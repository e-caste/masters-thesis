WEBVTT

00:00:00.000 --> 00:00:01.992
[SQUEAKING]

00:00:01.992 --> 00:00:03.486
[RUSTLING]

00:00:03.486 --> 00:00:06.474
[CLICKING]

00:00:24.930 --> 00:00:26.770
MICHAEL SIPSER: Welcome back.

00:00:26.770 --> 00:00:28.680
I hope you had a
good Thanksgiving

00:00:28.680 --> 00:00:36.300
and all refreshed
and ready to think

00:00:36.300 --> 00:00:38.550
about some theory
of computation.

00:00:38.550 --> 00:00:41.310
We're in the homestretch now.

00:00:41.310 --> 00:00:44.130
We have this lecture
and two more to go.

00:00:44.130 --> 00:00:53.880
And so today, I have for you,
a completion of the theorem

00:00:53.880 --> 00:01:02.370
we started before the
break, where we introduced

00:01:02.370 --> 00:01:09.570
probabilistic computation and
we talked about the class BPP,

00:01:09.570 --> 00:01:13.200
as I hope you remember, and
we looked, in particular,

00:01:13.200 --> 00:01:20.640
at these problems involving
branching programs, where

00:01:20.640 --> 00:01:27.630
we started the proof that the
problem of equivalence of two

00:01:27.630 --> 00:01:32.160
read-once branching programs
can be solved in this class BPP.

00:01:32.160 --> 00:01:36.120
So what I'm going to do is
spend the first 15 minutes

00:01:36.120 --> 00:01:41.440
or so just reviewing where we
were, because we started this,

00:01:41.440 --> 00:01:43.360
it feels like a
long time ago now.

00:01:43.360 --> 00:01:47.790
And I just want to make
sure that you're all

00:01:47.790 --> 00:01:52.290
on the same page and we're all
remembering what we were doing.

00:01:52.290 --> 00:01:55.200
And then, I will
finish off the proof.

00:01:55.200 --> 00:01:58.110
And along with doing
that, we're going

00:01:58.110 --> 00:02:01.350
to introduce an
important method.

00:02:01.350 --> 00:02:02.340
Well, we started that.

00:02:02.340 --> 00:02:05.620
We looked at the method of
arithmetization last time.

00:02:05.620 --> 00:02:07.890
So we'll review that.

00:02:07.890 --> 00:02:13.980
We're going to use
that again in the work

00:02:13.980 --> 00:02:16.590
that we're going to start on
Thursday on interactive proof

00:02:16.590 --> 00:02:17.340
systems.

00:02:17.340 --> 00:02:19.840
So this is a kind
of, in some ways,

00:02:19.840 --> 00:02:23.700
both an interesting theorem in
its own right, and a warm up

00:02:23.700 --> 00:02:30.540
for what we're going to
be doing in the last topic

00:02:30.540 --> 00:02:34.020
of the semester.

00:02:34.020 --> 00:02:36.600
OK.

00:02:36.600 --> 00:02:42.910
So let's just remember
what we were doing.

00:02:42.910 --> 00:02:47.860
So we introduced
probabilistic Turing machines.

00:02:47.860 --> 00:02:51.240
So those are these
machines that have--

00:02:51.240 --> 00:02:53.100
a kind of
non-deterministic machine,

00:02:53.100 --> 00:02:56.130
but there's a different
rule for acceptance.

00:02:56.130 --> 00:02:59.760
And these are also
non-deterministic machines

00:02:59.760 --> 00:03:03.000
which can either
make one choice, just

00:03:03.000 --> 00:03:05.460
to have a deterministic
move at a step,

00:03:05.460 --> 00:03:07.710
or they can make two choices.

00:03:07.710 --> 00:03:09.610
And when the machine
makes two choices,

00:03:09.610 --> 00:03:12.420
we actually think of there
being a probability there,

00:03:12.420 --> 00:03:14.190
where the machine
is tossing a coin

00:03:14.190 --> 00:03:17.980
to decide which branch to go on.

00:03:17.980 --> 00:03:22.650
So with that, there is a
tree of possible branches.

00:03:22.650 --> 00:03:25.170
And the probability of
some particular branch

00:03:25.170 --> 00:03:28.260
is going to be 1 over
2 to the number of coin

00:03:28.260 --> 00:03:31.080
tosses on that branch.

00:03:31.080 --> 00:03:35.730
And so we then use that
to define the probability

00:03:35.730 --> 00:03:38.400
that the machine
accepts, which is

00:03:38.400 --> 00:03:40.080
the sum over all of
the probabilities

00:03:40.080 --> 00:03:41.910
of the accepting branches.

00:03:41.910 --> 00:03:43.890
And the probability
that it rejects

00:03:43.890 --> 00:03:45.960
is 1 minus the probability
that it accepts.

00:03:49.170 --> 00:03:52.710
So thinking about it--

00:03:52.710 --> 00:03:57.510
this captures the
idea that if you just

00:03:57.510 --> 00:04:07.120
run the machine on a random set
of inputs from the coin tosses,

00:04:07.120 --> 00:04:09.190
what the probability that
you're going to end up

00:04:09.190 --> 00:04:11.020
with the machine accepting.

00:04:11.020 --> 00:04:14.020
That's the probability
of acceptance,

00:04:14.020 --> 00:04:16.958
defined in that way.

00:04:16.958 --> 00:04:19.000
Now, if we're thinking
about the machine deciding

00:04:19.000 --> 00:04:21.940
some particular
language, it's supposed

00:04:21.940 --> 00:04:23.590
to accept the strings
in the language

00:04:23.590 --> 00:04:26.050
and reject the strings which
are not in the language.

00:04:26.050 --> 00:04:28.450
But because of the probabilistic
nature of the machine,

00:04:28.450 --> 00:04:31.270
it might get the wrong
answer on some branches.

00:04:31.270 --> 00:04:33.860
And so we say that
a machine decides

00:04:33.860 --> 00:04:36.280
a language with a certain
error probability,

00:04:36.280 --> 00:04:39.160
means that the probability
of getting the wrong answer

00:04:39.160 --> 00:04:41.860
is going to be, at most,
that error probability

00:04:41.860 --> 00:04:45.730
epsilon over all of the
possible inputs to the machine.

00:04:45.730 --> 00:04:48.660
So if we say that the machine
is error probability 1/3

00:04:48.660 --> 00:04:53.130
that means that it gets the
right answer for every string

00:04:53.130 --> 00:04:54.900
with probability at least 2/3.

00:04:59.040 --> 00:05:03.600
OK, so that led us to the
definition of this complexity

00:05:03.600 --> 00:05:06.750
class BPP, which I don't
even remember if I told you

00:05:06.750 --> 00:05:07.690
what it stands for.

00:05:07.690 --> 00:05:11.280
It's bounded probabilistic
polynomial time.

00:05:11.280 --> 00:05:12.900
That's what BPP stands for.

00:05:16.050 --> 00:05:18.740
The "bounded" means is
bounded away from 1/2

00:05:18.740 --> 00:05:20.490
because we don't want
to allow the machine

00:05:20.490 --> 00:05:26.238
to have probability 1/2,
because then bad things happen.

00:05:26.238 --> 00:05:27.780
The machine can just
toss a coin when

00:05:27.780 --> 00:05:31.680
it decides to make
an answer, and not

00:05:31.680 --> 00:05:35.940
really give us any information.

00:05:35.940 --> 00:05:41.370
Then, we also went over
the amplification lemma.

00:05:41.370 --> 00:05:42.780
We did not give
the proof, but we

00:05:42.780 --> 00:05:44.405
went over the statement
of the theorem.

00:05:44.405 --> 00:05:46.680
The proof is really
just a calculation

00:05:46.680 --> 00:05:50.340
that you can drive down that
error probability to something

00:05:50.340 --> 00:05:55.650
extremely tiny just by
basically repeating the machine

00:05:55.650 --> 00:05:58.260
and taking the majority
vote of what it

00:05:58.260 --> 00:06:00.630
does on several different runs.

00:06:00.630 --> 00:06:03.210
If you run the machine
100 times and you

00:06:03.210 --> 00:06:06.150
see if it's mostly accepting,
then you want to accept.

00:06:06.150 --> 00:06:10.170
And the chances that the
machine was really biased

00:06:10.170 --> 00:06:11.850
toward rejecting,
even though you're

00:06:11.850 --> 00:06:15.120
in your sample see mostly
acceptance, is extremely small.

00:06:15.120 --> 00:06:17.820
And you can calculate that, but
you can make that very tiny.

00:06:17.820 --> 00:06:20.440
So small that, for all
practical purposes,

00:06:20.440 --> 00:06:22.870
it's really giving
you the right answer.

00:06:22.870 --> 00:06:24.270
But it's not deterministic.

00:06:24.270 --> 00:06:27.414
So it's not quite
100% guaranteed.

00:06:30.080 --> 00:06:35.930
And the way I like
to think about BPP

00:06:35.930 --> 00:06:39.350
in terms of the computation
tree of the machine,

00:06:39.350 --> 00:06:43.010
so that when it's accepting,
most of the branches

00:06:43.010 --> 00:06:48.150
are accepting, weighted by
their probability, of course.

00:06:48.150 --> 00:06:52.160
So the there are many accepting
branches when you're accepting,

00:06:52.160 --> 00:06:55.580
and many rejecting branches
when you're rejecting.

00:06:55.580 --> 00:06:59.470
So just another way of
saying the same thing.

00:06:59.470 --> 00:07:04.120
Now, we're going to jump
right in with a check-in.

00:07:04.120 --> 00:07:07.780
And this is a little bit
more, not exactly the material

00:07:07.780 --> 00:07:11.140
of the course, but a little bit
more on the philosophical side.

00:07:11.140 --> 00:07:15.420
But let's just see
how you do with it.

00:07:15.420 --> 00:07:20.060
When you're actually running
a probabilistic machine,

00:07:20.060 --> 00:07:22.220
you imagine the
machine, as we're

00:07:22.220 --> 00:07:27.330
kind of informally describing
it, is tossing coins.

00:07:27.330 --> 00:07:30.000
Every time it has a
non-deterministic--

00:07:30.000 --> 00:07:32.790
every time it has a choice.

00:07:32.790 --> 00:07:35.370
So it choice tosses a coin
to decide which way to go.

00:07:35.370 --> 00:07:40.260
Of course, a real computer
does not have a coin to toss,

00:07:40.260 --> 00:07:40.920
presumably.

00:07:40.920 --> 00:07:43.860
Well, maybe you might
actually build some hardware

00:07:43.860 --> 00:07:46.110
into the machine
that lets it access

00:07:46.110 --> 00:07:47.580
randomness in some sense.

00:07:47.580 --> 00:07:51.510
Maybe it uses some
quantum mechanical effect

00:07:51.510 --> 00:07:56.160
to get some random value
or maybe it uses the timer.

00:07:56.160 --> 00:07:57.600
I'm not exactly sure.

00:07:57.600 --> 00:08:02.370
You can imagine having a bunch
of ways of implementing that.

00:08:02.370 --> 00:08:06.510
A typical way that people
implement randomness

00:08:06.510 --> 00:08:10.170
in an algorithm is to use
a pseudo random number

00:08:10.170 --> 00:08:14.250
generator, which is a
procedure that might give you

00:08:14.250 --> 00:08:19.140
some kind of a value that looks
random, but may not actually

00:08:19.140 --> 00:08:20.850
be random.

00:08:20.850 --> 00:08:25.740
It's, for example, giving
you the digits of pi.

00:08:25.740 --> 00:08:34.470
If you want binary, expressing
pi as a binary number,

00:08:34.470 --> 00:08:37.740
then you might calculate the
different successive digits

00:08:37.740 --> 00:08:42.237
of pi and use that as for
your random number generator.

00:08:42.237 --> 00:08:44.070
Of course, that's a
deterministic procedure,

00:08:44.070 --> 00:08:47.220
so it's not really random.

00:08:47.220 --> 00:08:50.400
But often, people do use
those kinds of things

00:08:50.400 --> 00:08:52.530
when they're simulating
random machines.

00:08:52.530 --> 00:08:54.990
So what do you think
about doing that?

00:08:54.990 --> 00:08:59.400
Could we use a pseudo
random generator

00:08:59.400 --> 00:09:02.696
as the source of randomness
for our randomized algorithm?

00:09:06.190 --> 00:09:10.060
Yes, or no, or
what do you think?

00:09:10.060 --> 00:09:12.970
So let's launch a poll on
that, so I can see what

00:09:12.970 --> 00:09:16.240
your opinion about using
pseudo random number

00:09:16.240 --> 00:09:20.530
generators instead of true
randomness for our algorithms.

00:09:23.320 --> 00:09:28.420
I'll give you a few seconds,
a minute to weigh in on that.

00:09:31.400 --> 00:09:32.388
OK.

00:09:32.388 --> 00:09:33.680
We're going to close this down.

00:09:33.680 --> 00:09:37.880
Everybody's participated
who wants to?

00:09:37.880 --> 00:09:38.495
1, 2, 3.

00:09:41.530 --> 00:09:43.700
OK.

00:09:43.700 --> 00:09:49.610
Yeah, I think probably the best
answer is A. Let's take a look.

00:09:49.610 --> 00:09:52.370
There were a couple of answers
here that, really, that

00:09:52.370 --> 00:09:53.360
don't make--

00:09:53.360 --> 00:09:54.500
that aren't as good.

00:09:54.500 --> 00:09:57.830
I would say, B,
well, usually people

00:09:57.830 --> 00:09:59.630
think of pseudo
random generators

00:09:59.630 --> 00:10:01.790
as pretty fast procedures.

00:10:01.790 --> 00:10:03.830
They're not that
interesting, otherwise.

00:10:03.830 --> 00:10:06.590
So I wouldn't say that
B is a good choice

00:10:06.590 --> 00:10:13.070
because they're usually
pretty quick to implement.

00:10:13.070 --> 00:10:18.410
C is a worse choice, even,
because Turing machines

00:10:18.410 --> 00:10:20.630
can do anything that any
other algorithm can do.

00:10:20.630 --> 00:10:23.167
So, certainly, if
there is such a thing

00:10:23.167 --> 00:10:25.250
as a pseudo random number
generator, and there is,

00:10:25.250 --> 00:10:29.930
then you could implement
it on the Turing machine.

00:10:29.930 --> 00:10:31.970
D is kind of an
interesting answer

00:10:31.970 --> 00:10:35.240
because you're saying, well,
that would imply that P equals

00:10:35.240 --> 00:10:39.260
BPP if you could actually
simulate randomness

00:10:39.260 --> 00:10:42.350
with a deterministic procedure.

00:10:42.350 --> 00:10:46.310
But in fact, the reason
I would not choose D

00:10:46.310 --> 00:10:48.830
is because it's
perfectly conceivable

00:10:48.830 --> 00:10:51.740
that P does equal BPP.

00:10:51.740 --> 00:10:53.870
We don't know that P
is different from BPP,

00:10:53.870 --> 00:10:56.190
so it's conceivable
that they're equal.

00:10:56.190 --> 00:11:00.770
And in fact, I think if
you polled most complexity

00:11:00.770 --> 00:11:06.200
theorists, most
people in my field

00:11:06.200 --> 00:11:11.930
would believe that P does equal
BPP just for this very reason,

00:11:11.930 --> 00:11:15.320
that if you had sufficiently
good pseudo random number

00:11:15.320 --> 00:11:18.200
generators, you could
actually eliminate

00:11:18.200 --> 00:11:21.230
the probabalism in these
probabilistic computations.

00:11:21.230 --> 00:11:23.900
You could just run them on the
pseudo random number generator.

00:11:23.900 --> 00:11:27.410
And in fact, there is
some theory around that

00:11:27.410 --> 00:11:29.540
that has been developed.

00:11:29.540 --> 00:11:31.970
But at the present
time, we do not

00:11:31.970 --> 00:11:35.060
know how to prove that there
were pseudo random number

00:11:35.060 --> 00:11:35.630
generators.

00:11:35.630 --> 00:11:37.323
And it has some,
actually, there's

00:11:37.323 --> 00:11:38.990
actually, in some
line of this research,

00:11:38.990 --> 00:11:41.310
has some connection with
the P versus NP problem,

00:11:41.310 --> 00:11:43.190
but we don't know how
to prove that there

00:11:43.190 --> 00:11:46.490
are sufficiently good pseudo
random number generators that

00:11:46.490 --> 00:11:50.960
would allow you to run them
on a probabilistic algorithm

00:11:50.960 --> 00:11:54.020
and have a guaranteed behavior
which is as good as running

00:11:54.020 --> 00:12:00.060
truly random numbers into
the probabilistic algorithm.

00:12:00.060 --> 00:12:02.510
And so the answer
that I would pick

00:12:02.510 --> 00:12:04.767
would be A, that you
could use it, sure.

00:12:04.767 --> 00:12:07.100
You might get the right answer,
but it's not guaranteed.

00:12:07.100 --> 00:12:09.170
We just don't know
how to do the analysis

00:12:09.170 --> 00:12:11.120
for the pseudo random
number generators.

00:12:11.120 --> 00:12:14.460
And if you had ones
that were good enough,

00:12:14.460 --> 00:12:17.300
they would show P
is equal to BPP.

00:12:17.300 --> 00:12:20.360
But that might be, in
fact, the correct--

00:12:20.360 --> 00:12:23.180
that might actually be true.

00:12:23.180 --> 00:12:26.710
OK, so let's continue on.

00:12:26.710 --> 00:12:31.450
And remember, now,
branching programs.

00:12:31.450 --> 00:12:37.330
We had these kind of
networks of nodes and edges.

00:12:37.330 --> 00:12:40.012
And there was a procedure,
we'll see a couple of examples

00:12:40.012 --> 00:12:41.470
again, some of the
ones that we had

00:12:41.470 --> 00:12:45.310
from before where
you have branching

00:12:45.310 --> 00:12:47.770
programs that look like this.

00:12:47.770 --> 00:12:50.350
And you have a bunch
of query nodes.

00:12:50.350 --> 00:12:52.900
You look at the settings
of the variables

00:12:52.900 --> 00:12:56.075
to decide whether to go
down to 0 edge or a 1 edge.

00:12:56.075 --> 00:12:58.450
And eventually, you're going
to end up at an output node,

00:12:58.450 --> 00:13:00.730
and that's going
to be the output

00:13:00.730 --> 00:13:01.930
of the branching program.

00:13:01.930 --> 00:13:03.880
And in such a way,
these branching programs

00:13:03.880 --> 00:13:07.000
defined Boolean functions,
from the settings of the input

00:13:07.000 --> 00:13:10.780
variables to a 0 or 1 output.

00:13:10.780 --> 00:13:13.210
Now, you might have
two branching programs

00:13:13.210 --> 00:13:15.550
and wonder whether they're
computing the same Boolean

00:13:15.550 --> 00:13:16.640
function or not.

00:13:16.640 --> 00:13:20.320
And testing that is a
coNP complete problem,

00:13:20.320 --> 00:13:22.300
as you're asked to
show on your homework.

00:13:26.010 --> 00:13:30.210
Now, if the branching program,
however, has a restriction,

00:13:30.210 --> 00:13:34.260
namely, that it's
not allowed to ask

00:13:34.260 --> 00:13:38.520
to query the same variable
more than once on a path,

00:13:38.520 --> 00:13:45.180
then with that restriction, we
call it a read-once branching

00:13:45.180 --> 00:13:47.090
program.

00:13:47.090 --> 00:13:50.570
And then, the situation
for testing equivalence

00:13:50.570 --> 00:13:52.320
seems to be different.

00:13:52.320 --> 00:13:54.950
In fact, we can
give a BPP algorithm

00:13:54.950 --> 00:13:58.460
for testing the equivalence of
read-once branching programs,

00:13:58.460 --> 00:14:00.470
even though such a
thing is unlikely to be

00:14:00.470 --> 00:14:03.770
the case for general branching
programs because of the coNP

00:14:03.770 --> 00:14:06.090
completeness.

00:14:06.090 --> 00:14:08.520
OK, so I hope you're
comfortable and with me

00:14:08.520 --> 00:14:09.720
on all of that reasoning.

00:14:15.920 --> 00:14:16.420
OK.

00:14:27.650 --> 00:14:28.150
All right.

00:14:28.150 --> 00:14:31.570
So the idea for proving this
is, what we're going to do

00:14:31.570 --> 00:14:33.580
is we want to take the
two branching programs

00:14:33.580 --> 00:14:36.400
and run them on a
randomly-selected input.

00:14:36.400 --> 00:14:39.160
But as we observed
last time, if you just

00:14:39.160 --> 00:14:42.250
run them on a
randomly-selected Boolean input

00:14:42.250 --> 00:14:44.710
where we assign the
variable 0s and 1s,

00:14:44.710 --> 00:14:47.620
then that doesn't give
you the right answer

00:14:47.620 --> 00:14:51.190
with high probability, because
the two branching programs

00:14:51.190 --> 00:14:54.700
might be different, computing
different Boolean functions,

00:14:54.700 --> 00:14:57.790
but they differ only on
a single input setting.

00:14:57.790 --> 00:15:01.010
And then, just picking
them at random,

00:15:01.010 --> 00:15:03.910
you're not going to have a very
high probability of finding

00:15:03.910 --> 00:15:06.740
that one place of difference.

00:15:06.740 --> 00:15:10.480
So instead, what we're going to
do is define a way to run these

00:15:10.480 --> 00:15:13.510
branching programs on
non-Boolean inputs,

00:15:13.510 --> 00:15:17.599
where the variables are set
to values other than 0 and 1--

00:15:17.599 --> 00:15:20.470
2, 3, 7, 22--

00:15:20.470 --> 00:15:22.100
and make sense of that.

00:15:22.100 --> 00:15:26.860
And then argue that, by running
the two branching programs

00:15:26.860 --> 00:15:30.980
on a randomly-selected
non-Boolean input,

00:15:30.980 --> 00:15:33.500
that that's very
high probability

00:15:33.500 --> 00:15:36.750
of giving you the right answer.

00:15:36.750 --> 00:15:40.220
So somehow, by expanding
the domain of possibilities,

00:15:40.220 --> 00:15:43.520
you're going to
better your chance

00:15:43.520 --> 00:15:47.500
of getting the right
answer very significantly.

00:15:47.500 --> 00:15:48.000
OK.

00:15:48.000 --> 00:15:50.160
So even though these
two branching programs

00:15:50.160 --> 00:15:56.040
might agree on almost all
of the Boolean inputs,

00:15:56.040 --> 00:16:00.992
we're going to show that by
doing this arithmetization--

00:16:00.992 --> 00:16:01.950
so this is the method--

00:16:05.330 --> 00:16:08.000
if they're really
not equivalent,

00:16:08.000 --> 00:16:11.180
they're going to differ
almost all of the time

00:16:11.180 --> 00:16:13.368
on the expanded domain.

00:16:13.368 --> 00:16:14.660
OK, and then we have the proof.

00:16:18.870 --> 00:16:23.200
That's where today's
work is going to be.

00:16:23.200 --> 00:16:24.160
OK.

00:16:24.160 --> 00:16:29.260
So why don't we
just stop and make

00:16:29.260 --> 00:16:33.130
sure we're all together on this?

00:16:33.130 --> 00:16:36.470
I can take any questions.

00:16:36.470 --> 00:16:39.680
I'll also review how the
arithmetization goes.

00:16:39.680 --> 00:16:42.460
But I'll do that next.

00:16:42.460 --> 00:16:48.310
So, are we all OK on this?

00:16:48.310 --> 00:16:48.820
Good.

00:16:48.820 --> 00:16:51.860
So let's move on.

00:16:51.860 --> 00:16:55.090
So in order to move
toward understanding

00:16:55.090 --> 00:16:57.970
what it means to run
the branching programs

00:16:57.970 --> 00:17:01.000
on these non-Boolean
values, we're

00:17:01.000 --> 00:17:05.859
going to have to get a
somewhat different perspective

00:17:05.859 --> 00:17:09.310
on the computation of
a branching program.

00:17:09.310 --> 00:17:16.810
So the standard perspective
is that you take your setting,

00:17:16.810 --> 00:17:19.180
your assignment to
the input, which

00:17:19.180 --> 00:17:26.500
is 0,1,1 for x1, x2, and x3, and
use that to follow an execution

00:17:26.500 --> 00:17:29.350
path through the machine.

00:17:29.350 --> 00:17:32.470
So we know x1 is 0,
x2 is 1, x3 is 1,

00:17:32.470 --> 00:17:35.770
the output is 1, as I've
indicated in yellow.

00:17:38.800 --> 00:17:41.620
This other perspective
says, well, we're

00:17:41.620 --> 00:17:46.550
going to operate by labeling the
nodes and edges of the machine.

00:17:46.550 --> 00:17:52.050
And that's going to have a
very direct correspondence

00:17:52.050 --> 00:17:54.850
with the execution
path perspective.

00:17:54.850 --> 00:17:57.930
So we're going to label all of
the nodes and edges on the path

00:17:57.930 --> 00:18:01.290
with a 1, as
indicated in yellow,

00:18:01.290 --> 00:18:03.810
and all of the nodes
and edges that are not

00:18:03.810 --> 00:18:05.670
on the path, all the
other nodes and edges

00:18:05.670 --> 00:18:06.753
are going to be labeled 0.

00:18:10.950 --> 00:18:14.610
So by following the 1s,
it's like the breadcrumbs

00:18:14.610 --> 00:18:16.320
in Hansel and Gretel.

00:18:16.320 --> 00:18:18.420
This is the path
you need to follow

00:18:18.420 --> 00:18:22.410
to get through the machine.

00:18:22.410 --> 00:18:24.270
The 0s are the places
where you don't go.

00:18:27.400 --> 00:18:30.850
OK, so the output
label, here, the output

00:18:30.850 --> 00:18:34.775
is going to be the label of
the one output node, whatever

00:18:34.775 --> 00:18:35.650
you're labeling that.

00:18:35.650 --> 00:18:39.017
Because if it's a 1, that
means the path went to the 1,

00:18:39.017 --> 00:18:41.350
and if it's a 0, that means
the path didn't go to the 1,

00:18:41.350 --> 00:18:43.880
it went to the 0.

00:18:43.880 --> 00:18:45.690
So just by looking
at this value,

00:18:45.690 --> 00:18:50.020
you can see what the
output of the machine is.

00:18:50.020 --> 00:18:50.590
All right.

00:18:50.590 --> 00:18:56.110
So let's describe
a different way

00:18:56.110 --> 00:18:59.530
of defining this
labeling without just

00:18:59.530 --> 00:19:01.880
looking at the path.

00:19:01.880 --> 00:19:04.060
Well, it's going to capture
exactly the same thing.

00:19:07.460 --> 00:19:16.310
So we're going to say, if
you've already labeled a node,

00:19:16.310 --> 00:19:18.410
I'll tell you how to
label the two edges that

00:19:18.410 --> 00:19:19.640
emanate from that node.

00:19:23.830 --> 00:19:29.440
I'm going to label the one
edge a and the query variable.

00:19:29.440 --> 00:19:30.700
Why is that?

00:19:30.700 --> 00:19:35.683
Well, a is going to
be either a 0 or 1.

00:19:35.683 --> 00:19:37.350
And it's going to
tell us whether or not

00:19:37.350 --> 00:19:40.720
the path entered that node.

00:19:40.720 --> 00:19:43.050
So if it's a 1, it
entered that node, if 0,

00:19:43.050 --> 00:19:44.340
it didn't enter that node.

00:19:44.340 --> 00:19:47.010
The only way it's going
to go down this branch

00:19:47.010 --> 00:19:52.195
here is if it did
enter the xi node.

00:19:52.195 --> 00:19:53.820
If it didn't enter
the xi node, there's

00:19:53.820 --> 00:19:55.960
no way it can go
down this branch.

00:19:55.960 --> 00:19:59.510
So we're going to
and that value.

00:19:59.510 --> 00:20:02.890
So the only way you
can go down this branch

00:20:02.890 --> 00:20:05.180
is if it went
through that node--

00:20:05.180 --> 00:20:07.480
so that's the a,
the value of a--

00:20:07.480 --> 00:20:10.300
and the xi is a 1.

00:20:10.300 --> 00:20:12.378
That's why we say a and xi.

00:20:12.378 --> 00:20:14.920
So you really have to understand
this little expression here.

00:20:14.920 --> 00:20:18.680
If you don't understand
that, you're toast.

00:20:18.680 --> 00:20:21.140
OK, so you better understand
this so we can move forward.

00:20:21.140 --> 00:20:22.460
I'm happy to take a question.

00:20:22.460 --> 00:20:24.377
These are the simplest
questions are sometimes

00:20:24.377 --> 00:20:25.772
the most valuable.

00:20:25.772 --> 00:20:27.980
If you don't understand why
I'm labeling it this way,

00:20:27.980 --> 00:20:29.420
shoot me a chat.

00:20:32.020 --> 00:20:32.520
OK.

00:20:32.520 --> 00:20:35.680
Now, the other branch,
I'm going to say,

00:20:35.680 --> 00:20:40.730
well, I'm only going to go down
this edge if, well, a is true,

00:20:40.730 --> 00:20:42.420
so I did go through that node.

00:20:42.420 --> 00:20:44.980
And xi is false.

00:20:44.980 --> 00:20:49.430
So this is going to be a
and the complement of xi.

00:20:49.430 --> 00:20:49.930
All right.

00:20:49.930 --> 00:20:51.555
So that's how I'm
going to label these.

00:20:51.555 --> 00:20:55.490
This is another way,
giving these expressions

00:20:55.490 --> 00:20:59.060
for labeling these edges based
on the label of that node.

00:20:59.060 --> 00:21:01.880
And similarly, in order
to complete the picture,

00:21:01.880 --> 00:21:04.130
I've got to tell you how
to label the nodes based

00:21:04.130 --> 00:21:06.150
on the edges that
are coming into it.

00:21:06.150 --> 00:21:08.750
So if I know that I have
a1, a2, and a3, which

00:21:08.750 --> 00:21:15.050
tell me the status in terms of
the path of whether the path

00:21:15.050 --> 00:21:17.810
went through any of
these edges, well,

00:21:17.810 --> 00:21:19.580
I know that it's going
to go to that node

00:21:19.580 --> 00:21:24.497
if the or of these values--

00:21:24.497 --> 00:21:26.830
if the path went through here,
or it went through there,

00:21:26.830 --> 00:21:30.080
or went through there, then
it's going to go to that node.

00:21:30.080 --> 00:21:32.380
That's why the or is
the right thing to say.

00:21:32.380 --> 00:21:35.260
So this gives me another
way of constructing

00:21:35.260 --> 00:21:40.800
the labeling over here without
even talking about paths.

00:21:40.800 --> 00:21:42.720
As I describe it,
I argue that it's

00:21:42.720 --> 00:21:46.320
going to give the same
result. All right.

00:21:50.223 --> 00:21:51.140
So there's a question.

00:21:51.140 --> 00:21:53.875
Can we quickly say again why
we can't do that on Boolean?

00:21:53.875 --> 00:21:55.500
I'm not sure I
understand the question.

00:21:55.500 --> 00:21:57.110
So send it to me again.

00:21:57.110 --> 00:21:58.700
Right now, everything
is Boolean.

00:21:58.700 --> 00:22:03.063
We haven't done,
arithmetically, anything yet.

00:22:03.063 --> 00:22:05.480
And the reason why we can't
just live in the Boolean world

00:22:05.480 --> 00:22:10.250
is that, just by taking Boolean
values of Boolean assignments

00:22:10.250 --> 00:22:13.220
here, we don't have a
high enough probability

00:22:13.220 --> 00:22:15.950
of catching a difference
between the two machines.

00:22:20.640 --> 00:22:21.140
All right.

00:22:21.140 --> 00:22:21.890
So let's continue.

00:22:24.810 --> 00:22:25.470
All right.

00:22:25.470 --> 00:22:28.020
So now, I'm going
to talk about how

00:22:28.020 --> 00:22:33.150
we're going to extend this
to the non-Boolean case,

00:22:33.150 --> 00:22:35.530
using the
arithmetization method.

00:22:35.530 --> 00:22:38.730
So first of all, arithmetization
is a simulation of and and

00:22:38.730 --> 00:22:42.570
or with plus and times,
such that if I think

00:22:42.570 --> 00:22:50.280
about true as a 1
and false as a 0,

00:22:50.280 --> 00:22:52.590
this is going to give me
a faithful simulation.

00:22:52.590 --> 00:22:54.750
It's going to do
the right thing.

00:22:54.750 --> 00:22:57.930
It's going to compute exactly
the same values that we expect.

00:22:57.930 --> 00:23:04.200
So like a and b, well,
times works just like and.

00:23:08.970 --> 00:23:13.020
It does for 1 and 0
as true and false,

00:23:13.020 --> 00:23:16.410
times exactly works like and.

00:23:16.410 --> 00:23:21.230
And negation is 1 minus.

00:23:21.230 --> 00:23:26.360
Or is going to be the
sum minus the product.

00:23:26.360 --> 00:23:31.160
And then, these just give
you the right values, a or b.

00:23:31.160 --> 00:23:34.490
If you just calculate it
out by plugging in 1s or 0s,

00:23:34.490 --> 00:23:37.100
you get the right answer just
by using this arithmetic.

00:23:39.820 --> 00:23:43.630
So now, what we're going to do,
instead of using the Boolean

00:23:43.630 --> 00:23:45.880
labeling, we'll just use
the arithmetical labeling.

00:23:45.880 --> 00:23:48.640
But it's going to compute
exactly the same thing

00:23:48.640 --> 00:23:53.710
because the arithmetic
simulates the Boolean.

00:23:53.710 --> 00:23:56.900
So we always go
through the start node.

00:23:56.900 --> 00:24:00.400
So there's no question about
labeling the very start

00:24:00.400 --> 00:24:01.540
node with a 1.

00:24:01.540 --> 00:24:03.910
But now, I'm going to
give expressions just

00:24:03.910 --> 00:24:05.860
like the Boolean
expressions, but now they're

00:24:05.860 --> 00:24:09.490
going to use plus and times
instead of ands and ors.

00:24:09.490 --> 00:24:10.690
So let's just see.

00:24:10.690 --> 00:24:12.340
Remember what we
did from before.

00:24:12.340 --> 00:24:16.030
We had a and xi for this edge.

00:24:16.030 --> 00:24:17.170
I'm going to replace that.

00:24:17.170 --> 00:24:18.130
What is and?

00:24:18.130 --> 00:24:19.960
We just look up
here in our table,

00:24:19.960 --> 00:24:22.330
in our translation table.

00:24:22.330 --> 00:24:24.170
And becomes times.

00:24:24.170 --> 00:24:26.555
So we're going to replace
that with a times xi.

00:24:29.240 --> 00:24:31.470
And it's going to
work exactly the same.

00:24:31.470 --> 00:24:36.440
But the difference is that
this makes sense even when we

00:24:36.440 --> 00:24:39.380
have non-Boolean values.

00:24:39.380 --> 00:24:45.480
Times and plus are defined
for non-Boolean values,

00:24:45.480 --> 00:24:48.310
whereas ands and or are not.

00:24:48.310 --> 00:24:50.980
So what goes down on this edge?

00:24:50.980 --> 00:24:54.070
Well, this was a and
the complement of xi,

00:24:54.070 --> 00:24:56.530
as you remember.

00:24:56.530 --> 00:25:00.690
So that's going to become
a times 1 minus xi.

00:25:00.690 --> 00:25:04.662
And then similarly,
we had or over here.

00:25:04.662 --> 00:25:06.120
And here's a little
bit of a trick,

00:25:06.120 --> 00:25:09.540
but that's going to be
important for the analysis

00:25:09.540 --> 00:25:10.590
that we're going to do.

00:25:10.590 --> 00:25:17.310
Instead of using the recipe for
or in terms of plus and times,

00:25:17.310 --> 00:25:19.870
we're going to have
something a little simpler.

00:25:19.870 --> 00:25:21.450
It's just going to be the sum.

00:25:21.450 --> 00:25:23.730
And the reason why that works--

00:25:23.730 --> 00:25:28.830
good to understand-- is that
because of the acyclic nature

00:25:28.830 --> 00:25:32.340
of the branching programs,
at most, one of these edges

00:25:32.340 --> 00:25:34.300
can have a path through it.

00:25:34.300 --> 00:25:35.970
So this is a kind
of very special

00:25:35.970 --> 00:25:40.520
or, sometimes called
the disjoint or.

00:25:40.520 --> 00:25:44.810
You're not allowed to have more
than one of the values be 1,

00:25:44.810 --> 00:25:47.810
because that never happens when
you have an acyclical graph.

00:25:47.810 --> 00:25:50.360
You can never have the path
coming down this way, and then,

00:25:50.360 --> 00:25:51.710
again, coming down that way.

00:25:51.710 --> 00:25:53.630
Then it would be
entering that node twice.

00:25:53.630 --> 00:25:55.630
Have to be a cycle.

00:25:55.630 --> 00:25:57.610
So it's going to be
good enough for us,

00:25:57.610 --> 00:26:04.420
and necessary for us to
represent this or as a sum.

00:26:04.420 --> 00:26:06.380
OK.

00:26:06.380 --> 00:26:10.520
So I think that's all I
wanted to say on this slide.

00:26:10.520 --> 00:26:12.640
So somebody is asking,
is it possible for some

00:26:12.640 --> 00:26:14.110
of these values to be negative?

00:26:14.110 --> 00:26:15.978
Yes.

00:26:15.978 --> 00:26:18.520
As it stands right now, some of
these values can be negative.

00:26:18.520 --> 00:26:20.062
I haven't put any
restriction on what

00:26:20.062 --> 00:26:22.790
the values are going to be.

00:26:22.790 --> 00:26:24.650
So the input could
be a negative number.

00:26:24.650 --> 00:26:27.730
And then, you're going to just
get negative stuff happening.

00:26:27.730 --> 00:26:30.860
In fact, there's
subtractions going on here.

00:26:30.860 --> 00:26:32.200
So even with positive numbers--

00:26:32.200 --> 00:26:33.700
I think we did an
example last time.

00:26:33.700 --> 00:26:36.760
I think I'm going to do that
example again of exclusive

00:26:36.760 --> 00:26:40.697
or, where you get negative
numbers coming up.

00:26:40.697 --> 00:26:41.530
That doesn't matter.

00:26:41.530 --> 00:26:43.840
But actually, what we're
going to end up doing

00:26:43.840 --> 00:26:51.930
is doing these calculations
modulo some prime number q.

00:26:51.930 --> 00:26:52.830
OK.

00:26:52.830 --> 00:26:55.620
I'm going to pick
some prime like 17,

00:26:55.620 --> 00:26:58.530
and do all the
calculations mod 17.

00:26:58.530 --> 00:27:00.270
And the reason for
doing it that way

00:27:00.270 --> 00:27:03.330
is really because we're going
to be picking random assignments

00:27:03.330 --> 00:27:07.110
to the variables as our input.

00:27:07.110 --> 00:27:10.920
And it makes the most
sense to do that when

00:27:10.920 --> 00:27:15.970
you have a finite set of
possibilities to pick them up.

00:27:15.970 --> 00:27:18.390
So we're not going to pick
like a random integer.

00:27:18.390 --> 00:27:20.130
There's infinitely
many possibilities.

00:27:20.130 --> 00:27:22.200
And yeah, you could set
up a distribution there,

00:27:22.200 --> 00:27:23.670
but that's very complicated.

00:27:23.670 --> 00:27:24.840
That actually might work.

00:27:24.840 --> 00:27:25.500
I'm not sure.

00:27:25.500 --> 00:27:27.570
I haven't actually gone
through that analysis.

00:27:27.570 --> 00:27:29.160
But the typical
way people do this

00:27:29.160 --> 00:27:31.560
is by looking at what's
called a finite field.

00:27:31.560 --> 00:27:35.140
So I'll talk about
that in a second.

00:27:35.140 --> 00:27:38.020
Why is there at most one
1 among a1, a2, and a3?

00:27:42.010 --> 00:27:45.610
The 1s-- I'll say once
again-- but the 1s correspond

00:27:45.610 --> 00:27:46.850
to the path.

00:27:46.850 --> 00:27:50.080
So this is a 1 if the
path went this way.

00:27:50.080 --> 00:27:51.250
Just think about it.

00:27:51.250 --> 00:27:56.170
The path cannot go through
a1 and can, at the same time,

00:27:56.170 --> 00:27:59.410
go through a2, because that
means the path went through

00:27:59.410 --> 00:28:00.430
this node.

00:28:00.430 --> 00:28:03.070
Then, how is it going
to get over to a2?

00:28:03.070 --> 00:28:05.540
It's going to go
through that node twice.

00:28:05.540 --> 00:28:08.960
In an acyclic graph, you cannot
have a path going through

00:28:08.960 --> 00:28:11.790
it's the same node
more than once.

00:28:11.790 --> 00:28:16.410
So you're going to have
to think about that.

00:28:16.410 --> 00:28:19.418
OK, let's move on.

00:28:19.418 --> 00:28:21.210
So now we're going to
talk about the same--

00:28:24.520 --> 00:28:28.500
we're going to look at that
non-Boolean labeling applied

00:28:28.500 --> 00:28:29.500
to an example.

00:28:29.500 --> 00:28:32.730
So here is a very
simple branching program

00:28:32.730 --> 00:28:34.320
that actually
computes the exclusive

00:28:34.320 --> 00:28:35.880
or function in
the Boolean world.

00:28:38.840 --> 00:28:41.440
So this is the
labeling that I just

00:28:41.440 --> 00:28:47.500
developed for you, the
arithmetical labeling.

00:28:47.500 --> 00:28:49.300
And we always label
the start node with 1,

00:28:49.300 --> 00:28:51.910
because the path always
goes through there.

00:28:51.910 --> 00:28:55.120
And now, let's look at this
before we jump ahead, let's

00:28:55.120 --> 00:28:57.970
look at this edge here.

00:28:57.970 --> 00:28:58.870
Remember what it is.

00:28:58.870 --> 00:29:00.490
We have to apply this rule here.

00:29:00.490 --> 00:29:02.620
This is the one edge
coming out of a node that

00:29:02.620 --> 00:29:04.630
already is labeled.

00:29:04.630 --> 00:29:08.803
So it's that label on
that node times the xi.

00:29:08.803 --> 00:29:11.220
Because if you're thinking
about it, that, that's the and,

00:29:11.220 --> 00:29:12.690
captures the and.

00:29:12.690 --> 00:29:15.330
So it's just a times xi.

00:29:15.330 --> 00:29:17.920
So it's x1, in this case.

00:29:17.920 --> 00:29:22.720
So x1 is a 2 in our input.

00:29:22.720 --> 00:29:25.110
So it's going to be
1, which is the a,

00:29:25.110 --> 00:29:26.760
times the x1, which is 2.

00:29:26.760 --> 00:29:31.630
So this edge gets labeled 2.

00:29:31.630 --> 00:29:33.730
Now this-- well, OK, let's
look at this edge now.

00:29:33.730 --> 00:29:35.710
I think that's next.

00:29:35.710 --> 00:29:38.770
This is the 1 minus xi,
it's the 1 minus x1.

00:29:38.770 --> 00:29:39.730
So it's 1 minus 2.

00:29:39.730 --> 00:29:41.438
So you're going to
end up with a minus 1.

00:29:41.438 --> 00:29:43.120
1 minus times minus 2.

00:29:43.120 --> 00:29:49.640
1 times 1 minus 2, which is
minus 1, so it's a minus 1.

00:29:49.640 --> 00:29:53.540
Now we're going to label these
two nodes using the other rule.

00:29:53.540 --> 00:29:56.450
So this gets a 2 because that's
a sum of the incoming edges.

00:29:56.450 --> 00:29:57.950
This gets a minus
1, because that's

00:29:57.950 --> 00:30:00.300
the sum of its incoming edges.

00:30:00.300 --> 00:30:01.895
And now we're going to look at--

00:30:06.920 --> 00:30:08.300
which order did I do this in?

00:30:08.300 --> 00:30:13.920
OK, I'm going to
do this edge now.

00:30:13.920 --> 00:30:20.550
0 edge, which is going to be
2 times 1 minus its variable.

00:30:20.550 --> 00:30:22.520
So it's 1 minus x2.

00:30:22.520 --> 00:30:24.870
X2 is a 3.

00:30:24.870 --> 00:30:28.260
So it's 1 minus 3 to minus 2.

00:30:28.260 --> 00:30:31.467
So 2 times minus 2 is minus 4.

00:30:31.467 --> 00:30:33.050
OK, I don't want to
rush through this.

00:30:33.050 --> 00:30:35.090
No point in just blabbering on.

00:30:35.090 --> 00:30:40.020
I'm just trying to work this
example so you get the idea.

00:30:40.020 --> 00:30:43.270
OK, so could you fill this
next one out yourself?

00:30:43.270 --> 00:30:48.330
So this is the one outgoing
edge from this x2 node.

00:30:48.330 --> 00:30:54.850
So x2 is labeled with 2 here.

00:30:54.850 --> 00:30:56.670
So there's a is 2.

00:30:56.670 --> 00:30:59.890
This is the one edge going out,
so it's one on this side here.

00:30:59.890 --> 00:31:06.780
So it's 2 times the x2. x2
is a 3, so it's 2 times 3.

00:31:06.780 --> 00:31:08.310
So this should be 6.

00:31:08.310 --> 00:31:10.290
Oops.

00:31:10.290 --> 00:31:13.230
Right here-- 6.

00:31:13.230 --> 00:31:14.880
I'm going to do the same thing.

00:31:14.880 --> 00:31:17.090
So x2 is labeled minus 1.

00:31:22.130 --> 00:31:23.570
So minus 1 times 1 minus.

00:31:23.570 --> 00:31:27.410
So you get a 2 here,
you get a minus 3 here,

00:31:27.410 --> 00:31:30.920
just following, again,
the same process.

00:31:30.920 --> 00:31:35.050
And now, what is the
label on this 0 node here?

00:31:35.050 --> 00:31:38.660
So again, you take the sum
of its incoming labels.

00:31:38.660 --> 00:31:42.410
So there was a 2 and a 6.

00:31:42.410 --> 00:31:44.280
So that's an 8.

00:31:44.280 --> 00:31:50.420
And this is a a minus 3
and a minus 4 coming in.

00:31:50.420 --> 00:31:51.670
So it's a minus 7.

00:31:51.670 --> 00:31:53.320
What's the output?

00:31:53.320 --> 00:31:57.690
The output is minus 7, because
that's the label on the 1 node.

00:31:57.690 --> 00:31:59.850
OK, output is minus 7.

00:31:59.850 --> 00:32:01.230
OK.

00:32:01.230 --> 00:32:06.990
So this is going to
be our way of defining

00:32:06.990 --> 00:32:11.700
the output of a
branching program when

00:32:11.700 --> 00:32:15.800
it has a non-Boolean
setting on its inputs.

00:32:15.800 --> 00:32:18.710
If you had the Boolean
setting on its inputs

00:32:18.710 --> 00:32:21.605
and you followed this procedure,
what would you get out?

00:32:25.640 --> 00:32:27.410
You would get the
same answer that you

00:32:27.410 --> 00:32:30.750
would get by following
the path because

00:32:30.750 --> 00:32:35.990
the arithmetical simulation
is a faithful simulation

00:32:35.990 --> 00:32:37.010
of the ands and ors.

00:32:37.010 --> 00:32:38.630
And the ands and
ors capture exactly

00:32:38.630 --> 00:32:39.890
when-- what the path does.

00:32:42.410 --> 00:32:46.910
So this is a strict
extension of the operation

00:32:46.910 --> 00:32:49.640
of the branching program
into a new realm,

00:32:49.640 --> 00:32:51.410
these non-Boolean values.

00:32:51.410 --> 00:32:55.230
On the old realm, it behaves
just as it did originally.

00:32:55.230 --> 00:32:57.650
And that's critical
to understand that.

00:33:03.788 --> 00:33:06.080
Yeah, somebody's asking what
the final value of the 0s,

00:33:06.080 --> 00:33:07.080
they'd also be the same.

00:33:07.080 --> 00:33:08.150
Sure.

00:33:08.150 --> 00:33:12.860
In the Boolean case, if we
follow this in the Boolean

00:33:12.860 --> 00:33:17.330
cases, all of the labels would
be exactly what they were.

00:33:17.330 --> 00:33:21.995
They would just be the 0s and
1s that we had from before.

00:33:28.820 --> 00:33:34.605
So does this exactly mimic x
or if you take this all mod 2?

00:33:38.900 --> 00:33:39.540
I don't know.

00:33:39.540 --> 00:33:40.820
I'd have to think about that.

00:33:40.820 --> 00:33:43.370
I don't think that
that's essential.

00:33:43.370 --> 00:33:45.530
In this case, it
might behave correctly

00:33:45.530 --> 00:33:48.380
if you take the
answer mod 2 for XOR.

00:33:48.380 --> 00:33:50.150
But the XOR is going
to be very special.

00:33:50.150 --> 00:33:50.930
And I'm not sure.

00:33:50.930 --> 00:33:53.013
That might happen to be true.

00:33:53.013 --> 00:33:54.680
I'd have to think
about it for a second,

00:33:54.680 --> 00:33:58.765
but I'm not sure
that's relevant.

00:34:03.978 --> 00:34:05.270
OK, so this is a good question.

00:34:05.270 --> 00:34:08.870
If I picked a different
branching program that also

00:34:08.870 --> 00:34:12.370
implements XOR-- or--

00:34:12.370 --> 00:34:14.830
so it would be an equivalent
branching program--

00:34:14.830 --> 00:34:19.225
would it behave the same way
on the non-Boolean values?

00:34:21.840 --> 00:34:26.253
And the answer to
that is yes and no.

00:34:26.253 --> 00:34:27.420
You understand the question?

00:34:27.420 --> 00:34:28.510
It's a very good question.

00:34:28.510 --> 00:34:34.748
And actually, we're going to
prove this in the analysis.

00:34:34.748 --> 00:34:36.790
It's going to be easy to
prove because I gave you

00:34:36.790 --> 00:34:38.620
both possibilities, yes and no.

00:34:38.620 --> 00:34:41.718
But let me tell you
what I mean by that.

00:34:41.718 --> 00:34:43.010
So you understand the question.

00:34:43.010 --> 00:34:44.710
Suppose I had a different
branching program.

00:34:44.710 --> 00:34:47.002
I'm not sure you can come up
with a different branching

00:34:47.002 --> 00:34:49.047
program, but let's
say you could.

00:34:49.047 --> 00:34:51.130
You have a different
branching program, yeah, sure

00:34:51.130 --> 00:34:51.670
you can come--

00:34:51.670 --> 00:34:54.139
you can do the variables in a
different order, for example.

00:34:54.139 --> 00:34:57.250
So suppose you come up with
a different branching program

00:34:57.250 --> 00:35:00.220
that gives you XOR.

00:35:00.220 --> 00:35:03.370
And now you plugged in 2 and 3.

00:35:03.370 --> 00:35:07.530
Would I always get
the same value out?

00:35:07.530 --> 00:35:13.150
Yes, if that other branching
program was read-once.

00:35:13.150 --> 00:35:17.650
No, not necessarily
if it's not read-once.

00:35:20.160 --> 00:35:21.885
And that's why
read-once is critical.

00:35:24.500 --> 00:35:29.170
As we will prove, for two
read-once branching programs,

00:35:29.170 --> 00:35:33.700
if they behave the same
way on the Boolean values,

00:35:33.700 --> 00:35:37.225
they behave the same way even
on the non-Boolean values.

00:35:40.160 --> 00:35:43.520
That's not necessarily true if
the branching programs are not

00:35:43.520 --> 00:35:44.240
read-once.

00:35:49.690 --> 00:35:51.640
OK, we will see that.

00:35:51.640 --> 00:35:56.360
We will prove that and use that.

00:35:56.360 --> 00:35:58.890
That's going to be important.

00:35:58.890 --> 00:36:00.690
OK, so here is the
algorithm sketch,

00:36:00.690 --> 00:36:03.090
which is kind of a little
bit even sort of suggested

00:36:03.090 --> 00:36:06.255
by that very good question.

00:36:10.320 --> 00:36:11.820
So what we're going
to do is we want

00:36:11.820 --> 00:36:16.800
to take the two branching
programs that we're trying

00:36:16.800 --> 00:36:18.900
to test if they're equivalent.

00:36:18.900 --> 00:36:22.380
We're going to pick a random
non-Boolean input assignment--

00:36:22.380 --> 00:36:25.530
so set the values here
chosen from the field,

00:36:25.530 --> 00:36:27.240
but we'll get there.

00:36:27.240 --> 00:36:32.640
A random value for x1, random
value for x2, and so on.

00:36:32.640 --> 00:36:36.990
These could be numbers like
17, and 25, and 23, and so on.

00:36:36.990 --> 00:36:41.760
And then, using this process,
run the branching programs

00:36:41.760 --> 00:36:45.420
to evaluate them on that
non-Boolean assignment.

00:36:45.420 --> 00:36:48.060
If they disagree,
then we're going

00:36:48.060 --> 00:36:51.150
to know that the two branching
programs were not equivalent,

00:36:51.150 --> 00:36:55.100
even on the non-Boolean case.

00:36:55.100 --> 00:36:56.240
Even on the Boolean case.

00:36:56.240 --> 00:36:57.120
Did I say that wrong?

00:36:57.120 --> 00:36:59.810
So if they disagree, even
on the non-Boolean case,

00:36:59.810 --> 00:37:03.200
they have to be an equivalent
even in the Boolean case.

00:37:03.200 --> 00:37:05.910
Not obvious.

00:37:05.910 --> 00:37:10.865
But if they agree, then
it's not a guarantee

00:37:10.865 --> 00:37:12.240
that they're
equivalent, but it's

00:37:12.240 --> 00:37:16.777
going to be very strong evidence
that they're equivalent.

00:37:16.777 --> 00:37:18.610
OK, so that's where the
probabilistic nature

00:37:18.610 --> 00:37:21.650
is going to come in.

00:37:21.650 --> 00:37:23.580
So we're going to prove that.

00:37:23.580 --> 00:37:27.830
So first, we have to
develop an algebraic fact.

00:37:27.830 --> 00:37:30.502
And that involves polynomials.

00:37:30.502 --> 00:37:32.460
This is a simple thing
that I think many of you

00:37:32.460 --> 00:37:37.710
have run into already,
perhaps even in high school.

00:37:37.710 --> 00:37:39.570
I'm not going to prove
the algebraic facts,

00:37:39.570 --> 00:37:40.500
but I'm going to state them.

00:37:40.500 --> 00:37:41.790
And actually, the
proofs are not hard.

00:37:41.790 --> 00:37:42.790
They're in the textbook.

00:37:45.315 --> 00:37:49.770
So suppose we have a
polynomial of degree d here.

00:37:49.770 --> 00:37:50.955
It happens to have p.

00:37:50.955 --> 00:37:54.270
So there's a bunch of constants.

00:37:54.270 --> 00:37:55.890
These a's are constants.

00:37:55.890 --> 00:37:58.410
x is the variable
of the polynomial.

00:37:58.410 --> 00:38:01.380
And I presume you've seen
polynomials written out

00:38:01.380 --> 00:38:02.920
like this.

00:38:02.920 --> 00:38:10.850
And so if you assign x to some
value, some constant value z,

00:38:10.850 --> 00:38:14.630
and the polynomial
evaluates to 0,

00:38:14.630 --> 00:38:17.210
we often call that a
root of the polynomial.

00:38:20.920 --> 00:38:24.002
So these are the places where
the polynomial evaluates to 0

00:38:24.002 --> 00:38:25.210
that I've of shown over here.

00:38:25.210 --> 00:38:26.050
Those are the roots.

00:38:29.920 --> 00:38:33.850
It's not hard to show that a
low-degree polynomial cannot

00:38:33.850 --> 00:38:36.460
have lots of roots.

00:38:36.460 --> 00:38:39.580
Basically, if the polynomial
has degree at most d,

00:38:39.580 --> 00:38:42.370
it can have at most d roots,
as long as the polynomial

00:38:42.370 --> 00:38:45.730
itself is not the
everywhere 0 polynomial,

00:38:45.730 --> 00:38:48.040
because obviously, then
everything is a root.

00:38:51.050 --> 00:38:52.520
Oops, typo.

00:38:52.520 --> 00:38:53.300
Thank you.

00:38:53.300 --> 00:38:54.980
Should be d minus 2 over there.

00:38:59.140 --> 00:39:00.220
Pretend that's a 2.

00:39:03.140 --> 00:39:09.315
All right, so if we have
a low-degree polynomial--

00:39:09.315 --> 00:39:10.690
let's not get
ahead of ourselves.

00:39:10.690 --> 00:39:13.790
If we have a
low-degree polynomial,

00:39:13.790 --> 00:39:17.510
a polynomial of degree at most
d, it has at most d roots.

00:39:17.510 --> 00:39:19.490
And that's a simple proof.

00:39:19.490 --> 00:39:21.810
The basic idea is
every time you have

00:39:21.810 --> 00:39:24.650
a-- if you have a root
of the polynomial,

00:39:24.650 --> 00:39:35.330
so if setting x equal to 5 gives
you a root of the polynomial,

00:39:35.330 --> 00:39:38.840
it's a 0 of the polynomial,
then x-- you can easily to see

00:39:38.840 --> 00:39:41.270
that x minus 5 is a
factor of the polynomial.

00:39:45.540 --> 00:39:48.740
You can divide by x minus 5,
and you get a new polynomial

00:39:48.740 --> 00:39:50.130
of degree one less.

00:39:50.130 --> 00:39:53.990
And you can just, which
is going by induction,

00:39:53.990 --> 00:39:57.080
has one fewer root.

00:39:57.080 --> 00:39:59.450
So you can just divide out
by the roots, basically.

00:39:59.450 --> 00:40:01.418
It's very straightforward.

00:40:10.090 --> 00:40:14.230
And other very important thing--

00:40:14.230 --> 00:40:18.910
if I have two polynomials
that are both low-degree,

00:40:18.910 --> 00:40:21.790
they cannot agree
on very many places.

00:40:24.880 --> 00:40:29.140
That follows from what
I just proved above.

00:40:29.140 --> 00:40:32.260
Because what I'll do is I
take those two polynomials,

00:40:32.260 --> 00:40:34.540
and they look at the
difference, which is also

00:40:34.540 --> 00:40:36.400
a low-degree polynomial.

00:40:36.400 --> 00:40:38.950
Every time there's an
agreement between those two

00:40:38.950 --> 00:40:41.440
original polynomials,
there's a zero

00:40:41.440 --> 00:40:43.690
of the difference polynomial.

00:40:43.690 --> 00:40:46.240
And because that difference
polynomial cannot have too many

00:40:46.240 --> 00:40:49.060
zeroes, the two original
polynomials cannot have too

00:40:49.060 --> 00:40:49.990
many agreements.

00:40:53.270 --> 00:40:56.510
So the corollary is that if
x and y are both polynomials

00:40:56.510 --> 00:41:00.410
of degree at most d, and
they're not the same polynomial,

00:41:00.410 --> 00:41:03.780
because then the difference
would be the 0 polynomial,

00:41:03.780 --> 00:41:07.830
then the number of places where
they're equal is at most d.

00:41:07.830 --> 00:41:09.510
So the proof is
just letting p be

00:41:09.510 --> 00:41:12.920
the difference of p1 and p2--

00:41:12.920 --> 00:41:15.620
very standard kind of a trick.

00:41:15.620 --> 00:41:19.190
Now the above is going
to hold for any field.

00:41:19.190 --> 00:41:22.190
A field is just a set
with plus and times

00:41:22.190 --> 00:41:27.380
with the familiar properties
of distributive law and so on

00:41:27.380 --> 00:41:29.990
and identities and
all the stuff that you

00:41:29.990 --> 00:41:34.350
would expect plus and times
to have in the normal world.

00:41:34.350 --> 00:41:38.510
And so we're going to talk
about the finite field that

00:41:38.510 --> 00:41:41.810
has only q elements--

00:41:41.810 --> 00:41:44.842
that has exactly q elements,
where q is a prime number.

00:41:44.842 --> 00:41:47.300
So it turns out that-- and I'm
not going to prove all this,

00:41:47.300 --> 00:41:49.610
but it's pretty simple stuff--

00:41:49.610 --> 00:41:54.710
that if you just take the
numbers from 1 to q minus 1--

00:41:54.710 --> 00:42:01.400
from 0 to q minus 1, and
use plus n times mod q,

00:42:01.400 --> 00:42:05.940
that has all the right
properties to be a field.

00:42:05.940 --> 00:42:07.350
So just think of it--

00:42:07.350 --> 00:42:12.330
just modular arithmetic,
mod some prime q.

00:42:12.330 --> 00:42:20.110
And then we can in a natural
way pick a random assignment

00:42:20.110 --> 00:42:24.160
to a variable from the field
because it's just choosing

00:42:24.160 --> 00:42:26.087
from among q possibilities.

00:42:37.505 --> 00:42:38.880
Yeah, so getting
a question here.

00:42:38.880 --> 00:42:43.110
The coefficients of the
polynomial and the assignment

00:42:43.110 --> 00:42:46.410
to the variables-- they're all
going to come from this field.

00:42:46.410 --> 00:42:52.790
So everything's going to
be operating in this field.

00:42:52.790 --> 00:42:56.360
Don't let that throw you off.

00:42:56.360 --> 00:42:59.578
Just your ordinary intuition
about the way arithmetic works

00:42:59.578 --> 00:43:00.620
is going to be just fine.

00:43:11.530 --> 00:43:14.320
But this is important here from
the perspective of thinking

00:43:14.320 --> 00:43:15.640
about this probabilistically.

00:43:15.640 --> 00:43:18.310
So I'm going to rethink about
this polynomial lemma, which

00:43:18.310 --> 00:43:21.730
says there are not
too many roots.

00:43:21.730 --> 00:43:23.860
In terms of the
probability of picking

00:43:23.860 --> 00:43:26.140
an element of the field,
what are the chances

00:43:26.140 --> 00:43:29.080
that it happens to be a root?

00:43:29.080 --> 00:43:32.460
So if you have a
low-degree polynomial,

00:43:32.460 --> 00:43:35.950
and you pick a random
value in the field,

00:43:35.950 --> 00:43:39.600
what's the probability
that you've got a root?

00:43:39.600 --> 00:43:41.460
Well, it's just the
number of roots divided

00:43:41.460 --> 00:43:43.898
by the size of the field.

00:43:43.898 --> 00:43:45.440
So if you have this
really big field,

00:43:45.440 --> 00:43:47.150
and you have this
low-degree polynomial,

00:43:47.150 --> 00:43:50.480
it's going to be pretty
unlikely that you're

00:43:50.480 --> 00:43:55.520
going to end up picking one of
the zeroes, one of the roots,

00:43:55.520 --> 00:43:57.150
just at random.

00:43:57.150 --> 00:44:00.680
That's all that this is saying.

00:44:00.680 --> 00:44:04.010
So there's at most d roots
out of the q possibilities.

00:44:04.010 --> 00:44:06.410
And the last thing I'm
going to introduce here

00:44:06.410 --> 00:44:11.340
is the multivariable
version of this

00:44:11.340 --> 00:44:14.420
which is called, perhaps
somewhat unfairly,

00:44:14.420 --> 00:44:18.410
but it's called the
Schwartz-Zippel lemma,

00:44:18.410 --> 00:44:25.880
though in various forms, it had
been known prior to their work.

00:44:25.880 --> 00:44:31.110
In some cases, the literature
actually goes back a long ways.

00:44:31.110 --> 00:44:34.020
But anyway, this is called
the Schwartz-Zippel lemma.

00:44:34.020 --> 00:44:41.570
Doesn't really matter,
except to the people whose

00:44:41.570 --> 00:44:43.190
credit is being denied.

00:44:43.190 --> 00:44:46.170
But that's not one of us.

00:44:46.170 --> 00:44:49.640
So anyway, the Schwartz-Zippel
lemma says that if you have now

00:44:49.640 --> 00:44:52.080
a polynomial in
several variables,

00:44:52.080 --> 00:44:55.700
which is not the 0 polynomial,
where each variable has low

00:44:55.700 --> 00:44:56.580
degree--

00:44:56.580 --> 00:45:00.920
so if I say if it has
degree at most d in each xi.

00:45:00.920 --> 00:45:04.010
So each variable is going to
have at most an exponent of d

00:45:04.010 --> 00:45:07.380
appearing in that polynomial.

00:45:07.380 --> 00:45:12.650
And now if we pick random values
to assign to all of those n

00:45:12.650 --> 00:45:17.180
variables from the
field, the probability

00:45:17.180 --> 00:45:22.350
that we ended up with a root,
that we ended up with a 0,

00:45:22.350 --> 00:45:24.740
is something you can bound.

00:45:24.740 --> 00:45:27.970
So it's m times d, so
the number of variables

00:45:27.970 --> 00:45:30.700
times this maximum
degree, divided

00:45:30.700 --> 00:45:32.990
by the size of the field.

00:45:32.990 --> 00:45:36.490
And this is going to
come up later for us.

00:45:36.490 --> 00:45:42.090
And this is another fairly
simple proof, a little bit more

00:45:42.090 --> 00:45:43.980
sophisticated than the
one that we had above.

00:45:43.980 --> 00:45:52.350
And in fact, it uses that one as
a lemma to prove this theorem.

00:45:52.350 --> 00:45:54.092
So we're going to--

00:45:54.092 --> 00:45:56.550
not going to prove any of that,
but I refer you to the book

00:45:56.550 --> 00:45:57.300
if you're curious.

00:46:08.310 --> 00:46:11.290
Yeah, so a couple of
good questions here.

00:46:11.290 --> 00:46:15.642
What happens if these values
are bigger than q, for example?

00:46:15.642 --> 00:46:17.100
Then it's not
telling you anything.

00:46:17.100 --> 00:46:19.230
If d is bigger than
q, m is bigger than q,

00:46:19.230 --> 00:46:24.300
or the product is bigger than
q, then you learn nothing

00:46:24.300 --> 00:46:25.230
from this lemma--

00:46:25.230 --> 00:46:26.730
from this theorem.

00:46:26.730 --> 00:46:31.578
So typically in applications,
you're going to pick a large--

00:46:31.578 --> 00:46:33.120
you're going to have
the flexibility.

00:46:33.120 --> 00:46:36.250
You get to choose q to be
something that you want.

00:46:36.250 --> 00:46:38.190
So we're going to pick
the field to be big

00:46:38.190 --> 00:46:45.860
enough so that the m and d are
going to be relatively small.

00:46:45.860 --> 00:46:49.890
In fact, d is going to end
up being 1, as we will see.

00:46:49.890 --> 00:46:51.310
And m is the number
of variables.

00:46:51.310 --> 00:46:52.740
So we're going to
pick q, which is

00:46:52.740 --> 00:46:57.690
going to be substantially larger
than the number of variables.

00:46:57.690 --> 00:47:01.305
And how is the degree defined
in multivariable polynomials?

00:47:01.305 --> 00:47:10.110
If the polynomial has xy squared
plus 3x to the 5th y squared z,

00:47:10.110 --> 00:47:12.840
you just pull out each
variable separately.

00:47:12.840 --> 00:47:15.730
And you look at the maximum
degree of that variable.

00:47:15.730 --> 00:47:20.220
So the x in that case had
had a degree 5 appearance.

00:47:20.220 --> 00:47:22.800
The y had a degree 2 appearance.

00:47:22.800 --> 00:47:25.200
So you take the maximum
over all of the variables

00:47:25.200 --> 00:47:26.553
of the degree of that variable.

00:47:26.553 --> 00:47:28.470
And that's going to be
the bound on the degree

00:47:28.470 --> 00:47:30.330
of the polynomial.

00:47:30.330 --> 00:47:33.875
So in fact, in our case,
d is going to be 1.

00:47:33.875 --> 00:47:35.250
So all of the
variables-- there's

00:47:35.250 --> 00:47:37.678
not going to be any
exponents on anything.

00:47:37.678 --> 00:47:39.220
Everything is going
to be exponent 1.

00:47:45.025 --> 00:47:47.410
Is q related to the number
we choose for the mod?

00:47:47.410 --> 00:47:50.320
Yeah, q is the number
we're choosing for the mod.

00:47:50.320 --> 00:47:51.670
We're doing everything mod q.

00:47:55.560 --> 00:47:59.790
So all the arithmetic is
going to operate in mod q,

00:47:59.790 --> 00:48:04.350
and that's the size of the
field that we're going to pick.

00:48:07.070 --> 00:48:09.730
So I think we're
here at the break.

00:48:09.730 --> 00:48:12.220
Happy to take some
more questions,

00:48:12.220 --> 00:48:13.810
but why don't we
just start that off.

00:48:18.390 --> 00:48:22.540
And I will see you
in five minutes.

00:48:22.540 --> 00:48:26.220
But in the meantime, happy
to shoot me questions.

00:48:26.220 --> 00:48:28.555
So what happens if we use
Boolean assignments in the XOR

00:48:28.555 --> 00:48:29.055
example?

00:48:33.470 --> 00:48:38.730
Would that work to be
able to check agreement?

00:48:44.250 --> 00:48:44.970
It would.

00:48:44.970 --> 00:48:52.260
So it's hard to make an argument
based on just a single example.

00:48:52.260 --> 00:48:56.220
I think the better
thing would be

00:48:56.220 --> 00:49:05.720
to look at two
branching programs that

00:49:05.720 --> 00:49:07.380
just differ in a single place.

00:49:07.380 --> 00:49:10.100
So I can even suggest two.

00:49:10.100 --> 00:49:16.500
You can make a branching program
that always outputs true.

00:49:16.500 --> 00:49:18.360
It doesn't even
read its variables.

00:49:18.360 --> 00:49:20.610
Or if it reads them, they
always go to the same place.

00:49:20.610 --> 00:49:23.350
And it ends up always
at the q output.

00:49:23.350 --> 00:49:24.918
So you imagine a
branching program

00:49:24.918 --> 00:49:26.460
that always outputs
1, no matter what

00:49:26.460 --> 00:49:28.002
the assignments to
the variables are.

00:49:28.002 --> 00:49:30.660
And you can easily
make such a thing.

00:49:30.660 --> 00:49:32.490
And then you make
another branching program

00:49:32.490 --> 00:49:35.790
that computes the or function.

00:49:35.790 --> 00:49:37.250
So it reads every variable.

00:49:37.250 --> 00:49:42.750
And it's going to be 1 if
any one of those variables

00:49:42.750 --> 00:49:43.530
is set to 1.

00:49:46.270 --> 00:49:49.930
So the only time
the or function is

00:49:49.930 --> 00:49:52.435
0 is if everything is set to 0.

00:49:55.170 --> 00:50:00.240
But now if you're
trying to randomly check

00:50:00.240 --> 00:50:05.333
whether the always one function
is equal to the or function--

00:50:05.333 --> 00:50:07.500
of course, without knowing
in advance what they are,

00:50:07.500 --> 00:50:08.520
because that's cheating.

00:50:08.520 --> 00:50:10.560
You're just given
these two functions,

00:50:10.560 --> 00:50:13.050
and you want to know-- these
two branching programs.

00:50:13.050 --> 00:50:14.730
And you want to know,
are they computing

00:50:14.730 --> 00:50:17.400
the same thing or not?

00:50:17.400 --> 00:50:20.757
And by this procedure
of randomly sampling,

00:50:20.757 --> 00:50:23.090
you're always going to get
these branching programs both

00:50:23.090 --> 00:50:28.040
to say 1, unless you just happen
to pick the random assignment

00:50:28.040 --> 00:50:30.730
of everything set to 0.

00:50:30.730 --> 00:50:33.130
And that's very unlikely that
you're going to pick that.

00:50:33.130 --> 00:50:35.770
If you imagine you have--
your branching program

00:50:35.770 --> 00:50:37.480
has 100 variables in it.

00:50:37.480 --> 00:50:40.180
It's only 2 to the
minus 100 chance

00:50:40.180 --> 00:50:43.640
that you're going to set
them all to 0 randomly.

00:50:43.640 --> 00:50:47.710
And so you're extremely
unlikely to find

00:50:47.710 --> 00:50:51.100
that one place of difference
if there's only a single place.

00:50:51.100 --> 00:50:52.930
If there's lots of
places of difference,

00:50:52.930 --> 00:50:55.850
then it's not so bad.

00:50:55.850 --> 00:50:58.638
But if the number, the fraction
of differences, is low,

00:50:58.638 --> 00:51:00.430
you're going to have
to do a lot of samples

00:51:00.430 --> 00:51:02.470
in order to find that--

00:51:02.470 --> 00:51:04.420
possibly exponentially
many samples.

00:51:04.420 --> 00:51:06.550
And then you won't run
in polynomial time.

00:51:06.550 --> 00:51:08.675
So let me just see if
there's other questions here.

00:51:11.100 --> 00:51:13.500
Why can we accept--

00:51:13.500 --> 00:51:15.150
going back to the
Boolean labeling

00:51:15.150 --> 00:51:18.960
side, why can we accept that
b1 equals b2 if b1 and b2

00:51:18.960 --> 00:51:20.780
agree on--

00:51:20.780 --> 00:51:22.520
only on just one
input assignment?

00:51:22.520 --> 00:51:24.890
No, we didn't say that.

00:51:24.890 --> 00:51:26.420
All right, I'll go back there.

00:51:26.420 --> 00:51:30.270
Boolean assignment-- is this--

00:51:30.270 --> 00:51:31.830
I'm not sure which one you mean.

00:51:31.830 --> 00:51:33.950
Is this the one you mean?

00:51:33.950 --> 00:51:34.940
I don't know--

00:51:34.940 --> 00:51:37.100
Boolean labeling,
so it must be it.

00:51:37.100 --> 00:51:40.970
Why do we non-Boolean labeling?

00:51:53.190 --> 00:51:55.000
No, I see what you're saying.

00:51:55.000 --> 00:51:56.250
You're saying about this here.

00:51:56.250 --> 00:52:00.180
We're just going to pick
one random assignment.

00:52:00.180 --> 00:52:04.050
And if they agree on
that one random case,

00:52:04.050 --> 00:52:07.823
then we will say accept,
because you might think,

00:52:07.823 --> 00:52:09.740
well, we should take a
whole bunch of samples.

00:52:09.740 --> 00:52:11.500
That's a good question.

00:52:11.500 --> 00:52:14.410
But in fact, we're going to
arrange the probability such

00:52:14.410 --> 00:52:18.430
that if the two things
are not equivalent, then

00:52:18.430 --> 00:52:21.340
it's going to be--

00:52:21.340 --> 00:52:23.380
the values will be
different almost everywhere,

00:52:23.380 --> 00:52:25.370
or a large number of places.

00:52:25.370 --> 00:52:27.598
So just picking one
and having them agree

00:52:27.598 --> 00:52:29.890
is going to be strong enough
evidence that you're still

00:52:29.890 --> 00:52:30.640
going to accept.

00:52:30.640 --> 00:52:32.440
And you'll have still
a low probability

00:52:32.440 --> 00:52:34.140
of getting an error.

00:52:34.140 --> 00:52:37.593
You'd have to see the analysis.

00:52:37.593 --> 00:52:40.010
Are we assuming the roots of
the polynomials are integers?

00:52:40.010 --> 00:52:43.978
No, we're operating
over a field here.

00:52:43.978 --> 00:52:46.270
Even talking about integers
doesn't totally make sense.

00:52:46.270 --> 00:52:48.345
But it doesn't really matter.

00:52:48.345 --> 00:52:49.345
We're not assuming that.

00:52:53.830 --> 00:52:57.040
Oh, I should have
taken this away.

00:52:57.040 --> 00:52:58.240
The bound still works.

00:53:01.090 --> 00:53:07.950
The bound still works even
if we have non-integers.

00:53:07.950 --> 00:53:09.600
I'm not sure if I'm
being helpful here.

00:53:09.600 --> 00:53:11.495
Why don't we just move on?

00:53:11.495 --> 00:53:12.870
But we're not
assuming that these

00:53:12.870 --> 00:53:15.060
are integers because the
bound doesn't matter.

00:53:15.060 --> 00:53:20.190
If it says there is at most
five roots, including the reals,

00:53:20.190 --> 00:53:22.740
there's still going to be five
roots, including the integers.

00:53:22.740 --> 00:53:24.135
All right, so let's continue.

00:53:27.070 --> 00:53:28.780
Good, all right.

00:53:28.780 --> 00:53:32.350
So now everybody's back, I hope?

00:53:32.350 --> 00:53:35.695
Let's talk about
moving forward here.

00:53:38.470 --> 00:53:40.090
Where we're going
with this is we

00:53:40.090 --> 00:53:44.290
want to analyze the
algorithm, which

00:53:44.290 --> 00:53:49.180
picks a random non-Boolean
input and evaluates the two

00:53:49.180 --> 00:53:52.290
branching programs.

00:53:52.290 --> 00:53:55.650
And in order to do that, we're
going to look a little bit more

00:53:55.650 --> 00:54:02.400
carefully at what happens
when we arithmetize

00:54:02.400 --> 00:54:05.670
the branching
program, and we run it

00:54:05.670 --> 00:54:07.450
on these non-Boolean values.

00:54:07.450 --> 00:54:15.550
And so what I'm going to do is
take this branching program.

00:54:15.550 --> 00:54:19.120
Let's say this is the
same XOR, exclusive

00:54:19.120 --> 00:54:20.200
or, branching program.

00:54:20.200 --> 00:54:25.850
But instead of labeling it as
we did before by setting x1

00:54:25.850 --> 00:54:31.110
to 2 and x2 to 3, I'm going
to leave x1 and x2 variables

00:54:31.110 --> 00:54:33.780
and just do a
symbolic execution.

00:54:33.780 --> 00:54:36.420
So I'm going to label
these things, just

00:54:36.420 --> 00:54:40.810
leaving x1 and x2 as variables.

00:54:40.810 --> 00:54:43.160
So let's just see what
we get if we do that.

00:54:43.160 --> 00:54:46.480
So remember, we
assigned this to be 1.

00:54:46.480 --> 00:54:50.305
Now this edge here is--

00:54:52.995 --> 00:54:54.030
here's the rule.

00:54:54.030 --> 00:54:59.100
It's a, which is 1, times x1.

00:54:59.100 --> 00:55:00.360
So this should be--

00:55:00.360 --> 00:55:02.160
without knowing what
the value of x1 is,

00:55:02.160 --> 00:55:03.660
leaving it as a
variable, we're just

00:55:03.660 --> 00:55:05.710
going to put down x1 over here.

00:55:05.710 --> 00:55:08.050
Over here, what goes over there?

00:55:08.050 --> 00:55:11.050
Well, it's 1 times 1 minus x1--

00:55:11.050 --> 00:55:13.060
just 1 minus x1.

00:55:13.060 --> 00:55:17.172
Now we're going to add
things up, as we did before.

00:55:17.172 --> 00:55:18.630
And now what happens,
for example--

00:55:18.630 --> 00:55:20.172
I think I have this
edge coming next.

00:55:20.172 --> 00:55:24.240
Let's look at this edge,
the one edge coming out.

00:55:24.240 --> 00:55:27.075
The label now is
x1 on this node.

00:55:30.210 --> 00:55:31.890
This is the one edge
coming out, so you

00:55:31.890 --> 00:55:35.985
multiply by the value of x2.

00:55:35.985 --> 00:55:37.860
We're leaving it as a
variable, so we're just

00:55:37.860 --> 00:55:39.690
going to multiply it by x2.

00:55:39.690 --> 00:55:44.200
And so we're just going
to get x1 times x2--

00:55:44.200 --> 00:55:46.280
x1x2 on this edge.

00:55:46.280 --> 00:55:48.980
And now what happens
on this edge?

00:55:48.980 --> 00:55:50.740
So this x1 times--

00:55:50.740 --> 00:55:56.390
think with me--
times 1 minus x2.

00:55:59.050 --> 00:56:02.690
And similarly over here, we
have 1 minus x1 on this node.

00:56:02.690 --> 00:56:06.490
So I think on the one edge
coming out, it's 1 minus x1,

00:56:06.490 --> 00:56:09.730
now times x2, because
that's this rule again.

00:56:12.320 --> 00:56:14.240
1 minus x, 1 times x2.

00:56:14.240 --> 00:56:18.590
And this is going to be 1
minus x1 times 1 minus x2.

00:56:18.590 --> 00:56:23.060
Now we're going to add
this up for the 0 node.

00:56:23.060 --> 00:56:28.040
So we have this value, 1 minus
x1, 1 minus x2, plus x1 x2.

00:56:31.140 --> 00:56:33.510
And on this note
here, we're going

00:56:33.510 --> 00:56:38.980
to add these two values up.

00:56:38.980 --> 00:56:44.460
So 1 minus x1 times x2
plus x1 times 1 minus x2.

00:56:44.460 --> 00:56:49.323
And that's the output, now
expressed symbolically.

00:56:49.323 --> 00:56:50.990
Now you could plug
things in, and you're

00:56:50.990 --> 00:56:54.950
going to get the same value
out as you did before.

00:56:54.950 --> 00:56:58.550
But let's leave it as
a polynomial for now

00:56:58.550 --> 00:57:05.160
because that's going to
help us and analyze this.

00:57:05.160 --> 00:57:07.875
So now, notice the
form of this polynomial

00:57:07.875 --> 00:57:08.750
is something special.

00:57:13.290 --> 00:57:15.210
What happens is
it's going to look

00:57:15.210 --> 00:57:24.730
like a bunch of products of
xi's and 1 minus xi's added up.

00:57:24.730 --> 00:57:27.890
So it's a sum of
products of that form.

00:57:27.890 --> 00:57:35.590
So each row here is a product
of xi's and 1 minus xi's.

00:57:35.590 --> 00:57:38.860
And then those rows
are all added together.

00:57:38.860 --> 00:57:42.310
I claim that's going to be
the form of this polynomial.

00:57:42.310 --> 00:57:45.890
You see this already
has that form.

00:57:45.890 --> 00:57:51.440
And the reason for that is
every time you go to a node,

00:57:51.440 --> 00:57:53.000
you're just adding things up.

00:57:53.000 --> 00:57:56.780
So that's just going to be
like adding up more rows.

00:57:56.780 --> 00:57:59.720
And every time you go
down to through an edge,

00:57:59.720 --> 00:58:02.720
you're multiplying what
you have so far either

00:58:02.720 --> 00:58:07.050
by an xi or a 1 minus xi.

00:58:07.050 --> 00:58:10.170
So you're just accumulating
products of xi's and 1 minus

00:58:10.170 --> 00:58:12.700
xi's, and you're
just adding them up.

00:58:12.700 --> 00:58:15.720
So this is what that polynomial
is going to look like.

00:58:19.240 --> 00:58:25.400
Now let's look a little bit more
carefully at the form of this.

00:58:25.400 --> 00:58:35.530
So for one thing, could we
have higher powers here,

00:58:35.530 --> 00:58:37.990
like x2 cubed?

00:58:37.990 --> 00:58:38.740
Could that happen?

00:58:44.760 --> 00:58:47.940
And when I say it's products
of the xi's and 1 minus xi's,

00:58:47.940 --> 00:58:50.910
maybe there's going to be some
xi's that appear several times

00:58:50.910 --> 00:58:52.940
in the product.

00:58:52.940 --> 00:58:55.175
Well, that cannot happen.

00:58:55.175 --> 00:58:55.675
Why?

00:58:58.210 --> 00:59:00.560
It's a read once
branching program.

00:59:00.560 --> 00:59:05.500
So every time you multiply
by an xi or a 1 minus xi,

00:59:05.500 --> 00:59:07.000
you're never going
to do that again,

00:59:07.000 --> 00:59:12.310
because doing that would
imply you're querying

00:59:12.310 --> 00:59:16.090
that variable more than once.

00:59:16.090 --> 00:59:17.415
So this can't happen.

00:59:22.140 --> 00:59:23.240
So I cross that out.

00:59:23.240 --> 00:59:24.110
This just appeared.

00:59:24.110 --> 00:59:25.235
It's off to the side, here.

00:59:25.235 --> 00:59:26.850
But yeah, I'm crossing that out.

00:59:26.850 --> 00:59:28.360
That does not happen.

00:59:28.360 --> 00:59:33.690
Another thing that is
part of-- that's worthy--

00:59:33.690 --> 00:59:38.300
that's going to be helpful to
notice about this polynomial--

00:59:38.300 --> 00:59:41.540
and by the way, maybe
I'm being confusing here.

00:59:41.540 --> 00:59:45.710
This I'm supposed to be
representing as a generic form

00:59:45.710 --> 00:59:46.590
of the polynomial.

00:59:46.590 --> 00:59:47.810
This is not some
particularly-- yeah,

00:59:47.810 --> 00:59:49.518
I should have said
this at the beginning.

00:59:49.518 --> 00:59:51.290
This is not some
particular polynomial

00:59:51.290 --> 00:59:52.680
that came from anything.

00:59:52.680 --> 00:59:54.740
I'm just trying to describe
what the general form

00:59:54.740 --> 01:00:00.420
of the polynomial looks like,
just as an illustration.

01:00:00.420 --> 01:00:02.790
So this polynomial's
1 minus x1 times

01:00:02.790 --> 01:00:06.990
x2 times 1 minus x3
times x4 and so on,

01:00:06.990 --> 01:00:09.180
and adding up a bunch
of rows like this.

01:00:09.180 --> 01:00:11.370
I'm just saying this is
what the polynomial will

01:00:11.370 --> 01:00:14.640
look like for maybe
some branching program.

01:00:14.640 --> 01:00:16.140
So every branching
program is either

01:00:16.140 --> 01:00:20.970
going to have some polynomial
that looks sort of like this.

01:00:20.970 --> 01:00:23.610
And what I'm also going to say--

01:00:23.610 --> 01:00:25.830
for convenience,
now, I want to say

01:00:25.830 --> 01:00:29.910
that each row is going to have
every single variable appear

01:00:29.910 --> 01:00:35.050
either as an xi or
as a 1 minus xi.

01:00:35.050 --> 01:00:37.180
So in order to get
that, I need to make

01:00:37.180 --> 01:00:40.420
a further minor assumption
about the branching program--

01:00:40.420 --> 01:00:43.490
that it's a read exactly once.

01:00:43.490 --> 01:00:45.290
Currently when I
say "read once,"

01:00:45.290 --> 01:00:49.610
it can avoid reading some
variables on some branches,

01:00:49.610 --> 01:00:51.380
because it's like a
read at most once.

01:00:51.380 --> 01:00:54.470
But now I want to say that every
variable gets read exactly one

01:00:54.470 --> 01:00:56.720
time on every branch.

01:00:56.720 --> 01:00:59.360
And what that's going to
mean is that every row

01:00:59.360 --> 01:01:03.860
is going to contain every
variable, either as an xi

01:01:03.860 --> 01:01:06.370
or as a 1 minus xi.

01:01:06.370 --> 01:01:08.750
We can eliminate that
extra assumption easily.

01:01:08.750 --> 01:01:10.833
And I'm going to leave
that as an exercise to you.

01:01:10.833 --> 01:01:12.470
It's not very hard to do.

01:01:12.470 --> 01:01:14.892
So I think if you
follow me, you can see--

01:01:14.892 --> 01:01:16.600
and you play with it
for a minute or two,

01:01:16.600 --> 01:01:18.308
you'll see that it
doesn't really matter.

01:01:21.088 --> 01:01:24.740
But I think just for the
first time through this,

01:01:24.740 --> 01:01:28.660
let's assume that every
row has every variable--

01:01:31.290 --> 01:01:32.970
so important to understand.

01:01:37.510 --> 01:01:41.210
So this is the output polynomial
of this branching program.

01:01:41.210 --> 01:01:44.800
So let's look furthermore
at this polynomial

01:01:44.800 --> 01:01:48.610
and understand the rows.

01:01:48.610 --> 01:01:52.750
Let's take one row
out of this polynomial

01:01:52.750 --> 01:02:03.030
to understand what
it represents.

01:02:03.030 --> 01:02:04.850
So one row here--

01:02:04.850 --> 01:02:07.520
it's a product of a
bunch of things, product

01:02:07.520 --> 01:02:10.010
of a bunch of variables,
either variables

01:02:10.010 --> 01:02:11.300
or 1 minus the variables.

01:02:16.110 --> 01:02:20.190
Let's think about this in the
Boolean setting, first of all.

01:02:20.190 --> 01:02:23.540
So in the Boolean setting, each
of these variables are going

01:02:23.540 --> 01:02:25.130
to be 0's and 1's.

01:02:25.130 --> 01:02:27.350
And the 1 minus the variables
are also going to be

01:02:27.350 --> 01:02:28.310
0's and 1's.

01:02:28.310 --> 01:02:31.910
So it's going to be a
product of 0's and 1's.

01:02:31.910 --> 01:02:35.240
If there's a 0 that
appears in that product,

01:02:35.240 --> 01:02:39.220
that product is going to be a
0, because 0 times anything is

01:02:39.220 --> 01:02:40.930
a 0.

01:02:40.930 --> 01:02:51.880
So the only way that product
cannot be 0 is if all of those

01:02:51.880 --> 01:02:55.340
values are 1's in
the Boolean case.

01:02:55.340 --> 01:03:01.320
So that means that x1--

01:03:01.320 --> 01:03:03.780
well, let's look
at the second row.

01:03:03.780 --> 01:03:07.890
So x1 had to be a 1. x2 had
to be a 1. x3 had to be a 1.

01:03:07.890 --> 01:03:12.210
x4 had to be a 0 in
order to continue

01:03:12.210 --> 01:03:16.760
the product of 1's, and so on.

01:03:16.760 --> 01:03:21.340
So in fact, there's only a
single Boolean assignment

01:03:21.340 --> 01:03:25.570
to these variables
which make that row 1.

01:03:25.570 --> 01:03:29.620
Every other assignment to those
variables makes that row 0.

01:03:35.040 --> 01:03:39.360
Saying that another
way, each of these rows

01:03:39.360 --> 01:03:45.870
corresponds to one of
the rows of the truth

01:03:45.870 --> 01:03:53.090
table for the Boolean function,
where the truth table is true,

01:03:53.090 --> 01:03:55.580
gives a true value,
gives a 1 value

01:03:55.580 --> 01:03:57.920
for the function on that row.

01:03:57.920 --> 01:04:00.770
So I hope you're all familiar
with the notion of a truth

01:04:00.770 --> 01:04:02.600
table of a Boolean function.

01:04:02.600 --> 01:04:05.540
You just write down
the Boolean function,

01:04:05.540 --> 01:04:07.820
every possible assignment
to the Boolean function,

01:04:07.820 --> 01:04:11.312
and you write down 1 or
0 or true or false for

01:04:11.312 --> 01:04:12.770
what the value of
that function is.

01:04:12.770 --> 01:04:14.570
It's just a tabular
representation

01:04:14.570 --> 01:04:15.890
of the Boolean function.

01:04:15.890 --> 01:04:18.850
It's called a truth table.

01:04:18.850 --> 01:04:21.370
This thing here gives
you all of the 1's--

01:04:21.370 --> 01:04:25.430
all of the rows that are 1
in that Boolean function.

01:04:25.430 --> 01:04:28.060
That's what this
polynomial gives you.

01:04:32.620 --> 01:04:38.070
So I think we're at a
pause point for this slide.

01:04:42.440 --> 01:04:46.190
It's deathly silent on the chat.

01:04:46.190 --> 01:04:53.650
So I have a feeling that
that went down rough for you.

01:04:56.200 --> 01:05:01.535
It's important to understand the
form of this polynomial here.

01:05:04.330 --> 01:05:07.400
It corresponds to the truth
table of the Boolean function.

01:05:07.400 --> 01:05:10.330
So each one of these rows
is only going to be--

01:05:10.330 --> 01:05:13.420
again, thinking Boolean
now, each one of these rows

01:05:13.420 --> 01:05:17.800
is only going to be 1
on an assignment which

01:05:17.800 --> 01:05:21.308
makes the function 1--

01:05:21.308 --> 01:05:23.350
one of the assignments
that makes the function 1.

01:05:27.280 --> 01:05:30.070
And somebody says, and similarly
for the expression for the 0

01:05:30.070 --> 01:05:30.610
node.

01:05:30.610 --> 01:05:33.550
Yeah, the 0 node, which
I'm not focusing on, but,

01:05:33.550 --> 01:05:37.390
yeah, the 0 node would be all
of the false rows of the truth

01:05:37.390 --> 01:05:40.020
table.

01:05:40.020 --> 01:05:42.930
But the 1 node, the
polynomial for the 1 node,

01:05:42.930 --> 01:05:44.880
are all of the true rows--

01:05:44.880 --> 01:05:46.500
correspond to all
of the true rows

01:05:46.500 --> 01:05:56.742
in the function of the
branching-- the function

01:05:56.742 --> 01:05:58.075
that branching program computes.

01:06:00.885 --> 01:06:02.510
Let me just tell you
where we're going.

01:06:13.590 --> 01:06:17.500
Is it possible to have two
rows that are the same?

01:06:17.500 --> 01:06:20.700
If you think about how the
rows are being produced, no.

01:06:20.700 --> 01:06:22.350
You can't have two
rows that are going

01:06:22.350 --> 01:06:28.532
to be the same,
because for one thing,

01:06:28.532 --> 01:06:30.990
you have to think about what
this looks like in the Boolean

01:06:30.990 --> 01:06:32.340
case.

01:06:32.340 --> 01:06:33.780
If you have two
rows are the same,

01:06:33.780 --> 01:06:36.363
that means this thing is going
to-- would have an output which

01:06:36.363 --> 01:06:40.590
is non-Boolean because
you're going to end up

01:06:40.590 --> 01:06:44.993
with a 2 coming out that way
by adding those rows together.

01:06:44.993 --> 01:06:45.910
That can never happen.

01:06:45.910 --> 01:06:47.340
And if you just look at
the way it's constructed,

01:06:47.340 --> 01:06:49.465
you're never going to--
because every time you have

01:06:49.465 --> 01:06:53.460
a branching, one way is an xi.

01:06:53.460 --> 01:06:55.030
The other one is 1 minus xi.

01:06:55.030 --> 01:06:56.760
So every time you're
branching there,

01:06:56.760 --> 01:07:00.068
every time there's a
node, they're different.

01:07:00.068 --> 01:07:01.860
So you're never going
to have two rows that

01:07:01.860 --> 01:07:02.902
are going to be the same.

01:07:02.902 --> 01:07:08.670
But let me tell you the
importance of connecting up

01:07:08.670 --> 01:07:13.150
this polynomial with
the truth table,

01:07:13.150 --> 01:07:17.650
because that tells us that if
the two functions of the two

01:07:17.650 --> 01:07:20.170
branching programs that
we started off with

01:07:20.170 --> 01:07:24.880
agree in their Boolean values,
then the two polynomials are

01:07:24.880 --> 01:07:25.755
going to be the same.

01:07:34.800 --> 01:07:40.710
Because if the two branching
programs have the same Boolean

01:07:40.710 --> 01:07:45.720
function, so they're equivalent,
then the truth tables

01:07:45.720 --> 01:07:46.620
will be the same.

01:07:46.620 --> 01:07:49.680
And therefore, these
polynomials will be the same.

01:07:49.680 --> 01:07:52.530
And therefore, they
will behave the same way

01:07:52.530 --> 01:07:56.760
on all non-Boolean
values, because they're

01:07:56.760 --> 01:07:57.750
the same polynomial.

01:08:00.540 --> 01:08:03.030
So I'm getting ahead
of myself, but that's

01:08:03.030 --> 01:08:04.260
what we're going to argue.

01:08:04.260 --> 01:08:05.885
That's why it's
important to understand

01:08:05.885 --> 01:08:09.430
the connection with
the truth table,

01:08:09.430 --> 01:08:11.680
because it builds on the--

01:08:15.593 --> 01:08:17.760
understanding something
about how this thing behaves

01:08:17.760 --> 01:08:19.590
in the Boolean case
is going to give us

01:08:19.590 --> 01:08:22.050
information about how it
behaves in the non-Boolean case.

01:08:25.410 --> 01:08:26.660
But let's continue here, then.

01:08:38.590 --> 01:08:42.369
Yeah, this is essentially
the last slide,

01:08:42.369 --> 01:08:44.510
but we're going to spend
some time on this one.

01:08:44.510 --> 01:08:48.189
So here's the algorithm.

01:08:48.189 --> 01:08:51.310
We are going to take our
two branching programs.

01:08:51.310 --> 01:08:53.925
The variables are x1 to xm.

01:08:53.925 --> 01:08:55.300
First of all,
we're going to find

01:08:55.300 --> 01:08:59.590
a prime which is
at least 3 times m,

01:08:59.590 --> 01:09:01.880
the number of variables.

01:09:01.880 --> 01:09:04.220
m is not a very big number.

01:09:04.220 --> 01:09:06.120
It's just the
number of variables.

01:09:06.120 --> 01:09:09.532
So finding a prime that's bigger
than that is straightforward.

01:09:09.532 --> 01:09:11.240
We're not talking
about huge primes here.

01:09:11.240 --> 01:09:13.115
We're talking about very
modest-sized primes.

01:09:17.175 --> 01:09:19.175
Even trial and error is
going to be good enough.

01:09:22.770 --> 01:09:26.479
Now that's going to be
the size of the field.

01:09:26.479 --> 01:09:30.109
It's going to be
a field of size q.

01:09:30.109 --> 01:09:33.319
And now we're going to pick
a non-Boolean assignment

01:09:33.319 --> 01:09:34.340
to the variables.

01:09:44.177 --> 01:09:46.010
We're going to pick a
non-Boolean assignment

01:09:46.010 --> 01:09:54.900
to the variables and evaluate
the two branching programs

01:09:54.900 --> 01:09:59.280
on that non-Boolean assignment
using the arithmetization.

01:09:59.280 --> 01:10:01.710
If they agree,
then we'll accept.

01:10:01.710 --> 01:10:05.570
If they don't agree, then
we're going to reject.

01:10:05.570 --> 01:10:08.160
Now we have to argue
that this works.

01:10:08.160 --> 01:10:10.637
So we're going to first of
all arithmetize these two

01:10:10.637 --> 01:10:12.095
branching programs,
and we're going

01:10:12.095 --> 01:10:14.490
to get these two polynomials.

01:10:14.490 --> 01:10:19.990
They each have the form that--
as I described, so a bunch

01:10:19.990 --> 01:10:22.510
of rows that correspond to
the truth tables of those two

01:10:22.510 --> 01:10:24.505
respective branching programs.

01:10:27.310 --> 01:10:29.920
First claim-- that if the
branching programs were

01:10:29.920 --> 01:10:34.270
equivalent, so they compute
the same Boolean function,

01:10:34.270 --> 01:10:38.002
then the two polynomials
agree everywhere.

01:10:40.840 --> 01:10:42.640
So then the two
branching programs

01:10:42.640 --> 01:10:47.997
are going to get the same
value on every non-Boolean case

01:10:47.997 --> 01:10:49.330
as well as on the Boolean cases.

01:10:49.330 --> 01:10:50.710
So they agree in the Boolean.

01:10:50.710 --> 01:10:53.380
That means they always agree,
even on the non-Boolean.

01:10:53.380 --> 01:10:56.350
And I kind of
argued that already.

01:10:56.350 --> 01:11:00.220
The other point is that if the
two branching programs are not

01:11:00.220 --> 01:11:04.960
equivalent, so they differ
at some Boolean value,

01:11:04.960 --> 01:11:09.490
now picking a random value
for the polynomial evaluation,

01:11:09.490 --> 01:11:12.850
you're going to have only a
1/3 chance that they're going

01:11:12.850 --> 01:11:15.440
to agree, so a small chance.

01:11:20.340 --> 01:11:25.240
All right, so now let's
prove these two facts.

01:11:25.240 --> 01:11:26.880
The first one I
already kind of argued.

01:11:26.880 --> 01:11:29.430
If the two branching
programs agree

01:11:29.430 --> 01:11:34.280
on all the Boolean values,
then their functions

01:11:34.280 --> 01:11:36.940
have the same truth table.

01:11:36.940 --> 01:11:39.030
So then the polynomials
are identical

01:11:39.030 --> 01:11:42.030
because the polynomials
correspond to the truth table.

01:11:44.690 --> 01:11:47.492
And so therefore, they
always agree, even

01:11:47.492 --> 01:11:48.575
on the non-Boolean values.

01:11:54.150 --> 01:11:56.970
So that means that
the probability

01:11:56.970 --> 01:12:02.040
that if you evaluate the two
polynomials on a random place,

01:12:02.040 --> 01:12:05.820
whether they'll be equal, that's
a certainty, because in fact,

01:12:05.820 --> 01:12:08.820
in this case, p1 and p2
are the same polynomial.

01:12:12.770 --> 01:12:19.490
Now for two, if the branching
programs differ somewhere,

01:12:19.490 --> 01:12:23.000
even in one place, well you
know the polynomials could not

01:12:23.000 --> 01:12:24.510
be the same.

01:12:24.510 --> 01:12:26.780
They have to be
different polynomials

01:12:26.780 --> 01:12:30.440
because the polynomials include
the behavior in the Boolean

01:12:30.440 --> 01:12:34.410
case as well as all
the rest of the field.

01:12:34.410 --> 01:12:36.300
So the polynomials
have to be the same.

01:12:36.300 --> 01:12:39.120
And now we're going to apply
the Schwartz-Zippel lemma.

01:12:39.120 --> 01:12:45.140
We have two different
polynomials.

01:12:45.140 --> 01:12:47.900
They can only agree in a
relatively small number

01:12:47.900 --> 01:12:49.620
of places.

01:12:49.620 --> 01:12:53.750
So that says that, from the
Schwartz-Zippel theorem,

01:12:53.750 --> 01:12:57.440
then the probability
that p1 and p2 agree

01:12:57.440 --> 01:13:00.530
at this random location
is at most this value

01:13:00.530 --> 01:13:03.200
that we had from
before, the degree

01:13:03.200 --> 01:13:04.850
times the number of
variables divided

01:13:04.850 --> 01:13:07.410
by the size of the field.

01:13:07.410 --> 01:13:08.340
The degree is 1.

01:13:11.500 --> 01:13:15.490
And the field is
at least 3 times

01:13:15.490 --> 01:13:17.380
the number of variables in size.

01:13:17.380 --> 01:13:21.770
So that means you get
this inequality here.

01:13:21.770 --> 01:13:25.700
And so therefore, the
probability is a 1/3--

01:13:25.700 --> 01:13:28.040
at most 1/3.

01:13:28.040 --> 01:13:30.240
And that's good enough.

01:13:30.240 --> 01:13:32.600
This is the probability that
you get the wrong answer is

01:13:32.600 --> 01:13:34.215
going to be at most 1/3.

01:13:34.215 --> 01:13:35.840
So you're going to
get the right answer

01:13:35.840 --> 01:13:37.280
with at least 2/3 probability.

01:13:37.280 --> 01:13:40.070
So even just doing a
single sample point

01:13:40.070 --> 01:13:43.416
is going to be enough to
give it a PPP algorithm.

01:13:46.420 --> 01:13:50.380
What I have are a couple of
check-ins here now for you.

01:13:54.470 --> 01:13:58.550
Whoops, somehow this-- going
to take me out of here.

01:14:02.790 --> 01:14:06.325
All right, so this
is a little hard,

01:14:06.325 --> 01:14:08.650
but let's see how you do on it.

01:14:08.650 --> 01:14:12.220
Suppose the branching
program is--

01:14:12.220 --> 01:14:14.560
well, maybe I a little bit
discussed this already,

01:14:14.560 --> 01:14:15.270
but that's OK.

01:14:15.270 --> 01:14:17.020
The branching programs
were not read once.

01:14:17.020 --> 01:14:20.050
The polynomials might have
exponents bigger than 1.

01:14:20.050 --> 01:14:24.040
So where would the proof fail?

01:14:24.040 --> 01:14:28.450
Would they fail at the point
where b1 and equivalent to b2

01:14:28.450 --> 01:14:30.530
implies that they agree
on all Boolean inputs?

01:14:30.530 --> 01:14:34.000
So that's the first step here.

01:14:34.000 --> 01:14:38.110
Or was it that agreeing
on all Boolean inputs

01:14:38.110 --> 01:14:40.920
implies that the
polynomials are the same?

01:14:40.920 --> 01:14:44.430
Or would it be that having the
two polynomials being equal

01:14:44.430 --> 01:14:46.640
implies that they always agree?

01:14:46.640 --> 01:14:52.850
So those are the three steps
in the proof of part one.

01:14:52.850 --> 01:14:54.220
So let's see.

01:14:54.220 --> 01:14:55.220
What do you think there?

01:14:57.255 --> 01:14:58.630
I'm getting a
couple of questions

01:14:58.630 --> 01:14:59.922
about picking the prime number.

01:15:04.770 --> 01:15:08.040
The prime number here is--

01:15:08.040 --> 01:15:11.370
this is a very
small prime number.

01:15:11.370 --> 01:15:15.067
You could even represent
that prime number in unary

01:15:15.067 --> 01:15:17.400
within the amount of time we
have, because don't forget,

01:15:17.400 --> 01:15:21.300
this is a prime number
whose magnitude is at most

01:15:21.300 --> 01:15:22.300
the number of variables.

01:15:22.300 --> 01:15:24.390
So you can write that
prime number in unary.

01:15:24.390 --> 01:15:31.870
And finding the prime
and testing primality,

01:15:31.870 --> 01:15:33.610
testing whether the
number is prime,

01:15:33.610 --> 01:15:35.350
is something that
you can do even

01:15:35.350 --> 01:15:40.870
with a brute-force algorithm,
and it would be good enough.

01:15:40.870 --> 01:15:44.110
You don't have to do anything
fancy about testing primality

01:15:44.110 --> 01:15:44.665
in this case.

01:15:47.530 --> 01:15:49.600
So why does it have to be prime?

01:15:49.600 --> 01:15:55.180
You need it to prime in
order for it to be a field.

01:15:55.180 --> 01:15:58.940
So this is just
the algebra part.

01:15:58.940 --> 01:16:00.800
If you did not have
a prime number,

01:16:00.800 --> 01:16:03.650
then some of the field
properties don't work.

01:16:03.650 --> 01:16:07.220
And you may no
longer get the fact

01:16:07.220 --> 01:16:11.980
that the polynomial has
a small number of roots.

01:16:11.980 --> 01:16:17.940
So that's all I
can say about that.

01:16:17.940 --> 01:16:19.620
Is the polynomial
like a hash function

01:16:19.620 --> 01:16:21.060
for the branching program?

01:16:21.060 --> 01:16:22.650
Are they equal if
they are the same,

01:16:22.650 --> 01:16:24.360
but sometimes the
value is also equal

01:16:24.360 --> 01:16:25.890
if the programs are different?

01:16:25.890 --> 01:16:28.920
That's an interesting idea.

01:16:28.920 --> 01:16:31.050
Is the polynomial acting
like a hash function?

01:16:31.050 --> 01:16:33.480
I think there is something
to what you're saying,

01:16:33.480 --> 01:16:35.730
but I think it's actually
in the other direction.

01:16:40.850 --> 01:16:43.520
It's related to a hash function,
but it's actually acting more

01:16:43.520 --> 01:16:46.710
like an error-correcting code.

01:16:46.710 --> 01:16:47.840
Let's save that for later.

01:16:47.840 --> 01:16:48.660
It's a very good point.

01:16:48.660 --> 01:16:49.743
It's a very good question.

01:16:49.743 --> 01:16:53.780
Maybe we can talk about
it after if you remind me.

01:16:53.780 --> 01:16:56.150
OK, let's end this poll here.

01:16:58.770 --> 01:17:04.400
Should C be-- if
having these two agree

01:17:04.400 --> 01:17:09.890
implies-- well, I mean,
the question is, should we

01:17:09.890 --> 01:17:14.650
change p1 and p2 always agree
to b1 and b2 always agree?

01:17:14.650 --> 01:17:17.290
Well, b1 and b2 are
behaving exactly the way p1

01:17:17.290 --> 01:17:19.435
and p2 behave, so I'm not
sure it really matters.

01:17:24.250 --> 01:17:26.500
Too much time on this
chat, on this poll here.

01:17:26.500 --> 01:17:28.590
Let's end this poll--

01:17:28.590 --> 01:17:29.905
oh, sharing results.

01:17:34.130 --> 01:17:37.520
Yeah, so the
correct answer is B,

01:17:37.520 --> 01:17:39.290
that agreeing on
all Boolean inputs

01:17:39.290 --> 01:17:42.860
implies that they are equal.

01:17:42.860 --> 01:17:44.930
The other two
follow immediately.

01:17:44.930 --> 01:17:46.140
They're still true.

01:17:46.140 --> 01:17:48.980
But if it's not read
once, even though they

01:17:48.980 --> 01:17:51.620
agree on all the Boolean
inputs, they won't necessarily

01:17:51.620 --> 01:17:54.530
agree as polynomials.

01:17:54.530 --> 01:17:59.180
For one thing, if you just take
the two polynomials x1 squared

01:17:59.180 --> 01:18:03.690
and x1, they agree on
all the Boolean inputs,

01:18:03.690 --> 01:18:06.750
but they're not the same.

01:18:06.750 --> 01:18:09.720
They agree in the Boolean
world, because 0 squared is 0,

01:18:09.720 --> 01:18:10.950
and 1 squared is 1.

01:18:10.950 --> 01:18:14.950
But they're not the
same polynomial.

01:18:14.950 --> 01:18:15.670
Let's move on.

01:18:15.670 --> 01:18:18.790
Actually, I have
another check-in

01:18:18.790 --> 01:18:21.852
on the same slide here.

01:18:21.852 --> 01:18:23.560
And this is actually
answering a question

01:18:23.560 --> 01:18:25.030
that I got in the chat.

01:18:25.030 --> 01:18:26.050
If p1 and p2 were--

01:18:29.160 --> 01:18:30.990
how big are these polynomials?

01:18:30.990 --> 01:18:33.330
These look like
they could be big.

01:18:33.330 --> 01:18:35.700
If they're exponentially
large, would that

01:18:35.700 --> 01:18:37.380
be a problem for
the time complexity?

01:18:40.210 --> 01:18:44.160
So pick A or B here.

01:18:44.160 --> 01:18:45.810
We're running out of time here.

01:18:45.810 --> 01:18:52.410
So why don't I not say too much
and just let you go with it.

01:18:55.150 --> 01:18:58.100
I'm going to close this down.

01:18:58.100 --> 01:18:58.950
All in?

01:19:01.900 --> 01:19:06.590
Well, oh, my god, by one point.

01:19:11.060 --> 01:19:14.080
This is like Georgia here--

01:19:14.080 --> 01:19:16.420
do a recount.

01:19:16.420 --> 01:19:24.160
In fact, B is correct by a hair.

01:19:24.160 --> 01:19:25.720
They are not polynomial in size.

01:19:25.720 --> 01:19:29.020
The truth tables
can be very large.

01:19:29.020 --> 01:19:33.190
As we did with the
branching program

01:19:33.190 --> 01:19:38.260
for the exclusive or
case, you don't actually

01:19:38.260 --> 01:19:40.330
write down the polynomials
to evaluate them.

01:19:40.330 --> 01:19:42.700
You can evaluate them
as you're going along.

01:19:42.700 --> 01:19:44.570
The polynomials are huge.

01:19:44.570 --> 01:19:46.570
But you don't have to
write down the polynomials

01:19:46.570 --> 01:19:47.410
to evaluate them.

01:19:47.410 --> 01:19:48.670
That's only part of the proof.

01:19:52.030 --> 01:19:54.760
The algorithm doesn't have
to deal with the polynomials

01:19:54.760 --> 01:20:01.650
itself, so maybe good
to think about this.

01:20:01.650 --> 01:20:03.510
And somebody says, did
I invent this proof?

01:20:03.510 --> 01:20:05.130
No, I did not invent this proof.

01:20:05.130 --> 01:20:07.410
It's a wonderful proof,
but it's not mine.

01:20:07.410 --> 01:20:08.870
I would love to have been--

01:20:08.870 --> 01:20:11.310
get to take the credit for it.

01:20:11.310 --> 01:20:16.080
So why don't we wrap this up?

01:20:18.990 --> 01:20:21.480
Is there some way to
simplify the polynomials

01:20:21.480 --> 01:20:24.360
as we're going along
so that we don't end up

01:20:24.360 --> 01:20:28.800
with them being too big and
so that we can then just

01:20:28.800 --> 01:20:29.820
look at the polynomials?

01:20:29.820 --> 01:20:30.900
Not that I know of.

01:20:35.320 --> 01:20:38.760
I think the polynomials
are really going to be big.

01:20:38.760 --> 01:20:43.620
And so there's not going to be
any way to view it just as--

01:20:43.620 --> 01:20:45.120
if you could, it
would be fantastic,

01:20:45.120 --> 01:20:48.378
because that would give you
a deterministic algorithm.

01:20:48.378 --> 01:20:49.920
I think the only
way that people know

01:20:49.920 --> 01:20:53.280
how to do this in
terms of random inputs

01:20:53.280 --> 01:20:55.440
to a polynomial, which
is too big to write down.

01:20:55.440 --> 01:20:58.410
If you could write it down and
just analyze the polynomials,

01:20:58.410 --> 01:21:00.750
you'd have a huge,
huge result there.

01:21:06.475 --> 01:21:08.770
Oh, I'm glad people
like this proof.

01:21:08.770 --> 01:21:09.460
That's good.

01:21:14.520 --> 01:21:16.930
How many actual quantities
are there in the formula?

01:21:16.930 --> 01:21:18.150
I'm not sure what that means.

01:21:18.150 --> 01:21:20.550
What formula?

01:21:20.550 --> 01:21:23.600
I mean, the polynomial is huge.

01:21:23.600 --> 01:21:25.570
The number of
different polynomials--

01:21:25.570 --> 01:21:28.460
well, I guess I don't
understand the question.

01:21:28.460 --> 01:21:32.805
What motivates the idea
of arithmetization?

01:21:32.805 --> 01:21:35.115
What would make
somebody think of this?

01:21:35.115 --> 01:21:36.750
I'm not sure, actually.

01:21:41.360 --> 01:21:44.930
But we're going to use it
even in a more remarkable way

01:21:44.930 --> 01:21:50.340
in the last two lectures of
the course, so stay tuned.

01:21:50.340 --> 01:21:53.540
I mean, this is sort of clever,
but seems very specialized.

01:21:53.540 --> 01:21:57.920
But the next part, where we
go to the next application,

01:21:57.920 --> 01:22:00.140
we're going to use this
to analyze satisfiability,

01:22:00.140 --> 01:22:02.850
which is a much more
general kind of a situation.

01:22:02.850 --> 01:22:05.600
And that, I think, is
especially remarkable.

01:22:13.160 --> 01:22:20.320
For the polynomials p1 and p2,
it's only a polynomial number--

01:22:20.320 --> 01:22:21.760
I don't think so, because--

01:22:21.760 --> 01:22:23.860
well, it depends on
the size of the field.

01:22:23.860 --> 01:22:25.960
The size of-- no, it's
going to be something

01:22:25.960 --> 01:22:29.710
like m to the mth power, right?

01:22:29.710 --> 01:22:33.070
So those are the number
of possible inputs.

01:22:33.070 --> 01:22:39.430
Each field element has 3m
possibilities, roughly.

01:22:39.430 --> 01:22:41.830
And there are m field
elements, so it's

01:22:41.830 --> 01:22:47.180
m to the 3m different
possible inputs

01:22:47.180 --> 01:22:49.170
that you're picking at random.

01:22:49.170 --> 01:22:51.740
So anyway, I'm going to
shut this down and move over

01:22:51.740 --> 01:22:56.510
to the office hours Zoom.

01:22:56.510 --> 01:22:57.950
Feel free to join me there.

01:22:57.950 --> 01:23:01.330
Otherwise, I will see
you all on Thursday.

01:23:01.330 --> 01:23:02.930
Take care.