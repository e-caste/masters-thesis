WEBVTT

00:00:00.080 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.810
Commons license.

00:00:03.810 --> 00:00:06.060
Your support will help
MIT OpenCourseWare

00:00:06.060 --> 00:00:10.150
continue to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.305
at ocw.mit.edu.

00:00:25.735 --> 00:00:26.610
PROFESSOR: All right.

00:00:26.610 --> 00:00:29.140
Welcome back to 6.890.

00:00:29.140 --> 00:00:32.970
Today we're going to look at
a bunch of different graph

00:00:32.970 --> 00:00:35.440
problems, that is, their
unifying feature is

00:00:35.440 --> 00:00:36.830
they're problems on graphs.

00:00:36.830 --> 00:00:40.080
We're going to look
at vertex cover,

00:00:40.080 --> 00:00:43.680
we're going to look at
vertex coloring of graphs,

00:00:43.680 --> 00:00:47.600
and we're going to look at some
ordering problems on graphs,

00:00:47.600 --> 00:00:52.710
and I think, one more,
orientations of graphs.

00:00:52.710 --> 00:00:54.910
So these are all going to
be some kind of constraint

00:00:54.910 --> 00:00:56.710
that we place on the
graph or something we

00:00:56.710 --> 00:00:58.910
want to do with the graph.

00:00:58.910 --> 00:01:01.620
This is sort of a
miscellaneous lecture.

00:01:01.620 --> 00:01:04.360
We've spent a lot of
time talking about 3SAT,

00:01:04.360 --> 00:01:08.860
most recently Hamiltonicity, and
before all that, 3-partition,

00:01:08.860 --> 00:01:14.150
which are the most popular,
most useful, I would say,

00:01:14.150 --> 00:01:15.995
ways of doing NP
hardness reductions.

00:01:15.995 --> 00:01:17.370
But there are few
others that are

00:01:17.370 --> 00:01:22.610
good to know that are sometimes
relevant, and so this is that.

00:01:22.610 --> 00:01:25.230
Each one is a little
bit smaller in content,

00:01:25.230 --> 00:01:28.000
so we're just going to
lump them all together.

00:01:28.000 --> 00:01:30.570
So we'll start
with vertex cover.

00:01:30.570 --> 00:01:32.590
We saw this slide
from lecture four,

00:01:32.590 --> 00:01:35.620
I think, from planar 3SAT.

00:01:35.620 --> 00:01:38.950
Lichtenstein proved
planar vertex covers hard.

00:01:38.950 --> 00:01:41.415
Vertex cover, remember,
is this problem.

00:01:48.320 --> 00:01:51.500
You want to choose
a set of vertices,

00:01:51.500 --> 00:01:55.735
let's say k vertices,
to hit all the edges.

00:02:01.004 --> 00:02:03.420
A different way of thinking
about this problem-- and a lot

00:02:03.420 --> 00:02:06.380
of these problems, you can think
of in a more logical context,

00:02:06.380 --> 00:02:16.800
formulas and so on-- this is
essentially a form of 2SAT

00:02:16.800 --> 00:02:23.825
with k true variables.

00:02:23.825 --> 00:02:26.520
It's even a positive 2SAT.

00:02:30.100 --> 00:02:32.470
Because essentially,
you could think

00:02:32.470 --> 00:02:35.280
of there being a
variable for each vertex,

00:02:35.280 --> 00:02:37.594
whether you choose
it, and then the edge

00:02:37.594 --> 00:02:39.510
is just stating the
constraint that you should

00:02:39.510 --> 00:02:42.550
choose one or the
other endpoints

00:02:42.550 --> 00:02:46.230
and so that's a 2SAT constraint.

00:02:46.230 --> 00:02:48.426
And 2SAT is easy,
but when you say,

00:02:48.426 --> 00:02:50.800
I want to solve 2SAT with only
setting k of the variables

00:02:50.800 --> 00:02:53.920
to be true, then it becomes this
NP hard problem vertex cover.

00:02:53.920 --> 00:02:56.460
And so we have-- This was a
reduction from planar 3SAT

00:02:56.460 --> 00:02:59.660
to planar vertex cover, so
we know this problem is hard.

00:02:59.660 --> 00:03:03.190
Let's use it for some
things, and let's also

00:03:03.190 --> 00:03:10.290
prove some even more
related versions are hard.

00:03:10.290 --> 00:03:18.870
So this one was already
maximum degree 3,

00:03:18.870 --> 00:03:22.120
if we have some unused copies,
we'll get degree 2 vertices,

00:03:22.120 --> 00:03:24.120
but certainly every vertex
is at most degree 3.

00:03:24.120 --> 00:03:28.250
And it was planar, so
that's already cool.

00:03:28.250 --> 00:03:37.910
Planar max degree 3 is hard.

00:03:37.910 --> 00:03:40.850
Some polynomial versions
to be careful of if you're

00:03:40.850 --> 00:03:45.680
using vertex cover
as a starting point.

00:03:45.680 --> 00:03:48.565
One is what I call
exact vertex cover.

00:03:54.590 --> 00:04:07.815
Each edge is incident to
exactly one chosen vertex.

00:04:12.720 --> 00:04:15.360
So the vertex cover could
be one or the other.

00:04:15.360 --> 00:04:22.960
If you have exclusively, or
between those two, it's easy.

00:04:22.960 --> 00:04:25.810
And another version,
sort of the duel

00:04:25.810 --> 00:04:28.680
between vertices
and edges, one might

00:04:28.680 --> 00:04:33.730
call it edge cover,
which would be choose

00:04:33.730 --> 00:04:35.180
k edges to hit all vertices.

00:04:42.885 --> 00:04:46.780
AUDIENCE: Doesn't exact
edge cover perfect matching?

00:04:46.780 --> 00:04:51.500
PROFESSOR: Exact vertex cover
is perfect matching, thank you.

00:04:51.500 --> 00:04:53.560
This is also essentially
maximum cardinality

00:04:53.560 --> 00:04:57.567
matching because the more
you can be a matching,

00:04:57.567 --> 00:04:59.150
the more efficient
you're going to be,

00:04:59.150 --> 00:05:01.280
and then every isolated
vertex after you

00:05:01.280 --> 00:05:02.820
have a maximum
cardinality matching,

00:05:02.820 --> 00:05:04.611
you just have to cover
those with one more.

00:05:04.611 --> 00:05:06.470
So both of these
reduce to matching.

00:05:06.470 --> 00:05:10.390
So it's obvious in
hindsight, but be careful,

00:05:10.390 --> 00:05:13.750
if you're ever doing vertex
cover, not to accidentally do

00:05:13.750 --> 00:05:16.050
one of these.

00:05:16.050 --> 00:05:18.370
OK, so this morning's.

00:05:21.930 --> 00:05:24.390
Here's a cool version
of vertex cover.

00:05:24.390 --> 00:05:25.920
It can be useful.

00:05:25.920 --> 00:05:29.020
We'll use it in a moment to
prove a particular problem

00:05:29.020 --> 00:05:31.800
hard, connected vertex cover.

00:05:31.800 --> 00:05:33.380
So usually, with a
vertex cover, you

00:05:33.380 --> 00:05:34.950
imagine you're just
grabbing vertices

00:05:34.950 --> 00:05:36.480
from all over the graph.

00:05:36.480 --> 00:05:39.130
With connected vertex
cover, you require

00:05:39.130 --> 00:05:43.885
that the chosen vertices
induce a connected subgraph.

00:06:01.120 --> 00:06:05.150
So this is not, obviously,
easier or harder as a problem.

00:06:05.150 --> 00:06:08.100
It's more restrictive
on the cover,

00:06:08.100 --> 00:06:13.160
but we can prove that
it's NP hard by reduction

00:06:13.160 --> 00:06:15.417
from this problem.

00:06:15.417 --> 00:06:17.250
And so in particular,
we'll get that it's NP

00:06:17.250 --> 00:06:22.750
hard for planar max
degree 4 graphs.

00:06:38.290 --> 00:06:41.899
So here's the reduction.

00:06:41.899 --> 00:06:43.440
I think this reduction
is quite cool,

00:06:43.440 --> 00:06:46.512
because it uses planarity.

00:06:46.512 --> 00:06:48.220
It may not be necessary
to use planarity,

00:06:48.220 --> 00:06:52.172
but this reduction definitely
uses planarity in a rich way.

00:06:52.172 --> 00:06:54.630
So even if you were trying to
prove this without planarity,

00:06:54.630 --> 00:06:56.402
it would be more awkward.

00:06:56.402 --> 00:06:57.860
So, suppose you
have a planar graph

00:06:57.860 --> 00:07:02.300
and you want to find a minimum
vertex cover in this graph.

00:07:02.300 --> 00:07:04.970
We're going to modify
the graph in this way.

00:07:04.970 --> 00:07:08.360
This is yet another
Garey and Johnson paper.

00:07:08.360 --> 00:07:12.062
So you can see the original
faces of the graph,

00:07:12.062 --> 00:07:13.520
and then for each
face, we're going

00:07:13.520 --> 00:07:19.160
to add in sort of
a copy of the face.

00:07:19.160 --> 00:07:23.750
So also the outside face
gets this kind of curvy copy.

00:07:23.750 --> 00:07:25.860
And so in particular,
at every vertex

00:07:25.860 --> 00:07:29.500
there's now going to be
five copies of the vertex.

00:07:29.500 --> 00:07:32.339
One on the one incident face,
one on the other incident

00:07:32.339 --> 00:07:33.880
face, and then for
every one of these

00:07:33.880 --> 00:07:36.200
we're going to have an
extra leaf hanging off.

00:07:36.200 --> 00:07:37.250
Why leaves?

00:07:37.250 --> 00:07:41.090
Leaves are really cool, or
really annoying, or whatever.

00:07:41.090 --> 00:07:45.750
They're very forceful in
the case of vertex cover.

00:07:45.750 --> 00:07:49.532
If you look at a leaf--
So here's a leaf.

00:07:49.532 --> 00:07:51.990
It's connected to some vertex
that's presumably not a leaf,

00:07:51.990 --> 00:07:55.470
otherwise there'd be
an isolated component.

00:07:55.470 --> 00:07:59.230
It's never useful to put
this in the vertex cover.

00:07:59.230 --> 00:08:01.360
If you decide to put
this in the vertex cover,

00:08:01.360 --> 00:08:03.110
you might as well
choose this guy instead,

00:08:03.110 --> 00:08:05.054
because this covers more.

00:08:05.054 --> 00:08:07.470
It covers all the edges that
this one did, namely that one

00:08:07.470 --> 00:08:09.942
edge, and some other edges.

00:08:09.942 --> 00:08:11.650
Maybe it was already
in the vertex cover.

00:08:11.650 --> 00:08:12.608
Then it wasn't minimum.

00:08:12.608 --> 00:08:14.190
Then you got smaller.

00:08:14.190 --> 00:08:17.340
But you can assume there is
an optimal solution where

00:08:17.340 --> 00:08:21.540
you never put leaves
in the vertex cover.

00:08:21.540 --> 00:08:24.860
What that means is, wherever
we add a leaf like this,

00:08:24.860 --> 00:08:26.860
it basically forces
you-- It lets

00:08:26.860 --> 00:08:29.697
you know that you might as well
have this in the vertex cover.

00:08:29.697 --> 00:08:32.030
There is an optimal solution
where this is in the vertex

00:08:32.030 --> 00:08:34.760
cover, because the only other
option is that this one is,

00:08:34.760 --> 00:08:36.500
and then you can move it over.

00:08:36.500 --> 00:08:41.520
So these vertices on
the copies of the faces,

00:08:41.520 --> 00:08:45.350
those are all forced to
be in the cover, which

00:08:45.350 --> 00:08:49.730
means this entire copy of the
face, the inset copy the face,

00:08:49.730 --> 00:08:53.260
is completely covered
already, plus these edges

00:08:53.260 --> 00:08:57.110
are covered connecting
the inner copy of the face

00:08:57.110 --> 00:08:58.110
to the original face.

00:09:02.330 --> 00:09:04.450
So there's still stuff to cover.

00:09:04.450 --> 00:09:06.490
So in particular, it's
still interesting to put

00:09:06.490 --> 00:09:08.430
one of the original
vertices in the cover.

00:09:08.430 --> 00:09:12.160
That would cover these
three, now every edge

00:09:12.160 --> 00:09:13.520
got cut into three parts.

00:09:13.520 --> 00:09:16.662
So this would cover
1/3 of the edge.

00:09:16.662 --> 00:09:18.370
The idea is, if you
put this in the cover

00:09:18.370 --> 00:09:20.680
and you cover those
three guys, we still

00:09:20.680 --> 00:09:23.050
have to cover these
two, and we'll

00:09:23.050 --> 00:09:27.240
do that by putting this
vertex in the cover.

00:09:27.240 --> 00:09:29.170
Because one of these two
has to be in in order

00:09:29.170 --> 00:09:32.350
to cover this middle
edge, and the idea

00:09:32.350 --> 00:09:34.530
is that you'll be able to
just put one of them in.

00:09:34.530 --> 00:09:37.070
You'll be able to put
exactly one of these two

00:09:37.070 --> 00:09:40.030
on every subdivided edge, if
and only if there is a vertex

00:09:40.030 --> 00:09:42.660
cover of the right size.

00:09:42.660 --> 00:09:48.720
So if I do the arithmetic
here, the claim

00:09:48.720 --> 00:09:59.280
is we added exactly 5 times
the original number of edges

00:09:59.280 --> 00:10:03.430
to the optimal vertex cover.

00:10:03.430 --> 00:10:13.170
5 because for every original
edge we added 2 here,

00:10:13.170 --> 00:10:16.630
2 here, and then 1 of these too.

00:10:16.630 --> 00:10:21.280
So there were 6 vertices
around this edge that we added,

00:10:21.280 --> 00:10:26.289
and if we can cover, say,
this edge using that vertex

00:10:26.289 --> 00:10:28.080
or cover this edge
using that vertex, which

00:10:28.080 --> 00:10:30.705
is the same as saying that this
original edge is covered by one

00:10:30.705 --> 00:10:33.220
side or the other, then we
only need one of these two guys

00:10:33.220 --> 00:10:35.830
and then we'll get away
with just 5 per edge.

00:10:35.830 --> 00:10:38.850
So the original thing has
a vertex cover of size k

00:10:38.850 --> 00:10:42.130
if and only if this new thing
has a vertex cover size of k

00:10:42.130 --> 00:10:45.460
plus 5 times the
number of edges.

00:10:45.460 --> 00:10:46.770
Question?

00:10:46.770 --> 00:10:51.625
AUDIENCE: What stops you
from taking one of the--

00:10:51.625 --> 00:10:53.500
PROFESSOR: Taking both
of these, for example?

00:10:53.500 --> 00:10:54.040
AUDIENCE: Yeah.

00:10:54.040 --> 00:10:54.330
PROFESSOR: Yeah.

00:10:54.330 --> 00:10:55.913
So that's a good
thing to worry about.

00:10:55.913 --> 00:10:57.810
Maybe you take both
and then you don't

00:10:57.810 --> 00:10:59.580
have to choose either
one, so it doesn't

00:10:59.580 --> 00:11:02.267
look like a vertex cover, but
this is a similar argument

00:11:02.267 --> 00:11:02.850
to the leaves.

00:11:02.850 --> 00:11:04.290
If you choose both
of these guys,

00:11:04.290 --> 00:11:06.640
because you know that
the other four are there,

00:11:06.640 --> 00:11:08.980
you can always move one
of them to the vertex.

00:11:08.980 --> 00:11:11.332
So you'll get a
recover vertex cover.

00:11:11.332 --> 00:11:13.860
AUDIENCE: [INAUDIBLE]
fives times the edges

00:11:13.860 --> 00:11:17.550
plus the number for
vertices because you also

00:11:17.550 --> 00:11:20.235
have to cover the
leaves off the vertices?

00:11:20.235 --> 00:11:21.235
PROFESSOR: These leaves?

00:11:21.235 --> 00:11:21.550
AUDIENCE: No, the one
with the vertices.

00:11:21.550 --> 00:11:23.430
PROFESSOR: Oh, these ones.

00:11:23.430 --> 00:11:24.562
Whoops.

00:11:24.562 --> 00:11:26.020
Oh, so it looks
like they're always

00:11:26.020 --> 00:11:28.180
increasing the degree to 4.

00:11:28.180 --> 00:11:30.680
Connected vertex, however, is
actually an important problem.

00:11:30.680 --> 00:11:32.840
People think about it a lot.

00:11:32.840 --> 00:11:35.810
For some kind of
networking applications,

00:11:35.810 --> 00:11:38.350
you want to build some backbone
that can reach everybody,

00:11:38.350 --> 00:11:41.260
you need a connected network.

00:11:41.260 --> 00:11:44.380
But Garey and Johnson's
original motivation

00:11:44.380 --> 00:11:48.707
for introducing that problem is
rectilinear Steiner tree, also

00:11:48.707 --> 00:11:50.040
an important networking problem.

00:11:50.040 --> 00:11:53.810
Steiner tree is about
usually you imagine

00:11:53.810 --> 00:11:57.262
you're given some space where
you can build a network,

00:11:57.262 --> 00:11:59.720
and you're given some things
that you want to interconnect.

00:11:59.720 --> 00:12:04.206
So maybe you're building a
new city around some existing

00:12:04.206 --> 00:12:06.080
houses, you're given
some points in the plane

00:12:06.080 --> 00:12:07.370
that represent houses.

00:12:07.370 --> 00:12:09.745
Now you want to build roads
to connect them all together.

00:12:09.745 --> 00:12:12.220
You want to minimize the amount
of roads you have to build,

00:12:12.220 --> 00:12:13.760
so you're going to build a tree.

00:12:13.760 --> 00:12:16.880
And Steiner tree means that
you can add intersections

00:12:16.880 --> 00:12:20.920
wherever you want, as opposed
to a minimum spanning tree,

00:12:20.920 --> 00:12:25.150
where you can only turn
at the given vertices.

00:12:25.150 --> 00:12:33.249
If you have some points
like this in the plane,

00:12:33.249 --> 00:12:34.790
the best way to
connect them together

00:12:34.790 --> 00:12:38.870
in the Euclidean metric is
to have-- I didn't draw it

00:12:38.870 --> 00:12:43.070
super well-- to have
120 degree angles at all

00:12:43.070 --> 00:12:45.490
the intersections,
something you can prove.

00:12:45.490 --> 00:12:48.320
Here, we're thinking about
rectilinear Steiner tree, which

00:12:48.320 --> 00:12:51.610
is the Manhattan version,
where you're only

00:12:51.610 --> 00:12:57.660
allowed to draw orthogonal
connections, like that.

00:12:57.660 --> 00:12:59.170
So you can still
add extra vertices

00:12:59.170 --> 00:13:00.836
if you want to minimize
the total length

00:13:00.836 --> 00:13:04.170
of these connections given
endpoints in the plane.

00:13:04.170 --> 00:13:08.490
This problem is NP hard,
and you can prove it

00:13:08.490 --> 00:13:09.630
in a very simple way.

00:13:09.630 --> 00:13:15.130
This is the reduction
from the previous problem.

00:13:15.130 --> 00:13:18.030
So the first step
is-- And the reason

00:13:18.030 --> 00:13:20.750
they care about max degree
4 in the previous problem

00:13:20.750 --> 00:13:24.640
is to draw the graph in the
plane in orthogonal drawings.

00:13:24.640 --> 00:13:26.890
So every vertex becomes
a point, every edge

00:13:26.890 --> 00:13:29.520
become some orthogonal path
connecting two vertices.

00:13:29.520 --> 00:13:31.800
We've done that in
previous proofs.

00:13:31.800 --> 00:13:34.400
So now everything's drawn in
the plane, something like this.

00:13:34.400 --> 00:13:37.220
And that each
vertex, we're going

00:13:37.220 --> 00:13:42.070
to erase a little
circle of radius 2,

00:13:42.070 --> 00:13:44.450
and then that leaves
a bunch of segments,

00:13:44.450 --> 00:13:47.251
and the segments
connected together,

00:13:47.251 --> 00:13:49.500
and now we're just going to
place along those segments

00:13:49.500 --> 00:13:52.040
a whole bunch of points.

00:13:52.040 --> 00:13:55.210
And so the idea is that
the Steiner tree should

00:13:55.210 --> 00:13:59.350
connect all those together, and
then it's left with a choice.

00:13:59.350 --> 00:14:01.530
And those are all going
to be distance 1 apart.

00:14:01.530 --> 00:14:04.130
Then it's left with a choice
of where to connect things

00:14:04.130 --> 00:14:06.480
together, which vertices.

00:14:06.480 --> 00:14:12.670
So a little bit more
formally, each of these edges

00:14:12.670 --> 00:14:18.750
is going to be scaled up by a
huge factor, 4 times n squared,

00:14:18.750 --> 00:14:22.590
where n, I think, is the
dimension of the n by n grid.

00:14:22.590 --> 00:14:27.460
So these are the original
grids, the dash lines.

00:14:27.460 --> 00:14:30.440
Originally, when you draw
it on a graph, on a grid,

00:14:30.440 --> 00:14:32.360
you imagine probably
these are unit length.

00:14:32.360 --> 00:14:37.050
Scale it up to the length
4n squared and then the rule

00:14:37.050 --> 00:14:40.220
is, wherever you have an
integer point along that line,

00:14:40.220 --> 00:14:41.450
add a dot.

00:14:41.450 --> 00:14:44.530
And so they will be spaced
with distances of 1.

00:14:44.530 --> 00:14:47.240
Over here, we have
distances of 2

00:14:47.240 --> 00:14:51.680
between the vertex, which is
not actually a point in the set,

00:14:51.680 --> 00:14:52.950
and here.

00:14:52.950 --> 00:14:56.700
And so distance of 4 between
any pairs of those points.

00:14:56.700 --> 00:14:59.350
Because these
distances are so huge,

00:14:59.350 --> 00:15:02.990
you never want to connect from
here to anywhere else that's

00:15:02.990 --> 00:15:05.500
not at this local intersection.

00:15:05.500 --> 00:15:06.470
OK?

00:15:06.470 --> 00:15:08.010
And there's an
argument about that,

00:15:08.010 --> 00:15:10.860
looking at these regions
of where you could possibly

00:15:10.860 --> 00:15:14.690
want to go, and there's only
those endpoints in there

00:15:14.690 --> 00:15:16.350
and these are really
cheap to connect.

00:15:16.350 --> 00:15:18.516
So it really only pays to
connect things in between.

00:15:21.570 --> 00:15:23.090
So basically, you
show that you're

00:15:23.090 --> 00:15:26.560
forced to do all the
unit length connections,

00:15:26.560 --> 00:15:29.800
and now you just have to
make the thing connected.

00:15:29.800 --> 00:15:30.460
Question?

00:15:30.460 --> 00:15:32.307
AUDIENCE: Why 2?

00:15:32.307 --> 00:15:33.890
PROFESSOR: Because
2 is bigger than 1.

00:15:37.270 --> 00:15:37.770
Yeah?

00:15:37.770 --> 00:15:40.103
AUDIENCE: I guess with the
vertex covers that you'd want

00:15:40.103 --> 00:15:42.505
to fill in that whole cross?

00:15:42.505 --> 00:15:45.590
But maybe there's a fear
that you would just connect--

00:15:45.590 --> 00:15:46.460
PROFESSOR: No.

00:15:46.460 --> 00:15:48.230
You won't fill in the whole
cross in the vertex cover.

00:15:48.230 --> 00:15:49.730
Let me tell what
you're going to do.

00:15:52.020 --> 00:15:55.280
This proof is-- I mean, the
reduction is super simple,

00:15:55.280 --> 00:15:58.390
but the argument is confusing.

00:15:58.390 --> 00:16:01.340
So here's the idea.

00:16:58.330 --> 00:17:00.480
So there's essentially
two things going on,

00:17:00.480 --> 00:17:02.400
but let's first
think about the case

00:17:02.400 --> 00:17:06.390
where I give you a connected
vertex cover of some size.

00:17:06.390 --> 00:17:11.310
What I'm going to do is
first-- or you can think

00:17:11.310 --> 00:17:13.740
of it in either order--
I'm, in particular,

00:17:13.740 --> 00:17:16.774
going to connect all
the vertices together.

00:17:16.774 --> 00:17:19.190
Now, there's no particular
reason to connect the vertices,

00:17:19.190 --> 00:17:21.829
but I'm just going to do it
anyway, or think about doing it

00:17:21.829 --> 00:17:25.220
anyway, by a spanning tree.

00:17:25.220 --> 00:17:27.427
So there's lots of
redundant connectivity here.

00:17:27.427 --> 00:17:29.010
I don't need to
connect this, to this,

00:17:29.010 --> 00:17:30.440
to this all the way around.

00:17:30.440 --> 00:17:32.360
I can drop one of
those connections

00:17:32.360 --> 00:17:34.800
because I just need
to be connected,

00:17:34.800 --> 00:17:36.350
I just need a spanning tree.

00:17:36.350 --> 00:17:43.530
And in general, there are v
vertices to connect together,

00:17:43.530 --> 00:17:50.140
and each one of them costs
2, in a certain sense.

00:17:50.140 --> 00:17:53.800
To connect a vertex to
an incident edge costs 2.

00:17:53.800 --> 00:17:57.000
And so there are v minus 1
edges in the spanning tree,

00:17:57.000 --> 00:17:58.474
so I'm going to pay that.

00:17:58.474 --> 00:18:00.390
On the other hand, I
also knew that every edge

00:18:00.390 --> 00:18:02.570
is connected to some vertex.

00:18:02.570 --> 00:18:04.730
That's the vertex
cover constraint,

00:18:04.730 --> 00:18:06.890
and so every edge is
going to pay 2 in order

00:18:06.890 --> 00:18:08.300
to connect to a vertex.

00:18:08.300 --> 00:18:10.772
So the weird thing here is the
involvement of the vertices,

00:18:10.772 --> 00:18:12.230
even though there's
no point there.

00:18:15.650 --> 00:18:17.427
That's funny.

00:18:17.427 --> 00:18:20.010
Maybe we could add a point there
and make it a little clearer,

00:18:20.010 --> 00:18:24.780
but instead of thinking
about connections from edges

00:18:24.780 --> 00:18:27.037
to edges, which
would cost 4, that's

00:18:27.037 --> 00:18:29.370
sort of the wrong way to think
about it, because there's

00:18:29.370 --> 00:18:30.340
two things going on.

00:18:30.340 --> 00:18:32.985
One is just to get the edges
to connect to something,

00:18:32.985 --> 00:18:34.860
and then there's getting
all that something's

00:18:34.860 --> 00:18:36.370
connected together.

00:18:36.370 --> 00:18:38.360
So this is sort of a
spanning tree thing,

00:18:38.360 --> 00:18:42.624
and this is more of the actual
vertex cover constraint.

00:18:42.624 --> 00:18:44.290
Together, they give
the connector vertex

00:18:44.290 --> 00:18:44.998
cover constraint.

00:18:44.998 --> 00:18:47.250
It would be impossible
for a Steiner tree

00:18:47.250 --> 00:18:49.570
to do one without the other.

00:18:49.570 --> 00:18:52.230
But essentially-- I mean,
I'm going to wave my hands

00:18:52.230 --> 00:18:54.340
a little bit here,
but you work it out.

00:18:54.340 --> 00:18:57.520
In all cases, the number
of connections you need

00:18:57.520 --> 00:19:00.080
is exactly this if
there's a vertex cover,

00:19:00.080 --> 00:19:03.261
and this will have to go up
if there isn't a vertex cover.

00:19:06.700 --> 00:19:08.870
That was vertex cover.

00:19:08.870 --> 00:19:11.210
Let's do coloring.

00:19:11.210 --> 00:19:15.550
This will be, I think, more fun.

00:19:15.550 --> 00:19:21.400
So first, let's prove
that coloring is hard.

00:19:21.400 --> 00:19:24.297
So in general, in
the coloring problem,

00:19:24.297 --> 00:19:26.380
also called chromatic
number, you're given a graph

00:19:26.380 --> 00:19:27.880
and you're given a number k.

00:19:27.880 --> 00:19:30.180
You want to color the
vertices of the graph using

00:19:30.180 --> 00:19:33.550
k different colors,
so that's a mapping

00:19:33.550 --> 00:19:37.340
from the vertices
to the colors such

00:19:37.340 --> 00:19:40.280
that no edge is monochromatic.

00:19:46.150 --> 00:19:50.990
So you want a mapping, let's
call it c, from the vertices

00:19:50.990 --> 00:20:07.445
to 1 up to k such that for
every edge, let me call it vw,

00:20:07.445 --> 00:20:11.410
the color of v does not
equal to color of w.

00:20:11.410 --> 00:20:14.150
So that's the no
monochromatic edge constraint.

00:20:14.150 --> 00:20:15.930
It's usual coloring
for vertex coloring.

00:20:15.930 --> 00:20:18.720
You could also talk about
edge coloring and so on,

00:20:18.720 --> 00:20:21.010
and this problem is easy.

00:20:21.010 --> 00:20:25.410
If k is 1, then you
better not have any edges.

00:20:25.410 --> 00:20:27.060
It's easy if k is 2.

00:20:27.060 --> 00:20:28.610
That's bipartiteness testing.

00:20:28.610 --> 00:20:30.890
You can just greedily
color and you can never

00:20:30.890 --> 00:20:33.540
make a mistake unless the
graph isn't bipartite.

00:20:33.540 --> 00:20:36.030
But it becomes hard
when k equals 3,

00:20:36.030 --> 00:20:37.960
so that's a fun transition.

00:20:37.960 --> 00:20:41.680
And so here is why vertex
3-coloring is hard as proved

00:20:41.680 --> 00:20:44.800
by Garey, Johnson, Stockmeyer.

00:20:44.800 --> 00:20:46.860
Reduction from 3SAT.

00:20:46.860 --> 00:20:49.990
So we have, on the one
hand, variable gadget.

00:20:49.990 --> 00:20:56.270
We're going to represent
XI and XI bar like this.

00:20:56.270 --> 00:20:59.160
I mean, coloring should
feel a lot like SAT.

00:20:59.160 --> 00:21:06.460
In fact, you might think
of this as xor 2SAT,

00:21:06.460 --> 00:21:09.510
if you think of xor as
the not equals operator.

00:21:09.510 --> 00:21:15.110
But it's over ternary logic.

00:21:15.110 --> 00:21:17.950
So this gets back to
a question from class.

00:21:17.950 --> 00:21:19.200
What about ternary logic?

00:21:19.200 --> 00:21:22.360
You can think of 3-colorings
like ternary logic,

00:21:22.360 --> 00:21:24.830
just like on the problem set.

00:21:24.830 --> 00:21:28.540
So what we're going
to do is we're

00:21:28.540 --> 00:21:30.140
going to have one
copy of this gadget.

00:21:30.140 --> 00:21:31.300
I call it a colors gadget.

00:21:31.300 --> 00:21:33.780
It's just a triangle,
and so all three colors

00:21:33.780 --> 00:21:36.040
must appear on that triangle.

00:21:36.040 --> 00:21:38.540
We don't know in what order,
but we don't really care.

00:21:38.540 --> 00:21:41.030
We can just define the one.

00:21:41.030 --> 00:21:43.280
The color that this guy's
assigned, we'll call it red.

00:21:43.280 --> 00:21:45.410
It could be 1, 2, or 3,
but it doesn't matter.

00:21:45.410 --> 00:21:48.300
Call the color that this
guy's assigned green,

00:21:48.300 --> 00:21:50.210
and this one blue,
and hopefully you're

00:21:50.210 --> 00:21:53.480
not sufficiently colorblind to
be unable to distinguish those.

00:21:53.480 --> 00:21:55.710
But I did check with
a color blind tester,

00:21:55.710 --> 00:21:58.460
they do seem at least
different, but it might

00:21:58.460 --> 00:21:59.731
be hard to know the names.

00:21:59.731 --> 00:22:00.230
All right.

00:22:00.230 --> 00:22:04.320
So this green vertex is
connected to both XI and XI bar

00:22:04.320 --> 00:22:06.370
for each of the
variables, which means

00:22:06.370 --> 00:22:08.520
they can either be red or blue.

00:22:08.520 --> 00:22:12.260
And I want to red to mean
false, blue to mean true.

00:22:12.260 --> 00:22:14.832
So that's cool, that's
nice, regular binary logic.

00:22:14.832 --> 00:22:16.790
And then we're going to
combine those variables

00:22:16.790 --> 00:22:18.310
with this clause gadget.

00:22:18.310 --> 00:22:21.420
Clause gadget also has
one node out at the end

00:22:21.420 --> 00:22:23.560
here connected to
both green and red,

00:22:23.560 --> 00:22:25.880
which forces it to be blue.

00:22:25.880 --> 00:22:27.350
But otherwise,
it's kind of free.

00:22:27.350 --> 00:22:29.560
So we have instances
of literals.

00:22:29.560 --> 00:22:31.370
These don't have to
be the positive forms,

00:22:31.370 --> 00:22:34.767
this could be XI bar,
XJ bar, whatever.

00:22:34.767 --> 00:22:36.600
And now we're going to
think about coloring.

00:22:36.600 --> 00:22:39.950
So let me show you a couple
of possible colorings.

00:22:39.950 --> 00:22:41.159
Here's a valid coloring.

00:22:41.159 --> 00:22:43.450
It's valid because at least--
This is going to be 3SAT,

00:22:43.450 --> 00:22:46.640
so at least one of these should
be true, true means blue.

00:22:46.640 --> 00:22:49.930
This guy is blue,
and in general,

00:22:49.930 --> 00:22:52.630
what we're doing is
kind of taking an

00:22:52.630 --> 00:22:58.710
or of this pair and then an
or of that pair with this one

00:22:58.710 --> 00:23:02.380
variable, one
literal, I should say.

00:23:02.380 --> 00:23:07.590
And because this is not
red, I can put red here.

00:23:07.590 --> 00:23:09.420
Again, all three
colors must appear.

00:23:09.420 --> 00:23:11.320
So in general,
what I want to do--

00:23:11.320 --> 00:23:13.850
you'll see why in a moment--
is push the reds as far

00:23:13.850 --> 00:23:15.090
back as possible.

00:23:15.090 --> 00:23:18.640
So if I can put a red or
red here or here, I'm happy,

00:23:18.640 --> 00:23:21.850
and I put some other
color over there.

00:23:21.850 --> 00:23:25.390
I guess I'll put-- It
doesn't matter which

00:23:25.390 --> 00:23:27.830
one is blue or green here.

00:23:27.830 --> 00:23:29.740
As long as I can
put red back here,

00:23:29.740 --> 00:23:32.610
I can also put red back here.

00:23:32.610 --> 00:23:34.290
And it could be if
this one is blue,

00:23:34.290 --> 00:23:35.760
I could also put
the red guy here,

00:23:35.760 --> 00:23:37.070
and I have the flexibility.

00:23:37.070 --> 00:23:39.560
But as long as I can put
red either here or here,

00:23:39.560 --> 00:23:41.850
this one will not be red.

00:23:41.850 --> 00:23:43.920
And furthermore, I
can make it not green,

00:23:43.920 --> 00:23:47.040
and that's what these
constraints tell me.

00:23:47.040 --> 00:23:49.330
This vertex should
not be red or green.

00:23:49.330 --> 00:23:51.040
That's satisfied here.

00:23:51.040 --> 00:23:53.950
And you can show, you
can check all cases,

00:23:53.950 --> 00:23:56.940
or just sort of go
through that argument.

00:23:56.940 --> 00:23:59.660
The only bad case is
when they're all red,

00:23:59.660 --> 00:24:02.280
because then, looking
at this triangle,

00:24:02.280 --> 00:24:04.270
the red one has to
be pushed forward.

00:24:04.270 --> 00:24:06.520
And then, because this one
is red and this one is red,

00:24:06.520 --> 00:24:08.921
again, this red has
to be pushed forward,

00:24:08.921 --> 00:24:10.420
but then we have a
red-red adjacency

00:24:10.420 --> 00:24:12.520
and that's not allowed.

00:24:12.520 --> 00:24:16.740
So that is 3SAT to
vertex 3-coloring.

00:24:16.740 --> 00:24:17.240
Cool.

00:24:17.240 --> 00:24:23.192
Now, this does not
preserve planarity,

00:24:23.192 --> 00:24:24.775
because the colors
gadget is connected

00:24:24.775 --> 00:24:26.990
to pretty much everything,
and it does not

00:24:26.990 --> 00:24:28.860
preserve bounded degree.

00:24:28.860 --> 00:24:29.415
Question.

00:24:29.415 --> 00:24:30.040
AUDIENCE: Yeah.

00:24:30.040 --> 00:24:33.223
The variable gadget doesn't seem
to be connected to the clause

00:24:33.223 --> 00:24:34.002
gadget here.

00:24:34.002 --> 00:24:34.710
PROFESSOR: Sorry.

00:24:34.710 --> 00:24:36.380
I mean, when I
sit right XI here,

00:24:36.380 --> 00:24:38.810
I mean it's the same
vertex as one of these.

00:24:38.810 --> 00:24:39.440
Yeah.

00:24:39.440 --> 00:24:41.655
So if there's n
variables, n clauses,

00:24:41.655 --> 00:24:44.390
it's going to be 2n
of these vertices

00:24:44.390 --> 00:24:48.500
and then they're shared
among the n clauses.

00:24:48.500 --> 00:24:50.520
It's hard to draw,
because actually they're

00:24:50.520 --> 00:24:55.080
identified as opposed
to connected by an edge.

00:24:55.080 --> 00:24:56.911
Other questions?

00:24:56.911 --> 00:24:57.410
All right.

00:24:57.410 --> 00:25:00.910
So I think first
we make it planar.

00:25:00.910 --> 00:25:05.640
We have a new crossover gadget
for specific to 3-coloring.

00:25:05.640 --> 00:25:07.640
Planar 3SAT doesn't seem
to help immediately,

00:25:07.640 --> 00:25:09.080
so we're just going
to, because we

00:25:09.080 --> 00:25:11.040
have all of these
connections from colors

00:25:11.040 --> 00:25:16.720
gadget to everybody,
plug this in whenever

00:25:16.720 --> 00:25:17.830
we have an intersection.

00:25:17.830 --> 00:25:21.250
And the idea, locally,
is that whatever color

00:25:21.250 --> 00:25:22.910
is assigned to this
vertex, x, must

00:25:22.910 --> 00:25:25.080
be the same as the color
assigned to this vertex,

00:25:25.080 --> 00:25:28.700
x prime, and similarly,
y, and y prime.

00:25:28.700 --> 00:25:30.600
And they're free
of each other, you

00:25:30.600 --> 00:25:32.680
can do any assignment to
x, any assignment to y,

00:25:32.680 --> 00:25:34.982
and this will be satisfiable.

00:25:34.982 --> 00:25:37.904
I'll give you some colorings
to give you-- I mean,

00:25:37.904 --> 00:25:40.110
this is essentially two
cases, which is either

00:25:40.110 --> 00:25:43.520
x and x prime have the
same color as y and y prime

00:25:43.520 --> 00:25:45.370
or they have different colors.

00:25:45.370 --> 00:25:46.840
So here's the same
color case, you

00:25:46.840 --> 00:25:49.190
get this nice
rotational symmetry.

00:25:49.190 --> 00:25:53.070
In general, you've
got this wheel pattern

00:25:53.070 --> 00:25:58.100
of four triangles, and
you have some color here,

00:25:58.100 --> 00:26:00.990
and then that forced these guys
to alternate in the other two

00:26:00.990 --> 00:26:04.100
colors available
around that center,

00:26:04.100 --> 00:26:05.780
and then it essentially
communicates

00:26:05.780 --> 00:26:08.230
the information you need.

00:26:08.230 --> 00:26:10.320
It's hard to do sort of
a straight line argument

00:26:10.320 --> 00:26:13.200
about why this is the case,
other than to just try

00:26:13.200 --> 00:26:14.980
all the possibilities.

00:26:14.980 --> 00:26:16.700
But there's, again,
lots of triangles.

00:26:16.700 --> 00:26:19.241
So once you know this is red,
you know one of these is green,

00:26:19.241 --> 00:26:20.980
and one of them is blue.

00:26:20.980 --> 00:26:22.852
Could go one way or the
other at this point.

00:26:22.852 --> 00:26:25.060
I think you could actually
do it one way or the other

00:26:25.060 --> 00:26:26.726
and just flip all the
greens with blues,

00:26:26.726 --> 00:26:30.110
and vice versa, because green
and blue is, in this case,

00:26:30.110 --> 00:26:32.600
local to the gadget.

00:26:32.600 --> 00:26:35.920
And, anyway, you end up with,
once these two are set red,

00:26:35.920 --> 00:26:40.870
these two are forced to
be set red by casework.

00:26:40.870 --> 00:26:45.860
Here is the other case, when
xx prime is different from yy

00:26:45.860 --> 00:26:48.770
prime, or you could say
x and y are different,

00:26:48.770 --> 00:26:51.052
and then, again, it forces
x to propagate through,

00:26:51.052 --> 00:26:52.010
y to propagate through.

00:26:52.010 --> 00:26:56.140
We still get alternation
here, but now the unused color

00:26:56.140 --> 00:26:59.330
is in the center, whereas
before, this picture,

00:26:59.330 --> 00:27:02.380
we had the center color was
the color used by all three,

00:27:02.380 --> 00:27:03.240
or all four of them.

00:27:03.240 --> 00:27:05.260
On the outside
here, it's the color

00:27:05.260 --> 00:27:07.610
that's not any of those two.

00:27:07.610 --> 00:27:13.241
And, again, it's forced
by playing around.

00:27:13.241 --> 00:27:13.740
OK.

00:27:13.740 --> 00:27:16.210
So that means we
have a figure here

00:27:16.210 --> 00:27:18.430
about how you actually
use this crossover

00:27:18.430 --> 00:27:21.460
gadget because there's this
issue of identification,

00:27:21.460 --> 00:27:23.010
which is little bit subtle.

00:27:23.010 --> 00:27:26.170
So if you have an edge that's
crossed by a bunch of edges,

00:27:26.170 --> 00:27:27.660
you intuitively
want to stick this

00:27:27.660 --> 00:27:29.510
into each of the crossings.

00:27:29.510 --> 00:27:32.290
But because this is copying
the value here to here,

00:27:32.290 --> 00:27:34.010
it's really just like
taking this vertex

00:27:34.010 --> 00:27:36.870
and pushing it to the
other side of the edge.

00:27:36.870 --> 00:27:38.830
So when you throw
in this crossover,

00:27:38.830 --> 00:27:42.750
you want to identify the
left vertex of the crossover

00:27:42.750 --> 00:27:46.120
with the original
vertex on the left side,

00:27:46.120 --> 00:27:48.456
but not identify it
on the right side.

00:27:48.456 --> 00:27:49.830
Therefore, overall,
there's still

00:27:49.830 --> 00:27:53.630
one edge connecting x and y
because this is essentially

00:27:53.630 --> 00:27:56.740
a copy of x, but you still
need that edge to connect to y.

00:27:56.740 --> 00:27:58.520
So you don't want to
identify both sides,

00:27:58.520 --> 00:28:00.350
you don't want to
identify on neither side,

00:28:00.350 --> 00:28:02.310
because that would be two edges.

00:28:02.310 --> 00:28:03.220
Identify on one side.

00:28:03.220 --> 00:28:05.750
And it's like a vertex
cover, but you just

00:28:05.750 --> 00:28:10.240
pick one side for
each edge arbitrarily.

00:28:10.240 --> 00:28:15.250
And that is planar vertex
3-coloring not bound

00:28:15.250 --> 00:28:17.101
to degree yet.

00:28:17.101 --> 00:28:17.600
OK?

00:28:17.600 --> 00:28:19.180
Next reduction.

00:28:19.180 --> 00:28:22.690
This is in the same paper.

00:28:22.690 --> 00:28:24.240
Here's how to
simulate high degree.

00:28:24.240 --> 00:28:25.489
I mean, it's pretty intuitive.

00:28:25.489 --> 00:28:27.910
Once you have the
ability to copy color,

00:28:27.910 --> 00:28:32.060
you can use it to
get high degree.

00:28:32.060 --> 00:28:35.280
OK, I'll talk about the actual
degree bound in the moment,

00:28:35.280 --> 00:28:37.520
but let's say we're
aiming for max degree 4.

00:28:40.110 --> 00:28:42.767
This one, you can actually
argue in a very simple way.

00:28:42.767 --> 00:28:43.850
So here's a little gadget.

00:28:43.850 --> 00:28:46.330
I claim it makes three
copies of this color,

00:28:46.330 --> 00:28:49.020
or two copies of the color at x.

00:28:49.020 --> 00:28:50.479
So you've got these
three vertices.

00:28:50.479 --> 00:28:52.145
One of them's blue,
one of them's green.

00:28:52.145 --> 00:28:54.630
Doesn't matter which is which,
but then this vertex must

00:28:54.630 --> 00:28:58.250
be red because of that
triangle, and then this vertex

00:28:58.250 --> 00:29:00.230
must be green because
of that triangle,

00:29:00.230 --> 00:29:02.790
then this vertex must be blue
because of that triangle,

00:29:02.790 --> 00:29:05.750
this one must be red,
and this one must be red.

00:29:05.750 --> 00:29:08.240
So that's a really
easy one to argue.

00:29:08.240 --> 00:29:10.630
And so, this is not
very interesting,

00:29:10.630 --> 00:29:12.330
because we made two copies.

00:29:12.330 --> 00:29:14.020
This will simulate
a degree 3 vertex,

00:29:14.020 --> 00:29:16.090
which we don't worry about.

00:29:16.090 --> 00:29:17.840
But where it gets
interesting, if you just

00:29:17.840 --> 00:29:19.423
string a bunch of
these together here,

00:29:19.423 --> 00:29:21.930
we end up with five
copies of a single color,

00:29:21.930 --> 00:29:24.580
and so you can connect with
a single edge out here,

00:29:24.580 --> 00:29:26.870
let's say.

00:29:26.870 --> 00:29:29.270
I guess you could even
afford two edges there.

00:29:29.270 --> 00:29:31.330
In particular, we can
use this to simulate

00:29:31.330 --> 00:29:38.060
one vertex of degree 5 and we
will end up with max degree 4.

00:29:38.060 --> 00:29:41.210
Degree 4 Because some of
these vertices have degree 4.

00:29:41.210 --> 00:29:43.420
Actually, most of them do.

00:29:43.420 --> 00:29:46.383
AUDIENCE: Could you have just
used the crossover gadget

00:29:46.383 --> 00:29:48.850
as a high degree gadget?

00:29:48.850 --> 00:29:50.101
PROFESSOR: Oh, in a circle.

00:29:50.101 --> 00:29:51.600
Yeah, that would
also work, I think.

00:29:51.600 --> 00:29:52.602
Do you have a problem?

00:29:52.602 --> 00:29:55.060
AUDIENCE: There are degree 7
vertices when you pit together

00:29:55.060 --> 00:29:56.092
two of these?

00:29:56.092 --> 00:29:56.675
You've moved--

00:29:56.675 --> 00:29:58.200
[INTERPOSING VOICES]

00:29:58.200 --> 00:29:59.780
PROFESSOR: Degree 6.

00:29:59.780 --> 00:30:01.570
Yeah.

00:30:01.570 --> 00:30:02.100
Well, OK.

00:30:02.100 --> 00:30:04.050
So that will give
you max degree 6,

00:30:04.050 --> 00:30:05.700
and this gives you max degree 4.

00:30:05.700 --> 00:30:06.210
Yeah.

00:30:06.210 --> 00:30:08.030
If we do is after
the crossover gadget,

00:30:08.030 --> 00:30:10.230
then the crossover
gadget will become happy.

00:30:13.310 --> 00:30:14.420
So what's the conclusion?

00:30:14.420 --> 00:30:24.775
Planar max degree 4,
3-coloring is hard.

00:30:28.040 --> 00:30:38.160
But be careful, max
degree 3, 3-coloring

00:30:38.160 --> 00:30:47.550
is easy polynomial time
unless your graph is k4.

00:30:47.550 --> 00:30:48.900
So one counter example.

00:30:48.900 --> 00:30:50.370
This is always possible.

00:30:50.370 --> 00:30:56.600
This is called Burke's
theorem from 1941.

00:30:56.600 --> 00:30:59.320
So in general, if you
have max degree delta,

00:30:59.320 --> 00:31:02.780
there's a delta coloring unless
a couple of bad things happen.

00:31:02.780 --> 00:31:07.700
Odd cycle or a complete graph.

00:31:07.700 --> 00:31:08.350
So that's cool.

00:31:08.350 --> 00:31:09.891
AUDIENCE: What do
you mean if it's k4

00:31:09.891 --> 00:31:11.990
and then it doesn't work?

00:31:11.990 --> 00:31:14.667
PROFESSOR: k4
requires four colors.

00:31:14.667 --> 00:31:17.000
AUDIENCE: But then when finding
whether or not there's--

00:31:17.000 --> 00:31:19.278
PROFESSOR: But k4
has max degree 3.

00:31:19.278 --> 00:31:21.109
AUDIENCE: [INAUDIBLE]
polynomial figure out

00:31:21.109 --> 00:31:22.150
if there's a 3 colorable?

00:31:22.150 --> 00:31:24.370
PROFESSOR: It's
polynomial in all cases,

00:31:24.370 --> 00:31:27.820
but I'm saying every
max degree 3 graph is

00:31:27.820 --> 00:31:29.790
3 colorable except for k4.

00:31:29.790 --> 00:31:32.070
So the decision
problem is, am I k4.

00:31:32.070 --> 00:31:36.604
Or I guess, am I not k4 would
be the 3-coloring problem.

00:31:36.604 --> 00:31:38.460
AUDIENCE: The word
planar isn't up there.

00:31:38.460 --> 00:31:42.560
PROFESSOR: Right, even without
planar, it's polynomial.

00:31:42.560 --> 00:31:44.420
Don't need planarity
for that algorithm

00:31:44.420 --> 00:31:47.370
for testing for k4ness.

00:31:47.370 --> 00:31:49.950
And I didn't check,
but I'm pretty sure.

00:31:49.950 --> 00:31:51.710
Usually once the
decision problem is easy,

00:31:51.710 --> 00:31:53.739
also the actual coloring
algorithm is easy,

00:31:53.739 --> 00:31:54.530
but I didn't check.

00:31:54.530 --> 00:31:57.770
I assume there's a polynomial
coloring algorithm, not just

00:31:57.770 --> 00:32:00.380
a decision algorithm, but
we should double check

00:32:00.380 --> 00:32:03.798
before you cite that result.

00:32:03.798 --> 00:32:07.375
AUDIENCE: You can
[INAUDIBLE], make

00:32:07.375 --> 00:32:10.245
yourself a [INAUDIBLE] gadget
and then try probing things.

00:32:10.245 --> 00:32:11.120
PROFESSOR: Oh, right.

00:32:11.120 --> 00:32:12.661
You could reduce
the decision problem

00:32:12.661 --> 00:32:14.610
to the actual coloring problem.

00:32:14.610 --> 00:32:16.680
You can test whether two
guys have the same color

00:32:16.680 --> 00:32:19.190
by a bunch of probes.

00:32:19.190 --> 00:32:21.290
OK, so what?

00:32:21.290 --> 00:32:23.410
Why graph coloring?

00:32:23.410 --> 00:32:25.782
There aren't a ton of
proofs that use coloring,

00:32:25.782 --> 00:32:27.740
because usually 3SAT is
simpler because it only

00:32:27.740 --> 00:32:30.270
has binary values, but
there are situations

00:32:30.270 --> 00:32:31.830
where coloring is helpful.

00:32:31.830 --> 00:32:37.080
I have one here that we used in
the context of pushing blocks.

00:32:37.080 --> 00:32:45.030
We covered Push-* is hard,
we covered Push-1 is hard,

00:32:45.030 --> 00:32:48.260
we covered these two
proofs in that lecture,

00:32:48.260 --> 00:32:52.170
and then implied PushPush, but
we didn't talk about Push-X.

00:32:52.170 --> 00:32:54.920
Push-X was the version where
you're not allowed to revisit

00:32:54.920 --> 00:32:56.197
the same square twice.

00:32:56.197 --> 00:32:57.655
Like every time
you leave a square,

00:32:57.655 --> 00:33:00.170
it falls down into
the abyss behind you,

00:33:00.170 --> 00:33:03.050
so you can never step
on that square again.

00:33:03.050 --> 00:33:08.520
So our hardness proof
for that uses coloring,

00:33:08.520 --> 00:33:12.030
and I think it's instructive
not because I care especially

00:33:12.030 --> 00:33:14.820
about Push-1X but it seems
like a general approach

00:33:14.820 --> 00:33:16.340
to representing color.

00:33:16.340 --> 00:33:17.990
So good to see the gadgets.

00:33:17.990 --> 00:33:23.180
First, a simple idea is that,
if I have some planar graph

00:33:23.180 --> 00:33:25.230
I want to take an Euler
tour-- a tour that

00:33:25.230 --> 00:33:28.330
visits every edge
exactly twice--

00:33:28.330 --> 00:33:33.240
and I want to do
that in a planar way.

00:33:33.240 --> 00:33:35.270
So the idea is, I
don't want my tour

00:33:35.270 --> 00:33:37.250
to come down this
way through a vertex

00:33:37.250 --> 00:33:40.450
and then later come through
this way in a vertex.

00:33:40.450 --> 00:33:42.450
That's a meaningful
thing because I

00:33:42.450 --> 00:33:43.910
know that planar
coloring is hard,

00:33:43.910 --> 00:33:45.493
so I'm going to
reduce from planar max

00:33:45.493 --> 00:33:46.816
degree 4, 3-coloring.

00:33:46.816 --> 00:33:48.940
So I've got a planar graph,
I draw it in the plane,

00:33:48.940 --> 00:33:50.465
and then relative
to that drawing,

00:33:50.465 --> 00:33:52.590
I want to make sure there's
no crossings in my tour

00:33:52.590 --> 00:33:55.010
that visits every
edge exactly twice.

00:33:55.010 --> 00:33:57.300
These always exist,
simple inductive proof,

00:33:57.300 --> 00:34:00.510
start with one vertex,
visit the star around it,

00:34:00.510 --> 00:34:03.240
and then just start gluing
these things together.

00:34:03.240 --> 00:34:07.460
In the inductive way, you
will get a planar Eulerian

00:34:07.460 --> 00:34:11.090
tour, standard trick.

00:34:11.090 --> 00:34:12.659
Now we're going
to use that tour.

00:34:12.659 --> 00:34:15.310
So here we see an actual
graph in the dashed lines

00:34:15.310 --> 00:34:19.550
and then we see the Euler
tour in the red lines,

00:34:19.550 --> 00:34:24.520
and the red path is
essentially the tour

00:34:24.520 --> 00:34:28.960
taken by the robot that's
pushing the blocks around.

00:34:28.960 --> 00:34:31.230
So it's walking around in
some direction somewhere--

00:34:31.230 --> 00:34:32.760
I think not drawn here.

00:34:32.760 --> 00:34:34.146
Maybe that.

00:34:34.146 --> 00:34:36.270
I'm going to break this
apart and I'm going to say,

00:34:36.270 --> 00:34:38.269
the robot starts here,
there's an obstacle here,

00:34:38.269 --> 00:34:39.620
and the goal is to get here.

00:34:39.620 --> 00:34:41.830
So your sole purpose
in this puzzle

00:34:41.830 --> 00:34:44.480
is to start here and get
all the way around the loop,

00:34:44.480 --> 00:34:47.050
and you're just going to be
able to go along the red path.

00:34:47.050 --> 00:34:48.310
But there's some interactions.

00:34:48.310 --> 00:34:50.018
There's the blue
arrows, and then there's

00:34:50.018 --> 00:34:53.636
the green, wiggly lines
and that's all you'll need.

00:34:53.636 --> 00:34:55.760
One of them is an equal
constraint, and one of them

00:34:55.760 --> 00:34:56.790
is not equal constraint.

00:34:56.790 --> 00:34:59.230
And the idea is that when
you visit a vertex-- so let's

00:34:59.230 --> 00:35:02.060
say you start here at u-- I'm
going to pick a color-- 1, 2,

00:35:02.060 --> 00:35:05.520
or 3, and there will actually
be three red paths here.

00:35:05.520 --> 00:35:08.330
Then those three red paths
will interact with these three

00:35:08.330 --> 00:35:11.540
red paths to force equality.

00:35:11.540 --> 00:35:14.220
The wiggly lines mean equality.

00:35:14.220 --> 00:35:15.831
So I want that
whatever color I've

00:35:15.831 --> 00:35:18.080
chosen here is the same as
the color I've chosen here,

00:35:18.080 --> 00:35:20.160
because I want u
to have one color,

00:35:20.160 --> 00:35:22.060
I'm only allowed to
assign one color to u.

00:35:22.060 --> 00:35:25.170
So we're going to look at how
to do that equality constraint.

00:35:25.170 --> 00:35:28.070
And then we have these
types of constraints,

00:35:28.070 --> 00:35:32.370
which say that the
colors are different,

00:35:32.370 --> 00:35:34.690
non-equal, because I
want the color assigned

00:35:34.690 --> 00:35:37.160
to u to be different than
the color assigned to v.

00:35:37.160 --> 00:35:39.280
And this path is
coming from v so

00:35:39.280 --> 00:35:42.700
at this point the color that
you're on, which of the red

00:35:42.700 --> 00:35:45.470
rails you're on,
says which color

00:35:45.470 --> 00:35:48.100
is assigned to v. You
want that color to be

00:35:48.100 --> 00:35:49.930
different from the
color assigned to u.

00:35:49.930 --> 00:35:51.910
Then you transition and say, OK.

00:35:51.910 --> 00:35:53.410
Now I'm going to
start over and pick

00:35:53.410 --> 00:35:55.210
another color between 1 and 3.

00:35:55.210 --> 00:35:58.240
And then here, it's constrained
to be equal to this one.

00:35:58.240 --> 00:36:00.980
So I think the arrows are
delineating the transitions

00:36:00.980 --> 00:36:01.980
from the color.

00:36:01.980 --> 00:36:05.299
Here it should all be color
v. Well, that's maybe not so

00:36:05.299 --> 00:36:07.090
[INAUDIBLE], but
somewhere along this edge,

00:36:07.090 --> 00:36:08.845
you're going to
switch to thinking

00:36:08.845 --> 00:36:10.970
about the color v to thinking
about the color of u.

00:36:10.970 --> 00:36:13.790
You only need one
color at any moment,

00:36:13.790 --> 00:36:16.514
so there will only have to be
three parallel tracks for each

00:36:16.514 --> 00:36:17.240
of these things.

00:36:17.240 --> 00:36:18.490
That's the high level picture.

00:36:18.490 --> 00:36:21.520
Let me tell you actually do it.

00:36:21.520 --> 00:36:25.362
So here's this left part
expanded into a slightly more

00:36:25.362 --> 00:36:26.070
detailed picture.

00:36:26.070 --> 00:36:29.180
Still a bunch of
details to be filled in,

00:36:29.180 --> 00:36:31.810
but we see still the non-equal
and the equal gadgets,

00:36:31.810 --> 00:36:35.850
just like before, but
here I've explicitly

00:36:35.850 --> 00:36:38.530
shown the three tracks.

00:36:38.530 --> 00:36:51.220
So we were looking at this
edge before, so let's say here.

00:36:51.220 --> 00:36:53.010
Here's where you
choose the color for u.

00:36:53.010 --> 00:36:55.170
So we're going to use what
we call a fork gadget.

00:36:55.170 --> 00:36:57.050
We've maybe seen something
like this before.

00:36:57.050 --> 00:37:00.610
When you come in, you can
choose one of these three paths.

00:37:00.610 --> 00:37:02.110
Once you choose,
you can't unchoose.

00:37:02.110 --> 00:37:05.167
It's a one-way gadget.

00:37:05.167 --> 00:37:06.750
So let's say you
choose path one, that

00:37:06.750 --> 00:37:09.545
means that this
vertex u is colored 1.

00:37:09.545 --> 00:37:11.920
Then you're going to have some
equal gadget-- these three

00:37:11.920 --> 00:37:14.360
paths are connected
over here-- but you'll

00:37:14.360 --> 00:37:17.331
be forced that this path is
the same as the one chosen over

00:37:17.331 --> 00:37:17.830
here.

00:37:17.830 --> 00:37:19.270
We'll get to that one later.

00:37:19.270 --> 00:37:21.020
Then you go over
here, you're forced

00:37:21.020 --> 00:37:22.520
that among these
three paths, you're

00:37:22.520 --> 00:37:25.470
different from the
three paths over here,

00:37:25.470 --> 00:37:27.390
because that's going
to be the color v.

00:37:27.390 --> 00:37:30.025
And then, you now want to
switch from the u color

00:37:30.025 --> 00:37:31.390
to the v color.

00:37:31.390 --> 00:37:33.520
So I'm just going to have
some one-way gadgets here

00:37:33.520 --> 00:37:37.740
that coalesce these
three wires into one,

00:37:37.740 --> 00:37:42.980
and then whatever's next-- Let's
say this is next, v was a leaf.

00:37:42.980 --> 00:37:45.857
Then you have a fork, again,
to choose the color for v.

00:37:45.857 --> 00:37:47.940
So it's kind of weird, you
get to choose the color

00:37:47.940 --> 00:37:49.050
for vertex several times.

00:37:49.050 --> 00:37:51.720
Here we're choosing it for u,
here were choosing it again

00:37:51.720 --> 00:37:53.300
for u, but they're
combined together

00:37:53.300 --> 00:37:55.133
with this equal gadget,
so those two choices

00:37:55.133 --> 00:37:57.040
are forced to be the same.

00:37:57.040 --> 00:37:59.224
That's the idea.

00:37:59.224 --> 00:38:00.640
And then the
non-equal gadgets are

00:38:00.640 --> 00:38:03.226
doing the actual
coloring constraint

00:38:03.226 --> 00:38:06.130
of no monochromatic edges.

00:38:06.130 --> 00:38:09.300
So it looks complicated,
but all you really need

00:38:09.300 --> 00:38:10.080
are these things.

00:38:10.080 --> 00:38:11.150
Well, and the fork
and the one-way.

00:38:11.150 --> 00:38:12.566
Let's do the fork
and the one-way,

00:38:12.566 --> 00:38:13.695
because those are easy.

00:38:13.695 --> 00:38:15.070
We've basically
seen them before.

00:38:15.070 --> 00:38:17.890
Pretty sure we did
this one-way gadget.

00:38:17.890 --> 00:38:21.090
You can go from a to
b, but not from b to a.

00:38:24.111 --> 00:38:24.610
Cool.

00:38:24.610 --> 00:38:26.410
So that means when
I come through here,

00:38:26.410 --> 00:38:30.850
I can't back up along some
other path, that would be bad.

00:38:30.850 --> 00:38:34.650
And the fork gadget,
this is a two-way fork.

00:38:34.650 --> 00:38:38.150
You come in from a and you can
either push this in and then

00:38:38.150 --> 00:38:39.850
choose to go to
c, but then you'll

00:38:39.850 --> 00:38:44.250
never be able to go to b, or
you can push this down and then

00:38:44.250 --> 00:38:46.370
go to b and you'll never
be able to go to c.

00:38:46.370 --> 00:38:49.861
So when you make this choice,
you can't undo the choice.

00:38:49.861 --> 00:38:51.360
You just chain two
of these together

00:38:51.360 --> 00:38:52.960
to make a three-way choice.

00:38:52.960 --> 00:38:55.070
And the one-way is to
prevent you from going back

00:38:55.070 --> 00:38:57.300
along one of these paths.

00:38:57.300 --> 00:38:59.730
So that's the easy part.

00:38:59.730 --> 00:39:02.530
Then what about the equal
and the non-equal gadgets?

00:39:02.530 --> 00:39:04.470
These are complicated,
but in the end,

00:39:04.470 --> 00:39:06.680
they reduce to some
very simple gadgets.

00:39:06.680 --> 00:39:10.010
So let's start with
the non-equal gadget.

00:39:10.010 --> 00:39:16.030
So we have three possible
color choices for one edge,

00:39:16.030 --> 00:39:20.600
for one vertex, and we have
three possible choices down

00:39:20.600 --> 00:39:22.010
here for the other vertex.

00:39:22.010 --> 00:39:24.790
Together, those vertices
should form the edge e,

00:39:24.790 --> 00:39:27.080
and this is written
as e going one way

00:39:27.080 --> 00:39:29.540
or e going the other way
and coming from one vertex

00:39:29.540 --> 00:39:31.910
and coming from the
other vertex end.

00:39:31.910 --> 00:39:35.880
And what we want is
to forbid blue-blue,

00:39:35.880 --> 00:39:40.370
or to forbid red-red, or
to forbid orange-orange.

00:39:40.370 --> 00:39:43.280
And because this paper was also
printed in black and white,

00:39:43.280 --> 00:39:46.930
the dash patterns also
duplicate the color information.

00:39:46.930 --> 00:39:48.710
So even if you
lost all color, you

00:39:48.710 --> 00:39:51.500
can distinguish
these types of lines.

00:39:51.500 --> 00:39:58.050
So we need this gadget, which
we called a manned gadget,

00:39:58.050 --> 00:40:00.960
but you should not
have both of these.

00:40:00.960 --> 00:40:02.630
And there's a couple
different cases,

00:40:02.630 --> 00:40:04.680
depending on the orientation.

00:40:04.680 --> 00:40:07.470
But, for example, if
you go from a to b,

00:40:07.470 --> 00:40:08.934
you have to push this down.

00:40:08.934 --> 00:40:11.350
Which, because this is Push-1,
you only have strength one,

00:40:11.350 --> 00:40:12.660
you're not able to push up.

00:40:12.660 --> 00:40:16.230
You're not able to traverse
cd anymore if you do a to b.

00:40:16.230 --> 00:40:17.730
This is the symmetric
version where,

00:40:17.730 --> 00:40:23.390
if you first do b to a, then
that prevents cd traversal.

00:40:23.390 --> 00:40:26.160
And its symmetric,
so vice versa, OK?

00:40:26.160 --> 00:40:29.300
So that's the gadget
that plugs in here.

00:40:29.300 --> 00:40:35.360
And so now we know that, if
we follow the path along 3,

00:40:35.360 --> 00:40:39.010
the blue path for
this vertex, we

00:40:39.010 --> 00:40:40.710
won't be able to
traverse the blue path.

00:40:40.710 --> 00:40:43.690
And so whatever choice
you made here at the fork

00:40:43.690 --> 00:40:47.120
has to be different
from this choice.

00:40:47.120 --> 00:40:50.090
It's kind of a fun,
non-local effect.

00:40:50.090 --> 00:40:52.670
And it doesn't matter,
whoever makes the choice first

00:40:52.670 --> 00:40:54.609
will block the choice
for the other guy.

00:40:54.609 --> 00:40:56.900
If you had multiple robots
simultaneously doing things,

00:40:56.900 --> 00:40:59.890
then it would get
tricky when there's

00:40:59.890 --> 00:41:02.360
two robots right here at the
same time, but probably even

00:41:02.360 --> 00:41:04.940
then, it would work as long
as everything eventually

00:41:04.940 --> 00:41:06.760
gets traversed.

00:41:06.760 --> 00:41:08.980
OK.

00:41:08.980 --> 00:41:11.650
So then we also need some
limited kinds of crossovers

00:41:11.650 --> 00:41:15.142
to make this happen, because we
need to take this orange path.

00:41:15.142 --> 00:41:16.350
I don't know why it's orange.

00:41:16.350 --> 00:41:18.960
It should be green,
but there you go.

00:41:18.960 --> 00:41:22.310
Bring it down here and
then bring it back up.

00:41:22.310 --> 00:41:24.510
So that's going to require
the orange path to cross

00:41:24.510 --> 00:41:26.240
the red path and the blue path.

00:41:26.240 --> 00:41:27.152
Good news.

00:41:27.152 --> 00:41:28.610
We know that only
one of these will

00:41:28.610 --> 00:41:32.920
be traversed, because the
fork gadget has that property.

00:41:32.920 --> 00:41:34.470
If you end up
following the one path,

00:41:34.470 --> 00:41:36.386
you know that 2 will not
have to be traversed,

00:41:36.386 --> 00:41:39.040
so this is what we called
an xor crossover back when

00:41:39.040 --> 00:41:40.540
we were doing pushing blocks.

00:41:40.540 --> 00:41:42.560
It's a crossover that
works as long as you only

00:41:42.560 --> 00:41:47.030
are visiting it once,
one way or the other way.

00:41:47.030 --> 00:41:49.604
So, for example, if you come--
And it's also uni-directional.

00:41:49.604 --> 00:41:51.520
So if you come from a,
you can push that down,

00:41:51.520 --> 00:41:54.630
but then you won't be
able to go to c or d,

00:41:54.630 --> 00:41:56.230
and then you can
leave through b.

00:41:56.230 --> 00:42:01.130
And from c, you can
push this over, go to d,

00:42:01.130 --> 00:42:04.280
and those are the only cases we
need with various reflections

00:42:04.280 --> 00:42:06.010
and rotations.

00:42:06.010 --> 00:42:08.140
We either go from
up top to down here,

00:42:08.140 --> 00:42:13.241
or we go from right to left
here through that xor crossover.

00:42:13.241 --> 00:42:14.740
So you just plug
those crossovers in

00:42:14.740 --> 00:42:17.300
and you can get
each of these paths

00:42:17.300 --> 00:42:18.964
to where you need
them to be, and you

00:42:18.964 --> 00:42:20.380
know that they'll
work because you

00:42:20.380 --> 00:42:24.610
won't have to do both of those
traversals, and there you go.

00:42:24.610 --> 00:42:28.480
So in general, as long as you
have a NAND gadget and an xor

00:42:28.480 --> 00:42:31.590
gadget, then you can do this
to make a not equal gadget.

00:42:31.590 --> 00:42:33.600
So there's a lot of pieces
here, but in the end,

00:42:33.600 --> 00:42:35.000
it reduces to very few things.

00:42:35.000 --> 00:42:39.826
We had a one-way, a
fork, an xor, and a NAND.

00:42:39.826 --> 00:42:43.500
If you have those things,
you can simulate 3-coloring

00:42:43.500 --> 00:42:44.350
in this planar way.

00:42:44.350 --> 00:42:45.850
Now, I didn't cover
one more gadget,

00:42:45.850 --> 00:42:47.800
which is the equal gadget.

00:42:47.800 --> 00:42:49.390
It's just a more
complicated version

00:42:49.390 --> 00:42:52.770
of the non-equal gadget.

00:42:52.770 --> 00:42:57.802
So you need to prevent
this one from being

00:42:57.802 --> 00:42:59.260
blue when the bottom
one is orange,

00:42:59.260 --> 00:43:01.301
you need to prevent this
one from being blue when

00:43:01.301 --> 00:43:03.464
the bottom one is
red, and you need

00:43:03.464 --> 00:43:05.880
to prevent this one from being
red when that one's orange,

00:43:05.880 --> 00:43:06.995
you need to prevent
this one from being

00:43:06.995 --> 00:43:08.400
red when that one's blue.

00:43:08.400 --> 00:43:11.630
And all the pairwise things you
don't want to have happen, just

00:43:11.630 --> 00:43:12.927
make them not happen.

00:43:12.927 --> 00:43:15.260
So you can imagine, of course,
much more general gadgets

00:43:15.260 --> 00:43:16.160
than this.

00:43:16.160 --> 00:43:18.580
We're probably doing much
more than 3-coloring,

00:43:18.580 --> 00:43:22.420
but again, all we need
are the xors and the NAND.

00:43:22.420 --> 00:43:27.450
So that proves Push-1X
is NP complete for free,

00:43:27.450 --> 00:43:29.790
and this approach has been
used by a couple of papers.

00:43:29.790 --> 00:43:33.370
So here is another one, Push-1G.

00:43:33.370 --> 00:43:35.950
This is pushing
blocks with gravity.

00:43:35.950 --> 00:43:39.270
So imagine-- this happens
in a lot of games--

00:43:39.270 --> 00:43:41.160
when you're pushing
a block, the block

00:43:41.160 --> 00:43:43.960
will fall if it ever
has a hole below it.

00:43:43.960 --> 00:43:46.310
Let's say that you
don't fall though,

00:43:46.310 --> 00:43:49.370
or you could do lots of
jumps, or flying, or whatever.

00:43:49.370 --> 00:43:50.920
You can do something to avoid.

00:43:50.920 --> 00:43:54.439
I don't think we'll need any
big jumps for this to work.

00:43:54.439 --> 00:43:55.980
So there are lots
of video games that

00:43:55.980 --> 00:43:57.860
follow these kinds of roles.

00:43:57.860 --> 00:44:02.650
Here's a one-way in that model,
you just push this block over,

00:44:02.650 --> 00:44:04.150
it will fall.

00:44:04.150 --> 00:44:06.680
So you can't push
it the other way,

00:44:06.680 --> 00:44:09.720
but once you push it
forward, it's open

00:44:09.720 --> 00:44:12.680
and we're going to denote
that with an arrow.

00:44:12.680 --> 00:44:15.560
This is Eric Friedman.

00:44:15.560 --> 00:44:17.970
And here is an xor crossover.

00:44:17.970 --> 00:44:18.940
This is kind of fun.

00:44:18.940 --> 00:44:21.270
If I come in this way,
I push this guy over,

00:44:21.270 --> 00:44:23.430
it falls down
blocking that path,

00:44:23.430 --> 00:44:26.430
but I can still go through here,
and if I push this one over,

00:44:26.430 --> 00:44:29.250
the block falls, and
I can go this way,

00:44:29.250 --> 00:44:32.022
but I'm blocked from going
this way or that way.

00:44:32.022 --> 00:44:33.980
So that, again, works as
long as I'm only doing

00:44:33.980 --> 00:44:36.850
one of the two traversals.

00:44:36.850 --> 00:44:38.850
We have a fork gadget,
which is familiar.

00:44:38.850 --> 00:44:41.130
If you're coming out from
here, you can push this over

00:44:41.130 --> 00:44:43.296
and then you'd be prevented
from going the other way

00:44:43.296 --> 00:44:46.710
because you, again, only have
strength 1, and symmetrically

00:44:46.710 --> 00:44:47.630
the other side.

00:44:47.630 --> 00:44:50.330
Then the NAND ga-- Yeah?

00:44:50.330 --> 00:44:55.016
AUDIENCE: For the xor crossover,
you said you couldn't-- When

00:44:55.016 --> 00:44:56.390
you're going from
the bottom one,

00:44:56.390 --> 00:45:01.990
you push that over and it falls,
and then you can't go back up

00:45:01.990 --> 00:45:03.814
because you couldn't
push that block?

00:45:03.814 --> 00:45:04.480
PROFESSOR: Yeah.

00:45:04.480 --> 00:45:06.200
So I maybe need a wiggle here.

00:45:06.200 --> 00:45:09.044
AUDIENCE: The arrow is already
representing one-way gadgets?

00:45:09.044 --> 00:45:09.710
PROFESSOR: Good.

00:45:09.710 --> 00:45:12.120
That's already here because
the arrow is a one-way.

00:45:12.120 --> 00:45:13.470
I forgot the notation.

00:45:13.470 --> 00:45:13.970
Yeah.

00:45:13.970 --> 00:45:15.386
It's not the input
and the output.

00:45:15.386 --> 00:45:17.260
This is an actual one-way.

00:45:17.260 --> 00:45:19.460
Good.

00:45:19.460 --> 00:45:21.840
OK.

00:45:21.840 --> 00:45:24.510
And here's a fun thing I
learned from reading this paper,

00:45:24.510 --> 00:45:25.940
you don't even
need a NAND gadget,

00:45:25.940 --> 00:45:29.680
because you can simulate a NAND
gadget with xor crossovers.

00:45:29.680 --> 00:45:32.800
This is kind of like Jason's
idea of using the crossover

00:45:32.800 --> 00:45:36.100
gadget to make copies.

00:45:36.100 --> 00:45:40.480
If you traverse through this
way, and through this way,

00:45:40.480 --> 00:45:43.970
we know that's possible,
and if you have a set up

00:45:43.970 --> 00:45:45.840
where, by going
through a crossover

00:45:45.840 --> 00:45:48.990
you block the other traversal--
so that would be a true xor

00:45:48.990 --> 00:45:57.690
crossover-- Once I've
pushed this one over,

00:45:57.690 --> 00:46:00.291
if I tried to go through
this way down to here,

00:46:00.291 --> 00:46:02.040
I would hit the block
here that had fallen

00:46:02.040 --> 00:46:04.770
from there and vice versa.

00:46:04.770 --> 00:46:07.370
So if it actually prevents
the second traversal,

00:46:07.370 --> 00:46:10.460
and in Push-1X, it also
prevented the second traversal

00:46:10.460 --> 00:46:11.934
because we had
non-crossing paths.

00:46:11.934 --> 00:46:13.850
We weren't allowed to
revisit the same square,

00:46:13.850 --> 00:46:15.180
so there it was really trivial.

00:46:15.180 --> 00:46:17.180
Here with gravity, it's
a little more subtle,

00:46:17.180 --> 00:46:19.110
because the second time
you come through maybe you

00:46:19.110 --> 00:46:20.068
could go back that way.

00:46:20.068 --> 00:46:23.385
But the key thing is that the
second time you go through,

00:46:23.385 --> 00:46:27.130
you won't be able to go through
in the regular crossover way,

00:46:27.130 --> 00:46:29.044
and then you just string
two of them together

00:46:29.044 --> 00:46:31.460
and you can either traverse
this way or traverse this way,

00:46:31.460 --> 00:46:33.540
and each one will
block the other.

00:46:33.540 --> 00:46:37.510
So in the end, you just
need a one-way, fork, an xor

00:46:37.510 --> 00:46:40.870
crossover, and some kind of
notion of sequential traversal

00:46:40.870 --> 00:46:42.940
and you can simulate 3-coloring.

00:46:42.940 --> 00:46:43.587
So this is fun.

00:46:43.587 --> 00:46:45.420
I haven't seen this
technique used too much,

00:46:45.420 --> 00:46:48.440
but in a few papers and
maybe we can use it for more.

00:46:53.440 --> 00:46:54.840
Cool.

00:46:54.840 --> 00:46:58.480
I didn't mention, but the Push-1
proofs that we saw before,

00:46:58.480 --> 00:47:03.010
lecture four or whatever,
revisit the same square

00:47:03.010 --> 00:47:03.600
many times.

00:47:03.600 --> 00:47:06.190
So we can't use those
proofs for Push-1X.

00:47:06.190 --> 00:47:09.000
All the gadgets break.

00:47:09.000 --> 00:47:11.190
The next problem I
want to talk about

00:47:11.190 --> 00:47:13.940
is a little different,
another graph problem.

00:47:21.695 --> 00:47:22.945
It's called graph orientation.

00:47:25.510 --> 00:47:31.160
Kind of like edge coloring, but
the colors differ on each side.

00:47:31.160 --> 00:47:37.100
So a graph orientation.

00:47:41.467 --> 00:47:42.800
This is a pretty recent problem.

00:47:42.800 --> 00:47:46.990
It was introduced in 2012,
but I think it's very cool

00:47:46.990 --> 00:47:51.290
and deserves much more study.

00:47:51.290 --> 00:48:02.370
So you're given an
undirected graph

00:48:02.370 --> 00:48:07.710
and you want to find an
orientation-- orientation

00:48:07.710 --> 00:48:09.760
means for every
edge, you give it

00:48:09.760 --> 00:48:26.550
a direction-- satisfying
certain vertex constraints,

00:48:26.550 --> 00:48:30.355
and there are three types of
vertices, three types of vertex

00:48:30.355 --> 00:48:30.855
constraints.

00:48:35.200 --> 00:48:46.325
They are 1-in-3,
2-in-3, and 0 or 3.

00:48:46.325 --> 00:48:47.650
They all end in 3.

00:48:47.650 --> 00:48:50.950
I didn't mention, this
is a 3 regular graph.

00:48:50.950 --> 00:48:55.900
Every vertex has
degree 3, and so

00:48:55.900 --> 00:48:57.990
if you look at an orientation,
every vertex either

00:48:57.990 --> 00:49:08.250
has 3 in, 0 out, 2 in, 1 out,
1 in, 2 out, or 0 in, 3 out.

00:49:08.250 --> 00:49:12.510
And this problem is NP hard.

00:49:12.510 --> 00:49:15.770
Here is a simple
reduction from 3SAT.

00:49:15.770 --> 00:49:18.540
That's right, 1 in 3SAT.

00:49:18.540 --> 00:49:20.780
So we're going to have
a variable gadget, which

00:49:20.780 --> 00:49:25.490
is just this loop of
a cycle in the graph.

00:49:25.490 --> 00:49:29.350
And for each of
these vertices that's

00:49:29.350 --> 00:49:32.500
a solid black
circle is a 0 or 3.

00:49:32.500 --> 00:49:34.230
So that means in any
solution-- here's

00:49:34.230 --> 00:49:37.120
a solution-- you're going
to alternate between all in

00:49:37.120 --> 00:49:39.610
and all out, and
then all in, all out.

00:49:39.610 --> 00:49:42.500
So this is going to
represent x and x-bar.

00:49:42.500 --> 00:49:45.380
What the parity of that
cycle is is up to you,

00:49:45.380 --> 00:49:48.400
you could either make all the
x's all in or all the x-bars

00:49:48.400 --> 00:49:51.680
all in, and that corresponds
to x being true or false.

00:49:51.680 --> 00:49:54.800
I think in means
false in this case.

00:49:54.800 --> 00:50:01.570
And then for the clauses, we're
going to use a 1 in 3 gadget.

00:50:01.570 --> 00:50:04.570
It's because that's
a 1 in 3SAT clause.

00:50:04.570 --> 00:50:06.490
We want exactly one
of these three things

00:50:06.490 --> 00:50:08.390
to be in coming to the clause.

00:50:08.390 --> 00:50:12.550
That gives us exactly one
of them being set to true.

00:50:12.550 --> 00:50:18.630
Now, here we're
allowing negations.

00:50:18.630 --> 00:50:20.720
We know that's not
necessary for 1 in 3SAT,

00:50:20.720 --> 00:50:25.550
but we can in this proof, so
they're drawn here anyway.

00:50:25.550 --> 00:50:31.300
But to make it a little bit
weird, one issue in this style,

00:50:31.300 --> 00:50:34.650
or in this reduction,
really I just want

00:50:34.650 --> 00:50:35.960
a whole bunch of copies of x.

00:50:35.960 --> 00:50:38.610
But I get all these
copies of x-bar,

00:50:38.610 --> 00:50:40.644
and I need to put
them somewhere.

00:50:40.644 --> 00:50:42.060
Every vertex has
to have degree 3,

00:50:42.060 --> 00:50:44.660
so this has to go to something.

00:50:44.660 --> 00:50:48.190
And so their solution for
doing that is for every clause,

00:50:48.190 --> 00:50:52.360
we also build the anti-clause
and make it false.

00:50:52.360 --> 00:50:56.010
So we want exactly two
of the negated versions

00:50:56.010 --> 00:50:58.300
of these variables
to be set to true.

00:50:58.300 --> 00:51:00.920
That's the same thing as exactly
one of the positive forms

00:51:00.920 --> 00:51:04.540
of them being true.

00:51:04.540 --> 00:51:06.320
Yes.

00:51:06.320 --> 00:51:08.380
So we just negate
everything in the clause,

00:51:08.380 --> 00:51:12.570
and then wherever we use x, we
also use x-bar and vice versa.

00:51:12.570 --> 00:51:16.050
So that guarantees that we
use up all of these instances.

00:51:16.050 --> 00:51:18.460
If there are k
occurrences of x, then

00:51:18.460 --> 00:51:20.070
we'll make k
occurrences of x-bar

00:51:20.070 --> 00:51:23.950
and make them all used by the
corresponding anti-clauses.

00:51:23.950 --> 00:51:27.267
So this is why we need those
three types of gadgets.

00:51:27.267 --> 00:51:28.850
If we're doing a
problem in the plane,

00:51:28.850 --> 00:51:31.810
we'll also need a
crossover for this to work.

00:51:31.810 --> 00:51:35.700
But at this point, it's
just a graph problem.

00:51:35.700 --> 00:51:36.580
OK?

00:51:36.580 --> 00:51:38.640
So that's cool.

00:51:38.640 --> 00:51:42.930
And this problem was
introduced in order

00:51:42.930 --> 00:51:46.330
to solve a packing problem.

00:51:46.330 --> 00:51:49.920
A little bit of
history, some time ago,

00:51:49.920 --> 00:51:52.090
I think the '70s, there
was a paper about,

00:51:52.090 --> 00:51:55.850
if I give you polygon
some orthogonal polygon

00:51:55.850 --> 00:51:59.790
shape with holes in it,
and I want to pack as many,

00:51:59.790 --> 00:52:04.580
say, 3 by 3 squares in the
polygon, that's NP hard.

00:52:04.580 --> 00:52:07.870
If I want to pack as many 2
by 2 squares, that's NP hard.

00:52:07.870 --> 00:52:12.980
That was a later paper, and so
how much smaller of a square

00:52:12.980 --> 00:52:13.760
can you make?

00:52:13.760 --> 00:52:17.270
Well, a 1 by 1 square, that's
pretty easy, in a grid polygon.

00:52:17.270 --> 00:52:19.070
How many 1 by 1
squares can I pack?

00:52:19.070 --> 00:52:21.100
The area.

00:52:21.100 --> 00:52:24.680
In a grid polygon, how
many 2 by 1 rectangles

00:52:24.680 --> 00:52:26.640
can I pack this way or this way?

00:52:26.640 --> 00:52:30.070
That's maximum
cardinality matching.

00:52:30.070 --> 00:52:32.480
So the next thing
left is trominoes.

00:52:32.480 --> 00:52:35.250
Three squares, and they
could be in an L-shape

00:52:35.250 --> 00:52:37.460
or they could be in an I-shape.

00:52:37.460 --> 00:52:39.750
Here, we're thinking about
both problems separately.

00:52:39.750 --> 00:52:42.470
So suppose you have a whole
bunch of L-shaped packages

00:52:42.470 --> 00:52:45.820
that you want to fit into this
weirdly shaped warehouse, that

00:52:45.820 --> 00:52:47.270
is NP hard.

00:52:47.270 --> 00:52:49.620
It's even hard in the
exact packing case.

00:52:49.620 --> 00:52:51.385
There will be no
holes-- Sorry, there

00:52:51.385 --> 00:52:53.800
will be no gaps in this packing.

00:52:53.800 --> 00:52:56.810
Every unit square
will be filled,

00:52:56.810 --> 00:52:59.170
and I think that's
quite particular.

00:52:59.170 --> 00:53:02.090
Those other proofs of packing,
the 2 by 2 and the 3 by 3

00:53:02.090 --> 00:53:04.220
squared into a polygon,
I should have shown them,

00:53:04.220 --> 00:53:08.310
but they're from
3SAT, planar 3SAT.

00:53:08.310 --> 00:53:09.937
They leave gaps
all over the place.

00:53:09.937 --> 00:53:11.520
Here, you don't leave
gaps and I think

00:53:11.520 --> 00:53:16.070
it's somehow fundamental to
this graph orientation business.

00:53:16.070 --> 00:53:21.880
So here is the idea of for an
edge in that graph orientation

00:53:21.880 --> 00:53:23.770
problem.

00:53:23.770 --> 00:53:27.030
It's basically a rectangle
with a bump every other square.

00:53:27.030 --> 00:53:27.960
So this is a big hole.

00:53:27.960 --> 00:53:30.290
You're not allowed to
put anything down there.

00:53:30.290 --> 00:53:33.850
And the idea is
you can either have

00:53:33.850 --> 00:53:35.410
the L's all pointing
to the right

00:53:35.410 --> 00:53:37.100
or all pointing to the left.

00:53:37.100 --> 00:53:42.160
And so you think of these
as kind of the communication

00:53:42.160 --> 00:53:43.386
position.

00:53:43.386 --> 00:53:46.010
One of these will correspond to
the edge pointing to the right,

00:53:46.010 --> 00:53:49.320
one will correspond to the
edges pointing to the left.

00:53:49.320 --> 00:53:51.340
And you can build a turn gadget.

00:53:51.340 --> 00:53:52.810
It works pretty cleanly.

00:53:52.810 --> 00:53:55.615
It doesn't matter whether
this is covered by that guy

00:53:55.615 --> 00:53:56.820
or covered by that guy.

00:53:56.820 --> 00:53:58.460
It behaves the same
as a regular wire.

00:53:58.460 --> 00:54:01.930
So again, it's either
this or this is occupied,

00:54:01.930 --> 00:54:03.740
exactly one of them.

00:54:03.740 --> 00:54:06.690
That tells you the
orientation of the edge.

00:54:06.690 --> 00:54:08.660
So that's an edge.

00:54:08.660 --> 00:54:11.010
You can also build a crossover.

00:54:11.010 --> 00:54:13.500
This is a little more casework.

00:54:13.500 --> 00:54:16.810
But again, this is
occupied if and only

00:54:16.810 --> 00:54:19.820
if this is not occupied, and
this is occupied if and only

00:54:19.820 --> 00:54:22.940
if this is not occupied, and
all combinations are possible.

00:54:22.940 --> 00:54:26.187
We just need to check that there
is a valid packing no matter

00:54:26.187 --> 00:54:27.520
which of those choices you want.

00:54:27.520 --> 00:54:31.660
Either left and top being empty,
or left and bottom being empty,

00:54:31.660 --> 00:54:34.600
or top and right being empty,
or bottom and right being empty.

00:54:34.600 --> 00:54:37.810
Those are the four cases.

00:54:37.810 --> 00:54:38.750
Cool.

00:54:38.750 --> 00:54:39.850
Crossover.

00:54:39.850 --> 00:54:47.500
Now we need the 0 and
3, 1 and 3, and 2 and 3.

00:54:47.500 --> 00:54:52.330
So instead of a single 0 or
3, they built two in a row.

00:54:52.330 --> 00:54:53.739
I don't know if
this is required,

00:54:53.739 --> 00:54:55.780
but it's fine for the
proof, because in the proof

00:54:55.780 --> 00:54:58.250
it was always XI, XI-Bar,
so there are always

00:54:58.250 --> 00:55:05.350
2, 0, or 3's in a
row, and there it is.

00:55:05.350 --> 00:55:08.550
So in this setting,
essentially either the left two

00:55:08.550 --> 00:55:12.260
will have bumps and the right
two will not have bombs,

00:55:12.260 --> 00:55:14.270
or vice versa, the right
two will have bumps.

00:55:14.270 --> 00:55:17.016
This corresponds to
these guys all being out

00:55:17.016 --> 00:55:18.640
in all three directions,
and these guys

00:55:18.640 --> 00:55:21.530
all being in all three
directions, or vice versa,

00:55:21.530 --> 00:55:23.820
and these are all out
and these are all in.

00:55:23.820 --> 00:55:26.530
So that's the x or x-bar.

00:55:26.530 --> 00:55:29.600
And this gadget does it.

00:55:29.600 --> 00:55:31.940
Again, check the cases.

00:55:31.940 --> 00:55:34.595
We have exactly 1-in-3.

00:55:34.595 --> 00:55:39.420
If exactly 1 of these is in,
then this will be packable,

00:55:39.420 --> 00:55:40.380
and otherwise it won't.

00:55:40.380 --> 00:55:43.440
That's the part that's hard
to show but you check it.

00:55:43.440 --> 00:55:46.360
And if you want a
2-in-3 gadget, you just

00:55:46.360 --> 00:55:52.210
add a couple more blocks
right there and it works.

00:55:52.210 --> 00:55:52.860
So that's it.

00:55:52.860 --> 00:55:55.740
Once you have all those gadgets,
you can do graph orientation

00:55:55.740 --> 00:55:57.760
and then you're NP hard.

00:55:57.760 --> 00:55:59.740
That was for L-trominoes.

00:55:59.740 --> 00:56:01.420
Do the same thing
for I-trominoes.

00:56:01.420 --> 00:56:05.081
This is hard to see where the
bold lines are, but if you look

00:56:05.081 --> 00:56:07.580
and if you download the slide,
it's probably a little easier

00:56:07.580 --> 00:56:09.480
to see, but, again,
you can build.

00:56:09.480 --> 00:56:14.120
Here, an edge gadget is
fairly straightforward.

00:56:14.120 --> 00:56:17.890
Just wiggle a path and
you'll either have it--

00:56:17.890 --> 00:56:19.930
These wiggles are in
order to guarantee--

00:56:19.930 --> 00:56:22.670
There's actually three possible
parities you could have.

00:56:22.670 --> 00:56:26.060
Sticking out by 1, or sticking
out by 2 with an I-gadget.

00:56:26.060 --> 00:56:31.260
This will force it to be
just 1 or 0, because we

00:56:31.260 --> 00:56:34.260
don't want it to be 2.

00:56:34.260 --> 00:56:37.820
And then the crossover
is ugly, but it works.

00:56:37.820 --> 00:56:41.220
And the 0, 3, and the
1-in-3 are not too hard.

00:56:41.220 --> 00:56:42.960
And do I have the 2 in?

00:56:42.960 --> 00:56:46.700
I think this is a 2-in-3,
I didn't label it.

00:56:46.700 --> 00:56:49.909
So, presumably, for any
polynomial shape you want,

00:56:49.909 --> 00:56:51.450
you can build such
gadgets so that we

00:56:51.450 --> 00:56:54.990
don't have such a theorem,
but I think this is neat.

00:56:54.990 --> 00:56:58.840
It's a little different from
a lot of the other proofs,

00:56:58.840 --> 00:57:00.590
similar to one of the
problem set problems

00:57:00.590 --> 00:57:03.060
where we had some constraints
on the neighboring things.

00:57:03.060 --> 00:57:06.300
But instead of about constraints
on the neighboring colors

00:57:06.300 --> 00:57:08.340
of the vertices or
whatever, or the truth

00:57:08.340 --> 00:57:11.650
assignments in the vertices,
here, it's an edge direction.

00:57:11.650 --> 00:57:14.990
So the edge directions are
interesting because, first

00:57:14.990 --> 00:57:16.740
of all, there's only
two choices, but also

00:57:16.740 --> 00:57:18.850
that what you see on one
side is the opposite of what

00:57:18.850 --> 00:57:19.933
you see on the other side.

00:57:24.560 --> 00:57:27.240
Questions?

00:57:27.240 --> 00:57:33.560
So that is graph orientation,
and I have one more

00:57:33.560 --> 00:57:35.680
set of problems I
want to talk about.

00:57:42.030 --> 00:57:48.140
They have many names, but
the general family is usually

00:57:48.140 --> 00:57:55.920
called something like
linear layout of a graph,

00:57:55.920 --> 00:58:00.410
and it's a bijection--
let's call it

00:58:00.410 --> 00:58:09.260
f-- from the vertices to 1
up to the number of vertices.

00:58:09.260 --> 00:58:14.430
So in other words, I'm thinking
of a one dimensional diagram

00:58:14.430 --> 00:58:17.970
and the coordinates I have
are 1, 2, up to the number

00:58:17.970 --> 00:58:21.280
of vertices and I just
want to put exactly one

00:58:21.280 --> 00:58:22.750
vertex at each of these spots.

00:58:22.750 --> 00:58:26.030
So I basically want a
permutation of the vertices,

00:58:26.030 --> 00:58:27.744
and then I slap them
down in that order,

00:58:27.744 --> 00:58:29.660
and then I measure
something about the quality

00:58:29.660 --> 00:58:32.010
of that layout
based on the edges.

00:58:32.010 --> 00:58:33.890
We haven't involved edges yet.

00:58:33.890 --> 00:58:37.460
And there are many different
measures you might consider.

00:58:40.510 --> 00:58:44.660
Here are many of them,
but without definitions.

00:58:44.660 --> 00:58:48.570
So let me tell you
some definitions.

00:58:48.570 --> 00:58:51.370
So the first one, of the
earliest to be considered,

00:58:51.370 --> 00:58:54.460
is called bandwidth.

00:58:54.460 --> 00:59:01.816
Bandwidth is, if you look at an
edge, one endpoint of the edge

00:59:01.816 --> 00:59:04.190
gets mapped to one coordinate
and the other endpoint gets

00:59:04.190 --> 00:59:05.636
mapped to another coordinate.

00:59:05.636 --> 00:59:08.010
You can measure the length of
that edge in the embedding.

00:59:08.010 --> 00:59:10.343
I shouldn't call it embedding
because it's non-crossing,

00:59:10.343 --> 00:59:11.100
but in the layout.

00:59:11.100 --> 00:59:15.440
So for some edge vw, you can
measure the length of the edge.

00:59:15.440 --> 00:59:19.540
If I want to minimize the
maximum length of any edge,

00:59:19.540 --> 00:59:21.490
that is bandwidth.

00:59:21.490 --> 00:59:22.620
Why is it called bandwidth?

00:59:22.620 --> 00:59:23.240
Anyone know?

00:59:27.290 --> 00:59:33.330
No one does matrices anymore,
or numerical linear algebra,

00:59:33.330 --> 00:59:34.310
so I'll tell you why.

00:59:41.380 --> 00:59:46.890
If you have a matrix, let's
say, of 0's and 1's-- that's a

00:59:46.890 --> 00:59:54.270
graph, of course-- and all
of the non-zero elements are

00:59:54.270 --> 01:00:01.280
in that band, then we
call this bandwidth w.

01:00:01.280 --> 01:00:03.677
If it's 0 out here
and 0 out here.

01:00:03.677 --> 01:00:04.760
Why are these interesting?

01:00:04.760 --> 01:00:06.900
Because then if you run
Gaussian elimination,

01:00:06.900 --> 01:00:09.080
you always stay within the band.

01:00:09.080 --> 01:00:11.170
So this is some of the
early approaches to solving

01:00:11.170 --> 01:00:12.220
sparse linear systems.

01:00:12.220 --> 01:00:15.300
If you can get all of
the 0's into the corners,

01:00:15.300 --> 01:00:17.822
then you can focus here,
especially if your tri-diagonal

01:00:17.822 --> 01:00:18.530
is a common case.

01:00:18.530 --> 01:00:23.110
Anyway, that's called bandwidth,
and what this problem is saying

01:00:23.110 --> 01:00:27.920
is I'm allowed to permute the
rows and columns of my matrix

01:00:27.920 --> 01:00:32.050
in order to minimize how
many diagonals I need to use.

01:00:32.050 --> 01:00:35.180
So that is permutation
to minimize bandwidth.

01:00:35.180 --> 01:00:38.490
It would be great,
except it's NP hard.

01:00:38.490 --> 01:00:43.200
It's NP hard even on
trees of maximum degree 3.

01:00:43.200 --> 01:00:46.330
It's NP hard even
on caterpillars.

01:00:46.330 --> 01:00:47.210
Almost caterpillars.

01:00:47.210 --> 01:00:50.980
A caterpillar is a graph,
something like this.

01:00:54.100 --> 01:00:57.460
I think this is caterpillar
with hair length

01:00:57.460 --> 01:01:01.440
at most 3, so these may
be paths of a length 3,

01:01:01.440 --> 01:01:03.785
maybe they even
branch a little bit,

01:01:03.785 --> 01:01:09.090
but every vertex is within
distance 3 of a single path.

01:01:09.090 --> 01:01:12.535
So even for such graphs,
when mapped into matrices,

01:01:12.535 --> 01:01:13.660
this problem is NP hard.

01:01:13.660 --> 01:01:17.424
Lots of cases are NP hard,
even for good graphs.

01:01:17.424 --> 01:01:19.090
You might think of
that as more general,

01:01:19.090 --> 01:01:21.800
but it's not
immediately implied.

01:01:21.800 --> 01:01:22.300
OK.

01:01:22.300 --> 01:01:22.970
Cool.

01:01:22.970 --> 01:01:24.400
That was bandwidth.

01:01:24.400 --> 01:01:27.300
Next one, which I've seen used
in a few different hardness

01:01:27.300 --> 01:01:30.550
proofs, is minimum
linear arrangement.

01:01:30.550 --> 01:01:32.900
Almost the same problem,
but instead of taking

01:01:32.900 --> 01:01:35.360
the maximum edge length and
trying to minimize that,

01:01:35.360 --> 01:01:38.054
take the sum of the edge lengths
and try to minimize that.

01:01:38.054 --> 01:01:39.470
That's minimum
linear arrangement.

01:01:39.470 --> 01:01:43.300
We will see a reduction
from that in a moment.

01:01:43.300 --> 01:01:45.740
It's NP hard, even for
my bipartite graphs.

01:01:45.740 --> 01:01:47.871
Cut width.

01:01:47.871 --> 01:01:54.850
This is, you draw all the
edges as horizontal segments

01:01:54.850 --> 01:01:57.600
and then I come in
with a vertical line

01:01:57.600 --> 01:02:00.410
and see how many
edges can I cross.

01:02:00.410 --> 01:02:05.766
I want to find a permutation,
so I minimize the maximums,

01:02:05.766 --> 01:02:07.140
you might call it
stabbing width.

01:02:07.140 --> 01:02:09.200
The maximum number
of edges that cross

01:02:09.200 --> 01:02:11.150
from the left side
to the right side

01:02:11.150 --> 01:02:14.430
where I take the maximum
over all notions of side.

01:02:14.430 --> 01:02:16.850
I take the maximum over all
choices of this x-coordinate,

01:02:16.850 --> 01:02:19.680
and I want to
minimize that maximum.

01:02:19.680 --> 01:02:21.844
That is cut width.

01:02:21.844 --> 01:02:24.010
Why do I want to minimize
the maximum as opposed to,

01:02:24.010 --> 01:02:28.990
say, minimizing the sum
of those cut values?

01:02:28.990 --> 01:02:33.100
Because that's the same as
minimum linear arrangement.

01:02:33.100 --> 01:02:37.319
If I minimize the sum
of all of these cuts,

01:02:37.319 --> 01:02:39.110
that's the same thing
as minimizing the sum

01:02:39.110 --> 01:02:41.630
of the lengths of the edges.

01:02:41.630 --> 01:02:43.371
So that's the same problem.

01:02:43.371 --> 01:02:43.870
So, OK.

01:02:43.870 --> 01:02:45.570
We got rid of one.

01:02:45.570 --> 01:02:46.386
That was cut width.

01:02:46.386 --> 01:02:48.010
It's hard for planar
graphs, max degree

01:02:48.010 --> 01:02:52.270
3, good graphs, lots of things.

01:02:52.270 --> 01:02:53.580
I'm going to skip mod cut.

01:02:53.580 --> 01:02:57.950
That's just a slight different
variation on that definition.

01:02:57.950 --> 01:02:59.675
Next one is vertex separation.

01:03:04.420 --> 01:03:04.920
OK.

01:03:04.920 --> 01:03:06.465
This is a different
way of counting.

01:03:09.340 --> 01:03:12.140
So here, I was counting
how many edges cross,

01:03:12.140 --> 01:03:16.020
but maybe many of those edges
come from the same vertex.

01:03:16.020 --> 01:03:18.030
I don't want to double
count those, let's say.

01:03:18.030 --> 01:03:20.720
I just want to count how many
vertices on the left side

01:03:20.720 --> 01:03:22.850
have at least one edge that
goes to the right side,

01:03:22.850 --> 01:03:26.050
and only count it once instead
of three times in this picture.

01:03:26.050 --> 01:03:27.110
OK?

01:03:27.110 --> 01:03:29.830
Otherwise the same
problem as cut width.

01:03:29.830 --> 01:03:32.470
That is also hard.

01:03:32.470 --> 01:03:35.200
That problem is different if
you look at the sum versions.

01:03:35.200 --> 01:03:38.990
You can account for
every partition point

01:03:38.990 --> 01:03:43.190
how many vertices in the left
have an edge to the right side,

01:03:43.190 --> 01:03:45.920
sum that over all
of these x values,

01:03:45.920 --> 01:03:49.020
and then that is sum cut.

01:03:49.020 --> 01:03:51.830
All of these have been
considered in various contexts.

01:03:51.830 --> 01:03:53.530
Last one is edge by section.

01:03:53.530 --> 01:03:57.741
This is where you only look at
cutting in the middle at v/2.

01:03:57.741 --> 01:04:00.240
So you want to balance partition
all the things on the left,

01:04:00.240 --> 01:04:04.850
you want to have very few
edges to things on the right.

01:04:04.850 --> 01:04:06.420
Or the vertex version
where you want

01:04:06.420 --> 01:04:08.045
to minimize number
vertices on the left

01:04:08.045 --> 01:04:11.110
and edges to the right
half, but exactly half. v/2.

01:04:11.110 --> 01:04:12.710
v/2.

01:04:12.710 --> 01:04:13.580
A ton of problems.

01:04:13.580 --> 01:04:15.950
I mentioned them
so that if you ever

01:04:15.950 --> 01:04:19.206
run into a problem about
ordering vertices on a line,

01:04:19.206 --> 01:04:20.830
you should look at
all of those and see

01:04:20.830 --> 01:04:22.042
which one is the most useful.

01:04:22.042 --> 01:04:23.750
Sort of like we have
3SAT and 1 and 3SAT,

01:04:23.750 --> 01:04:26.460
and not-all-equal-SAT Choose
the one that's easiest for you.

01:04:26.460 --> 01:04:28.210
If you have some kind
of ordering problem,

01:04:28.210 --> 01:04:29.793
choose the one that's
easiest for you.

01:04:29.793 --> 01:04:31.930
Good to know that
these are out there.

01:04:31.930 --> 01:04:34.180
They come from
various applications.

01:04:34.180 --> 01:04:36.470
Cut width is studied
a lot in graph theory,

01:04:36.470 --> 01:04:38.910
graph minor stuff.

01:04:38.910 --> 01:04:42.130
It's closely related
to path width.

01:04:42.130 --> 01:04:44.040
Some of these
problem-- The bisection

01:04:44.040 --> 01:04:47.010
comes from numerical
linear algebra.

01:04:47.010 --> 01:04:49.980
Minimum linear arrangement
comes, I think, originally

01:04:49.980 --> 01:04:53.717
from VLSI layout, chip design.

01:04:53.717 --> 01:04:55.050
It's like a very simple version.

01:04:55.050 --> 01:04:57.049
If you just have a bunch
of ports on the bottom

01:04:57.049 --> 01:04:58.590
and you know that
certain things need

01:04:58.590 --> 01:05:00.550
to be connected by
wires, that's your graph,

01:05:00.550 --> 01:05:02.910
you want to minimize the
total amount of wire stuff

01:05:02.910 --> 01:05:06.899
you have to-- minimize
the total wire lengths.

01:05:06.899 --> 01:05:08.440
So that's minimum
linear arrangement.

01:05:08.440 --> 01:05:13.840
Very simple version of some
kind of VLSI layout problem.

01:05:13.840 --> 01:05:17.380
And there's this survey if you
want to see all these problems.

01:05:17.380 --> 01:05:19.290
There's one problem
not on the survey

01:05:19.290 --> 01:05:22.080
because it's not about a
graph, it's about a hypergraph,

01:05:22.080 --> 01:05:23.950
but it's a useful one.

01:05:23.950 --> 01:05:27.020
Among ordering problems,
it's the one I know the best.

01:05:27.020 --> 01:05:28.810
I've tried to use
it a couple times,

01:05:28.810 --> 01:05:31.440
but rarely have I succeeded in
getting an actual NP hardness

01:05:31.440 --> 01:05:34.100
proof from it, but
I will show you one,

01:05:34.100 --> 01:05:37.370
and it is called betweenness.

01:05:37.370 --> 01:05:42.580
So in this case, I'm
given a bunch of triples,

01:05:42.580 --> 01:05:51.000
a set of pairs of things-- it's
not a graph-- of the form y

01:05:51.000 --> 01:05:56.490
is between x and z.

01:05:56.490 --> 01:06:01.290
And what that means
is either it's

01:06:01.290 --> 01:06:04.930
between x and z in
that sense, or it's

01:06:04.930 --> 01:06:09.350
between x and z in
the other sense,

01:06:09.350 --> 01:06:12.360
where either x is to the left
of z or z is to the left of x,

01:06:12.360 --> 01:06:14.280
but y is always between.

01:06:14.280 --> 01:06:17.740
And here, of course, I really
mean f of x and f of y.

01:06:17.740 --> 01:06:20.140
I mean them in the
linear embedding.

01:06:20.140 --> 01:06:20.640
OK.

01:06:20.640 --> 01:06:22.890
So you're given a bunch
of triples like this,

01:06:22.890 --> 01:06:28.790
and then you want to find a
linear layout of your letters.

01:06:28.790 --> 01:06:32.220
So again, that's a
bijection from 1 to n,

01:06:32.220 --> 01:06:36.280
and such that these all hold.

01:06:36.280 --> 01:06:38.900
So there's no objective
function to minimize here.

01:06:38.900 --> 01:06:42.490
It's just you want each of
these things to be true.

01:06:42.490 --> 01:06:45.360
So this is nice, because it's
a pretty clean constraint

01:06:45.360 --> 01:06:46.904
and yet, it's hard.

01:06:46.904 --> 01:06:48.320
If I, for example,
was just giving

01:06:48.320 --> 01:06:50.861
you-- If I gave you a bunch of
inequality constraints, like x

01:06:50.861 --> 01:06:51.820
is less than y.

01:06:51.820 --> 01:06:52.410
That's easy.

01:06:52.410 --> 01:06:54.160
That's sorting a partial order.

01:06:54.160 --> 01:06:56.110
But here, you have a
little bit of ambiguity.

01:06:56.110 --> 01:06:57.570
You don't know how
x and z relate.

01:06:57.570 --> 01:06:59.236
You just know that y
is in between them.

01:06:59.236 --> 01:07:02.500
That's enough to get hardness.

01:07:02.500 --> 01:07:05.810
So I'm not going to prove
any of those problems hard,

01:07:05.810 --> 01:07:11.230
but I will show you two
examples of hardness proofs.

01:07:11.230 --> 01:07:16.840
First one is going to be from
the minimum linear arrangement.

01:07:16.840 --> 01:07:18.670
In case you haven't
already memorized

01:07:18.670 --> 01:07:22.750
all the problems I just
described, let me remind you.

01:07:22.750 --> 01:07:26.900
Minimum linear
arrangement was minimize

01:07:26.900 --> 01:07:31.160
the sum of the edge lengths.

01:07:31.160 --> 01:07:33.350
That was the second
problem I described,

01:07:33.350 --> 01:07:35.290
that was like the VLSI layout.

01:07:35.290 --> 01:07:38.190
Minimize the sum of
all the red lines.

01:07:38.190 --> 01:07:39.870
Find the permutation
that does that.

01:07:39.870 --> 01:07:42.180
So we're going to
reduce it first

01:07:42.180 --> 01:07:45.511
to a problem called
bipartite crossing number.

01:07:45.511 --> 01:07:46.760
It's a bit of a weird problem.

01:07:46.760 --> 01:07:49.850
It's mostly a stop gap on the
way to another problem, which

01:07:49.850 --> 01:07:51.340
is crossing number.

01:07:51.340 --> 01:07:53.580
Suppose you're given
bipartite a graph, which

01:07:53.580 --> 01:07:56.100
is hard to see in this picture.

01:07:56.100 --> 01:08:00.915
Given a bipartite graph, and
you want to draw in the plane.

01:08:07.420 --> 01:08:12.310
So I have some
bipartite graph, I

01:08:12.310 --> 01:08:16.050
want to draw it in the
plane in a special way.

01:08:16.050 --> 01:08:21.216
I want all of the vertices
in one side of bipartition

01:08:21.216 --> 01:08:22.340
to be on a horizontal line.

01:08:22.340 --> 01:08:25.760
I want all the vertices in the
other side of the bipartition

01:08:25.760 --> 01:08:28.825
to be on a parallel
horizontal line.

01:08:28.825 --> 01:08:30.200
And all the edges
are in between.

01:08:30.200 --> 01:08:31.220
They're straight lines.

01:08:31.220 --> 01:08:34.399
And I want to minimize
the number of crossings.

01:08:34.399 --> 01:08:36.887
So it's this very specific
kind of graph layout problem,

01:08:36.887 --> 01:08:38.970
but minimizing number of
crossing is clearly good.

01:08:38.970 --> 01:08:41.359
We want to draw as
planar as possible.

01:08:41.359 --> 01:08:45.750
So here is a reduction from
minimum linear arrangement

01:08:45.750 --> 01:08:47.500
to bipartite crossing number.

01:08:56.950 --> 01:09:00.390
So in this problem, we're
given a general graph, not

01:09:00.390 --> 01:09:01.790
necessarily bipartite.

01:09:01.790 --> 01:09:04.450
We want to convert it
into a bipartite graph.

01:09:04.450 --> 01:09:05.540
How do we do that?

01:09:05.540 --> 01:09:08.609
Make two copies of every vertex.

01:09:08.609 --> 01:09:11.750
OK, so for every vertex in
the minimum linear arrangement

01:09:11.750 --> 01:09:15.340
problem, we're going to
make two copies called

01:09:15.340 --> 01:09:18.970
bottom one and top one, top
two and bottom two, bottom

01:09:18.970 --> 01:09:20.380
two and top two, and so on.

01:09:20.380 --> 01:09:24.250
So there's n top vertices
and bottom vertices,

01:09:24.250 --> 01:09:26.640
and I'm going to do two things.

01:09:26.640 --> 01:09:29.859
One is connect a
whole bunch of edges.

01:09:29.859 --> 01:09:33.890
And a whole bunch
means e squared,

01:09:33.890 --> 01:09:39.630
and between bottom I and
top I. I just do that.

01:09:39.630 --> 01:09:42.330
That will basically
force this kind of layout

01:09:42.330 --> 01:09:45.040
where, basically,
the order on the top

01:09:45.040 --> 01:09:47.479
has to be identical to
the order on the bottom.

01:09:47.479 --> 01:09:50.569
Because if ever any of these
two bundles of edges crossed,

01:09:50.569 --> 01:09:53.240
you would get e to
the fourth crossings.

01:09:53.240 --> 01:09:54.990
And so if you ever
want to get less than e

01:09:54.990 --> 01:09:56.489
to the fourth
crossings-- and that's

01:09:56.489 --> 01:09:58.110
what we will hopefully
do-- then these

01:09:58.110 --> 01:10:01.330
must appear same order
on top and bottom.

01:10:01.330 --> 01:10:03.340
But we don't know
what the order is.

01:10:03.340 --> 01:10:05.000
You can still permute
the bottom, just

01:10:05.000 --> 01:10:08.870
correspondingly permute
the top, and all

01:10:08.870 --> 01:10:10.700
be well as far as
these edge bundles go.

01:10:10.700 --> 01:10:13.350
So that's good, because it
has exactly the flexibility,

01:10:13.350 --> 01:10:15.339
we have exactly one
permutation on n things.

01:10:15.339 --> 01:10:16.880
That's what we want
to represent with

01:10:16.880 --> 01:10:18.874
minimum linear arrangement.

01:10:18.874 --> 01:10:20.290
Then the only other
thing we do is

01:10:20.290 --> 01:10:22.030
add in the edges of the graph.

01:10:22.030 --> 01:10:24.930
But in the minimum linear
arrangement problem,

01:10:24.930 --> 01:10:28.140
the edges are like
from vertex I to vertex

01:10:28.140 --> 01:10:32.620
J. We're going to make that
connection from bottom I to top

01:10:32.620 --> 01:10:36.940
J. There's this choice, but it
doesn't matter which is which.

01:10:36.940 --> 01:10:43.230
So the idea is, then, that edge
will cross a bunch of bundles.

01:10:43.230 --> 01:10:45.580
The number of bundles
it crosses is the length

01:10:45.580 --> 01:10:50.700
of the edge minus 1, I think.

01:10:50.700 --> 01:10:53.460
I'll ignore these
additive constants.

01:10:53.460 --> 01:10:55.730
You have to be careful to
make sure everything adds up

01:10:55.730 --> 01:10:57.490
the right way.

01:10:57.490 --> 01:10:59.997
If you have a link
0 edge-- We never

01:10:59.997 --> 01:11:01.580
have the link 0 edge,
because vertices

01:11:01.580 --> 01:11:02.580
map to different places.

01:11:02.580 --> 01:11:04.940
If you have a length 1 edge,
you won't cross anything,

01:11:04.940 --> 01:11:06.000
so 0 crossings.

01:11:06.000 --> 01:11:10.070
If you have a length 2 edge, you
will cross exactly one bundle,

01:11:10.070 --> 01:11:11.760
and you pay e squared for that.

01:11:11.760 --> 01:11:13.385
In general, it will
be something like e

01:11:13.385 --> 01:11:16.115
squared times the sum of
the lengths of the edges.

01:11:16.115 --> 01:11:16.615
Not exactly.

01:11:16.615 --> 01:11:18.280
You have to subtract
off some things,

01:11:18.280 --> 01:11:21.680
but you just compute
what that is.

01:11:21.680 --> 01:11:27.011
It will always be basically
some fixed constant times

01:11:27.011 --> 01:11:28.510
the minimum linear
arrangement cost,

01:11:28.510 --> 01:11:32.990
which was the sum of the lengths
of the edges plus some fixed

01:11:32.990 --> 01:11:34.040
constant.

01:11:34.040 --> 01:11:36.720
And so you can solve the
bipartite crossing number

01:11:36.720 --> 01:11:39.630
with a given specified number
of crossings if and only

01:11:39.630 --> 01:11:42.670
if you can solve minimum linear
arrangement with a specified

01:11:42.670 --> 01:11:44.090
sum of edge lengths.

01:11:44.090 --> 01:11:44.785
Question.

01:11:44.785 --> 01:11:46.785
AUDIENCE: What about the
crossing between edges?

01:11:50.560 --> 01:11:51.500
PROFESSOR: Yes.

01:11:51.500 --> 01:11:55.680
There's also crossings
between edges,

01:11:55.680 --> 01:11:58.179
and you have to count them.

01:11:58.179 --> 01:12:00.470
AUDIENCE: [INAUDIBLE] because
you can't get more than e

01:12:00.470 --> 01:12:02.296
squared with this
in the normal case?

01:12:02.296 --> 01:12:02.920
PROFESSOR: Yes.

01:12:02.920 --> 01:12:05.440
So that will be in the noise.

01:12:05.440 --> 01:12:07.010
The bulk of the
number of crossings

01:12:07.010 --> 01:12:12.260
will be from crossing the
bundles with the single edges.

01:12:12.260 --> 01:12:16.470
You don't want to have
bundle-bundle crossings.

01:12:16.470 --> 01:12:18.000
Those, you can never afford.

01:12:18.000 --> 01:12:20.752
So you're basically counting
bundles versus single edges.

01:12:20.752 --> 01:12:22.460
The total number of
single edge crossings

01:12:22.460 --> 01:12:25.120
will be strictly
less than e squared,

01:12:25.120 --> 01:12:27.330
and so it will be strictly
less than a single guy

01:12:27.330 --> 01:12:29.110
crossing a bundle.

01:12:29.110 --> 01:12:30.456
So you have to inflate.

01:12:30.456 --> 01:12:32.080
It's not an exact
counting, because you

01:12:32.080 --> 01:12:34.163
don't know how many of
those single edge crossings

01:12:34.163 --> 01:12:35.220
you're going to get.

01:12:35.220 --> 01:12:40.810
So you have to add
almost e squared.

01:12:40.810 --> 01:12:42.950
I have the exact count here.

01:12:42.950 --> 01:12:44.950
I don't know how
interesting it is.

01:12:44.950 --> 01:12:50.420
But what they wrote, it's
e squared times k minus e,

01:12:50.420 --> 01:12:54.850
plus 1 minus 1 is the
exact number in the paper.

01:12:54.850 --> 01:12:58.800
k here is the sum of the lengths
of the edges in that problem.

01:12:58.800 --> 01:13:04.686
This is, I think, the minus 1
per edge, that gets multiplied

01:13:04.686 --> 01:13:06.560
by e squared, and then
we're basically adding

01:13:06.560 --> 01:13:08.730
e squared minus 1 at the end.

01:13:08.730 --> 01:13:12.040
So almost e squared to allow
for any number of crossings

01:13:12.040 --> 01:13:13.940
between the single guys.

01:13:13.940 --> 01:13:17.590
It does make a lot of sense.

01:13:17.590 --> 01:13:18.090
OK.

01:13:18.090 --> 01:13:20.040
So that was bipartite
crossing number,

01:13:20.040 --> 01:13:22.230
but the more natural
problem, I would say,

01:13:22.230 --> 01:13:23.920
is I give you a
graph, I want to draw

01:13:23.920 --> 01:13:25.460
on the plane with
fewest crossings.

01:13:25.460 --> 01:13:30.100
That is, crossing number,
and it's a reduction

01:13:30.100 --> 01:13:31.600
from the previous problem.

01:13:31.600 --> 01:13:36.070
So basically, you can
force these vertices

01:13:36.070 --> 01:13:38.810
to be on a horizontal
line, and these vertices

01:13:38.810 --> 01:13:41.050
to be on another
horizontal line,

01:13:41.050 --> 01:13:43.310
and to only have
edges between here

01:13:43.310 --> 01:13:48.400
and here by adding huge bundles
out here to basically prevent

01:13:48.400 --> 01:13:50.990
anything from going out there,

01:13:50.990 --> 01:13:52.610
Now we're given a
bipartite graph.

01:13:52.610 --> 01:13:54.580
We want to draw it
in this kind of way,

01:13:54.580 --> 01:13:56.900
minimizing number of
crossings in between.

01:13:56.900 --> 01:14:00.540
And so this will turn
that into a general graph.

01:14:00.540 --> 01:14:06.160
It's actually still bipartite,
but now the planar embedding

01:14:06.160 --> 01:14:07.580
is forced, more or less.

01:14:07.580 --> 01:14:08.830
I mean, it's not an embedding.

01:14:08.830 --> 01:14:10.240
I keep using that word.

01:14:10.240 --> 01:14:12.310
The planar drawing is
more or less forced.

01:14:12.310 --> 01:14:15.284
You can show these guys have
to be in this kind of topology,

01:14:15.284 --> 01:14:16.950
and then there's some
crossings in here,

01:14:16.950 --> 01:14:18.866
but none of these edges
could ever cross this,

01:14:18.866 --> 01:14:22.290
because this is way more
than the number of crossings

01:14:22.290 --> 01:14:24.065
in the input graph.

01:14:24.065 --> 01:14:24.564
Yeah?

01:14:24.564 --> 01:14:28.470
AUDIENCE: What about
not multi-graphs?

01:14:28.470 --> 01:14:30.120
PROFESSOR: Not multi-graphs?

01:14:30.120 --> 01:14:30.720
Good question.

01:14:30.720 --> 01:14:36.260
I assume you can split
these things up, or maybe

01:14:36.260 --> 01:14:39.360
subdivide the edges,
or some trick,

01:14:39.360 --> 01:14:42.090
but I have to be very careful.

01:14:42.090 --> 01:14:43.510
I don't know for sure.

01:14:43.510 --> 01:14:46.031
Definitely not
mentioned in this paper.

01:14:46.031 --> 01:14:46.530
OK.

01:14:46.530 --> 01:14:53.780
So that was crossing number,
bipartite, and unconstraints.

01:14:53.780 --> 01:15:00.830
And I have one more sketch of a
proof, which is mostly for fun,

01:15:00.830 --> 01:15:02.480
and I get to use
my favorite phrase,

01:15:02.480 --> 01:15:07.110
how to kill log n birds with
one stone, or order one stones.

01:15:07.110 --> 01:15:09.600
So suppose you have
a Rubik's cube,

01:15:09.600 --> 01:15:12.200
but 3, by 3, by 3, that's easy.

01:15:12.200 --> 01:15:15.750
So you have an n, by n, by
n Rubik's cube, like this 7,

01:15:15.750 --> 01:15:20.750
by 7, by 7, v cube, and
moves are-- I assume you all

01:15:20.750 --> 01:15:22.390
know how a Rubik's cube works.

01:15:22.390 --> 01:15:25.730
You can rotate in each
of these directions--

01:15:25.730 --> 01:15:28.960
and I hope not to
mess it up too much--

01:15:28.960 --> 01:15:31.470
and your goal is to get to the
state where it's all solved.

01:15:31.470 --> 01:15:34.610
Now, usually, someone's
mean, and they mix it all up,

01:15:34.610 --> 01:15:36.869
and they just give it
you like, OK solve it.

01:15:36.869 --> 01:15:38.410
I don't just want
to solve it, I want

01:15:38.410 --> 01:15:39.960
to solve it with
the fewest moves,

01:15:39.960 --> 01:15:43.140
because it's polynomial
time to solve it at all.

01:15:43.140 --> 01:15:45.499
I want to solve it
in the fewest moves.

01:15:45.499 --> 01:15:47.040
So if I'm given this
position, I want

01:15:47.040 --> 01:15:48.873
to know it's only one
move away from solved.

01:15:51.350 --> 01:15:54.120
We do not know the
complexity of that problem.

01:15:54.120 --> 01:16:01.100
Let me first tell you a nice
way to think about this problem

01:16:01.100 --> 01:16:03.530
is actually in the 2D case.

01:16:03.530 --> 01:16:06.000
So these are not
built super large,

01:16:06.000 --> 01:16:16.240
but, again, I can rotate
either a row or a column.

01:16:16.240 --> 01:16:19.430
So at a high level, you can
think of a picture like this.

01:16:19.430 --> 01:16:22.270
You have a red side
and a blue side,

01:16:22.270 --> 01:16:25.550
and there's a certain--
If you think about where

01:16:25.550 --> 01:16:28.990
this square goes, it
can go to this position,

01:16:28.990 --> 01:16:30.690
to this position,
and this position.

01:16:30.690 --> 01:16:32.630
In general, a
little cube can only

01:16:32.630 --> 01:16:34.760
go to four different
spots in 2D.

01:16:34.760 --> 01:16:36.710
On the 3D cube,
there's 24 spots it

01:16:36.710 --> 01:16:39.145
can go to, because there are
24 automorphisms on the cube.

01:16:39.145 --> 01:16:41.270
It's just a lot harder to
see, but it's essentially

01:16:41.270 --> 01:16:42.780
the same thing going on.

01:16:42.780 --> 01:16:44.410
So here's a sort of
thing you could do.

01:16:44.410 --> 01:16:48.900
If I flip this column,
these guys go over to here,

01:16:48.900 --> 01:16:50.740
and they flip upside down.

01:16:50.740 --> 01:16:53.840
So whatever was red here
becomes blue down here,

01:16:53.840 --> 01:16:55.670
and it gets reflected
across this line.

01:16:55.670 --> 01:16:58.280
So when I do this move,
I get this pattern

01:16:58.280 --> 01:16:59.940
for that row, that column.

01:16:59.940 --> 01:17:03.120
If I also do it at this
column, I get that pattern.

01:17:03.120 --> 01:17:03.620
OK.

01:17:03.620 --> 01:17:05.650
So now maybe I do
these two columns.

01:17:05.650 --> 01:17:08.030
They completely flip,
become all blue.

01:17:08.030 --> 01:17:11.250
Now maybe I do these two
columns and I get this picture

01:17:11.250 --> 01:17:18.040
because these red spots become
blue up here, and so on.

01:17:18.040 --> 01:17:22.510
And then if I flip these two
rows, hey, I solved the puzzle.

01:17:22.510 --> 01:17:26.440
And in general, if you look at
a [? cubee ?] and the four other

01:17:26.440 --> 01:17:29.349
[? cubees ?] that it can go
to, they have some pattern.

01:17:29.349 --> 01:17:31.390
There's a constant number
patterns they can have.

01:17:31.390 --> 01:17:35.360
For 2D it's-- I forget-- like
10 or 20 different patterns.

01:17:35.360 --> 01:17:38.910
In 3D, it's, like, a lot more.

01:17:38.910 --> 01:17:40.020
Billions or something.

01:17:40.020 --> 01:17:40.860
Anyway.

01:17:40.860 --> 01:17:45.970
But it's constant, even
for an n, by n, by n cube.

01:17:45.970 --> 01:17:49.460
So you can characterize
for each such pattern

01:17:49.460 --> 01:17:50.702
what it needs to be solved.

01:17:50.702 --> 01:17:52.160
So these [? cubees ?],
for example,

01:17:52.160 --> 01:17:55.064
need a column, row, column, row.

01:17:55.064 --> 01:17:55.980
That's what we showed.

01:17:55.980 --> 01:17:58.200
We flipped its column,
then we flipped its row,

01:17:58.200 --> 01:17:59.750
then we flipped its column,
then we flipped its row.

01:17:59.750 --> 01:18:00.430
That solved it.

01:18:00.430 --> 01:18:01.840
That's exactly what they need.

01:18:01.840 --> 01:18:03.830
And in minimal solution,
you will do that.

01:18:03.830 --> 01:18:06.000
But what you see
here is, suppose

01:18:06.000 --> 01:18:07.520
I had a big grid of them.

01:18:07.520 --> 01:18:10.470
I could do all the columns, then
all the rows containing them,

01:18:10.470 --> 01:18:12.300
then all of the columns
and all the rows.

01:18:12.300 --> 01:18:14.770
If they were in the
same initial pattern,

01:18:14.770 --> 01:18:18.410
I get a big savings in how
quickly I can solve it.

01:18:18.410 --> 01:18:21.560
If I have an x by y grid
of identically oriented

01:18:21.560 --> 01:18:23.470
[? cubees ?], I can
solve it in about x

01:18:23.470 --> 01:18:26.300
plus y moves instead
of x times y moves.

01:18:26.300 --> 01:18:29.340
And this is something we used to
prove that you can solve an n,

01:18:29.340 --> 01:18:32.330
by n, by n Rubik's cube and n
squared divided by log n moves,

01:18:32.330 --> 01:18:33.359
in the worst case.

01:18:33.359 --> 01:18:35.150
So you can kill log n
birds with one stone.

01:18:35.150 --> 01:18:39.510
There's always such a grid
of area roughly log n.

01:18:39.510 --> 01:18:44.850
But here, I want to use
that idea for hardness.

01:18:44.850 --> 01:18:47.640
In some sense, that was to
give you some intuition.

01:18:47.640 --> 01:18:49.920
Sadly, we don't know whether
this problem is NP hard,

01:18:49.920 --> 01:18:52.240
minimizing the number
of moves, but what

01:18:52.240 --> 01:18:53.990
we do know is that if
some of the stickers

01:18:53.990 --> 01:18:56.270
fell off your cube,
then it's NP hard.

01:18:56.270 --> 01:18:59.220
So the white things
here don't care.

01:18:59.220 --> 01:19:01.890
You don't care what
state they end up in.

01:19:01.890 --> 01:19:03.490
They're sort of
wild cards, so it

01:19:03.490 --> 01:19:05.290
could be the sticker
came off or maybe

01:19:05.290 --> 01:19:06.990
it just changes its
color to whatever's

01:19:06.990 --> 01:19:08.909
correct at the moment.

01:19:08.909 --> 01:19:10.450
But some of the
stickers are still on

01:19:10.450 --> 01:19:12.650
and they have to be
solved, and this is

01:19:12.650 --> 01:19:15.746
a reduction from betweenness.

01:19:15.746 --> 01:19:19.730
This gadget will be solvable
in a certain number of moves

01:19:19.730 --> 01:19:26.430
if and only if the first time
you make the x2 column move

01:19:26.430 --> 01:19:29.560
is between the first time
you make the x1 column

01:19:29.560 --> 01:19:32.164
move and the x3 column move.

01:19:32.164 --> 01:19:33.580
I think these are
in the situation

01:19:33.580 --> 01:19:35.967
that they want to do
column, row, column, row,

01:19:35.967 --> 01:19:36.800
something like that.

01:19:36.800 --> 01:19:38.500
So each one's going
to get used twice.

01:19:38.500 --> 01:19:41.100
It's a matter of how you
intersperse those orders.

01:19:41.100 --> 01:19:43.920
So it's an ordering problem, and
this ends up being betweenness.

01:19:43.920 --> 01:19:45.253
I will not go through the proof.

01:19:45.253 --> 01:19:48.030
It's quite tedious.

01:19:48.030 --> 01:19:50.010
So this column is going
to get used many times

01:19:50.010 --> 01:19:51.480
in the reduction.

01:19:51.480 --> 01:19:53.870
Basically, you just work
in the upper left corner

01:19:53.870 --> 01:19:59.620
of the picture because the
other quarters move similarly.

01:19:59.620 --> 01:20:01.380
You introduce some
extra rows and columns

01:20:01.380 --> 01:20:03.730
that are specific to
this betweenness gadget,

01:20:03.730 --> 01:20:06.220
and if you want to have
more betweenness gadgets,

01:20:06.220 --> 01:20:10.597
you add more such columns
and rows in this pattern.

01:20:10.597 --> 01:20:12.930
As long as they're sort of
off diagonal from each other,

01:20:12.930 --> 01:20:15.870
they won't interact, hence you
end up with a big betweenness

01:20:15.870 --> 01:20:18.410
reduction.

01:20:18.410 --> 01:20:20.990
So that's it for today.