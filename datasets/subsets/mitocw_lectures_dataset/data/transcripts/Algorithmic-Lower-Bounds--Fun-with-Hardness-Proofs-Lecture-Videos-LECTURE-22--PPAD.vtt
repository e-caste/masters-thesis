WEBVTT

00:00:00.080 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.820
Commons license.

00:00:03.820 --> 00:00:06.060
Your support will help
MIT OpenCourseWare

00:00:06.060 --> 00:00:10.150
continue to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.255
at ocw.mit.edu.

00:00:26.570 --> 00:00:28.070
PROFESSOR: So welcome
back to 6.890.

00:00:28.070 --> 00:00:30.240
Today we have the
first of two guest

00:00:30.240 --> 00:00:34.855
lectures by Costis Daskalakis
about PPAD completeness.

00:00:34.855 --> 00:00:35.730
Take it away, Costis.

00:00:35.730 --> 00:00:36.896
CONSTANTINOS DASKALAKIS: OK.

00:00:36.896 --> 00:00:40.300
Thanks for the invitation
to talk about PPAD.

00:00:40.300 --> 00:00:44.410
This is sort of an unusual class
if you haven't seen it before.

00:00:44.410 --> 00:00:46.610
So part of the
lecture is to describe

00:00:46.610 --> 00:00:49.840
the class and the motivation
behind this definition.

00:00:49.840 --> 00:00:54.830
If I start with the definition
itself, it may seem weird.

00:00:54.830 --> 00:00:57.860
So instead, I want to
provide some motivation

00:00:57.860 --> 00:00:58.790
about the definition.

00:00:58.790 --> 00:01:00.790
And then sort of towards
the end of the lecture,

00:01:00.790 --> 00:01:02.670
we're going to see
the definition.

00:01:02.670 --> 00:01:06.380
We're also going to see our
first PPAD complete problem

00:01:06.380 --> 00:01:07.910
in the end of this lecture.

00:01:07.910 --> 00:01:13.300
And the next lecture, I'm
going to describe more natural,

00:01:13.300 --> 00:01:16.221
if you want, problems
about PPAD complete.

00:01:16.221 --> 00:01:16.720
OK.

00:01:16.720 --> 00:01:21.670
So the motivation for
me looking at this class

00:01:21.670 --> 00:01:28.560
is some beautiful theorems
in game theory, economics,

00:01:28.560 --> 00:01:33.720
and topology, namely Nash's
theorem, Brouwer's theorem,

00:01:33.720 --> 00:01:36.200
and Sperner's theorem.

00:01:36.200 --> 00:01:38.670
And I want to describe
those theorems

00:01:38.670 --> 00:01:40.880
before I get into the
computational complexity

00:01:40.880 --> 00:01:43.370
of the resulting problems.

00:01:43.370 --> 00:01:45.630
So let me start
with Nash's theorem.

00:01:45.630 --> 00:01:49.960
So this table represents a
game between two players.

00:01:49.960 --> 00:01:51.670
The rows correspond
to the strategies

00:01:51.670 --> 00:01:53.580
available to the blue player.

00:01:53.580 --> 00:01:55.860
And the columns correspond
to the strategies

00:01:55.860 --> 00:01:57.750
available to the column player.

00:01:57.750 --> 00:02:02.270
And then every box in this
table writes down the playoffs

00:02:02.270 --> 00:02:05.180
that the two players
get if they chose

00:02:05.180 --> 00:02:06.390
the corresponding strategies.

00:02:06.390 --> 00:02:09.220
In particular-- so this
is a penalty shot game.

00:02:09.220 --> 00:02:14.590
If the goalie dives left,
and the kicker shoots right,

00:02:14.590 --> 00:02:17.206
then the goalie loses a point.

00:02:17.206 --> 00:02:20.860
The kicker gets a point.

00:02:20.860 --> 00:02:25.150
More generally, in
a game, you have

00:02:25.150 --> 00:02:29.050
to specify the players n,
the number of players n,

00:02:29.050 --> 00:02:31.360
the set of players n.

00:02:31.360 --> 00:02:34.910
Then for every
player p, you have

00:02:34.910 --> 00:02:39.700
to specify the set of strategies
available to this player.

00:02:39.700 --> 00:02:41.730
And also for every
player p, you have

00:02:41.730 --> 00:02:47.780
to describe a payoff function
Up that maps the strategies

00:02:47.780 --> 00:02:52.020
of everybody to the reals.

00:02:54.680 --> 00:03:04.370
So in particular, so Up of
a collection of strategies

00:03:04.370 --> 00:03:07.710
for all the players
corresponds to the payoff

00:03:07.710 --> 00:03:10.140
that player p gets if
the players chooses

00:03:10.140 --> 00:03:13.640
these strategies from
the corresponding sets.

00:03:13.640 --> 00:03:15.510
That's a general
definition of a game.

00:03:15.510 --> 00:03:18.020
But in that picture, I
have a two player game

00:03:18.020 --> 00:03:21.470
with two strategies per
player for simplicity.

00:03:21.470 --> 00:03:28.680
Now what game theory
studies and tries to predict

00:03:28.680 --> 00:03:35.160
is what happens when two
players interact in the way

00:03:35.160 --> 00:03:38.180
described by a payoff
table and have developed

00:03:38.180 --> 00:03:40.320
various notions of
equilibrium that

00:03:40.320 --> 00:03:43.410
may arise as a result
of this interaction.

00:03:43.410 --> 00:03:47.120
The one that is of particular
interest to us in this lecture

00:03:47.120 --> 00:03:50.050
is what is called the
Nash equilibrium, which

00:03:50.050 --> 00:03:52.630
is a pair of randomized
strategies for the two

00:03:52.630 --> 00:03:55.780
players of the game
such that none of them

00:03:55.780 --> 00:03:59.090
has incentive to change
their strategy given

00:03:59.090 --> 00:04:01.930
the strategy of
the other player.

00:04:01.930 --> 00:04:06.450
In this particular example,
the Nash equilibrium,

00:04:06.450 --> 00:04:08.000
which is actually
the unique one--

00:04:08.000 --> 00:04:10.360
a Nash equilibrium which is
the unique one of this game

00:04:10.360 --> 00:04:14.400
is for both players to
uniformly randomly play each

00:04:14.400 --> 00:04:16.680
of their available strategies.

00:04:16.680 --> 00:04:21.610
And it's quite easy to check
that this is a Nash equilibrium

00:04:21.610 --> 00:04:28.140
because given-- so for from
the kicker's perspective, given

00:04:28.140 --> 00:04:33.200
that the goalie uniformly
randomly dives left or right,

00:04:33.200 --> 00:04:36.370
the expected payoff from
shooting left or right

00:04:36.370 --> 00:04:38.230
is exactly 0.

00:04:38.230 --> 00:04:40.050
So in particular, any
complex combination

00:04:40.050 --> 00:04:43.320
of these two strategies
has an expected pay of 0.

00:04:43.320 --> 00:04:46.210
And he cannot improve it by
changing the mixing weights

00:04:46.210 --> 00:04:47.380
in any way.

00:04:47.380 --> 00:04:50.040
So given what the
goalie is doing,

00:04:50.040 --> 00:04:54.860
it's in the best interest of
the kicker to play half, half.

00:04:54.860 --> 00:04:56.670
And vice versa.

00:04:56.670 --> 00:04:59.900
You can do the same calculation
from the goalie's perspective.

00:04:59.900 --> 00:05:02.790
And given what the
kicker is doing,

00:05:02.790 --> 00:05:06.510
the goalie cannot improve
his expected payoff.

00:05:06.510 --> 00:05:11.650
So more generally,
in the general case,

00:05:11.650 --> 00:05:20.500
every player chooses
a randomized strategy.

00:05:20.500 --> 00:05:24.540
A randomized strategy is a
distribution over the strategy

00:05:24.540 --> 00:05:25.540
set of the players.

00:05:25.540 --> 00:05:29.320
So it's going to be--
with this symbol,

00:05:29.320 --> 00:05:32.790
I represent the collection of
distributions over the set.

00:05:36.030 --> 00:05:41.870
And I can extend this
function to distributions.

00:05:41.870 --> 00:05:45.405
So let's call this the
extension of that function

00:05:45.405 --> 00:05:46.900
to distributions.

00:05:46.900 --> 00:05:51.360
When I get as input a collection
of mixed strategies, what

00:05:51.360 --> 00:05:53.950
I'm going to do is I'm going
to look at the expectation

00:05:53.950 --> 00:05:59.570
where every-- according to
these strategies, this s1

00:05:59.570 --> 00:06:04.870
drawn from x1, s2 drawn from
x2 and so on and so forth,

00:06:04.870 --> 00:06:06.890
sn drawn from xn.

00:06:06.890 --> 00:06:10.160
I'm going to look at
the expected utility

00:06:10.160 --> 00:06:13.030
under strategies, actions
that are chosen according

00:06:13.030 --> 00:06:14.580
to this randomization.

00:06:14.580 --> 00:06:18.600
So that's the expected
utility of player p

00:06:18.600 --> 00:06:22.020
if players choose
these mixed strategies.

00:06:22.020 --> 00:06:33.540
And Nash equilibrium in general
has a definition, a collection,

00:06:33.540 --> 00:06:39.110
x1, x2, et cetera,
of mixed strategies

00:06:39.110 --> 00:06:45.400
is a Nash equilibrium
if and only

00:06:45.400 --> 00:06:55.430
if for every player p, the
expected utility that p gets

00:06:55.430 --> 00:07:02.200
by playing this strategy is at
least as good as the expected

00:07:02.200 --> 00:07:10.600
utility he would get if he
switched to something else

00:07:10.600 --> 00:07:13.530
for any other mixed strategy
he could possibly play.

00:07:17.780 --> 00:07:18.410
OK?

00:07:18.410 --> 00:07:23.070
So if none of the other players
change their strategies,

00:07:23.070 --> 00:07:26.380
there's no alternative
mixed strategy

00:07:26.380 --> 00:07:31.040
for this player that
may improve his payoff.

00:07:31.040 --> 00:07:34.450
So if that's simultaneously
true for all players,

00:07:34.450 --> 00:07:38.210
then that collection is
called the Nash equilibrium.

00:07:38.210 --> 00:07:40.420
And that example is
just a special case

00:07:40.420 --> 00:07:42.480
of this definition.

00:07:42.480 --> 00:07:46.322
Any questions about what
a Nash equilibrium is?

00:07:46.322 --> 00:07:48.100
OK.

00:07:48.100 --> 00:07:51.540
Now there are games
and games, right?

00:07:51.540 --> 00:07:53.710
And this game is a
particularly simple one.

00:07:53.710 --> 00:07:56.440
First of all, it has two
players and two strategies.

00:07:56.440 --> 00:07:58.430
But also it's very
symmetric in some sense.

00:08:02.210 --> 00:08:04.270
If I look at every
square of this table,

00:08:04.270 --> 00:08:08.360
the sum of payoffs
in each square is 0.

00:08:08.360 --> 00:08:11.420
These types of games are called
two player zero-sum games.

00:08:11.420 --> 00:08:16.380
And the existence of
equilibrium in these games

00:08:16.380 --> 00:08:17.700
was shown by von Neumann.

00:08:17.700 --> 00:08:21.060
So von Neumann showed that
any two players zero-sum game

00:08:21.060 --> 00:08:24.610
has such an equilibrium.

00:08:24.610 --> 00:08:29.462
I mean, a priori, it's not
clear if in a given game

00:08:29.462 --> 00:08:30.920
there is a collection
of strategies

00:08:30.920 --> 00:08:33.330
that are a Nash equilibrium.

00:08:33.330 --> 00:08:35.740
The first one to
establish such a result

00:08:35.740 --> 00:08:39.669
was von Neumann in the '20s, who
showed that if a game has two

00:08:39.669 --> 00:08:41.230
players, and it's
a zero-sum game,

00:08:41.230 --> 00:08:45.090
then there is always an
equilibrium in that game.

00:08:45.090 --> 00:08:48.280
By the way, the equilibrium
wasn't called Nash equilibrium

00:08:48.280 --> 00:08:50.160
at the time, because
Nash wasn't around.

00:08:50.160 --> 00:08:56.000
It is known as the
minmax equilibrium.

00:08:56.000 --> 00:08:59.650
And in fact, later on when
Dantzig was developing

00:08:59.650 --> 00:09:03.620
linear programming duality
together with von Neumann,

00:09:03.620 --> 00:09:07.970
they realized that this
theorem is actually implied

00:09:07.970 --> 00:09:11.030
by the strong LP duality.

00:09:11.030 --> 00:09:13.320
They also noticed that
using linear programming,

00:09:13.320 --> 00:09:17.650
you can compute equilibria
in these types of games.

00:09:17.650 --> 00:09:21.710
In fact now-- but that
took many years more.

00:09:21.710 --> 00:09:24.230
We know that this statement
and strong LP duality

00:09:24.230 --> 00:09:27.220
are actually equivalent
mathematical statements.

00:09:27.220 --> 00:09:27.720
OK.

00:09:27.720 --> 00:09:30.520
So the existence of equilibrium
in two player zero-sum games

00:09:30.520 --> 00:09:34.030
is equivalent to linear
programming duality.

00:09:34.030 --> 00:09:35.250
All right?

00:09:35.250 --> 00:09:36.580
But how about general games?

00:09:36.580 --> 00:09:39.560
What happens if I go to
this table, and I change it?

00:09:39.560 --> 00:09:42.580
Or I consider a game with
more than two players?

00:09:42.580 --> 00:09:46.120
So what happens, for example, if
I change this game in this way?

00:09:46.120 --> 00:09:50.140
Now I gave a big
advantage to the goalie

00:09:50.140 --> 00:09:57.090
in the left, left
choice of strategies.

00:09:57.090 --> 00:10:02.450
Now before Nash was
around, it was unclear

00:10:02.450 --> 00:10:07.340
if a general game has
a Nash equilibrium.

00:10:07.340 --> 00:10:11.460
This is what Nash established
in his celebrated paper.

00:10:11.460 --> 00:10:14.410
Nash showed that any
game, any finite game

00:10:14.410 --> 00:10:16.690
has a mixed Nash equilibrium.

00:10:16.690 --> 00:10:18.790
So a Nash equilibrium
and equilibrium

00:10:18.790 --> 00:10:21.160
in randomized strategies.

00:10:21.160 --> 00:10:23.630
Unfortunately,
what is not known--

00:10:23.630 --> 00:10:27.800
in this particular example,
this is the Nash equilibrium.

00:10:27.800 --> 00:10:30.310
You can verify that this is
actually a Nash equilibrium,

00:10:30.310 --> 00:10:31.710
what I'm showing there.

00:10:31.710 --> 00:10:35.555
But the point of the
slide is that there

00:10:35.555 --> 00:10:38.060
is a qualitative difference
when you go from two players

00:10:38.060 --> 00:10:40.840
zero-sum games to general games.

00:10:40.840 --> 00:10:44.430
In 60 or so years of work
after Nash's theorem,

00:10:44.430 --> 00:10:47.710
we have no proof
using LP duality.

00:10:47.710 --> 00:10:50.110
And we have no polynomial
time algorithms

00:10:50.110 --> 00:10:53.870
for finding equilibria
in general games.

00:10:53.870 --> 00:10:56.220
So part of this
lecture is to try

00:10:56.220 --> 00:11:00.990
to understand the computational
complexity of this problem.

00:11:00.990 --> 00:11:05.730
Given a game, how hard is it
to find a Nash equilibrium?

00:11:05.730 --> 00:11:06.250
OK.

00:11:06.250 --> 00:11:10.250
So that's problem number
one that I want to consider.

00:11:10.250 --> 00:11:10.770
Question?

00:11:10.770 --> 00:11:15.046
AUDIENCE: So the thing that
Nash proved, every game

00:11:15.046 --> 00:11:18.379
refers to any number
of players and--

00:11:18.379 --> 00:11:19.670
CONSTANTINOS DASKALAKIS: Right.

00:11:19.670 --> 00:11:26.490
Any finite number of
players, any strategy set,

00:11:26.490 --> 00:11:28.470
any utility functions.

00:11:28.470 --> 00:11:29.970
No matter how it
looks like, there's

00:11:29.970 --> 00:11:31.332
always a Nash equilibrium.

00:11:33.930 --> 00:11:35.850
OK?

00:11:35.850 --> 00:11:36.920
Other questions?

00:11:36.920 --> 00:11:40.810
This is, let's say, the actor
number one in this lecture.

00:11:43.770 --> 00:11:46.880
So the second actor
is Brouwer's theorem,

00:11:46.880 --> 00:11:50.090
which I want to illustrate
in the next few slides.

00:11:50.090 --> 00:11:52.280
The statement of the
theorem is very simple.

00:11:52.280 --> 00:11:55.190
It says that given
a function that

00:11:55.190 --> 00:12:00.025
maps a convex and compact
subset of the Euclidean space

00:12:00.025 --> 00:12:04.890
to itself-- so I don't know.

00:12:04.890 --> 00:12:07.650
In this setting, compact means
basically closed and bounded.

00:12:07.650 --> 00:12:10.190
So if you have a function
that maps a convex,

00:12:10.190 --> 00:12:13.675
closed, and bounded subset
of Euclidean space to itself,

00:12:13.675 --> 00:12:16.810
it must have a
point that doesn't

00:12:16.810 --> 00:12:18.440
move under the function.

00:12:21.516 --> 00:12:25.260
And I want to illustrate this
with a couple of examples.

00:12:25.260 --> 00:12:27.150
And for my examples,
I'm going to choose

00:12:27.150 --> 00:12:32.525
for D the disk, the unit disk.

00:12:36.790 --> 00:12:40.656
I'm going to note that all
conditions are needed actually

00:12:40.656 --> 00:12:41.780
for the theorem to be true.

00:12:41.780 --> 00:12:49.350
If you remove any of these
things, closeness, convexity,

00:12:49.350 --> 00:12:52.775
or bondedness,
the theorem fails.

00:12:52.775 --> 00:12:54.400
So I'm going to do
a bunch of examples,

00:12:54.400 --> 00:12:56.580
and you can think about
what may happen if you

00:12:56.580 --> 00:12:59.180
remove one of these conditions.

00:12:59.180 --> 00:13:01.970
So my first example is
to map the disk to itself

00:13:01.970 --> 00:13:05.240
by just rotating the disk.

00:13:05.240 --> 00:13:07.660
Now there is an
obvious fixed point

00:13:07.660 --> 00:13:14.380
in this map, which is the
center, as you may imagine.

00:13:14.380 --> 00:13:16.960
There's actually no
other fixed point.

00:13:16.960 --> 00:13:19.480
What if I take this
disk, and I shrink it,

00:13:19.480 --> 00:13:23.019
and then I shift it
somewhere inside it?

00:13:23.019 --> 00:13:23.560
I don't know.

00:13:23.560 --> 00:13:25.720
Maybe it takes a
little thinking,

00:13:25.720 --> 00:13:28.615
but you should believe
me that there must be

00:13:28.615 --> 00:13:30.110
a fixed point somewhere there.

00:13:32.970 --> 00:13:42.060
Or a fixed point still exists
if I kind of crumble the disk

00:13:42.060 --> 00:13:44.050
and move it.

00:13:44.050 --> 00:13:47.390
As long as I don't tear it
apart, that's a continuous map.

00:13:47.390 --> 00:13:49.534
And there's still a fixed point.

00:13:49.534 --> 00:13:50.950
And you probably
colloquially have

00:13:50.950 --> 00:13:54.350
heard that if I take
a map of Cambridge,

00:13:54.350 --> 00:13:56.760
and I throw it on
the ground, then

00:13:56.760 --> 00:13:58.740
there is a point on
the map that sits

00:13:58.740 --> 00:14:02.340
on top of the corresponding
point that it represents.

00:14:02.340 --> 00:14:04.790
This is a special
version of this theorem

00:14:04.790 --> 00:14:08.070
because effectively when
I'm throwing a Cambridge

00:14:08.070 --> 00:14:12.550
map to the ground, I define
a mapping from real points

00:14:12.550 --> 00:14:14.170
to points in the map.

00:14:14.170 --> 00:14:17.850
And by this theorem, there
is a point that doesn't move.

00:14:17.850 --> 00:14:19.100
OK?

00:14:19.100 --> 00:14:22.860
So that's what Brouwer's
theorem is saying.

00:14:22.860 --> 00:14:27.910
And the proof of Nash
actually uses this theorem.

00:14:27.910 --> 00:14:30.350
To show that the Nash
equilibrium exists,

00:14:30.350 --> 00:14:33.230
what Nash did is he
used Brouwer's theorem.

00:14:33.230 --> 00:14:35.920
And the next slide, I
want to illustrate the way

00:14:35.920 --> 00:14:42.260
Nash gets to prove the Nash
equilibrium's existence

00:14:42.260 --> 00:14:44.020
by using Brouwer's theorem.

00:14:44.020 --> 00:14:46.450
And I'm going to restrict
myself to the simple game we

00:14:46.450 --> 00:14:49.177
saw in the beginning,
the penalty shot game.

00:14:49.177 --> 00:14:50.760
And as I said, for
this specific game,

00:14:50.760 --> 00:14:52.468
you don't need Brouwer's
theorem to prove

00:14:52.468 --> 00:14:54.900
the existence of equilibrium,
because this is a two player

00:14:54.900 --> 00:14:57.470
zero-sum game, and you can even
do it with linear programming

00:14:57.470 --> 00:14:58.640
duality.

00:14:58.640 --> 00:15:02.070
But it's a simple
enough example that

00:15:02.070 --> 00:15:05.130
will help illustrate the
proof of Nash's theorem.

00:15:05.130 --> 00:15:06.750
So here's what Nash does.

00:15:06.750 --> 00:15:08.370
He starts with a game.

00:15:08.370 --> 00:15:13.240
And then he defines a continuous
function, in this case,

00:15:13.240 --> 00:15:19.600
from the square to itself,
from the unit square to itself

00:15:19.600 --> 00:15:21.900
in a way that the fixed
points of that function

00:15:21.900 --> 00:15:26.220
are actually exactly
Nash equilibria.

00:15:26.220 --> 00:15:28.720
The way the function
looks, where basically,

00:15:28.720 --> 00:15:29.610
what is the square?

00:15:29.610 --> 00:15:33.550
The square represents
the probability--

00:15:33.550 --> 00:15:35.920
the horizontal line is
the probability by which

00:15:35.920 --> 00:15:39.350
the kicker shoots right.

00:15:39.350 --> 00:15:41.650
The vertical axis is
the probability by which

00:15:41.650 --> 00:15:44.870
the goalie dives right.

00:15:44.870 --> 00:15:48.040
And then the
function is basically

00:15:48.040 --> 00:15:51.430
tracking which of
the two players

00:15:51.430 --> 00:15:55.610
has incentive to
change his strategy

00:15:55.610 --> 00:15:57.870
at every point in this quarter.

00:15:57.870 --> 00:16:00.460
So in particular, let's
consider this square over here.

00:16:00.460 --> 00:16:03.860
In this square, both
players play left.

00:16:03.860 --> 00:16:06.770
And the kicker is
actually unhappy.

00:16:06.770 --> 00:16:09.550
If both players play
left, the kicker

00:16:09.550 --> 00:16:10.930
wants to increase
the probability

00:16:10.930 --> 00:16:13.260
by which he is shooting right.

00:16:13.260 --> 00:16:15.990
So this is what this
arrow represents.

00:16:15.990 --> 00:16:18.960
So you want to increase
the probability over here.

00:16:18.960 --> 00:16:23.470
Similarly, if you're here,
they play opposite actions.

00:16:23.470 --> 00:16:27.660
Hence, the goalie wants to
change and so on and so forth.

00:16:27.660 --> 00:16:30.680
What Nash is-- I'm not going
to write down Nash's function,

00:16:30.680 --> 00:16:33.080
but intuitively, this
is what it tracks.

00:16:33.080 --> 00:16:37.220
It tracks at every combination
of mixed strategies,

00:16:37.220 --> 00:16:40.000
which players have
incentive to change

00:16:40.000 --> 00:16:43.360
their actions,
their randomizations

00:16:43.360 --> 00:16:44.530
and in which direction?

00:16:44.530 --> 00:16:48.315
This is what Nash's
function does.

00:16:48.315 --> 00:16:51.040
And in fact, to help
you a little bit,

00:16:51.040 --> 00:16:56.250
I'm going to even
color the unit square,

00:16:56.250 --> 00:17:00.630
depending on the direction
of the deviation.

00:17:00.630 --> 00:17:03.800
So this is the
picture that I get.

00:17:03.800 --> 00:17:07.260
It's very easy to locate
the fixed point as the point

00:17:07.260 --> 00:17:08.390
where all colors meet.

00:17:08.390 --> 00:17:12.550
And this is exactly half,
half, which is exactly

00:17:12.550 --> 00:17:14.790
the Nash equilibrium over here.

00:17:14.790 --> 00:17:19.440
This is a schematic
proof by picture.

00:17:19.440 --> 00:17:24.089
So this is an illustration
of Nash's proof.

00:17:27.119 --> 00:17:31.502
Any questions about Brouwer's
theorem or the proof?

00:17:31.502 --> 00:17:33.970
OK.

00:17:33.970 --> 00:17:37.345
The last actor-- so the last
actor is Sperner's lemma.

00:17:40.290 --> 00:17:42.830
It's a lemma in combinatorics,
but it's very related

00:17:42.830 --> 00:17:45.330
to topological statements.

00:17:50.660 --> 00:17:56.480
So the lemma
considers-- there are

00:17:56.480 --> 00:17:58.180
multiple versions of the lemma.

00:17:58.180 --> 00:18:02.960
And I'm going to show it in
two dimensions on the square.

00:18:02.960 --> 00:18:06.200
There are multi-dimensional
versions of the lemma.

00:18:06.200 --> 00:18:08.440
But I'm going to restrict
myself to the plane.

00:18:08.440 --> 00:18:11.390
And the lemma is going to
start with a triangulation

00:18:11.390 --> 00:18:13.660
of the grid.

00:18:13.660 --> 00:18:15.900
And I'm going to color
this triangulation

00:18:15.900 --> 00:18:18.296
with three colors.

00:18:18.296 --> 00:18:19.920
More generally, if
I'm in n dimensions,

00:18:19.920 --> 00:18:22.260
I'm going to be coloring
things with n plus 1 colors.

00:18:22.260 --> 00:18:23.440
Here I'm in two dimensions.

00:18:23.440 --> 00:18:26.220
I'm coloring with three colors.

00:18:26.220 --> 00:18:29.890
So the way I'm going to color
this square is the following.

00:18:29.890 --> 00:18:34.120
First, I'm obliged to use
this coloring on the boundary.

00:18:34.120 --> 00:18:37.000
Notice that this boundary
has the property that there

00:18:37.000 --> 00:18:38.400
is no red color here.

00:18:38.400 --> 00:18:39.890
There is no blue color here.

00:18:39.890 --> 00:18:46.670
There is no yellow color here
on that edge of the grid.

00:18:46.670 --> 00:18:49.860
But otherwise, I'm allowing you
to color the internal vertices

00:18:49.860 --> 00:18:52.700
in whatever fashion you want.

00:18:52.700 --> 00:18:56.900
All I want is to respect
the boundary coloring.

00:18:56.900 --> 00:18:59.700
So Sperner's lemma
says that no matter how

00:18:59.700 --> 00:19:02.830
you color the inside
of the square,

00:19:02.830 --> 00:19:07.550
there is always a
tri-chromatic triangle.

00:19:07.550 --> 00:19:08.970
In fact, it says something more.

00:19:08.970 --> 00:19:11.980
It says that there is
always an odd number

00:19:11.980 --> 00:19:15.310
of tri-chromatic triangles.

00:19:15.310 --> 00:19:19.164
Can you see one in this picture?

00:19:19.164 --> 00:19:20.680
AUDIENCE: I hope so.

00:19:20.680 --> 00:19:22.763
CONSTANTINOS DASKALAKIS:
You would hope so, right?

00:19:22.763 --> 00:19:24.760
So there are five in this case.

00:19:24.760 --> 00:19:25.478
Here they are.

00:19:27.985 --> 00:19:29.610
And later in the--
I mean, I'm actually

00:19:29.610 --> 00:19:31.640
going to show the proof
of Sperner's lemma

00:19:31.640 --> 00:19:35.830
because it's instructive for my
purposes later in this lecture.

00:19:35.830 --> 00:19:36.990
It's really remarkable.

00:19:36.990 --> 00:19:40.060
I mean, a priori, I
mean maybe you believe

00:19:40.060 --> 00:19:42.490
there's a tri-chromatic one.

00:19:42.490 --> 00:19:43.750
But it's not at all.

00:19:43.750 --> 00:19:47.350
Obviously, there should
be an odd number.

00:19:47.350 --> 00:19:49.630
And the proof is actually
going to easily give also

00:19:49.630 --> 00:19:53.570
the odd number as well.

00:19:53.570 --> 00:19:55.122
So that's the lemma.

00:19:55.122 --> 00:19:56.080
That's Sperner's lemma.

00:19:56.080 --> 00:19:57.000
Any questions?

00:19:57.000 --> 00:19:59.240
AUDIENCE: Can you repeat
where the legal coloring is?

00:19:59.240 --> 00:20:00.490
CONSTANTINOS DASKALAKIS: Yeah.

00:20:00.490 --> 00:20:04.210
So the legal coloring
says that either

00:20:04.210 --> 00:20:06.510
fix the color to be like this.

00:20:06.510 --> 00:20:12.380
Or more generally, as long
as you don't use red here,

00:20:12.380 --> 00:20:16.695
don't use yellow here, and not
use blue here, you're good.

00:20:16.695 --> 00:20:19.022
AUDIENCE: I don't understand
the general statement.

00:20:19.022 --> 00:20:20.980
CONSTANTINOS DASKALAKIS:
The general definition

00:20:20.980 --> 00:20:23.980
is that-- OK.

00:20:23.980 --> 00:20:27.520
So we have this square.

00:20:27.520 --> 00:20:31.170
There must be-- OK.

00:20:31.170 --> 00:20:33.470
So more general, no
yellow in these vertices.

00:20:36.700 --> 00:20:42.330
There should be no
blue on these vertices.

00:20:42.330 --> 00:20:51.230
And there should be no red here.

00:20:51.230 --> 00:20:53.380
That's the general statement.

00:20:53.380 --> 00:20:54.940
As long as you
respect that, then

00:20:54.940 --> 00:20:57.385
no matter what you
do inside, there

00:20:57.385 --> 00:20:59.744
is a tri-chromatic triangle.

00:20:59.744 --> 00:21:01.660
Or you could just fix
the coloring to be that.

00:21:01.660 --> 00:21:03.350
It doesn't really matter.

00:21:03.350 --> 00:21:06.930
In fact, if you have
such a coloring,

00:21:06.930 --> 00:21:09.560
respecting these
three properties,

00:21:09.560 --> 00:21:12.160
you can enlarge the
square by adding

00:21:12.160 --> 00:21:16.690
an extra layer that has exactly
the coloring I'm showing here.

00:21:16.690 --> 00:21:20.690
And you can notice that if
your original coloring respects

00:21:20.690 --> 00:21:23.885
these properties, if I
add this specific coloring

00:21:23.885 --> 00:21:26.620
in this extra layer, I'm
not going to be creating

00:21:26.620 --> 00:21:28.590
any triangles in this layer.

00:21:28.590 --> 00:21:31.300
So in fact, I can reduce
one instance to the other.

00:21:34.171 --> 00:21:34.670
All right.

00:21:34.670 --> 00:21:37.870
So this is the statement
of Sperner's lemma.

00:21:37.870 --> 00:21:40.900
There is a multi-dimensional
version in n dimensions.

00:21:40.900 --> 00:21:42.300
I'm using n plus 1 colors.

00:21:42.300 --> 00:21:43.758
But I'm not going
to state it here.

00:21:46.920 --> 00:21:49.560
Now again, I'm
going to hand wave

00:21:49.560 --> 00:21:53.550
to actually show you how
Brouwer's theorem is actually

00:21:53.550 --> 00:21:55.270
implied by Sperner's lemma.

00:21:58.150 --> 00:22:00.610
So in fact, one proof
of Brouwer is actually

00:22:00.610 --> 00:22:02.760
going through Sperner.

00:22:02.760 --> 00:22:04.670
Here's the high level
proof of the argument.

00:22:07.660 --> 00:22:10.580
Given a function-- I'm going
to do it on the square,

00:22:10.580 --> 00:22:14.310
on the unit square
in two dimensions.

00:22:14.310 --> 00:22:16.140
So suppose I'm given
a continuous function

00:22:16.140 --> 00:22:21.220
from the square to itself,
what I'm going to do

00:22:21.220 --> 00:22:25.980
is I'm going to prove for all
epsilons-- for all epsilons,

00:22:25.980 --> 00:22:29.340
I'm going to show that there
exists an approximate fixed

00:22:29.340 --> 00:22:32.730
point with
approximation epsilon.

00:22:32.730 --> 00:22:33.990
using Sperner's lemma.

00:22:33.990 --> 00:22:36.510
That's what I'm going to
do with Sperner's lemma.

00:22:36.510 --> 00:22:39.520
And then I'm going to use
a compactness argument

00:22:39.520 --> 00:22:41.220
to get this down to 0.

00:22:41.220 --> 00:22:45.275
So I'm going to create in fact
a sequence of approximate fixed

00:22:45.275 --> 00:22:48.050
points with smaller
and smaller epsilons.

00:22:48.050 --> 00:22:50.700
And I'm going to use
compactness-- remember,

00:22:50.700 --> 00:22:53.710
this is a compact set--
to argue that there

00:22:53.710 --> 00:22:55.750
is an exact fixed point.

00:22:55.750 --> 00:22:58.870
So Sperner's lemma can be
used for this first part

00:22:58.870 --> 00:23:00.000
of the proof.

00:23:00.000 --> 00:23:03.550
And roughly speaking, the way
it's used is the following.

00:23:03.550 --> 00:23:07.590
What you do is you first
triangulate the square.

00:23:07.590 --> 00:23:12.030
And the diameter
of your triangles,

00:23:12.030 --> 00:23:15.940
which is very rough in this
picture-- the diameter of this

00:23:15.940 --> 00:23:20.910
will depend on the constant
of absolute continuity

00:23:20.910 --> 00:23:21.920
of your function.

00:23:21.920 --> 00:23:25.400
So if the function is
ellipsis, it's just

00:23:25.400 --> 00:23:29.120
going to depend on epsilon
and the ellipsis constant.

00:23:29.120 --> 00:23:32.820
So depending on the
ellipsisness of the function,

00:23:32.820 --> 00:23:36.410
there's going to be a
finer triangulation.

00:23:36.410 --> 00:23:40.810
Now having
triangulated the square

00:23:40.810 --> 00:23:43.760
and adding this
extra layer outside,

00:23:43.760 --> 00:23:46.630
you're going to color the
vertices that are inside

00:23:46.630 --> 00:23:49.730
depending on the direction
of the displacements

00:23:49.730 --> 00:23:52.670
f of x minus x, using
exactly the same coloring

00:23:52.670 --> 00:23:56.570
schema I showed you earlier
for the illustration of how

00:23:56.570 --> 00:24:02.510
Nash showed the existence
of equilibria using Brouwer.

00:24:02.510 --> 00:24:06.670
So I'm going to color
those internal vertices

00:24:06.670 --> 00:24:12.400
using this coloring scheme,
depending on the directions.

00:24:12.400 --> 00:24:15.880
And then for the extra layer
that I added on the outside,

00:24:15.880 --> 00:24:18.245
I will just use my
standard coloring.

00:24:20.780 --> 00:24:23.919
Now what's cool with the
way I chose my colors here--

00:24:23.919 --> 00:24:25.460
I mean, this is my
standard coloring,

00:24:25.460 --> 00:24:27.610
except I have permuted
the names of colors.

00:24:27.610 --> 00:24:29.400
Sorry about that.

00:24:29.400 --> 00:24:35.540
I think, you know, red took
the role of blue and stuff

00:24:35.540 --> 00:24:36.040
like that.

00:24:36.040 --> 00:24:39.160
But it doesn't really matter.

00:24:39.160 --> 00:24:40.670
What is cool about
the way I chose

00:24:40.670 --> 00:24:44.010
my colors is that
if a point is here,

00:24:44.010 --> 00:24:54.645
I know that is not going
to be using-- essentially,

00:24:54.645 --> 00:24:56.940
it can only be in the boundary
between red and yellow.

00:24:56.940 --> 00:25:02.290
But if you're here, and
the displacement is yellow,

00:25:02.290 --> 00:25:04.200
you're going to
be going outside.

00:25:04.200 --> 00:25:06.770
That's a bad thing.

00:25:06.770 --> 00:25:08.780
So the way I chose
my colors, I know

00:25:08.780 --> 00:25:14.320
that some property like
this is going to happen.

00:25:14.320 --> 00:25:15.865
Some of the edges
of this cube are

00:25:15.865 --> 00:25:17.490
going to be missing
some of the colors.

00:25:17.490 --> 00:25:20.410
For example, here, there is no
red, because if there were red,

00:25:20.410 --> 00:25:24.300
then I would have to be
going down outside my square.

00:25:24.300 --> 00:25:26.300
And my function is mapping
the square to itself.

00:25:26.300 --> 00:25:27.760
So that can't happen.

00:25:27.760 --> 00:25:34.750
Similarly, over here
I cannot have a yellow

00:25:34.750 --> 00:25:36.210
and so on and so forth.

00:25:36.210 --> 00:25:41.590
So that's going to be a valid
instance of Sperner's lemma.

00:25:41.590 --> 00:25:44.210
And by Sperner, there is
a tri-chromatic triangle

00:25:44.210 --> 00:25:44.945
in this scenario.

00:25:44.945 --> 00:25:47.080
Here it is.

00:25:47.080 --> 00:25:51.290
You could see the fixed
point at the back.

00:25:51.290 --> 00:25:53.290
That's a coincidence
actually because I'm going

00:25:53.290 --> 00:25:54.540
to do the compactness after.

00:25:54.540 --> 00:25:58.930
But I'm going to
do Sperner's lemma.

00:25:58.930 --> 00:26:00.610
Now a tri-chromatic
triangle is actually

00:26:00.610 --> 00:26:04.290
going to-- one of the corners of
the tri-chromatic triangle will

00:26:04.290 --> 00:26:07.710
have this property if you choose
the diameter of your triangles

00:26:07.710 --> 00:26:11.730
to be-- it's correctly chosen.

00:26:11.730 --> 00:26:15.590
So that's, roughly speaking,
how the proof works.

00:26:15.590 --> 00:26:16.390
Yeah?

00:26:16.390 --> 00:26:18.450
AUDIENCE: The fact that
Sperner's lemma shows

00:26:18.450 --> 00:26:21.110
that there's an odd
number of such triangles

00:26:21.110 --> 00:26:25.309
means there's an odd number
of [INAUDIBLE] not carry over?

00:26:25.309 --> 00:26:27.100
CONSTANTINOS DASKALAKIS:
This carries over,

00:26:27.100 --> 00:26:31.430
except in degenerate games
where it doesn't hold.

00:26:31.430 --> 00:26:36.950
But in a non-degenerate
case, it will hold,

00:26:36.950 --> 00:26:40.685
not by direct use of Sperner's.

00:26:40.685 --> 00:26:44.180
Because Sperner is always going
to go through approximations.

00:26:44.180 --> 00:26:46.430
So there is another way to
prove the existence of Nash

00:26:46.430 --> 00:26:49.410
equilibria in two player
games using what is called

00:26:49.410 --> 00:26:51.380
the Lemke-Howson algorithm.

00:26:51.380 --> 00:26:54.070
and this Lemke-Howson
algorithm has a similar flavor

00:26:54.070 --> 00:26:54.829
as Sperner.

00:26:54.829 --> 00:26:56.620
And it also has an odd
number of solutions.

00:26:56.620 --> 00:26:59.310
And this is still true.

00:26:59.310 --> 00:27:01.144
So for two player
games, it is still true

00:27:01.144 --> 00:27:02.810
that there is an odd
number of solutions

00:27:02.810 --> 00:27:04.710
if the game is non-degenerate.

00:27:04.710 --> 00:27:08.670
I'm not sure what's the
status of multiplayer games,

00:27:08.670 --> 00:27:12.330
because then there are
irrational solutions.

00:27:12.330 --> 00:27:17.570
So combinatorics give you
approximations but not

00:27:17.570 --> 00:27:20.260
exact fixed points.

00:27:20.260 --> 00:27:21.990
Yeah?

00:27:21.990 --> 00:27:22.490
So yeah.

00:27:22.490 --> 00:27:24.860
So the fact that there is
an odd number of solutions

00:27:24.860 --> 00:27:27.980
calls for this combinatorial
problem, Sperner.

00:27:27.980 --> 00:27:31.590
But after you do compactness,
then I don't know what happens.

00:27:31.590 --> 00:27:33.480
So all bets are off.

00:27:33.480 --> 00:27:36.440
But for the specific
case of two player games,

00:27:36.440 --> 00:27:40.880
there is an alternative
proof that carries over.

00:27:40.880 --> 00:27:41.520
OK?

00:27:41.520 --> 00:27:42.200
Cool.

00:27:42.200 --> 00:27:42.700
OK.

00:27:42.700 --> 00:27:46.320
So these are the three problems
that I'm interested in.

00:27:46.320 --> 00:27:48.420
And now it's the
time where I'm going

00:27:48.420 --> 00:27:53.120
to get into a bit of
complex theory discussion.

00:27:53.120 --> 00:27:55.070
And in fact, this
complex theory discussion

00:27:55.070 --> 00:27:59.720
will lead to the fact that NP,
the standard concept that we

00:27:59.720 --> 00:28:02.610
use for understanding
complexity,

00:28:02.610 --> 00:28:05.334
is not sufficient to
address these problems.

00:28:05.334 --> 00:28:06.500
And that will motivate PPAD.

00:28:11.810 --> 00:28:15.410
But first of all, let me give
intuition about why Sperner

00:28:15.410 --> 00:28:17.450
hard.

00:28:17.450 --> 00:28:21.790
And here's the situation
I want to be looking at.

00:28:21.790 --> 00:28:26.695
So I want to be looking at
the grid of size 2 to the n.

00:28:26.695 --> 00:28:28.570
So in particular, I'm
not going to be drawing

00:28:28.570 --> 00:28:30.540
the grid explicitly for you.

00:28:30.540 --> 00:28:32.560
And I'm not going to
be listing the colors

00:28:32.560 --> 00:28:37.310
of the internal
vertices as a list.

00:28:37.310 --> 00:28:40.270
So what I want to do
is I want to create

00:28:40.270 --> 00:28:46.000
a succinct description of a
coloring of an exponentially

00:28:46.000 --> 00:28:48.240
large instance in
the following way.

00:28:48.240 --> 00:28:51.490
So I'm going to be imagining
the existence of this grid

00:28:51.490 --> 00:28:54.699
with its boundary colored
in this specific way.

00:28:54.699 --> 00:28:56.240
And what I'm going
to give you is I'm

00:28:56.240 --> 00:28:59.760
going to give you a
circuit that takes

00:28:59.760 --> 00:29:06.520
as input the coordinates of
points inside this square

00:29:06.520 --> 00:29:07.450
and outputs a color.

00:29:11.620 --> 00:29:16.030
Now so this circuit
only decides the colors

00:29:16.030 --> 00:29:18.820
of the vertices inside.

00:29:18.820 --> 00:29:23.600
And I fix the colors
of those vertices

00:29:23.600 --> 00:29:27.590
to be what is shown
in the picture.

00:29:27.590 --> 00:29:32.090
Thus, that's a succinct
description of a coloring of 2

00:29:32.090 --> 00:29:33.085
to the 2n vertices.

00:29:35.650 --> 00:29:38.810
And this coloring satisfies the
conditions of Sperner's lemma.

00:29:41.660 --> 00:29:45.564
In particular, there is
a tri-chromatic triangle.

00:29:45.564 --> 00:29:47.230
And what the problem
is asking you to do

00:29:47.230 --> 00:29:48.790
is to find such a triangle.

00:29:52.570 --> 00:29:55.500
Describing this
triangle can be done

00:29:55.500 --> 00:29:58.640
with polynomials complexity
because all you need to do

00:29:58.640 --> 00:30:02.280
is to output the coordinates
of the three points

00:30:02.280 --> 00:30:03.550
participating in the triangle.

00:30:03.550 --> 00:30:05.634
So the output
description-- I'm not

00:30:05.634 --> 00:30:07.300
asking you to do
something crazy, right?

00:30:07.300 --> 00:30:14.430
So the output can be
described in polynomial size.

00:30:14.430 --> 00:30:19.460
The input-- and
what's problematic

00:30:19.460 --> 00:30:21.970
with this problem
is that the size

00:30:21.970 --> 00:30:23.970
of the graph we're
working with is

00:30:23.970 --> 00:30:27.090
exponential in the input size.

00:30:27.090 --> 00:30:30.810
So this circuit
has n input bits.

00:30:30.810 --> 00:30:34.380
So this graph is in
principle exponentially

00:30:34.380 --> 00:30:37.210
large in the description
of the problem.

00:30:37.210 --> 00:30:41.290
So in particular, I cannot just
go and check every triangle

00:30:41.290 --> 00:30:43.710
about whether it is
tri-chromatic or not.

00:30:43.710 --> 00:30:47.710
I have to do something
smarter to solve this problem.

00:30:47.710 --> 00:30:52.250
And in fact, we have no other--
essentially, no smart solutions

00:30:52.250 --> 00:30:54.821
to this problem.

00:30:54.821 --> 00:30:55.320
OK.

00:30:55.320 --> 00:30:56.980
So that Sperner's lemma.

00:30:56.980 --> 00:30:59.790
That's a way to define
the computational version

00:30:59.790 --> 00:31:01.920
of Sperner's lemma.

00:31:01.920 --> 00:31:04.380
Similarly, you can
define Nash and Brouwer.

00:31:04.380 --> 00:31:05.760
I'm only going to define Nash.

00:31:05.760 --> 00:31:07.990
Brouwer is a bit
more complicated.

00:31:07.990 --> 00:31:09.930
So in the Nash
problem, I'm giving

00:31:09.930 --> 00:31:12.590
a game which is described
by the number of players,

00:31:12.590 --> 00:31:16.530
the strategy sets,
which I enumerate,

00:31:16.530 --> 00:31:18.850
and the utility
functions of all players.

00:31:18.850 --> 00:31:20.560
This is the product
of all the sets.

00:31:23.264 --> 00:31:25.430
And I'm also giving you an
approximation requirement

00:31:25.430 --> 00:31:26.330
epsilon.

00:31:26.330 --> 00:31:29.060
And I'm going to comment
on that in a second.

00:31:29.060 --> 00:31:31.340
What I want you to do is
to find an epsilon Nash

00:31:31.340 --> 00:31:34.470
equilibrium of this game.

00:31:34.470 --> 00:31:37.490
Now what's an epsilon Nash
equilibrium of the game?

00:31:37.490 --> 00:31:40.810
An epsilon Nash equilibrium is
a collection of mixed strategies

00:31:40.810 --> 00:31:43.820
such that no player has more
than an epsilon incentive

00:31:43.820 --> 00:31:46.870
to change his strategy.

00:31:46.870 --> 00:31:57.336
So in this definition here, I
would add a minus epsilon here

00:31:57.336 --> 00:31:59.324
to make it an epsilon
Nash equilibrium.

00:32:03.310 --> 00:32:05.970
So I have not more than
an epsilon incentive

00:32:05.970 --> 00:32:07.420
to change my mixed strategy.

00:32:07.420 --> 00:32:09.630
That's what an epsilon
Nash equilibrium is.

00:32:09.630 --> 00:32:12.700
Now why did I have to define
the problem in this way?

00:32:12.700 --> 00:32:14.840
There's a specific
complex theoretic reason

00:32:14.840 --> 00:32:18.480
why I'm defining my problem
as an epsilon Nash instead

00:32:18.480 --> 00:32:21.967
of an exact Nash equilibrium.

00:32:21.967 --> 00:32:22.800
What is that reason?

00:32:26.700 --> 00:32:27.387
Yeah

00:32:27.387 --> 00:32:30.069
AUDIENCE: Maybe the exact Nash
equilibrium makes [INAUDIBLE].

00:32:32.619 --> 00:32:33.910
CONSTANTINOS DASKALAKIS: Right.

00:32:33.910 --> 00:32:36.590
So Nash's proof is via
Brouwer's theorem, which

00:32:36.590 --> 00:32:39.260
is a topological statement.

00:32:39.260 --> 00:32:43.220
And there's no guarantee
that the output-- if I

00:32:43.220 --> 00:32:45.930
were to omit this epsilon
from this definition,

00:32:45.930 --> 00:32:48.910
there's no guarantee that the
output has polynomial size

00:32:48.910 --> 00:32:50.050
complexity.

00:32:50.050 --> 00:32:52.930
Maybe a Nash equilibrium
is comprised of irrational

00:32:52.930 --> 00:32:57.810
numbers, which I cannot specify.

00:32:57.810 --> 00:32:59.060
Maybe it's not even algebraic.

00:32:59.060 --> 00:32:59.977
Who knows?

00:32:59.977 --> 00:33:00.810
But it is algebraic.

00:33:03.360 --> 00:33:05.350
So approximations
are in fact-- Nash,

00:33:05.350 --> 00:33:09.450
his paper in '51, not the
original one but the one that

00:33:09.450 --> 00:33:11.250
appeared a year later.

00:33:11.250 --> 00:33:14.660
He actually provides an
example of a three player game

00:33:14.660 --> 00:33:18.600
that only has
irrational equilibria.

00:33:18.600 --> 00:33:23.490
So I'm working with epsilons
to avoid this issue.

00:33:26.370 --> 00:33:31.010
Coming back to two
player games, you

00:33:31.010 --> 00:33:32.730
can actually show
that any two player

00:33:32.730 --> 00:33:38.350
game has a rational equilibrium
whose probabilities are

00:33:38.350 --> 00:33:42.010
of polynomial complexity in
the description of the game.

00:33:42.010 --> 00:33:44.270
So in this specific case
of two player games,

00:33:44.270 --> 00:33:45.970
you can actually
omit the epsilon

00:33:45.970 --> 00:33:48.790
if you want from the
description of this problem.

00:33:48.790 --> 00:33:50.500
But for general
games, you add a third

00:33:50.500 --> 00:33:54.000
to make this question
computationally meaningful.

00:33:54.000 --> 00:33:54.610
Yeah?

00:33:54.610 --> 00:33:56.443
AUDIENCE: Is it always
the case that there's

00:33:56.443 --> 00:34:00.720
an equilibrium that's a root
of the polynomial bounded

00:34:00.720 --> 00:34:02.750
complexity in the
description of the problem?

00:34:02.750 --> 00:34:05.000
CONSTANTINOS DASKALAKIS: I
believe this is true, yeah.

00:34:07.310 --> 00:34:08.810
AUDIENCE: Can you
do the same thing?

00:34:08.810 --> 00:34:10.518
CONSTANTINOS DASKALAKIS:
You could, yeah.

00:34:10.518 --> 00:34:12.527
You could in principle do that.

00:34:12.527 --> 00:34:13.860
I'm not going to define Brouwer.

00:34:13.860 --> 00:34:16.824
But you can imagine in
Brouwer similar things.

00:34:16.824 --> 00:34:18.449
You have to take care
of similar things

00:34:18.449 --> 00:34:23.159
and define epsilon approximate
fixed points, et cetera.

00:34:23.159 --> 00:34:25.429
Now let's look at NP.

00:34:25.429 --> 00:34:27.920
The variant of NP
that I'm interested in

00:34:27.920 --> 00:34:33.130
is that of search problems
in NP, so function NP.

00:34:33.130 --> 00:34:34.510
I don't want to
bore you, but I'm

00:34:34.510 --> 00:34:36.489
going to go through
the definitions.

00:34:36.489 --> 00:34:39.780
So a search problem is
defined by a relation

00:34:39.780 --> 00:34:43.810
of inputs and solutions
such that a pair x and y

00:34:43.810 --> 00:34:47.190
is in this language
defined by this problem

00:34:47.190 --> 00:34:49.949
if y is a solution to x.

00:34:49.949 --> 00:34:52.420
So I expect you
to know all this.

00:34:52.420 --> 00:34:55.600
And I'm going to go fast
through these definitions.

00:34:55.600 --> 00:34:59.090
But what's important
here is this definition.

00:34:59.090 --> 00:35:01.660
When do we say that
the problem is total?

00:35:01.660 --> 00:35:04.080
We say the problem is
total if for every input

00:35:04.080 --> 00:35:06.650
there is a y that is a
solution to the problem.

00:35:09.210 --> 00:35:12.200
For example, Sperner's
problem is total

00:35:12.200 --> 00:35:18.290
because for any instance
of Sperner's problem,

00:35:18.290 --> 00:35:19.590
there is actually a solution.

00:35:24.720 --> 00:35:30.250
For any input of this form,
you know by Sperner's lemma

00:35:30.250 --> 00:35:32.790
that there is a solution.

00:35:32.790 --> 00:35:35.690
So that problem is
a total problem.

00:35:35.690 --> 00:35:41.520
Similarly, for every input
to Nash, there is a solution.

00:35:41.520 --> 00:35:43.140
So these problems
are total problems.

00:35:46.665 --> 00:35:49.395
Let's see.

00:35:49.395 --> 00:35:50.760
OK.

00:35:50.760 --> 00:35:59.480
Now a search problem is
an FNP, function of NP,

00:35:59.480 --> 00:36:03.030
if there is a polynomial
time algorithm

00:36:03.030 --> 00:36:09.130
and a polynomial function
so that two conditions are

00:36:09.130 --> 00:36:11.640
satisfied.

00:36:11.640 --> 00:36:18.860
First, if the algorithm
on input x and y is 1,

00:36:18.860 --> 00:36:24.580
then and only then y
is a solution to x.

00:36:24.580 --> 00:36:28.430
And also for every
input to the problem,

00:36:28.430 --> 00:36:32.720
if there is a solution
to that instance,

00:36:32.720 --> 00:36:37.490
then there is one whose size
is polynomial in the input

00:36:37.490 --> 00:36:38.730
of the problem.

00:36:38.730 --> 00:36:42.950
So you have solutions that
are polynomially large.

00:36:46.550 --> 00:36:48.470
And so this is FNP.

00:36:48.470 --> 00:36:50.895
And TFNP is the
class of problems

00:36:50.895 --> 00:36:54.160
that contains all problems
in NP that are total.

00:36:54.160 --> 00:36:56.840
And based on the previous
discussion, all the problems

00:36:56.840 --> 00:37:02.310
we're interested in, Sperner,
Nash, and Brouwer, are TFNP.

00:37:02.310 --> 00:37:02.810
Sorry.

00:37:02.810 --> 00:37:03.309
TFNP.

00:37:03.309 --> 00:37:08.765
Both in FNP but also in TFNP.

00:37:08.765 --> 00:37:10.630
OK.

00:37:10.630 --> 00:37:15.010
And I guess let me remind
you about FNP completeness.

00:37:15.010 --> 00:37:18.780
A problem in FNP associated
with an algorithm

00:37:18.780 --> 00:37:22.396
and a polynomial function
is poly-time reducible

00:37:22.396 --> 00:37:25.650
to another one associated
with an algorithm

00:37:25.650 --> 00:37:27.130
and a different bound.

00:37:27.130 --> 00:37:30.980
If there exist two functions,
f and g, one of them

00:37:30.980 --> 00:37:36.760
is mapping inputs to l
to inputs to l prime.

00:37:36.760 --> 00:37:38.410
And also, you have
two properties.

00:37:38.410 --> 00:37:40.490
And it's important to
look at these properties

00:37:40.490 --> 00:37:44.720
carefully because they're
related to a point

00:37:44.720 --> 00:37:47.770
that I want to make.

00:37:47.770 --> 00:37:50.620
So for the reduction
to be valid,

00:37:50.620 --> 00:37:55.340
you also need this property,
that for every x and y,

00:37:55.340 --> 00:37:59.900
if the algorithm of problem l
prime on the transformed input

00:37:59.900 --> 00:38:04.390
and y says 1, then you
can take that solution

00:38:04.390 --> 00:38:08.140
and transform it into a
solution to the instance to l.

00:38:08.140 --> 00:38:11.270
This is what it says.

00:38:11.270 --> 00:38:15.500
Well, this one says that if
the transform instance has

00:38:15.500 --> 00:38:19.380
no solution, then the
original instance also

00:38:19.380 --> 00:38:22.940
shouldn't have any solution.

00:38:22.940 --> 00:38:26.190
And a search problem is FNP
complete if it's both in FNP,

00:38:26.190 --> 00:38:32.510
and every problem in FNP is
polynomial time reducible

00:38:32.510 --> 00:38:33.470
to it.

00:38:33.470 --> 00:38:36.250
And of course, finding
a satisfying assignment

00:38:36.250 --> 00:38:38.230
is FNP complete.

00:38:38.230 --> 00:38:41.300
But now we reached the
point that I want to make.

00:38:41.300 --> 00:38:46.530
What I want to claim is that
I cannot possibly reduce SAT

00:38:46.530 --> 00:38:49.480
to any of the problems
that I'm interested in.

00:38:49.480 --> 00:38:54.940
In particular, I cannot show
that there's no Karp reduction

00:38:54.940 --> 00:38:58.490
from SAT to any
of these problems.

00:38:58.490 --> 00:39:01.370
And the reason is this property.

00:39:01.370 --> 00:39:05.920
Recall, this property was saying
that for every input to problem

00:39:05.920 --> 00:39:16.000
l, if the y' is a solution
to the transformed instance,

00:39:16.000 --> 00:39:19.120
then I can convert that
solution to a solution

00:39:19.120 --> 00:39:21.900
to the original instance.

00:39:21.900 --> 00:39:27.090
But now if l is SAT, and
this is Sperner, then

00:39:27.090 --> 00:39:31.660
no matter how you transform
the SAT instance to a Sperner

00:39:31.660 --> 00:39:36.680
instance, there is going to be a
triangle that is tri-chromatic,

00:39:36.680 --> 00:39:39.110
setting this to 1.

00:39:39.110 --> 00:39:43.360
So I should be able to
then convert this triangle

00:39:43.360 --> 00:39:44.840
to a satisfying assignment.

00:39:44.840 --> 00:39:48.210
But what if those instances
are unsatisfiable?

00:39:48.210 --> 00:39:53.750
That possibly cannot hold
if your two problems are SAT

00:39:53.750 --> 00:39:54.770
and Sperner.

00:39:54.770 --> 00:39:56.470
So there's no reduction.

00:39:56.470 --> 00:40:00.190
There's no Karp reduction
from SAT to Sperner.

00:40:00.190 --> 00:40:04.280
So you can't show any of these
problems for that matter.

00:40:04.280 --> 00:40:07.050
So you cannot possibly argue
that these problems are FNP

00:40:07.050 --> 00:40:09.860
complete.

00:40:09.860 --> 00:40:14.670
Another thing you may try is to
get Turing reductions from SAT

00:40:14.670 --> 00:40:16.570
to these problems.

00:40:16.570 --> 00:40:18.130
But that has other issues.

00:40:18.130 --> 00:40:23.690
It basically would imply
that NP equals co-NP.

00:40:23.690 --> 00:40:28.330
So there's no way basically.

00:40:28.330 --> 00:40:31.440
These types of problems
don't-- if you want type check,

00:40:31.440 --> 00:40:32.380
they don't type check.

00:40:32.380 --> 00:40:34.300
These are problems
that are total,

00:40:34.300 --> 00:40:39.830
and these are problems who's
complexity really resides

00:40:39.830 --> 00:40:41.830
with the fact that it's
hard to distinguish

00:40:41.830 --> 00:40:47.390
satisfiable and
non-satisfiable instances.

00:40:47.390 --> 00:40:50.850
So LP completeness is not the
right language, if you want.

00:40:50.850 --> 00:40:54.240
It's not the right framework
to understand the complexity

00:40:54.240 --> 00:40:55.447
of these problems.

00:40:55.447 --> 00:40:57.530
And the exercise through
which we're going today--

00:40:57.530 --> 00:40:59.960
and I think it's
instructive-- is

00:40:59.960 --> 00:41:02.900
how to go about
characterizing problems

00:41:02.900 --> 00:41:07.990
that don't fit into traditional
complexity theoretic

00:41:07.990 --> 00:41:09.769
frameworks.

00:41:09.769 --> 00:41:11.560
So in particular, what
I want to understand

00:41:11.560 --> 00:41:14.810
is how to go about
defining a complexity

00:41:14.810 --> 00:41:20.060
theory of total search
problems inside FNP.

00:41:20.060 --> 00:41:22.250
Clearly, these problems
actually are inside FNP.

00:41:22.250 --> 00:41:24.070
These are FNP problems.

00:41:24.070 --> 00:41:25.670
They're TFNP problems.

00:41:25.670 --> 00:41:33.030
So how do you go about coming
up with a complexity theory

00:41:33.030 --> 00:41:36.430
of total search problems?

00:41:36.430 --> 00:41:41.040
And the way you go
about it is to look

00:41:41.040 --> 00:41:47.980
at the proof of existence of
solutions in these problems

00:41:47.980 --> 00:41:55.510
and understand the combinatorial
underpinnings of the existence

00:41:55.510 --> 00:41:57.240
argument.

00:41:57.240 --> 00:42:01.860
So if you want the 100 feet
overview of the methodology

00:42:01.860 --> 00:42:04.290
that I'm going to
follow, it's this.

00:42:04.290 --> 00:42:08.350
First, I want to identify
the combinatorial argument

00:42:08.350 --> 00:42:11.970
of existence responsible for
making all these problems

00:42:11.970 --> 00:42:14.880
total problems.

00:42:14.880 --> 00:42:18.270
And then I want to define
a complexity class inspired

00:42:18.270 --> 00:42:21.470
by this argument of existence.

00:42:21.470 --> 00:42:25.320
And the litmus
test of my approach

00:42:25.320 --> 00:42:30.390
is if the resulting
complexity class actually

00:42:30.390 --> 00:42:33.771
tidily characterizes the
complexity of these problems.

00:42:33.771 --> 00:42:35.270
So what I'm going
to do is I'm going

00:42:35.270 --> 00:42:37.840
to show you the proof
for Sperner's lemma,

00:42:37.840 --> 00:42:42.020
and that's going to inspire
the definition of PPAD.

00:42:42.020 --> 00:42:45.570
So this is what I'm going to
do in the next few slides.

00:42:45.570 --> 00:42:47.280
So here's the
statement of the lemma.

00:42:47.280 --> 00:42:49.390
If your boundary
is legally colored,

00:42:49.390 --> 00:42:51.150
then there is
always an odd number

00:42:51.150 --> 00:42:56.300
of tri-chromatic triangles,
in particular at least one.

00:42:56.300 --> 00:42:57.600
Let me try to prove it for you.

00:43:00.610 --> 00:43:02.850
The first thing I'm
going to do says

00:43:02.850 --> 00:43:05.940
I'm going to introduce
an artificial vertex

00:43:05.940 --> 00:43:10.200
at the bottom left
of the square.

00:43:10.200 --> 00:43:11.020
Here it is.

00:43:11.020 --> 00:43:14.400
And I'm going to color it blue.

00:43:14.400 --> 00:43:18.030
Now no matter how you
color the internal vertices

00:43:18.030 --> 00:43:21.740
of this square,
because I have fixed

00:43:21.740 --> 00:43:24.460
by coloring on the boundary
to be the one you see here

00:43:24.460 --> 00:43:30.020
in this picture, I know that by
adding a blue vertex over here,

00:43:30.020 --> 00:43:34.640
I'm creating an artificial
tri-chromatic triangle.

00:43:34.640 --> 00:43:39.170
I'm going to call the triangle
the beginning of my walk.

00:43:39.170 --> 00:43:45.490
And now I'm going to basically
define a walk in this grid.

00:43:45.490 --> 00:43:47.570
Consider this is a big factory.

00:43:47.570 --> 00:43:52.470
The factory is partitioned
into triangular rooms.

00:43:52.470 --> 00:43:55.760
And I'm starting my walk in
this factory from this vertex

00:43:55.760 --> 00:43:59.660
here, from this triangle here.

00:43:59.660 --> 00:44:02.500
Now my walk is going to be
doing the following thing.

00:44:02.500 --> 00:44:04.970
It's going to be going from
triangle to neighbouring .

00:44:04.970 --> 00:44:09.500
Triangle and the transition
rule is the following.

00:44:09.500 --> 00:44:12.545
I'm going to look
in the room I'm in,

00:44:12.545 --> 00:44:17.720
and I'm going to try to
find a red-yellow door.

00:44:17.720 --> 00:44:22.710
If I find such a door, I want
to try to cross it having red

00:44:22.710 --> 00:44:24.260
on my left hand.

00:44:24.260 --> 00:44:27.290
That's the rule of my walk.

00:44:27.290 --> 00:44:29.120
Red-yellow doors.

00:44:29.120 --> 00:44:32.230
I want to cross them
with red on my left.

00:44:32.230 --> 00:44:34.140
That's important.

00:44:34.140 --> 00:44:35.830
I meant to say
yellow on your left.

00:44:35.830 --> 00:44:37.120
Sorry about that.

00:44:37.120 --> 00:44:38.870
So let's go back
to this picture.

00:44:38.870 --> 00:44:42.030
I created these artificial
triangle over here.

00:44:42.030 --> 00:44:43.660
I knew it's going
to be tri-chromatic

00:44:43.660 --> 00:44:47.030
because it only considers
vertices on the boundary.

00:44:47.030 --> 00:44:48.920
And I have fixed the
coloring of the boundary

00:44:48.920 --> 00:44:50.899
to be this specific one.

00:44:50.899 --> 00:44:53.190
I know it's going to have a
red-yellow door which I can

00:44:53.190 --> 00:44:56.470
cross having yellow on my left.

00:44:56.470 --> 00:44:59.720
So let me cross that door.

00:44:59.720 --> 00:45:03.340
Now I'm entering
into a new room.

00:45:03.340 --> 00:45:05.060
In this particular
case, there's nothing

00:45:05.060 --> 00:45:07.920
interesting about this
room because this still

00:45:07.920 --> 00:45:09.450
touches the boundary.

00:45:09.450 --> 00:45:11.840
So no matter how you color
the internal vertices,

00:45:11.840 --> 00:45:14.300
you couldn't affect the
coloring of this boundary.

00:45:14.300 --> 00:45:17.530
So it's also going to have a
red-yellow door, which I can

00:45:17.530 --> 00:45:18.920
cross having yellow on my left.

00:45:18.920 --> 00:45:21.820
And the interesting
business starts now.

00:45:21.820 --> 00:45:25.520
I entered into a new room, and
depending on your coloring,

00:45:25.520 --> 00:45:27.710
maybe it's already
tri-chromatic.

00:45:27.710 --> 00:45:30.530
So how do you color
this into blue?

00:45:30.530 --> 00:45:32.530
This would already be a
tri-chromatic triangle.

00:45:32.530 --> 00:45:33.030
why?

00:45:33.030 --> 00:45:35.830
Because you entered that room
through a red-yellow door,

00:45:35.830 --> 00:45:40.390
and you encountered
a blue color.

00:45:40.390 --> 00:45:43.800
What is cool about it though
is that if it's not blue,

00:45:43.800 --> 00:45:46.020
then there's going
to be for sure

00:45:46.020 --> 00:45:49.900
another door which you can cross
having yellow on your left.

00:45:49.900 --> 00:45:52.120
In this particular
scenario, this was a yellow.

00:45:52.120 --> 00:45:52.900
It wasn't a blue.

00:45:52.900 --> 00:45:55.530
So this was not a
tri-chromatic triangle.

00:45:55.530 --> 00:45:58.872
But because this was a
yellow, I enter a room

00:45:58.872 --> 00:46:00.830
through a red-yellow
door, and I find a yellow.

00:46:00.830 --> 00:46:02.840
There is for sure
another red-yellow

00:46:02.840 --> 00:46:06.780
door I can cross having
yellow on my left.

00:46:06.780 --> 00:46:08.410
So this is what I'm going to do.

00:46:08.410 --> 00:46:13.765
And I'm going to keep
doing this until-- what

00:46:13.765 --> 00:46:15.010
can go wrong, right?

00:46:15.010 --> 00:46:18.930
So the claim that I want to make
is that if I keep doing this

00:46:18.930 --> 00:46:23.860
procedure, I cannot
exit the factory.

00:46:23.860 --> 00:46:25.626
For me to exit
the factory, there

00:46:25.626 --> 00:46:29.550
has to be a door on the
boundary which I can

00:46:29.550 --> 00:46:32.580
cross having yellow on my left.

00:46:32.580 --> 00:46:35.720
Now because-- and that's where
the coloring of the boundary

00:46:35.720 --> 00:46:37.150
becomes important.

00:46:37.150 --> 00:46:39.200
Because I have fixed the
color of the boundary

00:46:39.200 --> 00:46:41.280
to be the one you
see in this picture,

00:46:41.280 --> 00:46:43.610
you can verify that there
is no red-yellow door

00:46:43.610 --> 00:46:45.100
you can cross to go outside.

00:46:47.610 --> 00:46:50.700
The only red-yellow door
that exists is this one.

00:46:50.700 --> 00:46:53.370
But if you're inside, you cannot
cross it going to the outside

00:46:53.370 --> 00:46:54.790
having yellow on your left.

00:46:54.790 --> 00:46:57.020
And that's where having
left on your left hand side

00:46:57.020 --> 00:46:59.020
is important.

00:46:59.020 --> 00:47:00.860
This is the only
red-yellow door.

00:47:00.860 --> 00:47:02.950
But you cannot cross
it going outside.

00:47:02.950 --> 00:47:05.100
You can only cross
it going inside.

00:47:05.100 --> 00:47:08.410
So you cannot exit the factory.

00:47:08.410 --> 00:47:10.510
So your walk is
going to keep going.

00:47:13.440 --> 00:47:15.760
And there are two
possibilities now.

00:47:15.760 --> 00:47:18.680
So one is that it's
going to keep going.

00:47:18.680 --> 00:47:21.275
And then it's going to
enter into a new room

00:47:21.275 --> 00:47:23.650
through a red-yellow door,
and it's going to find a blue.

00:47:23.650 --> 00:47:26.090
In that case, my
lemma is proven,

00:47:26.090 --> 00:47:28.959
not the odd number, but at
least I've proven to you

00:47:28.959 --> 00:47:31.500
there is at least one triangle
because I entered into a room.

00:47:31.500 --> 00:47:33.030
I found a blue.

00:47:33.030 --> 00:47:34.790
I entered through
a red-yellow door.

00:47:34.790 --> 00:47:36.740
That's a proof of existence.

00:47:36.740 --> 00:47:38.990
But there is one thing
that can go wrong, though.

00:47:38.990 --> 00:47:40.130
What is that?

00:47:40.130 --> 00:47:41.490
I can loop around.

00:47:41.490 --> 00:47:45.900
So what I can do is I can--
so this is my factory.

00:47:45.900 --> 00:47:47.130
I started over here.

00:47:47.130 --> 00:47:51.450
I start wandering
around this factory.

00:47:51.450 --> 00:47:53.935
And then I sort
of got into a room

00:47:53.935 --> 00:47:55.460
that I had already
visited before.

00:47:55.460 --> 00:47:59.880
And then I get into a
loop, and I go forever.

00:47:59.880 --> 00:48:03.550
That's the problem
that may happen.

00:48:03.550 --> 00:48:05.720
I claimed over there
that this cannot happen.

00:48:05.720 --> 00:48:07.862
Why can it not happen?

00:48:07.862 --> 00:48:09.155
AUDIENCE: Coloring.

00:48:09.155 --> 00:48:11.363
CONSTANTINOS DASKALAKIS:
Yeah, let's try to color it.

00:48:11.363 --> 00:48:13.140
Let's zoom into here.

00:48:13.140 --> 00:48:17.980
So this is a room that I
got into at the beginning

00:48:17.980 --> 00:48:20.430
through a red-yellow door
having yellow on my left.

00:48:20.430 --> 00:48:22.850
So originally, I
got into this room

00:48:22.850 --> 00:48:26.540
like this having
yellow on my left.

00:48:26.540 --> 00:48:31.440
Then I exited this room
through a red-yellow door

00:48:31.440 --> 00:48:32.530
having yellow my left.

00:48:32.530 --> 00:48:39.540
So this door, potentially
it was a red here.

00:48:39.540 --> 00:48:40.850
So I exited this way.

00:48:40.850 --> 00:48:43.850
But then I cannot possibly
enter through this door,

00:48:43.850 --> 00:48:45.700
because that's a red-red door.

00:48:45.700 --> 00:48:49.610
Or this could be a yellow, in
which case, I exited from here.

00:48:49.610 --> 00:48:51.720
But still now I cannot
get back from that door,

00:48:51.720 --> 00:48:53.560
because that's a
yellow-yellow door.

00:48:53.560 --> 00:48:56.060
So this cannot happen.

00:48:56.060 --> 00:49:03.410
So my walk cannot get back
into an already visited room,

00:49:03.410 --> 00:49:05.570
and it cannot exit the factory.

00:49:05.570 --> 00:49:07.930
So the only thing it
can do is just stop

00:49:07.930 --> 00:49:11.140
because there's a finite number
of rooms in this factory.

00:49:11.140 --> 00:49:15.530
But the only way it can stop
is if it finds a blue when

00:49:15.530 --> 00:49:17.180
it enters a new room.

00:49:17.180 --> 00:49:19.349
So that's the
proof of existence.

00:49:19.349 --> 00:49:20.890
If you follow my
walk, indeed, you're

00:49:20.890 --> 00:49:24.890
going to get into a
tri-chromatic triangle.

00:49:24.890 --> 00:49:28.890
And this way, I finished
the first part of the claim.

00:49:28.890 --> 00:49:32.370
Any questions about that?

00:49:32.370 --> 00:49:33.340
Yeah.

00:49:33.340 --> 00:49:35.300
AUDIENCE: The same argument
give you the odd number though?

00:49:35.300 --> 00:49:36.924
CONSTANTINOS DASKALAKIS:
It does, yeah.

00:49:36.924 --> 00:49:37.524
What is it?

00:49:37.524 --> 00:49:38.940
AUDIENCE: If you
find another one,

00:49:38.940 --> 00:49:40.709
then it has to [INAUDIBLE].

00:49:40.709 --> 00:49:42.000
CONSTANTINOS DASKALAKIS: Right.

00:49:42.000 --> 00:49:43.030
Let's try to do that.

00:49:43.030 --> 00:49:45.310
So let's start from
a different triangle.

00:49:45.310 --> 00:49:46.795
Let's start from here.

00:49:46.795 --> 00:49:48.170
But if I start
from here, there's

00:49:48.170 --> 00:49:50.280
no red-yellow door I can follow.

00:49:50.280 --> 00:49:51.791
So that doesn't
give me anything.

00:49:51.791 --> 00:49:53.290
But let's start
with somewhere where

00:49:53.290 --> 00:49:54.415
there are red-yellow doors.

00:49:54.415 --> 00:49:57.270
So let's start with here.

00:49:57.270 --> 00:49:59.630
Now I can follow the
same kind of business.

00:49:59.630 --> 00:50:04.310
I can get into doors.

00:50:04.310 --> 00:50:06.560
I can cross red-yellow doors
having yellow on my left.

00:50:06.560 --> 00:50:10.500
In this case, that got me
into a tri-chromatic triangle.

00:50:10.500 --> 00:50:14.150
Now let me go back here and
actually do the word backwards,

00:50:14.150 --> 00:50:17.390
so have it going backwards,
having yellow on my left.

00:50:17.390 --> 00:50:18.620
So this is what happens.

00:50:18.620 --> 00:50:21.520
So I found a
tri-chromatic triangle.

00:50:21.520 --> 00:50:23.230
And these actually
came in pairs.

00:50:23.230 --> 00:50:26.880
The fact that this gave me a
tri-chromatic triangle must

00:50:26.880 --> 00:50:30.860
mean that this has to give you
another one because by the same

00:50:30.860 --> 00:50:35.880
token, I cannot sort of get
into a loop while going back.

00:50:35.880 --> 00:50:37.740
On the other hand,
there are some triangles

00:50:37.740 --> 00:50:41.756
where that would give you-- so
you get another pair over here.

00:50:41.756 --> 00:50:44.130
These don't give you anything,
because if you start here,

00:50:44.130 --> 00:50:46.510
you don't move.

00:50:46.510 --> 00:50:50.170
But here you can get loops.

00:50:50.170 --> 00:50:52.740
If you start from the inside,
you can get into a loop.

00:50:52.740 --> 00:50:59.310
The point is that all
triangles come in pairs,

00:50:59.310 --> 00:51:02.480
except for this walk, which
started with an artificial one.

00:51:05.200 --> 00:51:09.190
So all tri-chromatic
triangles come in pairs,

00:51:09.190 --> 00:51:12.520
except for the tri-chromatic
triangle that I

00:51:12.520 --> 00:51:16.107
found in my original walk.

00:51:16.107 --> 00:51:17.815
Thereby, there is an
odd number of those.

00:51:21.700 --> 00:51:25.770
So it's kind of-- its
pretty cool, right?

00:51:25.770 --> 00:51:29.750
Let me actually try to abstract
this proof a little bit

00:51:29.750 --> 00:51:35.640
and sort of focus more onto the
core argument why this happens.

00:51:35.640 --> 00:51:36.870
So here's what I did, really.

00:51:36.870 --> 00:51:40.230
So this is my
space of triangles.

00:51:40.230 --> 00:51:43.050
This is my set of triangles.

00:51:43.050 --> 00:51:48.440
I want to define a graph where
the vertices are the triangles.

00:51:48.440 --> 00:51:54.950
And the adjacency of
triangles-- so two triangles

00:51:54.950 --> 00:51:58.320
are connected if
they share a door,

00:51:58.320 --> 00:52:03.490
and you can go from one
triangle into the other one

00:52:03.490 --> 00:52:07.170
through this door having
yellow on your left.

00:52:07.170 --> 00:52:12.895
So for this reason, all vertices
have out degree and in degree

00:52:12.895 --> 00:52:17.850
at most 1 because every
triangle-- no matter how it's

00:52:17.850 --> 00:52:20.080
colored-- has at most
one red-yellow door

00:52:20.080 --> 00:52:23.950
which you can cross having
yellow on your left to go out.

00:52:23.950 --> 00:52:25.630
And it has at most
one door which

00:52:25.630 --> 00:52:31.340
you can cross having yellow
on your left going in.

00:52:31.340 --> 00:52:35.470
So just the minute definition
of my transition rule,

00:52:35.470 --> 00:52:38.250
which was cross a red-yellow
door having yellow

00:52:38.250 --> 00:52:41.440
on your left, defined
a graph on the set

00:52:41.440 --> 00:52:48.200
of triangles that has in degree
and out degree at most 1.

00:52:48.200 --> 00:52:51.920
Now a graph with in degree
and out degree at most 1

00:52:51.920 --> 00:52:53.840
is a very simple type of graph.

00:52:53.840 --> 00:52:55.750
It looks like this.

00:52:55.750 --> 00:52:57.710
It's a bunch of
isolated vertices,

00:52:57.710 --> 00:53:00.930
a bunch of directed cycles,
and a bunch of directed paths.

00:53:03.690 --> 00:53:10.340
And in fact, the way I
define my position rule,

00:53:10.340 --> 00:53:16.070
you could check that all degree
1 nodes must be tri-chromatic.

00:53:16.070 --> 00:53:19.260
If you're tri-chromatic,
there is either

00:53:19.260 --> 00:53:22.340
one door you can exit,
one red-yellow door

00:53:22.340 --> 00:53:24.500
you can exit having
yellow on your left.

00:53:24.500 --> 00:53:27.170
Or depending on how the
coloring is, one door

00:53:27.170 --> 00:53:30.360
you can use to enter
the triangle having

00:53:30.360 --> 00:53:31.920
yellow on your left.

00:53:31.920 --> 00:53:38.890
So only tri-chromatic triangles
can have total degree 1.

00:53:43.360 --> 00:53:47.420
Isolated vertices are those who
don't have red-yellow doors.

00:53:47.420 --> 00:53:53.890
And degree 2 are those who
have two doors, one with which

00:53:53.890 --> 00:53:56.374
you can exit having yellow
on your left and one

00:53:56.374 --> 00:53:58.540
with which you can enter
having yellow on your left.

00:53:58.540 --> 00:54:03.050
So what I want to summarize
is that the mere definition

00:54:03.050 --> 00:54:06.980
of my transition rule
defines this graph in a way

00:54:06.980 --> 00:54:12.360
that all these unbalanced
vertices are solutions

00:54:12.360 --> 00:54:14.280
to the Sperner problem.

00:54:14.280 --> 00:54:18.670
All the vertices were solutions
to the Sperner problem.

00:54:18.670 --> 00:54:20.800
And in fact, one
solution was artificial

00:54:20.800 --> 00:54:23.580
because it was that triangle
that I created by adding

00:54:23.580 --> 00:54:25.790
the extra node outside.

00:54:25.790 --> 00:54:29.600
So all degree 1 vertices
are real solutions,

00:54:29.600 --> 00:54:32.278
except one of them.

00:54:32.278 --> 00:54:33.652
And by the structure
of the graph

00:54:33.652 --> 00:54:38.050
then, there has to be an
odd number of solutions.

00:54:38.050 --> 00:54:39.660
This is implied.

00:54:39.660 --> 00:54:42.130
So to summarize,
the mere description

00:54:42.130 --> 00:54:44.760
of my transition rule
defines this graph in a way

00:54:44.760 --> 00:54:48.840
that all unbalanced
vertices are solutions.

00:54:48.840 --> 00:54:53.070
And because these have to
come in pairs by parity,

00:54:53.070 --> 00:54:55.210
there is an even
number of solutions.

00:54:55.210 --> 00:54:56.419
Except one was artificial.

00:54:56.419 --> 00:54:58.335
So hence, there is an
odd number of solutions.

00:55:01.130 --> 00:55:03.840
So in particular,
what I want to argue

00:55:03.840 --> 00:55:06.500
is that all these very
beautiful, very interesting

00:55:06.500 --> 00:55:08.920
theorems that I showed
in the beginning,

00:55:08.920 --> 00:55:14.760
Nash, Brouwer, and Sperner--
the real argument of existence,

00:55:14.760 --> 00:55:18.280
besides sort of
mathematical work,

00:55:18.280 --> 00:55:21.450
mathematical
obfuscation, if you want,

00:55:21.450 --> 00:55:25.480
is this trivial statement
in combinatorics.

00:55:25.480 --> 00:55:30.470
If you have a directed graph
with some unbalanced vertex,

00:55:30.470 --> 00:55:33.090
then there must be
another unbalanced vertex.

00:55:36.750 --> 00:55:38.690
You obviously know this theorem.

00:55:38.690 --> 00:55:40.810
The proof of this
theorem is pretty clear.

00:55:40.810 --> 00:55:43.270
If you have a directed
graph where some node has

00:55:43.270 --> 00:55:48.040
a different number of
outgoing and ingoing edges,

00:55:48.040 --> 00:55:50.780
then there has to be
another such node.

00:55:50.780 --> 00:55:53.400
And effectively,
what I did over here

00:55:53.400 --> 00:55:56.880
is I described a
directed graph, and I

00:55:56.880 --> 00:56:01.180
identified this artificial
vertex, which was unbalanced.

00:56:01.180 --> 00:56:04.860
It only had an ongoing
edge but no incoming edge.

00:56:04.860 --> 00:56:08.990
And by parity, I knew there
must exist another one.

00:56:08.990 --> 00:56:13.040
So in fact, I didn't even
have to use my walk argument

00:56:13.040 --> 00:56:13.680
and stuff.

00:56:13.680 --> 00:56:16.950
All I had to claim is
that the mere definition

00:56:16.950 --> 00:56:19.860
of my transition rule
defined this directed graph.

00:56:19.860 --> 00:56:22.984
And this directed graph
had some unbalanced vertex.

00:56:22.984 --> 00:56:24.650
And I know that
somewhere in this graph,

00:56:24.650 --> 00:56:27.430
there has to be another
unbalanced vertex.

00:56:27.430 --> 00:56:29.284
But all I'm saying is
that the core of it

00:56:29.284 --> 00:56:30.200
is this trivial lemma.

00:56:35.460 --> 00:56:38.180
And now your question will
be, well, what the heck?

00:56:38.180 --> 00:56:39.560
This lemma is trivial.

00:56:39.560 --> 00:56:43.050
So we took so many
algorithms, Karger's class

00:56:43.050 --> 00:56:44.260
and so on and so forth.

00:56:44.260 --> 00:56:45.460
We've worked with graphs.

00:56:45.460 --> 00:56:48.700
We know how to identify
these things, right?

00:56:48.700 --> 00:56:50.780
Given a directed graph,
it's trivial to find

00:56:50.780 --> 00:56:51.800
an unbalanced vertex.

00:56:54.890 --> 00:56:58.000
But the point is that
you can sometimes

00:56:58.000 --> 00:57:03.010
define exponentially
large graphs succinctly.

00:57:03.010 --> 00:57:06.650
And you can ask people to
find your unbalanced vertices

00:57:06.650 --> 00:57:11.200
in exponentially large graphs.

00:57:11.200 --> 00:57:14.890
So that's what PPAD is about.

00:57:14.890 --> 00:57:18.590
In fact, if I give
you a Sperner instance

00:57:18.590 --> 00:57:21.720
by providing you a
circuit, we'd only

00:57:21.720 --> 00:57:25.270
be working with
exponentially many triangles

00:57:25.270 --> 00:57:27.770
in the description
of the circuit.

00:57:27.770 --> 00:57:30.520
So that's why the
problem is difficult.

00:57:30.520 --> 00:57:33.980
The problem is difficult because
the guy we're working with

00:57:33.980 --> 00:57:36.890
is exponentially large in the
description of the problem,

00:57:36.890 --> 00:57:39.180
of the instance.

00:57:39.180 --> 00:57:44.570
So the PPAD class is trying
to capture this structure.

00:57:44.570 --> 00:57:48.130
And we're right about
the point where I'm going

00:57:48.130 --> 00:57:51.860
to define the class formally.

00:57:51.860 --> 00:57:54.800
So you ready for this?

00:57:54.800 --> 00:57:56.280
Oops.

00:57:56.280 --> 00:57:56.780
OK.

00:57:56.780 --> 00:57:59.420
The PPAD class, defined
by Papadimitriou

00:57:59.420 --> 00:58:02.990
in the '90s-- actually,
this is the general version

00:58:02.990 --> 00:58:03.550
of the paper.

00:58:07.430 --> 00:58:12.910
The PPAD class is giving you
an exponentially large graph.

00:58:12.910 --> 00:58:17.830
The vertex set of the
graph is 0, 1 to the n.

00:58:17.830 --> 00:58:20.790
The graph is specified
in a weird way.

00:58:20.790 --> 00:58:26.240
I'm going to give
you two circuits that

00:58:26.240 --> 00:58:31.950
get an n input bit, and n bit
input and have an n bit output.

00:58:34.790 --> 00:58:38.070
And using these two
circuits, I define

00:58:38.070 --> 00:58:41.730
an edge between a string
and another string

00:58:41.730 --> 00:58:45.630
if a weird condition
is satisfied.

00:58:45.630 --> 00:58:48.220
So now we directed
that from v1 to v2

00:58:48.220 --> 00:58:51.160
if this condition is satisfied.

00:58:51.160 --> 00:58:56.290
Let me try to parse
these symbols there.

00:58:56.290 --> 00:58:58.190
But before that, let
me call this circuit

00:58:58.190 --> 00:59:00.700
the possible previous circuit.

00:59:00.700 --> 00:59:05.030
And let me call this circuit
the possible next circuit.

00:59:05.030 --> 00:59:08.910
Now this circuit
takes as input string,

00:59:08.910 --> 00:59:16.430
and it outputs a candidate
neighbor of that string.

00:59:16.430 --> 00:59:22.520
And similarly, this-- sorry, a
candidate father of the string.

00:59:22.520 --> 00:59:24.470
And takes as input
a string and outputs

00:59:24.470 --> 00:59:26.560
a possible child of the string.

00:59:26.560 --> 00:59:30.510
And I only established an edge,
a directed edge from string v1

00:59:30.510 --> 00:59:36.620
to string v2 if string v2
believes that its father is v1,

00:59:36.620 --> 00:59:42.140
and v1 believes that
its child is v2.

00:59:42.140 --> 00:59:46.260
If they agree on their sort
of parenthood relationship,

00:59:46.260 --> 00:59:49.220
I add this edge.

00:59:49.220 --> 00:59:51.210
OK?

00:59:51.210 --> 00:59:55.060
Now you may ask
me, what the heck?

00:59:55.060 --> 00:59:57.970
Why didn't you just define
this graph in a different way?

00:59:57.970 --> 00:59:59.950
Why did you have to
have this possible child

00:59:59.950 --> 01:00:03.200
and possible father
relationship and describe

01:00:03.200 --> 01:00:04.900
the graph in this way?

01:00:04.900 --> 01:00:06.390
And the answer to
this question is

01:00:06.390 --> 01:00:11.840
that no matter-- so the
answer to this question

01:00:11.840 --> 01:00:14.910
is, no matter what
circuit you give me,

01:00:14.910 --> 01:00:18.490
that always defines your graph
with a very specific property

01:00:18.490 --> 01:00:20.320
that we're going to
see in the next slide.

01:00:25.530 --> 01:00:26.770
Back to the definition.

01:00:26.770 --> 01:00:28.853
So I'm going to explain
the intuition behind this.

01:00:28.853 --> 01:00:30.980
But back to the
definition, describe

01:00:30.980 --> 01:00:35.170
an exponentially large graph
by giving these two circuits.

01:00:35.170 --> 01:00:37.090
And I establish the
edges between nodes

01:00:37.090 --> 01:00:39.840
only if this condition is true.

01:00:39.840 --> 01:00:42.220
And what I'll ask you
to do is the following.

01:00:42.220 --> 01:00:48.170
Given these two circuits, if
the all 0 string is unbalanced

01:00:48.170 --> 01:00:52.116
and gives an exponentially
large graph that I defined,

01:00:52.116 --> 01:00:55.430
then I'll ask you to find
another unbalanced node, which

01:00:55.430 --> 01:00:59.900
by parity exists.

01:00:59.900 --> 01:01:05.470
If the 0 string is unbalanced in
this exponentially large graph,

01:01:05.470 --> 01:01:07.180
then by parity
argument, there must

01:01:07.180 --> 01:01:08.897
be another unbalanced node.

01:01:08.897 --> 01:01:09.980
I'm asking you to find it.

01:01:09.980 --> 01:01:13.690
That's the definition of
this end of the line problem.

01:01:13.690 --> 01:01:15.990
And PPAD is the
class of all problems

01:01:15.990 --> 01:01:19.270
that are in FNP
that are poly-time

01:01:19.270 --> 01:01:23.090
reducible to this problem.

01:01:23.090 --> 01:01:24.370
Now this sounds weird.

01:01:24.370 --> 01:01:28.820
So let me show you how the graph
defined by these two circuits

01:01:28.820 --> 01:01:29.464
looks like.

01:01:33.010 --> 01:01:34.510
And this will be
hopefully familiar.

01:01:37.360 --> 01:01:40.320
So I'm copying here the
condition for putting

01:01:40.320 --> 01:01:43.500
an edge between two strings.

01:01:43.500 --> 01:01:47.030
The set of things I'm
looking at is 0, 1 to the n.

01:01:47.030 --> 01:01:50.120
This is the condition for when
I put an edge from string v1

01:01:50.120 --> 01:01:53.090
to string v2.

01:01:53.090 --> 01:01:56.800
Now notice that by
definition, every string

01:01:56.800 --> 01:01:59.790
has at most one possible child.

01:01:59.790 --> 01:02:03.820
And every string has at
most one possible father.

01:02:03.820 --> 01:02:07.850
So the in degrees and
out degrees of this graph

01:02:07.850 --> 01:02:09.010
are at most 1.

01:02:12.680 --> 01:02:16.660
So I'm implicitly describing
a graph that looks like this.

01:02:16.660 --> 01:02:19.010
And what I ask you to do
is to check the following.

01:02:19.010 --> 01:02:22.380
I ask you to check
if 0, the 0 string,

01:02:22.380 --> 01:02:27.000
is unbalanced, meaning it either
has a father but not a child.

01:02:27.000 --> 01:02:30.580
Or it has a child
but not a father.

01:02:30.580 --> 01:02:34.290
If it's balanced, you
don't need to do any work.

01:02:34.290 --> 01:02:37.130
But if it's unbalanced, which
is easy to check locally--

01:02:37.130 --> 01:02:40.770
you just query the candidate
next child and check

01:02:40.770 --> 01:02:46.690
if that child believes that 0
is its father or vice versa.

01:02:46.690 --> 01:02:50.450
If 0 to the n is
unbalanced, then by parity,

01:02:50.450 --> 01:02:51.900
because the graph
looks like this,

01:02:51.900 --> 01:02:54.930
there must be some other
unbalanced vertex, at least

01:02:54.930 --> 01:02:55.820
one.

01:02:55.820 --> 01:02:57.195
And I'm asking
you to find me any

01:02:57.195 --> 01:02:59.070
of these unbalanced vertices.

01:02:59.070 --> 01:03:02.390
So in particular, you don't need
to find the unbalanced vertex

01:03:02.390 --> 01:03:05.975
that's in the other end of the
path that starts at 0 to the n

01:03:05.975 --> 01:03:08.714
or finishes at 0 to the n.

01:03:08.714 --> 01:03:10.880
You can give me any of the
other unbalanced vertices

01:03:10.880 --> 01:03:12.230
if there are any.

01:03:12.230 --> 01:03:13.760
But by parity, I
know that there is

01:03:13.760 --> 01:03:17.500
at least one unbalanced vertex.

01:03:17.500 --> 01:03:19.650
So PPAD is this problem.

01:03:19.650 --> 01:03:22.730
I describe an
exponentially large graph

01:03:22.730 --> 01:03:25.830
by giving you two circuits.

01:03:25.830 --> 01:03:28.870
Now no matter what
circuits I gave you,

01:03:28.870 --> 01:03:30.302
I know the graph
looks like this.

01:03:33.010 --> 01:03:36.430
Now in this graph, if 0
to the n is unbalanced--

01:03:36.430 --> 01:03:38.220
if a 0 string is
unbalanced, you know

01:03:38.220 --> 01:03:40.740
that there must be
another unbalanced vertex.

01:03:40.740 --> 01:03:43.830
Any of them is good as a
solution to the problem.

01:03:43.830 --> 01:03:44.990
Yeah?

01:03:44.990 --> 01:03:47.220
AUDIENCE: So how then do
we know that 0 to the n

01:03:47.220 --> 01:03:49.860
doesn't point to a
previous other string that

01:03:49.860 --> 01:03:52.160
points to 0 to the n?

01:03:52.160 --> 01:03:53.860
How do we know that 0 to the n--

01:03:53.860 --> 01:03:56.290
CONSTANTINOS DASKALAKIS: So
in that-- no, it can happen.

01:03:56.290 --> 01:04:00.060
It could be that
this is 0 to the n.

01:04:00.060 --> 01:04:07.730
It has a child that believes
that this is its father.

01:04:07.730 --> 01:04:12.110
And also, v believes that
0 to the n is its child.

01:04:12.110 --> 01:04:15.220
And 0 to the n believes
that this is the father.

01:04:15.220 --> 01:04:18.280
This creates a 0 to the
n which is balanced.

01:04:18.280 --> 01:04:21.604
In that case, you don't
need to do any work.

01:04:21.604 --> 01:04:23.020
So the statement
of the problem is

01:04:23.020 --> 01:04:28.070
asking you to do work only
if 0 to the n is unbalanced.

01:04:28.070 --> 01:04:31.450
So end of the line
tells you if 0 to the n

01:04:31.450 --> 01:04:34.340
is unbalanced, which you can
trivially check locally-- you

01:04:34.340 --> 01:04:36.520
don't need to look
at the whole graph

01:04:36.520 --> 01:04:40.980
to decide whether 0 to
the n is balanced or not.

01:04:40.980 --> 01:04:43.950
So to decide whether 0
to the n is balanced,

01:04:43.950 --> 01:04:45.170
you need four queries.

01:04:45.170 --> 01:04:48.307
AUDIENCE: Couldn't you have
an exponentially long segment?

01:04:48.307 --> 01:04:50.140
CONSTANTINOS DASKALAKIS:
Yeah, but the point

01:04:50.140 --> 01:04:51.590
is-- that's the whole point.

01:04:51.590 --> 01:04:56.836
So if I query-- if v--

01:04:56.836 --> 01:04:57.830
AUDIENCE: I see.

01:04:57.830 --> 01:05:00.880
CONSTANTINOS DASKALAKIS: is the
possible parent of 0 to the n,

01:05:00.880 --> 01:05:10.250
and u is the possible
child of 0 to the n,

01:05:10.250 --> 01:05:12.830
then the state of the
world could be this.

01:05:18.000 --> 01:05:19.080
It could be this.

01:05:19.080 --> 01:05:23.790
Now if also this guy believes
that 0 to the n is his father,

01:05:23.790 --> 01:05:26.570
I'm going to make
this edge solid.

01:05:26.570 --> 01:05:29.440
That's the fourth query I'm
going to make to my circuits.

01:05:29.440 --> 01:05:33.220
If this guy believes that
0 to the n is his father,

01:05:33.220 --> 01:05:35.680
I'm going to also
make this edge solid.

01:05:35.680 --> 01:05:38.710
If both are solid, then
0 to the n is balanced.

01:05:38.710 --> 01:05:40.680
I don't need to do any work.

01:05:40.680 --> 01:05:43.150
If this is missing, then
0 to the n unbalanced.

01:05:43.150 --> 01:05:45.390
I need to do work and
so on and so forth.

01:05:45.390 --> 01:05:46.210
OK?

01:05:46.210 --> 01:05:48.335
But with four queries
to my circuits--

01:05:48.335 --> 01:05:50.230
so in polynomial
time in particular

01:05:50.230 --> 01:05:52.930
in the description of my input--
I can decide whether 0 to the n

01:05:52.930 --> 01:05:55.277
is balanced or not.

01:05:55.277 --> 01:05:57.610
And if it's unbalanced, then
I need to do a lot of work.

01:05:57.610 --> 01:06:01.320
And in fact, we have no
better than exponential

01:06:01.320 --> 01:06:03.930
bound for how long it
will take me to find

01:06:03.930 --> 01:06:07.132
the other unbalanced node.

01:06:07.132 --> 01:06:09.257
AUDIENCE: Can you make all
such graphs of this type

01:06:09.257 --> 01:06:12.610
with small circuits?

01:06:12.610 --> 01:06:14.050
CONSTANTINOS DASKALAKIS: Mm-mm.

01:06:14.050 --> 01:06:15.770
I mean, no.

01:06:15.770 --> 01:06:19.890
I mean, you're asking, if I pick
an arbitrary exponential graph,

01:06:19.890 --> 01:06:25.200
if it's always compressible
into polynomial size?

01:06:25.200 --> 01:06:27.670
I mean, it depends on
how phrase the question.

01:06:27.670 --> 01:06:33.760
So if you allow me to get a
huge p-- p is part of the input.

01:06:33.760 --> 01:06:35.130
p is a part of the input.

01:06:35.130 --> 01:06:38.390
So now if p is a
lookup table, that's

01:06:38.390 --> 01:06:41.010
a trivial instance, actually.

01:06:41.010 --> 01:06:44.270
So the instances that
are hard are those

01:06:44.270 --> 01:06:46.140
where p is a succinct thing.

01:06:46.140 --> 01:06:49.112
It's polynomially in n
size but still defines

01:06:49.112 --> 01:06:50.320
an exponentially large graph.

01:06:50.320 --> 01:06:52.810
If p is a huge thing,
a lookup table that

01:06:52.810 --> 01:06:55.640
keeps track of all
connectivities of all vertices

01:06:55.640 --> 01:06:58.810
with each other, we're getting
into algorithms territory,

01:06:58.810 --> 01:07:02.430
where I give you an adjacency
list for every node.

01:07:02.430 --> 01:07:05.970
So this is a purely
algorithmic problem

01:07:05.970 --> 01:07:08.050
that we can trivially solve.

01:07:08.050 --> 01:07:11.270
So if I get into the regime
where my p, my circuit

01:07:11.270 --> 01:07:15.820
description, is polynomial
in the size of the graph,

01:07:15.820 --> 01:07:18.970
that's an easy instance.

01:07:18.970 --> 01:07:21.067
But if you're
asking the question,

01:07:21.067 --> 01:07:23.150
can I always compress an
exponentially large graph

01:07:23.150 --> 01:07:27.680
into two circuits, p and n,
that are polynomial in size,

01:07:27.680 --> 01:07:29.950
then that's not the case.

01:07:29.950 --> 01:07:30.660
OK.

01:07:30.660 --> 01:07:34.630
So PPAD-- notice that this
end of the line problem

01:07:34.630 --> 01:07:38.930
is in FNP because I can just
guess the unbalanced vertex,

01:07:38.930 --> 01:07:40.700
different than the 0 string.

01:07:40.700 --> 01:07:43.430
And I can check
easily if it's also

01:07:43.430 --> 01:07:45.780
unbalanced with four queries.

01:07:45.780 --> 01:07:47.730
So it is in FNP.

01:07:47.730 --> 01:07:52.690
And I hope you believe me
that Sperner isn't PPAD,

01:07:52.690 --> 01:07:55.090
because just the
proof of Sperner

01:07:55.090 --> 01:07:57.190
was exactly the
same kind of thing.

01:07:57.190 --> 01:07:59.760
So I succinctly
described this graph that

01:07:59.760 --> 01:08:01.640
had exactly the same structure.

01:08:01.640 --> 01:08:04.320
So really, what inspired
the definition of this class

01:08:04.320 --> 01:08:07.980
is the proof of Sperner's lemma.

01:08:07.980 --> 01:08:13.320
Now I sort of argued that you
can prove Brouwer via Sperner.

01:08:13.320 --> 01:08:17.899
I gave this hand wave-y, high
level picture showing that.

01:08:17.899 --> 01:08:20.189
And also Nash through Brouwer.

01:08:20.189 --> 01:08:23.390
So in fact, PPAD definitely
contains the problems

01:08:23.390 --> 01:08:25.510
that I'm interested in.

01:08:25.510 --> 01:08:26.602
That was the litmus test.

01:08:26.602 --> 01:08:28.560
The litmus test is I went
through this exercise

01:08:28.560 --> 01:08:31.899
to define this class PPAD
based on the existence

01:08:31.899 --> 01:08:35.240
proof of Sperner's lemma.

01:08:35.240 --> 01:08:38.130
And I successful got all
these interesting problems

01:08:38.130 --> 01:08:39.899
inside PPAD.

01:08:39.899 --> 01:08:46.750
But the litmus test is--
the success of my exercise

01:08:46.750 --> 01:08:51.810
is whether I get also
tight reductions.

01:08:51.810 --> 01:08:54.770
So if I also get that
these problems are

01:08:54.770 --> 01:08:56.510
as hard as any other
problem in PPAD,

01:08:56.510 --> 01:08:59.510
now I can call my
thing successful.

01:08:59.510 --> 01:09:04.410
So in particular, as an
example, the definition of NP

01:09:04.410 --> 01:09:08.229
is that SAT is NP complete.

01:09:08.229 --> 01:09:11.850
So NP was defined
with SAT in mind.

01:09:14.640 --> 01:09:17.430
But it also captured exactly
the complexity of SAT.

01:09:17.430 --> 01:09:19.020
So that was a
successful definition

01:09:19.020 --> 01:09:20.620
of a complexity class.

01:09:20.620 --> 01:09:23.990
So the litmus test for this
exercise that I went through

01:09:23.990 --> 01:09:26.945
with you is whether
actually those problems

01:09:26.945 --> 01:09:30.660
that I'm interested in
are also PPAD complete.

01:09:30.660 --> 01:09:35.279
So what we showed with
Goldberg and Papadimitriou

01:09:35.279 --> 01:09:37.840
a bunch of-- I guess
10 years ago almost--

01:09:37.840 --> 01:09:41.520
is that actually the opposite
reductions are also true,

01:09:41.520 --> 01:09:46.540
that all these problems are
computationally equivalent.

01:09:46.540 --> 01:09:50.830
In fact, I didn't show that
these are equivalent to PPAD.

01:09:50.830 --> 01:09:52.200
These were already known.

01:09:52.200 --> 01:09:54.700
These results were already
known since Papadimitriou's

01:09:54.700 --> 01:09:57.780
original paper,
that PPAD exactly

01:09:57.780 --> 01:10:01.110
is equivalent to
Sperner and Brouwer.

01:10:01.110 --> 01:10:02.860
What we show together
is that Nash also

01:10:02.860 --> 01:10:05.399
is equivalent, is in the
same league of problems,

01:10:05.399 --> 01:10:07.440
basically establishing
that all of these problems

01:10:07.440 --> 01:10:08.787
are computationally equivalent.

01:10:08.787 --> 01:10:11.120
Finding a Nash equilibrium
is a computational equivalent

01:10:11.120 --> 01:10:13.730
to Sperner's lemma,
computationally equivalent

01:10:13.730 --> 01:10:17.350
to any problem in PPAD
and so on and so forth.

01:10:17.350 --> 01:10:20.790
And the high level
of the reduction--

01:10:20.790 --> 01:10:22.800
I'm going to hand
wave about it--

01:10:22.800 --> 01:10:26.750
is that we started this
generic PPAD instance.

01:10:26.750 --> 01:10:30.930
And what we do is we envision
embedding this instance

01:10:30.930 --> 01:10:32.550
into some geometry.

01:10:36.100 --> 01:10:38.070
Because this a
combinatorial problem,

01:10:38.070 --> 01:10:39.910
our goal eventually
is to reduce it

01:10:39.910 --> 01:10:45.950
to Brouwer and to Nash, which
are continuous problems.

01:10:45.950 --> 01:10:49.530
So the first thing we did is
we embed this graph into a cube

01:10:49.530 --> 01:10:53.070
in a way that's sort of like
every path or cycle corresponds

01:10:53.070 --> 01:10:59.950
to a path that moves
around this cube

01:10:59.950 --> 01:11:01.760
without intersecting itself.

01:11:01.760 --> 01:11:03.490
So this is the
first thing we do.

01:11:03.490 --> 01:11:10.160
Then we find a way to solve
the resulting embedded PPAD

01:11:10.160 --> 01:11:15.850
instance, reduce it to
a Sperner's instance.

01:11:15.850 --> 01:11:18.670
And then in fact, the
core of the proof--

01:11:18.670 --> 01:11:22.320
and I'm going to actually
talk about this more--

01:11:22.320 --> 01:11:28.370
is to reduce this problem
into a problem that

01:11:28.370 --> 01:11:33.080
asks you to evaluate
an arithmetic circuit.

01:11:33.080 --> 01:11:37.240
Now after you get that PPAD
reduces to this evaluation

01:11:37.240 --> 01:11:42.120
problem, it's really-- I call it
approximate arithmetic circuit

01:11:42.120 --> 01:11:43.130
SAT.

01:11:43.130 --> 01:11:45.260
So I'm going to get
into what this means.

01:11:45.260 --> 01:11:47.990
But it's really a
satisfiability problem

01:11:47.990 --> 01:11:49.470
for arithmetic circuits.

01:11:49.470 --> 01:11:53.130
But after you get PPAD to
reduce to this problem,

01:11:53.130 --> 01:11:57.880
it's easy to get to Nash and
all the other implications,

01:11:57.880 --> 01:12:01.820
all the other known PPAD
completeness reductions

01:12:01.820 --> 01:12:03.960
that people have established.

01:12:03.960 --> 01:12:07.060
So what I want to describe is
what this problem is about.

01:12:10.090 --> 01:12:14.960
It's the equivalent of circuit
SAT, which is NP complete.

01:12:14.960 --> 01:12:17.850
This is called
arithmetic circuit SATs,

01:12:17.850 --> 01:12:20.220
and I'm going to show
you what it means.

01:12:20.220 --> 01:12:20.880
Question?

01:12:20.880 --> 01:12:23.770
AUDIENCE: So in the
course of this reduction,

01:12:23.770 --> 01:12:26.610
do we get to replay
our game for Nash,

01:12:26.610 --> 01:12:28.720
like does this three
carry through to the--

01:12:28.720 --> 01:12:29.180
CONSTANTINOS DASKALAKIS: Yes.

01:12:29.180 --> 01:12:30.513
So you get actually two players.

01:12:30.513 --> 01:12:32.284
You can get two player Nash.

01:12:32.284 --> 01:12:33.220
Yeah.

01:12:33.220 --> 01:12:36.310
So it establishes
that all games are--

01:12:36.310 --> 01:12:38.020
if they're not two
player zero-sum,

01:12:38.020 --> 01:12:40.120
they are PPAD complete.

01:12:40.120 --> 01:12:44.150
So the input to the
problem is a circuit.

01:12:44.150 --> 01:12:47.810
The circuit comprises two
kinds of nodes, viable nodes

01:12:47.810 --> 01:12:49.560
and gates.

01:12:49.560 --> 01:12:53.320
So gates are represented
with solid circles.

01:12:53.320 --> 01:12:59.230
Viable nodes are with-- I
don't know-- empty circles.

01:12:59.230 --> 01:13:01.290
So the viable nodes
are x1 through xn.

01:13:01.290 --> 01:13:04.050
The gate's nodes
are g1 through gm.

01:13:04.050 --> 01:13:08.230
Now the gates can--
I can choose gates

01:13:08.230 --> 01:13:12.590
from the following
set of possible gates.

01:13:12.590 --> 01:13:15.890
I'm going to explain what
these gates are meant to do.

01:13:15.890 --> 01:13:17.380
But this is an assignment gate.

01:13:17.380 --> 01:13:19.140
This is a plus addition gate.

01:13:19.140 --> 01:13:21.100
This is a subtraction gate.

01:13:21.100 --> 01:13:24.450
This is set equal
to a constant gate.

01:13:24.450 --> 01:13:28.430
This is times a constant gate,
and this is a comparison gate.

01:13:28.430 --> 01:13:31.110
The subtraction and
comparison gates

01:13:31.110 --> 01:13:32.600
are non-symmetric
in their inputs.

01:13:32.600 --> 01:13:36.160
So they have a special input
1 and a special input 2,

01:13:36.160 --> 01:13:40.100
similarly for the
comparison gate.

01:13:40.100 --> 01:13:43.020
And I also have directed
edges that connect variables

01:13:43.020 --> 01:13:44.750
to gates and vice versa.

01:13:44.750 --> 01:13:46.910
But there are no edges
between variables.

01:13:46.910 --> 01:13:49.630
So there are no edges
between the gates.

01:13:49.630 --> 01:13:51.490
And also, the loops are allowed.

01:13:51.490 --> 01:13:52.390
That's important.

01:13:52.390 --> 01:13:53.440
So you can have loops.

01:13:53.440 --> 01:13:54.815
For example, in
this picture, you

01:13:54.815 --> 01:13:57.020
have a loop between vertices.

01:13:57.020 --> 01:14:00.270
And actually, there are
no inputs to the circuit.

01:14:00.270 --> 01:14:02.910
In circuit SAT, you
want to set the input

01:14:02.910 --> 01:14:04.169
so that the output is 1.

01:14:04.169 --> 01:14:05.210
And you don't have loops.

01:14:05.210 --> 01:14:06.280
You have a DAG.

01:14:06.280 --> 01:14:08.880
And your gates are
just binary gates.

01:14:08.880 --> 01:14:10.940
Here we're in a
different situation.

01:14:10.940 --> 01:14:13.030
We don't have inputs.

01:14:13.030 --> 01:14:15.312
Our gates can have loops.

01:14:15.312 --> 01:14:16.270
And they're not binary.

01:14:16.270 --> 01:14:18.820
They're arithmetic gates.

01:14:18.820 --> 01:14:27.440
The goal is to assign 0,
1 values to the variables

01:14:27.440 --> 01:14:30.450
so that the gate
constraints are satisfied.

01:14:30.450 --> 01:14:33.010
So now what are the
gate constraints?

01:14:33.010 --> 01:14:35.310
So the output of
an assignment gate

01:14:35.310 --> 01:14:39.390
should equal the input
to the assignment gate.

01:14:39.390 --> 01:14:43.250
If we have an addition gate,
the output of the addition gate

01:14:43.250 --> 01:14:47.590
should be the sum of the
inputs, except everything

01:14:47.590 --> 01:14:48.610
should line 0, 1.

01:14:48.610 --> 01:14:52.640
So it's the minimum between
the sum of inputs and 1.

01:14:55.520 --> 01:14:57.100
The subtraction gate is similar.

01:14:57.100 --> 01:14:59.100
So the output to
the subtraction gate

01:14:59.100 --> 01:15:01.640
is the difference of the inputs.

01:15:01.640 --> 01:15:05.230
But you can't go below 0.

01:15:05.230 --> 01:15:09.400
The set equal gate is-- set
equal to a constant gate

01:15:09.400 --> 01:15:12.080
is sets y to ba.

01:15:12.080 --> 01:15:17.000
But it doesn't allow
it to leave 0, 1.

01:15:17.000 --> 01:15:20.150
And then multiply by
constant gate multiplies

01:15:20.150 --> 01:15:22.150
the input with alpha, with a.

01:15:22.150 --> 01:15:27.730
But also it doesn't allow
it to go below 0 or above 1.

01:15:27.730 --> 01:15:32.280
And these are pretty
straightforward.

01:15:32.280 --> 01:15:34.330
What is slightly weird
is the comparison gate,

01:15:34.330 --> 01:15:36.800
which has a weird
behavior and actually must

01:15:36.800 --> 01:15:39.460
have this behavior for the
problem to be PPAD complete.

01:15:39.460 --> 01:15:41.210
You can show that.

01:15:41.210 --> 01:15:45.440
The comparison
gate has to be a 1.

01:15:45.440 --> 01:15:47.872
The output has to be a
1 if the first input is

01:15:47.872 --> 01:15:49.080
bigger than the second input.

01:15:49.080 --> 01:15:52.155
It has to be a 0 if this
first input is smaller.

01:15:52.155 --> 01:15:54.460
But if they're equal,
it can be anything.

01:15:54.460 --> 01:15:56.852
It's allowed to be anything.

01:15:56.852 --> 01:15:59.060
Actually, if you think about
it as a continuous gate,

01:15:59.060 --> 01:16:02.780
it cannot just jump from 0 to 1
without being able to take all

01:16:02.780 --> 01:16:06.510
the intermediate values.

01:16:06.510 --> 01:16:07.499
OK?

01:16:07.499 --> 01:16:08.290
It can be anything.

01:16:08.290 --> 01:16:10.164
Any value is allowed if
the inputs are equal.

01:16:12.640 --> 01:16:18.170
So that's the
arithmetic circuit SAT

01:16:18.170 --> 01:16:21.750
problem that is PPAD complete.

01:16:21.750 --> 01:16:24.150
First of all, this
problem is total.

01:16:24.150 --> 01:16:26.580
No matter what circuit
you write down,

01:16:26.580 --> 01:16:28.350
I can prove to you
that there is always

01:16:28.350 --> 01:16:31.120
an evaluation that works.

01:16:31.120 --> 01:16:32.730
That's not a priori obvious.

01:16:32.730 --> 01:16:35.170
It's not a priori obvious
that no matter what

01:16:35.170 --> 01:16:38.270
circuit I describe
using these gates

01:16:38.270 --> 01:16:41.400
has a satisfying assignment.

01:16:41.400 --> 01:16:42.727
But I claim this is true.

01:16:42.727 --> 01:16:44.060
I'm not going to show it to you.

01:16:44.060 --> 01:16:45.600
It is true though.

01:16:45.600 --> 01:16:48.950
And it must be true because this
problem belongs in this family

01:16:48.950 --> 01:16:50.160
of PPAD complete problems.

01:16:50.160 --> 01:16:52.910
So it has to also inherit
all the properties

01:16:52.910 --> 01:16:56.000
that this class of
problems shares.

01:16:56.000 --> 01:16:58.090
Now let's try to
work out the details

01:16:58.090 --> 01:17:01.150
of what the computation is.

01:17:01.150 --> 01:17:01.650
OK.

01:17:01.650 --> 01:17:07.720
So I want to argue
that in this-- I

01:17:07.720 --> 01:17:10.890
want to claim that the only
satisfying assignment is

01:17:10.890 --> 01:17:15.110
that everything is
equal to 1/2 actually.

01:17:15.110 --> 01:17:17.720
And let's try to verify it.

01:17:17.720 --> 01:17:22.960
So suppose that a was
not-- actually, no.

01:17:22.960 --> 01:17:24.960
I take that back.

01:17:24.960 --> 01:17:31.130
So a must be 1/2, and b can be--
no, actually they're all 1/2.

01:17:31.130 --> 01:17:32.200
Sorry, sorry.

01:17:32.200 --> 01:17:33.546
They're all 1/2.

01:17:33.546 --> 01:17:34.540
I don't take it back.

01:17:34.540 --> 01:17:35.900
So let me try to argue that.

01:17:35.900 --> 01:17:39.850
So suppose that a
was bigger than 1/2.

01:17:39.850 --> 01:17:41.510
So c must be 1/2, right?

01:17:41.510 --> 01:17:44.260
That's by the
condition of the gate.

01:17:44.260 --> 01:17:46.050
This is set equal to 1/2.

01:17:46.050 --> 01:17:47.630
So this must be 1/2.

01:17:47.630 --> 01:17:49.760
That's obvious.

01:17:49.760 --> 01:17:54.340
Now I claim that a cannot
be bigger than 1/2.

01:17:54.340 --> 01:17:59.420
If a was bigger
than 1/2, then this

01:17:59.420 --> 01:18:01.860
is bigger than this input
of the comparison gate.

01:18:01.860 --> 01:18:04.890
So the comparison
gate would output a 0.

01:18:04.890 --> 01:18:06.830
But this set equal
operation would

01:18:06.830 --> 01:18:09.000
have to set this guy to be 0.

01:18:09.000 --> 01:18:10.780
So 0 can't be bigger than 1/2.

01:18:13.350 --> 01:18:15.110
Let's do the other direction.

01:18:15.110 --> 01:18:17.700
Suppose a was smaller than 1/2.

01:18:17.700 --> 01:18:20.920
If a was smaller than 1/2,
then the comparison gate

01:18:20.920 --> 01:18:22.250
would [INAUDIBLE] 1.

01:18:22.250 --> 01:18:24.020
This would set it to 1.

01:18:24.020 --> 01:18:26.390
So how can 1 be
smaller than 1/2?

01:18:26.390 --> 01:18:29.600
So the only possibility
is that it's actually 1/2.

01:18:29.600 --> 01:18:34.774
And if it's 1/2 and 1/2,
then it's setting 1/2.

01:18:34.774 --> 01:18:36.940
Because the inputs are equal
to the comparison gate,

01:18:36.940 --> 01:18:38.920
you can set this to be anything.

01:18:38.920 --> 01:18:41.210
So everything being 1/2
satisfies all the conditions

01:18:41.210 --> 01:18:42.830
of the gates.

01:18:42.830 --> 01:18:45.840
So that's the problem
we're trying to solve.

01:18:45.840 --> 01:18:50.270
make The claim is that this
problem is PPAD complete.

01:18:50.270 --> 01:18:53.600
And this problem is going to
be the starting point for all

01:18:53.600 --> 01:18:57.550
our reduction next time, in
particular showing that Nash's

01:18:57.550 --> 01:19:02.410
theorem is PPAD complete.

01:19:02.410 --> 01:19:05.060
I want to add the last point.

01:19:05.060 --> 01:19:08.120
After we published our
paper, Chen, Deng, and Teng

01:19:08.120 --> 01:19:14.980
actually improved these
results to fuzzy gates.

01:19:14.980 --> 01:19:19.220
So they-- actually, we
allowed in our original paper

01:19:19.220 --> 01:19:22.280
exponential noise in
the outputs of the gate.

01:19:22.280 --> 01:19:25.230
So this is an
easier problem now.

01:19:25.230 --> 01:19:26.280
So I give you a circuit.

01:19:26.280 --> 01:19:29.190
And I want you to find me
an assignment that satisfies

01:19:29.190 --> 01:19:31.100
all gates approximately.

01:19:31.100 --> 01:19:33.250
So now in the original
paper, we could accommodate

01:19:33.250 --> 01:19:36.920
exponential noise in
the size of the input

01:19:36.920 --> 01:19:38.410
and the fuzziness of the gates.

01:19:38.410 --> 01:19:40.840
These guys showed
that you can even

01:19:40.840 --> 01:19:44.670
accommodate any polynomial
noise, inverse polynomial noise

01:19:44.670 --> 01:19:45.920
that you want.

01:19:45.920 --> 01:19:47.720
And it's still PPAD complete.

01:19:47.720 --> 01:19:51.481
That's an easier problem than
the exact problem obviously.

01:19:51.481 --> 01:19:52.980
But in fact, they're
computationally

01:19:52.980 --> 01:19:55.500
equivalent because they're
both PPAD complete.

01:19:55.500 --> 01:19:57.409
So now next time,
what I'm going to show

01:19:57.409 --> 01:19:59.950
is I'm going to use this problem
to show that Nash and market

01:19:59.950 --> 01:20:02.100
equilibrium are PPAD complete.

01:20:02.100 --> 01:20:05.140
I'm going to show that some
problems in combinatorics,

01:20:05.140 --> 01:20:09.225
such as fractional hypergraph
matching and Scarf's lemma

01:20:09.225 --> 01:20:10.670
are PPAD complete.

01:20:10.670 --> 01:20:12.590
And then if we have
time, I'm going

01:20:12.590 --> 01:20:15.500
to show you other
existence arguments that

01:20:15.500 --> 01:20:21.380
give rise to different
interesting complexity classes.

01:20:21.380 --> 01:20:23.310
AUDIENCE: Named
after Papadimitriou?

01:20:23.310 --> 01:20:23.380
CONSTANTINOS DASKALAKIS: Yeah.

01:20:23.380 --> 01:20:24.310
Many people ask that.

01:20:24.310 --> 01:20:27.160
So it means polynomial parity
argument of directed graphs.

01:20:30.622 --> 01:20:31.580
That's a good question.

01:20:31.580 --> 01:20:32.080
Yeah.

01:20:32.080 --> 01:20:35.120
I should have said that.

01:20:35.120 --> 01:20:35.620
OK.

01:20:35.620 --> 01:20:37.720
Thanks a lot.

01:20:37.720 --> 01:20:40.770
[APPLAUSE]