WEBVTT

00:00:00.000 --> 00:00:02.520
The following content is
provided under a Creative

00:00:02.520 --> 00:00:03.970
Commons license.

00:00:03.970 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.690
continue to offer high quality
educational resources for free.

00:00:10.690 --> 00:00:13.350
To make a donation or
view additional materials

00:00:13.350 --> 00:00:16.950
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.950 --> 00:00:18.400
at ocw.mit.edu.

00:00:31.380 --> 00:00:34.290
PROFESSOR: I wanted to
begin by just picking up

00:00:34.290 --> 00:00:35.740
a couple of things
from last time.

00:00:35.740 --> 00:00:37.200
This is part of
our sneaky agenda

00:00:37.200 --> 00:00:41.650
of trying to teach you some
probability as we go along.

00:00:41.650 --> 00:00:44.160
This is maybe a
little less crucial

00:00:44.160 --> 00:00:47.010
than other things
we've been doing,

00:00:47.010 --> 00:00:49.110
but to make sense of the
last couple of slides

00:00:49.110 --> 00:00:51.030
from last time,
there was actually

00:00:51.030 --> 00:00:55.710
stuff I swept under the rug
that it won't hurt you to know.

00:00:55.710 --> 00:00:57.210
Just a reminder,
we talked last time

00:00:57.210 --> 00:01:00.120
about the PDF of
a random variable.

00:01:00.120 --> 00:01:03.090
I neglected to explicitly say
that about something that's

00:01:03.090 --> 00:01:05.610
got to be non-negative
for all values of x.

00:01:05.610 --> 00:01:11.550
And the reason is that if
the area under this thing

00:01:11.550 --> 00:01:15.570
is going to be the
probability for any interval,

00:01:15.570 --> 00:01:17.670
no matter how small,
if the area under it

00:01:17.670 --> 00:01:21.720
is going to be the probability
that the random variable falls

00:01:21.720 --> 00:01:27.570
in that interval, since
probabilities have

00:01:27.570 --> 00:01:30.420
to be non-negative, well, this
function itself had better

00:01:30.420 --> 00:01:31.510
be non-negative.

00:01:31.510 --> 00:01:32.010
OK?

00:01:32.010 --> 00:01:35.250
So that's an explicit
condition, and then there's

00:01:35.250 --> 00:01:37.170
the normalization.

00:01:37.170 --> 00:01:38.760
The question now is,
if you're dealing

00:01:38.760 --> 00:01:42.210
with multiple random variables,
how does the story change?

00:01:42.210 --> 00:01:46.050
So if you've got two random
variables, let's say x and y,

00:01:46.050 --> 00:01:48.660
so two things that can
take numerical values,

00:01:48.660 --> 00:01:52.140
say height and weight of
a randomly picked person.

00:01:52.140 --> 00:01:54.180
We use a very analogous object.

00:01:54.180 --> 00:01:57.910
It's the joint PDF of
the two random variables.

00:01:57.910 --> 00:02:02.010
So it's some function of
two variables, non-negative,

00:02:02.010 --> 00:02:04.350
so you can imagine it
like some probability

00:02:04.350 --> 00:02:08.680
mass that sits on the plane
normalized to unit area.

00:02:08.680 --> 00:02:12.155
And the amount of mass over
any particular piece of area

00:02:12.155 --> 00:02:13.530
tells you what
the probability is

00:02:13.530 --> 00:02:16.750
that you fall in that region.

00:02:16.750 --> 00:02:20.520
So the expected value, we talked
about how to get expected value

00:02:20.520 --> 00:02:22.200
in the single dimensional case.

00:02:22.200 --> 00:02:24.980
In the 2-D case, it's a
natural generalization.

00:02:24.980 --> 00:02:29.370
So the expected value of a
function of x and y, just

00:02:29.370 --> 00:02:31.950
take that function under
the integral signs,

00:02:31.950 --> 00:02:35.110
so you're taking an average
with respect to the PDF.

00:02:35.110 --> 00:02:35.610
OK?

00:02:35.610 --> 00:02:37.027
So it's a very
natural extension.

00:02:37.027 --> 00:02:38.610
This is for the case
of two variables,

00:02:38.610 --> 00:02:43.290
and in the same way
for m variables.

00:02:43.290 --> 00:02:47.130
Now last time, I talked about a
very special case that involved

00:02:47.130 --> 00:02:48.760
multiple random variables.

00:02:48.760 --> 00:02:53.760
These were the random
variables corresponding

00:02:53.760 --> 00:02:56.460
to the noise samples.

00:02:56.460 --> 00:03:01.470
So we sent out a nice
clean looking signal.

00:03:06.180 --> 00:03:09.750
This was our x of n.

00:03:09.750 --> 00:03:13.200
And then what we received was
something that was perturbed.

00:03:13.200 --> 00:03:15.270
And so we would
have liked to get

00:03:15.270 --> 00:03:19.680
in the noise-free case the
same thing, but what we got

00:03:19.680 --> 00:03:23.710
was this perturbed by a
certain random amount.

00:03:23.710 --> 00:03:30.180
So the wi's this was
w1, for instance.

00:03:30.180 --> 00:03:34.980
It's the amount that you add on
or subtract from a given value

00:03:34.980 --> 00:03:39.230
to get the actually
received values.

00:03:39.230 --> 00:03:39.730
OK?

00:03:47.290 --> 00:03:47.790
OK.

00:03:47.790 --> 00:03:51.920
So these are the wi's or wn's.

00:03:54.720 --> 00:03:56.310
So we had multiple
random variables

00:03:56.310 --> 00:04:00.250
because we were taking many
samples in the bit slot.

00:04:00.250 --> 00:04:02.940
And in particular, we
looked at taking the average

00:04:02.940 --> 00:04:04.837
of a bunch of measurements.

00:04:04.837 --> 00:04:06.420
But now, what you've
got is a function

00:04:06.420 --> 00:04:07.840
of many random variables.

00:04:07.840 --> 00:04:11.160
So what does it mean to take
the expected value of a function

00:04:11.160 --> 00:04:12.210
of many variables?

00:04:12.210 --> 00:04:14.610
What does it mean to find
the variance of that?

00:04:14.610 --> 00:04:19.060
Well, we didn't actually
get into the details of it.

00:04:19.060 --> 00:04:21.060
But it turns out, there's
special structure here

00:04:21.060 --> 00:04:23.100
that made those
computations very simple.

00:04:23.100 --> 00:04:26.490
So one key thing was we said
that these noise samples were

00:04:26.490 --> 00:04:29.260
independent from one
time incident to another.

00:04:29.260 --> 00:04:30.900
And that's really
the crucial thing.

00:04:30.900 --> 00:04:34.170
The other piece was just for--

00:04:34.170 --> 00:04:36.150
well, it made sense for
our application because

00:04:36.150 --> 00:04:37.650
of the central limit
theorem, but we

00:04:37.650 --> 00:04:40.530
assumed that these noise
samples were Gaussian

00:04:40.530 --> 00:04:42.133
with varying sigma squared.

00:04:42.133 --> 00:04:43.800
There's a term I
didn't use, by the way,

00:04:43.800 --> 00:04:46.092
for this kind of noise, but
you'll see it in the notes.

00:04:46.092 --> 00:04:49.080
It's what's referred to as
additive white Gaussian noise.

00:04:49.080 --> 00:04:50.730
The additive part is clear.

00:04:50.730 --> 00:04:53.760
The white means
that it's IID noise.

00:04:53.760 --> 00:04:56.280
The reasons for that
name become clear

00:04:56.280 --> 00:04:57.910
when you think about
frequency domain,

00:04:57.910 --> 00:05:01.333
so we won't get into
the origins of the name.

00:05:01.333 --> 00:05:03.000
But the key thing
here is that these are

00:05:03.000 --> 00:05:07.150
independent random variables.

00:05:07.150 --> 00:05:09.803
So we should have actually been
talking about the joint density

00:05:09.803 --> 00:05:11.220
of all these random
variables when

00:05:11.220 --> 00:05:16.350
it came to computing expected
values and variances.

00:05:16.350 --> 00:05:19.120
But it turns out that there are
actually some simplification,

00:05:19.120 --> 00:05:21.630
so I'm just going to
give two statements which

00:05:21.630 --> 00:05:25.530
are the things I want
you to carry away.

00:05:25.530 --> 00:05:27.810
One is that expectation
is always additive.

00:05:27.810 --> 00:05:30.215
So when you take the
expected value of--

00:05:30.215 --> 00:05:32.340
I'm doing this for the case
of two random variables

00:05:32.340 --> 00:05:35.580
by the way, but the
same thing goes for m.

00:05:35.580 --> 00:05:38.550
If you've got the expectation
of a sum of two functions

00:05:38.550 --> 00:05:40.740
of these random variables
that you're interested in,

00:05:40.740 --> 00:05:44.160
the result is the sum of
the individual expectations.

00:05:44.160 --> 00:05:46.050
And that's just the
consequence of the fact

00:05:46.050 --> 00:05:49.290
that expectation is defined
through integrals and integrals

00:05:49.290 --> 00:05:53.160
are additive in their
arguments, in the integrands.

00:05:53.160 --> 00:05:53.660
Right?

00:05:53.660 --> 00:05:56.760
So that's all that's
involved there.

00:05:56.760 --> 00:05:58.500
Now, the particular
use we make of it

00:05:58.500 --> 00:06:00.660
is for actually for a
sum of this kind where

00:06:00.660 --> 00:06:03.270
one of the functions
is a function of just

00:06:03.270 --> 00:06:05.250
one of the random variables,
the other function

00:06:05.250 --> 00:06:07.720
is a function of just the
other random variable.

00:06:07.720 --> 00:06:09.450
And so if you apply
the result up there,

00:06:09.450 --> 00:06:12.030
you get sum of the expectations.

00:06:12.030 --> 00:06:13.890
And the nice thing now
is that each of these

00:06:13.890 --> 00:06:16.180
is just a 1-D expectation.

00:06:16.180 --> 00:06:20.010
So we never have to
deal with joint PDFs,

00:06:20.010 --> 00:06:23.220
joint distributions, multiple
integrals, and so on.

00:06:23.220 --> 00:06:25.900
It all stays as simple
as the 1-D case.

00:06:25.900 --> 00:06:27.850
And the reason is
that in every instance

00:06:27.850 --> 00:06:30.960
we talk about, when we
have the expectation

00:06:30.960 --> 00:06:35.080
of a sum of functions of
multiple random variables,

00:06:35.080 --> 00:06:38.880
well, the sum actually involves
functions, each of which

00:06:38.880 --> 00:06:41.130
is a function of only one
of those random variables.

00:06:41.130 --> 00:06:45.330
So it actually becomes
very easy to compute.

00:06:45.330 --> 00:06:48.490
Here's another thing that's
interesting with expectations,

00:06:48.490 --> 00:06:52.470
which is that under
independence, you can actually

00:06:52.470 --> 00:06:55.140
have expectations
be multiplicative.

00:06:55.140 --> 00:06:57.930
In fact, let's see,
so the expected value

00:06:57.930 --> 00:07:00.707
of the product of
a function of just

00:07:00.707 --> 00:07:02.790
one of the random variables
and a function of just

00:07:02.790 --> 00:07:05.550
the other factors
into the product

00:07:05.550 --> 00:07:09.030
of the individual expectations
if these two random variables

00:07:09.030 --> 00:07:09.760
are independent.

00:07:09.760 --> 00:07:12.450
So that, again,
ends up being used.

00:07:12.450 --> 00:07:17.970
For instance, when you're
computing the variance of,

00:07:17.970 --> 00:07:25.530
let's say, w1 plus w2,
so the variance of this

00:07:25.530 --> 00:07:28.500
is going to involve computing--

00:07:28.500 --> 00:07:29.720
this is the 0 mean case.

00:07:29.720 --> 00:07:31.220
So you'll find that
you're computing

00:07:31.220 --> 00:07:36.060
the expected value of
w1 squared and then

00:07:36.060 --> 00:07:37.860
the expected value
of w2 squared.

00:07:40.410 --> 00:07:48.180
And then you've got twice
the expected value of w1 w2.

00:07:51.060 --> 00:07:52.530
OK?

00:07:52.530 --> 00:07:56.710
So while this is easy,
this is sigma squared,

00:07:56.710 --> 00:08:00.510
this is sigma squared, what
do we do with this term?

00:08:00.510 --> 00:08:03.755
Well, if it was a
general function of two

00:08:03.755 --> 00:08:05.130
random variables,
then you've got

00:08:05.130 --> 00:08:08.560
to pull in the joint density,
and it becomes a big operation.

00:08:08.560 --> 00:08:11.460
But if these are independent,
then this expectation

00:08:11.460 --> 00:08:13.890
factors into the product
of the individual ones.

00:08:13.890 --> 00:08:15.790
These are 0 mean
random variables.

00:08:15.790 --> 00:08:17.650
And so this goes to 0.

00:08:17.650 --> 00:08:18.150
OK?

00:08:18.150 --> 00:08:21.820
So this kind of computation
was going on in the results

00:08:21.820 --> 00:08:25.770
I quoted or claimed
in the last lecture,

00:08:25.770 --> 00:08:29.310
and I just wanted you
to have that in mind.

00:08:29.310 --> 00:08:30.507
OK.

00:08:30.507 --> 00:08:32.549
But what I really want to
talk about for the rest

00:08:32.549 --> 00:08:36.120
of the lecture is going back
to understanding and modeling

00:08:36.120 --> 00:08:37.510
the single link.

00:08:37.510 --> 00:08:44.580
So we'll leave the probabilistic
stuff and that for now.

00:08:44.580 --> 00:08:45.150
OK.

00:08:45.150 --> 00:08:48.330
So we're back to
this picture of bits

00:08:48.330 --> 00:08:51.960
coming in, being
converted to signals.

00:08:51.960 --> 00:08:53.980
The signals are in
discrete time here.

00:08:53.980 --> 00:08:56.850
They're being adapted
then to transmit

00:08:56.850 --> 00:08:59.610
on an analog channel,
which has the noise in it,

00:08:59.610 --> 00:09:02.490
and then at the other
end back to discrete time

00:09:02.490 --> 00:09:05.830
through an inverse kind of
operation and out to bits

00:09:05.830 --> 00:09:06.330
again.

00:09:06.330 --> 00:09:08.205
So we're going to look
in more detail at what

00:09:08.205 --> 00:09:09.930
goes on in there.

00:09:09.930 --> 00:09:13.680
What we did with all our
noise analysis last time

00:09:13.680 --> 00:09:17.590
was really focused on this
box where the decision is.

00:09:17.590 --> 00:09:18.090
Right?

00:09:18.090 --> 00:09:19.465
You get a noisy
sample and you're

00:09:19.465 --> 00:09:20.790
trying to decide what you have.

00:09:20.790 --> 00:09:23.965
So the lecture last time
was focused on that box,

00:09:23.965 --> 00:09:26.340
and we're going to look at
the other parts of the picture

00:09:26.340 --> 00:09:28.740
this time.

00:09:28.740 --> 00:09:29.240
OK.

00:09:29.240 --> 00:09:37.370
So the digitized symbols that we
talk about, here's an example.

00:09:37.370 --> 00:09:38.670
We saw this last time.

00:09:38.670 --> 00:09:41.510
So what you're doing
is taking the bitstream

00:09:41.510 --> 00:09:43.550
and deciding that you're
going to represent it,

00:09:43.550 --> 00:09:49.070
for instance, as a voltage one
held for a number of samples

00:09:49.070 --> 00:09:52.130
to indicate a 1, a voltage of
0 held for a number of samples

00:09:52.130 --> 00:09:53.910
to indicate a 0, and so on.

00:09:53.910 --> 00:09:54.410
OK?

00:09:54.410 --> 00:09:59.300
So this is the signal that you
want to get across the channel.

00:09:59.300 --> 00:10:00.890
And then at the other
end, that signal

00:10:00.890 --> 00:10:02.970
will get interpreted
as a string of bits.

00:10:02.970 --> 00:10:03.470
OK?

00:10:03.470 --> 00:10:04.910
When you do the
optimal detection

00:10:04.910 --> 00:10:08.520
that we talked about last time.

00:10:08.520 --> 00:10:11.480
So this link actually has--

00:10:11.480 --> 00:10:13.670
it's a very hybrid kind
of thing because you've

00:10:13.670 --> 00:10:17.400
got clock discrete time
stuff happening here.

00:10:17.400 --> 00:10:19.670
This is a digital-to-analog
converter,

00:10:19.670 --> 00:10:21.860
so you're going from
clock discrete time

00:10:21.860 --> 00:10:22.910
to continuous time.

00:10:22.910 --> 00:10:25.370
You typically have a
continuous analog channel.

00:10:25.370 --> 00:10:26.840
And then at this
end, again, back

00:10:26.840 --> 00:10:30.977
to discrete time, so
analog to digital.

00:10:30.977 --> 00:10:32.810
Digital, by the way,
we use that word a lot.

00:10:32.810 --> 00:10:35.660
What we typically mean is
something gets sampled,

00:10:35.660 --> 00:10:39.710
it's a discrete time signal, and
there's often the implication

00:10:39.710 --> 00:10:41.660
that it's quantized to
one of a set of levels.

00:10:41.660 --> 00:10:45.230
It's basically the signal
you'll deal with in a processor

00:10:45.230 --> 00:10:47.390
whereas all of this
is the signal that you

00:10:47.390 --> 00:10:51.160
deal with in the physics,
in the analog part.

00:10:51.160 --> 00:10:51.660
OK.

00:10:51.660 --> 00:10:54.350
Then you're back to
the screen time here.

00:10:54.350 --> 00:11:00.023
And actually, there are
two clocks even there

00:11:00.023 --> 00:11:01.940
because there's a
particular clock that drives

00:11:01.940 --> 00:11:03.440
all of this signal processing.

00:11:03.440 --> 00:11:05.870
But then when you come
to spitting out the bits,

00:11:05.870 --> 00:11:08.150
you're only going to spit
on one bit per bit slot.

00:11:08.150 --> 00:11:13.125
So you've got many
samples per bit slot,

00:11:13.125 --> 00:11:14.750
and then when you
come all the way out,

00:11:14.750 --> 00:11:17.780
you're only going to report
one number, a 1 or a 0

00:11:17.780 --> 00:11:18.750
per bit slot.

00:11:18.750 --> 00:11:19.250
OK?

00:11:19.250 --> 00:11:23.910
So there's all of this mixed
together in the system.

00:11:23.910 --> 00:11:24.410
All right.

00:11:24.410 --> 00:11:27.650
So let's look at the
particular case you're

00:11:27.650 --> 00:11:29.090
going to be seeing in lab.

00:11:29.090 --> 00:11:34.110
I put this up on the
slides last time as well.

00:11:34.110 --> 00:11:37.010
So we're going to talk
about the specific case

00:11:37.010 --> 00:11:39.590
of a channel that's just
an acoustic channel.

00:11:39.590 --> 00:11:41.990
So we're going to
have sound coming out

00:11:41.990 --> 00:11:44.840
of a loudspeaker, that's your
transmitter, sound getting

00:11:44.840 --> 00:11:47.720
picked up in a microphone, and
that's your receiver, and then

00:11:47.720 --> 00:11:49.020
all of the signal processing.

00:11:49.020 --> 00:11:49.520
OK?

00:11:49.520 --> 00:11:52.790
So labs four through
six are going

00:11:52.790 --> 00:11:54.140
to be centered around this.

00:11:58.160 --> 00:12:03.650
So the challenge then is taking
the digitized symbols there

00:12:03.650 --> 00:12:07.280
and putting them to
a physical channel.

00:12:07.280 --> 00:12:12.800
So what is it that
happens in between?

00:12:12.800 --> 00:12:15.440
Let's see.

00:12:15.440 --> 00:12:18.290
The D to A converter, we
don't say much about that,

00:12:18.290 --> 00:12:20.900
but a typical D
to A converter is

00:12:20.900 --> 00:12:25.100
taking a sequence of samples
which are just numbered

00:12:25.100 --> 00:12:28.970
and then converting the samples
to a continuous waveform, which

00:12:28.970 --> 00:12:30.040
is on a time axis.

00:12:30.040 --> 00:12:34.190
So a discrete time sequence is
typically on an integer axis,

00:12:34.190 --> 00:12:39.230
but we convert in a D to A
converter, what typically

00:12:39.230 --> 00:12:40.970
happens is that
you're converting this

00:12:40.970 --> 00:12:42.220
to a continuous time waveform.

00:12:42.220 --> 00:12:44.262
And the simplest way to
do that is through what's

00:12:44.262 --> 00:12:45.440
called a zero order hold.

00:12:45.440 --> 00:12:50.120
So you take the value here, hold
it for some interval of time,

00:12:50.120 --> 00:12:52.400
t seconds, and you
take the next value,

00:12:52.400 --> 00:12:54.903
you hold it for t
seconds and so on.

00:12:54.903 --> 00:12:56.570
And then when you get
a change in value,

00:12:56.570 --> 00:12:57.820
you change to the new value.

00:12:57.820 --> 00:13:03.390
So you would hold this here, and
then come down here, hold it.

00:13:03.390 --> 00:13:04.970
So at the end of
it, what you've done

00:13:04.970 --> 00:13:09.050
is convert a discrete time
sequence into a continuous time

00:13:09.050 --> 00:13:11.360
waveform that can then
be applied to something

00:13:11.360 --> 00:13:12.710
like the loudspeaker.

00:13:12.710 --> 00:13:13.400
Right?

00:13:13.400 --> 00:13:15.160
So you'll have to
specify in the D

00:13:15.160 --> 00:13:18.920
to A converter what your
reconstruction interval is.

00:13:18.920 --> 00:13:20.540
This kind of a D to
A converter would

00:13:20.540 --> 00:13:23.540
be called a zero order hold.

00:13:26.630 --> 00:13:29.480
Zero order because it just
looks at the most recent sample

00:13:29.480 --> 00:13:30.605
and holds it.

00:13:30.605 --> 00:13:33.500
A first order hold would
look at the last two samples

00:13:33.500 --> 00:13:35.010
and do a linear projection.

00:13:35.010 --> 00:13:36.740
So you can imagine
more elaborate ways

00:13:36.740 --> 00:13:40.260
of doing the
digital-to-analog conversion.

00:13:40.260 --> 00:13:43.550
So what I want you to imagine
is that when we get to the DAC

00:13:43.550 --> 00:13:46.530
finally, it's going to
be something like this.

00:13:46.530 --> 00:13:50.450
So all my pictures will be
discrete time sequences,

00:13:50.450 --> 00:13:54.147
and I won't say much
about what goes on here.

00:13:54.147 --> 00:13:55.730
So I want you to
imagine that whenever

00:13:55.730 --> 00:13:58.105
I have a sequence like this,
and then I end up putting it

00:13:58.105 --> 00:14:01.130
on the physical channel, there's
been a conversion of the state.

00:14:01.130 --> 00:14:03.200
OK?

00:14:03.200 --> 00:14:05.000
That's what you're
D do A card will do

00:14:05.000 --> 00:14:07.080
in the computer at this point.

00:14:07.080 --> 00:14:09.450
So you feed it a
bunch of numbers.

00:14:09.450 --> 00:14:11.760
You give it a sampling rate
or a reconstruction rate.

00:14:11.760 --> 00:14:16.130
And then it does this
kind of interpolation.

00:14:16.130 --> 00:14:16.630
OK.

00:14:19.590 --> 00:14:22.740
So let's see.

00:14:22.740 --> 00:14:25.170
Is this a good voltage
to put on a loudspeaker?

00:14:25.170 --> 00:14:28.980
If I wanted to signal a one
or a whole series of ones,

00:14:28.980 --> 00:14:32.700
do I want to put a constant
voltage on a loudspeaker?

00:14:32.700 --> 00:14:35.340
A loud speaker is not very happy
getting a DC voltage on it.

00:14:35.340 --> 00:14:36.270
Right?

00:14:36.270 --> 00:14:38.610
So the point is
here that you have

00:14:38.610 --> 00:14:41.010
to think about your
transmission medium

00:14:41.010 --> 00:14:43.200
and what its happiest
responding to.

00:14:43.200 --> 00:14:46.292
So you've got to adapt your
signal to the capabilities

00:14:46.292 --> 00:14:47.250
of the physical medium.

00:14:47.250 --> 00:14:50.010
And that's what modulation is
all about, or at least that's

00:14:50.010 --> 00:14:50.830
a key part of it.

00:14:50.830 --> 00:14:53.010
Another part of modulation,
we'll see later,

00:14:53.010 --> 00:14:58.110
is to allow you to have multiple
users share the same channel.

00:14:58.110 --> 00:15:02.130
But a big part of it is
just adapting your signal

00:15:02.130 --> 00:15:05.430
to a form that is
comfortable for the channel.

00:15:05.430 --> 00:15:13.080
So here's what you might try
in the case of the loudspeaker.

00:15:13.080 --> 00:15:16.410
So what you've got is
the acoustic channel.

00:15:16.410 --> 00:15:19.320
You would like to transmit
these two levels, v0 and v1,

00:15:19.320 --> 00:15:21.340
to represent the 0 and the 1.

00:15:21.340 --> 00:15:24.300
I'm just generalizing here.

00:15:24.300 --> 00:15:27.630
I'm just saying that there's
some level v0 that represents

00:15:27.630 --> 00:15:30.430
the 0 and there's
some level of v1,

00:15:30.430 --> 00:15:36.030
and I will allow you to pick
different possibilities here.

00:15:36.030 --> 00:15:38.640
So what's typically done is
instead of trying to transmit

00:15:38.640 --> 00:15:42.270
the DC, you transmit
a burst of a sinusoid

00:15:42.270 --> 00:15:44.923
because loud speakers
like sinusoids

00:15:44.923 --> 00:15:46.590
provided they're at
the right frequency.

00:15:46.590 --> 00:15:48.570
So again, you've got
to think about what

00:15:48.570 --> 00:15:50.950
frequency makes sense.

00:15:50.950 --> 00:15:54.120
It's this cone trying
to move a massive air

00:15:54.120 --> 00:15:56.190
to try to make a
massive air oscillate.

00:15:56.190 --> 00:15:59.220
There are particular frequencies
that are good for that,

00:15:59.220 --> 00:16:02.170
so you have to think about that.

00:16:02.170 --> 00:16:07.380
So you might, for instance, say
that you want sinusoidal bursts

00:16:07.380 --> 00:16:09.570
at two kilohertz,
and you're going

00:16:09.570 --> 00:16:10.990
to modulate the amplitude.

00:16:10.990 --> 00:16:17.430
So you'll send a burst v0 cosine
2 pi of ct to represent the 0,

00:16:17.430 --> 00:16:21.930
and you'll send a burst
of v1 cosine 2 pi of ct

00:16:21.930 --> 00:16:24.240
to represent the 1.

00:16:24.240 --> 00:16:29.920
So if it's simple on-off keying
that we've been talking about,

00:16:29.920 --> 00:16:32.880
you'll have v0 equals 0.

00:16:32.880 --> 00:16:35.460
In other words, you'll signal
a 0 by sending nothing out

00:16:35.460 --> 00:16:36.690
on the loudspeaker.

00:16:36.690 --> 00:16:38.700
And then when you
want to signal a 1,

00:16:38.700 --> 00:16:42.360
you'll have a cosine
of amplitude capital V.

00:16:42.360 --> 00:16:44.880
In the other case
here, what you do

00:16:44.880 --> 00:16:49.950
is you have minus v cosine going
out to signal a 0 and plus v

00:16:49.950 --> 00:16:51.990
cosine going out to signal a 1.

00:16:51.990 --> 00:16:55.410
So that's basically just a
180 degree change of phase.

00:16:55.410 --> 00:16:58.380
Every time you want to shift
from a 1 to a 0 or a 0 to a 1,

00:16:58.380 --> 00:17:01.320
you're going to change
the phase by 180 degrees.

00:17:01.320 --> 00:17:02.250
That changes the sign.

00:17:02.250 --> 00:17:02.785
Right?

00:17:02.785 --> 00:17:05.130
Because it's fixed amplitude,
and you step the phase

00:17:05.130 --> 00:17:07.810
each time you want to change.

00:17:07.810 --> 00:17:11.400
So this would be a
natural way to do it.

00:17:11.400 --> 00:17:12.660
Why two kilohertz?

00:17:12.660 --> 00:17:15.150
Well we know that this
is the kind of frequency

00:17:15.150 --> 00:17:17.339
that a loud speaker likes.

00:17:17.339 --> 00:17:20.045
And the more
general principle is

00:17:20.045 --> 00:17:21.420
whenever you're
trying to radiate

00:17:21.420 --> 00:17:24.119
energy, the size of the
antenna that you use,

00:17:24.119 --> 00:17:26.460
the antenna element
that you use,

00:17:26.460 --> 00:17:28.290
for efficient
transfer of power, has

00:17:28.290 --> 00:17:33.117
to be comparable with the
wavelength of the signal

00:17:33.117 --> 00:17:33.700
that you have.

00:17:33.700 --> 00:17:36.300
So for instance, if
you're talking about sound

00:17:36.300 --> 00:17:39.660
at two kilohertz, the
speed of sound and air

00:17:39.660 --> 00:17:41.580
at room temperature is
something on that order

00:17:41.580 --> 00:17:44.010
340 meters per second.

00:17:44.010 --> 00:17:47.550
If you do the computation
of the wavelength,

00:17:47.550 --> 00:17:49.090
and I always do
it with the units,

00:17:49.090 --> 00:17:51.150
so I may get it wrong here.

00:17:51.150 --> 00:17:58.710
But 340 meters per second,
and for wavelength,

00:17:58.710 --> 00:18:01.110
I know that I want the
answer to come out in meters.

00:18:01.110 --> 00:18:04.950
I've got two kilohertz,
so I've got to divide

00:18:04.950 --> 00:18:08.100
by 2000 per second.

00:18:08.100 --> 00:18:08.812
Right?

00:18:08.812 --> 00:18:10.770
That's the units of
frequency, and that's going

00:18:10.770 --> 00:18:12.580
to give me something in meters.

00:18:12.580 --> 00:18:15.600
And if I wanted to come
out in centimeters,

00:18:15.600 --> 00:18:18.750
then it's 340 divided
by 20, so that's 17.

00:18:18.750 --> 00:18:22.560
And, well, 17 is in the
ballpark for the dimensions

00:18:22.560 --> 00:18:23.588
of a speaker.

00:18:23.588 --> 00:18:26.130
You actually-- it depends on
the details of how this is done,

00:18:26.130 --> 00:18:28.530
but you might be
satisfied with a quarter

00:18:28.530 --> 00:18:31.380
wavelength of the transmission.

00:18:31.380 --> 00:18:35.190
Quarter wavelength of
17 is really very well

00:18:35.190 --> 00:18:38.760
within the range of what a
speaker might be on a laptop,

00:18:38.760 --> 00:18:41.320
depending on the size
of your laptop, I guess.

00:18:41.320 --> 00:18:41.820
OK.

00:18:41.820 --> 00:18:44.370
So all of this goes on
in trying to figure out

00:18:44.370 --> 00:18:47.280
how to modulate the
signal onto a channel.

00:18:51.220 --> 00:18:54.000
So these are instances, actually
the very simple instances,

00:18:54.000 --> 00:18:58.930
of what's called
amplitude modulation.

00:18:58.930 --> 00:19:00.440
Actually, in the
very first lecture,

00:19:00.440 --> 00:19:03.580
I mentioned when we were
trying to distinguish

00:19:03.580 --> 00:19:06.550
analog communication from
digital communication,

00:19:06.550 --> 00:19:10.330
I said that the typical analog
communication scheme might

00:19:10.330 --> 00:19:16.210
be AM, amplitude modulation,
where you take a carrier

00:19:16.210 --> 00:19:20.200
and you modulate its amplitude.

00:19:20.200 --> 00:19:22.630
And the amplitude is what
carries the information.

00:19:22.630 --> 00:19:26.770
So this would be something
of the type x of t

00:19:26.770 --> 00:19:30.280
cosine 2 pi of ct.

00:19:30.280 --> 00:19:30.800
All right.

00:19:30.800 --> 00:19:34.120
So it's a carrier,
which is a pure cosine,

00:19:34.120 --> 00:19:36.640
and you have an amplitude
that slowly varying.

00:19:36.640 --> 00:19:39.280
And it's the amplitude that
carries the information

00:19:39.280 --> 00:19:41.350
for the analog communication.

00:19:41.350 --> 00:19:42.910
So the receiver
what would be done

00:19:42.910 --> 00:19:46.525
is figure out some way of
extracting the envelope here.

00:19:46.525 --> 00:19:47.180
All right?

00:19:47.180 --> 00:19:49.270
That's classic AM.

00:19:49.270 --> 00:19:53.690
Ours is a very simple case
where we're saying rx of t

00:19:53.690 --> 00:19:57.730
is either 0 or v in the
case of on-off keying,

00:19:57.730 --> 00:20:03.880
or it's a minus v or plus v
in the case of bipolar keying.

00:20:03.880 --> 00:20:08.090
But it's still on the
AM kind of modulation.

00:20:08.090 --> 00:20:08.590
OK.

00:20:08.590 --> 00:20:11.500
So what I have up
here is actually just

00:20:11.500 --> 00:20:14.050
to remind you that this also
happened in the neighborhood

00:20:14.050 --> 00:20:14.550
here.

00:20:14.550 --> 00:20:19.660
This is Fessenden in 1906
is credited on Christmas Eve

00:20:19.660 --> 00:20:22.450
with making the first
voice transmission,

00:20:22.450 --> 00:20:26.650
wireless voice transmission,
as opposed to Morse

00:20:26.650 --> 00:20:30.080
code transmissions which
had been around for a while.

00:20:30.080 --> 00:20:32.290
And what was his oscillator?

00:20:32.290 --> 00:20:33.970
Well, what was his antenna?

00:20:33.970 --> 00:20:37.990
It was this 420 foot thing,
that's about, I think,

00:20:37.990 --> 00:20:39.145
about 120 meters.

00:20:42.080 --> 00:20:45.370
So if you actually put
in the speed of light,

00:20:45.370 --> 00:20:48.395
you'll see what
kind of antenna size

00:20:48.395 --> 00:20:50.020
you need, sorry, what
kind of frequency

00:20:50.020 --> 00:20:56.300
you need to excite this
with for the wavelength

00:20:56.300 --> 00:20:58.300
to be the comparable to
the size of the antenna.

00:20:58.300 --> 00:21:05.620
So let's see, 3 times 10
to the 8 is speed of light,

00:21:05.620 --> 00:21:11.920
and I've got an antenna
that's 120 meters.

00:21:11.920 --> 00:21:17.590
So let's say 10 to the 2,
so it's about 3 times 10

00:21:17.590 --> 00:21:24.180
to the 6 Hertz that I need
to be exciting this at.

00:21:24.180 --> 00:21:26.800
Well, he wasn't able to
get anywhere near that.

00:21:26.800 --> 00:21:28.750
He actually had this
big electrical machine

00:21:28.750 --> 00:21:33.317
that could generate a
sinusoid of about 50 kilohertz

00:21:33.317 --> 00:21:35.650
for which he'd have needed a
much taller antenna to have

00:21:35.650 --> 00:21:37.067
efficient transmission,
but it was

00:21:37.067 --> 00:21:39.190
enough for the signal
to be picked up

00:21:39.190 --> 00:21:41.017
a few kilometers away.

00:21:41.017 --> 00:21:42.850
And he claimed that it
was heard all the way

00:21:42.850 --> 00:21:44.800
down the coast of
Virginia and so on,

00:21:44.800 --> 00:21:46.780
but there's some
controversy about that.

00:21:46.780 --> 00:21:48.520
Anyway, he's credited
with developing

00:21:48.520 --> 00:21:51.250
a lot of the basic
technology for AM

00:21:51.250 --> 00:21:54.490
and for developing these
machines and all of that.

00:21:54.490 --> 00:21:57.760
I like the name of the
cocktail named in his honor

00:21:57.760 --> 00:22:01.150
by the city of Marshfield.

00:22:01.150 --> 00:22:03.940
Here's a picture of the
antenna from an old postcard.

00:22:03.940 --> 00:22:07.184
Looks very Cape Cod
and Marshfield-y.

00:22:09.850 --> 00:22:14.290
He had a companion, a
system built in Scotland,

00:22:14.290 --> 00:22:18.435
but a careless workman,
at one point, disconnected

00:22:18.435 --> 00:22:20.560
a particular cable that
was tying it to the ground,

00:22:20.560 --> 00:22:21.810
and the whole tower collapsed.

00:22:21.810 --> 00:22:26.450
So his transatlantic experiments
were set back for a while.

00:22:26.450 --> 00:22:26.950
OK.

00:22:26.950 --> 00:22:30.320
So how is this done?

00:22:30.320 --> 00:22:33.200
Well, for our setting,
it's actually quite easy.

00:22:33.200 --> 00:22:35.620
We've got our digitized
symbols coming out here.

00:22:35.620 --> 00:22:38.450
This is the x of n,
something like this

00:22:38.450 --> 00:22:41.110
if we're doing
bipolar signaling.

00:22:41.110 --> 00:22:43.250
And we're going to
multiply it by a cosine.

00:22:43.250 --> 00:22:45.970
So here's our cosine carrier.

00:22:45.970 --> 00:22:49.100
We'll use capital omega
to denote frequency

00:22:49.100 --> 00:22:51.910
in these discrete time signals.

00:22:51.910 --> 00:22:58.698
And I'm using angular
frequency, so this is 2 pi times

00:22:58.698 --> 00:23:01.240
whatever other frequency you're
used to thinking in terms of,

00:23:01.240 --> 00:23:04.360
but this is typical for
discrete time signals.

00:23:04.360 --> 00:23:05.900
And so this is
what it looks like.

00:23:05.900 --> 00:23:10.620
This is for the specific case
of the x event I showed earlier.

00:23:10.620 --> 00:23:14.210
So let me flip back
to show you that.

00:23:14.210 --> 00:23:14.970
This one.

00:23:14.970 --> 00:23:15.470
OK?

00:23:15.470 --> 00:23:19.080
So we're taking this waveform
and multiplying it by cosine.

00:23:19.080 --> 00:23:22.550
So what you're going to have is
a burst of cosine and then 0,

00:23:22.550 --> 00:23:24.800
then a longer burst
of cosine and then 0,

00:23:24.800 --> 00:23:26.700
and then a burst of
cosine and then 0,

00:23:26.700 --> 00:23:28.670
and then a burst
of cosine again.

00:23:28.670 --> 00:23:34.870
So that's what
we're seeing here.

00:23:34.870 --> 00:23:37.590
OK.

00:23:37.590 --> 00:23:40.180
A short burst of cosine.

00:23:40.180 --> 00:23:43.950
This is 16 samples long
and then 32 samples of 0

00:23:43.950 --> 00:23:49.880
and then 48 samples
of cosine and so on.

00:23:49.880 --> 00:23:50.380
All right?

00:23:50.380 --> 00:23:56.322
So your loudspeaker is emitting
power and then turning off

00:23:56.322 --> 00:23:57.780
and emitting power
and turning off,

00:23:57.780 --> 00:23:59.863
and this is what gets
picked up by the microphone.

00:23:59.863 --> 00:24:02.400
So the microphone
has to figure out--

00:24:02.400 --> 00:24:05.130
this is the particular case
of an on-off signaling scheme.

00:24:05.130 --> 00:24:09.810
So the microphone has to
figure out what's being sent.

00:24:09.810 --> 00:24:10.390
OK.

00:24:10.390 --> 00:24:15.750
So any particular thoughts on
how you might recover things

00:24:15.750 --> 00:24:20.190
at the receiving end?

00:24:20.190 --> 00:24:22.860
So what I'm not
showing you is the D

00:24:22.860 --> 00:24:26.010
to A converter, which is
going to take this thing

00:24:26.010 --> 00:24:31.610
and interpolate these points and
put it out on real time access

00:24:31.610 --> 00:24:32.860
and put it out on the channel.

00:24:32.860 --> 00:24:33.360
OK?

00:24:33.360 --> 00:24:36.090
I'm imagining all of this
kind of stuff going on,

00:24:36.090 --> 00:24:38.635
but we're just going to
look from discrete signal

00:24:38.635 --> 00:24:40.260
to discrete signals,
so I'm suppressing

00:24:40.260 --> 00:24:42.420
all the stuff in between.

00:24:42.420 --> 00:24:45.660
So at the other
end, you somehow--

00:24:45.660 --> 00:24:47.880
let me assume there was no
distortion on the channel,

00:24:47.880 --> 00:24:50.940
and you figured out a way to
get exactly this after sampling

00:24:50.940 --> 00:24:52.320
at the receiving end.

00:24:52.320 --> 00:24:57.210
If you got the signal,
what might you do to it

00:24:57.210 --> 00:24:59.100
to recover those 0 and 1?

00:24:59.100 --> 00:25:00.900
Any particular ideas?

00:25:00.900 --> 00:25:03.600
If you had to write an
algorithm to do that?

00:25:03.600 --> 00:25:07.440
So I'm saying imagine no
distortion on your channel.

00:25:07.440 --> 00:25:09.180
You hear a sound
on your microphone,

00:25:09.180 --> 00:25:12.060
you take samples of it,
you get a signal like this,

00:25:12.060 --> 00:25:15.260
and now you've got to decode.

00:25:15.260 --> 00:25:15.870
Anything?

00:25:15.870 --> 00:25:17.300
It ought to be pretty simple.

00:25:17.300 --> 00:25:17.810
Right?

00:25:17.810 --> 00:25:18.606
Yeah.

00:25:18.606 --> 00:25:21.086
STUDENT: Take the absolute
value [INAUDIBLE]..

00:25:24.465 --> 00:25:25.840
PROFESSOR: OK,
yeah, I like that.

00:25:25.840 --> 00:25:27.215
So let's take the
absolute value.

00:25:31.440 --> 00:25:34.810
So you might get
something like this.

00:25:34.810 --> 00:25:44.480
And then there's a gap, and then
you get something like this,

00:25:44.480 --> 00:25:45.160
and so on.

00:25:45.160 --> 00:25:45.842
Right?

00:25:45.842 --> 00:25:47.800
I'm drawing these as
though they're continuous,

00:25:47.800 --> 00:25:52.180
but actually, what you're
getting is a bunch of samples.

00:25:52.180 --> 00:25:56.980
And these are supposed to
be sections of sinusoid.

00:25:56.980 --> 00:26:02.140
This is what we call
a rectified sinusoid.

00:26:05.830 --> 00:26:08.650
The electrical
engineers say rectified,

00:26:08.650 --> 00:26:10.450
it's just taking
the absolute value.

00:26:10.450 --> 00:26:11.175
Right?

00:26:11.175 --> 00:26:13.300
Once you have this, you're
probably in better shape

00:26:13.300 --> 00:26:16.570
to try and figure out
where there is signal

00:26:16.570 --> 00:26:18.035
and where there is not.

00:26:18.035 --> 00:26:18.910
So what could you do?

00:26:18.910 --> 00:26:21.730
What might you try doing?

00:26:21.730 --> 00:26:22.240
Felix?

00:26:22.240 --> 00:26:23.350
You want to continue?

00:26:23.350 --> 00:26:24.563
What's the next step?

00:26:24.563 --> 00:26:31.837
STUDENT: So you can take the
moving maximum [INAUDIBLE]??

00:26:31.837 --> 00:26:32.420
PROFESSOR: OK.

00:26:32.420 --> 00:26:36.120
So you're saying, let's
have a sliding window

00:26:36.120 --> 00:26:39.320
of some kind that looks to
see how much of the signal

00:26:39.320 --> 00:26:41.582
is in there.

00:26:41.582 --> 00:26:43.700
Is there any window
size that will actually

00:26:43.700 --> 00:26:46.280
give you a constant signal if
you're in the body of this?

00:26:50.468 --> 00:26:52.760
I mean, if you took a window
that was equal to a period

00:26:52.760 --> 00:26:53.790
here, this is periodic.

00:26:53.790 --> 00:26:54.290
Right?

00:26:54.290 --> 00:26:57.210
While the sinusoid is
ringing, its periodic.

00:26:57.210 --> 00:26:59.400
So if you took a
window of this size

00:26:59.400 --> 00:27:02.160
and then slid it along, at
least in the body of this,

00:27:02.160 --> 00:27:04.700
you're going to get a
constant because you're

00:27:04.700 --> 00:27:08.120
picking up the average value
of the rectified sinusoid.

00:27:08.120 --> 00:27:09.620
And then near the
ends, you're going

00:27:09.620 --> 00:27:13.008
to get some effects
whatever they are.

00:27:13.008 --> 00:27:14.550
But that should be
enough to give you

00:27:14.550 --> 00:27:15.750
a good stretch of signal.

00:27:15.750 --> 00:27:18.150
And again, you're not getting
a continuous green thing,

00:27:18.150 --> 00:27:19.800
you're actually getting samples.

00:27:19.800 --> 00:27:20.850
Right?

00:27:20.850 --> 00:27:22.320
But that should
be enough to help

00:27:22.320 --> 00:27:25.800
you figure out where you have
zeros and where you have ones.

00:27:25.800 --> 00:27:29.160
So very simple.

00:27:29.160 --> 00:27:32.400
What if we have
a bipolar scheme?

00:27:32.400 --> 00:27:38.010
Suppose we have a signal
that can be plus or minus.

00:27:38.010 --> 00:27:40.440
And so what we have
is not this, but we

00:27:40.440 --> 00:27:45.000
have a phase change every
time we go from a 1 to 0.

00:27:45.000 --> 00:27:47.237
Then, if you take
the absolute value,

00:27:47.237 --> 00:27:48.570
you've lost all the information.

00:27:48.570 --> 00:27:49.350
Right?

00:27:49.350 --> 00:27:52.940
So we've got to figure
out something else.

00:27:52.940 --> 00:27:53.440
OK.

00:27:53.440 --> 00:27:56.620
So the more general
way to do this,

00:27:56.620 --> 00:27:59.110
for instance, for the case
where you have the bipolar

00:27:59.110 --> 00:28:02.530
transmission, is--

00:28:02.530 --> 00:28:05.088
well, this is actually just to--

00:28:05.088 --> 00:28:07.130
it turns out that I had
the same idea as you did,

00:28:07.130 --> 00:28:09.100
which was take
absolute value and then

00:28:09.100 --> 00:28:11.180
a local average
over a half period.

00:28:11.180 --> 00:28:12.610
It's a very natural
thing to think

00:28:12.610 --> 00:28:15.010
of as a way to extract that.

00:28:15.010 --> 00:28:20.710
That works for the on-off
signaling, but for the bipolar,

00:28:20.710 --> 00:28:22.270
it's a little trickier.

00:28:22.270 --> 00:28:25.810
So here's what a typical
general demodulation

00:28:25.810 --> 00:28:29.920
scheme is for amplitude
modulated signals.

00:28:29.920 --> 00:28:31.480
Here's the transmitted signal.

00:28:31.480 --> 00:28:32.680
It's been received.

00:28:32.680 --> 00:28:36.278
I've converted it from
analog to digital and so on.

00:28:36.278 --> 00:28:37.820
I'm going to do the
same thing again.

00:28:37.820 --> 00:28:40.480
I'm going to multiply
it locally by a cosine

00:28:40.480 --> 00:28:42.470
at the same frequency.

00:28:42.470 --> 00:28:44.980
So I have a local
oscillator at my receiver

00:28:44.980 --> 00:28:48.760
that's got the same frequency
as the carrier frequency that

00:28:48.760 --> 00:28:50.230
was used for transmission.

00:28:50.230 --> 00:28:52.000
OK?

00:28:52.000 --> 00:28:54.850
When you tune your radio
on AM, what you're doing

00:28:54.850 --> 00:28:58.390
is actually adjusting the
local oscillator frequency

00:28:58.390 --> 00:29:04.570
to match that of the
station frequency.

00:29:04.570 --> 00:29:05.180
OK.

00:29:05.180 --> 00:29:06.847
And the station
frequencies, by the way,

00:29:06.847 --> 00:29:10.080
should be obvious by now
when you have, what is it,

00:29:10.080 --> 00:29:13.690
820 AM or whatever,
what they're announcing

00:29:13.690 --> 00:29:15.258
is the frequency
of their carrier.

00:29:15.258 --> 00:29:16.300
That's how they're known.

00:29:16.300 --> 00:29:18.950
They're known by the
frequency of the carrier.

00:29:18.950 --> 00:29:19.450
OK.

00:29:19.450 --> 00:29:21.040
So here's what the result is.

00:29:21.040 --> 00:29:24.460
You've got the signal
that you transmitted

00:29:24.460 --> 00:29:27.430
multiplied by the cosine.

00:29:27.430 --> 00:29:29.830
What's the signal
that you transmitted?

00:29:29.830 --> 00:29:33.310
Well it was the signal
you wanted to get across

00:29:33.310 --> 00:29:38.870
but multiplied by the carrier
at the transmitting end.

00:29:38.870 --> 00:29:39.370
OK.

00:29:39.370 --> 00:29:42.370
You've got the
cosine squared there.

00:29:42.370 --> 00:29:46.690
We have a standard identity
for cosine squared.

00:29:46.690 --> 00:29:50.650
That's half of 1 plus
cosine twice the angle.

00:29:50.650 --> 00:29:51.478
Right?

00:29:51.478 --> 00:29:52.434
Yeah?

00:29:52.434 --> 00:29:57.377
STUDENT: What if you're
given a phase shift?

00:29:57.377 --> 00:29:58.210
PROFESSOR: OK, yeah.

00:29:58.210 --> 00:29:58.790
Good question.

00:29:58.790 --> 00:30:00.850
The question is what if you
have a phase shift because this

00:30:00.850 --> 00:30:02.933
assumes not just that you
have the right frequency

00:30:02.933 --> 00:30:04.810
but that you have
exactly the right phase.

00:30:04.810 --> 00:30:06.707
And it turns out
that that's something

00:30:06.707 --> 00:30:07.790
that has to be dealt with.

00:30:07.790 --> 00:30:09.520
So there are mechanisms
for doing that.

00:30:09.520 --> 00:30:11.320
So basically, what
you end up doing

00:30:11.320 --> 00:30:15.400
in one way of tackling that
is you multiply by cosine,

00:30:15.400 --> 00:30:16.802
you multiply by a sine.

00:30:16.802 --> 00:30:18.760
And by looking at the
outputs of both of those,

00:30:18.760 --> 00:30:21.610
you can actually figure out
what the right phase shift is.

00:30:21.610 --> 00:30:23.253
So that's a good question.

00:30:23.253 --> 00:30:24.670
It's not just phase
shift, there's

00:30:24.670 --> 00:30:26.800
also time delays and
propagation and so on,

00:30:26.800 --> 00:30:28.180
so it's a real issue.

00:30:28.180 --> 00:30:31.410
But let's just deal with
the simplest case for now.

00:30:31.410 --> 00:30:31.910
OK.

00:30:31.910 --> 00:30:34.270
So what you have after the
multiplication is something

00:30:34.270 --> 00:30:36.460
that actually has the
signal you're interested in,

00:30:36.460 --> 00:30:40.398
that first part, just scaled
by a factor of a half,

00:30:40.398 --> 00:30:42.440
and then it's got some
stuff that you don't want.

00:30:42.440 --> 00:30:44.950
It's got a double
frequency component which

00:30:44.950 --> 00:30:46.875
you have to try and get rid of.

00:30:46.875 --> 00:30:48.250
But the nice thing
here is if you

00:30:48.250 --> 00:30:50.620
were able to get rid of the
double frequency component,

00:30:50.620 --> 00:30:53.050
then you have x of n
there whether or not

00:30:53.050 --> 00:30:54.070
it's plus or minus.

00:30:54.070 --> 00:30:55.550
So the sign is not lost.

00:30:55.550 --> 00:30:58.630
It's not the absolute value of
x anymore that we're recovering,

00:30:58.630 --> 00:30:59.980
it's the actual x.

00:30:59.980 --> 00:31:01.790
So your x can go
positive or negative,

00:31:01.790 --> 00:31:02.890
and you'll pull it out.

00:31:02.890 --> 00:31:03.390
OK?

00:31:03.390 --> 00:31:06.460
So this is better than just
taking the absolute value

00:31:06.460 --> 00:31:09.610
and doing a local filtering.

00:31:09.610 --> 00:31:10.150
OK.

00:31:10.150 --> 00:31:16.600
So here's what that looks like
for the particular example

00:31:16.600 --> 00:31:17.100
we have.

00:31:20.040 --> 00:31:25.800
So you can see the double
frequency cosine over here,

00:31:25.800 --> 00:31:29.970
and then the average value
that that cosine is riding on

00:31:29.970 --> 00:31:35.480
is going between 1 and 0
in this particular case.

00:31:35.480 --> 00:31:36.000
OK?

00:31:36.000 --> 00:31:38.370
So this was a 0-1 waveform
that we transmitted,

00:31:38.370 --> 00:31:41.580
but we're demodulating
it using a scheme that

00:31:41.580 --> 00:31:43.980
could have actually handled
a signal that went negative

00:31:43.980 --> 00:31:44.610
as well.

00:31:44.610 --> 00:31:48.060
But this example doesn't have
a signal that goes negative.

00:31:48.060 --> 00:31:50.650
It was the one that
I showed you earlier.

00:31:50.650 --> 00:31:53.910
But you can see that the average
value here is picking out

00:31:53.910 --> 00:31:55.530
exactly what you want.

00:31:55.530 --> 00:31:57.060
So your challenge
now is to get rid

00:31:57.060 --> 00:32:00.660
of the double frequency piece.

00:32:00.660 --> 00:32:03.180
So does someone want to
suggest to me how you

00:32:03.180 --> 00:32:04.540
might do that computationally?

00:32:04.540 --> 00:32:05.130
Yeah.

00:32:05.130 --> 00:32:05.880
STUDENT: Question.

00:32:05.880 --> 00:32:06.547
PROFESSOR: Yeah.

00:32:06.547 --> 00:32:09.410
STUDENT: If you wanted to extend
[INAUDIBLE] by extra sign,

00:32:09.410 --> 00:32:13.990
why don't we want to
multiply by it again?

00:32:13.990 --> 00:32:16.700
PROFESSOR: Oh, I see
what you're saying.

00:32:16.700 --> 00:32:21.460
What you're saying is, we could
have done this more simply

00:32:21.460 --> 00:32:23.400
if what came in--
that's a good question.

00:32:26.810 --> 00:32:28.490
We could just
divide by the cosine

00:32:28.490 --> 00:32:31.988
here and get what we want
because what went down

00:32:31.988 --> 00:32:33.530
was the transmitted
times the cosine.

00:32:33.530 --> 00:32:35.630
I never thought of that.

00:32:35.630 --> 00:32:39.195
Could there be a
problem with it?

00:32:39.195 --> 00:32:41.140
STUDENT: Maybe if
cosine has a value of 0.

00:32:41.140 --> 00:32:41.807
PROFESSOR: Yeah.

00:32:41.807 --> 00:32:45.340
So you see the point is that
the cosine has multiple zero

00:32:45.340 --> 00:32:45.940
crossings.

00:32:45.940 --> 00:32:48.148
And in the discrete
time case, of course,

00:32:48.148 --> 00:32:49.690
it depends on what
that frequency is.

00:32:49.690 --> 00:32:52.360
You might not go
exactly through 0.

00:32:52.360 --> 00:32:55.480
But then you're going to be
horrendously sensitive to noise

00:32:55.480 --> 00:32:57.500
and other things in the system.

00:32:57.500 --> 00:32:59.530
So that's a good thought.

00:32:59.530 --> 00:33:03.520
It's like in the Viterbi case,
by the way, if you're not

00:33:03.520 --> 00:33:06.130
thinking of noise, then
the very simple ways

00:33:06.130 --> 00:33:09.160
to combine the parity
stream to recover the input.

00:33:09.160 --> 00:33:12.020
But as soon as there's some
noise, all of this falls apart.

00:33:12.020 --> 00:33:15.750
So the scheme is robust
up to a point to noise.

00:33:15.750 --> 00:33:17.250
I mean, only up to
a point, you know

00:33:17.250 --> 00:33:18.833
if you've listened
to AM radio that it

00:33:18.833 --> 00:33:24.170
can get annoyingly noisy,
but up to a point, it's fine.

00:33:24.170 --> 00:33:24.670
OK.

00:33:24.670 --> 00:33:27.250
So we were here,
and I was asking,

00:33:27.250 --> 00:33:29.800
how might you get rid of that
double frequency component?

00:33:29.800 --> 00:33:30.497
Any ideas?

00:33:30.497 --> 00:33:32.080
Someone who hasn't
spoken today maybe?

00:33:36.990 --> 00:33:39.608
I want to do some filtering
operation on this.

00:33:39.608 --> 00:33:41.400
I want to run some
algorithm on this that's

00:33:41.400 --> 00:33:43.920
going to eliminate the
double frequency piece

00:33:43.920 --> 00:33:46.710
and just get me the
nice waveform back.

00:33:46.710 --> 00:33:47.500
Yeah.

00:33:47.500 --> 00:33:48.480
STUDENT: You can
do the same thing.

00:33:48.480 --> 00:33:49.990
PROFESSOR: I can
do the same thing.

00:33:49.990 --> 00:33:50.490
OK.

00:33:50.490 --> 00:33:55.185
So what interval
would I pick then?

00:33:55.185 --> 00:33:57.256
STUDENT: It would be not
the double frequency,

00:33:57.256 --> 00:33:58.594
the single frequency.

00:33:58.594 --> 00:33:59.177
PROFESSOR: OK.

00:33:59.177 --> 00:34:03.210
I could get away
with, let's see,

00:34:03.210 --> 00:34:07.180
I could get away with the
period of the double frequency.

00:34:07.180 --> 00:34:08.650
Right.

00:34:08.650 --> 00:34:12.159
If it was equal to the period of
the double frequency component,

00:34:12.159 --> 00:34:15.380
then as if I take the
average with that,

00:34:15.380 --> 00:34:18.330
then I've got a full cycle of
the double frequency component,

00:34:18.330 --> 00:34:19.330
and it will go off to 0.

00:34:19.330 --> 00:34:19.929
Right?

00:34:19.929 --> 00:34:21.320
So that's what I need to do.

00:34:21.320 --> 00:34:25.070
And that's the
simplest way to do it.

00:34:25.070 --> 00:34:28.179
So the filter here,
the simplest one,

00:34:28.179 --> 00:34:33.580
just puts out a signal that sums
L plus 1 of these values where

00:34:33.580 --> 00:34:34.570
L plus 1 is 8.

00:34:34.570 --> 00:34:37.870
That's exactly the period of
the double frequency component.

00:34:37.870 --> 00:34:40.780
Remember, we had 16 samples
for the original carrier,

00:34:40.780 --> 00:34:44.199
so double frequency
component has a period of 8.

00:34:44.199 --> 00:34:49.750
And so the 2 omega
piece gets eliminated,

00:34:49.750 --> 00:34:52.460
and here's what we get.

00:34:52.460 --> 00:34:52.960
OK.

00:34:52.960 --> 00:34:55.420
So there's some
transition at the ends

00:34:55.420 --> 00:34:59.110
because when you get to the
ends of something like this,

00:34:59.110 --> 00:35:01.480
and you're doing the
averaging, well, now you've

00:35:01.480 --> 00:35:03.788
got a little bit of
the previous bits

00:35:03.788 --> 00:35:05.830
worth and a little bit of
the current bits worth,

00:35:05.830 --> 00:35:07.330
so there's going
to be a transition.

00:35:07.330 --> 00:35:09.520
But it'll still leave
you with plenty of room

00:35:09.520 --> 00:35:14.170
in which to make your
decision as to what you have.

00:35:14.170 --> 00:35:16.810
OK.

00:35:16.810 --> 00:35:20.422
So now what I want to do
for the rest of the lecture,

00:35:20.422 --> 00:35:21.880
and we're going to
continue is well

00:35:21.880 --> 00:35:26.740
into the next few lectures,
is say we've understood,

00:35:26.740 --> 00:35:28.570
at least at some
level, how you might

00:35:28.570 --> 00:35:31.030
get across the analog channel.

00:35:31.030 --> 00:35:35.570
So let's now just focus
on input to output here.

00:35:35.570 --> 00:35:38.260
So we've got a discrete
time signal here,

00:35:38.260 --> 00:35:41.170
and I get a discrete time
signal coming out there.

00:35:41.170 --> 00:35:44.380
And I can think of that as
my channel input and output.

00:35:44.380 --> 00:35:46.570
I can suppress all
this other stuff.

00:35:46.570 --> 00:35:48.240
Knowing that all
of that goes on,

00:35:48.240 --> 00:35:49.900
but in terms of
my designing what

00:35:49.900 --> 00:35:53.950
I want to do with the signals, I
can just look at it end-to-end.

00:35:53.950 --> 00:35:58.990
So we're going to talk about
models for end-to-end behavior

00:35:58.990 --> 00:36:00.700
from the discrete
time sequence that

00:36:00.700 --> 00:36:03.280
goes in to the
discrete time sequence

00:36:03.280 --> 00:36:05.570
that you reconstruct
at the other end.

00:36:05.570 --> 00:36:06.070
OK?

00:36:11.070 --> 00:36:14.430
So abstractly, what we
have is some system,

00:36:14.430 --> 00:36:19.660
S. We've got an input
sequence, an output sequence.

00:36:19.660 --> 00:36:22.770
And this is typically how
these things are drawn.

00:36:22.770 --> 00:36:24.600
I just want to
caution you on this.

00:36:24.600 --> 00:36:27.300
When you see a
diagram like this,

00:36:27.300 --> 00:36:29.010
you want to think
of it as a snapshot

00:36:29.010 --> 00:36:30.750
of the system at a time n.

00:36:30.750 --> 00:36:32.610
You don't want to
think of it as saying

00:36:32.610 --> 00:36:36.780
that the value of y at the
output at some particular time

00:36:36.780 --> 00:36:41.260
n is determined by the value
of x at that same time n.

00:36:41.260 --> 00:36:41.760
OK?

00:36:41.760 --> 00:36:46.500
So the real story is that,
in general for such systems,

00:36:46.500 --> 00:36:50.220
the value of the output
at any particular time n

00:36:50.220 --> 00:36:56.280
is determined by all the
input values of the input.

00:36:56.280 --> 00:36:58.110
If it's a causal
system, then it only

00:36:58.110 --> 00:37:00.330
depends on the present
and past inputs.

00:37:00.330 --> 00:37:03.510
But in some settings, you can
think about non-causal kind

00:37:03.510 --> 00:37:04.690
of processing.

00:37:04.690 --> 00:37:06.930
So in general, when you
see a picture like this,

00:37:06.930 --> 00:37:09.630
think of it as a snapshot
of the system at time n.

00:37:09.630 --> 00:37:12.510
But it's not telling you
that x and that one value

00:37:12.510 --> 00:37:14.520
gets mapped to yn
that one value.

00:37:14.520 --> 00:37:16.370
That's not what's happening.

00:37:16.370 --> 00:37:19.380
I'm a little fuzzy about
this because, often, that's

00:37:19.380 --> 00:37:22.155
glossed over, and then
it leads to confusion.

00:37:22.155 --> 00:37:23.530
So more, generally,
if I want you

00:37:23.530 --> 00:37:25.890
to be thinking of the
signal as a whole,

00:37:25.890 --> 00:37:27.145
I'll use this notation.

00:37:27.145 --> 00:37:29.520
I'll just put a dot there to
say it's the entire waveform

00:37:29.520 --> 00:37:34.140
that I'm referring to because
I don't want you to fixate

00:37:34.140 --> 00:37:35.920
on a particular time instant.

00:37:35.920 --> 00:37:36.420
OK.

00:37:36.420 --> 00:37:38.740
So that's our system.

00:37:38.740 --> 00:37:41.430
Here's a little more
fussing about notation,

00:37:41.430 --> 00:37:43.560
but I don't think I want
to bother with that now.

00:37:43.560 --> 00:37:46.630
Please look at it when
you review the slides.

00:37:46.630 --> 00:37:49.025
Let's go to talking about
some particular signals,

00:37:49.025 --> 00:37:50.400
and these may be
ones you've seen

00:37:50.400 --> 00:37:54.870
in 601 is convenient
signals to talk about.

00:37:54.870 --> 00:37:57.850
We'll do a lot with
unit step functions.

00:37:57.850 --> 00:37:59.260
So these are signals.

00:37:59.260 --> 00:38:03.960
This is a signal that is
0 for all negative time.

00:38:03.960 --> 00:38:06.750
And then at time 0, it
goes up to the value 1

00:38:06.750 --> 00:38:07.780
and then stays at 1.

00:38:07.780 --> 00:38:09.360
So that's the unit step.

00:38:09.360 --> 00:38:11.700
And our standard notation
for it is u of n.

00:38:11.700 --> 00:38:16.740
So when you see u of n, that's
what you want to imagine.

00:38:16.740 --> 00:38:19.890
And u of n minus
3 then, well, this

00:38:19.890 --> 00:38:24.290
will have the same value at
n equals 3 that this had at n

00:38:24.290 --> 00:38:25.140
equals 0.

00:38:25.140 --> 00:38:28.200
So the point of transition
for this waveform must be at n

00:38:28.200 --> 00:38:29.080
equals 3.

00:38:29.080 --> 00:38:29.580
OK?

00:38:29.580 --> 00:38:33.180
So it's the same signal
but just delayed by 3.

00:38:33.180 --> 00:38:38.260
So u of n minus 3 just has
it step three instance later.

00:38:41.040 --> 00:38:45.480
Here's another very special
signal that we use a lot.

00:38:45.480 --> 00:38:48.810
It's what's called the unit
sample function or unit sample

00:38:48.810 --> 00:38:50.350
signal.

00:38:50.350 --> 00:38:51.540
So it's an entire signal.

00:38:51.540 --> 00:38:54.060
It's not just one value,
it's signal denoted

00:38:54.060 --> 00:38:56.340
by the symbol delta of n.

00:38:56.340 --> 00:38:59.220
It's 0 for all positive
and negative time.

00:38:59.220 --> 00:39:01.350
But at time 0, it
has the value 1.

00:39:01.350 --> 00:39:03.970
So that's the unit sample.

00:39:03.970 --> 00:39:07.380
And so if you had, for
instance, delta of n plus 5,

00:39:07.380 --> 00:39:09.570
it's the shifted version
of that function.

00:39:09.570 --> 00:39:13.830
And what happened that n equals
0 here will now happen at n

00:39:13.830 --> 00:39:15.060
equals minus 5.

00:39:15.060 --> 00:39:19.470
In other words, the spike up
there is at n equals minus 5.

00:39:19.470 --> 00:39:22.470
So we're going to need to get
comfortable with unit step

00:39:22.470 --> 00:39:24.720
functions and their shifted
versions and the unit

00:39:24.720 --> 00:39:27.390
sample functions and
their shifted versions.

00:39:30.130 --> 00:39:30.630
OK.

00:39:30.630 --> 00:39:32.890
And there's a relation
between the two as well.

00:39:32.890 --> 00:39:36.240
So you should see fairly
clearly that you can actually

00:39:36.240 --> 00:39:40.590
write the unit sample function
as a difference of a unit

00:39:40.590 --> 00:39:42.490
step and a delayed unit step.

00:39:42.490 --> 00:39:44.310
OK?

00:39:44.310 --> 00:39:47.220
Now, we can do standard
algebraic operations

00:39:47.220 --> 00:39:47.890
on signals.

00:39:47.890 --> 00:39:49.500
So I can take a
unit step function.

00:39:52.470 --> 00:39:58.920
I can do things like u of n
plus 3 times u of n minus 7.

00:39:58.920 --> 00:40:02.940
And what this means is
draw the signal u of n.

00:40:02.940 --> 00:40:06.750
Draw the signal 3 times u
of n minus 7, which is just

00:40:06.750 --> 00:40:09.690
u of n minus 7, each
value scaled by 3,

00:40:09.690 --> 00:40:11.700
and then just add them
instant by instant.

00:40:11.700 --> 00:40:14.880
So it's the most natural
way of adding signals.

00:40:14.880 --> 00:40:19.440
It's exactly what you would do
if you're adding or multiplying

00:40:19.440 --> 00:40:22.500
the functions of continuous
time from your calculus course.

00:40:22.500 --> 00:40:23.710
It's the same idea.

00:40:23.710 --> 00:40:26.220
So we can do all of these
algebraic operations.

00:40:30.850 --> 00:40:34.900
Now, the response of a system
to the unit step or the unit

00:40:34.900 --> 00:40:37.483
sample is interesting.

00:40:37.483 --> 00:40:39.400
It's not interesting for
all sorts of systems,

00:40:39.400 --> 00:40:42.130
but it's interesting
for the class of systems

00:40:42.130 --> 00:40:43.970
that we'll be focusing on.

00:40:43.970 --> 00:40:45.620
So let's talk about that.

00:40:45.620 --> 00:40:47.830
So the unit sample
response of a system

00:40:47.830 --> 00:40:51.580
is just the output signal
that you get when the input

00:40:51.580 --> 00:40:53.020
signal is the unit sample.

00:40:53.020 --> 00:40:54.010
OK?

00:40:54.010 --> 00:40:56.813
This is the traditional
symbol for it, h of n.

00:40:56.813 --> 00:40:58.480
So when you see h of
n, you're typically

00:40:58.480 --> 00:41:02.570
thinking of unit
sample response.

00:41:02.570 --> 00:41:06.490
Similarly, the unit step
response, put in a unit step.

00:41:06.490 --> 00:41:07.960
The signal that
you have the output

00:41:07.960 --> 00:41:11.800
is the unit step response, and
we'll use the symbol s of n

00:41:11.800 --> 00:41:12.370
for that.

00:41:17.420 --> 00:41:21.260
So the reason that these
are useful in many contexts

00:41:21.260 --> 00:41:24.600
is that you can take a
general signal, for instance,

00:41:24.600 --> 00:41:26.510
the one at the top
there and represent it

00:41:26.510 --> 00:41:32.340
as a weighted sum of scaled and
shifted unit sample functions.

00:41:32.340 --> 00:41:32.840
OK?

00:41:32.840 --> 00:41:35.330
So this is just saying I
can think of this function

00:41:35.330 --> 00:41:40.670
as being advanced unit
samples scaled by something

00:41:40.670 --> 00:41:42.830
and another one scaled
by something else

00:41:42.830 --> 00:41:45.740
and another one scaled by
something else and so on.

00:41:45.740 --> 00:41:48.300
Here is the analytical
expression that goes with that.

00:41:48.300 --> 00:41:51.230
So any signal can be
thought of as being made up

00:41:51.230 --> 00:41:53.900
of a bunch of unit samples
appropriately scaled

00:41:53.900 --> 00:41:56.630
and appropriately delayed.

00:41:56.630 --> 00:41:58.160
The same thing with
the unit steps.

00:42:01.770 --> 00:42:03.770
And these are waveforms,
as you've seen.

00:42:03.770 --> 00:42:05.300
This is the kind
of waveform we work

00:42:05.300 --> 00:42:07.170
with a lot in the
context of communication.

00:42:07.170 --> 00:42:10.910
So we've got these sorts
of rectangular waveforms.

00:42:10.910 --> 00:42:14.270
And it's very useful to think
of them as being combinations

00:42:14.270 --> 00:42:15.560
of unit steps.

00:42:15.560 --> 00:42:17.480
So the waveform
at the top can be

00:42:17.480 --> 00:42:21.920
generated by having a unit
step at this time climbing up.

00:42:21.920 --> 00:42:24.020
And then I've got to
calculate its effect

00:42:24.020 --> 00:42:29.240
on this next transition, so I
put a negative going unit step.

00:42:29.240 --> 00:42:31.470
And I want to bring it
back up again at that time,

00:42:31.470 --> 00:42:33.810
so I put another
unit step and so on.

00:42:33.810 --> 00:42:36.890
So you can synthesize
a signal of this type

00:42:36.890 --> 00:42:42.930
as a linear combination of
unit steps scaled and delayed.

00:42:42.930 --> 00:42:46.620
Now, this is actually
important when

00:42:46.620 --> 00:42:48.960
you get to particular classes
of systems for which you

00:42:48.960 --> 00:42:50.730
can exploit these properties.

00:42:50.730 --> 00:42:53.430
So let me tell you
what linearity is

00:42:53.430 --> 00:42:57.528
and what time invariance is,
because the rest of our talk

00:42:57.528 --> 00:42:59.820
about systems is going to be
focused on linear and time

00:42:59.820 --> 00:43:01.570
invariant systems.

00:43:01.570 --> 00:43:05.400
So let's start with what a
time invariant system is.

00:43:05.400 --> 00:43:08.880
It's just a system whose
response to a given input

00:43:08.880 --> 00:43:10.530
doesn't depend on
the day of the week

00:43:10.530 --> 00:43:12.150
that you do the experiment.

00:43:12.150 --> 00:43:14.610
If you come back tomorrow
and do the same experiment,

00:43:14.610 --> 00:43:16.860
you'll get the same result
except it's happening

00:43:16.860 --> 00:43:18.100
tomorrow instead of today.

00:43:18.100 --> 00:43:18.600
Right?

00:43:18.600 --> 00:43:21.690
So it's a system where
if you delayed the input

00:43:21.690 --> 00:43:24.480
by some capital
N, the response is

00:43:24.480 --> 00:43:26.580
the response you had
previously but just delayed

00:43:26.580 --> 00:43:27.970
by the same amount.

00:43:27.970 --> 00:43:30.510
So time invariant
system is one where

00:43:30.510 --> 00:43:34.710
the response doesn't depend on
absolute position on the time

00:43:34.710 --> 00:43:35.610
axis.

00:43:35.610 --> 00:43:37.350
If you shift the
input by some amount,

00:43:37.350 --> 00:43:40.180
you get the same response but
shifted by that same amount.

00:43:40.180 --> 00:43:43.970
So it's a very easy idea.

00:43:43.970 --> 00:43:46.180
OK.

00:43:46.180 --> 00:43:49.390
So for instance, if you
had a time invariant system

00:43:49.390 --> 00:43:53.410
and you put in a
delayed unit sample,

00:43:53.410 --> 00:43:56.230
this is a unit sample that
has the value 1 at the point

00:43:56.230 --> 00:44:00.850
capital N. Your response will
be the unit sample response

00:44:00.850 --> 00:44:02.840
but correspondingly delayed.

00:44:02.840 --> 00:44:03.700
Right?

00:44:03.700 --> 00:44:06.460
So time invariance of a
system allows you to do that,

00:44:06.460 --> 00:44:08.290
and that's very convenient.

00:44:08.290 --> 00:44:13.810
Here's the other property that's
crucial, which is linearity.

00:44:13.810 --> 00:44:16.720
And we've talked about
linearity a lot along the way.

00:44:16.720 --> 00:44:18.950
Here is a definition
in this context.

00:44:18.950 --> 00:44:19.450
OK.

00:44:19.450 --> 00:44:22.180
So we say no the
system S is linear

00:44:22.180 --> 00:44:24.430
if you can do the following.

00:44:24.430 --> 00:44:28.960
Take the response
y1 to an experiment

00:44:28.960 --> 00:44:30.620
with an arbitrary input x1.

00:44:30.620 --> 00:44:31.120
OK?

00:44:31.120 --> 00:44:34.720
So you put in an arbitrary input
x1, you get the response y1.

00:44:34.720 --> 00:44:37.810
Put in an arbitrary input
x2 and another experiment

00:44:37.810 --> 00:44:40.330
get out the response y2.

00:44:40.330 --> 00:44:45.130
If it's true that any
weighted linear combination

00:44:45.130 --> 00:44:48.550
of those inputs from the
previous two experiments

00:44:48.550 --> 00:44:50.350
will give rise to
a response that's

00:44:50.350 --> 00:44:54.430
the same weighted combination
of the original responses,

00:44:54.430 --> 00:44:56.075
then you have a linear system.

00:44:56.075 --> 00:44:57.100
OK?

00:44:57.100 --> 00:45:00.850
So if superposition
of inputs, according

00:45:00.850 --> 00:45:04.120
to this formula
so a weighted sum,

00:45:04.120 --> 00:45:06.460
leads to a response
and output, that's

00:45:06.460 --> 00:45:08.350
the same weighted
combination, then what

00:45:08.350 --> 00:45:09.600
you have is a linear system.

00:45:09.600 --> 00:45:10.100
OK?

00:45:10.100 --> 00:45:12.700
So if this is true for arbitrary
inputs and arbitrary scale

00:45:12.700 --> 00:45:13.200
factors.

00:45:15.690 --> 00:45:17.940
So one important conclusion
from that, by the way,

00:45:17.940 --> 00:45:20.240
is if you have a
linear system, and you

00:45:20.240 --> 00:45:23.480
put in the all-zero input,
the response must also

00:45:23.480 --> 00:45:26.060
be an all-zero response.

00:45:26.060 --> 00:45:29.660
And I'll leave you to think
about why that might be true.

00:45:32.390 --> 00:45:34.340
OK.

00:45:34.340 --> 00:45:38.150
So the systems that we are
going to be focusing on

00:45:38.150 --> 00:45:41.300
will be linear and
time invariant.

00:45:41.300 --> 00:45:42.350
OK?

00:45:42.350 --> 00:45:43.550
LTI.

00:45:43.550 --> 00:45:46.580
And so we're going
to be thinking

00:45:46.580 --> 00:45:55.620
of end-to-end models of the
channel, our digitized sequence

00:45:55.620 --> 00:46:00.582
xn, all the way through
the processing that

00:46:00.582 --> 00:46:01.415
happened in between.

00:46:05.030 --> 00:46:06.170
OK, so what did we have?

00:46:06.170 --> 00:46:08.030
We had modulate.

00:46:08.030 --> 00:46:10.070
We had D to A conversion.

00:46:10.070 --> 00:46:12.740
We had the channel.

00:46:12.740 --> 00:46:16.430
We had A to D. We had DMod.

00:46:19.010 --> 00:46:20.510
And there was a
filtering operation,

00:46:20.510 --> 00:46:22.710
as well, there as part
of the demodulation.

00:46:22.710 --> 00:46:25.550
So all of that,
end-to-end, we're

00:46:25.550 --> 00:46:30.960
going to try representing that
as a linear time invariant

00:46:30.960 --> 00:46:31.460
model.

00:46:31.460 --> 00:46:33.740
So it'll be an approximation.

00:46:33.740 --> 00:46:36.390
Real channels are
more complicated.

00:46:36.390 --> 00:46:38.420
But it turns out that
LTI is a very good place

00:46:38.420 --> 00:46:40.628
to start, and not just for
the communication setting,

00:46:40.628 --> 00:46:42.540
for a whole variety of settings.

00:46:42.540 --> 00:46:44.720
So it turns out
that if you're just

00:46:44.720 --> 00:46:47.450
talking about small deviations
from some nominal operating

00:46:47.450 --> 00:46:50.910
point, a linear
model is not bad.

00:46:50.910 --> 00:46:53.030
And the reason is,
well, it goes back

00:46:53.030 --> 00:46:55.160
to Taylor series
kinds of thinking.

00:47:04.440 --> 00:47:07.620
You can have a very
non-linear function,

00:47:07.620 --> 00:47:10.920
but if you're looking in the
neighborhood of some operating

00:47:10.920 --> 00:47:11.850
point--

00:47:11.850 --> 00:47:12.952
stick it up there.

00:47:12.952 --> 00:47:14.910
So here's some operating
point, and you're only

00:47:14.910 --> 00:47:17.610
looking at small
perturbations around there.

00:47:17.610 --> 00:47:20.190
The linear approximation
is not a bad one.

00:47:20.190 --> 00:47:20.820
OK?

00:47:20.820 --> 00:47:23.340
So it's really essentially
that idea that first order

00:47:23.340 --> 00:47:26.130
Taylor series kinds of
approximations are good.

00:47:26.130 --> 00:47:27.660
And so linearity works.

00:47:27.660 --> 00:47:31.415
Time invariance works because
many systems are inherently

00:47:31.415 --> 00:47:32.040
time invariant.

00:47:32.040 --> 00:47:34.680
Now, that's not always true
for communication channels.

00:47:34.680 --> 00:47:36.760
If you've got a mobile
device, for instance,

00:47:36.760 --> 00:47:38.302
the channel is
changing all the time.

00:47:38.302 --> 00:47:40.408
Well, if you're mobile
with your mobile device,

00:47:40.408 --> 00:47:41.950
the channel is
changing all the time.

00:47:41.950 --> 00:47:43.950
So you need to reckon
with time varying channels

00:47:43.950 --> 00:47:45.720
or what are called
fading channels.

00:47:45.720 --> 00:47:48.750
But for many situations,
a time invariant channel

00:47:48.750 --> 00:47:49.500
is reasonable.

00:47:49.500 --> 00:47:52.500
So time invariant and linear
is a good approximation.

00:47:52.500 --> 00:47:56.340
Now, as soon as you invoke
linearity and time invariance,

00:47:56.340 --> 00:48:00.300
you've got such a rich
structure that opens up

00:48:00.300 --> 00:48:02.730
that there's a lot you
can do by way of analysis

00:48:02.730 --> 00:48:05.480
and developing computational
tools and so on.

00:48:05.480 --> 00:48:08.610
And that gives you a very
good handle on doing design.

00:48:08.610 --> 00:48:11.250
So if you're trying to design
something that's, ideally,

00:48:11.250 --> 00:48:13.260
linear time invariant,
you have a large array

00:48:13.260 --> 00:48:14.840
of tools at your disposal.

00:48:14.840 --> 00:48:16.590
So you'll find that
in engineered systems,

00:48:16.590 --> 00:48:19.320
people are trying to design
modules that are thought

00:48:19.320 --> 00:48:22.110
about as LTI systems and then
interconnecting them, maybe,

00:48:22.110 --> 00:48:24.760
in non-linear ways
or time varying ways.

00:48:24.760 --> 00:48:25.260
OK.

00:48:25.260 --> 00:48:27.510
We'll pick up on this
in recitation tomorrow

00:48:27.510 --> 00:48:31.710
and next lecture which will
be Wednesday of next week.

00:48:31.710 --> 00:48:35.238
And make sure you're aware
of what the portions are

00:48:35.238 --> 00:48:36.780
for the quiz and
where you have to go

00:48:36.780 --> 00:48:39.040
for the quiz rooms and all
of that on Thursday evening

00:48:39.040 --> 00:48:40.700
next week.