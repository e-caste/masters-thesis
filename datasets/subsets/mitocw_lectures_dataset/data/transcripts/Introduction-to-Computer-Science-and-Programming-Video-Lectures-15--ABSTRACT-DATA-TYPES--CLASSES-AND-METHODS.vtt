WEBVTT

00:00:00.000 --> 00:00:01.990
OPERATOR: The following content
is provided under a

00:00:01.990 --> 00:00:03.830
Creative Commons license.

00:00:03.830 --> 00:00:06.840
Your support will help MIT
OpenCourseWare continue to

00:00:06.840 --> 00:00:10.900
offer high quality educational
resources for free, To make a

00:00:10.900 --> 00:00:14.380
donation or view additional
materials from hundreds of MIT

00:00:14.380 --> 00:00:19.930
courses, visit MIT
OpenCourseWare at ocw.mit.edu.

00:00:19.930 --> 00:00:24.030
PROFESSOR: Last time, Professor
Guttag introduced

00:00:24.030 --> 00:00:28.690
the idea of objects and classes
and this wonderful

00:00:28.690 --> 00:00:31.110
phrase called object-oriented
programming.

00:00:31.110 --> 00:00:33.230
And it's a topic I want to pick
up on today, we're going

00:00:33.230 --> 00:00:36.170
to do for the next few lectures,
and it's a topic I

00:00:36.170 --> 00:00:41.240
want to spend some time on
because this idea of capturing

00:00:41.240 --> 00:00:44.180
data and methods, the term we're
going to use for it, but

00:00:44.180 --> 00:00:46.770
data and functions that belong
to that data, things that can

00:00:46.770 --> 00:00:50.630
be used to manipulate them,
is a really powerful one.

00:00:50.630 --> 00:00:53.290
What we're really getting at is
the idea of saying I want

00:00:53.290 --> 00:00:57.080
to have a way of grouping
together information into

00:00:57.080 --> 00:00:58.990
units that make sense.

00:00:58.990 --> 00:01:00.980
So I can go back to one of those
topics we had at the

00:01:00.980 --> 00:01:03.000
beginning, which is the idea
of abstraction, that I can

00:01:03.000 --> 00:01:07.040
create one of those units as a
simple entity, bury away the

00:01:07.040 --> 00:01:09.900
details and write really
modular code.

00:01:09.900 --> 00:01:11.070
And so we're going to
talk about that a

00:01:11.070 --> 00:01:13.640
lot as we go along.

00:01:13.640 --> 00:01:15.980
What we're really doing, or
I shouldn't say what we're

00:01:15.980 --> 00:01:18.450
really doing, a basic piece of
what we're doing, when we talk

00:01:18.450 --> 00:01:21.650
about classes or objects, is
we're doing something that

00:01:21.650 --> 00:01:23.630
Professor Guttag mentioned,
we're defining an

00:01:23.630 --> 00:01:26.130
abstract data type.

00:01:26.130 --> 00:01:28.190
Now what in the world
does that mean?

00:01:28.190 --> 00:01:30.120
Well basically what we're
doing is we're giving

00:01:30.120 --> 00:01:32.720
ourselves the ability to create
data types the same way

00:01:32.720 --> 00:01:35.690
that we have some built-ins,
so we have things like int,

00:01:35.690 --> 00:01:39.440
float, string, these are
built-in data types.

00:01:39.440 --> 00:01:41.770
And if you think about it,
associated with each one of

00:01:41.770 --> 00:01:44.370
those data types is a set
of functions it's

00:01:44.370 --> 00:01:46.340
intended to apply to.

00:01:46.340 --> 00:01:49.330
Sometimes the functions --
sometimes a function can be

00:01:49.330 --> 00:01:53.250
used on multiple data types,
plus, for example, we saw

00:01:53.250 --> 00:01:55.580
could add strings, or could
add ints, but each one of

00:01:55.580 --> 00:01:58.130
those data types has associated
with it a set of

00:01:58.130 --> 00:02:00.550
functions that are geared
to handling them.

00:02:00.550 --> 00:02:03.290
We want to do the same thing,
but with our data types.

00:02:03.290 --> 00:02:06.140
We want to create data types and
functions, or we're going

00:02:06.140 --> 00:02:09.240
to call them methods, that
are specifically aimed at

00:02:09.240 --> 00:02:11.310
manipulating those
kinds of objects.

00:02:11.310 --> 00:02:14.430
And our goal is then to
basically see how we can build

00:02:14.430 --> 00:02:18.100
systems that take advantage
of that modularity.

00:02:18.100 --> 00:02:20.590
Right, so the fundamental idea
then, is, I want to glue

00:02:20.590 --> 00:02:23.190
together information, I want
to take pieces of data that

00:02:23.190 --> 00:02:25.950
naturally belong together, glue
them together, and attach

00:02:25.950 --> 00:02:27.310
some methods to it.

00:02:27.310 --> 00:02:30.420
And that's, you know, saying
a lot of words, let's do an

00:02:30.420 --> 00:02:32.590
example because it's probably
easiest to see this by looking

00:02:32.590 --> 00:02:34.620
at a specific example.

00:02:34.620 --> 00:02:38.640
So here's the example I'm
going to start with.

00:02:38.640 --> 00:02:45.050
Suppose I want to do little
piece of code that's going to

00:02:45.050 --> 00:02:48.440
do planar geometry, points
in the plane.

00:02:48.440 --> 00:02:50.800
All right, so I want to have
some way of gluing those

00:02:50.800 --> 00:02:51.940
things together.

00:02:51.940 --> 00:02:53.750
Well you know what a point is,
it's got an x- and a y-

00:02:53.750 --> 00:02:55.870
coordinate, it's natural to
think about those two things

00:02:55.870 --> 00:02:58.570
as belonging as a
single entity.

00:02:58.570 --> 00:03:00.710
So an easy way to do this would
be to say, let's just

00:03:00.710 --> 00:03:06.920
represent them as a list.
Just as a 2-list,

00:03:06.920 --> 00:03:08.172
or a list of 2 elements.

00:03:08.172 --> 00:03:10.610
It's easy to think of a point as
just a list of an x- and a

00:03:10.610 --> 00:03:12.530
y- coordinate.

00:03:12.530 --> 00:03:23.592
OK, for example, I might say
point p1 is that list, x is 1,

00:03:23.592 --> 00:03:33.120
y is 2. in fact, if I draw
a little simple -- it's

00:03:33.120 --> 00:03:35.670
basically pointing to that point
in the plane, right, x

00:03:35.670 --> 00:03:37.840
is 1, y is 2.

00:03:37.840 --> 00:03:41.820
OK, fine, there's another way
to represent points on the

00:03:41.820 --> 00:03:44.920
plane now, and that's in
polar form, so this, if

00:03:44.920 --> 00:03:48.690
you like, is Cartesian.

00:03:48.690 --> 00:03:50.890
Another way to represent a point
in a plane is I've got a

00:03:50.890 --> 00:03:53.750
radius and I've got an angle
from the x-axis, right, and

00:03:53.750 --> 00:03:55.330
that's a standard thing
you might do.

00:03:55.330 --> 00:04:00.040
So I might define, for example,
in polar form p 2,

00:04:00.040 --> 00:04:08.010
and let me see, which example
did I do here, we'll make this

00:04:08.010 --> 00:04:10.820
the point of radius 2 and at
angle pi by 2, I'm going to

00:04:10.820 --> 00:04:14.015
make it easy because pi by 2
is up along this axis, and

00:04:14.015 --> 00:04:17.750
that's basically that point.

00:04:17.750 --> 00:04:22.040
Ok, just fine, it's
no big deal.

00:04:22.040 --> 00:04:23.830
But here now becomes
the problem.

00:04:23.830 --> 00:04:27.340
I've glued things together but
just using a list. Suppose I

00:04:27.340 --> 00:04:30.250
hand you one of these lists.

00:04:30.250 --> 00:04:32.140
How do you know which
kind it is?

00:04:32.140 --> 00:04:33.780
How do you know whether
it's in Cartesian

00:04:33.780 --> 00:04:36.380
form or in polar form?

00:04:36.380 --> 00:04:38.625
You have nothing that identifies
that there, you

00:04:38.625 --> 00:04:41.620
have no way of saying what this
grouping actually means.

00:04:41.620 --> 00:04:43.900
Right, and just to get a sense
of this, let's look at a

00:04:43.900 --> 00:04:47.410
simple little example, so on
your hand-out, you'll see I've

00:04:47.410 --> 00:04:50.020
got a little piece of code that
says assuming I've got

00:04:50.020 --> 00:04:52.090
one of these points, I want to
do things with it, for example

00:04:52.090 --> 00:04:53.730
I might want to add
them together.

00:04:53.730 --> 00:04:57.000
So this first little piece of
code right here says, ok you

00:04:57.000 --> 00:05:01.610
give me 2 points, I'll create
another 1 of these lists and

00:05:01.610 --> 00:05:03.920
I'll simply take the x, sorry
I shouldn't say x, I'm going

00:05:03.920 --> 00:05:06.290
to assume it's the x, the
x-values are the two points,

00:05:06.290 --> 00:05:09.460
add them together, just right
there, the y-values, add them

00:05:09.460 --> 00:05:13.080
together and return that list.
And if I actually run this,

00:05:13.080 --> 00:05:19.830
which I'm going to do -- excuse
me, do it again --

00:05:19.830 --> 00:05:21.730
OK, you can see that I've
added together and I've

00:05:21.730 --> 00:05:23.710
printed out the value of r, and
I'll just show you that in

00:05:23.710 --> 00:05:24.830
fact that's what I've got.

00:05:24.830 --> 00:05:29.410
This looks fine, right, I'm
doing the right thing.

00:05:29.410 --> 00:05:32.300
Another way of saying it is,
I've actually said, what did I

00:05:32.300 --> 00:05:41.030
use there, (1,2) and (3,1), It's
basically saying there is

00:05:41.030 --> 00:05:42.700
the first point, there's the
second point, add them

00:05:42.700 --> 00:05:45.700
together and I get that point.

00:05:45.700 --> 00:05:49.080
OK, that sounds fine.

00:05:49.080 --> 00:05:52.900
Now, suppose in fact these
weren't x and y glued

00:05:52.900 --> 00:05:55.680
together, these were radius
and angle glued together.

00:05:55.680 --> 00:06:02.570
In that case point p 1 doesn't
correspond to this point, it

00:06:02.570 --> 00:06:05.350
actually corresponds to the
point of radius 2 and angle 1,

00:06:05.350 --> 00:06:07.710
which is about here.

00:06:07.710 --> 00:06:11.700
I think I wrote this down
carefully so I would make sure

00:06:11.700 --> 00:06:13.940
I did it right.

00:06:13.940 --> 00:06:17.770
Sorry, said that wrong, radius
1 and angle 2, 2 radians is a

00:06:17.770 --> 00:06:19.860
little bit more than pi half.

00:06:19.860 --> 00:06:25.350
And the second point is of
radius 3 and angle 1, which is

00:06:25.350 --> 00:06:30.110
up about there.

00:06:30.110 --> 00:06:32.890
So what point, sorry, bad
pun, what point am I

00:06:32.890 --> 00:06:34.460
trying to make here?

00:06:34.460 --> 00:06:38.630
Different understandings of what
that piece means gives

00:06:38.630 --> 00:06:42.440
you different values, and that's
a bit of a problem.

00:06:42.440 --> 00:06:45.960
The second problem is, suppose
actually I had p 1 and p 2

00:06:45.960 --> 00:06:49.890
were in polar form, and I
ran add points on them.

00:06:49.890 --> 00:06:52.710
This little piece of code
here that I did.

00:06:52.710 --> 00:06:55.130
Does that even make any sense?

00:06:55.130 --> 00:06:55.830
Course not, right?

00:06:55.830 --> 00:06:58.360
You know when you add 2 polar
forms, you add the radii

00:06:58.360 --> 00:07:00.490
together, you don't add the
angles together, you need to

00:07:00.490 --> 00:07:02.720
do it in Cartesian form.

00:07:02.720 --> 00:07:06.900
So what I'm leading up to here
is that we've got a problem.

00:07:06.900 --> 00:07:10.170
And the problem is, that we want
to build this abstract

00:07:10.170 --> 00:07:12.940
data type, but we'd like to
basically know what kind of

00:07:12.940 --> 00:07:16.005
object is it, and what functions
actually belong to

00:07:16.005 --> 00:07:17.890
it, how do we use them?

00:07:17.890 --> 00:07:19.995
And so I'm going to go back to
this idea of a class, and

00:07:19.995 --> 00:07:21.910
let's build the first of these,
and that is shown right

00:07:21.910 --> 00:07:25.350
here on this piece
of your handout.

00:07:25.350 --> 00:07:29.320
I'm going to define a class,
and in particular, what I'm

00:07:29.320 --> 00:07:33.210
going to do, is walk through
what that says.

00:07:33.210 --> 00:07:37.080
So I'm going to now build
an object, it's going to

00:07:37.080 --> 00:07:43.110
represent a point.

00:07:43.110 --> 00:07:44.580
So what does that thing
say up there?

00:07:44.580 --> 00:07:47.270
It's got this funky looking
form, right, it says, I've got

00:07:47.270 --> 00:07:52.030
something that I'm going to
call a class, got that key

00:07:52.030 --> 00:07:56.040
word class right here.

00:07:56.040 --> 00:07:58.790
And I'm going to give it a name,
and right now I'm just

00:07:58.790 --> 00:08:00.810
building a simple piece of it --
but first of all, what does

00:08:00.810 --> 00:08:01.460
a class do?

00:08:01.460 --> 00:08:11.610
Think of this as, this is
a template for creating

00:08:11.610 --> 00:08:19.700
instances of an object.

00:08:19.700 --> 00:08:22.410
At the moment, it's a really
dumb template.

00:08:22.410 --> 00:08:23.865
I'm going to add to it in
a second, but I want

00:08:23.865 --> 00:08:24.650
to build up to this.

00:08:24.650 --> 00:08:27.270
Right now it's got that second
key word there called pass,

00:08:27.270 --> 00:08:29.110
which is just Python's way
of saying there's an

00:08:29.110 --> 00:08:31.260
empty body in here.

00:08:31.260 --> 00:08:33.000
Right,, we're going to add to
it in a second, but the idea

00:08:33.000 --> 00:08:35.630
is class is going
to be a template

00:08:35.630 --> 00:08:37.700
for creating instances.

00:08:37.700 --> 00:08:39.180
How do I use it?

00:08:39.180 --> 00:08:41.530
Well, I call class just like
a function, and you

00:08:41.530 --> 00:08:42.560
can see that below.

00:08:42.560 --> 00:08:45.440
Having created this thing called
Cartesian point, I'm

00:08:45.440 --> 00:08:49.100
going to create two instances
of it. c p 1 and c p 2.

00:08:49.100 --> 00:08:51.670
Notice the form of it, it's
just the name of the class

00:08:51.670 --> 00:08:53.690
followed by open paren,
close paren,

00:08:53.690 --> 00:08:56.140
treating it like a function.

00:08:56.140 --> 00:09:03.130
What that does, is that it
creates, c p 1 and c p 2 are

00:09:03.130 --> 00:09:12.970
both instances of this
type, specific

00:09:12.970 --> 00:09:15.320
versions of this type.

00:09:15.320 --> 00:09:17.830
For now the way to think about
this is, when I call that

00:09:17.830 --> 00:09:22.350
class definition, it goes off
and allocates a specific spot

00:09:22.350 --> 00:09:25.050
in memory that corresponds
to that instance.

00:09:25.050 --> 00:09:27.020
Right now it's empty, actually
it's not quite empty, it has a

00:09:27.020 --> 00:09:28.980
pointer back to the class.

00:09:28.980 --> 00:09:32.050
And I can give a name to that,
so c p 1 and c p 2 are both

00:09:32.050 --> 00:09:34.200
going to point to that.

00:09:34.200 --> 00:09:37.420
Once I've got that, I can now
start giving some variable

00:09:37.420 --> 00:09:39.855
names, sorry not, rephrase
that, I can give some

00:09:39.855 --> 00:09:41.140
attributes, I can give some

00:09:41.140 --> 00:09:43.050
characteristics to these classes.

00:09:43.050 --> 00:09:50.150
So each instance has some
internal, or will have some

00:09:50.150 --> 00:09:58.580
internal attributes.

00:09:58.580 --> 00:10:00.720
Notice how I did
that up there.

00:10:00.720 --> 00:10:05.220
Having created c p 1 and
c p 2, I had this weird

00:10:05.220 --> 00:10:06.300
looking form here.

00:10:06.300 --> 00:10:08.050
Not so weird, you've actually
seen it before.

00:10:08.050 --> 00:10:15.810
In which I said c p 1
dot x equals 1.0.

00:10:15.810 --> 00:10:19.760
What's this doing? c p 1 points
to an instance, it

00:10:19.760 --> 00:10:23.500
points to a particular version
of this class.

00:10:23.500 --> 00:10:27.380
And I have now given an internal
variable name x and a

00:10:27.380 --> 00:10:29.360
value associated with that.

00:10:29.360 --> 00:10:31.500
So I've just given
it an x variable.

00:10:31.500 --> 00:10:34.860
All right, c p 1 dot y, I've
said assign that to

00:10:34.860 --> 00:10:37.040
the value 2, 2,0.

00:10:37.040 --> 00:10:42.270
So now c p 1 has inside of
it an x and y value.

00:10:42.270 --> 00:10:44.620
Did the same thing with
c p 2, give it a

00:10:44.620 --> 00:10:46.610
different x and y value.

00:10:46.610 --> 00:10:49.900
Again, remind you, c p 2
is a different instance

00:10:49.900 --> 00:10:51.850
of this data type.

00:10:51.850 --> 00:10:53.870
All right, when I call the class
definition it goes off

00:10:53.870 --> 00:10:56.070
and finds another spot in
memory, says that the spot I'm

00:10:56.070 --> 00:10:58.010
going to give you a pointer back
to that, give it the name

00:10:58.010 --> 00:11:02.310
c p 2, and then by running these
2 little assignments

00:11:02.310 --> 00:11:08.720
statements here, I've given it
an x and a y value for c p 2.

00:11:08.720 --> 00:11:10.620
So you see why I say it's
a template, right?

00:11:10.620 --> 00:11:12.520
Right now it's a simple
template, but it's a template

00:11:12.520 --> 00:11:14.800
for creating what a class looks
like, and I now have an

00:11:14.800 --> 00:11:18.050
x- and y- value associated with
each instance of this.

00:11:18.050 --> 00:11:20.250
OK, and if I wanted to look at
it, we can come back over

00:11:20.250 --> 00:11:28.860
here, and we can see what does
c p 1 look like, interesting.

00:11:28.860 --> 00:11:31.520
It says some funky stuff,
and says it's a kind

00:11:31.520 --> 00:11:33.500
of Cartesian point.

00:11:33.500 --> 00:11:35.420
And that's going to be valuable
to me when I want to

00:11:35.420 --> 00:11:36.870
get back to using these
things, right?

00:11:36.870 --> 00:11:39.830
You see that little thing says
dot Cartesian point in there.

00:11:39.830 --> 00:11:42.430
If I want to get out right now
the versions of these things,

00:11:42.430 --> 00:11:46.390
I can ask what's the value
of c p 1 x, and it

00:11:46.390 --> 00:11:48.240
returns it back out.

00:11:48.240 --> 00:11:52.270
I could say c p 2 dot x, that
was a bad one to use because

00:11:52.270 --> 00:11:54.090
they use the same valuable
in both places, didn't I?

00:11:54.090 --> 00:12:01.970
So let's do c p 1 dot
y, c p 2 dot y.

00:12:01.970 --> 00:12:04.460
OK, so I've just created local
versions of variables with

00:12:04.460 --> 00:12:05.840
each one of these objects.

00:12:05.840 --> 00:12:08.660
I can get at them just like I
would before, I can assign

00:12:08.660 --> 00:12:12.000
them in as I might
have done before.

00:12:12.000 --> 00:12:16.730
OK, now that I've got that, we
could think about what would I

00:12:16.730 --> 00:12:18.710
want to do with these points?

00:12:18.710 --> 00:12:20.930
Well one thing I might want to
do is say, is this the same

00:12:20.930 --> 00:12:22.450
point or not?

00:12:22.450 --> 00:12:25.900
So the next little piece of code
I've written here, just

00:12:25.900 --> 00:12:30.740
move down to it slightly.

00:12:30.740 --> 00:12:33.760
I've got a little piece of
code called same point.

00:12:33.760 --> 00:12:35.570
And you can look at it.

00:12:35.570 --> 00:12:36.500
What does it say to do?

00:12:36.500 --> 00:12:39.716
It says, if you give me two of
these data objects, I'm going

00:12:39.716 --> 00:12:42.070
to call them p 1 and p 2.

00:12:42.070 --> 00:12:45.360
I'm going to say, gee, is the
x value the same in both of

00:12:45.360 --> 00:12:50.350
them, and if it is, and the y
value's the same, then this is

00:12:50.350 --> 00:12:53.130
the same point, I'm going
to return true.

00:12:53.130 --> 00:12:54.610
Notice the form.

00:12:54.610 --> 00:12:58.170
This is saying, that's a class,
or sorry, an instance

00:12:58.170 --> 00:13:00.460
of a class, and I'm going
to get the x value

00:13:00.460 --> 00:13:02.410
associated with it.

00:13:02.410 --> 00:13:04.240
I going to come back in a second
to how it actually does

00:13:04.240 --> 00:13:07.050
that, but it basically says, get
me x value for p 1, get me

00:13:07.050 --> 00:13:08.690
the x value for p 2,
compare them, just

00:13:08.690 --> 00:13:10.490
as you would normally.

00:13:10.490 --> 00:13:12.310
I've got another little thing
here that I'm going to use a

00:13:12.310 --> 00:13:16.440
little later on that just prints
out values of things.

00:13:16.440 --> 00:13:21.100
OK, let's see what happens
if I do this.

00:13:21.100 --> 00:13:22.850
Let me show you simple
little example.

00:13:22.850 --> 00:13:29.890
I'm going to go over here, and
let me define a couple of

00:13:29.890 --> 00:13:30.620
these things.

00:13:30.620 --> 00:13:42.760
I'm going to say p 1, try it
again, p 1 is a Cartesian, it

00:13:42.760 --> 00:13:49.870
would help if I could type,
Cartesian point, and I'm going

00:13:49.870 --> 00:13:56.120
to say p 1 of x is 3, p 1 of y
is 4, and I'm going to make p

00:13:56.120 --> 00:14:03.660
2 another Cartesian point.

00:14:03.660 --> 00:14:12.120
And I'll give it an x value
of 3 and a y value of 4.

00:14:12.120 --> 00:14:15.210
OK, now I want to say,
are these the same?

00:14:15.210 --> 00:14:18.300
Thing I've got a little
procedure that could do that,

00:14:18.300 --> 00:14:20.100
but you know the simplest thing
I could do is to say

00:14:20.100 --> 00:14:22.450
well, gee, wait a minute, why
don't I just check to see if

00:14:22.450 --> 00:14:23.420
these are the same thing?

00:14:23.420 --> 00:14:29.210
So I can say is p 1 the same
as p 2, using Scheme's

00:14:29.210 --> 00:14:30.830
built-in is comparator.

00:14:30.830 --> 00:14:32.900
Say -- sorry?

00:14:32.900 --> 00:14:33.620
PROFESSOR 2: Part of Python?

00:14:33.620 --> 00:14:35.530
PROFESSOR: Part of Scheme, whoa,
there's a Freudian slip,

00:14:35.530 --> 00:14:36.570
thank you, John.

00:14:36.570 --> 00:14:40.390
I'm showing my age, and my
history here, is p 1 and p 2

00:14:40.390 --> 00:14:41.170
the same thing?

00:14:41.170 --> 00:14:43.070
Hey, there's a bad English
sentence even worse, now I'm

00:14:43.070 --> 00:14:43.930
really thrown off.

00:14:43.930 --> 00:14:45.950
I'm using Python's is comparator
to say is it the

00:14:45.950 --> 00:14:46.440
same thing?

00:14:46.440 --> 00:14:50.910
It says no.

00:14:50.910 --> 00:15:00.570
But if I say, are p 1 and p 2
the same point, it says yes.

00:15:00.570 --> 00:15:02.170
And this is a point I
want to stress here.

00:15:02.170 --> 00:15:04.780
So what's going on in this case
is, I want to distinguish

00:15:04.780 --> 00:15:18.530
between shallow equality
and deep equality.

00:15:18.530 --> 00:15:23.580
The first thing is testing
shallow equality.

00:15:23.580 --> 00:15:26.380
What it is doing, that's another
bad English sentence,

00:15:26.380 --> 00:15:27.810
but what it is doing?

00:15:27.810 --> 00:15:32.540
Is is essentially saying, given
2 things, do they point

00:15:32.540 --> 00:15:34.490
to exactly the same referent?

00:15:34.490 --> 00:15:37.140
Or another way of thinking about
it, is remember I said

00:15:37.140 --> 00:15:39.560
when I call that class
definition it creates an

00:15:39.560 --> 00:15:41.490
instance, that's a pointer to
some spot in memory that's got

00:15:41.490 --> 00:15:43.230
some local information
around it.

00:15:43.230 --> 00:15:46.680
Is is saying, do these things
point to exactly the same spot

00:15:46.680 --> 00:15:49.880
in memory, the same instance.

00:15:49.880 --> 00:15:56.250
Deep equality, we get to define,
that's what I did by

00:15:56.250 --> 00:15:57.920
writing same point.

00:15:57.920 --> 00:16:00.920
OK, as I said, I want equality
in the case of points to be,

00:16:00.920 --> 00:16:02.870
are the x- and y- coordinates
the same?

00:16:02.870 --> 00:16:05.520
And I'm actually going to change
it. just to show you

00:16:05.520 --> 00:16:06.120
this point.

00:16:06.120 --> 00:16:12.180
If I do the following, and
I say, I'm going to

00:16:12.180 --> 00:16:14.700
assign p 1 to be p 2.

00:16:14.700 --> 00:16:15.380
What's that doing?

00:16:15.380 --> 00:16:18.250
It's taking the name p 1 and
it's changing its value to

00:16:18.250 --> 00:16:21.360
point to exactly what
p 2 points to.

00:16:21.360 --> 00:16:25.670
And then I say, are they
the same thing?

00:16:25.670 --> 00:16:28.460
Answer's yes, because now they
are pointing to exactly the

00:16:28.460 --> 00:16:30.290
same spot in memory.

00:16:30.290 --> 00:16:32.430
The same instance.

00:16:32.430 --> 00:16:34.650
OK, the reason I'm saying this
is, we have one class

00:16:34.650 --> 00:16:36.610
definition, is a cookie cutter,
it's a template that's

00:16:36.610 --> 00:16:38.810
going to let us build versions
of these things.

00:16:38.810 --> 00:16:40.930
Every time I use it, I'm
creating a new instance,

00:16:40.930 --> 00:16:43.460
that's a different thing
inside of memory.

00:16:43.460 --> 00:16:45.300
And I want to have that because
I want to have lots of

00:16:45.300 --> 00:16:47.960
versions of points.

00:16:47.960 --> 00:16:54.240
OK, now, let's go back
to where I was.

00:16:54.240 --> 00:16:56.700
I said one of the things I want
to do is, I want to have

00:16:56.700 --> 00:16:57.850
different versions of points.

00:16:57.850 --> 00:17:00.700
So I've got now things that
are Cartesian points.

00:17:00.700 --> 00:17:03.330
I could do the same thing, I
could build polar point.

00:17:03.330 --> 00:17:04.630
I wanted to show
it to you here.

00:17:04.630 --> 00:17:07.570
I've got a class called polar
point, which is right there,

00:17:07.570 --> 00:17:10.610
and same kind of thing, I can
create instances of it, and

00:17:10.610 --> 00:17:13.350
then assign to them things like
a radius and an angle,

00:17:13.350 --> 00:17:15.570
make instances of those.

00:17:15.570 --> 00:17:18.350
OK, John?

00:17:18.350 --> 00:17:21.210
PROFESSOR 2: I just want to
maybe mention that in some of

00:17:21.210 --> 00:17:21.790
the reading, you'll see terms
like object equality and value

00:17:21.790 --> 00:17:26.050
equality, instead of shallow
equality and deep equality.

00:17:26.050 --> 00:17:33.850
PROFESSOR: Right, so, this
object, this is,

00:17:33.850 --> 00:17:35.430
right, value quality.

00:17:35.430 --> 00:17:36.170
Right.

00:17:36.170 --> 00:17:37.530
And you will see both
terms used.

00:17:37.530 --> 00:17:39.720
Some people like to use shallow
and deep, object and

00:17:39.720 --> 00:17:41.700
value, but they're talking about
the same thing, which is

00:17:41.700 --> 00:17:44.960
it the same object or is it the
same, in this case, set of

00:17:44.960 --> 00:17:49.970
values, depending on what you
want to define as you use it.

00:17:49.970 --> 00:17:57.150
OK, so as I said, now I can go
off and I could create a

00:17:57.150 --> 00:17:57.660
different class.

00:17:57.660 --> 00:18:00.210
I've got Cartesian points, I
could create a polar points.

00:18:00.210 --> 00:18:02.030
And I'm going to run it in a
sec, but you can see, the same

00:18:02.030 --> 00:18:02.560
kind of idea.

00:18:02.560 --> 00:18:05.400
I define a class call polar
point, I create a couple of

00:18:05.400 --> 00:18:07.440
them, and I give them a
radius and an angle.

00:18:07.440 --> 00:18:10.030
And then I could do things like
again, say, okay having

00:18:10.030 --> 00:18:17.430
done, that let me just run it
here, run that, so I've now

00:18:17.430 --> 00:18:19.820
got polar point 1, and
polar point 2.

00:18:19.820 --> 00:18:23.970
I can say is polar point 1 the
same as polar point 2, and the

00:18:23.970 --> 00:18:25.510
answer should be no.

00:18:25.510 --> 00:18:30.860
And then I could say well, gee,
are they the same point?

00:18:30.860 --> 00:18:38.370
Oops.

00:18:38.370 --> 00:18:40.730
What happened?

00:18:40.730 --> 00:18:41.750
Well it bombed out.

00:18:41.750 --> 00:18:43.410
Because, what was I
expecting to do?

00:18:43.410 --> 00:18:45.900
I was expecting to compare
x- and y- values,

00:18:45.900 --> 00:18:47.980
not radius and angle.

00:18:47.980 --> 00:18:49.710
And so this doesn't know how
to do it, it doesn't have a

00:18:49.710 --> 00:18:52.310
method to deal with it,
so it complains.

00:18:52.310 --> 00:18:54.530
So what's my problem here, and
this is what I want to now

00:18:54.530 --> 00:18:55.420
lead up to.

00:18:55.420 --> 00:18:59.340
I could imagine writing another
function for same

00:18:59.340 --> 00:19:01.590
point, and I have to give it a
name like same point polar,

00:19:01.590 --> 00:19:03.120
and same point Cartesian.

00:19:03.120 --> 00:19:05.600
A different function to compare
polar versions of

00:19:05.600 --> 00:19:07.040
these points.

00:19:07.040 --> 00:19:09.520
But that's starting to
get to be a nuisance.

00:19:09.520 --> 00:19:13.280
What I'd really like to do is to
have 1 representation for a

00:19:13.280 --> 00:19:17.160
point that supports different
ways of getting information

00:19:17.160 --> 00:19:20.680
out, but has gathered within it,
a method or a function for

00:19:20.680 --> 00:19:22.440
dealing with things like how
do I know if it's the same

00:19:22.440 --> 00:19:23.870
point or not.

00:19:23.870 --> 00:19:26.200
So I want to take this idea
classes now, and I want to

00:19:26.200 --> 00:19:28.050
generalize it.

00:19:28.050 --> 00:19:32.550
Right, and that is going to
lead us then to this funky

00:19:32.550 --> 00:19:34.770
looking thing.

00:19:34.770 --> 00:19:36.310
Right there, and I'd
like you to look at

00:19:36.310 --> 00:19:38.680
that in your handout.

00:19:38.680 --> 00:19:44.060
OK, I'm going to go back
and rebuild the class.

00:19:44.060 --> 00:19:45.190
Ok, and again, I'm going
to remind you, the

00:19:45.190 --> 00:19:50.670
class is this template.

00:19:50.670 --> 00:19:52.980
But now I'm going to change
it, so what is that new

00:19:52.980 --> 00:19:54.090
version of class say.

00:19:54.090 --> 00:19:55.120
I'm going to call it
c point just to

00:19:55.120 --> 00:19:56.430
make it a little shorter.

00:19:56.430 --> 00:20:00.120
You can see inside of it, it's
got a set of definitions for

00:20:00.120 --> 00:20:01.540
things like functions.

00:20:01.540 --> 00:20:04.310
And that first one is this kind
of interesting thing,

00:20:04.310 --> 00:20:09.800
it's two underbars, init,
and two underbars.

00:20:09.800 --> 00:20:11.140
Underscores, I guess
is the right way

00:20:11.140 --> 00:20:13.040
to say it, not underbars.

00:20:13.040 --> 00:20:17.660
Right that's a specific name,
and what it basically says is,

00:20:17.660 --> 00:20:20.970
when I call the class
instance.

00:20:20.970 --> 00:20:22.200
That's a bad mistake.

00:20:22.200 --> 00:20:25.835
When I call the class
definition, that is I call c

00:20:25.835 --> 00:20:29.970
point, I'm going to
call it with a

00:20:29.970 --> 00:20:31.180
specific set of arguments.

00:20:31.180 --> 00:20:34.560
And what is it going to
happen is that init is

00:20:34.560 --> 00:20:36.740
going to then apply.

00:20:36.740 --> 00:20:38.160
It's going to apply to
those arguments.

00:20:38.160 --> 00:20:40.330
So let me in fact show
you an example.

00:20:40.330 --> 00:20:43.740
I've got a definition of
Cartesian point, I've got a

00:20:43.740 --> 00:20:46.150
definition of polar point.

00:20:46.150 --> 00:20:51.470
Let me just run these to
get them in there.

00:20:51.470 --> 00:20:52.750
Now let's do the following.

00:20:52.750 --> 00:21:01.390
Let's let p be Cartesian point,
and we'll give it a

00:21:01.390 --> 00:21:03.870
couple of values.

00:21:03.870 --> 00:21:06.180
OK?

00:21:06.180 --> 00:21:06.840
So what happened?

00:21:06.840 --> 00:21:11.120
Notice in the class definition
here, is there, this is the

00:21:11.120 --> 00:21:12.940
first thing that's got called,
and I just called with the

00:21:12.940 --> 00:21:16.190
value for x and the value for
y, and it went off and did

00:21:16.190 --> 00:21:18.660
something for me.

00:21:18.660 --> 00:21:25.290
Does that look right?

00:21:25.290 --> 00:21:28.510
This is where you all hate it, I
get no eye contact anywhere.

00:21:28.510 --> 00:21:30.520
Anything look odd about that?

00:21:30.520 --> 00:21:31.040
I said.

00:21:31.040 --> 00:21:33.310
When I call this class
definition, it calls init, and

00:21:33.310 --> 00:21:38.250
I give it an x and a y value.

00:21:38.250 --> 00:21:40.910
How many arguments
does init take?

00:21:40.910 --> 00:21:41.920
Three.

00:21:41.920 --> 00:21:43.720
How many arguments
did I give it?

00:21:43.720 --> 00:21:44.850
Two.

00:21:44.850 --> 00:21:47.050
What in the world's going on?

00:21:47.050 --> 00:21:49.480
Well, this is a piece of
object-oriented coding that we

00:21:49.480 --> 00:21:50.590
get to talk about
a little bit.

00:21:50.590 --> 00:21:53.520
There's this weird extra
variable in there called self.

00:21:53.520 --> 00:21:57.220
So what is self?

00:21:57.220 --> 00:21:59.470
And I have to admit, I did the
standard thing you do every

00:21:59.470 --> 00:22:03.210
time you run across something
you don't know about, you go

00:22:03.210 --> 00:22:04.760
to Wikipedia.

00:22:04.760 --> 00:22:07.830
So I went and looked up self
in Wikipedia, and I have to

00:22:07.830 --> 00:22:08.250
read it out.

00:22:08.250 --> 00:22:12.150
Wikipedia informs us that the
self is the idea of a unified

00:22:12.150 --> 00:22:14.340
being, which is the source
of an idiosyncratic

00:22:14.340 --> 00:22:15.660
consciousness.

00:22:15.660 --> 00:22:18.110
Moreover, this self is the
agent responsible for the

00:22:18.110 --> 00:22:20.030
thoughts and actions
of an individual to

00:22:20.030 --> 00:22:21.600
which they are ascribed.

00:22:21.600 --> 00:22:23.770
It is a substance which
therefore endures through

00:22:23.770 --> 00:22:26.080
time, thus thoughts and actions
at different moments

00:22:26.080 --> 00:22:29.090
of time may pertain
to the same self.

00:22:29.090 --> 00:22:31.530
OK, how do we code that up?

00:22:31.530 --> 00:22:33.690
Sounds like an AI problem,
I guess right?

00:22:33.690 --> 00:22:38.220
But there's actually hidden in
there an important element,

00:22:38.220 --> 00:22:42.060
and that is, when I create an
instance, I have to be able to

00:22:42.060 --> 00:22:45.350
get access to the things that
characterize that instance.

00:22:45.350 --> 00:22:47.370
I won't say that they're
thoughts and emotions or

00:22:47.370 --> 00:22:50.130
things, but what characterizes
an instance here, it's the

00:22:50.130 --> 00:22:54.890
internal parameters that specify
what is going on.

00:22:54.890 --> 00:22:57.830
So in fact what happens inside
of an object-oriented system,

00:22:57.830 --> 00:22:59.740
and particularly in Python's
object-oriented

00:22:59.740 --> 00:23:02.920
system, is the following.

00:23:02.920 --> 00:23:14.080
When we call init, it's going
to create the instance, all

00:23:14.080 --> 00:23:16.550
right, just as we said before.

00:23:16.550 --> 00:23:29.810
But in particular, it's
going to use self to

00:23:29.810 --> 00:23:32.510
refer to that instance.

00:23:32.510 --> 00:23:36.290
Right, so let me say this
a little differently.

00:23:36.290 --> 00:23:38.530
I have a class definition.

00:23:38.530 --> 00:23:39.980
It's actually an object
somewhere.

00:23:39.980 --> 00:23:42.740
It has inside of it all those
internal definitions.

00:23:42.740 --> 00:23:45.350
When I call that class
definition, it calls init.

00:23:45.350 --> 00:23:48.840
Init creates a pointer
to the instance.

00:23:48.840 --> 00:23:51.745
And then it needs to have access
to that, so it calls

00:23:51.745 --> 00:23:56.330
it, passing in self as the
pointer to the instance.

00:23:56.330 --> 00:23:59.450
That is, it says it has access
to that piece in memory, and

00:23:59.450 --> 00:24:02.810
now inside of that piece of
memory, I can do things like,

00:24:02.810 --> 00:24:07.560
as you see here, define self
dot x to be the value

00:24:07.560 --> 00:24:09.220
passed in for x.

00:24:09.220 --> 00:24:09.980
What's that doing?

00:24:09.980 --> 00:24:11.930
It's saying where's
self pointing to?

00:24:11.930 --> 00:24:15.030
Inside of that structure, create
a variable name x, and

00:24:15.030 --> 00:24:16.770
a value associated with it.

00:24:16.770 --> 00:24:19.370
Notice what I also do here, I
create self dot y, give it a

00:24:19.370 --> 00:24:22.810
value, and then, oh cool, I
can also set up what's the

00:24:22.810 --> 00:24:27.560
radius and angle for this point,
by just doing a little

00:24:27.560 --> 00:24:29.020
bit of work.

00:24:29.020 --> 00:24:32.050
OK, in fact if you look at what
it does there, just put

00:24:32.050 --> 00:24:36.095
the pointer over here, it says,
get the value of x that

00:24:36.095 --> 00:24:39.630
I just stored away, square it,
add it to the value of y

00:24:39.630 --> 00:24:41.900
squared that I just stored away,
and then take square

00:24:41.900 --> 00:24:43.050
root, pass it back out.

00:24:43.050 --> 00:24:45.650
So I just computed the radius
of that particular thing.

00:24:45.650 --> 00:24:46.120
Right?

00:24:46.120 --> 00:24:47.780
Compute the angle the same
way, just using the

00:24:47.780 --> 00:24:49.540
appropriate things.

00:24:49.540 --> 00:24:54.220
So the idea is that self
will always point to

00:24:54.220 --> 00:24:56.770
the particular instance.

00:24:56.770 --> 00:24:58.490
Now you might say, why?

00:24:58.490 --> 00:25:00.710
Why do it this way?

00:25:00.710 --> 00:25:03.270
Well, basically because it was
a design choice when the

00:25:03.270 --> 00:25:05.590
creators of Python decided to
create the language, they

00:25:05.590 --> 00:25:07.890
basically said, we're always
going to have an explicit

00:25:07.890 --> 00:25:09.100
pointer to the instance.

00:25:09.100 --> 00:25:11.770
Some other object-oriented
programming languages do not

00:25:11.770 --> 00:25:13.940
provide that pointer.

00:25:13.940 --> 00:25:15.790
This is kind of nice in my view,
I don't know if John,

00:25:15.790 --> 00:25:17.230
you'd agree, but this
is explicit.

00:25:17.230 --> 00:25:19.590
It actually lets you see how to
get access to that pointer

00:25:19.590 --> 00:25:21.310
so you know what you're
referring to.

00:25:21.310 --> 00:25:23.600
But it's simply design choice.

00:25:23.600 --> 00:25:26.260
So another way saying it again
is, when I call the class

00:25:26.260 --> 00:25:28.760
definition, by default I'm going
to look to see is there

00:25:28.760 --> 00:25:31.640
an init method there, and if
there is, I'm going to use it.

00:25:31.640 --> 00:25:35.380
First argument by convention is
always self, because it has

00:25:35.380 --> 00:25:37.200
to point to the instance, and
then I pass, in this case,

00:25:37.200 --> 00:25:39.770
another couple of
arguments in.

00:25:39.770 --> 00:25:43.550
OK, now, if I actually do this,
and I'm going to show

00:25:43.550 --> 00:25:46.160
you the example, I just, what
did I type over there, I got p

00:25:46.160 --> 00:25:48.740
was a c point.

00:25:48.740 --> 00:25:52.950
If I want to get values back
out, I could in fact simply

00:25:52.950 --> 00:25:55.640
send to that instance a message,
in this case I could

00:25:55.640 --> 00:25:58.120
say p dot x.

00:25:58.120 --> 00:26:00.400
In fact let's do it.

00:26:00.400 --> 00:26:08.060
If I do that over here -- aha --
it gets me back the value.

00:26:08.060 --> 00:26:10.430
Now let me spend just a second
to say, what was this actually

00:26:10.430 --> 00:26:13.770
doing? p is an instance.

00:26:13.770 --> 00:26:16.830
It knows, or has stored away,
and in fact let's look at it,

00:26:16.830 --> 00:26:22.070
if we look at what p does,
p says -- it says reading

00:26:22.070 --> 00:26:25.830
through a little bit of this
stuff here, it says -- it's a

00:26:25.830 --> 00:26:28.930
kind of Cartesian point, it's an
instance, there's actually

00:26:28.930 --> 00:26:31.580
the memory location that it's
at, that's why I say this idea

00:26:31.580 --> 00:26:34.560
of it's an instant at
a specific spot.

00:26:34.560 --> 00:26:38.590
It knows that it came from
this class, c point.

00:26:38.590 --> 00:26:41.580
So when I type, I'm sorry, I
shouldn't say type, when I

00:26:41.580 --> 00:26:44.520
write, although I would have
typed it, p dot x, here's what

00:26:44.520 --> 00:26:48.210
basically happens. p is an
instance, it's being sent a

00:26:48.210 --> 00:26:50.976
message, in this case the
message x, it says I want the

00:26:50.976 --> 00:26:55.750
x-value back out. p knows that
it is a kind of Cartesian

00:26:55.750 --> 00:27:00.640
point, it actually goes and
gets, if you like, the class

00:27:00.640 --> 00:27:04.310
definition up here.

00:27:04.310 --> 00:27:06.320
And is able to then say,
inside of that class

00:27:06.320 --> 00:27:09.210
definition, find
the value of x.

00:27:09.210 --> 00:27:13.350
All right, now, that's one of
the ways we could get things

00:27:13.350 --> 00:27:15.380
out, but in fact it's really
not a good way.

00:27:15.380 --> 00:27:20.290
A better way to do this would
be the following.

00:27:20.290 --> 00:27:27.080
If I could type.

00:27:27.080 --> 00:27:29.080
What did I just do there?

00:27:29.080 --> 00:27:31.330
One of the things that I
defined inside my class

00:27:31.330 --> 00:27:36.850
definition here was an
internal method.

00:27:36.850 --> 00:27:39.390
That method has a name,
obviously, and

00:27:39.390 --> 00:27:39.990
what does it do?

00:27:39.990 --> 00:27:42.490
It's going to go off and get the
values of x and y attached

00:27:42.490 --> 00:27:45.240
to this thing and return
them to me.

00:27:45.240 --> 00:27:46.890
And that's one of the
things I want.

00:27:46.890 --> 00:27:57.110
I would like my classes
to have methods.

00:27:57.110 --> 00:28:09.700
So you can access the values
of the specific instance.

00:28:09.700 --> 00:28:11.850
Now, this is still a nuance, why
would I like to do this?

00:28:11.850 --> 00:28:14.020
Well this is leading up to why
I want to gather things

00:28:14.020 --> 00:28:16.470
together in classes
to start with.

00:28:16.470 --> 00:28:20.050
It's perfectly legal in Python
to type that in and get the

00:28:20.050 --> 00:28:21.550
value back out.

00:28:21.550 --> 00:28:23.820
As I said, I would prefer to
do something that uses an

00:28:23.820 --> 00:28:28.740
accessor that I just wrote.

00:28:28.740 --> 00:28:35.460
So p dot Cartesian is a kind
of accessor, it's getting

00:28:35.460 --> 00:28:39.240
access to the data.

00:28:39.240 --> 00:28:42.190
And here's why I'd
like to have it.

00:28:42.190 --> 00:28:45.810
Right now, I still have the
problem that those classes,

00:28:45.810 --> 00:28:47.730
those instances of classes,
are exposed.

00:28:47.730 --> 00:28:48.860
What do I mean by that?

00:28:48.860 --> 00:28:57.980
Here's something I could do.

00:28:57.980 --> 00:29:07.480
Let's do it in fact.

00:29:07.480 --> 00:29:09.220
OK.

00:29:09.220 --> 00:29:13.960
What point in the plane
does p now point to?

00:29:13.960 --> 00:29:16.370
X-axis is foobar y-axis
ought to be foobass

00:29:16.370 --> 00:29:18.290
something else, right?

00:29:18.290 --> 00:29:21.660
I know it looks like a simple
and silly little example, but

00:29:21.660 --> 00:29:24.630
at the moment, I still have
the ability to go in and

00:29:24.630 --> 00:29:27.650
change the values of the
parameters by that little

00:29:27.650 --> 00:29:28.220
definition.

00:29:28.220 --> 00:29:29.380
And this makes no sense.

00:29:29.380 --> 00:29:32.670
And this is because I don't have
something I would really

00:29:32.670 --> 00:29:40.520
like to have, which
is data hiding.

00:29:40.520 --> 00:29:42.230
So you'll see lots of
definitions of this.

00:29:42.230 --> 00:29:49.160
I think of data hiding as
basically saying, one can only

00:29:49.160 --> 00:29:54.650
access instance values, or,
we'll call them that, instance

00:29:54.650 --> 00:30:06.520
values through defined
methods.

00:30:06.520 --> 00:30:08.850
And that's a wonderful thing to
have because it gives you

00:30:08.850 --> 00:30:11.370
that modularity, that
encapsulation that basically

00:30:11.370 --> 00:30:14.100
says, when I create a point, the
only way I can get at the

00:30:14.100 --> 00:30:17.350
values, is by using one of the
defined methods, in this case

00:30:17.350 --> 00:30:20.050
it could be Cartesian, and get
all the pieces of that.

00:30:20.050 --> 00:30:28.810
Unfortunately, Python
doesn't do this.

00:30:28.810 --> 00:30:30.090
Which is really a shame.

00:30:30.090 --> 00:30:34.860
Or another way of saying it
is, please don't do that.

00:30:34.860 --> 00:30:37.370
Don't go in and change the
values of things by using the

00:30:37.370 --> 00:30:38.220
direct access.

00:30:38.220 --> 00:30:41.720
Have the computational hygiene,
if you like, to only

00:30:41.720 --> 00:30:44.010
go through accessors, only go
through methods that are

00:30:44.010 --> 00:30:46.910
actually provided to
you as you do this.

00:30:46.910 --> 00:30:51.100
I actually don't remember,
John, C++ does have data

00:30:51.100 --> 00:30:52.000
hiding, I think, right?

00:30:52.000 --> 00:30:57.420
PROFESSOR 2: And not only
shouldn't you change it, you

00:30:57.420 --> 00:30:58.210
shouldn't even read it.

00:30:58.210 --> 00:30:58.470
PROFESSOR: Exactly.

00:30:58.470 --> 00:31:00.400
What you're going to see in a
second I violated in some of

00:31:00.400 --> 00:31:02.740
my code, which Professor Guttag
is going to yell at me

00:31:02.740 --> 00:31:04.570
shortly because I should have
done it through accessors,

00:31:04.570 --> 00:31:06.050
but, he's exactly right.

00:31:06.050 --> 00:31:09.210
A good, hygienic way of doing
this is, not only do I not go

00:31:09.210 --> 00:31:11.570
in and change things except
through a pre-defined method,

00:31:11.570 --> 00:31:13.890
I shouldn't read it other than
through a pre-defined method.

00:31:13.890 --> 00:31:16.440
I should use Cartesian
or polar to pull out

00:31:16.440 --> 00:31:23.170
those pieces of it.

00:31:23.170 --> 00:31:28.050
Once I've got that, you notice
I can now define a polar

00:31:28.050 --> 00:31:30.830
point, same way.

00:31:30.830 --> 00:31:33.800
Notice I've now solved one of my
problems, which is, in each

00:31:33.800 --> 00:31:38.090
one of these cases here, I'm
creating both x y and radius

00:31:38.090 --> 00:31:40.870
angle values inside of there.

00:31:40.870 --> 00:31:43.310
If it's in polar form I passed
in a radius and angle and I'll

00:31:43.310 --> 00:31:46.050
compute what the x-
and y- value is.

00:31:46.050 --> 00:31:48.550
If its in Cartesian form I'll
pass in an x and y and compute

00:31:48.550 --> 00:31:50.050
what a radius and angle is.

00:31:50.050 --> 00:31:53.700
But it now says that in any, in
no matter what kind of form

00:31:53.700 --> 00:31:56.770
I made it from, I can get out
that kind of information.

00:31:56.770 --> 00:32:00.110
So for example I defined p,
remember back over here, as a

00:32:00.110 --> 00:32:01.970
Cartesian point, but
I can actually ask

00:32:01.970 --> 00:32:07.770
for its polar form.

00:32:07.770 --> 00:32:09.970
It's there accessible to me.

00:32:09.970 --> 00:32:11.840
OK, this is great.

00:32:11.840 --> 00:32:14.360
Just to drive home one more
reason why I don't want to

00:32:14.360 --> 00:32:16.500
have changes to the
values other than

00:32:16.500 --> 00:32:18.190
through pre-defined things.

00:32:18.190 --> 00:32:23.170
Notice what happens if
I do the following.

00:32:23.170 --> 00:32:26.100
I could say I want to
change the radius of

00:32:26.100 --> 00:32:28.670
this particular thing.

00:32:28.670 --> 00:32:32.580
OK, perfectly reasonable
thing to do.

00:32:32.580 --> 00:32:39.110
And if I go look at the polar
form of this, OK, good, looks

00:32:39.110 --> 00:32:40.610
right, right?

00:32:40.610 --> 00:32:42.780
It's now got a different radius,
same angle, so I just

00:32:42.780 --> 00:32:44.730
changed the radius of it.

00:32:44.730 --> 00:32:46.560
Oh, but what happened to
the Cartesian form.

00:32:46.560 --> 00:32:47.930
I should have done this
earlier by typing the

00:32:47.930 --> 00:32:50.480
Cartesian form earlier, so let
me go back to where I was,

00:32:50.480 --> 00:32:58.020
sorry for that, let me go
make this a 1 again.

00:32:58.020 --> 00:33:00.290
If I look at the Cartesian, oh,
I did have the Cartesian

00:33:00.290 --> 00:33:05.030
form, don't mind me while I
mutter to myself here quietly.

00:33:05.030 --> 00:33:07.380
Yeah, that's right, I did
screw that up badly.

00:33:07.380 --> 00:33:10.630
All right, we try one more time,
here we go, let's try

00:33:10.630 --> 00:33:12.100
one more time.

00:33:12.100 --> 00:33:23.170
We'll make p a new point, ok?

00:33:23.170 --> 00:33:24.970
There's the Cartesian
representation of it, which is

00:33:24.970 --> 00:33:26.920
right, (1,2).

00:33:26.920 --> 00:33:30.690
Here's the polar representation
of it, some

00:33:30.690 --> 00:33:33.180
random set of numbers
which makes sense.

00:33:33.180 --> 00:33:37.090
If I now say, I'm going to go
ahead and change the radius of

00:33:37.090 --> 00:33:47.750
this, something, my polar form
did it right, but what

00:33:47.750 --> 00:33:53.420
happened to the Cartesian
form?

00:33:53.420 --> 00:33:56.920
Ah yes, didn't change.

00:33:56.920 --> 00:33:58.540
Which makes sense if you
think of my code.

00:33:58.540 --> 00:34:00.730
I didn't have anything in there
that says, if you change

00:34:00.730 --> 00:34:03.170
one of these values, other
values depend on it, and I

00:34:03.170 --> 00:34:05.000
want to make that
change to it.

00:34:05.000 --> 00:34:08.210
So this is one more example of
stressing why I only want to

00:34:08.210 --> 00:34:12.220
come access to the instances
through defined methods.

00:34:12.220 --> 00:34:14.320
Because I could've built that
in, it says if you change the

00:34:14.320 --> 00:34:16.190
value of this thing, by the
way you need to change

00:34:16.190 --> 00:34:19.830
recompute those other values in
order to make this hold up.

00:34:19.830 --> 00:34:23.460
OK, so what else do I have
then in my little class

00:34:23.460 --> 00:34:25.210
definitions here?

00:34:25.210 --> 00:34:28.890
So, I've got an init
in both cases.

00:34:28.890 --> 00:34:31.320
I don't have to put an init in,
but it's again, usually a

00:34:31.320 --> 00:34:33.090
good idea to put that
in originally.

00:34:33.090 --> 00:34:34.990
I've got and init that says,
when you create an instance,

00:34:34.990 --> 00:34:36.230
here's what you do.

00:34:36.230 --> 00:34:39.940
Notice that that typically also
defines for me what the

00:34:39.940 --> 00:34:42.650
internal variables are, what the
internal characteristics

00:34:42.650 --> 00:34:44.600
of the class are going to be.

00:34:44.600 --> 00:34:46.510
Again, I could have some other
functions to compute things,

00:34:46.510 --> 00:34:47.800
but this is typically
the place where I'm

00:34:47.800 --> 00:34:48.340
going to put them in.

00:34:48.340 --> 00:34:51.203
So this is giving me now that
template, better way of saying

00:34:51.203 --> 00:34:53.350
it, all right, a template
now, for a point is

00:34:53.350 --> 00:34:55.160
x, y, radius, angle.

00:34:55.160 --> 00:34:57.100
And I can see that in
those pieces there.

00:34:57.100 --> 00:35:00.560
And then I've got some things
that get me back out

00:35:00.560 --> 00:35:02.200
information about them.

00:35:02.200 --> 00:35:04.440
But I got a couple of other of
these strange looking things

00:35:04.440 --> 00:35:05.990
in there with underbars
to them.

00:35:05.990 --> 00:35:09.810
So let's look at what some of
the traditional methods for

00:35:09.810 --> 00:35:11.230
classes are in Python.

00:35:11.230 --> 00:35:15.500
I have init.

00:35:15.500 --> 00:35:22.320
This is what's actually going
to create the instance,

00:35:22.320 --> 00:35:24.560
instantiate it, create what
the set of variable

00:35:24.560 --> 00:35:26.430
values are for it.

00:35:26.430 --> 00:35:27.630
OK, I have another
one in there,

00:35:27.630 --> 00:35:32.590
underbar, underbar, str.

00:35:32.590 --> 00:35:38.480
Anybody have a sense of
what that's doing?

00:35:38.480 --> 00:35:41.470
What's s -- sorry, I heard
something, sorry go ahead.

00:35:41.470 --> 00:35:44.410
STUDENT: Display what I have.

00:35:44.410 --> 00:35:44.770
PROFESSOR: Displaying what
I have. Thank you.

00:35:44.770 --> 00:35:47.710
Yeah, I was going to say, think
about what does str do,

00:35:47.710 --> 00:35:48.240
in general?

00:35:48.240 --> 00:35:50.720
It converts things into
a string type.

00:35:50.720 --> 00:35:52.120
How do we typically
print things, we

00:35:52.120 --> 00:35:53.230
convert them to strings.

00:35:53.230 --> 00:35:59.080
So str is basically telling
us how we want to

00:35:59.080 --> 00:36:08.070
have it printed out.

00:36:08.070 --> 00:36:15.950
OK, in fact if we look at this,
if I say, print of p, it

00:36:15.950 --> 00:36:16.740
prints it out in that form.

00:36:16.740 --> 00:36:18.410
Now this is actually a poor
way to do it, because you

00:36:18.410 --> 00:36:20.240
might say, well, it's just the
list. But remember, it wasn't

00:36:20.240 --> 00:36:21.090
a list. What does it do?

00:36:21.090 --> 00:36:23.590
It says, if I want to print
out something I built in

00:36:23.590 --> 00:36:28.240
Cartesian form up here, says,
again, I'm going to pass it in

00:36:28.240 --> 00:36:31.180
a pointer to the instance, that
self thing, and then I'm

00:36:31.180 --> 00:36:34.670
going to return a string that
I combine together with an

00:36:34.670 --> 00:36:38.670
open and close paren, a comma in
the middle, and getting the

00:36:38.670 --> 00:36:41.320
x-value and the y-value and
converting them into strings

00:36:41.320 --> 00:36:43.280
before I put the whole
thing together.

00:36:43.280 --> 00:36:46.430
So it gives me basically my
printed representation.

00:36:46.430 --> 00:36:47.690
OK.

00:36:47.690 --> 00:36:49.430
What else do I have in here?

00:36:49.430 --> 00:36:54.100
Well, I have cmp.

00:36:54.100 --> 00:36:57.340
My handout's wrong, which I
discovered this morning after

00:36:57.340 --> 00:36:58.890
I printed them all out.

00:36:58.890 --> 00:37:07.530
So the version I'd like you to
have uses, that, greater than

00:37:07.530 --> 00:37:11.070
rather than equals that
I had in my handout.

00:37:11.070 --> 00:37:14.190
What's cmp doing as a method?

00:37:14.190 --> 00:37:14.500
Yeah?

00:37:14.500 --> 00:37:16.600
STUDENT: Comparing values?

00:37:16.600 --> 00:37:17.680
PROFESSOR: Yeah, comparing
values, right?

00:37:17.680 --> 00:37:20.160
And again, it's similar
to what cmp would do

00:37:20.160 --> 00:37:22.380
generically in Python.

00:37:22.380 --> 00:37:23.710
It's a way of doing
comparisons.

00:37:23.710 --> 00:37:29.570
So this is doing comparisons.

00:37:29.570 --> 00:37:31.820
Now, I put a version up there,
I have no idea if this is the

00:37:31.820 --> 00:37:33.210
right way to do comparisons
or not.

00:37:33.210 --> 00:37:35.590
I said both the x- and y-
coordinates are bigger, then

00:37:35.590 --> 00:37:36.990
I'm going to return
something to it.

00:37:36.990 --> 00:37:40.760
And I think in the polar one I
said, if, what did I do there,

00:37:40.760 --> 00:37:42.810
I said, yeah, again if the x
and y are greater than the

00:37:42.810 --> 00:37:45.420
other one, I'm going to
return them to it.

00:37:45.420 --> 00:37:50.400
The version in the handout, what
was that actually doing?

00:37:50.400 --> 00:37:56.900
You could look at the handout.

00:37:56.900 --> 00:38:00.680
Well I think it was comparing,
are they the same?

00:38:00.680 --> 00:38:08.620
So that would actually be
another method I could put in.

00:38:08.620 --> 00:38:11.680
Underbar underbar eq,
underbar underbar.

00:38:11.680 --> 00:38:14.110
Would be a default or generic
way of doing, are

00:38:14.110 --> 00:38:16.450
these things the same?

00:38:16.450 --> 00:38:23.050
OK, in each case, what these
things are doing, is they're

00:38:23.050 --> 00:38:32.090
doing, what sometimes gets
referred to as operator

00:38:32.090 --> 00:38:33.740
overloading.

00:38:33.740 --> 00:38:35.720
I know you don't remember that
far back, but in about the

00:38:35.720 --> 00:38:38.690
second lecture I made a joke of
Professor Guttag which, you

00:38:38.690 --> 00:38:40.640
know, you didn't laugh at, he
didn't laugh at, that's okay.

00:38:40.640 --> 00:38:43.660
In which I said, you know, I
didn't like the fact that

00:38:43.660 --> 00:38:45.790
things like plus are overloaded,
because you can

00:38:45.790 --> 00:38:48.690
use plus to add strings, you can
use plus to add numbers,

00:38:48.690 --> 00:38:50.350
you can use plus
to add floats.

00:38:50.350 --> 00:38:52.430
And he quite correctly, because
he's more senior than

00:38:52.430 --> 00:38:54.240
I am, more experienced
than I am, said it's

00:38:54.240 --> 00:38:55.750
actually a good thing.

00:38:55.750 --> 00:38:57.440
And he's right.

00:38:57.440 --> 00:38:59.050
Most of the time.

00:38:59.050 --> 00:39:02.050
The reason I say that is, by
having operator overloading I

00:39:02.050 --> 00:39:06.150
can use 1 generic interface
to all of the objects

00:39:06.150 --> 00:39:07.130
that I want to use.

00:39:07.130 --> 00:39:10.220
So it makes sense to be able to
say, look for many methods

00:39:10.220 --> 00:39:12.870
I do want to have a way of doing
comparison, and I don't

00:39:12.870 --> 00:39:16.370
have to remember, at top level,
what the name of the

00:39:16.370 --> 00:39:17.750
comparison method was.

00:39:17.750 --> 00:39:20.780
I can simply use the built-in
Sc -- about to say Scheme

00:39:20.780 --> 00:39:23.790
again -- the built-in Python
comparison operation.

00:39:23.790 --> 00:39:25.790
Say, are these 2 things
the same?

00:39:25.790 --> 00:39:27.890
Same thing with cmp, that's just
saying greater than, and

00:39:27.890 --> 00:39:30.540
greater than now can apply to
strings, it can apply to

00:39:30.540 --> 00:39:32.760
floats, it could apply to
points, it could add other

00:39:32.760 --> 00:39:34.110
pieces into it.

00:39:34.110 --> 00:39:36.560
So there are some downsides, in
my view, to doing operator

00:39:36.560 --> 00:39:38.010
overloading, but there's
some real pluses.

00:39:38.010 --> 00:39:41.270
And the main one is, I get to
just decide, how do I want to

00:39:41.270 --> 00:39:42.670
use this, and call it.

00:39:42.670 --> 00:39:43.050
Yes, ma'am?

00:39:43.050 --> 00:39:47.040
STUDENT: [INAUDIBLE]

00:39:47.040 --> 00:39:52.260
PROFESSOR: Right, cmp other,
so how would I call this?

00:39:52.260 --> 00:39:52.810
A good question.

00:39:52.810 --> 00:39:54.730
Here's the way I
would call it.

00:39:54.730 --> 00:39:59.400
Let me give you, I'm going to
create, a polar point, I'm

00:39:59.400 --> 00:40:02.960
going to call it q, and we'll
give it some random values.

00:40:02.960 --> 00:40:09.630
OK, and now I want to know,
is p greater than q?

00:40:09.630 --> 00:40:11.640
Now happens to return true here,
but the question is,

00:40:11.640 --> 00:40:13.130
where's the other come from?

00:40:13.130 --> 00:40:16.200
P is a particular object type.

00:40:16.200 --> 00:40:19.830
When I try and evaluate that
expression of greater than, is

00:40:19.830 --> 00:40:22.770
going to go into the class
to say greater

00:40:22.770 --> 00:40:25.020
than is a comp method.

00:40:25.020 --> 00:40:27.440
So let me say it very
carefully here.

00:40:27.440 --> 00:40:32.960
When I evaluate, yeah, when
I evaluate this, p is an

00:40:32.960 --> 00:40:35.780
instance of a point, in this
case it was actually a

00:40:35.780 --> 00:40:40.580
Cartesian point, it sends a
message to the instance, which

00:40:40.580 --> 00:40:44.950
sends a message to the
class, to get the cmp

00:40:44.950 --> 00:40:46.880
method from the class.

00:40:46.880 --> 00:40:51.930
And that then gets applied to
itself, just p, and one other

00:40:51.930 --> 00:40:55.110
argument, which is the second
piece there, so other points

00:40:55.110 --> 00:40:57.890
to the second argument
that was present.

00:40:57.890 --> 00:40:59.220
OK.

00:40:59.220 --> 00:40:59.650
John?

00:40:59.650 --> 00:41:02.530
PROFESSOR 2: -- other,
it could have said

00:41:02.530 --> 00:41:03.480
who or zort or --

00:41:03.480 --> 00:41:05.400
PROFESSOR: Yeah, sorry, that
was part of the question, I

00:41:05.400 --> 00:41:07.690
could have a picked foobar could
put anything in here.

00:41:07.690 --> 00:41:11.120
It's simply, notice the form of
it here is, it's going to

00:41:11.120 --> 00:41:13.060
take two arguments, and
you're right, self is

00:41:13.060 --> 00:41:14.140
the original instance.

00:41:14.140 --> 00:41:16.300
This says, I need a second
argument to it, and that

00:41:16.300 --> 00:41:18.120
second argument better be
a point so I can do the

00:41:18.120 --> 00:41:19.820
comparison.

00:41:19.820 --> 00:41:20.000
Yes ma'am?

00:41:20.000 --> 00:41:23.270
STUDENT: [INAUDIBLE]

00:41:23.270 --> 00:41:28.290
PROFESSOR: What do you
think happens?

00:41:28.290 --> 00:41:29.960
Sorry, the question was, what
happens if I said p

00:41:29.960 --> 00:41:31.330
is less than q?

00:41:31.330 --> 00:41:34.180
Got it, yes?

00:41:34.180 --> 00:41:40.330
Seems pretty obvious, right?

00:41:40.330 --> 00:41:48.810
Next time I bring the
right glasses.

00:41:48.810 --> 00:41:51.660
It's still calling cmp, but it's
knowing that cmp is just

00:41:51.660 --> 00:41:53.790
reversing the order
of the arguments.

00:41:53.790 --> 00:41:54.740
Ok, which makes sense.

00:41:54.740 --> 00:41:58.060
If greater than takes, expects,
arguments in order x

00:41:58.060 --> 00:42:01.510
y, less than simply takes
greater than, but with the

00:42:01.510 --> 00:42:02.980
arguments reversed.

00:42:02.980 --> 00:42:04.770
OK, so I don't have to, it's a
great question, I don't have

00:42:04.770 --> 00:42:06.150
to create a second
one for cmp.

00:42:06.150 --> 00:42:08.860
Cmp is just saying, is this
bigger than, and if I want to

00:42:08.860 --> 00:42:10.190
reverse it, it goes
the other way.

00:42:10.190 --> 00:42:10.560
Question?

00:42:10.560 --> 00:42:13.570
STUDENT: [INAUDIBLE]

00:42:13.570 --> 00:42:17.610
PROFESSOR: Or equal equal?

00:42:17.610 --> 00:42:25.310
Let's try equal equal because
I didn't define it here.

00:42:25.310 --> 00:42:28.920
It says they're not the same,
and boy, I need help on this

00:42:28.920 --> 00:42:32.500
one, John, it's not, there's
no pre-defined eq in there.

00:42:32.500 --> 00:42:37.252
PROFESSOR 2: So, what cmp does,
and maybe this isn't

00:42:37.252 --> 00:42:40.600
exactly the right way to write
is, is cmp actually returns 1

00:42:40.600 --> 00:42:42.630
of 3 values.

00:42:42.630 --> 00:42:48.760
A 0, minus a positive value,
zero or a negative value,

00:42:48.760 --> 00:42:50.840
depending upon whether
it's less than,

00:42:50.840 --> 00:42:52.080
equal, or greater than.

00:42:52.080 --> 00:42:52.800
PROFESSOR: Right.

00:42:52.800 --> 00:42:56.150
PROFESSOR2: So it's not really
a Boolean-valued function.

00:42:56.150 --> 00:42:59.590
It has 3 possible values
it could return.

00:42:59.590 --> 00:43:01.840
PROFESSOR: And so in this case,
it's using the same

00:43:01.840 --> 00:43:04.250
piece, but it's returning that
middle value that says they're

00:43:04.250 --> 00:43:07.020
actually the same.

00:43:07.020 --> 00:43:09.480
Right, one the things you can
see now is, we start building

00:43:09.480 --> 00:43:10.860
up classes, we get
these methods.

00:43:10.860 --> 00:43:13.120
So you can actually say, how
do I know which methods are

00:43:13.120 --> 00:43:14.840
associated with the class?

00:43:14.840 --> 00:43:20.020
For that, we can call dir.

00:43:20.020 --> 00:43:25.220
And what it does, is it gives
me back a listing of all the

00:43:25.220 --> 00:43:27.750
things, all the methods, that
are associated with it.

00:43:27.750 --> 00:43:32.740
Some of which I built:
cmp, init, str.

00:43:32.740 --> 00:43:35.220
And there, notice, are the
internal definitions and there

00:43:35.220 --> 00:43:37.270
are the internal variables.

00:43:37.270 --> 00:43:38.850
And in fact I should've
said, we often call

00:43:38.850 --> 00:43:40.320
those things fields.

00:43:40.320 --> 00:43:45.880
So inside of an instance,
associated with an instance,

00:43:45.880 --> 00:43:51.630
we have both methods
and fields.

00:43:51.630 --> 00:43:53.660
These are both altogether
called

00:43:53.660 --> 00:43:56.710
attributes of the instance.

00:43:56.710 --> 00:43:58.330
And then there were a couple of
other ones in there that I

00:43:58.330 --> 00:44:00.650
hadn't actually dealt with.

00:44:00.650 --> 00:44:02.810
The reason I want to point this
out to you is, if we go

00:44:02.810 --> 00:44:05.280
back up to the kinds of data
objects we started with,

00:44:05.280 --> 00:44:09.890
floats, ints, strings, they
actually behave the same way.

00:44:09.890 --> 00:44:13.600
They are instances of a class,
and associated with that class

00:44:13.600 --> 00:44:14.780
is a set of methods.

00:44:14.780 --> 00:44:19.990
So for example, I can say,
what are all the methods

00:44:19.990 --> 00:44:24.370
associated with the number,
or the integer 1?

00:44:24.370 --> 00:44:26.500
And you probably recognize some
of them in there, right,

00:44:26.500 --> 00:44:30.800
absolute value, add, comp, cors,
well we didn't do cors,

00:44:30.800 --> 00:44:32.880
we did a bunch of
other things.

00:44:32.880 --> 00:44:38.340
It could also say, what are the
methods associated with

00:44:38.340 --> 00:44:42.520
the string, 1.

00:44:42.520 --> 00:44:44.220
I'm sure you can quickly
graph it, but notice

00:44:44.220 --> 00:44:46.570
they aren't the same.

00:44:46.570 --> 00:44:47.850
That makes sense.

00:44:47.850 --> 00:44:50.120
We have some set of things we
want to do with strings, and

00:44:50.120 --> 00:44:52.120
different set of things we
want to do with numbers.

00:44:52.120 --> 00:44:54.450
But underlying Python
is the same idea.

00:44:54.450 --> 00:44:57.960
These are instances of a class,
and associated with

00:44:57.960 --> 00:44:59.800
that class are a set
of methods, things

00:44:59.800 --> 00:45:01.160
that I can deal with.

00:45:01.160 --> 00:45:03.640
So this is a handy way of being
able to see, what are in

00:45:03.640 --> 00:45:05.700
fact the methods that are
available if I don't happen to

00:45:05.700 --> 00:45:08.890
remember them, and want
to go back to them.

00:45:08.890 --> 00:45:12.250
OK, I want to spend the last few
minutes just showing you a

00:45:12.250 --> 00:45:15.710
couple of other things that
we can do in here.

00:45:15.710 --> 00:45:17.110
Let me see where I want
to go with this.

00:45:17.110 --> 00:45:23.070
So let's add one more
piece to this.

00:45:23.070 --> 00:45:26.460
OK, now that I've got points,
I might want to do something

00:45:26.460 --> 00:45:27.580
with points.

00:45:27.580 --> 00:45:29.700
So an easy thing to do in planar
geometry is I want to

00:45:29.700 --> 00:45:30.830
make a line segment.

00:45:30.830 --> 00:45:32.280
It's got a start point,
it's got an end point.

00:45:32.280 --> 00:45:40.190
Right, if you want to think
of it back over here.

00:45:40.190 --> 00:45:43.273
There's a line segment, it's
got a starting point and

00:45:43.273 --> 00:45:44.510
ending point.

00:45:44.510 --> 00:45:45.830
Well, I can do the same thing.

00:45:45.830 --> 00:45:48.570
And the reason I want to use
this as an example is, here's

00:45:48.570 --> 00:45:51.020
my little definition
of segment.

00:45:51.020 --> 00:45:53.600
Again, it's got an initializer,
or an instance

00:45:53.600 --> 00:45:56.290
creator, right there.

00:45:56.290 --> 00:45:58.670
Takes a start and an end point,
just going to bind

00:45:58.670 --> 00:46:01.930
local variable names start
and end to those pieces.

00:46:01.930 --> 00:46:04.940
But notice now, those aren't
just simple things like

00:46:04.940 --> 00:46:08.190
numbers, those are
actually points.

00:46:08.190 --> 00:46:09.850
And that's where the modularity
comes in.

00:46:09.850 --> 00:46:12.740
Now I have the ability to say,
I've got a new class, I can

00:46:12.740 --> 00:46:15.720
create instances of a line
segment, and it's elements are

00:46:15.720 --> 00:46:19.140
themselves instances of points.

00:46:19.140 --> 00:46:20.090
OK?

00:46:20.090 --> 00:46:21.910
And then what might I want
to do with the segment?

00:46:21.910 --> 00:46:23.750
I might want to get the
length of the segment.

00:46:23.750 --> 00:46:25.620
And I know it's kind of, you can
see it on your handout, it

00:46:25.620 --> 00:46:28.310
has the rest of the
pieces over here.

00:46:28.310 --> 00:46:29.530
Ok, what's the geometry say?

00:46:29.530 --> 00:46:30.820
The length of a line segment?

00:46:30.820 --> 00:46:32.170
Well, it's Pythagoras, right?

00:46:32.170 --> 00:46:34.770
I take the difference in the
x-values, squared, the

00:46:34.770 --> 00:46:36.790
difference in the y-values,
squared, add them up, take the

00:46:36.790 --> 00:46:38.240
square root of that.

00:46:38.240 --> 00:46:41.020
Notice what this says to do.

00:46:41.020 --> 00:46:43.270
It says if I want to get the
length of a segment, going to

00:46:43.270 --> 00:46:49.140
pass in that instance, it says
from that instance, get the

00:46:49.140 --> 00:46:51.930
start point, that's the
thing I just found.

00:46:51.930 --> 00:46:56.870
And then from that start
point, get the x-value.

00:46:56.870 --> 00:46:59.460
Same thing, from that instance,
get the endpoint,

00:46:59.460 --> 00:47:02.860
from that end point get
the x-value, square.

00:47:02.860 --> 00:47:05.550
Add the same thing to the
y-values, squared, take the

00:47:05.550 --> 00:47:07.470
square root.

00:47:07.470 --> 00:47:07.940
Yes, ma'am?

00:47:07.940 --> 00:47:13.870
STUDENT: So are you entering a
tuple in for start and end?

00:47:13.870 --> 00:47:14.060
PROFESSOR: No.

00:47:14.060 --> 00:47:15.180
I'm entering -- well,
let's look at the

00:47:15.180 --> 00:47:17.770
example right down here.

00:47:17.770 --> 00:47:20.950
In fact, let me uncomment
it so we can look at it.

00:47:20.950 --> 00:47:22.282
All right.

00:47:22.282 --> 00:47:24.020
I'm going to uncomment that.

00:47:24.020 --> 00:47:25.790
So notice what I'm
going to do.

00:47:25.790 --> 00:47:28.804
I'm going to build, this case,
a Cartesian point, I'm going

00:47:28.804 --> 00:47:32.250
to build a second Cartesian
point, and my segment passes

00:47:32.250 --> 00:47:35.080
in those class instances.

00:47:35.080 --> 00:47:36.860
All right, they're not tuples,
they're simply an instance

00:47:36.860 --> 00:47:37.530
with some structuring.

00:47:37.530 --> 00:47:42.830
And in fact if I go off and
run this, OK, what I was

00:47:42.830 --> 00:47:48.700
printing here was s 1 dot
length, and that's --

00:47:48.700 --> 00:47:49.950
What is it doing?

00:47:49.950 --> 00:47:51.240
S 1 is a segment.

00:47:51.240 --> 00:47:53.550
It has inside of it
pointers to 2

00:47:53.550 --> 00:47:55.470
points which are instances.

00:47:55.470 --> 00:47:59.750
And when I call length on this,
it takes that starting

00:47:59.750 --> 00:48:01.590
point, sends it the message
saying give me your

00:48:01.590 --> 00:48:04.470
x-coordinate, takes the
endpoint, says give me your

00:48:04.470 --> 00:48:06.920
x-coordinate, and add
them together.

00:48:06.920 --> 00:48:08.930
Now, I prefaced this a few
minutes ago about saying

00:48:08.930 --> 00:48:10.380
Professor Guttag wasn't
going to like me.

00:48:10.380 --> 00:48:12.300
He doesn't like me generally,
but that's between he and I.

00:48:12.300 --> 00:48:14.060
He beats me regularly at
tennis, which is why

00:48:14.060 --> 00:48:15.470
I don't like him.

00:48:15.470 --> 00:48:16.430
Sorry, John.

00:48:16.430 --> 00:48:18.760
This is being taped, which
is really good, isn't it?

00:48:18.760 --> 00:48:19.860
So why am I saying that?

00:48:19.860 --> 00:48:23.950
I said that if I was really
hygienic, and you can now

00:48:23.950 --> 00:48:25.870
wonder about how often
do I shower?

00:48:25.870 --> 00:48:27.910
If I was really hygienic.

00:48:27.910 --> 00:48:32.880
I would only ever access the
values through a method.

00:48:32.880 --> 00:48:35.950
And I'm cheating here, right,
because what am I doing?

00:48:35.950 --> 00:48:39.080
I'm taking advantage of the fact
that start is going to be

00:48:39.080 --> 00:48:43.170
a point, and I'm just directly
saying, give me your x-value.

00:48:43.170 --> 00:48:44.880
So I don't know don't, John, I
would argue if I'd written

00:48:44.880 --> 00:48:47.660
this better, I would have had a
method that returned the x-

00:48:47.660 --> 00:48:49.310
and the y- value, and it
would be cleaner to go

00:48:49.310 --> 00:48:50.920
after it that way.

00:48:50.920 --> 00:48:53.400
This is nice shorthand, all
right, but it's something that

00:48:53.400 --> 00:48:57.490
in fact I probably would
want to do differently.

00:48:57.490 --> 00:48:59.850
Why would I want to
do it differently?

00:48:59.850 --> 00:49:02.180
Imagine that I've written
code like this,

00:49:02.180 --> 00:49:04.120
written a bunch of code.

00:49:04.120 --> 00:49:06.740
And I originally decided I was
going to have as points, it's

00:49:06.740 --> 00:49:09.740
going to have internal values
of an x and a y.

00:49:09.740 --> 00:49:12.080
And then somewhere along the
line, I decide to store things

00:49:12.080 --> 00:49:14.580
in a different representation.

00:49:14.580 --> 00:49:17.580
If I had had a clean interface,
that I had a

00:49:17.580 --> 00:49:20.840
specific method to get those
values out, I wouldn't have to

00:49:20.840 --> 00:49:22.100
change anything.

00:49:22.100 --> 00:49:24.500
Other than that interface.

00:49:24.500 --> 00:49:26.990
But here, if I decide I'm going
to store things not in x

00:49:26.990 --> 00:49:30.060
and y, but with some other set
of names, for example, I've

00:49:30.060 --> 00:49:32.390
gotta go back into these pieces
of code that use the

00:49:32.390 --> 00:49:34.290
points, and change them.

00:49:34.290 --> 00:49:35.530
So I've lost modularity.

00:49:35.530 --> 00:49:38.770
I'd really like to have that
modularity that says, I'm only

00:49:38.770 --> 00:49:41.860
going to get access to the
values, not by calling their

00:49:41.860 --> 00:49:44.700
names, but by calling some
specific method to get access

00:49:44.700 --> 00:49:46.170
to their names.

00:49:46.170 --> 00:49:48.695
You could argue, well, x is
in some sense inherently a

00:49:48.695 --> 00:49:52.160
method, but it's not nearly as
clean as what I would like.

00:49:52.160 --> 00:49:54.220
And the last piece I want you to
see here, and then I'll let

00:49:54.220 --> 00:49:59.350
you go is, notice now how that
encapsulation, that binding

00:49:59.350 --> 00:50:01.620
things together has
really helped me.

00:50:01.620 --> 00:50:03.930
Given the abstraction, the
notion of a point as an

00:50:03.930 --> 00:50:05.600
instance with some
values, I can now

00:50:05.600 --> 00:50:07.020
start building segments.

00:50:07.020 --> 00:50:08.060
And I could now extend that.

00:50:08.060 --> 00:50:10.140
I could have, you know,
polygonal figures, that are a

00:50:10.140 --> 00:50:11.690
sequence of segments.

00:50:11.690 --> 00:50:14.500
And I would be able to simply
bury away the details of how

00:50:14.500 --> 00:50:17.220
those other instances are
created from how I want to use

00:50:17.220 --> 00:50:20.920
them by simply calling methods
on the classes.

00:50:20.920 --> 00:50:23.120
We'll come back to
this next time.