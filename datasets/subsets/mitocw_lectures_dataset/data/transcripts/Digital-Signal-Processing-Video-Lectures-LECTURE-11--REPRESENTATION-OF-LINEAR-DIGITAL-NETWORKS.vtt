WEBVTT

00:00:00.090 --> 00:00:02.490
The following content is
provided under a Creative

00:00:02.490 --> 00:00:04.030
Commons license.

00:00:04.030 --> 00:00:06.330
Your support will help
MIT OpenCourseWare

00:00:06.330 --> 00:00:10.720
continue to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.320
To make a donation or
view additional materials

00:00:13.320 --> 00:00:17.280
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.280 --> 00:00:18.450
at ocw.mit.edu.

00:00:24.344 --> 00:00:27.780
[MUSIC PLAYING]

00:00:55.796 --> 00:00:58.410
ALAN OPPENHEIM: In several
of the previous lessons,

00:00:58.410 --> 00:01:01.220
we've focused
primarily on the class

00:01:01.220 --> 00:01:04.170
of linear shift-invariant
systems that

00:01:04.170 --> 00:01:07.530
are representable by linear
constant coefficient difference

00:01:07.530 --> 00:01:08.650
equations.

00:01:08.650 --> 00:01:12.420
And we've talked, for example,
about methods for solving

00:01:12.420 --> 00:01:15.490
that class of equations.

00:01:15.490 --> 00:01:19.650
One of the reasons why a linear
constant coefficient difference

00:01:19.650 --> 00:01:23.220
equations represent a
particularly important class

00:01:23.220 --> 00:01:26.850
of discrete time systems
is because of the fact

00:01:26.850 --> 00:01:32.010
that they have a particularly
straightforward implementation

00:01:32.010 --> 00:01:35.530
in terms of digital components.

00:01:35.530 --> 00:01:40.590
So in this lecture, and actually
over the next several lectures,

00:01:40.590 --> 00:01:45.810
what I'd like to
focus on is that class

00:01:45.810 --> 00:01:48.000
of linear
shift-invariant systems

00:01:48.000 --> 00:01:50.610
and in particular
the implementation

00:01:50.610 --> 00:01:54.000
of that class of
systems, in other words,

00:01:54.000 --> 00:01:58.650
digital networks for the
implementation of systems

00:01:58.650 --> 00:02:01.370
describable by linear constant
coefficient difference

00:02:01.370 --> 00:02:03.210
equations.

00:02:03.210 --> 00:02:08.310
Well, as we have
defined previously,

00:02:08.310 --> 00:02:12.720
an n-th order linear constant
coefficient difference equation

00:02:12.720 --> 00:02:18.000
essentially corresponds
to a linear combination

00:02:18.000 --> 00:02:26.100
of delayed output sequences set
equal to a linear combination

00:02:26.100 --> 00:02:28.840
of delayed input sequences.

00:02:28.840 --> 00:02:32.310
This is the general form for
a linear constant coefficient

00:02:32.310 --> 00:02:36.690
difference equation,
which as we discussed

00:02:36.690 --> 00:02:41.580
in one of the early
lectures, actually Lesson 3,

00:02:41.580 --> 00:02:44.610
corresponds to an
explicit input output

00:02:44.610 --> 00:02:46.150
description for the system.

00:02:46.150 --> 00:02:50.340
In other words, we can
solve this equation

00:02:50.340 --> 00:02:54.360
by taking this set of terms
over to the right-hand side

00:02:54.360 --> 00:02:55.650
of the equation.

00:02:55.650 --> 00:02:57.600
And the difference
equation that results

00:02:57.600 --> 00:03:00.930
is a statement that
says that y of n,

00:03:00.930 --> 00:03:03.720
the output sequence
for the system,

00:03:03.720 --> 00:03:07.920
is a linear combination
of past outputs

00:03:07.920 --> 00:03:14.140
plus a linear combination
of delayed inputs.

00:03:14.140 --> 00:03:17.550
Now, we also discussed
at that point

00:03:17.550 --> 00:03:20.070
in one of the early
lectures the fact

00:03:20.070 --> 00:03:22.410
that a linear constant
coefficient difference

00:03:22.410 --> 00:03:26.140
equation is not a unique
description for a system.

00:03:26.140 --> 00:03:30.690
In other words, we saw that
this system, or a system that

00:03:30.690 --> 00:03:34.980
satisfies this equation, could
correspond to a causal system.

00:03:34.980 --> 00:03:38.980
Or, in fact, it could correspond
to a non-causal system,

00:03:38.980 --> 00:03:42.030
depending on the initial
conditions or the boundary

00:03:42.030 --> 00:03:45.540
conditions that we
impose on the equation.

00:03:45.540 --> 00:03:51.300
We could in particular impose
the boundary conditions implied

00:03:51.300 --> 00:03:53.760
by the statement that
the system is causal,

00:03:53.760 --> 00:03:56.400
or we could impose
boundary conditions

00:03:56.400 --> 00:04:00.480
implied by the statement that
the system is non-causal.

00:04:00.480 --> 00:04:03.450
For this discussion, for the
discussion in this lecture

00:04:03.450 --> 00:04:06.000
and actually over the
next several lectures,

00:04:06.000 --> 00:04:08.910
the assumption will
always be that we're

00:04:08.910 --> 00:04:12.160
talking about a causal system.

00:04:12.160 --> 00:04:15.630
In other words, the boundary
conditions that we're imposing

00:04:15.630 --> 00:04:22.110
is that for the input 0
for n less than, say, n1,

00:04:22.110 --> 00:04:26.470
the output will also be
0 for n less than n1.

00:04:26.470 --> 00:04:30.120
So we're implying a set
of boundary conditions

00:04:30.120 --> 00:04:32.970
by virtue of the fact that
we're assuming that we're

00:04:32.970 --> 00:04:35.710
talking about causal systems.

00:04:35.710 --> 00:04:39.510
Now, in implementing
a system describable

00:04:39.510 --> 00:04:43.500
by a difference equation
of this form, what we see

00:04:43.500 --> 00:04:48.800
is that there are three basic
operations that are involved.

00:04:48.800 --> 00:04:53.450
We have to somehow
generate delayed sequences.

00:04:53.450 --> 00:04:56.270
We have to get y of n delayed.

00:04:56.270 --> 00:04:58.010
We have to get x of n delayed.

00:04:58.010 --> 00:05:03.030
So one of the basic operations
is the operation of delay.

00:05:03.030 --> 00:05:07.580
Furthermore, we need to
multiply these delayed sequences

00:05:07.580 --> 00:05:12.020
by scalars and these delayed
sequences by scalars.

00:05:12.020 --> 00:05:17.150
So there is the additional
operation of multiplication.

00:05:17.150 --> 00:05:20.750
And third, we have to
accumulate these sums,

00:05:20.750 --> 00:05:23.610
or accumulate these products.

00:05:23.610 --> 00:05:27.680
And so the third
operation that is required

00:05:27.680 --> 00:05:30.380
in the implementation of a
linear constant coefficient

00:05:30.380 --> 00:05:35.390
difference equation is
the operation of addition.

00:05:35.390 --> 00:05:39.890
Consequently, if we were to
think of basic digital network

00:05:39.890 --> 00:05:46.340
elements, we could choose
as our basic elements

00:05:46.340 --> 00:05:51.610
the operations corresponding
to delay, multiplication,

00:05:51.610 --> 00:05:53.770
and addition.

00:05:53.770 --> 00:05:57.220
In particular what we'd like
to develop, or generate,

00:05:57.220 --> 00:06:02.330
is a graphical representation
of the difference equation,

00:06:02.330 --> 00:06:05.450
which is what we'll refer
to as the digital network.

00:06:05.450 --> 00:06:08.920
So in essence, what we want
is a graphical representation

00:06:08.920 --> 00:06:12.310
of these three operations,
which we'll combine together

00:06:12.310 --> 00:06:15.680
into a digital network.

00:06:15.680 --> 00:06:19.340
One type of notation,
which is essentially

00:06:19.340 --> 00:06:22.460
block diagram
notation, corresponds

00:06:22.460 --> 00:06:31.840
to representing the
operation of delay as a box.

00:06:31.840 --> 00:06:34.270
The input, of course,
is the sequence

00:06:34.270 --> 00:06:38.600
that we want to delay,
let's say, x of n.

00:06:38.600 --> 00:06:42.680
And the output then is
that sequence delayed

00:06:42.680 --> 00:06:47.505
by one sample, x of n minus 1.

00:06:47.505 --> 00:06:50.250
And typically in the
block diagram type

00:06:50.250 --> 00:06:58.710
of representation, this element,
or block, is denoted with a z

00:06:58.710 --> 00:07:00.892
to the minus 1.

00:07:00.892 --> 00:07:03.500
Well, what does z
to the minus 1 have

00:07:03.500 --> 00:07:06.890
to do with the
operation of delay?

00:07:06.890 --> 00:07:12.170
Simply that if we were to think
of the z transform of the input

00:07:12.170 --> 00:07:15.770
sequence and the z transform
of the output sequence,

00:07:15.770 --> 00:07:18.540
what we know is that
those are related,

00:07:18.540 --> 00:07:23.690
in fact, by multiplication
by z to the minus 1.

00:07:23.690 --> 00:07:28.910
So the implication in
putting inside the box

00:07:28.910 --> 00:07:32.630
the notation z to the
minus 1, the implication

00:07:32.630 --> 00:07:35.570
is that essentially
what this block is doing

00:07:35.570 --> 00:07:40.010
is multiplying the z transform
of the input sequence by z

00:07:40.010 --> 00:07:42.380
to the minus 1.

00:07:42.380 --> 00:07:44.270
So that's one element.

00:07:44.270 --> 00:07:46.670
The second element
that we need is

00:07:46.670 --> 00:07:49.820
the element for multiplication.

00:07:49.820 --> 00:07:53.180
And typically,
that's denoted simply

00:07:53.180 --> 00:07:56.900
by a line with an arrow on it.

00:07:56.900 --> 00:08:00.370
The input to this
branch is x of n.

00:08:03.320 --> 00:08:05.360
Or it could be,
of course, y of n.

00:08:05.360 --> 00:08:09.830
The output of the branch is that
multiplied by a scalar, let's

00:08:09.830 --> 00:08:12.200
say, a, the scalar a.

00:08:12.200 --> 00:08:14.840
And this should be x of n.

00:08:14.840 --> 00:08:16.610
If we're talking
about x of n in,

00:08:16.610 --> 00:08:20.450
we're talking about x of n
out, or a times x of n out.

00:08:20.450 --> 00:08:25.490
And the branch transmittance
then is the coefficient a.

00:08:25.490 --> 00:08:29.780
So this branch allows for
coefficient multiplication.

00:08:29.780 --> 00:08:33.650
And finally the third
element that we want

00:08:33.650 --> 00:08:36.830
is an element that
will perform addition.

00:08:36.830 --> 00:08:41.720
And that element is the noted
in block diagram notation

00:08:41.720 --> 00:08:48.140
as a summer with two
inputs and a single output.

00:08:48.140 --> 00:08:53.300
The input, let's say, x1
and x2, then the output

00:08:53.300 --> 00:08:59.240
would be x1 plus x2
of n or z, depending

00:08:59.240 --> 00:09:02.660
on how we choose to
describe the sequence.

00:09:02.660 --> 00:09:06.080
Now in the difference
equation, of course,

00:09:06.080 --> 00:09:09.167
we had to accumulate
a number of turns.

00:09:09.167 --> 00:09:11.000
In other words, there
was more than one term

00:09:11.000 --> 00:09:13.310
that we were adding up.

00:09:13.310 --> 00:09:15.770
Typically, in either
digital hardware

00:09:15.770 --> 00:09:20.060
or on a digital computer,
when we're forming additions,

00:09:20.060 --> 00:09:21.770
the additions are
formed in pairs.

00:09:21.770 --> 00:09:28.490
In other words, we accumulate
a large number of terms

00:09:28.490 --> 00:09:31.370
by adding two terms together,
then adding one to that

00:09:31.370 --> 00:09:33.410
and adding another
one to that, etc.

00:09:33.410 --> 00:09:38.960
So it's convenient in that
sense to think of the addition

00:09:38.960 --> 00:09:42.050
as always being a two
input one output addition.

00:09:42.050 --> 00:09:44.690
Of course, if we
accumulate three terms,

00:09:44.690 --> 00:09:48.420
then it would require
two adders to do that.

00:09:48.420 --> 00:09:50.730
So these then are
the basic elements

00:09:50.730 --> 00:09:53.400
that correspond
to a block diagram

00:09:53.400 --> 00:09:56.730
representation of a linear
constant coefficient difference

00:09:56.730 --> 00:10:00.060
equation, or
equivalently correspond

00:10:00.060 --> 00:10:01.800
to a digital network.

00:10:01.800 --> 00:10:05.370
And for example, if we had
a first order difference

00:10:05.370 --> 00:10:09.240
equation, let's say
the equation y of n

00:10:09.240 --> 00:10:14.190
is equal to a times y
of minus 1 plus x of n,

00:10:14.190 --> 00:10:17.430
we can represent that
equation graphically

00:10:17.430 --> 00:10:22.690
in terms of these elements
as I've indicated here.

00:10:22.690 --> 00:10:24.250
So what do we have?

00:10:24.250 --> 00:10:31.810
Well, we have as an input x
of n, as an output y of n.

00:10:31.810 --> 00:10:36.200
We need in implementing
this difference equation

00:10:36.200 --> 00:10:38.930
to obtain y of n minus 1.

00:10:38.930 --> 00:10:43.490
And that's obtained
with the delay element.

00:10:43.490 --> 00:10:46.100
y of n minus 1 is
then multiplied

00:10:46.100 --> 00:10:48.140
by the coefficient a.

00:10:48.140 --> 00:10:51.410
So here, we have a
times y of n minus 1.

00:10:51.410 --> 00:10:54.320
And then the difference
equation states that y of n

00:10:54.320 --> 00:10:57.020
is the sum of that
with the input.

00:10:57.020 --> 00:10:58.910
And so that goes into the adder.

00:10:58.910 --> 00:11:00.920
And out comes y of n.

00:11:00.920 --> 00:11:07.340
So this then corresponds to a
block diagram representation

00:11:07.340 --> 00:11:10.650
of the difference
equation, or equivalently,

00:11:10.650 --> 00:11:15.590
a digital network in
block diagram notation.

00:11:15.590 --> 00:11:18.530
This notation, in fact,
is a very common type

00:11:18.530 --> 00:11:21.800
of notation for graphically
representing a difference

00:11:21.800 --> 00:11:23.900
equation, or digital network.

00:11:23.900 --> 00:11:26.600
There is an
alternative notation,

00:11:26.600 --> 00:11:30.830
which has a number of
important advantages, which

00:11:30.830 --> 00:11:34.490
is very much like the
block diagram with just

00:11:34.490 --> 00:11:39.500
a few minor changes, which
turn out in some instances

00:11:39.500 --> 00:11:40.610
to be convenient.

00:11:40.610 --> 00:11:43.580
And that is the
graphical representation

00:11:43.580 --> 00:11:47.390
of the difference equation,
or the digital network,

00:11:47.390 --> 00:11:52.370
in terms of signal flow graphs.

00:11:52.370 --> 00:11:56.880
Well let me introduce the
notation of signal flow graphs

00:11:56.880 --> 00:11:59.780
first in general and then
more specifically as it

00:11:59.780 --> 00:12:02.510
applies to your constant
coefficient difference

00:12:02.510 --> 00:12:04.690
equations.

00:12:04.690 --> 00:12:10.070
A signal flow graph is
essentially by definition

00:12:10.070 --> 00:12:17.030
a network of directed branches,
which are connected at nodes.

00:12:17.030 --> 00:12:22.550
So what that says is that in
a signal flow graph we have

00:12:22.550 --> 00:12:27.260
what will refer to
as nodes and directed

00:12:27.260 --> 00:12:33.470
branches, in other words
branches with arrows on them.

00:12:33.470 --> 00:12:37.460
The nodes will be numbered.

00:12:37.460 --> 00:12:44.510
And so, for example, we would
have a node j and a node k.

00:12:47.040 --> 00:12:49.600
Furthermore, each
node in the network

00:12:49.600 --> 00:12:52.110
has a variable
associated with it.

00:12:52.110 --> 00:12:56.240
So that, for example the j
node has the variable w sub j.

00:12:56.240 --> 00:12:58.880
The k node has the
variable w sub k.

00:13:01.680 --> 00:13:06.660
And we have a branch going
between the j-th node

00:13:06.660 --> 00:13:09.540
and the k-th node,
which will be referred

00:13:09.540 --> 00:13:14.020
to as the jk-th branch.

00:13:14.020 --> 00:13:16.570
So essentially the
numbering of the nodes

00:13:16.570 --> 00:13:18.640
allows us to refer
to the nodes and also

00:13:18.640 --> 00:13:22.030
to refer to the branches,
referring to the branches

00:13:22.030 --> 00:13:27.790
by talking about which nodes
the branches go between.

00:13:27.790 --> 00:13:29.230
The nodes that
I've indicated here

00:13:29.230 --> 00:13:33.670
correspond to what we'll
refer to as network nodes.

00:13:33.670 --> 00:13:37.540
There are also source nodes.

00:13:37.540 --> 00:13:39.070
And I've indicated one here.

00:13:39.070 --> 00:13:43.780
A source node is a node that
has no branches coming into it,

00:13:43.780 --> 00:13:46.450
only branches leaving it.

00:13:46.450 --> 00:13:50.900
And the opposite,
namely a sink node,

00:13:50.900 --> 00:13:54.760
which is a node that has
no branches going out

00:13:54.760 --> 00:13:57.130
of it and only branches
coming into it.

00:13:57.130 --> 00:14:00.010
Basically, it's
these type of nodes

00:14:00.010 --> 00:14:02.830
that allow us to get
inputs into the network.

00:14:02.830 --> 00:14:07.840
It's this type of node that
we use to represent outputs

00:14:07.840 --> 00:14:10.480
from the network.

00:14:10.480 --> 00:14:13.710
Now, this defines
essentially the notation.

00:14:13.710 --> 00:14:18.330
It doesn't yet specify what
the algebraic construction

00:14:18.330 --> 00:14:20.580
of a signal flow graph is.

00:14:20.580 --> 00:14:24.150
So in particular,
there are some rules

00:14:24.150 --> 00:14:27.930
that tell us how the node
variables are related

00:14:27.930 --> 00:14:30.330
to inputs and
outputs of branches

00:14:30.330 --> 00:14:35.680
or equivalently the inputs
and outputs of other nodes.

00:14:35.680 --> 00:14:38.730
A branch, the
jk-th branch, which

00:14:38.730 --> 00:14:42.540
originate at node j,
terminates at node k,

00:14:42.540 --> 00:14:47.580
has as its input, the
variable of the node

00:14:47.580 --> 00:14:51.570
that it originates from.

00:14:51.570 --> 00:14:53.570
It also has an output.

00:14:53.570 --> 00:14:57.450
The output we will
denote as v sub jk.

00:14:57.450 --> 00:15:00.180
That's the output
of the jk-th branch.

00:15:00.180 --> 00:15:03.920
And what it is very simply
in the most general sense,

00:15:03.920 --> 00:15:08.130
the most general
context, is some function

00:15:08.130 --> 00:15:10.420
of the input to the branch.

00:15:10.420 --> 00:15:13.500
So the output of a
branch is some function

00:15:13.500 --> 00:15:16.290
of the input to
the branch, where

00:15:16.290 --> 00:15:20.940
this function is different, of
course, for different branches.

00:15:20.940 --> 00:15:26.640
Finally, to get the values
of the node variables,

00:15:26.640 --> 00:15:30.570
the node values
are defined to be

00:15:30.570 --> 00:15:35.910
equal to the sum of the
outputs of the branches

00:15:35.910 --> 00:15:38.460
entering the node.

00:15:38.460 --> 00:15:43.020
So that if we were to
look up here, for example,

00:15:43.020 --> 00:15:49.980
this node variable would
be equal to the output

00:15:49.980 --> 00:15:53.410
of this branch plus the
output of that branch.

00:15:53.410 --> 00:15:55.950
And that's essentially
the algebraic construction

00:15:55.950 --> 00:15:58.650
of flow graphs.

00:15:58.650 --> 00:16:03.420
It's also convenient to
separate notationally

00:16:03.420 --> 00:16:07.560
the output of the branches
from an internal node

00:16:07.560 --> 00:16:09.750
to another internal
node, or from a network

00:16:09.750 --> 00:16:14.910
node to a network node, from the
output of those branches that

00:16:14.910 --> 00:16:19.050
originate at sources
and go to network nodes.

00:16:19.050 --> 00:16:24.780
And the notation that we'll
use is sub jk corresponding

00:16:24.780 --> 00:16:29.797
to the output of the branch
that goes from the j-th source--

00:16:29.797 --> 00:16:31.380
the sources being
numbered differently

00:16:31.380 --> 00:16:32.730
from the network nodes--

00:16:32.730 --> 00:16:38.590
going from the j-th source
to the k-th network node.

00:16:38.590 --> 00:16:44.770
OK, so what this says, and this
equation in particular says,

00:16:44.770 --> 00:16:49.540
that algebraically
the node variables

00:16:49.540 --> 00:16:55.780
are specified as the
k-th node variable

00:16:55.780 --> 00:17:03.430
being equal to the sum over the
internal nodes of the output

00:17:03.430 --> 00:17:07.660
of the branches from the
network nodes to the k-th node

00:17:07.660 --> 00:17:12.670
plus the output of the
branches from the j-th

00:17:12.670 --> 00:17:16.940
over all the source nodes,
from the j-th source node,

00:17:16.940 --> 00:17:19.829
to the network node
that we're focusing on.

00:17:19.829 --> 00:17:24.109
So this corresponds to
the output of the branches

00:17:24.109 --> 00:17:25.790
from the network nodes.

00:17:25.790 --> 00:17:29.570
And this corresponds to
the output of the branches

00:17:29.570 --> 00:17:30.650
from the source nodes.

00:17:33.830 --> 00:17:37.780
Well, for linear constant
coefficient difference

00:17:37.780 --> 00:17:41.440
equations, we don't need
all of the generality

00:17:41.440 --> 00:17:44.300
that we've implied in
the discussion so far.

00:17:44.300 --> 00:17:47.080
In particular, what
we can concentrate

00:17:47.080 --> 00:17:51.700
on is a special set
of signal flow graphs,

00:17:51.700 --> 00:17:55.370
namely signal flow
graphs which are linear.

00:17:55.370 --> 00:18:03.370
And what we mean by linear is
that the output of a branch

00:18:03.370 --> 00:18:08.470
is equal to the input
to the branch multiplied

00:18:08.470 --> 00:18:10.290
by some function.

00:18:10.290 --> 00:18:13.420
So that it's a linear
relationship between the branch

00:18:13.420 --> 00:18:15.470
output in the branch input.

00:18:15.470 --> 00:18:19.930
In other words v sub jk, the
output of the branch from

00:18:19.930 --> 00:18:25.840
the j-th node to the k-th node,
is equal to some function--

00:18:25.840 --> 00:18:28.900
this might be simply a scalar
or it might be a function of z,

00:18:28.900 --> 00:18:32.410
for example, which it will
often turn out to be--

00:18:32.410 --> 00:18:35.170
multiplied by the
input to that branch,

00:18:35.170 --> 00:18:40.760
in other words, the
value of the j-th node.

00:18:40.760 --> 00:18:43.880
So that is then the
additional constraint

00:18:43.880 --> 00:18:47.720
that we impose if we're talking
about linear signal flow

00:18:47.720 --> 00:18:50.210
graphs, which we'll
be concentrating

00:18:50.210 --> 00:18:53.370
on for the rest of the lecture.

00:18:53.370 --> 00:18:57.690
Well, to see how a linear
constant coefficient difference

00:18:57.690 --> 00:19:01.830
equation can be represented
in terms of linear signal flow

00:19:01.830 --> 00:19:07.800
graphs, let's take the
same example that we worked

00:19:07.800 --> 00:19:11.340
with previously in terms of
the block diagram notation,

00:19:11.340 --> 00:19:15.990
in other words, y of n is
equal to a times y of n minus 1

00:19:15.990 --> 00:19:19.310
plus x of n.

00:19:19.310 --> 00:19:23.420
Well, we have a node
that's a source node.

00:19:23.420 --> 00:19:25.370
That's x of n.

00:19:25.370 --> 00:19:27.020
We have a node
that's a sink node.

00:19:27.020 --> 00:19:27.860
That's y of n.

00:19:27.860 --> 00:19:30.500
That's what we'd like to
get out of the network.

00:19:30.500 --> 00:19:36.500
And presumably somehow we've
gotten a network node whose

00:19:36.500 --> 00:19:39.830
value will be y of n minus 1.

00:19:39.830 --> 00:19:46.600
If we have that node, then what
we want to form to get y of in

00:19:46.600 --> 00:19:50.990
is a times y of n minus 1.

00:19:50.990 --> 00:19:53.890
So we want y of
minus 1 multiplied

00:19:53.890 --> 00:19:59.310
by a, which means that this
branch has a transmittance,

00:19:59.310 --> 00:20:02.590
or a gain, which is a.

00:20:02.590 --> 00:20:07.210
And then because of the
algebraic definition at nodes,

00:20:07.210 --> 00:20:12.370
the value of this node
is the sum of this branch

00:20:12.370 --> 00:20:14.710
and the output of this branch.

00:20:14.710 --> 00:20:18.760
So if this branch
has a gain of unity,

00:20:18.760 --> 00:20:23.470
then this node variable
will have the value x of n

00:20:23.470 --> 00:20:27.290
plus a times y the minus 1.

00:20:27.290 --> 00:20:30.340
Well, now we simply have to
get from here all the way

00:20:30.340 --> 00:20:31.810
out to there.

00:20:31.810 --> 00:20:35.170
I've drawn it, the network,
somewhat inefficiently.

00:20:35.170 --> 00:20:40.340
I can get from this node to this
node simply with a unity gain.

00:20:40.340 --> 00:20:42.830
From this node to the
output node again,

00:20:42.830 --> 00:20:46.100
with the unity gain.

00:20:46.100 --> 00:20:49.470
And now the only question is--

00:20:49.470 --> 00:20:52.850
of course, if this is y of n,
and this node has value y of n

00:20:52.850 --> 00:20:53.780
also--

00:20:53.780 --> 00:20:57.410
how do I get from
this node to this node

00:20:57.410 --> 00:21:00.500
if I'm talking about a
linear signal flow graph?

00:21:00.500 --> 00:21:03.980
Well, y of n minus
1, of course, isn't

00:21:03.980 --> 00:21:07.400
a scalar multiplied by y of n.

00:21:07.400 --> 00:21:12.980
But y of z, or the z transform
rather of y of n minus 1

00:21:12.980 --> 00:21:16.670
is actually a scalar or
a function multiplied

00:21:16.670 --> 00:21:19.550
by the z transform of y of n.

00:21:19.550 --> 00:21:23.720
So if I were to think of
this rather than in terms

00:21:23.720 --> 00:21:28.460
of the sequences, if I were
to think of this in terms

00:21:28.460 --> 00:21:37.040
of this transform, then in fact
the z transform at this node

00:21:37.040 --> 00:21:42.950
would be z to the
minus 1 times y of z.

00:21:42.950 --> 00:21:46.850
And consequently, thinking
of it in terms of z

00:21:46.850 --> 00:21:50.330
transforms, the
gain of this branch

00:21:50.330 --> 00:21:55.890
then is z to the minus 1.

00:21:55.890 --> 00:21:58.200
So this, in fact
does, correspond

00:21:58.200 --> 00:22:01.890
to multiplication
by a function of z,

00:22:01.890 --> 00:22:05.490
as long as in the
background what we remember

00:22:05.490 --> 00:22:10.830
is that we're essentially
thinking of the flow graph

00:22:10.830 --> 00:22:14.670
as representing relationships
between the z transform.

00:22:14.670 --> 00:22:18.030
Now, obviously, we wouldn't
feel constrained to designate it

00:22:18.030 --> 00:22:19.300
that way all the time.

00:22:19.300 --> 00:22:21.900
In other words, I would
feel very comfortable

00:22:21.900 --> 00:22:24.930
about drawing this flow
graph and labeling this input

00:22:24.930 --> 00:22:28.020
as x of n, labeling
this node is y of n,

00:22:28.020 --> 00:22:30.870
and this is y of n
minus 1, and indicating

00:22:30.870 --> 00:22:33.825
that this branch has a
transmittance of z the minus 1.

00:22:33.825 --> 00:22:37.330
Just simply in the
background what we realize

00:22:37.330 --> 00:22:40.510
is it's not y of n that's
multiplied by z to the minus 1.

00:22:40.510 --> 00:22:45.460
It's y of z that's multiplied
by z to the minus 1.

00:22:45.460 --> 00:22:50.830
Also, notationally,
it's usually convenient,

00:22:50.830 --> 00:22:55.780
since very often we end up with
branches that have unity gain,

00:22:55.780 --> 00:23:03.130
to choose the convention
that if a branch doesn't have

00:23:03.130 --> 00:23:06.640
the game labeled on it, the
implication is that what

00:23:06.640 --> 00:23:08.950
the gain is, in fact, is unity.

00:23:08.950 --> 00:23:16.480
So generally, actually we won't
specify explicitly unity gain.

00:23:16.480 --> 00:23:18.820
If there is a branch
with unity gain,

00:23:18.820 --> 00:23:21.520
we simply won't label the gain.

00:23:21.520 --> 00:23:27.880
One final point and that is
that you can, I think, see--

00:23:27.880 --> 00:23:31.100
you probably observed this
for yourself already--

00:23:31.100 --> 00:23:34.600
that actually this flow graph
is drawn somewhat inefficiently

00:23:34.600 --> 00:23:36.640
as I've indicated here.

00:23:36.640 --> 00:23:38.710
Basically, I can
take these two nodes

00:23:38.710 --> 00:23:41.140
and collapse them together.

00:23:41.140 --> 00:23:45.400
I chose to draw this
flow graph this way so

00:23:45.400 --> 00:23:50.380
that it looks as much like the
block diagram representation as

00:23:50.380 --> 00:23:51.527
possible.

00:23:51.527 --> 00:23:53.860
And in fact, if you compare
it back to the block diagram

00:23:53.860 --> 00:23:58.300
representation, it is basically
the same except for the fact

00:23:58.300 --> 00:24:00.190
that we've chosen to
represent this delay

00:24:00.190 --> 00:24:01.900
branch a little differently.

00:24:01.900 --> 00:24:06.400
And we've used the algebra
of signal flow graphs

00:24:06.400 --> 00:24:09.790
to do the addition at nodes
rather than explicitly putting

00:24:09.790 --> 00:24:10.330
in an adder.

00:24:10.330 --> 00:24:12.262
And that's really
the only difference.

00:24:15.220 --> 00:24:20.210
Now, what a flow graph
or a block diagram

00:24:20.210 --> 00:24:24.470
is, as I've stressed, is
a graphical representation

00:24:24.470 --> 00:24:27.560
of that difference equation.

00:24:27.560 --> 00:24:31.610
And what it in
turn corresponds to

00:24:31.610 --> 00:24:37.040
is a graphical representation
of a linear set of equations,

00:24:37.040 --> 00:24:41.510
a set of equations, which
describe the relationships

00:24:41.510 --> 00:24:45.380
among the various variables
or among the nodes

00:24:45.380 --> 00:24:47.690
in the digital network.

00:24:47.690 --> 00:24:51.650
If I were, for example, going
to implement a difference

00:24:51.650 --> 00:24:57.080
equation or a single flow graph
on a digital computer, what

00:24:57.080 --> 00:25:01.940
I would implement in
effect is not the graphics

00:25:01.940 --> 00:25:04.220
of the signal flow graph.

00:25:04.220 --> 00:25:07.380
I would implement the algebra
of the signal flow graph.

00:25:07.380 --> 00:25:09.350
In other words,
I would implement

00:25:09.350 --> 00:25:15.170
the linear set of equations that
the flow graph corresponds to.

00:25:15.170 --> 00:25:18.020
Consequently, what
I'd like to spend

00:25:18.020 --> 00:25:20.810
the remainder of
the lecture on is

00:25:20.810 --> 00:25:25.790
focusing on the equivalent
linear set of equations

00:25:25.790 --> 00:25:29.970
that the signal flow graph
corresponds to, in other words,

00:25:29.970 --> 00:25:33.680
the matrix representation
of a digital network.

00:25:33.680 --> 00:25:38.690
And the matrix representation
is important from a number

00:25:38.690 --> 00:25:40.220
of points of view.

00:25:40.220 --> 00:25:42.350
One is, of course,
that as I've just

00:25:42.350 --> 00:25:45.560
stressed it's important for
the actual implementation

00:25:45.560 --> 00:25:47.330
of the digital network.

00:25:47.330 --> 00:25:50.030
It's also important
in a sense that lots

00:25:50.030 --> 00:25:52.310
of properties of
digital networks

00:25:52.310 --> 00:25:58.580
fall out from the
properties of matrices.

00:25:58.580 --> 00:26:00.800
We won't, in fact, in
this set of lectures

00:26:00.800 --> 00:26:04.270
be exploiting that
particularly, but it

00:26:04.270 --> 00:26:07.430
is one of the reasons why
the matrix representation

00:26:07.430 --> 00:26:11.910
of digital networks is also
important to be aware of.

00:26:11.910 --> 00:26:16.910
So let's then see what this
graphical representation,

00:26:16.910 --> 00:26:19.970
or the linear single flow
graph representation,

00:26:19.970 --> 00:26:23.600
corresponds to in terms of
a set of linear equations,

00:26:23.600 --> 00:26:26.210
or in terms of a
set of matrices.

00:26:26.210 --> 00:26:31.270
So we're considering
then a general network.

00:26:31.270 --> 00:26:35.560
It has some internal nodes,
branches, coming into them.

00:26:35.560 --> 00:26:38.470
I've indicated one source
node and one sink node.

00:26:38.470 --> 00:26:40.660
More generally, there would
be a set of source nodes

00:26:40.660 --> 00:26:43.060
and a set of sink nodes.

00:26:43.060 --> 00:26:49.780
The algebraic equations that
the flow graph corresponds to

00:26:49.780 --> 00:26:56.830
is a statement of how
the node variables are

00:26:56.830 --> 00:26:58.510
related to each other.

00:26:58.510 --> 00:27:03.230
And just to remind you
of how that's generated--

00:27:03.230 --> 00:27:05.890
and I'm expressing this now
in terms of the z transforms

00:27:05.890 --> 00:27:07.660
of the node variables--

00:27:07.660 --> 00:27:11.830
the z transform of the k-th
node variable is the sum over

00:27:11.830 --> 00:27:16.540
the network nodes of
the branch outputs--

00:27:16.540 --> 00:27:23.590
that's indicated here-- plus
the sum over the source branch

00:27:23.590 --> 00:27:25.090
outputs.

00:27:25.090 --> 00:27:29.890
And incidentally, I've
assumed that it's just--

00:27:29.890 --> 00:27:33.190
best to assume this because
of notational convenience--

00:27:33.190 --> 00:27:35.140
that there's a branch
from every network node

00:27:35.140 --> 00:27:36.910
to every other network node.

00:27:36.910 --> 00:27:39.310
Obviously I can always
get away with that.

00:27:39.310 --> 00:27:41.140
If that branch
doesn't really exist,

00:27:41.140 --> 00:27:46.210
I simply set the gain of
that branch equal to zero.

00:27:46.210 --> 00:27:48.520
Now, furthermore, we
have the relationship

00:27:48.520 --> 00:27:51.490
that defines what
the branch output is

00:27:51.490 --> 00:27:55.970
in terms of the branch input or
in terms of the node variables.

00:27:55.970 --> 00:27:58.330
So we have specifically
the statement

00:27:58.330 --> 00:28:02.380
that v sub jk, the output
of the jk-th branch,

00:28:02.380 --> 00:28:09.390
is some function of z
multiplied by the branch input.

00:28:09.390 --> 00:28:13.180
And furthermore, the
source branch output

00:28:13.180 --> 00:28:20.520
is some function, or scalar,
multiplied by the source node

00:28:20.520 --> 00:28:22.880
value.

00:28:22.880 --> 00:28:25.450
Well, if we substitute
these two equations

00:28:25.450 --> 00:28:27.160
into the previous
equation, which

00:28:27.160 --> 00:28:31.180
defined what the
node values are,

00:28:31.180 --> 00:28:33.100
we end up with a
statement that says

00:28:33.100 --> 00:28:39.910
that the node variables are
equal to a linear combination

00:28:39.910 --> 00:28:44.800
of the node variables, the
linear combination specified

00:28:44.800 --> 00:28:49.840
by the branch transmit answers,
plus a linear combination

00:28:49.840 --> 00:28:55.340
of the source node values.

00:28:55.340 --> 00:28:59.450
And this then is a set
of linear equations

00:28:59.450 --> 00:29:04.590
that, in essence, defines
the digital network.

00:29:04.590 --> 00:29:06.230
This is a set of
equations, of course,

00:29:06.230 --> 00:29:10.850
because we have an equation
like this for each value of k

00:29:10.850 --> 00:29:14.090
as k runs over all the
network nodes, in other words,

00:29:14.090 --> 00:29:18.370
for k starting from 1
and running up to n.

00:29:18.370 --> 00:29:24.610
We can express the set of linear
equations in matrix notation.

00:29:24.610 --> 00:29:28.390
If we think of a column
vector corresponding

00:29:28.390 --> 00:29:33.670
to the node variables,
then this equation

00:29:33.670 --> 00:29:42.940
says that the vector or column
matrix of node variables

00:29:42.940 --> 00:29:46.510
is equal to a matrix of
coefficients dictated

00:29:46.510 --> 00:29:49.960
by the branch transmittances
multiplied again

00:29:49.960 --> 00:29:56.080
by the node variables plus
a second matrix multiplied

00:29:56.080 --> 00:30:02.140
by the column of
source node values.

00:30:02.140 --> 00:30:06.940
And there is one peculiar thing
that happens notationally here,

00:30:06.940 --> 00:30:11.240
which it's worthwhile
to straighten out.

00:30:11.240 --> 00:30:13.430
It happens because
of the way that we

00:30:13.430 --> 00:30:18.980
chose to write these equations
that the branch transmittance

00:30:18.980 --> 00:30:25.530
values come in to the matrix,
as I've indicated here.

00:30:25.530 --> 00:30:28.811
So the first row, for
example, contains F 1 1,

00:30:28.811 --> 00:30:31.280
F2 through F sub N1.

00:30:31.280 --> 00:30:37.310
As you're well aware, typically
in defining a matrix and matrix

00:30:37.310 --> 00:30:40.400
elements, the
general convention is

00:30:40.400 --> 00:30:43.640
to refer to the matrix
elements with the first index

00:30:43.640 --> 00:30:45.410
corresponding to the
row, the second index

00:30:45.410 --> 00:30:47.300
corresponding to the column.

00:30:47.300 --> 00:30:54.060
So the tendency is to refer to
the matrix elements as A1 1,

00:30:54.060 --> 00:30:58.020
A 1 2 through A 1N, etc.

00:30:58.020 --> 00:31:04.230
So that simply means that in
writing this set of equations

00:31:04.230 --> 00:31:10.320
in compact matrix form,
it's convenient to do that

00:31:10.320 --> 00:31:15.510
by referring to the transpose
of a matrix of coefficients

00:31:15.510 --> 00:31:18.850
rather than directly to the
matrix of coefficients itself.

00:31:18.850 --> 00:31:20.640
In other words,
it's convenient when

00:31:20.640 --> 00:31:24.490
I write this set of equations,
or a set of equations

00:31:24.490 --> 00:31:28.550
in compact matrix
notation, to write it

00:31:28.550 --> 00:31:31.800
as I've indicated here.

00:31:31.800 --> 00:31:37.590
We have a column vector of
node values, node variables,

00:31:37.590 --> 00:31:42.990
equal to a transpose
coefficient matrix

00:31:42.990 --> 00:31:48.000
multiplied by the column
vector of node variables.

00:31:48.000 --> 00:31:51.930
And then the transpose
of the transmittances

00:31:51.930 --> 00:31:54.120
that connect the sources
to the internal network

00:31:54.120 --> 00:31:59.070
nodes multiplied by the
source vector, where

00:31:59.070 --> 00:32:03.990
the matrix F of z, the jk-th
element of the matrix F of z

00:32:03.990 --> 00:32:07.920
is F sub jk of z.

00:32:07.920 --> 00:32:12.360
I think that it takes just a few
minutes of private reflection

00:32:12.360 --> 00:32:15.560
to see that this works
out notationally.

00:32:15.560 --> 00:32:20.490
But it's this reason, it's to
interface the matrix notation

00:32:20.490 --> 00:32:24.900
and the flow graph notation that
makes it convenient to refer

00:32:24.900 --> 00:32:27.930
to the transpose, to a
transpose matrix here,

00:32:27.930 --> 00:32:30.852
rather than omitting
the transposition.

00:32:33.450 --> 00:32:39.570
It's typical and notationally
what will also stick with

00:32:39.570 --> 00:32:45.300
in representing a digital
network with flow graph

00:32:45.300 --> 00:32:54.000
notation to restrict ourselves
always to branches that are

00:32:54.000 --> 00:32:56.950
either simply co-efficient
branches-- in other words,

00:32:56.950 --> 00:33:00.090
they correspond to
multiplication by a scalar--

00:33:00.090 --> 00:33:02.220
or they're simply
delay branches.

00:33:02.220 --> 00:33:05.160
In other words, they
have a transmittance

00:33:05.160 --> 00:33:08.772
which is z to the minus 1.

00:33:08.772 --> 00:33:13.380
And with that restriction,
it's convenient for a number

00:33:13.380 --> 00:33:15.990
of reasons, and in particular
for developing some network

00:33:15.990 --> 00:33:22.980
properties, to consider
decomposing this matrix

00:33:22.980 --> 00:33:28.140
equation in such a way that we
separate out with the matrix F

00:33:28.140 --> 00:33:36.000
transpose of z the part of that
matrix that doesn't involve

00:33:36.000 --> 00:33:38.610
any delay terms and the
part of that matrix that

00:33:38.610 --> 00:33:41.310
does involve delay terms.

00:33:41.310 --> 00:33:45.300
In particular, we can write
the transpose matrix F

00:33:45.300 --> 00:33:46.980
transposed of z.

00:33:46.980 --> 00:33:50.160
We can separate it into
the sum of two matrices.

00:33:50.160 --> 00:33:55.110
One matrix is simply
a coefficient matrix.

00:33:55.110 --> 00:33:59.600
In other words, it involves
no terms z to the minus the 1.

00:33:59.600 --> 00:34:03.590
The second matrix
contains only terms

00:34:03.590 --> 00:34:05.075
involving z to the minus 1.

00:34:05.075 --> 00:34:08.239
And, of course, we can pull
the z to the minus 1 outside.

00:34:08.239 --> 00:34:13.070
And so we have the
delay terms isolated.

00:34:13.070 --> 00:34:15.320
In other words, we have
a matrix of coefficients

00:34:15.320 --> 00:34:19.469
here, all of the terms
multiplied by z to the minus 1.

00:34:19.469 --> 00:34:22.850
So the matrix f of
z can be separated

00:34:22.850 --> 00:34:28.050
into a coefficient matrix
and a delay matrix.

00:34:28.050 --> 00:34:34.280
And if we now substitute that
back into our original matrix

00:34:34.280 --> 00:34:38.090
equation, then we
have the statement

00:34:38.090 --> 00:34:42.480
that says that the
vector of node variables

00:34:42.480 --> 00:34:45.290
is a coefficient
matrix multiplied

00:34:45.290 --> 00:34:50.760
by that vector, a delay matrix
multiplied by that vector.

00:34:50.760 --> 00:34:53.270
And then I'm
assuming incidentally

00:34:53.270 --> 00:34:54.739
in this notation
and, of course, it

00:34:54.739 --> 00:35:00.050
can be generalized quite easily
that the sources are connected

00:35:00.050 --> 00:35:01.750
only with non-delay branches.

00:35:04.420 --> 00:35:07.930
I have suppressed incidentally
in the discussion up

00:35:07.930 --> 00:35:11.410
to this point, the
additional statement

00:35:11.410 --> 00:35:14.330
that we need, the additional
set of equations that we need,

00:35:14.330 --> 00:35:17.980
that tell us how finally
we get from the set

00:35:17.980 --> 00:35:22.990
of internal network nodes
to the network output.

00:35:22.990 --> 00:35:28.420
We have then an additional
set of equations

00:35:28.420 --> 00:35:35.140
that specify what the sink
node values are in terms

00:35:35.140 --> 00:35:38.260
of the internal network nodes.

00:35:38.260 --> 00:35:41.740
And often in referring to the
matrix equations for a signal

00:35:41.740 --> 00:35:45.670
flow graph, sometimes
we'll include this equation

00:35:45.670 --> 00:35:49.780
explicitly, and sometimes
we'll tend to suppress it.

00:35:49.780 --> 00:35:53.440
Now, looking at
this equation where

00:35:53.440 --> 00:35:57.130
we've separated out the
coefficient and delay branches,

00:35:57.130 --> 00:36:00.640
we can alternatively
reinterpret that equation

00:36:00.640 --> 00:36:01.600
in the time domain.

00:36:01.600 --> 00:36:05.170
It's expressed here in
terms of z transforms.

00:36:05.170 --> 00:36:10.300
In the time domain, then
this corresponds again

00:36:10.300 --> 00:36:15.430
to a matrix set of equations
stating that the column vector

00:36:15.430 --> 00:36:21.700
w of n is equal to a
coefficient matrix multiplied

00:36:21.700 --> 00:36:23.420
by the present state--

00:36:23.420 --> 00:36:27.130
in other words, the
same column vector--

00:36:27.130 --> 00:36:34.390
plus another matrix multiplied
by that set of node variables,

00:36:34.390 --> 00:36:38.620
one iteration previously, and
then, of course, an equation

00:36:38.620 --> 00:36:41.140
coupling the sources
into that and finally

00:36:41.140 --> 00:36:43.810
an equation that
generates the sync node

00:36:43.810 --> 00:36:46.300
outputs from the node variables.

00:36:46.300 --> 00:36:53.260
But if you look at this, what
this corresponds to, of course,

00:36:53.260 --> 00:36:59.230
is a set of first order
difference equations,

00:36:59.230 --> 00:37:01.600
so that essentially
what we've done,

00:37:01.600 --> 00:37:04.330
starting from our n-th order
linear constant coefficient

00:37:04.330 --> 00:37:07.540
difference equation, through
the signal flow graph

00:37:07.540 --> 00:37:11.740
representation, we have
in essence decomposed that

00:37:11.740 --> 00:37:17.080
into a set of first order linear
constant coefficient difference

00:37:17.080 --> 00:37:20.260
equations, of course,
all of them coupled.

00:37:20.260 --> 00:37:25.540
And the discussion in
the next several lectures

00:37:25.540 --> 00:37:29.530
will in fact involve
what the various options

00:37:29.530 --> 00:37:33.580
are in terms of what
various forms we can use,

00:37:33.580 --> 00:37:36.730
or are commonly
used, in representing

00:37:36.730 --> 00:37:38.560
this large n-th order equation.

00:37:38.560 --> 00:37:42.010
But what we see is that the
signal flow graph in essence

00:37:42.010 --> 00:37:43.900
breaks down the
n-th order equation

00:37:43.900 --> 00:37:50.350
into a set of first order
difference equations.

00:37:50.350 --> 00:37:53.260
Well, let's just finally
look at an example

00:37:53.260 --> 00:37:59.440
of how the set of equations
might look for a single flow

00:37:59.440 --> 00:38:03.370
graph, a relatively
simple example,

00:38:03.370 --> 00:38:05.980
and incidentally somewhat
meaningless in the sense

00:38:05.980 --> 00:38:09.730
that it's not a flow
graph that is motivated

00:38:09.730 --> 00:38:15.070
by anything other than something
to draw here for discussion.

00:38:15.070 --> 00:38:18.070
Well, all right, here's a
linear signal flow graph.

00:38:18.070 --> 00:38:20.380
It has these unity
gain branches.

00:38:20.380 --> 00:38:23.610
It has a branch with gain
b and a branch with gain a

00:38:23.610 --> 00:38:27.100
and the two delay branches.

00:38:27.100 --> 00:38:30.160
According to the algebra
for the flow graph,

00:38:30.160 --> 00:38:34.190
this node variable is equal
to B times this node variable.

00:38:34.190 --> 00:38:36.040
So that's this equation.

00:38:36.040 --> 00:38:40.240
This node variable is this one
delayed plus this one delayed.

00:38:40.240 --> 00:38:45.550
That's this equation
and this node--

00:38:45.550 --> 00:38:50.810
I'm sorry, this node is a
times w2 of n plus the source.

00:38:50.810 --> 00:38:52.990
So those are the linear
equations defining

00:38:52.990 --> 00:38:56.380
the internal network nodes.

00:38:56.380 --> 00:39:02.870
And this corresponds then
to a matrix equation.

00:39:02.870 --> 00:39:04.540
Let me draw your
attention to the fact,

00:39:04.540 --> 00:39:07.120
incidentally, that
the way that I've

00:39:07.120 --> 00:39:09.940
numbered these
nodes in fact is not

00:39:09.940 --> 00:39:14.560
the order in which I can compute
them if I were to compute them

00:39:14.560 --> 00:39:15.970
successively.

00:39:15.970 --> 00:39:19.360
Now, what I mean
by that is suppose

00:39:19.360 --> 00:39:21.910
that in my numbering
what I decide

00:39:21.910 --> 00:39:25.090
is that what the numbering
means is that node 1

00:39:25.090 --> 00:39:27.607
I'll compute first, node 2
I'll compute second, node 3

00:39:27.607 --> 00:39:30.370
I'll compute third.

00:39:30.370 --> 00:39:34.070
To compute node
1, I need node 3.

00:39:34.070 --> 00:39:37.150
And I don't have
node 3 if I'm going

00:39:37.150 --> 00:39:39.100
to compute that after node 1.

00:39:39.100 --> 00:39:43.540
So actually the order that I've
specified here for the nodes

00:39:43.540 --> 00:39:48.190
is not an order in which
I can compute the network.

00:39:48.190 --> 00:39:52.840
Or another way to say that
is that this network as I've

00:39:52.840 --> 00:39:56.260
numbered the nodes
is not computable.

00:39:56.260 --> 00:40:00.730
But let's go on, and
we'll look in fact

00:40:00.730 --> 00:40:02.980
at a rearrangement of the
nodes that is computable.

00:40:02.980 --> 00:40:05.980
But let's see how the
matrix equation looks.

00:40:05.980 --> 00:40:12.640
Simply, this equation rewritten
in terms of a set of matrices,

00:40:12.640 --> 00:40:16.360
then it comes out as
I've indicated here.

00:40:16.360 --> 00:40:18.490
We have the matrix F sub c.

00:40:18.490 --> 00:40:21.140
This is the coefficient matrix.

00:40:21.140 --> 00:40:22.990
This is the delay matrix.

00:40:22.990 --> 00:40:26.290
So it involves a vector
of only delayed sequences

00:40:26.290 --> 00:40:30.510
and then the input coupled in.

00:40:30.510 --> 00:40:32.950
Let me point out incidentally--

00:40:32.950 --> 00:40:37.410
just keep track of the
fact that this matrix,

00:40:37.410 --> 00:40:41.850
the coefficient matrix,
happens to have an element

00:40:41.850 --> 00:40:44.580
on or above the major diagonal.

00:40:44.580 --> 00:40:47.490
And that shouldn't have any
particular meaning right now,

00:40:47.490 --> 00:40:50.910
but it will in a
couple of minutes.

00:40:50.910 --> 00:40:55.260
All right, let's consider a
slightly different ordering

00:40:55.260 --> 00:40:57.820
for the network nodes.

00:40:57.820 --> 00:41:01.080
This is the same network.

00:41:01.080 --> 00:41:04.120
I now have ordered the
node slightly differently.

00:41:04.120 --> 00:41:08.640
I'm calling this node 1,
this node 2, and this node 3.

00:41:08.640 --> 00:41:14.430
And let's just inquire as
to whether the nodes ordered

00:41:14.430 --> 00:41:17.730
as I've indicated here
are now computable.

00:41:17.730 --> 00:41:24.160
Well, to get node 1, I need w
of n minus 1, which of course I

00:41:24.160 --> 00:41:27.240
got because that's from
the previous iteration.

00:41:27.240 --> 00:41:29.000
I need w3 of n minus 1.

00:41:29.000 --> 00:41:31.540
And that I've got from
the previous iteration.

00:41:31.540 --> 00:41:34.380
So this node can be computed.

00:41:34.380 --> 00:41:37.620
To compute this node, I need
the source, which I have.

00:41:37.620 --> 00:41:40.260
And I need w1 of n,
which I just got.

00:41:40.260 --> 00:41:42.330
So this can be computed.

00:41:42.330 --> 00:41:44.950
And then to compute
w3 of n, I need

00:41:44.950 --> 00:41:47.760
w2 of n, which I just computed.

00:41:47.760 --> 00:41:51.840
And so, in fact, the nodes
numbered in this order

00:41:51.840 --> 00:41:53.940
are computable,
whereas the nodes

00:41:53.940 --> 00:41:58.110
numbered in the previous
order are not computable.

00:41:58.110 --> 00:42:02.460
If I look at the
equations for this,

00:42:02.460 --> 00:42:06.120
they're, of course, the same
equations as I had previously,

00:42:06.120 --> 00:42:09.360
except that some of the
indices are changed.

00:42:09.360 --> 00:42:11.730
And so it simply
involves changing

00:42:11.730 --> 00:42:13.650
some of the rows and columns.

00:42:13.650 --> 00:42:17.280
And what it comes
out to look like,

00:42:17.280 --> 00:42:21.990
in fact, is what
I've indicated here.

00:42:21.990 --> 00:42:25.860
Again, the coefficient matrix--

00:42:25.860 --> 00:42:30.870
the same elements appear, but
the order is swapped around--

00:42:30.870 --> 00:42:36.840
multiplied by the vector
of current node states

00:42:36.840 --> 00:42:40.950
and then a delay
matrix multiplied

00:42:40.950 --> 00:42:46.720
by the vector of delayed states,
and then the input coupled in.

00:42:46.720 --> 00:42:52.680
And notice that in this case, we
don't have any non-zero values

00:42:52.680 --> 00:42:57.280
on or above the main diagonal.

00:42:57.280 --> 00:43:00.030
It turns out that
you can show it,

00:43:00.030 --> 00:43:04.260
and it's not too
difficult to do,

00:43:04.260 --> 00:43:09.060
you can show that a necessary
and sufficient condition

00:43:09.060 --> 00:43:12.120
for the node numbering
to correspond

00:43:12.120 --> 00:43:16.200
to a computable network, or
to be a computer numbering,

00:43:16.200 --> 00:43:19.620
is that this
coefficient matrix has

00:43:19.620 --> 00:43:24.090
to have the form that there
are no non-zero elements

00:43:24.090 --> 00:43:28.140
on or above the major diagonal.

00:43:28.140 --> 00:43:31.650
So often if the
nodes are numbered

00:43:31.650 --> 00:43:33.900
in a non-computable
order, the order

00:43:33.900 --> 00:43:38.790
can simply be rearranged
so that it is computable.

00:43:38.790 --> 00:43:43.230
It does turn out
incidentally that there

00:43:43.230 --> 00:43:46.890
are some networks for which
no matter how you number the

00:43:46.890 --> 00:43:51.390
nodes, you can't number them in
an order that makes the network

00:43:51.390 --> 00:43:53.370
computable.

00:43:53.370 --> 00:43:54.960
Computability, as
I've just said,

00:43:54.960 --> 00:43:59.130
is the statement that the notes
can be numbered in such a way

00:43:59.130 --> 00:44:03.780
that it's 0 above or
on the main diagonal.

00:44:03.780 --> 00:44:07.740
As you'll see as you work some
problems in the study guide,

00:44:07.740 --> 00:44:11.640
a non-computable network,
in essence, what happens

00:44:11.640 --> 00:44:16.350
is that we have a set of nodes
in the network all of which

00:44:16.350 --> 00:44:21.550
are connected together
by non-delay branches.

00:44:21.550 --> 00:44:24.960
And so you can see that what
happens is to compute this one

00:44:24.960 --> 00:44:25.950
I need that one.

00:44:25.950 --> 00:44:27.810
But to compute that
when, I need this one.

00:44:27.810 --> 00:44:29.351
But to compute this
one, I need this.

00:44:29.351 --> 00:44:30.960
But to compute
that, I need that.

00:44:30.960 --> 00:44:33.340
There's no way to
get out of that loop.

00:44:33.340 --> 00:44:36.660
So if there's a delay
free loop in the network,

00:44:36.660 --> 00:44:39.120
it turns out that
that corresponds

00:44:39.120 --> 00:44:41.050
to a non-computable network.

00:44:41.050 --> 00:44:43.230
Although it's
important to stress

00:44:43.230 --> 00:44:45.930
that the
non-computability doesn't

00:44:45.930 --> 00:44:49.410
mean that the set of
equations can't be solved,

00:44:49.410 --> 00:44:51.930
the set of equations
can still be solved,

00:44:51.930 --> 00:44:54.480
or the network
can be rearranged.

00:44:54.480 --> 00:44:57.090
What it simply means is
that non-computability

00:44:57.090 --> 00:45:02.820
means that we can't compute
the node variables in sequence.

00:45:02.820 --> 00:45:04.410
We can't start with
w1 of n and then

00:45:04.410 --> 00:45:08.130
go on the w2 of n and
then w3 of n, etc.

00:45:08.130 --> 00:45:10.860
Well, this issue of
non-computability

00:45:10.860 --> 00:45:17.700
is just one brief glimpse in
fact into the kinds of network

00:45:17.700 --> 00:45:20.760
properties that
can be pulled out

00:45:20.760 --> 00:45:24.150
of either the signal flow graph
representation of properties

00:45:24.150 --> 00:45:29.400
of signal flow graphs or out
of the matrix representation.

00:45:29.400 --> 00:45:31.920
As I indicated at the
beginning of the lecture,

00:45:31.920 --> 00:45:34.740
we won't be exploiting
these kinds of properties.

00:45:34.740 --> 00:45:38.010
There is, in fact, a
rather lengthy discussion

00:45:38.010 --> 00:45:41.670
of properties of digital
networks in the text, which

00:45:41.670 --> 00:45:44.100
we won't be going into further.

00:45:44.100 --> 00:45:48.780
In the next several lectures
what we'll concentrate on

00:45:48.780 --> 00:45:53.760
are the more common
digital network structures

00:45:53.760 --> 00:45:58.840
for implementing both
infinite impulse response,

00:45:58.840 --> 00:46:02.700
or recursive digital filters,
and finite impulse response,

00:46:02.700 --> 00:46:04.840
or non-recursive
digital filters.

00:46:04.840 --> 00:46:06.630
Thank you.