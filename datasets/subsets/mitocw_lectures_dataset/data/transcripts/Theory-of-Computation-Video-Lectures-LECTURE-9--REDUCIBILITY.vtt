WEBVTT

00:00:00.000 --> 00:00:25.140
[SQUEAKING]
[RUSTLING] [CLICKING]

00:00:25.140 --> 00:00:27.140
PROFESSOR: All righty,
why don't we get started.

00:00:31.200 --> 00:00:33.620
So welcome back.

00:00:33.620 --> 00:00:36.590
Nice to see you all.

00:00:36.590 --> 00:00:42.290
And what have we been doing
in theory of computation?

00:00:42.290 --> 00:00:46.160
We have been talking
about Turing machines

00:00:46.160 --> 00:00:50.750
and about the power
of Turing machines.

00:00:50.750 --> 00:00:55.370
We started at the
beginning by showing

00:00:55.370 --> 00:00:58.580
a bunch of decidability
theorems that

00:00:58.580 --> 00:01:00.620
exhibit the power
of Turing machines

00:01:00.620 --> 00:01:08.160
to calculate properties
of finite automata,

00:01:08.160 --> 00:01:12.130
context free grammars,
and so on in some cases.

00:01:12.130 --> 00:01:15.780
And last lecture, we talked
about the limitations

00:01:15.780 --> 00:01:20.670
of the power of Turing
machines by proving

00:01:20.670 --> 00:01:22.470
undecidability theorems.

00:01:22.470 --> 00:01:25.860
So we showed that
this language A TM,

00:01:25.860 --> 00:01:29.280
the acceptance problem
for Turing machines itself

00:01:29.280 --> 00:01:31.650
is an undecidable problem.

00:01:31.650 --> 00:01:33.660
That was the first of
many undecidable problems

00:01:33.660 --> 00:01:35.790
that we're going to encounter.

00:01:35.790 --> 00:01:39.540
And though we proved
the undecidability

00:01:39.540 --> 00:01:41.430
of A TM using the
diagonalization

00:01:41.430 --> 00:01:44.160
method as hopefully
you remember,

00:01:44.160 --> 00:01:46.140
we're going to introduce
a new method which

00:01:46.140 --> 00:01:48.420
we kind of basically
previewed last time

00:01:48.420 --> 00:01:50.430
called the reducibility
method, which

00:01:50.430 --> 00:01:52.440
is the way other
problems are typically

00:01:52.440 --> 00:01:56.420
shown to be undecidable.

00:01:56.420 --> 00:02:00.010
And so we're going to stick
with that for this lecture

00:02:00.010 --> 00:02:01.850
and also next lecture.

00:02:01.850 --> 00:02:04.870
We're going to be talking
about undecidability.

00:02:04.870 --> 00:02:08.889
And I think there's going to
be a few additional discussions

00:02:08.889 --> 00:02:09.860
after that.

00:02:09.860 --> 00:02:12.970
But this is one of
the important themes

00:02:12.970 --> 00:02:15.520
of the course is to
understand that threshold

00:02:15.520 --> 00:02:18.160
between decidability
and undecidability,

00:02:18.160 --> 00:02:23.780
or the limitations
of computation, OK.

00:02:23.780 --> 00:02:26.300
So today, as I
mentioned, we're going

00:02:26.300 --> 00:02:28.010
to talk about the
reducibility method

00:02:28.010 --> 00:02:30.290
for proving problems
undecidable and also

00:02:30.290 --> 00:02:34.760
for proving problems
non-turing recognizable,

00:02:34.760 --> 00:02:36.590
Turing unrecognizable.

00:02:36.590 --> 00:02:39.110
We're going to
introduce this notion

00:02:39.110 --> 00:02:41.960
of a reducibility in general.

00:02:41.960 --> 00:02:44.120
And we'll also talk about
a very specific kind

00:02:44.120 --> 00:02:46.680
of reducibility called
the mapping reducibility.

00:02:46.680 --> 00:02:48.650
So today as
promised, we're going

00:02:48.650 --> 00:02:51.230
to talk about using
reducibilities

00:02:51.230 --> 00:02:56.030
to prove problems are
undecidable, or unrecognizable.

00:02:56.030 --> 00:02:58.820
So that's going to be
our general method,

00:02:58.820 --> 00:03:02.060
oops, make myself
smaller, thank you.

00:03:02.060 --> 00:03:04.580
I always forget.

00:03:04.580 --> 00:03:06.755
Thank you for the reminder.

00:03:10.980 --> 00:03:17.040
So using reducibilities to
prove problems are undecidable,

00:03:17.040 --> 00:03:21.163
or unrecognizable, and
the basic way that works

00:03:21.163 --> 00:03:23.580
is we're going to leverage
another some problem we already

00:03:23.580 --> 00:03:26.790
know is undecidable
say, or unrecognizable

00:03:26.790 --> 00:03:29.280
to prove other problems
are unrecognizable.

00:03:29.280 --> 00:03:31.140
So we did a quick example
of that last time.

00:03:31.140 --> 00:03:33.690
We're going to go over
that example again just

00:03:33.690 --> 00:03:35.190
to set the stage.

00:03:35.190 --> 00:03:38.830
And then we're going to talk
about that in greater detail.

00:03:38.830 --> 00:03:42.370
So as you recall
from last time, we

00:03:42.370 --> 00:03:44.890
had this problem
HALT TM, which is

00:03:44.890 --> 00:03:47.410
the problem of testing
for a given Turing

00:03:47.410 --> 00:03:49.450
machine and an input
to that Turing machine,

00:03:49.450 --> 00:03:51.640
whether the Turing
machine halts,

00:03:51.640 --> 00:03:55.570
either accepting or rejecting,
but just whether it halts.

00:03:55.570 --> 00:03:57.850
Which is a somewhat different
problem, closely related

00:03:57.850 --> 00:04:00.160
obviously, but somewhat
different than the A TM

00:04:00.160 --> 00:04:02.740
problem, which is just
testing whether the Turing

00:04:02.740 --> 00:04:04.900
machine accepts.

00:04:04.900 --> 00:04:09.100
We already showed that
A TM is undecidable.

00:04:09.100 --> 00:04:14.200
Now, conceivably, HALT
TM might be decidable.

00:04:14.200 --> 00:04:16.390
You know, it's not
exactly the same problem.

00:04:16.390 --> 00:04:19.000
But we're going to show
that HALT TM is likewise

00:04:19.000 --> 00:04:20.360
undecidable.

00:04:20.360 --> 00:04:23.962
We did this last time, but
I'm just going over it again.

00:04:23.962 --> 00:04:26.700
I'm going to likewise show
that HALT TM is undecidable.

00:04:26.700 --> 00:04:30.480
We could go back to the
diagonalization method

00:04:30.480 --> 00:04:31.710
and do it from scratch.

00:04:31.710 --> 00:04:34.140
But generally, that's
not what's done.

00:04:34.140 --> 00:04:37.680
Generally what people do is they
use a reducibility from a known

00:04:37.680 --> 00:04:39.340
undecidable problem.

00:04:39.340 --> 00:04:42.120
And so what we're going to show
is a proof by contradiction

00:04:42.120 --> 00:04:49.840
which says that if
HALT TM were decidable,

00:04:49.840 --> 00:04:51.730
then A TM would
also be decidable.

00:04:51.730 --> 00:04:53.380
And we know it isn't.

00:04:53.380 --> 00:04:56.860
And that's by virtue of what we
call a reducibility from A TM

00:04:56.860 --> 00:04:57.557
to HALT TM.

00:04:57.557 --> 00:04:59.140
And I'll explain
with the terminology.

00:04:59.140 --> 00:05:01.870
And we'll have a chance
to play with the concept

00:05:01.870 --> 00:05:03.640
all lecture long.

00:05:03.640 --> 00:05:07.720
So we're going to see all
sorts of different variations.

00:05:07.720 --> 00:05:10.553
So as I said, we'll assume
HALT TM is decidable

00:05:10.553 --> 00:05:12.970
and use that to show that A
TM is decidable, which we know

00:05:12.970 --> 00:05:15.320
is not true.

00:05:15.320 --> 00:05:17.560
So quickly going through it
because we did it already

00:05:17.560 --> 00:05:20.830
once before, we're
going to assume

00:05:20.830 --> 00:05:22.780
that HALT TM is decidable.

00:05:22.780 --> 00:05:27.460
Let's say Turing machine
R is the decider.

00:05:27.460 --> 00:05:28.960
And now we're going
to show that ATM

00:05:28.960 --> 00:05:32.640
is decidable by constructing
a Turing machine S,

00:05:32.640 --> 00:05:37.010
which uses R to decide A TM.

00:05:37.010 --> 00:05:39.730
That's going to be
our contradiction.

00:05:39.730 --> 00:05:43.610
So here is the machine S.

00:05:43.610 --> 00:05:48.650
You have to keep in mind
what the goal of S is.

00:05:48.650 --> 00:05:53.640
We're going to design
S to solve A TM, which

00:05:53.640 --> 00:05:54.700
we know is not decidable.

00:05:54.700 --> 00:05:56.070
So don't get confused by that.

00:05:56.070 --> 00:05:59.500
We're aiming for
a contradiction.

00:05:59.500 --> 00:06:02.227
So we're going to
use S as typically--

00:06:02.227 --> 00:06:03.810
well, there might
be other variations.

00:06:03.810 --> 00:06:08.320
But for now, S is going
to be used to decide A TM.

00:06:08.320 --> 00:06:12.280
So we can try to figure
out, how can we decide A TM.

00:06:12.280 --> 00:06:20.050
And the way we're going to do
it is use our HALT TM tester

00:06:20.050 --> 00:06:23.480
that we assumed to have.

00:06:23.480 --> 00:06:26.910
And we'll first
take our M and w,

00:06:26.910 --> 00:06:29.970
where we're trying to
determine, does M accept w?

00:06:29.970 --> 00:06:33.000
And we'll first test
whether M halts on w.

00:06:33.000 --> 00:06:34.950
If it doesn't, we're done.

00:06:34.950 --> 00:06:37.170
Because it couldn't
be accepting w,

00:06:37.170 --> 00:06:39.450
M couldn't be accepting
w if it's not even

00:06:39.450 --> 00:06:40.620
just halting on w.

00:06:43.380 --> 00:06:50.210
So if R reports doesn't hold,
we can reject right off.

00:06:50.210 --> 00:06:55.580
But even if R says it does
halt, we're still in good shape

00:06:55.580 --> 00:06:59.120
because now we can run
M on w until completion

00:06:59.120 --> 00:07:02.800
because R has promised us
that it's going to halt.

00:07:02.800 --> 00:07:04.030
R is stated.

00:07:04.030 --> 00:07:06.060
And R is assumed to be correct.

00:07:06.060 --> 00:07:08.925
R is stated that M
halts on w, so now we

00:07:08.925 --> 00:07:10.300
don't have to
worry about getting

00:07:10.300 --> 00:07:12.220
into a loop, which
we're not allowed to do

00:07:12.220 --> 00:07:14.500
since we're making a decider.

00:07:14.500 --> 00:07:16.720
We're trying to
decide A TM here.

00:07:16.720 --> 00:07:18.640
But now we can run them
on w to completion.

00:07:18.640 --> 00:07:21.220
We can find out
what M does on w.

00:07:21.220 --> 00:07:22.878
And then we can act accordingly.

00:07:25.630 --> 00:07:29.220
So we're using the HALT
TM decider to decide A TM.

00:07:29.220 --> 00:07:32.700
That's the name of
the game here, OK?

00:07:32.700 --> 00:07:34.210
And that's a contradiction.

00:07:34.210 --> 00:07:37.133
And so therefore our assumption
that HALT TM was decidable

00:07:37.133 --> 00:07:37.800
had to be false.

00:07:37.800 --> 00:07:39.300
So it's undecidable.

00:07:39.300 --> 00:07:41.070
OK?

00:07:41.070 --> 00:07:44.550
Important to understand
this because this

00:07:44.550 --> 00:07:52.620
is sort of the prototype for
all of the other undecidability

00:07:52.620 --> 00:07:54.810
proofs that we're going
to do going forward.

00:07:54.810 --> 00:07:57.210
OK, so we can just take
a few seconds here.

00:07:57.210 --> 00:08:00.840
If there's something that
you're not getting about this,

00:08:00.840 --> 00:08:02.010
it's a good time to ask.

00:08:07.660 --> 00:08:12.760
Not seeing many messages here,
or any, so why don't we go on?

00:08:12.760 --> 00:08:17.410
But if you ask, I can get to
it next slide too, all right.

00:08:17.410 --> 00:08:18.050
Here we go.

00:08:18.050 --> 00:08:22.420
So here's the concept
of reducibility.

00:08:22.420 --> 00:08:24.420
And I know, I've taught
this course, many times.

00:08:24.420 --> 00:08:27.960
I know where the
bumpy places are

00:08:27.960 --> 00:08:30.900
in terms of people
struggling with material.

00:08:30.900 --> 00:08:37.750
The concept of reducibility
is a bit tricky.

00:08:37.750 --> 00:08:40.890
So don't feel bad if you
don't get it right away.

00:08:40.890 --> 00:08:42.390
You know, so that's
why I'm going

00:08:42.390 --> 00:08:44.340
to try to go slowly
in this lecture

00:08:44.340 --> 00:08:46.890
to make sure we're all
together on understanding

00:08:46.890 --> 00:08:50.050
how reducibility works.

00:08:50.050 --> 00:08:52.300
OK, so the concept
of reducibility

00:08:52.300 --> 00:08:55.870
is that we say one problem
is reducible to another,

00:08:55.870 --> 00:08:59.470
say A reducible to
B. It means that you

00:08:59.470 --> 00:09:04.700
can use B to solve A.
That's what it means

00:09:04.700 --> 00:09:08.930
for A to be reducible to B.

00:09:08.930 --> 00:09:11.720
OK, so I'm going to
give a bunch of sort

00:09:11.720 --> 00:09:16.090
of informal examples of that,
or easy examples of that.

00:09:16.090 --> 00:09:19.450
And then we'll start
to use it for real.

00:09:19.450 --> 00:09:23.733
So example 1, this is sort
of really outside material

00:09:23.733 --> 00:09:24.400
from the course.

00:09:24.400 --> 00:09:28.375
But I think it's something
you can appreciate.

00:09:28.375 --> 00:09:29.750
You know, everybody
knows you can

00:09:29.750 --> 00:09:34.310
measure the area of a
rectangle by measuring

00:09:34.310 --> 00:09:40.040
the lengths of the two
sides, measuring the length

00:09:40.040 --> 00:09:43.920
and width of the rectangle.

00:09:43.920 --> 00:09:46.670
So in other words, if
you had the problem

00:09:46.670 --> 00:09:51.320
of determining the area, you
could reduce that problem

00:09:51.320 --> 00:09:53.600
to the problem of
measuring the length

00:09:53.600 --> 00:09:57.340
and width of the rectangle.

00:09:57.340 --> 00:10:01.110
So here, we're
taking one problem

00:10:01.110 --> 00:10:02.970
and reducing it to
another problem.

00:10:02.970 --> 00:10:04.890
You know, it's
conceivable that measuring

00:10:04.890 --> 00:10:10.890
the length and width
is easier than it would

00:10:10.890 --> 00:10:14.580
be to measure the area
directly by somehow covering

00:10:14.580 --> 00:10:22.090
the space with tiles, is
one way of measuring it.

00:10:22.090 --> 00:10:25.605
But it tells you, you
don't have to do that.

00:10:25.605 --> 00:10:26.980
The problem of
measuring the area

00:10:26.980 --> 00:10:29.050
is easier than
covering with tiles.

00:10:29.050 --> 00:10:32.820
You can just measure the length
and width and you're done.

00:10:32.820 --> 00:10:34.800
So reducibility
is a way of making

00:10:34.800 --> 00:10:44.357
problems easier by translating
them into some easier problem.

00:10:44.357 --> 00:10:46.440
So here's another example
that we've already seen.

00:10:46.440 --> 00:10:48.510
We didn't call it
a reducibility.

00:10:48.510 --> 00:10:54.090
But if you remember back
a couple of weeks ago,

00:10:54.090 --> 00:10:56.120
we were talking about
the languages A NFA,

00:10:56.120 --> 00:11:01.300
and A DFA, the acceptance
problems for NFAs and DFAs.

00:11:01.300 --> 00:11:03.760
And we gave a way of
solving the A DFA problem.

00:11:03.760 --> 00:11:05.950
As you remember,
the Turing machine

00:11:05.950 --> 00:11:09.710
simulated the finite automaton.

00:11:09.710 --> 00:11:13.280
And we solved the
NFA problem not

00:11:13.280 --> 00:11:18.530
by doing it directly but by
converting the NFA to a DFA

00:11:18.530 --> 00:11:20.825
and then using the
solution for A DFA.

00:11:23.740 --> 00:11:25.330
In effect, what
we were doing was

00:11:25.330 --> 00:11:28.840
we were reducing the A NFA
problem to the A DFA problem.

00:11:38.250 --> 00:11:43.170
So let's do another example.

00:11:43.170 --> 00:11:44.210
Here's a problem.

00:11:44.210 --> 00:11:46.743
Here's an example
that you again,

00:11:46.743 --> 00:11:48.410
probably didn't think
about it this way.

00:11:48.410 --> 00:11:54.290
But from your homework, we
had this pusher problem,

00:11:54.290 --> 00:11:58.280
the problem of determining
whether a pushdown

00:11:58.280 --> 00:12:03.210
automaton ever pushes on
its stack for any input.

00:12:03.210 --> 00:12:05.040
I know a bunch of
you were struggling

00:12:05.040 --> 00:12:09.660
with that problem working
on it, hopefully solving it

00:12:09.660 --> 00:12:10.900
in one way or another.

00:12:10.900 --> 00:12:14.790
So there's one way to solve
it is in effect by reducing

00:12:14.790 --> 00:12:18.782
the pusher problem to the
E CFG the emptiness for CFG

00:12:18.782 --> 00:12:20.865
which is the equivalent
to the emptiness for PDAs.

00:12:28.320 --> 00:12:30.670
I mean, this is the
solution I had in mind,

00:12:30.670 --> 00:12:33.600
which is a particularly
simple and short solution.

00:12:33.600 --> 00:12:36.120
Of course, not
the only solution.

00:12:36.120 --> 00:12:38.280
You can take your
pushdown automaton

00:12:38.280 --> 00:12:41.870
where you're trying to
determine if it ever pushes.

00:12:41.870 --> 00:12:48.160
And you can take the states
that are about to make a push.

00:12:48.160 --> 00:12:50.680
And instead of making
them make a push,

00:12:50.680 --> 00:12:52.030
you make them accept states.

00:12:52.030 --> 00:12:54.070
And you get rid of the
original accept states.

00:12:56.660 --> 00:13:01.550
So now you've converted
this automaton

00:13:01.550 --> 00:13:08.300
to one that accepts every time
the original push on automaton

00:13:08.300 --> 00:13:10.278
pushes.

00:13:10.278 --> 00:13:12.820
And it accepts, and then has to
move to the end of the input,

00:13:12.820 --> 00:13:13.960
of course.

00:13:13.960 --> 00:13:15.780
So it goes into an
accept state and moves

00:13:15.780 --> 00:13:16.830
to the end of the input.

00:13:16.830 --> 00:13:20.190
So every time the original
machine was about to push,

00:13:20.190 --> 00:13:23.610
the new machine that
you're just creating here

00:13:23.610 --> 00:13:27.550
is going to go into an accept
state at the end of the input.

00:13:27.550 --> 00:13:31.840
Now to test whether the original
machine ever uses stack,

00:13:31.840 --> 00:13:34.720
it's enough to test whether
the new machine ever

00:13:34.720 --> 00:13:36.752
accepts an S string.

00:13:40.060 --> 00:13:41.170
OK, so that's a way.

00:13:41.170 --> 00:13:43.817
I don't want to overcomplicate
this right here and get

00:13:43.817 --> 00:13:45.400
you thinking about
the homework again.

00:13:45.400 --> 00:13:50.320
But this is a way of reducing
one problem to another problem.

00:13:50.320 --> 00:13:53.440
And if you don't
quite get this one,

00:13:53.440 --> 00:13:55.130
just focus on the
other two examples.

00:13:55.130 --> 00:13:57.700
I don't want to spend time on
the homework set 2 right now.

00:13:57.700 --> 00:14:02.213
So we can address that all
separately if you want.

00:14:02.213 --> 00:14:03.880
It's also the solution
that's written up

00:14:03.880 --> 00:14:09.070
in the solution set that's
posted on the home page

00:14:09.070 --> 00:14:09.580
by the way.

00:14:12.130 --> 00:14:15.680
OK, so getting
back to let's see,

00:14:15.680 --> 00:14:19.830
thinking about reducibility.

00:14:19.830 --> 00:14:22.470
What I have in mind, again,
this is sort of rephrasing it,

00:14:22.470 --> 00:14:26.970
but I'm trying to hammer it in
that if A is reducible to B,

00:14:26.970 --> 00:14:33.050
then solving B gives
a solution to A.

00:14:33.050 --> 00:14:36.560
Because that's what happens
in each of these examples.

00:14:36.560 --> 00:14:38.840
Now, how are we
going to use that?

00:14:38.840 --> 00:14:42.700
We're going to use that
in the following two ways.

00:14:42.700 --> 00:14:48.000
One is to observe that, if
A is reducible to B and B

00:14:48.000 --> 00:14:54.730
is an easy problem,
then A must also

00:14:54.730 --> 00:14:57.310
be easy because we have
a way of converting

00:14:57.310 --> 00:14:59.080
A problems into B problems.

00:14:59.080 --> 00:15:05.160
We have a way of solving
A using B. So B is easy.

00:15:05.160 --> 00:15:08.990
Then now you can
solve A too easily.

00:15:08.990 --> 00:15:12.950
Because you can solve A
using B, which is easy.

00:15:12.950 --> 00:15:16.670
Maybe that's clearest
up here in example 1,

00:15:16.670 --> 00:15:19.550
where measuring the area might
seem at first glance hard.

00:15:19.550 --> 00:15:21.980
You could have to walk
out over the whole area.

00:15:21.980 --> 00:15:23.510
But it's not hard
because you only

00:15:23.510 --> 00:15:25.218
have to measure the
length and the width.

00:15:27.340 --> 00:15:30.480
So the fact that B is easy
tells you that A is easy.

00:15:30.480 --> 00:15:32.420
But actually, this
is not the way

00:15:32.420 --> 00:15:34.170
we're going to be using
it most typically.

00:15:34.170 --> 00:15:37.080
We're going to be most
typically using it

00:15:37.080 --> 00:15:43.310
in the second version, which is
a little bit more convoluted.

00:15:43.310 --> 00:15:46.210
But this is the way you're going
to have to get used to this.

00:15:46.210 --> 00:15:49.265
So if A is reducible
to B, and you

00:15:49.265 --> 00:15:53.540
know A is hard,
undecidable, unrecognizable,

00:15:53.540 --> 00:15:56.340
whatever the form of
hard you care about,

00:15:56.340 --> 00:16:01.050
if you know A is hard,
and A is reducible to B,

00:16:01.050 --> 00:16:03.330
then that tells you B
also has to be hard.

00:16:06.290 --> 00:16:08.550
Why?

00:16:08.550 --> 00:16:12.320
Because if B were easy,
then A would be easy.

00:16:12.320 --> 00:16:15.960
But we're assuming
that A is hard.

00:16:15.960 --> 00:16:17.480
So B also has to be hard.

00:16:20.350 --> 00:16:25.480
OK, so I'm inverting
the logic here.

00:16:25.480 --> 00:16:29.240
But this is
logically equivalent.

00:16:29.240 --> 00:16:31.780
So you have to mull
that over a bit.

00:16:39.060 --> 00:16:40.710
So why don't you
think about that.

00:16:40.710 --> 00:16:43.320
And let me just take a
few questions on the chat

00:16:43.320 --> 00:16:45.540
and don't forget the
TAs are there too.

00:16:45.540 --> 00:16:47.820
So they're happy to
answer your questions.

00:16:47.820 --> 00:16:52.960
Don't make them sit
there lonely, all right.

00:16:55.960 --> 00:16:58.180
So somebody is
asking, is it possible

00:16:58.180 --> 00:17:03.630
that A is reducible to B and
that B is also reducible to A?

00:17:03.630 --> 00:17:05.220
So that's a good question.

00:17:05.220 --> 00:17:07.319
That can certainly happen.

00:17:07.319 --> 00:17:09.480
In that case in a
certain sense, A and B

00:17:09.480 --> 00:17:10.980
are going to be equivalent.

00:17:10.980 --> 00:17:16.290
So solving 1 is going to be
just as easy or hard as solving

00:17:16.290 --> 00:17:18.500
the other one, OK?

00:17:18.500 --> 00:17:20.750
So they're going to be
equivalent from the perspective

00:17:20.750 --> 00:17:23.760
of the difficulty
of solving them.

00:17:23.760 --> 00:17:24.859
So somebody is asking--

00:17:24.859 --> 00:17:29.600
and this is a
perennial confusion--

00:17:29.600 --> 00:17:34.206
so in the previous
slide here, I think

00:17:34.206 --> 00:17:36.100
I'll just flip back to it here.

00:17:36.100 --> 00:17:37.710
So which direction are we doing?

00:17:37.710 --> 00:17:41.205
Are we reducing A TM to
HALT TM or HALT TM to A TM?

00:17:41.205 --> 00:17:43.580
The way it's written on the
slide is what I have in mind.

00:17:43.580 --> 00:17:46.570
Here we're reducing
A TM to HALT TM

00:17:46.570 --> 00:17:52.250
because we're using
HALT TM to solve A TM.

00:17:52.250 --> 00:17:56.030
And that's reducing
A TM to HALT TM.

00:17:56.030 --> 00:18:04.100
Just like here,
measuring the area

00:18:04.100 --> 00:18:06.350
is reducible to measuring
the lengths of the sides,

00:18:06.350 --> 00:18:09.830
we're using measuring the length
of the sides to solve the area.

00:18:12.350 --> 00:18:16.840
So we're reducing the area
to the lengths, the area

00:18:16.840 --> 00:18:18.730
to the length of the sides.

00:18:18.730 --> 00:18:25.630
But I know you're going
to have to play with it,

00:18:25.630 --> 00:18:27.340
digest it, get used to it.

00:18:31.350 --> 00:18:38.470
All right, OK, so
let's continue.

00:18:38.470 --> 00:18:42.820
OK, so as I said,
this latter one

00:18:42.820 --> 00:18:46.120
because the focus on
this course is mainly

00:18:46.120 --> 00:18:48.700
on the limitations
of computation.

00:18:48.700 --> 00:18:52.060
So we're going to be
looking at ways of showing

00:18:52.060 --> 00:18:54.020
problems or difficulty.

00:18:54.020 --> 00:18:56.960
It could be difficult in
principle, like undecidable.

00:18:56.960 --> 00:18:58.383
Or it could be
difficult in terms

00:18:58.383 --> 00:19:00.050
of complexity, which
is what we're going

00:19:00.050 --> 00:19:01.610
to focus on in the second half.

00:19:01.610 --> 00:19:03.920
But in both cases,
we're going to be using

00:19:03.920 --> 00:19:05.720
the concept of reducibility.

00:19:05.720 --> 00:19:07.550
So reducibility is
going to be a theme.

00:19:07.550 --> 00:19:11.660
You've got to get comfortable
with reducibility, OK.

00:19:11.660 --> 00:19:14.060
So we're going to be
focusing more on the notion

00:19:14.060 --> 00:19:17.600
that if you reduce A to
B, and you know A is hard,

00:19:17.600 --> 00:19:20.990
that tells you B is also hard.

00:19:20.990 --> 00:19:25.310
OK, so I'm going to
say that a few times

00:19:25.310 --> 00:19:26.810
during the course
of today's lecture

00:19:26.810 --> 00:19:29.770
to try to help you get it.

00:19:29.770 --> 00:19:32.050
All right, here's a check in.

00:19:32.050 --> 00:19:35.650
A little bit sort
of off to the side.

00:19:35.650 --> 00:19:37.990
But I thought it was
a fun check in more.

00:19:41.420 --> 00:19:43.250
The question is, some
people say biology

00:19:43.250 --> 00:19:44.813
is reducible to physics.

00:19:44.813 --> 00:19:46.730
Well, maybe everything
is reducible to physics

00:19:46.730 --> 00:19:50.390
since physics tells you about
the laws of the universe.

00:19:50.390 --> 00:19:54.020
And biology is part
of the universe.

00:19:54.020 --> 00:19:57.410
So my question to
you is, do you think?

00:19:57.410 --> 00:19:59.550
And there's no
right answer here.

00:19:59.550 --> 00:20:01.410
Do you think, in
your opinion, is

00:20:01.410 --> 00:20:03.690
biology reducible to physics?

00:20:03.690 --> 00:20:08.250
Maybe yes, or maybe there are
some things like consciousness

00:20:08.250 --> 00:20:11.820
which cannot be
reduced to physics.

00:20:11.820 --> 00:20:13.690
Or maybe we don't know.

00:20:13.690 --> 00:20:18.275
So I'm curious to
know your thoughts.

00:20:23.110 --> 00:20:25.930
But it does kind
of use in a sense

00:20:25.930 --> 00:20:28.360
the notion of
reducible in the spirit

00:20:28.360 --> 00:20:31.420
of what I have in mind here.

00:20:31.420 --> 00:20:34.510
In the sense that if you could
fully understand physics,

00:20:34.510 --> 00:20:37.435
would that allow you to
fully understand biology?

00:20:42.640 --> 00:20:43.660
OK, here we are.

00:20:43.660 --> 00:20:50.400
We're almost-- kind of
interesting, though not too

00:20:50.400 --> 00:20:51.480
unexpected I suppose.

00:20:55.700 --> 00:20:59.660
So we are, I think,
just about done.

00:20:59.660 --> 00:21:03.830
5 seconds, pick anything if
you want to get credit for this

00:21:03.830 --> 00:21:08.310
and you haven't selected yet.

00:21:08.310 --> 00:21:09.750
Ready to go, ending polling.

00:21:12.690 --> 00:21:13.565
Here are the results.

00:21:17.900 --> 00:21:20.500
And as I say, there's
no right answer here.

00:21:20.500 --> 00:21:28.960
But if I had been in the
class, I would have picked B.

00:21:28.960 --> 00:21:33.580
But I'm not surprised,
especially in an MIT crowd

00:21:33.580 --> 00:21:39.195
that A is the winner, all right.

00:21:39.195 --> 00:21:39.820
Let's continue.

00:21:44.650 --> 00:21:48.410
OK, so now we're going to
use reducibility again.

00:21:48.410 --> 00:21:50.960
This is going to be yet another
example like the HALT TM

00:21:50.960 --> 00:21:53.030
example, but a
little bit harder.

00:21:55.005 --> 00:21:56.380
And we're going
to be doing this.

00:21:56.380 --> 00:21:57.838
You know, next
lecture, we're going

00:21:57.838 --> 00:22:01.030
to be doing more
reducibilities but much harder.

00:22:01.030 --> 00:22:08.415
So we really got to get
really comfortable, all right.

00:22:08.415 --> 00:22:09.290
I want to show E TMs.

00:22:09.290 --> 00:22:11.900
So E TM is the emptiness
problem for Turing machines.

00:22:11.900 --> 00:22:13.478
Is this language empty?

00:22:13.478 --> 00:22:15.020
I'm just going to
give you a machine.

00:22:15.020 --> 00:22:16.937
I want to know, is this
language empty or not?

00:22:16.937 --> 00:22:20.620
Does it accept something
or is this language empty?

00:22:20.620 --> 00:22:24.130
That's going to be
undecidable, no surprise, proof

00:22:24.130 --> 00:22:25.150
by contradiction.

00:22:25.150 --> 00:22:28.010
And we're going to show that
A TM is reducible to E TM.

00:22:31.730 --> 00:22:37.160
So these things often
take a very similar form.

00:22:37.160 --> 00:22:39.390
And I'm going to try
to use the same form.

00:22:39.390 --> 00:22:40.970
So if you're
feeling shaky on it,

00:22:40.970 --> 00:22:45.620
at least you'll get the form
of the way the solution goes

00:22:45.620 --> 00:22:52.240
and that will help you maybe
plug-in to solve problems, OK.

00:22:52.240 --> 00:22:57.290
So proof by
contradiction, assume

00:22:57.290 --> 00:22:59.630
that E TM is decidable,
opposite of what

00:22:59.630 --> 00:23:00.860
we've been trying to show.

00:23:00.860 --> 00:23:02.450
And then show that
A TM is decidable,

00:23:02.450 --> 00:23:03.560
which you know is false.

00:23:06.160 --> 00:23:10.440
So we'll say we have
a decider for A TM,

00:23:10.440 --> 00:23:14.560
R, using the same
letters on purpose

00:23:14.560 --> 00:23:18.220
here just to try to get
the pattern for you,

00:23:18.220 --> 00:23:20.020
so R deciding E TM.

00:23:20.020 --> 00:23:25.450
Construct S deciding A TM, OK.

00:23:25.450 --> 00:23:31.210
So now, let's think about
it together for a minute

00:23:31.210 --> 00:23:32.620
before I just put it up there.

00:23:36.390 --> 00:23:41.300
So S, I'm trying to
make a decider for A TM,

00:23:41.300 --> 00:23:48.850
using my decider for the
emptiness problem, OK?

00:23:48.850 --> 00:23:55.000
So we have R, which can tell us
whether M's language is empty.

00:23:55.000 --> 00:23:57.390
So why don't we
just, I don't know,

00:23:57.390 --> 00:24:03.780
stick M into that emptiness
tester and see what it says?

00:24:03.780 --> 00:24:05.280
I'm not saying this
is the solution,

00:24:05.280 --> 00:24:07.425
but this is how one might
think about coming up

00:24:07.425 --> 00:24:08.175
with the solution.

00:24:11.350 --> 00:24:13.060
So are you with me?

00:24:13.060 --> 00:24:17.350
We're going to take M, we
have an emptiness tester.

00:24:17.350 --> 00:24:22.030
Let's take M and plug it
into R, see what R says.

00:24:22.030 --> 00:24:25.420
R is going to come back and
tell us whether M's language is

00:24:25.420 --> 00:24:28.190
empty or not.

00:24:28.190 --> 00:24:32.285
Now, one of those answers
will make us happy.

00:24:36.040 --> 00:24:37.350
Why?

00:24:37.350 --> 00:24:45.640
Suppose R tells us that
M's language is empty.

00:24:45.640 --> 00:24:48.270
Why is that good?

00:24:48.270 --> 00:24:50.800
With that, we're done.

00:24:50.800 --> 00:24:52.480
Because S is trying
to figure out,

00:24:52.480 --> 00:24:55.810
we're trying to
figure out exactly,

00:24:55.810 --> 00:24:58.720
somebody told me the
answer which is correct.

00:24:58.720 --> 00:25:00.920
Because now we can reject.

00:25:00.920 --> 00:25:02.840
If M's language is
empty, it's clearly not

00:25:02.840 --> 00:25:07.350
accepting w because it's
not accepting anything.

00:25:07.350 --> 00:25:12.270
So if R says M's language
is empty, then we're good.

00:25:12.270 --> 00:25:15.470
The only problem is we also
say M's language is not empty.

00:25:15.470 --> 00:25:17.070
And then what do we know?

00:25:17.070 --> 00:25:20.750
Well, not much, not much
that's useful for testing

00:25:20.750 --> 00:25:21.860
whether M accepts w.

00:25:21.860 --> 00:25:24.080
We just know M
accepts something.

00:25:24.080 --> 00:25:26.720
But that something
may or may not be w.

00:25:32.270 --> 00:25:35.490
OK, so what do we do?

00:25:35.490 --> 00:25:39.510
Well, the problem is
that M is possibly

00:25:39.510 --> 00:25:44.310
accepting all sorts of
strings besides w, which are

00:25:44.310 --> 00:25:46.620
kind of mucking up the works.

00:25:46.620 --> 00:25:51.240
They're interfering with
the solution that we like.

00:25:51.240 --> 00:25:55.470
We'd like to be
able to use R on M

00:25:55.470 --> 00:25:58.170
to tell us whether
M is accepting w.

00:25:58.170 --> 00:25:59.640
But M is accepting other things.

00:25:59.640 --> 00:26:02.110
And that's making the
picture complicated.

00:26:02.110 --> 00:26:04.920
So what I propose
we do, why don't we

00:26:04.920 --> 00:26:10.830
modify M so that it never
accepts anything besides w?

00:26:10.830 --> 00:26:14.250
The very first thing M
does in the modified form

00:26:14.250 --> 00:26:16.170
is it looks at
its input and sees

00:26:16.170 --> 00:26:17.953
whether it's different from w.

00:26:17.953 --> 00:26:19.995
If it's different from w,
it immediately rejects.

00:26:22.880 --> 00:26:25.250
Now we take that
modified machine,

00:26:25.250 --> 00:26:27.590
and we feed it into
the emptiness tester.

00:26:30.860 --> 00:26:32.823
Now the emptiness
tester is going

00:26:32.823 --> 00:26:34.490
to give us the
information we're looking

00:26:34.490 --> 00:26:38.960
for because if the emptiness
tester says the modified

00:26:38.960 --> 00:26:40.490
machines language
is empty, well,

00:26:40.490 --> 00:26:44.180
we know that M is
not accepting w

00:26:44.180 --> 00:26:49.490
because we haven't changed how
M behaves when it's given w.

00:26:49.490 --> 00:26:56.330
But if R says M's
language is not empty,

00:26:56.330 --> 00:26:58.850
well, then it must be
that M is accepting w.

00:26:58.850 --> 00:27:00.560
Because we've
already filtered out

00:27:00.560 --> 00:27:03.440
all of the other
possibilities when

00:27:03.440 --> 00:27:06.280
we've modified the machine.

00:27:06.280 --> 00:27:08.910
So let me repeat
that on the slide

00:27:08.910 --> 00:27:11.950
and write it down a
little bit more formally.

00:27:11.950 --> 00:27:14.130
So what I'm going to do is
I'm going to transform M

00:27:14.130 --> 00:27:15.300
to a new Turing machine.

00:27:15.300 --> 00:27:18.720
I'm going to call it
M sub w to emphasize

00:27:18.720 --> 00:27:21.180
the fact that this new
machine depends on W.

00:27:21.180 --> 00:27:23.790
It's going to actually
have w built into as part

00:27:23.790 --> 00:27:26.668
of the rules of the machine.

00:27:26.668 --> 00:27:28.460
So for a different w,
we're going to end up

00:27:28.460 --> 00:27:29.710
with a different machine here.

00:27:29.710 --> 00:27:32.360
So this is a machine
whose structure is

00:27:32.360 --> 00:27:34.070
going to depend on knowing w.

00:27:37.030 --> 00:27:39.310
And that machine is
going to be very much

00:27:39.310 --> 00:27:42.460
like the original
machine M, except that

00:27:42.460 --> 00:27:45.940
when it gets an input,
let's say it's called X now,

00:27:45.940 --> 00:27:50.790
that machine is going
to compare X with w

00:27:50.790 --> 00:27:52.410
and reject if it's not equal.

00:27:55.590 --> 00:28:00.900
Otherwise, if X is equal to
w, it's going to run M on w

00:28:00.900 --> 00:28:01.690
as before.

00:28:01.690 --> 00:28:05.520
So it's not going to change the
behavior when the input is w.

00:28:05.520 --> 00:28:08.610
It's only going to change the
behavior when the input is

00:28:08.610 --> 00:28:10.800
something different
than w, and then it's

00:28:10.800 --> 00:28:16.350
going to reject, all right.

00:28:16.350 --> 00:28:21.660
So I'm going to look
at two aspects of this.

00:28:21.660 --> 00:28:25.770
First, let's understand the
language of this new machine.

00:28:25.770 --> 00:28:27.660
And then we'll
also talk about how

00:28:27.660 --> 00:28:31.120
we go about doing
this transformation.

00:28:31.120 --> 00:28:36.130
So first of all,
just for emphasis,

00:28:36.130 --> 00:28:39.510
so Mw works just like M.
It has all the rules of M

00:28:39.510 --> 00:28:42.600
in it, except some extra rules.

00:28:42.600 --> 00:28:45.750
It always at the
very first step,

00:28:45.750 --> 00:28:53.600
it tests whether X
is equal to w or not.

00:28:53.600 --> 00:28:56.590
And if it's not
equal to, it rejects.

00:28:56.590 --> 00:28:57.650
Not equal to, reject.

00:28:57.650 --> 00:28:59.560
So the language of
that new machine

00:28:59.560 --> 00:29:01.420
is either going to
be just the string

00:29:01.420 --> 00:29:04.840
w when M accepts w because
everything else is filtered

00:29:04.840 --> 00:29:05.950
out.

00:29:05.950 --> 00:29:08.373
Or the empty set if
M rejects something.

00:29:11.140 --> 00:29:15.150
So it's important that you
understand the behavior,

00:29:15.150 --> 00:29:18.790
at least, of this new machine.

00:29:18.790 --> 00:29:21.910
It's just like M except
filtering out all

00:29:21.910 --> 00:29:25.570
of the inputs which are not w.

00:29:25.570 --> 00:29:30.250
Those are going to be
automatically rejected.

00:29:30.250 --> 00:29:36.300
So it's also important
that S be able to make

00:29:36.300 --> 00:29:38.720
this transformation.

00:29:38.720 --> 00:29:41.800
But I claim that you'll
have to accept this

00:29:41.800 --> 00:29:43.780
if you don't totally see it.

00:29:43.780 --> 00:29:49.540
But the transformation
is simply taking M

00:29:49.540 --> 00:29:54.670
and adding some new rules,
some new transitions and states

00:29:54.670 --> 00:29:59.680
so that the very first
thing that M sub w does

00:29:59.680 --> 00:30:03.700
is it just has a
sequence of moves

00:30:03.700 --> 00:30:08.170
where it's checking that the
input string is equal to w

00:30:08.170 --> 00:30:09.260
or not.

00:30:09.260 --> 00:30:13.720
And if it's not equal
to w, it just rejects.

00:30:13.720 --> 00:30:16.240
So it's easy to modify
M. You could easily

00:30:16.240 --> 00:30:19.420
write a program which
would modify the states

00:30:19.420 --> 00:30:26.280
and transitions of M to make it
do that test at the beginning.

00:30:26.280 --> 00:30:28.940
So I'm not going to elaborate
on those kinds of things

00:30:28.940 --> 00:30:29.930
in the future.

00:30:29.930 --> 00:30:31.370
But just for the
very first time,

00:30:31.370 --> 00:30:33.740
I just want to make sure you
understand that we're not

00:30:33.740 --> 00:30:35.000
doing anything fishy here.

00:30:35.000 --> 00:30:41.570
This is a completely legitimate
thing for S to be able to do.

00:30:41.570 --> 00:30:45.200
So S can modify M
to this new machine

00:30:45.200 --> 00:30:48.840
Mw, which filters
that new machine,

00:30:48.840 --> 00:30:55.110
filters out all strings
except for w and rejects them.

00:30:55.110 --> 00:30:58.458
So S takes that new machine, and
what is it going to do with it?

00:30:58.458 --> 00:31:00.000
Is it ever going to
run that machine?

00:31:00.000 --> 00:31:01.750
No.

00:31:01.750 --> 00:31:04.780
This machine is built
not for running.

00:31:04.780 --> 00:31:11.510
This machine is built
for feeding into R.

00:31:11.510 --> 00:31:14.840
Because as you remember,
feeding M into R

00:31:14.840 --> 00:31:17.630
had the problem that M might
accept things besides w.

00:31:17.630 --> 00:31:20.810
And that confuses the result
that we get from R in the sense

00:31:20.810 --> 00:31:22.230
that it's not useful.

00:31:22.230 --> 00:31:26.560
But if we feed Mw
into R, now we're

00:31:26.560 --> 00:31:32.350
good because if the information
about whether Mw's language is

00:31:32.350 --> 00:31:36.430
empty from over here tells us
whether or not M accepts w.

00:31:39.500 --> 00:31:43.080
If Mw's language is not
empty, then M accepts w.

00:31:43.080 --> 00:31:45.784
If M's language is
empty, M rejects w.

00:31:51.690 --> 00:31:56.380
OK, so starting to get
some good questions here.

00:31:56.380 --> 00:32:00.600
Let me just finish
the description of S.

00:32:00.600 --> 00:32:02.260
So somebody is asking here.

00:32:02.260 --> 00:32:04.335
So this is an
excellent question.

00:32:08.670 --> 00:32:15.440
How do we know that Mw
halts on w, or whatever?

00:32:15.440 --> 00:32:16.700
We don't.

00:32:16.700 --> 00:32:18.470
Mw may not halt on w.

00:32:18.470 --> 00:32:20.820
We don't care.

00:32:20.820 --> 00:32:23.660
We're never going to
run Mw on anything.

00:32:26.800 --> 00:32:28.780
We're going to take
Mw as a machine,

00:32:28.780 --> 00:32:31.710
and we're going to feed it
into R as a description.

00:32:31.710 --> 00:32:33.460
We are going to take
the description of Mw

00:32:33.460 --> 00:32:37.000
and feed it into R.
Then it's R's problem.

00:32:37.000 --> 00:32:43.710
But R has been assumed to
answer emptiness testing.

00:32:43.710 --> 00:32:48.710
So we just took the original
machine, modified it

00:32:48.710 --> 00:32:52.100
so that the only possible
thing it could accept is w.

00:32:52.100 --> 00:32:54.500
And now feed it into
the emptiness tester

00:32:54.500 --> 00:32:57.780
to see whether its
language is empty or not.

00:32:57.780 --> 00:32:59.340
Now if its language
is not empty,

00:32:59.340 --> 00:33:01.920
it has to be accepting
w because it's built

00:33:01.920 --> 00:33:04.170
not to accept anything else.

00:33:04.170 --> 00:33:09.310
So we don't care whether
Mw might end up looping.

00:33:09.310 --> 00:33:10.520
We're never going to run Mw.

00:33:13.380 --> 00:33:17.520
I acknowledge, it's a
leap for many of you.

00:33:17.520 --> 00:33:21.610
So you're going to
have to mull it over.

00:33:21.610 --> 00:33:26.880
So we're going to use R to test
whether Mw's language is empty.

00:33:26.880 --> 00:33:29.820
If yes, that means
that M rejects w.

00:33:29.820 --> 00:33:31.320
So then we're going
to reject, if we

00:33:31.320 --> 00:33:33.570
know that Mw's
language is empty,

00:33:33.570 --> 00:33:36.580
that must have been
that M rejected w.

00:33:36.580 --> 00:33:40.560
So now as an A TM decider,
which is what S is,

00:33:40.560 --> 00:33:44.310
S is supposed to
reject, which is what we

00:33:44.310 --> 00:33:46.090
have here in the description.

00:33:46.090 --> 00:33:49.770
And if no, that means the
language is not empty.

00:33:49.770 --> 00:33:52.830
So M accepts w, and so
therefore we're accepting.

00:33:52.830 --> 00:33:55.660
So there's a little bit
of a twist here also.

00:33:55.660 --> 00:33:57.445
OK, so let's take some more.

00:34:01.580 --> 00:34:03.980
I'm expecting some
questions here.

00:34:03.980 --> 00:34:06.860
So somebody is
asking, how do you

00:34:06.860 --> 00:34:09.969
determine if the
language is decidable?

00:34:09.969 --> 00:34:13.100
I mean, that's what we're doing.

00:34:13.100 --> 00:34:17.420
You can show a language
is decidable by exhibiting

00:34:17.420 --> 00:34:19.820
a Turing machine
which decides it.

00:34:19.820 --> 00:34:22.429
And you can show a
language is not decidable,

00:34:22.429 --> 00:34:24.620
which is what we're
doing here by proving

00:34:24.620 --> 00:34:27.980
that it's not possible for a
Turing machine to decide it.

00:34:27.980 --> 00:34:30.560
You know, we did
that first with A TM.

00:34:30.560 --> 00:34:33.860
We got that contradiction
by diagonalization.

00:34:33.860 --> 00:34:36.800
And here we're
doing a reducibility

00:34:36.800 --> 00:34:43.570
to show as the method
of proof, all right.

00:34:43.570 --> 00:34:45.679
Let's continue.

00:34:45.679 --> 00:34:49.210
So now we're going to
talk about a special kind.

00:34:49.210 --> 00:34:52.270
So far we talked
about reducibility.

00:34:52.270 --> 00:34:55.030
We didn't define
it in a precise way

00:34:55.030 --> 00:34:57.130
because there are
several different ways

00:34:57.130 --> 00:35:01.150
to get at the notion of
reducibility precisely.

00:35:01.150 --> 00:35:03.940
And I'm going to introduce
a one version, which is

00:35:03.940 --> 00:35:05.320
a little bit more restrictive.

00:35:05.320 --> 00:35:07.480
I mean, somewhat more
restrictive and a little bit

00:35:07.480 --> 00:35:11.270
different way of looking at it
than we have been doing so far.

00:35:11.270 --> 00:35:13.720
But there were going to be
some benefits to looking

00:35:13.720 --> 00:35:16.060
at this particular kind of
reducibility, which we're

00:35:16.060 --> 00:35:18.730
calling mapping reducibility.

00:35:18.730 --> 00:35:21.550
It's going to have several
benefits for us immediately

00:35:21.550 --> 00:35:23.380
and down the road.

00:35:23.380 --> 00:35:27.760
But this is also
a little technical

00:35:27.760 --> 00:35:37.450
so don't get scared off.

00:35:37.450 --> 00:35:39.140
It might look
complicated at first.

00:35:39.140 --> 00:35:43.820
But we'll try to
unpack it for you, OK.

00:35:43.820 --> 00:35:51.080
So first of all, we have
to first of all talk

00:35:51.080 --> 00:35:54.040
about the notion of a
computable function.

00:35:54.040 --> 00:35:56.740
So generally when we've
had Turing machines,

00:35:56.740 --> 00:35:58.990
they're doing yes, no.

00:35:58.990 --> 00:36:02.210
They're doing accept,
reject kinds of things.

00:36:02.210 --> 00:36:04.660
So it's like a function,
just sort of a computing,

00:36:04.660 --> 00:36:07.630
sort of a binary function.

00:36:07.630 --> 00:36:10.840
For here, we're going to want to
talk about Turing machines that

00:36:10.840 --> 00:36:15.040
are computing a
function which converts

00:36:15.040 --> 00:36:17.760
one string to another string.

00:36:17.760 --> 00:36:22.810
So it's mapping from
strings to strings.

00:36:22.810 --> 00:36:28.600
And it could be like the
function which reverses

00:36:28.600 --> 00:36:30.700
the string, for example.

00:36:30.700 --> 00:36:34.960
That's one possible function
you could be having here.

00:36:34.960 --> 00:36:38.080
But there's of course zillions
of possible functions here.

00:36:38.080 --> 00:36:41.410
And we're going to talk about
functions that you can compute

00:36:41.410 --> 00:36:42.760
with the Turing machine.

00:36:42.760 --> 00:36:45.190
And that basically means
you provide the input

00:36:45.190 --> 00:36:47.470
to the function as input
to the Turing machine.

00:36:47.470 --> 00:36:50.200
And the output of the function,
the value of the function

00:36:50.200 --> 00:36:52.540
comes out as the output
of the Turing machine,

00:36:52.540 --> 00:36:55.480
which let's just say it
leaves that value on its tape

00:36:55.480 --> 00:36:56.440
when it halts.

00:36:56.440 --> 00:36:58.780
It halts with the value of
the function on the tape.

00:37:01.950 --> 00:37:05.050
But just, we're thinking
about algorithms here.

00:37:05.050 --> 00:37:06.640
Come up with your
favorite method

00:37:06.640 --> 00:37:08.080
of thinking about algorithms.

00:37:08.080 --> 00:37:09.820
It has an input and an output.

00:37:09.820 --> 00:37:12.310
And the algorithm just
computes the function

00:37:12.310 --> 00:37:16.222
by taking as input w,
and the output is f of w.

00:37:16.222 --> 00:37:18.040
It doesn't have to
be a Turing machine.

00:37:18.040 --> 00:37:20.410
Just any algorithm that
can compute something

00:37:20.410 --> 00:37:22.150
is good enough.

00:37:22.150 --> 00:37:24.983
They are all equivalent.

00:37:24.983 --> 00:37:27.150
And now we're going to use
this notion of a function

00:37:27.150 --> 00:37:31.260
that you can compute to
define a kind of reducibility

00:37:31.260 --> 00:37:32.967
called mapping reducibility.

00:37:32.967 --> 00:37:34.800
I'm going to say that
A is mapping reducible

00:37:34.800 --> 00:37:40.752
to B, written with this less
than or equal to sub M symbol.

00:37:40.752 --> 00:37:42.210
And you're going
to see that a lot.

00:37:42.210 --> 00:37:45.750
It's on the homework
also by the way.

00:37:45.750 --> 00:37:49.890
If there is some computable
function as I just described,

00:37:49.890 --> 00:37:58.530
where whenever w is
in A, f of w is in B.

00:37:58.530 --> 00:38:01.700
And the way to think about
it is with this picture.

00:38:01.700 --> 00:38:04.420
So A and B are
languages, written like,

00:38:04.420 --> 00:38:07.800
here's A and here's B.

00:38:07.800 --> 00:38:09.645
And now there are strings.

00:38:12.370 --> 00:38:19.140
So w might be in A.
It might be out of A.

00:38:19.140 --> 00:38:26.010
And you think of you're trying
to solve A. You're trying

00:38:26.010 --> 00:38:30.360
to decide membership in
A. So you want to test

00:38:30.360 --> 00:38:34.170
whether w is in A or not.

00:38:34.170 --> 00:38:36.910
A mapping reducible
is a function

00:38:36.910 --> 00:38:42.970
which maps things
from this space

00:38:42.970 --> 00:38:47.950
over to that space in a way
that strings that are in A

00:38:47.950 --> 00:38:51.440
get mapped to strings
that are in B.

00:38:51.440 --> 00:38:55.980
So if you start out with
w in A, f of w is in B.

00:38:55.980 --> 00:39:04.490
And if w is not in A, then f
of w is not in B. Pictorially

00:39:04.490 --> 00:39:06.218
it's a simple idea.

00:39:06.218 --> 00:39:07.760
We'll have to make
sure we understand

00:39:07.760 --> 00:39:13.910
why this fits with our
concept of reducibility.

00:39:13.910 --> 00:39:14.820
But we'll do that.

00:39:14.820 --> 00:39:16.400
But anyway, let's
first understand

00:39:16.400 --> 00:39:17.930
just what we're doing here.

00:39:17.930 --> 00:39:20.540
We're just coming up
with a function that

00:39:20.540 --> 00:39:22.400
can do this kind of a mapping.

00:39:22.400 --> 00:39:25.460
It sort of translates
problems which

00:39:25.460 --> 00:39:32.390
inputs which may or may not be
in A into other strings which

00:39:32.390 --> 00:39:40.970
may or may not be in B.
But sort of maintaining

00:39:40.970 --> 00:39:42.330
the same membership property.

00:39:42.330 --> 00:39:44.630
So if you start out
with something in A,

00:39:44.630 --> 00:39:48.860
when you apply f, you're going
to end up with something in B.

00:39:48.860 --> 00:39:54.715
And conversely, if you're not in
A, then you won't be in B, OK?

00:39:57.460 --> 00:40:01.700
Somebody is asking, so just
a couple of questions here.

00:40:01.700 --> 00:40:03.280
Not necessarily 1-to-1?

00:40:03.280 --> 00:40:05.740
No, so the function
doesn't have to be 1-to-1.

00:40:05.740 --> 00:40:08.455
There could be multiple things
that map to the same point.

00:40:11.530 --> 00:40:13.820
And is there any
restriction on the alphabet?

00:40:13.820 --> 00:40:14.320
No.

00:40:18.380 --> 00:40:24.400
So before we actually
get into the example,

00:40:24.400 --> 00:40:27.570
let me try to give
you a sense about why

00:40:27.570 --> 00:40:30.440
we call this a reducibility.

00:40:30.440 --> 00:40:36.700
And the reason is, suppose
we have such an f which can

00:40:36.700 --> 00:40:39.520
do the mapping as I described.

00:40:39.520 --> 00:40:45.820
And we also have a way of
deciding membership in B.

00:40:45.820 --> 00:40:48.610
So B is decidable.

00:40:48.610 --> 00:40:51.250
So that's going to tell us
right away that A is decidable.

00:40:51.250 --> 00:40:54.040
Because if you have some
input, and you want to know,

00:40:54.040 --> 00:41:02.380
is it an A or not, you can now
apply f and test whether f of w

00:41:02.380 --> 00:41:09.230
is in B. So the
test of w is in A,

00:41:09.230 --> 00:41:11.990
you're going to instead
test whether f of w is in B.

00:41:11.990 --> 00:41:16.050
And we're assuming that shows
that A is reducible to B.

00:41:16.050 --> 00:41:20.110
So if you could solve the B
problem, that also gives you

00:41:20.110 --> 00:41:22.200
a way to solve the A problem.

00:41:22.200 --> 00:41:25.137
So again, we're going to
say this several times

00:41:25.137 --> 00:41:26.220
in several different ways.

00:41:26.220 --> 00:41:31.040
So if you didn't quite
get it yet, don't panic.

00:41:31.040 --> 00:41:34.370
So here is going
to be an example.

00:41:34.370 --> 00:41:37.250
Sort of building on what
we just showed last time

00:41:37.250 --> 00:41:39.350
in the previous
slide, A TM, we're

00:41:39.350 --> 00:41:41.030
going to show how
A TM is actually

00:41:41.030 --> 00:41:45.740
mapping reducible to
the complement of E TM.

00:41:45.740 --> 00:41:47.450
And the complement
is necessary here.

00:41:50.710 --> 00:41:53.110
The computable function
that we're going to give,

00:41:53.110 --> 00:41:57.610
which is basically,
the computable function

00:41:57.610 --> 00:42:01.660
is going to translate
problems about A TM

00:42:01.660 --> 00:42:06.730
to problems about E TM
because we're mapping reducing

00:42:06.730 --> 00:42:09.870
A TM to the complement of E TM.

00:42:09.870 --> 00:42:16.420
So what we're doing here is with
mapping M and w to the machine

00:42:16.420 --> 00:42:16.920
Mw.

00:42:20.470 --> 00:42:23.890
Kind of in a way, we're
boiling out the essence,

00:42:23.890 --> 00:42:26.200
boiling down to the
essence of the proof

00:42:26.200 --> 00:42:28.470
that we gave in
the previous slide.

00:42:28.470 --> 00:42:31.590
This is really the
core of the proof.

00:42:31.590 --> 00:42:34.920
This translation of Mw
where you want to know,

00:42:34.920 --> 00:42:39.780
is M accepting w to a new
machine Mw where you're testing

00:42:39.780 --> 00:42:43.340
whether Mw's language is empty.

00:42:43.340 --> 00:42:47.180
And so remember Mw from before.

00:42:47.180 --> 00:42:48.920
It's the machine
that filters out

00:42:48.920 --> 00:42:51.470
all the non-w's
and rejects them.

00:42:54.060 --> 00:42:57.230
And the reason why this
reduction function works

00:42:57.230 --> 00:43:02.930
is that Mw is in A TM,
if and only if M sub w

00:43:02.930 --> 00:43:06.510
is in the complement of A TM.

00:43:06.510 --> 00:43:16.400
So M accepts w exactly when
Mw's language is not empty, OK?

00:43:16.400 --> 00:43:19.820
So M accepts w if and
only if the language of Mw

00:43:19.820 --> 00:43:21.180
is not empty.

00:43:21.180 --> 00:43:23.870
So you have to mull this
over a bit to realize it's--

00:43:23.870 --> 00:43:28.773
I know this can be
a little tricky.

00:43:28.773 --> 00:43:30.440
But I think what we're
going to do here,

00:43:30.440 --> 00:43:33.350
I think we're at the
time for the break.

00:43:33.350 --> 00:43:36.260
So oh, no, there's
one more slide.

00:43:36.260 --> 00:43:37.435
I apologize.

00:43:37.435 --> 00:43:38.810
So let's talk
about this and then

00:43:38.810 --> 00:43:40.352
we're going to have
our coffee break.

00:43:47.490 --> 00:43:50.250
So these properties
are really going

00:43:50.250 --> 00:43:56.370
to be getting at what
makes mapping reducibility

00:43:56.370 --> 00:44:00.310
fit with our understanding of
what a reducibility should be.

00:44:00.310 --> 00:44:03.360
So if A is mapping reducible
to B, and B is decidable,

00:44:03.360 --> 00:44:08.060
then so is A. So that
fits with what we want.

00:44:08.060 --> 00:44:10.850
Because if A is reducible to B,
and B is easy, then A is easy.

00:44:10.850 --> 00:44:14.073
So here easy means decidable.

00:44:14.073 --> 00:44:14.990
And here is the proof.

00:44:14.990 --> 00:44:17.420
Let's take a Turing
machine that decides B

00:44:17.420 --> 00:44:23.010
and construct a Turing machine
that decides A as claimed,

00:44:23.010 --> 00:44:24.600
S operates like this.

00:44:24.600 --> 00:44:28.860
It takes its input,
computes f of that input,

00:44:28.860 --> 00:44:38.520
tests whether f of w
is in B using the R

00:44:38.520 --> 00:44:40.440
machine that we were assuming.

00:44:40.440 --> 00:44:45.150
We have R deciding B.
And if R halts then

00:44:45.150 --> 00:44:47.700
output the same result.

00:44:47.700 --> 00:44:49.550
So if R accepts,
we're going to accept.

00:44:49.550 --> 00:44:51.590
If R halts and
rejects, we'll reject.

00:44:51.590 --> 00:44:54.110
And of course we're going
to be similarly running R.

00:44:54.110 --> 00:44:56.210
So if R is not
going to be halting,

00:44:56.210 --> 00:44:58.630
we are not going to
end up halting either.

00:44:58.630 --> 00:44:59.770
OK?

00:44:59.770 --> 00:45:02.200
So the corollary is,
and this is the way

00:45:02.200 --> 00:45:09.620
we're going to be using
it, if A is reducible to B

00:45:09.620 --> 00:45:17.090
and A is undecidable, then so
is B. So this is as I mentioned,

00:45:17.090 --> 00:45:20.180
the focus for us is going
to be on undecidability.

00:45:20.180 --> 00:45:22.250
And you may want
to think about A

00:45:22.250 --> 00:45:27.020
is like the A TM problem
which we know is undecidable.

00:45:27.020 --> 00:45:29.090
We're going to show
the A TM is mapping

00:45:29.090 --> 00:45:31.640
reducible to some other problem
to show that other problem is

00:45:31.640 --> 00:45:32.608
undecidable.

00:45:36.938 --> 00:45:38.480
And the important
thing about mapping

00:45:38.480 --> 00:45:42.990
reducibility is that it
also applies to recognizes.

00:45:42.990 --> 00:45:44.840
So if A is mapping
reducible to B,

00:45:44.840 --> 00:45:48.150
and B is Turing
recognizable, then so is A.

00:45:48.150 --> 00:45:51.630
So if you're reducing A
to a recognizable problem,

00:45:51.630 --> 00:45:54.740
then A is also
recognizable, same proof.

00:45:54.740 --> 00:45:58.910
Because you can just
map your w to f of w

00:45:58.910 --> 00:46:01.130
and feed it into the recognizer.

00:46:01.130 --> 00:46:02.690
That's going to give
you a recognizer

00:46:02.690 --> 00:46:03.773
for the original language.

00:46:07.010 --> 00:46:11.510
And the corollary is that if
A is mapping reducible to B,

00:46:11.510 --> 00:46:14.300
and A is unrecognizable,
then so is B.

00:46:14.300 --> 00:46:19.020
So this is again
that inverted logic.

00:46:19.020 --> 00:46:20.970
So now I think we're--

00:46:20.970 --> 00:46:25.170
oops, I meant to put
this picture up earlier.

00:46:25.170 --> 00:46:28.710
OK, so here's a check in.

00:46:28.710 --> 00:46:30.780
It will be more of a
check in for me to see

00:46:30.780 --> 00:46:34.660
how well you're following me.

00:46:34.660 --> 00:46:37.325
So these are some properties--

00:46:37.325 --> 00:46:38.950
so I'll give you a
minute here to think

00:46:38.950 --> 00:46:43.720
about this-- some properties
of mapping reducibility.

00:46:43.720 --> 00:46:48.870
Suppose A is mapping reducible
to B, what can we conclude?

00:46:48.870 --> 00:46:52.242
Does that mean that
we can flip it around?

00:46:52.242 --> 00:46:53.950
If A is mapping
reducible to B, does that

00:46:53.950 --> 00:46:56.660
mean that B is mapping
reducible to A?

00:46:56.660 --> 00:46:58.250
What about this one?

00:46:58.250 --> 00:47:01.610
If A is mapping reducible
to B, is the complement

00:47:01.610 --> 00:47:03.950
of A mapping reducible
to the complement of B,

00:47:03.950 --> 00:47:04.760
or maybe neither?

00:47:04.760 --> 00:47:17.260
So you can check all that apply,
multiple choice, 5 seconds.

00:47:20.490 --> 00:47:24.660
Sorry to pressure you, but
we have to move on here.

00:47:24.660 --> 00:47:26.520
Pick anything.

00:47:26.520 --> 00:47:33.290
If you don't know, OK,
1, 2, 3, the end, OK.

00:47:36.780 --> 00:47:40.540
Well, the majority is correct.

00:47:40.540 --> 00:47:51.170
In fact, it's only
B. Now, A really

00:47:51.170 --> 00:47:53.150
is not in the spirit
of reducibility.

00:47:53.150 --> 00:47:59.810
Because as suggested even by
the inequality sign there,

00:47:59.810 --> 00:48:03.080
A being reducible to B is really
a rather different thing than B

00:48:03.080 --> 00:48:07.890
being reducible to A.

00:48:07.890 --> 00:48:09.482
So that's something.

00:48:09.482 --> 00:48:11.190
We're not going to
prove that right here.

00:48:11.190 --> 00:48:17.760
But that's something that
you could think about.

00:48:17.760 --> 00:48:22.500
But part B, I think,
if you just look here

00:48:22.500 --> 00:48:26.370
at the definition of
mapping reducibility,

00:48:26.370 --> 00:48:30.780
it maps strings in
to in and out to out.

00:48:30.780 --> 00:48:33.960
Well, that's just going to be if
you exchange in and out as you

00:48:33.960 --> 00:48:36.900
do when you're flipping
compliments on both sides,

00:48:36.900 --> 00:48:40.380
it's still by the same f going
to still work as a mapping

00:48:40.380 --> 00:48:42.420
reduction, OK?

00:48:42.420 --> 00:48:47.170
So now we're at
our coffee break.

00:48:47.170 --> 00:48:54.920
So we're going to take
five minutes here,

00:48:54.920 --> 00:49:02.910
and I'll be happy to
take questions here.

00:49:02.910 --> 00:49:03.850
Don't forget the TAs.

00:49:03.850 --> 00:49:04.680
They're here to.

00:49:08.215 --> 00:49:08.715
OK.

00:49:19.530 --> 00:49:21.180
OK, so this is a
fair question here.

00:49:21.180 --> 00:49:24.360
You know, so we had this
notion of a general reduction

00:49:24.360 --> 00:49:26.460
and a mapping reduction.

00:49:26.460 --> 00:49:27.760
They are not the same.

00:49:27.760 --> 00:49:30.210
So any time you have
a mapping reduction,

00:49:30.210 --> 00:49:33.390
it's going to be an example of
a general reduction, but not

00:49:33.390 --> 00:49:35.170
the other way around.

00:49:35.170 --> 00:49:37.650
So if you go back and
look at the reduction

00:49:37.650 --> 00:49:41.820
that we offered
for HALT TM where

00:49:41.820 --> 00:49:46.350
we showed A TM is reducible
to HALT TM where we started,

00:49:46.350 --> 00:49:49.743
it's actually not
a mapping reduction

00:49:49.743 --> 00:49:51.660
because we're doing
something more complicated

00:49:51.660 --> 00:49:55.020
than translating an A
TM problem to a HALT TM.

00:49:55.020 --> 00:49:58.020
We're kind of using
the HALT TM decider

00:49:58.020 --> 00:49:59.550
in a more complicated way.

00:49:59.550 --> 00:50:03.340
And there are cases where
that's actually necessary.

00:50:03.340 --> 00:50:08.570
So we're not going
to discuss that here.

00:50:08.570 --> 00:50:11.360
But it's actually kind of an
interesting homework problem

00:50:11.360 --> 00:50:14.150
perhaps, or some kind of
a problem to think about.

00:50:17.078 --> 00:50:22.850
So Turing machines for f's,
it's not really a decider,

00:50:22.850 --> 00:50:23.893
but it has to be--

00:50:23.893 --> 00:50:26.060
well, I guess it does have
to be a decider in a way.

00:50:26.060 --> 00:50:26.900
It's always halts.

00:50:26.900 --> 00:50:29.090
The Turing machines for
f has to always halt.

00:50:29.090 --> 00:50:30.570
It always has to have an output.

00:50:30.570 --> 00:50:41.910
So f for the computing the
function always has to halt.

00:50:41.910 --> 00:50:46.730
So someone is asking me,
can I explain the statement

00:50:46.730 --> 00:50:49.640
that if error halts, then
output the same result?

00:50:49.640 --> 00:50:53.210
I just mean that in that
previous slide, or two

00:50:53.210 --> 00:50:57.320
slides back, if R accepts,
halts and accepts,

00:50:57.320 --> 00:50:58.850
then we're going
to halt and accept.

00:50:58.850 --> 00:51:02.240
And if R halts and rejects,
then we halt and reject.

00:51:02.240 --> 00:51:04.400
So I don't know if
this is a good idea,

00:51:04.400 --> 00:51:06.870
but we can just
pull that back here.

00:51:06.870 --> 00:51:08.270
So that was the statement here.

00:51:08.270 --> 00:51:10.310
If our halts and
output the same result,

00:51:10.310 --> 00:51:12.980
I just mean that S is
going to do the same.

00:51:12.980 --> 00:51:18.950
You know, we're translating
an A problem to a B problem,

00:51:18.950 --> 00:51:21.270
and then answering
the B problem.

00:51:21.270 --> 00:51:25.740
And we're going to give the same
value, the same answer there.

00:51:25.740 --> 00:51:29.716
So whatever R says,
we're going to say too,

00:51:29.716 --> 00:51:35.070
if that's helpful, all right.

00:51:37.653 --> 00:51:39.070
Boy, this is a
good question here.

00:51:41.860 --> 00:51:46.600
If A is reducible to B, why
can't we just get B reducible

00:51:46.600 --> 00:51:48.400
to A by inverting the function?

00:51:48.400 --> 00:51:49.400
That's a great question.

00:51:49.400 --> 00:51:52.450
I like that question.

00:51:52.450 --> 00:51:57.910
The reason is because the
function that's mapping onto B

00:51:57.910 --> 00:52:01.420
doesn't have to be onto,
subjective I guess.

00:52:01.420 --> 00:52:10.030
So if it was onto, so
if it covered all of B,

00:52:10.030 --> 00:52:13.690
then I think then you would
get an invertible function.

00:52:13.690 --> 00:52:18.560
And you would get the reduction
going the other way as well.

00:52:18.560 --> 00:52:21.590
But though, I'm not sure
what happens when you have.

00:52:21.590 --> 00:52:24.053
It doesn't matter if
you have collisions.

00:52:24.053 --> 00:52:25.720
It turns out that's
not going to matter.

00:52:25.720 --> 00:52:28.700
But anyway, let's not get
it too complicated here.

00:52:28.700 --> 00:52:33.190
But the problem with inverting
it is that it's not necessarily

00:52:33.190 --> 00:52:42.710
onto the whole range of B.

00:52:42.710 --> 00:52:44.165
So we're kind of
out of time here.

00:52:47.144 --> 00:52:48.970
Is A reducible to A compliment?

00:52:48.970 --> 00:52:49.970
Let me just handle that.

00:52:49.970 --> 00:52:52.820
No, not necessarily.

00:52:52.820 --> 00:52:55.910
It's reducible.

00:52:55.910 --> 00:53:00.380
A is reducible to A complement,
but not mapping reducible

00:53:00.380 --> 00:53:01.250
to A compliment.

00:53:01.250 --> 00:53:04.280
But A is general
reducible to A compliment.

00:53:04.280 --> 00:53:05.810
So actually we'll talk.

00:53:05.810 --> 00:53:07.740
I have a slide on that.

00:53:07.740 --> 00:53:12.270
So let us move on, OK?

00:53:12.270 --> 00:53:14.370
Mapping I think, it's
actually this line, mapping

00:53:14.370 --> 00:53:16.740
versus general reducibility.

00:53:16.740 --> 00:53:19.408
So we're going to
contrast it to a bit.

00:53:19.408 --> 00:53:21.450
So mapping reducibility,
which is what we've just

00:53:21.450 --> 00:53:22.990
been talking about
has this picture,

00:53:22.990 --> 00:53:27.090
which is, I think, a very
useful picture to remember.

00:53:27.090 --> 00:53:34.590
And because I like to think
of a mapping reduction

00:53:34.590 --> 00:53:37.740
as a problem translator.

00:53:37.740 --> 00:53:40.080
Your problem is sort
of in the A domain.

00:53:40.080 --> 00:53:43.290
And the mapping reduction allows
you to translate that problem

00:53:43.290 --> 00:53:46.030
into the B domain.

00:53:46.030 --> 00:53:49.750
OK, and then if you have a way
of solving it in the B domain,

00:53:49.750 --> 00:53:51.220
combining that
with the reduction,

00:53:51.220 --> 00:53:55.730
you get a solution to the
problem in the A domain.

00:53:55.730 --> 00:53:59.380
So that's why if A is
mapping reducible to B,

00:53:59.380 --> 00:54:02.150
and B is solvable, then
A is also solvable.

00:54:04.700 --> 00:54:08.830
So mapping reduction is a
special kind of reducibility,

00:54:08.830 --> 00:54:11.440
as opposed to the general
notion in general reducibility

00:54:11.440 --> 00:54:12.910
where we started.

00:54:12.910 --> 00:54:16.990
And it's particularly useful to
prove Turing unrecognizability.

00:54:16.990 --> 00:54:22.600
So when you want to prove
Turing unrecognizability,

00:54:22.600 --> 00:54:28.090
as we'll see, general
reducibility is not fine

00:54:28.090 --> 00:54:31.690
enough in a way, it doesn't
sort of differentiate things

00:54:31.690 --> 00:54:34.090
as well as mapping
reducibility does.

00:54:34.090 --> 00:54:37.450
And for that reason,
it's not always

00:54:37.450 --> 00:54:41.020
going to be useful to prove
Turing unrecognizability.

00:54:41.020 --> 00:54:43.897
It's better for
proving undecidability.

00:54:47.240 --> 00:54:49.300
So what we're
calling reducibility,

00:54:49.300 --> 00:54:52.750
or general reducibility
is where we just

00:54:52.750 --> 00:54:55.540
use a solvent for B
to solve A in sort

00:54:55.540 --> 00:54:58.460
of a most general possible way.

00:54:58.460 --> 00:55:00.740
So I'm writing that
as a picture here.

00:55:00.740 --> 00:55:02.920
If you want to solve
A, you're going

00:55:02.920 --> 00:55:07.942
to use the B solver as
a subroutine to solve A.

00:55:07.942 --> 00:55:13.270
That's the way we did the HALT
TM reduction at the beginning.

00:55:13.270 --> 00:55:16.600
But we didn't necessarily
translate an A TM problem

00:55:16.600 --> 00:55:18.830
to a HALT TM problem.

00:55:18.830 --> 00:55:20.850
It's slightly different.

00:55:20.850 --> 00:55:23.430
So you can go back
and look at that.

00:55:23.430 --> 00:55:27.380
So I find that people
struggle more with the mapping

00:55:27.380 --> 00:55:29.030
reducibility concept.

00:55:29.030 --> 00:55:30.680
And that the
general reducibility

00:55:30.680 --> 00:55:33.650
is what people naturally
gravitate towards.

00:55:33.650 --> 00:55:36.350
And so in some sense,
it's conceptually simpler.

00:55:36.350 --> 00:55:38.520
And it's useful to
proving undecidability.

00:55:38.520 --> 00:55:40.520
But you really have to
be comfortable with both.

00:55:40.520 --> 00:55:43.430
And especially in
the complexity part,

00:55:43.430 --> 00:55:48.060
we're going to be focusing
on mapping reducibility.

00:55:48.060 --> 00:55:52.410
So one noteworthy difference
here as sort of foreshadowed

00:55:52.410 --> 00:55:55.350
by the person who made
this question, which

00:55:55.350 --> 00:55:59.220
is a good question,
is that A is reducible

00:55:59.220 --> 00:56:02.370
using a general reduction to A
compliment, which kind of makes

00:56:02.370 --> 00:56:03.300
sense.

00:56:03.300 --> 00:56:08.702
I mean, if I can test whether
things are in A compliment,

00:56:08.702 --> 00:56:10.410
well, I can test
whether things are in A.

00:56:10.410 --> 00:56:13.670
You just invert the answer.

00:56:13.670 --> 00:56:17.840
But A may not be mapping
reducible to A compliment

00:56:17.840 --> 00:56:20.690
because there is a very
special kind of reduction.

00:56:20.690 --> 00:56:24.945
And you have to just translate
things in the language

00:56:24.945 --> 00:56:27.320
to things in the language,
and things out of the language

00:56:27.320 --> 00:56:28.570
to things out of the language.

00:56:28.570 --> 00:56:32.000
And they don't necessarily
allow you to do that inversion.

00:56:32.000 --> 00:56:36.620
So for example, A
TM complement is not

00:56:36.620 --> 00:56:38.870
mapping reducible to A TM.

00:56:38.870 --> 00:56:42.420
Because as we
pointed out, anything

00:56:42.420 --> 00:56:45.090
that's reducible to a
recognizable language

00:56:45.090 --> 00:56:46.860
is going to be recognizable.

00:56:46.860 --> 00:56:50.100
Anything mapping reducible
to a recognizable language

00:56:50.100 --> 00:56:52.600
is going to be recognizable.

00:56:52.600 --> 00:56:55.390
But we know that A TM
complement is not recognizable.

00:56:55.390 --> 00:56:56.830
We showed that before.

00:56:56.830 --> 00:57:02.076
So it couldn't be mapping
reducible to A TM.

00:57:02.076 --> 00:57:04.170
It's coming a little
fast I realize.

00:57:04.170 --> 00:57:07.210
You're going to
have to digest it.

00:57:07.210 --> 00:57:10.140
So here's the last
check in for today.

00:57:16.350 --> 00:57:19.740
OK, we showed that if A
is mapping reducible to B,

00:57:19.740 --> 00:57:23.740
and B is Turing
recognizable, then so is A.

00:57:23.740 --> 00:57:26.290
And so let's just say
that again carefully.

00:57:26.290 --> 00:57:32.220
If A is mapping reducible to B,
and B is Turing recognizable,

00:57:32.220 --> 00:57:37.350
then so is A. And here are the
emphasis on Turing recognizable

00:57:37.350 --> 00:57:41.030
as opposed to decidable.

00:57:41.030 --> 00:57:43.760
Is the same true if we use
general reducibility instead

00:57:43.760 --> 00:57:47.690
of mapping reducibility?

00:57:47.690 --> 00:57:48.540
So you got it?

00:57:48.540 --> 00:57:51.350
So we're saying A is
mapping reducible to B

00:57:51.350 --> 00:57:53.790
using this picture over here.

00:57:53.790 --> 00:57:59.670
And we're going to assume
that B is Turing recognizable,

00:57:59.670 --> 00:58:02.970
so that we have a
machine which halts an

00:58:02.970 --> 00:58:07.412
accepts when you're
inside B, and you know,

00:58:07.412 --> 00:58:09.620
is going to reject possibly
a looping when you're not

00:58:09.620 --> 00:58:10.820
inside B.

00:58:10.820 --> 00:58:16.520
Now, that allows you to get
a recognizer for A if you

00:58:16.520 --> 00:58:18.790
have a mapping reduction.

00:58:18.790 --> 00:58:21.040
Does it always work to
give you a recognizer

00:58:21.040 --> 00:58:23.210
if you have just a
general reduction?

00:58:23.210 --> 00:58:27.087
If you just have now,
assuming you have a B solver,

00:58:27.087 --> 00:58:29.170
and you're going to build
an A solver out of that.

00:58:32.650 --> 00:58:35.020
OK, so mull that over while
I'm setting this thing up.

00:58:37.680 --> 00:58:42.330
Well, the right answer is
winning, but not by much.

00:58:42.330 --> 00:58:47.190
I suppose I shouldn't
be laughing about it.

00:58:47.190 --> 00:58:49.903
But I knew that this is
going to be challenging.

00:58:49.903 --> 00:58:51.570
So I think it's the
kind of thing you're

00:58:51.570 --> 00:58:55.630
going to have to work at.

00:58:55.630 --> 00:59:01.790
So let's see we're almost
done here, 5 seconds to go.

00:59:01.790 --> 00:59:03.590
Better answer that, I
can see a few of you,

00:59:03.590 --> 00:59:09.250
either you've left
the room, or you're--

00:59:09.250 --> 00:59:12.820
OK, 2 seconds, 1, 2, 3.

00:59:12.820 --> 00:59:14.170
Somebody hasn't answered it.

00:59:18.750 --> 00:59:19.300
There we go.

00:59:19.300 --> 00:59:24.000
So the correct answer
is B. It's not the same.

00:59:24.000 --> 00:59:26.667
The reason is that
in general, I mean,

00:59:26.667 --> 00:59:27.750
the picture is right here.

00:59:35.360 --> 00:59:47.360
Let's see, how do
I explain this?

00:59:47.360 --> 00:59:58.080
So we know that a
language is going to be--

00:59:58.080 --> 01:00:00.930
OK, if we're using
general disability

01:00:00.930 --> 01:00:11.490
and A is just reducible to B,

01:00:11.490 --> 01:00:14.450
we know that a
language is always

01:00:14.450 --> 01:00:19.790
reducible to its complement
in using general reducibility.

01:00:19.790 --> 01:00:33.630
So if this were true,
then we would have here

01:00:33.630 --> 01:00:40.760
so if this were true,
when a language is

01:00:40.760 --> 01:00:43.430
reducible to its complement,
if the complement were

01:00:43.430 --> 01:00:46.940
recognizable, the language
would also be recognizable.

01:00:46.940 --> 01:00:53.040
That clearly is not going to
be the case because you know,

01:00:53.040 --> 01:00:56.390
A TM complement is
reducible to A TM

01:00:56.390 --> 01:00:58.820
using general reducibility.

01:00:58.820 --> 01:01:02.690
But A TM complement
is not recognizable

01:01:02.690 --> 01:01:04.280
even though A TM
is recognizable.

01:01:04.280 --> 01:01:06.950
So we kind of have a proof
that this has to be no.

01:01:06.950 --> 01:01:12.170
But as you can see, I'm even
getting myself confused.

01:01:12.170 --> 01:01:14.390
So you have to stare at it.

01:01:14.390 --> 01:01:17.630
So let me see, we can try to
take a couple of questions

01:01:17.630 --> 01:01:21.960
see if I can clear up
people's confusion.

01:01:21.960 --> 01:01:24.720
So why again, is A
reducible to its complement

01:01:24.720 --> 01:01:27.090
in the general sense?

01:01:27.090 --> 01:01:29.810
So I'm saying, if
you have a solver,

01:01:29.810 --> 01:01:33.410
if you have a decider
for A compliment,

01:01:33.410 --> 01:01:38.180
it gives you a solver for
A. You just ask the solver,

01:01:38.180 --> 01:01:40.850
is the string in
the language or not?

01:01:40.850 --> 01:01:45.240
And now you just give
the opposite answer

01:01:45.240 --> 01:01:48.550
if you want to solve the
complimentary problem.

01:01:48.550 --> 01:01:53.250
So the A complement is
general reducible to A.

01:01:53.250 --> 01:01:56.250
You just invert the answer for
whatever the solver is doing

01:01:56.250 --> 01:01:58.830
for A. But you can't just
do that inversion when

01:01:58.830 --> 01:02:01.530
you have a mapping reduction.

01:02:01.530 --> 01:02:07.690
It's a much more kind of
specific translation that's

01:02:07.690 --> 01:02:08.190
allowed.

01:02:10.910 --> 01:02:12.740
I mean, the
fundamental difference

01:02:12.740 --> 01:02:14.990
between general reducibility
and mapping reducibility,

01:02:14.990 --> 01:02:17.630
I'm trying to bring it out here.

01:02:17.630 --> 01:02:19.130
It's just a difference
in the nature

01:02:19.130 --> 01:02:20.750
of the way things are used.

01:02:20.750 --> 01:02:23.030
Mapping reducibility
is a special kind

01:02:23.030 --> 01:02:25.010
of general reducibility.

01:02:25.010 --> 01:02:27.140
So to answer the
question about what's

01:02:27.140 --> 01:02:31.580
the fundamental difference,
one is using the problem

01:02:31.580 --> 01:02:38.750
as a subroutine and the one is
using it as a transformation.

01:02:42.270 --> 01:02:46.540
Anyway, I think we're going
to have to move on here.

01:02:46.540 --> 01:02:49.660
And I am going to have couple
of examples which may help.

01:02:49.660 --> 01:02:57.750
And then, there are office
hours too after the lecture.

01:02:57.750 --> 01:03:02.070
OK, oh, yeah, so I wanted
to again to help you.

01:03:02.070 --> 01:03:04.290
I'm putting these down
as sort of templates

01:03:04.290 --> 01:03:07.290
for how do you use reducibility.

01:03:07.290 --> 01:03:11.460
I'm not saying you should
just apply things blindly.

01:03:11.460 --> 01:03:14.370
But I think it's sometimes
good just to see the pattern

01:03:14.370 --> 01:03:16.290
and then to understand
how the pattern works.

01:03:16.290 --> 01:03:19.560
So once you just start
to understand the pattern

01:03:19.560 --> 01:03:21.100
of how things are used.

01:03:21.100 --> 01:03:24.570
So to show a language
is undecidable,

01:03:24.570 --> 01:03:28.700
to prove a language
B is undecidable,

01:03:28.700 --> 01:03:32.590
show undecidable
languages reducible to B.

01:03:32.590 --> 01:03:36.850
Using just a general reduction
is going to be good enough.

01:03:36.850 --> 01:03:39.520
And the template
for that is, assume

01:03:39.520 --> 01:03:42.530
we have R deciding
B, which you then

01:03:42.530 --> 01:03:48.590
can use as a subroutine when
you make a Turing machine S

01:03:48.590 --> 01:03:51.560
deciding A. And that's going
to be your contradiction.

01:03:51.560 --> 01:03:55.894
If A was originally shown to
be known to be undecidable.

01:03:59.690 --> 01:04:03.260
But now to prove something
unrecognizable, this kind

01:04:03.260 --> 01:04:14.060
of reduction it's not
as restrictive enough

01:04:14.060 --> 01:04:18.330
because this kind of reduction
allows for complementation

01:04:18.330 --> 01:04:21.410
which is not going to be
satisfactory when you're trying

01:04:21.410 --> 01:04:23.960
to prove Turing unrecognizable.

01:04:23.960 --> 01:04:27.115
So you're going to have to
prohibit the complementation.

01:04:27.115 --> 01:04:29.360
And that's really one of
the effects of the mapping

01:04:29.360 --> 01:04:33.470
reducibility if that sort of is
getting at the essence of it.

01:04:33.470 --> 01:04:36.950
So you're going to show an
unTuring of a recognizable A

01:04:36.950 --> 01:04:39.920
is mapping reducible to
B. Often you start out

01:04:39.920 --> 01:04:42.170
with the complement of A
TM, which is a language

01:04:42.170 --> 01:04:50.400
we know is Turing unrecognizable
as we showed before,

01:04:50.400 --> 01:04:53.820
OK, here the template is you
give the reduction function f,

01:04:53.820 --> 01:04:57.930
that computable function, OK.

01:05:00.520 --> 01:05:02.590
So here are going
to be two examples,

01:05:02.590 --> 01:05:06.140
one showing that E TM is
Turing unrecognizable.

01:05:06.140 --> 01:05:08.470
We showed it was
undecidable before.

01:05:08.470 --> 01:05:12.580
Now we're going to show
it's even in a sense worse.

01:05:12.580 --> 01:05:16.220
It's not even recognizable.

01:05:16.220 --> 01:05:23.710
And the way we'll do that is to
reduce a known unrecognizable

01:05:23.710 --> 01:05:28.375
language to E TM in
the emptiness language.

01:05:31.070 --> 01:05:33.550
So here is the
picture that we have

01:05:33.550 --> 01:05:37.010
when we're doing
mapping reductions.

01:05:37.010 --> 01:05:43.680
We're going to map strings that
are in the complement of A TM,

01:05:43.680 --> 01:05:45.630
so strings that
are outside of A TM

01:05:45.630 --> 01:05:51.923
if you wish to strings where the
language is empty to machines

01:05:51.923 --> 01:05:53.090
where the language is empty.

01:05:53.090 --> 01:05:56.663
And here are strings
describing machines which are

01:05:56.663 --> 01:05:57.830
where the language is empty.

01:05:57.830 --> 01:06:04.770
And here we're going
to take A TM problems

01:06:04.770 --> 01:06:09.650
and map them to machines where
the language is not empty.

01:06:09.650 --> 01:06:11.400
And the thing that's
going to do the trick

01:06:11.400 --> 01:06:14.257
is going to be that
same reduction function

01:06:14.257 --> 01:06:15.090
that we saw earlier.

01:06:18.760 --> 01:06:22.600
We're going to take that
machine w from before,

01:06:22.600 --> 01:06:27.820
the machine that filters
out all the non-w's.

01:06:27.820 --> 01:06:36.860
And we're going to take Mw,
which is an A TM compliment

01:06:36.860 --> 01:06:37.360
problem.

01:06:40.090 --> 01:06:45.100
So if M rejects w that it's
in the complement of A TM,

01:06:45.100 --> 01:06:50.860
and that's supposed to map
to a string, a machine which

01:06:50.860 --> 01:07:00.530
is where the language
is empty, OK.

01:07:00.530 --> 01:07:04.400
So if Mw is in the complement
of A TM, so M rejects w,

01:07:04.400 --> 01:07:06.410
then Mw's language
is going to be empty,

01:07:06.410 --> 01:07:08.900
which is what you
want to have happen.

01:07:11.510 --> 01:07:12.900
Let me move on to my last.

01:07:12.900 --> 01:07:14.900
I mean, this example is
in a way kind of similar

01:07:14.900 --> 01:07:16.100
to the one we did before.

01:07:16.100 --> 01:07:20.540
And I really want to get
to the last example here.

01:07:20.540 --> 01:07:24.650
OK, so we'll have to
just talk through this

01:07:24.650 --> 01:07:26.690
rather than having it build.

01:07:29.480 --> 01:07:31.730
Let's take EQ TM.

01:07:31.730 --> 01:07:35.870
That's the equivalence
problem for Turing machines.

01:07:35.870 --> 01:07:39.485
Do they recognize
the same language?

01:07:43.520 --> 01:07:47.630
So this is a language
of a new kind for us.

01:07:47.630 --> 01:07:51.020
This is a language where
neither it nor its complement

01:07:51.020 --> 01:07:53.648
are going to be recognizable,
Turing recognizable.

01:07:58.330 --> 01:08:05.550
So the way we get that is, the
way we show problems are not

01:08:05.550 --> 01:08:11.830
recognizable is mapping reduce
a non-recognizable language

01:08:11.830 --> 01:08:14.020
to typically the
complement of A TM.

01:08:14.020 --> 01:08:17.020
So we're going to mapping
reduce the complement of A TM

01:08:17.020 --> 01:08:23.200
to both EQ TM and to
the complement of EQ TM

01:08:23.200 --> 01:08:26.930
to show that both of those
are not recognizable.

01:08:26.930 --> 01:08:30.140
And here we're going to
introduce a new machine

01:08:30.140 --> 01:08:35.410
that we're going to be building
inside the reduction function.

01:08:35.410 --> 01:08:39.960
And that's going to be a
machine I'm going to call Tw.

01:08:39.960 --> 01:08:44.880
And Tw is a machine that
always behaves the way

01:08:44.880 --> 01:08:48.800
M behaves on w for every input.

01:08:48.800 --> 01:08:53.600
So if M accepts w, T is
going to accept everything.

01:08:53.600 --> 01:08:57.850
If M rejects w, T is going
to reject everything.

01:08:57.850 --> 01:09:02.740
So it copies the behavior
of M on w onto all inputs.

01:09:02.740 --> 01:09:05.649
And the way I describe
that machine Tw is it

01:09:05.649 --> 01:09:06.520
ignores its input.

01:09:06.520 --> 01:09:11.979
Whatever the input is,
it just simulates M on w.

01:09:11.979 --> 01:09:14.830
You could easily
give an M and w,

01:09:14.830 --> 01:09:16.899
you can build the machine Tw.

01:09:16.899 --> 01:09:20.080
It just always runs M on w,
no matter what input it gets.

01:09:22.792 --> 01:09:24.750
And so now we're going
to give a function which

01:09:24.750 --> 01:09:27.779
maps A TM problems
which have the form Mw.

01:09:27.779 --> 01:09:30.040
So it's an A TM
compliment problem.

01:09:30.040 --> 01:09:33.790
So this want to test
if M accepts w or not.

01:09:33.790 --> 01:09:36.840
So that's an A TM
compliment-type problem.

01:09:36.840 --> 01:09:40.960
And I want to map that to an
EQ TM problem with the form--

01:09:40.960 --> 01:09:44.140
you know, EQ TM problems
repairs the machine

01:09:44.140 --> 01:09:46.191
now, and where going to
be testing equivalence.

01:09:46.191 --> 01:09:48.399
So I'm just trying to give
you the form of the output

01:09:48.399 --> 01:09:52.300
of the reduction function f.

01:09:52.300 --> 01:09:53.680
And specifically,
what it's going

01:09:53.680 --> 01:10:00.250
to look like is when we
have f is processing on Mw,

01:10:00.250 --> 01:10:01.720
it's going to
produce two machines.

01:10:01.720 --> 01:10:06.660
One of them is going to
be Tw which always behaves

01:10:06.660 --> 01:10:11.680
the way M behaves on w but
expanded to all inputs,

01:10:11.680 --> 01:10:17.230
and then a machine I'm going
to call T reject, which just is

01:10:17.230 --> 01:10:19.335
designed to reject everything.

01:10:22.070 --> 01:10:25.690
Now, just walk through
the logic with me.

01:10:25.690 --> 01:10:32.470
If M rejects w, Tw
rejects everything.

01:10:32.470 --> 01:10:37.330
And so we'll be equivalent
to the machine T reject.

01:10:37.330 --> 01:10:38.740
That's what we want.

01:10:38.740 --> 01:10:44.157
If M rejects w, so we're in
the language A TM compliment,

01:10:44.157 --> 01:10:46.240
then these two machines
that I produce for you are

01:10:46.240 --> 01:10:50.430
going to be in the EQ TM line.

01:10:50.430 --> 01:10:52.670
That's what I want
to have happen

01:10:52.670 --> 01:10:57.570
for a reduction from A
TM compliment to EQ TM.

01:10:57.570 --> 01:11:02.670
Similarly, to do
part 2, I'm going

01:11:02.670 --> 01:11:06.930
to make here a different f,
maybe I should call it f prime,

01:11:06.930 --> 01:11:09.910
all right, f1 and f2 for
the two different parts.

01:11:09.910 --> 01:11:12.240
So these are two different f's.

01:11:12.240 --> 01:11:13.380
I'm going to make f here.

01:11:16.500 --> 01:11:20.070
Instead of generating
Tw and T reject,

01:11:20.070 --> 01:11:21.970
I'm going to have
Tw and T accept

01:11:21.970 --> 01:11:26.020
which is a Turing machine
that always accepts its input.

01:11:26.020 --> 01:11:32.850
Now, if M rejects w,
it's in A TM compliment,

01:11:32.850 --> 01:11:35.790
then Tw is going to
reject everything.

01:11:35.790 --> 01:11:40.230
And it's going to be different
from its companion here,

01:11:40.230 --> 01:11:41.810
T accept.

01:11:41.810 --> 01:11:45.980
And so it won't be
in EQ TM compliment.

01:11:45.980 --> 01:11:50.360
But if M accepts w, then Tw
is going to accept everything.

01:11:50.360 --> 01:11:53.180
And it's going to be
equivalent to T accept.

01:11:53.180 --> 01:11:56.220
And you will be equivalent.

01:11:56.220 --> 01:11:59.750
So the here is where we're
taking A TM compliment

01:11:59.750 --> 01:12:02.282
and mapping it to the
compliment, the EQ TM.

01:12:05.730 --> 01:12:08.370
Too many compliments
here I realize.

01:12:08.370 --> 01:12:09.640
Compliments are confusing.

01:12:09.640 --> 01:12:13.140
But anyway, why don't
you mull this over.

01:12:13.140 --> 01:12:21.390
And just to summarize, OK,
we're out of time here.

01:12:21.390 --> 01:12:25.410
But why do we use reducing
when we talk about reductions?

01:12:25.410 --> 01:12:27.660
It's because when
we reduce A to B,

01:12:27.660 --> 01:12:30.990
we kind of bring A's difficulty
down to B's difficulty, that's

01:12:30.990 --> 01:12:34.510
where the reducing comes from.

01:12:34.510 --> 01:12:38.210
Or we bring B's difficulty
up to A's difficulty,

01:12:38.210 --> 01:12:41.290
because it's really A's
difficulty relative to B

01:12:41.290 --> 01:12:43.750
that we're talking about
when we're reducing A to B.

01:12:43.750 --> 01:12:48.400
So that's why the term reducing
seems a little out of place

01:12:48.400 --> 01:12:51.430
when we're proving things
undecidable, or unrecognizable.

01:12:51.430 --> 01:12:52.930
But that's where
it's coming from.

01:12:52.930 --> 01:12:56.510
Anyway, quick
review, we introduced

01:12:56.510 --> 01:12:58.480
the reducibility method.

01:12:58.480 --> 01:13:01.630
We defined mapping
reducibility as a special kind

01:13:01.630 --> 01:13:02.920
of reducibility.

01:13:02.920 --> 01:13:06.310
We showed E TM as undecidable
and unrecognizable.

01:13:06.310 --> 01:13:09.340
And that EQ TM is
both, it and it's

01:13:09.340 --> 01:13:11.290
complement are unrecognizable.

01:13:11.290 --> 01:13:13.480
So we're out of time.

01:13:13.480 --> 01:13:16.220
I will shut this down.

01:13:16.220 --> 01:13:18.197
But I'll take a few
questions here actually.

01:13:18.197 --> 01:13:19.780
I'll stick around
for a few questions.

01:13:19.780 --> 01:13:24.580
And then I'll move to the other
chat room for office hours, OK?

01:13:27.280 --> 01:13:34.950
So question, go over the case
for the complement of EQ TM.

01:13:34.950 --> 01:13:35.790
So I will do that.

01:13:38.810 --> 01:13:43.000
So that's in this slide here.

01:13:43.000 --> 01:13:51.790
OK, so this is proof
part 2 for the person

01:13:51.790 --> 01:13:53.080
who asked me to go over it.

01:13:53.080 --> 01:13:56.920
But I think it's helpful
for those of you who might

01:13:56.920 --> 01:13:58.690
be a little bit shaky on this.

01:14:01.270 --> 01:14:04.020
I want to mapping reduce
the complement of A TM

01:14:04.020 --> 01:14:05.325
to the complement of EQ TM.

01:14:09.617 --> 01:14:11.950
By the way, I don't know if
this is going to be helpful.

01:14:11.950 --> 01:14:14.970
But as we pointed out in
the check in a while back,

01:14:14.970 --> 01:14:18.390
that's completely equivalent
to having a mapping

01:14:18.390 --> 01:14:21.270
reduction from A TM to EQ TM.

01:14:21.270 --> 01:14:25.620
You can complement
both sides, and you

01:14:25.620 --> 01:14:28.530
get an equivalent statement.

01:14:28.530 --> 01:14:32.430
Maybe let's stick with the
compliments here though.

01:14:32.430 --> 01:14:36.740
I hope that doesn't make
it too confusing, OK.

01:14:36.740 --> 01:14:39.200
We're trying to show
the complement of A TM

01:14:39.200 --> 01:14:42.170
is mapping reducible to
the complement of EQ TM.

01:14:42.170 --> 01:14:43.740
What does that mean?

01:14:43.740 --> 01:14:49.490
So that means when M rejects
w, so you're in the compliment,

01:14:49.490 --> 01:14:55.130
we want the two Turing
machines to be inequivalent.

01:14:55.130 --> 01:14:58.235
No, yeah, so we're in
the compliment of EQ TM.

01:15:00.920 --> 01:15:04.010
So in other words, when we're
in the complement of A TM,

01:15:04.010 --> 01:15:12.090
we want the result of the f to
be in the complement of EQ TM.

01:15:12.090 --> 01:15:14.220
So in other words,
when M rejects w,

01:15:14.220 --> 01:15:16.020
the two machines
should be inequivalent.

01:15:19.690 --> 01:15:20.230
Right?

01:15:20.230 --> 01:15:24.830
When M accepts w, the two
machines should be equivalent.

01:15:24.830 --> 01:15:29.090
Because when we're not in this
language, so we're in A TM,

01:15:29.090 --> 01:15:30.800
we want to be not
in that language.

01:15:30.800 --> 01:15:32.810
So we should be in EQ TM.

01:15:32.810 --> 01:15:36.980
So when M accepts w, we
should be equivalent.

01:15:36.980 --> 01:15:39.710
When M rejects w, we
should be inequivalent.

01:15:39.710 --> 01:15:41.640
That's what we want.

01:15:41.640 --> 01:15:44.220
Let's go down here.

01:15:44.220 --> 01:15:51.720
So if M accepts w, we want
them to-- so when M accepts w,

01:15:51.720 --> 01:15:52.970
we want them to be equivalent.

01:15:52.970 --> 01:15:57.260
So if M accepts w, Tw
accepts everything.

01:15:57.260 --> 01:15:59.270
And it's equivalent to T accept.

01:15:59.270 --> 01:16:06.280
When M rejects w, Tw
rejects everything.

01:16:06.280 --> 01:16:08.170
And so it's not
equivalent to the machine

01:16:08.170 --> 01:16:09.960
that accepts everything.

01:16:09.960 --> 01:16:15.493
So just go through
the logic yourself.

01:16:15.493 --> 01:16:16.660
You'll see why it's working.

01:16:21.210 --> 01:16:24.200
All right, so,
bye, bye, everyone.