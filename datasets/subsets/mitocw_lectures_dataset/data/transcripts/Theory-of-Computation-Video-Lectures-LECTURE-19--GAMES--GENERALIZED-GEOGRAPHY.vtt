WEBVTT

00:00:00.000 --> 00:00:01.980
[SQUEAKING]

00:00:01.980 --> 00:00:03.960
[RUSTLING]

00:00:03.960 --> 00:00:06.930
[CLICKING]

00:00:24.760 --> 00:00:30.560
MICHAEL SIPSER: Let's get
back to space complexity.

00:00:30.560 --> 00:00:34.630
So just to review
what we've been doing

00:00:34.630 --> 00:00:37.840
from last lecture, which
feels like a long time ago

00:00:37.840 --> 00:00:43.030
but it was only two
days ago, we were

00:00:43.030 --> 00:00:48.730
looking at those three
theorems, which all

00:00:48.730 --> 00:00:51.760
had basically the same proof.

00:00:51.760 --> 00:00:55.210
One was about the
ladder problem,

00:00:55.210 --> 00:00:58.990
where you're trying to see if
you can get from one string

00:00:58.990 --> 00:01:03.010
to another string changing
one symbol at a time.

00:01:03.010 --> 00:01:06.070
And all of the strings
were in the language

00:01:06.070 --> 00:01:09.010
of some finite automaton, or
you had some reasonable rule

00:01:09.010 --> 00:01:13.090
for saying which are the
valid strings, which are not.

00:01:13.090 --> 00:01:16.660
And then we built on that idea.

00:01:16.660 --> 00:01:18.430
We showed Savitch's
theorem, that

00:01:18.430 --> 00:01:21.040
going from any
nondeterministic machine

00:01:21.040 --> 00:01:24.160
to a deterministic machine only
squares the amount of space.

00:01:24.160 --> 00:01:31.210
And then we finally
proved that TQBF,

00:01:31.210 --> 00:01:34.390
this problem about
quantified Boolean formulas,

00:01:34.390 --> 00:01:37.390
testing whether they are
true, that that problem is

00:01:37.390 --> 00:01:40.370
complete for PSPACE.

00:01:40.370 --> 00:01:43.090
So we're going to build
off of that last theorem

00:01:43.090 --> 00:01:50.110
today, and talk about one
other complete problem,

00:01:50.110 --> 00:01:54.730
and also show a
connection between PSPACE

00:01:54.730 --> 00:02:00.475
and testing which side can
win in certain kinds of games.

00:02:04.300 --> 00:02:07.000
And then at the end of the
lecture, the second half

00:02:07.000 --> 00:02:10.419
of the lecture, we'll
talk about diving deeper

00:02:10.419 --> 00:02:11.650
into space complexity.

00:02:11.650 --> 00:02:15.130
We're going to talk about a
different part of the parameter

00:02:15.130 --> 00:02:17.757
space where instead of
looking at polynomial space,

00:02:17.757 --> 00:02:19.840
we're going to talk about
what happens if you have

00:02:19.840 --> 00:02:23.800
logarithmic space, which is
another natural point to look

00:02:23.800 --> 00:02:26.560
at for space complexity.

00:02:26.560 --> 00:02:29.290
But we'll get to
that after the break.

00:02:33.070 --> 00:02:36.910
Talk about game
complexity and games--

00:02:36.910 --> 00:02:42.100
so when I was little, we used
to play, me and my sisters,

00:02:42.100 --> 00:02:44.020
would play a game
called Geography.

00:02:44.020 --> 00:02:46.000
I don't know how many
of you have heard it

00:02:46.000 --> 00:02:49.330
or maybe it goes under
a different name.

00:02:49.330 --> 00:02:54.250
But it was a game basically
about words and places.

00:02:54.250 --> 00:02:58.150
And it has a very
simple set of rules.

00:02:58.150 --> 00:02:59.560
Let's say there were two people.

00:02:59.560 --> 00:03:02.860
You take turns picking
names of places.

00:03:05.910 --> 00:03:10.440
And then each person has
to pick a place which

00:03:10.440 --> 00:03:15.450
starts with the letter that the
previous person's place ended

00:03:15.450 --> 00:03:17.980
with.

00:03:17.980 --> 00:03:22.390
So for example, you
have two people playing.

00:03:22.390 --> 00:03:25.450
Perhaps you agree on
some starting place

00:03:25.450 --> 00:03:28.900
like a major city
nearby, like Boston.

00:03:28.900 --> 00:03:32.380
So one player, the first
player, picks Boston.

00:03:32.380 --> 00:03:34.090
And then after that,
the next player

00:03:34.090 --> 00:03:38.830
has to pick a place that starts
with N, because Boston ends

00:03:38.830 --> 00:03:43.800
with N. And so maybe
Nebraska would be

00:03:43.800 --> 00:03:46.270
a possible response to Boston.

00:03:46.270 --> 00:03:47.820
And then the first
player would have

00:03:47.820 --> 00:03:50.340
to respond to that with a
place that starts with an A,

00:03:50.340 --> 00:03:52.560
because Nebraska
ends with an A, maybe

00:03:52.560 --> 00:03:57.340
Alaska, which also starts
with A, ends with A.

00:03:57.340 --> 00:04:00.480
So then Arkansas,
maybe, would be

00:04:00.480 --> 00:04:02.470
a reasonable response to that.

00:04:02.470 --> 00:04:06.990
And then that ends with
S, so San Francisco,

00:04:06.990 --> 00:04:09.210
and then so on, and so on.

00:04:09.210 --> 00:04:14.280
And of course, you
want to forbid people

00:04:14.280 --> 00:04:19.019
from reusing names because then
you'll just get into a loop.

00:04:19.019 --> 00:04:21.269
Saying, "Alaska,"
"Alaska," "Alaska,"

00:04:21.269 --> 00:04:23.070
won't make the game
very interesting,

00:04:23.070 --> 00:04:26.730
so you have to forbid
that possibility.

00:04:26.730 --> 00:04:28.240
Names cannot be reused.

00:04:28.240 --> 00:04:30.120
They can be used at most once.

00:04:30.120 --> 00:04:34.230
And then, eventually,
one side or the other

00:04:34.230 --> 00:04:37.380
is going to run out of
names and not have--

00:04:37.380 --> 00:04:40.800
either because of the lack of
their geographical knowledge

00:04:40.800 --> 00:04:43.320
or maybe you've just exhausted
all the possibilities--

00:04:43.320 --> 00:04:45.930
and will not have
a good response.

00:04:45.930 --> 00:04:47.400
And that person will be stuck.

00:04:47.400 --> 00:04:49.320
And that person is the loser.

00:04:49.320 --> 00:04:51.190
The other person
has won the game.

00:04:51.190 --> 00:04:54.220
So the objective is to try
to avoid getting stuck.

00:04:54.220 --> 00:04:56.190
So let's just take a look.

00:04:56.190 --> 00:05:00.330
I'm going to think about
that game in a slightly more

00:05:00.330 --> 00:05:02.790
abstracted, formalized way.

00:05:02.790 --> 00:05:05.700
So you write down all of
the legitimate places.

00:05:05.700 --> 00:05:09.150
They become nodes of a graph
such as I've shown here.

00:05:09.150 --> 00:05:13.860
And then you draw an edge
from one node to another

00:05:13.860 --> 00:05:20.950
if that corresponds to a legal
move in the game, a legal step

00:05:20.950 --> 00:05:21.530
of the game.

00:05:21.530 --> 00:05:25.030
So Boston connects to
places that start with N,

00:05:25.030 --> 00:05:27.460
like New York and Nebraska.

00:05:27.460 --> 00:05:29.230
So the first person
might pick Boston.

00:05:29.230 --> 00:05:31.803
The second person might
pick either of these two,

00:05:31.803 --> 00:05:33.220
and then back to
the first person.

00:05:33.220 --> 00:05:35.303
If they picked Nebraska,
they could pick Arkansas.

00:05:35.303 --> 00:05:39.630
They can pick Alaska, and
so on, just as I described.

00:05:39.630 --> 00:05:42.600
Believe it or not, we
actually played this game.

00:05:42.600 --> 00:05:44.760
I can remember playing
this game when I was a kid.

00:05:44.760 --> 00:05:50.340
That was, of course, before
we had "League of Legends"

00:05:50.340 --> 00:05:54.360
and other fun stuff, but
this is what kids used to do.

00:05:54.360 --> 00:06:04.210
So anyway, just to get it down
on the slide, the rules are--

00:06:04.210 --> 00:06:06.940
assuming we have
two players, we'll

00:06:06.940 --> 00:06:08.920
call them Player
I and Player II.

00:06:08.920 --> 00:06:11.260
Player I goes first.

00:06:11.260 --> 00:06:12.970
And they take turns
picking places

00:06:12.970 --> 00:06:16.330
that start with the letter
which ended the previous place,

00:06:16.330 --> 00:06:17.650
no repeats allowed.

00:06:17.650 --> 00:06:23.320
And the first player stuck
loses, the person who

00:06:23.320 --> 00:06:26.930
doesn't have a move to make.

00:06:26.930 --> 00:06:29.500
So what we're going
to look at today

00:06:29.500 --> 00:06:33.490
is a generalized version
of that, where we're just

00:06:33.490 --> 00:06:35.740
going to take away
the names, but just

00:06:35.740 --> 00:06:38.360
leave the underlying graph.

00:06:38.360 --> 00:06:42.050
And we call it going to call
that "generalized geography."

00:06:42.050 --> 00:06:45.560
So here, that can be played
on any directed graph.

00:06:45.560 --> 00:06:49.160
You take away the
names of the nodes.

00:06:49.160 --> 00:06:53.150
Now you just have
some arbitrary graph.

00:06:53.150 --> 00:06:55.010
You're going to designate
a particular node

00:06:55.010 --> 00:06:56.240
as the starting node.

00:06:56.240 --> 00:06:59.675
And then the players take
turns following those edges.

00:07:02.180 --> 00:07:09.800
And because you're going to
forbid having any loops reusing

00:07:09.800 --> 00:07:15.510
any nodes, what you end up
doing is, working together,

00:07:15.510 --> 00:07:20.120
you're going to be constructing
a simple path in that graph.

00:07:20.120 --> 00:07:22.790
Simple path just
follows those edges

00:07:22.790 --> 00:07:26.780
and never intersects itself.

00:07:26.780 --> 00:07:29.870
And the first player to
be stuck is the loser.

00:07:29.870 --> 00:07:31.730
So the other one is the winner.

00:07:31.730 --> 00:07:35.630
So we're going to call that
"generalized geography."

00:07:35.630 --> 00:07:38.300
And we're going to look at
the computational complexity

00:07:38.300 --> 00:07:41.000
of deciding, for a
given graph and starting

00:07:41.000 --> 00:07:49.730
point, which side would win if
both players played optimally,

00:07:49.730 --> 00:07:51.690
the best possible.

00:07:51.690 --> 00:07:55.160
And we'll name that
problem GG, or look

00:07:55.160 --> 00:07:56.760
at its associated language.

00:07:56.760 --> 00:08:00.170
So here is a graph
and the starting node.

00:08:00.170 --> 00:08:06.830
And you want to say that
pair is in the language GG

00:08:06.830 --> 00:08:13.220
if the first player, Player I,
who must play at that node A

00:08:13.220 --> 00:08:19.260
to start off with
has a forced win

00:08:19.260 --> 00:08:22.920
in that generalized geography
game on that graph starting

00:08:22.920 --> 00:08:26.107
at A. Again, what I
mean by a forced win--

00:08:26.107 --> 00:08:27.690
I'm not going to
define this formally,

00:08:27.690 --> 00:08:28.740
though we could do that--

00:08:28.740 --> 00:08:29.820
it's not hard to do.

00:08:29.820 --> 00:08:33.870
But a forced win is also
called a "winning strategy."

00:08:33.870 --> 00:08:37.289
That just means that if
both sides play optimally,

00:08:37.289 --> 00:08:39.720
they play the best possible--

00:08:39.720 --> 00:08:42.150
not of their capability,
I mean absolutely

00:08:42.150 --> 00:08:44.400
the best possible play--

00:08:44.400 --> 00:08:49.890
then that Player
I would still win.

00:08:49.890 --> 00:08:51.630
There's nothing
that Player II can

00:08:51.630 --> 00:08:55.380
do to prevent Player
I from winning

00:08:55.380 --> 00:08:59.130
if Player I has a winning
strategy or a forced win.

00:08:59.130 --> 00:09:02.160
You may have seen, for example--

00:09:02.160 --> 00:09:03.783
there are examples
of this that--

00:09:03.783 --> 00:09:05.700
I mean, I don't even
know if they still exist,

00:09:05.700 --> 00:09:07.530
but it used to be
in the newspaper.

00:09:07.530 --> 00:09:09.900
There used to be
examples of chess boards

00:09:09.900 --> 00:09:13.050
and they would start
from a certain position.

00:09:13.050 --> 00:09:15.900
And they would say,
"White to win in three."

00:09:15.900 --> 00:09:18.180
And so that means
white has a forced win.

00:09:18.180 --> 00:09:20.860
No matter what black does, white
is going to end up winning.

00:09:20.860 --> 00:09:22.777
But you have to think
of what the strategy is.

00:09:22.777 --> 00:09:24.240
It may not be so
obvious to think

00:09:24.240 --> 00:09:27.090
through what are the right
moves that white makes.

00:09:27.090 --> 00:09:30.150
But the point is that no
matter what black would do,

00:09:30.150 --> 00:09:32.670
white would end up winning.

00:09:32.670 --> 00:09:33.930
And what you can show--

00:09:33.930 --> 00:09:37.770
we're not going to do that--
but for a class of games that

00:09:37.770 --> 00:09:40.890
includes this
generalized geography,

00:09:40.890 --> 00:09:43.380
either one side or
the other is going

00:09:43.380 --> 00:09:46.050
to be guaranteed to
have a forced win.

00:09:46.050 --> 00:09:49.560
That's not necessarily true for
all possible games, obviously,

00:09:49.560 --> 00:09:53.760
but for a large class of
games, one side or the other

00:09:53.760 --> 00:09:59.490
is guaranteed to have a winning
strategy or a forced win.

00:09:59.490 --> 00:10:01.170
So let's just review
that, because this

00:10:01.170 --> 00:10:05.370
is going to be essential for
the first half of the lecture--

00:10:05.370 --> 00:10:07.720
to understand what
we mean by a game

00:10:07.720 --> 00:10:11.640
and what we mean by one side or
the other to have a forced win.

00:10:14.370 --> 00:10:17.720
And what we're going to show
is that GG is PSPACE complete,

00:10:17.720 --> 00:10:19.880
that the problem of
given one of these graphs

00:10:19.880 --> 00:10:22.130
and a starting
point, figuring out

00:10:22.130 --> 00:10:24.470
does Player I have a forced
win or is it Player II that

00:10:24.470 --> 00:10:27.410
has a forced win?

00:10:27.410 --> 00:10:30.500
Which side is guaranteed
to win under optimal play?

00:10:30.500 --> 00:10:33.690
That's a PSPACE
complete problem.

00:10:33.690 --> 00:10:36.540
And so let's do a
little checking on that.

00:10:36.540 --> 00:10:39.500
And so I'm going to give
you a very small example

00:10:39.500 --> 00:10:41.270
of a generalized geography game.

00:10:44.130 --> 00:10:48.060
You have to figure out whether
it's Player I or Player II that

00:10:48.060 --> 00:10:51.450
has the forced win, the
winning strategy, or maybe

00:10:51.450 --> 00:10:52.800
neither, or both.

00:10:52.800 --> 00:10:54.450
Those are the four options.

00:10:54.450 --> 00:10:57.030
And you understand Player
I has to play here,

00:10:57.030 --> 00:10:58.572
because that's
the starting place

00:10:58.572 --> 00:11:00.030
of this generalized
geography game.

00:11:00.030 --> 00:11:03.160
So then it's up to
Player II to continue on.

00:11:03.160 --> 00:11:07.230
All right, so let's
launch that poll.

00:11:07.230 --> 00:11:10.780
You'll have to think
about it a little bit,

00:11:10.780 --> 00:11:15.400
and let me know what you think.

00:11:15.400 --> 00:11:19.320
Which side has a forced win?

00:11:19.320 --> 00:11:20.850
Which player makes
the first move?

00:11:20.850 --> 00:11:24.060
It's Player I makes the first
move, and Player I plays,

00:11:24.060 --> 00:11:28.020
as I showed you here, this
is Player I playing at A.

00:11:28.020 --> 00:11:30.832
So Player I picks A,
and then Player II

00:11:30.832 --> 00:11:32.040
has to pick one of these two.

00:11:36.430 --> 00:11:38.600
All right, I think we're
the end of the poll.

00:11:38.600 --> 00:11:40.270
Everybody's in?

00:11:40.270 --> 00:11:41.110
Pick something.

00:11:50.090 --> 00:11:54.890
You guys did not do
well on this poll.

00:11:54.890 --> 00:11:56.900
At least not too
many of you picked

00:11:56.900 --> 00:12:01.100
D. That's a little
reassuring because you

00:12:01.100 --> 00:12:03.410
can't have both players
having a forced win.

00:12:03.410 --> 00:12:06.620
I did say that in games of this
kind, one side or the other

00:12:06.620 --> 00:12:08.660
is going to have a
forced win, so C is not

00:12:08.660 --> 00:12:11.000
a very good choice, either.

00:12:11.000 --> 00:12:14.745
So maybe you should spend
less time reading your email

00:12:14.745 --> 00:12:16.370
and more time listening
to the lecture.

00:12:20.730 --> 00:12:23.190
The actual correct answer is B.

00:12:23.190 --> 00:12:28.080
Player II, which obviously
is a minority position here--

00:12:28.080 --> 00:12:29.640
Player II has the forced win.

00:12:29.640 --> 00:12:31.890
Let's understand why.

00:12:31.890 --> 00:12:35.520
So Player I plays here.

00:12:35.520 --> 00:12:37.740
As I said, that's
the first move.

00:12:37.740 --> 00:12:41.340
Player II can either take the
upper node or the lower node.

00:12:44.050 --> 00:12:46.600
Player II takes the
upper node, then

00:12:46.600 --> 00:12:50.860
Player I has no choice but
to take the right-most node,

00:12:50.860 --> 00:12:55.380
and now there's no more
move for Player II.

00:12:55.380 --> 00:13:00.600
So Player II will lose if
Player II takes the upper node,

00:13:00.600 --> 00:13:02.340
the upper choice there.

00:13:02.340 --> 00:13:06.180
Because Player II will go
here, Player I will go there,

00:13:06.180 --> 00:13:08.220
and it'll be game over.

00:13:08.220 --> 00:13:11.670
And Player I will have won
because Player II was stuck.

00:13:11.670 --> 00:13:14.310
However, Player II
had another choice.

00:13:21.800 --> 00:13:25.710
Player II could have
also gone down here.

00:13:25.710 --> 00:13:30.213
So Player II, if it
played down here,

00:13:30.213 --> 00:13:32.130
things are looking a lot
better for Player II.

00:13:32.130 --> 00:13:35.790
If Player II goes here, Player
I's move is forced, goes here.

00:13:35.790 --> 00:13:39.330
But now, there's another move
left that Player II could make.

00:13:39.330 --> 00:13:45.380
So Player II goes here, I goes
there, Player II goes up there.

00:13:45.380 --> 00:13:47.060
And now Player I is stuck.

00:13:47.060 --> 00:13:51.480
So it's Player II's
choice, Player II

00:13:51.480 --> 00:13:54.390
can make a move
which will end up

00:13:54.390 --> 00:13:59.220
causing Player I to get
stuck, because that's

00:13:59.220 --> 00:14:01.950
the nature of what we mean
by having a winning strategy.

00:14:01.950 --> 00:14:05.125
There is some way to guarantee
if you're playing optimally,

00:14:05.125 --> 00:14:06.750
and you're certainly
playing optimally,

00:14:06.750 --> 00:14:10.200
means you'll take
that lower move.

00:14:10.200 --> 00:14:13.300
Then you will take that.

00:14:13.300 --> 00:14:19.990
So under optimal play,
Player II will win this game,

00:14:19.990 --> 00:14:22.090
and so Player II has
a winning strategy.

00:14:22.090 --> 00:14:25.030
It has a forced win.

00:14:25.030 --> 00:14:26.050
So I see.

00:14:26.050 --> 00:14:30.540
So I'm not going to define
"playing optimally."

00:14:30.540 --> 00:14:34.200
There's some questions
here about that.

00:14:39.180 --> 00:14:46.530
I'm going to-- I'm going to
leave it somewhat informal,

00:14:46.530 --> 00:14:48.840
but we could make
that all precise.

00:14:48.840 --> 00:14:50.970
I don't think it
would be clarifying

00:14:50.970 --> 00:14:53.670
to go through a precise
definition of that.

00:14:58.920 --> 00:15:00.480
We don't even have
to think about it

00:15:00.480 --> 00:15:01.860
in terms of optimal play.

00:15:01.860 --> 00:15:14.900
You can say that a
player has a forced

00:15:14.900 --> 00:15:19.970
win if they have moves
that they could make

00:15:19.970 --> 00:15:24.370
in response to every possible
move the opponent could make

00:15:24.370 --> 00:15:27.570
that will guarantee that
they will end up winning.

00:15:27.570 --> 00:15:30.330
So you don't even have to
talk about optimality here.

00:15:30.330 --> 00:15:33.510
Just talk about every
possible opponent.

00:15:33.510 --> 00:15:35.910
Every possible opponent
is going to lose

00:15:35.910 --> 00:15:43.870
to somebody who has
a winning strategy

00:15:43.870 --> 00:15:45.340
and follows that strategy.

00:15:49.370 --> 00:15:51.500
I can see there was
some confusion about who

00:15:51.500 --> 00:15:52.640
was going first and so on.

00:15:52.640 --> 00:15:53.150
I'm glad.

00:15:53.150 --> 00:15:55.275
That was part of the reason
I gave this check, just

00:15:55.275 --> 00:15:58.080
to hopefully to clear
up some of those points.

00:15:58.080 --> 00:16:01.910
So Player I plays here
then Player II goes.

00:16:01.910 --> 00:16:03.920
And I got some comments
that some people

00:16:03.920 --> 00:16:09.140
were confused about
what does it mean where

00:16:09.140 --> 00:16:11.090
does the first person move.

00:16:11.090 --> 00:16:14.930
Hopefully, that's clearer.

00:16:14.930 --> 00:16:17.600
All right, so let's
move on because we're

00:16:17.600 --> 00:16:22.370
going to be spending a
while proving something

00:16:22.370 --> 00:16:25.010
about generalized
geography in these graphs.

00:16:28.420 --> 00:16:31.180
So let's continue.

00:16:31.180 --> 00:16:37.400
So in order to make the
connection between games

00:16:37.400 --> 00:16:40.220
and complexity,
we're going to need

00:16:40.220 --> 00:16:45.950
to talk about a problem,
one related to one

00:16:45.950 --> 00:16:48.530
that we've already seen,
where we can reformulate

00:16:48.530 --> 00:16:50.400
that problem as a game.

00:16:50.400 --> 00:16:53.910
And that's going to be a problem
on quantified Boolean formulas

00:16:53.910 --> 00:16:56.850
called the "Formula Game."

00:16:56.850 --> 00:17:01.850
So this is a different game
now, not one that you're

00:17:01.850 --> 00:17:03.140
likely to end up playing.

00:17:03.140 --> 00:17:06.319
But in a sense in
which you'll see,

00:17:06.319 --> 00:17:09.200
this is still a reasonable
game where two players

00:17:09.200 --> 00:17:10.619
can play against one another.

00:17:10.619 --> 00:17:13.069
And one of them is going to
end up winning and one of them

00:17:13.069 --> 00:17:15.530
is going to end up having--

00:17:15.530 --> 00:17:18.450
one or the other will
have a winning strategy.

00:17:18.450 --> 00:17:21.480
So let's understand
what the game is.

00:17:21.480 --> 00:17:29.310
The game is played on a formula.

00:17:29.310 --> 00:17:32.120
So you write down a
quantified Boolean formula.

00:17:32.120 --> 00:17:36.530
Remember, we talked about
that for several lectures now.

00:17:36.530 --> 00:17:40.490
It's a bunch of quanti--
variables with quantifiers.

00:17:40.490 --> 00:17:46.850
And then there's a part that
has no quantifiers, which

00:17:46.850 --> 00:17:50.210
you can always put into
conjunctive normal form

00:17:50.210 --> 00:17:50.760
if you want.

00:17:50.760 --> 00:17:53.690
But for the purposes of
this discussion so far,

00:17:53.690 --> 00:17:54.440
it doesn't matter.

00:17:54.440 --> 00:17:59.000
Later on, we'll actually
want it to be in CNF.

00:17:59.000 --> 00:18:03.850
But for now, we just
have some formula.

00:18:03.850 --> 00:18:07.120
And associated to
that formula there

00:18:07.120 --> 00:18:09.200
is a game, in a
very natural sense.

00:18:09.200 --> 00:18:12.530
So first of all, there are
going to be two players.

00:18:12.530 --> 00:18:14.050
But now the names
of those players

00:18:14.050 --> 00:18:16.360
are going to be Player
Exist and Player For All.

00:18:20.800 --> 00:18:22.870
And this is how the game goes--

00:18:28.630 --> 00:18:32.350
both players are going to be
picking values for variables.

00:18:32.350 --> 00:18:37.840
They're going to say variable x1
is true, variable x2 is false,

00:18:37.840 --> 00:18:41.290
variable x3 is false,
variable x4 is true.

00:18:41.290 --> 00:18:45.880
And that's how the
moves of the game go.

00:18:45.880 --> 00:18:49.750
They're just assigning values
to variables so that in the end,

00:18:49.750 --> 00:18:53.170
all of the variables have
been assigned a Boolean value.

00:18:53.170 --> 00:18:55.120
And so we end up
with an assignment.

00:18:55.120 --> 00:19:00.530
But before we get to
that stage, which players

00:19:00.530 --> 00:19:03.110
get to pick which variables?

00:19:03.110 --> 00:19:05.330
And the way it works
is the Exist player

00:19:05.330 --> 00:19:08.850
is going to assign values
to the Exist variables.

00:19:08.850 --> 00:19:14.420
So Exist will pick x1 and
x3 and assign them values.

00:19:14.420 --> 00:19:18.380
The For All player is
going to assign values

00:19:18.380 --> 00:19:21.420
to the variables that have a
For All quantifier attached.

00:19:21.420 --> 00:19:27.980
So in this case,
the For All player

00:19:27.980 --> 00:19:32.480
will pick the value
for the x2 variable.

00:19:32.480 --> 00:19:33.320
Fading out here.

00:19:39.360 --> 00:19:41.940
And the order of
play is according

00:19:41.940 --> 00:19:45.570
to the order of the
appearance of the qualifiers

00:19:45.570 --> 00:19:47.610
in the formula.

00:19:47.610 --> 00:19:50.570
So the way I have it written
out in this particular formula,

00:19:50.570 --> 00:19:51.830
it's Exist x1--

00:19:51.830 --> 00:19:54.620
so Exist will pick
the value for x1.

00:19:54.620 --> 00:19:56.120
Then For All's turn.

00:19:56.120 --> 00:19:58.250
For All will pick
the value of x2.

00:19:58.250 --> 00:20:03.810
Then it's going to be Exist
picking the value for x3,

00:20:03.810 --> 00:20:07.860
and so on, until they get to the
end, and all of the variables

00:20:07.860 --> 00:20:11.670
have been assigned to value
by one side or the other.

00:20:11.670 --> 00:20:15.410
And now the game is over.

00:20:15.410 --> 00:20:23.915
So what's left is to understand
who has won at that point.

00:20:26.980 --> 00:20:37.230
And the way we say who has won
is Exist wins if in the end,

00:20:37.230 --> 00:20:41.460
this part psi, which is the
part without quantifiers,

00:20:41.460 --> 00:20:46.770
ended up being satisfied
by that assignment

00:20:46.770 --> 00:20:50.160
that the two players
together ended up picking.

00:20:50.160 --> 00:20:56.970
And then For All will win
if that part of the formula

00:20:56.970 --> 00:20:58.770
is not satisfied.

00:20:58.770 --> 00:21:00.270
So let me just write
that down here.

00:21:00.270 --> 00:21:02.460
After the variables have
been assigned values,

00:21:02.460 --> 00:21:03.900
we determine the winner.

00:21:03.900 --> 00:21:08.970
Exist wins if the assignment
that built cooperatively

00:21:08.970 --> 00:21:13.740
together satisfied psi,
and otherwise For All,

00:21:13.740 --> 00:21:16.610
if it doesn't satisfy psi.

00:21:16.610 --> 00:21:19.790
So think about it this way--

00:21:19.790 --> 00:21:22.370
Exist is picking the
values of those variables.

00:21:22.370 --> 00:21:28.280
He's trying to make this part
of the formula satisfied,

00:21:28.280 --> 00:21:30.170
trying to satisfy this
part of the formula.

00:21:30.170 --> 00:21:33.680
For All is picking
values, but she's

00:21:33.680 --> 00:21:36.890
trying to make this part
of the formula unsatisfied.

00:21:36.890 --> 00:21:42.090
So they're in opposition
to one another.

00:21:42.090 --> 00:21:46.730
And in the end, one of them
is going to have succeeded

00:21:46.730 --> 00:21:49.430
and the other one
will have failed.

00:21:49.430 --> 00:21:52.430
And now, thinking
about it as a game,

00:21:52.430 --> 00:21:55.430
depending upon the formula,
one side or the other

00:21:55.430 --> 00:21:58.190
is going to have the ability
to dominate the other one

00:21:58.190 --> 00:21:59.090
and always win.

00:22:01.930 --> 00:22:06.360
And so the question
is, which side

00:22:06.360 --> 00:22:09.450
has that ability to always win?

00:22:09.450 --> 00:22:11.972
Which side has the
winning strategy?

00:22:11.972 --> 00:22:13.680
Of course, it'll depend
upon the formula.

00:22:13.680 --> 00:22:15.442
Some formulas, it'll
be the Exist player

00:22:15.442 --> 00:22:16.650
who has the winning strategy.

00:22:16.650 --> 00:22:18.692
And other formulas, it
will be the For All player

00:22:18.692 --> 00:22:20.010
who has the winning strategy.

00:22:20.010 --> 00:22:23.260
And computationally, we'd like
to make that determination.

00:22:23.260 --> 00:22:29.190
Which side is going to
win for a given formula?

00:22:29.190 --> 00:22:34.380
And there's a very, very
nice, and actually very easy

00:22:34.380 --> 00:22:37.960
and simple way to understand
that because we've already

00:22:37.960 --> 00:22:40.660
run into that problem before.

00:22:40.660 --> 00:22:44.680
The problem of determining
which side has a forced win

00:22:44.680 --> 00:22:46.660
is exactly the same
thing as determining

00:22:46.660 --> 00:22:50.760
whether this quantified
Boolean formula is true

00:22:50.760 --> 00:22:55.860
because the Exist player has a
forced win when that formula--

00:23:01.460 --> 00:23:02.390
let me say it again--

00:23:02.390 --> 00:23:05.330
the Exist player has a forced
win when that formula is true.

00:23:08.570 --> 00:23:12.730
So if this quantified Boolean
formula were a true quantified

00:23:12.730 --> 00:23:15.490
Boolean formula, then
Exist is guaranteed

00:23:15.490 --> 00:23:21.540
to be able to win that game
if it plays its hand right.

00:23:21.540 --> 00:23:25.290
If this is a false
formula, the For All player

00:23:25.290 --> 00:23:30.760
will always be able to win
if it plays its hand right.

00:23:30.760 --> 00:23:32.980
So why is that?

00:23:36.070 --> 00:23:41.960
It really follows kind of almost
without doing any work at all.

00:23:41.960 --> 00:23:45.710
This proof, even though
it looks superficially

00:23:45.710 --> 00:23:48.500
like it might be not
so easy to prove,

00:23:48.500 --> 00:23:50.690
it follows for a
very simple reason

00:23:50.690 --> 00:23:56.210
because the meaning of what
it means for Exist to have

00:23:56.210 --> 00:24:00.530
a winning strategy is exactly
captured by the semantics

00:24:00.530 --> 00:24:02.330
of the quantifiers.

00:24:02.330 --> 00:24:03.690
Let's see what that means.

00:24:03.690 --> 00:24:06.140
What does it mean that
Exist has a forced

00:24:06.140 --> 00:24:10.420
win, let's say up here?

00:24:10.420 --> 00:24:14.330
That means that Exist has
a move that it could make,

00:24:14.330 --> 00:24:21.920
that Exist can pick some value
for x1-- so there was some way

00:24:21.920 --> 00:24:26.690
to assign x1 so that no
matter what the opponent does,

00:24:26.690 --> 00:24:29.460
no matter what For
All does, there's

00:24:29.460 --> 00:24:32.980
going to be a response
that Exist can make,

00:24:32.980 --> 00:24:40.325
some assignment to x3, so that
no matter what For All does,

00:24:40.325 --> 00:24:41.700
there's going to
be an assignment

00:24:41.700 --> 00:24:46.540
to the next variable,
and so on and so on,

00:24:46.540 --> 00:24:48.677
so that this thing
ends up being true.

00:24:48.677 --> 00:24:50.260
So let me just say
that again somehow.

00:24:50.260 --> 00:24:52.560
I didn't feel it
came out very clear.

00:24:52.560 --> 00:24:56.580
So Exist has a winning
strategy exactly when

00:24:56.580 --> 00:24:59.070
there is some assignment
to x1 that Exist

00:24:59.070 --> 00:25:01.620
can make such that no
matter what assignment

00:25:01.620 --> 00:25:05.190
that For All makes to x2,
there is some assignment

00:25:05.190 --> 00:25:09.780
x3 such that no matter what
assignment that For All

00:25:09.780 --> 00:25:14.860
makes to x4 and so on,
makes this thing true.

00:25:14.860 --> 00:25:19.030
That's what it means for Exist
to have a winning strategy.

00:25:19.030 --> 00:25:21.070
That's exactly what
the quantifiers

00:25:21.070 --> 00:25:22.760
are saying in the first place.

00:25:22.760 --> 00:25:25.270
So even really without
doing anything,

00:25:25.270 --> 00:25:28.780
you can see that "Exist
has a winning strategy"

00:25:28.780 --> 00:25:32.410
means exactly the same thing
as the quantified Boolean

00:25:32.410 --> 00:25:34.010
formula being true.

00:25:34.010 --> 00:25:39.010
So making the test of which
side has a winning strategy

00:25:39.010 --> 00:25:41.350
is the same as testing
whether the formula is true.

00:25:45.550 --> 00:25:48.520
So let me try to
turn to the chat

00:25:48.520 --> 00:25:50.440
before we move on
to anything else.

00:25:57.840 --> 00:25:58.470
Here we go.

00:26:10.260 --> 00:26:12.960
So I'm getting some questions
about the order of play

00:26:12.960 --> 00:26:15.700
and about the alternation
of the quantifiers here.

00:26:15.700 --> 00:26:18.900
So the way I'm showing it is
that the quantifiers always

00:26:18.900 --> 00:26:19.920
alternate--

00:26:19.920 --> 00:26:21.900
Exist, For All, Exist, For All.

00:26:21.900 --> 00:26:25.140
That doesn't really matter.

00:26:25.140 --> 00:26:27.120
You can have several
Exists in a row,

00:26:27.120 --> 00:26:28.620
and that would
correspond to Exist

00:26:28.620 --> 00:26:31.530
making several moves
in a row before turning

00:26:31.530 --> 00:26:33.360
it over to For All.

00:26:33.360 --> 00:26:39.650
But alternatively, we could
just add extra variables which

00:26:39.650 --> 00:26:42.960
don't play any role in psi.

00:26:42.960 --> 00:26:45.720
And they're just kind
of dummy variables

00:26:45.720 --> 00:26:48.930
that serve as spacers so if
you have two Exists in a row

00:26:48.930 --> 00:26:51.120
and you don't like
that, you can just add a

00:26:51.120 --> 00:26:55.470
For All of some variables that
you never see again in between.

00:26:55.470 --> 00:26:57.780
So you can always get it to
be alternating if you want.

00:27:05.940 --> 00:27:12.600
OK, also question-- the
difference between phi and psi.

00:27:12.600 --> 00:27:16.510
So psi is the part here that
does not have any quantifiers.

00:27:16.510 --> 00:27:19.410
So the way we always
write down our QBFs

00:27:19.410 --> 00:27:23.610
is they're leading quantifiers
with the variables,

00:27:23.610 --> 00:27:26.310
and all variables have to
be within the scope of one

00:27:26.310 --> 00:27:29.140
of the quantified variables.

00:27:29.140 --> 00:27:31.590
So there are no
free variables that

00:27:31.590 --> 00:27:33.835
are unquantified in our QBFs.

00:27:36.570 --> 00:27:40.110
And so all of these
QBFs have a run

00:27:40.110 --> 00:27:42.960
of quantifiers and then a
part without quantifiers, so

00:27:42.960 --> 00:27:44.820
the Boolean logic part.

00:27:44.820 --> 00:27:48.010
Psi here is the
Boolean logic part.

00:27:48.010 --> 00:27:50.905
And phi is the whole thing
together with the quantifiers.

00:27:53.580 --> 00:28:01.050
So I'm not sure I
understand some of these--

00:28:01.050 --> 00:28:03.250
why not have the For All
player have a forced win?

00:28:03.250 --> 00:28:07.050
The For All player
might have a forced win.

00:28:07.050 --> 00:28:08.970
One side or the
other is guaranteed

00:28:08.970 --> 00:28:10.240
to have a forced win.

00:28:10.240 --> 00:28:12.180
So if Exist does not
have a forced win,

00:28:12.180 --> 00:28:14.760
then For All will
have a forced win.

00:28:14.760 --> 00:28:16.710
I'm not going to prove that.

00:28:16.710 --> 00:28:19.263
That's a fairly simple
proof by induction, which

00:28:19.263 --> 00:28:20.430
I'm not going to go through.

00:28:20.430 --> 00:28:23.290
Just take it as a fact.

00:28:23.290 --> 00:28:27.940
Somebody is asking, why does
For All want to not satisfy

00:28:27.940 --> 00:28:32.470
this expression, the psi part?

00:28:32.470 --> 00:28:35.140
Well, that's the way
we set up the game.

00:28:35.140 --> 00:28:40.060
In order to make this
correspond to TQBF,

00:28:40.060 --> 00:28:44.270
just the truth of
this expression,

00:28:44.270 --> 00:28:48.830
we want to make Exist
try to satisfy this part

00:28:48.830 --> 00:28:56.530
and For All try to make it
not satisfied because that's

00:28:56.530 --> 00:28:57.220
what works.

00:28:57.220 --> 00:29:02.350
I'm not sure what else, what
other why I can answer there.

00:29:02.350 --> 00:29:05.300
I'm going to answer some of
the most basic questions here.

00:29:05.300 --> 00:29:08.990
Somebody is asking, how do we
know how many variables to use?

00:29:08.990 --> 00:29:13.190
So the variables are the
variables of the formula.

00:29:13.190 --> 00:29:15.490
So somebody is going
to hand you a formula.

00:29:15.490 --> 00:29:19.030
That's going to have x1 to
x10, whatever that formula has,

00:29:19.030 --> 00:29:20.350
some number of variables.

00:29:20.350 --> 00:29:23.980
And so that game is
going to have 10 moves.

00:29:23.980 --> 00:29:28.120
If the quantifiers alternate,
then the moves will alternate,

00:29:28.120 --> 00:29:30.550
but whatever the pattern
of the quantifiers

00:29:30.550 --> 00:29:32.260
is going to be the
pattern of the moves.

00:29:32.260 --> 00:29:37.990
So Exist is going to follow
the places where the Exist

00:29:37.990 --> 00:29:40.235
quantifier occurs,
and For All is

00:29:40.235 --> 00:29:42.860
going to follow the places where
the For All quantifier occurs.

00:29:42.860 --> 00:29:45.983
So if you have Exist, For
All, Exist, For All, Exist

00:29:45.983 --> 00:29:47.650
will move first, then
For All will move,

00:29:47.650 --> 00:29:49.525
then Exist will move,
then For All will move.

00:29:49.525 --> 00:29:52.640
Together, they're picking values
to their respective variables

00:29:52.640 --> 00:29:54.730
with their opposing goals.

00:29:54.730 --> 00:29:59.710
Exist is trying to make
the psi part satisfied.

00:29:59.710 --> 00:30:02.970
For All is trying to
avoid making it satisfied,

00:30:02.970 --> 00:30:07.370
to make the assignment
not satisfy that part.

00:30:07.370 --> 00:30:10.690
And if you think about
what that means, just

00:30:10.690 --> 00:30:13.540
in terms of the
meaning of that, it's

00:30:13.540 --> 00:30:15.280
going to mean exactly
the same thing,

00:30:15.280 --> 00:30:16.360
that the formula is true.

00:30:20.600 --> 00:30:24.840
So anyway, if you don't--

00:30:24.840 --> 00:30:25.710
let's see.

00:30:25.710 --> 00:30:27.460
I don't know if there's
any more questions

00:30:27.460 --> 00:30:28.770
that I can try to answer here.

00:30:37.890 --> 00:30:39.945
It's still about the
numbers of variables.

00:30:43.260 --> 00:30:46.740
Each formula is going to
define a different game.

00:30:46.740 --> 00:30:49.500
You see the formula.

00:30:49.500 --> 00:30:52.310
So the formula, however big--
it may have 50 variables,

00:30:52.310 --> 00:30:53.657
it may have two variables.

00:30:53.657 --> 00:30:54.740
Well, we'll do an example.

00:30:54.740 --> 00:30:57.680
Maybe that'll help.

00:30:57.680 --> 00:30:59.970
The next check in, which
is coming up pretty soon--

00:30:59.970 --> 00:31:01.490
might actually be now--

00:31:01.490 --> 00:31:03.540
we'll give you an example.

00:31:03.540 --> 00:31:08.180
So we'll see who is
understanding and who is not.

00:31:08.180 --> 00:31:09.260
So let's continue here.

00:31:12.040 --> 00:31:15.710
So therefore, the
problem of determining

00:31:15.710 --> 00:31:19.460
does Exist have a forced win
is exactly the TQBF problem,

00:31:19.460 --> 00:31:22.310
because Exist has a forced win
exactly when the formula is

00:31:22.310 --> 00:31:24.820
true.

00:31:24.820 --> 00:31:30.400
And what we're going to show is
that TQBF is a polynomial time

00:31:30.400 --> 00:31:33.100
reducible to
generalized geography,

00:31:33.100 --> 00:31:37.210
but conceptually, we're going to
think about TQBF now as a game

00:31:37.210 --> 00:31:40.600
because that's how generalized
geography is set up.

00:31:40.600 --> 00:31:43.660
So given a formula
like this, we're

00:31:43.660 --> 00:31:46.360
going to construct an instance
of generalized geography.

00:31:46.360 --> 00:31:50.730
We're going to construct a
graph where play on that graph

00:31:50.730 --> 00:31:55.150
is going to mimic play
in the formula game.

00:31:55.150 --> 00:31:56.800
So making the
moves in that graph

00:31:56.800 --> 00:31:59.470
are going to correspond
to setting variables

00:31:59.470 --> 00:32:01.300
true and false
because the graph is

00:32:01.300 --> 00:32:04.315
going to be specially designed
to force that behavior.

00:32:06.850 --> 00:32:08.820
So I think we have a
check-in coming in.

00:32:08.820 --> 00:32:11.250
Yeah, so let's just see how--

00:32:11.250 --> 00:32:13.610
I suggest you pay
attention to this check-in,

00:32:13.610 --> 00:32:15.360
really try to think
about it and solve it,

00:32:15.360 --> 00:32:16.902
because I think
that'll help you make

00:32:16.902 --> 00:32:21.390
the connection between
the truth of the formula

00:32:21.390 --> 00:32:24.285
and Exist having a
winning strategy.

00:32:28.870 --> 00:32:31.390
So if you take
this formula here--

00:32:31.390 --> 00:32:34.270
this is some particular
formula, Exist x for all y,

00:32:34.270 --> 00:32:36.520
blah, blah, blah.

00:32:36.520 --> 00:32:39.010
There's going to be associated
to that formula, a formula

00:32:39.010 --> 00:32:42.190
game where first
Exist moves, assigns

00:32:42.190 --> 00:32:44.860
a value for x, and
depending upon that value,

00:32:44.860 --> 00:32:48.040
For All is going to move and is
going to assign a value for y.

00:32:48.040 --> 00:32:50.320
And after that's
done, this part here

00:32:50.320 --> 00:32:51.820
is either going to
be true or false,

00:32:51.820 --> 00:32:54.910
is either going to be
satisfied or unsatisfied.

00:32:54.910 --> 00:32:57.550
And I want to know,
can Exist always find

00:32:57.550 --> 00:33:01.930
a way to guarantee that this
part is going to be satisfied,

00:33:01.930 --> 00:33:05.500
or can For All always find a way
to guarantee that this part is

00:33:05.500 --> 00:33:07.670
not satisfied?

00:33:07.670 --> 00:33:12.890
So you have to look
at this formula

00:33:12.890 --> 00:33:18.670
to understand which side is
going to end up succeeding.

00:33:18.670 --> 00:33:21.870
So if you're not clear on
the rules, look back here.

00:33:21.870 --> 00:33:24.480
Exist is trying to make
this part satisfied.

00:33:24.480 --> 00:33:26.970
For All is trying to make
this part unsatisfied.

00:33:26.970 --> 00:33:29.790
But they neither of them
has the totally upper hand,

00:33:29.790 --> 00:33:32.460
because Exist is picking
one of the variables,

00:33:32.460 --> 00:33:34.350
For All is picking
the other variable.

00:33:34.350 --> 00:33:38.420
But they're doing it
in a certain order.

00:33:38.420 --> 00:33:41.240
First Exist is going to pick,
then For All is going to pick.

00:33:44.150 --> 00:33:46.180
So that's the way
the game works--

00:33:46.180 --> 00:33:48.710
Exist picks a value, then
For All picks a value,

00:33:48.710 --> 00:33:51.530
and then you see who wins.

00:33:51.530 --> 00:33:52.990
So who wins?

00:33:52.990 --> 00:33:55.570
Who's guaranteed to win?

00:33:55.570 --> 00:33:57.970
Can we make sure
that Exists always

00:33:57.970 --> 00:34:00.610
wins or can we make sure
that For All always wins

00:34:00.610 --> 00:34:02.240
for this particular formula?

00:34:02.240 --> 00:34:05.125
So there's just
two variables here.

00:34:05.125 --> 00:34:07.500
You can think about this in
either of two ways-- strictly

00:34:07.500 --> 00:34:10.920
speaking, purely as a
game, or you can look at,

00:34:10.920 --> 00:34:13.409
understand whether that
formula is true or not.

00:34:20.110 --> 00:34:23.900
They're equivalent ways
of looking at the problem.

00:34:23.900 --> 00:34:26.179
In fact, in a certain
sense, it's the same.

00:34:26.179 --> 00:34:28.821
That's what I'm
trying to get across.

00:34:28.821 --> 00:34:30.904
Thinking about this as a
game or thinking about it

00:34:30.904 --> 00:34:33.725
in terms of quantifiers-- it
doesn't make any difference.

00:34:37.790 --> 00:34:39.510
Almost done here.

00:34:39.510 --> 00:34:44.510
So all right, last call.

00:34:44.510 --> 00:34:45.440
Closing the poll.

00:34:49.010 --> 00:34:50.989
I think this one you got.

00:34:50.989 --> 00:34:52.610
You did pretty well on.

00:34:52.610 --> 00:34:55.580
So the correct answer
is the For All player

00:34:55.580 --> 00:35:00.980
has a winning strategy,
has a forced win.

00:35:00.980 --> 00:35:09.080
And also, similarly, the
expression, phi is false.

00:35:09.080 --> 00:35:12.980
Because if you try to
find some x such that

00:35:12.980 --> 00:35:17.287
no matter what y you pick,
this is going to be true,

00:35:17.287 --> 00:35:19.370
this is going to be
satisfied, you're out of luck.

00:35:19.370 --> 00:35:23.585
Because if you make
x true, well, then--

00:35:32.332 --> 00:35:33.040
now I'm confused.

00:35:37.972 --> 00:35:38.680
What is going on.

00:35:38.680 --> 00:35:48.940
If you make x true,
then x bar is false,

00:35:48.940 --> 00:35:50.295
so y bar has to be true.

00:35:55.850 --> 00:35:57.110
Now I'm completely confused.

00:35:57.110 --> 00:35:59.710
Oh, no.

00:35:59.710 --> 00:36:01.940
If you make x true, you
have to work For All y.

00:36:01.940 --> 00:36:03.260
So this thing is clearly false.

00:36:03.260 --> 00:36:10.310
If you make x true, then this
x bar is going to be false,

00:36:10.310 --> 00:36:15.080
and it's not the case that
for every y, setting for y--

00:36:15.080 --> 00:36:17.783
because y is forced here. y
is going to have to be true.

00:36:17.783 --> 00:36:19.200
y bar is going to
have to be true,

00:36:19.200 --> 00:36:20.617
so y is going to
have to be false.

00:36:20.617 --> 00:36:29.390
So if you try again
to make x false--

00:36:29.390 --> 00:36:34.277
maybe that's one to think about
first-- if you make x false,

00:36:34.277 --> 00:36:36.110
you're going to be stuck
on the first clause

00:36:36.110 --> 00:36:39.590
because it has to work
for both settings of y.

00:36:39.590 --> 00:36:44.270
But maybe thinking about
it as a game is better.

00:36:44.270 --> 00:36:47.210
No matter what x
does, y is going

00:36:47.210 --> 00:36:52.250
to have a way of making one of
those two clauses unsatisfied.

00:36:52.250 --> 00:37:02.350
So if x is true, we can set
y to make the second clause

00:37:02.350 --> 00:37:05.650
unsatisfied, and
if x is false, y

00:37:05.650 --> 00:37:09.550
can be assigned to make the
first clause unsatisfied.

00:37:09.550 --> 00:37:15.110
So anyway, the right answer
is the For All player

00:37:15.110 --> 00:37:16.520
has the winning strategy here.

00:37:16.520 --> 00:37:18.920
And at the end of the
day, it's not critical

00:37:18.920 --> 00:37:20.600
that you understand
this correspondence,

00:37:20.600 --> 00:37:23.498
but you have to then,
if you don't quite

00:37:23.498 --> 00:37:25.040
understand that,
you're going to have

00:37:25.040 --> 00:37:29.000
to take on faith that the
formula game is the same as

00:37:29.000 --> 00:37:31.550
TQBF because that's
what we're going to use.

00:37:31.550 --> 00:37:33.830
And by the way, I would
like to also mention here

00:37:33.830 --> 00:37:40.430
that this correspondence
between games and quantifiers

00:37:40.430 --> 00:37:44.430
is something that
mathematicians use all the time.

00:37:44.430 --> 00:37:47.390
Because if you have
some expression which

00:37:47.390 --> 00:37:49.640
comes up often in
mathematics, where there

00:37:49.640 --> 00:37:57.170
are a whole run of quantifiers
in front of some statement,

00:37:57.170 --> 00:38:00.410
it's really kind
of hard for anybody

00:38:00.410 --> 00:38:04.550
to really get a feeling
for what that means.

00:38:04.550 --> 00:38:07.760
If you have six alternating
quantifiers, which

00:38:07.760 --> 00:38:09.477
happens often in
mathematics-- you're

00:38:09.477 --> 00:38:11.810
going to have statements that
have a lot of alternations

00:38:11.810 --> 00:38:13.310
with quantifiers--
very hard to get

00:38:13.310 --> 00:38:14.700
a feeling for what that means.

00:38:14.700 --> 00:38:17.990
But if you think about it as a
game, it's much more intuitive.

00:38:17.990 --> 00:38:21.230
And it's completely equivalent
to think about quantifiers.

00:38:21.230 --> 00:38:25.070
Go back and forth between
quantifiers and games.

00:38:25.070 --> 00:38:29.990
Anyway, let's look
at the reduction,

00:38:29.990 --> 00:38:32.780
the construction that
shows generalized geography

00:38:32.780 --> 00:38:34.340
is complete.

00:38:34.340 --> 00:38:36.300
A little longer than I thought--

00:38:36.300 --> 00:38:38.580
I just want to make sure
everybody is with me on this.

00:38:38.580 --> 00:38:43.340
So why don't we call the break
now, and then we'll come back

00:38:43.340 --> 00:38:45.973
and we'll look at the
construction after that.

00:38:45.973 --> 00:38:47.390
Because the
construction itself is

00:38:47.390 --> 00:38:50.690
going to take about 10 minutes
to work through to, figure out

00:38:50.690 --> 00:38:56.140
how to reduce TQBF
and build a graph that

00:38:56.140 --> 00:38:58.480
simulates the formula.

00:38:58.480 --> 00:39:02.275
So I'm going to move
right on to the--

00:39:05.580 --> 00:39:07.650
and we'll come back.

00:39:07.650 --> 00:39:14.430
So feel free to ask some
questions and get ready for us

00:39:14.430 --> 00:39:21.360
diving in to a construction
for the reduction of TQBF

00:39:21.360 --> 00:39:23.590
to generalized geography.

00:39:23.590 --> 00:39:28.260
So it is an interesting
question about what's

00:39:28.260 --> 00:39:31.780
the relationship
between a formula

00:39:31.780 --> 00:39:34.470
and when you swap the
order of the quantifiers.

00:39:37.660 --> 00:39:42.550
The questioner is asking, does
that somehow relate to negating

00:39:42.550 --> 00:39:48.010
the quantifier-free part, the
part without the quantifiers?

00:39:48.010 --> 00:39:51.070
And I don't think that that's
the right correspondence.

00:39:51.070 --> 00:39:54.160
There actually is
some relationship.

00:39:54.160 --> 00:39:59.260
When you say "there
exists for all,"

00:39:59.260 --> 00:40:00.910
it's actually a
stronger statement

00:40:00.910 --> 00:40:03.220
than saying that "for
all there exists."

00:40:03.220 --> 00:40:06.790
And in general, that
actually implies--

00:40:06.790 --> 00:40:14.440
exist x for a y implies
for a y there exists an x,

00:40:14.440 --> 00:40:22.060
because what you're saying
is that if there exists an x

00:40:22.060 --> 00:40:25.540
for a y, there is one x that
works for every one of the y's.

00:40:25.540 --> 00:40:27.910
If you're saying for
a y there exists an x,

00:40:27.910 --> 00:40:31.940
the choice of that x
can depend on the y.

00:40:31.940 --> 00:40:35.450
So there is a
connection, but you

00:40:35.450 --> 00:40:37.400
have to think through
what it means in order

00:40:37.400 --> 00:40:40.700
to understand that connection.

00:40:40.700 --> 00:40:43.070
You won't need to
know that in order

00:40:43.070 --> 00:40:44.940
to process what we're
going to be doing,

00:40:44.940 --> 00:40:46.732
but maybe it just helps
you think about it.

00:40:49.670 --> 00:40:50.750
Other questions here.

00:40:59.980 --> 00:41:03.610
I think we're out of time here.

00:41:06.390 --> 00:41:11.445
So let's return to our lecture.

00:41:15.020 --> 00:41:17.720
So I'm going to go back.

00:41:17.720 --> 00:41:20.720
Hopefully that won't
crash everything.

00:41:24.250 --> 00:41:26.680
There we go.

00:41:26.680 --> 00:41:29.860
So now we're going
to be reducing TQBF

00:41:29.860 --> 00:41:31.260
to generalized geography.

00:41:31.260 --> 00:41:32.260
Are we all together now?

00:41:36.400 --> 00:41:37.540
OK.

00:41:37.540 --> 00:41:41.350
So I'm going to illustrate this
construction, which is a very

00:41:41.350 --> 00:41:42.820
nice construction, by the way.

00:41:42.820 --> 00:41:44.737
I'm going to illustrate
this construction just

00:41:44.737 --> 00:41:48.170
by doing an example,
or a partial example,

00:41:48.170 --> 00:41:50.620
but I think it'll
give you the idea.

00:41:50.620 --> 00:41:52.770
So you understand what
I'm trying to do here,

00:41:52.770 --> 00:41:58.740
is I'm starting off with a
quantified Boolean formula.

00:41:58.740 --> 00:42:00.860
So here it is.

00:42:00.860 --> 00:42:05.450
I'm going to assume it's in
conjunctive normal form, which

00:42:05.450 --> 00:42:08.420
I can always convert
it into that form,

00:42:08.420 --> 00:42:10.850
maybe by adding some
additional variables,

00:42:10.850 --> 00:42:18.210
but without doing anything
too drastic to it.

00:42:18.210 --> 00:42:23.580
And so now, starting
from that formula,

00:42:23.580 --> 00:42:27.570
I'm going to now build a graph,
where playing the geography

00:42:27.570 --> 00:42:30.510
game on that graph-- which
is, remember, taking turns,

00:42:30.510 --> 00:42:33.810
picking nodes
which form a path--

00:42:33.810 --> 00:42:38.580
is going to correspond to
playing the formula game, which

00:42:38.580 --> 00:42:41.250
is picking the variables
of that formula.

00:42:41.250 --> 00:42:44.646
And then you want--

00:42:44.646 --> 00:42:47.160
if the Exist player
wins in the formula,

00:42:47.160 --> 00:42:51.360
then Player I is supposed to
win in the geography game.

00:42:54.240 --> 00:42:56.550
So here is how the
graph is going to look.

00:42:59.200 --> 00:43:01.510
So try to follow this.

00:43:01.510 --> 00:43:05.510
So there's going to
be kind of two parts,

00:43:05.510 --> 00:43:08.410
one that's going to
correspond to the variables,

00:43:08.410 --> 00:43:12.760
and the other part that's going
to correspond to the clauses.

00:43:12.760 --> 00:43:14.980
And so for each
variable, I'm going

00:43:14.980 --> 00:43:16.863
to have a diamond
structure here.

00:43:16.863 --> 00:43:18.280
So there's a little
starting thing

00:43:18.280 --> 00:43:21.080
that's going to be unique
to the first variable.

00:43:21.080 --> 00:43:23.800
But then every variable is
going to have a little diamond

00:43:23.800 --> 00:43:25.960
structure here.

00:43:25.960 --> 00:43:29.520
And they're going to be
attached one to the next.

00:43:29.520 --> 00:43:36.870
And we'll understand what this
means when we play geography

00:43:36.870 --> 00:43:40.253
on this piece of the
graph, but let's just

00:43:40.253 --> 00:43:41.545
understand the structure first.

00:43:44.340 --> 00:43:46.740
So this is the start node.

00:43:46.740 --> 00:43:51.540
And now, here Player I is going
to play the role of Exist.

00:43:51.540 --> 00:43:53.790
Player II is going to
play the role of For All.

00:43:53.790 --> 00:43:56.290
And in fact, I'm going
to identify that.

00:43:56.290 --> 00:43:58.110
So I'm going to
call-- because it's

00:43:58.110 --> 00:44:03.390
going to be helpful just
to think about Player I

00:44:03.390 --> 00:44:04.860
as being the Exist player.

00:44:04.860 --> 00:44:08.525
So the Exist player is going
to be playing on this graph.

00:44:08.525 --> 00:44:09.900
The Exist and the
For All players

00:44:09.900 --> 00:44:11.442
are going to be
playing on the graph.

00:44:11.442 --> 00:44:12.900
It's really just
Players I and II.

00:44:12.900 --> 00:44:19.830
So the Exist player,
Player I, by the rules,

00:44:19.830 --> 00:44:22.640
has to pick the start node.

00:44:22.640 --> 00:44:26.560
And now it's Player II's move,
the For All player's move.

00:44:26.560 --> 00:44:33.380
Now, if you're with
me on this graph,

00:44:33.380 --> 00:44:36.770
the For All player's move
is now not very interesting

00:44:36.770 --> 00:44:38.480
because it's forced.

00:44:38.480 --> 00:44:41.090
It has to go to here,
because again, they're

00:44:41.090 --> 00:44:48.760
just picking the nodes of a
simple path in this graph.

00:44:48.760 --> 00:44:52.710
So the For All, Player
II, the For All player,

00:44:52.710 --> 00:44:56.310
has to go here if Exist
started over there.

00:44:56.310 --> 00:45:00.720
Now it's the Exist
player's turn.

00:45:00.720 --> 00:45:03.630
And now something
interesting happens.

00:45:03.630 --> 00:45:05.550
The Exist player has a choice--

00:45:05.550 --> 00:45:08.570
it can either go left or right.

00:45:08.570 --> 00:45:11.540
There are two possibilities.

00:45:11.540 --> 00:45:15.010
And then after that,
the For All player's

00:45:15.010 --> 00:45:18.250
turn, who is,
again, just forced.

00:45:18.250 --> 00:45:20.680
So far, For All has not
had much interesting stuff

00:45:20.680 --> 00:45:26.450
to do in this, has
not had to think hard.

00:45:26.450 --> 00:45:30.550
So no matter whether
Exist went left or right,

00:45:30.550 --> 00:45:34.820
the For All player's move is
forced and ends up over here.

00:45:34.820 --> 00:45:36.440
And now it's this player's turn.

00:45:36.440 --> 00:45:38.650
And again, this is
kind of an easy one.

00:45:38.650 --> 00:45:44.680
Oh, before I do that, let's just
look at how that play could go.

00:45:44.680 --> 00:45:47.580
So the first two moves, as
kind of I was suggesting,

00:45:47.580 --> 00:45:52.150
Exist goes here and
then For All goes there.

00:45:52.150 --> 00:45:56.680
I'm going to illustrate possible
plays through this graph

00:45:56.680 --> 00:45:58.600
by tracing them out in green.

00:46:01.570 --> 00:46:03.960
So now Exist goes here,
For All goes there.

00:46:03.960 --> 00:46:05.190
Those were forced.

00:46:05.190 --> 00:46:08.640
But now, the Exist player
goes, could either go this way

00:46:08.640 --> 00:46:10.800
or could go that way.

00:46:15.120 --> 00:46:18.750
So those are two
possible different ways

00:46:18.750 --> 00:46:23.340
of playing the game
that we're building.

00:46:23.340 --> 00:46:29.960
And now, whose turn is it here?

00:46:32.547 --> 00:46:34.380
This was the For All
player picked this one,

00:46:34.380 --> 00:46:40.410
so the next turn is the Exist
player, and that's forced.

00:46:40.410 --> 00:46:43.740
But now notice-- now
for the first time,

00:46:43.740 --> 00:46:47.040
the For All player has to think,
because the For All player

00:46:47.040 --> 00:46:56.485
can either go left or right,
so could either go left,

00:46:56.485 --> 00:46:57.360
or it could go right.

00:47:00.980 --> 00:47:05.920
And so then there's going to
be a sequence of these diamond

00:47:05.920 --> 00:47:10.840
structures, where they're
constructed so that alternately

00:47:10.840 --> 00:47:13.030
either the Exist
has a choice or the

00:47:13.030 --> 00:47:16.437
For All player has a choice,
until you get all the way down

00:47:16.437 --> 00:47:17.020
to the bottom.

00:47:21.380 --> 00:47:23.660
That is the graph
we've built so far.

00:47:23.660 --> 00:47:31.970
Now, if we stopped here, then
whoever ended up at this point,

00:47:31.970 --> 00:47:34.220
whether it was Exist or For
All, would be the winner

00:47:34.220 --> 00:47:38.390
because there's nowhere
for the opponent to go.

00:47:38.390 --> 00:47:41.010
Of course, that wouldn't
be very interesting.

00:47:41.010 --> 00:47:43.940
So there's going to be more
stuff we're going to add on,

00:47:43.940 --> 00:47:47.250
which are going to
correspond to the clauses.

00:47:47.250 --> 00:47:52.340
Now, how to think about
what's happened so far?

00:47:52.340 --> 00:47:55.810
Maybe some of you
might be guessing

00:47:55.810 --> 00:47:59.277
that when the Exist player
over here has a choice,

00:47:59.277 --> 00:48:01.360
could have either gone
left or right, that's going

00:48:01.360 --> 00:48:05.350
to correspond-- because this
is supposed to be mimicking

00:48:05.350 --> 00:48:09.970
the formula game-- that's going
to correspond to the Exist

00:48:09.970 --> 00:48:13.450
player in the formula
picking the variable

00:48:13.450 --> 00:48:15.380
either true or false.

00:48:15.380 --> 00:48:19.370
So to the left or right is going
to correspond to true or false.

00:48:19.370 --> 00:48:22.190
And so let's just
arbitrarily say

00:48:22.190 --> 00:48:25.548
left is going to correspond
to picking it true and right

00:48:25.548 --> 00:48:27.215
is going to correspond
to picking false.

00:48:30.300 --> 00:48:35.970
So the way I've set it
so far is Exist ended up

00:48:35.970 --> 00:48:38.340
picking the first
variable false,

00:48:38.340 --> 00:48:41.910
then For All picked the
second variable false.

00:48:41.910 --> 00:48:44.160
And the nth variable
also got set false.

00:48:44.160 --> 00:48:45.543
Everything got set false so far.

00:48:45.543 --> 00:48:47.460
Who knows what happened
over here, of course--

00:48:51.500 --> 00:48:54.690
so just to understand
what we've done so far.

00:48:54.690 --> 00:48:58.200
Now I'm going to show you how
to build the rest of the graph.

00:48:58.200 --> 00:49:02.280
So let's take away
the green part.

00:49:02.280 --> 00:49:05.340
And now we're just back
to the construction.

00:49:05.340 --> 00:49:07.720
The green part is actually
how you use that construction.

00:49:07.720 --> 00:49:09.570
So back to the
construction here-- now,

00:49:09.570 --> 00:49:12.210
what do we want to achieve?

00:49:12.210 --> 00:49:18.180
By the time the players on the
graph have got down to here,

00:49:18.180 --> 00:49:21.390
they've effectively made an
assignment to the variables

00:49:21.390 --> 00:49:24.570
by going either left or right
at each one of these diamonds.

00:49:24.570 --> 00:49:27.000
So the assignment is done.

00:49:27.000 --> 00:49:31.140
From the perspective of the
formula game, the game is over,

00:49:31.140 --> 00:49:34.820
and now one side or
the other has won.

00:49:34.820 --> 00:49:38.600
Here, we want to build
some extra structure here

00:49:38.600 --> 00:49:44.290
as a kind of an endgame, to make
sure that the For All player

00:49:44.290 --> 00:49:47.440
gets stuck if the
Exist player has

00:49:47.440 --> 00:49:50.570
made an assignment
which satisfies

00:49:50.570 --> 00:49:51.940
this part of the formula.

00:49:51.940 --> 00:49:56.630
And the Exist player should get
stuck if the For All player,

00:49:56.630 --> 00:50:02.070
if the assignment that they made
does not satisfy the formula.

00:50:02.070 --> 00:50:04.080
So let's see how we're
going to achieve that

00:50:04.080 --> 00:50:06.310
with some additional structure.

00:50:06.310 --> 00:50:09.463
So there's going to be
some extra node over here.

00:50:09.463 --> 00:50:11.880
Let me just tell you what the
structure is, and then we'll

00:50:11.880 --> 00:50:13.290
argue why it works.

00:50:13.290 --> 00:50:16.470
So going from this
bottom node, we're

00:50:16.470 --> 00:50:21.300
going to start the
second part of the graph.

00:50:21.300 --> 00:50:24.390
There's going to be
a node which fans out

00:50:24.390 --> 00:50:26.250
to a node for each
one of the clauses.

00:50:29.310 --> 00:50:30.990
And each one of those
clauses, in turn,

00:50:30.990 --> 00:50:36.000
fans out to a node for
each one of its literals.

00:50:36.000 --> 00:50:39.030
So you see we have
clause c1, and it

00:50:39.030 --> 00:50:43.950
has the literals x1, x2
bar, x3, x1, x2 bar, x3.

00:50:43.950 --> 00:50:47.280
So there's a node for each
of the literals in clause c1,

00:50:47.280 --> 00:50:49.650
same for clause c2, and so on.

00:50:52.340 --> 00:50:53.770
Now we're almost done.

00:50:53.770 --> 00:50:58.150
Now I'm going to tell you how to
connect up these literal nodes.

00:50:58.150 --> 00:51:03.130
So x1, each node is
going to correspond back

00:51:03.130 --> 00:51:05.500
to its own diamond.

00:51:05.500 --> 00:51:06.970
So now we're going
to tie it back

00:51:06.970 --> 00:51:10.120
to the first part, where
we made the assignment

00:51:10.120 --> 00:51:11.350
part of the graph.

00:51:11.350 --> 00:51:15.040
x1 is going to connect
back to the true part

00:51:15.040 --> 00:51:18.270
of the x1 diamond.

00:51:18.270 --> 00:51:20.460
And x2 because, it's
negated, is going

00:51:20.460 --> 00:51:24.920
to tie back to the false
part of the x2 diamond

00:51:24.920 --> 00:51:28.160
because it's an x2 variable.

00:51:28.160 --> 00:51:36.040
Similarly, x1 bar--
because x1 bar--

00:51:36.040 --> 00:51:39.350
here's x1 bar in clause 2--

00:51:39.350 --> 00:51:43.010
x1 bar is going
to connect up now

00:51:43.010 --> 00:51:48.100
to the false side
of the x1 diamond.

00:51:48.100 --> 00:51:50.350
And x2 bar is
going to connect up

00:51:50.350 --> 00:51:55.140
to the false side of the
x2 diamond, and so on.

00:51:55.140 --> 00:51:56.970
I don't have the
other diamonds here,

00:51:56.970 --> 00:52:01.050
but the x4 would connect
up to the true side

00:52:01.050 --> 00:52:05.550
of the x4 diamond, for example.

00:52:05.550 --> 00:52:06.810
That's the whole construction.

00:52:06.810 --> 00:52:09.620
Let's understand why it works.

00:52:09.620 --> 00:52:11.870
So the endgame here
is we want Exist

00:52:11.870 --> 00:52:18.340
to win if the assignment
satisfied all the clauses.

00:52:18.340 --> 00:52:22.400
And For All should win if there
was some unsatisfied clauses.

00:52:22.400 --> 00:52:23.910
So why does this happen?

00:52:23.910 --> 00:52:26.370
So let's put back an
assignment here that was made.

00:52:26.370 --> 00:52:32.030
So the one I'm putting
back, the assignment

00:52:32.030 --> 00:52:36.440
that they cooperatively
built had x1 being true,

00:52:36.440 --> 00:52:40.700
x2 being false, and
some other stuff.

00:52:40.700 --> 00:52:41.850
Now, why does this work?

00:52:41.850 --> 00:52:44.660
So what we want to
have happen now--

00:52:44.660 --> 00:52:47.570
so now, the move
proceeds over to here,

00:52:47.570 --> 00:52:52.820
and you need to arrange
it so that Exist

00:52:52.820 --> 00:52:54.650
is the one who picks that node.

00:53:00.730 --> 00:53:03.370
If this would have been For
All, just add an extra node

00:53:03.370 --> 00:53:06.860
to switch whose turn it is.

00:53:06.860 --> 00:53:08.420
But you want Exist
to be up here.

00:53:08.420 --> 00:53:13.760
And what you want is for For All
to be picking the clause node.

00:53:13.760 --> 00:53:18.080
Now, here is the part to
understand what's going on--

00:53:22.240 --> 00:53:28.160
we want For All to win
if this is not satisfied.

00:53:28.160 --> 00:53:32.070
So For All is going
to make a claim.

00:53:32.070 --> 00:53:34.050
If it is not satisfied,
there is some clause

00:53:34.050 --> 00:53:35.190
which is not satisfied.

00:53:35.190 --> 00:53:36.870
There's some clause
which ended up

00:53:36.870 --> 00:53:38.410
being false in the assignment.

00:53:38.410 --> 00:53:42.530
So the For All player going
to say, "I think I won.

00:53:42.530 --> 00:53:47.500
And I won because clause
number 1 is unsatisfied."

00:53:47.500 --> 00:53:50.647
So it's going to pick
clause number one.

00:53:50.647 --> 00:53:52.480
So here's the For All
player's [INAUDIBLE]..

00:53:52.480 --> 00:53:53.920
Here's Exist player.

00:53:53.920 --> 00:53:59.110
And so the For All player picks
the clause claimed unsatisfied.

00:53:59.110 --> 00:54:03.130
So over here, For All player
says, clause c1 is unsatisfied.

00:54:03.130 --> 00:54:06.170
I'm going to move here.

00:54:06.170 --> 00:54:10.050
Exist player says, "Uh-uh,
I don't agree with you.

00:54:10.050 --> 00:54:12.840
The assignment, your line--

00:54:15.660 --> 00:54:20.100
the assignment actually
makes one of the literals

00:54:20.100 --> 00:54:23.600
true in clause c1.

00:54:23.600 --> 00:54:28.190
Let's say you made x1 was
true, as in fact, it is here--

00:54:28.190 --> 00:54:29.580
x1, in fact, is true.

00:54:29.580 --> 00:54:37.340
So Exist is now going to pick
the literal that was true

00:54:37.340 --> 00:54:40.820
in the assignment in that
clause, that the For All player

00:54:40.820 --> 00:54:43.090
is claiming is unsatisfied.

00:54:43.090 --> 00:54:46.750
One of them is
lying at this point.

00:54:46.750 --> 00:54:49.630
This is either now true in here,
which means the For All player

00:54:49.630 --> 00:54:51.520
did not pick an
unsatisfied clause,

00:54:51.520 --> 00:54:54.410
or the Exist player
picked the false literal,

00:54:54.410 --> 00:54:58.780
which is the Exist player picked
the false literal so the Exist

00:54:58.780 --> 00:55:00.070
player is lying.

00:55:00.070 --> 00:55:06.510
Now, the moment of truth
because let's see--

00:55:06.510 --> 00:55:12.590
if Exist picked here, now it's
the For All player's turn.

00:55:12.590 --> 00:55:15.005
It's connected back to the
true side of the diamond.

00:55:18.530 --> 00:55:20.570
So that node was already used.

00:55:20.570 --> 00:55:23.390
That's the only place that
For All could possibly go.

00:55:23.390 --> 00:55:26.030
For All is stuck,
and Exist has won

00:55:26.030 --> 00:55:31.190
the game, which is what you
want because For All's claims

00:55:31.190 --> 00:55:36.110
are false and the Exist
was correct in saying

00:55:36.110 --> 00:55:39.410
that x1 satisfied clause c1.

00:55:39.410 --> 00:55:43.490
So x1 is true, so there's
nowhere for For All to go.

00:55:43.490 --> 00:55:45.830
But compare that
with the situation

00:55:45.830 --> 00:55:49.130
if the assignment, on
this part of the graph,

00:55:49.130 --> 00:55:52.550
had gone through the
false, had assigned x1

00:55:52.550 --> 00:55:55.710
to be false, so the path
had gone through the

00:55:55.710 --> 00:55:57.890
For All side of the diamond.

00:55:57.890 --> 00:56:00.650
Now this node would
still be unoccupied,

00:56:00.650 --> 00:56:04.860
would still be available.

00:56:04.860 --> 00:56:08.210
So now the For All
play-- so if Exist

00:56:08.210 --> 00:56:13.920
was claiming that x1 was
true and it really was false,

00:56:13.920 --> 00:56:16.608
the For All player would be
able to move onto that node.

00:56:16.608 --> 00:56:18.150
And now it's the
Exist player's turn,

00:56:18.150 --> 00:56:21.990
and the Exist would be stuck
because this node down here is

00:56:21.990 --> 00:56:23.220
guaranteed to have been used.

00:56:25.780 --> 00:56:29.460
So that is the idea.

00:56:29.460 --> 00:56:34.170
It's really very beautiful, and
actually not that complicated.

00:56:34.170 --> 00:56:36.010
You have to stare at it a bit.

00:56:36.010 --> 00:56:38.380
So let's just see what
happens, for example,

00:56:38.380 --> 00:56:42.180
if I had one other case-- maybe
it's not necessary at this

00:56:42.180 --> 00:56:49.080
point, but if the For All player
claimed it's the second clause

00:56:49.080 --> 00:56:53.710
which is unsatisfied in the
mutually selected assignment,

00:56:53.710 --> 00:56:54.210
then--

00:56:57.930 --> 00:57:00.760
so this is sort of the case
where the For All player

00:57:00.760 --> 00:57:05.500
is correct, in that if
the Exist player now says,

00:57:05.500 --> 00:57:11.520
well, I think x1 bar
satisfied that second clause,

00:57:11.520 --> 00:57:17.280
but this assignment made x1
true, so x1 bar is false.

00:57:17.280 --> 00:57:20.170
And so the Exist
player's lying this time.

00:57:20.170 --> 00:57:23.250
And so now the For All player
can take this last edge

00:57:23.250 --> 00:57:27.790
and go here, and has
one last move to make.

00:57:27.790 --> 00:57:29.370
And then the Exist
player's stuck.

00:57:29.370 --> 00:57:31.330
So the For All will
win in that case.

00:57:31.330 --> 00:57:35.250
So let's turn now,
shifting gears entirely

00:57:35.250 --> 00:57:42.480
to a different part
of space complexity.

00:57:42.480 --> 00:57:46.210
Instead of looking at polynomial
space, which is very powerful,

00:57:46.210 --> 00:57:48.990
we're going to look at log
space, which is comparatively

00:57:48.990 --> 00:57:50.640
speaking much, much weaker.

00:57:50.640 --> 00:57:54.180
So log space are the things
that you can do when you only

00:57:54.180 --> 00:57:57.600
have enough space to
write down, essentially,

00:57:57.600 --> 00:58:00.810
a pointer or some fixed number
of pointers into the input.

00:58:00.810 --> 00:58:08.010
That's what you get when
you have logarithmic space,

00:58:08.010 --> 00:58:10.430
because log space is
enough to write down

00:58:10.430 --> 00:58:11.990
an index of something.

00:58:11.990 --> 00:58:15.830
So this is what you can do
with a bunch of pointers.

00:58:15.830 --> 00:58:20.210
And in order to
make sense of this,

00:58:20.210 --> 00:58:22.370
we have to change the
model of computation.

00:58:22.370 --> 00:58:26.120
Because if we use the ordinary
one-tape Turing machine, just

00:58:26.120 --> 00:58:31.970
scanning across the input,
just reading the input the way

00:58:31.970 --> 00:58:34.580
we've defined it,
would cost space n.

00:58:34.580 --> 00:58:36.650
And so you can't
even read the input

00:58:36.650 --> 00:58:40.110
if you have less than n space
available, like log space.

00:58:40.110 --> 00:58:43.360
So we're going to introduce
a different model just

00:58:43.360 --> 00:58:44.860
to allow us to define this.

00:58:44.860 --> 00:58:46.870
And that's a model
where it's going

00:58:46.870 --> 00:58:51.710
to have two tapes, where the
part that contains the input

00:58:51.710 --> 00:58:52.945
doesn't count.

00:58:52.945 --> 00:58:57.220
And in order to make sure
it's not being cheated,

00:58:57.220 --> 00:59:01.068
the input tape is
going to be read only,

00:59:01.068 --> 00:59:02.860
but it doesn't count
toward the space used.

00:59:02.860 --> 00:59:10.092
Only the work tape, which
now can be written or read,

00:59:10.092 --> 00:59:11.800
is going to count
toward the space bound.

00:59:14.720 --> 00:59:17.780
So now what we're
going to define is,

00:59:17.780 --> 00:59:24.620
using this definition
for our space complexity,

00:59:24.620 --> 00:59:28.550
we'll define SPACE
log n, the things

00:59:28.550 --> 00:59:30.800
that you can do if you have
only a log amount of space

00:59:30.800 --> 00:59:34.700
here, on the work tape.

00:59:34.700 --> 00:59:36.860
So the length of the input is n.

00:59:36.860 --> 00:59:44.250
The length of the work
tape is order log n.

00:59:44.250 --> 00:59:49.110
So we have the deterministic
and nondeterministic associated

00:59:49.110 --> 00:59:50.610
classes--

00:59:50.610 --> 00:59:52.920
SPACE log n and NSPACE log n.

00:59:52.920 --> 00:59:55.260
We're calling it L and NL--

00:59:55.260 --> 00:59:59.430
log space and
nondeterministic log space.

00:59:59.430 --> 01:00:01.140
And as I said, that's
just enough space

01:00:01.140 --> 01:00:03.240
to write down some
pointers into the input.

01:00:03.240 --> 01:00:04.695
And let's do some
quick examples.

01:00:08.090 --> 01:00:12.040
So if you take the language of
palindromes, essentially, or ww

01:00:12.040 --> 01:00:17.930
reverse, that's in log space.

01:00:17.930 --> 01:00:19.810
So here is a string.

01:00:19.810 --> 01:00:23.650
Here's a string
that's in ww reverse.

01:00:23.650 --> 01:00:28.600
And the ordinary
way you might use

01:00:28.600 --> 01:00:32.590
to test whether a string is
of this form in ww reverse

01:00:32.590 --> 01:00:35.663
might be to cross off
corresponding locations here.

01:00:35.663 --> 01:00:36.580
But you can't do that.

01:00:36.580 --> 01:00:38.390
It's a read-only input tape.

01:00:38.390 --> 01:00:41.500
So you have to somehow avoid
writing on the input tape,

01:00:41.500 --> 01:00:44.110
but still testing whether
you're in this language.

01:00:44.110 --> 01:00:45.460
It's not hard to do.

01:00:45.460 --> 01:00:49.210
You can use the work tape
just to keep track of where

01:00:49.210 --> 01:00:51.700
your pointers would be.

01:00:51.700 --> 01:00:56.260
And in so doing,
you can just make

01:00:56.260 --> 01:01:00.640
sure you're matching off
corresponding locations

01:01:00.640 --> 01:01:03.440
with each other in the input.

01:01:03.440 --> 01:01:05.590
So log space, because
of its ability

01:01:05.590 --> 01:01:08.380
to store some fixed
number of pointers,

01:01:08.380 --> 01:01:12.240
gives you enough to test
membership in this language.

01:01:12.240 --> 01:01:16.910
So this is in
solvable in log space.

01:01:16.910 --> 01:01:19.550
The path problem, which
we've seen before--

01:01:19.550 --> 01:01:23.210
you're given a graph, and a
start node, and an ending node,

01:01:23.210 --> 01:01:24.710
or a start and a target.

01:01:24.710 --> 01:01:27.580
You're given a graph
of an s and t--

01:01:27.580 --> 01:01:28.780
it's a directed a graph--

01:01:28.780 --> 01:01:32.200
and can I know, can
I get from s to t?

01:01:32.200 --> 01:01:37.780
So that problem is solvable
in nondeterministic log space

01:01:37.780 --> 01:01:44.200
because the way we would do
that, not writing this down

01:01:44.200 --> 01:01:47.470
in any detail,
but what you would

01:01:47.470 --> 01:01:52.270
do in your nondeterministic
log space machine--

01:01:52.270 --> 01:01:56.290
you have your input graph
written here in the input,

01:01:56.290 --> 01:02:02.650
and you're just going to guess
the sequence of nodes one

01:02:02.650 --> 01:02:09.340
by one, which takes you from the
start node to the target node.

01:02:09.340 --> 01:02:12.040
You're not going to write down
that whole sequence in advance

01:02:12.040 --> 01:02:15.970
because that cost you way
too much space to write down.

01:02:15.970 --> 01:02:17.650
The only space that
you're going to use

01:02:17.650 --> 01:02:20.590
is to remember the current
location where you're sitting.

01:02:20.590 --> 01:02:23.320
So you start out, you
write down on the work tape

01:02:23.320 --> 01:02:24.580
the start node.

01:02:24.580 --> 01:02:26.920
Then you're going to
nondeterministically pick

01:02:26.920 --> 01:02:29.650
one of the outgoing
edges from the start node

01:02:29.650 --> 01:02:33.670
and look at its associated node,
and replace that on your work

01:02:33.670 --> 01:02:36.790
tape, and keep repeating that.

01:02:36.790 --> 01:02:42.190
If you ever get to the node
t, then you can accept.

01:02:42.190 --> 01:02:43.940
And you also have to
be a little careful--

01:02:43.940 --> 01:02:46.240
I don't have this on the slide.

01:02:46.240 --> 01:02:53.270
You also have to make sure that
if the graph has a loop in it,

01:02:53.270 --> 01:02:56.370
because that's not allowed
in space complexity,

01:02:56.370 --> 01:02:58.730
so you're going to need
also a counter to make sure

01:02:58.730 --> 01:03:03.550
that if you count up to--

01:03:03.550 --> 01:03:05.510
you've gone through
a number of nodes

01:03:05.510 --> 01:03:08.480
which exceeds the total
number of nodes in the graph,

01:03:08.480 --> 01:03:11.510
then you can shut down that
branch of the nondeterministic,

01:03:11.510 --> 01:03:19.560
because it's just
going in a loop.

01:03:19.560 --> 01:03:22.020
If there's any path
that connects s to t,

01:03:22.020 --> 01:03:23.748
there's certainly
going to be a path that

01:03:23.748 --> 01:03:26.040
has the most of the number
of nodes of the graph in it.

01:03:28.730 --> 01:03:30.380
So path is in NL.

01:03:30.380 --> 01:03:34.250
This language here
is in L. What's

01:03:34.250 --> 01:03:36.470
the relationship
between L and NL?

01:03:36.470 --> 01:03:38.780
Well, certainly the
deterministic class

01:03:38.780 --> 01:03:41.150
is contained in the
nondeterministic class.

01:03:41.150 --> 01:03:43.320
That's all that's known.

01:03:43.320 --> 01:03:47.400
Whether these two collapse down
to be the same is unsolved.

01:03:47.400 --> 01:03:49.800
And so we're going to spend
a little time next lecture

01:03:49.800 --> 01:03:52.350
exploring this.

01:03:52.350 --> 01:03:58.680
But let's first look at some
of the basic facts about log

01:03:58.680 --> 01:04:02.595
space, sort of setting
ourselves up for next lecture.

01:04:06.710 --> 01:04:08.920
So first of all,
anything that you

01:04:08.920 --> 01:04:12.130
can do in log space you
can do in polynomial time--

01:04:12.130 --> 01:04:15.370
in a sense kind of
trivially, and in a sense

01:04:15.370 --> 01:04:18.130
we almost kind of really
proved this already.

01:04:18.130 --> 01:04:21.610
Because if you remember,
we said that anything

01:04:21.610 --> 01:04:23.800
that you can do in a
certain amount of space

01:04:23.800 --> 01:04:33.970
you can do in time that's
exponential in the amount

01:04:33.970 --> 01:04:36.430
of space, in the
corresponding amount of space.

01:04:36.430 --> 01:04:40.670
So going from space to time
blows you up exponentially.

01:04:40.670 --> 01:04:45.910
And the exponential of
order log n is polynomial.

01:04:45.910 --> 01:04:48.460
So the way we're
going to prove this--

01:04:48.460 --> 01:04:50.650
and again, we kind of
proved this already

01:04:50.650 --> 01:04:55.840
but let's just go through it
again, specific to log space.

01:04:55.840 --> 01:04:58.600
We'll say-- and this is going
to be a useful definition for us

01:04:58.600 --> 01:05:00.130
anyway--

01:05:00.130 --> 01:05:02.860
a configuration for M on w.

01:05:02.860 --> 01:05:05.830
So we also already talked
about the configuration

01:05:05.830 --> 01:05:07.960
of the Turing machine
M, which is just

01:05:07.960 --> 01:05:12.670
a snapshot, which is the
tape, the state, and the head

01:05:12.670 --> 01:05:14.410
position.

01:05:14.410 --> 01:05:17.980
When we have an
input, which is sort

01:05:17.980 --> 01:05:20.650
of a read-only
input, which is not

01:05:20.650 --> 01:05:22.510
being counted
toward the space, we

01:05:22.510 --> 01:05:26.170
don't include that
in the configuration.

01:05:26.170 --> 01:05:30.250
We just say it's a configuration
of M on that particular input,

01:05:30.250 --> 01:05:32.620
but we're going to be
counting configurations.

01:05:32.620 --> 01:05:35.320
And I don't want to count all
the different inputs as well.

01:05:35.320 --> 01:05:36.970
I'm going to fix
the input and count

01:05:36.970 --> 01:05:39.385
all of the configurations
relative to that input.

01:05:42.720 --> 01:05:45.780
And so the number of
such configurations

01:05:45.780 --> 01:05:49.530
is just simply going to
be the number of states

01:05:49.530 --> 01:05:52.860
times the number of head
positions for the two heads

01:05:52.860 --> 01:05:56.580
now, times the number of
possible tape contents, which

01:05:56.580 --> 01:05:58.620
is, as I mentioned,
here is a number

01:05:58.620 --> 01:06:00.790
of different possible
tape contents.

01:06:00.790 --> 01:06:05.190
It's d, which is the tape
alphabet, to the order log n.

01:06:05.190 --> 01:06:07.530
And that's just going to
be n to the k for some k.

01:06:07.530 --> 01:06:09.120
So it's going to be polynomial.

01:06:09.120 --> 01:06:12.270
So that tells us that
because the total number

01:06:12.270 --> 01:06:17.760
of configurations for
M on w is polynomial,

01:06:17.760 --> 01:06:21.510
this machine can only be
running for a polynomial number

01:06:21.510 --> 01:06:22.283
of steps.

01:06:22.283 --> 01:06:23.450
Otherwise, it'll be looping.

01:06:23.450 --> 01:06:25.380
It'll be repeating
a configuration.

01:06:25.380 --> 01:06:28.440
And so therefore, that
machine has to run itself

01:06:28.440 --> 01:06:29.650
in polynomial time.

01:06:29.650 --> 01:06:32.190
So you don't really, in a
sense, have to do any work.

01:06:32.190 --> 01:06:34.680
If a machine is
deterministically

01:06:34.680 --> 01:06:37.020
deciding a language
in log space,

01:06:37.020 --> 01:06:40.085
it's also deterministically
deciding the language

01:06:40.085 --> 01:06:41.460
in polynomial time
because that's

01:06:41.460 --> 01:06:43.080
all the time you
can use when you

01:06:43.080 --> 01:06:46.890
have log space, unless you're
looping, which is not allowed.

01:06:46.890 --> 01:06:49.530
So therefore, the
same machine shows

01:06:49.530 --> 01:06:53.705
that you're also in P. I'll
get to that in a second.

01:06:53.705 --> 01:06:55.830
One thing I forgot to
mention on the previous slide

01:06:55.830 --> 01:06:57.788
when I'm talking about
the model is by the way,

01:06:57.788 --> 01:07:01.020
this model is not
so unreasonable,

01:07:01.020 --> 01:07:03.270
where you have kind
of-- imagine having

01:07:03.270 --> 01:07:08.710
a very large, read-only
input and your local storage

01:07:08.710 --> 01:07:09.560
is much smaller.

01:07:09.560 --> 01:07:13.760
It's much too small to
pull in the entire input.

01:07:13.760 --> 01:07:16.550
The way I used to
explain this years ago

01:07:16.550 --> 01:07:20.790
was your input as a CD-ROM,
which you guys probably barely

01:07:20.790 --> 01:07:22.670
even know what it
is anymore, but you

01:07:22.670 --> 01:07:24.530
used to distribute
software that way.

01:07:24.530 --> 01:07:28.970
So the ROM was on a
DVD or a CD, which

01:07:28.970 --> 01:07:33.020
contained whatever you're trying
to-- like your software you're

01:07:33.020 --> 01:07:34.460
trying to distribute.

01:07:34.460 --> 01:07:37.550
It was some large
thing, relatively,

01:07:37.550 --> 01:07:42.350
and so you imagine having
a smaller amount of memory

01:07:42.350 --> 01:07:43.058
relative to that.

01:07:43.058 --> 01:07:44.642
So you didn't want
to necessarily copy

01:07:44.642 --> 01:07:46.250
that whole thing
into your storage.

01:07:46.250 --> 01:07:49.130
Maybe even a better example
now is you think of the input

01:07:49.130 --> 01:07:52.010
as being the entire internet.

01:07:52.010 --> 01:07:54.080
Obviously, unless
you're Google, you

01:07:54.080 --> 01:07:57.350
can't download
the whole internet

01:07:57.350 --> 01:08:00.610
into your own local
memory, but you

01:08:00.610 --> 01:08:03.220
can have references,
pointers into the input

01:08:03.220 --> 01:08:04.420
into different places.

01:08:04.420 --> 01:08:07.660
That's perhaps more analogous
to this sort of read-only input

01:08:07.660 --> 01:08:10.240
Turing machine model
that I'm describing.

01:08:16.120 --> 01:08:18.160
And there's another fact
that I want to mention,

01:08:18.160 --> 01:08:24.550
is that anything that you can
do in nondeterministic log

01:08:24.550 --> 01:08:28.210
space you can do in
deterministic space,

01:08:28.210 --> 01:08:30.340
but now with the squaring.

01:08:30.340 --> 01:08:32.380
And that's using the same proof.

01:08:32.380 --> 01:08:35.620
That's using Savitch's theorem,
which you have to check also

01:08:35.620 --> 01:08:37.810
works down to log space--

01:08:37.810 --> 01:08:38.439
same proof.

01:08:41.890 --> 01:08:44.080
So anything that you
do nondeterministically

01:08:44.080 --> 01:08:47.170
in log n space you can use
deterministically in log

01:08:47.170 --> 01:08:49.154
squared n space.

01:08:49.154 --> 01:08:51.279
So let me just see if
there's a couple of questions

01:08:51.279 --> 01:08:52.196
I want to answer here.

01:08:55.359 --> 01:09:02.040
The relationship between L and
NL is not known to be strict.

01:09:02.040 --> 01:09:03.510
Nobody knows of an example.

01:09:03.510 --> 01:09:06.790
No one knows whether
they're equal.

01:09:06.790 --> 01:09:16.500
And have people looked at
sublinear time classes?

01:09:16.500 --> 01:09:19.920
Yes, generally when you
have nondeterministic

01:09:19.920 --> 01:09:22.779
or probabilistic-- which
we haven't defined yet,

01:09:22.779 --> 01:09:23.850
but we will--

01:09:23.850 --> 01:09:27.819
people have looked at those
sublinear time classes as well.

01:09:27.819 --> 01:09:29.819
Deterministically, it
doesn't make so much sense

01:09:29.819 --> 01:09:33.270
because then you can't even
talk about the whole input.

01:09:39.029 --> 01:09:40.890
OK, let me move on.

01:09:43.950 --> 01:09:45.069
This is my last slide.

01:09:45.069 --> 01:09:48.359
Let me see if we can do
this before we break.

01:09:48.359 --> 01:09:50.880
Not only is L
contained within P,

01:09:50.880 --> 01:09:52.830
but the much
stronger statement is

01:09:52.830 --> 01:09:57.240
that NL is contained
within P. And for that

01:09:57.240 --> 01:09:59.580
you'll have to do some
work because converting

01:09:59.580 --> 01:10:01.680
your nondeterministic
log space machine

01:10:01.680 --> 01:10:05.670
to a deterministic machine--

01:10:05.670 --> 01:10:09.750
obviously, you're going to
have to change the machine.

01:10:09.750 --> 01:10:11.700
And so we'll introduce
a new method here.

01:10:11.700 --> 01:10:14.670
Maybe we'll quickly go
over this at the beginning

01:10:14.670 --> 01:10:16.995
of the next lecture.

01:10:16.995 --> 01:10:19.950
I don't like rushing
through things at the end.

01:10:19.950 --> 01:10:27.950
But for this, if I'm given a
nondeterministic machine that

01:10:27.950 --> 01:10:31.340
runs in log space, I want
to make a new machine that

01:10:31.340 --> 01:10:33.440
runs in polynomial
time deterministically

01:10:33.440 --> 01:10:34.820
for the same language.

01:10:34.820 --> 01:10:36.320
And I'm going to
define something

01:10:36.320 --> 01:10:41.700
called the "configuration
graph" for M on an input w.

01:10:41.700 --> 01:10:48.780
And that's just you
take M and w, its input,

01:10:48.780 --> 01:10:55.120
and you look at all of the
configurations for M on w--

01:10:55.120 --> 01:10:56.830
actually, configuration--

01:10:56.830 --> 01:11:00.100
actually, that should be
called the "computation graph."

01:11:00.100 --> 01:11:02.800
That's what it's called in
the book, but it's a typo.

01:11:02.800 --> 01:11:04.960
Yeah, I'll fix that next time.

01:11:04.960 --> 01:11:06.040
It doesn't matter.

01:11:06.040 --> 01:11:10.252
Computation graph, configuration
graph, all the same.

01:11:10.252 --> 01:11:12.835
Basically, you're going to take
all of the configurations of M

01:11:12.835 --> 01:11:16.990
on w, of which we
already observed

01:11:16.990 --> 01:11:19.570
are only polynomial in number.

01:11:19.570 --> 01:11:23.320
And they become the
nodes of a graph.

01:11:23.320 --> 01:11:26.470
And the edges connect
two configurations

01:11:26.470 --> 01:11:30.960
if one follows another according
to the rules of the machine.

01:11:30.960 --> 01:11:32.220
So here's a picture.

01:11:32.220 --> 01:11:34.710
This is some graph.

01:11:34.710 --> 01:11:40.570
The nodes of this graph are
the configurations of M on w.

01:11:40.570 --> 01:11:44.860
So each node here
corresponds to a snapshot

01:11:44.860 --> 01:11:52.730
of the machine, a tape contents,
head position, and state.

01:11:52.730 --> 01:11:55.070
So writing down all those
different configurations,

01:11:55.070 --> 01:11:56.870
I connect one to
the other, if I can

01:11:56.870 --> 01:12:02.610
get to C j from C i in one
step legally on the machine.

01:12:02.610 --> 01:12:07.280
And then, the
nondeterministic machine M

01:12:07.280 --> 01:12:11.760
accepts w exactly when
there's a path from the start

01:12:11.760 --> 01:12:15.180
configuration to an
accept configuration.

01:12:15.180 --> 01:12:18.270
Let's assume we have just a
single accept configuration,

01:12:18.270 --> 01:12:23.410
as we argued we can do
one or two lectures back,

01:12:23.410 --> 01:12:24.850
if we clean up the tapes.

01:12:24.850 --> 01:12:31.900
So testing whether you can get
from the start to the accept

01:12:31.900 --> 01:12:36.740
is the same as testing whether
the machine accepts its input.

01:12:36.740 --> 01:12:40.910
And so because we can
test whether there's

01:12:40.910 --> 01:12:45.080
a path in a graph connecting
two nodes in polynomial time,

01:12:45.080 --> 01:12:48.230
we can solve this problem on
this computation/configuration

01:12:48.230 --> 01:12:50.040
graph in polynomial time.

01:12:50.040 --> 01:12:52.730
And so we can figure out whether
the nondeterministic machine

01:12:52.730 --> 01:12:54.145
accepts its input.

01:12:54.145 --> 01:12:56.270
Sorry, that came a little
faster than I like to do,

01:12:56.270 --> 01:12:59.070
so we'll see it again.

01:12:59.070 --> 01:13:01.220
So here's the polynomial
time algorithm.

01:13:01.220 --> 01:13:03.822
You construct the
graph, you accept

01:13:03.822 --> 01:13:05.780
if there's a path from
the start to the accept,

01:13:05.780 --> 01:13:07.072
and you reject if there is not.

01:13:09.800 --> 01:13:14.830
And so that tells us that not
only is L contained within NL,

01:13:14.830 --> 01:13:17.710
but NL itself is also
contained within P.

01:13:17.710 --> 01:13:23.140
So here's a kind of a nice
hierarchy of languages.

01:13:23.140 --> 01:13:25.870
Not only do we not know
whether L equals NL,

01:13:25.870 --> 01:13:28.690
we don't know
whether L equals P.

01:13:28.690 --> 01:13:31.480
It's possible that anything
you can do in polynomial time,

01:13:31.480 --> 01:13:33.790
you can do deterministically
in log space,

01:13:33.790 --> 01:13:35.530
shocking as that
might be, because this

01:13:35.530 --> 01:13:38.080
is a pretty weak class.

01:13:38.080 --> 01:13:40.180
But we don't know how
to prove that there's

01:13:40.180 --> 01:13:44.980
anything different, anything
in P that's not in here.

01:13:44.980 --> 01:13:47.150
Last check in.

01:13:47.150 --> 01:13:49.120
So we showed that PATH is in NL.

01:13:49.120 --> 01:13:51.850
What's the best thing we can do
about the deterministic space

01:13:51.850 --> 01:13:52.990
complexity of PATH?

01:13:52.990 --> 01:13:54.110
So deterministic.

01:13:54.110 --> 01:13:56.050
So this is
nondeterministic log space.

01:13:56.050 --> 01:14:00.640
What can we say
deterministically about PATH?

01:14:00.640 --> 01:14:05.650
Hint-- this should not be
hard if you think back to what

01:14:05.650 --> 01:14:08.200
we've shown very recently.

01:14:13.360 --> 01:14:14.890
Get your check in points.

01:14:14.890 --> 01:14:16.000
Closing up.

01:14:16.000 --> 01:14:17.680
Closing shop here.

01:14:17.680 --> 01:14:18.775
All set, 1, 2, 3.

01:14:21.550 --> 01:14:24.340
Yeah, so the correct answer
is log squared space,

01:14:24.340 --> 01:14:27.180
because this is just
Savitch's theorem.

01:14:27.180 --> 01:14:29.470
We can do it in log space
nondeterministically,

01:14:29.470 --> 01:14:32.700
so you can do it in log squared
space deterministically.

01:14:32.700 --> 01:14:35.430
So this is what we did today.

01:14:38.900 --> 01:14:45.580
And as I mentioned,
I will do this again

01:14:45.580 --> 01:14:48.790
on Tuesday's lecture,
just to recap that.

01:14:48.790 --> 01:14:51.760
All right, so I'll stick around
a little bit for questions.

01:14:51.760 --> 01:14:56.470
And someone's asking me
about the nomenclature.

01:14:56.470 --> 01:14:58.320
Why is it L and not L space?

01:15:03.160 --> 01:15:06.280
Because people don't
usually talk about L time.

01:15:06.280 --> 01:15:07.890
So L is sort of--

01:15:07.890 --> 01:15:11.010
everybody knows the only
reasonable option is space,

01:15:11.010 --> 01:15:14.550
so people just say L and NL.

01:15:14.550 --> 01:15:23.730
I mean, some of these names have
a little bit evolved over time.

01:15:23.730 --> 01:15:26.115
And even now, some
people talk about--

01:15:29.210 --> 01:15:32.630
I call "time classes," some
people call "detime classes."

01:15:38.160 --> 01:15:41.890
You can make different
choices there.

01:15:41.890 --> 01:15:42.390
Let's see.

01:15:44.775 --> 01:15:45.275
Good.

01:15:47.780 --> 01:15:50.900
Why does Savitch's
theorem work for log n?

01:15:50.900 --> 01:15:54.260
You have to look back
and see what you needed.

01:15:54.260 --> 01:15:56.360
And all you needed
to be able to do

01:15:56.360 --> 01:16:03.720
was to write down
the configurations.

01:16:03.720 --> 01:16:07.053
And if you look back at
how Savitch's film works,

01:16:07.053 --> 01:16:09.220
you're just needing to write
down the configuration.

01:16:09.220 --> 01:16:11.543
So the deterministic
machine can write down

01:16:11.543 --> 01:16:13.710
the configurations for the
nondeterministic machine.

01:16:13.710 --> 01:16:16.450
They take exactly the same size.

01:16:16.450 --> 01:16:18.360
And then you look
at the recursion.

01:16:18.360 --> 01:16:20.910
And the depth of
the recursion is

01:16:20.910 --> 01:16:25.683
going to be exponential in the
size of the configurations.

01:16:25.683 --> 01:16:27.850
And so you're going to end
up with a squaring again.

01:16:27.850 --> 01:16:31.140
You have to go back and
just rethink that proof.

01:16:31.140 --> 01:16:34.410
And you'll see nowhere did it
need a linear amount of space.

01:16:34.410 --> 01:16:35.730
It works down to--

01:16:35.730 --> 01:16:38.100
it actually does not
work for less than log n.

01:16:38.100 --> 01:16:41.680
Log n is sort of the
lower threshold there.

01:16:41.680 --> 01:16:44.730
And the reason for that
is because you also

01:16:44.730 --> 01:16:48.510
need to store the
input location,

01:16:48.510 --> 01:16:50.040
and that already
takes log space.

01:16:53.920 --> 01:16:56.460
The tape heads-- the
tape heads already kind

01:16:56.460 --> 01:17:01.390
have kind of a log
space aspect to them.

01:17:01.390 --> 01:17:04.740
And so if you're going to
use less than log space,

01:17:04.740 --> 01:17:08.550
then funky things happen
with storing the tape heads.

01:17:08.550 --> 01:17:11.220
And so less than
log space usually

01:17:11.220 --> 01:17:14.550
turns out not to be
interesting, very

01:17:14.550 --> 01:17:17.940
specific to Turing machines
and not general models.

01:17:21.170 --> 01:17:26.540
Yeah, so somebody's asking,
suppose in the reduction

01:17:26.540 --> 01:17:29.420
to generalized
geography from TQBF,

01:17:29.420 --> 01:17:32.745
if the formula had
two Exists in a row,

01:17:32.745 --> 01:17:35.120
then you would do kind of the
natural thing in the graph.

01:17:35.120 --> 01:17:38.150
Instead of having that spacer
edge between the two diamonds,

01:17:38.150 --> 01:17:40.640
you could just have one
diamond connecting directly

01:17:40.640 --> 01:17:43.250
to the other diamond
without a spacer edge.

01:17:43.250 --> 01:17:48.560
And that would give you
the effect of not switching

01:17:48.560 --> 01:17:50.820
whose turn it is.

01:17:50.820 --> 01:17:54.360
Somebody is asking me
just a general question,

01:17:54.360 --> 01:17:57.420
are people thinking about
these open problems?

01:18:02.630 --> 01:18:05.530
I don't know.

01:18:05.530 --> 01:18:09.760
People don't say.

01:18:09.760 --> 01:18:13.120
There was a lot of work
on problems related,

01:18:13.120 --> 01:18:17.530
that seemed to be related to
those many open questions,

01:18:17.530 --> 01:18:22.210
like P versus NP, L versus
NL or L versus P and so on,

01:18:22.210 --> 01:18:24.200
P versus PSPACE.

01:18:24.200 --> 01:18:26.200
We'll talk a little bit
more about some of that.

01:18:26.200 --> 01:18:27.430
There's some very
interesting things

01:18:27.430 --> 01:18:28.550
that have been developed.

01:18:28.550 --> 01:18:30.760
I think there's a sense
within the community

01:18:30.760 --> 01:18:34.150
that people are
stuck, and you're

01:18:34.150 --> 01:18:37.750
going to need some
sort of major new idea

01:18:37.750 --> 01:18:39.530
in order to push
the thing forward.

01:18:39.530 --> 01:18:44.195
So I don't know how many people
are still thinking about them.

01:18:44.195 --> 01:18:45.570
I hope people are
because I would

01:18:45.570 --> 01:18:50.130
like to see the answer at
some point, or get the answer.

01:18:50.130 --> 01:18:51.810
I think about them
sometimes myself,

01:18:51.810 --> 01:18:57.360
but one has to acknowledge
chances of success

01:18:57.360 --> 01:18:57.990
are not high.

01:19:03.790 --> 01:19:08.320
So we're a little after past
the end of the hour here.

01:19:08.320 --> 01:19:09.820
Unless there's any
other questions,

01:19:09.820 --> 01:19:12.112
if I didn't answer your
question, I may have missed it,

01:19:12.112 --> 01:19:15.050
so you can ask again.

01:19:15.050 --> 01:19:19.000
But otherwise, I'm going to
close this, close the session

01:19:19.000 --> 01:19:20.080
here.

01:19:20.080 --> 01:19:21.940
OK, bye-bye all.

01:19:21.940 --> 01:19:22.940
Have a good weekend.

01:19:22.940 --> 01:19:24.560
See you next week.

01:19:24.560 --> 01:19:26.160
Take care.