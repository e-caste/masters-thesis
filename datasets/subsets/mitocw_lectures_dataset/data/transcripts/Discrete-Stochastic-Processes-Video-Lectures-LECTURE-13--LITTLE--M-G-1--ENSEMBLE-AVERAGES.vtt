WEBVTT

00:00:00.530 --> 00:00:02.960
The following content is
provided under a Creative

00:00:02.960 --> 00:00:04.370
Commons license.

00:00:04.370 --> 00:00:07.410
Your support will help MIT
OpenCourseWare continue to

00:00:07.410 --> 00:00:11.060
offer high quality educational
resources for free.

00:00:11.060 --> 00:00:13.960
To make a donation or view
additional materials from

00:00:13.960 --> 00:00:19.790
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:19.790 --> 00:00:21.040
ocw.mit.edu.

00:00:23.292 --> 00:00:24.170
PROFESSOR: OK.

00:00:24.170 --> 00:00:27.390
So let's get started.

00:00:27.390 --> 00:00:32.060
We want to first review Wald's
equality a little bit.

00:00:32.060 --> 00:00:36.230
Wald's equality is very
tricky thing.

00:00:36.230 --> 00:00:40.590
If you think you understand
it, you will go along.

00:00:40.590 --> 00:00:44.310
And at some point, you will be
using it and you will say, I

00:00:44.310 --> 00:00:47.040
don't understand
what this says.

00:00:47.040 --> 00:00:50.340
And that will happen
for a long time.

00:00:50.340 --> 00:00:52.870
It still happens to
me occasionally.

00:00:52.870 --> 00:00:55.000
What happens is you
work with it for

00:00:55.000 --> 00:00:57.420
longer and longer times.

00:00:57.420 --> 00:01:02.280
The periods when it becomes
confusing become rarer.

00:01:02.280 --> 00:01:04.190
And the expected time
to straighten

00:01:04.190 --> 00:01:06.045
it out becomes smaller.

00:01:08.810 --> 00:01:12.230
It is a strange kind
of result.

00:01:12.230 --> 00:01:18.700
So we started out with a
stopping trial definition.

00:01:18.700 --> 00:01:26.500
J is a stopping trial for a
sequence of random variables.

00:01:26.500 --> 00:01:30.600
If it's a random variable and
it has the property that for

00:01:30.600 --> 00:01:34.460
each n greater than or equal
to 1, the indicator random

00:01:34.460 --> 00:01:38.770
variable indicator of J
equals n is a function

00:01:38.770 --> 00:01:41.200
of X1 to X sub n.

00:01:41.200 --> 00:01:47.840
In other words, the decision of
whether to stop at time n

00:01:47.840 --> 00:01:51.210
is a function of 1 up to n.

00:01:54.437 --> 00:01:58.040
A possibly effective stopping
trial is the same, except that

00:01:58.040 --> 00:02:00.000
might be a defective
random variable.

00:02:00.000 --> 00:02:02.780
And the reason you want to have
possibly defective random

00:02:02.780 --> 00:02:06.860
variables is that before you
start analyzing something that

00:02:06.860 --> 00:02:10.150
might be a stopping rule, you
generally have no way of

00:02:10.150 --> 00:02:15.720
knowing whether that actually is
a stopping rule or whether

00:02:15.720 --> 00:02:17.250
it's a detective
stopping rule.

00:02:17.250 --> 00:02:20.740
So you might as well just say
it's a defective stopping rule

00:02:20.740 --> 00:02:24.680
to start with and show
that it's not.

00:02:24.680 --> 00:02:28.930
Then from that, we went on to
Wald's equality which added

00:02:28.930 --> 00:02:33.690
the condition that X sub n that
this is based on is a

00:02:33.690 --> 00:02:35.930
sequence of IID random
variables.

00:02:35.930 --> 00:02:38.450
To be a stopping trial,
you don't

00:02:38.450 --> 00:02:40.240
need IID random variables.

00:02:40.240 --> 00:02:43.760
You don't need any restriction
at all, other than the fact

00:02:43.760 --> 00:02:46.960
that you can make a decision on
when to stop based on what

00:02:46.960 --> 00:02:49.310
you've already seen.

00:02:49.310 --> 00:02:51.030
That's the only condition
there.

00:02:51.030 --> 00:02:55.270
Wald's equality is based on this
extra condition that the

00:02:55.270 --> 00:02:58.030
random variables are IID.

00:02:58.030 --> 00:03:01.710
Each of them, with
some mean, X bar.

00:03:01.710 --> 00:03:06.880
If J is a stopping trial and as
the expected value of J is

00:03:06.880 --> 00:03:12.570
less than infinity, then the
sum S sub J at the stopping

00:03:12.570 --> 00:03:17.380
trial, J, satisfies this
relationship here.

00:03:17.380 --> 00:03:20.040
And remember we proved
that last time.

00:03:20.040 --> 00:03:25.896
And the key to proving it,
the hard part of it--

00:03:25.896 --> 00:03:28.880
well, it's not hard
if you see it.

00:03:28.880 --> 00:03:35.810
But what's difficult is when you
start looking at how you

00:03:35.810 --> 00:03:40.820
find the expected value of S
sub J that's equal to a sum

00:03:40.820 --> 00:03:48.360
over n of X sub n times the
indicator function of J being

00:03:48.360 --> 00:03:50.910
greater than or equal to n.

00:03:50.910 --> 00:03:56.810
Now the condition here is that
this indicator at J equals n

00:03:56.810 --> 00:03:59.810
is a function of these
quantities here.

00:03:59.810 --> 00:04:04.790
When you add the IID quantity
down here, what you find then

00:04:04.790 --> 00:04:09.180
is the indicator function for J
greater than or equal to n.

00:04:09.180 --> 00:04:13.160
It's also the indicator function
for J 1 minus the

00:04:13.160 --> 00:04:17.860
indicator function for
J less than n.

00:04:17.860 --> 00:04:25.090
It's independent of X1 up to
X sub blah, blah, blah.

00:04:25.090 --> 00:04:30.430
That indicator random variable
is then a function only of X1

00:04:30.430 --> 00:04:35.770
up to X sub n minus 1, because
it's 1 minus the indicator of

00:04:35.770 --> 00:04:39.190
J less than or equal
to n minus 1.

00:04:39.190 --> 00:04:46.890
J less than n, which means that
X1 up to X n minus 1 is

00:04:46.890 --> 00:04:49.090
independent of Xn.

00:04:49.090 --> 00:05:01.050
And X1 up to X n minus 1 is what
determines this indicator

00:05:01.050 --> 00:05:04.770
function J less than n.

00:05:04.770 --> 00:05:08.870
It's the J less than n
which is important.

00:05:08.870 --> 00:05:14.730
So we got that Wald's
equality.

00:05:14.730 --> 00:05:18.750
What I want to do today to start
off with is to do the

00:05:18.750 --> 00:05:23.350
elementary renewal theorem,
which is a strange result.

00:05:23.350 --> 00:05:27.380
Wald's equality, you can use it
to determine the expected

00:05:27.380 --> 00:05:29.140
value of N of t.

00:05:29.140 --> 00:05:31.300
Now why do we want to determine
the expected

00:05:31.300 --> 00:05:33.220
value of N of t?

00:05:33.220 --> 00:05:38.450
We already have shown in great
generality that there's a very

00:05:38.450 --> 00:05:44.140
nice, with probability, one type
limit theorem associated

00:05:44.140 --> 00:05:45.570
with N of t over t.

00:05:45.570 --> 00:05:49.310
We know that N of t over
t approaches t

00:05:49.310 --> 00:05:50.670
with probability 1.

00:05:50.670 --> 00:05:53.270
Namely, all the sample
functions, except a set of

00:05:53.270 --> 00:05:57.330
probability 0, all approach
this same

00:05:57.330 --> 00:05:59.430
constant, 1 over X bar.

00:05:59.430 --> 00:06:02.530
So it seems that we know
everything we want to know

00:06:02.530 --> 00:06:06.360
about the expected value of
N of t, about N of t, and

00:06:06.360 --> 00:06:08.220
everything else.

00:06:08.220 --> 00:06:10.470
But no.

00:06:10.470 --> 00:06:12.370
And there are two reasons
why you want to do

00:06:12.370 --> 00:06:14.180
something more than that.

00:06:14.180 --> 00:06:25.110
One of them is that very often
you want to know how N of t

00:06:25.110 --> 00:06:29.900
over t approaches the limit
of 1 over X bar.

00:06:29.900 --> 00:06:33.430
The other is that sometimes you
really are interested in,

00:06:33.430 --> 00:06:37.880
what is N of t at some
finite value of t?

00:06:37.880 --> 00:06:40.830
N of t is a random variable,
some finite value of t.

00:06:40.830 --> 00:06:42.590
So you can't evaluate it.

00:06:42.590 --> 00:06:44.460
But at least you would
like to know what its

00:06:44.460 --> 00:06:45.690
expected value is.

00:06:45.690 --> 00:06:48.420
You might want to know what
it's variance is too.

00:06:48.420 --> 00:06:52.880
But people who study renewal
theory have spent an enormous

00:06:52.880 --> 00:06:55.960
amount of time on trying
to find the expected

00:06:55.960 --> 00:06:57.940
value of N of t.

00:06:57.940 --> 00:07:03.120
It's the basic problem that
people work on all the time.

00:07:03.120 --> 00:07:12.490
The elementary renewal theorem
is something which says a

00:07:12.490 --> 00:07:13.940
little more for finite times.

00:07:16.700 --> 00:07:20.870
And it actually says the
expected value of N of t over

00:07:20.870 --> 00:07:25.810
t and the limit is equal
to 1 over X bar.

00:07:25.810 --> 00:07:29.480
Sounds like much less than
what we've done before.

00:07:29.480 --> 00:07:35.080
And perhaps this is because this
was a computational thing

00:07:35.080 --> 00:07:37.850
that people could do without
computers, before computers

00:07:37.850 --> 00:07:39.630
came along.

00:07:39.630 --> 00:07:43.990
And all the work on renewal
theory went on basically from

00:07:43.990 --> 00:07:46.900
1900 until about 1970.

00:07:46.900 --> 00:07:49.245
People didn't have any computers
to compute things.

00:07:53.250 --> 00:07:56.620
And all the mathematicians who
were interested in this field

00:07:56.620 --> 00:07:59.270
really loved to compute
ugly things.

00:07:59.270 --> 00:08:01.850
And they computed ugly
things all the time.

00:08:01.850 --> 00:08:05.430
And the expected value of N of
t was one of the ugly things

00:08:05.430 --> 00:08:07.350
that they could really
do a lot with.

00:08:07.350 --> 00:08:10.440
So it probably has more
importance in this field than

00:08:10.440 --> 00:08:12.200
it deserves.

00:08:12.200 --> 00:08:14.830
But it does have some
importance.

00:08:14.830 --> 00:08:19.080
Anyway, what we want to do is
to get some idea of why this

00:08:19.080 --> 00:08:21.240
elementary renewal
theorem is true.

00:08:21.240 --> 00:08:24.870
Later on we will study how to
actually find the expected

00:08:24.870 --> 00:08:27.230
value of N of t.

00:08:27.230 --> 00:08:29.870
N of t is the number of arrivals
that have occurred up

00:08:29.870 --> 00:08:32.820
to and including t.

00:08:32.820 --> 00:08:37.110
So N of t plus 1 is the
number of the first

00:08:37.110 --> 00:08:44.000
arrival after t since--

00:08:44.000 --> 00:08:45.900
that should be a t there--

00:08:45.900 --> 00:08:49.930
the expected value of N of t is
finite, the expected value

00:08:49.930 --> 00:08:52.740
J is also finite.

00:08:52.740 --> 00:08:57.800
In other words, we're defining
J to be N of t plus 1.

00:08:57.800 --> 00:09:03.640
We want to show the J is
actually a stopping trial.

00:09:03.640 --> 00:09:07.430
And therefore we can use
Wald's equality on it.

00:09:07.430 --> 00:09:09.110
Let's stop and think
for a minute.

00:09:09.110 --> 00:09:16.530
Why don't we just define a
stopping trial to be the

00:09:16.530 --> 00:09:21.370
number of arrivals that have
occurred up until time t?

00:09:21.370 --> 00:09:22.770
What's the matter with that?

00:09:27.620 --> 00:09:33.990
If I let you observe a sequence
of these IID random

00:09:33.990 --> 00:09:36.620
variables, the first
inter-arrival interval, the

00:09:36.620 --> 00:09:40.770
second inter-arrival interval,
the third inter-arrival

00:09:40.770 --> 00:09:47.600
interval, and so forth, and I
say stop when you have the

00:09:47.600 --> 00:09:51.340
last dozen that's less than t.

00:09:51.340 --> 00:09:56.330
The question is, is that
a stopping trial?

00:09:56.330 --> 00:09:59.750
You have to be able to determine
that just from what

00:09:59.750 --> 00:10:03.810
you've seen up until
the present.

00:10:03.810 --> 00:10:06.750
But when you see that last
arrival, there's no way you

00:10:06.750 --> 00:10:10.110
know that it's the last arrival
less than t unless you

00:10:10.110 --> 00:10:13.400
see the arrival after that,
also to see whether that's

00:10:13.400 --> 00:10:14.680
greater than t.

00:10:14.680 --> 00:10:19.640
So the only way you can define
a stopping trial of this form

00:10:19.640 --> 00:10:24.240
is to define the stopping trial
not at N of t, but of N

00:10:24.240 --> 00:10:26.560
of t plus 1.

00:10:26.560 --> 00:10:33.130
So now we want to apply Wald's
equality to the expected value

00:10:33.130 --> 00:10:37.540
of the time at which N
of t plus 1 arises.

00:10:37.540 --> 00:10:40.650
Do you see now why we want to
call this a stopping trial

00:10:40.650 --> 00:10:42.710
instead of a stopping time?

00:10:42.710 --> 00:10:45.810
If you call that a stopping
time, you want to know what

00:10:45.810 --> 00:10:47.860
you were doing at this point.

00:10:47.860 --> 00:10:51.470
Because the stopping trial says
you're looking at the

00:10:51.470 --> 00:10:57.030
first arrival that occurs
after time t.

00:10:57.030 --> 00:10:58.840
Then you're looking at
the time at which

00:10:58.840 --> 00:11:00.240
that arrival occurs.

00:11:00.240 --> 00:11:05.900
Wald's equality says the
expected value of that time is

00:11:05.900 --> 00:11:10.870
equal to the expected value of
the inter-arrival time times

00:11:10.870 --> 00:11:14.790
the expected value of J.
J is a stopping trial.

00:11:14.790 --> 00:11:18.210
The expected value
of J is just--

00:11:18.210 --> 00:11:19.970
J is N of t plus 1.

00:11:19.970 --> 00:11:25.240
So that's expected value of
N of t plus 1 times X bar.

00:11:25.240 --> 00:11:27.120
That's simple.

00:11:27.120 --> 00:11:31.280
It's simple until you try to
recreate that argument.

00:11:31.280 --> 00:11:35.660
I would suggest to all of you
that sometime later today you

00:11:35.660 --> 00:11:37.905
go back and try to recreate
this argument.

00:11:37.905 --> 00:11:40.820
And if you can do it, then
you understand it.

00:11:40.820 --> 00:11:43.980
If you can't, think about
it a little more.

00:11:43.980 --> 00:11:45.715
Because it is deceptively
simple.

00:11:48.620 --> 00:11:52.290
So that was a relationship
we had.

00:11:52.290 --> 00:11:55.160
Wald's equality then is
relating two unknown

00:11:55.160 --> 00:11:55.770
quantities.

00:11:55.770 --> 00:11:59.250
It's relating the expected
value of N of t with the

00:11:59.250 --> 00:12:05.560
expected value of the first
arrival time after t.

00:12:05.560 --> 00:12:07.710
That's one of the troubles
with Wald's equality.

00:12:07.710 --> 00:12:11.410
It relates two things that,
neither of which you know in

00:12:11.410 --> 00:12:12.400
many cases.

00:12:12.400 --> 00:12:14.440
There are many situations
in which you do

00:12:14.440 --> 00:12:15.870
know one or the other.

00:12:15.870 --> 00:12:18.500
We talked about one last time.

00:12:18.500 --> 00:12:22.250
But in most of them, you don't
know either of them.

00:12:22.250 --> 00:12:24.190
So it doesn't help
you immediately.

00:12:24.190 --> 00:12:26.560
You have to find
something else.

00:12:26.560 --> 00:12:30.820
So what we're going to do here
is say, well we can't find

00:12:30.820 --> 00:12:32.880
expected value of N
of t from this.

00:12:32.880 --> 00:12:34.570
But we can at least bound it.

00:12:34.570 --> 00:12:39.330
And we can bound it by saying
that S sub N of t plus 1.

00:12:39.330 --> 00:12:43.050
This is the time of the
first arrival after t.

00:12:43.050 --> 00:12:46.750
The first arrival after t has
to be at a time greater than

00:12:46.750 --> 00:12:48.000
or equal to t.

00:12:48.000 --> 00:12:53.450
So expected value of S sub N
of t plus 1 also is greater

00:12:53.450 --> 00:12:55.130
than or equal to t.

00:12:55.130 --> 00:13:00.810
So expected value of N of t,
solving this equation is

00:13:00.810 --> 00:13:06.960
expected value of S sub N of t
plus 1 over X bar minus 1.

00:13:06.960 --> 00:13:10.900
And then you lower bound
expected value of this first

00:13:10.900 --> 00:13:14.330
arrival after t by t.

00:13:14.330 --> 00:13:18.740
So the expected value of N of
t has to be greater than t

00:13:18.740 --> 00:13:22.140
over X bar minus 1.

00:13:22.140 --> 00:13:26.010
Well this seems to be useful,
because if what you're

00:13:26.010 --> 00:13:29.850
interested in is the expected
value of N of t over t.

00:13:29.850 --> 00:13:31.670
And that's what we're interested
in for the

00:13:31.670 --> 00:13:35.030
elementary renewal theorem.

00:13:35.030 --> 00:13:39.240
You're saying that that's
greater than 1 over X bar

00:13:39.240 --> 00:13:41.280
minus 1 over t.

00:13:41.280 --> 00:13:45.555
And when t gets large, that 1
over t term gets very small.

00:13:50.920 --> 00:13:54.020
What that means is you have a
lower bound on expected value

00:13:54.020 --> 00:14:00.090
of N of t, which is going
to 1 over X bar.

00:14:00.090 --> 00:14:03.250
The elementary renewal theorem
then says, let X bar be the

00:14:03.250 --> 00:14:04.500
mean inter-renewal.

00:14:06.250 --> 00:14:10.180
Then the limit of t approaches
infinity of the expected value

00:14:10.180 --> 00:14:14.300
of N of t over t is equal
to 1 over X bar.

00:14:14.300 --> 00:14:16.990
Very weak result.

00:14:16.990 --> 00:14:21.030
At least it seems to be
a very weak result.

00:14:21.030 --> 00:14:25.760
But we need an upper bound on
the expected value of N of t.

00:14:25.760 --> 00:14:29.180
We don't have any upper bound
on this quantity here.

00:14:29.180 --> 00:14:31.150
Because you remember these--

00:14:35.910 --> 00:14:46.860
Actually S sub N of t plus 1
minus t is this residual

00:14:46.860 --> 00:14:48.570
life at time t.

00:14:48.570 --> 00:14:51.490
And we found that the residual
life at time t can be pretty

00:14:51.490 --> 00:14:53.230
badly behaved.

00:14:53.230 --> 00:14:54.140
So we're in trouble.

00:14:54.140 --> 00:14:55.890
So what do we do?

00:14:55.890 --> 00:15:01.560
Well the argument is done
carefully in the notes.

00:15:01.560 --> 00:15:04.240
It's very discouraging to me,
because this should be a

00:15:04.240 --> 00:15:05.750
simple result.

00:15:05.750 --> 00:15:10.600
And here this argument
is incredibly tricky.

00:15:10.600 --> 00:15:15.570
So we're working very hard to
do something that's not--

00:15:15.570 --> 00:15:19.770
Well, it seems like it ought
to be elementary.

00:15:19.770 --> 00:15:23.270
It is an elementary result in
terms of its usefulness.

00:15:23.270 --> 00:15:27.700
It's a very hard result in terms
of trying to prove it.

00:15:27.700 --> 00:15:31.460
So the way you prove this is
first you truncate the random

00:15:31.460 --> 00:15:37.000
variable X. Namely instead of
having a random variable with

00:15:37.000 --> 00:15:41.340
this arbitrary, non-negative
probability distribution, what

00:15:41.340 --> 00:15:45.580
you do is you look at another
random variable, which has the

00:15:45.580 --> 00:15:50.140
same distribution up until some
large value B. And then

00:15:50.140 --> 00:15:52.000
you truncate it at that point.

00:15:52.000 --> 00:15:54.210
So the distribution function
looks like--

00:15:59.970 --> 00:16:03.230
Here's f of x, however
it might look.

00:16:06.460 --> 00:16:08.140
This is 1 here.

00:16:08.140 --> 00:16:10.390
This is supposed to be
going up towards 1.

00:16:13.110 --> 00:16:18.350
And what you do is you truncate
it at some point B.

00:16:18.350 --> 00:16:28.280
So this is a truncated version
which stops at B. And this

00:16:28.280 --> 00:16:34.850
here is the actual Fx of x.

00:16:34.850 --> 00:16:38.010
So first you truncate
the random variable.

00:16:38.010 --> 00:16:43.190
Then you prove the elementary
renewal theorem for that

00:16:43.190 --> 00:16:46.680
truncated random variable,
which is easy.

00:16:46.680 --> 00:16:50.820
Because at that point, the
expected value of S sub N of t

00:16:50.820 --> 00:17:01.080
plus 1 is less than or
equal to t plus B.

00:17:01.080 --> 00:17:03.570
And then the next thing you have
to do is monkey around

00:17:03.570 --> 00:17:11.079
with the difference between
X bar and X tilde bar.

00:17:11.079 --> 00:17:14.520
And you have to go through a
bunch of strange inequalities.

00:17:14.520 --> 00:17:17.880
You have to then let B approach
infinity as t is

00:17:17.880 --> 00:17:20.460
approaching infinity in
just the right way.

00:17:20.460 --> 00:17:24.230
And when you get all of done
doing this, bingo.

00:17:24.230 --> 00:17:26.530
You get the elementary
renewal theorem.

00:17:26.530 --> 00:17:30.230
You see why I don't want to
go through that in class.

00:17:30.230 --> 00:17:35.380
And you see, I hope, why
probably most of you will not

00:17:35.380 --> 00:17:38.400
want to go through it
in detail either.

00:17:38.400 --> 00:17:41.800
Because if you want to learn
how to do truncation

00:17:41.800 --> 00:17:48.090
arguments, this is probably not
the best one to use as a

00:17:48.090 --> 00:17:50.330
way of figuring out
how to do that.

00:17:50.330 --> 00:17:55.170
If you want to learn how to use
truncation arguments, do

00:17:55.170 --> 00:17:58.310
the Weak law of large
numbers where you

00:17:58.310 --> 00:17:59.460
don't have a variance.

00:17:59.460 --> 00:18:02.010
It's done back in chapter one.

00:18:02.010 --> 00:18:05.950
It's a nice relatively simple
argument where you truncate a

00:18:05.950 --> 00:18:06.860
random variable.

00:18:06.860 --> 00:18:08.900
This one is just peculiar.

00:18:14.990 --> 00:18:18.080
We do all of that with stopping
trials as we've

00:18:18.080 --> 00:18:18.950
defined them.

00:18:18.950 --> 00:18:21.890
Very often, and particularly
when you get to queuing

00:18:21.890 --> 00:18:25.730
theory, you want to define
stopping trials in a more

00:18:25.730 --> 00:18:27.260
general way.

00:18:27.260 --> 00:18:28.903
And here's a more general
definition.

00:18:32.300 --> 00:18:36.690
A generalized stopping trial
for a sequence of pairs of

00:18:36.690 --> 00:18:43.840
random variables, X1, V1, X2,
V2, X3, V3, is a positive

00:18:43.840 --> 00:18:47.770
integer random variable such as
for each n greater than or

00:18:47.770 --> 00:18:51.310
equal to 1, the indicator
function, which tells you

00:18:51.310 --> 00:18:55.730
whether to stop or not, is
a function of X1, V1, X2,

00:18:55.730 --> 00:18:58.020
V2, up to Xn, Vn.

00:18:58.020 --> 00:19:01.060
In other words, you don't have
to decide whether to stop or

00:19:01.060 --> 00:19:05.270
not in terms of these random
variables X1 to Xn that you're

00:19:05.270 --> 00:19:06.430
interested in.

00:19:06.430 --> 00:19:09.400
You have this other set of
random variables too.

00:19:09.400 --> 00:19:12.740
Typically in queuing situations,
these other random

00:19:12.740 --> 00:19:14.140
variables that you're
interested

00:19:14.140 --> 00:19:16.170
in are service times.

00:19:16.170 --> 00:19:19.740
And the X's are arrival times.

00:19:19.740 --> 00:19:24.250
And these things are going on
in parallel with each other.

00:19:24.250 --> 00:19:29.950
And still, you can do the same
arguments about stopping

00:19:29.950 --> 00:19:37.630
trials by looking at just the
past history of the input

00:19:37.630 --> 00:19:40.800
random variables and these
other random variables,

00:19:40.800 --> 00:19:43.550
whatever they happen to be.

00:19:43.550 --> 00:19:48.530
Wald's equality then says that
the expected value of S sub n

00:19:48.530 --> 00:19:53.610
is equal to X bar times the
expected value J, where Sn is

00:19:53.610 --> 00:19:55.920
the sum of the X's.

00:19:55.920 --> 00:19:58.130
And Wald's equality holds
by exactly the

00:19:58.130 --> 00:20:00.680
same proof as before.

00:20:00.680 --> 00:20:01.580
There's nothing new.

00:20:01.580 --> 00:20:07.110
You just look at the proof
and you say, OK.

00:20:07.110 --> 00:20:10.560
All these V's are involved
there also.

00:20:10.560 --> 00:20:14.670
You can replace each of Vi in
this definition with a whole

00:20:14.670 --> 00:20:16.170
vector of random variable.

00:20:16.170 --> 00:20:18.420
So you can make this
as general as you

00:20:18.420 --> 00:20:19.710
want to make it.

00:20:19.710 --> 00:20:27.030
In fact, a lot of people prove
Wald's equality by skipping

00:20:27.030 --> 00:20:30.760
all of this stuff about
stopping trials.

00:20:30.760 --> 00:20:41.530
And what they say is that the
rule for stopping at time J is

00:20:41.530 --> 00:20:46.450
independent of all of
the future arrivals.

00:20:46.450 --> 00:20:49.490
And that lets you prove the
theorem immediately.

00:20:49.490 --> 00:20:56.490
It doesn't give you any clue at
all as to when that holds,

00:20:56.490 --> 00:21:00.350
so that in fact you're taking
Wald's equality and making it

00:21:00.350 --> 00:21:02.680
essentially a truism.

00:21:02.680 --> 00:21:05.880
And you're avoiding the real
problem, which is to know when

00:21:05.880 --> 00:21:08.980
you have a stopping rule
and when you don't

00:21:08.980 --> 00:21:10.360
have a stopping rule.

00:21:10.360 --> 00:21:15.230
But anyway, we can generalize
it in this way.

00:21:15.230 --> 00:21:21.020
And now we want to use this to
look at a fairly general

00:21:21.020 --> 00:21:23.020
queueing situation.

00:21:23.020 --> 00:21:26.600
We talked about the G/G/M
queue before.

00:21:26.600 --> 00:21:30.060
Let's just talk about the G/G/1
queue at this point.

00:21:30.060 --> 00:21:34.860
This is a queue with general
independent IID and her

00:21:34.860 --> 00:21:39.730
arrival times, IID
service times.

00:21:39.730 --> 00:21:45.080
So what you wind up with is
at time 0, you assume that

00:21:45.080 --> 00:21:47.330
there's an arrival at time 0.

00:21:47.330 --> 00:21:51.970
You don't count it as part of
the arrival renewal process.

00:21:51.970 --> 00:21:54.560
So this arrival is here.

00:21:54.560 --> 00:21:56.780
That arrival goes
into service.

00:21:56.780 --> 00:22:00.430
There's some service
time V sub 0.

00:22:00.430 --> 00:22:06.730
At some inter-arrival time, X1,
another arrival comes in.

00:22:06.730 --> 00:22:10.760
In this particular sample
function here, the second

00:22:10.760 --> 00:22:17.850
arrival comes in before this 0
arrival that we didn't account

00:22:17.850 --> 00:22:20.030
finishes service.

00:22:20.030 --> 00:22:20.770
And I'm sorry.

00:22:20.770 --> 00:22:22.500
I should have--

00:22:22.500 --> 00:22:26.680
It might make better sense to
call this X1 and call this V1.

00:22:26.680 --> 00:22:29.610
It would make all the
notation simpler.

00:22:29.610 --> 00:22:32.290
Or call this X0 and
call this V0.

00:22:34.920 --> 00:22:37.990
But unfortunately that's not
consistent with any of the

00:22:37.990 --> 00:22:40.750
notation that anybody
uses for talking

00:22:40.750 --> 00:22:42.940
about renewal processes.

00:22:42.940 --> 00:22:46.170
Because you want these X's
to be the elements

00:22:46.170 --> 00:22:48.280
of a renewal process.

00:22:48.280 --> 00:22:52.520
You want the V's to be
IID random variables.

00:22:52.520 --> 00:22:56.560
And this, unfortunately, is
the way it has to be.

00:22:56.560 --> 00:22:58.640
So these arrivals come in.

00:22:58.640 --> 00:23:01.465
This is the inter-arrival
time before--

00:23:04.900 --> 00:23:08.640
This is S1 here, which is
the time of the first

00:23:08.640 --> 00:23:10.810
arrival after 0.

00:23:10.810 --> 00:23:13.540
This is S2, which is the
time of the first

00:23:13.540 --> 00:23:18.350
arrival after time 0.

00:23:18.350 --> 00:23:22.740
And when you count the arrival
at time 0 in, this function

00:23:22.740 --> 00:23:28.730
here is N of t plus 1.

00:23:28.730 --> 00:23:32.070
So this is N of t plus
1 going along here.

00:23:32.070 --> 00:23:35.940
This is the arrival process
plus 1, where now we've

00:23:35.940 --> 00:23:39.220
counted this arrival
at time 0.

00:23:39.220 --> 00:23:41.300
You have these services
going on.

00:23:41.300 --> 00:23:46.230
V0 for this particular sample
function is the time of the

00:23:46.230 --> 00:23:50.410
service of this 0 arrival.

00:23:50.410 --> 00:23:55.990
V1 is the time of the
service of this X1--

00:23:55.990 --> 00:24:15.300
well, it's the service time of
the arrival that has come in

00:24:15.300 --> 00:24:16.230
at this point.

00:24:16.230 --> 00:24:22.530
This is the service time of
the arrival at time 0.

00:24:22.530 --> 00:24:26.190
This is the service time of
the arrival at this time.

00:24:26.190 --> 00:24:28.230
This as the service time
of the arrival at

00:24:28.230 --> 00:24:29.840
this time and so forth.

00:24:35.170 --> 00:24:38.340
I want to make sure that you
understand this model here

00:24:38.340 --> 00:24:40.540
before we go on.

00:24:40.540 --> 00:24:42.480
Because if you don't understand
this, you won't

00:24:42.480 --> 00:24:44.940
understand anything
we do after this.

00:24:47.610 --> 00:24:51.060
If you look at this now, you see
a departure process which

00:24:51.060 --> 00:24:53.600
is going on also.

00:24:53.600 --> 00:25:03.220
These departure times are
determined partly as a sum of

00:25:03.220 --> 00:25:07.920
the number of customers to
have departed by time t.

00:25:07.920 --> 00:25:14.720
And this example here is just
the sum of V0 plus V1 plus V2.

00:25:14.720 --> 00:25:19.810
So it's almost the same as this
renewal process here,

00:25:19.810 --> 00:25:22.920
except here you're talking about
a renewal process of

00:25:22.920 --> 00:25:25.310
dealing with the departure
times.

00:25:25.310 --> 00:25:29.340
This changes any time that
the queue empties out.

00:25:29.340 --> 00:25:32.680
Because when the queue empties
out, the server isn't doing

00:25:32.680 --> 00:25:34.150
anything for a while.

00:25:34.150 --> 00:25:37.675
So suddenly, the number of
departures slows up.

00:25:40.200 --> 00:25:43.750
And in some sense, you
reset things here.

00:25:43.750 --> 00:25:47.800
What I want to do in this
argument today is to explain

00:25:47.800 --> 00:25:52.030
much more carefully why you can
actually restart things

00:25:52.030 --> 00:25:55.110
when this new arrival occurs.

00:25:55.110 --> 00:26:00.710
So I want to say that, in fact,
this is a renewal time

00:26:00.710 --> 00:26:04.650
for this entire queuing
process.

00:26:04.650 --> 00:26:07.800
These are renewal times
for the arrivals

00:26:07.800 --> 00:26:09.510
to the queuing process.

00:26:09.510 --> 00:26:15.350
This thing here, the next
arrival to an empty server and

00:26:15.350 --> 00:26:20.830
so forth, are all, in fact,
renewals of the

00:26:20.830 --> 00:26:22.640
entire queuing system.

00:26:22.640 --> 00:26:24.960
We want to understand
why that is.

00:26:24.960 --> 00:26:28.100
We want to use this idea
of stopping trials

00:26:28.100 --> 00:26:30.440
to understand this.

00:26:30.440 --> 00:26:34.770
So look at the first arrival
to start a new busy period.

00:26:34.770 --> 00:26:38.130
Well, think of that as a
generalized stopping trial.

00:26:38.130 --> 00:26:40.960
Why is it generalized
stopping trial?

00:26:40.960 --> 00:26:43.850
Well the sequence of paired
random variables we want to

00:26:43.850 --> 00:26:52.430
look at is X1, V0, X2, V1,
X3, V2, and so forth.

00:26:52.430 --> 00:26:59.660
And stopping at J equals 3 is
actually a function of this

00:26:59.660 --> 00:27:06.070
first pair, the second pair, and
the third pair, which is

00:27:06.070 --> 00:27:09.630
the restriction we need
for a stopping trial.

00:27:09.630 --> 00:27:15.640
So the stopping trial stop when
the first arrival comes

00:27:15.640 --> 00:27:21.960
to an empty system is in fact a
function of the arrivals and

00:27:21.960 --> 00:27:25.230
as the departure intervals
up until that time.

00:27:28.050 --> 00:27:32.870
Wald's equality holds because,
in fact, every time you get a

00:27:32.870 --> 00:27:37.440
new arrival, it's independent
of all the old arrivals.

00:27:37.440 --> 00:27:39.960
It's independent of all
the old service times.

00:27:39.960 --> 00:27:41.780
It's independent of all
the new service

00:27:41.780 --> 00:27:44.640
times also, sort of.

00:27:44.640 --> 00:27:48.080
But you have to be more
careful with that.

00:27:48.080 --> 00:27:51.160
But in fact, the service
times are all IID.

00:27:51.160 --> 00:27:54.030
So that works too.

00:27:54.030 --> 00:27:56.950
So Wald's equality holds here.

00:27:56.950 --> 00:28:00.190
But that's not what we're
interested in here.

00:28:00.190 --> 00:28:04.070
What we're interested in is
trying to show that you do get

00:28:04.070 --> 00:28:07.310
renewals at these times here.

00:28:07.310 --> 00:28:11.800
So let's try to argue
why that is.

00:28:11.800 --> 00:28:12.861
Did I--

00:28:12.861 --> 00:28:16.298
AUDIENCE: Question?

00:28:16.298 --> 00:28:18.262
Do V's have to be independent
somehow?

00:28:18.262 --> 00:28:19.110
PROFESSOR: What?

00:28:19.110 --> 00:28:21.360
AUDIENCE: Do the V's have to
be independent somehow?

00:28:21.360 --> 00:28:22.072
PROFESSOR: Yes.

00:28:22.072 --> 00:28:22.310
Yes.

00:28:22.310 --> 00:28:24.685
AUDIENCE: So they have to be
independent from one another?

00:28:24.685 --> 00:28:25.635
PROFESSOR: Yes.

00:28:25.635 --> 00:28:27.550
AUDIENCE: It was the case
here, you said.

00:28:27.550 --> 00:28:28.180
PROFESSOR: Yes.

00:28:28.180 --> 00:28:32.490
That's what you mean
by a G/G/1 queue.

00:28:32.490 --> 00:28:34.500
A G/G/1 queue is--

00:28:34.500 --> 00:28:36.600
AUDIENCE: You have a service
time and the arrival.

00:28:36.600 --> 00:28:37.120
PROFESSOR: Service time.

00:28:37.120 --> 00:28:38.036
AUDIENCE: They're both
independent.

00:28:38.036 --> 00:28:39.870
PROFESSOR: They're both
independent, yes.

00:28:39.870 --> 00:28:41.785
AUDIENCE: And that makes
the departure?

00:28:41.785 --> 00:28:42.810
PROFESSOR: Right.

00:28:42.810 --> 00:28:47.480
And in fact, the first G says
that the arrivals are IID,

00:28:47.480 --> 00:28:50.390
have an arbitrary
distribution.

00:28:50.390 --> 00:28:54.640
The second G says that the
service times are IID, but

00:28:54.640 --> 00:28:56.960
have an arbitrary
distribution.

00:28:56.960 --> 00:29:01.240
And then the 1, our the M, or
whatever, says how many

00:29:01.240 --> 00:29:04.196
servers there are.

00:29:04.196 --> 00:29:07.010
AUDIENCE: And that makes the
departures independent?

00:29:07.010 --> 00:29:07.950
PROFESSOR: Yeah.

00:29:07.950 --> 00:29:10.450
So you can really have much
more general queuing

00:29:10.450 --> 00:29:11.720
situations than this.

00:29:11.720 --> 00:29:13.940
And you often do.

00:29:13.940 --> 00:29:14.370
Yes?

00:29:14.370 --> 00:29:17.457
AUDIENCE: With the departure
process, it's not a renewal?

00:29:17.457 --> 00:29:18.380
PROFESSOR: What?

00:29:18.380 --> 00:29:18.600
AUDIENCE: The departures.

00:29:18.600 --> 00:29:21.670
PROFESSOR: The departure process
is not a renewal

00:29:21.670 --> 00:29:23.860
process, because every
once in while, the

00:29:23.860 --> 00:29:27.370
server stops doing anything.

00:29:27.370 --> 00:29:27.580
What?

00:29:27.580 --> 00:29:29.530
AUDIENCE: That's how I got
confused actually.

00:29:29.530 --> 00:29:31.750
Because every once in a while,
the server somehow--

00:29:31.750 --> 00:29:32.800
PROFESSOR: Every once
in a while, the

00:29:32.800 --> 00:29:34.560
server stops working.

00:29:34.560 --> 00:29:42.470
But V1, V2, V3 are defined
as the service time

00:29:42.470 --> 00:29:44.470
of the first customer.

00:29:44.470 --> 00:29:49.260
Well actually V0, the service
time of the zeroth customer.

00:29:49.260 --> 00:29:52.720
V1 is the service time of
the first customer.

00:29:52.720 --> 00:29:56.100
Namely the time from when the
customer enters service to

00:29:56.100 --> 00:29:57.795
when the customer's finished
with service.

00:30:01.740 --> 00:30:04.400
And the reason why
these things--

00:30:04.400 --> 00:30:09.480
If you looked at the sequence
V0, V1, V2, V3, you could call

00:30:09.480 --> 00:30:12.130
that a renewal process.

00:30:12.130 --> 00:30:15.040
But it wouldn't be a renewal
process of any interest to

00:30:15.040 --> 00:30:21.650
you, because it would be a
renewal process where the

00:30:21.650 --> 00:30:27.540
renewals occur at V0,
at V0 plus V1, at V0

00:30:27.540 --> 00:30:29.320
plus V1 plus V2.

00:30:29.320 --> 00:30:32.340
And those might not be the time
when these customers are

00:30:32.340 --> 00:30:33.590
finishing service.

00:30:36.310 --> 00:30:38.410
Because there are these
idle times to take

00:30:38.410 --> 00:30:40.020
into account also.

00:30:40.020 --> 00:30:43.400
If you didn't have the ideal
times to take into account,

00:30:43.400 --> 00:30:46.610
you wouldn't have to think about
queuing theory at all.

00:30:46.610 --> 00:30:49.810
Because all you'd have is two
separate and independent

00:30:49.810 --> 00:30:52.090
renewal processes.

00:30:52.090 --> 00:30:57.270
So this is where all of the
gimmickry in all of queuing

00:30:57.270 --> 00:31:00.050
theory comes from.

00:31:00.050 --> 00:31:06.330
But what I wanted to come back
and say that I didn't say very

00:31:06.330 --> 00:31:08.350
well before.

00:31:08.350 --> 00:31:11.070
In the notes, the assumption
is that these

00:31:11.070 --> 00:31:13.580
pairs here are IID.

00:31:16.740 --> 00:31:19.370
What you really would like is
something a little more

00:31:19.370 --> 00:31:25.450
general than that, which says
that each Xi is independent of

00:31:25.450 --> 00:31:28.790
all of the earlier pairs.

00:31:28.790 --> 00:31:33.560
So that that's giving you a
little bit of flexibility for

00:31:33.560 --> 00:31:34.810
how these other random

00:31:34.810 --> 00:31:39.581
variables impact the situation.

00:31:39.581 --> 00:31:42.840
And in fact, they can be
anything at all, just so long

00:31:42.840 --> 00:31:46.980
as you have this condition that
each Xi is independent of

00:31:46.980 --> 00:31:48.520
all these past things here.

00:31:54.230 --> 00:31:56.205
So we said that Wald's
equality holds.

00:31:58.900 --> 00:32:03.060
But the other thing, which is
what we really want, is the

00:32:03.060 --> 00:32:04.720
new arrivals.

00:32:04.720 --> 00:32:15.360
Namely the arrival after S3,
which comes at S3 plus X3.

00:32:15.360 --> 00:32:19.630
That's X sub J plus 1, X sub
J plus 2, and so forth.

00:32:19.630 --> 00:32:25.770
And the service times, in this
case V sub J, is the service

00:32:25.770 --> 00:32:29.160
time that occurs after this.

00:32:29.160 --> 00:32:33.820
V sub J plus 1, and so forth,
are all independent of the old

00:32:33.820 --> 00:32:36.840
arrivals and the old
service times.

00:32:36.840 --> 00:32:40.170
So in fact, this is actually
saying that everything that

00:32:40.170 --> 00:32:48.670
happens after this J's arrival
is independent of everything

00:32:48.670 --> 00:32:49.920
that happens before.

00:32:49.920 --> 00:32:56.550
And when I say everything, you
have to be careful about that,

00:32:56.550 --> 00:32:59.790
because we're talking about all
the inter-arrival times

00:32:59.790 --> 00:33:01.470
that occur after this.

00:33:01.470 --> 00:33:05.240
And we're talking about all of
the service times that occur

00:33:05.240 --> 00:33:05.960
after this.

00:33:05.960 --> 00:33:10.550
We're not talking about things
like S sub n plus 1, which is

00:33:10.550 --> 00:33:16.310
the time of the next arrival,
because that's this arrival

00:33:16.310 --> 00:33:23.950
time plus that next
inter-arrival time.

00:33:23.950 --> 00:33:27.870
So each of these intervals
are in fact

00:33:27.870 --> 00:33:29.500
independent of each other.

00:33:29.500 --> 00:33:33.850
And what we've done here is use
this idea of a stopping

00:33:33.850 --> 00:33:39.700
trial not to define when we stop
this whole process, but

00:33:39.700 --> 00:33:41.810
to define when a
renewal occurs.

00:33:41.810 --> 00:33:45.950
In other words, we're using
it to define when the old

00:33:45.950 --> 00:33:50.230
inter-renewal period ends
and a new one begins.

00:33:50.230 --> 00:33:56.640
This can be called a stopping
trial, if in fact you stop the

00:33:56.640 --> 00:33:58.820
whole process at that
point and then

00:33:58.820 --> 00:34:00.890
don't do anything further.

00:34:00.890 --> 00:34:05.710
So that's what's nice about this
idea of stopping trials.

00:34:05.710 --> 00:34:08.940
They let you not only
do Wald's equality.

00:34:08.940 --> 00:34:14.239
But they also let you actually
see why it is that these

00:34:14.239 --> 00:34:18.719
arrivals that start after this
point are independent of the

00:34:18.719 --> 00:34:20.940
arrivals and departures
before that.

00:34:24.639 --> 00:34:28.100
So let me just try to
say that again.

00:34:28.100 --> 00:34:32.480
The stopping rule is the index
of the first arrival in a new

00:34:32.480 --> 00:34:33.880
busy period.

00:34:33.880 --> 00:34:36.510
The arrivals and departures
in the new busy period are

00:34:36.510 --> 00:34:39.540
independent and identically
distributed to

00:34:39.540 --> 00:34:41.500
those in the old.

00:34:41.500 --> 00:34:44.350
Thus the intervals between
new busy periods

00:34:44.350 --> 00:34:46.350
form a renewal process.

00:34:46.350 --> 00:34:48.570
And that's the thing that
we're going to use in

00:34:48.570 --> 00:34:51.460
everything else we do here.

00:34:51.460 --> 00:34:54.449
So we have one renewal process,
which is embedded in

00:34:54.449 --> 00:34:57.760
another renewable process.

00:34:57.760 --> 00:35:03.770
The outside renewal process of
the arrivals are what you

00:35:03.770 --> 00:35:05.510
start out with.

00:35:05.510 --> 00:35:11.410
These embedded renewals are, in
fact, functions of both the

00:35:11.410 --> 00:35:15.680
arrival process and the
service distribution.

00:35:15.680 --> 00:35:18.250
So that's a more complicated
thing.

00:35:18.250 --> 00:35:21.970
But at least you now know that
that's an arrival process.

00:35:21.970 --> 00:35:26.230
It says that you can analyze
any one of these queuing

00:35:26.230 --> 00:35:31.420
systems or any considerably
broader type of queueing

00:35:31.420 --> 00:35:34.860
system, which has the same
property of having renewals

00:35:34.860 --> 00:35:38.730
every once in a while, by
looking at what happens within

00:35:38.730 --> 00:35:40.260
a renewal period.

00:35:40.260 --> 00:35:44.080
Then using what happens within
a renewal period and applying

00:35:44.080 --> 00:35:48.010
one of these limit theorems on
the embedded renewals to get

00:35:48.010 --> 00:35:50.510
some time average
overall time.

00:35:50.510 --> 00:35:54.590
So that's what we're
really up to here.

00:35:54.590 --> 00:35:58.280
This same analysis
applies to G/G/m.

00:35:58.280 --> 00:36:01.310
Applies to lots of
queueing systems.

00:36:01.310 --> 00:36:03.630
You have to look at a
queuing system and

00:36:03.630 --> 00:36:05.760
see whether it applies.

00:36:05.760 --> 00:36:10.710
To get some idea of how you
can see that without going

00:36:10.710 --> 00:36:16.040
through this whole analysis,
suppose that you decided to

00:36:16.040 --> 00:36:22.080
try to call this point here,
at which the system first

00:36:22.080 --> 00:36:26.470
became empty the end of
a renewal period.

00:36:26.470 --> 00:36:27.740
Why couldn't you do that?

00:36:35.060 --> 00:36:37.690
Why is this not a
renewal period?

00:36:45.310 --> 00:36:48.300
Well, is it a stopping trial?

00:36:48.300 --> 00:36:53.060
It certainly isn't a stopping
trial for the X's.

00:36:53.060 --> 00:36:58.840
Because at this time when this
last departure has left, you

00:36:58.840 --> 00:37:03.360
have no idea how long this new
inter-arrival period that's

00:37:03.360 --> 00:37:06.050
going on here is going to be.

00:37:06.050 --> 00:37:08.060
That has some arbitrary
distribution.

00:37:08.060 --> 00:37:12.620
All we know at this point is
that it's longer than this.

00:37:12.620 --> 00:37:17.860
And if you had a busy period end
at some point close to the

00:37:17.860 --> 00:37:20.980
beginning of this inter-arrival
period, you have

00:37:20.980 --> 00:37:25.180
a different distribution from
when it occurs close to the

00:37:25.180 --> 00:37:27.050
end of an inter-arrival
period.

00:37:30.540 --> 00:37:33.540
Well, because these
inter-arrivals are not

00:37:33.540 --> 00:37:35.150
memoryless.

00:37:35.150 --> 00:37:40.250
They have memory which says
their conditional distribution

00:37:40.250 --> 00:37:43.450
depends on how long they've
been running.

00:37:43.450 --> 00:37:52.740
So this is the only sensible
place you can define a renewal

00:37:52.740 --> 00:37:53.990
process here.

00:38:02.540 --> 00:38:05.140
So let's go on.

00:38:05.140 --> 00:38:08.880
There is something called
Little's theorem, which was

00:38:08.880 --> 00:38:13.270
invented by John Little
not all that long ago.

00:38:13.270 --> 00:38:17.060
And Little's theorem is curious,
because you can view

00:38:17.060 --> 00:38:22.020
it as being either trivial
or non-trivial.

00:38:22.020 --> 00:38:25.560
I will try to convince you that
it's trivial and also

00:38:25.560 --> 00:38:28.950
convince you that it's
non-trivial.

00:38:28.950 --> 00:38:32.870
And what I mean by that is that
it's trivial in terms of

00:38:32.870 --> 00:38:36.040
trying to use it someplace.

00:38:36.040 --> 00:38:38.970
It's then nontrivial to try
to justify that you

00:38:38.970 --> 00:38:40.960
can actually do that.

00:38:40.960 --> 00:38:46.070
But you get the idea of doing
it in many, many places.

00:38:46.070 --> 00:38:48.700
We're going to assume an arrival
at time 0, like we've

00:38:48.700 --> 00:38:50.800
been doing before.

00:38:50.800 --> 00:38:53.780
Service process can be
almost anything.

00:38:53.780 --> 00:38:56.530
But let's assume a G/G/1
queue to be specific.

00:38:59.230 --> 00:39:03.240
The system empties out
eventually with probability 1.

00:39:03.240 --> 00:39:05.220
And assume that it restarts
on the next arrival.

00:39:08.180 --> 00:39:11.560
We've seen that intervals
between restarting form a

00:39:11.560 --> 00:39:14.850
renewal process for
the G/G/1 queue.

00:39:14.850 --> 00:39:18.820
And we've argued that it forms
a renewal process for an even

00:39:18.820 --> 00:39:20.235
broader class of queues.

00:39:22.930 --> 00:39:24.670
That's normally.

00:39:24.670 --> 00:39:33.340
Who can tell me when you don't
get a renewal process when you

00:39:33.340 --> 00:39:35.650
have a G/G/1 queue?

00:39:35.650 --> 00:39:40.470
We made an assumption
here without talking

00:39:40.470 --> 00:39:43.640
at all about it.

00:39:43.640 --> 00:39:46.770
And what's that assumption?

00:39:46.770 --> 00:39:47.246
What?

00:39:47.246 --> 00:39:50.380
AUDIENCE: Starting with
an empty queue.

00:39:50.380 --> 00:39:51.010
PROFESSOR: Yes.

00:39:51.010 --> 00:39:53.830
Every once in a while, you
get an empty queue.

00:39:53.830 --> 00:40:01.960
If you have a system where
service times are greater than

00:40:01.960 --> 00:40:05.330
inter-arrival times, what's
going to happen is that

00:40:05.330 --> 00:40:08.310
arrivals keep coming
in, eventually

00:40:08.310 --> 00:40:10.090
building up more and more.

00:40:10.090 --> 00:40:13.690
The queue gets longer
and longer.

00:40:13.690 --> 00:40:18.600
And you never have any
renewals occurring.

00:40:18.600 --> 00:40:21.950
So one thing we didn't say here
is we're talking about

00:40:21.950 --> 00:40:25.950
G/G/1 queues and more general
queues, and the more important

00:40:25.950 --> 00:40:30.180
case where the queue sometimes
empty out.

00:40:30.180 --> 00:40:32.870
We want to use this to
analyze when they

00:40:32.870 --> 00:40:34.580
actually do empty out.

00:40:37.560 --> 00:40:40.650
So here's the picture.

00:40:40.650 --> 00:40:44.636
The same kind of picture as
before of an arrival process.

00:40:47.270 --> 00:40:49.880
And every time we're talking
about these kinds of things,

00:40:49.880 --> 00:40:54.280
these queuing situations, we
will distinguish the arrival

00:40:54.280 --> 00:40:56.710
process, which is a
renewal process.

00:40:56.710 --> 00:40:59.940
But when we talk about the
renewal process, we'll talk

00:40:59.940 --> 00:41:04.840
about this renewal process which
starts on arrivals to an

00:41:04.840 --> 00:41:05.710
empty system.

00:41:05.710 --> 00:41:07.280
So here's a renewal.

00:41:07.280 --> 00:41:11.430
Here's a renewal,
and so forth.

00:41:11.430 --> 00:41:15.375
Suppose we look at the
difference between A

00:41:15.375 --> 00:41:17.250
of t and D of t.

00:41:17.250 --> 00:41:21.560
A of t is the number of arrivals
that have come in up

00:41:21.560 --> 00:41:26.220
until time t, counting this
arrival at time 0.

00:41:26.220 --> 00:41:29.280
D of t is the number of
departures that have occurred.

00:41:29.280 --> 00:41:30.970
What is the difference?

00:41:30.970 --> 00:41:34.910
The difference, L of t, is the
number of customers in the

00:41:34.910 --> 00:41:36.310
system at time t.

00:41:38.950 --> 00:41:41.620
And one of the things you'd like
to be able to analyze in

00:41:41.620 --> 00:41:44.880
a queuing system is, what's
the distribution?

00:41:44.880 --> 00:41:49.050
What do you know about how
busy the queue is?

00:41:49.050 --> 00:41:53.730
If you build storage for 100
customers, you would like to

00:41:53.730 --> 00:41:56.200
know what's the likelihood
that that

00:41:56.200 --> 00:41:58.050
storage will fill up.

00:41:58.050 --> 00:42:01.050
And you have to drop customers
on the floor or do whatever

00:42:01.050 --> 00:42:06.400
you do to customers when
the queue is full.

00:42:06.400 --> 00:42:09.420
So L of t is clearly something
we want to look at.

00:42:09.420 --> 00:42:12.820
It's the number of customers
in the system at any time.

00:42:12.820 --> 00:42:15.340
Not the number of customers
waiting in queue, but the

00:42:15.340 --> 00:42:19.410
number of customers both to
waiting in queue and being

00:42:19.410 --> 00:42:20.660
served currently.

00:42:24.080 --> 00:42:27.660
We can view this as a
generalized renewal reward

00:42:27.660 --> 00:42:31.350
function at this point, because
this number in the

00:42:31.350 --> 00:42:39.230
system at any given time t, is a
function what happens within

00:42:39.230 --> 00:42:41.110
this inter-renewal
period here.

00:42:41.110 --> 00:42:44.090
It's a function of these
arrivals within this

00:42:44.090 --> 00:42:47.380
inter-renewal period and these
departures within this

00:42:47.380 --> 00:42:48.630
inter-renewal period.

00:42:51.330 --> 00:42:54.700
So we can use renewal
reward theory.

00:42:54.700 --> 00:42:59.870
The total reward with an inner
renewal period is the integral

00:42:59.870 --> 00:43:02.850
of L of tau over that period.

00:43:02.850 --> 00:43:04.100
This is the way we found--

00:43:11.010 --> 00:43:14.250
Every time we looked at renewal
reward theory, we

00:43:14.250 --> 00:43:19.180
looked at the reward within
one inter-renewal period.

00:43:19.180 --> 00:43:22.530
And then we tried to look at
what happened when we started

00:43:22.530 --> 00:43:25.920
to look at many, many
inter-renewal periods.

00:43:25.920 --> 00:43:29.920
So we want to look at
L of tau integrated

00:43:29.920 --> 00:43:32.080
over one renewal period.

00:43:32.080 --> 00:43:35.730
And then we want to go on to
see how we apply renewal

00:43:35.730 --> 00:43:37.770
theory over that.

00:43:37.770 --> 00:43:43.680
So in each inter-renewal period,
the aggregate number

00:43:43.680 --> 00:43:50.370
and queue number in the system
integrated over the duration

00:43:50.370 --> 00:43:55.750
of that inter-renewal period is
this integral of L of tau.

00:43:55.750 --> 00:43:58.590
Here I've stated Little's
theorem really.

00:43:58.590 --> 00:44:01.920
Let's go back and see where
that comes from.

00:44:01.920 --> 00:44:07.130
If I want to look at the
integral of L of t over this

00:44:07.130 --> 00:44:10.580
period of time, what is it?

00:44:10.580 --> 00:44:16.540
I can view it as W1
plus W2 plus W3.

00:44:16.540 --> 00:44:19.380
That's the easy way to integrate
this function.

00:44:19.380 --> 00:44:21.050
You start out here.

00:44:21.050 --> 00:44:22.410
You're integrating up to here.

00:44:26.100 --> 00:44:27.890
1 times D tau.

00:44:27.890 --> 00:44:30.170
And you have 2 times D tau.

00:44:30.170 --> 00:44:34.270
Then 1, then 2, and
then 1 again.

00:44:34.270 --> 00:44:37.690
But the easy way to integrate it
is just say the integral is

00:44:37.690 --> 00:44:41.900
W1 plus W2 times this
height, plus W3.

00:44:44.520 --> 00:44:48.800
For those of you who have
studied Lebesgue integration,

00:44:48.800 --> 00:44:52.020
it's the idea of a Lebesgue
integral as opposed to a

00:44:52.020 --> 00:44:53.350
Riemann integral.

00:44:53.350 --> 00:44:55.910
If you haven't studied it,
don't worry about it.

00:44:55.910 --> 00:44:59.740
It's just a trivial idea that
you can integrate this way as

00:44:59.740 --> 00:45:01.380
well as integrating this way.

00:45:05.930 --> 00:45:07.630
That's the crux of
Little's theorem.

00:45:07.630 --> 00:45:13.150
The crux of Little's theorem is
this equality between the

00:45:13.150 --> 00:45:19.520
integral of L of t and the
sum of the waiting

00:45:19.520 --> 00:45:21.860
times of each customer.

00:45:21.860 --> 00:45:26.050
W1 is the waiting time
of customer--

00:45:26.050 --> 00:45:28.450
Well it's the waiting time of
customer 0 in this case.

00:45:28.450 --> 00:45:31.920
W2 is the waiting time of
customer 1, from the time it

00:45:31.920 --> 00:45:35.180
comes in, it's waiting in
queue until this time.

00:45:35.180 --> 00:45:36.430
Then it starts service.

00:45:38.980 --> 00:45:40.860
Next customer comes in here.

00:45:40.860 --> 00:45:42.010
Waits in queue.

00:45:42.010 --> 00:45:43.380
Finally starts service.

00:45:43.380 --> 00:45:45.300
Then the system is empty.

00:45:45.300 --> 00:45:49.210
And you integrate L of t
from here up to here.

00:45:49.210 --> 00:45:51.090
You sum the W's.

00:45:51.090 --> 00:45:52.555
And that's what I did
in the next slide.

00:45:58.660 --> 00:46:02.440
And I can integrate over as many
inter-renewal periods as

00:46:02.440 --> 00:46:05.030
you want to integrate over.

00:46:05.030 --> 00:46:06.610
And what's going to happen?

00:46:06.610 --> 00:46:10.310
I'm adding up these individual
inter-renewal periods.

00:46:10.310 --> 00:46:13.400
I'm adding up this integral
over each of them.

00:46:13.400 --> 00:46:18.350
I'm also adding up the sum of
the waiting times over that

00:46:18.350 --> 00:46:20.180
larger interval.

00:46:20.180 --> 00:46:22.980
And this equality
still occurs.

00:46:22.980 --> 00:46:26.470
Any time I integrate over
an integer number of

00:46:26.470 --> 00:46:30.130
inter-renewal periods, I have
this equality between the

00:46:30.130 --> 00:46:34.690
integral of L of t and
the sum of W sub i's.

00:46:34.690 --> 00:46:38.850
One of the things that we
observe from renewal theory is

00:46:38.850 --> 00:46:43.240
when you start taking limits
between 0 and infinity, one

00:46:43.240 --> 00:46:47.100
inter-renewal period doesn't
make any difference.

00:46:47.100 --> 00:46:49.380
When we go on through the
mathematics there, we've done

00:46:49.380 --> 00:46:50.080
it carefully.

00:46:50.080 --> 00:46:51.460
We've upper bound it.

00:46:51.460 --> 00:46:52.900
And we've lower bound it.

00:46:52.900 --> 00:46:56.930
And we've then shown that it
doesn't make any difference.

00:46:56.930 --> 00:46:59.080
But at this point, you know
that it doesn't make any

00:46:59.080 --> 00:47:01.690
difference.

00:47:01.690 --> 00:47:08.210
So that you know that when you
take the time average, the

00:47:08.210 --> 00:47:12.910
time average number in the
system is equal to the limit

00:47:12.910 --> 00:47:18.740
as t goes to infinity of 1 over
t times i equals 1 up to

00:47:18.740 --> 00:47:23.970
the number of arrivals up until
time t times W sub i.

00:47:23.970 --> 00:47:28.630
When you take that limit, it's
W sub i over A of t times the

00:47:28.630 --> 00:47:32.340
limit of A of t over t.

00:47:32.340 --> 00:47:36.840
Both of these go to a limit with
probability 1, because

00:47:36.840 --> 00:47:40.390
this is just a strong law
of large numbers again.

00:47:40.390 --> 00:47:43.890
This is just the renewal
theorem again.

00:47:43.890 --> 00:47:50.890
And that limit here is the
time average of W. It's a

00:47:50.890 --> 00:47:54.000
little awkward calling
this a time average.

00:47:54.000 --> 00:47:58.670
Because what this really is
is a sample path average.

00:47:58.670 --> 00:48:00.910
That's a sample path average
which exists

00:48:00.910 --> 00:48:02.540
with probability 1.

00:48:02.540 --> 00:48:06.880
This is a sample path every over
any old sample path you

00:48:06.880 --> 00:48:12.420
want to look at of the time
average over all of the

00:48:12.420 --> 00:48:13.580
customers that come in.

00:48:13.580 --> 00:48:17.800
You add up all the customers
that come in and you divide by

00:48:17.800 --> 00:48:19.220
the number of customers.

00:48:19.220 --> 00:48:25.000
And that gives you the time
average delay that a customer

00:48:25.000 --> 00:48:26.160
experiences.

00:48:26.160 --> 00:48:30.640
So what Little's theorem says
is that the time average of

00:48:30.640 --> 00:48:34.090
the expected number of customers
in the system at a

00:48:34.090 --> 00:48:38.595
given time is equal to lambda,
which is the arrival rate--

00:48:38.595 --> 00:48:41.620
A of t over t, is
arrival rate--

00:48:41.620 --> 00:48:44.090
times the expected delay that
each customer experiences.

00:48:48.290 --> 00:48:50.990
That's a very useful
relationship.

00:48:50.990 --> 00:48:58.760
Like all of the things that come
from the Wald equality,

00:48:58.760 --> 00:49:01.080
it only gives you a relationship
between two

00:49:01.080 --> 00:49:04.460
things that you don't know.

00:49:04.460 --> 00:49:07.580
But one relationship between two
things you don't know is

00:49:07.580 --> 00:49:10.290
better than no relationships
between two

00:49:10.290 --> 00:49:12.050
things you don't know.

00:49:12.050 --> 00:49:15.470
Here we have this one
useful relationship.

00:49:15.470 --> 00:49:21.420
We can understand intuitively
what's going on here if we

00:49:21.420 --> 00:49:23.135
look this diagram again.

00:49:39.130 --> 00:49:46.460
If you look at the diagram
again, if you expand this

00:49:46.460 --> 00:49:53.540
whole diagram in t, if you
measure it in hours instead of

00:49:53.540 --> 00:49:56.410
measuring it in milliseconds,
for example.

00:49:56.410 --> 00:49:59.410
This whole thing spreads
out enormously.

00:49:59.410 --> 00:50:00.750
And what happens?

00:50:00.750 --> 00:50:06.170
The W's all get multiplied
by a very large amount.

00:50:06.170 --> 00:50:10.310
A of tau stays the same.

00:50:10.310 --> 00:50:13.210
Lambda, the expected
arrival rate,

00:50:13.210 --> 00:50:14.890
becomes very much larger.

00:50:14.890 --> 00:50:21.090
Arrivals per hour rather than
arrivals per millisecond.

00:50:21.090 --> 00:50:34.340
So you see that at least as
far as scaling is scaling,

00:50:34.340 --> 00:50:38.050
there's no way of relating this
to this without having

00:50:38.050 --> 00:50:41.890
something there, which is
something per unit time.

00:50:41.890 --> 00:50:43.070
This is time.

00:50:43.070 --> 00:50:47.790
This is a time average.

00:50:47.790 --> 00:50:50.900
So we have Little's theorem.

00:50:50.900 --> 00:50:54.340
Useful in many, many
situations.

00:50:54.340 --> 00:50:56.910
It's useful as an approximation
in many places

00:50:56.910 --> 00:50:58.160
where it doesn't hold.

00:51:01.650 --> 00:51:05.840
But the right way to look at
this, this is really an

00:51:05.840 --> 00:51:07.420
accounting identity.

00:51:07.420 --> 00:51:10.400
There was this first thing
we brought out, that this

00:51:10.400 --> 00:51:19.100
integral of L of t over 1
inter-renewal period was equal

00:51:19.100 --> 00:51:20.850
to the sum of the waiting
times over

00:51:20.850 --> 00:51:23.670
that one renewal period.

00:51:23.670 --> 00:51:26.460
All of the mathematics and all
of the stuff we've been

00:51:26.460 --> 00:51:31.160
struggling with have all been
concerned with showing that

00:51:31.160 --> 00:51:37.760
when you go to the limit as t
goes to infinity, all of these

00:51:37.760 --> 00:51:39.320
things make sense.

00:51:39.320 --> 00:51:42.900
Question is not whether L equals
lambda W, but whether

00:51:42.900 --> 00:51:46.860
these quantities exist as
sensible time averages or is

00:51:46.860 --> 00:51:48.690
limiting ensemble averages.

00:51:48.690 --> 00:51:52.130
What we're dealing with
now is time averages.

00:51:52.130 --> 00:51:55.430
But you can do all of these
same things with limiting

00:51:55.430 --> 00:51:57.110
ensemble averages.

00:51:57.110 --> 00:51:59.950
And hopefully, you get the same
answer when you do it.

00:51:59.950 --> 00:52:02.450
And you have to go through a
lot of analysis in order to

00:52:02.450 --> 00:52:04.880
show that these are the same.

00:52:04.880 --> 00:52:11.630
But the idea that L is equal to
lambda W is, in some sense,

00:52:11.630 --> 00:52:14.215
much more simple and fundamental
than that.

00:52:16.960 --> 00:52:19.010
Last thing I want to do
is talk about the

00:52:19.010 --> 00:52:22.840
Pollaczek-Khinchin formula
for M/G/1 queues.

00:52:25.730 --> 00:52:32.220
The thing that you get here is
you improve on Little by one

00:52:32.220 --> 00:52:39.480
step, because now if you have
arrivals that are coming in a

00:52:39.480 --> 00:52:40.470
Poisson way--

00:52:40.470 --> 00:52:40.960
Yes?

00:52:40.960 --> 00:52:41.940
AUDIENCE: I'm sorry.

00:52:41.940 --> 00:52:43.410
I just have a question.

00:52:43.410 --> 00:52:47.575
Is there an easy way to tell
when we have the condition we

00:52:47.575 --> 00:52:51.740
need with probability
1 that restarts?

00:52:51.740 --> 00:52:57.355
That the system empties
out with probability--

00:52:57.355 --> 00:52:59.006
is there some kind of condition
like the expectation

00:52:59.006 --> 00:53:03.200
of the probable [INAUDIBLE]?

00:53:03.200 --> 00:53:06.980
PROFESSOR: Well certainly one
thing that you want is that

00:53:06.980 --> 00:53:10.780
the expected time between
arrivals has to be less than

00:53:10.780 --> 00:53:14.365
the expected service time if
you only have one server.

00:53:20.880 --> 00:53:27.090
And if you have n servers,
then you want the similar

00:53:27.090 --> 00:53:31.500
situation that the expected
inter-arrival arrival time of

00:53:31.500 --> 00:53:35.770
arriving customers is less than
or equal to the expected

00:53:35.770 --> 00:53:39.950
service time divided by n.

00:53:39.950 --> 00:53:41.710
Because you have n servers.

00:53:41.710 --> 00:53:47.270
Now the expected arrival time
is less than or equal to n

00:53:47.270 --> 00:53:52.340
times the expected service time
for each server, because

00:53:52.340 --> 00:53:55.230
you have n servers working
at a time.

00:53:55.230 --> 00:53:57.280
You have to be careful
on that one.

00:53:57.280 --> 00:54:02.540
Because you can dream up
situations where you can have

00:54:02.540 --> 00:54:04.940
half the servers busy
all the time.

00:54:04.940 --> 00:54:07.800
The system never empties out.

00:54:07.800 --> 00:54:10.660
And you always keep oscillating
between half of

00:54:10.660 --> 00:54:14.620
the servers full and all
of the servers full.

00:54:14.620 --> 00:54:17.320
You can even control systems
and you sometimes want to

00:54:17.320 --> 00:54:21.230
control systems so that you have
about half the servers

00:54:21.230 --> 00:54:23.500
operating at all time.

00:54:23.500 --> 00:54:26.310
If you have half the servers
operating at all times, then

00:54:26.310 --> 00:54:29.530
you have a fair amount
of leeway before

00:54:29.530 --> 00:54:31.340
the queue fills up.

00:54:31.340 --> 00:54:34.540
You also have a fair amount
of leeway before the queue

00:54:34.540 --> 00:54:35.940
empties out.

00:54:35.940 --> 00:54:38.750
And you have all these servers
that you're paying $100 an

00:54:38.750 --> 00:54:41.930
hour to and they're not
doing anything.

00:54:41.930 --> 00:54:43.900
So you'd like to keep, somehow,

00:54:43.900 --> 00:54:45.880
sitting in the middle.

00:54:45.880 --> 00:54:48.450
You would like to keep servers
busy doing other things when

00:54:48.450 --> 00:54:50.990
they're not busy serving
customers, to

00:54:50.990 --> 00:54:51.690
put it another way.

00:54:51.690 --> 00:54:54.959
AUDIENCE: So there is no way
to obviously tell when the

00:54:54.959 --> 00:54:55.893
[INAUDIBLE]?

00:54:55.893 --> 00:54:58.460
PROFESSOR: There is
no way in general.

00:54:58.460 --> 00:55:00.650
For particular simple
kinds of queueing

00:55:00.650 --> 00:55:04.060
systems, yes you can tell.

00:55:04.060 --> 00:55:06.280
We've been going through
some of that.

00:55:06.280 --> 00:55:09.190
For the M/G/1 queue, it's very
easy to tell, because there's

00:55:09.190 --> 00:55:10.440
a nice formula.

00:55:13.000 --> 00:55:15.560
And you'll see from the simple
formula that it's not as

00:55:15.560 --> 00:55:16.810
simple as it looks.

00:55:20.360 --> 00:55:23.540
Because first I'll tell you
what the formula is.

00:55:23.540 --> 00:55:30.430
Suppose that X1, X2, as usual,
are IID exponential arrivals

00:55:30.430 --> 00:55:31.520
at rate lambda.

00:55:31.520 --> 00:55:34.730
So the arrival process
is Poisson.

00:55:34.730 --> 00:55:40.050
That's what the M there means,
memoryless arrivals.

00:55:40.050 --> 00:55:44.940
V1, V2, and so forth are going
to be IID service times.

00:55:44.940 --> 00:55:48.010
We're going to assume they have
first and second moments.

00:55:48.010 --> 00:55:52.470
First moment of the service
time, we'll call it V bar.

00:55:52.470 --> 00:55:55.330
The second moment of the service
time, we'll call it V

00:55:55.330 --> 00:55:57.190
squared bar.

00:55:57.190 --> 00:56:01.500
What the Pollaczek-Khinchin
formula says is that the

00:56:01.500 --> 00:56:05.640
expected waiting time in queue,
namely before you get

00:56:05.640 --> 00:56:10.990
into service, expected waiting
time in queue is lambda times

00:56:10.990 --> 00:56:16.590
V squared bar divided by 2 times
1 minus rho, where rho

00:56:16.590 --> 00:56:21.080
is the service factor, which is
the arrival rate times the

00:56:21.080 --> 00:56:23.610
expected service time.

00:56:23.610 --> 00:56:26.810
This quantity here,
as the simplest

00:56:26.810 --> 00:56:29.420
answer to your question.

00:56:29.420 --> 00:56:37.060
If the service factor, which is
the arrival rate times the

00:56:37.060 --> 00:56:40.620
expected service time, if that's
bigger than 1, you're

00:56:40.620 --> 00:56:41.700
in trouble.

00:56:41.700 --> 00:56:43.260
If that's less than 1, normally

00:56:43.260 --> 00:56:44.990
you're not in trouble.

00:56:44.990 --> 00:56:49.940
This formula says it's something
worse than that.

00:56:49.940 --> 00:56:55.450
It says that as the service
factor, if the duty factor is

00:56:55.450 --> 00:57:00.150
less than 1, this quantity
here is positive.

00:57:00.150 --> 00:57:06.500
But if the second moment of the
service time is infinite,

00:57:06.500 --> 00:57:08.690
you're still going to spend
an infinite amount of time

00:57:08.690 --> 00:57:11.200
waiting in the queue.

00:57:11.200 --> 00:57:13.610
And that's unfortunate.

00:57:13.610 --> 00:57:17.870
You might expect this by now
after talking about residual

00:57:17.870 --> 00:57:19.750
life on all of these things.

00:57:19.750 --> 00:57:24.340
But it's still is unpleasant
to see it.

00:57:24.340 --> 00:57:31.180
When you go from the expected
number in the queue to the

00:57:31.180 --> 00:57:34.160
expected number in the
system, what is it?

00:57:34.160 --> 00:57:39.900
Well, the expected number in the
system over time is going

00:57:39.900 --> 00:57:45.070
to be expected number
in queue plus the

00:57:45.070 --> 00:57:47.040
expected service time.

00:57:49.690 --> 00:57:51.560
Yes.

00:57:51.560 --> 00:57:53.890
A customer comes into
the system.

00:57:53.890 --> 00:57:55.550
He waits in the queue
for a while.

00:57:55.550 --> 00:57:57.250
Then he gets served.

00:57:57.250 --> 00:57:59.500
This is his expected
service time.

00:57:59.500 --> 00:58:03.150
This his expected time
waiting for service.

00:58:03.150 --> 00:58:07.220
The expected number in this
system, how do you get that?

00:58:07.220 --> 00:58:11.420
We get that from this by using
Little's relationship.

00:58:11.420 --> 00:58:14.570
So the expected number in the
system is lambda squared times

00:58:14.570 --> 00:58:20.560
V squared bar over 2
times 1 minus rho.

00:58:20.560 --> 00:58:23.590
You multiply this
times lambda.

00:58:23.590 --> 00:58:26.740
So you get lambda squared
from this lambda.

00:58:26.740 --> 00:58:29.150
From the V bar, you
get lambda V bar,

00:58:29.150 --> 00:58:31.970
which is the duty factor.

00:58:31.970 --> 00:58:36.160
The expected number sitting in
the queue is just going to be

00:58:36.160 --> 00:58:38.020
this quantity.

00:58:38.020 --> 00:58:40.610
I won't derive that for you.

00:58:40.610 --> 00:58:41.860
You can work it out.

00:58:46.020 --> 00:58:48.990
If you look at some examples of
this, before we do try to

00:58:48.990 --> 00:58:55.840
derive it, expected number in
a queue for an M/D/1 system,

00:58:55.840 --> 00:59:03.000
namely Poisson arrivals,
deterministic service time.

00:59:03.000 --> 00:59:06.950
When you have deterministic
service time, the second

00:59:06.950 --> 00:59:11.940
moment of the service time is
just the first moment squared.

00:59:11.940 --> 00:59:14.350
Every arrival takes you exactly
the same amount of

00:59:14.350 --> 00:59:19.620
time to be served so that V
bar is that service time.

00:59:19.620 --> 00:59:22.780
V bar squared is a second moment
of the service time.

00:59:22.780 --> 00:59:26.490
So we just get the formula
we had before.

00:59:26.490 --> 00:59:28.245
I hope it's the formula
we had before.

00:59:34.310 --> 00:59:36.360
Lambda times V bar squared.

00:59:40.650 --> 00:59:46.450
Oh yes, rho is lambda
times V bar.

00:59:46.450 --> 00:59:50.240
So we have lambda times
V bar squared over 2

00:59:50.240 --> 00:59:52.260
times 1 minus rho.

00:59:52.260 --> 00:59:57.190
You look at exponential
inter-arrivals, suddenly you

00:59:57.190 --> 01:00:00.460
get twice as much
wait in queue.

01:00:00.460 --> 01:00:07.780
It is worse to have exponential
service times than

01:00:07.780 --> 01:00:13.300
it is to have Fx deterministic
service times.

01:00:13.300 --> 01:00:16.950
If you look at this strange kind
of distribution we talked

01:00:16.950 --> 01:00:23.080
about last time, a very, very
heavy tailed distribution in a

01:00:23.080 --> 01:00:28.490
sense, binary distribution where
V is equal to epsilon

01:00:28.490 --> 01:00:31.130
with probability 1
minus epsilon.

01:00:31.130 --> 01:00:33.980
And V is equal to
1 over epsilon

01:00:33.980 --> 01:00:36.810
with probability epsilon.

01:00:36.810 --> 01:00:43.490
Then if you work it out, the
expected W sub q is equal to

01:00:43.490 --> 01:00:46.010
rho over epsilon times
1 minus rho.

01:00:46.010 --> 01:00:48.960
This is the same kind of
behavior we had before.

01:00:48.960 --> 01:00:51.540
You have an enormous
residual life.

01:00:51.540 --> 01:00:54.900
And therefore, the time that
you wait for a customer in

01:00:54.900 --> 01:00:59.100
service to get finished
is very, very large.

01:00:59.100 --> 01:01:05.970
It's what you notice all the
time if you're waiting in some

01:01:05.970 --> 01:01:10.780
kind of system where many
of the customers

01:01:10.780 --> 01:01:12.680
get very rapid service.

01:01:12.680 --> 01:01:15.600
And every once in while,
there's a disaster.

01:01:15.600 --> 01:01:20.610
A good example of this is at an
airline, when you've missed

01:01:20.610 --> 01:01:22.140
your plane or something.

01:01:22.140 --> 01:01:24.860
And you go up to
a booth there.

01:01:24.860 --> 01:01:27.560
And many customers, it's
just a matter of

01:01:27.560 --> 01:01:29.040
printing them out a ticket.

01:01:29.040 --> 01:01:31.600
They're done in 20
or 30 seconds.

01:01:31.600 --> 01:01:34.110
Every once in while, there's
a customer who

01:01:34.110 --> 01:01:36.830
has enormous problems.

01:01:36.830 --> 01:01:40.100
And it takes an hour for
them to be served.

01:01:40.100 --> 01:01:42.790
That's exactly this
situation here.

01:01:42.790 --> 01:01:47.010
This says that the expected
waiting time in q, before you

01:01:47.010 --> 01:01:51.030
even get up to get your own
service has this factor of 1

01:01:51.030 --> 01:01:52.800
over epsilon in it.

01:01:52.800 --> 01:01:57.150
This is a nice kind formula,
because, in fact, it separates

01:01:57.150 --> 01:01:58.550
two different kinds of things.

01:02:03.540 --> 01:02:08.730
It has this one factor of 1 over
1 minus rho, which is a

01:02:08.730 --> 01:02:11.230
typical factor that you get.

01:02:11.230 --> 01:02:15.820
Because if you have a server
which is overwhelmed by too

01:02:15.820 --> 01:02:21.710
many customers, if the average
service time is very, very

01:02:21.710 --> 01:02:24.860
close to the average
inter-arrival time, then

01:02:24.860 --> 01:02:26.430
you're going to have
relatively large

01:02:26.430 --> 01:02:27.930
build ups of queues.

01:02:27.930 --> 01:02:29.890
Every once in while,
it'll empty out.

01:02:29.890 --> 01:02:31.410
But it will be rare.

01:02:31.410 --> 01:02:33.980
And you're going to have a
large amount of delay.

01:02:33.980 --> 01:02:38.220
This term here is a separate
kind of term.

01:02:38.220 --> 01:02:42.200
And this has to do simply with
a service time distribution

01:02:42.200 --> 01:02:46.580
that says that bad service time
distributions affect you

01:02:46.580 --> 01:02:49.880
in exactly the same way,
no matter what

01:02:49.880 --> 01:02:51.850
the duty factor is.

01:02:51.850 --> 01:02:54.580
So there's this nice separation
between these two

01:02:54.580 --> 01:02:57.640
things, which is just
the way it is.

01:03:04.600 --> 01:03:07.050
Why does the wait in
q go up with--

01:03:09.670 --> 01:03:11.230
that should be V squared bar.

01:03:11.230 --> 01:03:13.280
I'm sorry.

01:03:13.280 --> 01:03:18.100
Look at the time average weight,
the expected R of t,

01:03:18.100 --> 01:03:21.680
for the customer in service
to finish service.

01:03:21.680 --> 01:03:25.620
And picture of that
is down here.

01:03:25.620 --> 01:03:32.130
If you look at this over time,
what you see is at time 0,

01:03:32.130 --> 01:03:34.600
there's a customer that
just came in.

01:03:34.600 --> 01:03:39.010
The residual time until it gets
finished, residual life,

01:03:39.010 --> 01:03:41.500
is this triangle that
we're used to.

01:03:41.500 --> 01:03:45.560
Then at this point, the next
customer starts to be served.

01:03:45.560 --> 01:03:47.140
That time is there.

01:03:47.140 --> 01:03:50.260
And the third customer
starts to be served.

01:03:50.260 --> 01:03:53.120
The difference between this
and a renewal process we

01:03:53.120 --> 01:03:56.900
looked at before, is that when
we're looking at this residual

01:03:56.900 --> 01:04:00.760
life in a queueing system, every
once in while the queue

01:04:00.760 --> 01:04:01.930
empties out.

01:04:01.930 --> 01:04:04.720
And then there's a period
when nothing happens.

01:04:04.720 --> 01:04:08.510
And then suddenly again we start
these triangles here.

01:04:08.510 --> 01:04:11.570
So there's a question
as to how you

01:04:11.570 --> 01:04:14.850
evaluate this time average.

01:04:14.850 --> 01:04:16.690
Very difficult question,
isn't it?

01:04:19.690 --> 01:04:23.550
If you had to do this in a quiz,
how would you do it?

01:04:23.550 --> 01:04:25.270
Would you throw up your arms?

01:04:25.270 --> 01:04:28.610
Or would you say, well let
me just figure out

01:04:28.610 --> 01:04:29.680
what this has to be.

01:04:29.680 --> 01:04:31.580
I have these triangles here.

01:04:31.580 --> 01:04:34.050
I have this idle time here.

01:04:34.050 --> 01:04:35.530
How much idle time is there?

01:04:35.530 --> 01:04:39.160
How much triangle
time is there?

01:04:39.160 --> 01:04:43.230
The triangles are these one half
V sub i's that we're used

01:04:43.230 --> 01:04:45.460
to from before.

01:04:45.460 --> 01:04:50.740
And then this empty time here
is a 1 minus rho term.

01:04:50.740 --> 01:04:54.630
It's 1 minus the duty factor
of the system.

01:04:54.630 --> 01:04:57.370
And that's the amount of time
over a very long period of

01:04:57.370 --> 01:05:01.765
time, the fraction of time,
that the system is empty.

01:05:01.765 --> 01:05:05.370
That fraction has to be 1 minus
rho, because the system

01:05:05.370 --> 01:05:07.375
is busy with fraction rho.

01:05:07.375 --> 01:05:09.830
It's empty with fraction
1 minus rho.

01:05:09.830 --> 01:05:14.360
So you can write down the answer
to this without really

01:05:14.360 --> 01:05:17.175
having much of a justification
for it.

01:05:22.570 --> 01:05:27.785
So now we want to figure out
why this is what it is.

01:05:43.070 --> 01:05:45.490
This is all right.

01:05:45.490 --> 01:05:48.890
I want to take the limit as tau
goes to infinity of this

01:05:48.890 --> 01:05:52.470
integral here over time.

01:05:52.470 --> 01:05:56.980
And what that is going
to be is 1 over tau.

01:05:56.980 --> 01:06:00.900
And what this is is an analytic
way of finding that

01:06:00.900 --> 01:06:05.840
factor of 1 minus rho
that I really

01:06:05.840 --> 01:06:07.870
didn't talk about before.

01:06:07.870 --> 01:06:13.610
So this integral here, if I look
at it out to A of tau, is

01:06:13.610 --> 01:06:18.480
going to be 1 over tau times
the sum of all of these

01:06:18.480 --> 01:06:22.950
triangles here up to the number
of customers which have

01:06:22.950 --> 01:06:25.070
arrived up until time tau.

01:06:25.070 --> 01:06:29.190
So I have all of these out to
time tau, which is going to be

01:06:29.190 --> 01:06:30.330
out here now.

01:06:30.330 --> 01:06:33.510
So I sum all of these up.

01:06:33.510 --> 01:06:38.900
And now I ask the question, what
is that sum going to be

01:06:38.900 --> 01:06:42.210
and the limit as tau
goes to infinity?

01:06:42.210 --> 01:06:46.810
Well, we know how to evaluate
that kind of thing, because

01:06:46.810 --> 01:06:50.960
we've done it four or
five times already.

01:06:50.960 --> 01:07:02.560
The limit as tau goes to
infinity of 1 over tau times

01:07:02.560 --> 01:07:10.520
the summation from i equals
1 to A of tau Vi

01:07:10.520 --> 01:07:18.030
squared divided by 2.

01:07:18.030 --> 01:07:37.180
You can write this as limit of A
of tau over tau times 1 over

01:07:37.180 --> 01:07:41.975
A of tau times the sum
from i equals 1

01:07:41.975 --> 01:07:47.070
to A of tau Vi squared.

01:07:47.070 --> 01:07:52.890
Now as tau increases, this A of
tau is going to increase.

01:07:52.890 --> 01:07:55.690
These are IID random
variables.

01:07:55.690 --> 01:08:00.180
So what we're doing is
increasing the sample average

01:08:00.180 --> 01:08:02.640
of these IID random variables.

01:08:02.640 --> 01:08:08.200
So this quantity goes to what?

01:08:08.200 --> 01:08:19.939
It goes to the expected value of
V squared by the strong law

01:08:19.939 --> 01:08:21.189
of large numbers.

01:08:24.340 --> 01:08:28.250
And what does this
quantity go to?

01:08:28.250 --> 01:08:30.630
A of tau over tau, that's
the number of

01:08:30.630 --> 01:08:33.170
arrivals per unit time.

01:08:33.170 --> 01:08:36.054
And that goes to lambda.

01:08:36.054 --> 01:08:38.060
Is that what I got there?

01:08:42.460 --> 01:08:44.170
I forgot this 2 here.

01:08:47.800 --> 01:08:53.010
So that goes 1/2 expected
value of V squared.

01:08:53.010 --> 01:08:56.200
So this is the careful way of
doing it, where you bring all

01:08:56.200 --> 01:09:00.279
of this enormous power to bear
for something that you could

01:09:00.279 --> 01:09:02.690
intuit without using
any of the power.

01:09:05.649 --> 01:09:08.600
And what is W sub q then?

01:09:08.600 --> 01:09:13.850
What is the average time
we spend in the queue?

01:09:13.850 --> 01:09:16.370
Well you have two components
of time you

01:09:16.370 --> 01:09:17.819
spend in the queue.

01:09:17.819 --> 01:09:23.359
If you arrive when the server is
busy, you're going to have

01:09:23.359 --> 01:09:27.910
to wait this residual lifetime,
which is the

01:09:27.910 --> 01:09:32.350
expected value of r, which
is residual life.

01:09:32.350 --> 01:09:35.330
The other thing you're going
to have to wait for is for

01:09:35.330 --> 01:09:39.350
every customer in the
queue to be served.

01:09:39.350 --> 01:09:42.120
Now how long does that take?

01:09:42.120 --> 01:09:47.410
Well here you have to be quite
careful, because you have a

01:09:47.410 --> 01:09:51.210
number of customers that have
been built up in the queue.

01:09:51.210 --> 01:09:54.910
Each customer that's in the
queue has a service time

01:09:54.910 --> 01:09:57.450
associated with it.

01:09:57.450 --> 01:09:58.590
Think of a customer.

01:09:58.590 --> 01:10:02.580
When it comes in, it's given a
little packet with its service

01:10:02.580 --> 01:10:04.900
time in it.

01:10:04.900 --> 01:10:09.240
So you look at the sum
of all those terms.

01:10:09.240 --> 01:10:15.990
The question is, is the expected
number in the queue

01:10:15.990 --> 01:10:19.150
independent of the service
time of the

01:10:19.150 --> 01:10:20.400
customers in the queue?

01:10:23.370 --> 01:10:24.940
And how do you reason
that out?

01:10:28.070 --> 01:10:30.780
And at this point, you really
don't want to reason it out in

01:10:30.780 --> 01:10:32.770
terms of writing a
lot of equations.

01:10:32.770 --> 01:10:35.910
You want to just
think about it.

01:10:35.910 --> 01:10:39.320
How does a queueing system work,
if you have a first come

01:10:39.320 --> 01:10:41.680
first served queuing system?

01:10:41.680 --> 01:10:44.810
Customers come in.

01:10:44.810 --> 01:10:48.710
Each of them has a certain
amount of time to be served,

01:10:48.710 --> 01:10:53.050
which it's holding in a little
bag at its side, but which

01:10:53.050 --> 01:10:54.910
nobody else sees.

01:10:54.910 --> 01:10:57.740
And these are independent,
random variables.

01:10:57.740 --> 01:11:01.210
But when it comes in, there
are a certain number of

01:11:01.210 --> 01:11:03.210
customers in the queue
in front of it.

01:11:06.730 --> 01:11:09.700
So the number of customers that
are in the queue before

01:11:09.700 --> 01:11:12.770
it each have their own service
times sitting in their own

01:11:12.770 --> 01:11:14.970
little pockets.

01:11:14.970 --> 01:11:22.520
So the amount of time that it
takes for me to be served is

01:11:22.520 --> 01:11:25.650
this sum of all of the
previous times.

01:11:25.650 --> 01:11:27.650
And all these previous
times are

01:11:27.650 --> 01:11:29.630
independent, random variables.

01:11:29.630 --> 01:11:32.010
And each of them are independent
of how many

01:11:32.010 --> 01:11:35.725
customers are in the queue
at the time they arrive.

01:11:38.520 --> 01:11:42.180
So what I'm trying to argue is
that the number of customers

01:11:42.180 --> 01:11:47.900
in the queue at time t are
independent of the service

01:11:47.900 --> 01:11:52.420
time of each of those customers,
because the service

01:11:52.420 --> 01:11:57.130
times are not apparent to the
system until a person getting

01:11:57.130 --> 01:11:59.730
into service takes it out of his
pocket and looks at what

01:11:59.730 --> 01:12:02.130
his service time is.

01:12:02.130 --> 01:12:04.410
And that's unknown
to the system

01:12:04.410 --> 01:12:07.340
until the service starts.

01:12:07.340 --> 01:12:12.640
So when you take N q bar
independent of V bar0--

01:12:12.640 --> 01:12:15.110
Incidentally, if you read the
notes, this is explained in a

01:12:15.110 --> 01:12:19.640
slightly more mathematical than
customers having little

01:12:19.640 --> 01:12:21.950
pockets which they read.

01:12:21.950 --> 01:12:25.440
But it doesn't help
a whole lot.

01:12:25.440 --> 01:12:28.520
But anyway, when you go through
that argument, you

01:12:28.520 --> 01:12:31.030
then get this expression.

01:12:31.030 --> 01:12:34.010
And then you add a
little Little.

01:12:34.010 --> 01:12:37.430
Namely a little Little's
theorem, which says that N sub

01:12:37.430 --> 01:12:41.400
q is equal to lambda
times W sub q.

01:12:41.400 --> 01:12:45.850
So you can take this over
on the other side.

01:12:45.850 --> 01:12:50.090
And this gives you lambda
V squared over 2,

01:12:50.090 --> 01:12:52.430
which is this term.

01:12:52.430 --> 01:12:55.870
And at the same time,
you get 1 over--

01:12:59.790 --> 01:13:00.880
Excuse me.

01:13:00.880 --> 01:13:05.290
Lambda V squared over
2 is this term.

01:13:05.290 --> 01:13:15.540
And W q minus N q V bar is
1 minus is W q times 1--

01:13:15.540 --> 01:13:18.490
I'll do it at the board.

01:13:18.490 --> 01:13:19.570
Probably I'll see it.

01:13:19.570 --> 01:13:33.820
But W sub q is equal to lambda
V squared over 2.

01:13:33.820 --> 01:13:42.700
That's the expected value of
r plus lambda W sub Q bar.

01:13:42.700 --> 01:13:45.840
So we take this over
on this side.

01:13:45.840 --> 01:13:57.930
And then we get W q bar equals
lambda V squared over 2 times

01:13:57.930 --> 01:14:00.445
1 over 1 minus lambda.

01:14:06.430 --> 01:14:08.710
1 minus lambda V bar.

01:14:08.710 --> 01:14:10.850
Where did the V bar come from?

01:14:10.850 --> 01:14:11.926
Beats me.

01:14:11.926 --> 01:14:16.430
Oh, came from this
quantity there.

01:14:16.430 --> 01:14:29.430
Let's patch up our lambda
V bar times W sub q bar.

01:14:29.430 --> 01:14:32.396
So now we get lambda V bar.

01:14:36.700 --> 01:14:39.790
That is all I had
to say today.

01:14:39.790 --> 01:14:42.200
And so have any questions?