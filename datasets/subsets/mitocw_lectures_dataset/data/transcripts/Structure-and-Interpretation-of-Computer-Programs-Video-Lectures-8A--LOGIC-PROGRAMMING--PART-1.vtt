WEBVTT

00:00:00.000 --> 00:00:17.814
[MUSIC PLAYING BY J.S. BACH]

00:00:17.814 --> 00:00:20.040
PROFESSOR: The last time we
began having a look at how

00:00:20.040 --> 00:00:22.132
languages are constructed.

00:00:22.132 --> 00:00:26.050
Remember the main point that an
evaluator for, LISP, say,

00:00:26.050 --> 00:00:27.580
has two main elements.

00:00:27.580 --> 00:00:36.350
There is EVAL, and EVAL's job
is to take in an expression

00:00:36.350 --> 00:00:43.820
and an environment and turn that
into a procedure and some

00:00:43.820 --> 00:00:46.635
arguments and pass that
off to APPLY.

00:00:49.410 --> 00:00:52.250
And APPLY takes the procedure
in the arguments, turns that

00:00:52.250 --> 00:00:55.680
back into, in a general case,
another expression to be

00:00:55.680 --> 00:00:58.280
evaluated in another environment
and passes that

00:00:58.280 --> 00:01:00.770
off to EVAL, which passes it
to APPLY, and there's this

00:01:00.770 --> 00:01:02.750
whole big circle where things
go around and around and

00:01:02.750 --> 00:01:05.519
around until you get either to
some very primitive data or to

00:01:05.519 --> 00:01:07.740
a primitive procedure.

00:01:07.740 --> 00:01:12.080
See, what this cycle has to do
with is unwinding the means of

00:01:12.080 --> 00:01:15.020
combination and the means of
abstraction in the language.

00:01:15.020 --> 00:01:17.870
So for instance, you have
a procedure in LISP-- a

00:01:17.870 --> 00:01:21.320
procedure is a general way of
saying, I want to be able to

00:01:21.320 --> 00:01:25.392
evaluate this expression for
any value of the arguments,

00:01:25.392 --> 00:01:27.670
and that's sort of what's
going on here.

00:01:27.670 --> 00:01:28.510
That's what APPLY does.

00:01:28.510 --> 00:01:30.770
It says the general thing coming
in with the arguments

00:01:30.770 --> 00:01:33.380
reduces to the expression that's
the body, and then if

00:01:33.380 --> 00:01:35.790
that's a compound expression
or another procedure

00:01:35.790 --> 00:01:40.440
application, the thing will go
around and around the circle.

00:01:40.440 --> 00:01:43.040
Anyway, that's sort of the basic
structure of gee, pretty

00:01:43.040 --> 00:01:45.120
much any interpreter.

00:01:45.120 --> 00:01:46.720
The other thing that you saw
is once you have the

00:01:46.720 --> 00:01:49.080
interpreter in your hands, you
have all this power to start

00:01:49.080 --> 00:01:49.870
playing with the language.

00:01:49.870 --> 00:01:53.390
So you can make it dynamically
scoped, or you can put in

00:01:53.390 --> 00:01:55.960
normal order evaluation, or you
can add new forms to the

00:01:55.960 --> 00:01:57.680
language, whatever you like.

00:01:57.680 --> 00:02:00.570
Or more generally, there's this
notion of metalinguistic

00:02:00.570 --> 00:02:07.930
abstraction, which says that
part of your perspective as an

00:02:07.930 --> 00:02:09.970
engineer, as a software
engineer, but as an engineer

00:02:09.970 --> 00:02:15.270
in general is that you can gain
control of complexity by

00:02:15.270 --> 00:02:18.010
inventing new languages
sometimes.

00:02:18.010 --> 00:02:22.830
See, one way to think about
computer programming is that

00:02:22.830 --> 00:02:25.170
it only incidentally has
to do with getting a

00:02:25.170 --> 00:02:26.440
computer to do something.

00:02:26.440 --> 00:02:29.220
Primarily what a computer
program has to do with, it's a

00:02:29.220 --> 00:02:33.270
way of expressing ideas with
communicating ideas.

00:02:33.270 --> 00:02:36.300
And sometimes when you want to
communicate new kinds of

00:02:36.300 --> 00:02:39.770
ideas, you'd like to invent new
modes of expressing that.

00:02:39.770 --> 00:02:44.300
Well, today we're going to apply
this framework to build

00:02:44.300 --> 00:02:45.730
a new language.

00:02:45.730 --> 00:02:48.140
See, once we have the basic idea
of the interpreter, you

00:02:48.140 --> 00:02:50.830
can pretty much go build any
language that you like.

00:02:50.830 --> 00:02:54.370
So for example, we can go
off and build Pascal.

00:02:54.370 --> 00:02:58.820
And gee, we would worry about
syntax and parsing and various

00:02:58.820 --> 00:03:01.450
kinds of compiler optimizations,
and there are

00:03:01.450 --> 00:03:05.580
people who make honest livings
doing that, but at the level

00:03:05.580 --> 00:03:09.100
of abstraction that we're
talking, a Pascal interpreter

00:03:09.100 --> 00:03:13.020
would not look very different at
all from what you saw Gerry

00:03:13.020 --> 00:03:15.350
do last time.

00:03:15.350 --> 00:03:18.190
Instead of that, we'll spend
today building a really

00:03:18.190 --> 00:03:23.400
different language, a language
that encourages you to think

00:03:23.400 --> 00:03:26.980
about programming not in terms
of procedures, but in a really

00:03:26.980 --> 00:03:29.090
different way.

00:03:29.090 --> 00:03:33.650
And the lecture today is going
to be at two levels

00:03:33.650 --> 00:03:34.810
simultaneously.

00:03:34.810 --> 00:03:37.210
On the one hand, I'm going to
show you what this language

00:03:37.210 --> 00:03:40.410
looks like, and on the other
hand, I'll show you how it's

00:03:40.410 --> 00:03:41.010
implemented.

00:03:41.010 --> 00:03:43.250
And we'll build an
implementation in LISP and see

00:03:43.250 --> 00:03:44.220
how that works.

00:03:44.220 --> 00:03:48.730
And you should be drawing
lessons on two levels.

00:03:48.730 --> 00:03:52.190
The first is to realize
just how different a

00:03:52.190 --> 00:03:53.790
language can be.

00:03:53.790 --> 00:03:57.830
So if you think that the jump
from Fortran to LISP is a big

00:03:57.830 --> 00:04:01.560
deal, you haven't seen
anything yet.

00:04:01.560 --> 00:04:05.660
And secondly, you'll see that
even with such a very

00:04:05.660 --> 00:04:08.590
different language, which will
turn out to not have

00:04:08.590 --> 00:04:12.260
procedures at all and not talk
about functions at all, there

00:04:12.260 --> 00:04:16.570
will still be this basic cycle
of eval and apply that's

00:04:16.570 --> 00:04:19.170
unwinds the means of combination
and the means an

00:04:19.170 --> 00:04:20.950
abstraction.

00:04:20.950 --> 00:04:24.430
And then thirdly, as kind of a
minor but elegant technical

00:04:24.430 --> 00:04:27.720
point, you'll see a nice
use of streams to avoid

00:04:27.720 --> 00:04:28.970
backtracking.

00:04:32.330 --> 00:04:35.860
OK, well, I said that this
language is very different.

00:04:35.860 --> 00:04:41.620
To explain that, let's go back
to the very first idea that we

00:04:41.620 --> 00:04:44.710
talked about in this course, and
that was the idea of the

00:04:44.710 --> 00:04:48.780
distinction between the
declarative knowledge of

00:04:48.780 --> 00:04:50.240
mathematics--

00:04:50.240 --> 00:04:55.470
the definition of a square root
as a mathematical truth--

00:04:55.470 --> 00:04:59.080
and the idea that computer
science talks about the how to

00:04:59.080 --> 00:04:59.810
knowledge--

00:04:59.810 --> 00:05:03.700
contrast that definition of
square root with a program to

00:05:03.700 --> 00:05:05.970
compute a square root.

00:05:05.970 --> 00:05:08.042
That's where we started off.

00:05:08.042 --> 00:05:11.830
Well, wouldn't it be great if
you could somehow bridge this

00:05:11.830 --> 00:05:16.030
gap and make a programming
language which sort of did

00:05:16.030 --> 00:05:20.510
things, but you talked about
it in terms of truth, in

00:05:20.510 --> 00:05:22.380
declarative terms?

00:05:22.380 --> 00:05:24.110
So that would be a programming
language in

00:05:24.110 --> 00:05:27.690
which you specify facts.

00:05:27.690 --> 00:05:28.880
You tell it what is.

00:05:28.880 --> 00:05:30.950
You say what is true.

00:05:30.950 --> 00:05:34.220
And then when you want an
answer, somehow the language

00:05:34.220 --> 00:05:38.560
has built into it automatically
general kinds of

00:05:38.560 --> 00:05:41.200
how to knowledge so it can just
take your facts and it

00:05:41.200 --> 00:05:44.180
can evolve these methods on
its on using the facts you

00:05:44.180 --> 00:05:46.200
gave it and maybe some general
rules of logic.

00:05:49.330 --> 00:05:53.920
So for instance, I might go up
to this program and start

00:05:53.920 --> 00:05:55.645
telling it some things.

00:05:55.645 --> 00:06:08.920
So I might tell it that the
son of Adam is Abel.

00:06:08.920 --> 00:06:17.660
And I might tell it that the
son of Adam is Cain.

00:06:17.660 --> 00:06:24.670
And I might tell it that the
son of Cain is Enoch.

00:06:27.502 --> 00:06:37.550
And I might tell it that the son
of Enoch is Irad, and all

00:06:37.550 --> 00:06:41.190
through the rest of our chapter
whatever of Genesis,

00:06:41.190 --> 00:06:45.010
which ends up ending in Adah, by
the way, and this shows the

00:06:45.010 --> 00:06:48.760
genealogy of Adah from Cain.

00:06:48.760 --> 00:06:52.520
Anyway, once you tell
it these facts, you

00:06:52.520 --> 00:06:53.510
might ask it things.

00:06:53.510 --> 00:06:58.560
You might go up to your language
and say, who's the

00:06:58.560 --> 00:07:00.420
son of Adam?

00:07:00.420 --> 00:07:03.480
And you can very easily imagine
having a little

00:07:03.480 --> 00:07:06.460
general purpose search program
which would be able to go

00:07:06.460 --> 00:07:08.800
through and in response to that
say, oh yeah, there are

00:07:08.800 --> 00:07:10.930
two answers: the son of
Adam is Abel and the

00:07:10.930 --> 00:07:14.140
son of Adam is Cain.

00:07:14.140 --> 00:07:19.350
Or you might say, based on the
very same facts, who is Cain

00:07:19.350 --> 00:07:21.950
the son of?

00:07:21.950 --> 00:07:25.520
And then you can imagine
generating another slightly

00:07:25.520 --> 00:07:29.510
different search program which
would be able to go through

00:07:29.510 --> 00:07:33.760
and checked for who is
Cain, and son of, and

00:07:33.760 --> 00:07:35.890
come up with Adam.

00:07:35.890 --> 00:07:40.300
Or you might say, what's
the relationship

00:07:40.300 --> 00:07:42.070
between Cain and Enoch?

00:07:42.070 --> 00:07:46.340
And again, a minor variant
on that search program.

00:07:46.340 --> 00:07:48.160
You could figure out that
it said son of.

00:07:52.880 --> 00:07:56.960
But even here in this very
simple example, what you see

00:07:56.960 --> 00:08:00.460
is that a single fact, see, a
single fact like the son of

00:08:00.460 --> 00:08:04.230
Adam is Cain can be
used to answer

00:08:04.230 --> 00:08:06.520
different kinds of questions.

00:08:06.520 --> 00:08:10.540
You can say, who's the son of,
or you can say who's the son

00:08:10.540 --> 00:08:12.220
of Adam, or you can say
what's the relation

00:08:12.220 --> 00:08:12.970
between Adam and Cain?

00:08:12.970 --> 00:08:17.370
Those are different questions
being run by different

00:08:17.370 --> 00:08:22.474
traditional procedures all
based on the same fact.

00:08:22.474 --> 00:08:24.960
And that's going to be the
essence of the power of this

00:08:24.960 --> 00:08:30.050
programming style, that one
piece of declarative knowledge

00:08:30.050 --> 00:08:33.150
can be used as the basis for
a lot of different kinds of

00:08:33.150 --> 00:08:36.440
how-to knowledge, as opposed
to the kinds of procedures

00:08:36.440 --> 00:08:39.010
we're writing where you sort of
tell it what input you're

00:08:39.010 --> 00:08:41.490
giving it and what
answer you want.

00:08:41.490 --> 00:08:43.710
So for instance, our square
root program can perfectly

00:08:43.710 --> 00:08:48.900
well answer the question, what's
the square root of 144?

00:08:48.900 --> 00:08:51.290
But in principle, the
mathematical definition of

00:08:51.290 --> 00:08:52.830
square root tells you
other things.

00:08:52.830 --> 00:08:57.590
Like it could say, what is
17 the square root of?

00:08:57.590 --> 00:08:58.590
And that would be have
to be answered

00:08:58.590 --> 00:09:01.920
by a different program.

00:09:01.920 --> 00:09:05.700
So the mathematical definition,
or in general, the

00:09:05.700 --> 00:09:09.540
facts that you give it are
somehow unbiased as to what

00:09:09.540 --> 00:09:10.900
the question is.

00:09:10.900 --> 00:09:13.240
Whereas the programs we tend to
write specifically because

00:09:13.240 --> 00:09:15.230
they are how-to knowledge
tend to be looking

00:09:15.230 --> 00:09:17.700
for a specific answer.

00:09:17.700 --> 00:09:19.530
So that's going to be one
characteristic of what we're

00:09:19.530 --> 00:09:21.810
talking about.

00:09:21.810 --> 00:09:23.480
We can go on.

00:09:23.480 --> 00:09:26.420
We can imagine that we've
given our language

00:09:26.420 --> 00:09:27.710
some sort of facts.

00:09:27.710 --> 00:09:30.020
Now let's give it some
rules of inference.

00:09:30.020 --> 00:09:35.100
We can say, for instance,
if the--

00:09:35.100 --> 00:09:36.510
make up some syntax here--

00:09:36.510 --> 00:09:41.580
if the son of x is y--

00:09:41.580 --> 00:09:45.650
I'll put question marks to
indicate variables here--

00:09:45.650 --> 00:10:01.800
if the son of x is y and the
son of y is z, then the

00:10:01.800 --> 00:10:09.320
grandson of x is z.

00:10:09.320 --> 00:10:15.370
So I can imagine telling my
machine that rule and then

00:10:15.370 --> 00:10:17.680
being able to say, for
instance, who's

00:10:17.680 --> 00:10:20.610
the grandson of Adam?

00:10:20.610 --> 00:10:24.790
Or who is Irad the
grandson of?

00:10:24.790 --> 00:10:28.080
Or deduce all grandson
relationships you possibly can

00:10:28.080 --> 00:10:29.330
from this information.

00:10:31.220 --> 00:10:34.580
We can imagine somehow the
language knowing how to do

00:10:34.580 --> 00:10:35.830
that automatically.

00:10:42.640 --> 00:10:45.200
Let me give you maybe a little
bit more concrete example.

00:10:49.610 --> 00:10:53.700
Here's a procedure that merges
two sorted lists.

00:10:53.700 --> 00:11:01.370
So x and y are two, say, lists
of numbers, lists of distinct

00:11:01.370 --> 00:11:04.780
numbers, if you like, that
are in increasing order.

00:11:04.780 --> 00:11:08.560
And what merge does is take
two such lists and combine

00:11:08.560 --> 00:11:10.040
them into a list where
everything's in increasing

00:11:10.040 --> 00:11:15.330
order, and this is a pretty easy
programs that you ought

00:11:15.330 --> 00:11:16.390
to be able to write.

00:11:16.390 --> 00:11:18.860
It says, if x is empty,
the answer is y.

00:11:18.860 --> 00:11:21.180
If y is empty, the
answer is x.

00:11:21.180 --> 00:11:22.990
Otherwise, you compare the
first two elements.

00:11:22.990 --> 00:11:25.540
So you pick out the first thing
in x and the first thing

00:11:25.540 --> 00:11:31.060
in y, and then depending on
which of those first elements

00:11:31.060 --> 00:11:35.500
is less, you stick the lower
one on to the result a

00:11:35.500 --> 00:11:40.150
recursively merging, either
chopping the first one off x

00:11:40.150 --> 00:11:42.400
or chopping the first
one off y.

00:11:42.400 --> 00:11:43.960
That's a standard
kind of program.

00:11:46.470 --> 00:11:48.620
Let's look at the logic.

00:11:48.620 --> 00:11:51.660
Let's forget about the program
and look at the logic on which

00:11:51.660 --> 00:11:53.820
that procedure is based.

00:11:53.820 --> 00:11:56.860
See, there's some logic which
says, gee, if the first one is

00:11:56.860 --> 00:12:00.240
less, then we get the answer by
sticking something onto the

00:12:00.240 --> 00:12:03.350
result of recursively merging
the rest. So let's try and be

00:12:03.350 --> 00:12:05.420
explicit about what that
logic is that's

00:12:05.420 --> 00:12:08.430
making the program work.

00:12:08.430 --> 00:12:10.130
So here's one piece.

00:12:10.130 --> 00:12:13.820
Here's the piece of the program
which recursively

00:12:13.820 --> 00:12:19.980
chops down x if the first
thing in x is smaller.

00:12:19.980 --> 00:12:22.030
And if you want to be very
explicit about what the logic

00:12:22.030 --> 00:12:27.120
is there, what's really going on
is a deduction, which says,

00:12:27.120 --> 00:12:31.790
if you know that some list, that
we'll call cdr of x, and

00:12:31.790 --> 00:12:40.480
y merged to form z, and you know
that a is less than the

00:12:40.480 --> 00:12:47.570
first thing in y, then you know
that if you put a onto

00:12:47.570 --> 00:12:55.820
the cdr of x, then that result
and y merge to form a onto z.

00:12:55.820 --> 00:12:58.720
And what that is, that's the
underlying piece of logic--

00:12:58.720 --> 00:13:01.620
I haven't written it as a
program, I wrote it a sort of

00:13:01.620 --> 00:13:05.480
deduction that's underneath this
particular clause that

00:13:05.480 --> 00:13:09.410
says we can use the
recursion there.

00:13:09.410 --> 00:13:11.910
And then similar, here's
the other clause

00:13:11.910 --> 00:13:14.000
just to complete it.

00:13:14.000 --> 00:13:16.880
The other clause is based on
this piece of logic, which is

00:13:16.880 --> 00:13:19.460
almost the same and I won't go
through it, and then there's

00:13:19.460 --> 00:13:22.730
the n cases where we tested for
null, and that's based on

00:13:22.730 --> 00:13:26.920
the idea that for any x, x and
the empty list merge to form

00:13:26.920 --> 00:13:30.740
an x, or for any y, the empty
list and y merge to form y.

00:13:33.360 --> 00:13:39.340
OK, so there's a piece of
procedure and the logic on

00:13:39.340 --> 00:13:41.740
which it's based.

00:13:41.740 --> 00:13:44.750
And notice a big difference.

00:13:44.750 --> 00:13:51.050
The procedure looked
like this: it

00:13:51.050 --> 00:13:52.900
said there was a box--

00:13:52.900 --> 00:13:55.410
and all the things we've been
doing have the characteristic

00:13:55.410 --> 00:13:57.890
we have boxes and things going
in and things going out--

00:13:57.890 --> 00:14:04.480
there was this box called merge,
and in came an x and y,

00:14:04.480 --> 00:14:07.550
and out came an answer.

00:14:07.550 --> 00:14:09.340
That's the character of the
procedure that we wrote.

00:14:13.160 --> 00:14:14.660
These rules don't
look like that.

00:14:14.660 --> 00:14:17.620
These rules talk about
a relation.

00:14:17.620 --> 00:14:23.030
There's some sort of relation
that in those slides I called

00:14:23.030 --> 00:14:25.370
mrege-to-form.

00:14:25.370 --> 00:14:29.200
So I said x and y merge
to form z, and

00:14:29.200 --> 00:14:32.610
somehow this is a function.

00:14:32.610 --> 00:14:32.850
Right?

00:14:32.850 --> 00:14:36.070
The answer is a function of x
and y, and here what I have is

00:14:36.070 --> 00:14:39.720
a relation between
three things.

00:14:39.720 --> 00:14:43.120
And I'm not going to specify
which is the input and which

00:14:43.120 --> 00:14:44.200
is the output.

00:14:44.200 --> 00:14:48.690
And the reason I want to say
that is because in principle,

00:14:48.690 --> 00:14:51.300
we could use exactly those same
logic rules to answer a

00:14:51.300 --> 00:14:54.570
lot of different questions.

00:14:54.570 --> 00:14:56.750
So we can say, for instance--

00:14:56.750 --> 00:14:59.050
imagine giving our machine
those rules of logic.

00:14:59.050 --> 00:15:01.400
Not the program, the underlying
rules of logic.

00:15:01.400 --> 00:15:04.750
Then it ought to be
able to say--

00:15:04.750 --> 00:15:06.770
we could ask it--

00:15:06.770 --> 00:15:20.910
1, 3, 7 and 2, 4, 8 merge
to form what?

00:15:20.910 --> 00:15:23.880
And that's a question it ought
to be able to answer.

00:15:23.880 --> 00:15:26.480
That's exactly the same
question that our list

00:15:26.480 --> 00:15:28.180
procedure answered.

00:15:28.180 --> 00:15:33.750
But the exact same rules should
also be able to answer

00:15:33.750 --> 00:15:41.760
a question like this: 1, 3, 7
and what merged to form 1, 2,

00:15:41.760 --> 00:15:45.560
3, 4, 7, 8?

00:15:45.560 --> 00:15:48.120
The same rules of logic can
answer this, although the

00:15:48.120 --> 00:15:50.880
procedure we wrote can't
answer that question.

00:15:50.880 --> 00:15:56.070
Or we might be able to
say what and what

00:15:56.070 --> 00:16:07.900
else merge to form--

00:16:07.900 --> 00:16:13.780
what and what else merge to
form 1, 2, 3, 4, 7, 8?

00:16:13.780 --> 00:16:16.320
And the thing should be able
to go through, if it really

00:16:16.320 --> 00:16:20.470
can apply that logic, and deduce
all, whatever is, 2 to

00:16:20.470 --> 00:16:22.540
the sixth answers to
that question.

00:16:25.600 --> 00:16:28.790
It could be 1 and the rest, or
it could be 1, 2 and the rest.

00:16:28.790 --> 00:16:32.490
Or it could be 1 and 3 and 7 and
the rest. There's a whole

00:16:32.490 --> 00:16:33.410
bunch of answers.

00:16:33.410 --> 00:16:36.830
And in principle, the
logic should be

00:16:36.830 --> 00:16:38.550
enough to deduce that.

00:16:38.550 --> 00:16:44.540
So there are going to be two big
differences in the kind of

00:16:44.540 --> 00:16:48.370
program we're going to look
at and not only list, but

00:16:48.370 --> 00:16:49.850
essentially all the programming
you've probably

00:16:49.850 --> 00:16:54.150
done so far in pretty much any
language you can think of.

00:16:54.150 --> 00:16:57.620
The first is, we're not going
to be computing functions.

00:17:00.800 --> 00:17:03.770
We're not going to be talking
about things that take input

00:17:03.770 --> 00:17:04.410
and output.

00:17:04.410 --> 00:17:06.890
We're going to be talking
about relations.

00:17:06.890 --> 00:17:09.180
And that means in principle,
these relations don't have

00:17:09.180 --> 00:17:11.089
directionality.

00:17:11.089 --> 00:17:14.569
So the knowledge that you
specify to answer this

00:17:14.569 --> 00:17:19.220
question, that same knowledge
should also allow you to

00:17:19.220 --> 00:17:21.345
answer these other questions
and conversely.

00:17:26.310 --> 00:17:30.590
And the second issue is that
since we're talking about

00:17:30.590 --> 00:17:33.150
relations, these
relations don't

00:17:33.150 --> 00:17:35.610
necessarily have one answer.

00:17:35.610 --> 00:17:37.480
So that third question down
there doesn't have a

00:17:37.480 --> 00:17:39.415
particular answer, it has a
whole bunch of answers.

00:17:42.270 --> 00:17:44.640
Well, that's where
we're going.

00:17:44.640 --> 00:17:48.620
This style of programming, by
the way, is called logic

00:17:48.620 --> 00:17:51.310
programming, for kind
of obvious reasons.

00:17:56.160 --> 00:18:02.440
And people who do logic
programming say that-- they

00:18:02.440 --> 00:18:04.150
have this little phrase-- they
say the point of logic

00:18:04.150 --> 00:18:10.190
programming is that you use
logic to express what is true,

00:18:10.190 --> 00:18:15.190
you use logic to check whether
something is true, and you use

00:18:15.190 --> 00:18:19.200
logic to find out
what is true.

00:18:19.200 --> 00:18:23.300
The best known logic programming
language, as you

00:18:23.300 --> 00:18:25.780
probably know, is
called Prolog.

00:18:25.780 --> 00:18:31.010
The language that we're going
to implement this morning is

00:18:31.010 --> 00:18:33.110
something we call the query
language, and it essentially

00:18:33.110 --> 00:18:35.320
has the essence of prologue.

00:18:35.320 --> 00:18:38.340
It can do about the same stuff,
although it's a lot

00:18:38.340 --> 00:18:42.390
slower because we're going to
implement it in LISP rather

00:18:42.390 --> 00:18:44.210
than building a particular
compiler.

00:18:44.210 --> 00:18:47.510
We're going to interpret it on
top of the LISP interpreter.

00:18:47.510 --> 00:18:48.950
But other than that,
it can do about the

00:18:48.950 --> 00:18:49.750
same stuff as prolog.

00:18:49.750 --> 00:18:52.160
It has about the same power
and about the same

00:18:52.160 --> 00:18:54.696
limitations.

00:18:54.696 --> 00:18:56.120
All right, let's break
for question.

00:19:00.040 --> 00:19:04.010
STUDENT: Yes, could you please
repeat what the three things

00:19:04.010 --> 00:19:06.720
you use logic programming
to find?

00:19:06.720 --> 00:19:09.120
In other words, to find what is
true, learn what is true--

00:19:09.120 --> 00:19:09.840
what is the?

00:19:09.840 --> 00:19:10.520
PROFESSOR: Right.

00:19:10.520 --> 00:19:15.850
Sort of a logic programmer's
little catechism.

00:19:15.850 --> 00:19:22.610
You use logic to express what
is true, like these rules.

00:19:22.610 --> 00:19:26.120
You use logic to check whether
something is true, and that's

00:19:26.120 --> 00:19:28.550
the kind of question I
didn't answer here.

00:19:28.550 --> 00:19:29.720
I might say--

00:19:29.720 --> 00:19:33.620
another question I could put
down here is to say, is it

00:19:33.620 --> 00:19:41.400
true that 1, 3, 7 and 2, 4, 8
merge to form 1, 2, 6, 10 And

00:19:41.400 --> 00:19:45.690
that same logic should
be enough to say no.

00:19:45.690 --> 00:19:49.190
So I use logic to check what is
true, and then you also use

00:19:49.190 --> 00:19:50.480
logic to find out what's true.

00:20:04.060 --> 00:20:04.570
All right.

00:20:04.570 --> 00:20:06.138
Let's break.

00:20:06.138 --> 00:20:22.106
[MUSIC PLAYING BY J.S. BACH]

00:20:22.106 --> 00:20:47.590
[MUSIC ENDS]

00:20:47.590 --> 00:21:02.901
[MUSIC PLAYING BY J.S. BACH]

00:21:02.901 --> 00:21:06.810
PROFESSOR: OK, let's go ahead
and take a look at this query

00:21:06.810 --> 00:21:10.520
language and operation.

00:21:10.520 --> 00:21:12.890
The first thing you might
notice, when I put up that

00:21:12.890 --> 00:21:15.390
little biblical database, is
that it's nice to be able to

00:21:15.390 --> 00:21:18.900
ask this language questions
in relation to some

00:21:18.900 --> 00:21:21.330
collection of facts.

00:21:21.330 --> 00:21:26.060
So let's start off and make a
little collection of facts.

00:21:26.060 --> 00:21:31.700
This is a tiny fragment of
personnel records for a Boston

00:21:31.700 --> 00:21:34.440
high tech company, and here's
a piece of the personnel

00:21:34.440 --> 00:21:37.500
records of Ben Bitdiddle.

00:21:37.500 --> 00:21:41.470
And Ben Bitdiddle is the
computer wizard in this

00:21:41.470 --> 00:21:44.660
company, he's the underpaid
computer

00:21:44.660 --> 00:21:46.420
wizard in this company.

00:21:46.420 --> 00:21:49.330
His supervisor is all
Oliver Warbucks,

00:21:49.330 --> 00:21:52.150
and here's his address.

00:21:52.150 --> 00:21:55.220
So the format is we're giving
this information: job, salary,

00:21:55.220 --> 00:21:57.300
supervisor, address.

00:21:57.300 --> 00:21:59.250
And there are some other
conventions.

00:21:59.250 --> 00:22:01.570
Computer here means that Ben
works in the computer

00:22:01.570 --> 00:22:03.590
division, and his
position in the

00:22:03.590 --> 00:22:06.440
computer division is wizard.

00:22:06.440 --> 00:22:07.580
Here's somebody else.

00:22:07.580 --> 00:22:13.860
Alyssa, Alyssa P. Hacker is a
computer programmer, and she

00:22:13.860 --> 00:22:17.550
works for Ben, and she
lives in Cambridge.

00:22:17.550 --> 00:22:19.990
And there's another programmer
who works for Ben

00:22:19.990 --> 00:22:22.820
who's Lem E. Tweakit.

00:22:22.820 --> 00:22:26.330
And there's a programmer
trainee, who is Louis

00:22:26.330 --> 00:22:30.100
Reasoner, and he works
for Alyssa.

00:22:30.100 --> 00:22:34.830
And the big wheel of the company
doesn't work for

00:22:34.830 --> 00:22:37.010
anybody, right?

00:22:37.010 --> 00:22:38.110
That's Oliver Warbucks.

00:22:38.110 --> 00:22:43.080
Anyway, what we're going to do
is ask questions about that

00:22:43.080 --> 00:22:44.971
little world.

00:22:44.971 --> 00:22:47.410
And that'll be a sample
world that we're

00:22:47.410 --> 00:22:48.660
going to do logic in.

00:22:51.420 --> 00:22:55.810
Let me just write up here, for
probably the last time, what I

00:22:55.810 --> 00:22:57.600
said is the very most important
thing you should get

00:22:57.600 --> 00:23:00.760
out of this course, and that
is, when somebody tells you

00:23:00.760 --> 00:23:03.440
about a language,
you say, fine--

00:23:03.440 --> 00:23:15.050
what are the primitives, what
are the means of combination,

00:23:15.050 --> 00:23:18.480
how do you put the primitives
together, and then how do you

00:23:18.480 --> 00:23:24.690
abstract them, how do you
abstract the compound pieces

00:23:24.690 --> 00:23:26.740
so you can use them as pieces
to make something more

00:23:26.740 --> 00:23:28.500
complicated?

00:23:28.500 --> 00:23:31.440
And we've said this a whole
bunch of times already, but

00:23:31.440 --> 00:23:32.690
it's worth saying again.

00:23:36.210 --> 00:23:36.670
Let's start.

00:23:36.670 --> 00:23:38.040
The primitives.

00:23:38.040 --> 00:23:41.660
Well, there's really only one
primitive, and the primitive

00:23:41.660 --> 00:23:44.400
in this language is
called a query.

00:23:44.400 --> 00:23:46.810
A primitive query.

00:23:46.810 --> 00:23:48.060
Let's look at some primitive
queries.

00:23:52.160 --> 00:23:53.100
Job x.

00:23:53.100 --> 00:23:55.550
Who is a computer programmer?

00:23:55.550 --> 00:24:04.700
Or find every fact in the
database that matches job of

00:24:04.700 --> 00:24:06.640
the x is computer programmer.

00:24:06.640 --> 00:24:08.470
And you see a little
syntax here.

00:24:08.470 --> 00:24:11.330
Things without question marks
are meant to be literal,

00:24:11.330 --> 00:24:13.940
question mark x means that's a
variable, and this thing will

00:24:13.940 --> 00:24:18.110
match, for example, the fact
that Alyssa P. Hacker is a

00:24:18.110 --> 00:24:21.930
computer programmer, or
x is Alyssa P. Hacker.

00:24:26.820 --> 00:24:29.170
Or more generally, I could
have something with two

00:24:29.170 --> 00:24:30.750
variables in it.

00:24:30.750 --> 00:24:39.530
I could say, the job of x is
computer something, and

00:24:39.530 --> 00:24:42.140
that'll match computer wizard.

00:24:42.140 --> 00:24:44.865
So there's something here: type
will match wizard, or

00:24:44.865 --> 00:24:49.390
type will match programmer,
or x might match

00:24:49.390 --> 00:24:50.370
various certain things.

00:24:50.370 --> 00:24:53.270
So there are, in our little
example, only three facts in

00:24:53.270 --> 00:24:55.150
that database that
match that query.

00:24:59.210 --> 00:25:04.910
Let's see, just to show you some
syntax, the same query,

00:25:04.910 --> 00:25:11.490
this query doesn't match the job
of x, doesn't match Lewis

00:25:11.490 --> 00:25:13.200
Reasoner, the reason for that
is when I write something

00:25:13.200 --> 00:25:17.160
here, what I mean is that this
is going to be a list of two

00:25:17.160 --> 00:25:22.730
symbols, of which the first is
the word computer, and the

00:25:22.730 --> 00:25:24.810
second can be anything.

00:25:24.810 --> 00:25:28.130
And Lewis's job description here
has three symbols, so it

00:25:28.130 --> 00:25:30.340
doesn't match.

00:25:30.340 --> 00:25:35.360
And just to show you a little
bit of syntax, the more

00:25:35.360 --> 00:25:37.920
general thing I might want to
type is a thing with a dot

00:25:37.920 --> 00:25:42.550
here, and this is just standard
this notation for

00:25:42.550 --> 00:25:46.560
saying, this is a list, of which
the first element is the

00:25:46.560 --> 00:25:49.350
word computers, and THE
REST, is something

00:25:49.350 --> 00:25:50.600
that I'll call type.

00:25:53.730 --> 00:25:56.930
So this one would match.

00:25:56.930 --> 00:26:00.000
Lewis's job is computer
programmer trainee, and type

00:26:00.000 --> 00:26:04.690
here would be the cdr of this
list. It would be the list

00:26:04.690 --> 00:26:06.960
programmer trainee.

00:26:06.960 --> 00:26:08.410
And that kind of dot
processing is done

00:26:08.410 --> 00:26:10.460
automatically by the
LISP reader.

00:26:15.900 --> 00:26:17.760
Well, let's actually try this.

00:26:17.760 --> 00:26:20.810
The idea is I'm going to type
in queries in this language,

00:26:20.810 --> 00:26:23.630
and answers will come out.

00:26:23.630 --> 00:26:25.180
Let's look at this.

00:26:25.180 --> 00:26:30.000
I can go up and say, who works
in the computer division?

00:26:30.000 --> 00:26:39.730
Job of x is computer dot y.

00:26:39.730 --> 00:26:42.562
Doesn't matter what I call
the dummy variables.

00:26:42.562 --> 00:26:45.690
It says the answers to that, and
it's found four answers.

00:26:48.650 --> 00:26:51.380
Or I can go off and say, tell
me about everybody's

00:26:51.380 --> 00:26:52.505
supervisor.

00:26:52.505 --> 00:26:56.610
So I'll put in the query,
the primitive query, the

00:26:56.610 --> 00:26:59.390
supervisor of x is y.

00:27:02.860 --> 00:27:05.540
There are all the supervisor
relationships I know.

00:27:05.540 --> 00:27:08.830
Or I could go type in, who
lives in Cambridge?

00:27:08.830 --> 00:27:20.670
So I can say, the address of x
is Cambridge dot anything.

00:27:25.090 --> 00:27:26.585
And only one person lives
in Cambridge.

00:27:30.820 --> 00:27:32.170
OK, so those are primitive
queries.

00:27:32.170 --> 00:27:34.460
And you see what happens to
basic interaction with the

00:27:34.460 --> 00:27:38.140
system is you type in a query,
and it types out

00:27:38.140 --> 00:27:39.620
all possible answers.

00:27:39.620 --> 00:27:43.100
Or another way to say that: it
finds out all the possible

00:27:43.100 --> 00:27:45.330
values of those variables x and
y or t or whatever I've

00:27:45.330 --> 00:27:50.380
called them, and it types out
all ways of taking that query

00:27:50.380 --> 00:27:53.080
and instantiating it--

00:27:53.080 --> 00:27:56.250
remember that from the rule
system lecture-- instantiates

00:27:56.250 --> 00:27:59.150
the query with all possible
values for those variables and

00:27:59.150 --> 00:28:01.000
then types out all of them.

00:28:01.000 --> 00:28:02.370
And there are a lot
of ways you can

00:28:02.370 --> 00:28:03.350
arrange a logic language.

00:28:03.350 --> 00:28:06.010
Prolog, for instance, does
something slightly different.

00:28:06.010 --> 00:28:08.980
Rather than typing back your
query, prolog would type out,

00:28:08.980 --> 00:28:12.230
x equals this and y equals that,
or x sequels this and y

00:28:12.230 --> 00:28:12.650
equals that.

00:28:12.650 --> 00:28:16.430
And that's a very surface level
thing, you can decide

00:28:16.430 --> 00:28:19.070
what you like.

00:28:19.070 --> 00:28:20.760
OK.

00:28:20.760 --> 00:28:21.340
All right.

00:28:21.340 --> 00:28:23.390
So the primitives in
this language?

00:28:23.390 --> 00:28:24.570
Only one, right?

00:28:24.570 --> 00:28:27.230
Primitive query.

00:28:31.360 --> 00:28:31.650
OK.

00:28:31.650 --> 00:28:34.330
Means of combination.

00:28:34.330 --> 00:28:39.770
Let's look at some compound
queries in this language.

00:28:39.770 --> 00:28:41.790
Here's one.

00:28:41.790 --> 00:28:47.250
This one says, tell me all the
people who work in the

00:28:47.250 --> 00:28:49.810
computer division.

00:28:49.810 --> 00:28:52.610
Tell me all the people who work
in the computer division

00:28:52.610 --> 00:28:53.860
together with their
supervisors.

00:28:56.800 --> 00:29:00.220
The way I write that is
the query is and.

00:29:00.220 --> 00:29:04.920
And the job of the x is computer
something or other.

00:29:04.920 --> 00:29:07.560
And job of x is computer
dot y.

00:29:07.560 --> 00:29:11.650
And the supervisor of x is z.

00:29:11.650 --> 00:29:13.570
Tell me all the people in
the computer division--

00:29:13.570 --> 00:29:16.460
that's this-- together with
their supervisors.

00:29:16.460 --> 00:29:20.290
And notice in this query I
have three variables--

00:29:20.290 --> 00:29:23.660
x, y, and z.

00:29:23.660 --> 00:29:29.450
And this x is supposed to
be the same as that x.

00:29:29.450 --> 00:29:31.560
So x works in the computer
division, and the

00:29:31.560 --> 00:29:34.810
supervisor of x is z.

00:29:34.810 --> 00:29:37.250
Let's try another one.

00:29:37.250 --> 00:29:39.005
So one means of combination
is and.

00:29:41.540 --> 00:29:45.790
Who are all the people who
make more than $30,000?

00:29:45.790 --> 00:29:51.640
And the salary of some person
p is some amount a.

00:29:54.590 --> 00:30:00.600
And when I go and look at a,
a is greater than $30,000.

00:30:00.600 --> 00:30:06.300
And LISP value here is a little
piece of interface that

00:30:06.300 --> 00:30:10.600
interfaces the query language
to the underlying LISP.

00:30:10.600 --> 00:30:13.540
And what the LISP value allows
you to do is call any LISP

00:30:13.540 --> 00:30:17.180
predicate inside a query.

00:30:17.180 --> 00:30:19.110
So here I'm using the LISP
predicate greater than, so I

00:30:19.110 --> 00:30:21.020
say LISP value.

00:30:21.020 --> 00:30:21.750
This I say and.

00:30:21.750 --> 00:30:28.190
So all the people whose salary
is greater than $30,000.

00:30:28.190 --> 00:30:31.270
Or here's a more complicated
one.

00:30:31.270 --> 00:30:36.150
Tell me all the people who work
in the computer division

00:30:36.150 --> 00:30:38.560
who do not have a supervisor
who works in

00:30:38.560 --> 00:30:39.810
the computer division.

00:30:42.790 --> 00:30:45.510
and x works in the computer
division.

00:30:45.510 --> 00:30:47.780
The job of x is computer
dot y.

00:30:47.780 --> 00:30:55.570
And it's not the case that both
x has a supervisor z and

00:30:55.570 --> 00:30:59.620
the job of z is computer
something or other.

00:30:59.620 --> 00:31:04.050
All right, so again, this x has
got to be that x, and this

00:31:04.050 --> 00:31:05.710
z is going to be that z.

00:31:09.390 --> 00:31:11.380
And then you see another means
a combination, not.

00:31:17.272 --> 00:31:20.880
All right, well, let's
look at that.

00:31:20.880 --> 00:31:22.400
It works the same way.

00:31:22.400 --> 00:31:33.110
I can go up to the machine and
say and the job of the x is

00:31:33.110 --> 00:31:35.400
computer dot y.

00:31:38.480 --> 00:31:46.600
And the supervisor of x is z.

00:31:46.600 --> 00:31:50.794
And I typed that in
like a query.

00:31:50.794 --> 00:31:55.680
And what it types back, what
you see are the queries I

00:31:55.680 --> 00:31:58.930
typed in instantiated by
all possible answers.

00:31:58.930 --> 00:32:02.000
And then you see there
are a lot of answers.

00:32:02.000 --> 00:32:02.190
All right.

00:32:02.190 --> 00:32:05.230
So the means of combination
in this language--

00:32:05.230 --> 00:32:07.550
and this is why it's called
a logic language--

00:32:07.550 --> 00:32:09.800
are logical operations.

00:32:09.800 --> 00:32:16.120
Means of combinations are things
like AND and NOT and

00:32:16.120 --> 00:32:18.490
there's one I didn't show
you, which is OR.

00:32:18.490 --> 00:32:24.310
And then I showed you LISP
value, which is not logic, of

00:32:24.310 --> 00:32:26.365
course, but is a little special
hack to interface that

00:32:26.365 --> 00:32:29.250
to LISP so you can
get more power.

00:32:29.250 --> 00:32:32.690
Those are the means
of combination.

00:32:32.690 --> 00:32:34.160
OK, the means of abstraction.

00:32:34.160 --> 00:32:35.410
What we'd like to do--

00:32:38.330 --> 00:32:42.260
let's go back for second and
look at that last slide.

00:32:42.260 --> 00:32:45.010
We might like to take very
complicated thing, the idea

00:32:45.010 --> 00:32:48.800
that someone works in a division
but does not have a

00:32:48.800 --> 00:32:52.400
supervisor in the division.

00:32:52.400 --> 00:32:56.090
And as before, name that.

00:32:56.090 --> 00:32:58.800
Well, if someone works in a
division and does not have a

00:32:58.800 --> 00:33:00.950
supervisor who works in that
division, that means that

00:33:00.950 --> 00:33:02.750
person is a big shot.

00:33:02.750 --> 00:33:08.370
So let's make a rule that
somebody x is a big shot in

00:33:08.370 --> 00:33:16.760
some department if x works in
the department and it's not

00:33:16.760 --> 00:33:19.610
the case that x has a supervisor
who works in the

00:33:19.610 --> 00:33:21.510
department.

00:33:21.510 --> 00:33:22.940
So this is our means
of abstraction.

00:33:22.940 --> 00:33:24.190
This is a rule.

00:33:26.220 --> 00:33:27.580
And a rule has three parts.

00:33:30.970 --> 00:33:33.450
The thing that says
it's a rule.

00:33:33.450 --> 00:33:37.530
And then there's the conclusion
of the rule.

00:33:37.530 --> 00:33:40.000
And then there's the
body of the rule.

00:33:40.000 --> 00:33:42.150
And you can read this as a piece
of logic which says, if

00:33:42.150 --> 00:33:46.940
you know that the body of the
rule is true, then you can

00:33:46.940 --> 00:33:49.470
conclude that the conclusion
is true.

00:33:49.470 --> 00:33:52.640
Or in order to deduce that
x is a big shot in some

00:33:52.640 --> 00:33:57.480
department, it's enough
to verify that.

00:33:57.480 --> 00:33:58.820
So that's what rules
look like.

00:34:03.280 --> 00:34:07.180
Let's go back and look at that
merge example that I did

00:34:07.180 --> 00:34:08.110
before the break.

00:34:08.110 --> 00:34:11.610
Let's look at how that would
look in terms of rules.

00:34:11.610 --> 00:34:14.030
I'm going to take the logic I
put up and just change it into

00:34:14.030 --> 00:34:15.500
a bunch of rules
in this format.

00:34:18.739 --> 00:34:19.350
We have a rule.

00:34:19.350 --> 00:34:21.710
Remember, there was this
thing merge-to-form.

00:34:21.710 --> 00:34:28.489
There is a rule that says,
the empty list and y

00:34:28.489 --> 00:34:29.620
merge to form y.

00:34:29.620 --> 00:34:30.870
This is the rule conclusion.

00:34:33.210 --> 00:34:36.650
And notice this particular
rule has no body.

00:34:36.650 --> 00:34:40.010
And in this language, a rule
with no body is something that

00:34:40.010 --> 00:34:41.239
is always true.

00:34:41.239 --> 00:34:42.510
You can always assume
that's true.

00:34:45.190 --> 00:34:47.530
And there was another piece of
logic that said anything in

00:34:47.530 --> 00:34:49.460
the empty list merged to
form the anything.

00:34:49.460 --> 00:34:50.900
That's this.

00:34:50.900 --> 00:34:55.510
A rule y and the empty
list merge to form y.

00:34:55.510 --> 00:34:58.060
Those corresponded to the two
end cases in our merge

00:34:58.060 --> 00:35:00.890
procedure, but now we're talking
about logic, not about

00:35:00.890 --> 00:35:03.490
procedures.

00:35:03.490 --> 00:35:07.560
Then we had another rule, which
said if you know how

00:35:07.560 --> 00:35:09.830
shorter things merge, you
can put them together.

00:35:09.830 --> 00:35:15.340
So this says, if you have a list
x and y and z, and if you

00:35:15.340 --> 00:35:19.530
want to deduce that a dot x--
this means constant a onto x,

00:35:19.530 --> 00:35:23.160
or a list whose first thing
is a and whose rest is x--

00:35:23.160 --> 00:35:26.230
so if you want to deduce that
a dot x and b dot y merge to

00:35:26.230 --> 00:35:27.480
form b dot c--

00:35:30.570 --> 00:35:34.070
that would say you merge these
two lists a x and b y and

00:35:34.070 --> 00:35:37.680
you're going to get something
that starts with b--

00:35:37.680 --> 00:35:41.880
you can deduce that if you know
that it's the case both

00:35:41.880 --> 00:35:48.690
that a dot x and y merge to form
z and a is larger than b.

00:35:48.690 --> 00:35:52.610
So when I merge them, b will
come first in the list. That's

00:35:52.610 --> 00:35:56.050
a little translation of the
logic rule that I wrote in

00:35:56.050 --> 00:35:57.960
pseudo-English before.

00:35:57.960 --> 00:35:59.870
And then just for completeness,

00:35:59.870 --> 00:36:03.130
here's the other case.

00:36:03.130 --> 00:36:08.170
a dot x and b dot y merge to
form a dot z if x and b dot y

00:36:08.170 --> 00:36:12.190
merged to form z and
b is larger than a.

00:36:12.190 --> 00:36:15.610
So that's a little program that
I've typed in in this

00:36:15.610 --> 00:36:17.416
language, and now let's
look at it run.

00:36:21.900 --> 00:36:27.740
So I typed in the merge rules
before, and I could use this

00:36:27.740 --> 00:36:28.510
like a procedure.

00:36:28.510 --> 00:36:39.590
I could say merge to form
1 and 3 and 2 and 7.

00:36:39.590 --> 00:36:43.330
So here I'm using it like
the LISP procedure.

00:36:43.330 --> 00:36:46.940
Now it's going to think about
that for a while and apply

00:36:46.940 --> 00:36:48.190
these rules.

00:36:50.780 --> 00:36:52.800
So it found an answer.

00:36:52.800 --> 00:36:55.370
Now it's going to see if there
are any other answers but it

00:36:55.370 --> 00:36:57.810
doesn't know a priori there's
only one answer.

00:36:57.810 --> 00:37:00.790
So it's sitting here checking
all possibilities, and it

00:37:00.790 --> 00:37:01.970
says, no more.

00:37:01.970 --> 00:37:02.775
Done.

00:37:02.775 --> 00:37:05.210
So there I've used those
rules like a procedure.

00:37:05.210 --> 00:37:08.340
Or remember the whole point is
that I can ask different kinds

00:37:08.340 --> 00:37:10.220
of questions.

00:37:10.220 --> 00:37:24.590
I could say merge to form, let's
see, how about 2 and a.

00:37:24.590 --> 00:37:29.440
Some list of two elements which
I know starts with 2,

00:37:29.440 --> 00:37:34.600
and the other thing I don't
know, and x and some other

00:37:34.600 --> 00:37:39.510
list merge to form
a 1, 2, 3 and 4.

00:37:42.760 --> 00:37:44.590
So now it's going to
think about that.

00:37:44.590 --> 00:37:45.840
It's got to find--

00:37:48.070 --> 00:37:49.095
so it found one possibility.

00:37:49.095 --> 00:37:53.830
It said a could be 3, and x
could be the list 1, 4.

00:37:53.830 --> 00:37:57.220
And now, again, it's got to
check because it doesn't a

00:37:57.220 --> 00:37:59.050
priori know that there
aren't any other

00:37:59.050 --> 00:38:00.300
possibilities going on.

00:38:03.680 --> 00:38:10.660
Or like I said, I could say
something like merge to form,

00:38:10.660 --> 00:38:17.275
like, what and what else merge
to form 1, 2, 3, 4, 5?

00:38:24.340 --> 00:38:25.590
Now it's going to think
about that.

00:38:28.490 --> 00:38:30.310
And there are a lot of answers
that it might get.

00:38:35.180 --> 00:38:37.920
And what you see is here you're
really paying the price

00:38:37.920 --> 00:38:39.170
of slowness.

00:38:42.210 --> 00:38:43.880
And kind of for three reasons.

00:38:43.880 --> 00:38:47.630
One is that this language
is doubly interpreted.

00:38:47.630 --> 00:38:50.100
Whereas in a real
implementation, you would go

00:38:50.100 --> 00:38:52.190
compile this down to primitive
operations.

00:38:52.190 --> 00:38:56.410
The other reason is that this
particular algorithm for

00:38:56.410 --> 00:38:58.380
merges is doubly recursive.

00:38:58.380 --> 00:39:01.020
So it's going to take
a very long time.

00:39:01.020 --> 00:39:06.710
And eventually, this is going
to go through and find--

00:39:06.710 --> 00:39:07.130
find what?

00:39:07.130 --> 00:39:08.730
Two to the fifth possible
answers.

00:39:12.140 --> 00:39:14.830
And you see they come out in
some fairly arbitrary order,

00:39:14.830 --> 00:39:17.100
depending on which order
it's going to be

00:39:17.100 --> 00:39:20.160
trying these rules.

00:39:20.160 --> 00:39:21.530
In fact, what we're going
to do when they edit the

00:39:21.530 --> 00:39:24.310
videotape is speed
all this up.

00:39:24.310 --> 00:39:26.600
Don't you like taking
out these weights?

00:39:26.600 --> 00:39:28.250
And don't you wish you could
do that in your demos?

00:39:32.840 --> 00:39:34.260
Anyway, it's still
grinding there.

00:39:39.220 --> 00:39:41.170
Anyway, there are 32
possibilities--

00:39:41.170 --> 00:39:42.630
we won't wait for it to
print out all of them.

00:39:47.850 --> 00:39:49.410
OK, so the needs of abstraction
in this

00:39:49.410 --> 00:39:50.660
language are rules.

00:39:53.630 --> 00:39:57.410
So we take some bunch of things
that are put together

00:39:57.410 --> 00:40:00.350
with logic and we name them.

00:40:00.350 --> 00:40:02.080
And you can think of
that as naming a

00:40:02.080 --> 00:40:03.410
particular pattern of logic.

00:40:03.410 --> 00:40:05.810
Or you can think of that as
saying, if you want to deduce

00:40:05.810 --> 00:40:10.660
some conclusion, you can apply
those rules of logic.

00:40:10.660 --> 00:40:13.420
And those are three elements
of this language.

00:40:13.420 --> 00:40:15.670
Let's break now, and then we'll
talk about how it's

00:40:15.670 --> 00:40:16.920
actually implemented.

00:40:22.747 --> 00:40:27.380
STUDENT: Does using LISP value
primitive or whatever

00:40:27.380 --> 00:40:31.770
interfere with your means to go
both directions on a query?

00:40:31.770 --> 00:40:33.530
PROFESSOR: OK, that's a--

00:40:33.530 --> 00:40:37.840
the question is, does using LISP
value interfere with the

00:40:37.840 --> 00:40:40.090
ability to go both directions
on the query?

00:40:40.090 --> 00:40:43.850
We haven't really talked about
the implementation yet, but

00:40:43.850 --> 00:40:46.890
the answer is, yes, it can.

00:40:46.890 --> 00:40:50.510
In general, as we'll
see at the end--

00:40:50.510 --> 00:40:53.330
although I really won't
to go into details--

00:40:53.330 --> 00:40:58.140
it's fairly complicated,
especially when you use either

00:40:58.140 --> 00:40:59.780
not or LISP value--

00:40:59.780 --> 00:41:04.310
or actually, if you use anything
besides only and, it

00:41:04.310 --> 00:41:07.350
becomes very complicated
to say when

00:41:07.350 --> 00:41:08.700
these things will work.

00:41:08.700 --> 00:41:10.360
They won't work quite
in all situations.

00:41:10.360 --> 00:41:14.300
I'll talk about that at the end
of the second half today.

00:41:14.300 --> 00:41:17.180
But the answer to your question
is, yes, by dragging

00:41:17.180 --> 00:41:22.000
in a lot more power from LISP
value, you lose some of the

00:41:22.000 --> 00:41:24.170
principal power of logic
programming.

00:41:24.170 --> 00:41:28.090
That's a trade-off that
you have to make.

00:41:28.090 --> 00:41:30.390
OK, let's take a break.