WEBVTT

00:00:00.000 --> 00:00:01.984
[SQUEAKING]

00:00:01.984 --> 00:00:04.464
[RUSTLING]

00:00:04.464 --> 00:00:08.432
[CLICKING]

00:00:25.230 --> 00:00:26.805
MICHAEL SIPSER: OK, everybody.

00:00:26.805 --> 00:00:27.305
Let's begin.

00:00:30.000 --> 00:00:31.850
Welcome back.

00:00:31.850 --> 00:00:36.110
Good to see you
all here on Zoom.

00:00:36.110 --> 00:00:38.420
So we're going to
pick up with what

00:00:38.420 --> 00:00:43.410
we had been
discussing last week,

00:00:43.410 --> 00:00:50.550
which was an introduction
to NP-completeness.

00:00:50.550 --> 00:00:56.010
So we're following on our
description of time complexity.

00:00:56.010 --> 00:00:58.670
We started talking
about the time

00:00:58.670 --> 00:01:04.160
complexity classes, the class
P, the nondeterministic classes,

00:01:04.160 --> 00:01:07.130
the class NP, P versus
NP problem, and then

00:01:07.130 --> 00:01:10.193
leading to this discussion
of NP-completeness.

00:01:10.193 --> 00:01:12.110
And today we're going
to prove the big theorem

00:01:12.110 --> 00:01:15.890
in the field, which really
kind of got things going back

00:01:15.890 --> 00:01:19.430
in the early 1970s
by Cook and Levin

00:01:19.430 --> 00:01:22.850
that there was actually
an NP-complete problem,

00:01:22.850 --> 00:01:25.550
that SAT in particular is
an NP-complete problem.

00:01:25.550 --> 00:01:29.060
And then we'll also talk about
3SAT, which is a useful tool.

00:01:32.000 --> 00:01:37.760
Just to remember, we had this
notion of NP-completeness.

00:01:37.760 --> 00:01:40.910
A language is NP-complete
if it's in NP.

00:01:40.910 --> 00:01:43.670
And everything else in NP
is polynomial time reducible

00:01:43.670 --> 00:01:45.420
to it.

00:01:45.420 --> 00:01:48.630
And if an NP-complete
problem turns out

00:01:48.630 --> 00:01:50.730
to have a polynomial
time solution,

00:01:50.730 --> 00:01:54.420
then every NP-problem has
a polynomial time solution.

00:01:54.420 --> 00:01:57.420
And that's part of the
importance of NP-completeness,

00:01:57.420 --> 00:02:04.620
because since we consider it
unlikely that P equals NP,

00:02:04.620 --> 00:02:09.539
and that there probably are
some problems that are an NP,

00:02:09.539 --> 00:02:12.660
but are not solvable
in polynomial time.

00:02:12.660 --> 00:02:16.110
That would imply that
an NP-complete problem

00:02:16.110 --> 00:02:17.680
would have that property.

00:02:17.680 --> 00:02:21.450
And so proving a problem
being NP-complete

00:02:21.450 --> 00:02:23.610
is evidence, very
strong evidence,

00:02:23.610 --> 00:02:27.010
that it doesn't have a
polynomial time solution.

00:02:27.010 --> 00:02:29.140
And so therefore it's
called intractable.

00:02:29.140 --> 00:02:30.390
It's a very difficult problem.

00:02:33.590 --> 00:02:39.280
So the way we are going
to typically show problems

00:02:39.280 --> 00:02:42.910
NP-complete is by reducing
a known-- a previously

00:02:42.910 --> 00:02:46.390
known NP-complete
problem to that problem.

00:02:46.390 --> 00:02:50.500
Often it's 3SAT, as we've seen
in several examples already,

00:02:50.500 --> 00:02:53.030
or it could be
some other example.

00:02:53.030 --> 00:02:57.760
So let's just survey briefly
the things that we've already--

00:02:57.760 --> 00:03:01.940
languages that we've already
seen, which are NP-complete.

00:03:01.940 --> 00:03:04.480
So we have the
languages SAT, which

00:03:04.480 --> 00:03:07.220
has a direct reduction
from every NP problem.

00:03:07.220 --> 00:03:17.630
And so we're going to show
that today, that every NP

00:03:17.630 --> 00:03:20.270
language is polynomial time
reducible to SAT, which

00:03:20.270 --> 00:03:23.790
is, in turn, reducible to 3SAT.

00:03:23.790 --> 00:03:28.730
And we showed
previously that 3SAT

00:03:28.730 --> 00:03:30.530
is reducible to
CLIQUE and HAMPATH.

00:03:33.460 --> 00:03:37.330
And in recitation,
if you went to that,

00:03:37.330 --> 00:03:40.690
they showed that the SUBSET-SUM
problem and the undirected

00:03:40.690 --> 00:03:45.670
HAMPATH problems are also
reducible from previously

00:03:45.670 --> 00:03:46.480
shown--

00:03:46.480 --> 00:03:50.680
well, either from
3SAT, or in the case

00:03:50.680 --> 00:03:52.240
of the undirected
HAMPATH problem,

00:03:52.240 --> 00:03:55.630
it's reducible from
the HAMPATH problem.

00:03:55.630 --> 00:04:03.190
And the conclusion, once we have
these two blue reducibilities

00:04:03.190 --> 00:04:07.450
shown, then we know that all of
these problems are NP-complete.

00:04:10.150 --> 00:04:12.810
So the class NP
basically breaks down

00:04:12.810 --> 00:04:16.740
into the NP-complete
problems, P problems, problems

00:04:16.740 --> 00:04:19.500
that are in P, and then
there might be problems

00:04:19.500 --> 00:04:20.605
in between as well.

00:04:20.605 --> 00:04:22.230
So there are some
problems that are not

00:04:22.230 --> 00:04:23.880
known to be in either category.

00:04:23.880 --> 00:04:26.070
And in fact, there's
an old theorem

00:04:26.070 --> 00:04:28.560
which shows that if P
is different from NP,

00:04:28.560 --> 00:04:30.750
then there are
actually problems that

00:04:30.750 --> 00:04:32.800
are in the intermediate state.

00:04:32.800 --> 00:04:38.530
And of course, it's
possible that P equals NP,

00:04:38.530 --> 00:04:40.660
and then everything
collapses down

00:04:40.660 --> 00:04:44.230
to be the same with the
tiny exception of the sigma

00:04:44.230 --> 00:04:47.380
star and empty set languages,
which can never be complete.

00:04:50.620 --> 00:04:51.850
OK.

00:04:51.850 --> 00:04:54.220
So that's our quick review.

00:04:54.220 --> 00:04:55.960
Here is a check-in
that I'm going

00:04:55.960 --> 00:04:59.925
to use to get us ready
for the big proof

00:04:59.925 --> 00:05:02.050
that we're going to be
spending most of the lecture

00:05:02.050 --> 00:05:06.010
on about showing
SAT is NP-complete,

00:05:06.010 --> 00:05:07.930
but just to define a
little notation, which

00:05:07.930 --> 00:05:10.990
you might have-- maybe
you've seen already.

00:05:10.990 --> 00:05:14.450
But I'm going to do it in
the form of a check-in.

00:05:14.450 --> 00:05:18.550
So I'm sure you've
all seen the big sum

00:05:18.550 --> 00:05:23.440
notation using a big
sigma to represent a sum

00:05:23.440 --> 00:05:29.410
over some set of possibilities.

00:05:29.410 --> 00:05:32.170
Just as there is the big
sigma notation, we have--

00:05:32.170 --> 00:05:35.110
you can have other
operations that

00:05:35.110 --> 00:05:39.080
apply to a set of elements.

00:05:39.080 --> 00:05:42.550
So in this case, we're going
to be seeing the big end AND

00:05:42.550 --> 00:05:44.920
and the big OR operation--

00:05:44.920 --> 00:05:47.380
it's going to--
notation, which is

00:05:47.380 --> 00:05:52.540
going to allow us to talk about
taking the AND of many things

00:05:52.540 --> 00:05:55.420
or the OR of many
things, because we're

00:05:55.420 --> 00:05:57.490
going to be building
these Boolean formulas.

00:05:57.490 --> 00:06:00.910
And so ANDs and ORs are going
to be the operations that we're

00:06:00.910 --> 00:06:02.510
going to be focusing on.

00:06:02.510 --> 00:06:05.950
And so just as an
example just to make sure

00:06:05.950 --> 00:06:08.510
we're all understanding
this notation,

00:06:08.510 --> 00:06:15.550
if you have two strings x
and y written out in terms

00:06:15.550 --> 00:06:16.723
of their individual symbols.

00:06:16.723 --> 00:06:17.890
So they're both of length n.

00:06:17.890 --> 00:06:19.630
So x is x1 to xn.

00:06:19.630 --> 00:06:22.150
Y is y1 to yn.

00:06:22.150 --> 00:06:26.120
And now I write the
following expression.

00:06:26.120 --> 00:06:32.260
The big AND for i ranging
between 1 and n of xi

00:06:32.260 --> 00:06:33.670
equal to yi.

00:06:33.670 --> 00:06:37.810
If that big AND is true, what
does it tell us about x and y?

00:06:37.810 --> 00:06:40.300
And I'm just going to offer
you two possibilities,

00:06:40.300 --> 00:06:44.980
that either x and y agree
on some symbol or are equal,

00:06:44.980 --> 00:06:47.590
namely that they
agree on every symbol.

00:06:47.590 --> 00:06:52.300
And so let's just pull
that up as a quick poll

00:06:52.300 --> 00:06:53.395
to get us going here.

00:06:56.393 --> 00:06:58.560
I just want to make sure
you understand the notation

00:06:58.560 --> 00:07:00.630
because we're going
to be using that a lot

00:07:00.630 --> 00:07:08.640
in describing the polynomial
time reduction from languages

00:07:08.640 --> 00:07:11.920
in NP to the SAT language.

00:07:11.920 --> 00:07:12.420
OK.

00:07:12.420 --> 00:07:15.930
I think most of you
have got the idea.

00:07:15.930 --> 00:07:17.310
So let's finish this up quick.

00:07:22.140 --> 00:07:24.870
So another 15
seconds, please, just

00:07:24.870 --> 00:07:26.430
to give you a chance
to participate.

00:07:31.680 --> 00:07:32.670
OK.

00:07:32.670 --> 00:07:36.270
We're going to close this poll.

00:07:36.270 --> 00:07:38.430
Last chance, last call.

00:07:38.430 --> 00:07:39.660
All right.

00:07:39.660 --> 00:07:43.470
So yes, the big AND--

00:07:43.470 --> 00:07:50.160
as most of you can see, the
big AND says that x1 equals y1,

00:07:50.160 --> 00:07:57.050
and x2 equals y2, and x3
equals y3 so they're all--

00:07:57.050 --> 00:08:00.860
every symbol in x is equal to
the corresponding symbol in y.

00:08:00.860 --> 00:08:04.220
If we had a big OR
instead of a big AND,

00:08:04.220 --> 00:08:05.868
then A would be
the correct answer,

00:08:05.868 --> 00:08:07.910
because then just there
would be some place where

00:08:07.910 --> 00:08:11.120
they agree instead of every
place where they agree.

00:08:14.090 --> 00:08:20.795
So let's then start to
launch into this big theorem.

00:08:23.470 --> 00:08:27.880
The proof itself is
a mass of details

00:08:27.880 --> 00:08:30.020
with one underlying idea.

00:08:30.020 --> 00:08:33.159
And in fact, it's an
idea we've seen before.

00:08:33.159 --> 00:08:35.500
But let's-- before we
get ahead of ourselves,

00:08:35.500 --> 00:08:38.809
let's just understand
what we're trying to do.

00:08:38.809 --> 00:08:43.900
So we want to show that this
language SAT is NP-complete.

00:08:43.900 --> 00:08:45.280
We remember what SAT is.

00:08:45.280 --> 00:08:47.860
It's Boolean formulas
that are satisfiable.

00:08:50.500 --> 00:08:54.090
So we already showed that the
SAT prob-- so being NP-complete

00:08:54.090 --> 00:08:56.430
means it has these two features.

00:08:56.430 --> 00:09:00.400
It's in NP, and everything
in NP is reducible to it.

00:09:00.400 --> 00:09:03.840
So first of all, SAT is in
NP, as we've already seen.

00:09:03.840 --> 00:09:07.230
The witness that shows
the formula is satisfiable

00:09:07.230 --> 00:09:09.450
is simply the
satisfying assignment

00:09:09.450 --> 00:09:12.220
that evaluates to true.

00:09:12.220 --> 00:09:16.650
So now we're going to pick
some language in NP, A,

00:09:16.650 --> 00:09:20.490
and show that A is polynomial
time reducible to SAT.

00:09:23.350 --> 00:09:25.990
So this is going to apply
to any language A in NP.

00:09:25.990 --> 00:09:28.480
So let A be some language in NP.

00:09:28.480 --> 00:09:31.030
It's decided by some
nondeterministic Turing machine

00:09:31.030 --> 00:09:33.900
M in time n to the k.

00:09:33.900 --> 00:09:36.810
That's what it
means to be an NP.

00:09:36.810 --> 00:09:39.300
I'm going to be ignoring
the constant factors when

00:09:39.300 --> 00:09:41.400
we could carry that
throughout the proof.

00:09:41.400 --> 00:09:44.220
It just would make
the description

00:09:44.220 --> 00:09:46.470
a little more
cumbersome and wouldn't

00:09:46.470 --> 00:09:47.640
change any of the ideas.

00:09:47.640 --> 00:09:51.660
So let's just say it's M
runs in time n to the k,

00:09:51.660 --> 00:09:57.660
and recognizes or decides
this language in A.

00:09:57.660 --> 00:10:02.940
So it's a
nondeterministic machine.

00:10:02.940 --> 00:10:04.980
So we've got to give
a polynomial time

00:10:04.980 --> 00:10:06.930
reduction from A to SAT.

00:10:06.930 --> 00:10:10.930
That's what I have to
demonstrate to you.

00:10:10.930 --> 00:10:12.960
So what does that
reduction look like?

00:10:12.960 --> 00:10:16.260
It's going to map strings,
which may or may not

00:10:16.260 --> 00:10:21.730
be in A, to formulas, which
may or may not be satisfied.

00:10:21.730 --> 00:10:24.460
That's what the
reduction has got to do.

00:10:24.460 --> 00:10:31.720
So saying that out
more formally is it's

00:10:31.720 --> 00:10:34.030
going to take some
string w and map it

00:10:34.030 --> 00:10:36.910
to a formula we'll
call phi sub M, w,

00:10:36.910 --> 00:10:45.770
where M is the machine that
decides A and w is the input.

00:10:45.770 --> 00:10:49.910
So f is going to map w
to this formula, where

00:10:49.910 --> 00:10:53.300
the string is in the language
exactly when the formula is

00:10:53.300 --> 00:10:54.930
satisfied.

00:10:54.930 --> 00:10:57.480
And the formula is going
to depend upon M and w.

00:10:57.480 --> 00:11:00.310
That's why it just has--
it's written in this way.

00:11:00.310 --> 00:11:02.460
So we've seen that
kind of thing before.

00:11:02.460 --> 00:11:05.760
So basically, my job--

00:11:05.760 --> 00:11:09.330
we have this language
A that's in NP.

00:11:09.330 --> 00:11:13.650
And now we have some string
w, which might be in A,

00:11:13.650 --> 00:11:19.510
or maybe not is in A. And I have
to quickly in polynomial time

00:11:19.510 --> 00:11:24.470
now produce a formula which is
going to be satisfiable exactly

00:11:24.470 --> 00:11:30.640
when the string w is in A.

00:11:30.640 --> 00:11:33.270
So how is that
formula going to work?

00:11:33.270 --> 00:11:35.350
How can I produce
such a formula?

00:11:35.350 --> 00:11:39.190
Which I mean, of course, I don't
know whether w is in A or not,

00:11:39.190 --> 00:11:42.400
because I'm just the
polynomial time reduction.

00:11:42.400 --> 00:11:45.460
And A is an NP language.

00:11:45.460 --> 00:11:47.800
So polynomial time
probably is not

00:11:47.800 --> 00:11:50.740
enough to solve
whether w is in A.

00:11:50.740 --> 00:11:57.800
So I've got to do that mapping
without knowing the answer.

00:11:57.800 --> 00:11:59.870
And the idea is that--

00:11:59.870 --> 00:12:03.290
and this is where we've seen
things like this before--

00:12:03.290 --> 00:12:05.780
the formula we're
going to construct

00:12:05.780 --> 00:12:08.615
simulates the machine on w.

00:12:11.870 --> 00:12:14.540
So in some way it's going
to do that simulation.

00:12:14.540 --> 00:12:18.530
The trick is figuring out
how to-- what that means.

00:12:18.530 --> 00:12:22.910
But the interpretation
of that formula

00:12:22.910 --> 00:12:28.010
is that in a sense describes,
says, in my informal language,

00:12:28.010 --> 00:12:31.740
that M accepts w.

00:12:31.740 --> 00:12:38.820
Very much like-- there's a lot
of parallel here between this

00:12:38.820 --> 00:12:41.970
construction and, for
example, the construction,

00:12:41.970 --> 00:12:46.590
the PCP construction,
where we made an instant--

00:12:46.590 --> 00:12:51.600
given a machine and
an input, we made

00:12:51.600 --> 00:12:54.450
a set of those dominoes,
where finding a match

00:12:54.450 --> 00:12:56.930
forced you to
simulate the machine.

00:12:56.930 --> 00:12:59.933
Here finding a
satisfying assignment

00:12:59.933 --> 00:13:01.850
is going to force you
to simulate the machine.

00:13:05.330 --> 00:13:07.340
So the satisfying
assignment is going

00:13:07.340 --> 00:13:11.780
to be a computation
history for M on w.

00:13:11.780 --> 00:13:13.730
And I'm just going to
write that computation

00:13:13.730 --> 00:13:15.813
history in a particular way.

00:13:15.813 --> 00:13:18.230
So it's going to have a somewhat
different encoding, which

00:13:18.230 --> 00:13:21.380
is going to help us to visualize
what's going on better.

00:13:24.080 --> 00:13:28.210
So that's the approach.

00:13:28.210 --> 00:13:29.960
That's the basic idea
of what we're trying

00:13:29.960 --> 00:13:31.127
to-- what we're going to do.

00:13:31.127 --> 00:13:33.920
So I'm happy to take
a minute if you have

00:13:33.920 --> 00:13:35.780
any questions about this part.

00:13:35.780 --> 00:13:39.890
But otherwise, I'll
just move on to start

00:13:39.890 --> 00:13:43.160
doing the actual construction
of what the formula looks like.

00:13:43.160 --> 00:13:44.340
How is it going to do that?

00:13:44.340 --> 00:13:47.190
How is that formula
going to work?

00:13:47.190 --> 00:13:47.690
OK.

00:13:47.690 --> 00:13:48.950
So no questions.

00:13:48.950 --> 00:13:54.530
Hopefully, we are all together.

00:13:54.530 --> 00:14:00.820
So first of all, let me
describe what my computation

00:14:00.820 --> 00:14:02.620
history is going to look like.

00:14:02.620 --> 00:14:04.420
And the situation
is a little bit

00:14:04.420 --> 00:14:08.752
different than what we
had before because when

00:14:08.752 --> 00:14:10.960
we were talking about the
Post correspondence problem

00:14:10.960 --> 00:14:13.180
we had a deterministic machine.

00:14:13.180 --> 00:14:17.240
And now our machine
is nondeterministic.

00:14:17.240 --> 00:14:21.800
So we're going to
call the object--

00:14:21.800 --> 00:14:24.920
instead of an accepting
computation or a computation

00:14:24.920 --> 00:14:26.420
history, we're just
going to-- we're

00:14:26.420 --> 00:14:29.390
going to call it a tableau, or
sometimes an accepting tableau

00:14:29.390 --> 00:14:32.720
if you want to emphasize
the accepting nature of it.

00:14:32.720 --> 00:14:35.900
But generally, we're just
going to call it a tableau.

00:14:35.900 --> 00:14:40.970
So a tableau is really an
accepting computation history

00:14:40.970 --> 00:14:48.520
for the machine on
an accepting branch

00:14:48.520 --> 00:14:52.380
of its nondeterministic
computation.

00:14:52.380 --> 00:14:59.600
So if M accepts w, it's got
to have some accepting branch,

00:14:59.600 --> 00:15:04.790
and the tableau is going to be
the sequence of configurations

00:15:04.790 --> 00:15:08.060
that the machine goes through
on that accepting branch.

00:15:08.060 --> 00:15:09.920
If there are several
accepting branches,

00:15:09.920 --> 00:15:11.780
there may be several tableaus.

00:15:11.780 --> 00:15:13.490
There will be several tableaus.

00:15:13.490 --> 00:15:15.770
So there's going
to be one tableau

00:15:15.770 --> 00:15:21.900
for each accepting branch of
the machine's computation on w.

00:15:21.900 --> 00:15:26.550
If the machine does not accept
w, there won't be any tableaus.

00:15:26.550 --> 00:15:29.490
And so the whole
point is that we're

00:15:29.490 --> 00:15:35.780
going to make our formula
represent the statement

00:15:35.780 --> 00:15:39.370
that there is a tableau.

00:15:39.370 --> 00:15:41.350
And satisfying that
formula is going

00:15:41.350 --> 00:15:46.750
to correspond to filling out the
symbols in the tableau to make

00:15:46.750 --> 00:15:48.910
it a tableau.

00:15:48.910 --> 00:15:51.550
So here is a tableau.

00:15:51.550 --> 00:15:55.960
So a tableau is just, again, an
accepting computation history

00:15:55.960 --> 00:15:59.440
on some branch, some accepting
branch of the machine's

00:15:59.440 --> 00:16:02.290
computation.

00:16:02.290 --> 00:16:03.640
The rows are the--

00:16:03.640 --> 00:16:07.090
instead of writing the
computation history

00:16:07.090 --> 00:16:11.170
out linearly, we're going to
represent it in a table form

00:16:11.170 --> 00:16:16.790
where each configuration is
going to be on a separate row.

00:16:16.790 --> 00:16:19.220
Now, the dimensions
of that table

00:16:19.220 --> 00:16:23.080
are going to be n to
the k by n to the k,

00:16:23.080 --> 00:16:30.500
because the machine runs
for n to the k steps.

00:16:30.500 --> 00:16:33.700
So there's going to-- if
there's an accepting branch,

00:16:33.700 --> 00:16:36.610
it's going to accept within
that number of steps.

00:16:36.610 --> 00:16:39.370
And we'll have enough
rows here to write down

00:16:39.370 --> 00:16:42.400
all of the configurations that
the machine goes through one

00:16:42.400 --> 00:16:45.460
after the next, row by
row, each one having

00:16:45.460 --> 00:16:49.020
a configuration in it.

00:16:49.020 --> 00:16:52.690
And then at the bottom,
there'll be an accept.

00:16:52.690 --> 00:16:55.990
Minor detail, if the
machine accepts earlier,

00:16:55.990 --> 00:16:58.000
we'll just say the
machine stays in the--

00:16:58.000 --> 00:17:01.300
once it enters an
accept, the machine

00:17:01.300 --> 00:17:03.470
does not change
from that point on.

00:17:03.470 --> 00:17:06.099
So the rule of the machine
is nothing changes.

00:17:06.099 --> 00:17:08.829
And it just remains in the same
configuration from that point

00:17:08.829 --> 00:17:09.329
on.

00:17:13.470 --> 00:17:19.140
So important to understand what
we're-- if you're not following

00:17:19.140 --> 00:17:23.800
what I mean by a tableau,
you're doomed for this lecture.

00:17:23.800 --> 00:17:29.430
So it makes sense for
you to ask a question

00:17:29.430 --> 00:17:33.810
to understand what
we mean by tableau.

00:17:33.810 --> 00:17:36.220
So just a few more
elements here.

00:17:36.220 --> 00:17:38.953
So this is going to be the
start configuration for M on w.

00:17:38.953 --> 00:17:40.620
This would be an
accepting configuration

00:17:40.620 --> 00:17:44.370
here down at the very last row.

00:17:44.370 --> 00:17:46.500
And you might imagine--

00:17:46.500 --> 00:17:53.270
I think I've filled out
some hypothetical first step

00:17:53.270 --> 00:17:58.700
of the machine after the start
where maybe the machine was--

00:17:58.700 --> 00:18:03.060
when it's in-- remember how
we encoded our configurations.

00:18:03.060 --> 00:18:05.990
So this is the machine
is in state q0,

00:18:05.990 --> 00:18:09.890
looking at the w, the first
symbol of the input, w1.

00:18:09.890 --> 00:18:14.510
And maybe when it's in q0
looking at that first symbol,

00:18:14.510 --> 00:18:19.340
it moves to state q7,
and goes right, and then

00:18:19.340 --> 00:18:24.960
changes that w1 to an A. And
so now here is the head shown

00:18:24.960 --> 00:18:28.680
moved one position to the
right in the new state q7.

00:18:28.680 --> 00:18:30.570
I mean, of course,
that depends on what

00:18:30.570 --> 00:18:33.730
the machine is designed to do,
what the transition function

00:18:33.730 --> 00:18:34.230
is.

00:18:34.230 --> 00:18:39.430
But this possibly
is what happens.

00:18:39.430 --> 00:18:40.680
So does the--

00:18:40.680 --> 00:18:41.640
OK, so good.

00:18:41.640 --> 00:18:44.820
Does the tableau trace
all steps of all branches?

00:18:44.820 --> 00:18:45.990
No.

00:18:45.990 --> 00:18:51.660
The tableau corresponds
to one accepting branch.

00:18:51.660 --> 00:18:53.610
Each different
accepting branch is

00:18:53.610 --> 00:18:54.960
going to have its own tableau.

00:18:54.960 --> 00:18:57.420
So there might be several
different ways of filling out

00:18:57.420 --> 00:18:58.440
that second row even.

00:18:58.440 --> 00:19:01.470
Of course, the first row is
going to be-- in any tableau,

00:19:01.470 --> 00:19:04.020
it's got to be the same.

00:19:04.020 --> 00:19:06.780
Once I know w--

00:19:06.780 --> 00:19:08.100
here I've written down--

00:19:08.100 --> 00:19:10.170
maybe I should
unpack this for you.

00:19:10.170 --> 00:19:13.410
It's in the start state here,
then here are the first--

00:19:13.410 --> 00:19:16.680
here are n symbols of
w, w's of length n.

00:19:16.680 --> 00:19:19.230
So there's w1, w2, up to wn.

00:19:19.230 --> 00:19:23.180
And then I'm padding out
the rest with blanks.

00:19:23.180 --> 00:19:24.770
So I should have said that, too.

00:19:24.770 --> 00:19:26.300
But OK.

00:19:26.300 --> 00:19:29.390
So I want to make my table
n to the k by n to the k

00:19:29.390 --> 00:19:32.870
because that's going to
be enough to represent

00:19:32.870 --> 00:19:35.600
the entire--

00:19:35.600 --> 00:19:41.750
all of these configurations of
M running for most n to the k

00:19:41.750 --> 00:19:47.660
steps, because the machine,
even if it sends its head

00:19:47.660 --> 00:19:51.480
moving to the right as
fast as it possibly can,

00:19:51.480 --> 00:19:53.540
it's never going to have--

00:19:53.540 --> 00:19:59.100
it's never going to
go outside this box

00:19:59.100 --> 00:20:01.120
if it only runs for
n to the k steps.

00:20:01.120 --> 00:20:02.520
So this is going
to be big enough

00:20:02.520 --> 00:20:05.385
to represent the entire
computation of M.

00:20:05.385 --> 00:20:08.460
So it means running
for n to the k time.

00:20:08.460 --> 00:20:13.010
And the input w is of length n.

00:20:13.010 --> 00:20:14.510
All right.

00:20:14.510 --> 00:20:15.170
What is k?

00:20:15.170 --> 00:20:17.360
So k is the running
time of the machine.

00:20:17.360 --> 00:20:21.720
So we assumed from the previous
slide that M runs in time n

00:20:21.720 --> 00:20:22.220
to the k.

00:20:25.365 --> 00:20:25.865
OK.

00:20:31.700 --> 00:20:32.930
So a good question here.

00:20:32.930 --> 00:20:35.150
How can the tableau
be a square table

00:20:35.150 --> 00:20:37.550
if we have a low number
of computation histories,

00:20:37.550 --> 00:20:40.590
but a lot of tape?

00:20:40.590 --> 00:20:44.250
Well, the low number computation
history, that's a problem.

00:20:44.250 --> 00:20:45.690
You're not saying that well.

00:20:45.690 --> 00:20:49.500
You know, each
computation history

00:20:49.500 --> 00:20:51.700
is in a different table.

00:20:51.700 --> 00:20:54.150
So this, I'm representing a
single computation history

00:20:54.150 --> 00:20:54.700
here.

00:20:54.700 --> 00:20:59.250
There may be-- there are going
to be many configurations.

00:20:59.250 --> 00:21:01.640
So I can't have a small
number of configurations

00:21:01.640 --> 00:21:05.330
using a lot of tape,
because I can only

00:21:05.330 --> 00:21:09.020
use one more cell, one
additional tape cell each time

00:21:09.020 --> 00:21:10.295
I--

00:21:10.295 --> 00:21:11.795
each additional
step of the machine.

00:21:14.360 --> 00:21:14.900
Yeah.

00:21:14.900 --> 00:21:16.970
So there's really no
difference between this.

00:21:16.970 --> 00:21:19.220
If you want to think of this
as a computation history,

00:21:19.220 --> 00:21:20.120
that's fine.

00:21:20.120 --> 00:21:22.160
This is really just the
standard terminology

00:21:22.160 --> 00:21:26.957
that's used when you're proving
this particular theorem.

00:21:26.957 --> 00:21:28.790
Typically people talk
about it as a tableau,

00:21:28.790 --> 00:21:30.582
but it's really just
a computation history.

00:21:35.450 --> 00:21:36.140
The q state--

00:21:36.140 --> 00:21:39.830
I mean, the question about
what are these states' q,

00:21:39.830 --> 00:21:42.680
this is the way we
represent configurations.

00:21:42.680 --> 00:21:46.803
So this means the
machine is in a state.

00:21:46.803 --> 00:21:48.470
They're not all going
down the diagonal.

00:21:48.470 --> 00:21:52.520
The states are going to zigzag
here through this picture

00:21:52.520 --> 00:21:56.290
here, depending upon how the
head of the machine moves.

00:21:56.290 --> 00:21:57.700
So you have to go
back and review

00:21:57.700 --> 00:22:00.370
how we represent the
configurations of the machine.

00:22:00.370 --> 00:22:03.610
Remember the configuration
is a snapshot of the machine

00:22:03.610 --> 00:22:04.420
at a given point.

00:22:07.703 --> 00:22:09.620
How do we know that M
runs in polynomial time?

00:22:09.620 --> 00:22:11.720
We're assuming M
runs in polynomial.

00:22:11.720 --> 00:22:16.040
We started off with a
language that's in NP.

00:22:16.040 --> 00:22:19.790
So it's a nondeterministic
polynomial time machine,

00:22:19.790 --> 00:22:23.570
and we're picking one
branch that accepts

00:22:23.570 --> 00:22:25.708
and writing down all the
sequence of configurations

00:22:25.708 --> 00:22:26.750
the machine goes through.

00:22:26.750 --> 00:22:27.770
Let's move on.

00:22:27.770 --> 00:22:31.730
And maybe ask more questions
as they come to you,

00:22:31.730 --> 00:22:34.695
and I'll pick out some
to answer if that's

00:22:34.695 --> 00:22:35.945
going to be helpful to others.

00:22:41.490 --> 00:22:51.100
So we're going to now
construct this formula

00:22:51.100 --> 00:22:52.750
to say that M accepts w.

00:22:52.750 --> 00:22:54.294
Again, that was what we--

00:22:54.294 --> 00:22:55.990
that's our goal.

00:22:55.990 --> 00:22:58.855
And it says that a
tableau for M on w exists.

00:23:02.730 --> 00:23:04.740
And basically what
that means is we

00:23:04.740 --> 00:23:08.040
want to say that it starts
right, it ends right,

00:23:08.040 --> 00:23:11.130
and everything in
between is right,

00:23:11.130 --> 00:23:13.410
and then we're going to need
some other stuff to talk

00:23:13.410 --> 00:23:16.620
about how we're going to be
encoding those symbols using

00:23:16.620 --> 00:23:18.250
Boolean variables.

00:23:18.250 --> 00:23:20.290
So those are going
to be the four parts.

00:23:20.290 --> 00:23:21.040
Here's the start.

00:23:21.040 --> 00:23:22.050
It starts right.

00:23:22.050 --> 00:23:23.340
Here it ends right.

00:23:23.340 --> 00:23:24.660
Here it moves right.

00:23:24.660 --> 00:23:27.390
And here it talks about
the encoding of the symbols

00:23:27.390 --> 00:23:30.820
into Boolean variables.

00:23:30.820 --> 00:23:33.900
So those are the four
parts of this formula

00:23:33.900 --> 00:23:35.025
that I'm going to describe.

00:23:38.710 --> 00:23:40.960
I hope you got your
question answered

00:23:40.960 --> 00:23:43.840
as to why the total number
of columns is n to the k,

00:23:43.840 --> 00:23:47.110
because it's just big
enough to fit the entire--

00:23:47.110 --> 00:23:49.300
all configurations
that the machine

00:23:49.300 --> 00:23:51.130
is running for at
most n to the k

00:23:51.130 --> 00:23:53.420
steps, which is
what we're assuming.

00:23:56.970 --> 00:23:57.470
OK.

00:23:57.470 --> 00:24:00.410
So now just getting
back to that,

00:24:00.410 --> 00:24:03.398
I'm going to describe these
different components now

00:24:03.398 --> 00:24:04.190
on separate slides.

00:24:08.030 --> 00:24:11.390
Let me start out with this
component phi cell, which

00:24:11.390 --> 00:24:13.077
is sort of the most
fundamental one

00:24:13.077 --> 00:24:14.660
because it talks
about how we're going

00:24:14.660 --> 00:24:20.660
to be encoding those symbols
of the tableau into the Boolean

00:24:20.660 --> 00:24:21.380
variables.

00:24:25.070 --> 00:24:28.130
So again, here's kind of the
picture to have in mind of this

00:24:28.130 --> 00:24:32.080
tableau, this n to the
k by n to the k table,

00:24:32.080 --> 00:24:38.680
representing some accepting
branch of the machine's

00:24:38.680 --> 00:24:42.830
computation if there is one.

00:24:42.830 --> 00:24:48.950
And so now let me draw
one of the cells here.

00:24:48.950 --> 00:24:51.360
I'm going to magnify it.

00:24:51.360 --> 00:24:55.800
So this is the i, j cell here.

00:24:55.800 --> 00:24:58.040
And I'm going to--

00:24:58.040 --> 00:25:02.520
there are going
to be a collection

00:25:02.520 --> 00:25:07.325
of Boolean variables associated
with each one of the cells.

00:25:07.325 --> 00:25:08.700
So each one of
the cells is going

00:25:08.700 --> 00:25:13.080
to have a bunch of
variables all to itself.

00:25:13.080 --> 00:25:16.010
And those are going to be
basically indicator variables.

00:25:16.010 --> 00:25:18.950
They're going to
indicate which symbol

00:25:18.950 --> 00:25:24.110
that cell gets to have in it.

00:25:24.110 --> 00:25:27.920
So again, picture here--

00:25:27.920 --> 00:25:29.992
in this tableau,
we don't know how

00:25:29.992 --> 00:25:31.200
it's going to get filled out.

00:25:31.200 --> 00:25:34.850
But however it gets filled
out, each one of these cells

00:25:34.850 --> 00:25:36.125
gets some symbol.

00:25:38.622 --> 00:25:40.580
And that symbol could
either be a tape alphabet

00:25:40.580 --> 00:25:44.530
symbol, or a symbol
representing a state.

00:25:44.530 --> 00:25:46.730
That's the way we do
our configurations.

00:25:46.730 --> 00:25:48.400
So it could be a
tape alphabet symbol

00:25:48.400 --> 00:25:53.080
here showing the magnification.

00:25:53.080 --> 00:25:54.830
Maybe it's the tape
alphabet symbol, which

00:25:54.830 --> 00:25:57.470
represents the blank symbol.

00:25:57.470 --> 00:26:00.440
Or maybe it's
represents some state.

00:26:03.500 --> 00:26:07.200
Now, how am I going to
encode that with variables?

00:26:07.200 --> 00:26:10.390
So this-- let me--

00:26:10.390 --> 00:26:12.280
this is the collection
of variables

00:26:12.280 --> 00:26:16.661
that's going to apply to the
entire formula phi sub M, w.

00:26:20.270 --> 00:26:24.050
Each cell is-- so
each cell i, j is

00:26:24.050 --> 00:26:27.620
going to have a
set of variables,

00:26:27.620 --> 00:26:33.500
one for each
possible symbol sigma

00:26:33.500 --> 00:26:39.080
that's in the configuration
alphabet, namely a tape

00:26:39.080 --> 00:26:41.450
symbol or a state symbol.

00:26:47.450 --> 00:26:50.080
So I'm going to have--

00:26:50.080 --> 00:26:52.940
well, maybe this will become
clear as I'm writing it.

00:26:52.940 --> 00:27:01.940
So if I turn the variable x
i, j, sigma equal to true,

00:27:01.940 --> 00:27:06.550
that's just a way of saying
that cell i, j contains a sigma.

00:27:06.550 --> 00:27:12.460
So if I have x i, j, a, that
means the symbol contains an a.

00:27:12.460 --> 00:27:15.110
So I'm going to illustrate
that now for you.

00:27:15.110 --> 00:27:19.390
So imagine you have
lights representing all

00:27:19.390 --> 00:27:25.765
the different x i, j's
for the different sigmas.

00:27:25.765 --> 00:27:26.640
Didn't say that well.

00:27:26.640 --> 00:27:30.120
So we're in cell i, j.

00:27:30.120 --> 00:27:32.520
So these are all
x i, j variables.

00:27:32.520 --> 00:27:34.470
They're all x i,
j sigma variables

00:27:34.470 --> 00:27:40.900
for the different sigmas
that can go in this cell.

00:27:40.900 --> 00:27:42.780
So all different
possible sigmas.

00:27:42.780 --> 00:27:47.860
So this is gamma union Q.

00:27:47.860 --> 00:27:58.270
So now if I have an A
here in that cell, so then

00:27:58.270 --> 00:28:03.520
the variable x i, j, a is true.

00:28:03.520 --> 00:28:06.280
And just helping
you visualize that,

00:28:06.280 --> 00:28:08.717
that's going to correspond
to turning the light on.

00:28:08.717 --> 00:28:10.300
There's going to be
a light associated

00:28:10.300 --> 00:28:11.675
with each one of
these variables.

00:28:11.675 --> 00:28:15.660
And it's going to be turned
on when that variable is true.

00:28:15.660 --> 00:28:19.340
Similarly, if I have
the blank symbol

00:28:19.340 --> 00:28:22.430
is the thing that
goes in that cell,

00:28:22.430 --> 00:28:24.193
then that variable
gets turned on.

00:28:24.193 --> 00:28:25.110
I hope you can see it.

00:28:25.110 --> 00:28:28.820
Maybe it's a little bit
small on your screen.

00:28:28.820 --> 00:28:32.900
The x i, j blank,
a variable is true.

00:28:32.900 --> 00:28:39.550
And similarly, if it's q7 here,
the x i, j q7 variable is true.

00:28:39.550 --> 00:28:42.460
So that's the way we're
going to be encoding

00:28:42.460 --> 00:28:46.720
the contents of these
cells using these indicator

00:28:46.720 --> 00:28:48.610
variables.

00:28:48.610 --> 00:28:54.490
And now we have to start making
some Boolean logic to make sure

00:28:54.490 --> 00:29:01.140
that those variables reasonably
represent the cell con--

00:29:01.140 --> 00:29:02.685
the contents of these cells.

00:29:02.685 --> 00:29:04.560
So for example, what
would be the first thing

00:29:04.560 --> 00:29:07.380
that comes to your mind?

00:29:07.380 --> 00:29:11.593
Well, we better not
have two lights going on

00:29:11.593 --> 00:29:13.260
in any one of the
cells, because then we

00:29:13.260 --> 00:29:14.520
have two symbols in that cell.

00:29:14.520 --> 00:29:15.823
And that's not allowed.

00:29:15.823 --> 00:29:18.240
Each cell is going-- we want
each cell to have exactly one

00:29:18.240 --> 00:29:18.900
symbol.

00:29:18.900 --> 00:29:21.870
And that corresponds
to each cell having

00:29:21.870 --> 00:29:23.730
exactly one of its
lights turned on,

00:29:23.730 --> 00:29:25.800
or equivalently,
each cell should

00:29:25.800 --> 00:29:29.800
have exactly one of
the variables be true.

00:29:29.800 --> 00:29:31.740
That's the very first
part of the formula

00:29:31.740 --> 00:29:32.970
is just going to say that.

00:29:32.970 --> 00:29:35.580
So let me show you
what that looks like.

00:29:38.840 --> 00:29:41.150
So here we're talking
about this phi cell.

00:29:41.150 --> 00:29:44.720
It says that there's exactly
one light on per cell,

00:29:44.720 --> 00:29:47.367
or in other words,
exactly one of the x i,

00:29:47.367 --> 00:29:49.742
j sigmas is true for each i, j.

00:29:56.150 --> 00:29:58.400
So this is how I'm going
to actually express

00:29:58.400 --> 00:30:01.130
that using my Boolean formula.

00:30:04.657 --> 00:30:06.490
I'm sort of color coding
the different parts

00:30:06.490 --> 00:30:08.532
of the formula, which I'm
writing out to you here

00:30:08.532 --> 00:30:09.550
in English.

00:30:09.550 --> 00:30:11.080
So first, I want to say this.

00:30:11.080 --> 00:30:14.770
So in every cell, there's at
least one light that's on,

00:30:14.770 --> 00:30:16.600
and there's at most
one light that's on.

00:30:19.320 --> 00:30:20.960
So here's the green part.

00:30:20.960 --> 00:30:23.030
This is going to say at
least one light is on.

00:30:23.030 --> 00:30:27.290
So I'm going to say that
by taking all of the var--

00:30:27.290 --> 00:30:31.910
all of the symbols that
can appear in that cell,

00:30:31.910 --> 00:30:37.040
and taking an OR over all of
those different associated

00:30:37.040 --> 00:30:38.370
variables.

00:30:38.370 --> 00:30:40.280
So it's either got
the first symbol on,

00:30:40.280 --> 00:30:44.180
or the second symbol is
there, or dot dot dot,

00:30:44.180 --> 00:30:45.410
or the last symbol is there.

00:30:45.410 --> 00:30:47.670
One of those has
got to be there.

00:30:47.670 --> 00:30:52.790
I'm going to write this
using my big OR notation.

00:30:52.790 --> 00:30:58.570
So for sigma appearing in
this set of possibilities,

00:30:58.570 --> 00:31:02.580
one of those variables
has got to be on at least.

00:31:02.580 --> 00:31:05.410
That's what this
big OR tells you.

00:31:05.410 --> 00:31:10.060
Now we want to make sure that
there's at most one that's on.

00:31:10.060 --> 00:31:11.380
So that there are not--

00:31:11.380 --> 00:31:15.880
there's at least one on, but
there are not two that are on.

00:31:15.880 --> 00:31:19.660
So I'm going to have an
additional part of the formula

00:31:19.660 --> 00:31:21.370
here, which says--

00:31:21.370 --> 00:31:23.406
and I hope you can read this.

00:31:23.406 --> 00:31:26.860
It's a little small.

00:31:26.860 --> 00:31:33.740
If I have two different
symbols, sigma and tau,

00:31:33.740 --> 00:31:36.650
that are configuration--

00:31:36.650 --> 00:31:39.830
possible configuration symbols,
where sigma and tau are not

00:31:39.830 --> 00:31:40.410
equal.

00:31:40.410 --> 00:31:41.870
So that's I'm
reading it out to you

00:31:41.870 --> 00:31:44.990
if it's too small
for your screen.

00:31:44.990 --> 00:31:47.580
Then I'm going to say
it's not possible.

00:31:47.580 --> 00:31:52.490
So I have the negation of x
i, j sigma, and x i, j tau.

00:31:52.490 --> 00:31:56.720
So saying it another
way, it's not the case

00:31:56.720 --> 00:32:01.700
that that cell contains both
sigma and tau for any two

00:32:01.700 --> 00:32:06.790
symbols sigma and tau as
long as they're different.

00:32:06.790 --> 00:32:10.280
And we want to take these two
formulas and add them together.

00:32:10.280 --> 00:32:15.150
And this tells me
in the cell i, j,

00:32:15.150 --> 00:32:18.450
there's exactly one of
the variables is true.

00:32:18.450 --> 00:32:20.130
Exactly one of the lights is on.

00:32:20.130 --> 00:32:22.200
And that's going
to represent which

00:32:22.200 --> 00:32:24.590
symbol goes into that cell.

00:32:24.590 --> 00:32:28.640
And then I want to take the
AND over all possible cells

00:32:28.640 --> 00:32:33.580
to make sure that I'm going
to now apply that everywhere.

00:32:33.580 --> 00:32:37.920
And so now I do an AND for i
and j ranging between 1 and n

00:32:37.920 --> 00:32:42.405
to the k to apply this logic
throughout the picture.

00:32:45.550 --> 00:32:46.050
Yeah.

00:32:46.050 --> 00:32:49.080
Sigma unions--
asking sigma union Q

00:32:49.080 --> 00:32:51.690
contains the input, output, yes.

00:32:51.690 --> 00:32:52.530
This is not a sigma.

00:32:52.530 --> 00:32:54.540
This is a gamma.

00:32:54.540 --> 00:32:56.070
Gamma is the tape alphabet.

00:32:56.070 --> 00:33:00.990
This is any symbol, including
an input symbol, from sigma

00:33:00.990 --> 00:33:03.280
is going to be in gamma.

00:33:03.280 --> 00:33:05.990
So this is any symbol
can appear on the tape.

00:33:10.350 --> 00:33:17.430
And this expression here, that
is the expression phi sub cell.

00:33:17.430 --> 00:33:19.620
So here's a little
check-in for you.

00:33:19.620 --> 00:33:21.840
But maybe before we
jump into the check-in,

00:33:21.840 --> 00:33:23.430
let's just make sure--

00:33:23.430 --> 00:33:26.070
it may be better to
take some questions,

00:33:26.070 --> 00:33:31.818
and then we can ask
the check-in for you.

00:33:31.818 --> 00:33:33.120
Do you understand?

00:33:33.120 --> 00:33:37.390
I mean, if you're
not getting this,

00:33:37.390 --> 00:33:42.210
you should try to figure
out how to get it,

00:33:42.210 --> 00:33:45.990
because this is really
just the foundation.

00:33:45.990 --> 00:33:47.753
It only gets more--

00:33:47.753 --> 00:33:49.170
it is not a very
complicated proof

00:33:49.170 --> 00:33:51.212
once you sort of get the
idea of what's going on,

00:33:51.212 --> 00:33:53.010
but if you're not
getting this part,

00:33:53.010 --> 00:33:54.720
you won't be able
to get the rest.

00:34:01.310 --> 00:34:01.810
OK.

00:34:01.810 --> 00:34:04.660
I have no idea what the--
what that means, but I'll

00:34:04.660 --> 00:34:06.070
read it out to you guys.

00:34:06.070 --> 00:34:09.940
This looks like a one-hot tensor
encoding, same from common--

00:34:09.940 --> 00:34:12.639
same form commonly used in ML.

00:34:12.639 --> 00:34:14.980
OK.

00:34:14.980 --> 00:34:15.947
It's just an indicate--

00:34:15.947 --> 00:34:17.739
I would just call them
indicator variables.

00:34:23.420 --> 00:34:27.409
Why is it sigma union
Q for the big AND here?

00:34:30.179 --> 00:34:32.100
Sigma union Q?

00:34:32.100 --> 00:34:34.449
You mean gamma union Q?

00:34:34.449 --> 00:34:34.949
[GASPING]

00:34:34.949 --> 00:34:36.929
This is wrong.

00:34:36.929 --> 00:34:38.020
OK.

00:34:38.020 --> 00:34:40.230
Now I understand why
everybody is upset.

00:34:40.230 --> 00:34:44.000
This should be a
gamma, not a sigma.

00:34:44.000 --> 00:34:45.699
There's a boo-boo.

00:34:45.699 --> 00:34:46.951
Sorry about that.

00:34:46.951 --> 00:34:48.909
I don't know if I can
fix that without breaking

00:34:48.909 --> 00:34:51.460
the whole slide, so I'm
not going to even try.

00:34:51.460 --> 00:34:54.880
This symbol here should
be gamma, not sigma.

00:34:54.880 --> 00:34:56.548
It's a typo.

00:34:56.548 --> 00:34:57.590
Thanks for catching that.

00:35:04.800 --> 00:35:05.550
Yes.

00:35:05.550 --> 00:35:08.670
So the question is--

00:35:08.670 --> 00:35:09.240
OK.

00:35:09.240 --> 00:35:17.240
So phi sub cell is just
trying to make sure

00:35:17.240 --> 00:35:21.980
that the encoding represents
setting a bunch of symbols

00:35:21.980 --> 00:35:23.300
into the tableau.

00:35:23.300 --> 00:35:26.240
Not-- so each cell is
going to have one symbol

00:35:26.240 --> 00:35:29.810
exactly, not two, not zero.

00:35:29.810 --> 00:35:30.980
So that's what phi sub--

00:35:30.980 --> 00:35:34.130
if you've satisfied, if
you've set the variables

00:35:34.130 --> 00:35:37.100
to satisfy phi sub
cell, then there's

00:35:37.100 --> 00:35:40.070
going to be one
symbol on in each--

00:35:40.070 --> 00:35:43.370
one symbol in each
of those cells.

00:35:43.370 --> 00:35:45.980
Now, another question,
this is not a CNF.

00:35:45.980 --> 00:35:47.720
No, this is not a CNF.

00:35:47.720 --> 00:35:50.540
That's the second half
of-- that's going to be--

00:35:50.540 --> 00:35:52.010
I hope we don't run out of time.

00:35:52.010 --> 00:35:58.670
But I have a way of converting
general SAT formulas to CNFs

00:35:58.670 --> 00:36:00.270
and preserving satisfiability.

00:36:00.270 --> 00:36:02.578
So we're going to do
that reduction afterward.

00:36:08.210 --> 00:36:11.510
Here's a little check
to see if you understand

00:36:11.510 --> 00:36:13.580
at some level what's going on.

00:36:17.680 --> 00:36:22.020
How many variables does
this formula actually have?

00:36:25.000 --> 00:36:26.010
Is order n?

00:36:26.010 --> 00:36:27.370
Order n square?

00:36:27.370 --> 00:36:28.920
n to the k?

00:36:28.920 --> 00:36:32.580
Remember, k is the running
time of the machine.

00:36:32.580 --> 00:36:34.880
Or n to the 2k?

00:36:34.880 --> 00:36:36.900
What do you think?

00:36:36.900 --> 00:36:40.620
So I mean, for how
many variables.

00:36:40.620 --> 00:36:46.200
I mean that in all of
phi sub M. How many

00:36:46.200 --> 00:36:50.218
variables do we have all
together in this formula

00:36:50.218 --> 00:36:51.510
if that's what the question is.

00:36:56.680 --> 00:36:58.640
And here are the variables.

00:36:58.640 --> 00:37:02.530
So describing them
here-- x i, j, sigma.

00:37:02.530 --> 00:37:03.370
OK.

00:37:03.370 --> 00:37:05.620
I'm going to close this.

00:37:05.620 --> 00:37:08.270
So pick something.

00:37:08.270 --> 00:37:08.960
All right.

00:37:08.960 --> 00:37:13.190
Ending polling, 1, 2, 3.

00:37:13.190 --> 00:37:14.730
OK.

00:37:14.730 --> 00:37:15.230
Yeah.

00:37:21.430 --> 00:37:21.930
OK.

00:37:21.930 --> 00:37:23.800
That's a good question.

00:37:23.800 --> 00:37:25.710
So first of all,
the correct answer

00:37:25.710 --> 00:37:29.280
is, in fact, D. It's
order n to the 2k.

00:37:29.280 --> 00:37:33.940
Now, I'm getting
some questions about,

00:37:33.940 --> 00:37:37.360
what about the size
of gamma and Q?

00:37:37.360 --> 00:37:40.660
Well, those are
going to be fixed.

00:37:40.660 --> 00:37:45.820
They depend only on the machine,
but they don't depend on n.

00:37:45.820 --> 00:37:49.540
So thinking about it
functionally in terms of n,

00:37:49.540 --> 00:37:54.320
that's going to be a
constant multiplier.

00:37:54.320 --> 00:37:59.560
And so it's going to be
absorbed within the big O.

00:37:59.560 --> 00:38:03.874
So that's why we have--

00:38:03.874 --> 00:38:05.958
these are constant
relative to n.

00:38:05.958 --> 00:38:06.625
These are fixed.

00:38:11.380 --> 00:38:13.833
There are not n to the
k possible symbols.

00:38:13.833 --> 00:38:15.250
There's a fixed
number of symbols.

00:38:15.250 --> 00:38:16.675
It depends only on the machine.

00:38:20.350 --> 00:38:22.410
So we're looking at
a particular machine,

00:38:22.410 --> 00:38:24.405
and what happens when
you look at large inputs.

00:38:31.250 --> 00:38:34.138
So why is D and not C?

00:38:34.138 --> 00:38:35.930
Well, don't forget--
how big is this table?

00:38:38.670 --> 00:38:41.310
This is n to the
k by n to the k.

00:38:41.310 --> 00:38:45.300
So there are n to the 2k cells,
n to the k quantity squared,

00:38:45.300 --> 00:38:50.110
or n to the 2k cells here.

00:38:50.110 --> 00:38:51.810
And so there's a
collection of variables

00:38:51.810 --> 00:38:54.790
for each cell, some fixed number
of variables for each cell.

00:38:54.790 --> 00:38:56.475
So that's why its
order n to the 2k.

00:39:00.360 --> 00:39:01.230
Good.

00:39:01.230 --> 00:39:03.930
So let's move on.

00:39:03.930 --> 00:39:07.200
I think we're
actually-- hold on.

00:39:07.200 --> 00:39:10.200
So we have one more
slide, and I think

00:39:10.200 --> 00:39:12.660
then we have a break after.

00:39:12.660 --> 00:39:20.640
So now let's next talk about
constructing two more pieces

00:39:20.640 --> 00:39:24.490
of the phi sub M, w formula.

00:39:24.490 --> 00:39:28.560
So we already got
phi sub cell done.

00:39:28.560 --> 00:39:33.310
Let's look at phi sub
start and phi sub accept.

00:39:33.310 --> 00:39:36.940
And phi start is
going to tell us

00:39:36.940 --> 00:39:42.540
that the start configuration
has exactly these symbols.

00:39:42.540 --> 00:39:51.390
And phi accept tells us that the
bottom configuration contains

00:39:51.390 --> 00:39:54.320
an accepting state somewhere.

00:39:54.320 --> 00:39:56.350
So how are we going
to write that down?

00:39:56.350 --> 00:39:59.890
Well, first of all, I'm going
to write these down just cell

00:39:59.890 --> 00:40:01.250
by cell.

00:40:01.250 --> 00:40:04.710
So first of all, phi start
is going to say the cell 1,

00:40:04.710 --> 00:40:07.870
1 contains a q0.

00:40:07.870 --> 00:40:12.040
I mean, I know what the
start configuration should

00:40:12.040 --> 00:40:19.250
be, because thinking of me, or
think of us as the reduction,

00:40:19.250 --> 00:40:21.860
the reduction is
given M. It's given w.

00:40:21.860 --> 00:40:23.480
So it knows what
the start state is.

00:40:23.480 --> 00:40:28.340
It knows what the
symbols of w are.

00:40:28.340 --> 00:40:31.820
So it knows what that
start configuration is.

00:40:31.820 --> 00:40:35.630
It's just q0 followed
by the n symbols

00:40:35.630 --> 00:40:37.820
of w followed by blanks.

00:40:37.820 --> 00:40:44.360
So it wants the very first
cell in the left-hand corner

00:40:44.360 --> 00:40:48.740
here to be a q0, the start state
of the machine, which it knows.

00:40:48.740 --> 00:40:55.200
So it's going to say x sub 1,
1, q0, that has to be turned on.

00:40:55.200 --> 00:40:59.030
So it's going to be AND of
a bunch of variables here.

00:40:59.030 --> 00:41:03.170
And in order to satisfy phi sub
start, all of those variables

00:41:03.170 --> 00:41:05.810
have to be set to true.

00:41:05.810 --> 00:41:09.860
So that means we have to
have a q0 in that cell.

00:41:09.860 --> 00:41:13.150
So now we're going to
do the next cell here.

00:41:13.150 --> 00:41:17.830
The 1, 2, the next cell of
the start configuration.

00:41:17.830 --> 00:41:21.910
So phi start is
going to have x 1, 2.

00:41:21.910 --> 00:41:23.665
So that's the next place.

00:41:23.665 --> 00:41:25.930
It contains w1.

00:41:25.930 --> 00:41:27.190
And so on.

00:41:27.190 --> 00:41:32.790
x 1, 3 contains w2,
all the way up to wn,

00:41:32.790 --> 00:41:40.010
and then there's going to be
a bunch of additional parts

00:41:40.010 --> 00:41:43.460
which say that we have
blanks in the rest,

00:41:43.460 --> 00:41:48.750
just spelling out exactly all
of the symbols in that top row.

00:41:48.750 --> 00:41:57.170
Because that's what
the phi start formula,

00:41:57.170 --> 00:41:59.840
or sub formula of
the overall formula

00:41:59.840 --> 00:42:03.860
we're making looks like.

00:42:03.860 --> 00:42:06.710
Now let's take a
look at phi accept.

00:42:06.710 --> 00:42:09.590
Phi accept, because
I'm just looking

00:42:09.590 --> 00:42:16.350
for q accept to appear
somewhere in that bottom row,

00:42:16.350 --> 00:42:19.160
I'm going to do that
in terms of an OR.

00:42:19.160 --> 00:42:23.930
So here is-- the variables
now, notice, have n to the k

00:42:23.930 --> 00:42:27.150
because it's the last
row in the table.

00:42:27.150 --> 00:42:30.460
So row n to the k here.

00:42:30.460 --> 00:42:33.710
And then I'm going to vary
j from 1 to n to the k.

00:42:33.710 --> 00:42:35.740
So j, the column
number, is going

00:42:35.740 --> 00:42:37.510
to range from 1 to n to the k.

00:42:37.510 --> 00:42:39.250
And I'm looking
for that to accept.

00:42:39.250 --> 00:42:44.440
So x n to the k j, where
j's vary, and q accept.

00:42:44.440 --> 00:42:47.240
One of those has to be true.

00:42:47.240 --> 00:42:48.870
One of those has
to be turned on.

00:42:48.870 --> 00:42:52.560
And so that's why it's a big OR.

00:42:52.560 --> 00:43:00.033
And that's my phi accept piece.

00:43:00.033 --> 00:43:01.450
And now we'll take
a little break.

00:43:01.450 --> 00:43:04.690
And feel free to ask
me some more questions.

00:43:04.690 --> 00:43:06.135
Let me just start our clock.

00:43:15.370 --> 00:43:20.130
Go grab yourself some coffee,
or ask me some questions.

00:43:20.130 --> 00:43:22.760
I'm happy to answer them.

00:43:22.760 --> 00:43:27.920
Why don't we check that q
accept only appears once?

00:43:27.920 --> 00:43:30.835
Is it possible for q
accept to appear twice?

00:43:30.835 --> 00:43:31.835
That's a great question.

00:43:34.590 --> 00:43:37.940
So that would definitely
be a broken configuration

00:43:37.940 --> 00:43:39.740
if that happened,
because a configuration

00:43:39.740 --> 00:43:44.960
can have-- must have exactly
one state symbol appearing.

00:43:44.960 --> 00:43:50.540
The way we're going to enforce
that is with the phi move

00:43:50.540 --> 00:43:52.590
part of the formula,
which we haven't seen yet.

00:43:52.590 --> 00:43:54.920
So phi move is
going to guarantee

00:43:54.920 --> 00:43:57.500
that the machine is
acting correctly,

00:43:57.500 --> 00:44:01.490
so that all of the
rows of the tableau

00:44:01.490 --> 00:44:04.460
are all legal configurations,
and they all legally follow

00:44:04.460 --> 00:44:06.500
from the previous.

00:44:06.500 --> 00:44:09.020
So really, in a sense,
the hard-- heavy lifting

00:44:09.020 --> 00:44:11.960
is coming in phi move, but
it's really not that bad.

00:44:18.670 --> 00:44:20.420
Somebody says, out of
curiosity, how close

00:44:20.420 --> 00:44:23.390
is this intuition proof
to the actual proof?

00:44:23.390 --> 00:44:24.920
This is the actual proof.

00:44:24.920 --> 00:44:28.130
There's no-- I'm
not hiding anything.

00:44:28.130 --> 00:44:31.250
I mean, we're being
a little loose here,

00:44:31.250 --> 00:44:33.695
but you can turn this--

00:44:33.695 --> 00:44:35.390
we're not cutting
any corners here.

00:44:35.390 --> 00:44:38.570
This is exactly
how the proof goes.

00:44:38.570 --> 00:44:44.030
And so not-- you're
getting the real deal here.

00:44:44.030 --> 00:44:46.820
Somebody wanted to see the
previous slide, so here we are.

00:44:46.820 --> 00:44:49.340
Whoops.

00:44:49.340 --> 00:44:50.885
Is there something
you want to ask?

00:44:54.990 --> 00:45:02.240
So phi cell says there's
exactly one symbol per cell.

00:45:02.240 --> 00:45:04.820
And the variables are set in
a way in terms of thinking

00:45:04.820 --> 00:45:06.500
of them as indicator variables.

00:45:06.500 --> 00:45:11.160
There's exactly one variable
set to true in each cell.

00:45:11.160 --> 00:45:13.460
So there's exactly
one symbol per cell.

00:45:13.460 --> 00:45:16.460
That's what phi cell tells you.

00:45:16.460 --> 00:45:18.680
If you don't have that,
then you have a mess.

00:45:18.680 --> 00:45:20.820
So you've got to
start with that.

00:45:20.820 --> 00:45:22.320
And then with the--
other things are

00:45:22.320 --> 00:45:23.880
going to be
additional conditions,

00:45:23.880 --> 00:45:27.030
which when satisfied are
going to enforce the rest

00:45:27.030 --> 00:45:29.370
of the properties that we want.

00:45:29.370 --> 00:45:32.760
Why would the proof fail if
we replace n to the k with 2

00:45:32.760 --> 00:45:33.780
to the n to the k?

00:45:36.920 --> 00:45:39.100
So OK.

00:45:39.100 --> 00:45:43.300
I presume where does-- we'll
just use the polynomial running

00:45:43.300 --> 00:45:48.430
time of the machine of M,
the nondeterministic machine.

00:45:48.430 --> 00:45:50.350
I mean, if you had
an enormous tab--

00:45:50.350 --> 00:45:53.650
we have to show ultimately
that this reduction is

00:45:53.650 --> 00:45:55.960
a polynomial time reduction.

00:45:55.960 --> 00:45:58.210
And that's going to depend
on how big the tableau is,

00:45:58.210 --> 00:46:00.585
because that's going to tell
us how big the formula we're

00:46:00.585 --> 00:46:02.530
producing is, phi sub M, w.

00:46:02.530 --> 00:46:04.480
If phi sub M, w is
exponentially big,

00:46:04.480 --> 00:46:07.750
we don't have a prayer of being
able to output that formula

00:46:07.750 --> 00:46:08.740
in polynomial time.

00:46:11.830 --> 00:46:14.650
If there were less
than n to the k steps,

00:46:14.650 --> 00:46:16.540
do we repeat the
last configuration?

00:46:16.540 --> 00:46:18.250
Yeah, that's what I said.

00:46:18.250 --> 00:46:21.160
If the machine ends early,
the last configuration

00:46:21.160 --> 00:46:22.910
just stays there.

00:46:22.910 --> 00:46:25.720
So we're going to modify the
definition of the machine

00:46:25.720 --> 00:46:29.600
slightly so it just stays.

00:46:29.600 --> 00:46:30.100
Yeah.

00:46:35.090 --> 00:46:35.590
OK.

00:46:46.880 --> 00:46:47.380
Yeah.

00:46:47.380 --> 00:46:48.893
Let me not take
the other-- there's

00:46:48.893 --> 00:46:50.560
a bunch of other
questions, some of them

00:46:50.560 --> 00:46:54.160
a little on the technical side.

00:46:54.160 --> 00:46:57.200
Let me-- maybe I'll
try to address them

00:46:57.200 --> 00:47:01.340
as they come along if it
turns out to work to do that.

00:47:01.340 --> 00:47:06.140
So the break is over.

00:47:06.140 --> 00:47:10.460
Why don't we-- is it possible
that the encoding configuration

00:47:10.460 --> 00:47:12.830
will not fit in n to the k?

00:47:15.950 --> 00:47:17.700
So the question is,
is there a possibility

00:47:17.700 --> 00:47:19.290
that the encoding
of the configuration

00:47:19.290 --> 00:47:20.670
won't fit in n to the k?

00:47:20.670 --> 00:47:23.960
If the machine runs
for n to the k steps,

00:47:23.960 --> 00:47:26.720
the configuration has to
fit within n to the k,

00:47:26.720 --> 00:47:31.110
because it can't use anything
more within n to the k steps.

00:47:31.110 --> 00:47:31.870
So think about it.

00:47:31.870 --> 00:47:32.980
But no.

00:47:32.980 --> 00:47:36.690
The answer is the
configurations--

00:47:36.690 --> 00:47:39.360
if the machine runs
in time n to the k,

00:47:39.360 --> 00:47:43.500
that whole tableau is
big enough to write down

00:47:43.500 --> 00:47:46.440
the entire computation history.

00:47:46.440 --> 00:47:48.610
All right, so let's continue.

00:47:48.610 --> 00:47:53.860
Phi sub move, this
is, in a sense,

00:47:53.860 --> 00:47:57.930
the part which is going
to tell us that we

00:47:57.930 --> 00:48:02.080
started right, we ended right.

00:48:02.080 --> 00:48:05.990
Phi cell says every cell
contains one symbol.

00:48:05.990 --> 00:48:10.750
And now we have to say that
the whole interior is correct.

00:48:10.750 --> 00:48:12.280
How are we going to do that?

00:48:12.280 --> 00:48:15.575
So these are the parts
we've already done.

00:48:15.575 --> 00:48:16.950
And the way I'm
going to describe

00:48:16.950 --> 00:48:21.310
that is in terms of these
kind of little windows

00:48:21.310 --> 00:48:22.870
I'm calling neighborhoods.

00:48:22.870 --> 00:48:28.630
So imagine here we have a 2 by
3 rectangle, which I'm going

00:48:28.630 --> 00:48:31.560
to call a 2 by 3 neighborhood.

00:48:31.560 --> 00:48:35.363
And what I'm going to argue,
but I'm not going to prove here.

00:48:35.363 --> 00:48:36.780
I'm just going to
really state it,

00:48:36.780 --> 00:48:41.280
but it's really just a sort
of more or less obvious fact.

00:48:41.280 --> 00:48:47.070
But the proof-- the book has
the formal proof, that if any--

00:48:47.070 --> 00:48:50.100
every one of these
here is legitimate,

00:48:50.100 --> 00:48:52.680
is legal according to
the rules of the machine,

00:48:52.680 --> 00:48:56.800
if every single--
imagine you have these--

00:48:56.800 --> 00:48:57.300
oops.

00:48:57.300 --> 00:48:59.670
Let me put myself back on
here so you can see me.

00:49:02.190 --> 00:49:12.040
If you have here
every 2 by 3 window,

00:49:12.040 --> 00:49:14.920
you can take this
as a window, and you

00:49:14.920 --> 00:49:19.530
slide that over the entire
picture of the tableau.

00:49:19.530 --> 00:49:22.530
And everything here
looks OK as far

00:49:22.530 --> 00:49:23.850
as the running of the machine.

00:49:23.850 --> 00:49:26.700
So I'll say what that
means in a second.

00:49:26.700 --> 00:49:30.690
But if everything looks
locally fine everywhere,

00:49:30.690 --> 00:49:34.650
then the whole tableau
has to be a valid tableau

00:49:34.650 --> 00:49:39.790
in terms of the rules of M.

00:49:39.790 --> 00:49:42.340
Maybe it's easier
if I describe what

00:49:42.340 --> 00:49:44.125
I mean by these being legal.

00:49:47.000 --> 00:49:52.520
So these neighborhoods,
these 2 by 3 neighborhoods

00:49:52.520 --> 00:49:56.460
are legal if they're consistent
with M's transition function.

00:49:56.460 --> 00:49:58.400
So I'm going to
describe rather than--

00:49:58.400 --> 00:50:00.350
I mean, to do this
formally, I would

00:50:00.350 --> 00:50:03.470
have to go through a
process that we went--

00:50:03.470 --> 00:50:07.820
like what we did when we
went through the construction

00:50:07.820 --> 00:50:09.470
for the Post
correspondence problem,

00:50:09.470 --> 00:50:11.780
and say if the machine moves
left, this thing happens.

00:50:11.780 --> 00:50:13.000
If it moves right, that's--

00:50:13.000 --> 00:50:15.690
I think that it's
not really necessary.

00:50:15.690 --> 00:50:18.320
You can kind of get
the idea very clearly

00:50:18.320 --> 00:50:20.240
by doing it at a little
bit of a higher level.

00:50:23.180 --> 00:50:26.510
So let's look at what I mean
by a legal neighborhood.

00:50:26.510 --> 00:50:29.860
So a legal neighborhood is
a setting of the values,

00:50:29.860 --> 00:50:34.990
the six values of this
2 by 3 neighborhood,

00:50:34.990 --> 00:50:39.770
in a way which doesn't
violate M's rules.

00:50:39.770 --> 00:50:47.520
So for example, if M, when
it's in state q7 reading of b,

00:50:47.520 --> 00:50:52.390
goes into state
q3 and moves left,

00:50:52.390 --> 00:50:56.680
then this would be a legal
neighborhood, because it

00:50:56.680 --> 00:51:02.130
shows the head moving
left, the b becoming a c.

00:51:02.130 --> 00:51:03.900
So reading a b,
I should also say

00:51:03.900 --> 00:51:07.210
that it converts that b to a c.

00:51:07.210 --> 00:51:09.030
And we just head
left into state q3.

00:51:09.030 --> 00:51:11.100
So this would be a
legal neighborhood

00:51:11.100 --> 00:51:12.540
if that's the way--

00:51:12.540 --> 00:51:18.120
so being legal depends upon
the transition function

00:51:18.120 --> 00:51:19.720
of the machine.

00:51:19.720 --> 00:51:21.820
So given the
transition function,

00:51:21.820 --> 00:51:24.460
that's going to tell you which
are the legal neighborhoods.

00:51:24.460 --> 00:51:26.740
So another legal neighborhood--
this would always

00:51:26.740 --> 00:51:29.770
be a legal neighborhood--
is that if nothing changes.

00:51:29.770 --> 00:51:33.260
So that means the head of the
machine was somewhere else.

00:51:33.260 --> 00:51:38.890
And so whatever was on
the tape in this step

00:51:38.890 --> 00:51:43.240
is going to be the same stuff
in those places one step later.

00:51:47.150 --> 00:51:52.210
Here's another possible
legal neighborhood.

00:51:52.210 --> 00:52:00.050
If the head suddenly
appears on one of the cells

00:52:00.050 --> 00:52:04.040
either in the left
or the right, that

00:52:04.040 --> 00:52:08.720
would correspond to the machine
moving its head from somewhere

00:52:08.720 --> 00:52:14.460
off the neighborhood into the
neighborhood in that step.

00:52:14.460 --> 00:52:16.730
So this could be a
legal neighborhood,

00:52:16.730 --> 00:52:18.470
provided the machine
actually does

00:52:18.470 --> 00:52:21.020
move its head left
into a state q5

00:52:21.020 --> 00:52:26.090
at some point under
some conditions.

00:52:26.090 --> 00:52:28.700
And here is another kind of
a weird legal neighborhood.

00:52:28.700 --> 00:52:32.810
If you have a, b, c, and
then the a changes to a d,

00:52:32.810 --> 00:52:34.910
that could also be
a legal neighborhood

00:52:34.910 --> 00:52:39.270
if the machine transition
function allows

00:52:39.270 --> 00:52:41.940
an a to get converted
to a d when there

00:52:41.940 --> 00:52:44.670
is some machine-- when there
is some state reading that a,

00:52:44.670 --> 00:52:46.950
and that state also
moves its head left.

00:52:46.950 --> 00:52:49.785
So it doesn't move
into this picture.

00:52:49.785 --> 00:52:51.660
So those are examples
of legal neighborhoods.

00:52:51.660 --> 00:52:54.488
Let me show you some
illegal neighborhoods.

00:52:54.488 --> 00:52:57.030
Just I'm doing this-- this is
kind of a proof by example now.

00:52:57.030 --> 00:52:59.490
This is perhaps the
most intuitive part.

00:52:59.490 --> 00:53:03.210
But I claim that this is easy
to turn this into something

00:53:03.210 --> 00:53:06.260
airtight and formal.

00:53:06.260 --> 00:53:08.330
So this would be
clearly illegal.

00:53:08.330 --> 00:53:15.680
If you have a piece of the
tape in the previous step where

00:53:15.680 --> 00:53:19.340
it's a, b, c, and then
suddenly the b changes to a d.

00:53:19.340 --> 00:53:23.030
The symbol on the tape
changes out of nowhere

00:53:23.030 --> 00:53:27.230
without having a head
nearby to a different--

00:53:27.230 --> 00:53:28.370
to something else.

00:53:28.370 --> 00:53:29.730
That could never happen.

00:53:29.730 --> 00:53:30.902
So that would be illegal.

00:53:30.902 --> 00:53:32.360
Another thing that
would be illegal

00:53:32.360 --> 00:53:35.200
is if a state
appears from nowhere.

00:53:35.200 --> 00:53:37.360
That could never happen.

00:53:37.360 --> 00:53:38.650
Or if it just disappears.

00:53:38.650 --> 00:53:40.640
That could never happen.

00:53:40.640 --> 00:53:43.280
And here's another--
here's an interesting one.

00:53:43.280 --> 00:53:45.005
If a state becomes two states.

00:53:49.060 --> 00:53:51.130
Don't forget the machine
is nondeterministic.

00:53:51.130 --> 00:53:53.110
So the machine in
principle could

00:53:53.110 --> 00:53:56.710
move its head left on one
branch and move its head right

00:53:56.710 --> 00:53:58.750
on a different branch,
but those would have

00:53:58.750 --> 00:54:00.070
to be in different tableaus.

00:54:00.070 --> 00:54:02.350
They can't be in
the same tableau,

00:54:02.350 --> 00:54:04.240
because that doesn't
correspond to any

00:54:04.240 --> 00:54:06.070
of the threads of the
computation, those

00:54:06.070 --> 00:54:08.410
with multiple threads.

00:54:08.410 --> 00:54:14.720
And I say this because if you
think about my claim, which

00:54:14.720 --> 00:54:18.200
is going to put down over
here, that if every 2

00:54:18.200 --> 00:54:21.980
by 3 neighborhood is legal, then
the tableau overall corresponds

00:54:21.980 --> 00:54:24.870
to a computation history.

00:54:24.870 --> 00:54:28.890
This illustrates why it's
not enough to have a 2

00:54:28.890 --> 00:54:33.300
by 2 neighborhood, where
you really need the 2 by 3.

00:54:33.300 --> 00:54:36.210
Because if this was a
2 by 2 neighborhood,

00:54:36.210 --> 00:54:38.970
if you just look at these four--

00:54:38.970 --> 00:54:46.860
this leftmost 2 by 2, that could
be a legal neighborhood if it

00:54:46.860 --> 00:54:51.240
was a 2 by 2, if the rules of
the machine allowed for that.

00:54:51.240 --> 00:54:54.000
And the right four box--

00:54:54.000 --> 00:54:56.970
right four cells could also
be a legal neighborhood.

00:54:56.970 --> 00:54:59.490
So you could have
something that looks

00:54:59.490 --> 00:55:02.670
OK from the perspective
of 2 by 2 neighborhoods,

00:55:02.670 --> 00:55:05.790
but globally, in terms
of the overall tableau,

00:55:05.790 --> 00:55:08.295
it's completely nonsensical
because it has multiple hits.

00:55:11.370 --> 00:55:13.380
But if you have a 2
by 3 neighborhood,

00:55:13.380 --> 00:55:17.620
it's big enough to prevent
this situation from occurring.

00:55:17.620 --> 00:55:22.170
And then you can
check the details.

00:55:22.170 --> 00:55:25.620
And I think it's very
plausible that it guarantees

00:55:25.620 --> 00:55:29.970
that the overall
tableau is legitimate

00:55:29.970 --> 00:55:34.650
if all of the 2 by 3
neighborhoods are legal.

00:55:34.650 --> 00:55:39.870
And so that's what we're
going to turn into a Boolean

00:55:39.870 --> 00:55:41.310
expression.

00:55:41.310 --> 00:55:46.380
We're going to say for
each cell that the set--

00:55:46.380 --> 00:55:49.830
for each neighborhood-- so
here's a neighborhood at the i,

00:55:49.830 --> 00:55:51.180
j location.

00:55:51.180 --> 00:55:53.790
I'm calling this
position here sort

00:55:53.790 --> 00:55:56.985
of the home location
for that neighborhood.

00:56:00.066 --> 00:56:04.990
For each neighborhood,
it has to be set to one

00:56:04.990 --> 00:56:07.480
of the legal possibilities.

00:56:07.480 --> 00:56:10.180
And there's, again, only
a fixed number of those

00:56:10.180 --> 00:56:13.150
because there's a fixed
number of possible symbols

00:56:13.150 --> 00:56:16.130
that can appear in those cells.

00:56:16.130 --> 00:56:19.570
So this is that fixed number
to the sixth power at most.

00:56:19.570 --> 00:56:24.530
And I'm going to say that
the cell in the upper left,

00:56:24.530 --> 00:56:27.880
which would be
this one, is in r.

00:56:27.880 --> 00:56:29.320
And this one here is an s.

00:56:29.320 --> 00:56:30.950
And this one is a t.

00:56:30.950 --> 00:56:33.610
And this one is a v, if
you just trace down what

00:56:33.610 --> 00:56:36.040
the indices are telling you.

00:56:36.040 --> 00:56:40.120
It says that that piece of the
tape, that piece of the tableau

00:56:40.120 --> 00:56:46.550
here is set according to one
of the possible legal settings.

00:56:46.550 --> 00:56:50.390
And we're just going to OR over
all of those possible fixed

00:56:50.390 --> 00:56:52.580
number of legal settings.

00:56:52.580 --> 00:56:57.890
And then I take an AND over
all possible tape cells,

00:56:57.890 --> 00:56:59.897
over all possible neighborhoods.

00:57:02.580 --> 00:57:04.350
And so that's going
to be my phi move.

00:57:06.870 --> 00:57:07.950
And that's it.

00:57:10.420 --> 00:57:10.920
OK.

00:57:10.920 --> 00:57:11.760
Let's see.

00:57:11.760 --> 00:57:15.240
Can I explain again the
third example of illegal?

00:57:15.240 --> 00:57:19.020
So this one over here, I
presume, I'm being asked about.

00:57:19.020 --> 00:57:25.700
Well, if the machine is
in a state q7 reading a c,

00:57:25.700 --> 00:57:27.500
the head has to move
either left or right.

00:57:27.500 --> 00:57:33.570
So at the next
configuration, there's

00:57:33.570 --> 00:57:37.320
got to be a state symbol
appearing either in this cell

00:57:37.320 --> 00:57:39.970
or in this cell.

00:57:39.970 --> 00:57:41.020
And here the tape--

00:57:41.020 --> 00:57:46.120
the head has basically
just vanished with nowhere

00:57:46.120 --> 00:57:48.550
to-- it's gone.

00:57:48.550 --> 00:57:52.862
That could not happen
according to the rules

00:57:52.862 --> 00:57:55.070
of the machine the way we
talk about Turing machines.

00:57:55.070 --> 00:57:56.330
So that's not possible.

00:57:56.330 --> 00:58:02.530
So this would be an
illegal neighborhood.

00:58:02.530 --> 00:58:05.140
You want to prevent
any of the bad stuff

00:58:05.140 --> 00:58:06.760
from happening anywhere in here.

00:58:06.760 --> 00:58:09.070
So only good stuff can
be happening locally.

00:58:09.070 --> 00:58:11.440
And that guarantees the
overall picture is OK.

00:58:16.720 --> 00:58:19.383
Do we have to check
that the head doesn't

00:58:19.383 --> 00:58:21.550
leave the tableau from the
left most to right right?

00:58:21.550 --> 00:58:23.675
Yeah, there are some little
details here like that.

00:58:23.675 --> 00:58:27.055
So the question is, do I
have to make sure that the--

00:58:27.055 --> 00:58:29.470
yeah, you probably need to mark.

00:58:29.470 --> 00:58:31.870
I think the book probably
does this correctly.

00:58:31.870 --> 00:58:34.480
You may have to mark
the left and right ends

00:58:34.480 --> 00:58:35.890
to make sure that--

00:58:35.890 --> 00:58:37.850
I mean, the right
end is not a problem,

00:58:37.850 --> 00:58:45.690
because the machine can
never go off the right end.

00:58:45.690 --> 00:58:48.180
And if you design the
machine so that it never

00:58:48.180 --> 00:58:51.198
moves its head off the left
end either, which you can do,

00:58:51.198 --> 00:58:53.490
then you wouldn't have to
worry about that possibility.

00:58:53.490 --> 00:58:56.940
But otherwise, you would have to
put some sort of delimiter here

00:58:56.940 --> 00:59:01.110
to enforce the head not
moving off the left end.

00:59:01.110 --> 00:59:03.030
So there are some
details like that, too.

00:59:05.923 --> 00:59:07.590
There will be two
heads in the same row.

00:59:07.590 --> 00:59:10.020
No, this can-- I don't know
what you-- somebody says,

00:59:10.020 --> 00:59:12.780
there will be two
heads in the same row.

00:59:12.780 --> 00:59:16.710
Please elaborate, because
this is designed not to allow

00:59:16.710 --> 00:59:18.000
two heads in the same row.

00:59:21.250 --> 00:59:23.510
Could I go over the
OR for legal again?

00:59:23.510 --> 00:59:24.010
OK.

00:59:24.010 --> 00:59:30.560
The OR, the big OR here, what
I have in mind is I take--

00:59:30.560 --> 00:59:33.020
there's going to be-- first
of all, I look at the machine

00:59:33.020 --> 00:59:35.580
and I look at the
transition function.

00:59:35.580 --> 00:59:41.900
And based on that, I write down
the list of all the legal 2

00:59:41.900 --> 00:59:42.980
by 3 neighborhoods.

00:59:42.980 --> 00:59:46.040
So all the settings which
correspond to legal 2

00:59:46.040 --> 00:59:47.090
by 3 neighborhoods.

00:59:47.090 --> 00:59:49.460
There's going to be some
fixed number of those.

00:59:49.460 --> 00:59:52.400
100.

00:59:52.400 --> 00:59:55.310
There's 100 possible legal
neighborhoods of which

00:59:55.310 --> 00:59:57.820
I've written down here four.

00:59:57.820 --> 01:00:00.310
But maybe there's
some number, say 100.

01:00:00.310 --> 01:00:03.730
So now there's going to
be an OR over those 100

01:00:03.730 --> 01:00:05.360
different possibilities.

01:00:05.360 --> 01:00:07.360
It's either going to be
this legal neighborhood,

01:00:07.360 --> 01:00:08.620
or some other
legal neighborhood,

01:00:08.620 --> 01:00:10.090
or some other
legal neighborhood.

01:00:10.090 --> 01:00:12.580
And for each one of those
legal neighborhoods,

01:00:12.580 --> 01:00:16.940
I'm going to say, well, the
variables are set according

01:00:16.940 --> 01:00:21.530
to that legal neighborhood, or
the variables are set according

01:00:21.530 --> 01:00:23.975
to the next legal neighborhood,
or the variables are

01:00:23.975 --> 01:00:25.850
set according to the
next legal neighborhood,

01:00:25.850 --> 01:00:28.300
and do that 100 times.

01:00:28.300 --> 01:00:30.530
One of those has got to end up--

01:00:30.530 --> 01:00:33.170
I mean it's an OR, so
one of them has to work.

01:00:33.170 --> 01:00:34.480
Otherwise, the formula fails.

01:00:34.480 --> 01:00:36.520
And it will be
false, because you're

01:00:36.520 --> 01:00:39.970
going to AND that over
all of the neighborhoods

01:00:39.970 --> 01:00:40.600
in the picture.

01:00:46.630 --> 01:00:48.910
Is it possible to have
a head on the far left

01:00:48.910 --> 01:00:51.235
of the configuration and
one on the far right?

01:00:55.240 --> 01:00:58.110
You mean a head over here
and a head over there?

01:00:58.110 --> 01:01:00.480
I mean, how'd the
head get there?

01:01:00.480 --> 01:01:03.730
It can't happen.

01:01:03.730 --> 01:01:08.970
You know, the head has to
come from a head above it.

01:01:08.970 --> 01:01:11.670
If you're going to be
worrying about the details

01:01:11.670 --> 01:01:16.980
of the boundaries here,
all that's fixable.

01:01:16.980 --> 01:01:21.593
So let's not lose
sight of the main idea.

01:01:21.593 --> 01:01:23.260
I mean, if you
understand the main idea,

01:01:23.260 --> 01:01:25.090
you can fix the little details.

01:01:25.090 --> 01:01:27.465
So I want to make sure you
understand the main idea

01:01:27.465 --> 01:01:29.700
of what's happening.

01:01:29.700 --> 01:01:31.395
So let's finish up this proof.

01:01:34.010 --> 01:01:38.950
So in summary, we gave a
reduction from 8 to SAT.

01:01:38.950 --> 01:01:41.890
This is what we needed.

01:01:41.890 --> 01:01:43.960
It was in those four pieces.

01:01:43.960 --> 01:01:45.520
And you really
just need to argue

01:01:45.520 --> 01:01:49.740
that that formula we're
building is not too big.

01:01:49.740 --> 01:01:52.020
And it's going to be basically
the size of the tableau

01:01:52.020 --> 01:01:54.960
if you look at what
we constructed.

01:01:54.960 --> 01:01:56.760
The number of variables
is roughly the size

01:01:56.760 --> 01:01:57.810
of the tableau.

01:01:57.810 --> 01:02:00.540
And the amount of logic that
we're putting into the formula

01:02:00.540 --> 01:02:02.310
is also going to
be a fixed amount

01:02:02.310 --> 01:02:05.730
of logic independent
of n for each

01:02:05.730 --> 01:02:08.430
of the variables
in that tableau.

01:02:08.430 --> 01:02:11.850
And somebody asked me about the
size-- how big the indices are.

01:02:14.470 --> 01:02:22.060
The indices for the x i
value, the i and j values,

01:02:22.060 --> 01:02:24.910
technically, they're going
to be numbers between 1

01:02:24.910 --> 01:02:25.990
and n to the k.

01:02:25.990 --> 01:02:27.860
So you're going to have
to write those down.

01:02:27.860 --> 01:02:30.235
And so that's going to be a
slight additional logarithmic

01:02:30.235 --> 01:02:32.280
cost to write those things down.

01:02:32.280 --> 01:02:34.000
It's not really that
interesting a point.

01:02:36.760 --> 01:02:39.490
And so the overall
f is going to be

01:02:39.490 --> 01:02:41.980
computable in polynomial time
because the output is not

01:02:41.980 --> 01:02:42.800
very big.

01:02:42.800 --> 01:02:46.590
And it's also not complicated
to write the output down.

01:02:46.590 --> 01:02:50.670
So that's the end of the proof.

01:02:50.670 --> 01:02:54.580
I can take a couple
of questions.

01:02:54.580 --> 01:02:56.455
Why can't we just check
that the whole-- this

01:02:56.455 --> 01:02:56.990
is a good question.

01:02:56.990 --> 01:02:59.157
Why can't we just check
that the whole row is legal?

01:03:05.200 --> 01:03:08.530
You can check that a row
actually is a configuration.

01:03:08.530 --> 01:03:15.390
But to check that the row
follows from the previous row,

01:03:15.390 --> 01:03:18.600
ultimately, the operation
of a Turing machine

01:03:18.600 --> 01:03:20.820
is a local thing.

01:03:20.820 --> 01:03:26.730
I mean, the way it moves from
one configuration to the next

01:03:26.730 --> 01:03:31.230
depends locally on
how where the head is.

01:03:31.230 --> 01:03:34.200
And so really, that's
just another way of--

01:03:34.200 --> 01:03:36.450
the way I'm saying it
is just really checking

01:03:36.450 --> 01:03:39.482
the whole configuration,
but just doing it locally.

01:03:39.482 --> 01:03:41.190
I don't know if that's
satisfying to you.

01:03:44.700 --> 01:03:46.278
Why don't I move
on because I just

01:03:46.278 --> 01:03:47.820
want to make sure
we have enough time

01:03:47.820 --> 01:03:50.400
to get to the very last
part, which is a little bit--

01:03:50.400 --> 01:03:52.710
I'm afraid, a little technical.

01:03:52.710 --> 01:03:56.310
So we're going to kind of
shift gears now and talk

01:03:56.310 --> 01:04:00.870
about reducing SAT to 3SAT.

01:04:00.870 --> 01:04:07.010
And let's see how it goes.

01:04:07.010 --> 01:04:08.560
I don't always have
the most success

01:04:08.560 --> 01:04:11.380
with presenting
this little piece,

01:04:11.380 --> 01:04:13.190
because it's slightly
a technical argument.

01:04:13.190 --> 01:04:16.270
But if you don't
get it, don't worry.

01:04:16.270 --> 01:04:18.772
Just you have to
accept that it's true.

01:04:18.772 --> 01:04:20.230
But I'd like to
show it to you just

01:04:20.230 --> 01:04:27.420
to make the whole presentation
complete in that sense.

01:04:27.420 --> 01:04:33.240
So I'm going to give a reduction
that maps general formulas

01:04:33.240 --> 01:04:35.880
to 3CNF formulas.

01:04:35.880 --> 01:04:40.100
So that's how we
map SAT to 3SAT.

01:04:40.100 --> 01:04:42.710
If you remember 3SAT
is satisfiability

01:04:42.710 --> 01:04:45.140
but for three CNFs.

01:04:45.140 --> 01:04:48.860
So a conjunctive normal form
in the form of those clauses,

01:04:48.860 --> 01:04:50.420
which are ANDed together.

01:04:50.420 --> 01:04:54.530
And each clause is an OR of a
bunch of literals, which are

01:04:54.530 --> 01:04:58.080
variables or negated variables.

01:04:58.080 --> 01:05:04.220
So I want to convert phi to phi
prime, which is 3CNF formula,

01:05:04.220 --> 01:05:07.070
but preserve the satisfiability.

01:05:07.070 --> 01:05:10.460
And phi prime is not going to
be logically equivalent to phi,

01:05:10.460 --> 01:05:12.680
because I could do that, too.

01:05:12.680 --> 01:05:17.480
I can convert any formula to
a logically equivalent CNF

01:05:17.480 --> 01:05:18.200
formula.

01:05:18.200 --> 01:05:20.675
Maybe not even a
3CNF, but yeah, you

01:05:20.675 --> 01:05:23.870
won't be able to get a
3CNF, but you can get a CNF.

01:05:23.870 --> 01:05:26.405
But it might be
exponentially larger.

01:05:26.405 --> 01:05:27.530
And that's not good enough.

01:05:27.530 --> 01:05:30.270
I have to do the reduction
in polynomial time.

01:05:30.270 --> 01:05:32.720
So I can't generate
a much larger formula

01:05:32.720 --> 01:05:34.190
that's exponentially larger.

01:05:34.190 --> 01:05:40.650
And so I'm going to do that by
adding additional variables.

01:05:40.650 --> 01:05:42.140
So it won't be
logically equivalent

01:05:42.140 --> 01:05:44.120
because the new formula
is going to have

01:05:44.120 --> 01:05:46.510
additional variables in it.

01:05:46.510 --> 01:05:49.250
I'm going to kind
of do it by example.

01:05:49.250 --> 01:05:51.840
And we'll see how that goes.

01:05:51.840 --> 01:05:56.770
So here's phi, which
is not in 3CNF.

01:05:56.770 --> 01:05:59.730
It's not even in
CNF, because it's

01:05:59.730 --> 01:06:03.840
got ORs of ANDs
appearing, which is not

01:06:03.840 --> 01:06:07.600
allowed to happen in a CNF.

01:06:07.600 --> 01:06:10.960
So how are we going
to convert that

01:06:10.960 --> 01:06:14.980
into a 3CNF formula
preserving the satisfiability?

01:06:14.980 --> 01:06:17.800
And just working it
through with this example,

01:06:17.800 --> 01:06:20.140
I hope to at least give
you some idea of how you

01:06:20.140 --> 01:06:22.040
do the conversion in general.

01:06:22.040 --> 01:06:24.340
So first of all, I'm going
to represent this formula

01:06:24.340 --> 01:06:29.100
as a tree using its
natural tree structure.

01:06:29.100 --> 01:06:30.140
So you understand.

01:06:30.140 --> 01:06:34.910
So a AND B becomes a
AND b written as a tree.

01:06:34.910 --> 01:06:37.830
And then I OR that with c.

01:06:37.830 --> 01:06:41.310
So I get the tree structure
here in sort of the natural way.

01:06:41.310 --> 01:06:45.120
And I'm going to label all of
these intermediate nodes, which

01:06:45.120 --> 01:06:49.400
are associated now
with operations.

01:06:49.400 --> 01:06:55.760
And I'm assuming also that the
formula is fully parenthesized

01:06:55.760 --> 01:06:58.280
so that each operation
I'm only thinking about

01:06:58.280 --> 01:07:02.600
is applying just the two--
it's a binary operation.

01:07:02.600 --> 01:07:05.750
And let's ignore negations for
the minute, because negations,

01:07:05.750 --> 01:07:08.220
you can always push those
through down to the leaves.

01:07:08.220 --> 01:07:11.665
But it's just going to
make it too complicated.

01:07:11.665 --> 01:07:13.415
So negations turn out
not to be a problem.

01:07:16.140 --> 01:07:17.690
So there's only
going to be negations

01:07:17.690 --> 01:07:22.610
at the level of the
inputs, not at the negation

01:07:22.610 --> 01:07:25.370
operations in the middle.

01:07:25.370 --> 01:07:27.420
So we have this
tree structure here.

01:07:27.420 --> 01:07:31.580
And now I'm going to use
these two logical facts.

01:07:31.580 --> 01:07:34.040
And I don't know if--

01:07:34.040 --> 01:07:36.740
you've probably all seen
ANDs and ORs, I hope.

01:07:36.740 --> 01:07:38.990
Otherwise, it's going
to be really tough.

01:07:38.990 --> 01:07:40.970
But there's also other
logical operators,

01:07:40.970 --> 01:07:43.850
such as the
implication operator,

01:07:43.850 --> 01:07:52.500
where you have A implies B
sort of as a logical operation.

01:07:52.500 --> 01:07:58.590
And so this requires that if
A is true, then B is true.

01:08:02.920 --> 01:08:07.380
However, if A is false,
B can be anything.

01:08:07.380 --> 01:08:09.660
And similarly if B is
true, A can be anything.

01:08:12.570 --> 01:08:15.710
The only thing that's
prohibited is that if A is true

01:08:15.710 --> 01:08:17.180
and B is false.

01:08:17.180 --> 01:08:20.569
That's the only thing
that would be invalid.

01:08:20.569 --> 01:08:22.520
And so if you think
about it, that's

01:08:22.520 --> 01:08:26.180
going to be equivalent to
saying that either A is false

01:08:26.180 --> 01:08:27.770
or B is true.

01:08:27.770 --> 01:08:30.109
One of those has to be.

01:08:30.109 --> 01:08:32.750
And that's going to be
logically equivalent to saying

01:08:32.750 --> 01:08:36.649
that A implies B.

01:08:36.649 --> 01:08:39.410
Another logical equivalence
may be more familiar to you.

01:08:39.410 --> 01:08:42.200
It's just simply
De Morgan's law,

01:08:42.200 --> 01:08:47.210
which says that if you have
the not of A AND B, that's

01:08:47.210 --> 01:08:54.750
equivalent to saying the
not of A or the not of B.

01:08:54.750 --> 01:08:57.960
I'm going to make
use of both of these.

01:08:57.960 --> 01:09:01.660
Now, here, I want to--

01:09:01.660 --> 01:09:03.080
I ran out of room on this slide.

01:09:03.080 --> 01:09:05.205
So I'm going to take myself
out of the picture here

01:09:05.205 --> 01:09:05.950
for a minute.

01:09:08.930 --> 01:09:10.810
I had no place else to put this.

01:09:10.810 --> 01:09:12.729
So here we have--

01:09:12.729 --> 01:09:14.979
if you're going to
think of the AND

01:09:14.979 --> 01:09:19.359
in terms of its truth
table, so here's a and b

01:09:19.359 --> 01:09:22.000
in terms of a and b.

01:09:22.000 --> 01:09:27.790
So 1 and 1 is 1, but all
other settings of a and b

01:09:27.790 --> 01:09:30.420
yield 0 for the AND.

01:09:30.420 --> 01:09:32.234
And I'm going to
represent those--

01:09:35.300 --> 01:09:38.330
if you imagine a and b
is going to be called c.

01:09:38.330 --> 01:09:41.240
I'm going to represent
this information

01:09:41.240 --> 01:09:48.620
with four small formulas, which
taken together, you AND them

01:09:48.620 --> 01:09:52.490
together, are going to force
c to have the correct behavior

01:09:52.490 --> 01:09:54.196
associated with a AND b.

01:10:00.610 --> 01:10:03.970
So if a AND b are
both 1, then c is 1.

01:10:03.970 --> 01:10:14.260
If a is 0 and b is 1,
then it forces c to be 0.

01:10:14.260 --> 01:10:18.700
And similarly, every other
setting besides a AND

01:10:18.700 --> 01:10:24.520
b being true, for C to
be false, which is what

01:10:24.520 --> 01:10:26.410
you want when you have AND.

01:10:26.410 --> 01:10:29.170
So I'm going to write
this expression here down

01:10:29.170 --> 01:10:35.460
with z1 being in the place of
c by just taking those four

01:10:35.460 --> 01:10:38.320
expressions and
ANDing them together.

01:10:38.320 --> 01:10:41.190
So this is exactly those same
four expressions written out

01:10:41.190 --> 01:10:42.800
linearly.

01:10:42.800 --> 01:10:45.800
Now I want to do the
same thing for z2,

01:10:45.800 --> 01:10:48.148
but now that's written
in terms of an OR.

01:10:48.148 --> 01:10:49.940
So there's a slightly
different truth table

01:10:49.940 --> 01:10:51.515
here up in this corner.

01:10:55.030 --> 01:10:59.420
So now if either one is
1, we get a 1 result.

01:10:59.420 --> 01:11:06.380
And so now if a AND b are
true, you get c is true.

01:11:06.380 --> 01:11:08.740
However, if a is
true and b is false,

01:11:08.740 --> 01:11:12.210
that still implies c is true.

01:11:12.210 --> 01:11:20.340
So I'm going to write down
those rules for specifying

01:11:20.340 --> 01:11:25.320
how z2 must be set.

01:11:25.320 --> 01:11:27.150
And each one of
these things is going

01:11:27.150 --> 01:11:31.290
to get converted into clauses,
three clauses with three

01:11:31.290 --> 01:11:36.790
literals, using these
rules over here.

01:11:36.790 --> 01:11:39.570
So I'm going to do
that for each zi.

01:11:39.570 --> 01:11:42.430
And lastly, to make sure the
whole thing is satisfied,

01:11:42.430 --> 01:11:44.340
which means there's
an output of one here,

01:11:44.340 --> 01:11:47.850
I'm going to have one
clause associated, which

01:11:47.850 --> 01:11:52.700
says that z4, the output, is 1.

01:11:52.700 --> 01:11:57.950
Now, I can convert all of those
when I have a AND b implies c.

01:11:57.950 --> 01:12:03.147
That's logically equivalent
to not a OR not b OR c.

01:12:03.147 --> 01:12:04.730
And the way you can
see that is really

01:12:04.730 --> 01:12:08.780
by repeated application
of these rules here.

01:12:08.780 --> 01:12:11.070
We're running a
little low on time.

01:12:11.070 --> 01:12:14.300
So maybe you'll just have
to check this offline.

01:12:14.300 --> 01:12:21.390
But quickly, a AND b implies
c using the first equivalence

01:12:21.390 --> 01:12:26.190
is the not of this
part, OR C. And then

01:12:26.190 --> 01:12:30.420
I can use De Morgan to
convert that not of an AND

01:12:30.420 --> 01:12:33.360
to an OR of the nots.

01:12:33.360 --> 01:12:36.810
And then I can remove
the parentheses

01:12:36.810 --> 01:12:39.840
because OR is associative.

01:12:39.840 --> 01:12:43.770
And so I get a clause,
which is what I need.

01:12:43.770 --> 01:12:47.130
So each one of these guys is
really equivalent to a clause.

01:12:47.130 --> 01:12:49.038
And so I just get
a bunch of clauses.

01:12:49.038 --> 01:12:50.580
And actually,
technically, this needs

01:12:50.580 --> 01:12:55.410
to be three, a copy
of three things here.

01:12:55.410 --> 01:13:02.910
It should be z4 OR z4
OR z4, which is a lot.

01:13:02.910 --> 01:13:05.520
So check-in--
[INAUDIBLE] I realize

01:13:05.520 --> 01:13:08.910
my check-in is broken, because
I only realized that last point

01:13:08.910 --> 01:13:10.440
just now as I was talking.

01:13:10.440 --> 01:13:16.140
So the actual value
that you get in terms

01:13:16.140 --> 01:13:19.200
of-- oh, no, the number
of clauses is correct.

01:13:19.200 --> 01:13:20.640
No, I take it back.

01:13:20.640 --> 01:13:21.820
This is fine.

01:13:21.820 --> 01:13:23.700
So if you understood
what I was saying,

01:13:23.700 --> 01:13:27.960
hopefully, you can see
how big the formula

01:13:27.960 --> 01:13:33.840
phi prime is in terms of the
number of operations in phi.

01:13:33.840 --> 01:13:35.940
So let's see how
many people get that.

01:13:35.940 --> 01:13:41.820
I acknowledge this may be a
little on the technical side.

01:13:41.820 --> 01:13:42.390
OK.

01:13:42.390 --> 01:13:46.040
I'm going to close
it, close it down.

01:13:46.040 --> 01:13:47.040
Please enter your value.

01:13:50.440 --> 01:13:52.670
OK.

01:13:52.670 --> 01:13:56.870
Yeah, the correct
answer is 4k plus 1,

01:13:56.870 --> 01:14:02.940
because each one
of these operations

01:14:02.940 --> 01:14:04.965
is going to end up being
a row in this picture.

01:14:07.520 --> 01:14:10.040
Each operation is going to have
a variable associated to it.

01:14:10.040 --> 01:14:12.090
It's going to become
a row in this picture.

01:14:12.090 --> 01:14:20.060
And so then each row is going
to have four clauses, which

01:14:20.060 --> 01:14:26.090
define what you need--
set what you need in order

01:14:26.090 --> 01:14:30.890
to force that variable to have
the right value corresponding

01:14:30.890 --> 01:14:31.850
to that operation.

01:14:34.800 --> 01:14:38.220
And so then you need-- and
you need one extra clause here

01:14:38.220 --> 01:14:43.020
for saying that this whole
thing evaluates to true.

01:14:45.630 --> 01:14:50.730
So that's all I
wanted to do today.

01:14:50.730 --> 01:14:52.860
We proved those
two main theorems.

01:14:52.860 --> 01:14:55.750
And now we know that there
are NP-complete problems.

01:14:55.750 --> 01:14:59.670
And all of the other problems
that we can get from--

01:14:59.670 --> 01:15:02.550
by reductions from
these problems

01:15:02.550 --> 01:15:07.170
are also going to be NP-complete
as long as they're in NP.

01:15:07.170 --> 01:15:09.030
So that's it.

01:15:09.030 --> 01:15:13.680
Feel free to put some
questions into the chat,

01:15:13.680 --> 01:15:17.580
or move on to whatever else
you're going to be doing next.

01:15:17.580 --> 01:15:19.950
So a good question here
is, why is phi prime

01:15:19.950 --> 01:15:22.305
not logically equivalent
with this construction?

01:15:22.305 --> 01:15:24.780
It can't be
logically equivalent.

01:15:24.780 --> 01:15:27.180
Logically equivalent
means that it gives you

01:15:27.180 --> 01:15:28.950
exactly the same function.

01:15:28.950 --> 01:15:31.020
If you set the variables
in the same way,

01:15:31.020 --> 01:15:34.250
you get the same
result coming out.

01:15:34.250 --> 01:15:37.700
Well, phi prime has more
variables than phi does.

01:15:37.700 --> 01:15:39.680
So it wouldn't even
make sense to talk

01:15:39.680 --> 01:15:41.420
about logical equivalence
because they're

01:15:41.420 --> 01:15:44.070
two functions on different
numbers of variables.

01:15:44.070 --> 01:15:47.150
So in that sense, it
doesn't really make sense.

01:15:47.150 --> 01:15:50.390
What you could say is
that for every setting

01:15:50.390 --> 01:15:54.050
of the overlapping
variables, so the variables

01:15:54.050 --> 01:15:56.070
that appear in both
phi and phi prime--

01:15:56.070 --> 01:15:58.670
so those are the original
variables of phi--

01:15:58.670 --> 01:16:02.900
there's going to exist some
setting of new variables, which

01:16:02.900 --> 01:16:04.960
is going to make the--

01:16:11.997 --> 01:16:13.580
there's going to
be-- there will exist

01:16:13.580 --> 01:16:15.260
some setting of the
new variables which

01:16:15.260 --> 01:16:17.660
will make the two
formulas agree,

01:16:17.660 --> 01:16:20.914
but that's not the definition
of logical equivalence.

01:16:23.970 --> 01:16:28.890
So why-- going back to the
proof, the satisfiability proof

01:16:28.890 --> 01:16:30.840
and the legal
neighborhoods, could I

01:16:30.840 --> 01:16:35.010
go over why the number of legal
neighborhoods is polynomial.

01:16:35.010 --> 01:16:36.390
The number of
legal neighborhoods

01:16:36.390 --> 01:16:38.100
is not only polynomial.

01:16:38.100 --> 01:16:40.810
It's constant.

01:16:40.810 --> 01:16:42.610
It depends only on the machine.

01:16:42.610 --> 01:16:49.840
It does not depend on M.
Because each cell can have

01:16:49.840 --> 01:16:52.480
at most some fixed number of--

01:16:52.480 --> 01:16:55.210
can have the number
of tape symbols

01:16:55.210 --> 01:16:56.890
plus the number
of state symbols.

01:16:56.890 --> 01:16:59.980
That depends on
the machine only.

01:16:59.980 --> 01:17:06.340
So now we have six tape cells
for the six cells in a 2

01:17:06.340 --> 01:17:07.360
by 3 neighborhood.

01:17:07.360 --> 01:17:09.970
So you're going to have that
number to the sixth power.

01:17:09.970 --> 01:17:11.900
But still, it's a constant
to the sixth power.

01:17:11.900 --> 01:17:12.817
It's still a constant.

01:17:12.817 --> 01:17:15.340
It doesn't depend on M.
So it's not a question

01:17:15.340 --> 01:17:18.340
of even being polynomial.

01:17:18.340 --> 01:17:19.400
It's a constant value.

01:17:19.400 --> 01:17:21.580
It's a constant
multiplier if you

01:17:21.580 --> 01:17:26.290
want to think about it in terms
of the size of the formula

01:17:26.290 --> 01:17:27.970
that's going to result.

01:17:27.970 --> 01:17:36.310
Don't forget we're trying
to make a formula which is--

01:17:36.310 --> 01:17:40.340
the reduction has
to be polynomial.

01:17:40.340 --> 01:17:41.800
It's a polynomial
time reduction.

01:17:41.800 --> 01:17:45.410
So that means that
as n increases,

01:17:45.410 --> 01:17:47.770
the time to calculate
the reduction increases

01:17:47.770 --> 01:17:50.290
as a polynomial.

01:17:50.290 --> 01:17:58.090
But we're fixing M.
So M does not change.

01:17:58.090 --> 01:18:00.570
So therefore anything
that depends on M only

01:18:00.570 --> 01:18:03.760
is just going to be a constant
impact on the formula.

01:18:03.760 --> 01:18:04.830
It's not going to be--

01:18:04.830 --> 01:18:08.200
it doesn't depend on M.

01:18:08.200 --> 01:18:10.980
OK, everybody.

01:18:10.980 --> 01:18:12.210
Bye bye.

01:18:12.210 --> 01:18:13.940
See you.