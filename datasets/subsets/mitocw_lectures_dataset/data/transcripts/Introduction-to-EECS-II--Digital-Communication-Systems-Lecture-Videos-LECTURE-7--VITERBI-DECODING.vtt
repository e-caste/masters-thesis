WEBVTT

00:00:00.000 --> 00:00:02.490
The following content is
provided under a Creative

00:00:02.490 --> 00:00:04.059
Commons license.

00:00:04.059 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.720
continue to offer high-quality
educational resources for free.

00:00:10.720 --> 00:00:13.350
To make a donation or
view additional materials

00:00:13.350 --> 00:00:17.300
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.300 --> 00:00:18.300
at ocw.mit.edu.

00:00:25.305 --> 00:00:26.680
PROFESSOR: All
right, we're going

00:00:26.680 --> 00:00:29.310
to continue talking
about convolutional code.

00:00:29.310 --> 00:00:32.640
So I want to give you a quick
reminder of how coding works

00:00:32.640 --> 00:00:35.190
and then talk to
you about decoding.

00:00:35.190 --> 00:00:37.330
Can you hear me OK now?

00:00:37.330 --> 00:00:37.830
All right?

00:00:37.830 --> 00:00:38.330
OK.

00:00:42.410 --> 00:00:48.000
So we talked in terms
of a state diagram,

00:00:48.000 --> 00:00:51.470
but let me remind you of the
shift register picture was.

00:00:51.470 --> 00:00:55.970
So we had a two-stage
shift register.

00:00:55.970 --> 00:01:00.860
For this particular
example, we had xn, a stream

00:01:00.860 --> 00:01:03.210
of data being fed in here.

00:01:03.210 --> 00:01:04.760
So since this is
a shift register,

00:01:04.760 --> 00:01:09.830
what sits in here at time
n is the previous input.

00:01:09.830 --> 00:01:15.680
What sits here is the
input from 2 times ago.

00:01:15.680 --> 00:01:19.370
And you can then feed these
off and get your parity check.

00:01:19.370 --> 00:01:27.940
So take these in
particular combinations

00:01:27.940 --> 00:01:29.670
and make your parity checks.

00:01:29.670 --> 00:01:37.725
So you can have one box
spitting out a p0 of n.

00:01:37.725 --> 00:01:39.100
And then you can
have another box

00:01:39.100 --> 00:01:44.350
that takes these same outputs
from the shift register

00:01:44.350 --> 00:01:47.320
and puts out--

00:01:47.320 --> 00:01:50.590
let me just show them.

00:01:50.590 --> 00:01:55.270
Actually, why don't
I just put it here?

00:01:55.270 --> 00:01:58.510
You generate a bunch
of party check bits.

00:01:58.510 --> 00:02:00.820
And I've shown an
example on top where--

00:02:00.820 --> 00:02:03.630
this is the same one
I used last time.

00:02:03.630 --> 00:02:05.080
p0 at time n--

00:02:05.080 --> 00:02:06.610
I should have had an n there--

00:02:06.610 --> 00:02:10.419
is xn plus xn minus
1 plus xn minus 2.

00:02:10.419 --> 00:02:13.660
And p1, xn, and at xn minus 2.

00:02:13.660 --> 00:02:16.630
And we skip the xn minus 1.

00:02:16.630 --> 00:02:21.940
But you can choose different
coefficients there.

00:02:21.940 --> 00:02:23.500
Different coefficients
will give you

00:02:23.500 --> 00:02:25.100
codes that have
different properties.

00:02:25.100 --> 00:02:30.880
So the choices in the code are
how many shift registers do

00:02:30.880 --> 00:02:32.810
you have, so how much memory.

00:02:32.810 --> 00:02:45.400
The constraint length
here is equal to what?

00:02:45.400 --> 00:02:48.080
Constraint length in
this particular example

00:02:48.080 --> 00:02:49.210
on the slide?

00:02:49.210 --> 00:02:50.483
AUDIENCE: 3.

00:02:50.483 --> 00:02:51.400
PROFESSOR: k equals 3?

00:02:51.400 --> 00:02:54.010
Oh, you can see it.

00:02:54.010 --> 00:02:56.560
It's the number of
message bits that

00:02:56.560 --> 00:03:00.692
are involved in generating
a parity bit at the maximum.

00:03:00.692 --> 00:03:01.900
It's actually not the number.

00:03:01.900 --> 00:03:04.720
It's the window
over which you're

00:03:04.720 --> 00:03:08.170
taking message bits to combine
to make the parity bits.

00:03:11.720 --> 00:03:15.660
All right, so for instance,
if you just had p1,

00:03:15.660 --> 00:03:18.270
you would still say that
your constraint length is 3,

00:03:18.270 --> 00:03:21.610
because you're involving a
window of three message bits.

00:03:21.610 --> 00:03:24.850
It's the span over
which you're extending.

00:03:24.850 --> 00:03:27.130
All right, now, in terms
of interpreting this,

00:03:27.130 --> 00:03:31.380
we've got the possible states of
the shift register combination.

00:03:31.380 --> 00:03:37.900
So 0, 0; 0, 1' 1, 0' 1, 1, these
are the four possible states.

00:03:37.900 --> 00:03:46.060
So in general, what you have
is for a constraint length k,

00:03:46.060 --> 00:03:53.680
you've got 2 to the k minus 1
states, because one of these

00:03:53.680 --> 00:03:54.615
is the input.

00:03:54.615 --> 00:03:56.240
And then the other
is stored in memory.

00:03:56.240 --> 00:03:58.280
So you've got k minus
1 stored in memory.

00:03:58.280 --> 00:04:01.030
So that's the number of
states that you have.

00:04:01.030 --> 00:04:03.880
And that's how these
circles are labeled here.

00:04:03.880 --> 00:04:06.610
And then on each of
the arcs, what you have

00:04:06.610 --> 00:04:12.040
is the message bit that's coming
in at that time and the parity

00:04:12.040 --> 00:04:14.020
bits that are emitted.

00:04:14.020 --> 00:04:19.930
So for instance, from 0,
0, if you've got 0 here

00:04:19.930 --> 00:04:23.980
and 0 here, the only places
you can go to at the next step

00:04:23.980 --> 00:04:27.220
are 0, 0, and 0, 1,
because you can either--

00:04:27.220 --> 00:04:30.910
sorry, 0, 0 and 1, 0,
because you can either

00:04:30.910 --> 00:04:33.660
feet in a 0 or a 1 from here.

00:04:33.660 --> 00:04:36.580
If you feed in a 0, then at the
next state, you're still in 0.

00:04:36.580 --> 00:04:40.660
If you feed in a 1, then at
the next state, you're 1, 0.

00:04:40.660 --> 00:04:43.550
So those are the only
possibilities from 0, 0.

00:04:43.550 --> 00:04:48.280
And if you had a 1 in, you
would go from 0, 0 to 1, 0.

00:04:48.280 --> 00:04:50.780
And what would be your
parity check bits?

00:04:50.780 --> 00:04:54.040
So if you had 1 at
the input and you

00:04:54.040 --> 00:04:56.640
have the parity
check expressions

00:04:56.640 --> 00:04:59.950
that I have up here, you see
that what you would be emitting

00:04:59.950 --> 00:05:03.066
would be a 1 and a 1.

00:05:03.066 --> 00:05:05.910
Is that right?

00:05:05.910 --> 00:05:09.510
If you had a 1 in
the input, 0, 0,

00:05:09.510 --> 00:05:12.648
and you use these two parity
bits, you generate a 1 and a 1.

00:05:12.648 --> 00:05:14.190
So that's how these
arcs are labeled.

00:05:22.560 --> 00:05:24.240
Now we said, to
actually understand

00:05:24.240 --> 00:05:27.600
the convolutional code
well, what you really

00:05:27.600 --> 00:05:29.970
want to do is translate
the state transition

00:05:29.970 --> 00:05:32.700
diagram to a trellis diagram.

00:05:32.700 --> 00:05:35.730
This is just showing two
stages of the trellis.

00:05:35.730 --> 00:05:37.980
In general, the trellis
would be the state diagram

00:05:37.980 --> 00:05:42.700
unfolded over the whole
time interval of interest.

00:05:42.700 --> 00:05:43.720
So it's the same thing.

00:05:43.720 --> 00:05:44.650
It's just that we've--

00:05:44.650 --> 00:05:45.150
let's see.

00:05:45.150 --> 00:05:50.910
We've chosen to write the
states in binary counting order,

00:05:50.910 --> 00:05:53.540
so 0, 0; 0, 1; 1, 0; 1, 1.

00:05:53.540 --> 00:05:57.040
It was arranged slightly
differently here.

00:05:57.040 --> 00:05:58.690
Apart from that,
it's the same thing.

00:05:58.690 --> 00:06:00.900
So we're drawing the
state diagram here.

00:06:00.900 --> 00:06:02.760
We're drawing the
same state diagram

00:06:02.760 --> 00:06:06.530
here except this is representing
the state possibilities

00:06:06.530 --> 00:06:07.740
at time--

00:06:07.740 --> 00:06:08.772
at one particular time.

00:06:08.772 --> 00:06:10.230
And this is the
state possibilities

00:06:10.230 --> 00:06:11.672
of the next particular time.

00:06:11.672 --> 00:06:13.380
So the state transition
arrows are always

00:06:13.380 --> 00:06:16.170
going from one stage
to the next, all right?

00:06:16.170 --> 00:06:19.290
So the arrow that we
saw here, which takes us

00:06:19.290 --> 00:06:22.710
from 0, 0 to 1, 0
is going to take us

00:06:22.710 --> 00:06:25.620
from this box to this box.

00:06:25.620 --> 00:06:28.670
And what it emits on the
way is the 1 and the--

00:06:28.670 --> 00:06:30.690
sorry, the 1, 1.

00:06:30.690 --> 00:06:32.490
What it emits is the 1, 1.

00:06:32.490 --> 00:06:34.380
So each arc is labeled
in the same way.

00:06:34.380 --> 00:06:37.830
This is just a rearrangement.

00:06:37.830 --> 00:06:40.630
Now, the nice thing I mentioned
last time, the nice thing

00:06:40.630 --> 00:06:44.020
about this is, when you have
this in binary counting order,

00:06:44.020 --> 00:06:47.380
then the upper arc of the two
that emanate from each box

00:06:47.380 --> 00:06:49.540
corresponds to an input of 0.

00:06:49.540 --> 00:06:51.850
The lower arc corresponds
to an input of 1.

00:06:51.850 --> 00:06:54.970
So you can actually
dispense with the index

00:06:54.970 --> 00:06:57.610
or with the bit that's in
front of the stroke there.

00:06:57.610 --> 00:07:02.530
So you can just make do with
labeling by the parity bits.

00:07:02.530 --> 00:07:03.860
So you'll get used to that.

00:07:03.860 --> 00:07:05.580
0 is the upward movement.

00:07:05.580 --> 00:07:08.630
And 1 is a downward movement.

00:07:08.630 --> 00:07:13.070
So if you're thinking
at the transmitter--

00:07:13.070 --> 00:07:15.070
by the way, I hope I've
made these changes well.

00:07:15.070 --> 00:07:17.650
I had an earlier
version of this slide,

00:07:17.650 --> 00:07:20.560
but I changed it to work for a
new set of parity bits, which

00:07:20.560 --> 00:07:23.440
meant I had to go in and change
every one of these transitions.

00:07:23.440 --> 00:07:26.080
So you might see the
odd bug here and there.

00:07:26.080 --> 00:07:28.030
But hopefully this is
correct and consistent

00:07:28.030 --> 00:07:31.180
with the state transition
diagram I showed you.

00:07:31.180 --> 00:07:33.040
So what we're saying
is now suppose you're

00:07:33.040 --> 00:07:35.950
starting off in the 0, 0 state.

00:07:35.950 --> 00:07:37.990
And you get the sequence
of message bits.

00:07:37.990 --> 00:07:40.880
So 0, 1, 1, 1 is your message.

00:07:40.880 --> 00:07:44.260
And then you bring it back to
the 0 state again by appending

00:07:44.260 --> 00:07:45.760
two 0's.

00:07:45.760 --> 00:07:49.720
What's the path that you
traverse through the trellis?

00:07:49.720 --> 00:07:52.750
Well, you're starting
off in the 0 state.

00:07:52.750 --> 00:07:56.140
Every time you have
a 0 in the message,

00:07:56.140 --> 00:07:57.520
you take the upper branch.

00:07:57.520 --> 00:08:00.460
Whenever you have a 1, you take
the lower branch of the two

00:08:00.460 --> 00:08:01.733
that are available to you.

00:08:01.733 --> 00:08:03.400
So you can see very
quickly how to steer

00:08:03.400 --> 00:08:07.480
through this trellis for any
particular message sequence.

00:08:07.480 --> 00:08:10.120
So this is the upper
one of the two here,

00:08:10.120 --> 00:08:13.390
and then the lower one of the
two here because it's a 1,

00:08:13.390 --> 00:08:16.420
then the lower one of the
two here because it's a 1,

00:08:16.420 --> 00:08:19.780
and the lower one of the two
here because it's a 1, and then

00:08:19.780 --> 00:08:23.140
the upper one because it's
a 0, and the upper one

00:08:23.140 --> 00:08:24.563
because it's a 0.

00:08:24.563 --> 00:08:26.230
So that's your path
through the trellis.

00:08:26.230 --> 00:08:27.790
It's told to you by
the message bits.

00:08:31.520 --> 00:08:33.710
You should also remember,
by the way, this diagram

00:08:33.710 --> 00:08:38.539
hides a little bit, because
I have just a box here

00:08:38.539 --> 00:08:44.450
for something that's
actually a pair of registers.

00:08:44.450 --> 00:08:50.210
So when I just show the box,
let's say, at this point,

00:08:50.210 --> 00:08:52.490
this actually has the 1
and the 0 sitting in it.

00:08:57.330 --> 00:09:00.290
So if you were just looking at
this box and what was in it,

00:09:00.290 --> 00:09:03.210
if I just gave you the
contents of that box,

00:09:03.210 --> 00:09:05.790
could you tell me what the
input was of the previous time?

00:09:05.790 --> 00:09:09.450
If I just told you that
the contents of that box

00:09:09.450 --> 00:09:11.820
are 1 and 0, can you
tell me what the input

00:09:11.820 --> 00:09:14.840
was at the previous time?

00:09:14.840 --> 00:09:15.655
Yes?

00:09:15.655 --> 00:09:17.030
It's just what
got fed in, right?

00:09:17.030 --> 00:09:18.980
It's just the one
that got fed in.

00:09:18.980 --> 00:09:21.680
So this diagram
is fine, but we've

00:09:21.680 --> 00:09:23.105
suppressed a little bit there.

00:09:23.105 --> 00:09:26.870
There are occasions, especially
on homework and quiz problems,

00:09:26.870 --> 00:09:32.090
where you're given the contents
of the shift registers.

00:09:32.090 --> 00:09:35.080
And you're asked to figure out
what happened at the last time

00:09:35.080 --> 00:09:37.123
step, what message bit came in.

00:09:37.123 --> 00:09:38.540
So really, don't
forget that there

00:09:38.540 --> 00:09:41.480
is a link between the two.

00:09:41.480 --> 00:09:43.830
OK, so the steering
is straightforward.

00:09:43.830 --> 00:09:46.760
Now, what's the code
word that's emitted?

00:09:46.760 --> 00:09:50.510
Well, it's the parity bits
that you encounter on the arcs.

00:09:50.510 --> 00:09:52.730
So on this upper
arc here, you've

00:09:52.730 --> 00:09:54.130
got a 0, 0 that's emitted.

00:09:54.130 --> 00:09:56.180
So that's what
you're going to emit.

00:09:56.180 --> 00:10:00.510
That's the part of the code word
generated by that message bit.

00:10:00.510 --> 00:10:02.960
And then on the lower
arc, you emit 1, 1.

00:10:02.960 --> 00:10:06.170
On the lower arc, you
emit 0, 1, lower arc,

00:10:06.170 --> 00:10:11.510
you emit 1, 0, and
0, 1, and then 1, 1.

00:10:11.510 --> 00:10:14.680
So that's the code word.

00:10:14.680 --> 00:10:16.630
So the set of all
possible code words

00:10:16.630 --> 00:10:18.880
that you can get with
this convolutional code

00:10:18.880 --> 00:10:20.620
corresponds to the
set of all paths you

00:10:20.620 --> 00:10:23.080
can take through the trellis.

00:10:23.080 --> 00:10:27.040
If you're starting
at 0, 0, 0, then it's

00:10:27.040 --> 00:10:31.930
the set of all paths
starting at 0, 0, 0.

00:10:31.930 --> 00:10:32.800
So let's see.

00:10:32.800 --> 00:10:39.610
Roughly speaking, can you tell
me, if I've got l stages--

00:10:39.610 --> 00:10:43.142
when I say stages,
I mean time, if you

00:10:43.142 --> 00:10:45.100
want to think of these
as happening on a clock.

00:10:45.100 --> 00:10:49.540
If I've got l stages here and
I'm starting off with the 0

00:10:49.540 --> 00:10:53.650
state there, for a large l,
roughly how many possible paths

00:10:53.650 --> 00:10:54.190
do I have?

00:11:01.560 --> 00:11:02.150
Any thoughts?

00:11:04.880 --> 00:11:05.880
2 to the l?

00:11:05.880 --> 00:11:06.870
Yeah.

00:11:06.870 --> 00:11:10.350
Because you see here, coming
out of a box here on each stage,

00:11:10.350 --> 00:11:12.300
you've got two choices.

00:11:12.300 --> 00:11:14.740
And you've got those two
choices for l stages.

00:11:14.740 --> 00:11:21.320
So you've got approximately
2 to the l possible paths.

00:11:21.320 --> 00:11:25.330
Now, I say approximately,
because well, in this case,

00:11:25.330 --> 00:11:25.830
it's fine.

00:11:25.830 --> 00:11:29.520
But now if you're a lot to start
from other starting states,

00:11:29.520 --> 00:11:31.560
then you will have to
take account of that.

00:11:31.560 --> 00:11:32.520
But it's of that order.

00:11:32.520 --> 00:11:33.982
It's exponential.

00:11:33.982 --> 00:11:35.940
The number of possible
paths that you can have,

00:11:35.940 --> 00:11:38.370
the number of code words is
exponential in the length

00:11:38.370 --> 00:11:41.648
of the trellis, right?

00:11:41.648 --> 00:11:43.440
OK, so that's a large
number of code words.

00:11:47.570 --> 00:11:52.520
Our focus, though, is going
to be on decoding today.

00:11:52.520 --> 00:11:56.420
What I did so far was just
review what we saw for coding.

00:11:56.420 --> 00:11:58.940
We're interested
in decoding now.

00:11:58.940 --> 00:12:04.610
So at the receiver, what you
have is a knowledge of what

00:12:04.610 --> 00:12:05.170
the code is.

00:12:05.170 --> 00:12:06.170
So you have the trellis.

00:12:06.170 --> 00:12:07.500
You know what the labels are.

00:12:07.500 --> 00:12:11.000
You know that things are going
to start in the zero state.

00:12:11.000 --> 00:12:14.637
And then you get
your received signal.

00:12:14.637 --> 00:12:16.470
Now, what I've shown
here is that, actually,

00:12:16.470 --> 00:12:20.300
your received signal is
not necessarily going to be

00:12:20.300 --> 00:12:22.280
0's and 1's.

00:12:22.280 --> 00:12:25.160
It's probably going to be
samples of some voltage, where

00:12:25.160 --> 00:12:26.270
you've got some waveform.

00:12:26.270 --> 00:12:27.050
You process it.

00:12:27.050 --> 00:12:28.670
And then you take a sample.

00:12:28.670 --> 00:12:30.680
And what you've got is a
sample of some voltage.

00:12:30.680 --> 00:12:33.320
So you're typically
looking at real numbers

00:12:33.320 --> 00:12:38.530
that you then have to decide
whether to call as a 0 or a 1.

00:12:38.530 --> 00:12:46.910
OK, so yeah, maybe this is 0,
0, maybe 0, 1; 0, 1, probably 1,

00:12:46.910 --> 00:12:53.390
0; 0, 1; 1, 0, yeah?

00:12:53.390 --> 00:12:56.690
So if you were forced to choose,
if you had a threshold of 0.5,

00:12:56.690 --> 00:12:59.690
for instance, and this was
the range, if nominally

00:12:59.690 --> 00:13:04.200
these were supposed
to be at 0 and 1,

00:13:04.200 --> 00:13:07.880
then you might actually
be willing to call

00:13:07.880 --> 00:13:09.090
this one way or another.

00:13:09.090 --> 00:13:12.410
So if I was to draw
this on the real axis

00:13:12.410 --> 00:13:16.910
thinking of a voltage, so
we've got 0 volts that we're

00:13:16.910 --> 00:13:20.900
expecting, 1 volt or
something proportional to 1

00:13:20.900 --> 00:13:22.073
volt that we're expecting.

00:13:22.073 --> 00:13:23.990
These are the two possible
values depending on

00:13:23.990 --> 00:13:26.660
whether a 0 is sent
or a 1 is sent.

00:13:26.660 --> 00:13:28.190
This is because
we've coded the bits

00:13:28.190 --> 00:13:31.400
at the transmitter for
physical transmission

00:13:31.400 --> 00:13:33.393
on a continuous time channel.

00:13:33.393 --> 00:13:35.810
And then at the receiving end,
we're doing some processing

00:13:35.810 --> 00:13:38.180
and extracting samples, right?

00:13:38.180 --> 00:13:40.190
But because of noise,
what might happen

00:13:40.190 --> 00:13:44.450
is that you get samples
anywhere around the 0

00:13:44.450 --> 00:13:48.170
or anywhere around
the 1, depending

00:13:48.170 --> 00:13:50.330
on the particular
transmission instance.

00:13:50.330 --> 00:13:52.670
It'll vary from one
instant to the next.

00:13:52.670 --> 00:13:56.160
And if the noise is really
bad, then of course,

00:13:56.160 --> 00:13:58.280
what started off as a
0 here with the noise

00:13:58.280 --> 00:14:00.020
added to it, by the
time you sample it,

00:14:00.020 --> 00:14:03.740
might fall in a region
where you call it a 1.

00:14:03.740 --> 00:14:05.390
So there is an
intermediate step.

00:14:05.390 --> 00:14:07.160
And very often, you
have access to that.

00:14:10.450 --> 00:14:16.060
And then you've got to figure
out how to do your decoding.

00:14:16.060 --> 00:14:20.283
All right, is this
the same slide?

00:14:20.283 --> 00:14:21.700
Or does it say
anything different?

00:14:21.700 --> 00:14:24.168
OK.

00:14:24.168 --> 00:14:25.460
So what are we going to do now?

00:14:25.460 --> 00:14:28.880
We're going to, of all
the paths available to us,

00:14:28.880 --> 00:14:32.690
we're going to try and
find the path along which

00:14:32.690 --> 00:14:36.890
the emitted parity bits
come closest, in some sense,

00:14:36.890 --> 00:14:40.830
to the sequence of samples here.

00:14:40.830 --> 00:14:43.190
That's, if you were
doing minimum distance,

00:14:43.190 --> 00:14:45.530
in some sense, that's
what you'd want to do.

00:14:45.530 --> 00:14:49.910
If you believed that
errors further away from 0

00:14:49.910 --> 00:14:53.180
are less likely than
errors close to 0,

00:14:53.180 --> 00:14:57.710
then you would want to have
a reconstructed set of parity

00:14:57.710 --> 00:14:59.480
bits along whatever
path you choose

00:14:59.480 --> 00:15:01.970
to come close to
the values there.

00:15:06.380 --> 00:15:08.480
Now, it turns out that
it's actually simpler

00:15:08.480 --> 00:15:12.710
initially to think of
first making a decision

00:15:12.710 --> 00:15:15.530
to call these 0's or
1's and then finding

00:15:15.530 --> 00:15:18.950
a path through this that
comes closest to the 0, 1

00:15:18.950 --> 00:15:21.890
sequence that approximates
the voltage samples

00:15:21.890 --> 00:15:23.655
that you've actually got.

00:15:23.655 --> 00:15:25.280
So we make a distinction
between what's

00:15:25.280 --> 00:15:38.450
called hard decision decoding
and soft decision decoding.

00:15:41.200 --> 00:15:45.770
So in soft decision decoding,
which we'll talk about later,

00:15:45.770 --> 00:15:47.262
you preserve those
voltage samples.

00:15:47.262 --> 00:15:48.470
And you don't mess with them.

00:15:48.470 --> 00:15:50.660
But in hard decision
decoding, at each stage,

00:15:50.660 --> 00:15:53.150
you just make a
decision, on each sample,

00:15:53.150 --> 00:15:56.270
decide to call it a 0 or a
1 and proceed from there.

00:15:56.270 --> 00:16:00.320
OK, so which do you think
is likely to get you

00:16:00.320 --> 00:16:02.540
better performance
if you're doing

00:16:02.540 --> 00:16:05.288
the optimal thing after that?

00:16:05.288 --> 00:16:06.260
AUDIENCE: Soft.

00:16:06.260 --> 00:16:06.630
PROFESSOR: The soft?

00:16:06.630 --> 00:16:07.190
Yeah.

00:16:07.190 --> 00:16:09.260
Because when you make the
decision at one stage,

00:16:09.260 --> 00:16:11.720
you're throwing away
some information.

00:16:11.720 --> 00:16:14.505
You're not taking account
of how these samples might

00:16:14.505 --> 00:16:15.380
relate to each other.

00:16:15.380 --> 00:16:18.648
You're treating that
sample in isolation.

00:16:18.648 --> 00:16:20.690
If you know that what
you're going to end up with

00:16:20.690 --> 00:16:24.170
is a code word that corresponds
to a path through here,

00:16:24.170 --> 00:16:25.730
then there is
additional information

00:16:25.730 --> 00:16:27.813
that actually couples the
different numbers you're

00:16:27.813 --> 00:16:29.120
getting across there.

00:16:29.120 --> 00:16:31.430
And so you have a
hope of doing better

00:16:31.430 --> 00:16:33.100
with soft decision decoding.

00:16:33.100 --> 00:16:36.480
So postpone the
decision until later.

00:16:36.480 --> 00:16:37.350
But you pay a cost.

00:16:37.350 --> 00:16:39.350
Or you could pay a cost
for that, because you've

00:16:39.350 --> 00:16:41.683
got to deal, for instance,
with the real numbers and all

00:16:41.683 --> 00:16:43.230
of that.

00:16:43.230 --> 00:16:47.400
So hard decision decoding
can simplify your processing.

00:16:47.400 --> 00:16:49.800
So what you'll say is, I'll
just make a choice here.

00:16:49.800 --> 00:16:53.810
So I'll call this 0, 0;
0, 1; 0, 1, and so on,

00:16:53.810 --> 00:16:58.820
and then look for a path
through the Trellis along which

00:16:58.820 --> 00:17:01.340
the emitted party
bits come closest

00:17:01.340 --> 00:17:07.280
to what I've approximated
that sequence of samples by.

00:17:07.280 --> 00:17:10.280
So we're talking about
having distance again.

00:17:10.280 --> 00:17:13.609
And minimum timing distance
is going to give us the most

00:17:13.609 --> 00:17:16.910
likely path, given that
you've already committed

00:17:16.910 --> 00:17:22.020
to interpreting the received
samples as 0's or 1's.

00:17:22.020 --> 00:17:23.750
So what you might
imagine is, OK, you've

00:17:23.750 --> 00:17:26.960
got this received sequence.

00:17:26.960 --> 00:17:31.067
You've got a tabulation
of all the possible paths

00:17:31.067 --> 00:17:32.900
through the trellis and
the parity bits that

00:17:32.900 --> 00:17:35.300
are emitted along those paths.

00:17:35.300 --> 00:17:37.940
Each path corresponds
to a different message.

00:17:37.940 --> 00:17:40.040
What you actually
have here-- let's see.

00:17:40.040 --> 00:17:43.640
We've got 12 bits here, because
in addition to the message,

00:17:43.640 --> 00:17:48.080
I'm appending a 0, 0 to each
one, which forces the trellis

00:17:48.080 --> 00:17:49.430
back down to the 0 state.

00:17:49.430 --> 00:17:52.310
So what I'm actually
doing here is,

00:17:52.310 --> 00:17:55.517
I actually have a message
that's this followed by two 0's.

00:17:55.517 --> 00:17:57.350
And so if you're trying
to connect these two

00:17:57.350 --> 00:18:00.050
columns with the trellis that
I had on the previous page,

00:18:00.050 --> 00:18:01.880
that's how you should
think about it.

00:18:01.880 --> 00:18:04.850
But with any particular message,
you navigate up and down

00:18:04.850 --> 00:18:06.380
on the trellis.

00:18:06.380 --> 00:18:09.710
This particular one, you
navigate up, up, down, up.

00:18:09.710 --> 00:18:12.380
And that's the sequence
that's generated.

00:18:12.380 --> 00:18:14.000
That's the code
word that you would

00:18:14.000 --> 00:18:16.340
expect if this was the message.

00:18:16.340 --> 00:18:19.230
What you'll do is you'll
search over all possibilities.

00:18:19.230 --> 00:18:21.410
At least that's one way
to do this, in principle,

00:18:21.410 --> 00:18:23.990
search over all possibilities
for the code word

00:18:23.990 --> 00:18:26.270
here that's closest
to what you received.

00:18:28.800 --> 00:18:30.855
The trouble is, that's
a lot of code words.

00:18:30.855 --> 00:18:31.980
That's a lot of code words.

00:18:31.980 --> 00:18:34.350
So this can quickly
get out of hand.

00:18:34.350 --> 00:18:36.180
If you've got long
sequences, which

00:18:36.180 --> 00:18:39.480
is exactly where you want
to do convolutional coding,

00:18:39.480 --> 00:18:43.568
you've got a very long table.

00:18:43.568 --> 00:18:45.360
So you really want to
find an efficient way

00:18:45.360 --> 00:18:46.650
to do this matching.

00:18:49.377 --> 00:18:50.960
I just wrote down
the Hamming distance

00:18:50.960 --> 00:18:58.160
that happens to hold for what
is the message that was actually

00:18:58.160 --> 00:19:02.240
sent, which also will be the
message that you will recover

00:19:02.240 --> 00:19:04.160
at the receiver if you
do the optimal thing

00:19:04.160 --> 00:19:06.360
and you don't get
fooled by the errors.

00:19:06.360 --> 00:19:09.020
So what I've got here as a
2 is the Hamming distance

00:19:09.020 --> 00:19:14.540
between the code word here
and the received message.

00:19:23.670 --> 00:19:26.630
So if that 2 was the smallest
one in that whole stack--

00:19:26.630 --> 00:19:29.343
I haven't filled them all out--

00:19:29.343 --> 00:19:31.010
then that's the one
that you would call.

00:19:34.080 --> 00:19:39.050
OK, so a much
cleverer way of doing

00:19:39.050 --> 00:19:41.000
this was invented
by the Viterbi,

00:19:41.000 --> 00:19:44.090
who did his bachelor's
degree here,

00:19:44.090 --> 00:19:45.320
then moved to the West Coast.

00:19:45.320 --> 00:19:49.530
He was very involved
in the JPL program.

00:19:49.530 --> 00:19:52.070
But he was also a
founder of, well,

00:19:52.070 --> 00:19:55.443
a succession of companies,
but most recently, Qualcomm.

00:19:55.443 --> 00:19:57.110
And he's a big friend
of the department.

00:19:57.110 --> 00:19:58.700
He's on our visiting committee.

00:19:58.700 --> 00:20:02.270
Or he has served time with
the visiting committee.

00:20:02.270 --> 00:20:06.990
So this is an algorithm that
he developed in the early days.

00:20:06.990 --> 00:20:08.440
And we're going
to talk about it.

00:20:12.500 --> 00:20:14.330
I think I'll put it
all up on the slide.

00:20:14.330 --> 00:20:16.220
And then let's talk.

00:20:16.220 --> 00:20:18.510
All right, there is a lot there.

00:20:18.510 --> 00:20:20.690
I don't want you to
struggle through that.

00:20:20.690 --> 00:20:24.092
Let's talk about it here.

00:20:24.092 --> 00:20:25.550
And when we're
done, I think what's

00:20:25.550 --> 00:20:26.592
up there will make sense.

00:20:26.592 --> 00:20:32.960
That's for you to refer
to from the slides later.

00:20:32.960 --> 00:20:34.933
And it's my little
checklist to know

00:20:34.933 --> 00:20:36.350
that I've spoken
about everything,

00:20:36.350 --> 00:20:41.060
but don't try and
navigate that just yet.

00:20:41.060 --> 00:20:43.730
So here is what Viterbi says.

00:20:43.730 --> 00:20:50.010
He says, we're starting off
from some initial state.

00:20:50.010 --> 00:20:52.062
This is the zero state.

00:20:52.062 --> 00:20:56.062
At an intermediate state,
intermediate time--

00:20:56.062 --> 00:20:57.270
sorry, I shouldn't say state.

00:20:57.270 --> 00:20:59.640
I meant stage or time.

00:20:59.640 --> 00:21:03.390
At an intermediate stage, we
have these four possibilities.

00:21:07.840 --> 00:21:10.495
What I'm going to do for a
given received sequence--

00:21:10.495 --> 00:21:12.370
and let me actually put
the received sequence

00:21:12.370 --> 00:21:14.495
I'm going to use
in this example.

00:21:14.495 --> 00:21:15.745
We've got a received sequence.

00:21:25.620 --> 00:21:29.790
Let's say it's 0, 0 on
the first stage, and then

00:21:29.790 --> 00:21:37.650
0, 1 on the second
stage, and 0, 1; 1, 0--

00:21:37.650 --> 00:21:39.060
AUDIENCE: [INAUDIBLE]

00:21:39.060 --> 00:21:41.010
PROFESSOR: Yeah?

00:21:41.010 --> 00:21:44.670
Did someone say something?

00:21:44.670 --> 00:21:45.328
No?

00:21:45.328 --> 00:21:46.120
I thought I heard--

00:21:46.120 --> 00:21:48.000
OK.

00:21:48.000 --> 00:21:50.790
We'll park the question for
now and check in again later.

00:21:53.810 --> 00:21:57.690
OK, here is the
received sequence.

00:21:57.690 --> 00:22:01.770
What we're trying to do is
find a path through the trellis

00:22:01.770 --> 00:22:03.420
where the emitted
bits come closest

00:22:03.420 --> 00:22:04.650
to this in Hamming distance.

00:22:09.240 --> 00:22:11.400
Here is what Viterbi
proposes to do.

00:22:11.400 --> 00:22:14.070
He says, from the
starting state,

00:22:14.070 --> 00:22:16.920
let's find the
optimum path to each

00:22:16.920 --> 00:22:19.990
of these states at
any particular time,

00:22:19.990 --> 00:22:21.810
let's say a time i here.

00:22:21.810 --> 00:22:25.050
Here is time i.

00:22:25.050 --> 00:22:28.200
Let's find the
optimum path to these

00:22:28.200 --> 00:22:29.830
with the associated
minimum cost.

00:22:29.830 --> 00:22:32.080
So let's assume
that I have that.

00:22:32.080 --> 00:22:34.270
So what I'm going to do
is, for each of these,

00:22:34.270 --> 00:22:36.090
I'm going to put in some number.

00:22:36.090 --> 00:22:37.560
This won't be
exactly the notation

00:22:37.560 --> 00:22:42.698
that we have on this slide,
but it's streamlined.

00:22:45.910 --> 00:22:50.005
These p's correspond to
what we call path metrics.

00:22:58.280 --> 00:23:00.430
And I should actually
have an index i here

00:23:00.430 --> 00:23:02.740
to tell you that I'm
doing this at time i,

00:23:02.740 --> 00:23:05.190
but I'll just leave that off.

00:23:05.190 --> 00:23:19.800
p sub 1 is cost along
optimal path to state one.

00:23:23.220 --> 00:23:25.170
OK, so assume that,
magically, you've

00:23:25.170 --> 00:23:28.230
computed the
optimal path to this

00:23:28.230 --> 00:23:29.620
starting from the initial time.

00:23:29.620 --> 00:23:31.710
So what that means is
maybe you've gone down

00:23:31.710 --> 00:23:33.120
to a particular stage here.

00:23:33.120 --> 00:23:34.512
You've gone down further.

00:23:34.512 --> 00:23:35.970
And then maybe
you've come up here.

00:23:35.970 --> 00:23:38.693
Maybe that's the optimum path.

00:23:38.693 --> 00:23:40.110
So what you're
going to keep track

00:23:40.110 --> 00:23:44.340
of is, for each of
these times, for each

00:23:44.340 --> 00:23:49.280
of these states, what's
the cost, the optimal cost?

00:23:49.280 --> 00:23:52.530
Or what's the cost along
an optimal path there?

00:23:52.530 --> 00:23:53.850
OK, now what do I mean by cost?

00:23:53.850 --> 00:23:56.700
I just mean Hamming
distance between what

00:23:56.700 --> 00:23:59.568
I received and the
parity bits emitted along

00:23:59.568 --> 00:24:00.610
the way up to that point.

00:24:05.370 --> 00:24:10.120
So Viterbi is going to keep
track of this for every stage

00:24:10.120 --> 00:24:12.380
as you step along and for
every one of these states.

00:24:16.250 --> 00:24:20.170
Now, let's take
this particular one.

00:24:20.170 --> 00:24:25.420
If I'm transitioning to
state one here, let's see.

00:24:25.420 --> 00:24:29.300
This emits a 0, 0 if I go from--

00:24:29.300 --> 00:24:31.525
let's go back to our trellis.

00:24:35.557 --> 00:24:36.890
I should draw this up, actually.

00:24:36.890 --> 00:24:44.490
But if I go along the
top, I am at 0, 0.

00:24:44.490 --> 00:24:46.720
What other state comes
into the top one?

00:24:50.000 --> 00:24:52.628
This comes in.

00:24:52.628 --> 00:24:54.120
And this emits 1, 1.

00:24:58.820 --> 00:25:01.540
So what's the cost I incurred
if I take the upper path?

00:25:04.360 --> 00:25:08.230
The cost is just the Hamming
distance between the 1, 0

00:25:08.230 --> 00:25:10.340
that I received and the
0, 0 that I have here.

00:25:10.340 --> 00:25:11.890
So there is a cost of 1.

00:25:11.890 --> 00:25:13.840
Let me, again, use
colors for costs here.

00:25:17.260 --> 00:25:19.300
What's the cost I
incur if I instead

00:25:19.300 --> 00:25:24.420
come to this point from
p2, again cost of 1?

00:25:31.690 --> 00:25:33.070
So this is the generic picture.

00:25:33.070 --> 00:25:35.070
What you're going to do
is, you're having this--

00:25:35.070 --> 00:25:36.580
you have this at any stage.

00:25:36.580 --> 00:25:39.830
You compute the branch
costs and continues.

00:25:39.830 --> 00:25:52.870
And now suppose p1 was equal
to 3 and p2 was equal to 4,

00:25:52.870 --> 00:25:55.870
and you wanted to figure out
what's the shortest way, what's

00:25:55.870 --> 00:25:59.500
the minimum-cost way to get
from the origin to this point,

00:25:59.500 --> 00:26:01.150
to p1 at the next time instant?

00:26:04.510 --> 00:26:05.740
What's the minimum cost?

00:26:05.740 --> 00:26:07.494
And what's the root?

00:26:07.494 --> 00:26:11.470
AUDIENCE: [INAUDIBLE]

00:26:11.470 --> 00:26:13.630
PROFESSOR: If you
came from here,

00:26:13.630 --> 00:26:17.080
you've incurred a cost
of 3 up to this point.

00:26:17.080 --> 00:26:19.270
And you're adding an
additional cost of 1.

00:26:19.270 --> 00:26:22.060
You'll end up with a
cost of 4 to get to here.

00:26:22.060 --> 00:26:25.360
If you get to hear
from p2, well, you've

00:26:25.360 --> 00:26:29.030
incurred a cost of, let's
say, 4 up to this point.

00:26:29.030 --> 00:26:31.180
And now you're going to
incur an additional cost

00:26:31.180 --> 00:26:32.350
to bring it to 5.

00:26:32.350 --> 00:26:36.040
So your best route
to p1 at this time

00:26:36.040 --> 00:26:38.680
is to come from p1 at
this time using this arc.

00:26:41.240 --> 00:26:43.610
So if you've built it up
at a particular stage,

00:26:43.610 --> 00:26:45.665
then it's actually
very straightforward

00:26:45.665 --> 00:26:47.790
to figure out what you
should do at the next stage.

00:26:47.790 --> 00:26:52.151
So let me now start putting
some time indices on this.

00:26:52.151 --> 00:27:01.631
This would be p1 at
time i is equal to 3.

00:27:01.631 --> 00:27:08.610
p1 at time i plus
1 is equal to 4.

00:27:08.610 --> 00:27:10.020
This is p2 at time i.

00:27:20.020 --> 00:27:22.030
So you can actually
forget about this arrow,

00:27:22.030 --> 00:27:24.322
because there is no way you're
going to use that arrow.

00:27:24.322 --> 00:27:26.440
Whenever you come to
this stage at this time,

00:27:26.440 --> 00:27:30.558
you're going to come
via the upper branch.

00:27:30.558 --> 00:27:32.350
So at every stage,
you're going to do this.

00:27:32.350 --> 00:27:34.503
And it's a very
simple calculation.

00:27:34.503 --> 00:27:36.670
So now we've got slightly
more elaborate notation up

00:27:36.670 --> 00:27:38.795
on the board, but I hope
you have the general idea.

00:27:43.380 --> 00:27:45.890
This is an instance,
by the way, and a way

00:27:45.890 --> 00:27:49.310
of thinking about such
problems that's referred

00:27:49.310 --> 00:27:51.168
to as dynamic programming.

00:27:59.780 --> 00:28:02.000
It works for these sorts
of rooting problems.

00:28:02.000 --> 00:28:04.850
We're rooting ourselves
along a trellis where

00:28:04.850 --> 00:28:07.790
the total cost of
taking a path is the sum

00:28:07.790 --> 00:28:10.010
of the costs at every stage.

00:28:10.010 --> 00:28:13.250
So the total Hamming
distance between the bits

00:28:13.250 --> 00:28:16.310
you emit along the way and
the bits that you've received

00:28:16.310 --> 00:28:19.550
is made up of the Hamming
distance between the branch

00:28:19.550 --> 00:28:21.590
here and the piece
you've received here

00:28:21.590 --> 00:28:24.920
plus the Hamming distance on the
branch here plus the piece you

00:28:24.920 --> 00:28:27.110
between the branch
here and the branch--

00:28:27.110 --> 00:28:29.850
sorry, the received segment
over there, and so on.

00:28:29.850 --> 00:28:31.520
So the total Hamming
distance is made up

00:28:31.520 --> 00:28:34.190
of the sum of the Hamming
distances along the way.

00:28:34.190 --> 00:28:38.510
In all such situations where
you've got a total cost that's

00:28:38.510 --> 00:28:41.210
additive over the
path and you've

00:28:41.210 --> 00:28:43.310
got to do an optimization,
dynamic programming

00:28:43.310 --> 00:28:45.840
is something you can think of.

00:28:45.840 --> 00:28:49.100
And the idea we've used
here is actually one

00:28:49.100 --> 00:28:51.770
that you might
come at naturally.

00:28:51.770 --> 00:28:55.190
If you found the best way from
here to the Student Center,

00:28:55.190 --> 00:28:59.240
and it happens to
go through Lobby 7,

00:28:59.240 --> 00:29:02.443
what's your best way
from here to Lobby 7?

00:29:02.443 --> 00:29:04.610
Presumably, it's going to
be the section of the path

00:29:04.610 --> 00:29:06.830
that you would take to
the Student Center that

00:29:06.830 --> 00:29:09.590
passes through Lobby 7,
because if you had a better way

00:29:09.590 --> 00:29:10.970
to get to Lobby
7, you would have

00:29:10.970 --> 00:29:14.920
used it to get to the
Student Center via Lobby 7.

00:29:14.920 --> 00:29:16.490
It's just that idea.

00:29:16.490 --> 00:29:21.140
So on an optimum path where
the costs are additive,

00:29:21.140 --> 00:29:24.710
it must be the case
that the optimum path

00:29:24.710 --> 00:29:26.957
to an intermediate
point is exactly

00:29:26.957 --> 00:29:28.790
the section of the
optimum path to the point

00:29:28.790 --> 00:29:34.560
that you're looking
at, a simple idea.

00:29:34.560 --> 00:29:38.578
OK, so let's go back
to the more formal way

00:29:38.578 --> 00:29:39.995
it's written up
here on the slide.

00:29:46.150 --> 00:29:48.100
So we talk about
the branch metric.

00:29:48.100 --> 00:29:51.670
That's just the Hamming
distance that we computed here

00:29:51.670 --> 00:29:52.840
for the branch.

00:29:52.840 --> 00:29:56.860
It's the difference
between what we received

00:29:56.860 --> 00:30:02.740
and what would be transmitted
if you moved along that arc.

00:30:02.740 --> 00:30:04.030
So that's the branch metric.

00:30:04.030 --> 00:30:06.850
It's the piece
contributed by the branch.

00:30:06.850 --> 00:30:09.100
This is the notation we've used.

00:30:09.100 --> 00:30:12.550
We've already talked about this,
that you could either do a hard

00:30:12.550 --> 00:30:15.280
decision kind of rule where
you've already set these

00:30:15.280 --> 00:30:16.090
to 1's and 0's.

00:30:16.090 --> 00:30:19.150
Or you could stick with
the original samples.

00:30:19.150 --> 00:30:21.520
If you've already converted
them to 1's and 0's, there

00:30:21.520 --> 00:30:25.380
is a natural notion of distance,
which is the Hamming distance.

00:30:25.380 --> 00:30:26.860
And there is a
probabilistic reason

00:30:26.860 --> 00:30:28.670
why you would want to do that.

00:30:28.670 --> 00:30:30.550
So we're sticking to
the Hamming distance

00:30:30.550 --> 00:30:34.660
setting right now, so
hard decision decoding.

00:30:34.660 --> 00:30:38.080
And the path metric, this
is a more elaborate notation

00:30:38.080 --> 00:30:39.770
than what I have here.

00:30:39.770 --> 00:30:43.390
So instead of a subscript
to denote the state,

00:30:43.390 --> 00:30:47.690
this has got the state index
here, and the time index here,

00:30:47.690 --> 00:30:50.980
and pm for path metric
instead of just p,

00:30:50.980 --> 00:30:52.550
but it's the same thing.

00:30:52.550 --> 00:30:55.220
So for each state
and at each stage,

00:30:55.220 --> 00:31:01.150
so for each of the four states
and for each of the stages,

00:31:01.150 --> 00:31:03.230
you're going to compute this.

00:31:03.230 --> 00:31:06.300
And you can the path
metric up to time

00:31:06.300 --> 00:31:08.110
i is the smallest
sum of the branch

00:31:08.110 --> 00:31:10.270
metrics over all
the sequences that

00:31:10.270 --> 00:31:12.220
will get you to that place.

00:31:12.220 --> 00:31:14.600
And if you assume you
have that at any stage,

00:31:14.600 --> 00:31:17.440
then the computation that
takes you to the next stage

00:31:17.440 --> 00:31:18.130
is an easy one.

00:31:22.920 --> 00:31:24.830
I think I've said all this.

00:31:24.830 --> 00:31:26.220
You can come back to it later.

00:31:31.730 --> 00:31:33.690
So let's actually just
step through this.

00:31:36.790 --> 00:31:39.005
So we're at some
intermediate stage.

00:31:39.005 --> 00:31:41.130
We're just doing the same
thing I had on the board.

00:31:41.130 --> 00:31:43.140
I'm doing it again
in pictures here

00:31:43.140 --> 00:31:45.750
so you get to think
about it one more time.

00:31:45.750 --> 00:31:50.250
Suppose we've received 0, 0.

00:31:50.250 --> 00:31:54.660
We first label each of the arcs
here by the Hamming distance

00:31:54.660 --> 00:31:58.080
between the bits we'd emit
along the arc and the bits

00:31:58.080 --> 00:32:01.260
we've actually received,
so Hamming distant 0 here

00:32:01.260 --> 00:32:04.390
between what we would
emit and what we received,

00:32:04.390 --> 00:32:07.800
Hamming distance 2 here on
this arc, Hamming distance

00:32:07.800 --> 00:32:09.520
2 on this arc, and so on.

00:32:09.520 --> 00:32:13.170
So the red numbers here
are below the top two

00:32:13.170 --> 00:32:14.730
just are the costs on the arcs.

00:32:25.170 --> 00:32:27.400
Actually, I don't like the
last line of that slide.

00:32:27.400 --> 00:32:29.070
So you may want to strike that.

00:32:29.070 --> 00:32:31.950
We're not going to really
be talking about the most

00:32:31.950 --> 00:32:33.000
likely branch metric.

00:32:33.000 --> 00:32:34.875
We're only going to make
decisions once we're

00:32:34.875 --> 00:32:36.220
done with the whole path.

00:32:41.290 --> 00:32:45.250
So we assume at some stage,
that we have the path metrics

00:32:45.250 --> 00:32:48.220
up to that point.

00:32:48.220 --> 00:32:50.860
And then we do the computation
that I just talked about.

00:33:05.538 --> 00:33:06.080
So let's see.

00:33:06.080 --> 00:33:10.157
In this particular case, what
would be the path metric value

00:33:10.157 --> 00:33:10.865
in this position?

00:33:15.365 --> 00:33:16.880
It's the same thing
we did already,

00:33:16.880 --> 00:33:19.470
but just another
chance to look at it.

00:33:19.470 --> 00:33:23.840
What would be the value
of the path metric there?

00:33:23.840 --> 00:33:26.130
3?

00:33:26.130 --> 00:33:29.400
Because you can either
do 3 plus 1 on that arc.

00:33:29.400 --> 00:33:33.330
Or you can do 2 plus 1
on this-- sorry, 3 plus 1

00:33:33.330 --> 00:33:36.180
on this arc for a
cost of 4 or 2 plus 1

00:33:36.180 --> 00:33:38.640
on this arc for a cost of 3.

00:33:38.640 --> 00:33:39.870
So it should be a 3 there.

00:33:39.870 --> 00:33:41.537
And this is the arc
that you would pick.

00:33:45.790 --> 00:33:49.780
And similarly, you can
do it for all of them.

00:33:49.780 --> 00:33:52.990
So once you have one stage,
you can fill out the next stage

00:33:52.990 --> 00:33:56.055
completely and then keep
track of the arcs that

00:33:56.055 --> 00:33:56.680
lead you there.

00:34:03.833 --> 00:34:06.000
And at some point, you'll--
at each stage, actually,

00:34:06.000 --> 00:34:08.949
you can prune away things that
you're not going to be using.

00:34:08.949 --> 00:34:11.070
So you're never going
to use that edge.

00:34:11.070 --> 00:34:13.080
So you don't have to
worry about it anymore.

00:34:13.080 --> 00:34:15.060
You're never going
to use this edge.

00:34:15.060 --> 00:34:16.889
There are also stages
where you might

00:34:16.889 --> 00:34:19.139
have two different ways
of getting to a box

00:34:19.139 --> 00:34:20.656
and incurring the same cost.

00:34:20.656 --> 00:34:22.739
And then it doesn't matter
which of them you pick.

00:34:22.739 --> 00:34:24.120
You can pick one or the other.

00:34:24.120 --> 00:34:26.850
In terms of the overall cost,
it's not going to matter.

00:34:30.674 --> 00:34:34.546
AUDIENCE: [INAUDIBLE]

00:34:38.487 --> 00:34:40.070
PROFESSOR: Yeah, so
what you're saying

00:34:40.070 --> 00:34:43.510
is that, if there isn't
a unique way back,

00:34:43.510 --> 00:34:44.510
then you're not certain.

00:34:44.510 --> 00:34:46.552
Well, you're never certain
here in this business.

00:34:46.552 --> 00:34:48.060
You're just doing
your best guess.

00:34:48.060 --> 00:34:50.929
So what you would do when you
commit to one particular choice

00:34:50.929 --> 00:34:53.485
when there are two equally
likely costs is you're saying,

00:34:53.485 --> 00:34:54.860
the probability
of error is going

00:34:54.860 --> 00:34:56.402
to be the same with
this choice as it

00:34:56.402 --> 00:34:57.830
will be with the other choice.

00:34:57.830 --> 00:35:01.010
And in the end, that's what
we have for the metric.

00:35:01.010 --> 00:35:03.073
It is unsatisfying, perhaps.

00:35:03.073 --> 00:35:04.490
Now, there are
schemes where you'd

00:35:04.490 --> 00:35:06.865
keep a list of the possibilities
and try and do something

00:35:06.865 --> 00:35:09.790
with that, because maybe there
is some higher level thing that

00:35:09.790 --> 00:35:13.370
would help you disambiguate
between possibilities,

00:35:13.370 --> 00:35:16.160
but that would complicate
the processing.

00:35:16.160 --> 00:35:19.003
But as far as this
goes, you make a choice.

00:35:19.003 --> 00:35:19.670
And you move on.

00:35:26.840 --> 00:35:28.430
So you can imagine
actually working

00:35:28.430 --> 00:35:30.380
through this whole thing.

00:35:36.027 --> 00:35:38.110
If you knew you were
starting from the zero state,

00:35:38.110 --> 00:35:40.260
you'd start off with
a zero cost there.

00:35:40.260 --> 00:35:42.210
So you're at
infinity here, which

00:35:42.210 --> 00:35:46.290
is going to force all the
optimal paths to come from 0.

00:35:46.290 --> 00:35:49.360
And then you'll
continue from there.

00:35:49.360 --> 00:35:57.840
So I just wanted to show you a
few things that come with this.

00:36:04.150 --> 00:36:13.280
Actually, I might have shown
you everything I want on that.

00:36:13.280 --> 00:36:17.460
So let's just go back to
the soft decision decoding.

00:36:17.460 --> 00:36:20.730
So how might things
differ if you go back

00:36:20.730 --> 00:36:22.260
to soft decision decoding?

00:36:22.260 --> 00:36:23.460
So let me find that slide.

00:36:33.140 --> 00:36:35.800
The Viterbi algorithm
doesn't care

00:36:35.800 --> 00:36:37.630
how you come at these costs.

00:36:37.630 --> 00:36:39.913
The Viterbi algorithm is
just dynamic programming

00:36:39.913 --> 00:36:40.580
on this trellis.

00:36:40.580 --> 00:36:42.550
It finds you the
minimum-cost path.

00:36:42.550 --> 00:36:44.320
It's up to you how
you decide what

00:36:44.320 --> 00:36:47.170
cost to attribute to an edge.

00:36:47.170 --> 00:36:49.600
So the question is, are
there other costs that you

00:36:49.600 --> 00:36:51.100
might have come up with?

00:36:51.100 --> 00:36:53.650
Well, if the received sequence
has been translated already

00:36:53.650 --> 00:36:58.270
to 0's and 1's, then Hamming
distance is the natural thing.

00:36:58.270 --> 00:37:01.240
But if you're keeping
particular numbers there,

00:37:01.240 --> 00:37:04.820
then it turns out that you might
want to do things differently.

00:37:04.820 --> 00:37:15.320
So suppose at a particular
stage, what you got was not--

00:37:15.320 --> 00:37:15.920
let's see.

00:37:15.920 --> 00:37:17.680
Did I put numbers up there?

00:37:17.680 --> 00:37:27.360
Suppose it wasn't 0 and 1, but
it was some particular numbers,

00:37:27.360 --> 00:37:33.870
let's say, 0.3 and 0.7.

00:37:33.870 --> 00:37:38.190
And you had actually
translated them to a 0 and a 1

00:37:38.190 --> 00:37:41.700
in your hard decision decoding.

00:37:41.700 --> 00:37:43.530
If you decide not to
do that, but to stick

00:37:43.530 --> 00:37:44.970
with these numbers,
then what you

00:37:44.970 --> 00:37:48.420
have is the task for
any particular edge

00:37:48.420 --> 00:37:52.140
that you're traveling
on of finding

00:37:52.140 --> 00:37:54.300
the distance between
the parity bits

00:37:54.300 --> 00:37:58.800
you would emit on that edge and
the samples that you have here.

00:37:58.800 --> 00:38:02.910
It turns out that a very widely
used cost for soft decision

00:38:02.910 --> 00:38:06.250
decoding is the sum of
squared differences.

00:38:06.250 --> 00:38:09.900
So what you would
have is 1 minus 0.3

00:38:09.900 --> 00:38:15.390
squared plus 1
minus 0.7 squared.

00:38:18.540 --> 00:38:21.060
So it would be the
first bit that you

00:38:21.060 --> 00:38:23.610
emit on this arc
minus the first sample

00:38:23.610 --> 00:38:29.423
that you got squared error
plus the second sample,

00:38:29.423 --> 00:38:30.840
the second bit
that you would emit

00:38:30.840 --> 00:38:34.590
on this arc minus the second
sample, whole thing squared.

00:38:34.590 --> 00:38:39.450
If there was another arc
that was a 1 and 0 arc,

00:38:39.450 --> 00:38:43.500
then what you would
computers 1 minus 0.3

00:38:43.500 --> 00:38:51.630
squared plus 0
minus 0.7 squared.

00:38:51.630 --> 00:38:54.300
So it's just a different way
of coming up with the cost.

00:38:54.300 --> 00:38:56.760
The rest of the Viterbi
algorithm is exactly the same.

00:38:56.760 --> 00:39:00.880
the navigating through the
trellis is exactly the same.

00:39:00.880 --> 00:39:05.610
It turns out that there
is a logic and a reason

00:39:05.610 --> 00:39:11.670
behind this particular
metric for situations where

00:39:11.670 --> 00:39:16.850
your voltage samples
are distributed

00:39:16.850 --> 00:39:22.930
in the familiar
bell-shaped fashion here,

00:39:22.930 --> 00:39:24.542
what's called a
Gaussian distribution.

00:39:24.542 --> 00:39:26.000
We'll talk about
it more next time.

00:39:33.710 --> 00:39:38.830
So what we're saying is
that if you send a 1,

00:39:38.830 --> 00:39:41.320
you get a spread
of possible values.

00:39:41.320 --> 00:39:43.360
The probability of
your values falling

00:39:43.360 --> 00:39:47.230
in some particular range here
can be computed by the area

00:39:47.230 --> 00:39:48.920
under this particular curve.

00:39:48.920 --> 00:39:53.000
It's got an
analytical expression.

00:39:53.000 --> 00:39:54.400
So this is the most likely spot.

00:39:54.400 --> 00:39:55.900
But there is certainly
probabilities

00:39:55.900 --> 00:39:58.180
of falling in any
particular interval here.

00:39:58.180 --> 00:40:01.580
Well, what does the Gaussian
distribution look like?

00:40:01.580 --> 00:40:03.960
We'll talk more about it.

00:40:03.960 --> 00:40:06.920
the essential part of
it is e to the minus--

00:40:06.920 --> 00:40:07.420
let's see.

00:40:07.420 --> 00:40:10.060
Let me put some labels here.

00:40:10.060 --> 00:40:11.260
This is where it's centered.

00:40:11.260 --> 00:40:13.120
Let me call it mu.

00:40:13.120 --> 00:40:17.840
And let's say x is the
value along the axis.

00:40:17.840 --> 00:40:21.580
So we'll have e
to the x minus mu

00:40:21.580 --> 00:40:27.530
all squared divided by
some normalizing parameter.

00:40:27.530 --> 00:40:30.610
Well actually,
let's just call it

00:40:30.610 --> 00:40:36.780
capital N. Think of capital
N as a noise variance.

00:40:36.780 --> 00:40:38.820
Actually, let me
just call it N sub 0

00:40:38.820 --> 00:40:42.340
so you don't think
it's a counting number.

00:40:42.340 --> 00:40:45.060
Think of it as a noise variance.

00:40:45.060 --> 00:40:50.000
So the larger that
N is, would you

00:40:50.000 --> 00:40:52.020
spread out more or less here?

00:40:55.165 --> 00:40:57.290
Well, just from the fact
that I call it a variance,

00:40:57.290 --> 00:40:59.167
maybe you would guess
that, if N is larger,

00:40:59.167 --> 00:41:00.500
you're going to spread out more.

00:41:03.080 --> 00:41:06.710
Well, in this kind of setting,
when you take log likelihoods--

00:41:06.710 --> 00:41:09.080
you've seen that computation
in the chapters--

00:41:09.080 --> 00:41:11.300
what ends up appearing
in your cost criterion

00:41:11.300 --> 00:41:13.910
is x minus mu squared.

00:41:13.910 --> 00:41:16.010
So it's the squared
difference from the mean

00:41:16.010 --> 00:41:17.830
that you want to be looking at.

00:41:17.830 --> 00:41:20.942
And that's exactly why,
in that kind of setting,

00:41:20.942 --> 00:41:23.150
this is what you end up
choosing as your cost metric.

00:41:27.860 --> 00:41:37.013
But once you're done
computing those metrics,

00:41:37.013 --> 00:41:38.930
the rest of the Viterbi
algorithm is the same.

00:41:42.220 --> 00:41:47.990
So once you have the
convolutional coding in hand,

00:41:47.990 --> 00:41:50.750
you know how to
decode, you can start

00:41:50.750 --> 00:41:54.920
to do some comparisons of how
these different codes perform.

00:41:54.920 --> 00:41:57.920
There is an extensive
discussion in the chapter.

00:41:57.920 --> 00:42:01.240
Let me just give you
some highlights here.

00:42:01.240 --> 00:42:03.080
OK, so what are
we plotting here?

00:42:05.660 --> 00:42:10.430
What we're saying is we send
a whole bunch of message bits

00:42:10.430 --> 00:42:11.690
through the channel.

00:42:11.690 --> 00:42:14.210
And then we decode
at the other end.

00:42:14.210 --> 00:42:16.680
And what we're
talking about is--

00:42:16.680 --> 00:42:17.180
let's see.

00:42:17.180 --> 00:42:18.830
Here is the binary
symmetric channel.

00:42:18.830 --> 00:42:20.840
Here is the error
probability on the channel.

00:42:20.840 --> 00:42:24.100
You can see to well what
this is, but it's the--

00:42:24.100 --> 00:42:26.500
why is that chopped off?

00:42:26.500 --> 00:42:30.850
It's the probability of
error overall end to end,

00:42:30.850 --> 00:42:32.350
not of the channel,
but after you've

00:42:32.350 --> 00:42:35.570
done your coding and decoding.

00:42:35.570 --> 00:42:36.070
Let's see.

00:42:36.070 --> 00:42:37.750
Do we recognize
any of these codes?

00:42:37.750 --> 00:42:42.220
Here is the uncoded case
where basically you're

00:42:42.220 --> 00:42:46.750
exposing the stream directly
to the error on the binary

00:42:46.750 --> 00:42:49.330
symmetric channel.

00:42:49.330 --> 00:42:51.280
We expect higher
errors when we have

00:42:51.280 --> 00:42:55.120
higher probabilities of
flipping a bit on the channel.

00:42:55.120 --> 00:42:57.520
So this is the uncoded case.

00:42:57.520 --> 00:42:59.630
What does the Hamming code do?

00:42:59.630 --> 00:43:04.270
That's a Hamming code
probability, 0.74.

00:43:04.270 --> 00:43:08.080
So the Hamming code
performance, you can see here

00:43:08.080 --> 00:43:10.150
end to end what it looks like.

00:43:10.150 --> 00:43:11.650
What's the rate
that goes with that?

00:43:15.588 --> 00:43:17.130
What's the rate of
that Hamming code?

00:43:20.370 --> 00:43:22.380
4 over 7, right?

00:43:22.380 --> 00:43:28.370
Because n is the number
of bits in the message--

00:43:28.370 --> 00:43:29.370
sorry, in the code word.

00:43:29.370 --> 00:43:33.450
And 4 is the number of bits
in the message, so 4 over 7,

00:43:33.450 --> 00:43:36.240
something over 1/2.

00:43:36.240 --> 00:43:36.780
Let's see.

00:43:36.780 --> 00:43:40.080
Do we know what
that code might be?

00:43:42.980 --> 00:43:45.260
Any codes you know about
that take 4 message bits

00:43:45.260 --> 00:43:49.400
and pad them to
8 code word bits?

00:43:52.090 --> 00:43:53.705
You've seen at
least one such code.

00:43:53.705 --> 00:43:54.580
AUDIENCE: [INAUDIBLE]

00:43:54.580 --> 00:43:54.850
PROFESSOR: Sorry?

00:43:54.850 --> 00:43:56.200
AUDIENCE: Rectangular parity?

00:43:56.200 --> 00:43:58.320
PROFESSOR: Rectangular
parity, right?

00:43:58.320 --> 00:44:00.070
If you didn't have
that corner parity bit,

00:44:00.070 --> 00:44:01.960
but you just did the
rows and columns,

00:44:01.960 --> 00:44:05.720
then you'd arrange 4
bits in a 2 by 2 pattern

00:44:05.720 --> 00:44:07.448
and then have 4 parity bits.

00:44:07.448 --> 00:44:08.740
So that's a rectangular parity.

00:44:08.740 --> 00:44:11.710
That's rate 1/2.

00:44:11.710 --> 00:44:14.650
What this denotes is
a convolutional code.

00:44:14.650 --> 00:44:17.320
It's actually the
code we've been--

00:44:17.320 --> 00:44:19.820
sorry, no, this one is the
code we've been looking at.

00:44:19.820 --> 00:44:23.980
So let me explain to you
what that notation means when

00:44:23.980 --> 00:44:25.225
you're reading the chapter.

00:44:31.530 --> 00:44:34.620
This code is represented as--

00:44:34.620 --> 00:44:38.130
the one we've been talking
about as represented as this.

00:44:38.130 --> 00:44:42.030
So what this is is
the constraint length.

00:44:42.030 --> 00:44:44.220
And what this is
is just to tell me

00:44:44.220 --> 00:44:49.500
that the generator bits I
used for my party generation

00:44:49.500 --> 00:44:52.830
correspond to the binary
representation of 7

00:44:52.830 --> 00:44:56.250
and the binary
representation of 5.

00:44:56.250 --> 00:44:59.190
So remember that for
my first parody bit,

00:44:59.190 --> 00:45:03.630
I chose xn plus xn
minus 1 plus xn minus 2.

00:45:03.630 --> 00:45:05.190
I picked all three of them.

00:45:05.190 --> 00:45:09.060
For my second parity bit,
I took xn plus xn minus 2.

00:45:09.060 --> 00:45:10.470
I skipped the middle one.

00:45:10.470 --> 00:45:13.830
So the notation that's used
to denote a convolutional code

00:45:13.830 --> 00:45:20.480
with these two generators is,
just for compactness, the 7,

00:45:20.480 --> 00:45:22.870
5 there.

00:45:22.870 --> 00:45:23.370
Let's see.

00:45:23.370 --> 00:45:26.040
Is this redundant,
the k, the value of k?

00:45:26.040 --> 00:45:30.300
Could you have figured out
what the constraint length is?

00:45:30.300 --> 00:45:31.120
AUDIENCE: Yeah.

00:45:31.120 --> 00:45:31.787
PROFESSOR: Yeah.

00:45:31.787 --> 00:45:35.290
It's already staring at you here
what the constraints length.

00:45:35.290 --> 00:45:36.780
So this is a little redundant.

00:45:36.780 --> 00:45:38.490
It's just that it's
a convenient way

00:45:38.490 --> 00:45:42.150
to distinguish a convolutional
code from a Hamming code.

00:45:46.333 --> 00:45:48.750
Now, we have to be a little
careful comparing these codes,

00:45:48.750 --> 00:45:51.000
because the rates are
all a little different.

00:45:51.000 --> 00:45:53.520
Here the rate is 1/2.

00:45:53.520 --> 00:45:55.860
What's the rate for
this convolution

00:45:55.860 --> 00:46:01.763
for the two convolution
codes here, the 3, 7, 6

00:46:01.763 --> 00:46:04.040
and the 3, 7, 5?

00:46:04.040 --> 00:46:06.040
AUDIENCE: [INAUDIBLE]

00:46:07.040 --> 00:46:08.147
PROFESSOR: Sorry, what's--

00:46:08.147 --> 00:46:09.230
AUDIENCE: 1/2 [INAUDIBLE].

00:46:09.230 --> 00:46:10.750
PROFESSOR: 1/2, right?

00:46:10.750 --> 00:46:17.360
So the rate is 1 over
the number of parity bits

00:46:17.360 --> 00:46:18.610
you're generating per message.

00:46:23.300 --> 00:46:27.380
One message bit, r parity bits,
therefore, a rate of 1 over r.

00:46:27.380 --> 00:46:30.140
So these are rate one-off codes,
just like the rectangular case.

00:46:34.100 --> 00:46:37.070
This is constraint length 4.

00:46:37.070 --> 00:46:42.470
And you can actually write
out what that would be there.

00:46:42.470 --> 00:46:45.350
How big is the trellis for
the constraint length 4 case?

00:46:47.940 --> 00:46:48.700
How many stages?

00:46:53.308 --> 00:46:54.350
This last one down there?

00:46:58.260 --> 00:46:58.780
8, right?

00:46:58.780 --> 00:47:03.130
Constraint length 4, that means
k equals 4, 2 to the k minus 1,

00:47:03.130 --> 00:47:04.080
so 2 cubed states.

00:47:04.080 --> 00:47:07.020
So there is 8 states
that we're talking about.

00:47:07.020 --> 00:47:11.340
The Cassini convolution code
that I showed you last time

00:47:11.340 --> 00:47:14.370
had a constraint length of 15.

00:47:14.370 --> 00:47:18.170
So how many states
there on the trellis?

00:47:18.170 --> 00:47:22.740
2 to the 14, that's
a lot of states.

00:47:22.740 --> 00:47:25.120
So that's a lot of
computation there happening.

00:47:25.120 --> 00:47:26.800
And actually, there
is no hope of that

00:47:26.800 --> 00:47:30.010
having been done if it wasn't
for the Viterbi algorithm.

00:47:30.010 --> 00:47:33.340
All right, we'll talk more about
comparison between these codes

00:47:33.340 --> 00:47:35.230
next time.

00:47:35.230 --> 00:47:37.600
Sorry, I should do
one more thing here.

00:47:37.600 --> 00:47:40.015
I did talk last time about
this notion of free distance.

00:47:43.800 --> 00:47:48.090
Let's just stare
at this a second.

00:47:48.090 --> 00:47:51.750
We said the free distance was
the weight of the smallest

00:47:51.750 --> 00:47:54.510
non-zero codeword.

00:47:54.510 --> 00:47:56.940
And it gave you a handle on
the performance of the code.

00:47:56.940 --> 00:48:00.810
It was the Hamming distance
for the set of code words

00:48:00.810 --> 00:48:04.450
you could generate between
0, 0 here and 0, 0 there.

00:48:04.450 --> 00:48:10.940
Can you see by inspection
here what might be a candidate

00:48:10.940 --> 00:48:13.768
free distance here?

00:48:13.768 --> 00:48:15.560
I think what we had
last time was 5, right?

00:48:15.560 --> 00:48:18.470
This is the 1, 1; 0, 1; 1, 1.

00:48:18.470 --> 00:48:23.138
And we'll pick up 1, 2,
3, 4, 5, a weight of 5.

00:48:23.138 --> 00:48:25.430
And it turns out there is no
other path that's smaller.

00:48:25.430 --> 00:48:28.550
So the performance of
this particular code

00:48:28.550 --> 00:48:31.520
is indicated by that number 5.

00:48:31.520 --> 00:48:35.300
It tells you that you
can correct two bits.

00:48:35.300 --> 00:48:37.400
But actually, it
tells you much more

00:48:37.400 --> 00:48:42.830
than you would typically try
and extract from a typical block

00:48:42.830 --> 00:48:45.768
code where you would say, if
there is Hamming distance 5,

00:48:45.768 --> 00:48:47.060
you only can correct two codes.

00:48:47.060 --> 00:48:49.250
Here you've got
message bits that

00:48:49.250 --> 00:48:52.010
go on for a long time,
thousands of bits.

00:48:52.010 --> 00:48:56.210
So what this is telling you
is that in a duration that's

00:48:56.210 --> 00:48:59.900
of the order of five
or six message bits,

00:48:59.900 --> 00:49:03.080
you can, with this scheme,
correct up to two bits.

00:49:03.080 --> 00:49:05.870
You can have bursts of
errors that are very frequent

00:49:05.870 --> 00:49:08.810
and correct them with
this Viterbi decoding.

00:49:08.810 --> 00:49:11.000
So the free distance
is an important notion.

00:49:11.000 --> 00:49:13.700
So when you do the examples
in recitation tomorrow,

00:49:13.700 --> 00:49:17.120
please look out for what the
free distance is for your codes

00:49:17.120 --> 00:49:19.960
and compare with
what we have here.