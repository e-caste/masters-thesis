WEBVTT

00:00:00.070 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.810
Commons license.

00:00:03.810 --> 00:00:06.050
Your support will help
MIT OpenCourseWare

00:00:06.050 --> 00:00:10.150
continue to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.700
To make a donation, or to
view additional materials

00:00:12.700 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.263
at ocw.mit.edu.

00:00:25.725 --> 00:00:26.600
PROFESSOR: All right.

00:00:26.600 --> 00:00:29.160
Today, more games.

00:00:29.160 --> 00:00:31.540
Last time in
general, we're going

00:00:31.540 --> 00:00:36.310
to look at this categorization
of different types of games.

00:00:36.310 --> 00:00:39.580
So far we've been focusing on
the one-player category, which

00:00:39.580 --> 00:00:42.800
normally think of as
puzzles or not games at all.

00:00:42.800 --> 00:00:47.170
But today we're going to branch
out in the other directions.

00:00:47.170 --> 00:00:50.220
And we're going to talk about
zero-player games, which

00:00:50.220 --> 00:00:54.150
arguably are also not
games, and two-player games.

00:00:54.150 --> 00:00:57.330
But to fill out this
space, we probably

00:00:57.330 --> 00:01:03.740
won't get out here yet to
EXPTIME and Undecidable games.

00:01:03.740 --> 00:01:07.080
But we will stick to this chunk.

00:01:07.080 --> 00:01:09.210
We're going to start
with zero-player games,

00:01:09.210 --> 00:01:13.550
also simulations-- Game of Life
is the classic example here.

00:01:13.550 --> 00:01:17.270
And these can be very hard,
despite being very simple

00:01:17.270 --> 00:01:19.890
and not really
having any choices.

00:01:19.890 --> 00:01:23.810
So as a funny equality here,
the sliding block puzzles

00:01:23.810 --> 00:01:26.040
and things that we
looked at last time

00:01:26.040 --> 00:01:29.870
where you have agency, you have
a choice of which move to make,

00:01:29.870 --> 00:01:31.450
will remain PSPACE
complete even when

00:01:31.450 --> 00:01:34.340
you don't have that choice.

00:01:34.340 --> 00:01:36.060
This category is
not so interesting.

00:01:36.060 --> 00:01:39.190
If you a polynomially
bounded zero-player game,

00:01:39.190 --> 00:01:40.035
that is a computer.

00:01:40.035 --> 00:01:43.420
And it can just compute
something for polynomial time.

00:01:43.420 --> 00:01:47.130
And recall, this polynomially
bounded number of moves.

00:01:47.130 --> 00:01:50.509
And this is an exponentially
bounded number of moves.

00:01:50.509 --> 00:01:52.550
Although you can actually
go a little bit higher.

00:01:52.550 --> 00:01:55.660
And we'll talk about that
and get even harder problems

00:01:55.660 --> 00:01:59.220
when you have potentially
infinitely many moves.

00:01:59.220 --> 00:02:01.064
And then we'll go
into two-player,

00:02:01.064 --> 00:02:02.480
in particular,
two-player bounded,

00:02:02.480 --> 00:02:07.210
where we get another
PSPACE completeness result.

00:02:07.210 --> 00:02:12.580
As you may recall from time ago,
all of these versions of games

00:02:12.580 --> 00:02:16.450
have constraint
logic variations.

00:02:16.450 --> 00:02:19.430
So we've focused on this one.

00:02:19.430 --> 00:02:25.380
But I'll mention this one, and
this one, and this one today.

00:02:25.380 --> 00:02:26.570
And they're all complete.

00:02:26.570 --> 00:02:30.830
So we can use them
to reduce things.

00:02:30.830 --> 00:02:33.120
But before we get
to constraint logic,

00:02:33.120 --> 00:02:35.990
I'm going to be talking about
both more classical ways

00:02:35.990 --> 00:02:37.630
of proving hardness
in these classes,

00:02:37.630 --> 00:02:40.980
and then also the
constraint logic way.

00:02:40.980 --> 00:02:43.950
And we'll start with
the Game of Life.

00:02:43.950 --> 00:02:46.110
Let me write down a
definition of the game in case

00:02:46.110 --> 00:02:51.590
you haven't seen it,
or if you've forgotten.

00:02:51.590 --> 00:02:53.485
So this was invented by Conway.

00:03:01.760 --> 00:03:04.070
'70s.

00:03:04.070 --> 00:03:07.885
So you have two types of
cells-- living cells, which

00:03:07.885 --> 00:03:10.800
are the black cells;
and dead cells,

00:03:10.800 --> 00:03:12.370
those are the white cells.

00:03:12.370 --> 00:03:16.300
And you have this iteration--
every cell in parallel updates.

00:03:16.300 --> 00:03:19.550
In general, this is called
a cellular automaton.

00:03:19.550 --> 00:03:23.910
And if we have a
living cell, it will

00:03:23.910 --> 00:03:31.205
continue to live if and only
if it has two or three living

00:03:31.205 --> 00:03:31.705
neighbors.

00:03:37.220 --> 00:03:39.510
This is among the
eight neighbors

00:03:39.510 --> 00:03:42.090
in the 8-way adjacency.

00:03:42.090 --> 00:03:45.730
And then if we have
a dead cell, then it

00:03:45.730 --> 00:03:52.710
becomes living-- it's
born, if you will-- if

00:03:52.710 --> 00:03:57.090
and only if it has exactly
three living neighbors.

00:04:02.210 --> 00:04:04.180
And so those are the rules.

00:04:04.180 --> 00:04:06.830
We don't really need
to know the rules

00:04:06.830 --> 00:04:09.080
except for verifying that
very small gadgets work.

00:04:09.080 --> 00:04:11.490
Most of what I'll talk
about are higher level

00:04:11.490 --> 00:04:13.540
than specifics of these rules.

00:04:13.540 --> 00:04:15.750
But some things you
should know is sometimes

00:04:15.750 --> 00:04:18.089
you get a periodic
pattern like this pulsar.

00:04:18.089 --> 00:04:20.050
Sometimes you get
a static pattern.

00:04:20.050 --> 00:04:23.190
These things don't change
because for example, on the 2

00:04:23.190 --> 00:04:25.340
by 2 square, each
of the living cells

00:04:25.340 --> 00:04:28.280
has exactly three neighbors.

00:04:28.280 --> 00:04:29.420
And so it lives.

00:04:29.420 --> 00:04:33.210
And each of the dead cells has
not exactly three neighbors.

00:04:33.210 --> 00:04:36.250
And so I guess one or two.

00:04:36.250 --> 00:04:37.370
And so they remain dead.

00:04:37.370 --> 00:04:38.350
And so nothing changes.

00:04:38.350 --> 00:04:40.430
That's called still life.

00:04:40.430 --> 00:04:43.560
There's tons of
puns in this area.

00:04:43.560 --> 00:04:45.290
And so that's well and good.

00:04:45.290 --> 00:04:47.789
And so one question you might
ask is, given a pattern,

00:04:47.789 --> 00:04:48.580
is it a still life?

00:04:48.580 --> 00:04:50.150
Well, that's easy to check.

00:04:50.150 --> 00:04:51.760
Is it periodic?

00:04:51.760 --> 00:04:53.980
That's harder to check.

00:04:53.980 --> 00:04:56.190
Does it ever die out
and become nothing?

00:04:56.190 --> 00:04:58.340
That's actually kind of common.

00:04:58.340 --> 00:05:02.720
And that, we will prove,
is very hard to check.

00:05:02.720 --> 00:05:05.230
But all these
questions are related,

00:05:05.230 --> 00:05:07.890
other than still
life, which is easy.

00:05:07.890 --> 00:05:11.480
So some other cool things you
should know about are gliders.

00:05:11.480 --> 00:05:14.510
Gliders are a kind
of periodic pattern,

00:05:14.510 --> 00:05:16.710
but with a diagonal offset.

00:05:16.710 --> 00:05:19.040
So they go off to infinity
in a diagonal direction,

00:05:19.040 --> 00:05:20.180
unless they hit something.

00:05:20.180 --> 00:05:21.900
Then something might happen.

00:05:21.900 --> 00:05:23.910
But in the absence
of anything else

00:05:23.910 --> 00:05:26.600
they'll just keep
going on for infinity.

00:05:26.600 --> 00:05:30.380
So this is a little different
from most of our games.

00:05:30.380 --> 00:05:32.280
Most of our games we
have a finite board.

00:05:32.280 --> 00:05:34.580
There's some rectangular thing.

00:05:34.580 --> 00:05:36.700
Sometimes Life is
played on a torus.

00:05:36.700 --> 00:05:38.500
So when you go off
the south edge,

00:05:38.500 --> 00:05:40.890
you end up on the
north edge, and so on.

00:05:40.890 --> 00:05:44.760
In that setting, Life is
going to be PSPACE complete.

00:05:44.760 --> 00:05:53.330
So in general for
zero-player games,

00:05:53.330 --> 00:05:59.820
if we have a polynomial number
of moves, then of course

00:05:59.820 --> 00:06:03.570
we're going to be
in polynomial time.

00:06:03.570 --> 00:06:05.360
If we have an unbounded
number of moves

00:06:05.360 --> 00:06:10.330
but a polynomial space,
basically, then we're

00:06:10.330 --> 00:06:13.610
going to get PSPACE.

00:06:13.610 --> 00:06:14.110
OK.

00:06:14.110 --> 00:06:14.730
No surprise.

00:06:14.730 --> 00:06:21.180
So the finite versions of
Life will be like that.

00:06:21.180 --> 00:06:26.330
But if we have infinite
space, normally we

00:06:26.330 --> 00:06:27.900
can't think about
infinite space.

00:06:27.900 --> 00:06:30.610
But with Life it's meaningful
to have an infinite board.

00:06:30.610 --> 00:06:33.990
But initially only a finite
rectangle has any stuff in it.

00:06:33.990 --> 00:06:38.000
So if you just encode all of the
positions of the living cells

00:06:38.000 --> 00:06:41.120
and say, well everything
outside of that is dead,

00:06:41.120 --> 00:06:43.205
then you can think
about infinite space.

00:06:43.205 --> 00:06:48.350
And here we will get that
the problem is undecidable.

00:06:48.350 --> 00:06:52.570
So there's no finite
algorithm to solve it.

00:06:52.570 --> 00:06:54.572
So that's cool.

00:06:54.572 --> 00:06:57.030
And I'm going to tell you a
little bit about both of these.

00:06:57.030 --> 00:06:58.940
Spaceship is like
a glider, but it

00:06:58.940 --> 00:07:01.990
goes in one dimension
instead of diagonally.

00:07:01.990 --> 00:07:04.140
So usually horizontally.

00:07:04.140 --> 00:07:05.640
There are many
spaceships out there.

00:07:05.640 --> 00:07:09.160
This is one particularly
efficient one.

00:07:09.160 --> 00:07:11.600
And one of the coolest
things is this thing

00:07:11.600 --> 00:07:15.410
called Gosper glider gun,
invented by Bill Gosper,

00:07:15.410 --> 00:07:17.770
I think while he was at MIT.

00:07:17.770 --> 00:07:19.170
It's this construction up here.

00:07:19.170 --> 00:07:21.240
And it creates gliders.

00:07:21.240 --> 00:07:23.220
And so they just
go off to infinity.

00:07:23.220 --> 00:07:27.020
And you just keep making more,
and more, and more of them.

00:07:27.020 --> 00:07:29.960
So in some infinite sense, this
thing is periodic, I guess.

00:07:29.960 --> 00:07:33.366
But at any finite time you have
maybe n of these coming out.

00:07:33.366 --> 00:07:34.990
And you just keep
making more and more.

00:07:37.810 --> 00:07:39.800
Gliders and glider
guns are the key things

00:07:39.800 --> 00:07:43.722
you should know about
for hardness proofs.

00:07:43.722 --> 00:07:46.900
First I'm just going to show you
a couple of pictures of fairly

00:07:46.900 --> 00:07:48.140
recent hardness proofs.

00:07:48.140 --> 00:07:52.287
This is an explicit construction
of a particular Turing machine.

00:07:52.287 --> 00:07:54.870
I think it is a Turing machine
that given a number represented

00:07:54.870 --> 00:07:57.840
in unary doubles that number.

00:07:57.840 --> 00:08:01.420
So it's a fairly clean
machine, which is in here.

00:08:01.420 --> 00:08:03.670
And there's two stacks.

00:08:03.670 --> 00:08:05.430
So you can think of
a Turing machine,

00:08:05.430 --> 00:08:07.000
normally you have a tape.

00:08:07.000 --> 00:08:10.270
And you have your head
at some cell in the tape.

00:08:10.270 --> 00:08:12.470
You can think of that as a
stack going to your left,

00:08:12.470 --> 00:08:14.180
and a stack going to your right.

00:08:14.180 --> 00:08:16.220
Each time you can pop off
an item from the stack

00:08:16.220 --> 00:08:18.387
and push it onto the other side.

00:08:18.387 --> 00:08:20.220
That would be the same
as moving to the left

00:08:20.220 --> 00:08:21.829
or moving to the right.

00:08:21.829 --> 00:08:23.370
So this is implementing
what's called

00:08:23.370 --> 00:08:24.930
a pushdown automaton
with two stacks,

00:08:24.930 --> 00:08:28.260
but basically a Turing
machine with one tape.

00:08:28.260 --> 00:08:29.280
And you can do that.

00:08:29.280 --> 00:08:31.200
And this is done
algorithmically.

00:08:31.200 --> 00:08:34.380
So he also applied it to a
universal Turing machine,

00:08:34.380 --> 00:08:35.589
if you're more a fan of that.

00:08:35.589 --> 00:08:38.171
That's the Turing machine that
takes a Turing machine as input

00:08:38.171 --> 00:08:38.900
and simulates it.

00:08:38.900 --> 00:08:40.025
So that's the code in here.

00:08:40.025 --> 00:08:41.789
It's much bigger.

00:08:41.789 --> 00:08:46.310
Now this construction relies
on the tape being finite.

00:08:46.310 --> 00:08:50.620
So it proves PSPACE completeness
for the polynomial space

00:08:50.620 --> 00:08:51.120
version.

00:08:51.120 --> 00:08:55.480
It will remain in this
rectangle, as big as it is.

00:08:55.480 --> 00:08:58.670
And it will run the machine.

00:08:58.670 --> 00:09:00.510
If it ran out of
tape, then the machine

00:09:00.510 --> 00:09:03.400
might crash or not
do the thing that it

00:09:03.400 --> 00:09:05.970
was supposed to do if
it was a Turing machine.

00:09:05.970 --> 00:09:08.070
So that's fine for
PSPACE hardness,

00:09:08.070 --> 00:09:09.960
because simulating a
Turing machine is hard.

00:09:09.960 --> 00:09:11.560
I mentioned that last time.

00:09:11.560 --> 00:09:13.340
But not good for undecidability.

00:09:14.630 --> 00:09:19.680
Same guy a year later came
up with a Turing machine that

00:09:19.680 --> 00:09:22.620
grows itself automatically.

00:09:22.620 --> 00:09:27.520
So it's a little hard to see,
but this is the original thing.

00:09:27.520 --> 00:09:29.970
And then as you run
it longer and longer,

00:09:29.970 --> 00:09:33.670
this machine moves
along this dotted line.

00:09:33.670 --> 00:09:34.610
So it's moved here.

00:09:34.610 --> 00:09:38.580
This is like the dirt
that it leaves behind.

00:09:38.580 --> 00:09:41.200
And simultaneously
it's been building

00:09:41.200 --> 00:09:43.900
larger and larger versions
of its stacks, so by the time

00:09:43.900 --> 00:09:46.680
it needs to use it,
it will be available.

00:09:46.680 --> 00:09:49.270
Because space is
bounded by time.

00:09:49.270 --> 00:09:52.870
So limit on the rate of growth.

00:09:52.870 --> 00:09:54.750
Very complicated, obviously.

00:09:54.750 --> 00:09:56.850
But extremely powerful.

00:09:56.850 --> 00:09:59.490
This establishes that
some version of Life

00:09:59.490 --> 00:10:03.052
like, will the thing ever
stop growing, is undecidable.

00:10:03.052 --> 00:10:05.260
Cause if the machine halts,
you could make this thing

00:10:05.260 --> 00:10:07.790
just stop.

00:10:07.790 --> 00:10:16.120
It will non answer the question
of, given a life setup,

00:10:16.120 --> 00:10:18.930
will everything
eventually disappear?

00:10:18.930 --> 00:10:21.250
At least not easily.

00:10:21.250 --> 00:10:23.720
So I'm going to talk about
that version and a somewhat

00:10:23.720 --> 00:10:25.810
older proof, partly
because I like old proofs.

00:10:25.810 --> 00:10:27.680
And it's a very epic proof.

00:10:27.680 --> 00:10:30.360
So this one, I don't
understand the details of.

00:10:30.360 --> 00:10:34.010
But they are online if you
want to study this thing.

00:10:34.010 --> 00:10:39.510
There is another proof by
Berlekamp, Conway, and Guy

00:10:39.510 --> 00:10:41.790
in their series of books
called Winning Ways, which

00:10:41.790 --> 00:10:44.880
is a very cool set of books.

00:10:44.880 --> 00:10:46.950
Interested in two-player
games in particular.

00:10:46.950 --> 00:10:49.600
But they have this chapter
about life being undecidable.

00:10:53.280 --> 00:10:54.680
At a high level
it's very simple.

00:10:54.680 --> 00:10:56.600
It's just if you
have a glider, that's

00:10:56.600 --> 00:10:58.290
going to represent a 1 bit.

00:10:58.290 --> 00:11:01.400
If you don't have a glider
in a particular area,

00:11:01.400 --> 00:11:03.090
that's going to
represent a zero bit.

00:11:03.090 --> 00:11:05.190
And so you can think
of streams of bits

00:11:05.190 --> 00:11:08.980
and doing stuff
with them over time.

00:11:08.980 --> 00:11:11.810
And so that's cool.

00:11:11.810 --> 00:11:15.400
Everything's going to be
oriented diagonally, of course.

00:11:15.400 --> 00:11:17.790
Now one useful structure.

00:11:17.790 --> 00:11:19.840
That's going to be our wire.

00:11:19.840 --> 00:11:22.220
We can also build a terminator.

00:11:22.220 --> 00:11:23.560
They call these eaters.

00:11:23.560 --> 00:11:25.080
So this is a
particular construction

00:11:25.080 --> 00:11:27.280
where-- and this
is frame-by-frame--

00:11:27.280 --> 00:11:30.630
if the glider comes
in here, it basically

00:11:30.630 --> 00:11:33.340
gets eaten by the eater,
and the eater remains.

00:11:33.340 --> 00:11:36.270
The notation, by the
way, is that the dots

00:11:36.270 --> 00:11:39.590
are going to be newly born
positions in the next step.

00:11:39.590 --> 00:11:42.720
And the holes are going
to die in the next step.

00:11:42.720 --> 00:11:45.300
So you can see the transition.

00:11:45.300 --> 00:11:46.040
Stuff happens.

00:11:46.040 --> 00:11:47.706
These are just things
you need to check.

00:11:47.706 --> 00:11:50.684
And boom, it ends up
just the eater remains.

00:11:50.684 --> 00:11:52.100
The eater is
otherwise still life.

00:11:52.100 --> 00:11:54.100
So it will just hang out.

00:11:54.100 --> 00:11:56.010
So you can send
gliders into an eater,

00:11:56.010 --> 00:11:57.880
and they'll just disappear.

00:11:57.880 --> 00:12:04.870
One thing to note is
that the exact offset

00:12:04.870 --> 00:12:07.421
of this stream versus the
eater is very critical.

00:12:07.421 --> 00:12:08.920
You do something a
little different,

00:12:08.920 --> 00:12:11.680
eater might explode or
do something else weird.

00:12:11.680 --> 00:12:15.610
So if you're going to
build these, be careful.

00:12:15.610 --> 00:12:17.780
We'll talk a little bit
more about parity and things

00:12:17.780 --> 00:12:19.360
in a moment.

00:12:19.360 --> 00:12:19.860
OK.

00:12:19.860 --> 00:12:25.150
So here's a fun thing you can
do with a glider gun up top,

00:12:25.150 --> 00:12:27.270
and a stream of bits.

00:12:27.270 --> 00:12:29.430
So if you have a stream
of bits coming in here.

00:12:29.430 --> 00:12:33.830
And you have a glider gun
shooting one, one, one, one

00:12:33.830 --> 00:12:37.470
down, then if you
set up your gliders

00:12:37.470 --> 00:12:39.900
with the exact right
offsets-- so I've

00:12:39.900 --> 00:12:42.190
got to shift that
gun to be precise--

00:12:42.190 --> 00:12:44.610
and then when gliders
hit each other,

00:12:44.610 --> 00:12:46.530
they annihilate each other.

00:12:46.530 --> 00:12:49.930
Nothing is left with
this particular offset.

00:12:49.930 --> 00:12:52.320
So what that means
is in some sense

00:12:52.320 --> 00:12:53.560
you're negating the signal.

00:12:53.560 --> 00:12:56.330
If a 1 comes in here,
it'll hit another 1.

00:12:56.330 --> 00:12:58.720
And then 0 will come out here.

00:12:58.720 --> 00:13:01.094
But in particular,
if there's a 0 here,

00:13:01.094 --> 00:13:03.510
there will be nothing to stop
this guy from going through,

00:13:03.510 --> 00:13:05.050
so you get a 1 out.

00:13:05.050 --> 00:13:07.200
So this isn't really a
negation, because whenever

00:13:07.200 --> 00:13:09.350
it's horizontal, it's
going to be one way.

00:13:09.350 --> 00:13:11.600
And whenever it's negative,
it's going to be inverted.

00:13:11.600 --> 00:13:12.800
But this is really a turn.

00:13:12.800 --> 00:13:14.810
So if I turn this and
then turn it back,

00:13:14.810 --> 00:13:18.720
which I think is the next
image, I can now turn a wire.

00:13:18.720 --> 00:13:21.970
So this is progress, but
already a little challenging.

00:13:21.970 --> 00:13:25.330
So we have this input wire
gets turned by the gun.

00:13:25.330 --> 00:13:27.300
Turn back, turn back, turn back.

00:13:27.300 --> 00:13:32.290
So sufficiently zoomed out,
you can do arbitrary turns.

00:13:32.290 --> 00:13:34.670
You can use this to delay
signals, which is useful,

00:13:34.670 --> 00:13:38.060
because timing is really
sensitive here with the wires

00:13:38.060 --> 00:13:42.790
and when there's a
one bit or a zero bit.

00:13:42.790 --> 00:13:44.560
Another thing you
can do with this

00:13:44.560 --> 00:13:48.160
is get a parity offset shift.

00:13:48.160 --> 00:13:50.230
Because there are actually
many different offsets

00:13:50.230 --> 00:13:55.420
of the gliders that all lead to
evaporation and into nothing.

00:13:55.420 --> 00:13:58.040
So you have to believe
this a little bit,

00:13:58.040 --> 00:14:00.450
but there are enough
different offsets here

00:14:00.450 --> 00:14:04.460
that by doing a bunch of
turns like in this picture,

00:14:04.460 --> 00:14:07.020
with slightly different
offsets of each of these guns,

00:14:07.020 --> 00:14:11.350
you can shift your signal to be
anywhere you want on the grid.

00:14:11.350 --> 00:14:13.500
That's good, because
all the gadgets will

00:14:13.500 --> 00:14:17.230
require very careful alignment.

00:14:17.230 --> 00:14:19.950
So, that's a shift.

00:14:19.950 --> 00:14:26.370
So now here's how we can do
AND and OR gates pretty easily.

00:14:26.370 --> 00:14:29.950
So on the one hand, if
we have two streams A, B,

00:14:29.950 --> 00:14:31.450
and we want to make
the end of them.

00:14:31.450 --> 00:14:33.570
We're going to use
a single glider gun

00:14:33.570 --> 00:14:35.780
to kind of merge them together.

00:14:35.780 --> 00:14:39.920
So a 1 is going to get
through here if and only

00:14:39.920 --> 00:14:42.490
if there was a 0 here.

00:14:42.490 --> 00:14:44.380
And in that case, it
will prevent any A

00:14:44.380 --> 00:14:46.830
from getting through.

00:14:46.830 --> 00:14:50.410
So if B was false, there's a 0,
then there'll be a glider here.

00:14:50.410 --> 00:14:56.317
And it will annihilate whatever
was an A, so the AND will be 0.

00:14:56.317 --> 00:14:58.150
On the other hand, maybe
both of them are 0.

00:14:58.150 --> 00:14:59.675
Then the glider will just
go up here to the eater

00:14:59.675 --> 00:15:00.670
and disappear.

00:15:00.670 --> 00:15:02.640
So that's also fine.

00:15:02.640 --> 00:15:08.040
And if A is zero, then there
will be nothing over there,

00:15:08.040 --> 00:15:09.330
obviously.

00:15:09.330 --> 00:15:12.080
And if they're both one,
then A will get through,

00:15:12.080 --> 00:15:16.480
because B will prevent the
gun here from getting there.

00:15:16.480 --> 00:15:18.405
So A and B have to be
sort of offset in time,

00:15:18.405 --> 00:15:20.530
because it takes a little
bit longer for the signal

00:15:20.530 --> 00:15:23.800
to get here, but
you get the And.

00:15:23.800 --> 00:15:31.380
And similarly for the OR, if
you want to send up a gun here,

00:15:31.380 --> 00:15:33.960
and then it's essentially
getting negated on the right.

00:15:33.960 --> 00:15:36.260
So for there to be
an output in the OR,

00:15:36.260 --> 00:15:37.950
there must be nothing here.

00:15:37.950 --> 00:15:41.300
And so for a glider
to be blocked,

00:15:41.300 --> 00:15:43.670
either A blocks
it or B blocks it.

00:15:43.670 --> 00:15:47.210
So then the output
is the OR of A and B.

00:15:47.210 --> 00:15:51.694
And because everything
here is horizontal,

00:15:51.694 --> 00:15:52.860
we're not negating anything.

00:15:52.860 --> 00:15:53.580
That's actually annoying.

00:15:53.580 --> 00:15:55.750
It would be better if
we had an AND and an OR.

00:15:55.750 --> 00:15:58.422
Or an AND or an OR, cause
then it would be done.

00:15:58.422 --> 00:15:59.505
So we still need negation.

00:16:04.316 --> 00:16:04.940
Yeah, question.

00:16:04.940 --> 00:16:08.330
AUDIENCE: If you go
back into this line,

00:16:08.330 --> 00:16:10.648
you are going to have
this A and B output

00:16:10.648 --> 00:16:13.083
there as well, to
get the terminator.

00:16:13.083 --> 00:16:15.202
In the right-hand diagram.

00:16:15.202 --> 00:16:15.910
PROFESSOR: Right.

00:16:15.910 --> 00:16:16.340
Right.

00:16:16.340 --> 00:16:16.510
Sorry.

00:16:16.510 --> 00:16:18.320
So there should also
be an eater here,

00:16:18.320 --> 00:16:21.680
because this is
not fully occupied.

00:16:21.680 --> 00:16:22.350
Good.

00:16:22.350 --> 00:16:23.808
But because this
is fully occupied,

00:16:23.808 --> 00:16:25.060
we don't need an eater there.

00:16:25.060 --> 00:16:27.120
Cause this is fully occupied,
we don't need and eater here.

00:16:27.120 --> 00:16:28.745
You could put them
in for good measure.

00:16:28.745 --> 00:16:33.050
But, cool.

00:16:33.050 --> 00:16:36.000
So before I show
you the next gadget,

00:16:36.000 --> 00:16:40.360
I need another fun tool
called the kick back.

00:16:40.360 --> 00:16:43.870
So this is of somewhat weirder
offset between two gliders.

00:16:43.870 --> 00:16:47.210
So one's coming in this way,
the other is coming in this way.

00:16:47.210 --> 00:16:48.940
And stuff happens.

00:16:48.940 --> 00:16:53.600
And then this glider
goes backwards.

00:16:53.600 --> 00:16:55.880
Returns along its original spot.

00:16:55.880 --> 00:16:56.990
So this is really cool.

00:16:56.990 --> 00:16:58.710
It means if you're
sending a glider,

00:16:58.710 --> 00:17:00.520
if you can kind of
head it off at the pass

00:17:00.520 --> 00:17:02.380
with the perpendicular
glider, you

00:17:02.380 --> 00:17:05.829
can cause that glider to come
back the way it was going.

00:17:05.829 --> 00:17:10.930
Which I think exactly
the same offset, even.

00:17:10.930 --> 00:17:13.760
So this is useful
for a lot of things.

00:17:13.760 --> 00:17:17.190
In particular, it lets
us build a crossover.

00:17:17.190 --> 00:17:19.079
So the idea with a
crossover is that instead

00:17:19.079 --> 00:17:25.589
of every-- a glider gun produces
gliders at a certain rate.

00:17:25.589 --> 00:17:27.900
Call that rate one.

00:17:27.900 --> 00:17:32.050
When it's so dense, if
you cross two streams,

00:17:32.050 --> 00:17:34.455
you're guaranteed collisions
and something unintentional

00:17:34.455 --> 00:17:35.550
will happen.

00:17:35.550 --> 00:17:37.420
But if I could just
thin out the stream so

00:17:37.420 --> 00:17:42.290
that every 10th
position is a glider,

00:17:42.290 --> 00:17:46.000
and then we only look at the
bits, you know, modular 10,

00:17:46.000 --> 00:17:48.150
then there will be no
problem to do crossings.

00:17:48.150 --> 00:17:51.070
You just have to set up the
parity so that the gap happens

00:17:51.070 --> 00:17:52.630
whenever the other guy happens.

00:17:52.630 --> 00:17:53.550
And vice versa.

00:17:53.550 --> 00:17:56.730
So they'll never
collide with each other.

00:17:56.730 --> 00:17:58.570
Even if it's all ones.

00:17:58.570 --> 00:18:02.550
So here's how you
thin out a stream.

00:18:02.550 --> 00:18:06.900
We have a single
glider here, which

00:18:06.900 --> 00:18:11.060
is just going to be kicked back
and forth, just hanging out.

00:18:11.060 --> 00:18:15.600
And on the other hand, we
have these guns-- G1, G2, G3.

00:18:15.600 --> 00:18:19.420
So this is going to
replace a single gun.

00:18:19.420 --> 00:18:25.190
So this is the notation for
the kickback minute mechanism.

00:18:25.190 --> 00:18:29.610
So mostly these guys are
just going to shoot off.

00:18:29.610 --> 00:18:33.000
But they're set up so that
if this glider comes here,

00:18:33.000 --> 00:18:34.800
he gets kicked back.

00:18:34.800 --> 00:18:36.830
And also we lose
one glider here,

00:18:36.830 --> 00:18:38.650
but they're going to
eat it all up anyway,

00:18:38.650 --> 00:18:40.860
so it doesn't matter.

00:18:40.860 --> 00:18:42.180
And same thing over here.

00:18:42.180 --> 00:18:46.220
So this guy is mostly ones,
but every once in awhile

00:18:46.220 --> 00:18:48.130
this glider will come
in and get kickback,

00:18:48.130 --> 00:18:51.810
and consume one of the
gliders down this G2 stream.

00:18:51.810 --> 00:18:53.550
So there will be a
couple holes here.

00:18:53.550 --> 00:18:55.720
And then if you basically
negate that stream,

00:18:55.720 --> 00:18:58.160
so you send another
glider down through here,

00:18:58.160 --> 00:19:01.000
then only every once in
awhile will you have a glider.

00:19:01.000 --> 00:19:04.050
And by controlling this width,
you can control the rate.

00:19:04.050 --> 00:19:05.950
And I think in this
proof, you just

00:19:05.950 --> 00:19:07.500
need all of them the same rate.

00:19:07.500 --> 00:19:12.080
Sufficiently large
to allow crossovers.

00:19:12.080 --> 00:19:12.960
OK.

00:19:12.960 --> 00:19:14.610
Cool.

00:19:14.610 --> 00:19:17.389
So that's thinning
and crossover.

00:19:17.389 --> 00:19:18.430
AUDIENCE: Quick question.

00:19:18.430 --> 00:19:18.680
PROFESSOR: Yeah.

00:19:18.680 --> 00:19:20.263
AUDIENCE: Are glider
gun constructions

00:19:20.263 --> 00:19:22.412
that we know about, or
as least know about it

00:19:22.412 --> 00:19:24.680
at the time [INAUDIBLE]
enough that you can't just

00:19:24.680 --> 00:19:28.655
set the rate of fire from
the gun construction use.

00:19:28.655 --> 00:19:30.946
AUDIENCE: There's a gun for
every period either greater

00:19:30.946 --> 00:19:32.646
than or equal to 14.

00:19:32.646 --> 00:19:34.240
PROFESSOR: Oh, cool.

00:19:34.240 --> 00:19:35.587
According to--

00:19:35.587 --> 00:19:36.420
AUDIENCE: Wikipedia.

00:19:36.420 --> 00:19:37.295
PROFESSOR: Wikipedia.

00:19:37.295 --> 00:19:39.920
Must be true.

00:19:39.920 --> 00:19:43.060
I'll make a weak claim
to the extent to which I

00:19:43.060 --> 00:19:45.147
know glider guns, these
are not like easily

00:19:45.147 --> 00:19:46.105
variable constructions.

00:19:46.105 --> 00:19:49.090
They're kind of magical,
and they just work.

00:19:49.090 --> 00:19:51.556
There are probably many
different glider guns,

00:19:51.556 --> 00:19:52.680
each with a different rate.

00:19:52.680 --> 00:19:54.960
But I don't think there's
a general purpose glider

00:19:54.960 --> 00:19:57.104
gun with an arbitrary rate.

00:19:57.104 --> 00:19:58.520
Now there might
be one by now that

00:19:58.520 --> 00:20:02.870
has a slow enough
rate that we're OK.

00:20:02.870 --> 00:20:04.190
But I don't know.

00:20:04.190 --> 00:20:06.820
So this certainly guarantees
that yeah, you could do it.

00:20:06.820 --> 00:20:10.170
It's a little bit messy, but
maybe there's a simpler one.

00:20:10.170 --> 00:20:14.770
Life is still actively studied
so there are many more guns

00:20:14.770 --> 00:20:18.450
and there were in
the early '80s so I

00:20:18.450 --> 00:20:21.000
think I won't go through
this construction in detail,

00:20:21.000 --> 00:20:24.720
but using orders
and some kickbacks

00:20:24.720 --> 00:20:27.080
and some crazy
ideas with guns, you

00:20:27.080 --> 00:20:29.014
could build a split and a not.

00:20:29.014 --> 00:20:31.740
Is that OK?

00:20:31.740 --> 00:20:34.920
In particular, we're using
this idea of rate limiting,

00:20:34.920 --> 00:20:36.270
so there's a lot of zeroes here.

00:20:36.270 --> 00:20:38.630
And this is, whatever,
10 spots-- there's

00:20:38.630 --> 00:20:40.860
only one every 10 spots.

00:20:40.860 --> 00:20:46.990
And there's two cases, depending
on whether A is there or not.

00:20:46.990 --> 00:20:49.740
And by ORing it
together with something,

00:20:49.740 --> 00:20:51.490
and then having all
these chain reactions,

00:20:51.490 --> 00:20:59.230
we end up with a copy of A
here, and a negated copy of A

00:20:59.230 --> 00:21:01.320
hear with different offsets.

00:21:01.320 --> 00:21:01.890
Yeah.

00:21:01.890 --> 00:21:03.264
AUDIENCE: So for
NOT, isn't there

00:21:03.264 --> 00:21:06.088
the super easy gadget
of A equal gun,

00:21:06.088 --> 00:21:10.607
and then-- sorry-- the gun
gets through if A is not there.

00:21:10.607 --> 00:21:12.690
PROFESSOR: That's what we
had for the turn gadget,

00:21:12.690 --> 00:21:13.981
but it always turns the signal.

00:21:13.981 --> 00:21:15.887
AUDIENCE: And that's bad?

00:21:15.887 --> 00:21:17.470
PROFESSOR: That's
bad because it means

00:21:17.470 --> 00:21:20.910
if you think of your gadgets
having inputs horizontally,

00:21:20.910 --> 00:21:24.000
then you need to negate
and still be horizontal.

00:21:24.000 --> 00:21:25.930
So this negates and
still is horizontal.

00:21:25.930 --> 00:21:29.820
In their writeup, they actually
call the turn a NOT gadget.

00:21:29.820 --> 00:21:33.409
But I think that's not NOT.

00:21:33.409 --> 00:21:34.700
It depends on your perspective.

00:21:34.700 --> 00:21:40.060
You definitely need a
direction-preserving NOT.

00:21:40.060 --> 00:21:42.160
OK.

00:21:42.160 --> 00:21:43.810
So that's cool.

00:21:43.810 --> 00:21:46.650
And at this point, they say
just give this to the engineers

00:21:46.650 --> 00:21:48.680
and they'll build a computer.

00:21:48.680 --> 00:21:52.220
Once you have AND or NOT,
you can build binary logic,

00:21:52.220 --> 00:21:53.940
so you can do
CIRCUIT-SAT style things.

00:21:53.940 --> 00:21:58.540
And you could make
re-entrant circuits.

00:21:58.540 --> 00:22:01.060
And so you can compute
on stuff and build

00:22:01.060 --> 00:22:04.070
a Turing machine
with a finite size,

00:22:04.070 --> 00:22:07.300
or any machine of finite
size, bounded size.

00:22:07.300 --> 00:22:10.410
So that's enough to
prove PSPACE hardness.

00:22:10.410 --> 00:22:12.480
But if you want to
prove undecidability,

00:22:12.480 --> 00:22:15.780
you need some way to
grow up to infinity.

00:22:15.780 --> 00:22:19.460
And their idea is to have a
small number of registers.

00:22:19.460 --> 00:22:21.260
Two are enough.

00:22:21.260 --> 00:22:29.490
This is called a Minsky machine,
is the two-counter version.

00:22:29.490 --> 00:22:34.620
And Minsky proved that you
can simulate a Turing machine

00:22:34.620 --> 00:22:35.790
with two counters.

00:22:35.790 --> 00:22:37.090
What's a counter?

00:22:37.090 --> 00:22:39.790
It stores a
non-negative integer.

00:22:39.790 --> 00:22:43.310
And you have three operations--
increment, decrement, and check

00:22:43.310 --> 00:22:45.160
whether it's 0.

00:22:45.160 --> 00:22:46.430
So it's a little crazy.

00:22:46.430 --> 00:22:49.720
But that's enough to
simulate an entire Turing

00:22:49.720 --> 00:22:53.410
machine with infinite tape.

00:22:53.410 --> 00:22:57.580
So the rough idea is to
store a bit onto the tape.

00:22:57.580 --> 00:23:00.060
You double it and
possibly add one.

00:23:00.060 --> 00:23:04.230
And if you want to remove
something from the stack,

00:23:04.230 --> 00:23:06.540
then you divide by 2.

00:23:06.540 --> 00:23:08.060
So with four
registers, you can use

00:23:08.060 --> 00:23:11.020
this one to represent
one stack, and this one

00:23:11.020 --> 00:23:12.250
to represent the other stack.

00:23:12.250 --> 00:23:13.040
Dot, dot, dot.

00:23:13.040 --> 00:23:16.670
It's not too hard.

00:23:16.670 --> 00:23:19.920
So how are we going to represent
an arbitrary non-negative

00:23:19.920 --> 00:23:20.770
integer?

00:23:20.770 --> 00:23:22.500
We're going to have
a little 2 by 2

00:23:22.500 --> 00:23:27.810
box-- this is drawn diagonally--
somewhere along this ray.

00:23:27.810 --> 00:23:31.160
And then we're going to be
able to increment or decrement

00:23:31.160 --> 00:23:34.770
the box by sending
a wave of gliders

00:23:34.770 --> 00:23:36.730
using these constructions.

00:23:36.730 --> 00:23:43.170
Sorry, next slide we'll have the
constructions for incrementing.

00:23:43.170 --> 00:23:44.860
Here actually is a
glider that's going

00:23:44.860 --> 00:23:47.090
to test whether this
guy's currently zero.

00:23:47.090 --> 00:23:50.200
And he happens to be.

00:23:50.200 --> 00:23:51.780
And so here's how you test.

00:23:51.780 --> 00:23:55.580
I mean, you just send a
glider through the box.

00:23:55.580 --> 00:23:58.360
And there may be a cleaner test.

00:23:58.360 --> 00:24:00.100
This one is a destructive test.

00:24:00.100 --> 00:24:01.350
It destroys the box.

00:24:01.350 --> 00:24:03.680
But in particular, it
destroys the glider.

00:24:03.680 --> 00:24:06.680
So then you can have a gate
on this side that says, well,

00:24:06.680 --> 00:24:09.890
if I didn't get a glider, then
I know that I'm actually 0,

00:24:09.890 --> 00:24:12.740
and I can feed that back
to my logic circuit.

00:24:12.740 --> 00:24:15.370
If I do get a glider, then
I know this was empty.

00:24:15.370 --> 00:24:16.771
So that's pretty easy.

00:24:16.771 --> 00:24:18.770
The only catch is then
you've destroyed the box.

00:24:18.770 --> 00:24:20.310
You have to create a new box.

00:24:20.310 --> 00:24:23.440
And you can do that by sending
two gliders with a slightly

00:24:23.440 --> 00:24:24.340
different offset.

00:24:24.340 --> 00:24:27.030
This looks like this same as
all the others, but in this one

00:24:27.030 --> 00:24:28.910
you end up with
a box at the end.

00:24:28.910 --> 00:24:30.820
So if you send like
another one here

00:24:30.820 --> 00:24:33.080
and another one timed
just right here,

00:24:33.080 --> 00:24:34.580
you'll recreate the
box after you've

00:24:34.580 --> 00:24:37.110
discovered that it was there.

00:24:37.110 --> 00:24:38.590
So that's cool.

00:24:38.590 --> 00:24:39.900
And then this is a swarm.

00:24:39.900 --> 00:24:43.500
I think it's actually drawn
somewhat accurately to push

00:24:43.500 --> 00:24:47.360
this block forward by 1.

00:24:47.360 --> 00:24:49.140
I think it's this stream.

00:24:49.140 --> 00:24:51.130
So there are two
constructions here.

00:24:51.130 --> 00:24:56.870
One is a wave of gliders that
pulls it a block back by 3,

00:24:56.870 --> 00:24:58.470
another one pushes
it forward by 1.

00:24:58.470 --> 00:25:02.770
Together you could use this to
increment or decrement by 1.

00:25:02.770 --> 00:25:06.090
So I mean, lots of
details to check here.

00:25:06.090 --> 00:25:09.110
This one is a
little bit cleaner.

00:25:09.110 --> 00:25:11.990
We have one glider here,
a second glide here.

00:25:11.990 --> 00:25:13.050
And it ends up moving.

00:25:13.050 --> 00:25:15.760
It goes in this
order and then back.

00:25:15.760 --> 00:25:20.290
And we end up moving the box
up to here, back three spaces.

00:25:20.290 --> 00:25:23.910
I assume these are found
by trial and error.

00:25:23.910 --> 00:25:27.500
And then to push a block
forward 1, this is pretty crazy.

00:25:27.500 --> 00:25:34.370
Their second wave
of five gliders.

00:25:34.370 --> 00:25:36.038
Where's the first wave?

00:25:36.038 --> 00:25:38.430
AUDIENCE: Turning the
block into a honey farm.

00:25:38.430 --> 00:25:40.050
PROFESSOR: That's right.

00:25:40.050 --> 00:25:41.550
Turning the block
into a honey farm,

00:25:41.550 --> 00:25:43.870
which is this particular
still life pattern.

00:25:43.870 --> 00:25:46.080
Anyway.

00:25:46.080 --> 00:25:46.930
Dot, dot, dot.

00:25:46.930 --> 00:25:48.430
You check the results.

00:25:48.430 --> 00:25:48.930
It works.

00:25:48.930 --> 00:25:50.150
It's actually a lot
of fun to implement

00:25:50.150 --> 00:25:52.470
these in a life simulator
and check that it works.

00:25:52.470 --> 00:25:56.660
But for now I'm showing
you the ancient diagrams,

00:25:56.660 --> 00:25:59.240
hand-drawn diagrams.

00:25:59.240 --> 00:26:00.620
OK.

00:26:00.620 --> 00:26:04.780
So there's like a
catch with this.

00:26:04.780 --> 00:26:10.720
In order to generate these
gliders in this very specific

00:26:10.720 --> 00:26:16.190
pattern, currently the only
way we have of making gliders

00:26:16.190 --> 00:26:17.900
is with the glider gun.

00:26:17.900 --> 00:26:19.680
Glider guns are large objects.

00:26:19.680 --> 00:26:22.740
And you can't put them
right next to each other.

00:26:22.740 --> 00:26:24.550
And even worse, if
you have a glider gun,

00:26:24.550 --> 00:26:26.720
it's spitting out gliders
in the middle of it.

00:26:26.720 --> 00:26:30.290
You can't put a glider gun
shifted over a little bit

00:26:30.290 --> 00:26:33.074
even if you slide it
this way or that way.

00:26:33.074 --> 00:26:34.490
If you want to
produce two streams

00:26:34.490 --> 00:26:36.031
very close to each
other, one of them

00:26:36.031 --> 00:26:39.190
will go through the other glider
gun and destroy the glider gun.

00:26:39.190 --> 00:26:42.720
So you can't actually
build this kind of pattern

00:26:42.720 --> 00:26:45.060
with glider guns ultimately.

00:26:45.060 --> 00:26:47.300
But there's this
trick using kickbacks

00:26:47.300 --> 00:26:52.660
to get a glider to go out
far away from any guns.

00:26:52.660 --> 00:26:56.020
And this is to-- so
here's your original gun.

00:26:56.020 --> 00:26:58.360
And this one has
some holes in it.

00:26:58.360 --> 00:27:00.150
So you can get a
glider through here.

00:27:00.150 --> 00:27:03.750
And then get this glider to
bounce back and forth until you

00:27:03.750 --> 00:27:06.730
have the right timing.

00:27:06.730 --> 00:27:11.550
Then this glider will escape
through this little gap.

00:27:11.550 --> 00:27:15.160
And then the result is, you
send the glider basically offset

00:27:15.160 --> 00:27:17.340
to the right from this gun.

00:27:17.340 --> 00:27:19.470
So using that, you can
have a bunch of glider guns

00:27:19.470 --> 00:27:21.660
sort of around
where you need it.

00:27:21.660 --> 00:27:23.450
Get all the gliders to come up.

00:27:23.450 --> 00:27:24.840
And now you're very narrow.

00:27:24.840 --> 00:27:26.964
You could have two gliders
right next to each other

00:27:26.964 --> 00:27:28.560
without any trouble.

00:27:28.560 --> 00:27:30.500
So you do a bunch of
these constructions

00:27:30.500 --> 00:27:32.780
at various heights.

00:27:32.780 --> 00:27:35.090
So this is the picture of
two glider guns, one shooting

00:27:35.090 --> 00:27:36.214
a glider through the other.

00:27:36.214 --> 00:27:37.100
That's bad.

00:27:37.100 --> 00:27:40.710
So instead, we'll put
these away from it,

00:27:40.710 --> 00:27:44.910
and send the gliders offset
to be like that, using

00:27:44.910 --> 00:27:46.800
two of these constructions.

00:27:46.800 --> 00:27:47.450
OK.

00:27:47.450 --> 00:27:51.790
So now we can increment and
decrement, and test for 0.

00:27:51.790 --> 00:27:57.880
With this similar trick
we can do some fun stuff

00:27:57.880 --> 00:28:02.270
in sending gliders
forward and backward.

00:28:02.270 --> 00:28:04.050
So this is cool.

00:28:04.050 --> 00:28:06.090
Remember I said that
you could send a glider

00:28:06.090 --> 00:28:09.400
and cause it to come
back using the kickback.

00:28:09.400 --> 00:28:11.150
So normally if you
want to send the glider

00:28:11.150 --> 00:28:13.920
and have it come back,
you need another glider

00:28:13.920 --> 00:28:16.340
to be shot this way.

00:28:16.340 --> 00:28:18.597
So that's OK in some cases.

00:28:18.597 --> 00:28:20.930
But here's a cool construction
where all the gliders are

00:28:20.930 --> 00:28:23.620
way down here, and still I
can make the glider go up

00:28:23.620 --> 00:28:26.139
and then come back
at some desired time.

00:28:26.139 --> 00:28:27.430
And it's the same kind of idea.

00:28:27.430 --> 00:28:29.638
You use this construction
to make this glider go back

00:28:29.638 --> 00:28:31.250
and forth, spend lots of time.

00:28:31.250 --> 00:28:34.220
And then eventually hit this guy
at just the right orientation

00:28:34.220 --> 00:28:35.490
to send it back.

00:28:35.490 --> 00:28:37.352
And if you have
some more stuff, you

00:28:37.352 --> 00:28:39.560
could actually get it to go
back and forth many times

00:28:39.560 --> 00:28:42.730
and come over
farther to the right.

00:28:42.730 --> 00:28:44.850
Why do I care about this?

00:28:44.850 --> 00:28:47.550
For self-destruction.

00:28:47.550 --> 00:28:52.840
So the idea is if the Turing
machine says yes, if it stops,

00:28:52.840 --> 00:28:56.460
then you want the entire
thing to collapse to nothing.

00:28:56.460 --> 00:28:59.077
And so when you get
to this magical state,

00:28:59.077 --> 00:29:01.160
you're going to send out
a whole bunch of gliders,

00:29:01.160 --> 00:29:03.701
and then turn them around using
the mechanism I just showed--

00:29:03.701 --> 00:29:05.600
the boomerang--
and get them to hit

00:29:05.600 --> 00:29:09.710
every gadget in the construction
at exactly the right offset

00:29:09.710 --> 00:29:11.480
to make them disappear.

00:29:11.480 --> 00:29:14.740
This is how you kill an eater
from going from slightly

00:29:14.740 --> 00:29:16.320
wrong orientation.

00:29:16.320 --> 00:29:18.230
This is how you destroy a gun.

00:29:18.230 --> 00:29:20.090
It ends up with nothing.

00:29:23.000 --> 00:29:23.500
Oh.

00:29:23.500 --> 00:29:23.640
Sorry.

00:29:23.640 --> 00:29:24.260
This is a gun.

00:29:24.260 --> 00:29:25.740
This is a how you
destroy a square.

00:29:25.740 --> 00:29:27.760
We already saw that.

00:29:27.760 --> 00:29:31.557
So all of that infrastructure
being able to precisely place

00:29:31.557 --> 00:29:34.140
gliders exactly where you need
them, lots of details to check.

00:29:34.140 --> 00:29:37.610
But you should be able
to get them all come out

00:29:37.610 --> 00:29:38.350
and come back.

00:29:38.350 --> 00:29:43.500
And you always hit them in
the backside of the guns.

00:29:43.500 --> 00:29:45.700
I think first you kill
all the guns so they

00:29:45.700 --> 00:29:46.890
stop generating gliders.

00:29:46.890 --> 00:29:48.810
You let the gliders
get eaten by eaters.

00:29:48.810 --> 00:29:52.430
And then you go out and destroy
all the eaters and squares

00:29:52.430 --> 00:29:53.190
and so on.

00:29:53.190 --> 00:29:55.285
So, pretty epic.

00:29:55.285 --> 00:29:59.190
But in the end we
get undecidability

00:29:59.190 --> 00:30:02.980
of life in an infinite board.

00:30:02.980 --> 00:30:07.120
So zero-player is
more interesting

00:30:07.120 --> 00:30:08.887
than you might expect.

00:30:08.887 --> 00:30:10.470
This is certainly
one of the more epic

00:30:10.470 --> 00:30:12.422
proofs in that direction.

00:30:12.422 --> 00:30:13.880
Next thing I want
to tell you about

00:30:13.880 --> 00:30:16.610
is zero-player constraint logic.

00:30:16.610 --> 00:30:19.160
This is called deterministic
constraint logic, as opposed

00:30:19.160 --> 00:30:21.500
to nondeterministic
constraint logic, which

00:30:21.500 --> 00:30:23.480
we talked about last time.

00:30:23.480 --> 00:30:26.600
So let me define it for you.

00:30:38.070 --> 00:30:41.890
So in deterministic
constraint logic

00:30:41.890 --> 00:30:45.390
we have a little bit more state.

00:30:45.390 --> 00:30:49.050
Before it's just in
the state of a machine

00:30:49.050 --> 00:30:51.680
is just the orientations
of all the edges.

00:30:51.680 --> 00:30:53.270
Now we're also
going to have-- it's

00:30:53.270 --> 00:30:55.290
a little hard to see
on this projector--

00:30:55.290 --> 00:31:00.809
but there's some highlighted
edges which are active.

00:31:00.809 --> 00:31:02.600
So I'll describe what
they are in a moment.

00:31:02.600 --> 00:31:06.310
So even if you can't see
them, they are there.

00:31:06.310 --> 00:31:12.410
Active literally means that
you just flipped the edge

00:31:12.410 --> 00:31:14.174
in the previous step.

00:31:14.174 --> 00:31:15.590
So deterministic
constraint logic,

00:31:15.590 --> 00:31:18.430
we're going to be flipping
multiple edges at once

00:31:18.430 --> 00:31:19.220
in one round.

00:31:19.220 --> 00:31:23.060
And in the next round, those
edges are all called active.

00:31:23.060 --> 00:31:26.550
And the rest are inactive.

00:31:26.550 --> 00:31:28.100
Now that's for edges.

00:31:28.100 --> 00:31:33.470
We're going to define a
vertex to be active basically

00:31:33.470 --> 00:31:37.190
if that reversal did
something useful.

00:31:37.190 --> 00:31:53.550
So if its active incoming
edges have total weight greater

00:31:53.550 --> 00:31:55.290
or equal to 2.

00:31:55.290 --> 00:32:00.690
So if the just flipped edges
satisfy that vertex possibly

00:32:00.690 --> 00:32:04.460
in a new way, then we
call the vertex active.

00:32:04.460 --> 00:32:07.240
It's been activated by
what just got flipped.

00:32:07.240 --> 00:32:09.655
And then here's what we're
going to do in each round.

00:32:17.180 --> 00:32:24.820
We are going to reverse
inactive edges pointing

00:32:24.820 --> 00:32:29.070
to active vertices.

00:32:37.590 --> 00:32:46.386
And we're going to reverse
active edges pointing

00:32:46.386 --> 00:32:47.260
to inactive vertices.

00:33:00.760 --> 00:33:04.570
And then these reversed edges
are the new active edges.

00:33:14.640 --> 00:33:16.120
OK.

00:33:16.120 --> 00:33:19.530
So let's look at an example.

00:33:19.530 --> 00:33:20.950
So here's a little gadget.

00:33:20.950 --> 00:33:22.575
We're actually going
to use this gadget

00:33:22.575 --> 00:33:26.040
in proving PSPACE
completeness of this model.

00:33:26.040 --> 00:33:31.130
And initially just
this edge is active.

00:33:31.130 --> 00:33:35.200
And if that's all that happens--
now there's some inputs

00:33:35.200 --> 00:33:38.510
and outputs here-- if
that's all that happens,

00:33:38.510 --> 00:33:39.810
this edge is active.

00:33:39.810 --> 00:33:42.490
It alone does not
satisfy this vertex.

00:33:42.490 --> 00:33:44.890
So this vertex is inactive.

00:33:44.890 --> 00:33:48.550
And in the inactive case,
if the vertex is inactive,

00:33:48.550 --> 00:33:50.700
we're supposed to
reverse the active edge.

00:33:50.700 --> 00:33:52.840
This is basically bouncing back.

00:33:52.840 --> 00:33:54.410
If you try to
satisfy a vertex, you

00:33:54.410 --> 00:33:56.820
didn't satisfy it, you
just undo what you did.

00:33:56.820 --> 00:33:58.860
You're going to
reverse the edge.

00:33:58.860 --> 00:34:02.320
So what's going to
happen here is this guy

00:34:02.320 --> 00:34:04.200
will just flip back and forth.

00:34:04.200 --> 00:34:05.570
First he's gonna go this way.

00:34:05.570 --> 00:34:06.720
Says, oh, I didn't
satisfy this one.

00:34:06.720 --> 00:34:07.720
So I'll reverse this edge.

00:34:07.720 --> 00:34:08.620
Now it points into here.

00:34:08.620 --> 00:34:10.100
Still doesn't
satisfy that vertex.

00:34:10.100 --> 00:34:11.090
It's inactive.

00:34:11.090 --> 00:34:13.580
So this guy will just
flip back and forth

00:34:13.580 --> 00:34:18.800
forever until here we're
drawing the picture where

00:34:18.800 --> 00:34:22.870
A reverses, so because
of some gadget below it.

00:34:22.870 --> 00:34:26.420
Suppose A reverses at the same
time this one is reversing.

00:34:26.420 --> 00:34:28.130
So now this edge is active.

00:34:28.130 --> 00:34:29.969
And this edge is active.

00:34:29.969 --> 00:34:31.889
Still this guy didn't
satisfy what he wants.

00:34:31.889 --> 00:34:34.670
So he's going to reverse
again in the next step.

00:34:34.670 --> 00:34:38.000
But this guy did satisfy the
vertex because he has weight 2.

00:34:38.000 --> 00:34:42.239
So now it alone
satisfies this vertex.

00:34:42.239 --> 00:34:44.219
So now both of these
are going to reverse.

00:34:44.219 --> 00:34:46.100
This is the forward case.

00:34:46.100 --> 00:34:49.370
We have a active edge
satisfying-- so now

00:34:49.370 --> 00:34:51.670
this vertex is active.

00:34:51.670 --> 00:34:55.920
We're going to reverse
these inactive edges which

00:34:55.920 --> 00:34:57.594
point to the active vertex.

00:34:57.594 --> 00:34:58.760
So we end up flipping those.

00:34:58.760 --> 00:35:00.385
Now they're pointing
out of the vertex.

00:35:00.385 --> 00:35:01.700
This one remains pointing in.

00:35:01.700 --> 00:35:04.496
It's no longer active, because
we didn't just flip it.

00:35:04.496 --> 00:35:06.870
So we propagate from this
being active to these two being

00:35:06.870 --> 00:35:07.370
active.

00:35:07.370 --> 00:35:09.780
This is a splitter.

00:35:09.780 --> 00:35:12.290
We have the signal and we
split it into two parts.

00:35:12.290 --> 00:35:15.010
So it's acting like the
splitter that we know and love

00:35:15.010 --> 00:35:16.700
from last lecture.

00:35:16.700 --> 00:35:17.200
OK.

00:35:17.200 --> 00:35:20.290
Meanwhile, this guy
just reversed again.

00:35:20.290 --> 00:35:23.240
But now these two are
simultaneously here.

00:35:23.240 --> 00:35:27.090
So together, those two active
edges satisfy the vertex.

00:35:27.090 --> 00:35:30.070
So this vertex is active, which
will flip that edge up there.

00:35:33.040 --> 00:35:34.090
Yes.

00:35:34.090 --> 00:35:38.370
I should say this vertex
is a little bit weird.

00:35:38.370 --> 00:35:41.400
You could think of there being
a red to blue conversion here.

00:35:41.400 --> 00:35:45.460
This guy only has a
desired weight of 1.

00:35:45.460 --> 00:35:47.560
This is basically a
red edge, but it's

00:35:47.560 --> 00:35:49.630
subdivided to fix the timing.

00:35:49.630 --> 00:35:52.360
So we'll see how to get
rid of that subdivision.

00:35:52.360 --> 00:35:54.580
But you can think of
this as a red to blue.

00:35:54.580 --> 00:35:56.530
And there's two blue edges here.

00:35:56.530 --> 00:36:00.260
But this one edge will
actually satisfy this vertex.

00:36:00.260 --> 00:36:03.620
And so then this guy
flips in the next stage.

00:36:03.620 --> 00:36:06.980
And then it's just
going to hang out here,

00:36:06.980 --> 00:36:10.220
flipping back and
forth along this path.

00:36:10.220 --> 00:36:13.610
And meanwhile, this will
go off and do something

00:36:13.610 --> 00:36:18.700
until it comes back
and reverses the edge.

00:36:18.700 --> 00:36:22.150
And I should say at this
point-- because there

00:36:22.150 --> 00:36:23.829
are a lot of timing
issues here, we're

00:36:23.829 --> 00:36:25.870
going to set up all the
gadgets so that they only

00:36:25.870 --> 00:36:31.840
get an input edge reversed
at times divisible by 4.

00:36:31.840 --> 00:36:34.570
So this one happened at time 0.

00:36:34.570 --> 00:36:37.800
And then this one we know will
happen at a certain parity

00:36:37.800 --> 00:36:39.040
relative to 4.

00:36:39.040 --> 00:36:41.550
And so we know when this
guy has gotten flipped,

00:36:41.550 --> 00:36:44.620
this one will also
have just been flipped.

00:36:44.620 --> 00:36:47.862
And then stuff happens.

00:36:47.862 --> 00:36:49.695
And then this edge ends
up getting reversed.

00:36:52.350 --> 00:36:54.070
And then more stuff happens.

00:36:54.070 --> 00:36:56.670
Then this edge gets
reversed again.

00:36:56.670 --> 00:36:59.410
And then the A gets
reversed again.

00:36:59.410 --> 00:37:01.830
So this gadget has
sort of three cycles.

00:37:01.830 --> 00:37:06.090
When you reverse A, first B will
reverse, then C will reverse,

00:37:06.090 --> 00:37:10.486
then B will reverse,
then A will reverse.

00:37:10.486 --> 00:37:11.610
It's a little bit overkill.

00:37:11.610 --> 00:37:13.890
But we're going to use
this to check two options.

00:37:13.890 --> 00:37:15.431
We're just going to
check one of them

00:37:15.431 --> 00:37:19.290
twice because that's
what we can build easily.

00:37:19.290 --> 00:37:19.790
OK.

00:37:19.790 --> 00:37:24.950
So now we want to prove PSPACE
completeness of this model.

00:37:24.950 --> 00:37:28.360
The decision question is again,
does a particular edge ever

00:37:28.360 --> 00:37:30.920
get reversed?

00:37:30.920 --> 00:37:36.600
And so we're going to reduce in
the usual way from quantified

00:37:36.600 --> 00:37:37.860
CNF-SAT.

00:37:37.860 --> 00:37:41.670
We have our blocks which
represent quantifiers.

00:37:41.670 --> 00:37:43.850
They're going to produce
variable settings.

00:37:43.850 --> 00:37:45.415
We're going to have
some CNF logic.

00:37:45.415 --> 00:37:47.790
And then in the end, this is
actually not quite accurate.

00:37:47.790 --> 00:37:50.060
We're going to get some
satisfied signal which

00:37:50.060 --> 00:37:53.120
is piped into these guys.

00:37:53.120 --> 00:37:55.410
So the first thing
that has to change

00:37:55.410 --> 00:37:57.140
are the quantifier gadgets.

00:37:57.140 --> 00:37:58.890
In particular, the
existential quantifier

00:37:58.890 --> 00:38:05.630
needs to change because before
we let the player decide

00:38:05.630 --> 00:38:09.040
whether to choose x or x bar.

00:38:09.040 --> 00:38:11.860
So in this case, we're going
to use the gadget you just saw,

00:38:11.860 --> 00:38:16.680
the little wheel, which
will try x being false.

00:38:16.680 --> 00:38:20.437
Then it will try x being true,
then it will try x being false.

00:38:20.437 --> 00:38:22.270
And all we need is that
one of them is true.

00:38:22.270 --> 00:38:24.760
So if at any point this
formula is satisfied,

00:38:24.760 --> 00:38:26.820
we'll just output that
formula satisfied.

00:38:26.820 --> 00:38:29.470
We have four edges here
because everything needs

00:38:29.470 --> 00:38:32.500
to work modular 4 in timing.

00:38:32.500 --> 00:38:36.170
So there's a little bit
more going on here, which

00:38:36.170 --> 00:38:37.860
I will get into in a moment.

00:38:37.860 --> 00:38:41.380
On the other hand, universal
quantifier is similar.

00:38:41.380 --> 00:38:43.210
I think I will leave it at that.

00:38:43.210 --> 00:38:46.130
There's this generator
to try all the options.

00:38:46.130 --> 00:38:48.860
This is going to act in
some sense like the one

00:38:48.860 --> 00:38:51.750
bit of memory, the latch,
that we had before.

00:38:51.750 --> 00:38:52.650
So it's similar.

00:38:52.650 --> 00:38:55.030
But I think the details
are not worth getting into.

00:38:55.030 --> 00:38:57.672
If you look at the appendix of
Games, Puzzles, Computation,

00:38:57.672 --> 00:38:59.630
you'll see an explicit
execution of this thing.

00:38:59.630 --> 00:39:00.770
I mean, it's like life.

00:39:00.770 --> 00:39:02.920
You just run it through
and see if it works.

00:39:02.920 --> 00:39:05.330
And it does.

00:39:05.330 --> 00:39:10.100
So what's going on
up here is that when

00:39:10.100 --> 00:39:14.050
we set x bar to be false,
we're going to flip this edge.

00:39:14.050 --> 00:39:19.816
And we're basically telling
the circuit, hey, x is false.

00:39:19.816 --> 00:39:21.190
And then at some
point it's going

00:39:21.190 --> 00:39:24.090
to acknowledge and say, OK.

00:39:24.090 --> 00:39:25.470
I understand that x is false.

00:39:27.705 --> 00:39:30.710
But that's going to be
on a different channel.

00:39:30.710 --> 00:39:33.740
So let me illustrate the issue.

00:39:33.740 --> 00:39:38.050
So this is how we
used to do CNF logic.

00:39:38.050 --> 00:39:46.370
We did ANDs of ORs using OR
vertices and AND vertices.

00:39:46.370 --> 00:39:48.985
And that was cool if we had
a signal for what was true

00:39:48.985 --> 00:39:50.610
and what was false,
we could throw away

00:39:50.610 --> 00:39:53.480
signals we didn't need.

00:39:53.480 --> 00:39:57.160
Then this would propagate
and produce a true answer.

00:39:57.160 --> 00:39:58.880
Nondeterministically it would.

00:39:58.880 --> 00:40:02.070
But deterministically there's
a lot of timing issues here.

00:40:02.070 --> 00:40:04.527
Everything has to arrive
at the inputs at exactly

00:40:04.527 --> 00:40:05.110
the same time.

00:40:05.110 --> 00:40:07.980
And AND will only work if
this edge and this edge

00:40:07.980 --> 00:40:10.610
simultaneously reverse.

00:40:10.610 --> 00:40:11.120
So OK.

00:40:11.120 --> 00:40:14.090
Maybe you could subdivide enough
edges to fix the timing issue.

00:40:14.090 --> 00:40:15.870
But it's worse than that.

00:40:15.870 --> 00:40:18.450
If you're doing an
AND of two things,

00:40:18.450 --> 00:40:22.180
and you discover that
the answer is false,

00:40:22.180 --> 00:40:23.970
then all bets are off.

00:40:23.970 --> 00:40:27.140
So normally that would be
OK, because we can always

00:40:27.140 --> 00:40:27.980
undo what we did.

00:40:27.980 --> 00:40:31.200
But we need to guarantee that
the deterministic constraint

00:40:31.200 --> 00:40:35.280
machine will exactly undo
what it was supposed to do.

00:40:35.280 --> 00:40:37.500
So it's an issue that if
one of these comes in true

00:40:37.500 --> 00:40:39.500
and the other's false,
this one will bounce back

00:40:39.500 --> 00:40:41.630
and then chaos will happen.

00:40:41.630 --> 00:40:44.300
We'll end up getting
edges just randomly

00:40:44.300 --> 00:40:46.710
reversing it at annoying times.

00:40:46.710 --> 00:40:49.190
So that seems messy.

00:40:49.190 --> 00:40:52.740
And so instead we build
this much safer version

00:40:52.740 --> 00:40:56.830
called AND prime, OR prime,
and split prime, I guess.

00:40:56.830 --> 00:41:02.760
There should be a prime
there where each input

00:41:02.760 --> 00:41:04.120
is represented by two things.

00:41:04.120 --> 00:41:07.870
First the signal, and
then the acknowledgement.

00:41:07.870 --> 00:41:10.840
And so there's some
details to check here.

00:41:10.840 --> 00:41:13.030
The OR is particularly messy.

00:41:13.030 --> 00:41:16.980
But these are just deterministic
constraint logic machines.

00:41:16.980 --> 00:41:22.000
You see this gadget yet
again to try various things.

00:41:22.000 --> 00:41:26.290
But in this case, if
input 1 comes at sometime

00:41:26.290 --> 00:41:33.000
before input 2, then it will
essentially-- so this comes up.

00:41:33.000 --> 00:41:35.090
The signal gets split out here.

00:41:35.090 --> 00:41:37.230
And so we send off
the acknowledgement.

00:41:37.230 --> 00:41:39.330
And then this edge
will, I think,

00:41:39.330 --> 00:41:42.530
just be flipping back and forth.

00:41:42.530 --> 00:41:45.050
So it's basically holding
the input for awhile.

00:41:45.050 --> 00:41:47.380
And later, the second
input could come in.

00:41:47.380 --> 00:41:49.550
And it will trigger
this to happen, and also

00:41:49.550 --> 00:41:51.925
trigger the output, and also
trigger the acknowledgement,

00:41:51.925 --> 00:41:54.150
cause it does all the things.

00:41:54.150 --> 00:41:59.370
So that is roughly
how that works.

00:41:59.370 --> 00:42:02.850
So I think the details are not
worth spending more time on.

00:42:02.850 --> 00:42:07.570
This is the final thing after
you have all the CNF logic come

00:42:07.570 --> 00:42:12.000
out, then this is how
you end up sending

00:42:12.000 --> 00:42:19.510
it to satisfy out to the
quantifiers, which are here.

00:42:19.510 --> 00:42:21.390
So it's a bit messy.

00:42:21.390 --> 00:42:23.360
But the main point
is that this works.

00:42:23.360 --> 00:42:27.010
And so hopefully we can use
deterministic constraint logic

00:42:27.010 --> 00:42:29.660
to prove lots of interesting
zero-player games are hard.

00:42:29.660 --> 00:42:31.910
We don't know very many
interesting zero-player games.

00:42:31.910 --> 00:42:34.860
So please help in finding them.

00:42:34.860 --> 00:42:37.010
There's one detail I'd
like to get rid of though.

00:42:37.010 --> 00:42:41.990
These degree 2 vertices, it
would be nicer to avoid those.

00:42:41.990 --> 00:42:47.100
So this is a bunch of reductions
to get rid of degree 2 vertices

00:42:47.100 --> 00:42:49.460
and keep things mod 4.

00:42:49.460 --> 00:42:52.150
So we're going to
take every edge

00:42:52.150 --> 00:42:55.510
and subdivide it into
a path of length 4,

00:42:55.510 --> 00:43:01.040
because then if we have two
red edges in the original graph

00:43:01.040 --> 00:43:05.010
together, instead of replacing
it by two red paths of length

00:43:05.010 --> 00:43:08.600
4, we're going to
replace it by two paths

00:43:08.600 --> 00:43:11.695
here, with the first
and last edge being red,

00:43:11.695 --> 00:43:13.740
but everything else being blue.

00:43:13.740 --> 00:43:16.880
The motivation
for that is now we

00:43:16.880 --> 00:43:21.440
just have blue, blue
edges and red, blue edges.

00:43:21.440 --> 00:43:22.850
No red, reds.

00:43:22.850 --> 00:43:26.380
To get a blue, blue, we just
add on a thing like this

00:43:26.380 --> 00:43:27.700
that's forced to be out.

00:43:27.700 --> 00:43:30.475
And this will be satisfied if
and only if one of these is in.

00:43:30.475 --> 00:43:33.060
So we've done that
kind of trick before.

00:43:33.060 --> 00:43:35.590
And red, blue edges, we've
explicitly done before.

00:43:35.590 --> 00:43:37.142
So we know how to
deal with those.

00:43:37.142 --> 00:43:38.850
And so we do all the
subdivision in order

00:43:38.850 --> 00:43:40.016
to get rid of the red, reds.

00:43:40.016 --> 00:43:43.710
Also where these guys have
a smaller weight constraint,

00:43:43.710 --> 00:43:45.680
just one of them has to be in.

00:43:45.680 --> 00:43:50.950
So now we have no
degree 2 vertices.

00:43:50.950 --> 00:43:53.420
The other thing is, we
have a non-planar graph.

00:43:53.420 --> 00:43:55.295
It would be nice to get
rid of the crossings.

00:43:55.295 --> 00:43:57.755
AUDIENCE: Don't you still
have a timing issue?

00:44:00.317 --> 00:44:02.650
PROFESSOR: This should preserve
the fact that everything

00:44:02.650 --> 00:44:05.750
happens at time 0 mod 4.

00:44:05.750 --> 00:44:08.050
So we'll slow everything
down by a factor of 4.

00:44:08.050 --> 00:44:10.710
But it shouldn't
be a timing issue.

00:44:10.710 --> 00:44:13.220
And because these
things are rigid,

00:44:13.220 --> 00:44:17.360
they don't have any timing.

00:44:17.360 --> 00:44:18.140
OK.

00:44:18.140 --> 00:44:19.860
So next we get rid of crossings.

00:44:19.860 --> 00:44:22.880
This actually is a
little easier for once.

00:44:22.880 --> 00:44:26.580
This was how we implemented
a red, red, red, red vertex

00:44:26.580 --> 00:44:29.050
in the crossover gadget for NCL.

00:44:29.050 --> 00:44:31.870
But here it's actually
enough as a crossover,

00:44:31.870 --> 00:44:36.765
because we have the luxury
of timing in some sense.

00:44:36.765 --> 00:44:38.390
There are a lot of
things that could've

00:44:38.390 --> 00:44:39.973
happened undeterministically
that just

00:44:39.973 --> 00:44:42.340
can't happen deterministically.

00:44:42.340 --> 00:44:43.060
So does it work?

00:44:43.060 --> 00:44:46.420
Here I pasted in the figure.

00:44:46.420 --> 00:44:48.980
You run it through and you check
that it works in both cases.

00:44:48.980 --> 00:44:51.460
If they don't activate at
the same time, then it works.

00:44:51.460 --> 00:44:53.918
Activated at the same time, I
don't know what would happen.

00:44:53.918 --> 00:44:57.940
But we can offset all the timing
so there are no collisions.

00:44:57.940 --> 00:44:59.950
And boom, we get crossovers.

00:44:59.950 --> 00:45:12.850
So the conclusion is
deterministic constraint logic

00:45:12.850 --> 00:45:31.330
is PSPACE complete for
a planar and OR graphs.

00:45:31.330 --> 00:45:35.640
I think I actually
want to also say split.

00:45:35.640 --> 00:45:39.020
So normally we think of AND
and OR as the same thing.

00:45:39.020 --> 00:45:47.350
But it is helpful to
distinguish them based

00:45:47.350 --> 00:45:48.600
on their initial orientations.

00:45:52.220 --> 00:45:56.715
An AND would
probably be this way.

00:45:56.715 --> 00:45:58.380
Because you want
to activate this,

00:45:58.380 --> 00:46:01.050
and you can only do that if both
of these have been activated.

00:46:01.050 --> 00:46:04.380
And so this is the output.

00:46:04.380 --> 00:46:05.870
For a split, this is the input.

00:46:05.870 --> 00:46:08.320
So it's initially not active.

00:46:08.320 --> 00:46:10.070
And then it wold look
something like that.

00:46:10.070 --> 00:46:12.028
So if you want to
distinguish between these two

00:46:12.028 --> 00:46:13.480
vertex-- sorry.

00:46:13.480 --> 00:46:16.770
This should be the other way.

00:46:16.770 --> 00:46:19.490
If you want to distinguish what
the initial orientations are,

00:46:19.490 --> 00:46:22.450
then you also need
to list split here.

00:46:22.450 --> 00:46:24.570
So up to you whether you
feel like doing that.

00:46:28.458 --> 00:46:29.430
OK.

00:46:29.430 --> 00:46:31.830
That's all I want to say
about zero-player games.

00:46:31.830 --> 00:46:33.280
Any questions?

00:46:33.280 --> 00:46:34.978
AUDIENCE: What should
happen in the end?

00:46:34.978 --> 00:46:36.690
Everything is--

00:46:36.690 --> 00:46:39.940
PROFESSOR: In the end, if you
satisfy the whole formula then

00:46:39.940 --> 00:46:45.310
you will get here,
this edge will reverse.

00:46:45.310 --> 00:46:48.430
And so the decision question
is, does this edge reverse?

00:46:48.430 --> 00:46:50.580
Either it will or it won't.

00:46:50.580 --> 00:46:53.430
In both cases, I think
the behavior's periodic.

00:46:53.430 --> 00:46:56.160
Because it's a funny thing.

00:46:56.160 --> 00:46:57.245
Yeah.

00:46:57.245 --> 00:46:59.120
AUDIENCE: So there were
two decision problems

00:46:59.120 --> 00:47:01.025
for nondeterministic
constraint logic.

00:47:01.025 --> 00:47:04.490
One of them was can you
reach this configuration.

00:47:04.490 --> 00:47:06.470
Another one was can
you fit this edge?

00:47:06.470 --> 00:47:08.165
Do you know anything about--

00:47:08.165 --> 00:47:08.790
PROFESSOR: Yes.

00:47:11.620 --> 00:47:12.120
OK.

00:47:12.120 --> 00:47:13.760
If you want to
solve configuration

00:47:13.760 --> 00:47:19.120
to configuration for DCL,
I think you can basically

00:47:19.120 --> 00:47:21.280
add some red edges here.

00:47:21.280 --> 00:47:24.200
So if this thing
activates-- well,

00:47:24.200 --> 00:47:26.720
you need to do a little bit
more of a construction here.

00:47:26.720 --> 00:47:29.094
But I want to
basically get an edge

00:47:29.094 --> 00:47:30.260
to start flipping over here.

00:47:30.260 --> 00:47:31.660
Whereas before it
was not flipping.

00:47:31.660 --> 00:47:33.201
I think you can get
an edge flipping,

00:47:33.201 --> 00:47:35.006
and then everything inverts.

00:47:35.006 --> 00:47:37.130
And then you will be in
the original configuration,

00:47:37.130 --> 00:47:38.200
except this guy
will be flipping.

00:47:38.200 --> 00:47:40.070
If you set your parity
right, then he'll

00:47:40.070 --> 00:47:42.800
be flipped in a state
where everything else is

00:47:42.800 --> 00:47:44.090
in its original state.

00:47:44.090 --> 00:47:45.561
So, pretty sure.

00:47:45.561 --> 00:47:47.060
I forget whether
that's in the book.

00:47:47.060 --> 00:47:50.540
But I think configuration to
configuration, also PSPACE

00:47:50.540 --> 00:47:53.250
complete for DCL.

00:47:53.250 --> 00:47:53.750
Good.

00:47:57.420 --> 00:48:02.560
So let's move on to
multiplayer games.

00:48:02.560 --> 00:48:10.440
First I'd like to reduce
to the two-player case.

00:48:13.440 --> 00:48:16.032
So there's a big difference
between one and two players.

00:48:16.032 --> 00:48:17.490
But there's not so
big a difference

00:48:17.490 --> 00:48:20.570
between two and three and
four and five and six players.

00:48:20.570 --> 00:48:22.760
At least the usual
decision problem

00:48:22.760 --> 00:48:28.185
is, does the first player
have a winning strategy.

00:48:33.020 --> 00:48:36.580
Can the first player
win, basically.

00:48:36.580 --> 00:48:40.280
Sometimes this is
called a forced win.

00:48:40.280 --> 00:48:42.940
If a player forces a win.

00:48:42.940 --> 00:48:45.490
If you think of it this way,
and all the other players

00:48:45.490 --> 00:48:47.160
are free agents,
then the worst case

00:48:47.160 --> 00:48:50.470
is when they all collude
to try to make you not win.

00:48:50.470 --> 00:48:53.010
So that would be the
opposite of a forced win.

00:48:53.010 --> 00:48:55.920
If it's not possible
for you to force a win,

00:48:55.920 --> 00:48:58.500
that means the players can
somehow work together in order

00:48:58.500 --> 00:48:59.710
to prevent you from winning.

00:48:59.710 --> 00:49:01.960
So in that sense, they are
all essentially one player.

00:49:01.960 --> 00:49:04.440
You can thinking of
them as one hive mind.

00:49:04.440 --> 00:49:06.280
Now in the mechanics
of the game, of course

00:49:06.280 --> 00:49:09.500
there are differences between
two players and three players,

00:49:09.500 --> 00:49:12.640
because they have more
power in some sense.

00:49:12.640 --> 00:49:15.330
They can do three things for
every time you do one thing.

00:49:15.330 --> 00:49:18.050
But at some level that is
just a two-player game again,

00:49:18.050 --> 00:49:20.690
where you are
relatively impoverished

00:49:20.690 --> 00:49:22.810
compared to your opponent.

00:49:22.810 --> 00:49:24.450
So the asymmetric,
but still two-player

00:49:24.450 --> 00:49:27.100
game from a
complexity standpoint.

00:49:27.100 --> 00:49:29.170
So we just need to think
about two-player games

00:49:29.170 --> 00:49:30.990
and their complexity.

00:49:30.990 --> 00:49:33.720
Later we'll add some variations
that make this not true.

00:49:33.720 --> 00:49:37.570
But in a perfect information
deterministic game,

00:49:37.570 --> 00:49:41.920
this is true, this
reduction is true.

00:49:41.920 --> 00:49:43.920
So for a two
players, we're going

00:49:43.920 --> 00:49:46.550
to have-- at least
for the duration

00:49:46.550 --> 00:49:48.220
of this lecture--
the two players will

00:49:48.220 --> 00:49:50.720
be called white and black.

00:49:50.720 --> 00:49:54.110
In Winning Ways for example,
they're called red and blue.

00:49:54.110 --> 00:49:56.130
But this is problematic
because we have

00:49:56.130 --> 00:49:57.370
red and blue edges already.

00:49:57.370 --> 00:50:03.680
And I want red, white edges and
blue, black edges and so on.

00:50:03.680 --> 00:50:08.090
So the players will be white and
black as in chess, checkers--

00:50:08.090 --> 00:50:08.760
not checkers.

00:50:08.760 --> 00:50:10.490
Go, whatever.

00:50:10.490 --> 00:50:13.710
But color renaming.

00:50:13.710 --> 00:50:15.810
OK.

00:50:15.810 --> 00:50:18.920
And I'm going to
focus today on games

00:50:18.920 --> 00:50:29.630
that have a polynomial number
of moves in any execution, which

00:50:29.630 --> 00:50:34.330
places the problem into PSPACE.

00:50:34.330 --> 00:50:37.420
So again, we're going to
aim for PSPACE completeness.

00:50:37.420 --> 00:50:40.340
It's PSPACE because you
can think of this question

00:50:40.340 --> 00:50:45.260
as being equivalent to, do I
have a move such that no matter

00:50:45.260 --> 00:50:48.570
how the opponent
responds to that move--

00:50:48.570 --> 00:50:50.340
so every move for
the opponent, which

00:50:50.340 --> 00:50:54.840
I will call response--
I have another move

00:50:54.840 --> 00:51:00.500
such that no matter what
the opponent does dot,

00:51:00.500 --> 00:51:02.920
dot, dot through the
polynomial number of moves.

00:51:02.920 --> 00:51:05.310
If there's only a
polynomial in many moves,

00:51:05.310 --> 00:51:08.580
then there's only a polynomial
number of quantifiers here.

00:51:08.580 --> 00:51:11.020
And then in the
formula I'm going

00:51:11.020 --> 00:51:13.550
to write whatever
the rules of the game

00:51:13.550 --> 00:51:17.980
are, and then AND it
together with I win.

00:51:21.160 --> 00:51:23.230
I think you believe
almost all games you

00:51:23.230 --> 00:51:28.060
can write as some Boolean
formula to do that.

00:51:28.060 --> 00:51:30.950
Some polynomial-sized Boolean
formula saying at each

00:51:30.950 --> 00:51:35.760
step you satisfy what you need.

00:51:35.760 --> 00:51:38.730
And so this is a QSAT problem.

00:51:43.680 --> 00:51:47.240
And therefore, any
two-player game

00:51:47.240 --> 00:51:50.185
where you can write moves and
responses succinctly and have

00:51:50.185 --> 00:51:53.380
a polynomial number
of moves is in PSPACE,

00:51:53.380 --> 00:51:56.771
because you can
reduce it to QSAT.

00:51:56.771 --> 00:51:57.270
OK.

00:51:57.270 --> 00:51:59.340
So that's why
PSPACE is the class

00:51:59.340 --> 00:52:02.340
we care about for
polynomially bounded games.

00:52:02.340 --> 00:52:06.210
So now we want to
prove hardness.

00:52:06.210 --> 00:52:08.520
And first I want to give
you some hard problems

00:52:08.520 --> 00:52:13.780
in this setting starting
with SAT-style games.

00:52:19.570 --> 00:52:23.045
This is from another paper
by Shaefer, same guy who

00:52:23.045 --> 00:52:26.870
did Shaefer Dichotomy Theorem.

00:52:26.870 --> 00:52:30.180
He also did some
nice stuff on games.

00:52:30.180 --> 00:52:40.220
So first game is just your
favorite flavor of QSAT.

00:52:40.220 --> 00:52:42.790
You can think of it as a game.

00:52:42.790 --> 00:52:46.420
Because QSAT is exactly of this
form, you can think of the game

00:52:46.420 --> 00:52:50.380
as-- in your first move you're
going to choose this variable.

00:52:50.380 --> 00:52:52.290
In your second
move, your opponent

00:52:52.290 --> 00:52:53.800
is going to choose
this variable.

00:52:53.800 --> 00:52:56.520
In the third move you
choose this variable.

00:52:56.520 --> 00:52:57.060
And so on.

00:52:57.060 --> 00:52:59.710
Because play alternates,
you are following

00:52:59.710 --> 00:53:04.050
exactly an alternating
quantifier kind of thing.

00:53:04.050 --> 00:53:08.690
And the goal of player one
is to satisfy this formula.

00:53:08.690 --> 00:53:11.647
The goal player two is to have
it not satisfied in the end.

00:53:11.647 --> 00:53:13.230
And so player one
will win if and only

00:53:13.230 --> 00:53:16.260
if this formula is true.

00:53:16.260 --> 00:53:18.600
So in the game, you think of
it as there are a sequence

00:53:18.600 --> 00:53:21.130
of variables-- x1, x2, x3.

00:53:21.130 --> 00:53:25.640
Play alternates between
assigning xi and xi plus 1.

00:53:25.640 --> 00:53:28.227
Player one's always
assigning the odd variables.

00:53:28.227 --> 00:53:30.310
Player two is always
assigning the even variables.

00:53:30.310 --> 00:53:32.530
And then if the
formula is satisfied,

00:53:32.530 --> 00:53:35.880
then player one wins.

00:53:35.880 --> 00:53:38.410
OK.

00:53:38.410 --> 00:53:46.880
So this is what you
might call the game

00:53:46.880 --> 00:53:56.100
version of a satisfiable formula
is that player one wins if

00:53:56.100 --> 00:53:59.040
and only if the formula
is satisfied in the end.

00:54:09.140 --> 00:54:10.870
But there's some
other goal conditions

00:54:10.870 --> 00:54:14.360
you might consider
that Schaefer defines.

00:54:14.360 --> 00:54:23.210
One is called Seek,
which is the first player

00:54:23.210 --> 00:54:32.980
to satisfy the formula wins.

00:54:32.980 --> 00:54:40.422
And so in general, if you're
choosing some variables,

00:54:40.422 --> 00:54:42.130
you have a set of
variables, some of them

00:54:42.130 --> 00:54:44.120
have been assigned 0 or 1.

00:54:44.120 --> 00:54:46.110
Some of them haven't
been assigned yet.

00:54:46.110 --> 00:54:47.550
So when I say
satisfy here, I mean

00:54:47.550 --> 00:54:54.370
that unassigned things are 0.

00:54:54.370 --> 00:54:58.885
So if you think of everything as
initially 0, whoever satisfies

00:54:58.885 --> 00:55:01.880
the formula first wins.

00:55:01.880 --> 00:55:06.370
Then the opposite
version is Void.

00:55:06.370 --> 00:55:10.132
So the first person to
satisfy the formula loses.

00:55:10.132 --> 00:55:11.625
So the formula starts false.

00:55:15.210 --> 00:55:17.760
And the first person to set
it to true loses the game.

00:55:17.760 --> 00:55:19.690
Other person wins.

00:55:19.690 --> 00:55:20.190
OK.

00:55:20.190 --> 00:55:25.860
So those are some rule
variations of the goal state.

00:55:25.860 --> 00:55:27.688
Now let me tell you
about the moves.

00:55:37.090 --> 00:55:45.020
So other than QSAT, we're going
to have two types of moves.

00:55:45.020 --> 00:55:46.630
One is impartial moves.

00:55:46.630 --> 00:55:51.350
Impartial means that both
players have the same moves.

00:55:51.350 --> 00:55:56.470
So an impartial move is
going to be whoever's playing

00:55:56.470 --> 00:56:00.937
sets an unassigned variable.

00:56:00.937 --> 00:56:02.520
So on all of these
games, you can only

00:56:02.520 --> 00:56:06.110
assign a variable once.

00:56:06.110 --> 00:56:07.680
If you can assign
it multiple times,

00:56:07.680 --> 00:56:09.471
then you're no longer
polynomially bounded,

00:56:09.471 --> 00:56:11.670
and you get x time completeness.

00:56:11.670 --> 00:56:13.890
But for the polynomially
bounded games,

00:56:13.890 --> 00:56:15.990
we're going to define
each variable can only

00:56:15.990 --> 00:56:16.830
be assigned once.

00:56:16.830 --> 00:56:19.420
And in a partial
game, any player

00:56:19.420 --> 00:56:22.260
can assign any variable
that's not yet assigned.

00:56:22.260 --> 00:56:22.760
OK.

00:56:22.760 --> 00:56:26.770
So whereas in QSAT, you
had a fixed ordering.

00:56:26.770 --> 00:56:30.020
First x1, then x2, then x3.

00:56:30.020 --> 00:56:38.240
An impartial game
version of SAT, players

00:56:38.240 --> 00:56:40.260
take turns setting
variables, any one they want.

00:56:40.260 --> 00:56:41.770
It's not yet assigned.

00:56:41.770 --> 00:56:45.330
And in the end, if the formula
is satisfied, player one wins.

00:56:45.330 --> 00:56:47.320
That would be impartial game.

00:56:47.320 --> 00:56:49.540
But I could also do impartial
seek, impartial void.

00:56:52.430 --> 00:56:55.360
And then by the way,
I made up these names.

00:56:55.360 --> 00:57:00.110
So they don't match
what Shaefer calls them.

00:57:00.110 --> 00:57:01.380
But these are more modern.

00:57:01.380 --> 00:57:04.430
These terms are in
Winning Ways, for example.

00:57:04.430 --> 00:57:05.450
Seek and Avoid he used.

00:57:05.450 --> 00:57:08.440
But the other ones I made up.

00:57:08.440 --> 00:57:09.250
OK.

00:57:09.250 --> 00:57:14.450
Partisan version is that
there are white variables

00:57:14.450 --> 00:57:17.110
and there are black variables.

00:57:17.110 --> 00:57:21.440
And the white player can
only set white variables,

00:57:21.440 --> 00:57:25.530
black player can only
set black variables.

00:57:25.530 --> 00:57:28.250
There's 50% of each.

00:57:28.250 --> 00:57:34.170
And so they balance if you
play all the way to the end,

00:57:34.170 --> 00:57:41.070
like in the game
version, then it's

00:57:41.070 --> 00:57:45.254
OK to have the white player play
any unsatisfied white variable

00:57:45.254 --> 00:57:46.420
and set it to true or false.

00:57:49.210 --> 00:57:51.260
I think that defines all
the games that I want.

00:57:51.260 --> 00:57:53.390
Now let me tell you which
combinations are PSPACE

00:57:53.390 --> 00:57:53.890
complete.

00:57:56.490 --> 00:57:59.090
A bunch of them.

00:57:59.090 --> 00:58:02.270
So impartial.

00:58:02.270 --> 00:58:04.000
In addition to this
characterization,

00:58:04.000 --> 00:58:07.180
there's also all the different
versions of SAT that we know.

00:58:07.180 --> 00:58:14.680
So we have impartial
game positive 11-SAT.

00:58:17.240 --> 00:58:18.840
So this is a version of CNF.

00:58:18.840 --> 00:58:21.070
Instead of 3-SAT, I have 11-SAT.

00:58:21.070 --> 00:58:23.760
There are no negative literals.

00:58:23.760 --> 00:58:25.860
And it's impartial.

00:58:25.860 --> 00:58:27.920
So anyone could
set any variable.

00:58:27.920 --> 00:58:29.730
And it's the game
version, so player one

00:58:29.730 --> 00:58:30.810
wants to set it true.

00:58:30.810 --> 00:58:33.452
Player two wants the
formula to be false.

00:58:33.452 --> 00:58:34.410
That's PSPACE complete.

00:58:37.020 --> 00:58:44.715
Also, if we do 11-DNF-SAT, so
a DNF formula with positive.

00:58:47.910 --> 00:58:49.430
This is also as hard.

00:58:49.430 --> 00:58:52.440
I mean, that essentially
corresponds to flipping

00:58:52.440 --> 00:58:53.342
all the quantifiers.

00:58:53.342 --> 00:58:54.925
So that doesn't make
a big difference.

00:58:58.430 --> 00:59:01.050
So this is cool because
positive SAT is usually

00:59:01.050 --> 00:59:04.150
pretty easy with all
existential quantifiers.

00:59:04.150 --> 00:59:06.656
With alternating
quantifiers, not so easy.

00:59:06.656 --> 00:59:07.612
Yeah.

00:59:07.612 --> 00:59:11.940
AUDIENCE: Is impartial game
positive 10-SAT [INAUDIBLE]?

00:59:11.940 --> 00:59:15.360
PROFESSOR: We don't
know the exact cutoff.

00:59:15.360 --> 00:59:18.740
There is a paper, I think,
proving six is enough.

00:59:18.740 --> 00:59:20.880
But the positive disappears.

00:59:20.880 --> 00:59:25.880
So I think that's an open
problem, how low you could go.

00:59:28.780 --> 00:59:31.300
It's hard to do the
usual kind of reductions

00:59:31.300 --> 00:59:35.680
from many occurrences
to fewer, because games

00:59:35.680 --> 00:59:40.530
are very sensitive about who's
playing win, timing, and so on.

00:59:40.530 --> 00:59:46.500
So next one is
partisan game CNF-SAT.

00:59:46.500 --> 00:59:47.800
Here we don't have positive.

00:59:47.800 --> 00:59:50.030
And we don't have the bound 11.

00:59:50.030 --> 00:59:52.840
But we changed
impartial to partisan.

00:59:52.840 --> 00:59:55.740
That still is hard.

00:59:55.740 --> 00:59:57.920
And next we have a
whole bunch of games

00:59:57.920 --> 01:00:02.480
that work both for impartial
and partisan moves.

01:00:10.400 --> 01:00:10.900
OK.

01:00:10.900 --> 01:00:17.300
So we have avoid
positive 2-DNF-SAT.

01:00:19.870 --> 01:00:25.945
We have seek positive 3-DNF-SAT.

01:00:29.250 --> 01:00:39.720
We have avoid positive CNF-SAT.

01:00:39.720 --> 01:00:41.305
And we have seek
positive CNF-SAT.

01:00:47.790 --> 01:00:50.182
So the main point is,
most combinations are

01:00:50.182 --> 01:00:51.390
hard for some version of SAT.

01:00:51.390 --> 01:00:55.450
And these are the tightest
ones that Shaefer could show.

01:00:55.450 --> 01:00:58.300
Doesn't necessarily
mean that they're tight.

01:00:58.300 --> 01:01:00.959
And there's no
dichotomy theorem here,

01:01:00.959 --> 01:01:03.000
so we don't know exactly
which problems are hard.

01:01:03.000 --> 01:01:05.300
But this is a ton of
games to start from.

01:01:05.300 --> 01:01:11.250
And in particular, we're going
to use at least one of them.

01:01:11.250 --> 01:01:11.900
OK.

01:01:11.900 --> 01:01:13.270
Let's maybe go over here.

01:01:25.740 --> 01:01:26.650
OK.

01:01:26.650 --> 01:01:32.690
A couple more problems
which are in Shaefer paper.

01:01:32.690 --> 01:01:36.350
One's called Kayles,
one is called Geography.

01:01:43.350 --> 01:01:45.980
Kayles is essentially
the two-player version

01:01:45.980 --> 01:01:47.960
of independent set.

01:01:47.960 --> 01:01:50.310
So there are a
couple of versions.

01:01:50.310 --> 01:01:57.795
There is node Kayles and
bipartite node Kayles.

01:02:01.361 --> 01:02:05.090
These are the traditional names.

01:02:05.090 --> 01:02:07.560
You could also think of
this is impartial Kayles

01:02:07.560 --> 01:02:10.720
and this as partisan Kayles.

01:02:10.720 --> 01:02:12.840
So here the moves
are all the same.

01:02:12.840 --> 01:02:14.730
The moves are here.

01:02:14.730 --> 01:02:17.530
Pick any vertex, add
to an independent set.

01:02:20.287 --> 01:02:20.870
That's a move.

01:02:20.870 --> 01:02:22.100
So players take turns adding.

01:02:22.100 --> 01:02:24.850
At all times, you
must add a vertex

01:02:24.850 --> 01:02:26.220
that keeps it independent set.

01:02:26.220 --> 01:02:27.636
So you're effectively
removing all

01:02:27.636 --> 01:02:29.610
of its neighbors and itself.

01:02:29.610 --> 01:02:31.410
Last player to move wins.

01:02:31.410 --> 01:02:34.190
You can't move, you lose.

01:02:34.190 --> 01:02:37.650
Bipartite node Kayles, you
have a bipartite graph.

01:02:37.650 --> 01:02:40.495
And one side you call white,
one side you call black.

01:02:40.495 --> 01:02:42.620
A white player can only
choose from the white side.

01:02:42.620 --> 01:02:45.010
A black player can only
choose from the black side.

01:02:45.010 --> 01:02:47.520
So these are both
PSPACE complete as well,

01:02:47.520 --> 01:02:49.060
via reductions from
these problems.

01:02:49.060 --> 01:02:53.430
But I don't have those
reductions with me.

01:02:53.430 --> 01:02:54.730
OK.

01:02:54.730 --> 01:02:57.270
So that's independent set.

01:02:57.270 --> 01:02:59.400
Geography is essentially
a two-player version

01:02:59.400 --> 01:03:00.900
of Longest Path.

01:03:00.900 --> 01:03:05.320
It's inspired by this
real-life game where

01:03:05.320 --> 01:03:07.190
one person names
a city or country

01:03:07.190 --> 01:03:09.030
or pick your favorite
class of objects.

01:03:09.030 --> 01:03:11.700
And then the other
player must name

01:03:11.700 --> 01:03:14.040
a word whose first letter
equals the last letter

01:03:14.040 --> 01:03:15.170
of the previous word.

01:03:15.170 --> 01:03:17.290
So you're forming
chains of words.

01:03:17.290 --> 01:03:19.680
And you can think of that
as just having a graph where

01:03:19.680 --> 01:03:21.420
vertices are the
words, the edges

01:03:21.420 --> 01:03:24.290
are valid moves between words.

01:03:24.290 --> 01:03:26.930
Do they have some
common property.

01:03:26.930 --> 01:03:29.520
So in general, you're
given a directed graph

01:03:29.520 --> 01:03:31.240
and you're given a start node.

01:03:31.240 --> 01:03:34.760
And you have a token
at that start node.

01:03:37.400 --> 01:03:39.140
A move in the game
is to follow an edge,

01:03:39.140 --> 01:03:42.190
to move the token along an edge.

01:03:42.190 --> 01:03:44.820
But then there's some
non-repetition condition.

01:03:44.820 --> 01:03:49.060
So we have node geography
where you're not

01:03:49.060 --> 01:03:50.350
allowed to repeat any notes.

01:03:50.350 --> 01:03:52.100
That would be the
usual longest path.

01:03:59.324 --> 01:04:00.990
And again, the last
player to move wins.

01:04:00.990 --> 01:04:03.440
If you can't make a move,
you lose the game, just

01:04:03.440 --> 01:04:05.490
like the real game.

01:04:05.490 --> 01:04:10.456
And on the other hand,
we have edge geography,

01:04:10.456 --> 01:04:12.080
which is more like
an [INAUDIBLE] path.

01:04:16.370 --> 01:04:18.690
The longest edge
destroying path.

01:04:18.690 --> 01:04:20.910
So edge geography you're
not allowed to repeat edges.

01:04:24.320 --> 01:04:26.820
And for each one, you could
think of a directed graph,

01:04:26.820 --> 01:04:29.760
you have to follow directed
edges or an undirected graph.

01:04:29.760 --> 01:04:37.620
And here undirected,
no geography is NP.

01:04:37.620 --> 01:04:40.430
Directed, no geography
if PSPACE complete.

01:04:45.410 --> 01:04:47.760
And for edge geography,
surprisingly, both

01:04:47.760 --> 01:04:48.700
are PSPACE complete.

01:04:52.890 --> 01:04:54.920
So this is a useful problem.

01:04:54.920 --> 01:04:57.370
I've seen a ton of PSPACE
completeness proofs

01:04:57.370 --> 01:04:58.730
based on geography.

01:04:58.730 --> 01:05:01.410
It's kind of conceptually clean.

01:05:01.410 --> 01:05:04.560
And I will show you one now.

01:05:04.560 --> 01:05:09.780
Everyone play Othello, Reversi.

01:05:09.780 --> 01:05:11.440
In general, you
have these pieces

01:05:11.440 --> 01:05:14.340
which are black on one
side, white on the other.

01:05:14.340 --> 01:05:16.310
The black side is
the one that you play

01:05:16.310 --> 01:05:18.000
if you're the black player.

01:05:18.000 --> 01:05:22.410
But then you can, for example,
if you place a new black stone

01:05:22.410 --> 01:05:24.760
here, given this
configuration, because there's

01:05:24.760 --> 01:05:27.420
a black string of whites
and then a black here,

01:05:27.420 --> 01:05:29.769
you end up flipping
that one over.

01:05:29.769 --> 01:05:31.810
Because this is black and
then a bunch of whites,

01:05:31.810 --> 01:05:34.340
or black and then a space,
nothing else happens.

01:05:34.340 --> 01:05:37.660
In this picture though, if
you place this black thing,

01:05:37.660 --> 01:05:40.160
this is black, a bunch of
whites, then black, black,

01:05:40.160 --> 01:05:42.430
bunch of whites, black,
black, bunch of whites, black.

01:05:42.430 --> 01:05:44.720
So all of those flip over.

01:05:44.720 --> 01:05:47.280
And your goal is to
maximize your color.

01:05:47.280 --> 01:05:51.520
You want more more stones of
your color than the opponent's.

01:05:51.520 --> 01:05:52.670
OK.

01:05:52.670 --> 01:05:53.604
Cool game.

01:05:53.604 --> 01:05:55.770
Bounded number of moves,
polynomial number of moves,

01:05:55.770 --> 01:05:58.840
because every time
you add a new stone,

01:05:58.840 --> 01:06:01.080
you've occupied one of
the squares on the board.

01:06:01.080 --> 01:06:03.240
And you'll never get that back.

01:06:03.240 --> 01:06:06.310
So n by n board would be
exactly n squared minus 4 moves,

01:06:06.310 --> 01:06:09.290
because four is the
original number.

01:06:09.290 --> 01:06:11.390
So this is PSPACE
complete, given

01:06:11.390 --> 01:06:13.980
a particular
configuration to decide

01:06:13.980 --> 01:06:16.410
whether black has a
winning strategy, say,

01:06:16.410 --> 01:06:18.570
is PSPACE complete.

01:06:18.570 --> 01:06:24.900
And most of the
construction is in here.

01:06:24.900 --> 01:06:27.180
This box is actually
this picture.

01:06:27.180 --> 01:06:30.310
And that's going to
simulate geography.

01:06:30.310 --> 01:06:32.450
But let me tell you
about this other part.

01:06:32.450 --> 01:06:34.470
So right now white has
a huge amount of area.

01:06:34.470 --> 01:06:35.730
This is actually really big.

01:06:35.730 --> 01:06:40.377
So I guess this is very thin,
so there's not much action here.

01:06:40.377 --> 01:06:42.210
Here you've got a huge
amount of white area.

01:06:42.210 --> 01:06:45.250
So white will win unless
black can take this part.

01:06:45.250 --> 01:06:48.210
And what happens is
there's a gap here.

01:06:48.210 --> 01:06:51.811
And if black can play
any of these spots,

01:06:51.811 --> 01:06:53.310
now black won't be
able to play here

01:06:53.310 --> 01:06:55.690
if there's some corresponding
black thing over here.

01:06:55.690 --> 01:06:59.520
So that's what these long
horizontal channels will be.

01:06:59.520 --> 01:07:01.730
So if black can play over
here, because there's

01:07:01.730 --> 01:07:05.510
a black stone and long
white channels here,

01:07:05.510 --> 01:07:08.390
then this will flip to black.

01:07:08.390 --> 01:07:10.850
And then in this
picture is this.

01:07:10.850 --> 01:07:16.670
So if one of these stones
up here is now black,

01:07:16.670 --> 01:07:20.160
that means you can
play at position alpha.

01:07:20.160 --> 01:07:22.680
And if I play at position
alpha, black plays there.

01:07:22.680 --> 01:07:25.290
Then I get black
all the way here.

01:07:25.290 --> 01:07:28.750
White can't really
respond much to that.

01:07:28.750 --> 01:07:30.690
And then in the next
black move, black

01:07:30.690 --> 01:07:32.840
can go here and flip that one.

01:07:32.840 --> 01:07:37.397
And then black can go
here in the corner.

01:07:37.397 --> 01:07:38.980
Corners are very
important in Othello.

01:07:38.980 --> 01:07:42.320
So once you take this corner
and flip all these things to be

01:07:42.320 --> 01:07:45.400
black, then I can play here,
here, here, here, here, here,

01:07:45.400 --> 01:07:47.280
here and take all of these.

01:07:47.280 --> 01:07:48.910
And because this
is the edge, white

01:07:48.910 --> 01:07:51.890
won't be able to
take anything back.

01:07:51.890 --> 01:07:53.679
So that's the threat.

01:07:53.679 --> 01:07:55.470
Each of these lines is
going to be a threat

01:07:55.470 --> 01:08:00.550
that if any of these
become black over here,

01:08:00.550 --> 01:08:02.280
white has to turn
them back to white.

01:08:02.280 --> 01:08:05.551
Otherwise, in the very next
move, black will win the game.

01:08:05.551 --> 01:08:06.050
OK.

01:08:06.550 --> 01:08:09.220
A lot of two-player game proofs
have this constant notion

01:08:09.220 --> 01:08:09.720
of threat.

01:08:09.720 --> 01:08:11.230
One player's basically
just slogging

01:08:11.230 --> 01:08:13.230
through trying to put out fires.

01:08:13.230 --> 01:08:14.650
And the other
player is constantly

01:08:14.650 --> 01:08:16.649
causing fires in order
to force the other player

01:08:16.649 --> 01:08:18.310
to do what they want.

01:08:18.310 --> 01:08:20.180
So it almost reduces
to a one-player game.

01:08:20.180 --> 01:08:22.109
But there's still
some choices involved.

01:08:25.946 --> 01:08:27.529
Well, these are not
terribly exciting.

01:08:27.529 --> 01:08:29.770
But let me show you
the typical setup.

01:08:29.770 --> 01:08:33.609
This is just a turn gadget, or
it could be a degree 2 vertex.

01:08:33.609 --> 01:08:36.270
I should mention we're
reducing from directed

01:08:36.270 --> 01:08:43.029
no geography, where this
is directed no geography.

01:08:43.029 --> 01:08:44.609
Also max degree 3.

01:08:51.160 --> 01:08:54.960
So that means you might
have a degree 2 vertex,

01:08:54.960 --> 01:08:56.520
or you might have
a degree 3 vertex.

01:08:56.520 --> 01:08:58.439
There are two types
of degree 3 directed

01:08:58.439 --> 01:09:05.850
vertices merging and branching.

01:09:05.850 --> 01:09:08.100
So we need gadgets
for each of these.

01:09:08.100 --> 01:09:09.840
Also, bipartite.

01:09:13.050 --> 01:09:16.060
Bipartite is useful
because in geography you're

01:09:16.060 --> 01:09:18.439
always moving along an edge,
which means you'll always

01:09:18.439 --> 01:09:20.439
be jumping from the left
side of the bipartition

01:09:20.439 --> 01:09:21.188
to the right side.

01:09:21.188 --> 01:09:23.029
So you can color the
edges black and white.

01:09:23.029 --> 01:09:24.920
And black player will only
play in the black side,

01:09:24.920 --> 01:09:27.109
and white player will only
play in the white side.

01:09:27.109 --> 01:09:27.775
So this is good.

01:09:27.775 --> 01:09:30.979
You can predict who's going
to be playing in each gadget.

01:09:30.979 --> 01:09:33.740
So in a degree 2 gadget, it
works something like this.

01:09:33.740 --> 01:09:35.600
If white has played
here, that will

01:09:35.600 --> 01:09:39.760
be because of the other gadget.

01:09:39.760 --> 01:09:40.896
This is the trigger.

01:09:40.896 --> 01:09:43.229
Then now this is black, a
bunch of whites, and now black

01:09:43.229 --> 01:09:45.914
can play here,
reversing all of these.

01:09:45.914 --> 01:09:46.830
This is a threat line.

01:09:46.830 --> 01:09:48.890
And there's now a
black square, which

01:09:48.890 --> 01:09:51.600
means white must
immediately play here

01:09:51.600 --> 01:09:54.520
in order to reverse all of
those stones back to white.

01:09:54.520 --> 01:09:58.180
But now this is a white stone,
which lets this thing trigger.

01:09:58.180 --> 01:10:01.400
So now black can play at the
end of this thing, et cetera.

01:10:01.400 --> 01:10:03.580
So this just propagates
a signal, does a turn.

01:10:03.580 --> 01:10:04.790
It's a degree 2 vertex.

01:10:04.790 --> 01:10:06.042
Whatever.

01:10:06.042 --> 01:10:06.750
All those things.

01:10:06.750 --> 01:10:08.333
And this is slightly
different version

01:10:08.333 --> 01:10:10.382
for a different orientation,
because these things

01:10:10.382 --> 01:10:11.340
have to go to the left.

01:10:11.340 --> 01:10:12.990
This looks a little different.

01:10:12.990 --> 01:10:13.490
OK.

01:10:13.490 --> 01:10:16.120
More interesting are
the degree 3 vertices.

01:10:16.120 --> 01:10:18.920
This is the type where I have
two incoming edges and one

01:10:18.920 --> 01:10:20.290
outgoing.

01:10:20.290 --> 01:10:23.730
Key thing here is we need to
check that we do not visit

01:10:23.730 --> 01:10:24.890
this vertex more than once.

01:10:24.890 --> 01:10:26.860
We came in here and
then came in again.

01:10:26.860 --> 01:10:28.760
We want something bad to happen.

01:10:28.760 --> 01:10:30.974
Now what should
happen bad depends on

01:10:30.974 --> 01:10:33.390
whether it was the white player
moving or the black player

01:10:33.390 --> 01:10:34.810
moving. if it was the
white player moving

01:10:34.810 --> 01:10:36.893
and they double visit, it
means white should lose.

01:10:36.893 --> 01:10:39.560
If it was the black player
moving, and they double visit,

01:10:39.560 --> 01:10:41.320
it means black should lose.

01:10:41.320 --> 01:10:45.349
Because of the bipartiteness,
we know which gadget to use.

01:10:45.349 --> 01:10:46.640
They're almost the same gadget.

01:10:46.640 --> 01:10:50.130
Just these two dots
have been added.

01:10:50.130 --> 01:10:55.870
So something like, if this
activates, and it's symmetric,

01:10:55.870 --> 01:10:59.460
but let's say this one
activates by white playing here,

01:10:59.460 --> 01:11:01.650
then black can play
here, flip all those,

01:11:01.650 --> 01:11:03.940
which has this threat
line, which means white

01:11:03.940 --> 01:11:04.720
must play here.

01:11:04.720 --> 01:11:06.280
Flip them all back to white.

01:11:06.280 --> 01:11:08.770
But now this B1
position is white,

01:11:08.770 --> 01:11:12.100
which enables black to play
here, flip all those to black.

01:11:12.100 --> 01:11:14.800
This is the threat line,
therefore white must play here.

01:11:14.800 --> 01:11:16.640
Can't play there.

01:11:16.640 --> 01:11:18.070
And turn all these
back to white.

01:11:18.070 --> 01:11:18.960
Now this is white.

01:11:18.960 --> 01:11:21.440
And now this
activates down there.

01:11:21.440 --> 01:11:23.400
So that's just
following the vertex.

01:11:23.400 --> 01:11:24.480
No big deal.

01:11:24.480 --> 01:11:26.920
But if you came
along a second time

01:11:26.920 --> 01:11:31.250
and activated this as white--
now this is already white.

01:11:31.250 --> 01:11:35.550
So when you play black,
you get a black here.

01:11:35.550 --> 01:11:38.320
And white can't do anything.

01:11:38.320 --> 01:11:41.250
There's no white stone up there.

01:11:41.250 --> 01:11:42.640
Yeah.

01:11:42.640 --> 01:11:44.580
Well it's entirely black.

01:11:44.580 --> 01:11:46.590
If there was a white
on either side,

01:11:46.590 --> 01:11:48.480
white could flip it
and get them back.

01:11:48.480 --> 01:11:49.520
But you can't.

01:11:49.520 --> 01:11:51.830
And so you actually have
two threat lines activated.

01:11:51.830 --> 01:11:52.990
And then black wins.

01:11:52.990 --> 01:11:55.780
So this is the version
where black wins.

01:11:55.780 --> 01:11:58.620
If instead, we have
a white thing here,

01:11:58.620 --> 01:11:59.920
everything else is the same.

01:11:59.920 --> 01:12:02.120
So this was white,
this was white.

01:12:02.120 --> 01:12:05.800
Black now plays here.

01:12:05.800 --> 01:12:07.900
Now white can go
here and completely

01:12:07.900 --> 01:12:09.850
make this thing
white, and then black

01:12:09.850 --> 01:12:11.142
doesn't have any moves anymore.

01:12:11.142 --> 01:12:12.974
And that's the way that
white's going to win

01:12:12.974 --> 01:12:14.910
is to prevent black
from playing anymore.

01:12:14.910 --> 01:12:19.600
Then the area that was white
is white, so we're done.

01:12:19.600 --> 01:12:21.310
There are lots of
details here to check,

01:12:21.310 --> 01:12:22.930
but that's how it works.

01:12:22.930 --> 01:12:25.090
There's one more
gadget basically

01:12:25.090 --> 01:12:32.680
that says this is for
one incoming edge and two

01:12:32.680 --> 01:12:34.260
outgoing edges.

01:12:34.260 --> 01:12:36.960
So here you want the
players to have a choice,

01:12:36.960 --> 01:12:38.726
either I go this way,
or I go this way.

01:12:38.726 --> 01:12:41.350
And if it's a white vertex, you
want white to make that choice.

01:12:41.350 --> 01:12:43.840
If it's a black vertex, you
want black to make that choice.

01:12:43.840 --> 01:12:45.840
But black is still kind
of doing all the action.

01:12:45.840 --> 01:12:48.470
So it can be done.

01:12:48.470 --> 01:12:52.200
When this activates,
then black plays here,

01:12:52.200 --> 01:12:54.560
flipping all these things.

01:12:54.560 --> 01:12:59.440
Then white plays here,
immediately flipping it back.

01:12:59.440 --> 01:13:01.680
That's the trouble, is
always black is in control.

01:13:01.680 --> 01:13:05.470
Now black plays here,
flipping that one guy.

01:13:05.470 --> 01:13:07.060
And white has two choices.

01:13:07.060 --> 01:13:09.890
It can either play here and
flip just this one, or play here

01:13:09.890 --> 01:13:11.660
and flip those guys.

01:13:11.660 --> 01:13:13.822
And either put a
white here or here,

01:13:13.822 --> 01:13:15.530
and that will end up
activating for black

01:13:15.530 --> 01:13:18.240
either this path, or this path.

01:13:18.240 --> 01:13:19.430
So white made the choice.

01:13:19.430 --> 01:13:21.263
And in this version,
black makes the choice.

01:13:21.263 --> 01:13:23.054
That's a little easier.

01:13:23.054 --> 01:13:23.890
Yeah.

01:13:23.890 --> 01:13:27.370
AUDIENCE: Are these
gadgets constructable?

01:13:27.370 --> 01:13:28.540
PROFESSOR: In an 8 by 8?

01:13:28.540 --> 01:13:29.530
AUDIENCE: No.

01:13:29.530 --> 01:13:31.520
Like from a starting
configuration.

01:13:31.520 --> 01:13:34.850
Can you get to a configuration
of these gadgets?

01:13:34.850 --> 01:13:37.140
PROFESSOR: Oh, I see.

01:13:37.140 --> 01:13:39.230
I think so.

01:13:39.230 --> 01:13:41.669
I didn't read that
as [INAUDIBLE],

01:13:41.669 --> 01:13:43.710
but it wouldn't surprise
me if it's in the paper.

01:13:43.710 --> 01:13:46.370
It's traditional in constructing
these generalized games

01:13:46.370 --> 01:13:49.190
to actually show that you
can reach this position

01:13:49.190 --> 01:13:51.230
from the initial state.

01:13:51.230 --> 01:13:54.160
Although the problem makes
sense even if you can't.

01:13:54.160 --> 01:13:56.590
It's more interesting to say,
well we played like crazy.

01:13:56.590 --> 01:13:58.280
And then we ended
up with this thing.

01:13:58.280 --> 01:14:00.240
Can you finish it off for me?

01:14:00.240 --> 01:14:04.140
That's basically the
problem we'd like to solve.

01:14:04.140 --> 01:14:05.174
Can white win?

01:14:05.174 --> 01:14:06.590
It's like the
commentator problem.

01:14:06.590 --> 01:14:07.381
People are playing.

01:14:07.381 --> 01:14:10.860
And now I want to know who's
going to win at this point.

01:14:10.860 --> 01:14:12.890
But I don't know for
sure for this reduction.

01:14:12.890 --> 01:14:14.200
Usually they can.

01:14:14.200 --> 01:14:14.700
OK.

01:14:14.700 --> 01:14:17.980
So that's a sketch of
Othello PSPACE hardness

01:14:17.980 --> 01:14:19.045
reduction from geography.

01:14:21.870 --> 01:14:26.560
So the last thing I want to talk
about, back to this picture,

01:14:26.560 --> 01:14:33.270
is the two-player setup
for constraint logic.

01:14:33.270 --> 01:14:36.530
So polynomially
bounded, two-player game

01:14:36.530 --> 01:14:39.230
should be PSPACE complete.

01:14:39.230 --> 01:14:40.980
First I'm going to
talk briefly about what

01:14:40.980 --> 01:14:43.220
does bounded mean in general
for constraint logic.

01:14:43.220 --> 01:14:45.830
So in particular, for
one player which we know,

01:14:45.830 --> 01:14:51.840
the bounded NCL means each
edge can flip only once.

01:14:51.840 --> 01:14:53.037
That's our definition.

01:14:53.037 --> 01:14:55.120
And that game is clearly
in NP, cause one you flip

01:14:55.120 --> 01:14:57.210
all the edges, you're done.

01:14:57.210 --> 01:14:59.340
And in the same way,
we prove that just

01:14:59.340 --> 01:15:01.950
finding and satisfying
orientation of a constraint

01:15:01.950 --> 01:15:05.380
graph is NP
complete, we can show

01:15:05.380 --> 01:15:11.120
just I changed the very top
gadget, that bounded NCL,

01:15:11.120 --> 01:15:13.950
you just want to flip this
one edge is NP complete.

01:15:13.950 --> 01:15:15.480
Because you basically
have to make

01:15:15.480 --> 01:15:17.270
a choice for each
of these vertices,

01:15:17.270 --> 01:15:18.470
which way to set them.

01:15:18.470 --> 01:15:19.900
And then you can propagate up.

01:15:19.900 --> 01:15:22.860
We don't have to flip any edges
for this very simple proof.

01:15:22.860 --> 01:15:27.010
So NP completeness
for a bounded NCL.

01:15:27.010 --> 01:15:30.560
We do for this proof
need a choice gadget.

01:15:30.560 --> 01:15:32.590
So all three red edges.

01:15:32.590 --> 01:15:34.040
It doesn't work
to just blow it up

01:15:34.040 --> 01:15:37.450
like we could before
in the bounded case.

01:15:37.450 --> 01:15:38.429
OK.

01:15:38.429 --> 01:15:40.720
And there's a crossover gadget
in this setting as well.

01:15:40.720 --> 01:15:43.060
It's actually pretty
simple because a bounded

01:15:43.060 --> 01:15:45.150
you can't revisit.

01:15:45.150 --> 01:15:45.650
OK.

01:15:45.650 --> 01:15:49.805
So now bounded two-player
constraint logic is called 2CL.

01:15:49.805 --> 01:15:54.280
This is PSPACE complete by
pretty much the same proof

01:15:54.280 --> 01:15:55.500
structure.

01:15:55.500 --> 01:15:56.760
So what's the game?

01:15:56.760 --> 01:15:58.510
I have white edges
and black edges.

01:15:58.510 --> 01:16:02.860
Each edge is white or black,
and it's also red or blue.

01:16:02.860 --> 01:16:03.870
Exclusive ORs.

01:16:03.870 --> 01:16:06.352
So they're drawn as--
these are all white edges.

01:16:06.352 --> 01:16:07.810
This is an example
of a black edge.

01:16:07.810 --> 01:16:10.980
So the fill is white or black,
the outline is red or blue,

01:16:10.980 --> 01:16:12.664
as before.

01:16:12.664 --> 01:16:14.330
White players can
only flip white edges,

01:16:14.330 --> 01:16:17.440
black players can
only flip black edges.

01:16:17.440 --> 01:16:19.530
And otherwise it's
the same constraints.

01:16:19.530 --> 01:16:21.460
I mean, the inflow
constraint doesn't care

01:16:21.460 --> 01:16:23.900
whether you're black or white.

01:16:23.900 --> 01:16:28.520
It's politically correct
vertices, I guess.

01:16:28.520 --> 01:16:32.190
So we just need one
new type of vertex.

01:16:32.190 --> 01:16:35.179
Everything else is going to
be done by the white player.

01:16:35.179 --> 01:16:36.720
There's one new type
or vertex, which

01:16:36.720 --> 01:16:39.460
is an incoming black edge
and an incoming white edge.

01:16:39.460 --> 01:16:40.750
Call this a variable.

01:16:40.750 --> 01:16:43.540
The idea is that wherever gets
there first, white or black

01:16:43.540 --> 01:16:45.860
can flip it, preventing
the other player

01:16:45.860 --> 01:16:47.387
from flipping their edge.

01:16:47.387 --> 01:16:49.720
So that's what we're going
to use for variable settings.

01:16:49.720 --> 01:16:56.000
And I'm reducing from--
remember the terminology here--

01:16:56.000 --> 01:16:59.850
impartial game positive CNF-SAT.

01:16:59.850 --> 01:17:01.320
The very first one here.

01:17:01.320 --> 01:17:03.480
Impartial game positive CNF-SAT.

01:17:03.480 --> 01:17:07.460
So player one's goal--
white is the player one.

01:17:07.460 --> 01:17:09.510
Player one's goal is
to satisfy the formula

01:17:09.510 --> 01:17:11.710
and flip their edge.

01:17:11.710 --> 01:17:16.040
And it's the impartial
version, meaning anyone

01:17:16.040 --> 01:17:17.560
can set any variable.

01:17:17.560 --> 01:17:19.900
So if black plays
this edge, that's

01:17:19.900 --> 01:17:22.030
going to correspond
to setting x2 false.

01:17:22.030 --> 01:17:23.890
If white plays the
edge, it's going

01:17:23.890 --> 01:17:25.670
to correspond to x being true.

01:17:25.670 --> 01:17:27.740
Because this is a
positive formula,

01:17:27.740 --> 01:17:29.340
every time white
choose a variable,

01:17:29.340 --> 01:17:30.910
they're gonna want
to set it to true.

01:17:30.910 --> 01:17:32.340
And every time black
sets a variable,

01:17:32.340 --> 01:17:33.420
they're going to
set it to false,

01:17:33.420 --> 01:17:36.060
because they want to prevent
satisfaction of the formula.

01:17:36.060 --> 01:17:38.560
So that's why it's OK to
just represent it this way.

01:17:38.560 --> 01:17:41.330
And then the rest
just propagates.

01:17:41.330 --> 01:17:42.940
So if there are n
variables, there's

01:17:42.940 --> 01:17:45.620
going to be n over 2 rounds
where all the variables get

01:17:45.620 --> 01:17:46.470
set.

01:17:46.470 --> 01:17:48.600
And then black can't
do anything else.

01:17:48.600 --> 01:17:49.525
Just sitting there.

01:17:49.525 --> 01:17:51.400
This one is not going
to be flippable because

01:17:51.400 --> 01:17:53.680
of this gadget.

01:17:53.680 --> 01:17:57.070
So white's just going
to fill in the formula.

01:17:57.070 --> 01:17:59.060
And if it happens
to be come out true,

01:17:59.060 --> 01:18:01.420
and white can flip their
edge, then they win the game.

01:18:01.420 --> 01:18:04.590
And that will correspond
to the formula being true.

01:18:04.590 --> 01:18:06.464
And otherwise, not.

01:18:06.464 --> 01:18:07.362
Yeah.

01:18:07.362 --> 01:18:09.028
AUDIENCE: So is pass
in that you can do?

01:18:09.028 --> 01:18:10.360
Or they're just like--

01:18:10.360 --> 01:18:13.820
PROFESSOR: In this
game you can pass.

01:18:13.820 --> 01:18:15.510
I think you could
probably avoid that

01:18:15.510 --> 01:18:19.100
by just adding a bunch
of floating black edges

01:18:19.100 --> 01:18:23.950
that you can flip, or just
flip repeatedly until white

01:18:23.950 --> 01:18:25.934
either wins, or
white doesn't win.

01:18:25.934 --> 01:18:27.600
The decision question
is does white win?

01:18:27.600 --> 01:18:31.940
Now we end up with a tie in
the case white doesn't win.

01:18:31.940 --> 01:18:34.670
You can also change that by
having a long path of blacks.

01:18:34.670 --> 01:18:37.330
And black is going to sit
there flipping, trying

01:18:37.330 --> 01:18:38.580
to get to flipping their edge.

01:18:38.580 --> 01:18:40.860
And the length of the
wire is exactly how long

01:18:40.860 --> 01:18:42.810
it takes to fill in
all these things.

01:18:42.810 --> 01:18:44.724
Yeah.

01:18:44.724 --> 01:18:46.890
AUDIENCE: The reason why
they have that gadget there

01:18:46.890 --> 01:18:48.990
at the end is you
need to set exactly

01:18:48.990 --> 01:18:51.670
a certain number of them true?

01:18:51.670 --> 01:18:54.797
Before black can, and so--

01:18:54.797 --> 01:18:55.380
PROFESSOR: Oh.

01:18:55.380 --> 01:18:55.880
I see.

01:18:55.880 --> 01:18:57.090
Right.

01:18:57.090 --> 01:18:57.834
Yeah.

01:18:57.834 --> 01:18:59.000
That's a little more subtle.

01:19:01.050 --> 01:19:03.312
OK.

01:19:03.312 --> 01:19:04.270
Zero minutes remaining.

01:19:08.300 --> 01:19:11.220
The same crossover works.

01:19:11.220 --> 01:19:14.310
And you can also
build a protected OR.

01:19:14.310 --> 01:19:17.830
Protected OR is where you never
have both of these coming in.

01:19:17.830 --> 01:19:20.040
If you allow me the
notion of a free edge,

01:19:20.040 --> 01:19:22.414
which is just floating there
and can be reversed whenever

01:19:22.414 --> 01:19:26.890
you want, this is a white edge,
then this will act as a OR,

01:19:26.890 --> 01:19:30.064
because this choice gadget can
only go one way or the other.

01:19:30.064 --> 01:19:31.730
It's only one of the
inputs can actually

01:19:31.730 --> 01:19:36.000
flip one of these edges, and
then the OR will just take it.

01:19:36.000 --> 01:19:38.690
So we can build predicted ORs.

01:19:38.690 --> 01:19:44.320
And then I have a bunch
of PSPACE hardness proofs

01:19:44.320 --> 01:19:46.410
based on bounded
constraint logic,

01:19:46.410 --> 01:19:49.020
but I suggest we wait
til Thursday to see this.

01:19:49.020 --> 01:19:50.350
Because they're kind of fun.

01:19:50.350 --> 01:19:52.860
And I'd rather spend a little
time going through the proof

01:19:52.860 --> 01:19:54.150
details.

01:19:54.150 --> 01:19:58.200
So you'll have to
wait in suspense

01:19:58.200 --> 01:20:00.982
before we get to
Amazons, which is

01:20:00.982 --> 01:20:02.940
a very fun-- you should
play Amazons meanwhile,

01:20:02.940 --> 01:20:04.115
if you get a chance.

01:20:04.115 --> 01:20:06.870
It's very fun if you
have a chessboard around.

01:20:06.870 --> 01:20:14.140
And Konane, which is an ancient,
at least 300-year-old game

01:20:14.140 --> 01:20:20.554
from Hawaii, and Cross Purposes,
which is a modern game.

01:20:20.554 --> 01:20:22.470
These are all three
bounded two- player games.

01:20:22.470 --> 01:20:24.680
And they're all PSPACE
complete by a reduction

01:20:24.680 --> 01:20:28.910
from bounded two-player
constraint logic.

01:20:31.610 --> 01:20:33.160
Cool.