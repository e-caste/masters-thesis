WEBVTT

00:00:00.080 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.810
Commons license.

00:00:03.810 --> 00:00:06.060
Your support will help
MIT OpenCourseWare

00:00:06.060 --> 00:00:10.150
continue to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.330
at ocw.mit.edu.

00:00:25.955 --> 00:00:26.830
PROFESSOR: All right.

00:00:26.830 --> 00:00:30.660
So today we finish our
game characterization.

00:00:30.660 --> 00:00:32.310
We have this giant table.

00:00:32.310 --> 00:00:37.020
We've done two players, zero
players, one player, of course.

00:00:37.020 --> 00:00:38.260
That's the oldest.

00:00:38.260 --> 00:00:41.110
Today we're going to do
team imperfect information

00:00:41.110 --> 00:00:43.870
games, which when you
have a polynomial bound

00:00:43.870 --> 00:00:46.340
on the number of moves,
you get NEXPTIME--

00:00:46.340 --> 00:00:48.240
nondeterministic
exponential time.

00:00:48.240 --> 00:00:50.730
This is the exponential
version of NP.

00:00:50.730 --> 00:00:54.535
And for games with unbounded
number of moves-- normally,

00:00:54.535 --> 00:00:56.660
I would say exponentially
many moves, but, in fact,

00:00:56.660 --> 00:00:58.680
this will be really
unbounded, could

00:00:58.680 --> 00:01:03.550
be close to infinitely many
moves-- we get Undecidability,

00:01:03.550 --> 00:01:05.810
so no algorithm,
whatsoever, to solve it.

00:01:05.810 --> 00:01:09.140
We don't know any natural
games in these classes.

00:01:09.140 --> 00:01:10.990
But I have a couple of
question marks here.

00:01:10.990 --> 00:01:14.670
Bridge is an example of a game
with imperfect information

00:01:14.670 --> 00:01:17.390
and teams in one hand.

00:01:17.390 --> 00:01:18.560
And it has bounded play.

00:01:18.560 --> 00:01:20.940
Once you play your cards--
all of the cards are down--

00:01:20.940 --> 00:01:21.700
you're done.

00:01:21.700 --> 00:01:23.950
So potentially, it
falls in this class.

00:01:23.950 --> 00:01:26.340
Although, I don't know if
Bridge is sophisticated enough

00:01:26.340 --> 00:01:30.280
or-- it depends on your
notion of the bidding rules

00:01:30.280 --> 00:01:32.800
and what can be
communicated there.

00:01:32.800 --> 00:01:35.830
On the other hand, for
the unbounded game,

00:01:35.830 --> 00:01:38.630
one candidate problem is
called Rengo Kriegspiel.

00:01:38.630 --> 00:01:40.720
Kriegspiel is blind chess.

00:01:40.720 --> 00:01:44.040
Rengo Kriegspiel is
blind Go with teams.

00:01:44.040 --> 00:01:46.400
So there are two black
players, two white players.

00:01:46.400 --> 00:01:48.401
And you make moves
without knowing

00:01:48.401 --> 00:01:50.400
what the other moves of
any of the other players

00:01:50.400 --> 00:01:52.191
are, usually by writing
on a piece of paper

00:01:52.191 --> 00:01:54.230
and giving it to some
referee who tells you

00:01:54.230 --> 00:01:57.390
whether that was valid.

00:01:57.390 --> 00:01:59.990
This is a game
people actually play.

00:01:59.990 --> 00:02:02.770
And I'm told-- I know
Bob Hearn has played it.

00:02:02.770 --> 00:02:05.790
He likes playing Go.

00:02:05.790 --> 00:02:08.919
But it's open, whether that
problem is Undecidable.

00:02:08.919 --> 00:02:10.789
Potentially, yes.

00:02:10.789 --> 00:02:13.080
That seems more likely.

00:02:13.080 --> 00:02:15.710
And then finally, one other
cell that we didn't do,

00:02:15.710 --> 00:02:17.300
which I'll get to
after those two,

00:02:17.300 --> 00:02:22.520
is this box, which sounds
pretty boring because it's just

00:02:22.520 --> 00:02:26.740
polynomial time things--
polynomial bounded zero player

00:02:26.740 --> 00:02:27.250
games.

00:02:27.250 --> 00:02:30.290
It's just like Game of Life
running for a polynomial amount

00:02:30.290 --> 00:02:31.050
of time.

00:02:31.050 --> 00:02:34.640
You can generate-- I mean,
you can solve those problems

00:02:34.640 --> 00:02:35.476
in polynomial time.

00:02:35.476 --> 00:02:37.850
But there's a stronger sense
in which all polynomial time

00:02:37.850 --> 00:02:40.730
problems can be represented,
say, by Game of Life.

00:02:40.730 --> 00:02:43.720
And this, actually, is
relevant to parallel computing.

00:02:43.720 --> 00:02:46.350
And it essentially says,
there's no good way

00:02:46.350 --> 00:02:49.870
to parallelize Game of
Life, among other problems.

00:02:49.870 --> 00:02:52.061
So I mentioned that way
back in lecture one.

00:02:52.061 --> 00:02:53.560
And a lot of people
said, oh, what's

00:02:53.560 --> 00:02:55.020
this P-completeness business?

00:02:55.020 --> 00:02:57.850
And so today we will
cover that, as well.

00:02:57.850 --> 00:03:02.990
But let's start with
NEXPTIME and Undecidability.

00:03:02.990 --> 00:03:04.790
Let's start with a bounded case.

00:03:13.070 --> 00:03:16.220
So in the bounded case,
there's this cool paper

00:03:16.220 --> 00:03:18.680
by Peterson and
Reif, introducing

00:03:18.680 --> 00:03:21.960
a problem variation of QSAT.

00:03:27.190 --> 00:03:29.660
Remember, QSAT,
also known as QBF.

00:03:29.660 --> 00:03:30.810
So this is DQBF.

00:03:33.580 --> 00:03:36.660
And it's a funny problem.

00:03:36.660 --> 00:03:40.020
First, I'll phrase it
as a formula problem.

00:03:40.020 --> 00:03:42.120
And then I'll talk
about it as a game.

00:03:58.630 --> 00:04:03.210
So normally, in QSAT QBF, we
have N alternating quantifiers.

00:04:03.210 --> 00:04:04.910
And that's PSACE complete.

00:04:04.910 --> 00:04:09.330
And every quantifier can depend
on all of the previous values.

00:04:09.330 --> 00:04:10.900
But now we're going
to have two sort

00:04:10.900 --> 00:04:13.470
of in parallel
existential quantifiers.

00:04:13.470 --> 00:04:16.171
So we have two universal--
I should mention the capital

00:04:16.171 --> 00:04:16.670
letters.

00:04:16.670 --> 00:04:17.836
That's a bunch of variables.

00:04:17.836 --> 00:04:21.000
So there's like N bits
here, N bits here that

00:04:21.000 --> 00:04:23.256
has to work for all
choices of those.

00:04:23.256 --> 00:04:24.380
Why do I separate them out?

00:04:24.380 --> 00:04:26.710
Because over here, I'm
going to separate them out.

00:04:26.710 --> 00:04:30.670
And Y1-- the choice of Y1 is
only allowed to depend on X1.

00:04:30.670 --> 00:04:35.029
And the choice of Y2 is only
allowed to depend on X2.

00:04:35.029 --> 00:04:36.570
And then we're going
to have some CNF

00:04:36.570 --> 00:04:38.990
formula on the X1, X2, Y1, Y2.

00:04:47.140 --> 00:04:52.480
So we can think of that
as this is one player.

00:04:52.480 --> 00:04:53.480
It could be two players.

00:04:53.480 --> 00:04:56.100
But it doesn't really matter.

00:04:56.100 --> 00:04:57.770
So make it one-- simpler.

00:04:57.770 --> 00:04:59.380
It's going to be a
three player game.

00:04:59.380 --> 00:05:02.300
Black makes these choices.

00:05:02.300 --> 00:05:09.400
And then white player
1 chooses the Y1s.

00:05:09.400 --> 00:05:12.610
And the private information
aspect of this game

00:05:12.610 --> 00:05:16.420
is that the white player one
can only see the X1 variables--

00:05:16.420 --> 00:05:18.904
choices made by black.

00:05:18.904 --> 00:05:20.320
Maybe it's more
intuitive to think

00:05:20.320 --> 00:05:21.570
of this as a four player game.

00:05:21.570 --> 00:05:22.780
There are two black players.

00:05:22.780 --> 00:05:25.270
And the white 1 player
can see the values chosen

00:05:25.270 --> 00:05:27.210
by the black 1 player
but not the values

00:05:27.210 --> 00:05:28.980
chosen by the black 2 player.

00:05:28.980 --> 00:05:33.860
And then, over here, we have
white player two, who can only

00:05:33.860 --> 00:05:36.570
see the variables chosen-- X2.

00:05:36.570 --> 00:05:37.070
Question?

00:05:37.070 --> 00:05:39.319
AUDIENCE: Does the black
team have full information?

00:05:39.319 --> 00:05:41.110
PROFESSOR: Black team
has full information.

00:05:41.110 --> 00:05:42.526
I mean, the black
team goes first.

00:05:42.526 --> 00:05:44.514
So it doesn't,
obviously, see Y1 and Y2.

00:05:44.514 --> 00:05:45.680
But they can see each other.

00:05:45.680 --> 00:05:46.180
Yeah.

00:05:46.180 --> 00:05:48.926
So X2 can see X1.

00:05:48.926 --> 00:05:49.830
Yeah.

00:05:49.830 --> 00:05:52.690
So if I don't write a
parenthetical dependency,

00:05:52.690 --> 00:05:55.630
then it can depend
on everything.

00:05:55.630 --> 00:05:56.130
Yeah.

00:05:56.130 --> 00:05:57.320
Really, this is one player.

00:05:57.320 --> 00:06:01.111
So they get to choose
everything in the X [INAUDIBLE].

00:06:01.111 --> 00:06:01.610
OK?

00:06:01.610 --> 00:06:03.460
So then the question
is given this--

00:06:03.460 --> 00:06:08.580
I mean, this quantified
formula's equivalent to saying,

00:06:08.580 --> 00:06:16.790
can white force a
win, where white wins

00:06:16.790 --> 00:06:19.170
if that formula is satisfied?

00:06:19.170 --> 00:06:21.830
And white collectively
needs to make these choices.

00:06:21.830 --> 00:06:24.300
But it's acting as a team
with impartial information.

00:06:24.300 --> 00:06:26.010
So it's not acting
as a single player

00:06:26.010 --> 00:06:29.150
anymore, unlike when we
had full information.

00:06:29.150 --> 00:06:32.590
Then three players
was the same as two.

00:06:32.590 --> 00:06:33.380
OK?

00:06:33.380 --> 00:06:37.210
So let's first observe
that this is in NEXPTIME.

00:06:37.210 --> 00:06:39.720
And then, furthermore, the
claim, which I won't prove,

00:06:39.720 --> 00:06:43.820
is that this is
NEXPTIME complete.

00:06:43.820 --> 00:06:48.410
So the idea is there are only
exponentially many choices

00:06:48.410 --> 00:06:50.240
for these variables.

00:06:50.240 --> 00:06:54.210
So then I can guess--
both player 1 and player 2

00:06:54.210 --> 00:06:56.980
can guess what--
white 1 and white 2

00:06:56.980 --> 00:07:00.970
can guess what the possibilities
are for all possible choices

00:07:00.970 --> 00:07:02.090
of X1 and X2.

00:07:02.090 --> 00:07:04.690
So they're making
exponentially many guesses.

00:07:04.690 --> 00:07:09.290
For every state of X1, X2, guess
what the right strategy is.

00:07:09.290 --> 00:07:14.290
And then just combine--
then check whether everyone

00:07:14.290 --> 00:07:16.070
plays properly.

00:07:16.070 --> 00:07:18.100
So then white can decide
whether they can win.

00:07:22.280 --> 00:07:23.255
That's cool.

00:07:26.700 --> 00:07:31.550
This can be reduced to a bounded
team, private information

00:07:31.550 --> 00:07:34.920
version of constraint
logic-- TPCL.

00:07:34.920 --> 00:07:37.050
Let me define that.

00:07:46.150 --> 00:07:53.160
We're going to do this
with three players

00:07:53.160 --> 00:07:54.650
And a plane or a graph.

00:07:58.070 --> 00:08:01.110
I think just and/or
graph is enough.

00:08:01.110 --> 00:08:03.301
But it's a team.

00:08:03.301 --> 00:08:05.300
There are going to be,
again, two white players,

00:08:05.300 --> 00:08:06.950
one black player.

00:08:06.950 --> 00:08:09.680
And it's private
information, meaning

00:08:09.680 --> 00:08:13.430
that each edge is marked
as visible to white

00:08:13.430 --> 00:08:14.620
or visible to black.

00:08:14.620 --> 00:08:16.710
Now, the figures-- it's
a little hard to draw.

00:08:16.710 --> 00:08:18.430
So the figures--
the color is just

00:08:18.430 --> 00:08:21.430
indicating whether that player
is allowed to flip that edge.

00:08:21.430 --> 00:08:23.972
Each player can only flip--
each white player can only

00:08:23.972 --> 00:08:24.680
flip white edges.

00:08:24.680 --> 00:08:27.880
Black player can only flip
black edges, just like before.

00:08:27.880 --> 00:08:30.080
Well, now it's
white team can only

00:08:30.080 --> 00:08:31.950
flip-- either of
the white players

00:08:31.950 --> 00:08:34.500
can only flip a white edge.

00:08:34.500 --> 00:08:38.620
So some edges are
flippable by two players.

00:08:38.620 --> 00:08:40.890
But then, in addition, some
edges-- some white edges

00:08:40.890 --> 00:08:42.880
are going to be marked
as invisible to black.

00:08:42.880 --> 00:08:44.230
And some black edges
are going to be

00:08:44.230 --> 00:08:45.438
marked as invisible to white.

00:08:45.438 --> 00:08:47.960
And furthermore, you can say
invisible to this white player

00:08:47.960 --> 00:08:49.880
or this white player.

00:08:49.880 --> 00:08:50.380
OK?

00:08:50.380 --> 00:08:52.260
So it's a little
bit more general.

00:08:52.260 --> 00:08:54.630
And the rules of the
game are pretty simple.

00:08:54.630 --> 00:08:56.720
You can make moves
just like before.

00:08:56.720 --> 00:09:02.350
But you must be able to know
that that move is legal.

00:09:07.660 --> 00:09:09.630
So unlike Rengo
Kriegspiel, you're

00:09:09.630 --> 00:09:12.385
not allowed to make
impossible moves.

00:09:15.920 --> 00:09:20.080
You must know, based on the
information that you can see,

00:09:20.080 --> 00:09:22.794
that the movie is valid.

00:09:22.794 --> 00:09:24.710
There are probably other
variations that work.

00:09:24.710 --> 00:09:27.320
But this is a clean
one to work with.

00:09:27.320 --> 00:09:29.240
So if you can see
all of the edges,

00:09:29.240 --> 00:09:31.090
or you see that there's enough
incoming white to an edge,

00:09:31.090 --> 00:09:33.548
then you can reverse one of
the ones you have control over.

00:09:35.950 --> 00:09:40.320
So this problem-- I mean,
so a funny thing about DQBF

00:09:40.320 --> 00:09:42.920
is that there's sort of
only one round to the game--

00:09:42.920 --> 00:09:45.530
I mean, black plays,
white plays, white plays,

00:09:45.530 --> 00:09:49.260
and then you see who won--
whereas most games we think

00:09:49.260 --> 00:09:50.910
of as having many rounds.

00:09:50.910 --> 00:09:54.420
And in particular, bounded
TPCL has many rounds.

00:09:54.420 --> 00:09:55.500
They play in round robin.

00:09:55.500 --> 00:09:58.040
You've got black, white 1, white
2, black, white 1, white two.

00:09:58.040 --> 00:09:59.914
And you play in that
sequence, over and over.

00:09:59.914 --> 00:10:02.220
Each turn, someone's just
reversing a single edge,

00:10:02.220 --> 00:10:05.720
whereas over here, you're
choosing a ton of variables.

00:10:05.720 --> 00:10:10.310
Turns out this problem
is also in NEXPTIME,

00:10:10.310 --> 00:10:17.330
essentially because if there is
a winning strategy for white,

00:10:17.330 --> 00:10:21.330
over here, that winning
strategy is deterministic.

00:10:21.330 --> 00:10:24.910
And it's just a function
of the visible state.

00:10:24.910 --> 00:10:27.980
And there are at most
N different edges

00:10:27.980 --> 00:10:29.130
that you can see.

00:10:29.130 --> 00:10:31.160
So the number of possible
states is exponential.

00:10:31.160 --> 00:10:36.070
So at the beginning, you
just guess your strategy.

00:10:36.070 --> 00:10:38.050
That's exponentially
many bits to guess.

00:10:38.050 --> 00:10:40.010
So in NEXPTIME, you can do that.

00:10:40.010 --> 00:10:42.289
And then you just play
deterministically,

00:10:42.289 --> 00:10:43.080
with that strategy.

00:10:43.080 --> 00:10:45.530
So even though the game may
run for a very long time,

00:10:45.530 --> 00:10:47.394
and you do many,
many rounds, still,

00:10:47.394 --> 00:10:49.685
the information you need to
guess was only exponential.

00:10:49.685 --> 00:10:51.630
So you can do this in NEXPTIME.

00:10:51.630 --> 00:10:53.610
So it's a funny thing here.

00:10:53.610 --> 00:10:55.450
In this particular
world, unlike all

00:10:55.450 --> 00:10:59.470
of the other cells
of that matrix,

00:10:59.470 --> 00:11:02.250
one round versus many
rounds is the same.

00:11:02.250 --> 00:11:05.550
You get NEXPTIME
completeness in both cases.

00:11:05.550 --> 00:11:06.050
OK.

00:11:06.050 --> 00:11:12.842
So let me tell you how we reduce
from DQBF to bounded TPCL.

00:11:12.842 --> 00:11:13.550
So many acronyms.

00:11:17.190 --> 00:11:21.580
So the idea's pretty simple.

00:11:21.580 --> 00:11:25.090
Again, we want
black to play first.

00:11:25.090 --> 00:11:27.690
So there's a bunch of
black variables, here,

00:11:27.690 --> 00:11:30.280
which are represented by this.

00:11:30.280 --> 00:11:32.070
These two figures
are almost the same.

00:11:32.070 --> 00:11:35.090
Just these edges are blacked
down here and white down here.

00:11:35.090 --> 00:11:37.885
That's going to correspond
to the variable setting.

00:11:37.885 --> 00:11:40.650
In this context, we only want
variables to be set once.

00:11:40.650 --> 00:11:44.850
You don't get to reset them
because it's a bounded game.

00:11:44.850 --> 00:11:47.010
As in all of the bounded
constraint logic games,

00:11:47.010 --> 00:11:48.760
you can only flip
each edge once.

00:11:48.760 --> 00:11:49.300
Question?

00:11:49.300 --> 00:11:50.701
AUDIENCE: It's kind of a
question about your earlier

00:11:50.701 --> 00:11:52.492
point, but could you
clarify the difference

00:11:52.492 --> 00:11:55.007
between why having one
round of one of the games

00:11:55.007 --> 00:11:59.869
is equivalent to having
all-around [INAUDIBLE] game?

00:11:59.869 --> 00:12:01.660
PROFESSOR: I don't have
an intuitive reason

00:12:01.660 --> 00:12:06.710
why-- only that this game
is in NEXPTIME and this game

00:12:06.710 --> 00:12:08.150
is NEXPTIME complete.

00:12:08.150 --> 00:12:09.970
I mean, they both are
NEXPTIME complete.

00:12:09.970 --> 00:12:12.970
So in that sense,
they're equivalent.

00:12:12.970 --> 00:12:13.780
Yeah.

00:12:13.780 --> 00:12:15.560
So we're going to
simulate this one round

00:12:15.560 --> 00:12:19.440
game with multiple
rounds, over here.

00:12:19.440 --> 00:12:20.110
But yeah.

00:12:20.110 --> 00:12:23.130
It's a little bit odd that
alternation doesn't help.

00:12:23.130 --> 00:12:24.580
It doesn't give you more power.

00:12:24.580 --> 00:12:26.770
All of the other game
settings that it does.

00:12:26.770 --> 00:12:29.600
So it's just a weird
thing about team.

00:12:29.600 --> 00:12:30.410
Yeah.

00:12:30.410 --> 00:12:34.692
AUDIENCE: So are you [INAUDIBLE]
kind of rely on the fact

00:12:34.692 --> 00:12:37.320
that white doesn't learn
anything from black's moves

00:12:37.320 --> 00:12:39.290
when black moves on
an invisible edge?

00:12:39.290 --> 00:12:39.790
Sorry.

00:12:39.790 --> 00:12:41.150
It seems like in some
board configurations,

00:12:41.150 --> 00:12:42.360
if black moves on
an invisible edge,

00:12:42.360 --> 00:12:43.970
you can actually
learn something based

00:12:43.970 --> 00:12:48.211
on what moves were allowed,
and not allowed, for black.

00:12:48.211 --> 00:12:49.960
PROFESSOR: Maybe I
should say that passing

00:12:49.960 --> 00:12:52.030
is allowed in this game.

00:12:52.030 --> 00:12:55.249
Otherwise, the fact that you
moved does tell you something.

00:12:55.249 --> 00:12:56.790
But if you're always
allowed to pass,

00:12:56.790 --> 00:12:59.170
you really have no idea
whether something happened,

00:12:59.170 --> 00:13:00.501
except by what was visible.

00:13:00.501 --> 00:13:01.000
Yeah.

00:13:01.000 --> 00:13:03.960
So that's-- make explicit,
passing is allowed.

00:13:09.040 --> 00:13:12.301
Yeah, these are a bit subtle.

00:13:12.301 --> 00:13:12.800
OK.

00:13:12.800 --> 00:13:16.880
So the intent is, first, we
let black choose variables,

00:13:16.880 --> 00:13:19.150
either by flipping true edge,
flipping the false edge.

00:13:19.150 --> 00:13:21.320
We want to set it up
so you can't do-- well,

00:13:21.320 --> 00:13:23.925
you can't do both because
of this vertex constraint.

00:13:23.925 --> 00:13:24.550
So that's cool.

00:13:24.550 --> 00:13:28.680
As soon as that
happens, probably, white

00:13:28.680 --> 00:13:31.500
will flip this edge and
black will flip this edge.

00:13:31.500 --> 00:13:35.890
That's a split, activating--
well, not yet activating

00:13:35.890 --> 00:13:40.460
the formula part, but enabling
black to activate the chosen

00:13:40.460 --> 00:13:43.630
edge, saying that this
variable has been chosen.

00:13:43.630 --> 00:13:47.470
And so black will
sort of output that.

00:13:47.470 --> 00:13:50.920
Then in here, so there's
n such variables.

00:13:50.920 --> 00:13:53.730
And B1 and B2 are both in here.

00:13:53.730 --> 00:13:57.030
And we take the and of
all of those chosen edges.

00:13:57.030 --> 00:13:59.770
And that's this chosen wire.

00:13:59.770 --> 00:14:02.090
So this-- black is
motivated to do this.

00:14:02.090 --> 00:14:04.940
Black wants to set
their variable some way.

00:14:04.940 --> 00:14:06.929
And they could, I
guess, set them back

00:14:06.929 --> 00:14:07.970
and change the variables.

00:14:07.970 --> 00:14:10.150
But there won't be any
motivation to do that.

00:14:10.150 --> 00:14:12.370
The goal for black is
to flip this edge, which

00:14:12.370 --> 00:14:15.540
is connected by a long path from
the AND of all of the chosen

00:14:15.540 --> 00:14:16.040
wires.

00:14:16.040 --> 00:14:18.730
So basically, B has to
choose all of the variables,

00:14:18.730 --> 00:14:21.350
get this AND to be true,
and then just sit there,

00:14:21.350 --> 00:14:23.700
flipping these edges,
until this edge is flipped.

00:14:23.700 --> 00:14:28.270
So that's a threat line, once
B has set their variables.

00:14:28.270 --> 00:14:30.290
So B is going to
race to do that.

00:14:30.290 --> 00:14:32.780
White is going to have
just enough time to satisfy

00:14:32.780 --> 00:14:36.740
the formula and flip this
edge if the formula was true,

00:14:36.740 --> 00:14:39.030
obviously.

00:14:39.030 --> 00:14:42.690
So what happens next--
white will basically

00:14:42.690 --> 00:14:46.740
sit there and
twiddle their thumbs,

00:14:46.740 --> 00:14:50.026
flipping some useless
edge, until all

00:14:50.026 --> 00:14:51.440
of the black variables are set.

00:14:51.440 --> 00:14:53.023
They could actually
do something else.

00:14:53.023 --> 00:14:55.130
But there's going to
be enough time to wait.

00:14:55.130 --> 00:14:56.780
So it's better to wait.

00:14:56.780 --> 00:15:01.410
Then the white variables can
depend on the black variables

00:15:01.410 --> 00:15:03.500
that it can see.

00:15:03.500 --> 00:15:07.840
Obviously, pretty much
all of the edges in here

00:15:07.840 --> 00:15:10.045
are visible to only one
of the white players.

00:15:10.045 --> 00:15:13.480
If this is a B1
variable, then this

00:15:13.480 --> 00:15:15.830
is only visible the white 1.

00:15:15.830 --> 00:15:17.700
White 1 can see
that it was chosen

00:15:17.700 --> 00:15:19.250
but can't see which
of these edges

00:15:19.250 --> 00:15:21.360
got flipped and can't
see which of these edges

00:15:21.360 --> 00:15:24.460
got flipped or these ones.

00:15:24.460 --> 00:15:24.960
OK?

00:15:24.960 --> 00:15:28.220
So that's representing
the visibility.

00:15:28.220 --> 00:15:30.410
And so then white will
set their variables,

00:15:30.410 --> 00:15:32.670
the same kind of construction.

00:15:32.670 --> 00:15:38.640
And once chosen is
activated for both of them,

00:15:38.640 --> 00:15:43.210
we take the AND here, and
we trigger the unlock paths.

00:15:43.210 --> 00:15:47.110
It's going to unlock the white
1, unlock the white 2, unlock

00:15:47.110 --> 00:15:49.830
all of the black variables.

00:15:49.830 --> 00:15:55.190
And the unlock part is what
lets you trigger the formula

00:15:55.190 --> 00:15:56.330
activation.

00:15:56.330 --> 00:16:00.490
So if true was selected
here, and this was flipped,

00:16:00.490 --> 00:16:02.740
once the unlock is
flipped, then this guy

00:16:02.740 --> 00:16:05.560
can activate and start inputting
all of the true variables

00:16:05.560 --> 00:16:06.950
into the formula.

00:16:06.950 --> 00:16:09.710
And then white will sit there
and evaluate the formula.

00:16:09.710 --> 00:16:14.350
It has just enough time, if it's
satisfied, to flip and be done.

00:16:14.350 --> 00:16:17.100
So that's how we
represent dependency QBF.

00:16:17.100 --> 00:16:19.800
I mean, it's pretty natural.

00:16:19.800 --> 00:16:23.125
It's just some fun stuff
to get these to happen

00:16:23.125 --> 00:16:25.050
in essentially two rounds.

00:16:25.050 --> 00:16:28.000
The visibility constraints of
the partial-- the privateness

00:16:28.000 --> 00:16:31.669
of visible information
makes this part really easy

00:16:31.669 --> 00:16:32.210
to implement.

00:16:32.210 --> 00:16:34.930
So no big surprises.

00:16:34.930 --> 00:16:37.474
Questions?

00:16:37.474 --> 00:16:38.950
OK.

00:16:38.950 --> 00:16:40.750
Let's go to the
unbounded case, which

00:16:40.750 --> 00:16:42.820
is the much more exciting one.

00:16:48.520 --> 00:16:53.350
So I mean, Undecidability
is weird and unusual.

00:16:53.350 --> 00:16:56.410
It's weird in this
context because this game

00:16:56.410 --> 00:16:58.200
has finite resources.

00:16:58.200 --> 00:16:59.840
All of our games--
in particular,

00:16:59.840 --> 00:17:03.690
in constraint logic-- you
have some graph of size n.

00:17:03.690 --> 00:17:06.329
And Undecidability is
about, essentially,

00:17:06.329 --> 00:17:10.764
simulating a Turing machine
for arbitrary amounts of time

00:17:10.764 --> 00:17:12.055
and arbitrary amounts of space.

00:17:14.854 --> 00:17:16.020
It's bigger than 2 to the n.

00:17:16.020 --> 00:17:17.395
It's bigger than
2 to 2 to the n.

00:17:17.395 --> 00:17:18.900
It's bigger than 2 tower.

00:17:18.900 --> 00:17:21.500
And it's bigger than
any-- I guess, it's

00:17:21.500 --> 00:17:24.240
any computable function of
n is how far you have to go.

00:17:24.240 --> 00:17:26.180
So a little bit less
than busy beaver.

00:17:28.710 --> 00:17:30.490
That's a lot of space.

00:17:30.490 --> 00:17:35.179
So in game graph,
we can't represent

00:17:35.179 --> 00:17:37.470
the state of the machine that
we're trying to simulate.

00:17:37.470 --> 00:17:43.520
So I should say-- we haven't
done Undecidability at all,

00:17:43.520 --> 00:17:48.850
but the canonical
problem to start from

00:17:48.850 --> 00:17:50.770
is a halting problem.

00:17:50.770 --> 00:17:53.470
You're given a Turing machine.

00:17:53.470 --> 00:17:55.490
And here, I'd like
to say algorithm,

00:17:55.490 --> 00:17:58.090
but we need some model
of the machine growing

00:17:58.090 --> 00:17:59.610
to arbitrarily large sizes.

00:17:59.610 --> 00:18:03.770
And this Turing machine
is really ideal for this.

00:18:03.770 --> 00:18:06.735
Given the Turing machine,
does it ever halt?

00:18:12.040 --> 00:18:16.170
So remember, a Turing
machine, you have some tape.

00:18:16.170 --> 00:18:19.770
Let's say, initially, all of
the tape squares are empty.

00:18:19.770 --> 00:18:21.990
You have some pointer
into the tape, starts

00:18:21.990 --> 00:18:24.510
at some canonical position.

00:18:24.510 --> 00:18:28.010
And you can read and
write squares in the tape.

00:18:28.010 --> 00:18:29.480
And you can move left and right.

00:18:29.480 --> 00:18:32.300
And that's it.

00:18:32.300 --> 00:18:34.480
The feeling, as this
corresponds-- this

00:18:34.480 --> 00:18:37.020
includes all
possible computation.

00:18:37.020 --> 00:18:39.847
And so deciding whether
this machine will ever

00:18:39.847 --> 00:18:41.930
finish-- so there's an
instruction that just says,

00:18:41.930 --> 00:18:47.750
halt-- or whether to just
keep going on forever seems--

00:18:47.750 --> 00:18:49.460
is provably impossible.

00:18:49.460 --> 00:18:51.360
There is no algorithm
to decide that,

00:18:51.360 --> 00:18:53.890
essentially because it's an
algorithm to study algorithms.

00:18:53.890 --> 00:18:55.940
But I won't prove that here.

00:18:55.940 --> 00:18:57.745
I'm going to reduce
from this problem.

00:18:57.745 --> 00:19:00.325
And so I need to be able to
simulate a Turing machine

00:19:00.325 --> 00:19:02.470
of arbitrary size and time.

00:19:05.550 --> 00:19:07.080
Cool.

00:19:07.080 --> 00:19:11.480
So while most of the time
I don't show you the source

00:19:11.480 --> 00:19:14.967
problem, I think, here, it's
instructive to see-- well,

00:19:14.967 --> 00:19:16.800
I guess I'm not proving
this as undecidable.

00:19:16.800 --> 00:19:20.720
But it's instructive to see
how we turn this into a game,

00:19:20.720 --> 00:19:21.850
with bounded resources.

00:19:21.850 --> 00:19:24.940
So before I get to the
constrain logic version,

00:19:24.940 --> 00:19:27.660
I'm going to talk about
something called a team

00:19:27.660 --> 00:19:37.670
computation game-- this is
from our book, Games, Puzzles,

00:19:37.670 --> 00:19:43.260
Computation-- that will allow
us to simulate the halting

00:19:43.260 --> 00:19:44.940
problem, but using
finite resources.

00:19:44.940 --> 00:19:46.670
This is where the action is.

00:19:46.670 --> 00:19:48.240
Going from here to
a constrain logic

00:19:48.240 --> 00:19:51.770
is not that hard and
not super interesting.

00:19:51.770 --> 00:19:53.390
But this part is
quite interesting.

00:19:57.100 --> 00:19:57.600
OK.

00:19:57.600 --> 00:19:59.410
So in team computation
game, there's

00:19:59.410 --> 00:20:03.000
going to be three players--
one black player, two

00:20:03.000 --> 00:20:04.880
white players.

00:20:04.880 --> 00:20:09.900
And the instance to the game--
sort of the board set up,

00:20:09.900 --> 00:20:16.740
whatever-- is
going to be-- here,

00:20:16.740 --> 00:20:19.400
I could use any algorithm
or Turing machine.

00:20:19.400 --> 00:20:21.590
It's going to be machine.

00:20:21.590 --> 00:20:25.320
And it has some
space bound which

00:20:25.320 --> 00:20:28.540
are called k. k is going to
be, essentially, a constant.

00:20:28.540 --> 00:20:29.680
But it's part of the input.

00:20:32.560 --> 00:20:34.204
And the idea-- if
this is an algorithm,

00:20:34.204 --> 00:20:35.370
it starts with blank memory.

00:20:35.370 --> 00:20:39.350
If it's a Turing machine,
it starts with a blank tape.

00:20:39.350 --> 00:20:42.680
And then we're going to define
black moves and white moves.

00:20:45.370 --> 00:20:48.300
So remember, there's
one black player.

00:20:48.300 --> 00:20:53.400
And what the black player does,
or what the black player's

00:20:53.400 --> 00:20:57.160
forced to do, is run the
algorithm or the machine

00:20:57.160 --> 00:21:00.080
for k time steps.

00:21:04.580 --> 00:21:06.990
So k obviously is an input.

00:21:06.990 --> 00:21:10.380
So black is forced to do that.

00:21:10.380 --> 00:21:13.310
Now, that algorithm
may return an answer.

00:21:13.310 --> 00:21:16.460
And the answer is always
black wins or white wins.

00:21:16.460 --> 00:21:18.489
Or it may not do
anything, in which case

00:21:18.489 --> 00:21:19.530
it wants to keep running.

00:21:19.530 --> 00:21:21.866
In the next black
move, it's going

00:21:21.866 --> 00:21:22.990
to run for another k steps.

00:21:22.990 --> 00:21:24.850
And in the next black moves,
it runs for another k steps,

00:21:24.850 --> 00:21:25.779
and so on.

00:21:25.779 --> 00:21:26.820
Think of k as a constant.

00:21:29.550 --> 00:21:37.339
So if there's output from
this algorithm or machine,

00:21:37.339 --> 00:21:38.630
that will determine the winner.

00:21:45.550 --> 00:21:46.180
OK?

00:21:46.180 --> 00:21:50.690
And otherwise, black actually
gets to make a choice.

00:21:50.690 --> 00:21:53.000
This was completely forced,
what black had to do here.

00:21:53.000 --> 00:21:54.916
You could think of it
as part of black's move.

00:21:54.916 --> 00:21:59.680
But it's really-- the game
mechanics make this happen.

00:21:59.680 --> 00:22:05.570
And in this case, black can
set two variables-- X1 and X2--

00:22:05.570 --> 00:22:10.960
to be anything in
the set A, B. OK?

00:22:10.960 --> 00:22:14.530
Black gets to choose two
bits if the machine doesn't

00:22:14.530 --> 00:22:16.390
say that the game is over.

00:22:16.390 --> 00:22:16.890
OK?

00:22:16.890 --> 00:22:18.640
We'll see what those
bits do, in a moment.

00:22:23.960 --> 00:22:26.810
So that was black's move.

00:22:26.810 --> 00:22:29.070
Now, what about white?

00:22:29.070 --> 00:22:32.370
Again, there are two
players-- white 1 and white 2.

00:22:32.370 --> 00:22:38.870
And white i is basically blind.

00:22:38.870 --> 00:22:42.030
White i can only see Xi.

00:22:42.030 --> 00:22:44.504
These Xis are messages
to the white players.

00:22:44.504 --> 00:22:45.920
And that's all
that white can see.

00:22:45.920 --> 00:22:49.020
White can't see anything
else about the machine.

00:22:49.020 --> 00:22:51.350
Good that it knows what
the machine is, knows what

00:22:51.350 --> 00:22:52.675
it's doing, probably knows k.

00:22:52.675 --> 00:22:54.800
But that's because that's
all part of the instance.

00:22:54.800 --> 00:22:59.540
But you don't know anything else
about the state of the machine.

00:22:59.540 --> 00:23:01.770
And white can also
do one other thing.

00:23:07.770 --> 00:23:11.340
There's one memory cell
in the machine, called M1.

00:23:11.340 --> 00:23:12.940
And there's another
one called M2.

00:23:12.940 --> 00:23:18.230
And player white i can set Mi.

00:23:18.230 --> 00:23:19.770
And so that will
communicate, back

00:23:19.770 --> 00:23:23.550
into the machine,
what white i did.

00:23:23.550 --> 00:23:27.120
And that is exactly
the move of white i.

00:23:27.120 --> 00:23:33.190
White i move is just set Mi.

00:23:33.190 --> 00:23:34.860
And I'm not specifying
how big that is.

00:23:34.860 --> 00:23:36.830
It's not just a single bit.

00:23:36.830 --> 00:23:42.270
It could be some stuff.

00:23:42.270 --> 00:23:46.450
In particular, it's going to be
one cell in the Turing machine

00:23:46.450 --> 00:23:48.490
we want to simulate,
essentially.

00:23:48.490 --> 00:23:51.020
But OK.

00:23:51.020 --> 00:23:53.860
So now the question is, does
white have a forced win?

00:23:59.020 --> 00:24:02.340
So this is the problem I
want to prove undecidable

00:24:02.340 --> 00:24:05.810
by a reduction from
halting problem.

00:24:09.702 --> 00:24:10.202
OK.

00:24:22.910 --> 00:24:24.930
So is the problem clear?

00:24:24.930 --> 00:24:29.330
We have a finite setup, which
is this space k situation,

00:24:29.330 --> 00:24:32.490
that the entire state of
the game is, in some sense,

00:24:32.490 --> 00:24:36.900
encoded by that-- the state of
that algorithm, it would seem.

00:24:39.640 --> 00:24:43.840
And black is just
telling-- in each turn,

00:24:43.840 --> 00:24:48.700
white 1 says A or B, white 2, it
says A or B. White 1 and 2 then

00:24:48.700 --> 00:24:50.690
respond with some symbol.

00:24:50.690 --> 00:24:52.670
And then the game continues.

00:24:52.670 --> 00:24:54.700
So a pretty simple setup.

00:24:54.700 --> 00:24:58.570
But amazingly, this can
simulate any Turing machine.

00:25:01.930 --> 00:25:02.870
So let's do it.

00:25:14.700 --> 00:25:16.879
So this algorithm is
going to be a function.

00:25:16.879 --> 00:25:18.420
Given the Turing
machine, we're going

00:25:18.420 --> 00:25:20.570
to construct the
algorithm, naturally.

00:25:20.570 --> 00:25:27.930
So we basically need a
constant space algorithm

00:25:27.930 --> 00:25:37.716
to check that the
white players produce--

00:25:37.716 --> 00:25:40.960
so the white players are
outputting a strain of symbols.

00:25:40.960 --> 00:25:43.210
White 1 is outputting M1 and
then outputting something

00:25:43.210 --> 00:25:44.780
else to M1, and so on.

00:25:44.780 --> 00:25:48.460
That strain of symbols,
for both white players,

00:25:48.460 --> 00:25:52.200
should essentially form a
valid computation history,

00:25:52.200 --> 00:25:55.150
an execution trace
of the Turing machine

00:25:55.150 --> 00:25:57.120
we want to simulate--
the given Turing machine.

00:26:00.585 --> 00:26:02.460
It's a little bit more
complicated than that.

00:26:02.460 --> 00:26:04.310
But that's the idea.

00:26:42.600 --> 00:26:45.280
And we'd like it to
end in a halt state.

00:26:45.280 --> 00:26:47.210
So there are lots
of canonical ways

00:26:47.210 --> 00:26:49.820
to write down the state
of the Turing machine.

00:26:49.820 --> 00:26:51.370
Basically, you
write down the tape

00:26:51.370 --> 00:26:55.240
and what instruction it's on.

00:26:55.240 --> 00:26:57.324
And that should be about it.

00:26:57.324 --> 00:26:59.240
And we're going to put
a special symbol-- hash

00:26:59.240 --> 00:27:00.914
mark-- in between
each of these states.

00:27:00.914 --> 00:27:02.830
So this is the state of
the machine at time 0.

00:27:02.830 --> 00:27:04.259
It's going to be a blank tape.

00:27:04.259 --> 00:27:06.550
And you only have to write
as many symbols as you need.

00:27:06.550 --> 00:27:08.820
So in the beginning,
don't write any symbols.

00:27:08.820 --> 00:27:12.390
As you start writing stuff to
tape, this will get longer.

00:27:12.390 --> 00:27:14.222
And yeah.

00:27:14.222 --> 00:27:16.180
And then the goal is to
get it to a halt state.

00:27:16.180 --> 00:27:20.050
Each of these states should be
the uniquely determined state

00:27:20.050 --> 00:27:22.430
from the previous one, which
is, if I do one instruction,

00:27:22.430 --> 00:27:24.072
what happens?

00:27:24.072 --> 00:27:24.980
OK?

00:27:24.980 --> 00:27:28.300
Now, this is problematic.

00:27:28.300 --> 00:27:31.250
So our goal-- we're trying
to design this algorithm

00:27:31.250 --> 00:27:36.164
to confirm that these states
are being generated correctly.

00:27:36.164 --> 00:27:38.830
That's really hard to do because
we can't compute the next state

00:27:38.830 --> 00:27:40.621
from the previous one
because we can't even

00:27:40.621 --> 00:27:44.560
store the previous
state in space k.

00:27:44.560 --> 00:27:46.200
We have constant space.

00:27:46.200 --> 00:27:49.110
Very soon, the state
is going to get huge.

00:27:49.110 --> 00:27:51.650
So you think of this as kind
of a streaming [INAUDIBLE]

00:27:51.650 --> 00:27:53.640
We're just seeing
these characters go by.

00:27:53.640 --> 00:27:56.480
And we can't remember the
entire previous states.

00:27:56.480 --> 00:27:59.000
So the fact-- to check
that the next state is

00:27:59.000 --> 00:28:02.350
almost the same as the
previous one is very hard.

00:28:02.350 --> 00:28:06.280
And that's where we're going
to use this A, B thing.

00:28:06.280 --> 00:28:08.930
This is not literally true.

00:28:08.930 --> 00:28:11.580
The sequence of
characters-- M1, say--

00:28:11.580 --> 00:28:14.670
will not produce a valid state.

00:28:14.670 --> 00:28:18.590
Essentially, what we
want player white 1

00:28:18.590 --> 00:28:23.090
to do is to maintain two
pointers into this state--

00:28:23.090 --> 00:28:29.800
A and B. And when we-- I'm
identifying with black here.

00:28:29.800 --> 00:28:32.680
When we specify X1
equals A, we would

00:28:32.680 --> 00:28:36.970
like to know what character's
being pointed to by pointer A.

00:28:36.970 --> 00:28:40.640
And then we'd like to advance
A to the next character.

00:28:40.640 --> 00:28:41.140
OK?

00:28:41.140 --> 00:28:44.180
When we request B,
with X1 equals B,

00:28:44.180 --> 00:28:46.395
we want to know what
character is at position B,

00:28:46.395 --> 00:28:48.020
and then advance to
the next character.

00:28:48.020 --> 00:28:51.940
So there's one strain that
we're trying to look at.

00:28:51.940 --> 00:28:55.200
And each white player has to
maintain an A pointer and a B

00:28:55.200 --> 00:28:56.470
pointer.

00:28:56.470 --> 00:28:59.490
And as black, we can
make independent requests

00:28:59.490 --> 00:29:00.530
to each of the two.

00:29:00.530 --> 00:29:07.720
It's like you have two disks
with two heads on the disk.

00:29:07.720 --> 00:29:09.810
And they both have
the exact same data.

00:29:09.810 --> 00:29:11.400
Or they're supposed to.

00:29:11.400 --> 00:29:13.320
And I can say, give
me the next character

00:29:13.320 --> 00:29:14.700
at this pointer from this disk.

00:29:14.700 --> 00:29:17.670
And I can give you-- ask for
what is-- simultaneously,

00:29:17.670 --> 00:29:20.030
I get one character
from one of the two

00:29:20.030 --> 00:29:21.410
pointers on the other disk.

00:29:21.410 --> 00:29:23.506
And then it advances by one.

00:29:23.506 --> 00:29:24.070
OK?

00:29:24.070 --> 00:29:25.829
Seems almost the same.

00:29:25.829 --> 00:29:27.620
But that's what will
make this undecidable.

00:29:39.610 --> 00:29:40.110
OK.

00:29:44.970 --> 00:29:49.940
So here's the trick, how we're
going to build this algorithm.

00:29:49.940 --> 00:29:52.890
I mean, the real trick is
that we have nondeterminism.

00:29:52.890 --> 00:29:56.940
We're asking whether white wins.

00:29:56.940 --> 00:29:59.770
That means-- or whether
white has a winning strategy.

00:29:59.770 --> 00:30:01.660
For white to have
a winning strategy,

00:30:01.660 --> 00:30:06.610
that must mean it can win or the
white team can win, no matter

00:30:06.610 --> 00:30:09.130
how black plays.

00:30:09.130 --> 00:30:11.780
And black is just non--
so basically, black

00:30:11.780 --> 00:30:14.640
is nondeterministically
choosing between the A

00:30:14.640 --> 00:30:19.410
and the B pointer requests.

00:30:19.410 --> 00:30:21.090
And so what this is
saying is, no matter

00:30:21.090 --> 00:30:26.890
what sequence of As and Bs
you get, white must win.

00:30:26.890 --> 00:30:28.900
And winning is going
to happen because we

00:30:28.900 --> 00:30:33.870
will build this algorithm to
only output yes when it gets

00:30:33.870 --> 00:30:35.120
to a halt state, basically.

00:30:39.700 --> 00:30:43.050
The algorithm must not
complain, no matter how

00:30:43.050 --> 00:30:45.194
we choose the A and B sequence.

00:30:45.194 --> 00:30:46.860
So let me get to what
we're going to do.

00:30:53.850 --> 00:31:10.725
So the algorithm maintains--
let's call this white 1.

00:31:20.100 --> 00:31:23.820
I would like to
know when-- let me

00:31:23.820 --> 00:31:28.812
be specific-- when white 1's A
state equals white 2's B state.

00:31:28.812 --> 00:31:30.520
But in fact, we'll do
this for all pairs.

00:31:30.520 --> 00:31:31.530
It'll be four different things.

00:31:31.530 --> 00:31:32.140
A, B here.

00:31:32.140 --> 00:31:33.980
A, B here.

00:31:33.980 --> 00:31:35.860
But let's say I want to
know when white 1's A

00:31:35.860 --> 00:31:41.000
state is in exactly the same
place as white 2's B state.

00:31:41.000 --> 00:31:45.885
So we have-- in
some sense, there

00:31:45.885 --> 00:31:51.006
are two of the strains, one
for white 1, one for white 2.

00:31:51.006 --> 00:31:58.010
And I want to know when I have
just to read through a state

00:31:58.010 --> 00:32:01.700
by white 1 and I've also read
through the exact same state

00:32:01.700 --> 00:32:03.740
from white 2.

00:32:03.740 --> 00:32:08.250
So that will happen when--
first of all, both white players

00:32:08.250 --> 00:32:11.040
should have just
returned a hash mark.

00:32:11.040 --> 00:32:14.080
And then-- hash
tag, if you prefer.

00:32:14.080 --> 00:32:19.490
And then also, while we were
running through this tape,

00:32:19.490 --> 00:32:22.850
I see whether they happen to
always return the same result.

00:32:22.850 --> 00:32:41.290
So this will basically
happen when-- so whenever

00:32:41.290 --> 00:32:46.540
both A and-- so if we just ask
for A, A, and white 1 returns

00:32:46.540 --> 00:32:48.660
a hash mark and white
2 returns a hash mark,

00:32:48.660 --> 00:32:50.410
then we're going to
start paying attention

00:32:50.410 --> 00:32:52.380
to every single
character we see.

00:32:52.380 --> 00:32:55.800
If-- assuming we keep
playing A, A, is black.

00:32:55.800 --> 00:32:58.500
And this has to work for all
possible assigned choices of A,

00:32:58.500 --> 00:33:01.620
B. So in particular,
it will be an execution

00:33:01.620 --> 00:33:04.965
where we play A, A
throughout this entire state.

00:33:04.965 --> 00:33:07.590
And as we're doing that, we just
check, character by character,

00:33:07.590 --> 00:33:09.470
are they returning
exactly the same result,

00:33:09.470 --> 00:33:12.510
and have they, so
far-- have they always,

00:33:12.510 --> 00:33:13.870
since the last hash mark?

00:33:18.730 --> 00:33:19.230
OK?

00:33:19.230 --> 00:33:21.360
And if they did, that's a
constant space algorithm.

00:33:21.360 --> 00:33:22.943
I just compare
character by character.

00:33:22.943 --> 00:33:26.480
Remember the AND of all
of those comparisons.

00:33:26.480 --> 00:33:29.220
If they were all the same,
and I reach a hash mark,

00:33:29.220 --> 00:33:35.510
that means I know that both
the W1 strain and the W2

00:33:35.510 --> 00:33:38.637
strain just output
the same state.

00:33:38.637 --> 00:33:40.220
So that means the A
and the A pointers

00:33:40.220 --> 00:33:43.575
are in the same
place at this moment.

00:33:46.980 --> 00:33:47.540
Cool.

00:33:47.540 --> 00:33:49.080
That's not quite
where I want them.

00:33:49.080 --> 00:33:51.120
But at least I can detect that.

00:33:51.120 --> 00:33:51.620
OK?

00:33:51.620 --> 00:33:53.260
I can detect identical states.

00:33:53.260 --> 00:33:55.380
Remember, I can't even
store-- I can't even

00:33:55.380 --> 00:33:56.840
count A and B
because these could

00:33:56.840 --> 00:33:58.460
get to really huge numbers.

00:33:58.460 --> 00:34:01.780
That only buys me an exponential
when I write things in binary.

00:34:01.780 --> 00:34:04.660
So I can't afford to write
down the A and the B pointers.

00:34:04.660 --> 00:34:05.770
It's what I'd like to do.

00:34:05.770 --> 00:34:09.580
But I can check, oh, did they
just output the same state?

00:34:09.580 --> 00:34:10.860
So far so good?

00:34:10.860 --> 00:34:14.520
Now, what I'd really like them
to be is one step out of sync

00:34:14.520 --> 00:34:18.149
because what I do have a
streaming algorithm for is

00:34:18.149 --> 00:34:20.190
if I have the previous
data of the Turing machine

00:34:20.190 --> 00:34:22.469
and the proposed next date
of this Turing machine,

00:34:22.469 --> 00:34:26.090
and I compare them letter
by letter, I can just check,

00:34:26.090 --> 00:34:28.659
are all of the tape squares
identical except for the one

00:34:28.659 --> 00:34:30.370
that the pointer's on?

00:34:30.370 --> 00:34:33.050
And that got changed
by a simple rule.

00:34:33.050 --> 00:34:35.370
And then all the others
should be identical.

00:34:35.370 --> 00:34:37.090
So it's very easy,
in a streaming sense.

00:34:37.090 --> 00:34:39.739
If I'm giving the previous
state and the next state,

00:34:39.739 --> 00:34:41.260
I'd be happy.

00:34:41.260 --> 00:34:46.580
So my goal is to get W1 state
to be one step out of sync,

00:34:46.580 --> 00:34:48.046
one step behind W2 state.

00:34:51.061 --> 00:34:51.560
OK.

00:34:51.560 --> 00:34:55.960
So how can I make that happen?

00:35:15.150 --> 00:35:18.750
Again, so I mean, black
isn't really making-- well,

00:35:18.750 --> 00:35:21.370
black is making all possible
choices among A and B,

00:35:21.370 --> 00:35:22.990
at all times.

00:35:22.990 --> 00:35:25.890
So in particular, we can
consider the situation

00:35:25.890 --> 00:35:32.370
in which black plays, let's
say A for the W1 player,

00:35:32.370 --> 00:35:34.100
and plays B on the other player.

00:35:34.100 --> 00:35:38.780
W2's A state does not change
because we're advancing B.

00:35:38.780 --> 00:35:42.767
And then W1's
state is advancing.

00:35:42.767 --> 00:35:44.850
And if I keep doing that,
and then, at some point,

00:35:44.850 --> 00:35:46.516
I get a hash mark,
which I can obviously

00:35:46.516 --> 00:35:50.830
detect in constant space,
then I advance my finite state

00:35:50.830 --> 00:35:53.320
machine, and say,
OK, cool, that means

00:35:53.320 --> 00:35:57.530
W1 is one step ahead--
one state ahead of W2.

00:36:00.350 --> 00:36:03.790
And now I'm going to compare.

00:36:03.790 --> 00:36:11.010
So when that happens, so
then out of sync by 1.

00:36:17.420 --> 00:36:21.660
And now what I'd like to
happen next is X1 and X2 moves.

00:36:26.780 --> 00:36:29.760
Then now I'm going to run
my streaming algorithm

00:36:29.760 --> 00:36:32.960
to check that this was
a valid transition.

00:36:52.210 --> 00:36:55.470
So from whatever
W2 is outputting

00:36:55.470 --> 00:36:59.530
to whatever W1 is outputting
because W1 is ahead,

00:36:59.530 --> 00:37:00.930
that should be a valid state.

00:37:00.930 --> 00:37:05.450
So basically, I had--
I ran for some time.

00:37:05.450 --> 00:37:06.900
Who knows what happened.

00:37:06.900 --> 00:37:12.550
Then I got this thing which
is identical to this thing.

00:37:12.550 --> 00:37:13.340
I detect that.

00:37:13.340 --> 00:37:14.290
And I see a hash mark.

00:37:14.290 --> 00:37:17.570
So I say, OK, they must
be in the same state.

00:37:17.570 --> 00:37:20.490
Now I'm going to
skip over whatever

00:37:20.490 --> 00:37:22.650
state was written here.

00:37:22.650 --> 00:37:27.740
And then I'm going to check
that every thing I get here

00:37:27.740 --> 00:37:29.940
is a valid transition
for whenever I get here.

00:37:32.830 --> 00:37:34.240
So this should go to that.

00:37:34.240 --> 00:37:35.500
This should go to that.

00:37:35.500 --> 00:37:38.030
And I don't need any
memory to do this.

00:37:38.030 --> 00:37:40.030
I'm just looking at
this square, knowing

00:37:40.030 --> 00:37:43.750
the state of this machine,
looking at this square,

00:37:43.750 --> 00:37:46.020
making sure that was
a valid transition.

00:37:46.020 --> 00:37:48.522
Usually, it's just that
this is equal to that,

00:37:48.522 --> 00:37:50.480
except at the one place
where the tape head is,

00:37:50.480 --> 00:37:54.190
which is written in
that little symbol.

00:37:54.190 --> 00:37:56.347
And in that spot, I do
whatever the Turing machine

00:37:56.347 --> 00:37:57.180
does to that symbol.

00:37:57.180 --> 00:37:59.510
If the writes to
it, it might change.

00:37:59.510 --> 00:38:01.480
Maybe it moves the
pointer left or right.

00:38:01.480 --> 00:38:03.090
But in constant
space, I just need

00:38:03.090 --> 00:38:04.650
to know what's happening here.

00:38:04.650 --> 00:38:06.560
And maybe it's
neighboring squares.

00:38:06.560 --> 00:38:08.510
I can figure out what
should be written here.

00:38:08.510 --> 00:38:10.810
And if white 1 ever
does the wrong thing,

00:38:10.810 --> 00:38:14.100
if it's not a valid
transition, then I

00:38:14.100 --> 00:38:18.280
will say black wins
as this algorithm.

00:38:18.280 --> 00:38:24.160
So for white to win, it
can't make any mistakes.

00:38:24.160 --> 00:38:27.670
White has to conform to this
idea that basically, first,

00:38:27.670 --> 00:38:30.690
it-- well, it basically--
as it's playing,

00:38:30.690 --> 00:38:34.120
it must be computing whatever
the Turing machine that's

00:38:34.120 --> 00:38:36.650
part of the game, essentially.

00:38:36.650 --> 00:38:40.610
It's embedded in this
algorithm, the Turing machine.

00:38:40.610 --> 00:38:45.930
And so we have to-- it has to be
simulating the Turing machine,

00:38:45.930 --> 00:38:48.870
maintaining these pointers,
A and B, and running through.

00:38:48.870 --> 00:38:51.240
It has to do that
because it has to win,

00:38:51.240 --> 00:38:53.260
no matter what black does.

00:38:53.260 --> 00:38:56.530
And it could be that black
does this really weird sequence

00:38:56.530 --> 00:39:00.900
of As and Bs in order to
verify the one place where

00:39:00.900 --> 00:39:04.107
you lied about one of these
being an invalid transition.

00:39:04.107 --> 00:39:06.440
It will eventually check for
some choices of the A and B

00:39:06.440 --> 00:39:07.500
moves.

00:39:07.500 --> 00:39:09.470
It will check that it
was a valid transition,

00:39:09.470 --> 00:39:12.220
from here to here.

00:39:12.220 --> 00:39:17.870
And therefore, all
transitions must be valid.

00:39:17.870 --> 00:39:20.490
So it's a pretty crazy
use of essentially

00:39:20.490 --> 00:39:23.080
the universal quantifier
that's given to black.

00:39:26.101 --> 00:39:28.290
White has to win, no matter
what black's moves are.

00:39:31.200 --> 00:39:38.690
So you might ask, where is
the Turing machine state.

00:39:38.690 --> 00:39:40.560
And it's essentially
in the heads

00:39:40.560 --> 00:39:43.500
of the white players, which
are not represented directly

00:39:43.500 --> 00:39:44.750
by the game.

00:39:44.750 --> 00:39:48.660
The game is just, you know, what
is the state of this algorithm?

00:39:48.660 --> 00:39:51.450
And it's, in some sense,
informed by the history

00:39:51.450 --> 00:39:54.000
of the plays, the sequence
of moves that have been made.

00:39:58.560 --> 00:40:01.490
That's, in some sense,
where you can also see

00:40:01.490 --> 00:40:04.670
this long sequence of moves.

00:40:04.670 --> 00:40:07.316
I mean, each of these
got output at some point.

00:40:07.316 --> 00:40:09.940
But initially, you could sort of
think of, all of the execution

00:40:09.940 --> 00:40:11.184
was in the players' heads.

00:40:11.184 --> 00:40:13.350
Then they're just maintaining
these A and B pointers

00:40:13.350 --> 00:40:14.340
and playing.

00:40:14.340 --> 00:40:17.450
And there must be such an
execution in order for white

00:40:17.450 --> 00:40:18.340
to win.

00:40:18.340 --> 00:40:22.270
So white will win, if, and only
if, there's a-- the machine

00:40:22.270 --> 00:40:26.860
halts, basically, because this
algorithm only output yes--

00:40:26.860 --> 00:40:30.110
output that white wins
when the machine halts.

00:40:30.110 --> 00:40:33.160
And it will report that black
wins, if you ever cheat.

00:40:33.160 --> 00:40:35.970
So you have to not cheat.

00:40:35.970 --> 00:40:39.640
And you have to get
to a halting state.

00:40:39.640 --> 00:40:40.470
It's pretty crazy.

00:40:40.470 --> 00:40:42.990
And this probably won't make
sense the first or second time.

00:40:42.990 --> 00:40:47.000
But it's clear to me,
again, every time I learn.

00:40:47.000 --> 00:40:49.235
It's like, oh, yeah,
that's really cool.

00:40:49.235 --> 00:40:50.860
Hopefully, it will
become clear to you.

00:40:50.860 --> 00:40:52.120
But if there are any questions--

00:40:52.120 --> 00:40:54.120
AUDIENCE: Why is it
important that the algorithm

00:40:54.120 --> 00:40:56.730
is only one space, in
the first place, though?

00:40:56.730 --> 00:41:00.490
PROFESSOR: I mean,
it's not technically--

00:41:00.490 --> 00:41:03.290
the overall algorithm is not
technically constant space

00:41:03.290 --> 00:41:06.450
because it needs to include the
entire Turing machine as part

00:41:06.450 --> 00:41:08.750
of it, to know how to run.

00:41:08.750 --> 00:41:11.900
But I mentioned that
the checking algorithm

00:41:11.900 --> 00:41:13.180
is constant space.

00:41:13.180 --> 00:41:18.980
And the point is, really, that
the size of this space key

00:41:18.980 --> 00:41:22.440
algorithm has to be only a
function of the given Turing

00:41:22.440 --> 00:41:23.890
machine.

00:41:23.890 --> 00:41:26.780
It can't depend on the
execution time or the execution

00:41:26.780 --> 00:41:28.300
space of the Turing machine.

00:41:28.300 --> 00:41:30.290
But that's all I
want to emphasize.

00:41:30.290 --> 00:41:33.726
So effectively, I mean, if you
think of the Turing machine

00:41:33.726 --> 00:41:35.350
as being pretty small,
but it's running

00:41:35.350 --> 00:41:39.900
for some huge amount of
time, like busy beaver time,

00:41:39.900 --> 00:41:41.800
relative to that, we're
thinking, basically,

00:41:41.800 --> 00:41:43.690
constant space.

00:41:43.690 --> 00:41:45.740
And in fact, we can get
away with constant space.

00:41:45.740 --> 00:41:47.440
That's for the checking part.

00:41:47.440 --> 00:41:49.360
That's my point.

00:41:49.360 --> 00:41:52.390
If you view the Turing machine
execution as an oracle.

00:41:52.390 --> 00:41:56.560
So when I check that this
goes to this-- in fact,

00:41:56.560 --> 00:42:00.210
I have to run the Turing
machine on this tape head input,

00:42:00.210 --> 00:42:02.300
to see what it would output.

00:42:02.300 --> 00:42:05.280
But the Turing machine
is inside the algorithm.

00:42:05.280 --> 00:42:08.260
So I can do that and
[INAUDIBLE] some time

00:42:08.260 --> 00:42:11.520
with the lookup table.

00:42:11.520 --> 00:42:14.330
So the point is, really, you
need, effectively, a streaming

00:42:14.330 --> 00:42:17.360
algorithm to do this
because these states get

00:42:17.360 --> 00:42:22.870
to be really, really
huge, because we

00:42:22.870 --> 00:42:26.780
want this reduction
to be polynomial time.

00:42:26.780 --> 00:42:29.964
And it is.

00:42:29.964 --> 00:42:31.630
Basically, copy the
Turing machine over,

00:42:31.630 --> 00:42:34.810
write some constant amount
of code to do this checking,

00:42:34.810 --> 00:42:37.690
and that's all you need.

00:42:37.690 --> 00:42:39.700
I guess we don't need it
to be polynomial time.

00:42:39.700 --> 00:42:40.440
But it is.

00:42:40.440 --> 00:42:42.070
So it's kind of nice.

00:42:42.070 --> 00:42:45.440
But we need that
it's finite time.

00:42:45.440 --> 00:42:48.090
And there's no finite way
to give an upper bound

00:42:48.090 --> 00:42:49.840
on the running time
of the Turing machine,

00:42:49.840 --> 00:42:50.980
other than running it.

00:42:50.980 --> 00:42:55.530
So polynomial time is good.

00:42:58.740 --> 00:43:00.810
OK.

00:43:00.810 --> 00:43:03.850
Let me briefly mention a
more formula-oriented game.

00:43:11.790 --> 00:43:13.265
This is not terribly exciting.

00:43:17.567 --> 00:43:18.900
I'll just write it down quickly.

00:43:38.570 --> 00:43:44.280
Basically, you can convert this
problem-- team computation game

00:43:44.280 --> 00:43:47.270
where black is forced to run
a particular machine-- you can

00:43:47.270 --> 00:43:49.580
convert machines into formulas.

00:43:49.580 --> 00:43:52.870
So it ends up looking
something like this.

00:43:52.870 --> 00:43:54.315
It might be possible
to simplify.

00:44:03.779 --> 00:44:05.445
This is one thing
that definitely works.

00:44:32.660 --> 00:44:33.160
OK.

00:44:33.160 --> 00:44:38.670
So again, white 1 can only
see one variable-- X1--

00:44:38.670 --> 00:44:40.060
that is set by black.

00:44:40.060 --> 00:44:42.480
And white 2 can only
see one variable-- X2--

00:44:42.480 --> 00:44:44.510
that's set by black.

00:44:44.510 --> 00:44:48.710
Black can set a bunch of
variables in one round.

00:44:48.710 --> 00:44:50.830
And there's some condition
that it has to satisfy.

00:44:50.830 --> 00:44:53.329
This will basically force you
to simulate the Turing machine

00:44:53.329 --> 00:44:55.560
and not break any rules.

00:44:55.560 --> 00:44:58.210
And if black ever
satisfies something,

00:44:58.210 --> 00:45:01.320
which is when the Turing
machine's, hey, black wins.

00:45:01.320 --> 00:45:02.370
Then black wins.

00:45:02.370 --> 00:45:04.720
And then you just turn
that into a formula.

00:45:04.720 --> 00:45:08.030
And then black sets
some other stuff.

00:45:08.030 --> 00:45:11.990
And so this is more in the
style of the dependency QBF.

00:45:11.990 --> 00:45:13.704
Again, you have this
kind of dependency.

00:45:13.704 --> 00:45:15.120
But now there are
multiple rounds.

00:45:15.120 --> 00:45:18.830
And now there's no bound to
the number of moves you make.

00:45:18.830 --> 00:45:21.440
We can reset
variables many times.

00:45:21.440 --> 00:45:24.990
And this is undecidable
by essentially simulating

00:45:24.990 --> 00:45:28.100
this machine, turning that
machine into a formula.

00:45:31.040 --> 00:45:35.551
So once we have that, we can
turn it into a constraint logic

00:45:35.551 --> 00:45:36.050
version.

00:45:36.050 --> 00:45:40.270
This is the team private but
not bounded constraint logic.

00:45:40.270 --> 00:45:42.300
Pretty much the same setup.

00:45:42.300 --> 00:45:44.770
Black has these
variables, X and X prime.

00:45:44.770 --> 00:45:47.360
Y1 has these variables, Y1.

00:45:47.360 --> 00:45:49.620
Y2 has these variables, Y2.

00:45:49.620 --> 00:45:50.890
They're fed into this formula.

00:45:50.890 --> 00:45:53.240
And there are various
things to-- that

00:45:53.240 --> 00:45:56.010
when those conditions
that I wrote down happen,

00:45:56.010 --> 00:45:58.690
you trigger the
appropriate target edge.

00:45:58.690 --> 00:46:01.670
And then black wins, up there,
or white wins, down there.

00:46:01.670 --> 00:46:04.790
So not too exciting to go
through the details of that.

00:46:04.790 --> 00:46:10.070
But the result is team private
information constraint logic is

00:46:10.070 --> 00:46:12.820
undecidable for three players.

00:46:12.820 --> 00:46:14.750
And you can use a crossover.

00:46:14.750 --> 00:46:17.315
And you can make this
planar graphs if you want.

00:46:20.170 --> 00:46:24.784
Any more questions
about Undecidability?

00:46:24.784 --> 00:46:26.284
AUDIENCE: Are you
ever going to give

00:46:26.284 --> 00:46:31.057
some examples of
undecidable-- like real games?

00:46:31.057 --> 00:46:31.640
PROFESSOR: No.

00:46:31.640 --> 00:46:34.290
There are no known
good examples of games.

00:46:34.290 --> 00:46:36.952
These are the games, I'm afraid.

00:46:36.952 --> 00:46:38.170
Yeah.

00:46:38.170 --> 00:46:40.040
Sorry.

00:46:40.040 --> 00:46:45.190
So I would like to switch gears
and go to the extreme opposite.

00:46:45.190 --> 00:46:48.030
Instead of Undecidability,
when there's no algorithm,

00:46:48.030 --> 00:46:50.660
let's go back to good
old-fashioned polynomial time

00:46:50.660 --> 00:46:52.300
algorithms.

00:46:52.300 --> 00:46:53.955
I think you remember what P is.

00:46:57.300 --> 00:47:01.560
But let me tell you a stronger
notion of P, which comes up

00:47:01.560 --> 00:47:03.300
in parallel algorithms.

00:47:03.300 --> 00:47:06.580
There are many different
models of parallel computing.

00:47:06.580 --> 00:47:10.680
So it's a little
bit-- you know, it's

00:47:10.680 --> 00:47:15.100
hard to write down one
good model of computation

00:47:15.100 --> 00:47:16.650
for parallel computing.

00:47:16.650 --> 00:47:18.830
But fortunately, if we're
proving lower bounds,

00:47:18.830 --> 00:47:20.830
it doesn't matter whether
our model is good.

00:47:20.830 --> 00:47:25.010
It really matters that our
model is super powerful.

00:47:25.010 --> 00:47:26.700
If we can prove
something is impossible

00:47:26.700 --> 00:47:29.950
in a super powerful model, that
means it's impossible in weaker

00:47:29.950 --> 00:47:30.790
models too.

00:47:30.790 --> 00:47:35.250
So I'm going to give you a
super powerful model called NC.

00:47:35.250 --> 00:47:37.780
So NC is Nick's class,
named after Nick Pippinger,

00:47:37.780 --> 00:47:40.360
who did a lot of
parallel algorithms.

00:47:40.360 --> 00:47:44.130
And there are a few
equivalent definitions.

00:47:44.130 --> 00:47:45.680
Let me give you two of them.

00:47:56.850 --> 00:47:59.030
I would like my
problem to be solvable.

00:47:59.030 --> 00:48:01.980
With P, we wanted things to
be solvable in poly time.

00:48:01.980 --> 00:48:04.200
So a natural
improvement is that I

00:48:04.200 --> 00:48:08.200
want to run in poly log time
for parallel algorithms,

00:48:08.200 --> 00:48:10.310
given a huge number
of processors,

00:48:10.310 --> 00:48:12.840
but not incredibly huge--
just polynomial number

00:48:12.840 --> 00:48:14.550
of processors.

00:48:14.550 --> 00:48:15.050
OK?

00:48:17.715 --> 00:48:19.840
If I was given an exponential
number of processors,

00:48:19.840 --> 00:48:22.960
I could solve SAT and all
sorts of crazy things.

00:48:22.960 --> 00:48:25.540
So shouldn't go too extreme.

00:48:25.540 --> 00:48:28.800
But let's say polynomial--
not problems but processors.

00:48:33.594 --> 00:48:35.760
Polynomial number of
processors is reasonable, maybe

00:48:35.760 --> 00:48:37.349
a little overkill, but OK.

00:48:37.349 --> 00:48:38.890
With polynomial
number of processors,

00:48:38.890 --> 00:48:40.660
I'd like to get poly log time.

00:48:40.660 --> 00:48:44.470
That's a pretty
natural, good situation.

00:48:44.470 --> 00:48:46.600
I let these processors
communicate however

00:48:46.600 --> 00:48:48.800
they want, super fast.

00:48:48.800 --> 00:48:52.415
You can think of
it as a circuit.

00:48:55.592 --> 00:48:57.050
If you're thinking
about the p-set,

00:48:57.050 --> 00:48:59.170
you'll be thinking about
small weft circuits.

00:48:59.170 --> 00:49:03.690
But here, it's just good
old-fashioned depth.

00:49:03.690 --> 00:49:05.220
We want poly log depth.

00:49:05.220 --> 00:49:09.930
That will be the running time
if every gate of the circuit

00:49:09.930 --> 00:49:12.090
can run in parallel.

00:49:12.090 --> 00:49:14.750
You still have to run in
sequence, along the depth

00:49:14.750 --> 00:49:15.250
lines.

00:49:15.250 --> 00:49:18.111
But if there are a polynomial
number of gates-- OK,

00:49:18.111 --> 00:49:20.780
that should be, of size.

00:49:20.780 --> 00:49:23.760
Polynomial number of
gates and poly log depth,

00:49:23.760 --> 00:49:27.714
then in particular, this
gives you an algorithm.

00:49:27.714 --> 00:49:29.880
Each processor just waits
for the inputs to be ready

00:49:29.880 --> 00:49:32.890
and then writes out the output
to the next gate that it--

00:49:32.890 --> 00:49:37.524
or to whatever gates it has that
it's connected to by a wire.

00:49:37.524 --> 00:49:38.940
And you get an
algorithm that runs

00:49:38.940 --> 00:49:41.023
in poly log time, polynomial
number of processors.

00:49:41.023 --> 00:49:43.190
So whichever you think
of is more intuitive.

00:49:45.950 --> 00:49:48.260
OK.

00:49:48.260 --> 00:49:50.660
So I have a small example here.

00:49:50.660 --> 00:49:54.360
Suppose you want to sort n
numbers in the comparison

00:49:54.360 --> 00:49:55.980
model.

00:49:55.980 --> 00:49:56.986
You can do that.

00:49:56.986 --> 00:49:58.610
And there are good
algorithms to do it.

00:49:58.610 --> 00:50:00.318
I will give you a not
so great algorithm.

00:50:00.318 --> 00:50:02.620
But at least it works in NC.

00:50:02.620 --> 00:50:04.730
Namely, with n
squared processors,

00:50:04.730 --> 00:50:08.910
I'm going to compare, in
parallel, all pairs of items.

00:50:08.910 --> 00:50:12.170
I'm going to compare ai
to aj for all i and j.

00:50:12.170 --> 00:50:15.120
Now I know which items
are less than which.

00:50:15.120 --> 00:50:17.200
And now, for each
item i, I basically

00:50:17.200 --> 00:50:21.715
just want to compute how many
items are smaller than it.

00:50:21.715 --> 00:50:24.340
If there are items smaller than
it-- let's say all of the items

00:50:24.340 --> 00:50:26.520
are distinct-- then
that item should

00:50:26.520 --> 00:50:29.620
go to the I-th
position in the array.

00:50:29.620 --> 00:50:33.700
So it's going to compute
this matrix, i versus j.

00:50:33.700 --> 00:50:38.670
Each one says ai is
smaller or greater than aj.

00:50:38.670 --> 00:50:41.590
And now, for a
given-- what do I say,

00:50:41.590 --> 00:50:45.210
a given row-- I want to compute
how many less than signs

00:50:45.210 --> 00:50:46.620
are in that row.

00:50:46.620 --> 00:50:49.550
This is basically computing a
sum where I view less than as 1

00:50:49.550 --> 00:50:51.320
and greater than as 0.

00:50:51.320 --> 00:50:54.890
And you can compute a sum
of n items in log n time,

00:50:54.890 --> 00:50:56.599
just by building a binary tree.

00:50:56.599 --> 00:50:58.390
I'm going to add these
two guys in parallel

00:50:58.390 --> 00:51:00.890
with these two guys, and so on.

00:51:00.890 --> 00:51:02.655
And then I compute my sum.

00:51:05.360 --> 00:51:08.000
And I can do each of
these rows in parallel.

00:51:08.000 --> 00:51:10.850
So in log n time, I can
compute all of these sums.

00:51:10.850 --> 00:51:14.420
Then I know where every item
needs to go and put it there.

00:51:14.420 --> 00:51:17.770
So this is a little overkill,
that I use a ton of processors.

00:51:17.770 --> 00:51:18.820
But still polynomial.

00:51:18.820 --> 00:51:22.140
So in n square processors,
I can easily, in log n time,

00:51:22.140 --> 00:51:22.980
sort n numbers.

00:51:22.980 --> 00:51:24.480
There are more
efficient algorithms.

00:51:24.480 --> 00:51:27.380
But the point is when
you have a par-- when

00:51:27.380 --> 00:51:30.540
there is a parallel algorithm,
in this powerful model,

00:51:30.540 --> 00:51:33.160
you can do it without
too much effort.

00:51:33.160 --> 00:51:34.950
But what we're
going to show, here,

00:51:34.950 --> 00:51:41.140
is something called
P-hardness, which,

00:51:41.140 --> 00:51:44.780
assuming not all problems
can be solved in this--

00:51:44.780 --> 00:51:46.970
not all polynomial time
algorithms can be solved

00:51:46.970 --> 00:51:50.770
in this model, these
problems can't.

00:51:50.770 --> 00:51:52.680
Just like NP hardness.

00:51:52.680 --> 00:51:54.520
Note, in particular,
NC is contained

00:51:54.520 --> 00:51:56.890
in P. If I had
such an algorithm,

00:51:56.890 --> 00:51:58.290
I could simulate this algorithm.

00:51:58.290 --> 00:52:00.497
Because I have parallelism
only polynomial,

00:52:00.497 --> 00:52:02.830
I could simulate the whole
algorithm in polynomial time,

00:52:02.830 --> 00:52:03.330
still.

00:52:03.330 --> 00:52:06.160
So this is stronger
than being in P.

00:52:06.160 --> 00:52:12.360
And P hardness means
that all problems in NC

00:52:12.360 --> 00:52:17.970
can be reduced in the
usual Karp-style reduction,

00:52:17.970 --> 00:52:19.220
in P reduction.

00:52:19.220 --> 00:52:24.160
But now the reduction must
be a parallel time reduction.

00:52:24.160 --> 00:52:33.300
So it must be an NC
algorithm to your problem.

00:52:38.050 --> 00:52:40.940
So P-hard means you're as
hard as all problems in P.

00:52:40.940 --> 00:52:43.020
And reductions must be
parallel algorithms.

00:52:43.020 --> 00:52:45.620
They must in NC.

00:52:45.620 --> 00:52:50.600
And so this implies
that you're not in NC,

00:52:50.600 --> 00:52:58.200
assuming NC does
not equal P, which

00:52:58.200 --> 00:53:01.810
is another standard complexity
theoretic assumption.

00:53:01.810 --> 00:53:04.900
Makes sense-- not all problems
should be parallelizable.

00:53:04.900 --> 00:53:07.740
So in particular,
P-hard problems

00:53:07.740 --> 00:53:09.090
would be such problems.

00:53:09.090 --> 00:53:13.580
And P-complete, of course,
means you're in P and P-hard.

00:53:13.580 --> 00:53:14.080
OK.

00:53:17.912 --> 00:53:19.912
AUDIENCE: Shouldn't it
be that all problems in P

00:53:19.912 --> 00:53:21.856
can be reduced by
an NC algorithm?

00:53:25.080 --> 00:53:26.622
PROFESSOR: Yes.

00:53:26.622 --> 00:53:27.490
Thank you.

00:53:30.640 --> 00:53:32.240
All problems in P. Yeah.

00:53:32.240 --> 00:53:32.880
Cool.

00:53:32.880 --> 00:53:35.670
So all problems, presumably
including the ones

00:53:35.670 --> 00:53:39.236
that are hard to parallelize--
not just the NC ones-- can

00:53:39.236 --> 00:53:40.360
be reduced to your problem.

00:53:40.360 --> 00:53:45.380
And so that means your problem
is probably in P minus NC.

00:53:45.380 --> 00:53:45.880
Good.

00:54:02.500 --> 00:54:16.590
So let me give you some
base P-complete problems,

00:54:16.590 --> 00:54:21.410
starting with a very natural
one-- general machine

00:54:21.410 --> 00:54:23.865
simulation, sequential machine.

00:54:31.800 --> 00:54:32.300
OK?

00:54:32.300 --> 00:54:40.060
So given a sequential algorithm,
such as a Turing machine,

00:54:40.060 --> 00:54:42.220
run it for t steps.

00:54:42.220 --> 00:54:44.110
Now, this is a
little bit subtle.

00:54:52.932 --> 00:54:53.890
Let me write this down.

00:54:53.890 --> 00:54:55.223
And then I'm going to modify it.

00:54:59.390 --> 00:55:03.955
Does the algorithm, say,
halt within t steps?

00:55:08.010 --> 00:55:09.820
Or does it keep running
for longer than t?

00:55:09.820 --> 00:55:11.653
So this is a version
of the halting problem.

00:55:11.653 --> 00:55:15.170
I mean, we-- same thing with
a nondeterministic Turing

00:55:15.170 --> 00:55:16.100
machine.

00:55:16.100 --> 00:55:20.157
Running for polynomial time was
our prototype for NP problems.

00:55:20.157 --> 00:55:21.740
We've done this kind
of problem a lot.

00:55:21.740 --> 00:55:23.489
We did a similar thing with W1.

00:55:23.489 --> 00:55:24.530
It was a run for k steps.

00:55:24.530 --> 00:55:26.410
And k was a parameter.

00:55:26.410 --> 00:55:31.740
I want this problem to be in
P. But if I phrase it this way,

00:55:31.740 --> 00:55:35.560
it would be X time complete
because t could represent

00:55:35.560 --> 00:55:37.580
an exponentially large value.

00:55:37.580 --> 00:55:40.190
So what I want is for
this to be encoded

00:55:40.190 --> 00:55:43.307
in unary, which usually,
we're not supposed to do.

00:55:43.307 --> 00:55:45.140
But here, I'm going to
explicitly say, look,

00:55:45.140 --> 00:55:49.910
t is bounded by a polynomial
in the size of the machine--

00:55:49.910 --> 00:55:53.230
or equivalently, it's
written in unary.

00:55:53.230 --> 00:55:55.970
And now I can do this
in polynomial time.

00:55:55.970 --> 00:55:57.870
Because I have t
steps to do it, I'll

00:55:57.870 --> 00:55:59.930
just run the machine t steps.

00:55:59.930 --> 00:56:00.430
OK?

00:56:00.430 --> 00:56:04.100
So this is in P. And if
you believe anything is not

00:56:04.100 --> 00:56:06.420
parallelizable, then this
shouldn't be because this

00:56:06.420 --> 00:56:07.760
lets you simulate all things.

00:56:07.760 --> 00:56:11.636
So pretty easy to reduce
all problems in P.

00:56:11.636 --> 00:56:14.010
If they're in P, that means
there's an algorithm to solve

00:56:14.010 --> 00:56:15.320
them, sequential algorithm.

00:56:15.320 --> 00:56:16.449
So you plug it in here.

00:56:16.449 --> 00:56:18.240
It's going to run for
only polynomial time.

00:56:18.240 --> 00:56:20.020
So you can set t
to that polynomial.

00:56:20.020 --> 00:56:21.970
And boom.

00:56:21.970 --> 00:56:26.430
You know, the algorithm
halting is it's answering, yes.

00:56:26.430 --> 00:56:29.571
Or you could change this
to returning s or whatever.

00:56:32.950 --> 00:56:33.450
OK?

00:56:33.450 --> 00:56:35.660
So that's actually how
you prove this problem is

00:56:35.660 --> 00:56:38.225
P-hard, or actually P-complete.

00:56:38.225 --> 00:56:40.058
AUDIENCE: Is there any
problem with symmetry

00:56:40.058 --> 00:56:41.522
between yea and
no answers, here?

00:56:44.240 --> 00:56:46.780
PROFESSOR: Here, yes
and no are the same.

00:56:46.780 --> 00:56:47.340
Yeah.

00:56:47.340 --> 00:56:48.900
Unlike NP.

00:56:48.900 --> 00:56:50.582
NP had an asymmetry
between yes and no.

00:56:50.582 --> 00:56:52.290
So I could also change
this to return no.

00:56:52.290 --> 00:56:54.295
That would also be as hard.

00:56:54.295 --> 00:56:54.794
Yeah.

00:57:05.900 --> 00:57:07.990
But of course, this is
not a very useful problem.

00:57:07.990 --> 00:57:09.115
It's just a starting point.

00:57:09.115 --> 00:57:13.470
And it's a very natural
P-complete problem.

00:57:13.470 --> 00:57:16.890
More useful for reductions
are these circuit

00:57:16.890 --> 00:57:21.645
value problems, CVP.

00:57:28.100 --> 00:57:30.660
This is going to be
like circuit set.

00:57:30.660 --> 00:57:33.460
So with circuit set, we were
given an acyclic Boolean

00:57:33.460 --> 00:57:39.431
circuit which had one output.

00:57:39.431 --> 00:57:41.430
Or maybe we're given a
particular output we care

00:57:41.430 --> 00:57:42.684
about.

00:57:42.684 --> 00:57:45.100
And we wanted to know whether
there was some input setting

00:57:45.100 --> 00:57:46.460
that made the output true.

00:57:46.460 --> 00:57:48.180
Here, we are given
the input setting.

00:57:55.920 --> 00:58:00.020
So I mean, the circuit actually
has the inputs written down,

00:58:00.020 --> 00:58:02.250
like 0, 1, 1.

00:58:02.250 --> 00:58:05.090
And then let's say
we take an AND,

00:58:05.090 --> 00:58:08.310
and then we take an OR,
something like that.

00:58:08.310 --> 00:58:10.800
And we want to know, what
is this thing at the output?

00:58:10.800 --> 00:58:12.841
Of course, this can be
solved in polynomial time.

00:58:12.841 --> 00:58:15.030
You compute this
AND, and you get a 0.

00:58:15.030 --> 00:58:16.285
This was a 1.

00:58:16.285 --> 00:58:18.840
So you compute this
OR, and you get 1.

00:58:18.840 --> 00:58:20.205
So the answer is 1.

00:58:20.205 --> 00:58:20.705
OK?

00:58:20.705 --> 00:58:23.940
And you can do that
in linear time.

00:58:23.940 --> 00:58:25.730
But to do it parallel
is really hard

00:58:25.730 --> 00:58:28.290
because it's really
hard to predict what

00:58:28.290 --> 00:58:29.570
these inputs are going to be.

00:58:29.570 --> 00:58:31.500
So you can't do
anything on this gate

00:58:31.500 --> 00:58:34.100
until the inputs are ready.

00:58:34.100 --> 00:58:38.040
So presumably, this circuit
will not have poly log depth.

00:58:38.040 --> 00:58:40.480
Otherwise, it isn't in NC.

00:58:40.480 --> 00:58:43.070
But if you have a really large
debt circuit, simulating--

00:58:43.070 --> 00:58:47.180
running it in parallel is
just as hard as this problem.

00:58:47.180 --> 00:58:50.190
So you can reduce a
general machine simulation

00:58:50.190 --> 00:58:51.160
to a circuit value.

00:58:51.160 --> 00:58:53.240
And the standard way
of converting machines

00:58:53.240 --> 00:58:56.550
into circuits, that's the
electrical engineering problem.

00:58:56.550 --> 00:58:57.050
OK.

00:58:57.050 --> 00:58:58.040
What was the question?

00:58:58.040 --> 00:58:59.270
Is the output true?

00:59:06.490 --> 00:59:07.560
OK.

00:59:07.560 --> 00:59:09.630
Now, there are
many special cases

00:59:09.630 --> 00:59:11.120
of this that are also hard.

00:59:11.120 --> 00:59:15.230
For example, NAM CVP.

00:59:15.230 --> 00:59:15.730
OK.

00:59:15.730 --> 00:59:17.580
We know how to build
computers out of NAND.

00:59:17.580 --> 00:59:20.030
We know how to build
computers out of NOR.

00:59:20.030 --> 00:59:20.530
Cool.

00:59:20.530 --> 00:59:23.570
So that's easy.

00:59:23.570 --> 00:59:26.750
More interesting
is monotone CVP.

00:59:29.660 --> 00:59:33.510
So in monotone CVP, you
just have AND and OR gates.

00:59:33.510 --> 00:59:37.500
You don't have negation or
an AND or an OR or an XOR.

00:59:37.500 --> 00:59:38.770
Those sorts of things.

00:59:38.770 --> 00:59:41.200
This is also hard, essentially.

00:59:41.200 --> 00:59:43.920
By dual-rail logic, representing
the true and the false

00:59:43.920 --> 00:59:46.720
as separate wires and
manipulating them,

00:59:46.720 --> 00:59:48.600
you can get this to be hard.

00:59:48.600 --> 00:59:50.670
Also kind of similar
to constraint logic.

00:59:50.670 --> 00:59:52.316
OK?

00:59:52.316 --> 00:59:55.320
But I won't prove it here.

00:59:55.320 --> 00:59:59.310
A little stronger is
alternating monotone CVP.

01:00:01.870 --> 01:00:10.680
This alternates AND
OR down any path.

01:00:10.680 --> 01:00:14.970
So if you take a path from
an input bit to the output,

01:00:14.970 --> 01:00:17.860
it alternates AND
OR, AND OR, AND OR.

01:00:17.860 --> 01:00:20.940
And furthermore, we can
assume that it starts and ends

01:00:20.940 --> 01:00:21.440
with OR.

01:00:25.270 --> 01:00:26.950
It's nice to nail this down.

01:00:26.950 --> 01:00:29.650
It's not hard to prove.

01:00:29.650 --> 01:00:32.670
But I will prove it in a
moment, once I tell you

01:00:32.670 --> 01:00:37.691
a general enough version
that I want to analyze.

01:00:37.691 --> 01:00:39.690
This will just let us
worry about fewer gadgets.

01:00:39.690 --> 01:00:42.650
So up here, we had to think
about all Boolean gates.

01:00:42.650 --> 01:00:44.480
Now we just have to
think about AND and OR.

01:00:44.480 --> 01:00:46.354
And we can always assume
the output of an AND

01:00:46.354 --> 01:00:48.680
is the input of an
OR, and vice versa,

01:00:48.680 --> 01:00:51.640
and that we only need to
connect inputs to OR gates

01:00:51.640 --> 01:00:53.770
and not like this
picture, and we only

01:00:53.770 --> 01:00:56.815
have to get the output
from an OR gate.

01:00:56.815 --> 01:00:59.190
So it reduces the number of
cases we need to worry about.

01:01:04.340 --> 01:01:04.840
Yeah?

01:01:04.840 --> 01:01:07.709
AUDIENCE: So is this
with bounded fanin?

01:01:07.709 --> 01:01:08.750
PROFESSOR: Good question.

01:01:15.040 --> 01:01:18.810
Basically, bounded fanin
doesn't matter with this model.

01:01:18.810 --> 01:01:27.490
So usually, when NC is defined,
it's bounded fanin and fanout.

01:01:27.490 --> 01:01:28.930
And there's another
class, called

01:01:28.930 --> 01:01:32.960
AC, which is when you have
unbounded fanouts and fanin,

01:01:32.960 --> 01:01:34.160
let's say.

01:01:34.160 --> 01:01:36.762
But that only hurts
us by a log factor.

01:01:36.762 --> 01:01:38.720
So it matters if you're
worried about something

01:01:38.720 --> 01:01:43.590
called AC0 and NC0, when this is
0 and you want constant height.

01:01:43.590 --> 01:01:45.730
AUDIENCE: It matters for
alternation, as well.

01:01:45.730 --> 01:01:47.063
PROFESSOR: Please wait, I guess.

01:01:49.410 --> 01:01:51.610
It won't matter, is the answer.

01:01:51.610 --> 01:01:56.422
AUDIENCE: Is this the only
setting of starting and ending

01:01:56.422 --> 01:01:58.690
that works?

01:01:58.690 --> 01:01:59.470
PROFESSOR: Sorry?

01:01:59.470 --> 01:02:01.261
AUDIENCE: Starting and
ending with both AND

01:02:01.261 --> 01:02:02.220
or starting with AND?

01:02:02.220 --> 01:02:02.750
PROFESSOR: Oh, yeah.

01:02:02.750 --> 01:02:04.575
I think you could
also make this an AND,

01:02:04.575 --> 01:02:06.497
although I haven't checked that.

01:02:06.497 --> 01:02:08.330
I don't think it's
critical that this is OR.

01:02:08.330 --> 01:02:11.172
But you could probably do one
of them in OR, one of them

01:02:11.172 --> 01:02:12.680
in AND-- all of
those combinations.

01:02:12.680 --> 01:02:14.822
But this is the one
I've seen proved.

01:02:14.822 --> 01:02:16.280
We'd need to check
the other cases.

01:02:16.280 --> 01:02:17.363
But I think it's not hard.

01:02:21.570 --> 01:02:24.290
This is called AM2CVP.

01:02:27.420 --> 01:02:30.370
Great acronyms.

01:02:30.370 --> 01:02:33.320
Every gate has
fanin2 and fanout2.

01:02:33.320 --> 01:02:36.630
So in particular, bounded
but also nice and uniform.

01:02:36.630 --> 01:02:38.820
Every single-- not less
than or equal to 2.

01:02:38.820 --> 01:02:41.424
This is exactly 2.

01:02:41.424 --> 01:02:42.080
OK?

01:02:42.080 --> 01:02:43.650
We'll prove that.

01:02:43.650 --> 01:02:50.980
And even stronger,
synchronous AM2CVP.

01:02:54.870 --> 01:02:58.060
I prefer AVP, personally.

01:02:58.060 --> 01:02:59.085
So this is SAM2CVP.

01:03:03.970 --> 01:03:06.870
Synchronous means that all
of the inputs of the gate

01:03:06.870 --> 01:03:09.270
are available at
exactly the same time.

01:03:09.270 --> 01:03:14.360
If you imagine running all of
the gates of depth i at time i,

01:03:14.360 --> 01:03:16.270
then you can do that.

01:03:16.270 --> 01:03:18.595
At time i, all gates of
depth i will be ready.

01:03:18.595 --> 01:03:19.970
They'll have all
of their inputs.

01:03:19.970 --> 01:03:24.430
In other words, a gate of
depth i has one of its inputs

01:03:24.430 --> 01:03:25.530
at depth i, minus 1.

01:03:25.530 --> 01:03:27.840
But in the synchronous
circuit, both of the inputs

01:03:27.840 --> 01:03:29.710
will have depth i, minus 1.

01:03:29.710 --> 01:03:33.010
And so at time i, you'll
actually be ready to do it.

01:03:33.010 --> 01:03:35.480
This is useful, in
particular, for things

01:03:35.480 --> 01:03:40.390
like constraint logic and
other constructions, as well.

01:03:40.390 --> 01:03:41.880
One more.

01:03:41.880 --> 01:03:44.179
Planar CVP.

01:03:44.179 --> 01:03:45.720
I don't know how
many of these things

01:03:45.720 --> 01:03:47.270
you can import into
the planar case.

01:03:47.270 --> 01:03:51.070
Probably many of them.

01:03:51.070 --> 01:03:54.960
But just like planar circuit
set, out of NAND and NOR,

01:03:54.960 --> 01:03:56.680
for example, you can
build crossovers.

01:03:56.680 --> 01:04:00.870
And so planar circuits
are also hard.

01:04:00.870 --> 01:04:05.200
But actually, not all
of them because planar

01:04:05.200 --> 01:04:13.420
monotone CVP is in NC.

01:04:13.420 --> 01:04:16.650
So you can't take the
monotone AND OR- ness

01:04:16.650 --> 01:04:20.650
with planarity, which is kind
of annoying because that problem

01:04:20.650 --> 01:04:22.880
can be done in parallel.

01:04:22.880 --> 01:04:25.030
But planar with an AND--
then you've got negation.

01:04:25.030 --> 01:04:28.390
And you can build a crossover.

01:04:28.390 --> 01:04:28.890
OK.

01:04:28.890 --> 01:04:30.306
Let me prove some
of these things.

01:04:30.306 --> 01:04:32.500
This was to give you a
flavor for what's hard.

01:04:32.500 --> 01:04:36.820
Still, all of these
problems up are P-complete.

01:04:42.640 --> 01:04:45.420
And we're going to do it
in a series of reductions.

01:04:45.420 --> 01:04:54.245
So first, let's deal with
starting and ending with OR.

01:04:54.245 --> 01:04:55.620
So this is the
part you'd switch.

01:04:55.620 --> 01:04:57.300
If you want to start
or end with an AND,

01:04:57.300 --> 01:04:59.210
it should be no problem.

01:04:59.210 --> 01:05:00.600
So this is an input bit.

01:05:00.600 --> 01:05:03.300
Either 0 or 1, they're going
to be drawn with squares.

01:05:03.300 --> 01:05:04.680
Oh, I should
mention, by the way,

01:05:04.680 --> 01:05:07.824
there's a textbook
devoted to P completeness.

01:05:07.824 --> 01:05:08.740
It's a short textbook.

01:05:08.740 --> 01:05:09.850
But it's a nice read.

01:05:09.850 --> 01:05:10.730
And it's online.

01:05:10.730 --> 01:05:13.440
So I linked to it
from the website now.

01:05:13.440 --> 01:05:16.160
So if you want to learn a little
more, check out that book.

01:05:16.160 --> 01:05:18.420
These are figures
from that book.

01:05:18.420 --> 01:05:24.560
So if I have some input
being sent to some gates,

01:05:24.560 --> 01:05:26.570
I'm just going to
put an OR there.

01:05:26.570 --> 01:05:28.860
And let's say i OR
that bit with itself.

01:05:28.860 --> 01:05:31.100
So now everything
starts with an OR.

01:05:31.100 --> 01:05:32.386
Done.

01:05:32.386 --> 01:05:34.010
If I want to make
things end with an OR

01:05:34.010 --> 01:05:36.940
and they end with an AND,
I'll just put an OR gate.

01:05:36.940 --> 01:05:39.090
I don't know why here
we use only one input,

01:05:39.090 --> 01:05:40.510
here we put two inputs.

01:05:40.510 --> 01:05:43.380
But I could have just
put one input up there.

01:05:43.380 --> 01:05:45.489
I'm allowing, for now,
one input OR gate.

01:05:45.489 --> 01:05:46.780
So I'm going to fix that later.

01:05:46.780 --> 01:05:47.280
Question?

01:05:47.280 --> 01:05:49.770
AUDIENCE: [INAUDIBLE]

01:05:49.770 --> 01:05:51.640
PROFESSOR: Coming soon.

01:05:51.640 --> 01:05:54.722
So this is just to
start and end with ORs.

01:05:54.722 --> 01:05:56.930
Next thing I'd like to do
is make things alternating.

01:05:56.930 --> 01:06:00.780
So if I have two gates--
actually, before I do this,

01:06:00.780 --> 01:06:01.780
I need to do this later.

01:06:01.780 --> 01:06:03.240
It's important to get
the sequence right.

01:06:03.240 --> 01:06:05.420
First, I want to make sure
the fanout is less than

01:06:05.420 --> 01:06:07.310
or equal to 2, in this way.

01:06:07.310 --> 01:06:08.910
This is a standard trick.

01:06:08.910 --> 01:06:12.160
If I have large fanout, I
just build a binary tree.

01:06:12.160 --> 01:06:13.940
And you can put
ORs or ANDs here.

01:06:13.940 --> 01:06:14.920
There's only one input.

01:06:14.920 --> 01:06:16.980
So it doesn't do anything to it.

01:06:16.980 --> 01:06:19.480
But now I have
fanout, at most, 2.

01:06:19.480 --> 01:06:22.700
Fanin is whatever.

01:06:22.700 --> 01:06:24.800
Did we deal with large fanin?

01:06:24.800 --> 01:06:25.300
Not yet.

01:06:28.910 --> 01:06:30.160
So I'm going to do that first.

01:06:30.160 --> 01:06:32.374
This will make lots of
ORs next to each other.

01:06:32.374 --> 01:06:35.040
But then whenever I have two ORs
or two ANDs next to each other,

01:06:35.040 --> 01:06:37.010
I just add the opposite
gate, in between.

01:06:37.010 --> 01:06:37.510
OK.

01:06:37.510 --> 01:06:40.570
So now it's alternating
fanout, at most, 2.

01:06:40.570 --> 01:06:43.870
So we've gotten this
property in a weak sense,

01:06:43.870 --> 01:06:45.110
with less than or equal to 2.

01:06:45.110 --> 01:06:48.140
We're going to fix the 1s later.

01:06:48.140 --> 01:06:49.610
We haven't dealt with this yet.

01:06:52.570 --> 01:06:54.790
I assumed-- sorry-- that
I'm starting with monotones.

01:06:54.790 --> 01:06:56.080
So I just have ANDs and ORs.

01:06:56.080 --> 01:06:57.475
No indication.

01:06:57.475 --> 01:07:00.552
I'm reducing from monotone
CVP to these other problems.

01:07:00.552 --> 01:07:02.260
I've got alternation,
starting and ending

01:07:02.260 --> 01:07:05.260
with or and fanout, at
most, 2, at this point.

01:07:05.260 --> 01:07:10.460
Next reduction is to
make fanin exactly 2.

01:07:10.460 --> 01:07:12.060
So yeah.

01:07:12.060 --> 01:07:14.220
I guess I didn't write it.

01:07:14.220 --> 01:07:16.950
But we can use the same
trick on the other side.

01:07:16.950 --> 01:07:19.210
If you have fanin
larger than 2, then you

01:07:19.210 --> 01:07:22.060
can just take ANDs
and ANDs and ANDs.

01:07:22.060 --> 01:07:24.540
So you can also get
fanin, at most, 2.

01:07:24.540 --> 01:07:27.140
Now if I have fanin 1, which
I've used all over the place,

01:07:27.140 --> 01:07:29.930
now I'm going to get rid of
it in two different ways.

01:07:29.930 --> 01:07:32.820
If I have an OR gate
with one input that

01:07:32.820 --> 01:07:35.290
happens to be an
AND or original bit,

01:07:35.290 --> 01:07:37.660
I'll just add in
another input of 0.

01:07:37.660 --> 01:07:39.410
That won't affect things.

01:07:39.410 --> 01:07:43.380
And if I have an AND bit, I
would like to put a 1 here.

01:07:43.380 --> 01:07:46.380
But I'm not allowed to feed a
number-- an input-- directly

01:07:46.380 --> 01:07:49.550
to an AND gate because I want
to preserve the property that I

01:07:49.550 --> 01:07:50.680
start and end with ORs.

01:07:50.680 --> 01:07:52.440
So this is one thing
that would be--

01:07:52.440 --> 01:07:54.981
you'd have to tweak a little
bit if you want to start and end

01:07:54.981 --> 01:07:55.750
with ANDs.

01:07:55.750 --> 01:07:57.949
But you can do, I
think, a similar trick.

01:07:57.949 --> 01:07:59.740
I want to build the 1
bit using an OR gate.

01:07:59.740 --> 01:08:01.840
So I take two one
bits, OR them together.

01:08:01.840 --> 01:08:03.400
Now I have a 1
bit fed into here.

01:08:03.400 --> 01:08:05.242
And then that will
just pass through.

01:08:05.242 --> 01:08:05.780
OK?

01:08:05.780 --> 01:08:07.550
So now I have fanin, exactly 2.

01:08:07.550 --> 01:08:08.555
No 1s.

01:08:08.555 --> 01:08:10.680
You can imagine this is
useful when you're actually

01:08:10.680 --> 01:08:12.536
building gadgets
because then you don't

01:08:12.536 --> 01:08:13.660
have to do all of the work.

01:08:13.660 --> 01:08:14.535
AUDIENCE: [INAUDIBLE]

01:08:18.973 --> 01:08:20.889
PROFESSOR: I haven't
dealt with fanout 2, yet.

01:08:20.889 --> 01:08:22.979
At this point, just fanin 2.

01:08:22.979 --> 01:08:26.711
So variables-- some of them
still only have fanout 1.

01:08:26.711 --> 01:08:27.960
But they will have at most, 2.

01:08:27.960 --> 01:08:31.590
So now we're going to
do fanout, exactly 2.

01:08:31.590 --> 01:08:35.410
So what I'm going to
do is take my circuit,

01:08:35.410 --> 01:08:38.109
make two copies of it.

01:08:38.109 --> 01:08:40.660
There's the primed copy
and the original copy.

01:08:40.660 --> 01:08:41.630
OK?

01:08:41.630 --> 01:08:46.100
So now I just need to hook
things how I want them.

01:08:46.100 --> 01:08:49.250
The inputs, which
are not drawn here--

01:08:49.250 --> 01:08:53.425
if I have an input out
degree 1, then I'll

01:08:53.425 --> 01:08:54.620
merge them into one copy.

01:08:54.620 --> 01:08:55.834
Then I'll have out degree 2.

01:08:55.834 --> 01:08:57.250
If they already
have out degree 2,

01:08:57.250 --> 01:08:58.501
just leave them as two copies.

01:08:58.501 --> 01:08:59.000
OK?

01:08:59.000 --> 01:09:03.060
So now all of the inputs have
out degree 2, or fanout 2.

01:09:03.060 --> 01:09:06.092
If I have an AND gate
with out degree 2, again,

01:09:06.092 --> 01:09:06.800
I don't touch it.

01:09:06.800 --> 01:09:08.300
I'll leave them as two copies.

01:09:08.300 --> 01:09:13.479
If I have an AND gate with
one-- a fanout of one-- then

01:09:13.479 --> 01:09:15.109
here are the two copies of it.

01:09:15.109 --> 01:09:19.121
I basically want to add an extra
output that gets thrown away.

01:09:19.121 --> 01:09:20.620
So because I have
to end with an OR,

01:09:20.620 --> 01:09:21.600
I'm going to put it OR here.

01:09:21.600 --> 01:09:22.683
And then that's an output.

01:09:22.683 --> 01:09:25.090
It's not the output that we're
asking the question about,

01:09:25.090 --> 01:09:28.370
where I want to know, does
the output become true?

01:09:28.370 --> 01:09:29.419
That's a specific output.

01:09:29.419 --> 01:09:30.960
So for this reduction
I need to allow

01:09:30.960 --> 01:09:33.560
there to be multiple
outputs in my circuit,

01:09:33.560 --> 01:09:36.649
but only one of
them of interest.

01:09:36.649 --> 01:09:37.910
OK?

01:09:37.910 --> 01:09:39.930
And the rest is
connected as before.

01:09:39.930 --> 01:09:43.350
So now these guys have fanout 2.

01:09:43.350 --> 01:09:45.350
If I have an OR gate
with one output,

01:09:45.350 --> 01:09:48.470
this is a little trickier
because I want to end with ORs,

01:09:48.470 --> 01:09:49.597
I guess.

01:09:49.597 --> 01:09:51.180
We're going to combine
these two bits.

01:09:51.180 --> 01:09:52.179
And I have to alternate.

01:09:52.179 --> 01:09:55.390
So next thing is I
have to go to an AND.

01:09:55.390 --> 01:09:57.220
This also has to
have two outputs.

01:09:57.220 --> 01:10:01.760
So I'm going to put one of
them here and one of them here.

01:10:01.760 --> 01:10:03.261
These guys need two
inputs because I

01:10:03.261 --> 01:10:05.593
don't want to [INAUDIBLE]
with the two input conditions.

01:10:05.593 --> 01:10:06.862
So I add another bit.

01:10:06.862 --> 01:10:07.570
It could be 0, 1.

01:10:07.570 --> 01:10:08.350
It doesn't matter.

01:10:08.350 --> 01:10:09.350
Feed it to both of them.

01:10:09.350 --> 01:10:10.890
Now this has out degree 2.

01:10:10.890 --> 01:10:12.660
These have in degree 2.

01:10:12.660 --> 01:10:13.660
And this is an output.

01:10:13.660 --> 01:10:18.034
So output is-- you could think
of there as being two of them.

01:10:18.034 --> 01:10:18.958
Yeah?

01:10:18.958 --> 01:10:20.833
AUDIENCE: Can you chain
the outputs together,

01:10:20.833 --> 01:10:22.192
so that there's a 1 output?

01:10:22.192 --> 01:10:24.650
PROFESSOR: Oh, combine the
different outputs together?

01:10:24.650 --> 01:10:26.316
AUDIENCE: If you have
fanout, exactly 2,

01:10:26.316 --> 01:10:28.761
and fanin, exactly
2, doesn't that

01:10:28.761 --> 01:10:32.994
mean that you're preserving
the number of inputs,

01:10:32.994 --> 01:10:38.090
So that you can't reduce
those extra outputs to 1?

01:10:38.090 --> 01:10:38.980
PROFESSOR: Yes.

01:10:38.980 --> 01:10:39.480
Good.

01:10:39.480 --> 01:10:42.980
So I think if we tried to
combine all of the outputs

01:10:42.980 --> 01:10:45.850
together, we'd end up
with a similar problem.

01:10:45.850 --> 01:10:48.100
And we'd basically have to
do this construction again,

01:10:48.100 --> 01:10:50.580
and then produce more outputs.

01:10:50.580 --> 01:10:52.101
Good.

01:10:52.101 --> 01:10:52.600
Yeah.

01:10:52.600 --> 01:10:56.422
So we violate fanin 2,
obviously, at the inputs.

01:10:56.422 --> 01:10:57.130
But you're right.

01:10:57.130 --> 01:10:59.480
After the input level,
the number of lines

01:10:59.480 --> 01:11:01.250
should be preserved.

01:11:01.250 --> 01:11:02.050
OK.

01:11:02.050 --> 01:11:02.640
So never mind.

01:11:02.640 --> 01:11:03.870
We do need multiple outputs.

01:11:03.870 --> 01:11:06.430
And exactly one
of them is marked

01:11:06.430 --> 01:11:10.014
as the one we care about,
whether an output's true.

01:11:10.014 --> 01:11:11.670
Is that the end?

01:11:11.670 --> 01:11:12.550
Yes.

01:11:12.550 --> 01:11:18.450
At this point, we've proved
AM2CVP is P-complete.

01:11:18.450 --> 01:11:19.920
OK.

01:11:19.920 --> 01:11:20.660
So one more.

01:11:20.660 --> 01:11:23.190
Reduction is for the
synchronous case.

01:11:25.870 --> 01:11:27.695
This is cool.

01:11:30.630 --> 01:11:33.255
Let me, maybe, first
say what we're doing.

01:11:36.880 --> 01:11:39.886
So for the
synchronous reduction,

01:11:39.886 --> 01:11:42.260
we're going to make n over 2
copies of the circuit, where

01:11:42.260 --> 01:11:43.345
n is the number of gates.

01:11:50.160 --> 01:11:52.770
At a high level, that's
what we're doing.

01:11:52.770 --> 01:11:54.570
And basically,
the i-th copy will

01:11:54.570 --> 01:11:56.200
feed into the i plus 1st copy.

01:11:56.200 --> 01:11:59.860
Well, not quite, because we
want to alternate ANDs and ORs.

01:11:59.860 --> 01:12:06.470
So in the i-th copy-- the
i-th copy of the circuit

01:12:06.470 --> 01:12:14.640
will be the depth
levels 2i and 2i plus 1,

01:12:14.640 --> 01:12:18.110
in the final circuit
that I'm producing, where

01:12:18.110 --> 01:12:21.545
these are ANDs and inputs.

01:12:25.690 --> 01:12:28.781
And this level is
going to be ORs.

01:12:28.781 --> 01:12:29.280
OK?

01:12:29.280 --> 01:12:32.480
So basically, I want to take
an AND level and an OR level

01:12:32.480 --> 01:12:34.810
from one copy, then an
AND level and an OR level

01:12:34.810 --> 01:12:37.800
from the next copy, and so on.

01:12:37.800 --> 01:12:40.419
The inputs are a
little more subtle.

01:12:40.419 --> 01:12:41.960
But in particular,
I'm at least going

01:12:41.960 --> 01:12:43.335
to make the copies
of the inputs.

01:12:43.335 --> 01:12:46.280
And I'm going to
change them later.

01:12:46.280 --> 01:12:51.250
And so the outputs of
the ORs from one copy

01:12:51.250 --> 01:12:55.660
will go to the inputs of
the ANDs in the next copy,

01:12:55.660 --> 01:12:58.200
and vice versa.

01:12:58.200 --> 01:13:01.740
So the outputs from the ANDs
stay within the same copy.

01:13:01.740 --> 01:13:04.660
And then the outputs from
here go to the next copy.

01:13:04.660 --> 01:13:08.200
Basically, this will force
synchronization, in a sense.

01:13:08.200 --> 01:13:11.260
Now, the one tricky
part is the inputs.

01:13:11.260 --> 01:13:16.490
I want the i-th copy to be
triggered at time 2i, exactly.

01:13:16.490 --> 01:13:19.220
And so for that, I can't
just have the inputs.

01:13:19.220 --> 01:13:21.520
Maybe some of the gates
in there take an input

01:13:21.520 --> 01:13:24.120
from-- sort of straight.

01:13:24.120 --> 01:13:26.750
I need to delay that
input from coming

01:13:26.750 --> 01:13:32.060
and still preserve fanin and
fanout 2 and alternation.

01:13:32.060 --> 01:13:36.910
So to do that, I'm going
to use this gadget.

01:13:36.910 --> 01:13:40.420
So I just have the
same bit written twice.

01:13:40.420 --> 01:13:42.540
And then I OR them
with themselves

01:13:42.540 --> 01:13:44.580
and then AND then with
themselves and OR them.

01:13:44.580 --> 01:13:44.830
OK?

01:13:44.830 --> 01:13:45.840
It seems innocent enough.

01:13:45.840 --> 01:13:48.090
That latter obviously will
not change any of the bits.

01:13:48.090 --> 01:13:52.420
So just duplicating those
bits at every time step.

01:13:52.420 --> 01:13:54.570
It's all about timing here.

01:13:54.570 --> 01:13:55.800
And now here's the fun thing.

01:13:55.800 --> 01:14:00.386
If this gate needs
this bit, obviously, I

01:14:00.386 --> 01:14:01.510
can just take it out, here.

01:14:01.510 --> 01:14:05.470
That will still
preserve fanout 2, here.

01:14:05.470 --> 01:14:09.220
And if I'm taking
one bit from here,

01:14:09.220 --> 01:14:11.680
I'm going to have to
throw away another bit.

01:14:11.680 --> 01:14:15.700
And magically-- this is very
cool-- if I throw away a bit

01:14:15.700 --> 01:14:18.350
here, it doesn't matter
what that bit value is.

01:14:18.350 --> 01:14:20.430
This will still be X2.

01:14:24.100 --> 01:14:30.470
You can think of the two cases--
either x2 is 0, in which case

01:14:30.470 --> 01:14:33.780
this is 0, and then it doesn't
matter what this bit is.

01:14:33.780 --> 01:14:34.640
It will output 0.

01:14:34.640 --> 01:14:35.380
OK?

01:14:35.380 --> 01:14:37.460
Or this bit could be a 1.

01:14:37.460 --> 01:14:39.412
Then I go here.

01:14:39.412 --> 01:14:41.870
And I mean, it actually doesn't
matter that it's preserved.

01:14:41.870 --> 01:14:42.700
But it is.

01:14:42.700 --> 01:14:44.130
I think it's kind of cool.

01:14:44.130 --> 01:14:48.190
If this was a 1, then this will
output whatever that bit is.

01:14:48.190 --> 01:14:50.910
But because, again,
this will be a 1

01:14:50.910 --> 01:14:54.080
because it gets it
from here, then the OR

01:14:54.080 --> 01:14:55.780
will turn it back into a 1.

01:14:55.780 --> 01:14:57.260
So either way, the
bit is restored.

01:14:57.260 --> 01:14:58.580
So you could actually
reuse this gadget

01:14:58.580 --> 01:14:59.663
a few times if you wanted.

01:14:59.663 --> 01:15:04.010
But we can also be lazy and just
make many copies of this gadget

01:15:04.010 --> 01:15:06.640
because we have polynomial size.

01:15:06.640 --> 01:15:09.580
So basically, we can get a 1
bit and also destroy an output,

01:15:09.580 --> 01:15:14.850
basically, with
this kind of gadget,

01:15:14.850 --> 01:15:17.270
and get the inputs to
be triggered exactly

01:15:17.270 --> 01:15:18.020
at the right time.

01:15:18.020 --> 01:15:22.789
So the i-th copy-- all of the
gates will trigger at time 2i.

01:15:22.789 --> 01:15:24.830
And then all of the AND
gates will trigger at 2i.

01:15:24.830 --> 01:15:26.205
And then all of
the OR gates will

01:15:26.205 --> 01:15:27.610
trigger at time 2i, plus 1.

01:15:27.610 --> 01:15:31.640
And they'll feed
into the next copy.

01:15:31.640 --> 01:15:32.960
All of those will trigger.

01:15:32.960 --> 01:15:33.580
And so on.

01:15:33.580 --> 01:15:35.560
So it's a little bit redundant.

01:15:35.560 --> 01:15:37.500
But it works.

01:15:41.890 --> 01:15:43.800
And then the output
is going to be

01:15:43.800 --> 01:15:47.780
the output of the last
copy, n over second copy,

01:15:47.780 --> 01:15:50.120
I guess you'd call it.

01:15:50.120 --> 01:15:51.250
OK.

01:15:51.250 --> 01:15:55.630
So you can, of
course, convert this

01:15:55.630 --> 01:15:58.290
into bounded deterministic
constraint logic, where

01:15:58.290 --> 01:16:00.391
each edge only flips once.

01:16:00.391 --> 01:16:03.084
Once you have the synchronous
version of CVP, it's very easy.

01:16:03.084 --> 01:16:04.750
I didn't draw a
synchronous picture here

01:16:04.750 --> 01:16:06.583
because it's tedious
to draw these pictures.

01:16:06.583 --> 01:16:10.870
But if you just set these--
whichever the 1 bits are--

01:16:10.870 --> 01:16:12.580
as your initially
active edges-- those

01:16:12.580 --> 01:16:15.090
are the ones that just
flipped, just reversed,

01:16:15.090 --> 01:16:17.040
then things will just
propagate and everything

01:16:17.040 --> 01:16:19.920
will be timed exactly right,
whenever you arrive at a gate.

01:16:19.920 --> 01:16:21.560
Both of the inputs
have just activated.

01:16:21.560 --> 01:16:22.880
And then the output
will activate.

01:16:22.880 --> 01:16:23.720
So just like before.

01:16:23.720 --> 01:16:25.980
But now each edge only
has to reverse once.

01:16:25.980 --> 01:16:28.420
And you'll get the
results at the end.

01:16:28.420 --> 01:16:30.250
So deciding whether
the last edge flips

01:16:30.250 --> 01:16:34.540
is the same as whether the
output was a 1 in the circuit.

01:16:34.540 --> 01:16:37.110
Open problem, I guess, would
be to use bounded deterministic

01:16:37.110 --> 01:16:38.860
constrain logic to
prove interesting games

01:16:38.860 --> 01:16:40.910
P-complete or interesting
problems P-complete.

01:16:40.910 --> 01:16:43.100
That hasn't been done.

01:16:43.100 --> 01:16:51.510
But I have, for fun, an example
of the P completeness-- P

01:16:51.510 --> 01:16:53.680
hardness reduction.

01:16:53.680 --> 01:16:56.640
So suppose you want to
find an independence set.

01:16:56.640 --> 01:16:57.890
Independence set is hard.

01:16:57.890 --> 01:17:00.030
Suppose I want to find a
maximal independence set,

01:17:00.030 --> 01:17:02.770
an independence set where I
can't add anymore vertices.

01:17:02.770 --> 01:17:04.170
So here's a way to do that.

01:17:04.170 --> 01:17:06.010
I start with nothing.

01:17:06.010 --> 01:17:08.090
I do a for loop.

01:17:08.090 --> 01:17:09.590
Let's say the
vertices are numbered.

01:17:09.590 --> 01:17:11.870
It's going to be important.

01:17:11.870 --> 01:17:18.070
And if I can add
that vertex, add it.

01:17:18.070 --> 01:17:21.010
If V is not adjacent
to S, add it.

01:17:21.010 --> 01:17:21.510
OK.

01:17:21.510 --> 01:17:23.280
I mean, this whole
world is weird

01:17:23.280 --> 01:17:25.280
because it's all about
polynomial time problems.

01:17:25.280 --> 01:17:27.080
Here's a polynomial
time algorithm.

01:17:27.080 --> 01:17:31.600
It produces what I would call
the lexically first maximal

01:17:31.600 --> 01:17:35.170
independence set because
it adds 1, if it can.

01:17:35.170 --> 01:17:38.550
And then, subject to that, it
adds 2 if it can, and so on.

01:17:38.550 --> 01:17:40.840
I will always add one, I guess.

01:17:40.840 --> 01:17:43.070
So with this
labeling of vertices,

01:17:43.070 --> 01:17:45.810
it finds the lexically
smallest one.

01:17:45.810 --> 01:17:47.950
Suppose you want to find
the lexically smallest

01:17:47.950 --> 01:17:49.360
maximal independence set.

01:17:49.360 --> 01:17:53.050
finding a maximal independence
set can be done in parallel.

01:17:53.050 --> 01:17:55.890
But finding the lexically
smallest one cannot.

01:17:55.890 --> 01:17:57.080
This is P-complete.

01:18:01.570 --> 01:18:03.390
And the reduction is super cute.

01:18:06.390 --> 01:18:13.800
Reduction from NOR CVP.

01:18:13.800 --> 01:18:16.250
Suppose I give
you a NOR circuit,

01:18:16.250 --> 01:18:19.710
and I want to know whether
the output becomes true.

01:18:19.710 --> 01:18:23.180
What I'm going to do is
build a special vertex,

01:18:23.180 --> 01:18:31.180
called 0, which is connected
to all of the 0 inputs.

01:18:31.180 --> 01:18:33.650
So the circuit has 0
inputs and 1 inputs.

01:18:33.650 --> 01:18:36.061
I'm going to make the
inputs into nodes.

01:18:36.061 --> 01:18:36.560
OK?

01:18:36.560 --> 01:18:38.560
And so there are some 1 nodes.

01:18:38.560 --> 01:18:40.390
Those are just
going to be nodes.

01:18:40.390 --> 01:18:43.280
They connect to
whatever the gates are.

01:18:43.280 --> 01:18:46.180
Then these things are combined
with various gates, and so on.

01:18:46.180 --> 01:18:48.450
I'm just going to replace
a gate with a node.

01:18:48.450 --> 01:18:50.940
I'm going to replace
an input with a node.

01:18:50.940 --> 01:18:52.900
And I'm going to add
a special node, 0,

01:18:52.900 --> 01:18:55.080
which is numbered
first, that connects

01:18:55.080 --> 01:18:57.870
to all of the 0 inputs.

01:18:57.870 --> 01:19:01.570
And then I'm also going
to order the vertices

01:19:01.570 --> 01:19:03.230
in a topological sort.

01:19:03.230 --> 01:19:05.200
So this will have
the earliest number.

01:19:05.200 --> 01:19:06.440
Then these guys.

01:19:06.440 --> 01:19:07.380
And so on.

01:19:07.380 --> 01:19:09.090
So any topological sort.

01:19:09.090 --> 01:19:12.090
Lemma topological sorting
can be done in parallel.

01:19:12.090 --> 01:19:14.250
There's an NC algorithm
for topological sorting.

01:19:14.250 --> 01:19:19.250
We need that here because this
reduction has to be in NC.

01:19:19.250 --> 01:19:23.570
But once you do
that, I claim that V

01:19:23.570 --> 01:19:29.000
will be in S if, and only
if, that gate outputs a 1.

01:19:31.710 --> 01:19:33.866
Proof by induction.

01:19:33.866 --> 01:19:35.240
So initially, this
is going to be

01:19:35.240 --> 01:19:38.550
put in the independent set,
which means these guys won't,

01:19:38.550 --> 01:19:41.520
but these guys will because
they're lexically first--

01:19:41.520 --> 01:19:43.834
or they're first in
the topological order--

01:19:43.834 --> 01:19:44.625
and then induction.

01:19:46.992 --> 01:19:48.450
There's only one
type of gate here.

01:19:48.450 --> 01:19:49.330
It's a NOR.

01:19:49.330 --> 01:19:51.620
So basically, this
guy will be circled

01:19:51.620 --> 01:19:56.000
if, and only if, neither
of the inputs are circles.

01:19:56.000 --> 01:19:56.940
So that's a NOR.

01:19:56.940 --> 01:19:58.410
And so then the
decision question

01:19:58.410 --> 01:20:00.850
is there's some last thing
corresponding to the output.

01:20:00.850 --> 01:20:03.940
It's going to be circled if, and
only if, the circuit outputs 1.

01:20:03.940 --> 01:20:04.960
And that's it.

01:20:04.960 --> 01:20:07.130
It's kind of a
beautiful reduction.

01:20:07.130 --> 01:20:09.760
And I just, for fun, I have a
list of some more P-complete

01:20:09.760 --> 01:20:11.700
problems without proofs.

01:20:11.700 --> 01:20:13.620
Game of Life, obviously.

01:20:13.620 --> 01:20:16.930
When you're given a time bound
that is written in unary,

01:20:16.930 --> 01:20:20.080
and I want to know, is this
cell alive at time t, where

01:20:20.080 --> 01:20:22.940
t is written in unary, by
the proof we did already,

01:20:22.940 --> 01:20:25.210
that's P-complete.

01:20:25.210 --> 01:20:27.510
And just, it's with
the unary version.

01:20:27.510 --> 01:20:29.640
Also, one-dimensional
cellular automata.

01:20:29.640 --> 01:20:31.240
Same kind of thing.

01:20:31.240 --> 01:20:32.360
Generalize geography.

01:20:32.360 --> 01:20:34.510
Remember that PSPACE
complete problem.

01:20:34.510 --> 01:20:36.846
But if you have an
acyclic directed graph,

01:20:36.846 --> 01:20:38.720
and you want to solve
geography on an acyclic

01:20:38.720 --> 01:20:40.761
directed graph-- so it's
a two player game-- that

01:20:40.761 --> 01:20:43.460
can be done in polynomial time.

01:20:43.460 --> 01:20:46.080
But it's P-complete.

01:20:46.080 --> 01:20:48.030
If I have a point
set in the plane,

01:20:48.030 --> 01:20:50.635
and I compute the convex
hull, remove those points,

01:20:50.635 --> 01:20:52.510
compute the convex hull,
remove those points,

01:20:52.510 --> 01:20:54.020
it's called an onion peeling.

01:20:54.020 --> 01:20:58.010
And given a point, I want to
know, is it on the k-th layer

01:20:58.010 --> 01:20:59.879
for some value k,
that's P-complete.

01:20:59.879 --> 01:21:01.670
Basically, you have to
sequentially compute

01:21:01.670 --> 01:21:04.580
the convex hulls.

01:21:04.580 --> 01:21:07.390
Another good canonical
one is multilist ranking.

01:21:07.390 --> 01:21:11.230
Suppose I give you k, say,
sorted lists of numbers,

01:21:11.230 --> 01:21:14.600
and I want to know,
given an item,

01:21:14.600 --> 01:21:17.610
what is its rank in
the union of the lists?

01:21:17.610 --> 01:21:20.320
So items can appear
in multiple lists.

01:21:20.320 --> 01:21:23.210
And I want to know, is it the
kth item, in sorted order,

01:21:23.210 --> 01:21:24.150
in the union?

01:21:24.150 --> 01:21:26.170
So basically, I want
to sort the union.

01:21:26.170 --> 01:21:29.070
That's P-complete.

01:21:29.070 --> 01:21:33.430
If I want to compute A mod
B1, mod B2, mod B3, mod B4,

01:21:33.430 --> 01:21:35.660
n times-- so the
repeated mod-- I

01:21:35.660 --> 01:21:38.830
want to know whether that
equals 0, that's P-complete.

01:21:38.830 --> 01:21:41.270
If I wanted to--
linear programming,

01:21:41.270 --> 01:21:43.190
that's polynomial time.

01:21:43.190 --> 01:21:45.950
This is P-complete, even when
the coefficients are 0 and 1.

01:21:45.950 --> 01:21:48.220
So this is called
strongly P-complete.

01:21:48.220 --> 01:21:53.560
You don't need large numbers,
whereas something like max flow

01:21:53.560 --> 01:21:59.657
is weakly P-complete and can be,
in the analogy to full P test--

01:21:59.657 --> 01:22:01.740
fully polynomial time
approximation scheme-- there

01:22:01.740 --> 01:22:04.520
is a fully RNC
approximation scheme.

01:22:04.520 --> 01:22:06.620
R means there's randomization.

01:22:06.620 --> 01:22:09.036
I think it's open, whether
you can get rid of that.

01:22:09.036 --> 01:22:11.410
There's some fun open problems,
like deciding whether two

01:22:11.410 --> 01:22:12.860
numbers are relatively prime.

01:22:12.860 --> 01:22:14.550
It's conjectured
to be P-complete.

01:22:14.550 --> 01:22:15.720
But we don't know.

01:22:15.720 --> 01:22:20.440
Computing A or the B mod C is
conjectured to be P-complete.

01:22:20.440 --> 01:22:24.770
Maximum matching is conjectured
to be-- with large edge

01:22:24.770 --> 01:22:26.860
weights, it's conjectured
to be P-complete.

01:22:26.860 --> 01:22:30.570
But there is a
pseudo RNC algorithm.

01:22:30.570 --> 01:22:33.980
So if the weights are small,
and you allow randomization,

01:22:33.980 --> 01:22:36.710
then it's parallelizable.

01:22:36.710 --> 01:22:38.760
Another open problem
is graph isomorphism

01:22:38.760 --> 01:22:41.329
with bounded degree,
which is polynomial time.

01:22:41.329 --> 01:22:42.120
I didn't know that.

01:22:42.120 --> 01:22:43.619
But bounded degree
graph isomorphism

01:22:43.619 --> 01:22:45.604
is easy in a serial setting.

01:22:45.604 --> 01:22:47.770
But a conjecture is it's
hard in a parallel setting.

01:22:47.770 --> 01:22:50.950
So lots of things out there.

01:22:50.950 --> 01:22:53.290
I don't see too many
papers about P completeness

01:22:53.290 --> 01:22:53.980
these days.

01:22:53.980 --> 01:22:55.540
But it's a fun thing.

01:22:55.540 --> 01:22:58.790
Once you decide your problem is
in P, next thing, next level,

01:22:58.790 --> 01:23:01.480
you can find hardness
anywhere, it turns out.

01:23:01.480 --> 01:23:04.234
Next thing is to prove P
completeness for your problem,

01:23:04.234 --> 01:23:05.900
make sure there's no
parallel algorithm,

01:23:05.900 --> 01:23:07.720
or find an NC algorithm.

01:23:07.720 --> 01:23:09.780
If you do the upper bound
side, once you have NC,

01:23:09.780 --> 01:23:12.300
you want to get the
smallest depth possible.

01:23:12.300 --> 01:23:14.400
That's another story.

01:23:14.400 --> 01:23:15.140
Cool.

01:23:15.140 --> 01:23:17.200
That's it for today.