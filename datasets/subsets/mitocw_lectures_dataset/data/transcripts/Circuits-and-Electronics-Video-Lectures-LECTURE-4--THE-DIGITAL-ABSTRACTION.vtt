WEBVTT

00:00:00.000 --> 00:00:09.000
So today we are going to talk
about another process of lumping

00:00:09.000 --> 00:00:16.000
or another process of
discretization what will lead to

00:00:16.000 --> 00:00:24.000
the digital abstraction.
So today's lecture is titled

00:00:24.000 --> 00:00:30.000
"Go Digital".
So let me begin with a usual

00:00:30.000 --> 00:00:36.000
review.
And so in the first lecture we

00:00:36.000 --> 00:00:41.000
started out by looking at
elements and lumping them.

00:00:41.000 --> 00:00:46.000
For example,
we took an element and said for

00:00:46.000 --> 00:00:51.000
the purpose of analyzing
electrical properties let's lump

00:00:51.000 --> 00:00:57.000
this element into a single
lumped value called a resistor,

00:00:57.000 --> 00:01:01.000
R.
And this led to the lumped

00:01:01.000 --> 00:01:04.000
circuit abstraction.
The lumped circuit abstraction

00:01:04.000 --> 00:01:09.000
says let's take these elements,
connect them with wires and

00:01:09.000 --> 00:01:13.000
analyze the properties of these
using a sort of analysis

00:01:13.000 --> 00:01:15.000
technique.

00:01:22.000 --> 00:01:28.000
So a set of a methods.
We've looked at the KVL,

00:01:28.000 --> 00:01:33.000
KCL method.
Another example of a method we

00:01:33.000 --> 00:01:39.000
looked at was the node method.
And of this category there is

00:01:39.000 --> 00:01:45.000
one method you should remember,
which you can apply to every

00:01:45.000 --> 00:01:51.000
single circuit and it will
simply work, is the node method.

00:01:51.000 --> 00:01:56.000
For linear circuits other
methods also apply,

00:01:56.000 --> 00:01:59.000
and these include
superposition,

00:01:59.000 --> 00:02:04.000
Thevenin method,
and in recitation or in your

00:02:04.000 --> 00:02:12.000
course notes you would have
looked at the Norton method.

00:02:12.000 --> 00:02:15.000
So that's what we did so far.
So this is a toolkit.

00:02:15.000 --> 00:02:19.000
So now you have a utility belt
with a bunch of tools in it,

00:02:19.000 --> 00:02:21.000
and you can draw from those
tools.

00:02:21.000 --> 00:02:24.000
And, just like any good
carpenter, you know,

00:02:24.000 --> 00:02:27.000
the carpenter has to cut a
piece of wood.

00:02:27.000 --> 00:02:30.000
He could use a chisel.
He could use a saw.

00:02:30.000 --> 00:02:34.000
He could use an electric saw.
And the reason you pay

00:02:34.000 --> 00:02:39.000
carpenters $80 an hour in the
Boston region is because they

00:02:39.000 --> 00:02:42.000
know which tool to use for what
job.

00:02:42.000 --> 00:02:46.000
So what we'll learn today is,
so this was one process of

00:02:46.000 --> 00:02:49.000
discretization.
We discretized matter.

00:02:49.000 --> 00:02:54.000
This gave us the discipline
here that we decided to follow,

00:02:54.000 --> 00:02:58.000
lumped matter discipline,
that moved us from Maxwell's

00:02:58.000 --> 00:03:03.000
equations into this new
playground called EECS.

00:03:03.000 --> 00:03:06.000
Where all elements looked like
these rinky-dinky little values

00:03:06.000 --> 00:03:09.000
like resistors and voltage
sources and so on.

00:03:09.000 --> 00:03:12.000
What we'll do today,
if that wasn't simple enough,

00:03:12.000 --> 00:03:15.000
let's simplify our lives even
further.

00:03:15.000 --> 00:03:17.000
What we're going to do is lump
some more.

00:03:17.000 --> 00:03:20.000
So what else can we lump?
We've lumped matter,

00:03:20.000 --> 00:03:24.000
so all matter is taken care of.
So what can we lump to make

00:03:24.000 --> 00:03:26.000
life even easier?
When in doubt,

00:03:26.000 --> 00:03:29.000
if things are complicated,
discretize it or lump it,

00:03:29.000 --> 00:03:32.000
right?
So what do you think?

00:03:32.000 --> 00:03:36.000
What we will do today is lump
signal values.

00:03:45.000 --> 00:03:47.000
So we'll just deal with lumped
values.

00:03:47.000 --> 00:03:51.000
And this will lead to the
digital abstraction.

00:04:02.000 --> 00:04:10.000
And the related reading is
Chapter 5 of the course notes.

00:04:15.000 --> 00:04:19.000
So before we do this kind of
lumping, let me motivate why we

00:04:19.000 --> 00:04:21.000
do this.
One reason is to simplify our

00:04:21.000 --> 00:04:25.000
lives, but there is no need to
just go around simplifying

00:04:25.000 --> 00:04:29.000
things just because we can.
Let's try to see if there are

00:04:29.000 --> 00:04:34.000
other reasons motivating the
digital abstraction.

00:04:34.000 --> 00:04:39.000
So what I would like to start
with is a simple example of a

00:04:39.000 --> 00:04:44.000
analog processing circuit that
you should now be able to

00:04:44.000 --> 00:04:47.000
analyze.
So I'm going to be motivating

00:04:47.000 --> 00:04:51.000
digital.
So let's start with an analog

00:04:51.000 --> 00:04:55.000
circuit that looks like this,
two resistors,

00:04:55.000 --> 00:05:00.000
R1 and R2.
And what I'm going to do is

00:05:00.000 --> 00:05:06.000
apply a voltage source here,
V1, apply another one here,

00:05:06.000 --> 00:05:13.000
V2, and make this connection.
And let me call this voltage V

00:05:13.000 --> 00:05:20.000
nought and call this my output.
This voltage with respect to

00:05:20.000 --> 00:05:25.000
ground node, rather than drawing
this wire here,

00:05:25.000 --> 00:05:31.000
I often times draw a ground
here and simply throw ground

00:05:31.000 --> 00:05:36.000
wherever I want.
This symbol simply refers to

00:05:36.000 --> 00:05:40.000
the fact that the other terminal
is taken at the ground node.

00:05:40.000 --> 00:05:44.000
So here is my V nought.
Now, let's go and analyze this

00:05:44.000 --> 00:05:46.000
and see what it gives us.
In this example,

00:05:46.000 --> 00:05:50.000
V1 and V2 may be outputs of two
sensors, maybe heat sensors or

00:05:50.000 --> 00:05:53.000
something like that.
This is a heat sensor on that

00:05:53.000 --> 00:05:57.000
side of the room and this is a
heat sensor on this side of the

00:05:57.000 --> 00:06:01.000
room.
And I pass their signals

00:06:01.000 --> 00:06:05.000
through two resistors and I look
at the voltage there.

00:06:05.000 --> 00:06:10.000
So by now you should be able to
write the answer V nought,

00:06:10.000 --> 00:06:13.000
or the value V nought almost by
inspection.

00:06:13.000 --> 00:06:17.000
Just to show you,
let me use superposition.

00:06:17.000 --> 00:06:22.000
When you see multiple sources,
the first thing you should

00:06:22.000 --> 00:06:26.000
think about is can I use
superposition to simplify my

00:06:26.000 --> 00:06:30.000
life?
And let me do that.

00:06:30.000 --> 00:06:35.000
V nought here is the sum of two
voltages, one due to V1 acting

00:06:35.000 --> 00:06:38.000
alone and one due to V2 acting
alone.

00:06:38.000 --> 00:06:43.000
So what's the voltage here due
to V1 acting alone?

00:06:43.000 --> 00:06:48.000
To find out that I short this
voltage, I zero out this voltage

00:06:48.000 --> 00:06:52.000
and look at the effect of V1.
So the effect of V1,

00:06:52.000 --> 00:06:57.000
if this were shorted out,
is simply V1 x R2 / R1 + R2.

00:06:57.000 --> 00:07:02.000
This is now a voltage divider,
right?

00:07:02.000 --> 00:07:06.000
A voltage V applied across two
resistors and the output taken

00:07:06.000 --> 00:07:09.000
across one resistor.
So that's this value.

00:07:09.000 --> 00:07:12.000
Then I could do the second
part.

00:07:12.000 --> 00:07:16.000
To look at the effect of V2,
what I will do is short this

00:07:16.000 --> 00:07:19.000
voltage and look at the effect
of this.

00:07:19.000 --> 00:07:23.000
Now, this voltage is across
this resistor divider.

00:07:23.000 --> 00:07:27.000
And so I get R1 / (R1 + R2)
here.

00:07:27.000 --> 00:07:30.000
So you'll notice that for
something like this,

00:07:30.000 --> 00:07:34.000
if I had applied KVL and KCL of
the node method I would have

00:07:34.000 --> 00:07:38.000
gotten a bunch of equations,
but here I wrote it just by

00:07:38.000 --> 00:07:41.000
inspection.
You should be able to look at

00:07:41.000 --> 00:07:45.000
circuit patterns like this and
write the answers down very

00:07:45.000 --> 00:07:48.000
quickly.
Let's say if I chose R1 to be

00:07:48.000 --> 00:07:52.000
equal to R2 then V nought would
simply be (V1 + V2) / 2.

00:07:52.000 --> 00:07:56.000
So if these two values were
equal, I simply get the output,

00:07:56.000 --> 00:08:00.000
the average of the two
voltages.

00:08:00.000 --> 00:08:02.000
So this guy is an adder
circuit.

00:08:02.000 --> 00:08:05.000
It adds up these two voltages.
But more precisely it's an

00:08:05.000 --> 00:08:09.000
averaging circuit.
It takes two voltages and gives

00:08:09.000 --> 00:08:12.000
me the average value.
Now, if you have two sensors in

00:08:12.000 --> 00:08:16.000
the room, you might think of why
you want to take that average

00:08:16.000 --> 00:08:19.000
value to control the temperature
of the room.

00:08:19.000 --> 00:08:23.000
But suffice it to say that V
nought is the average of the two

00:08:23.000 --> 00:08:26.000
values.
So let me show you a quick demo

00:08:26.000 --> 00:08:30.000
of this example and then look at
what the problems are with this

00:08:30.000 --> 00:08:33.000
example.
So let's say,

00:08:33.000 --> 00:08:36.000
as one example,
I applied a square wave at V1,

00:08:36.000 --> 00:08:39.000
which is the top curve,
the green curve,

00:08:39.000 --> 00:08:44.000
and I applied a triangular wave
at V2, that's the second one.

00:08:44.000 --> 00:08:48.000
As you expect,
the output is going to be the

00:08:48.000 --> 00:08:51.000
sum of the two voltages scaled
appropriately.

00:08:51.000 --> 00:08:56.000
So notice that I have a square
wave with a superimposed

00:08:56.000 --> 00:09:01.000
triangular wave on top.
And I can play around.

00:09:01.000 --> 00:09:06.000
What I could do is change the
amplitude of my wave form here.

00:09:06.000 --> 00:09:11.000
And, as you notice,
the amplitude of the output

00:09:11.000 --> 00:09:14.000
component also changes
accordingly.

00:09:14.000 --> 00:09:18.000
So this is one simple example
of an adder circuit,

00:09:18.000 --> 00:09:24.000
and the two wave forms get
summed up and I get the output.

00:09:24.000 --> 00:09:28.000
So I'll switch to Page 3.
Let me just draw a little

00:09:28.000 --> 00:09:35.000
sketch for you here.
Here, what I showed you was I

00:09:35.000 --> 00:09:44.000
had a triangular wave coming on
one of these inputs and I had a

00:09:44.000 --> 00:09:52.000
square wave on the other one,
and the output looks something

00:09:52.000 --> 00:09:54.000
like this.

00:10:04.000 --> 00:10:05.000
OK?
No surprise here.

00:10:05.000 --> 00:10:11.000
This is a simple analog signal
processing circuit which gives

00:10:11.000 --> 00:10:13.000
me the average of two wave
forms.

00:10:13.000 --> 00:10:18.000
Now, let me do the following.
Often times I may need to look

00:10:18.000 --> 00:10:21.000
at this value some distance
away.

00:10:21.000 --> 00:10:26.000
So let's say this person here
wants to look at the value.

00:10:26.000 --> 00:10:32.000
So I bring this wire here.
And I also bring the ground

00:10:32.000 --> 00:10:38.000
connection and I look at it.
I look at this value here.

00:10:38.000 --> 00:10:44.000
And when I have a long wire I
can get noise added onto the

00:10:44.000 --> 00:10:48.000
circuit.
So let's say a bunch of noise

00:10:48.000 --> 00:10:52.000
gets added into the signal
there.

00:10:52.000 --> 00:10:58.000
And what I end up seeing here
is not something that looks like

00:10:58.000 --> 00:11:04.000
this but something that looks
like that.

00:11:04.000 --> 00:11:08.000
That's not unusual.
And the problem with this is

00:11:08.000 --> 00:11:12.000
now when I look at this,
if I'm looking to distinguish

00:11:12.000 --> 00:11:15.000
between, say,
a 3.9 and a 3.8,

00:11:15.000 --> 00:11:20.000
it's really hard to do that
because my noise is overwhelming

00:11:20.000 --> 00:11:23.000
my signal.
I have a real problem,

00:11:23.000 --> 00:11:27.000
a real problem here.
Noise is a fact of life.

00:11:27.000 --> 00:11:31.000
So what do we do?
This is so fundamental.

00:11:31.000 --> 00:11:35.000
Large bodies of courses in
electrical engineering are

00:11:35.000 --> 00:11:40.000
devoted to how do I carefully
analyze signals in the presence

00:11:40.000 --> 00:11:42.000
of noise?
You'll take courses in speech

00:11:42.000 --> 00:11:47.000
processing that look at clever
techniques to recognize speech

00:11:47.000 --> 00:11:50.000
in the presence of noise and so
on and so forth.

00:11:50.000 --> 00:11:54.000
One technique we adopt that
we'll talk about here,

00:11:54.000 --> 00:11:58.000
which is fundamental to EECS,
is using the digital

00:11:58.000 --> 00:12:03.000
abstraction.
Let me show you how it can

00:12:03.000 --> 00:12:07.000
really help with the noise
problem.

00:12:07.000 --> 00:12:13.000
So the idea is value lumping or
value discretization.

00:12:13.000 --> 00:12:20.000
Much like we lumped matter,
we've discretized matter into

00:12:20.000 --> 00:12:26.000
discrete chunks,
let's discretize value into two

00:12:26.000 --> 00:12:31.000
chunks.
Let's simply say that now I'm

00:12:31.000 --> 00:12:35.000
going to deal with two values
and I can, say,

00:12:35.000 --> 00:12:37.000
call them high,
low.

00:12:37.000 --> 00:12:43.000
I have a bunch of choices here.
I may call it 5 volts and 0

00:12:43.000 --> 00:12:47.000
volts.
I may call it true and false.

00:12:47.000 --> 00:12:53.000
What I'm doing is I'm just
restricting my universe to deal

00:12:53.000 --> 00:12:58.000
with just two values,
zero and one.

00:12:58.000 --> 00:13:01.000
This is like dealing with a
number system with only two

00:13:01.000 --> 00:13:04.000
digits.
And these are zero and one.

00:13:04.000 --> 00:13:08.000
So what I've now done is I'm
saying that rather than dealing

00:13:08.000 --> 00:13:12.000
with all possible continuous
values, 0.1, 3.9999 recurring

00:13:12.000 --> 00:13:16.000
and so on and so forth,
what I'm going to do is simply

00:13:16.000 --> 00:13:19.000
deal with a high and a low.
Dealing with this whole

00:13:19.000 --> 00:13:22.000
continuum of numbers is really
complicated.

00:13:22.000 --> 00:13:26.000
Let me simplify my life and
just postulate that I am going

00:13:26.000 --> 00:13:32.000
to be looking at high and low.
Whenever I see something I'll

00:13:32.000 --> 00:13:37.000
look at it and say high or low,
is it black or white,

00:13:37.000 --> 00:13:39.000
period.
There's no choice here,

00:13:39.000 --> 00:13:44.000
just two individual values.
So that sounds simple,

00:13:44.000 --> 00:13:47.000
and nice and so on,
but what's the point?

00:13:47.000 --> 00:13:52.000
What do we get by doing that?
Let's take our example.

00:13:52.000 --> 00:13:55.000
Let's take what might be a
digital system.

00:13:55.000 --> 00:14:02.000
Let's take a digital system and
let's say I have a sender.

00:14:02.000 --> 00:14:07.000
Much like I sent a signal value
a long distance,

00:14:07.000 --> 00:14:13.000
let me have a sender,
and I have a ground as well and

00:14:13.000 --> 00:14:18.000
here is a receiver.
This symbol simply says that

00:14:18.000 --> 00:14:22.000
both of them share a ground
wire.

00:14:22.000 --> 00:14:28.000
So the sender and a receiver.
And what I'm interested in

00:14:28.000 --> 00:14:34.000
doing, the sender is interested
in sending a signal to the

00:14:34.000 --> 00:14:39.000
receiver.
And in the digital system,

00:14:39.000 --> 00:14:44.000
the way I would send a digital
signal is all I can use is ones

00:14:44.000 --> 00:14:47.000
and zeros, OK?
So let's say the sender sends

00:14:47.000 --> 00:14:51.000
something like this.
The sender wants to send a

00:14:51.000 --> 00:14:54.000
value.
This is my time axis and this

00:14:54.000 --> 00:14:57.000
is 2.5 volts,
this is 0 volts and this is 5

00:14:57.000 --> 00:15:01.000
volts.
My sender has some agreement

00:15:01.000 --> 00:15:05.000
with the receiver and says I'm
just going to be sending to you

00:15:05.000 --> 00:15:09.000
low values and high values.
And this signal here would

00:15:09.000 --> 00:15:12.000
correspond to "0" "1" "0".
It's a symbol.

00:15:12.000 --> 00:15:15.000
That's why I have input zero in
quotes there.

00:15:15.000 --> 00:15:18.000
We'll go into this in much more
detail later,

00:15:18.000 --> 00:15:22.000
but for now suffice it to say
that I'm sending a set of

00:15:22.000 --> 00:15:26.000
signals here "0" "1" "0".
This simplistic scheme will not

00:15:26.000 --> 00:15:30.000
work in many situations but go
along with this for a few

00:15:30.000 --> 00:15:34.000
seconds.
So I send the signal sequence

00:15:34.000 --> 00:15:38.000
"0" "1" "0" out here.
And notice that there is a high

00:15:38.000 --> 00:15:41.000
and a low.
And the agreement the sender

00:15:41.000 --> 00:15:45.000
and the receiver have is that,
look, if you see a value that's

00:15:45.000 --> 00:15:48.000
higher than 2.5 volts that's a
high.

00:15:48.000 --> 00:15:53.000
If you see a value below 2.5
volts in the wire that's a low.

00:15:53.000 --> 00:15:57.000
And I'm going to send a 0 volt
and a 5 volt from here.

00:15:57.000 --> 00:16:01.000
So now at the sending site
let's say I don't have any noise

00:16:01.000 --> 00:16:06.000
in this system.
Let's say this is my Vn,

00:16:06.000 --> 00:16:11.000
some noise being added.
And let's say Vn is 0.

00:16:11.000 --> 00:16:18.000
Then in that case I will
receive exactly what is sent "0"

00:16:18.000 --> 00:16:22.000
"0" 5, 2.5, 0 volts.
And this is time.

00:16:22.000 --> 00:16:25.000
Nothing fancy here,
right?

00:16:25.000 --> 00:16:30.000
My receiver receives a "0" "1"
"0".

00:16:30.000 --> 00:16:36.000
Now, the beauty of this is that
now suppose I were to impose

00:16:36.000 --> 00:16:42.000
noise much like I had noise out
there and Vn was not 0.

00:16:42.000 --> 00:16:48.000
Rather Vn was some noise
voltage, let's say 0.2 volts

00:16:48.000 --> 00:16:52.000
peak to peak.
Let's say that simply got

00:16:52.000 --> 00:16:58.000
superposed on the signal.
In which case what do I get?

00:16:58.000 --> 00:17:06.000
What I end up here with is a
signal that looks like this.

00:17:06.000 --> 00:17:09.000
So the receiver gets that
signal because a noise is added

00:17:09.000 --> 00:17:12.000
into my signal and that's what I
get.

00:17:12.000 --> 00:17:14.000
But guess what?
No problem.

00:17:14.000 --> 00:17:17.000
The receiver says oh,
yeah, this is a 0 because the

00:17:17.000 --> 00:17:21.000
values are less than 2.5,
this is a 1 and this is a 0.

00:17:21.000 --> 00:17:24.000
"0" "1" "0".
So here my receiver was able to

00:17:24.000 --> 00:17:28.000
receive the signal and correctly
interpret it without any

00:17:28.000 --> 00:17:32.000
problems.
So because I used this value

00:17:32.000 --> 00:17:36.000
discretization and because I had
this agreement with the

00:17:36.000 --> 00:17:39.000
receiver, I had better noise
immunity.

00:17:45.000 --> 00:17:48.000
Consequently,
I had what is called a noise

00:17:48.000 --> 00:17:51.000
margin.
Noise margin says how much

00:17:51.000 --> 00:17:56.000
noise can I tolerate?
And in this situation,

00:17:56.000 --> 00:18:00.000
because the sender sends 5
volts and 0 volts,

00:18:00.000 --> 00:18:04.000
the 5 volts can creep all the
way down to 2.5,

00:18:04.000 --> 00:18:10.000
I'll still be OK.
Similarly, 0 could go all the

00:18:10.000 --> 00:18:14.000
way up to 2.5,
I'd still be OK.

00:18:14.000 --> 00:18:21.000
So in this case I have a noise
margin of 2.5 volts for a 1 and

00:18:21.000 --> 00:18:28.000
similarly 2.5 volts for a 0,
because there are 2.5 volts

00:18:28.000 --> 00:18:34.000
between a 0 volt and 2.5.
So notice that I have a nice

00:18:34.000 --> 00:18:37.000
little noise margin here,
which simply is the English

00:18:37.000 --> 00:18:41.000
meaning of the term there is a
margin for noise.

00:18:41.000 --> 00:18:45.000
And even though I can change
the signal value by up to 2.5

00:18:45.000 --> 00:18:50.000
volts, the receiver will still
correctly interpret the signal.

00:18:50.000 --> 00:18:54.000
So I've decided to discretize
values into highs and lows.

00:18:54.000 --> 00:18:57.000
And because of that,
if all I wanted to do in life

00:18:57.000 --> 00:19:03.000
is send highs and lows I can
send them very effectively.

00:19:03.000 --> 00:19:08.000
There are many complications,
but if all I care about is

00:19:08.000 --> 00:19:14.000
sending highs and lows I can
send it with a lot of tolerance

00:19:14.000 --> 00:19:17.000
to noise.
So many of you are saying but

00:19:17.000 --> 00:19:21.000
what about this,
but what about that?

00:19:21.000 --> 00:19:27.000
There are lots of buts here.
And let's take a look at some

00:19:27.000 --> 00:19:31.000
of them.
If you look up there.

00:19:31.000 --> 00:19:38.000
What I ended up doing was
creating a design space that

00:19:38.000 --> 00:19:42.000
looked like this.
This is on Page 6.

00:19:42.000 --> 00:19:50.000
What I did was I said with a
range of values from 0 to 5,

00:19:50.000 --> 00:19:58.000
what I'm going to do is at 2.5
I drew a line and I said as a

00:19:58.000 --> 00:20:05.000
sender if you wanted to send a 0
then you would send a value

00:20:05.000 --> 00:20:10.000
here.
And if you wanted to send a 1

00:20:10.000 --> 00:20:14.000
you would send a value here.
Similarly, for a receiver.

00:20:14.000 --> 00:20:18.000
And if the sender sent a value
all the way up in 5 volts that

00:20:18.000 --> 00:20:22.000
was the best thing,
but technically the sender

00:20:22.000 --> 00:20:25.000
could send any value between 2.5
and 5.

00:20:25.000 --> 00:20:29.000
And if there was no noise then
the receiver could correctly

00:20:29.000 --> 00:20:35.000
interpret a 1 if it was above
this and 0 if it was below this.

00:20:35.000 --> 00:20:39.000
The problem with this approach
really is that if I allow the

00:20:39.000 --> 00:20:44.000
sender to send any value above
2.5 all the way to 5 then there

00:20:44.000 --> 00:20:48.000
really is no noise margin in
this situation.

00:20:53.000 --> 00:20:55.000
OK?
Because if I allowed the sender

00:20:55.000 --> 00:21:00.000
to send any value between 2.5
and 5 then what if I have a

00:21:00.000 --> 00:21:04.000
value 2.5 for a 1?
Then I may end up getting very

00:21:04.000 --> 00:21:08.000
little noise margin on the other
side.

00:21:08.000 --> 00:21:11.000
Worse yet, what if I get a
value 2.5?

00:21:11.000 --> 00:21:16.000
That's a much worse situation.
What if the receiver receives a

00:21:16.000 --> 00:21:18.000
value of 2.5?
Now what?

00:21:18.000 --> 00:21:23.000
What does the receiver do?
The receiver cannot tell

00:21:23.000 --> 00:21:28.000
whether it's a 1 or a 0.
The receiver gets hopelessly

00:21:28.000 --> 00:21:33.000
confused.
So to deal with that,

00:21:33.000 --> 00:21:40.000
I'm going to fix this,
what I'm going to do is the

00:21:40.000 --> 00:21:45.000
following.
Switch to Page 7.

00:21:45.000 --> 00:21:53.000
What I'll do here is to prevent
the receiver from getting

00:21:53.000 --> 00:22:02.000
confused, if the receiver saw
2.5, what I'm going to do is

00:22:02.000 --> 00:22:10.000
define what is called "no man's
land".

00:22:10.000 --> 00:22:15.000
I'm going to define the region
of my voltage space called the

00:22:15.000 --> 00:22:19.000
forbidden region.
And what I'm going to do is,

00:22:19.000 --> 00:22:24.000
say, let's say I defined it as
2 volts, 3 volts and 5 volts,

00:22:24.000 --> 00:22:28.000
0, 2, 3 and 5.
With my forbidden region,

00:22:28.000 --> 00:22:33.000
if I have a sender then I tell
the sender you can send any

00:22:33.000 --> 00:22:39.000
value between 3 and 5 for a 1.
And you can send any value

00:22:39.000 --> 00:22:44.000
between 2 and 0 for a 0.
To send the symbol 0,

00:22:44.000 --> 00:22:50.000
I can send any voltage between
0 and 2, and similarly for 1.

00:22:50.000 --> 00:22:55.000
At the receiving side,
if I see any value between 3

00:22:55.000 --> 00:23:00.000
and 5, I read that as a 0,
and any value between 0 and 2 I

00:23:00.000 --> 00:23:06.000
read that as 2 volts.
So I may label this value VH

00:23:06.000 --> 00:23:11.000
and label this threshold VL,
so there's a high threshold and

00:23:11.000 --> 00:23:15.000
a low threshold.
So this solves one problem.

00:23:15.000 --> 00:23:20.000
Now the receiver can never see
a value in the forbidden region.

00:23:20.000 --> 00:23:24.000
Now, I can stand her and
pontificate and say,

00:23:24.000 --> 00:23:30.000
oops, that's a forbidden
region, thou shalt not go there.

00:23:30.000 --> 00:23:33.000
But what if I get some noise
and a value goes in there?

00:23:33.000 --> 00:23:36.000
In real systems values may
enter there.

00:23:36.000 --> 00:23:39.000
But what I'm saying,
so this is the beauty of using

00:23:39.000 --> 00:23:41.000
a discipline.
Let me use my playground

00:23:41.000 --> 00:23:43.000
analogy.
This is my playground.

00:23:43.000 --> 00:23:47.000
We got into this playground
using the discrete matter of

00:23:47.000 --> 00:23:51.000
discipline, the playground of
EECS, but in that playground

00:23:51.000 --> 00:23:55.000
some region of that playground
deals with just high and low

00:23:55.000 --> 00:23:57.000
values.
I further restrict the

00:23:57.000 --> 00:24:00.000
playground and I say I'm only
going to focus on that

00:24:00.000 --> 00:24:06.000
playground in which all signal
values have a forbidden region.

00:24:06.000 --> 00:24:09.000
All senders and receivers
adhere to a forbidden region.

00:24:09.000 --> 00:24:14.000
And if there is any signal in
this space, in the forbidden

00:24:14.000 --> 00:24:16.000
space then my behavior is
undefined.

00:24:16.000 --> 00:24:19.000
I don't care.
You want to go there?

00:24:19.000 --> 00:24:21.000
Sure.
I don't know what's going to

00:24:21.000 --> 00:24:24.000
happen to you.
Now, we're engineers,

00:24:24.000 --> 00:24:26.000
right?
So we've disciplined ourselves

00:24:26.000 --> 00:24:32.000
to play in this playground.
It's like I tell my 9-year-old,

00:24:32.000 --> 00:24:33.000
don't go there,
right?

00:24:33.000 --> 00:24:36.000
And of course he wants to go
there.

00:24:36.000 --> 00:24:39.000
He says what will happen if I
go there?

00:24:39.000 --> 00:24:42.000
And the answer here will be
undefined, OK?

00:24:42.000 --> 00:24:45.000
Something really bad could
happen to you.

00:24:45.000 --> 00:24:48.000
I don't know what it is but
something really bad,

00:24:48.000 --> 00:24:52.000
you know, a lightening bolt or
who knows what,

00:24:52.000 --> 00:24:55.000
but something really bad.
And you as a designer of a

00:24:55.000 --> 00:25:00.000
circuit can, let's say you were
Intel.

00:25:00.000 --> 00:25:02.000
Intel designs its chips.
And let's say Intel decides to

00:25:02.000 --> 00:25:05.000
play in this playground and
there is a forbidden region.

00:25:05.000 --> 00:25:08.000
So Intel says oh,
it's really easy for me if in

00:25:08.000 --> 00:25:11.000
the forbidden region the chip
simply burns up and catches

00:25:11.000 --> 00:25:13.000
fire, we'll sell more chips.
That's fine.

00:25:13.000 --> 00:25:15.000
Whatever you want.
The key here is that all I'm

00:25:15.000 --> 00:25:19.000
saying is that I am going to
discipline myself into playing

00:25:19.000 --> 00:25:22.000
in this playground and that's
where I will define my rules,

00:25:22.000 --> 00:25:24.000
and you stay within the
boundaries and all the rules

00:25:24.000 --> 00:25:28.000
will apply.
It's called a "discipline."

00:25:28.000 --> 00:25:31.000
You're disciplining yourselves
to stay within it.

00:25:31.000 --> 00:25:34.000
There's no logic to it.
It's just a discipline.

00:25:34.000 --> 00:25:37.000
Just do it and you'll be OK.
When we look at practical

00:25:37.000 --> 00:25:40.000
circuits and so on,
we have to address the issue of

00:25:40.000 --> 00:25:43.000
what happens when things go in
there.

00:25:43.000 --> 00:25:45.000
But let's postpone that
discussion.

00:25:45.000 --> 00:25:48.000
For now I've solved one of my
problems, which is,

00:25:48.000 --> 00:25:52.000
the previous problem was what
does a receiver do if it saw a

00:25:52.000 --> 00:25:53.000
2.5?
Now it can't see a 2.5.

00:25:53.000 --> 00:25:57.000
But then the receiver asks,
Agarwal, but what if I see a

00:25:57.000 --> 00:26:00.000
2.5?
I can tell the receiver you can

00:26:00.000 --> 00:26:03.000
do whatever you want to do.
You can stomp it.

00:26:03.000 --> 00:26:05.000
You can squish it.
You can burn it.

00:26:05.000 --> 00:26:07.000
You can chuck it.
Whatever you want.

00:26:07.000 --> 00:26:10.000
It's up to you.
Do whatever you want.

00:26:10.000 --> 00:26:13.000
You won't see a value.
If you do, do whatever you

00:26:13.000 --> 00:26:14.000
want.
It's undefined.

00:26:14.000 --> 00:26:16.000
That works.
So you, as the receiver

00:26:16.000 --> 00:26:19.000
designer can do whatever you
want when you see a 2.5.

00:26:19.000 --> 00:26:22.000
You can say yeah,
I'll just put out a 1 if I see

00:26:22.000 --> 00:26:25.000
a 2.5 or a 2.6.
I'll just do something.

00:26:25.000 --> 00:26:27.000
No one cares.
So this is pretty good.

00:26:27.000 --> 00:26:32.000
This is pretty good.
We still have a problem,

00:26:32.000 --> 00:26:35.000
though.
Do people see the problem here?

00:26:35.000 --> 00:26:40.000
This still doesn't quite work.
If Intel did this,

00:26:40.000 --> 00:26:46.000
instead of your laptops failing
and blue-screening every hour

00:26:46.000 --> 00:26:49.000
they'd be doing it every
millisecond.

00:26:49.000 --> 00:26:54.000
So the problem is this
discipline have allowed the

00:26:54.000 --> 00:27:00.000
sender to send any value between
3 and 5 as a 1.

00:27:00.000 --> 00:27:05.000
And any value between 3 and 5
at the receiver is treated as a

00:00:01.000 --> 00:27:08.000
Do you see where the problem

00:27:08.000 --> 00:27:09.000
is?
Yes?

00:27:09.000 --> 00:27:14.000
The sender sends a 1.99 and the
noise pumps it into forbidden

00:27:14.000 --> 00:27:16.000
region.
Exactly.

00:27:16.000 --> 00:27:20.000
So the sender says it's
legitimate, I'm Intel.

00:27:20.000 --> 00:00:02.000
They've told me stick to 0 and

00:27:23.000 --> 00:27:30.000
And Intel parts will be sending
to values between 0 and 2.

00:27:30.000 --> 00:27:32.000
And Motorola parts,
which are receivers,

00:27:32.000 --> 00:27:35.000
you know they have to receive 0
and 2.

00:27:35.000 --> 00:00:02.000
So Intel can send the value,

00:27:37.000 --> 00:27:39.000
They can because it's 1.9 out
of 2.

00:27:39.000 --> 00:27:42.000
It's legal.
This way I can make really

00:27:42.000 --> 00:27:45.000
cheap parts.
But now the problem is that

00:27:45.000 --> 00:27:48.000
even the smallest amount of
noise will bump it into the

00:27:48.000 --> 00:27:52.000
forbidden region,
and so therefore this one has a

00:27:52.000 --> 00:27:54.000
problem.
And the problem is that this

00:27:54.000 --> 00:28:00.000
one offers zero noise margin.
There is no noise margin.

00:28:00.000 --> 00:28:05.000
There is no margin for noise in
the discipline.

00:28:05.000 --> 00:28:10.000
All right, back to the drawing
board, folks.

00:28:10.000 --> 00:28:15.000
Switch to Page 8.
Let's get rid of all this stuff

00:28:15.000 --> 00:28:20.000
and go back to the drawing
board.

00:28:31.000 --> 00:28:35.000
OK, so what do we do now?
How about the following?

00:28:35.000 --> 00:28:39.000
How, about as before I say,
as a receiver,

00:28:39.000 --> 00:28:44.000
if you see a value between 3
and 5 you treat that as a 1 and

00:28:44.000 --> 00:28:49.000
a value between 0 and 2 you
treat that as a 0.

00:28:49.000 --> 00:28:52.000
No difference.
So as a receiver same as

00:28:52.000 --> 00:28:56.000
before.
But now what I do is I hold the

00:28:56.000 --> 00:29:03.000
sender to tougher standards.
I hold the feet of the sender

00:29:03.000 --> 00:29:09.000
to the fire and say you have to
adhere to tougher standards.

00:29:09.000 --> 00:29:16.000
So what I'm going to do is hold
the sender to tougher standards,

00:29:16.000 --> 00:29:21.000
maybe four walls.
That is tell the sender that if

00:29:21.000 --> 00:29:27.000
you want to send to 0 or a 1,
for a 1 you have to send a

00:29:27.000 --> 00:29:33.000
value between 4 and 5,
and for a 0 a value between 0

00:29:33.000 --> 00:29:37.000
and 1.
Sender is now held to tougher

00:29:37.000 --> 00:29:41.000
standards.
This is what my chart looks

00:29:41.000 --> 00:29:44.000
like.
So now I do have some noise

00:29:44.000 --> 00:29:48.000
margin.
Can someone tell me what is the

00:29:48.000 --> 00:29:51.000
noise margin here for a 1?
1 volt.

00:29:51.000 --> 00:29:57.000
And the reason is that the
lowest voltage a sender can send

00:29:57.000 --> 00:30:02.000
is 4 volts, OK?
If the 4 leaks down to 2.99

00:30:02.000 --> 00:30:05.000
that's in the forbidden region,
I'm in trouble.

00:00:02.990 --> 00:30:08.000
This is my forbidden region

00:30:08.000 --> 00:30:10.000
here.
And 2.99 is in the forbidden

00:30:10.000 --> 00:30:12.000
region.
I'm in trouble.

00:30:12.000 --> 00:30:17.000
So notice that the lowest value
that the receiver can receive is

00:30:17.000 --> 00:30:19.000
3 volts.
So if I sent the 4 and sent

00:30:19.000 --> 00:30:24.000
this over a long cable to you,
the value can be beaten up by

00:30:24.000 --> 00:30:28.000
noise to such an extent that you
may begin receiving 3s but

00:30:28.000 --> 00:30:35.000
nothing lower than a 3.
So this is a noise margin,

00:30:35.000 --> 00:30:39.000
1 volt.
Similarly, for a 0 the noise

00:30:39.000 --> 00:30:44.000
margin is also 1 volt.
So let me label these.

00:30:44.000 --> 00:30:48.000
There are four important
thresholds here.

00:30:48.000 --> 00:30:53.000
This threshold is called VOL.
V output low.

00:30:53.000 --> 00:31:01.000
These have special meanings.
This threshold here is called

00:31:01.000 --> 00:31:06.000
VOH, V output high.
This threshold here is called V

00:31:06.000 --> 00:31:12.000
input high and this threshold
here is called V input low.

00:31:12.000 --> 00:31:19.000
So VOH simply says that senders
must send voltages higher than

00:31:19.000 --> 00:31:23.000
VOH.
Receivers must receive values

00:31:23.000 --> 00:31:28.000
higher than VIH as a 1.
So these four thresholds

00:31:28.000 --> 00:31:33.000
together give you your
threshold.

00:31:46.000 --> 00:31:50.000
For the sender gets 2.5,
what does sender do?

00:31:50.000 --> 00:31:53.000
It could do that.
So, in that case,

00:31:53.000 --> 00:31:57.000
you can do that.
If all you want to do is have

00:31:57.000 --> 00:32:03.000
one value here then what you
have is an infinitesimal value

00:32:03.000 --> 00:32:07.000
here for the forbidden region.
That's fine.

00:32:07.000 --> 00:32:09.000
It's up to you to design it
that way.

00:32:09.000 --> 00:32:12.000
You can.
But it turns out that when you

00:32:12.000 --> 00:32:14.000
design circuits,
when we see some examples in

00:32:14.000 --> 00:32:18.000
the next lecture it turns out to
be fairly practical and easy to

00:32:18.000 --> 00:32:21.000
do it this way.
But, again, these are design

00:32:21.000 --> 00:32:22.000
choices.
If I'm Intel,

00:32:22.000 --> 00:32:25.000
Intel wants all its parts to
work together.

00:32:25.000 --> 00:32:28.000
So parts that follow a common
discipline can work together,

00:32:28.000 --> 00:32:33.000
right?
Because senders will send

00:32:33.000 --> 00:32:38.000
values, receivers will receive
these values here,

00:32:38.000 --> 00:32:45.000
so it will simply work.
So the noise margin for a 1

00:32:45.000 --> 00:32:52.000
here is simply VOH minus VIH and
the noise margin for a 0 is VIL

00:32:52.000 --> 00:32:57.000
minus VOL.
VIL minus VOL is the noise

00:32:57.000 --> 00:33:02.000
margin for a 0.
So what do we have here?

00:33:02.000 --> 00:33:06.000
What we have here is a
discipline that we've agreed to

00:33:06.000 --> 00:33:11.000
follow where senders are held to
a tough standard and receivers

00:33:11.000 --> 00:33:16.000
are held to a different standard
so that I allow myself some

00:33:16.000 --> 00:33:20.000
margin for error.
And it's up to you as a

00:33:20.000 --> 00:33:24.000
designer to choose ranges for
the forbidden region.

00:33:24.000 --> 00:33:29.000
Now, you may say that I want to
make my forbidden region as

00:33:29.000 --> 00:33:34.000
small as possible.
But you will see in practical

00:33:34.000 --> 00:33:37.000
circuits it's very hard to
achieve that.

00:33:37.000 --> 00:33:41.000
Practical devices that you get,
they have a natural region that

00:33:41.000 --> 00:33:45.000
gets very, very hard to break
apart, and that tends to

00:33:45.000 --> 00:33:48.000
establish what that region looks
like.

00:33:48.000 --> 00:33:53.000
So to continue with an example
here, I may have the following

00:33:53.000 --> 00:33:57.000
voltage wave form for a sender.
So I have some sender,

00:33:57.000 --> 00:34:00.000
I have a sender here.

00:34:08.000 --> 00:34:13.000
I have VOL, VIL,
VIH, VOH and some other high

00:34:13.000 --> 00:34:17.000
voltage.
And then, as a sender,

00:34:17.000 --> 00:34:22.000
if I want to send a "0" "1" "0"
then I send a 0.

00:34:22.000 --> 00:34:29.000
I have to be within this band.
And then for a 1 I have to be

00:34:29.000 --> 00:34:35.000
within this band.
So this is an example of,

00:34:35.000 --> 00:34:41.000
say, "0" "1" "0" "1".
And at the receiver --

00:34:51.000 --> 00:34:55.000
Let's have VOL,
VIL, VIH, VOH.

00:34:55.000 --> 00:35:02.000
So at the receiver,
I interpret any signal below

00:35:02.000 --> 00:35:06.000
VIL as a 0.
So I may get some signal that

00:35:06.000 --> 00:35:08.000
looks like this.

00:35:16.000 --> 00:35:21.000
And I'll still interpret that
as a "0" "1" "0" "1".

00:35:21.000 --> 00:35:26.000
So to summarize here,
this discipline that forms the

00:35:26.000 --> 00:35:34.000
foundations of digital systems
is called "a static discipline".

00:35:41.000 --> 00:36:03.000
The static discipline says if
inputs meet input thresholds --

00:36:03.000 --> 00:36:08.000
So if an input to a digital
system meets the input

00:36:08.000 --> 00:36:14.000
thresholds then outputs will
meet, or the digital system

00:36:14.000 --> 00:36:19.000
should ensure that the outputs
--

00:36:24.000 --> 00:36:29.000
Output thresholds.
So this means that if I have a

00:36:29.000 --> 00:36:35.000
system like this then if I give
it good inputs.

00:36:35.000 --> 00:36:40.000
And by giving it good inputs I
mean for 1s I have signal values

00:36:40.000 --> 00:36:45.000
that are greater than VIH and
for 0s signal values which are

00:36:45.000 --> 00:36:48.000
less than VIL.
These are valid inputs.

00:36:48.000 --> 00:36:53.000
So if my inputs are valid,
that is below VIL for a 0 and

00:36:53.000 --> 00:36:57.000
above VIH for a 1 then this
digital system D will produce

00:36:57.000 --> 00:37:03.000
corresponding outputs that
follow output thresholds.

00:37:03.000 --> 00:37:07.000
For a 1 it will produce outputs
that are greater than VOH and if

00:37:07.000 --> 00:37:12.000
it needs to produce a 0 it will
produce outputs that are less

00:37:12.000 --> 00:37:15.000
than VOL.
So notice that there is this

00:37:15.000 --> 00:37:19.000
tough requirement in digital
systems that for the inputs,

00:37:19.000 --> 00:37:23.000
I should recognize as a 1
anything higher than a VIH.

00:37:23.000 --> 00:37:27.000
But if I want to produce a 1,
I have to produce a tough 1

00:37:27.000 --> 00:37:31.000
like a 4-volt 1.
So there is a discipline that

00:37:31.000 --> 00:37:35.000
all my digital systems must
follow, and that discipline is

00:37:35.000 --> 00:37:39.000
called a static discipline.
So static discipline encodes

00:37:39.000 --> 00:37:42.000
the thresholds,
encodes four thresholds that

00:37:42.000 --> 00:37:46.000
all digital systems must follow
so that they can talk to each

00:37:46.000 --> 00:37:49.000
other.
So if Intel and Motorola want

00:37:49.000 --> 00:37:51.000
to make parts that are
compatible with,

00:37:51.000 --> 00:37:55.000
say, Pentium 4 devices then
they will all talk over the

00:37:55.000 --> 00:38:00.000
phone or something and agree on
a static discipline.

00:38:00.000 --> 00:38:02.000
We will say that,
all right, all my peripherals

00:38:02.000 --> 00:38:05.000
will follow a static discipline
with the following volted

00:38:05.000 --> 00:38:07.000
thresholds.
And this way parts made by

00:38:07.000 --> 00:38:10.000
different manufacturers can
interoperate and still provide

00:38:10.000 --> 00:38:11.000
immunity to noise.
Yes.

00:38:11.000 --> 00:38:13.000
Question?

00:38:19.000 --> 00:38:21.000
Absolutely.
There are many constraints on

00:38:21.000 --> 00:38:24.000
how you as a designer choose the
noise margin.

00:38:24.000 --> 00:38:28.000
As a designer you want to make
your noise margin as large as

00:38:28.000 --> 00:38:32.000
possible.
The larger the noise margin the

00:38:32.000 --> 00:38:35.000
better you can tolerate noise
which is why,

00:38:35.000 --> 00:38:40.000
how many people have heard of
some devices called rad hard

00:38:40.000 --> 00:38:44.000
devices, radiation hard devices?
Some of you have.

00:38:44.000 --> 00:38:48.000
There are a bunch of devices.
Different manufacturers make

00:38:48.000 --> 00:38:52.000
different kinds of devices for
different markets.

00:38:52.000 --> 00:38:57.000
For consumer markets they use
parts which may have relatively

00:38:57.000 --> 00:39:01.000
poor noise margins because
consumers can tolerate more

00:39:01.000 --> 00:39:05.000
faults.
But if you're building devices

00:39:05.000 --> 00:39:09.000
for, say, the medical industry
or for spaceships and so on,

00:39:09.000 --> 00:39:13.000
you need to be held to a much,
much tougher standard.

00:39:13.000 --> 00:39:16.000
So for those devices you may
end up having much,

00:39:16.000 --> 00:39:20.000
much tighter bands in which you
have to operate so you have a

00:39:20.000 --> 00:39:23.000
tougher noise margin.
So that leads us to,

00:39:23.000 --> 00:39:28.000
given these sort of voltage
thresholds, we now move into the

00:39:28.000 --> 00:39:31.000
digital world.
And in the digital world we can

00:39:31.000 --> 00:39:33.000
build a bunch of digital
devices.

00:39:33.000 --> 00:39:36.000
The first device we will look
at is called a combinational

00:39:36.000 --> 00:39:37.000
gate.

00:39:42.000 --> 00:39:46.000
A combinational gate is a
device that adheres to the

00:39:46.000 --> 00:39:51.000
static discipline,
Page 11, and this is a device

00:39:51.000 --> 00:39:56.000
whose outputs are a function of
inputs alone.

00:40:03.000 --> 00:40:07.000
So I can build little boxes
which take some inputs,

00:40:07.000 --> 00:40:13.000
produces an output where the
outputs are a function of the

00:40:13.000 --> 00:40:17.000
existing inputs.
And this kind of a device is

00:40:17.000 --> 00:40:22.000
called a combinational gate.
And I can analyze such devices

00:40:22.000 --> 00:40:28.000
for the kinds of things that I
would like to do.

00:40:28.000 --> 00:40:34.000
Before I go into the kinds of
devices I'd like to build,

00:40:34.000 --> 00:40:39.000
let's spend a few minutes
talking about how to process

00:40:39.000 --> 00:40:44.000
signals.
How to process digital signals,

00:40:44.000 --> 00:40:48.000
Page 10.
So notice that you have two

00:40:48.000 --> 00:40:52.000
values, 0 and a 1.
So devices like my

00:40:52.000 --> 00:40:55.000
combinational gate,
for example,

00:40:55.000 --> 00:41:02.000
can only deal with 0s and 1s.
So I have to come up with some

00:41:02.000 --> 00:41:06.000
kind of a mathematics or some
kind of a set of processing that

00:41:06.000 --> 00:41:10.000
can work with 0,1 values.
So 0,1 map completely natural

00:41:10.000 --> 00:41:15.000
to the logic true and false.
So I can borrow from logic and

00:41:15.000 --> 00:41:19.000
use true and false to do my
processing of signals.

00:41:19.000 --> 00:41:23.000
So if all I care about is
processing logic values,

00:41:23.000 --> 00:41:29.000
0s and 1s, trues and falses
then that's all I need.

00:41:29.000 --> 00:41:33.000
I can also use numbers.
How do I represent a number?

00:41:33.000 --> 00:41:38.000
3.9 which is 0s and 1s.
It turns out that this is a

00:41:38.000 --> 00:41:43.000
whole field in itself.
You'll hear more about this in

00:41:43.000 --> 00:41:46.000
recitation.
Let me also point you to the

00:41:46.000 --> 00:41:52.000
last section of the course
notes, Chapter 5.6 I believe,

00:41:52.000 --> 00:41:57.000
that talks about how to
represent numbers.

00:41:57.000 --> 00:42:01.000
The basic insight is much like
you can represent arbitrary long

00:42:01.000 --> 00:42:05.000
numbers with the digits 0
through 9 in the same way,

00:42:05.000 --> 00:42:09.000
but concatenating digits you
can represent arbitrary long

00:42:09.000 --> 00:42:11.000
numbers with 0-1-1-1-0-0 and so
on.

00:42:11.000 --> 00:42:15.000
So you can have a whole
sequence of digits and you can

00:42:15.000 --> 00:42:19.000
build a binary number system.
So you can read A&L Section

00:42:19.000 --> 00:42:22.000
5.6, I believe.
It's the last section for

00:42:22.000 --> 00:42:24.000
numbers.
And you will also discuss this

00:42:24.000 --> 00:42:31.000
in your recitation tomorrow.
Let me spend some more time

00:42:31.000 --> 00:42:36.000
talking about Boolean logic,
two-valued logic,

00:42:36.000 --> 00:42:40.000
and how to process these
systems.

00:42:40.000 --> 00:42:46.000
So one way of processing it is
using logic statements of the

00:42:46.000 --> 00:42:52.000
following form.
If X is true and Y is true then

00:42:52.000 --> 00:43:00.000
Z is true, else is Z false.
So this is a logic statement.

00:43:00.000 --> 00:43:04.000
It says if X is true and Y is
true then Z is true,

00:43:04.000 --> 00:43:08.000
else Z is false.
So I can process this with 0s

00:43:08.000 --> 00:43:13.000
and 1s, trues and falses.
And I do this all the time so I

00:43:13.000 --> 00:43:16.000
have a succinct notation for
this.

00:43:16.000 --> 00:43:20.000
I express this as Z is X anded
with Y.

00:43:20.000 --> 00:43:24.000
X and Y is Z.
So Z is true if X is true and Y

00:43:24.000 --> 00:43:27.000
is true.
A shorthand notation for this

00:43:27.000 --> 00:43:33.000
is just a dot.
And a circuit notation for this

00:43:33.000 --> 00:43:38.000
is called an "AND gate".
That's a little circuit.

00:43:38.000 --> 00:43:41.000
I haven't told you what's
inside it.

00:43:41.000 --> 00:43:47.000
It's an abstract little device
called an AND gate which takes

00:43:47.000 --> 00:43:54.000
two inputs, produces one output
Z where the output is related to

00:43:54.000 --> 00:43:59.000
the inputs in the following
manner.

00:43:59.000 --> 00:44:03.000
That's a little device called
an AND gate.

00:44:03.000 --> 00:44:07.000
I could also represent logic in
truth tables.

00:44:07.000 --> 00:44:12.000
And truth tables simply
enumerate all the values and the

00:44:12.000 --> 00:44:17.000
corresponding outputs.
Inputs can be 0-0-0-1-1-0 or

00:44:17.000 --> 00:44:21.000
1-1.
For an AND system output is 1,

00:44:21.000 --> 00:44:25.000
only if both are ones,
it's a 0 otherwise.

00:44:25.000 --> 00:44:30.000
So that's a truth table for AND
gate.

00:44:30.000 --> 00:44:36.000
So from 0s and 1s we deal with
logic and we create devices like

00:44:36.000 --> 00:44:40.000
the AND gate to process digital
signals.

00:44:40.000 --> 00:44:46.000
And what we will do is look at
a whole bunch of little symbols

00:44:46.000 --> 00:44:51.000
like this, like the AND gate to
process our input signals.

00:44:51.000 --> 00:44:57.000
And these devices might look
like other functions like OR

00:44:57.000 --> 00:45:03.000
gates and so on.
Let me show you a quick demo.

00:45:03.000 --> 00:45:09.000
What I'm going to show you is a
signal feeding an AND gate.

00:45:09.000 --> 00:45:15.000
And one signal is going to look
like this, and my signal Y is

00:45:15.000 --> 00:45:21.000
going to look like this.
So you expect a processed

00:45:21.000 --> 00:45:23.000
output.
So 1-0-1-0-1-0-1.

00:45:23.000 --> 00:45:29.000
And the output is simply going
to be --

00:45:29.000 --> 00:45:31.000
This is my time axis going this
way.

00:45:31.000 --> 00:45:35.000
It is going to be an AND-ing of
these two signal values like so.

00:45:35.000 --> 00:45:39.000
What I'm also going to show you
is I'm going to superimpose

00:45:39.000 --> 00:45:43.000
noise on this wire.
I'm going to superimpose noise

00:45:43.000 --> 00:45:47.000
on the wire, and what I want you
to observe is the output of this

00:45:47.000 --> 00:45:50.000
digital gate.
The output will stay exactly

00:45:50.000 --> 00:45:52.000
like this, even though I impose
noise.

00:45:52.000 --> 00:45:55.000
The ultimate test.
So stay right there.

00:45:55.000 --> 00:46:00.000
Let's do this demo.
Give me a couple of seconds.

00:47:42.000 --> 00:47:45.000
If you look at the signal up
there, look at the middle wave

00:47:45.000 --> 00:47:49.000
form, and I'm imposing let's
have a digital system in a noisy

00:47:49.000 --> 00:47:52.000
environment like a lumberyard,
for example,

00:47:52.000 --> 00:47:56.000
or chopping a bunch of trees in
my backyard and building digital

00:47:56.000 --> 00:48:00.000
systems on the side.
And if I have my buddies

00:48:00.000 --> 00:48:04.000
revving up chainsaws
superimposing noise on my second

00:48:04.000 --> 00:48:10.000
input, but look at the output.
And just to show that I'm not

00:48:10.000 --> 00:48:13.000
bluffing here,
what I'll do is I'll pass the

00:48:13.000 --> 00:48:17.000
noise through and make the noise
larger.

00:48:17.000 --> 00:48:22.000
And you'll notice that when the
noise begins to surpass the

00:48:22.000 --> 00:48:26.000
noise margins the output begins
to go berserk.

00:48:26.000 --> 00:48:31.000
Watch.
Can you increase it gradually?

00:48:31.000 --> 00:48:35.000
Notice that as I put in a lot
more noise then the output

00:48:35.000 --> 00:48:40.000
begins to go berserk,
but as long as my input is

00:48:40.000 --> 00:48:45.000
within the noise margin my
output stays perfectly stable.

00:48:45.000 --> 00:48:48.000
So that's the "Intro to Digital
Systems".

00:48:48.000 --> 00:48:51.000
You'll see numbers in
recitation.

00:48:51.000 --> 00:48:54.000
And we'll see you at lecture on
Tuesday.