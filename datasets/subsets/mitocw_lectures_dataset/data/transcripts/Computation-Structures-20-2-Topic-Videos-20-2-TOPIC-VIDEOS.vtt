WEBVTT

00:00:01.040 --> 00:00:06.100
Network technologies were developed to connect
components (in this case individual computer

00:00:06.100 --> 00:00:13.769
systems) separated by larger distances, i.e.,
distances measured in meters instead of centimeters.

00:00:13.769 --> 00:00:17.650
Communicating over these larger distances
led to different design tradeoffs.

00:00:17.650 --> 00:00:23.020
In early networks, information was sent as
a sequence of bits over the shared communication

00:00:23.020 --> 00:00:24.020
medium.

00:00:24.020 --> 00:00:28.960
The bits were organized into packets, each
containing the address of the destination.

00:00:28.960 --> 00:00:34.520
Packets also included a checksum used to detect
errors in transmission and the protocol supported

00:00:34.520 --> 00:00:39.520
the ability to request the retransmission
of corrupted packets.

00:00:39.520 --> 00:00:44.520
The software controlling the network is divided
into a "stack" of modules, each implementing

00:00:44.520 --> 00:00:47.330
a different communication abstraction.

00:00:47.330 --> 00:00:52.250
The lowest-level physical layer is responsible
for transmitting and receiving an individual

00:00:52.250 --> 00:00:54.400
packet of bits.

00:00:54.400 --> 00:01:00.130
Bit errors are detected and corrected, and
packets with uncorrectable errors are discarded.

00:01:00.130 --> 00:01:04.819
There are different physical-layer modules
available for the different types of physical

00:01:04.819 --> 00:01:06.350
networks.

00:01:06.350 --> 00:01:10.490
The network layer deals with the addressing
and routing of packets.

00:01:10.490 --> 00:01:15.280
Clever routing algorithms find the shortest
communication path through the multi-hop network

00:01:15.280 --> 00:01:20.760
and deal with momentary or long-term outages
on particular network links.

00:01:20.760 --> 00:01:25.370
The transport layer is responsible for providing
the reliable communication of a stream of

00:01:25.370 --> 00:01:30.390
data, dealing with the issues of discarded
or out-of-order packets.

00:01:30.390 --> 00:01:36.330
In an effort to optimize network usage and
limit packet loses due to network congestion,

00:01:36.330 --> 00:01:42.000
the transport layer deals with flow control,
i.e., the rate at which packets are sent.

00:01:42.000 --> 00:01:47.590
A key idea in the networking community is
the notion of building a reliable communication

00:01:47.590 --> 00:01:51.729
channel on top of a "best efforts" packet
network.

00:01:51.729 --> 00:01:55.939
Higher layers of the protocol are designed
so that its possible to recover from errors

00:01:55.939 --> 00:01:57.280
in the lower layers.

00:01:57.280 --> 00:02:04.119
This has proven to be much more cost-effective
and robust than trying to achieve 100% reliability

00:02:04.119 --> 00:02:06.400
at each layer.

00:02:06.400 --> 00:02:10.799
As we saw in the previous section, there are
a lot of electrical issues when trying to

00:02:10.799 --> 00:02:15.760
communicate over a shared wire with multiple
drivers and receivers.

00:02:15.760 --> 00:02:21.200
Slowing down the rate of communication helps
to solve the problems, but "slow" isn't in

00:02:21.200 --> 00:02:25.629
the cards for today's high-performance systems.

00:02:25.629 --> 00:02:30.489
Experience in the network world has shown
that the fastest and least problematic communication

00:02:30.489 --> 00:02:36.569
channels have a single driver communicating
with a single receiver, what's called a point-to-point

00:02:36.569 --> 00:02:37.790
link.

00:02:37.790 --> 00:02:41.040
Using differential signaling is particularly
robust.

00:02:41.040 --> 00:02:44.739
With differential signaling, the receiver
measures the voltage difference across the

00:02:44.739 --> 00:02:47.010
two signaling wires.

00:02:47.010 --> 00:02:51.029
Electrical effects that might induce voltage
noise on one signaling wire will affect the

00:02:51.029 --> 00:02:57.950
other in equal measure, so the voltage difference
will be largely unaffected by most noise.

00:02:57.950 --> 00:03:02.620
Almost af bus architecture proved to be
a very workable design for accommodating add-in

00:03:04.430 --> 00:03:12.060
cards as long as the rate of transactions
wasn't too fast, say less than 50 Mhz.

00:03:12.060 --> 00:03:17.409
But as system speeds increased, transaction
rates had to increase to keep system performance

00:03:17.409 --> 00:03:22.939
at acceptable levels, so the time for each
transaction got smaller.

00:03:22.939 --> 00:03:27.989
With less time for signaling on the bus wires,
various effects began loom large.

00:03:27.989 --> 00:03:33.079
If the clock had too short a period, there
wasn't enough time for the master to see the

00:03:33.079 --> 00:03:38.170
assertion edge, enable its drivers,
have the signal propagate down a long bus

00:03:38.170 --> 00:03:42.980
to the intended receiver and be stable at
each receiver for long enough before the sample

00:03:42.980 --> 00:03:44.550
edge.

00:03:44.550 --> 00:03:49.079
Another problem was that the clock signal
would arrive at different cards at different

00:03:49.079 --> 00:03:50.140
times.

00:03:50.140 --> 00:03:55.049
So a card with an early-arriving clock might
decide it was its turn to start driving the

00:03:55.049 --> 00:03:59.719
bus signals, while a card with a late-arriving
clock might still be driving the bus from

00:03:59.719 --> 00:04:01.349
the previous cycle.

00:04:01.349 --> 00:04:05.409
These momentary conflicts between drivers
could add huge amounts of electrical noise

00:04:05.409 --> 00:04:07.750
to the system.

00:04:07.750 --> 00:04:13.110
Another big issue is that energy would reflect
off all the small impedance discontinuities

00:04:13.110 --> 00:04:15.280
caused by the bus connectors.

00:04:15.280 --> 00:04:19.570
If there were many connectors, there would
be many small echoes which would could corrupt

00:04:19.570 --> 00:04:22.550
the signal seen by various receivers.

00:04:22.550 --> 00:04:26.331
The equations in the upper right show how
much of the signal energy is transmitted and

00:04:26.331 --> 00:04:30.229
how much is reflected at each discontinuity.

00:04:30.229 --> 00:04:35.870
The net effect was like trying to talk very
fast while yelling into the Grand Canyon.

00:04:35.870 --> 00:04:41.060
The echoes could distort the message beyond
recognition unless sufficient time was allocated

00:04:41.060 --> 00:04:44.750
between words for the echoes to die away.

00:04:44.750 --> 00:04:50.460
Eventually buses were relegated to relatively
low-speed communication tasks and a different

00:04:50.460 --> 00:04:53.470
approach had to be developed for high-speed
communication.e at both ends.

00:05:08.580 --> 00:05:13.150
What this model is telling is the time it
takes to transmit information from one component

00:05:13.150 --> 00:05:18.889
to another and that we have to be careful
to absorb the energy associated with the transmission

00:05:18.889 --> 00:05:22.730
when the information has reached its destination.

00:05:22.730 --> 00:05:27.110
With that little bit of theory as background,
we're in a position to describe the real-world

00:05:27.110 --> 00:05:31.110
consequences of poor engineering of our signal
wires.

00:05:31.110 --> 00:05:36.470
The key observation is that unless we're careful
there can still be energy left over from previous

00:05:36.470 --> 00:05:41.020
transmissions that might corrupt the current
transmission.

00:05:41.020 --> 00:05:46.190
The general fix to this problem is time, i.e.,
giving the transmitted value a longer time

00:05:46.190 --> 00:05:49.409
to settle to an interference-free value.

00:05:49.409 --> 00:05:54.170
But slowing down isn't usually acceptable
in high-performance systems, so we have to

00:05:54.170 --> 00:05:58.759
do our best to minimize these energy-storage
effects.

00:05:58.759 --> 00:06:03.560
If the termination isn't exactly right, we'll
get some reflections from any voltage step

00:06:03.560 --> 00:06:08.630
reaching the end of the wire, and it will
take a while for these echoes to die out.

00:06:08.630 --> 00:06:14.039
In fact, as we'll see, energy will reflect
off of any impedance discontinuity, which

00:06:14.039 --> 00:06:17.759
means we'll want to minimize the number of
such discontinuities.

00:06:17.759 --> 00:06:24.440
We need to be careful to allow sufficient
time for signals to reach valid logic levels.

00:06:24.440 --> 00:06:31.020
The shaded region shows a transition of the
wire A from 1 to 0 to 1.

00:06:31.020 --> 00:06:35.590
The first inverter is trying to produce a
1-output from the initial input transition

00:06:35.590 --> 00:06:41.180
to 0, but doesn't have sufficient time to
complete the transition on wire B before the

00:06:41.180 --> 00:06:43.800
input changes again.

00:06:43.800 --> 00:06:49.139
This leads to a runt pulse on wire C, the
output of the second inverter, and we see

00:06:49.139 --> 00:06:55.400
that the sequence of bits on A has been corrupted
by the time the signal reaches C.

00:06:55.400 --> 00:07:00.210
This problem was caused by the energy storage
in the capacitance of the wire between the

00:07:00.210 --> 00:07:04.500
inverters, which will limit the speed at which
we can run the logic.

00:07:04.500 --> 00:07:11.390
And here see we what happens when a large
voltage step triggers oscillations in a wire,

00:07:11.390 --> 00:07:16.220
called ringing, due to the wire's inductance
and capacitance.

00:07:16.220 --> 00:07:20.710
The graph shows it takes some time before
the ringing dampens to the point that we have

00:07:20.710 --> 00:07:23.830
a reliable digital signal.

00:07:23.830 --> 00:07:28.759
The ringing can be diminished by spreading
the voltage step over a longer time.

00:07:28.759 --> 00:07:34.110
The key idea here is that by paying close
attention to the design of our wiring and

00:07:34.110 --> 00:07:39.240
the drivers that put information onto the
wire, we can minimize the performance implications

00:07:39.240 --> 00:07:42.100
of these energy-storage effects.

00:07:42.100 --> 00:07:45.280
Okay, enough electrical engineering!

00:07:45.280 --> 00:07:48.319
Suppose we have some information in our system.

00:07:48.319 --> 00:07:53.050
If we preserve that information over time,
we call that storage.

00:07:53.050 --> 00:07:58.129
If we send that information to another component,
we call that communication.

00:07:58.129 --> 00:08:03.599
In the real world, we've seen that communication
takes time and we have to budget for that

00:08:03.599 --> 00:08:05.819
time in our system timing.

00:08:05.819 --> 00:08:11.800
Our engineering has to accommodate the fundamental
bounds on propagating speeds, distances between

00:08:11.800 --> 00:08:16.919
components, and how fast we can change wire
voltages without triggering the effects we

00:08:16.919 --> 00:08:18.970
saw on the previous slide.

00:08:18.970 --> 00:08:24.940
The upshot: our timing models will have to
account for wire delays.

00:08:24.940 --> 00:08:29.169
In Part 1 of this course, we had a simple
timing model that assigned a fixed propagation

00:08:29.169 --> 00:08:34.929
delay, t_PD, to the time it took for the output
of a logic gate to reflect a change to the

00:08:34.929 --> 00:08:36.260
gate's input.

00:08:36.260 --> 00:08:41.419
We'll need to change our timing model to account
for delay of transmitting the output of a

00:08:41.419 --> 00:08:44.600
logic gate to the next components.

00:08:44.600 --> 00:08:50.300
The timing will be load dependent, so signals
that connect to the inputs of many other gates

00:08:50.300 --> 00:08:54.050
will be slower than signals that connect to
only one other gate.

00:08:54.050 --> 00:09:00.149
The Jade simulator takes the loading of a
gate's output signal into account when calculating

00:09:00.149 --> 00:09:03.890
the effective propagation delay of the gate.

00:09:03.890 --> 00:09:09.200
We can improve propagation delays by reducing
the number of loads on output signals or by

00:09:09.200 --> 00:09:15.550
using specially-design gates called buffers
(the component shown in red) to drive signals

00:09:15.550 --> 00:09:17.580
that have very large loads.

00:09:17.580 --> 00:09:23.790
A common task when optimizing the performance
of a circuit is to track down heavily-loaded

00:09:23.790 --> 00:09:30.480
and hence slow wires and re-engineering the
circuit to make them faster.

00:09:30.480 --> 00:09:35.440
Today our concern is wires used to connect
components at the system level.

00:09:35.440 --> 00:09:40.490
So next we'll turn our attention to possible
designs for system-level interconnect and

00:09:40.490 --> 00:09:42.050
the issues that might arise.