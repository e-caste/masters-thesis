WEBVTT

00:00:00.000 --> 00:00:03.944
[SQUEAKING][RUSTLING][CLICKING]

00:00:25.190 --> 00:00:27.800
MICHAEL SIPSER: So we are--

00:00:27.800 --> 00:00:31.830
welcome back, everybody.

00:00:31.830 --> 00:00:39.300
And we are going to
continue our discussion

00:00:39.300 --> 00:00:46.050
of computability theory,
Turing machines, and how

00:00:46.050 --> 00:00:51.100
to prove things undecidable,
which is what we've been doing.

00:00:51.100 --> 00:00:54.480
So we talked about this
more advanced method

00:00:54.480 --> 00:00:56.820
of proving things undecidable
last lecture, called

00:00:56.820 --> 00:01:01.260
the computation history
method, which comes up

00:01:01.260 --> 00:01:06.900
in all sorts of proofs of
undecidability, usually more

00:01:06.900 --> 00:01:08.220
complex ones.

00:01:08.220 --> 00:01:13.193
Such as, for example, the
proof of Hilbert's 10th problem

00:01:13.193 --> 00:01:14.610
that I mentioned,
whether you want

00:01:14.610 --> 00:01:19.170
to-- if you want to test
whether a polynomial has

00:01:19.170 --> 00:01:23.220
a solution in integers.

00:01:23.220 --> 00:01:25.710
It's a reduction from
ATM, just like we've

00:01:25.710 --> 00:01:26.850
been doing all along.

00:01:26.850 --> 00:01:29.160
All of those proofs are
pretty much reductional

00:01:29.160 --> 00:01:30.690
from something undecidable.

00:01:30.690 --> 00:01:35.730
This reduction from ATM is as
good a starting point as any.

00:01:35.730 --> 00:01:40.360
And it uses the
computation history method.

00:01:40.360 --> 00:01:43.200
So what they end up doing
is, given a Turing machine

00:01:43.200 --> 00:01:46.600
and an input, you
construct a polynomial

00:01:46.600 --> 00:01:48.460
that has several variables.

00:01:48.460 --> 00:01:54.930
And where in order to
get an integer root,

00:01:54.930 --> 00:01:58.470
an integer solution
of that polynomial,

00:01:58.470 --> 00:02:00.600
one of the variables
is going to have

00:02:00.600 --> 00:02:03.780
to be assigned to
some kind of encoding

00:02:03.780 --> 00:02:09.600
of a computation history of
the Turing machine of M on w.

00:02:09.600 --> 00:02:14.280
One of those variables is going
to be a computation history--

00:02:14.280 --> 00:02:19.320
an integer which represents the
computation history for m on W.

00:02:19.320 --> 00:02:22.770
And the other
variables are there

00:02:22.770 --> 00:02:25.260
to help you kind
of decode that so

00:02:25.260 --> 00:02:29.590
that the polynomial can actually
check and make a solution.

00:02:29.590 --> 00:02:31.540
It becomes a solution
if that actually

00:02:31.540 --> 00:02:35.048
is a legitimate computation
history of m on W.

00:02:35.048 --> 00:02:37.090
So it really uses the very
same method that we've

00:02:37.090 --> 00:02:42.310
been using all along,
but it's pretty hairy

00:02:42.310 --> 00:02:47.170
to construct that polynomial
and do the check in the way

00:02:47.170 --> 00:02:48.830
that you need to do.

00:02:48.830 --> 00:02:50.420
So for the Post
Correspondence problem

00:02:50.420 --> 00:02:53.380
which we introduced last
time, doing the check

00:02:53.380 --> 00:02:55.400
is relatively simple.

00:02:55.400 --> 00:03:00.010
You know that the match is
the computation history,

00:03:00.010 --> 00:03:03.190
and following the
rules of the match,

00:03:03.190 --> 00:03:08.230
it's fairly simple to construct
that Post Correspondence

00:03:08.230 --> 00:03:09.260
problem instance.

00:03:09.260 --> 00:03:12.460
We talked about linearly
bounded automata.

00:03:12.460 --> 00:03:15.700
Of course, we defined
configurations and computation

00:03:15.700 --> 00:03:18.400
histories along the way and
proved certain problem--

00:03:18.400 --> 00:03:22.940
other problems are undecidable
as well using the same method.

00:03:22.940 --> 00:03:28.100
OK, so today, we're
going to shift gears.

00:03:28.100 --> 00:03:30.380
We're going to--
in our last lecture

00:03:30.380 --> 00:03:35.070
on the computability
section of the course,

00:03:35.070 --> 00:03:37.820
we're going to talk about
something called the recursion

00:03:37.820 --> 00:03:44.060
theorem, which basically gives
Turing machines the ability

00:03:44.060 --> 00:03:45.410
to refer to themselves.

00:03:45.410 --> 00:03:47.630
Turing machines in
any program, to do

00:03:47.630 --> 00:03:50.090
self-reference so
that you can actually

00:03:50.090 --> 00:03:52.400
get at the code of
the Turing machine

00:03:52.400 --> 00:03:55.160
or the code of the program
that you're writing.

00:03:55.160 --> 00:03:59.523
Even if that's not a built-in
primitive of the programming

00:03:59.523 --> 00:04:01.940
language or the operating
system that you're working with,

00:04:01.940 --> 00:04:04.410
it still gives you that access.

00:04:04.410 --> 00:04:06.660
And also, we're going to--
if we have time at the end,

00:04:06.660 --> 00:04:09.243
I'm going to talk a little bit
about mathematical logic, which

00:04:09.243 --> 00:04:11.630
is sort of a nice application
of the recursion theorem.

00:04:11.630 --> 00:04:13.910
And it's a beautiful
subject on its own.

00:04:13.910 --> 00:04:16.519
And it's something that I can
give a brief introduction to.

00:04:16.519 --> 00:04:24.850
OK, so today's topic is
about self-reference,

00:04:24.850 --> 00:04:28.540
self-reproducing machines,
and the broader topic

00:04:28.540 --> 00:04:31.270
called the recursion theorem.

00:04:31.270 --> 00:04:34.210
So let me introduce it
with what I would call

00:04:34.210 --> 00:04:37.190
the self-reproduction paradox.

00:04:37.190 --> 00:04:43.775
And that is, suppose you have
a factory, like a Tesla effect

00:04:43.775 --> 00:04:46.280
or a car manufacturing factory.

00:04:48.980 --> 00:04:52.430
See, there's a picture
of the factory,

00:04:52.430 --> 00:04:55.160
and it's producing cars.

00:04:55.160 --> 00:04:56.590
All right?

00:04:56.590 --> 00:04:58.870
So we have a factory
that makes cars.

00:04:58.870 --> 00:05:07.690
And what can we say about the
relative complexity of the cars

00:05:07.690 --> 00:05:10.375
compared with the factory,
in some informal sense?

00:05:13.370 --> 00:05:15.610
So I would argue
that you would be

00:05:15.610 --> 00:05:21.460
reasonable to say that the
complexity of the factory

00:05:21.460 --> 00:05:26.200
is going to have to be greater
than the complexity of the cars

00:05:26.200 --> 00:05:28.250
that it makes.

00:05:28.250 --> 00:05:30.590
Because not only
does the factory

00:05:30.590 --> 00:05:32.420
have to know how
to make the cars,

00:05:32.420 --> 00:05:34.130
so it has to have
all the instructions

00:05:34.130 --> 00:05:36.410
and whatever things
that go into a car,

00:05:36.410 --> 00:05:42.695
it has to be included in
at least some kind of--

00:05:42.695 --> 00:05:47.030
it has to be, in some sense,
represented in the factory.

00:05:47.030 --> 00:05:51.480
But the factory also has
to have other stuff--

00:05:51.480 --> 00:05:56.460
the robots, and the other
manufacturing items,

00:05:56.460 --> 00:05:59.100
tools, and so on--
for making the cars.

00:05:59.100 --> 00:06:02.460
So the factory has to
have all the complexity

00:06:02.460 --> 00:06:06.100
of a car incorporated
plus other things as well.

00:06:06.100 --> 00:06:09.030
And for that reason,
one could imagine

00:06:09.030 --> 00:06:15.250
that the factory's complexity is
more than the car's complexity.

00:06:15.250 --> 00:06:18.610
But now, suppose you want
to have a factory that

00:06:18.610 --> 00:06:21.093
makes factories--

00:06:21.093 --> 00:06:22.385
so imagine here's the picture--

00:06:25.370 --> 00:06:29.360
or in general, a machine
that makes copies of itself.

00:06:29.360 --> 00:06:35.900
Well, that seems, at first
glance, to be impossible.

00:06:35.900 --> 00:06:39.650
Because not only does
the factory obviously

00:06:39.650 --> 00:06:42.860
have to have all of the
instructions for what

00:06:42.860 --> 00:06:47.960
a factory is like, but it needs
to have all of the extra things

00:06:47.960 --> 00:06:49.790
that it would need to
do the manufacturing.

00:06:52.340 --> 00:06:55.610
And so for that reason,
it seems like it's not

00:06:55.610 --> 00:07:00.980
possible to have a machine
make copies of itself.

00:07:00.980 --> 00:07:04.190
I mean, you would run
into the very same problem

00:07:04.190 --> 00:07:08.660
if I asked you to
produce a program

00:07:08.660 --> 00:07:14.330
in your favorite language
that prints out itself--

00:07:14.330 --> 00:07:17.450
an exact copy of the same code.

00:07:17.450 --> 00:07:19.340
You can always write
a program which

00:07:19.340 --> 00:07:23.150
is going to print out some
string, like Hello, world.

00:07:23.150 --> 00:07:25.640
That's easy because you
just put Hello, world

00:07:25.640 --> 00:07:32.000
into some kind of a variable
or some sort of a table

00:07:32.000 --> 00:07:34.710
into the program and
say print that table.

00:07:34.710 --> 00:07:40.730
But if you want the program
to print out a copy of itself,

00:07:40.730 --> 00:07:44.000
you can't take the whole program
and stick that into a table

00:07:44.000 --> 00:07:48.050
because the program
is going to have

00:07:48.050 --> 00:07:50.090
to be bigger than the table.

00:07:50.090 --> 00:07:53.240
And so, you're going to
end up with something

00:07:53.240 --> 00:07:54.620
impossible happening.

00:07:54.620 --> 00:07:57.710
Because the program-- an
entire copy of the program

00:07:57.710 --> 00:08:00.890
can't fit inside the program.

00:08:00.890 --> 00:08:05.240
You just get the program
inside itself, inside itself,

00:08:05.240 --> 00:08:07.050
inside itself, forever.

00:08:07.050 --> 00:08:11.010
And so, you end up with an
infinite program that way.

00:08:11.010 --> 00:08:16.350
So if you just kind of
naively approach the problem

00:08:16.350 --> 00:08:17.850
for how to make a
program which is

00:08:17.850 --> 00:08:22.390
going to print out a copy of
itself, it's not so easy to do.

00:08:22.390 --> 00:08:25.900
But hopefully, after
today's lecture,

00:08:25.900 --> 00:08:29.770
you will see that it is possible
and in fact, how to do it.

00:08:29.770 --> 00:08:35.250
And not only that is an
idle bit of curiosity,

00:08:35.250 --> 00:08:37.530
but there are
actually applications

00:08:37.530 --> 00:08:39.960
for why you might want
to do that, mainly

00:08:39.960 --> 00:08:45.000
within mathematics and in
computer science theory.

00:08:45.000 --> 00:08:47.890
But there's even a kind of
a real-world application,

00:08:47.890 --> 00:08:49.697
if you will, in a way too.

00:08:49.697 --> 00:08:51.030
So we'll get to that at the end.

00:08:54.130 --> 00:08:56.620
So it seems, as I'm
saying, impossible to have

00:08:56.620 --> 00:08:57.910
a self-reproducing machine.

00:08:57.910 --> 00:09:00.820
But we know that
in the world, there

00:09:00.820 --> 00:09:06.290
are things that make copies
of themselves-- living things.

00:09:06.290 --> 00:09:09.220
So it seems like a paradox.

00:09:09.220 --> 00:09:12.430
Cells can make copies
exactly of themselves.

00:09:12.430 --> 00:09:15.230
All living things can
make copies of themselves.

00:09:15.230 --> 00:09:19.720
So how do they manage to
get around this paradox?

00:09:19.720 --> 00:09:24.370
Well, in fact, it is no
paradox because it is possible

00:09:24.370 --> 00:09:27.610
to make a machine
that self-reproduces,

00:09:27.610 --> 00:09:29.000
that makes copies of itself.

00:09:29.000 --> 00:09:32.830
And this has been
known for many years.

00:09:32.830 --> 00:09:35.860
Probably, it goes
back to Von Neumann

00:09:35.860 --> 00:09:40.280
who wrote a famous paper on
self-reproducing machines.

00:09:40.280 --> 00:09:43.475
OK, so self-reproducing
machines are, in fact, possible.

00:09:47.140 --> 00:09:48.880
So let me give you
an example of how

00:09:48.880 --> 00:09:51.010
you would make a
self-reproducing Turing

00:09:51.010 --> 00:09:52.360
machine.

00:09:52.360 --> 00:09:54.460
What do we mean by that?

00:09:54.460 --> 00:09:55.810
I mean a machine--

00:09:55.810 --> 00:09:58.190
I'm going to call it SELF--

00:09:58.190 --> 00:10:01.150
which ignores its input.

00:10:01.150 --> 00:10:05.950
So on any input, you turn it
on, the machine grinds around

00:10:05.950 --> 00:10:10.330
for a while, and halts with
a description of itself

00:10:10.330 --> 00:10:11.740
on the tape--

00:10:11.740 --> 00:10:14.500
with the description
of SELF, its own code,

00:10:14.500 --> 00:10:16.060
sitting on the tape.

00:10:16.060 --> 00:10:19.330
So very much like
producing a program which

00:10:19.330 --> 00:10:24.670
would print out its own code,
that's really what we're doing.

00:10:27.280 --> 00:10:29.230
So for that, we're
going to first need

00:10:29.230 --> 00:10:31.790
a little lemma, which
is a very simple lemma,

00:10:31.790 --> 00:10:35.780
but it looks worse than it is.

00:10:35.780 --> 00:10:38.530
So let me just
read it out to you,

00:10:38.530 --> 00:10:40.210
and then I'll explain
what its saying.

00:10:40.210 --> 00:10:43.640
Because what it's saying
is extremely simple.

00:10:43.640 --> 00:10:45.370
So there's a
computable function,

00:10:45.370 --> 00:10:47.600
I'm going to call
it q, that maps

00:10:47.600 --> 00:10:52.470
strings to strings, which
will take any string,

00:10:52.470 --> 00:10:58.155
w, and produce from w a Turing
machine which will print w.

00:11:01.040 --> 00:11:01.540
OK?

00:11:01.540 --> 00:11:02.350
That's all it does.

00:11:02.350 --> 00:11:05.440
So as you know, if I
give you a string, w,

00:11:05.440 --> 00:11:07.330
you could produce
a Turing machine

00:11:07.330 --> 00:11:12.790
which would have w
represented in the states

00:11:12.790 --> 00:11:14.500
and transitions of the machine.

00:11:14.500 --> 00:11:19.120
So that if you turn the machine
on, the machine will output w.

00:11:19.120 --> 00:11:22.930
If I want you to give
me a Turing machine that

00:11:22.930 --> 00:11:26.950
prints the string 1, 1, 0, 1 on
the tape, you could do that--

00:11:26.950 --> 00:11:28.720
I hope.

00:11:28.720 --> 00:11:31.900
And no matter what that
string was, instead of 1, 1,

00:11:31.900 --> 00:11:38.560
0, 0, or whatever, it's
20 0's and then five 1's,

00:11:38.560 --> 00:11:40.120
you could do that too.

00:11:40.120 --> 00:11:44.140
And in fact, there's
a simple procedure

00:11:44.140 --> 00:11:46.900
that takes a string
and maps that

00:11:46.900 --> 00:11:51.090
onto a Turing machine which
prints out that string.

00:11:51.090 --> 00:11:58.710
So that's a computable function,
which basically takes a string

00:11:58.710 --> 00:12:04.050
and converts it to something
that evaluates to that string.

00:12:04.050 --> 00:12:06.303
And I'm calling it q.

00:12:06.303 --> 00:12:08.220
I don't know if this is
helpful to you or not.

00:12:08.220 --> 00:12:12.480
It's kind of like it converts
the string w to w in quotes.

00:12:12.480 --> 00:12:17.380
So q stands for
quotes, in a way.

00:12:17.380 --> 00:12:23.360
So if that's helpful, then good.

00:12:23.360 --> 00:12:26.680
But anyway, Pw is
a Turing machine.

00:12:26.680 --> 00:12:32.580
When you turn it on, it
just prints out w and halts.

00:12:32.580 --> 00:12:34.740
And I can find Pw from w--

00:12:37.630 --> 00:12:40.060
straightforward proof.

00:12:40.060 --> 00:12:43.300
So now, I'm going to
tell you, assuming

00:12:43.300 --> 00:12:51.420
that we have that
computable function, q,

00:12:51.420 --> 00:12:55.970
I'm going to tell you how
to make this machine SELF.

00:12:55.970 --> 00:12:57.620
And it's not complicated.

00:13:00.320 --> 00:13:04.570
The Turing machine
SELF is going to have

00:13:04.570 --> 00:13:07.330
two parts I'll call
A and B. Here's

00:13:07.330 --> 00:13:09.710
a schematic for the machine.

00:13:09.710 --> 00:13:10.960
So here's SELF.

00:13:10.960 --> 00:13:12.970
It's in two parts A and B.

00:13:12.970 --> 00:13:16.750
And what I mean by A and B,
it's like two separate teams.

00:13:16.750 --> 00:13:19.120
SELF is going to
start out running A,

00:13:19.120 --> 00:13:22.090
and when A is finished, it's
going to pass control to B.

00:13:22.090 --> 00:13:23.860
And then B is going
to finish the job.

00:13:23.860 --> 00:13:26.320
And when it's done, you're
going to have the description

00:13:26.320 --> 00:13:29.790
SELF sitting here on the tape.

00:13:29.790 --> 00:13:31.580
All right?

00:13:31.580 --> 00:13:38.060
So what's left is to give
you the code for A and for B.

00:13:38.060 --> 00:13:43.820
So A is going to be
something super simple.

00:13:43.820 --> 00:13:48.950
A is going to be that
machine which prints out B--

00:13:48.950 --> 00:13:52.040
prints out a description
of B. The one

00:13:52.040 --> 00:13:54.940
that I described up here.

00:13:54.940 --> 00:14:00.450
So remember, Pw is the
machine which prints out w.

00:14:00.450 --> 00:14:03.360
And P sub the description
of B is simply

00:14:03.360 --> 00:14:08.610
going to machine that has
this string, PB, stored

00:14:08.610 --> 00:14:10.540
in its states and transitions.

00:14:10.540 --> 00:14:13.110
You turn on that machine,
and it prints out B,

00:14:13.110 --> 00:14:15.180
and then it's done.

00:14:15.180 --> 00:14:16.310
So this is a very simple--

00:14:16.310 --> 00:14:17.760
A is very simple.

00:14:17.760 --> 00:14:29.040
So here, PB is a part of
A. And when it's done,

00:14:29.040 --> 00:14:30.390
B appears on the tape.

00:14:30.390 --> 00:14:34.510
So that's at the point when
A has finished its work.

00:14:34.510 --> 00:14:37.340
Now it's going to
pass control to B.

00:14:37.340 --> 00:14:40.190
So we're not obviously done
yet, because what we want

00:14:40.190 --> 00:14:42.450
is A and B both
to be on the tape,

00:14:42.450 --> 00:14:45.030
not just B. Because SELF
is a combination of A and B

00:14:45.030 --> 00:14:45.530
together.

00:14:48.860 --> 00:14:53.920
So I have to tell you how
B works to finish the job.

00:14:56.860 --> 00:15:02.370
So you might think,
as a first, given

00:15:02.370 --> 00:15:04.890
what we did for
getting B on the tape,

00:15:04.890 --> 00:15:07.530
that we'll get A on the
tape in the same way,

00:15:07.530 --> 00:15:16.570
by putting a copy of A inside
B. So a copy of B is inside A,

00:15:16.570 --> 00:15:21.230
and a copy of A is inside B.

00:15:21.230 --> 00:15:23.540
And at some
conceptual level, that

00:15:23.540 --> 00:15:24.950
seems like that
might do the job.

00:15:24.950 --> 00:15:26.090
But it's really not--

00:15:26.090 --> 00:15:28.470
that is not a solution.

00:15:28.470 --> 00:15:32.880
Because the fact that I
can put B inside A kind of

00:15:32.880 --> 00:15:34.478
forbids me from also
putting A inside

00:15:34.478 --> 00:15:36.270
P, because that's going
to be the same kind

00:15:36.270 --> 00:15:38.580
of circular reasoning
of just putting

00:15:38.580 --> 00:15:39.948
a machine inside itself.

00:15:39.948 --> 00:15:41.490
You just can't do
that because you're

00:15:41.490 --> 00:15:43.110
going to end up with an
infinitely big machine

00:15:43.110 --> 00:15:43.610
that way.

00:15:46.140 --> 00:15:50.166
In fact, if I'm
putting B inside A--

00:15:50.166 --> 00:15:53.702
a copy of B in terms of
its description inside A, A

00:15:53.702 --> 00:15:55.410
is really going to be
much bigger than B.

00:15:55.410 --> 00:15:59.510
Because it has all of B with
inside it, plus other stuff--

00:15:59.510 --> 00:16:03.360
all the states and transitions
for printing that B out.

00:16:03.360 --> 00:16:05.730
So I can't have the A
be much bigger than B

00:16:05.730 --> 00:16:07.560
and then B also
much bigger than A.

00:16:07.560 --> 00:16:11.632
So this is no good.

00:16:11.632 --> 00:16:13.340
We're going to have
to do something else.

00:16:17.030 --> 00:16:19.810
So how is B now going
to get ahold of A?

00:16:24.690 --> 00:16:31.960
And the trick for doing
that, without having

00:16:31.960 --> 00:16:35.410
a copy of A inside B--
which doesn't work.

00:16:35.410 --> 00:16:37.450
That's not going to
be a good solution.

00:16:37.450 --> 00:16:39.670
Instead, the way that
B is going to get A,

00:16:39.670 --> 00:16:41.230
it's going to figure
out what A is.

00:16:41.230 --> 00:16:44.890
It's going to figure
out what A is.

00:16:44.890 --> 00:16:47.470
And how is it going to
figure out what A is?

00:16:47.470 --> 00:16:53.900
Because if you remember, B can
now look can look at the tape.

00:16:53.900 --> 00:16:55.925
It sees some string
there which happens

00:16:55.925 --> 00:16:58.050
to be a description of
itself, but it doesn't care.

00:16:58.050 --> 00:17:00.170
It sees some string on the tape.

00:17:00.170 --> 00:17:02.840
A is the machine that
prints out that string.

00:17:07.790 --> 00:17:10.445
A is q of this string.

00:17:15.130 --> 00:17:19.089
So B is simply going to
compute q of whatever it

00:17:19.089 --> 00:17:21.089
sees on the tape.

00:17:21.089 --> 00:17:28.230
That is A. OK?

00:17:28.230 --> 00:17:29.760
So I don't know if you can read.

00:17:29.760 --> 00:17:31.320
That's kind of small here.

00:17:31.320 --> 00:17:34.920
It's going to compute A
from B sitting on the tape.

00:17:34.920 --> 00:17:36.780
So here is the
instructions for B.

00:17:36.780 --> 00:17:40.740
It's going to compute q of
the tape contents, which

00:17:40.740 --> 00:17:43.050
happens to be the
description of B.

00:17:43.050 --> 00:17:45.390
But that's irrelevant
to B. B just sees

00:17:45.390 --> 00:17:46.770
some string on the tape.

00:17:46.770 --> 00:17:51.300
It computes q of
that, and that is A.

00:17:51.300 --> 00:17:55.940
Because A is the machine
which prints out that string.

00:17:55.940 --> 00:17:59.750
Then it's going to
combine A with B,

00:17:59.750 --> 00:18:02.600
doing whatever
slight interfacing

00:18:02.600 --> 00:18:03.830
that needs to happen--

00:18:03.830 --> 00:18:06.760
I'm not going to get
into those details--

00:18:06.760 --> 00:18:10.700
to convert those two
pieces into one machine,

00:18:10.700 --> 00:18:14.200
which is the machine SELF.

00:18:14.200 --> 00:18:16.810
And then it's going to print out
with SELF on the tape, as I'm

00:18:16.810 --> 00:18:17.977
going to indicate over here.

00:18:22.080 --> 00:18:23.040
OK?

00:18:23.040 --> 00:18:27.960
So that's how a
Turing machine can

00:18:27.960 --> 00:18:30.720
print out a copy of
its own description

00:18:30.720 --> 00:18:31.770
and leave it on the tape.

00:18:34.988 --> 00:18:36.530
And what's nice
about this is nothing

00:18:36.530 --> 00:18:37.950
specific about Turing machines.

00:18:37.950 --> 00:18:42.890
This is a general
procedure that allows

00:18:42.890 --> 00:18:45.560
any programming
language to print out

00:18:45.560 --> 00:18:46.550
a copy of its own code.

00:18:46.550 --> 00:18:49.400
You can even carry
this out in English,

00:18:49.400 --> 00:18:50.990
as I'm going to do
in the next slide.

00:18:55.990 --> 00:18:57.967
OK, so here's a good question.

00:18:57.967 --> 00:18:59.800
There are many possible
Turing machines that

00:18:59.800 --> 00:19:02.410
can print out B. That's right.

00:19:02.410 --> 00:19:04.810
How do I know how to
get the particular one?

00:19:04.810 --> 00:19:06.640
What I have in mind,
that's a little bit

00:19:06.640 --> 00:19:08.995
of a subtle question,
but it's a good question.

00:19:12.210 --> 00:19:15.960
I have in mind the
particular Turing machine

00:19:15.960 --> 00:19:19.470
that prints out B, which
is the one that q produces.

00:19:22.180 --> 00:19:25.150
Remember, so we have to
refer back to this lemma.

00:19:25.150 --> 00:19:27.970
This lemma produces
a particular machine

00:19:27.970 --> 00:19:32.350
that prints out B from B.

00:19:32.350 --> 00:19:35.193
And that's the one that
I'm going to use for A,

00:19:35.193 --> 00:19:36.610
and that's the one
that B is going

00:19:36.610 --> 00:19:41.020
to be able to obtain by running
the q algorithm to figure out

00:19:41.020 --> 00:19:41.860
what A is.

00:19:41.860 --> 00:19:44.183
So you have to make sure
you're being consistent then.

00:19:44.183 --> 00:19:46.600
That's a little bit of a detail,
but it's a good question.

00:19:49.590 --> 00:19:51.870
And why doesn't this create
a circular argument too?

00:19:51.870 --> 00:19:53.820
Well, so that was
another question

00:19:53.820 --> 00:19:55.510
I'm seeing here on the tape.

00:19:55.510 --> 00:19:57.810
Well, there's no
longer anything-- see,

00:19:57.810 --> 00:20:01.500
B does not have to have
A stored within it.

00:20:01.500 --> 00:20:03.240
It figures out A.

00:20:03.240 --> 00:20:06.975
So in a sense, you're going
to write the code for B first.

00:20:09.620 --> 00:20:10.850
B is just a simple program.

00:20:10.850 --> 00:20:11.503
Here it is.

00:20:11.503 --> 00:20:12.920
There's nothing
circular about it.

00:20:12.920 --> 00:20:15.380
It says B is a
simple-- the code for B

00:20:15.380 --> 00:20:20.400
is, take a look at the
tape, compute q of that,

00:20:20.400 --> 00:20:23.220
combine the result with
whatever was sitting on the tape

00:20:23.220 --> 00:20:26.950
from before, and print it out.

00:20:26.950 --> 00:20:30.160
I mean, that's a piece of
code which you can just write.

00:20:30.160 --> 00:20:32.488
This will become more
clear, hopefully,

00:20:32.488 --> 00:20:34.030
in our next slide
where we talk about

00:20:34.030 --> 00:20:35.770
the English implementation.

00:20:35.770 --> 00:20:39.780
But just, I don't
want to rush to that.

00:20:39.780 --> 00:20:43.920
So you could figure out B
without even knowing what A is.

00:20:43.920 --> 00:20:45.760
B stands alone.

00:20:45.760 --> 00:20:48.720
But then, because B is
just a piece of code

00:20:48.720 --> 00:20:52.260
that runs q based on
what it sees on the tape.

00:20:52.260 --> 00:20:56.400
A, now you need to
know what B is in order

00:20:56.400 --> 00:21:01.940
to obtain A. Because A has
the code for B embedded

00:21:01.940 --> 00:21:05.520
within A as a string.

00:21:05.520 --> 00:21:08.780
So first you produce B, then
you can figure out-- then

00:21:08.780 --> 00:21:10.370
you can obtain A.
There's nothing

00:21:10.370 --> 00:21:11.480
circular in this argument.

00:21:11.480 --> 00:21:13.805
I don't know if
that's helpful to you,

00:21:13.805 --> 00:21:15.180
but you may need
to mull it over.

00:21:15.180 --> 00:21:17.340
Or maybe it'll be helpful
from the next slide.

00:21:17.340 --> 00:21:19.970
So let's go there now.

00:21:19.970 --> 00:21:22.460
So as I'm saying, you can
implement this in any language.

00:21:22.460 --> 00:21:25.840
In particular, you can
implement it in English.

00:21:25.840 --> 00:21:27.380
So let's just shift gears.

00:21:27.380 --> 00:21:31.450
Let's talk about writing
down English instructions.

00:21:31.450 --> 00:21:35.980
And then I'll show what
happens if you carry out

00:21:35.980 --> 00:21:37.070
those instructions.

00:21:37.070 --> 00:21:40.180
So let's start simple.

00:21:40.180 --> 00:21:45.860
How about the sentence,
Write "Hello World."

00:21:45.860 --> 00:21:50.750
So an obedient person
reading those instructions

00:21:50.750 --> 00:21:57.665
would then write "Hello World"
on their paper or wherever.

00:22:01.120 --> 00:22:07.040
OK, fine, hopefully
you get the idea.

00:22:07.040 --> 00:22:08.560
So now, what I'd like--

00:22:08.560 --> 00:22:17.320
here's another sentence,
another instruction.

00:22:17.320 --> 00:22:18.175
Write this sentence.

00:22:20.840 --> 00:22:30.880
And the obedient reader would
then, OK, Write this sentence.

00:22:30.880 --> 00:22:34.010
This is the kind of
thing I'm looking for.

00:22:34.010 --> 00:22:38.120
Here is a sentence which
instructs the reader

00:22:38.120 --> 00:22:40.660
to make an exact copy.

00:22:40.660 --> 00:22:42.660
But I don't like this
one, even though it

00:22:42.660 --> 00:22:44.760
does, in a sense,
what I'm looking for.

00:22:44.760 --> 00:22:49.350
Because it kind of cheats.

00:22:49.350 --> 00:22:55.800
When it has this, this refers
to the entire sentence itself.

00:22:55.800 --> 00:23:00.790
It's using kind of
implicitly here a construct

00:23:00.790 --> 00:23:03.560
which a Turing
machine does not have.

00:23:03.560 --> 00:23:06.620
The Turing machine
does not have a way

00:23:06.620 --> 00:23:08.795
of accessing its own code.

00:23:12.080 --> 00:23:16.150
And in fact, really what the
point of this whole theorem

00:23:16.150 --> 00:23:17.642
that we're going
to present is, is

00:23:17.642 --> 00:23:22.590
that you don't need to have this
self-reference as a primitive.

00:23:22.590 --> 00:23:28.950
You can get that effectively
using the procedure

00:23:28.950 --> 00:23:31.660
that I'm describing, which
will give you the same effect.

00:23:31.660 --> 00:23:33.210
So you don't need
it as a primitive.

00:23:33.210 --> 00:23:36.690
You can design some
software basically,

00:23:36.690 --> 00:23:38.190
which will give you
the same effect.

00:23:41.280 --> 00:23:43.220
So let me show you how
to do that in English.

00:23:43.220 --> 00:23:47.720
So let's look at
a slightly more--

00:23:47.720 --> 00:23:49.880
whoops, cheating,
so Turing machines

00:23:49.880 --> 00:23:51.680
don't have this
self-reference primitive.

00:23:51.680 --> 00:23:54.190
So let's look at
another sentence here.

00:23:54.190 --> 00:23:56.620
Write the following
twice, the second time

00:23:56.620 --> 00:24:00.930
in quotes, and
then, "Hello World."

00:24:00.930 --> 00:24:06.340
So what do we get if we
follow that instruction?

00:24:06.340 --> 00:24:10.030
Well, you get "Hello World"
and then "Hello World"

00:24:10.030 --> 00:24:11.260
again, now in quotes.

00:24:14.040 --> 00:24:15.600
OK?

00:24:15.600 --> 00:24:17.650
Hopefully not too bad.

00:24:17.650 --> 00:24:19.860
But now, I'm one
step away for doing

00:24:19.860 --> 00:24:24.655
the implementation of the
self-reproducing algorithm

00:24:24.655 --> 00:24:25.155
in English.

00:24:28.050 --> 00:24:31.920
Write the following twice,
the second time in quotes,

00:24:31.920 --> 00:24:33.630
and then in quotes,
the same text.

00:24:37.440 --> 00:24:39.210
Now following
those instructions,

00:24:39.210 --> 00:24:43.800
you get, well, "Write
the following twice,

00:24:43.800 --> 00:24:46.120
the second time in quotes,"
so that comes out here.

00:24:46.120 --> 00:24:48.730
And the second time,
you put it in quotes,

00:24:48.730 --> 00:24:51.600
just like you did with
the "Hello World."

00:24:51.600 --> 00:24:57.570
But that's exactly
here, the output

00:24:57.570 --> 00:25:00.650
is exactly what the input was.

00:25:00.650 --> 00:25:05.820
And even though there is a
part of the sentence here

00:25:05.820 --> 00:25:07.830
which refers to
a different part,

00:25:07.830 --> 00:25:11.840
so here the first part is
referring to the second part,

00:25:11.840 --> 00:25:14.870
never do I have to have
the sentence referring

00:25:14.870 --> 00:25:17.720
to its entirety.

00:25:17.720 --> 00:25:19.220
There's no part of
the sentence here

00:25:19.220 --> 00:25:22.430
that's pointing at
the entire sentence.

00:25:22.430 --> 00:25:26.960
And so, this here
manages to get the effect

00:25:26.960 --> 00:25:31.300
that I'm looking for, where the
output is equal to the code,

00:25:31.300 --> 00:25:35.840
but avoids having
the self-reference.

00:25:35.840 --> 00:25:37.675
One thing is referring
to something else,

00:25:37.675 --> 00:25:39.050
but not referring
back to itself.

00:25:43.530 --> 00:25:47.160
So let me just see here.

00:25:47.160 --> 00:25:53.250
So here, I'm going to have a
check-in on this in a minute.

00:25:53.250 --> 00:25:56.300
So I'm going to try to
contrast what's happening here

00:25:56.300 --> 00:25:58.580
with what's happening in
that Turing machine SELF

00:25:58.580 --> 00:26:01.730
that I had from
the previous slide.

00:26:01.730 --> 00:26:04.520
So why don't you mull this
over, and I'm going to give you

00:26:04.520 --> 00:26:06.920
a check-in to see--

00:26:06.920 --> 00:26:09.680
this is a little bit of
a challenging check-in.

00:26:09.680 --> 00:26:13.820
But let's see if you can
figure your way through it.

00:26:17.220 --> 00:26:19.642
And basically it says, so
really what we're doing here

00:26:19.642 --> 00:26:21.600
is called the recursion
theorem, as you'll see.

00:26:21.600 --> 00:26:23.808
We'll actually present the
recursion theorem formally

00:26:23.808 --> 00:26:25.410
on the next slide.

00:26:25.410 --> 00:26:29.260
But here, in both
of these cases,

00:26:29.260 --> 00:26:33.210
we kind of have a template
part and an action part.

00:26:33.210 --> 00:26:38.070
In both cases, there are two
parts to the instructions,

00:26:38.070 --> 00:26:40.320
the template and the action.

00:26:40.320 --> 00:26:40.820
OK?

00:26:40.820 --> 00:26:43.130
So I'm going to leave
it to you to try

00:26:43.130 --> 00:26:46.310
to imagine which
of those is which,

00:26:46.310 --> 00:26:49.460
in each of these two examples.

00:26:49.460 --> 00:26:51.305
And then, I'm going
to ask you to pick.

00:26:53.623 --> 00:26:55.790
In the Turing machine, which
is the action and which

00:26:55.790 --> 00:26:57.833
is the template,
and in the sentence,

00:26:57.833 --> 00:26:59.750
which is the action and
which is the template.

00:26:59.750 --> 00:27:02.870
The action is the
part where there's

00:27:02.870 --> 00:27:08.000
some interesting sort of
instructional stuff happening

00:27:08.000 --> 00:27:09.800
that you have to carry out.

00:27:09.800 --> 00:27:16.950
The template is really basically
just text or just a string.

00:27:16.950 --> 00:27:19.785
So let me pull up that poll.

00:27:23.748 --> 00:27:24.540
See what you think.

00:27:30.920 --> 00:27:34.220
Because I'm asking you
now to indicate where

00:27:34.220 --> 00:27:37.400
is the action part in
both of those cases.

00:27:44.570 --> 00:27:46.320
What is the upper
phrase and lower phrase?

00:27:46.320 --> 00:27:47.500
I mean, of this sentence here.

00:27:47.500 --> 00:27:48.770
So write the following twice.

00:27:48.770 --> 00:27:49.920
This is the upper phrase.

00:27:49.920 --> 00:27:52.965
And the part in quotations
is the lower phrase-- sorry.

00:28:00.510 --> 00:28:01.620
OK, almost done here?

00:28:07.130 --> 00:28:12.300
5 seconds-- a few of you
have not answered yet.

00:28:12.300 --> 00:28:12.990
Answer it.

00:28:15.810 --> 00:28:17.340
One second to go.

00:28:17.340 --> 00:28:19.950
OK, here we go, ending polling.

00:28:22.510 --> 00:28:24.880
So the majority here is correct.

00:28:29.510 --> 00:28:33.500
I would say, in the
English sentence here,

00:28:33.500 --> 00:28:36.020
the action part
is the first part.

00:28:36.020 --> 00:28:40.460
That's where you actually have
been directed to do something.

00:28:40.460 --> 00:28:44.390
The second half of the sentence,
the lower part of the sentence,

00:28:44.390 --> 00:28:47.960
is just a template written.

00:28:47.960 --> 00:28:49.850
This is just some string here.

00:28:49.850 --> 00:28:51.830
There's no action
really being directed.

00:28:51.830 --> 00:28:53.470
It happens to be
the same as the top,

00:28:53.470 --> 00:28:55.220
but this could have
been just Hello World.

00:28:55.220 --> 00:28:57.140
This could have been anything.

00:28:57.140 --> 00:28:59.150
And then the upper
part acts on that.

00:28:59.150 --> 00:29:01.160
So the upper part
is the action part.

00:29:01.160 --> 00:29:04.160
So it's the upper phrase
that's the relevant part.

00:29:04.160 --> 00:29:07.760
Now, in the Turing
machine, in a sense,

00:29:07.760 --> 00:29:09.740
it's the other way around.

00:29:09.740 --> 00:29:12.560
The first part is really
just the template.

00:29:12.560 --> 00:29:16.700
The second part, B, is where
you're doing some actual work

00:29:16.700 --> 00:29:18.200
on the template.

00:29:18.200 --> 00:29:23.250
You're taking that, basically
text, which could be anything.

00:29:23.250 --> 00:29:24.320
A could be anything.

00:29:24.320 --> 00:29:29.870
And you're looking
at that template

00:29:29.870 --> 00:29:34.940
and reconstructing what A
was from that string that

00:29:34.940 --> 00:29:35.870
appears on the tape.

00:29:35.870 --> 00:29:38.090
So B is actually the one
that's doing the work.

00:29:38.090 --> 00:29:41.180
So it's B and the upper
phrase with part c is correct.

00:29:43.700 --> 00:29:46.730
So let us continue then.

00:29:52.280 --> 00:29:58.100
Oh, I want to mention here
problem 6 on the Pset.

00:29:58.100 --> 00:30:02.090
So your job really is
to implement this in--

00:30:02.090 --> 00:30:05.720
if you have a programming
language that you like--

00:30:05.720 --> 00:30:10.160
it could be Python or whatever
your favorite Java, whatever

00:30:10.160 --> 00:30:12.050
you like-- you can
implement this.

00:30:12.050 --> 00:30:14.163
If you don't know any
programming languages,

00:30:14.163 --> 00:30:16.580
then just make up some sort
of pseudo programming language

00:30:16.580 --> 00:30:18.560
and implement it there.

00:30:18.560 --> 00:30:27.040
Let me point out that
getting the quoting right

00:30:27.040 --> 00:30:31.570
is a bit of a pain because
you have to kind of escape

00:30:31.570 --> 00:30:33.650
the quotes and so on.

00:30:33.650 --> 00:30:35.380
I'm not going to be
fussy about that.

00:30:35.380 --> 00:30:37.780
So you can still get full
credit even if you don't get

00:30:37.780 --> 00:30:39.790
the quoting part quite correct.

00:30:39.790 --> 00:30:41.950
Do your best.

00:30:41.950 --> 00:30:45.850
I think it's an interesting
problem to try to solve.

00:30:45.850 --> 00:30:50.710
And if you struggle with it
for a while, it's slippery.

00:30:50.710 --> 00:30:54.340
It's the kind of
thing you can easily

00:30:54.340 --> 00:30:57.040
spend a couple of
hours on this problem.

00:30:57.040 --> 00:31:00.670
Because it's a bit
tricky to manage

00:31:00.670 --> 00:31:03.250
to make a program which
prints itself out,

00:31:03.250 --> 00:31:06.640
which is what the task of
problem is on the Pset.

00:31:06.640 --> 00:31:08.710
But don't fuss about
too much on the quoting

00:31:08.710 --> 00:31:10.750
if that's the only thing
that's hanging you up.

00:31:10.750 --> 00:31:13.250
Try to get the main structure
of it, which is fairly simple,

00:31:13.250 --> 00:31:14.440
actually.

00:31:14.440 --> 00:31:17.350
And if you can't get the
quoting part to work,

00:31:17.350 --> 00:31:20.980
I'll ask the graders not to
penalize you for that part.

00:31:26.590 --> 00:31:31.300
Let's look at the sort of
the more formal version

00:31:31.300 --> 00:31:35.050
of what we've just done and
really kind of also taking it

00:31:35.050 --> 00:31:36.850
to the next level.

00:31:36.850 --> 00:31:40.420
Because being able to print
out a copy of yourself

00:31:40.420 --> 00:31:45.500
is kind of a curiosity in a way.

00:31:45.500 --> 00:31:48.290
But the recursion theorem
says, not only can you

00:31:48.290 --> 00:31:50.720
make a machine which prints
out a copy of itself,

00:31:50.720 --> 00:31:52.760
but you can actually
make a machine which

00:31:52.760 --> 00:31:57.080
can obtain a copy of itself
and then do some computation

00:31:57.080 --> 00:32:01.400
on that copy of itself, on its
own description, which actually

00:32:01.400 --> 00:32:03.980
turns out to be a
useful thing to do.

00:32:03.980 --> 00:32:06.230
Once you have access to
your own description,

00:32:06.230 --> 00:32:07.850
as you'll see from
some examples,

00:32:07.850 --> 00:32:12.230
then you can do perhaps some
interesting things with that.

00:32:12.230 --> 00:32:14.810
So basically, what the
recursion theorem is,

00:32:14.810 --> 00:32:16.190
is a kind of a compiler.

00:32:16.190 --> 00:32:19.820
It allows you to have a
new primitive when you're

00:32:19.820 --> 00:32:21.920
writing Turing
machines, which is,

00:32:21.920 --> 00:32:23.690
compute your own description.

00:32:23.690 --> 00:32:27.450
And the recursion theorem
will implement that for you.

00:32:27.450 --> 00:32:29.100
OK?

00:32:29.100 --> 00:32:33.000
So the technical form
of the recursion theorem

00:32:33.000 --> 00:32:38.730
is going to look a little bit
counterintuitive, perhaps.

00:32:38.730 --> 00:32:40.470
Let me put it out there.

00:32:40.470 --> 00:32:45.030
If you struggle a little bit
with the slide, don't sweat it.

00:32:45.030 --> 00:32:48.300
The main thing to remember,
and we'll see from examples,

00:32:48.300 --> 00:32:51.140
is that you can compute your
own description in a Turing

00:32:51.140 --> 00:32:51.640
machine.

00:32:51.640 --> 00:32:55.350
And that's going to
be allowed as code.

00:32:55.350 --> 00:32:57.780
So the way we're
going to do this

00:32:57.780 --> 00:33:03.030
is, what the
recursion theorem does

00:33:03.030 --> 00:33:08.830
for you is, it says you can
write a piece of code here.

00:33:08.830 --> 00:33:12.540
Let's call it a piece
of Turing machine code--

00:33:12.540 --> 00:33:17.240
algorithmic code--
called T. And T is

00:33:17.240 --> 00:33:21.880
going to get transformed
into a new machine, R.

00:33:21.880 --> 00:33:27.540
And R is going to get
provided a copy of the program

00:33:27.540 --> 00:33:31.260
itself, which is just a
description of R, for free.

00:33:31.260 --> 00:33:33.930
But otherwise, it's going
to act exactly like T.

00:33:33.930 --> 00:33:36.480
So R is going to
act exactly like T,

00:33:36.480 --> 00:33:41.640
except R is going to have
provided a copy of R.

00:33:41.640 --> 00:33:45.630
And that's what the theorem
shows you how to implement.

00:33:45.630 --> 00:33:46.470
So let me just see.

00:33:46.470 --> 00:33:49.500
So for any machine, T,
there is a machine R

00:33:49.500 --> 00:33:56.610
which, for any w, which is going
to be the input for R. R, on w,

00:33:56.610 --> 00:33:59.910
operates the same as
R on the input with w

00:33:59.910 --> 00:34:05.010
where it's given R. So R is
going to be getting access

00:34:05.010 --> 00:34:07.050
to R without--

00:34:07.050 --> 00:34:12.630
it's going to be obtaining
R by calculating it.

00:34:12.630 --> 00:34:15.270
Maybe it'll be clear
from the proof.

00:34:15.270 --> 00:34:19.173
I always struggled with how
to explain this clearly.

00:34:19.173 --> 00:34:20.590
So now, the proof
of this is going

00:34:20.590 --> 00:34:22.570
to be very much like
the proof from two

00:34:22.570 --> 00:34:26.139
slides back, except it's
going to be three parts.

00:34:26.139 --> 00:34:29.290
This is the part, T, that
you're going to provide.

00:34:29.290 --> 00:34:31.659
And the T is going to be
the Turing machine code that

00:34:31.659 --> 00:34:35.280
says, get your own description.

00:34:35.280 --> 00:34:39.179
And you don't have to worry
about how that happens.

00:34:39.179 --> 00:34:42.360
The compiler is going to add
on the A and B parts, which

00:34:42.360 --> 00:34:44.860
is going to get the whole
description of the whole thing,

00:34:44.860 --> 00:34:51.909
which is R, and feed it into
T as if T had it as an input.

00:34:51.909 --> 00:34:55.320
So T is going to be allowed
to get its own description now

00:34:55.320 --> 00:35:01.560
and operate on-- now does
its thing on the input w.

00:35:01.560 --> 00:35:03.645
So the way it's going
to work, so T is given.

00:35:06.950 --> 00:35:12.800
A is going to be, as before,
the description of B now with T.

00:35:12.800 --> 00:35:17.450
So when A is done, it's going to
produce BT sitting on the tape

00:35:17.450 --> 00:35:20.760
next to the w.

00:35:20.760 --> 00:35:25.560
B is going to now figure out
what A was from the BT sitting

00:35:25.560 --> 00:35:26.130
on the tape.

00:35:30.470 --> 00:35:35.300
And then, it's going to combine
that to get ABT, which is R.

00:35:35.300 --> 00:35:41.560
And after that, it passes
control to T with w and now R

00:35:41.560 --> 00:35:42.820
sitting on the tape.

00:35:42.820 --> 00:35:47.320
And now, T is going to
have its own description.

00:35:47.320 --> 00:35:49.810
But don't forget, now T
has been modified to be R.

00:35:49.810 --> 00:35:52.720
So it's not that T is
going to get T on the tape.

00:35:52.720 --> 00:35:55.060
For this to make
sense, this is going

00:35:55.060 --> 00:35:59.470
to be now the new machine R.
And R appears on the tape.

00:35:59.470 --> 00:36:01.540
And now, the code
that you provided,

00:36:01.540 --> 00:36:06.650
T, is now going to get
to operate on that.

00:36:06.650 --> 00:36:07.790
OK?

00:36:07.790 --> 00:36:11.990
If you didn't get that,
I'm not so worried.

00:36:11.990 --> 00:36:13.700
The main thing is
that you can use

00:36:13.700 --> 00:36:15.020
compute your own
description when you're

00:36:15.020 --> 00:36:16.145
describing Turing machines.

00:36:16.145 --> 00:36:20.560
That's what this
thing is telling you.

00:36:20.560 --> 00:36:21.920
I think it'll be--

00:36:21.920 --> 00:36:25.470
oh, there's a check-in here.

00:36:25.470 --> 00:36:27.180
Yeah, so I don't know.

00:36:27.180 --> 00:36:29.640
Let's do this one
kind of quickly here.

00:36:29.640 --> 00:36:35.880
Can we use the recursion theorem
to design a machine T which,

00:36:35.880 --> 00:36:43.670
instead of producing
its own description,

00:36:43.670 --> 00:36:49.010
accepts only its own
description as an input?

00:36:49.010 --> 00:36:51.080
So the language
of this machine is

00:36:51.080 --> 00:36:57.010
going to be simply the one
string, the description of T.

00:36:57.010 --> 00:37:01.090
So can we make a machine,
T, which does this?

00:37:01.090 --> 00:37:02.800
Now I'm looking
at this check-in.

00:37:02.800 --> 00:37:04.810
This T here is
confusing with that T.

00:37:04.810 --> 00:37:07.870
It's not the same T. That's bad.

00:37:07.870 --> 00:37:11.590
I should call it M. Design
a machine, M, where L of M

00:37:11.590 --> 00:37:15.940
is the description of M.

00:37:15.940 --> 00:37:18.670
And can we use the recursion
theorem to do that?

00:37:18.670 --> 00:37:23.350
What I would ask you to do is
think about it in this context.

00:37:23.350 --> 00:37:26.950
You can use compute
your own description

00:37:26.950 --> 00:37:30.130
when you're writing the
code for this machine.

00:37:30.130 --> 00:37:32.590
If you could do that,
could you make a machine

00:37:32.590 --> 00:37:34.390
which just accepts
strings which happen

00:37:34.390 --> 00:37:36.010
to be their own description?

00:37:36.010 --> 00:37:37.850
This is supposed to be easy.

00:37:37.850 --> 00:37:40.510
But I think it ended up being
a little bit more complicated

00:37:40.510 --> 00:37:41.200
than I wanted.

00:37:45.450 --> 00:37:49.030
Launch polling, make
your best guess.

00:37:51.600 --> 00:37:53.400
I think you all kind of see--

00:37:53.400 --> 00:37:57.870
I was kind of leading you,
leading you along the path

00:37:57.870 --> 00:37:58.650
here.

00:37:58.650 --> 00:38:02.850
Yes so, I think you're pretty
much all are getting it.

00:38:02.850 --> 00:38:12.160
Maybe a few of you are unsure.

00:38:12.160 --> 00:38:15.672
But anyway, let's just
wrap this one up quickly

00:38:15.672 --> 00:38:16.630
so that we can move on.

00:38:16.630 --> 00:38:23.340
I think you're pretty much-- so,
5 seconds, I'm going to end it.

00:38:23.340 --> 00:38:26.490
So the correct answer is
Yes, as I was hinting at.

00:38:26.490 --> 00:38:29.640
So I think maybe this example
would have been better

00:38:29.640 --> 00:38:30.900
after the next example.

00:38:30.900 --> 00:38:32.442
And then we're going
to have a break.

00:38:34.720 --> 00:38:38.910
So here is a new proof
that ATM is undecidable

00:38:38.910 --> 00:38:41.100
but now using the
recursion theorem.

00:38:41.100 --> 00:38:43.320
And this is going to give
you a nice example of how

00:38:43.320 --> 00:38:47.730
we use the recursion
theorem in action.

00:38:47.730 --> 00:38:54.060
So remember, we spent half a
lecture or more with a proof

00:38:54.060 --> 00:38:55.440
by diagonalization.

00:38:55.440 --> 00:38:59.610
As our first example of an
undecidable problem ATM,

00:38:59.610 --> 00:39:01.500
we subsequently
showed other things

00:39:01.500 --> 00:39:04.380
undecidable by reduction.

00:39:04.380 --> 00:39:09.880
But for the very first example,
we used that diagonalization.

00:39:09.880 --> 00:39:13.855
Now I'm going to
give you a new proof.

00:39:13.855 --> 00:39:15.230
So proof by
contradiction, assume

00:39:15.230 --> 00:39:18.230
we have a Turing machine,
H, that decides ATM.

00:39:18.230 --> 00:39:21.620
It starts the same way that
the diagonalization proof went.

00:39:21.620 --> 00:39:24.440
But now I'm going to
make a new machine called

00:39:24.440 --> 00:39:28.070
R. So this is going to be
different from the earlier

00:39:28.070 --> 00:39:29.300
proof.

00:39:29.300 --> 00:39:33.110
R says, on input w, I
get my own description.

00:39:33.110 --> 00:39:34.610
Use the recursion theorem.

00:39:34.610 --> 00:39:36.620
That's the way these
things always start.

00:39:36.620 --> 00:39:42.820
Now, I'm going to use H. Now
that I know my own description,

00:39:42.820 --> 00:39:45.850
I'm going to feed--

00:39:45.850 --> 00:39:50.060
I can ask H. I can feed R, w--

00:39:50.060 --> 00:39:51.310
w was the input here.

00:39:51.310 --> 00:39:56.560
I can feed R, w into H to
determine whether R accepts w.

00:39:56.560 --> 00:39:59.110
That's what H does.

00:39:59.110 --> 00:40:08.110
Solving ATM, H will tell this
machine whether R accepts w.

00:40:08.110 --> 00:40:10.840
R is the machine we're
writing, however.

00:40:10.840 --> 00:40:15.920
That is the machine
that's currently running.

00:40:15.920 --> 00:40:23.960
So R now uses H, and it knows
what it's supposed to do.

00:40:23.960 --> 00:40:26.380
H is going to say, well,
you're going to accept w

00:40:26.380 --> 00:40:28.760
or you're not going to accept w.

00:40:28.760 --> 00:40:31.520
That's what H is assumed
to be able to do.

00:40:31.520 --> 00:40:34.980
But then what is R
going to do after that?

00:40:34.980 --> 00:40:39.490
R is going to do the opposite
of what H says it's going to do.

00:40:39.490 --> 00:40:46.770
So if H says, R accepts w,
then R is going to reject w.

00:40:46.770 --> 00:40:50.610
If H says R doesn't accept w--

00:40:50.610 --> 00:40:53.670
it rejects it by looping or
halting, doesn't matter--

00:40:53.670 --> 00:41:02.560
H just says it rejects, then
it's just going to accept.

00:41:02.560 --> 00:41:06.160
So whatever H says, R is
going to show that H is wrong.

00:41:06.160 --> 00:41:08.092
So that's a contradiction.

00:41:08.092 --> 00:41:13.620
It says that H cannot
be deciding ATM.

00:41:13.620 --> 00:41:17.770
So if you step back and think
about what this is here,

00:41:17.770 --> 00:41:20.070
that's that whole
diagonalization proof

00:41:20.070 --> 00:41:22.140
in one line.

00:41:22.140 --> 00:41:25.428
Basically, we've done that
proof in a different way,

00:41:25.428 --> 00:41:26.970
though there is some
similarity here.

00:41:26.970 --> 00:41:29.460
I don't want to say that we've
totally reinvented things

00:41:29.460 --> 00:41:30.877
and done that
totally differently.

00:41:30.877 --> 00:41:32.640
But it's kind of, in
some ways, sort of

00:41:32.640 --> 00:41:34.740
gets at the essence
of the diagonalization

00:41:34.740 --> 00:41:36.270
in a certain sense.

00:41:36.270 --> 00:41:39.030
But anyway, it gives you kind
of a new, very short proof

00:41:39.030 --> 00:41:40.650
that ATM is undecidable.

00:41:40.650 --> 00:41:42.490
I think that's kind
of a cool thing.

00:41:42.490 --> 00:41:48.480
So why don't we take our
little coffee break here,

00:41:48.480 --> 00:41:52.500
and you can feel free to ask
questions during the break.

00:41:52.500 --> 00:41:56.130
I will start my timer going.

00:41:56.130 --> 00:41:59.580
And we'll be back continuing
lecture in five minutes.

00:42:14.610 --> 00:42:16.990
OK, so questions-- so we're
getting some questions

00:42:16.990 --> 00:42:20.950
on when I said, we don't have
to worry about the quotes

00:42:20.950 --> 00:42:27.460
when we're solving
problem 6 on the Pset.

00:42:27.460 --> 00:42:33.700
Somebody says, can we just say
print A, B, C, instead of print

00:42:33.700 --> 00:42:37.012
quote, "A, B, C," and it will
print A, B, C. Yes, you can--

00:42:37.012 --> 00:42:38.220
don't worry about the quotes.

00:42:41.020 --> 00:42:42.190
I think it's kind of--

00:42:42.190 --> 00:42:44.140
you'll see a challenge
if you want to try

00:42:44.140 --> 00:42:45.520
to get the quotes to work.

00:42:45.520 --> 00:42:46.970
But it's also kind of a pain.

00:42:46.970 --> 00:42:49.750
So yeah, you can just
kind of ignore the quotes,

00:42:49.750 --> 00:42:53.810
and I'll ask the graders to
give that full marks there.

00:42:53.810 --> 00:42:58.750
So any reasonable
interpretation will--

00:42:58.750 --> 00:43:01.150
as long as you get the
rest of the concept right--

00:43:01.150 --> 00:43:03.340
will be fine.

00:43:03.340 --> 00:43:09.150
Let's see, somebody is asking,
In the recursion theorem,

00:43:09.150 --> 00:43:12.480
why doesn't T get
the description of T

00:43:12.480 --> 00:43:15.620
instead of the description of R?

00:43:15.620 --> 00:43:19.250
Because the machine
that's running

00:43:19.250 --> 00:43:26.980
is R, back in the previous
slide, two slides ago.

00:43:26.980 --> 00:43:29.452
So if R got T, it would not be
getting its own description.

00:43:29.452 --> 00:43:30.910
It would be getting
the description

00:43:30.910 --> 00:43:32.000
of some other machine.

00:43:32.000 --> 00:43:33.850
So you need to think
about what we actually

00:43:33.850 --> 00:43:36.475
need to have happen here in the
proof of the recursion theorem.

00:43:36.475 --> 00:43:39.940
But it needs to have R, not T.

00:43:39.940 --> 00:43:41.590
Let's just see if I can--

00:43:41.590 --> 00:43:43.960
why does R do the
opposite of what H says?

00:43:56.870 --> 00:43:59.072
Why does R do the
opposite of what H says?

00:43:59.072 --> 00:44:00.530
Well, first of all,
I'm the one who

00:44:00.530 --> 00:44:03.710
gets to design R. So
here is the code arc.

00:44:03.710 --> 00:44:05.930
We're assuming we
have H. I'm going

00:44:05.930 --> 00:44:11.180
to design R to do anything
I want to satisfy the proof.

00:44:11.180 --> 00:44:20.140
And R here is designed
to do the opposite of H.

00:44:20.140 --> 00:44:21.220
So I'm asking R--

00:44:21.220 --> 00:44:24.490
I'm programming R
to find out what

00:44:24.490 --> 00:44:29.068
H predicts it will do
and then do the opposite.

00:44:29.068 --> 00:44:31.730
Maybe the situation
is sort of like this.

00:44:31.730 --> 00:44:38.930
Suppose somebody says, I
have a crystal ball, which

00:44:38.930 --> 00:44:41.510
is going to be like the role
of H. And you say, oh, really?

00:44:41.510 --> 00:44:43.190
That's kind of cool.

00:44:43.190 --> 00:44:46.850
I don't believe you, but it
still sounds interesting.

00:44:46.850 --> 00:44:49.085
And the person says, yeah,
I can see the future.

00:44:52.160 --> 00:44:57.360
I know what you're going
to do in five minutes.

00:44:57.360 --> 00:45:01.280
And in fact, I can see
that in five minutes,

00:45:01.280 --> 00:45:05.570
you're going to say, Hello.

00:45:05.570 --> 00:45:08.940
And you can say, well,
you can think to yourself,

00:45:08.940 --> 00:45:10.340
well, this person is nuts.

00:45:10.340 --> 00:45:12.120
I'm not going to do that.

00:45:12.120 --> 00:45:13.940
I'm just not going to say Hello.

00:45:13.940 --> 00:45:18.448
And then the genie there
with the crystal ball

00:45:18.448 --> 00:45:20.240
waits five minutes and
you don't say Hello.

00:45:20.240 --> 00:45:23.000
And then you've proven that
the crystal ball doesn't work.

00:45:23.000 --> 00:45:23.750
It's very similar.

00:45:31.210 --> 00:45:34.240
I'm not going to explain how we
can do the combining in SELF.

00:45:34.240 --> 00:45:38.410
I just want to explain
at a high level.

00:45:38.410 --> 00:45:40.780
That's just going to be messy.

00:45:40.780 --> 00:45:44.520
Because I said, we were somehow
going to combine in SELF.

00:45:44.520 --> 00:45:48.570
Let me leave that as
a conceptual level.

00:45:48.570 --> 00:45:52.773
OK, how does this idea
work for Turing machines?

00:45:52.773 --> 00:45:54.440
I don't really
understand that question.

00:45:54.440 --> 00:45:57.290
How does this idea work for
Turing machines are decidable?

00:45:57.290 --> 00:45:58.790
You'll have to
resend that because I

00:45:58.790 --> 00:46:02.060
don't understand the question.

00:46:02.060 --> 00:46:06.290
Can I explain, use
your own description?

00:46:06.290 --> 00:46:12.220
So when you write code that
says, get your own description,

00:46:12.220 --> 00:46:18.120
after that code executes,
the Turing machine

00:46:18.120 --> 00:46:22.960
appears on the tape, like
magic, the description

00:46:22.960 --> 00:46:25.870
of its own code.

00:46:25.870 --> 00:46:28.570
Say, sitting next to the
input to the machine,

00:46:28.570 --> 00:46:31.280
because the machine may have
an separate input from that.

00:46:31.280 --> 00:46:34.420
So the machine just
magically gets its own code.

00:46:34.420 --> 00:46:38.320
And the proof of the recursion
theorem implements that,

00:46:38.320 --> 00:46:39.760
so it's not magic after all.

00:46:44.790 --> 00:46:49.970
But I still don't
understand the question.

00:46:55.440 --> 00:46:57.470
So for problem 6, is it
enough to attach code?

00:46:57.470 --> 00:47:05.510
If you're going to attach
code for problem 6, and that's

00:47:05.510 --> 00:47:06.140
good enough.

00:47:06.140 --> 00:47:10.130
Or if you can explain,
it's also good, like usual.

00:47:10.130 --> 00:47:11.810
Do we worry about
tabs and new lines?

00:47:11.810 --> 00:47:12.310
No.

00:47:17.682 --> 00:47:20.140
OK, we're going to have to
defer the rest of the questions.

00:47:20.140 --> 00:47:22.140
Don't forget we have
a zillion questions

00:47:22.140 --> 00:47:23.280
here which I didn't get to.

00:47:27.140 --> 00:47:30.620
OK, last one here-- why
does programming R do

00:47:30.620 --> 00:47:32.780
the opposite of H?

00:47:32.780 --> 00:47:34.620
Is that a contradiction?

00:47:34.620 --> 00:47:37.370
Well, H is predicting that R
accepts, but R doesn't accept,

00:47:37.370 --> 00:47:39.350
so H is wrong.

00:47:39.350 --> 00:47:40.670
We're a little short on time.

00:47:40.670 --> 00:47:44.070
Let me skip this one.

00:47:44.070 --> 00:47:46.180
You can look at
this on your own.

00:47:46.180 --> 00:47:49.290
I mean, this is proving
sort of the cool fact that--

00:47:49.290 --> 00:47:51.090
I'll just say it
at a high level.

00:47:51.090 --> 00:47:56.050
If you have a program
transformation,

00:47:56.050 --> 00:47:58.590
so if I have some
method of transforming

00:47:58.590 --> 00:48:01.540
one program to another program,
but it's done by algorithm.

00:48:01.540 --> 00:48:03.900
So an algorithmic way
that transforms one

00:48:03.900 --> 00:48:05.460
program to another program.

00:48:05.460 --> 00:48:09.030
There's always going to be
some program whose behavior is

00:48:09.030 --> 00:48:12.060
unchanged by the transformation.

00:48:12.060 --> 00:48:15.090
That's called the
fixed point theorem.

00:48:15.090 --> 00:48:16.800
So there some program
whose behavior

00:48:16.800 --> 00:48:18.600
doesn't change no
matter how you try

00:48:18.600 --> 00:48:21.540
two transform programs-- easy
proof using the recursion

00:48:21.540 --> 00:48:23.370
theorem.

00:48:23.370 --> 00:48:27.480
You can look at
the slide offline

00:48:27.480 --> 00:48:30.063
separately if you like
to see how that goes.

00:48:30.063 --> 00:48:30.855
It's pretty simple.

00:48:35.340 --> 00:48:38.895
Here's another exercise
of the recursion theorem.

00:48:43.180 --> 00:48:44.785
So if I have a--

00:48:51.580 --> 00:48:58.030
let's say a Turing
machine is minimal

00:48:58.030 --> 00:49:03.640
if its description is the
shortest among all Turing

00:49:03.640 --> 00:49:06.310
machines which behave
the way it does,

00:49:06.310 --> 00:49:07.660
which are equivalent to it.

00:49:12.570 --> 00:49:18.000
When I was an undergraduate,
I took a programming class.

00:49:18.000 --> 00:49:21.930
And some of us sort of
enjoyed writing short programs

00:49:21.930 --> 00:49:27.558
to carry out the exercises.

00:49:27.558 --> 00:49:29.100
Probably these days,
that's forbidden

00:49:29.100 --> 00:49:31.890
because it just encourages
bad programming style.

00:49:31.890 --> 00:49:38.730
But anyway, so you
kind of won if you

00:49:38.730 --> 00:49:42.720
found the shortest solution for
a given programming exercise.

00:49:42.720 --> 00:49:44.910
It was Heap Sort, I
remember, was one of the ones

00:49:44.910 --> 00:49:47.250
that we had to do.

00:49:47.250 --> 00:49:53.510
So this is sort of similar.

00:49:53.510 --> 00:49:56.750
You might imagine if people try
to find the shortest possible

00:49:56.750 --> 00:49:58.650
universal Turing machine.

00:49:58.650 --> 00:50:01.700
So short is, in our
sense is, in terms

00:50:01.700 --> 00:50:04.610
of whatever encoding
method we have in mind,

00:50:04.610 --> 00:50:09.770
a machine is minimal if there
is no shorter program which

00:50:09.770 --> 00:50:15.470
is equivalent using our
encoding system, whatever it is.

00:50:15.470 --> 00:50:20.600
So M is minimal if anything
that has a shorter description

00:50:20.600 --> 00:50:21.785
has a different language.

00:50:26.390 --> 00:50:32.590
OK, so let's look at the
collection of all descriptions

00:50:32.590 --> 00:50:34.980
of minimal Turing machines.

00:50:34.980 --> 00:50:39.562
And I want to prove that that
language is unrecognizable.

00:50:39.562 --> 00:50:41.520
I'm going to do it using
the recursion theorem.

00:50:41.520 --> 00:50:44.228
And it's kind of
a cool exercise.

00:50:44.228 --> 00:50:46.770
And you can actually use it to
prove something more powerful.

00:50:46.770 --> 00:50:52.170
But let's focus on
this theorem for now.

00:50:52.170 --> 00:50:54.690
So assume we have--

00:50:54.690 --> 00:50:58.622
and it's also in the little
nice exercise about enumerators.

00:50:58.622 --> 00:51:01.080
I don't know how comfortable
you ever got with enumerators.

00:51:01.080 --> 00:51:04.860
But I'm trying to prove
this language here

00:51:04.860 --> 00:51:06.120
is not recognizable.

00:51:06.120 --> 00:51:08.820
And so remember,
enumerators, you

00:51:08.820 --> 00:51:12.090
can enumerate exactly all
the recognizable languages.

00:51:12.090 --> 00:51:14.880
So I'm going to assume I have
an enumerator for this language,

00:51:14.880 --> 00:51:21.160
which just prints out all of
the minimal Turing machines.

00:51:21.160 --> 00:51:22.530
So I have some enumerator.

00:51:22.530 --> 00:51:26.550
It's a program that prints
out the descriptions of all

00:51:26.550 --> 00:51:27.960
of the minimal--

00:51:27.960 --> 00:51:30.300
the shortest possible
Turing machines.

00:51:30.300 --> 00:51:32.980
And now I'm going to
get a contradiction.

00:51:32.980 --> 00:51:36.960
So we're going to build
this Turing machine, R,

00:51:36.960 --> 00:51:39.620
which gets its own description.

00:51:39.620 --> 00:51:46.550
And then, it's going to
start the enumerator until--

00:51:46.550 --> 00:51:50.360
so looking at the strings
that the enumerator produces.

00:51:50.360 --> 00:51:53.000
So this enumerator is producing
these minimal Turing machines,

00:51:53.000 --> 00:51:55.700
one after the next-- chunk,
chunk, chunk, chunk, chunk.

00:51:55.700 --> 00:51:58.610
All these minimal Turing
machines are coming out.

00:51:58.610 --> 00:52:02.060
And you keep looking at those
until you find one of them

00:52:02.060 --> 00:52:05.870
which is bigger than yourself.

00:52:05.870 --> 00:52:08.090
And how do you know how
big you are yourself?

00:52:08.090 --> 00:52:12.430
From the description you're
given by the recursion theorem.

00:52:12.430 --> 00:52:15.820
So you keep on printing
out these Turing machines

00:52:15.820 --> 00:52:18.590
until you find one that's
bigger than yourself.

00:52:18.590 --> 00:52:20.270
And then, what do
you do with that?

00:52:20.270 --> 00:52:22.990
You simulate that.

00:52:22.990 --> 00:52:27.120
So now, so what?

00:52:27.120 --> 00:52:29.190
Well, the point is
that you're going

00:52:29.190 --> 00:52:33.630
to be smaller than that
machine that you're simulating.

00:52:33.630 --> 00:52:35.400
Because you waited
to find a machine

00:52:35.400 --> 00:52:39.040
that the enumerator produced
which is bigger than you.

00:52:39.040 --> 00:52:41.440
So you're going to be
simulating that machine that's

00:52:41.440 --> 00:52:43.720
bigger than you.

00:52:43.720 --> 00:52:46.668
And so, you're going to be doing
exactly what that machine does

00:52:46.668 --> 00:52:48.210
on every input,
because you're always

00:52:48.210 --> 00:52:51.630
going to be simulating that
same machine on every input.

00:52:51.630 --> 00:52:53.910
And so, you're going to be
equivalent to that bigger

00:52:53.910 --> 00:52:55.410
machine.

00:52:55.410 --> 00:52:58.860
But that bigger machine
is supposed to be minimal

00:52:58.860 --> 00:53:01.800
because E is producing it.

00:53:01.800 --> 00:53:03.950
But here, you are
exhibiting a machine

00:53:03.950 --> 00:53:06.770
that's smaller than that--

00:53:06.770 --> 00:53:10.400
that allegedly minimal
machine couldn't be minimal.

00:53:10.400 --> 00:53:14.000
That's the contradiction.

00:53:14.000 --> 00:53:17.770
So the language of R, this
machine I just produced,

00:53:17.770 --> 00:53:23.050
equals the language of B.
Because R ends up simulating B.

00:53:23.050 --> 00:53:26.650
But R is smaller
than B because R

00:53:26.650 --> 00:53:29.890
waited until it found a bigger
machine that's bigger than it.

00:53:29.890 --> 00:53:33.220
So B couldn't be minimal,
but B was one of the machines

00:53:33.220 --> 00:53:34.990
that the enumerator produced.

00:53:34.990 --> 00:53:38.480
That's a contradiction.

00:53:38.480 --> 00:53:40.990
So let me do a check-in on this.

00:53:40.990 --> 00:53:43.720
I expect this is going to
cause some of you heartburn,

00:53:43.720 --> 00:53:45.700
but let's do the best you can.

00:53:51.430 --> 00:53:54.190
Suppose I have this collection
of minimal Turing machines

00:53:54.190 --> 00:53:57.450
and I take some
infinite subset of that.

00:53:57.450 --> 00:53:59.538
So now I'm not demanding
that I have all

00:53:59.538 --> 00:54:00.830
of the minimal Turing machines.

00:54:00.830 --> 00:54:04.660
I just have infinitely many
minimal Turing machines.

00:54:04.660 --> 00:54:08.880
Is it possible that
subset-- whatever it is--

00:54:08.880 --> 00:54:13.380
could be Turing-recognizable?

00:54:13.380 --> 00:54:14.910
Now, think about that.

00:54:14.910 --> 00:54:18.570
Now, you can have
languages which

00:54:18.570 --> 00:54:20.670
are not
Turing-recognizable, that

00:54:20.670 --> 00:54:25.810
have infinite
Turing-recognizable subsets.

00:54:25.810 --> 00:54:27.610
Could that be for this language?

00:54:42.330 --> 00:54:43.740
And maybe I'll give you a--

00:54:48.420 --> 00:54:53.400
it will be helpful to you to
understand and perhaps apply

00:54:53.400 --> 00:54:57.265
the methodology that I gave
you in this proof here.

00:54:57.265 --> 00:54:58.640
And that might be
helpful to you.

00:55:01.340 --> 00:55:05.380
But I can see this is not--

00:55:05.380 --> 00:55:07.870
this one is a bit of a struggle.

00:55:11.080 --> 00:55:12.280
OK, let's end it.

00:55:15.400 --> 00:55:19.670
Two seconds, just
pick something.

00:55:19.670 --> 00:55:23.110
So the majority has the
correct answer here.

00:55:27.240 --> 00:55:33.350
So in fact, this
proof would still

00:55:33.350 --> 00:55:40.500
work if the enumerator was
enumerating an infinite subset

00:55:40.500 --> 00:55:43.070
of minimal Turing machines.

00:55:43.070 --> 00:55:45.290
Because all you need
is to wait until one

00:55:45.290 --> 00:55:47.300
that's bigger than you appears.

00:55:47.300 --> 00:55:50.810
And all that R
needs to do is wait

00:55:50.810 --> 00:55:53.090
until one that's
bigger than R appears,

00:55:53.090 --> 00:55:54.890
which will certainly
happen eventually

00:55:54.890 --> 00:55:56.600
if the subset is infinite.

00:55:56.600 --> 00:56:02.810
And then R simulates that bigger
machine and acts the same way,

00:56:02.810 --> 00:56:04.625
thereby proving it
could not be minimal.

00:56:07.330 --> 00:56:10.630
So it's exactly the same proof
shows that the answer here

00:56:10.630 --> 00:56:13.170
is No.

00:56:13.170 --> 00:56:14.680
And it's a kind of a curiosity.

00:56:14.680 --> 00:56:17.490
It's not necessarily
that easy to construct

00:56:17.490 --> 00:56:20.910
languages which not only
are they not recognizable,

00:56:20.910 --> 00:56:23.520
but they have no
recognizable subsets--

00:56:23.520 --> 00:56:24.570
infinite subsets.

00:56:24.570 --> 00:56:26.100
Obviously, a finite
subset is going

00:56:26.100 --> 00:56:31.910
to be recognizable because it
would be decidable as well.

00:56:31.910 --> 00:56:33.310
So anyway, let's move on.

00:56:37.730 --> 00:56:43.712
Some other
applications-- so first,

00:56:43.712 --> 00:56:46.790
a real-world application--

00:56:54.790 --> 00:56:58.200
somebody is asking
for an example

00:56:58.200 --> 00:57:03.390
of a language of a
recognizable subset

00:57:03.390 --> 00:57:06.750
of a non-recognizable language.

00:57:06.750 --> 00:57:09.540
So starting out with something
which is not recognizable,

00:57:09.540 --> 00:57:18.245
and can we come
up with a quick--

00:57:21.180 --> 00:57:25.230
So here is, I don't know
if this will help you.

00:57:25.230 --> 00:57:28.190
So the question is,
can I give an example

00:57:28.190 --> 00:57:33.670
of a non-recognizable language
that has a recognizable subset?

00:57:33.670 --> 00:57:40.150
So I didn't prepare this, but
let me see if this helps you.

00:57:40.150 --> 00:57:42.460
So let's take ATM complement.

00:57:42.460 --> 00:57:47.300
We already showed that ATM
complement is not recognizable.

00:57:47.300 --> 00:57:51.890
So these are the sets
of pairs, M and w,

00:57:51.890 --> 00:57:53.510
where M does not accept w.

00:58:03.965 --> 00:58:11.630
So if I focus only on those
M's, which are finite automata,

00:58:11.630 --> 00:58:15.260
which are a subclass
of Turing machines,

00:58:15.260 --> 00:58:17.930
then I can get the
answer for those M's.

00:58:20.450 --> 00:58:24.200
So for the infinitely many cases
where the Turing machine never

00:58:24.200 --> 00:58:31.350
writes on its tape, it
even becomes decidable.

00:58:31.350 --> 00:58:33.730
So I don't know
if that's helpful,

00:58:33.730 --> 00:58:37.350
but you can
definitely find cases

00:58:37.350 --> 00:58:39.900
where there are
undecidable languages that

00:58:39.900 --> 00:58:42.780
have decidable subsets,
unrecognizable languages that

00:58:42.780 --> 00:58:45.540
have recognizable
infinite subsets.

00:58:45.540 --> 00:58:47.923
But there's one example
where it's not true,

00:58:47.923 --> 00:58:48.840
in the previous slide.

00:58:53.740 --> 00:58:55.490
OK, a lot of questions
are coming up here.

00:59:00.860 --> 00:59:05.540
Yes, I'm seeing some
other proposals here.

00:59:05.540 --> 00:59:09.270
If you take ATM
complement and you union

00:59:09.270 --> 00:59:11.990
with just any old
strings of 1's,

00:59:11.990 --> 00:59:14.762
just one star, assuming
that one star--

00:59:14.762 --> 00:59:16.220
just strings of
1's are never going

00:59:16.220 --> 00:59:18.530
to code for a Turing machine--

00:59:18.530 --> 00:59:20.360
that's still going
to be unrecognizable.

00:59:20.360 --> 00:59:22.400
But then you can
just throw away all

00:59:22.400 --> 00:59:24.890
of those just strings
of 1's, and you're

00:59:24.890 --> 00:59:26.330
going to get an infinite subset.

00:59:26.330 --> 00:59:27.646
Oh, wait a minute.

00:59:27.646 --> 00:59:29.130
It's still unrecognizable.

00:59:29.130 --> 00:59:29.820
That's no good.

00:59:32.880 --> 00:59:35.430
Oh, no, yeah, I threw
away the wrong stuff.

00:59:35.430 --> 00:59:39.090
You throw away the descriptions
of the Turing machines,

00:59:39.090 --> 00:59:42.090
and you just have the
one-star strings left.

00:59:42.090 --> 00:59:45.130
And so, that becomes
decidable, even regular.

00:59:45.130 --> 00:59:48.620
Anyway, I'm not sure
I'm helping you.

00:59:48.620 --> 00:59:50.270
Let's move on to
other applications.

00:59:50.270 --> 00:59:54.790
So this is kind of a curious
application that actually

00:59:54.790 --> 00:59:57.610
is in the real world,
where a machine might want

00:59:57.610 --> 01:00:00.760
to get a copy of itself and
then do something perhaps

01:00:00.760 --> 01:00:07.367
even nefarious with a
copy of its own code.

01:00:07.367 --> 01:00:08.825
And that would be
a computer virus.

01:00:12.010 --> 01:00:16.540
Computer viruses make
copies of themselves

01:00:16.540 --> 01:00:20.950
and then propagate them through
the internet, or whatever media

01:00:20.950 --> 01:00:23.440
you have, to infect
other computers.

01:00:23.440 --> 01:00:28.580
And I'm sure we all
know computer viruses.

01:00:28.580 --> 01:00:31.000
Well, they need to get
copies of themselves

01:00:31.000 --> 01:00:35.020
in order to do the infection.

01:00:35.020 --> 01:00:37.420
How do they do that?

01:00:37.420 --> 01:00:42.580
Many of them operate in a way
where in either in a language

01:00:42.580 --> 01:00:46.060
or in a system, where
they can make reference

01:00:46.060 --> 01:00:55.670
to their own code, either by
looking at the machine code,

01:00:55.670 --> 01:00:58.970
or whatever direct
access to their own code.

01:00:58.970 --> 01:01:02.550
There are languages and
systems which allow for that.

01:01:02.550 --> 01:01:05.420
But I'm not an expert
on computer viruses.

01:01:05.420 --> 01:01:09.560
I would be shocked if they're
not some other viruses that

01:01:09.560 --> 01:01:15.620
get access to their own code by
using something in the same--

01:01:15.620 --> 01:01:19.250
using basically the method
of the recursion theorem.

01:01:19.250 --> 01:01:21.170
I haven't done a
systematic study.

01:01:21.170 --> 01:01:23.210
But I'm sure, if
you can't access

01:01:23.210 --> 01:01:26.810
to your own code directly
using some operating system

01:01:26.810 --> 01:01:29.510
mechanism, some primitive,
the only other way

01:01:29.510 --> 01:01:32.497
is basically doing the method
that we just described.

01:01:36.480 --> 01:01:44.540
OK, so another application
is in a branch of mathematics

01:01:44.540 --> 01:01:47.700
called mathematical logic.

01:01:47.700 --> 01:01:51.570
Where, I imagine that many
of you have heard of the work

01:01:51.570 --> 01:01:54.720
of Godel from the earlier
part of the 20th century,

01:01:54.720 --> 01:01:58.560
where they show that
you can come up--

01:01:58.560 --> 01:02:02.490
it's possible to demonstrate
that there are true

01:02:02.490 --> 01:02:05.200
mathematical statements but
which cannot be proven to be

01:02:05.200 --> 01:02:05.700
true.

01:02:08.410 --> 01:02:13.050
So proof-- there might be
something like maybe even

01:02:13.050 --> 01:02:16.710
questions of interest to us,
like P versus NP question,

01:02:16.710 --> 01:02:21.660
which we will, at some point,
look at in a few weeks--

01:02:21.660 --> 01:02:25.923
actually, yeah, maybe two
or three weeks from now.

01:02:25.923 --> 01:02:27.840
There are many unsolved
mathematical problems.

01:02:27.840 --> 01:02:31.250
And people wonder,
maybe there's just

01:02:31.250 --> 01:02:33.000
no way to prove them
one way or the other.

01:02:35.560 --> 01:02:40.350
So in the 1930s, when
Godel did his work,

01:02:40.350 --> 01:02:42.720
he shocked the
mathematical community

01:02:42.720 --> 01:02:48.120
by showing that proof does
not work for everything.

01:02:48.120 --> 01:02:50.910
There may be things that are
true that you cannot prove.

01:02:53.740 --> 01:02:56.760
In Hilbert, in particular,
from Hilbert's 10th problem,

01:02:56.760 --> 01:03:02.970
he was dismayed by this
result. Because he had earlier

01:03:02.970 --> 01:03:07.350
believed that anything that
was true you could prove.

01:03:07.350 --> 01:03:10.650
So anyway, let's just see how--

01:03:10.650 --> 01:03:14.490
I'm going to sketch how we
actually go about doing that.

01:03:14.490 --> 01:03:16.500
Because we now have a
kind of enough technique

01:03:16.500 --> 01:03:18.510
to at least give you
an idea of how do

01:03:18.510 --> 01:03:21.510
you demonstrate that there are
true but unprovable statements

01:03:21.510 --> 01:03:25.240
and actually even exhibit one.

01:03:25.240 --> 01:03:27.490
OK, mathematical logic
is the mathematical study

01:03:27.490 --> 01:03:28.555
of mathematics itself.

01:03:31.610 --> 01:03:34.490
Godel's first incompleteness
theorem, as we described,

01:03:34.490 --> 01:03:37.490
is that in any
reasonable formal system

01:03:37.490 --> 01:03:41.570
of mathematical
provability, there

01:03:41.570 --> 01:03:43.310
are going to be some
true statements that

01:03:43.310 --> 01:03:46.150
are not provable.

01:03:46.150 --> 01:03:49.620
And in order to sort of get
the sketch of the proof--

01:03:49.620 --> 01:03:50.910
I shouldn't say proof here.

01:03:50.910 --> 01:03:54.090
We're going to proof sketch.

01:03:54.090 --> 01:03:59.310
We're going to basically use
two properties of formal proof

01:03:59.310 --> 01:04:01.120
systems.

01:04:01.120 --> 01:04:08.050
One is that kind of obvious
property that you would expect

01:04:08.050 --> 01:04:11.320
all probability systems to
have, is that you can only

01:04:11.320 --> 01:04:13.730
prove true things.

01:04:13.730 --> 01:04:16.840
So if something is being
proven, it's going to be true.

01:04:16.840 --> 01:04:20.080
You can't prove anything false.

01:04:20.080 --> 01:04:23.050
If you can prove false things,
your system of provability

01:04:23.050 --> 01:04:23.560
is bad.

01:04:26.550 --> 01:04:30.930
And the other thing
is that proofs

01:04:30.930 --> 01:04:33.960
are checkable by machine.

01:04:33.960 --> 01:04:37.850
So if you write down-- do
your system in a formal way

01:04:37.850 --> 01:04:39.930
and you have this
formal notion of proofs,

01:04:39.930 --> 01:04:42.410
which underlies all mathematical
reasoning, by the way.

01:04:42.410 --> 01:04:43.820
This is completely
well accepted.

01:04:43.820 --> 01:04:46.640
Both of these properties are
accepted by mathematicians.

01:04:46.640 --> 01:04:50.570
Then in principle, you can
convert any mathematical proof

01:04:50.570 --> 01:04:53.270
into a form that you can
check it by computer.

01:04:53.270 --> 01:04:54.810
It might become much longer.

01:04:54.810 --> 01:04:58.070
But in principle, you can
put the proof into a form

01:04:58.070 --> 01:05:01.070
where a computer
could check the proof.

01:05:01.070 --> 01:05:05.240
And the way we're going
to frame that in the way

01:05:05.240 --> 01:05:07.190
we've been talking
about things is

01:05:07.190 --> 01:05:10.290
that the language of
all pairs of proof,

01:05:10.290 --> 01:05:13.310
comma statement being proved--

01:05:13.310 --> 01:05:17.270
so where pi is a proof
of the statement phi--

01:05:17.270 --> 01:05:18.690
that's a decidable thing.

01:05:18.690 --> 01:05:23.210
So you can check, by
machine, whether pi

01:05:23.210 --> 01:05:25.010
is a valid proof of phi.

01:05:28.174 --> 01:05:33.790
So your proof checker can say,
Yes, it's valid, No, not valid.

01:05:33.790 --> 01:05:37.588
And that's something
you can do by algorithm.

01:05:37.588 --> 01:05:39.380
So those are the two
assumptions that we're

01:05:39.380 --> 01:05:41.088
going to make about
our system of proofs.

01:05:41.088 --> 01:05:44.010
And that's all
we're going to need.

01:05:44.010 --> 01:05:46.000
Now, the first
conclusion, which is,

01:05:46.000 --> 01:05:48.900
I think, a good sort of
a little bit of exercise

01:05:48.900 --> 01:05:55.060
on the kind of thinking we've
been doing in this course.

01:05:55.060 --> 01:05:58.200
Number 2, checkability
implies that the set

01:05:58.200 --> 01:06:03.900
of provable statements
is recognizable.

01:06:03.900 --> 01:06:05.010
Why?

01:06:05.010 --> 01:06:09.300
Suppose I give you a
statement that has a proof--

01:06:09.300 --> 01:06:11.650
a provable statement.

01:06:11.650 --> 01:06:13.870
I'm not saying it's a true
statement, necessarily.

01:06:13.870 --> 01:06:18.820
That's going to be perhaps a
larger class of statements.

01:06:18.820 --> 01:06:21.880
But the statement
that do have proofs,

01:06:21.880 --> 01:06:23.850
that's a recognizable language.

01:06:26.930 --> 01:06:30.800
Because, if I give
you a statement,

01:06:30.800 --> 01:06:33.650
your recognizer is going
to take that statement

01:06:33.650 --> 01:06:38.900
and start looking through
all possible proofs.

01:06:38.900 --> 01:06:41.900
It's going to look at string
after string as a candidate

01:06:41.900 --> 01:06:43.340
proof, one after the next.

01:06:43.340 --> 01:06:46.297
Some strings, of course-- most
strings are going to be junk.

01:06:46.297 --> 01:06:48.630
But every once in a while, a
proof is going to come out.

01:06:48.630 --> 01:06:52.112
It's going to be a string which
is a valid proof of something.

01:06:52.112 --> 01:06:53.570
And then you're
going to check, oh,

01:06:53.570 --> 01:06:55.280
let me just see if
that's a valid proof.

01:06:55.280 --> 01:06:58.070
And if it does prove the
statement that I have in mind,

01:06:58.070 --> 01:07:00.920
and if it is, then I
accept that statement.

01:07:00.920 --> 01:07:03.130
And it goes through
statement by--

01:07:03.130 --> 01:07:06.810
the input is a
mathematical statement.

01:07:06.810 --> 01:07:09.830
And that's going to be accepted
if the machine, by looking

01:07:09.830 --> 01:07:11.960
through all possible
proofs, finds one

01:07:11.960 --> 01:07:14.160
and then it accepts
that statement.

01:07:14.160 --> 01:07:16.040
So the collection
of all statements

01:07:16.040 --> 01:07:18.470
that have a proof,
that's recognizable.

01:07:21.340 --> 01:07:29.770
So similarly, if you take
statements of the form

01:07:29.770 --> 01:07:34.660
M and w is in the
complement of ATM.

01:07:34.660 --> 01:07:36.698
So M doesn't accept w.

01:07:40.290 --> 01:07:43.230
If you take all statements
of that form where M doesn't

01:07:43.230 --> 01:07:49.530
accept w, or M, w is in
the complement of ATM,

01:07:49.530 --> 01:07:52.950
some of those statements may
have proofs in your system.

01:07:52.950 --> 01:07:55.080
Some of them may
not have proofs.

01:07:55.080 --> 01:07:58.230
If all of them
had proofs, if you

01:07:58.230 --> 01:08:00.270
can prove every
statement of this form

01:08:00.270 --> 01:08:02.260
when it happens to be true--

01:08:02.260 --> 01:08:04.510
obviously, you can't prove
the ones that are not true.

01:08:04.510 --> 01:08:08.370
But if you can prove all the
true statements of this kind,

01:08:08.370 --> 01:08:13.660
then ATM complement would
be Turing-recognizable.

01:08:13.660 --> 01:08:18.609
Because you can go through, just
for the same reason as above.

01:08:18.609 --> 01:08:20.859
But we know that that's false.

01:08:20.859 --> 01:08:25.210
So there must be some
statement of this kind which is

01:08:25.210 --> 01:08:28.060
true but does not have a proof.

01:08:28.060 --> 01:08:29.710
Because otherwise,
the ATM complement

01:08:29.710 --> 01:08:30.790
would be recognizable.

01:08:34.660 --> 01:08:41.470
So we've actually done the first
half of Godel's incompleteness

01:08:41.470 --> 01:08:42.140
theorem.

01:08:42.140 --> 01:08:45.130
The second half, which
we're going to unfortunately

01:08:45.130 --> 01:08:48.279
not have time to finish, but let
me just give you the outline,

01:08:48.279 --> 01:08:51.520
is that we can use the recursion
theorem to give it specific--

01:08:51.520 --> 01:08:53.859
see, what we showed
here is that there

01:08:53.859 --> 01:08:57.115
is some statement of this form
which is true but unprovable.

01:08:57.115 --> 01:08:59.720
It doesn't exhibit
a particular one.

01:08:59.720 --> 01:09:03.939
Now the recursion theorem allows
you to give a particular one.

01:09:03.939 --> 01:09:07.779
And the one, it
basically implements

01:09:07.779 --> 01:09:10.750
Godel's so-called Godel
statement or Godel

01:09:10.750 --> 01:09:15.340
sense that says, "This
statement is unprovable."

01:09:15.340 --> 01:09:21.950
And you can formalize
that precisely.

01:09:21.950 --> 01:09:26.310
And then that statement
becomes true but unprovable.

01:09:26.310 --> 01:09:28.319
Let's just say why that is.

01:09:28.319 --> 01:09:32.790
Because if the
statement were false,

01:09:32.790 --> 01:09:35.819
suppose the
statement were false,

01:09:35.819 --> 01:09:38.359
then, well, then it
would be provable.

01:09:38.359 --> 01:09:41.990
Because the truth says
it's not provable.

01:09:41.990 --> 01:09:43.729
But if the statement
were provable,

01:09:43.729 --> 01:09:46.240
then it had to be
true, which would

01:09:46.240 --> 01:09:48.040
mean it would be unprovable.

01:09:48.040 --> 01:09:51.430
So the only viable outcome
here is that the statement

01:09:51.430 --> 01:09:53.800
is unprovable.

01:09:53.800 --> 01:09:59.080
And which is, it's
therefore that it's true

01:09:59.080 --> 01:10:00.400
that it's unprovable.

01:10:00.400 --> 01:10:01.990
So that this is
a true statement,

01:10:01.990 --> 01:10:03.610
but then it has no proof.

01:10:03.610 --> 01:10:10.110
And let me not go through
it because again, we're

01:10:10.110 --> 01:10:11.670
unfortunately running
short on time.

01:10:11.670 --> 01:10:18.150
But you can implement this using
the recursion theorem to make

01:10:18.150 --> 01:10:25.370
a particular machine, R, where
you cannot prove that R does

01:10:25.370 --> 01:10:27.740
not accept, say, some string 0.

01:10:30.730 --> 01:10:33.010
So you can find a particular
R using the recursion

01:10:33.010 --> 01:10:35.770
theorem, where it's
impossible to prove

01:10:35.770 --> 01:10:39.370
that R doesn't accept 0.

01:10:39.370 --> 01:10:43.150
Even though, by construction,
R does not accept 0.

01:10:43.150 --> 01:10:44.710
So it's a little
bit slippery there

01:10:44.710 --> 01:10:46.168
because you have
to understand what

01:10:46.168 --> 01:10:48.130
we mean by proof within
the formal system

01:10:48.130 --> 01:10:50.950
versus our external
form of reasoning,

01:10:50.950 --> 01:10:54.730
but taking us a
little bit far afield.

01:10:54.730 --> 01:10:59.140
So for those of you who care,
I hope this little digression

01:10:59.140 --> 01:11:00.250
was interesting.

01:11:00.250 --> 01:11:02.517
As I mentioned at the
beginning, for those

01:11:02.517 --> 01:11:04.850
of you who don't care, you
don't have to worry about it.

01:11:04.850 --> 01:11:07.225
It's not going to be on the
midterm or on the final exam.

01:11:07.225 --> 01:11:09.632
You're not going to be
responsible for this last five

01:11:09.632 --> 01:11:10.840
minutes or so of the lecture.

01:11:10.840 --> 01:11:13.630
But I thought it's kind of
an interesting application

01:11:13.630 --> 01:11:17.620
of the recursion theorem to
a problem outside of computer

01:11:17.620 --> 01:11:19.090
science in mathematical logic.

01:11:22.000 --> 01:11:27.440
OK, so here is the entire
reasoning here again.

01:11:27.440 --> 01:11:31.750
I invite you to look
at that on the slide

01:11:31.750 --> 01:11:35.440
that I posted if you're curious.

01:11:35.440 --> 01:11:37.780
So anyway, a quick
review of today

01:11:37.780 --> 01:11:39.490
is, we went through
self-reference

01:11:39.490 --> 01:11:40.690
and the recursion theorem.

01:11:40.690 --> 01:11:42.670
We gave a few applications.

01:11:42.670 --> 01:11:45.580
And we did a sketch of Godel's
first incompleteness theorem

01:11:45.580 --> 01:11:47.457
in mathematical logic.

01:11:47.457 --> 01:11:49.540
OK, so that's all I'm going
to have for you today.

01:11:49.540 --> 01:11:51.370
We're out of time.

01:11:51.370 --> 01:11:56.950
And I will take any questions.

01:11:56.950 --> 01:11:59.930
So getting back to the MIN
Turing machine example,

01:11:59.930 --> 01:12:01.452
somebody is asking,
how do I know

01:12:01.452 --> 01:12:03.910
there's a Turing machine that's
longer than the machine, R,

01:12:03.910 --> 01:12:05.200
that I'm building?

01:12:05.200 --> 01:12:08.290
Well, there are infinitely
many machines in MIN TM

01:12:08.290 --> 01:12:09.952
or in the infinite
subset of MIN TM.

01:12:09.952 --> 01:12:11.410
So eventually, one
of them is going

01:12:11.410 --> 01:12:15.040
to have to be longer than the
machine that I'm constructing.

01:12:15.040 --> 01:12:20.915
Because that's a machine
of some very specific size,

01:12:20.915 --> 01:12:23.540
and so eventually there's going
to have to be one that's bigger

01:12:23.540 --> 01:12:24.350
that shows up.

01:12:33.033 --> 01:12:34.450
So this may be a
similar question.

01:12:38.710 --> 01:12:42.340
Now, another similar question
is about, how big is R?

01:12:42.340 --> 01:12:47.348
And does the size of R in
that previous thing here--

01:12:47.348 --> 01:12:49.140
I don't know if we want
to go through this.

01:12:49.140 --> 01:12:52.590
But, OK, let's
quickly look at it.

01:12:52.590 --> 01:12:58.680
This machine, R, has a
fixed, predetermined size.

01:12:58.680 --> 01:13:01.520
Its size does not depend on B.

01:13:01.520 --> 01:13:05.520
It depends on E because it's
going to be simulating E.

01:13:05.520 --> 01:13:08.490
But E might be producing
very, very long strings.

01:13:08.490 --> 01:13:10.020
Eventually, it will.

01:13:10.020 --> 01:13:11.400
So E is fixed.

01:13:11.400 --> 01:13:18.520
And then, R's size is fixed.

01:13:18.520 --> 01:13:20.260
So eventually, R
will find a machine

01:13:20.260 --> 01:13:23.740
that's bigger than it is.

01:13:23.740 --> 01:13:24.920
But let's look at--

01:13:29.880 --> 01:13:32.460
right, so this is
a good question.

01:13:32.460 --> 01:13:34.710
I was wondering if I would
get questions of this kind.

01:13:34.710 --> 01:13:37.170
This is getting back to
the question in logic

01:13:37.170 --> 01:13:38.460
here at the end.

01:13:45.220 --> 01:13:49.300
Yes, because I said this
statement here is unprovable.

01:13:49.300 --> 01:13:51.010
But in a sense, I proved it.

01:13:51.010 --> 01:13:54.480
Because how do I know it's true?

01:13:54.480 --> 01:13:57.740
And I gave you an
argument for it.

01:13:57.740 --> 01:14:00.280
And so, you have
to differentiate

01:14:00.280 --> 01:14:03.790
between the reasoning
that we're providing

01:14:03.790 --> 01:14:06.940
and the formal system that
we're reasoning about.

01:14:06.940 --> 01:14:09.880
And the formal system
that we're reasoning about

01:14:09.880 --> 01:14:11.950
is not capable of proving this.

01:14:11.950 --> 01:14:14.020
But we're outside
that formal system

01:14:14.020 --> 01:14:16.150
so that we can reason
about the formal system.

01:14:16.150 --> 01:14:18.610
I know it's a little
bit perverse seeming.

01:14:18.610 --> 01:14:20.860
And mathematical logic
is a little tricky

01:14:20.860 --> 01:14:24.610
because it has to deal
with those kinds of issues.

01:14:24.610 --> 01:14:27.550
But this is arguing within
any particular formal system

01:14:27.550 --> 01:14:33.190
of probability, this
is going to be true.

01:14:33.190 --> 01:14:38.920
But that's kind of
an approximation

01:14:38.920 --> 01:14:41.110
to our own thought process.

01:14:41.110 --> 01:14:44.560
So it's slippery, I agree.

01:14:52.440 --> 01:14:54.720
So, a good question here,
would Godel's theorem still

01:14:54.720 --> 01:14:58.020
hold informal systems where
we don't require that proofs

01:14:58.020 --> 01:14:59.610
of statements are decidable?

01:14:59.610 --> 01:15:02.190
So I'm not saying that
the proofs are decidable.

01:15:02.190 --> 01:15:04.050
That you can--
proofs are checkable.

01:15:04.050 --> 01:15:07.620
So you can test whether
a proof is a proof.

01:15:07.620 --> 01:15:09.570
If you can't test whether
a proof is a proof,

01:15:09.570 --> 01:15:14.230
I don't know of any people who
have studied that situation.

01:15:14.230 --> 01:15:18.030
So that's a little bit
of a trickier case.

01:15:18.030 --> 01:15:21.850
I'm not sure what
to say about that.

01:15:21.850 --> 01:15:25.120
Can I give an example of two
equivalent Turing machines

01:15:25.120 --> 01:15:27.920
where one has a shorter
description than the other?

01:15:27.920 --> 01:15:32.380
How do we define the
length of the description?

01:15:32.380 --> 01:15:39.940
Well, we never really precisely
defined our encoding system.

01:15:39.940 --> 01:15:43.300
But whatever encoding
system you want to use,

01:15:43.300 --> 01:15:50.330
is going to represent
Turing machines as strings.

01:15:50.330 --> 01:15:52.330
And those strings are
going to have a length.

01:15:52.330 --> 01:15:55.150
And so, it doesn't
really matter which

01:15:55.150 --> 01:15:58.540
encoding system you're going to
use because the statement isn't

01:15:58.540 --> 01:16:00.190
going to be true in any of them.

01:16:00.190 --> 01:16:02.380
We could go through the
exercise of defining

01:16:02.380 --> 01:16:03.970
a particular encoding system.

01:16:03.970 --> 01:16:06.950
It's going to be pretty
tedious to do that.

01:16:06.950 --> 01:16:11.500
But you can just imagine writing
down the states, the transition

01:16:11.500 --> 01:16:17.058
function, et cetera, et cetera,
as this big long string.

01:16:17.058 --> 01:16:18.850
And that's going to be
our encoding system.

01:16:18.850 --> 01:16:20.933
And then there are going
to be some long machines.

01:16:20.933 --> 01:16:23.890
Some machines will have
long representations

01:16:23.890 --> 01:16:26.050
and other machines that
have short representations.

01:16:26.050 --> 01:16:30.010
And there's going to
be some machine where

01:16:30.010 --> 01:16:31.930
you can introduce a
bunch of useless states

01:16:31.930 --> 01:16:33.410
that are never accessed.

01:16:33.410 --> 01:16:36.550
So you can expand--

01:16:36.550 --> 01:16:40.347
you can kind of add
junk to the description

01:16:40.347 --> 01:16:42.430
of the machine, which is
not going to do anything.

01:16:42.430 --> 01:16:45.040
But it's just going to make
the description of the machine

01:16:45.040 --> 01:16:48.190
unnecessarily long
compared to what

01:16:48.190 --> 01:16:50.260
with some other
description, which

01:16:50.260 --> 01:16:54.200
is going to compute the same
thing but will be much shorter.

01:16:54.200 --> 01:16:56.560
So you can certainly
find examples

01:16:56.560 --> 01:17:01.040
of pairs of machines that
do the same thing where one

01:17:01.040 --> 01:17:02.290
is much longer than the other.

01:17:05.720 --> 01:17:08.230
So I will then close
the session here.

01:17:08.230 --> 01:17:15.370
And I will be very shortly
on the office hours link

01:17:15.370 --> 01:17:18.720
and see some of you there.