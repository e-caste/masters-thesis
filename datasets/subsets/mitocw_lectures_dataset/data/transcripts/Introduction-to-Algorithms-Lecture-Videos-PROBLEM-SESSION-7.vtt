WEBVTT

00:00:00.000 --> 00:00:12.584
[SQUEAKING]
[RUSTLING] [CLICKING]

00:00:12.584 --> 00:00:15.250
JUSTIN SOLOMON: Right, so
today is going to be our first,

00:00:15.250 --> 00:00:17.050
I believe, of two
problem sessions

00:00:17.050 --> 00:00:18.670
covering dynamic programming.

00:00:21.032 --> 00:00:22.490
I've learned dynamic
programming is

00:00:22.490 --> 00:00:24.698
one of these interesting
parts of an algorithms class

00:00:24.698 --> 00:00:26.960
where, somehow, the people
that are really good at it

00:00:26.960 --> 00:00:28.730
are completely disjoint
with the people that

00:00:28.730 --> 00:00:31.063
are good at all the other
parts of the algorithms class.

00:00:31.063 --> 00:00:33.290
So for some of you guys,
that might be promising,

00:00:33.290 --> 00:00:35.750
and for others, maybe
a little bit less so.

00:00:35.750 --> 00:00:38.000
So maybe we'll spend just
a minute or two reviewing

00:00:38.000 --> 00:00:40.490
the basic ideas we're going
to apply in these problems

00:00:40.490 --> 00:00:43.640
because they'll follow, more
or less, the same template.

00:00:43.640 --> 00:00:45.560
Although, of course,
as usual in 6.006,

00:00:45.560 --> 00:00:49.370
we like to put some interesting
window dressing around it

00:00:49.370 --> 00:00:52.200
so that it's not totally
obvious what you're doing.

00:00:52.200 --> 00:00:54.960
And then we'll do a
bunch of sample problems.

00:00:54.960 --> 00:00:55.460
Right.

00:00:55.460 --> 00:00:58.880
So let's talk a little bit
about dynamic programming

00:00:58.880 --> 00:01:01.520
and the basic idea here.

00:01:01.520 --> 00:01:05.209
So, dynamic programming is kind
of a funny outlier in 6.006

00:01:05.209 --> 00:01:06.138
in that--

00:01:06.138 --> 00:01:08.430
for example, in the data
structures part of the course,

00:01:08.430 --> 00:01:11.260
we learned, like, what--

00:01:11.260 --> 00:01:13.740
now I'm struggling to
think of a data structure--

00:01:13.740 --> 00:01:16.530
like a useful-- like trees
and arrays or whatever.

00:01:16.530 --> 00:01:18.530
And these are actually
things that you can code.

00:01:18.530 --> 00:01:22.610
if you look and
see if there are--

00:01:22.610 --> 00:01:24.590
well, plausibly, it could
be an implementation

00:01:24.590 --> 00:01:26.810
of a tree in there somewhere.

00:01:26.810 --> 00:01:28.280
And so these are
useful algorithms

00:01:28.280 --> 00:01:29.930
that you can maybe even
read the pseudocode.

00:01:29.930 --> 00:01:31.555
And there's a universe
where you really

00:01:31.555 --> 00:01:33.740
do translate that
pseudocode into something

00:01:33.740 --> 00:01:35.567
inside of your laptop.

00:01:35.567 --> 00:01:37.400
Dynamic programming is
a little bit less so.

00:01:37.400 --> 00:01:38.420
This is more of a meta--

00:01:38.420 --> 00:01:40.337
I don't know if you'd
call it a meta algorithm

00:01:40.337 --> 00:01:42.590
or problem solving
approach or what,

00:01:42.590 --> 00:01:44.290
but it's not like
you somehow say,

00:01:44.290 --> 00:01:46.040
I'm going to apply the
dynamic programming

00:01:46.040 --> 00:01:48.030
algorithm to this problem.

00:01:48.030 --> 00:01:51.410
But rather, it's sort of this
big class of things that all

00:01:51.410 --> 00:01:55.100
follow a similar template or
sort of approach to thinking

00:01:55.100 --> 00:01:58.790
about problem solving, which
I think sort of explains why,

00:01:58.790 --> 00:02:01.940
actually, in some sense, the
last couple of lectures that

00:02:01.940 --> 00:02:04.762
you've seen-- and, I guess, if
I'm getting the time sequence

00:02:04.762 --> 00:02:07.220
of our course right, the next
couple of years that you will

00:02:07.220 --> 00:02:08.815
see--

00:02:08.815 --> 00:02:10.190
and the problem
sessions actually

00:02:10.190 --> 00:02:13.280
start to coincide in the sense
that when Erik was teaching

00:02:13.280 --> 00:02:16.080
you guys dynamic programming,
how did he do it?

00:02:16.080 --> 00:02:17.540
Well, he didn't
write down-- well,

00:02:17.540 --> 00:02:18.800
he sort of wrote
down some template

00:02:18.800 --> 00:02:20.300
for dynamic programming,
but then we just did

00:02:20.300 --> 00:02:21.710
a bunch of sample problems.

00:02:21.710 --> 00:02:23.812
And that's exactly what
we're going to do today.

00:02:23.812 --> 00:02:25.520
So, somehow, all of
these things are just

00:02:25.520 --> 00:02:28.610
going to converge in
this part of our course

00:02:28.610 --> 00:02:30.770
because dynamic
programming, it's

00:02:30.770 --> 00:02:35.203
really more of a way of life
than any particular algorithm.

00:02:35.203 --> 00:02:36.620
And this is a
pattern that I think

00:02:36.620 --> 00:02:38.623
you see a lot in
advanced algorithms.

00:02:38.623 --> 00:02:40.040
Like, for example,
in my universe,

00:02:40.040 --> 00:02:43.360
in numerical analysis, when you
talk about the ADMM algorithm,

00:02:43.360 --> 00:02:45.110
it's actually a totally
useless algorithm.

00:02:45.110 --> 00:02:48.350
What matters is applying
it to a particular problem.

00:02:48.350 --> 00:02:51.500
And this is sort of, I think,
a more mature or grown up

00:02:51.500 --> 00:02:53.030
way to think about
a lot of things

00:02:53.030 --> 00:02:56.900
in algorithms, that pretty soon,
this sort of general purpose

00:02:56.900 --> 00:02:59.340
stuff that's useful
all the time,

00:02:59.340 --> 00:03:02.150
I think, it starts to
disperse a little bit in favor

00:03:02.150 --> 00:03:03.782
of different patterns
and mechanisms

00:03:03.782 --> 00:03:05.240
that you're used
to thinking about.

00:03:05.240 --> 00:03:07.100
So there's my
10-second, sort of,

00:03:07.100 --> 00:03:09.320
philosophical introduction
to what we're doing,

00:03:09.320 --> 00:03:10.850
during which I've
managed to chase

00:03:10.850 --> 00:03:14.870
this table across the room.

00:03:14.870 --> 00:03:15.860
You know, I played--

00:03:15.860 --> 00:03:18.183
I did college on the
west coast, and I

00:03:18.183 --> 00:03:19.850
thought I was going
to be a music major.

00:03:19.850 --> 00:03:21.517
And there was a piano
master class where

00:03:21.517 --> 00:03:23.720
we forgot to put the
little clips on the wheels

00:03:23.720 --> 00:03:26.080
and there was an
earthquake, and I just

00:03:26.080 --> 00:03:28.580
thought I was really nervous
because the piano was literally

00:03:28.580 --> 00:03:30.980
slipping away from me.

00:03:30.980 --> 00:03:35.160
I can never think of that Chopin
nocturne in quite the same way.

00:03:35.160 --> 00:03:38.570
But in any event, in
dynamic programming,

00:03:38.570 --> 00:03:41.240
Erik laid out for you guys
a particular, sort of,

00:03:41.240 --> 00:03:46.160
set of steps that are a useful
problem-solving approach

00:03:46.160 --> 00:03:47.738
in the dynamic
programming universe.

00:03:47.738 --> 00:03:49.280
In today's problem
session, I'm going

00:03:49.280 --> 00:03:51.770
to try and help you guys
translate a little bit

00:03:51.770 --> 00:03:55.040
from this template to what it
means to actually write code

00:03:55.040 --> 00:03:56.990
to implement a dynamic
programming algorithm

00:03:56.990 --> 00:04:01.260
because I think it's a little
easy to forget that here.

00:04:01.260 --> 00:04:03.860
But, on the other
hand, on your homework,

00:04:03.860 --> 00:04:06.480
when you're writing out
answers to algorithms problem,

00:04:06.480 --> 00:04:09.860
it's perfectly fine to follow
this template even letter--

00:04:09.860 --> 00:04:13.058
I guess-- literally letter
for letter and answer each

00:04:13.058 --> 00:04:13.850
of these questions.

00:04:13.850 --> 00:04:17.600
And then the remaining glue
that you need to actually write

00:04:17.600 --> 00:04:19.910
the code is not
terribly exciting

00:04:19.910 --> 00:04:22.980
from an algorithms
theory perspective.

00:04:22.980 --> 00:04:25.010
So the basic idea
here is that there's

00:04:25.010 --> 00:04:27.560
a lot of different problems
that can be written recursively,

00:04:27.560 --> 00:04:29.580
in some sense.

00:04:29.580 --> 00:04:32.810
Certainly, we've encountered
many of those in this course.

00:04:32.810 --> 00:04:34.310
In fact, I think
the bias in the way

00:04:34.310 --> 00:04:35.850
that we've presented
algorithms that

00:04:35.850 --> 00:04:39.420
don't have to be recursive is to
write them in a recursive way.

00:04:39.420 --> 00:04:43.370
And the point here is that
when you have a recursive call

00:04:43.370 --> 00:04:46.790
and you repeat something,
you give the function

00:04:46.790 --> 00:04:48.680
the same input
more than one time,

00:04:48.680 --> 00:04:51.542
you might as well remember what
you got the last time you saw

00:04:51.542 --> 00:04:53.000
that input, and
then you don't have

00:04:53.000 --> 00:04:54.290
to do that computation again.

00:04:54.290 --> 00:04:57.740
Really, in one sentence, I think
that's roughly the logic behind

00:04:57.740 --> 00:05:00.320
all these dynamic
programming things.

00:05:00.320 --> 00:05:02.960
So there's no reason to be
too redundant with lecture.

00:05:02.960 --> 00:05:05.690
For just the
10-second overview, I

00:05:05.690 --> 00:05:08.150
think that there's an example
which is simultaneously

00:05:08.150 --> 00:05:12.050
good and misleading, which
is this Fibonacci sequence.

00:05:12.050 --> 00:05:15.140
It's good in the sense that the
logic of dynamic programming

00:05:15.140 --> 00:05:16.010
is really easy.

00:05:16.010 --> 00:05:20.075
It's bad in that the runtime is
kind of weird to think about.

00:05:20.075 --> 00:05:21.950
But remember, though,
your Fibonacci sequence

00:05:21.950 --> 00:05:27.380
looks something like f of
k equals f of k minus 1

00:05:27.380 --> 00:05:30.750
plus f of k minus 2.

00:05:30.750 --> 00:05:34.740
And if you look at your, sort
of, recursive call tree here--

00:05:34.740 --> 00:05:37.490
like, let's say that
I do k equals 4.

00:05:37.490 --> 00:05:39.800
Then it's going to call--

00:05:39.800 --> 00:05:43.040
my function f is going to have
to evaluate it at 3 and 2.

00:05:43.040 --> 00:05:46.880
And then the 3 is going to
evaluate at 2 and 1, and so on.

00:05:46.880 --> 00:05:51.050
And the thing to notice is
that when I call f of 4--

00:05:51.050 --> 00:05:54.740
or, rather, f of 3 here, if
there were 3 somewhere else

00:05:54.740 --> 00:05:56.360
in my tree, I get
the same number, so,

00:05:56.360 --> 00:05:59.578
in particular, f
of 2 and f of 2.

00:05:59.578 --> 00:06:01.370
Both of these are going
to take some amount

00:06:01.370 --> 00:06:03.328
of algorithmic work, but
if just the first time

00:06:03.328 --> 00:06:05.780
I see a 2 I have a little
piece of scratch paper

00:06:05.780 --> 00:06:08.870
and I say, oh, any
time I see k equals

00:06:08.870 --> 00:06:10.400
2, just return
this number rather

00:06:10.400 --> 00:06:12.980
than doing recursive
calls, then, in effect,

00:06:12.980 --> 00:06:16.220
if there's any subtree
underneath this thing,

00:06:16.220 --> 00:06:19.010
I've just pruned
it from my tree.

00:06:19.010 --> 00:06:22.620
And so that's the
basic logic here.

00:06:22.620 --> 00:06:24.500
And that's basically
the paradigm

00:06:24.500 --> 00:06:30.790
that's going on in this
SRTBOT acronym, which

00:06:30.790 --> 00:06:34.960
is you first take your problem
and divide it into subproblems.

00:06:34.960 --> 00:06:36.080
That is mysterious.

00:06:36.080 --> 00:06:37.150
Why is this board moving?

00:06:40.276 --> 00:06:42.901
Oh, there's a phone in my pocket
and I bumped against the wall.

00:06:48.302 --> 00:06:50.750
I'm not used to this classroom.

00:06:50.750 --> 00:06:52.510
Right.

00:06:52.510 --> 00:06:53.010
Yeah.

00:06:53.010 --> 00:06:54.385
So the first thing
you want to do

00:06:54.385 --> 00:06:58.272
is to write my problem
as this sort of form.

00:06:58.272 --> 00:07:00.480
Notice just that we've done
this a lot in this class,

00:07:00.480 --> 00:07:01.855
we've written
things recursively.

00:07:01.855 --> 00:07:04.320
The difference here is
the sort of argument

00:07:04.320 --> 00:07:06.360
that goes into recursion
is typically, maybe,

00:07:06.360 --> 00:07:10.140
a little simpler than putting
some giant data structure

00:07:10.140 --> 00:07:11.840
inside of there or
something like that.

00:07:11.840 --> 00:07:13.680
So, for instance,
merge sort, you

00:07:13.680 --> 00:07:14.980
could write in this paradigm.

00:07:14.980 --> 00:07:16.730
I guess we covered
that, but it's probably

00:07:16.730 --> 00:07:19.370
not the most natural way
to think about merge sort.

00:07:19.370 --> 00:07:22.290
Then we need to relate our
subproblems to each other.

00:07:22.290 --> 00:07:24.920
So, for instance, in the
Fibonacci sequence problem,

00:07:24.920 --> 00:07:26.750
I just gave you
the relation that--

00:07:26.750 --> 00:07:28.500
what defines the problem.

00:07:28.500 --> 00:07:32.840
Incidentally, this is, what,
a model for the reproduction

00:07:32.840 --> 00:07:34.550
of rabbits, I
think, if I remember

00:07:34.550 --> 00:07:36.710
reading the history of
the Fibonacci sequence.

00:07:39.250 --> 00:07:41.505
And then, I think,
to me, the most--

00:07:41.505 --> 00:07:44.130
not necessarily unnatural-- but
I think the thing that maybe is

00:07:44.130 --> 00:07:46.422
hardest to translate to an
algorithm if you're thinking

00:07:46.422 --> 00:07:47.760
about writing code is this--

00:07:47.760 --> 00:07:50.170
oh, man, this is going
to be a problem--

00:07:50.170 --> 00:07:53.430
this idea of topological order.

00:07:53.430 --> 00:07:57.090
The basic idea here is that
if f of 1 depended on f of 2,

00:07:57.090 --> 00:08:01.110
and f of 2 depended on f of
1, I'd be in a lot of trouble,

00:08:01.110 --> 00:08:03.510
right, because somehow
my tree would never

00:08:03.510 --> 00:08:06.210
converge, for one thing, if
I made these recursive calls

00:08:06.210 --> 00:08:09.090
and I'd never be able
to memoize or, kind of,

00:08:09.090 --> 00:08:10.910
remember a value when I move on.

00:08:10.910 --> 00:08:11.410
Right?

00:08:11.410 --> 00:08:12.910
And so the idea
here is that there's

00:08:12.910 --> 00:08:14.370
some ordering of
my subproblem so

00:08:14.370 --> 00:08:16.630
that I can build up a solution.

00:08:16.630 --> 00:08:18.460
And there's, sort
of, two dual ways

00:08:18.460 --> 00:08:20.490
to think about
why that's useful.

00:08:20.490 --> 00:08:24.530
So in the memoization
universe, what do I do?

00:08:24.530 --> 00:08:27.430
I just add an if statement
saying if I've already

00:08:27.430 --> 00:08:29.560
evaluated f of k, return it.

00:08:29.560 --> 00:08:31.640
That's perfectly fine.

00:08:31.640 --> 00:08:34.030
The other thing I can do
is if I write my problems

00:08:34.030 --> 00:08:37.289
in topological order,
then I can sort of

00:08:37.289 --> 00:08:40.950
go in the reverse direction and
build up my memoization table.

00:08:40.950 --> 00:08:45.120
So, for instance, for the
Fibonacci sequence problem,

00:08:45.120 --> 00:08:48.630
I could do f of 1 and then f
of 2 and then f of 3 and f of 4

00:08:48.630 --> 00:08:51.270
all the way until I get to the
k value that I actually wanted.

00:08:51.270 --> 00:08:53.400
And those are just
duals of the same coin.

00:08:53.400 --> 00:08:55.715
They're exactly
the same approach.

00:08:55.715 --> 00:08:57.090
Although the
memoization version,

00:08:57.090 --> 00:08:58.860
sometimes you can
prune out subproblems

00:08:58.860 --> 00:09:00.610
that you didn't
actually need to solve.

00:09:00.610 --> 00:09:03.430
So, for instance, maybe
this was f of k minus 7,

00:09:03.430 --> 00:09:06.340
and so I can skip a few
indices in my array.

00:09:06.340 --> 00:09:08.835
I don't think, typically, that
has a big effect on runtime

00:09:08.835 --> 00:09:10.210
for the problems
that we've seen,

00:09:10.210 --> 00:09:13.690
but it could, plausibly,
in some universal.

00:09:13.690 --> 00:09:15.100
I'd have to think
about a problem

00:09:15.100 --> 00:09:18.440
where that makes a difference.

00:09:18.440 --> 00:09:18.940
Right.

00:09:18.940 --> 00:09:20.773
And then I think the
BOT part of SRTBOT

00:09:20.773 --> 00:09:22.190
is a little easier
to think about.

00:09:22.190 --> 00:09:25.810
You have to make sure that
this recursion has a base case,

00:09:25.810 --> 00:09:27.730
like when is this
thing going to stop.

00:09:27.730 --> 00:09:28.880
That's exactly the same.

00:09:28.880 --> 00:09:32.090
It's just any
recursive algorithm.

00:09:32.090 --> 00:09:35.590
The O for original, I
think, is a little bit

00:09:35.590 --> 00:09:38.050
retrofit to make
SRTBOT sound nice,

00:09:38.050 --> 00:09:39.670
but I think the idea
here is that you

00:09:39.670 --> 00:09:40.960
need to go back to
your original problem

00:09:40.960 --> 00:09:42.335
and make sure that
it corresponds

00:09:42.335 --> 00:09:44.830
to one of the function
calls that you've written

00:09:44.830 --> 00:09:46.390
in all this complicated stuff.

00:09:46.390 --> 00:09:48.620
Hopefully that's a
reasonable characterization.

00:09:48.620 --> 00:09:51.280
And then, finally,
the t is more--

00:09:51.280 --> 00:09:53.440
these are for describing
your algorithm.

00:09:53.440 --> 00:09:55.270
The last one is
for analyzing it.

00:09:55.270 --> 00:09:57.670
And, again, the
BOT part of SRTBOT

00:09:57.670 --> 00:10:00.490
almost applies to anything we've
done in 6.006, like you should

00:10:00.490 --> 00:10:02.780
always analyze your run time.

00:10:02.780 --> 00:10:03.280
OK.

00:10:03.280 --> 00:10:07.190
So, in any event, that's
my 10-minute version

00:10:07.190 --> 00:10:10.340
of the last couple lectures
and, I think, more or less,

00:10:10.340 --> 00:10:13.757
enough to get us started with
some sample problems here.

00:10:13.757 --> 00:10:14.840
Sorry, I couldn't help it.

00:10:14.840 --> 00:10:16.530
I like to teach things.

00:10:16.530 --> 00:10:17.030
OK.

00:10:17.030 --> 00:10:18.320
So, right.

00:10:18.320 --> 00:10:20.570
So in our problem
session, we have

00:10:20.570 --> 00:10:25.220
a few of the homework problems
from last year to go over.

00:10:25.220 --> 00:10:26.900
If it makes you guys
feel any better,

00:10:26.900 --> 00:10:28.648
I got myself all balled
up on one of them

00:10:28.648 --> 00:10:30.440
last night while I was
preparing for today.

00:10:30.440 --> 00:10:33.050
And I look forward to doing
that in front of all of you guys

00:10:33.050 --> 00:10:34.470
now.

00:10:34.470 --> 00:10:34.970
Right.

00:10:34.970 --> 00:10:40.080
So, I'm afraid of this, so I'm
going to go to the next board.

00:10:40.080 --> 00:10:40.580
OK.

00:10:40.580 --> 00:10:44.690
So in our first
problem, Sunny studies--

00:10:44.690 --> 00:10:46.640
this was-- somehow,
the cute naming

00:10:46.640 --> 00:10:50.210
conventions we have in 6.006
got really meta in this problem,

00:10:50.210 --> 00:10:52.340
because there's a problem
about Tim the Beaver.

00:10:52.340 --> 00:10:55.490
But, as we all know,
Tim is MIT backwards,

00:10:55.490 --> 00:10:59.840
so he happens to fit
into this goofy game

00:10:59.840 --> 00:11:02.180
that Jason likes to play in
writing homework problems.

00:11:02.180 --> 00:11:05.450
Anyway, but it's
also the MIT mascot.

00:11:05.450 --> 00:11:07.900
Anyway, I got very excited.

00:11:07.900 --> 00:11:08.400
Right.

00:11:08.400 --> 00:11:11.190
So what's going on
in this problem?

00:11:11.190 --> 00:11:15.060
So Tim the Beaver has kind
of an interesting-- you know,

00:11:15.060 --> 00:11:17.660
mathematics, I think you would
call this a martingale if you

00:11:17.660 --> 00:11:19.910
flip the coin a little bit
when he solve this problem.

00:11:19.910 --> 00:11:24.890
But luckily, Tim the Beaver is
a deterministic kind of a guy.

00:11:24.890 --> 00:11:27.230
And he looks at the
weather outside,

00:11:27.230 --> 00:11:29.570
and if it's a temperature
t-- apparently,

00:11:29.570 --> 00:11:31.940
Tim the Beaver is
OK with boiling.

00:11:31.940 --> 00:11:35.570
The higher the temperature,
the happier Tim gets.

00:11:35.570 --> 00:11:38.630
So this is a first derivative
kind of a phenomenon.

00:11:38.630 --> 00:11:45.200
In particular, on a given day,
if I have a temperature t,

00:11:45.200 --> 00:11:47.720
Tim the Beaver has
two things that he

00:11:47.720 --> 00:11:49.670
can do to change his mood.

00:11:49.670 --> 00:11:51.980
Apparently, Tim the Beaver's
mood never stays fixed.

00:11:51.980 --> 00:11:54.800
It always goes up and down.

00:11:54.800 --> 00:12:05.430
In particular, he can either
go outside, in which case

00:12:05.430 --> 00:12:21.450
the happiness increases by
t, OK, or he can stay inside,

00:12:21.450 --> 00:12:29.750
in which case his
happiness decreases by t.

00:12:29.750 --> 00:12:30.340
OK.

00:12:30.340 --> 00:12:35.175
So every day, Tim the
Beaver, he wakes up he--

00:12:35.175 --> 00:12:37.300
I really want to say that
he checks for his shadow,

00:12:37.300 --> 00:12:39.400
but that's a gopher, right?

00:12:39.400 --> 00:12:42.910
i any event, he wakes up in the
morning, he checks the weather,

00:12:42.910 --> 00:12:44.432
and he makes the
determination does

00:12:44.432 --> 00:12:45.640
he want to go outside or not.

00:12:45.640 --> 00:12:47.680
And if he goes outside,
he gets happier

00:12:47.680 --> 00:12:50.320
by an amount that's
equal to the temperature.

00:12:50.320 --> 00:12:53.808
If he stays inside, he gets
less happy by an amount that's

00:12:53.808 --> 00:12:54.850
equal to the temperature.

00:12:54.850 --> 00:12:56.933
By the way, I think our
solution is perfectly fine

00:12:56.933 --> 00:13:00.040
if temperatures are negative
here, in which case,

00:13:00.040 --> 00:13:02.620
I guess, everything
would flip intuitively.

00:13:02.620 --> 00:13:06.400
But there's no reason to
get too hung up on that.

00:13:06.400 --> 00:13:09.070
But, of course,
there's a twist here.

00:13:09.070 --> 00:13:19.040
So Tim, as with many of you,
has n days until his final exam.

00:13:23.030 --> 00:13:24.840
And he's worried about studying.

00:13:24.840 --> 00:13:25.340
Yeah?

00:13:25.340 --> 00:13:30.140
So, in particular, he
never wants to go--

00:13:30.140 --> 00:13:31.760
he's come up with
a personal resolve

00:13:31.760 --> 00:13:35.090
to never go outside more
than two days in a row.

00:13:35.090 --> 00:13:37.040
Yeah?

00:13:37.040 --> 00:13:37.940
So, right.

00:13:47.590 --> 00:13:52.117
And so the question is--
right, because that way

00:13:52.117 --> 00:13:53.950
he has to stay inside
and study at least one

00:13:53.950 --> 00:13:56.030
out of every three-ish days.

00:13:56.030 --> 00:13:56.810
OK.

00:13:56.810 --> 00:14:02.490
So the question is how can
Tim maximize his happiness.

00:14:02.490 --> 00:14:04.350
Incidentally, in
machine learning,

00:14:04.350 --> 00:14:06.310
sometimes they call
that minimizing regret,

00:14:06.310 --> 00:14:08.070
which I always found
to be a very sad way

00:14:08.070 --> 00:14:11.580
to think about algorithms when
there's a totally dual version.

00:14:11.580 --> 00:14:12.780
But Tim's an optimistic guy.

00:14:12.780 --> 00:14:15.180
He wants to maximize his
happiness subject to this

00:14:15.180 --> 00:14:18.510
constraint that he cannot go
outside more than two days

00:14:18.510 --> 00:14:19.020
in a row.

00:14:19.020 --> 00:14:19.520
Right?

00:14:19.520 --> 00:14:21.150
So if I go out on
Monday and Tuesday,

00:14:21.150 --> 00:14:23.880
I have to stay
inside on Wednesday.

00:14:23.880 --> 00:14:24.380
Yes?

00:14:24.380 --> 00:14:26.547
AUDIENCE: I think there's
no effect to his happiness

00:14:26.547 --> 00:14:27.290
when he stays in.

00:14:27.290 --> 00:14:29.373
JUSTIN SOLOMON: There's
no effect to his happiness

00:14:29.373 --> 00:14:31.750
when he stays in.

00:14:31.750 --> 00:14:34.107
AUDIENCE: At least,
that's [INAUDIBLE]..

00:14:34.107 --> 00:14:36.440
JUSTIN SOLOMON: No, it says
with a decrease in happiness

00:14:36.440 --> 00:14:39.998
when t-- oh, when t is negative.

00:14:39.998 --> 00:14:42.290
That's not actually going to
affect our problem at all.

00:14:45.687 --> 00:14:47.270
AUDIENCE: It's not
going to affect it.

00:14:47.270 --> 00:14:50.838
JUSTIN SOLOMON: Sure,
yeah, I can fix this live.

00:14:50.838 --> 00:14:52.880
This is what happens when
I do the problem myself

00:14:52.880 --> 00:14:56.320
before looking at the answer
and then don't check it closely.

00:14:56.320 --> 00:14:56.820
Fine.

00:14:56.820 --> 00:14:59.190
So let's change that.

00:14:59.190 --> 00:15:02.010
I like this problem better,
somehow, psychologically.

00:15:02.010 --> 00:15:03.450
But that's OK.

00:15:03.450 --> 00:15:03.950
Right.

00:15:03.950 --> 00:15:07.110
So, Jason correctly points
out that if you actually

00:15:07.110 --> 00:15:11.940
read the problem, what's asked
there is slightly different,

00:15:11.940 --> 00:15:14.610
that when he goes outside,
his happiness increases by t.

00:15:14.610 --> 00:15:17.350
If he stays inside, his
happiness does nothing.

00:15:17.350 --> 00:15:17.850
Right?

00:15:17.850 --> 00:15:23.530
So it stays the same.

00:15:23.530 --> 00:15:27.110
My apologies, so Tim the Beaver
is a particularly optimistic

00:15:27.110 --> 00:15:27.610
beaver.

00:15:27.610 --> 00:15:30.130
His happiness can
only increase in time,

00:15:30.130 --> 00:15:33.010
assuming he lives in a climate
with positive temperatures.

00:15:33.010 --> 00:15:34.030
OK.

00:15:34.030 --> 00:15:35.620
I think I've got it right now.

00:15:35.620 --> 00:15:36.320
Cool.

00:15:36.320 --> 00:15:39.670
We'll see if I
can still do this.

00:15:39.670 --> 00:15:42.520
Yeah, I think basically
nothing changes.

00:15:42.520 --> 00:15:45.610
OK, that's great.

00:15:45.610 --> 00:15:46.110
All right.

00:15:46.110 --> 00:15:46.985
We're going to do it.

00:15:51.760 --> 00:15:52.930
OK.

00:15:52.930 --> 00:15:56.440
Right, so the question is
how do we solve this problem.

00:15:56.440 --> 00:15:59.230
And thankfully, I think we
put the easiest problem first.

00:15:59.230 --> 00:16:03.000
And, in particular, if we're
following our SRTBOT paradigm

00:16:03.000 --> 00:16:06.480
here, somehow there's a
set of subproblems that

00:16:06.480 --> 00:16:09.190
are staring us in the face.

00:16:09.190 --> 00:16:11.400
That's the word I'm looking for.

00:16:11.400 --> 00:16:15.330
In particular,
well, there's sort

00:16:15.330 --> 00:16:17.160
of only one index in
our problem, which

00:16:17.160 --> 00:16:18.600
is what day it is.

00:16:18.600 --> 00:16:21.150
So the obvious thing
to do would be to say,

00:16:21.150 --> 00:16:23.550
can we figure out
the maximum amount

00:16:23.550 --> 00:16:27.810
of happiness for days,
say, i to the last day?

00:16:27.810 --> 00:16:30.240
By the way, if I do that,
I'm using the prefix version

00:16:30.240 --> 00:16:31.720
of my problem--

00:16:31.720 --> 00:16:33.700
ah, suffix version
of my problem.

00:16:33.700 --> 00:16:36.270
I could also do it the opposite
way and work from the end

00:16:36.270 --> 00:16:37.262
back in.

00:16:37.262 --> 00:16:38.970
Maybe if we have time
all the way at end,

00:16:38.970 --> 00:16:39.970
we'll do the second one.

00:16:39.970 --> 00:16:42.240
But it doesn't really matter.

00:16:42.240 --> 00:16:42.960
OK.

00:16:42.960 --> 00:16:46.840
So, in particular, just to
add a little bit of notation,

00:16:46.840 --> 00:16:56.370
let's say that t of i is equal
to the temperature on day i.

00:16:56.370 --> 00:16:57.900
OK.

00:16:57.900 --> 00:17:00.600
And now we're going to
make a new thing, which

00:17:00.600 --> 00:17:02.850
is going to be the actual
variable we want to compute.

00:17:02.850 --> 00:17:05.670
This is going to be x to
i, which, we'll write,

00:17:05.670 --> 00:17:15.869
is the maximum happiness that
you can achieve if you only

00:17:15.869 --> 00:17:22.760
consider the calendar from day
i to day n, I guess inclusive.

00:17:22.760 --> 00:17:24.650
OK.

00:17:24.650 --> 00:17:26.329
Incidentally, just
for convenience,

00:17:26.329 --> 00:17:28.250
we'll assume that
x i is equal to 0

00:17:28.250 --> 00:17:32.090
if I go past the end of
my array, which I think

00:17:32.090 --> 00:17:36.730
is, kind of, a, typical thing to
do in these type DP algorithms.

00:17:36.730 --> 00:17:37.330
OK.

00:17:37.330 --> 00:17:40.060
So the question is can
we actually come up

00:17:40.060 --> 00:17:42.650
with a recursive
algorithm that computes

00:17:42.650 --> 00:17:50.080
x i using this nice, sort
of, typologically acyclic way

00:17:50.080 --> 00:17:51.820
of thinking about our problem.

00:17:51.820 --> 00:17:55.060
The answer is obviously yes,
or I wouldn't be here today.

00:17:55.060 --> 00:17:58.390
And so in the absence
of a smarter idea,

00:17:58.390 --> 00:18:01.720
let's just do the Toucan
Sam approach here and follow

00:18:01.720 --> 00:18:06.610
our nose and see if we can
just write our problem in terms

00:18:06.610 --> 00:18:08.120
of other ones.

00:18:08.120 --> 00:18:10.330
So, in general, let's
say that Tim the Beaver

00:18:10.330 --> 00:18:12.160
wakes up on day i.

00:18:12.160 --> 00:18:16.030
He has, basically, two decisions
that he can make, right?

00:18:16.030 --> 00:18:20.410
He can either stay inside
or he can not stay inside.

00:18:20.410 --> 00:18:22.360
He can go outside, right?

00:18:22.360 --> 00:18:27.320
So let's just basically
handle these three cases.

00:18:27.320 --> 00:18:30.460
So in case, one he stays inside.

00:18:33.430 --> 00:18:36.790
Well, now what happens
to his happiness?

00:18:36.790 --> 00:18:39.430
Well, according to
my revised version

00:18:39.430 --> 00:18:44.870
of this problem, nothing, so,
in particular, what do we know?

00:18:44.870 --> 00:18:47.302
Well, if he stays
inside, then he has--

00:18:47.302 --> 00:18:49.510
any decision he can make
tomorrow, it doesn't matter.

00:18:49.510 --> 00:18:51.190
He can go inside,
he can go outside,

00:18:51.190 --> 00:18:53.530
whatever, because by
having stayed inside,

00:18:53.530 --> 00:18:56.890
he's earned himself two
free days of going outside

00:18:56.890 --> 00:18:57.810
if he wants.

00:18:57.810 --> 00:18:58.420
Right?

00:18:58.420 --> 00:19:02.500
So, in particular, in this
case, we can convince ourselves

00:19:02.500 --> 00:19:08.170
that this is true, I think.

00:19:08.170 --> 00:19:12.520
Yes, so, in other words, while
he gets no utility for today,

00:19:12.520 --> 00:19:14.770
he wakes up tomorrow and he
can make whatever decision

00:19:14.770 --> 00:19:16.400
he wants.

00:19:16.400 --> 00:19:18.860
OK.

00:19:18.860 --> 00:19:20.900
The second thing he
can do is go out.

00:19:25.760 --> 00:19:28.110
This is where things
get a little tricky.

00:19:28.110 --> 00:19:28.610
Right?

00:19:28.610 --> 00:19:34.170
Can I just do, like, take t
i and add it to x i plus 1?

00:19:34.170 --> 00:19:37.468
What goes wrong?

00:19:37.468 --> 00:19:38.940
AUDIENCE: You go
out three days--

00:19:38.940 --> 00:19:41.440
JUSTIN SOLOMON: Maybe you go
out three days in a row, right?

00:19:41.440 --> 00:19:43.770
Somehow, you have to
remember that, right?

00:19:43.770 --> 00:19:47.295
And so that's where things are
a little bit of a headache,

00:19:47.295 --> 00:19:51.530
that, in particular, if I
go out today and tomorrow,

00:19:51.530 --> 00:19:54.080
I can't go out the
day after that.

00:19:54.080 --> 00:19:57.020
And somehow, if we just
dealt with this one case

00:19:57.020 --> 00:19:59.870
as t i plus x i plus 1,
we wouldn't remember that.

00:19:59.870 --> 00:20:01.890
And that's a problem.

00:20:01.890 --> 00:20:04.100
So, instead, what we
can do is think of there

00:20:04.100 --> 00:20:06.470
being two subcases, right?

00:20:06.470 --> 00:20:08.900
So what we're going to assume
is that not only does he

00:20:08.900 --> 00:20:12.348
go out today, but that he's
free to go out tomorrow.

00:20:12.348 --> 00:20:14.390
And we're going to make
that recursive assumption

00:20:14.390 --> 00:20:16.910
as we move down our array.

00:20:16.910 --> 00:20:21.860
So if we do that, well, now
we have case a and case b.

00:20:21.860 --> 00:20:27.630
So in case a, he goes out
today and he stays in tomorrow.

00:20:27.630 --> 00:20:28.130
Yeah.

00:20:35.160 --> 00:20:35.910
OK.

00:20:35.910 --> 00:20:38.010
So what happens in
this case, well--

00:20:40.800 --> 00:20:43.260
by the way, I'm using this
kind of weird arrow notation.

00:20:43.260 --> 00:20:44.310
I don't know if
this is good or not,

00:20:44.310 --> 00:20:45.450
but, essentially,
the point is that I'm

00:20:45.450 --> 00:20:47.490
keeping track of cases,
and then eventually I'm

00:20:47.490 --> 00:20:49.032
going to want to
have to take the max

00:20:49.032 --> 00:20:50.382
overall of these things.

00:20:50.382 --> 00:20:52.590
So I don't like the equal
sign because somehow that's

00:20:52.590 --> 00:20:54.750
a little misleading.

00:20:54.750 --> 00:20:55.250
Right.

00:20:55.250 --> 00:20:58.050
So in that case, well,
he gets the utility

00:20:58.050 --> 00:21:01.540
of having gone out today.

00:21:01.540 --> 00:21:04.778
Tomorrow he stays
in, which means

00:21:04.778 --> 00:21:07.070
that the day after tomorrow
he can do whatever the heck

00:21:07.070 --> 00:21:08.360
he wants.

00:21:08.360 --> 00:21:09.260
He has free reign.

00:21:09.260 --> 00:21:15.500
So I can write that using
this recursive call.

00:21:15.500 --> 00:21:16.280
OK.

00:21:16.280 --> 00:21:22.910
Similarly-- right.

00:21:26.450 --> 00:21:29.940
I'm getting the hang of this.

00:21:29.940 --> 00:21:32.330
Sorry, this is way too
entertaining for me.

00:21:32.330 --> 00:21:34.260
I can play with
this board all day.

00:21:34.260 --> 00:21:34.760
OK.

00:21:34.760 --> 00:21:39.665
So in case 2b, he goes out
today and he goes out tomorrow.

00:21:45.500 --> 00:21:46.020
OK?

00:21:46.020 --> 00:21:46.520
So--

00:21:46.520 --> 00:21:47.570
AUDIENCE: He's a party animal.

00:21:47.570 --> 00:21:49.070
JUSTIN SOLOMON:
He's a party animal.

00:21:49.070 --> 00:21:51.500
He is an animal and
he's going out a lot.

00:21:51.500 --> 00:21:53.300
Right, so in that
case, what happens?

00:21:53.300 --> 00:21:55.460
Well, he gets that.

00:21:55.460 --> 00:21:59.090
He gets today's utility.

00:21:59.090 --> 00:22:01.370
He gets tomorrow's utility.

00:22:04.410 --> 00:22:06.770
The day after, he
has to stay in,

00:22:06.770 --> 00:22:09.140
so we might as well skip it.

00:22:09.140 --> 00:22:14.790
And then he can do whatever
he wants the day after that.

00:22:14.790 --> 00:22:16.390
OK?

00:22:16.390 --> 00:22:20.580
So if we go back, I
guess, technically, we

00:22:20.580 --> 00:22:23.770
should revise our
definition of x a tiny bit,

00:22:23.770 --> 00:22:25.800
that it's not the maximum
of happiness-- well,

00:22:25.800 --> 00:22:27.925
we can convince ourselves
that it's the same thing.

00:22:27.925 --> 00:22:30.900
But really, it's not the maximum
happiness for day i through n.

00:22:30.900 --> 00:22:32.340
It's the maximum
happiness for day

00:22:32.340 --> 00:22:34.890
i through n under the
assumption that he has

00:22:34.890 --> 00:22:37.040
permission to go out on day i.

00:22:37.040 --> 00:22:37.540
Right?

00:22:37.540 --> 00:22:39.090
And that's really
what's going on

00:22:39.090 --> 00:22:42.010
in our recursive
set of calls here.

00:22:42.010 --> 00:22:42.510
OK.

00:22:42.510 --> 00:22:45.900
So does our recursion
make sense here?

00:22:45.900 --> 00:22:46.860
Cool.

00:22:46.860 --> 00:22:47.940
All right.

00:22:47.940 --> 00:22:49.930
So let's see here.

00:22:49.930 --> 00:22:51.865
So if we're following
our SRTBOT--

00:22:51.865 --> 00:22:54.240
I keep reviewing papers that
use the word paradigm a lot,

00:22:54.240 --> 00:22:56.110
so I feel like I should do that.

00:22:56.110 --> 00:22:57.510
So what is t?

00:22:57.510 --> 00:22:59.710
It's the topological order.

00:22:59.710 --> 00:23:08.060
Notice that x i only
depends on larger i's.

00:23:10.610 --> 00:23:12.187
So in terms of our
topological order,

00:23:12.187 --> 00:23:13.770
the dependence graph
is really simple.

00:23:13.770 --> 00:23:17.060
It's just a line,
so remember that you

00:23:17.060 --> 00:23:18.590
can think about
topological order

00:23:18.590 --> 00:23:20.475
or you can think about
being acyclic graph.

00:23:20.475 --> 00:23:21.350
Those are equivalent.

00:23:21.350 --> 00:23:22.790
We covered that in this course.

00:23:22.790 --> 00:23:25.820
I kind of like thinking
about acyclic graphs.

00:23:25.820 --> 00:23:29.240
So x1 depends on x2 depends
on x3 depends on x4.

00:23:29.240 --> 00:23:33.770
That graph has no
cycles, so we're good.

00:23:33.770 --> 00:23:35.150
Right.

00:23:35.150 --> 00:23:38.090
So next we have to
come up with our base

00:23:38.090 --> 00:23:40.130
case for our recursion.

00:23:40.130 --> 00:23:43.730
Notice that the way I have
chosen to solve this problem

00:23:43.730 --> 00:23:47.360
is by calling future
indices, which

00:23:47.360 --> 00:23:50.650
means that my base case
sits at the end of my array

00:23:50.650 --> 00:23:53.150
because that's sort of like the
lowest down on the recursion

00:23:53.150 --> 00:23:53.650
train.

00:23:53.650 --> 00:23:56.030
The recursion chain is
what I was going for,

00:23:56.030 --> 00:23:59.120
but I kind of like the
recursion train better.

00:23:59.120 --> 00:24:02.600
In particular, on day n--

00:24:02.600 --> 00:24:06.670
well, if he has permission
to go out on day n,

00:24:06.670 --> 00:24:07.970
he can do one of two things.

00:24:07.970 --> 00:24:09.137
He can either go out or not.

00:24:09.137 --> 00:24:10.780
It doesn't matter, right?

00:24:10.780 --> 00:24:16.220
So, in particular, we can
say that that's the max of 0

00:24:16.220 --> 00:24:17.675
or t of n.

00:24:17.675 --> 00:24:19.550
Remember, I didn't tell
you that temperatures

00:24:19.550 --> 00:24:21.770
have to be positive.

00:24:21.770 --> 00:24:24.800
Maybe he's a Celsius
kind of a beaver.

00:24:24.800 --> 00:24:26.610
OK.

00:24:26.610 --> 00:24:27.110
Right.

00:24:27.110 --> 00:24:31.070
And then in addition to the--

00:24:31.070 --> 00:24:33.053
for convenience,
notice that, like,

00:24:33.053 --> 00:24:35.470
there's a universe where I
look beyond the end of my array

00:24:35.470 --> 00:24:38.920
in my recursive call here, so
I should probably think about

00:24:38.920 --> 00:24:40.600
a few extra x's.

00:24:40.600 --> 00:24:43.390
Obviously, the utility of going
out on a day that doesn't exist

00:24:43.390 --> 00:24:44.890
is 0.

00:24:44.890 --> 00:24:52.270
So we can say that x n plus
1 equals x n plus 2 equals 0.

00:24:52.270 --> 00:24:53.440
OK.

00:24:53.440 --> 00:24:55.570
I've managed to use way
too much space for one

00:24:55.570 --> 00:24:57.210
simple algorithms problem.

00:25:00.770 --> 00:25:01.270
OK.

00:25:09.120 --> 00:25:10.460
Yeah?

00:25:10.460 --> 00:25:11.410
I get credit for that?

00:25:11.410 --> 00:25:12.940
OK.

00:25:12.940 --> 00:25:13.440
Right.

00:25:13.440 --> 00:25:16.430
So now we need to
do the o and the t.

00:25:16.430 --> 00:25:20.280
So what's our original problem?

00:25:20.280 --> 00:25:22.950
Well, remember that he wants to
maximize his happiness starting

00:25:22.950 --> 00:25:32.510
on day one, so our original
problem is just x of 1,

00:25:32.510 --> 00:25:33.680
or is it?

00:25:33.680 --> 00:25:36.140
So, remember that
Tim the Beaver--

00:25:36.140 --> 00:25:37.640
your instructor is
very sloppy when

00:25:37.640 --> 00:25:39.390
it comes to actually
reading the problems,

00:25:39.390 --> 00:25:41.630
as you saw at the beginning.

00:25:41.630 --> 00:25:43.940
A second mistake for which
I would have personally

00:25:43.940 --> 00:25:46.730
lost points were I to solve
this problem on my homework

00:25:46.730 --> 00:25:50.540
is that it didn't ask for just
the maximum amount of happiness

00:25:50.540 --> 00:25:52.370
that Tim could achieve--

00:25:52.370 --> 00:25:55.520
that's not very practical
for your everyday beaver--

00:25:55.520 --> 00:25:57.945
but rather, he wants to
know the actual plan.

00:25:57.945 --> 00:26:00.320
He wants to know what days he
can go out and what days he

00:26:00.320 --> 00:26:00.890
can't.

00:26:00.890 --> 00:26:01.460
Yeah?

00:26:01.460 --> 00:26:03.710
And I haven't actually told
you how to do that, right?

00:26:03.710 --> 00:26:05.085
I've only told
you how to compute

00:26:05.085 --> 00:26:09.660
x, which is just the
maximum amount of happiness.

00:26:09.660 --> 00:26:11.340
If I were you guys,
I think this is

00:26:11.340 --> 00:26:13.317
a perfectly reasonable
simplification that's

00:26:13.317 --> 00:26:14.650
like a warm up problem to solve.

00:26:14.650 --> 00:26:17.220
In fact, I would argue it's
less of a warm up and more

00:26:17.220 --> 00:26:18.642
the crux of the problem--

00:26:18.642 --> 00:26:20.100
and then going back
and making sure

00:26:20.100 --> 00:26:22.142
you can convince yourself
that you could actually

00:26:22.142 --> 00:26:24.960
reconstruct the solution.

00:26:24.960 --> 00:26:27.067
My way of solving this
was ever so slightly

00:26:27.067 --> 00:26:28.650
different from the
one in the problem,

00:26:28.650 --> 00:26:31.740
but they're equivalent,
which is to say

00:26:31.740 --> 00:26:33.332
I can make a second array--

00:26:33.332 --> 00:26:36.050
I won't write it down,
because I'm slow at writing--

00:26:36.050 --> 00:26:39.110
that just says on every day,
whether I took option 1, option

00:26:39.110 --> 00:26:41.712
2a, or option 2b.

00:26:41.712 --> 00:26:43.920
And now I can reconstruct
my plan very easily, right?

00:26:43.920 --> 00:26:48.330
So I look at x1, if I took
option 1, then I stay in

00:26:48.330 --> 00:26:50.580
and I look at day two.

00:26:50.580 --> 00:26:55.870
If I took option 2a, then I
can label today, tomorrow,

00:26:55.870 --> 00:26:56.720
and the day after.

00:26:56.720 --> 00:26:59.910
Oh, wait-- yeah, that's right.

00:26:59.910 --> 00:27:02.400
I can label today's choice,
tomorrow's choice, the day's

00:27:02.400 --> 00:27:05.460
after choice, and then
look three days later

00:27:05.460 --> 00:27:07.500
and recurse that way.

00:27:07.500 --> 00:27:10.260
Option b is kind of similar.

00:27:10.260 --> 00:27:13.432
So a reasonable way to
reconstruct the actual set

00:27:13.432 --> 00:27:15.390
of what days you go out
and what days you go in

00:27:15.390 --> 00:27:19.950
is just to remember, as you do
your memoization or whatever,

00:27:19.950 --> 00:27:22.140
whether you did
option 1, 2a, or 2b.

00:27:22.140 --> 00:27:24.420
And then it's pretty easy
to reconstruct from there.

00:27:24.420 --> 00:27:26.212
Maybe I'll let you guys
convince yourselves

00:27:26.212 --> 00:27:28.290
of that at home or
in the last 8 seconds

00:27:28.290 --> 00:27:31.530
if you happen to be the two
audience members that I have.

00:27:31.530 --> 00:27:36.760
And then, finally, we
need to do our time thing.

00:27:36.760 --> 00:27:38.478
And most of the
time arguments here

00:27:38.478 --> 00:27:40.020
follow more or less
the same pattern,

00:27:40.020 --> 00:27:41.610
which is you count the
number of subproblems

00:27:41.610 --> 00:27:44.027
and the time per subproblem,
you multiply those two things

00:27:44.027 --> 00:27:45.935
together, and you
get your runtime.

00:27:45.935 --> 00:27:47.310
We're going to
see in one problem

00:27:47.310 --> 00:27:49.920
on this problem set that's
not quite right because we

00:27:49.920 --> 00:27:52.260
have to account for
some precomputation.

00:27:52.260 --> 00:27:53.910
But in this case, it is.

00:27:57.220 --> 00:27:59.752
Right, so let's see, what
are our subproblems here?

00:27:59.752 --> 00:28:01.960
Well, essentially-- I guess
I didn't actually say it,

00:28:01.960 --> 00:28:06.210
but you have to take the
max of these three values.

00:28:06.210 --> 00:28:08.130
This is the max of
three expressions which

00:28:08.130 --> 00:28:10.380
have a constant number
of plus signs and lookups

00:28:10.380 --> 00:28:12.610
and memory and all
that good stuff.

00:28:12.610 --> 00:28:21.310
So each subproblem
takes order one time.

00:28:21.310 --> 00:28:23.300
How many problems are there?

00:28:23.300 --> 00:28:26.830
Well, there's, I
guess, n plus 2 max,

00:28:26.830 --> 00:28:29.080
if you want to be
conservative about it.

00:28:29.080 --> 00:28:34.750
So, in particular, there's
order n subproblems, right?

00:28:34.750 --> 00:28:37.210
So all I have to do is multiply
these two things together,

00:28:37.210 --> 00:28:40.880
and my algorithm
takes order n time.

00:28:43.610 --> 00:28:47.730
And that's our solution
to problem number one.

00:28:47.730 --> 00:28:49.620
Any questions so far?

00:28:49.620 --> 00:28:50.120
Yes?

00:28:50.120 --> 00:28:51.552
Uh-oh.

00:28:51.552 --> 00:28:54.010
AUDIENCE: When I was thinking
about the problem beforehand,

00:28:54.010 --> 00:28:57.450
I was wondering could
you use base cases--

00:28:57.450 --> 00:29:00.590
right now, we have two
different kinds of base case,

00:29:00.590 --> 00:29:05.130
a base case for x of n and a
base case for things after.

00:29:05.130 --> 00:29:08.280
Can I remove the first
one and add an x of n

00:29:08.280 --> 00:29:10.740
plus 3 equals 0 as well?

00:29:10.740 --> 00:29:11.997
What would that do?

00:29:11.997 --> 00:29:13.830
JUSTIN SOLOMON: Could
I remove the first one

00:29:13.830 --> 00:29:16.930
and add an x of n plus 3?

00:29:16.930 --> 00:29:19.960
Yeah, I guess that's fine.

00:29:19.960 --> 00:29:22.270
I'm sorry, that's not a
particularly helpful answer

00:29:22.270 --> 00:29:24.340
for the people
watching on video.

00:29:24.340 --> 00:29:28.150
My answer to this question
you can't hear is yes.

00:29:28.150 --> 00:29:33.550
So the question, to repeat,
was this base case was somehow

00:29:33.550 --> 00:29:35.350
kind of complicated-looking.

00:29:35.350 --> 00:29:36.970
To be fair, it's
the one that I was

00:29:36.970 --> 00:29:40.420
given in [INAUDIBLE]
assignment, but that's OK.

00:29:40.420 --> 00:29:43.540
But the question was is
this truly necessary.

00:29:43.540 --> 00:29:46.270
In particular, can I
get rid of the x n case

00:29:46.270 --> 00:29:50.690
and instead add a third
day past the end of time,

00:29:50.690 --> 00:29:52.600
which also has value 0?

00:29:52.600 --> 00:29:59.640
And if you, kind of, look at
that plus case b, I think--

00:29:59.640 --> 00:30:00.807
or rather, case a--

00:30:00.807 --> 00:30:02.640
think you can convince--
well, case a and b,

00:30:02.640 --> 00:30:04.973
for that matter-- you can
convince yourselves that these

00:30:04.973 --> 00:30:05.970
are equivalent, right?

00:30:05.970 --> 00:30:06.970
That's absolutely right.

00:30:06.970 --> 00:30:11.100
So I could add a third day after
the end of this thing, which

00:30:11.100 --> 00:30:12.570
also has value 0.

00:30:12.570 --> 00:30:16.260
Or, by the way, I could just
say in my code if n is--

00:30:16.260 --> 00:30:18.390
if i is bigger than n, return 0.

00:30:18.390 --> 00:30:21.472
That's the same thing.

00:30:21.472 --> 00:30:22.930
Yeah, and then I
guess I don't have

00:30:22.930 --> 00:30:24.360
to worry about that x n case.

00:30:24.360 --> 00:30:26.610
Yeah, these are the same.

00:30:26.610 --> 00:30:28.740
To each their own.

00:30:28.740 --> 00:30:29.620
Fabulous question.

00:30:29.620 --> 00:30:34.030
Any others that I can
answer while we're at it?

00:30:34.030 --> 00:30:35.010
Cool.

00:30:35.010 --> 00:30:35.510
All right.

00:30:35.510 --> 00:30:36.427
So that's problem one.

00:30:39.016 --> 00:30:41.980
Writing too big-- I don't
like this big chalk, you know.

00:30:41.980 --> 00:30:42.480
OK.

00:30:42.480 --> 00:30:44.362
So problem two is the
one that got me all hot

00:30:44.362 --> 00:30:45.320
and bothered yesterday.

00:30:45.320 --> 00:30:47.880
So let's see if we do any
better in front of people,

00:30:47.880 --> 00:30:50.010
because that's usually
the best way to improve

00:30:50.010 --> 00:30:52.230
a problem solving skill.

00:30:52.230 --> 00:30:53.280
Right.

00:30:53.280 --> 00:30:56.430
So in problem two,
which, annoyingly,

00:30:56.430 --> 00:30:58.860
is also probably the
most practical problem

00:30:58.860 --> 00:31:00.240
on this problem set.

00:31:00.240 --> 00:31:02.162
Essentially, you have a--

00:31:02.162 --> 00:31:03.870
I suppose I should
write some stuff down.

00:31:06.450 --> 00:31:07.770
So in problem--

00:31:07.770 --> 00:31:10.410
I used the wrong side--

00:31:10.410 --> 00:31:16.090
two, you have an
operating system Menix--

00:31:16.090 --> 00:31:19.864
whatever-- which is--

00:31:19.864 --> 00:31:21.442
apparently, it's very simple.

00:31:21.442 --> 00:31:23.170
AUDIENCE: Menix, Unix.

00:31:23.170 --> 00:31:24.478
JUSTIN SOLOMON: Oh, I get it.

00:31:24.478 --> 00:31:27.950
[LAUGHS] It doesn't
mean I have to like it.

00:31:27.950 --> 00:31:28.450
Right.

00:31:28.450 --> 00:31:35.830
[LAUGHS] So, in
Menix, apparently,

00:31:35.830 --> 00:31:37.840
the only thing that my
operating system can do

00:31:37.840 --> 00:31:41.590
is compute edit
distance between files.

00:31:41.590 --> 00:31:43.730
And it wants to
do so efficiently.

00:31:43.730 --> 00:31:50.315
So we have that a file
is a sequence of strings.

00:31:54.940 --> 00:31:57.840
And I believe we
say their length is

00:31:57.840 --> 00:31:59.310
less than or equal to k.

00:31:59.310 --> 00:32:02.940
That's going to come into
play a little bit later.

00:32:02.940 --> 00:32:05.100
And the strings are
basically just lines

00:32:05.100 --> 00:32:08.020
of the different files.

00:32:08.020 --> 00:32:13.103
So there's three different
ways that we can change a file.

00:32:13.103 --> 00:32:14.520
So here are the
changes we can do.

00:32:18.030 --> 00:32:20.760
Change number 1
is to add a line.

00:32:23.390 --> 00:32:26.780
Change number 2 is
to remove a line.

00:32:29.730 --> 00:32:34.590
And change number 3 is to swap.

00:32:34.590 --> 00:32:40.170
But a caveat for this
interesting model

00:32:40.170 --> 00:32:45.390
of what's cheap and what's
not is that, apparently,

00:32:45.390 --> 00:32:48.150
swapping two lines is cheap
because they exist in memory.

00:32:48.150 --> 00:32:50.910
Like, maybe I'm, I don't
know, using a linked

00:32:50.910 --> 00:32:53.160
list or something
to store files,

00:32:53.160 --> 00:32:56.520
and so swapping two
pointers isn't so bad.

00:32:56.520 --> 00:32:58.320
But inserting and
removing a line

00:32:58.320 --> 00:33:01.140
is hard because, I don't know,
memory allocation is expensive,

00:33:01.140 --> 00:33:04.740
like Menix is actually
operating on clay tablets.

00:33:04.740 --> 00:33:08.940
And I can chop my clay
tablets into different slices

00:33:08.940 --> 00:33:11.880
and just pick them up and
swap them, and that's fine,

00:33:11.880 --> 00:33:13.530
but if I want to add
a line in my file,

00:33:13.530 --> 00:33:17.810
I have to go to the Tigris and
Euphrates and pull out the--

00:33:17.810 --> 00:33:20.280
or whatever it was,
the Eugris and the

00:33:20.280 --> 00:33:23.660
Tiphrates-- and
pull out a stone.

00:33:23.660 --> 00:33:27.960
It's a lot of work to make
a new line or to dispose.

00:33:27.960 --> 00:33:35.680
So these are expensive
and this is cheap.

00:33:35.680 --> 00:33:38.920
And so the question
that I'm trying to sa--

00:33:38.920 --> 00:33:41.890
that I'm trying to say and that
the problem is trying to ask

00:33:41.890 --> 00:33:52.800
is that you are given files
A and B with n lines each.

00:33:57.680 --> 00:34:03.710
We want to know what the minimum
number of non-swap operations

00:34:03.710 --> 00:34:05.890
it'll take, and
so, in other words,

00:34:05.890 --> 00:34:08.780
the minimum number of time for
you to add and remove lines

00:34:08.780 --> 00:34:20.300
to transform A into B,
essentially, with low cost.

00:34:23.040 --> 00:34:25.920
And, in fact, just to be nice--

00:34:25.920 --> 00:34:29.460
I think it's actually kind of a
critical hint in this problem--

00:34:29.460 --> 00:34:32.190
we give you the runtime.

00:34:32.190 --> 00:34:34.273
And I'm going to, kind of,
ignore it in my answer,

00:34:34.273 --> 00:34:36.398
notice that I did something
wrong, and then go back

00:34:36.398 --> 00:34:36.969
and fix it.

00:34:36.969 --> 00:34:38.400
This is different from the
way the answer is written,

00:34:38.400 --> 00:34:41.463
where god came in and said,
like, oh, we observe that we're

00:34:41.463 --> 00:34:42.880
probably going to
need this thing,

00:34:42.880 --> 00:34:44.520
so we're going to go
ahead and do it here.

00:34:44.520 --> 00:34:46.770
I think that's, maybe, not
representative of the logic

00:34:46.770 --> 00:34:48.150
here.

00:34:48.150 --> 00:34:53.250
Right, so the runtime here
is k n plus n squared.

00:34:53.250 --> 00:34:57.330
The first thing to note
is there is a k here.

00:34:57.330 --> 00:35:02.480
Yeah, and so someday we're going
to have to compare strings,

00:35:02.480 --> 00:35:03.980
because that's what k is.

00:35:03.980 --> 00:35:05.408
And I think that's
the hint that's

00:35:05.408 --> 00:35:06.450
implicit in this problem.

00:35:06.450 --> 00:35:07.940
It's easy to miss.

00:35:07.940 --> 00:35:10.280
And so, indeed, what
we're going to notice

00:35:10.280 --> 00:35:11.863
is we're going to
look at our solution

00:35:11.863 --> 00:35:14.720
and say, well, wait a second, if
we didn't incur a factor of k,

00:35:14.720 --> 00:35:16.850
we must have done
something wrong.

00:35:16.850 --> 00:35:18.890
And, indeed, that's
going to be the case,

00:35:18.890 --> 00:35:23.942
but it's only a minor
fix to change it.

00:35:23.942 --> 00:35:25.900
AUDIENCE: There's another
important distinction

00:35:25.900 --> 00:35:26.850
on this [INAUDIBLE].

00:35:26.850 --> 00:35:28.100
JUSTIN SOLOMON: Oh, I'm sorry.

00:35:28.100 --> 00:35:35.006
Yeah, right, when I swap things,
they have to be adjacent.

00:35:35.006 --> 00:35:38.570
I can't write at the
bottom of the board.

00:35:38.570 --> 00:35:41.893
That's supposed to be a, d,
j, for those watching at home.

00:35:41.893 --> 00:35:43.310
But they have to
be-- you can only

00:35:43.310 --> 00:35:45.800
swap lines that are
adjacent, as they

00:35:45.800 --> 00:35:47.668
appear in their original file.

00:35:47.668 --> 00:35:50.210
I'll say it out loud rather than
try and write it because you

00:35:50.210 --> 00:35:52.460
it's going to take the rest
of the lecture to do that.

00:35:52.460 --> 00:35:56.237
OK, any other things
I've forgotten?

00:35:56.237 --> 00:35:57.320
There's a high likelihood.

00:35:57.320 --> 00:35:58.970
I'm bad at this.

00:35:58.970 --> 00:35:59.510
OK.

00:35:59.510 --> 00:36:02.870
So this one was annoying.

00:36:02.870 --> 00:36:04.650
And it's not actually annoying.

00:36:04.650 --> 00:36:07.730
It's actually a relatively easy
instance of a very well-known

00:36:07.730 --> 00:36:11.780
dynamic program plus a tiny
bit of additional stuff, which

00:36:11.780 --> 00:36:13.660
is called edit distance.

00:36:13.660 --> 00:36:15.910
In fact, I think if you guys
are looking for intuition

00:36:15.910 --> 00:36:18.380
on this problem,
you might google

00:36:18.380 --> 00:36:21.847
that one first as, sort of, a--

00:36:21.847 --> 00:36:22.430
what was that?

00:36:22.430 --> 00:36:23.120
AUDIENCE: [INAUDIBLE]

00:36:23.120 --> 00:36:24.320
JUSTIN SOLOMON: Oh, in fact
you're doing a recitation.

00:36:24.320 --> 00:36:26.690
Oh, that's why it's not
totally unreasonable to come

00:36:26.690 --> 00:36:29.185
up with the answer
here, even better.

00:36:29.185 --> 00:36:30.560
But even if you
hadn't, you know,

00:36:30.560 --> 00:36:32.820
this is just another
dynamic programming problem

00:36:32.820 --> 00:36:35.450
that's just a little
bit more annoying

00:36:35.450 --> 00:36:38.720
than your average dynamic
programming problem.

00:36:38.720 --> 00:36:41.180
Now, the solution written
out in the course notes

00:36:41.180 --> 00:36:44.480
works from, sort of, the
last line of the file

00:36:44.480 --> 00:36:47.210
downward, in some sense--

00:36:47.210 --> 00:36:51.230
upward, whatever.

00:36:51.230 --> 00:36:53.240
I, like, literally lost
two hours of my life

00:36:53.240 --> 00:36:56.330
trying to think about
editing files from the end up

00:36:56.330 --> 00:36:58.768
and just getting myself
all upset and confused.

00:36:58.768 --> 00:37:01.310
So here, I'm going to attempt
to do it in the other direction

00:37:01.310 --> 00:37:04.170
and probably introduce a bunch
of mistakes in the process.

00:37:04.170 --> 00:37:06.975
So what do we do in
dynamic programming

00:37:06.975 --> 00:37:08.350
if we don't know
what else to do?

00:37:08.350 --> 00:37:12.040
We do sort stuff, SRTBOT.

00:37:12.040 --> 00:37:13.910
And so let's do that here.

00:37:13.910 --> 00:37:17.110
So, in particular, what
are our subproblems?

00:37:17.110 --> 00:37:19.902
This is a little bit funky.

00:37:19.902 --> 00:37:21.860
So actually, even before
we do the S of SRTBOT,

00:37:21.860 --> 00:37:23.652
let's think about our
problem a little bit.

00:37:26.000 --> 00:37:27.920
Let's think about
what it actually

00:37:27.920 --> 00:37:30.380
means to edit a
file because this

00:37:30.380 --> 00:37:33.500
is what helped me think
about the right answer

00:37:33.500 --> 00:37:35.558
here, which is to
say, you know--

00:37:35.558 --> 00:37:36.350
so what's going on?

00:37:36.350 --> 00:37:38.570
I have, like, two documents.

00:37:38.570 --> 00:37:43.370
This is document A. This is
document B. Each one of them

00:37:43.370 --> 00:37:46.130
is composed of a bunch of lines.

00:37:46.130 --> 00:37:47.930
And I'm basically
trying to turn A into B.

00:37:47.930 --> 00:37:51.260
And the only thing I can
do is scroll out of line,

00:37:51.260 --> 00:37:54.110
insert, just hit the Enter
key, or do a third thing

00:37:54.110 --> 00:37:56.423
where I kind of like
swap two things that

00:37:56.423 --> 00:37:57.590
are adjacent to one another.

00:37:57.590 --> 00:37:59.980
That is the only thing I can do.

00:37:59.980 --> 00:38:03.553
And the way I like to
think about this problem--

00:38:03.553 --> 00:38:04.970
there's kind of
an annoyance here,

00:38:04.970 --> 00:38:06.550
which I think is a
typical annoyance

00:38:06.550 --> 00:38:08.133
in dynamic programming
problems, which

00:38:08.133 --> 00:38:12.900
is that the order of operations
suggests that this problem is

00:38:12.900 --> 00:38:16.050
a lot, combinatorially, more
difficult than it is, because,

00:38:16.050 --> 00:38:16.832
like--

00:38:16.832 --> 00:38:19.290
OK, let's think about how I
actually edit documents-- like,

00:38:19.290 --> 00:38:22.080
I spend 2/3 of my day editing
bad grad student writing--

00:38:22.080 --> 00:38:24.900
is like I'm jumping all over the
place between different lines.

00:38:24.900 --> 00:38:26.460
Like, first I delete
this line, then

00:38:26.460 --> 00:38:28.085
maybe I go to the
bottom of my document

00:38:28.085 --> 00:38:29.220
and delete some other one.

00:38:29.220 --> 00:38:32.430
That would be a big problem
from a dynamic programming

00:38:32.430 --> 00:38:33.120
perspective.

00:38:33.120 --> 00:38:35.070
I can't jump all
over my document,

00:38:35.070 --> 00:38:37.950
because keeping track of
that whole edit history

00:38:37.950 --> 00:38:41.620
is going to be somehow
combinatorially ginormous.

00:38:41.620 --> 00:38:42.120
Right?

00:38:42.120 --> 00:38:45.120
I'm not the Track Changes
button in Microsoft Word.

00:38:45.120 --> 00:38:47.910
I want the minimum
number of changes.

00:38:47.910 --> 00:38:51.030
And if I have to recurse
over all possible edits

00:38:51.030 --> 00:38:53.070
to every single
line in any order,

00:38:53.070 --> 00:38:54.750
that's an awful
lot of factorials

00:38:54.750 --> 00:38:57.240
and 2 to the n's floating around
that I don't want to have.

00:38:57.240 --> 00:38:57.740
Right?

00:38:57.740 --> 00:39:01.320
And so that's the sort of
crux of the challenge here,

00:39:01.320 --> 00:39:05.670
is to organize my approach
to editing these files

00:39:05.670 --> 00:39:07.890
in a way that doesn't
require me to have

00:39:07.890 --> 00:39:11.088
to do this sort of combinatorial
jumping all over the place.

00:39:11.088 --> 00:39:13.380
And I think it's also the
one where there's a sort of--

00:39:13.380 --> 00:39:15.088
like I know Jerry
Caine at Stanford talks

00:39:15.088 --> 00:39:18.480
a lot about the
recursive leap of faith.

00:39:18.480 --> 00:39:20.370
Like, somehow
dividing your problem

00:39:20.370 --> 00:39:22.290
into organized
subproblems, that's

00:39:22.290 --> 00:39:25.690
really where the
challenge lives here.

00:39:25.690 --> 00:39:28.990
So if I were a more
organized PhD advisor,

00:39:28.990 --> 00:39:33.990
the way that I would edit
a file, or a clay tablet,

00:39:33.990 --> 00:39:37.540
I guess, in this case,
would be linearly,

00:39:37.540 --> 00:39:39.480
that I might as well
do whatever the heck

00:39:39.480 --> 00:39:42.960
I'm going to do to line one
before I move on the line two.

00:39:42.960 --> 00:39:45.202
And at the end of the
day, even if I did stuff

00:39:45.202 --> 00:39:47.160
in a different order,
you can convince yourself

00:39:47.160 --> 00:39:48.630
that I could always
order it in such a way

00:39:48.630 --> 00:39:50.588
that all the edits that
I do to the first line,

00:39:50.588 --> 00:39:54.920
kind of, happen before
lines later in the document,

00:39:54.920 --> 00:39:57.980
with the possible exception
of this swap thing.

00:39:57.980 --> 00:40:00.440
But we'll see that
somehow doesn't matter.

00:40:00.440 --> 00:40:03.730
And, moreover, if
I do an edit, I

00:40:03.730 --> 00:40:07.300
might as well do the edit to
make things better, right?

00:40:07.300 --> 00:40:09.640
There's no reason to start
willy-nilly inserting

00:40:09.640 --> 00:40:11.680
and removing lines.

00:40:11.680 --> 00:40:15.890
I might as well always do an
operation that improves stuff.

00:40:15.890 --> 00:40:19.656
And so thinking about that
sort of logic leads me--

00:40:19.656 --> 00:40:23.260
ta-da-- to a particular
way that I might write down

00:40:23.260 --> 00:40:26.262
my S, my some
problems here, which

00:40:26.262 --> 00:40:28.720
is to say that I'm going to
think about editing my document

00:40:28.720 --> 00:40:31.000
line by line.

00:40:31.000 --> 00:40:33.810
So, in other words, once
I've dealt with line one,

00:40:33.810 --> 00:40:36.330
meaning that I found
some way to mess with it

00:40:36.330 --> 00:40:39.170
and make it match line
one of the other guy,

00:40:39.170 --> 00:40:41.570
I'm just going to
think about removing it

00:40:41.570 --> 00:40:44.190
and then think about the
rest of the document.

00:40:44.190 --> 00:40:47.210
You start saying, aha, that
sentence sounds like recursion.

00:40:47.210 --> 00:40:47.930
And that's right.

00:40:47.930 --> 00:40:49.620
That's how we're going
to solve this problem.

00:40:49.620 --> 00:40:50.180
OK?

00:40:50.180 --> 00:40:53.033
So, in particular, here's
going to be our thing.

00:40:53.033 --> 00:40:55.450
I'm going to do a slightly
different one in the solution--

00:40:55.450 --> 00:40:57.830
so you guys should
all be vigilant--

00:40:57.830 --> 00:41:06.470
which is I'm going to write x ij
to be the min work to convert.

00:41:11.000 --> 00:41:15.560
I'm not a Python programmer,
but hopefully I got this right.

00:41:15.560 --> 00:41:18.710
i colon is going to
be everything from i

00:41:18.710 --> 00:41:20.730
to the end of the file.

00:41:20.730 --> 00:41:26.310
So in other words, this is the
suffix version of our problem--

00:41:26.310 --> 00:41:36.600
and into B j colon, like that.

00:41:36.600 --> 00:41:37.680
OK.

00:41:37.680 --> 00:41:39.780
So, in other words,
I have a little--

00:41:39.780 --> 00:41:42.570
it's kind of like a video--
like, think about Tetris.

00:41:42.570 --> 00:41:44.288
Once you get that
full line of blocks,

00:41:44.288 --> 00:41:46.080
you can just throw that
line of blocks away

00:41:46.080 --> 00:41:47.850
and the whole video
game moves down.

00:41:47.850 --> 00:41:48.990
There's somehow
something very similar

00:41:48.990 --> 00:41:50.615
going on here, which
is the second I've

00:41:50.615 --> 00:41:52.710
managed to get a match
for line one of document

00:41:52.710 --> 00:41:54.810
into line one of
the next document,

00:41:54.810 --> 00:41:58.230
I'm just going to throw
it away and pretend

00:41:58.230 --> 00:42:01.500
like I have two documents
with one less line in them.

00:42:01.500 --> 00:42:05.152
Now, the thing that got
me all hung up last night,

00:42:05.152 --> 00:42:07.360
my original problem assumes
that both of my documents

00:42:07.360 --> 00:42:09.600
have the same length.

00:42:09.600 --> 00:42:12.840
But here, I'm not making
that assumption, right?

00:42:12.840 --> 00:42:15.030
And, essentially, what
we're going to figure out

00:42:15.030 --> 00:42:17.072
is that that actually
doesn't matter a whole lot,

00:42:17.072 --> 00:42:20.340
that if I end up with one
document of length k--

00:42:20.340 --> 00:42:21.750
well, I shouldn't use k--

00:42:21.750 --> 00:42:25.380
one document of length l and
another document of length 0,

00:42:25.380 --> 00:42:27.850
what's the amount of work
that I should do to convert?

00:42:27.850 --> 00:42:33.300
Well, l, because my only choice
is to insert a bunch of lines

00:42:33.300 --> 00:42:36.785
in one document, by the way,
or delete a bunch of lines

00:42:36.785 --> 00:42:37.410
from the other.

00:42:37.410 --> 00:42:38.660
Those are dual to one another.

00:42:38.660 --> 00:42:40.290
They're exactly the same.

00:42:40.290 --> 00:42:43.050
I'm philosophizing a lot because
I'm also convincing myself

00:42:43.050 --> 00:42:45.420
that my answer is
OK in the process.

00:42:45.420 --> 00:42:46.930
OK.

00:42:46.930 --> 00:42:49.080
So this is going to be
our set subproblems.

00:42:49.080 --> 00:42:53.070
And now we have to
do the r, right?

00:42:53.070 --> 00:42:57.770
We have to relate, something
we struggle with in the math

00:42:57.770 --> 00:43:00.020
department sometimes.

00:43:00.020 --> 00:43:03.230
And, essentially, the way
that I went about this

00:43:03.230 --> 00:43:05.720
is to just do a
billion different cases

00:43:05.720 --> 00:43:08.600
of all the possible edits that
I could do to line i and line j.

00:43:08.600 --> 00:43:10.350
And that's perfectly
fine in this problem.

00:43:10.350 --> 00:43:11.870
I think the problem
is a little slick.

00:43:11.870 --> 00:43:13.500
And the way that they're
written the solution,

00:43:13.500 --> 00:43:15.020
they've convinced themselves
that some things are

00:43:15.020 --> 00:43:16.743
equivalent to others
and removed them.

00:43:16.743 --> 00:43:17.660
But you don't have to.

00:43:17.660 --> 00:43:19.160
As long as there's
a constant number

00:43:19.160 --> 00:43:22.610
of cases, your golden Ponyboy.

00:43:22.610 --> 00:43:25.770
So, in particular, let's
think about some cases.

00:43:25.770 --> 00:43:32.040
So first of all, if line i
matches line j of my document--

00:43:32.040 --> 00:43:33.650
remember that it's
not really line j.

00:43:33.650 --> 00:43:35.450
It's like making a
document that just

00:43:35.450 --> 00:43:37.930
happens to start at line j.

00:43:37.930 --> 00:43:39.600
It's like taking scissors.

00:43:39.600 --> 00:43:42.170
Well, then I can match
them with zero-cost

00:43:42.170 --> 00:43:44.600
because the beginnings
are in the same place.

00:43:44.600 --> 00:43:46.850
And I can move my
Tetris came down one,

00:43:46.850 --> 00:43:48.752
and that's perfectly fine.

00:43:48.752 --> 00:43:50.460
So case one, I think,
is the easiest one,

00:43:50.460 --> 00:43:58.680
which is if A i equals
B j, then I can just

00:43:58.680 --> 00:44:00.510
remove that line
from both documents

00:44:00.510 --> 00:44:02.920
and move forward,
in which case--

00:44:02.920 --> 00:44:04.635
I'll use my same
goofy notation--

00:44:04.635 --> 00:44:05.760
I'm going to get that x ij.

00:44:08.290 --> 00:44:10.340
Well, I'm going to
just increment i and j

00:44:10.340 --> 00:44:15.560
and keep going, like that.

00:44:15.560 --> 00:44:17.380
Cool?

00:44:17.380 --> 00:44:20.260
So what's something
else I could do?

00:44:20.260 --> 00:44:22.040
I could delete a line.

00:44:22.040 --> 00:44:23.713
Yeah, so what happens--

00:44:27.270 --> 00:44:28.650
OK.

00:44:28.650 --> 00:44:36.210
So case two is
delete A i, right?

00:44:36.210 --> 00:44:38.498
That's a different thing
I can do the line i.

00:44:38.498 --> 00:44:39.790
Well, now what do I have to do?

00:44:39.790 --> 00:44:41.450
I have a document on
the left-hand side,

00:44:41.450 --> 00:44:42.450
which is 1 line shorter.

00:44:42.450 --> 00:44:44.590
And on the right-hand
side, nothing changed.

00:44:44.590 --> 00:44:47.920
But deleting a line
cost me a dollar.

00:44:47.920 --> 00:44:53.020
So, in particular,
I have that x ij.

00:44:53.020 --> 00:44:53.890
Well, what happens?

00:44:53.890 --> 00:45:02.800
Well, I got rid of one
line, but I had to pay.

00:45:02.800 --> 00:45:03.310
OK.

00:45:03.310 --> 00:45:05.740
Let's think about
some other things.

00:45:05.740 --> 00:45:07.570
You could delete B j.

00:45:10.693 --> 00:45:12.360
This case actually
isn't in the solution

00:45:12.360 --> 00:45:14.745
because it turns out
to be unnecessary.

00:45:14.745 --> 00:45:16.620
AUDIENCE: Well, we're
only allowed to edit A.

00:45:16.620 --> 00:45:18.180
JUSTIN SOLOMON: Oh, I'm
only allowed to edit A?

00:45:18.180 --> 00:45:20.160
Oh, in that case, I
don't have to delete B j.

00:45:20.160 --> 00:45:22.202
I really didn't read these
problems very closely.

00:45:22.202 --> 00:45:23.260
That's my bad.

00:45:23.260 --> 00:45:24.760
This would have
made it much easier.

00:45:24.760 --> 00:45:27.770
I really should
read these things.

00:45:27.770 --> 00:45:30.670
Cool, so that eliminates half
of the cases on my notes.

00:45:30.670 --> 00:45:31.960
Fabulous.

00:45:31.960 --> 00:45:35.430
Incidentally, you could do these
things on the other direction

00:45:35.430 --> 00:45:38.830
and it really wouldn't change
this problem a whole lot.

00:45:38.830 --> 00:45:40.600
Sorry, you know, I
have this bad habit

00:45:40.600 --> 00:45:43.030
when I'm reading research papers
of reading the research paper I

00:45:43.030 --> 00:45:44.590
wanted to be there
instead of the one

00:45:44.590 --> 00:45:46.210
that's actually on the paper.

00:45:46.210 --> 00:45:48.980
And, somehow, it's very
similar phenomenon here.

00:45:48.980 --> 00:45:49.480
OK.

00:45:49.480 --> 00:45:49.980
Right.

00:45:49.980 --> 00:45:50.810
So, great.

00:45:50.810 --> 00:45:52.330
So I can only edit
document A, which

00:45:52.330 --> 00:45:55.510
makes this probably easier
than what I was worried about.

00:45:55.510 --> 00:45:56.110
Fabulous.

00:45:56.110 --> 00:46:00.400
In that case-- ah, bananas.

00:46:00.400 --> 00:46:05.670
With our third case
here, well, let's see,

00:46:05.670 --> 00:46:10.140
I could also insert a line.

00:46:10.140 --> 00:46:10.640
Let's see.

00:46:10.640 --> 00:46:12.120
So what ends up happening there?

00:46:12.120 --> 00:46:14.783
So I can only edit document A?

00:46:14.783 --> 00:46:16.700
So that makes my cases
different than the ones

00:46:16.700 --> 00:46:17.742
I wrote down on my notes.

00:46:24.506 --> 00:46:25.410
Sorry.

00:46:25.410 --> 00:46:25.910
OK.

00:46:36.270 --> 00:46:36.770
OK.

00:46:36.770 --> 00:46:38.198
So if I insert--

00:46:38.198 --> 00:46:38.990
let's do this live.

00:46:38.990 --> 00:46:42.551
Yeah, OK, so if I
insert a line at line i,

00:46:42.551 --> 00:46:44.930
I might as well
make it match B j.

00:46:44.930 --> 00:46:46.430
There's no reason not to.

00:46:46.430 --> 00:46:47.030
Right?

00:46:47.030 --> 00:46:49.980
I might as well kill off one
element of B while I'm at it.

00:46:49.980 --> 00:46:50.480
Yeah?

00:46:50.480 --> 00:46:53.520
So if I do that, what
ends up happening?

00:46:53.520 --> 00:46:55.520
Well, I still have
to match line i.

00:46:55.520 --> 00:46:57.650
I've just, kind of, moved
it lower in my file.

00:46:57.650 --> 00:47:01.730
But I've, in essence,
killed one line in file B

00:47:01.730 --> 00:47:04.613
by making it match this
new line that I inserted.

00:47:04.613 --> 00:47:06.530
In my notes, because I
thought I could edit B,

00:47:06.530 --> 00:47:08.720
I said, OK, I can just
delete the line in B instead.

00:47:08.720 --> 00:47:11.303
And somehow, logically, that's
a little easier to think about.

00:47:11.303 --> 00:47:13.830
But these are exactly
dual to one another.

00:47:13.830 --> 00:47:17.540
So, in that case, I have x ij.

00:47:17.540 --> 00:47:19.100
Well, I still have
to deal with A i.

00:47:19.100 --> 00:47:20.225
I haven't gotten rid of it.

00:47:20.225 --> 00:47:22.130
But I've matched line j.

00:47:22.130 --> 00:47:27.740
So I paid $1 for
inserting a line.

00:47:27.740 --> 00:47:30.890
And now I have that
because I've gotten rid

00:47:30.890 --> 00:47:33.978
of a line in the other file.

00:47:33.978 --> 00:47:36.520
If I stopped here, by the way,
I would have it at a distance.

00:47:36.520 --> 00:47:40.000
But, unfortunately for me,
I have one additional case,

00:47:40.000 --> 00:47:46.420
which is mild irritant, as they
say, which is that I can swap.

00:47:49.710 --> 00:47:52.930
First of all, can I always swap?

00:47:52.930 --> 00:47:55.230
I mean, I can, but
if I swap two lines

00:47:55.230 --> 00:47:57.730
and they still don't match the
lines on the right-hand side,

00:47:57.730 --> 00:47:59.870
I'm kind of hosed, right,
because you can convince

00:47:59.870 --> 00:48:01.328
yourself that in
the next step, I'm

00:48:01.328 --> 00:48:03.520
going to have to delete
something anyway.

00:48:03.520 --> 00:48:04.518
Swapping was free.

00:48:04.518 --> 00:48:07.060
If I swap and delete, that's
the same thing as just deleting,

00:48:07.060 --> 00:48:09.160
so it doesn't really matter.

00:48:09.160 --> 00:48:10.630
So, in particular,
what that means

00:48:10.630 --> 00:48:13.270
is I might as well only
check the swap if it actually

00:48:13.270 --> 00:48:14.080
helps me.

00:48:14.080 --> 00:48:14.830
Yeah?

00:48:14.830 --> 00:48:20.692
So, in other words,
if I have A--

00:48:20.692 --> 00:48:23.240
now you have to be a little bit
careful because I'm swapping.

00:48:23.240 --> 00:48:28.030
So if the next guy in A
equals B, the current guy in B

00:48:28.030 --> 00:48:36.260
and the current guy in A
equals the next guy in B. Well,

00:48:36.260 --> 00:48:39.560
now I can swap this guy and
kill off two lines in my files

00:48:39.560 --> 00:48:40.850
while I'm at it, right?

00:48:40.850 --> 00:48:46.190
So, in this case,
I get that X ij.

00:48:46.190 --> 00:48:48.050
Well, swapping doesn't
cost me anything,

00:48:48.050 --> 00:48:49.560
and I killed off two things.

00:48:49.560 --> 00:48:56.663
So that's the recursion.

00:48:56.663 --> 00:48:58.580
So if I were to write
this out on my homework,

00:48:58.580 --> 00:48:59.450
what should I do?

00:48:59.450 --> 00:49:01.610
Well, I shouldn't-- I mean,
probably if you use this error

00:49:01.610 --> 00:49:03.260
notation, I don't think
it would be a big deal.

00:49:03.260 --> 00:49:04.730
But really, you
should add a line

00:49:04.730 --> 00:49:07.010
at the bottom saying
that I can choose

00:49:07.010 --> 00:49:08.130
to do any of these things.

00:49:08.130 --> 00:49:09.860
So really, my
recursive call is x

00:49:09.860 --> 00:49:14.330
ij gets the min
of all of these 1,

00:49:14.330 --> 00:49:17.140
2, 3, 4 expressions
that I've written here.

00:49:17.140 --> 00:49:19.113
OK.

00:49:19.113 --> 00:49:21.363
AUDIENCE: What if you have
the first condition but not

00:49:21.363 --> 00:49:21.988
the second one?

00:49:21.988 --> 00:49:24.405
JUSTIN SOLOMON: What if I have
the first condition but not

00:49:24.405 --> 00:49:25.230
the second one?

00:49:25.230 --> 00:49:28.390
Ah, so that's a great question.

00:49:28.390 --> 00:49:30.460
Yeah, so the question
was like, OK, well,

00:49:30.460 --> 00:49:35.820
what if I can match the next
line but not the current one.

00:49:35.820 --> 00:49:37.820
Well, there's two different
things you could do.

00:49:37.820 --> 00:49:39.653
You could either make
another case for that.

00:49:39.653 --> 00:49:40.630
That's perfectly fine.

00:49:40.630 --> 00:49:41.690
In fact, you could do that.

00:49:41.690 --> 00:49:43.480
You could do that I matched
the second condition, not

00:49:43.480 --> 00:49:44.488
the first one, whatever.

00:49:44.488 --> 00:49:46.030
You can just enumerate
as many things

00:49:46.030 --> 00:49:47.530
you want as long
as they're all true

00:49:47.530 --> 00:49:48.820
and there's a constant number.

00:49:48.820 --> 00:49:50.487
Alternatively, you
can convince yourself

00:49:50.487 --> 00:49:53.410
that actually is unnecessary
here because a different--

00:49:53.410 --> 00:49:55.850
so that's like swapping.

00:49:55.850 --> 00:49:58.130
But then one of those two
lines is still a mismatch,

00:49:58.130 --> 00:49:59.922
so you're going to have
to delete something

00:49:59.922 --> 00:50:00.920
in the next step.

00:50:00.920 --> 00:50:03.130
So you might as well just
delete first, rather than

00:50:03.130 --> 00:50:05.560
swap and then delete.

00:50:05.560 --> 00:50:07.850
And so that's why that
case isn't necessary.

00:50:07.850 --> 00:50:08.350
Yeah?

00:50:08.350 --> 00:50:10.017
AUDIENCE: [INAUDIBLE]
in the first case.

00:50:10.017 --> 00:50:11.320
JUSTIN SOLOMON: Exactly.

00:50:11.320 --> 00:50:11.860
Exactly.

00:50:11.860 --> 00:50:13.900
So if you swapped and you
killed a line, then, in effect,

00:50:13.900 --> 00:50:15.858
I think it's a combination
of case 1 and case 2

00:50:15.858 --> 00:50:18.710
here, if you, kind of,
expand your recursion out.

00:50:18.710 --> 00:50:20.710
But if you're having
trouble convincing yourself

00:50:20.710 --> 00:50:23.320
of that, that's fine,
just add a case here.

00:50:23.320 --> 00:50:25.167
Yeah.

00:50:25.167 --> 00:50:26.000
Any other questions?

00:50:26.000 --> 00:50:28.625
I'm going to ask quickly because
this problem makes me nervous.

00:50:28.625 --> 00:50:32.675
AUDIENCE: [INAUDIBLE]

00:50:32.675 --> 00:50:33.550
JUSTIN SOLOMON: Sure.

00:50:33.550 --> 00:50:33.870
OK.

00:50:33.870 --> 00:50:35.912
In the worst case, if
we've done something wrong,

00:50:35.912 --> 00:50:39.010
you can certainly add
another case here.

00:50:39.010 --> 00:50:40.640
I'll think about it at home.

00:50:40.640 --> 00:50:41.140
OK.

00:50:41.140 --> 00:50:44.202
So since I've managed
to pontificate too long,

00:50:44.202 --> 00:50:45.160
let's keep moving here.

00:50:45.160 --> 00:50:47.882
AUDIENCE: Can we swap them
if they [INAUDIBLE] match?

00:50:47.882 --> 00:50:49.590
JUSTIN SOLOMON: Oh,
you know, the problem

00:50:49.590 --> 00:50:50.910
is it might have been--

00:50:50.910 --> 00:50:53.050
AUDIENCE: --used
in the final file.

00:50:53.050 --> 00:50:55.680
So if you can make swap one
match one of them and not

00:50:55.680 --> 00:50:58.803
the other, then that's not OK.

00:50:58.803 --> 00:51:00.970
JUSTIN SOLOMON: Yeah, because
at the end of the day,

00:51:00.970 --> 00:51:02.010
the files have to agree.

00:51:02.010 --> 00:51:03.810
Like, you have to match B to A.

00:51:03.810 --> 00:51:05.310
AUDIENCE: Swap and
delete is cheaper

00:51:05.310 --> 00:51:07.573
than doing two deletes
and two inserts.

00:51:07.573 --> 00:51:10.380
AUDIENCE: No, no, no,
but the swap and delete

00:51:10.380 --> 00:51:12.725
is illegal because you
have to use both ones.

00:51:12.725 --> 00:51:14.100
That's a condition
in the pocket.

00:51:14.100 --> 00:51:15.350
JUSTIN SOLOMON: Oh, I'm sorry.

00:51:15.350 --> 00:51:16.370
That's a better answer.

00:51:16.370 --> 00:51:18.037
So Jason points out
that if I swap, then

00:51:18.037 --> 00:51:21.120
I can't delete it because the
way the problem is written.

00:51:21.120 --> 00:51:23.350
So that effectively
removes this case.

00:51:23.350 --> 00:51:24.330
Otherwise, I think--

00:51:24.330 --> 00:51:25.320
I guess Erik is--

00:51:25.320 --> 00:51:26.460
AUDIENCE: Actually, there are
two important conditions--

00:51:26.460 --> 00:51:27.150
JUSTIN SOLOMON: Oh, sorry.

00:51:27.150 --> 00:51:28.620
I've managed to
totally botch this,

00:51:28.620 --> 00:51:30.960
which is totally unsurprising.

00:51:30.960 --> 00:51:31.820
Yeah.

00:51:31.820 --> 00:51:34.590
So I think the problem also
states that if you swap,

00:51:34.590 --> 00:51:37.460
the swap has to be useful.

00:51:37.460 --> 00:51:39.390
And that's why this
additional case

00:51:39.390 --> 00:51:42.150
that Erik is asking about
where you swap and then you

00:51:42.150 --> 00:51:45.600
match one line but not
the other is unnecessary.

00:51:45.600 --> 00:51:48.058
You might be able to relax that
by just adding a case here,

00:51:48.058 --> 00:51:49.600
but since the problem
doesn't ask it,

00:51:49.600 --> 00:51:50.920
I'm not going to think about.

00:51:50.920 --> 00:51:51.670
OK.

00:51:51.670 --> 00:51:52.815
Right.

00:51:52.815 --> 00:51:54.690
So, under all the
assumptions of this problem

00:51:54.690 --> 00:51:56.857
that I didn't read but are
very important to solving

00:51:56.857 --> 00:51:59.070
this problem
correctly, I believe

00:51:59.070 --> 00:52:03.940
we really have written
down all of our cases here.

00:52:03.940 --> 00:52:04.440
OK.

00:52:04.440 --> 00:52:09.210
So let's continue with
our SRTBOT paradigm.

00:52:09.210 --> 00:52:12.540
So now we have all
of our recursion.

00:52:12.540 --> 00:52:17.010
The topological order here is a
little bit trickier than normal

00:52:17.010 --> 00:52:19.230
because now you've got
a two-dimensional array,

00:52:19.230 --> 00:52:22.000
but it follows a pattern
that's pretty typical here,

00:52:22.000 --> 00:52:31.740
which is that x ij only
depends on other x ij's

00:52:31.740 --> 00:52:38.150
with higher i plus j.

00:52:38.150 --> 00:52:41.030
So I think about my
graph of subproblems.

00:52:41.030 --> 00:52:43.370
If I wrote this in a 2D
matrix, it always, kind of,

00:52:43.370 --> 00:52:45.590
points down and to
the right, maybe,

00:52:45.590 --> 00:52:47.870
which is what's
making it acyclic.

00:52:47.870 --> 00:52:49.790
This is a very typical
pattern in these sort

00:52:49.790 --> 00:52:52.710
of two-dimensional dynamic
programming problem.

00:52:52.710 --> 00:52:53.210
All right.

00:52:53.210 --> 00:52:55.310
So let's see here, SRTBOT.

00:52:55.310 --> 00:52:57.993
So we need our base case.

00:52:57.993 --> 00:52:59.660
This isn't too bad
because, essentially,

00:52:59.660 --> 00:53:02.600
when you have boring
documents, they're

00:53:02.600 --> 00:53:05.500
very easy to match
to one another.

00:53:05.500 --> 00:53:12.735
So, in particular, for any
i, if I'm at line n plus 1--

00:53:12.735 --> 00:53:15.110
in other words, I have a blank
document that I'm matching

00:53:15.110 --> 00:53:16.730
to document i--

00:53:16.730 --> 00:53:20.140
well, how much work
do I have to do?

00:53:20.140 --> 00:53:21.640
You have to be a
little bit careful.

00:53:21.640 --> 00:53:24.120
This is where the suffix version
of this problem is a little bit

00:53:24.120 --> 00:53:25.750
more annoying than
the prefix one--

00:53:25.750 --> 00:53:29.070
or have I managed to swap
those backward again--

00:53:29.070 --> 00:53:32.010
that, in particular, the
remaining number of lines

00:53:32.010 --> 00:53:38.140
looks like n plus
1 minus i, which is

00:53:38.140 --> 00:53:39.390
different than in the problem.

00:53:39.390 --> 00:53:40.848
It's just i because
they're working

00:53:40.848 --> 00:53:43.740
in the other direction--
in the solution, rather.

00:53:43.740 --> 00:53:46.570
And similarly, you need a second
case for those two here, right?

00:53:46.570 --> 00:53:58.248
So you have x n plus 1 j is
going to be n plus 1 minus j.

00:53:58.248 --> 00:53:59.730
Cool.

00:53:59.730 --> 00:54:01.050
OK.

00:54:01.050 --> 00:54:03.620
So we're going to
continue with SRTBOT here.

00:54:06.232 --> 00:54:07.440
So what is our original case?

00:54:07.440 --> 00:54:13.530
Kind of by definition
it's x 1, 1 or 0 0,

00:54:13.530 --> 00:54:15.780
depending on how you index.

00:54:15.780 --> 00:54:19.450
And then, finally,
what's our runtime?

00:54:19.450 --> 00:54:27.180
Well, let's see, there's n
plus 1 squared subproblems,

00:54:27.180 --> 00:54:31.050
and, of course, that's
equal to order n squared.

00:54:31.050 --> 00:54:34.530
The subproblems are just
a constant amount of work,

00:54:34.530 --> 00:54:38.780
so they're each
with constant work.

00:54:41.750 --> 00:54:46.210
So our entire runtime
is order n squared.

00:54:46.210 --> 00:54:49.900
And hopefully by watching me
be confused in front of you

00:54:49.900 --> 00:54:51.550
and think through
this problem, you too

00:54:51.550 --> 00:54:55.000
will see how the problem
solving procedure

00:54:55.000 --> 00:54:57.920
can happen in your own
disorganized brains.

00:54:57.920 --> 00:54:58.420
OK.

00:54:58.420 --> 00:55:03.780
So that concludes our
treatment of this problem here.

00:55:03.780 --> 00:55:05.300
That, I think, is
the hardest one.

00:55:05.300 --> 00:55:08.820
So the other two, thankfully,
are much easier to think about,

00:55:08.820 --> 00:55:10.327
I thought.

00:55:10.327 --> 00:55:11.660
But I never liked edit distance.

00:55:11.660 --> 00:55:13.961
I remember seeing that and
undergrad algorithms getting

00:55:13.961 --> 00:55:14.670
confused.

00:55:14.670 --> 00:55:15.190
OK.

00:55:15.190 --> 00:55:22.800
So the next problem, problem 3
here, deals with Saggy Mimsin.

00:55:22.800 --> 00:55:25.260
And she has a bunch
of block, and she

00:55:25.260 --> 00:55:28.420
wants to stack them on top
of each other, as one does.

00:55:28.420 --> 00:55:31.740
And as a young
structural engineer,

00:55:31.740 --> 00:55:34.790
she has a few criteria
on her problem.

00:55:37.850 --> 00:55:40.110
Let me go to the right
page in my notes here.

00:55:44.190 --> 00:55:46.140
Right.

00:55:46.140 --> 00:55:48.090
So this is problem 3.

00:55:48.090 --> 00:55:59.040
So we have that block bi has
size that looks like width wi

00:55:59.040 --> 00:56:03.950
by height hi by length li.

00:56:03.950 --> 00:56:06.090
I remember getting confused
in elementary school

00:56:06.090 --> 00:56:08.580
about the difference between
width and length all the time.

00:56:08.580 --> 00:56:10.320
To me, those always
sounded the same.

00:56:10.320 --> 00:56:12.112
But it doesn't really
matter, because she's

00:56:12.112 --> 00:56:16.740
happy to rotate her cubes
any way that she pleases.

00:56:16.740 --> 00:56:19.680
There's a key detail which I
did remember to actually read

00:56:19.680 --> 00:56:24.450
in this problem, which is
that she has at least three

00:56:24.450 --> 00:56:31.333
of each type, where type
here means that I can permute

00:56:31.333 --> 00:56:32.750
these three numbers
any way that I

00:56:32.750 --> 00:56:35.180
want because that's the same
as just rotating a block.

00:56:35.180 --> 00:56:38.240
But any time she has one
block that's like 1 by 2 by 3,

00:56:38.240 --> 00:56:41.200
she has at least two more
in her bag somewhere.

00:56:41.200 --> 00:56:41.746
OK.

00:56:41.746 --> 00:56:44.240
APPLE WATCH: It's 6.

00:56:44.240 --> 00:56:46.940
JUSTIN SOLOMON: Oh, 1 times
2 times 3 is equal to 6.

00:56:46.940 --> 00:56:48.900
Thank you, Apple Watch.

00:56:48.900 --> 00:56:49.560
OK.

00:56:49.560 --> 00:56:51.490
So that's odd.

00:56:51.490 --> 00:56:53.060
So she can orient
her block any way

00:56:53.060 --> 00:56:58.010
that she wants, meaning she
can rotate it in any fashion

00:56:58.010 --> 00:56:59.150
that she'd like.

00:56:59.150 --> 00:57:02.930
And so what we're trying
to do, what we want

00:57:02.930 --> 00:57:10.380
is the max height where
she's stacking her n blocks.

00:57:10.380 --> 00:57:15.720
I suppose I should
say they're n blocks.

00:57:15.720 --> 00:57:18.210
So she wants the max height
that she can achieve.

00:57:18.210 --> 00:57:22.120
But just to be kind of
annoying, or because, again,

00:57:22.120 --> 00:57:24.120
she's very concerned with
structural stability--

00:57:24.120 --> 00:57:25.680
she lives in an
earthquake zone--

00:57:25.680 --> 00:57:29.670
she would like
with the condition

00:57:29.670 --> 00:57:33.360
that each block is strictly
supported on the block

00:57:33.360 --> 00:57:34.000
beneath it.

00:57:34.000 --> 00:57:34.500
Right?

00:57:40.350 --> 00:57:44.580
So in other words, if this
is the base of one block,

00:57:44.580 --> 00:57:46.980
then the next block that's
stacked on top of it

00:57:46.980 --> 00:57:51.950
has to be strictly contained
within the block below it.

00:57:51.950 --> 00:57:52.980
Right?

00:57:52.980 --> 00:57:54.615
So does the problem make sense?

00:57:54.615 --> 00:57:56.668
Have I omitted any
critical details?

00:57:56.668 --> 00:57:57.960
I don't think I have this time.

00:57:57.960 --> 00:57:59.618
This one's a little easier.

00:57:59.618 --> 00:58:01.748
AUDIENCE: [INAUDIBLE]

00:58:01.748 --> 00:58:02.790
JUSTIN SOLOMON: Oh, yeah.

00:58:02.790 --> 00:58:04.123
And she can't do anything crazy.

00:58:04.123 --> 00:58:06.660
She can't do a weird,
like, balance it

00:58:06.660 --> 00:58:09.000
on this edge kind
of thing, which--

00:58:09.000 --> 00:58:12.802
Erik is absolutely right--
could actually give her a taller

00:58:12.802 --> 00:58:14.760
tower than you could get
if you're only allowed

00:58:14.760 --> 00:58:16.320
to rotate blocks 90 degrees.

00:58:16.320 --> 00:58:18.900
I don't think the problem
states that explicitly, but this

00:58:18.900 --> 00:58:21.900
isn't a trigonometry class, so
I think we're in good shape.

00:58:21.900 --> 00:58:23.710
OK.

00:58:23.710 --> 00:58:24.210
Right.

00:58:24.210 --> 00:58:27.337
So that's our
basic problem here.

00:58:27.337 --> 00:58:28.920
And this is one of
these problems that

00:58:28.920 --> 00:58:30.795
is going to be a dynamic
programming problem,

00:58:30.795 --> 00:58:33.180
but, again, similar to
many of the things that we

00:58:33.180 --> 00:58:36.000
saw in lecture, is not
totally obvious how,

00:58:36.000 --> 00:58:39.720
because somehow she has
this big, disorganized bag

00:58:39.720 --> 00:58:40.440
of blocks.

00:58:40.440 --> 00:58:41.880
You could imagine
a universe where

00:58:41.880 --> 00:58:45.155
there's 2 to the n different
things she could do, right?

00:58:45.155 --> 00:58:46.530
For every single
block, she could

00:58:46.530 --> 00:58:48.747
decide whether or not
to put it in her stack,

00:58:48.747 --> 00:58:50.580
and then she has to do
a bunch of other work

00:58:50.580 --> 00:58:52.950
to verify whether
she can stack them

00:58:52.950 --> 00:58:56.410
while supporting the strict
support condition or not.

00:58:56.410 --> 00:58:59.200
So, initially, that
seems kind of annoying.

00:58:59.200 --> 00:59:01.137
So what we have to
do, which, again,

00:59:01.137 --> 00:59:02.970
is pretty common to a
lot of these problems,

00:59:02.970 --> 00:59:05.520
is place some order on it.

00:59:05.520 --> 00:59:07.300
I mean that both in
the entropy sense,

00:59:07.300 --> 00:59:09.930
and also, like, literally,
were going to order stuff.

00:59:09.930 --> 00:59:12.420
And, in particular, we'll
see that this problem has

00:59:12.420 --> 00:59:14.610
a lot in common
with that longest

00:59:14.610 --> 00:59:17.880
common subsequence problem that
we saw in lecture-- increasing

00:59:17.880 --> 00:59:20.670
subsequence, sorry.

00:59:20.670 --> 00:59:21.750
Right.

00:59:21.750 --> 00:59:26.860
So here's some observations
about our problem

00:59:26.860 --> 00:59:28.350
which are going to help.

00:59:28.350 --> 00:59:33.260
First of all, when
we stack our blocks,

00:59:33.260 --> 00:59:36.860
we might as well always align
the shorter side of the block

00:59:36.860 --> 00:59:40.470
on top to the shorter side
of the block underneath it.

00:59:40.470 --> 00:59:40.970
Right?

00:59:43.598 --> 00:59:45.140
Let me draw a picture
of what I mean.

00:59:50.900 --> 00:59:52.645
So let's say I have a really--

00:59:52.645 --> 00:59:54.920
a block whose base
kind of looks like that

00:59:54.920 --> 00:59:58.300
and then another block
which is also rectangular

00:59:58.300 --> 01:00:01.390
that I sit on top
of it like that.

01:00:01.390 --> 01:00:04.748
Then notice I could-- so in this
case, the shorter edge of one

01:00:04.748 --> 01:00:06.790
block is aligned to the
longer edge of the other.

01:00:06.790 --> 01:00:09.640
Notice I can rotate
it 90 degrees and it

01:00:09.640 --> 01:00:11.780
still supports on one another.

01:00:11.780 --> 01:00:13.240
So there's never a case--

01:00:13.240 --> 01:00:16.030
you convince yourself with
just a few inequalities--

01:00:16.030 --> 01:00:18.640
where I don't, kind of, always
put the long side parallel

01:00:18.640 --> 01:00:21.040
to the long side of the guy
underneath and the short side

01:00:21.040 --> 01:00:22.740
parallel to the short
guy underneath it.

01:00:22.740 --> 01:00:24.570
Does that makes sense?

01:00:24.570 --> 01:00:25.070
Cool.

01:00:25.070 --> 01:00:26.640
So that's observation one.

01:00:29.990 --> 01:00:33.350
Observation two, can
they ever-- like,

01:00:33.350 --> 01:00:36.650
let's say that Maggie
actually-- sorry,

01:00:36.650 --> 01:00:41.000
Saggy actually had not just
three blocks of a type,

01:00:41.000 --> 01:00:43.020
but like 25.

01:00:43.020 --> 01:00:46.670
So she's just has hella blocks.

01:00:46.670 --> 01:00:49.110
My question is does it matter.

01:00:49.110 --> 01:00:54.978
The answer is no because this
word here is really critical,

01:00:54.978 --> 01:00:56.520
which is that there's
strict support.

01:00:56.520 --> 01:00:59.880
So your block only
has so many faces.

01:00:59.880 --> 01:01:03.330
And, in fact, by
observation one,

01:01:03.330 --> 01:01:07.230
really all that matters is which
of the three types of faces

01:01:07.230 --> 01:01:11.080
is sitting on top because we
can just always rotate it.

01:01:11.080 --> 01:01:17.400
So there's three configurations
of every block, so, at most,

01:01:17.400 --> 01:01:20.380
can any one configuration
appear more than one time?

01:01:20.380 --> 01:01:22.530
No, because of the
strict support condition.

01:01:22.530 --> 01:01:23.030
Right?

01:01:23.030 --> 01:01:24.738
Otherwise, the rectangles
would match up,

01:01:24.738 --> 01:01:27.570
and that's against the rules.

01:01:27.570 --> 01:01:32.470
So, in particular-- oops,
the number after two is--

01:01:32.470 --> 01:01:37.280
the number after 1 is 2,
which looks like that.

01:01:37.280 --> 01:01:38.960
OK.

01:01:38.960 --> 01:01:39.460
Right.

01:01:39.460 --> 01:01:43.430
So, in particular, there
are only three orientations.

01:01:47.530 --> 01:01:49.630
This is just which of the
three edges of the block

01:01:49.630 --> 01:01:52.810
is the one that's going away
from the floor, the normal

01:01:52.810 --> 01:01:54.130
to the ground.

01:01:54.130 --> 01:02:01.810
And moreover, each can appear
less than or equal to 1 time.

01:02:01.810 --> 01:02:05.210
That's good because it limits
the size of our problem.

01:02:05.210 --> 01:02:13.840
And, finally-- oops, I collapsed
two of the cases in my notes

01:02:13.840 --> 01:02:15.100
into one case here.

01:02:15.100 --> 01:02:16.363
But that's OK.

01:02:16.363 --> 01:02:18.280
And, in fact, notice
that the problem tells us

01:02:18.280 --> 01:02:20.210
that she has at least
three of each type.

01:02:20.210 --> 01:02:23.960
So, in a sense, if the problem--

01:02:23.960 --> 01:02:26.870
if you observe one of a
block you might as well just

01:02:26.870 --> 01:02:28.760
throw away the rest
because you know that you

01:02:28.760 --> 01:02:30.230
can use it at most three times.

01:02:30.230 --> 01:02:31.652
And she has three of that block.

01:02:31.652 --> 01:02:33.860
We can't use it more than
three times, so in a sense,

01:02:33.860 --> 01:02:36.200
that's just superfluous
information.

01:02:36.200 --> 01:02:37.420
OK.

01:02:37.420 --> 01:02:37.920
Right.

01:02:37.920 --> 01:02:42.620
So this allows us to put
a little bit of order

01:02:42.620 --> 01:02:45.290
here, because notice that when
I look at the stack of blocks

01:02:45.290 --> 01:02:46.790
here, what do we know?

01:02:46.790 --> 01:02:49.940
If I look at the
length of the long side

01:02:49.940 --> 01:02:54.050
and the length of the short
side in the plane of the ground,

01:02:54.050 --> 01:02:57.780
those numbers have to decrease
on every level of my block.

01:02:57.780 --> 01:02:58.780
They can never increase.

01:02:58.780 --> 01:03:00.738
That's what the strict
support conditions says,

01:03:00.738 --> 01:03:03.350
combined with observation
one, actually, even

01:03:03.350 --> 01:03:07.345
without observation one,
which is good news, right?

01:03:07.345 --> 01:03:09.470
So this is what's going to
allow us to impose order

01:03:09.470 --> 01:03:12.290
on our problem, namely, that
we can sort by the edge lengths

01:03:12.290 --> 01:03:14.670
because we know that we
have this support condition.

01:03:14.670 --> 01:03:15.170
OK.

01:03:15.170 --> 01:03:18.015
So let's fill in some
details of our algorithm.

01:03:20.550 --> 01:03:21.050
OK.

01:03:26.310 --> 01:03:30.090
So originally-- already we can
see that our list of blocks

01:03:30.090 --> 01:03:32.000
is kind of useless
because the width, length,

01:03:32.000 --> 01:03:36.150
and values are sorted in
ways that don't matter.

01:03:36.150 --> 01:03:39.030
Moreover, if we have more
than three of a given block,

01:03:39.030 --> 01:03:42.130
that's somehow not super useful.

01:03:42.130 --> 01:03:47.500
So, instead of that,
without loss of generality,

01:03:47.500 --> 01:03:48.310
let's assume--

01:03:48.310 --> 01:03:56.238
so WLOG here-- we can always
take our block and assume--

01:03:56.238 --> 01:03:58.530
I'm going to do this slightly
different from my notes--

01:03:58.530 --> 01:04:06.553
that the width is less than
or equal to the height is less

01:04:06.553 --> 01:04:07.720
than or equal to the length.

01:04:07.720 --> 01:04:08.220
OK.

01:04:08.220 --> 01:04:10.570
So every block, if
this isn't the case,

01:04:10.570 --> 01:04:12.460
I could go down my array
of blocks and sort.

01:04:12.460 --> 01:04:15.700
And sorting a list of three
numbers is constant time.

01:04:15.700 --> 01:04:17.800
OK?

01:04:17.800 --> 01:04:18.820
Right.

01:04:18.820 --> 01:04:21.100
So what does this
allow me to do?

01:04:21.100 --> 01:04:24.670
Well, I'm going to say
that a block type actually

01:04:24.670 --> 01:04:28.450
is an ordered set where
the third number is going

01:04:28.450 --> 01:04:30.710
to be the axis that points up.

01:04:30.710 --> 01:04:32.210
And the reason to
do that is that we

01:04:32.210 --> 01:04:34.160
know that we can never
use that more than once

01:04:34.160 --> 01:04:35.600
for any type of a block.

01:04:35.600 --> 01:04:36.260
Yeah?

01:04:36.260 --> 01:04:47.360
So now I'm going to make a new
list of blocks with a capital B

01:04:47.360 --> 01:04:50.390
because I like blocks.

01:04:50.390 --> 01:04:52.590
And it's going to look
like the following.

01:04:52.590 --> 01:04:57.673
So if width-- so if w is
less than h is less than l,

01:04:57.673 --> 01:04:59.090
then I'm going to
take every block

01:04:59.090 --> 01:05:02.488
and duplicate it three times.

01:05:02.488 --> 01:05:04.780
Notice that I might end up
with a list with, like, nine

01:05:04.780 --> 01:05:09.100
times of every block,
but we'll fix that later.

01:05:09.100 --> 01:05:09.610
Right.

01:05:09.610 --> 01:05:12.670
And it's going to look
like the following, which

01:05:12.670 --> 01:05:19.270
is that, OK, I'm going
to have wi, hi, li.

01:05:19.270 --> 01:05:22.000
This is like describing a way
to stack my block because it's

01:05:22.000 --> 01:05:25.240
saying this is the short
side, this is the long side,

01:05:25.240 --> 01:05:28.210
this is the vertical side.

01:05:28.210 --> 01:05:30.730
And there are three cases
where any one of these guys

01:05:30.730 --> 01:05:31.810
can be the vertical side.

01:05:31.810 --> 01:05:33.080
So there's one.

01:05:33.080 --> 01:05:36.370
Let's say that the h
is the vertical side,

01:05:36.370 --> 01:05:38.380
then w has to go before l.

01:05:38.380 --> 01:05:45.010
So it would be wi, li,
hi, and a third one

01:05:45.010 --> 01:05:48.010
where the third guy is w.

01:05:48.010 --> 01:05:52.420
H is less than l, so
it would be hi, li, wi.

01:05:52.420 --> 01:05:53.920
And those are all
the different ways

01:05:53.920 --> 01:05:57.730
that I can, sort of, orient
these blocks in my stacking,

01:05:57.730 --> 01:06:02.710
assuming that I impose condition
one for convenience here.

01:06:02.710 --> 01:06:03.737
OK.

01:06:03.737 --> 01:06:05.320
I'm going to make a
new list of blocks

01:06:05.320 --> 01:06:07.507
where I take every
block in my original set

01:06:07.507 --> 01:06:09.340
and I just duplicate
it three times this way

01:06:09.340 --> 01:06:12.730
after I sort its coordinates.

01:06:12.730 --> 01:06:14.655
And now, well, what
do I need to do?

01:06:14.655 --> 01:06:16.780
For one thing, this thing
may have too many blocks.

01:06:16.780 --> 01:06:19.072
I might have a block that's
repeated more than one time

01:06:19.072 --> 01:06:20.198
and I can't do that.

01:06:20.198 --> 01:06:22.240
And moreover, it's going
to be convenient to have

01:06:22.240 --> 01:06:25.090
this sorted because I've got
to stack these guys eventually.

01:06:25.090 --> 01:06:25.810
Yeah?

01:06:25.810 --> 01:06:30.670
So I'm going to sort that list.

01:06:30.670 --> 01:06:31.960
And I want to do it--

01:06:31.960 --> 01:06:34.790
I can never say this
word-- lexicographically,

01:06:34.790 --> 01:06:37.630
meaning that I'm going sort out
the first coordinate, and then

01:06:37.630 --> 01:06:45.410
the second and the
third lexicographically.

01:06:45.410 --> 01:06:49.190
Notice this length is 3 n if
I had n blocks to start with.

01:06:49.190 --> 01:06:54.830
So this entire thing takes
order n log n time, which

01:06:54.830 --> 01:06:57.570
is important to account for.

01:06:57.570 --> 01:06:59.210
And then I can
remove duplicates.

01:07:03.072 --> 01:07:04.530
I'll let you guys
convince yourself

01:07:04.530 --> 01:07:06.510
you can do this in order n time.

01:07:06.510 --> 01:07:08.970
An easier way would've been
making second array and just

01:07:08.970 --> 01:07:09.570
kind of move--

01:07:09.570 --> 01:07:11.520
and only add stuff
when you didn't

01:07:11.520 --> 01:07:13.410
see the same thing before.

01:07:13.410 --> 01:07:14.430
OK.

01:07:14.430 --> 01:07:18.030
And, finally, now these are
ordered in a really nice way

01:07:18.030 --> 01:07:20.970
because I can stack
my blocks, but only

01:07:20.970 --> 01:07:22.620
ever looking to the
right in my sorted

01:07:22.620 --> 01:07:28.880
list, assuming that I'm stacking
from the top of my tower down,

01:07:28.880 --> 01:07:33.050
which is, I think, sort of
what's going on in this thing.

01:07:33.050 --> 01:07:33.590
OK.

01:07:33.590 --> 01:07:37.080
So now, finally, we
can do our SRTBOT.

01:07:37.080 --> 01:07:40.092
And I might do S and R
and T and then allow you

01:07:40.092 --> 01:07:42.050
guys to think about the
rest because, as usual,

01:07:42.050 --> 01:07:43.680
I'm talking too much.

01:07:43.680 --> 01:07:44.180
OK.

01:07:44.180 --> 01:07:49.580
So now this is starting to
look like a subsequence problem

01:07:49.580 --> 01:07:52.460
because, essentially, when
I stuck my blocks, if I

01:07:52.460 --> 01:07:54.140
use this block here--

01:07:54.140 --> 01:07:57.560
again, if I'm stacking from
my tower from the top down--

01:07:57.560 --> 01:08:00.200
all the blocks that can
sit underneath this one

01:08:00.200 --> 01:08:03.680
have to be further to the right
in my array because of the way

01:08:03.680 --> 01:08:06.190
that I sorted.

01:08:06.190 --> 01:08:08.740
Now, that doesn't mean
that I can put anything

01:08:08.740 --> 01:08:10.510
on the right
underneath this guy,

01:08:10.510 --> 01:08:12.640
but it does mean that I
know nothing to the left

01:08:12.640 --> 01:08:13.780
can go underneath this guy.

01:08:13.780 --> 01:08:15.460
That's the way to
think about it.

01:08:15.460 --> 01:08:16.120
OK.

01:08:16.120 --> 01:08:18.220
So it is going to be SRTBOT.

01:08:18.220 --> 01:08:23.439
So S, what I'm going
to say is that x i here

01:08:23.439 --> 01:08:27.700
is equal to the maximum height
of my tower, and I'm going to--

01:08:27.700 --> 01:08:29.140
taking a little
bit of inspiration

01:08:29.140 --> 01:08:32.350
from our subsequence problem
that we've already seen,

01:08:32.350 --> 01:08:34.720
I'm going to force
myself to use block i.

01:08:34.720 --> 01:08:36.105
We'll see if that's convenient.

01:08:46.310 --> 01:08:54.729
i and possibly-- just
for fun, maybe we'll

01:08:54.729 --> 01:08:58.460
do the prefix version of
this problem this time.

01:08:58.460 --> 01:09:04.310
So now I can use any
of the previous blocks.

01:09:04.310 --> 01:09:06.800
So I can use the first i
blocks to make a tower,

01:09:06.800 --> 01:09:08.547
but I'm forced to use block i.

01:09:08.547 --> 01:09:10.380
By the way, from now
on, when I use indices,

01:09:10.380 --> 01:09:12.290
it's into this sorted array.

01:09:12.290 --> 01:09:14.840
OK.

01:09:14.840 --> 01:09:15.740
So this is a problem.

01:09:15.740 --> 01:09:18.260
Obviously, if I
could solve for x,

01:09:18.260 --> 01:09:20.600
I would be done, because I
could get the maximum height

01:09:20.600 --> 01:09:23.330
by just iterating over all the
x's and choosing the biggest

01:09:23.330 --> 01:09:25.770
possible value here.

01:09:25.770 --> 01:09:27.979
And the question is, how
do I do this recursively?

01:09:32.950 --> 01:09:33.450
OK.

01:09:33.450 --> 01:09:37.600
So here's our recursive step.

01:09:37.600 --> 01:09:42.029
So let's say that I
use block i, well,

01:09:42.029 --> 01:09:43.830
because we know we have to.

01:09:43.830 --> 01:09:44.760
Right?

01:09:44.760 --> 01:09:49.140
So, in particular, we have--

01:09:49.140 --> 01:09:51.779
now I'm seeing why they
didn't use this notation

01:09:51.779 --> 01:09:53.130
in their answer, but that's OK.

01:10:00.370 --> 01:10:03.010
Let's use another letter to
refer to the third coordinate.

01:10:06.413 --> 01:10:08.080
AUDIENCE: v i for
vertical [INAUDIBLE]..

01:10:08.080 --> 01:10:09.700
JUSTIN SOLOMON: Yeah,
let's say v i is always

01:10:09.700 --> 01:10:10.210
the third coordinate.

01:10:10.210 --> 01:10:11.620
We've already used
w, h, and l, and I'm

01:10:11.620 --> 01:10:13.210
afraid if I reuse
them after sorting,

01:10:13.210 --> 01:10:14.980
it's going to confuse people.

01:10:14.980 --> 01:10:22.030
So v i is the third
coordinate of the i-th element

01:10:22.030 --> 01:10:23.920
of my sorted array.

01:10:23.920 --> 01:10:26.560
That's fine, OK.

01:10:26.560 --> 01:10:31.600
Right, so what is my
height if I use x i here?

01:10:31.600 --> 01:10:34.155
Well, I get some height from vi.

01:10:34.155 --> 01:10:35.780
And in addition to
that, I get whatever

01:10:35.780 --> 01:10:39.220
I stack underneath that guy.

01:10:39.220 --> 01:10:43.652
So, in particular,
I get that xi.

01:10:43.652 --> 01:10:45.110
Well, I get the
height of the block

01:10:45.110 --> 01:10:47.390
that I just decided to use.

01:10:47.390 --> 01:10:50.930
And now, what are all my cases?

01:10:50.930 --> 01:10:53.120
Well, I could decide
to do nothing else,

01:10:53.120 --> 01:10:55.110
like, just not use
any other blocks.

01:10:55.110 --> 01:10:57.740
That gives me a height of 0.

01:10:57.740 --> 01:11:02.940
Or, well, let's see here.

01:11:02.940 --> 01:11:05.100
I could use the x's,
but I have to be careful

01:11:05.100 --> 01:11:07.140
that I can actually stack them.

01:11:07.140 --> 01:11:12.225
So, in particular,
well, I need--

01:11:15.330 --> 01:11:20.220
yeah, I can take an
x j value, but I've

01:11:20.220 --> 01:11:22.500
got to be careful that I
can stick it underneath.

01:11:22.500 --> 01:11:26.710
So, in particular,
what do we know?

01:11:26.710 --> 01:11:34.410
Well, I can do anything
from 1 to i minus 1

01:11:34.410 --> 01:11:37.800
because that's sort of
the definition of xi.

01:11:37.800 --> 01:11:43.090
But, in particular, I
can stack it on top.

01:11:45.970 --> 01:11:48.490
So one easy way to do
this is I just array--

01:11:48.490 --> 01:11:52.150
I iterate through the first i
minus 1 elements of my array,

01:11:52.150 --> 01:11:53.830
and I just check my
stacking condition

01:11:53.830 --> 01:11:55.480
for every single
one of them relative

01:11:55.480 --> 01:11:59.830
to block j, so, in other words,
that the width and the height--

01:11:59.830 --> 01:12:02.080
or rather, the first and
the second coordinate

01:12:02.080 --> 01:12:04.450
satisfy the strict
inequalities that I need.

01:12:04.450 --> 01:12:06.910
I'm phrasing this
sentence neutrally

01:12:06.910 --> 01:12:10.310
because I forget whether this
is increasing or decreasing.

01:12:10.310 --> 01:12:11.530
But in any event--

01:12:11.530 --> 01:12:12.290
so what do I do?

01:12:12.290 --> 01:12:15.070
I check all of the blocks
that I could possibly

01:12:15.070 --> 01:12:17.035
stack from the index of
the array perspective.

01:12:17.035 --> 01:12:18.910
I make sure that I could
actually stack them,

01:12:18.910 --> 01:12:21.460
thanks to the size
of the current block

01:12:21.460 --> 01:12:24.070
that I just decided
to add to my stack.

01:12:24.070 --> 01:12:26.530
And I move recursively.

01:12:26.530 --> 01:12:27.260
OK.

01:12:27.260 --> 01:12:27.760
Right.

01:12:27.760 --> 01:12:30.010
So this is great
because now we're

01:12:30.010 --> 01:12:31.870
in exactly the recursive
scenario we wanted

01:12:31.870 --> 01:12:36.140
to be in, because x i
only depends on x j, where

01:12:36.140 --> 01:12:37.630
j is smaller than i.

01:12:37.630 --> 01:12:40.780
And that is exactly
our topological

01:12:40.780 --> 01:12:43.450
ordering that we need.

01:12:43.450 --> 01:12:47.260
If you do that on your homework,
you get a minus n for large n.

01:12:47.260 --> 01:12:48.730
OK.

01:12:48.730 --> 01:12:50.920
Similarly, what's our base case?

01:12:50.920 --> 01:12:56.020
Well, obviously, if I
only have one block,

01:12:56.020 --> 01:12:58.030
I might as well use it.

01:12:58.030 --> 01:13:03.190
So in that case, we have x1 is
equal to v(1) our notation here

01:13:03.190 --> 01:13:05.380
like that.

01:13:05.380 --> 01:13:08.510
Our original one, we have to
be a little bit careful because

01:13:08.510 --> 01:13:12.670
of the way that I've defined
x, because x assumes that I've

01:13:12.670 --> 01:13:16.760
used a particular
block, so I have to say,

01:13:16.760 --> 01:13:19.870
well, I might not have actually
chosen the very last block

01:13:19.870 --> 01:13:21.880
as the one I want to keep.

01:13:21.880 --> 01:13:22.840
So I have to iterate.

01:13:22.840 --> 01:13:26.500
I can say that,
really, my original

01:13:26.500 --> 01:13:27.927
is the max over i of x i.

01:13:27.927 --> 01:13:30.010
So one of these blocks has
to be the block on top.

01:13:30.010 --> 01:13:32.177
I'm just going to iterate
over all the possible ones

01:13:32.177 --> 01:13:33.490
and find it.

01:13:33.490 --> 01:13:38.740
And then our final thing
to do is the runtime t.

01:13:38.740 --> 01:13:42.520
This one is mildly trickier
than the previous runtimes

01:13:42.520 --> 01:13:45.370
that we've done so far
in our example problem.

01:13:45.370 --> 01:13:50.000
In particular, how many
subproblems are there?

01:13:50.000 --> 01:13:52.360
Well, there's n subproblems--

01:13:52.360 --> 01:13:54.610
or I'll say order n because
I'm always off by 1--

01:13:59.630 --> 01:14:04.347
corresponding to each
block in my stack here.

01:14:04.347 --> 01:14:05.930
But how much time
does each subproblem

01:14:05.930 --> 01:14:08.540
take, at least the way
that I've written it here?

01:14:08.540 --> 01:14:10.220
Well, what I have to do?

01:14:10.220 --> 01:14:12.500
I have to loop over all
of the possible blocks

01:14:12.500 --> 01:14:16.290
and find the one that
I can stack on top of

01:14:16.290 --> 01:14:17.310
and then take the max.

01:14:17.310 --> 01:14:22.480
So there's a loop here from 1
to i. i is upper bounded by n.

01:14:22.480 --> 01:14:27.280
So this is order n
subproblems times order n

01:14:27.280 --> 01:14:32.510
work per subproblem.

01:14:32.510 --> 01:14:35.860
So at the end of the
day, my algorithm

01:14:35.860 --> 01:14:38.700
is going to be order
n squared time.

01:14:38.700 --> 01:14:39.720
And, of course, again--

01:14:39.720 --> 01:14:42.450
I guess I promised it and
then I didn't actually do it--

01:14:42.450 --> 01:14:44.197
to actually implement
this algorithm,

01:14:44.197 --> 01:14:46.030
there's sort of two
different ways to do it.

01:14:46.030 --> 01:14:49.640
I could write a recursive
call plus a table.

01:14:49.640 --> 01:14:51.990
The tables maybe initialized
to a bunch of NaNs.

01:14:51.990 --> 01:14:54.630
And then I implement this
function recursively.

01:14:54.630 --> 01:14:58.343
But before I do that, I say, if
the table does not equal NaN,

01:14:58.343 --> 01:14:59.760
just return the
value in the table

01:14:59.760 --> 01:15:03.030
and otherwise call
this recursion.

01:15:03.030 --> 01:15:06.300
Or I can just have a
four loop from 1 to n

01:15:06.300 --> 01:15:09.060
and build up the table
one element at a time.

01:15:09.060 --> 01:15:11.010
And both of those
are exactly the same

01:15:11.010 --> 01:15:13.550
from a runtime perspective.

01:15:13.550 --> 01:15:14.050
OK.

01:15:14.050 --> 01:15:15.800
So I think I've managed
to watch that much

01:15:15.800 --> 01:15:18.160
more than my notes or
the written solution,

01:15:18.160 --> 01:15:19.660
but the problem
itself is actually

01:15:19.660 --> 01:15:20.490
pretty straightforward.

01:15:20.490 --> 01:15:22.720
So if you guys read through
the answer plus some of--

01:15:22.720 --> 01:15:24.762
I think, actually, the
hard parts of this problem

01:15:24.762 --> 01:15:26.170
were not the
dynamic programming,

01:15:26.170 --> 01:15:28.253
it was all the observations
you need to get there.

01:15:28.253 --> 01:15:31.270
So that's why I spent a
little more time there.

01:15:31.270 --> 01:15:31.870
OK.

01:15:31.870 --> 01:15:33.940
So, as usual, I haven't
left myself enough time

01:15:33.940 --> 01:15:35.740
for the last problem.

01:15:35.740 --> 01:15:37.810
But we have a few
minutes and that'll

01:15:37.810 --> 01:15:39.825
be sufficient to
set up the parts.

01:15:39.825 --> 01:15:41.200
I actually found
the last problem

01:15:41.200 --> 01:15:44.020
to be easier even though
it technically is, sort of,

01:15:44.020 --> 01:15:46.000
two dynamic programs in one.

01:15:46.000 --> 01:15:48.380
So I think the logic
is a little easier.

01:15:48.380 --> 01:15:49.240
OK.

01:15:49.240 --> 01:15:53.130
So

01:15:53.130 --> 01:15:55.603
AUDIENCE: Use the
backboard [INAUDIBLE]..

01:15:55.603 --> 01:15:57.520
JUSTIN SOLOMON: I think
this is the backboard.

01:15:57.520 --> 01:16:00.070
Yeah, I was just realizing
that this room doesn't work

01:16:00.070 --> 01:16:02.680
the same way as the other one.

01:16:02.680 --> 01:16:03.880
Yeah, this is embarrassing.

01:16:03.880 --> 01:16:05.963
You know, I spent all day
thinking about topology,

01:16:05.963 --> 01:16:10.770
and this is like a classic kind
of problem in that universe.

01:16:14.450 --> 01:16:15.110
OK.

01:16:15.110 --> 01:16:17.120
Well, we'll just erase
one board at a time,

01:16:17.120 --> 01:16:20.703
and I'll try not to write
three feet wide this time.

01:16:20.703 --> 01:16:22.828
Oh, this is probably the
one board I shouldn't use.

01:16:26.040 --> 01:16:29.060
I don't think I
like this classroom.

01:16:29.060 --> 01:16:29.560
OK.

01:16:29.560 --> 01:16:36.360
So, right, in our final problem,
we're given an n-by-n grid.

01:16:36.360 --> 01:16:40.980
And on our n-by-n
grid, Princess Apple--

01:16:40.980 --> 01:16:41.855
Banana--

01:16:41.855 --> 01:16:42.480
AUDIENCE: Plum.

01:16:42.480 --> 01:16:42.840
JUSTIN SOLOMON: --Plum.

01:16:42.840 --> 01:16:43.560
Princess Plum.

01:16:46.590 --> 01:16:48.300
Right, so here's
our basic setup.

01:16:48.300 --> 01:16:53.753
There's a big grid of
stuff, or maybe a small grid

01:16:53.753 --> 01:16:55.170
because I don't
feel like drawing.

01:16:55.170 --> 01:16:58.570
And every grid square can
have one of three things.

01:16:58.570 --> 01:16:59.920
We can have a mushroom.

01:16:59.920 --> 01:17:01.350
We can have a tree.

01:17:01.350 --> 01:17:03.540
Or it can have nothing at all.

01:17:03.540 --> 01:17:09.180
And our princess starts
here, and she goes--

01:17:09.180 --> 01:17:11.490
she wants to go there.

01:17:11.490 --> 01:17:15.330
And moreover, there's
a couple of things

01:17:15.330 --> 01:17:16.720
that are worth noting here.

01:17:16.720 --> 01:17:24.330
So, first of all, her
path is quick, meaning

01:17:24.330 --> 01:17:35.600
that she can only traverse
2n minus 1 grid squares

01:17:35.600 --> 01:17:38.610
to get from one
corner to the other.

01:17:38.610 --> 01:17:40.850
And, apparently, she's
very into mushrooms,

01:17:40.850 --> 01:17:44.390
and she'd like to accumulate
as many as possible

01:17:44.390 --> 01:17:45.320
along her path.

01:17:45.320 --> 01:17:46.640
That's the basic setup here.

01:17:46.640 --> 01:17:50.440
So she wants to get from the
upper left to lower right.

01:17:50.440 --> 01:17:54.670
And, in order to do so, she
wants to take a quick path.

01:17:54.670 --> 01:17:56.530
Her main priority
is to be efficient.

01:17:56.530 --> 01:17:59.050
But among the
different quick paths,

01:17:59.050 --> 01:18:01.270
she wants to pick up
a lot of mushrooms.

01:18:01.270 --> 01:18:02.188
It's understandable.

01:18:02.188 --> 01:18:03.730
AUDIENCE: And not
walk through trees.

01:18:03.730 --> 01:18:05.980
JUSTIN SOLOMON: And not only
through trees, thank you.

01:18:05.980 --> 01:18:07.780
So maybe there's
some grid squares

01:18:07.780 --> 01:18:09.863
that are marked with a
tree, meaning that you just

01:18:09.863 --> 01:18:11.190
can't go there.

01:18:11.190 --> 01:18:13.230
That's a tree.

01:18:13.230 --> 01:18:15.190
OK.

01:18:15.190 --> 01:18:17.530
Right, so that's our
basic setup here.

01:18:17.530 --> 01:18:18.480
But the problem does--

01:18:18.480 --> 01:18:19.855
it takes a bit of
a twist, right?

01:18:19.855 --> 01:18:22.410
It's not saying just could
be the shortest path, which

01:18:22.410 --> 01:18:26.400
would be very much like the
last kind of unit in 6.006.

01:18:26.400 --> 01:18:29.220
But rather, the
question is, sort of,

01:18:29.220 --> 01:18:33.240
what is the number of paths
that she can take from one side

01:18:33.240 --> 01:18:38.143
to the other and what is the
maximum number of mushrooms, is

01:18:38.143 --> 01:18:39.810
roughly the question
asking, or at least

01:18:39.810 --> 01:18:41.750
what I remember from
reading it last night.

01:18:41.750 --> 01:18:44.832
AUDIENCE: The number of paths
that maximizes the same number.

01:18:44.832 --> 01:18:46.040
JUSTIN SOLOMON: That's right.

01:18:46.040 --> 01:18:48.890
So she has to take the
most number of mushrooms

01:18:48.890 --> 01:18:51.380
she can, but there may be
more than one path that

01:18:51.380 --> 01:18:53.013
gets you there
that is quick, that

01:18:53.013 --> 01:18:54.680
satisfies this
condition, in which case,

01:18:54.680 --> 01:18:56.720
she wants the count of
the total number of ways

01:18:56.720 --> 01:18:58.512
you could get from one
corner to the other.

01:18:58.512 --> 01:18:59.460
Why, you might ask--

01:18:59.460 --> 01:19:01.740
why not?

01:19:01.740 --> 01:19:02.240
OK.

01:19:02.240 --> 01:19:04.700
So, right.

01:19:04.700 --> 01:19:10.530
So, for instance, maybe
there's a mushroom here.

01:19:10.530 --> 01:19:13.280
Now there's a quick
path that gets her there

01:19:13.280 --> 01:19:14.720
and collects one mushroom.

01:19:14.720 --> 01:19:15.740
So there's exactly one.

01:19:15.740 --> 01:19:21.620
But maybe if there's a mushroom
there, well, initially,

01:19:21.620 --> 01:19:24.230
it feels like maybe she
could get two mushrooms.

01:19:24.230 --> 01:19:27.050
She could go there, go pick
up the second mushroom,

01:19:27.050 --> 01:19:28.560
and get back.

01:19:28.560 --> 01:19:31.880
But we're going to see that
this quick condition actually

01:19:31.880 --> 01:19:33.620
allows-- it doesn't
allow you to do that.

01:19:33.620 --> 01:19:34.460
OK?

01:19:34.460 --> 01:19:37.520
So, in fact, it'll turn out
that quick paths can only

01:19:37.520 --> 01:19:40.100
collect one mushroom
in this 3-by-3 case,

01:19:40.100 --> 01:19:44.150
so there's at least
two different paths.

01:19:44.150 --> 01:19:49.360
Well, there's 1,
2, 3 different ways

01:19:49.360 --> 01:19:52.890
that she could collect one
mushroom and have a quick path.

01:19:52.890 --> 01:19:55.060
OK.

01:19:55.060 --> 01:19:57.280
So the first thing to
notice is the instructions

01:19:57.280 --> 01:20:01.450
are a little bit sneaky
by defining quick paths,

01:20:01.450 --> 01:20:03.880
basically, by giving
her no slack at all.

01:20:03.880 --> 01:20:05.320
Right?

01:20:05.320 --> 01:20:08.280
And here's a basic observation.

01:20:08.280 --> 01:20:10.280
Notice that in order to
give from the upper left

01:20:10.280 --> 01:20:11.947
to the bottom right,
she's going to have

01:20:11.947 --> 01:20:13.390
to go down and to the right.

01:20:13.390 --> 01:20:14.800
Plausibly, she could also go up.

01:20:14.800 --> 01:20:19.752
She could try and go around
a tree, but only plausibly.

01:20:19.752 --> 01:20:22.210
And, in particular, the question
is how many times does she

01:20:22.210 --> 01:20:23.960
have to go down and
how many times did she

01:20:23.960 --> 01:20:25.490
have to go to the right.

01:20:25.490 --> 01:20:28.230
Well, she has to get to
the bottom of the grid.

01:20:28.230 --> 01:20:30.115
So she's on grid
square number 1.

01:20:30.115 --> 01:20:32.240
She has to go down, in this
case, at least two more

01:20:32.240 --> 01:20:34.730
times, so, in general,
n minus 1 times.

01:20:34.730 --> 01:20:38.592
She has to go to the
right n minus 1 times.

01:20:38.592 --> 01:20:39.550
So what does that mean?

01:20:39.550 --> 01:20:43.100
She has to make
2n minus 2 moves.

01:20:43.100 --> 01:20:44.447
And that's a lower bound, right?

01:20:44.447 --> 01:20:46.780
So if she goes up, she's going
to have to go down again,

01:20:46.780 --> 01:20:48.120
so it's only going
to make it bigger.

01:20:48.120 --> 01:20:48.770
Right?

01:20:48.770 --> 01:20:55.670
So at the very least, she
has to do 2n minus 2 moves

01:20:55.670 --> 01:21:01.310
down and right to get from the
upper left to the lower right.

01:21:01.310 --> 01:21:03.620
How many squares does she
touch when she's doing that?

01:21:03.620 --> 01:21:05.040
This is a fence post problem.

01:21:05.040 --> 01:21:06.710
So she made 2n minus
2 moves, and she

01:21:06.710 --> 01:21:09.380
had a place where she started.

01:21:09.380 --> 01:21:13.070
That implies that just by
moving down and to the right,

01:21:13.070 --> 01:21:17.150
she makes 2n minus 1 squares--

01:21:17.150 --> 01:21:20.020
she touches, rather.

01:21:20.020 --> 01:21:22.460
So can she ever move up?

01:21:22.460 --> 01:21:23.060
No.

01:21:23.060 --> 01:21:24.710
Can she ever move to the left?

01:21:24.710 --> 01:21:25.947
No.

01:21:25.947 --> 01:21:28.405
And that, basically, is all
you need to solve this problem.

01:21:28.405 --> 01:21:30.170
The rest of it's
actually pretty easy.

01:21:30.170 --> 01:21:32.937
So the basic observation here
is she can only move down

01:21:32.937 --> 01:21:35.270
and to the right because if
she moved up or to the left,

01:21:35.270 --> 01:21:37.490
her path would no
longer be called quick,

01:21:37.490 --> 01:21:38.880
and that would be a problem.

01:21:38.880 --> 01:21:41.750
Moreover, every path that
moves down and to the right

01:21:41.750 --> 01:21:45.330
is a quick path, assuming
she reaches their target

01:21:45.330 --> 01:21:46.980
and doesn't hit a tree.

01:21:46.980 --> 01:21:49.080
OK?

01:21:49.080 --> 01:21:50.460
So that's the basic observation.

01:21:50.460 --> 01:21:52.560
And notice that that
already basically suggests--

01:21:52.560 --> 01:21:54.253
it's, like, screaming
out to you--

01:21:54.253 --> 01:21:56.670
how to do dynamic programming
because, literally, you have

01:21:56.670 --> 01:22:01.450
a table looking at you on
the blackboard right now,

01:22:01.450 --> 01:22:05.530
and you have an ordering
down and to the right that

01:22:05.530 --> 01:22:06.410
is acyclic.

01:22:06.410 --> 01:22:07.370
Yeah?

01:22:07.370 --> 01:22:07.870
OK.

01:22:07.870 --> 01:22:09.730
Have I slammed on the
board enough times?

01:22:09.730 --> 01:22:11.350
The first time I
taught at Stanford,

01:22:11.350 --> 01:22:14.620
I got negative course feedback
that I had too much coffee

01:22:14.620 --> 01:22:18.070
and was slamming on the
board a lot, apparently.

01:22:18.070 --> 01:22:21.050
I watched the video later, and,
indeed, that was not wrong.

01:22:21.050 --> 01:22:22.180
OK.

01:22:22.180 --> 01:22:23.830
So, right.

01:22:23.830 --> 01:22:27.520
So, we're going to call k--

01:22:27.520 --> 01:22:34.090
this is going to be
the max mushrooms she

01:22:34.090 --> 01:22:36.550
can get going on the entire
path from the upper left

01:22:36.550 --> 01:22:37.447
of the lower right.

01:22:37.447 --> 01:22:39.280
So we want to know the
number of quick paths

01:22:39.280 --> 01:22:42.150
that can achieve this number k.

01:22:42.150 --> 01:22:42.650
OK.

01:22:42.650 --> 01:22:48.496
So let's do SRTBOT really fast
because I've got four minutes--

01:22:48.496 --> 01:22:51.150
actually, a tiny bit more than
that because we started late.

01:22:51.150 --> 01:22:51.650
OK.

01:22:55.300 --> 01:22:57.700
Now, the kind of
annoyance here is

01:22:57.700 --> 01:23:01.180
that there's two different
numbers that we don't know.

01:23:01.180 --> 01:23:03.820
One of them is k, and the
other is the number of paths.

01:23:03.820 --> 01:23:06.790
The problem didn't tell you how
many mushrooms she can pick up.

01:23:06.790 --> 01:23:08.830
It does tell you that
there's some path

01:23:08.830 --> 01:23:10.360
to get from the upper
left to the bottom right,

01:23:10.360 --> 01:23:12.068
that there's not just
like a row of trees

01:23:12.068 --> 01:23:17.660
somewhere, which I feel
in my commute sometimes.

01:23:17.660 --> 01:23:21.740
But it doesn't
tell you the number

01:23:21.740 --> 01:23:23.600
that she has to accomplish.

01:23:23.600 --> 01:23:25.890
And, initially, that's
kind of annoying.

01:23:25.890 --> 01:23:27.680
So maybe the first
thing that we do

01:23:27.680 --> 01:23:30.170
is just compute k,
like, the maximum number

01:23:30.170 --> 01:23:34.660
of mushrooms that she can
collect on any quick path.

01:23:34.660 --> 01:23:37.070
And then we go back and
compute that other count.

01:23:37.070 --> 01:23:38.820
That would be one
problem-solving approach

01:23:38.820 --> 01:23:41.750
that we could think
about a little bit.

01:23:41.750 --> 01:23:50.065
So, in particular, let's define
our k ij to be equal to--

01:23:50.065 --> 01:23:51.940
well, we can generalize
our problem slightly,

01:23:51.940 --> 01:23:54.250
and say what is the
number of mushrooms

01:23:54.250 --> 01:23:57.340
that I can get on any kind
of rectangle embedded inside

01:23:57.340 --> 01:23:59.260
of my full problem, right?

01:23:59.260 --> 01:24:04.540
So, in other words, this is
the max number of mushrooms,

01:24:04.540 --> 01:24:14.987
or m's for short, on
a quick path to ij.

01:24:14.987 --> 01:24:17.320
So, in other words, she always
starts in the upper left,

01:24:17.320 --> 01:24:20.020
but now she stops at
any other grid cell.

01:24:20.020 --> 01:24:20.520
OK?

01:24:23.570 --> 01:24:25.925
Because I'm running
low on time--

01:24:25.925 --> 01:24:28.050
no, I'm going to do this
the way I want to do this.

01:24:28.050 --> 01:24:29.758
No, so we're just
going to think about k.

01:24:29.758 --> 01:24:30.600
Yeah?

01:24:30.600 --> 01:24:34.620
So the question is
could we compute just

01:24:34.620 --> 01:24:38.160
as value k, which
certainly seems convenient.

01:24:38.160 --> 01:24:41.343
Princess Plum, she might
as well know her enemy.

01:24:41.343 --> 01:24:43.260
She might as well know
the number of mushrooms

01:24:43.260 --> 01:24:44.880
she's targeting,
if she can get it.

01:24:47.640 --> 01:24:53.830
So how could we do
this recursively?

01:24:53.830 --> 01:24:58.120
Well, she has to
get to position ij.

01:24:58.120 --> 01:25:00.430
And from our argument
up there, she

01:25:00.430 --> 01:25:04.640
has to get there by either
coming from up or to the left,

01:25:04.640 --> 01:25:07.020
the way we've chosen to
write down this problem.

01:25:07.020 --> 01:25:09.980
So what are our different cases?

01:25:09.980 --> 01:25:12.080
Well, first of all,
if there's a tree,

01:25:12.080 --> 01:25:13.200
you can't do a damn thing.

01:25:13.200 --> 01:25:14.750
She shouldn't even
be able to get there.

01:25:14.750 --> 01:25:16.490
And for convenience,
we're going to find

01:25:16.490 --> 01:25:18.590
you can argue that it's 0.

01:25:18.590 --> 01:25:20.750
We're going to mark this
with a special number,

01:25:20.750 --> 01:25:22.500
and we'll see that
that makes our notation

01:25:22.500 --> 01:25:23.540
a little convenient.

01:25:23.540 --> 01:25:28.430
So one is if there
exists a tree,

01:25:28.430 --> 01:25:32.723
then we're going to say
k ij is minus infinity.

01:25:32.723 --> 01:25:34.640
Again, there's a
philosophical question there.

01:25:34.640 --> 01:25:36.380
Does she get minus
infinity mushrooms

01:25:36.380 --> 01:25:38.180
if she is standing
on top of a tree?

01:25:38.180 --> 01:25:39.060
I don't know,
because she shouldn't

01:25:39.060 --> 01:25:40.220
stand on top of a tree.

01:25:40.220 --> 01:25:42.500
But at least it's going to
let us know that something

01:25:42.500 --> 01:25:44.720
went wrong in this grid
square in the other parts

01:25:44.720 --> 01:25:46.130
of our recursion.

01:25:46.130 --> 01:25:48.320
OK?

01:25:48.320 --> 01:25:55.720
And otherwise, well, what
are our different cases here?

01:25:55.720 --> 01:25:58.100
Well, she always picks up
a mushroom if it's there.

01:25:58.100 --> 01:25:58.850
She might as well.

01:25:58.850 --> 01:26:00.370
She's maximizing.

01:26:00.370 --> 01:26:02.385
In fact, the problem even
says that she's really

01:26:02.385 --> 01:26:03.010
into mushrooms.

01:26:03.010 --> 01:26:05.950
She collects them
automatically, right?

01:26:05.950 --> 01:26:07.720
So what do we get?

01:26:10.710 --> 01:26:13.110
I use unnecessarily
fancy notation.

01:26:13.110 --> 01:26:19.140
This is an indicator of
whether there exists a mushroom

01:26:19.140 --> 01:26:27.030
at position ij, meaning
this is a 1 if there is,

01:26:27.030 --> 01:26:29.280
and there's a 0 if there's not.

01:26:29.280 --> 01:26:32.790
Sometimes this is indicated with
a 1 with a little subscript,

01:26:32.790 --> 01:26:34.830
but whatever.

01:26:34.830 --> 01:26:36.870
In addition to that,
she might have picked up

01:26:36.870 --> 01:26:38.490
mushrooms along paths.

01:26:38.490 --> 01:26:41.580
And we know that her path
to position ij either

01:26:41.580 --> 01:26:44.480
came from up or to the left.

01:26:44.480 --> 01:26:51.140
So, in other words,
we know that she

01:26:51.140 --> 01:26:53.600
could have gotten the max
from any path ending above her

01:26:53.600 --> 01:26:55.250
or any path to the left of her.

01:26:55.250 --> 01:27:00.380
So that's k i minus
1j, which, I guess,

01:27:00.380 --> 01:27:07.210
is to the left, and k
ij minus 1, like that.

01:27:07.210 --> 01:27:11.620
And this can be used to fill
in our whole table of k values.

01:27:11.620 --> 01:27:13.120
In fact, since I'm
low on time, I'll

01:27:13.120 --> 01:27:18.650
let you do the TBOT for the
remainder of this problem.

01:27:18.650 --> 01:27:21.395
Essentially, I think the
key observation is this one.

01:27:21.395 --> 01:27:23.270
Obviously, when she
starts in the upper left,

01:27:23.270 --> 01:27:24.620
she gets 0 mushrooms
because she's not

01:27:24.620 --> 01:27:25.578
standing on top of one.

01:27:25.578 --> 01:27:27.750
The problem says that.

01:27:27.750 --> 01:27:30.360
And this allows us to
fill in our whole table k.

01:27:30.360 --> 01:27:32.610
So, in particular, this
gives us our enemy now.

01:27:32.610 --> 01:27:36.952
We now know how many
mushrooms she should have

01:27:36.952 --> 01:27:38.160
at every step of her journey.

01:27:38.160 --> 01:27:39.660
In fact, it tells
us a tiny bit more

01:27:39.660 --> 01:27:42.240
than that because it
says if I'm at this grid

01:27:42.240 --> 01:27:46.020
sq-- at this particular
grid square during my path,

01:27:46.020 --> 01:27:47.560
I should have this
many mushrooms.

01:27:47.560 --> 01:27:49.950
If I didn't, then
something went wrong.

01:27:49.950 --> 01:27:51.343
Yeah?

01:27:51.343 --> 01:27:53.010
So the way that the
solution is written,

01:27:53.010 --> 01:27:55.272
they do two pieces of
the recursion at once.

01:27:55.272 --> 01:27:57.480
You actually could have just
solved for this k matrix

01:27:57.480 --> 01:27:59.550
first and then gone back
and done the second half

01:27:59.550 --> 01:28:00.300
of this problem.

01:28:00.300 --> 01:28:02.770
And those are exactly the same.

01:28:02.770 --> 01:28:04.458
And when I was
writing my solution,

01:28:04.458 --> 01:28:06.750
this is the way I thought
about it, because, somehow, I

01:28:06.750 --> 01:28:07.980
kind of felt like she
might as well know

01:28:07.980 --> 01:28:09.990
how many mushrooms she wants
to collect before she starts

01:28:09.990 --> 01:28:10.615
counting paths.

01:28:10.615 --> 01:28:13.620
That's like a secondary
question, you know.

01:28:13.620 --> 01:28:15.760
And so this is one way to do it.

01:28:15.760 --> 01:28:18.820
So in our remaining
negative 2 minutes,

01:28:18.820 --> 01:28:20.920
let's think about the
recursion for computing.

01:28:20.920 --> 01:28:24.600
Remember that we want to know
the number of paths needed

01:28:24.600 --> 01:28:28.770
to collect that many
mushrooms, the maximum number

01:28:28.770 --> 01:28:31.690
of mushrooms.

01:28:31.690 --> 01:28:34.300
Please let there not be a whole
lot of stuff on this board.

01:28:34.300 --> 01:28:35.967
Ah, there's not any
stuff on this board.

01:28:35.967 --> 01:28:36.860
That's great.

01:28:36.860 --> 01:28:38.320
OK.

01:28:38.320 --> 01:28:42.690
So, in particular, now I'm
going to define a second thing

01:28:42.690 --> 01:28:45.360
that I also I'm going to
do dynamic programming on.

01:28:45.360 --> 01:28:51.540
I'm going to say that x ij
is equal to-- and I'm going

01:28:51.540 --> 01:28:55.270
to make it kind of a
sneaky definition here,

01:28:55.270 --> 01:29:12.320
which is the number of quick
paths that end at ij with--

01:29:12.320 --> 01:29:15.930
now, let's anticipate
our problem a little bit.

01:29:15.930 --> 01:29:18.677
So at the end of the day, we're
going to do x of n comma n

01:29:18.677 --> 01:29:21.260
because she wants to end up all
the way down and to the right.

01:29:21.260 --> 01:29:23.135
And how many mushrooms
does she want to have,

01:29:23.135 --> 01:29:24.290
now that we know k?

01:29:24.290 --> 01:29:27.770
She wants to have k of
n comma n mushrooms.

01:29:27.770 --> 01:29:31.100
Along the way, it would
be kind of ambitious

01:29:31.100 --> 01:29:32.780
if she wanted to
have k of n comma n

01:29:32.780 --> 01:29:35.120
mushrooms the entire path.

01:29:35.120 --> 01:29:37.970
But it would be slightly
less ambitious to have

01:29:37.970 --> 01:29:42.080
k of ij mushrooms
because, somehow, that's

01:29:42.080 --> 01:29:45.900
exactly what we just constructed
in the previous thing

01:29:45.900 --> 01:29:48.290
where it was paths.

01:29:48.290 --> 01:29:50.102
Well, the last guy
looks like a max.

01:29:50.102 --> 01:29:52.310
Now we're going to expect
to see some plus signs here

01:29:52.310 --> 01:29:54.980
because we're adding up
how many paths we have.

01:29:54.980 --> 01:29:56.000
OK?

01:29:56.000 --> 01:29:59.480
And now let's come up with a
recursive rule for the array x,

01:29:59.480 --> 01:30:01.560
and then we'll call it a day.

01:30:01.560 --> 01:30:10.980
So, in particular, [INAUDIBLE]
one, if there's a tree,

01:30:10.980 --> 01:30:12.770
how many paths are there?

01:30:12.770 --> 01:30:15.560
There are no paths,
because I can't get there.

01:30:15.560 --> 01:30:19.730
So then ij equals 0.

01:30:19.730 --> 01:30:20.330
OK?

01:30:20.330 --> 01:30:23.450
Otherwise, there ain't a tree.

01:30:23.450 --> 01:30:27.770
And now I have to be a
little careful, right?

01:30:27.770 --> 01:30:30.890
So I need to write this
like a little piece of code.

01:30:30.890 --> 01:30:34.400
You could have written this as
a giant max, instead, or a bunch

01:30:34.400 --> 01:30:37.380
of cases and whatever.

01:30:37.380 --> 01:30:39.770
So let's think about it
like a piece of code.

01:30:39.770 --> 01:30:42.560
So, initially, I think
there are no paths that

01:30:42.560 --> 01:30:44.030
get me k ij mushrooms.

01:30:44.030 --> 01:30:45.995
That's perfectly fine.

01:30:45.995 --> 01:30:47.370
And remember,
we're going to keep

01:30:47.370 --> 01:30:48.745
applying the same
piece of logic,

01:30:48.745 --> 01:30:51.990
which is that a path can only
come from to the left and up.

01:30:51.990 --> 01:30:56.770
And let's think about
those two cases.

01:30:56.770 --> 01:30:58.560
And by the way, we're
going to use chi

01:30:58.560 --> 01:31:01.710
to equal this chi
of stuff that we

01:31:01.710 --> 01:31:04.500
had in the previous expression.

01:31:04.500 --> 01:31:07.470
So chi is 1 if there's a
mushroom at this place,

01:31:07.470 --> 01:31:09.610
and 0 if there is not.

01:31:09.610 --> 01:31:12.290
OK.

01:31:12.290 --> 01:31:15.650
So my path can come
from the left or up.

01:31:15.650 --> 01:31:20.030
I know that it can't come from
up if the number of mushrooms

01:31:20.030 --> 01:31:23.150
that I got from up plus,
potentially, the one that I got

01:31:23.150 --> 01:31:25.460
here doesn't align with
the number of mushrooms

01:31:25.460 --> 01:31:28.670
that I should have
by the k ij standard

01:31:28.670 --> 01:31:31.100
that I have set for myself.

01:31:31.100 --> 01:31:34.325
So if I want to write that out
in code, the way I do that is I

01:31:34.325 --> 01:31:37.910
would say, if k of--

01:31:37.910 --> 01:31:40.217
so let's say I look
to the left first.

01:31:40.217 --> 01:31:42.800
This is like, you know, look to
your left, look to your right,

01:31:42.800 --> 01:31:46.160
one of you will pass this
exam kind of scenario.

01:31:46.160 --> 01:31:49.730
And I potentially add a
mushroom at my current position

01:31:49.730 --> 01:31:52.140
if there is one.

01:31:52.140 --> 01:31:55.568
If that is equal to k ij,
well, what does that mean?

01:31:55.568 --> 01:31:57.360
That means that paths
that went to the left

01:31:57.360 --> 01:31:59.910
were able to collect the number
of mushrooms I need to get

01:31:59.910 --> 01:32:01.560
to the position I am now.

01:32:01.560 --> 01:32:08.700
So now I can add all
of the different ways.

01:32:08.700 --> 01:32:14.940
Maybe I'll do a plus
equals x of i minus 1j

01:32:14.940 --> 01:32:16.815
because any path that
got to the previous guy

01:32:16.815 --> 01:32:18.607
and collected the right
number of mushrooms

01:32:18.607 --> 01:32:21.050
can now reach me and get the
right number of mushrooms.

01:32:21.050 --> 01:32:24.300
And similarly, I can look up
and do exactly the same logic.

01:32:24.300 --> 01:32:33.040
So if k of ij minus 1 plus
this number is equal to k ij,

01:32:33.040 --> 01:32:43.980
then x ij gets an additional
number of paths, like that.

01:32:43.980 --> 01:32:46.770
And now I do think it's worth
spending 8 seconds thinking

01:32:46.770 --> 01:32:50.040
about our base cases
here because, initially,

01:32:50.040 --> 01:32:52.050
when I first saw this,
I panicked a little bit

01:32:52.050 --> 01:32:54.217
because it kind of looks
like this would just end up

01:32:54.217 --> 01:32:56.643
getting a bunch of 0's
because I'm just adding

01:32:56.643 --> 01:32:57.810
values of x's to themselves.

01:32:57.810 --> 01:32:59.352
I don't have, like,
a 1 plus anything

01:32:59.352 --> 01:33:02.593
anywhere, which is kind of
weird if you think about it.

01:33:02.593 --> 01:33:04.760
So all of the reason why
the positive numbers appear

01:33:04.760 --> 01:33:07.310
in this problem is from the base
case, which is kind of cool,

01:33:07.310 --> 01:33:07.810
I think.

01:33:07.810 --> 01:33:09.810
This is like, I think,
one of these things where

01:33:09.810 --> 01:33:12.020
if you anticipated a
problem, then it's cool,

01:33:12.020 --> 01:33:13.415
and if you didn't anticipate
the problem to begin with

01:33:13.415 --> 01:33:15.080
and you just wrote
down these formulas,

01:33:15.080 --> 01:33:17.990
you probably wouldn't even
think that it's interesting.

01:33:17.990 --> 01:33:21.420
But in any event,
what is our base case?

01:33:21.420 --> 01:33:24.440
So, we'll do the B in SRTBOT.

01:33:24.440 --> 01:33:30.053
So, first of all,
what is k of 1, 1?

01:33:30.053 --> 01:33:31.720
Remember, that's the
number of mushrooms

01:33:31.720 --> 01:33:33.637
she can collect by
starting at the left square

01:33:33.637 --> 01:33:34.890
and going nowhere.

01:33:34.890 --> 01:33:37.530
And that's 0 because
the problem says there's

01:33:37.530 --> 01:33:40.430
no mushrooms in the upper left.

01:33:40.430 --> 01:33:43.012
What's x of 1, 1?

01:33:43.012 --> 01:33:44.720
Well, this is the
number of paths from 1,

01:33:44.720 --> 01:33:49.570
1 to itself that collects
0 mushrooms, so that's 1.

01:33:49.570 --> 01:33:50.530
OK.

01:33:50.530 --> 01:33:52.930
And I think that the
rest of the SRTBOT table

01:33:52.930 --> 01:33:56.360
here isn't terribly
difficult to fill in.

01:33:56.360 --> 01:33:58.370
So I noticed that in
kind of a funny way,

01:33:58.370 --> 01:34:00.287
all of these recursive
steps are just adding 1

01:34:00.287 --> 01:34:02.745
to itself a bunch of times.

01:34:02.745 --> 01:34:04.870
But, of course, the way
you do that, the reason why

01:34:04.870 --> 01:34:06.040
you get a number
that is interesting,

01:34:06.040 --> 01:34:08.123
is because of all these
if statements and the fact

01:34:08.123 --> 01:34:10.090
that you can add two
different pluses coming

01:34:10.090 --> 01:34:11.870
from two different sources.

01:34:11.870 --> 01:34:12.430
OK.

01:34:12.430 --> 01:34:13.990
So I actually do
encourage you guys

01:34:13.990 --> 01:34:16.540
to look at the code in
the problem solution

01:34:16.540 --> 01:34:18.580
because I think it's a
nice example of taking

01:34:18.580 --> 01:34:20.920
this recursive formula and
then unrolling it into,

01:34:20.920 --> 01:34:22.802
like, iterating over a table.

01:34:22.802 --> 01:34:25.010
And that's a useful skill
that I intended to do today

01:34:25.010 --> 01:34:27.645
and then didn't actually
do very carefully.

01:34:27.645 --> 01:34:29.770
But with that, as usual,
we've gone over time here.

01:34:29.770 --> 01:34:31.240
So we'll call it for the day.

01:34:31.240 --> 01:34:34.720
And I will see you guys
when I see you guys.

01:34:34.720 --> 01:34:36.420
All right.