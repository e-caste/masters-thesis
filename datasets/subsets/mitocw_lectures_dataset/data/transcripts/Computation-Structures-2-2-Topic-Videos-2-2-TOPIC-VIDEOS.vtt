WEBVTT

00:00:00.530 --> 00:00:02.980
Consider the problem
of using voltages

00:00:02.980 --> 00:00:06.380
to represent the information
in a black-and-white image.

00:00:06.380 --> 00:00:10.400
Each (x,y) point in the image
has an associated intensity:

00:00:10.400 --> 00:00:14.610
black is the weakest
intensity, white the strongest.

00:00:14.610 --> 00:00:16.740
An obvious voltage-based
representation

00:00:16.740 --> 00:00:20.730
would be to encode the intensity
as a voltage, say 0V for black,

00:00:20.730 --> 00:00:23.560
1V for white, and some
intermediate voltage

00:00:23.560 --> 00:00:26.620
for intensities in-between.

00:00:26.620 --> 00:00:29.210
First question: how much
information is there

00:00:29.210 --> 00:00:31.510
at each point in the image?

00:00:31.510 --> 00:00:34.710
The answer depends on how well
we can distinguish intensities

00:00:34.710 --> 00:00:37.490
or, in our case, voltages.

00:00:37.490 --> 00:00:40.450
If we can distinguish
arbitrarily small differences,

00:00:40.450 --> 00:00:43.880
then there’s potentially an
infinite amount of information

00:00:43.880 --> 00:00:45.920
in each point of the image.

00:00:45.920 --> 00:00:48.690
But, as engineers, we
suspect there’s a lower-bound

00:00:48.690 --> 00:00:51.420
on the size of
differences we can detect.

00:00:51.420 --> 00:00:53.720
To represent the same amount
of information that can be

00:00:53.720 --> 00:00:57.100
represented with N bits, we
need to be able to distinguish

00:00:57.100 --> 00:01:00.500
a total 2^N voltages in
the range of 0V to 1V.

00:01:00.500 --> 00:01:04.900
For example, for N = 2, we’d
need to be able to distinguish

00:01:04.900 --> 00:01:07.190
between four possible voltages.

00:01:07.190 --> 00:01:10.550
That doesn’t seem too hard —
an inexpensive volt-meter would

00:01:10.550 --> 00:01:17.310
let us easily distinguish
between 0V, 1/3V, 2/3V and 1V.

00:01:17.310 --> 00:01:20.290
In theory, N can be
arbitrarily large.

00:01:20.290 --> 00:01:23.460
In practice, we know it would
be quite challenging to make

00:01:23.460 --> 00:01:26.260
measurements with, say, a
precision of 1-millionth

00:01:26.260 --> 00:01:29.000
of a volt and probably
next to impossible

00:01:29.000 --> 00:01:32.940
if we wanted a precision
of 1-billionth of a volt.

00:01:32.940 --> 00:01:36.000
Not only would the equipment
start to get very expensive

00:01:36.000 --> 00:01:38.290
and the measurements
very time consuming,

00:01:38.290 --> 00:01:41.190
but we’d discover that
phenomenon like thermal noise

00:01:41.190 --> 00:01:44.090
would confuse what we mean
by the instantaneous voltage

00:01:44.090 --> 00:01:46.170
at a particular time.

00:01:46.170 --> 00:01:49.540
So our ability to encode
information using voltages

00:01:49.540 --> 00:01:51.700
will clearly be
constrained by our ability

00:01:51.700 --> 00:01:53.770
to reliably and
quickly distinguish

00:01:53.770 --> 00:01:56.670
the voltage at particular time.

00:01:56.670 --> 00:01:59.190
To complete our project of
representing a complete image,

00:01:59.190 --> 00:02:02.270
we’ll scan the image in some
prescribed raster order —

00:02:02.270 --> 00:02:05.610
left-to-right, top-to-bottom
— converting intensities

00:02:05.610 --> 00:02:07.610
to voltages as we go.

00:02:07.610 --> 00:02:09.509
In this way, we can
convert the image

00:02:09.509 --> 00:02:12.720
into a time-varying
sequence of voltages.

00:02:12.720 --> 00:02:15.280
This is how the original
televisions worked:

00:02:15.280 --> 00:02:17.590
the picture was encoded
as a voltage waveform that

00:02:17.590 --> 00:02:19.670
varied between the
representation for black

00:02:19.670 --> 00:02:21.610
and that for white.

00:02:21.610 --> 00:02:23.130
Actually the range
of voltages was

00:02:23.130 --> 00:02:25.320
expanded to allow
the signal to specify

00:02:25.320 --> 00:02:28.940
the end of the horizontal
scan and the end of an image,

00:02:28.940 --> 00:02:31.680
the so-called sync signals.

00:02:31.680 --> 00:02:34.250
We call this a “continuous
waveform” to indicatuld
have to be made of precision

00:02:32.410 --> 00:02:35.320
components and run in
precisely-controlled physical

00:02:35.320 --> 00:02:36.530
environments

00:02:36.530 --> 00:02:39.080
— hard to accomplish when
we consider the multitude

00:02:39.080 --> 00:02:42.020
of environments and the
modest cost expectations

00:02:42.020 --> 00:02:45.160
for the systems
we want to build.

00:02:45.160 --> 00:02:48.100
So although this definition
has an appealing mathematical

00:02:48.100 --> 00:02:51.510
simplicity, it’s not workable
on practical grounds.

00:02:51.510 --> 00:02:53.030
This one gets a big red “X”.

00:02:55.560 --> 00:02:57.940
In our second attempt, we’ll
introduce two threshold

00:02:57.940 --> 00:03:01.510
voltages: V_L and V_H.

00:03:01.510 --> 00:03:05.670
Voltages less than or equal to
V_L will be interpreted as 0,

00:03:05.670 --> 00:03:08.140
and voltages greater
than or equal to V_H

00:03:08.140 --> 00:03:09.190
will be interpreted as 1.

00:03:09.190 --> 00:03:14.200
The range of voltages
between V_L and V_H is called

00:03:14.200 --> 00:03:17.720
the “forbidden zone”, where we
are forbidden to ask for any

00:03:17.720 --> 00:03:20.860
particular behavior
of our digital system.

00:03:20.860 --> 00:03:22.350
A particular system
can interpret

00:03:22.350 --> 00:03:26.120
a voltage in the forbidden
zone as either a 0 or a 1,

00:03:26.120 --> 00:03:28.530
and is not even required
to be consistent

00:03:28.530 --> 00:03:30.470
in its interpretation.

00:03:30.470 --> 00:03:32.110
In fact the system
is not required

00:03:32.110 --> 00:03:36.430
to produce any interpretation at
all for voltages in this range.

00:03:36.430 --> 00:03:38.680
How does this help?

00:03:38.680 --> 00:03:41.190
Now we can build a
quick-and-dirty voltage-to-bit

00:03:41.190 --> 00:03:44.500
converter, say by using a
high-gain op-amp and reference

00:03:44.500 --> 00:03:46.310
voltage somewhere in
the forbidden zone

00:03:46.310 --> 00:03:50.310
to decide if a given voltage
is above or below the threshold

00:03:50.310 --> 00:03:51.810
voltage.

00:03:51.810 --> 00:03:54.400
This reference voltage doesn’t
have to be super-accurate,

00:03:54.400 --> 00:03:56.180
so it could be
generated with, say,

00:03:56.180 --> 00:03:59.250
a voltage divider built
from low-cost 10%-accurate

00:03:59.250 --> 00:04:01.400
resistors.

00:04:01.400 --> 00:04:03.040
The reference could
change slightly

00:04:03.040 --> 00:04:05.570
as the operating temperature
varied or the power supply

00:04:05.570 --> 00:04:07.950
voltage changed, and so on.

00:04:07.950 --> 00:04:10.530
We only need to guarantee
the correct behavior

00:04:10.530 --> 00:04:16.140
of our converter for voltages
below V_L or above V_H.

00:04:16.140 --> 00:04:19.290
This representation is pretty
promising and we’ll tentatively

00:04:19.290 --> 00:04:22.110
give it a green
checkmark for now.

00:04:22.110 --> 00:04:24.560
After a bit more discussion,
we’ll need to make one more

00:04:24.560 --> 00:04:28.300
small tweak before we get
to where we want to go.expect the
output image to look like?

00:04:29.340 --> 00:04:32.670
Well, the COPY blocks don’t
change the image and there are

00:04:32.670 --> 00:04:35.780
an even number of INVERTING
blocks, so, in theory,

00:04:35.780 --> 00:04:39.960
the output image should be
identical to the input image.

00:04:39.960 --> 00:04:42.890
But in reality, the output
image isn’t a perfect copy

00:04:42.890 --> 00:04:43.590
of the input.

00:04:43.590 --> 00:04:47.060
It’s slightly fuzzy, the
intensities are slightly off

00:04:47.060 --> 00:04:50.300
and it looks like sharp changes
in intensity have been smoothed

00:04:50.300 --> 00:04:54.750
out, creating a blurry
reproduction of the original.

00:04:54.750 --> 00:04:57.320
What went wrong?

00:04:57.320 --> 00:04:59.990
Why doesn’t theory
match reality?

00:04:59.990 --> 00:05:03.810
Perhaps the COPY and INVERTING
blocks don’t work correctly?

00:05:03.810 --> 00:05:06.250
That’s almost certainly true,
in the sense that they don’t

00:05:06.250 --> 00:05:10.400
precisely obey the mathematical
description of their behavior.

00:05:10.400 --> 00:05:13.790
Small manufacturing variations
and differing environmental

00:05:13.790 --> 00:05:16.590
conditions will cause each
instance of the COPY block

00:05:16.590 --> 00:05:19.950
to produce not V volts
for a V-volt input,

00:05:19.950 --> 00:05:23.840
but V+epsilon volts, where
epsilon represents the amount

00:05:23.840 --> 00:05:26.700
of error introduced
during processing.

00:05:26.700 --> 00:05:29.280
Ditto for the INVERTING block.

00:05:29.280 --> 00:05:32.650
The difficulty is that in our
continuous-value representation

00:05:32.650 --> 00:05:37.240
of intensity, V+epsilon is a
perfectly correct output value,

00:05:37.240 --> 00:05:40.243
just not for a V-volt input!

00:05:40.243 --> 00:05:42.410
In other words, we can’t
tell the difference between

00:05:42.410 --> 00:05:45.770
a slightly corrupted signal
and a perfectly valid signal

00:05:45.770 --> 00:05:48.900
for a slightly different image.

00:05:48.900 --> 00:05:52.200
More importantly — and this is
the real killer — the errors

00:05:52.200 --> 00:05:55.560
accumulate as the encoded
image passes through the system

00:05:55.560 --> 00:05:58.050
of COPY and INVERTING blocks.

00:05:58.050 --> 00:05:59.970
The larger the
system, the larger

00:05:59.970 --> 00:06:03.010
the amount of accumulated
processing error.

00:06:03.010 --> 00:06:05.060
This doesn’t seem so good.

00:06:05.060 --> 00:06:06.930
It would be awkward,
to say the least,

00:06:06.930 --> 00:06:10.650
if we had to have rules about
how many computations could

00:06:10.650 --> 00:06:12.640
be performed on
encoded information

00:06:12.640 --> 00:06:17.452
before the results became
too corrupted to be usable.

00:06:17.452 --> 00:06:18.910
You would be correct
if you thought

00:06:18.910 --> 00:06:20.590
this meant that
the theory we used

00:06:20.590 --> 00:06:24.470
to describe the operation
of our system was imperfect.

00:06:24.470 --> 00:06:27.460
We’d need a very complicated
theory indeed to capture all

00:06:27.460 --> 00:06:30.300
the possible ways in which the
output signal could differ from

00:06:30.300 --> 00:06:32.830
its expected value.

00:06:32.830 --> 00:06:35.230
Those of us who are
mathematically minded might

00:06:35.230 --> 00:06:37.970
complain that “reality
is imperfect”.

00:06:37.970 --> 00:06:40.210
This is going a bit far though.

00:06:40.210 --> 00:06:42.960
Reality is what it
is and, as engineers,

00:06:42.960 --> 00:06:45.660
we need to build our
systems to operate reliably

00:06:45.660 --> 00:06:47.730
in the real world.

00:06:47.730 --> 00:06:50.190
So perhaps the real
problem lies in how we

00:06:50.190 --> 00:06:53.080
chose to engineer the system.

00:06:53.080 --> 00:06:55.030
In fact, all of
the above are true!

00:06:55.030 --> 00:06:57.900
Noise and inaccuracy
are inevitable.

00:06:57.900 --> 00:07:01.320
We can’t reliably reproduce
infinite information.

00:07:01.320 --> 00:07:04.160
We must design our system to
tolerate some amount of error

00:07:04.160 --> 00:07:07.120
if it is to process
information reliably.

00:07:07.120 --> 00:07:10.300
Basically, we need to find a way
to notice that errors have been

00:07:10.300 --> 00:07:13.020
introduced by a processing
step and restore

00:07:13.020 --> 00:07:15.350
the correct value before
the errors have a chance

00:07:15.350 --> 00:07:16.790
to accumulate.

00:07:16.790 --> 00:07:19.920
How to do that is
our next topic.