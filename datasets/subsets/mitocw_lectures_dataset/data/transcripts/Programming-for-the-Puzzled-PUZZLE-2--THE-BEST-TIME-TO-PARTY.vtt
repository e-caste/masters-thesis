WEBVTT

00:00:05.767 --> 00:00:08.100
SRINI DEVADAS: How many of
you have attended a celebrity

00:00:08.100 --> 00:00:10.520
party?

00:00:10.520 --> 00:00:11.630
I haven't.

00:00:11.630 --> 00:00:13.460
Well, if you count
MIT professors

00:00:13.460 --> 00:00:16.550
as being celebrities, I've
been to a lot of them,

00:00:16.550 --> 00:00:20.870
but that's not the case, right?

00:00:20.870 --> 00:00:25.034
People don't really think
of us as celebrities,

00:00:25.034 --> 00:00:25.950
which is fine with me.

00:00:31.940 --> 00:00:37.720
So this puzzle, I call it
the best time to party.

00:00:37.720 --> 00:00:52.536
And-- I'm having a little
trouble erasing the--

00:00:52.536 --> 00:00:56.570
oh you're right.

00:00:56.570 --> 00:00:59.390
There's another one?

00:00:59.390 --> 00:01:00.190
All right.

00:01:00.190 --> 00:01:02.500
Well, I'm probably going
to run out of this.

00:01:02.500 --> 00:01:03.460
But you know what?

00:01:03.460 --> 00:01:05.140
This time I'll use--

00:01:05.140 --> 00:01:07.780
I don't think I need
this super thick chalk.

00:01:07.780 --> 00:01:09.310
There's a slightly--

00:01:09.310 --> 00:01:10.060
I'll use this one.

00:01:23.310 --> 00:01:26.150
So setup here-- with
all of these things,

00:01:26.150 --> 00:01:28.490
there's always a
little bit of setup--

00:01:28.490 --> 00:01:31.920
is, you got a ticket
to this party.

00:01:31.920 --> 00:01:34.950
There are going to be
all these celebrities.

00:01:34.950 --> 00:01:39.720
And it's a timed ticket
with some flexibility.

00:01:39.720 --> 00:01:42.155
You only get to stay for
a certain amount of time

00:01:42.155 --> 00:01:44.030
before you have to leave
and other people are

00:01:44.030 --> 00:01:47.180
going to come in and hobnob
with these celebrities.

00:01:47.180 --> 00:01:51.300
But you get to pick the
particular time that you go,

00:01:51.300 --> 00:01:52.010
right?

00:01:52.010 --> 00:01:53.960
And so, initially,
we'll set things up

00:01:53.960 --> 00:01:56.020
in a fairly straightforward way.

00:01:56.020 --> 00:02:02.750
We're going to say that you
have an hour, a particular hour,

00:02:02.750 --> 00:02:05.250
maybe it's 6:00 to 7:00,
7:00 to 8:00, what have you.

00:02:05.250 --> 00:02:06.320
You get to choose.

00:02:06.320 --> 00:02:07.650
That's part of the puzzle.

00:02:07.650 --> 00:02:10.520
How do you pick the
best time to party?

00:02:10.520 --> 00:02:13.370
And you do have a schedule.

00:02:13.370 --> 00:02:16.010
And amazingly, these
celebrities are going

00:02:16.010 --> 00:02:17.570
to stick to those schedules.

00:02:17.570 --> 00:02:20.380
But the schedule has been
published with respect

00:02:20.380 --> 00:02:23.780
to when particular celebrities
are going to be at this party.

00:02:23.780 --> 00:02:24.830
All right?

00:02:24.830 --> 00:02:30.500
And as you can imagine, as the
title of the puzzle gives away,

00:02:30.500 --> 00:02:35.960
you want to choose the hour
such that the maximum number

00:02:35.960 --> 00:02:41.990
of celebrities-- so you're
not particularly interested

00:02:41.990 --> 00:02:47.900
in particular celebrities
or one specific celebrity,

00:02:47.900 --> 00:02:50.150
you just wanted sort of
max out number of selfies

00:02:50.150 --> 00:02:52.330
so you can put it on your
Facebook page, Instagram,

00:02:52.330 --> 00:02:53.420
what have you.

00:02:53.420 --> 00:02:55.520
And you have that
schedule and you're

00:02:55.520 --> 00:02:58.040
trying to optimize the number.

00:02:58.040 --> 00:03:00.860
So here you go.

00:03:00.860 --> 00:03:03.380
We're going to have a--

00:03:03.380 --> 00:03:06.980
let's just solve this
again manually first,

00:03:06.980 --> 00:03:09.680
and then we'll
think of algorithms.

00:03:09.680 --> 00:03:11.300
We're going to have
intervals again.

00:03:14.090 --> 00:03:22.190
And so think of these as hours.

00:03:22.190 --> 00:03:24.225
Beyonce comes in at
6:00, leaves at 7.

00:03:29.036 --> 00:03:30.285
Taylor from 7:00 through 9:00.

00:03:33.680 --> 00:03:36.886
Brad 10:00 to 11:00.

00:03:40.780 --> 00:03:44.982
Katie 10:00 to 12:00.

00:03:47.940 --> 00:03:52.367
Tom 8:00 to 10:00.

00:04:10.410 --> 00:04:11.850
Going to run out of room here.

00:04:11.850 --> 00:04:12.480
All right.

00:04:12.480 --> 00:04:15.210
So that's the schedule
that's published, right?

00:04:15.210 --> 00:04:18.060
And we can think
of these as hours--

00:04:18.060 --> 00:04:19.019
comes and goes.

00:04:19.019 --> 00:04:22.079
There's one small
subtlety, which

00:04:22.079 --> 00:04:24.930
is, I'm going to
think of these as

00:04:24.930 --> 00:04:30.790
closed intervals on the left
end and open at the right end.

00:04:30.790 --> 00:04:35.460
So all that means is,
if this is 6:00 PM,

00:04:35.460 --> 00:04:39.375
and if you come in at
6:00 PM on the dot, well,

00:04:39.375 --> 00:04:40.750
you certainly get
to see Beyonce.

00:04:40.750 --> 00:04:43.610
And if you come in at 6:59,
you get to see Beyonce,

00:04:43.610 --> 00:04:46.640
but if you come in
at 7:00, she's gone.

00:04:46.640 --> 00:04:47.910
Right?

00:04:47.910 --> 00:04:51.210
And the same thing
with Taylor at 9:00.

00:04:51.210 --> 00:04:56.280
So you you have to choose
your time properly.

00:04:56.280 --> 00:04:59.460
So what's the best time?

00:04:59.460 --> 00:05:02.120
You get to go for any
hour that you choose.

00:05:02.120 --> 00:05:04.890
What's the best
time to go to get

00:05:04.890 --> 00:05:07.190
the maximum number of selfies?

00:05:07.190 --> 00:05:08.910
Anyone?

00:05:08.910 --> 00:05:11.860
You can do this manually.

00:05:11.860 --> 00:05:16.960
Tell me what the time
is and then I'll ask you

00:05:16.960 --> 00:05:18.940
what your algorithm was?

00:05:18.940 --> 00:05:19.690
Right?

00:05:19.690 --> 00:05:23.160
So-- someone who
hasn't answered yet.

00:05:28.140 --> 00:05:29.634
Yep?

00:05:29.634 --> 00:05:31.740
AUDIENCE: Either 6:00 or 10:00.

00:05:31.740 --> 00:05:32.740
SRINI DEVADAS: Either 6:00
or-- what's your name?

00:05:32.740 --> 00:05:33.550
AUDIENCE: Kevin.

00:05:33.550 --> 00:05:33.860
SRINI DEVADAS: Oh!

00:05:33.860 --> 00:05:34.130
Kevin.

00:05:34.130 --> 00:05:34.670
Right.

00:05:34.670 --> 00:05:35.169
Sorry.

00:05:37.212 --> 00:05:38.170
You're the other Kevin.

00:05:38.170 --> 00:05:38.940
All right.

00:05:38.940 --> 00:05:41.472
So-- 6:00 o'clock
or 10:00 o'clock,

00:05:41.472 --> 00:05:43.430
because at 6:00 o'clock--
so who are the people

00:05:43.430 --> 00:05:44.513
you'd see at 6:00 o'clock?

00:05:44.513 --> 00:05:46.770
AUDIENCE: Beyonce
and Alicia Keys.

00:05:46.770 --> 00:05:48.966
SRINI DEVADAS: That's only two.

00:05:48.966 --> 00:05:49.850
AUDIENCE: Yeah.

00:05:49.850 --> 00:05:52.210
SRINI DEVADAS: So can
you do better than two?

00:05:52.210 --> 00:05:54.340
Can someone do better
than what Kevin did?

00:05:59.610 --> 00:06:00.300
Yeah, go ahead.

00:06:00.300 --> 00:06:01.743
Kanishka

00:06:01.743 --> 00:06:03.186
AUDIENCE: That will be Brad.

00:06:03.186 --> 00:06:05.591
So at 10:00, you'll get Brad.

00:06:05.591 --> 00:06:08.689
Katy, and Drake.

00:06:08.689 --> 00:06:09.480
SRINI DEVADAS: Yes.

00:06:09.480 --> 00:06:10.396
So you could do three.

00:06:10.396 --> 00:06:12.670
At 10:00, you would get Brad.

00:06:12.670 --> 00:06:16.360
You would get Katie, and
then you'd also get Drake.

00:06:16.360 --> 00:06:17.210
OK?

00:06:17.210 --> 00:06:18.190
So that's three.

00:06:18.190 --> 00:06:18.890
OK?

00:06:18.890 --> 00:06:24.890
So that's the best you can
do in this puzzle, right?

00:06:24.890 --> 00:06:27.080
But you may have
hundreds of celebrities

00:06:27.080 --> 00:06:28.830
and you want to
pick the right time.

00:06:28.830 --> 00:06:31.550
So obviously, we want to write
a computer program here, right?

00:06:31.550 --> 00:06:35.180
What algorithm,
Kevin or Kanishka

00:06:35.180 --> 00:06:37.790
did you use to do this?

00:06:37.790 --> 00:06:40.550
How do you do it in your head?

00:06:40.550 --> 00:06:44.966
AUDIENCE: I first
of all saw which

00:06:44.966 --> 00:06:47.800
were the good candidates or
shortlisting them essentially.

00:06:47.800 --> 00:06:49.840
SRINI DEVADAS: Did you
go, either one of you,

00:06:49.840 --> 00:06:52.760
did you go hour by hour?

00:06:52.760 --> 00:06:54.140
Did you go 6:00 o'clock--

00:06:54.140 --> 00:06:55.370
how many people are there?

00:06:55.370 --> 00:06:57.680
Or did you try and intersect,
or what did you do?

00:07:02.440 --> 00:07:05.160
What's a reasonable
way of proceeding here?

00:07:05.160 --> 00:07:05.810
Right?

00:07:05.810 --> 00:07:09.137
What's a reasonable
way of proceeding?

00:07:09.137 --> 00:07:10.720
Someone other than--
yeah, back there.

00:07:10.720 --> 00:07:14.309
AUDIENCE: Look at the most
frequent amount of time.

00:07:14.309 --> 00:07:16.100
SRINI DEVADAS: The
frequent amount of time?

00:07:16.100 --> 00:07:18.440
So look at the hours.

00:07:18.440 --> 00:07:20.304
You say 6:00 o'clock
and you try and see

00:07:20.304 --> 00:07:21.470
how many sixes are up there?

00:07:21.470 --> 00:07:22.722
Or-- right.

00:07:22.722 --> 00:07:23.430
What's your name?

00:07:23.430 --> 00:07:24.734
AUDIENCE: Nisha.

00:07:24.734 --> 00:07:26.150
SRINI DEVADAS: So
Nisha says she's

00:07:26.150 --> 00:07:28.250
going to go look
for 6:00 o'clock

00:07:28.250 --> 00:07:30.601
and see if many
sixes are up there.

00:07:30.601 --> 00:07:31.100
Right?

00:07:31.100 --> 00:07:32.570
And there's two sixes up there.

00:07:32.570 --> 00:07:35.250
And maybe that's why
Kevin said six, right?

00:07:35.250 --> 00:07:40.760
On the other hand, clearly that
didn't quite work in this case,

00:07:40.760 --> 00:07:44.660
because what happened was,
10:00 o'clock-- there's only two

00:07:44.660 --> 00:07:45.240
of those.

00:07:45.240 --> 00:07:47.210
And so that looks good,
too, 6:00 and 10:00,

00:07:47.210 --> 00:07:52.580
but you missed the fact that
10 exists in 9:00 and 11:00,

00:07:52.580 --> 00:07:53.210
correct?

00:07:53.210 --> 00:07:55.085
So you're not explicitly
seeing these things.

00:07:57.890 --> 00:07:59.360
But that gives you an algorithm.

00:07:59.360 --> 00:08:00.943
I mean, it does give
you an algorithm.

00:08:00.943 --> 00:08:03.920
The algorithm is--
let me go ahead

00:08:03.920 --> 00:08:06.750
and do a little bit better
than what you described,

00:08:06.750 --> 00:08:10.040
a little more
relaxed check, right?

00:08:10.040 --> 00:08:14.990
It's not just an identical, I
want six to be in the table.

00:08:14.990 --> 00:08:17.600
But I want to see
if six is contained

00:08:17.600 --> 00:08:21.470
in the interval associated
with any particular celebrity.

00:08:21.470 --> 00:08:22.040
Correct?

00:08:22.040 --> 00:08:25.520
So if I did six, I'd say six
is contained in this interval.

00:08:25.520 --> 00:08:27.020
It's not contained
in this interval.

00:08:27.020 --> 00:08:30.000
Not, not, not, not, yes.

00:08:30.000 --> 00:08:30.500
Right?

00:08:30.500 --> 00:08:31.970
So I'd get two.

00:08:31.970 --> 00:08:34.039
And then when I've
finally got to 10,

00:08:34.039 --> 00:08:38.460
I'd get contained, contained,
contained, and I'd get three.

00:08:38.460 --> 00:08:39.020
Right?

00:08:39.020 --> 00:08:42.890
So there's clearly
an algorithm here

00:08:42.890 --> 00:08:47.660
that depends on the number of
hours that you're looking at.

00:08:47.660 --> 00:08:52.730
Depends, really, on the
granularity of time, OK?

00:08:52.730 --> 00:08:57.560
So this particular algorithm
would say, let me go ahead

00:08:57.560 --> 00:09:03.500
and enumerate the different
times that I could possibly go.

00:09:03.500 --> 00:09:04.400
I could start 6:00.

00:09:04.400 --> 00:09:06.320
I could start at 7:00.

00:09:06.320 --> 00:09:07.940
But maybe we'll start at 6:30.

00:09:07.940 --> 00:09:10.240
I could go from 6:30 to 7:30.

00:09:10.240 --> 00:09:12.410
You're allowed to
do that, right?

00:09:12.410 --> 00:09:15.830
The point is, if you stick
with the original description,

00:09:15.830 --> 00:09:18.350
you could go ahead and
enumerate 6:00 through 12:00,

00:09:18.350 --> 00:09:20.870
and then you could generate
a bunch of different numbers

00:09:20.870 --> 00:09:22.880
associated with the
number of celebrities

00:09:22.880 --> 00:09:27.570
and you could go ahead and
pick what time you want to go.

00:09:27.570 --> 00:09:28.430
Right?

00:09:28.430 --> 00:09:32.930
So it's a little bit like our
previous puzzle in the sense

00:09:32.930 --> 00:09:37.850
that there's a relatively
straightforward strategy that

00:09:37.850 --> 00:09:42.230
enumerates different hours
and goes through and does

00:09:42.230 --> 00:09:45.650
a bunch of computation and
then picks the maximum,

00:09:45.650 --> 00:09:46.490
in this case.

00:09:46.490 --> 00:09:49.120
Previously, it was the minimum
for, you will all conform.

00:09:49.120 --> 00:09:51.320
Here, it's the maximum, right?

00:09:51.320 --> 00:09:55.940
What is a disadvantage of
this particular algorithm

00:09:55.940 --> 00:09:57.330
that we just described?

00:09:57.330 --> 00:10:01.777
What is one potential
disadvantage?

00:10:01.777 --> 00:10:02.277
Yeah?

00:10:05.560 --> 00:10:06.320
Go ahead, Fadi.

00:10:06.320 --> 00:10:09.270
AUDIENCE: Well, it's
not linear, so you have

00:10:09.270 --> 00:10:12.436
to make multiple passes on.

00:10:12.436 --> 00:10:14.269
First of all, you
have to enumerate

00:10:14.269 --> 00:10:15.352
all of the possible times.

00:10:15.352 --> 00:10:16.972
And then for every
time, you have

00:10:16.972 --> 00:10:20.220
to go through the list
over and over again.

00:10:20.220 --> 00:10:22.050
So there's a lot
of computational--

00:10:24.787 --> 00:10:26.620
SRINI DEVADAS: There's
a lot of computation.

00:10:26.620 --> 00:10:29.682
There's a lot of
computational overhead.

00:10:29.682 --> 00:10:31.140
Let me show you
what the code looks

00:10:31.140 --> 00:10:35.700
like for the straightforward
algorithm, all right?

00:10:35.700 --> 00:10:40.530
And so it's going to,
again, be intuitive.

00:10:40.530 --> 00:10:43.560
It's going to do exactly what
we just described, right?

00:10:43.560 --> 00:10:45.960
And so if you look at
what you have up there--

00:10:45.960 --> 00:10:52.470
schedule up there is simply
a set of intervals, right?

00:10:52.470 --> 00:10:54.330
And they're tuples.

00:10:54.330 --> 00:10:57.450
And so I have something that's
bigger than this example here,

00:10:57.450 --> 00:10:58.540
but it includes that.

00:10:58.540 --> 00:11:00.570
And there's a whole
bunch of things in there.

00:11:00.570 --> 00:11:04.020
And now I'm going to look at--

00:11:04.020 --> 00:11:07.424
this is just a start time
for a particular celebrity.

00:11:07.424 --> 00:11:09.090
This is the end time
for that celebrity.

00:11:09.090 --> 00:11:10.350
I'm just setting that up.

00:11:10.350 --> 00:11:14.130
And I'm going to go ahead and--

00:11:14.130 --> 00:11:19.807
I'm looking at for
each c in schedule,

00:11:19.807 --> 00:11:20.890
I'm going to look at this.

00:11:20.890 --> 00:11:21.973
I'm going to look at that.

00:11:21.973 --> 00:11:23.400
I'm going to look at that.

00:11:23.400 --> 00:11:30.570
I'm going to figure out what the
start time is and the end is.

00:11:30.570 --> 00:11:33.990
And I'm just doing
this simply because I

00:11:33.990 --> 00:11:40.110
want to figure out what the
earliest start time for any

00:11:40.110 --> 00:11:41.315
of these celebrities are.

00:11:41.315 --> 00:11:42.630
So in this case, it's six.

00:11:42.630 --> 00:11:44.985
And the latest time that
a celebrity is around

00:11:44.985 --> 00:11:45.990
is 12, right?

00:11:45.990 --> 00:11:48.170
So that's all of this
first thing does.

00:11:48.170 --> 00:11:51.540
It's just finding the range
that I have to deal with.

00:11:51.540 --> 00:11:53.430
So there's not much there.

00:11:53.430 --> 00:11:55.290
I'm going to go ahead
and compute what's

00:11:55.290 --> 00:11:57.000
called the celebrity density.

00:11:57.000 --> 00:11:58.530
And I'll show you
the code for that.

00:11:58.530 --> 00:12:01.150
But that's essentially
what we describe,

00:12:01.150 --> 00:12:04.590
which is for a particular
hour between start and end,

00:12:04.590 --> 00:12:07.380
how many celebrities do I see
at that particular hour, right?

00:12:07.380 --> 00:12:09.840
And then for the next hour,
how many celebrities do I see?

00:12:09.840 --> 00:12:14.040
I'm just calling it
the density, right?

00:12:14.040 --> 00:12:20.130
And then, the count
is a list that

00:12:20.130 --> 00:12:23.490
is going to have celebrity
densities for particular times

00:12:23.490 --> 00:12:26.400
that correspond to
the indices of count.

00:12:26.400 --> 00:12:28.500
And I'm just going to
go through that list

00:12:28.500 --> 00:12:31.590
and I'm going to figure out
the time that has max count,

00:12:31.590 --> 00:12:34.380
or the maximum number
of celebrities.

00:12:34.380 --> 00:12:36.840
And there's a couple of
different ways of doing that.

00:12:36.840 --> 00:12:40.640
Don't worry about that, but
I'm happy to answer questions

00:12:40.640 --> 00:12:43.810
if you have them.

00:12:43.810 --> 00:12:46.080
And then, I just
say the best time

00:12:46.080 --> 00:12:48.810
to end the party
is at this time.

00:12:48.810 --> 00:12:51.960
Time, which was discovered
here, and the number

00:12:51.960 --> 00:12:55.050
of celebrities who are going
to be attending is max count.

00:12:55.050 --> 00:12:55.900
OK.

00:12:55.900 --> 00:12:59.890
So this is essentially the
code for the algorithm.

00:12:59.890 --> 00:13:08.050
And this thing here is doing
the slightly more relaxed check

00:13:08.050 --> 00:13:11.460
that I alluded to, which
was like when you have 6:00,

00:13:11.460 --> 00:13:14.820
you're not just
looking for 6:00 here,

00:13:14.820 --> 00:13:18.600
you're looking for 6:00
within this interval

00:13:18.600 --> 00:13:19.870
that looks like this.

00:13:19.870 --> 00:13:23.100
So 6:00 is definitely within
this, but it would not be--

00:13:26.760 --> 00:13:34.230
6:00 is not inside 5:00 and 6:00
as I described to you before,

00:13:34.230 --> 00:13:34.890
right?

00:13:34.890 --> 00:13:36.690
So that's simply the check.

00:13:36.690 --> 00:13:39.450
That's why you have a
less than equal to here

00:13:39.450 --> 00:13:41.670
and a strictly greater
than over here,

00:13:41.670 --> 00:13:45.790
just to take care of that
closed and open part of it.

00:13:45.790 --> 00:13:47.850
So again, if you
don't understand

00:13:47.850 --> 00:13:50.160
every nuance in this code,
it's not that big a deal.

00:13:50.160 --> 00:13:53.740
But hopefully you have the
overall picture, right?

00:13:53.740 --> 00:13:55.590
Makes sense, right?

00:13:55.590 --> 00:13:59.040
So as you can imagine,
there's a much better way.

00:13:59.040 --> 00:14:00.840
There's a much
better way that isn't

00:14:00.840 --> 00:14:03.900
as exhaustive as this one.

00:14:03.900 --> 00:14:08.850
And do people have a sense of
what a better way would be,

00:14:08.850 --> 00:14:10.330
or would you like a hint?

00:14:10.330 --> 00:14:14.640
And anyone want to conjecture
a different way of solving this

00:14:14.640 --> 00:14:15.990
problem that's--

00:14:15.990 --> 00:14:16.895
yeah, go ahead.

00:14:16.895 --> 00:14:19.120
AUDIENCE: The exhaustiveness
of this algorithm?

00:14:19.120 --> 00:14:20.350
SRINI DEVADAS: Ah,
so the exhaustiveness

00:14:20.350 --> 00:14:22.120
of this algorithm is as follows.

00:14:22.120 --> 00:14:25.290
So basically what
I'm saying is--

00:14:25.290 --> 00:14:29.130
what I'm saying is I'm going to
go look at the range of times.

00:14:29.130 --> 00:14:31.320
And all of these
are per hour, right?

00:14:31.320 --> 00:14:32.830
Everything is per hour.

00:14:32.830 --> 00:14:34.830
I'm going to look at
the range of times,

00:14:34.830 --> 00:14:39.870
and I'm going to go
ahead and include 6:00

00:14:39.870 --> 00:14:41.220
through 12:00 here.

00:14:41.220 --> 00:14:42.900
And I'm going to
go 6:00, and I'm

00:14:42.900 --> 00:14:47.640
going to go figure out at 6:00
how many celebrities exist.

00:14:47.640 --> 00:14:49.290
And then at 7:00,
how many celebrities

00:14:49.290 --> 00:14:52.380
exist, and then at 8:00 all
the way to 12:00, right?

00:14:52.380 --> 00:14:56.400
And I'm going to get in count,
which is that list there, I'm

00:14:56.400 --> 00:14:58.220
going to get for each--

00:14:58.220 --> 00:15:02.730
for count 6:00, I'm
going to say two.

00:15:02.730 --> 00:15:07.960
And for count 10:00,
I'm going to get three,

00:15:07.960 --> 00:15:09.540
because 10 is the hour.

00:15:09.540 --> 00:15:11.290
And then I'm going to
go through that list

00:15:11.290 --> 00:15:14.200
and figure out that 10 had
the maximum number in it.

00:15:14.200 --> 00:15:16.400
And that's the
exhaustiveness, right?

00:15:16.400 --> 00:15:18.550
That make sense?

00:15:18.550 --> 00:15:20.840
So if we're good with
that, this algorithm works.

00:15:20.840 --> 00:15:24.330
But it's a little
painful, right?

00:15:24.330 --> 00:15:27.880
So what-- any ideas as
to how we could do things

00:15:27.880 --> 00:15:32.410
quite differently, which
would be more efficient?

00:15:32.410 --> 00:15:34.030
And let me give out the word.

00:15:34.030 --> 00:15:37.150
I want an incremental
way of doing this.

00:15:40.040 --> 00:15:41.310
How could I do this?

00:15:41.310 --> 00:15:45.380
I have a starting
time, and I want

00:15:45.380 --> 00:15:49.430
to compute the same densities
in an incremental way.

00:15:52.020 --> 00:15:56.300
Someone else other than Fadi?

00:15:56.300 --> 00:15:58.139
Yeah, back there.

00:15:58.139 --> 00:16:00.430
AUDIENCE: Well, you have to
start the n time thing just

00:16:00.430 --> 00:16:06.470
for each list of whatever
tuple or whatever you could

00:16:06.470 --> 00:16:09.040
keep like a count--
a different count,

00:16:09.040 --> 00:16:13.079
a dictionary of the start time,
and then increment through each

00:16:13.079 --> 00:16:15.579
of the start times until the
end and just add one each time.

00:16:15.579 --> 00:16:18.465
So you're basically iterating
through each set of times

00:16:18.465 --> 00:16:21.050
and finding the
count of each time

00:16:21.050 --> 00:16:22.560
and whichever time is the most.

00:16:22.560 --> 00:16:23.930
SRINI DEVADAS: You're
absolutely on the right track.

00:16:23.930 --> 00:16:26.130
And it turns out you don't
even need dictionaries.

00:16:26.130 --> 00:16:28.530
You can do this with
just plain lists.

00:16:28.530 --> 00:16:31.680
But the idea here is actually
a very compelling one.

00:16:31.680 --> 00:16:33.930
It's something that you'll
see in other algorithms.

00:16:33.930 --> 00:16:37.950
Whenever you have something
where you're doing repeated

00:16:37.950 --> 00:16:40.170
computation, there's always--

00:16:40.170 --> 00:16:45.400
many a time, there's a way of
removing redundancy and turning

00:16:45.400 --> 00:16:48.090
into incremental
computation, right?

00:16:48.090 --> 00:16:51.190
And so the insight
here is the following.

00:16:51.190 --> 00:16:55.290
The only time that
celebrity density, which

00:16:55.290 --> 00:16:58.640
is the number of celebrities
that are in the room, changes

00:16:58.640 --> 00:17:00.810
is obviously when
a celebrity enters

00:17:00.810 --> 00:17:03.570
or when a celebrity
leaves, right?

00:17:03.570 --> 00:17:04.380
I mean, that's it.

00:17:04.380 --> 00:17:06.799
I mean, we're all
celebrities here.

00:17:06.799 --> 00:17:10.170
And I guess we did have
someone leave, so there you go.

00:17:10.170 --> 00:17:12.520
And then maybe someone is
going to come in, right?

00:17:12.520 --> 00:17:17.579
So I just need to monitor
sort of input and output,

00:17:17.579 --> 00:17:20.369
or entry and exit.

00:17:20.369 --> 00:17:22.920
And I also know
what the endpoints

00:17:22.920 --> 00:17:29.250
are with respect to the 6:00,
6:00 PM versus 12:00, correct?

00:17:29.250 --> 00:17:32.300
So what I can do here
is the following.

00:17:37.440 --> 00:17:46.310
Suppose I had a chart that
looks like this, right?

00:17:46.310 --> 00:17:53.700
And what I'm drawing
here are these intervals.

00:17:53.700 --> 00:17:55.640
They aren't exactly
what I had up there,

00:17:55.640 --> 00:17:57.850
but I'm drawing those
intervals up, right?

00:17:57.850 --> 00:18:04.970
So you could think of this,
if you'd like, as being 6:00.

00:18:04.970 --> 00:18:08.810
You can think of
these two lined up

00:18:08.810 --> 00:18:11.150
as being 7:00, and
so on and so forth.

00:18:14.150 --> 00:18:15.530
So I could draw these out.

00:18:15.530 --> 00:18:18.070
And I don't really
have to draw these out

00:18:18.070 --> 00:18:21.900
in a computer program, but I
can certainly draw them out

00:18:21.900 --> 00:18:25.550
in terms of giving you
the intuition, right?

00:18:25.550 --> 00:18:28.510
So what I'm going to do is
I'm going to start with zero.

00:18:28.510 --> 00:18:31.830
So before 6:00, there's
absolutely no one in the room,

00:18:31.830 --> 00:18:34.130
so I'm at zero.

00:18:34.130 --> 00:18:36.170
And the moment I see--

00:18:38.840 --> 00:18:42.770
I take one of these things,
and if I see a celebrity,

00:18:42.770 --> 00:18:44.210
I can increment the count.

00:18:44.210 --> 00:18:49.580
So here at 5:00 I'm at
zero, at 6:00 I get one.

00:18:49.580 --> 00:18:55.870
And at 7:00, no one has
left, and two more people

00:18:55.870 --> 00:18:59.920
have come in, so I get three.

00:18:59.920 --> 00:19:03.620
And now, the next
thing happens out here.

00:19:03.620 --> 00:19:08.740
Let's say this one here is
8:00, I would get four for that.

00:19:08.740 --> 00:19:11.770
And then out here it's 9:00.

00:19:11.770 --> 00:19:16.180
I go 4 minus 1 equals 3,
because this celebrity left.

00:19:18.950 --> 00:19:21.580
So essentially,
what I want to do

00:19:21.580 --> 00:19:27.820
is not have to compute this over
and over for every time running

00:19:27.820 --> 00:19:29.950
through all of the
list of celebrities

00:19:29.950 --> 00:19:31.457
like I did before,
for 6:00, 7:00,

00:19:31.457 --> 00:19:33.040
through all the
celebrities for 7:00--

00:19:33.040 --> 00:19:34.540
I meant through all
the celebrities.

00:19:34.540 --> 00:19:42.163
But if I sort the celebrities
in increasing order of start

00:19:42.163 --> 00:19:45.970
times, essentially this
picture is important

00:19:45.970 --> 00:19:51.820
and it requires sorting, because
I went from left to right.

00:19:51.820 --> 00:19:54.340
And when I go from
left to right,

00:19:54.340 --> 00:19:56.620
I'm essentially
saying I want to see

00:19:56.620 --> 00:20:00.670
things that come earlier before
the ones that come later,

00:20:00.670 --> 00:20:01.210
right?

00:20:01.210 --> 00:20:03.730
That's essentially what time
goes to the right, right?

00:20:03.730 --> 00:20:05.420
So I'm going from left to right.

00:20:05.420 --> 00:20:13.600
So if I take these intervals and
I sort them, and basically sort

00:20:13.600 --> 00:20:19.960
them by the start times,
then all I need to do

00:20:19.960 --> 00:20:22.750
is, in the sorted
list of intervals,

00:20:22.750 --> 00:20:24.160
I just showed you
the computation

00:20:24.160 --> 00:20:26.406
that we have to perform.

00:20:26.406 --> 00:20:28.030
The computation that
we have to perform

00:20:28.030 --> 00:20:30.760
is-- this was the first
interval in the sorted list

00:20:30.760 --> 00:20:34.420
of intervals, because it
was the leftmost interval.

00:20:34.420 --> 00:20:38.620
And I take that and I go ahead
and increment it to one, right?

00:20:38.620 --> 00:20:42.070
Then, the next thing
I do is I don't

00:20:42.070 --> 00:20:45.490
have to worry about any time.

00:20:45.490 --> 00:20:47.260
Even if there was a
time, if this was 6:00

00:20:47.260 --> 00:20:50.860
and this was 8:00, for
example, as long as there's

00:20:50.860 --> 00:20:53.830
no celebrity that
came in at 7:00,

00:20:53.830 --> 00:20:56.470
there's no reason for
me to change anything

00:20:56.470 --> 00:20:58.360
in my data structure, right?

00:20:58.360 --> 00:21:00.820
The only times that
are interesting

00:21:00.820 --> 00:21:04.180
are when celebrities
enter and leave.

00:21:04.180 --> 00:21:06.430
So the other nice thing
about this algorithm

00:21:06.430 --> 00:21:09.580
is that it will
work if Beyonce came

00:21:09.580 --> 00:21:13.660
in at 6:39:39, 39 seconds--

00:21:13.660 --> 00:21:18.550
39 minutes, 39 seconds
and left at 6:51 whatever,

00:21:18.550 --> 00:21:22.540
because I'm only
concerned with the entry

00:21:22.540 --> 00:21:24.400
of a celebrity and the
exit of a celebrity

00:21:24.400 --> 00:21:30.130
that correspond to these points
that you see here, right?

00:21:30.130 --> 00:21:33.460
Does the algorithm make sense
from an intuitive standpoint?

00:21:33.460 --> 00:21:34.960
Do you see what's
happening here?

00:21:34.960 --> 00:21:37.420
Hopefully the picture
gives you a sense

00:21:37.420 --> 00:21:40.480
for how you're doing
the correct computation.

00:21:40.480 --> 00:21:42.520
And the only times
that things change

00:21:42.520 --> 00:21:45.580
are when-- at the end points
of these intervals, right?

00:21:45.580 --> 00:21:48.640
When you see someone, increment,
and when someone leaves,

00:21:48.640 --> 00:21:49.960
decrement, right?

00:21:49.960 --> 00:21:54.940
So this set of numbers
that you generate

00:21:54.940 --> 00:21:58.060
is essentially the
density down at the bottom

00:21:58.060 --> 00:22:02.980
that corresponds to, at
particular times, not

00:22:02.980 --> 00:22:05.830
necessarily on the hour, but
whenever the celebrities come

00:22:05.830 --> 00:22:07.180
and go.

00:22:07.180 --> 00:22:10.630
And so that list
that you get is all

00:22:10.630 --> 00:22:14.350
that you need to look at to
figure out what the maximum is,

00:22:14.350 --> 00:22:14.980
right?

00:22:14.980 --> 00:22:17.650
So ultimately down below,
in this particular example,

00:22:17.650 --> 00:22:20.860
perhaps four was the maximum.

00:22:20.860 --> 00:22:22.690
And it started with zero.

00:22:22.690 --> 00:22:26.121
It climbs up, maybe goes to
four, maybe goes to five,

00:22:26.121 --> 00:22:28.120
and then goes down again,
maybe climbs up again.

00:22:28.120 --> 00:22:30.400
Who cares?

00:22:30.400 --> 00:22:33.040
Once you get to the point where
you've written the program,

00:22:33.040 --> 00:22:35.500
size doesn't matter
anymore, right?

00:22:35.500 --> 00:22:37.120
So the last thing
I'll do is I'll

00:22:37.120 --> 00:22:38.330
show you the code for this.

00:22:38.330 --> 00:22:39.910
It will be up on the website.

00:22:39.910 --> 00:22:44.170
And feel free to
come to office hours

00:22:44.170 --> 00:22:46.750
and ask me questions
about the code,

00:22:46.750 --> 00:22:49.790
or before lecture tomorrow.

00:22:49.790 --> 00:22:53.110
But this is the
entirety of the code.

00:22:53.110 --> 00:22:58.140
And I'm not even using the built
in sort functions in Python.

00:22:58.140 --> 00:22:59.890
I went ahead and wrote
it just to give you

00:22:59.890 --> 00:23:02.560
a sense of how long
the code would be.

00:23:02.560 --> 00:23:04.450
But it's a much more
elegant algorithm.

00:23:04.450 --> 00:23:06.910
It would run faster
on large examples.

00:23:06.910 --> 00:23:09.250
And I don't want to get
into asymptotic complexity.

00:23:09.250 --> 00:23:12.440
That's really beyond this class.

00:23:12.440 --> 00:23:14.890
But as you can imagine,
rather than going

00:23:14.890 --> 00:23:18.040
through the list of
celebrities over and over,

00:23:18.040 --> 00:23:21.880
we're actually doing
sorting exactly once, right?

00:23:21.880 --> 00:23:23.230
So that's better.

00:23:23.230 --> 00:23:26.420
But essentially, what
happens here is simple.

00:23:26.420 --> 00:23:30.230
You go ahead and you
create each of these times.

00:23:30.230 --> 00:23:32.590
So this is particular
celebrity, particular time,

00:23:32.590 --> 00:23:34.510
and this is the start
point of the celebrity.

00:23:34.510 --> 00:23:36.160
So you have to mark that.

00:23:36.160 --> 00:23:38.470
This is very
different from that.

00:23:38.470 --> 00:23:42.970
What happens here
is I am adding.

00:23:42.970 --> 00:23:45.850
What happens here
is I'm subtracting.

00:23:45.850 --> 00:23:47.859
So I have to know
whether this point is

00:23:47.859 --> 00:23:49.150
very different from that point.

00:23:49.150 --> 00:23:51.430
This is the same as
that, same as that.

00:23:51.430 --> 00:23:52.990
And all of these
are similar, but I

00:23:52.990 --> 00:23:56.290
have to differentiate between
the two for obvious reasons.

00:23:56.290 --> 00:23:58.750
So I have to have start and end.

00:23:58.750 --> 00:24:01.270
And then I go ahead
and take these times.

00:24:01.270 --> 00:24:03.810
Each of these times that you
see with these black dots

00:24:03.810 --> 00:24:06.051
here, they all
need to be sorted,

00:24:06.051 --> 00:24:08.050
because that's the only
way I'm going to go from

00:24:08.050 --> 00:24:09.850
left to right, right?

00:24:09.850 --> 00:24:14.020
That's the only way, by going
through that list of times.

00:24:14.020 --> 00:24:16.300
So I'm going to go ahead
and do that sorting.

00:24:16.300 --> 00:24:18.310
And I could have done
times dot sort by the way.

00:24:18.310 --> 00:24:22.750
I don't have to have sort
list, but I just, as I said,

00:24:22.750 --> 00:24:25.360
I wanted to show you
the code without using

00:24:25.360 --> 00:24:27.580
any Python library functions.

00:24:27.580 --> 00:24:33.400
And then choose time is simply
looking through that list,

00:24:33.400 --> 00:24:36.460
finding that maximum
number, be it four or five,

00:24:36.460 --> 00:24:38.890
and returning the index of
that, because that tells you

00:24:38.890 --> 00:24:41.170
what the particular time is.

00:24:41.170 --> 00:24:44.050
And that time will always be--

00:24:44.050 --> 00:24:44.920
can someone tell me?

00:24:44.920 --> 00:24:46.390
Last question and
I'll let you go.

00:24:49.680 --> 00:24:53.170
What am I going to get--
on any given example, what

00:24:53.170 --> 00:24:59.610
am I going to get as the
best time, any given example?

00:24:59.610 --> 00:25:02.580
I'll get you if Ganatra.

00:25:02.580 --> 00:25:03.550
Yeah?

00:25:03.550 --> 00:25:05.940
AUDIENCE: A time when more
people come and leave.

00:25:05.940 --> 00:25:08.190
SRINI DEVADAS: A time when
more people come and leave.

00:25:08.190 --> 00:25:10.212
That's correct, but I
want something stronger.

00:25:10.212 --> 00:25:10.920
What's your name?

00:25:10.920 --> 00:25:11.730
AUDIENCE: Josh.

00:25:11.730 --> 00:25:12.210
SRINI DEVADAS: Josh?

00:25:12.210 --> 00:25:13.918
Yeah, Josh is right,
but I want something

00:25:13.918 --> 00:25:18.630
even stronger than a time that
more people come than leave.

00:25:18.630 --> 00:25:23.730
I mean, it's correct, but
a variant observation.

00:25:23.730 --> 00:25:25.970
Someone else?

00:25:25.970 --> 00:25:28.160
I want to say something about--

00:25:28.160 --> 00:25:31.640
there's two sets of
points here, right?

00:25:31.640 --> 00:25:33.970
There's two sets of points here.

00:25:33.970 --> 00:25:36.290
Which set of points
are going to be

00:25:36.290 --> 00:25:41.939
the ones that are in play, with
respect to the maximum time.

00:25:41.939 --> 00:25:43.230
That's maybe a better question.

00:25:46.200 --> 00:25:47.217
Go ahead.

00:25:47.217 --> 00:25:48.800
AUDIENCE: The arrival
time of someone.

00:25:48.800 --> 00:25:49.580
SRINI DEVADAS: That's right.

00:25:49.580 --> 00:25:51.360
That arrival time of
a celebrity, right?

00:25:51.360 --> 00:25:54.630
And it's true that what you
said, George is correct.

00:25:54.630 --> 00:25:56.250
Ultimately, the
best time is going

00:25:56.250 --> 00:26:01.740
to be when the maximum
number of arrivals happen.

00:26:01.740 --> 00:26:05.217
But the bottom line is,
I'm never going to--

00:26:05.217 --> 00:26:07.050
this is actually an
interesting observation,

00:26:07.050 --> 00:26:09.522
and there's an exercise
related to this observation

00:26:09.522 --> 00:26:10.980
for this puzzle
that you might want

00:26:10.980 --> 00:26:14.100
to look at that I'll
put up on the website

00:26:14.100 --> 00:26:15.650
as soon as we're done here.

00:26:15.650 --> 00:26:18.570
You're always going to pick
one of these beginning times,

00:26:18.570 --> 00:26:20.370
because that's when
the increment happens.

00:26:20.370 --> 00:26:22.453
You'd never pick one of
these, because that's when

00:26:22.453 --> 00:26:24.390
a decrement happens, right?

00:26:24.390 --> 00:26:25.860
So that's all I wanted to say.

00:26:25.860 --> 00:26:28.170
And the reason I wanted
to say that, as I said,

00:26:28.170 --> 00:26:31.470
there's an extra question
on top of this, and yet

00:26:31.470 --> 00:26:33.750
another algorithm
to solve this that

00:26:33.750 --> 00:26:37.020
is really based on that final
observation that we made.

00:26:37.020 --> 00:26:37.650
All right.

00:26:37.650 --> 00:26:38.610
Well, thank you.

00:26:38.610 --> 00:26:41.880
Sorry for going over, but
as I said, this is IAP.

00:26:41.880 --> 00:26:43.700
Forgive me.