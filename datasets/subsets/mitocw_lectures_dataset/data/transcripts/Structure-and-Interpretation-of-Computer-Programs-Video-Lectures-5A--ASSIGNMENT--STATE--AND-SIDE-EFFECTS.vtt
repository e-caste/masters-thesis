WEBVTT

00:00:00.000 --> 00:00:16.830
[MUSIC PLAYING]

00:00:16.830 --> 00:00:22.480
PROFESSOR: Well, so far we've
invented enough programming to

00:00:22.480 --> 00:00:24.850
do some very complicated
things.

00:00:24.850 --> 00:00:28.710
And you surely learned
a lot about

00:00:28.710 --> 00:00:29.760
programming at this point.

00:00:29.760 --> 00:00:32.189
You've learned almost all the
most important tricks that

00:00:32.189 --> 00:00:34.870
usually don't get taught to
people until they have had a

00:00:34.870 --> 00:00:36.610
lot of experience.

00:00:36.610 --> 00:00:40.800
For example, data directed
programming is a major trick,

00:00:40.800 --> 00:00:42.755
and yesterday you also saw
an interpreted language.

00:00:45.300 --> 00:00:50.320
We did this all in a computer
language, at this point, where

00:00:50.320 --> 00:00:54.020
there was no assignment
statement.

00:00:54.020 --> 00:00:56.790
And presumably, for those of you
who've seen your Basic or

00:00:56.790 --> 00:01:00.170
Pascal or whatever, that's
usually considered the most

00:01:00.170 --> 00:01:02.040
important thing.

00:01:02.040 --> 00:01:03.580
Well today, we're going to
do some thing horrible.

00:01:03.580 --> 00:01:07.370
We're going to add an assignment
statement.

00:01:07.370 --> 00:01:09.220
And since we can do all these
wonderful things without it,

00:01:09.220 --> 00:01:11.110
why should we add it?

00:01:11.110 --> 00:01:13.040
An important thing to understand
is that today we're

00:01:13.040 --> 00:01:17.270
going to, first of all, have a
rule, which is going to always

00:01:17.270 --> 00:01:19.520
be obeyed, which is the only
reason we ever add a feature

00:01:19.520 --> 00:01:23.636
to our language is because
there is a good reason.

00:01:23.636 --> 00:01:27.470
And the good reason is going to
boil down to the ability,

00:01:27.470 --> 00:01:30.500
you now get an ability to break
a problem into pieces

00:01:30.500 --> 00:01:32.010
that are different sets of
pieces then you could have

00:01:32.010 --> 00:01:35.380
broken it down without that,
give you another means of

00:01:35.380 --> 00:01:36.630
decomposition.

00:01:38.350 --> 00:01:39.490
However, let's just start.

00:01:39.490 --> 00:01:43.270
Let me quick begin by reviewing
the kind of language

00:01:43.270 --> 00:01:48.240
that we have now.

00:01:48.240 --> 00:01:51.310
We've been writing what's called
functional programs.

00:01:51.310 --> 00:01:56.770
And functional programs are
a kind of encoding of

00:01:56.770 --> 00:01:58.890
mathematical truths.

00:01:58.890 --> 00:02:02.420
For example, when we look at the
factorial procedure that

00:02:02.420 --> 00:02:07.090
you see on the slide here, it's
basically two clauses.

00:02:07.090 --> 00:02:09.530
If n is one, the result is
one, otherwise n times

00:02:09.530 --> 00:02:11.230
factorial n minus one.

00:02:11.230 --> 00:02:12.990
That's factorial of n.

00:02:12.990 --> 00:02:14.960
Well, that is factorial of n.

00:02:14.960 --> 00:02:17.120
And written down in some other
obscure notation that you

00:02:17.120 --> 00:02:22.310
might have learned in calculus
classes, mathematical logic,

00:02:22.310 --> 00:02:28.090
what you see there is if n
equals one, for the result of

00:02:28.090 --> 00:02:31.060
n factorial is one, otherwise,
greater than one, n factorial

00:02:31.060 --> 00:02:32.680
is n times n minus
one factorial.

00:02:32.680 --> 00:02:35.560
True statements, that's
the kind of

00:02:35.560 --> 00:02:37.000
language we've been using.

00:02:37.000 --> 00:02:39.610
And whenever we have true
statements of that sort, there

00:02:39.610 --> 00:02:47.490
is a kind of, a way of
understanding how they work

00:02:47.490 --> 00:02:50.170
which is that such processes
can be involved by

00:02:50.170 --> 00:02:51.390
substitution.

00:02:51.390 --> 00:02:56.230
And so we see on the second
slide here, that the way we

00:02:56.230 --> 00:03:02.010
understand the execution implied
by those statements in

00:03:02.010 --> 00:03:05.640
arranged in that order, is
that you do successive

00:03:05.640 --> 00:03:09.370
substitutions of arguments for
formal parameters in the body

00:03:09.370 --> 00:03:12.430
of a procedure.

00:03:12.430 --> 00:03:14.710
This is basically a sequence
of equalities.

00:03:14.710 --> 00:03:17.390
Factorial four is four times
factorial three.

00:03:17.390 --> 00:03:21.290
That is four times three times
factorial of two and so on.

00:03:21.290 --> 00:03:23.325
We're always preserving truth.

00:03:26.580 --> 00:03:29.190
Even though we're talking about
true statements, there

00:03:29.190 --> 00:03:31.390
might be more than one
organization of these true

00:03:31.390 --> 00:03:34.630
statements to describe the
computation of a particular

00:03:34.630 --> 00:03:37.490
function, the computation
of the value of

00:03:37.490 --> 00:03:38.640
a particular function.

00:03:38.640 --> 00:03:42.460
So, for example, looking
at the next one here.

00:03:42.460 --> 00:03:49.780
Here is a way of looking
at the sum of n and m.

00:03:49.780 --> 00:03:52.930
And we did this one by
a recursive process.

00:03:52.930 --> 00:04:00.130
It's the increment of the sum
of the decrement of n and m.

00:04:00.130 --> 00:04:03.780
And, of course, there is some
piece of mathematical logic

00:04:03.780 --> 00:04:06.240
here that describes that.

00:04:06.240 --> 00:04:11.450
It's the increment of the sum
of the decrement of n and m,

00:04:11.450 --> 00:04:13.120
just like that.

00:04:13.120 --> 00:04:16.440
So there's nothing particularly
magic about that.

00:04:16.440 --> 00:04:19.059
And, of course, if we can also
look at an iterative process

00:04:19.059 --> 00:04:22.920
for the same, a program that
evolves an iterative process,

00:04:22.920 --> 00:04:25.310
for the same function.

00:04:25.310 --> 00:04:29.930
These are two things that
compute the same answer.

00:04:29.930 --> 00:04:34.220
And we have equivalent
mathematical truths that are

00:04:34.220 --> 00:04:36.720
arranged there.

00:04:36.720 --> 00:04:38.920
And just the way you arrange
those truths determine the

00:04:38.920 --> 00:04:40.430
particular process.

00:04:40.430 --> 00:04:42.810
In the way choose and arrange
them determines the process

00:04:42.810 --> 00:04:44.400
that's evolved.

00:04:44.400 --> 00:04:47.370
So we have the flexibility
of talking about both the

00:04:47.370 --> 00:04:49.260
function to be computed,
and the method

00:04:49.260 --> 00:04:50.410
by which it's computed.

00:04:50.410 --> 00:04:53.580
So it's not clear
we need more.

00:04:53.580 --> 00:04:55.440
However, today I'm going
to this awful thing.

00:04:55.440 --> 00:04:59.070
I'm going to introduce this
assignment operation.

00:04:59.070 --> 00:05:02.890
Now, what is this?

00:05:02.890 --> 00:05:07.830
Well, first of all, there is
going to be another kind of

00:05:07.830 --> 00:05:09.960
kind of statement, if you
will, in a programming

00:05:09.960 --> 00:05:11.210
language called Set!

00:05:13.800 --> 00:05:16.550
Things that do things like
assignment, I'm going to put

00:05:16.550 --> 00:05:18.570
exclamation points after.

00:05:18.570 --> 00:05:20.990
We'll talk about what that
means in a second.

00:05:20.990 --> 00:05:23.370
The exclamation point, again
like question mark, is an

00:05:23.370 --> 00:05:25.960
arbitrary thing we attach to the
symbol which is the name,

00:05:25.960 --> 00:05:28.090
has no significance
to the system.

00:05:28.090 --> 00:05:31.520
The only significance is to me
and you to alert you that this

00:05:31.520 --> 00:05:35.910
is an assignment of some sort.

00:05:35.910 --> 00:05:39.960
But we're going to set a
variable to a value.

00:05:43.800 --> 00:05:47.120
And what that's going to mean
is that there is a time at

00:05:47.120 --> 00:05:48.600
which something happens.

00:05:48.600 --> 00:05:50.100
Here's a time.

00:05:50.100 --> 00:05:55.030
If I have time going this
way, it's a time access.

00:05:55.030 --> 00:05:58.650
Time progresses by walking
down the page.

00:05:58.650 --> 00:06:01.250
Then an assignment is the
first thing we have that

00:06:01.250 --> 00:06:06.670
produces the difference between
a before and an after.

00:06:06.670 --> 00:06:09.660
All the other programs that
we've written, that have no

00:06:09.660 --> 00:06:12.400
assignments in them, the order
in which they were evaluated

00:06:12.400 --> 00:06:14.590
didn't matter.

00:06:14.590 --> 00:06:17.990
But assignment is special, it
produces a moment in time.

00:06:17.990 --> 00:06:27.980
So there is a moment before the
set occurs and after, such

00:06:27.980 --> 00:06:39.500
that after this moment in time,
the variable has the

00:06:39.500 --> 00:06:43.320
value, value.

00:06:49.310 --> 00:06:53.340
Independent of what value
it had before, set!

00:06:53.340 --> 00:06:57.660
changes the value
of the variable.

00:06:57.660 --> 00:07:03.150
Until this moment, we had
nothing that changed.

00:07:03.150 --> 00:07:06.910
So, for example, one of the
things we can think of is that

00:07:06.910 --> 00:07:09.890
the procedures we write for
something like factorial are

00:07:09.890 --> 00:07:13.740
in fact pretty much identical
to the function factorial.

00:07:13.740 --> 00:07:18.120
Factorial of four, if I write
fact4, independent of what

00:07:18.120 --> 00:07:20.920
context it's in, and independent
of how many times

00:07:20.920 --> 00:07:23.040
I write it, I always get
the same answer.

00:07:23.040 --> 00:07:25.430
It's always 24.

00:07:25.430 --> 00:07:30.360
It's a unique map from the
argument to the answer.

00:07:30.360 --> 00:07:33.580
And all the programs we've
written so far are like that.

00:07:33.580 --> 00:07:37.020
However, once I have assignment,
that isn't true.

00:07:37.020 --> 00:07:50.070
So, for example, if I were to
define count to be one.

00:07:50.070 --> 00:07:55.550
And then I'm going to define
also a procedure, a simple

00:07:55.550 --> 00:08:02.960
procedure called demo, which
takes argument x and does the

00:08:02.960 --> 00:08:03.870
following operations.

00:08:03.870 --> 00:08:09.650
It first sets x to x plus one.

00:08:09.650 --> 00:08:13.160
My gosh, this looks just
like FORTRAN, right--

00:08:13.160 --> 00:08:14.410
in a funny syntax.

00:08:16.910 --> 00:08:24.330
And then add to x count, Oh,
I just made a mistake.

00:08:24.330 --> 00:08:27.010
I want to say, set! count
to one plus count.

00:08:30.310 --> 00:08:31.730
It's this thing defined here.

00:08:34.350 --> 00:08:36.369
And then plus x count.

00:08:40.409 --> 00:08:42.559
Then I can try this procedure.

00:08:42.559 --> 00:08:43.880
Let's run it.

00:08:43.880 --> 00:08:48.125
So, suppose I get a prompt
and I say, demo three.

00:08:52.210 --> 00:08:53.540
Well, what happens here?

00:08:53.540 --> 00:08:57.020
The first thing that happens
is count is currently one.

00:08:57.020 --> 00:08:59.130
Currently, there is a time.

00:08:59.130 --> 00:09:00.710
We're talking about time.

00:09:00.710 --> 00:09:02.960
x gets three.

00:09:02.960 --> 00:09:06.090
At this moment, I say,
oh yes, count is

00:09:06.090 --> 00:09:08.690
incremented, so count is two.

00:09:08.690 --> 00:09:10.710
two plus three is five.

00:09:10.710 --> 00:09:14.460
So the answer I get
out is five.

00:09:14.460 --> 00:09:23.640
Then I say, demo of
say, three again.

00:09:23.640 --> 00:09:24.830
What do I get?

00:09:24.830 --> 00:09:29.310
Well, now count is two, it's
not one anymore, because I

00:09:29.310 --> 00:09:30.760
have incremented it.

00:09:30.760 --> 00:09:35.050
But now I go through this
process, three goes into x,

00:09:35.050 --> 00:09:38.160
count becomes one plus count,
so that's three now.

00:09:38.160 --> 00:09:42.130
The sum of those two is six,
so the answer is six.

00:09:42.130 --> 00:09:45.760
And what we see is the same
expression leads to two

00:09:45.760 --> 00:09:52.170
different answers, depending
upon time.

00:09:52.170 --> 00:09:55.040
So demo is not a function,
does not compute a

00:09:55.040 --> 00:09:56.290
mathematical function.

00:10:00.020 --> 00:10:03.180
In fact, you could also see why
now, of course, this is

00:10:03.180 --> 00:10:05.650
the first place where the
substitution model

00:10:05.650 --> 00:10:07.780
isn't going to work.

00:10:07.780 --> 00:10:11.410
This kills the substitution
model dead.

00:10:11.410 --> 00:10:14.060
You know, with quotation there
were some little problems that

00:10:14.060 --> 00:10:17.380
a philosopher might notice
with the substitutions,

00:10:17.380 --> 00:10:19.560
because you have to worry about
what deductions you can

00:10:19.560 --> 00:10:23.070
make when you substitute into
quotes, if you're allowed to

00:10:23.070 --> 00:10:25.150
do that at all.

00:10:25.150 --> 00:10:28.590
But here the substitution
model is dead, can't do

00:10:28.590 --> 00:10:29.810
anything at all.

00:10:29.810 --> 00:10:34.490
Because, supposing I wanted to
use a substitution model to

00:10:34.490 --> 00:10:37.560
consider substituting
for count?

00:10:37.560 --> 00:10:42.150
Well, my gosh, if I substitute
for here and here, they're

00:10:42.150 --> 00:10:44.540
different ones.

00:10:44.540 --> 00:10:46.570
It's not the same
count any more.

00:10:46.570 --> 00:10:47.880
I get the wrong answer.

00:10:47.880 --> 00:10:51.410
The substitution model is
a static phenomenon that

00:10:51.410 --> 00:10:55.560
describes things that are true
and not things that change.

00:10:55.560 --> 00:10:56.810
Here, we have truths
that change.

00:11:01.860 --> 00:11:06.770
OK, Well, before I give you
any understanding of this,

00:11:06.770 --> 00:11:07.870
this is very bad.

00:11:07.870 --> 00:11:11.520
Now, we've lost our model
of computation.

00:11:11.520 --> 00:11:13.420
Pretty soon, I'm going to have
to build you a new model of

00:11:13.420 --> 00:11:15.030
computation.

00:11:15.030 --> 00:11:18.710
But ours plays with this, just
now, in an informal sense.

00:11:18.710 --> 00:11:21.490
Of course, what you already
see is that when I have

00:11:21.490 --> 00:11:24.600
something like assignment, the
model that we're going to need

00:11:24.600 --> 00:11:27.760
is different from the model that
we had before in that the

00:11:27.760 --> 00:11:31.840
variables, those symbols like
count, or x are no longer

00:11:31.840 --> 00:11:35.010
going to refer to the values
they have, but rather to some

00:11:35.010 --> 00:11:37.810
sort of place where the
value restored.

00:11:37.810 --> 00:11:40.330
We're going to have to think
that way for a while.

00:11:40.330 --> 00:11:42.290
And it's going to be a
very bad thing and

00:11:42.290 --> 00:11:44.590
cause a lot of trouble.

00:11:44.590 --> 00:11:47.350
And so, as I said, the very fact
that we're inventing this

00:11:47.350 --> 00:11:49.750
bad thing, means that there had
better be a good reason

00:11:49.750 --> 00:11:52.040
for it, otherwise, just
a waste of time

00:11:52.040 --> 00:11:53.510
and a lot of effort.

00:11:53.510 --> 00:11:56.090
Let's just look at some
of it just to play.

00:11:56.090 --> 00:11:59.130
Supposing we write down the
functional version, functional

00:11:59.130 --> 00:12:02.770
meaning in the old style,
of factorial by

00:12:02.770 --> 00:12:04.430
an iterative process.

00:12:09.780 --> 00:12:26.810
Factorial of n, we're going to
iterate of m and i, which says

00:12:26.810 --> 00:12:40.030
if i is greater than n, then
the result is m, otherwise,

00:12:40.030 --> 00:12:46.930
the result of iterating the
product of i and m.

00:12:46.930 --> 00:12:51.690
So m is going to be the product
that I'm accumulating.

00:12:51.690 --> 00:12:52.940
m is the product.

00:12:58.170 --> 00:12:59.990
And the count I'm going
to increase by one.

00:13:04.810 --> 00:13:12.060
Plus, ITER, ELSE,
COND, define.

00:13:12.060 --> 00:13:13.310
I'm going to start this up.

00:13:17.000 --> 00:13:18.980
And these days, you should
have no trouble reading

00:13:18.980 --> 00:13:21.020
something like this.

00:13:21.020 --> 00:13:23.750
What I have here is a
product there being

00:13:23.750 --> 00:13:26.750
accumulated and a counter.

00:13:26.750 --> 00:13:29.050
I start them up both at one.

00:13:29.050 --> 00:13:32.380
I'm going to buzz the counter
up, i goes to i plus one every

00:13:32.380 --> 00:13:34.800
time around.

00:13:34.800 --> 00:13:38.910
But that's only our putting a
time on the process, each of

00:13:38.910 --> 00:13:42.840
this is just a set of
truths, true rules.

00:13:42.840 --> 00:13:47.010
And m is going to get a new
values of i and m, i times m

00:13:47.010 --> 00:13:49.860
each time around, and eventually
i is going to be

00:13:49.860 --> 00:13:52.750
bigger than n, in which case,
the answer's going to be m.

00:13:52.750 --> 00:13:55.760
Now, I'm speaking to you,
use time in this.

00:13:55.760 --> 00:13:58.210
That's just because I know
how the computer works.

00:13:58.210 --> 00:13:59.090
But I didn't have to.

00:13:59.090 --> 00:14:01.810
This could be a purely
mathematical description at

00:14:01.810 --> 00:14:03.040
this point, because
substitution

00:14:03.040 --> 00:14:05.280
will work for this.

00:14:05.280 --> 00:14:08.870
But let's set right down a
similar sort of program, using

00:14:08.870 --> 00:14:11.975
the same algorithm, but
with assignments.

00:14:15.296 --> 00:14:16.940
So this is called the
functional version.

00:14:23.840 --> 00:14:25.255
I want to write down an
imperative version.

00:14:34.150 --> 00:14:36.010
Factorial of n.

00:14:36.010 --> 00:14:37.510
I'm going to create
my two variables.

00:14:40.120 --> 00:14:48.230
Let i initialize itself to one,
and m be initialized to

00:14:48.230 --> 00:14:50.930
one, similar.

00:14:50.930 --> 00:15:05.840
We'll create a loop which has
COND greater than i, and if i

00:15:05.840 --> 00:15:07.360
is greater than n, we're done.

00:15:07.360 --> 00:15:10.910
And the result is m, the product
I'm accumulating.

00:15:10.910 --> 00:15:19.320
Otherwise, I'm going to write
down three things to do.

00:15:19.320 --> 00:15:22.300
I'm going to set!

00:15:22.300 --> 00:15:34.610
m to the product of i and m,
set! i to the sum of i and

00:15:34.610 --> 00:15:40.610
one, and go around
the loop again.

00:15:40.610 --> 00:15:44.890
Looks very familiar to you
FORTRAN programmers.

00:15:44.890 --> 00:15:47.760
ELSE, COND, define, funny
syntax though.

00:15:51.270 --> 00:15:59.320
Start the loop up, and
that's the program.

00:15:59.320 --> 00:16:02.790
Now, this program, how
do we think about it?

00:16:02.790 --> 00:16:04.690
Well, let's just say what
we're seeing here.

00:16:04.690 --> 00:16:07.820
There are two local variables,
i and m, that have been

00:16:07.820 --> 00:16:10.810
initialized to one.

00:16:10.810 --> 00:16:13.120
Every time around the loop, I
test to see if i is greater

00:16:13.120 --> 00:16:16.040
than n, which is the input
argument, and if so, the

00:16:16.040 --> 00:16:19.240
result is the product being
accumulated in m.

00:16:19.240 --> 00:16:23.640
However, if it's not the end of
the loop, if I'm not done,

00:16:23.640 --> 00:16:26.260
then what I'm going to do is
change the product to be the

00:16:26.260 --> 00:16:29.130
result of multiplying i times
the current product.

00:16:29.130 --> 00:16:31.530
Which is sort of what
we were doing here.

00:16:31.530 --> 00:16:33.386
Except here I wasn't changing.

00:16:33.386 --> 00:16:38.220
I was making another copy,
because the substitution model

00:16:38.220 --> 00:16:44.410
says, you copy the body of the
procedure with the arguments

00:16:44.410 --> 00:16:46.710
substituted for the
formal parameters.

00:16:46.710 --> 00:16:49.690
Here I'm not worried about
copying, here I've changed the

00:16:49.690 --> 00:16:51.990
value of m.

00:16:51.990 --> 00:16:56.090
I also then change the value
of i to i plus one, and go

00:16:56.090 --> 00:16:58.300
buzzing around.

00:16:58.300 --> 00:17:01.360
Seems like essentially the same
program, but there are

00:17:01.360 --> 00:17:03.110
some ways of making
errors here that

00:17:03.110 --> 00:17:06.160
didn't exist until today.

00:17:06.160 --> 00:17:10.660
For example, if I were to do
the horrible thing of not

00:17:10.660 --> 00:17:15.329
being careful in writing my
program and interchange those

00:17:15.329 --> 00:17:17.890
two assignments, the
program wouldn't

00:17:17.890 --> 00:17:20.339
compute the same function.

00:17:20.339 --> 00:17:24.859
I get a timing error because
there's a dependency that m

00:17:24.859 --> 00:17:27.460
depends upon having the
last value of i.

00:17:27.460 --> 00:17:32.760
If I try to i first, then I've
got the wrong value of i when

00:17:32.760 --> 00:17:36.060
I multiply by m.

00:17:36.060 --> 00:17:38.600
It's a bug that wasn't available
until this moment,

00:17:38.600 --> 00:17:40.660
until we introduced something
that had time in it.

00:17:43.470 --> 00:17:47.650
So, as I said, first we need a
new model of computation, and

00:17:47.650 --> 00:17:49.790
second, we have to be damn good
reason for doing this

00:17:49.790 --> 00:17:52.800
kind of ugly thing.

00:17:52.800 --> 00:17:54.050
Are there any questions?

00:17:58.800 --> 00:18:00.505
Speak loudly, David.

00:18:00.505 --> 00:18:04.220
AUDIENCE: I'm confused about,
we've introduced set now, but

00:18:04.220 --> 00:18:07.630
we had let before and
define before.

00:18:07.630 --> 00:18:09.980
I'm confused about the
difference between the three.

00:18:09.980 --> 00:18:14.100
Wouldn't define work in the same
situation as set if you

00:18:14.100 --> 00:18:15.280
introduced it a bit?

00:18:15.280 --> 00:18:18.230
PROFESSOR: No, define is
intended for setting something

00:18:18.230 --> 00:18:20.230
once the first time,
for making it.

00:18:22.790 --> 00:18:26.440
You've never seen me write on a
blackboard two defines in a

00:18:26.440 --> 00:18:30.940
row whose intention was to
change the old value of some

00:18:30.940 --> 00:18:31.970
variable to a new one.

00:18:31.970 --> 00:18:34.380
AUDIENCE: Is that by
convention or--

00:18:34.380 --> 00:18:38.120
PROFESSOR: No, it's intention.

00:18:38.120 --> 00:18:41.680
The answer is that, for
example, internal to a

00:18:41.680 --> 00:18:47.250
procedure, two defines in a row
are illegal, two defines

00:18:47.250 --> 00:18:49.850
in a row of the same variable.

00:18:49.850 --> 00:18:51.890
x can't be defined twice.

00:18:51.890 --> 00:18:54.300
Whether or not a system catches
that error is a

00:18:54.300 --> 00:18:58.840
different question, but I
legislate to you that define

00:18:58.840 --> 00:19:00.840
happens once on anything.

00:19:00.840 --> 00:19:04.770
Now, indeed, in interactive
debugging, we intend that you

00:19:04.770 --> 00:19:08.460
interacting with your computer
will redefine things, and so

00:19:08.460 --> 00:19:10.050
there's a special
exception made

00:19:10.050 --> 00:19:11.610
for interactive debugging.

00:19:11.610 --> 00:19:18.480
But define is intended to mean
to set up something which will

00:19:18.480 --> 00:19:22.460
be forever that value
after that point.

00:19:22.460 --> 00:19:26.490
It's as if all the defines were
done at the beginning.

00:19:26.490 --> 00:19:29.870
In fact, the only legal place
to put a define in Scheme,

00:19:29.870 --> 00:19:32.570
internal to a procedure, is
just at the beginning of a

00:19:32.570 --> 00:19:36.605
lambda expression,
the beginning of

00:19:36.605 --> 00:19:37.855
the body of a procedure.

00:19:41.750 --> 00:19:46.670
Now, let of course does nothing
like either of that.

00:19:46.670 --> 00:19:50.520
I mean, if you look at what's
happening with a let, this

00:19:50.520 --> 00:19:52.220
happens again exactly once.

00:19:52.220 --> 00:19:56.820
It sets up a context where i and
m are values one and one.

00:19:56.820 --> 00:20:01.630
That context exists throughout
this scope, this

00:20:01.630 --> 00:20:02.880
region of the program.

00:20:05.080 --> 00:20:11.110
However, you don't think of that
let as setting i again.

00:20:11.110 --> 00:20:12.350
It doesn't change it.

00:20:12.350 --> 00:20:15.390
i never changes because
of the let.

00:20:15.390 --> 00:20:18.690
i gets created because of let.

00:20:18.690 --> 00:20:22.300
In fact, the let is a
very simple idea.

00:20:22.300 --> 00:20:30.930
Let does nothing more, Let a
variable one to have value

00:20:30.930 --> 00:20:37.660
one; I'll write this down a
little bit more neatly; Let's

00:20:37.660 --> 00:20:43.890
write, var one have value, the
value of expression e1, and

00:20:43.890 --> 00:20:48.470
variable two, have this value
of the expression e2, in an

00:20:48.470 --> 00:21:00.420
expression e3, is the same thing
as a procedure of var

00:21:00.420 --> 00:21:08.460
one and var two, the formal
parameters, and e3 being the

00:21:08.460 --> 00:21:15.010
body, where var one is bound
to the value of e1, and var

00:21:15.010 --> 00:21:16.820
two gets the value of e2.

00:21:19.590 --> 00:21:22.050
So this is, in fact, a perfectly
understandable thing

00:21:22.050 --> 00:21:24.930
from a substitution
point of view.

00:21:24.930 --> 00:21:27.300
This is really the same
expression written in two

00:21:27.300 --> 00:21:28.550
different ways.

00:21:31.820 --> 00:21:34.220
In fact, the way the actual
system works is this gets

00:21:34.220 --> 00:21:37.311
translated into this before
anything happens.

00:21:37.311 --> 00:21:39.690
AUDIENCE: OK, I'm still unclear
as then what makes the

00:21:39.690 --> 00:21:41.360
difference between a
let and a define.

00:21:41.360 --> 00:21:42.125
They could--

00:21:42.125 --> 00:21:45.570
PROFESSOR: A define is a
syntactic sugar, whereby,

00:21:45.570 --> 00:21:48.270
essentially a bunch of variables
get created by lets

00:21:48.270 --> 00:21:49.520
and then set up once.

00:21:57.170 --> 00:21:58.790
OK, time for the first
break, I think.

00:21:58.790 --> 00:22:00.040
Thank you.

00:22:03.480 --> 00:23:04.430
[MUSIC PLAYING]

00:23:04.430 --> 00:23:06.530
Well let's see.

00:23:06.530 --> 00:23:10.520
I now have to rebuild the model
of computation, so you

00:23:10.520 --> 00:23:13.690
understand how some such
mechanical mechanism could

00:23:13.690 --> 00:23:17.600
work that can do what we've
just talked about.

00:23:17.600 --> 00:23:22.730
I just recently destroyed
your substitution model.

00:23:22.730 --> 00:23:25.070
Unfortunately, this model is
significantly more complicated

00:23:25.070 --> 00:23:26.380
than the substitution model.

00:23:26.380 --> 00:23:29.010
It's called the environment
model.

00:23:29.010 --> 00:23:32.130
And I'm going to have to
introduce some terminology,

00:23:32.130 --> 00:23:34.660
which is very good terminology
for you to know anyway.

00:23:34.660 --> 00:23:36.640
It's about names.

00:23:36.640 --> 00:23:39.360
And we're going to give names
to the kinds of names things

00:23:39.360 --> 00:23:42.720
have and the way those
names are used.

00:23:42.720 --> 00:23:48.290
So this is a meta-description,
if you will.

00:23:48.290 --> 00:23:50.840
Anyway, there is a pile of an
unfortunate terminology here,

00:23:50.840 --> 00:23:52.730
but we're going to need this
to understand what's called

00:23:52.730 --> 00:23:54.770
the environment model.

00:23:54.770 --> 00:23:58.250
We're about to do a little bit
of boring, dog-work here.

00:23:58.250 --> 00:24:02.280
Let's look at the first
transparency.

00:24:02.280 --> 00:24:08.880
And we see a description
of a word called bound.

00:24:08.880 --> 00:24:11.980
And we're going to say that a
variable, v, is bound in an

00:24:11.980 --> 00:24:16.890
expression, e, if the meaning
of e is unchanged by the

00:24:16.890 --> 00:24:22.520
uniform replacement of a
variable w, not occurring in

00:24:22.520 --> 00:24:25.440
e, for every occurrence
of v in e.

00:24:25.440 --> 00:24:28.390
Now that's a long sentence, so,
I think, I'm going to have

00:24:28.390 --> 00:24:31.690
to say a little bit about
that before we even fool

00:24:31.690 --> 00:24:33.490
around at all here.

00:24:33.490 --> 00:24:35.260
Bound variables we're
talking about here.

00:24:44.030 --> 00:24:46.710
And you've seen lots of them.

00:24:46.710 --> 00:24:48.170
You may not know that you've
seen lots of them.

00:24:48.170 --> 00:24:51.880
Well, I suppose in your logic
you saw a logical variables

00:24:51.880 --> 00:24:58.210
like, for every x there exists
a y such that p is true of x

00:24:58.210 --> 00:24:59.860
and y from your calculus
class.

00:25:02.960 --> 00:25:06.780
This variable, x, and this
variable, y, are bound,

00:25:06.780 --> 00:25:10.920
because the meaning of this
expression does not depend

00:25:10.920 --> 00:25:16.640
upon the particular letters I
used to describe x and y.

00:25:16.640 --> 00:25:21.740
If I were to change the w for x,
then said for every w there

00:25:21.740 --> 00:25:26.420
exists a y such that p is true
of w and y, it would be the

00:25:26.420 --> 00:25:29.540
same sentence.

00:25:29.540 --> 00:25:30.390
That's what it means.

00:25:30.390 --> 00:25:35.690
Or another case of this that
you've seen is integral say,

00:25:35.690 --> 00:25:42.415
from 0 to one of dx over
one plus x square.

00:25:46.080 --> 00:25:47.440
Well that's something you
see all the time.

00:25:47.440 --> 00:25:52.270
And this x is a bound
variable.

00:25:52.270 --> 00:25:55.190
If I change that to a
t, the expression is

00:25:55.190 --> 00:25:58.170
still the same thing.

00:25:58.170 --> 00:26:04.850
This is a 1/4 of the arctan of
one or something like that.

00:26:04.850 --> 00:26:06.620
Yes, that's the arctan of one.

00:26:06.620 --> 00:26:09.380
So bound variables are actually
fairly common, for

00:26:09.380 --> 00:26:13.690
those of you who have played
a bit with mathematics.

00:26:13.690 --> 00:26:19.100
Well, let's go into the
programming world.

00:26:19.100 --> 00:26:22.220
Instead of the quantifier being
something like, for

00:26:22.220 --> 00:26:25.000
every, or there exists, or
integral, a quantifier is a

00:26:25.000 --> 00:26:27.570
symbol that binds a variable.

00:26:27.570 --> 00:26:30.280
And we are going to use the
quantifier lambda as being the

00:26:30.280 --> 00:26:33.970
essential thing that
binds variables.

00:26:33.970 --> 00:26:37.730
And so we have some nice
examples here like that

00:26:37.730 --> 00:26:43.160
procedure of one argument
y which does

00:26:43.160 --> 00:26:44.370
the following thing.

00:26:44.370 --> 00:26:50.300
It calls the procedure of one
argument x, which multiplies x

00:26:50.300 --> 00:26:54.145
by y, and applies
that to three.

00:26:58.810 --> 00:27:00.860
That procedure has the property
there of two bound

00:27:00.860 --> 00:27:04.790
variables in it, x and y.

00:27:04.790 --> 00:27:08.500
This quantifier, lambda here,
binds this y, and this

00:27:08.500 --> 00:27:12.120
quantifier, lambda,
binds that x.

00:27:12.120 --> 00:27:15.000
Because, if I were to take an
arbitrary symbol does not

00:27:15.000 --> 00:27:20.130
occur in this expression like w
and replace all y's with w's

00:27:20.130 --> 00:27:23.610
in this expression, the
expression is still the same,

00:27:23.610 --> 00:27:26.240
the same procedure.

00:27:26.240 --> 00:27:27.430
And this is an important idea.

00:27:27.430 --> 00:27:30.700
The reason why we had such
things like that is a kind of

00:27:30.700 --> 00:27:31.500
modularity.

00:27:31.500 --> 00:27:34.800
If two people are writing
programs, and they work

00:27:34.800 --> 00:27:38.150
together, it shouldn't matter
what names they use internal

00:27:38.150 --> 00:27:42.490
to their own little machines
that they're building.

00:27:42.490 --> 00:27:45.960
And so, what I'm really telling
you there, is that,

00:27:45.960 --> 00:27:49.490
for example, this is equivalent
to that procedure

00:27:49.490 --> 00:27:54.260
of one argument y which uses
that procedure of one argument

00:27:54.260 --> 00:28:01.200
d which multiplies z by y.

00:28:01.200 --> 00:28:03.570
Because nobody cares what
I used in here.

00:28:06.270 --> 00:28:08.880
It's a nice example.

00:28:08.880 --> 00:28:15.320
On the other hand, I have some
variables that are not bound.

00:28:15.320 --> 00:28:22.450
For example, that procedure
of one argument x which

00:28:22.450 --> 00:28:27.390
multiplies x by y.

00:28:27.390 --> 00:28:32.370
In this case, y is not bound.

00:28:32.370 --> 00:28:36.440
Supposing y had the value three,
and z had the value

00:28:36.440 --> 00:28:41.420
four, then this procedure
would be the thing that

00:28:41.420 --> 00:28:44.910
multiplies its argument
by three.

00:28:44.910 --> 00:28:47.793
If I were to replace every
instance of y with z, I would

00:28:47.793 --> 00:28:50.190
have a different procedure
which multiplies every

00:28:50.190 --> 00:28:53.491
argument that's given by four.

00:28:53.491 --> 00:28:57.810
And, in fact, we have a name
for such a variable.

00:28:57.810 --> 00:29:03.680
Here, we say that a variable, v,
is free in the expression,

00:29:03.680 --> 00:29:06.200
e, if the meaning of the
expression, e, is changed by

00:29:06.200 --> 00:29:09.355
the uniform replacement of a
variable, w, not occurring in

00:29:09.355 --> 00:29:13.120
e for every occurrence
of v and e.

00:29:13.120 --> 00:29:20.680
So that's why this variable
over here,

00:29:20.680 --> 00:29:22.525
y, is a free variable.

00:29:29.010 --> 00:29:33.610
And so free variables
in this expression--

00:29:33.610 --> 00:29:38.690
And other examples of that is
that procedure of one argument

00:29:38.690 --> 00:29:43.160
y, which is just what we had
before, which uses that

00:29:43.160 --> 00:29:48.130
procedure of one argument x
that multiplies x by y--

00:29:51.540 --> 00:29:52.790
use that on three.

00:29:56.940 --> 00:30:00.060
This procedure has
a free variable

00:30:00.060 --> 00:30:01.795
in it which is asterisk.

00:30:05.010 --> 00:30:07.170
See, because, if that has
a normal meaning of

00:30:07.170 --> 00:30:11.360
multiplication, then if I were
to replace uniformly all

00:30:11.360 --> 00:30:15.770
asterisks with pluses, then the
meaning of this expression

00:30:15.770 --> 00:30:17.020
would change.

00:30:19.360 --> 00:30:22.850
That's what you mean
by a free variable.

00:30:22.850 --> 00:30:26.350
So, so far you've learned some
logician words which describe

00:30:26.350 --> 00:30:29.020
the way names are used.

00:30:29.020 --> 00:30:32.490
Now, we have to do a little bit
more playing around here,

00:30:32.490 --> 00:30:35.200
a little bit more.

00:30:35.200 --> 00:30:38.600
I want to tell you about the
regions are over which

00:30:38.600 --> 00:30:39.850
variables are defined.

00:30:42.270 --> 00:30:45.260
You see, we've been very
informal about this up till

00:30:45.260 --> 00:30:48.870
now, and, of course, many of you
have probably understood

00:30:48.870 --> 00:30:51.960
very clearly or most of you,
that the x that's being

00:30:51.960 --> 00:30:55.170
declared here is defined
only in here.

00:30:58.250 --> 00:31:03.580
This x is the defined only in
here, and this y is defined

00:31:03.580 --> 00:31:04.830
only in here.

00:31:07.080 --> 00:31:08.400
We have a name for
such an idea.

00:31:08.400 --> 00:31:11.660
It's called a scope.

00:31:11.660 --> 00:31:14.710
And let me give you another
piece of terminology.

00:31:14.710 --> 00:31:16.050
It's a long story.

00:31:16.050 --> 00:31:18.850
If x is a bound variable in
e, then there is a lambda

00:31:18.850 --> 00:31:20.560
expression where it is bound.

00:31:20.560 --> 00:31:23.956
So the only way you can get a
bound variable ultimately is

00:31:23.956 --> 00:31:24.970
by lambda expression.

00:31:24.970 --> 00:31:28.250
Then you may worry, does
define quite an

00:31:28.250 --> 00:31:29.670
exception to this?

00:31:29.670 --> 00:31:31.840
And it turns out, we could
always arrange things so you

00:31:31.840 --> 00:31:33.100
don't need any defines.

00:31:33.100 --> 00:31:34.070
And we'll see that in a while.

00:31:34.070 --> 00:31:36.900
It's a very magical thing.

00:31:36.900 --> 00:31:39.000
So define really can go away.

00:31:39.000 --> 00:31:42.650
The really, only thing that
makes names is lambda .

00:31:42.650 --> 00:31:44.350
That's its job.

00:31:44.350 --> 00:31:46.865
And what's so amazing about
a lot of things is you can

00:31:46.865 --> 00:31:48.740
compute with only lambda.

00:31:48.740 --> 00:31:53.910
But, in any case, a lambda
expression has a place where

00:31:53.910 --> 00:31:55.880
it declares a variable.

00:31:55.880 --> 00:31:59.970
We call it the formal parameter
list or the bound

00:31:59.970 --> 00:32:03.290
variable list. We say that the
lambda expression binds--

00:32:03.290 --> 00:32:04.970
so it's a verb--

00:32:04.970 --> 00:32:08.730
binds the variables declared in
it's found variable list.

00:32:08.730 --> 00:32:10.580
In addition, those parts of
the expression where the

00:32:10.580 --> 00:32:15.680
variable is defined, which was
declared by some declaration,

00:32:15.680 --> 00:32:20.400
is called the scope
of that variable.

00:32:20.400 --> 00:32:22.270
So these are scopes.

00:32:22.270 --> 00:32:23.630
This is the scope of y.

00:32:27.140 --> 00:32:28.690
And this is the scope of x--

00:32:33.030 --> 00:32:34.280
that sort of thing.

00:32:41.460 --> 00:32:47.120
OK, well, now we have enough
terminology to begin to

00:32:47.120 --> 00:32:52.360
understand how to make a new
model for computation, because

00:32:52.360 --> 00:32:56.060
the key thing going on here
is that we destroyed the

00:32:56.060 --> 00:32:58.820
substitution model, and we now
have to have a model that

00:32:58.820 --> 00:33:03.950
represents the names as
referring to places.

00:33:03.950 --> 00:33:06.460
Because if we are going to
change something, then we have

00:33:06.460 --> 00:33:09.660
a place where it's stored.

00:33:09.660 --> 00:33:14.860
You see, if a name only refers
to a value, and if I tried to

00:33:14.860 --> 00:33:19.280
change the name's meaning,
well, that's not clear.

00:33:19.280 --> 00:33:23.570
There's nothing that is
the place that that

00:33:23.570 --> 00:33:25.030
name referred to.

00:33:25.030 --> 00:33:25.960
How am I really saying it?

00:33:25.960 --> 00:33:28.220
There is nothing shared
among all of the

00:33:28.220 --> 00:33:29.840
instances of that name.

00:33:29.840 --> 00:33:32.080
And what we really mean,
by a name, is that we

00:33:32.080 --> 00:33:34.440
fan something out.

00:33:34.440 --> 00:33:37.350
We've given something a name,
and you have it, and you have

00:33:37.350 --> 00:33:39.470
it, because I'm given you a
reference to it, and I've

00:33:39.470 --> 00:33:41.130
given you a reference to it.

00:33:41.130 --> 00:33:43.580
And we'll see a lot
about that.

00:33:43.580 --> 00:33:45.986
So let me tell you about
environments.

00:33:45.986 --> 00:33:52.140
I need the overhead projection
machine, thank you.

00:33:52.140 --> 00:34:01.590
And so here is a bunch of
environment structures.

00:34:01.590 --> 00:34:06.490
An environment is a way of doing
substitutions virtually.

00:34:06.490 --> 00:34:09.639
It represents a place where
something is stored which is

00:34:09.639 --> 00:34:11.409
the substitutions that
you haven't done.

00:34:14.540 --> 00:34:17.639
It's a place where everything
accumulates, where the names

00:34:17.639 --> 00:34:20.600
of the variables are associated
with the values

00:34:20.600 --> 00:34:26.020
they have such that when you
say, what dose this name mean,

00:34:26.020 --> 00:34:28.090
you look it up in
an environment.

00:34:28.090 --> 00:34:32.420
So an environment is a function,
or a table, or

00:34:32.420 --> 00:34:33.290
something like that.

00:34:33.290 --> 00:34:35.790
But it's a structured
sort of table.

00:34:35.790 --> 00:34:37.125
It's made out of things
called frames.

00:34:41.050 --> 00:34:45.210
Frames are pieces of
environment, and they are

00:34:45.210 --> 00:34:50.270
chained together, in some nice
ways, by what's called parent

00:34:50.270 --> 00:34:53.940
links or something like that.

00:34:53.940 --> 00:34:57.740
So here, we have an environment
structure

00:34:57.740 --> 00:35:00.100
consisting of three
environments,

00:35:00.100 --> 00:35:05.250
basically, a, b, and c.

00:35:05.250 --> 00:35:11.480
d is also an environment, but
it's the same one, they share.

00:35:11.480 --> 00:35:14.550
And that's the essence
of assignment.

00:35:14.550 --> 00:35:18.120
If I change a variable, a value
of a valuable that lives

00:35:18.120 --> 00:35:21.950
here, like that one, it should
be visible from all places

00:35:21.950 --> 00:35:23.750
that you're looking
at it from.

00:35:23.750 --> 00:35:24.990
Take this one, x.

00:35:24.990 --> 00:35:28.560
If I change the x to four, it's

00:35:28.560 --> 00:35:30.340
visible from other places.

00:35:30.340 --> 00:35:32.270
But I'm not going to worry
about that right now.

00:35:32.270 --> 00:35:34.590
We're going to talk a lot about
that in a little while.

00:35:34.590 --> 00:35:36.830
What do we have here?

00:35:36.830 --> 00:35:37.990
Well, these are called frames.

00:35:37.990 --> 00:35:43.270
Here is a frame, here's a frame,
and here's a frame.

00:35:43.270 --> 00:35:47.040
a is an environment which
consists of the table which is

00:35:47.040 --> 00:35:52.570
frame two, followed by the
table labeled frame one.

00:35:52.570 --> 00:35:59.280
And, in this environment, in
say this environment, frame

00:35:59.280 --> 00:36:04.150
two, x and y are bound.

00:36:04.150 --> 00:36:05.920
They have values.

00:36:05.920 --> 00:36:07.290
Sorry, in frame one--

00:36:07.290 --> 00:36:15.340
In frame two, z is bound, and
x is bound, and y is bound,

00:36:15.340 --> 00:36:18.560
but the value of x that we see,
looking from this point

00:36:18.560 --> 00:36:20.940
of view, is this x.

00:36:20.940 --> 00:36:24.940
It's x is seven, rather than
this one which is three.

00:36:24.940 --> 00:36:27.660
We say that this x
shadows this x.

00:36:31.070 --> 00:36:33.320
From environment three--

00:36:33.320 --> 00:36:36.460
from frame three, from
environment b, which refers to

00:36:36.460 --> 00:36:42.155
frame three, we have variables
n and y bound and also x.

00:36:44.740 --> 00:36:48.630
This y shadow this one.

00:36:48.630 --> 00:36:50.580
So the value, looking
from this point of

00:36:50.580 --> 00:36:53.410
view, of y is two.

00:36:53.410 --> 00:36:54.900
The value for looking
from this point of

00:36:54.900 --> 00:36:56.500
view and m is one.

00:36:56.500 --> 00:36:57.620
And the value, looking
from this point of

00:36:57.620 --> 00:36:58.870
view, of x is three.

00:37:02.310 --> 00:37:04.300
So there we have a very
simple environment

00:37:04.300 --> 00:37:06.340
structure made out of frames.

00:37:06.340 --> 00:37:10.990
These correspond to the
applications of procedures.

00:37:10.990 --> 00:37:14.390
And we'll see that
in a second.

00:37:14.390 --> 00:37:16.860
So now I have to make you some
other nice little structure

00:37:16.860 --> 00:37:18.110
that we build.

00:37:20.870 --> 00:37:25.820
Next slide, we see an object,
which I'm going to draw

00:37:25.820 --> 00:37:27.850
procedures.

00:37:27.850 --> 00:37:30.190
This is a procedure.

00:37:30.190 --> 00:37:33.150
A procedure is made
out of two parts.

00:37:33.150 --> 00:37:34.515
It's sort of like a cons.

00:37:37.210 --> 00:37:38.460
However, it's the two parts.

00:37:40.820 --> 00:37:46.410
The first part refers to some
code, something that can be

00:37:46.410 --> 00:37:48.940
executed, a set of instructions,
if you will.

00:37:48.940 --> 00:37:50.750
You can think of it that way.

00:37:50.750 --> 00:37:53.830
And the second part is
the environment.

00:37:53.830 --> 00:37:57.250
The procedure is the
whole thing.

00:37:57.250 --> 00:38:01.420
And we're going to have to use
this to capture the values of

00:38:01.420 --> 00:38:06.250
the free variables that occur
in the procedure.

00:38:06.250 --> 00:38:08.760
If a variable occurs in the
procedure it's either bound in

00:38:08.760 --> 00:38:11.170
that procedure or free.

00:38:11.170 --> 00:38:16.930
If it's bound, then the value
will somehow be easy to find.

00:38:16.930 --> 00:38:19.070
It will be in some easy
environment to get at.

00:38:19.070 --> 00:38:21.800
If it's free, we're going to
have to have something that

00:38:21.800 --> 00:38:24.010
goes with the procedure that
says where we'll go

00:38:24.010 --> 00:38:27.100
look for its value.

00:38:27.100 --> 00:38:32.290
And the reasons why are not
obvious yet, but will be soon.

00:38:32.290 --> 00:38:33.760
So here's a procedure object.

00:38:33.760 --> 00:38:40.200
It's a composite object
consisting of a piece of code

00:38:40.200 --> 00:38:42.750
and a environment structure.

00:38:42.750 --> 00:38:46.400
Now I will tell you the new
rules, the complete new rules,

00:38:46.400 --> 00:38:47.650
for evaluation.

00:38:50.690 --> 00:38:53.250
The first rule is-- there's
only two of them.

00:38:53.250 --> 00:38:57.250
These correspond to the
substitution model rules.

00:38:57.250 --> 00:39:00.830
And the first one has to do
with how do you apply a

00:39:00.830 --> 00:39:02.570
procedure to its arguments?

00:39:05.610 --> 00:39:08.890
And a procedural object is
applied to a set of arguments

00:39:08.890 --> 00:39:11.270
by constructing a new frame.

00:39:11.270 --> 00:39:13.860
That frame will contain the
mapping of the former

00:39:13.860 --> 00:39:16.540
parameters to the actual
parameters of the arguments

00:39:16.540 --> 00:39:21.490
that were supplied
in the call.

00:39:21.490 --> 00:39:25.320
As you know, when we make up
a call to a procedure like

00:39:25.320 --> 00:39:28.670
lambda x times x y, and we call
that with the argument

00:39:28.670 --> 00:39:31.280
three, then we're going
to need some

00:39:31.280 --> 00:39:34.290
mapping of x to three.

00:39:34.290 --> 00:39:38.490
It's the same thing as later
substituting, if you will, the

00:39:38.490 --> 00:39:41.990
three for the x in
the old model.

00:39:41.990 --> 00:39:45.160
So I'm going to build a frame
which contains x equals three

00:39:45.160 --> 00:39:46.550
as the information
in that frame.

00:39:49.230 --> 00:39:52.640
Now, the body of the procedure
will then have to be evaluated

00:39:52.640 --> 00:39:54.170
which is this.

00:39:54.170 --> 00:40:04.710
I will be evaluated in an
environment which is

00:40:04.710 --> 00:40:08.780
constructed by adjoining the new
frame that we just made to

00:40:08.780 --> 00:40:10.450
the environment which
was part of the

00:40:10.450 --> 00:40:13.100
procedure that we applied.

00:40:13.100 --> 00:40:15.670
So I'm going to make a little
example of that here.

00:40:19.220 --> 00:40:25.110
Supposing I have some
environment.

00:40:25.110 --> 00:40:27.980
Here's a frame which
represents it.

00:40:27.980 --> 00:40:30.190
And some procedure-- which I'm
going to draw with circles

00:40:30.190 --> 00:40:33.370
here because it's easier
than little triangles--

00:40:33.370 --> 00:40:38.940
Sorry, those are rhombuses,
rhomboidal little pieces of

00:40:38.940 --> 00:40:42.710
fruit jelly or something.

00:40:42.710 --> 00:40:45.960
So here's a procedure which
takes this environment.

00:40:45.960 --> 00:40:48.920
And the procedure has a piece
of code, which is a lambda

00:40:48.920 --> 00:40:55.600
expression, which binds x and
y and then executes an

00:40:55.600 --> 00:40:58.010
expression, e.

00:40:58.010 --> 00:40:59.345
And this is the procedure.

00:40:59.345 --> 00:41:01.470
We'll call it p.

00:41:01.470 --> 00:41:06.490
I wish to apply that procedure
to three and four.

00:41:06.490 --> 00:41:09.790
So I want to do p of
three and four.

00:41:09.790 --> 00:41:13.210
What I'm going to do, of course,
is make a new frame.

00:41:13.210 --> 00:41:18.630
I build a frame which contains
x equals three,

00:41:18.630 --> 00:41:21.740
and y equals four.

00:41:21.740 --> 00:41:27.680
I'm going to connect that frame
to this frame over here.

00:41:27.680 --> 00:41:31.940
And then this environment, with
I will call b, is the

00:41:31.940 --> 00:41:34.880
environment in which I will
evaluate the body of e.

00:41:39.940 --> 00:41:46.890
Now, e may contain references
to x and y and other things.

00:41:46.890 --> 00:41:50.790
x and y will have values
right here.

00:41:50.790 --> 00:41:55.040
Other things will have
their values here.

00:41:55.040 --> 00:41:56.920
How do we get this frame?

00:41:56.920 --> 00:42:00.110
That we do by the construction
of procedures which is the

00:42:00.110 --> 00:42:01.980
other rule.

00:42:01.980 --> 00:42:05.500
And I think that's
the next slide.

00:42:05.500 --> 00:42:10.000
Rule two, when a lambda
expression is evaluated,

00:42:10.000 --> 00:42:11.510
relative to a particular
environment--

00:42:14.150 --> 00:42:17.470
See, the way I get a procedure
is by evaluating the lambda

00:42:17.470 --> 00:42:18.300
expression.

00:42:18.300 --> 00:42:20.110
Here's a lambda expression.

00:42:20.110 --> 00:42:22.880
By evaluating it, I get
a procedure which I

00:42:22.880 --> 00:42:25.170
can apply to three.

00:42:25.170 --> 00:42:28.710
Now this lambda expression is
evaluated in an environment

00:42:28.710 --> 00:42:31.820
where y is defined.

00:42:31.820 --> 00:42:33.760
And I want the body of
this which contains a

00:42:33.760 --> 00:42:36.680
free version of y.

00:42:36.680 --> 00:42:41.790
y is free in here, it's bound
over the whole thing, but it's

00:42:41.790 --> 00:42:43.350
free over here.

00:42:43.350 --> 00:42:47.440
I want that y to be this one.

00:42:47.440 --> 00:42:53.150
I evaluate this body of this
procedure in the environment

00:42:53.150 --> 00:42:55.470
where y was created.

00:42:55.470 --> 00:42:57.800
That's this kind of thing,
because that was done by

00:42:57.800 --> 00:42:59.140
application.

00:42:59.140 --> 00:43:03.490
Now, if I ever want to look up
the value of y, I have to know

00:43:03.490 --> 00:43:04.370
where it is.

00:43:04.370 --> 00:43:07.440
Therefore, this procedural was
created, the creation of the

00:43:07.440 --> 00:43:09.530
procedure which is the result
of evaluating that lambda

00:43:09.530 --> 00:43:14.480
expression had better capture
a pointer or remember the

00:43:14.480 --> 00:43:18.110
frame in which y was bound.

00:43:18.110 --> 00:43:22.100
So that's what this rule
is telling us.

00:43:22.100 --> 00:43:28.610
So, for example, if I happen
to be evaluating a lambda

00:43:28.610 --> 00:43:37.370
expression, lambda expression in
e, lambda of say, x and y,

00:43:37.370 --> 00:43:43.020
let's call it g in e,
evaluating that.

00:43:43.020 --> 00:43:47.190
Well, all that means is I now
construct a procedure object.

00:43:47.190 --> 00:43:48.990
e is some environment.

00:43:48.990 --> 00:43:51.920
e is something which has
a pointer to it.

00:43:51.920 --> 00:43:56.120
I construct a procedure object
that points up to that

00:43:56.120 --> 00:44:01.830
environment, where the code of
that is a lambda expression or

00:44:01.830 --> 00:44:03.180
whatever that translates into.

00:44:06.330 --> 00:44:07.580
And this is the procedure.

00:44:12.380 --> 00:44:17.640
So this produces for me-- this
object here, this environment

00:44:17.640 --> 00:44:21.140
pointer, captures the place
where this lambda expression

00:44:21.140 --> 00:44:25.820
was evaluated, where the
definition was used, where the

00:44:25.820 --> 00:44:26.900
definition was used to make a

00:44:26.900 --> 00:44:32.950
procedure, to make the procedure.

00:44:32.950 --> 00:44:35.190
So it picks up the environment
from the place where that

00:44:35.190 --> 00:44:39.680
procedure was defined, stores
it in the procedure itself,

00:44:39.680 --> 00:44:42.210
and then when the procedure is
used, the environment where it

00:44:42.210 --> 00:44:44.990
was defined is extended
with the new frame.

00:44:48.740 --> 00:44:51.170
So this gives us a locus
for putting where a

00:44:51.170 --> 00:44:53.090
variable has a value.

00:44:53.090 --> 00:44:55.700
And, for example, if there are
lots of guys pointing in at

00:44:55.700 --> 00:45:01.430
that environment, then they
share that place.

00:45:01.430 --> 00:45:03.810
And we'll see more
of that shortly.

00:45:03.810 --> 00:45:08.940
Well, now you have a new model
for understanding the

00:45:08.940 --> 00:45:12.420
execution of programs. I suppose
I'll take questions

00:45:12.420 --> 00:45:14.970
now, and then we'll go on and
use that for something.

00:45:17.802 --> 00:45:21.870
AUDIENCE: Is it right to say
then, the environment is that

00:45:21.870 --> 00:45:23.695
linked chain of frames--

00:45:23.695 --> 00:45:24.580
PROFESSOR: That's right.

00:45:24.580 --> 00:45:25.650
AUDIENCE: starting with--

00:45:25.650 --> 00:45:27.076
working all the way back?

00:45:27.076 --> 00:45:29.400
PROFESSOR: Yes, the environment
is a sequence of

00:45:29.400 --> 00:45:32.470
frames linked together.

00:45:32.470 --> 00:45:34.700
And the way I like to think
about it, it's the pointer to

00:45:34.700 --> 00:45:38.150
the first one, because
once you've got that

00:45:38.150 --> 00:45:39.400
you've got them all.

00:45:44.080 --> 00:45:44.995
Anybody else?

00:45:44.995 --> 00:45:47.800
AUDIENCE: Is it possible to
evaluate a procedure or to

00:45:47.800 --> 00:45:49.300
define a procedure in two
different environments such

00:45:49.300 --> 00:45:51.580
that it will behave
differently, and

00:45:51.580 --> 00:45:52.140
have pointers to both--

00:45:52.140 --> 00:45:53.600
PROFESSOR: Oh, yes.

00:45:53.600 --> 00:45:55.260
The same procedure is not going
to have two different

00:45:55.260 --> 00:45:57.290
environments.

00:45:57.290 --> 00:46:01.895
The same code, the same lambda
expression can be evaluated in

00:46:01.895 --> 00:46:03.430
two environments producing
two different procedures.

00:46:06.220 --> 00:46:07.140
Each procedure--

00:46:07.140 --> 00:46:08.690
AUDIENCE: Their definition
has the same name.

00:46:08.690 --> 00:46:09.170
Their operation--

00:46:09.170 --> 00:46:11.070
PROFESSOR: The definition is
written the same, with the

00:46:11.070 --> 00:46:12.570
same characters.

00:46:12.570 --> 00:46:16.700
I can evaluate that set of
characters, whatever, that

00:46:16.700 --> 00:46:19.530
list structure that defines,
that is the textual

00:46:19.530 --> 00:46:21.340
representation.

00:46:21.340 --> 00:46:23.650
I can evaluate that in two
different environments

00:46:23.650 --> 00:46:25.650
producing two different
procedures.

00:46:25.650 --> 00:46:31.700
Each of those procedures has
its own local sets of

00:46:31.700 --> 00:46:33.490
variables, and we'll
see that right now.

00:46:36.770 --> 00:46:38.020
Anybody else?

00:46:42.670 --> 00:46:43.280
OK, thank you.

00:46:43.280 --> 00:46:44.530
Let's take a break.

00:46:48.750 --> 00:47:22.870
[MUSIC PLAYING]

00:47:22.870 --> 00:47:26.670
Well, now I've done this
terrible thing to you.

00:47:26.670 --> 00:47:34.600
I've introduced a very
complicated thing, assignment,

00:47:34.600 --> 00:47:36.680
which destroys most of the
interesting mathematical

00:47:36.680 --> 00:47:43.270
properties of our programs. Why
should I have done this?

00:47:43.270 --> 00:47:46.590
What possible good
could this do?

00:47:46.590 --> 00:47:52.490
Clearly not a nice thing, so I
better have a good excuse.

00:47:52.490 --> 00:47:56.150
Well, let's do a little bit of
playing, first of all, with

00:47:56.150 --> 00:47:58.870
some very interesting programs
that have assignment.

00:47:58.870 --> 00:48:02.000
Understand something special
about them that makes them

00:48:02.000 --> 00:48:04.820
somewhat valuable.

00:48:04.820 --> 00:48:08.110
Start with a very simple program
which I'm going to

00:48:08.110 --> 00:48:10.670
call make-counter.

00:48:10.670 --> 00:48:26.480
I'm going to define make-counter
to be a procedure

00:48:26.480 --> 00:48:31.280
of one argument n which
returns as its value a

00:48:31.280 --> 00:48:34.390
procedure of no arguments--

00:48:34.390 --> 00:48:36.840
a procedure that produces
a procedure--

00:48:36.840 --> 00:48:48.600
which sets n to the increment
of n and returns

00:48:48.600 --> 00:48:50.120
that value of n.

00:48:55.520 --> 00:48:57.560
Now we're going to investigate
the behavior of this.

00:48:57.560 --> 00:48:59.840
It's a sort of interesting
thing.

00:48:59.840 --> 00:49:02.150
In order to investigate the
behavior, I have to make an

00:49:02.150 --> 00:49:05.130
environment model, because
we can't understand

00:49:05.130 --> 00:49:06.380
this any other way.

00:49:08.630 --> 00:49:10.040
So let's just do that.

00:49:10.040 --> 00:49:13.005
We start out with
some sort of--

00:49:13.005 --> 00:49:15.270
let's say there is a global
environment that the machine

00:49:15.270 --> 00:49:16.240
is born with.

00:49:16.240 --> 00:49:19.720
Global we'll call it.

00:49:19.720 --> 00:49:24.530
And it's going to have in it
a bunch of initial things.

00:49:24.530 --> 00:49:25.820
We all know what it's got.

00:49:25.820 --> 00:49:32.930
It's got things in it like
say, plus, and times, and

00:49:32.930 --> 00:49:39.330
quotient, and difference,
and CAR, and et

00:49:39.330 --> 00:49:42.960
cetera, lots of things.

00:49:42.960 --> 00:49:46.160
I don't know what they are, some
various squiggles that

00:49:46.160 --> 00:49:51.290
are the things the machine
is born with.

00:49:51.290 --> 00:49:56.350
And by doing the definition
here, what I plan to do--

00:49:56.350 --> 00:49:57.390
Well, what am I doing?

00:49:57.390 --> 00:49:59.780
I'm doing this relative to
the global environment.

00:49:59.780 --> 00:50:03.580
So here's my environment
pointer.

00:50:03.580 --> 00:50:05.980
In order to do that I have
to evaluate this lambda

00:50:05.980 --> 00:50:08.270
expression.

00:50:08.270 --> 00:50:11.490
That means I make a
procedure object.

00:50:11.490 --> 00:50:13.190
So I'm going to make a procedure
object here.

00:50:17.400 --> 00:50:21.430
And the procedure object has, as
the place it's defined, the

00:50:21.430 --> 00:50:23.820
global environment.

00:50:23.820 --> 00:50:29.880
The procedure object contains
some code that represents a

00:50:29.880 --> 00:50:33.470
procedure of one argument n
which returns a procedure of

00:50:33.470 --> 00:50:35.340
no arguments which
does something.

00:50:38.320 --> 00:50:44.580
And the define is a way of
changing this environment, so

00:50:44.580 --> 00:50:53.230
that I now add to it a
make-counter, a special rule

00:50:53.230 --> 00:50:55.470
for the special thing defined.

00:50:55.470 --> 00:50:59.810
But what that is, is
it gives me that

00:50:59.810 --> 00:51:03.840
pointer to that procedure.

00:51:03.840 --> 00:51:06.370
So now the global environment
contains make-counter as well.

00:51:09.330 --> 00:51:11.800
Now, we're going to do
some operations.

00:51:11.800 --> 00:51:14.596
I'm going to use this to
make some counters.

00:51:14.596 --> 00:51:17.140
We'll see what a counter is.

00:51:17.140 --> 00:51:26.700
So let's define c1 to be a
counter beginning at 0.

00:51:35.440 --> 00:51:39.660
Well, we know how to do this
now, according to the model.

00:51:39.660 --> 00:51:43.340
I have to evaluate the
expression make-counter in the

00:51:43.340 --> 00:51:47.900
global environment,
make-counter of 0.

00:51:47.900 --> 00:51:50.785
Well, I look up make-counter and
see that it's a procedure.

00:51:53.630 --> 00:51:56.010
I'm going to have to apply
that procedure.

00:51:56.010 --> 00:51:59.820
The way I apply the procedure
is by constructing a frame.

00:52:02.400 --> 00:52:12.030
So I construct a frame which has
a value for n in it which

00:52:12.030 --> 00:52:16.850
is 0, and the parent environment
is the one which

00:52:16.850 --> 00:52:18.810
is the environment of definition
of make-counter.

00:52:23.890 --> 00:52:28.400
So I've made an environment by
applying make-counter to 0.

00:52:31.580 --> 00:52:34.700
Now, I have to evaluate the body
of make-counter, which is

00:52:34.700 --> 00:52:37.455
this lambda expression,
in that environment.

00:52:40.730 --> 00:52:43.770
Well evaluating this body,
this body is a lambda

00:52:43.770 --> 00:52:46.360
expression.

00:52:46.360 --> 00:52:49.570
Evaluate a lambda expression
means make a procedure object.

00:52:49.570 --> 00:52:50.820
So I'm going to make
a procedure object.

00:52:56.840 --> 00:52:59.620
And that procedure object has
the environment it was defined

00:52:59.620 --> 00:53:07.656
in being that, where n
was defined to be 0.

00:53:07.656 --> 00:53:11.370
And it has some code, which is
the procedure of no arguments

00:53:11.370 --> 00:53:17.622
which does something, that sets
something, and returns n.

00:53:17.622 --> 00:53:22.680
And this thing is going to be
the object, which in the

00:53:22.680 --> 00:53:26.020
global environment, will
have the name c1.

00:53:26.020 --> 00:53:32.625
So we construct a name here, c1,
and say that equals that.

00:53:35.560 --> 00:53:50.790
Now, but also make another
counter, c2 to be make-counter

00:53:50.790 --> 00:53:53.868
say, starting with 10.

00:53:53.868 --> 00:53:57.270
Then I do essentially
the same thing.

00:53:57.270 --> 00:53:59.910
I apply the make-counter
procedure, which I got from

00:53:59.910 --> 00:54:05.690
here, to make another frame
with n being 10.

00:54:05.690 --> 00:54:10.050
That frame has the global
environment as its parent.

00:54:10.050 --> 00:54:16.750
I then construct a procedure
which has that as it's frame

00:54:16.750 --> 00:54:18.000
of definition.

00:54:20.440 --> 00:54:23.240
The code of it is the procedure
of no arguments

00:54:23.240 --> 00:54:25.390
which does something.

00:54:25.390 --> 00:54:28.700
And it does a set, and so on.

00:54:28.700 --> 00:54:31.510
And n comes out.

00:54:31.510 --> 00:54:36.950
And c2 is this.

00:54:36.950 --> 00:54:38.780
Well, you're already beginning
to see something fairly

00:54:38.780 --> 00:54:40.200
interesting.

00:54:40.200 --> 00:54:42.880
There are two n's here.

00:54:42.880 --> 00:54:46.330
They are not one n.

00:54:46.330 --> 00:54:49.310
Each time I called make-counter,
I made another

00:54:49.310 --> 00:54:52.520
instance of n.

00:54:52.520 --> 00:54:54.370
These are distinct and separate
from each other.

00:54:57.880 --> 00:55:00.783
Now, let's do some execution,
use those counters.

00:55:00.783 --> 00:55:02.735
I'm going to use
those counters.

00:55:05.990 --> 00:55:15.900
Well, what happens if I
say, c1 at this point?

00:55:15.900 --> 00:55:18.420
Well, I go over here,
and I say, oh

00:55:18.420 --> 00:55:20.840
yes, c1 is a procedure.

00:55:20.840 --> 00:55:23.490
I'm going to call this procedure
on no arguments, but

00:55:23.490 --> 00:55:25.060
it has no parameters.

00:55:25.060 --> 00:55:27.020
That's right.

00:55:27.020 --> 00:55:28.080
What's its body?

00:55:28.080 --> 00:55:29.776
Well, I have to look over
here, because I

00:55:29.776 --> 00:55:30.130
didn't write it down.

00:55:30.130 --> 00:55:39.050
It said, set n to one plus n
and return n, increment n.

00:55:39.050 --> 00:55:42.970
Well, the n it sees
is this one.

00:55:42.970 --> 00:55:45.490
So I increment that n.

00:55:45.490 --> 00:55:50.040
That becomes one, and I
return the value one.

00:55:53.050 --> 00:55:58.220
Supposing I then called c2.

00:55:58.220 --> 00:55:59.820
Well, what do I do?

00:55:59.820 --> 00:56:03.600
I say c2 is this procedure which
does the same thing, but

00:56:03.600 --> 00:56:05.450
here's the n.

00:56:05.450 --> 00:56:11.140
It becomes 11.

00:56:11.140 --> 00:56:15.980
And so I have an 11 which
is the value.

00:56:15.980 --> 00:56:18.130
I then can say, let's
try c1 again.

00:56:21.580 --> 00:56:29.660
c1 is this, that's two,
so the answer is two.

00:56:29.660 --> 00:56:36.560
And c2 gives me a 12 by the same
method, by walking down

00:56:36.560 --> 00:56:38.730
here looking at that and saying,
here's the n, I'm

00:56:38.730 --> 00:56:39.980
incrementing.

00:56:41.630 --> 00:56:44.920
So what I have are computational
objects.

00:56:44.920 --> 00:56:49.780
There are two counters,
each with its own

00:56:49.780 --> 00:56:51.060
independent local state.

00:56:55.540 --> 00:56:56.650
Let's talk about
this a little.

00:56:56.650 --> 00:56:58.510
This is a strange thing.

00:57:01.270 --> 00:57:04.140
What's an object?

00:57:04.140 --> 00:57:07.560
It's not at all obvious
what an object is.

00:57:07.560 --> 00:57:11.720
We like to think about
objects, because it's

00:57:11.720 --> 00:57:14.800
economical to think that way.

00:57:14.800 --> 00:57:18.670
It's an intellectual economy.

00:57:18.670 --> 00:57:21.120
I am an object.

00:57:21.120 --> 00:57:23.610
You are an object.

00:57:23.610 --> 00:57:25.030
We are not the same object.

00:57:27.600 --> 00:57:32.315
I can divide the world into
two parts, me and you, and

00:57:32.315 --> 00:57:36.600
there's other things as well,
such that most of the things I

00:57:36.600 --> 00:57:41.410
might want to discuss about my
workings do not involve you,

00:57:41.410 --> 00:57:43.790
and most of the things I want to
discuss about your workings

00:57:43.790 --> 00:57:45.750
don't involve me.

00:57:45.750 --> 00:57:50.990
I have a blood pressure, a
temperature, a respiration

00:57:50.990 --> 00:57:56.900
rate, a certain amount of
sugar in my blood, and

00:57:56.900 --> 00:57:59.400
numerous, thousands, of state
variables-- millions actually,

00:57:59.400 --> 00:58:01.030
or I don't know how many--

00:58:01.030 --> 00:58:03.040
huge numbers of state variables
in the physical

00:58:03.040 --> 00:58:09.240
sense which represent the state
of me as a particle, and

00:58:09.240 --> 00:58:12.770
you have gazillions
of them as well.

00:58:12.770 --> 00:58:17.290
And most of mine are uncoupled
to most of yours.

00:58:17.290 --> 00:58:21.000
So we can compute the properties
of me without

00:58:21.000 --> 00:58:23.940
worrying too much about
the properties of you.

00:58:23.940 --> 00:58:26.310
If we had to work about both
of us together, than the

00:58:26.310 --> 00:58:28.460
number of states that we have to
consider is the product of

00:58:28.460 --> 00:58:29.840
the number of states you have
and the number of states I

00:58:29.840 --> 00:58:32.760
have. But this way it's
almost a sum.

00:58:32.760 --> 00:58:36.110
Now, indeed there are forces
that couple us.

00:58:36.110 --> 00:58:38.420
I'm talking to you and
your state changes.

00:58:38.420 --> 00:58:41.680
I'm looking at you and
my state changes.

00:58:41.680 --> 00:58:45.010
Some of my state variables, a
very few of them, therefore,

00:58:45.010 --> 00:58:46.190
are coupled to yours.

00:58:46.190 --> 00:58:48.470
If you were to suddenly yell
very loud, my blood pressure

00:58:48.470 --> 00:58:49.720
would go up.

00:58:54.320 --> 00:58:57.590
However, and it may not be
always appropriate to think

00:58:57.590 --> 00:59:00.360
about the world as being made
out of independent states and

00:59:00.360 --> 00:59:02.260
independent particles.

00:59:02.260 --> 00:59:05.350
Lots of the bugs that occur in
things like quantum mechanics,

00:59:05.350 --> 00:59:07.660
or the bugs in our minds that
occur when we think about

00:59:07.660 --> 00:59:09.840
things like quantum mechanics,
are due the fact that we are

00:59:09.840 --> 00:59:11.910
trying to think about things
being broken up into

00:59:11.910 --> 00:59:15.880
independent pieces, when in
fact there's more coupling

00:59:15.880 --> 00:59:19.750
than we see on the surface, or
that we want to believe in,

00:59:19.750 --> 00:59:22.300
because we want to compute
efficiently and effectively.

00:59:22.300 --> 00:59:23.780
We've been trained to
think that way.

00:59:29.336 --> 00:59:31.440
Well, let's see.

00:59:31.440 --> 00:59:35.140
How would we know if we
had objects at all?

00:59:35.140 --> 00:59:37.690
How can we tell if
we have objects?

00:59:37.690 --> 00:59:41.770
Consider some possible
optical illusions.

00:59:41.770 --> 00:59:44.805
This could be done.

00:59:44.805 --> 00:59:47.970
These pieces of chalk are not
appropriately identical, but

00:59:47.970 --> 00:59:49.520
supposing you couldn't tell
the difference of them by

00:59:49.520 --> 00:59:52.130
looking at them.

00:59:52.130 --> 00:59:54.290
Well, there's a possibility
that this all a game I'm

00:59:54.290 --> 00:59:55.725
playing with mirrors.

00:59:55.725 --> 00:59:59.690
It's really the same piece
of chalk, but you're

00:59:59.690 --> 01:00:01.660
seeing two of them.

01:00:01.660 --> 01:00:05.160
How would you know if you're
seeing one or two?

01:00:05.160 --> 01:00:07.430
Well, there's only
one way I know.

01:00:07.430 --> 01:00:10.110
You grab one of them and change
it and see if the other

01:00:10.110 --> 01:00:11.360
one changed.

01:00:13.580 --> 01:00:16.180
And it didn't, so there's
two of them.

01:00:19.070 --> 01:00:20.890
And, on the other hand, there
is some other screwy

01:00:20.890 --> 01:00:22.580
properties of things
like that.

01:00:22.580 --> 01:00:25.040
Like, how do we know if
something changed?

01:00:25.040 --> 01:00:28.760
We have to look at it before
and after the change.

01:00:28.760 --> 01:00:32.200
The change is an assignment,
it's a moment in time.

01:00:32.200 --> 01:00:34.120
But that means we have to know
it was the same one that we're

01:00:34.120 --> 01:00:36.540
looking at.

01:00:36.540 --> 01:00:39.270
So some very strange, and
unusual, and obscure, and--

01:00:39.270 --> 01:00:42.950
I don't understand the problems
associated with

01:00:42.950 --> 01:00:47.380
assignment, and change,
and objects.

01:00:47.380 --> 01:00:51.420
These could get very,
very bad.

01:00:51.420 --> 01:00:56.250
For example, here I am, I am
a particular person, a

01:00:56.250 --> 01:00:57.650
particular object.

01:00:57.650 --> 01:01:02.430
Now, I can take out my knife,
and cut my fingernail.

01:01:02.430 --> 01:01:06.030
A piece of my fingernail has
fallen off onto the table.

01:01:06.030 --> 01:01:11.200
I believe I am the same person
I was a second ago, but I'm

01:01:11.200 --> 01:01:14.490
not physically the same
in the slightest.

01:01:14.490 --> 01:01:15.620
I have changed.

01:01:15.620 --> 01:01:18.180
Why am I the same?

01:01:18.180 --> 01:01:21.070
What is the identity of me?

01:01:21.070 --> 01:01:22.320
I don't know.

01:01:25.170 --> 01:01:29.770
Except for the fact that I have
some sort of identity.

01:01:29.770 --> 01:01:34.770
And so, I think by introducing
assignment and objects, we

01:01:34.770 --> 01:01:37.670
have opened ourselves up to all
the horrible questions of

01:01:37.670 --> 01:01:40.490
philosophy that have been
plaguing philosophers for some

01:01:40.490 --> 01:01:43.510
thousands of years about
this sort of thing.

01:01:43.510 --> 01:01:45.880
It's why mathematics
is a lot cleaner.

01:01:45.880 --> 01:01:49.590
Let's look at the best things
I know to say about actions

01:01:49.590 --> 01:01:50.840
and identity.

01:01:52.500 --> 01:01:56.050
We say that an action, a, had an
effect on an object, x, or

01:01:56.050 --> 01:01:59.340
equivalently, that x was
changed by a, if some

01:01:59.340 --> 01:02:02.410
property, p, which was true
of x before a, became

01:02:02.410 --> 01:02:05.100
false of x after a.

01:02:05.100 --> 01:02:07.750
Let's test. It still means
I have to have the

01:02:07.750 --> 01:02:10.950
x before and after.

01:02:10.950 --> 01:02:13.810
Or, the other way of saying
this is, we say that two

01:02:13.810 --> 01:02:15.460
objects x and y are the same
for any action which has an

01:02:15.460 --> 01:02:19.580
effect on x has the
same effect on y.

01:02:19.580 --> 01:02:22.230
However, objects are very
useful, as I said, for

01:02:22.230 --> 01:02:24.650
intellectual economy.

01:02:24.650 --> 01:02:28.350
One of the things that's
incredibly useful about them,

01:02:28.350 --> 01:02:32.980
is that the world is, we like
to think about, made out of

01:02:32.980 --> 01:02:35.050
independent objects with
independent local state.

01:02:35.050 --> 01:02:36.430
We like to think that
way, although it

01:02:36.430 --> 01:02:39.730
isn't completely true.

01:02:39.730 --> 01:02:42.470
When we want to make very
complicated programs that deal

01:02:42.470 --> 01:02:45.400
with such a world, if we want
those programs to be

01:02:45.400 --> 01:02:49.070
understandable by us and also
to be changeable, so that if

01:02:49.070 --> 01:02:51.390
we change the world we change
the program only a little bit,

01:02:51.390 --> 01:02:53.810
then we want there to be
connections, isomorphism,

01:02:53.810 --> 01:02:56.130
between the objects in the world
and the objects in our

01:02:56.130 --> 01:02:58.720
mental model.

01:02:58.720 --> 01:03:00.960
The modularity of the world can
give us the modularity in

01:03:00.960 --> 01:03:02.400
our programming.

01:03:02.400 --> 01:03:04.590
So we invent things called
object-oriented programming

01:03:04.590 --> 01:03:09.950
and things like that to provide
us with that power.

01:03:09.950 --> 01:03:10.990
But it's even easier.

01:03:10.990 --> 01:03:12.310
Let's play a little game.

01:03:12.310 --> 01:03:15.110
I want to play a little game,
show you an even easier

01:03:15.110 --> 01:03:19.610
example of where modularity can
be enhanced by using an

01:03:19.610 --> 01:03:22.960
assignment statement,
judiciously.

01:03:22.960 --> 01:03:26.280
One thing I want to enforce and
impress on you, is don't

01:03:26.280 --> 01:03:28.280
use assignment statements the
way you use it in FORTRAN or

01:03:28.280 --> 01:03:30.930
Basic or something or Pascal,
to do the things you don't

01:03:30.930 --> 01:03:32.180
have to do with it.

01:03:34.200 --> 01:03:37.010
It's not the right way to
think for most things.

01:03:37.010 --> 01:03:39.810
Sometimes it's essential,
or maybe it's essential.

01:03:39.810 --> 01:03:42.320
We'll see more about that too.

01:03:42.320 --> 01:03:44.330
OK, let me show you
a fun game here.

01:03:47.270 --> 01:03:51.750
There was mathematician by
the name of Cesaro--

01:03:51.750 --> 01:03:54.760
or Cesaro, Cesaro I
suppose it is--

01:03:54.760 --> 01:03:58.450
who figured out a clever
way of computing pi.

01:03:58.450 --> 01:04:06.320
It turns out that if I take to
random numbers, two integers

01:04:06.320 --> 01:04:11.110
at random, and compute the
greatest common divisor, their

01:04:11.110 --> 01:04:13.920
greatest common divisor is
either one or it's not one.

01:04:13.920 --> 01:04:15.445
If it's one, then they have
no common divisors.

01:04:18.240 --> 01:04:21.060
If their greatest common
divisor is one--

01:04:21.060 --> 01:04:23.590
the probability that two random
numbers, two numbers

01:04:23.590 --> 01:04:26.910
chosen at random, has as
greatest common divisor one is

01:04:26.910 --> 01:04:29.580
related to pi.

01:04:29.580 --> 01:04:31.310
In fact--

01:04:31.310 --> 01:04:33.070
yes, it's very strange--

01:04:33.070 --> 01:04:34.980
of course there are other ways
of computing pi, like dropping

01:04:34.980 --> 01:04:38.100
pins on flags, and things like
that, and sort of the same

01:04:38.100 --> 01:04:40.110
kind of thing.

01:04:40.110 --> 01:04:48.510
So the probability of that the
GCD of number one and number

01:04:48.510 --> 01:04:55.660
two, two random numbers chosen,
is 6 over pi squared.

01:04:55.660 --> 01:04:57.240
I'm not going to try
to prove that.

01:04:57.240 --> 01:05:01.120
It's actually not too hard
and sort of fun.

01:05:01.120 --> 01:05:03.590
How would we estimate
such probability?

01:05:03.590 --> 01:05:07.340
Well, the way we do that, the
way we estimate probabilities,

01:05:07.340 --> 01:05:09.620
is by doing lots of experiments,
and then

01:05:09.620 --> 01:05:12.260
computing the ratios of the ones
that come out one way to

01:05:12.260 --> 01:05:13.570
the total number of
experiments we do.

01:05:16.320 --> 01:05:19.680
It's called Monte Carlo, and
it's useful in other contexts

01:05:19.680 --> 01:05:21.280
for doing things like integrals
where you have lots

01:05:21.280 --> 01:05:22.960
and lots of variables--

01:05:22.960 --> 01:05:24.780
the space which is limiting the
dimensions you are doing

01:05:24.780 --> 01:05:26.360
you integral in.

01:05:26.360 --> 01:05:34.680
But going back to here, Let's
look at this slide, We can use

01:05:34.680 --> 01:05:40.520
Cesaro's method for estimating
pi with n trials by taking the

01:05:40.520 --> 01:05:45.850
square root of six over a Monte
Carlo, a Monte Carlo

01:05:45.850 --> 01:05:51.410
experiment with n trials, using
Cesaro's experiment,

01:05:51.410 --> 01:05:56.550
where Cesaro's experiment is the
test of whether the GCD of

01:05:56.550 --> 01:05:59.070
two random numbers--

01:05:59.070 --> 01:06:01.200
And you can see that I've
already got some assignments

01:06:01.200 --> 01:06:03.990
in here, just by what I wrote.

01:06:03.990 --> 01:06:07.930
The fact that this word rand,
in parentheses, therefore,

01:06:07.930 --> 01:06:11.530
that procedure call, yields a
different value than this one,

01:06:11.530 --> 01:06:13.330
at least that's what I'm
assuming by writing this this

01:06:13.330 --> 01:06:18.590
way, indicates that this is not
a function, that there's

01:06:18.590 --> 01:06:20.400
internal state in it
which is changing.

01:06:25.110 --> 01:06:28.530
If the GCD of those two random
numbers is equal to one,

01:06:28.530 --> 01:06:31.530
that's the experiment.

01:06:31.530 --> 01:06:34.330
So here I have an experimental
method for estimating the

01:06:34.330 --> 01:06:36.560
value of pi.

01:06:36.560 --> 01:06:40.160
Where, I can easily divide this
problem into two parts.

01:06:40.160 --> 01:06:43.610
One is the specific Monte Carlo
experiment of Cesaro,

01:06:43.610 --> 01:06:46.700
which you just saw, and the
other is the general technique

01:06:46.700 --> 01:06:49.320
of doing Monte Carlo
experiments.

01:06:49.320 --> 01:06:51.190
And that's what this is.

01:06:51.190 --> 01:06:55.930
If I want to do Monte Carlo
experiments with n trials, a

01:06:55.930 --> 01:06:59.590
certain number of trials, and
a particular experiment, the

01:06:59.590 --> 01:07:03.460
way I do that is I make a little
iterative procedure

01:07:03.460 --> 01:07:05.960
which has variable the number
of trials remaining and the

01:07:05.960 --> 01:07:10.230
number trials that have been
passed, that I've gotten true.

01:07:10.230 --> 01:07:13.010
And if the number remaining is
0, then the answer is the

01:07:13.010 --> 01:07:16.260
number past divided by this
whole number of trials, was

01:07:16.260 --> 01:07:19.150
the estimate of the
probability.

01:07:19.150 --> 01:07:22.140
And if it's not, if I have
more trials to do,

01:07:22.140 --> 01:07:22.870
then let's do one.

01:07:22.870 --> 01:07:23.860
We do an experiment.

01:07:23.860 --> 01:07:27.350
We call the procedure which is
experiment on no arguments.

01:07:27.350 --> 01:07:30.870
We do the experiment and then,
if that turned out to be true,

01:07:30.870 --> 01:07:33.830
we go around the loop
decrementing the number of

01:07:33.830 --> 01:07:36.560
experiments we have to do by
one and incrementing the

01:07:36.560 --> 01:07:38.650
number that were passed.

01:07:38.650 --> 01:07:41.880
And if the experiment was false,
we just go around the

01:07:41.880 --> 01:07:44.700
loop decrementing the number of
experiments remaining and

01:07:44.700 --> 01:07:48.910
keeping the number
passed the same.

01:07:48.910 --> 01:07:51.320
We start this up iterating
over the total number of

01:07:51.320 --> 01:07:55.840
trials with 0 experiments
past. A very

01:07:55.840 --> 01:07:57.730
elegant little program.

01:07:57.730 --> 01:08:00.530
And I don't have to just do this
with Cesaro's experiment,

01:08:00.530 --> 01:08:03.390
it could be lots of Monte Carlo
experiments I might do.

01:08:03.390 --> 01:08:05.860
Of course, this depends upon the
existence of some sort of

01:08:05.860 --> 01:08:07.440
random number generator.

01:08:07.440 --> 01:08:09.960
And random number generators
generally look

01:08:09.960 --> 01:08:11.210
something like this.

01:08:13.570 --> 01:08:17.550
There is a random number
generator--

01:08:17.550 --> 01:08:24.490
is in fact a procedure which is
going to do something just

01:08:24.490 --> 01:08:25.710
like the counter.

01:08:25.710 --> 01:08:30.870
It's going to update an x to
the result of applying some

01:08:30.870 --> 01:08:34.600
function to x, where this
function is some screwy kind

01:08:34.600 --> 01:08:38.800
of function that you might find
out in Knuth's books on

01:08:38.800 --> 01:08:41.689
the details of programming.

01:08:41.689 --> 01:08:45.020
He does these wonderful books
that are full of the details

01:08:45.020 --> 01:08:47.500
of programming, because I can't
remember how to make a

01:08:47.500 --> 01:08:50.156
random number generator, but I
can look it up there, and I

01:08:50.156 --> 01:08:51.720
can find out.

01:08:51.720 --> 01:08:54.850
And then, eventually, I return
the value of x which is the

01:08:54.850 --> 01:08:58.319
state variable internal to the
random number generator.

01:08:58.319 --> 01:09:00.140
That state variable
is initialized

01:09:00.140 --> 01:09:03.479
somehow, and has a value.

01:09:03.479 --> 01:09:06.490
And this procedure is defined
in the context where that

01:09:06.490 --> 01:09:10.450
variable is bound.

01:09:10.450 --> 01:09:15.930
So this is a hidden piece of
local state that you see here.

01:09:15.930 --> 01:09:21.720
And this procedure is defined
in that context.

01:09:21.720 --> 01:09:24.103
Now, that's a very simple
thing to do.

01:09:24.103 --> 01:09:26.020
And it's very nice.

01:09:26.020 --> 01:09:29.080
Supposing, I didn't want
to use assignments.

01:09:29.080 --> 01:09:30.819
Supposing, I wanted to write
this program without

01:09:30.819 --> 01:09:32.840
assignments.

01:09:32.840 --> 01:09:35.580
What problems would I have?

01:09:35.580 --> 01:09:37.890
Well, let's see.

01:09:37.890 --> 01:09:44.540
I'd like to use the overhead
machine here, thank you.

01:09:44.540 --> 01:09:45.870
First of all, let's look
at the whole thing.

01:09:45.870 --> 01:09:48.140
It's a big story.

01:09:48.140 --> 01:09:51.720
Unfortunately, which tells you
there is something wrong.

01:09:51.720 --> 01:09:54.255
It's at least that big,
and it's monolithic.

01:09:57.020 --> 01:09:59.580
You don't have to understand
or look at the text there

01:09:59.580 --> 01:10:02.120
right now to see that
it's monolithic.

01:10:02.120 --> 01:10:05.090
It isn't a thing which is
Cesaro's experiment.

01:10:05.090 --> 01:10:10.050
It's not pulled out from the
Monte Carlo process.

01:10:10.050 --> 01:10:10.890
It's not separated.

01:10:10.890 --> 01:10:12.140
Let's look why.

01:10:14.350 --> 01:10:19.330
Remember, the constraint here is
that every procedure return

01:10:19.330 --> 01:10:23.070
the same value for the
same arguments.

01:10:23.070 --> 01:10:26.800
Every procedure represents
a function.

01:10:26.800 --> 01:10:28.275
That's a different kind
of constraint.

01:10:28.275 --> 01:10:30.250
Because when I have assignments,
I can change some

01:10:30.250 --> 01:10:31.840
internal state variable.

01:10:31.840 --> 01:10:35.060
So let's see how that causes
things to go wrong.

01:10:35.060 --> 01:10:38.510
Well, start at the beginning.

01:10:38.510 --> 01:10:42.950
The estimate of pi looks
sort of the same.

01:10:42.950 --> 01:10:47.560
What I'm doing is I take the
square root of six over the

01:10:47.560 --> 01:10:52.990
random GCD test applied to n,
whereas that's what this is.

01:10:52.990 --> 01:10:55.390
But here, we are beginning
to see something funny.

01:10:55.390 --> 01:10:58.770
The random GCD test of a certain
number of trials is

01:10:58.770 --> 01:11:03.400
just like we had before, an
iteration on the number of

01:11:03.400 --> 01:11:06.210
trials remaining, the number
of trials that have been

01:11:06.210 --> 01:11:10.870
passed, and another
variable x.

01:11:10.870 --> 01:11:12.370
What's that x?

01:11:12.370 --> 01:11:14.950
That x is the state of the
random number generator.

01:11:18.950 --> 01:11:21.150
And it is now going
to be used here.

01:11:21.150 --> 01:11:23.890
The same random update function
that I have over here

01:11:23.890 --> 01:11:25.890
is the one I would have used in
a random number generator

01:11:25.890 --> 01:11:28.510
if I were building it the other
way, the one I get out

01:11:28.510 --> 01:11:31.710
of Knuth's books.

01:11:31.710 --> 01:11:33.380
x is going to get transformed
into x1, I

01:11:33.380 --> 01:11:34.950
need two random numbers.

01:11:34.950 --> 01:11:37.630
And x1 is going to get
transformed into x2, I have

01:11:37.630 --> 01:11:39.550
two random numbers.

01:11:39.550 --> 01:11:42.620
I then have to do exactly
what I did before.

01:11:42.620 --> 01:11:43.870
I take the GCD of x1 x2.

01:11:43.870 --> 01:11:48.260
If that's one, then I go around
the loop with x2 being

01:11:48.260 --> 01:11:49.520
the next value of x.

01:11:54.850 --> 01:11:57.740
You see what's happened here
is that the state of the

01:11:57.740 --> 01:12:00.480
random number generator is no
longer confined to the insides

01:12:00.480 --> 01:12:01.495
of the random number
generator.

01:12:01.495 --> 01:12:03.450
It has leaked out.

01:12:03.450 --> 01:12:09.240
It has leaked out into my
procedure that does the Monte

01:12:09.240 --> 01:12:10.720
Carlo experiment.

01:12:10.720 --> 01:12:13.480
But what's worse than that, is
it's also, because it was

01:12:13.480 --> 01:12:17.470
contained inside my experiment
itself, Cesaro, it leaked out

01:12:17.470 --> 01:12:18.090
of that too.

01:12:18.090 --> 01:12:21.920
Because Cesaro called twice, has
to have a different value

01:12:21.920 --> 01:12:24.780
each time, if I going to have
a legitimate experimental

01:12:24.780 --> 01:12:31.910
test. So Cesaro can't be a
function either, unless I pass

01:12:31.910 --> 01:12:34.730
it the seed of the random number
generator that is going

01:12:34.730 --> 01:12:36.490
to go wandering around.

01:12:36.490 --> 01:12:39.740
So unfortunately, the seed of
random number generator has

01:12:39.740 --> 01:12:42.850
leaked out into Cesaro, from the
random number generator,

01:12:42.850 --> 01:12:45.465
that's leaked into the Monte
Carlo experiment.

01:12:45.465 --> 01:12:48.485
And, unfortunately, my Monte
Carlo experiment here is no

01:12:48.485 --> 01:12:50.310
longer general.

01:12:50.310 --> 01:12:52.990
The Monte Carlo experiment here
knows how many random

01:12:52.990 --> 01:12:54.405
numbers I need to do
the experiment.

01:12:58.530 --> 01:13:00.230
That's sort of horrible.

01:13:00.230 --> 01:13:04.090
I lost an ability to decompose a
problem into pieces, because

01:13:04.090 --> 01:13:10.720
I wasn't willing to accept the
little loop of information,

01:13:10.720 --> 01:13:14.720
the feedback process, that
happens inside the random

01:13:14.720 --> 01:13:18.000
number generator before that
was made by having an

01:13:18.000 --> 01:13:20.400
assignment to a state variable
that was confined to the

01:13:20.400 --> 01:13:22.770
random number generator.

01:13:22.770 --> 01:13:26.070
So the fact that the random
number generator is an object,

01:13:26.070 --> 01:13:29.040
with an internal state variable,
it's affected by

01:13:29.040 --> 01:13:30.595
nothing, but it'll give you
something, and it will apply

01:13:30.595 --> 01:13:34.290
it's force to you, that was
what we're missing now.

01:13:38.140 --> 01:13:42.870
OK, well I think we've seen
enough reason for doing this,

01:13:42.870 --> 01:13:45.510
and it all sort of looks
very wonderful.

01:13:45.510 --> 01:13:51.840
Wouldn't it be nice if
assignment was a good thing

01:13:51.840 --> 01:13:55.440
and maybe it's worth it,
but I'm not sure.

01:13:55.440 --> 01:13:57.860
As Mr. Gilbert and Sullivan
said, things are seldom what

01:13:57.860 --> 01:14:01.940
they seem, skim milk masquerades
as cream.

01:14:01.940 --> 01:14:03.655
Are there any questions?

01:14:17.010 --> 01:14:20.120
Are there any philosophers
here?

01:14:20.120 --> 01:14:21.930
Anybody want to argue
about objects?

01:14:24.590 --> 01:14:25.840
You're just floored, right?

01:14:29.840 --> 01:14:30.805
And you haven't done
your homework yet.

01:14:30.805 --> 01:14:32.055
You haven't come up with
a good question.

01:14:36.790 --> 01:14:38.040
Oh, well.

01:14:40.110 --> 01:14:41.120
Sure, thank you.

01:14:41.120 --> 01:14:42.370
Let's take the long break now.