WEBVTT

00:00:00.000 --> 00:00:02.425
[SQUEAKING]

00:00:02.425 --> 00:00:04.365
[RUSTLING]

00:00:04.365 --> 00:00:05.820
[CLICKING]

00:00:12.620 --> 00:00:16.340
JUSTIN SOLOMON: Well, welcome
to problem session 5 of 6.006.

00:00:16.340 --> 00:00:20.195
It's a pleasure to see all
your smiling faces here today.

00:00:20.195 --> 00:00:22.070
This week, we're going
to cover some problems

00:00:22.070 --> 00:00:24.947
in graph theory related
to depth-first search

00:00:24.947 --> 00:00:27.530
and breadth-first search, which
were roughly the topics that I

00:00:27.530 --> 00:00:29.060
guess we've covered in
the last couple lectures

00:00:29.060 --> 00:00:30.920
and what's going to
be on your homework.

00:00:30.920 --> 00:00:32.753
And I believe this is
basically the homework

00:00:32.753 --> 00:00:36.440
from last year with
a few revisions,

00:00:36.440 --> 00:00:38.282
based on some typos we caught.

00:00:38.282 --> 00:00:39.740
Oh, and I caught
a spelling mistake

00:00:39.740 --> 00:00:41.960
that I'll bother our
instructor about later.

00:00:41.960 --> 00:00:42.950
OK.

00:00:42.950 --> 00:00:44.913
So without further
ado, let's get started.

00:00:44.913 --> 00:00:47.330
I guess we'll just do them in
order for lack of creativity

00:00:47.330 --> 00:00:48.068
here.

00:00:48.068 --> 00:00:50.360
The very first problem has
to do with some measurements

00:00:50.360 --> 00:00:54.170
on a graph, which is actually
a really interesting one to me.

00:00:54.170 --> 00:00:56.378
So it turns out that in
a lot of research in--

00:00:56.378 --> 00:00:57.920
for some reason, in
computer science,

00:00:57.920 --> 00:00:59.878
there's graph theory
research, and then there's

00:00:59.878 --> 00:01:01.050
networks research.

00:01:01.050 --> 00:01:03.170
And these are two
different communities

00:01:03.170 --> 00:01:05.600
for weird historical
reasons that I don't totally

00:01:05.600 --> 00:01:06.830
understand.

00:01:06.830 --> 00:01:09.140
But people in the network
science literature

00:01:09.140 --> 00:01:11.000
often measure things
like the radius

00:01:11.000 --> 00:01:12.937
of the graph and some
other kind of measures

00:01:12.937 --> 00:01:15.020
that are trying to tell
you something about, like,

00:01:15.020 --> 00:01:16.970
is a graph a long,
spread-out thing,

00:01:16.970 --> 00:01:20.510
like a line graph, or something
super compact, like a star?

00:01:20.510 --> 00:01:21.447
And so on.

00:01:21.447 --> 00:01:23.030
And so this problem
is kind of digging

00:01:23.030 --> 00:01:24.873
into the algorithmic
aspects of how

00:01:24.873 --> 00:01:26.540
we might compute one
of the measurements

00:01:26.540 --> 00:01:32.520
that I believe is fairly
common in that community.

00:01:32.520 --> 00:01:34.340
So let's kind of go
through these problems.

00:01:34.340 --> 00:01:37.718
As usual, in 6.006, we
like to take actually

00:01:37.718 --> 00:01:39.760
relatively straightforward
computational problems

00:01:39.760 --> 00:01:41.740
and then dress them up
with a lot of language

00:01:41.740 --> 00:01:43.840
to make it annoying
for you guys to parse.

00:01:43.840 --> 00:01:47.240
And indeed, this problem
is no exception to that.

00:01:47.240 --> 00:01:50.560
So in this problem, we're
given an undirected graph.

00:01:56.050 --> 00:02:00.980
And as usual, we
will call him G.

00:02:00.980 --> 00:02:02.960
And we define a
particular number

00:02:02.960 --> 00:02:05.380
that we're trying to measure
in this problem, right?

00:02:05.380 --> 00:02:12.140
So in particular, if
we're given a vertex v,

00:02:12.140 --> 00:02:15.860
then we can define something
called the eccentricity of v,

00:02:15.860 --> 00:02:19.470
which is the distance to
the farthest-away thing.

00:02:19.470 --> 00:02:22.250
So in particular,
we can define--

00:02:27.290 --> 00:02:31.730
it's going to be given by
the following, which is

00:02:31.730 --> 00:02:35.540
the max over all the possible--

00:02:35.540 --> 00:02:38.347
I'll try to make
sure my notation--

00:02:38.347 --> 00:02:39.930
oops, I've already--
well, that's OK--

00:02:42.990 --> 00:02:50.070
over all the other vertices
of the distance from v to w.

00:02:50.070 --> 00:02:52.140
So I'm standing at
a point on a graph.

00:02:52.140 --> 00:02:54.090
And now I like
make a loud noise.

00:02:54.090 --> 00:02:56.850
And the last person to hear
me, the distance to him

00:02:56.850 --> 00:03:00.760
would be the eccentricity
of that vertex.

00:03:00.760 --> 00:03:06.000
And so this is some kind of
notion of radius or diameter,

00:03:06.000 --> 00:03:08.197
but sort of planted at a point.

00:03:08.197 --> 00:03:10.530
And then if we want to learn
a property not of a vertex,

00:03:10.530 --> 00:03:13.230
but of the entire graph,
one thing we can do

00:03:13.230 --> 00:03:14.250
is define the radius.

00:03:17.510 --> 00:03:25.390
And that is given by R
of G is the min over all

00:03:25.390 --> 00:03:31.390
of the different vertices,
u, of the eccentricity of u.

00:03:31.390 --> 00:03:33.640
OK, so I think this is one
of these definitions that's

00:03:33.640 --> 00:03:35.425
really annoying to
parse and think about.

00:03:35.425 --> 00:03:37.300
So we should draw a
little bit of a schematic

00:03:37.300 --> 00:03:40.270
and see what's going
on here, because

00:03:40.270 --> 00:03:42.250
especially as a geometry
professor, this one's

00:03:42.250 --> 00:03:44.710
kind of nice, because it
translates directly to what you

00:03:44.710 --> 00:03:46.010
might do in metric geometry.

00:03:46.010 --> 00:03:49.780
So let's say that I
have a circle here.

00:03:49.780 --> 00:03:51.610
And I want the world's
most complicated way

00:03:51.610 --> 00:03:53.890
of defining its radius.

00:03:53.890 --> 00:03:56.890
So for any given point--

00:03:56.890 --> 00:03:58.120
there's a point in a circle.

00:03:58.120 --> 00:03:59.470
That's a circle, in
case you were wondering.

00:03:59.470 --> 00:04:01.160
You know those
internet contests where

00:04:01.160 --> 00:04:03.160
they have people that
just walk up to the board,

00:04:03.160 --> 00:04:05.350
and draw perfect
circles, and then leave?

00:04:05.350 --> 00:04:09.280
I unfortunately am not
an expert at this matter.

00:04:09.280 --> 00:04:11.740
But anyway, so if we
think of a point--

00:04:11.740 --> 00:04:14.080
like a circle as some
analog of our graph,

00:04:14.080 --> 00:04:15.730
and then I draw a
point, which might

00:04:15.730 --> 00:04:19.360
be the analog of a vertex,
then what is the eccentricity?

00:04:19.360 --> 00:04:23.350
Well, it's the distance to the
farthest-away point, right?

00:04:23.350 --> 00:04:28.450
So for this guy, it might
be the length of this line,

00:04:28.450 --> 00:04:30.730
roughly, because
that's the distance

00:04:30.730 --> 00:04:32.720
to the farthest-away thing.

00:04:32.720 --> 00:04:36.280
So for every different
point that I draw,

00:04:36.280 --> 00:04:38.110
each point has its own
farthest-away point

00:04:38.110 --> 00:04:39.857
in the circle.

00:04:39.857 --> 00:04:41.440
So there's some
positive number that's

00:04:41.440 --> 00:04:43.680
assigned to every single
point in this domain.

00:04:43.680 --> 00:04:46.870
And if I take the minimum
of that positive number,

00:04:46.870 --> 00:04:48.694
where do you think I end up?

00:04:48.694 --> 00:04:49.990
AUDIENCE: Center of the circle.

00:04:49.990 --> 00:04:51.490
JUSTIN SOLOMON:
That's right, Jason.

00:04:51.490 --> 00:04:53.050
I end up in the
center of the circle,

00:04:53.050 --> 00:04:55.210
because if I think
about it, the distance

00:04:55.210 --> 00:04:58.750
to the farthest-away point
in this domain, one thing you

00:04:58.750 --> 00:05:00.250
can convince yourself
is that that's

00:05:00.250 --> 00:05:02.270
sort of as small as possible.

00:05:02.270 --> 00:05:04.240
So this is what we might
call a min-max problem

00:05:04.240 --> 00:05:07.000
in optimization, because
we are minimizing

00:05:07.000 --> 00:05:09.820
the maximum distance, yeah?

00:05:09.820 --> 00:05:11.420
This also shows
up in game theory,

00:05:11.420 --> 00:05:13.700
all kinds of different
places that solve this stuff.

00:05:13.700 --> 00:05:15.492
But thankfully, in this
particular problem,

00:05:15.492 --> 00:05:17.020
we're not going
to need all that.

00:05:17.020 --> 00:05:18.680
OK, so right.

00:05:18.680 --> 00:05:22.100
So this homework
problem has two parts.

00:05:22.100 --> 00:05:25.480
The first is to give an
algorithm for computing

00:05:25.480 --> 00:05:27.152
the radius of a graph.

00:05:27.152 --> 00:05:29.110
And then the second one
is to give an algorithm

00:05:29.110 --> 00:05:31.540
for approximating the
radius of the graph

00:05:31.540 --> 00:05:35.032
really quickly, or more
quickly than the first part.

00:05:35.032 --> 00:05:37.240
I actually don't know if
there's a lower bound there.

00:05:37.240 --> 00:05:40.060
But come back to that later.

00:05:40.060 --> 00:05:47.430
OK, so in part a, we're
given G. And moreover, we're

00:05:47.430 --> 00:05:49.930
given one additional piece of
information, which we actually

00:05:49.930 --> 00:05:50.965
do need in this problem.

00:05:50.965 --> 00:05:53.590
I think it's one of those words
that kind of slips past us when

00:05:53.590 --> 00:05:55.270
we read a graph theory problem.

00:05:55.270 --> 00:05:57.430
But it's important to
pay attention, of course.

00:05:57.430 --> 00:06:02.427
And that is, we're given
G. And it's connected.

00:06:02.427 --> 00:06:04.510
I suppose, really, it
should be given connected G.

00:06:04.510 --> 00:06:06.530
But that's OK.

00:06:06.530 --> 00:06:14.860
Now what we want is to compute
the radius of G in time that

00:06:14.860 --> 00:06:17.920
looks like the product
of the vertices,

00:06:17.920 --> 00:06:20.320
the number of vertices-- oops--

00:06:20.320 --> 00:06:23.800
times the number of edges,
or the number of times

00:06:23.800 --> 00:06:25.530
the number of vertices.

00:06:25.530 --> 00:06:27.442
Your instructor struggles
to speak and write

00:06:27.442 --> 00:06:28.150
at the same time.

00:06:28.150 --> 00:06:30.310
But it's a skill
that I'm working on.

00:06:30.310 --> 00:06:33.750
And frankly, handwriting is much
easier with this little chalk.

00:06:33.750 --> 00:06:34.600
OK.

00:06:34.600 --> 00:06:38.620
So essentially-- I used to have
a math professor in college

00:06:38.620 --> 00:06:40.900
that used this phrase all
the time that was just

00:06:40.900 --> 00:06:43.360
like, it's important
not to think here.

00:06:43.360 --> 00:06:48.130
The problem asks you to
compute the radius of a graph.

00:06:48.130 --> 00:06:49.840
And in some sense,
there's an algorithm

00:06:49.840 --> 00:06:52.990
that just writes itself for
computing the radius, right?

00:06:52.990 --> 00:06:55.900
Because the radius is the
min over all the vertices,

00:06:55.900 --> 00:06:57.460
of the eccentricity.

00:06:57.460 --> 00:06:59.690
The eccentricity is
the max distance.

00:06:59.690 --> 00:07:01.780
So what would be the
simplest thing to do here?

00:07:01.780 --> 00:07:05.528
Well, in some sense, it would be
to loop over all the vertices,

00:07:05.528 --> 00:07:07.570
compute their distance to
all the other vertices,

00:07:07.570 --> 00:07:11.600
and take the max for
each one of those

00:07:11.600 --> 00:07:14.710
and then the min over all of
the guys in the outer loop.

00:07:14.710 --> 00:07:17.170
Since I just said a sentence
that I'm realizing doesn't

00:07:17.170 --> 00:07:20.860
parse particularly well, let's
sort of write down what I mean,

00:07:20.860 --> 00:07:24.130
which is to say, we're going to
think of there being an outer--

00:07:24.130 --> 00:07:27.170
that's why we don't use this
chalk-- an outer for loop,

00:07:27.170 --> 00:07:29.230
which is computing this min.

00:07:29.230 --> 00:07:33.070
So-- right?

00:07:33.070 --> 00:07:34.320
Well, what are we going to do?

00:07:34.320 --> 00:07:45.390
We can compute the
shortest path distance

00:07:45.390 --> 00:08:01.450
to all of the other w in my
graph, take the max of w--

00:08:01.450 --> 00:08:04.860
of distance from v
to all the other w's.

00:08:04.860 --> 00:08:08.010
Obviously, we can kind of do
these two at the same time.

00:08:08.010 --> 00:08:10.980
And then, if this number is
bigger than my current max,

00:08:10.980 --> 00:08:12.470
keep it.

00:08:12.470 --> 00:08:13.470
Oh, yikes.

00:08:13.470 --> 00:08:18.280
If it's smaller than the current
estimate I have of the radius,

00:08:18.280 --> 00:08:18.960
then I keep it.

00:08:18.960 --> 00:08:20.835
And if it's not, then
I throw it away, right?

00:08:20.835 --> 00:08:25.480
So maybe I initialize
my radius at infinity.

00:08:25.480 --> 00:08:29.410
And now let's call this
number, I don't know, little r.

00:08:29.410 --> 00:08:34.409
If little r is less
than big R, then just

00:08:34.409 --> 00:08:36.650
keep it around, right?

00:08:36.650 --> 00:08:38.336
And so if we think
about it, I don't

00:08:38.336 --> 00:08:40.669
think it's terribly hard to
prove that this algorithm is

00:08:40.669 --> 00:08:42.799
correct, because it's
sort of just taking

00:08:42.799 --> 00:08:45.500
our definition of what
the radius of a graph is

00:08:45.500 --> 00:08:49.440
and translating it into
a braindead algorithm.

00:08:49.440 --> 00:08:52.310
So I think really,
the challenge here

00:08:52.310 --> 00:08:57.420
is proving the runtime in
this particular algorithm.

00:08:57.420 --> 00:08:59.020
So what does our
runtime look like?

00:08:59.020 --> 00:09:03.800
So we have a loop over vertices.

00:09:03.800 --> 00:09:07.640
So I kind of incur a
factor of mod v here.

00:09:07.640 --> 00:09:11.030
And then, well, our
graph is unweighted.

00:09:11.030 --> 00:09:14.210
So one strategy for computing
the shortest path distance

00:09:14.210 --> 00:09:16.783
would be breadth-first search.

00:09:16.783 --> 00:09:18.200
I think that's
what's in my notes.

00:09:18.200 --> 00:09:19.340
Yep.

00:09:19.340 --> 00:09:21.680
And in general,
breadth-first search,

00:09:21.680 --> 00:09:28.380
if you recall from lecture,
takes mod v plus mod E time.

00:09:28.380 --> 00:09:31.817
So the question is, OK, so if I
multiply these things together,

00:09:31.817 --> 00:09:32.400
what do I get?

00:09:32.400 --> 00:09:43.400
I get O of v times v
plus E, like that, time.

00:09:43.400 --> 00:09:44.450
But like, uh-oh.

00:09:44.450 --> 00:09:47.450
That's not the time that my
homework problem wanted, right?

00:09:47.450 --> 00:09:49.070
Because the homework
problem asks

00:09:49.070 --> 00:09:53.000
you to solve this in
just mod v times E time.

00:09:53.000 --> 00:09:56.330
And somehow we've
incurred an extra factor.

00:09:56.330 --> 00:09:59.297
And now we have to figure
out why this is actually OK,

00:09:59.297 --> 00:10:00.630
or we have to fix our algorithm.

00:10:00.630 --> 00:10:03.170
But in this case, it turns
out that this runtime

00:10:03.170 --> 00:10:07.360
is just inaccurate, OK?

00:10:07.360 --> 00:10:08.590
What's our intuition here?

00:10:08.590 --> 00:10:11.650
Well, I kind of underlined
it for you here.

00:10:11.650 --> 00:10:13.442
Our graph is connected.

00:10:13.442 --> 00:10:15.420
And in particular,
there's going to be

00:10:15.420 --> 00:10:18.600
a nice property of
connected graphs, which

00:10:18.600 --> 00:10:21.210
is that the number of edges
dwarfs the number of vertices

00:10:21.210 --> 00:10:22.060
here.

00:10:22.060 --> 00:10:25.200
So really, if we have v
plus E, in some sense,

00:10:25.200 --> 00:10:27.480
this is going to look like
a constant factor times E

00:10:27.480 --> 00:10:29.320
plus another E here.

00:10:29.320 --> 00:10:32.010
So this whole thing is going
to be v times E time, yeah?

00:10:32.010 --> 00:10:36.310
So let's make that argument
a tiny bit more formal here.

00:10:36.310 --> 00:10:41.250
So in particular, we
know that G is connected.

00:10:46.050 --> 00:10:49.170
And every vertex--
so in particular,

00:10:49.170 --> 00:10:51.270
what can happen here is--

00:10:51.270 --> 00:10:54.510
OK, unless my graph consists
of one vertex, which

00:10:54.510 --> 00:10:57.387
is a case you could dispose of
pretty quickly, what I can't

00:10:57.387 --> 00:10:59.970
have is a graph that looks like
this, like one vertex and then

00:10:59.970 --> 00:11:01.350
an edge floating around there.

00:11:01.350 --> 00:11:05.790
Everything has to be
connected together--

00:11:05.790 --> 00:11:07.180
connected together.

00:11:07.180 --> 00:11:10.530
OK, so in particular,
what this means

00:11:10.530 --> 00:11:22.770
is that every vertex is adjacent
to at least one edge, again,

00:11:22.770 --> 00:11:24.930
except, I guess, technically,
the one vertex case.

00:11:24.930 --> 00:11:26.520
But I think we can
convince ourselves

00:11:26.520 --> 00:11:28.110
that for any graph
of constant size,

00:11:28.110 --> 00:11:30.540
we're not terribly
worried about it, right?

00:11:30.540 --> 00:11:33.090
It's just the asymptotics
that matter in this problem.

00:11:33.090 --> 00:11:35.700
OK, so if every vertex
is adjacent to one

00:11:35.700 --> 00:11:38.700
edge, well-- and remember
that every edge, kind

00:11:38.700 --> 00:11:42.070
of by definition of an edge,
is adjacent to two vertices.

00:11:42.070 --> 00:11:45.210
Then what we can conclude is
that the number of vertices

00:11:45.210 --> 00:11:48.480
is less than or equal to the
number of edges divided by 2.

00:11:48.480 --> 00:11:50.860
This is a conservative estimate.

00:11:50.860 --> 00:11:53.680
And so in particular,
what does that mean?

00:11:53.680 --> 00:11:59.478
It means that v is
big O of E. This

00:11:59.478 --> 00:12:01.770
is a case where we have to
be quite careful about big O

00:12:01.770 --> 00:12:04.310
being an upper bound, right?

00:12:04.310 --> 00:12:07.710
In this case, typically,
v is much less than E--

00:12:07.710 --> 00:12:09.720
well, depends how
many edges, like

00:12:09.720 --> 00:12:12.760
if you have a really
dense graph or not.

00:12:12.760 --> 00:12:14.380
But in this case,
what does that mean?

00:12:14.380 --> 00:12:22.030
That means that mod v plus mod
E is really just big O of mod E,

00:12:22.030 --> 00:12:22.530
right?

00:12:22.530 --> 00:12:26.220
Because this is big O of
mod E plus big O of mod E.

00:12:26.220 --> 00:12:35.840
And that means that our problem
really runs in v times E time,

00:12:35.840 --> 00:12:38.320
which is what we
wanted in our problem.

00:12:38.320 --> 00:12:44.340
Are there any questions from
our audience on part a here?

00:12:44.340 --> 00:12:44.840
Cool.

00:12:44.840 --> 00:12:47.710
AUDIENCE: I don't
quite understand why--

00:12:47.710 --> 00:12:49.570
where you went from
the first statement

00:12:49.570 --> 00:12:51.520
to the second statement there.

00:12:51.520 --> 00:12:55.318
At least one edge implies v is
less than or equal to E over 2.

00:12:55.318 --> 00:12:56.360
JUSTIN SOLOMON: Oh, yeah.

00:12:56.360 --> 00:12:59.110
So I guess there's sort of two
things that matter here, right?

00:12:59.110 --> 00:13:02.800
Every vertex is adjacent
to one edge at most.

00:13:02.800 --> 00:13:08.680
And every edge-- yikes.

00:13:08.680 --> 00:13:16.593
Every edge is adjacent
to two vertices.

00:13:16.593 --> 00:13:18.760
I guess, actually, it's the
second one that matters.

00:13:18.760 --> 00:13:22.070
So you can never have a vertex
just floating by itself.

00:13:22.070 --> 00:13:24.625
So one way that I can
count my number of vertices

00:13:24.625 --> 00:13:26.530
is by looking at
the number of edges

00:13:26.530 --> 00:13:30.250
and saying that, well, every
edge can touch exactly two

00:13:30.250 --> 00:13:30.820
vertices.

00:13:30.820 --> 00:13:33.160
Every vertex has
to touch exactly--

00:13:33.160 --> 00:13:34.725
well, at least one edge.

00:13:34.725 --> 00:13:36.100
So if you put
those together, you

00:13:36.100 --> 00:13:38.363
can convince yourself that
this bound has to be 2.

00:13:38.363 --> 00:13:40.030
If you want to be
conservative about it,

00:13:40.030 --> 00:13:42.760
you can just get rid of the
divided by 2 here, I guess.

00:13:42.760 --> 00:13:45.570
It doesn't really matter.

00:13:45.570 --> 00:13:47.280
Any other questions
from our audience?

00:13:47.280 --> 00:13:48.330
Cool.

00:13:48.330 --> 00:13:52.710
All right, so now, let's
take a look at part b.

00:13:52.710 --> 00:13:57.248
So in part b here, they ask us
to basically do some version

00:13:57.248 --> 00:13:58.290
of the same thing, right?

00:13:58.290 --> 00:14:00.870
They want us to now
approximate the radius.

00:14:00.870 --> 00:14:03.850
But we're given a
smaller budget of time.

00:14:03.850 --> 00:14:08.250
So now what we want
in number b here

00:14:08.250 --> 00:14:17.730
is, compute an R
star such that--

00:14:17.730 --> 00:14:21.420
I got yelled at in my
textbook that st should always

00:14:21.420 --> 00:14:22.830
be "subject to."

00:14:22.830 --> 00:14:24.900
I got an angry review
of the textbook

00:14:24.900 --> 00:14:27.300
I wrote because of that,
which was puzzling to me.

00:14:27.300 --> 00:14:32.310
But amazon.com is not a
great source of useful data.

00:14:32.310 --> 00:14:35.280
But in any event, we
want R star, which

00:14:35.280 --> 00:14:40.000
is sandwiched between
the radius of G

00:14:40.000 --> 00:14:45.740
and 2 times the radius
of G, like that.

00:14:45.740 --> 00:14:48.115
Now, notice-- so in
other words, we want to--

00:14:48.115 --> 00:14:49.990
the first thing to notice
is we want to upper

00:14:49.990 --> 00:14:53.060
bound the radius of our graph.

00:14:53.060 --> 00:14:55.310
And already, this
should suggest to us

00:14:55.310 --> 00:14:58.520
how we might solve this problem,
because if we take a look back

00:14:58.520 --> 00:15:00.600
at our definition
of radius over here,

00:15:00.600 --> 00:15:03.440
notice that the radius
is a min, right?

00:15:03.440 --> 00:15:06.230
So what's going to
happen if I returned

00:15:06.230 --> 00:15:08.330
epsilon of some other vertex?

00:15:08.330 --> 00:15:10.490
Well, it's lower
bounded by the radius,

00:15:10.490 --> 00:15:12.740
because the radius is the
smallest possible epsilon

00:15:12.740 --> 00:15:14.300
over any vertex.

00:15:14.300 --> 00:15:16.160
That make sense?

00:15:16.160 --> 00:15:18.320
Now, when I was
doing this problem,

00:15:18.320 --> 00:15:21.290
because, you know, I'm the
dumb instructor of the three,

00:15:21.290 --> 00:15:25.700
I said, well, OK,
but maybe I need

00:15:25.700 --> 00:15:29.480
to be somehow judicious
about what vertex I choose.

00:15:29.480 --> 00:15:32.612
Like, well, in some
sense, what this suggests

00:15:32.612 --> 00:15:34.320
is that maybe I choose
some other vertex,

00:15:34.320 --> 00:15:36.770
and compute its
radius, and return

00:15:36.770 --> 00:15:38.900
that as our approximation.

00:15:38.900 --> 00:15:41.420
But of course, the problem
wants me to sandwich it

00:15:41.420 --> 00:15:42.780
between two values here.

00:15:42.780 --> 00:15:46.498
So in addition to
upper bounding R,

00:15:46.498 --> 00:15:48.540
I want to be less than 2
times R. In other words,

00:15:48.540 --> 00:15:51.860
my approximation is
within a constant factor.

00:15:51.860 --> 00:15:54.470
I tried some weird stuff, like
farthest point sampling and so

00:15:54.470 --> 00:15:54.970
on.

00:15:54.970 --> 00:15:57.140
Then I realized that you
actually don't really

00:15:57.140 --> 00:15:58.490
need to do any of that.

00:15:58.490 --> 00:16:02.750
One thing you can do is
literally choose any vertex,

00:16:02.750 --> 00:16:06.020
return its eccentricity.

00:16:06.020 --> 00:16:08.330
And that's actually good enough.

00:16:08.330 --> 00:16:12.050
So here's our algorithm.

00:16:12.050 --> 00:16:14.287
Let me go back to my notes here.

00:16:14.287 --> 00:16:16.370
I don't know why I'm
following my notes, actually.

00:16:16.370 --> 00:16:17.100
I could do this off
the top of my head.

00:16:17.100 --> 00:16:19.400
But they make me feel
better if I'm looking

00:16:19.400 --> 00:16:21.660
at them at the same time.

00:16:21.660 --> 00:16:31.830
So in particular, what I'm going
to do is choose u and v. Let me

00:16:31.830 --> 00:16:32.730
be clear here--

00:16:32.730 --> 00:16:36.960
any u and v. So if I'm
using some data structure

00:16:36.960 --> 00:16:40.620
to store all my vertices, I just
take the first one, whatever.

00:16:40.620 --> 00:16:53.012
And two, I'm going to return R
star is equal to epsilon of u.

00:16:53.012 --> 00:16:54.970
Now, of course, this
isn't really an algorithm.

00:16:54.970 --> 00:16:56.770
If you do this on your
homework, you'll lose points.

00:16:56.770 --> 00:16:58.478
And the reason is that
I haven't told you

00:16:58.478 --> 00:17:00.545
how to compute this value here.

00:17:00.545 --> 00:17:02.920
So if you were to write out
your answer for this problem,

00:17:02.920 --> 00:17:04.810
of course, you
should tell us that,

00:17:04.810 --> 00:17:07.420
like, really, to compute
epsilon, what do I do?

00:17:07.420 --> 00:17:09.250
I use breadth-first
search to compute

00:17:09.250 --> 00:17:11.710
the shortest path from u
to all the other vertices.

00:17:11.710 --> 00:17:14.460
And then I guess I take
the max value here.

00:17:14.460 --> 00:17:17.200
OK, so I think you guys
can fill in the details

00:17:17.200 --> 00:17:19.000
of the algorithm.

00:17:19.000 --> 00:17:20.740
The bigger challenge
is going to be

00:17:20.740 --> 00:17:24.400
to prove that this is
actually a good bound, right?

00:17:24.400 --> 00:17:28.480
And so, in other words,
what we need to prove here--

00:17:28.480 --> 00:17:29.063
I don't know.

00:17:29.063 --> 00:17:29.980
Like, there's a claim.

00:17:29.980 --> 00:17:31.000
There's a proposition.

00:17:31.000 --> 00:17:33.202
There's a theorem,
somewhere on that axis.

00:17:33.202 --> 00:17:34.660
I'm going to call
this one a claim.

00:17:34.660 --> 00:17:37.600
I'm going to downgrade it.

00:17:37.600 --> 00:17:42.820
And that is that the
radius of my graph

00:17:42.820 --> 00:17:47.680
is less than or equal to
R star, which is less than

00:17:47.680 --> 00:17:53.140
or equal to 2 times
the radius of my graph.

00:17:53.140 --> 00:17:57.586
OK, so let's prove this thing.

00:17:57.586 --> 00:18:02.240
I'm managing to use all of my
boards on one problem here.

00:18:02.240 --> 00:18:05.720
OK, so in particular,
to prove this claim,

00:18:05.720 --> 00:18:07.190
I need to prove
two inequalities.

00:18:07.190 --> 00:18:09.680
This is like two
homework problems in one.

00:18:09.680 --> 00:18:11.010
So let's number those off.

00:18:11.010 --> 00:18:12.080
There's 1.

00:18:12.080 --> 00:18:14.040
There's 2.

00:18:14.040 --> 00:18:19.080
OK, so let's do inequality 1.

00:18:19.080 --> 00:18:23.860
I think we can squeeze him
into a relatively small space.

00:18:23.860 --> 00:18:28.000
So remember, what is
the radius of my graph?

00:18:28.000 --> 00:18:30.960
Well, just by
definition, we know

00:18:30.960 --> 00:18:39.270
that it's the min over all
possible u of epsilon of u.

00:18:39.270 --> 00:18:41.020
So in particular, what's--

00:18:41.020 --> 00:18:43.020
the nice property about
the minimum of something

00:18:43.020 --> 00:18:46.050
is that it's less than
everything else or equal.

00:18:46.050 --> 00:18:49.860
So this-- maybe
let's call this u0,

00:18:49.860 --> 00:18:52.500
just to distinguish between
that and the notation I

00:18:52.500 --> 00:18:53.940
have on the left-hand side.

00:18:53.940 --> 00:18:58.210
This is less than or
equal to epsilon of u,

00:18:58.210 --> 00:19:02.770
because, I don't know,
because min, yeah?

00:19:02.770 --> 00:19:05.200
So that actually already--

00:19:05.200 --> 00:19:08.770
and of course, this is exactly
what we chose to be our R star.

00:19:08.770 --> 00:19:12.340
So our first part of
our proof is done here.

00:19:12.340 --> 00:19:14.680
So this is the easy part.

00:19:14.680 --> 00:19:16.218
And sometimes,
like, this is sort

00:19:16.218 --> 00:19:17.510
of what inspired our algorithm.

00:19:17.510 --> 00:19:20.890
So we expect this bound to
be kind of straightforward.

00:19:20.890 --> 00:19:23.680
OK, but the other
half of the problem

00:19:23.680 --> 00:19:26.120
is a little more tricky.

00:19:26.120 --> 00:19:28.360
And actually, there's a
solution in the notes.

00:19:28.360 --> 00:19:30.550
And then I decided, just to make
it a little more inaccurate,

00:19:30.550 --> 00:19:31.342
to write up my own.

00:19:33.940 --> 00:19:36.753
But actually, I have I have
an ulterior motive, which

00:19:36.753 --> 00:19:38.170
is I notice in
this class we don't

00:19:38.170 --> 00:19:40.900
tend to use a tiny piece
of notation that I like.

00:19:40.900 --> 00:19:43.060
So for my convenience in
future problems sessions,

00:19:43.060 --> 00:19:46.000
I thought I'd introduce it now.

00:19:46.000 --> 00:19:49.040
So we're solving a
minimization problem.

00:19:49.040 --> 00:19:51.040
The nice thing is that
in this class, everything

00:19:51.040 --> 00:19:52.307
we do is finite.

00:19:52.307 --> 00:19:53.890
If you take my
graduate course, that's

00:19:53.890 --> 00:19:55.100
not going to be the case.

00:19:55.100 --> 00:19:56.230
In fact, actually,
in lecture 2, we're

00:19:56.230 --> 00:19:57.813
going to do like
variational calculus.

00:19:57.813 --> 00:20:01.400
But in this course,
what does that mean?

00:20:01.400 --> 00:20:03.700
That means if I
minimize a function,

00:20:03.700 --> 00:20:05.920
there is actually a
vertex in my graph

00:20:05.920 --> 00:20:09.160
that achieves that
minimum, right?

00:20:09.160 --> 00:20:11.330
This is different than
like, for example, if I--

00:20:11.330 --> 00:20:12.080
then I'll shut up.

00:20:12.080 --> 00:20:17.950
But if I wanted to minimize--
here's f of x equals 1 over x,

00:20:17.950 --> 00:20:19.780
and I ask you for
the minimum value.

00:20:19.780 --> 00:20:23.770
Well, it's over all x
greater than or equal to 0.

00:20:23.770 --> 00:20:27.340
Well, the minimum value is 0
if I take x off to infinity.

00:20:27.340 --> 00:20:29.110
But it never quite crosses 0.

00:20:29.110 --> 00:20:31.300
So you're kind of in
this weird universe.

00:20:31.300 --> 00:20:33.940
If you remember Jason's lecture,
he talked about infs and sups

00:20:33.940 --> 00:20:35.770
as opposed to mins and maxes.

00:20:35.770 --> 00:20:38.672
But this can't happen
in our problem,

00:20:38.672 --> 00:20:40.630
because when we compute
a min, there's actually

00:20:40.630 --> 00:20:42.400
a vertex that achieves it.

00:20:42.400 --> 00:20:45.880
And that vertex,
we call arg min.

00:20:45.880 --> 00:20:48.980
And so this arg here
stands for argument.

00:20:48.980 --> 00:20:51.370
So one thing that I
can do is say, OK.

00:20:51.370 --> 00:20:59.190
So remember that my
radius is the min, the min

00:20:59.190 --> 00:21:03.660
over all u of epsilon of u.

00:21:03.660 --> 00:21:09.045
Then I'm going to define a
vertex, u0, to be the arg

00:21:09.045 --> 00:21:14.620
min over u of epsilon of u.

00:21:14.620 --> 00:21:16.930
And this is just fancy
notation for saying, give me

00:21:16.930 --> 00:21:19.780
the actual vertex that
makes this value as

00:21:19.780 --> 00:21:22.095
small as possible, yeah?

00:21:22.095 --> 00:21:23.470
The nice thing
about this problem

00:21:23.470 --> 00:21:27.268
is that we're not worried yet
about how we make runtime.

00:21:27.268 --> 00:21:28.810
So I can construct
this kind of thing

00:21:28.810 --> 00:21:31.510
and not worry about how I
actually found it, right?

00:21:31.510 --> 00:21:33.980
OK, so let's say
that we did that.

00:21:33.980 --> 00:21:38.740
So this is, find me the
vertex that actually gives me

00:21:38.740 --> 00:21:39.940
the radius, right?

00:21:39.940 --> 00:21:41.690
So in other words,
I find that vertex.

00:21:41.690 --> 00:21:45.110
And then I find his or
her farthest-away vertex

00:21:45.110 --> 00:21:46.370
and measure the distance.

00:21:46.370 --> 00:21:50.517
And that distance is the
radius of my graph, OK?

00:21:50.517 --> 00:21:51.600
So let's actually do that.

00:21:51.600 --> 00:21:56.710
So in particular, then I can
define a second vertex, v0.

00:21:56.710 --> 00:21:59.103
Well, how does the
radius algorithm work?

00:21:59.103 --> 00:22:00.520
I find the central
guy, and then I

00:22:00.520 --> 00:22:02.510
find the one that's
farthest away.

00:22:02.510 --> 00:22:05.110
So we're going to
make him the arg

00:22:05.110 --> 00:22:11.290
max over all v in my graph
of the distance starting

00:22:11.290 --> 00:22:14.800
at u to any v.

00:22:14.800 --> 00:22:17.380
So if I think about my circle--

00:22:17.380 --> 00:22:18.910
that's a circle.

00:22:18.910 --> 00:22:22.570
Then u0 is like that
center of my circle.

00:22:22.570 --> 00:22:27.505
And then v0 is like
that far-away point.

00:22:27.505 --> 00:22:28.630
This is a schematic, right?

00:22:28.630 --> 00:22:30.520
My circle is really a
graph in this problem.

00:22:30.520 --> 00:22:32.780
But I think the
analogy actually works.

00:22:32.780 --> 00:22:33.910
OK.

00:22:33.910 --> 00:22:36.070
But in reality, my
algorithm was braindead.

00:22:36.070 --> 00:22:38.090
I didn't actually compute u0.

00:22:38.090 --> 00:22:39.315
I just randomly drew--

00:22:39.315 --> 00:22:40.690
sorry, I shouldn't
use that word.

00:22:40.690 --> 00:22:44.650
I arbitrarily drew a
vertex, u, and then computed

00:22:44.650 --> 00:22:47.350
the farthest-away
distance from that guy.

00:22:47.350 --> 00:22:48.880
And of course, what
we have to check

00:22:48.880 --> 00:22:51.940
is that that thing is within a
factor of 2 of what I wanted.

00:22:51.940 --> 00:22:53.230
So OK.

00:22:53.230 --> 00:22:55.120
If I have u, then
I'm additionally

00:22:55.120 --> 00:22:58.780
going to define one more
thing called v. And that--

00:23:09.810 --> 00:23:10.950
oh boy.

00:23:10.950 --> 00:23:13.000
OK, so I'm noticing
I'm saying one thing,

00:23:13.000 --> 00:23:14.130
and I'm writing another.

00:23:14.130 --> 00:23:16.860
u0 is the center of my graph.

00:23:16.860 --> 00:23:17.610
I think I said it.

00:23:17.610 --> 00:23:18.750
I just forgot to write it.

00:23:18.750 --> 00:23:21.630
And then this v is the
farthest-away guy from him.

00:23:21.630 --> 00:23:24.300
So basically, the
subscript 0 here means--

00:23:24.300 --> 00:23:26.760
is the platonic ideal of
what I wanted in my problem.

00:23:26.760 --> 00:23:29.730
And no subscript is going
to mean the other one.

00:23:29.730 --> 00:23:33.757
So now I compute the
farthest-away thing from the u

00:23:33.757 --> 00:23:35.340
that I actually chose
in my algorithm.

00:23:35.340 --> 00:23:36.990
That's some v bar.

00:23:36.990 --> 00:23:39.570
So again, remember, my
algorithm just says, OK,

00:23:39.570 --> 00:23:42.420
I'm going to choose
some other point, v,

00:23:42.420 --> 00:23:47.590
and then return v's distance
to some farthest-away point--

00:23:47.590 --> 00:23:49.140
oh, sorry, choose another--

00:23:49.140 --> 00:23:50.000
oh boy.

00:23:50.000 --> 00:23:53.090
Choose a point, u, and
return his distance

00:23:53.090 --> 00:23:55.130
to some far-away
point, v. I think

00:23:55.130 --> 00:23:57.920
I've managed to lose
everybody, knotting together

00:23:57.920 --> 00:23:59.580
u's and v's here.

00:23:59.580 --> 00:24:01.838
OK, so why'd I introduce
all of this notation?

00:24:01.838 --> 00:24:04.130
Because this is what's going
on in this problem, right?

00:24:04.130 --> 00:24:05.570
To actually compute
the radius, I

00:24:05.570 --> 00:24:08.270
want to find the most central
point, u0, and its distance

00:24:08.270 --> 00:24:10.250
its farthest-away thing, v0.

00:24:10.250 --> 00:24:13.340
In reality, I arbitrarily
chose the point u.

00:24:13.340 --> 00:24:16.122
And I returned u's
distance to some point,

00:24:16.122 --> 00:24:18.080
v. And I want to show
that those two things are

00:24:18.080 --> 00:24:19.940
within a factor of
2 of each other.

00:24:19.940 --> 00:24:21.530
OK, that summary
makes sense even,

00:24:21.530 --> 00:24:23.470
if I talked in circles
for a little while.

00:24:23.470 --> 00:24:25.890
OK, so let's actually do that.

00:24:25.890 --> 00:24:29.480
So remember that the thing that
I'm going to actually return

00:24:29.480 --> 00:24:30.500
is R star.

00:24:30.500 --> 00:24:35.210
And that is equal to the
distance from u to v now,

00:24:35.210 --> 00:24:37.790
because I just made
all these definitions.

00:24:37.790 --> 00:24:43.637
And now I get to use
my favorite inequality.

00:24:43.637 --> 00:24:45.470
In fact, this is sort
of the only inequality

00:24:45.470 --> 00:24:47.470
we know in this class
so far, I think,

00:24:47.470 --> 00:24:49.840
which is the triangle
inequality, which

00:24:49.840 --> 00:24:52.750
says that, of
course, this is less

00:24:52.750 --> 00:24:56.260
than or equal to
the distance from u

00:24:56.260 --> 00:25:02.193
to u0 plus the
distance from u0 to v.

00:25:02.193 --> 00:25:03.610
So in other words,
this is saying,

00:25:03.610 --> 00:25:06.235
the shortest path
from u to v is always

00:25:06.235 --> 00:25:08.110
upper bounded from the
length of the shortest

00:25:08.110 --> 00:25:11.330
path from u to u0 and
then u0 to v, right?

00:25:11.330 --> 00:25:13.560
This is drawing a triangle.

00:25:13.560 --> 00:25:15.210
Aha!

00:25:15.210 --> 00:25:16.200
But take a look.

00:25:16.200 --> 00:25:20.410
What is the actual
radius of my graph?

00:25:20.410 --> 00:25:23.280
Well, in my notation,
the radius of my graph

00:25:23.280 --> 00:25:30.250
is exactly the
distance from u0 to v0.

00:25:30.250 --> 00:25:35.050
And this thing is bigger
than the distance from u0

00:25:35.050 --> 00:25:43.430
to anything else, by
definition, for all v, right?

00:25:43.430 --> 00:25:47.240
So if I flip this inequality
backward, well, take a look.

00:25:47.240 --> 00:25:49.250
This is the distance
from u0 to something.

00:25:49.250 --> 00:25:51.230
This is the distance
from u0 to something.

00:25:51.230 --> 00:25:52.955
So I incur two
factors of the radius.

00:25:56.270 --> 00:25:58.910
And I get the bound
that I wanted, yeah?

00:25:58.910 --> 00:26:01.340
And so this is a slightly
more formal little proof

00:26:01.340 --> 00:26:04.208
of exactly the same thing
that's in the homework notes.

00:26:04.208 --> 00:26:05.750
OK, so the one thing
that's remaining

00:26:05.750 --> 00:26:08.248
is to actually show
that our algorithm runs

00:26:08.248 --> 00:26:09.540
in a reasonable amount of time.

00:26:09.540 --> 00:26:13.970
So I think they give us
a budget of order E time.

00:26:13.970 --> 00:26:16.490
But notice, that argument
is precisely the argument

00:26:16.490 --> 00:26:20.690
that we just made right here,
just minus the v factor.

00:26:20.690 --> 00:26:22.970
And the v factor just
came from looping over

00:26:22.970 --> 00:26:25.740
all the vertices in part a.

00:26:25.740 --> 00:26:29.120
So now I think we're
done with problem 1.

00:26:29.120 --> 00:26:31.820
As usual, I've wasted too
much time on the easy problem.

00:26:31.820 --> 00:26:34.890
All right, any questions
about this one?

00:26:34.890 --> 00:26:35.390
Excellent.

00:26:35.390 --> 00:26:39.582
Well, now that I've written too
much, let's do the rest of it.

00:26:39.582 --> 00:26:41.540
I spent time on this
problem because I like it.

00:26:41.540 --> 00:26:43.170
It looks like a
geometry problem.

00:26:43.170 --> 00:26:43.670
OK.

00:26:46.290 --> 00:26:47.830
So now, let's see.

00:26:47.830 --> 00:26:50.700
In problem 2, which I
noticed that this homework is

00:26:50.700 --> 00:26:56.010
kind of full of
prototypical 6.006

00:26:56.010 --> 00:26:57.813
slash graph theory
problems in general.

00:26:57.813 --> 00:27:00.480
Like, they just go down the list
of things that people typically

00:27:00.480 --> 00:27:04.470
do in graph theory that
are useful tricks to know.

00:27:04.470 --> 00:27:07.450
So I would suggest to the
students in this class,

00:27:07.450 --> 00:27:10.230
even if it's pass-fail, look
very closely at this homework

00:27:10.230 --> 00:27:12.390
before doing the current one.

00:27:12.390 --> 00:27:16.740
I think the ordering works
out that they can do that,

00:27:16.740 --> 00:27:19.860
because I think you'll get some
good hints for how to solve

00:27:19.860 --> 00:27:22.320
all the current homework.

00:27:22.320 --> 00:27:25.330
So you heard it
here first, guys.

00:27:25.330 --> 00:27:25.830
OK.

00:27:25.830 --> 00:27:31.680
So in problem 2, we're talking
about internet investigation.

00:27:31.680 --> 00:27:36.570
So in particular, at MIT has
a bunch of different routers

00:27:36.570 --> 00:27:39.730
that are connected by
cables to one another.

00:27:39.730 --> 00:27:42.120
And essentially,
what are we given?

00:27:42.120 --> 00:27:44.040
We're given a bunch
of different routers.

00:27:44.040 --> 00:27:46.860
And we're given the length
of the cable in between them.

00:27:46.860 --> 00:27:48.570
And the latency,
unsurprisingly, is

00:27:48.570 --> 00:27:50.237
proportional to the
length of the cable.

00:27:50.237 --> 00:27:52.260
That, in my abstract
understanding

00:27:52.260 --> 00:27:54.460
of how computers work,
kind of makes sense to me.

00:27:54.460 --> 00:27:55.877
I'm not sure that's
actually true.

00:27:55.877 --> 00:28:01.050
But that's sort of
immaterial for 6.006.

00:28:01.050 --> 00:28:02.940
I assume our department
has a networks

00:28:02.940 --> 00:28:06.360
class if you're interested
in that kind of thing.

00:28:06.360 --> 00:28:08.220
And essentially, what
we're trying to do

00:28:08.220 --> 00:28:11.910
is sum up the latency
over all of the routers.

00:28:11.910 --> 00:28:14.190
So let's break down a
little bit of notation

00:28:14.190 --> 00:28:18.246
here while I continue to
dance all over the room here.

00:28:18.246 --> 00:28:20.400
I keep losing my chalk.

00:28:27.050 --> 00:28:28.610
I need like a holster.

00:28:28.610 --> 00:28:31.700
I feel like that would be
useful for the chalk bucket.

00:28:31.700 --> 00:28:33.290
OK.

00:28:33.290 --> 00:28:37.080
So now we're going
to do problem 2 here.

00:28:37.080 --> 00:28:38.540
So we're given r routers.

00:28:42.460 --> 00:28:48.360
And some of them are
marked as entry points.

00:28:53.730 --> 00:29:06.840
And now we have a bunch of
bidirectional wires, wi,

00:29:06.840 --> 00:29:12.350
each of which has length li.

00:29:12.350 --> 00:29:17.360
And that's a positive
integer value here.

00:29:17.360 --> 00:29:18.938
And actually, because of this--

00:29:18.938 --> 00:29:21.230
so technically, I think a
lot of students in this class

00:29:21.230 --> 00:29:22.897
have encountered
weighted graphs before.

00:29:22.897 --> 00:29:25.640
But if you think about the
narrative of this course,

00:29:25.640 --> 00:29:27.590
I think, for the version
of this homework,

00:29:27.590 --> 00:29:29.750
we haven't really encountered
weighted graphs yet.

00:29:29.750 --> 00:29:32.208
But a better way of putting
it, rather than psychologically

00:29:32.208 --> 00:29:35.603
diagnosing your instructors, is
that what we're going to find

00:29:35.603 --> 00:29:38.270
is that there are often problems
that look like they're weighted

00:29:38.270 --> 00:29:39.895
graph problems, but
they really aren't.

00:29:39.895 --> 00:29:43.490
And this is a nice example
where that's the case.

00:29:43.490 --> 00:29:48.770
OK, so we define
latency as follows,

00:29:48.770 --> 00:29:52.400
that it's at least
proportional to the shortest

00:29:52.400 --> 00:29:53.560
path to an entry point.

00:30:01.740 --> 00:30:04.690
And now we have two additional
assumptions that we need,

00:30:04.690 --> 00:30:05.190
right?

00:30:05.190 --> 00:30:09.690
One is that the total latency,
or at least the latency

00:30:09.690 --> 00:30:15.470
of every vertex, which is
the same thing-- latency--

00:30:15.470 --> 00:30:17.570
is less than infinity.

00:30:17.570 --> 00:30:20.090
What is this really
saying, by the way?

00:30:20.090 --> 00:30:21.860
Like, when would the
latency be infinity?

00:30:21.860 --> 00:30:23.630
It would only be infinity if I
like took a pair of scissors,

00:30:23.630 --> 00:30:25.550
and cut a wire,
and just connected

00:30:25.550 --> 00:30:27.440
for the rest of the network.

00:30:27.440 --> 00:30:28.460
Yes?

00:30:28.460 --> 00:30:31.002
AUDIENCE: Every router is
connected to some entry point.

00:30:31.002 --> 00:30:32.210
JUSTIN SOLOMON: Yes, exactly.

00:30:32.210 --> 00:30:34.820
Like, there's some path from
every router to some entry

00:30:34.820 --> 00:30:35.360
point.

00:30:35.360 --> 00:30:37.652
Doesn't necessarily mean the
entire graph is connected,

00:30:37.652 --> 00:30:38.430
I guess.

00:30:38.430 --> 00:30:41.900
But at least you can always
get to an entry point.

00:30:41.900 --> 00:30:44.240
And then, moreover,
and this one's

00:30:44.240 --> 00:30:46.940
the real kicker
here, that there's

00:30:46.940 --> 00:30:51.650
at most 100r feet of wire.

00:30:55.920 --> 00:30:57.780
Incidentally, r
stands for routers.

00:30:57.780 --> 00:30:59.960
I had the previous
problem in my head

00:30:59.960 --> 00:31:02.110
and was thinking
radius a long time.

00:31:02.110 --> 00:31:03.785
So don't be like
your instructor.

00:31:03.785 --> 00:31:05.910
And actually read the entire
problem before getting

00:31:05.910 --> 00:31:07.330
hung up on it.

00:31:07.330 --> 00:31:11.190
But in any event, the thing
that you're trying to do

00:31:11.190 --> 00:31:20.550
is to compute the sum
over all of the routers--

00:31:20.550 --> 00:31:25.990
I don't know, r, whatever--
of the latency of that router.

00:31:25.990 --> 00:31:27.595
OK, so that's our problem here.

00:31:27.595 --> 00:31:29.910
Incidentally, this
little goofy exercise

00:31:29.910 --> 00:31:31.707
I just did of taking
this paragraph problem

00:31:31.707 --> 00:31:34.290
and kind of writing it in bullet
points, I find helps me a lot

00:31:34.290 --> 00:31:36.330
when I'm trying to solve
these algorithms problems,

00:31:36.330 --> 00:31:38.830
because I think it's really
easy to just get like thrown off

00:31:38.830 --> 00:31:41.200
by a wall of text here.

00:31:41.200 --> 00:31:44.940
OK, so this problem is
screaming out graph theory.

00:31:44.940 --> 00:31:47.040
Like, we're practically
using the terms here.

00:31:47.040 --> 00:31:48.300
We are using the terms, right?

00:31:48.300 --> 00:31:51.660
Like, we've got nodes that
are kind of like routers.

00:31:51.660 --> 00:31:54.840
And maybe edges are
kind of like wires.

00:31:54.840 --> 00:31:58.410
But there's a bit of a catch,
which is that your runtime--

00:31:58.410 --> 00:32:04.650
at the end of the day, I think
you want order r runtime.

00:32:04.650 --> 00:32:07.620
That's where things get
a little funky initially.

00:32:07.620 --> 00:32:09.120
And so we have to
think a little bit

00:32:09.120 --> 00:32:11.100
carefully about how to do it.

00:32:11.100 --> 00:32:13.345
And here's going
to be the trick.

00:32:13.345 --> 00:32:15.720
So this is starting to look
like a shortest path problem.

00:32:15.720 --> 00:32:18.480
But what would you
maybe not want to do?

00:32:18.480 --> 00:32:20.820
Would be to iterate over
every single router,

00:32:20.820 --> 00:32:23.610
or every single vertex
and every single router,

00:32:23.610 --> 00:32:26.610
and compute the shortest path
between every single pair,

00:32:26.610 --> 00:32:28.500
because if you did
that-- oh boy, I'm

00:32:28.500 --> 00:32:30.120
confusing my terminology.

00:32:30.120 --> 00:32:32.400
There are entry points, which
is the thing that I need

00:32:32.400 --> 00:32:34.410
to compute the distance to.

00:32:34.410 --> 00:32:36.535
And I need to iterate
over every single router

00:32:36.535 --> 00:32:38.910
and compute its distance,
maybe, to all the entry points,

00:32:38.910 --> 00:32:41.140
and then take the min,
or something like that.

00:32:41.140 --> 00:32:42.990
But if I had a double
for loop, then I'm

00:32:42.990 --> 00:32:45.237
probably not going to
get order r time, right?

00:32:45.237 --> 00:32:47.820
Because somehow, you expect it
to look like something squared,

00:32:47.820 --> 00:32:49.310
or like the product
of two terms.

00:32:49.310 --> 00:32:51.310
So we have to be a little
more sneaky than that.

00:32:51.310 --> 00:32:54.810
And we're going to use sort
of a canonical trick in graph

00:32:54.810 --> 00:32:56.050
theory.

00:32:56.050 --> 00:33:00.050
OK, so let's follow the
Toucan Sam approach here.

00:33:00.050 --> 00:33:03.160
We're going to follow our
nose and say that, OK, there's

00:33:03.160 --> 00:33:06.768
basically a graph that's staring
us in the face in this problem.

00:33:06.768 --> 00:33:09.310
But then we're going to have to
make a little bit of an edit,

00:33:09.310 --> 00:33:13.180
because we'd like to use the
kind of linear-looking time

00:33:13.180 --> 00:33:16.240
search that BFS affords us.

00:33:16.240 --> 00:33:18.620
But it looks like we have
edge weights in our graph,

00:33:18.620 --> 00:33:22.510
because the wires are
associated to lengths, right?

00:33:22.510 --> 00:33:24.490
Different wires have
different sizes.

00:33:24.490 --> 00:33:26.680
But we have this
nice fun fact, which

00:33:26.680 --> 00:33:29.170
is that the total amount of
wire in our whole universe

00:33:29.170 --> 00:33:31.758
is less than 100r.

00:33:31.758 --> 00:33:34.050
I guess the units of this
100 are kind of weird, right?

00:33:34.050 --> 00:33:38.220
It's like feet per router
or something, but whatever.

00:33:38.220 --> 00:33:46.190
OK, so in particular,
I'm going to make a graph

00:33:46.190 --> 00:33:51.200
with the node per router.

00:33:51.200 --> 00:33:53.090
So like, maybe here's a router.

00:33:53.090 --> 00:33:54.620
There's another router.

00:33:54.620 --> 00:33:58.200
There's router 1 and router 2.

00:33:58.200 --> 00:34:00.450
But since I want to use
the sort of linear time

00:34:00.450 --> 00:34:02.940
advantages of
breadth-first search

00:34:02.940 --> 00:34:06.390
when I'm computing distances,
I can be a little bit sneaky

00:34:06.390 --> 00:34:08.429
about this, which
is to say, instead

00:34:08.429 --> 00:34:10.980
of having like 10 feet
of wires, I'm going

00:34:10.980 --> 00:34:14.370
to have 10 1-foot wires, yeah?

00:34:14.370 --> 00:34:19.250
Except now I'm additionally
going to have little chains.

00:34:19.250 --> 00:34:24.889
So here, maybe the length l
1, 2 is equal to 3, right?

00:34:24.889 --> 00:34:29.060
So I'm going to put
three edges in between.

00:34:29.060 --> 00:34:30.040
So in other words--

00:34:30.040 --> 00:34:38.219
and I'm going to
connect them with chains

00:34:38.219 --> 00:34:45.510
of li edges for each wire.

00:34:49.155 --> 00:34:50.030
Does that make sense?

00:34:50.030 --> 00:34:52.548
So essentially, I'm going to
take my weighted graph problem

00:34:52.548 --> 00:34:55.090
and make it unweighted by just
like repeating a bunch-- well,

00:34:55.090 --> 00:34:56.882
not really repeating,
but chaining together

00:34:56.882 --> 00:35:00.880
a bunch of edges so that the
total length of this thing

00:35:00.880 --> 00:35:04.120
is equal to the distance
from one router to another.

00:35:04.120 --> 00:35:05.890
OK.

00:35:05.890 --> 00:35:07.600
One thing we might
as well do is bound

00:35:07.600 --> 00:35:10.940
the number of vertices and edges
in our graph when we do that.

00:35:10.940 --> 00:35:18.180
So first of all, let's think
about the number of vertices.

00:35:18.180 --> 00:35:20.550
And we can be totally lazy
and upper bound this stuff.

00:35:20.550 --> 00:35:21.570
It doesn't matter.

00:35:21.570 --> 00:35:24.210
Well, for one thing, I
have one node per router.

00:35:24.210 --> 00:35:28.280
So we incur one
factor of r there.

00:35:28.280 --> 00:35:31.220
And now, notice that we're
kind of laying down cable

00:35:31.220 --> 00:35:35.120
one little piece at a
time here in our chains.

00:35:35.120 --> 00:35:39.050
And now I always tend to have
a fencepost-style headache

00:35:39.050 --> 00:35:41.090
about exactly what the
constant factor is here.

00:35:41.090 --> 00:35:43.880
But if we're
conservative about it,

00:35:43.880 --> 00:35:48.010
we incur at most a factor of
100r kind of additional edges,

00:35:48.010 --> 00:35:49.760
because those are all
the different pieces

00:35:49.760 --> 00:35:50.660
that we could lay together.

00:35:50.660 --> 00:35:53.243
I think it's actually less than
that because of the endpoints,

00:35:53.243 --> 00:35:58.280
but whatever, because r
plus 100 r is big O of r.

00:35:58.280 --> 00:36:02.202
So the number of vertices in
my graph here is big O of r.

00:36:02.202 --> 00:36:03.785
Similarly, what's
the number of edges?

00:36:07.590 --> 00:36:10.950
Well, this is exactly the
amount of cable that's inside

00:36:10.950 --> 00:36:12.800
of my network, I believe.

00:36:12.800 --> 00:36:13.840
Yep.

00:36:13.840 --> 00:36:15.090
So this is exactly 100r.

00:36:17.600 --> 00:36:19.490
Well, I guess the way
the problem is written,

00:36:19.490 --> 00:36:23.690
it's upper bounded by
100r, but whatever.

00:36:23.690 --> 00:36:27.065
So this, again, is big O of r.

00:36:27.065 --> 00:36:28.190
This is kind of convenient.

00:36:28.190 --> 00:36:29.898
So now we have one
number that rules them

00:36:29.898 --> 00:36:32.730
all, which is r, which tells
you both the number of vertices

00:36:32.730 --> 00:36:35.420
and the number of edges, up
to a constant factor, right?

00:36:35.420 --> 00:36:37.340
So one thing I can
convince myself

00:36:37.340 --> 00:36:39.920
is if I do BFS on my
graph, that's sort of OK.

00:36:39.920 --> 00:36:43.020
Remember, that's
vertices plus edges time.

00:36:43.020 --> 00:36:45.560
But in this case,
those are the same.

00:36:45.560 --> 00:36:48.702
OK, so right.

00:36:48.702 --> 00:36:50.160
So remember, at
the end of the day,

00:36:50.160 --> 00:36:51.660
I'm trying to
compute the latency.

00:36:51.660 --> 00:36:56.240
This is like the length of
the shortest path to the entry

00:36:56.240 --> 00:36:58.460
point nodes.

00:36:58.460 --> 00:37:00.440
So here would be a
braindead algorithm,

00:37:00.440 --> 00:37:12.990
which is to say, for all
routers, for all entry points,

00:37:12.990 --> 00:37:13.490
compute--

00:37:16.438 --> 00:37:16.980
I don't know.

00:37:16.980 --> 00:37:20.770
Let's call the router
on i, the entry point j.

00:37:20.770 --> 00:37:23.760
I compute distance ij like
using breadth-first search

00:37:23.760 --> 00:37:25.330
or something.

00:37:25.330 --> 00:37:32.850
And then I take the
min of these values

00:37:32.850 --> 00:37:35.660
and add them all
together, right?

00:37:35.660 --> 00:37:38.890
So I compute-- for every router,
I look at every possible entry

00:37:38.890 --> 00:37:39.390
point.

00:37:39.390 --> 00:37:41.190
I compute its distance
to the entry point.

00:37:41.190 --> 00:37:42.990
I take the min over
all these things.

00:37:42.990 --> 00:37:46.655
And now I add that
to my running sum.

00:37:46.655 --> 00:37:48.030
There's a problem
here, which is,

00:37:48.030 --> 00:37:50.520
I haven't told you the
relative number of entry points

00:37:50.520 --> 00:37:52.610
to the total number of routers.

00:37:52.610 --> 00:37:56.250
So at least the way that I've
written this algorithm here,

00:37:56.250 --> 00:37:58.290
how much time would this take?

00:37:58.290 --> 00:38:00.360
Well, there's two
different for loops.

00:38:00.360 --> 00:38:02.453
And in the worst
possible case, at least

00:38:02.453 --> 00:38:03.870
in my braindead
algorithm, I don't

00:38:03.870 --> 00:38:07.150
notice that if I
am an entry point,

00:38:07.150 --> 00:38:10.570
then I don't need to
compute distances.

00:38:10.570 --> 00:38:14.140
Well, this would take
order r squared--

00:38:14.140 --> 00:38:17.890
whoa, r squared time, right?

00:38:17.890 --> 00:38:18.880
At least, right?

00:38:18.880 --> 00:38:21.880
Actually, I shouldn't even
write big O. I should write--

00:38:21.880 --> 00:38:22.840
what's lower bound?

00:38:22.840 --> 00:38:24.760
Oh god, I'm a terrible
algorithms professor.

00:38:24.760 --> 00:38:28.573
Omega of r squared time,
because I haven't even

00:38:28.573 --> 00:38:30.490
accounted for the amount
of time that it takes

00:38:30.490 --> 00:38:33.412
to compute the distance, right?

00:38:33.412 --> 00:38:34.870
And this is a
problem, because I've

00:38:34.870 --> 00:38:37.030
only given you a budget of
linear time for your algorithm,

00:38:37.030 --> 00:38:37.690
right?

00:38:37.690 --> 00:38:40.120
So this is frowny face.

00:38:40.120 --> 00:38:42.070
I tried drawing the
turd emoji on my notes.

00:38:42.070 --> 00:38:43.750
And it really-- it didn't work.

00:38:43.750 --> 00:38:47.440
OK, so we need a better trick.

00:38:47.440 --> 00:38:51.700
And this is actually one of
these prototypical tricks,

00:38:51.700 --> 00:38:53.750
which is to do the following.

00:38:53.750 --> 00:38:54.920
So let's construct a graph.

00:38:54.920 --> 00:38:57.610
I'm going to draw my
graph in a particular way.

00:38:57.610 --> 00:38:59.843
But notice that there's
nothing about my algorithm

00:38:59.843 --> 00:39:01.510
that cares about the
way that I drew it.

00:39:01.510 --> 00:39:03.143
This is just to
make my life easier,

00:39:03.143 --> 00:39:04.810
which is, I'm going
to put all the entry

00:39:04.810 --> 00:39:08.050
points on the left
and all the remaining

00:39:08.050 --> 00:39:11.433
non-entry-point routers on
the right, because I can.

00:39:11.433 --> 00:39:13.100
And so this is what
my graph looks like.

00:39:13.100 --> 00:39:14.517
So these are like
my entry points.

00:39:16.952 --> 00:39:18.035
Here are my other routers.

00:39:21.206 --> 00:39:23.402
My graph doesn't
have to be bipartite.

00:39:23.402 --> 00:39:25.360
Like, it could be that
my routers are connected

00:39:25.360 --> 00:39:27.670
to each other, whatever.

00:39:27.670 --> 00:39:31.120
And then there are some edges
that go from my entry points

00:39:31.120 --> 00:39:33.070
to the routers in the graph.

00:39:33.070 --> 00:39:35.620
I'm trying to make sure
that my graph is connected.

00:39:35.620 --> 00:39:36.680
OK.

00:39:36.680 --> 00:39:39.490
And so essentially, what this
problem is asking you to do

00:39:39.490 --> 00:39:42.160
is to say, OK, for every
single node in my graph,

00:39:42.160 --> 00:39:46.870
I need to compute the distance
to the closest entry point

00:39:46.870 --> 00:39:48.910
and then sum all those
things together, right?

00:39:48.910 --> 00:39:52.980
That's just the schematic
we could have in mind.

00:39:52.980 --> 00:39:57.160
So in some sense,
what we want to do

00:39:57.160 --> 00:39:58.870
is think about the
set of entry points

00:39:58.870 --> 00:40:02.200
as like one giant node,
because it doesn't matter

00:40:02.200 --> 00:40:06.540
which of these guys I choose
for my shortest path to an entry

00:40:06.540 --> 00:40:07.040
point.

00:40:07.040 --> 00:40:08.890
I just need to find one, yeah?

00:40:08.890 --> 00:40:10.205
And so here's the basic trick.

00:40:10.205 --> 00:40:12.580
And this is one that appears
all over graph theory, which

00:40:12.580 --> 00:40:15.260
is I'm going to introduce one
additional node to my graph.

00:40:15.260 --> 00:40:18.140
And I'm going to put him
on the left-hand side.

00:40:18.140 --> 00:40:23.540
He's really big, because
he is a supernode, which

00:40:23.540 --> 00:40:25.370
is a term of art.

00:40:25.370 --> 00:40:26.570
This term shows up a lot.

00:40:26.570 --> 00:40:31.860
And I'm going to connect
it to every entry

00:40:31.860 --> 00:40:35.961
point in my network of routers.

00:40:35.961 --> 00:40:38.670
Does that makes sense, class?

00:40:38.670 --> 00:40:39.930
OK.

00:40:39.930 --> 00:40:42.760
So here's the kind
of cool thing.

00:40:42.760 --> 00:40:44.790
So first of all, for
every entry point,

00:40:44.790 --> 00:40:46.770
what's the shortest
path from the entry

00:40:46.770 --> 00:40:48.328
point to the supernode?

00:40:48.328 --> 00:40:49.995
Well, obviously, it
has length 1, right?

00:40:49.995 --> 00:40:52.240
I drew it for you here.

00:40:52.240 --> 00:40:53.680
Now, here's the thing.

00:40:53.680 --> 00:40:56.100
Let's take the shortest
path from the supernode

00:40:56.100 --> 00:40:59.690
to any of the routers
on the right-hand side.

00:40:59.690 --> 00:41:00.530
What do I know?

00:41:00.530 --> 00:41:04.378
Well, clearly-- like maybe
I choose this guy here.

00:41:04.378 --> 00:41:05.670
Well, what is my shortest path?

00:41:05.670 --> 00:41:08.760
It goes here and then there.

00:41:08.760 --> 00:41:10.140
There's one property
that matters

00:41:10.140 --> 00:41:14.550
here, which is that it has to
pass through one of these entry

00:41:14.550 --> 00:41:16.420
nodes.

00:41:16.420 --> 00:41:19.370
Which one does it
have to pass through?

00:41:19.370 --> 00:41:21.020
Shrug.

00:41:21.020 --> 00:41:21.890
For shame.

00:41:21.890 --> 00:41:24.710
Well, remember, Justin's
favorite inequality

00:41:24.710 --> 00:41:26.385
is the triangle inequality.

00:41:26.385 --> 00:41:27.260
And what does it say?

00:41:27.260 --> 00:41:29.060
It says that if I
compute the shortest

00:41:29.060 --> 00:41:33.560
path from the supernode
to any node in my graph,

00:41:33.560 --> 00:41:36.920
then every sort of sub-piece
of that shortest path

00:41:36.920 --> 00:41:38.750
is also a shortest path.

00:41:38.750 --> 00:41:40.190
That sentence was hard to parse.

00:41:40.190 --> 00:41:41.400
Let's try that again.

00:41:41.400 --> 00:41:43.400
So in particular,
if I have a graph

00:41:43.400 --> 00:41:45.793
from the supernode to
some router over here,

00:41:45.793 --> 00:41:47.210
well, we've convinced
ourselves it

00:41:47.210 --> 00:41:50.112
has to pass through
one of the entry nodes.

00:41:50.112 --> 00:41:51.820
Which one does that
have to pass through?

00:41:51.820 --> 00:41:55.450
Is it ever something that is
farther than the closest entry

00:41:55.450 --> 00:41:57.230
node?

00:41:57.230 --> 00:41:59.210
Well, no, because I
could compute a shorter

00:41:59.210 --> 00:42:01.940
path in that case by
choosing the closest entry

00:42:01.940 --> 00:42:04.740
node and then going
to the supernode.

00:42:04.740 --> 00:42:07.850
So this is a complicated way
of saying that essentially,

00:42:07.850 --> 00:42:18.910
what we really want is for
every router, the distance

00:42:18.910 --> 00:42:26.310
from that router, let's call
it i, to the supernode, s.

00:42:26.310 --> 00:42:27.210
Is that quite right?

00:42:27.210 --> 00:42:31.132
Is that the distance to
the closest entry point?

00:42:31.132 --> 00:42:32.840
AUDIENCE: You went
one more inch too far.

00:42:32.840 --> 00:42:34.210
JUSTIN SOLOMON: I went
one inch too far, right?

00:42:34.210 --> 00:42:36.210
Because I went to the
closest entry point.

00:42:36.210 --> 00:42:37.668
And then I took an
additional edge.

00:42:37.668 --> 00:42:40.500
So we want to do minus 1.

00:42:40.500 --> 00:42:41.730
OK.

00:42:41.730 --> 00:42:43.117
So what does this mean?

00:42:43.117 --> 00:42:44.700
Well, that means
that I don't actually

00:42:44.700 --> 00:42:48.180
have to have this inner for
loop over all the possible entry

00:42:48.180 --> 00:42:49.090
points.

00:42:49.090 --> 00:42:51.690
I just need to construct this
new special graph with one

00:42:51.690 --> 00:42:53.815
additional node-- notice
that's not going to affect

00:42:53.815 --> 00:42:54.690
my runtime--

00:42:54.690 --> 00:42:56.940
and compute the shortest
distance from the supernode

00:42:56.940 --> 00:43:00.190
to every other node
in my graph, and then

00:43:00.190 --> 00:43:02.080
use that as my output, yeah?

00:43:02.080 --> 00:43:07.810
So in other words, what is my
algorithm going to look like?

00:43:07.810 --> 00:43:13.560
Well, first, I'm going to
construct my graph, right?

00:43:13.560 --> 00:43:15.188
So what do I need to do?

00:43:15.188 --> 00:43:16.980
If I were to write this
out in my homework,

00:43:16.980 --> 00:43:18.570
I would have to
talk about how I've

00:43:18.570 --> 00:43:20.790
got these chains of edges
between different pairs

00:43:20.790 --> 00:43:21.570
of routers.

00:43:21.570 --> 00:43:23.153
In addition to that,
I'm going to make

00:43:23.153 --> 00:43:26.130
one additional supernode
and insert an edge

00:43:26.130 --> 00:43:29.250
from that to every entry point.

00:43:29.250 --> 00:43:33.750
Notice that adding the entry
point here just adds a 1

00:43:33.750 --> 00:43:36.780
to the number of
vertices, and at most, I

00:43:36.780 --> 00:43:38.620
guess, an r to the
number of edges,

00:43:38.620 --> 00:43:40.740
which doesn't affect
asymptotically

00:43:40.740 --> 00:43:42.480
the size of either
of these two sets.

00:43:42.480 --> 00:43:44.430
So that's a good thing.

00:43:44.430 --> 00:43:47.820
Now I'm going to do--

00:43:47.820 --> 00:43:56.620
I'm going to use BFS to do a
single-source shortest path

00:43:56.620 --> 00:44:02.260
from my supernode to
all other vertices.

00:44:06.070 --> 00:44:08.510
And how much time
does this take?

00:44:08.510 --> 00:44:11.450
Well, remember that in general,
BFS takes v plus E time.

00:44:11.450 --> 00:44:14.450
In this case, v
plus E are both--

00:44:14.450 --> 00:44:15.470
look like r.

00:44:15.470 --> 00:44:18.440
So this is order r time.

00:44:18.440 --> 00:44:19.760
OK.

00:44:19.760 --> 00:44:31.010
And then finally, I'm
going to sum over routers

00:44:31.010 --> 00:44:37.790
i the value of the distance from
the supernode to the router i,

00:44:37.790 --> 00:44:41.070
minus 1 to account for that
additional edge that I added.

00:44:41.070 --> 00:44:44.390
OK, and that's the
solution to our problem.

00:44:44.390 --> 00:44:48.410
OK, any questions
about number 2 here?

00:44:48.410 --> 00:44:49.190
Excellent.

00:44:49.190 --> 00:44:50.220
Go team.

00:44:50.220 --> 00:44:50.720
OK.

00:44:50.720 --> 00:44:53.420
So now let's move
on to problem 3.

00:44:53.420 --> 00:44:55.910
Am I-- yeah, we're
about halfway.

00:44:55.910 --> 00:44:59.240
OK, so in problem 3--

00:44:59.240 --> 00:44:59.740
right.

00:44:59.740 --> 00:45:06.715
So we're doing Potry Harter
and three wizard friends.

00:45:06.715 --> 00:45:08.090
The number three
here, I believe,

00:45:08.090 --> 00:45:10.845
is actually irrelevant,
although like any time

00:45:10.845 --> 00:45:12.470
you see a specific
number in a problem,

00:45:12.470 --> 00:45:15.560
you should cache that in your
bag of things to remember.

00:45:15.560 --> 00:45:18.890
And in this case, that
was a red herring.

00:45:18.890 --> 00:45:24.200
Potry Harter and her
three wizard friends

00:45:24.200 --> 00:45:27.890
are tasked with searching
around a labyrinth, yeah?

00:45:27.890 --> 00:45:30.620
And in particular,
there's some nice things

00:45:30.620 --> 00:45:35.390
to know about the labyrinth
and Potry Harter world--

00:45:35.390 --> 00:45:39.150
this is really throwing
off my dyslexia here--

00:45:39.150 --> 00:45:40.130
which is the following.

00:45:43.140 --> 00:45:45.820
Right, so what do we know?

00:45:45.820 --> 00:45:54.880
We know that there are
n rooms in my labyrinth

00:45:54.880 --> 00:46:02.110
and that each of my rooms
has at most four doors.

00:46:05.810 --> 00:46:09.080
So in other words, if I
think of building a graph out

00:46:09.080 --> 00:46:10.940
of my rooms, which is
like, I don't think

00:46:10.940 --> 00:46:12.890
I'm giving much away
about this problem

00:46:12.890 --> 00:46:15.560
by jumping to the
solution a little bit,

00:46:15.560 --> 00:46:17.870
what do we know about
the degree of any vertex,

00:46:17.870 --> 00:46:21.620
assuming my vertices are
rooms in the labyrinth?

00:46:21.620 --> 00:46:22.460
It's at most four.

00:46:22.460 --> 00:46:24.260
So that's kind of nice.

00:46:24.260 --> 00:46:26.630
OK, right.

00:46:26.630 --> 00:46:28.160
And all the doors start closed.

00:46:31.110 --> 00:46:33.750
So that seems like a
useful piece of information

00:46:33.750 --> 00:46:35.580
to remember.

00:46:35.580 --> 00:46:37.980
But we have this kind
of weird thing, which is

00:46:37.980 --> 00:46:44.454
that some doors are enchanted.

00:46:47.120 --> 00:46:54.320
And apparently, Potry
Harter can open up

00:46:54.320 --> 00:46:57.030
certain doors for free, which
are not the intended doors.

00:46:57.030 --> 00:46:59.180
And then other ones,
they have to do

00:46:59.180 --> 00:47:00.860
the blessing, and
the holy water,

00:47:00.860 --> 00:47:04.460
and whatever it is that
happens in this universe,

00:47:04.460 --> 00:47:06.200
and then opens up that door.

00:47:06.200 --> 00:47:09.500
But that costs them materials
and heartache, right?

00:47:09.500 --> 00:47:12.110
And so we want to minimize that.

00:47:12.110 --> 00:47:17.580
And so what they're
given is basically a map.

00:47:17.580 --> 00:47:19.580
And this includes all
of the different rooms,

00:47:19.580 --> 00:47:22.080
how they're connected to one
another, and which of the doors

00:47:22.080 --> 00:47:23.790
are enchanted.

00:47:23.790 --> 00:47:31.740
And what I want is the
minimum number of doors

00:47:31.740 --> 00:47:35.040
that they have to disenchant.

00:47:39.630 --> 00:47:42.780
Now, this problem is
like kind of sneaky.

00:47:42.780 --> 00:47:46.860
And the reason why is that
there's like the network that's

00:47:46.860 --> 00:47:48.210
obvious to build.

00:47:48.210 --> 00:47:51.053
And that turns out to be
not quite the right one.

00:47:51.053 --> 00:47:53.220
And then you can start
thinking about adding weights

00:47:53.220 --> 00:47:54.887
on your graph and
going crazy with that.

00:47:54.887 --> 00:47:57.370
But that turns out not to
be the right direction.

00:47:57.370 --> 00:47:59.932
And in fact, in
Potry Harter world,

00:47:59.932 --> 00:48:02.390
apparently, we're not worried
about their physical fitness.

00:48:02.390 --> 00:48:05.035
In other words, shortest
paths are actually

00:48:05.035 --> 00:48:06.160
irrelevant in this problem.

00:48:06.160 --> 00:48:06.827
Do you see that?

00:48:06.827 --> 00:48:13.710
Because let's say that I have
a really complicated, annoying

00:48:13.710 --> 00:48:14.210
problem.

00:48:14.210 --> 00:48:16.150
So like, maybe I have--

00:48:16.150 --> 00:48:20.310
here's my labyrinth.

00:48:20.310 --> 00:48:24.720
And we don't even talk
about the entry point,

00:48:24.720 --> 00:48:26.130
like where they actually go in.

00:48:26.130 --> 00:48:28.020
But just for fiction
purposes, let's say

00:48:28.020 --> 00:48:30.990
that they enter my
labyrinth here and that,

00:48:30.990 --> 00:48:34.638
just to be annoying, the two
doors that are enchanted--

00:48:34.638 --> 00:48:36.180
remember, we could
make a graph where

00:48:36.180 --> 00:48:39.060
all the vertices are rooms,
and the edges are doors--

00:48:39.060 --> 00:48:42.090
are like at these two endpoints
of the T. So I have a giant T.

00:48:42.090 --> 00:48:44.920
And I enter right in the middle.

00:48:44.920 --> 00:48:48.340
Now, what is Potry
Harter to do here?

00:48:48.340 --> 00:48:50.993
Well, obviously, there's--
since this graph is a tree,

00:48:50.993 --> 00:48:52.660
there's only so much
they can do, right?

00:48:52.660 --> 00:48:54.760
Maybe they enter here.

00:48:54.760 --> 00:48:56.950
They walk over all
the way to the end

00:48:56.950 --> 00:48:59.560
to disenchant the
door over here.

00:48:59.560 --> 00:49:02.680
And then they turn around
and walk to the other end.

00:49:02.680 --> 00:49:06.100
They disenchant that guy, yeah?

00:49:06.100 --> 00:49:08.140
And now they can
reach other rooms.

00:49:10.737 --> 00:49:13.070
Yeah, because that's their
goal, is to visit every room.

00:49:13.070 --> 00:49:15.842
Sorry, I think I
skipped that step.

00:49:15.842 --> 00:49:17.300
Now, there's a few
things to notice

00:49:17.300 --> 00:49:18.675
about this example,
which make it

00:49:18.675 --> 00:49:20.870
a little bit different
from the typical graph

00:49:20.870 --> 00:49:24.750
theory thing, which is, once
they disenchant this door,

00:49:24.750 --> 00:49:28.600
like they walk over here, and
they open it, well, now they

00:49:28.600 --> 00:49:31.240
walk over to this
other room, just to--

00:49:31.240 --> 00:49:32.740
you know those gym
exercises where

00:49:32.740 --> 00:49:34.630
you run to the other side of
the room, you touch the floor,

00:49:34.630 --> 00:49:35.600
and then you run back?

00:49:35.600 --> 00:49:36.880
That's kind of what
they did here, right?

00:49:36.880 --> 00:49:38.170
They ran to this room.

00:49:38.170 --> 00:49:39.240
They tapped that vertex.

00:49:39.240 --> 00:49:41.740
And now they want to turn around
and walk to the other side.

00:49:41.740 --> 00:49:44.860
They don't pay money again
on their way out, right?

00:49:44.860 --> 00:49:48.960
So once they open that
door, it stays open.

00:49:48.960 --> 00:49:52.052
And that's actually quite
important, because what it does

00:49:52.052 --> 00:49:54.510
is it makes this problem not
look like a traveling salesman

00:49:54.510 --> 00:49:57.030
problem, which
wouldn't be so great.

00:49:57.030 --> 00:49:59.040
OK, so right.

00:49:59.040 --> 00:50:02.140
And moreover, does the
fact that they're-- like,

00:50:02.140 --> 00:50:03.420
maybe I subdivide these edges.

00:50:03.420 --> 00:50:06.690
I have a bunch of edges here
that are all not enchanted.

00:50:06.690 --> 00:50:12.700
Does that matter, like if I had
like five billion edges here?

00:50:12.700 --> 00:50:13.510
No, right?

00:50:13.510 --> 00:50:15.220
Because they only
ask in this problem

00:50:15.220 --> 00:50:20.180
for the minimum number of doors
that you have to disenchant,

00:50:20.180 --> 00:50:20.680
yeah?

00:50:20.680 --> 00:50:24.940
So it might be the Harry
Harter walks really

00:50:24.940 --> 00:50:26.195
far along my graph.

00:50:26.195 --> 00:50:28.570
But as long as they don't walk
through an enchanted door,

00:50:28.570 --> 00:50:31.072
it costs them nothing.

00:50:31.072 --> 00:50:32.030
So what does that mean?

00:50:32.030 --> 00:50:34.530
Well, that means that in some
sense, the second that I enter

00:50:34.530 --> 00:50:37.710
a room, I might as well
walk to every other room

00:50:37.710 --> 00:50:41.370
that it's connected to
through unenchanted doors.

00:50:41.370 --> 00:50:43.210
And that doesn't
cost me anything.

00:50:43.210 --> 00:50:46.050
So sort of as a policy,
I should do that, right?

00:50:46.050 --> 00:50:47.160
I enter a room.

00:50:47.160 --> 00:50:48.930
And then I kind of
just search around

00:50:48.930 --> 00:50:50.730
and enter every
possible door that I

00:50:50.730 --> 00:50:54.180
can that doesn't cost me an
enchantment, because those

00:50:54.180 --> 00:50:54.690
are free.

00:50:54.690 --> 00:50:58.080
And my goal is to
visit every room, yeah?

00:50:58.080 --> 00:51:00.870
OK, so here's going to
be the sneaky trick.

00:51:00.870 --> 00:51:03.090
Like, what is that
starting to smell like?

00:51:03.090 --> 00:51:06.300
I open a door, and now I want
to explore all the other rooms

00:51:06.300 --> 00:51:08.370
that are connected to that one.

00:51:08.370 --> 00:51:09.987
AUDIENCE: Maybe a
connected component.

00:51:09.987 --> 00:51:12.070
JUSTIN SOLOMON: Yeah, maybe
a connected component.

00:51:12.070 --> 00:51:12.820
There's a problem.

00:51:12.820 --> 00:51:14.760
Is it connected
component in this graph?

00:51:14.760 --> 00:51:15.260
Well, no.

00:51:15.260 --> 00:51:17.978
Like, this whole graph is one
giant connected component.

00:51:17.978 --> 00:51:19.770
So the sneaky trick is
we're actually going

00:51:19.770 --> 00:51:23.100
to remove the enchanted doors.

00:51:23.100 --> 00:51:26.340
That was supposed to erase,
and it didn't happen.

00:51:26.340 --> 00:51:29.140
But the point is that if we
remove the connected doors,

00:51:29.140 --> 00:51:30.900
these are like the
chunks of my map

00:51:30.900 --> 00:51:34.540
that I can visit without
incurring any cost.

00:51:34.540 --> 00:51:36.600
So if I think of my
graph, maybe there's

00:51:36.600 --> 00:51:38.262
a bunch of vertices over here.

00:51:38.262 --> 00:51:39.720
And then there's
an enchanted door.

00:51:39.720 --> 00:51:41.550
And there's a bunch
of vertices over here,

00:51:41.550 --> 00:51:44.397
and then like two more
enchanted doors like that.

00:51:44.397 --> 00:51:46.230
And like, what goes on
in here, like if this

00:51:46.230 --> 00:51:47.940
is like a giant
triangle or something,

00:51:47.940 --> 00:51:50.910
is actually irrelevant, because
once I touch any one of these,

00:51:50.910 --> 00:51:53.740
I can now touch all
the rest of them.

00:51:53.740 --> 00:51:54.990
So let's suggest an algorithm.

00:51:54.990 --> 00:52:03.740
So our first step is that
we construct a graph, G,

00:52:03.740 --> 00:52:05.420
where the nodes are the rooms--

00:52:09.440 --> 00:52:10.535
are the rooms.

00:52:13.520 --> 00:52:15.650
And what should the edges be?

00:52:15.650 --> 00:52:19.220
Well, if I'm just trying to find
these little clumps of rooms

00:52:19.220 --> 00:52:22.640
that I can visit for free
if I get to any one of them,

00:52:22.640 --> 00:52:29.100
then the edges are the
non-enchanted doors.

00:52:36.300 --> 00:52:37.230
OK?

00:52:37.230 --> 00:52:41.640
And so now, in
step two, I'm going

00:52:41.640 --> 00:52:46.020
to compute my connected
components, which

00:52:46.020 --> 00:52:49.030
we covered in lecture--

00:52:49.030 --> 00:52:51.490
the connected
components of my graph,

00:52:51.490 --> 00:52:54.410
G. How much time does that take?

00:52:54.410 --> 00:52:56.660
Well, remember that there
are two different algorithms

00:52:56.660 --> 00:52:58.850
we mentioned that can do this.

00:52:58.850 --> 00:53:04.910
This is full BFS or DFS.

00:53:04.910 --> 00:53:07.880
And both of them are going to
take the same amount of time.

00:53:07.880 --> 00:53:09.250
What is that time?

00:53:09.250 --> 00:53:11.000
AUDIENCE: Linear in
the size of the graph.

00:53:11.000 --> 00:53:13.430
JUSTIN SOLOMON: Linear
in the size of the graph.

00:53:13.430 --> 00:53:16.040
So initially, that
could be problematic,

00:53:16.040 --> 00:53:17.130
because I want order n.

00:53:17.130 --> 00:53:20.840
Remember, there
are n rooms here.

00:53:20.840 --> 00:53:23.420
But thanks to our
degree bound, thanks

00:53:23.420 --> 00:53:25.953
to knowing that every room
has at most four doors,

00:53:25.953 --> 00:53:28.370
you can convince yourself that
both the number of vertices

00:53:28.370 --> 00:53:30.460
and the number of edges
are order n, which

00:53:30.460 --> 00:53:32.502
I should probably rush
through, because as usual,

00:53:32.502 --> 00:53:33.920
I'm going slowly.

00:53:33.920 --> 00:53:35.090
OK.

00:53:35.090 --> 00:53:36.815
So now, what do I have?

00:53:36.815 --> 00:53:38.690
I have a list of all
the connected components

00:53:38.690 --> 00:53:40.860
in my graph.

00:53:40.860 --> 00:53:43.340
And each one is
potentially connected

00:53:43.340 --> 00:53:47.290
to some other ones
by enchanted doors.

00:53:47.290 --> 00:53:49.473
So in some sense, I
could think about--

00:53:49.473 --> 00:53:51.640
it's not to say this is the
solution to the problem.

00:53:51.640 --> 00:53:53.432
But I could think about
modeling my problem

00:53:53.432 --> 00:53:57.010
as making some new graph,
where I put a giant vertex

00:53:57.010 --> 00:53:59.020
in every connected component.

00:53:59.020 --> 00:54:01.270
And maybe I connect
them by enchanted doors.

00:54:01.270 --> 00:54:06.490
And I want a path that touches
every one of these rooms.

00:54:06.490 --> 00:54:09.470
But that's not quite
the right way to go.

00:54:09.470 --> 00:54:12.160
And this is what catches you
by surprise, because this

00:54:12.160 --> 00:54:13.480
starts something scary, right?

00:54:13.480 --> 00:54:15.563
If you've heard of the
traveling salesman problem,

00:54:15.563 --> 00:54:17.080
it kind of smells like that.

00:54:17.080 --> 00:54:20.160
But that's not actually
correct here for two reasons.

00:54:20.160 --> 00:54:22.878
One is that once I
open an enchanted door,

00:54:22.878 --> 00:54:23.920
I can go back through it.

00:54:23.920 --> 00:54:25.780
Like, I can like
hopscotch back and forth

00:54:25.780 --> 00:54:27.370
through that door as
many times as I want,

00:54:27.370 --> 00:54:28.703
and it doesn't cost me anything.

00:54:28.703 --> 00:54:33.380
It only costs me something the
first time I open it, yeah?

00:54:33.380 --> 00:54:37.100
And moreover, I didn't
ask you to actually

00:54:37.100 --> 00:54:38.643
compute me that path.

00:54:38.643 --> 00:54:40.310
If you read the problem
closely, it just

00:54:40.310 --> 00:54:43.890
asks for the minimum number
of doors you have to open.

00:54:43.890 --> 00:54:45.830
So this is a really
sneaky problem,

00:54:45.830 --> 00:54:50.690
because it turns out there's
an additional one line of code

00:54:50.690 --> 00:54:51.853
that solves this problem.

00:54:51.853 --> 00:54:53.270
That's step three,
which I'm going

00:54:53.270 --> 00:54:56.600
to write before steps one and
two, just to keep you confused.

00:54:56.600 --> 00:55:04.180
And that is to return this
number of connected components

00:55:04.180 --> 00:55:04.720
minus 1.

00:55:07.610 --> 00:55:08.680
That seems sneaky.

00:55:08.680 --> 00:55:09.580
Why is that?

00:55:09.580 --> 00:55:14.223
Well, what's going on
here is the following,

00:55:14.223 --> 00:55:16.390
which is that let's say
that I walk along-- remember

00:55:16.390 --> 00:55:17.580
that my graph is connected.

00:55:17.580 --> 00:55:19.150
So what I know is
that I can always

00:55:19.150 --> 00:55:23.080
get from any one connected
component to any other.

00:55:23.080 --> 00:55:26.190
And so let's just
take whatever order--

00:55:26.190 --> 00:55:28.020
notice that the
problem hasn't actually

00:55:28.020 --> 00:55:31.720
asked me how to return
an efficient path.

00:55:31.720 --> 00:55:34.807
It just asked me for the minimum
number of doors I have to open.

00:55:34.807 --> 00:55:36.390
So all I have to do
is convince myself

00:55:36.390 --> 00:55:38.850
there exists a path with this
many doors I have to open.

00:55:38.850 --> 00:55:40.380
I don't have to
actually return it.

00:55:40.380 --> 00:55:44.070
If I did, it would be mildly
more annoying to think about.

00:55:44.070 --> 00:55:45.690
OK.

00:55:45.690 --> 00:55:47.292
So my graph is connected.

00:55:47.292 --> 00:55:49.375
So one thing that I could
do is make the world's--

00:55:52.170 --> 00:55:54.490
well, how do I want to do this?

00:55:57.110 --> 00:55:58.170
Well, let's see here.

00:55:58.170 --> 00:56:01.690
I guess I could come up
with an ordering that

00:56:01.690 --> 00:56:04.210
looks like depth-first
search of my graph.

00:56:04.210 --> 00:56:05.390
That should do it.

00:56:05.390 --> 00:56:05.890
OK.

00:56:05.890 --> 00:56:07.720
So maybe I start at this guy.

00:56:07.720 --> 00:56:10.570
I just start at some
arbitrary vertex.

00:56:10.570 --> 00:56:12.760
And then I'm going to
do depth-first search,

00:56:12.760 --> 00:56:14.650
but rather than
on the full graph,

00:56:14.650 --> 00:56:16.030
on this kind of
meta graph, where

00:56:16.030 --> 00:56:19.398
I've clumped together rooms
that I can get to with no cost.

00:56:19.398 --> 00:56:20.440
So what am I going to do?

00:56:20.440 --> 00:56:21.820
I'm going to start
walking outward

00:56:21.820 --> 00:56:23.740
toward this guy and then
a depth-first search,

00:56:23.740 --> 00:56:26.740
backtracking, and
then going back down.

00:56:26.740 --> 00:56:28.328
And if you think
about it, remember

00:56:28.328 --> 00:56:30.370
that in depth-first search,
I have this property,

00:56:30.370 --> 00:56:34.390
I never need to revisit a clump
which I've got to it once.

00:56:34.390 --> 00:56:36.640
Well, the total number of
doors that I'm going to open

00:56:36.640 --> 00:56:38.890
is exactly the number of
connected components minus 1,

00:56:38.890 --> 00:56:41.380
because as soon as I've done
that, my depth-first search is

00:56:41.380 --> 00:56:43.060
done here, yeah?

00:56:43.060 --> 00:56:46.680
In other words, that's the
number of nodes in my graph.

00:56:46.680 --> 00:56:48.760
So if I took--

00:56:48.760 --> 00:56:51.930
what would be a better way to--

00:56:51.930 --> 00:56:53.840
I'm noticing that in my
head, this was easier

00:56:53.840 --> 00:56:55.060
to articulate than in words.

00:56:58.315 --> 00:57:03.170
Here would be a way
to do it, would be--

00:57:03.170 --> 00:57:06.060
AUDIENCE: Maybe add some more
enchanted doors to the graph?

00:57:06.060 --> 00:57:07.390
JUSTIN SOLOMON: Maybe add
some more enchanted doors.

00:57:07.390 --> 00:57:08.100
Ah, that's true.

00:57:08.100 --> 00:57:11.070
Actually, my problem's
a little too easy.

00:57:11.070 --> 00:57:13.800
So as long as my depth-first
search backtracks

00:57:13.800 --> 00:57:15.510
along the paths
it's already found,

00:57:15.510 --> 00:57:17.280
then I'm sort of reaching
out into this tentacle,

00:57:17.280 --> 00:57:19.655
and then reaching back, and
then reaching to a new place.

00:57:19.655 --> 00:57:21.330
I'll never traverse
an enchanted door

00:57:21.330 --> 00:57:26.318
that I don't need to, because
I've already seen the location.

00:57:26.318 --> 00:57:28.360
AUDIENCE: So you're
traversing a tree, basically?

00:57:28.360 --> 00:57:29.235
JUSTIN SOLOMON: Yeah.

00:57:29.235 --> 00:57:31.993
So I've got a shortest path
tree that's going on here.

00:57:31.993 --> 00:57:33.660
Actually, I guess a
breadth-first search

00:57:33.660 --> 00:57:34.743
would be a better example.

00:57:37.638 --> 00:57:39.680
In fact, here's-- OK,
let's be concrete about it.

00:57:39.680 --> 00:57:40.220
I'm sorry.

00:57:40.220 --> 00:57:42.178
I should have thought
about this more carefully

00:57:42.178 --> 00:57:43.687
than I did at home yesterday.

00:57:43.687 --> 00:57:46.020
One thing I could do would
be to compute a shortest path

00:57:46.020 --> 00:57:49.790
tree from one vertex in this
graph to all the other ones.

00:57:49.790 --> 00:57:52.770
In particular, that gives
me the shortest path.

00:57:52.770 --> 00:57:55.490
And I could traverse
that tree to one node,

00:57:55.490 --> 00:57:57.103
and then traverse
it all the way back,

00:57:57.103 --> 00:57:58.520
and then reverse
it to a new node,

00:57:58.520 --> 00:58:01.040
and then traverse it all
the way back, and so on.

00:58:01.040 --> 00:58:04.310
This is not an efficient path
from a walking perspective.

00:58:04.310 --> 00:58:05.990
But from a door
opening perspective,

00:58:05.990 --> 00:58:08.690
it's extremely efficient,
because it's a tree, right?

00:58:08.690 --> 00:58:10.640
And remember that
the number of edges

00:58:10.640 --> 00:58:13.520
in a spanning tree of
my graph is exactly

00:58:13.520 --> 00:58:18.480
the number of vertices
in my graph minus 1,

00:58:18.480 --> 00:58:20.850
which is exactly the
property we have here.

00:58:20.850 --> 00:58:23.090
Whoo, sweating for
a second there.

00:58:23.090 --> 00:58:24.570
OK.

00:58:24.570 --> 00:58:27.720
So now, in our remaining
30 minutes here, we've

00:58:27.720 --> 00:58:31.210
got two more problems, which
is more than enough time,

00:58:31.210 --> 00:58:33.728
especially because
the last problem is

00:58:33.728 --> 00:58:35.520
largely combinatorial
and less algorithmic.

00:58:35.520 --> 00:58:37.890
So I think it's OK to focus--

00:58:37.890 --> 00:58:41.220
maybe talk about that at a
high level and show a fun plot.

00:58:41.220 --> 00:58:47.140
OK, so for problem 4, we have
an airline, Purity Atlantic.

00:58:47.140 --> 00:58:49.800
That's cute, Jason, really.

00:58:49.800 --> 00:58:53.430
And it's owned by
Brichard Ranson.

00:58:53.430 --> 00:58:55.110
Did I get that right?

00:58:55.110 --> 00:59:00.876
And Purity Atlantic
has a cute sale--

00:59:00.876 --> 00:59:05.190
this is not like a
cute angle, I suppose--

00:59:05.190 --> 00:59:06.880
which is essentially
the following,

00:59:06.880 --> 00:59:09.210
which is that you can
book an itinerary where

00:59:09.210 --> 00:59:11.160
you have your home city.

00:59:11.160 --> 00:59:14.160
And then you choose, I
believe, three other cities

00:59:14.160 --> 00:59:16.170
that you want to visit.

00:59:16.170 --> 00:59:18.560
And then Purity Atlantic--

00:59:18.560 --> 00:59:20.310
maybe you're on your
honeymoon, and you're

00:59:20.310 --> 00:59:23.025
not concerned with price, but
rather, just the efficiency,

00:59:23.025 --> 00:59:25.650
because you don't want to spend
your whole time in an airplane.

00:59:25.650 --> 00:59:28.290
That's particularly
true this month.

00:59:28.290 --> 00:59:30.170
Then what do you want to do?

00:59:30.170 --> 00:59:33.090
You want to minimize your total
number of connections, right?

00:59:33.090 --> 00:59:38.070
Because as we all
know, in spring 2020,

00:59:38.070 --> 00:59:41.190
we don't want to spend very
much time in airports, yeah?

00:59:41.190 --> 00:59:43.530
So, right.

00:59:43.530 --> 00:59:45.120
So how do we do that?

00:59:45.120 --> 00:59:47.460
Well, we make a
website, where you

00:59:47.460 --> 00:59:49.593
tell Purity Atlantic
the cities that you want

00:59:49.593 --> 00:59:50.760
to visit and your home city.

00:59:50.760 --> 00:59:53.430
And they give you back
an efficient itinerary

00:59:53.430 --> 00:59:56.410
that minimizes the
number of connections.

00:59:56.410 --> 00:59:56.910
OK.

00:59:56.910 --> 01:00:00.140
And the question is, how do
you actually do that, right?

01:00:00.140 --> 01:00:03.420
How do you compute
the best itinerary

01:00:03.420 --> 01:00:05.837
that minimizes the number
of flights you have to take?

01:00:05.837 --> 01:00:06.920
So what are our variables?

01:00:06.920 --> 01:00:08.330
And sometimes it feels
like the variables

01:00:08.330 --> 01:00:10.190
are all the different
permutations of the cities you

01:00:10.190 --> 01:00:10.990
could visit, right?

01:00:10.990 --> 01:00:15.140
I could go to, I don't know,
Cambridge, Boston, and then

01:00:15.140 --> 01:00:16.760
Cambridge in the UK.

01:00:16.760 --> 01:00:18.590
Maybe you're doing like
a University thing,

01:00:18.590 --> 01:00:21.210
and then, I don't know,
Budapest and some other place.

01:00:21.210 --> 01:00:23.330
Or I could do those
in any other order.

01:00:23.330 --> 01:00:25.680
And that feels like it
should be factorial,

01:00:25.680 --> 01:00:28.820
which would be bad news.

01:00:28.820 --> 01:00:33.140
But this is one of
these problems which

01:00:33.140 --> 01:00:35.750
I suppose a computer
science theorist might

01:00:35.750 --> 01:00:37.190
call fixed parameter tractable.

01:00:37.190 --> 01:00:39.800
But that's sort of an
overkill term here.

01:00:39.800 --> 01:00:41.690
But essentially, as
long as you ignore

01:00:41.690 --> 01:00:45.410
all the factors that make this
problem hard, then it's easy.

01:00:45.410 --> 01:00:48.290
A different way to
put it is that, OK,

01:00:48.290 --> 01:00:50.720
if I'm only visiting
three cities, what's

01:00:50.720 --> 01:00:56.650
the total number of possible
orderings of my three cities?

01:00:56.650 --> 01:00:59.090
Class?

01:00:59.090 --> 01:01:04.960
So I have city A, B, C. I could
do B, C, A. I could do B, A, C.

01:01:04.960 --> 01:01:06.150
AUDIENCE: List them out.

01:01:06.150 --> 01:01:09.270
JUSTIN SOLOMON:
Yeah, fine, Jason.

01:01:09.270 --> 01:01:10.870
I'll do that.

01:01:10.870 --> 01:01:15.830
So this is what we call
direct proof mathematically,

01:01:15.830 --> 01:01:21.050
which are other possible
ways to visit three cities.

01:01:28.810 --> 01:01:32.710
And now, by my direct proof, I
claim there are no other ways

01:01:32.710 --> 01:01:34.360
to visit three cities.

01:01:34.360 --> 01:01:36.890
And in particular,
there are 1, 2, 3, 4, 5,

01:01:36.890 --> 01:01:41.470
6 different orderings of
the cities that I can visit.

01:01:41.470 --> 01:01:43.570
Notice that this is a
constant in my problem.

01:01:43.570 --> 01:01:45.850
I am not asking you
to make a website that

01:01:45.850 --> 01:01:48.747
takes like the
total set of cities

01:01:48.747 --> 01:01:50.830
that you want to visit as
a couple and order them.

01:01:50.830 --> 01:01:52.450
It's specifically three.

01:01:52.450 --> 01:01:57.730
You might also notice that 6 is
3 factorial, which is perhaps

01:01:57.730 --> 01:02:00.880
a more efficient way to
get to that same bound.

01:02:00.880 --> 01:02:02.050
OK.

01:02:02.050 --> 01:02:02.740
So, right.

01:02:02.740 --> 01:02:05.470
So there's six different
orderings of the cities.

01:02:05.470 --> 01:02:09.090
And in each case, what
am I going to have to do?

01:02:09.090 --> 01:02:13.270
I'm going to have to compute
the sum of going from my source

01:02:13.270 --> 01:02:16.498
city to the first one, from the
first one to the second one,

01:02:16.498 --> 01:02:18.040
from the second one
to the third one,

01:02:18.040 --> 01:02:21.490
from the third one back
to the first one, OK?

01:02:21.490 --> 01:02:24.140
So what do I need?

01:02:24.140 --> 01:02:26.535
Well, I need-- in
some sense, I want

01:02:26.535 --> 01:02:27.910
to be conservative
about it, just

01:02:27.910 --> 01:02:30.850
the cost of flying from every
city to every other city.

01:02:30.850 --> 01:02:32.390
But that's not quite right.

01:02:32.390 --> 01:02:35.590
I only need the cost of
flying from every city

01:02:35.590 --> 01:02:37.270
that you have specified
as a city you're

01:02:37.270 --> 01:02:38.920
interested in to
every other city

01:02:38.920 --> 01:02:41.524
that you've specified that
you're interested in, yeah?

01:02:41.524 --> 01:02:42.790
OK.

01:02:42.790 --> 01:02:46.880
So in particular,
I go to my new one.

01:02:46.880 --> 01:02:52.300
So in this problem, we have
c cities and f flights.

01:02:56.780 --> 01:02:57.280
OK.

01:02:57.280 --> 01:02:58.910
And initially, it
might seem that we

01:02:58.910 --> 01:03:01.010
have to compute a ton
of shortest paths.

01:03:01.010 --> 01:03:03.170
But like, if I want
to go from Boston,

01:03:03.170 --> 01:03:06.365
to Budapest, to London, to--

01:03:06.365 --> 01:03:07.490
I'm running out of cities--

01:03:07.490 --> 01:03:10.460
Paris, and back to Boston, or
whatever ordering I prefer,

01:03:10.460 --> 01:03:16.070
do I need to worry about the
shortest path from Nebraska

01:03:16.070 --> 01:03:17.630
to California?

01:03:17.630 --> 01:03:18.297
Potentially not.

01:03:18.297 --> 01:03:19.588
Like, that could be irrelevant.

01:03:19.588 --> 01:03:22.040
The only ones that I care
about are those four cities

01:03:22.040 --> 01:03:24.770
that I've identified, OK?

01:03:24.770 --> 01:03:29.620
So there's 3 factorial
possible permutations.

01:03:29.620 --> 01:03:36.700
And at the end of the day, well,
there's 2 times 4 choose 2.

01:03:36.700 --> 01:03:45.480
If you're wondering, this is 12,
or big O of 1 pairs of cities,

01:03:45.480 --> 01:03:46.470
meaning that, like--

01:03:49.260 --> 01:03:53.930
for itinerary
purposes-- itinerary--

01:03:57.480 --> 01:04:02.685
meaning that if I always enter
an airport in one of city A, B,

01:04:02.685 --> 01:04:06.720
C, or my hometown, and I always
exit through another one,

01:04:06.720 --> 01:04:08.820
so then there's four
possible cities.

01:04:08.820 --> 01:04:11.550
I choose them two at a time.

01:04:11.550 --> 01:04:13.430
Notice that flights
might not be ordered.

01:04:13.430 --> 01:04:15.680
Like, I might be able to get
from one city to another.

01:04:15.680 --> 01:04:18.150
But then maybe the airplane
has a connection or something.

01:04:18.150 --> 01:04:19.970
So going back is
a different cost.

01:04:19.970 --> 01:04:24.140
But totally, there's 2 times
4 choose 2 different pairs

01:04:24.140 --> 01:04:27.050
of cities that I could
enter or exit from.

01:04:27.050 --> 01:04:28.400
OK.

01:04:28.400 --> 01:04:31.020
So now, what am I going to do?

01:04:31.020 --> 01:04:36.790
Well, so I can compute the
12 different shortest paths

01:04:36.790 --> 01:04:38.640
that matter in my graph.

01:04:38.640 --> 01:04:40.720
So when I say shortest
path, what do I mean?

01:04:40.720 --> 01:04:49.850
Well, I'm going to
construct a graph, G,

01:04:49.850 --> 01:05:02.660
with one vertex per city
and one edge per flight.

01:05:05.760 --> 01:05:08.130
And notice the
number of connections

01:05:08.130 --> 01:05:10.020
that I need to make,
the minimum number

01:05:10.020 --> 01:05:13.020
between any city
than any other city,

01:05:13.020 --> 01:05:14.760
is equal to the shortest path--

01:05:14.760 --> 01:05:17.370
the length of the shortest
path minus 1, right?

01:05:17.370 --> 01:05:18.885
So like, maybe I have--

01:05:18.885 --> 01:05:20.430
like, here's Boston.

01:05:20.430 --> 01:05:21.630
Here's London.

01:05:21.630 --> 01:05:28.450
Here's Paris, B, L, P for short.

01:05:28.450 --> 01:05:31.977
Then the length of my
shortest path is 2.

01:05:31.977 --> 01:05:33.810
And the number of
connections I have to make

01:05:33.810 --> 01:05:37.110
is 1, because I stop
through London, yeah?

01:05:37.110 --> 01:05:38.470
So what am I going to do?

01:05:38.470 --> 01:05:46.623
Well, for every pair
of cities in this--

01:05:46.623 --> 01:05:49.620
oops-- no, that's OK--

01:05:53.230 --> 01:05:57.250
in the set of the source
city and the three cities

01:05:57.250 --> 01:06:04.280
you want to visit, I'm going
to compute the shortest--

01:06:04.280 --> 01:06:06.257
the length of the shortest path.

01:06:06.257 --> 01:06:08.090
So this is the minimum
number of connections

01:06:08.090 --> 01:06:09.548
I need to get from
any one of these

01:06:09.548 --> 01:06:14.600
to any other one in my graph, G.

01:06:14.600 --> 01:06:16.100
Well, how much time
does this take?

01:06:16.100 --> 01:06:17.690
Well, there's 12 such pairs.

01:06:17.690 --> 01:06:19.740
We already argued that.

01:06:19.740 --> 01:06:25.890
And how much time does it take
to actually do shortest path,

01:06:25.890 --> 01:06:27.817
so using breadth-first search?

01:06:27.817 --> 01:06:29.650
AUDIENCE: Linear time
the size of the graph.

01:06:29.650 --> 01:06:31.733
JUSTIN SOLOMON: Linear
time the size of the graph.

01:06:31.733 --> 01:06:34.060
I think Jason actually has
a t-shirt that says that.

01:06:34.060 --> 01:06:36.040
Well, in this case,
remember, that's

01:06:36.040 --> 01:06:39.370
big O of the number of edges
plus the number of vertices.

01:06:39.370 --> 01:06:42.400
But just to make your life
a little more annoying,

01:06:42.400 --> 01:06:44.647
the number of vertices
is the number of cities.

01:06:44.647 --> 01:06:46.980
And the number of edges is
the number of flights, right?

01:06:46.980 --> 01:06:52.700
So this takes 12 times O of c
plus f time, which, of course,

01:06:52.700 --> 01:06:57.472
is just O of c plus f time.

01:06:57.472 --> 01:06:58.930
Notice, this is
one of these things

01:06:58.930 --> 01:06:59.972
where we're being sneaky.

01:06:59.972 --> 01:07:01.870
We told you that
you specifically

01:07:01.870 --> 01:07:04.030
visit three places.

01:07:04.030 --> 01:07:06.580
And that's where this
number 12 came from.

01:07:06.580 --> 01:07:09.400
If we'd said that you
wanted to visit m cities,

01:07:09.400 --> 01:07:11.710
then this would be a very
different homework problem.

01:07:11.710 --> 01:07:13.710
This is one of those
things you got to remember,

01:07:13.710 --> 01:07:15.400
where we've given
you a few constants,

01:07:15.400 --> 01:07:17.530
and you should use them.

01:07:17.530 --> 01:07:18.430
OK.

01:07:18.430 --> 01:07:21.680
So now, what can I do?

01:07:21.680 --> 01:07:39.400
I can iterate over every
permutation of A, B, C, right?

01:07:39.400 --> 01:07:45.670
So this is like saying I go from
my source to city 1, to city 2,

01:07:45.670 --> 01:07:49.930
to city 3, back to my source.

01:07:49.930 --> 01:08:01.170
I add together and compute the
cost, the cost of that trip.

01:08:01.170 --> 01:08:02.940
And remember, cost
in this case is

01:08:02.940 --> 01:08:05.970
equal to the minimum
number of connections.

01:08:05.970 --> 01:08:07.500
And then I return the minimizer.

01:08:10.890 --> 01:08:12.540
So I say, like, is
it cheaper for me

01:08:12.540 --> 01:08:15.270
to go Boston, Budapest,
Paris, Boston, Paris,

01:08:15.270 --> 01:08:17.140
Budapest, and so on.

01:08:17.140 --> 01:08:19.080
So a for loop over
permutations, which

01:08:19.080 --> 01:08:20.609
generally is frowned upon.

01:08:20.609 --> 01:08:22.710
But in this case,
because we told you

01:08:22.710 --> 01:08:26.090
you're visiting
precisely three places,

01:08:26.090 --> 01:08:29.390
how many steps are going
to happen in that for loop?

01:08:29.390 --> 01:08:32.390
Well, we actually wrote them
all out over here on our board.

01:08:32.390 --> 01:08:36.080
It's exactly 3 factorial,
or 6 steps, right?

01:08:36.080 --> 01:08:39.200
3 times 2 times 1, which is 6.

01:08:39.200 --> 01:08:40.939
OK.

01:08:40.939 --> 01:08:41.569
So, right.

01:08:41.569 --> 01:08:44.300
So at the end of the
day, this for loop

01:08:44.300 --> 01:08:52.859
is going to take, well, order 6
time, which, of course, is just

01:08:52.859 --> 01:08:53.370
order 1.

01:08:53.370 --> 01:08:56.160
So it doesn't really contribute
to our runtime at all.

01:08:56.160 --> 01:09:01.560
And our entire algorithm
runs in c plus f time.

01:09:01.560 --> 01:09:02.677
OK, so right.

01:09:02.677 --> 01:09:04.260
So this is one of
these problems where

01:09:04.260 --> 01:09:06.210
you're really taking
advantage of the constants

01:09:06.210 --> 01:09:06.918
that we gave you.

01:09:06.918 --> 01:09:09.060
We said you're
visiting three cities.

01:09:09.060 --> 01:09:10.470
So use it.

01:09:10.470 --> 01:09:12.720
Incidentally, as a
computer science theorist,

01:09:12.720 --> 01:09:15.930
if I said you're visiting
exactly 17 cities,

01:09:15.930 --> 01:09:17.800
well, what would
be our numbers now?

01:09:17.800 --> 01:09:22.020
I mean, it would be 17 factorial
and then like 17 choose 2.

01:09:22.020 --> 01:09:22.960
Those are big numbers.

01:09:22.960 --> 01:09:24.127
But they're still constants.

01:09:24.127 --> 01:09:26.580
So for purposes of this
class, that would be OK.

01:09:26.580 --> 01:09:29.939
But the second that I
give it a name, like m,

01:09:29.939 --> 01:09:32.700
then I got to think about those
factorial things a little more

01:09:32.700 --> 01:09:34.490
carefully.

01:09:34.490 --> 01:09:36.439
All right.

01:09:36.439 --> 01:09:37.510
So that's this problem.

01:09:37.510 --> 01:09:39.950
So the basic trick
here was that,

01:09:39.950 --> 01:09:42.800
like, yeah, it looks like
all pairs shortest path.

01:09:42.800 --> 01:09:43.760
But it's not quite.

01:09:43.760 --> 01:09:45.740
It's all pairs of things
that you're actually

01:09:45.740 --> 01:09:47.850
going to travel
between shortest path.

01:09:47.850 --> 01:09:51.090
And since that number of pairs
is finite-- it's just 12--

01:09:51.090 --> 01:09:53.210
that's an OK thing to do.

01:09:53.210 --> 01:09:55.590
OK.

01:09:55.590 --> 01:09:57.150
How we doing?

01:09:57.150 --> 01:09:58.020
Ah, 15 minutes.

01:09:58.020 --> 01:09:59.468
Perfect.

01:09:59.468 --> 01:10:01.010
I didn't want to do
the last problem.

01:10:01.010 --> 01:10:03.860
And I think I've
managed to get myself

01:10:03.860 --> 01:10:05.390
in exactly that position.

01:10:05.390 --> 01:10:05.970
OK.

01:10:05.970 --> 01:10:07.820
So the very last problem
on this homework,

01:10:07.820 --> 01:10:09.237
which, again, this
homework really

01:10:09.237 --> 01:10:12.260
follows the prototypical
6.006 breadth-first search,

01:10:12.260 --> 01:10:13.700
depth-first search homework.

01:10:13.700 --> 01:10:16.190
I feel like they all fall
into a similar pattern.

01:10:16.190 --> 01:10:18.680
Again, all these resources
are available to you guys.

01:10:18.680 --> 01:10:20.960
You should look at them.

01:10:20.960 --> 01:10:22.850
We're not trying
to hide anything.

01:10:22.850 --> 01:10:24.920
This problem involves
solving a pocket

01:10:24.920 --> 01:10:26.990
cube, which is like a
little mini Rubik's cube,

01:10:26.990 --> 01:10:29.750
which is 2 by 2.

01:10:29.750 --> 01:10:33.340
And it looks like this.

01:10:33.340 --> 01:10:34.750
Ah, there's chalk.

01:10:34.750 --> 01:10:38.750
Actually, there we go.

01:10:38.750 --> 01:10:39.840
So here's my Rubik's cube.

01:10:42.780 --> 01:10:47.790
Looks like a cube, which I'm
having some trouble drawing.

01:10:47.790 --> 01:10:52.190
And in particular,
it's 2 by 2, which

01:10:52.190 --> 01:10:56.870
makes it a little easier than
your typical Rubik's cube.

01:10:56.870 --> 01:11:00.260
And in particular, we're
going to mark some faces.

01:11:00.260 --> 01:11:02.340
Sneakily, they used a
little geometry term here,

01:11:02.340 --> 01:11:03.300
which is cute.

01:11:03.300 --> 01:11:05.492
So here's face f0.

01:11:05.492 --> 01:11:06.950
I'm sorry you can't
quite see that.

01:11:06.950 --> 01:11:11.360
But the top face is f0, in
case you were wondering.

01:11:11.360 --> 01:11:15.650
The left face is f1.

01:11:15.650 --> 01:11:20.323
And the front-facing
face here, f2.

01:11:20.323 --> 01:11:21.740
Notice that we've
identified these

01:11:21.740 --> 01:11:24.620
by like vectors that point
90 degrees out from the face.

01:11:24.620 --> 01:11:26.625
These are called normal vectors.

01:11:26.625 --> 01:11:28.250
If you want to define
those rigorously,

01:11:28.250 --> 01:11:30.950
you can take my
grad level class.

01:11:30.950 --> 01:11:33.960
But for a Rubik's cube,
it's not terribly difficult.

01:11:33.960 --> 01:11:37.250
But in any event, I can talk
about flipping this Rubik's

01:11:37.250 --> 01:11:40.080
cube in a pretty easy
way, which is that I like,

01:11:40.080 --> 01:11:42.450
I'm going to fix one
corner of my cube.

01:11:42.450 --> 01:11:45.110
So this is like the corner that
I'm holding onto with my hand.

01:11:45.110 --> 01:11:47.030
And now I can grab, what?

01:11:47.030 --> 01:11:50.330
The top, the side, or
the front of my cube.

01:11:50.330 --> 01:11:53.218
And I can rotate it clockwise
or counterclockwise.

01:11:53.218 --> 01:11:55.760
And you can convince yourself
those are all the possible ways

01:11:55.760 --> 01:11:58.280
that I could sort of mess
with the state of my cube

01:11:58.280 --> 01:12:01.100
after fixing one corner.

01:12:01.100 --> 01:12:02.960
OK, right.

01:12:02.960 --> 01:12:05.592
And so this problem
basically is involving

01:12:05.592 --> 01:12:06.800
sort of a very typical trick.

01:12:06.800 --> 01:12:10.430
In fact, a lot of the history
of these different search

01:12:10.430 --> 01:12:13.070
algorithms-- breadth-first
search, depth-first search, A*,

01:12:13.070 --> 01:12:16.370
which I guess we won't
really cover here--

01:12:16.370 --> 01:12:19.770
date back to, what,
20 or 30 years ago,

01:12:19.770 --> 01:12:22.250
we would have called
artificial intelligence.

01:12:22.250 --> 01:12:25.220
These days, that has a
very different meaning.

01:12:25.220 --> 01:12:28.580
But back in the day, AI was
all about solving board games,

01:12:28.580 --> 01:12:31.910
and Rubik's cubes, and
all these kinds of things,

01:12:31.910 --> 01:12:32.912
using algorithms.

01:12:32.912 --> 01:12:34.370
And the way that
they would do that

01:12:34.370 --> 01:12:37.910
is by searching the different
spaces of configurations.

01:12:37.910 --> 01:12:41.420
And so now, if we think
of every face of this cube

01:12:41.420 --> 01:12:45.080
as painted with a color, there
are different configurations

01:12:45.080 --> 01:12:49.280
of my graph that I get by
flipping the three sides.

01:12:49.280 --> 01:12:59.610
So if we think of there
being a vertex for each state

01:12:59.610 --> 01:13:03.180
of my cube, where
state here means

01:13:03.180 --> 01:13:07.020
like the coloring of every
face on my Rubik's cube,

01:13:07.020 --> 01:13:14.610
then there's an
edge for every move.

01:13:14.610 --> 01:13:17.460
And in this problem, we
encoded a move as a pair,

01:13:17.460 --> 01:13:20.280
j comma s, where
it's saying that I'm

01:13:20.280 --> 01:13:28.710
going to rotate face fj, where
j is between, I guess, 0, 1, 2,

01:13:28.710 --> 01:13:32.160
in direction s.

01:13:32.160 --> 01:13:35.940
And we can just index that as
like plus or minus 1 to kind

01:13:35.940 --> 01:13:38.970
of say counterclockwise
or clockwise.

01:13:38.970 --> 01:13:40.720
So this is kind of
a cute thing, where

01:13:40.720 --> 01:13:43.310
your graph has a
bunch of vertices,

01:13:43.310 --> 01:13:46.760
which are all Rubik's cubes.

01:13:46.760 --> 01:13:48.080
That's a cube.

01:13:48.080 --> 01:13:50.900
And then there are edges if
I can get from one to another

01:13:50.900 --> 01:13:53.070
by doing one of these moves.

01:13:53.070 --> 01:13:54.980
And this is a nice
abstraction, because if I

01:13:54.980 --> 01:13:58.298
want to solve a Rubik's cube
in the most efficient way

01:13:58.298 --> 01:14:00.590
possible, one way to do that
is to compute the shortest

01:14:00.590 --> 01:14:03.920
path from my current
configuration

01:14:03.920 --> 01:14:08.090
to the Platonic
Rubik's cube, where

01:14:08.090 --> 01:14:11.720
all the colors are constant on
the different faces of my cube.

01:14:11.720 --> 01:14:15.560
And so that's like a sort
of basic identification

01:14:15.560 --> 01:14:18.650
that happens all over the
place in search strategies,

01:14:18.650 --> 01:14:21.530
where I'm going to think
of every vertex of my graph

01:14:21.530 --> 01:14:24.290
as being the state of
some system and every edge

01:14:24.290 --> 01:14:26.900
as being a transition
from one to another.

01:14:26.900 --> 01:14:29.693
And then paths in this thing
are kind of like different ways

01:14:29.693 --> 01:14:30.860
of solving my puzzle, right?

01:14:30.860 --> 01:14:33.740
So like a different one
would be, I don't know,

01:14:33.740 --> 01:14:38.210
every vertex is a chess board
with the chess pieces scattered

01:14:38.210 --> 01:14:39.080
on the chess board.

01:14:39.080 --> 01:14:42.520
And every edge is one chess
move by one player or the other.

01:14:42.520 --> 01:14:45.200
In that case, you'd have to be
a little careful, because you

01:14:45.200 --> 01:14:47.825
want player 1 or player 2 to go
back and forth from each other.

01:14:47.825 --> 01:14:50.150
But I'll let you think
about the reduction there.

01:14:50.150 --> 01:14:52.010
OK, so right.

01:14:52.010 --> 01:14:54.680
This problem, I think
largely, is mostly

01:14:54.680 --> 01:14:57.120
just fun combinatorics
rather than algorithms.

01:14:57.120 --> 01:15:00.240
But there's a little bit of
algorithms hiding in here.

01:15:00.240 --> 01:15:02.240
So they want you to
argue that the number

01:15:02.240 --> 01:15:04.460
of distinct configurations
of this Rubik's

01:15:04.460 --> 01:15:08.062
cube, this 2-by-2 guy,
is less than 12 million.

01:15:08.062 --> 01:15:10.520
This is nice, because 12 million
is a number that computers

01:15:10.520 --> 01:15:12.698
can actually cope with.

01:15:12.698 --> 01:15:14.990
And so there's a pretty
straightforward argument there.

01:15:19.860 --> 01:15:20.790
Right.

01:15:20.790 --> 01:15:27.490
So in particular, here's a cube.

01:15:27.490 --> 01:15:29.463
How many quarters are in a cube?

01:15:29.463 --> 01:15:30.130
AUDIENCE: Eight.

01:15:30.130 --> 01:15:31.450
JUSTIN SOLOMON: Eight, thanks.

01:15:31.450 --> 01:15:35.650
I hid one back here, in
case you were wondering.

01:15:35.650 --> 01:15:39.220
So let's say that I fix
a corner of the cube,

01:15:39.220 --> 01:15:40.900
like we've done that.

01:15:40.900 --> 01:15:44.470
Then every time that I rotate
one of the faces of my cube

01:15:44.470 --> 01:15:46.150
clockwise or
counterclockwise, I'm

01:15:46.150 --> 01:15:48.080
essentially like taking
one corner of my cube

01:15:48.080 --> 01:15:50.890
and like sticking it in
another place, right?

01:15:50.890 --> 01:15:56.835
So in all, seven corners
of my cube can move.

01:15:59.980 --> 01:16:02.605
And if I'm not
worried about, like--

01:16:02.605 --> 01:16:04.690
it could be that some
of these permutations

01:16:04.690 --> 01:16:06.655
are not actually achievable
by a set of steps.

01:16:06.655 --> 01:16:08.530
Like, maybe I'd have to
break my Rubik's cube

01:16:08.530 --> 01:16:10.580
and glue it back together.

01:16:10.580 --> 01:16:12.490
But if I'm being
conservative about it,

01:16:12.490 --> 01:16:15.430
there's of course less
than or equal to 7

01:16:15.430 --> 01:16:18.415
factorial different
configurations of the corners.

01:16:24.520 --> 01:16:26.590
So in other words, every
time I rotate my face,

01:16:26.590 --> 01:16:28.700
one of the corners ends
up in a different place.

01:16:28.700 --> 01:16:31.325
So there's 7 factorial different
ways that could have happened.

01:16:33.840 --> 01:16:35.957
OK, so that's part of my bound.

01:16:35.957 --> 01:16:38.040
Remember that I'm trying
to bound the total number

01:16:38.040 --> 01:16:40.020
of configurations here.

01:16:40.020 --> 01:16:42.240
And essentially, what I've
done so far is I've said,

01:16:42.240 --> 01:16:46.180
OK, well, there's
a bunch of cubes

01:16:46.180 --> 01:16:47.980
in my 2-by-2 Rubik's cube.

01:16:47.980 --> 01:16:50.890
So I'm going to like
unglue this entire cube,

01:16:50.890 --> 01:16:53.568
take just this corner,
and stick it up here.

01:16:53.568 --> 01:16:55.360
And there's like 7
factorial different ways

01:16:55.360 --> 01:16:57.873
that I could do that.

01:16:57.873 --> 01:16:59.540
But I still have to
account for the fact

01:16:59.540 --> 01:17:00.830
that I pull this piece off.

01:17:00.830 --> 01:17:02.002
I stick it in the top.

01:17:02.002 --> 01:17:03.710
But I have to figure
out its orientation.

01:17:03.710 --> 01:17:07.340
I can still rotate
it about this corner.

01:17:07.340 --> 01:17:09.140
And in fact, there are
three different ways

01:17:09.140 --> 01:17:10.400
that I could rotate it, right?

01:17:10.400 --> 01:17:11.840
You can kind of see it, right?

01:17:11.840 --> 01:17:15.300
1, 2, 3, yeah?

01:17:15.300 --> 01:17:27.750
So in all, so each corner
can rotate three ways.

01:17:27.750 --> 01:17:32.300
So that means that I
have 3 times 7 factorial

01:17:32.300 --> 01:17:36.280
different configurations
as an upper bound.

01:17:36.280 --> 01:17:45.520
And this number is,
wait for it, 11,022,480.

01:17:45.520 --> 01:17:49.300
The problem asks you to argue
that your upper bound is

01:17:49.300 --> 01:17:50.840
upper bounded by 12 million.

01:17:50.840 --> 01:17:55.045
And indeed, it is less than
or equal to 12 million.

01:17:55.045 --> 01:17:59.480
AUDIENCE: Is that 3
times 7 factorial or--

01:17:59.480 --> 01:18:00.830
JUSTIN SOLOMON: Oh, I'm sorry.

01:18:00.830 --> 01:18:03.247
Right, because there are
seven corners, each of which

01:18:03.247 --> 01:18:04.580
can rotate three different ways.

01:18:04.580 --> 01:18:07.730
It's actually 3 to the 7th
power times 7 factorial.

01:18:07.730 --> 01:18:10.550
Thank you, student.

01:18:10.550 --> 01:18:12.170
OK, right.

01:18:12.170 --> 01:18:13.820
So let's see here.

01:18:13.820 --> 01:18:17.030
Really quickly moving here,
the next problem says,

01:18:17.030 --> 01:18:18.890
state the maximum
and minimum degree

01:18:18.890 --> 01:18:22.350
of any vertex in my graph.

01:18:22.350 --> 01:18:24.420
First of all, do
I expect vertices

01:18:24.420 --> 01:18:25.740
to have different degrees?

01:18:25.740 --> 01:18:28.320
This is kind of a goofy problem.

01:18:28.320 --> 01:18:35.450
Like, what would it mean to have
a vertex that somehow has lower

01:18:35.450 --> 01:18:36.575
degree than another vertex?

01:18:36.575 --> 01:18:38.450
It would mean that
there's some configuration

01:18:38.450 --> 01:18:40.950
of this cube for which
there are fewer moves that I

01:18:40.950 --> 01:18:43.320
could do to change it than
a different configuration

01:18:43.320 --> 01:18:45.582
of this cube.

01:18:45.582 --> 01:18:47.290
And that's obviously
not the case, right?

01:18:47.290 --> 01:18:51.820
Because when I flip one of the
faces of my cube, all I'm doing

01:18:51.820 --> 01:18:53.230
is I'm moving the colors around.

01:18:53.230 --> 01:18:55.430
I haven't somehow changed
the physics of how

01:18:55.430 --> 01:18:57.160
a Rubik's cube works, right?

01:18:57.160 --> 01:19:02.140
And so I think this
was just intended to be

01:19:02.140 --> 01:19:04.120
annoying by your instructors.

01:19:04.120 --> 01:19:13.780
The min degree is equal
to the max degree.

01:19:13.780 --> 01:19:17.290
And in fact, the degree
of every node in my graph

01:19:17.290 --> 01:19:20.180
is constant here.

01:19:20.180 --> 01:19:21.980
The one thing that's
worth noting here--

01:19:21.980 --> 01:19:23.123
what I haven't argued--

01:19:23.123 --> 01:19:24.540
it turns out, I
think, to be true.

01:19:24.540 --> 01:19:27.980
But what I have argued is
that I couldn't rotate a face

01:19:27.980 --> 01:19:29.930
and actually end up in
the same configuration.

01:19:29.930 --> 01:19:32.128
Like, maybe, for some
reason, I had red all the way

01:19:32.128 --> 01:19:32.920
around the outside.

01:19:32.920 --> 01:19:35.357
And so when I rotate
it, nothing changed.

01:19:35.357 --> 01:19:36.440
That obviously isn't true.

01:19:36.440 --> 01:19:37.965
But I haven't
argued it carefully.

01:19:37.965 --> 01:19:40.340
But as long as I don't worry
about my graph being simple,

01:19:40.340 --> 01:19:43.880
like I'm OK with self-loops,
then the degree is certainly

01:19:43.880 --> 01:19:45.800
constant, yeah?

01:19:45.800 --> 01:19:47.690
OK.

01:19:47.690 --> 01:19:50.770
And in fact, I don't think that
can happen in a typical Rubik's

01:19:50.770 --> 01:19:51.270
cube.

01:19:51.270 --> 01:19:52.645
AUDIENCE: Well,
I think the point

01:19:52.645 --> 01:19:55.585
is to say what the degree was.

01:19:55.585 --> 01:19:56.960
JUSTIN SOLOMON:
Oh, yeah, indeed.

01:19:56.960 --> 01:19:58.130
So we haven't
computed the degree.

01:19:58.130 --> 01:20:00.260
But we've argued that
they're equal to one another.

01:20:00.260 --> 01:20:04.280
OK, so now we have to
compute what that degree is.

01:20:04.280 --> 01:20:05.410
And here's how to do it.

01:20:05.410 --> 01:20:08.780
So of course--
well, this, I think,

01:20:08.780 --> 01:20:11.120
is actually even easier
than the first part.

01:20:11.120 --> 01:20:14.030
Essentially, remember, we
have three different options

01:20:14.030 --> 01:20:15.440
for faces that I can rotate.

01:20:15.440 --> 01:20:19.820
I can rotate the top, the
front, or the side here.

01:20:19.820 --> 01:20:24.950
So there's three faces
that we could rotate.

01:20:27.360 --> 01:20:29.360
OK, and how many different
ways can rotate them?

01:20:29.360 --> 01:20:32.870
I can rotate them
counterclockwise or clockwise.

01:20:32.870 --> 01:20:34.560
So there's two directions.

01:20:34.560 --> 01:20:37.580
So in all, there's degree
6 for every vertex, right?

01:20:37.580 --> 01:20:43.030
There's sis different ways
in or out of a vertex here.

01:20:43.030 --> 01:20:44.530
OK, so the next
part of the problem

01:20:44.530 --> 01:20:48.430
gives you a piece of code and
then does breadth-first search

01:20:48.430 --> 01:20:50.950
on this graph.

01:20:50.950 --> 01:20:52.870
And it's super,
super slow to give me

01:20:52.870 --> 01:20:55.690
the distance to all the
other configurations.

01:20:55.690 --> 01:20:59.320
And Jason conveniently has
run it on his laptop here.

01:20:59.320 --> 01:21:02.580
I don't-- I'm nervous
to touch your laptop.

01:21:02.580 --> 01:21:04.750
I don't care so
much, but I don't--

01:21:04.750 --> 01:21:06.440
you know, I don't
want to infect your--

01:21:06.440 --> 01:21:06.940
yeah.

01:21:09.460 --> 01:21:10.030
Right.

01:21:10.030 --> 01:21:12.490
So we have a piece
of code that explores

01:21:12.490 --> 01:21:15.320
the graph of all the
configurations of our cube

01:21:15.320 --> 01:21:18.490
by breadth-first search and then
sort of gives me the shortest

01:21:18.490 --> 01:21:20.885
path, I think from
the base cube,

01:21:20.885 --> 01:21:22.510
where all the faces
are constant to all

01:21:22.510 --> 01:21:24.970
the other configurations
that are reachable,

01:21:24.970 --> 01:21:28.400
and generates a plot.

01:21:28.400 --> 01:21:29.050
Right.

01:21:29.050 --> 01:21:32.290
And so what they
ask is to figure out

01:21:32.290 --> 01:21:33.760
the total number
of configurations

01:21:33.760 --> 01:21:35.127
that it explores.

01:21:35.127 --> 01:21:36.460
One thing that you'll find out--

01:21:39.330 --> 01:21:45.030
center down-- is that it
explores pretty much a third--

01:21:45.030 --> 01:21:47.880
in fact, exactly a third of
all the possible configurations

01:21:47.880 --> 01:21:48.795
of my cube.

01:21:48.795 --> 01:21:52.450
I think we can see that here.

01:21:52.450 --> 01:21:54.030
So I guess it runs
this whole thing.

01:21:54.030 --> 01:21:56.580
You saw them all together.

01:21:56.580 --> 01:21:57.420
Right.

01:21:57.420 --> 01:21:57.920
Oops.

01:22:02.280 --> 01:22:03.450
That's OK.

01:22:03.450 --> 01:22:06.300
And so in fact, the kind of fun
fact that you can learn about

01:22:06.300 --> 01:22:10.710
the 2-by-2-by-2 Rubik's cube
is that there's actually three

01:22:10.710 --> 01:22:13.090
connected components
in this graph.

01:22:13.090 --> 01:22:15.240
So in other words,
there's sort of like three

01:22:15.240 --> 01:22:18.150
different Rubik's cubes you can
make, modulo all the different

01:22:18.150 --> 01:22:21.000
flips that you can
do to the faces.

01:22:21.000 --> 01:22:23.550
And those correspond to
there corner rotations of one

01:22:23.550 --> 01:22:26.010
of the corners of the thing.

01:22:26.010 --> 01:22:30.570
OK, so right.

01:22:30.570 --> 01:22:32.900
So then the next
part of the problem

01:22:32.900 --> 01:22:35.420
asks you to state the maximum
number of moves needed

01:22:35.420 --> 01:22:37.067
to solve any Rubik's cube.

01:22:37.067 --> 01:22:38.400
And you can see it in this plot.

01:22:38.400 --> 01:22:40.370
So what this plot is
showing you is the size

01:22:40.370 --> 01:22:43.010
of the level set
of this distance

01:22:43.010 --> 01:22:44.970
function for every distance.

01:22:44.970 --> 01:22:47.840
So I think technically,
it looks like 0.

01:22:47.840 --> 01:22:49.580
But there's actually,
this is at a 1

01:22:49.580 --> 01:22:52.970
here, which is to say there's
one vertex at distance 0, which

01:22:52.970 --> 01:22:54.380
is the source.

01:22:54.380 --> 01:22:56.360
And as we move farther
and farther out,

01:22:56.360 --> 01:22:57.303
our tree is expanding.

01:22:57.303 --> 01:22:58.970
And we're seeing more
and more vertices.

01:22:58.970 --> 01:23:02.240
And apparently, most vertices
are approximately distance--

01:23:02.240 --> 01:23:04.010
is that 11 or 12?

01:23:04.010 --> 01:23:06.480
11 away from the original.

01:23:06.480 --> 01:23:09.140
Then eventually I explore the
entire graph, and I'm done.

01:23:09.140 --> 01:23:12.770
And you can see that the
farthest-away vertex is 14

01:23:12.770 --> 01:23:16.940
away, meaning that the most
annoying Rubik's cube to solve

01:23:16.940 --> 01:23:22.400
can be solved in 14 steps for
the 2-by-2-by-2 pocket cube.

01:23:22.400 --> 01:23:25.520
I'm sure that Jason probably
knows the equivalent of this

01:23:25.520 --> 01:23:26.840
number for the 3-by-3-by-3.

01:23:26.840 --> 01:23:29.148
But I have no idea what it is.

01:23:29.148 --> 01:23:31.190
I'm impressed if he can
calculate it in his head,

01:23:31.190 --> 01:23:33.460
like he looked like
he was about to try.

01:23:33.460 --> 01:23:35.490
But I digress.

01:23:35.490 --> 01:23:35.990
Right.

01:23:35.990 --> 01:23:40.323
So in other words, this is
actually a fancy term for--

01:23:40.323 --> 01:23:41.990
we talked about the
radius of your graph

01:23:41.990 --> 01:23:42.865
in the first problem.

01:23:42.865 --> 01:23:45.830
Now we've got the
diameter, which is, well,

01:23:45.830 --> 01:23:47.400
not necessarily 2
times the radius,

01:23:47.400 --> 01:23:51.980
the way that we've defined it
here, but actually, almost--

01:23:51.980 --> 01:23:55.150
I think within some
constant of that.

01:23:55.150 --> 01:23:58.100
OK, so right.

01:23:58.100 --> 01:24:01.610
So notice that the vertical
axis here is really big.

01:24:01.610 --> 01:24:04.310
And this is explaining why this
BFS code is so slow, right?

01:24:04.310 --> 01:24:06.440
Because these are all the
different configurations

01:24:06.440 --> 01:24:07.670
it has to hit.

01:24:07.670 --> 01:24:10.620
Or more accurately, if
I take the y-position

01:24:10.620 --> 01:24:13.610
of each one of these vertices
and sum up its height,

01:24:13.610 --> 01:24:16.220
those are all the configurations
that are reachable.

01:24:16.220 --> 01:24:19.040
And those are all the steps
that BFS needs before it's done.

01:24:19.040 --> 01:24:22.700
And so that number is in the--

01:24:22.700 --> 01:24:25.760
it's certainly in
the millions, yeah.

01:24:25.760 --> 01:24:27.830
OK, so then the last
part of this problem,

01:24:27.830 --> 01:24:31.160
which it conveniently looks
like I'm low on time to solve,

01:24:31.160 --> 01:24:34.010
but I'll refer you to
the solution anyway,

01:24:34.010 --> 01:24:37.520
is asking how we
might do this faster.

01:24:37.520 --> 01:24:41.130
And so in particular,
what it says is,

01:24:41.130 --> 01:24:44.850
let's say that I have a total of
n configurations for my Rubik's

01:24:44.850 --> 01:24:45.350
cube.

01:24:45.350 --> 01:24:47.330
In this case, it
turns out that that's

01:24:47.330 --> 01:24:49.720
like roughly three
million, I think.

01:24:49.720 --> 01:24:50.510
OK.

01:24:50.510 --> 01:24:54.860
And now I want an
algorithm that gives me

01:24:54.860 --> 01:25:00.410
the shortest sequence of moves
to solve any pocket cube.

01:25:00.410 --> 01:25:04.430
Man, I'm really ravaging
the chalk today.

01:25:04.430 --> 01:25:08.660
And I want to solve any
cube in a number of steps

01:25:08.660 --> 01:25:17.950
that looks like 2N to the
ceiling of w over 2, where--

01:25:23.660 --> 01:25:24.890
let's see here.

01:25:24.890 --> 01:25:26.540
The code provided--
sorry, this problem

01:25:26.540 --> 01:25:28.252
changed on me this afternoon.

01:25:28.252 --> 01:25:30.530
[LAUGHS] Right.

01:25:30.530 --> 01:25:36.710
So where N sub i is equal to
the number of configurations

01:25:36.710 --> 01:25:38.940
reachable within i moves.

01:25:38.940 --> 01:25:39.440
Oh, good.

01:25:39.440 --> 01:25:40.398
I see what we did here.

01:25:46.840 --> 01:25:50.075
So if this is my base cube,
then we've got like maybe,

01:25:50.075 --> 01:25:52.250
I guess, six different--

01:25:52.250 --> 01:25:56.388
1, 2, 3, 4, 5, 6 different cubes
that I can reach from those.

01:25:56.388 --> 01:25:58.680
And then there's 6 cubes I
can reach from all of those.

01:25:58.680 --> 01:26:00.597
But of course, some of
those might be pointing

01:26:00.597 --> 01:26:03.290
backward or to each other.

01:26:03.290 --> 01:26:06.020
But this is the number of things
that are reachable in i moves.

01:26:06.020 --> 01:26:08.330
And they ask for an algorithm
that finds the shortest

01:26:08.330 --> 01:26:10.910
path in this amount of time.

01:26:10.910 --> 01:26:13.880
By the way, big N typically
exponentiates in that subscript

01:26:13.880 --> 01:26:14.800
there.

01:26:14.800 --> 01:26:17.870
This looks innocent,
but it's not.

01:26:17.870 --> 01:26:20.413
The basic trick here is to do--

01:26:20.413 --> 01:26:22.080
I'm not going to
bother writing it down.

01:26:22.080 --> 01:26:24.663
We'll just talk about it for a
second and call it for the day.

01:26:24.663 --> 01:26:26.620
Well, I'll draw a picture.

01:26:26.620 --> 01:26:28.680
So the breadth-first
search algorithm

01:26:28.680 --> 01:26:31.420
that we've thought about
so far chooses a vertex

01:26:31.420 --> 01:26:35.790
and then computes level sets
outward from that vertex

01:26:35.790 --> 01:26:39.570
until it maybe reaches
the destination that you

01:26:39.570 --> 01:26:41.602
want to hit.

01:26:41.602 --> 01:26:42.810
That doesn't quite work here.

01:26:42.810 --> 01:26:44.130
And the-- well, I
mean, it does work.

01:26:44.130 --> 01:26:46.140
But it's going to be
quite slow, because like,

01:26:46.140 --> 01:26:49.390
let's say I had bad luck, and
now we're in that 14 vertex,

01:26:49.390 --> 01:26:49.890
right?

01:26:49.890 --> 01:26:51.348
Then, somewhere in
there, I'm going

01:26:51.348 --> 01:26:55.410
to hit this big height,
which is sitting over the 11,

01:26:55.410 --> 01:26:59.070
before I can get to vertex 14.

01:26:59.070 --> 01:27:01.110
So the trick here
is it turns out

01:27:01.110 --> 01:27:04.050
that I can do it by
only ever getting to 7.

01:27:04.050 --> 01:27:08.470
And the way that I'm going
to do that is instead,

01:27:08.470 --> 01:27:10.997
I'm going to run BFS sort
of in parallel for two

01:27:10.997 --> 01:27:12.080
different vertices, right?

01:27:12.080 --> 01:27:13.163
The source and the target.

01:27:13.163 --> 01:27:15.850
So in this case, my
current cube and the cube

01:27:15.850 --> 01:27:18.340
I would like it to be, like
the solution to the problem.

01:27:18.340 --> 01:27:21.690
I'm first going to compute
the level set 1 of that cube,

01:27:21.690 --> 01:27:24.820
then level set 1 of the
next cube, then level set 2,

01:27:24.820 --> 01:27:26.950
level set 2, 3, 4.

01:27:26.950 --> 01:27:28.630
And notice that
eventually, they're

01:27:28.630 --> 01:27:32.320
going to intersect, pretty
much right at the midpoint.

01:27:32.320 --> 01:27:34.140
And so the size
of the level set--

01:27:34.140 --> 01:27:35.890
I never need to compute
a level set that's

01:27:35.890 --> 01:27:38.850
bigger than a half of
the shortest path length.

01:27:38.850 --> 01:27:41.530
I have to round up to be
conservative about that.

01:27:41.530 --> 01:27:43.203
And that's where I
get this factor here.

01:27:43.203 --> 01:27:44.620
So that's just a
nice little trick

01:27:44.620 --> 01:27:46.697
for reducing the search size.

01:27:46.697 --> 01:27:48.280
This is another kind
of standard trick

01:27:48.280 --> 01:27:50.530
if you look at some
of the code people use

01:27:50.530 --> 01:27:52.930
for solving board games
algorithmically and so on.

01:27:52.930 --> 01:27:55.690
I think they typically sort
of search from the beginning

01:27:55.690 --> 01:27:58.900
and end state outward and
try and meet in the middle

01:27:58.900 --> 01:28:00.370
for exactly this
reason, which is

01:28:00.370 --> 01:28:03.470
that exponential
growth, as we all know,

01:28:03.470 --> 01:28:05.752
can be quite problematic.

01:28:05.752 --> 01:28:06.460
All right, folks.

01:28:06.460 --> 01:28:08.127
So I think we're just
about out of time.

01:28:08.127 --> 01:28:10.150
And I've certainly
worn myself out.

01:28:10.150 --> 01:28:12.580
So with that, hopefully
we'll see you next week.

01:28:12.580 --> 01:28:15.900
And yeah, I hope
everybody is doing well.