WEBVTT

00:00:05.892 --> 00:00:21.947
[MUSIC PLAYING]

00:00:21.947 --> 00:00:23.530
PROFESSOR: Well, so
far in this course

00:00:23.530 --> 00:00:26.370
we've been talking
about procedures,

00:00:26.370 --> 00:00:29.132
and then just to remind
you of this framework

00:00:29.132 --> 00:00:31.090
that we introduced for
talking about languages,

00:00:31.090 --> 00:00:33.860
we talked about the
primitive things that

00:00:33.860 --> 00:00:36.040
are built into the system.

00:00:36.040 --> 00:00:38.947
We mentioned some
means of combination

00:00:38.947 --> 00:00:40.530
by which you take
the primitive things

00:00:40.530 --> 00:00:42.327
and you make more
complicated things.

00:00:42.327 --> 00:00:44.410
And then we talked about
the means of abstraction,

00:00:44.410 --> 00:00:46.118
how you can take those
complicated things

00:00:46.118 --> 00:00:49.584
and name them so you can use
them as simple building blocks.

00:00:49.584 --> 00:00:51.750
And then last time you saw
we went even beyond that.

00:00:51.750 --> 00:00:55.570
We saw that by using
higher order procedures,

00:00:55.570 --> 00:00:58.400
you can actually express general
methods for computing things.

00:00:58.400 --> 00:01:00.150
Like the method
of doing something

00:01:00.150 --> 00:01:03.700
by fixed points, or
Newton's method, and so

00:01:03.700 --> 00:01:05.420
the incredible
expressive power you

00:01:05.420 --> 00:01:08.730
can get just by combining
these means of abstraction.

00:01:08.730 --> 00:01:11.400
And the crucial
idea in all of this

00:01:11.400 --> 00:01:15.210
is the one that we
build a layered system.

00:01:15.210 --> 00:01:17.570
So for instance, if we're
writing the square root

00:01:17.570 --> 00:01:23.080
procedure, somewhere the
square root procedure

00:01:23.080 --> 00:01:31.490
uses a procedure
called good-enough,

00:01:31.490 --> 00:01:35.220
and between those there is some
sort of abstraction boundary.

00:01:38.060 --> 00:01:41.450
It's almost as if we go out
and in writing square root,

00:01:41.450 --> 00:01:45.120
we go and make a
contract with George,

00:01:45.120 --> 00:01:49.060
and tell George that his
job is to write good-enough,

00:01:49.060 --> 00:01:50.660
and so long as
good-enough works,

00:01:50.660 --> 00:01:52.589
we don't care what it does.

00:01:52.589 --> 00:01:54.380
We don't care exactly
how it's implemented.

00:01:54.380 --> 00:01:56.770
There are levels of
detail here that are

00:01:56.770 --> 00:02:00.450
George's concern and not ours.

00:02:00.450 --> 00:02:04.350
So for instance, George might
use an absolute value procedure

00:02:04.350 --> 00:02:07.820
that's written by Harry, and
we don't much care about that

00:02:07.820 --> 00:02:10.065
or even know that,
maybe, Harry exists.

00:02:13.830 --> 00:02:16.760
So the crucial idea is that
when we're building things,

00:02:16.760 --> 00:02:21.530
we divorce the task
of building things

00:02:21.530 --> 00:02:23.850
from the task of
implementing the parts.

00:02:27.690 --> 00:02:29.090
And in a large
system, of course,

00:02:29.090 --> 00:02:32.210
we have abstraction barriers
like this at lots, and lots,

00:02:32.210 --> 00:02:34.180
and lots of levels.

00:02:34.180 --> 00:02:36.960
And that's the idea that we've
been using so far over and over

00:02:36.960 --> 00:02:38.290
in implementing procedures.

00:02:38.290 --> 00:02:41.080
Well, now what we're
going to do is look

00:02:41.080 --> 00:02:44.101
at the same issues for data.

00:02:44.101 --> 00:02:46.350
We're going to see that the
system has primitive data.

00:02:46.350 --> 00:02:47.724
In fact, we've
already seen that.

00:02:47.724 --> 00:02:49.750
We've talked about
numbers as primitive data.

00:02:49.750 --> 00:02:52.000
And then we're going to see
their means of combination

00:02:52.000 --> 00:02:52.499
for data.

00:02:52.499 --> 00:02:55.940
There's glue that allows you
to put primitive data together

00:02:55.940 --> 00:02:59.500
to make more complicated,
kind of compound data.

00:02:59.500 --> 00:03:04.840
And then we're going to see
a methodology for abstraction

00:03:04.840 --> 00:03:07.600
that's a very good thing to use
when you start building up data

00:03:07.600 --> 00:03:09.090
in terms of simpler data.

00:03:09.090 --> 00:03:11.260
And again, the key
idea is that you're

00:03:11.260 --> 00:03:13.770
going to build the
system in layers

00:03:13.770 --> 00:03:15.700
and set up abstraction
barriers that

00:03:15.700 --> 00:03:19.506
isolate the details
at the lower layers

00:03:19.506 --> 00:03:21.630
from the thing that's going
on at the upper layers.

00:03:21.630 --> 00:03:25.260
The details at the lower layers,
the ideas, they won't matter.

00:03:25.260 --> 00:03:26.850
They're going to
be George's concern

00:03:26.850 --> 00:03:29.170
because he signed this
contract with us for how

00:03:29.170 --> 00:03:32.030
the stuff that he
implements behaves,

00:03:32.030 --> 00:03:36.182
and how he implements
the thing is his problem.

00:03:36.182 --> 00:03:37.890
All right, well let's
look at an example.

00:03:37.890 --> 00:03:39.890
And the example I'm
going to talk about

00:03:39.890 --> 00:03:43.010
is a system that does
arithmetic on rational numbers.

00:03:43.010 --> 00:03:46.160
And what I have in mind is
that we should have something

00:03:46.160 --> 00:03:51.870
in the computer that
allows us to ask it, like,

00:03:51.870 --> 00:03:56.880
what's the sum of 1/2 and
1/4, and somehow the system

00:03:56.880 --> 00:04:02.890
should say, yeah, that's 3/4.

00:04:02.890 --> 00:04:11.070
Or we should be able to
say what's 3/4 times 2/3,

00:04:11.070 --> 00:04:13.650
and the system should be able
to say, yeah, that's 1/2.

00:04:16.230 --> 00:04:16.730
Right?

00:04:16.730 --> 00:04:18.104
And you know what
I have in mind.

00:04:18.104 --> 00:04:20.459
And you also know how to
do this from, I don't know,

00:04:20.459 --> 00:04:22.410
fifth grade or sixth grade.

00:04:22.410 --> 00:04:23.910
There are these
formulas that say

00:04:23.910 --> 00:04:28.530
if I have some fraction which is
a numerator over a denominator,

00:04:28.530 --> 00:04:31.940
and I want to add that to
some other fraction which

00:04:31.940 --> 00:04:35.470
is another numerator
over another denominator,

00:04:35.470 --> 00:04:39.810
then the answer is the
numerator of the first times

00:04:39.810 --> 00:04:43.710
the denominator of the
second, plus the numerator

00:04:43.710 --> 00:04:48.130
of the second times the
denominator of the first.

00:04:48.130 --> 00:04:49.840
That's the numerator
of the answer,

00:04:49.840 --> 00:04:52.090
and the denominator
is the product

00:04:52.090 --> 00:04:53.260
of the two denominators.

00:04:53.260 --> 00:04:53.760
Right?

00:04:53.760 --> 00:04:56.850
So there's something from
fifth or sixth grade fraction

00:04:56.850 --> 00:04:57.570
arithmetic.

00:04:57.570 --> 00:04:59.950
And then similarly, if I
want to multiply two things,

00:04:59.950 --> 00:05:05.890
n1 over d1 multiplied
by n2 over d2

00:05:05.890 --> 00:05:09.677
is the product of the
numerators over the product

00:05:09.677 --> 00:05:10.510
of the denominators.

00:05:14.330 --> 00:05:17.960
So it's no problem at all,
but it's absolutely no problem

00:05:17.960 --> 00:05:20.520
to think about what
computation you

00:05:20.520 --> 00:05:23.760
want to make in adding and
multiplying these fractions.

00:05:23.760 --> 00:05:25.880
But as soon as we
go to implement it,

00:05:25.880 --> 00:05:27.920
we run up across something.

00:05:27.920 --> 00:05:33.320
We don't have what a
rational number is.

00:05:33.320 --> 00:05:36.840
So we said that the system
gives us individual numbers,

00:05:36.840 --> 00:05:42.110
so we can have 5 and
3, but somehow we

00:05:42.110 --> 00:05:44.140
don't have a way
of saying there's

00:05:44.140 --> 00:05:49.850
a thing that has both a 3 and
a 4 in it, or both a 2 and a 3.

00:05:49.850 --> 00:05:54.980
It's almost as if we'd like
to imagine that somehow there

00:05:54.980 --> 00:05:59.010
are these clouds,
and a cloud somehow

00:05:59.010 --> 00:06:02.274
has both a numerator
and a denominator in it,

00:06:02.274 --> 00:06:04.190
and that's what we'd
like to work in terms of.

00:06:06.445 --> 00:06:08.320
Well, how are we going
to solve that problem?

00:06:08.320 --> 00:06:09.720
We're going to
solve that problem

00:06:09.720 --> 00:06:12.770
by using this incredibly
powerful design

00:06:12.770 --> 00:06:16.497
strategy that you've already
seen us use over and over.

00:06:16.497 --> 00:06:18.330
And that's the strategy
of wishful thinking.

00:06:25.624 --> 00:06:28.040
Just like before when we didn't
have a procedure, we said,

00:06:28.040 --> 00:06:31.420
well, let's imagine that that
procedure already exists.

00:06:31.420 --> 00:06:36.100
We'll say, well, let's imagine
that we have these clouds.

00:06:36.100 --> 00:06:39.250
Now more precisely
what I mean is

00:06:39.250 --> 00:06:44.287
let's imagine that we
have three procedures,

00:06:44.287 --> 00:06:45.120
one called make-RAT.

00:06:47.740 --> 00:06:54.530
make-RAT is going to take
as arguments two numbers,

00:06:54.530 --> 00:06:57.990
so I'll call them
numerator and denominator,

00:06:57.990 --> 00:07:05.300
and it'll return for us a
cloud-- one of these clouds.

00:07:05.300 --> 00:07:07.030
I don't really know
what a cloud is.

00:07:07.030 --> 00:07:11.160
It's whatever make-RAT
returns, that's its business.

00:07:11.160 --> 00:07:12.660
And then we're going
to say, suppose

00:07:12.660 --> 00:07:15.310
we've got one of these clouds,
we have a procedure called

00:07:15.310 --> 00:07:20.260
numer, which takes in a cloud
that has an n and a d in it,

00:07:20.260 --> 00:07:23.690
whatever a cloud is, and I don't
know what it is, and returns

00:07:23.690 --> 00:07:26.980
for us the numerator part.

00:07:26.980 --> 00:07:31.250
And then we'll assume we
have a procedure denom,

00:07:31.250 --> 00:07:33.025
which again takes
in a cloud, whatever

00:07:33.025 --> 00:07:37.850
a cloud is, and returns for us
the denominator [? required. ?]

00:07:37.850 --> 00:07:40.710
This is just like
before, when if we're

00:07:40.710 --> 00:07:43.230
building a square
root, we assume

00:07:43.230 --> 00:07:45.101
that we have good enough.

00:07:45.101 --> 00:07:45.600
Right?

00:07:45.600 --> 00:07:47.649
And what we'll say is,
we'll go find George,

00:07:47.649 --> 00:07:49.690
and we'll say to George,
well, it's your business

00:07:49.690 --> 00:07:52.135
to make us these procedures.

00:07:52.135 --> 00:07:54.010
And how you choose to
implement these clouds,

00:07:54.010 --> 00:07:54.884
that's your problem.

00:07:54.884 --> 00:07:55.800
We don't want to know.

00:07:58.670 --> 00:08:03.340
Well, having pushed this
task off onto George,

00:08:03.340 --> 00:08:05.520
then it's pretty easy
to do the other part.

00:08:05.520 --> 00:08:07.950
Once we've got the
clouds, it's pretty easy

00:08:07.950 --> 00:08:11.820
to write the thing that does say
addition of rational numbers.

00:08:11.820 --> 00:08:17.820
You can just say define,
well, let's say +RAT.

00:08:21.980 --> 00:08:28.110
Define +RAT, which will take in
two rational numbers, x and y.

00:08:28.110 --> 00:08:31.706
x and y are each these clouds.

00:08:31.706 --> 00:08:32.539
And what does it do?

00:08:32.539 --> 00:08:35.840
Well, it's going to return
for us a rational number.

00:08:40.299 --> 00:08:41.460
What rational number is it?

00:08:41.460 --> 00:08:43.659
Well, we've got
the formulas there.

00:08:43.659 --> 00:08:52.180
The numerator of it is the sum
of the product of the numerator

00:08:52.180 --> 00:08:56.550
of x and the denominator of y.

00:09:02.580 --> 00:09:03.950
It's one thing in the sum.

00:09:03.950 --> 00:09:06.240
And the other thing
in the numerator

00:09:06.240 --> 00:09:19.060
is the product of the numerator
of y and the denominator of x.

00:09:19.060 --> 00:09:20.910
The star, close the plus.

00:09:20.910 --> 00:09:23.580
Right, that's the first
argument to make-RAT,

00:09:23.580 --> 00:09:26.080
which is the numerator of
the thing I'm constructing.

00:09:26.080 --> 00:09:28.050
And then the rest
of the thing goes

00:09:28.050 --> 00:09:30.940
into make-RAT is the
denominator of the answer, which

00:09:30.940 --> 00:09:37.210
is the product of
the denominator of x

00:09:37.210 --> 00:09:42.050
and the denominator of y.

00:09:42.050 --> 00:09:42.550
Like that.

00:09:46.001 --> 00:09:46.500
OK?

00:09:46.500 --> 00:09:51.710
So there is the analog of
doing rational number addition.

00:09:51.710 --> 00:09:53.732
And it's no problem
at all, assuming

00:09:53.732 --> 00:09:54.815
that we have these clouds.

00:09:59.020 --> 00:10:02.250
And of course, we can do
multiplication in the same way.

00:10:05.570 --> 00:10:11.160
Define how to get the product
of two rational numbers,

00:10:11.160 --> 00:10:13.080
call it *RAT.

00:10:13.080 --> 00:10:20.420
Takes in two of these
clouds, x and y, it returns

00:10:20.420 --> 00:10:25.450
a rational number,
make-RAT, whose numerator

00:10:25.450 --> 00:10:32.020
is the product of the
numerators-- numerator of x

00:10:32.020 --> 00:10:38.170
times the numerator of y.

00:10:38.170 --> 00:10:41.387
And the denominator of the
thing it's going to return

00:10:41.387 --> 00:10:42.845
is the product of
the denominators.

00:10:57.930 --> 00:11:02.630
Well, except that I haven't
told you what these clouds are,

00:11:02.630 --> 00:11:04.489
that's all there is to it.

00:11:04.489 --> 00:11:05.280
See, what did I do?

00:11:05.280 --> 00:11:08.210
I assumed by wishful
thinking that I

00:11:08.210 --> 00:11:10.490
had a new kind of data object.

00:11:10.490 --> 00:11:13.950
And in particular,
I assumed I had ways

00:11:13.950 --> 00:11:16.360
of creating these data objects.

00:11:16.360 --> 00:11:18.140
Make-RAT creates
one of these things.

00:11:18.140 --> 00:11:19.348
This is called a constructor.

00:11:25.720 --> 00:11:29.750
All right, I have a thing that
constructs such data objects.

00:11:29.750 --> 00:11:34.399
And then I assume I have things
that, having made these things,

00:11:34.399 --> 00:11:35.940
I have ways of
getting the parts out.

00:11:35.940 --> 00:11:37.550
Those are called selectors.

00:11:42.850 --> 00:11:44.900
And so formally, what
I said is I assumed

00:11:44.900 --> 00:11:47.270
I had procedures
that are constructors

00:11:47.270 --> 00:11:49.160
and selectors for
these data objects,

00:11:49.160 --> 00:11:52.090
and then I went
off and used them.

00:11:52.090 --> 00:11:54.180
That's no different
in kind from saying

00:11:54.180 --> 00:11:56.380
I assume I have a
procedure good-enough,

00:11:56.380 --> 00:11:58.335
and I go use it to
implement square root.

00:12:00.850 --> 00:12:05.250
OK, well before we
go on, let's ask

00:12:05.250 --> 00:12:08.660
the question of why do we want
to do this in the first place?

00:12:08.660 --> 00:12:16.340
See, why do we want a procedure
like +RAT that takes in two

00:12:16.340 --> 00:12:20.044
rational numbers and
returns a rational number?

00:12:20.044 --> 00:12:21.960
See, another way to think
about this is, well,

00:12:21.960 --> 00:12:22.793
here's this formula.

00:12:25.160 --> 00:12:27.740
And I've also got to
implement something

00:12:27.740 --> 00:12:29.824
that adds rational numbers.

00:12:29.824 --> 00:12:32.240
One other way to think about
is, well, there's this thing,

00:12:32.240 --> 00:12:34.750
and I type in four
numbers, an n1, and a d1,

00:12:34.750 --> 00:12:36.600
and an n2, and a d2.

00:12:36.600 --> 00:12:38.510
And it sets some
registers in the machine

00:12:38.510 --> 00:12:42.255
to this numerator
and this denominator.

00:12:42.255 --> 00:12:43.630
So I might say,
well, why don't I

00:12:43.630 --> 00:12:45.470
just add rational
numbers by I type in four

00:12:45.470 --> 00:12:47.220
numbers, numerators
and denominators,

00:12:47.220 --> 00:12:48.595
and get out two
numbers, which is

00:12:48.595 --> 00:12:51.000
a numerator and a denominator.

00:12:51.000 --> 00:12:54.250
Why are we worrying
about building things

00:12:54.250 --> 00:12:55.100
like this anyway?

00:12:58.620 --> 00:13:00.820
Well, the answer
is, suppose you want

00:13:00.820 --> 00:13:06.090
to think about expressing
something like this,

00:13:06.090 --> 00:13:10.900
suppose I'd like to
express the idea of taking

00:13:10.900 --> 00:13:15.300
two rational numbers,
x plus y, say,

00:13:15.300 --> 00:13:23.670
and multiplying that by the sum
of two other rational numbers.

00:13:23.670 --> 00:13:28.266
Well, the way I do it, having
things like +RAT and *RAT,

00:13:28.266 --> 00:13:33.930
is I'd say, oh yeah, what
that is is just the product.

00:13:33.930 --> 00:13:51.570
That's *RAT of the sum of x
and y and the sum of s and t.

00:13:51.570 --> 00:13:55.940
So except for syntax,
I get an expression

00:13:55.940 --> 00:13:58.380
that looks like the
way I want to think

00:13:58.380 --> 00:13:59.490
about it mathematically.

00:13:59.490 --> 00:14:02.080
I want to say there
are two numbers.

00:14:02.080 --> 00:14:05.407
There's a thing which
is the sum of them,

00:14:05.407 --> 00:14:07.490
and there's a thing which
is the sum of these two.

00:14:07.490 --> 00:14:10.780
That's this and this.

00:14:10.780 --> 00:14:12.474
And then I multiply them.

00:14:12.474 --> 00:14:14.640
So I get an expression that
matches this expression.

00:14:14.640 --> 00:14:16.600
If I did the other
thing, if I said,

00:14:16.600 --> 00:14:18.450
well, the way I want
to think about this

00:14:18.450 --> 00:14:20.950
is I type into my machine
four numbers, which

00:14:20.950 --> 00:14:24.140
are the numerators and the
denominators of x and y,

00:14:24.140 --> 00:14:26.440
and then four more numbers,
which are the numerators

00:14:26.440 --> 00:14:28.841
and denominators of s and t.

00:14:28.841 --> 00:14:31.340
And then what I'd be sitting
with is, well, what would I do?

00:14:31.340 --> 00:14:33.280
I'd add these, and
somehow I'd have

00:14:33.280 --> 00:14:36.440
to have two temporary variables,
which are the numerators

00:14:36.440 --> 00:14:38.377
and denominators of
this sum, and I'd

00:14:38.377 --> 00:14:39.710
go off and store them someplace.

00:14:42.235 --> 00:14:44.610
And then I'd go over here,
I'd type in four more numbers,

00:14:44.610 --> 00:14:46.720
I'd get two more
temporary variables,

00:14:46.720 --> 00:14:50.180
which are the numerators
and denominators of s and t.

00:14:50.180 --> 00:14:54.962
And then finally, I put those
together by multiplying them.

00:14:54.962 --> 00:14:56.420
You see, what's
starting to happen,

00:14:56.420 --> 00:14:58.830
there are all these
temporary variables, which

00:14:58.830 --> 00:15:02.060
are sort of the guts
of the internals

00:15:02.060 --> 00:15:04.180
of these rational numbers
that start hanging

00:15:04.180 --> 00:15:05.997
out all over the system.

00:15:05.997 --> 00:15:08.580
And of course, if I had more and
more complicated expressions,

00:15:08.580 --> 00:15:10.288
there'd be more and
more guts hanging out

00:15:10.288 --> 00:15:13.010
that confuse my programming.

00:15:13.010 --> 00:15:15.340
And those of you who
sort of programmed things

00:15:15.340 --> 00:15:17.794
like that, where you're just
adding numbers in assembly

00:15:17.794 --> 00:15:19.210
language, you sort
of see you have

00:15:19.210 --> 00:15:23.040
to suddenly be concerned with
these temporary variables.

00:15:23.040 --> 00:15:28.350
But more importantly than
confusing my programming,

00:15:28.350 --> 00:15:29.760
they're going to
confuse my mind.

00:15:29.760 --> 00:15:33.440
Because the whole
name of this game

00:15:33.440 --> 00:15:37.740
is that we'd like the
programming language to express

00:15:37.740 --> 00:15:39.670
the concepts that we
have in our heads,

00:15:39.670 --> 00:15:43.510
like rational numbers are things
that you can add and then take

00:15:43.510 --> 00:15:44.770
that result and multiply them.

00:15:48.587 --> 00:15:49.670
Let's break for questions.

00:15:59.570 --> 00:16:00.080
Yeah?

00:16:00.080 --> 00:16:02.127
AUDIENCE: I don't
quite see the need-

00:16:02.127 --> 00:16:04.460
when we had make-RAT with the
numerator and denominator,

00:16:04.460 --> 00:16:06.626
we had to have the numerator
and denominator to pass

00:16:06.626 --> 00:16:08.677
as parameters to
create the cloud,

00:16:08.677 --> 00:16:10.885
and then we extracted to
get back what we had to have

00:16:10.885 --> 00:16:11.720
originally.

00:16:11.720 --> 00:16:13.740
PROFESSOR: That's right.

00:16:13.740 --> 00:16:15.770
So the question
is, I sort of have

00:16:15.770 --> 00:16:17.370
the numerator and
the denominator,

00:16:17.370 --> 00:16:20.890
why am I worrying about
having the cloud given that I

00:16:20.890 --> 00:16:23.500
have to get the pieces out?

00:16:23.500 --> 00:16:25.490
That's sort of what I
tried to say at the end,

00:16:25.490 --> 00:16:27.740
but let me try and say it
again, because that's really

00:16:27.740 --> 00:16:29.390
the crucial question.

00:16:29.390 --> 00:16:32.540
The point is, I want to carry
this numerator and denominator

00:16:32.540 --> 00:16:36.816
around together all the time.

00:16:36.816 --> 00:16:38.716
And it's almost as
if I want to know,

00:16:38.716 --> 00:16:40.840
yeah, there's a numerator
and denominator in there,

00:16:40.840 --> 00:16:47.420
but also, I would like to say,
fine, but from another point

00:16:47.420 --> 00:16:50.180
of view, that's x.

00:16:50.180 --> 00:16:53.040
And I carry x around, and I
name it as x, and I hold it.

00:16:53.040 --> 00:16:55.897
And I can say things
like, the sum of x and y,

00:16:55.897 --> 00:16:58.230
rather than just have-- see,
it's not so bad when I only

00:16:58.230 --> 00:17:00.840
think about x, but if
I have a system with 10

00:17:00.840 --> 00:17:03.220
rational numbers, suddenly
I have 20 numerators

00:17:03.220 --> 00:17:05.481
and denominators, which
are not necessarily--

00:17:05.481 --> 00:17:06.980
if I don't link
them, then it's just

00:17:06.980 --> 00:17:09.000
20 arbitrary
numbers that are not

00:17:09.000 --> 00:17:10.560
linked in any particular way.

00:17:10.560 --> 00:17:14.090
It's a lot like saying, well,
I have these instructions

00:17:14.090 --> 00:17:15.589
that are the body
of the procedures,

00:17:15.589 --> 00:17:17.970
why do I want to package them
and say it's the procedure?

00:17:17.970 --> 00:17:19.109
It's exactly the same idea.

00:17:31.875 --> 00:17:33.840
No?

00:17:33.840 --> 00:17:35.120
OK.

00:17:35.120 --> 00:17:38.349
Let's break, let's just stretch
and get somebody-- [INAUDIBLE]

00:17:38.349 --> 00:18:27.080
[MUSIC PLAYING]

00:18:27.080 --> 00:18:30.310
OK, well, we've been working on
this rational number arithmetic

00:18:30.310 --> 00:18:34.730
system, and then what we
did, the important thing

00:18:34.730 --> 00:18:37.310
about what we did, is we
thought about the problem

00:18:37.310 --> 00:18:40.160
by breaking it into two pieces.

00:18:40.160 --> 00:18:43.410
We said, assume there is
this contract with George,

00:18:43.410 --> 00:18:45.230
and George has
figured out the way

00:18:45.230 --> 00:18:47.920
to how to construct
these clouds,

00:18:47.920 --> 00:18:50.690
provided us procedures
make-RAT, which

00:18:50.690 --> 00:18:53.790
was a constructor,
and selectors, which

00:18:53.790 --> 00:18:55.040
are numerator and denominator.

00:18:55.040 --> 00:18:56.623
And then in terms
of that, we went off

00:18:56.623 --> 00:18:58.580
and implemented addition
and multiplication

00:18:58.580 --> 00:19:00.630
of rational numbers.

00:19:00.630 --> 00:19:03.640
Well, now let's go look
at George's problem.

00:19:03.640 --> 00:19:05.660
How can we go and
package together

00:19:05.660 --> 00:19:08.150
a numerator and a
denominator and actually make

00:19:08.150 --> 00:19:09.360
one of these clouds?

00:19:09.360 --> 00:19:15.760
See, what we need is a kind of
glue, a glue for data objects

00:19:15.760 --> 00:19:18.040
that allows us to
put things together.

00:19:18.040 --> 00:19:23.134
And Lisp provides such
a glue, and that glue

00:19:23.134 --> 00:19:24.175
is called list structure.

00:19:30.410 --> 00:19:32.940
List structure is a
way of gluing things

00:19:32.940 --> 00:19:37.690
together, and more
precisely, Lisp

00:19:37.690 --> 00:19:41.540
provides a way of constructing
things called pairs.

00:19:44.750 --> 00:19:52.222
There's a primitive operator
in Lisp called cons.

00:19:52.222 --> 00:19:54.920
We can take a look at it.

00:19:54.920 --> 00:19:57.170
There's a thing called cons.

00:20:00.620 --> 00:20:03.880
Cons is an operator which
takes in two arguments called

00:20:03.880 --> 00:20:08.800
x and y, and it returns for
us a thing called a pair.

00:20:11.510 --> 00:20:17.300
All right, so a thing called
a pair that has a first part

00:20:17.300 --> 00:20:18.100
a second part.

00:20:22.250 --> 00:20:25.450
So cons takes two objects.

00:20:25.450 --> 00:20:26.780
There's a thing called a pair.

00:20:26.780 --> 00:20:31.100
The first part of the cons is x,
and the second part of the cons

00:20:31.100 --> 00:20:31.600
is y.

00:20:31.600 --> 00:20:34.090
And that's what it builds.

00:20:34.090 --> 00:20:36.880
And then we also assume we have
ways of getting things out.

00:20:36.880 --> 00:20:41.820
If you're given a pair,
there's a thing called car,

00:20:41.820 --> 00:20:44.250
and car of a pair,
p, gives you out

00:20:44.250 --> 00:20:46.640
the first part of the pair, p.

00:20:46.640 --> 00:20:49.650
And there's a thing called
cdr, and cdr of the pair, p,

00:20:49.650 --> 00:20:54.310
gives you the second
part of the pair, p.

00:20:54.310 --> 00:20:56.710
OK, so that's how
we construct things.

00:20:56.710 --> 00:21:01.620
There's also a conventional
way of drawing pictures

00:21:01.620 --> 00:21:02.800
of these things.

00:21:02.800 --> 00:21:10.140
Just like we write down that as
the conventional way of writing

00:21:10.140 --> 00:21:16.890
Plato's idea of two,
the way we could

00:21:16.890 --> 00:21:21.510
draw a diagram to represent cons
of two and three is like this.

00:21:21.510 --> 00:21:23.912
We draw a little box.

00:21:23.912 --> 00:21:26.510
And so here's the box
we're talking about,

00:21:26.510 --> 00:21:30.070
and this box has two
arrows coming out of it.

00:21:30.070 --> 00:21:35.180
And say the first part
of this pair is 2,

00:21:35.180 --> 00:21:38.250
and the second part
of this pair is 3.

00:21:38.250 --> 00:21:40.950
And this notation
has a name, it's

00:21:40.950 --> 00:21:44.855
called box and pointer notation.

00:21:55.942 --> 00:21:58.150
By the way, let me say right
now that a lot of people

00:21:58.150 --> 00:22:00.590
get confused that
there's some significance

00:22:00.590 --> 00:22:03.534
to the geometric way I drew
these pointers, the directions.

00:22:03.534 --> 00:22:05.200
Like some people think
it'd be different

00:22:05.200 --> 00:22:07.650
if I took this pointer
and turned it up here,

00:22:07.650 --> 00:22:08.660
and put the 3 out here.

00:22:08.660 --> 00:22:10.440
That has no significance.

00:22:10.440 --> 00:22:10.940
All right?

00:22:10.940 --> 00:22:13.040
It's merely you have
a bunch of arrows,

00:22:13.040 --> 00:22:15.090
these pointers, and the boxes.

00:22:15.090 --> 00:22:17.390
The only issue is how
they're connected,

00:22:17.390 --> 00:22:19.720
not the geometric
arrangement of whether I

00:22:19.720 --> 00:22:23.160
write the pointer
across, or up, or down.

00:22:23.160 --> 00:22:26.490
Now it's completely
un-obvious, probably,

00:22:26.490 --> 00:22:28.337
why that's called
list structure.

00:22:28.337 --> 00:22:30.420
We're not actually going
to talk about that today.

00:22:30.420 --> 00:22:31.850
We'll see that next time.

00:22:37.870 --> 00:22:41.740
So those are pairs, there's
cons that constructs them.

00:22:41.740 --> 00:22:45.640
And what I'm going to know
about cons, and car, and cdr,

00:22:45.640 --> 00:22:51.170
is precisely that if I have
any x and y, all right,

00:22:51.170 --> 00:22:55.800
if I have any things x and y,
and I use cons to construct

00:22:55.800 --> 00:23:01.200
a pair, then the
car of that pair

00:23:01.200 --> 00:23:03.920
is going to be x,
the thing I put in,

00:23:03.920 --> 00:23:07.790
and the cdr of that
pair is going to be y.

00:23:07.790 --> 00:23:12.360
That's the behavior of these
operators, cons, car, and cdr.

00:23:12.360 --> 00:23:13.960
Given them, it's
pretty clear how

00:23:13.960 --> 00:23:17.520
George can go off and
construct his rational numbers.

00:23:17.520 --> 00:23:19.580
After all, all he
has to do-- remember

00:23:19.580 --> 00:23:22.520
George's problem was to
implement make-RAT, numerator,

00:23:22.520 --> 00:23:23.320
and denom.

00:23:23.320 --> 00:23:29.410
So all George has
to do is say define

00:23:29.410 --> 00:23:40.710
make-RAT of some n and a d-- so
all I have to do is cons them.

00:23:40.710 --> 00:23:42.790
That's cons of n and d.

00:23:45.365 --> 00:23:46.990
And then if I want
to get the numerator

00:23:46.990 --> 00:23:57.340
out, I would say define
the numerator, numer,

00:23:57.340 --> 00:24:00.260
of some rational number, x.

00:24:00.260 --> 00:24:02.510
If the rational number's
implemented as a pair,

00:24:02.510 --> 00:24:06.190
then all I have to do
is get out the car of x.

00:24:06.190 --> 00:24:19.350
And then similarly, define the
denom is going to be the cdr,

00:24:19.350 --> 00:24:21.430
the other thing I
put into the pair.

00:24:27.080 --> 00:24:28.960
Well, now we're in business.

00:24:28.960 --> 00:24:33.810
That's a complete implementation
of rational numbers.

00:24:33.810 --> 00:24:34.410
Let's use it.

00:24:34.410 --> 00:24:36.540
Suppose I want to say,
so I want to think

00:24:36.540 --> 00:24:43.470
about how to add 1/2 plus 1/4
and watch the system work.

00:24:43.470 --> 00:24:50.780
Well, the way I'd use that is
I'd say, well, maybe define a.

00:24:50.780 --> 00:24:53.080
I have to make a 1/2.

00:24:53.080 --> 00:24:55.830
Well, that's a rational
number with numerator 1

00:24:55.830 --> 00:25:01.090
and denominator 2, so a
will be make-RAT of 1 and 2.

00:25:05.490 --> 00:25:07.770
And then I'll construct the 1/4.

00:25:07.770 --> 00:25:20.560
I'll say define d to
be make-RAT of 1 and 4.

00:25:23.362 --> 00:25:25.630
And if I'd like to look
at the answer-- well,

00:25:25.630 --> 00:25:28.110
assuming I don't have a special
thing that prints rational

00:25:28.110 --> 00:25:31.530
numbers, or I could make one--
I could say, for instance,

00:25:31.530 --> 00:25:46.930
define the answer to be +RAT
of a and b, and now I can say,

00:25:46.930 --> 00:25:47.790
what's the answer?

00:25:47.790 --> 00:25:50.900
What are the numerators and
denominators of the answer?

00:25:50.900 --> 00:25:54.470
So if I'm adding
1/2 and 1/4, I'll

00:25:54.470 --> 00:26:00.440
say, what is the
numerator of the answer?

00:26:04.230 --> 00:26:10.880
And the system is going
to type out, well, 6.

00:26:10.880 --> 00:26:13.250
Bad news.

00:26:13.250 --> 00:26:22.340
And if I say what's the
denominator of the answer,

00:26:22.340 --> 00:26:26.430
the system's going
to type out 8.

00:26:26.430 --> 00:26:29.930
So instead of what
I would really like,

00:26:29.930 --> 00:26:35.630
which is for it to say
that 1/2 and 1/4 is 3/4,

00:26:35.630 --> 00:26:40.450
this foolish machine is
going to say, no, it's 6/8.

00:26:40.450 --> 00:26:43.400
Well, that's sort of bad news.

00:26:43.400 --> 00:26:44.220
Where's the bug?

00:26:47.280 --> 00:26:48.780
Why does it do that, after all?

00:26:48.780 --> 00:26:51.400
Well, it's the way
that we just had +RAT.

00:26:51.400 --> 00:26:56.210
+RAT just took the-- it said
you add the numerator times

00:26:56.210 --> 00:26:59.450
the denominator, you add
that to the numerator times

00:26:59.450 --> 00:27:02.210
the denominator, and put that
over the product of the two

00:27:02.210 --> 00:27:05.890
denominators, and
that's why you get 6/8.

00:27:05.890 --> 00:27:10.489
So what was wrong with our
implementation of +RAT?

00:27:10.489 --> 00:27:12.780
What's wrong with that rational
number arithmetic stuff

00:27:12.780 --> 00:27:15.582
that we did before the break?

00:27:15.582 --> 00:27:17.290
Well, the answer is
one way to look at it

00:27:17.290 --> 00:27:19.529
is absolutely nothing's wrong.

00:27:19.529 --> 00:27:21.070
That's perfectly
good implementation.

00:27:21.070 --> 00:27:25.901
It follows the sixth grade,
fifth grade mathematic

00:27:25.901 --> 00:27:26.775
for adding fractions.

00:27:30.000 --> 00:27:33.310
One thing we can say is,
well, that's George's problem.

00:27:33.310 --> 00:27:36.250
Like, boy, wasn't
George dumb to say

00:27:36.250 --> 00:27:38.440
that he can make a
rational number simply

00:27:38.440 --> 00:27:42.900
by sticking together the
numerator and the denominator?

00:27:42.900 --> 00:27:45.360
Wouldn't it be
better for George,

00:27:45.360 --> 00:27:48.420
when he made a rational
number, to reduce

00:27:48.420 --> 00:27:50.970
the stuff to lowest terms?

00:27:50.970 --> 00:27:55.750
And what I mean is, wouldn't
it be better for George,

00:27:55.750 --> 00:28:00.430
instead of using this
version of make-RAT,

00:28:00.430 --> 00:28:03.580
to use this one on the slide?

00:28:03.580 --> 00:28:09.190
Or instead of just saying cons
together n and d, what you do

00:28:09.190 --> 00:28:12.800
is compute the greatest
common divisor of n and d,

00:28:12.800 --> 00:28:15.471
and gcd is the procedure
which, well, for all we

00:28:15.471 --> 00:28:17.470
care is a primitive, which
computes the greatest

00:28:17.470 --> 00:28:20.628
common divisor of two numbers.

00:28:20.628 --> 00:28:24.520
So the way I can construct
a rational number is

00:28:24.520 --> 00:28:26.890
get the greatest common
divisor of the two numbers,

00:28:26.890 --> 00:28:30.530
and I'm going to
call that g, and then

00:28:30.530 --> 00:28:32.959
instead of consing
together n and d,

00:28:32.959 --> 00:28:34.000
I'll divide them through.

00:28:34.000 --> 00:28:35.499
I'll cons together
the quotient of n

00:28:35.499 --> 00:28:40.454
by the the gcd and the
quotient of d by the gcd.

00:28:40.454 --> 00:28:42.120
And that will reduce
the rational number

00:28:42.120 --> 00:28:43.000
to lowest terms.

00:28:47.780 --> 00:28:54.330
So when I do this addition,
when +RAT calls make-RAT--

00:28:54.330 --> 00:28:57.685
and for the definition of +RAT
it had a make-RAT in there--

00:28:57.685 --> 00:28:59.560
just by the fact that
it's constructing that,

00:28:59.560 --> 00:29:01.935
the thing will get reduced to
lowest terms automatically.

00:29:09.612 --> 00:29:15.180
OK, that is a complete system.

00:29:15.180 --> 00:29:19.590
For rational number arithmetic,
let's look at what we've done.

00:29:19.590 --> 00:29:22.440
All right, we said we want
to build rational number

00:29:22.440 --> 00:29:27.230
arithmetic, and we had
a thing called +RAT.

00:29:27.230 --> 00:29:29.940
We implemented that.

00:29:29.940 --> 00:29:33.330
And I showed you multiplying
rational numbers,

00:29:33.330 --> 00:29:35.317
and although I didn't
put them up there,

00:29:35.317 --> 00:29:36.900
presumably we'd like
to have something

00:29:36.900 --> 00:29:39.937
that subtracts rational
numbers, and I don't know,

00:29:39.937 --> 00:29:40.770
all sorts of things.

00:29:40.770 --> 00:29:43.270
Things that test equality in
division, and maybe things that

00:29:43.270 --> 00:29:46.190
print rational numbers
in some particular way.

00:29:46.190 --> 00:29:52.330
And we implemented
those in terms of pairs.

00:29:52.330 --> 00:29:55.800
These pairs, cons, car, and
cdr that are built into Lisp.

00:29:55.800 --> 00:30:05.100
But the important thing is
that between these and these,

00:30:05.100 --> 00:30:07.622
we set up an
abstraction barrier.

00:30:07.622 --> 00:30:09.260
We set up a layer
of abstraction.

00:30:17.310 --> 00:30:19.190
And what was that
layer of abstraction?

00:30:19.190 --> 00:30:21.795
That layer of abstraction
was precisely the constructor

00:30:21.795 --> 00:30:22.545
and the selectors.

00:30:25.630 --> 00:30:34.730
This layer was make-RAT,
and numer, and denom.

00:30:38.970 --> 00:30:43.480
This methodology, another
way to say what it's doing,

00:30:43.480 --> 00:30:53.520
is that we are separating
the way something is used,

00:30:53.520 --> 00:30:56.380
separating the use
of data objects,

00:30:56.380 --> 00:30:59.350
from the representation
of data objects.

00:31:07.650 --> 00:31:11.440
So up here, we have the way
that rational numbers are used,

00:31:11.440 --> 00:31:12.620
do arithmetic on them.

00:31:12.620 --> 00:31:15.140
Down here, we have the way
that they're represented,

00:31:15.140 --> 00:31:17.647
and they're separated
by this boundary.

00:31:17.647 --> 00:31:19.605
The boundary is the
constructors and selectors.

00:31:23.760 --> 00:31:25.597
And this methodology has a name.

00:31:25.597 --> 00:31:26.930
This is called data abstraction.

00:31:35.820 --> 00:31:38.920
Data abstraction is sort of
the programming methodology

00:31:38.920 --> 00:31:41.960
of setting up data objects
by postulating constructors

00:31:41.960 --> 00:31:44.085
and selectors to isolate
use from representation.

00:31:47.550 --> 00:31:49.060
Well, so why?

00:31:49.060 --> 00:31:51.750
I mean, after all, we didn't
have to do it this way.

00:31:51.750 --> 00:31:55.450
It's perfectly possible to
do rational number addition

00:31:55.450 --> 00:31:58.930
without having any compound data
objects, and here on the slide

00:31:58.930 --> 00:32:00.060
is one example.

00:32:00.060 --> 00:32:03.220
We certainly could
have defined +RAT,

00:32:03.220 --> 00:32:06.456
which takes in things
x and y, and we'll say,

00:32:06.456 --> 00:32:10.030
well what are these
rational numbers really?

00:32:10.030 --> 00:32:12.730
So really, they're just
pairs, and the numerator's

00:32:12.730 --> 00:32:15.120
the car and the denominator's
the cdr. So what we'll do

00:32:15.120 --> 00:32:23.310
is we'll take the car of x times
the cdr of y, multiply them.

00:32:23.310 --> 00:32:26.470
Take the car of y times the
cdr of x, multiply them.

00:32:26.470 --> 00:32:28.650
Add them.

00:32:28.650 --> 00:32:30.550
Take the cdr of x
and the cdr of y,

00:32:30.550 --> 00:32:32.930
multiply them, and then
constitute together.

00:32:35.265 --> 00:32:36.890
Well, that sort of
does the same thing.

00:32:41.560 --> 00:32:43.550
But this ignores the
problem of reducing things

00:32:43.550 --> 00:32:47.680
to lowest terms, but let's not
worry about that for a minute.

00:32:47.680 --> 00:32:48.200
But so what?

00:32:48.200 --> 00:32:50.461
Why don't we do it that way?

00:32:50.461 --> 00:32:50.960
Right?

00:32:50.960 --> 00:32:53.220
After all, there are sort of
fewer procedures to define,

00:32:53.220 --> 00:32:54.719
and it's a lot more
straightforward.

00:32:57.210 --> 00:32:59.240
It saves all this
self-righteous BS

00:32:59.240 --> 00:33:00.850
about talking about
data abstraction.

00:33:00.850 --> 00:33:02.270
We just sort of do it.

00:33:02.270 --> 00:33:04.870
I mean, who knows, maybe it's
even marginally more efficient

00:33:04.870 --> 00:33:07.930
depending on whatever
compiler were using for this.

00:33:07.930 --> 00:33:11.230
What's the point of
isolating the use

00:33:11.230 --> 00:33:13.910
from the representation?

00:33:13.910 --> 00:33:17.130
Well, it goes back to
this notion of naming.

00:33:17.130 --> 00:33:20.870
Remember, one of the
most important principles

00:33:20.870 --> 00:33:23.030
in programming is
the same as one

00:33:23.030 --> 00:33:25.660
of the most important principles
in sorcery, all right?

00:33:25.660 --> 00:33:27.930
That's if you have the
name of the spirit,

00:33:27.930 --> 00:33:30.330
you get control over it.

00:33:30.330 --> 00:33:33.790
And if you go back
and look at the slide,

00:33:33.790 --> 00:33:36.940
you see what's in there is
we have this thing +RAT,

00:33:36.940 --> 00:33:40.600
but nowhere in the system,
if I have a +RAT and a -RAT

00:33:40.600 --> 00:33:42.580
and a *RAT, and things
that look like that,

00:33:42.580 --> 00:33:46.030
nowhere in the system do I
have a thing that I can point

00:33:46.030 --> 00:33:50.770
at which is a rational number.

00:33:53.550 --> 00:33:57.170
I don't have, in a
system like that,

00:33:57.170 --> 00:34:01.340
the idea of rational number
as a conceptual entity.

00:34:01.340 --> 00:34:04.270
Well, what's the
advantage of that?

00:34:04.270 --> 00:34:05.920
What's the advantage
of isolating

00:34:05.920 --> 00:34:08.360
the idea of rational numbers
as a conceptual entity,

00:34:08.360 --> 00:34:10.929
and really naming it
with make-RAT, numerator,

00:34:10.929 --> 00:34:12.900
and denominator.

00:34:12.900 --> 00:34:18.230
Well, one advantage is
you might want to have

00:34:18.230 --> 00:34:20.679
alternative representations.

00:34:20.679 --> 00:34:23.520
See, before I showed you
that one way George can solve

00:34:23.520 --> 00:34:26.920
this things not reduced
to lowest terms problem,

00:34:26.920 --> 00:34:29.149
is when you build
a rational number,

00:34:29.149 --> 00:34:31.190
you divide up by the
greatest common denominator.

00:34:31.190 --> 00:34:36.634
Another way to do that
is shown over here.

00:34:36.634 --> 00:34:38.300
I can have an alternative
representation

00:34:38.300 --> 00:34:40.980
for rational numbers where when
you make a rational number,

00:34:40.980 --> 00:34:43.409
you just cons them.

00:34:43.409 --> 00:34:45.040
However, when you
go to select out

00:34:45.040 --> 00:34:50.409
the numerator, at that point
you compute the gcd of the stuff

00:34:50.409 --> 00:34:53.440
that's sitting in that pair,
and divide out by the gcd.

00:34:57.970 --> 00:35:01.090
And similarly, when I
get the denominator,

00:35:01.090 --> 00:35:03.600
at that point when I go
to get the denominator,

00:35:03.600 --> 00:35:05.420
I'll divide out by the gcd.

00:35:05.420 --> 00:35:09.090
So the difference would be in
the old representation, when

00:35:09.090 --> 00:35:13.170
ans was constructed
here, say what's 6 and 8,

00:35:13.170 --> 00:35:15.054
in the first way,
the 6 and 8 would

00:35:15.054 --> 00:35:17.220
have got reduced when they
got stuck into that pair,

00:35:17.220 --> 00:35:20.165
numerator would select out 3.

00:35:20.165 --> 00:35:21.540
And in the way I
just showed you,

00:35:21.540 --> 00:35:25.110
well, ans would
get 6 and 8 put in,

00:35:25.110 --> 00:35:27.650
and then at the point
where I said numerator,

00:35:27.650 --> 00:35:32.590
some computation would get
done to put out 3 instead of 6.

00:35:32.590 --> 00:35:34.520
So those are two different
ways I might do it.

00:35:34.520 --> 00:35:37.461
Which one's better?

00:35:37.461 --> 00:35:38.460
Well, it depends, right?

00:35:38.460 --> 00:35:40.642
If I'm making a system
where I am mostly

00:35:40.642 --> 00:35:42.850
constructing rational numbers
and hardly ever looking

00:35:42.850 --> 00:35:44.266
at them, then it's
probably better

00:35:44.266 --> 00:35:47.776
not to do that gcd computation
when I construct them.

00:35:47.776 --> 00:35:50.910
If I'm doing a system where
I look at things a lot more

00:35:50.910 --> 00:35:53.030
than I construct them,
then it's probably better

00:35:53.030 --> 00:35:57.087
to do the work when
I construct them.

00:35:57.087 --> 00:35:58.170
So there's a choice there.

00:35:58.170 --> 00:36:01.780
But the real issue
is that you might not

00:36:01.780 --> 00:36:05.640
be able to decide at the
moment you're worrying

00:36:05.640 --> 00:36:07.640
about these rational numbers.

00:36:07.640 --> 00:36:13.430
See, in general, as
systems designers,

00:36:13.430 --> 00:36:15.900
you're forced with the
necessity to make decisions

00:36:15.900 --> 00:36:18.010
about how you're
going to do things,

00:36:18.010 --> 00:36:20.880
and in general, the way you'd
like to retain flexibility

00:36:20.880 --> 00:36:23.990
is to never make up
your mind about anything

00:36:23.990 --> 00:36:26.890
until you're forced to do it.

00:36:26.890 --> 00:36:31.350
The problem is, there's
a very, very narrow line

00:36:31.350 --> 00:36:34.765
between deferring decisions
and outright procrastination.

00:36:38.760 --> 00:36:44.080
So you'd like to make progress,
but also at the same time,

00:36:44.080 --> 00:36:48.620
never be bound by the
consequences of your decisions.

00:36:48.620 --> 00:36:50.550
Data abstraction's
one way of doing this.

00:36:50.550 --> 00:36:54.540
What we did is we
used wishful thinking.

00:36:54.540 --> 00:36:57.190
See, we gave a name
to the decision.

00:36:57.190 --> 00:37:00.505
We said, make-RAT,
numerator, and denominator

00:37:00.505 --> 00:37:02.380
will stand for however
it's going to be done,

00:37:02.380 --> 00:37:04.630
and however it's going to
be done is George's problem.

00:37:04.630 --> 00:37:06.890
But really, what that was
doing is giving a name

00:37:06.890 --> 00:37:10.380
to the decision of how
we're going to do it,

00:37:10.380 --> 00:37:14.400
and then continuing as
if we made the decision.

00:37:14.400 --> 00:37:17.110
And then eventually, when
we really wanted it to work,

00:37:17.110 --> 00:37:20.330
coming back and facing
what we really had to do.

00:37:20.330 --> 00:37:22.690
And in fact, we'll see
a couple times from now

00:37:22.690 --> 00:37:24.120
that you may never
have to choose

00:37:24.120 --> 00:37:27.800
any particular
representation, ever, ever.

00:37:27.800 --> 00:37:30.004
Anyway, that's a very
powerful design technique.

00:37:30.004 --> 00:37:32.295
It's the key to the reason
people use data abstraction.

00:37:34.830 --> 00:37:37.854
And we're going to see
that idea again and again.

00:37:37.854 --> 00:37:40.510
Let's stop for questions.

00:37:40.510 --> 00:37:43.600
AUDIENCE: What does
this decision making

00:37:43.600 --> 00:37:47.500
through abstraction layers do to
the axiom of do all your design

00:37:47.500 --> 00:37:49.800
before any of your code?

00:37:49.800 --> 00:37:52.282
PROFESSOR: Well,
that's someone's axiom,

00:37:52.282 --> 00:37:53.990
and I bet that's the
axiom of someone who

00:37:53.990 --> 00:37:56.600
hasn't implemented very large
computer systems very much.

00:38:01.220 --> 00:38:03.460
I said that computer
science is a lot like magic,

00:38:03.460 --> 00:38:05.270
and it's sort of good
that it's like magic.

00:38:05.270 --> 00:38:06.853
There's a bad part
of computer science

00:38:06.853 --> 00:38:08.746
that's a lot like religion.

00:38:08.746 --> 00:38:12.637
And in general, I
think people who

00:38:12.637 --> 00:38:15.220
really believe that you design
everything before you implement

00:38:15.220 --> 00:38:17.732
it basically are people
who haven't designed

00:38:17.732 --> 00:38:18.440
very many things.

00:38:21.230 --> 00:38:23.870
The real power is
that you can pretend

00:38:23.870 --> 00:38:27.000
that you've made the
decision and then later

00:38:27.000 --> 00:38:29.530
on figure out which one is
right, which decision you ought

00:38:29.530 --> 00:38:30.412
to have made.

00:38:30.412 --> 00:38:32.870
And when you can do that, you
have the best of both worlds.

00:38:35.664 --> 00:38:37.330
AUDIENCE: Can you
explain the difference

00:38:37.330 --> 00:38:40.180
between let and define?

00:38:40.180 --> 00:38:43.520
PROFESSOR: Oh, OK.

00:38:43.520 --> 00:38:49.040
Let is a way to
establish local names.

00:38:55.150 --> 00:38:57.430
Let me give you sort
of the half answer.

00:38:57.430 --> 00:39:00.970
And I'll say, later on we
can talk about the whole very

00:39:00.970 --> 00:39:02.960
complicated thing.

00:39:02.960 --> 00:39:05.750
But the big difference
for now is that, see,

00:39:05.750 --> 00:39:08.130
when you're typing
at Lisp, you're

00:39:08.130 --> 00:39:12.020
typing in this environment
where you're making definitions.

00:39:12.020 --> 00:39:20.446
And when you say define a to be
5, if I say define a to be 5,

00:39:20.446 --> 00:39:25.640
then from then on the thing
will remember that a is 5.

00:39:25.640 --> 00:39:29.210
Let is a way to set up
a local context where

00:39:29.210 --> 00:39:31.090
there's a definition.

00:39:31.090 --> 00:39:37.490
So if I type something
like, saying let a-- no,

00:39:37.490 --> 00:39:43.360
I shouldn't say
a-- if I said let z

00:39:43.360 --> 00:39:53.730
be 10, and within that context,
tell me what the sum of z and z

00:39:53.730 --> 00:39:54.280
is.

00:39:54.280 --> 00:40:00.240
So if I typed in this expression
to Lisp, and then this

00:40:00.240 --> 00:40:02.210
would put out 20.

00:40:02.210 --> 00:40:05.975
However, then if
I said what's z,

00:40:05.975 --> 00:40:10.910
the computer would say
that's an unbound variable.

00:40:10.910 --> 00:40:13.260
So let is a way of
setting up a context where

00:40:13.260 --> 00:40:16.320
you can make definitions.

00:40:16.320 --> 00:40:19.320
But those definitions are
local to this context.

00:40:19.320 --> 00:40:27.990
And of course, if I'd said
a in here, I'd still get 20.

00:40:27.990 --> 00:40:33.859
But this a would not interfere
at all with this one.

00:40:33.859 --> 00:40:36.400
So if I type this, and then type
this, and then say what's a?

00:40:36.400 --> 00:40:39.160
a will still be 5.

00:40:39.160 --> 00:40:41.510
So there's some other
subtle differences

00:40:41.510 --> 00:40:44.543
between let and define, but
that's the most important one.

00:41:20.090 --> 00:41:23.800
All right, well, we've looked at
implementing this little system

00:41:23.800 --> 00:41:26.210
for doing arithmetic
on rational numbers

00:41:26.210 --> 00:41:28.740
as an example of this
methodology of data

00:41:28.740 --> 00:41:31.096
abstraction.

00:41:31.096 --> 00:41:36.870
And that's a way of controlling
complexity in large systems.

00:41:36.870 --> 00:41:38.935
But, see, like
procedure definition,

00:41:38.935 --> 00:41:40.310
and like all the
ways we're going

00:41:40.310 --> 00:41:42.370
to talk about for
controlling complexity,

00:41:42.370 --> 00:41:46.370
the real power of these things
show up not when you sort of do

00:41:46.370 --> 00:41:49.880
these things in themselves,
like it's not such a great thing

00:41:49.880 --> 00:41:52.430
that we've done rational
number arithmetic,

00:41:52.430 --> 00:41:56.670
it's that you can use
these as building blocks

00:41:56.670 --> 00:42:00.620
for making more
complicated things.

00:42:00.620 --> 00:42:03.266
So it's no wonderful idea that
you can just put two numbers

00:42:03.266 --> 00:42:04.265
together to form a pair.

00:42:04.265 --> 00:42:06.020
If that's all you
ever wanted to do,

00:42:06.020 --> 00:42:08.450
there are tons of ways
that you can do that.

00:42:08.450 --> 00:42:11.490
The real issue is can
you do that in such a way

00:42:11.490 --> 00:42:13.080
so that the things
that you build

00:42:13.080 --> 00:42:16.945
become building blocks for doing
something even more complex?

00:42:16.945 --> 00:42:18.640
So whenever someone
shows you a method

00:42:18.640 --> 00:42:20.690
for controlling complexity, you
should say, yeah, that's great,

00:42:20.690 --> 00:42:21.930
but what can I build with it?

00:42:25.290 --> 00:42:30.632
So for example, let me just run
through another thing that's

00:42:30.632 --> 00:42:32.090
a lot like the
rational number one.

00:42:32.090 --> 00:42:35.760
Suppose we would like to
represent points in the plane.

00:42:35.760 --> 00:42:37.550
You sort of say,
well, there's a point,

00:42:37.550 --> 00:42:40.810
and we're going to
call that point p.

00:42:40.810 --> 00:42:47.360
And that point might
have coordinates,

00:42:47.360 --> 00:42:50.330
like this might be
the point 1 comma 2.

00:42:50.330 --> 00:42:54.370
The x-coordinate might be 1, and
it's y-coordinate might be 2.

00:42:54.370 --> 00:42:57.620
And we'll make a little
system for manipulating points

00:42:57.620 --> 00:43:00.450
in the plane.

00:43:00.450 --> 00:43:03.000
And again, we can
do that-- here's

00:43:03.000 --> 00:43:04.120
a little example of that.

00:43:07.070 --> 00:43:10.080
It can represent vectors, the
same as points in the plane,

00:43:10.080 --> 00:43:18.160
and we'll say, yep, there's a
constructor called make-vector,

00:43:18.160 --> 00:43:21.100
make-vector's going to
take two coordinates,

00:43:21.100 --> 00:43:24.050
and here we can implement
them if we like as pairs,

00:43:24.050 --> 00:43:27.120
but the important thing is
that there's a constructor.

00:43:27.120 --> 00:43:31.890
And then given some vector, p,
we can find its x-coordinate,

00:43:31.890 --> 00:43:33.540
or we can get its y-coordinate.

00:43:33.540 --> 00:43:36.170
So there's a constructor
and selectors

00:43:36.170 --> 00:43:39.010
for points in the plane.

00:43:39.010 --> 00:43:40.670
Well, given points
in the plane, we

00:43:40.670 --> 00:43:42.420
might want to use them
to build something.

00:43:42.420 --> 00:43:44.020
So for instance, we
might want to talk

00:43:44.020 --> 00:43:48.460
about, we might have a
point, p, and a point, q,

00:43:48.460 --> 00:43:54.790
and p might be the point 1, 2,
and q might be the point 2, 3.

00:43:54.790 --> 00:43:58.970
And we might want to talk
about the line segment that

00:43:58.970 --> 00:44:01.570
starts at p and ends at q.

00:44:01.570 --> 00:44:05.180
And that might be the segment s.

00:44:05.180 --> 00:44:11.920
So we might want to
build points for vectors

00:44:11.920 --> 00:44:16.410
in terms of numbers, and
segments in terms of vectors.

00:44:16.410 --> 00:44:18.180
So we can represent
line segments

00:44:18.180 --> 00:44:19.920
in exactly the same way.

00:44:19.920 --> 00:44:21.724
All right, so the line
segment from p to q,

00:44:21.724 --> 00:44:23.640
we'll say there's a
constructor, make-segment.

00:44:27.010 --> 00:44:29.530
And make up names
for the selectors,

00:44:29.530 --> 00:44:31.060
the starting point
of the segment

00:44:31.060 --> 00:44:32.560
and the ending point
of the segment.

00:44:32.560 --> 00:44:34.755
And again, we can implement
a segment using cons

00:44:34.755 --> 00:44:38.874
as a pair of points, and car
and cdr get out the two points

00:44:38.874 --> 00:44:40.540
that we put together
to get the segment.

00:44:44.820 --> 00:44:48.210
Well, now having
done that, we can

00:44:48.210 --> 00:44:51.920
have some operations on them.

00:44:51.920 --> 00:44:57.610
Like we could say, what's the
midpoint of a line segment?

00:44:57.610 --> 00:45:00.140
So here's the midpoint
of a line segment,

00:45:00.140 --> 00:45:05.000
that's going to be the
points whose coordinates are

00:45:05.000 --> 00:45:07.310
the averages of the
coordinates of the endpoints.

00:45:07.310 --> 00:45:10.170
OK, there's the midpoint.

00:45:10.170 --> 00:45:12.060
So to get the midpoint
of a line segment,

00:45:12.060 --> 00:45:17.630
s, we'll just say grab the
starting point to the segment,

00:45:17.630 --> 00:45:20.320
grab the ending
point of the segment,

00:45:20.320 --> 00:45:24.500
and now make a vector-- make
a point whose coordinates are

00:45:24.500 --> 00:45:27.880
the average of the
x-coordinate of the first point

00:45:27.880 --> 00:45:30.220
and the x-coordinate
of the second point,

00:45:30.220 --> 00:45:33.530
and whose y-coordinate is the
average of the y-coordinates.

00:45:33.530 --> 00:45:37.810
So there's an
implementation of midpoint.

00:45:37.810 --> 00:45:42.130
And then similarly,
we can build something

00:45:42.130 --> 00:45:44.450
like the length of the segment.

00:45:44.450 --> 00:45:46.710
The length of the
segment is a thing

00:45:46.710 --> 00:45:52.850
whose-- use Pythagoras's rule,
the length of the segment

00:45:52.850 --> 00:45:57.100
is the square root of the d
x squared plus d y squared.

00:45:57.100 --> 00:46:00.600
We'll say to get the
length of a line segment,

00:46:00.600 --> 00:46:06.570
we'll let dx be the difference
of the x-coordinate of one

00:46:06.570 --> 00:46:11.560
endpoint and the x-coordinate
of the other endpoint,

00:46:11.560 --> 00:46:13.910
and we'll let dy
be the difference

00:46:13.910 --> 00:46:16.260
of the y-coordinates.

00:46:16.260 --> 00:46:17.860
And then we'll take
the square root

00:46:17.860 --> 00:46:22.251
of the sum of the squares of dx
and dy, that's what this says.

00:46:22.251 --> 00:46:26.190
All right, so there's an
implementation of length.

00:46:26.190 --> 00:46:35.760
And again, what we built
is a layered system.

00:46:35.760 --> 00:46:39.712
We built a system which
has, well, say up here

00:46:39.712 --> 00:46:40.420
there's segments.

00:46:47.430 --> 00:46:50.530
And then there's an
abstraction barrier.

00:46:50.530 --> 00:46:56.880
The abstraction barrier
separates the implementation

00:46:56.880 --> 00:46:58.870
of segments from the
implementation of vectors

00:46:58.870 --> 00:47:02.460
and points, and what that
abstraction barrier is

00:47:02.460 --> 00:47:04.260
are the constructors
and selectors.

00:47:04.260 --> 00:47:14.750
It's make-segment, and
segment-start, and segment-end.

00:47:18.030 --> 00:47:20.120
And then there are vectors.

00:47:20.120 --> 00:47:25.600
And vectors in turn are built
on top of pairs and numbers.

00:47:25.600 --> 00:47:29.670
So I'll say pairs and numbers.

00:47:29.670 --> 00:47:32.930
And that has its own
abstraction barrier,

00:47:32.930 --> 00:47:42.350
which is make-vector, and
x-coordinate, and y-coordinate.

00:47:46.920 --> 00:47:48.930
So we have, again,
a layered system.

00:47:48.930 --> 00:47:52.080
You're starting to see
that there are layers here.

00:47:52.080 --> 00:47:57.470
I ought to mention, there
is a very important thing

00:47:57.470 --> 00:47:59.220
that I kind of took for granted.

00:48:02.016 --> 00:48:04.670
And it's sort of so natural,
but on the other hand

00:48:04.670 --> 00:48:07.580
it's a very important thing.

00:48:07.580 --> 00:48:10.230
Notice that in order to
represent this segment

00:48:10.230 --> 00:48:16.600
s, I said this segment
is a pair of points.

00:48:16.600 --> 00:48:19.120
And a point is a
pair of numbers.

00:48:19.120 --> 00:48:21.750
And if I were going to
draw the box and pointers

00:48:21.750 --> 00:48:25.080
structure for that, I
would say, oh, the segment

00:48:25.080 --> 00:48:29.560
is, given those particular
representations that I showed

00:48:29.560 --> 00:48:34.050
you, I'd say this
segment s is a pair,

00:48:34.050 --> 00:48:40.600
and the first thing in
the pair is a vector,

00:48:40.600 --> 00:48:45.430
and the vector is
a pair of numbers.

00:48:45.430 --> 00:48:47.000
And that's this, that's p.

00:48:50.190 --> 00:48:52.060
And the other thing
in the segment

00:48:52.060 --> 00:49:00.100
is q, which is itself
a pair of numbers.

00:49:00.100 --> 00:49:01.660
So I almost took
it for granted when

00:49:01.660 --> 00:49:08.960
I said that cons allows
you to put things together.

00:49:08.960 --> 00:49:12.420
But it's very easy
to not appreciate

00:49:12.420 --> 00:49:17.490
that, because notice, some of
the things I can put together

00:49:17.490 --> 00:49:20.720
can themselves be pairs.

00:49:20.720 --> 00:49:24.400
And let me introduce a word that
I'll talk about more next time,

00:49:24.400 --> 00:49:26.915
it's one of my favorite
words, called closure.

00:49:30.640 --> 00:49:34.780
And by closure I mean that
the means of combination

00:49:34.780 --> 00:49:39.040
in your system are such that
when you put things together

00:49:39.040 --> 00:49:43.430
using them, like we make a pair,
you can then put those together

00:49:43.430 --> 00:49:45.080
with the same means
of combination.

00:49:45.080 --> 00:49:47.370
So I can have not only
a pair of numbers,

00:49:47.370 --> 00:49:48.675
but I can have a pair of pairs.

00:49:51.710 --> 00:49:57.920
So for instance, making arrays
in a language like Fortran

00:49:57.920 --> 00:49:59.690
is not a closed
means of combination,

00:49:59.690 --> 00:50:01.575
because I can make
an array of numbers,

00:50:01.575 --> 00:50:03.100
but I can't make
an array of arrays.

00:50:05.790 --> 00:50:09.060
And one of the things that you
should ask, one of your tests

00:50:09.060 --> 00:50:11.770
of quality for a
means of combination

00:50:11.770 --> 00:50:14.940
that someone shows
you, is gee, are

00:50:14.940 --> 00:50:18.340
the things you make closed
under that means of combination?

00:50:18.340 --> 00:50:21.460
So pairs would not be nearly so
interesting if all I could do

00:50:21.460 --> 00:50:23.160
was make a pair of numbers.

00:50:23.160 --> 00:50:26.754
I couldn't build very
much structure at all.

00:50:26.754 --> 00:50:28.170
OK, well, we'll
come back to that.

00:50:28.170 --> 00:50:29.503
I just wanted to mention it now.

00:50:29.503 --> 00:50:32.170
You'll hear a lot
about closure later on.

00:50:32.170 --> 00:50:38.420
You can also see the
potential for losing control

00:50:38.420 --> 00:50:40.970
of complexity as you have
a layered system if you

00:50:40.970 --> 00:50:44.030
don't use data abstraction.

00:50:44.030 --> 00:50:48.130
Let's go back and look
at this slide for length.

00:50:48.130 --> 00:50:52.826
Length works and is a simple
thing because I can say,

00:50:52.826 --> 00:50:55.510
when I want to get this
value, I can say, oh,

00:50:55.510 --> 00:51:00.430
that is the x-coordinate of the
first endpoint of the segment.

00:51:02.767 --> 00:51:04.850
And each of these things,
each of these selectors,

00:51:04.850 --> 00:51:09.190
x-coordinate and endpoint,
stand for a decision choice

00:51:09.190 --> 00:51:12.260
whose details I don't
have to look at.

00:51:12.260 --> 00:51:14.500
So I could perfectly
well, again, just

00:51:14.500 --> 00:51:16.270
like rational numbers
I did before, I

00:51:16.270 --> 00:51:18.400
could say, oh well,
gee, a segment really

00:51:18.400 --> 00:51:21.180
is a pair of pairs.

00:51:21.180 --> 00:51:24.810
And the x-coordinate of the
first endpoint or the segment

00:51:24.810 --> 00:51:27.330
really is the--
well, what is it?

00:51:27.330 --> 00:51:33.890
It's the car of the
car of the segment.

00:51:33.890 --> 00:51:37.500
So I could perfectly well
go and redefine length.

00:51:37.500 --> 00:51:48.614
I could say, define the
length of some segment s.

00:51:48.614 --> 00:51:50.420
And I could start
off writing something

00:51:50.420 --> 00:51:56.062
like, well, we'll let dx be--
well, what's it have to be?

00:51:56.062 --> 00:51:58.270
It's got to be the difference
of the two coordinates,

00:51:58.270 --> 00:52:00.740
so that's the difference
of, the first one is

00:52:00.740 --> 00:52:08.910
the car of the car
of s, subtracted

00:52:08.910 --> 00:52:14.040
from the first one, the car
of the other half of it,

00:52:14.040 --> 00:52:16.140
the cdr of s.

00:52:21.530 --> 00:52:24.820
All right, and then
dy would be-- well,

00:52:24.820 --> 00:52:27.260
let's see, I'd get
the y-coordinate,

00:52:27.260 --> 00:52:33.850
so it'd be the difference
of the cdr of the car of s,

00:52:33.850 --> 00:52:41.385
and the cdr of the cdr
of s, sort of go on.

00:52:44.210 --> 00:52:46.800
You can see that's
much harder to read

00:52:46.800 --> 00:52:48.270
than the program I had before.

00:52:48.270 --> 00:52:52.681
But worse than that, suppose
you'd gone and implemented

00:52:52.681 --> 00:52:53.180
length?

00:52:56.854 --> 00:52:59.020
And then the next day,
George comes to you and says,

00:52:59.020 --> 00:53:01.030
I'm sorry, I changed my mind.

00:53:01.030 --> 00:53:04.945
I want to write points with
the x-coordinate first.

00:53:04.945 --> 00:53:06.570
So you come back you
stare at this code

00:53:06.570 --> 00:53:07.861
and say, oh gee, what was that?

00:53:07.861 --> 00:53:13.980
That was the car, so I
have to change this to cdr,

00:53:13.980 --> 00:53:20.770
and this is cdr, and
this now has to be car.

00:53:20.770 --> 00:53:23.685
And this has to be car.

00:53:23.685 --> 00:53:25.060
And you sort of
do that, and then

00:53:25.060 --> 00:53:26.726
the next day George
comes back and says,

00:53:26.726 --> 00:53:31.410
sorry, the guys
designing the display

00:53:31.410 --> 00:53:35.490
would like lines to be painted
in the opposite direction,

00:53:35.490 --> 00:53:37.630
so I have to write the
endpoint first in the order.

00:53:37.630 --> 00:53:40.088
And then you come back and you
stare at this code, and say,

00:53:40.088 --> 00:53:42.400
gee, what was it talking about?

00:53:42.400 --> 00:53:44.930
Oh yeah, well I've got to
change this one to cdr,

00:53:44.930 --> 00:53:49.746
and this one becomes
car, this one comes car,

00:53:49.746 --> 00:53:50.620
and this becomes cdr.

00:53:50.620 --> 00:53:53.340
And you go up and do that,
and then the next day, George

00:53:53.340 --> 00:53:54.670
comes back and says,
I'm sorry, what I really

00:53:54.670 --> 00:53:56.130
meant is that the
segments always

00:53:56.130 --> 00:53:59.616
have to be painted from
left to right on the screen.

00:53:59.616 --> 00:54:00.990
And then you sort
of, it's clear,

00:54:00.990 --> 00:54:03.610
you just go and punch George
in the mouth at that point.

00:54:03.610 --> 00:54:09.310
But you see, as soon as
we have a 10 layer system,

00:54:09.310 --> 00:54:11.820
you see how that complexity
immediately builds up

00:54:11.820 --> 00:54:13.750
to the point where even
something like this

00:54:13.750 --> 00:54:16.250
gets out of control.

00:54:16.250 --> 00:54:19.560
So again, the way we've
gotten out of that

00:54:19.560 --> 00:54:21.150
is we've named that spirit.

00:54:21.150 --> 00:54:25.770
We built a system where
there is a thing, which

00:54:25.770 --> 00:54:29.420
is the representation
choice for how you're

00:54:29.420 --> 00:54:31.570
going to talk about vectors.

00:54:31.570 --> 00:54:33.450
And choices about
that representation

00:54:33.450 --> 00:54:35.472
are localized right there.

00:54:35.472 --> 00:54:36.930
They don't have
their guts spilling

00:54:36.930 --> 00:54:38.930
over into things like how
you compute the length

00:54:38.930 --> 00:54:40.926
and how you compute
the midpoint.

00:54:40.926 --> 00:54:45.660
And that's the real
power of this system.

00:54:45.660 --> 00:54:48.500
OK, we're explicit
about them, so

00:54:48.500 --> 00:54:50.916
that we have control over them.

00:54:50.916 --> 00:54:51.884
All right, questions?

00:54:51.884 --> 00:54:53.550
AUDIENCE: What happens
in the case where

00:54:53.550 --> 00:54:56.660
you don't want to be treating
objects in terms of pairs?

00:54:56.660 --> 00:55:00.420
For instance, in
three-dimensional space,

00:55:00.420 --> 00:55:01.680
you'd have three coordinates.

00:55:01.680 --> 00:55:03.640
Or even in the case where you
have n-dimensional space, what

00:55:03.640 --> 00:55:04.180
happens?

00:55:04.180 --> 00:55:05.140
PROFESSOR: Right, OK.

00:55:05.140 --> 00:55:08.374
Well, this is a preview
of what I'll say tomorrow.

00:55:08.374 --> 00:55:14.640
But the point is, once
you have two things,

00:55:14.640 --> 00:55:16.871
you have as many
things as you want.

00:55:16.871 --> 00:55:17.370
All right?

00:55:17.370 --> 00:55:19.310
Because if I want to
make three things,

00:55:19.310 --> 00:55:25.880
I could start making things
like a pair whose first thing is

00:55:25.880 --> 00:55:31.370
1, and whose second thing
is another pair that,

00:55:31.370 --> 00:55:34.582
say, has 2 and 3 in it.

00:55:34.582 --> 00:55:35.760
And so on, a hundred things.

00:55:35.760 --> 00:55:37.550
I can nest them out of pairs.

00:55:37.550 --> 00:55:40.076
I made a pretty arbitrary
decision about how to do it,

00:55:40.076 --> 00:55:41.450
and you can
immediately see there

00:55:41.450 --> 00:55:42.724
are lots of ways to do that.

00:55:42.724 --> 00:55:44.390
What we'll start
talking about next time

00:55:44.390 --> 00:55:47.600
are conventions for how
to do things like that.

00:55:47.600 --> 00:55:49.600
But notice that what this
really depends on is I

00:55:49.600 --> 00:55:51.950
can make pairs of pairs.

00:55:51.950 --> 00:55:54.380
If all I could do was make
pairs of numbers, I'd be stuck.

00:56:07.140 --> 00:56:09.236
OK.

00:56:09.236 --> 00:56:11.960
Let's break.

00:56:11.960 --> 00:56:55.580
[MUSIC PLAYING]

00:56:55.580 --> 00:56:57.080
All right, well,
we've just gone off

00:56:57.080 --> 00:57:03.575
and done a couple of simple
examples of data abstraction.

00:57:03.575 --> 00:57:05.695
Now I want to do something
more complicated.

00:57:05.695 --> 00:57:08.310
We're going to talk
about what it means.

00:57:08.310 --> 00:57:11.390
And this will be harder,
because it's always

00:57:11.390 --> 00:57:13.340
much harder in
computer programming

00:57:13.340 --> 00:57:16.450
to talk about what something
means than to go off and do it.

00:57:16.450 --> 00:57:22.070
But let's go back to
almost the very beginning.

00:57:22.070 --> 00:57:25.800
Let's go back to the
point where I said,

00:57:25.800 --> 00:57:32.370
we just assumed that there
were procedures, make-RAT,

00:57:32.370 --> 00:57:38.480
and numer, and denom.

00:57:38.480 --> 00:57:41.570
Let's go back to where we had
this, at the very beginning,

00:57:41.570 --> 00:57:44.920
constructors and
selectors, and went off

00:57:44.920 --> 00:57:47.210
and defined the rational
number arithmetic.

00:57:47.210 --> 00:57:48.940
And remember, I
said at that point

00:57:48.940 --> 00:57:51.990
we were sort of done,
except for George.

00:57:51.990 --> 00:57:55.920
Well, what is it that we'd
actually done at that point?

00:57:55.920 --> 00:57:59.420
What was it that was done?

00:57:59.420 --> 00:58:01.470
Well, what I want
to say is, what

00:58:01.470 --> 00:58:04.680
was done after we'd
implemented the operations

00:58:04.680 --> 00:58:08.780
and terms of these, was that we
had defined a rational number

00:58:08.780 --> 00:58:12.390
representation in
terms of abstract data.

00:58:17.946 --> 00:58:21.090
What do I mean by abstract data?

00:58:21.090 --> 00:58:25.610
Well, the idea is
that at that point,

00:58:25.610 --> 00:58:28.870
when we had our
+RAT and our *RAT,

00:58:28.870 --> 00:58:33.060
that any implementation of
make-RAT, and numerator,

00:58:33.060 --> 00:58:38.000
and denominator that
George supplied us with,

00:58:38.000 --> 00:58:40.990
could be the basis for a
rational number representation.

00:58:40.990 --> 00:58:44.500
Like, it wasn't our concern
where you divided through

00:58:44.500 --> 00:58:48.980
to get the greatest common
denominator, or any of that.

00:58:48.980 --> 00:58:52.260
So the idea is
that what we built

00:58:52.260 --> 00:58:54.560
is a rational arithmetic
system that would sit

00:58:54.560 --> 00:58:57.140
on top of any representation.

00:58:57.140 --> 00:58:59.930
What do I mean by
any representation?

00:58:59.930 --> 00:59:02.732
I mean, certainly it can't
be the case that all I mean

00:59:02.732 --> 00:59:04.440
is George can reach
in a bag and pull out

00:59:04.440 --> 00:59:09.830
three arbitrary procedures
and say, well, fine,

00:59:09.830 --> 00:59:11.960
now that's the implementation.

00:59:11.960 --> 00:59:14.080
That can't be what I mean.

00:59:14.080 --> 00:59:18.070
What I've got to
mean is that there's

00:59:18.070 --> 00:59:21.940
some way of saying whether
three procedures are

00:59:21.940 --> 00:59:25.510
going to be suitable as a
basis for rational number

00:59:25.510 --> 00:59:26.690
representation.

00:59:26.690 --> 00:59:29.250
If we think about
it, what suitable

00:59:29.250 --> 00:59:32.210
might mean is if I have to
assume something like this,

00:59:32.210 --> 00:59:39.230
I have to say that if
x is the result of say,

00:59:39.230 --> 00:59:59.730
doing make-RAT of n and d,
then the numerator of x divided

00:59:59.730 --> 01:00:09.680
by the denominator of
x is equal to n over d.

01:00:09.680 --> 01:00:13.770
See, what that is is
that's George's contract.

01:00:13.770 --> 01:00:16.520
What we mean by writing a
contract for rational numbers,

01:00:16.520 --> 01:00:18.790
if you think about it,
this is the right thing.

01:00:18.790 --> 01:00:21.510
And the two ones we
showed do the right thing.

01:00:21.510 --> 01:00:25.369
See, if I'm taking out
greatest common divisors,

01:00:25.369 --> 01:00:27.410
it doesn't matter whether
I take them out or not,

01:00:27.410 --> 01:00:29.830
or the place where I take
them, because the idea is I'm

01:00:29.830 --> 01:00:32.380
going to divide through.

01:00:32.380 --> 01:00:33.930
But see, this is
George's contract.

01:00:33.930 --> 01:00:35.720
So what we really
say to George is

01:00:35.720 --> 01:00:39.410
your business is to
go off and find us

01:00:39.410 --> 01:00:41.806
three procedures,
make-RAT, and numerator,

01:00:41.806 --> 01:00:45.660
and denominator, that
fulfill this contract

01:00:45.660 --> 01:00:46.870
for any choice of n and d.

01:00:46.870 --> 01:00:50.390
And that's what we
mean by we can use that

01:00:50.390 --> 01:00:54.540
as the basis for a rational
number representation.

01:00:54.540 --> 01:00:57.130
And other than that, it
fulfills this contract.

01:00:57.130 --> 01:00:59.292
We don't care how he does it.

01:00:59.292 --> 01:01:00.410
It's not our business.

01:01:00.410 --> 01:01:02.330
It's below the layer
of abstraction.

01:01:07.010 --> 01:01:13.539
In fact, if we want to say, what
is a rational number really?

01:01:13.539 --> 01:01:15.080
See, what's it
really, without having

01:01:15.080 --> 01:01:17.480
to talk about going below the
layer of abstraction, what

01:01:17.480 --> 01:01:21.150
we're forced into saying
is a rational number

01:01:21.150 --> 01:01:27.870
really is sort of this
axiom, is three procedures,

01:01:27.870 --> 01:01:29.630
make-RAT, numerator,
and denominator,

01:01:29.630 --> 01:01:32.370
that satisfy this axiom.

01:01:32.370 --> 01:01:34.640
In some sense,
abstractly, that's

01:01:34.640 --> 01:01:37.080
what a rational
number is really.

01:01:41.490 --> 01:01:43.864
That's sort of easy
words to listen to,

01:01:43.864 --> 01:01:45.780
because what you have
in your head, of course,

01:01:45.780 --> 01:01:47.880
is well, for all this
thing about saying

01:01:47.880 --> 01:01:50.742
that's what a rational
number is really,

01:01:50.742 --> 01:01:52.950
you actually just saw that
we built rational numbers.

01:01:58.830 --> 01:02:03.350
See, what we really did is
we built rational numbers

01:02:03.350 --> 01:02:04.230
on top of pairs.

01:02:08.680 --> 01:02:10.680
So for all I'm
saying abstractly,

01:02:10.680 --> 01:02:15.450
we can say a rational number
really is just this axiom.

01:02:15.450 --> 01:02:17.030
You can listen to
that comfortably,

01:02:17.030 --> 01:02:18.446
because you're
saying, well, yeah,

01:02:18.446 --> 01:02:21.950
but really it's actually pairs,
and I'm just annoying you

01:02:21.950 --> 01:02:24.820
by trying to be abstract.

01:02:24.820 --> 01:02:28.970
Well, let me, as an
antidote for that,

01:02:28.970 --> 01:02:32.474
let me do something that I think
is really going to terrify you.

01:02:32.474 --> 01:02:33.890
I mean, it's really
going to bring

01:02:33.890 --> 01:02:39.320
you face to face with the
sort of existential reality

01:02:39.320 --> 01:02:41.490
of this abstraction that
we're talking about.

01:02:41.490 --> 01:02:45.960
And what I'm going to talk
about is, what are pairs really?

01:02:45.960 --> 01:02:48.545
See, what did I tell
you about pairs?

01:02:48.545 --> 01:02:49.420
I tricked you, right?

01:02:49.420 --> 01:02:51.520
I said that Lisp has
this primitive called

01:02:51.520 --> 01:02:53.520
cons that builds pairs.

01:02:53.520 --> 01:02:56.470
But what did I really
tell you about?

01:02:56.470 --> 01:02:59.510
If you go back and said,
let's look on this slide,

01:02:59.510 --> 01:03:02.570
all I really told
you about pairs

01:03:02.570 --> 01:03:05.680
is that there happens to be
this property, these properties

01:03:05.680 --> 01:03:07.510
of cons, car, and
cdr. And all I really

01:03:07.510 --> 01:03:10.350
said about pairs is that
there's a thing called cons,

01:03:10.350 --> 01:03:14.870
and a thing called car,
and a thing called cdr.

01:03:14.870 --> 01:03:17.750
And it is the case that
if I build cons of x, y

01:03:17.750 --> 01:03:20.710
and take car of it, I get x.

01:03:20.710 --> 01:03:25.810
And if I build cons of x, y
and get cdr of it, I get y.

01:03:25.810 --> 01:03:31.602
And even though I lulled you
into thinking that there's

01:03:31.602 --> 01:03:34.060
something in Lisp that does
that, so you pretended you knew

01:03:34.060 --> 01:03:36.330
what it was, in fact, I
didn't tell you any more

01:03:36.330 --> 01:03:39.750
about pairs than this tells
you about rational numbers.

01:03:39.750 --> 01:03:41.050
It's just some axiom for pairs.

01:03:44.720 --> 01:03:49.060
Well, to drive that
home, let me really

01:03:49.060 --> 01:03:56.120
scare you, and show you what we
might build pairs in terms of.

01:03:56.120 --> 01:03:58.280
And what you're going
to see is that we

01:03:58.280 --> 01:04:01.890
can build rational
numbers, and line segments,

01:04:01.890 --> 01:04:04.780
and vectors, and all of this
stuff in terms of pairs,

01:04:04.780 --> 01:04:06.930
and we're going to see
below here that pairs can

01:04:06.930 --> 01:04:10.680
be built out of nothing at all.

01:04:10.680 --> 01:04:12.680
Pure abstraction.

01:04:12.680 --> 01:04:17.620
So let me show you on this
slide an implementation

01:04:17.620 --> 01:04:23.080
of cons, car, and cdr. And we'll
look at it again in a second,

01:04:23.080 --> 01:04:26.880
but notice that their procedure
definitions of cons, car,

01:04:26.880 --> 01:04:30.170
and cdr, you don't see any
data in there, what you see

01:04:30.170 --> 01:04:34.720
is a lambda.

01:04:34.720 --> 01:04:38.840
So cons here is
going to return--

01:04:38.840 --> 01:04:41.660
is a procedure that
returns a procedure, just

01:04:41.660 --> 01:04:44.630
like AVERAGE DAMP.

01:04:44.630 --> 01:04:49.050
Cons of a and b returns a
procedure of an argument

01:04:49.050 --> 01:04:54.825
called pick, and it says,
if pick is equal to 1,

01:04:54.825 --> 01:04:58.940
I'm going to return a,
and if pick is equal to 2,

01:04:58.940 --> 01:05:00.870
I'm going to return
b, and that's

01:05:00.870 --> 01:05:02.000
what cons is going to be.

01:05:04.810 --> 01:05:10.850
Car of a thing x,
car of a pair x,

01:05:10.850 --> 01:05:12.304
is going to be x applied to 1.

01:05:12.304 --> 01:05:13.470
And notice that makes sense.

01:05:13.470 --> 01:05:16.690
You might not understand why
or how I'm doing such a thing,

01:05:16.690 --> 01:05:19.820
but at least it makes sense,
because the thing constructed

01:05:19.820 --> 01:05:24.630
by cons is a procedure,
and car applies that to 1.

01:05:24.630 --> 01:05:29.370
And similarly, cdr
applies that thing to 2.

01:05:29.370 --> 01:05:33.290
OK, now I claimed that this is
a representation of cons, car,

01:05:33.290 --> 01:05:35.780
and cdr, and notice
there's no data in it.

01:05:35.780 --> 01:05:37.190
All right, it's
built out of air.

01:05:37.190 --> 01:05:39.600
It's just procedures.

01:05:39.600 --> 01:05:43.640
There's no data objects at
all in that representation.

01:05:43.640 --> 01:05:45.140
Well, what could
that possibly mean?

01:05:49.690 --> 01:05:54.320
Well, if you really
believe this stuff,

01:05:54.320 --> 01:05:57.060
then you have to
believe that in order

01:05:57.060 --> 01:05:59.390
to show that that's a
representation for cons, car,

01:05:59.390 --> 01:06:01.140
and cdr, all I
have to do is show

01:06:01.140 --> 01:06:03.550
that it satisfies the axiom.

01:06:03.550 --> 01:06:05.410
See, all I should have
to convince you of

01:06:05.410 --> 01:06:22.310
is, for example, that gee,
that car of cons of 37 and 49

01:06:22.310 --> 01:06:28.060
is 37 for arbitrary
values of 37 and 49.

01:06:28.060 --> 01:06:29.070
And cdr the same way.

01:06:32.070 --> 01:06:34.430
See, if I really can
demonstrate to you

01:06:34.430 --> 01:06:37.430
that that weird procedure
definition, in terms

01:06:37.430 --> 01:06:41.810
of [? air ?], has the property
that it satisfies this,

01:06:41.810 --> 01:06:43.880
then you just have
to grant me that that

01:06:43.880 --> 01:06:47.970
is a possible implementation of
cons, car, and cdr, on which I

01:06:47.970 --> 01:06:49.939
can build everything else.

01:06:49.939 --> 01:06:50.980
Well, let's look at that.

01:06:50.980 --> 01:06:53.820
And this will be practice
in the substitution model.

01:06:59.320 --> 01:07:00.549
How could we check this?

01:07:00.549 --> 01:07:01.840
We sort of know how to do that.

01:07:01.840 --> 01:07:05.811
It's just the same
substitution model.

01:07:05.811 --> 01:07:06.310
Let's look.

01:07:06.310 --> 01:07:11.120
We start out, and we say,
what's car of cons of 37 and 49?

01:07:11.120 --> 01:07:11.720
What do we do?

01:07:11.720 --> 01:07:13.085
Cons is some procedure.

01:07:15.950 --> 01:07:19.530
Its value is cons was
a procedure of a and b.

01:07:19.530 --> 01:07:23.440
The thing returned by
cons is its procedure body

01:07:23.440 --> 01:07:27.370
with 37 and 49 substituted
for the parameters.

01:07:27.370 --> 01:07:32.770
It'll be 37 substituted for
a and 49 substituted for b.

01:07:32.770 --> 01:07:37.170
So this expression has the same
meaning as this expression.

01:07:37.170 --> 01:07:40.270
Its car of, and the body
of cons was this thing

01:07:40.270 --> 01:07:43.190
that started with lambda.

01:07:43.190 --> 01:07:46.090
And it says, so if
pick is equal to 1,

01:07:46.090 --> 01:07:47.630
where pick is this
other argument,

01:07:47.630 --> 01:07:51.450
if pick is equal to 1, it's
37, that's where a was,

01:07:51.450 --> 01:07:55.240
and if pick is
equal to 2, it's 49.

01:07:55.240 --> 01:07:56.410
So that's the first step.

01:07:56.410 --> 01:07:59.190
I'm just going through
mechanical substitution.

01:07:59.190 --> 01:08:00.940
And remember, at this
point in the course,

01:08:00.940 --> 01:08:02.690
if you're confused
about what things mean,

01:08:02.690 --> 01:08:05.480
go mechanically through
the substitution model.

01:08:05.480 --> 01:08:07.920
Well, what is this reduced to?

01:08:07.920 --> 01:08:15.050
Car said, take your argument,
which in this case is this,

01:08:15.050 --> 01:08:16.060
and apply it to 1.

01:08:16.060 --> 01:08:17.979
That was the definition of car.

01:08:17.979 --> 01:08:22.370
So if I look at car, if
I do that, the answer is,

01:08:22.370 --> 01:08:25.165
well, it's that argument,
this was the argument to car,

01:08:25.165 --> 01:08:26.319
applied to 1.

01:08:29.580 --> 01:08:31.140
Well, what does that mean?

01:08:31.140 --> 01:08:33.970
I take 1, and I
substitute it in the body

01:08:33.970 --> 01:08:36.120
here for this value
of pick, which

01:08:36.120 --> 01:08:39.779
is the name of the
argument, what do I get?

01:08:39.779 --> 01:08:43.390
Well, I get the thing that
says if 1 equals 1 it's 37,

01:08:43.390 --> 01:08:46.700
and if 1 equals 2 it's
49, so the answer's 37.

01:08:46.700 --> 01:08:49.880
And similarly, if I'd taken
cdr, that would apply it to 2,

01:08:49.880 --> 01:08:51.729
and I'd get 49.

01:08:51.729 --> 01:08:53.810
So you see, what
I've demonstrated

01:08:53.810 --> 01:08:57.560
is that that completely weird
implementation of cons, car,

01:08:57.560 --> 01:09:00.120
and cdr, satisfies the axioms.

01:09:00.120 --> 01:09:02.640
So it's a perfectly
valid way of building,

01:09:02.640 --> 01:09:05.417
in fact, all of the data objects
we're going to see in Lisp.

01:09:05.417 --> 01:09:07.000
So they all, if you
like, can be built

01:09:07.000 --> 01:09:09.670
on sort of existential nothing.

01:09:09.670 --> 01:09:14.229
And as far as you know,
that's how it works.

01:09:14.229 --> 01:09:15.149
You couldn't tell.

01:09:15.149 --> 01:09:17.856
If all you're ever
going to do with pairs

01:09:17.856 --> 01:09:20.439
is construct them with cons and
look at them with car and cdr,

01:09:20.439 --> 01:09:23.946
you couldn't possibly
tell how this thing works.

01:09:23.946 --> 01:09:26.529
Now, it might give you a sort
of warm feeling inside if I say,

01:09:26.529 --> 01:09:29.470
well, yeah, in fact, for
various reasons there happens

01:09:29.470 --> 01:09:31.770
to be a primitive called
cons, car, and cdr,

01:09:31.770 --> 01:09:34.950
and if it's too scary, if this
kind of stuff is too scary,

01:09:34.950 --> 01:09:36.770
you don't have to
look inside of it.

01:09:36.770 --> 01:09:39.069
So that might make
you feel better,

01:09:39.069 --> 01:09:41.792
but the point is, it
really could work this way,

01:09:41.792 --> 01:09:43.250
and it wouldn't
make any difference

01:09:43.250 --> 01:09:46.590
to the system at all.

01:09:46.590 --> 01:09:48.640
So in some sense, we
don't need data at all

01:09:48.640 --> 01:09:51.760
to build these
data abstractions.

01:09:51.760 --> 01:09:54.860
We can do everything
in terms of procedures.

01:09:54.860 --> 01:09:57.500
OK, well, why did I
terrify you in this way?

01:09:57.500 --> 01:09:59.130
First, I really
want to reinforce

01:09:59.130 --> 01:10:02.800
this idea of abstraction,
that you really

01:10:02.800 --> 01:10:06.220
can do these things abstractly.

01:10:06.220 --> 01:10:10.200
Secondly, I want to
introduce an idea

01:10:10.200 --> 01:10:14.430
we're going to see more and
more of in this course, which

01:10:14.430 --> 01:10:17.440
is we're going to blur the
line between what's data

01:10:17.440 --> 01:10:19.715
and what's a procedure.

01:10:19.715 --> 01:10:21.840
See, in this funny
implementation

01:10:21.840 --> 01:10:25.060
it turned out that
cons of something

01:10:25.060 --> 01:10:27.320
happened to be represented
in terms of a procedure,

01:10:27.320 --> 01:10:29.080
even though we
think of it as data.

01:10:31.940 --> 01:10:34.630
While here that's sort
of a mathematical trick,

01:10:34.630 --> 01:10:36.350
but one of the
things we'll see is

01:10:36.350 --> 01:10:38.540
that a lot of the very
important programming

01:10:38.540 --> 01:10:42.150
techniques that we're
going to get to sort of

01:10:42.150 --> 01:10:44.400
depend very
crucially on blurring

01:10:44.400 --> 01:10:47.580
this traditional line between
what you consider a procedure

01:10:47.580 --> 01:10:48.950
and what you consider data.

01:10:48.950 --> 01:10:52.495
We're going to see more and more
of that, especially next time.

01:10:52.495 --> 01:10:55.190
OK, questions?

01:10:55.190 --> 01:10:56.770
AUDIENCE: If you
asked the system

01:10:56.770 --> 01:11:00.720
to print a, what would happen?

01:11:00.720 --> 01:11:04.390
PROFESSOR: The question
is, what would happen if I

01:11:04.390 --> 01:11:05.600
asked the system to print a.

01:11:05.600 --> 01:11:10.200
Given this representation,
you already know the answer.

01:11:10.200 --> 01:11:18.485
The answer is compound procedure
a, just like last time.

01:11:21.170 --> 01:11:22.590
It'd say compound procedure.

01:11:25.129 --> 01:11:26.420
It might say a little bit more.

01:11:26.420 --> 01:11:29.620
It might say compound procedure
lambda or something or other,

01:11:29.620 --> 01:11:31.730
depending on details
of how I named it.

01:11:31.730 --> 01:11:33.070
But it's a procedure.

01:11:33.070 --> 01:11:34.890
And the only reason
for that is I

01:11:34.890 --> 01:11:37.620
haven't told the
system anything special

01:11:37.620 --> 01:11:40.220
about how to print such things.

01:11:40.220 --> 01:11:43.500
Now, it's in fact true that
with the actual implementation

01:11:43.500 --> 01:11:45.270
of cons that to be
built in the system,

01:11:45.270 --> 01:11:46.840
it would print something else.

01:11:46.840 --> 01:11:48.890
It would print,
say, this is a pair.

01:11:53.500 --> 01:11:58.410
AUDIENCE: When you
define cons, and then you

01:11:58.410 --> 01:12:01.840
pass it into values,
how does it know

01:12:01.840 --> 01:12:05.700
where to look for the cons,
because you can use cons

01:12:05.700 --> 01:12:07.220
over and over again?

01:12:07.220 --> 01:12:11.285
How does it know where to
look to know which a and b

01:12:11.285 --> 01:12:13.500
it's supposed to pull back out?

01:12:13.500 --> 01:12:17.140
I don't know if I'm
expressing that quite right.

01:12:17.140 --> 01:12:19.120
Where is it stored?

01:12:19.120 --> 01:12:23.660
PROFESSOR: OK, the
question is, I sort of have

01:12:23.660 --> 01:12:27.370
a cons with a 37 and a 49,
and I might make another cons

01:12:27.370 --> 01:12:29.766
with a 1 and a 2, and I
might have one called a,

01:12:29.766 --> 01:12:31.817
and I might have one called b.

01:12:31.817 --> 01:12:33.400
And the question is,
how does it know?

01:12:33.400 --> 01:12:35.275
And why don't they get confused?

01:12:35.275 --> 01:12:37.510
And that's a very good question.

01:12:40.820 --> 01:12:43.410
See, you have to really
believe that the procedures are

01:12:43.410 --> 01:12:45.550
objects.

01:12:45.550 --> 01:12:49.340
It's sort of like saying-- let's
try another simpler example.

01:12:49.340 --> 01:12:51.190
Suppose I ask for
the square root of 3.

01:12:55.760 --> 01:12:58.260
So I asked for the
square root of 5,

01:12:58.260 --> 01:13:00.826
and then I ask for
the square of 20.

01:13:06.216 --> 01:13:07.590
You're probably
not the least bit

01:13:07.590 --> 01:13:10.480
bothered that I can take
square root and apply it to 5,

01:13:10.480 --> 01:13:14.624
and then I can take square
root and apply it to 20.

01:13:14.624 --> 01:13:16.040
And there's sort
of no issue, gee,

01:13:16.040 --> 01:13:17.790
doesn't it get confused
about whether it's

01:13:17.790 --> 01:13:19.630
working on 5 or 20?

01:13:19.630 --> 01:13:22.630
There's no issue about
that because you're

01:13:22.630 --> 01:13:26.600
thinking of a procedure which
goes off and does something.

01:13:26.600 --> 01:13:30.410
Now, in some sense you're
asking me the same question.

01:13:30.410 --> 01:13:32.750
But it's really bothering
you, and it's bothering you

01:13:32.750 --> 01:13:34.140
for a really good reason.

01:13:34.140 --> 01:13:36.990
Because when I write that,
you're saying gee, this is,

01:13:36.990 --> 01:13:38.300
I know, sort of a procedure.

01:13:38.300 --> 01:13:40.250
But it's not a procedure
that's just running.

01:13:40.250 --> 01:13:42.600
It's just sort of a
procedure sitting there.

01:13:42.600 --> 01:13:46.960
And how can it be that sometimes
this procedure has 37 and 49,

01:13:46.960 --> 01:13:49.740
and there might be another one
which has 5 and 6 in there,

01:13:49.740 --> 01:13:52.630
and why don't they get confused?

01:13:52.630 --> 01:13:58.990
So there's something very, very
important that's bothering you.

01:13:58.990 --> 01:14:01.380
And it's really crucial
to what's going on.

01:14:01.380 --> 01:14:06.280
We're suddenly saying that
procedures are not just the act

01:14:06.280 --> 01:14:08.290
of doing something.

01:14:08.290 --> 01:14:11.940
Procedures are conceptual
entities, objects,

01:14:11.940 --> 01:14:14.910
and if I built
cons of 37 and 49,

01:14:14.910 --> 01:14:18.070
that's a particular
procedure that sits there.

01:14:18.070 --> 01:14:21.312
And it's different
from cons of 3 and 4.

01:14:21.312 --> 01:14:23.020
That's another procedure
that sits there.

01:14:23.020 --> 01:14:24.060
AUDIENCE: Both of them
exist independently.

01:14:24.060 --> 01:14:25.610
PROFESSOR: And
exists independently.

01:14:25.610 --> 01:14:28.370
AUDIENCE: And they both can
be referenced by car and cdr.

01:14:28.370 --> 01:14:30.870
PROFESSOR: And they both would
be referenced by car and cdr.

01:14:30.870 --> 01:14:35.290
Just like I could
increment this,

01:14:35.290 --> 01:14:38.270
and I could increment that.

01:14:38.270 --> 01:14:39.960
They're objects.

01:14:39.960 --> 01:14:41.730
And that's sort of
where we're going.

01:14:41.730 --> 01:14:43.280
See, the fact that you're
asking the question

01:14:43.280 --> 01:14:44.654
shows that you're
really starting

01:14:44.654 --> 01:14:47.790
to think about the implications
of what's going on.

01:14:47.790 --> 01:14:50.700
It's the difference between
saying a procedure is just

01:14:50.700 --> 01:14:53.070
the act of doing something.

01:14:53.070 --> 01:14:56.270
And a procedure is a real
object that has existence.

01:14:56.270 --> 01:14:58.377
AUDIENCE: So when the
procedure gets built,

01:14:58.377 --> 01:15:01.050
the actual values are now
substituted for a and b--

01:15:01.050 --> 01:15:02.050
PROFESSOR: That's right.

01:15:02.050 --> 01:15:04.870
AUDIENCE: And then that
procedure exists as lambda,

01:15:04.870 --> 01:15:07.720
and pick is what's
actually passed in.

01:15:07.720 --> 01:15:11.850
PROFESSOR: Yes, when cons gets
called, and the result of cons

01:15:11.850 --> 01:15:13.530
is a new procedure
that's constructed,

01:15:13.530 --> 01:15:17.080
that new procedure has an
argument that's called pick.

01:15:17.080 --> 01:15:18.830
AUDIENCE: But it no
longer has an a and b.

01:15:18.830 --> 01:15:20.820
The a and b are the actual
values that are passed through.

01:15:20.820 --> 01:15:23.320
PROFESSOR: And it has-- right,
according to the substitution

01:15:23.320 --> 01:15:26.340
model, what it now has is not
those arbitrary names a and b,

01:15:26.340 --> 01:15:31.187
it somehow has that
37 and 49 in there.

01:15:31.187 --> 01:15:33.520
But you're right, that's a
hard thing to think about it,

01:15:33.520 --> 01:15:35.103
and it's different
from the way you've

01:15:35.103 --> 01:15:36.500
been thinking about procedures.

01:15:36.500 --> 01:15:38.975
AUDIENCE: And if I have
again cons of 37 and 49,

01:15:38.975 --> 01:15:41.300
it's a different object?

01:15:41.300 --> 01:15:51.790
PROFESSOR: And if you make
another cons of 37 and 49,

01:15:51.790 --> 01:15:54.390
you're into a wonderful
philosophical problem, which

01:15:54.390 --> 01:15:57.730
is going to be what the
lecture about halfway

01:15:57.730 --> 01:16:00.080
through this course is about.

01:16:00.080 --> 01:16:03.340
Which is, if I cons 37
and 49, and I do it again,

01:16:03.340 --> 01:16:06.490
is that the same thing, or
is it a different thing?

01:16:06.490 --> 01:16:07.680
And how could you tell?

01:16:07.680 --> 01:16:10.240
And when could it
possibly matter?

01:16:10.240 --> 01:16:21.140
And that's sort of like saying,
is that the same thing as this?

01:16:21.140 --> 01:16:23.850
Or is this the
same thing as that?

01:16:23.850 --> 01:16:25.150
It's the same kind of question.

01:16:25.150 --> 01:16:27.930
And that's a very,
very deep question.

01:16:27.930 --> 01:16:30.180
And I can't answer
in less than an hour.

01:16:30.180 --> 01:16:31.770
But we will.