WEBVTT

00:00:07.000 --> 00:00:10.000
We're going to talk about
shortest paths,

00:00:10.000 --> 00:00:14.000
and we're going to talk about
shortest paths for three

00:00:14.000 --> 00:00:17.000
lectures.
So, this is a trilogy.

00:00:17.000 --> 00:00:20.000
Today will be Shortest Paths
One.

00:00:20.000 --> 00:00:25.000
I've been watching far too many
versions of Star Wars this

00:00:25.000 --> 00:00:28.000
weekend.
I saw the musical yesterday,

00:00:28.000 --> 00:00:31.000
matinee.
That was an MIT musical.

00:00:31.000 --> 00:00:35.000
That was fun,
of all three movies in about

00:00:35.000 --> 00:00:38.000
four hours.
That was a bit long and then I

00:00:38.000 --> 00:00:42.000
saw the one-man show on Friday.
One-man Star Wars:

00:00:42.000 --> 00:00:45.000
the original three movies in
one hour.

00:00:45.000 --> 00:00:48.000
That was the opposite of too
long.

00:00:48.000 --> 00:00:51.000
Both were fun.
So I get my trilogy fix.

00:00:51.000 --> 00:00:54.000
All episodes,
first we're going to start with

00:00:54.000 --> 00:00:58.000
The New Hope,
and we're going to talk about

00:00:58.000 --> 00:01:02.000
the shortest paths problem and
solve one particular problem of

00:01:02.000 --> 00:01:09.000
it, a very interesting version.
And then we're going to look at

00:01:09.000 --> 00:01:12.000
increasingly more general
versions as we go on.

00:01:12.000 --> 00:01:15.000
Shortest paths are sort of an
application of dynamic

00:01:15.000 --> 00:01:19.000
programming, which we saw last
week, and greedy algorithms,

00:01:19.000 --> 00:01:23.000
which we also saw last week.
So, were going to build that

00:01:23.000 --> 00:01:27.000
and get some pretty interesting
algorithms for an important

00:01:27.000 --> 00:01:30.000
problem, which is how to get
from Alderon to,

00:01:30.000 --> 00:01:33.000
I don't know,
Cambridge as quickly as

00:01:33.000 --> 00:01:37.000
possible, OK,
when you live in a graph.

00:01:37.000 --> 00:01:41.000
So, there's geometric shortest
paths which is a little bit

00:01:41.000 --> 00:01:44.000
harder.
Here, we're just going to look

00:01:44.000 --> 00:01:48.000
at shortest paths in graphs.
Now, hopefully you all know

00:01:48.000 --> 00:01:52.000
what a path in a graph is.
But, so, very quick review in

00:01:52.000 --> 00:01:56.000
particular because we're going
to be looking at weighted

00:01:56.000 --> 00:01:59.000
graphs.
So, the usual setup:

00:01:59.000 --> 00:02:03.000
suppose we have directed graph,
G, have some vertices,

00:02:03.000 --> 00:02:07.000
some edges.
We have edge weights,

00:02:07.000 --> 00:02:12.000
make it a little more
interesting.

00:02:12.000 --> 00:02:18.000
So, this is just a real number
on each edge.

00:02:18.000 --> 00:02:25.000
So, edge weights are usually
given by function,

00:02:25.000 --> 00:02:27.000
w.
For every edge,

00:02:27.000 --> 00:02:32.000
you get a real number.

00:02:40.000 --> 00:02:43.000
And then, if we look at the
paths in the graph,

00:02:43.000 --> 00:02:47.000
so we're going to use some
simple notation for paths called

00:02:47.000 --> 00:02:51.000
a path, p, starts at some
vertex, and it goes to some

00:02:51.000 --> 00:02:52.000
other vertex,
and so on.

00:02:52.000 --> 00:02:56.000
Say the last vertex is v_k,
and each of these should be a

00:02:56.000 --> 00:03:00.000
directed edge in the digraph.
So, this is a directed path.

00:03:00.000 --> 00:03:04.000
It has to respect edges in
here.

00:03:04.000 --> 00:03:10.000
And, we'll say that the weight
of such a path is just the sum

00:03:10.000 --> 00:03:14.000
of the weights of the edges
along the path.

00:03:14.000 --> 00:03:18.000
And, we'll call that w(p).
This is sum,

00:03:18.000 --> 00:03:23.000
i equals one to k minus one of
w(v_i, v_(i+1)) plus one.

00:03:23.000 --> 00:03:27.000
OK, so just to rub it in,
and in particular,

00:03:27.000 --> 00:03:32.000
how general this can be,
we have some path,

00:03:32.000 --> 00:03:37.000
it starts at some vertex,
there's some edge weights along

00:03:37.000 --> 00:03:42.000
the way.
This is some arbitrary path in

00:03:42.000 --> 00:03:46.000
the graph, in some hypothetical
graph.

00:03:58.000 --> 00:04:01.000
OK, this is mainly to point out
that some of the edge weights

00:04:01.000 --> 00:04:04.000
could be negative.
Some of them could be zero.

00:04:04.000 --> 00:04:08.000
This sum here is minus two.
So, the weight of this path is

00:04:08.000 --> 00:04:09.000
minus two.
And, presumably,

00:04:09.000 --> 00:04:12.000
the graph is much bigger than
this.

00:04:12.000 --> 00:04:14.000
This is just one path in the
graph.

00:04:14.000 --> 00:04:18.000
We're usually thinking about
simple paths that can't repeat a

00:04:18.000 --> 00:04:20.000
vertex.
But, sometimes we allow that.

00:04:20.000 --> 00:04:23.000
And then, what we care about is
the shortest path,

00:04:23.000 --> 00:04:26.000
or a shortest path.
Again, this may not be unique,

00:04:26.000 --> 00:04:31.000
but we'll still usually call it
the shortest path.

00:04:31.000 --> 00:04:36.000
So, we want the shortest path
from some A to some B.

00:04:36.000 --> 00:04:39.000
Or, we'll call the vertices u
and v.

00:04:39.000 --> 00:04:45.000
And we want this to be some
path of minimum possible weight,

00:04:45.000 --> 00:04:49.000
subject to starting at u,
and going to v.

00:04:49.000 --> 00:04:53.000
OK, so that's what we're
looking for.

00:04:53.000 --> 00:04:58.000
In general, give you a vertex,
u, give you a vertex,

00:04:58.000 --> 00:05:04.000
v, find a shortest path as
quickly as possible.

00:05:04.000 --> 00:05:06.000
What's a good algorithm for
that?

00:05:06.000 --> 00:05:10.000
That's the topic for the next
three lectures.

00:05:10.000 --> 00:05:15.000
We'll usually think about a
slightly simpler problem,

00:05:15.000 --> 00:05:19.000
which is just computing the
weight of that path,

00:05:19.000 --> 00:05:24.000
which is essentially computing
the distance from A to B.

00:05:24.000 --> 00:05:28.000
So, we'll call this the
shortest path weight from u to

00:05:28.000 --> 00:05:33.000
v.
And, we'll denote it by delta

00:05:33.000 --> 00:05:38.000
of (u,v), delta .
So, I mean, it's the weight of

00:05:38.000 --> 00:05:43.000
the shortest path,
or a weight of every shortest

00:05:43.000 --> 00:05:45.000
path.
Or, in other words,

00:05:45.000 --> 00:05:51.000
it's the Min over the weight of
each path from u to v.

00:05:51.000 --> 00:05:56.000
So, p here is a path.
OK, so you just consider,

00:05:56.000 --> 00:06:02.000
there could be a lot of
different paths.

00:06:02.000 --> 00:06:04.000
There could,
in principle,

00:06:04.000 --> 00:06:09.000
be infinitely many,
if you're allowed to repeat

00:06:09.000 --> 00:06:13.000
vertices.
You look at all those paths

00:06:13.000 --> 00:06:17.000
hypothetically.
You take the minimum weight.

00:06:17.000 --> 00:06:19.000
Question?
Good.

00:06:19.000 --> 00:06:25.000
My next question was going to
be, when do shortest paths not

00:06:25.000 --> 00:06:28.000
exist?
And you've hit upon one

00:06:28.000 --> 00:06:36.000
version, which is when you have
negative edge weights.

00:06:36.000 --> 00:06:40.000
So, in principle,
when you have negative edge

00:06:40.000 --> 00:06:45.000
weights, some shortest paths may
not exist in the sense that

00:06:45.000 --> 00:06:50.000
there is no shortest paths.
There are no shortest paths.

00:06:50.000 --> 00:06:54.000
There is no shortest path from
u to v.

00:06:54.000 --> 00:06:58.000
OK, in particular,
if I have two vertices,

00:06:58.000 --> 00:07:02.000
u and v, and I want the
shortest path between them,

00:07:02.000 --> 00:07:06.000
and I have negative edge
weights, well,

00:07:06.000 --> 00:07:12.000
this is fine.
I mean, I can still compute the

00:07:12.000 --> 00:07:17.000
weight of a path that has
negative weights.

00:07:17.000 --> 00:07:24.000
But when specifically won't I
have a single shortest path from

00:07:24.000 --> 00:07:26.000
u to v?
So, go ahead.

00:07:26.000 --> 00:07:29.000
Good.
So, if I can find the cycle

00:07:29.000 --> 00:07:34.000
somewhere along here whose total
weight, say, the sum of all the

00:07:34.000 --> 00:07:37.000
weights of these images is
negative, then I get there,

00:07:37.000 --> 00:07:40.000
I go around as many times as I
want.

00:07:40.000 --> 00:07:44.000
I keep decreasing the weight
because the weight is negative.

00:07:44.000 --> 00:07:48.000
I decrease it by some fixed
amount, and then I can go to v.

00:07:48.000 --> 00:07:52.000
So, as long as there is a
negative weights cycle reachable

00:07:52.000 --> 00:07:56.000
from u that can also reach v,
then there's no shortest path

00:07:56.000 --> 00:08:00.000
because if I take any particular
path, I can make it shorter by

00:08:00.000 --> 00:08:04.000
going around a couple more
times.

00:08:04.000 --> 00:08:07.000
So, in some sense,
this is not really a minimum.

00:08:07.000 --> 00:08:11.000
It's more like an infimum for
those who like to get fancy

00:08:11.000 --> 00:08:14.000
about such things.
But we'll just say that delta

00:08:14.000 --> 00:08:16.000
of (u,v) is minus infinity in
this case.

00:08:16.000 --> 00:08:19.000
There's a negative weights
cycle from u to v.

00:08:19.000 --> 00:08:23.000
So, that's one case we have to
worry about in some sense.

00:08:23.000 --> 00:08:27.000
But, as long as there are no
negative weight cycles,

00:08:27.000 --> 00:08:30.000
delta of (u,v) will be
something bigger than minus

00:08:30.000 --> 00:08:34.000
infinity, bounded below by some
finite value even if you could

00:08:34.000 --> 00:08:38.000
have negative weights,
but still no negative weights

00:08:38.000 --> 00:08:41.000
cycle for example,
there might not be any cycles

00:08:41.000 --> 00:08:45.000
in your graph.
So that's still interesting.

00:08:45.000 --> 00:08:50.000
And, I guess it's useful to
note that you can get from A to

00:08:50.000 --> 00:08:53.000
B in negative infinite time.
It's time travel,

00:08:53.000 --> 00:08:56.000
if the weights happen that
correspond to time.

00:08:56.000 --> 00:09:00.000
But when else might shortest
paths not exist?

00:09:00.000 --> 00:09:04.000
So, this is one case,
but there's another,

00:09:04.000 --> 00:09:07.000
simpler case.
It's not connected.

00:09:07.000 --> 00:09:12.000
There might not be any path
from u to v.

00:09:12.000 --> 00:09:17.000
This path might be empty.
There may be no path from u to

00:09:17.000 --> 00:09:21.000
v.
Here we have to define what

00:09:21.000 --> 00:09:25.000
happens, and here,
we'll say it's infinity if

00:09:25.000 --> 00:09:32.000
there's no path from u to v.
So, there are these exceptional

00:09:32.000 --> 00:09:35.000
cases plus infinity and minus
infinity, which are pretty

00:09:35.000 --> 00:09:39.000
intuitive because it takes a
really long time to get from u

00:09:39.000 --> 00:09:44.000
to v if there's no path there.
You can't get there from here.

00:09:44.000 --> 00:09:47.000
OK, but that's the definition.
Most of the time,

00:09:47.000 --> 00:09:50.000
this is the case we care about,
of course.

00:09:50.000 --> 00:09:53.000
Usually this is a finite set.
OK, good, so that's the

00:09:53.000 --> 00:09:56.000
definition.
We're going to get a few basic

00:09:56.000 --> 00:10:00.000
structural properties about
shortest paths that will allow

00:10:00.000 --> 00:10:04.000
us to obtain good algorithms
finding these paths when they

00:10:04.000 --> 00:10:07.000
exist.
And, in particular,

00:10:07.000 --> 00:10:10.000
we want to use ideas from
dynamic programming.

00:10:10.000 --> 00:10:14.000
So, if I want to use dynamic
programming to solve shortest

00:10:14.000 --> 00:10:17.000
paths, what do I need to
establish?

00:10:17.000 --> 00:10:19.000
What's the first thing I should
check?

00:10:19.000 --> 00:10:23.000
You've all implemented dynamic
programming by now,

00:10:23.000 --> 00:10:27.000
so should make complete sense
hopefully, at least more sense

00:10:27.000 --> 00:10:30.000
than it did a couple of weeks
ago, last week,

00:10:30.000 --> 00:10:34.000
when we learned it.
Dynamic programming is

00:10:34.000 --> 00:10:39.000
something that grows on you.
Every year I think I understand

00:10:39.000 --> 00:10:42.000
it better than the previous
year.

00:10:42.000 --> 00:10:45.000
But, in particular,
when you learned dynamic

00:10:45.000 --> 00:10:50.000
programming in this class,
there is this nice key property

00:10:50.000 --> 00:10:52.000
that you should check.
Yeah?

00:10:52.000 --> 00:10:54.000
Optimal substructure:
good.

00:10:54.000 --> 00:10:58.000
This is the phrase you should
keep in mind.

00:10:58.000 --> 00:11:03.000
It's not really enough for
dynamic programming to be useful

00:11:03.000 --> 00:11:07.000
in an efficient way,
but it at least tells you that

00:11:07.000 --> 00:11:12.000
you should be able to try to
apply it.

00:11:12.000 --> 00:11:15.000
That's a pretty weak statement,
but it's something that you

00:11:15.000 --> 00:11:18.000
should check.
It's definitely pretty much a

00:11:18.000 --> 00:11:22.000
necessary condition for dynamic
programming to make sense.

00:11:22.000 --> 00:11:26.000
And so, optimal some structure
here means that if I take some

00:11:26.000 --> 00:11:29.000
shortest path,
and I look at a subpath of that

00:11:29.000 --> 00:11:32.000
shortest path,
I claimed that it too is a

00:11:32.000 --> 00:11:34.000
shortest path,
OK, with its respective

00:11:34.000 --> 00:11:39.000
endpoints; obviously not between
the same endpoints.

00:11:39.000 --> 00:11:43.000
But if I have some shortest
path between two endpoints,

00:11:43.000 --> 00:11:47.000
I take any subpath and that's
also the shortest path.

00:11:47.000 --> 00:11:51.000
This is one version of optimal
substructure.

00:11:51.000 --> 00:11:55.000
This one turns out to be true
for this setup.

00:11:55.000 --> 00:11:59.000
And, how should I prove an
optimal substructure property?

00:11:59.000 --> 00:12:04.000
Cut and paste.
Yep, that works here too.

00:12:04.000 --> 00:12:09.000
I mean, this isn't always true.
But it's a good technique here.

00:12:09.000 --> 00:12:14.000
So, we're going to think about,
and I'll do essentially a proof

00:12:14.000 --> 00:12:17.000
by picture here.
So, suppose you have some

00:12:17.000 --> 00:12:22.000
subpath of some shortest path.
So, let's say the subpath is x

00:12:22.000 --> 00:12:25.000
to y.
And, the path goes from u to v.

00:12:25.000 --> 00:12:30.000
So, we assume that (u,v) is a
shortest path.

00:12:30.000 --> 00:12:33.000
We want to prove that (x,y) is
a shortest path.

00:12:33.000 --> 00:12:36.000
Well, suppose (x,y) isn't a
shortest path.

00:12:36.000 --> 00:12:40.000
Then there is some shorter path
that goes from x to y.

00:12:40.000 --> 00:12:45.000
But, if you have some shorter
path from x to y than this one.

00:12:45.000 --> 00:12:49.000
Then I should just erase this
part of the shortest path from u

00:12:49.000 --> 00:12:52.000
to v, and replace it with this
shorter one.

00:12:52.000 --> 00:12:56.000
So, this is some hypothetical
shorter path.

00:12:56.000 --> 00:12:59.000
So, suppose this existed.
If that existed,

00:12:59.000 --> 00:13:02.000
then I should just cut the old
path from x to y,

00:13:02.000 --> 00:13:07.000
and paste in this new one from
x to y.

00:13:07.000 --> 00:13:10.000
It's strictly shorter.
Therefore, I get a strictly

00:13:10.000 --> 00:13:14.000
shorter path from u to v.
But I assumed u to v was a

00:13:14.000 --> 00:13:16.000
shortest path:
contradiction.

00:13:16.000 --> 00:13:18.000
OK, so there is no shorter
path.

00:13:18.000 --> 00:13:21.000
And that proves the lemma that
we have this:

00:13:21.000 --> 00:13:25.000
subpaths of shortest paths are
shortest paths.

00:13:25.000 --> 00:13:29.000
OK, this should now be a pretty
familiar proof technique.

00:13:29.000 --> 00:13:34.000
But, there is yet another
instance of cut and paste.

00:13:34.000 --> 00:13:36.000
OK, so that's a good sign for
computing shortest paths.

00:13:36.000 --> 00:13:39.000
I mean, in terms of dynamic
programming, we won't look

00:13:39.000 --> 00:13:42.000
directly at dynamic programming
here because we are going to aim

00:13:42.000 --> 00:13:44.000
for greedy, which is even
stronger.

00:13:44.000 --> 00:13:47.000
But, next Monday we'll see some
dynamic programming approaches.

00:13:47.000 --> 00:13:49.000
Intuitively,
there are some pretty natural

00:13:49.000 --> 00:13:52.000
sub-problems here.
I mean, going from u to v,

00:13:52.000 --> 00:13:55.000
if I want to find what is the
shortest path from u to v,

00:13:55.000 --> 00:13:56.000
well, that's a particular
problem.

00:13:56.000 --> 00:13:59.000
Maybe it involves computing
shortest paths from u to some

00:13:59.000 --> 00:14:01.000
intermediate point,
x, and then from x to u,

00:14:01.000 --> 00:14:05.000
something like that.
That feels good.

00:14:05.000 --> 00:14:07.000
That's like,
quadratically,

00:14:07.000 --> 00:14:11.000
many subproblems.
And, V^2 subproblems,

00:14:11.000 --> 00:14:16.000
it sounds like that would lead
to a dynamic program.

00:14:16.000 --> 00:14:21.000
You can make it work out;
it's just a little bit trickier

00:14:21.000 --> 00:14:25.000
than that.
We'll see that next Monday.

00:14:25.000 --> 00:14:29.000
But thinking about this
intermediate point we get

00:14:29.000 --> 00:14:35.000
something called the triangle
inequality.

00:14:35.000 --> 00:14:40.000
So, you've probably heard some
form of the triangle inequality

00:14:40.000 --> 00:14:42.000
before.
It holds in all sorts of

00:14:42.000 --> 00:14:46.000
geometric spaces,
but it also holds for shortest

00:14:46.000 --> 00:14:51.000
paths, which is slightly less
obvious, or more obvious,

00:14:51.000 --> 00:14:54.000
I guess, depending on your
inclination.

00:14:54.000 --> 00:14:59.000
So, if you have any triple of
vertices, the shortest path from

00:14:59.000 --> 00:15:03.000
u to v is, at most,
the shortest path from u to x

00:15:03.000 --> 00:15:08.000
plus the shortest path from x to
v.

00:15:08.000 --> 00:15:10.000
Of course, here I need a
shortest path weight from u to

00:15:10.000 --> 00:15:12.000
x, and shortest path weight from
x to v.

00:15:12.000 --> 00:15:15.000
So, this should be pretty
natural just from the statement,

00:15:15.000 --> 00:15:18.000
even more natural if you draw
the picture.

00:15:18.000 --> 00:15:19.000
So, we have some vertex,
u.

00:15:19.000 --> 00:15:22.000
I'm using wiggly lines to
denote potentially long paths as

00:15:22.000 --> 00:15:24.000
opposed to edges.
We have some intermediate

00:15:24.000 --> 00:15:27.000
point, x, and we have some
target, v, and we are

00:15:27.000 --> 00:15:30.000
considering these three shortest
paths.

00:15:30.000 --> 00:15:35.000
This is the shortest path from
u to v, or this is its weights.

00:15:35.000 --> 00:15:38.000
This is the shortest path from
u to x.

00:15:38.000 --> 00:15:42.000
And here's its weight,
and the shortest path from x to

00:15:42.000 --> 00:15:44.000
v.
And here's its weight.

00:15:44.000 --> 00:15:48.000
And, the point is,
this should be the shortest

00:15:48.000 --> 00:15:51.000
path or a shortest path from u
to v.

00:15:51.000 --> 00:15:55.000
And, in particular,
one such path is you go from u

00:15:55.000 --> 00:16:00.000
to x, and then you go from x to
v.

00:16:00.000 --> 00:16:04.000
So, I mean, this sum is just
measuring the length of this

00:16:04.000 --> 00:16:07.000
particular path.
Take the shortest path here;

00:16:07.000 --> 00:16:12.000
take the shortest path here.
And, this is supposed to be the

00:16:12.000 --> 00:16:15.000
Min over all paths.
So, certainly this is,

00:16:15.000 --> 00:16:19.000
at most, this particular path,
the sum of these two values,

00:16:19.000 --> 00:16:22.000
OK, another proof by picture.
Clear?

00:16:22.000 --> 00:16:26.000
OK, this stuff is easy.
I assume we'll get into some

00:16:26.000 --> 00:16:31.000
more set exciting algorithms in
particular, which is always more

00:16:31.000 --> 00:16:36.000
exciting.
Today, we're going to look at a

00:16:36.000 --> 00:16:41.000
particular version of shortest
paths called,

00:16:41.000 --> 00:16:46.000
or the shortest paths problem
called the single source

00:16:46.000 --> 00:16:51.000
shortest path problem.
OK, it's a little bit more

00:16:51.000 --> 00:16:56.000
general than go from A to B.
The problem is,

00:16:56.000 --> 00:17:03.000
you're given a source vertex,
and you want to know how to get

00:17:03.000 --> 00:17:09.000
from that source vertex to
everywhere else.

00:17:09.000 --> 00:17:12.000
So, we'll call this source
vertex s.

00:17:12.000 --> 00:17:15.000
And from that source,
we want to find,

00:17:15.000 --> 00:17:21.000
let's say, the shortest path
weights from s to everyone.

00:17:21.000 --> 00:17:24.000
In particular,
we'd also like to know the

00:17:24.000 --> 00:17:30.000
shortest paths,
but that isn't too much harder.

00:17:30.000 --> 00:17:33.000
So, that's delta of s,
v for all vertices,

00:17:33.000 --> 00:17:35.000
v.
OK, so this is actually a

00:17:35.000 --> 00:17:39.000
little bit harder than the
problem we started with a

00:17:39.000 --> 00:17:41.000
getting from Alderon to
Cambridge.

00:17:41.000 --> 00:17:46.000
Now, we want to get from
Alderon to the entire universe.

00:17:46.000 --> 00:17:50.000
OK, it turns out,
this is one of the weird things

00:17:50.000 --> 00:17:53.000
about shortest paths,
according to the

00:17:53.000 --> 00:17:57.000
state-of-the-art we know today,
it seems like the following

00:17:57.000 --> 00:18:02.000
statement will remain true for
all time.

00:18:02.000 --> 00:18:05.000
But we don't know.
The best algorithms for solving

00:18:05.000 --> 00:18:08.000
the A to B problem,
given s, given t,

00:18:08.000 --> 00:18:11.000
go from s to t,
is no easier than this problem.

00:18:11.000 --> 00:18:15.000
It's the best ways we know how
to solve going from A to B is to

00:18:15.000 --> 00:18:18.000
solve how to go from A to
everywhere else.

00:18:18.000 --> 00:18:22.000
So, we sort of can't help
ourselves, but to solve this

00:18:22.000 --> 00:18:26.000
problem it turns out.
Today, we're going to look at a

00:18:26.000 --> 00:18:30.000
further restriction on this
problem because this is a bit

00:18:30.000 --> 00:18:34.000
tricky.
Will solve it next class.

00:18:34.000 --> 00:18:39.000
But, today we're going to get
rid of the negative weight cycle

00:18:39.000 --> 00:18:42.000
issue by forbidding negative
weights.

00:18:42.000 --> 00:18:47.000
So, we're going to assume that
all of the edge weights are

00:18:47.000 --> 00:18:50.000
nonnegative, so,
for all vertices,

00:18:50.000 --> 00:18:53.000
u and v.
So, in particular,

00:18:53.000 --> 00:18:58.000
shortest paths exist,
provided paths exist.

00:19:12.000 --> 00:19:15.000
And, we don't have to worry
about these minus infinities.

00:19:15.000 --> 00:19:18.000
Delta of (u,v) is always bigger
than minus infinity.

00:19:18.000 --> 00:19:21.000
It still might be plus infinity
if there is no path,

00:19:21.000 --> 00:19:23.000
but this will make life a lot
easier.

00:19:23.000 --> 00:19:26.000
And the algorithm we'll cover
today really requires this

00:19:26.000 --> 00:19:30.000
property.
You can't get away without it.

00:19:30.000 --> 00:19:36.000
Next class, we'll get away
without it with a fancier and

00:19:36.000 --> 00:19:40.000
slower algorithm.
So, as I hinted at,

00:19:40.000 --> 00:19:47.000
the main idea we're going to
use for the algorithm today is

00:19:47.000 --> 00:19:54.000
greedy, which should be faster
than dynamic programming

00:19:54.000 --> 00:19:58.000
generally.
And, the tricky part will be

00:19:58.000 --> 00:20:06.000
proving that the greedy
algorithm actually works.

00:20:06.000 --> 00:20:11.000
So, I think there's pretty much
only one natural way to go

00:20:11.000 --> 00:20:16.000
about, well, there's one way
that works to go about greedy,

00:20:16.000 --> 00:20:19.000
let's say.
This may be not the obvious

00:20:19.000 --> 00:20:22.000
one.
So, let me give you a little

00:20:22.000 --> 00:20:26.000
bit of setup.
The invariant we are going to

00:20:26.000 --> 00:20:31.000
maintain is that at all times,
we have estimates on the

00:20:31.000 --> 00:20:36.000
distances from the source to
every vertex.

00:20:36.000 --> 00:20:39.000
When I say distance,
I mean shortest path weight.

00:20:39.000 --> 00:20:43.000
I'm going to use weight and
distance interchangeably here

00:20:43.000 --> 00:20:46.000
for more intuition.
And, in particular,

00:20:46.000 --> 00:20:50.000
I want to maintain the set of
vertices where those estimates

00:20:50.000 --> 00:20:53.000
are actually the right answer.

00:21:10.000 --> 00:21:13.000
OK, this is little s.
This is big S.

00:21:13.000 --> 00:21:18.000
So, the big S will be the set
of all vertices where I know the

00:21:18.000 --> 00:21:21.000
answer.
What is the shortest path

00:21:21.000 --> 00:21:25.000
distance from little S to that
vertex in big S?

00:21:25.000 --> 00:21:29.000
So, for starters,
which distance do I know?

00:21:29.000 --> 00:21:31.000
Sorry?
s.

00:21:31.000 --> 00:21:34.000
I know the shortest path
distance from s to s because if

00:21:34.000 --> 00:21:37.000
I assume that all of my weights
are nonnegative,

00:21:37.000 --> 00:21:40.000
I really can't get from s to s
any faster than not doing

00:21:40.000 --> 00:21:43.000
anything.
OK, if I had a negative weight

00:21:43.000 --> 00:21:46.000
cycle, maybe the distance from s
to s is minus infinity.

00:21:46.000 --> 00:21:50.000
OK, but I can't have negative
weights so there's no way I can

00:21:50.000 --> 00:21:53.000
get from s to s any faster than
zero time.

00:21:53.000 --> 00:21:56.000
There might be a longer path
that still has zero cost,

00:21:56.000 --> 00:22:00.000
but it can't be any better than
zero.

00:22:00.000 --> 00:22:02.000
So, in particular,
I know that.

00:22:02.000 --> 00:22:05.000
So, initially,
S is certainly an s.

00:22:05.000 --> 00:22:09.000
OK, and the idea is we're going
to accumulate more and more

00:22:09.000 --> 00:22:14.000
vertices that we know.
So, at some point we know the

00:22:14.000 --> 00:22:16.000
distances from some of the
vertices.

00:22:16.000 --> 00:22:21.000
So, we have some cloud here.
This is S, and this is

00:22:21.000 --> 00:22:23.000
everything else.
This is the graph,

00:22:23.000 --> 00:22:26.000
G.
This is the subset of the

00:22:26.000 --> 00:22:29.000
vertices.
And, there's some edges that go

00:22:29.000 --> 00:22:33.000
out from there.
And, so we have estimates on

00:22:33.000 --> 00:22:36.000
how to get to these vertices.
Some of them,

00:22:36.000 --> 00:22:39.000
we may not have even seen yet.
They may not be connected to

00:22:39.000 --> 00:22:42.000
this portion of S.
I mean: not directly.

00:22:42.000 --> 00:22:44.000
They might be connected by some
longer path.

00:22:44.000 --> 00:22:48.000
They might be in a completely
different connected component.

00:22:48.000 --> 00:22:50.000
We don't know yet.
Some of them,

00:22:50.000 --> 00:22:53.000
we have estimates for because
we've sort of seen how to get

00:22:53.000 --> 00:22:55.000
there from S.
And the idea is,

00:22:55.000 --> 00:22:58.000
among all of these nodes where
we have estimates,

00:22:58.000 --> 00:23:01.000
and on to get from little S,
which is some vertex in here,

00:23:01.000 --> 00:23:04.000
to these vertices,
we're going to take the one for

00:23:04.000 --> 00:23:10.000
which the estimate is smallest.
That's the greedy choice.

00:23:10.000 --> 00:23:15.000
And, we're just going to add
that vertex to S.

00:23:15.000 --> 00:23:18.000
So, S grows one vertex per
step.

00:23:18.000 --> 00:23:23.000
Each step, we're going to add
to S, the vertex.

00:23:23.000 --> 00:23:27.000
Of course, again,
this is not a unique,

00:23:27.000 --> 00:23:32.000
it's a vertex,
v, in V minus S.

00:23:32.000 --> 00:23:39.000
So, it's something we haven't
yet computed yet whose estimated

00:23:39.000 --> 00:23:47.000
distance from S is minimum.
So, we look at all the vertices

00:23:47.000 --> 00:23:55.000
we haven't yet added to S.
Just take the one where we have

00:23:55.000 --> 00:24:01.000
the estimated smallest distance.
The intuition is that that

00:24:01.000 --> 00:24:03.000
should be a good choice.
So, if I pick the one that's

00:24:03.000 --> 00:24:06.000
closest to little s among all
the ones that I've seen,

00:24:06.000 --> 00:24:09.000
among all the paths that I've
seen, I sort of have to buy into

00:24:09.000 --> 00:24:11.000
that those are good paths.
But, I mean,

00:24:11.000 --> 00:24:13.000
maybe there's some path I
didn't see.

00:24:13.000 --> 00:24:16.000
Maybe you go out to here and
then you take some other path to

00:24:16.000 --> 00:24:18.000
some vertex, which we've already
seen.

00:24:18.000 --> 00:24:20.000
OK, the worry is,
well, I'd better not say that

00:24:20.000 --> 00:24:23.000
that's the shortest path because
there may have been some other

00:24:23.000 --> 00:24:25.000
way to get there.
Right, as soon as I add

00:24:25.000 --> 00:24:27.000
something to S,
I declare I've solved the

00:24:27.000 --> 00:24:32.000
problem for that vertex.
I can't change my answer later.

00:24:32.000 --> 00:24:35.000
OK, the estimates can change
until they get added to S.

00:24:35.000 --> 00:24:39.000
So, I don't want to add this
vertex to S because I haven't

00:24:39.000 --> 00:24:43.000
considered this path.
Well, if all my weights are

00:24:43.000 --> 00:24:47.000
nonnegative, and I take the
vertex here that has the

00:24:47.000 --> 00:24:50.000
shortest estimate from S,
so let's suppose this one is

00:24:50.000 --> 00:24:54.000
the shortest one,
then this can't be a shorter

00:24:54.000 --> 00:24:57.000
path because the distance
estimate, at least,

00:24:57.000 --> 00:25:02.000
from S to that vertex is larger
from S to that vertex.

00:25:02.000 --> 00:25:05.000
So, no way can I make the path
longer and decrease the

00:25:05.000 --> 00:25:07.000
distance.
That's the intuition.

00:25:07.000 --> 00:25:10.000
OK, it's a little bit fuzzy
here because I don't have any

00:25:10.000 --> 00:25:14.000
induction hypotheses set up,
and it's going to be a lot more

00:25:14.000 --> 00:25:17.000
work to prove that.
But that's the intuition why

00:25:17.000 --> 00:25:21.000
this is the right thing to do.
OK, you have to prove something

00:25:21.000 --> 00:25:25.000
about the distance estimates for
that to be a proof.

00:25:25.000 --> 00:25:27.000
But, intuitively,
it feels good.

00:25:27.000 --> 00:25:32.000
It was a good starting point.
OK, and then presumably we have

00:25:32.000 --> 00:25:34.000
to maintain these distance
estimates.

00:25:34.000 --> 00:25:38.000
So, the heart of the algorithm
is updating distance estimates,

00:25:38.000 --> 00:25:41.000
I mean, choosing the best
vertex to add to S,

00:25:41.000 --> 00:25:44.000
that's one step.
Then, updating the distance

00:25:44.000 --> 00:25:46.000
estimates is sort of where the
work is.

00:25:46.000 --> 00:25:50.000
And, it turns out we'll only
need to update distance

00:25:50.000 --> 00:25:53.000
estimates of some of the
vertices, the ones that are

00:25:53.000 --> 00:25:56.000
adjacent to v.
v was the vertex we just added

00:25:56.000 --> 00:25:59.000
to S.
So, once we add somebody to S,

00:25:59.000 --> 00:26:02.000
so we grow S by a little bit,
then we look at all the new

00:26:02.000 --> 00:26:07.000
edges that go out of S from that
vertex.

00:26:07.000 --> 00:26:14.000
We update something.
That's the idea.

00:26:14.000 --> 00:26:24.000
So, that's the idea for how
we're going to use greedy.

00:26:24.000 --> 00:26:32.000
Now I'll give you the
algorithm.

00:26:32.000 --> 00:26:40.000
So, this is called Dijkstra's
algorithm.

00:26:40.000 --> 00:26:47.000
Dijkstra is a famous,
recently late,

00:26:47.000 --> 00:26:57.000
if that makes sense,
computer scientist from the

00:26:57.000 --> 00:27:04.000
Netherlands.
And, this is probably the

00:27:04.000 --> 00:27:12.000
algorithm he is most famous for.
So, the beginning of the

00:27:12.000 --> 00:27:18.000
algorithm is just some
initialization,

00:27:18.000 --> 00:27:24.000
not too exciting.
OK, but let me tell you what

00:27:24.000 --> 00:27:34.000
some of the variables mean.
OK, so d is some array indexed

00:27:34.000 --> 00:27:42.000
by vertices, and the idea is
that d of x is the distance

00:27:42.000 --> 00:27:47.000
estimate for x,
so, from S to x.

00:27:47.000 --> 00:27:54.000
so in particular,
it's going to equal the real

00:27:54.000 --> 00:28:03.000
shortest path weight from S to x
when we've added x to our set

00:28:03.000 --> 00:28:07.000
capital, S.
OK, so this is,

00:28:07.000 --> 00:28:10.000
in particular,
going to be the output to the

00:28:10.000 --> 00:28:11.000
algorithm.
Did you have a question?

00:28:11.000 --> 00:28:13.000
Or were you just stretching?
Good.

00:28:13.000 --> 00:28:15.000
So, in d of x,
when we are done,

00:28:15.000 --> 00:28:17.000
d of x is the output.
For every vertex,

00:28:17.000 --> 00:28:20.000
it's going to give us the
shortest path weight from S to

00:28:20.000 --> 00:28:21.000
that vertex.
Along the way,

00:28:21.000 --> 00:28:24.000
it's going to be some estimated
distance from S to that vertex.

00:28:24.000 --> 00:28:26.000
And, we're going to improve it
over time.

00:28:26.000 --> 00:28:29.000
This is an infinity.
So initially,

00:28:29.000 --> 00:28:32.000
we know that the distance,
we know the distance from S to

00:28:32.000 --> 00:28:35.000
S is zero.
So, we're going to set that to

00:28:35.000 --> 00:28:37.000
be our estimate.
It's going to be accurate.

00:28:37.000 --> 00:28:40.000
Everything else we're going to
just set to infinity because we

00:28:40.000 --> 00:28:43.000
may not be connected.
From the beginning,

00:28:43.000 --> 00:28:45.000
we don't know much.
S, initially,

00:28:45.000 --> 00:28:47.000
is going to be infinity.
Immediately,

00:28:47.000 --> 00:28:49.000
we're going to add little s to
big S.

00:28:49.000 --> 00:28:52.000
And then, the interesting part
here is Q, which is going to

00:28:52.000 --> 00:28:55.000
consist of, initially all the
vertices in the graph.

00:28:55.000 --> 00:29:00.000
And, it's going to not just be
a queue as the letter suggests.

00:29:00.000 --> 00:29:03.000
It's going to be a priority
queue.

00:29:03.000 --> 00:29:07.000
So, it's going to maintain,
in particular,

00:29:07.000 --> 00:29:12.000
the vertex that has the
smallest distance estimate.

00:29:12.000 --> 00:29:17.000
So, this is a priority queue.
This is really an abuse of

00:29:17.000 --> 00:29:23.000
notation for a data structure.
OK, so this could be a heap or

00:29:23.000 --> 00:29:27.000
whatever.
The vertices are keyed on d,

00:29:27.000 --> 00:29:32.000
our distance estimate.
So, in particular,

00:29:32.000 --> 00:29:35.000
S will have the,
this is going to be a Min heap.

00:29:35.000 --> 00:29:38.000
S will be the guy who has the
minimum.

00:29:38.000 --> 00:29:41.000
Everyone else has the same key
initially.

00:29:41.000 --> 00:29:45.000
And, we're going to repeatedly
extract the minimum element from

00:29:45.000 --> 00:29:50.000
this queue and do other things.
OK, so this is initialization.

00:29:50.000 --> 00:29:53.000
OK, I'm going to call that
initialization.

00:29:53.000 --> 00:29:57.000
It's a pretty simple thing.
It just takes linear time,

00:29:57.000 --> 00:30:02.000
nothing fancy going on.
The heart of the algorithm is

00:30:02.000 --> 00:30:06.000
all in six lines.
And, so this is not really a

00:30:06.000 --> 00:30:09.000
step.
The first step here that we

00:30:09.000 --> 00:30:15.000
need to do is we take the vertex
whose distance estimate is

00:30:15.000 --> 00:30:17.000
minimum.
So that, among all the

00:30:17.000 --> 00:30:21.000
vertices, not yet,
and that's currently S is

00:30:21.000 --> 00:30:23.000
empty.
Q has everyone.

00:30:23.000 --> 00:30:29.000
In general, Q will have
everyone except S.

00:30:29.000 --> 00:30:33.000
So, we'll take the vertex,
u, that has the minimum key in

00:30:33.000 --> 00:30:38.000
that priority queue.
So, extract the Min from Q.

00:30:48.000 --> 00:31:02.000
OK.
We're going to add a little u

00:31:02.000 --> 00:31:07.000
to S, claim that that is now,
I mean, that's exactly what

00:31:07.000 --> 00:31:11.000
we're saying here.
We add to S that vertex that

00:31:11.000 --> 00:31:17.000
has minimum distance estimate.
And now, we need to update the

00:31:17.000 --> 00:31:21.000
distances.
So, we're going to look at each

00:31:21.000 --> 00:31:27.000
adjacent vertex for each v in
the adjacency list for u.

00:31:27.000 --> 00:31:30.000
We look at a few distances.

00:31:47.000 --> 00:31:49.000
So that's the algorithm or more
or less.

00:31:49.000 --> 00:31:53.000
This is the key.
I should define it a little bit

00:31:53.000 --> 00:31:56.000
what's going on here.
We talked mainly about

00:31:56.000 --> 00:32:00.000
undirected graph last time.
Here, we're thinking about

00:32:00.000 --> 00:32:03.000
undirected graphs.
And, the adjacency list for u

00:32:03.000 --> 00:32:07.000
here is just going to mean,
give me all the vertices for

00:32:07.000 --> 00:32:09.000
which there is an edge from u to
v.

00:32:09.000 --> 00:32:11.000
So, this is the outgoing
adjacency list,

00:32:11.000 --> 00:32:13.000
not the incoming adjacency
list.

00:32:13.000 --> 00:32:16.000
Undirected graphs:
you list everything.

00:32:16.000 --> 00:32:19.000
Directed graphs:
here, we're only going to care

00:32:19.000 --> 00:32:21.000
about those ones.
So, for every edge,

00:32:21.000 --> 00:32:24.000
(u,v), is what this is saying,
we are going to compare the

00:32:24.000 --> 00:32:28.000
current estimate for v,
and this candidate estimate,

00:32:28.000 --> 00:32:30.000
which intuitively means you go
from s to u.

00:32:30.000 --> 00:32:34.000
That's d of u because we now
know that that's the right

00:32:34.000 --> 00:32:37.000
answer.
This, in fact,

00:32:37.000 --> 00:32:39.000
equals, we hope,
assuming the algorithm is

00:32:39.000 --> 00:32:44.000
correct, this should be the
shortest path weight from s to u

00:32:44.000 --> 00:32:48.000
because we just added u to S.
And whenever we add something

00:32:48.000 --> 00:32:50.000
to S, it should have the right
value.

00:32:50.000 --> 00:32:54.000
So, we could say,
well, you take the shortest

00:32:54.000 --> 00:32:57.000
path from S to u,
and then you follow this edge

00:32:57.000 --> 00:32:59.000
from u to v.
That has weight,

00:32:59.000 --> 00:33:02.000
w, of (u,v).
That's one possible path from S

00:33:02.000 --> 00:33:05.000
to v.
And, if that's a shorter path

00:33:05.000 --> 00:33:09.000
than the one we currently have
in our estimate,

00:33:09.000 --> 00:33:12.000
if this is smaller than that,
then we should update the

00:33:12.000 --> 00:33:16.000
estimate to be that sum because
that's a better path,

00:33:16.000 --> 00:33:19.000
so, add it to our database of
paths, so to speak:

00:33:19.000 --> 00:33:23.000
OK, very intuitive operation;
clearly should not do anything

00:33:23.000 --> 00:33:25.000
bad.
I mean, these should be paths

00:33:25.000 --> 00:33:30.000
that makes sense.
We'll prove that in a moment.

00:33:30.000 --> 00:33:33.000
That's the first part of
correctness, that this never

00:33:33.000 --> 00:33:36.000
screws up.
And then, the tricky part is to

00:33:36.000 --> 00:33:40.000
show that it finds all the paths
that we care about.

00:33:40.000 --> 00:33:43.000
This step is called a
relaxation step.

00:33:43.000 --> 00:33:47.000
Relaxation is always a
difficult technique to teach to

00:33:47.000 --> 00:33:50.000
MIT students.
It doesn't come very naturally.

00:33:50.000 --> 00:33:55.000
But it's very simple operation.
It comes from optimization

00:33:55.000 --> 00:34:00.000
terminology, programming
terminology, so to speak.

00:34:00.000 --> 00:34:04.000
And, does this inequality look
familiar at all especially when

00:34:04.000 --> 00:34:08.000
you start writing it this way?
You say, the shortest path from

00:34:08.000 --> 00:34:12.000
S to v and the shortest path
from S to u in some edge from u

00:34:12.000 --> 00:34:15.000
to v, does that look like
anything we've seen?

00:34:15.000 --> 00:34:18.000
In fact, it was on this board
but I just erased it.

00:34:18.000 --> 00:34:20.000
Triangle inequality,
yeah.

00:34:20.000 --> 00:34:24.000
So, this is trying to make the
triangle inequality true.

00:34:24.000 --> 00:34:28.000
Certainly, the shortest path
from S to v should be less than

00:34:28.000 --> 00:34:32.000
or equal to, not greater than.
The shortest path from S to u,

00:34:32.000 --> 00:34:36.000
plus whatever path from u to v,
the shortest path should be,

00:34:36.000 --> 00:34:40.000
at most, that.
So, this is sort of a somewhat

00:34:40.000 --> 00:34:42.000
more general triangle
inequality.

00:34:42.000 --> 00:34:44.000
And, we want to,
certainly it should be true.

00:34:44.000 --> 00:34:46.000
So, if it's not true,
we fix it.

00:34:46.000 --> 00:34:48.000
If it's greater than,
we make it equal.

00:34:48.000 --> 00:34:51.000
But we don't want to make it
less than because that's not

00:34:51.000 --> 00:34:52.000
always true.
OK, but certainly,

00:34:52.000 --> 00:34:54.000
it should be less than or equal
to.

00:34:54.000 --> 00:34:56.000
So, this is fixing the triangle
inequality.

00:34:56.000 --> 00:35:00.000
It's trying to make that
constraint more true.

00:35:00.000 --> 00:35:03.000
In optimization,
that's called relaxing the

00:35:03.000 --> 00:35:06.000
constraint.
OK, so we're sort of relaxing

00:35:06.000 --> 00:35:11.000
the triangle inequality here.
In the end, we should have all

00:35:11.000 --> 00:35:14.000
the shortest paths.
That's a claim.

00:35:14.000 --> 00:35:19.000
So: a very simple algorithm.
Let's try it out on a graph,

00:35:19.000 --> 00:35:23.000
and that should make it more
intuitive why it's working,

00:35:23.000 --> 00:35:28.000
and that the rest of the
lecture will be proving that it

00:35:28.000 --> 00:35:32.000
works.
Yeah, this is enough room.

00:35:32.000 --> 00:35:36.000
So, oh, I should mention one
other thing here.

00:35:36.000 --> 00:35:38.000
Sorry.
Whenever we change d of v,

00:35:38.000 --> 00:35:43.000
this is changing the key of v
in the priority queue.

00:35:43.000 --> 00:35:48.000
So, implicitly what's happening
here in this assignment,

00:35:48.000 --> 00:35:53.000
this is getting a bit messy,
is a decreased key operation,

00:35:53.000 --> 00:35:58.000
OK, which we talked briefly
about last class in the context

00:35:58.000 --> 00:36:05.000
of minimum spanning trees where
we were also decreasing the key.

00:36:05.000 --> 00:36:08.000
The point is we were changing
the key of one element industry

00:36:08.000 --> 00:36:11.000
like station step in the
priority queue so that if it now

00:36:11.000 --> 00:36:14.000
becomes the minimum,
we should extract here.

00:36:14.000 --> 00:36:17.000
And, we are only ever
decreasing keys because we are

00:36:17.000 --> 00:36:20.000
always replacing larger values
with smaller values.

00:36:20.000 --> 00:36:23.000
So, we'll come back to that
later when we analyze the

00:36:23.000 --> 00:36:25.000
running time.
But, there is some data

00:36:25.000 --> 00:36:28.000
structure work going on here.
Again, we are abusing notation

00:36:28.000 --> 00:36:33.000
a bit.
OK, so here is a graph with

00:36:33.000 --> 00:36:36.000
edge weights.

00:37:06.000 --> 00:37:10.000
OK, and I want my priority
queue over here.

00:37:10.000 --> 00:37:14.000
And, I'm also going to draw my
estimates.

00:37:14.000 --> 00:37:19.000
OK, now I don't want to cheat.
So, we're going to run the

00:37:19.000 --> 00:37:23.000
algorithm on this graph.
s will be A,

00:37:23.000 --> 00:37:30.000
and I want to know the shortest
path from A to everyone else.

00:37:30.000 --> 00:37:32.000
So, you can check,
OK, paths exist.

00:37:32.000 --> 00:37:35.000
So, hopefully everything should
end up a finite value by the

00:37:35.000 --> 00:37:37.000
end.
All the weights are

00:37:37.000 --> 00:37:39.000
nonnegative, so this algorithm
should work.

00:37:39.000 --> 00:37:42.000
The algorithm doesn't even need
connectivity,

00:37:42.000 --> 00:37:45.000
but it does mean that all the
weights are nonnegative.

00:37:45.000 --> 00:37:48.000
So, we run the algorithm.
For the initialization,

00:37:48.000 --> 00:37:51.000
we set the distance estimate
for our source to be zero

00:37:51.000 --> 00:37:54.000
because, in fact,
there's only one path from A to

00:37:54.000 --> 00:37:57.000
A, and that to do nothing,
the empty path.

00:37:57.000 --> 00:38:00.000
So, I'm going to put the key of
zero over here.

00:38:00.000 --> 00:38:03.000
And, for everyone else,
we're just going to put

00:38:03.000 --> 00:38:08.000
infinity because we don't know
any better at this point.

00:38:08.000 --> 00:38:11.000
So, I'll put keys of infinity
for everyone else.

00:38:11.000 --> 00:38:15.000
OK, so now you can see what the
algorithm does is extract the

00:38:15.000 --> 00:38:18.000
minimum from the queue.
And, given our setup,

00:38:18.000 --> 00:38:21.000
we'll definitely choose s,
or in this case,

00:38:21.000 --> 00:38:23.000
A.
So, it has a weight of zero.

00:38:23.000 --> 00:38:26.000
Everyone else has quite a bit
larger weight.

00:38:26.000 --> 00:38:30.000
OK, so we look at s,
or I'll use A here.

00:38:30.000 --> 00:38:32.000
So, we look at A.
We add A to our set,

00:38:32.000 --> 00:38:33.000
S.
So, it's now removed from the

00:38:33.000 --> 00:38:35.000
queue.
It will never go back in

00:38:35.000 --> 00:38:38.000
because we never add anything to
the queue, start with all the

00:38:38.000 --> 00:38:40.000
vertices, and extract,
and decrease keys.

00:38:40.000 --> 00:38:42.000
But we never insert.
So, A is gone.

00:38:42.000 --> 00:38:45.000
OK, and now I want to update
the keys of all of the other

00:38:45.000 --> 00:38:48.000
vertices.
And the claim is I only need to

00:38:48.000 --> 00:38:50.000
look at the vertices that have
edges from A.

00:38:50.000 --> 00:38:53.000
So, there's an edge from A to
B, and that has weight ten.

00:38:53.000 --> 00:38:56.000
And so, I compare:
well, is it a good idea to go

00:38:56.000 --> 00:38:58.000
from A to A, which costs
nothing, and then to go along

00:38:58.000 --> 00:39:02.000
this edge, AB,
which costs ten?

00:39:02.000 --> 00:39:06.000
Well, it seems like a pretty
good idea because that has a

00:39:06.000 --> 00:39:09.000
total weight of zero plus ten,
which is ten,

00:39:09.000 --> 00:39:11.000
which is much smaller than
infinity.

00:39:11.000 --> 00:39:15.000
So, I'm going to erase this
infinity; write ten,

00:39:15.000 --> 00:39:19.000
and over in the queue as well.
That's the decreased key

00:39:19.000 --> 00:39:22.000
operation.
So now, I know a path from A to

00:39:22.000 --> 00:39:22.000
B.
Good.
A to C is the only other edge.
Zero plus three is less than

00:39:27.000 --> 00:39:28.000
infinity, so,
cool.

00:39:28.000 --> 00:39:33.000
I'll put three here for C,
and C is there.

00:39:33.000 --> 00:39:35.000
OK, the other vertices I don't
touch.

00:39:35.000 --> 00:39:38.000
I'm going to rewrite them here,
but the algorithm doesn't have

00:39:38.000 --> 00:39:41.000
to copy them.
Those keys were already there.

00:39:41.000 --> 00:39:44.000
It's just touching these two.
OK, that was pretty boring.

00:39:44.000 --> 00:39:47.000
Now we look at our queue,
and we extract the minimum

00:39:47.000 --> 00:39:49.000
element.
So, A is no longer in there,

00:39:49.000 --> 00:39:51.000
so the minimum key here is
three.

00:39:51.000 --> 00:39:54.000
So, the claim is that this is a
shortest path;

00:39:54.000 --> 00:39:56.000
from A to C,
here is the shortest path from

00:39:56.000 --> 00:39:58.000
A to C.
There's no other shorter way.

00:39:58.000 --> 00:40:03.000
You could check that,
and we'll prove it in a moment.

00:40:03.000 --> 00:40:05.000
Cool, so we'll remove C from
the list.

00:40:05.000 --> 00:40:07.000
It's gone.
Then we look at all of the

00:40:07.000 --> 00:40:10.000
outgoing edges from C.
So, there's one that goes up to

00:40:10.000 --> 00:40:13.000
B, which has weight four,
four plus three,

00:40:13.000 --> 00:40:15.000
which is the shortest path
weight from A to C.

00:40:15.000 --> 00:40:18.000
So, going from A to C,
and C to B should cost three

00:40:18.000 --> 00:40:21.000
plus four, which is seven,
which is less than ten.

00:40:21.000 --> 00:40:24.000
So, we found an even better
path to get to B.

00:40:24.000 --> 00:40:27.000
It's better to go like this
than it is to go like that.

00:40:27.000 --> 00:40:30.000
So, we write seven for B,
and there's an outgoing edge

00:40:30.000 --> 00:40:35.000
from C to d which costs eight.
Three plus eight is 11.

00:40:35.000 --> 00:40:38.000
11 is less than infinity last
time I checked.

00:40:38.000 --> 00:40:41.000
So, we write 11 for d.
Then we look at E.

00:40:41.000 --> 00:40:45.000
We have three plus two is five,
which is less than infinity.

00:40:45.000 --> 00:40:48.000
So, we write five for the new
key for E.

00:40:48.000 --> 00:40:51.000
At this point,
we have finite shortest paths

00:40:51.000 --> 00:40:54.000
to everywhere,
but they may not be the best

00:40:54.000 --> 00:40:56.000
ones.
So, we have to keep looking.

00:40:56.000 --> 00:40:59.000
OK, next round of the
algorithm, we extract the

00:40:59.000 --> 00:41:04.000
minimum key among all these.
OK, it's not B,

00:41:04.000 --> 00:41:07.000
which we've seen though
probably know the answer to.

00:41:07.000 --> 00:41:09.000
But it's E.
E has the smallest key.

00:41:09.000 --> 00:41:12.000
So, we now declare this to be a
shortest path.

00:41:12.000 --> 00:41:16.000
The way we got to E was along
this path: A to C,

00:41:16.000 --> 00:41:18.000
C to E, declare that to be
shortest.

00:41:18.000 --> 00:41:22.000
We claim we're done with E.
But we still have to update.

00:41:22.000 --> 00:41:25.000
What about all the outgoing
edges from E?

00:41:25.000 --> 00:41:28.000
There's only one here.
It costs five plus nine,

00:41:28.000 --> 00:41:32.000
which is 14,
which is bigger than 11.

00:41:32.000 --> 00:41:34.000
So, no go.
That's not an interesting path.

00:41:34.000 --> 00:41:38.000
Our previous path,
which went like this at a cost

00:41:38.000 --> 00:41:42.000
of the 11, is better than the
one we are considering now.

00:41:42.000 --> 00:41:45.000
I'm drawing the whole path,
but the algorithm is only

00:41:45.000 --> 00:41:48.000
adding these two numbers.
OK, good.

00:41:48.000 --> 00:41:52.000
So, I don't change anything.
Seven, 11, and five is removed,

00:41:52.000 --> 00:41:55.000
or E is removed.
Our new keys are seven and 11.

00:41:55.000 --> 00:41:57.000
So, we take the key,
seven, here,

00:41:57.000 --> 00:42:01.000
which is for element B,
vertex B.

00:42:01.000 --> 00:42:04.000
We declare the path we
currently have in our hands from

00:42:04.000 --> 00:42:06.000
A to B, which happens to be this
one.

00:42:06.000 --> 00:42:09.000
Algorithm can't actually tell
this, by the way,

00:42:09.000 --> 00:42:11.000
but we're drawing it anyway.
This path, A,

00:42:11.000 --> 00:42:14.000
C, B, is the candidate shortest
path.

00:42:14.000 --> 00:42:16.000
The claim is it is indeed
shortest.

00:42:16.000 --> 00:42:18.000
Now, we look at all the
outgoing edges.

00:42:18.000 --> 00:42:22.000
There's one that goes back to C
at a cost of seven plus one,

00:42:22.000 --> 00:42:24.000
which is eight,
which is bigger than three,

00:42:24.000 --> 00:42:27.000
which is good.
We already declared C to be

00:42:27.000 --> 00:42:29.000
done.
But the algorithm checks this

00:42:29.000 --> 00:42:31.000
path and says,
oh, that's no better.

00:42:31.000 --> 00:42:34.000
And then we look at this other
edge from B to d.

00:42:34.000 --> 00:42:36.000
That costs seven plus two,
which is nine,

00:42:36.000 --> 00:42:41.000
which is better than 11.
So, we, in fact,

00:42:41.000 --> 00:42:46.000
found an even shorter path.
So, the shortest path weight,

00:42:46.000 --> 00:42:51.000
now, for d, is nine because
there is this path that goes A,

00:42:51.000 --> 00:42:55.000
C, B, d for a total cost of
three plus four plus two is

00:42:55.000 --> 00:42:58.000
nine.
Cool, now there's only one

00:42:58.000 --> 00:43:02.000
element in the queue.
We remove it.

00:43:02.000 --> 00:43:04.000
d: we look at the outgoing
edges.

00:43:04.000 --> 00:43:07.000
There's one going here which
costs nine plus seven,

00:43:07.000 --> 00:43:09.000
which is 16,
which is way bigger than five.

00:43:09.000 --> 00:43:12.000
So, we're done.
Don't do anything.

00:43:12.000 --> 00:43:14.000
At this point,
the queue is empty.

00:43:14.000 --> 00:43:18.000
And the claim is that all these
numbers that are written here,

00:43:18.000 --> 00:43:21.000
the final values are the
shortest path weights.

00:43:21.000 --> 00:43:24.000
This looks an awful lot like a
five, but it's an s.

00:43:24.000 --> 00:43:27.000
It has a weight of zero.
I've also drawn in here all the

00:43:27.000 --> 00:43:31.000
shortest paths.
And, this is not hard to do.

00:43:31.000 --> 00:43:34.000
We're not going to talk about
it too much in this class,

00:43:34.000 --> 00:43:37.000
but it's mentioned in a little
bit more detail at the end of

00:43:37.000 --> 00:43:40.000
the textbook.
And it's something called the

00:43:40.000 --> 00:43:42.000
shortest path tree.
It's just something good to

00:43:42.000 --> 00:43:46.000
know about if you actually want
to compute shortest paths.

00:43:46.000 --> 00:43:48.000
In this class,
we mainly worry about the

00:43:48.000 --> 00:43:50.000
weights because it's pretty much
the same problem.

00:43:50.000 --> 00:43:55.000
The shortest path tree is the
union of all shortest paths.

00:43:55.000 --> 00:43:58.000
And in particular,
if you look at each vertex in

00:43:58.000 --> 00:44:04.000
your graph, if you consider the
last edge into that vertex that

00:44:04.000 --> 00:44:08.000
was relaxed among all vertices,
u, you look at the edges,

00:44:08.000 --> 00:44:12.000
(u,v), say, was that last one
to relax?

00:44:12.000 --> 00:44:15.000
So, just look at the last edges
we relaxed here.

00:44:15.000 --> 00:44:20.000
You put them all together:
that's called a shortest path

00:44:20.000 --> 00:44:23.000
tree.
And, it has the property that

00:44:23.000 --> 00:44:28.000
from S to everywhere else,
there is a unique path down the

00:44:28.000 --> 00:44:31.000
tree.
And it's the shortest path.

00:44:31.000 --> 00:44:34.000
It's the shortest path that we
found.

00:44:34.000 --> 00:44:37.000
OK, so you actually get
shortest paths out of this

00:44:37.000 --> 00:44:40.000
algorithm even though it's not
explicitly described.

00:44:40.000 --> 00:44:44.000
All we are mainly talking about
are the shortest path weights.

00:44:44.000 --> 00:44:48.000
Algorithm clear at this point?
Feels like it's doing the right

00:44:48.000 --> 00:44:50.000
thing?
You can check all those numbers

00:44:50.000 --> 00:44:53.000
are the best paths.
And now we're going to prove

00:44:53.000 --> 00:44:55.000
that.

00:45:12.000 --> 00:45:15.000
So: correctness.

00:45:25.000 --> 00:45:31.000
So the first thing I want to
prove is that relaxation never

00:45:31.000 --> 00:45:35.000
makes a mistake.
If it ever sets d of v to be

00:45:35.000 --> 00:45:42.000
something, I want to prove that
d of v is always an upper bound

00:45:42.000 --> 00:45:45.000
on delta.
So, we have this variant.

00:45:45.000 --> 00:45:51.000
It's greater than or equal to
delta of s, v for all v.

00:45:51.000 --> 00:45:55.000
And, this invariant holds at
all times.

00:45:55.000 --> 00:45:59.000
So, after initialization,
it doesn't hold before

00:45:59.000 --> 00:46:06.000
initialization because d isn't
defined then.

00:46:06.000 --> 00:46:09.000
But if you do this
initialization where you set S

00:46:09.000 --> 00:46:14.000
to zero, and everyone else to
infinity, and you take any

00:46:14.000 --> 00:46:19.000
sequence of relaxation steps,
then this variant will hold

00:46:19.000 --> 00:46:22.000
after each relaxation step you
apply.

00:46:22.000 --> 00:46:25.000
This is actually a very general
lemma.

00:46:25.000 --> 00:46:29.000
It's also pretty easy to prove.
It holds not only for

00:46:29.000 --> 00:46:33.000
Dijkstra's algorithm,
but for a lot of other

00:46:33.000 --> 00:46:38.000
algorithms we'll see.
Pretty much every algorithm we

00:46:38.000 --> 00:46:43.000
see will involve relaxation.
And, this is saying no matter

00:46:43.000 --> 00:46:47.000
what relaxations you do,
you always have a reasonable

00:46:47.000 --> 00:46:51.000
estimate in the sense that it's
greater than or equal to the

00:46:51.000 --> 00:46:56.000
true shortest path weight.
So, it should be converging

00:46:56.000 --> 00:46:58.000
from above.
So, that's the lemma.

00:46:58.000 --> 00:47:02.000
Let's prove it.
Any suggestions on how we

00:47:02.000 --> 00:47:07.000
should prove this lemma?
What technique might we use?

00:47:07.000 --> 00:47:09.000
What's that?
Cut and paste?

00:47:09.000 --> 00:47:12.000
It would be good for optimal
substructure.

00:47:12.000 --> 00:47:16.000
Cut and paste:
maybe sort of what's going on

00:47:16.000 --> 00:47:20.000
here but not exactly.
Something a little more

00:47:20.000 --> 00:47:22.000
general.
It's just intuition here;

00:47:22.000 --> 00:47:26.000
it doesn't have to be the right
answer.

00:47:26.000 --> 00:47:32.000
In fact, many answers are
correct, have plausible proofs.

00:47:32.000 --> 00:47:34.000
Induction, yeah.
So, I'm not going to write

00:47:34.000 --> 00:47:36.000
induction here,
but effectively we are using

00:47:36.000 --> 00:47:38.000
induction.
That's the answer I was

00:47:38.000 --> 00:47:40.000
expecting.
So, there is sort of an

00:47:40.000 --> 00:47:42.000
induction already in time going
on here.

00:47:42.000 --> 00:47:45.000
We say after initialization it
should be true.

00:47:45.000 --> 00:47:47.000
That's our base case.
And then, every relaxation we

00:47:47.000 --> 00:47:50.000
do, it should still be true.
So, we're going to assume by

00:47:50.000 --> 00:47:53.000
induction that all the previous
relaxations worked,

00:47:53.000 --> 00:47:56.000
and then we're going to prove
that the last relaxation,

00:47:56.000 --> 00:47:59.000
whatever it is,
works.

00:47:59.000 --> 00:48:01.000
So, first let's do the base
case.

00:48:01.000 --> 00:48:04.000
So, this is after an
initialization,

00:48:04.000 --> 00:48:09.000
let's say, initially.
So, initially we have d of s

00:48:09.000 --> 00:48:12.000
equal to zero.
And we have d of v equal to

00:48:12.000 --> 00:48:17.000
infinity for all other vertices,
for all vertices,

00:48:17.000 --> 00:48:21.000
v, not equal to little s.
OK, now we have to check that

00:48:21.000 --> 00:48:26.000
this inequality holds.
Well, we have delta of s,

00:48:26.000 --> 00:48:28.000
s.
We've already argued that

00:48:28.000 --> 00:48:33.000
that's zero.
You can't get negative when

00:48:33.000 --> 00:48:36.000
there are only nonnegative edge
weights.

00:48:36.000 --> 00:48:40.000
So, that's the best.
So, certainly zero is greater

00:48:40.000 --> 00:48:44.000
than or equal to zero.
And, we have everything else,

00:48:44.000 --> 00:48:47.000
well, I mean,
delta of S, v is certainly less

00:48:47.000 --> 00:48:50.000
than or equal to infinity.
So this holds.

00:48:50.000 --> 00:48:54.000
Everything is less than or
equal to infinity.

00:48:54.000 --> 00:48:59.000
So: base case is done.
So, now we do an induction.

00:48:59.000 --> 00:49:06.000
And, I'm going to write it as a
proof by contradiction.

00:49:06.000 --> 00:49:12.000
So, let's say,
suppose that this fails to hold

00:49:12.000 --> 00:49:18.000
at some point.
So, suppose for contradiction

00:49:18.000 --> 00:49:26.000
that the invariant is violated.
So, we'd like to sue the

00:49:26.000 --> 00:49:32.000
violator and find a
contradiction.

00:49:32.000 --> 00:49:36.000
So, it's going to be violated.
So, let's look at the first

00:49:36.000 --> 00:49:39.000
violation, the first time it's
violated.

00:49:39.000 --> 00:49:41.000
So, this is,
essentially,

00:49:41.000 --> 00:49:45.000
again, a proof by induction.
So, let's say we have some

00:49:45.000 --> 00:49:48.000
violation, d of v is less than
delta of s, v.

00:49:48.000 --> 00:49:53.000
That would be bad if we somehow
got an estimate smaller than the

00:49:53.000 --> 00:49:56.000
shortest path.
Well, then I think about

00:49:56.000 --> 00:50:01.000
looking at the first violation
is we know sort of by induction

00:50:01.000 --> 00:50:05.000
that all other values are
correct.

00:50:05.000 --> 00:50:09.000
OK, d of v is the first one
where we've screwed up.

00:50:09.000 --> 00:50:12.000
So, the invariant holds
everywhere else.

00:50:12.000 --> 00:50:17.000
Well, what caused this to fail,
this invariant to be violated,

00:50:17.000 --> 00:50:20.000
is some relaxation,
OK, on d of v.

00:50:20.000 --> 00:50:24.000
So, we had some d of v,
and we replaced it with some

00:50:24.000 --> 00:50:30.000
other d of u plus the weight of
the edge from u to v.

00:50:30.000 --> 00:50:34.000
And somehow,
this made it invalid.

00:50:34.000 --> 00:50:39.000
So, d of v is somehow less than
that.

00:50:39.000 --> 00:50:46.000
We just set d of v to this.
So, this must be less than

00:50:46.000 --> 00:50:51.000
delta of s, v.
The claim is that that's not

00:50:51.000 --> 00:50:59.000
possible because,
let me rewrite a little bit.

00:50:59.000 --> 00:51:07.000
We have d of u plus w of (u,v).
And, we have our induction

00:51:07.000 --> 00:51:15.000
hypothesis, which holds on u,
u of some other vertex.

00:51:15.000 --> 00:51:22.000
We know that d of u is at least
delta of s, u.

00:51:22.000 --> 00:51:30.000
So, this has to be at least
delta of s, u plus w of u,

00:51:30.000 --> 00:51:34.000
v.
Now, what about this w of u,

00:51:34.000 --> 00:51:37.000
v?
Well, that's some path from u

00:51:37.000 --> 00:51:40.000
to v.
So, it's got to be bigger than

00:51:40.000 --> 00:51:44.000
the shortest path or equal.
So certainly,

00:51:44.000 --> 00:51:48.000
this is greater than or equal
to delta of u,

00:51:48.000 --> 00:51:50.000
v.
OK, it could be larger if

00:51:50.000 --> 00:51:56.000
there's some multi-edged path
that has a smaller total weight,

00:51:56.000 --> 00:52:00.000
but it's certainly no smaller
than delta of u,

00:52:00.000 --> 00:52:04.000
v.
And, this looks like a good

00:52:04.000 --> 00:52:08.000
summation, delta of S to u,
and u to v is a triangle

00:52:08.000 --> 00:52:11.000
inequality, yeah.
So, that is,

00:52:11.000 --> 00:52:15.000
it's upside down here.
But, the triangle S,

00:52:15.000 --> 00:52:19.000
u, u to v, so this is only
longer than S to v.

00:52:19.000 --> 00:52:24.000
OK, so we have this thing,
which is simultaneously greater

00:52:24.000 --> 00:52:29.000
than or equal to the shortest
path weight from S to v,

00:52:29.000 --> 00:52:34.000
and also strictly less than the
shortest path weight from S to

00:52:34.000 --> 00:52:37.000
v.
So, that's a contradiction.

00:52:37.000 --> 00:52:41.000
Maybe contradiction is the most
intuitive way isn't the most

00:52:41.000 --> 00:52:43.000
intuitive way to proceed.
The intuition,

00:52:43.000 --> 00:52:47.000
here, is whatever you assign d
of v, you have a path in mind.

00:52:47.000 --> 00:52:50.000
You inductively had a path from
s to u.

00:52:50.000 --> 00:52:53.000
Then you added this edge.
So, that was a real path.

00:52:53.000 --> 00:52:57.000
We always know that every path
has weight greater than or equal

00:52:57.000 --> 00:53:00.000
to the shortest path.
So, it should be true,

00:53:00.000 --> 00:53:06.000
and here's the inductive proof.
All right, moving right along,

00:53:06.000 --> 00:53:14.000
so this was an easy warm-up.
We have greater than or equal

00:53:14.000 --> 00:53:18.000
to.
Now we have to prove less than

00:53:18.000 --> 00:53:23.000
or equal to at the end of the
algorithm.

00:53:23.000 --> 00:53:31.000
This is true all the time;
less than or equal to will only

00:53:31.000 --> 00:53:37.000
be true at the end.
So, we are not going to prove

00:53:37.000 --> 00:53:41.000
less than or equal to quite yet.
We're going to prove another

00:53:41.000 --> 00:53:44.000
lemma, which again,
so both of these lemmas are

00:53:44.000 --> 00:53:46.000
useful for other algorithms,
too.

00:53:46.000 --> 00:53:51.000
So, we're sort of building some
shortest path theory that we can

00:53:51.000 --> 00:53:54.000
apply later.
This one will give you some

00:53:54.000 --> 00:53:58.000
intuition about why relaxation,
not only is it not bad,

00:53:58.000 --> 00:54:01.000
it's actually good.
Not only does it not screw up

00:54:01.000 --> 00:54:07.000
anything, but it also makes
progress in the following sense.

00:54:07.000 --> 00:54:12.000
So, suppose you knew the
shortest path from s to some

00:54:12.000 --> 00:54:16.000
vertex.
OK, so you go from s to some

00:54:16.000 --> 00:54:19.000
other vertices.
Then you go to u.

00:54:19.000 --> 00:54:25.000
Then you go to v.
Suppose that is a shortest path

00:54:25.000 --> 00:54:29.000
from s to v.
OK, and also suppose that we

00:54:29.000 --> 00:54:35.000
already know in d of u the
shortest path weight from s to

00:54:35.000 --> 00:54:39.000
u.
So, suppose we have this

00:54:39.000 --> 00:54:43.000
equality.
We now know that we always have

00:54:43.000 --> 00:54:49.000
a greater than or equal to.
Suppose they are equal for u,

00:54:49.000 --> 00:54:53.000
OK, the vertex just before v in
the shortest path.

00:54:53.000 --> 00:54:58.000
OK, and suppose we relax that
edge, (u,v), OK,

00:54:58.000 --> 00:55:05.000
which is exactly this step.
This is relaxing the edge,

00:55:05.000 --> 00:55:08.000
(u,v).
But we'll just call it

00:55:08.000 --> 00:55:13.000
relaxation here.
After that relaxation,

00:55:13.000 --> 00:55:19.000
d of v equals delta of (s,v).
So, if we had the correct

00:55:19.000 --> 00:55:23.000
answer for u,
and we relax (u,v),

00:55:23.000 --> 00:55:29.000
then we get the correct answer
for v.

00:55:29.000 --> 00:55:32.000
OK, this is good news.
It means, if inductively we can

00:55:32.000 --> 00:55:36.000
somehow get the right answer for
u, now we know how to get the

00:55:36.000 --> 00:55:38.000
right answer for v.
In the algorithm,

00:55:38.000 --> 00:55:42.000
we don't actually know what the
vertex just before v in the

00:55:42.000 --> 00:55:45.000
shortest path is,
but in the analysis we can

00:55:45.000 --> 00:55:48.000
pretty much know that.
So, we have to prove this

00:55:48.000 --> 00:55:50.000
lemma.
This is actually even easier

00:55:50.000 --> 00:55:53.000
than the previous one:
don't even need induction

00:55:53.000 --> 00:55:57.000
because you just work through
what's going on in relaxation,

00:55:57.000 --> 00:56:01.000
and it's true.
So, here we go.

00:56:01.000 --> 00:56:04.000
So, we're interested in this
value, delta of Ss v.

00:56:04.000 --> 00:56:07.000
And we know what the shortest
path is.

00:56:07.000 --> 00:56:12.000
So, the shortest path weight is
the weight of this path.

00:56:12.000 --> 00:56:15.000
OK, so we can write down some
equality here.

00:56:15.000 --> 00:56:20.000
Well, I'm going to split out
the first part of the path and

00:56:20.000 --> 00:56:22.000
the last part of the path.
So, we have,

00:56:22.000 --> 00:56:27.000
I'll say, the weight from s,
so, this part of the path from

00:56:27.000 --> 00:56:32.000
s to u, plus the weight of this
edge, u, v.

00:56:32.000 --> 00:56:40.000
Remember, we could write w of a
path, and that was the total

00:56:40.000 --> 00:56:46.000
weight of all those edges.
So, what is this,

00:56:46.000 --> 00:56:51.000
the weight of this path from S
to u?

00:56:51.000 --> 00:56:59.000
Or, what property should I use
to figure out what that value

00:56:59.000 --> 00:57:02.000
is?
Yeah?

00:57:02.000 --> 00:57:05.000
s to v is the shortest path,
right?

00:57:05.000 --> 00:57:11.000
So, by optimal substructure,
from s to u is also a shortest

00:57:11.000 --> 00:57:13.000
path.
So, this is delta of s,

00:57:13.000 --> 00:57:14.000
u.
Cool.

00:57:14.000 --> 00:57:19.000
We'll hold on for now.
That's all we're going to say.

00:57:19.000 --> 00:57:24.000
On the other hand,
we know from this lemma that

00:57:24.000 --> 00:57:28.000
matter what we do,
d of v is greater than or equal

00:57:28.000 --> 00:57:32.000
to delta of s,
v.

00:57:32.000 --> 00:57:36.000
So, let's write that down.
So, there's a few cases,

00:57:36.000 --> 00:57:39.000
and this will eliminate some of
the cases.

00:57:39.000 --> 00:57:44.000
By that lemma correctness one,
we know that d of v is greater

00:57:44.000 --> 00:57:46.000
than or equal to delta of s,
v.

00:57:46.000 --> 00:57:50.000
So, it's either equal or
greater than at all times.

00:57:50.000 --> 00:57:55.000
So, I'm thinking about the time
before we do the relaxation,

00:57:55.000 --> 00:57:58.000
this (u,v).
So, at that point,

00:57:58.000 --> 00:58:02.000
this is certainly true.
So, either they're equal before

00:58:02.000 --> 00:58:06.000
relaxation or it's greater.

00:58:16.000 --> 00:58:19.000
OK, if they are equal before
relaxation, we're happy because

00:58:19.000 --> 00:58:23.000
relaxation only decreases values
by correctness one.

00:58:23.000 --> 00:58:26.000
It can't get any smaller than
this, so after relaxation it

00:58:26.000 --> 00:58:29.000
will also be equal.
OK, so in this case we're done.

00:58:29.000 --> 00:58:35.000
So, that's a trivial case.
So let's now suppose that d of

00:58:35.000 --> 00:58:41.000
v is greater than delta of s,
v before relaxation.

00:58:41.000 --> 00:58:46.000
That's perfectly valid.
Hopefully now we fix it.

00:58:46.000 --> 00:58:51.000
OK, well the point is,
we know this delta s,

00:58:51.000 --> 00:58:53.000
v.
It is this sum.

00:58:53.000 --> 00:58:58.000
OK, we also know this.
So, delta of s,

00:58:58.000 --> 00:59:03.000
u we know is d of u.
And, we have this w u,

00:59:03.000 --> 00:59:04.000
v.
So, delta of s,

00:59:04.000 --> 00:59:07.000
v is d of u plus w of (u,v)
because we are assuming we have

00:59:07.000 --> 00:59:11.000
this shortest path structure
where you go from s to u,

00:59:11.000 --> 00:59:13.000
and then you follow the edge,
(u,v).

00:59:13.000 --> 00:59:16.000
So, we know this.
So, we know d of v is greater

00:59:16.000 --> 00:59:19.000
than d of u plus w of (u,v).
By golly, that's this condition

00:59:19.000 --> 00:59:22.000
in relaxation.
So, we're just checking,

00:59:22.000 --> 00:59:24.000
relaxation actually does
something here.

00:59:24.000 --> 00:59:26.000
OK, if you had the wrong
distance estimate,

00:59:26.000 --> 00:59:33.000
this if condition is satisfied.
Therefore, we do this.

00:59:33.000 --> 00:59:36.000
So, in this case,
we relax.

00:59:36.000 --> 00:59:44.000
So, I'm just relaxing.
Then, we set d of v to d of u

00:59:44.000 --> 00:59:52.000
plus WUV, which is what we want.
OK, so we set d of v to d of u

00:59:52.000 --> 00:59:57.000
plus w of (u,v).
And, this equals,

00:59:57.000 --> 01:00:01.761
as we said here,
delta of S, v,

01:00:01.761 --> 01:00:08.000
which is what we wanted to
prove.

01:00:08.000 --> 01:00:12.662
Done.
OK, I'm getting more and more

01:00:12.662 --> 01:00:18.834
excited as we get into the meat
of this proof.

01:00:18.834 --> 01:00:22.400
Any questions so far?
Good.

01:00:22.400 --> 01:00:28.982
Now comes the hard part.
These are both very easy

01:00:28.982 --> 01:00:35.935
lemmas, right?
I'll use these two boards.

01:00:35.935 --> 01:00:41.081
We don't need these proofs
anymore.

01:00:41.081 --> 01:00:48.043
We just need these statements:
correctness one,

01:00:48.043 --> 01:00:52.583
correctness lemma;
great names.

01:00:52.583 --> 01:01:00.000
So, now finally we get to
correctness two.

01:01:00.000 --> 01:01:03.771
So, we had one and one and a
half.

01:01:03.771 --> 01:01:09.485
So, I guess correctness is,
itself, a mini-trilogy,

01:01:09.485 --> 01:01:14.400
the mini-series.
OK, so correctness two says

01:01:14.400 --> 01:01:20.342
when the algorithm is done,
we have the right answer.

01:01:20.342 --> 01:01:26.514
This is really correctness.
But, it's going to build on

01:01:26.514 --> 01:01:32.000
correctness one and correctness
lemma.

01:01:32.000 --> 01:01:35.699
So, we want d of v to equal
delta of s, v for all vertices,

01:01:35.699 --> 01:01:39.207
v at the end of the algorithm.
That is clearly our goal.

01:01:39.207 --> 01:01:42.779
Now, this theorem is assuming
that all of the weights are

01:01:42.779 --> 01:01:46.223
nonnegative, just to repeat.
It doesn't assume anything

01:01:46.223 --> 01:01:48.136
else.
So, it's going to get the

01:01:48.136 --> 01:01:50.687
infinities right.
But, if there are minus

01:01:50.687 --> 01:01:54.004
infinities, all bets are off.
OK, even if there's any

01:01:54.004 --> 01:01:57.831
negative weight edge anywhere,
it's not going to do the right

01:01:57.831 --> 01:02:02.573
thing necessarily.
But, assuming all the weights

01:02:02.573 --> 01:02:06.656
are nonnegative,
which is reasonable if they're

01:02:06.656 --> 01:02:10.207
measuring time.
Usually it costs money to

01:02:10.207 --> 01:02:14.378
travel along edges.
They don't pay you to do it.

01:02:14.378 --> 01:02:18.106
But who knows?
So, I need just to say a few

01:02:18.106 --> 01:02:20.769
things.
One of the things we've

01:02:20.769 --> 01:02:26.094
mentioned somewhere along the
way is when you add a vertex to

01:02:26.094 --> 01:02:32.363
S, you never change its weight.
OK, that actually requires

01:02:32.363 --> 01:02:35.272
proof.
I'm just going to state it

01:02:35.272 --> 01:02:37.636
here.
It's not hard to see.

01:02:37.636 --> 01:02:42.000
d of v doesn't change.
OK, this is essentially an

01:02:42.000 --> 01:02:47.636
induction once v is added to S.
OK, this will actually followed

01:02:47.636 --> 01:02:50.727
by something we'll say in a
moment.

01:02:50.727 --> 01:02:56.272
OK, so all I really care about
is when a vertex is added to S,

01:02:56.272 --> 01:03:01.000
we better have the right
estimate because after that,

01:03:01.000 --> 01:03:06.000
we're not going to change it,
let's say.

01:03:06.000 --> 01:03:10.097
OK, we could define the
algorithm that way.

01:03:10.097 --> 01:03:15.365
We are not, but we could.
I'll say more about this in a

01:03:15.365 --> 01:03:18.390
second.
So, all we care about is

01:03:18.390 --> 01:03:21.804
whether d of v equals delta of
s, v.

01:03:21.804 --> 01:03:26.780
That's what we want to prove.
So, it's clearly that.

01:03:26.780 --> 01:03:32.536
It should be true at the end.
But, it suffices to prove that

01:03:32.536 --> 01:03:38.000
it holds when v is added to S,
to capital S.

01:03:38.000 --> 01:03:40.327
OK, this actually implies the
first statement.

01:03:40.327 --> 01:03:42.086
It has sort of a funny
implication.

01:03:42.086 --> 01:03:44.982
But, if we can prove this,
that d of v equals delta of s,

01:03:44.982 --> 01:03:47.258
v, when you add to S,
we know relaxation only

01:03:47.258 --> 01:03:49.586
decreases value.
So, it can't get any smaller.

01:03:49.586 --> 01:03:51.241
It would be from correctness
one.

01:03:51.241 --> 01:03:54.137
Correctness one says we can't
get any smaller than delta.

01:03:54.137 --> 01:03:57.396
So, if we get a quality at that
point, we'll have a quality from

01:03:57.396 --> 01:03:59.362
then on.
So, that actually implies d of

01:03:59.362 --> 01:04:02.000
v never changes after that
point.

01:04:02.000 --> 01:04:06.085
OK, so we're going to prove
this.

01:04:06.085 --> 01:04:10.297
Good.
Well, suppose it isn't true.

01:04:10.297 --> 01:04:15.787
So this would be a proof by a
contradiction.

01:04:15.787 --> 01:04:22.042
Suppose for contradiction that
this fails to hold.

01:04:22.042 --> 01:04:26.638
And, let's look at the first
failure.

01:04:26.638 --> 01:04:32.000
Suppose u is the first vertex
--

01:04:41.000 --> 01:04:45.053
-- that's about to be added to
S.

01:04:45.053 --> 01:04:52.146
I want to consider the time
right before it's added to S,

01:04:52.146 --> 01:04:56.706
for which we don't have what we
want.

01:04:56.706 --> 01:05:04.166
These are not equal.
d of u does not equal delta of

01:05:04.166 --> 01:05:08.611
s, u.
Well, if they're not equal,

01:05:08.611 --> 01:05:16.805
we know from correctness one
that d of E is strictly greater

01:05:16.805 --> 01:05:20.971
than delta of s,
u, so, d of u.

01:05:20.971 --> 01:05:28.471
So, we have d of u is strictly
greater than delta of s,

01:05:28.471 --> 01:05:32.852
u.
OK, that's the beginning of the

01:05:32.852 --> 01:05:37.453
proof, nothing too exciting yet,
just some warm-up.

01:05:37.453 --> 01:05:41.319
OK, but this,
used already correctness one.

01:05:41.319 --> 01:05:46.564
I think that's the only time
that we use it in this proof.

01:05:46.564 --> 01:05:52.177
OK, so I sort of just want to
draw picture of what's going on.

01:05:52.177 --> 01:05:55.674
But I need a little bit of
description.

01:05:55.674 --> 01:06:00.000
So, let's look at the shortest
path.

01:06:00.000 --> 01:06:04.176
Somehow, d of u is greater than
the shortest path.

01:06:04.176 --> 01:06:08.352
So, consider the shortest path
or a shortest path.

01:06:08.352 --> 01:06:12.784
Let p be a shortest path,
not just any shortest path,

01:06:12.784 --> 01:06:15.596
but the shortest path from s to
u.

01:06:15.596 --> 01:06:20.028
OK, so that means that the
weight of this path is the

01:06:20.028 --> 01:06:24.375
shortest path weight.
So, we have some equations for

01:06:24.375 --> 01:06:28.636
what's going on here.
So, we care about delta of s,

01:06:28.636 --> 01:06:32.791
u.
Here's a path with that weight.

01:06:32.791 --> 01:06:37.473
It's got to be one because
shortest paths exist here;

01:06:37.473 --> 01:06:41.796
slight exceptional cases if
it's a plus infinity,

01:06:41.796 --> 01:06:45.127
but I'm not going to worry
about that.

01:06:45.127 --> 01:06:49.000
So, let me draw a picture
somewhere.

01:07:03.000 --> 01:07:06.283
So, we have s.
We have u.

01:07:06.283 --> 01:07:11.344
Here is the shortest path from
s to u.

01:07:11.344 --> 01:07:16.542
That's p.
No idea what it looks like so

01:07:16.542 --> 01:07:21.056
far.
Now, what we also have is the

01:07:21.056 --> 01:07:27.759
notion of capital S.
So, I'm going to draw capital

01:07:27.759 --> 01:07:32.000
S.
So, this is big S.

01:07:32.000 --> 01:07:34.600
We know that little s is in big
S.

01:07:34.600 --> 01:07:37.279
We know that u is not yet in
big S.

01:07:37.279 --> 01:07:40.195
So, I haven't screwed up
anything yet,

01:07:40.195 --> 01:07:42.638
right?
This path starts in S and

01:07:42.638 --> 01:07:47.445
leaves it at some point because
until we are about to add u to

01:07:47.445 --> 01:07:51.070
S, so it hasn't happened yet,
so u is not in S.

01:07:51.070 --> 01:07:53.671
Fine.
What I want to do is look at

01:07:53.671 --> 01:07:57.375
the first place here where the
path, p, exits S.

01:07:57.375 --> 01:08:02.526
So, there is some vertex here.
Let's call it x.

01:08:02.526 --> 01:08:06.436
There's some vertex here.
We'll call it y.

01:08:06.436 --> 01:08:10.632
OK, possibly x equals S.
Possibly y equals u.

01:08:10.632 --> 01:08:16.260
But it's got to exit somewhere,
because it starts inside and

01:08:16.260 --> 01:08:19.979
ends up outside.
And it's a finite path.

01:08:19.979 --> 01:08:25.893
OK, so consider the first time
it happens; not the second time,

01:08:25.893 --> 01:08:29.803
the first.
OK, so consider the first edge,

01:08:29.803 --> 01:08:37.140
(x,y), where p exits capital S.
The shortest path from s to u

01:08:37.140 --> 01:08:42.014
exits capital S.
It's got to happen somewhere.

01:08:42.014 --> 01:08:46.779
Cool, now, what do we know?
Little x is in S.

01:08:46.779 --> 01:08:53.060
So, it has the right answer
because u, we were about to add

01:08:53.060 --> 01:08:59.776
u to S, and that was the first
violation of something in S that

01:08:59.776 --> 01:09:06.206
has the wrong d of x estimate.
So, d of x equals delta of s,

01:09:06.206 --> 01:09:08.565
x.
Because we are looking at the

01:09:08.565 --> 01:09:11.988
first violation,
x is something that got added

01:09:11.988 --> 01:09:14.423
before.
So, by induction on time,

01:09:14.423 --> 01:09:18.608
or because we had the first
violation, d of x equals the

01:09:18.608 --> 01:09:21.042
shortest path weight from S to
x.

01:09:21.042 --> 01:09:25.000
So, that's good news.
Now we are trying to apply this

01:09:25.000 --> 01:09:27.815
lemma.
It's the only thing left to do.

01:09:27.815 --> 01:09:32.000
We haven't used this lemma for
anything.

01:09:32.000 --> 01:09:35.358
So, we have the setup.
If we already know that one of

01:09:35.358 --> 01:09:38.974
the d values is the right
answer, and we relaxed the edge

01:09:38.974 --> 01:09:42.009
that goes out from it,
then we get another right

01:09:42.009 --> 01:09:44.399
answer.
So that's what I want to argue

01:09:44.399 --> 01:09:46.982
over here.
We know that the d of x equals

01:09:46.982 --> 01:09:50.017
this weight because,
again, subpaths of shortest

01:09:50.017 --> 01:09:53.504
paths are shortest paths.
We have optimal substructure,

01:09:53.504 --> 01:09:56.023
so this is a shortest path,
from S to x.

01:09:56.023 --> 01:09:58.800
It might not be the only one,
but it is one.

01:09:58.800 --> 01:10:02.029
So we know that matches.
Now, I want to think about

01:10:02.029 --> 01:10:05.000
relaxing this edge,
(x,y).

01:10:05.000 --> 01:10:08.536
Well, x is in capital S.
And, the algorithm says,

01:10:08.536 --> 01:10:11.778
whenever you add a vertex,
u, to the big set,

01:10:11.778 --> 01:10:15.389
S, you relax all the edges that
go out from there.

01:10:15.389 --> 01:10:19.368
OK, so when we added x to S,
and we now look far in the

01:10:19.368 --> 01:10:22.610
future, we're about to add some
other vertex.

01:10:22.610 --> 01:10:26.073
Right after we added x to S,
we relax this edge,

01:10:26.073 --> 01:10:30.273
(x,y), because we relaxed every
edge that goes out from x,

01:10:30.273 --> 01:10:36.443
OK, whatever they were.
Some of them went into S.

01:10:36.443 --> 01:10:42.091
Some of them went out.
Here's one of them.

01:10:42.091 --> 01:10:46.913
So, when we added x to S,
we got XS.

01:10:46.913 --> 01:10:52.561
When we added x to S,
we relaxed the edge,

01:10:52.561 --> 01:10:57.382
(x,y).
OK, so now we're going to use

01:10:57.382 --> 01:11:04.000
the lemma.
So, by the correctness lemma --

01:11:15.000 --> 01:11:18.863
What do you get?
Well, we add this correct

01:11:18.863 --> 01:11:23.387
shortest path weight to x now.
We relax the edge,

01:11:23.387 --> 01:11:26.403
(x,y).
So, now we should have the

01:11:26.403 --> 01:11:29.607
correct shortest path weight for
y.

01:11:29.607 --> 01:11:33.000
d of y equals delta of s,
y.

01:11:33.000 --> 01:11:35.509
OK, this is sometime in the
past.

01:11:35.509 --> 01:11:38.803
In particular,
now, it should still be true

01:11:38.803 --> 01:11:43.588
because once you get down to the
right answer you never change

01:11:43.588 --> 01:11:45.549
it.
OK, we should be done.

01:11:45.549 --> 01:11:49.156
OK, why are we done?
Well, what else do we know

01:11:49.156 --> 01:11:51.431
here?
We assumed something for

01:11:51.431 --> 01:11:54.803
contradiction,
so we better contradict that.

01:11:54.803 --> 01:11:58.647
We assume somehow,
d of u is strictly greater than

01:11:58.647 --> 01:12:03.142
delta of s, u.
So, d of u here is strictly

01:12:03.142 --> 01:12:06.476
greater than the length of this
whole path.

01:12:06.476 --> 01:12:10.047
Well, we don't really know
whether u equals y.

01:12:10.047 --> 01:12:14.015
It could, could not.
And, but what do we know about

01:12:14.015 --> 01:12:18.857
this shortest path from S to y?
Well, it could only be shorter

01:12:18.857 --> 01:12:21.952
than from S to u because it's a
subpath.

01:12:21.952 --> 01:12:26.476
And it's the shortest path
because it's the subpath of the

01:12:26.476 --> 01:12:29.888
shortest path.
The shortest path from S to y

01:12:29.888 --> 01:12:36.000
has to be less than or equal to
the shortest path from S to u.

01:12:36.000 --> 01:12:44.627
OK, S to y: less than or equal
to s, u, OK, just because the

01:12:44.627 --> 01:12:47.405
subpath.
I'm closer.

01:12:47.405 --> 01:12:51.207
I've got delta of s,
u now.

01:12:51.207 --> 01:12:56.033
Somehow, I want to involve d of
u.

01:12:56.033 --> 01:13:01.443
So, I want to relate d of y to
d of u.

01:13:01.443 --> 01:13:07.389
What do I know about d of u?
Yeah?

01:13:07.389 --> 01:13:10.814
d of u is smaller because we
have a Min heap,

01:13:10.814 --> 01:13:12.449
yeah.
We always chose,

01:13:12.449 --> 01:13:14.862
let's erase,
it's way down here.

01:13:14.862 --> 01:13:17.664
We chose u.
This is the middle of the

01:13:17.664 --> 01:13:20.778
algorithm.
It's the reason I kept this to

01:13:20.778 --> 01:13:23.736
be the minimum key.
This is keyed on d.

01:13:23.736 --> 01:13:28.095
So, we know that at this
moment, when we're trying to add

01:13:28.095 --> 01:13:30.275
u to S, right,
y is not in S,

01:13:30.275 --> 01:13:35.412
and u is not in S.
They might actually be the same

01:13:35.412 --> 01:13:38.057
vertex.
But both of these vertices,

01:13:38.057 --> 01:13:40.080
same or not,
are outside S.

01:13:40.080 --> 01:13:44.204
We chose u because d of u has
the smallest d estimate.

01:13:44.204 --> 01:13:48.250
So, d of y has to be greater
than or equal to d of u.

01:13:48.250 --> 01:13:51.674
It might be equal if they're
the same vertex,

01:13:51.674 --> 01:13:55.020
but it's got to be greater than
or equal to.

01:13:55.020 --> 01:14:00.000
So, d of y here is greater than
or equal to d of u.

01:14:00.000 --> 01:14:03.791
So, here we're using the fact
that we actually made a greedy

01:14:03.791 --> 01:14:06.168
choice.
It's the one place we're using

01:14:06.168 --> 01:14:09.317
the greedy choice.
Better use it somewhere because

01:14:09.317 --> 01:14:13.108
you can't just take an arbitrary
vertex and declare it to be

01:14:13.108 --> 01:14:15.293
done.
You've got to take the greedy

01:14:15.293 --> 01:14:17.477
one.
OK, now we have d of u is less

01:14:17.477 --> 01:14:20.947
than or equal to delta of s,
u, which contradicts this.

01:14:20.947 --> 01:14:24.096
OK, sort of magical that that
all just worked out.

01:14:24.096 --> 01:14:27.566
But sort of like the previous
proofs, you just see what

01:14:27.566 --> 01:14:32.000
happens and it works.
OK, that's the approximation.

01:14:32.000 --> 01:14:35.005
The only real idea here is to
look at this edge.

01:14:35.005 --> 01:14:37.563
In fact, you could look at this
edge too.

01:14:37.563 --> 01:14:41.209
But let's look at some edge
that comes from S and goes out

01:14:41.209 --> 01:14:44.151
of S, and argue that while x has
to be correct,

01:14:44.151 --> 01:14:47.156
and what we made x correct,
y had to be correct,

01:14:47.156 --> 01:14:49.779
and now, why the hell are we
looking at u?

01:14:49.779 --> 01:14:52.337
y is the thing you should have
looked at.

01:14:52.337 --> 01:14:55.598
And, there you get a
contradiction because y had the

01:14:55.598 --> 01:14:57.325
right answer.
If u equals y,

01:14:57.325 --> 01:14:59.755
that's fine,
or if u and y were sort of

01:14:59.755 --> 01:15:02.441
equally good,
that's also fine if all these

01:15:02.441 --> 01:15:07.604
weights were zero.
So, the picture might actually

01:15:07.604 --> 01:15:10.469
look like this.
But, in that case,

01:15:10.469 --> 01:15:14.376
d of u is the correct answer.
It was delta SU.

01:15:14.376 --> 01:15:19.064
We assumed that it wasn't.
That's where we're getting a

01:15:19.064 --> 01:15:21.408
contradiction.
Pretty clear?

01:15:21.408 --> 01:15:25.054
Go over this proof.
It's a bit complicated,

01:15:25.054 --> 01:15:28.440
naturally.
OK, we have a little bit more

01:15:28.440 --> 01:15:34.168
to cover, some easier stuff.
OK, the first thing is what's

01:15:34.168 --> 01:15:36.710
the running time of this
algorithm?

01:15:36.710 --> 01:15:41.196
I'll do this very quick because
we're actually seen this many

01:15:41.196 --> 01:15:45.233
times before last class.
There was some initialization.

01:15:45.233 --> 01:15:48.448
The initialization,
which is no longer here,

01:15:48.448 --> 01:15:50.467
is linear time.
No big deal.

01:15:50.467 --> 01:15:53.308
OK, extract Min.
Well, that's some data

01:15:53.308 --> 01:15:56.373
structure.
So, we have something like size

01:15:56.373 --> 01:15:59.065
of V.
Every vertex we extract the Min

01:15:59.065 --> 01:16:01.607
once, and that's it.
So, size of V,

01:16:01.607 --> 01:16:06.634
extract mins.
OK, so that's pretty simple.

01:16:06.634 --> 01:16:12.466
OK, then we had this main loop.
This is a completely conceptual

01:16:12.466 --> 01:16:16.135
operation.
S is not actually used in the

01:16:16.135 --> 01:16:19.240
algorithm.
It's just for thinking.

01:16:19.240 --> 01:16:23.285
OK, so this takes zero time.
Got to love it.

01:16:23.285 --> 01:16:28.742
OK, and now the heart is here.
So, how many times does this

01:16:28.742 --> 01:16:33.324
loop iterate?
That's the degree of u.

01:16:33.324 --> 01:16:38.780
So, what is the total number of
times that we execute a

01:16:38.780 --> 01:16:43.428
relaxation step?
It doesn't necessarily mean we

01:16:43.428 --> 01:16:47.672
do this, but we at least execute
this body.

01:16:47.672 --> 01:16:53.128
Over the whole algorithm,
how many times do we do this?

01:16:53.128 --> 01:16:57.170
Every vertex,
we look at all the outgoing

01:16:57.170 --> 01:17:02.000
edges from there.
So, the total would be?

01:17:11.000 --> 01:17:12.615
Number of edges,
yeah.

01:17:12.615 --> 01:17:15.307
So, this number of edges
iterations.

01:17:15.307 --> 01:17:19.615
OK, this is essentially the
handshaking lemma we saw last

01:17:19.615 --> 01:17:24.230
time, but for directed graphs.
And we are only looking at the

01:17:24.230 --> 01:17:27.538
outgoing edges.
So, it's not a factor of two

01:17:27.538 --> 01:17:32.000
here because you're only
outgoing from one side.

01:17:32.000 --> 01:17:36.573
So, we have number of
reiterations.

01:17:36.573 --> 01:17:42.358
In the worst case,
we do a decreased key for

01:17:42.358 --> 01:17:45.183
everyone.
So, at most:

01:17:45.183 --> 01:17:50.026
E decreased keys.
OK, so the time is,

01:17:50.026 --> 01:17:57.695
well, we have v extract Mins,
so the time to do an extract

01:17:57.695 --> 01:18:05.771
Min, whatever that is.
And we have E decreased keys,

01:18:05.771 --> 01:18:12.013
whatever that is,
and this is exactly the running

01:18:12.013 --> 01:18:20.336
time we had for Prim's algorithm
for a minimum spanning tree last

01:18:20.336 --> 01:18:24.237
time.
And, it depends what data

01:18:24.237 --> 01:18:31.000
structure you use,
what running time you get.

01:18:31.000 --> 01:18:34.688
So, I'm going to skip the whole
table here.

01:18:34.688 --> 01:18:39.518
But, if you use an array,
the final running time will be

01:18:39.518 --> 01:18:44.436
V^2 because you have order of v
extract Min, and you have

01:18:44.436 --> 01:18:49.090
constant time decreased key.
If you use a binary heap,

01:18:49.090 --> 01:18:53.568
which we know and love,
then we have order log v for

01:18:53.568 --> 01:18:57.609
each operation.
And so, this is V plus E log V.

01:18:57.609 --> 01:19:02.000
And, so that's what we know how
to do.

01:19:02.000 --> 01:19:06.830
And, if you use this fancy data
structure called a Fibonacci

01:19:06.830 --> 01:19:11.005
heap, you get constant time
decreased key amortized.

01:19:11.005 --> 01:19:16.000
And, you get an E plus v log v
worst case bound on the running

01:19:16.000 --> 01:19:18.701
time.
So, this is the best we know

01:19:18.701 --> 01:19:23.368
how to solve shortest paths
without any extra assumptions,

01:19:23.368 --> 01:19:28.116
single source shortest paths
with non-negative edge weights

01:19:28.116 --> 01:19:32.040
in general.
OK, this is almost as good and

01:19:32.040 --> 01:19:34.353
this is sometimes better than
that.

01:19:34.353 --> 01:19:38.163
But these are essentially
irrelevant except that you know

01:19:38.163 --> 01:19:41.020
how to do these.
You don't know how to do a

01:19:41.020 --> 01:19:45.238
Fibonacci heap unless you read
that in the chapter of the book.

01:19:45.238 --> 01:19:48.434
That's why we mention the top
two running times.

01:19:48.434 --> 01:19:51.632
OK, I want to talk briefly
about a simpler case,

01:19:51.632 --> 01:19:55.510
which you may have seen before.
And so it's sort of fun to

01:19:55.510 --> 01:20:00.000
connect this up to breadth first
search in a graph.

01:20:00.000 --> 01:20:03.302
So, I mean that ends Dijkstra,
so to speak.

01:20:03.302 --> 01:20:08.175
But now I want to think about a
special case where the graph is

01:20:08.175 --> 01:20:12.737
unweighted, meaning w of (u,v)
equals one for all vertices,

01:20:12.737 --> 01:20:15.174
u and v.
OK, suppose we had that

01:20:15.174 --> 01:20:17.847
property.
Can we do any better than

01:20:17.847 --> 01:20:20.599
Dijkstra?
Can we do better than this

01:20:20.599 --> 01:20:23.980
running time?
Well, we probably have to look

01:20:23.980 --> 01:20:26.889
at all the edges and all the
vertices.

01:20:26.889 --> 01:20:32.000
So, the only thing I'm
questioning is this log v.

01:20:32.000 --> 01:20:36.067
Can I avoid that?
I gave away the answer a little

01:20:36.067 --> 01:20:38.779
bit.
The answer is called breadth

01:20:38.779 --> 01:20:42.508
first search,
or BFS, which you have probably

01:20:42.508 --> 01:20:45.813
seen before.
Next to depth first search,

01:20:45.813 --> 01:20:50.050
it's one of the standard ways
to look at the graph.

01:20:50.050 --> 01:20:54.627
But we can say a little bit
more than you may have seen

01:20:54.627 --> 01:20:57.762
before.
Breadth for search is actually

01:20:57.762 --> 01:21:02.000
Dijkstra's algorithm:
kind of nifty.

01:21:02.000 --> 01:21:08.607
There are two changes.
First change is that breadth

01:21:08.607 --> 01:21:13.894
for search does not use a
priority queue.

01:21:13.894 --> 01:21:19.048
I'll just tell you what it uses
instead.

01:21:19.048 --> 01:21:26.449
You can use a queue first in
first out honest-to-goodness

01:21:26.449 --> 01:21:32.000
queue instead of a priority
queue.

01:21:32.000 --> 01:21:36.728
OK, it turns out that works.
Instead of doing extract Min,

01:21:36.728 --> 01:21:40.295
you just take the first thing
off the queue.

01:21:40.295 --> 01:21:44.692
Instead of doing decreased key,
OK, here's a subtlety.

01:21:44.692 --> 01:21:48.260
But, this if statement changes
a little bit.

01:21:48.260 --> 01:21:50.831
So, here is the relaxation
step.

01:21:50.831 --> 01:21:54.730
So, in order to relax,
you say this much simpler

01:21:54.730 --> 01:21:57.550
thing.
If we haven't visited v yet,

01:21:57.550 --> 01:22:01.782
then we declare it to have the
shortest path weight,

01:22:01.782 --> 01:22:06.511
say, d of v is d of u plus one,
which is the weight of the

01:22:06.511 --> 01:22:12.423
edge, (u,v).
And we add v to the end of the

01:22:12.423 --> 01:22:16.076
queue.
So, now, we start with the

01:22:16.076 --> 01:22:20.869
queue empty.
Actually, it will just contain

01:22:20.869 --> 01:22:25.777
the vertex, S,
because that's the only thing

01:22:25.777 --> 01:22:31.347
we know the shortest path for.
So, the queue is just for,

01:22:31.347 --> 01:22:33.316
I know the shortest path of
this thing.

01:22:33.316 --> 01:22:36.217
Just deal with it when you
can't look at all the outgoing

01:22:36.217 --> 01:22:38.652
edges when you can.
So, initially that's just S.

01:22:38.652 --> 01:22:40.777
You say, well,
for all the outgoing edges,

01:22:40.777 --> 01:22:42.746
S has zero.
All the outgoing edges from

01:22:42.746 --> 01:22:45.388
there have weight one.
The shortest path weight from

01:22:45.388 --> 01:22:47.668
the source is one.
You certainly can't do any

01:22:47.668 --> 01:22:49.896
better than that if all the
weights are one.

01:22:49.896 --> 01:22:52.434
OK, so we add all those
vertices to the end of the

01:22:52.434 --> 01:22:54.093
queue.
Then, we process things in

01:22:54.093 --> 01:22:55.958
order, and we just keep
incrementing,

01:22:55.958 --> 01:22:57.979
if their value is d of u,
add one to it.

01:22:57.979 --> 01:23:02.543
That's d of v.
And then we are going to add v

01:23:02.543 --> 01:23:05.510
to S what we get to it in the
queue.

01:23:05.510 --> 01:23:09.156
OK, that is breadth for search,
very simple.

01:23:09.156 --> 01:23:13.989
And, you can look at the text
for the algorithm and for an

01:23:13.989 --> 01:23:17.973
example because I don't have
time to cover that.

01:23:17.973 --> 01:23:21.704
But the key thing is that the
time is faster.

01:23:21.704 --> 01:23:25.434
The time is order V plus E
because as before,

01:23:25.434 --> 01:23:30.267
we only look at each edge once
we look at all the outgoing

01:23:30.267 --> 01:23:34.930
edges from all the vertices.
As soon as we set d of v to

01:23:34.930 --> 01:23:40.079
something, it will remain that.
We never touch it.

01:23:40.079 --> 01:23:43.136
We are going to add it to S.
That only happens once.

01:23:43.136 --> 01:23:46.193
So, this if statement,
and so on, in the in-queuing,

01:23:46.193 --> 01:23:48.711
is done order E times,
or actually E times,

01:23:48.711 --> 01:23:50.689
exactly.
An in-queuing to a queue,

01:23:50.689 --> 01:23:54.106
and de-queuing from a queue,
that's what we use instead of

01:23:54.106 --> 01:23:57.583
extract Min, take constant time,
so the total running time,

01:23:57.583 --> 01:24:01.000
number of vertices plus the
number of edges.

01:24:01.000 --> 01:24:04.580
OK, not so obvious that this
works, but you can prove that it

01:24:04.580 --> 01:24:06.550
works using the Dijkstra
analysis.

01:24:06.550 --> 01:24:09.891
All you have to do is prove
that the FIFO priority queue.

01:24:09.891 --> 01:24:12.816
Once you know that,
by the correctness of Dijkstra

01:24:12.816 --> 01:24:15.501
you get the correctness of
breadth for search.

01:24:15.501 --> 01:24:19.022
So, not only is breadth for
search finding all the vertices,

01:24:19.022 --> 01:24:21.588
which is maybe what you
normally use it for,

01:24:21.588 --> 01:24:25.109
but it finds the shortest path
weights from S to every other

01:24:25.109 --> 01:24:27.198
vertex when the weights are all
one.

01:24:27.198 --> 01:24:30.003
So, there we go:
introduction to shortest paths.

01:24:30.003 --> 01:24:33.000
Next time we'll deal with
negative weights.