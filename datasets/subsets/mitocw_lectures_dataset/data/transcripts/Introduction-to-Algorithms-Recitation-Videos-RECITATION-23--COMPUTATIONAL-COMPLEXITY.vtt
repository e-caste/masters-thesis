WEBVTT

00:00:00.080 --> 00:00:01.800
The following
content is provided

00:00:01.800 --> 00:00:04.040
under a Creative
Commons license.

00:00:04.040 --> 00:00:06.890
Your support will help MIT
OpenCourseWare continue

00:00:06.890 --> 00:00:10.740
to offer high quality
educational resources for free.

00:00:10.740 --> 00:00:13.350
To make a donation or
view additional materials

00:00:13.350 --> 00:00:17.237
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.237 --> 00:00:17.862
at ocw.mit.edu.

00:00:22.272 --> 00:00:23.730
PROFESSOR:
Computational complexity

00:00:23.730 --> 00:00:27.167
is basically about how
hard is a problem, right?

00:00:27.167 --> 00:00:29.000
There are some problems
that are really easy

00:00:29.000 --> 00:00:31.310
and some problems
that are really hard.

00:00:31.310 --> 00:00:34.130
And Eric drew this
line on the board

00:00:34.130 --> 00:00:37.600
where you have really
easy on the left

00:00:37.600 --> 00:00:38.920
and really hard on the right.

00:00:41.990 --> 00:00:44.630
What's the hardest problem
that we can possibly have?

00:00:47.822 --> 00:00:49.190
AUDIENCE: It was chess, right?

00:00:49.190 --> 00:00:50.980
Or something like that?

00:00:50.980 --> 00:00:53.784
PROFESSOR: No, there's
something beyond chess.

00:00:53.784 --> 00:00:54.950
AUDIENCE: A halting problem?

00:00:54.950 --> 00:00:55.256
PROFESSOR: Halting problem.

00:00:55.256 --> 00:00:55.881
AUDIENCE: Yeah.

00:00:55.881 --> 00:00:56.600
PROFESSOR: Yep.

00:00:56.600 --> 00:00:58.530
Halting problem
is somewhere here.

00:01:03.830 --> 00:01:08.710
So what's the best solution
for the halting problem?

00:01:08.710 --> 00:01:10.006
Running time.

00:01:10.006 --> 00:01:11.755
AUDIENCE: It is
exponential, or something?

00:01:11.755 --> 00:01:13.332
PROFESSOR: You'd wish.

00:01:13.332 --> 00:01:14.165
AUDIENCE: Oh really?

00:01:14.165 --> 00:01:15.590
It's not even exponential?

00:01:15.590 --> 00:01:17.970
AUDIENCE: I think
there's like no solution.

00:01:17.970 --> 00:01:20.470
PROFESSOR: There is no solution
for the halting problem.

00:01:20.470 --> 00:01:23.610
No matter how much time,
computers, and money you have,

00:01:23.610 --> 00:01:25.420
you cannot solve
the halting problem.

00:01:25.420 --> 00:01:27.080
It's undesignable.

00:01:27.080 --> 00:01:30.617
So this is the worst kind of
problem you can come up with.

00:01:30.617 --> 00:01:32.802
AUDIENCE: What exactly
is the halting problem?

00:01:32.802 --> 00:01:35.210
PROFESSOR: So halting
problem is given

00:01:35.210 --> 00:01:38.100
a program in any representation
that makes sense to you,

00:01:38.100 --> 00:01:41.680
machine language, CE, assembly,
parsing tree, whatever

00:01:41.680 --> 00:01:46.250
you want, decide if
it terminates or not.

00:01:46.250 --> 00:01:48.080
Sounds really simple, right?

00:01:48.080 --> 00:01:51.910
Turns out there's a proof that
says it's impossible to solve.

00:01:51.910 --> 00:01:54.900
So you can't say will terminate
or will not terminate.

00:01:54.900 --> 00:01:58.365
AUDIENCE: Well, but for some
programs, it's like while true,

00:01:58.365 --> 00:02:00.290
but there's no break.

00:02:00.290 --> 00:02:02.251
PROFESSOR: So Turing Machine.

00:02:02.251 --> 00:02:02.750
Yeah.

00:02:02.750 --> 00:02:04.958
If you have a machine where
you're not allowed loops,

00:02:04.958 --> 00:02:07.331
then it's easy to know
what's going to happen.

00:02:07.331 --> 00:02:09.289
So you need to have a
Turing machine, something

00:02:09.289 --> 00:02:10.810
that allows loops.

00:02:10.810 --> 00:02:12.960
So some instances
are easy, right?

00:02:12.960 --> 00:02:14.840
But for the general
case of you have

00:02:14.840 --> 00:02:18.470
to write a program that gets
another program and outputs

00:02:18.470 --> 00:02:21.550
this bit, we don't
know how to do that.

00:02:21.550 --> 00:02:24.590
But we've proven that nobody
will know how to do that,

00:02:24.590 --> 00:02:26.827
so we're OK with it.

00:02:26.827 --> 00:02:27.910
So this means undecidable.

00:02:30.950 --> 00:02:34.039
We know that nobody will
ever be able to solve this.

00:02:34.039 --> 00:02:36.330
So if you're given the halting
problem on an interview,

00:02:36.330 --> 00:02:38.642
it's safe to laugh in the
guy's face and tell them,

00:02:38.642 --> 00:02:40.100
why don't you show
me how to do it?

00:02:43.590 --> 00:02:46.200
So what is better
than undecidable?

00:02:46.200 --> 00:02:51.070
There are these problems here
that are outright impossible.

00:02:51.070 --> 00:02:54.056
What's the next best thing?

00:02:54.056 --> 00:02:55.892
AUDIENCE: Chess?

00:02:55.892 --> 00:02:57.730
I know chess is in
there somewhere.

00:02:57.730 --> 00:02:59.430
PROFESSOR: Chess is still here.

00:02:59.430 --> 00:03:03.140
There's something
harder than that.

00:03:03.140 --> 00:03:05.675
AUDIENCE: Is it R, or
something like that?

00:03:05.675 --> 00:03:06.300
PROFESSOR: Yup.

00:03:10.380 --> 00:03:13.020
So this is the boundary
for R and this whole thing

00:03:13.020 --> 00:03:16.350
is R. What R?

00:03:16.350 --> 00:03:19.110
R is-- so if these
are undecidable,

00:03:19.110 --> 00:03:20.430
R means decidable, right?

00:03:20.430 --> 00:03:25.850
So you can write an algorithm
that will compute the answer

00:03:25.850 --> 00:03:29.210
and do that in a
finite amount of time.

00:03:29.210 --> 00:03:31.490
Will the world end before
the algorithm ends?

00:03:31.490 --> 00:03:33.180
Maybe, who knows.

00:03:33.180 --> 00:03:35.210
But at least there's a
finite amount of time,

00:03:35.210 --> 00:03:39.190
so the problem can
be solved somehow.

00:03:39.190 --> 00:03:40.050
That means R.

00:03:40.050 --> 00:03:43.770
AUDIENCE: R is like,
real, like it's not.

00:03:43.770 --> 00:03:44.790
PROFESSOR: Real, OK.

00:03:44.790 --> 00:03:47.360
AUDIENCE: So like numbers,
like, you know, real numbers--

00:03:47.360 --> 00:03:49.760
PROFESSOR: So you know it
actually comes from recursive,

00:03:49.760 --> 00:03:52.320
because some old people
decided that recursive

00:03:52.320 --> 00:03:55.820
means it terminates
at some point.

00:03:55.820 --> 00:03:59.570
This is really old
school stuff, 1940.

00:03:59.570 --> 00:04:03.350
So R actually stands
for recursive.

00:04:03.350 --> 00:04:06.710
Just know that R
means decidable.

00:04:06.710 --> 00:04:09.132
Weird abbreviation, but oh well.

00:04:09.132 --> 00:04:10.780
AUDIENCE: I'll go with real.

00:04:10.780 --> 00:04:12.200
PROFESSOR: OK.

00:04:12.200 --> 00:04:12.830
What's next?

00:04:12.830 --> 00:04:16.000
So some problems are
in R. All the ones

00:04:16.000 --> 00:04:19.230
that we care about are in r.

00:04:19.230 --> 00:04:20.900
So what's better than r?

00:04:20.900 --> 00:04:22.930
R means it's going to
terminate at some point,

00:04:22.930 --> 00:04:24.950
there is a running
time for the problem.

00:04:24.950 --> 00:04:26.360
What's the better than that?

00:04:26.360 --> 00:04:28.180
Exponential, OK.

00:04:28.180 --> 00:04:30.709
What does exponential mean?

00:04:30.709 --> 00:04:31.625
AUDIENCE: Exponential?

00:04:35.850 --> 00:04:36.990
PROFESSOR: Yup.

00:04:36.990 --> 00:04:40.303
So the running time
looks like what?

00:04:40.303 --> 00:04:45.213
AUDIENCE: 2 to the 10, or
something constant to the n?

00:04:45.213 --> 00:04:48.480
2 to the n of the C?

00:04:48.480 --> 00:04:51.030
PROFESSOR: For some
constant C, right?

00:04:51.030 --> 00:04:53.230
So it's not just 2 to the n.

00:04:53.230 --> 00:04:54.930
The moment you
have a 2 to the n,

00:04:54.930 --> 00:04:56.310
we're like, OK,
if you're already

00:04:56.310 --> 00:04:58.480
in this bad of a
situation, I don't

00:04:58.480 --> 00:05:00.790
care if this is a polynomial.

00:05:00.790 --> 00:05:02.982
I don't care if it's
an n or n to the 100,

00:05:02.982 --> 00:05:04.440
you're already
pretty much screwed,

00:05:04.440 --> 00:05:07.690
you're not going to solve
this before the world ends.

00:05:07.690 --> 00:05:09.979
So that's what
exponential means.

00:05:09.979 --> 00:05:11.770
Going to solve it, but
not before the world

00:05:11.770 --> 00:05:15.830
ends for most
practical problems.

00:05:15.830 --> 00:05:18.956
What's better than exponential?

00:05:18.956 --> 00:05:19.914
AUDIENCE: NP.

00:05:25.179 --> 00:05:26.970
PROFESSOR: OK, and
before we talk about NP,

00:05:26.970 --> 00:05:28.880
let's talk about the
easy case, the problems

00:05:28.880 --> 00:05:31.115
that we've talked about all
the time in the semester.

00:05:31.115 --> 00:05:33.238
AUDIENCE: May I ask
you a stupid question?

00:05:33.238 --> 00:05:35.867
What does NP stand for?

00:05:35.867 --> 00:05:37.450
PROFESSOR: It's not
a stupid question.

00:05:37.450 --> 00:05:39.450
It has a really hard to answer.

00:05:39.450 --> 00:05:43.830
So the one-sentence
answer is NP stands

00:05:43.830 --> 00:05:45.700
for non deterministic binomial.

00:05:45.700 --> 00:05:48.251
And we're going to go
over that at some point

00:05:48.251 --> 00:05:49.250
in the next few minutes.

00:06:04.480 --> 00:06:06.760
OK, so what problems
have we talked about?

00:06:06.760 --> 00:06:08.810
All the terms, except
for one problem,

00:06:08.810 --> 00:06:11.042
for the knapsack
problem, the entire term

00:06:11.042 --> 00:06:12.625
we talked about some
sort of problems.

00:06:15.770 --> 00:06:16.410
Polynomial.

00:06:16.410 --> 00:06:20.270
These are the
reasonably easy ones.

00:06:20.270 --> 00:06:32.830
So polynomial problems are those
where t of n is n to the C,

00:06:32.830 --> 00:06:34.640
so it's a binomial.

00:06:34.640 --> 00:06:38.420
The running time is a binomial
in terms of the input sites.

00:06:38.420 --> 00:06:40.050
Why does this matter?

00:06:40.050 --> 00:06:42.930
If you have a
polynomial algorithm,

00:06:42.930 --> 00:06:48.260
than if you double the
input, then the running time

00:06:48.260 --> 00:06:52.870
is going to be 2 to
the C times n to the C.

00:06:52.870 --> 00:06:54.460
So every time you
double the input,

00:06:54.460 --> 00:06:57.510
the running time will
increase by a constant factor.

00:06:57.510 --> 00:07:00.510
And you know what that is.

00:07:00.510 --> 00:07:04.320
If your problem is exponential,
then if you double the input,

00:07:04.320 --> 00:07:08.180
then the running time
increases quadratically.

00:07:08.180 --> 00:07:09.990
It's not a linear increase.

00:07:09.990 --> 00:07:11.185
Here it's a linear increase.

00:07:14.890 --> 00:07:17.710
The factor isn't 2, but it's
still a linear increase.

00:07:20.610 --> 00:07:22.230
Make sense?

00:07:22.230 --> 00:07:24.210
So that's why we like
these problems, at least

00:07:24.210 --> 00:07:27.900
we like them more
than anything else.

00:07:27.900 --> 00:07:30.360
So polynomial problems
are the nice and easy ones

00:07:30.360 --> 00:07:33.740
that we've talked about so far.

00:07:33.740 --> 00:07:35.770
What does NP stand for?

00:07:35.770 --> 00:07:39.257
Give me a practical definition.

00:07:39.257 --> 00:07:40.882
AUDIENCE: You can
check it [INAUDIBLE].

00:07:46.350 --> 00:07:49.015
PROFESSOR: OK, so NP means
that we can write the verifier.

00:07:52.660 --> 00:07:56.540
I'm going to say exactly what
you said with different words.

00:07:56.540 --> 00:07:58.440
That takes a solution
to the problem.

00:08:04.420 --> 00:08:09.150
And of course, it has to
think the input to the problem

00:08:09.150 --> 00:08:13.590
and tells us is it correct
or is it not correct.

00:08:16.430 --> 00:08:20.280
And this very fire is NP.

00:08:20.280 --> 00:08:22.020
So the very fire runs
in polynomial time.

00:08:27.160 --> 00:08:27.660
Yes.

00:08:30.800 --> 00:08:35.350
So if the verifier runs
in polynomial time,

00:08:35.350 --> 00:08:38.070
what's the solution size
and what's the input size?

00:08:42.282 --> 00:08:46.000
AUDIENCE: I think the-- I mean,
the solution said it's like 01,

00:08:46.000 --> 00:08:47.889
right?

00:08:47.889 --> 00:08:49.555
PROFESSOR: If we have
decision problems.

00:08:52.520 --> 00:08:54.460
An algorithm that
solves an NP problem.

00:08:54.460 --> 00:08:56.700
If you run it
against the verifier,

00:08:56.700 --> 00:09:01.060
also has to convince you
that its answer is correct.

00:09:01.060 --> 00:09:04.420
So the problems that we
talked about in class

00:09:04.420 --> 00:09:06.750
were decidability problems
where you have to say,

00:09:06.750 --> 00:09:08.000
is it possible to do this?

00:09:08.000 --> 00:09:09.414
Yes or no.

00:09:09.414 --> 00:09:10.830
When you have a
verifier with you,

00:09:10.830 --> 00:09:13.750
then you have to output a string
that convinces the verifier

00:09:13.750 --> 00:09:16.710
that your answer is correct.

00:09:16.710 --> 00:09:18.650
So like if you
have a problem that

00:09:18.650 --> 00:09:23.970
says-- if you have three
sets, for example-- that says,

00:09:23.970 --> 00:09:29.380
given a logical expression, can
you assign variable values such

00:09:29.380 --> 00:09:31.090
that the expression is true?

00:09:31.090 --> 00:09:32.950
If I say yes, what
does that mean?

00:09:32.950 --> 00:09:34.060
That means nothing.

00:09:34.060 --> 00:09:37.140
How do I convince you
that my answer is correct?

00:09:37.140 --> 00:09:39.970
I will have to give you
the assignment, right?

00:09:39.970 --> 00:09:42.960
And then you can verify
in polynomial time

00:09:42.960 --> 00:09:46.580
if my answer is right or not.

00:09:46.580 --> 00:09:49.240
So the input to the
verifier, this solution,

00:09:49.240 --> 00:09:51.570
is not necessarily the decision.

00:09:51.570 --> 00:09:52.990
It's not just the
bit, yes or no.

00:09:56.720 --> 00:09:59.400
So if the verifier runs
in polynomial time,

00:09:59.400 --> 00:10:01.600
what's true about
the problem input

00:10:01.600 --> 00:10:03.880
and what's true about
the problem output which

00:10:03.880 --> 00:10:05.340
becomes an input
to the verifier?

00:10:12.440 --> 00:10:14.270
They have to be
polynomial in size.

00:10:14.270 --> 00:10:15.990
Otherwise, my
algorithm wouldn't be

00:10:15.990 --> 00:10:17.510
able to consume
them fast enough.

00:10:21.840 --> 00:10:26.980
So actually, polynomial
means that the running time

00:10:26.980 --> 00:10:28.970
is polynomial in the input size.

00:10:28.970 --> 00:10:31.440
So the input size is
automatically all set.

00:10:31.440 --> 00:10:34.650
But the solution has to be
polynomial in the input size

00:10:34.650 --> 00:10:35.150
as well.

00:10:50.222 --> 00:10:51.930
And if you're thinking
decision problems,

00:10:51.930 --> 00:10:54.100
you can be more rigorous
and call this a proof.

00:11:04.740 --> 00:11:08.750
So if this proof is
binomial in the input size,

00:11:08.750 --> 00:11:12.450
then if I'm really,
really lucky,

00:11:12.450 --> 00:11:14.500
I can take the
input to a problem,

00:11:14.500 --> 00:11:18.950
and I can flip coins and use
the corn results as bits,

00:11:18.950 --> 00:11:22.420
and put them together,
and create the proof.

00:11:22.420 --> 00:11:27.150
If I'm really, really lucky,
I'll get the right proof.

00:11:27.150 --> 00:11:29.180
Chances of that
happening almost zero,

00:11:29.180 --> 00:11:33.080
but if I'm really, really lucky,
conceptually I can get a proof.

00:11:33.080 --> 00:11:37.750
This is what a non-deterministic
polynomial means.

00:11:37.750 --> 00:11:40.170
It means that if you have
a magical machine where

00:11:40.170 --> 00:11:44.590
you can flip a coin, and
it will always be lucky,

00:11:44.590 --> 00:11:47.550
then you can output the
proof in polynomial time.

00:11:53.170 --> 00:11:54.040
So far so good?

00:11:57.830 --> 00:12:02.430
So this definition of a machine
that can flip random bits

00:12:02.430 --> 00:12:06.630
is really useful, because we can
use it to build a common sense

00:12:06.630 --> 00:12:08.850
proof that P is not NP.

00:12:08.850 --> 00:12:11.870
There is no real rigorous
math proof that P's not NP.

00:12:11.870 --> 00:12:14.036
That's worth a million dollars.

00:12:14.036 --> 00:12:16.220
There is no proof
that P equals NP.

00:12:16.220 --> 00:12:19.030
If you have proof
that P equals NP, then

00:12:19.030 --> 00:12:20.610
that's worth a lot more.

00:12:20.610 --> 00:12:23.010
And I will use that in
the common sense proof

00:12:23.010 --> 00:12:26.660
that I'm going to show you now.

00:12:26.660 --> 00:12:33.450
So we don't know if P is NP--
get it right-- if P is NP

00:12:33.450 --> 00:12:37.000
or if P is not NP.

00:12:37.000 --> 00:12:41.380
This is an open problem, and
there's at least $1 million

00:12:41.380 --> 00:12:44.140
worth of prize money for it.

00:12:47.090 --> 00:12:49.880
Let's talk about
an algorithm where

00:12:49.880 --> 00:12:51.630
if you would know--
so if you would

00:12:51.630 --> 00:12:55.620
be able to solve NP
problems in polynomial time,

00:12:55.620 --> 00:12:59.090
you would be able to
make a lot of money.

00:12:59.090 --> 00:13:00.960
A million dollars
is nothing compared

00:13:00.960 --> 00:13:02.904
to what you could make
if you could do that.

00:13:02.904 --> 00:13:04.570
So I'm going to use
that to convince you

00:13:04.570 --> 00:13:07.996
that nobody knows how to
solve NP problems in P time.

00:13:13.620 --> 00:13:15.460
Suppose you want to do
something really bad.

00:13:15.460 --> 00:13:18.370
Suppose you want to
impersonate a bank.

00:13:18.370 --> 00:13:21.280
So you guys probably
imagine that banks nowadays

00:13:21.280 --> 00:13:22.710
don't transfer
money to each other

00:13:22.710 --> 00:13:26.410
by sending trucks
with gold bars.

00:13:26.410 --> 00:13:29.200
They do that every once in
awhile, but most of the time

00:13:29.200 --> 00:13:31.620
the transfers happen very
quickly over the internet.

00:13:31.620 --> 00:13:33.180
So banks have a
secure connection,

00:13:33.180 --> 00:13:35.766
and they say, yo, give
me a billion dollars.

00:13:35.766 --> 00:13:37.390
I'll give it back to
you in a few days.

00:13:37.390 --> 00:13:37.889
Sure.

00:13:37.889 --> 00:13:39.320
Done deal.

00:13:39.320 --> 00:13:40.820
Now imagine what
you could do if you

00:13:40.820 --> 00:13:43.490
could impersonate
one of those banks.

00:13:43.490 --> 00:13:47.310
Sweet happy life in some
faraway place, right?

00:13:50.160 --> 00:13:52.790
What would it take to
impersonate another bank?

00:13:52.790 --> 00:13:58.680
It turns out that the
encryption algorithm that

00:13:58.680 --> 00:14:02.420
use to secure this links
is an algorithm called RSA.

00:14:02.420 --> 00:14:04.070
Do you guys remember that?

00:14:04.070 --> 00:14:04.920
Heard about it?

00:14:10.560 --> 00:14:14.530
So in RSA, each
party-- so each bank

00:14:14.530 --> 00:14:17.450
has a secret key that
consists of two numbers--

00:14:17.450 --> 00:14:20.540
P and Q-- big prime numbers.

00:14:23.530 --> 00:14:28.584
And say each of these
are N-bit prime numbers.

00:14:28.584 --> 00:14:30.000
And then they have
a probably key.

00:14:30.000 --> 00:14:31.650
So they have a
number that announce

00:14:31.650 --> 00:14:37.110
that is N equals
P times Q. So this

00:14:37.110 --> 00:14:39.010
is announced to
the entire world.

00:14:39.010 --> 00:14:39.850
This is public.

00:14:42.047 --> 00:14:43.880
We went through this
[INAUDIBLE] set, right?

00:14:43.880 --> 00:14:46.610
So this rings a bell.

00:14:46.610 --> 00:14:50.070
They have to announce this
so that the other people can

00:14:50.070 --> 00:14:52.490
encrypt messages for them.

00:14:52.490 --> 00:14:54.942
If you want someone else to
be able to send you a message,

00:14:54.942 --> 00:14:56.150
you have to tell them your n.

00:15:00.510 --> 00:15:03.270
Now if you know P and Q,
you can decrypt messages.

00:15:03.270 --> 00:15:06.650
So you can pretend
you're the bank.

00:15:06.650 --> 00:15:09.050
Now let's set up a
problem in this way.

00:15:11.630 --> 00:15:16.460
Given a verifier that
does long division--

00:15:16.460 --> 00:15:22.740
so we have a verifier that
the verifiers input is N,

00:15:22.740 --> 00:15:28.530
and some guess P,
P guess, right?

00:15:28.530 --> 00:15:33.260
So the verifier will
compute N modulo P.

00:15:33.260 --> 00:15:38.050
And if N modulo P is 0,
then it will say happy.

00:15:38.050 --> 00:15:41.280
Actually, it will say,
you're rich as hell.

00:15:41.280 --> 00:15:45.040
If it's not 0, then well,
tough luck, try again.

00:15:49.040 --> 00:15:51.540
So if you could make
this verifier happy,

00:15:51.540 --> 00:15:58.820
you could get P. So
given public information,

00:15:58.820 --> 00:16:00.790
you could get the
private information that

00:16:00.790 --> 00:16:03.700
would allow you to
impersonate the bank.

00:16:03.700 --> 00:16:05.620
This is called a factoring
problem by the way.

00:16:14.520 --> 00:16:20.480
So P and N are
usually 1024 bits.

00:16:20.480 --> 00:16:23.220
So the chances of doing
that with a coin flip, no.

00:16:25.810 --> 00:16:34.800
The chances of guessing it
are one in two to the 1024--

00:16:34.800 --> 00:16:36.610
it's basically worse
than having to pick

00:16:36.610 --> 00:16:39.128
a random atom in the universe
and choosing the right one.

00:16:41.880 --> 00:16:44.770
So not going to happen.

00:16:44.770 --> 00:16:47.640
But if you had an algorithm
that takes a verifier

00:16:47.640 --> 00:16:52.480
and produces an input
that makes it happy,

00:16:52.480 --> 00:16:56.570
then you would
solve this problem,

00:16:56.570 --> 00:16:58.326
and you would
impersonate the bank,

00:16:58.326 --> 00:16:59.700
and you would
become really rich,

00:16:59.700 --> 00:17:02.660
and then the whole
world's economic system

00:17:02.660 --> 00:17:05.059
would be in a
terrible situation.

00:17:09.079 --> 00:17:13.588
AUDIENCE: P and Q
are primes, right?

00:17:13.588 --> 00:17:18.079
So couldn't you just
find all the primes?

00:17:18.079 --> 00:17:22.930
PROFESSOR: Well, so look at
it from this perspective,

00:17:22.930 --> 00:17:25.589
the economic system
still functions.

00:17:25.589 --> 00:17:29.870
It's not like everyone's
money disappeared somewhere.

00:17:29.870 --> 00:17:34.310
Therefore, nobody was
able to pull this off.

00:17:34.310 --> 00:17:36.700
AUDIENCE: Isn't there a
quantum algorithm to do it

00:17:36.700 --> 00:17:40.009
or that's something different?

00:17:40.009 --> 00:17:41.800
PROFESSOR: So this
assumes Turing machines.

00:17:41.800 --> 00:17:43.870
We're assuming regular
Turing machines.

00:17:43.870 --> 00:17:47.340
A quantum computer
breaks that abstraction.

00:17:47.340 --> 00:17:50.300
For practical purposes, if
you had a quantum computer

00:17:50.300 --> 00:17:52.210
that can manipulate
this many bits.

00:17:52.210 --> 00:17:55.020
Then you would break RSA, and
the world would go to hell.

00:17:55.020 --> 00:17:58.410
So hopefully by the time quantum
computers get this powerful,

00:17:58.410 --> 00:18:03.080
we'll invent new security
algorithms that replace them.

00:18:03.080 --> 00:18:07.140
But the fact that eCommerce
works now and that banks work

00:18:07.140 --> 00:18:10.500
means that nobody
is able to solve

00:18:10.500 --> 00:18:13.860
NP problems in polynomial time.

00:18:13.860 --> 00:18:18.830
So by the way, factoring is not
the hardest type of NP problem.

00:18:18.830 --> 00:18:20.230
Factoring is somewhere here.

00:18:34.381 --> 00:18:34.880
OK.

00:18:34.880 --> 00:18:36.130
Any questions about this part?

00:18:36.130 --> 00:18:39.540
AUDIENCE: So factoring
is not an NP problem?

00:18:39.540 --> 00:18:41.400
PROFESSOR: Factoring
is NP, but it's not

00:18:41.400 --> 00:18:43.470
the most difficult
type of NP problem.

00:18:43.470 --> 00:18:45.110
We'll get to those right now.

00:18:48.210 --> 00:18:50.850
So this is a common sense
proof not the math proof

00:18:50.850 --> 00:18:56.340
that NP is not P--
that at least nobody

00:18:56.340 --> 00:19:01.250
knows how to solve NP
problems in polynomial time.

00:19:01.250 --> 00:19:05.940
So there are these NP problems
that if you think about it,

00:19:05.940 --> 00:19:08.180
the solution is
polynomial in size.

00:19:08.180 --> 00:19:10.800
We can write a verifier
in polynomial time.

00:19:10.800 --> 00:19:14.820
So why can't we write the
solver in polynomial time?

00:19:14.820 --> 00:19:17.930
If you're a very high picture
guy like managerial type,

00:19:17.930 --> 00:19:19.970
then you might think,
yeah why, can't you guys

00:19:19.970 --> 00:19:21.230
just figure this out?

00:19:21.230 --> 00:19:23.170
Like come up with an algorithm.

00:19:23.170 --> 00:19:25.132
Isn't that what you guys do?

00:19:25.132 --> 00:19:26.840
Well, so theory people
have been thinking

00:19:26.840 --> 00:19:29.080
about this for 40 years or more.

00:19:29.080 --> 00:19:31.080
So what do you do when
you think about something

00:19:31.080 --> 00:19:32.663
and you can't come
up with a solution?

00:19:35.210 --> 00:19:36.802
AUDIENCE: Say it's impossible?

00:19:36.802 --> 00:19:38.760
PROFESSOR: You try to
say that it's impossible.

00:19:38.760 --> 00:19:41.840
So you try to prove
that P is not NP.

00:19:41.840 --> 00:19:46.250
But if you fail to do that
too, what do you do next?

00:19:46.250 --> 00:19:47.625
AUDIENCE: Offer
a million dollars

00:19:47.625 --> 00:19:48.987
to someone who can do it.

00:19:48.987 --> 00:19:49.820
PROFESSOR: That too.

00:19:49.820 --> 00:19:50.486
That might help.

00:19:50.486 --> 00:19:52.010
That might help.

00:19:52.010 --> 00:19:54.476
Well, you complain that it's
really, really hard, right?

00:19:54.476 --> 00:19:56.100
You want to go back
to your boss or you

00:19:56.100 --> 00:19:58.782
want to go back to the world,
and say, we thought about this.

00:19:58.782 --> 00:20:00.990
It is true that with thought
about it for four years,

00:20:00.990 --> 00:20:04.680
but it's a really,
really hard problem.

00:20:04.680 --> 00:20:06.649
Well, so for
undecidable problems--

00:20:06.649 --> 00:20:08.190
so for the whole
thing problems, they

00:20:08.190 --> 00:20:10.810
are able to convince the world
that nobody can solve this,

00:20:10.810 --> 00:20:12.950
so we're all good.

00:20:12.950 --> 00:20:15.880
So we couldn't come up with a
solution, because nobody can.

00:20:15.880 --> 00:20:20.040
Here, we can't prove
that P is not NP yet.

00:20:20.040 --> 00:20:22.990
So instead the next best
thing that theory people

00:20:22.990 --> 00:20:25.770
could come up with
is-- they saw,

00:20:25.770 --> 00:20:28.972
what are the hardest
kind of NP problems?

00:20:28.972 --> 00:20:31.180
Let's look at them and let's
see if we can solve them

00:20:31.180 --> 00:20:32.590
in some way.

00:20:32.590 --> 00:20:34.390
And they found
some problems here

00:20:34.390 --> 00:20:36.760
that are the
hardest NP problems.

00:20:36.760 --> 00:20:39.570
And they called them
NP-complete problems.

00:20:39.570 --> 00:20:41.236
And we'll see why
complete in a bit.

00:20:48.530 --> 00:20:50.960
So these are the hardest NP
problems that you can have.

00:20:50.960 --> 00:20:52.820
Factoring is not one of them.

00:20:52.820 --> 00:20:54.890
Factoring is not
with the cool kids,

00:20:54.890 --> 00:20:56.530
even though it
would make you rich.

00:20:56.530 --> 00:20:59.030
There are some problems
that are harder than that.

00:20:59.030 --> 00:21:01.130
OK so for these
NP-complete problems,

00:21:01.130 --> 00:21:03.740
turns out there are a
few hundred of them that

00:21:03.740 --> 00:21:06.122
would have practical
implications.

00:21:06.122 --> 00:21:08.080
So you wouldn't be able
to get rich right away,

00:21:08.080 --> 00:21:10.350
but still you'd be able to
solved the important problems

00:21:10.350 --> 00:21:12.058
that would save
companies a lot of money.

00:21:12.058 --> 00:21:14.380
So you think, if
there's a solution

00:21:14.380 --> 00:21:16.580
someone would come up with it.

00:21:16.580 --> 00:21:19.700
It also turns out that
they're all interrelated.

00:21:19.700 --> 00:21:22.842
So if you can solve one problem,
you can solve all of them.

00:21:22.842 --> 00:21:24.300
And you do that
through reductions,

00:21:24.300 --> 00:21:26.540
which we'll go over in a bit.

00:21:26.540 --> 00:21:30.690
But the bottom line
is there are hundreds

00:21:30.690 --> 00:21:32.640
of NP-complete problems.

00:21:38.990 --> 00:21:42.960
And if you solve one, then
you solved everything.

00:21:50.904 --> 00:21:52.570
For now theory people
are trying to say,

00:21:52.570 --> 00:21:55.330
look there are all
these problems.

00:21:55.330 --> 00:21:57.980
If anyone would solve
any of them, all of them

00:21:57.980 --> 00:21:58.700
would go away.

00:21:58.700 --> 00:22:00.830
Nobody was able to
solve any of them,

00:22:00.830 --> 00:22:03.340
so they must be
really, really hard.

00:22:03.340 --> 00:22:05.700
This is the best they
could come up with.

00:22:05.700 --> 00:22:06.855
This is NP complete.

00:22:10.221 --> 00:22:12.720
AUDIENCE: This is same lecture
that you-- any problem that's

00:22:12.720 --> 00:22:16.124
already [INAUDIBLE] transform
it into a different problem?

00:22:16.124 --> 00:22:16.790
PROFESSOR: Yeah.

00:22:16.790 --> 00:22:19.010
So if you have the
solution for one of them,

00:22:19.010 --> 00:22:22.090
you could transform all the
other ones into that problem

00:22:22.090 --> 00:22:24.590
just like we do with
graph transformations,

00:22:24.590 --> 00:22:29.050
solve it, use the solution for
it to solve all the other ones.

00:22:29.050 --> 00:22:32.230
So if anyone could solve any
of those hundreds of problems,

00:22:32.230 --> 00:22:36.220
we'd have the solution to
all of them in an instant.

00:22:36.220 --> 00:22:38.310
The fact that we don't
have a solution to them

00:22:38.310 --> 00:22:41.752
means that nobody was
able to solve any of them.

00:22:41.752 --> 00:22:45.230
AUDIENCE: Like there are some
problems like the chess problem

00:22:45.230 --> 00:22:47.299
that can be solved
exponential time.

00:22:47.299 --> 00:22:48.590
PROFESSOR: Those are different.

00:22:48.590 --> 00:22:49.958
Chess is here.

00:22:49.958 --> 00:22:53.660
AUDIENCE: So we can solve
chess though, right?

00:22:53.660 --> 00:22:57.030
It's just exponential time.

00:22:57.030 --> 00:22:58.932
Right?

00:22:58.932 --> 00:23:01.390
PROFESSOR: As far as I know,
because it's exponential time,

00:23:01.390 --> 00:23:03.740
there's no algorithm
that can actually

00:23:03.740 --> 00:23:07.130
look at the entire configuration
space, and tell if you can win

00:23:07.130 --> 00:23:07.630
or not.

00:23:10.290 --> 00:23:12.580
So solving chess, what's chess?

00:23:12.580 --> 00:23:15.220
Chess has given a board.

00:23:15.220 --> 00:23:18.270
Can I win or not
from this board?

00:23:18.270 --> 00:23:20.130
This would be very
useful in playing chess,

00:23:20.130 --> 00:23:21.838
because you start with
the initial board,

00:23:21.838 --> 00:23:23.470
and then for every
move you can make,

00:23:23.470 --> 00:23:25.136
you look at the
resulting board, and you

00:23:25.136 --> 00:23:27.780
say can I win or
not from that board.

00:23:27.780 --> 00:23:29.890
If you're in a board
configuration in which you

00:23:29.890 --> 00:23:31.960
can win, you don't want
to go to a configuration

00:23:31.960 --> 00:23:34.310
where you won't be
able to win anymore.

00:23:34.310 --> 00:23:36.940
So if you keep doing
this you eventually win.

00:23:36.940 --> 00:23:40.340
So it would be really nice
to have this algorithm.

00:23:40.340 --> 00:23:42.360
Yeah, we don't have it.

00:23:42.360 --> 00:23:44.430
We don't have it and
chess is unsolved.

00:23:44.430 --> 00:23:44.930
Wait.

00:23:44.930 --> 00:23:47.180
AUDIENCE: So only things
that are below P--

00:23:47.180 --> 00:23:49.785
but there are some algorithms
that run in exponential time.

00:23:49.785 --> 00:23:53.010
They just take longer.

00:23:53.010 --> 00:23:55.540
PROFESSOR: So the problem
is what's the input size?

00:23:55.540 --> 00:23:57.090
Exponential in what?

00:23:57.090 --> 00:23:59.630
If it's going to be-- if the
running time is 2 to the n,

00:23:59.630 --> 00:24:02.540
and it's 10, then that's fine.

00:24:02.540 --> 00:24:05.130
But for chess its exponential
in the board configuration.

00:24:05.130 --> 00:24:07.610
And it turns out that there's
so many board configurations

00:24:07.610 --> 00:24:10.410
that we don't have
computers fast

00:24:10.410 --> 00:24:12.040
enough to solve the whole thing.

00:24:12.040 --> 00:24:14.750
So deep blue goes to
a level-- to a depth

00:24:14.750 --> 00:24:18.640
I think of somewhere around
15 and can barely competes

00:24:18.640 --> 00:24:21.230
with humans, but it's not
guaranteed to win all the time.

00:24:21.230 --> 00:24:25.362
So we don't have something that
has completely solved chess.

00:24:25.362 --> 00:24:28.560
AUDIENCE: So we can only
solve things below P then.

00:24:28.560 --> 00:24:30.780
PROFESSOR: We can only
solve things below P

00:24:30.780 --> 00:24:33.082
fast, reasonably fast.

00:24:33.082 --> 00:24:34.540
So what we care
about in this class

00:24:34.540 --> 00:24:36.140
is how do our algorithm scale.

00:24:36.140 --> 00:24:38.400
So do we have this or not?

00:24:38.400 --> 00:24:41.460
Does your algorithm
scale or not?

00:24:41.460 --> 00:24:44.600
The reason we don't like
algorithms that are after this

00:24:44.600 --> 00:24:49.750
is that for problem sizes that
are really small like 8, 10,

00:24:49.750 --> 00:24:52.700
or something small,
they're going to work.

00:24:52.700 --> 00:24:56.510
But the moment the problem
gets bigger and bigger,

00:24:56.510 --> 00:24:58.506
you're going to run
into a dead end.

00:24:58.506 --> 00:25:01.612
AUDIENCE: Well, can
you use DP on chess?

00:25:01.612 --> 00:25:03.070
PROFESSOR: You can
use DP until you

00:25:03.070 --> 00:25:06.240
get to an exponential algorithm.

00:25:06.240 --> 00:25:08.030
You might get to an
exponential algorithm

00:25:08.030 --> 00:25:10.280
where the exponent is better.

00:25:10.280 --> 00:25:12.480
So far all the smart
algorithms for chess

00:25:12.480 --> 00:25:15.380
have reduced the
c here, but they

00:25:15.380 --> 00:25:19.630
haven't been able to get
away from 2 to the n part.

00:25:19.630 --> 00:25:21.920
If you make c smaller, sure
it's going to run faster,

00:25:21.920 --> 00:25:23.878
and you can explore a
bigger part of the board.

00:25:23.878 --> 00:25:26.120
But you're still not
going to be able to run

00:25:26.120 --> 00:25:29.870
through the whole thing
before the world ends.

00:25:29.870 --> 00:25:31.690
That's a good thing
to think about.

00:25:31.690 --> 00:25:33.684
Will we solve chess
before the world

00:25:33.684 --> 00:25:35.600
ends with the current
algorithms and machines?

00:25:35.600 --> 00:25:38.420
No.

00:25:38.420 --> 00:25:39.830
AUDIENCE: I guess.

00:25:39.830 --> 00:25:41.920
Remember the Rubik's cube?

00:25:41.920 --> 00:25:47.310
Wasn't that bordering
exponential or something?

00:25:47.310 --> 00:25:51.830
I think Eric said that there
is order one solution where

00:25:51.830 --> 00:25:53.450
the constant factor
is really high.

00:25:53.450 --> 00:25:55.250
So that's different.

00:25:55.250 --> 00:26:00.830
raises I think Tetris is
here, but the Rubik's cube--

00:26:00.830 --> 00:26:02.290
AUDIENCE: It's in
the P, isn't it?

00:26:02.290 --> 00:26:02.790
Yeah.

00:26:02.790 --> 00:26:04.290
PROFESSOR: There's
a solution that's

00:26:04.290 --> 00:26:06.670
order one with a high
constant [INAUDIBLE].

00:26:06.670 --> 00:26:09.322
AUDIENCE: But our
brains can play chess.

00:26:09.322 --> 00:26:10.030
PROFESSOR: Sorry?

00:26:10.030 --> 00:26:10.529
Our brains--

00:26:10.529 --> 00:26:12.030
AUDIENCE: We can play chess.

00:26:12.030 --> 00:26:13.905
PROFESSOR: Well, we can
play reasonably well,

00:26:13.905 --> 00:26:15.580
but if someone could
play optimally,

00:26:15.580 --> 00:26:17.540
they'd probably beat you.

00:26:17.540 --> 00:26:20.435
Yeah.

00:26:20.435 --> 00:26:23.928
AUDIENCE: Can someone
play optimally?

00:26:23.928 --> 00:26:26.423
[INAUDIBLE]

00:26:26.423 --> 00:26:30.230
AUDIENCE: What about
machine learning?

00:26:30.230 --> 00:26:34.180
PROFESSOR: Machine learning
problems are usually here.

00:26:34.180 --> 00:26:35.880
That's why they don't
scale, and that's

00:26:35.880 --> 00:26:38.230
why we've seen a lot of
interesting machine learning,

00:26:38.230 --> 00:26:43.104
but so far I can't talk
to my computer right.

00:26:43.104 --> 00:26:44.520
They can't make a
lot of progress,

00:26:44.520 --> 00:26:46.895
because they have these really
hard problems that they're

00:26:46.895 --> 00:26:49.470
working on.

00:26:49.470 --> 00:26:50.940
AUDIENCE: There's Siri, right.

00:26:50.940 --> 00:26:52.900
You can talk to Siri.

00:26:52.900 --> 00:26:54.420
PROFESSOR: Yeah OK.

00:26:54.420 --> 00:26:55.280
Sure.

00:26:55.280 --> 00:26:57.230
I think I've seen
on the Internet

00:26:57.230 --> 00:26:59.400
that it says some
awful things sometimes.

00:26:59.400 --> 00:27:03.220
So I wouldn't
consider that solved.

00:27:03.220 --> 00:27:07.920
So what does NP mean to
us like practical terms?

00:27:07.920 --> 00:27:12.040
Here's how I see it, you're
on an exam or in an interview,

00:27:12.040 --> 00:27:14.100
you start out with a problem.

00:27:14.100 --> 00:27:16.330
Suppose all the
possible problems

00:27:16.330 --> 00:27:19.030
are a graph, because
we work with graphs.

00:27:19.030 --> 00:27:20.324
You have your starting problem.

00:27:20.324 --> 00:27:22.490
This Is the problem that
you're trying to solve now.

00:27:25.290 --> 00:27:28.200
Then you have a few
destination nodes.

00:27:28.200 --> 00:27:30.786
Say you have merge sort.

00:27:30.786 --> 00:27:31.660
We know how to solve.

00:27:31.660 --> 00:27:34.950
If you can reduce your
problem to merge sort,

00:27:34.950 --> 00:27:36.612
then you're in a good position.

00:27:36.612 --> 00:27:37.820
You're writing your solution.

00:27:37.820 --> 00:27:39.740
You're out of the room.

00:27:39.740 --> 00:27:42.710
If you can reduce your problem
to a graph search algorithm,

00:27:42.710 --> 00:27:46.270
so to BFS or DFS, you're done.

00:27:46.270 --> 00:27:50.350
If you can reduce it to
shortest path, you're happy.

00:27:50.350 --> 00:27:51.690
You're done.

00:27:51.690 --> 00:27:54.080
If you can reduce it to a
dynamic programming problem

00:27:54.080 --> 00:27:56.650
that we understand, you're done.

00:27:56.650 --> 00:28:00.090
If you can somehow use hashing
or use divide and conquer

00:28:00.090 --> 00:28:03.310
with an algorithm that we
studied, you're also happy.

00:28:03.310 --> 00:28:06.257
So we have all these
destination points.

00:28:06.257 --> 00:28:07.840
And what you're
trying to do is you're

00:28:07.840 --> 00:28:11.885
trying to get from here all
the way to here via reductions.

00:28:15.440 --> 00:28:18.430
So suppose you see
three reductions

00:28:18.430 --> 00:28:19.754
that you could possibly do.

00:28:22.409 --> 00:28:24.450
You don't have time to
work on all three of them,

00:28:24.450 --> 00:28:26.310
so let's say you
choose the middle one,

00:28:26.310 --> 00:28:28.594
because this one seems
like it's the easiest one.

00:28:28.594 --> 00:28:30.010
So I'm going to
guess that this is

00:28:30.010 --> 00:28:31.456
the easiest one I can tackle.

00:28:31.456 --> 00:28:32.830
So now I'm going
to work on this.

00:28:32.830 --> 00:28:34.663
I'm going to put the
original problem aside.

00:28:34.663 --> 00:28:38.490
And I'm going to say if I can
solve this, then I'm happy.

00:28:38.490 --> 00:28:42.470
Now say this turns into
three more reductions.

00:28:42.470 --> 00:28:46.027
And this one looks promising.

00:28:46.027 --> 00:28:46.860
it's a hard problem.

00:28:46.860 --> 00:28:48.193
You have to do a few reductions.

00:28:48.193 --> 00:28:49.690
It doesn't work right away.

00:28:49.690 --> 00:28:51.820
But say I take this one
which looks promising,

00:28:51.820 --> 00:28:55.610
and I'm able to reduce
it to a happy problem.

00:28:55.610 --> 00:28:57.380
Reduction, reduction, reduction.

00:28:57.380 --> 00:28:58.550
I write this up.

00:28:58.550 --> 00:29:00.840
I'm done.

00:29:00.840 --> 00:29:04.304
Exam solved or interview
question solved.

00:29:04.304 --> 00:29:05.720
Now the problem
is what if instead

00:29:05.720 --> 00:29:08.540
of going on this path which
is reasonably happy, what if I

00:29:08.540 --> 00:29:12.080
go on a path that
looks like this?

00:29:12.080 --> 00:29:14.760
All the reductions that
I can see from there

00:29:14.760 --> 00:29:17.280
go really, really far
away from the problems

00:29:17.280 --> 00:29:21.190
that I know how to solve.

00:29:21.190 --> 00:29:23.460
Well you're going to
try some reductions,

00:29:23.460 --> 00:29:25.790
and eventually you're
going to run out of time.

00:29:25.790 --> 00:29:27.940
And this other interviewer
is going to say, yeah,

00:29:27.940 --> 00:29:30.000
do you have any
questions about us?

00:29:30.000 --> 00:29:34.060
Or the exam people will be like,
hey, can we have the exam back?

00:29:34.060 --> 00:29:36.040
We want to go home now.

00:29:36.040 --> 00:29:38.420
So this is a bad outcome.

00:29:38.420 --> 00:29:42.990
Up until now, all you had
was good destination points.

00:29:42.990 --> 00:29:45.330
So this is where
you want to reach.

00:29:45.330 --> 00:29:49.230
Now we have these NP-complete
problems that we know are hard.

00:29:49.230 --> 00:29:52.230
I've convinced you
hopefully that their hard.

00:29:52.230 --> 00:29:54.250
So if you know some
NP-complete problems,

00:29:54.250 --> 00:29:56.420
you also have some landmines.

00:29:56.420 --> 00:29:58.670
You have some places
where if you got there

00:29:58.670 --> 00:30:03.220
via reductions, not a good path.

00:30:03.220 --> 00:30:06.190
You want to backtrack and
think of something else.

00:30:06.190 --> 00:30:13.300
So for example if this
was an NP-complete problem

00:30:13.300 --> 00:30:17.360
like if this reduction
then was, oh yeah,

00:30:17.360 --> 00:30:20.310
solve [INAUDIBLE]
in polynomial time.

00:30:20.310 --> 00:30:21.060
Let's see.

00:30:21.060 --> 00:30:22.260
I don't know how to do that.

00:30:22.260 --> 00:30:23.600
The world tried really hard.

00:30:23.600 --> 00:30:26.430
Maybe I shouldn't try
this avenue on the exam.

00:30:26.430 --> 00:30:28.255
So if you know that
this is NP-complete.

00:30:28.255 --> 00:30:29.260
You stop right there.

00:30:29.260 --> 00:30:30.480
You don't waste anymore time.

00:30:33.690 --> 00:30:34.970
So this isn't time wasted.

00:30:38.740 --> 00:30:42.520
If you understand NP-complete,
and you read the CLRS chapter

00:30:42.520 --> 00:30:43.760
on NP-complete problems.

00:30:43.760 --> 00:30:47.230
Then you also have
some sad faces here.

00:30:47.230 --> 00:30:51.550
You have some land mines and
you know not to go there.

00:30:51.550 --> 00:30:54.250
So now your space that
you're looking through

00:30:54.250 --> 00:30:57.336
is a lot more bonded.

00:30:57.336 --> 00:30:59.710
Hopefully, you're going to
have better chances of finding

00:30:59.710 --> 00:31:02.700
a happy path, because not only
you have some destinations,

00:31:02.700 --> 00:31:06.870
but you have some places that
you know you shouldn't go to.

00:31:06.870 --> 00:31:09.510
So this is the point
of NP-complete.

00:31:09.510 --> 00:31:11.840
You're probably really
busy at the end of the term

00:31:11.840 --> 00:31:13.940
as we all are, so I'm
guessing you're not

00:31:13.940 --> 00:31:18.190
going to have time to read
CLRS beyond what we really

00:31:18.190 --> 00:31:19.930
ask you to read now.

00:31:19.930 --> 00:31:22.700
But after you're done,
do yourself a favor.

00:31:22.700 --> 00:31:24.910
For the sake of your
future interviews

00:31:24.910 --> 00:31:28.180
and general happy
programming life,

00:31:28.180 --> 00:31:31.370
read the NP-complete
chapter in CLRS.

00:31:31.370 --> 00:31:34.352
Read the problem statements
and understand them.

00:31:34.352 --> 00:31:35.560
Don't worry about the proofs.

00:31:35.560 --> 00:31:38.500
Don't worry about the reductions
that say their NP-complete.

00:31:38.500 --> 00:31:39.490
Read the statements.

00:31:39.490 --> 00:31:42.230
Believe CLRS that
it's NP-complete.

00:31:42.230 --> 00:31:44.630
And remember that whenever
you solve a problem,

00:31:44.630 --> 00:31:46.880
you want to stay
away from those.

00:31:46.880 --> 00:31:48.940
So those will be your landmines.

00:31:48.940 --> 00:31:50.710
Those will be your sad spots.

00:31:50.710 --> 00:31:52.660
Guaranteed, after you
do that, your interviews

00:31:52.660 --> 00:31:55.450
will go a lot better,
because you'll

00:31:55.450 --> 00:31:56.790
be faster at solving problems.

00:31:56.790 --> 00:31:58.331
And that's what we
really care about.

00:32:01.620 --> 00:32:05.960
So that's why NP-complete
is relevant in real life.

00:32:05.960 --> 00:32:07.688
It gives us these data points.

00:32:11.350 --> 00:32:11.850
Makes sense?

00:32:18.430 --> 00:32:21.430
All right, I want to talk about
one NP complete problem that's

00:32:21.430 --> 00:32:22.560
really important.

00:32:22.560 --> 00:32:23.550
And that is SAT.

00:32:27.400 --> 00:32:29.466
So SAT means satisfiability.

00:32:36.500 --> 00:32:38.970
So given the logical
expression, find some values

00:32:38.970 --> 00:32:42.050
for the variables
that make it true.

00:32:42.050 --> 00:32:45.430
Let me grab an
example from here.

00:32:45.430 --> 00:32:47.210
So in SAT your
expressions come out

00:32:47.210 --> 00:32:50.910
in a really nice form, so
parsing isn't a big deal.

00:32:50.910 --> 00:32:52.530
The way they come
out is there a bunch

00:32:52.530 --> 00:32:54.500
of terms separated by AND.

00:32:54.500 --> 00:33:00.860
So your expressions
look like this-- and,

00:33:00.860 --> 00:33:07.610
and, and-- say we
have four terms.

00:33:07.610 --> 00:33:10.110
These look good.

00:33:10.110 --> 00:33:15.580
So you have some
terms, say n terms,

00:33:15.580 --> 00:33:17.410
and they're all
separated by ANDs.

00:33:17.410 --> 00:33:20.100
This is a term.

00:33:20.100 --> 00:33:23.830
In a term you have
variables separated by ORs.

00:33:23.830 --> 00:33:24.560
Nothing else.

00:33:24.560 --> 00:33:27.590
Just either the
variable or a variable

00:33:27.590 --> 00:33:29.750
with a NOT in front of it.

00:33:29.750 --> 00:33:55.600
So say x1 OR NOT x2, NOT x1 OR
x4, NOT x3 or x4, and X2 OR X4.

00:33:55.600 --> 00:33:59.050
So this is called the
Conjuntive Normal Form, CNF.

00:34:01.756 --> 00:34:05.610
The reason this is really
nice to work with is-- OK,

00:34:05.610 --> 00:34:08.460
you just have some
variables here.

00:34:08.460 --> 00:34:10.690
You know that these
are all joined by AND,

00:34:10.690 --> 00:34:12.900
so you're going to have to
make all these terms true.

00:34:16.420 --> 00:34:17.830
And then you have ORs inside.

00:34:17.830 --> 00:34:19.940
So you know that for
every term, at least one

00:34:19.940 --> 00:34:22.699
of the things inside
the term has to be true.

00:34:22.699 --> 00:34:25.007
And that's it.

00:34:25.007 --> 00:34:25.840
This is the problem.

00:34:25.840 --> 00:34:27.810
This is SAT.

00:34:27.810 --> 00:34:29.080
You have n terms.

00:34:29.080 --> 00:34:33.790
And then the number of variables
that you have inside is k.

00:34:33.790 --> 00:34:37.529
So you have at most k
variables in a term.

00:34:42.120 --> 00:34:44.830
This k looks like
a constant factor.

00:34:44.830 --> 00:34:46.510
But it's so important
that in fact it

00:34:46.510 --> 00:34:48.020
shows up in the
name of the problem.

00:34:51.400 --> 00:34:53.449
The problem is called k-SAT.

00:34:53.449 --> 00:34:57.630
And there are two
values of k for which

00:34:57.630 --> 00:34:58.910
the problem is important.

00:34:58.910 --> 00:35:06.030
There's 2-SAT,
and there's 3-SAT.

00:35:06.030 --> 00:35:08.330
2-SAT is polynomial.

00:35:08.330 --> 00:35:11.460
We have a solution that runs
in order and time in fact.

00:35:11.460 --> 00:35:12.060
Really good.

00:35:17.868 --> 00:35:20.288
AUDIENCE: But you're
saying that to make--

00:35:20.288 --> 00:35:23.240
you're actually rearranging
things or you're just--

00:35:23.240 --> 00:35:27.090
PROFESSOR: So I have to come
up with values for x1, x2, x3,

00:35:27.090 --> 00:35:30.290
and four, so that the
whole thing is true.

00:35:30.290 --> 00:35:32.130
And the expression
is already arranged

00:35:32.130 --> 00:35:36.000
in this nice form for you.

00:35:36.000 --> 00:35:38.049
AUDIENCE: It's just--
it seems like order

00:35:38.049 --> 00:35:40.215
and, because you're just
evaluating to block, right?

00:35:40.215 --> 00:35:42.608
PROFESSOR: Well, no, you have
to come up with the values.

00:35:42.608 --> 00:35:43.572
AUDIENCE: Oh, I know.

00:35:43.572 --> 00:35:44.072
I know.

00:35:44.072 --> 00:35:44.572
But like--

00:35:44.572 --> 00:35:46.610
PROFESSOR: OK and this
seems really easy, right?

00:35:46.610 --> 00:35:47.640
Well, wait for it.

00:35:47.640 --> 00:35:48.830
Wait for it.

00:35:48.830 --> 00:35:51.270
2-SAT is polynomial.

00:35:51.270 --> 00:35:53.230
3-SAT is NP-complete.

00:35:58.210 --> 00:36:01.730
So if you solve it, you're
in turn for a Turing reward,

00:36:01.730 --> 00:36:05.730
or you can become
really, really rich.

00:36:05.730 --> 00:36:08.200
So n-SAT can be
reduced to 3-SAT.

00:36:12.530 --> 00:36:14.450
So for anything
bigger than three,

00:36:14.450 --> 00:36:18.950
n-SAT can be reduced to 3-SAT
using reasonable reduction.

00:36:18.950 --> 00:36:21.930
So the input size
won't explode too much.

00:36:25.280 --> 00:36:27.290
So why is this important.

00:36:27.290 --> 00:36:30.700
This basically shows us
that 3-SAT is NP-complete.

00:36:30.700 --> 00:36:34.630
And I can make a
three-minute proof

00:36:34.630 --> 00:36:36.260
that 3-SAT is NP-complete.

00:36:38.780 --> 00:36:42.040
Let's take that verifier
guy that we have there.

00:36:42.040 --> 00:36:44.480
A verifier wants the
input, which already have

00:36:44.480 --> 00:36:45.950
and the proof.

00:36:45.950 --> 00:36:49.110
Let's write the
verifier as a circuit

00:36:49.110 --> 00:36:53.550
that takes the input
and the proof as bits.

00:36:53.550 --> 00:36:55.120
Those are input to the circuit.

00:36:55.120 --> 00:36:58.370
The circuit is going to
evaluate to true or false.

00:36:58.370 --> 00:37:00.950
Now that we have a circuit,
it's easy to turn that

00:37:00.950 --> 00:37:02.980
into a logical expression.

00:37:02.980 --> 00:37:09.420
Turn AND gate and OR gate
into-- and ANDs and ORs,

00:37:09.420 --> 00:37:12.365
and then reduce N-SAT to
3-SAT and get one of these.

00:37:15.240 --> 00:37:18.510
If you can solve
3-SAT, then you can

00:37:18.510 --> 00:37:21.551
compute values for
the proof bits.

00:37:21.551 --> 00:37:22.050
Bam.

00:37:22.050 --> 00:37:22.925
That's it.

00:37:26.440 --> 00:37:33.210
So I take the verifier and
I turn it into a circuit.

00:37:36.710 --> 00:37:38.750
The circuit is all logic gates.

00:37:38.750 --> 00:37:47.770
And then it has some inputs,
the original problem input

00:37:47.770 --> 00:37:50.580
and the proof.

00:37:50.580 --> 00:37:52.417
These are represented
as a series of bits,

00:37:52.417 --> 00:37:54.000
and they're all
inputs in the circuit.

00:38:00.300 --> 00:38:03.290
If the algorithm
is polynomial time,

00:38:03.290 --> 00:38:08.760
then the circuit also has to be
polynomial in the input size.

00:38:08.760 --> 00:38:11.010
Proof already has to be
polynomial in the input size,

00:38:11.010 --> 00:38:11.760
so we're all good.

00:38:11.760 --> 00:38:14.600
We're all in polynomial world.

00:38:14.600 --> 00:38:17.682
Now we take this
circuit, and we turn it

00:38:17.682 --> 00:38:18.765
into a logical expression.

00:38:23.780 --> 00:38:32.360
Sorry not logical, logic, also
known as a Boolean expression.

00:38:32.360 --> 00:38:34.670
So the input bits become
Boolean variables,

00:38:34.670 --> 00:38:38.370
and then we express gates as
Boolean functions-- AND, OR,

00:38:38.370 --> 00:38:40.000
NOT, whatever we want.

00:38:40.000 --> 00:38:41.875
And this is going to
give us some expression.

00:38:44.490 --> 00:38:50.210
That expression is going to map
to N-SAT for some value of n.

00:38:50.210 --> 00:38:52.280
So then we're going to
take this expression,

00:38:52.280 --> 00:38:54.160
and we're going to
reduce it to 3-SAT.

00:38:57.840 --> 00:39:00.610
So actually we're going to
reduce the expression to 3-CNF

00:39:00.610 --> 00:39:02.840
and then run 3-SAT on it.

00:39:02.840 --> 00:39:05.900
The expression will
be reduced to 3-CNF.

00:39:05.900 --> 00:39:07.570
So to something that
looks like this,

00:39:07.570 --> 00:39:11.280
except you have three
variables inside everything.

00:39:11.280 --> 00:39:14.310
Once it's in 3-CNF, you
can run 3-SAT on it.

00:39:18.110 --> 00:39:20.340
If it is satisfiable,
then 3-SAT has

00:39:20.340 --> 00:39:25.640
to give us some values
here for the variables.

00:39:25.640 --> 00:39:29.370
Some of the variables are
the problem input-- Sorry

00:39:29.370 --> 00:39:31.470
the problem input gets
hard coded in the circuit.

00:39:31.470 --> 00:39:31.969
Sorry.

00:39:31.969 --> 00:39:39.580
Not thinking here--
hard coded in circuit,

00:39:39.580 --> 00:39:42.560
because we don't want it to
tell us what the input is.

00:39:42.560 --> 00:39:44.740
And then the proof is
encoded as a series

00:39:44.740 --> 00:39:48.511
of bits, which are
inputs in the circuit.

00:39:48.511 --> 00:39:49.010
OK.

00:39:49.010 --> 00:39:53.210
So problem hard coded, proofs
are inputs in the circuit.

00:39:53.210 --> 00:39:56.150
We've taken the circuits, turned
it into an input for 3-SAT.

00:39:56.150 --> 00:40:02.610
If 3-SAT says there is a
valid variable assignment,

00:40:02.610 --> 00:40:05.630
then that assignment tells me
what the bits are in the proof.

00:40:08.210 --> 00:40:11.830
So that means I can take the
proof, feed it to the verifier.

00:40:11.830 --> 00:40:13.430
The verifier will
say it's happy,

00:40:13.430 --> 00:40:15.650
so we solved the problem.

00:40:15.650 --> 00:40:18.600
And this is true for
any NP-complete problem.

00:40:18.600 --> 00:40:20.810
NP-complete means it has
to have a verifier that

00:40:20.810 --> 00:40:22.180
runs in polynomial time.

00:40:22.180 --> 00:40:25.070
So I have to be able
to follow this process.

00:40:25.070 --> 00:40:26.990
So for the factoring
problem, for example, I

00:40:26.990 --> 00:40:30.080
would take this
modulo algorithm,

00:40:30.080 --> 00:40:32.050
I would express it as a circuit.

00:40:32.050 --> 00:40:34.800
The bits of P
would be the input.

00:40:34.800 --> 00:40:38.760
I take that circuit and I turn
into a 3-CNF formula, run it

00:40:38.760 --> 00:40:40.840
on 3-SAT.

00:40:40.840 --> 00:40:45.050
The variable values for
which the circuit happy

00:40:45.050 --> 00:40:48.150
are the bits of P that make up.

00:40:48.150 --> 00:40:51.790
So they're the bits of P.
They make up a factor of n.

00:40:51.790 --> 00:40:54.690
So if I can run 3-SAT fast
enough to get an answer,

00:40:54.690 --> 00:40:57.960
then I have P and
I have factor of n.

00:40:57.960 --> 00:41:01.120
And I've become really, really
rich, and bye guys, I'm gone.

00:41:05.854 --> 00:41:07.520
AUDIENCE: For each
of those expressions,

00:41:07.520 --> 00:41:09.620
you said you make
that circuit n.

00:41:09.620 --> 00:41:11.090
You've got all
these inputs, which

00:41:11.090 --> 00:41:13.730
are x1, x2,
everything like that.

00:41:13.730 --> 00:41:17.730
Could you just go through
every possible combination?

00:41:17.730 --> 00:41:19.790
PROFESSOR: That's
exponential, right?

00:41:19.790 --> 00:41:24.550
That's two to the n, where
n is number of variables.

00:41:24.550 --> 00:41:26.440
And the number of
variables can be

00:41:26.440 --> 00:41:29.016
proportional to the
number of terms.

00:41:29.016 --> 00:41:29.962
AUDIENCE: Yeah.

00:41:29.962 --> 00:41:31.275
That would be fine with it.

00:41:31.275 --> 00:41:32.650
PROFESSOR: So that
means you have

00:41:32.650 --> 00:41:33.900
an exponential running time.

00:41:33.900 --> 00:41:36.090
It's not polynomial,
which is reassuring,

00:41:36.090 --> 00:41:39.880
because otherwise it would mean
that the whole world has been

00:41:39.880 --> 00:41:42.610
spinning their wheels around
nothing all this time, right?

00:41:42.610 --> 00:41:44.030
So it's reassuring
that you can't

00:41:44.030 --> 00:41:46.071
find the solution in two
minutes to this problem.

00:41:49.580 --> 00:41:51.580
In fact, so far I've been
trying to convince you

00:41:51.580 --> 00:41:53.080
that you should not
attempt to solve

00:41:53.080 --> 00:41:56.520
this problem in real
time, so not on exam time,

00:41:56.520 --> 00:41:59.347
not on [INAUDIBLE] time,
nor anywhere else where time

00:41:59.347 --> 00:42:00.055
actually matters.

00:42:04.130 --> 00:42:05.602
You guys bored?

00:42:05.602 --> 00:42:06.880
Maybe.

00:42:06.880 --> 00:42:09.410
Well, so there's
this proof that's

00:42:09.410 --> 00:42:12.830
not too hard to follow that
says that if you solve 3-SAT

00:42:12.830 --> 00:42:15.180
you have solved any
NP-complete problem by turning

00:42:15.180 --> 00:42:18.380
the verifier into a
logical expression.

00:42:18.380 --> 00:42:20.280
That's what it comes down to.

00:42:20.280 --> 00:42:22.062
Now 2-SAT is polynomial.

00:42:22.062 --> 00:42:24.270
And if you guys want, we
can go through the solution.

00:42:24.270 --> 00:42:26.460
If not, we can skip that.

00:42:26.460 --> 00:42:29.530
But this tiny difference
here, how many variables

00:42:29.530 --> 00:42:31.290
you're allowed
inside, which looks

00:42:31.290 --> 00:42:34.180
like it might be a constant
factor in an algorithm

00:42:34.180 --> 00:42:38.300
actually makes the difference
between a very easy problem,

00:42:38.300 --> 00:42:42.570
a problem that's in P, and
the hardest problem in NP.

00:42:42.570 --> 00:42:45.400
So 2-SAT is order n,
so it's somewhere here.

00:42:51.960 --> 00:42:53.530
3-SAT is all the way here.

00:43:02.401 --> 00:43:04.150
Small difference how
many variables you're

00:43:04.150 --> 00:43:06.417
allowed, two or three.

00:43:06.417 --> 00:43:08.000
Makes all the
difference in the world.

00:43:14.552 --> 00:43:19.719
AUDIENCE: There are logic
reductions you can make, right?

00:43:19.719 --> 00:43:21.510
PROFESSOR: There are
optimizations that you

00:43:21.510 --> 00:43:22.130
can make.

00:43:22.130 --> 00:43:24.620
And there are some
people who do research

00:43:24.620 --> 00:43:28.820
on how to solve 3-SAT in
a reasonably fast time.

00:43:28.820 --> 00:43:30.580
Because if you solve
3-SAT, any problem

00:43:30.580 --> 00:43:34.990
can be reduced to 3-SAT.

00:43:34.990 --> 00:43:37.770
All right, we have a feeling
that we're not going to be able

00:43:37.770 --> 00:43:39.360
to solve this in
polynomial time,

00:43:39.360 --> 00:43:42.560
because a lot of people tried,
but some researchers are hoping

00:43:42.560 --> 00:43:46.910
that well maybe you can solve
3-SAT in order of 2 to the n

00:43:46.910 --> 00:43:53.330
to the power of 0.00001,
which exponential, right?

00:43:53.330 --> 00:43:58.620
But you can solve many
problems with this.

00:43:58.620 --> 00:44:03.114
Active research, so far I don't
think they've come very far.

00:44:03.114 --> 00:44:05.030
Actually, I shouldn't
say that, because if you

00:44:05.030 --> 00:44:06.571
apply the brute
force algorithm, then

00:44:06.571 --> 00:44:10.400
you die at about 20 variables.

00:44:10.400 --> 00:44:13.790
State of the art 3-SAT
solving algorithms,

00:44:13.790 --> 00:44:16.920
I think it can handle
1,000 to 10,000 variables

00:44:16.920 --> 00:44:20.360
in a reasonable time,
like a few hours.

00:44:20.360 --> 00:44:22.261
There progress.

00:44:22.261 --> 00:44:24.510
And that is all by doing the
reductions that you said.

00:44:24.510 --> 00:44:27.780
You see some optimizations that
you can make in the expression.

00:44:27.780 --> 00:44:30.410
You draw some
inferences, and you

00:44:30.410 --> 00:44:32.350
explore the possible
configurations,

00:44:32.350 --> 00:44:34.480
taking us part way.

00:44:34.480 --> 00:44:36.730
So there's a lot of active
research going in that area

00:44:36.730 --> 00:44:37.640
too.

00:44:37.640 --> 00:44:42.536
So far, they didn't get here.

00:44:42.536 --> 00:44:46.350
AUDIENCE: That's almost solving
NP-complete problem then,

00:44:46.350 --> 00:44:46.850
right?

00:44:46.850 --> 00:44:48.690
PROFESSOR: Well,
yeah, the thing is

00:44:48.690 --> 00:44:52.000
in the end we care about
practical solutions, right?

00:44:52.000 --> 00:44:54.260
So they're hoping to get
to a practical solution.

00:44:54.260 --> 00:44:56.259
AUDIENCE: Well, a few
hours is pretty practical.

00:44:58.850 --> 00:45:01.490
So that's for some problems.

00:45:01.490 --> 00:45:04.250
Obviously they didn't
solve factoring, right?

00:45:04.250 --> 00:45:07.070
If they would have solved
1,000-bit factoring in a few

00:45:07.070 --> 00:45:09.120
hours, then we
would have noticed.

00:45:12.000 --> 00:45:13.920
AUDIENCE: Maybe.

00:45:13.920 --> 00:45:15.095
Seriously, OK.

00:45:15.095 --> 00:45:16.470
PROFESSOR: We
would have noticed.

00:45:21.010 --> 00:45:21.660
So far so good?

00:45:21.660 --> 00:45:22.826
Any questions on this stuff?

00:45:25.330 --> 00:45:29.110
So I want to reemphasize in
two minutes, the reduction

00:45:29.110 --> 00:45:29.820
part of this.

00:45:29.820 --> 00:45:32.810
So the reason why we
can solve, once we solve

00:45:32.810 --> 00:45:35.270
one NP-complete problem,
we solve all the other ones

00:45:35.270 --> 00:45:36.333
is reductions.

00:45:39.640 --> 00:45:42.390
So we've done a lot of graph
transformations in this class.

00:45:42.390 --> 00:45:45.970
We had three recitations and two
or three exam problems on that,

00:45:45.970 --> 00:45:48.170
and I think we had some
homework problems on it

00:45:48.170 --> 00:45:50.450
too-- a lot of graph
transformations.

00:45:50.450 --> 00:45:52.260
Graph transformations
are just reductions.

00:45:52.260 --> 00:45:56.790
You take some problem that looks
hard, and you do some magic,

00:45:56.790 --> 00:45:59.290
and you build a graph that
represents that problem,

00:45:59.290 --> 00:46:01.520
and you run shortest path on it.

00:46:01.520 --> 00:46:04.330
Then you take the output for
the shortest path algorithm,

00:46:04.330 --> 00:46:07.487
and you turn it into a solution
to the initial problem.

00:46:07.487 --> 00:46:09.320
This means that we've
reduced those problems

00:46:09.320 --> 00:46:12.440
to shortest path.

00:46:12.440 --> 00:46:14.440
Well, you don't have to
reduce to shortest path.

00:46:14.440 --> 00:46:16.481
If you have a problem that
you know how to solve,

00:46:16.481 --> 00:46:18.990
you can take any other
problem and reduce to it,

00:46:18.990 --> 00:46:21.120
and you've solved
that other problem.

00:46:21.120 --> 00:46:24.960
So basically, here, if you
have your starting problem,

00:46:24.960 --> 00:46:26.890
shortest path is
just one smiley face.

00:46:26.890 --> 00:46:28.680
As long as you arrive
to any smiley face,

00:46:28.680 --> 00:46:32.018
you're in good shape.

00:46:32.018 --> 00:46:33.720
Of course, you
have to be careful

00:46:33.720 --> 00:46:35.428
that while you're
doing you're reduction,

00:46:35.428 --> 00:46:38.110
your problem size
doesn't explode.

00:46:38.110 --> 00:46:45.420
So for example, if you take this
problem-- if you take 3-SAT--

00:46:45.420 --> 00:46:49.290
if you take a 3-CNF
expression, and you reduce it

00:46:49.290 --> 00:46:51.471
to the graph that has
3 to the n vertices,

00:46:51.471 --> 00:46:53.220
and then you try to
run [INAUDIBLE] on it,

00:46:53.220 --> 00:46:55.200
it was the running
time, 3 to the n.

00:46:55.200 --> 00:46:57.144
Now I've got a new
polynomial, right?

00:46:57.144 --> 00:46:58.560
So when you do the
reductions, you

00:46:58.560 --> 00:47:03.020
have to be careful about what
happens to your input size.

00:47:03.020 --> 00:47:04.930
And that's about it.

00:47:04.930 --> 00:47:08.024
This is complexity theory.

00:47:08.024 --> 00:47:10.300
It's basically one
big excuse for why

00:47:10.300 --> 00:47:13.340
we can't solve some
problems that are hard.