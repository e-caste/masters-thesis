WEBVTT

00:00:00.050 --> 00:00:02.460
The following content is
provided under a Creative

00:00:02.460 --> 00:00:03.900
Commons license.

00:00:03.900 --> 00:00:06.900
Your support will help MIT
OpenCourseWare continue to

00:00:06.900 --> 00:00:10.580
offer high quality educational
resources for free.

00:00:10.580 --> 00:00:13.450
To make a donation, or view
additional materials from

00:00:13.450 --> 00:00:17.250
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:17.250 --> 00:00:18.500
ocw.mit.edu.

00:00:21.320 --> 00:00:22.320
PROFESSOR: OK.

00:00:22.320 --> 00:00:22.560
Welcome.

00:00:22.560 --> 00:00:23.710
This is great.

00:00:23.710 --> 00:00:27.080
It almost looks like the
beginning of the Fall, at

00:00:27.080 --> 00:00:29.100
least outside.

00:00:29.100 --> 00:00:32.830
So, what we are going to do,
is it's going to be a very

00:00:32.830 --> 00:00:33.900
exciting month.

00:00:33.900 --> 00:00:38.610
And mainly the reason for doing
this course, is I think

00:00:38.610 --> 00:00:40.670
we are about a software
crisis.

00:00:40.670 --> 00:00:42.460
So there's an interesting quote
I want to start with.

00:00:42.460 --> 00:00:47.030
This is somebody very famous in
computer science, who spoke

00:00:47.030 --> 00:00:50.600
during his student
award lecture.

00:00:50.600 --> 00:00:53.570
His point was, when the
computers were small, there's

00:00:53.570 --> 00:00:54.110
no problem.

00:00:54.110 --> 00:00:55.970
When computers got bigger,
this is basically when

00:00:55.970 --> 00:00:57.810
software started having
problems.

00:00:57.810 --> 00:01:00.580
So, the first software crisis,
in fact, happened around the

00:01:00.580 --> 00:01:02.700
'60s and '70s.

00:01:02.700 --> 00:01:05.310
The problem for the first
software crisis was people are

00:01:05.310 --> 00:01:07.100
writing Assembly language
program.

00:01:07.100 --> 00:01:09.890
When the computers are small,
and memory was small, it was

00:01:09.890 --> 00:01:10.410
completely doable.

00:01:10.410 --> 00:01:11.340
No problem.

00:01:11.340 --> 00:01:14.180
But as computers became larger
and larger, it became very

00:01:14.180 --> 00:01:18.280
hard to write Assembly language
programs. And what

00:01:18.280 --> 00:01:21.040
they needed was some kind of
abstraction portability.

00:01:21.040 --> 00:01:23.840
So you should be able to go
every two years, to not have

00:01:23.840 --> 00:01:26.020
to rewrite the programs
in there.

00:01:26.020 --> 00:01:27.550
So you need portability and
you need some level of

00:01:27.550 --> 00:01:28.530
abstraction.

00:01:28.530 --> 00:01:32.460
So, what that means is instead
of writing all Assembly

00:01:32.460 --> 00:01:35.890
hacking and dealing with every
hardware feature, you can

00:01:35.890 --> 00:01:37.210
erase about that.

00:01:37.210 --> 00:01:40.020
And the way that we solved it,
in that generation is, we,

00:01:40.020 --> 00:01:42.140
came up with these high level
languages like Fortran and C.

00:01:42.140 --> 00:01:46.120
And what those did was, they
kind of provided a common

00:01:46.120 --> 00:01:50.970
machine language across
these machines.

00:01:50.970 --> 00:01:57.130
And so what these did was, they
looked at all machines

00:01:57.130 --> 00:02:01.920
those days, the uniprocessors,
and kind of abstracted out:

00:02:01.920 --> 00:02:05.790
First of all, all the common
properties made available for

00:02:05.790 --> 00:02:06.820
the programmer.

00:02:06.820 --> 00:02:09.110
So it didn't really lead the
programmer too far away from

00:02:09.110 --> 00:02:09.750
the machine.

00:02:09.750 --> 00:02:11.830
But it abstracted out
all the differences.

00:02:11.830 --> 00:02:14.920
So by doing that, we avoided,
we managed to get these

00:02:14.920 --> 00:02:16.240
languagese like C and Fortran.

00:02:16.240 --> 00:02:18.160
Weren't very fast.
Pretty efficient.

00:02:18.160 --> 00:02:19.890
And working through this.

00:02:19.890 --> 00:02:22.350
So that's how we avoided the
first software crisis.

00:02:22.350 --> 00:02:24.670
And I think that a lot of really
good work happened, and

00:02:24.670 --> 00:02:26.970
a few people got Turing
Awards for doing

00:02:26.970 --> 00:02:28.160
these kind of things.

00:02:28.160 --> 00:02:31.030
And then, we faced a second
software crisis in

00:02:31.030 --> 00:02:33.200
the '80s and '90s.

00:02:33.200 --> 00:02:36.940
The problem there was, C was
great if two guys sit in a

00:02:36.940 --> 00:02:38.690
corner and write a program.

00:02:38.690 --> 00:02:40.900
When Microsoft started
programming Word, Word suite,

00:02:40.900 --> 00:02:45.230
with a few hundred programmers,
the problem was

00:02:45.230 --> 00:02:46.780
the bugs never went away.

00:02:46.780 --> 00:02:48.240
The project was supposed
to finish in a year.

00:02:48.240 --> 00:02:49.180
It lasted three years.

00:02:49.180 --> 00:02:51.090
And bugs kept coming
and coming.

00:02:51.090 --> 00:02:53.640
And they had no idea when the
project was going to finish.

00:02:53.640 --> 00:02:57.990
Because the way you write in a
small piece of code really

00:02:57.990 --> 00:02:59.500
didn't scale.

00:02:59.500 --> 00:03:02.150
And, this was a huge crisis for
people, who said we will

00:03:02.150 --> 00:03:04.020
never be able write large
programs. Because these

00:03:04.020 --> 00:03:04.750
programs will never work.

00:03:04.750 --> 00:03:06.790
They're going to be brittle.

00:03:06.790 --> 00:03:11.220
And the problem there is we
want to be able to build

00:03:11.220 --> 00:03:14.430
software that's composable,
malleable, and maintainable.

00:03:14.430 --> 00:03:16.300
So software should be: Multiple
people should

00:03:16.300 --> 00:03:17.840
be able to do it.

00:03:17.840 --> 00:03:18.600
Compose it.

00:03:18.600 --> 00:03:22.190
And the requirements say it
should be easy to change and

00:03:22.190 --> 00:03:22.970
easy to maintain.

00:03:22.970 --> 00:03:25.530
The interesting thing is, we
never cared about high

00:03:25.530 --> 00:03:27.290
performance at that time.

00:03:27.290 --> 00:03:29.420
Moore's law.

00:03:29.420 --> 00:03:32.060
They started to take
care of that.

00:03:32.060 --> 00:03:34.470
The way we solved
that crisis --

00:03:34.470 --> 00:03:36.870
Again, a lot of people got very
famous for doing that, is

00:03:36.870 --> 00:03:37.570
came up with things like

00:03:37.570 --> 00:03:38.990
object-oriented programming languages.

00:03:38.990 --> 00:03:44.980
C#, C++, and now C# and Java,
basically made it possible

00:03:44.980 --> 00:03:47.900
for, now, hundreds if not
thousands of people to develop

00:03:47.900 --> 00:03:52.110
programs. If you look at
something like new Microsoft

00:03:52.110 --> 00:03:53.880
products coming out, thousands
of people are involved.

00:03:53.880 --> 00:03:56.380
And still they manage to
get it out on time.

00:03:56.380 --> 00:03:58.640
And, also we did a bunch
of better tools.

00:03:58.640 --> 00:04:00.330
Things like component
libraries,

00:04:00.330 --> 00:04:01.640
and tools like Purify.

00:04:01.640 --> 00:04:03.350
And we developed a lot of
software engineering

00:04:03.350 --> 00:04:05.090
methodology to develop
software.

00:04:05.090 --> 00:04:07.230
We made it more of a process
than an ad hoc art-form.

00:04:10.000 --> 00:04:10.850
This is great.

00:04:10.850 --> 00:04:12.610
So here we are today.

00:04:12.610 --> 00:04:13.660
We are very happy.

00:04:13.660 --> 00:04:14.740
A lot of programmers, yes.

00:04:14.740 --> 00:04:18.680
Unfortunately, programmers are
pretty oblivious to what's

00:04:18.680 --> 00:04:19.970
happening in hardware.

00:04:19.970 --> 00:04:21.600
We don't care.

00:04:21.600 --> 00:04:24.110
Programs don't have to know
about what things are running.

00:04:24.110 --> 00:04:25.860
You have these nice
virtual machines.

00:04:25.860 --> 00:04:29.190
And, of course, Moore's law,
this great new thing is going

00:04:29.190 --> 00:04:31.490
to come and take
care of all us.

00:04:31.490 --> 00:04:33.395
If you want speed, just
wait six months, the

00:04:33.395 --> 00:04:34.500
machines will be faster.

00:04:34.500 --> 00:04:36.420
And that's the thing we
have been going on.

00:04:36.420 --> 00:04:39.420
The nice thing is, these
programs, programs written

00:04:39.420 --> 00:04:41.810
even in the '70s, still run.

00:04:41.810 --> 00:04:44.030
Probably two, three, orders of
magnitude faster, because

00:04:44.030 --> 00:04:46.750
processors today have gotten
really fast. And this

00:04:46.750 --> 00:04:49.650
abstraction gave us huge
amounts of power.

00:04:49.650 --> 00:04:51.450
Just say, don't care
what's underneath.

00:04:51.450 --> 00:04:53.770
We are going to sit up there,
and just basically program.

00:04:53.770 --> 00:04:55.290
We were very happy with that.

00:04:55.290 --> 00:04:57.960
The problem is, we are running
into an issue here.

00:04:57.960 --> 00:05:02.090
So, we are at the beginning of
this third software crisis.

00:05:02.090 --> 00:05:04.000
What I call the software
crisis due to

00:05:04.000 --> 00:05:05.540
the multicore menace.

00:05:05.540 --> 00:05:08.150
So, multicore, for hardware
people, it's a good

00:05:08.150 --> 00:05:08.460
opportunity.

00:05:08.460 --> 00:05:10.650
But for software people, its
kind of a menace in there.

00:05:10.650 --> 00:05:13.430
Problem is, sequential programs
are left behind by

00:05:13.430 --> 00:05:14.310
Moore's law.

00:05:14.310 --> 00:05:17.570
And, as you see, as probably a
lot of you know, that you're

00:05:17.570 --> 00:05:20.280
not going to get performance
on sequential programs,

00:05:20.280 --> 00:05:25.460
increased performance, without
dealing with this

00:05:25.460 --> 00:05:27.530
And -- the key thing here is,
so why don't we just stop?

00:05:27.530 --> 00:05:27.610
OK.

00:05:27.610 --> 00:05:28.270
Good.

00:05:28.270 --> 00:05:31.770
We have the programs. Machines
today run very fast. Isn't

00:05:31.770 --> 00:05:32.940
that good enough?

00:05:32.940 --> 00:05:35.000
The problem is, we
want it all.

00:05:35.000 --> 00:05:36.210
We need to support
new features.

00:05:36.210 --> 00:05:40.160
We need to support things like
large datasets in the same

00:05:40.160 --> 00:05:43.640
programs. And we kind of keep
expecting a certain

00:05:43.640 --> 00:05:45.390
performance gain every year.

00:05:45.390 --> 00:05:48.660
To sustain portability and
malleability, we assume that

00:05:48.660 --> 00:05:52.830
every few years, the machines'
performance will double.

00:05:52.830 --> 00:05:53.720
Because we believe in that.

00:05:53.720 --> 00:05:56.765
For example, Microsoft Word at
the beginning, ten years ago,

00:05:56.765 --> 00:05:57.900
it still works.

00:05:57.900 --> 00:06:00.520
But it didn't have Spellcheck
running in the background.

00:06:00.520 --> 00:06:01.670
We didn't deal with
very large images.

00:06:01.670 --> 00:06:04.830
We didn't deal with XML
formats in there.

00:06:04.830 --> 00:06:06.730
And, then of course, next
generation, we probably want

00:06:06.730 --> 00:06:09.700
to have integrated video, audio,
voice recognition, all

00:06:09.700 --> 00:06:10.610
those things in there.

00:06:10.610 --> 00:06:11.840
And, we need that power.

00:06:11.840 --> 00:06:13.620
We rely on that power.

00:06:13.620 --> 00:06:16.710
And this is going to be a big
problem, because sequential

00:06:16.710 --> 00:06:18.780
programs are stuck.

00:06:18.780 --> 00:06:21.400
They're not going to provide
that power anymore.

00:06:21.400 --> 00:06:23.760
And it's critical.

00:06:23.760 --> 00:06:26.690
This kind of power is critical
to keep up the

00:06:26.690 --> 00:06:28.610
current rate of evolution.

00:06:28.610 --> 00:06:31.680
And, if we get stuck there,
we are going to have

00:06:31.680 --> 00:06:34.010
a big crisis happening.

00:06:34.010 --> 00:06:38.320
So, how is this happening?

00:06:38.320 --> 00:06:39.710
I talked about Moore's law.

00:06:39.710 --> 00:06:43.180
So this the obligatory
slide of Moore's law.

00:06:43.180 --> 00:06:47.220
So if you look at it, going from
even before the 1970's,

00:06:47.220 --> 00:06:50.920
we had this amazing, amazing
growth in the number of

00:06:50.920 --> 00:06:52.080
transistors available.

00:06:52.080 --> 00:06:54.410
So Moore's law doesn't say
anything about performance.

00:06:54.410 --> 00:06:56.420
It says about the number
of transistors

00:06:56.420 --> 00:06:58.090
available on a die.

00:06:58.090 --> 00:07:00.300
Every 18 months, it doubles.

00:07:00.300 --> 00:07:03.240
So, this basically -- some
people even say -- this is the

00:07:03.240 --> 00:07:08.670
basis of these last two decades
of economic expansion.

00:07:08.670 --> 00:07:11.270
Because we got all this amazing
power, because of this

00:07:11.270 --> 00:07:13.850
kind of growth in here.

00:07:13.850 --> 00:07:16.900
The problem is, if you
look at performance,

00:07:16.900 --> 00:07:18.280
it's flattening out.

00:07:18.280 --> 00:07:20.150
So, this is spec numbers.

00:07:20.150 --> 00:07:23.180
Kind of the way you measure
performance is to have this

00:07:23.180 --> 00:07:24.750
set of programs that
we can keep

00:07:24.750 --> 00:07:25.760
running on these machines.

00:07:25.760 --> 00:07:27.550
And we keep running on
these same machines.

00:07:27.550 --> 00:07:29.510
So even though we are getting
twice the amount of

00:07:29.510 --> 00:07:31.820
transistors, this is kind
of flattening out.

00:07:31.820 --> 00:07:34.960
And then, for the last few
years, it's almost constant.

00:07:34.960 --> 00:07:37.410
We're not getting anything
from there.

00:07:37.410 --> 00:07:40.760
And so, we're still running from
the fumes of that amazing

00:07:40.760 --> 00:07:42.380
growth rates we had
in this time.

00:07:42.380 --> 00:07:45.310
And now we're kind of flattening
out in here.

00:07:45.310 --> 00:07:47.670
And why is this?

00:07:47.670 --> 00:07:51.326
The main reason for this is, I
will talk about four things.

00:07:51.326 --> 00:07:51.430
One

00:07:51.430 --> 00:07:53.690
is power consumption.

00:07:53.690 --> 00:07:56.730
Wire delay, and DRAM access
time, and diminishing returns.

00:07:56.730 --> 00:07:59.300
So I'll go a little bit into
these details, to kind of give

00:07:59.300 --> 00:08:02.000
you an overview of why
this happened.

00:08:02.000 --> 00:08:04.060
The first thing is power.

00:08:04.060 --> 00:08:09.370
So as we go about, we keep
taking more and more power.

00:08:09.370 --> 00:08:14.350
Right now, if you look at the
one Moore trend, that,

00:08:14.350 --> 00:08:15.820
normally, these one point-some
volts that these processors

00:08:15.820 --> 00:08:19.380
run, this draws more
current than any of

00:08:19.380 --> 00:08:22.490
your houses back home.

00:08:22.490 --> 00:08:23.320
I mean, that's amazing.

00:08:23.320 --> 00:08:28.070
The houses probably draw
like 150 amps.

00:08:28.070 --> 00:08:31.530
And in one volt, we are drawing
about 150 watts.

00:08:31.530 --> 00:08:34.060
So there's that much current
going to those things.

00:08:34.060 --> 00:08:36.240
And, heat is a big issue.

00:08:36.240 --> 00:08:39.160
So this still shows, OK, power,
we are flattening out.

00:08:39.160 --> 00:08:42.040
But another interesting thing
is power efficiency.

00:08:42.040 --> 00:08:43.510
So, we are trying to use
these transistors.

00:08:43.510 --> 00:08:45.930
We are trying to do more and
more out of these transistors.

00:08:45.930 --> 00:08:49.390
And if you look at how many
watts, you are spending to get

00:08:49.390 --> 00:08:52.420
one of those spec rates, that's
basically how much to

00:08:52.420 --> 00:08:56.030
do the same amount of work, we
are spending a lot more power.

00:08:56.030 --> 00:08:58.710
Because we are building these
things that have very marginal

00:08:58.710 --> 00:09:00.030
return today.

00:09:00.030 --> 00:09:02.170
That is the problem in
building the current

00:09:02.170 --> 00:09:03.880
super-scaled type things.

00:09:03.880 --> 00:09:04.900
Because it doesn't go.

00:09:04.900 --> 00:09:05.790
This power efficiency.

00:09:05.790 --> 00:09:12.410
This is why Google is building
their shops next to the Grand

00:09:12.410 --> 00:09:15.150
Coulee dam, because they are
sucking in so much power.

00:09:15.150 --> 00:09:17.440
Because power efficiency is
a big issue for them.

00:09:17.440 --> 00:09:21.320
And, today, microprocessors,
most the cost of it is more

00:09:21.320 --> 00:09:22.300
than purchasing.

00:09:22.300 --> 00:09:27.230
It's basically feeding it with
power and cooling it.

00:09:27.230 --> 00:09:29.330
So another problem
is wire delay.

00:09:29.330 --> 00:09:31.650
If you try to build this
monolithic, large process.

00:09:31.650 --> 00:09:37.530
So what happened is, in the
good old days, within the

00:09:37.530 --> 00:09:40.720
clock cycle, in the processor
[UNINTELLIGIBLE] this side.

00:09:40.720 --> 00:09:44.780
You can basically send a wire
from one end to another

00:09:44.780 --> 00:09:47.180
processor, still within
one clock cycle.

00:09:47.180 --> 00:09:49.550
So if you are building this
monolithic thing, it's almost

00:09:49.550 --> 00:09:50.580
like sitting in a room.

00:09:50.580 --> 00:09:54.050
When I talk, the other end
of the room will hear it

00:09:54.050 --> 00:09:54.720
instantaneously.

00:09:54.720 --> 00:09:59.160
Because I'm talking slowly,
or you're clocking slowly.

00:09:59.160 --> 00:10:05.000
And today, we are around this
area, So what that means is,

00:10:05.000 --> 00:10:08.500
in a clock cycle, you can't
get a wire for more than a

00:10:08.500 --> 00:10:10.170
small part of the chip.

00:10:10.170 --> 00:10:14.700
So it's almost like trying to
communicate in this building.

00:10:14.700 --> 00:10:18.010
I want to tell something to
everybody, I can't broadcast.

00:10:18.010 --> 00:10:20.570
Somebody has to go next-door
to tell somebody to get the

00:10:20.570 --> 00:10:22.060
information through
the entire thing.

00:10:22.060 --> 00:10:23.260
Takes time.

00:10:23.260 --> 00:10:26.440
And as we go more and more, this
is going to be harder and

00:10:26.440 --> 00:10:27.480
harder and harder.

00:10:27.480 --> 00:10:33.020
And what that means is, trying
to build large, monolithic,

00:10:33.020 --> 00:10:36.440
processors like we did to keep
the Moore's law kind of

00:10:36.440 --> 00:10:38.410
performance going,
is not working.

00:10:38.410 --> 00:10:40.760
And we have this problem.

00:10:40.760 --> 00:10:45.670
Interesting third issue
is DRAM access time.

00:10:45.670 --> 00:10:46.850
So what's happening is

00:10:46.850 --> 00:10:49.950
microprocessors going like this.

00:10:49.950 --> 00:10:51.620
Performance gets faster
and faster.

00:10:51.620 --> 00:10:56.050
DRAM gets doubled only
about every 10 years.

00:10:56.050 --> 00:11:00.770
And because of that, there's
this interesting mismatch.

00:11:00.770 --> 00:11:02.835
If you are trying to get to
DRAM, if you put things in

00:11:02.835 --> 00:11:07.560
DRAM, it's almost -- about 10
years ago the kind of latency

00:11:07.560 --> 00:11:11.010
we had to the disk, is now
we are having to DRAM.

00:11:11.010 --> 00:11:14.170
So the way we look at this
activity, the costs of it are

00:11:14.170 --> 00:11:15.090
going to get big.

00:11:15.090 --> 00:11:18.880
And it's also a power issue
because if you're on chip,

00:11:18.880 --> 00:11:22.390
it's probably two orders of
magnitude cheaper to get to a

00:11:22.390 --> 00:11:25.350
word on chip then go all the way
outside, get to the DRAM

00:11:25.350 --> 00:11:26.710
and get things out.

00:11:26.710 --> 00:11:29.780
And so, between power and this,
is also creating a huge

00:11:29.780 --> 00:11:33.060
amount of issue, an
impossibility for us to keep

00:11:33.060 --> 00:11:37.050
this kind of Moore's law type
performance to keep going.

00:11:37.050 --> 00:11:39.430
The final thing is diminishing
returns.

00:11:39.430 --> 00:11:41.560
So if you look at the `80s,
that is the era of

00:11:41.560 --> 00:11:42.010
superscalars.

00:11:42.010 --> 00:11:45.760
We had amazing performance
improvements.

00:11:45.760 --> 00:11:49.750
For example, when you started
the decade, every CPI speed,

00:11:49.750 --> 00:11:52.250
clocks per instructions.

00:11:52.250 --> 00:11:54.850
How many clocks you had to run
to get one instruction going?

00:11:54.850 --> 00:11:56.810
At the beginning of the decade,
you had to have about

00:11:56.810 --> 00:11:59.290
10 clock cycles to execute
one instruction on

00:11:59.290 --> 00:11:59.450
[UNINTELLIGIBLE].

00:11:59.450 --> 00:12:03.430
At the end of the decade, we
went about one clock cycle

00:12:03.430 --> 00:12:04.370
[UNINTELLIGIBLE]

00:12:04.370 --> 00:12:08.240
we get a new instruction
graduated from that.

00:12:08.240 --> 00:12:10.750
And that gave an amazing
performance boost.

00:12:10.750 --> 00:12:14.550
And in the '90s, we had an era
of diminishing returns.

00:12:14.550 --> 00:12:16.950
We kind of went from this
two-way, superscaled, almost

00:12:16.950 --> 00:12:20.340
like six-way out of order, out
of issue, branch prediction,

00:12:20.340 --> 00:12:21.140
everything's predicated.

00:12:21.140 --> 00:12:23.910
And this huge pipeline.

00:12:23.910 --> 00:12:25.240
Amazingly complex machines.

00:12:25.240 --> 00:12:29.280
But we went from one clock per
instruction to about half a

00:12:29.280 --> 00:12:30.440
clock per instruction.

00:12:30.440 --> 00:12:33.070
So we just doubled that
kind of performance.

00:12:33.070 --> 00:12:36.860
And performance was below
expectations, and projects got

00:12:36.860 --> 00:12:38.710
delayed and cancelled.

00:12:38.710 --> 00:12:39.910
One thing that failed --

00:12:39.910 --> 00:12:41.280
I'm not going to talk
about that much.

00:12:41.280 --> 00:12:44.550
Is, even at this time, you could
get that clock frequency

00:12:44.550 --> 00:12:45.110
higher and higher.

00:12:45.110 --> 00:12:47.990
And because of power and other
physical limitations, we are

00:12:47.990 --> 00:12:49.690
also hitting a wall in
clock frequency.

00:12:49.690 --> 00:12:54.070
We are not getting -- because at
that time, if you realize,

00:12:54.070 --> 00:12:55.095
everybody [UNINTELLIGIBLE]
saying how fast

00:12:55.095 --> 00:12:56.340
their machine ran.

00:12:56.340 --> 00:12:58.260
And they have stopped that,
because they can't get

00:12:58.260 --> 00:13:00.990
machines to double their
frequencies any more.

00:13:00.990 --> 00:13:05.810
So, between those two, your
performance kind of stuck.

00:13:05.810 --> 00:13:10.370
So that is why now we are
starting the new era of

00:13:10.370 --> 00:13:10.970
multicores.

00:13:10.970 --> 00:13:12.140
We need explicit parallelism.

00:13:12.140 --> 00:13:15.570
We can't build these large
monolithic things that keep

00:13:15.570 --> 00:13:17.905
giving you performance
every few years.

00:13:17.905 --> 00:13:18.530
That stopped.

00:13:18.530 --> 00:13:22.220
And we can build a sequential
machine where what you get in

00:13:22.220 --> 00:13:25.880
10 years' time will almost be
same as what you get today.

00:13:25.880 --> 00:13:28.680
But, we get more and
more silicon.

00:13:28.680 --> 00:13:29.320
It's doubling.

00:13:29.320 --> 00:13:30.700
Moore's law still keeps going.

00:13:30.700 --> 00:13:33.200
So what you do with that silicon
is replicate, and

00:13:33.200 --> 00:13:34.010
build more.

00:13:34.010 --> 00:13:36.800
And that's where we are going.

00:13:36.800 --> 00:13:41.450
So, if you look at what's
happening, the unicores are a

00:13:41.450 --> 00:13:42.840
dying breed.

00:13:42.840 --> 00:13:45.660
The last big one was Intel had
this project that tried to

00:13:45.660 --> 00:13:48.900
build very fast, amazing,
superscalar machines.

00:13:48.900 --> 00:13:50.450
All those projects had
to get cancelled.

00:13:50.450 --> 00:13:53.190
Because they could not
get the performance.

00:13:53.190 --> 00:13:55.320
Power was way too high,
they couldn't get

00:13:55.320 --> 00:13:56.050
the power in there.

00:13:56.050 --> 00:13:57.370
And those things
got cancelled.

00:13:57.370 --> 00:14:00.200
And as you see, there's
more and more

00:14:00.200 --> 00:14:02.650
multicores coming in there.

00:14:02.650 --> 00:14:05.030
In fact, if you look at
it, multicores are

00:14:05.030 --> 00:14:06.810
here in a big way.

00:14:06.810 --> 00:14:11.040
If you look all these machines,
the Pentium line of

00:14:11.040 --> 00:14:13.020
uniprocessors.

00:14:13.020 --> 00:14:16.330
From recent time, there had been
four cores, eight cores

00:14:16.330 --> 00:14:19.080
and even machines that have
more than 256 cores.

00:14:19.080 --> 00:14:22.450
Small cores, but we are
basically going into -- that's

00:14:22.450 --> 00:14:23.410
a new trend.

00:14:23.410 --> 00:14:24.690
And if you look at the trend
line, it's an interesting

00:14:24.690 --> 00:14:26.450
trend line going in there.

00:14:26.450 --> 00:14:32.510
So, what I'm going to do
now is switch gears.

00:14:32.510 --> 00:14:40.450
Because, we had Mike [? Brown ?]
from IBM.

00:14:40.450 --> 00:14:43.740
We are very fortunate to have
him here to give us a feel

00:14:43.740 --> 00:14:45.810
about the cell processor.

00:14:45.810 --> 00:14:48.550
Because we are going to spend
this month really getting to

00:14:48.550 --> 00:14:49.390
understand cell processing.

00:14:49.390 --> 00:14:50.770
And really taking advantage
of that.

00:14:50.770 --> 00:14:53.550
And he had done huge amounts
of work with cells.

00:14:53.550 --> 00:14:56.030
He's at IBM TJ Watson.

00:14:56.030 --> 00:14:59.385
And so he's going to, in the
next hour, hour and half, he's

00:14:59.385 --> 00:15:00.640
going to give us the
lowdown on cell.

00:15:00.640 --> 00:15:05.250
And then I will conclude with
a little bit more remarks

00:15:05.250 --> 00:15:10.180
about how we are going to
do the class structure.

00:15:10.180 --> 00:15:10.250
OK.

00:15:10.250 --> 00:15:12.250
Mike.

00:15:12.250 --> 00:15:14.630
Hopefully -- he has to catch a
flight, so we will kind of go

00:15:14.630 --> 00:15:20.110
fast. Hopefully you guys
[INAUDIBLE] go without too

00:15:20.110 --> 00:15:21.150
much of a break.

00:15:21.150 --> 00:15:25.980
So if things get too tired, let
us know so we'll see if we

00:15:25.980 --> 00:15:28.320
can put a break in the middle.