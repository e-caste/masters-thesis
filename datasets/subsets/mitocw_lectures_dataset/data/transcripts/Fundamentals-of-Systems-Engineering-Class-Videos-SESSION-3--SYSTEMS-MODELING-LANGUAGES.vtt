WEBVTT

00:00:00.120 --> 00:00:02.460
The following content is
provided under a Creative

00:00:02.460 --> 00:00:03.880
Commons license.

00:00:03.880 --> 00:00:06.090
Your support will help
MIT OpenCourseWare

00:00:06.090 --> 00:00:10.180
continue to offer high-quality
educational resources for free.

00:00:10.180 --> 00:00:12.720
To make a donation or to
view additional materials

00:00:12.720 --> 00:00:16.680
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.680 --> 00:00:17.880
at ocw.mit.edu.

00:00:25.150 --> 00:00:28.170
OLIVER DE WECK: So let me start.

00:00:28.170 --> 00:00:31.080
Session 3 is about system
modeling languages.

00:00:31.080 --> 00:00:37.950
But before I start, I'd like
to remind you that A1 is due

00:00:37.950 --> 00:00:38.940
today.

00:00:38.940 --> 00:00:41.910
The first assignment
is due today.

00:00:41.910 --> 00:00:46.620
And I think neither [? Yuanna ?]
or I or [INAUDIBLE],,

00:00:46.620 --> 00:00:48.850
did you get a lot of
questions about A1?

00:00:53.870 --> 00:00:54.620
GUEST SPEAKER: No.

00:00:54.620 --> 00:00:55.745
I didn't get any questions.

00:00:55.745 --> 00:00:56.619
OLIVER DE WECK: Yeah.

00:00:56.619 --> 00:00:58.250
So we didn't get many questions.

00:00:58.250 --> 00:01:02.060
So I interpret
that as a positive,

00:01:02.060 --> 00:01:05.150
but I guess we'll find out.

00:01:05.150 --> 00:01:06.740
Everybody submitted.

00:01:06.740 --> 00:01:12.220
Well, so we're hoping to have
these graded in about a week,

00:01:12.220 --> 00:01:13.330
give you feedback.

00:01:13.330 --> 00:01:16.900
And we'll also post
a master solution.

00:01:16.900 --> 00:01:20.170
And A2 is out right now.

00:01:20.170 --> 00:01:22.990
And the other good news is
there is no new assignment

00:01:22.990 --> 00:01:24.430
today that's being--

00:01:24.430 --> 00:01:26.700
the next A3 is going
to go out next week.

00:01:29.620 --> 00:01:31.890
Any questions about A1?

00:01:31.890 --> 00:01:35.500
Was there something
that was particularly

00:01:35.500 --> 00:01:37.120
difficult or confusing?

00:01:37.120 --> 00:01:38.710
Or was it straightforward?

00:01:38.710 --> 00:01:40.150
Anybody want to comment on A1?

00:01:44.774 --> 00:01:47.630
Wow.

00:01:47.630 --> 00:01:49.550
Sam.

00:01:49.550 --> 00:01:52.082
Do you want me--
push the button.

00:01:52.082 --> 00:01:53.540
GUEST SPEAKER: No,
our team thought

00:01:53.540 --> 00:01:56.000
it was fairly clear
on what we had

00:01:56.000 --> 00:01:57.809
to do based on the lectures.

00:01:57.809 --> 00:01:58.600
OLIVER DE WECK: OK.

00:01:58.600 --> 00:01:59.870
GUEST SPEAKER: We
didn't have any trouble.

00:01:59.870 --> 00:02:01.190
OLIVER DE WECK: Good.

00:02:01.190 --> 00:02:02.770
All right.

00:02:02.770 --> 00:02:05.330
Well, let's keep going then.

00:02:05.330 --> 00:02:08.900
So the V-Model is our
roadmap for the class.

00:02:08.900 --> 00:02:10.759
We're starting to
fill in the V. We're

00:02:10.759 --> 00:02:12.290
still in the upper left corner.

00:02:12.290 --> 00:02:15.320
And today's lecture is
actually a little different.

00:02:15.320 --> 00:02:18.410
It's sort of in the center
of the V, system modeling

00:02:18.410 --> 00:02:22.070
languages, as a
precondition or precursor

00:02:22.070 --> 00:02:26.600
to what we've been calling MBSE,
Model-Based System Engineering.

00:02:26.600 --> 00:02:32.490
So what I'd like to cover
today is why do we need--

00:02:32.490 --> 00:02:35.960
or why have these system
modeling languages emerged,

00:02:35.960 --> 00:02:39.320
particularly, what do we
mean by ontology, semantics,

00:02:39.320 --> 00:02:40.730
and syntax?

00:02:40.730 --> 00:02:43.550
And then we're going
to give you a--

00:02:43.550 --> 00:02:46.220
I would characterize
this as a sampler

00:02:46.220 --> 00:02:48.710
of three different
system modeling

00:02:48.710 --> 00:02:50.690
languages that
have emerged really

00:02:50.690 --> 00:02:53.910
within the last 10, 15 years.

00:02:53.910 --> 00:02:58.370
The first one is called OPM,
Object Process Methodology.

00:02:58.370 --> 00:03:02.270
The second one is called SySML,
System Modeling Language.

00:03:02.270 --> 00:03:05.510
And then the third one
is called Modelica.

00:03:05.510 --> 00:03:09.080
And then we'll sort of quickly
wrap up with the question,

00:03:09.080 --> 00:03:12.090
you know, what does this mean
now for system engineering

00:03:12.090 --> 00:03:15.460
today, and tomorrow
in the future?

00:03:15.460 --> 00:03:19.000
So I'd like to motivate
this with a little exercise.

00:03:19.000 --> 00:03:22.120
So you remember Mr.
Sticky from last time?

00:03:22.120 --> 00:03:23.700
You came up with
some requirements.

00:03:23.700 --> 00:03:27.430
So it's kind of the simplest
system I could think of here.

00:03:27.430 --> 00:03:32.140
So what we'd like to do is
have you work in pairs again.

00:03:32.140 --> 00:03:38.690
And the assignment here
is to describe this system

00:03:38.690 --> 00:03:42.730
as clearly as you can,
provide a description.

00:03:42.730 --> 00:03:46.390
So last time the assignment
was right, a requirement,

00:03:46.390 --> 00:03:50.440
come up with some requirements
that led to this design.

00:03:50.440 --> 00:03:52.930
But today I would
like you to describe

00:03:52.930 --> 00:03:54.880
what the system is,
how it functions,

00:03:54.880 --> 00:03:57.970
and so forth, as
clearly as you can.

00:03:57.970 --> 00:03:59.720
And I would like
you to do this--

00:03:59.720 --> 00:04:04.450
so hopefully you're on the
Webex, logged into the Webex.

00:04:04.450 --> 00:04:07.000
I would like you to do
this in teams of two.

00:04:07.000 --> 00:04:09.100
And as you're
doing this, I don't

00:04:09.100 --> 00:04:11.680
know if you've noticed but
on the Webex there's actually

00:04:11.680 --> 00:04:18.160
a Notepad feature.

00:04:18.160 --> 00:04:19.112
Where is it?

00:04:30.940 --> 00:04:32.700
Tell me.

00:04:32.700 --> 00:04:33.200
Left?

00:04:33.200 --> 00:04:33.998
Right?

00:04:33.998 --> 00:04:43.270
AUDIENCE: [INAUDIBLE]

00:04:43.270 --> 00:04:46.240
OLIVER DE WECK: Oh, I see.

00:04:46.240 --> 00:04:49.310
So I can't share and use the
Notepad at the same time.

00:04:49.310 --> 00:04:53.747
AUDIENCE: [INAUDIBLE]

00:04:53.747 --> 00:04:54.788
OLIVER DE WECK: Annotate.

00:04:54.788 --> 00:04:56.165
AUDIENCE: [INAUDIBLE]

00:04:56.165 --> 00:04:57.290
OLIVER DE WECK: Yeah, yeah.

00:04:57.290 --> 00:05:01.980
AUDIENCE: [INAUDIBLE]

00:05:01.980 --> 00:05:04.540
OLIVER DE WECK: Stop sharing.

00:05:04.540 --> 00:05:07.870
But then they can't see it.

00:05:07.870 --> 00:05:09.144
AUDIENCE: [INAUDIBLE]

00:05:09.144 --> 00:05:10.560
OLIVER DE WECK:
Can they see this?

00:05:10.560 --> 00:05:13.832
AUDIENCE: [INAUDIBLE]

00:05:13.832 --> 00:05:15.415
OLIVER DE WECK: So
you can write text.

00:05:32.760 --> 00:05:34.995
You can draw shapes.

00:05:41.990 --> 00:05:45.230
So the reason I want you to
do this on the whiteboard

00:05:45.230 --> 00:05:48.620
is such that we can
then go around and look

00:05:48.620 --> 00:05:51.020
at some examples.

00:05:51.020 --> 00:05:56.430
So the assignment is take five
minutes, turn to your partner

00:05:56.430 --> 00:05:59.990
and try to describe this system.

00:05:59.990 --> 00:06:02.180
And then we'll go around
and look at some--

00:06:02.180 --> 00:06:05.386
we'll sample people's
descriptions.

00:06:05.386 --> 00:06:08.271
Go for it.

00:06:08.271 --> 00:06:08.770
All right.

00:06:08.770 --> 00:06:12.250
So keep working
on the assignment

00:06:12.250 --> 00:06:14.080
but do it locally
on your computer,

00:06:14.080 --> 00:06:16.420
not on the whiteboard.

00:06:16.420 --> 00:06:21.190
And then we'll sort of discuss
it and share it and maybe

00:06:21.190 --> 00:06:22.720
not use the
whiteboard, because I

00:06:22.720 --> 00:06:26.170
didn't realize there's only one
whiteboard that we all share.

00:06:26.170 --> 00:06:28.420
I thought that you have
individually the whiteboard

00:06:28.420 --> 00:06:31.300
and then you can sort of pass
it on to different people.

00:06:31.300 --> 00:06:35.210
So if you do it locally
on your machine,

00:06:35.210 --> 00:06:37.200
then we can share the
screen so it'll work.

00:06:37.200 --> 00:06:42.850
So do it in do it in PowerPoint,
or Word, or sketchpad,

00:06:42.850 --> 00:06:44.352
or anything you want.

00:06:44.352 --> 00:06:45.060
Sorry about that.

00:06:50.950 --> 00:06:51.450
All right.

00:06:51.450 --> 00:06:53.234
So let's do this.

00:06:53.234 --> 00:06:54.900
We're going to sort
of go back and forth

00:06:54.900 --> 00:06:58.170
between here and EPFL.

00:06:58.170 --> 00:07:02.960
Let's start maybe
over here with Narek.

00:07:02.960 --> 00:07:04.430
Are you ready?

00:07:04.430 --> 00:07:07.690
So I'm going to
give you the ball,

00:07:07.690 --> 00:07:10.480
and then you can
sort of explain how

00:07:10.480 --> 00:07:13.690
you guys describe the system.

00:07:13.690 --> 00:07:16.090
NAREK SHOUGARIAN: So
what we decided to do

00:07:16.090 --> 00:07:23.470
was identify the primary
function of Mr. Sticky.

00:07:23.470 --> 00:07:28.510
So the primary function is
to trap the fly, we thought.

00:07:28.510 --> 00:07:30.730
This is enabled by a
couple of other functions

00:07:30.730 --> 00:07:33.560
that are sort of at a
lower layer of abstraction.

00:07:33.560 --> 00:07:36.220
It's attracting the fly,
immobilizing the fly,

00:07:36.220 --> 00:07:39.010
transporting the
objects to where

00:07:39.010 --> 00:07:42.880
you need to immobilize the
fly, and deploying Mr. Sticky.

00:07:42.880 --> 00:07:45.790
And we mapped this
to the physical forms

00:07:45.790 --> 00:07:46.960
that enable the function.

00:07:46.960 --> 00:07:49.210
So the canister, the
physical form of the canister

00:07:49.210 --> 00:07:51.880
is helping with the
transporting function.

00:07:51.880 --> 00:07:54.860
The sticky tape is helping
with the immobilizing function.

00:07:54.860 --> 00:07:56.650
The scented
material, we thought,

00:07:56.650 --> 00:07:58.690
would be helping for
the attracting function.

00:07:58.690 --> 00:08:01.510
And the hook maybe on top
that you use to hang it

00:08:01.510 --> 00:08:03.040
would help with the deploying.

00:08:03.040 --> 00:08:03.860
OLIVER DE WECK: OK.

00:08:03.860 --> 00:08:04.360
Good.

00:08:04.360 --> 00:08:07.420
So nice function
form separation.

00:08:07.420 --> 00:08:11.830
And you used primarily text,
human language to describe it.

00:08:11.830 --> 00:08:14.710
So let's see, at EPFL,
who would like to share?

00:08:18.704 --> 00:08:19.870
And we'll give you the ball.

00:08:22.059 --> 00:08:22.600
AUDIENCE: OK.

00:08:22.600 --> 00:08:25.610
We can try maybe.

00:08:25.610 --> 00:08:27.650
OLIVER DE WECK: Who is speaking?

00:08:27.650 --> 00:08:28.650
AUDIENCE: Maxim.

00:08:28.650 --> 00:08:29.733
OLIVER DE WECK: Maxim, OK.

00:08:29.733 --> 00:08:32.550
Can we give the ball to Maxim?

00:08:32.550 --> 00:08:33.390
AUDIENCE: Yes.

00:08:33.390 --> 00:08:34.299
Do you see something?

00:08:34.299 --> 00:08:35.623
OLIVER DE WECK: Yeah, its good.

00:08:35.623 --> 00:08:36.539
AUDIENCE: Oh, perfect.

00:08:36.539 --> 00:08:42.710
So we draw like the same system
when deployed and undeployed.

00:08:42.710 --> 00:08:45.720
So we begin with a container
containing basically

00:08:45.720 --> 00:08:47.940
the sticky setup rolled.

00:08:47.940 --> 00:08:49.980
Then when unrolled,
we have the container

00:08:49.980 --> 00:08:54.056
that should be linked to the
sticky setup, the [INAUDIBLE]

00:08:54.056 --> 00:08:55.190
whatever.

00:08:55.190 --> 00:08:59.670
And then we have like an
external input from the insects

00:08:59.670 --> 00:09:01.995
that were, that come to--

00:09:01.995 --> 00:09:03.415
we it sticked onto the--

00:09:07.076 --> 00:09:11.870
OLIVER DE WECK: Yeah, go ahead

00:09:11.870 --> 00:09:12.730
AUDIENCE: OK.

00:09:12.730 --> 00:09:14.920
So that's all.

00:09:14.920 --> 00:09:17.420
OLIVER DE WECK:
So I'll note here

00:09:17.420 --> 00:09:19.250
that you guys used graphics.

00:09:19.250 --> 00:09:20.960
You used some kind of
graphical language.

00:09:20.960 --> 00:09:23.570
And at the highest
level, you have--

00:09:23.570 --> 00:09:26.360
it's like a state
diagram, rolled, unrolled.

00:09:26.360 --> 00:09:28.940
So you showed the system
in two different states.

00:09:28.940 --> 00:09:30.680
Very nice.

00:09:30.680 --> 00:09:32.750
Somebody else here
on the MIT side,

00:09:32.750 --> 00:09:34.620
and then we'll go
back one more time.

00:09:34.620 --> 00:09:36.790
Who would like to share here?

00:09:36.790 --> 00:09:38.010
Lucille?

00:09:38.010 --> 00:09:39.730
OK.

00:09:39.730 --> 00:09:42.130
So let's--

00:09:42.130 --> 00:09:48.580
AUDIENCE: So we did a diagram
showing the use of Mr. Sticky.

00:09:48.580 --> 00:09:50.560
So we have a user
because Mr. Sticky

00:09:50.560 --> 00:09:54.330
has to be rolled and
unrolled-- well, unrolled.

00:09:54.330 --> 00:09:59.110
The user installs or
disposes of Mr. Sticky.

00:09:59.110 --> 00:10:02.500
The flies are attracted to-- or
Mr. Sticky attracts the flies,

00:10:02.500 --> 00:10:04.540
and the flies stick
to Mr. Sticky.

00:10:04.540 --> 00:10:06.250
And then we did
compose Mr. Sticky

00:10:06.250 --> 00:10:08.890
into the different
components that

00:10:08.890 --> 00:10:11.800
are below at a lower level.

00:10:11.800 --> 00:10:14.710
And yeah, so it's basically at
a higher level of use diagram.

00:10:14.710 --> 00:10:15.670
OLIVER DE WECK: OK.

00:10:15.670 --> 00:10:19.150
So here we have, again,
a graphical description.

00:10:19.150 --> 00:10:20.890
The states are sort of implied.

00:10:20.890 --> 00:10:25.680
But you're focusing on
decomposition, the elements.

00:10:25.680 --> 00:10:26.950
Very nice.

00:10:26.950 --> 00:10:28.250
Anybody else at EPFL?

00:10:28.250 --> 00:10:32.215
Did anybody just write a
paragraph of text, or more

00:10:32.215 --> 00:10:33.610
of, like, sentences?

00:10:36.406 --> 00:10:39.670
AUDIENCE: [INAUDIBLE]

00:10:39.670 --> 00:10:41.620
OLIVER DE WECK: At EPFL,
who wants to share?

00:10:44.810 --> 00:10:45.820
AUDIENCE: Chris here.

00:10:45.820 --> 00:10:47.540
OLIVER DE WECK: Chris, OK.

00:10:47.540 --> 00:10:49.630
AUDIENCE: So we
didn't write the text.

00:10:49.630 --> 00:10:55.150
The text seems a bit heavy
to convey a description

00:10:55.150 --> 00:10:57.070
in efficient terms.

00:10:57.070 --> 00:11:01.120
What we prefer to do is
decompose in elements

00:11:01.120 --> 00:11:09.680
and for each element
give some properties.

00:11:09.680 --> 00:11:10.890
OLIVER DE WECK: OK.

00:11:10.890 --> 00:11:13.700
And did you do this
in the form of a list,

00:11:13.700 --> 00:11:15.790
or in the form of a table?

00:11:15.790 --> 00:11:19.371
Or how did you
actually describe it?

00:11:19.371 --> 00:11:20.120
AUDIENCE: So wait.

00:11:20.120 --> 00:11:21.860
I'm trying to share the screen.

00:11:21.860 --> 00:11:22.747
OLIVER DE WECK: OK.

00:11:22.747 --> 00:11:23.580
AUDIENCE: All right.

00:11:23.580 --> 00:11:26.520
So we just worked on
the first half here.

00:11:26.520 --> 00:11:28.030
We have the band.

00:11:28.030 --> 00:11:29.790
And we give here properties.

00:11:29.790 --> 00:11:33.180
Those that have to be made
of paper or soft material

00:11:33.180 --> 00:11:40.720
has to be 1 to 1.5 meters
long, 3 to 5 centimeters large.

00:11:40.720 --> 00:11:46.320
It needs to have a coating which
itself is a sticky material,

00:11:46.320 --> 00:11:49.125
and be centered in
order to attract flies.

00:11:49.125 --> 00:11:51.300
It needs to have visible color.

00:11:51.300 --> 00:11:57.960
And then, well, the other part
here, which I'm highlighting,

00:11:57.960 --> 00:12:04.100
would be related to
the packaging, so

00:12:04.100 --> 00:12:08.430
a self-sealing linear container
with a single-use opening,

00:12:08.430 --> 00:12:10.820
including a hanger.

00:12:10.820 --> 00:12:14.530
We'd possibly give
branding on the packaging

00:12:14.530 --> 00:12:16.620
and, well, the
non-toxic material

00:12:16.620 --> 00:12:20.685
would refer to the
sticky material.

00:12:20.685 --> 00:12:21.810
OLIVER DE WECK: Good, good.

00:12:21.810 --> 00:12:22.710
Thank you very much.

00:12:22.710 --> 00:12:23.830
This is great.

00:12:23.830 --> 00:12:26.880
So what you showed,
that's more like a list.

00:12:26.880 --> 00:12:28.290
And I would
describe-- this looks

00:12:28.290 --> 00:12:31.770
like what I would call
a bill of materials.

00:12:31.770 --> 00:12:35.970
It's essentially a list
of the primary elements

00:12:35.970 --> 00:12:37.500
of form of the system.

00:12:37.500 --> 00:12:41.470
But there are some attributes
that are associated.

00:12:41.470 --> 00:12:46.530
So this is a list format in
the form of a bill of materials

00:12:46.530 --> 00:12:47.990
with attributes attached.

00:12:47.990 --> 00:12:49.570
So thank you very much.

00:12:49.570 --> 00:12:50.770
That's great.

00:12:50.770 --> 00:12:54.720
So I'm going to
share here again.

00:12:54.720 --> 00:12:59.180
And you're probably
wondering what the heck?

00:12:59.180 --> 00:13:01.150
Why did we do this?

00:13:01.150 --> 00:13:03.470
Why did we do this exercise?

00:13:03.470 --> 00:13:10.450
And that's the point
I want to make next.

00:13:10.450 --> 00:13:12.400
So here's a very simple system.

00:13:12.400 --> 00:13:15.340
And we have four
examples of descriptions

00:13:15.340 --> 00:13:17.470
that were quite different.

00:13:17.470 --> 00:13:19.960
And of course, if
you had more time,

00:13:19.960 --> 00:13:21.380
they'd become more complete.

00:13:21.380 --> 00:13:23.170
But they would be
really different.

00:13:23.170 --> 00:13:27.010
So this is
fundamentally the issue

00:13:27.010 --> 00:13:28.690
that we've been
facing in systems

00:13:28.690 --> 00:13:30.520
engineering for a long time.

00:13:30.520 --> 00:13:32.980
The means for describing
our artifacts,

00:13:32.980 --> 00:13:35.230
whether it's something
as simple as a Mr.

00:13:35.230 --> 00:13:38.560
Sticky, or an airplane,
or a spacecraft,

00:13:38.560 --> 00:13:41.440
or a medical device,
or even a service,

00:13:41.440 --> 00:13:42.510
how would we describe it?

00:13:42.510 --> 00:13:44.530
Well, first of all,
natural language,

00:13:44.530 --> 00:13:46.670
the human natural language.

00:13:46.670 --> 00:13:50.440
And as we know, the human
natural language is very rich.

00:13:50.440 --> 00:13:53.140
There's very different
ways in which

00:13:53.140 --> 00:13:56.710
we can express, essentially,
the same facts, the same things.

00:13:56.710 --> 00:14:01.760
That's a wonderful thing if
you're a poet or a writer.

00:14:01.760 --> 00:14:04.610
But it makes system
engineering challenging,

00:14:04.610 --> 00:14:08.270
because it gets
confusing when we're

00:14:08.270 --> 00:14:11.510
describing the same thing
in very different ways.

00:14:11.510 --> 00:14:14.210
Or graphical, so
we saw some boxes,

00:14:14.210 --> 00:14:18.050
and we saw some great
examples, sketches, drawings.

00:14:18.050 --> 00:14:22.340
So fundamentally, the
way we describe systems--

00:14:22.340 --> 00:14:25.670
and this gets to the left half
and right half of the brain--

00:14:25.670 --> 00:14:31.400
is using language, words,
sentences, lists, or graphical.

00:14:31.400 --> 00:14:35.010
Those are the two fundamental
ways of describing systems.

00:14:35.010 --> 00:14:38.270
And then we put all these
descriptions together

00:14:38.270 --> 00:14:41.480
in what we've been
calling documents.

00:14:41.480 --> 00:14:43.130
We aggregate this in documents.

00:14:43.130 --> 00:14:46.880
So examples of documents would
be a requirements document.

00:14:46.880 --> 00:14:49.910
That's what, essentially,
you're doing in Assignment 2.

00:14:49.910 --> 00:14:55.130
Or a drawing package,
even if it's in CAD,

00:14:55.130 --> 00:14:59.150
it's still essentially
a document.

00:14:59.150 --> 00:15:01.670
So typically in system
engineering all of this

00:15:01.670 --> 00:15:06.660
gets assembled into what we call
a TDP, Technical Data Package.

00:15:06.660 --> 00:15:09.620
And fundamentally, when
you're designing a new system,

00:15:09.620 --> 00:15:11.450
you're producing
a technical data

00:15:11.450 --> 00:15:16.340
package that has software
drawings, descriptions.

00:15:16.340 --> 00:15:19.560
And that's the deliverable
from the design process,

00:15:19.560 --> 00:15:22.440
is this TDP, Technical
Data Package.

00:15:22.440 --> 00:15:25.040
And from that, you should then
be able to build and operate

00:15:25.040 --> 00:15:29.450
the system with as few errors,
mistakes, misunderstandings

00:15:29.450 --> 00:15:30.830
as possible.

00:15:30.830 --> 00:15:33.590
And fundamentally,
as our systems

00:15:33.590 --> 00:15:35.780
have been getting more
and more complex--

00:15:35.780 --> 00:15:38.180
we're now talking
about the systems

00:15:38.180 --> 00:15:42.050
that need the three, four,
five layers of decomposition--

00:15:42.050 --> 00:15:45.770
it's very easy to have
errors, omissions,

00:15:45.770 --> 00:15:48.780
different interpretations
of this information.

00:15:48.780 --> 00:15:53.060
So that's fundamentally--
but there are advantages.

00:15:53.060 --> 00:15:56.540
I don't want to say
it's categorically

00:15:56.540 --> 00:16:00.140
bad to use natural
language and graphics.

00:16:00.140 --> 00:16:03.080
They're definitely an advantage,
familiarity to the creator

00:16:03.080 --> 00:16:03.950
of the description.

00:16:03.950 --> 00:16:05.180
So it's easy.

00:16:05.180 --> 00:16:05.960
It's comfortable.

00:16:05.960 --> 00:16:07.430
It feels familiar.

00:16:07.430 --> 00:16:09.500
And also it's not
confining, so you

00:16:09.500 --> 00:16:13.190
can be quite creative
by creating descriptions

00:16:13.190 --> 00:16:14.240
in this way.

00:16:14.240 --> 00:16:16.670
But the list of
disadvantages is quite

00:16:16.670 --> 00:16:21.080
long for allowing an
arbitrary description, room

00:16:21.080 --> 00:16:23.930
for ambiguous
interpretations and errors.

00:16:23.930 --> 00:16:25.830
It's quite difficult to update.

00:16:25.830 --> 00:16:27.950
So if you make a change
in one description,

00:16:27.950 --> 00:16:30.020
that change will
not automatically

00:16:30.020 --> 00:16:32.960
propagate to the
other descriptions.

00:16:32.960 --> 00:16:35.900
Handing off these descriptions
from one lifecycle phase

00:16:35.900 --> 00:16:38.480
to another, there's
discontinuities

00:16:38.480 --> 00:16:40.340
in these hand-offs.

00:16:40.340 --> 00:16:44.300
Uneven level of abstraction,
so what I mean by that is you

00:16:44.300 --> 00:16:47.990
may describe one part of the
system, and very detailed.

00:16:47.990 --> 00:16:52.945
So the last example
we saw with the list,

00:16:52.945 --> 00:16:54.320
with the bill of
materials, there

00:16:54.320 --> 00:16:56.810
was quite a bit of
detail there on the scent

00:16:56.810 --> 00:16:59.320
and the attributes of the tape.

00:16:59.320 --> 00:17:01.670
But one of the other--
at least a couple

00:17:01.670 --> 00:17:04.250
of the other descriptions
didn't have that level of detail

00:17:04.250 --> 00:17:05.750
when it came to the tape.

00:17:05.750 --> 00:17:08.359
So the level of
abstraction could

00:17:08.359 --> 00:17:13.010
be quite different in the
different ways to describe it.

00:17:13.010 --> 00:17:15.470
And then for a
complex system, you

00:17:15.470 --> 00:17:19.099
can imagine that the amount
of volume of information

00:17:19.099 --> 00:17:20.000
grows a lot.

00:17:20.000 --> 00:17:24.380
And so you can walk into any
program manager and systems

00:17:24.380 --> 00:17:27.260
engineers office
and see bookshelves

00:17:27.260 --> 00:17:30.500
full of binders, dozens
and dozens of binders

00:17:30.500 --> 00:17:33.860
with documents, thousands
and thousands of pages.

00:17:33.860 --> 00:17:36.380
And many of them are never read.

00:17:36.380 --> 00:17:38.240
That's the big issue.

00:17:38.240 --> 00:17:40.880
So that's been the
kind of way in which

00:17:40.880 --> 00:17:44.330
we've been doing system
engineering traditionally.

00:17:44.330 --> 00:17:47.990
So the idea here
is that in order

00:17:47.990 --> 00:17:51.893
to mitigate-- yes, Justice.

00:17:51.893 --> 00:17:58.759
AUDIENCE: [INAUDIBLE]

00:17:58.759 --> 00:18:00.550
OLIVER DE WECK: Phase
A, conceptual design.

00:18:00.550 --> 00:18:03.760
Phase B, preliminary
and detail design.

00:18:03.760 --> 00:18:08.260
Phase C is testing and launch.

00:18:08.260 --> 00:18:09.460
Phase E is operation.

00:18:09.460 --> 00:18:14.590
So usually not the same
people do conceptual design,

00:18:14.590 --> 00:18:16.180
preliminary design testing.

00:18:16.180 --> 00:18:18.580
So all the technical
data package,

00:18:18.580 --> 00:18:21.940
these artifacts have to be
transferred and handed off

00:18:21.940 --> 00:18:25.360
to new people who then
work on the next phase.

00:18:25.360 --> 00:18:27.850
That's what I mean by hand-offs.

00:18:27.850 --> 00:18:33.380
And, yeah, so the
idea is in order

00:18:33.380 --> 00:18:35.630
to mitigate some of
these disadvantages

00:18:35.630 --> 00:18:40.960
of natural language and
graphical description,

00:18:40.960 --> 00:18:42.940
there has been, and
this has been recognized

00:18:42.940 --> 00:18:47.710
for a long time, a need to
be more precise, perhaps more

00:18:47.710 --> 00:18:50.650
confining, but to
create languages

00:18:50.650 --> 00:18:56.120
that allow us to describe
systems much more precisely.

00:18:56.120 --> 00:18:58.690
And so I'll mention a
couple of the past efforts.

00:18:58.690 --> 00:19:02.090
And you can read about these.

00:19:02.090 --> 00:19:03.130
Each of these has--

00:19:03.130 --> 00:19:06.920
so I'll mention bond
graphs first, 1960.

00:19:06.920 --> 00:19:09.800
This was actually
invented here at MIT

00:19:09.800 --> 00:19:13.850
by a professor in
mechanical engineering.

00:19:13.850 --> 00:19:15.320
His name was Henry Paynter.

00:19:15.320 --> 00:19:18.320
Professor Paynter
created bond graphs.

00:19:18.320 --> 00:19:20.840
You can think of bond
graphs as block diagrams

00:19:20.840 --> 00:19:24.920
where different blocks have
ports or interfaces where

00:19:24.920 --> 00:19:28.160
information, material,
energy flows in and out.

00:19:28.160 --> 00:19:31.670
And you can compose a
system out of these blocks.

00:19:31.670 --> 00:19:33.860
These bond graphs
are essentially--

00:19:33.860 --> 00:19:38.030
and Narik will talk
about Modelica,

00:19:38.030 --> 00:19:40.970
which is sort of a modern
version of bond graphs.

00:19:40.970 --> 00:19:42.820
It has other features, too.

00:19:42.820 --> 00:19:46.430
But this has been
sort of one attempt.

00:19:46.430 --> 00:19:50.880
Another one that's very
well-known is IDEF, I-D-E-F,

00:19:50.880 --> 00:19:52.470
about 20 years later.

00:19:52.470 --> 00:19:56.630
This was created by the Air
Force, the US Air Force.

00:19:56.630 --> 00:19:58.640
And this is essentially
a description

00:19:58.640 --> 00:20:01.190
of systems that's very
functionally oriented.

00:20:01.190 --> 00:20:03.500
So it shows you what
functions are involved.

00:20:03.500 --> 00:20:05.000
And we saw one of
the descriptions

00:20:05.000 --> 00:20:07.790
was very functionally
oriented, and how

00:20:07.790 --> 00:20:12.660
the functions of the system
relate to each other.

00:20:12.660 --> 00:20:16.580
But generally these
system languages

00:20:16.580 --> 00:20:19.070
have not fully been deployed.

00:20:19.070 --> 00:20:21.890
Some organizations use
them, others don't use them.

00:20:21.890 --> 00:20:23.830
And the main reason
for that is twofold.

00:20:23.830 --> 00:20:27.750
First of all, some of these
languages were incomplete.

00:20:27.750 --> 00:20:30.530
They would focus only on
one aspect, like functions

00:20:30.530 --> 00:20:34.940
or the block nature of the
system, the block diagrams.

00:20:34.940 --> 00:20:38.040
And a lot of them
were not executable.

00:20:38.040 --> 00:20:40.580
So they would be graphical,
but you couldn't actually

00:20:40.580 --> 00:20:43.670
simulate and actually check
whether that description was

00:20:43.670 --> 00:20:45.800
complete or accurate.

00:20:45.800 --> 00:20:49.260
So since then-- and
the other thing,

00:20:49.260 --> 00:20:52.100
of course, important
is domain agnostic.

00:20:52.100 --> 00:20:55.490
So what I mean by this is that
the system modeling language

00:20:55.490 --> 00:20:59.360
should be applicable for any
kind of cyber physical system.

00:20:59.360 --> 00:21:03.590
Again, if you're designing
a spacecraft, an aircraft,

00:21:03.590 --> 00:21:06.410
medical device, any
kind of product,

00:21:06.410 --> 00:21:08.330
the language shouldn't
have to be adapted.

00:21:08.330 --> 00:21:10.970
The language sort of covers
all these applications.

00:21:10.970 --> 00:21:12.500
That's the idea.

00:21:12.500 --> 00:21:17.780
So whatever language it is that
you're using or developing,

00:21:17.780 --> 00:21:20.480
it has to have
these three things.

00:21:20.480 --> 00:21:22.200
Any language has
these three things.

00:21:22.200 --> 00:21:24.230
So the first is ontology.

00:21:24.230 --> 00:21:27.264
And I reference here
the Wikipedia articles

00:21:27.264 --> 00:21:27.930
on these things.

00:21:27.930 --> 00:21:31.010
Some of my colleagues-- in
academia it's a big debate

00:21:31.010 --> 00:21:35.120
is Wikipedia a legitimate source
of information or is it not?

00:21:35.120 --> 00:21:37.040
My position on
this is that it is.

00:21:37.040 --> 00:21:40.340
I think Wikipedia is
definitely not perfect,

00:21:40.340 --> 00:21:42.620
depending on what topic
you're looking at,

00:21:42.620 --> 00:21:45.440
but it's a sort of
self-correcting system.

00:21:45.440 --> 00:21:48.800
So I actually go to Wikipedia,
and then there's references.

00:21:48.800 --> 00:21:50.310
And you can dive deeper.

00:21:50.310 --> 00:21:51.890
So I give you the
Wikipedia links

00:21:51.890 --> 00:21:53.190
here for these three things.

00:21:53.190 --> 00:21:55.110
First, ontology.

00:21:55.110 --> 00:21:59.520
So ontology is a
very fancy word.

00:21:59.520 --> 00:22:01.430
What ontology actually is--

00:22:01.430 --> 00:22:03.820
Mark, why don't
you come up here?

00:22:03.820 --> 00:22:06.110
You're an instructor today.

00:22:06.110 --> 00:22:11.510
Ontology, fundamentally,
is describing the entities

00:22:11.510 --> 00:22:16.430
that are allowed to exist in
the language, subjects, nouns,

00:22:16.430 --> 00:22:21.870
adverbs, what are the objects,
the entities, that can exist.

00:22:21.870 --> 00:22:25.010
So it's a kind of
very abstract thing.

00:22:25.010 --> 00:22:28.310
But it's essentially the
library of words and objects

00:22:28.310 --> 00:22:31.850
that are allowed to
exist in that language

00:22:31.850 --> 00:22:35.240
and then how these entities
can be grouped perhaps

00:22:35.240 --> 00:22:37.290
in a hierarchy and subdivided.

00:22:37.290 --> 00:22:40.160
So it essentially
constrains the universe

00:22:40.160 --> 00:22:42.430
of things you can
describe in that language.

00:22:42.430 --> 00:22:45.860
The shorter, the smaller
your ontology is,

00:22:45.860 --> 00:22:48.740
the more confined the language.

00:22:48.740 --> 00:22:50.330
Semantics.

00:22:50.330 --> 00:22:57.800
Semantics is basically a branch
of science of philosophy, which

00:22:57.800 --> 00:23:01.430
is fundamentally assigning
meaning to those objects that

00:23:01.430 --> 00:23:03.380
are described in the ontology.

00:23:03.380 --> 00:23:06.980
And so the way
that we say this is

00:23:06.980 --> 00:23:10.360
that it's the relationship
between the signifiers,

00:23:10.360 --> 00:23:14.270
so the signifiers are
words, letters, symbols,

00:23:14.270 --> 00:23:16.070
graphical symbols.

00:23:16.070 --> 00:23:18.380
So how do we describe a
resistor, for example,

00:23:18.380 --> 00:23:21.080
in electrical engineering?

00:23:21.080 --> 00:23:22.010
A squiggly line.

00:23:22.010 --> 00:23:24.000
It's the zigzag line.

00:23:24.000 --> 00:23:27.140
Well, if you don't know
electrical engineering,

00:23:27.140 --> 00:23:28.850
you just see a squiggly line.

00:23:28.850 --> 00:23:30.650
It's meaningless to you.

00:23:30.650 --> 00:23:33.710
But if you know that
semantically that

00:23:33.710 --> 00:23:36.830
means that's a resistor,
that's the symbol for resistor,

00:23:36.830 --> 00:23:38.930
that's what we
mean by semantics.

00:23:38.930 --> 00:23:41.150
And then the third is syntax.

00:23:41.150 --> 00:23:42.090
What is syntax?

00:23:42.090 --> 00:23:46.340
It's the set of rules, the set
of principles and processes

00:23:46.340 --> 00:23:51.710
by which the objects or the
entities in the ontology

00:23:51.710 --> 00:23:54.320
can be combined to
build up higher level

00:23:54.320 --> 00:23:59.460
information, like sentences,
paragraphs, and so forth.

00:23:59.460 --> 00:24:02.900
And so that's essentially
the construction rules

00:24:02.900 --> 00:24:03.770
for the language.

00:24:03.770 --> 00:24:07.580
So every language has
these three things.

00:24:07.580 --> 00:24:10.040
So any questions
about this before we

00:24:10.040 --> 00:24:12.610
move into our first language?

00:24:12.610 --> 00:24:15.000
So we're going to give three
examples of system modeling

00:24:15.000 --> 00:24:18.090
languages, and you'll see the
similarities and differences.

00:24:18.090 --> 00:24:21.030
But as you see these
languages, keep in mind they

00:24:21.030 --> 00:24:25.990
all have ontology,
semantics, and syntax.

00:24:25.990 --> 00:24:27.330
Any questions about that?

00:24:30.270 --> 00:24:32.490
So OPM.

00:24:32.490 --> 00:24:34.200
Let me describe to you OPM.

00:24:34.200 --> 00:24:38.160
This is one of the
younger languages.

00:24:38.160 --> 00:24:41.970
And so OPM stands for
Object Process Methodology.

00:24:41.970 --> 00:24:47.970
And it was created by
Professor Dov Dori at Technion,

00:24:47.970 --> 00:24:49.620
a colleague of mine.

00:24:49.620 --> 00:24:52.920
Dov is essentially a computer
scientist by training.

00:24:52.920 --> 00:24:56.340
And you'll see the
heritage here of OPM.

00:24:56.340 --> 00:25:00.090
And the big news
here about OPM is

00:25:00.090 --> 00:25:02.580
OPM is not that well-known yet.

00:25:02.580 --> 00:25:06.870
If you ask around, not
too many people know OPM.

00:25:06.870 --> 00:25:09.060
But I predict that
in the next decade

00:25:09.060 --> 00:25:11.170
that will change very quickly.

00:25:11.170 --> 00:25:13.800
And one of the reasons
is that OPM was just

00:25:13.800 --> 00:25:17.590
now adopted as an ISO standard.

00:25:17.590 --> 00:25:19.800
And if you know ISO, the
International Standards

00:25:19.800 --> 00:25:22.160
Organization, they're
located in Geneva,

00:25:22.160 --> 00:25:24.910
it's a big deal to
become an ISO standard.

00:25:24.910 --> 00:25:26.880
It took like five years,
the whole process,

00:25:26.880 --> 00:25:28.830
with committees and reviews.

00:25:28.830 --> 00:25:32.280
And so the ISO
standard is actually--

00:25:32.280 --> 00:25:35.070
OPM was adopted
as an ISO standard

00:25:35.070 --> 00:25:39.630
as a means to describe and
develop other standards.

00:25:39.630 --> 00:25:43.380
So it's kind of a metalanguage
because, as you can imagine,

00:25:43.380 --> 00:25:45.870
when you read different
standards which, by the way,

00:25:45.870 --> 00:25:48.480
have a lot of
influence, they're also

00:25:48.480 --> 00:25:50.760
written in natural
language and graphics

00:25:50.760 --> 00:25:52.210
and lots of inconsistencies.

00:25:52.210 --> 00:25:55.170
So the idea is that future
ISO standards should

00:25:55.170 --> 00:25:59.310
be written using OPM such that
they're clear and consistent,

00:25:59.310 --> 00:26:01.420
and so forth.

00:26:01.420 --> 00:26:07.170
So the history here is
that if we go back further,

00:26:07.170 --> 00:26:09.960
UML, which is Unified Modeling
Language which I'm not

00:26:09.960 --> 00:26:12.810
going to talk about
today, is a software--

00:26:12.810 --> 00:26:15.060
this is a language that
was developed primarily

00:26:15.060 --> 00:26:18.780
for software engineering
to consistently describe

00:26:18.780 --> 00:26:22.080
use cases, to
consistently describe

00:26:22.080 --> 00:26:27.420
activity and flows in software,
the structure of software.

00:26:27.420 --> 00:26:29.400
But it's really
software centric.

00:26:29.400 --> 00:26:32.970
So from UML 2.0, we then
sort of branched off

00:26:32.970 --> 00:26:37.050
into SysML, which Mark
Chodas, who just joined us

00:26:37.050 --> 00:26:41.550
will talk about, and then OPM.

00:26:41.550 --> 00:26:43.740
So these are sort of
derivatives of UML.

00:26:43.740 --> 00:26:47.250
And there's a book, it's not
one of the mandatory books

00:26:47.250 --> 00:26:50.400
for this class, OPM 2002.

00:26:50.400 --> 00:26:52.170
If you're really
interested in OPM,

00:26:52.170 --> 00:26:54.420
I recommend you
invest in that book.

00:26:54.420 --> 00:26:57.420
It's really very well written.

00:26:57.420 --> 00:27:03.990
So let me give you an example
of how OPM can be used.

00:27:03.990 --> 00:27:06.720
So like we said, typical
product representations

00:27:06.720 --> 00:27:09.660
are sketches, engineering
drawings, or UML diagrams

00:27:09.660 --> 00:27:14.880
and software, but the need
for a unified representation.

00:27:14.880 --> 00:27:19.560
And fundamentally,
we have functions

00:27:19.560 --> 00:27:23.190
and then we have objects,
form and function, in systems.

00:27:23.190 --> 00:27:27.270
And so what we would like to
do, and the premise of OPM,

00:27:27.270 --> 00:27:33.120
is that we can show everything
in one diagram type,

00:27:33.120 --> 00:27:38.370
so the functions, the functional
attributes, the objects,

00:27:38.370 --> 00:27:40.830
and there's different
types of objects, operands,

00:27:40.830 --> 00:27:44.130
system components,
consumables, the attributes

00:27:44.130 --> 00:27:46.410
of those objects,
and then the links.

00:27:46.410 --> 00:27:48.000
And I'll show you
the different types

00:27:48.000 --> 00:27:51.000
of links between these
that exist in OPM.

00:27:51.000 --> 00:27:53.220
So it's a generic
modeling language.

00:27:53.220 --> 00:27:55.140
And it has been
successfully applied

00:27:55.140 --> 00:27:57.930
to system architecting
of complex products

00:27:57.930 --> 00:27:59.730
in different organizations.

00:27:59.730 --> 00:28:02.320
I'm going to try to give you
a pretty simple example here,

00:28:02.320 --> 00:28:03.820
which is a refrigerator.

00:28:03.820 --> 00:28:06.750
So we're going to
look at a small kind

00:28:06.750 --> 00:28:11.860
of household-level refrigerator
through the eyes of OPM.

00:28:11.860 --> 00:28:12.360
All right.

00:28:12.360 --> 00:28:16.050
So here's the basic
ontology of OPM.

00:28:16.050 --> 00:28:18.030
It's very, very simple.

00:28:18.030 --> 00:28:24.180
And that's the idea, is to have
as few objects, as few entities

00:28:24.180 --> 00:28:27.450
as possible in the
language to keep it simple.

00:28:27.450 --> 00:28:31.350
So the first one is
the idea of an object.

00:28:31.350 --> 00:28:32.790
What is an object?

00:28:32.790 --> 00:28:35.820
Objects are drawn
as these rectangles.

00:28:35.820 --> 00:28:39.840
Objects are defined
as entities that

00:28:39.840 --> 00:28:44.490
have the potential for stable,
unconditional existence

00:28:44.490 --> 00:28:47.160
for some positive
duration of time.

00:28:47.160 --> 00:28:49.710
And objects have
states within them.

00:28:49.710 --> 00:28:55.360
So what would be an
example of an object

00:28:55.360 --> 00:28:57.206
that we've talked about today?

00:28:57.206 --> 00:28:58.095
Go ahead.

00:28:58.095 --> 00:28:59.640
AUDIENCE: Maybe the sticky tape.

00:28:59.640 --> 00:29:01.230
OLIVIER DE WECK: Yeah, so
the sticky tape itself.

00:29:01.230 --> 00:29:01.950
That's an object.

00:29:01.950 --> 00:29:03.990
It exists unconditionally.

00:29:03.990 --> 00:29:05.010
It's there.

00:29:05.010 --> 00:29:09.040
And what's important is it
could be a physical object.

00:29:09.040 --> 00:29:11.280
So it has a physical existence.

00:29:11.280 --> 00:29:16.120
But it could also be a sort
of informational object.

00:29:16.120 --> 00:29:21.750
So for example, if you
have an idea or a vision,

00:29:21.750 --> 00:29:22.920
that's an object, too.

00:29:22.920 --> 00:29:25.560
It's not physical in that
sense, but it does exist

00:29:25.560 --> 00:29:29.010
as an informational object.

00:29:29.010 --> 00:29:30.600
What are states?

00:29:30.600 --> 00:29:31.860
Let's see at EPFL.

00:29:31.860 --> 00:29:34.500
What would be an example
of a state that's

00:29:34.500 --> 00:29:35.850
associated with an object?

00:29:43.770 --> 00:29:46.340
Yeah, that's OK.

00:29:46.340 --> 00:29:49.040
Can somebody give an
example of a state?

00:29:49.040 --> 00:29:50.515
AUDIENCE: Yeah.

00:29:50.515 --> 00:29:52.469
Rolled and unrolled
for the sticky tape.

00:29:52.469 --> 00:29:54.010
OLIVIER DE WECK:
Rolled and unrolled.

00:29:54.010 --> 00:29:55.310
Exactly.

00:29:55.310 --> 00:29:56.790
Or furled and unfurled.

00:29:56.790 --> 00:30:01.100
So that's kind of a binary state
that could be halfway unrolled,

00:30:01.100 --> 00:30:06.830
or the sticky tape is full of
flies, or it's kind of empty.

00:30:06.830 --> 00:30:10.190
Those would be describing the
object in terms of what state

00:30:10.190 --> 00:30:10.850
it is in.

00:30:10.850 --> 00:30:11.930
Exactly.

00:30:11.930 --> 00:30:14.930
So the form is then the
sum of all these objects.

00:30:17.560 --> 00:30:19.560
So that's one building block.

00:30:19.560 --> 00:30:21.800
And then processes
are the other.

00:30:21.800 --> 00:30:23.362
So what are processes?

00:30:23.362 --> 00:30:24.570
Oh, is there another example?

00:30:24.570 --> 00:30:25.190
Yeah, go ahead.

00:30:25.190 --> 00:30:26.481
AUDIENCE: May I ask a question?

00:30:26.481 --> 00:30:28.670
OLIVIER DE WECK: Is
this [INAUDIBLE]??

00:30:28.670 --> 00:30:28.970
AUDIENCE: Yeah,
it's [INAUDIBLE]..

00:30:28.970 --> 00:30:30.300
OLIVIER DE WECK: Go ahead.

00:30:30.300 --> 00:30:33.630
AUDIENCE: What do you mean
by positive duration of time?

00:30:33.630 --> 00:30:36.020
OLIVIER DE WECK: Well,
meaning that the object

00:30:36.020 --> 00:30:37.880
could be created.

00:30:37.880 --> 00:30:39.450
It didn't exist before.

00:30:39.450 --> 00:30:41.450
It's created, and it exists.

00:30:41.450 --> 00:30:43.640
And then it could
be destroyed again.

00:30:43.640 --> 00:30:46.520
It could disappear, or
it could be consumed.

00:30:46.520 --> 00:30:48.260
But it means that
the object needs

00:30:48.260 --> 00:30:53.000
to exist for a non-zero
period of time in order

00:30:53.000 --> 00:30:58.980
for it to be called
an object, so objects

00:30:58.980 --> 00:31:02.640
in the world that can
be described with OPM,

00:31:02.640 --> 00:31:06.610
fundamentally, objects
can be created.

00:31:06.610 --> 00:31:09.970
Objects can be modified,
particularly their states

00:31:09.970 --> 00:31:11.420
can be modified.

00:31:11.420 --> 00:31:14.610
And they can be
destroyed or consumed.

00:31:14.610 --> 00:31:16.120
That's basically it.

00:31:16.120 --> 00:31:18.760
That's a complete set.

00:31:18.760 --> 00:31:21.770
Does that make sense?

00:31:21.770 --> 00:31:24.510
So processes are--
what are processes?

00:31:24.510 --> 00:31:26.180
Processes are
really fundamentally

00:31:26.180 --> 00:31:27.290
different from objects.

00:31:27.290 --> 00:31:30.560
Processes are shown
as these ellipses.

00:31:30.560 --> 00:31:33.740
And they're the patterns
of transformation

00:31:33.740 --> 00:31:35.510
applied to one or more objects.

00:31:35.510 --> 00:31:37.430
And processes change states.

00:31:37.430 --> 00:31:42.170
So processes, unlike objects,
cannot exist on their own.

00:31:42.170 --> 00:31:46.220
Processes only make sense
if they're associated

00:31:46.220 --> 00:31:48.860
with at least one object.

00:31:48.860 --> 00:31:51.470
So processes are essentially--

00:31:51.470 --> 00:31:53.720
the functions that
we develop in systems

00:31:53.720 --> 00:31:57.500
are processes that transform
or create, destroy,

00:31:57.500 --> 00:31:59.440
or transform objects.

00:31:59.440 --> 00:32:02.910
So function emerges from
one or more processes.

00:32:02.910 --> 00:32:06.770
And then we have different links
between objects and processes.

00:32:06.770 --> 00:32:08.130
I'll show you two examples here.

00:32:08.130 --> 00:32:11.240
One is the arrow
with a pointy head.

00:32:11.240 --> 00:32:18.800
That could be a consumption
or production type link,

00:32:18.800 --> 00:32:23.450
or a link with this
little lollipop symbol.

00:32:23.450 --> 00:32:25.780
This is known as
an instrument link.

00:32:25.780 --> 00:32:29.690
And so the difference there
is that if an object is linked

00:32:29.690 --> 00:32:32.990
to a process using an arrow,
it means that something's

00:32:32.990 --> 00:32:34.460
happening to that object.

00:32:34.460 --> 00:32:37.370
It's being created, or
destroyed, or modified.

00:32:37.370 --> 00:32:40.610
If an object is linked to a
process using the lollipop

00:32:40.610 --> 00:32:43.130
symbol, the instrument
link, it means

00:32:43.130 --> 00:32:47.450
that in order for that process
to happen this object is

00:32:47.450 --> 00:32:49.310
needed, it's an instrument.

00:32:49.310 --> 00:32:51.350
But the object itself,
the instrument,

00:32:51.350 --> 00:32:55.200
does not get modified in
any way by the process.

00:32:55.200 --> 00:32:59.530
But the process couldn't happen
if that object didn't exist.

00:32:59.530 --> 00:33:01.180
Do you see the difference?

00:33:01.180 --> 00:33:03.490
And so one of the really,
I think, important things

00:33:03.490 --> 00:33:06.360
about OPM, but any
of the languages,

00:33:06.360 --> 00:33:10.000
is that every box,
every arrow, every link

00:33:10.000 --> 00:33:12.640
has precise semantics.

00:33:12.640 --> 00:33:14.917
And usually when
we kind of doodle,

00:33:14.917 --> 00:33:16.000
when we just think about--

00:33:16.000 --> 00:33:19.000
we put arrows and
links between boxes,

00:33:19.000 --> 00:33:20.920
we often don't
really deeply think

00:33:20.920 --> 00:33:23.990
when I put a link in here, what
does that link actually mean?

00:33:23.990 --> 00:33:25.780
What does that link imply?

00:33:25.780 --> 00:33:28.840
So when you do system modeling
using these languages,

00:33:28.840 --> 00:33:31.420
you become much,
much more precise.

00:33:31.420 --> 00:33:32.410
Yes, please.

00:33:32.410 --> 00:33:34.431
And would you push
the mic button?

00:33:34.431 --> 00:33:34.930
Yeah.

00:33:34.930 --> 00:33:36.400
Mark, go ahead.

00:33:36.400 --> 00:33:38.680
AUDIENCE: Can an object
be a process or a process

00:33:38.680 --> 00:33:39.520
be an object?

00:33:39.520 --> 00:33:40.780
OLIVIER DE WECK: No.

00:33:40.780 --> 00:33:44.580
AUDIENCE: So what
about if you have--

00:33:44.580 --> 00:33:48.670
I guess I'm thinking
in terms of if there's

00:33:48.670 --> 00:33:50.410
some process for
doing some procedure

00:33:50.410 --> 00:33:53.770
and like you're assembling
a satellite or whatnot.

00:33:53.770 --> 00:33:55.390
You need to modify that process.

00:33:55.390 --> 00:33:58.990
So how is that sort of
thing represented in OPM?

00:33:58.990 --> 00:34:01.870
OLIVIER DE WECK: The
process modifies objects,

00:34:01.870 --> 00:34:05.260
but processes cannot
modify other processes

00:34:05.260 --> 00:34:08.739
because processes are
fundamentally, in OPM,

00:34:08.739 --> 00:34:11.159
acting upon the objects.

00:34:11.159 --> 00:34:13.389
Now, processes can
invoke each other.

00:34:13.389 --> 00:34:16.010
So if there's a
sequence of processes--

00:34:16.010 --> 00:34:19.389
you have to do this assembly
step before this other assembly

00:34:19.389 --> 00:34:19.989
step--

00:34:19.989 --> 00:34:24.139
you can have what's
called an invocation link.

00:34:24.139 --> 00:34:26.540
But that's a logical
dependency between processes.

00:34:26.540 --> 00:34:30.348
But fundamentally, the processes
act through the objects in OPM.

00:34:30.348 --> 00:34:30.889
AUDIENCE: OK.

00:34:35.186 --> 00:34:37.310
OLIVIER DE WECK: So let's
go into some more detail.

00:34:37.310 --> 00:34:42.190
So at a high level when you
look at the economy, products--

00:34:42.190 --> 00:34:44.814
yes, go ahead.

00:34:44.814 --> 00:34:45.980
AUDIENCE: I have a question.

00:34:45.980 --> 00:34:50.788
Why create another language
and not just stick with UML?

00:34:50.788 --> 00:34:52.204
OLIVIER DE WECK:
So good question.

00:34:54.770 --> 00:34:59.630
So we'll talk about SysML,
which is very similar to UML.

00:34:59.630 --> 00:35:02.660
It's sort of generalized for
cyber-physical systems, not

00:35:02.660 --> 00:35:05.020
just software.

00:35:05.020 --> 00:35:08.630
So the reason that OPM
was created, because UML

00:35:08.630 --> 00:35:11.450
was found to be
somewhat too confining.

00:35:11.450 --> 00:35:14.690
This is more general
and also the idea

00:35:14.690 --> 00:35:20.030
of a unified representation, one
type of diagram and description

00:35:20.030 --> 00:35:22.460
for any application.

00:35:22.460 --> 00:35:27.110
So it's basically a kind of a
more general version of UML.

00:35:27.110 --> 00:35:29.600
But the other really
important thing about OPM

00:35:29.600 --> 00:35:32.480
is that objects and
processes are sort of--

00:35:32.480 --> 00:35:36.890
the processes are often in
object-oriented thinking.

00:35:36.890 --> 00:35:40.020
Processes are embedded
inside objects.

00:35:40.020 --> 00:35:43.700
And in OPM, the
processes have been

00:35:43.700 --> 00:35:47.640
emancipated to stand at
the same level as objects.

00:35:47.640 --> 00:35:49.640
Those are the main differences.

00:35:49.640 --> 00:35:53.140
So let me go in a
little bit more detail.

00:35:53.140 --> 00:35:58.340
So if you think about the
economy in general, goods

00:35:58.340 --> 00:36:04.100
and services, goods are objects,
and services are processes.

00:36:04.100 --> 00:36:13.730
So if you buy a new iPad, or a
new pencil, or whatever it is,

00:36:13.730 --> 00:36:16.070
you're actually
buying an object.

00:36:16.070 --> 00:36:17.390
You're purchasing an object.

00:36:17.390 --> 00:36:19.430
That's obvious.

00:36:19.430 --> 00:36:21.660
But why are you
purchasing that object?

00:36:24.380 --> 00:36:28.340
So let's say you're
buying a new tablet.

00:36:28.340 --> 00:36:30.400
You're buying the tablet.

00:36:30.400 --> 00:36:34.310
But why are you
buying the tablet?

00:36:34.310 --> 00:36:35.552
Sam, go ahead.

00:36:39.124 --> 00:36:40.540
AUDIENCE: You're
buying the tablet

00:36:40.540 --> 00:36:44.500
to perform an action for a
process on something else,

00:36:44.500 --> 00:36:45.450
to do something.

00:36:45.450 --> 00:36:45.670
OLIVIER DE WECK: Right.

00:36:45.670 --> 00:36:46.840
So what do tablets do?

00:36:46.840 --> 00:36:52.560
I mean, not stone tablets,
but modern tablets.

00:36:52.560 --> 00:36:56.530
AUDIENCE: They allow you to
work with software, communicate.

00:36:56.530 --> 00:36:59.260
OLIVIER DE WECK: Yeah, so
they're information processing.

00:36:59.260 --> 00:37:01.330
They're information-processing
devices.

00:37:01.330 --> 00:37:03.970
And there's an
argument with tablets

00:37:03.970 --> 00:37:05.660
are great for
consuming information.

00:37:05.660 --> 00:37:09.640
They're maybe not as good for
generating new information.

00:37:09.640 --> 00:37:13.490
So fundamentally, you're
purchasing the tablet,

00:37:13.490 --> 00:37:16.780
which is an object,
in order to be

00:37:16.780 --> 00:37:19.600
able to do information
processing and information

00:37:19.600 --> 00:37:20.680
consumption.

00:37:20.680 --> 00:37:22.630
So the process is then implicit.

00:37:25.210 --> 00:37:28.300
What's an example-- if you
purchase a service, what would

00:37:28.300 --> 00:37:30.002
be an example of a service?

00:37:33.306 --> 00:37:37.480
What would be an
example of a service?

00:37:37.480 --> 00:37:38.590
Let's see at EPFL.

00:37:38.590 --> 00:37:40.270
What would be an
example of a service

00:37:40.270 --> 00:37:41.270
that you could purchase?

00:37:47.249 --> 00:37:48.540
AUDIENCE: Going to the dentist.

00:37:48.540 --> 00:37:50.123
OLIVIER DE WECK:
Going to the dentist.

00:37:50.123 --> 00:37:53.852
Yeah, one of our
favorite things to do.

00:37:53.852 --> 00:37:55.060
Have you been there recently?

00:37:58.454 --> 00:38:00.280
AUDIENCE: Yeah, one month ago.

00:38:00.280 --> 00:38:02.340
OLIVIER DE WECK: So
I don't want to be--

00:38:02.340 --> 00:38:04.320
I don't want to
violate your privacy,

00:38:04.320 --> 00:38:09.710
but can you share with us
what happened at the dentist?

00:38:09.710 --> 00:38:11.460
AUDIENCE: It's the
yearly checkup.

00:38:11.460 --> 00:38:16.140
You have to check that
there's no hidden--

00:38:16.140 --> 00:38:19.207
I don't know how you call
that in English, carries?

00:38:19.207 --> 00:38:20.540
OLIVIER DE WECK: Yeah, cavities.

00:38:20.540 --> 00:38:21.315
Yeah.

00:38:21.315 --> 00:38:22.740
AUDIENCE: Yeah, cavities.

00:38:22.740 --> 00:38:25.470
Check that wisdom
tooth don't mess up

00:38:25.470 --> 00:38:28.710
what you've been working
on tirelessly when

00:38:28.710 --> 00:38:30.370
you were younger with braces.

00:38:30.370 --> 00:38:34.605
And [INAUDIBLE] get checked.

00:38:34.605 --> 00:38:35.730
OLIVIER DE WECK: Very good.

00:38:35.730 --> 00:38:37.985
So going to the dentist.

00:38:37.985 --> 00:38:39.810
The dentist provides
a service which

00:38:39.810 --> 00:38:42.810
is either checking
your teeth or filling

00:38:42.810 --> 00:38:45.240
cavities, which is a process.

00:38:45.240 --> 00:38:47.520
And all the objects, the
chair on which you sit,

00:38:47.520 --> 00:38:49.200
the instruments--

00:38:49.200 --> 00:38:53.130
I guess we still use gold
sometimes in some places--

00:38:53.130 --> 00:38:56.490
those are objects that are
used in the performance

00:38:56.490 --> 00:38:57.450
of the service.

00:38:57.450 --> 00:38:59.610
You see the relationship?

00:38:59.610 --> 00:39:02.700
So objects and processes
always come in pairs.

00:39:02.700 --> 00:39:04.650
Thank you for that example.

00:39:04.650 --> 00:39:08.670
So let me talk about the
links in OPM briefly.

00:39:08.670 --> 00:39:09.790
So there are two types.

00:39:09.790 --> 00:39:13.800
There's the structural links,
which link objects to objects.

00:39:13.800 --> 00:39:16.740
And we typically use arrows,
you know, is related to

00:39:16.740 --> 00:39:19.030
or we can tag these as well.

00:39:19.030 --> 00:39:21.960
So for example, something
powers something else.

00:39:21.960 --> 00:39:23.730
This is known as a tagged link.

00:39:23.730 --> 00:39:26.170
It suppresses the processes.

00:39:26.170 --> 00:39:29.370
And then there's these
triangles that are--

00:39:29.370 --> 00:39:31.800
essentially, there's a
kind of hierarchy implied

00:39:31.800 --> 00:39:34.910
there and slightly
different meanings.

00:39:34.910 --> 00:39:38.640
So the solid triangle
means decomposition.

00:39:38.640 --> 00:39:41.730
So the higher level
object is composed

00:39:41.730 --> 00:39:43.860
of lower-level objects.

00:39:43.860 --> 00:39:46.350
So that's, Mark, you
mentioned assembly, you know,

00:39:46.350 --> 00:39:49.230
are you creating the bus of
the spacecraft and it has

00:39:49.230 --> 00:39:51.090
a whole bunch of stuff in it?

00:39:51.090 --> 00:39:53.640
Well, you would use
this filled in triangle

00:39:53.640 --> 00:39:55.440
to show that decomposition.

00:39:55.440 --> 00:39:59.260
The second example is the
characterization link.

00:39:59.260 --> 00:40:02.820
So this is essentially
relating an attribute

00:40:02.820 --> 00:40:05.150
to its kind of master object.

00:40:05.150 --> 00:40:07.290
Specialization
and generalization

00:40:07.290 --> 00:40:09.150
is the empty triangle.

00:40:09.150 --> 00:40:12.390
And then this funny symbol
here is instantiation.

00:40:12.390 --> 00:40:17.544
So essentially, you
have a general object.

00:40:17.544 --> 00:40:18.960
And then you can
instantiate that.

00:40:18.960 --> 00:40:22.560
So I have two children.

00:40:22.560 --> 00:40:25.140
I have two children,
which is general.

00:40:25.140 --> 00:40:27.760
And there's two
instantiations of them.

00:40:27.760 --> 00:40:29.130
One of them is called Gabrielle.

00:40:29.130 --> 00:40:30.629
And one of them is
called Christian.

00:40:30.629 --> 00:40:32.550
And they're actual people.

00:40:32.550 --> 00:40:35.880
So that's the idea
of instantiation.

00:40:35.880 --> 00:40:37.740
Processes.

00:40:37.740 --> 00:40:41.520
Processes are these
patterns of transformation.

00:40:41.520 --> 00:40:42.600
They're tricky.

00:40:42.600 --> 00:40:45.570
Processes are trickier to
understand than the objects

00:40:45.570 --> 00:40:48.060
because we cannot hold
or touch a process.

00:40:48.060 --> 00:40:49.730
It's fleeting.

00:40:49.730 --> 00:40:53.520
And the creating change
or destruction of objects

00:40:53.520 --> 00:40:55.770
is what processes do.

00:40:55.770 --> 00:40:58.650
They rely on at least
one object in what

00:40:58.650 --> 00:41:00.770
we call the preprocess set.

00:41:00.770 --> 00:41:03.690
A process transforms
at least one object.

00:41:03.690 --> 00:41:06.840
And the time is implied.

00:41:06.840 --> 00:41:09.330
So processes take
along a timeline.

00:41:09.330 --> 00:41:12.180
And in terms of the
description, in English

00:41:12.180 --> 00:41:14.670
we use the so-called
Gerund form.

00:41:14.670 --> 00:41:17.220
So all the processes,
there's some examples

00:41:17.220 --> 00:41:22.050
on the right side, use
the "ing" form of a verb.

00:41:22.050 --> 00:41:25.190
So we can then put
these together, objects

00:41:25.190 --> 00:41:26.550
and processes.

00:41:26.550 --> 00:41:29.010
So here's an example
of a machine.

00:41:29.010 --> 00:41:31.890
This happens to be like a
printer or copy machine.

00:41:31.890 --> 00:41:33.470
It has a main switch.

00:41:33.470 --> 00:41:36.290
The main switch has an
attribute called Main Switch

00:41:36.290 --> 00:41:39.680
State, which can be on or off.

00:41:39.680 --> 00:41:42.800
The process of
switching transforms,

00:41:42.800 --> 00:41:46.490
in this case, the Main
Switch State from on to off.

00:41:46.490 --> 00:41:48.290
Or we could go the other way.

00:41:48.290 --> 00:41:52.280
And in order for this to
happen, we have here--

00:41:52.280 --> 00:41:54.691
this is actually slightly
different than the instrument

00:41:54.691 --> 00:41:55.190
link.

00:41:55.190 --> 00:41:57.350
This is a filled
in lollipop, which

00:41:57.350 --> 00:41:59.300
is known as an agent link.

00:41:59.300 --> 00:42:01.580
So the operator
is an active agent

00:42:01.580 --> 00:42:04.070
to carry out the
switching process which

00:42:04.070 --> 00:42:07.970
changes the main switch state
from on to off or off to on,

00:42:07.970 --> 00:42:13.430
and the Main Switch State is an
attribute of the main switch.

00:42:13.430 --> 00:42:14.720
So transporting.

00:42:14.720 --> 00:42:16.310
This is another example.

00:42:16.310 --> 00:42:20.600
Transporting changes the state
of a person from being here,

00:42:20.600 --> 00:42:27.260
Location A, to being
there, Location B.

00:42:27.260 --> 00:42:34.950
So there are seven-- huh,
coincidence, seven, seven--

00:42:34.950 --> 00:42:37.890
object process links in OPM.

00:42:37.890 --> 00:42:42.660
So P changes-- the process
changes the object,

00:42:42.660 --> 00:42:46.800
say from State A to B. That's
the example we just looked at.

00:42:46.800 --> 00:42:48.090
You can actually hide that.

00:42:48.090 --> 00:42:51.810
If you're really not interested
in all the states and details,

00:42:51.810 --> 00:42:53.070
you hide the states.

00:42:53.070 --> 00:42:54.600
You don't want to see them.

00:42:54.600 --> 00:42:56.400
And then you can
replace that with what's

00:42:56.400 --> 00:43:00.540
called the affectee link,
which is this two-sided arrow.

00:43:00.540 --> 00:43:03.450
And all you know is
that this process

00:43:03.450 --> 00:43:05.670
is affecting that object.

00:43:05.670 --> 00:43:07.500
And it's a two-sided arrow.

00:43:07.500 --> 00:43:11.730
But you don't know exactly how
but you know it's affected.

00:43:11.730 --> 00:43:15.900
A resultee link-- so this is an
arrow pointing from the process

00:43:15.900 --> 00:43:17.280
to the object--

00:43:17.280 --> 00:43:20.130
means that the process
of transporting

00:43:20.130 --> 00:43:23.160
produces emissions that
weren't there before.

00:43:23.160 --> 00:43:24.930
So that's a resultee link.

00:43:24.930 --> 00:43:29.160
But the process of transporting
requires or consumes energy.

00:43:29.160 --> 00:43:31.440
So the arrow is
pointing from energy

00:43:31.440 --> 00:43:36.060
into the transporting process
because it's being consumed.

00:43:36.060 --> 00:43:37.560
I did mention the agent link.

00:43:37.560 --> 00:43:39.570
So there's an
operator of a vehicle.

00:43:39.570 --> 00:43:43.470
And when we talk about
autonomously driving vehicles,

00:43:43.470 --> 00:43:46.380
a big topic right now,
actually, it was cool.

00:43:46.380 --> 00:43:50.520
At EPA this summer, there's
the autonomous shuttle

00:43:50.520 --> 00:43:52.260
on the campus, the
electric shuttle.

00:43:52.260 --> 00:43:53.850
Did anybody take that?

00:43:53.850 --> 00:43:56.125
Did you guys try that
shuttle this summer?

00:43:56.125 --> 00:43:57.000
AUDIENCE: [INAUDIBLE]

00:43:57.000 --> 00:43:57.630
OLIVIER DE WECK: Yeah?

00:43:57.630 --> 00:43:58.320
Did you like it?

00:44:01.032 --> 00:44:01.990
AUDIENCE: No, I didn't.

00:44:01.990 --> 00:44:04.570
But a friend is working
in this kind of shuttle,

00:44:04.570 --> 00:44:09.280
like sitting for hours waiting
for people [INAUDIBLE]..

00:44:09.280 --> 00:44:11.200
OLIVIER DE WECK:
So fundamentally, I

00:44:11.200 --> 00:44:14.460
mean, if you want to think
of this in OPM language,

00:44:14.460 --> 00:44:18.100
a driverless vehicle is
basically eliminating this,

00:44:18.100 --> 00:44:21.580
no longer needing an
operator with an agent link

00:44:21.580 --> 00:44:24.430
and replacing this with
a piece of software,

00:44:24.430 --> 00:44:28.670
which would be an
instrument link.

00:44:28.670 --> 00:44:31.100
So the instrument, the
transporting process

00:44:31.100 --> 00:44:32.330
requires a vehicle.

00:44:32.330 --> 00:44:35.850
And then we have what's
known as a conditional link.

00:44:35.850 --> 00:44:39.020
So this process can only
occur if this object

00:44:39.020 --> 00:44:40.950
is in that particular state.

00:44:40.950 --> 00:44:43.940
So this example here,
obviously, ignores the existence

00:44:43.940 --> 00:44:46.040
of credit cards.

00:44:46.040 --> 00:44:49.920
So you can do the purchasing.

00:44:49.920 --> 00:44:55.230
The process of purchasing is
conditional upon the state

00:44:55.230 --> 00:44:59.347
of the object money being
in a state of enough

00:44:59.347 --> 00:45:00.305
for doing the purchase.

00:45:03.030 --> 00:45:07.150
So here's an example of a
little bit more complicated.

00:45:07.150 --> 00:45:11.830
This is a Level 0 OPM diagram
of a car, of a vehicle.

00:45:11.830 --> 00:45:13.650
So you can see in
the upper right is

00:45:13.650 --> 00:45:16.650
sort of a sketch of a vehicle.

00:45:16.650 --> 00:45:18.680
And it has these
different attributes.

00:45:18.680 --> 00:45:23.190
ED is engine displacement,
height, ground clearance,

00:45:23.190 --> 00:45:25.860
overall length, wheelbase.

00:45:25.860 --> 00:45:28.740
There's a trailer here
with a towing capacity.

00:45:28.740 --> 00:45:31.470
So the way the way you
would interpret this

00:45:31.470 --> 00:45:34.080
is that we have a
transporting process.

00:45:34.080 --> 00:45:37.710
That's our master, sort of
the highest level process.

00:45:37.710 --> 00:45:41.670
And it changes the attribute
location for driver passengers

00:45:41.670 --> 00:45:45.640
and cargo from A to B.
And that's, fundamentally,

00:45:45.640 --> 00:45:49.330
where the value is for
the owner of the vehicle.

00:45:49.330 --> 00:45:52.000
And then we can zoom in to
the transporting process

00:45:52.000 --> 00:45:54.850
and look at subprocesses,
towing, propelling,

00:45:54.850 --> 00:45:55.960
and housing.

00:45:55.960 --> 00:45:58.420
And if you think about what
a vehicle does at the highest

00:45:58.420 --> 00:46:04.870
level, it protects you, it
houses you, and it propels you.

00:46:04.870 --> 00:46:07.810
And then you can break
those into more detail.

00:46:07.810 --> 00:46:11.050
And then on the left side
here we have, essentially,

00:46:11.050 --> 00:46:13.180
the elements of form.

00:46:13.180 --> 00:46:15.340
So the automobile,
which is an instrument

00:46:15.340 --> 00:46:17.410
of the transporting
process, can be

00:46:17.410 --> 00:46:20.770
decomposed into its major
subsystems, powertrain,

00:46:20.770 --> 00:46:22.740
chassis, body, wheels.

00:46:22.740 --> 00:46:24.700
And each of those
are characterized--

00:46:24.700 --> 00:46:26.530
you see those attribute links--

00:46:26.530 --> 00:46:31.630
characterized by things
like fuel capacity,

00:46:31.630 --> 00:46:33.190
engine displacement.

00:46:33.190 --> 00:46:36.520
This is the design domain
we talked about last time.

00:46:36.520 --> 00:46:37.810
Ground clearance.

00:46:37.810 --> 00:46:39.910
And so those are the
design variables.

00:46:39.910 --> 00:46:41.800
Those are the parts
and assemblies.

00:46:41.800 --> 00:46:43.990
And then on the right
side, the processes,

00:46:43.990 --> 00:46:48.460
the internal processes can also
be characterized by performance

00:46:48.460 --> 00:46:51.670
or functional attributes
like towing capacity,

00:46:51.670 --> 00:46:54.460
fuel economy, acceleration.

00:46:54.460 --> 00:46:58.000
PV stands for Passenger
Volume and cargo volume.

00:46:58.000 --> 00:47:00.760
And those are things when you're
comparing different vehicles

00:47:00.760 --> 00:47:03.040
to purchase, those
are the things

00:47:03.040 --> 00:47:05.020
you would compare
vehicles against.

00:47:05.020 --> 00:47:07.330
So they're the internal
functions and then

00:47:07.330 --> 00:47:09.490
the functional attributes.

00:47:09.490 --> 00:47:12.970
And then up here there
is the fuel and emissions

00:47:12.970 --> 00:47:15.520
and safety-related
issues, which that's often

00:47:15.520 --> 00:47:18.700
where the governments
intervene and then regulate.

00:47:18.700 --> 00:47:23.800
And this is sort of a highest
level OPM of a vehicle.

00:47:23.800 --> 00:47:25.750
And then if you want
to see more detail,

00:47:25.750 --> 00:47:27.940
you would start drilling
down into these.

00:47:27.940 --> 00:47:30.160
And you'd have multiple
levels of these,

00:47:30.160 --> 00:47:31.750
like a hierarchy
of these diagrams.

00:47:31.750 --> 00:47:33.210
Yeah.

00:47:33.210 --> 00:47:35.620
AUDIENCE: So here,
what is the use

00:47:35.620 --> 00:47:39.290
of the-- or the meaning
of the open arrows?

00:47:39.290 --> 00:47:42.100
And it looks like there's a
couple of different arrows

00:47:42.100 --> 00:47:44.920
here than what we had
in the other diagram.

00:47:44.920 --> 00:47:48.064
OLIVIER DE WECK: Are you
talking about these guys?

00:47:48.064 --> 00:47:48.667
AUDIENCE: No.

00:47:48.667 --> 00:47:50.000
OLIVIER DE WECK: Oh, these here.

00:47:50.000 --> 00:47:50.330
Yeah.

00:47:50.330 --> 00:47:50.955
AUDIENCE: Yeah.

00:47:50.955 --> 00:47:52.840
OLIVIER DE WECK: So
it's just a visual

00:47:52.840 --> 00:47:55.250
represent-- there's no
distinction on the arrows

00:47:55.250 --> 00:47:56.780
whether they're
filled in or empty.

00:47:56.780 --> 00:47:58.730
That's just a kind
of graphical thing.

00:47:58.730 --> 00:47:59.230
Yeah.

00:48:01.870 --> 00:48:04.300
So one of the--

00:48:04.300 --> 00:48:04.810
yes.

00:48:04.810 --> 00:48:08.260
Veronica, do you
want to push the--

00:48:08.260 --> 00:48:09.850
AUDIENCE: How
would you represent

00:48:09.850 --> 00:48:14.530
a process that creates
kind of a temporary state?

00:48:14.530 --> 00:48:17.210
So if you're saying this
is acted on an object,

00:48:17.210 --> 00:48:19.070
and this changes the
form of the object

00:48:19.070 --> 00:48:21.580
but the object will ultimately
return to its original state

00:48:21.580 --> 00:48:24.550
kind of absent of a
reversing process,

00:48:24.550 --> 00:48:28.270
if it's a natural tendency
for the object to return,

00:48:28.270 --> 00:48:30.305
how would you
represent that change?

00:48:30.305 --> 00:48:31.930
Would you need to
break it down as kind

00:48:31.930 --> 00:48:34.402
of a subprocess
within the object?

00:48:34.402 --> 00:48:35.360
OLIVIER DE WECK: Right.

00:48:35.360 --> 00:48:38.240
So I mean, and sometimes
there's multiple,

00:48:38.240 --> 00:48:41.110
there's non-uniqueness in sort
of representing the same thing.

00:48:41.110 --> 00:48:43.540
But there's one
process that brings you

00:48:43.540 --> 00:48:44.679
to the temporary state.

00:48:44.679 --> 00:48:45.220
AUDIENCE: OK.

00:48:45.220 --> 00:48:45.790
OLIVIER DE WECK:
And then there would

00:48:45.790 --> 00:48:48.310
be a restoring process
that restores you back

00:48:48.310 --> 00:48:49.390
to the original state.

00:48:49.390 --> 00:48:52.390
AUDIENCE: Does the process
have to be a separate plan

00:48:52.390 --> 00:48:53.810
within the system?

00:48:53.810 --> 00:48:56.770
Because there are certain
objects that have a tendency--

00:48:56.770 --> 00:48:59.050
I'm thinking primarily of
kind of chemical states

00:48:59.050 --> 00:49:01.601
where reactions would
happen naturally.

00:49:01.601 --> 00:49:03.100
It's kind of a
specific thing, but I

00:49:03.100 --> 00:49:05.110
was thinking about how you
might model different systems.

00:49:05.110 --> 00:49:06.568
And I was thinking
about the engine

00:49:06.568 --> 00:49:09.550
of the car, just kind of how
things might naturally return.

00:49:09.550 --> 00:49:12.580
So do you have to describe
the process explicitly

00:49:12.580 --> 00:49:17.650
if it's not something that's
inherently designed in,

00:49:17.650 --> 00:49:18.930
if it's kind of a--

00:49:18.930 --> 00:49:21.550
if it will happen anyway.

00:49:21.550 --> 00:49:23.380
OLIVIER DE WECK: I
think, I want to say you

00:49:23.380 --> 00:49:24.699
have to explicitly define that.

00:49:24.699 --> 00:49:25.240
AUDIENCE: OK.

00:49:25.240 --> 00:49:28.840
OLIVIER DE WECK: So if it's a
man-made process, so to speak,

00:49:28.840 --> 00:49:30.990
then that's a process
you want to happen.

00:49:30.990 --> 00:49:33.910
And then if the restoring
it back to some other state

00:49:33.910 --> 00:49:37.080
is a natural process,
well, it exists.

00:49:37.080 --> 00:49:40.360
So it will restore the
system to a prior state.

00:49:40.360 --> 00:49:42.280
That process would also
have to be modeled.

00:49:42.280 --> 00:49:43.450
AUDIENCE: Is there a
distinction between how

00:49:43.450 --> 00:49:45.940
you would indicate a man-made
process or a natural process?

00:49:45.940 --> 00:49:46.960
OLIVIER DE WECK:
Not fundamentally.

00:49:46.960 --> 00:49:47.350
AUDIENCE: OK.

00:49:47.350 --> 00:49:48.724
OLIVIER DE WECK:
And in fact, OPM

00:49:48.724 --> 00:49:51.200
has been applied to modeling
how a cell functions.

00:49:51.200 --> 00:49:53.260
So there's been some
pretty recent work on--

00:49:53.260 --> 00:49:56.770
cells are incredibly-- the
biological engineering is just

00:49:56.770 --> 00:49:58.114
really complex.

00:49:58.114 --> 00:49:59.530
So there's some
really recent work

00:49:59.530 --> 00:50:03.100
on describing even the
RNA and cell division,

00:50:03.100 --> 00:50:04.569
using very much this language.

00:50:04.569 --> 00:50:05.110
AUDIENCE: OK.

00:50:05.110 --> 00:50:06.651
OLIVIER DE WECK: So
it doesn't matter

00:50:06.651 --> 00:50:09.857
whether it's an artificial
process or a natural process.

00:50:09.857 --> 00:50:10.690
AUDIENCE: Thank you.

00:50:10.690 --> 00:50:12.070
OLIVIER DE WECK: Let me
go a couple more minutes,

00:50:12.070 --> 00:50:13.486
and then we'll
take a short break.

00:50:13.486 --> 00:50:16.480
And then we'll talk
about SysML and Modelica.

00:50:16.480 --> 00:50:19.120
So the key thing
in OPM is there's

00:50:19.120 --> 00:50:21.550
only one type of diagram.

00:50:21.550 --> 00:50:23.290
And there's also
natural language

00:50:23.290 --> 00:50:24.820
that gets auto-generated.

00:50:24.820 --> 00:50:27.130
And I'll show you this
very quickly in the tool.

00:50:27.130 --> 00:50:29.620
So as you can imagine,
as you're working

00:50:29.620 --> 00:50:32.560
on real systems, these
diagrams, if you'd showed them

00:50:32.560 --> 00:50:37.210
on one sort of level, you'd have
thousands of objects and links.

00:50:37.210 --> 00:50:38.830
It would be a mess.

00:50:38.830 --> 00:50:41.050
So how does OPM
handle complexity?

00:50:41.050 --> 00:50:43.090
There's three
fundamental mechanisms.

00:50:43.090 --> 00:50:45.880
One is known as
folding and unfolding.

00:50:45.880 --> 00:50:46.780
What does that mean?

00:50:46.780 --> 00:50:50.980
It's basically related
to the structure.

00:50:50.980 --> 00:50:54.760
So folding/unfolding means
that higher level objects, you

00:50:54.760 --> 00:50:58.430
can show the decomposition of
the objects or you can hide it.

00:50:58.430 --> 00:51:00.610
That's known as
folding and unfolding.

00:51:00.610 --> 00:51:04.810
Then the second one is
in-zooming or out-zooming.

00:51:04.810 --> 00:51:09.160
And so here's an example of
a process and an instrument

00:51:09.160 --> 00:51:12.150
and an affectee that's
affected by the process.

00:51:12.150 --> 00:51:17.000
And I want to know, what are the
subprocesses in that process?

00:51:17.000 --> 00:51:19.100
So you can zoom
into this process,

00:51:19.100 --> 00:51:22.030
and it will expose
the subprocesses

00:51:22.030 --> 00:51:23.560
that are happening inside.

00:51:23.560 --> 00:51:24.860
That's known as in-zooming.

00:51:24.860 --> 00:51:28.544
And then going back the other
way is called out-zooming.

00:51:28.544 --> 00:51:30.460
And then the third one
I've already mentioned,

00:51:30.460 --> 00:51:33.630
which is that states
can be expressed

00:51:33.630 --> 00:51:37.020
or suppressed or hidden
depending on your interest

00:51:37.020 --> 00:51:40.970
and what states of the
system you want to look at.

00:51:40.970 --> 00:51:44.510
So here's the sort of Level
0 OPM of our refrigerator.

00:51:44.510 --> 00:51:46.940
I said that was kind
of our case study.

00:51:46.940 --> 00:51:50.600
So how does the refrigerator
work at the sort of--

00:51:50.600 --> 00:51:53.690
Level 0, that's what the
stakeholder, what the customer

00:51:53.690 --> 00:51:54.650
sees.

00:51:54.650 --> 00:51:56.480
Don't care about the
details of what's

00:51:56.480 --> 00:51:58.670
happening in the refrigerator.

00:51:58.670 --> 00:52:00.530
So we have food--

00:52:00.530 --> 00:52:03.800
and we'll get back to
this I think next week

00:52:03.800 --> 00:52:06.920
in the kind of creativity
concept generation.

00:52:06.920 --> 00:52:10.640
Why do we have
refrigerators fundamentally?

00:52:10.640 --> 00:52:14.180
If you've heard this
before, you keep quiet.

00:52:14.180 --> 00:52:15.650
Maybe EPFL.

00:52:15.650 --> 00:52:17.406
Why do we have refrigerators?

00:52:21.970 --> 00:52:22.520
Any ideas?

00:52:27.210 --> 00:52:28.920
Go ahead.

00:52:28.920 --> 00:52:30.150
AUDIENCE: Keep food cold.

00:52:30.150 --> 00:52:33.930
OLIVIER DE WECK: Yeah, well,
if you're a beer drinker,

00:52:33.930 --> 00:52:36.240
you want cold beer.

00:52:36.240 --> 00:52:39.000
But if you really
think about it deeply,

00:52:39.000 --> 00:52:41.490
that's not really
the primary reason.

00:52:41.490 --> 00:52:46.470
The primary reason is this
state change, their shelf life.

00:52:46.470 --> 00:52:48.840
So the primary reason why
you have refrigerators

00:52:48.840 --> 00:52:53.100
is to extend the shelf
life of the food.

00:52:53.100 --> 00:52:57.450
So speaking as a systems
architect, system engineer,

00:52:57.450 --> 00:53:03.830
a refrigerator is a food
spoilage rate reduction device.

00:53:03.830 --> 00:53:04.760
You see that?

00:53:04.760 --> 00:53:08.390
So the attribute of the
food is the shelf life,

00:53:08.390 --> 00:53:11.830
and we're going to extend
the shelf life of the food.

00:53:11.830 --> 00:53:14.300
If you think about it
sort of architecturally,

00:53:14.300 --> 00:53:16.190
that's why we have
refrigerators.

00:53:16.190 --> 00:53:19.280
But I agree with you
on the cold beer.

00:53:19.280 --> 00:53:21.920
We all agree we want
cold beer, not warm beer.

00:53:21.920 --> 00:53:23.060
So you're right.

00:53:23.060 --> 00:53:24.710
You're right, too.

00:53:24.710 --> 00:53:27.200
So the refrigerator
essentially is an instrument

00:53:27.200 --> 00:53:30.020
of extending the
food shelf life.

00:53:30.020 --> 00:53:32.510
So the food is the operand.

00:53:32.510 --> 00:53:34.310
The food is the operand.

00:53:34.310 --> 00:53:36.140
The extending of
shelf life is what

00:53:36.140 --> 00:53:38.900
we call the primary
value delivering process.

00:53:38.900 --> 00:53:40.610
That's where the value is.

00:53:40.610 --> 00:53:44.270
The refrigerator itself
is the product system.

00:53:44.270 --> 00:53:48.440
And then the operator sets
the thermostat setting

00:53:48.440 --> 00:53:51.200
at which temperature the
refrigerator should be.

00:53:51.200 --> 00:53:53.870
And then here we have the
primary operating process,

00:53:53.870 --> 00:53:58.340
which is what allows us to keep
the temperature of the food

00:53:58.340 --> 00:53:59.690
at that level.

00:53:59.690 --> 00:54:02.450
And in order to do this, we
consume electrical power.

00:54:02.450 --> 00:54:04.220
We produce waste heat.

00:54:04.220 --> 00:54:07.820
And we also require, or
we convect that waste heat

00:54:07.820 --> 00:54:11.580
to the exterior air at
a certain temperature.

00:54:11.580 --> 00:54:14.573
How well do refrigerators
work in a vacuum chamber?

00:54:20.000 --> 00:54:21.610
They don't.

00:54:21.610 --> 00:54:22.180
They don't.

00:54:22.180 --> 00:54:24.220
There's no way
to-- well, I guess

00:54:24.220 --> 00:54:25.930
you could radiate the
heat a little bit.

00:54:25.930 --> 00:54:28.170
But they're not going
to work very well.

00:54:28.170 --> 00:54:29.740
You're not going
to have conduction

00:54:29.740 --> 00:54:32.200
because you're sort of in the
middle of the vacuum chamber.

00:54:32.200 --> 00:54:33.490
You're not going
to have convection.

00:54:33.490 --> 00:54:34.750
So you only have radiation.

00:54:34.750 --> 00:54:37.040
And that's not going
to work very well.

00:54:37.040 --> 00:54:42.310
So the exterior air is important
for the refrigerator to work.

00:54:42.310 --> 00:54:43.720
So then you say, well, OK.

00:54:43.720 --> 00:54:44.560
That's fine.

00:54:44.560 --> 00:54:45.580
I buy that.

00:54:45.580 --> 00:54:48.520
But now I want to really
know, how does it really work?

00:54:48.520 --> 00:54:50.050
So you say operating.

00:54:50.050 --> 00:54:51.820
The refrigerator is operating.

00:54:51.820 --> 00:54:54.760
But I want to do
in-zooming and understand,

00:54:54.760 --> 00:54:56.740
how is it operating?

00:54:56.740 --> 00:55:00.070
So what's the key
to refrigeration?

00:55:00.070 --> 00:55:03.182
What's the magic word
there, or two magic words?

00:55:03.182 --> 00:55:07.232
AUDIENCE: [INAUDIBLE]

00:55:07.232 --> 00:55:08.940
OLIVIER DE WECK: Yeah,
that's part of it.

00:55:08.940 --> 00:55:11.720
That's just a sliver of it.

00:55:11.720 --> 00:55:13.220
Heat exchange is part of it.

00:55:13.220 --> 00:55:17.570
So the magic word
is Carnot cycle.

00:55:17.570 --> 00:55:20.690
So here's a little graphic
that sort of gets into it.

00:55:20.690 --> 00:55:25.490
So the Carnot cycle is actually
a thermodynamic concept

00:55:25.490 --> 00:55:30.220
where you're compressing
essentially a refrigerant.

00:55:30.220 --> 00:55:34.340
A coolant is being
compressed, absorbs the heat

00:55:34.340 --> 00:55:39.470
from the inside and then expands
and condenses and radiates that

00:55:39.470 --> 00:55:42.410
or convects that
heat to the outside.

00:55:42.410 --> 00:55:43.295
So here's a--

00:55:43.295 --> 00:55:45.710
I don't know if you remember
your thermodynamics.

00:55:45.710 --> 00:55:48.230
This is a classic PV diagram.

00:55:48.230 --> 00:55:50.780
You've got the four legs
of the Carnot cycle.

00:55:50.780 --> 00:55:52.730
And actually, what's
really nice here--

00:55:52.730 --> 00:55:55.340
so we're going through
this counter-clockwise.

00:55:55.340 --> 00:55:59.060
What's really nice about it is
that every leg of the Carnot

00:55:59.060 --> 00:56:01.970
cycle is one of our processes.

00:56:01.970 --> 00:56:07.040
So compressing is this leg
here from D to B. Condensing

00:56:07.040 --> 00:56:10.010
is from B to A.
Expanding from A to E.

00:56:10.010 --> 00:56:12.740
And then evaporation
happens from E to D.

00:56:12.740 --> 00:56:17.930
So the Carnot cycle
can be decomposed

00:56:17.930 --> 00:56:20.630
into four subprocesses.

00:56:20.630 --> 00:56:23.870
These are the internal
processes in the system

00:56:23.870 --> 00:56:26.280
that are governed by physics.

00:56:26.280 --> 00:56:29.120
So if we take that
operating process

00:56:29.120 --> 00:56:31.370
that we looked at
before, we can actually

00:56:31.370 --> 00:56:35.460
zoom in and see the
subprocesses emerging.

00:56:35.460 --> 00:56:38.720
And so in cooling we have
those four expanding,

00:56:38.720 --> 00:56:40.910
evaporating,
compressing, condensing.

00:56:40.910 --> 00:56:42.886
But I'm adding the
absorbing process,

00:56:42.886 --> 00:56:44.510
which is that the
heat then needs to be

00:56:44.510 --> 00:56:47.360
absorbed by the exterior air.

00:56:47.360 --> 00:56:48.770
We have to power the device.

00:56:48.770 --> 00:56:51.080
You can decompose
that into grounding,

00:56:51.080 --> 00:56:52.850
protecting, supplying.

00:56:52.850 --> 00:56:55.820
Regulation, keeping
it at the set point,

00:56:55.820 --> 00:56:59.750
you can decompose that process
into sensing, switching,

00:56:59.750 --> 00:57:02.030
and setting the set point.

00:57:02.030 --> 00:57:03.470
And then we have
supporting, which

00:57:03.470 --> 00:57:06.950
is we need to be opening and
closing the refrigerator,

00:57:06.950 --> 00:57:09.490
retaining it, and then
connecting all the pieces.

00:57:09.490 --> 00:57:14.120
So at Level -1, we had
one process at Level 0,

00:57:14.120 --> 00:57:15.470
which was operating.

00:57:15.470 --> 00:57:17.630
The refrigerator was operating.

00:57:17.630 --> 00:57:20.105
And then as we
zoom into Level -1,

00:57:20.105 --> 00:57:23.450
four processes appear,
powering, regulating, cooling,

00:57:23.450 --> 00:57:24.560
and supporting.

00:57:24.560 --> 00:57:28.850
And then at Level -2,
we have 15 subprocesses.

00:57:28.850 --> 00:57:33.700
So this is sort of
a view at Level -1,

00:57:33.700 --> 00:57:37.160
our four subprocesses,
cooling, powering, regulating,

00:57:37.160 --> 00:57:38.210
supporting.

00:57:38.210 --> 00:57:40.880
And then we can zoom in more.

00:57:40.880 --> 00:57:44.870
So here's the general idea, and
we've looked at many systems

00:57:44.870 --> 00:57:48.500
over the years, that most
cyber-physical systems--

00:57:48.500 --> 00:57:51.680
or it says optomechanical
here, but I really

00:57:51.680 --> 00:57:55.670
mean it more generally-- have
this kind of OPM structure.

00:57:55.670 --> 00:57:58.130
On the right side,
we have the output

00:57:58.130 --> 00:58:00.290
that the customer,
the stakeholder cares

00:58:00.290 --> 00:58:02.160
about, the operand.

00:58:02.160 --> 00:58:04.890
We have a set of
specialized processes,

00:58:04.890 --> 00:58:07.610
and these can be often
organized in a cascade.

00:58:07.610 --> 00:58:09.230
And then we have
supporting processes,

00:58:09.230 --> 00:58:11.870
like powering,
connecting, controlling,

00:58:11.870 --> 00:58:15.920
that provide support for
the specialized processes.

00:58:15.920 --> 00:58:22.920
Most systems that we've seen
have this generic architecture.

00:58:22.920 --> 00:58:24.740
How do you generate an OPM?

00:58:24.740 --> 00:58:27.050
Fundamentally, you
can do a top-down.

00:58:27.050 --> 00:58:29.280
So you start with
your stakeholders.

00:58:29.280 --> 00:58:31.610
That's what we did
in the first lecture.

00:58:31.610 --> 00:58:33.980
Where's the value?

00:58:33.980 --> 00:58:35.780
You start thinking
about requirements,

00:58:35.780 --> 00:58:40.050
what functions, how well the
functions should be performed.

00:58:40.050 --> 00:58:41.570
And you sort of go down.

00:58:41.570 --> 00:58:43.520
Or if you already
have a system, you

00:58:43.520 --> 00:58:46.010
can actually reverse
engineer that system

00:58:46.010 --> 00:58:49.370
and from bottom
up, like we started

00:58:49.370 --> 00:58:52.160
doing for the Mr. Sticky,
and that's fundamentally

00:58:52.160 --> 00:58:54.890
reverse engineering.

00:58:54.890 --> 00:58:59.360
So just for time, I'm
going to skip this demo.

00:58:59.360 --> 00:59:01.610
But what I will do is
I will post a video.

00:59:01.610 --> 00:59:04.490
I'm going to make a little
video with the OPCAT demo

00:59:04.490 --> 00:59:07.970
and post that to Stellar so
you can sort of watch that.

00:59:07.970 --> 00:59:11.690
So this is one of the--
it's still not super mature,

00:59:11.690 --> 00:59:13.640
but it's a Java-based
program called

00:59:13.640 --> 00:59:18.890
OPCAT that allows you to
generate object process

00:59:18.890 --> 00:59:23.180
diagrams in a
computer-supported environment

00:59:23.180 --> 00:59:27.080
and store them in an XML
format, and so forth.

00:59:27.080 --> 00:59:29.030
It allows you to
create a hierarchy.

00:59:29.030 --> 00:59:32.880
And the other thing that's very
cool, it autogenerates text.

00:59:32.880 --> 00:59:36.710
So the text is called OPL,
Object Process Language.

00:59:36.710 --> 00:59:40.140
And right now you can go from
the graphics to the text,

00:59:40.140 --> 00:59:42.290
but you can't go the other way.

00:59:42.290 --> 00:59:44.240
So they're complete sentences.

00:59:44.240 --> 00:59:47.150
It's not like an exciting
novel when you read it.

00:59:47.150 --> 00:59:50.430
But it is semantically precise.

00:59:50.430 --> 00:59:53.940
So we're going to
switch to SysML.

00:59:53.940 --> 00:59:55.770
We're going to take
a very short break.

00:59:55.770 --> 00:59:57.850
Are there any
questions about OPM?

00:59:57.850 --> 00:59:59.610
In the system
architecture class,

00:59:59.610 --> 01:00:02.970
we spend like five,
six lectures on OPM

01:00:02.970 --> 01:00:05.280
and you get to do
detailed exercises.

01:00:05.280 --> 01:00:07.750
We kind of don't have time
for this in this class.

01:00:07.750 --> 01:00:10.120
But hopefully you've
seen what it is.

01:00:10.120 --> 01:00:13.380
And if I've whetted
your appetite for OPM,

01:00:13.380 --> 01:00:16.190
then the goal has been met.

01:00:16.190 --> 01:00:17.853
Any questions about OPM?

01:00:21.030 --> 01:00:22.770
Is it pretty clear?

01:00:22.770 --> 01:00:23.270
All right.

01:00:23.270 --> 01:00:26.160
So let's take-- yes.

01:00:26.160 --> 01:00:28.520
AUDIENCE: Compared to
Modelica, because I've

01:00:28.520 --> 01:00:31.800
seen one of the
links that OPM is

01:00:31.800 --> 01:00:33.680
just for describing
the system, though.

01:00:33.680 --> 01:00:37.200
It's not for making
calculations or simulations.

01:00:37.200 --> 01:00:38.880
OLIVIER DE WECK: That's correct.

01:00:38.880 --> 01:00:40.710
The latest versions
of OPM you can

01:00:40.710 --> 01:00:42.760
do like a logical simulation.

01:00:42.760 --> 01:00:46.170
So you can say, OK, this process
enables and does this state,

01:00:46.170 --> 01:00:48.000
so it's kind of a
discrete logical.

01:00:48.000 --> 01:00:53.070
But usually it's not used for
any mathematical calculations.

01:00:53.070 --> 01:00:56.760
The purpose of OPM is really
to support conceptual design,

01:00:56.760 --> 01:00:58.020
early conceptual design.

01:00:58.020 --> 01:00:59.006
That's correct.

01:01:03.260 --> 01:01:04.130
Mark.

01:01:04.130 --> 01:01:07.590
So just a couple of
words about Mark.

01:01:07.590 --> 01:01:10.830
He's a doctoral student right
now in the Space Systems Lab.

01:01:10.830 --> 01:01:15.300
He's been working a lot on
an instrument called REXIS.

01:01:15.300 --> 01:01:17.600
I guess you're the chief
system engineer for REXIS.

01:01:17.600 --> 01:01:18.600
MARK CHODAS: Yeah, yeah.

01:01:18.600 --> 01:01:20.190
OLIVIER DE WECK: And
that was also the topic

01:01:20.190 --> 01:01:21.300
of his master's thesis.

01:01:21.300 --> 01:01:24.940
So Mark really knows
what he's talking about.

01:01:24.940 --> 01:01:27.250
He knows SysML quite well.

01:01:27.250 --> 01:01:29.287
And thanks for doing this.

01:01:29.287 --> 01:01:30.870
MARK CHODAS: So let
me start by giving

01:01:30.870 --> 01:01:33.270
kind of a high-level
overview of what SysML is

01:01:33.270 --> 01:01:34.410
and what it aims to do.

01:01:34.410 --> 01:01:37.170
So it's similar to OPM,
but there are a couple

01:01:37.170 --> 01:01:39.080
important differences.

01:01:39.080 --> 01:01:42.360
SysML, as Olly said, it
kind of is an extension

01:01:42.360 --> 01:01:44.625
or inherits a lot from UML.

01:01:44.625 --> 01:01:48.510
And its aim is to really
provide a language that

01:01:48.510 --> 01:01:50.760
enables you to capture
all the different aspects

01:01:50.760 --> 01:01:54.270
of information about
a system in one place.

01:01:54.270 --> 01:01:56.146
And this concept
of Single Source

01:01:56.146 --> 01:01:58.520
Of Truth is something that
I'll kind of try and emphasize

01:01:58.520 --> 01:01:59.670
during my presentation.

01:01:59.670 --> 01:02:01.710
The idea is if all
your information

01:02:01.710 --> 01:02:05.770
is in this one model, then
communication is easy.

01:02:05.770 --> 01:02:08.675
There's no ambiguity
between versions.

01:02:08.675 --> 01:02:10.050
Everyone knows
where to go to get

01:02:10.050 --> 01:02:13.150
the most up-to-date and
correct piece of information.

01:02:13.150 --> 01:02:17.140
So that's one of the
emphases of SysML.

01:02:17.140 --> 01:02:20.460
SysML is a graphical
language, similar to OPM.

01:02:20.460 --> 01:02:22.260
It's defined in terms
of diagram types

01:02:22.260 --> 01:02:23.550
that I'll go into in a second.

01:02:23.550 --> 01:02:25.380
It has more than just
one diagram type,

01:02:25.380 --> 01:02:27.000
as compared to OPM.

01:02:27.000 --> 01:02:28.470
But basically it
aims to do things

01:02:28.470 --> 01:02:31.170
like capture functional
behavioral models,

01:02:31.170 --> 01:02:34.144
capture performance models,
capture the structural topology

01:02:34.144 --> 01:02:35.810
of your system, the
parts of your system

01:02:35.810 --> 01:02:37.690
and how they're
all interconnected,

01:02:37.690 --> 01:02:39.450
and any other engineering
analysis model

01:02:39.450 --> 01:02:41.520
is one of the big
emphases with SysML,

01:02:41.520 --> 01:02:44.130
is integration with
external analysis tools.

01:02:44.130 --> 01:02:48.410
So if you have a thermal tool, a
structural tool, an electronics

01:02:48.410 --> 01:02:50.250
tool, or something
like that, integrating

01:02:50.250 --> 01:02:52.560
this informational,
descriptional model

01:02:52.560 --> 01:02:55.550
with that analysis
model and enabling,

01:02:55.550 --> 01:02:58.230
making it easy to
transfer information

01:02:58.230 --> 01:03:00.379
from your description model
to your analysis model,

01:03:00.379 --> 01:03:02.670
do an analysis, and then
incorporate those results back

01:03:02.670 --> 01:03:05.670
into your descriptive
model is one of the things

01:03:05.670 --> 01:03:07.360
that SysML really is all about.

01:03:07.360 --> 01:03:08.943
Then another thing,
another difference

01:03:08.943 --> 01:03:11.340
compared to SysML from
OPM is it incorporates

01:03:11.340 --> 01:03:12.967
requirements pretty explicitly.

01:03:12.967 --> 01:03:15.300
And that's one of the other
areas that people are really

01:03:15.300 --> 01:03:17.970
interested in is if you have
good modeling of requirements,

01:03:17.970 --> 01:03:20.340
what sort of information can
you glean about your system

01:03:20.340 --> 01:03:22.791
that you couldn't otherwise?

01:03:22.791 --> 01:03:26.607
How do I advance the slide?

01:03:26.607 --> 01:03:29.450
Oh, there we go.

01:03:29.450 --> 01:03:32.420
So as I said, SysML is
composed of diagrams.

01:03:32.420 --> 01:03:34.100
I'll go into in a
second kind of what

01:03:34.100 --> 01:03:35.790
each diagram, what all
the diagram types are

01:03:35.790 --> 01:03:37.164
and what kind of
their intent is.

01:03:37.164 --> 01:03:39.249
But here's kind of a
high-level overview.

01:03:39.249 --> 01:03:41.040
It might be a little
bit difficult to read.

01:03:41.040 --> 01:03:42.623
So at the top you
have a system model.

01:03:42.623 --> 01:03:45.350
You have requirements,
diagrams, behavior, structure

01:03:45.350 --> 01:03:46.579
and parametrics.

01:03:46.579 --> 01:03:48.120
Within requirements,
there's actually

01:03:48.120 --> 01:03:50.300
a specific requirements
diagram that's

01:03:50.300 --> 01:03:52.040
supposed to represent
the relationship

01:03:52.040 --> 01:03:53.539
between requirements
in your system.

01:03:53.539 --> 01:03:55.060
And I'll show an
example of that.

01:03:55.060 --> 01:03:58.310
In behavior, there are
diagrams to describe

01:03:58.310 --> 01:04:01.310
kind of the activity of your
system, the sequence of events

01:04:01.310 --> 01:04:02.577
that may happen.

01:04:02.577 --> 01:04:04.160
There's a state
machine diagram if you

01:04:04.160 --> 01:04:05.810
want to model your
system as a state

01:04:05.810 --> 01:04:08.950
and transition between those
states, things like that.

01:04:08.950 --> 01:04:11.124
In the structure,
there's diagrams

01:04:11.124 --> 01:04:13.040
that go over the
decomposition of your system.

01:04:13.040 --> 01:04:13.873
What is your system?

01:04:13.873 --> 01:04:15.860
And what parts make
up your system?

01:04:15.860 --> 01:04:19.700
Both the logical decomposition
and the physical decomposition.

01:04:19.700 --> 01:04:21.230
And then there's topology.

01:04:21.230 --> 01:04:23.022
How are they all connected?

01:04:23.022 --> 01:04:24.980
What are the characteristics
of the interfaces?

01:04:24.980 --> 01:04:26.180
Things like that.

01:04:26.180 --> 01:04:28.700
And then parametrics,
which is kind

01:04:28.700 --> 01:04:32.660
of adding constraints and
numbers to all these things,

01:04:32.660 --> 01:04:34.160
whether they be
logical constraints,

01:04:34.160 --> 01:04:36.140
mathematical constraints,
things like that.

01:04:36.140 --> 01:04:39.980
Similar to OPM, SysML has no
built-in analysis capabilities,

01:04:39.980 --> 01:04:45.389
so you can't like run a model or
calculate an equation in SysML.

01:04:45.389 --> 01:04:46.430
You can't really do that.

01:04:46.430 --> 01:04:53.470
But very frequently the
tools that implement system

01:04:53.470 --> 01:04:55.320
that I'll show
you have that kind

01:04:55.320 --> 01:04:57.380
of analysis capability
built into the tools,

01:04:57.380 --> 01:04:58.630
as opposed to the language.

01:04:58.630 --> 01:05:03.270
So you can do things like use a
parametric diagram with a bunch

01:05:03.270 --> 01:05:05.760
of equations to create
a system of equations

01:05:05.760 --> 01:05:08.066
that you then can solve,
whether it be in the tool,

01:05:08.066 --> 01:05:09.690
or you can move it
to an external tool,

01:05:09.690 --> 01:05:11.856
like Mathematica or something
and solve it, and then

01:05:11.856 --> 01:05:14.910
bring that information
back into your system.

01:05:14.910 --> 01:05:19.920
You also can do kind of
sequence-based computation.

01:05:19.920 --> 01:05:22.957
If you have an activity
diagram that says first you

01:05:22.957 --> 01:05:24.540
have to build this
part of your system

01:05:24.540 --> 01:05:25.590
and then this part
of your system,

01:05:25.590 --> 01:05:27.630
there's things in sequence,
things in parallel.

01:05:27.630 --> 01:05:30.840
You can run simulations like
that where it's all about,

01:05:30.840 --> 01:05:32.370
have you done
everything you need

01:05:32.370 --> 01:05:34.170
to do to get to the next step?

01:05:34.170 --> 01:05:36.510
Things in a more logical
flow, as opposed to actually

01:05:36.510 --> 01:05:38.760
mathematical equations, you can
do those sorts of computations

01:05:38.760 --> 01:05:39.260
as well.

01:05:41.830 --> 01:05:45.040
One note is that these diagrams,
although they are the main way

01:05:45.040 --> 01:05:48.130
to define your system and
interface with the model,

01:05:48.130 --> 01:05:49.990
are not the model themselves.

01:05:49.990 --> 01:05:53.080
So you can create
links between diagrams.

01:05:53.080 --> 01:05:56.110
If an element shows up in
one diagram and that element

01:05:56.110 --> 01:05:59.362
shows up in another diagram,
that's the same element.

01:05:59.362 --> 01:06:00.820
If you make changes
in one diagram,

01:06:00.820 --> 01:06:02.740
that's going to propagate
to all your diagrams.

01:06:02.740 --> 01:06:04.281
So there's kind of
a database backend

01:06:04.281 --> 01:06:06.957
to this whole model
that encompasses

01:06:06.957 --> 01:06:07.790
all the information.

01:06:07.790 --> 01:06:10.280
So instead of having a bunch
of isolated block diagrams,

01:06:10.280 --> 01:06:12.730
they're really just views
into this model that's

01:06:12.730 --> 01:06:14.920
hidden in a backend database.

01:06:20.480 --> 01:06:23.354
So we'll talk a little bit
about the applications of SysML.

01:06:23.354 --> 01:06:24.770
First is requirements
engineering.

01:06:24.770 --> 01:06:27.160
As I said, when you can
explicitly model requirements

01:06:27.160 --> 01:06:29.540
in the relationship between
requirements and your system,

01:06:29.540 --> 01:06:31.280
you can do a lot more.

01:06:31.280 --> 01:06:32.990
The way that it's
typically done nowadays

01:06:32.990 --> 01:06:34.317
is with tons of documents--

01:06:34.317 --> 01:06:36.650
I'm not sure if you've ever
actually developed a system,

01:06:36.650 --> 01:06:39.200
but there's an ungodly
amount of documents.

01:06:39.200 --> 01:06:41.180
I've experienced that firsthand.

01:06:41.180 --> 01:06:42.209
It's a real pain.

01:06:42.209 --> 01:06:44.000
There are tools like
DOORS that will enable

01:06:44.000 --> 01:06:46.010
you to link requirements
to other requirements,

01:06:46.010 --> 01:06:48.540
and things like that that help
you manage your requirements.

01:06:48.540 --> 01:06:50.290
But what if you had
a really explicit tie

01:06:50.290 --> 01:06:52.040
between your requirements
and your system?

01:06:52.040 --> 01:06:53.420
You can actually
represent in SysML.

01:06:53.420 --> 01:06:55.170
And I'll show you a
little bit about this.

01:06:55.170 --> 01:06:57.860
You can represent in SysML a
textural requirement, you know,

01:06:57.860 --> 01:07:00.560
the mass of your system must
be less than 5 kilograms,

01:07:00.560 --> 01:07:01.580
or something like that.

01:07:01.580 --> 01:07:03.121
You can tie that
requirement directly

01:07:03.121 --> 01:07:04.790
to the mass property
of your system.

01:07:04.790 --> 01:07:05.660
You can [INAUDIBLE].

01:07:05.660 --> 01:07:08.059
You can start
building constraints.

01:07:08.059 --> 01:07:10.100
Your requirements aren't
just textual statements,

01:07:10.100 --> 01:07:12.210
they're actually constraints
upon properties of your system.

01:07:12.210 --> 01:07:14.840
Those are the types of things
you can start to do with SysML.

01:07:14.840 --> 01:07:16.298
Do you have a question?

01:07:16.298 --> 01:07:25.690
AUDIENCE: [INAUDIBLE]

01:07:25.690 --> 01:07:26.440
MARK CHODAS: Yeah.

01:07:26.440 --> 01:07:28.981
Yeah, so that isn't something
that's built into the language.

01:07:28.981 --> 01:07:31.030
But that is something
you can do with--

01:07:31.030 --> 01:07:33.809
basically there's a whole API.

01:07:33.809 --> 01:07:35.350
And you can interface
with the model.

01:07:35.350 --> 01:07:37.150
I'll show you this,
actually, in my demo.

01:07:37.150 --> 01:07:39.890
But you can build in rules and
constraints that say, check,

01:07:39.890 --> 01:07:42.240
for example, that all my
requirements, at least how

01:07:42.240 --> 01:07:43.840
they've been defined,
are satisfied.

01:07:43.840 --> 01:07:44.830
You can run that
check, and it will

01:07:44.830 --> 01:07:46.510
tell you have they
been satisfied or not.

01:07:46.510 --> 01:07:48.301
And that's something
that's really powerful

01:07:48.301 --> 01:07:51.060
that you can't really do with
existing kind of techniques.

01:07:51.060 --> 01:07:51.560
Yeah.

01:07:51.560 --> 01:07:53.185
AUDIENCE: Thank you.

01:07:53.185 --> 01:07:58.170
And can you also, for
example, requirement changes,

01:07:58.170 --> 01:08:00.460
like the master system
has to be this much,

01:08:00.460 --> 01:08:03.370
as opposed to this much, then
would it go through and check

01:08:03.370 --> 01:08:06.400
until you have to now look
at this, this, and this,

01:08:06.400 --> 01:08:07.910
and then that affect like-

01:08:07.910 --> 01:08:10.300
MARK CHODAS: So you're
getting down in the weeds.

01:08:10.300 --> 01:08:13.362
That's something that would
be awesome if you could do.

01:08:13.362 --> 01:08:15.070
That really-- again,
that's not something

01:08:15.070 --> 01:08:17.260
that SysML enables
you to do natively.

01:08:17.260 --> 01:08:19.479
But it gives you the
language and the syntax

01:08:19.479 --> 01:08:21.499
to be able to write
queries that give you

01:08:21.499 --> 01:08:22.540
that type of information.

01:08:22.540 --> 01:08:24.859
That's kind of where the
cutting edge is right now is,

01:08:24.859 --> 01:08:25.569
can we do that?

01:08:25.569 --> 01:08:28.240
Can we get that type of
information from a SysML model?

01:08:28.240 --> 01:08:29.979
That's something I'm really
interested in for my PhD

01:08:29.979 --> 01:08:30.399
thesis.

01:08:30.399 --> 01:08:31.982
So yeah, that's
something that I think

01:08:31.982 --> 01:08:34.086
is possible and would
be really great to have

01:08:34.086 --> 01:08:35.710
in the development
process of a system.

01:08:38.665 --> 01:08:40.790
So the next bullet here is
on a system description.

01:08:40.790 --> 01:08:43.010
So actually one of the
fundamental questions

01:08:43.010 --> 01:08:46.069
is, how do you describe
a domain-specific system

01:08:46.069 --> 01:08:47.240
within SysML?

01:08:47.240 --> 01:08:50.000
I'll show you that SysML
has a pretty strong notion

01:08:50.000 --> 01:08:51.920
of inheritance, and
classes, and things like.

01:08:51.920 --> 01:08:53.580
It's object-oriented.

01:08:53.580 --> 01:08:55.670
And so one of the questions is--

01:08:55.670 --> 01:08:56.689
I'm in the space system.

01:08:56.689 --> 01:08:59.330
So how do you describe
a spacecraft in SysML?

01:08:59.330 --> 01:09:00.410
SysML is very general.

01:09:00.410 --> 01:09:02.460
But how do you
actually represent,

01:09:02.460 --> 01:09:04.910
for example, a CNDH
system in SysML?

01:09:04.910 --> 01:09:09.680
What are the types of attributes
that are typically found?

01:09:09.680 --> 01:09:11.180
How do you represent that?

01:09:11.180 --> 01:09:12.859
How does it interface with
other parts of your system?

01:09:12.859 --> 01:09:13.858
Those type of questions.

01:09:13.858 --> 01:09:15.800
That's another active
area of research,

01:09:15.800 --> 01:09:17.450
domain-specific modeling.

01:09:17.450 --> 01:09:19.910
And then finally, as
I said, integration

01:09:19.910 --> 01:09:21.127
with external analysis tools.

01:09:21.127 --> 01:09:23.210
So there's quite a lot of
papers in the literature

01:09:23.210 --> 01:09:26.930
about going from a
SysML model to MATLAB

01:09:26.930 --> 01:09:32.680
to SDK to Thermal Desktop,
external modeling tools,

01:09:32.680 --> 01:09:35.180
taking that information out of
the model, doing an analysis,

01:09:35.180 --> 01:09:36.939
putting it back in the model.

01:09:36.939 --> 01:09:38.960
And actually, I
think there I was

01:09:38.960 --> 01:09:42.620
going to talk about Simscape,
which is a kind of analysis

01:09:42.620 --> 01:09:43.950
tool, external analysis tool.

01:09:43.950 --> 01:09:45.270
And there's actually
been papers written on,

01:09:45.270 --> 01:09:47.620
how do you take SysML
information from a SysML model,

01:09:47.620 --> 01:09:49.210
pull it into
Simscape process it,

01:09:49.210 --> 01:09:50.890
and put it back in the model?

01:09:54.360 --> 01:09:56.680
So let's talk
about the diagrams.

01:09:56.680 --> 01:09:59.010
There are nine types
of diagrams in SysML.

01:09:59.010 --> 01:10:01.174
And I'll try and just give
you a brief explanation

01:10:01.174 --> 01:10:01.840
of what they do.

01:10:01.840 --> 01:10:03.370
I won't go into the
syntax for all of them

01:10:03.370 --> 01:10:05.536
because there's quite a bit
of detail in the syntax.

01:10:05.536 --> 01:10:07.969
But I'll show you some
examples of a couple of them.

01:10:07.969 --> 01:10:09.260
So we'll go from left to right.

01:10:09.260 --> 01:10:12.410
So there's two main classes,
behavior and structure,

01:10:12.410 --> 01:10:14.050
similar to OPM.

01:10:14.050 --> 01:10:17.620
In the behavior diagram, in
the behavior diagram category

01:10:17.620 --> 01:10:19.900
you have activity
diagrams, which basically

01:10:19.900 --> 01:10:21.610
represent flows of activities.

01:10:21.610 --> 01:10:24.850
So you do this, then you
do this, then you do this.

01:10:24.850 --> 01:10:26.890
Those can be tied
to system elements.

01:10:26.890 --> 01:10:29.830
If this system element has this
sort of function or property

01:10:29.830 --> 01:10:32.710
or performs this operation on
another part of the system,

01:10:32.710 --> 01:10:35.050
you can represent
that link as well.

01:10:35.050 --> 01:10:39.680
There's a sequence diagram,
which is more about logical

01:10:39.680 --> 01:10:40.180
ordering.

01:10:40.180 --> 01:10:43.732
So if you have, for example, a
multi-threaded software system,

01:10:43.732 --> 01:10:45.190
and you have
different threads that

01:10:45.190 --> 01:10:48.262
may need different other
threads to communicate with them

01:10:48.262 --> 01:10:50.470
or finish their computation
before that, that way you

01:10:50.470 --> 01:10:51.850
can execute things
like that, you

01:10:51.850 --> 01:10:56.830
can do that sort of interfacing
between different threads

01:10:56.830 --> 01:10:59.680
of activities in a
sequence diagram.

01:10:59.680 --> 01:11:03.070
This is one of the diagram
types that was kind of inherited

01:11:03.070 --> 01:11:03.950
directly from UML.

01:11:03.950 --> 01:11:05.740
So there is a very
kind of strong software

01:11:05.740 --> 01:11:06.990
element to that diagram.

01:11:11.400 --> 01:11:13.072
There's a state machine diagram.

01:11:13.072 --> 01:11:15.030
So obviously, state
machines are very powerful.

01:11:15.030 --> 01:11:16.410
If your system has
various states,

01:11:16.410 --> 01:11:18.030
if things in your system
have various states,

01:11:18.030 --> 01:11:20.160
you can represent that in
a state machine diagram

01:11:20.160 --> 01:11:22.830
and then talk about, what are
the criteria for transitioning

01:11:22.830 --> 01:11:23.490
between states?

01:11:23.490 --> 01:11:26.550
What would trigger or cause
a transition between states?

01:11:26.550 --> 01:11:28.724
What are guards that
must be met before you

01:11:28.724 --> 01:11:29.640
can transition states?

01:11:29.640 --> 01:11:30.348
Things like that.

01:11:30.348 --> 01:11:32.850
That's where you represent
the state machine diagram.

01:11:32.850 --> 01:11:36.000
These type of diagrams are very
powerful for describing things

01:11:36.000 --> 01:11:38.220
like concept of operations.

01:11:38.220 --> 01:11:39.900
So there has been some work--

01:11:39.900 --> 01:11:42.390
I did an internship at JPL
a couple of summers ago.

01:11:42.390 --> 01:11:44.670
And they were trying to
build up this capability

01:11:44.670 --> 01:11:46.980
to model a concept of
operations for a spacecraft.

01:11:46.980 --> 01:11:50.096
So what are all the power
modes of everything?

01:11:50.096 --> 01:11:51.720
What are the time--
you know, it spends

01:11:51.720 --> 01:11:53.344
this amount of time
in this power mode,

01:11:53.344 --> 01:11:54.899
then it transitions here.

01:11:54.899 --> 01:11:56.940
For example, I can give
an orbit of a spacecraft.

01:11:56.940 --> 01:11:58.315
That's sort of
the thing that you

01:11:58.315 --> 01:12:01.200
can do with this set
of behavior diagrams.

01:12:01.200 --> 01:12:02.340
And then use case analysis.

01:12:02.340 --> 01:12:04.770
Again, it's mostly focused
on early concept development,

01:12:04.770 --> 01:12:05.527
stakeholders.

01:12:05.527 --> 01:12:07.110
How do they interface
with the system?

01:12:07.110 --> 01:12:08.790
Where do they derive value?

01:12:08.790 --> 01:12:11.002
How does the user
interact with the system?

01:12:11.002 --> 01:12:11.710
Things like that.

01:12:11.710 --> 01:12:14.610
That's where you put
a use case diagram.

01:12:14.610 --> 01:12:18.010
Going over to structure,
the block definition diagram

01:12:18.010 --> 01:12:21.070
is where you define the
structure of your system.

01:12:21.070 --> 01:12:23.250
So the logical or
physical decomposition,

01:12:23.250 --> 01:12:24.714
I'll show you an
example of this.

01:12:24.714 --> 01:12:26.130
So if your system
is a spacecraft,

01:12:26.130 --> 01:12:28.350
it has various
subsystems, if you

01:12:28.350 --> 01:12:30.600
want to decompose it logically
as a thermal subsystem,

01:12:30.600 --> 01:12:33.211
a structure subsystem,
ADCS subsystem,

01:12:33.211 --> 01:12:35.460
things like that, you can
also decompose it physically

01:12:35.460 --> 01:12:38.590
so your spacecraft has solar
arrays, it has instruments,

01:12:38.590 --> 01:12:40.119
it has thrusters,
things like that.

01:12:40.119 --> 01:12:42.660
You can represent those types
of things in a block definition

01:12:42.660 --> 01:12:43.520
diagram.

01:12:43.520 --> 01:12:44.940
And then internal
block diagram is

01:12:44.940 --> 01:12:47.398
where you describe the ties
with the interfaces between all

01:12:47.398 --> 01:12:48.870
the components of your system.

01:12:48.870 --> 01:12:50.661
And this can be at
varying different levels

01:12:50.661 --> 01:12:53.340
of abstraction,
as I'll show you.

01:12:53.340 --> 01:12:55.710
Parametric diagram is
kind of a subdiagram type

01:12:55.710 --> 01:12:57.060
of the internal block diagram.

01:12:57.060 --> 01:12:58.620
So you can, again,
put constraints,

01:12:58.620 --> 01:13:01.260
mathematical, logical, things
like that, on your interfaces

01:13:01.260 --> 01:13:04.650
and begin to build up the
infrastructure for doing

01:13:04.650 --> 01:13:06.420
computation in the model.

01:13:06.420 --> 01:13:09.990
And then a packaging diagram
is not terribly important.

01:13:09.990 --> 01:13:12.240
It's really focused on the
organization of your model.

01:13:12.240 --> 01:13:13.240
How do you scope things?

01:13:13.240 --> 01:13:15.780
It's kind of a modeling
diagram as opposed

01:13:15.780 --> 01:13:17.434
to a representation
of your system.

01:13:17.434 --> 01:13:19.600
Then last of all is the
requirements diagram up top.

01:13:19.600 --> 01:13:21.150
So again, I'll show you
a good example of this.

01:13:21.150 --> 01:13:23.525
But that's where you represent,
how are your requirements

01:13:23.525 --> 01:13:25.170
related to your system?

01:13:25.170 --> 01:13:27.100
And then you can see
here what's been modified

01:13:27.100 --> 01:13:30.000
and what's been taken from
UML and the new diagram types

01:13:30.000 --> 01:13:32.020
of requirement and parametric.

01:13:32.020 --> 01:13:33.520
There were a couple
of diagram types

01:13:33.520 --> 01:13:34.936
that were eliminated
from UML that

01:13:34.936 --> 01:13:37.600
were pretty software-specific.

01:13:37.600 --> 01:13:40.120
I think there is one called the
deployment diagram, like how

01:13:40.120 --> 01:13:43.120
has your software been
deployed across various servers

01:13:43.120 --> 01:13:43.622
or users?

01:13:43.622 --> 01:13:44.330
Things like that.

01:13:44.330 --> 01:13:47.230
That's not really-- that's a
pretty software-specific thing,

01:13:47.230 --> 01:13:48.800
so in a general
system you might not

01:13:48.800 --> 01:13:50.050
care about that all that much.

01:13:50.050 --> 01:13:53.270
So that diagram was removed.

01:13:53.270 --> 01:13:56.580
So let me quickly go
over some of the syntax.

01:13:56.580 --> 01:13:59.110
So this is an Interface
Block Diagram, an IBD.

01:13:59.110 --> 01:14:00.710
And this is the type
of diagram that I

01:14:00.710 --> 01:14:06.270
find is really interesting
representing these interfaces.

01:14:06.270 --> 01:14:08.120
So here's the system
engineering ontology

01:14:08.120 --> 01:14:09.140
we typically talk about.

01:14:09.140 --> 01:14:12.200
So this is basically a
model of an avionics board.

01:14:12.200 --> 01:14:14.870
So you have things like
voltage converters.

01:14:14.870 --> 01:14:17.230
You have memory,
volatile, nonvolatile.

01:14:17.230 --> 01:14:21.430
We have an FPGA, which is
our main computational unit.

01:14:21.430 --> 01:14:24.080
We talk about these as being
parts of a system in terms

01:14:24.080 --> 01:14:25.430
of system engineering ontology.

01:14:25.430 --> 01:14:28.930
Then these are these interfaces
or these lines right here.

01:14:28.930 --> 01:14:31.600
So in SysML, the way we
talk about it is these

01:14:31.600 --> 01:14:35.540
are part properties
of the system.

01:14:35.540 --> 01:14:38.270
It's kind of like an
instantiation type of thing.

01:14:38.270 --> 01:14:40.730
What we're saying is all of
these parts can represent

01:14:40.730 --> 01:14:42.270
independent of each other.

01:14:42.270 --> 01:14:44.840
And then you define a
property of that part

01:14:44.840 --> 01:14:46.850
as being part of
a different part,

01:14:46.850 --> 01:14:48.930
if that makes any sense at all.

01:14:48.930 --> 01:14:50.550
So for example, this is a board.

01:14:50.550 --> 01:14:53.150
This main electronics
board is this whole block.

01:14:53.150 --> 01:14:55.580
And then that has some
blocks within this block,

01:14:55.580 --> 01:14:57.870
which represent the subparts
that make up the board.

01:14:57.870 --> 01:14:59.630
And these are called
part properties

01:14:59.630 --> 01:15:02.775
of this overall block.

01:15:02.775 --> 01:15:05.150
We have these green little
boxes, which are called ports.

01:15:05.150 --> 01:15:06.733
And again, that's
to support this kind

01:15:06.733 --> 01:15:08.960
of system-independent modeling.

01:15:08.960 --> 01:15:11.480
So you can model like a
voltage converter independent

01:15:11.480 --> 01:15:14.150
of any type of system
as maybe an input

01:15:14.150 --> 01:15:15.290
voltage and output voltage.

01:15:15.290 --> 01:15:17.581
You can define what ranges
those are, things like that.

01:15:17.581 --> 01:15:20.000
And you can model those
interfaces using ports.

01:15:20.000 --> 01:15:23.630
And then these connectors, which
are called connectors in SysML

01:15:23.630 --> 01:15:25.850
which represent the
interfaces, represent

01:15:25.850 --> 01:15:28.490
how each part is tied into
the kind of larger system.

01:15:28.490 --> 01:15:30.350
And you could, for
example, check that you

01:15:30.350 --> 01:15:31.820
don't have any empty ports.

01:15:31.820 --> 01:15:34.340
If a part needs
an input voltage,

01:15:34.340 --> 01:15:36.380
you could run a
script that checks

01:15:36.380 --> 01:15:39.800
that all the parts have all
their ports kind of satisfied.

01:15:39.800 --> 01:15:41.450
That's something you
can do with SysML.

01:15:44.021 --> 01:15:45.520
So before I get
into the case study,

01:15:45.520 --> 01:15:47.980
I want to talk a little bit
about what you're going to see.

01:15:47.980 --> 01:15:49.938
As Olly said, I work on
something called REXIS,

01:15:49.938 --> 01:15:52.240
which is the REgolith
X-Ray Imaging Spectrometer.

01:15:52.240 --> 01:15:53.920
It's an x-ray
spectrometer that's

01:15:53.920 --> 01:15:57.370
flying on NASA's OSIRIS-REx
asteroid sample return mission.

01:15:57.370 --> 01:15:59.290
I've been working
on it since 2011,

01:15:59.290 --> 01:16:02.180
when I was a senior here
all throughout my master's,

01:16:02.180 --> 01:16:03.725
and then now for my PhD.

01:16:03.725 --> 01:16:05.350
Basically we're going
to measure x-rays

01:16:05.350 --> 01:16:07.599
that are fluoresced from the
asteroid surface in order

01:16:07.599 --> 01:16:10.660
to tell what the elemental
composition of the asteroid is.

01:16:10.660 --> 01:16:12.616
So that's our main science goal.

01:16:12.616 --> 01:16:13.990
And that will
basically enable us

01:16:13.990 --> 01:16:17.172
to categorize where
the asteroid is

01:16:17.172 --> 01:16:18.880
within the different
meteorite types that

01:16:18.880 --> 01:16:21.520
have been defined on the ground
based upon existing meteorite

01:16:21.520 --> 01:16:23.350
samples.

01:16:23.350 --> 01:16:25.740
So what I did for
my master's thesis

01:16:25.740 --> 01:16:28.410
was modeled the design
history of REXIS.

01:16:28.410 --> 01:16:31.860
So how has our design evolved
from the very beginning

01:16:31.860 --> 01:16:35.460
where it was very open
ended, very abstract,

01:16:35.460 --> 01:16:38.340
and you'll see this,
to the current design,

01:16:38.340 --> 01:16:42.300
which current in this case
was CDR which was over a year

01:16:42.300 --> 01:16:44.281
ago now.

01:16:44.281 --> 01:16:45.780
Right now the current
state of REXIS

01:16:45.780 --> 01:16:48.130
is we're almost ready to
mount to the spacecraft.

01:16:48.130 --> 01:16:50.670
So it's very exciting.

01:16:50.670 --> 01:16:53.116
Just to give you an
idea of a timeline,

01:16:53.116 --> 01:16:55.740
this is something I'm sure Olly
will talk about in this course,

01:16:55.740 --> 01:16:58.180
is the flow through the
system development lifecycles.

01:16:58.180 --> 01:17:00.013
So we have a system
requirements review back

01:17:00.013 --> 01:17:02.120
in January of 2012, system--

01:17:02.120 --> 01:17:05.730
I think it's definition
review, April 2012,

01:17:05.730 --> 01:17:08.130
preliminary design
review January of 2013,

01:17:08.130 --> 01:17:11.040
and then critical design
review February of 2014.

01:17:11.040 --> 01:17:13.924
So I created models at each of
these design points in SysML

01:17:13.924 --> 01:17:16.340
and looked at, what are the
lessons we could have learned?

01:17:16.340 --> 01:17:17.904
We didn't use the
SysML in REXIS.

01:17:17.904 --> 01:17:19.570
I was kind of looking
back historically,

01:17:19.570 --> 01:17:20.920
what if we had used it?

01:17:20.920 --> 01:17:22.620
Could we have designed
our system better

01:17:22.620 --> 01:17:25.840
in any sort of way?

01:17:25.840 --> 01:17:27.801
So here is kind of
a CAD representation

01:17:27.801 --> 01:17:28.800
of how a design evolved.

01:17:28.800 --> 01:17:30.600
And I think you can
kind of get the idea.

01:17:30.600 --> 01:17:32.939
Back at SRR, a lot of
things we didn't really

01:17:32.939 --> 01:17:34.230
know what they would look like.

01:17:34.230 --> 01:17:36.063
We didn't know what the
interfaces would be.

01:17:36.063 --> 01:17:38.340
We didn't know what
all the parts would be.

01:17:38.340 --> 01:17:40.260
We had a little more
development for SDR.

01:17:40.260 --> 01:17:42.180
You can see there's more arrows.

01:17:42.180 --> 01:17:44.250
The CAD is a little
bit more detailed.

01:17:44.250 --> 01:17:46.861
PDR, we had even more detail.

01:17:46.861 --> 01:17:48.610
This was actually like
a buildable design.

01:17:48.610 --> 01:17:50.760
This turned out to
not even be buildable.

01:17:50.760 --> 01:17:54.620
And then we had more
evolution between PDR and CDR

01:17:54.620 --> 01:17:56.670
to get to pretty much
where the design is.

01:17:56.670 --> 01:17:58.170
There's actually
been some evolution

01:17:58.170 --> 01:18:02.299
after this as well, as sometimes
happens with a new system.

01:18:02.299 --> 01:18:03.840
But you can see just
graphically kind

01:18:03.840 --> 01:18:05.730
of the increase in level
of detail and level

01:18:05.730 --> 01:18:08.255
of fidelity of the
state of our system

01:18:08.255 --> 01:18:09.630
throughout its
development cycle.

01:18:09.630 --> 01:18:12.745
And I'll show you that and how
that looks in the SysML model

01:18:12.745 --> 01:18:14.584
as well.

01:18:14.584 --> 01:18:17.000
So one of the things you can
do if you have a SysML model,

01:18:17.000 --> 01:18:18.820
is as I talked about,
you can run queries on it

01:18:18.820 --> 01:18:21.319
and pull out information that's
very difficult or impossible

01:18:21.319 --> 01:18:23.330
to get with our current
deployment practices.

01:18:23.330 --> 01:18:26.510
So this is just looking at
the different subassemblies

01:18:26.510 --> 01:18:27.154
within REXIS.

01:18:27.154 --> 01:18:29.570
What are the number of parts
in each of the subassemblies?

01:18:29.570 --> 01:18:31.861
So you can see the general
trend is up for all of them,

01:18:31.861 --> 01:18:33.350
as you would expect.

01:18:33.350 --> 01:18:35.510
Some jump up very high.

01:18:35.510 --> 01:18:37.694
Some kind of stay
basically where they were.

01:18:37.694 --> 01:18:39.110
But in general,
they all increase.

01:18:39.110 --> 01:18:40.526
And this is something
you might be

01:18:40.526 --> 01:18:42.577
able to do with looking
at like a parts list

01:18:42.577 --> 01:18:44.660
or something like that
with current methodologies.

01:18:44.660 --> 01:18:46.460
But it would be very hard to
get this information, which

01:18:46.460 --> 01:18:48.440
is the number of
ports per assembly.

01:18:48.440 --> 01:18:49.920
So each interface has two ports.

01:18:49.920 --> 01:18:51.795
So these numbers divided
by 2 basically equal

01:18:51.795 --> 01:18:54.250
the number of interfaces that
we have in each subassembly.

01:18:54.250 --> 01:18:56.208
And you can see, again,
there's a general trend

01:18:56.208 --> 01:18:59.750
of increasing number of ports
as you go through the lifecycle.

01:18:59.750 --> 01:19:01.949
So this is a piece
of information

01:19:01.949 --> 01:19:03.740
you might want to use
if you want to manage

01:19:03.740 --> 01:19:04.860
the complexity of your system.

01:19:04.860 --> 01:19:06.660
And you say, this
subassembly is getting--

01:19:06.660 --> 01:19:09.220
it's way too many interfaces,
way too many parts.

01:19:09.220 --> 01:19:10.150
It's way too complex.

01:19:10.150 --> 01:19:11.900
We need to think about
how we've logically

01:19:11.900 --> 01:19:13.700
arranged our system
and maybe how can we

01:19:13.700 --> 01:19:15.950
rearrange it to make it more
understandable and easier

01:19:15.950 --> 01:19:16.920
to work with.

01:19:16.920 --> 01:19:18.632
And then you can divide the two.

01:19:18.632 --> 01:19:20.340
And you end up looking
at how many-- this

01:19:20.340 --> 01:19:24.020
is ports per part in
each subassembly at each

01:19:24.020 --> 01:19:25.370
of the design reviews.

01:19:25.370 --> 01:19:27.740
And you can see trends here,
too, which are interesting.

01:19:27.740 --> 01:19:29.510
So you can see in the
beginning we didn't really

01:19:29.510 --> 01:19:30.140
know what we were doing.

01:19:30.140 --> 01:19:32.360
Some of these had a lot
of parts, ports per part.

01:19:32.360 --> 01:19:33.860
Some of these had very few.

01:19:33.860 --> 01:19:35.860
They all ended up
stabilizing kind

01:19:35.860 --> 01:19:38.505
of in between the three and
five ports per part range.

01:19:38.505 --> 01:19:40.130
And then you can look
at the literature

01:19:40.130 --> 01:19:42.680
and say, well,
typically systems tend

01:19:42.680 --> 01:19:45.332
to be between five and
six ports per part.

01:19:45.332 --> 01:19:46.290
So what does that mean?

01:19:46.290 --> 01:19:48.742
Does that mean that our system
didn't model it correctly?

01:19:48.742 --> 01:19:49.700
That's one possibility.

01:19:49.700 --> 01:19:53.030
It didn't model it to the lowest
level of fidelity possible.

01:19:53.030 --> 01:19:55.552
Does it mean that our
system is too simple?

01:19:55.552 --> 01:19:57.260
Does it mean that
we're missing something

01:19:57.260 --> 01:19:58.580
that we haven't thought about?

01:19:58.580 --> 01:20:00.740
Does it mean that
our system, which

01:20:00.740 --> 01:20:03.110
was intended to be simple
and cheap and implementable

01:20:03.110 --> 01:20:05.330
by students is actually
achieving that goal

01:20:05.330 --> 01:20:07.460
because it's beneath what
you typically expect?

01:20:07.460 --> 01:20:09.960
Those are the types of questions
you can ask with this data.

01:20:09.960 --> 01:20:12.680
But this data is not easy to get
with the current methodologies.

01:20:12.680 --> 01:20:15.140
So this kind of very
simple queries you can do

01:20:15.140 --> 01:20:19.490
gives you power on managing
complexity in your system.

01:20:19.490 --> 01:20:24.340
So let me now transition
quickly to the demo.

01:20:24.340 --> 01:20:25.330
Let's see.

01:20:45.650 --> 01:20:46.515
There's no sound.

01:20:46.515 --> 01:20:48.265
AUDIENCE: I know, but
I need to sync it up

01:20:48.265 --> 01:20:49.450
to make it [INAUDIBLE].

01:21:00.730 --> 01:21:03.190
OLIVIER DE WECK: So while Mark
is setting up for the demo,

01:21:03.190 --> 01:21:06.185
are there any questions
about SysML so far,

01:21:06.185 --> 01:21:07.476
any observations you guys have?

01:21:11.450 --> 01:21:12.860
Maybe at EPFL.

01:21:12.860 --> 01:21:15.140
Do you see the similarities
and differences

01:21:15.140 --> 01:21:16.070
between OPM and SysML?

01:21:18.850 --> 01:21:22.570
What's the biggest
difference between the two?

01:21:22.570 --> 01:21:24.404
There's two really
important differences.

01:21:27.204 --> 01:21:28.370
GUEST SPEAKER: No questions?

01:21:28.370 --> 01:21:29.023
Yes.

01:21:29.023 --> 01:21:30.010
AUDIENCE: I was going to ask--

01:21:30.010 --> 01:21:30.230
OLIVIER DE WECK: Hang on.

01:21:30.230 --> 01:21:31.030
Hang on.

01:21:31.030 --> 01:21:34.920
Is there anybody at EPFL who
wants to comment on this?

01:21:40.570 --> 01:21:42.577
AUDIENCE: No, there is
no comment from EPFL.

01:21:42.577 --> 01:21:43.410
OLIVIER DE WECK: OK.

01:21:43.410 --> 01:21:43.910
Good.

01:21:43.910 --> 01:21:45.330
That's fine.

01:21:45.330 --> 01:21:46.770
That's fine.

01:21:46.770 --> 01:21:48.016
Mark, are you set up?

01:21:48.016 --> 01:21:48.932
GUEST SPEAKER: Almost.

01:21:54.077 --> 01:21:55.660
OLIVIER DE WECK:
What I would say is--

01:21:55.660 --> 01:21:59.890
so first of all, OPM has
only one type of diagram,

01:21:59.890 --> 01:22:02.965
and then you go really deep,
sort of a deep hierarchy.

01:22:02.965 --> 01:22:05.880
SysML has nine different
types of diagrams

01:22:05.880 --> 01:22:08.520
split between behavioral
and structural.

01:22:08.520 --> 01:22:10.190
So that's one difference.

01:22:10.190 --> 01:22:12.490
And then the other is that
the SysML is fundamentally

01:22:12.490 --> 01:22:16.420
object-oriented because it comes
from object-oriented thinking

01:22:16.420 --> 01:22:20.140
and software, whereas OPM
has objects and processes

01:22:20.140 --> 01:22:22.180
sort of at the same level.

01:22:22.180 --> 01:22:24.976
Those are two of the most
important differences.

01:22:27.522 --> 01:22:28.480
MARK CHODAS: All right.

01:22:28.480 --> 01:22:30.730
So what I'm showing you--
can everyone see the screen?

01:22:30.730 --> 01:22:33.160
Just let me know if you
can't see the screen.

01:22:33.160 --> 01:22:36.530
What I'm showing you right now
is a tool called MagicDraw.

01:22:36.530 --> 01:22:38.530
There are basically a
variety of tools provided

01:22:38.530 --> 01:22:41.440
by commercial vendors that
enable you to build and work

01:22:41.440 --> 01:22:42.350
with a SysML model.

01:22:42.350 --> 01:22:45.130
So SysML is a language, and
then it's implemented in tools.

01:22:45.130 --> 01:22:48.220
And this just happens to be
one that's fairly well, fairly

01:22:48.220 --> 01:22:49.900
widely utilized.

01:22:49.900 --> 01:22:51.680
Unfortunately, it's
quite expensive.

01:22:51.680 --> 01:22:53.737
But anyway, so what I'm
showing you right now,

01:22:53.737 --> 01:22:56.320
and this is going to be a little
bit difficult because, as you

01:22:56.320 --> 01:22:59.070
can see, you need a big screen.

01:22:59.070 --> 01:23:01.510
What I'm showing you right
now is a requirements diagram.

01:23:01.510 --> 01:23:02.801
So you can see that right here.

01:23:02.801 --> 01:23:04.540
It's a requirements diagram.

01:23:04.540 --> 01:23:08.920
And each of these blocks, as
you can see by the tag here,

01:23:08.920 --> 01:23:10.090
is a requirement.

01:23:10.090 --> 01:23:12.991
So this is one of our
operating criterias.

01:23:12.991 --> 01:23:14.990
Well operating temperature
of all our components

01:23:14.990 --> 01:23:17.380
shall be maintained
within operability limits.

01:23:17.380 --> 01:23:19.210
Straightforward requirement.

01:23:19.210 --> 01:23:21.760
And you can create these
satisfy relationships

01:23:21.760 --> 01:23:24.340
between that requirement
and the components

01:23:24.340 --> 01:23:27.160
in the system that must
satisfy that requirement.

01:23:27.160 --> 01:23:30.840
So right now, this is being done
at SRR, as you can see up here.

01:23:30.840 --> 01:23:34.040
So this is very
early in the design.

01:23:34.040 --> 01:23:37.030
So we don't have it broken down
fully to all the components.

01:23:37.030 --> 01:23:39.160
But we have-- here is our
main electronics board.

01:23:39.160 --> 01:23:40.826
It has to satisfy
that requirement.

01:23:40.826 --> 01:23:41.950
Here's our radiation cover.

01:23:41.950 --> 01:23:43.480
It has to satisfy
that requirement.

01:23:43.480 --> 01:23:45.550
So you can tie these two
things, the requirement

01:23:45.550 --> 01:23:48.091
and the part of the system that
must satisfy the requirement.

01:23:48.091 --> 01:23:50.110
And here I've tied it to parts.

01:23:50.110 --> 01:23:51.850
So these are called
blocks, which

01:23:51.850 --> 01:23:54.545
are the fundamental unit
in SysML, is a block.

01:23:54.545 --> 01:23:56.170
So these represent
parts of our system.

01:23:56.170 --> 01:23:58.128
But you could tie it to
a property of that part

01:23:58.128 --> 01:23:59.144
if you wanted to.

01:23:59.144 --> 01:24:00.560
So then you get
into the situation

01:24:00.560 --> 01:24:02.290
I talked about
earlier where you have

01:24:02.290 --> 01:24:05.210
the requirement is on the mass
of it must be less than this.

01:24:05.210 --> 01:24:07.210
You can tie it to the
mass of the system itself,

01:24:07.210 --> 01:24:08.251
as opposed to the system.

01:24:08.251 --> 01:24:12.850
You can tie it to the actual
property, which is very useful.

01:24:12.850 --> 01:24:19.810
So let me quickly show you
one of the cool things.

01:24:19.810 --> 01:24:21.894
If I delete these requirements,
I'm not actually--

01:24:21.894 --> 01:24:23.393
you can see there's
no requirements.

01:24:23.393 --> 01:24:25.800
I'm not actually deleting
them from the system itself,

01:24:25.800 --> 01:24:28.610
but I'm just doing it as I'm
removing it from the diagram.

01:24:28.610 --> 01:24:32.160
But if you wanted
to, you should be

01:24:32.160 --> 01:24:39.200
able to look at related elements
of the different blocks.

01:24:39.200 --> 01:24:40.990
So I just clicked
on a block, and I

01:24:40.990 --> 01:24:44.620
can choose to show all the
requirements, all the things

01:24:44.620 --> 01:24:48.280
that are satisfied, the
requirements of that component

01:24:48.280 --> 01:24:49.870
of the system satisfies.

01:24:49.870 --> 01:24:53.150
And these requirements pop up.

01:24:53.150 --> 01:24:56.422
So this is showing how
the diagrams themselves

01:24:56.422 --> 01:24:57.130
aren't the model.

01:24:57.130 --> 01:24:59.016
There's actually
backend to the model.

01:24:59.016 --> 01:25:00.640
And you can kind of
work in the diagram

01:25:00.640 --> 01:25:02.960
and show or hide things
however you want.

01:25:02.960 --> 01:25:06.940
But the information is actually
kept behind the diagram,

01:25:06.940 --> 01:25:09.120
so to speak.

01:25:09.120 --> 01:25:11.970
So my research looked
into typologies.

01:25:11.970 --> 01:25:15.300
So let me just kind of show you
a little bit about what I did.

01:25:15.300 --> 01:25:17.610
So this is a block definition
diagram, again, defining

01:25:17.610 --> 01:25:18.660
all the parts of your system.

01:25:18.660 --> 01:25:20.660
And I just want to give
you kind of a high level

01:25:20.660 --> 01:25:24.410
idea of the type of
things that we saw.

01:25:24.410 --> 01:25:32.110
So it's big, first
of all, very big.

01:25:32.110 --> 01:25:33.940
These are all the
parts of the system.

01:25:33.940 --> 01:25:35.950
So we start high like
the mission context,

01:25:35.950 --> 01:25:37.574
and the mission
context contains things

01:25:37.574 --> 01:25:40.294
like the environment and the
spacecraft and then REXIS.

01:25:40.294 --> 01:25:41.710
And then you can
break down REXIS.

01:25:41.710 --> 01:25:43.820
We have these various
subassemblies broken down

01:25:43.820 --> 01:25:44.680
to parts.

01:25:44.680 --> 01:25:47.020
And that's how you get
this tree structure.

01:25:47.020 --> 01:25:50.470
And then this tree structure
can be tied together.

01:25:50.470 --> 01:25:52.780
I can zoom in, but
it's big again.

01:25:52.780 --> 01:25:55.430
So these are all the
parts of our system.

01:25:55.430 --> 01:25:58.320
Let me give you an example.

01:25:58.320 --> 01:26:00.410
So we have a couple
of boards that we

01:26:00.410 --> 01:26:02.200
call our detector electronics.

01:26:02.200 --> 01:26:05.327
And those detector electronics
have various ports.

01:26:05.327 --> 01:26:07.160
One thing they had to
do, they had this port

01:26:07.160 --> 01:26:10.850
in here and this interface here,
which connects to our CCDs.

01:26:10.850 --> 01:26:14.360
So this is showing how you can
build interfaces and SysML.

01:26:14.360 --> 01:26:16.700
So here are the green
boxes, again, or the ports.

01:26:16.700 --> 01:26:18.408
The lines are the
connectors, and they're

01:26:18.408 --> 01:26:19.700
defining all the interfaces.

01:26:19.700 --> 01:26:23.660
And you can see at a high
level how complicated things

01:26:23.660 --> 01:26:24.900
get very quickly.

01:26:24.900 --> 01:26:28.250
This is the earliest, most
abstract version of our design.

01:26:28.250 --> 01:26:30.920
And it already has a
lot of complication.

01:26:30.920 --> 01:26:32.740
One thing you can do--

01:26:32.740 --> 01:26:34.375
I talked about running scripts.

01:26:34.375 --> 01:26:35.730
I'll show you how that works.

01:26:35.730 --> 01:26:36.860
It's quite easy.

01:26:40.080 --> 01:26:42.000
So I just ran a script
on the model that

01:26:42.000 --> 01:26:45.120
told me to find the number
of parts in the scope

01:26:45.120 --> 01:26:47.542
that I defined and
the number of ports.

01:26:47.542 --> 01:26:49.500
And here's the output of
that model right here.

01:26:49.500 --> 01:26:53.170
So the script itself is
not even very complicated.

01:26:53.170 --> 01:26:55.940
It's like 50, 60 lines of code.

01:26:55.940 --> 01:26:58.620
And immediately I can pull out
how many ports, how many parts,

01:26:58.620 --> 01:27:01.574
things like that,
information down my system.

01:27:01.574 --> 01:27:03.990
So let me kind of take you
briefly through the development

01:27:03.990 --> 01:27:05.280
process.

01:27:05.280 --> 01:27:07.590
So that was, again, the
highest, the most abstract,

01:27:07.590 --> 01:27:09.620
the earliest version
of our system, SRR.

01:27:09.620 --> 01:27:12.000
This is SDR.

01:27:12.000 --> 01:27:16.830
You can see it's starting
to get a bit more complex.

01:27:16.830 --> 01:27:20.265
And then you can go
over to PDR, and it

01:27:20.265 --> 01:27:21.690
starts to get really scary.

01:27:25.700 --> 01:27:29.800
And you can go to CDR,
and it's just a nightmare.

01:27:29.800 --> 01:27:32.430
So I created all these systems,
all these models by hand.

01:27:32.430 --> 01:27:34.950
You can actually build
the model with the script,

01:27:34.950 --> 01:27:37.240
if you would like.

01:27:37.240 --> 01:27:39.690
You can basically do things
like define a pattern

01:27:39.690 --> 01:27:42.810
and then apply that pattern
to all the parts of that type.

01:27:42.810 --> 01:27:45.180
That's all possible
through the API.

01:27:45.180 --> 01:27:48.060
And just to show you how much
of a nightmare it was at CDR,

01:27:48.060 --> 01:27:54.470
let me run the same
script on the CDR model.

01:27:54.470 --> 01:27:57.617
You have 230 parts
and 900 interfaces.

01:27:57.617 --> 01:27:59.450
And this was not even
modeling to the lowest

01:27:59.450 --> 01:28:00.500
level of fidelity possible.

01:28:00.500 --> 01:28:02.499
I didn't, for example,
model all the components,

01:28:02.499 --> 01:28:04.880
all the capacitors,
resistors, op amps, and stuff

01:28:04.880 --> 01:28:06.360
on the board.

01:28:06.360 --> 01:28:09.980
And now you can already
see it's quite large.

01:28:09.980 --> 01:28:12.080
Kind of the idea
behind these models

01:28:12.080 --> 01:28:15.830
would be to extend this to the
lowest level in a real system

01:28:15.830 --> 01:28:18.260
and use this, basically use
all the capabilities that you

01:28:18.260 --> 01:28:19.718
had with the model
to really manage

01:28:19.718 --> 01:28:22.310
your complexity in a way that
is just not possible currently.

01:28:22.310 --> 01:28:23.685
And there's no
way you can really

01:28:23.685 --> 01:28:25.566
mentally keep track of
all these interfaces

01:28:25.566 --> 01:28:27.440
and understanding how
your system is working.

01:28:27.440 --> 01:28:28.856
So having this
modeling capability

01:28:28.856 --> 01:28:31.700
and querying capability is
really, really powerful.

01:28:31.700 --> 01:28:33.020
Yeah?

01:28:33.020 --> 01:28:37.350
AUDIENCE: What was used
during REXIS for the systems

01:28:37.350 --> 01:28:38.690
engineering?

01:28:38.690 --> 01:28:41.240
You had applied
this after the fact.

01:28:41.240 --> 01:28:46.257
So what was used to create these
block diagram or [INAUDIBLE]..

01:28:46.257 --> 01:28:48.840
MARK CHODAS: Do you mean during
when we were developing REXIS?

01:28:48.840 --> 01:28:49.580
AUDIENCE: Yeah.

01:28:49.580 --> 01:28:51.500
MARK CHODAS: We basically
didn't have this.

01:28:51.500 --> 01:28:53.150
So we were relying--

01:28:53.150 --> 01:28:56.060
as you would typically do upon
the capabilities of the system

01:28:56.060 --> 01:28:58.070
engineer or the team--
you'd to have documents.

01:28:58.070 --> 01:29:00.050
We have a ton of documents.

01:29:00.050 --> 01:29:02.360
But I was talking about how
things weren't buildable.

01:29:02.360 --> 01:29:05.264
I found a situation
where because of the way

01:29:05.264 --> 01:29:06.680
we had done our
thermal system, we

01:29:06.680 --> 01:29:09.150
were dumping spacecraft
heat to space,

01:29:09.150 --> 01:29:11.210
which you don't want to do.

01:29:11.210 --> 01:29:13.770
I can explain why, but
you don't want to do that.

01:29:13.770 --> 01:29:16.329
And that's something we
didn't realize at the time.

01:29:16.329 --> 01:29:17.870
If we had tried to
build it, we would

01:29:17.870 --> 01:29:19.610
have had this
property of the system

01:29:19.610 --> 01:29:21.281
that we didn't know
actually existed

01:29:21.281 --> 01:29:23.030
until I went back and
looked at the model.

01:29:23.030 --> 01:29:24.769
So we definitely miss things.

01:29:24.769 --> 01:29:26.810
And this should have
improved the design process,

01:29:26.810 --> 01:29:29.460
if we had been using it.

01:29:29.460 --> 01:29:32.267
OLIVIER DE WECK: Great, so
Mark, sort of to wrap up,

01:29:32.267 --> 01:29:34.600
because we've got to switch
over to [INAUDIBLE],, what's

01:29:34.600 --> 01:29:38.140
your recommendation for, let's
say, students in the class

01:29:38.140 --> 01:29:40.330
got sort of intrigued by SysML.

01:29:40.330 --> 01:29:41.985
What's the next step?

01:29:41.985 --> 01:29:43.860
MARK CHODAS: There's a
couple different ways.

01:29:43.860 --> 01:29:45.318
Certainly if you're
interested, let

01:29:45.318 --> 01:29:47.430
me know, and I can
give you resources

01:29:47.430 --> 01:29:49.740
to further your understanding.

01:29:49.740 --> 01:29:51.980
As I said, working
with these tools

01:29:51.980 --> 01:29:53.717
can be expensive
to get these tools.

01:29:53.717 --> 01:29:55.800
So I can help you understand
what that would take.

01:29:59.250 --> 01:30:03.060
There are beginning to
be some companies that

01:30:03.060 --> 01:30:06.300
will do like SysML training
courses that will sit down

01:30:06.300 --> 01:30:08.940
for a day or a week
and teach you SysML,

01:30:08.940 --> 01:30:11.544
basically, how to work with the
model, how to build the model.

01:30:11.544 --> 01:30:12.710
I took one of those courses.

01:30:12.710 --> 01:30:14.557
It was really great.

01:30:14.557 --> 01:30:16.140
Yeah, talk to me if
you're interested,

01:30:16.140 --> 01:30:18.059
and I can steer you
down the right path.

01:30:18.059 --> 01:30:19.600
OLIVIER DE WECK:
Great, thanks, Mark.

01:30:19.600 --> 01:30:20.350
MARK CHODAS: Sure.

01:30:20.350 --> 01:30:22.400
OLIVIER DE WECK: Very good.

01:30:22.400 --> 01:30:25.440
So we did in 20 minutes what
usually takes about a week,

01:30:25.440 --> 01:30:26.887
right?

01:30:26.887 --> 01:30:28.470
MARK CHODAS: There's
a lot more depth.

01:30:28.470 --> 01:30:29.550
There's a lot more depth.

01:30:29.550 --> 01:30:31.925
OLIVIER DE WECK: Great, so
we're going to switch over now

01:30:31.925 --> 01:30:35.190
to Modelica, which I think is--

01:30:35.190 --> 01:30:37.980
we're going to maybe run a
couple of minutes over today,

01:30:37.980 --> 01:30:42.280
but I think it's important
we cover all three languages.

01:30:42.280 --> 01:30:45.370
So let's get the slides back up.

01:30:45.370 --> 01:30:47.170
And I'm going to
switch here to Narek.

01:30:47.170 --> 01:30:49.780
He's another doctoral
student in the group.

01:30:49.780 --> 01:30:56.514
And so introduce yourself and
then tell us about Modelica.

01:30:56.514 --> 01:30:58.700
NAREK SHOUGARIAN: Thank you.

01:30:58.700 --> 01:30:59.304
OLIVIER DE WECK: Are
you using this computer

01:30:59.304 --> 01:31:00.470
for slides or this computer?

01:31:00.470 --> 01:31:03.707
NAREK SHOUGARIAN: For the demo,
I'm going to use this one.

01:31:03.707 --> 01:31:04.790
OLIVIER DE WECK: This one?

01:31:04.790 --> 01:31:05.283
NAREK SHOUGARIAN: This one.

01:31:05.283 --> 01:31:06.366
OLIVIER DE WECK: This one.

01:31:15.054 --> 01:31:16.220
NAREK SHOUGARIAN: Thank you.

01:31:16.220 --> 01:31:16.980
So hello, everyone.

01:31:16.980 --> 01:31:17.688
My name is Narek.

01:31:17.688 --> 01:31:20.720
I'm a doctoral student
at AeroAstro here.

01:31:20.720 --> 01:31:22.964
My background is in
gas turbine engines,

01:31:22.964 --> 01:31:24.380
and specifically
I've been looking

01:31:24.380 --> 01:31:27.110
at concept generation of gas
turbine engines, automated

01:31:27.110 --> 01:31:28.820
concept generation.

01:31:28.820 --> 01:31:31.370
And the way I got
acquainted with Modelica

01:31:31.370 --> 01:31:34.490
was that I needed to be
able to rapidly reconfigure

01:31:34.490 --> 01:31:38.120
different concepts and
simulate them mathematically,

01:31:38.120 --> 01:31:39.890
do physics-based simulations.

01:31:39.890 --> 01:31:42.440
So in contrast to the
first two languages,

01:31:42.440 --> 01:31:46.100
Modelica is a lot
more about rapidly

01:31:46.100 --> 01:31:48.860
being able to build
physical models of systems

01:31:48.860 --> 01:31:51.660
and reconfiguring them and
reusing them for later on.

01:31:54.400 --> 01:31:57.600
So like I mentioned,
Modelica is primarily

01:31:57.600 --> 01:32:00.390
about modeling physics-based
modeling of systems

01:32:00.390 --> 01:32:04.560
and rapidly being able to reuse
models and reconfigure them.

01:32:04.560 --> 01:32:05.790
It's a language, again.

01:32:05.790 --> 01:32:09.519
It's not a tool like the first
two that you heard about.

01:32:09.519 --> 01:32:12.060
There are many different tools
which implement this language.

01:32:12.060 --> 01:32:14.069
But I'm going to start
off with just describing

01:32:14.069 --> 01:32:16.110
how the language works
and then go on to describe

01:32:16.110 --> 01:32:17.700
which tools that you can use.

01:32:17.700 --> 01:32:19.950
In contrast to SysML,
there are a couple

01:32:19.950 --> 01:32:22.260
of really good free tools
that you can use and rapidly

01:32:22.260 --> 01:32:22.950
get into.

01:32:22.950 --> 01:32:25.440
And there are a lot
of libraries that you

01:32:25.440 --> 01:32:27.450
can use with hundreds,
even thousands,

01:32:27.450 --> 01:32:31.020
of actually basic components
that you can use for modeling.

01:32:31.020 --> 01:32:32.670
So it's a declarative language.

01:32:32.670 --> 01:32:35.010
And what I mean
by declarative is

01:32:35.010 --> 01:32:38.700
that in sequential
sort of programming,

01:32:38.700 --> 01:32:39.930
you write commands.

01:32:39.930 --> 01:32:42.820
And you make assignments
to various parameters.

01:32:42.820 --> 01:32:45.750
Here, you just describe
the governing equations

01:32:45.750 --> 01:32:48.690
of the components
you want to simulate.

01:32:48.690 --> 01:32:51.300
And there's no particular
order in which you do this.

01:32:51.300 --> 01:32:52.530
The models are acausal.

01:32:52.530 --> 01:32:54.480
There's no direction to flows.

01:32:54.480 --> 01:32:58.470
All you really need to do is
describe what ports, like Mark

01:32:58.470 --> 01:32:59.376
mentioned.

01:32:59.376 --> 01:33:01.500
It's similar in this
situation-- what kind of ports

01:33:01.500 --> 01:33:02.760
you have, what
kind of interfaces

01:33:02.760 --> 01:33:04.710
the components can have
with other components,

01:33:04.710 --> 01:33:08.160
and the governing equations and
the parameters and variables.

01:33:08.160 --> 01:33:10.107
It's a multi-domain
modeling language,

01:33:10.107 --> 01:33:11.940
so it's like agnostic
to what kind of domain

01:33:11.940 --> 01:33:12.689
you're working in.

01:33:12.689 --> 01:33:14.640
It's not particular to
electrical engineering.

01:33:14.640 --> 01:33:16.140
For example, I'm
going to be showing

01:33:16.140 --> 01:33:17.820
an electrical
engineering example

01:33:17.820 --> 01:33:20.130
and also show a gas
turbine engine example

01:33:20.130 --> 01:33:22.534
with aeroelastic vibrations.

01:33:22.534 --> 01:33:24.450
So you don't necessarily--
you're not attached

01:33:24.450 --> 01:33:26.340
to any specific domain.

01:33:26.340 --> 01:33:28.680
It's also
object-orientated, and it

01:33:28.680 --> 01:33:33.390
enables you to decompose
systems into subsystems

01:33:33.390 --> 01:33:36.570
or recombine them and look
at them at various levels

01:33:36.570 --> 01:33:38.020
of abstraction.

01:33:38.020 --> 01:33:40.342
It's designed to be efficient.

01:33:40.342 --> 01:33:42.300
So this is a quote from
Professor Peter Fritzen

01:33:42.300 --> 01:33:44.310
at the Linkopings University.

01:33:44.310 --> 01:33:47.610
So these are just about
the scale of problems

01:33:47.610 --> 01:33:50.632
that you can solve with
the Modelica language.

01:33:50.632 --> 01:33:52.590
Obviously, it depends on
what kind of equations

01:33:52.590 --> 01:33:55.500
you're talking about,
but it's designed

01:33:55.500 --> 01:34:00.540
to be a very efficient
way of simulating systems.

01:34:00.540 --> 01:34:02.610
So I really want to
talk a little bit more

01:34:02.610 --> 01:34:04.950
about this idea of
acausal modeling

01:34:04.950 --> 01:34:06.640
that I mentioned before.

01:34:06.640 --> 01:34:09.880
So on the left hand
side is an assignment.

01:34:09.880 --> 01:34:13.530
And that's typically what you
do when you program in MATLAB,

01:34:13.530 --> 01:34:15.890
just the MATLAB normal scripts.

01:34:15.890 --> 01:34:19.380
f is assigned to ma or p is
assigned the value of rho rt

01:34:19.380 --> 01:34:21.160
for the equation
of state of a gas.

01:34:21.160 --> 01:34:22.950
And what that means
is that you know

01:34:22.950 --> 01:34:24.780
what the mass and
acceleration are,

01:34:24.780 --> 01:34:26.030
and you figure out the force.

01:34:26.030 --> 01:34:28.040
You assign that
value to the force.

01:34:28.040 --> 01:34:30.505
In Modelica, there's
almost none of this.

01:34:30.505 --> 01:34:32.340
It's equations not assignments.

01:34:32.340 --> 01:34:34.470
And what I mean by
that is this equation

01:34:34.470 --> 01:34:36.840
can be written in any which
way, as long as your system

01:34:36.840 --> 01:34:39.865
has the same number of
equations as unknowns.

01:34:39.865 --> 01:34:43.230
The tool that you're using
will interpret the language

01:34:43.230 --> 01:34:44.770
and will solve your problem.

01:34:44.770 --> 01:34:46.519
So you can write this
in any which way you

01:34:46.519 --> 01:34:47.670
want in any order.

01:34:47.670 --> 01:34:51.150
As long as your problem
is properly constrained,

01:34:51.150 --> 01:34:53.030
the tool that you're
using will interpret it

01:34:53.030 --> 01:34:54.854
and solve the problem for you.

01:34:58.050 --> 01:35:04.230
So just to go into a little bit
more detail, all of Modelica's

01:35:04.230 --> 01:35:06.810
and also other acausal
modeling language that I'll

01:35:06.810 --> 01:35:08.350
mention in a little bit--

01:35:08.350 --> 01:35:11.460
which one of them is Simscape--

01:35:11.460 --> 01:35:12.850
have essentially three parts.

01:35:12.850 --> 01:35:15.880
They're designed to
be extremely simple.

01:35:15.880 --> 01:35:19.810
The first, like Mark
mentioned, are ports.

01:35:19.810 --> 01:35:24.630
It's essentially identical
to SysML in a way.

01:35:24.630 --> 01:35:27.600
Ports are the ways
with which components

01:35:27.600 --> 01:35:31.990
can share information, material,
or energy, for example.

01:35:31.990 --> 01:35:33.752
You can define any
kind of port you want.

01:35:33.752 --> 01:35:36.210
All you need to really do is
define what kind of parameters

01:35:36.210 --> 01:35:38.793
it carries-- like for gas, for
example, temperature, pressure,

01:35:38.793 --> 01:35:43.060
and mass flow; or for electrical
ports, voltage and current.

01:35:43.060 --> 01:35:45.000
The second part of
any kind of model

01:35:45.000 --> 01:35:47.640
that you're building in
Modelica or Simscape,

01:35:47.640 --> 01:35:49.092
which I'll mention
a little later,

01:35:49.092 --> 01:35:50.300
are variables and parameters.

01:35:50.300 --> 01:35:51.270
So you just declare those.

01:35:51.270 --> 01:35:53.061
And the third part are
governing equations.

01:35:53.061 --> 01:35:55.380
The point is that
there's nothing else.

01:35:55.380 --> 01:35:57.890
It's just that.

01:35:57.890 --> 01:36:00.350
And I'll just brief briefly
go through a very, very

01:36:00.350 --> 01:36:01.640
simple example.

01:36:01.640 --> 01:36:04.860
So for example, a capacitor.

01:36:04.860 --> 01:36:06.710
This is the entire
code for a capacitor,

01:36:06.710 --> 01:36:10.580
and this is what will generate
a visual image of a capacitor

01:36:10.580 --> 01:36:13.640
with the correct ports for you.

01:36:13.640 --> 01:36:18.050
First you have pins that
carry voltage and current.

01:36:18.050 --> 01:36:21.740
So the key thing to notice here
is that there are fundamentally

01:36:21.740 --> 01:36:25.930
two types of variables-- flow
variables and normal variables

01:36:25.930 --> 01:36:26.960
here.

01:36:26.960 --> 01:36:29.900
Flow variables are ones
for which the Kirchoff's

01:36:29.900 --> 01:36:30.780
current law applies.

01:36:30.780 --> 01:36:33.620
So mass flow, for
example, every time

01:36:33.620 --> 01:36:35.240
you connect 15
components together

01:36:35.240 --> 01:36:37.910
in a network, mass
flow into that network

01:36:37.910 --> 01:36:39.240
needs to be conserved.

01:36:39.240 --> 01:36:43.010
So the sum of mass flows
into any node has to be zero.

01:36:43.010 --> 01:36:46.774
That doesn't apply to
the standard variables.

01:36:49.560 --> 01:36:54.650
So then you essentially define
the parameters, the variables.

01:36:54.650 --> 01:36:57.170
And you need to define
the governing equations.

01:36:57.170 --> 01:36:58.940
And that's the
capacitor for you.

01:36:58.940 --> 01:37:01.040
There are slightly more
complicated components

01:37:01.040 --> 01:37:05.450
that you can use, for example
a pressure drop component.

01:37:05.450 --> 01:37:06.760
Did I lose my sharing?

01:37:06.760 --> 01:37:08.820
No.

01:37:08.820 --> 01:37:12.170
In this case, the main thing
to take away from this one

01:37:12.170 --> 01:37:14.480
is that if you have
complicated mathematics

01:37:14.480 --> 01:37:16.940
describing the fluid
mechanics in a component,

01:37:16.940 --> 01:37:19.490
you can actually
initialized with one model

01:37:19.490 --> 01:37:21.890
and then go to a full
turbulent simulation.

01:37:21.890 --> 01:37:25.220
That's what this is doing here.

01:37:25.220 --> 01:37:31.450
So just to get to the tool side
of the equation, the language I

01:37:31.450 --> 01:37:33.754
just showed you, it's the
same across all the tools.

01:37:33.754 --> 01:37:35.170
But there are many
different tools

01:37:35.170 --> 01:37:38.710
which you can use free and
commercial to actually run

01:37:38.710 --> 01:37:40.720
these models.

01:37:40.720 --> 01:37:44.770
The main one that you'll be
using if you want to get deeper

01:37:44.770 --> 01:37:46.030
into this is OpenModelica.

01:37:46.030 --> 01:37:47.140
It's free.

01:37:47.140 --> 01:37:50.870
It's actually become
quite user-friendly.

01:37:50.870 --> 01:37:55.650
And there's a link in the slides
from which you can download it.

01:37:55.650 --> 01:37:57.130
There's one from Wolfram.

01:37:57.130 --> 01:38:00.204
It's integrated
with Mathematica,

01:38:00.204 --> 01:38:01.120
which is quite useful.

01:38:01.120 --> 01:38:03.040
And there's a free
trial of it as well.

01:38:03.040 --> 01:38:04.070
There's Dymola.

01:38:04.070 --> 01:38:05.860
There are other ones.

01:38:05.860 --> 01:38:07.780
But mainly, I think
OpenModelica is the one

01:38:07.780 --> 01:38:09.544
that you guys will be using.

01:38:09.544 --> 01:38:11.660
OLIVIER DE WECK: OK,
so in other words,

01:38:11.660 --> 01:38:14.020
I think we're going to
wrap up and then have you

01:38:14.020 --> 01:38:14.760
back next week.

01:38:14.760 --> 01:38:15.225
NAREK SHOUGARIAN: OK.

01:38:15.225 --> 01:38:15.900
OLIVIER DE WECK: Are
you around next week?

01:38:15.900 --> 01:38:17.358
NAREK SHOUGARIAN:
Yeah, yeah. sure.

01:38:20.269 --> 01:38:21.810
OLIVIER DE WECK:
Just to stay around.

01:38:21.810 --> 01:38:27.390
So basically we're going to
finish this lecture next week.

01:38:27.390 --> 01:38:30.540
I think it's important enough
that you really see the demo

01:38:30.540 --> 01:38:31.670
and see sort of the--

01:38:31.670 --> 01:38:35.250
and it actually ties in kind of
nicely with next week's topic

01:38:35.250 --> 01:38:36.840
is concept generation.

01:38:36.840 --> 01:38:40.620
This is the next step in the V.
And since Narek, your research

01:38:40.620 --> 01:38:44.470
is also on concept generation,
it'll tie in nicely.

01:38:44.470 --> 01:38:47.110
So I think we're going
to stop here for today.

01:38:47.110 --> 01:38:50.430
So you heard about the general
idea of system modeling

01:38:50.430 --> 01:38:54.150
languages that are rigorous,
that have ontology, syntax

01:38:54.150 --> 01:38:55.890
and, semantics.

01:38:55.890 --> 01:38:58.830
There's different of these that
have been proposed, developed.

01:38:58.830 --> 01:39:00.700
Some are used more than others.

01:39:00.700 --> 01:39:03.130
There's really important
differences between them.

01:39:03.130 --> 01:39:05.570
So OPM is very conceptual.

01:39:05.570 --> 01:39:09.900
SysML is based on UML and
has these different type

01:39:09.900 --> 01:39:12.960
of diagrams and can
really help you flesh out

01:39:12.960 --> 01:39:14.670
your design in more detail.

01:39:14.670 --> 01:39:17.100
And then Modelica allows
you to build these blocks.

01:39:17.100 --> 01:39:20.190
It's acausal or declarative.

01:39:20.190 --> 01:39:23.520
And you can actually simulate
the physics of the system

01:39:23.520 --> 01:39:25.920
pretty readily.

01:39:25.920 --> 01:39:29.250
So the big picture here,
just to wrap up here,

01:39:29.250 --> 01:39:32.220
the big picture
is the following.

01:39:32.220 --> 01:39:34.750
And we'll come back
to this next week.

01:39:34.750 --> 01:39:39.690
The big picture is basically
that system engineering

01:39:39.690 --> 01:39:41.880
is in a transition phase.

01:39:41.880 --> 01:39:44.280
The classic way of doing
system engineering really

01:39:44.280 --> 01:39:48.630
for the last 50 years is on
the left, document-centric.

01:39:48.630 --> 01:39:50.400
Write your requirements.

01:39:50.400 --> 01:39:51.870
Do your drawings.

01:39:51.870 --> 01:39:54.510
Even CAD, you know,
computer-aided design,

01:39:54.510 --> 01:39:56.670
is great, but it
only essentially does

01:39:56.670 --> 01:39:59.040
the mechanical
part of the design.

01:39:59.040 --> 01:40:02.400
And so the result of that
is as you get-- even REXIS,

01:40:02.400 --> 01:40:05.910
REXIS is a box, like
shoe-box size, basically.

01:40:05.910 --> 01:40:08.910
And it's going to fit on
a much bigger spacecraft.

01:40:08.910 --> 01:40:11.040
And you saw how much
complexity is there.

01:40:11.040 --> 01:40:14.700
And it gets very, very difficult
to manage all this information,

01:40:14.700 --> 01:40:19.440
to prevent errors, oversights,
any change that you make.

01:40:19.440 --> 01:40:21.210
It doesn't propagate
automatically

01:40:21.210 --> 01:40:22.920
in these documents.

01:40:22.920 --> 01:40:26.360
So the transition is
happening to the right side,

01:40:26.360 --> 01:40:30.420
a model-centric way to
do system engineering.

01:40:30.420 --> 01:40:33.090
And think of
paperless engineering.

01:40:33.090 --> 01:40:35.730
Everything you're
doing is in a model.

01:40:35.730 --> 01:40:37.110
The models are linked.

01:40:37.110 --> 01:40:38.940
The models are executable.

01:40:38.940 --> 01:40:42.210
The models automatically
propagate any changes

01:40:42.210 --> 01:40:44.910
that you make in
requirements or design.

01:40:44.910 --> 01:40:46.410
We're not quite there yet.

01:40:46.410 --> 01:40:48.960
But that is where
things are moving.

01:40:48.960 --> 01:40:51.780
And so keep that in mind.

01:40:51.780 --> 01:40:53.580
So there's no new
assignment this week.

01:40:53.580 --> 01:40:56.987
So next week, we have A-2,
which is do, the requirements.

01:40:56.987 --> 01:40:59.320
Please let us know if you
have any-- we're here for you.

01:40:59.320 --> 01:41:02.370
So I'm going to have office
hours now on the WebEx.

01:41:02.370 --> 01:41:03.210
You have the link.

01:41:05.930 --> 01:41:07.600
If you have any
questions about A-2,

01:41:07.600 --> 01:41:12.180
don't be shy to email me or
[? Yuanna ?] or [? Leislu ?]

01:41:12.180 --> 01:41:13.529
at EPFL.

01:41:13.529 --> 01:41:15.320
We're really here to
answer your questions.

01:41:15.320 --> 01:41:18.480
So next week topic, we're
going to finish on Modelica,

01:41:18.480 --> 01:41:22.420
and concept generation is going
to be sort of our-- creativity

01:41:22.420 --> 01:41:26.340
concept generation is
our main topic next week.