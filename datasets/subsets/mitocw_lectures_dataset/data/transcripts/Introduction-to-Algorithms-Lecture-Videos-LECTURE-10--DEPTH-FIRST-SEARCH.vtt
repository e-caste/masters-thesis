WEBVTT

00:00:00.000 --> 00:00:04.850
[CREAKING] [CLICKING]
[SQUEAKING] [RUSTLING]

00:00:04.850 --> 00:00:07.760
[CLICKING]

00:00:12.120 --> 00:00:13.870
JUSTIN SOLOMON: We
just started a new unit

00:00:13.870 --> 00:00:16.239
on graph theory,
which is going to be

00:00:16.239 --> 00:00:20.343
sort of our focus for the next
couple of lectures in 6006.

00:00:20.343 --> 00:00:22.510
And so I thought we'd give
it a little bit of review

00:00:22.510 --> 00:00:24.468
at the beginning the
lecture because, as usual,

00:00:24.468 --> 00:00:26.470
I've muddled together
a lot of notions

00:00:26.470 --> 00:00:30.160
in our previous lecture, and
then start with some new ideas.

00:00:30.160 --> 00:00:31.910
So basically, in our
previous lecture,

00:00:31.910 --> 00:00:35.020
we talked about an algorithm
called breadth-first search.

00:00:35.020 --> 00:00:37.120
And then almost always
you see that paired

00:00:37.120 --> 00:00:39.550
with a second algorithm
called depth-first search.

00:00:39.550 --> 00:00:42.220
And following tradition,
and basically logic,

00:00:42.220 --> 00:00:46.270
we'll do the same
thing in 006 today.

00:00:46.270 --> 00:00:48.100
But in any event,
for today we'll

00:00:48.100 --> 00:00:50.030
stick to the technical material.

00:00:50.030 --> 00:00:52.180
So as a little bit of
review, I guess actually,

00:00:52.180 --> 00:00:53.827
the one thing I didn't
do on this slide

00:00:53.827 --> 00:00:54.910
was actually draw a graph.

00:00:54.910 --> 00:00:57.410
So we should probably
start with that.

00:00:57.410 --> 00:01:03.010
So if you recall, graph is a
collection of nodes or vertices

00:01:03.010 --> 00:01:03.640
depending--

00:01:03.640 --> 00:01:05.723
I don't know, is it like
a European American thing

00:01:05.723 --> 00:01:08.780
or something-- and edges.

00:01:08.780 --> 00:01:10.810
So here's an example,
which as usual, I'm

00:01:10.810 --> 00:01:13.660
not managing to draw
particularly clearly.

00:01:13.660 --> 00:01:15.900
So this graph is
kind of like a cycle.

00:01:15.900 --> 00:01:19.480
So I have directed edges
here, here, here, and here.

00:01:19.480 --> 00:01:21.760
And of course, there are
many kind of variations

00:01:21.760 --> 00:01:22.950
on the theme, right?

00:01:22.950 --> 00:01:25.660
So our basic sort of
definition of a graph

00:01:25.660 --> 00:01:27.808
is that we have
some set V, which

00:01:27.808 --> 00:01:28.975
is like the set of vertices.

00:01:32.080 --> 00:01:35.245
And then we have a set
E, which is set of edges.

00:01:38.940 --> 00:01:41.490
And this was a
subset of V cross V.

00:01:41.490 --> 00:01:44.820
And this is nothing more than
fancy notation for saying

00:01:44.820 --> 00:01:47.520
that an edge is a pair
of vertices, like a from

00:01:47.520 --> 00:01:48.725
and a to vertex.

00:01:48.725 --> 00:01:50.850
Of course, there are many
variations on this theme.

00:01:50.850 --> 00:01:54.220
You could have a directed
versus an undirected graph.

00:01:54.220 --> 00:01:57.180
So this one is directed, meaning
the edges look like arrows.

00:01:57.180 --> 00:02:00.240
If they didn't have arrowheads,
they'd be undirected.

00:02:00.240 --> 00:02:02.610
We define something called a
simple graph where you have

00:02:02.610 --> 00:02:04.860
essentially no repeated edges.

00:02:04.860 --> 00:02:06.510
So for instance, you
can't do something

00:02:06.510 --> 00:02:09.953
like this where you have
the same edge twice.

00:02:09.953 --> 00:02:12.120
And then there are a couple
of different definitions

00:02:12.120 --> 00:02:13.300
that were kind of useful.

00:02:13.300 --> 00:02:17.550
So in particular-- I'm going
to erase this, whoops--

00:02:17.550 --> 00:02:18.570
useless edge here.

00:02:21.950 --> 00:02:23.970
Maybe make my graph
slightly more interesting.

00:02:23.970 --> 00:02:28.020
So add another edge going
in the reverse direction.

00:02:28.020 --> 00:02:29.940
So maybe I have--

00:02:29.940 --> 00:02:36.500
I'm going to give my vertices
labels. x, y, z, and w.

00:02:36.500 --> 00:02:39.020
Then we talked
about the neighbors

00:02:39.020 --> 00:02:42.110
of a given vertex, which
are the vertices that you

00:02:42.110 --> 00:02:45.840
can reach by following edges
in or out of your vertex.

00:02:45.840 --> 00:02:48.350
So in particular, the
outgoing neighbors,

00:02:48.350 --> 00:02:51.710
which we sort of implicitly
defined in our previous lecture

00:02:51.710 --> 00:02:57.423
but didn't call it out, we're
going to notate with Adj+.

00:02:57.423 --> 00:02:59.090
And these are all of
the things that you

00:02:59.090 --> 00:03:02.250
can reach by going out of
a vertex into the next one.

00:03:02.250 --> 00:03:07.100
So for example, Adj+ of
w is going to be the set

00:03:07.100 --> 00:03:08.030
of vertices.

00:03:08.030 --> 00:03:12.270
We'll notice I can get from
w to y and also from w to z.

00:03:12.270 --> 00:03:12.770
Yeah.

00:03:12.770 --> 00:03:14.010
So.

00:03:14.010 --> 00:03:16.440
Nope, nope.

00:03:16.440 --> 00:03:19.120
y comma z.

00:03:19.120 --> 00:03:21.070
OK.

00:03:21.070 --> 00:03:24.382
So to continue just our tiny
amount of review for the day,

00:03:24.382 --> 00:03:26.590
remember that a graph--
there are many different ways

00:03:26.590 --> 00:03:28.013
to represent a graph.

00:03:28.013 --> 00:03:29.680
The sort of brain
dead one would be just

00:03:29.680 --> 00:03:31.090
like a big long list of edges.

00:03:31.090 --> 00:03:32.908
But of course,
for our algorithms

00:03:32.908 --> 00:03:34.450
it's not a particularly
efficient way

00:03:34.450 --> 00:03:38.240
to check things like, does
this edge exist in my graph.

00:03:38.240 --> 00:03:40.570
So the basic
representation that I

00:03:40.570 --> 00:03:42.770
think we're mostly working
from in this course

00:03:42.770 --> 00:03:46.300
is to think of a graph like a
set of vertices, each of which

00:03:46.300 --> 00:03:47.970
maps to another set of vertices.

00:03:47.970 --> 00:03:51.790
So roughly every vertex
maybe stores its outgoing set

00:03:51.790 --> 00:03:53.280
of edges.

00:03:53.280 --> 00:03:55.990
And so this is kind of
nice because, of course,

00:03:55.990 --> 00:03:57.980
very quickly we can
answer questions like,

00:03:57.980 --> 00:03:59.980
is this edge inside
of our graph?

00:03:59.980 --> 00:04:01.510
Or we can iterate
over the neighbors

00:04:01.510 --> 00:04:03.968
of a vertex and so on, which
are the kind of typical things

00:04:03.968 --> 00:04:06.610
that we do in a lot
of graph algorithms.

00:04:06.610 --> 00:04:09.410
And then finally, in
our previous lecture,

00:04:09.410 --> 00:04:10.900
we started talking about paths.

00:04:10.900 --> 00:04:13.600
So a path is like
a chain of vertices

00:04:13.600 --> 00:04:16.630
that can get me from one vertex
to the other only following

00:04:16.630 --> 00:04:18.339
edges of my graph.

00:04:18.339 --> 00:04:20.256
There is a term that
I think I forgot

00:04:20.256 --> 00:04:22.089
to define last time
because it didn't really

00:04:22.089 --> 00:04:25.630
matter a ton, which is a
simple path, which is just

00:04:25.630 --> 00:04:28.588
a path that doesn't have the
same vertex more than once.

00:04:28.588 --> 00:04:30.880
And then, of course, there
are many different questions

00:04:30.880 --> 00:04:33.670
you could ask about a
graph that are basically

00:04:33.670 --> 00:04:35.600
different problems
involving computing paths.

00:04:35.600 --> 00:04:38.300
So for instance, the shortest
path between two vertices

00:04:38.300 --> 00:04:41.110
is sort of our canonical
one in graph theory.

00:04:41.110 --> 00:04:44.030
Or you could ask questions
about reachability and so on.

00:04:44.030 --> 00:04:48.820
So there's our basic review
from our previous lecture.

00:04:48.820 --> 00:04:52.790
Does our course staff have any
questions about things so far?

00:04:52.790 --> 00:04:53.940
Excellent.

00:04:53.940 --> 00:04:54.440
OK.

00:04:54.440 --> 00:04:56.660
And there's one additional
piece of terminology

00:04:56.660 --> 00:04:59.450
that I fudged a little
bit last time-- or rather,

00:04:59.450 --> 00:05:02.250
my co-instructor suggested a
bit of an attitude adjustment.

00:05:02.250 --> 00:05:05.190
So I thought I'd better
clarify really quick.

00:05:05.190 --> 00:05:07.280
There's this interesting
phrase, linear time,

00:05:07.280 --> 00:05:10.640
which we all know and love
in computer science theory.

00:05:10.640 --> 00:05:13.172
And this sort of implicit thing,
especially in this course,

00:05:13.172 --> 00:05:14.630
is that when we
say linear time, we

00:05:14.630 --> 00:05:16.680
mean in the size of the input.

00:05:16.680 --> 00:05:17.180
Right?

00:05:17.180 --> 00:05:20.180
And so if we have a linear
time graph algorithm, well,

00:05:20.180 --> 00:05:22.712
how much space does it
take to store a graph?

00:05:22.712 --> 00:05:24.920
Well, we need a list of
vertices and a list of edges,

00:05:24.920 --> 00:05:26.310
if nothing else.

00:05:26.310 --> 00:05:29.453
So a reasonable way to interpret
this phrase linear time

00:05:29.453 --> 00:05:31.370
is that it's an algorithm
that looks like what

00:05:31.370 --> 00:05:33.000
we've shown on the screen.

00:05:33.000 --> 00:05:35.060
The times proportional
to maybe the sum

00:05:35.060 --> 00:05:37.370
of the number of vertices
and the number of edges.

00:05:37.370 --> 00:05:40.130
If that makes you uncomfortable
like it does for me because one

00:05:40.130 --> 00:05:41.960
of these can kind of
scale on the other,

00:05:41.960 --> 00:05:43.980
I think it's always
fine to add more detail.

00:05:43.980 --> 00:05:44.480
Right?

00:05:44.480 --> 00:05:46.310
So if you want to
say, linear in the sum

00:05:46.310 --> 00:05:49.440
of the number of vertices and
edges, that's perfectly fine.

00:05:49.440 --> 00:05:51.290
But if you see
this phrase, that's

00:05:51.290 --> 00:05:52.610
how you should interpret it.

00:05:52.610 --> 00:05:55.520
Hopefully that's a
fair way to put it.

00:05:55.520 --> 00:05:57.270
Excellent.

00:05:57.270 --> 00:05:57.770
OK.

00:05:57.770 --> 00:06:01.110
So last time, we talked about an
algorithm called breadth-first

00:06:01.110 --> 00:06:01.610
search--

00:06:01.610 --> 00:06:04.160
BFS, for those in the know.

00:06:04.160 --> 00:06:06.830
Breadth-first search
is an algorithm.

00:06:06.830 --> 00:06:08.540
And the reason we
use the word breadth

00:06:08.540 --> 00:06:10.910
is because it's kind of,
remember, we talked about level

00:06:10.910 --> 00:06:13.700
sets last time because we talked
about breadth-first search

00:06:13.700 --> 00:06:16.640
in the context of
computing shortest paths.

00:06:16.640 --> 00:06:20.210
And in particular, we have
our source node all the way

00:06:20.210 --> 00:06:21.410
on the left-hand side.

00:06:21.410 --> 00:06:23.750
And then breadth-first search
constructed all the nodes

00:06:23.750 --> 00:06:24.940
that were distance 1 away.

00:06:24.940 --> 00:06:25.440
Right.

00:06:25.440 --> 00:06:28.190
That's the first level set, and
then all the distance 2 away,

00:06:28.190 --> 00:06:30.890
and then all the distance
3 away, and so on.

00:06:30.890 --> 00:06:33.080
So in particular,
the level set L3

00:06:33.080 --> 00:06:34.910
isn't visited until
we're completely

00:06:34.910 --> 00:06:37.670
done with level set L2.

00:06:37.670 --> 00:06:40.880
Today, we're going to define
another algorithm, which

00:06:40.880 --> 00:06:43.220
is called depth-first search,
which doesn't do that,

00:06:43.220 --> 00:06:45.357
but rather, starts with
its first vertex and just

00:06:45.357 --> 00:06:47.940
starts walking all the way out
until it can't do that anymore.

00:06:47.940 --> 00:06:49.232
And then it kind of backtracks.

00:06:49.232 --> 00:06:50.940
That's one way to
think about it.

00:06:50.940 --> 00:06:53.330
And so somehow, in
breadth-first search,

00:06:53.330 --> 00:06:55.320
we're like, drawing
concentric circles.

00:06:55.320 --> 00:06:57.320
In depth-first search,
we're doing the opposite.

00:06:57.320 --> 00:06:58.550
We're like, shooting
outward until we

00:06:58.550 --> 00:07:00.410
reach the outer boundary,
and then exploring

00:07:00.410 --> 00:07:01.500
the graph that way.

00:07:01.500 --> 00:07:02.000
OK.

00:07:02.000 --> 00:07:03.740
And these are sort
of the two extremes

00:07:03.740 --> 00:07:08.060
in terms of graph search kind
of techniques that are typically

00:07:08.060 --> 00:07:10.340
used under the basic building
blocks for algorithms

00:07:10.340 --> 00:07:11.430
in graph theory.

00:07:11.430 --> 00:07:14.570
So in order to motivate and
think about depth-first search,

00:07:14.570 --> 00:07:16.760
we're going to define
a second problem, which

00:07:16.760 --> 00:07:20.070
is closely related to shortest
path, but not exactly the same.

00:07:20.070 --> 00:07:22.170
And that's the
reachability problem.

00:07:22.170 --> 00:07:26.310
So here I have the world's
simplest directed graph.

00:07:26.310 --> 00:07:28.340
So the black things
are the edges.

00:07:28.340 --> 00:07:31.940
And the circles are the
nodes or the vertices.

00:07:31.940 --> 00:07:34.670
And I've marked one
special node in blue.

00:07:34.670 --> 00:07:37.070
And his name is the source node.

00:07:37.070 --> 00:07:38.810
And now the question
I want to ask

00:07:38.810 --> 00:07:41.300
is, what are all of the
other nodes in my graph

00:07:41.300 --> 00:07:44.120
that I can reach by
following edges--

00:07:44.120 --> 00:07:47.460
directed edges--
starting with the source?

00:07:47.460 --> 00:07:49.070
So obviously, I
can get to the node

00:07:49.070 --> 00:07:50.680
in the lower right, no problem.

00:07:50.680 --> 00:07:52.220
And of course once
I get there, I

00:07:52.220 --> 00:07:54.590
can traverse and
edge upward to get

00:07:54.590 --> 00:07:57.170
to that second green vertex.

00:07:57.170 --> 00:07:59.210
Notice that I was
really sneaky and evil,

00:07:59.210 --> 00:08:01.790
and I drew edges in this
graph that might make you

00:08:01.790 --> 00:08:04.010
think that the red
node is reachable.

00:08:04.010 --> 00:08:05.510
The red one being
on the upper left.

00:08:05.510 --> 00:08:07.385
I'm realizing now that
for colorblind people,

00:08:07.385 --> 00:08:09.350
this isn't a great slide.

00:08:09.350 --> 00:08:12.110
But of course,
because all the edges

00:08:12.110 --> 00:08:14.840
from the red vertex on
the left here point out,

00:08:14.840 --> 00:08:18.170
I can't actually reach it
from the blue source node.

00:08:18.170 --> 00:08:20.030
So the reachability
problem is just

00:08:20.030 --> 00:08:24.110
asking, which nodes can I
reach from a given source?

00:08:24.110 --> 00:08:25.500
Pretty straightforward, I think.

00:08:25.500 --> 00:08:27.730
Of course, there are
many ways to solve this.

00:08:27.730 --> 00:08:28.230
Right?

00:08:28.230 --> 00:08:30.860
In fact, one way we
could do it would

00:08:30.860 --> 00:08:32.159
be to use our previous lecture.

00:08:32.159 --> 00:08:34.700
We could compute the shortest
path distance from the source

00:08:34.700 --> 00:08:35.992
to all the other nodes.

00:08:35.992 --> 00:08:37.909
And then what would the
length of the shortest

00:08:37.909 --> 00:08:40.429
path from the source to
an unreachable node be?

00:08:40.429 --> 00:08:42.890
Any thoughts from
our audience here?

00:08:42.890 --> 00:08:43.640
Infinity.

00:08:43.640 --> 00:08:46.130
Thank you, Professor Demaine.

00:08:46.130 --> 00:08:47.120
Right.

00:08:47.120 --> 00:08:51.260
So in addition to this, of
course, a totally reasonable

00:08:51.260 --> 00:08:54.017
question, thinking back to
our shortest path lecture,

00:08:54.017 --> 00:08:55.850
there are sort of two
queries we might make.

00:08:55.850 --> 00:08:56.350
Right?

00:08:56.350 --> 00:08:58.670
One is just what is the
length of the shortest path?

00:08:58.670 --> 00:09:01.070
The other is like, what is
the actual shortest path

00:09:01.070 --> 00:09:03.770
from the source
to a given vertex?

00:09:03.770 --> 00:09:06.380
We can ask a very similar
thing here, which is like, OK.

00:09:06.380 --> 00:09:09.440
You tell me that the green
guy is reachable, but how?

00:09:09.440 --> 00:09:12.680
Give me a path as evidence
or a certificate, if you

00:09:12.680 --> 00:09:14.520
want to be fancy about it.

00:09:14.520 --> 00:09:17.750
So in order to do that, just
like last time, remember,

00:09:17.750 --> 00:09:19.550
we defined a particular
data structure that

00:09:19.550 --> 00:09:21.110
was the shortest path tree.

00:09:21.110 --> 00:09:22.880
We can do something
very similar here.

00:09:22.880 --> 00:09:26.270
In particular, this is like the
extent of my PowerPoint skills

00:09:26.270 --> 00:09:28.010
here.

00:09:28.010 --> 00:09:32.270
If I have a
reachability problem,

00:09:32.270 --> 00:09:33.470
I can additionally store--

00:09:33.470 --> 00:09:35.480
I can decorate every
node in my graph

00:09:35.480 --> 00:09:37.680
with one other piece
of information,

00:09:37.680 --> 00:09:41.000
which is the previous
node along some path

00:09:41.000 --> 00:09:43.770
from my source to that thing.

00:09:43.770 --> 00:09:44.270
Right?

00:09:44.270 --> 00:09:46.160
And just like last
time, if I want

00:09:46.160 --> 00:09:50.430
to get an actual path from the
source to w, what could I do?

00:09:50.430 --> 00:09:52.070
I can start with w
and then just keep

00:09:52.070 --> 00:09:53.840
following those
parent relationships

00:09:53.840 --> 00:09:55.660
until I get back to the source.

00:09:55.660 --> 00:09:58.250
Then if I flip the order
of that list of vertices,

00:09:58.250 --> 00:10:02.590
I get a path from the source
to the target that's valid.

00:10:02.590 --> 00:10:04.340
So this object is
called a path tree, just

00:10:04.340 --> 00:10:06.740
like we talked-- or a
parent tree, rather.

00:10:06.740 --> 00:10:08.963
Just like we talked about
in our last lecture,

00:10:08.963 --> 00:10:11.630
there's no reason why this thing
should ever have a cycle in it.

00:10:11.630 --> 00:10:14.640
It's certainly a tree.

00:10:14.640 --> 00:10:15.140
Right.

00:10:15.140 --> 00:10:18.200
So that's the basic
reachability problem.

00:10:18.200 --> 00:10:20.780
And in addition to that, we
can compute this object P,

00:10:20.780 --> 00:10:23.390
which is going to give me
sort of information about how

00:10:23.390 --> 00:10:24.863
any given node was reachable.

00:10:24.863 --> 00:10:26.780
There's a slight difference
between the parent

00:10:26.780 --> 00:10:30.170
tree that I've defined here and
the shortest path tree, which

00:10:30.170 --> 00:10:33.140
I defined last time, which
is, I'm not going to require

00:10:33.140 --> 00:10:35.930
that the shortest path I
get-- oh, man-- the path

00:10:35.930 --> 00:10:40.490
I get when I backtrack along
my tree P is the shortest path,

00:10:40.490 --> 00:10:43.760
it's just a path because for
the reachability problem,

00:10:43.760 --> 00:10:45.560
I actually don't care.

00:10:45.560 --> 00:10:48.320
Like, I could have a weird,
circuitous, crazy long path.

00:10:48.320 --> 00:10:52.260
And it still tells me
that a node is reachable.

00:10:52.260 --> 00:10:52.760
Right.

00:10:52.760 --> 00:10:55.890
So that's our basic set
up and our data structure.

00:10:55.890 --> 00:10:59.042
And now we can introduce a
problem to solve reachability.

00:10:59.042 --> 00:11:00.500
Again, we already
have an algorithm

00:11:00.500 --> 00:11:03.170
for doing that, which is
to compute shortest paths.

00:11:03.170 --> 00:11:05.390
And remember that our
shortest path algorithm

00:11:05.390 --> 00:11:07.490
from previous lecture
took linear time

00:11:07.490 --> 00:11:08.810
and the size of the input.

00:11:08.810 --> 00:11:11.330
It took v plus e time.

00:11:11.330 --> 00:11:13.288
Now the question is, can
we do a little better?

00:11:13.288 --> 00:11:15.580
The answer, obviously, is
yes, because I just asked it,

00:11:15.580 --> 00:11:16.880
and I gave you this problem.

00:11:16.880 --> 00:11:18.030
OK.

00:11:18.030 --> 00:11:22.010
And here's a technique for doing
that, which unsurprisingly,

00:11:22.010 --> 00:11:23.780
is a recursive algorithm.

00:11:23.780 --> 00:11:27.830
I'm going to swap my notes
for my handwritten notes.

00:11:27.830 --> 00:11:30.920
And this algorithm is
called depth-first search.

00:11:30.920 --> 00:11:33.515
And here's the basic strategy.

00:11:33.515 --> 00:11:34.890
I'm going to choose
a source node

00:11:34.890 --> 00:11:36.817
and label that Node 1 here.

00:11:36.817 --> 00:11:38.900
I suppose it actually would
have made sense for me

00:11:38.900 --> 00:11:40.250
to actually 0 index this.

00:11:40.250 --> 00:11:43.010
Maybe in the slides
I'll fix it later.

00:11:43.010 --> 00:11:46.910
But in any event, I'm going
to mark my source node.

00:11:46.910 --> 00:11:50.630
And now I'm going to look at
every node, every edge coming

00:11:50.630 --> 00:11:53.300
out of that node, and I'm
going to visit it recursively.

00:11:53.300 --> 00:11:57.560
So that's our sort of for loop
inside of this function visit.

00:11:57.560 --> 00:11:59.240
And then for each
neighboring node,

00:11:59.240 --> 00:12:01.470
if I haven't visited it
before, in other words,

00:12:01.470 --> 00:12:03.590
I currently haven't
given it a parent.

00:12:03.590 --> 00:12:05.108
That's our if statement here.

00:12:05.108 --> 00:12:07.400
Then I'm going to say, well,
now they do have a parent.

00:12:07.400 --> 00:12:08.840
And that parent is me.

00:12:08.840 --> 00:12:10.477
And I'm going to recurse.

00:12:10.477 --> 00:12:11.810
You guys see what this is doing?

00:12:11.810 --> 00:12:14.390
It's kind of crawling
outward inside of our graph.

00:12:14.390 --> 00:12:17.600
So let's do the
example on the screen.

00:12:17.600 --> 00:12:20.990
And I purposefully designed this
experiment-- or this example--

00:12:20.990 --> 00:12:23.480
to look a little bit different
from breadth-first search,

00:12:23.480 --> 00:12:26.000
at least if you choose to
do the ordering that I did.

00:12:26.000 --> 00:12:28.010
So here's our graph.

00:12:28.010 --> 00:12:34.290
1, 2, 5, 3, 4.

00:12:34.290 --> 00:12:34.790
OK.

00:12:34.790 --> 00:12:37.198
And let's think about
the traversal order

00:12:37.198 --> 00:12:38.990
that the depth-first
search is going to do.

00:12:38.990 --> 00:12:39.460
Right.

00:12:39.460 --> 00:12:40.335
So here's our source.

00:12:43.090 --> 00:12:44.860
And now what does the source do?

00:12:44.860 --> 00:12:47.360
It rec-- so let's think
about our recursion tree.

00:12:47.360 --> 00:12:50.360
So we have the source
all the way up in here.

00:12:50.360 --> 00:12:52.810
And now he's going to
start calling the visit

00:12:52.810 --> 00:12:54.850
function recursively.

00:12:54.850 --> 00:12:56.500
So.

00:12:56.500 --> 00:12:59.500
And I'll go ahead and
number these the same as

00:12:59.500 --> 00:13:00.100
on the screen.

00:13:02.700 --> 00:13:04.680
Well, he has one
outgoing neighbor,

00:13:04.680 --> 00:13:06.133
and it hasn't been visited yet.

00:13:06.133 --> 00:13:08.550
So of course, the very first
recursive call that I'll make

00:13:08.550 --> 00:13:10.990
is to that neighbor 2.

00:13:10.990 --> 00:13:14.393
Now the neighbor
2 also recurses.

00:13:14.393 --> 00:13:16.060
Hopefully this kind
of schematic picture

00:13:16.060 --> 00:13:18.610
makes some sense, what
I'm trying to draw here.

00:13:18.610 --> 00:13:22.540
And well now, the 2 has
two neighbors, a 3 and a 5.

00:13:22.540 --> 00:13:24.040
So let's say that
we choose 3 first.

00:13:27.000 --> 00:13:29.277
Well, the 3 now
recurses and calls 4.

00:13:29.277 --> 00:13:31.110
And then the recursion
tree is kind of done.

00:13:31.110 --> 00:13:32.610
So now it goes back out.

00:13:32.610 --> 00:13:36.480
And then finally,
well, now, the 3--

00:13:36.480 --> 00:13:38.590
or, oh, boy.

00:13:38.590 --> 00:13:39.090
Yeah.

00:13:39.090 --> 00:13:41.940
The 2 looks at his next
neighbor, which is the 5

00:13:41.940 --> 00:13:43.800
and visits that recursively.

00:13:43.800 --> 00:13:46.830
Notice that this is not
following the level sets.

00:13:46.830 --> 00:13:47.460
Right?

00:13:47.460 --> 00:13:49.620
The depth-first search
algorithm got all the way

00:13:49.620 --> 00:13:52.740
to the end of my tree
in the recursive calls

00:13:52.740 --> 00:13:54.840
and then kind of backed
its way out to the 2

00:13:54.840 --> 00:13:56.225
before calling the 5.

00:13:56.225 --> 00:13:57.600
These are not the
same technique.

00:13:57.600 --> 00:14:01.085
One goes all the way to the end
and then kind of backtracks.

00:14:01.085 --> 00:14:02.460
When I say backtrack,
what I mean

00:14:02.460 --> 00:14:04.803
is the recursion is
kind of unraveling.

00:14:04.803 --> 00:14:07.470
Whereas in breadth-first search,
I visit everything in one level

00:14:07.470 --> 00:14:09.300
set before I work my way out.

00:14:09.300 --> 00:14:12.080
That distinction make sense?

00:14:12.080 --> 00:14:12.590
OK.

00:14:12.590 --> 00:14:14.882
So of course, we need to
prove that this algorithm does

00:14:14.882 --> 00:14:16.410
something useful.

00:14:16.410 --> 00:14:17.430
So let's do that now.

00:14:17.430 --> 00:14:21.170
So in particular, we
need a correctness proof.

00:14:21.170 --> 00:14:26.990
So our claim is
going to be that--

00:14:26.990 --> 00:14:36.740
let's see here-- the depth-first
search algorithm visits all,

00:14:36.740 --> 00:14:45.740
I guess reachable v,
and that it correctly

00:14:45.740 --> 00:14:47.900
sets the parent in the process.

00:14:56.650 --> 00:14:57.370
OK.

00:14:57.370 --> 00:15:00.862
So in order to prove
this, of course,

00:15:00.862 --> 00:15:02.570
as with almost everything
in this course,

00:15:02.570 --> 00:15:04.630
we're going to use induction.

00:15:04.630 --> 00:15:06.880
And in particular,
what we're going to do

00:15:06.880 --> 00:15:10.095
is do induction on the
distance from the source.

00:15:10.095 --> 00:15:11.470
So we're going to
say that, like,

00:15:11.470 --> 00:15:16.510
for all vertices in
distance k from the source,

00:15:16.510 --> 00:15:17.630
this statement is true.

00:15:17.630 --> 00:15:20.050
And then we're going to
prove this inductively on k.

00:15:20.050 --> 00:15:20.590
OK?

00:15:20.590 --> 00:15:26.770
So we want to do
induction on k, which

00:15:26.770 --> 00:15:33.020
is the distance to
the source vertex.

00:15:33.020 --> 00:15:35.410
So as with all of
our inductive proofs,

00:15:35.410 --> 00:15:38.570
we have to do our base case
and then our inductive step.

00:15:38.570 --> 00:15:42.460
So in the base case, k equals 0.

00:15:42.460 --> 00:15:44.140
This is a hella
easy case because,

00:15:44.140 --> 00:15:46.720
of course, what
is the thing that

00:15:46.720 --> 00:15:49.970
is distance 0 from the source?

00:15:49.970 --> 00:15:50.970
It's the source!

00:15:50.970 --> 00:15:51.470
Yeah.

00:15:51.470 --> 00:15:53.750
And take a look at our
strategy all the way

00:15:53.750 --> 00:15:55.010
at the top of the slide.

00:15:55.010 --> 00:15:58.347
We explicitly set the correct
parent for the source,

00:15:58.347 --> 00:16:00.680
and in some sense, visit it
because the very first thing

00:16:00.680 --> 00:16:02.455
we do is call visit of s.

00:16:02.455 --> 00:16:04.080
So there's kind of
nothing to say here.

00:16:04.080 --> 00:16:04.520
Yeah?

00:16:04.520 --> 00:16:06.470
Or there's plenty to say if
you write it on your homework.

00:16:06.470 --> 00:16:08.150
But your lazy
instructor is going

00:16:08.150 --> 00:16:10.310
to write a check mark here.

00:16:10.310 --> 00:16:12.630
OK.

00:16:12.630 --> 00:16:14.460
So now we have to do
our inductive step.

00:16:20.350 --> 00:16:23.100
So what does that mean?

00:16:23.100 --> 00:16:25.050
We're going to assume
that our statement is

00:16:25.050 --> 00:16:27.203
true for all nodes
within a distance k.

00:16:27.203 --> 00:16:29.370
And then we're going to
prove that the same thing is

00:16:29.370 --> 00:16:32.220
true for all nodes within
a distance k plus 1.

00:16:32.220 --> 00:16:33.360
OK.

00:16:33.360 --> 00:16:35.110
So let's do that.

00:16:35.110 --> 00:16:43.390
Let's consider a vertex v
that's distance k plus 1 away.

00:16:43.390 --> 00:16:45.990
So in other words, the
distance from the source to v

00:16:45.990 --> 00:16:48.750
is equal to k plus 1.

00:16:48.750 --> 00:16:49.750
And what's our goal?

00:16:49.750 --> 00:16:52.630
Our goal is to show that the
parent of v is set correctly.

00:16:52.630 --> 00:16:53.130
Yeah?

00:16:55.740 --> 00:16:57.170
What was that?

00:16:57.170 --> 00:16:58.827
AUDIENCE: [INAUDIBLE].

00:16:58.827 --> 00:16:59.910
JUSTIN SOLOMON: Oh, sorry.

00:16:59.910 --> 00:17:02.340
I forgot that the distances
in this class are in order.

00:17:02.340 --> 00:17:02.610
Yeah.

00:17:02.610 --> 00:17:03.610
That's absolutely right.

00:17:03.610 --> 00:17:07.075
So it should be the
distance from s to v. Yeah.

00:17:07.075 --> 00:17:07.575
Sorry.

00:17:07.575 --> 00:17:09.825
I'm really not used to
thinking about directed graphs.

00:17:09.825 --> 00:17:12.730
But that's a good fix.

00:17:12.730 --> 00:17:13.660
OK.

00:17:13.660 --> 00:17:15.589
So now what can we do?

00:17:15.589 --> 00:17:19.369
Well, there's this
number is distance here.

00:17:19.369 --> 00:17:22.810
So in particular, the
shortest path from s to v.

00:17:22.810 --> 00:17:25.602
So remember our argument
last time that essentially,

00:17:25.602 --> 00:17:28.060
when we look at shortest path
and we kind of truncate by 1,

00:17:28.060 --> 00:17:29.880
it's still shortest path?

00:17:29.880 --> 00:17:31.630
That property doesn't
matter so much here.

00:17:31.630 --> 00:17:33.100
But at least we
know that there's

00:17:33.100 --> 00:17:37.090
another vertex on the path,
which is 1 distance from one

00:17:37.090 --> 00:17:39.430
less away.

00:17:39.430 --> 00:17:45.910
So let's take u, which
is also a vertex,

00:17:45.910 --> 00:17:54.820
to be the previous node on
the shortest path from s

00:17:54.820 --> 00:17:57.140
to v. Right.

00:17:57.140 --> 00:18:01.790
And so in particular, we know
that the distance from s to u

00:18:01.790 --> 00:18:02.630
is equal to k.

00:18:02.630 --> 00:18:05.750
And conveniently, of course,
by our inductive hypothesis

00:18:05.750 --> 00:18:09.780
here, we know that our
property is true for this guy.

00:18:09.780 --> 00:18:10.590
OK.

00:18:10.590 --> 00:18:13.540
So now our algorithm,
what do we know?

00:18:13.540 --> 00:18:15.840
Well, because our
property is true,

00:18:15.840 --> 00:18:17.880
the visit function at
some point in its life

00:18:17.880 --> 00:18:20.030
is called on this vertex u.

00:18:20.030 --> 00:18:22.650
That's sort of what
our induction assumes.

00:18:22.650 --> 00:18:26.070
So we have two cases.

00:18:26.070 --> 00:18:26.580
Right.

00:18:26.580 --> 00:18:35.520
So when we visit u, we know
that when we call this visit

00:18:35.520 --> 00:18:40.080
function, well, remember that
v kind of by definition is

00:18:40.080 --> 00:18:41.400
in Adj+ of u.

00:18:41.400 --> 00:18:41.900
Right.

00:18:41.900 --> 00:18:51.450
So in particular, DGS
is going to consider v

00:18:51.450 --> 00:18:53.520
when it gets called.

00:18:53.520 --> 00:18:55.360
OK.

00:18:55.360 --> 00:18:56.710
And now there's two cases.

00:18:56.710 --> 00:18:57.790
Right?

00:18:57.790 --> 00:19:07.400
So either when this happens,
P of v does not equal None.

00:19:07.400 --> 00:19:07.947
Right.

00:19:07.947 --> 00:19:09.030
Well, what does that mean?

00:19:09.030 --> 00:19:12.320
Well, it means that we already
kind of found a suitable parent

00:19:12.320 --> 00:19:15.960
for v. And we're in good shape.

00:19:15.960 --> 00:19:21.720
Otherwise, p of v
does equal None.

00:19:21.720 --> 00:19:23.910
Well, in this case, the
very next line of code

00:19:23.910 --> 00:19:25.350
correctly sets the parent.

00:19:25.350 --> 00:19:27.030
And we're all set.

00:19:27.030 --> 00:19:31.300
So in both of these two cases,
we show that the parent of u

00:19:31.300 --> 00:19:33.690
was set correctly either
by that line of code

00:19:33.690 --> 00:19:35.890
right here or just previously.

00:19:35.890 --> 00:19:40.090
And so in either case,
our induction is done.

00:19:40.090 --> 00:19:40.840
All right.

00:19:40.840 --> 00:19:42.970
I guess given the
feedback I received

00:19:42.970 --> 00:19:47.920
from our previous lecture, we
now can end our LaTeX suitably.

00:19:47.920 --> 00:19:48.520
OK.

00:19:48.520 --> 00:19:49.880
So what did we just show?

00:19:49.880 --> 00:19:52.990
We showed that the depth-first
search algorithm can dig around

00:19:52.990 --> 00:19:55.420
in a graph and tell me
all of the things that

00:19:55.420 --> 00:19:58.900
are searchable, or rather, are
reachable from a given source,

00:19:58.900 --> 00:20:01.330
just basically by calling
visit on that source

00:20:01.330 --> 00:20:04.010
and then expanding
outward recursively.

00:20:04.010 --> 00:20:04.510
OK.

00:20:04.510 --> 00:20:06.910
So I think this is
certainly straightforward

00:20:06.910 --> 00:20:08.790
from an intuitive perspective.

00:20:08.790 --> 00:20:10.290
It's easy to get
lost when you write

00:20:10.290 --> 00:20:12.755
these kind of formal
induction proofs

00:20:12.755 --> 00:20:14.880
because they always feel
a tiny bit like tautology.

00:20:14.880 --> 00:20:17.005
So you should go home and
kind of convince yourself

00:20:17.005 --> 00:20:18.050
that it's not.

00:20:18.050 --> 00:20:18.550
OK.

00:20:18.550 --> 00:20:20.300
So of course, what do
we do in this class?

00:20:20.300 --> 00:20:22.470
We always follow the same
kind of boring pattern.

00:20:22.470 --> 00:20:24.660
The first thing we do,
define an algorithm.

00:20:24.660 --> 00:20:27.160
Second thing we do, make sure
that it's the right algorithm.

00:20:27.160 --> 00:20:28.702
What's the third
thing we need to do?

00:20:28.702 --> 00:20:29.577
AUDIENCE: Analyze it.

00:20:29.577 --> 00:20:30.868
JUSTIN SOLOMON: Analyze it.

00:20:30.868 --> 00:20:31.410
That's right.

00:20:31.410 --> 00:20:34.110
In particular, make sure that
it finishes before the heat

00:20:34.110 --> 00:20:35.670
death of the universe.

00:20:35.670 --> 00:20:38.640
And indeed, depth-first
research doesn't really

00:20:38.640 --> 00:20:41.080
take all that long,
which is a good thing.

00:20:41.080 --> 00:20:43.450
So let's think about this a bit.

00:20:43.450 --> 00:20:46.160
So what's going to
end up happening

00:20:46.160 --> 00:20:49.280
in depth-first
search, well, we're

00:20:49.280 --> 00:20:52.250
going to visit every vertex
at most once, kind of

00:20:52.250 --> 00:20:54.110
by definition here.

00:20:54.110 --> 00:20:56.870
And in each case, we're going
to just visit its neighboring

00:20:56.870 --> 00:20:58.070
edges.

00:20:58.070 --> 00:21:01.490
Can we ever traverse an
edge more than one time?

00:21:01.490 --> 00:21:01.990
No.

00:21:01.990 --> 00:21:02.140
Right.

00:21:02.140 --> 00:21:03.910
Because the visit
function only ever gets

00:21:03.910 --> 00:21:05.960
called one time per vertex.

00:21:05.960 --> 00:21:07.600
And our edges are directed.

00:21:07.600 --> 00:21:08.110
Right.

00:21:08.110 --> 00:21:12.220
So kind think about the from
of every edge, the from vertex

00:21:12.220 --> 00:21:13.690
is only ever visited one time.

00:21:13.690 --> 00:21:17.290
And hence, every edge is
only visited one time.

00:21:17.290 --> 00:21:19.030
Do we ever visit-- ah, yes.

00:21:19.030 --> 00:21:21.030
AUDIENCE: Does DFS work
for an undirected graph?

00:21:21.030 --> 00:21:22.530
JUSTIN SOLOMON: An
undirected graph.

00:21:22.530 --> 00:21:23.080
Absolutely.

00:21:23.080 --> 00:21:25.847
So there's sort of different
ways to think about it.

00:21:25.847 --> 00:21:27.430
One is to think of
an undirected graph

00:21:27.430 --> 00:21:29.085
like a directed
graph with two edges

00:21:29.085 --> 00:21:30.460
pointed either
way, which I think

00:21:30.460 --> 00:21:32.740
is in this class how we
actually kind of notated it

00:21:32.740 --> 00:21:33.740
in the previous lecture.

00:21:36.100 --> 00:21:36.600
Yeah.

00:21:36.600 --> 00:21:38.933
Actually, that's probably a
reasonable way to reduce it.

00:21:38.933 --> 00:21:41.010
So let's stick with that.

00:21:41.010 --> 00:21:41.790
Right.

00:21:41.790 --> 00:21:44.220
Now, does DFS ever
visit a vertex

00:21:44.220 --> 00:21:46.140
that is not reachable
from the source?

00:21:48.720 --> 00:21:51.030
Well, the answer is no
because all I ever do

00:21:51.030 --> 00:21:52.680
is recursively call
on my neighbors.

00:21:52.680 --> 00:21:55.470
And so kind of by definition,
if I'm not reachable,

00:21:55.470 --> 00:21:57.612
DFS will never see it.

00:21:57.612 --> 00:21:59.320
So if I think about
my runtime carefully,

00:21:59.320 --> 00:22:01.980
it's not quite the same
as breadth-first search.

00:22:01.980 --> 00:22:05.870
Remember that breadth-first
search took v plus e time.

00:22:05.870 --> 00:22:09.140
In depth-first search, it
just takes order e time

00:22:09.140 --> 00:22:12.050
because I'm expanding outward
from the source vertex,

00:22:12.050 --> 00:22:14.930
hitting every edge
adjacent to every vertex

00:22:14.930 --> 00:22:16.400
that I've seen so far.

00:22:16.400 --> 00:22:19.010
But I never reach a
vertex that I haven't--

00:22:19.010 --> 00:22:20.270
that isn't reachable.

00:22:20.270 --> 00:22:20.990
Right?

00:22:20.990 --> 00:22:24.170
And so because this only ever
touches every edge one time,

00:22:24.170 --> 00:22:25.837
we're in good shape.

00:22:25.837 --> 00:22:26.920
And I see a question here.

00:22:26.920 --> 00:22:27.420
Yeah.

00:22:27.420 --> 00:22:29.390
AUDIENCE: Does
BFS reach vertices

00:22:29.390 --> 00:22:31.550
that are not reachable?

00:22:31.550 --> 00:22:33.380
JUSTIN SOLOMON: Does
BFS reach vertices

00:22:33.380 --> 00:22:36.460
that are not reachable?

00:22:36.460 --> 00:22:38.090
I guess not, now
that you mention it.

00:22:38.090 --> 00:22:40.900
But at least in my
boring proof of order

00:22:40.900 --> 00:22:43.900
v time last time, our
very first step of BFS,

00:22:43.900 --> 00:22:47.080
reserve space
proportional to v, which

00:22:47.080 --> 00:22:49.777
is enough to already make
that runtime correct.

00:22:49.777 --> 00:22:50.360
Good question.

00:22:50.360 --> 00:22:50.560
Yeah.

00:22:50.560 --> 00:22:52.270
So I guess the way that
we've talked about it where

00:22:52.270 --> 00:22:54.700
you can stretch one little
set after a time, if you

00:22:54.700 --> 00:22:56.640
think of that as
reachability, then no.

00:22:56.640 --> 00:22:58.330
It doesn't reach
it in the for loop.

00:22:58.330 --> 00:23:00.790
But just by construction,
when we started

00:23:00.790 --> 00:23:04.267
we already took the time that
we're talking about here.

00:23:04.267 --> 00:23:06.350
So notice these run times
aren't exactly the same.

00:23:06.350 --> 00:23:09.430
So for example, if my
graph has no edges,

00:23:09.430 --> 00:23:14.320
BFS still is going to
take time because it still

00:23:14.320 --> 00:23:17.068
has to take order
v time, at least

00:23:17.068 --> 00:23:19.360
in the sort of brain-dead
way that we've implemented it

00:23:19.360 --> 00:23:19.750
last time.

00:23:19.750 --> 00:23:21.500
Obviously, in that
case, we could probably

00:23:21.500 --> 00:23:23.020
do something better.

00:23:23.020 --> 00:23:26.080
Whereas the way that we've
defined the DFS algorithm,

00:23:26.080 --> 00:23:28.510
it only takes edge time.

00:23:28.510 --> 00:23:30.380
I see confusion on
my instructor's face.

00:23:30.380 --> 00:23:30.880
No?

00:23:30.880 --> 00:23:31.630
OK.

00:23:31.630 --> 00:23:33.538
Good.

00:23:33.538 --> 00:23:35.080
The one thing to
notice is that these

00:23:35.080 --> 00:23:38.230
are algorithms for slightly
different tasks in some sense.

00:23:38.230 --> 00:23:40.660
The way that we wrote down
breadth-first search last time,

00:23:40.660 --> 00:23:42.658
conveniently, it gives
us the shortest path.

00:23:42.658 --> 00:23:44.950
There are breadth-first search
algorithms that doesn't.

00:23:44.950 --> 00:23:48.610
I think in this class we kind of
think of breadth-first search--

00:23:48.610 --> 00:23:50.960
we motivate it in terms of
the shortest path problem.

00:23:50.960 --> 00:23:53.470
But it's just kind of a
strategy of working outwards

00:23:53.470 --> 00:23:55.900
from a vertex.

00:23:55.900 --> 00:23:57.700
Whereas here, the way
we've written down

00:23:57.700 --> 00:24:00.372
depth-first search, there's no
reason why the path that we get

00:24:00.372 --> 00:24:01.330
should be the shortest.

00:24:01.330 --> 00:24:01.830
Right?

00:24:01.830 --> 00:24:05.440
So to think of a
really extreme example,

00:24:05.440 --> 00:24:07.030
let's say that I
have a cycle graph.

00:24:11.140 --> 00:24:14.150
So I get a big loop like this.

00:24:14.150 --> 00:24:16.660
Let's say that I do
depth-first search

00:24:16.660 --> 00:24:18.310
starting from this vertex.

00:24:18.310 --> 00:24:19.930
Well, what will happen?

00:24:19.930 --> 00:24:23.650
Well, this guy will call
its neighbor recursively,

00:24:23.650 --> 00:24:25.690
who will then call its
neighbor recursively,

00:24:25.690 --> 00:24:29.060
who will then call his neighbor
recursively, and so on.

00:24:29.060 --> 00:24:32.440
So of course, when I do
depth-first search, when

00:24:32.440 --> 00:24:35.320
I get to this vertex,
there's a chain of 1, 2, 3, 4

00:24:35.320 --> 00:24:37.450
vertices behind it.

00:24:37.450 --> 00:24:41.470
Is that the shortest path from
the source to the target here?

00:24:41.470 --> 00:24:42.250
Well, clearly not.

00:24:42.250 --> 00:24:42.610
Right?

00:24:42.610 --> 00:24:44.020
I could have
traversed that edge.

00:24:44.020 --> 00:24:46.140
I just chose not to.

00:24:46.140 --> 00:24:47.798
OK.

00:24:47.798 --> 00:24:49.590
So that's the depth-first
search algorithm.

00:24:49.590 --> 00:24:51.510
It's just essentially
a recursive strategy

00:24:51.510 --> 00:24:54.570
where I traverse
all my neighbors,

00:24:54.570 --> 00:24:56.940
and each of my neighbors
traverses their neighbors,

00:24:56.940 --> 00:24:58.870
and so on.

00:24:58.870 --> 00:24:59.370
OK.

00:24:59.370 --> 00:25:01.162
So why might we want
to use this algorithm?

00:25:01.162 --> 00:25:04.000
Well, we've already solved
the reachability problem.

00:25:04.000 --> 00:25:07.440
So let's solve a few more things
using the same basic strategy

00:25:07.440 --> 00:25:08.800
here.

00:25:08.800 --> 00:25:12.053
So there's some notions
that we've sort of--

00:25:12.053 --> 00:25:14.470
actually, in some sense, already
used in the lecture here.

00:25:14.470 --> 00:25:15.887
But we might as
well call them out

00:25:15.887 --> 00:25:19.240
for what they are, which is
this idea of connectivity.

00:25:19.240 --> 00:25:21.430
So a graph is
connected if there's

00:25:21.430 --> 00:25:25.480
a path getting from every
vertex to every other vertex.

00:25:25.480 --> 00:25:26.380
Right.

00:25:26.380 --> 00:25:28.060
Now connectivity
in a directed graph

00:25:28.060 --> 00:25:30.805
is kind of a weird object.

00:25:30.805 --> 00:25:32.680
Like, for instance,
think of a directed graph

00:25:32.680 --> 00:25:33.790
with just two edges.

00:25:33.790 --> 00:25:38.440
And one edge goes from u to
v. Then I can get from v to u,

00:25:38.440 --> 00:25:39.790
but not vise versa.

00:25:39.790 --> 00:25:42.460
That's kind of a weird notion.

00:25:42.460 --> 00:25:46.480
So here in 6006 we'll mostly
worry about connectivity only

00:25:46.480 --> 00:25:48.550
for undirected graphs
because they're--

00:25:48.550 --> 00:25:52.210
the vertices just basically come
in like, big connected clumps.

00:25:52.210 --> 00:25:54.640
Or the more technical term
for a big connected clump

00:25:54.640 --> 00:25:56.250
is a connected component.

00:25:56.250 --> 00:25:56.750
Yeah?

00:25:56.750 --> 00:25:58.740
So let's see an example.

00:25:58.740 --> 00:26:02.750
So let's say that I
have a graph, which has

00:26:02.750 --> 00:26:08.120
an edge and then a triangle.

00:26:08.120 --> 00:26:09.283
This is one graph.

00:26:09.283 --> 00:26:09.950
Do you see that?

00:26:09.950 --> 00:26:11.480
There's a collection
of vertices,

00:26:11.480 --> 00:26:13.730
and there's a
collection of edges.

00:26:13.730 --> 00:26:16.460
But it has two
connected components--

00:26:16.460 --> 00:26:19.560
the guy on the right
and the guy on the left,

00:26:19.560 --> 00:26:22.130
meaning that each
vertex here is reachable

00:26:22.130 --> 00:26:23.480
from every other vertex here.

00:26:23.480 --> 00:26:25.790
Each vertex here is reachable
from every vertex here.

00:26:25.790 --> 00:26:28.070
But there's no edge that
goes from the triangle

00:26:28.070 --> 00:26:29.550
to the line segment.

00:26:29.550 --> 00:26:30.260
Yeah?

00:26:30.260 --> 00:26:32.730
And so in the connected
components problem,

00:26:32.730 --> 00:26:35.420
we're given a graph
like this guy.

00:26:35.420 --> 00:26:37.080
And initially, we
don't, you know--

00:26:37.080 --> 00:26:37.580
OK.

00:26:37.580 --> 00:26:39.372
When I draw it like
this, it's pretty clear

00:26:39.372 --> 00:26:42.620
that my graph has two
connected components.

00:26:42.620 --> 00:26:45.080
Maybe my graph-embedding
algorithm failed

00:26:45.080 --> 00:26:46.910
and it drew an edge like that.

00:26:46.910 --> 00:26:48.140
Well, then maybe--

00:26:48.140 --> 00:26:49.730
I don't know-- it's still
pretty obvious that there's

00:26:49.730 --> 00:26:50.772
two connected components.

00:26:50.772 --> 00:26:52.850
But you can imagine
a universe where

00:26:52.850 --> 00:26:54.290
you don't know that a priori.

00:26:54.290 --> 00:26:56.150
And the problem
you're trying to solve

00:26:56.150 --> 00:26:58.460
is just to enumerate all
these clumps of vertices

00:26:58.460 --> 00:27:02.270
that are reachable from one
another in an undirected graph.

00:27:02.270 --> 00:27:05.600
And conveniently, we can
use depth-first search

00:27:05.600 --> 00:27:07.790
to solve this problem
pretty easily.

00:27:07.790 --> 00:27:08.690
Right?

00:27:08.690 --> 00:27:10.310
So how could we do it?

00:27:10.310 --> 00:27:14.750
Well, in some sense how can we
find one connected component?

00:27:14.750 --> 00:27:18.838
So let's say that I just
choose a vertex in my graph.

00:27:18.838 --> 00:27:20.380
Well, what do I know
about everything

00:27:20.380 --> 00:27:23.330
in its connected component?

00:27:23.330 --> 00:27:25.047
Well, it's reachable
from that vertex.

00:27:25.047 --> 00:27:27.380
Remember, we just solved the
reachability problem, which

00:27:27.380 --> 00:27:29.960
says, if I have a
vertex, I can now

00:27:29.960 --> 00:27:31.460
tell you all the
other vertices that

00:27:31.460 --> 00:27:33.540
are reachable from this guy.

00:27:33.540 --> 00:27:38.273
So I could call DFS on, well,
any vertex of this cycle here.

00:27:38.273 --> 00:27:39.440
Call the reachability thing.

00:27:39.440 --> 00:27:43.370
And I know that for every vertex
there's one of two things.

00:27:43.370 --> 00:27:46.730
Either the vertex has a
parent in that object P,

00:27:46.730 --> 00:27:48.510
or it's the source.

00:27:48.510 --> 00:27:50.660
So I can very easily find
the connected component

00:27:50.660 --> 00:27:51.980
corresponding to that vertex.

00:27:51.980 --> 00:27:53.930
Does that makes sense?

00:27:53.930 --> 00:27:56.290
Have I found all the
connected components?

00:27:56.290 --> 00:27:56.790
No.

00:27:56.790 --> 00:27:57.630
I found one.

00:27:57.630 --> 00:28:00.030
I found the one corresponding
to the arbitrary vertex

00:28:00.030 --> 00:28:02.080
that I just chose.

00:28:02.080 --> 00:28:04.530
So how could I fix this?

00:28:04.530 --> 00:28:05.530
Well, it's super simple.

00:28:05.530 --> 00:28:08.290
I could put a for loop on
the outside, which just loops

00:28:08.290 --> 00:28:10.390
over all the vertices, maybe.

00:28:10.390 --> 00:28:13.240
And if that vertex is not part
of a connected component yet,

00:28:13.240 --> 00:28:15.500
then I need to make a new one.

00:28:15.500 --> 00:28:17.410
So then I call DFS
on that vertex.

00:28:17.410 --> 00:28:19.360
I collect all the
vertices that I got.

00:28:19.360 --> 00:28:19.990
And I iterate.

00:28:19.990 --> 00:28:22.780
So this is the algorithm
that in this class

00:28:22.780 --> 00:28:24.965
we're going to call full DFS.

00:28:24.965 --> 00:28:26.590
By the way, you could
do the same thing

00:28:26.590 --> 00:28:27.882
with full breadth-first search.

00:28:27.882 --> 00:28:30.490
That's perfectly fine.

00:28:30.490 --> 00:28:32.180
Just kind of by analogy here.

00:28:32.180 --> 00:28:32.680
Right.

00:28:32.680 --> 00:28:36.340
So what is full D--

00:28:36.340 --> 00:28:38.890
oh, this chalk is easier.

00:28:38.890 --> 00:28:42.960
Well, I'm going to iterate
over all my vertices.

00:28:42.960 --> 00:28:44.730
Where I stands for for loop.

00:28:44.730 --> 00:28:48.510
Of-- right.

00:28:48.510 --> 00:28:55.650
So if v is unvisited,
then I'm going

00:28:55.650 --> 00:29:01.020
to do to DFS starting at v. I
guess we used visit to refer

00:29:01.020 --> 00:29:02.580
to this in the previous slide.

00:29:02.580 --> 00:29:03.955
And that's going
to kind of flood

00:29:03.955 --> 00:29:06.160
fill that whole
connected component.

00:29:06.160 --> 00:29:08.458
And then I can collect
that connected component

00:29:08.458 --> 00:29:09.000
and continue.

00:29:09.000 --> 00:29:11.320
We have to be a little bit
careful because, of course,

00:29:11.320 --> 00:29:13.030
we don't want like,
checking things--

00:29:13.030 --> 00:29:15.810
something to be visited to
somehow take a bunch of time

00:29:15.810 --> 00:29:17.948
and make my algorithm
slower than it needs to be.

00:29:17.948 --> 00:29:19.740
But of course, we have
a set data structure

00:29:19.740 --> 00:29:22.780
that we know can do that
and order one time at least

00:29:22.780 --> 00:29:25.240
in expectation.

00:29:25.240 --> 00:29:26.400
OK.

00:29:26.400 --> 00:29:29.580
So this is the
full DFS algorithm.

00:29:29.580 --> 00:29:30.510
It's really simple.

00:29:30.510 --> 00:29:33.540
Of DFS because I called
DGS on every vertex.

00:29:33.540 --> 00:29:36.790
And it's full because I
looped over all the vertices.

00:29:36.790 --> 00:29:37.290
Right.

00:29:37.290 --> 00:29:40.530
And so if we think about it, how
much time does this algorithm

00:29:40.530 --> 00:29:41.870
take?

00:29:41.870 --> 00:29:45.150
It's little bit sneaky
because somehow I

00:29:45.150 --> 00:29:47.027
have a for loop over
all the vertices.

00:29:47.027 --> 00:29:49.110
Then I could imagine a
universe where I get, like,

00:29:49.110 --> 00:29:51.943
vertices times some other number
because there's a for loop,

00:29:51.943 --> 00:29:53.610
and then there's
something inside of it.

00:29:53.610 --> 00:29:55.318
I think that's how
we're used to thinking

00:29:55.318 --> 00:29:58.345
about runtime of for loops.

00:29:58.345 --> 00:29:59.970
But in this case,
that actually doesn't

00:29:59.970 --> 00:30:02.410
happen because there's never
a case where an edge gets

00:30:02.410 --> 00:30:04.060
traversed more than one time.

00:30:04.060 --> 00:30:07.320
Because if I'm in one connected
component, then by definition,

00:30:07.320 --> 00:30:09.580
I can't be in another
connected component.

00:30:09.580 --> 00:30:10.080
Right?

00:30:10.080 --> 00:30:12.510
And so what happens
is, in some sense,

00:30:12.510 --> 00:30:15.090
this innocent
looking call to DFS--

00:30:15.090 --> 00:30:17.370
I suppose if you were like
a LISP or a programmer,

00:30:17.370 --> 00:30:18.662
you somehow wouldn't like this.

00:30:18.662 --> 00:30:20.970
It has a side effect,
which is that I marked

00:30:20.970 --> 00:30:23.010
all the vertices in that
connected component as

00:30:23.010 --> 00:30:24.480
"don't touch me again."

00:30:24.480 --> 00:30:25.080
Right.

00:30:25.080 --> 00:30:29.240
And so implicitly I kind of
removed edges in this process.

00:30:29.240 --> 00:30:30.840
So if you think
through it carefully,

00:30:30.840 --> 00:30:34.140
the runtime of this
full DFS algorithm

00:30:34.140 --> 00:30:37.710
is v plus e time
because every edge is

00:30:37.710 --> 00:30:40.270
touched no more than one time.

00:30:40.270 --> 00:30:44.343
Kind of amortized over all the
different calls to DGS here.

00:30:44.343 --> 00:30:46.010
And there's this for
loop over vertices.

00:30:46.010 --> 00:30:49.070
So there's clearly an
order v that you need here.

00:30:49.070 --> 00:30:51.240
Does that argument make sense?

00:30:51.240 --> 00:30:54.350
So again, we call that linear
in the size of the input.

00:30:54.350 --> 00:30:57.270
I'm going to say it as many
times to get it in my own head

00:30:57.270 --> 00:30:58.410
correctly.

00:30:58.410 --> 00:30:59.770
OK.

00:30:59.770 --> 00:31:00.270
Right.

00:31:00.270 --> 00:31:02.185
So this is the basic problem.

00:31:02.185 --> 00:31:03.810
This comes up all
the time, by the way.

00:31:03.810 --> 00:31:06.510
Like, it seems like somehow
a totally brain dead

00:31:06.510 --> 00:31:07.865
weird algorithm.

00:31:07.865 --> 00:31:09.990
Like, somehow, why would
you want an algorithm that

00:31:09.990 --> 00:31:10.920
finds connected components.

00:31:10.920 --> 00:31:13.295
Like, why would you even have
a graph that's disconnected

00:31:13.295 --> 00:31:13.996
or something?

00:31:13.996 --> 00:31:15.538
But of course, that
can happen a lot.

00:31:15.538 --> 00:31:19.110
So for instance, maybe you
work at a social media company,

00:31:19.110 --> 00:31:20.130
and people have friends.

00:31:20.130 --> 00:31:21.793
But like, Eric
and I are friends.

00:31:21.793 --> 00:31:23.460
And we're not friends
with anybody else.

00:31:23.460 --> 00:31:26.440
We have a-- there's like,
a blood oath kind of thing.

00:31:26.440 --> 00:31:30.030
Then that might be not so
easy to find in the graph

00:31:30.030 --> 00:31:33.540
because, of course, we're just
two among a sea of students

00:31:33.540 --> 00:31:35.970
in this classroom,
all of which have

00:31:35.970 --> 00:31:38.880
different interconnections
that are just enumerated based

00:31:38.880 --> 00:31:40.140
on the list of edges.

00:31:40.140 --> 00:31:43.050
And so even though
like, pictorially, it's

00:31:43.050 --> 00:31:46.993
kind of hard to draw a
connecting component algorithm

00:31:46.993 --> 00:31:48.660
in a way that doesn't
make it sound kind

00:31:48.660 --> 00:31:50.700
of like a useless
technique from the start,

00:31:50.700 --> 00:31:53.220
because it's very clear there
are two connected components

00:31:53.220 --> 00:31:53.970
there.

00:31:53.970 --> 00:31:56.012
Of course, we still have
to be able to write code

00:31:56.012 --> 00:31:58.780
to solve this sort of thing.

00:31:58.780 --> 00:31:59.400
OK.

00:31:59.400 --> 00:32:03.910
So for once, I think I'm almost
on time in lecture today.

00:32:03.910 --> 00:32:07.020
So we have one
additional application

00:32:07.020 --> 00:32:10.810
of depth-first search
in our class today,

00:32:10.810 --> 00:32:14.360
which is sort of on the
opposite end of the spectrum.

00:32:14.360 --> 00:32:18.000
So we just talked about
graphs that are undirected

00:32:18.000 --> 00:32:20.190
and thinking about cycles.

00:32:20.190 --> 00:32:23.910
Now, on the opposite end
we might think of a DAG.

00:32:23.910 --> 00:32:28.690
So a DAG is a Directed
Acyclic Graph.

00:32:28.690 --> 00:32:30.550
Can anyone think of a
special case of a DAG?

00:32:30.550 --> 00:32:32.008
I suppose I should
define it first.

00:32:32.008 --> 00:32:34.913
And then we'll come back to
that question, which means

00:32:34.913 --> 00:32:36.080
exactly what it sounds like.

00:32:36.080 --> 00:32:39.040
So it's a graph that
has directed edges now

00:32:39.040 --> 00:32:40.550
and doesn't have
any cycles in it.

00:32:40.550 --> 00:32:43.630
So actually, the
graph I gave you

00:32:43.630 --> 00:32:46.720
all the way at the beginning
of lecture I think secretly

00:32:46.720 --> 00:32:48.860
was an example of one of these.

00:32:48.860 --> 00:32:51.996
So let's say that I
have directed edges.

00:32:51.996 --> 00:32:53.593
Maybe if I make the
head a triangle,

00:32:53.593 --> 00:32:54.760
it's a little easier to see.

00:32:57.510 --> 00:32:59.000
I'm not so sure.

00:32:59.000 --> 00:33:01.912
In any event, so I'm going to
have an edge up and an edge

00:33:01.912 --> 00:33:03.620
to the right, and
similarly, an edge down

00:33:03.620 --> 00:33:04.662
and an edge to the right.

00:33:07.860 --> 00:33:09.930
This graph looks like a cycle.

00:33:09.930 --> 00:33:13.380
But it's not because the only
direction that I can move

00:33:13.380 --> 00:33:16.120
is from the left-hand side
to the right-hand side.

00:33:16.120 --> 00:33:17.543
So this is a directed graph.

00:33:17.543 --> 00:33:18.960
And it doesn't
contain any cycles,

00:33:18.960 --> 00:33:20.580
meaning there's no
path that it can

00:33:20.580 --> 00:33:23.400
take from a vertex that
gets back to itself

00:33:23.400 --> 00:33:25.570
along the directed edges.

00:33:25.570 --> 00:33:26.070
OK.

00:33:26.070 --> 00:33:27.320
And DAGs show up all the time.

00:33:27.320 --> 00:33:28.950
Now that I've defined
what a DAG is,

00:33:28.950 --> 00:33:30.690
can somebody give me
an example of a DAG

00:33:30.690 --> 00:33:35.862
that we've already seen in 6006?

00:33:35.862 --> 00:33:36.570
AUDIENCE: A tree.

00:33:36.570 --> 00:33:37.320
JUSTIN SOLOMON: A tree.

00:33:37.320 --> 00:33:39.653
At least if we orient all all
the edges kind of pointing

00:33:39.653 --> 00:33:40.560
downward in the tree.

00:33:40.560 --> 00:33:42.210
Yeah.

00:33:42.210 --> 00:33:44.850
Otherwise, it gets
kind of debatable over

00:33:44.850 --> 00:33:46.720
whether it's a DAG or not.

00:33:46.720 --> 00:33:48.930
If there's no direction
to the edges, then somehow

00:33:48.930 --> 00:33:51.850
the definition
just doesn't apply.

00:33:51.850 --> 00:33:52.350
OK.

00:33:52.350 --> 00:33:56.587
So in processing
directed acyclic graphs,

00:33:56.587 --> 00:33:58.170
there's a really
useful thing that you

00:33:58.170 --> 00:34:00.620
can do that's going to show
up in this class apparently

00:34:00.620 --> 00:34:02.620
quite a bit, which is
kind of interesting to me,

00:34:02.620 --> 00:34:05.000
I'm curious to see
what that looks like,

00:34:05.000 --> 00:34:09.637
which is to compute a
topological order on the graph.

00:34:09.637 --> 00:34:10.679
We're at topologies here.

00:34:10.679 --> 00:34:14.370
So as a geometry professor in
my day job, I get all excited.

00:34:14.370 --> 00:34:16.230
But in this case,
a topological order

00:34:16.230 --> 00:34:18.318
is a fairly
straightforward thing.

00:34:18.318 --> 00:34:19.860
Actually, it's
defined on the screen,

00:34:19.860 --> 00:34:21.277
and I have bad
handwriting anyway.

00:34:21.277 --> 00:34:22.565
So let's just stick with that.

00:34:22.565 --> 00:34:23.565
So topological ordering.

00:34:23.565 --> 00:34:27.750
So we think of f as a function
that assigns maybe every node

00:34:27.750 --> 00:34:29.037
an index in array.

00:34:29.037 --> 00:34:30.870
I guess I shouldn't use
the word array here.

00:34:30.870 --> 00:34:32.670
But just like an
index, an ordering.

00:34:32.670 --> 00:34:34.550
So like, this is
the first vertex.

00:34:34.550 --> 00:34:35.800
And this is the second vertex.

00:34:35.800 --> 00:34:37.050
And so on.

00:34:37.050 --> 00:34:39.570
Then a topological
order is one that

00:34:39.570 --> 00:34:41.070
has the properties
shown here, which

00:34:41.070 --> 00:34:46.770
is that if I have a directed
edge from u to v, then f of u

00:34:46.770 --> 00:34:51.610
is less than f of v.
So in other words,

00:34:51.610 --> 00:34:54.719
if I look at the ordering that
I get on my topological order,

00:34:54.719 --> 00:34:57.697
u has to appear before v. Yeah?

00:34:57.697 --> 00:34:59.030
Let's look at our example again.

00:34:59.030 --> 00:35:01.820
So let's give our nodes names.

00:35:01.820 --> 00:35:08.470
So here's A, B, C,
D. Well, what clearly

00:35:08.470 --> 00:35:11.390
has to be the first node
in my topological order?

00:35:11.390 --> 00:35:12.240
A. Right.

00:35:12.240 --> 00:35:13.990
It goes all the way
to the left-hand side.

00:35:13.990 --> 00:35:16.270
Yeah.

00:35:16.270 --> 00:35:18.123
Well, after that it's
a bit of a toss-up.

00:35:18.123 --> 00:35:18.790
What do we know?

00:35:18.790 --> 00:35:22.620
We know that B and C have to
appear before D. So maybe just

00:35:22.620 --> 00:35:28.160
to be annoying, I do A, C,
B-- that's a B-- and then D.

00:35:28.160 --> 00:35:29.683
So it's a topological order.

00:35:29.683 --> 00:35:31.100
Notice that things
that are on the

00:35:31.100 --> 00:35:34.370
left appear in my graph before
things that are on the right,

00:35:34.370 --> 00:35:36.470
where the word
"before" here means

00:35:36.470 --> 00:35:39.530
that there's an edge that
points from one to the other.

00:35:39.530 --> 00:35:40.820
OK.

00:35:40.820 --> 00:35:45.110
By the way, are topological
orderings unique?

00:35:45.110 --> 00:35:45.610
No.

00:35:45.610 --> 00:35:47.790
So if we look at our
graph example here,

00:35:47.790 --> 00:35:53.610
ABCD is also a
topological order.

00:35:53.610 --> 00:35:55.950
And what that means is
somehow very liberating.

00:35:55.950 --> 00:35:57.750
It means that when we
design an algorithm

00:35:57.750 --> 00:36:00.480
for finding a topological
order, so there's some design

00:36:00.480 --> 00:36:01.860
decisions that we can make.

00:36:01.860 --> 00:36:04.650
And we just have to
find one among many.

00:36:04.650 --> 00:36:09.000
But in any event, we're going
to define a slightly different

00:36:09.000 --> 00:36:09.810
notion of order.

00:36:09.810 --> 00:36:10.920
And then we're going to
show that they're closely

00:36:10.920 --> 00:36:12.420
linked to each other.

00:36:12.420 --> 00:36:15.097
And that is the finishing order.

00:36:15.097 --> 00:36:16.680
So in the finishing
order, we're going

00:36:16.680 --> 00:36:19.185
to call full DFS on our graph.

00:36:19.185 --> 00:36:21.310
Remember, that means we
iterate over all our nodes.

00:36:21.310 --> 00:36:24.450
And if we haven't seen that
node yet, we call DFS on it.

00:36:24.450 --> 00:36:28.410
And now we're going to
make an order in which

00:36:28.410 --> 00:36:31.530
as soon as the call to a
node in that visit function

00:36:31.530 --> 00:36:33.600
is complete,
meaning I've already

00:36:33.600 --> 00:36:36.180
iterated over all
my neighbors, then

00:36:36.180 --> 00:36:39.413
I add my node to the ordering.

00:36:39.413 --> 00:36:40.080
That make sense?

00:36:40.080 --> 00:36:41.510
It's like a little
bit backward from what

00:36:41.510 --> 00:36:42.718
we're used to thinking about.

00:36:42.718 --> 00:36:44.960
So it's the order
in which full DFS

00:36:44.960 --> 00:36:48.020
finishes visiting each vertex.

00:36:48.020 --> 00:36:49.190
Yeah?

00:36:49.190 --> 00:36:53.240
And now here's the
claim, is that if we

00:36:53.240 --> 00:36:55.340
have a reverse
finishing order, meaning

00:36:55.340 --> 00:36:58.070
that we take the finishing order
and then we flip it backward.

00:36:58.070 --> 00:37:01.220
That's exactly going to give
us a topological ordering

00:37:01.220 --> 00:37:03.950
of the vertices in our graph.

00:37:03.950 --> 00:37:04.660
Right.

00:37:04.660 --> 00:37:07.922
So let's do that really quickly.

00:37:07.922 --> 00:37:09.380
So in other words,
our claim here--

00:37:12.170 --> 00:37:15.030
I think, yeah, let's
see-- is that if I

00:37:15.030 --> 00:37:16.110
have a directed graph.

00:37:18.840 --> 00:37:22.670
So G is a DAG.

00:37:22.670 --> 00:37:27.740
Then let's see here.

00:37:27.740 --> 00:37:30.652
Then the-- oops.

00:37:30.652 --> 00:37:31.610
My notes are backwards.

00:37:31.610 --> 00:37:32.945
So I should switch to my--

00:37:32.945 --> 00:37:35.150
Jason's notes, which
of course, are correct.

00:37:41.220 --> 00:37:41.820
Right.

00:37:41.820 --> 00:37:44.250
So if I have a
graph that's a DAG,

00:37:44.250 --> 00:37:54.790
then the reverse of
the finishing order

00:37:54.790 --> 00:37:56.320
is a topological order.

00:38:01.920 --> 00:38:04.620
By the way, we're not going to
prove the converse that if I

00:38:04.620 --> 00:38:08.190
have a topological order,
that somehow that thing is

00:38:08.190 --> 00:38:13.348
the reverse of DFS, at least
the way that maybe I coded it.

00:38:13.348 --> 00:38:15.390
There's a slightly different
statement, which is,

00:38:15.390 --> 00:38:18.750
does there exist a DFS
that has that ordering?

00:38:18.750 --> 00:38:21.570
But that's one that we'll
worry about another time

00:38:21.570 --> 00:38:23.220
around piazza or whatever.

00:38:23.220 --> 00:38:23.760
OK.

00:38:23.760 --> 00:38:27.630
So let's see here.

00:38:27.630 --> 00:38:28.950
So we need to prove this thing.

00:38:28.950 --> 00:38:30.075
So what are we going to do?

00:38:30.075 --> 00:38:32.600
Well, what do we need to
check is the topological order

00:38:32.600 --> 00:38:34.730
is that if I look at
any edge of my graph,

00:38:34.730 --> 00:38:38.180
it obeys the relationship that
I have on the screen here.

00:38:38.180 --> 00:38:40.490
So in particularly,
we're going to take

00:38:40.490 --> 00:38:44.480
uv inside of my set of edges.

00:38:44.480 --> 00:38:51.070
And then what I
need is that u is

00:38:51.070 --> 00:38:59.140
ordered before v using the
reverse of the finishing order

00:38:59.140 --> 00:39:00.820
that we've defined here.

00:39:00.820 --> 00:39:02.110
OK.

00:39:02.110 --> 00:39:06.790
So let's think back to our
call to the DFS algorithm,

00:39:06.790 --> 00:39:09.140
where call this visit function.

00:39:09.140 --> 00:39:09.640
Right.

00:39:09.640 --> 00:39:11.650
So we have two cases.

00:39:11.650 --> 00:39:15.430
Either u is visited
before v. Or it ain't.

00:39:15.430 --> 00:39:16.660
Yeah.

00:39:16.660 --> 00:39:18.475
So let's do those two cases.

00:39:22.080 --> 00:39:33.520
So case Number 1 is, u
is visited before v. OK.

00:39:40.780 --> 00:39:41.380
All right.

00:39:41.380 --> 00:39:42.680
So what does that mean?

00:39:42.680 --> 00:39:44.482
Well, remember that
there's an edge.

00:39:44.482 --> 00:39:45.940
Like, pictorially,
what's going on?

00:39:45.940 --> 00:39:47.983
Well, there's all kinds
of graph stuff going on.

00:39:47.983 --> 00:39:48.775
And then there's u.

00:39:48.775 --> 00:39:51.490
And we know that there's
a directed edge from u

00:39:51.490 --> 00:39:53.870
to v. That's our picture.

00:39:53.870 --> 00:39:54.370
Right?

00:39:54.370 --> 00:39:57.820
And maybe there's other
stuff going on outside of us.

00:39:57.820 --> 00:40:00.790
So in particular,
well, just by the way

00:40:00.790 --> 00:40:03.380
that we've defined that visit
function, what do we know?

00:40:03.380 --> 00:40:10.450
We know that when we
call visit on u, well,

00:40:10.450 --> 00:40:12.500
v is one of its
outgoing neighbors.

00:40:12.500 --> 00:40:14.470
So in particular,
a visit on u is

00:40:14.470 --> 00:40:22.930
going to call visit v. And
we know that because well, u

00:40:22.930 --> 00:40:25.270
is visited before v.

00:40:25.270 --> 00:40:28.240
So currently, v's
parent is l when

00:40:28.240 --> 00:40:32.770
I get to you That make sense?

00:40:32.770 --> 00:40:34.940
Now, here's where
reverse ordering,

00:40:34.940 --> 00:40:37.540
we're going have to keep
it in our head because now,

00:40:37.540 --> 00:40:42.580
well, visit of u calls visit
of v. So notice that visit of v

00:40:42.580 --> 00:40:47.080
has to complete
before visit of u.

00:40:47.080 --> 00:40:47.580
Right?

00:40:52.020 --> 00:41:00.470
V completes before visit of u.

00:41:00.470 --> 00:41:00.970
Well.

00:41:00.970 --> 00:41:05.040
So in reverse, sorting--

00:41:05.040 --> 00:41:08.200
in reverse finishing order
here, what does that mean?

00:41:08.200 --> 00:41:11.310
Well, if this completes before
the other guy, then they get

00:41:11.310 --> 00:41:13.170
flipped backward
in the list, which

00:41:13.170 --> 00:41:16.950
is exactly what I want because
there's an edge from u to v.

00:41:16.950 --> 00:41:17.450
OK.

00:41:17.450 --> 00:41:19.620
So Case 1 is done.

00:41:19.620 --> 00:41:26.490
Now we have Case 2, which is
that v is visited before u.

00:41:33.570 --> 00:41:35.130
OK.

00:41:35.130 --> 00:41:38.740
So now I'm going to make
one additional observation.

00:41:38.740 --> 00:41:39.240
OK.

00:41:39.240 --> 00:41:41.370
So now I'm going to go
back to my other notes

00:41:41.370 --> 00:41:42.828
because I like my
schematic better.

00:41:45.740 --> 00:41:46.700
Right.

00:41:46.700 --> 00:41:50.380
So what's our
basic picture here?

00:41:50.380 --> 00:41:50.940
Oh, no.

00:41:50.940 --> 00:41:52.600
I-- Oh, you know what it was?

00:41:52.600 --> 00:41:54.090
I printed out
another copy of this.

00:41:54.090 --> 00:41:54.590
That's OK.

00:41:54.590 --> 00:41:56.020
I can do it off
the top of my head.

00:41:56.020 --> 00:41:56.520
OK.

00:41:56.520 --> 00:41:58.210
So here's my source vertex.

00:41:58.210 --> 00:42:03.550
His name is S. Now, there's a
bunch of edges and whatever.

00:42:03.550 --> 00:42:05.680
There's a long path.

00:42:05.680 --> 00:42:08.630
And now eventually,
what happens?

00:42:08.630 --> 00:42:09.130
Well.

00:42:09.130 --> 00:42:13.720
I have a node v. And
somewhere out there

00:42:13.720 --> 00:42:16.620
in the universe
is another node u.

00:42:16.620 --> 00:42:17.500
And what do I know?

00:42:17.500 --> 00:42:19.980
I know that by
assumption, I know

00:42:19.980 --> 00:42:23.380
that there's an edge from
u to v. That make sense?

00:42:23.380 --> 00:42:25.900
So that's our sort
of picture so far.

00:42:25.900 --> 00:42:27.090
OK.

00:42:27.090 --> 00:42:28.360
So what do we know?

00:42:28.360 --> 00:42:30.840
We know that our
graph is acyclic.

00:42:30.840 --> 00:42:31.530
Yeah?

00:42:31.530 --> 00:42:33.820
Kind of by definition,
that's our assumption.

00:42:33.820 --> 00:42:38.570
So can we reach u from v?

00:42:38.570 --> 00:42:42.992
In other words, does there
exist a path from v to u?

00:42:42.992 --> 00:42:44.200
So that would look like this.

00:42:49.200 --> 00:42:52.720
No because our graph is acyclic,
and I just drew a cycle.

00:42:52.720 --> 00:42:56.010
So this is a big X.
There's a frowny face here.

00:42:56.010 --> 00:42:57.370
Can't do it.

00:42:57.370 --> 00:42:59.930
He has hair, unlike
your instructor.

00:42:59.930 --> 00:43:00.580
OK.

00:43:00.580 --> 00:43:01.810
So right.

00:43:01.810 --> 00:43:03.200
So what does this mean?

00:43:03.200 --> 00:43:04.030
Well, OK.

00:43:04.030 --> 00:43:10.330
So by this picture, I suppose,
we know that u cannot be

00:43:10.330 --> 00:43:13.984
reached from v.

00:43:20.160 --> 00:43:21.930
Yeah.

00:43:21.930 --> 00:43:23.230
So what does that mean?

00:43:23.230 --> 00:43:25.710
Well, it means
that the visit to v

00:43:25.710 --> 00:43:28.650
is going to complete
and never see u

00:43:28.650 --> 00:43:31.410
because remember, the visit to
v only ever call things that

00:43:31.410 --> 00:43:39.210
are kind of descendants of v.
So in other words, visit of v

00:43:39.210 --> 00:43:45.130
completes without seeing u.

00:43:50.412 --> 00:43:51.870
Well, that's exactly
the same thing

00:43:51.870 --> 00:43:53.100
that we showed in
our first case.

00:43:53.100 --> 00:43:53.600
Right?

00:43:53.600 --> 00:43:56.580
So by the same reasoning,
what does that mean?

00:43:56.580 --> 00:44:00.930
In our reverse finishing
order, the ordering from u to v

00:44:00.930 --> 00:44:02.530
is preserved.

00:44:02.530 --> 00:44:03.030
OK.

00:44:03.030 --> 00:44:05.130
So that sort of
completes our proof

00:44:05.130 --> 00:44:07.770
here that reverse
finishing order gives me

00:44:07.770 --> 00:44:10.980
a topological order,
which is kind of nice.

00:44:10.980 --> 00:44:12.660
And so this is a
nice convenient way

00:44:12.660 --> 00:44:16.740
of taking all of the nodes
in a directed acyclic graph

00:44:16.740 --> 00:44:18.450
and ordering them in
a way that respects

00:44:18.450 --> 00:44:22.090
the topology or the
connectivity of that graph.

00:44:22.090 --> 00:44:25.440
So we're going to conclude
with one final problem, which

00:44:25.440 --> 00:44:26.520
I don't have a slide on.

00:44:26.520 --> 00:44:27.540
But that's OK.

00:44:27.540 --> 00:44:29.890
And that's cycle detection.

00:44:29.890 --> 00:44:36.090
So there's a bit of an exercise
left to the reader here.

00:44:36.090 --> 00:44:44.040
So the problem that
we're looking for now

00:44:44.040 --> 00:44:47.985
is that we're given
a directed graph.

00:44:52.440 --> 00:44:55.500
There's a G in graph, in
case you're wondering.

00:44:55.500 --> 00:44:58.600
But now, we don't know
if it's a DAG or not.

00:44:58.600 --> 00:45:01.200
And so the question that
we're trying to ask is,

00:45:01.200 --> 00:45:08.705
does there exist a cycle in
our directed acyclic graph?

00:45:08.705 --> 00:45:10.830
So we're just given our
graph, and we want to know,

00:45:10.830 --> 00:45:13.230
can we do this?

00:45:13.230 --> 00:45:15.628
Let's think through the
logic of this a bit.

00:45:15.628 --> 00:45:16.420
So what do we know?

00:45:16.420 --> 00:45:22.140
We know that if our
graph were a DAG, then

00:45:22.140 --> 00:45:25.365
I could call DGS,
get the ordering out,

00:45:25.365 --> 00:45:27.240
and then I guess flip
its ordering backwards.

00:45:27.240 --> 00:45:30.090
So I could compute the
reverse finishing order.

00:45:30.090 --> 00:45:34.190
And it would give me a
topological order of my graph.

00:45:34.190 --> 00:45:37.630
So if I were a DAG, I would
get a topological order

00:45:37.630 --> 00:45:40.425
when I call DFS.

00:45:40.425 --> 00:45:43.940
So let's say that I ran DFS.

00:45:43.940 --> 00:45:46.093
I got whatever ordering I got.

00:45:46.093 --> 00:45:48.510
And now I found an edge the
points in the wrong direction.

00:45:48.510 --> 00:45:50.810
I can just double
check my list of edges,

00:45:50.810 --> 00:45:54.470
and I find one that does not
respect the relationship that I

00:45:54.470 --> 00:45:57.580
see in the second
bullet point here.

00:45:57.580 --> 00:46:00.350
Can my graph be a DAG?

00:46:00.350 --> 00:46:00.850
No.

00:46:00.850 --> 00:46:03.750
Because if my graph were a
DAG, the algorithm would work.

00:46:03.750 --> 00:46:04.750
I just proved it to you.

00:46:04.750 --> 00:46:05.320
Right?

00:46:05.320 --> 00:46:08.200
So if my graph
were a DAG, then I

00:46:08.200 --> 00:46:10.000
could do reverse
finishing order.

00:46:10.000 --> 00:46:12.380
And what I would get back
is a topological order.

00:46:12.380 --> 00:46:14.970
So if I found a certificate that
my order wasn't topological,

00:46:14.970 --> 00:46:17.470
something went wrong, and the
only thing that could go wrong

00:46:17.470 --> 00:46:19.670
is that my graph isn't a DAG.

00:46:19.670 --> 00:46:20.170
Yeah.

00:46:20.170 --> 00:46:21.590
Isn't a DAG.

00:46:21.590 --> 00:46:24.610
In fact, sort of an exercise
left to the reader and/or

00:46:24.610 --> 00:46:26.530
to your section-- do
we still have section?

00:46:26.530 --> 00:46:29.050
I think we do, as of now--

00:46:29.050 --> 00:46:32.275
is that this is an if
and only if, meaning

00:46:32.275 --> 00:46:35.740
that the only time that you
even have a topological ordering

00:46:35.740 --> 00:46:39.400
in your graph is if
your graph is a DAG.

00:46:39.400 --> 00:46:41.900
This is a really easy fact
to sanity check, by the way.

00:46:41.900 --> 00:46:43.630
This is not like, a particularly
challenging problem.

00:46:43.630 --> 00:46:46.130
But you should think through
it because it's a good exercise

00:46:46.130 --> 00:46:48.370
to make sure you understand
the definitions, which

00:46:48.370 --> 00:46:51.010
is to say that if you
have a topological order,

00:46:51.010 --> 00:46:52.120
your graph is a DAG.

00:46:52.120 --> 00:46:55.775
If you don't have a topological
order, your graph isn't a DAG.

00:46:55.775 --> 00:46:57.400
So in other words,
we secretly gave you

00:46:57.400 --> 00:47:00.410
an algorithm for checking
if a graph is a DAG at all.

00:47:00.410 --> 00:47:00.910
Right?

00:47:00.910 --> 00:47:01.910
What could I do?

00:47:01.910 --> 00:47:04.360
I could compute reverse
finishing order.

00:47:04.360 --> 00:47:06.280
Check if it obeys
the relationship

00:47:06.280 --> 00:47:08.410
on the second bullet
point here for every edge.

00:47:08.410 --> 00:47:10.130
And if it does, then
we're in good shape.

00:47:10.130 --> 00:47:11.530
My graph is a DAG.

00:47:11.530 --> 00:47:13.030
If it doesn't,
something went wrong.

00:47:13.030 --> 00:47:14.905
And the only thing that
could have gone wrong

00:47:14.905 --> 00:47:16.590
is not being a DAG.

00:47:16.590 --> 00:47:17.610
OK.

00:47:17.610 --> 00:47:21.050
So in other words,
secretly we just solved--

00:47:21.050 --> 00:47:23.050
well, I guess the way
that I've written it here,

00:47:23.050 --> 00:47:26.240
we've solved the cycle
detection problem here,

00:47:26.240 --> 00:47:29.560
which is to say that,
well, I have a cycle if

00:47:29.560 --> 00:47:32.380
and only if I'm
not a DAG, which I

00:47:32.380 --> 00:47:33.830
can check using this technique.

00:47:33.830 --> 00:47:35.980
Of course, the word
"detection" here probably means

00:47:35.980 --> 00:47:37.647
that I actually want
to find that cycle,

00:47:37.647 --> 00:47:39.680
and I haven't told you
how to do that yet.

00:47:39.680 --> 00:47:42.400
All we know how to do so
far is say, like, somewhere

00:47:42.400 --> 00:47:43.660
in this graph there's a cycle.

00:47:43.660 --> 00:47:45.520
And that's not so good.

00:47:45.520 --> 00:47:47.890
So we can do one additional
piece of information

00:47:47.890 --> 00:47:50.680
in the two minutes we have
remaining to sort of complete

00:47:50.680 --> 00:47:54.100
our story here, which is to
modify our algorithm ever so

00:47:54.100 --> 00:47:57.100
slightly to not only say thumbs
up, thumbs down, is there

00:47:57.100 --> 00:47:59.800
a cycle in this graph, but also
to actually return the vertices

00:47:59.800 --> 00:48:01.690
as a cycle.

00:48:01.690 --> 00:48:03.520
And here's the
property that we're

00:48:03.520 --> 00:48:06.980
going to do that,
which is following,

00:48:06.980 --> 00:48:20.370
which is that if G contains
a cycle, right, then

00:48:20.370 --> 00:48:31.580
full DFS will traverse
an edge from a vertex v

00:48:31.580 --> 00:48:38.990
to some ancestor of v. I guess
we haven't carefully defined

00:48:38.990 --> 00:48:40.540
the term "ancestor" here.

00:48:40.540 --> 00:48:45.995
Essentially, if you think of the
sort of the running of the DFS

00:48:45.995 --> 00:48:47.870
algorithm, then an
ancestor is like something

00:48:47.870 --> 00:48:52.050
that appears in the recursive
call tree before I got to v.

00:48:52.050 --> 00:48:52.580
OK.

00:48:52.580 --> 00:48:54.840
So how could we prove that?

00:48:54.840 --> 00:48:58.705
Well, let's take a cycle.

00:49:03.130 --> 00:49:04.450
And we'll give it a name.

00:49:04.450 --> 00:49:10.270
In particular, we'll say that
it's a cycle from v0 v1 to vk.

00:49:10.270 --> 00:49:12.790
And then it's a cycle,
so it goes back to v0.

00:49:12.790 --> 00:49:14.080
OK.

00:49:14.080 --> 00:49:16.940
And I can order this
cycle any way I want.

00:49:16.940 --> 00:49:19.385
Notice that if I
permute the vertices

00:49:19.385 --> 00:49:21.010
in this list in a
cyclical way, meaning

00:49:21.010 --> 00:49:22.990
that I take the last few
of them and stick them

00:49:22.990 --> 00:49:25.032
at the beginning of the
list, it's still a cycle.

00:49:25.032 --> 00:49:27.290
That's the nice
thing about cycles.

00:49:27.290 --> 00:49:33.280
So in particular, without
loss of generality,

00:49:33.280 --> 00:49:41.530
we're going to assume that v0
is the first vertex visited

00:49:41.530 --> 00:49:42.685
by DFS.

00:49:52.157 --> 00:49:52.990
What does that mean?

00:49:52.990 --> 00:49:55.280
That means, like, when I
do my DFS algorithm making

00:49:55.280 --> 00:49:57.680
all these recursive calls,
the very first vertex

00:49:57.680 --> 00:50:00.670
to be touched by
this technique is v0.

00:50:00.670 --> 00:50:02.170
OK.

00:50:02.170 --> 00:50:04.400
Well, now what's going
to end up happening?

00:50:04.400 --> 00:50:07.345
Well, think about the recursive
call tree starting at v0.

00:50:10.260 --> 00:50:13.350
By the time that
completes, anything

00:50:13.350 --> 00:50:16.620
that's reachable from v0 is
also going to be complete.

00:50:16.620 --> 00:50:18.280
Do you see that?

00:50:18.280 --> 00:50:22.520
So for instance, v0 somewhere
in its call tree might call v2.

00:50:22.520 --> 00:50:24.360
And notice that v2 was
not already visited.

00:50:24.360 --> 00:50:25.930
So in fact, it will.

00:50:25.930 --> 00:50:28.790
For v1 I got to
call v2 and so on.

00:50:28.790 --> 00:50:34.760
And in particular, we're going
to get all the way to vertex k.

00:50:34.760 --> 00:50:36.140
Right?

00:50:36.140 --> 00:50:43.150
So in other words, we're
going to visit a vertex vk.

00:50:46.110 --> 00:50:47.710
And notice what's
going to happen.

00:50:47.710 --> 00:50:49.147
So remember our algorithm.

00:50:49.147 --> 00:50:51.480
In fact, we should probably
just put it up on the screen

00:50:51.480 --> 00:50:54.300
would be easier than
talking about it a bunch.

00:50:54.300 --> 00:50:58.320
Well, vk is now
going to iterate over

00:50:58.320 --> 00:51:00.660
every one of the
neighbors of vk.

00:51:00.660 --> 00:51:05.040
And in particular, it's
going to see vertex v0.

00:51:05.040 --> 00:51:06.330
Right?

00:51:06.330 --> 00:51:12.560
So we're going to
see the edge from vk

00:51:12.560 --> 00:51:16.430
to v0, which is an edge
kind of by definition

00:51:16.430 --> 00:51:19.517
because we took this
to be a cycle here.

00:51:19.517 --> 00:51:21.850
But notice that's exactly the
thing we set out to prove,

00:51:21.850 --> 00:51:26.140
namely that full DFS traverses
an edge from a vertex

00:51:26.140 --> 00:51:27.520
to one of its ancestors.

00:51:27.520 --> 00:51:28.840
Here's a vertex k.

00:51:28.840 --> 00:51:30.688
Here's the ancestor v0.

00:51:30.688 --> 00:51:32.230
Why do we know that
it's an ancestor?

00:51:32.230 --> 00:51:35.230
Well, because v0 was
called in our call tree

00:51:35.230 --> 00:51:37.090
before any of these other guys.

00:51:37.090 --> 00:51:38.350
Right?

00:51:38.350 --> 00:51:41.140
So we wanted an algorithm that
not only did cycle detection,

00:51:41.140 --> 00:51:42.910
but also actually
gave me the cycle.

00:51:42.910 --> 00:51:43.910
What could I do?

00:51:43.910 --> 00:51:46.050
Well, it's essentially
a small modification

00:51:46.050 --> 00:51:47.050
of what we already have.

00:51:47.050 --> 00:51:47.550
Right.

00:51:47.550 --> 00:51:48.740
So-- whoops.

00:51:48.740 --> 00:51:49.240
Right.

00:51:49.240 --> 00:51:51.580
If I want to compute
topological order or whatever,

00:51:51.580 --> 00:51:53.170
I can just do DFS.

00:51:53.170 --> 00:51:55.930
And that'll tell me like, yay or
nay, does there exist a cycle.

00:51:55.930 --> 00:51:59.170
If I want to actually find
that cycle, all I have to do

00:51:59.170 --> 00:52:03.040
is check that topological
order property at the same time

00:52:03.040 --> 00:52:05.290
that it traversed
the graph during DFS.

00:52:05.290 --> 00:52:10.250
And the second that I find an
edge that loops back, I'm done.

00:52:10.250 --> 00:52:12.280
And so that's our
basic algorithm here.

00:52:12.280 --> 00:52:14.410
And this is a technique
for actually just finding

00:52:14.410 --> 00:52:18.270
the cycle in a graph
using the DFS algorithm.