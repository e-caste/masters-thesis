WEBVTT

00:00:25.680 --> 00:00:27.960
PROFESSOR: Well, yesterday
was easy.

00:00:27.960 --> 00:00:33.020
You learned all of the rules
of programming and lived.

00:00:33.020 --> 00:00:34.980
Almost all of them.

00:00:34.980 --> 00:00:38.372
And so at this point, you're
now certified programmers--

00:00:38.372 --> 00:00:40.200
it says.

00:00:40.200 --> 00:00:48.890
However, I suppose what we did
is we, aah, sort of got you a

00:00:48.890 --> 00:00:51.700
little bit of into
an easy state.

00:00:51.700 --> 00:00:54.770
Here, you still believe it's
possible that this might be

00:00:54.770 --> 00:00:59.250
programming in BASIC or Pascal
with just a funny syntax.

00:00:59.250 --> 00:01:01.770
Today, that illusion--

00:01:01.770 --> 00:01:04.919
or you can no longer support
that belief.

00:01:04.919 --> 00:01:06.450
What we're going to do
today is going to

00:01:06.450 --> 00:01:08.340
completely smash that.

00:01:08.340 --> 00:01:13.590
So let's start out by writing
a few programs on the

00:01:13.590 --> 00:01:15.895
blackboard that have a lot in
common with each other.

00:01:15.895 --> 00:01:19.540
What we're going to do is try to
make them abstractions that

00:01:19.540 --> 00:01:23.880
are not ones that are easy to
make in most languages.

00:01:23.880 --> 00:01:26.040
Let's start with some very
simple ones that you can make

00:01:26.040 --> 00:01:28.070
in most languages.

00:01:28.070 --> 00:01:32.130
Supposing I want to write the
mathematical expression which

00:01:32.130 --> 00:01:34.100
adds up a bunch of integers.

00:01:34.100 --> 00:01:38.850
So if I wanted to write down
and say the sum from i

00:01:38.850 --> 00:01:41.410
equal a to b on i.

00:01:41.410 --> 00:01:44.190
Now, you know that that's an
easy thing to compute in a

00:01:44.190 --> 00:01:46.180
closed form for it, and I'm
not interested in that.

00:01:46.180 --> 00:01:47.140
But I'm going to write
a program that

00:01:47.140 --> 00:01:49.045
adds up those integers.

00:01:49.045 --> 00:01:57.890
Well, that's rather easy to do
to say I want to define the

00:01:57.890 --> 00:02:08.710
sum of the integers from
a to b to be--

00:02:08.710 --> 00:02:11.380
well, it's the following
two possibilities.

00:02:11.380 --> 00:02:17.430
If a is greater than b, well,
then there's nothing to be

00:02:17.430 --> 00:02:19.582
done and the answer is zero.

00:02:19.582 --> 00:02:22.530
This is how you're going to
have to think recursively.

00:02:22.530 --> 00:02:24.880
You're going to say if I have
an easy case that I know the

00:02:24.880 --> 00:02:26.610
answer to, just write it down.

00:02:26.610 --> 00:02:29.890
Otherwise, I'm going to try to
reduce this problem to a

00:02:29.890 --> 00:02:31.060
simpler problem.

00:02:31.060 --> 00:02:33.000
And maybe in this case, I'm
going to make a subproblem of

00:02:33.000 --> 00:02:35.340
the simpler problem and then
do something to the result.

00:02:35.340 --> 00:02:41.290
So the easiest way to do this
is say that I'm going to add

00:02:41.290 --> 00:02:46.530
the index, which in this case is
a, to the result of adding

00:02:46.530 --> 00:02:57.960
up the integers from
a plus 1 to b.

00:03:02.343 --> 00:03:04.460
Now, at this point, you should
have no trouble looking at

00:03:04.460 --> 00:03:06.190
such a definition.

00:03:06.190 --> 00:03:09.740
Indeed, coming up with such a
thing might be a little hard

00:03:09.740 --> 00:03:12.230
in synthesis, but being able
to read it at this point

00:03:12.230 --> 00:03:13.840
should be easy.

00:03:13.840 --> 00:03:18.220
And what it says to you is,
well, here is the subproblem

00:03:18.220 --> 00:03:19.520
I'm going to solve.

00:03:19.520 --> 00:03:24.240
I'm going to try to add up the
integers, one fewer integer

00:03:24.240 --> 00:03:26.970
than I added up for the
the whole problem.

00:03:26.970 --> 00:03:31.270
I'm adding up the one fewer one,
and that subproblem, once

00:03:31.270 --> 00:03:35.150
I've solved it, I'm going to add
a to that, and that will

00:03:35.150 --> 00:03:38.550
be the answer to this problem.

00:03:38.550 --> 00:03:41.626
And the simplest case, I don't
have to do any work.

00:03:41.626 --> 00:03:44.990
Now, I'm also going to write
down another simple one just

00:03:44.990 --> 00:03:49.617
like this, which is the
mathematical expression, the

00:03:49.617 --> 00:03:55.840
sum of the square from
i equal a to b.

00:03:55.840 --> 00:03:58.055
And again, it's a very
simple program.

00:04:11.220 --> 00:04:13.510
And indeed, it starts
the same way.

00:04:16.029 --> 00:04:21.240
If a is greater than b, then
the answer is zero.

00:04:21.240 --> 00:04:24.160
And, of course, we're beginning
to see that there's

00:04:24.160 --> 00:04:27.980
something wrong with me writing
this down again.

00:04:27.980 --> 00:04:29.820
It's the same program.

00:04:29.820 --> 00:04:42.180
It's the sum of the square of a
and the sum of the square of

00:04:42.180 --> 00:04:46.134
the increment and b.

00:04:50.880 --> 00:04:54.070
Now, if you look at these
things, these programs are

00:04:54.070 --> 00:04:56.380
almost identical.

00:04:56.380 --> 00:04:59.860
There's not much to
distinguish them.

00:04:59.860 --> 00:05:03.140
They have the same first clause
of the conditional and

00:05:03.140 --> 00:05:06.250
the same predicate and the
same consequence, and the

00:05:06.250 --> 00:05:08.910
alternatives are very
similar, too.

00:05:08.910 --> 00:05:15.510
They only differ by the fact
that where here I have a,

00:05:15.510 --> 00:05:17.336
here, I have the square of a.

00:05:17.336 --> 00:05:22.020
The only other difference, but
this one's sort of unessential

00:05:22.020 --> 00:05:25.240
is in the name of this procedure
is sum int, whereas

00:05:25.240 --> 00:05:27.560
the name of the procedure
is sum square.

00:05:27.560 --> 00:05:29.820
So the things that vary
between these

00:05:29.820 --> 00:05:33.250
two are very small.

00:05:33.250 --> 00:05:36.080
Now, wherever you see yourself
writing the same thing down

00:05:36.080 --> 00:05:38.340
more than once, there's
something wrong, and you

00:05:38.340 --> 00:05:40.280
shouldn't be doing it.

00:05:40.280 --> 00:05:43.420
And the reason is not because
it's a waste of time to write

00:05:43.420 --> 00:05:45.540
something down more than once.

00:05:45.540 --> 00:05:50.720
It's because there's some idea
here, a very simple idea,

00:05:50.720 --> 00:05:54.620
which has to do with the
sigma notation--

00:05:54.620 --> 00:05:57.330
this much--

00:05:57.330 --> 00:06:01.255
not depending upon what
it is I'm adding up.

00:06:01.255 --> 00:06:03.070
And I would like
to be able to--

00:06:03.070 --> 00:06:05.610
always, whenever trying to make
complicated systems and

00:06:05.610 --> 00:06:08.575
understand them, it's crucial
to divide the things up into

00:06:08.575 --> 00:06:11.030
as many pieces as I can, each
of which I understand

00:06:11.030 --> 00:06:13.050
separately.

00:06:13.050 --> 00:06:15.030
I would like to understand the
way of adding things up

00:06:15.030 --> 00:06:19.540
independently of what it is I'm
adding up so I can do that

00:06:19.540 --> 00:06:24.260
having debugged it once and
understood it once and having

00:06:24.260 --> 00:06:29.400
been able to share that among
many different uses of it.

00:06:29.400 --> 00:06:32.360
Here, we have another example.

00:06:32.360 --> 00:06:40.400
This is Leibnitz's formula
for finding pi over 8.

00:06:40.400 --> 00:06:43.460
It's a funny, ugly mess.

00:06:43.460 --> 00:06:43.930
What is it?

00:06:43.930 --> 00:06:50.670
It's something like 1 over 1
times 3 plus 1 over 5 times 7

00:06:50.670 --> 00:06:54.340
plus 1 over 9 times 11 plus--

00:06:54.340 --> 00:06:59.750
and for some reason, things
like this tend to have

00:06:59.750 --> 00:07:02.160
interesting values
like pi over 8.

00:07:02.160 --> 00:07:04.460
But what do we see here?

00:07:04.460 --> 00:07:07.850
It's the same program or almost
the same program.

00:07:07.850 --> 00:07:09.290
It's a sum.

00:07:09.290 --> 00:07:12.660
So we're seeing the figure
notation, although over here,

00:07:12.660 --> 00:07:17.320
we're dealing with incrementing
by 4, so it's a

00:07:17.320 --> 00:07:20.550
slightly different problem,
which means that over here, I

00:07:20.550 --> 00:07:25.560
have to change a by 4, as
you see right over here.

00:07:25.560 --> 00:07:28.390
It's not by 1.

00:07:28.390 --> 00:07:31.150
The other thing, of course,
is that the thing that's

00:07:31.150 --> 00:07:34.805
represented by square in the
previous sum of squares, or a

00:07:34.805 --> 00:07:36.400
when adding up the integers.

00:07:36.400 --> 00:07:38.060
Well, here, I have a different
thing I'm adding up, a

00:07:38.060 --> 00:07:44.290
different term, which is 1
over a times a plus 2.

00:07:44.290 --> 00:07:45.875
But the rest of this program
is identical.

00:07:48.530 --> 00:07:50.640
Well, any time we have a bunch
of things like this that are

00:07:50.640 --> 00:07:53.200
identical, we're going to have
to come up with some sort of

00:07:53.200 --> 00:07:55.582
abstraction to cover them.

00:07:55.582 --> 00:07:59.920
If you think about this, what
you've learned so far is the

00:07:59.920 --> 00:08:03.370
rules of some language, some
primitive, some means of

00:08:03.370 --> 00:08:06.310
combination, almost all
of them, the means of

00:08:06.310 --> 00:08:09.730
abstraction, almost
all of them.

00:08:09.730 --> 00:08:13.290
But what you haven't learned is
common patterns of usage.

00:08:13.290 --> 00:08:15.150
Now, most of the time, you learn
idioms when learning a

00:08:15.150 --> 00:08:18.380
language, which is a common
pattern that mean things that

00:08:18.380 --> 00:08:20.760
are useful to know in a flash.

00:08:20.760 --> 00:08:22.760
And if you build a great number
of them, if you're a

00:08:22.760 --> 00:08:26.180
FORTRAN programmer, of course,
everybody knows how to--

00:08:26.180 --> 00:08:29.640
what do you do, for example, to
get an integer which is the

00:08:29.640 --> 00:08:31.250
biggest integer in something.

00:08:31.250 --> 00:08:32.600
It's a classic thing.

00:08:32.600 --> 00:08:34.350
Every FORTRAN programmer
knows how to do that.

00:08:34.350 --> 00:08:36.059
And if you don't know that,
you're in real hot water

00:08:36.059 --> 00:08:38.150
because it takes a long
time to think it out.

00:08:38.150 --> 00:08:41.620
However, one of the things you
can do in this language that

00:08:41.620 --> 00:08:43.900
we're showing you is not only
do you know something like

00:08:43.900 --> 00:08:48.380
that, but you give the knowledge
of that a name.

00:08:48.380 --> 00:08:50.500
And so that's what we're going
to be going after right now.

00:08:53.530 --> 00:08:55.860
OK, well, let's see what these
things have in common.

00:08:58.680 --> 00:09:02.560
Right over here we have what
appears to be a general

00:09:02.560 --> 00:09:06.470
pattern, a general pattern which
covers all of the cases

00:09:06.470 --> 00:09:09.700
we've seen so far.

00:09:09.700 --> 00:09:15.200
There is a sum procedure,
which is being defined.

00:09:15.200 --> 00:09:17.680
It has two arguments, which
are a lower bound

00:09:17.680 --> 00:09:19.630
and an upper bound.

00:09:19.630 --> 00:09:23.150
The lower bound is tested to
be greater than the upper

00:09:23.150 --> 00:09:27.590
bound, and if it is greater,
then the result is zero.

00:09:27.590 --> 00:09:31.640
Otherwise, we're going to do
something to the lower bound,

00:09:31.640 --> 00:09:35.540
which is the index of the
conversation, and add that

00:09:35.540 --> 00:09:40.150
result to the result of
following the procedure

00:09:40.150 --> 00:09:45.050
recursively on our lower bound
incremented by some next

00:09:45.050 --> 00:09:49.605
operation with the same upper
bound as I had before.

00:09:53.710 --> 00:09:59.230
So this is a general pattern,
and what I'd like to do is be

00:09:59.230 --> 00:10:03.610
able to name this general
pattern a bit.

00:10:03.610 --> 00:10:06.550
Well, that's sort of easy,
because one of the things I'm

00:10:06.550 --> 00:10:09.610
going to do right now is--
there's nothing very special

00:10:09.610 --> 00:10:11.790
about numbers.

00:10:11.790 --> 00:10:14.790
Numbers are just one
kind of data.

00:10:14.790 --> 00:10:17.570
It seems to me perfectly
reasonable to give all sorts

00:10:17.570 --> 00:10:23.260
of names to all kinds of data,
for example, procedures.

00:10:23.260 --> 00:10:26.370
And now many languages allow you
have procedural arguments,

00:10:26.370 --> 00:10:27.830
and right now, we're
going to talk

00:10:27.830 --> 00:10:29.120
about procedural arguments.

00:10:29.120 --> 00:10:31.280
They're very easy
to deal with.

00:10:31.280 --> 00:10:33.300
And shortly, we'll do some
remarkable things that are not

00:10:33.300 --> 00:10:35.730
like procedural arguments.

00:10:35.730 --> 00:10:43.190
So here, we'll define
our sigma notation.

00:10:43.190 --> 00:10:55.450
This is called sum and it takes
a term, an A, a next

00:10:55.450 --> 00:11:00.190
term, and B as arguments.

00:11:00.190 --> 00:11:03.420
So it takes four arguments,
and there was nothing

00:11:03.420 --> 00:11:06.580
particularly special about me
writing this in lowercase.

00:11:06.580 --> 00:11:08.700
I hope that it doesn't confuse
you, so I'll write it in

00:11:08.700 --> 00:11:09.930
uppercase right now.

00:11:09.930 --> 00:11:11.180
The machine doesn't care.

00:11:14.350 --> 00:11:17.180
But these two arguments
are different.

00:11:17.180 --> 00:11:19.360
These are not numbers.

00:11:19.360 --> 00:11:21.600
These are going to be procedures
for computing

00:11:21.600 --> 00:11:23.690
something given a number.

00:11:23.690 --> 00:11:26.590
Term will be a procedure which,
when given an index,

00:11:26.590 --> 00:11:29.920
will produce the value of
the term for that index.

00:11:29.920 --> 00:11:31.660
Next will be given an
index, which will

00:11:31.660 --> 00:11:34.050
produce the next index.

00:11:34.050 --> 00:11:36.000
This will be for counting.

00:11:36.000 --> 00:11:37.250
And it's very simple.

00:11:40.590 --> 00:11:43.400
It's exactly what you see.

00:11:43.400 --> 00:11:52.220
If A is greater than B,
then the result is 0.

00:11:52.220 --> 00:12:04.970
Otherwise, it's the sum of term
applied to A and the sum

00:12:04.970 --> 00:12:10.410
of term, next index.

00:12:14.990 --> 00:12:16.480
Let me write it this way.

00:12:29.370 --> 00:12:32.160
Now, I'd like you to see
something, first of all.

00:12:32.160 --> 00:12:35.210
I was writing here, and
I ran out of space.

00:12:35.210 --> 00:12:38.110
What I did is I start indenting
according to the

00:12:38.110 --> 00:12:41.080
Pretty-printing rule, which says
that I align all of the

00:12:41.080 --> 00:12:44.340
arguments of the procedure
so I can see

00:12:44.340 --> 00:12:47.060
which ones go together.

00:12:47.060 --> 00:12:49.840
And this is just something I do
automatically, and I want

00:12:49.840 --> 00:12:51.530
you to learn how to do that,
too, so your programs can be

00:12:51.530 --> 00:12:52.780
read and understood.

00:12:54.750 --> 00:12:57.610
However, what do we have here?

00:12:57.610 --> 00:13:01.730
We have four arguments: the
procedure, the lower index--

00:13:01.730 --> 00:13:03.670
lower bound index--

00:13:03.670 --> 00:13:09.010
the way to get the next index,
and the upper bound.

00:13:09.010 --> 00:13:13.890
What's passed along on the
recursive call is indeed the

00:13:13.890 --> 00:13:18.110
same procedure because I'm going
to need it again, the

00:13:18.110 --> 00:13:21.260
next index, which is using the
next procedure to compute it,

00:13:21.260 --> 00:13:23.332
the procedure for computing
next, which I also have to

00:13:23.332 --> 00:13:25.250
have separately, and
that's different.

00:13:25.250 --> 00:13:27.940
The procedure for computing
next is different from the

00:13:27.940 --> 00:13:30.680
next index, which is the result
of using next on the

00:13:30.680 --> 00:13:32.510
last index.

00:13:32.510 --> 00:13:34.210
And I also have to pass
along the upper bound.

00:13:37.090 --> 00:13:44.850
So this captures both of these
and the other nice program

00:13:44.850 --> 00:13:47.810
that we are playing with.

00:13:47.810 --> 00:13:52.740
So using this, we can write down
the original program as

00:13:52.740 --> 00:13:56.260
instances of sum very simply.

00:14:08.880 --> 00:14:17.620
A and B. Well, I'm going to
need an identity procedure

00:14:17.620 --> 00:14:29.440
here because ,ahh, the sum of
the integers requires me to in

00:14:29.440 --> 00:14:33.020
this case compute a term for
every integer, but the term

00:14:33.020 --> 00:14:35.560
procedure doesn't want to do
anything to that integer.

00:14:35.560 --> 00:14:41.460
So the identity procedure on A
is A or X or whatever, and I

00:14:41.460 --> 00:14:52.420
want to say the sum of using
identity of the term procedure

00:14:52.420 --> 00:14:58.400
and using A as the initial
index and the incrementer

00:14:58.400 --> 00:15:05.552
being the way to get the next
index and B being the high

00:15:05.552 --> 00:15:07.870
bound, the upper bound.

00:15:07.870 --> 00:15:12.010
This procedure does exactly
the same as the sum of the

00:15:12.010 --> 00:15:14.140
integers over here, computes
the same answer.

00:15:17.690 --> 00:15:21.520
Now, one thing you should see,
of course, is that there's

00:15:21.520 --> 00:15:25.220
nothing very special over here
about what I used as the

00:15:25.220 --> 00:15:25.990
formal parameter.

00:15:25.990 --> 00:15:27.230
I could have, for example,
written this

00:15:27.230 --> 00:15:29.690
X. It doesn't matter.

00:15:29.690 --> 00:15:33.760
I just wanted you to see that
this name does not conflict

00:15:33.760 --> 00:15:35.140
with this one at all.

00:15:35.140 --> 00:15:37.850
It's an internal name.

00:15:37.850 --> 00:15:40.500
For the second procedure here,
the sum of the squares, it's

00:15:40.500 --> 00:15:41.750
even a little bit easier.

00:15:53.760 --> 00:15:54.850
And what do we have to do?

00:15:54.850 --> 00:16:02.560
Nothing more than add up the
squares, this is the procedure

00:16:02.560 --> 00:16:05.620
that each index will be given,
will be given each--

00:16:05.620 --> 00:16:06.780
yes.

00:16:06.780 --> 00:16:10.410
Each index will have this done
to it to get the term.

00:16:10.410 --> 00:16:13.570
That's the thing that maps
against term over here.

00:16:13.570 --> 00:16:18.810
Then I have A as the lower
bound, the incrementer as the

00:16:18.810 --> 00:16:21.520
next term method, and B
as the upper bound.

00:16:26.780 --> 00:16:29.030
And finally, just for the thing
that we did about pi

00:16:29.030 --> 00:16:33.270
sums, pi sums are sort of--

00:16:33.270 --> 00:16:35.840
well, it's even easier to think
about them this way

00:16:35.840 --> 00:16:36.610
because I don't have to think.

00:16:36.610 --> 00:16:41.110
What I'm doing is separating the
thing I'm adding up from

00:16:41.110 --> 00:16:43.340
the method of doing
the addition.

00:16:43.340 --> 00:16:57.200
And so we have here, for
example, pi sum A B

00:16:57.200 --> 00:16:59.890
of the sum of things.

00:16:59.890 --> 00:17:03.350
I'm going to write the terms
procedure here explicitly

00:17:03.350 --> 00:17:05.670
without giving it a name.

00:17:05.670 --> 00:17:07.119
This is done anonymously.

00:17:07.119 --> 00:17:10.960
I don't necessarily have to give
a name to something if I

00:17:10.960 --> 00:17:12.310
just want to use it once.

00:17:12.310 --> 00:17:18.050
And, of course, I can write
sort of a expression that

00:17:18.050 --> 00:17:19.579
produces a procedure.

00:17:19.579 --> 00:17:22.740
I'm going to write the Greek
lambda letter here instead of

00:17:22.740 --> 00:17:26.220
L-A-M-B-D-A in general to avoid
taking up a lot of space

00:17:26.220 --> 00:17:27.240
on blackboards.

00:17:27.240 --> 00:17:28.270
But unfortunately,
we don't have

00:17:28.270 --> 00:17:29.960
lambda keys on our keyboards.

00:17:29.960 --> 00:17:32.170
Maybe we can convince our
friends in the computer

00:17:32.170 --> 00:17:34.040
industry that this
is an important.

00:17:34.040 --> 00:17:43.480
Lambda of i is the quotient of 1
and the product of i and the

00:17:43.480 --> 00:17:58.020
sum of i 2, starting at a with
the way of incrementing being

00:17:58.020 --> 00:18:08.666
that procedure of an index i,
which adds i to 4, and b being

00:18:08.666 --> 00:18:09.916
the upper bound.

00:18:12.270 --> 00:18:17.490
So you can see that this
notation, the invention of the

00:18:17.490 --> 00:18:21.370
procedure that takes a
procedural argument, allows us

00:18:21.370 --> 00:18:26.066
to compress a lot of these
procedures into one thing.

00:18:26.066 --> 00:18:32.780
This procedure, sums, covers
a whole bunch of ideas.

00:18:32.780 --> 00:18:34.740
Now, just why is
this important?

00:18:34.740 --> 00:18:37.370
I tried to say before that it
helps us divide a problem into

00:18:37.370 --> 00:18:42.760
two pieces, and indeed, it does,
for example, if someone

00:18:42.760 --> 00:18:46.570
came up with a different way of
implementing this, which,

00:18:46.570 --> 00:18:50.010
of course, one might.

00:18:50.010 --> 00:18:51.230
Here, for example, an iterative

00:18:51.230 --> 00:18:52.480
implementation of sum.

00:18:55.900 --> 00:18:59.470
Iterative implementation for
some reason might be better

00:18:59.470 --> 00:19:00.840
than the recursive
implementation.

00:19:03.670 --> 00:19:06.460
But the important thing is
that it's different.

00:19:06.460 --> 00:19:09.460
Now, supposing I had written my
program this way that you

00:19:09.460 --> 00:19:14.310
see on the blackboard
on the left.

00:19:14.310 --> 00:19:17.810
That's correct, the left.

00:19:17.810 --> 00:19:22.280
Well, then if I want to change
the method of addition, then

00:19:22.280 --> 00:19:25.200
I'd have to change
each of these.

00:19:25.200 --> 00:19:30.210
Whereas if I write them like
this that you see here, then

00:19:30.210 --> 00:19:32.430
the method by which I did the
addition is encapsulated in

00:19:32.430 --> 00:19:34.850
the procedure sum.

00:19:34.850 --> 00:19:37.780
That decomposition allows me
to independently change one

00:19:37.780 --> 00:19:43.210
part of the program and prove
it perhaps without changing

00:19:43.210 --> 00:19:45.052
the other part that was
written for some

00:19:45.052 --> 00:19:46.630
of the other cases.

00:19:50.366 --> 00:19:51.010
Thank you.

00:19:51.010 --> 00:19:52.420
Are there any questions?

00:19:52.420 --> 00:19:53.190
Yes, sir.

00:19:53.190 --> 00:19:55.150
AUDIENCE: Would you go over
next A and next again on--

00:19:55.150 --> 00:19:55.640
PROFESSOR: Yes.

00:19:55.640 --> 00:19:56.680
It's the same problem.

00:19:56.680 --> 00:19:57.900
I'm sure you're going to--

00:19:57.900 --> 00:19:59.160
you're going to have
to work on this.

00:19:59.160 --> 00:20:01.280
This is hard the first
time you've ever seen

00:20:01.280 --> 00:20:02.460
something like this.

00:20:02.460 --> 00:20:06.300
What I have here is
a-- procedures

00:20:06.300 --> 00:20:07.550
can be named by variables.

00:20:10.020 --> 00:20:12.710
Procedures are not special.

00:20:12.710 --> 00:20:15.230
Actually, sum square is a
variable, which has gotten a

00:20:15.230 --> 00:20:18.640
value, which is a procedure.

00:20:18.640 --> 00:20:20.030
This is define sum square to be

00:20:20.030 --> 00:20:23.310
lambda of A and B something.

00:20:23.310 --> 00:20:24.700
So the procedure can be named.

00:20:24.700 --> 00:20:27.900
Therefore, they can be passed
from one to another, one

00:20:27.900 --> 00:20:31.430
procedure to another,
as arguments.

00:20:31.430 --> 00:20:33.630
Well, what we're doing here is
we're passing the procedure

00:20:33.630 --> 00:20:38.190
term as an argument to sum just
when we get it around in

00:20:38.190 --> 00:20:41.060
the next recursive.

00:20:41.060 --> 00:20:45.350
Here, we're passing
the procedure next

00:20:45.350 --> 00:20:47.630
as an argument also.

00:20:47.630 --> 00:20:50.120
However, here we're using
the procedure next.

00:20:50.120 --> 00:20:51.690
That's what the parentheses
mean.

00:20:51.690 --> 00:20:56.750
We're applying next to A to get
the next value of A. If

00:20:56.750 --> 00:20:59.390
you look at what next is mapped
against, remember that

00:20:59.390 --> 00:21:02.390
the way you think about this
is that you substitute the

00:21:02.390 --> 00:21:06.800
arguments for the formal
parameters in the body.

00:21:06.800 --> 00:21:10.590
If you're ever confused, think
of the thing that way.

00:21:10.590 --> 00:21:14.730
Well, over here, with
sum of the integers.

00:21:14.730 --> 00:21:21.150
I substitute identity for
a term and 1 plus the

00:21:21.150 --> 00:21:26.070
incrementer for next
in the body.

00:21:26.070 --> 00:21:30.600
Well, the identity procedure
on A is what I get here.

00:21:30.600 --> 00:21:35.170
Identity is being passed
along, and here, I have

00:21:35.170 --> 00:21:41.040
increment 1 plus being applied
to A and 1 plus is being

00:21:41.040 --> 00:21:42.980
passed along.

00:21:42.980 --> 00:21:46.340
Does that clarify
the situation?

00:21:46.340 --> 00:21:49.355
AUDIENCE: We could also define
explicitly those two

00:21:49.355 --> 00:21:51.300
functions, then pass them.

00:21:51.300 --> 00:21:52.360
PROFESSOR: Sure.

00:21:52.360 --> 00:21:54.950
What we can do is we could have
given names to them, just

00:21:54.950 --> 00:21:55.770
like I did here.

00:21:55.770 --> 00:21:57.530
In fact, I gave you various
ways so you

00:21:57.530 --> 00:21:59.390
could see it, a variety.

00:21:59.390 --> 00:22:05.130
Here, I define the thing which
I passed the name of.

00:22:05.130 --> 00:22:07.850
I referenced it by its name.

00:22:07.850 --> 00:22:10.400
But the thing is, in fact, that
procedure, one argument

00:22:10.400 --> 00:22:14.300
X, which is X. And the identity
procedure is just

00:22:14.300 --> 00:22:20.870
lambda of X X. And that's
what you're seeing here.

00:22:20.870 --> 00:22:26.190
Here, I happened to just write
its canonical name there for

00:22:26.190 --> 00:22:27.440
you to see.

00:22:31.730 --> 00:22:33.020
Is it OK if we take our
five-minute break?

00:23:15.850 --> 00:23:19.780
As I said, computers to make
people happy, not people to

00:23:19.780 --> 00:23:21.070
make computers happy.

00:23:21.070 --> 00:23:23.080
And for the most part, the
reason why we introduce all

00:23:23.080 --> 00:23:26.440
this abstraction stuff is to
make it so that programs can

00:23:26.440 --> 00:23:29.940
be more easily written
and more easily read.

00:23:29.940 --> 00:23:32.930
Let's try to understand what's
the most complicated program

00:23:32.930 --> 00:23:36.280
we've seen so far using
a little bit of

00:23:36.280 --> 00:23:38.120
this abstraction stuff.

00:23:38.120 --> 00:23:44.560
If you look at the slide, this
is the Heron of Alexandria's

00:23:44.560 --> 00:23:51.590
method of computing square roots
that we saw yesterday.

00:23:51.590 --> 00:23:56.460
And let's see.

00:23:56.460 --> 00:24:00.780
Well, in any case, this
program is a little

00:24:00.780 --> 00:24:01.805
complicated.

00:24:01.805 --> 00:24:04.800
And at the current state of your
thinking, you just can't

00:24:04.800 --> 00:24:07.320
look at that and say, oh,
this obviously means

00:24:07.320 --> 00:24:10.380
something very clear.

00:24:10.380 --> 00:24:12.930
It's not obvious from
looking at the

00:24:12.930 --> 00:24:17.060
program what it's computing.

00:24:17.060 --> 00:24:21.890
There's some loop here inside
try, and a loop does something

00:24:21.890 --> 00:24:26.030
about trying the improvement
of y.

00:24:26.030 --> 00:24:30.170
There's something called
improve, which does some

00:24:30.170 --> 00:24:33.270
averaging and quotienting
and things like that.

00:24:33.270 --> 00:24:34.840
But what's the real idea?

00:24:34.840 --> 00:24:38.930
Can we make it clear
what the idea is?

00:24:38.930 --> 00:24:41.610
Well, I think we can.

00:24:41.610 --> 00:24:45.070
I think we can use abstraction
that we have learned about so

00:24:45.070 --> 00:24:48.990
far to clarify what's
going on.

00:24:48.990 --> 00:24:54.720
Now, what we have mathematically
is a procedure

00:24:54.720 --> 00:24:58.411
for improving a guess
for square roots.

00:24:58.411 --> 00:25:02.610
And if y is a guess for a square
root, then what we want

00:25:02.610 --> 00:25:04.570
to get we'll call
a function f.

00:25:04.570 --> 00:25:07.660
This is the means
of improvement.

00:25:07.660 --> 00:25:17.510
I want to get y plus x/y over
2, so the average of y and x

00:25:17.510 --> 00:25:24.080
divided by y as the improved
value for the square root of x

00:25:24.080 --> 00:25:27.920
such that-- one thing you can
notice about this function f

00:25:27.920 --> 00:25:36.310
is that f of the square root
of f is in fact the

00:25:36.310 --> 00:25:38.460
square root of x.

00:25:38.460 --> 00:25:41.670
In other words, if I take
the square root of x and

00:25:41.670 --> 00:25:44.930
substitute it for y here, I see
the square root of x plus

00:25:44.930 --> 00:25:47.560
x divided by the square of x,
which is the square root of x.

00:25:47.560 --> 00:25:49.890
That's 2 times the square root
of x divided by 2, is the

00:25:49.890 --> 00:25:51.640
square root of x.

00:25:51.640 --> 00:25:55.630
So, in fact, what we're really
looking for is we're looking

00:25:55.630 --> 00:26:12.850
for a fixed point, a fixed
point of the function f.

00:26:17.570 --> 00:26:22.650
A fixed point is a place which
has the property that if you

00:26:22.650 --> 00:26:24.850
put it into the function, you
get the same value out.

00:26:27.620 --> 00:26:29.700
Now, I suppose if I were giving
some nice, boring

00:26:29.700 --> 00:26:34.480
lecture, and you happened to
have in front of you an HP-35

00:26:34.480 --> 00:26:36.380
desk calculator like I
used to have when I

00:26:36.380 --> 00:26:38.170
went to boring lectures.

00:26:38.170 --> 00:26:41.120
And if you think it was really
boring, you put it into

00:26:41.120 --> 00:26:44.720
radians mode, and you hit
cosine, and you hit cosine,

00:26:44.720 --> 00:26:45.780
and you hit cosine.

00:26:45.780 --> 00:26:48.770
And eventually, you end
up with 0.734 or

00:26:48.770 --> 00:26:50.090
something like that.

00:26:50.090 --> 00:26:53.250
0.743, I don't remember what
exactly, and it gets closer

00:26:53.250 --> 00:26:54.810
and closer to that.

00:26:54.810 --> 00:26:57.980
Some functions have the property
that you can find

00:26:57.980 --> 00:27:03.420
their fixed point by iterating
the function, and that's

00:27:03.420 --> 00:27:07.170
essentially what's happening in
the square root program by

00:27:07.170 --> 00:27:08.420
Heron's method.

00:27:11.550 --> 00:27:14.732
So let's see if we can write
that down, that idea.

00:27:14.732 --> 00:27:17.670
Now, I'm not going to say how
I compute fixed points yet.

00:27:17.670 --> 00:27:19.240
There might be more
than one way.

00:27:19.240 --> 00:27:22.750
But the first thing to
do is I'm going to

00:27:22.750 --> 00:27:24.310
say what I just said.

00:27:24.310 --> 00:27:27.460
I'm going to say it
specifically, the square root.

00:27:32.440 --> 00:27:48.210
The square root of x is the
fixed point of that procedure

00:27:48.210 --> 00:27:59.180
which takes an argument
y and averages of x

00:27:59.180 --> 00:28:02.330
divided by y with y.

00:28:05.620 --> 00:28:08.120
And we're going to start up with
the initial guess for the

00:28:08.120 --> 00:28:09.630
fixed point of 1.

00:28:09.630 --> 00:28:11.860
It doesn't matter
where it starts.

00:28:11.860 --> 00:28:13.940
A theorem having to do
with square roots.

00:28:18.610 --> 00:28:21.410
So what you're seeing here is
I'm just trying to write out

00:28:21.410 --> 00:28:22.560
by wishful thinking.

00:28:22.560 --> 00:28:24.380
I don't know how I'm going to
make fixed point happen.

00:28:24.380 --> 00:28:26.290
We'll worry about that later.

00:28:26.290 --> 00:28:29.570
But if somehow I had a way of
finding the fixed point of the

00:28:29.570 --> 00:28:33.590
function computed by this
procedure, then I would have--

00:28:33.590 --> 00:28:36.120
that would be the square root
that I'm looking for.

00:28:39.770 --> 00:28:41.500
OK, well, now let's see how
we're going to write--

00:28:41.500 --> 00:28:43.470
how we're going to come
up with fixed points.

00:28:43.470 --> 00:28:44.890
Well, it's very simple,
actually.

00:28:44.890 --> 00:28:47.180
I'm going to write an
abbreviated version here just

00:28:47.180 --> 00:28:48.430
so we understand it.

00:29:00.450 --> 00:29:03.310
I'm going to find the fixed
point of a function f--

00:29:03.310 --> 00:29:06.140
actually, the fixed point of the
function computed by the

00:29:06.140 --> 00:29:09.990
procedure whose name will
be f in this procedure.

00:29:09.990 --> 00:29:11.025
How's that?

00:29:11.025 --> 00:29:13.230
A long sentence--

00:29:13.230 --> 00:29:14.820
starting with a particular
starting value.

00:29:19.920 --> 00:29:22.660
Well, I'm going to have a little
loop inside here, which

00:29:22.660 --> 00:29:25.800
is going to push the button on
the calculator repeatedly,

00:29:25.800 --> 00:29:28.940
hoping that it will eventually
converge.

00:29:28.940 --> 00:29:35.290
And we will say here internal
loops are written by defining

00:29:35.290 --> 00:29:36.540
internal procedures.

00:29:39.340 --> 00:29:41.860
Well, one thing I'm going to
have to do is I'm going to

00:29:41.860 --> 00:29:43.690
have to say whether I'm done.

00:29:43.690 --> 00:29:45.410
And the way I'm going to decide
when I'm done is when

00:29:45.410 --> 00:29:47.760
the old value and the new value
are close enough so I

00:29:47.760 --> 00:29:50.820
can't distinguish
them anymore.

00:29:50.820 --> 00:29:53.510
That's the standard thing you
do on the calculator unless

00:29:53.510 --> 00:29:54.970
you look at more precision,
and eventually,

00:29:54.970 --> 00:29:57.820
you run out of precision.

00:29:57.820 --> 00:30:06.530
So the old value and new value,
and I'm going to stay

00:30:06.530 --> 00:30:14.758
here if I can't distinguish them
if they're close enough,

00:30:14.758 --> 00:30:16.830
and we'll have to worry about
what that is soon.

00:30:20.780 --> 00:30:22.580
The old value and the new value
are close enough to each

00:30:22.580 --> 00:30:25.880
other and let's pick the new
value as the answer.

00:30:25.880 --> 00:30:33.520
Otherwise, I'm going to iterate
around again with the

00:30:33.520 --> 00:30:39.020
next value of old being the
current value of new and the

00:30:39.020 --> 00:30:43.160
next value of new being the
result of calling f on new.

00:30:54.810 --> 00:30:57.680
And so this is my iteration loop
that pushes the button on

00:30:57.680 --> 00:30:58.600
the calculator.

00:30:58.600 --> 00:31:00.760
I basically think of it as
having two registers on the

00:31:00.760 --> 00:31:02.495
calculator: old and new.

00:31:02.495 --> 00:31:09.070
And in each step, new becomes
old, and new gets F of new.

00:31:09.070 --> 00:31:13.080
So this is the thing where I'm
getting the next value.

00:31:13.080 --> 00:31:20.970
And now, I'm going to
start this thing up

00:31:20.970 --> 00:31:22.220
by giving two values.

00:31:28.470 --> 00:31:30.570
I wrote down on the blackboard
to be slow

00:31:30.570 --> 00:31:31.640
so you can see this.

00:31:31.640 --> 00:31:34.650
This is the first time you've
seen something quite this

00:31:34.650 --> 00:31:37.700
complicated, I think.

00:31:37.700 --> 00:31:44.710
However, we might want to see
the whole thing over here in

00:31:44.710 --> 00:31:50.720
this transparency or
slide or whatever.

00:31:50.720 --> 00:31:57.200
What we have is all of the
details that are required to

00:31:57.200 --> 00:31:58.500
make this thing work.

00:31:58.500 --> 00:32:01.660
I have a way of getting a
tolerance for a close enough

00:32:01.660 --> 00:32:03.080
procedure, which we see here.

00:32:03.080 --> 00:32:06.030
The close enough procedure, it
tests whether u and v are

00:32:06.030 --> 00:32:09.170
close enough by seeing if the
absolute value of the

00:32:09.170 --> 00:32:12.460
difference in u and v is less
than the given tolerance, OK?

00:32:12.460 --> 00:32:14.440
And here is the iteration loop
that I just wrote on the

00:32:14.440 --> 00:32:17.930
blackboard and the
initialization for it, which

00:32:17.930 --> 00:32:19.180
is right there.

00:32:21.680 --> 00:32:22.930
It's very simple.

00:32:34.210 --> 00:32:34.880
But let's see.

00:32:34.880 --> 00:32:36.630
I haven't told you enough.

00:32:36.630 --> 00:32:39.500
It's actually easier
than this.

00:32:39.500 --> 00:32:42.120
There is more structure to
this problem than I've

00:32:42.120 --> 00:32:43.310
already told you.

00:32:43.310 --> 00:32:45.700
Like why should this work?

00:32:45.700 --> 00:32:48.070
Why should it converge?

00:32:48.070 --> 00:32:50.930
There's a hairy theorem in
mathematics tied up in what

00:32:50.930 --> 00:32:52.760
I've written here.

00:32:52.760 --> 00:32:55.890
Why is it that I should assume
that by iterating averaging

00:32:55.890 --> 00:32:57.780
the quotient of x and y
and y that I should

00:32:57.780 --> 00:33:00.110
get the right answer?

00:33:00.110 --> 00:33:01.360
It isn't so obvious.

00:33:03.710 --> 00:33:07.280
Surely there are other things,
other procedures, which

00:33:07.280 --> 00:33:09.870
compute functions whose fixed
points would also be the

00:33:09.870 --> 00:33:12.040
square root.

00:33:12.040 --> 00:33:20.480
For example, the obvious one
will be a new function g,

00:33:20.480 --> 00:33:25.330
which maps y to x/y.

00:33:27.950 --> 00:33:30.870
That's even simpler.

00:33:30.870 --> 00:33:34.540
The fixed point of g is surely
the square root also, and it's

00:33:34.540 --> 00:33:37.400
a simpler procedure.

00:33:37.400 --> 00:33:39.020
Why am I not using it?

00:33:39.020 --> 00:33:40.470
Well, I suppose you know.

00:33:40.470 --> 00:33:44.970
Supposing x is 2 and I start out
with 1, and if I divide 1

00:33:44.970 --> 00:33:47.700
into 2, I get 2.

00:33:47.700 --> 00:33:49.610
And then if I divide
2 into 2, I get 1.

00:33:49.610 --> 00:33:52.740
If I divide 1 into 2, I get 2,
and 2 into 2, I get 1, and I

00:33:52.740 --> 00:33:55.480
never get any closer
to the square root.

00:33:55.480 --> 00:33:56.730
It just oscillates.

00:33:59.080 --> 00:34:03.110
So what we have is a signal
processing system, an

00:34:03.110 --> 00:34:06.230
electrical circuit which is
oscillating, and I want to

00:34:06.230 --> 00:34:07.480
damp out these oscillations.

00:34:10.530 --> 00:34:11.840
Well, I can do that.

00:34:11.840 --> 00:34:14.190
See, what I'm really doing
here when I'm taking my

00:34:14.190 --> 00:34:17.290
average, the average is
averaging the last two values

00:34:17.290 --> 00:34:21.350
of something which oscillates,
getting something in between.

00:34:21.350 --> 00:34:24.480
The classic way is damping out
oscillations in a signal

00:34:24.480 --> 00:34:25.730
processing system.

00:34:28.460 --> 00:34:31.719
So why don't we write down the
strategy that I just said in a

00:34:31.719 --> 00:34:33.872
more clear way?

00:34:33.872 --> 00:34:35.520
Well, that's easy enough.

00:34:38.639 --> 00:34:53.790
I'm going to define the square
root of x to be a fixed point

00:34:53.790 --> 00:34:58.510
of the procedure resulting
from average damping.

00:34:58.510 --> 00:35:10.780
So I have a procedure resulting
from average damp of

00:35:10.780 --> 00:35:24.820
the procedure, that procedure
of y, which divides x by y

00:35:24.820 --> 00:35:26.070
starting out at 1.

00:35:29.840 --> 00:35:33.520
Ah, but average damp is a
special procedure that's going

00:35:33.520 --> 00:35:35.720
to take a procedure as its
argument and return a

00:35:35.720 --> 00:35:38.080
procedure as its value.

00:35:38.080 --> 00:35:42.090
It's a generalization that says
given a procedure, it's

00:35:42.090 --> 00:35:45.090
the thing which produces a
procedure which averages the

00:35:45.090 --> 00:35:47.980
last value and the
value before and

00:35:47.980 --> 00:35:51.320
after running the procedure.

00:35:51.320 --> 00:35:53.260
You can use it for anything
if you want to damp out

00:35:53.260 --> 00:35:54.880
oscillations.

00:35:54.880 --> 00:35:56.495
So let's write that down.

00:35:56.495 --> 00:35:57.745
It's very easy.

00:36:00.624 --> 00:36:04.590
And stylistically here, I'm
going to use lambda notation

00:36:04.590 --> 00:36:06.950
because it's much easier to
think when you're dealing with

00:36:06.950 --> 00:36:08.845
procedure, the mid-line
procedures, to understand that

00:36:08.845 --> 00:36:11.552
the procedures are the objects
I'm dealing with, so I'm going

00:36:11.552 --> 00:36:13.830
to use lambda notation here.

00:36:13.830 --> 00:36:14.490
Not always.

00:36:14.490 --> 00:36:18.110
I don't always use it, but
very specifically here to

00:36:18.110 --> 00:36:22.040
expand on that idea,
to elucidate it.

00:36:28.590 --> 00:36:33.810
Well, average damp is a
procedure, which takes a

00:36:33.810 --> 00:36:37.560
procedure as its argument,
which we will call f.

00:36:37.560 --> 00:36:38.710
And what does it produce?

00:36:38.710 --> 00:36:40.340
It produces as its value--

00:36:40.340 --> 00:36:43.890
the body of this procedure is
a thing which produces a

00:36:43.890 --> 00:36:47.260
procedure, the construct of the
procedures right here, of

00:36:47.260 --> 00:37:00.440
one argument x, which averages
f of x with x.

00:37:10.420 --> 00:37:14.070
This is a very special thing.

00:37:14.070 --> 00:37:17.730
I think for the first time
you're seeing a procedure

00:37:17.730 --> 00:37:21.730
which produces a procedure
as its value.

00:37:21.730 --> 00:37:25.690
This procedure takes the
procedure f and does something

00:37:25.690 --> 00:37:29.360
to it to produce a new procedure
of one argument x,

00:37:29.360 --> 00:37:31.050
which averages f--

00:37:31.050 --> 00:37:31.950
this f--

00:37:31.950 --> 00:37:36.040
applied to x and x itself.

00:37:36.040 --> 00:37:40.280
Using the context here, I apply
average damping to the

00:37:40.280 --> 00:37:44.670
procedure, which just
divides x by y.

00:37:44.670 --> 00:37:45.920
It's a division.

00:37:48.122 --> 00:37:51.980
And I'm finding to fixed point
of that, and that's a clearer

00:37:51.980 --> 00:37:54.460
way of writing down what
I wrote down over

00:37:54.460 --> 00:37:57.796
here, wherever it was.

00:37:57.796 --> 00:38:01.110
Here, because it tells why
I am writing this down.

00:38:07.910 --> 00:38:11.110
I suppose this to some extent
really clarifies what Heron of

00:38:11.110 --> 00:38:14.260
Alexandria was up to.

00:38:14.260 --> 00:38:15.130
I suppose I'll stop now.

00:38:15.130 --> 00:38:16.380
Are there any questions?

00:38:18.190 --> 00:38:21.282
AUDIENCE: So when you define
average damp, don't you need

00:38:21.282 --> 00:38:25.210
to have a variable on f?

00:38:25.210 --> 00:38:28.150
PROFESSOR: Ah, the question was,
and here we're having--

00:38:28.150 --> 00:38:29.900
again, you've got to learn
about the syntax.

00:38:29.900 --> 00:38:33.840
The question was when defining
average damp, don't you have

00:38:33.840 --> 00:38:38.070
to have a variable
defined with f?

00:38:38.070 --> 00:38:40.310
What you are asking about is
the formal parameter of f?

00:38:40.310 --> 00:38:41.290
AUDIENCE: Yeah.

00:38:41.290 --> 00:38:42.810
PROFESSOR: OK.

00:38:42.810 --> 00:38:45.580
The formal parameter
of f is here.

00:38:45.580 --> 00:38:47.318
The formal parameter of f--

00:38:47.318 --> 00:38:50.190
AUDIENCE: The formal parameter
of average damp.

00:38:50.190 --> 00:38:51.890
PROFESSOR: F is being
used to apply it to

00:38:51.890 --> 00:38:54.400
an argument, right?

00:38:54.400 --> 00:38:57.780
It's indeed true that f must
have a formal parameter.

00:38:57.780 --> 00:39:00.380
Let's find out what f's
formal parameter is.

00:39:00.380 --> 00:39:02.440
AUDIENCE: The formal parameter
of average damp.

00:39:02.440 --> 00:39:04.700
PROFESSOR: Oh, f is the formal
parameter of average damp.

00:39:04.700 --> 00:39:05.500
I'm sorry.

00:39:05.500 --> 00:39:07.910
You're just confusing
a syntactic thing.

00:39:07.910 --> 00:39:10.470
I could have written
this the other way.

00:39:10.470 --> 00:39:12.520
Actually, I didn't understand
your question.

00:39:12.520 --> 00:39:13.910
Of course, I could have written
it this other way.

00:39:19.340 --> 00:39:21.540
Those are identical notations.

00:39:21.540 --> 00:39:25.607
This is a different way
of writing this.

00:39:31.710 --> 00:39:33.280
You're going to have to get
used to lambda notation

00:39:33.280 --> 00:39:35.520
because I'm going to use it.

00:39:35.520 --> 00:39:40.460
What it says here, I'm defining
the name average damp

00:39:40.460 --> 00:39:44.600
to name the procedure whose
of one argument f.

00:39:44.600 --> 00:39:49.250
That's the formal parameter of
the procedure average damp.

00:39:49.250 --> 00:39:56.550
What define does is it says
give this name a value.

00:39:56.550 --> 00:39:57.860
Here is the value of for it.

00:40:01.310 --> 00:40:05.100
That there happens to be a
funny syntax to make that

00:40:05.100 --> 00:40:08.085
easier in some cases is
purely convenience.

00:40:10.900 --> 00:40:14.540
But the reason why I wrote it
this way here is to emphasize

00:40:14.540 --> 00:40:16.530
that I'm dealing with a
procedure that takes a

00:40:16.530 --> 00:40:18.100
procedure as its argument
and produces a

00:40:18.100 --> 00:40:19.350
procedure as its value.

00:40:23.640 --> 00:40:25.800
AUDIENCE: I don't understand
why you use lambda twice.

00:40:25.800 --> 00:40:27.760
Can you just use one
lambda and take two

00:40:27.760 --> 00:40:29.230
arguments f and x?

00:40:29.230 --> 00:40:29.520
PROFESSOR: No.

00:40:29.520 --> 00:40:30.330
AUDIENCE: You can't?

00:40:30.330 --> 00:40:32.500
PROFESSOR: No, that would
be a different thing.

00:40:32.500 --> 00:40:36.190
If I were to write the procedure
lambda of f and x,

00:40:36.190 --> 00:40:40.090
the average of f of x and x,
that would not be something

00:40:40.090 --> 00:40:42.810
which would be allowed to take a
procedure as an argument and

00:40:42.810 --> 00:40:44.580
produce a procedure
as its value.

00:40:44.580 --> 00:40:46.330
That would be a thing that
takes a procedure as its

00:40:46.330 --> 00:40:48.700
argument and numbers
its argument and

00:40:48.700 --> 00:40:50.620
produces a new number.

00:40:50.620 --> 00:40:53.650
But what I'm producing here is
a procedure to fit in the

00:40:53.650 --> 00:40:56.090
procedure slot over here,
which is going to

00:40:56.090 --> 00:40:58.860
be used over here.

00:40:58.860 --> 00:41:01.450
So the number has to
come from here.

00:41:01.450 --> 00:41:04.440
This is the thing that's going
to eventually end up in the x.

00:41:04.440 --> 00:41:07.810
And if you're confused, you
should do some substitution

00:41:07.810 --> 00:41:09.060
and see for yourself.

00:41:12.010 --> 00:41:12.746
Yes?

00:41:12.746 --> 00:41:15.870
AUDIENCE: Will you please show
the definition for average

00:41:15.870 --> 00:41:19.320
damp without using lambda
notation in both cases.

00:41:19.320 --> 00:41:21.490
PROFESSOR: I can't make a very
simple one like that.

00:41:21.490 --> 00:41:22.990
Let me do it for you, though.

00:41:22.990 --> 00:41:26.530
I can get rid of this
lambda easily.

00:41:26.530 --> 00:41:27.780
I don't want to be--

00:41:32.760 --> 00:41:33.810
actually, I'm lying to you.

00:41:33.810 --> 00:41:37.170
I don't want to do what you want
because I think it's more

00:41:37.170 --> 00:41:39.310
confusing than you think.

00:41:39.310 --> 00:41:40.560
I'm not going to write
what you want.

00:41:55.450 --> 00:41:56.500
So we'll have to get a name.

00:41:56.500 --> 00:42:13.370
FOO of x to be of F of x and x
and return as a value FOO.

00:42:17.140 --> 00:42:20.406
This is equivalent, but
I've had to make an

00:42:20.406 --> 00:42:21.700
arbitrary name up.

00:42:21.700 --> 00:42:26.290
This is equivalent to this
without any lambdas.

00:42:26.290 --> 00:42:31.240
Lambda is very convenient for
naming anonymous procedures.

00:42:31.240 --> 00:42:34.080
It's the anonymous name
of something.

00:42:34.080 --> 00:42:39.780
Now, if you really want to know
a cute way of doing this,

00:42:39.780 --> 00:42:41.820
we'll talk about it later.

00:42:41.820 --> 00:42:44.680
We're going to have to define
the anonymous procedure.

00:42:44.680 --> 00:42:45.930
Any other questions?

00:42:49.116 --> 00:42:50.880
And so we go for our
break again.

00:43:31.740 --> 00:43:35.380
So now we've seen how
to use high-order

00:43:35.380 --> 00:43:36.490
procedures, they're called.

00:43:36.490 --> 00:43:38.570
That's procedures that take
procedural arguments and

00:43:38.570 --> 00:43:43.310
produce procedural values to
help us clarify and abstract

00:43:43.310 --> 00:43:46.470
some otherwise complicated
processes.

00:43:46.470 --> 00:43:48.500
I suppose what I'd like to do
now is have a bit of fun with

00:43:48.500 --> 00:43:54.080
that and sort of a little
practice as well.

00:43:54.080 --> 00:43:56.290
So let's play with this square
root thing even more.

00:43:56.290 --> 00:43:59.800
Let's elaborate it and
understand what's going on and

00:43:59.800 --> 00:44:04.270
make use of this kind of
programming style.

00:44:04.270 --> 00:44:08.680
One thing that you might know
is that there is a general

00:44:08.680 --> 00:44:12.990
method called Newton's method
the purpose of which is to

00:44:12.990 --> 00:44:15.180
find the roots--

00:44:15.180 --> 00:44:17.280
that's the zeroes--

00:44:17.280 --> 00:44:19.130
of functions.

00:44:19.130 --> 00:44:38.420
So, for example, to find a y
such that f of y equals 0, we

00:44:38.420 --> 00:44:40.280
start with some guess.

00:44:40.280 --> 00:44:41.530
This is Newton's method.

00:44:51.260 --> 00:44:55.860
And the guess we start with
we'll call y0, and then we

00:44:55.860 --> 00:45:01.100
will iterate the following
expression.

00:45:01.100 --> 00:45:04.880
y n plus 1-- this is a
difference equation--

00:45:04.880 --> 00:45:17.366
is yn minus f of yn over the
derivative with respect to y

00:45:17.366 --> 00:45:23.270
of f evaluated at y equal yn.

00:45:23.270 --> 00:45:26.430
Very strange notation.

00:45:26.430 --> 00:45:31.700
I must say ugh.

00:45:31.700 --> 00:45:35.990
The derivative of f with respect
to y is a function.

00:45:35.990 --> 00:45:38.420
I'm having a little bit of
unhappiness with that, but

00:45:38.420 --> 00:45:39.120
that's all right.

00:45:39.120 --> 00:45:41.050
It turns out in the programming
language world,

00:45:41.050 --> 00:45:43.930
the notation is much clearer.

00:45:43.930 --> 00:45:45.950
Now, what is this?

00:45:45.950 --> 00:45:47.330
People call it Newton's
method.

00:45:47.330 --> 00:45:54.250
It's a method for finding the
roots of the function f.

00:45:54.250 --> 00:45:56.410
And it, of course, sometimes
converges, and when it does,

00:45:56.410 --> 00:45:59.310
it does so very fast. And
sometimes, it doesn't

00:45:59.310 --> 00:46:03.230
converge, and, oh well, we have
to do something else.

00:46:03.230 --> 00:46:07.190
But let's talk about square
root by Newton's method.

00:46:07.190 --> 00:46:08.680
Well, that's rather
interesting.

00:46:08.680 --> 00:46:11.340
Let's do exactly the same thing
we did last time: a bit

00:46:11.340 --> 00:46:13.490
of wishful thinking.

00:46:13.490 --> 00:46:18.210
We will apply Newton's method,
assuming we knew how to do it.

00:46:18.210 --> 00:46:20.620
You don't know how
to do it yet.

00:46:20.620 --> 00:46:21.870
Well, let's go.

00:46:25.090 --> 00:46:26.070
What do I have here?

00:46:26.070 --> 00:46:27.320
The square root of x.

00:46:31.410 --> 00:46:37.480
It's Newton's method applied
to a procedure which will

00:46:37.480 --> 00:46:39.990
represent that function
of y, which computes

00:46:39.990 --> 00:46:42.480
that function of y.

00:46:42.480 --> 00:46:48.820
Well, that procedure is that
procedure of y, which is the

00:46:48.820 --> 00:46:51.810
difference between x and
the square of y.

00:47:00.080 --> 00:47:07.570
Indeed, if I had a value of y
for which this was zero, then

00:47:07.570 --> 00:47:10.020
y would be the square
root of x.

00:47:13.730 --> 00:47:15.550
See that?

00:47:15.550 --> 00:47:19.250
OK, I'm going to start this
out searching at 1.

00:47:19.250 --> 00:47:23.570
Again, completely arbitrary
property of square roots that

00:47:23.570 --> 00:47:24.820
I can do that.

00:47:27.950 --> 00:47:31.480
Now, how am I going to compute
Newton's method?

00:47:31.480 --> 00:47:32.170
Well, this is the method.

00:47:32.170 --> 00:47:34.310
I have it right here.

00:47:34.310 --> 00:47:37.740
In fact, what I'm doing is
looking for a fixed point of

00:47:37.740 --> 00:47:41.240
some procedure.

00:47:41.240 --> 00:47:45.190
This procedure involves some
complicated expressions in

00:47:45.190 --> 00:47:47.150
terms of other complicated
things.

00:47:47.150 --> 00:47:48.800
Well, I'm trying to find the
fixed point of this.

00:47:48.800 --> 00:47:54.620
I want to find the values of y,
which if I put y in here, I

00:47:54.620 --> 00:48:00.130
get the same value out here up
to some degree of accuracy.

00:48:00.130 --> 00:48:02.710
Well, I already have a
fixed point process

00:48:02.710 --> 00:48:05.040
around to do that.

00:48:05.040 --> 00:48:07.350
And so, let's just define
Newton's method over here.

00:48:19.430 --> 00:48:21.680
A procedure which computes
a function and a

00:48:21.680 --> 00:48:26.640
guess, initial guess.

00:48:26.640 --> 00:48:28.920
Now, I'm going to have
to do something here.

00:48:28.920 --> 00:48:33.280
I'm going to need the derivative
of the function.

00:48:33.280 --> 00:48:36.550
I'm going to need a procedure
which computes the derivative

00:48:36.550 --> 00:48:39.490
of the function computed by
the given a procedure f.

00:48:42.140 --> 00:48:44.440
I'm trying to be very careful
about what I'm saying.

00:48:44.440 --> 00:48:46.270
I don't want to mix up the word
procedure and function.

00:48:46.270 --> 00:48:47.875
Function is a mathematical
word.

00:48:47.875 --> 00:48:52.950
It says I'm mapping from values
to other values, a set

00:48:52.950 --> 00:48:55.430
of ordered pairs.

00:48:55.430 --> 00:49:00.380
But sometimes, I'll accidentally
mix those up.

00:49:00.380 --> 00:49:01.655
Procedures compute functions.

00:49:07.400 --> 00:49:12.100
So I'm going to define the
derivative of f to be by

00:49:12.100 --> 00:49:12.930
wishful thinking again.

00:49:12.930 --> 00:49:14.720
I don't know how I'm
going to do it.

00:49:14.720 --> 00:49:15.970
Let's worry about that later--

00:49:18.612 --> 00:49:25.340
of F. So if F is a procedure,
which happens to be this one

00:49:25.340 --> 00:49:31.800
over here for a square root,
then DF will be the derivative

00:49:31.800 --> 00:49:34.890
of it, which is also the
derivative of the function

00:49:34.890 --> 00:49:36.080
computed by that procedure.

00:49:36.080 --> 00:49:38.760
DF will be a procedure that
computes the derivative of the

00:49:38.760 --> 00:49:42.920
function computed by the
procedure F. And then given

00:49:42.920 --> 00:49:44.850
that, I will just go looking
for a fixed point.

00:49:51.910 --> 00:49:53.710
What is the fixed point
I'm looking for?

00:49:53.710 --> 00:49:57.580
It's the one for that procedure
of one argument x,

00:49:57.580 --> 00:50:00.500
which I compute by
subtracting x.

00:50:00.500 --> 00:50:04.870
That's the old-- that's
the yn here.

00:50:04.870 --> 00:50:21.110
The quotient of f of x and df
of x, starting out with the

00:50:21.110 --> 00:50:22.360
original guess.

00:50:29.450 --> 00:50:32.640
That's all very simple.

00:50:32.640 --> 00:50:35.130
Now, I have one part left that
I haven't written, and I want

00:50:35.130 --> 00:50:37.720
you to see the process by which
I write these things,

00:50:37.720 --> 00:50:40.150
because this is really true.

00:50:40.150 --> 00:50:43.810
I start out with some
mathematical idea, perhaps.

00:50:43.810 --> 00:50:48.440
By wishful thinking, I assume
that by some magic I can do

00:50:48.440 --> 00:50:50.980
something that I have
a name for.

00:50:50.980 --> 00:50:54.850
I'm not going to worry about
how I do it yet.

00:50:54.850 --> 00:50:57.970
Then I go walking down here and
say, well, by some magic,

00:50:57.970 --> 00:51:01.142
I'm somehow going to figure how
to do that, but I'm going

00:51:01.142 --> 00:51:04.330
to write my program anyway.

00:51:04.330 --> 00:51:07.990
Wishful thinking, essential
to good engineering, and

00:51:07.990 --> 00:51:10.060
certainly essential to a
good computer science.

00:51:12.770 --> 00:51:15.900
So anyway, how many of
you wished that your

00:51:15.900 --> 00:51:17.150
computer ran faster?

00:51:21.120 --> 00:51:23.390
Well, the derivative isn't
so bad either.

00:51:23.390 --> 00:51:24.640
Sort of like average damping.

00:51:28.922 --> 00:51:34.010
The derivative is a procedure
that takes a procedure that

00:51:34.010 --> 00:51:38.560
computes a function as its
argument, and it produces a

00:51:38.560 --> 00:51:42.230
procedure that computes a
function, which needs one

00:51:42.230 --> 00:51:43.930
argument x.

00:51:43.930 --> 00:51:46.270
Well, you all know
this definition.

00:51:46.270 --> 00:51:49.040
It's f of x plus delta x minus
f of x over delta x, right?

00:51:49.040 --> 00:51:50.800
For some small delta x.

00:51:50.800 --> 00:51:59.850
So that's the quotient of the
difference of f of the sum of

00:51:59.850 --> 00:52:10.345
x and dx minus f point
x divided by dx.

00:52:18.530 --> 00:52:21.360
I think the thing was lining up
correctly when I balanced

00:52:21.360 --> 00:52:22.610
the parentheses.

00:52:25.120 --> 00:52:27.070
Now, I want you to
look at this.

00:52:27.070 --> 00:52:28.320
Just look.

00:52:31.330 --> 00:52:33.220
I suppose I haven't told
you what dx is.

00:52:33.220 --> 00:52:44.880
Somewhere in the world I'm going
to have to write down

00:52:44.880 --> 00:52:45.770
something like that.

00:52:45.770 --> 00:52:48.150
I'm not interested.

00:52:48.150 --> 00:52:52.970
This is a procedure which takes
a procedure and produces

00:52:52.970 --> 00:52:55.950
an approximation, a procedure
that computes an approximation

00:52:55.950 --> 00:52:58.010
of the derivative of the
function computed by the

00:52:58.010 --> 00:53:02.740
procedure given by the standard
methods that you all

00:53:02.740 --> 00:53:04.800
know and love.

00:53:04.800 --> 00:53:08.920
Now, it may not be the case that
doing this operation is

00:53:08.920 --> 00:53:11.390
such a good way of approximating
a derivative.

00:53:11.390 --> 00:53:14.800
Numerical analysts here
should jump on me and

00:53:14.800 --> 00:53:16.690
say don't do that.

00:53:16.690 --> 00:53:20.150
Computing derivatives produces
noisy answers, which is true.

00:53:20.150 --> 00:53:24.850
However, this again is for the
sake of understanding.

00:53:24.850 --> 00:53:26.620
Look what we've got.

00:53:26.620 --> 00:53:29.040
We started out with what is
apparently a mathematically

00:53:29.040 --> 00:53:31.210
complex thing.

00:53:31.210 --> 00:53:31.610
and.

00:53:31.610 --> 00:53:35.370
In a few blackboards full, we
managed to decompose the

00:53:35.370 --> 00:53:37.900
problem of computing square
roots by the way you were

00:53:37.900 --> 00:53:41.770
taught in your college
calculus class--

00:53:41.770 --> 00:53:43.720
Newton's method--

00:53:43.720 --> 00:53:45.830
so that it can be understood.

00:53:45.830 --> 00:53:47.840
It's clear.

00:53:47.840 --> 00:53:51.231
Let's look at the structure
of what it is we've got.

00:53:51.231 --> 00:53:54.660
Let's look at this slide.

00:53:54.660 --> 00:54:03.110
This is a diagram of the machine
described by the

00:54:03.110 --> 00:54:05.520
program on the blackboard.

00:54:05.520 --> 00:54:08.940
There's a machine
described here.

00:54:08.940 --> 00:54:10.700
And what have I got?

00:54:10.700 --> 00:54:17.690
Over here is the Newton's method
function f that we have

00:54:17.690 --> 00:54:21.040
on the left-most blackboard.

00:54:21.040 --> 00:54:24.990
It's the thing that takes an
argument called y and puts out

00:54:24.990 --> 00:54:32.500
the difference between x and
the square of y, where x is

00:54:32.500 --> 00:54:35.400
some sort of free variable that
comes in from the outside

00:54:35.400 --> 00:54:38.050
by some magic.

00:54:38.050 --> 00:54:43.430
So the square root routine picks
up an x, and builds this

00:54:43.430 --> 00:54:47.750
procedure, which I have the
x rolled up in it by

00:54:47.750 --> 00:54:50.170
substitution.

00:54:50.170 --> 00:54:58.930
Now, this procedure in the cloud
is fed in as the f into

00:54:58.930 --> 00:55:01.630
the Newton's method which
is here, this box.

00:55:04.650 --> 00:55:08.790
The f is fanned out.

00:55:08.790 --> 00:55:12.130
Part of it goes into something
else, and the other part of it

00:55:12.130 --> 00:55:15.670
goes through a derivative
process into something else to

00:55:15.670 --> 00:55:20.570
produce a procedure, which
computes the function which is

00:55:20.570 --> 00:55:24.090
the iteration function of
Newton's method when we use

00:55:24.090 --> 00:55:27.450
the fixed point method.

00:55:27.450 --> 00:55:33.030
So this procedure, which
contains it by substitution--

00:55:33.030 --> 00:55:37.730
remember, Newton's method over
here, Newton's method builds

00:55:37.730 --> 00:55:43.010
this procedure, and Newton's
method has in it defined f and

00:55:43.010 --> 00:55:48.900
df, so those are captured
over here: f and df.

00:55:48.900 --> 00:55:51.930
Starting with this procedure,
I can now feed this to the

00:55:51.930 --> 00:55:55.260
fixed point process within an
initial guess coming out from

00:55:55.260 --> 00:55:59.135
the outside from square
root to produce the

00:55:59.135 --> 00:56:00.385
square root of x.

00:56:03.680 --> 00:56:07.680
So what we've built is a very
powerful engine, which allows

00:56:07.680 --> 00:56:11.256
us to make nice things
like this.

00:56:11.256 --> 00:56:19.000
Now, I want to end this with
basically an idea of Chris

00:56:19.000 --> 00:56:21.520
Strachey, one of the

00:56:21.520 --> 00:56:23.230
grandfathers of computer science.

00:56:23.230 --> 00:56:27.440
He's a logician who
lived in the--

00:56:27.440 --> 00:56:30.320
I suppose about 10 years ago
or 15 years ago, he died.

00:56:30.320 --> 00:56:31.840
I don't remember exactly when.

00:56:31.840 --> 00:56:33.250
He's one of the inventors
of something called

00:56:33.250 --> 00:56:34.820
denotational semantics.

00:56:34.820 --> 00:56:40.560
He was a great advocate of
making procedures or functions

00:56:40.560 --> 00:56:43.950
first-class citizens in a
programming language.

00:56:43.950 --> 00:56:46.910
So here's the rights and
privileges of first-class

00:56:46.910 --> 00:56:50.690
citizens in a programming
language.

00:56:50.690 --> 00:56:53.070
It allows you to make any
abstraction you like if you

00:56:53.070 --> 00:56:57.710
have functions as first-class
citizens.

00:56:57.710 --> 00:56:59.030
The first-class citizens
must be able

00:56:59.030 --> 00:57:02.270
to be named by variables.

00:57:02.270 --> 00:57:04.600
And you're seeing me doing
that all the time.

00:57:04.600 --> 00:57:07.700
Here's a nice variable which
names a procedure which

00:57:07.700 --> 00:57:08.950
computes something.

00:57:13.270 --> 00:57:15.370
They have to be passed as
arguments to procedures.

00:57:15.370 --> 00:57:18.540
We've certainly seen that.

00:57:18.540 --> 00:57:20.640
We have to be able to return
them as values from

00:57:20.640 --> 00:57:23.340
procedures.

00:57:23.340 --> 00:57:25.300
And I suppose we've seen that.

00:57:25.300 --> 00:57:27.970
We haven't yet seen anything
about data structures.

00:57:27.970 --> 00:57:31.490
We will soon, but it's also the
case that in order to have

00:57:31.490 --> 00:57:33.940
a first-class citizen in a
programming language, the

00:57:33.940 --> 00:57:37.200
object has to be allowed to be
part of a data structure.

00:57:37.200 --> 00:57:39.110
We're going to see that soon.

00:57:39.110 --> 00:57:43.530
So I just want to close with
this and say having things

00:57:43.530 --> 00:57:46.180
like procedures as first-class
data structures, first-class

00:57:46.180 --> 00:57:50.780
data, allows one to make
powerful abstractions, which

00:57:50.780 --> 00:57:53.110
encode general methods
like Newton's method

00:57:53.110 --> 00:57:54.780
in very clear way.

00:57:54.780 --> 00:57:57.430
Are there any questions?

00:57:57.430 --> 00:57:57.780
Yes.

00:57:57.780 --> 00:58:00.040
AUDIENCE: Could you put
derivative instead of df

00:58:00.040 --> 00:58:02.570
directly in the fixed point?

00:58:02.570 --> 00:58:03.810
PROFESSOR: Oh, sure.

00:58:03.810 --> 00:58:09.220
Yes, I could have put deriv of
f right here, no question.

00:58:11.810 --> 00:58:16.190
Any time you see something
defined, you can put the thing

00:58:16.190 --> 00:58:18.950
that the definition is
there because you

00:58:18.950 --> 00:58:21.060
get the same result.

00:58:21.060 --> 00:58:22.800
In fact, what that would look
like, it's interesting.

00:58:22.800 --> 00:58:23.750
AUDIENCE: Lambda.

00:58:23.750 --> 00:58:24.085
PROFESSOR: Huh?

00:58:24.085 --> 00:58:25.970
AUDIENCE: You could put the
lambda expression in there.

00:58:25.970 --> 00:58:29.990
PROFESSOR: I could also put
derivative of f here.

00:58:29.990 --> 00:58:32.640
It would look interesting
because of the open paren,

00:58:32.640 --> 00:58:38.610
open paren, deriv of f,
closed paren on an x.

00:58:38.610 --> 00:58:40.900
Now, that would have the bad
property of computing the

00:58:40.900 --> 00:58:43.980
derivative many times, because
every time I would run this

00:58:43.980 --> 00:58:45.490
procedure, I would compute
the derivative again.

00:58:48.030 --> 00:58:52.510
However, the two open parens
here both would be meaningful.

00:58:52.510 --> 00:58:54.600
I want you to understand
syntactically that that's a

00:58:54.600 --> 00:58:55.350
sensible thing.

00:58:55.350 --> 00:58:58.190
Because if was to rewrite this
program-- and I should do it

00:58:58.190 --> 00:59:00.210
right here just so
you see because

00:59:00.210 --> 00:59:01.460
that's a good question--

00:59:11.490 --> 00:59:25.430
of F and guess to be fixed point
of that procedure of one

00:59:25.430 --> 00:59:34.920
argument x, which subtracts
from x the quotient of F

00:59:34.920 --> 00:59:45.045
applied to x and the deriv
of F applied to x.

00:59:53.459 --> 00:59:54.709
This is guess.

00:59:59.960 --> 01:00:02.680
This is a perfectly legitimate
program,

01:00:02.680 --> 01:00:04.250
because what I have here--

01:00:04.250 --> 01:00:05.910
remember the evaluation rule.

01:00:05.910 --> 01:00:08.760
The evaluation rule is evaluate
all of the parts of

01:00:08.760 --> 01:00:12.070
the combination: the operator
and the operands.

01:00:12.070 --> 01:00:14.575
This is the operator of
this combination.

01:00:17.080 --> 01:00:21.080
Evaluating this operator will,
of course, produce the

01:00:21.080 --> 01:00:28.250
derivative of F.

01:00:28.250 --> 01:00:30.300
AUDIENCE: To get it one step
further, you could put the

01:00:30.300 --> 01:00:31.200
lambda expression there, too.

01:00:31.200 --> 01:00:33.180
PROFESSOR: Oh, of course.

01:00:33.180 --> 01:00:37.620
Any time I take something which
is define, I can put the

01:00:37.620 --> 01:00:40.420
thing it's defined to be in
the place where the thing

01:00:40.420 --> 01:00:42.420
defined is.

01:00:42.420 --> 01:00:44.430
I can't remember which is
definiens and which is

01:00:44.430 --> 01:00:45.680
definiendum.

01:00:47.490 --> 01:00:50.230
When I'm trying to figure out
how to do a lecture about this

01:00:50.230 --> 01:00:54.160
in a freshman class, I use such
words and tell everybody

01:00:54.160 --> 01:00:55.440
it's fun to tell
their friends.

01:00:59.470 --> 01:01:01.460
OK, I think that's it.