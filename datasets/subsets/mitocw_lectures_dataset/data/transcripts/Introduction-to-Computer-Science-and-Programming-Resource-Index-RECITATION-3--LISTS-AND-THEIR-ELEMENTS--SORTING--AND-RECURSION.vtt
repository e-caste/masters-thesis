WEBVTT

00:00:00.530 --> 00:00:02.960
The following content is
provided under a Creative

00:00:02.960 --> 00:00:04.370
Commons license.

00:00:04.370 --> 00:00:07.410
Your support will help MIT
OpenCourseWare continue to

00:00:07.410 --> 00:00:11.060
offer high quality educational
resources for free.

00:00:11.060 --> 00:00:13.960
To make a donation or view
additional materials from

00:00:13.960 --> 00:00:19.790
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:19.790 --> 00:00:21.040
ocw.mit.edu.

00:00:23.050 --> 00:00:25.840
PROFESSOR: So let's start.

00:00:25.840 --> 00:00:28.980
I mean for the first question
you can answer what is tuple.

00:00:28.980 --> 00:00:30.870
You can go to that later.

00:00:30.870 --> 00:00:32.520
Can a tuple contain a list?

00:00:35.280 --> 00:00:36.730
What do you think?

00:00:36.730 --> 00:00:38.960
Can a tuple contain a list?

00:00:38.960 --> 00:00:39.820
AUDIENCE: Yes.

00:00:39.820 --> 00:00:41.620
PROFESSOR: Yes, it can.

00:00:41.620 --> 00:00:43.790
So we'll go through the
examples later.

00:00:43.790 --> 00:00:48.890
And let's see this
first example.

00:00:48.890 --> 00:00:50.305
We have two tuples.

00:00:50.305 --> 00:00:53.500
The tuple B contains tuple
A, as well as a list.

00:00:56.640 --> 00:00:57.890
So it can't populate.

00:01:00.120 --> 00:01:01.630
Let's bring those lists, too.

00:01:07.540 --> 00:01:14.840
So for the first example we try
to access the elements 0

00:01:14.840 --> 00:01:22.730
and 2 of the tuple A. And
let me use minus 1 to

00:01:22.730 --> 00:01:24.450
access which element?

00:01:24.450 --> 00:01:26.715
AUDIENCE: [INAUDIBLE]

00:01:26.715 --> 00:01:28.080
PROFESSOR: OK.

00:01:28.080 --> 00:01:30.150
And 0 is the first element,
of course.

00:01:30.150 --> 00:01:32.830
And remember now we
are using 0, 1.

00:01:37.260 --> 00:01:39.970
OK, what is tuple B?

00:01:39.970 --> 00:01:42.750
It's a two-dimensional tuple.

00:01:42.750 --> 00:01:43.630
AUDIENCE: [INAUDIBLE]

00:01:43.630 --> 00:01:44.600
PROFESSOR: Yeah, exactly.

00:01:44.600 --> 00:01:46.860
It has a list and
a tuple inside.

00:01:46.860 --> 00:01:50.640
So the first element is
a tuple, and the last

00:01:50.640 --> 00:01:51.920
element is the list.

00:01:51.920 --> 00:01:54.720
So now it's sort of like
two-dimensional.

00:01:54.720 --> 00:01:59.960
But if you look at the first
element of it, the MIT word,

00:01:59.960 --> 00:02:02.420
that doesn't have
any dimension.

00:02:02.420 --> 00:02:04.600
Does it?

00:02:04.600 --> 00:02:05.320
It's a string.

00:02:05.320 --> 00:02:07.650
So you can again access,
but not this way.

00:02:07.650 --> 00:02:08.900
But still you can access.

00:02:12.330 --> 00:02:18.360
And we are using this notation
to access a portion of the

00:02:18.360 --> 00:02:21.870
list, a part of the tuple,
actually, here.

00:02:21.870 --> 00:02:23.770
It's called slicing.

00:02:23.770 --> 00:02:27.240
So here 0 to 1 gives
you which element?

00:02:29.760 --> 00:02:30.960
Just one element right?

00:02:30.960 --> 00:02:32.210
It's the first element.

00:02:35.140 --> 00:02:40.790
0 to 2 gives you 1 and 2 OK?

00:02:40.790 --> 00:02:45.780
This is an interesting
usage of the slicing.

00:02:45.780 --> 00:02:48.695
This is used to access
the whole tuple.

00:02:48.695 --> 00:02:50.720
Now you might wonder
why we need them.

00:02:50.720 --> 00:02:52.186
We could just--

00:02:52.186 --> 00:02:54.920
the handouts are here.

00:02:54.920 --> 00:03:00.100
So why we need to copy or why
we need to access the list

00:03:00.100 --> 00:03:03.810
through the column operator
like this?

00:03:03.810 --> 00:03:04.690
We'll look at that later.

00:03:04.690 --> 00:03:09.090
It's very essential when
we have lists.

00:03:09.090 --> 00:03:12.610
For the timing it's OK when
tuples are immutable.

00:03:12.610 --> 00:03:15.840
So it doesn't have
a special usage.

00:03:15.840 --> 00:03:18.310
But later on we'll
be using it.

00:03:18.310 --> 00:03:20.650
Then if you look at this
part, this is the

00:03:20.650 --> 00:03:22.500
most interesting part.

00:03:22.500 --> 00:03:23.850
How do iterate through
a tuple?

00:03:26.490 --> 00:03:30.770
You use a FOR loop and you call
like item in tuple, the

00:03:30.770 --> 00:03:33.290
element in tuple.

00:03:33.290 --> 00:03:37.510
The element is initialized with
every element when it

00:03:37.510 --> 00:03:38.990
goes through iteration.

00:03:38.990 --> 00:03:44.380
At every iteration it will
be instantiated with the

00:03:44.380 --> 00:03:46.580
corresponding element
in the tuple.

00:03:46.580 --> 00:03:48.315
But you're using the
same name anyway.

00:03:48.315 --> 00:03:49.565
It's item.

00:03:51.450 --> 00:03:54.105
This is equivalent to accessing
the tuple like this.

00:03:57.760 --> 00:04:00.650
Going one-by-one in the range
and accessing their

00:04:00.650 --> 00:04:02.330
corresponding element
in the tuple.

00:04:02.330 --> 00:04:05.630
So this is the simpler
way to access that.

00:04:05.630 --> 00:04:07.205
Do you have any questions
in that part?

00:04:12.940 --> 00:04:14.900
Yeah?

00:04:14.900 --> 00:04:17.595
AUDIENCE: For that part, don't,
usually if you have a

00:04:17.595 --> 00:04:19.310
range you have to [INAUDIBLE]

00:04:19.310 --> 00:04:22.750
name because is not--

00:04:22.750 --> 00:04:24.530
PROFESSOR: OK, that's correct.

00:04:24.530 --> 00:04:25.610
.

00:04:25.610 --> 00:04:27.000
OK.

00:04:27.000 --> 00:04:30.040
Suppose a tuple has 3 elements,
or for example in

00:04:30.040 --> 00:04:33.130
this case tuple A, how many
elements are in the tuple A?

00:04:33.130 --> 00:04:34.250
3 elements.

00:04:34.250 --> 00:04:36.265
So what would be the
length of tuple A?

00:04:36.265 --> 00:04:36.630
AUDIENCE: 3.

00:04:36.630 --> 00:04:37.330
PROFESSOR: 3.

00:04:37.330 --> 00:04:39.650
But what would be the range?

00:04:39.650 --> 00:04:41.350
0, 1, 2, right?

00:04:41.350 --> 00:04:44.470
So you have to type 0 to 3.

00:04:44.470 --> 00:04:47.180
So that's why I put that, OK?

00:04:47.180 --> 00:04:50.678
That is 3, OK?

00:04:50.678 --> 00:04:51.176
PROFESSOR: You.

00:04:51.176 --> 00:04:54.247
AUDIENCE: So you just say a
range like the tuple is, it

00:04:54.247 --> 00:04:55.170
seems like the first one--

00:04:55.170 --> 00:04:57.264
PROFESSOR: First the 0 if you
don't specify it the same way.

00:05:08.200 --> 00:05:08.880
OK.

00:05:08.880 --> 00:05:10.370
Now let's go through the list.

00:05:18.730 --> 00:05:22.620
So if you go through the
questions, what is the

00:05:22.620 --> 00:05:24.330
difference between a
list and a tuple?

00:05:27.990 --> 00:05:30.293
What is the difference between
a list and a tuple?

00:05:30.293 --> 00:05:31.682
Anyone?

00:05:31.682 --> 00:05:33.534
Yeah?

00:05:33.534 --> 00:05:34.923
AUDIENCE: Tuples
are immutable.

00:05:34.923 --> 00:05:35.390
PROFESSOR: OK.

00:05:35.390 --> 00:05:36.450
Lists are mutable.

00:05:36.450 --> 00:05:41.190
And because it's mutable it
takes special functions to

00:05:41.190 --> 00:05:44.470
access the elements,
add elements, and

00:05:44.470 --> 00:05:46.220
modify the list itself.

00:05:49.210 --> 00:05:51.535
How would you add an
element to a list?

00:05:54.370 --> 00:06:05.920
Suppose you have list A. How
would you add 3 to this list?

00:06:10.600 --> 00:06:12.472
AUDIENCE: [INAUDIBLE]

00:06:12.472 --> 00:06:12.950
PROFESSOR: OK.

00:06:12.950 --> 00:06:14.200
Let's start our print.

00:06:20.978 --> 00:06:22.120
OK.

00:06:22.120 --> 00:06:24.505
That's good.

00:06:24.505 --> 00:06:25.755
OK?

00:06:30.950 --> 00:06:33.810
How would you remove
the element from

00:06:33.810 --> 00:06:34.830
the top of the list?

00:06:34.830 --> 00:06:36.480
Or the last element, how
would you remove

00:06:36.480 --> 00:06:38.720
this 3 from the list?

00:06:42.129 --> 00:06:43.379
AUDIENCE: [INAUDIBLE]

00:06:50.900 --> 00:06:52.260
PROFESSOR: This one?

00:06:52.260 --> 00:06:53.510
Let's see.

00:07:00.598 --> 00:07:04.950
You know how to check
the specification

00:07:04.950 --> 00:07:07.270
of a function, right?

00:07:07.270 --> 00:07:08.520
Sorry.

00:07:15.620 --> 00:07:17.430
So it's not the right
function, right?

00:07:17.430 --> 00:07:19.930
Because it says it removes
the first occurrence of a

00:07:19.930 --> 00:07:23.380
particular value you are parsing
to that function.

00:07:23.380 --> 00:07:25.100
OK, there's another function.

00:07:25.100 --> 00:07:26.700
It's called list.pop.

00:07:30.860 --> 00:07:34.060
That removes the last inserted
value, so it

00:07:34.060 --> 00:07:37.300
pops from the top.

00:07:37.300 --> 00:07:40.430
So remove can be used to remove
a particular element.

00:07:40.430 --> 00:07:42.890
So here suppose we
want to remove 1.

00:07:42.890 --> 00:07:46.340
So we could say list
A, remove 1.

00:07:50.116 --> 00:07:51.060
OK.

00:07:51.060 --> 00:07:53.200
So in this example,
actually, I have

00:07:53.200 --> 00:07:56.150
commented out this line.

00:07:56.150 --> 00:07:58.260
This will be an error
if I execute.

00:07:58.260 --> 00:07:59.510
Why?

00:08:04.480 --> 00:08:06.280
Why will it give you an error?

00:08:09.105 --> 00:08:10.480
AUDIENCE: [INAUDIBLE]

00:08:10.480 --> 00:08:11.875
PROFESSOR: It doesn't exit.

00:08:11.875 --> 00:08:14.110
Great.

00:08:14.110 --> 00:08:17.520
So the problem here is we can't
access an element in the

00:08:17.520 --> 00:08:20.610
list unless we explicitly
assign

00:08:20.610 --> 00:08:23.450
something or create something.

00:08:23.450 --> 00:08:28.720
But suppose we want to pass
a list of 10 elements to a

00:08:28.720 --> 00:08:31.770
program so that it can assign
values on the fly.

00:08:31.770 --> 00:08:33.490
And it can modify.

00:08:33.490 --> 00:08:34.299
OK?

00:08:34.299 --> 00:08:38.133
So how would you pass an empty
list of 10 elements?

00:08:41.235 --> 00:08:42.179
OK.

00:08:42.179 --> 00:08:44.800
The problem is if you're passing
something like this,

00:08:44.800 --> 00:08:50.850
you need to know how this list
should be instantiated.

00:08:50.850 --> 00:08:54.080
So you should know what
are the initial

00:08:54.080 --> 00:08:57.090
values of these elements.

00:08:57.090 --> 00:09:01.610
Suppose you want to create
a list of ten 0's.

00:09:01.610 --> 00:09:03.670
Then the easiest way to
create the list is--

00:09:09.070 --> 00:09:12.220
So you would create a list
with ten elements.

00:09:12.220 --> 00:09:15.670
But If you don't want to waste
memory, or if you don't want

00:09:15.670 --> 00:09:18.790
to keep anything particular,
you could do

00:09:18.790 --> 00:09:20.040
something like this.

00:09:24.730 --> 00:09:29.210
Now this will create a
list of empty list.

00:09:29.210 --> 00:09:32.490
And there'll be ten
such empty lists.

00:09:32.490 --> 00:09:34.390
OK?

00:09:34.390 --> 00:09:37.090
And you could pass this list to
a program so that it will

00:09:37.090 --> 00:09:38.340
assign the elements.

00:09:40.930 --> 00:09:41.760
OK?

00:09:41.760 --> 00:09:45.900
You can iterate to the
list the same way.

00:09:45.900 --> 00:09:48.010
But lists are interesting.

00:09:48.010 --> 00:09:48.440
Why?

00:09:48.440 --> 00:09:49.870
They are mutable.

00:09:49.870 --> 00:09:53.370
So they can be actually used
to create interesting

00:09:53.370 --> 00:09:54.870
mathematical objects.

00:09:54.870 --> 00:09:58.070
For example, like matrix.

00:09:58.070 --> 00:10:00.330
So how would you create
a matrix using lists?

00:10:03.230 --> 00:10:04.390
Any ideas?

00:10:04.390 --> 00:10:06.610
How would you create,
say a 2 by 2 matrix?

00:10:11.280 --> 00:10:17.160
If you consider this example,
this creates a matrix 4 by 2.

00:10:20.370 --> 00:10:23.495
So that would be like 4
rows and 2 columns.

00:10:26.790 --> 00:10:31.310
But how can you go and
access the inner

00:10:31.310 --> 00:10:33.870
element or inner matrix?

00:10:33.870 --> 00:10:37.070
So if you suppose you want
access 2, 3, that is the third

00:10:37.070 --> 00:10:39.570
row, then how would
you access?

00:10:42.870 --> 00:10:45.220
How would you call M?

00:10:48.391 --> 00:10:48.850
AUDIENCE: M3?

00:10:48.850 --> 00:10:50.700
PROFESSOR: M3.

00:10:50.700 --> 00:10:53.200
M3 gives you 2, 3.

00:10:53.200 --> 00:10:58.190
Suppose you want to access
the 3 and the 2, 3.

00:10:58.190 --> 00:10:58.650
Then we--

00:10:58.650 --> 00:10:59.570
[INTERPOSING VOICES]

00:10:59.570 --> 00:11:01.508
PROFESSOR: Sorry.

00:11:01.508 --> 00:11:04.610
AUDIENCE: Why does a 3
give you [INAUDIBLE]?

00:11:04.610 --> 00:11:06.270
PROFESSOR: Oh, sorry.

00:11:06.270 --> 00:11:07.520
My bad.

00:11:11.440 --> 00:11:11.920
Yeah.

00:11:11.920 --> 00:11:12.400
OK.

00:11:12.400 --> 00:11:13.920
This is computer science,
not maths.

00:11:17.240 --> 00:11:19.040
You got it right, why
it's not 3, it's 2?

00:11:19.040 --> 00:11:19.496
AUDIENCE: Yeah.

00:11:19.496 --> 00:11:21.320
I thought you were talking
about 3 and 4.

00:11:21.320 --> 00:11:21.652
PROFESSOR: OK.

00:11:21.652 --> 00:11:22.430
That's fine.

00:11:22.430 --> 00:11:25.520
So I'm asking now how
would you access the

00:11:25.520 --> 00:11:29.482
3 in the 2, 3 box?

00:11:29.482 --> 00:11:33.258
AUDIENCE: So I need to do
another parentheses?

00:11:33.258 --> 00:11:33.730
PROFESSOR: Not a bracket.

00:11:33.730 --> 00:11:34.202
AUDIENCE: OK.

00:11:34.202 --> 00:11:35.620
PROFESSOR: OK.

00:11:35.620 --> 00:11:38.390
That is all.

00:11:38.390 --> 00:11:42.290
So you can access matrices
like this.

00:11:45.454 --> 00:11:45.910
OK.

00:11:45.910 --> 00:11:47.765
Great.

00:11:47.765 --> 00:11:49.015
We are on time.

00:11:59.870 --> 00:12:02.990
So this actually gives you
a summary of functions.

00:12:02.990 --> 00:12:05.170
Associated functions.

00:12:05.170 --> 00:12:07.930
For example the pop I
explained earlier.

00:12:07.930 --> 00:12:10.810
Remove removes a particular
element.

00:12:10.810 --> 00:12:14.080
Extent, that's interesting.

00:12:14.080 --> 00:12:17.640
Can you tell me what
it does here, the

00:12:17.640 --> 00:12:19.590
method extent on list?

00:12:36.880 --> 00:12:38.757
What does that method take?

00:12:42.030 --> 00:12:44.640
It takes another list.

00:12:44.640 --> 00:12:49.660
So which means it's going to
merge the list you are passing

00:12:49.660 --> 00:12:52.460
with the list you're calling
the method on, that is

00:12:52.460 --> 00:12:54.000
[UNINTELLIGIBLE].

00:12:54.000 --> 00:12:56.430
So it's going to combine
those lists.

00:12:56.430 --> 00:12:57.680
Let's see.

00:13:04.440 --> 00:13:06.705
So this corresponds to this.

00:13:09.590 --> 00:13:10.965
So two lists are combined.

00:13:13.720 --> 00:13:16.300
So this method is actually
useful, right, because you

00:13:16.300 --> 00:13:17.750
don't have to write yourself.

00:13:17.750 --> 00:13:19.580
Most of things you
can easily do.

00:13:19.580 --> 00:13:23.965
Now the question is, why tuple
didn't have these methods?

00:13:26.640 --> 00:13:27.890
Why?

00:13:30.040 --> 00:13:33.946
Why we didn't have these
methods for tuples?

00:13:33.946 --> 00:13:34.850
AUDIENCE: [INAUDIBLE]

00:13:34.850 --> 00:13:35.680
PROFESSOR: They're immutable.

00:13:35.680 --> 00:13:37.160
So you can't extent, you
can't [UNINTELLIGIBLE].

00:13:37.160 --> 00:13:39.360
So even if you extent,
what would happen?

00:13:39.360 --> 00:13:41.861
It's going to create
a new tuple.

00:13:41.861 --> 00:13:43.520
Actually, you can do that.

00:13:43.520 --> 00:13:44.420
But like this.

00:13:44.420 --> 00:13:50.860
For example, you have tuple
A which is 1, 2.

00:13:50.860 --> 00:13:54.470
And suppose you have
tuple B --

00:13:54.470 --> 00:13:55.960
3, 4.

00:13:55.960 --> 00:13:58.610
If you want to combine them,
how would you do it?

00:14:01.440 --> 00:14:07.500
Tuple A plus tuple B. OK?

00:14:07.500 --> 00:14:09.150
That concatenates.

00:14:09.150 --> 00:14:13.256
This operator is all
loaded for tuples.

00:14:13.256 --> 00:14:14.506
OK?

00:14:20.680 --> 00:14:24.810
So lists are mutable so you can
do all of these things.

00:14:24.810 --> 00:14:26.380
Let's look at a few other
examples, too.

00:14:51.590 --> 00:14:52.840
OK.

00:14:55.230 --> 00:14:58.100
There's an interesting
part here.

00:14:58.100 --> 00:14:59.310
Lists are mutable.

00:14:59.310 --> 00:15:00.950
That we understand.

00:15:00.950 --> 00:15:08.970
But how these lists are actually
stored in the memory,

00:15:08.970 --> 00:15:14.360
For example, suppose you
have a list lst,

00:15:14.360 --> 00:15:17.103
sorry, 0, 1, apple.

00:15:21.180 --> 00:15:22.920
How do you think it's stored
in the memory?

00:15:27.080 --> 00:15:28.965
So you have 3 elements.

00:15:28.965 --> 00:15:31.770
But these elements are actually
not stored in the

00:15:31.770 --> 00:15:34.570
list itself.

00:15:34.570 --> 00:15:36.560
They actually in the memory.

00:15:36.560 --> 00:15:37.810
0, 1, apple.

00:15:40.920 --> 00:15:44.260
But you have the pointers
to those lists.

00:15:44.260 --> 00:15:48.000
Sorry, to those elements.

00:15:48.000 --> 00:15:53.480
So actually you can modify these
values without changing

00:15:53.480 --> 00:15:57.625
the list itself, because the
list actually points to this

00:15:57.625 --> 00:16:00.970
part, the container.

00:16:00.970 --> 00:16:06.220
So in this example you have list
A and B. But the list B

00:16:06.220 --> 00:16:09.780
actually contains list A. OK?

00:16:09.780 --> 00:16:15.340
Since list A is mutable you
can go and change it.

00:16:15.340 --> 00:16:18.970
So here first you print list A
and B, but you're going to

00:16:18.970 --> 00:16:21.020
change list A's 0th element.

00:16:24.800 --> 00:16:30.290
After changing the element
the list A becomes first.

00:16:30.290 --> 00:16:34.730
Its first element
changed to 88.

00:16:34.730 --> 00:16:35.980
OK.

00:16:37.890 --> 00:16:40.480
Fine.

00:16:40.480 --> 00:16:42.420
What do you think the
list B would be?

00:16:48.252 --> 00:16:49.502
OK, let's print.

00:16:55.270 --> 00:16:58.900
It contains the 88, right,
the modified value.

00:16:58.900 --> 00:17:00.150
Why?

00:17:02.540 --> 00:17:12.280
Because list B actually had a
pointer to list A. Which again

00:17:12.280 --> 00:17:14.859
had pointers to other
elements.

00:17:14.859 --> 00:17:18.410
And we modified this
value to 88.

00:17:18.410 --> 00:17:22.339
So you're still accessing
list B. OK?

00:17:22.339 --> 00:17:26.170
The pointers are not changed.

00:17:26.170 --> 00:17:28.890
That we can see here, in
the second example,

00:17:28.890 --> 00:17:31.230
the problem of aliasing.

00:17:31.230 --> 00:17:37.270
So we have list X. And we call
it by list Y as well.

00:17:37.270 --> 00:17:42.110
And we are now changing
the list Y. Sorry.

00:17:42.110 --> 00:17:45.850
We are changing the list X. But
it's going to affect list

00:17:45.850 --> 00:17:51.740
X as well as list Y. See?

00:17:51.740 --> 00:17:54.360
Because it's just a reference.

00:17:54.360 --> 00:17:57.170
The actual object is this.

00:17:57.170 --> 00:17:59.000
You can call it by two
different names.

00:17:59.000 --> 00:17:59.570
It doesn't matter.

00:17:59.570 --> 00:18:00.820
But the actual object is here.

00:18:05.150 --> 00:18:07.315
That's where we need
this operator.

00:18:10.970 --> 00:18:15.640
So if you just point, OK, for
example we had list X, if you

00:18:15.640 --> 00:18:20.000
just assign list Y to list X,
it's not going to copy the

00:18:20.000 --> 00:18:23.170
elements, just going to
copy the reference.

00:18:23.170 --> 00:18:29.250
Which means list X and list Y,
both would be pointing to the

00:18:29.250 --> 00:18:32.420
same object.

00:18:32.420 --> 00:18:39.370
If you want to copy these
elements and put in a new one,

00:18:39.370 --> 00:18:45.300
say, list Z, then we need to
copy one-by-one every element.

00:18:45.300 --> 00:18:49.690
For that we can use
this operator.

00:18:49.690 --> 00:18:50.940
It's called full slicing.

00:18:53.700 --> 00:18:55.860
It's not going to
modify elements.

00:18:55.860 --> 00:18:58.955
It's going to copy the whole
list of elements.

00:19:15.360 --> 00:19:24.700
And in the same line, just
another small example that

00:19:24.700 --> 00:19:28.640
tells you how to cast a
list into tuple, and

00:19:28.640 --> 00:19:29.890
a tuple into list.

00:19:45.370 --> 00:19:49.120
So you had a tuple, one for
apple [UNINTELLIGIBLE]

00:19:49.120 --> 00:19:51.170
and you cast into list.

00:19:51.170 --> 00:19:52.515
Now the type is list.

00:19:55.330 --> 00:19:57.150
It's a very simple operation.

00:19:57.150 --> 00:20:00.250
Can you do that yourself?

00:20:00.250 --> 00:20:03.470
How would you do it if you want
to write a function to

00:20:03.470 --> 00:20:07.420
cast, how would you do that?

00:20:07.420 --> 00:20:11.810
You go through element by
element and add it to a tuple.

00:20:11.810 --> 00:20:14.790
And then concatentae
two tuples.

00:20:14.790 --> 00:20:17.350
Right?

00:20:17.350 --> 00:20:19.350
So I guess you can write
probably as a

00:20:19.350 --> 00:20:21.340
homework, try that.

00:20:21.340 --> 00:20:26.380
Try how to convert a list to
a tuple without explicitly

00:20:26.380 --> 00:20:29.385
calling the casting function.

00:20:29.385 --> 00:20:30.780
OK.

00:20:30.780 --> 00:20:33.540
Similarly you can convert
a tuple back into list.

00:20:36.640 --> 00:20:38.490
So it's pretty straightforward.

00:20:38.490 --> 00:20:40.530
And suppose you're getting
an input from

00:20:40.530 --> 00:20:42.020
the user as a tuple.

00:20:42.020 --> 00:20:43.970
then suppose you want
to make it a list.

00:20:43.970 --> 00:20:45.350
You don't have to write
your function.

00:20:45.350 --> 00:20:48.940
You can just call this
casting operator.

00:20:48.940 --> 00:20:51.130
So it'll be--

00:20:51.130 --> 00:20:53.690
it will save some time.

00:20:53.690 --> 00:20:53.980
OK.

00:20:53.980 --> 00:20:56.470
Great.

00:20:56.470 --> 00:20:57.960
Let's go to our dictionaries
now.

00:21:05.930 --> 00:21:10.030
So we have a third data
type, dictionaries.

00:21:10.030 --> 00:21:11.280
Oh, you didn't get
the second one?

00:21:18.490 --> 00:21:21.740
So we have another data
type, dictionaries.

00:21:21.740 --> 00:21:24.210
And why do we need dictionaries

00:21:24.210 --> 00:21:26.050
in the first place?

00:21:26.050 --> 00:21:28.010
Do we need another data type?

00:21:28.010 --> 00:21:32.320
Can we just get away with
tuple and list?

00:21:32.320 --> 00:21:33.120
Yes.

00:21:33.120 --> 00:21:38.520
Because you can actually make
a dictionary out of lists.

00:21:38.520 --> 00:21:43.400
And Professor Grimson went
through that in the lecture.

00:21:43.400 --> 00:21:45.960
If you want, you can come and
ask in the office hours.

00:21:45.960 --> 00:21:49.440
But first try whether you
can do it yourself.

00:21:49.440 --> 00:21:55.520
But the problem is, actually not
just the dictionaries, but

00:21:55.520 --> 00:21:58.370
the high-level data structures
are actually available in

00:21:58.370 --> 00:22:03.420
Python as building data
structures or as classes.

00:22:03.420 --> 00:22:07.310
Just because they will have
these methods on these data

00:22:07.310 --> 00:22:08.980
structures implemented.

00:22:08.980 --> 00:22:11.180
So it would say some
time for us.

00:22:11.180 --> 00:22:15.720
Plus those methods are
guaranteed to be state of art.

00:22:15.720 --> 00:22:18.747
For example, if you want to go
through all the lists, then

00:22:18.747 --> 00:22:23.200
the search function or the
lookup function that you write

00:22:23.200 --> 00:22:25.760
may not be that efficient,
right?

00:22:25.760 --> 00:22:28.040
But they might use those
efficient algorithms in the

00:22:28.040 --> 00:22:29.290
standard implementation.

00:22:29.290 --> 00:22:32.660
So it's why you should
always look for the

00:22:32.660 --> 00:22:34.420
standard data types.

00:22:34.420 --> 00:22:36.880
If you can't you can
write yourself one.

00:22:36.880 --> 00:22:40.510
But it's good to use the
available data types so that

00:22:40.510 --> 00:22:44.270
they would have this efficient
method implemented.

00:22:44.270 --> 00:22:45.910
OK.

00:22:45.910 --> 00:22:54.310
So in this dictionary,
we have two elements.

00:22:54.310 --> 00:22:57.520
One is key, one is value.

00:22:57.520 --> 00:22:58.980
OK?

00:22:58.980 --> 00:23:02.130
So these keys actually have
a special property.

00:23:02.130 --> 00:23:04.650
What is that?

00:23:04.650 --> 00:23:12.360
The keys should be an
immutable object.

00:23:12.360 --> 00:23:15.930
So you can actually have
a tuple as a key.

00:23:15.930 --> 00:23:20.310
You can have a string as a key,
but not a list as a key.

00:23:20.310 --> 00:23:25.270
So you need an immutable
object for the keys.

00:23:25.270 --> 00:23:27.685
What about the values?

00:23:27.685 --> 00:23:30.040
They can be anything.

00:23:30.040 --> 00:23:33.230
Values can be even
a dictionary.

00:23:33.230 --> 00:23:34.935
It can be a list.

00:23:34.935 --> 00:23:36.950
But the keys must be mutable.

00:23:40.160 --> 00:23:42.110
Do these keys need
to be unique?

00:23:47.400 --> 00:23:49.370
Yes.

00:23:49.370 --> 00:23:51.264
No?

00:23:51.264 --> 00:23:52.760
OK.

00:23:52.760 --> 00:23:54.010
The problem is this.

00:23:56.610 --> 00:24:00.430
Dictionaries have the same
type, I mean structure.

00:24:05.340 --> 00:24:08.320
This is a key.

00:24:08.320 --> 00:24:11.690
And this key points to a
place in the memory.

00:24:11.690 --> 00:24:16.060
Suppose you call it key A. OK?

00:24:16.060 --> 00:24:20.770
If you assign another value to
key A, that will actually

00:24:20.770 --> 00:24:23.890
replace the content in
the memory, right?

00:24:23.890 --> 00:24:27.560
So that's why keys are going
to be unique, It's by

00:24:27.560 --> 00:24:31.850
construction, by the
construction of the dictionary

00:24:31.850 --> 00:24:34.540
the keys are going
to be unique.

00:24:34.540 --> 00:24:37.370
Because if you want to assign
something different, you have

00:24:37.370 --> 00:24:41.040
to call it by a different key,
call it by a different name.

00:24:41.040 --> 00:24:47.240
Say key B.

00:24:47.240 --> 00:24:48.490
What about the values.

00:24:50.600 --> 00:24:52.037
Do they need to be unique?

00:24:52.037 --> 00:24:54.030
No, of course.

00:24:54.030 --> 00:24:57.450
Otherwise no use of key, and no
use of dictionaries, right?

00:24:57.450 --> 00:25:02.010
What is the order of the items
stored in the dictionary?

00:25:02.010 --> 00:25:05.460
Can you give a guarantee
like in lists?

00:25:05.460 --> 00:25:09.490
In lists items are stored from
zero to the left, right?

00:25:09.490 --> 00:25:11.670
Length minus 1, actually.

00:25:11.670 --> 00:25:13.410
What about dictionaries?

00:25:13.410 --> 00:25:16.280
Surely can't guarantee
the order, but you

00:25:16.280 --> 00:25:18.192
can modify the order.

00:25:18.192 --> 00:25:19.330
OK.

00:25:19.330 --> 00:25:23.800
So the thing is first, if you
look at this example, first we

00:25:23.800 --> 00:25:27.990
have the staff dictionary.

00:25:27.990 --> 00:25:33.040
And when I pin the length
it gives me 3, fine.

00:25:33.040 --> 00:25:34.820
Then I'm doing three things.

00:25:34.820 --> 00:25:42.540
First I change the address
by calling its key.

00:25:42.540 --> 00:25:44.590
And dictionaries are
mutable so you can

00:25:44.590 --> 00:25:45.840
change their values.

00:25:48.220 --> 00:25:50.950
Then also we are adding
a new element.

00:25:50.950 --> 00:25:52.190
Fine.

00:25:52.190 --> 00:25:54.840
If you wanted a new element you
call it by the key that

00:25:54.840 --> 00:25:56.130
you already assigned.

00:25:56.130 --> 00:26:00.000
If the key already exists you
will just modify the value.

00:26:00.000 --> 00:26:04.160
Otherwise it will create a new
key and add that value.

00:26:04.160 --> 00:26:07.080
You can also check whether this
particular element is in

00:26:07.080 --> 00:26:09.120
the dictionary.

00:26:09.120 --> 00:26:11.320
But this must be the key.

00:26:11.320 --> 00:26:12.660
Whatever you are calling
here should be the

00:26:12.660 --> 00:26:13.820
key, not the value.

00:26:13.820 --> 00:26:15.550
It won't search for the value.

00:26:15.550 --> 00:26:17.070
It will search only for the
key, [UNINTELLIGIBLE]

00:26:17.070 --> 00:26:19.705
for that particular key because
you access the values

00:26:19.705 --> 00:26:20.955
through keys.

00:26:23.080 --> 00:26:25.920
Again here if it is not
in the list, actually

00:26:25.920 --> 00:26:29.410
I'm adding an element--

00:26:29.410 --> 00:26:30.660
OK.

00:26:35.680 --> 00:26:36.020
OK.

00:26:36.020 --> 00:26:42.660
To compare in the list, suppose
I have a list 0, 1, 2.

00:26:45.460 --> 00:26:48.750
If I want to check whether
1 is in the

00:26:48.750 --> 00:26:50.310
list, how would I check?

00:26:53.050 --> 00:26:55.370
Do you have to go through
element by element?

00:26:55.370 --> 00:26:57.850
No, there's a shortcut.

00:26:57.850 --> 00:27:05.340
If 1 in list, right?

00:27:05.340 --> 00:27:08.530
If I want to check whether 1 is
not in the list, if I want

00:27:08.530 --> 00:27:16.240
to negate this, I would write
it 1 not in list.

00:27:16.240 --> 00:27:17.380
We just ignore the words.

00:27:17.380 --> 00:27:19.898
It's pretty much like English.

00:27:19.898 --> 00:27:20.730
OK?

00:27:20.730 --> 00:27:22.660
We just remove the words.

00:27:22.660 --> 00:27:24.360
OK.

00:27:24.360 --> 00:27:29.360
In the dictionary we do the
same thing through keys.

00:27:29.360 --> 00:27:35.530
If key A and, OK I'll
call it, say, D1.

00:27:41.402 --> 00:27:42.340
OK?

00:27:42.340 --> 00:27:46.260
And you actually call or you'd
search for the key,

00:27:46.260 --> 00:27:47.510
not the other way.

00:27:58.550 --> 00:27:59.560
OK.

00:27:59.560 --> 00:28:03.140
There is an interesting
part here.

00:28:03.140 --> 00:28:04.890
If you want to modify
the order--

00:28:04.890 --> 00:28:08.420
actually I tell you that the
order C earlier, we couldn't

00:28:08.420 --> 00:28:11.950
guarantee the order, right?

00:28:11.950 --> 00:28:15.860
It was not the order we typed
because it starts at

00:28:15.860 --> 00:28:17.800
[UNINTELLIGIBLE]

00:28:17.800 --> 00:28:20.530
because we added at the
end actually, right?

00:28:20.530 --> 00:28:22.640
So actually you can't
guarantee the order.

00:28:22.640 --> 00:28:25.370
But we can sort it.

00:28:25.370 --> 00:28:27.420
But how do you sort it?

00:28:27.420 --> 00:28:32.280
We call the keys and
we sort the keys.

00:28:32.280 --> 00:28:36.020
Because remember,
every values--

00:28:36.020 --> 00:28:38.180
if you want to access a
particular value, you access

00:28:38.180 --> 00:28:39.750
it through key.

00:28:39.750 --> 00:28:42.730
Actually, if you call the
dictionary, it doesn't know

00:28:42.730 --> 00:28:44.280
where these values are.

00:28:44.280 --> 00:28:47.460
Just you have to go to the
key to access the value.

00:28:47.460 --> 00:28:50.910
So if you want to do something
in the dictionary itself, you

00:28:50.910 --> 00:28:53.340
can do that only on keys.

00:28:53.340 --> 00:28:54.670
So if you want to sort
the dictionary,

00:28:54.670 --> 00:28:56.520
you sort it by keys.

00:28:56.520 --> 00:29:01.400
So you call the keys method
for the dictionary--

00:29:01.400 --> 00:29:06.450
so it returns the list of
keys and you sort them.

00:29:09.070 --> 00:29:10.690
This is called chaining
methods.

00:29:10.690 --> 00:29:13.160
So I have chained the methods.

00:29:13.160 --> 00:29:15.350
I would have like two
methods, right?

00:29:15.350 --> 00:29:17.100
I call the keys.

00:29:17.100 --> 00:29:20.900
This first part actually returns
to this top key.

00:29:20.900 --> 00:29:22.830
Then you sort them.

00:29:22.830 --> 00:29:23.851
Yes?

00:29:23.851 --> 00:29:27.080
AUDIENCE: It doesn't look like
they're in alphabetical order?

00:29:27.080 --> 00:29:27.705
PROFESSOR: Oh, on this?

00:29:27.705 --> 00:29:28.955
Sorry.

00:29:32.600 --> 00:29:33.850
Let's see.

00:29:40.670 --> 00:29:41.150
OK.

00:29:41.150 --> 00:29:42.400
Let's see.

00:29:55.550 --> 00:29:56.800
Ooops.

00:30:03.370 --> 00:30:03.950
OK.

00:30:03.950 --> 00:30:05.200
Now they're sorted.

00:30:07.730 --> 00:30:09.190
OK.

00:30:09.190 --> 00:30:12.160
What was the problem?

00:30:12.160 --> 00:30:14.160
What was the problem there?

00:30:14.160 --> 00:30:16.030
Why it wasn't sorted?

00:30:16.030 --> 00:30:17.790
AUDIENCE: You have to
do it in two lines.

00:30:17.790 --> 00:30:18.240
PROFESSOR: Sorry?

00:30:18.240 --> 00:30:21.802
AUDIENCE: You have to call up
the keys and then sort it in a

00:30:21.802 --> 00:30:24.300
separate line?

00:30:24.300 --> 00:30:25.810
PROFESSOR: OK.

00:30:25.810 --> 00:30:29.830
The problem is in the logic.

00:30:29.830 --> 00:30:32.560
Actually, when you call this
function, method, you're

00:30:32.560 --> 00:30:35.650
actually sorting the keys
returned by this method.

00:30:35.650 --> 00:30:40.290
You're not actually going to
sort of the dictionary itself.

00:30:40.290 --> 00:30:44.820
You're sorting only the list
that was returned, right?

00:30:44.820 --> 00:30:47.230
The list of keys.

00:30:47.230 --> 00:30:53.200
Although the dictionary is
mutable, it wasn't sorted.

00:30:53.200 --> 00:30:54.720
Do you see the problem?

00:30:54.720 --> 00:30:59.230
So that's why when they called
keys equal to staff.keys I'm

00:30:59.230 --> 00:31:02.190
getting a list of keys.

00:31:02.190 --> 00:31:05.000
Then I'm sorting that list.

00:31:05.000 --> 00:31:08.180
And I'm printing that list.

00:31:08.180 --> 00:31:12.820
But if you want to go in a
particular order, if you want

00:31:12.820 --> 00:31:15.230
to access the dictionary in a
particular order, what could

00:31:15.230 --> 00:31:24.380
you do is you could do something
like keys is equal

00:31:24.380 --> 00:31:25.630
to staff.keys.

00:31:28.280 --> 00:31:29.530
Then you can store keys.

00:31:34.430 --> 00:31:40.880
Then for k in keys you can go
and iterate now, right?

00:31:40.880 --> 00:31:47.560
So you can say print
k and staff k.

00:31:47.560 --> 00:31:49.500
OK?

00:31:49.500 --> 00:31:51.770
So you can do this.

00:31:51.770 --> 00:31:56.770
But actually, Python provides a
way to iterate what keys and

00:31:56.770 --> 00:31:58.020
value pairs.

00:32:00.540 --> 00:32:07.660
That you do by calling
both elements?

00:32:07.660 --> 00:32:09.730
All the method items.

00:32:09.730 --> 00:32:16.040
The items return a list
of key-value pairs.

00:32:19.650 --> 00:32:27.530
If you call D1.items you get
a list of key-value pairs.

00:32:35.250 --> 00:32:38.210
You see that?

00:32:38.210 --> 00:32:42.740
And we are going to iterate
through individual elements.

00:32:42.740 --> 00:32:46.190
So first we start with this
and then second this.

00:32:46.190 --> 00:32:49.560
So that's a simpler way to
access every elements in the

00:32:49.560 --> 00:32:51.448
dictionary.

00:32:51.448 --> 00:32:52.698
Great.

00:32:59.384 --> 00:33:02.360
OK.

00:33:02.360 --> 00:33:04.680
Now we have an interesting
part, recursion.

00:33:13.780 --> 00:33:17.040
What's the principle
behind recursion?

00:33:17.040 --> 00:33:18.290
Anyone?

00:33:21.140 --> 00:33:22.390
What's the idea of recursion?

00:33:25.320 --> 00:33:25.720
Yes?

00:33:25.720 --> 00:33:28.929
AUDIENCE: The cause itself
is [INAUDIBLE]

00:33:28.929 --> 00:33:29.875
base case.

00:33:29.875 --> 00:33:32.240
And it saves a lot of money.

00:33:32.240 --> 00:33:35.160
PROFESSOR: Yes.

00:33:35.160 --> 00:33:38.890
The idea of recursion is, if
you have a problem, try to

00:33:38.890 --> 00:33:41.170
express the problem
in a simpler

00:33:41.170 --> 00:33:43.090
version of the same problem.

00:33:43.090 --> 00:33:47.260
So if you want to find factorial
n, try to express it

00:33:47.260 --> 00:33:49.530
in terms of factorial
n minus 1.

00:33:49.530 --> 00:33:52.940
So you could keep on doing
this till you come to

00:33:52.940 --> 00:33:56.828
factorial 1 for which you know
the explicit answer.

00:33:56.828 --> 00:33:57.700
Right?

00:33:57.700 --> 00:34:02.000
So you try to express the
problem in its simpler form.

00:34:02.000 --> 00:34:05.340
It would be useful
in many cases.

00:34:05.340 --> 00:34:09.060
Actually, in your next piece
you do have the problem.

00:34:09.060 --> 00:34:12.540
But be mindful.

00:34:12.540 --> 00:34:14.000
What's --

00:34:14.000 --> 00:34:19.000
what makes it possible for
you to use the recursion?

00:34:19.000 --> 00:34:21.840
Only if you can express in terms
of the simpler version.

00:34:21.840 --> 00:34:23.860
Otherwise you can't.

00:34:23.860 --> 00:34:26.600
This is probably quite like the
induction you might have

00:34:26.600 --> 00:34:28.010
studied, mathematical
induction.

00:34:28.010 --> 00:34:29.870
I don't know whether you studied
it in high school, but

00:34:29.870 --> 00:34:32.170
it's quite like that.

00:34:32.170 --> 00:34:34.889
OK.

00:34:34.889 --> 00:34:38.389
So there are two parts
in recursion.

00:34:38.389 --> 00:34:39.925
The first one is
the base case.

00:34:43.340 --> 00:34:53.310
So for a factorial problem we
can express the factorial, say

00:34:53.310 --> 00:35:01.530
nth factorial, as any n in
to n minus 1 factorial.

00:35:01.530 --> 00:35:03.660
OK?

00:35:03.660 --> 00:35:07.050
So this would be our
recursive case.

00:35:07.050 --> 00:35:08.740
So what is a recursive case?

00:35:14.880 --> 00:35:23.330
Suppose we want to define a
function factorial A. OK?

00:35:23.330 --> 00:35:26.042
So what will be our
recursive case?

00:35:26.042 --> 00:35:27.292
AUDIENCE: A is greater than 0?

00:35:29.270 --> 00:35:30.750
PROFESSOR: I'm asking the
recursive function.

00:35:30.750 --> 00:35:32.682
What would be that?

00:35:32.682 --> 00:35:33.932
AUDIENCE: [INAUDIBLE]

00:35:37.300 --> 00:35:38.550
PROFESSOR: n into 2.

00:35:42.350 --> 00:35:45.690
Factorial n minus 1 right?

00:35:45.690 --> 00:35:46.950
And you just return this.

00:35:50.120 --> 00:35:51.370
What would be your base case?

00:35:56.460 --> 00:36:01.070
If n is equal to 0, we know
factorial 0 is 1, right?

00:36:06.260 --> 00:36:12.090
What is factorial of 1?

00:36:15.750 --> 00:36:17.000
1.

00:36:25.420 --> 00:36:27.910
OK?

00:36:27.910 --> 00:36:30.020
But why in this program
we didn't have

00:36:30.020 --> 00:36:31.270
that particular line.

00:36:34.010 --> 00:36:37.340
Why we didn't have n equals 1?

00:36:37.340 --> 00:36:38.595
Why we didn't have that?

00:36:42.960 --> 00:36:45.385
AUDIENCE: Because it
always goes to 0?

00:36:45.385 --> 00:36:47.100
PROFESSOR: It always
goes 0, right?

00:36:47.100 --> 00:36:51.000
Because you can express 1 in
terms of 0 as well, right?

00:36:51.000 --> 00:36:53.320
So you don't need to actually
write this explicitly.

00:36:53.320 --> 00:36:54.840
Why?

00:36:54.840 --> 00:36:57.780
Because your recursive function
only depends on its

00:36:57.780 --> 00:36:59.360
previous value.

00:36:59.360 --> 00:37:03.760
So you need only one value in
advance Which means you need

00:37:03.760 --> 00:37:05.200
only one value for
your base case.

00:37:08.830 --> 00:37:12.140
So you can understand
this program, right?

00:37:12.140 --> 00:37:13.550
I'm not going to go
through that.

00:37:13.550 --> 00:37:16.040
But anyway when you write
a program always

00:37:16.040 --> 00:37:17.760
check its base case.

00:37:17.760 --> 00:37:21.470
So you have to start with
factorial 0 for this case.

00:37:21.470 --> 00:37:21.920
OK?

00:37:21.920 --> 00:37:23.140
And check one by one.

00:37:23.140 --> 00:37:24.790
Then you would know whether
the program is running

00:37:24.790 --> 00:37:26.100
correctly or not.

00:37:26.100 --> 00:37:27.985
So always start with
a simpler case.

00:37:31.130 --> 00:37:32.910
But remember in Fibonacci
series.

00:37:36.531 --> 00:37:40.220
OK. for Fibonacci series
can you give me

00:37:40.220 --> 00:37:41.470
the recursive function.?

00:37:44.270 --> 00:37:44.540
Yes.

00:37:44.540 --> 00:37:46.650
What is Fibonacci series?

00:37:46.650 --> 00:37:47.900
AUDIENCE: [INAUDIBLE]

00:37:50.150 --> 00:37:50.650
PROFESSOR: OK.

00:37:50.650 --> 00:37:51.150
Yeah.

00:37:51.150 --> 00:37:52.650
That's great.

00:37:52.650 --> 00:38:00.020
So return say F of n minus
1 plus F of n minus 2.

00:38:00.020 --> 00:38:01.610
What is the Fibonacci series?

00:38:01.610 --> 00:38:03.920
You start from 0, you
add these elements.

00:38:03.920 --> 00:38:04.740
So 1.

00:38:04.740 --> 00:38:06.710
You add last two elements, 2.

00:38:06.710 --> 00:38:08.200
You add last two elements, 3.

00:38:08.200 --> 00:38:09.450
You add last two elements, 5.

00:38:13.030 --> 00:38:14.600
So you add last two elements.

00:38:14.600 --> 00:38:19.080
So if you want to find F of n,
you return F of n minus 1 and

00:38:19.080 --> 00:38:21.410
plus F of n minus 2.

00:38:21.410 --> 00:38:26.880
But here since you have two
elements, or you need to

00:38:26.880 --> 00:38:30.450
access two previous elements,
you need to define you base

00:38:30.450 --> 00:38:31.700
case accordingly.

00:38:33.640 --> 00:38:40.820
So for your base case,
F of 0, is what?

00:38:43.526 --> 00:38:45.800
Actually, that depends
on whether you

00:38:45.800 --> 00:38:48.135
start here or here.

00:38:48.135 --> 00:38:49.385
OK?

00:38:51.860 --> 00:38:53.110
You could do this.

00:38:59.970 --> 00:39:03.940
I'll go through an interesting
recursive example.

00:39:29.350 --> 00:39:30.040
OK.

00:39:30.040 --> 00:39:32.810
It's called a recursive
exponentiation.

00:39:32.810 --> 00:39:37.720
So I actually you can do an
exponentiation through

00:39:37.720 --> 00:39:39.940
recursive multiplication.

00:39:39.940 --> 00:39:43.800
Suppose you want to find 3
to the power, say, of 10.

00:39:49.546 --> 00:39:50.880
Then how would you do that?

00:39:53.970 --> 00:39:58.300
You start by expressing
it in terms of its

00:39:58.300 --> 00:39:59.800
simpler version, right?

00:39:59.800 --> 00:40:02.630
So it will be 3 into
3 to the power 9.

00:40:02.630 --> 00:40:05.280
Sorry, 3 to the power 9.

00:40:05.280 --> 00:40:06.530
OK?

00:40:11.230 --> 00:40:17.240
So if you want to find that
nth power of number M, you

00:40:17.240 --> 00:40:24.490
would say M into M to
the power n minus 1.

00:40:24.490 --> 00:40:26.460
So now you have your
recursive case.

00:40:29.160 --> 00:40:30.410
What is the base case?

00:40:34.060 --> 00:40:36.890
AUDIENCE: [INAUDIBLE]

00:40:36.890 --> 00:40:38.775
PROFESSOR: Yes, if
n is equal to 0.

00:40:41.720 --> 00:40:48.260
In Python you would test this
by two equal signs.

00:40:48.260 --> 00:40:51.694
If n is equal to 0, then what?

00:40:51.694 --> 00:40:52.560
AUDIENCE: Return 1.

00:40:52.560 --> 00:40:53.810
PROFESSOR: Return 1.

00:40:57.574 --> 00:40:59.480
OK?

00:40:59.480 --> 00:41:03.492
Why we have only one
base case here?

00:41:03.492 --> 00:41:05.250
AUDIENCE: [INAUDIBLE]

00:41:05.250 --> 00:41:05.596
PROFESSOR: Sorry?

00:41:05.596 --> 00:41:07.340
AUDIENCE: [INAUDIBLE]

00:41:07.340 --> 00:41:07.810
PROFESSOR: Yes.

00:41:07.810 --> 00:41:09.660
And because you're accessing
only one

00:41:09.660 --> 00:41:11.350
previous series, right?

00:41:11.350 --> 00:41:12.600
Fibonacci series.

00:41:14.880 --> 00:41:18.180
Similarly, if you want to
multiply something--

00:41:18.180 --> 00:41:22.670
OK, here what we did is we
replaced this operator by

00:41:22.670 --> 00:41:26.280
recursively using
this operator.

00:41:26.280 --> 00:41:28.700
OK?

00:41:28.700 --> 00:41:33.120
Can you do the multiplication
by recursive addition?

00:41:33.120 --> 00:41:38.360
So can you replace this operator
by this operator?

00:41:38.360 --> 00:41:39.360
Yes.

00:41:39.360 --> 00:41:45.020
So how would you do this, for
example say 3 into 5?

00:41:45.020 --> 00:41:46.270
So how would you do it here?

00:41:49.470 --> 00:41:49.970
Tell me.

00:41:49.970 --> 00:41:51.220
What would this?

00:41:55.960 --> 00:41:58.790
AUDIENCE: 3 plus 3 times 4.

00:41:58.790 --> 00:41:59.220
PROFESSOR: 3 plus?

00:41:59.220 --> 00:42:00.510
AUDIENCE: 3 times 4.

00:42:00.510 --> 00:42:02.230
PROFESSOR: 3 times 4.

00:42:02.230 --> 00:42:03.480
Here?

00:42:11.630 --> 00:42:13.549
Come on, it's simple, right?

00:42:13.549 --> 00:42:14.910
AUDIENCE: [INAUDIBLE]

00:42:14.910 --> 00:42:17.154
PROFESSOR: I'm insulting you.

00:42:17.154 --> 00:42:18.630
OK.

00:42:18.630 --> 00:42:20.230
What's the base case?

00:42:20.230 --> 00:42:22.090
That is interesting.

00:42:22.090 --> 00:42:25.550
What is the base case
if n is equal to 0?

00:42:32.438 --> 00:42:35.882
AUDIENCE: [INAUDIBLE]

00:42:35.882 --> 00:42:37.850
PROFESSOR: OK.

00:42:37.850 --> 00:42:40.210
If n is equal to 0, that is 0.

00:42:40.210 --> 00:42:41.250
But that's fine.

00:42:41.250 --> 00:42:42.500
But there's another problem.

00:42:49.010 --> 00:42:52.930
The problem is you don't know
whether these values are

00:42:52.930 --> 00:42:54.620
positive or negative.

00:42:54.620 --> 00:42:57.600
So you can't just keep
on adding like this.

00:42:57.600 --> 00:42:58.850
This will work if
it's positive.

00:43:01.350 --> 00:43:03.860
But if it's negative, actually
you have to check.

00:43:03.860 --> 00:43:07.390
Which is sort of tricky
if you want to use the

00:43:07.390 --> 00:43:08.770
same recursive function.

00:43:08.770 --> 00:43:14.030
Otherwise you could have
an if condition here.

00:43:14.030 --> 00:43:17.120
If say n is greater
than 0, do this.

00:43:19.690 --> 00:43:25.010
Else-if you multiply n by minus
1 you negate that so it

00:43:25.010 --> 00:43:26.080
becomes positive.

00:43:26.080 --> 00:43:30.910
And do it the same way and
then that's the answer.

00:43:30.910 --> 00:43:32.370
So you could do that.

00:43:32.370 --> 00:43:36.780
But if you want to do it in the
same recursive case, then

00:43:36.780 --> 00:43:37.940
you had to follow this.

00:43:37.940 --> 00:43:39.420
If you have any questions,
come to the

00:43:39.420 --> 00:43:42.730
office hours on that.

00:43:42.730 --> 00:43:46.175
The final question is, final
example is, the Hanoi example.

00:43:49.640 --> 00:43:50.490
OK.

00:43:50.490 --> 00:43:51.740
This is very interesting.

00:43:57.890 --> 00:44:04.520
So here we have three towers;
source, target, and buffer.

00:44:07.580 --> 00:44:10.350
Suppose you have three disks.

00:44:10.350 --> 00:44:13.420
You want to move them from
source to target.

00:44:13.420 --> 00:44:16.200
And you can always have a
smaller disk on top of a

00:44:16.200 --> 00:44:18.250
bigger disk.

00:44:18.250 --> 00:44:19.670
Then how would you move?

00:44:19.670 --> 00:44:20.470
OK?

00:44:20.470 --> 00:44:25.010
So can you express this problem
in a simpler version?

00:44:25.010 --> 00:44:26.880
So now we have three disks.

00:44:26.880 --> 00:44:29.110
You want to move
them to target.

00:44:29.110 --> 00:44:31.710
So can you express it in
a simpler version?

00:44:34.320 --> 00:44:37.090
Come on.

00:44:37.090 --> 00:44:40.380
Just in plain English,
how would you do it?

00:44:40.380 --> 00:44:42.550
Without looking at
the program.

00:44:42.550 --> 00:44:43.950
Because Python is very robust.

00:44:43.950 --> 00:44:47.010
So if you read the program
you get it in English.

00:44:49.776 --> 00:44:53.890
So any ideas?

00:44:53.890 --> 00:44:55.210
OK.

00:44:55.210 --> 00:44:57.860
We have to here move the last
disk to target, right?

00:44:57.860 --> 00:44:59.750
But that's the hardest part.

00:44:59.750 --> 00:45:02.720
So before doing that you have
to move this somewhere else.

00:45:02.720 --> 00:45:04.120
So let's move it to buffer.

00:45:07.960 --> 00:45:10.360
Done.

00:45:10.360 --> 00:45:13.600
How would you move this?

00:45:13.600 --> 00:45:16.496
Now you can move it to target.

00:45:16.496 --> 00:45:18.230
OK.

00:45:18.230 --> 00:45:20.634
Now what would you do?

00:45:20.634 --> 00:45:21.884
AUDIENCE: [INAUDIBLE]

00:45:25.394 --> 00:45:25.880
PROFESSOR: OK.

00:45:25.880 --> 00:45:26.460
Sorry.

00:45:26.460 --> 00:45:27.870
Yeah, OK?

00:45:27.870 --> 00:45:28.250
No.

00:45:28.250 --> 00:45:29.317
What would you do?

00:45:29.317 --> 00:45:30.780
AUDIENCE: [INAUDIBLE]

00:45:30.780 --> 00:45:35.270
PROFESSOR: You can only move
this to the buffer, right?

00:45:35.270 --> 00:45:36.330
AUDIENCE: [INAUDIBLE]

00:45:36.330 --> 00:45:36.360
[?

00:45:36.360 --> 00:45:37.610
PROFESSOR: Not the target.

00:45:39.820 --> 00:45:40.920
OK.

00:45:40.920 --> 00:45:42.170
So we made some mistake
earlier.

00:45:44.888 --> 00:45:46.250
Remember?

00:45:46.250 --> 00:45:49.300
The problem is because we didn't
think recursively.

00:45:53.720 --> 00:45:55.080
OK.

00:45:55.080 --> 00:45:56.330
Let's think recursively.

00:46:01.350 --> 00:46:03.751
Source, target, buffer.

00:46:03.751 --> 00:46:05.540
Sorry.

00:46:05.540 --> 00:46:07.200
Suppose we have only one disk.

00:46:10.360 --> 00:46:13.630
Then you can simply
move to target.

00:46:13.630 --> 00:46:14.570
OK?

00:46:14.570 --> 00:46:17.450
So a condition is if there's
only one disk, just move it to

00:46:17.450 --> 00:46:18.700
the target.

00:46:21.350 --> 00:46:27.960
So if n is equal to 1
we always move from

00:46:27.960 --> 00:46:30.745
move source to target.

00:46:33.350 --> 00:46:34.760
OK?

00:46:34.760 --> 00:46:36.010
Suppose you have two.

00:46:41.330 --> 00:46:44.410
Then what would you do?

00:46:44.410 --> 00:46:45.870
You move the top
one to buffer.

00:46:50.970 --> 00:46:52.610
OK?

00:46:52.610 --> 00:46:56.870
So move source to buffer.

00:47:02.560 --> 00:47:05.135
Then you move the next disk
from source to target.

00:47:07.990 --> 00:47:11.720
So now it's source to target.

00:47:15.660 --> 00:47:19.480
And finally you move
it from the buffer.

00:47:19.480 --> 00:47:20.730
All right?

00:47:24.130 --> 00:47:28.590
Now we have a very nice
recursive case.

00:47:28.590 --> 00:47:34.400
If you have two, we move from
source to buffer, then source

00:47:34.400 --> 00:47:36.660
to target, then from
buffer to target.

00:47:39.360 --> 00:47:45.600
So if you look at this example
I'm checking if

00:47:45.600 --> 00:47:48.060
n is equal to 1.

00:47:48.060 --> 00:47:53.180
If it is 1, just I'm moving
from source to target.

00:47:53.180 --> 00:47:55.920
If it is greater than
n, what would I do?

00:47:55.920 --> 00:47:58.150
And that first assert statement
is just there to

00:47:58.150 --> 00:47:59.460
make sure that n is
greater than 0.

00:47:59.460 --> 00:48:01.690
Otherwise it's meaningless,
right?

00:48:01.690 --> 00:48:02.830
You need to have this.

00:48:02.830 --> 00:48:05.660
You can't have negative this.

00:48:05.660 --> 00:48:12.630
So what would be the next
step if you have

00:48:12.630 --> 00:48:13.760
more than one disk?

00:48:13.760 --> 00:48:14.980
Suppose you have two disks.

00:48:14.980 --> 00:48:16.810
Then what would you do?

00:48:16.810 --> 00:48:19.590
You move the top disk
or whatever on

00:48:19.590 --> 00:48:22.320
the top to the buffer.

00:48:22.320 --> 00:48:26.270
For this simple example
it was just one disk.

00:48:26.270 --> 00:48:30.120
But suppose you had more disks
on top of the last disk?

00:48:30.120 --> 00:48:32.280
So you would have moved
all of them to buffer.

00:48:32.280 --> 00:48:33.760
You don't have to worry
how you move it.

00:48:33.760 --> 00:48:36.050
But you have to move
it anyway.

00:48:36.050 --> 00:48:39.830
After moving that, you can
leisurely move this big disk

00:48:39.830 --> 00:48:42.420
to the top, to the target.

00:48:42.420 --> 00:48:43.420
OK?

00:48:43.420 --> 00:48:48.510
Finally, you bring back all
of them here, right?

00:48:48.510 --> 00:48:52.340
For you first operation, for
your first operation, from

00:48:52.340 --> 00:48:54.890
source to target, you have
to move all of them, the

00:48:54.890 --> 00:48:56.150
[UNINTELLIGIBLE].

00:48:56.150 --> 00:48:57.910
You could have used target
as your buffer.

00:49:00.622 --> 00:49:01.530
OK?

00:49:01.530 --> 00:49:10.450
So that's why in this line I'm
using source as source.

00:49:10.450 --> 00:49:14.030
But the second argument, which
should have been the target,

00:49:14.030 --> 00:49:17.580
is now buffer because my current
target is buffer for

00:49:17.580 --> 00:49:20.480
the top n minus 1 disk.

00:49:20.480 --> 00:49:23.500
But my buffer is
now the target.

00:49:23.500 --> 00:49:23.550
OK.

00:49:23.550 --> 00:49:28.240
Because I can use the target
as buffer for the movement.

00:49:28.240 --> 00:49:33.204
Then I moved from source to the
target, the last big disk.

00:49:33.204 --> 00:49:34.090
OK?

00:49:34.090 --> 00:49:36.210
For that I can use buffer
as my buffer.

00:49:39.290 --> 00:49:43.170
Then finally I bring back from
buffer to target using source

00:49:43.170 --> 00:49:44.420
as my buffer.

00:49:47.478 --> 00:49:48.850
OK?

00:49:48.850 --> 00:49:52.240
So the thing is if you want to
have a recursive problem you

00:49:52.240 --> 00:49:54.110
can do it in two ways.

00:49:54.110 --> 00:49:59.830
One thing, you can start
thinking how to express this

00:49:59.830 --> 00:50:02.500
problem in its simpler version
like how you thought about the

00:50:02.500 --> 00:50:04.430
Fibonacci series,
for instance.

00:50:04.430 --> 00:50:08.700
Or else, you can start from
its base case, the most

00:50:08.700 --> 00:50:10.310
fundamental situation.

00:50:10.310 --> 00:50:12.810
So here it's n equal to
1, but this doesn't

00:50:12.810 --> 00:50:14.350
give you enough context.

00:50:14.350 --> 00:50:17.100
So you go to the next level, n
is equal to 2, and you have

00:50:17.100 --> 00:50:18.720
the answer.

00:50:18.720 --> 00:50:19.970
Right?