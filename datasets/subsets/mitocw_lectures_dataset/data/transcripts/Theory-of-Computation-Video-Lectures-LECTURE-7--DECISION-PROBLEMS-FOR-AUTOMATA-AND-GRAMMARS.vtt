WEBVTT

00:00:00.000 --> 00:00:01.980
[SQUEAKING]

00:00:01.980 --> 00:00:03.960
[RUSTLING]

00:00:03.960 --> 00:00:05.940
[CLICKING]

00:00:25.323 --> 00:00:27.490
MICHAEL SIPSER: All right,
why don't we get started?

00:00:27.490 --> 00:00:32.820
It's 2:35, time to begin.

00:00:32.820 --> 00:00:35.250
So everyone, welcome back--

00:00:35.250 --> 00:00:38.240
good to see you all.

00:00:38.240 --> 00:00:40.753
Well, at least a few of you--

00:00:40.753 --> 00:00:41.670
glad that you're here.

00:00:44.320 --> 00:00:48.170
So let's see.

00:00:48.170 --> 00:00:53.310
Why don't I get a layout, as I
usually do, where we have been,

00:00:53.310 --> 00:00:54.450
where we're going today.

00:00:54.450 --> 00:00:56.408
I'll talk a little tiny
bit about the homework,

00:00:56.408 --> 00:00:58.710
because I've gotten a
couple of questions on that.

00:00:58.710 --> 00:01:01.410
And then we'll jump in.

00:01:01.410 --> 00:01:06.810
So we have been talking
about Turing machines, which

00:01:06.810 --> 00:01:10.590
is going to be our
preferred model for the rest

00:01:10.590 --> 00:01:15.330
of the semester, since Turing
machines are the model which

00:01:15.330 --> 00:01:20.070
we use to capture general
purpose computing.

00:01:20.070 --> 00:01:27.800
And we looked at Turing
machines in various variations

00:01:27.800 --> 00:01:31.010
on Turing machines--
multi-tapes, non-deterministic,

00:01:31.010 --> 00:01:33.650
and so on.

00:01:33.650 --> 00:01:37.430
It's a bit recapping the history
of the subject, when people

00:01:37.430 --> 00:01:41.660
looked at a variety of
different ways of formalizing

00:01:41.660 --> 00:01:43.190
the notion of algorithm.

00:01:43.190 --> 00:01:48.650
And they showed that all of
those different formalizations

00:01:48.650 --> 00:01:51.890
were equivalent to one another,
which led to the Church-Turing

00:01:51.890 --> 00:01:55.070
thesis that all
of these models--

00:01:55.070 --> 00:01:58.430
each of these models really
capture our intuitive idea

00:01:58.430 --> 00:02:06.650
of what we mean by a procedure
or an algorithm for--

00:02:06.650 --> 00:02:11.240
at least for addressing things
like mathematical problems

00:02:11.240 --> 00:02:15.200
and precise problems
of that kind.

00:02:15.200 --> 00:02:17.510
So we talked about the
Church-Turing thesis.

00:02:17.510 --> 00:02:20.430
We also talked about a notation
for encodings and Turing

00:02:20.430 --> 00:02:20.930
machines.

00:02:20.930 --> 00:02:24.230
We'll review that briefly.

00:02:24.230 --> 00:02:28.610
So today we're going to give
a bunch of examples of Turing

00:02:28.610 --> 00:02:31.688
machine algorithms for solving
a variety of different problems.

00:02:31.688 --> 00:02:33.230
I should just say
algorithms really--

00:02:33.230 --> 00:02:34.880
nothing special about
Turing machines.

00:02:34.880 --> 00:02:38.300
Turing machines are just going
to be our formal counterpart.

00:02:38.300 --> 00:02:43.130
But from now on, we're going
to use our Church-Turing thesis

00:02:43.130 --> 00:02:45.260
in a way to just talk about
algorithms in general,

00:02:45.260 --> 00:02:46.820
because that's
really our interest.

00:02:46.820 --> 00:02:51.260
Turing machines is just our
way of reasoning about them

00:02:51.260 --> 00:02:53.150
mathematically, but
we're really ultimately

00:02:53.150 --> 00:02:54.775
interested in
understanding algorithms.

00:02:57.820 --> 00:02:59.920
In terms of the format
of today's class,

00:02:59.920 --> 00:03:02.990
I'm going to try a
little experiment.

00:03:02.990 --> 00:03:06.100
We're going to have little
breaks along the way,

00:03:06.100 --> 00:03:08.740
as well as the big coffee
break in the middle.

00:03:08.740 --> 00:03:11.230
We're going to have a little
mini breaks, because I

00:03:11.230 --> 00:03:14.170
sometimes feel that there really
isn't enough time for people

00:03:14.170 --> 00:03:16.900
to be writing chat--

00:03:16.900 --> 00:03:20.910
questions in the chat, because
things just are racing on.

00:03:20.910 --> 00:03:23.890
And so this way we'll have
a little break after the--

00:03:23.890 --> 00:03:25.210
pretty much after each slide.

00:03:25.210 --> 00:03:27.700
Some of them are going to be
a little longer than others.

00:03:27.700 --> 00:03:29.800
In case you have questions,
you can pose them

00:03:29.800 --> 00:03:32.800
to me or to the TAs, and
we'll try to get back to you

00:03:32.800 --> 00:03:34.250
on those.

00:03:34.250 --> 00:03:40.400
So moving on then, so today,
just as a quick review,

00:03:40.400 --> 00:03:45.050
Turing machines, as we
set them up, they have--

00:03:45.050 --> 00:03:49.100
on any input w, they have
three possible outcomes.

00:03:49.100 --> 00:03:52.130
The Turing machine
can halt and accept w,

00:03:52.130 --> 00:03:55.970
can halt and reject w,
or it can go forever

00:03:55.970 --> 00:03:59.930
on w, which is rejecting
by looping in our language.

00:04:02.650 --> 00:04:06.430
A Turing machine can recognize
a language, the collection

00:04:06.430 --> 00:04:08.530
of old strings that it accepts.

00:04:08.530 --> 00:04:10.780
And if the Turing
machine always halts,

00:04:10.780 --> 00:04:13.570
we say it decides the
language, and it's a decider,

00:04:13.570 --> 00:04:16.870
and so therefore, that language
is a decided language, a Turing

00:04:16.870 --> 00:04:17.612
decider.

00:04:17.612 --> 00:04:19.779
Often we just say decidable,
because we don't really

00:04:19.779 --> 00:04:23.410
have a notion of
deciding in other models,

00:04:23.410 --> 00:04:26.050
so we often talk about
Turing-recognizable

00:04:26.050 --> 00:04:26.960
or just decidable.

00:04:26.960 --> 00:04:28.750
Or we'll sometimes
just say recognizable,

00:04:28.750 --> 00:04:33.460
when we understand that we're
talking about Turing machines.

00:04:33.460 --> 00:04:37.390
We briefly talked
about encodings.

00:04:37.390 --> 00:04:40.090
When you write it inside
brackets, some objects--

00:04:40.090 --> 00:04:42.730
whatever they are-- could be
strings, could be machines,

00:04:42.730 --> 00:04:46.210
could be graphs,
could be polynomials--

00:04:46.210 --> 00:04:49.480
we're representing
them as strings,

00:04:49.480 --> 00:04:50.890
and maybe a
collection of objects

00:04:50.890 --> 00:04:53.410
together represented
as a string in order

00:04:53.410 --> 00:04:55.240
so that we can present
that information

00:04:55.240 --> 00:04:57.520
as an input to a machine.

00:04:57.520 --> 00:04:58.810
And we talk about--

00:04:58.810 --> 00:05:02.740
our languages our
collections of strings.

00:05:02.740 --> 00:05:04.840
And a notation for
writing a Turing machine

00:05:04.840 --> 00:05:09.310
is going to be simply that
English description put

00:05:09.310 --> 00:05:11.560
inside quotation
marks to represent

00:05:11.560 --> 00:05:14.860
our informal way of talking
about the formal object

00:05:14.860 --> 00:05:16.630
that we could produce,
if we wanted to.

00:05:16.630 --> 00:05:19.960
But we're never going
to ask you to do that.

00:05:19.960 --> 00:05:28.565
OK, so now let me see.

00:05:31.695 --> 00:05:33.570
Let's just take a quick
break, as I promised.

00:05:40.518 --> 00:05:42.560
If there's any quick
questions here, you can ask.

00:06:12.040 --> 00:06:14.530
Let's see-- got a lot
of questions here.

00:06:18.180 --> 00:06:19.710
All right, why don't we move on?

00:06:19.710 --> 00:06:24.240
And some of these things
are good questions.

00:06:24.240 --> 00:06:26.070
Somebody asked, can
you-- how do you

00:06:26.070 --> 00:06:29.640
tell if the machine is looping
or if it's really just taking

00:06:29.640 --> 00:06:32.100
a very long time?

00:06:32.100 --> 00:06:33.710
You can't.

00:06:33.710 --> 00:06:36.270
That's what we're going to
prove not in today's lecture,

00:06:36.270 --> 00:06:37.770
but going to prove
that on Thursday.

00:06:40.730 --> 00:06:42.080
You just can't tell.

00:06:42.080 --> 00:06:44.120
So if that's in
reference to problem 5,

00:06:44.120 --> 00:06:46.370
you're going to have to find
some other way of doing--

00:06:46.370 --> 00:06:48.980
solving that problem without
knowing whether the machine is

00:06:48.980 --> 00:06:54.550
actually ever going to halt.

00:06:54.550 --> 00:06:57.160
And somebody asked,
how can we tell

00:06:57.160 --> 00:06:59.950
if an English description is
possible for a Turing machine?

00:06:59.950 --> 00:07:06.100
Well, you can always write
down an English description

00:07:06.100 --> 00:07:07.750
for any machine.

00:07:07.750 --> 00:07:11.930
It's-- might be very
technical looking,

00:07:11.930 --> 00:07:14.770
but if you can write it down
in a formal way as states

00:07:14.770 --> 00:07:17.290
and transitions, then you can
simply write down an English

00:07:17.290 --> 00:07:22.750
description, which would
just be, follow those states.

00:07:22.750 --> 00:07:24.160
OK, let's move on.

00:07:29.300 --> 00:07:32.480
OK, this is going to
be our first example

00:07:32.480 --> 00:07:37.260
of a algorithm that's
going to answer

00:07:37.260 --> 00:07:41.390
a question about automata.

00:07:41.390 --> 00:07:42.870
And it's a very simple problem.

00:07:42.870 --> 00:07:46.670
It's a very simple
problem to solve,

00:07:46.670 --> 00:07:48.155
because we want
to start out easy.

00:07:51.140 --> 00:07:53.780
The name of the problem
is the acceptance problem

00:07:53.780 --> 00:07:56.480
for deterministic
finite automata,

00:07:56.480 --> 00:07:59.560
acceptance problem for DFAs.

00:07:59.560 --> 00:08:04.230
And I'm going to express it,
as I always do, as a language.

00:08:04.230 --> 00:08:07.340
So with this language here,
I'm calling it a ADFA--

00:08:07.340 --> 00:08:10.700
which stands for the
acceptance problem for DFAs--

00:08:10.700 --> 00:08:14.270
is the collection of pairs.

00:08:14.270 --> 00:08:15.320
B and w--

00:08:15.320 --> 00:08:17.570
B is a DFA.

00:08:17.570 --> 00:08:21.770
w is considered to be
some other string, which

00:08:21.770 --> 00:08:24.440
will be an input to B.
We're going to be thinking

00:08:24.440 --> 00:08:27.110
of it as an input to B.
I put the two of them

00:08:27.110 --> 00:08:29.720
in brackets to represent
the pair of them

00:08:29.720 --> 00:08:32.560
as a single string.

00:08:32.560 --> 00:08:35.340
We're not going to make explicit
what the form of the encoding

00:08:35.340 --> 00:08:35.840
is.

00:08:35.840 --> 00:08:38.419
The only important thing
is that the encoding should

00:08:38.419 --> 00:08:42.140
be something simple, but
that the Turing machine

00:08:42.140 --> 00:08:48.920
can decode back into the DFA and
this input string to that DFA.

00:08:48.920 --> 00:08:53.000
So anything reasonable is going
to be a satisfactory encoding

00:08:53.000 --> 00:08:55.180
from us-- for us.

00:08:55.180 --> 00:08:58.230
So this is an encoding of the
two of them into a string,

00:08:58.230 --> 00:09:01.530
and where B is a
DFA, and B accepts w.

00:09:01.530 --> 00:09:08.040
So now, if you want to test if
something's a member of ADFA,

00:09:08.040 --> 00:09:10.500
then, first of all,
you want to make sure

00:09:10.500 --> 00:09:13.950
that the string itself
that you're getting really

00:09:13.950 --> 00:09:17.910
encodes a DFA and a string.

00:09:17.910 --> 00:09:20.230
So it has to be the right form.

00:09:20.230 --> 00:09:24.510
And once you know that,
then you have the DFA,

00:09:24.510 --> 00:09:26.880
you have the string
w, and you're then

00:09:26.880 --> 00:09:28.740
going to do the
obvious thing, which

00:09:28.740 --> 00:09:31.710
would be to simulate
B on w and see

00:09:31.710 --> 00:09:35.490
if it's actually accepting w.

00:09:35.490 --> 00:09:38.380
So that's what the
content of this slide is.

00:09:38.380 --> 00:09:40.617
I'm just going to
write it down for you.

00:09:40.617 --> 00:09:42.450
So I'm going to give a
Turing machine, which

00:09:42.450 --> 00:09:43.650
I'm going to call--

00:09:43.650 --> 00:09:46.570
the name of that Turing
machine is going to be D A DFA.

00:09:49.260 --> 00:09:52.330
To help you remember the
function of this machine.

00:09:52.330 --> 00:09:55.110
This is a decider
for the language

00:09:55.110 --> 00:09:57.510
below, the ADFA language.

00:09:57.510 --> 00:10:00.240
This is just a name, but-- so
nothing fancy going on here,

00:10:00.240 --> 00:10:02.340
but just to help us
remember, because I'm

00:10:02.340 --> 00:10:07.000
going to refer to some of
these Turing machines later on.

00:10:07.000 --> 00:10:09.540
So this is the decider for ADFA.

00:10:09.540 --> 00:10:11.550
And I'm going to describe
that machine for you,

00:10:11.550 --> 00:10:16.490
and that machine decides
the ADFA language.

00:10:16.490 --> 00:10:17.690
So what does that mean?

00:10:17.690 --> 00:10:18.890
So that machine--

00:10:18.890 --> 00:10:22.300
I'm describing it now in
English, as I promised.

00:10:22.300 --> 00:10:25.990
We're going to take
an input string s,

00:10:25.990 --> 00:10:30.520
and first, it's going to check
that s has the right form, as I

00:10:30.520 --> 00:10:32.770
mentioned-- has
the form which is

00:10:32.770 --> 00:10:36.980
the encoding of a DFA and a w.

00:10:36.980 --> 00:10:39.260
If it's not of that
form, the Turing machine

00:10:39.260 --> 00:10:41.995
should reject that
input right away.

00:10:41.995 --> 00:10:44.620
Now, I'm not going to go through
the details of how that Turing

00:10:44.620 --> 00:10:47.640
machine is going to work, though
I'll say a little bit more

00:10:47.640 --> 00:10:51.690
this time only just to give
you a sense of how it actually

00:10:51.690 --> 00:10:54.702
might carry that out.

00:10:54.702 --> 00:10:56.910
If you don't believe that
you can do it with a Turing

00:10:56.910 --> 00:10:58.860
machine, believe you could do it
with your favorite programming

00:10:58.860 --> 00:10:59.190
language.

00:10:59.190 --> 00:11:00.607
That's good enough,
because that's

00:11:00.607 --> 00:11:03.708
going to be-- that's
equivalent to a Turing machine.

00:11:03.708 --> 00:11:06.000
So first, you check that the
input's of the right form.

00:11:06.000 --> 00:11:08.930
Then you're going to simulate
the computation of B on w.

00:11:08.930 --> 00:11:11.650
And then, if B ends
up in an accept state,

00:11:11.650 --> 00:11:14.150
then we know B is accepting the
input, and we should accept,

00:11:14.150 --> 00:11:15.380
and we do.

00:11:15.380 --> 00:11:20.390
If B does not end up in an
accept state at the end of w,

00:11:20.390 --> 00:11:24.000
then we should reject,
because B is not accepting w.

00:11:24.000 --> 00:11:24.500
OK?

00:11:24.500 --> 00:11:28.940
That's my description
of this machine.

00:11:28.940 --> 00:11:31.210
Let's just turn to a
little bit of details

00:11:31.210 --> 00:11:34.070
just to make sure we're
comfortable with this.

00:11:34.070 --> 00:11:37.390
So here is our Turing machine--

00:11:37.390 --> 00:11:40.938
D, the decider for ADFA.

00:11:40.938 --> 00:11:42.980
The input to that Turing
machine, as I mentioned,

00:11:42.980 --> 00:11:47.500
is going to be B and w,
provided it's of the right form.

00:11:47.500 --> 00:11:50.810
So that's what this string S
is supposed to be of that form.

00:11:50.810 --> 00:11:51.970
And what does that mean?

00:11:51.970 --> 00:11:55.630
It's just an encoding of the
machine w and the string--

00:11:55.630 --> 00:12:00.157
the machine B and the string w.

00:12:00.157 --> 00:12:01.240
Let me just write it down.

00:12:01.240 --> 00:12:05.470
Here is B written down in some
just completely explicit way,

00:12:05.470 --> 00:12:09.280
where you're just listing the
states of B, the alphabet of B,

00:12:09.280 --> 00:12:12.490
the transition function as
a table, the start state,

00:12:12.490 --> 00:12:14.920
and the set of
accepting states--

00:12:14.920 --> 00:12:17.410
just writing it down
explicitly, as you might do it

00:12:17.410 --> 00:12:18.910
if you would just
want to describe

00:12:18.910 --> 00:12:20.950
that machine in a
completely formal way,

00:12:20.950 --> 00:12:24.430
and then writing down
with the string is--

00:12:24.430 --> 00:12:26.630
whatever it is.

00:12:26.630 --> 00:12:30.510
Once DADFA has
that as its input,

00:12:30.510 --> 00:12:33.110
it can then go ahead
and do that computation.

00:12:33.110 --> 00:12:37.520
And just to try to make it
a little bit more explicit,

00:12:37.520 --> 00:12:39.500
I'm going to capture
that here by saying,

00:12:39.500 --> 00:12:43.250
let's give that Turing
machine an extra tape,

00:12:43.250 --> 00:12:45.887
because we already know that the
multi-tape model is equivalent

00:12:45.887 --> 00:12:46.970
to the single tape model--

00:12:46.970 --> 00:12:49.280
make our life perhaps
a little easier.

00:12:49.280 --> 00:12:51.440
And in the course of doing
that simulation, what

00:12:51.440 --> 00:12:52.730
do we want to keep track of?

00:12:52.730 --> 00:12:57.800
Well, what is the current
state of B, the DFA,

00:12:57.800 --> 00:13:00.980
as we're reading
the symbols of w?

00:13:00.980 --> 00:13:03.390
And where in w are
we at right now?

00:13:03.390 --> 00:13:08.630
So I'll call that k, which is
the input head location on w.

00:13:08.630 --> 00:13:12.340
How many symbols
of w have we read?

00:13:12.340 --> 00:13:12.940
OK?

00:13:12.940 --> 00:13:17.890
And that's all I'm going to say
about what this Turing machine

00:13:17.890 --> 00:13:19.030
D looks like.

00:13:22.600 --> 00:13:24.910
Oh, there's one more thing
I do want to say for the--

00:13:24.910 --> 00:13:31.150
that's coming up, because pretty
much all of the Turing machines

00:13:31.150 --> 00:13:34.090
that we're going to talk
about today and going forward

00:13:34.090 --> 00:13:36.850
are going to often want to
check that their input is

00:13:36.850 --> 00:13:37.840
of the correct form.

00:13:37.840 --> 00:13:40.090
I don't want to repeat this
every time, because that's

00:13:40.090 --> 00:13:41.500
going to be assumed.

00:13:41.500 --> 00:13:45.490
So my shorthand for that is
to say my input is of the form

00:13:45.490 --> 00:13:48.640
I'm looking for, and
that has built into it

00:13:48.640 --> 00:13:50.440
the check that the string--

00:13:50.440 --> 00:13:52.210
the input string
is of that form,

00:13:52.210 --> 00:13:55.480
and we're going to
reject if it is not.

00:13:55.480 --> 00:13:57.490
So all of our
Turing machines are

00:13:57.490 --> 00:14:01.300
going to start out, on
input, the string is

00:14:01.300 --> 00:14:05.160
of a certain form, and then go
out and do something with it.

00:14:05.160 --> 00:14:05.660
OK?

00:14:13.370 --> 00:14:16.870
OK, so let me try to answer
a few of the questions

00:14:16.870 --> 00:14:22.680
that I've gotten here, because
I think this is important

00:14:22.680 --> 00:14:25.693
as a way of getting
us all started.

00:14:25.693 --> 00:14:28.110
Now, somebody asked me, can
we use arguments of this form?

00:14:31.850 --> 00:14:33.710
Somebody asking, can we use--

00:14:33.710 --> 00:14:38.410
can we give our
description of a procedure,

00:14:38.410 --> 00:14:39.910
if I'm understanding
this correctly,

00:14:39.910 --> 00:14:43.310
as using some other
programming language?

00:14:43.310 --> 00:14:45.970
Well, typically, you just want
to make sure you're understood.

00:14:45.970 --> 00:14:47.560
If you want to do
that on a homework,

00:14:47.560 --> 00:14:52.167
I wouldn't advocate writing
your algorithm in Java,

00:14:52.167 --> 00:14:53.750
because it's going
to be hard to read.

00:14:53.750 --> 00:14:56.860
But write it down in some
pseudo programming language

00:14:56.860 --> 00:14:58.570
if you want, just to
make sure it's clear

00:14:58.570 --> 00:14:59.992
that-- what you're doing.

00:14:59.992 --> 00:15:02.200
Probably English is going
to be the easiest for you--

00:15:06.420 --> 00:15:07.885
even though this person says--

00:15:07.885 --> 00:15:09.260
feels it would be
easier to do it

00:15:09.260 --> 00:15:11.390
in terms of a formal language.

00:15:11.390 --> 00:15:16.640
Well, whatever's easier-- as
long as we can understand it.

00:15:16.640 --> 00:15:18.680
This is a good question
here I got to ask.

00:15:18.680 --> 00:15:26.290
What if B-- here's our
B-- gets into a loop on w?

00:15:26.290 --> 00:15:28.060
Well, that's not
going to happen.

00:15:28.060 --> 00:15:29.080
B is a DFA.

00:15:29.080 --> 00:15:35.050
DFAs-- they move from state
to state every time they

00:15:35.050 --> 00:15:36.550
read a symbol of w.

00:15:36.550 --> 00:15:39.070
When they get to the end of
w, it's the end of the story.

00:15:39.070 --> 00:15:41.140
There's no more
computation to be done.

00:15:41.140 --> 00:15:43.360
So we know in exactly
how many steps

00:15:43.360 --> 00:15:45.490
B is ever going to
take on-- it's going

00:15:45.490 --> 00:15:48.280
to take the same number of steps
as the length of the input.

00:15:48.280 --> 00:15:50.800
That's how many moves
it gets to make.

00:15:50.800 --> 00:15:53.470
B as a DFA never loops.

00:15:53.470 --> 00:15:56.930
So that would be a problem if
it did loop, but it doesn't.

00:15:56.930 --> 00:16:00.860
That input never does loop.

00:16:00.860 --> 00:16:03.260
So have we verified
that D is a decider?

00:16:03.260 --> 00:16:04.880
Well, I think I just did.

00:16:09.830 --> 00:16:13.430
From my standpoint, we've
said enough to be sure

00:16:13.430 --> 00:16:16.520
that D is a decider.

00:16:16.520 --> 00:16:19.010
There's never any
reason for D to be--

00:16:19.010 --> 00:16:24.575
for that DADFA Turing machine
to be getting into a loop.

00:16:24.575 --> 00:16:26.450
The input head location
is referring to where

00:16:26.450 --> 00:16:27.900
we are on the string w?

00:16:27.900 --> 00:16:28.400
Yes.

00:16:34.278 --> 00:16:36.070
And somebody's asking
me, is this the level

00:16:36.070 --> 00:16:37.210
of detail for the homework?

00:16:37.210 --> 00:16:38.080
Yes.

00:16:38.080 --> 00:16:38.830
That's all I want.

00:16:38.830 --> 00:16:41.345
It's all I'm looking for.

00:16:41.345 --> 00:16:41.845
OK?

00:16:44.480 --> 00:16:47.150
Let us move on.

00:16:47.150 --> 00:16:48.992
I'm going to have to--

00:16:48.992 --> 00:16:50.450
otherwise we'll
never get anywhere.

00:16:50.450 --> 00:16:51.867
There are a lot
of questions here.

00:16:51.867 --> 00:16:53.250
They're good questions.

00:16:53.250 --> 00:16:55.160
So why don't we go on?

00:16:55.160 --> 00:16:56.858
Some of these may
get resolved as we're

00:16:56.858 --> 00:16:58.400
going to look at
additional examples,

00:16:58.400 --> 00:17:01.830
because that's all of today
is pretty much examples.

00:17:01.830 --> 00:17:04.657
Let's talk about the similar
problem, the acceptance

00:17:04.657 --> 00:17:05.740
problem, but now for NFAs.

00:17:09.390 --> 00:17:12.270
So now, actually,
NFAs can loop, so we

00:17:12.270 --> 00:17:14.950
have to think about what
that possibly could look at.

00:17:14.950 --> 00:17:17.640
But before we get ahead
of ourselves-- so now

00:17:17.640 --> 00:17:20.319
the acceptance problems for
NFAs looked very similar,

00:17:20.319 --> 00:17:24.099
except B is going to be an NFA.

00:17:24.099 --> 00:17:27.430
That's going to be a
decidable language too.

00:17:27.430 --> 00:17:29.740
And now we have
Turing machine A--

00:17:29.740 --> 00:17:34.950
DANFA, the decider for
ANFA that decides ANFA.

00:17:34.950 --> 00:17:35.450
OK?

00:17:35.450 --> 00:17:38.298
So now, as promised,
here's our new form

00:17:38.298 --> 00:17:39.590
for writing our Turing machine.

00:17:39.590 --> 00:17:45.026
On input B, w, we're
assuming that B--

00:17:45.026 --> 00:17:47.030
based on the context,
sometimes you

00:17:47.030 --> 00:17:49.247
may want to say at this
point, what B and w are.

00:17:49.247 --> 00:17:51.080
But from the context,
we know what they are.

00:17:51.080 --> 00:17:53.885
They're going to be an NFA
and an input w for that NFA.

00:17:58.200 --> 00:18:01.510
I do want to jump
into the solution.

00:18:01.510 --> 00:18:06.935
First, before we actually look
at the solution of this, we--

00:18:06.935 --> 00:18:10.980
the Turing machine could
simulate the NFA on input w.

00:18:10.980 --> 00:18:13.050
And you have to be
careful on that simulation

00:18:13.050 --> 00:18:17.520
that you don't end up
looping, because don't forget,

00:18:17.520 --> 00:18:22.230
an NFA could have epsilon
moves, and could be

00:18:22.230 --> 00:18:24.540
looping on those epsilon moves.

00:18:24.540 --> 00:18:28.920
And so that would be a problem,
if you're not careful about how

00:18:28.920 --> 00:18:30.060
you do that simulation.

00:18:33.510 --> 00:18:37.890
Now, I think, if you were
going to simulate an NFA,

00:18:37.890 --> 00:18:40.350
you would be--

00:18:40.350 --> 00:18:45.120
wouldn't follow loop
around loops forever.

00:18:45.120 --> 00:18:46.938
And I think you can--

00:18:46.938 --> 00:18:48.480
without getting--
because this is not

00:18:48.480 --> 00:18:50.147
the way I'm going to
solve the problem--

00:18:50.147 --> 00:18:52.920
you could find a way
to avoid getting caught

00:18:52.920 --> 00:18:58.230
and getting stuck
in loops for an NFA.

00:18:58.230 --> 00:19:04.440
So even though that looks like
it could be a problem, in terms

00:19:04.440 --> 00:19:08.400
of looping forever, it turns
out that it won't be a problem--

00:19:08.400 --> 00:19:10.530
it wouldn't be a problem
if you're careful.

00:19:10.530 --> 00:19:12.120
But I'm not going
to solve it that way

00:19:12.120 --> 00:19:14.670
anyway, because I'm going to
illustrate a different method

00:19:14.670 --> 00:19:15.870
for solving this problem.

00:19:15.870 --> 00:19:21.625
And that is we have exhibited
before a way of converting NFAs

00:19:21.625 --> 00:19:22.125
to DFAs.

00:19:25.020 --> 00:19:30.180
So my Turing machine is going
to solve the ANFA problem

00:19:30.180 --> 00:19:32.940
by converting its
input, which is an NFA,

00:19:32.940 --> 00:19:34.830
to an equivalent DFA.

00:19:34.830 --> 00:19:36.900
I'm calling the
NFA B and the DFA

00:19:36.900 --> 00:19:40.450
that I got-- converting
it into B prime.

00:19:40.450 --> 00:19:43.460
And what's nice about that
is that, first of all,

00:19:43.460 --> 00:19:47.320
we already know how to do
that conversion, because we

00:19:47.320 --> 00:19:50.740
essentially went over that in
lecture a few lectures back,

00:19:50.740 --> 00:19:54.050
and it's spelled out in
full detail in the textbook.

00:19:54.050 --> 00:19:56.020
So that is a conversion
we know how to do--

00:19:56.020 --> 00:19:58.620
we'll assume we know how to do.

00:19:58.620 --> 00:20:01.890
And we can implement that
Turing-- that conversion

00:20:01.890 --> 00:20:04.280
on a Turing machine.

00:20:04.280 --> 00:20:07.820
Then, once we have
the equivalent DFA,

00:20:07.820 --> 00:20:10.220
what do we do with that?

00:20:10.220 --> 00:20:12.140
In the previous
slide, we showed how

00:20:12.140 --> 00:20:15.190
to solve the problem for DFAs.

00:20:15.190 --> 00:20:17.560
So if we can convert
the NFA to a DFA,

00:20:17.560 --> 00:20:20.170
and then we already know how
to solve the problem for DFAs,

00:20:20.170 --> 00:20:21.698
then we're done.

00:20:21.698 --> 00:20:22.990
So that's how I'm going to say.

00:20:22.990 --> 00:20:25.510
We're going to convert
the NFA to a DFA,

00:20:25.510 --> 00:20:30.040
and then I'm going
to run that DADFA

00:20:30.040 --> 00:20:33.650
problem on the new
machine that I produced.

00:20:33.650 --> 00:20:35.090
So remember that the--

00:20:35.090 --> 00:20:39.900
this machine here
decides the ADFA problem.

00:20:39.900 --> 00:20:43.620
And now I'm going to accept,
if that new machine--

00:20:43.620 --> 00:20:51.720
if that previous Turing machine
accepts the DADFA problem

00:20:51.720 --> 00:20:55.680
the machine accepts, and
I'm going to basically do

00:20:55.680 --> 00:20:56.430
whatever it does.

00:20:56.430 --> 00:20:58.410
If it accepts, I'll accept.

00:20:58.410 --> 00:21:00.180
If it rejects, then I'll reject.

00:21:11.100 --> 00:21:14.700
So I guess the thing
that this illustrates

00:21:14.700 --> 00:21:18.300
is this idea of using a
conversion construction

00:21:18.300 --> 00:21:20.310
inside a Turing
machine, and then

00:21:20.310 --> 00:21:22.290
a previously constructed
Turing machine

00:21:22.290 --> 00:21:26.140
basically as a subroutine.

00:21:26.140 --> 00:21:29.080
All this is perfectly legal,
and it's the kind of thing

00:21:29.080 --> 00:21:30.520
we're going to be
doing a lot of,

00:21:30.520 --> 00:21:31.870
and that you should
be used to doing

00:21:31.870 --> 00:21:34.162
that-- get ready to be doing
that on your homework too.

00:21:38.650 --> 00:21:41.890
And in fact, I'll give you
another a little extra hint

00:21:41.890 --> 00:21:45.400
that problem 6 can be
solved in this way.

00:21:48.910 --> 00:21:51.190
OK.

00:21:51.190 --> 00:21:53.860
All right, so here,
let's pause briefly.

00:22:01.550 --> 00:22:05.720
OK, got some interesting
questions here coming up--

00:22:10.850 --> 00:22:12.560
somebody asked me,
do we need to be

00:22:12.560 --> 00:22:14.570
explicit about how
we're going to simulate

00:22:14.570 --> 00:22:17.135
that NFA or the DFA?

00:22:17.135 --> 00:22:19.010
Because we don't know
how many states it has.

00:22:21.820 --> 00:22:23.600
You do know how
many states it has.

00:22:23.600 --> 00:22:26.390
Once it's presented
to you on the input,

00:22:26.390 --> 00:22:29.990
you can see, oh, this is a
machine that has 12 states--

00:22:29.990 --> 00:22:32.360
because you're given
the machine, and then

00:22:32.360 --> 00:22:33.500
you can do the simulation.

00:22:40.270 --> 00:22:40.825
Let's see.

00:22:44.370 --> 00:22:47.520
And someone's asking me about
limits on the simulation

00:22:47.520 --> 00:22:49.860
power of a Turing machine.

00:22:49.860 --> 00:22:52.470
That's a question that I'm
going to postpone to later,

00:22:52.470 --> 00:22:53.890
because you're
asking if a Turing

00:22:53.890 --> 00:22:55.267
machine can simulate itself.

00:22:55.267 --> 00:22:56.850
And we'll talk about
things like that,

00:22:56.850 --> 00:22:59.890
but that's in a
few weeks from now,

00:22:59.890 --> 00:23:02.340
so I'll hold off on that one.

00:23:05.560 --> 00:23:08.600
Decidable languages--
somebody's asking me

00:23:08.600 --> 00:23:11.660
a good question about closure
properties of the class

00:23:11.660 --> 00:23:13.400
of decidable languages.

00:23:13.400 --> 00:23:16.760
Are they closed under
intersection, union, and so on?

00:23:16.760 --> 00:23:19.460
Yes.

00:23:19.460 --> 00:23:23.660
And the decidable languages are
also closed under complement.

00:23:23.660 --> 00:23:25.850
That should be something
you should think about.

00:23:25.850 --> 00:23:28.010
But yes, that is true.

00:23:28.010 --> 00:23:30.470
The recognizable
languages, however,

00:23:30.470 --> 00:23:33.050
are closed under union
and intersection,

00:23:33.050 --> 00:23:36.590
but they are not closed
under complement.

00:23:36.590 --> 00:23:39.500
So that we will prove
on Thursday's lecture.

00:23:45.830 --> 00:23:49.205
So another question is, could we
have just run B on w in this--

00:23:49.205 --> 00:23:51.860
in solving this problem,
instead of using reduced--

00:23:51.860 --> 00:23:55.250
converting it to a
new Turing machine--

00:23:55.250 --> 00:23:56.690
the B prime?

00:23:56.690 --> 00:24:01.940
Well, yes, we could
have just done that.

00:24:01.940 --> 00:24:03.050
OK.

00:24:03.050 --> 00:24:04.340
I think we better move on.

00:24:04.340 --> 00:24:07.280
I don't want to get
too bogged down here--

00:24:07.280 --> 00:24:09.020
got a lot of questions
there, so sorry

00:24:09.020 --> 00:24:12.950
if I'm not getting to
all of the questions.

00:24:12.950 --> 00:24:15.360
OK.

00:24:15.360 --> 00:24:17.310
Or you can write to
the TAs too, obviously.

00:24:17.310 --> 00:24:18.720
I'm sure you are.

00:24:18.720 --> 00:24:21.330
OK, so let's talk about
a different problem--

00:24:21.330 --> 00:24:22.800
emptiness problem for DFAs.

00:24:29.740 --> 00:24:32.410
I'm going to give you now a--

00:24:32.410 --> 00:24:35.230
just a DFA--

00:24:35.230 --> 00:24:38.650
B-- and no input.

00:24:38.650 --> 00:24:42.040
And I'm going to ask, is
the language of that DFA

00:24:42.040 --> 00:24:46.092
the empty set, the
empty language?

00:24:46.092 --> 00:24:47.800
You understand the
problem, first of all?

00:24:47.800 --> 00:24:51.180
I'm just handing you in a
DFA, and I want to know,

00:24:51.180 --> 00:24:53.520
does this DFA accept
any strings at all,

00:24:53.520 --> 00:24:56.760
or is it just some dumb DFA--

00:24:56.760 --> 00:24:59.110
it's just always
very negative DFA,

00:24:59.110 --> 00:25:02.120
it just rejects everything--

00:25:02.120 --> 00:25:04.550
and it has the empty language?

00:25:04.550 --> 00:25:06.800
How do you tell?

00:25:06.800 --> 00:25:09.070
Not super hard, if
you think about how

00:25:09.070 --> 00:25:11.670
you would write a
program to do that

00:25:11.670 --> 00:25:14.470
or how you would
do it yourself--

00:25:14.470 --> 00:25:17.120
so that's a decidable
language again.

00:25:17.120 --> 00:25:19.350
So we're going to give
now a Turing machine

00:25:19.350 --> 00:25:22.290
decider for that language.

00:25:22.290 --> 00:25:27.540
That decider says, well,
I'm giving that DFA--

00:25:27.540 --> 00:25:29.760
I want to know if its
language is empty.

00:25:29.760 --> 00:25:32.430
And the idea is just
what you would think.

00:25:32.430 --> 00:25:35.490
I'm going to see, is there
a path from the start state

00:25:35.490 --> 00:25:38.040
of that DFA to the-- an
accept state of the DFA?

00:25:38.040 --> 00:25:40.590
If there is such a
path, then that DFA

00:25:40.590 --> 00:25:43.270
is going to have an input
which goes along that path,

00:25:43.270 --> 00:25:45.070
and will be accepted.

00:25:45.070 --> 00:25:46.840
And so the language
won't be empty.

00:25:46.840 --> 00:25:50.030
If there's no such path,
then clearly, this DFA

00:25:50.030 --> 00:25:54.170
can never accept anything, and
so this language will be empty.

00:25:54.170 --> 00:25:54.860
OK.

00:25:54.860 --> 00:26:01.470
Now, there are many
different path algorithms.

00:26:01.470 --> 00:26:07.530
I think it would be a little
bit sparse of me just--

00:26:07.530 --> 00:26:08.710
some of you know algorithms.

00:26:08.710 --> 00:26:11.230
Some of you don't know
path checking algorithms.

00:26:11.230 --> 00:26:13.230
I would like you to just
to-- if you were giving

00:26:13.230 --> 00:26:14.790
this kind of an
answer on a homework,

00:26:14.790 --> 00:26:17.040
to give me some sense
of how that algorithm is

00:26:17.040 --> 00:26:19.110
going to work.

00:26:19.110 --> 00:26:22.700
Don't be too high
level about it.

00:26:22.700 --> 00:26:27.310
So the one I have in mind
is the breadth research,

00:26:27.310 --> 00:26:28.310
if you've heard of that.

00:26:28.310 --> 00:26:30.620
But it's very simple algorithm.

00:26:30.620 --> 00:26:33.510
What I'm going to use is
kind of a marking procedure.

00:26:33.510 --> 00:26:36.440
So I'm going to start
by coloring the--

00:26:36.440 --> 00:26:41.950
here is this-- I should have
indicated-- this is my DFAB.

00:26:41.950 --> 00:26:45.460
This is B over here.

00:26:45.460 --> 00:26:49.780
Should I try taking a chance
of writing on this thing--

00:26:49.780 --> 00:26:51.740
oops.

00:26:51.740 --> 00:26:56.470
This is B. Oh, great--

00:26:56.470 --> 00:26:59.140
that didn't help.

00:26:59.140 --> 00:27:00.850
So this is B here.

00:27:00.850 --> 00:27:04.150
And the way I'm going to
test if it has a path--

00:27:04.150 --> 00:27:06.610
if it accepts an
input is by seeing

00:27:06.610 --> 00:27:08.710
if there's a path from
the start state to any one

00:27:08.710 --> 00:27:09.850
of the accept states.

00:27:09.850 --> 00:27:13.210
And I'm going to start it
by marking the start state,

00:27:13.210 --> 00:27:15.160
and then marking
all states that I

00:27:15.160 --> 00:27:17.530
can get to from
previously marked states,

00:27:17.530 --> 00:27:20.200
and keep doing that until I
can't get to anything new.

00:27:23.200 --> 00:27:26.260
There's going to be a series
of iterations here marking

00:27:26.260 --> 00:27:29.500
more and more states until
there's nothing new to mark,

00:27:29.500 --> 00:27:31.870
and then I say, did I
mark any accept states?

00:27:34.800 --> 00:27:39.030
OK, so let's just see how I
write that down in English.

00:27:39.030 --> 00:27:41.970
So I started marking
the start state.

00:27:41.970 --> 00:27:44.160
I repeat until no
new state is marked.

00:27:46.885 --> 00:27:48.510
I'm going to say,
mark every state that

00:27:48.510 --> 00:27:53.130
has an incoming arrow from
a previously marked state.

00:27:53.130 --> 00:27:56.070
Accept-- then, once I'm done
with, that repeat loop--

00:27:56.070 --> 00:28:00.193
accept if no accept state is
marked, because that means--

00:28:00.193 --> 00:28:01.860
don't forget, it's a
little bit inverted

00:28:01.860 --> 00:28:02.943
from what you might think.

00:28:02.943 --> 00:28:06.900
I'm going to accept if there's
no marked accept state,

00:28:06.900 --> 00:28:10.170
because that means there's
no path to an accept state

00:28:10.170 --> 00:28:13.200
from the start state, which
means the language is empty.

00:28:13.200 --> 00:28:17.610
And EDFA is the DFAs
that have empty language,

00:28:17.610 --> 00:28:20.390
so I should be accepting those.

00:28:20.390 --> 00:28:23.540
If there's no way to
get to an accept state,

00:28:23.540 --> 00:28:24.920
no accept state is marked.

00:28:24.920 --> 00:28:27.560
And reject if some accept
state earmark, because then

00:28:27.560 --> 00:28:30.350
the language is not empty.

00:28:30.350 --> 00:28:32.690
OK, so that's all I
wanted to say about that.

00:28:35.262 --> 00:28:36.720
Somebody's asking,
can you just say

00:28:36.720 --> 00:28:40.270
something like breadth
versus [AUDIO OUT]..

00:28:40.270 --> 00:28:43.050
The sketchier you
are, the more chances

00:28:43.050 --> 00:28:45.960
that you're going to get
caught by the grader, who's

00:28:45.960 --> 00:28:48.525
not going--

00:28:48.525 --> 00:28:51.330
we have an army of people
grading these problems,

00:28:51.330 --> 00:28:53.250
and just to stay on the--

00:28:53.250 --> 00:28:55.980
be on the safe
side of sketchiness

00:28:55.980 --> 00:28:58.110
and, say, don't cut
too many corners,

00:28:58.110 --> 00:29:00.547
because you might
miss something.

00:29:00.547 --> 00:29:02.880
Chances are it would be OK
just to say breadth research,

00:29:02.880 --> 00:29:04.530
but I would prefer if--

00:29:04.530 --> 00:29:07.260
you'd be safer if you said
a little bit more than that.

00:29:07.260 --> 00:29:08.990
OK.

00:29:08.990 --> 00:29:14.100
Oh, this is a good
question here.

00:29:14.100 --> 00:29:18.670
Somebody asked, can we just
run the DFA on all short--

00:29:18.670 --> 00:29:19.520
on all strings?

00:29:19.520 --> 00:29:23.510
Well, first of all, one thing--

00:29:23.510 --> 00:29:26.360
to say something bad
would be, well, just

00:29:26.360 --> 00:29:30.200
feed in all possible
strings into the DFA,

00:29:30.200 --> 00:29:31.970
and if any one of them--

00:29:31.970 --> 00:29:33.770
if it accepts any
one of them, then we

00:29:33.770 --> 00:29:36.590
know its language is not empty.

00:29:36.590 --> 00:29:38.420
Well, that's not
a good algorithm,

00:29:38.420 --> 00:29:42.560
because that's going to
potentially run forever,

00:29:42.560 --> 00:29:44.240
because there's lots of strings.

00:29:44.240 --> 00:29:48.140
There's infinitely many
strings to feed in to that DFA.

00:29:48.140 --> 00:29:52.130
And so a Turing machine, if
it's trying to be a decider,

00:29:52.130 --> 00:29:55.212
had better not do any infinite
operations that are potentially

00:29:55.212 --> 00:29:56.045
going to go forever.

00:29:59.290 --> 00:30:02.410
To be fair to the proposer
here, the questioner here--

00:30:02.410 --> 00:30:06.010
didn't ask that-- says, well,
can we feed in all strings

00:30:06.010 --> 00:30:10.470
up to some bound, which
would be the number of states

00:30:10.470 --> 00:30:11.730
of the machine in this case?

00:30:11.730 --> 00:30:13.350
And yes, that would
work, but then you

00:30:13.350 --> 00:30:17.310
would have to argue
that that's enough.

00:30:17.310 --> 00:30:21.060
And yes, it is enough, but it
wouldn't-- would not be enough

00:30:21.060 --> 00:30:22.920
in answering the
problem just to say,

00:30:22.920 --> 00:30:25.707
feed it in that number
of them, and we're done.

00:30:25.707 --> 00:30:26.790
You would have to say why.

00:30:32.365 --> 00:30:32.865
OK.

00:30:40.550 --> 00:30:41.565
Lot of questions here--

00:30:41.565 --> 00:30:42.440
I'm going to move on.

00:30:45.720 --> 00:30:46.340
Let's see.

00:30:46.340 --> 00:30:48.770
Equivalence problem for DFAs--

00:30:48.770 --> 00:30:51.860
now we're going to take things
to the next level-- ask,

00:30:51.860 --> 00:30:55.490
are there two--

00:30:55.490 --> 00:30:59.170
I'm going to give you two DFAs.

00:30:59.170 --> 00:31:01.810
And I want to know, do they
describe the same language--

00:31:01.810 --> 00:31:05.140
do they recognize
the same language?

00:31:05.140 --> 00:31:07.900
OK?

00:31:07.900 --> 00:31:09.620
So how are we going to do that?

00:31:09.620 --> 00:31:12.148
So that's a decidable language.

00:31:12.148 --> 00:31:12.940
Here's the decider.

00:31:16.160 --> 00:31:19.560
My input now is going
to be two DFAs--

00:31:19.560 --> 00:31:21.780
again, represented as a
string, because that's

00:31:21.780 --> 00:31:24.270
what Turing machines deal
with as their inputs.

00:31:24.270 --> 00:31:28.290
But they can unpack that
string into two DFAs.

00:31:28.290 --> 00:31:32.040
And there are several different
ways to do this problem,

00:31:32.040 --> 00:31:35.140
and I'm sure I'm going to get
suggestions with other ways

00:31:35.140 --> 00:31:35.640
to go.

00:31:35.640 --> 00:31:41.910
One thing you could do is
just to feed in strings

00:31:41.910 --> 00:31:45.260
up to a certain length.

00:31:45.260 --> 00:31:48.170
Just like before, you can't
feed in all possible strings

00:31:48.170 --> 00:31:50.240
and see if the machines
ever behave differently

00:31:50.240 --> 00:31:55.160
on any of them, because
that's an infinite operation,

00:31:55.160 --> 00:31:56.930
and we already decided
we can't do that.

00:31:56.930 --> 00:31:59.450
Now, if you want
to talk about this

00:31:59.450 --> 00:32:02.570
being a recognizer,
instead of a decider,

00:32:02.570 --> 00:32:04.730
then you might be able
to do something like that

00:32:04.730 --> 00:32:06.620
just to make sure your--

00:32:06.620 --> 00:32:09.357
you have to be just careful.

00:32:09.357 --> 00:32:10.940
Let me not say more
on that right now.

00:32:10.940 --> 00:32:15.540
But certainly, for a decider,
you can't go forever.

00:32:15.540 --> 00:32:18.950
You can't have
infinite operations.

00:32:18.950 --> 00:32:23.500
So you would have
to have a cut-off.

00:32:23.500 --> 00:32:26.710
So you can feed in all possible
strings up to some length,

00:32:26.710 --> 00:32:29.800
say, into A and B, and see
if there's any difference.

00:32:29.800 --> 00:32:32.410
Now, we actually had a problem
on that in the problem set

00:32:32.410 --> 00:32:39.160
1, which said, if two DFAs
have unequal languages,

00:32:39.160 --> 00:32:41.567
then they're going
to see a difference.

00:32:41.567 --> 00:32:43.900
Then there's going to be a
string which acts differently

00:32:43.900 --> 00:32:46.510
on them, which is
of length, at most,

00:32:46.510 --> 00:32:49.660
the product of the number of
states of those two machines.

00:32:49.660 --> 00:32:54.040
So you can either
reference that problem--

00:32:54.040 --> 00:32:56.840
that would be an adequate
solution-- or reprove it

00:32:56.840 --> 00:32:57.340
or whatever.

00:32:57.340 --> 00:32:58.400
That would be fine.

00:32:58.400 --> 00:33:00.160
In fact, you can do
even better than that,

00:33:00.160 --> 00:33:01.630
as the optional problem showed.

00:33:01.630 --> 00:33:04.150
You only have to go up to the
sum of the number of states,

00:33:04.150 --> 00:33:05.440
not up to the product.

00:33:05.440 --> 00:33:09.510
But that's actually
very difficult to show.

00:33:09.510 --> 00:33:11.255
I'm not going to
prove it that way.

00:33:11.255 --> 00:33:13.630
I'm going to prove it in an
entirely different way, which

00:33:13.630 --> 00:33:16.150
doesn't require any
analysis at all--

00:33:16.150 --> 00:33:19.510
no proving something
about balance.

00:33:19.510 --> 00:33:24.220
I'm going to take advantage of
something we've already shown,

00:33:24.220 --> 00:33:27.820
which is I'm going to make
a new finite automaton,

00:33:27.820 --> 00:33:32.170
a new DFAC built out
of A and B, which

00:33:32.170 --> 00:33:36.247
accepts all the strings
on which A and B disagree.

00:33:36.247 --> 00:33:37.330
And I'll show you how to--

00:33:37.330 --> 00:33:39.182
that's easy to do.

00:33:39.182 --> 00:33:41.140
So first of all, let's--
in terms of a picture,

00:33:41.140 --> 00:33:42.420
let's understand what this is.

00:33:42.420 --> 00:33:43.960
So here we have--

00:33:43.960 --> 00:33:46.510
this is the language of
A, this is the language

00:33:46.510 --> 00:33:49.590
of B written as a Venn diagram.

00:33:49.590 --> 00:33:53.430
And where are those places
where they disagree?

00:33:53.430 --> 00:33:56.850
Well, they're either in
A, but not in B, or in B,

00:33:56.850 --> 00:33:58.590
but not in A. I'm
showing it to you here

00:33:58.590 --> 00:34:02.040
in terms of the blue region.

00:34:02.040 --> 00:34:05.130
That actually has a name
called the symmetric difference

00:34:05.130 --> 00:34:07.830
of these two sets.

00:34:07.830 --> 00:34:10.120
These are the--
all of the members

00:34:10.120 --> 00:34:13.020
which are in exactly one out
of the two, but not both.

00:34:15.870 --> 00:34:21.289
If you can make a machine C that
would accept all of the strings

00:34:21.289 --> 00:34:23.664
in the blue region, then what
do we do with that machine?

00:34:26.610 --> 00:34:29.070
We test of its length
language is empty,

00:34:29.070 --> 00:34:31.380
which is what we've
already shown how to do--

00:34:31.380 --> 00:34:34.679
because of the blue region is
empty, that means that L of A

00:34:34.679 --> 00:34:39.139
equals L of B.

00:34:39.139 --> 00:34:44.000
So I'm going to make a machine,
a DFAC where the language of C

00:34:44.000 --> 00:34:45.980
is exactly that
symmetric difference.

00:34:45.980 --> 00:34:48.889
It's all the strings in A
intersected with the strings

00:34:48.889 --> 00:34:53.150
that are not in B-- so in A and
not in B-- or in B and not--

00:34:53.150 --> 00:34:54.050
then not an A--

00:34:54.050 --> 00:34:56.179
take the union of
those two parts.

00:34:56.179 --> 00:34:58.100
And how do we know
we can make C?

00:34:58.100 --> 00:35:02.690
Well, we have those
closure constructions,

00:35:02.690 --> 00:35:04.430
which we showed
several lectures back.

00:35:04.430 --> 00:35:06.680
Those closure instructions
can be implemented

00:35:06.680 --> 00:35:09.560
on a Turing machine.

00:35:09.560 --> 00:35:12.520
So a Turing machine
can build the DFAC,

00:35:12.520 --> 00:35:18.850
and then use that test
from a few slides back,

00:35:18.850 --> 00:35:21.880
the emptiness-- the last
slide-- the emptiness tester

00:35:21.880 --> 00:35:25.970
for DFAs on C to see whether
its language is empty.

00:35:25.970 --> 00:35:28.043
And now, if C's
language is empty,

00:35:28.043 --> 00:35:29.710
then we know we can
accept, because that

00:35:29.710 --> 00:35:33.310
means the two-- that L of
A equals L of B. Otherwise,

00:35:33.310 --> 00:35:35.610
we can reject.

00:35:35.610 --> 00:35:36.330
OK?

00:35:36.330 --> 00:35:37.350
So here's a note--

00:35:37.350 --> 00:35:40.430
I'm going to ask you a check-in.

00:35:40.430 --> 00:35:43.630
You can also use that time to
send me a few more questions,

00:35:43.630 --> 00:35:44.820
if you want.

00:35:44.820 --> 00:35:46.570
OK, here's my check-in.

00:35:46.570 --> 00:35:49.750
OK, now, instead of testing
equivalence of finite--

00:35:49.750 --> 00:35:51.880
of DFAs, I want to
test equivalence

00:35:51.880 --> 00:35:53.230
of regular expressions.

00:35:56.440 --> 00:35:58.290
So here are R1, R2.

00:35:58.290 --> 00:36:00.840
Regular expressions are called
the EQ regular expressions

00:36:00.840 --> 00:36:01.740
problem--

00:36:01.740 --> 00:36:03.300
equivalents of
regular expressions.

00:36:03.300 --> 00:36:07.910
Can we now conclude that this
problem is also decidable,

00:36:07.910 --> 00:36:10.940
either immediately from
stuff we've already shown;

00:36:10.940 --> 00:36:14.780
or yes, but would take some
significant extra work; or no,

00:36:14.780 --> 00:36:17.000
because intersection is
not a regular operation?

00:36:17.000 --> 00:36:19.640
So let's see if I can pull that
out here-- launch the polling.

00:36:22.830 --> 00:36:23.460
Here we go.

00:36:26.510 --> 00:36:28.205
OK, I think we're
just about done here.

00:36:32.823 --> 00:36:33.910
Five seconds more--

00:36:37.000 --> 00:36:38.905
OK, ready, set, end.

00:36:42.790 --> 00:36:43.360
All right.

00:36:47.580 --> 00:36:51.630
Yes, the correct answer is A.
We have basically already shown

00:36:51.630 --> 00:36:54.900
this fact, because--

00:36:54.900 --> 00:36:55.590
why is that?

00:36:55.590 --> 00:36:59.730
Because we have shown
that we can convert--

00:36:59.730 --> 00:37:01.690
if you're given two
regular expressions,

00:37:01.690 --> 00:37:03.900
and we want to test
whether they're equivalent,

00:37:03.900 --> 00:37:05.760
they generate the
same language, we

00:37:05.760 --> 00:37:10.980
can convert them both
to find out automata.

00:37:10.980 --> 00:37:15.620
We can convert them to NFAs,
and then the NFAs to DFAs.

00:37:15.620 --> 00:37:18.770
And then we can
apply what we've just

00:37:18.770 --> 00:37:22.640
showed about testing
equivalence of DFAs.

00:37:22.640 --> 00:37:25.010
So yes, it really follows
immediately from stuff

00:37:25.010 --> 00:37:27.590
we've already shown-- the
conversion, number one,

00:37:27.590 --> 00:37:31.550
and then the testing of
equivalence for DFAs.

00:37:31.550 --> 00:37:33.590
So there's not really
any work to do here.

00:37:33.590 --> 00:37:38.000
And in fact, what I'm trying to
illustrate with this check-in--

00:37:38.000 --> 00:37:41.240
that, once you've shown
how to do some kind

00:37:41.240 --> 00:37:44.010
of a test for one model, it--

00:37:44.010 --> 00:37:46.520
going to apply for all
of the equivalent models

00:37:46.520 --> 00:37:48.860
that we've shown to be
equivalent, because the Turing

00:37:48.860 --> 00:37:54.570
machine can do the constructions
which show the equivalence.

00:37:54.570 --> 00:37:56.880
OK, so let's move on.

00:37:59.450 --> 00:38:01.250
Somebody didn't get the poll.

00:38:01.250 --> 00:38:03.710
Did most people
not get the poll?

00:38:03.710 --> 00:38:06.810
Well, I think most of
you have gotten it.

00:38:06.810 --> 00:38:08.792
Did you?

00:38:08.792 --> 00:38:10.250
I'm not seeing a
lot of complaints.

00:38:10.250 --> 00:38:12.350
So if you didn't get
the poll, something

00:38:12.350 --> 00:38:14.510
is wrong with your
setup, and you're

00:38:14.510 --> 00:38:20.060
going to have to take the
recorded check-ins that

00:38:20.060 --> 00:38:22.720
are going to launch right
after this lecture's over.

00:38:22.720 --> 00:38:24.152
Sorry.

00:38:24.152 --> 00:38:26.360
But you should figure out
what's wrong with the setup

00:38:26.360 --> 00:38:28.730
there, because I think most
people are getting these.

00:38:28.730 --> 00:38:31.520
OK, and with that, we're
going to take a little break,

00:38:31.520 --> 00:38:34.240
and then we'll
continue on afterward.

00:38:34.240 --> 00:38:37.250
Let me know how this is--

00:38:37.250 --> 00:38:39.980
should I be speed
a little speedier

00:38:39.980 --> 00:38:44.600
about the little mini
breaks that we're taking,

00:38:44.600 --> 00:38:47.530
or is this good for you?

00:38:47.530 --> 00:38:48.920
Feedback is always--

00:38:48.920 --> 00:38:52.760
I'm trying to make this as
good as I can for all of you.

00:38:52.760 --> 00:38:55.880
OK, I think there's a mixture
of between people saying

00:38:55.880 --> 00:38:57.210
that these breaks are good.

00:38:57.210 --> 00:38:59.180
Someone says they're
a little overlong,

00:38:59.180 --> 00:39:02.450
so I'll try to tighten
them up a little.

00:39:02.450 --> 00:39:04.940
Some folks are saying what--

00:39:04.940 --> 00:39:09.290
more people should
be asking the TAs.

00:39:09.290 --> 00:39:11.630
I don't know how the TAs are
doing, in terms of their--

00:39:11.630 --> 00:39:13.490
I'll check with them
afterward-- how well

00:39:13.490 --> 00:39:16.540
this is going for them,
in terms of the questions.

00:39:16.540 --> 00:39:20.940
But I think some amount of
break is good so that we don't--

00:39:20.940 --> 00:39:23.312
so there's time to
be asking questions.

00:39:23.312 --> 00:39:25.520
Otherwise, what's the point
of having a live lecture?

00:39:30.470 --> 00:39:35.420
So we will start promptly
when this timer runs down.

00:39:35.420 --> 00:39:43.000
So be ready to go in
55 seconds from now.

00:39:50.170 --> 00:39:53.415
Just to confirm, to show the
decidability of the equivalence

00:39:53.415 --> 00:39:54.790
of two regular
expressions, do we

00:39:54.790 --> 00:39:57.332
need to show that we can use a
Turing machine to convert them

00:39:57.332 --> 00:39:58.345
to two DFAs first?

00:40:03.770 --> 00:40:06.680
If you want to test whether
two regular expressions are

00:40:06.680 --> 00:40:10.970
equivalent, you can
give any procedure

00:40:10.970 --> 00:40:14.370
for doing that
deciding you want.

00:40:14.370 --> 00:40:16.850
I'm just offering one
simple way to do it

00:40:16.850 --> 00:40:19.500
that takes advantage of
stuff we've already shown.

00:40:19.500 --> 00:40:21.170
But if you want
to dig down and do

00:40:21.170 --> 00:40:23.900
some analysis of those
regular expressions

00:40:23.900 --> 00:40:26.600
to show that they describe
the same language,

00:40:26.600 --> 00:40:28.940
they generate the same
language, be my guest.

00:40:28.940 --> 00:40:32.060
I think that's-- actually would
be complicated to do that that

00:40:32.060 --> 00:40:32.600
way.

00:40:32.600 --> 00:40:37.250
OK, so we're just about ready
to go here, so let's continue.

00:40:41.830 --> 00:40:43.990
And let me take
this timer off here.

00:40:47.560 --> 00:40:48.670
All right.

00:40:48.670 --> 00:40:51.460
Now, we are going
to talk a little

00:40:51.460 --> 00:40:53.660
about context-free grammars.

00:40:53.660 --> 00:40:56.720
So we talked about decision
problems for finite automata.

00:40:56.720 --> 00:40:58.405
Let's talk about
some for grammars.

00:41:01.137 --> 00:41:03.220
OK, now I'm going to give
us an analogous problem.

00:41:03.220 --> 00:41:05.110
I'm going to give you a--

00:41:05.110 --> 00:41:06.730
I'm calling it the
acceptance problem,

00:41:06.730 --> 00:41:09.100
but-- just for consistency
with everything else,

00:41:09.100 --> 00:41:11.030
but it's really the
generating problem.

00:41:11.030 --> 00:41:13.870
So I'm giving you a grammar--

00:41:13.870 --> 00:41:18.392
context-free grammar G and
a string that's in a string.

00:41:18.392 --> 00:41:20.350
And I want to know, is
it in the language of G?

00:41:20.350 --> 00:41:23.420
So does G generate w?

00:41:23.420 --> 00:41:26.870
I'm calling that
the ACFG problem.

00:41:26.870 --> 00:41:28.570
So that's going to
be a decidable again.

00:41:31.630 --> 00:41:34.450
These are getting slightly
harder as we're moving along,

00:41:34.450 --> 00:41:43.160
so I'm giving you a grammar and
a string, and I want to know,

00:41:43.160 --> 00:41:45.250
does the grammar
generate that string?

00:41:49.790 --> 00:41:54.740
Well, it's not totally
trivial to solve that.

00:41:54.740 --> 00:41:59.570
One thing you might try doing is
looking at all possible things,

00:41:59.570 --> 00:42:03.810
all possible derivations
from that grammar

00:42:03.810 --> 00:42:07.530
and see if any one
of them leads to w--

00:42:07.530 --> 00:42:10.750
leads you to generate w.

00:42:10.750 --> 00:42:15.740
Well, you have to be careful,
because as I've-- as we've

00:42:15.740 --> 00:42:21.200
shown in some of our examples,
you actually could have--

00:42:21.200 --> 00:42:23.960
because you're allowed
to have variables

00:42:23.960 --> 00:42:26.950
that can get converted
to empty string,

00:42:26.950 --> 00:42:31.030
you might have very long
intermediate strings being

00:42:31.030 --> 00:42:34.660
generated from a, grammar
which then ultimately give you

00:42:34.660 --> 00:42:39.072
a small string of terminals
that get generated,

00:42:39.072 --> 00:42:41.155
a small string in the
language that gets produced.

00:42:46.130 --> 00:42:49.280
You certainly don't want to
try every possible derivation,

00:42:49.280 --> 00:42:52.220
because there's infinitely
many different derivations--

00:42:52.220 --> 00:42:53.930
most of them
generating, of course,

00:42:53.930 --> 00:42:56.870
things that are irrelevant
to the string w.

00:42:56.870 --> 00:43:00.317
But you have to know
how to cut things off,

00:43:00.317 --> 00:43:02.400
and it's not immediately
obvious how you do that--

00:43:04.930 --> 00:43:11.853
unless you have done the
homework problems that I asked

00:43:11.853 --> 00:43:14.270
you to do, which I'm sure very
many of you have not done--

00:43:14.270 --> 00:43:17.480
the zero point X problems,
because they're--

00:43:17.480 --> 00:43:20.180
that's going to come
in handy right now.

00:43:20.180 --> 00:43:21.830
And so I'll help
you through that.

00:43:24.820 --> 00:43:28.900
Remember-- you should remember,
but you may not have looked

00:43:28.900 --> 00:43:30.160
at it--

00:43:30.160 --> 00:43:34.210
something called
Chomsky normal form,

00:43:34.210 --> 00:43:36.600
which is for
context-free grammars,

00:43:36.600 --> 00:43:40.360
but only allows the rules
to be of a special kind.

00:43:40.360 --> 00:43:42.290
And they have to look like this.

00:43:42.290 --> 00:43:45.738
They can be a variable
that goes to two variables,

00:43:45.738 --> 00:43:47.280
on the right-hand
side, or a variable

00:43:47.280 --> 00:43:48.900
that goes to a terminal.

00:43:48.900 --> 00:43:51.207
Those are the only kinds of
rules that you're allowed.

00:43:51.207 --> 00:43:53.040
This is a special case
for the empty string,

00:43:53.040 --> 00:43:56.040
but let's ignore that for--

00:43:56.040 --> 00:43:58.470
the start variable can also
work to the empty string,

00:43:58.470 --> 00:44:01.320
if you want to have a-- the
empty string in a language.

00:44:01.320 --> 00:44:03.060
But that's a special case.

00:44:03.060 --> 00:44:05.850
Let's ignore that.

00:44:05.850 --> 00:44:07.770
These are the only
two kinds of rules

00:44:07.770 --> 00:44:12.090
that you can have in a
Chomsky normal form grammar.

00:44:12.090 --> 00:44:16.235
Once you have a Chomsky
normal form grammar--

00:44:16.235 --> 00:44:17.860
well, first of all,
there's two things.

00:44:17.860 --> 00:44:19.360
First of all, you
can always convert

00:44:19.360 --> 00:44:23.490
any context-free grammar
into Chomsky normal form.

00:44:23.490 --> 00:44:26.310
So that's given in the textbook.

00:44:26.310 --> 00:44:28.650
You do the obvious thing.

00:44:28.650 --> 00:44:30.700
I'm not going to
spend time on it.

00:44:30.700 --> 00:44:31.950
And you don't have to know it.

00:44:31.950 --> 00:44:37.110
It's just a little bit tedious,
but it's straightforward

00:44:37.110 --> 00:44:41.185
and it's there,
if you're curious.

00:44:41.185 --> 00:44:42.810
But the second lemma's
the thing that's

00:44:42.810 --> 00:44:48.770
important to us, which is that,
if you have a grammar which

00:44:48.770 --> 00:44:53.330
is in Chomsky normal form and
a string that's generated,

00:44:53.330 --> 00:44:59.870
every derivation of that
string has exactly 2 times

00:44:59.870 --> 00:45:02.105
the length of the
string minus 1 steps.

00:45:04.850 --> 00:45:08.270
If you think about it, this is
a lemma-- very easy to prove.

00:45:08.270 --> 00:45:10.430
I think the homework
problem asks

00:45:10.430 --> 00:45:13.400
you to prove that in
the 0.2 or whatever

00:45:13.400 --> 00:45:15.620
it was in problem set 1--

00:45:15.620 --> 00:45:16.370
or problem set 2--

00:45:16.370 --> 00:45:17.078
I don't remember.

00:45:23.500 --> 00:45:26.630
Rules of this kind allow you
to make the string one longer,

00:45:26.630 --> 00:45:30.870
and rules of this kind allow
you to produce a new terminal

00:45:30.870 --> 00:45:31.370
symbol.

00:45:36.266 --> 00:45:39.860
If the length w is n, you're
going to have n minus 1

00:45:39.860 --> 00:45:40.820
of these and n of.

00:45:40.820 --> 00:45:46.440
Those that's why you
get 2n minus 1 steps.

00:45:46.440 --> 00:45:49.290
But the point is that I don't
really care exactly how many.

00:45:49.290 --> 00:45:51.060
It's just that we have a bound.

00:45:51.060 --> 00:45:53.250
And once you have
that bound, life

00:45:53.250 --> 00:45:57.270
is good from the point
of view of giving

00:45:57.270 --> 00:46:02.780
a Turing machine which is
going to decide this language--

00:46:02.780 --> 00:46:04.290
because here's the
Turing machine.

00:46:04.290 --> 00:46:05.248
What it's going to do--

00:46:05.248 --> 00:46:07.020
the first thing is
it's going to convert G

00:46:07.020 --> 00:46:10.330
into Chomsky normal form.

00:46:10.330 --> 00:46:12.690
That we assume we
know how to do.

00:46:12.690 --> 00:46:15.750
Now, we're going to try all
derivations, but only those

00:46:15.750 --> 00:46:19.320
of length 2--

00:46:19.320 --> 00:46:24.870
twice the length of
the string minus 1,

00:46:24.870 --> 00:46:28.440
because if any derivation
is going to generate w,

00:46:28.440 --> 00:46:33.990
it has to be this many steps,
now that we know the grammar

00:46:33.990 --> 00:46:36.770
is in Chomsky normal form.

00:46:36.770 --> 00:46:41.780
OK, so we have
converted this problem

00:46:41.780 --> 00:46:45.980
of one that might be a very
unboundedly lengthy problem

00:46:45.980 --> 00:46:48.710
and to one where it's going
to terminate after some fixed

00:46:48.710 --> 00:46:50.350
number of steps.

00:46:50.350 --> 00:46:54.160
And so therefore, we can
accept, if any of those

00:46:54.160 --> 00:46:57.000
generate w, and reject if not.

00:46:57.000 --> 00:46:59.700
OK?

00:46:59.700 --> 00:47:03.840
Before moving on, so this
answers the problem--

00:47:03.840 --> 00:47:09.620
shows that this language is
decidable, the ACFG language.

00:47:09.620 --> 00:47:11.090
So that's something that--

00:47:11.090 --> 00:47:13.198
make sure you understand.

00:47:15.950 --> 00:47:19.070
We're basically trying
old derivations of up to--

00:47:19.070 --> 00:47:21.050
of a certain length,
because that's

00:47:21.050 --> 00:47:24.330
all that's needed when the
grammar is in that form.

00:47:24.330 --> 00:47:30.000
Now we're going to use that
to prove a corollary, which

00:47:30.000 --> 00:47:33.390
is important for understanding
how everything fits together.

00:47:33.390 --> 00:47:39.240
And that corollary states that
every context-free language

00:47:39.240 --> 00:47:41.570
is a decidable language.

00:47:41.570 --> 00:47:43.490
Every context-free
language is decidable.

00:47:43.490 --> 00:47:45.990
Now, why does that
follow from this?

00:47:45.990 --> 00:47:52.550
Well, suppose you have
a context-free language.

00:47:52.550 --> 00:47:54.920
We know that
language is generated

00:47:54.920 --> 00:48:02.500
by some context-free grammar
G. That's what it means.

00:48:02.500 --> 00:48:07.500
So then you can take that
grammar G and you can build it

00:48:07.500 --> 00:48:08.680
into a Turing machine.

00:48:08.680 --> 00:48:16.590
So there's going to be a term
machine which is constructed

00:48:16.590 --> 00:48:20.940
with the knowledge of G.

00:48:20.940 --> 00:48:24.930
And that Turing machine
is going to take its w

00:48:24.930 --> 00:48:31.890
and run the ACFG algorithm
with w combined with a G that's

00:48:31.890 --> 00:48:33.580
already built into it.

00:48:33.580 --> 00:48:36.810
So it's just going to stick
that grammar G in front of w,

00:48:36.810 --> 00:48:40.900
and now we run the ACFG decider.

00:48:40.900 --> 00:48:43.600
It's going to say,
does degenerate w?

00:48:43.600 --> 00:48:49.870
Well, that's going to be
yes every time w is in A.

00:48:49.870 --> 00:48:53.140
And so this machine here
now is going to end up

00:48:53.140 --> 00:48:56.950
accepting every
string that's in A,

00:48:56.950 --> 00:49:00.760
because it's every
string that G generates.

00:49:00.760 --> 00:49:06.890
So that is, I think, what
I wanted to say about this.

00:49:06.890 --> 00:49:12.120
Now, I feel that this
corollary here throws

00:49:12.120 --> 00:49:14.730
a little bit of a curveball.

00:49:14.730 --> 00:49:18.210
And we can just
pause for a moment

00:49:18.210 --> 00:49:22.650
here just to make sure
you're understanding this.

00:49:28.910 --> 00:49:34.550
The tricky thing about
this corollary is--

00:49:34.550 --> 00:49:36.530
that I often get--

00:49:36.530 --> 00:49:38.420
a question I often get where--

00:49:38.420 --> 00:49:43.190
is when we start off with
a context-free language,

00:49:43.190 --> 00:49:44.990
who gives--

00:49:44.990 --> 00:49:46.220
how do we get G?

00:49:48.830 --> 00:49:54.758
Because we need G to build
a Turing machine M sub G. So

00:49:54.758 --> 00:49:56.300
we know A is a
context-free language,

00:49:56.300 --> 00:49:58.970
but how do we know what G is?

00:49:58.970 --> 00:50:06.800
Well, the point is that
we may not know what G is,

00:50:06.800 --> 00:50:11.210
but we know G exists, because
that's a definition of A

00:50:11.210 --> 00:50:14.540
being a context-free language.

00:50:14.540 --> 00:50:19.250
It must have a context-free
grammar, by definition.

00:50:19.250 --> 00:50:23.070
And so because G exists, I now
know my Turing machine, M sub

00:50:23.070 --> 00:50:25.030
G, exists.

00:50:25.030 --> 00:50:29.080
And that's enough to
know that A is decidable,

00:50:29.080 --> 00:50:32.190
because it has a
decider that exists.

00:50:32.190 --> 00:50:35.430
Now, if you're not going to
tell me the grammar for G,

00:50:35.430 --> 00:50:42.380
I'm not going to tell you the
Turing machine which decides A.

00:50:42.380 --> 00:50:44.660
But both of them exist.

00:50:44.660 --> 00:50:47.500
So if you tell me G, then I can
tell you the Turing machine.

00:50:50.240 --> 00:50:52.790
So it's a subtle,
tricky issue there.

00:50:52.790 --> 00:50:55.220
A certain little element
maybe of-- sometimes people

00:50:55.220 --> 00:50:57.170
call it non-constructive,
because we're just, in a sense,

00:50:57.170 --> 00:50:58.837
showing just that
something is existing.

00:51:02.250 --> 00:51:04.270
It does the job for
us, because it shows

00:51:04.270 --> 00:51:06.980
that A is a decidable language.

00:51:06.980 --> 00:51:09.402
OK, so not so many questions
here-- maybe the TAs

00:51:09.402 --> 00:51:10.110
are getting them.

00:51:10.110 --> 00:51:11.820
So let's move on.

00:51:11.820 --> 00:51:15.260
Here's another check-in.

00:51:15.260 --> 00:51:18.280
So now, can we conclude that A--

00:51:18.280 --> 00:51:21.730
instead of ACFG,
APDA is decidable?

00:51:36.608 --> 00:51:38.275
People are getting
this one pretty fast.

00:51:42.890 --> 00:51:53.990
Another 10 seconds--
three seconds--

00:51:53.990 --> 00:51:55.280
OK, going to shut it down--

00:51:57.880 --> 00:52:02.410
end polling, share results.

00:52:02.410 --> 00:52:02.910
Yeah.

00:52:08.010 --> 00:52:14.647
So this problem here
is APDA is decidable.

00:52:14.647 --> 00:52:16.980
I was almost wondering whether
or not to give this poll,

00:52:16.980 --> 00:52:20.160
because it has-- it's true for
the same reason as poll number

00:52:20.160 --> 00:52:23.835
1, because we know
how to convert PDAs--

00:52:23.835 --> 00:52:29.850
or we stated we can
convert PDAs to CFGs.

00:52:29.850 --> 00:52:31.842
And that conversion
has given in the book.

00:52:31.842 --> 00:52:33.300
We didn't do in
lecture, but I just

00:52:33.300 --> 00:52:34.770
stated you have
to know that fact,

00:52:34.770 --> 00:52:36.730
but not necessarily
know how to do it.

00:52:36.730 --> 00:52:37.590
That's OK.

00:52:37.590 --> 00:52:40.008
But the fact is true.

00:52:40.008 --> 00:52:41.550
The conversion is
in the book, and it

00:52:41.550 --> 00:52:43.420
could be implemented
on a Turing machine.

00:52:43.420 --> 00:52:47.580
So if you want to know whether
a PDA's language is empty,

00:52:47.580 --> 00:52:50.250
you convert it to a context-free
grammar and then use this

00:52:50.250 --> 00:52:52.560
procedure here to test
whether it's a language--

00:52:55.710 --> 00:52:58.710
oh, not empty-- I'm sorry.

00:52:58.710 --> 00:53:01.170
The acceptance problem--

00:53:01.170 --> 00:53:05.370
I just want to know, does
the PDA accept some input?

00:53:05.370 --> 00:53:06.490
I'm saying it wrong.

00:53:06.490 --> 00:53:09.120
So I want to know, does
the PDA accept some input?

00:53:09.120 --> 00:53:12.990
I convert that PDA to
a grammar, and then I

00:53:12.990 --> 00:53:15.330
see if the grammar generates
that input, because it's

00:53:15.330 --> 00:53:17.980
an equivalent grammar.

00:53:17.980 --> 00:53:22.030
So again, this is using the
fact that grammars and PDAs are

00:53:22.030 --> 00:53:25.640
equivalent and convertible
from one to another,

00:53:25.640 --> 00:53:27.460
just like regular
expressions and DFAs

00:53:27.460 --> 00:53:29.790
from the previous poll.

00:53:29.790 --> 00:53:32.150
So you need to be
comfortable with that,

00:53:32.150 --> 00:53:34.400
because we're going to not
even talk about it anymore.

00:53:34.400 --> 00:53:36.317
We're just going to be
treating those things--

00:53:36.317 --> 00:53:39.180
going back and forth between
them without sometimes

00:53:39.180 --> 00:53:41.490
even any comment.

00:53:41.490 --> 00:53:43.850
OK.

00:53:43.850 --> 00:53:47.130
So let's move on.

00:53:47.130 --> 00:53:49.440
Emptiness problem for CFGs--

00:53:49.440 --> 00:53:50.940
hopefully you're
getting comfortable

00:53:50.940 --> 00:53:53.790
with the terminology I'm using.

00:53:53.790 --> 00:53:57.810
So now the emptiness problem
for context-free grammars--

00:53:57.810 --> 00:53:59.520
I'm just going to
give you a grammar,

00:53:59.520 --> 00:54:03.430
and I want to know if
its language is empty.

00:54:03.430 --> 00:54:06.190
OK, so remember, we did
this for finite automata

00:54:06.190 --> 00:54:08.530
by testing a path.

00:54:08.530 --> 00:54:10.600
We don't really have paths here.

00:54:10.600 --> 00:54:12.810
You might think testing
paths and pushed automata.

00:54:12.810 --> 00:54:15.310
That's not going to really work,
because the stack is there.

00:54:15.310 --> 00:54:17.110
So how are we going
to do that test?

00:54:17.110 --> 00:54:20.470
Well, there's something
sort of like testing a path,

00:54:20.470 --> 00:54:24.080
just working with
the grammar itself,

00:54:24.080 --> 00:54:27.740
kind of working backwards
from the terminals now.

00:54:27.740 --> 00:54:31.910
I'll illustrate that here.

00:54:31.910 --> 00:54:37.310
Here's a very simple
grammar, and I want to know,

00:54:37.310 --> 00:54:40.460
does it generate any strings?

00:54:40.460 --> 00:54:42.920
Obviously, only care about
strings of terminals,

00:54:42.920 --> 00:54:45.850
because those are the things
that are in the language--

00:54:45.850 --> 00:54:51.160
so does this grammar generate
any strings of terminals?

00:54:51.160 --> 00:54:55.240
So way we're going to answer
that is by a marking procedure,

00:54:55.240 --> 00:54:58.690
but in a sense, we're going
to start from the terminals

00:54:58.690 --> 00:55:02.810
and work backwards to see if we
can get to the start variable.

00:55:02.810 --> 00:55:06.370
So first, we're going to mark
all the terminal symbols,

00:55:06.370 --> 00:55:09.160
and then we're going
to mark anything

00:55:09.160 --> 00:55:16.370
that goes to a string of
completely marked symbols,

00:55:16.370 --> 00:55:19.220
either terminals or variables--

00:55:19.220 --> 00:55:22.340
because anything that's
marked, we know, can derive

00:55:22.340 --> 00:55:23.420
a string of terminals.

00:55:23.420 --> 00:55:24.560
That's what it means.

00:55:24.560 --> 00:55:28.580
Anything that's blue can derive
a string of just terminals.

00:55:28.580 --> 00:55:30.170
And so now, if you
have a collection

00:55:30.170 --> 00:55:34.130
of those that are all
marked, they together

00:55:34.130 --> 00:55:39.180
can generate some string
of terminals together.

00:55:39.180 --> 00:55:41.610
And so then you can mark
the associated variable.

00:55:41.610 --> 00:55:43.310
So T goes to a.

00:55:43.310 --> 00:55:45.860
So that may be
oversimple, but we're

00:55:45.860 --> 00:55:49.310
going to mark T here
everywhere in the grammar.

00:55:49.310 --> 00:55:51.050
So all these T's are
going to get marked,

00:55:51.050 --> 00:55:56.430
because we know that T can
generate a string of terminals.

00:55:56.430 --> 00:55:59.640
Now let's take a
look at R. R is going

00:55:59.640 --> 00:56:03.540
to a string of symbols
that are all marked,

00:56:03.540 --> 00:56:06.565
and that means those symbols
can, in turn, generate

00:56:06.565 --> 00:56:07.440
strings of terminals.

00:56:07.440 --> 00:56:09.270
So we're going to mark R2.

00:56:09.270 --> 00:56:12.150
We can't yet mark S,
because we don't know yet

00:56:12.150 --> 00:56:15.150
whether S has some unmarked
thing that it goes to.

00:56:15.150 --> 00:56:16.830
So we don't know
yet whether S can

00:56:16.830 --> 00:56:18.150
generate a string of terminals.

00:56:18.150 --> 00:56:21.390
But R we know right now,
so we're going to mark R.

00:56:21.390 --> 00:56:23.820
But then now that gets
us to mark this R,

00:56:23.820 --> 00:56:27.500
and so then we can go
backwards and we can mark S.

00:56:27.500 --> 00:56:31.195
And we keep doing that until
there's nothing new to mark.

00:56:31.195 --> 00:56:32.570
And here we've
marked everything,

00:56:32.570 --> 00:56:34.490
so clearly there's
nothing more you can mark.

00:56:34.490 --> 00:56:37.460
But you might stop before
you've marked everything.

00:56:37.460 --> 00:56:42.890
And then you see whether you've
marked the start variable

00:56:42.890 --> 00:56:43.740
or not.

00:56:43.740 --> 00:56:48.700
And if you have, you know
the language is not empty.

00:56:48.700 --> 00:56:53.470
OK, so let's just go
through this in text.

00:56:53.470 --> 00:56:56.680
Mark all occurrences
of terminals in G, then

00:56:56.680 --> 00:56:58.690
repeat until no new
variables are marked.

00:56:58.690 --> 00:57:02.620
We mark all occurrences
of variables A,

00:57:02.620 --> 00:57:05.410
if A goes to a
string of symbols,

00:57:05.410 --> 00:57:08.755
and all of those symbols
were already marked,

00:57:08.755 --> 00:57:10.130
because those are
the things that

00:57:10.130 --> 00:57:14.830
already have been shown to
generate a string of terminals.

00:57:14.830 --> 00:57:17.290
And so now we're going to
reject if the start date--

00:57:17.290 --> 00:57:19.540
start variable's marked--
because that means that

00:57:19.540 --> 00:57:21.130
the language is not empty--

00:57:21.130 --> 00:57:24.020
and accept if it's not.

00:57:24.020 --> 00:57:24.520
OK?

00:57:34.210 --> 00:57:36.560
I'll take a couple of
quick questions here.

00:57:44.350 --> 00:57:51.170
OK, somebody asked whether--

00:57:51.170 --> 00:57:53.480
if I understand-- are the
regular languages also

00:57:53.480 --> 00:57:54.128
decidable?

00:57:54.128 --> 00:57:55.670
Well, remember, the
regular languages

00:57:55.670 --> 00:57:58.370
are context-free languages,
and the context-free languages

00:57:58.370 --> 00:58:00.650
are decidable, so yes,
the regular languages

00:58:00.650 --> 00:58:01.827
are decidable.

00:58:12.268 --> 00:58:14.310
Some of those are going
to be too long to answer,

00:58:14.310 --> 00:58:17.560
and they're trying to come up
with alternative solutions.

00:58:17.560 --> 00:58:20.880
So I think we're
going to move on.

00:58:20.880 --> 00:58:21.420
All right.

00:58:23.940 --> 00:58:27.130
Just like we did for
the finite automata,

00:58:27.130 --> 00:58:30.130
we talked about acceptance,
we talked about emptiness,

00:58:30.130 --> 00:58:33.400
we talked about equivalence.

00:58:33.400 --> 00:58:36.430
So how about the equivalence
problem for context-free

00:58:36.430 --> 00:58:38.050
grammars?

00:58:38.050 --> 00:58:41.860
I'm going to give you now
two context-free grammars,

00:58:41.860 --> 00:58:46.390
and I'd like to know, are
those two context-free grammars

00:58:46.390 --> 00:58:50.070
generating the same language?

00:58:50.070 --> 00:58:54.550
OK, so how might you
think about that?

00:58:54.550 --> 00:58:58.390
Well, one thing-- following some
of the ideas that we've already

00:58:58.390 --> 00:59:03.730
had, you could try feeding
strings into those grammars.

00:59:03.730 --> 00:59:07.270
You know how to test whether
those individual grammars can

00:59:07.270 --> 00:59:08.950
generate those strings,
so you can just

00:59:08.950 --> 00:59:13.300
try feeding strings
in to G and to H,

00:59:13.300 --> 00:59:16.870
and seeing whether those
grammars ever disagree

00:59:16.870 --> 00:59:18.550
or whether they
generate some string.

00:59:18.550 --> 00:59:21.400
Find some string that say
G generates, but H does not

00:59:21.400 --> 00:59:22.120
generate.

00:59:22.120 --> 00:59:25.240
And we can test that
string by string.

00:59:25.240 --> 00:59:29.760
Unfortunately, we got a
lot of strings to test.

00:59:29.760 --> 00:59:32.940
We would need to give
some bound if we were

00:59:32.940 --> 00:59:35.550
going to use that procedure--

00:59:35.550 --> 00:59:37.080
not clear what the bound is.

00:59:39.880 --> 00:59:48.520
Another idea might be to
use the closure construction

00:59:48.520 --> 00:59:50.860
that we had from before.

00:59:50.860 --> 00:59:53.290
So let's mull that over--

00:59:53.290 --> 00:59:55.360
whether that might work.

00:59:55.360 --> 01:00:04.950
But in fact, let me give
away the answer here.

01:00:04.950 --> 01:00:07.740
This language is not decidable.

01:00:07.740 --> 01:00:10.890
There's no algorithm out
there-- no Turing machine,

01:00:10.890 --> 01:00:12.760
but therefore no algorithm--

01:00:12.760 --> 01:00:16.920
which can take two grammars
and test whether they generate

01:00:16.920 --> 01:00:20.010
the same language or not--

01:00:20.010 --> 01:00:23.410
seems, at first, glance
kind of surprising.

01:00:23.410 --> 01:00:26.470
Such simple things as
context-free grammars can

01:00:26.470 --> 01:00:30.250
nonetheless be so complicated
that there's no procedure out

01:00:30.250 --> 01:00:33.163
there which can tell
whether the two--

01:00:33.163 --> 01:00:35.080
those two grammars
generate the same language.

01:00:35.080 --> 01:00:37.780
We will show that next week.

01:00:40.940 --> 01:00:44.420
A related problem, which is
related to your homework--

01:00:44.420 --> 01:00:48.950
this that's due on Thursday--

01:00:48.950 --> 01:00:53.820
is testing whether a
grammar is ambiguous.

01:00:53.820 --> 01:00:55.550
So given a grammar,
I'd like to know,

01:00:55.550 --> 01:01:00.080
is that grammar an
ambiguous grammar or not?

01:01:00.080 --> 01:01:04.700
Does it generate some
string in the language

01:01:04.700 --> 01:01:07.370
of that grammar in two
possibly different ways, two

01:01:07.370 --> 01:01:09.000
or more different ways?

01:01:09.000 --> 01:01:12.780
So is there some string
that can be generated

01:01:12.780 --> 01:01:16.390
with two different parts.

01:01:16.390 --> 01:01:20.460
So the problem with testing
whether grammar is ambiguous--

01:01:20.460 --> 01:01:22.490
not decidable.

01:01:22.490 --> 01:01:25.610
So I'm asking you to
do something hard,

01:01:25.610 --> 01:01:30.680
when you have to produce that
grammar which is unambiguous

01:01:30.680 --> 01:01:32.150
for that language.

01:01:32.150 --> 01:01:35.060
In general, testing
whether a grammar is

01:01:35.060 --> 01:01:37.880
ambiguous or is not
a decidable problem.

01:01:37.880 --> 01:01:44.930
Now, hopefully the grammar that
you'll produce to show that--

01:01:44.930 --> 01:01:47.960
that unambiguous grammar
for that language

01:01:47.960 --> 01:01:49.760
that I'm asking you
to produce is not

01:01:49.760 --> 01:01:53.900
going to require our graders to
solve some decidable problem,

01:01:53.900 --> 01:01:56.870
but it'll be clear based the
construction of that grammar

01:01:56.870 --> 01:01:59.060
why it's not ambiguous.

01:01:59.060 --> 01:02:02.120
So you'll have to hopefully
say some explanation

01:02:02.120 --> 01:02:03.680
of your thinking there.

01:02:06.505 --> 01:02:07.005
OK.

01:02:09.840 --> 01:02:13.890
And we will prove that the
problem of testing ambiguity

01:02:13.890 --> 01:02:15.060
is not decidable.

01:02:15.060 --> 01:02:19.510
That's going to be a homework
problem in problem set 3.

01:02:19.510 --> 01:02:21.390
OK.

01:02:21.390 --> 01:02:24.480
Last check-in here--
something that I alluded

01:02:24.480 --> 01:02:26.040
to, but didn't quite--

01:02:26.040 --> 01:02:28.050
didn't want to give away.

01:02:28.050 --> 01:02:31.170
Why not use the same
technique that we

01:02:31.170 --> 01:02:34.800
use to show equivalence
of DFAs is decidable,

01:02:34.800 --> 01:02:36.960
to show that equivalence
of context-free grammars

01:02:36.960 --> 01:02:37.620
is desirable?

01:02:37.620 --> 01:02:42.870
Obviously, something goes wrong
because EQCFG is not decidable.

01:02:42.870 --> 01:02:46.680
Why doesn't that same
technique just work?

01:02:46.680 --> 01:02:52.175
Well, what's the answer?

01:03:04.680 --> 01:03:05.910
Got a real race here--

01:03:11.740 --> 01:03:16.090
another 15 seconds-- this
one gives you something

01:03:16.090 --> 01:03:16.810
to mull over.

01:03:24.430 --> 01:03:25.210
All right.

01:03:25.210 --> 01:03:26.530
Let's end it.

01:03:26.530 --> 01:03:28.210
OK, you're good to go.

01:03:28.210 --> 01:03:30.500
At least click something.

01:03:30.500 --> 01:03:37.515
OK, ending polling,
sharing results--

01:03:37.515 --> 01:03:41.610
OK, bunch of you have thought,
well, CFGs are generators

01:03:41.610 --> 01:03:44.310
and DFAs are recognizers,
and that's the issue.

01:03:44.310 --> 01:03:52.410
Well, not really,
because we could test

01:03:52.410 --> 01:03:55.080
equivalence of
regular expressions--

01:03:55.080 --> 01:03:56.040
those are generators.

01:03:56.040 --> 01:03:57.930
It's nothing to do
with being a generator

01:03:57.930 --> 01:04:04.550
or not, because we can convert
regular expressions to DFAs

01:04:04.550 --> 01:04:07.130
and then test
equivalence for the DFAs,

01:04:07.130 --> 01:04:10.010
so that-- it's not really a
matter of being generated.

01:04:10.010 --> 01:04:12.150
That's not the issue.

01:04:12.150 --> 01:04:15.590
The issue is that we can't
follow the same construction

01:04:15.590 --> 01:04:18.440
that we did to show
EQDFA is decidable,

01:04:18.440 --> 01:04:22.310
because the context-free
languages are not closed under

01:04:22.310 --> 01:04:25.700
those operations we needed to
make that symmetric difference

01:04:25.700 --> 01:04:27.070
machine--

01:04:27.070 --> 01:04:29.840
if you remember how that worked.

01:04:29.840 --> 01:04:31.590
So they're not closed
under implementation

01:04:31.590 --> 01:04:33.007
and not closed
under intersection.

01:04:33.007 --> 01:04:35.730
We needed both in order
to build that machine

01:04:35.730 --> 01:04:39.120
C, which accepted
all the strings that

01:04:39.120 --> 01:04:42.250
are in the difference.

01:04:42.250 --> 01:04:43.600
OK?

01:04:43.600 --> 01:04:46.400
So let's continue on.

01:04:46.400 --> 01:04:48.892
Let's move now to
Turing machines.

01:04:48.892 --> 01:04:50.350
This is where stuff
is really going

01:04:50.350 --> 01:04:53.440
to start to get interesting--
hope it's been interesting

01:04:53.440 --> 01:04:57.320
all along, but maybe
even more interesting.

01:04:57.320 --> 01:05:00.340
So let's talk about
the acceptance problem

01:05:00.340 --> 01:05:03.460
for Turing machines, ATM.

01:05:03.460 --> 01:05:06.550
This language is going
to become an old friend,

01:05:06.550 --> 01:05:09.882
but we're just
getting to know it.

01:05:09.882 --> 01:05:10.840
So this is the problem.

01:05:10.840 --> 01:05:13.990
You're given a Turing
machine now, and an input,

01:05:13.990 --> 01:05:18.810
and I want to know, does
M accept that input?

01:05:18.810 --> 01:05:20.610
Does that Turing machine
accept its input?

01:05:23.270 --> 01:05:27.390
OK, so that's going to not be
a decidable problem either.

01:05:27.390 --> 01:05:29.780
So we've shifted gears from
a bunch of decidable things

01:05:29.780 --> 01:05:32.820
to a bunch of
undecidable things.

01:05:32.820 --> 01:05:34.730
So this is not a
decidable language.

01:05:34.730 --> 01:05:37.317
We will prove that on Thursday.

01:05:37.317 --> 01:05:39.650
That's going to be the whole
point of Thursday's lecture

01:05:39.650 --> 01:05:42.530
is proving the ATM is decidable.

01:05:42.530 --> 01:05:44.600
And that's going to be
really a jumping off point

01:05:44.600 --> 01:05:48.240
for showing other
problems are decidable.

01:05:48.240 --> 01:05:51.540
So that's going to be our
first proof of decidability.

01:05:54.240 --> 01:05:58.860
But we do know that
ATM is recognizable,

01:05:58.860 --> 01:06:04.230
and that's worth understanding--

01:06:04.230 --> 01:06:06.540
for multiple reasons,
but for one thing,

01:06:06.540 --> 01:06:09.000
it's going to give us an
example of a problem which

01:06:09.000 --> 01:06:11.460
we know is recognizable,
but not decidable,

01:06:11.460 --> 01:06:14.010
as we'll prove undecidability.

01:06:14.010 --> 01:06:23.610
But it's also, I think,
of historical importance,

01:06:23.610 --> 01:06:26.100
this algorithm for showing--

01:06:26.100 --> 01:06:26.832
recognizable.

01:06:26.832 --> 01:06:28.290
So let's go through
that algorithm.

01:06:28.290 --> 01:06:32.470
It's very simple, sort of
doing the obvious thing.

01:06:32.470 --> 01:06:33.720
The following Turing machine--

01:06:33.720 --> 01:06:37.920
I'm going to call it U, for
a reason that I'll make clear

01:06:37.920 --> 01:06:38.880
in a second.

01:06:38.880 --> 01:06:41.910
That's going to be a
recognizer for ATM.

01:06:41.910 --> 01:06:46.990
So it takes as
input an M and a w,

01:06:46.990 --> 01:06:50.830
and it's just going to simulate
M on w, pretty much the way

01:06:50.830 --> 01:06:57.580
the algorithm the
decider for ADFA work.

01:06:57.580 --> 01:07:00.160
But now the machine--

01:07:00.160 --> 01:07:02.410
instead of being a DFA,
it's a Turing machine,

01:07:02.410 --> 01:07:05.470
and the Turing machine
might go forever.

01:07:05.470 --> 01:07:08.520
And so the simulation
may not stop.

01:07:08.520 --> 01:07:11.100
And that's the key difference,
which makes it from a decider

01:07:11.100 --> 01:07:12.210
into a recognizer.

01:07:15.457 --> 01:07:17.040
So you're going to
be simulating, just

01:07:17.040 --> 01:07:22.650
keeping track of the tape of M,
the current state of M, where--

01:07:22.650 --> 01:07:28.410
and proceeding to modify
the tape as M modifies it.

01:07:28.410 --> 01:07:32.980
And then, if M enters
an accept state,

01:07:32.980 --> 01:07:34.690
then you know M has
accepted its input,

01:07:34.690 --> 01:07:36.400
so U also will enter
an accept state.

01:07:36.400 --> 01:07:39.520
So the machine U
enters the accept state

01:07:39.520 --> 01:07:41.770
if M observes during
the simulation

01:07:41.770 --> 01:07:45.020
that M enters an accept state.

01:07:45.020 --> 01:07:49.800
Furthermore, if an M
enters a reject state,

01:07:49.800 --> 01:07:54.500
then U also enters
a reject state.

01:07:54.500 --> 01:07:55.670
OK?

01:07:55.670 --> 01:07:57.920
Now I'm going to say
something beyond that, which

01:07:57.920 --> 01:08:07.030
I want you to pay attention to,
which is the kind of thing I

01:08:07.030 --> 01:08:10.640
do see sometimes people saying.

01:08:10.640 --> 01:08:13.820
We want U to reject
if M never halts.

01:08:16.569 --> 01:08:20.109
That's also-- seems
like what we want,

01:08:20.109 --> 01:08:23.830
because if it never halts,
then M is rejecting by looping,

01:08:23.830 --> 01:08:26.779
so you should also reject.

01:08:26.779 --> 01:08:29.060
But I don't like that.

01:08:29.060 --> 01:08:33.770
I don't like that line here,
step 4 of the Turing machine,

01:08:33.770 --> 01:08:37.010
because there's no way for a
Turing machine to determine--

01:08:37.010 --> 01:08:40.140
or at least as we--
no obvious way--

01:08:40.140 --> 01:08:41.930
and in fact, there
will not be any way,

01:08:41.930 --> 01:08:44.779
but certainly, at this
point, no obvious way for M

01:08:44.779 --> 01:08:46.470
to even tell--

01:08:46.470 --> 01:08:50.727
for U you to tell whether
M is halting or not.

01:08:50.727 --> 01:08:52.310
Well, certainly you
can tell that it's

01:08:52.310 --> 01:08:53.359
to say it never halts.

01:08:53.359 --> 01:08:56.569
How can you make
that determination?

01:08:56.569 --> 01:09:01.460
If I saw this on a
solution, either on an exam

01:09:01.460 --> 01:09:04.310
or a homework, I
would mark you off.

01:09:04.310 --> 01:09:05.779
This is no good.

01:09:05.779 --> 01:09:09.149
It's not illegal to
Turing machine action.

01:09:09.149 --> 01:09:17.300
If M does not hold on w,
then you should reject.

01:09:17.300 --> 01:09:18.500
That is correct.

01:09:18.500 --> 01:09:23.750
And you can make that reasoning
external to the algorithm of U,

01:09:23.750 --> 01:09:26.569
but U is going to end up
rejecting, because it never

01:09:26.569 --> 01:09:28.569
holds either.

01:09:28.569 --> 01:09:33.399
It never actually knows that
M is rejecting w in that case,

01:09:33.399 --> 01:09:34.899
if M is rejecting by looping.

01:09:34.899 --> 01:09:37.930
It's just blindly going along
and doing the simulation of M

01:09:37.930 --> 01:09:40.200
on w--

01:09:40.200 --> 01:09:41.250
and will end up halting--

01:09:41.250 --> 01:09:43.925
rejecting by looping, if
M is rejecting by looping.

01:09:43.925 --> 01:09:45.300
But that's something
that you can

01:09:45.300 --> 01:09:48.609
argue if you need
to make a proof

01:09:48.609 --> 01:09:50.810
or make some sort of
reasoning about the machine,

01:09:50.810 --> 01:09:52.893
but it's not part of the
algorithm of the machine.

01:09:56.310 --> 01:09:56.850
OK.

01:09:56.850 --> 01:09:59.610
Now, what's, I think, from
a historical standpoint,

01:09:59.610 --> 01:10:01.320
that's interesting
about this machine U

01:10:01.320 --> 01:10:04.740
and why I'm calling it U
is because this appeared--

01:10:04.740 --> 01:10:09.450
this machine U appeared
in Turing's original paper

01:10:09.450 --> 01:10:11.130
where he laid out
Turing machines.

01:10:11.130 --> 01:10:12.600
He didn't call them Turing
machines, by the way.

01:10:12.600 --> 01:10:14.110
He called them
computing machines.

01:10:14.110 --> 01:10:17.700
People afterward called
them Turing machines.

01:10:17.700 --> 01:10:21.557
But Turing called this the
universal computing machine.

01:10:21.557 --> 01:10:22.390
That's his language.

01:10:22.390 --> 01:10:23.890
Actually, I just
looked at the paper

01:10:23.890 --> 01:10:27.360
yesterday just to
refresh my memory of it.

01:10:27.360 --> 01:10:30.450
And he gives the description
of the operation of U

01:10:30.450 --> 01:10:34.248
in gory detail, with all of
the transitions and the states.

01:10:34.248 --> 01:10:35.790
He nails the whole
thing down-- takes

01:10:35.790 --> 01:10:38.780
pages, and pages, and pages.

01:10:38.780 --> 01:10:42.260
So he it gives it there.

01:10:42.260 --> 01:10:46.880
So this is the original
universal computing machine,

01:10:46.880 --> 01:10:49.490
universal Turing machine.

01:10:49.490 --> 01:10:51.770
It's more than just
an idle curiosity

01:10:51.770 --> 01:10:53.540
that this appeared
in Turing's paper,

01:10:53.540 --> 01:10:56.180
because this actually
turned out to be profoundly

01:10:56.180 --> 01:11:01.070
influential in computer
science, because it really

01:11:01.070 --> 01:11:04.430
was the first example of
a machine that operated

01:11:04.430 --> 01:11:08.230
based on a stored program.

01:11:08.230 --> 01:11:10.390
It really was a
revolutionary idea.

01:11:10.390 --> 01:11:12.370
In those days, if
you wanted to make

01:11:12.370 --> 01:11:14.480
a machine that did
something different,

01:11:14.480 --> 01:11:15.460
you had to wire the--

01:11:15.460 --> 01:11:17.730
rewire the machine.

01:11:17.730 --> 01:11:22.860
But here's a machine that
operated based on instructions.

01:11:22.860 --> 01:11:27.110
And instructions, in a sense,
are no different than the data.

01:11:27.110 --> 01:11:29.740
So this is what's been--

01:11:29.740 --> 01:11:32.050
come to be known as the
von Neumann architecture,

01:11:32.050 --> 01:11:35.260
but von Neumann himself gave
credit to Turing machine

01:11:35.260 --> 01:11:38.470
for having inspired
him to think of this.

01:11:38.470 --> 01:11:40.480
And some people argue
that it's really--

01:11:40.480 --> 01:11:41.800
calling it the von Neumann--

01:11:41.800 --> 01:11:43.900
bunch of people came
up with this concept

01:11:43.900 --> 01:11:46.360
around the same time,
maybe other people too.

01:11:46.360 --> 01:11:50.080
There's Babbage and so
on, and others who--

01:11:50.080 --> 01:11:54.190
Ada Lovelace-- also who came
up with notions of programming,

01:11:54.190 --> 01:11:57.700
but I think it's a little
different than this,

01:11:57.700 --> 01:11:58.900
in concept.

01:11:58.900 --> 01:12:02.680
But anyway, this nevertheless
played an important role

01:12:02.680 --> 01:12:04.480
in the history of the subject.

01:12:04.480 --> 01:12:06.250
So with that, I think
we're out of time.

01:12:06.250 --> 01:12:10.810
I'm going to quickly
review where we've been.

01:12:10.810 --> 01:12:12.490
So we just showed
the decidability

01:12:12.490 --> 01:12:14.960
of various problems.

01:12:14.960 --> 01:12:19.180
These are all languages that
we showed are decidable.

01:12:19.180 --> 01:12:21.970
We showed that ATM is
Turing-recognizable,

01:12:21.970 --> 01:12:25.460
and I think that was
all we had for today.

01:12:25.460 --> 01:12:31.150
So I will stop right here.

01:12:31.150 --> 01:12:33.100
I will stick around and
take a few questions,

01:12:33.100 --> 01:12:35.650
and our TAs can take a few
questions, if you want,

01:12:35.650 --> 01:12:37.750
by chat.

01:12:37.750 --> 01:12:39.620
And then I also have
my office hours,

01:12:39.620 --> 01:12:41.465
which will start in
like five minutes or so,

01:12:41.465 --> 01:12:43.090
once I get everything
set up on my end.

01:12:46.010 --> 01:12:51.400
OK, somebody wanted me to
review this point here,

01:12:51.400 --> 01:12:52.440
which I'm happy to do.

01:12:59.118 --> 01:13:03.580
This code here that I'm
describing in English

01:13:03.580 --> 01:13:06.190
needs to be something
that you can

01:13:06.190 --> 01:13:11.800
implement on a Turing machine.

01:13:11.800 --> 01:13:15.910
We're never going to go
through the effort of building

01:13:15.910 --> 01:13:19.330
the transition functions,
and the states, and so on,

01:13:19.330 --> 01:13:23.500
but we need to be sure that
we could, if we had to.

01:13:23.500 --> 01:13:31.120
And how could you make a
Turing machine do the test

01:13:31.120 --> 01:13:33.610
that M doesn't halt?

01:13:33.610 --> 01:13:36.350
That's something we
don't know how to do.

01:13:36.350 --> 01:13:39.250
I can see if M halts.

01:13:39.250 --> 01:13:41.540
During the simulation,
I can see that M

01:13:41.540 --> 01:13:45.400
has entered the Q reject
state or the Q accept state,

01:13:45.400 --> 01:13:50.230
so I can tell while I'm
simulating that it has halted.

01:13:50.230 --> 01:13:53.470
But how would the
machine, or how

01:13:53.470 --> 01:13:56.870
would you know that M is now--

01:13:56.870 --> 01:14:01.480
someone says, well,
do x if M never holds.

01:14:01.480 --> 01:14:04.930
Well, how do you know M--
how can you do the test

01:14:04.930 --> 01:14:06.040
that M is not halting?

01:14:09.570 --> 01:14:11.300
There's no obvious
way to do that.

01:14:11.300 --> 01:14:13.170
In fact, there is
no way to do that.

01:14:13.170 --> 01:14:15.360
But as it stands
right now, the proof

01:14:15.360 --> 01:14:21.520
would be on you to show how to
implement that on a machine,

01:14:21.520 --> 01:14:23.740
and there's just no
obvious way to do that.

01:14:23.740 --> 01:14:26.970
So I think that's why you
should only put down things

01:14:26.970 --> 01:14:30.510
here which you're sure
you could implement,

01:14:30.510 --> 01:14:32.170
even if it might
take a long time.

01:14:32.170 --> 01:14:34.890
So you don't have to worry
about how long it would take,

01:14:34.890 --> 01:14:37.590
but you have to put
things down that you

01:14:37.590 --> 01:14:42.040
are sure you could at least
implement in principle.

01:14:42.040 --> 01:14:48.320
OK, so someone has asked me
about the equivalence problem

01:14:48.320 --> 01:14:52.700
for context-free grammars
being unsolvable.

01:14:52.700 --> 01:14:56.820
Why couldn't the machine be
a human level system of logic

01:14:56.820 --> 01:15:01.100
so that the computer could
logically deduce whether or not

01:15:01.100 --> 01:15:02.238
it was decidable?

01:15:08.950 --> 01:15:11.950
We're taking a turn
into the subject

01:15:11.950 --> 01:15:16.900
of mathematical logic, which is
supposed to formalize reasoning

01:15:16.900 --> 01:15:17.560
in a way.

01:15:21.630 --> 01:15:24.330
In the end, what it
really has come down to--

01:15:24.330 --> 01:15:29.910
that there are
certain grammars which

01:15:29.910 --> 01:15:38.030
are equivalent to one
another, but there's not

01:15:38.030 --> 01:15:40.400
going to be any way
to prove that they're

01:15:40.400 --> 01:15:42.170
equivalent in any
reasonable system.

01:15:45.870 --> 01:15:48.300
Inequivalence you
can always prove.

01:15:48.300 --> 01:15:50.850
You can exhibit a
string that one-- you

01:15:50.850 --> 01:15:53.370
can show that this
grammar's generating it,

01:15:53.370 --> 01:15:55.410
this grammar's not generating.

01:15:55.410 --> 01:15:56.680
This other one is not.

01:15:56.680 --> 01:16:00.792
So inequivalence you can
always prove, but equivalence--

01:16:00.792 --> 01:16:03.000
there are going to be certain
pairs of grammars which

01:16:03.000 --> 01:16:05.820
are going to be
beyond the capability

01:16:05.820 --> 01:16:07.800
of any reasonable
formal system to be

01:16:07.800 --> 01:16:09.750
able to prove that
they're equivalent,

01:16:09.750 --> 01:16:11.340
because you can even convert--

01:16:11.340 --> 01:16:13.230
make those grammars
into something

01:16:13.230 --> 01:16:16.630
which talk about the
system itself, ultimately.

01:16:16.630 --> 01:16:19.480
You're going to end up with a
Russell paradox kind of thing.

01:16:19.480 --> 01:16:22.270
That's maybe going beyond
more than you want to know,

01:16:22.270 --> 01:16:24.520
and I'm happy to talk
about it offline.

01:16:24.520 --> 01:16:28.540
But there's just no way to make
a Turing machine which is going

01:16:28.540 --> 01:16:31.930
to implement human reasoning,
and then get the right answer

01:16:31.930 --> 01:16:34.700
on all pairs of grammars--
just cannot be done.

01:16:34.700 --> 01:16:35.200
Goodbye.

01:16:35.200 --> 01:16:39.390
I'm going to shut
down the meeting now.