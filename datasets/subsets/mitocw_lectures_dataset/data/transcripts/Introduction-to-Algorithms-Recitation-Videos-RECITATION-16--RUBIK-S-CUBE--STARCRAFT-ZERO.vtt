WEBVTT

00:00:00.060 --> 00:00:01.770
The following
content is provided

00:00:01.770 --> 00:00:04.010
under a Creative
Commons license.

00:00:04.010 --> 00:00:06.860
Your support will help MIT
OpenCourseWare continue

00:00:06.860 --> 00:00:10.720
to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.330
To make a donation or
view additional materials

00:00:13.330 --> 00:00:17.226
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.226 --> 00:00:17.851
at ocw.mit.edu.

00:00:20.907 --> 00:00:21.490
PROFESSOR: OK.

00:00:21.490 --> 00:00:25.020
So who's going lecture?

00:00:25.020 --> 00:00:27.290
Good.

00:00:27.290 --> 00:00:29.905
Does everything makes sense?

00:00:29.905 --> 00:00:31.252
AUDIENCE: Mostly.

00:00:31.252 --> 00:00:33.710
PROFESSOR: That's good, because
we're going to do problems.

00:00:33.710 --> 00:00:34.460
AUDIENCE: Awesome.

00:00:34.460 --> 00:00:37.240
PROFESSOR: So, what I want
to talk about is, first,

00:00:37.240 --> 00:00:39.750
there's a subtlety in the
Rubik's cube problem, which I'm

00:00:39.750 --> 00:00:42.462
guessing nobody has seen yet,
but we're going to talk about

00:00:42.462 --> 00:00:44.920
it anyway, because otherwise
you'll trip on it while you're

00:00:44.920 --> 00:00:46.340
doing the problem.

00:00:46.340 --> 00:00:48.780
And then we're going to
talk about one or maybe two

00:00:48.780 --> 00:00:49.380
problems.

00:00:49.380 --> 00:00:51.474
And I'm excited about
the problem titled,

00:00:51.474 --> 00:00:53.140
"there's StarCraft
and counter strikes,"

00:00:53.140 --> 00:00:55.050
so, let's hope we get to them.

00:00:57.960 --> 00:01:00.600
AUDIENCE: I'm curious, did you
write this week's problem set?

00:01:00.600 --> 00:01:02.630
Because there's some
Chinese in there.

00:01:02.630 --> 00:01:03.260
PROFESSOR: No.

00:01:03.260 --> 00:01:03.968
AUDIENCE: Oh, OK.

00:01:03.968 --> 00:01:06.580
PROFESSOR: No,
someone else wrote it.

00:01:06.580 --> 00:01:08.675
I suggested putting
that in there, though.

00:01:11.675 --> 00:01:13.857
AUDIENCE: You had an
awesome internship, right?

00:01:13.857 --> 00:01:14.811
[INAUDIBLE]

00:01:14.811 --> 00:01:17.767
AUDIENCE: Wait, did you make all
the AMD [INAUDIBLE] questions?

00:01:17.767 --> 00:01:18.600
PROFESSOR:Of course.

00:01:18.600 --> 00:01:19.266
That's my stuff.

00:01:22.531 --> 00:01:23.030
OK.

00:01:23.030 --> 00:01:25.280
So Rubik's cubes.

00:01:25.280 --> 00:01:27.319
Did everyone see a 2
by 2 by 2 Rubik's cube?

00:01:27.319 --> 00:01:28.860
You guys are going
to lecture, right?

00:01:28.860 --> 00:01:29.700
You have one.

00:01:29.700 --> 00:01:31.240
Yeah.

00:01:31.240 --> 00:01:34.210
Did you guys see Eric's
2 by 2 by 2 Rubik's cube?

00:01:36.830 --> 00:01:37.960
It looks sort of like this.

00:01:48.140 --> 00:01:51.230
All right, so big
Rubik's cube has how many

00:01:51.230 --> 00:01:53.319
small cubelets in it?

00:01:53.319 --> 00:01:53.860
AUDIENCE: 80.

00:01:53.860 --> 00:01:55.820
AUDIENCE: 80.

00:01:55.820 --> 00:01:58.270
AUDIENCE: I like cubelets
better than cubies.

00:01:58.270 --> 00:01:59.687
Cubies is hard to say.

00:01:59.687 --> 00:02:01.270
PROFESSOR: Yeah, I
would say cubicles.

00:02:01.270 --> 00:02:03.260
So let's go for--
let's try cubelets

00:02:03.260 --> 00:02:05.410
and see how this works.

00:02:05.410 --> 00:02:06.410
OK.

00:02:06.410 --> 00:02:11.750
So each cubelet has six
faces, but three faces

00:02:11.750 --> 00:02:13.460
are always facing inwards.

00:02:13.460 --> 00:02:15.960
They're always attached
to the center of the cube.

00:02:15.960 --> 00:02:17.810
So we don't care about them.

00:02:17.810 --> 00:02:19.760
We only care about
the other three faces.

00:02:19.760 --> 00:02:22.060
So if you have a
plastic Rubik's cube.

00:02:22.060 --> 00:02:27.360
Say this is a plastic--
This is a plastic cube.

00:02:27.360 --> 00:02:30.870
Then you're going to have
eight plastic cubelets.

00:02:30.870 --> 00:02:32.722
Each cubelet has
three colored faces

00:02:32.722 --> 00:02:34.430
and three faces that
we don't care about.

00:02:38.440 --> 00:02:42.020
So how many total plastic
faces in a cubelet, sorry,

00:02:42.020 --> 00:02:44.728
plastic cube?

00:02:44.728 --> 00:02:46.144
AUDIENCE: Twenty-four.
[INAUDIBLE]

00:02:50.975 --> 00:02:51.850
PROFESSOR: All right.

00:02:51.850 --> 00:02:54.010
Now let's play with
an imaginary cube.

00:02:54.010 --> 00:02:56.224
And I call this
a wireframe cube,

00:02:56.224 --> 00:02:57.390
because I draw it like this.

00:03:11.800 --> 00:03:14.460
So, here pretend you have the
skeleton of a Rubik's cube,

00:03:14.460 --> 00:03:17.510
made out of wires or out
of wood or something.

00:03:17.510 --> 00:03:22.130
So it's basically a small sheet
of wood, small piece of wood,

00:03:22.130 --> 00:03:24.200
small sheet of wood,
so on and so forth.

00:03:24.200 --> 00:03:28.310
And so this doesn't
have any colors in it,

00:03:28.310 --> 00:03:32.700
but it's the right shape
and sort of the right look.

00:03:32.700 --> 00:03:35.440
So the way you would build
the configuration is,

00:03:35.440 --> 00:03:41.050
you take 24 plastic faces that
you get from a plastic cube,

00:03:41.050 --> 00:03:45.590
and you paste them one
by one onto the faces

00:03:45.590 --> 00:03:47.430
of a wireframe cube.

00:03:47.430 --> 00:03:50.200
And they claim that this
can build any configuration

00:03:50.200 --> 00:03:53.570
that you can think about.

00:03:53.570 --> 00:03:56.110
If you look at a cube, after
no matter how many moves

00:03:56.110 --> 00:03:58.750
you've done to it,
it's going to have

00:03:58.750 --> 00:04:01.420
some-- it's going to have
the faces somewhere, right?

00:04:01.420 --> 00:04:03.275
So you can take the
faces and face them

00:04:03.275 --> 00:04:05.250
where they belong
and there you go.

00:04:05.250 --> 00:04:07.560
You have a real cube
built out of a wireframe

00:04:07.560 --> 00:04:08.570
and plastic faces.

00:04:16.810 --> 00:04:19.630
How many wireframe
faces there are?

00:04:19.630 --> 00:04:21.864
Please don't get this wrong.

00:04:21.864 --> 00:04:22.780
AUDIENCE: Twenty-four.

00:04:22.780 --> 00:04:25.107
PROFESSOR: OK.

00:04:25.107 --> 00:04:26.732
AUDIENCE: There are
some configurations

00:04:26.732 --> 00:04:28.807
that aren't possible, right?

00:04:28.807 --> 00:04:29.390
PROFESSOR: OK.

00:04:29.390 --> 00:04:31.400
There are some configurations
that aren't possible,

00:04:31.400 --> 00:04:32.590
and that is very good news.

00:04:32.590 --> 00:04:33.640
We'll get to that later.

00:04:41.830 --> 00:04:46.060
Let's see how the code
talks about these faces.

00:04:46.060 --> 00:04:49.720
So suppose we have a cubelet
that has these faces.

00:04:49.720 --> 00:04:56.740
Front faces yellow, this face is
blue, and this face is orange.

00:04:56.740 --> 00:05:01.580
This facing code is called--
so this yellow face here

00:05:01.580 --> 00:05:06.520
is called y o b.

00:05:06.520 --> 00:05:08.972
So y is yellow, that's
the yellow face,

00:05:08.972 --> 00:05:11.110
and is the yellow
facing the cubelet that

00:05:11.110 --> 00:05:14.880
has a yellow face, an orange
face, and a blue face.

00:05:14.880 --> 00:05:17.010
Fortunately, there
aren't two cubelets

00:05:17.010 --> 00:05:20.180
that have the same face
color, so this is good enough

00:05:20.180 --> 00:05:22.599
to distinguish
between all of them.

00:05:22.599 --> 00:05:24.390
Let's see if you guys
are paying attention.

00:05:24.390 --> 00:05:27.330
How would I call this face?

00:05:32.674 --> 00:05:33.340
AUDIENCE: o y b?

00:05:37.914 --> 00:05:38.580
PROFESSOR: Yeah.

00:05:38.580 --> 00:05:43.670
Either that or o b y, whichever
one the code happens to use.

00:05:43.670 --> 00:05:45.810
So the principal is,
these are the colors

00:05:45.810 --> 00:05:49.960
and the first one is the
face that you're pointing at.

00:05:49.960 --> 00:05:53.310
So there are 24
plastic faces, so there

00:05:53.310 --> 00:05:55.960
are 24 names for
these plastic faces.

00:05:55.960 --> 00:05:57.825
Let's see how we name
the wireframe faces.

00:06:01.650 --> 00:06:07.570
If I take this face-- so
we don't have colors here,

00:06:07.570 --> 00:06:08.450
they're all the same.

00:06:08.450 --> 00:06:11.550
So instead we care
about their position.

00:06:11.550 --> 00:06:14.650
A cube has a front
and a back, right?

00:06:14.650 --> 00:06:18.770
This cubelet is on the
front somewhere, right?

00:06:18.770 --> 00:06:23.660
So I'm going to have front
somewhere in the name.

00:06:23.660 --> 00:06:29.610
It has an upper face
and a lower face.

00:06:29.610 --> 00:06:32.034
Is this going to
be upper or lower?

00:06:32.034 --> 00:06:34.990
AUDIENCE: Upper.

00:06:34.990 --> 00:06:36.816
PROFESSOR: And
the left or right?

00:06:36.816 --> 00:06:37.524
PROFESSOR: Right.

00:06:40.870 --> 00:06:41.570
PROFESSOR: OK.

00:06:41.570 --> 00:06:46.702
So front upper right,
which face am I looking at?

00:06:46.702 --> 00:06:47.777
AUDIENCE: The front.

00:06:47.777 --> 00:06:48.360
PROFESSOR: OK.

00:06:51.330 --> 00:06:53.630
f u r, fur.

00:06:53.630 --> 00:06:55.440
How about this space?

00:06:59.524 --> 00:07:00.440
AUDIENCE: [INAUDIBLE].

00:07:04.940 --> 00:07:07.604
PROFESSOR: So far so good?

00:07:07.604 --> 00:07:09.490
Or it could be r u f, right?

00:07:09.490 --> 00:07:10.908
PROFESSOR: Or it could be r u f.

00:07:10.908 --> 00:07:11.824
AUDIENCE: [INAUDIBLE].

00:07:17.770 --> 00:07:20.322
PROFESSOR: I really don't know
what it means, I'm behind.

00:07:20.322 --> 00:07:21.405
AUDIENCE: Ruff like a dog?

00:07:21.405 --> 00:07:22.830
It has fur.

00:07:22.830 --> 00:07:23.100
PROFESSOR: Oh, ruff ruff ruff.

00:07:23.100 --> 00:07:23.600
OK.

00:07:23.600 --> 00:07:24.500
That's not too bad.

00:07:24.500 --> 00:07:25.833
I was afraid of something worse.

00:07:25.833 --> 00:07:26.970
OK.

00:07:26.970 --> 00:07:28.270
That's cool.

00:07:28.270 --> 00:07:32.860
So a configuration
will take plastic faces

00:07:32.860 --> 00:07:34.890
and face them onto
the wireframe faces.

00:07:37.460 --> 00:07:40.730
So a configuration is going
to be an array of 24 elements.

00:07:47.820 --> 00:07:51.660
And the first element is going
to tell me which plastic face

00:07:51.660 --> 00:07:57.270
ends up in-- Let's say if
you are the second one,

00:07:57.270 --> 00:08:03.607
says which plastic
face ends up in r u f,

00:08:03.607 --> 00:08:06.210
and the third one, let's
assume it's the space.

00:08:09.204 --> 00:08:10.035
AUDIENCE: Ruff.

00:08:10.035 --> 00:08:10.701
PROFESSOR: Ruff.

00:08:14.200 --> 00:08:16.120
And there are 21
more faces, right?

00:08:16.120 --> 00:08:17.960
So each face has
a number from zero

00:08:17.960 --> 00:08:22.990
to 23, because we're in Python,
so we like zero-based indexing.

00:08:22.990 --> 00:08:29.050
And 24 elements in the
array, 24 plastic faces.

00:08:29.050 --> 00:08:32.799
Which plastic face
goes into f u r?

00:08:32.799 --> 00:08:37.970
Assuming this cubelet here--
see, I said cubicle anyway.

00:08:37.970 --> 00:08:41.945
This cubelet here goes here
in exactly this configuration.

00:08:45.350 --> 00:08:47.576
AUDIENCE: [INAUDIBLE].

00:08:47.576 --> 00:08:49.770
PROFESSOR: Yeah.

00:08:49.770 --> 00:08:53.110
So this face ends up here.

00:08:53.110 --> 00:08:55.630
And that's what it means that
the first element in the array

00:08:55.630 --> 00:08:57.420
is y o b.

00:08:57.420 --> 00:08:59.416
How about r u f?

00:08:59.416 --> 00:09:00.290
Who ends up in r u f?

00:09:03.882 --> 00:09:05.646
AUDIENCE: [INAUDIBLE].

00:09:05.646 --> 00:09:06.312
AUDIENCE: B o y.

00:09:10.210 --> 00:09:14.314
PROFESSOR: And who
ends up in e r f?

00:09:14.314 --> 00:09:15.230
AUDIENCE: [INAUDIBLE].

00:09:19.347 --> 00:09:19.930
PROFESSOR: OK.

00:09:19.930 --> 00:09:22.680
So does everyone
understand configurations?

00:09:22.680 --> 00:09:24.422
Does this make sense?

00:09:24.422 --> 00:09:25.047
AUDIENCE: Yeah.

00:09:25.047 --> 00:09:26.544
I got lost somewhere in there.

00:09:26.544 --> 00:09:30.037
Can you explain the order
for f u r and [INAUDIBLE]?

00:09:30.037 --> 00:09:31.727
Like front upright?

00:09:31.727 --> 00:09:32.310
PROFESSOR: Oh.

00:09:32.310 --> 00:09:34.907
So do you mean-- so the
order of the letters.

00:09:34.907 --> 00:09:36.240
So there are two orderings here.

00:09:36.240 --> 00:09:39.500
One is the order of the
letters and there is an order.

00:09:39.500 --> 00:09:41.570
I think the code
uses clockwise order,

00:09:41.570 --> 00:09:44.970
but what really matters is the
first letter tells you which

00:09:44.970 --> 00:09:46.404
face you're talking about.

00:09:46.404 --> 00:09:48.020
AUDIENCE: So this is front face.

00:09:48.020 --> 00:09:50.758
PROFESSOR: Face, up face.

00:09:50.758 --> 00:09:51.666
AUDIENCE: What's up?

00:09:51.666 --> 00:09:53.940
What's front?

00:09:53.940 --> 00:09:57.480
PROFESSOR: So for this
cubelet, this is front,

00:09:57.480 --> 00:09:58.730
this is the right, this is up.

00:10:02.310 --> 00:10:11.230
This cubelet wold have a
front, an up, and a left.

00:10:11.230 --> 00:10:13.580
So now there are
24 faces and all

00:10:13.580 --> 00:10:16.370
of them get numbers from 0 23.

00:10:16.370 --> 00:10:19.400
And here we assume that
f u r is space zero,

00:10:19.400 --> 00:10:21.800
r u f is space 1, and
e r f is face 2, which

00:10:21.800 --> 00:10:26.830
is not quite [INAUDIBLE], but
you'll have the mapping there.

00:10:26.830 --> 00:10:27.330
OK.

00:10:27.330 --> 00:10:30.610
So a configuration is in
an array of 24 elements

00:10:30.610 --> 00:10:33.450
and it maps plastic faces
to wireframe faces, which

00:10:33.450 --> 00:10:36.530
brings us to, how many
configurations are there?

00:10:43.208 --> 00:10:45.847
AUDIENCE: You mean like
mapping 4 factorial?

00:10:45.847 --> 00:10:46.430
PROFESSOR: OK.

00:10:49.000 --> 00:10:50.280
So let's see what it does.

00:10:50.280 --> 00:10:51.625
We have 24 plastic faces.

00:10:57.600 --> 00:11:00.550
From 0 to 23.

00:11:00.550 --> 00:11:04.832
And they have to be
mapped to 24 positions.

00:11:04.832 --> 00:11:06.082
AUDIENCE: [INTERPOSING VOICES]

00:11:13.537 --> 00:11:15.525
AUDIENCE: There's six
colors, aren't there?

00:11:15.525 --> 00:11:17.040
AUDIENCE: Yeah.

00:11:17.040 --> 00:11:21.022
PROFESSOR: There are six colors,
but if this is also yellow,

00:11:21.022 --> 00:11:21.980
but there's a red here.

00:11:21.980 --> 00:11:24.160
This is a different face,
see, this is yellow,

00:11:24.160 --> 00:11:26.230
red, and there's
a green down here.

00:11:26.230 --> 00:11:29.960
Then this is the yellow face of
the yellow, green, red cubelet.

00:11:29.960 --> 00:11:31.800
So we care about the
individual faces.

00:11:31.800 --> 00:11:33.141
So yeah, your answer was right.

00:11:33.141 --> 00:11:34.890
I'm trying to explain
it to everyone else.

00:11:34.890 --> 00:11:36.158
But your answer is right.

00:11:36.158 --> 00:11:37.033
AUDIENCE: Well, wait.

00:11:37.033 --> 00:11:40.485
But you can't-- I mean, we
talk about some are impossible.

00:11:40.485 --> 00:11:43.540
Like, you're always gonna
have a grouping of y o b.

00:11:43.540 --> 00:11:45.352
That's never gonna change.

00:11:45.352 --> 00:11:46.060
PROFESSOR: Right.

00:11:46.060 --> 00:11:48.870
So some of these
aren't reachable,

00:11:48.870 --> 00:11:50.870
because you're not allowed
to break up the cube.

00:11:50.870 --> 00:11:51.730
AUDIENCE: Yeah.

00:11:51.730 --> 00:11:53.709
PROFESSOR: And that's OK.

00:11:53.709 --> 00:11:55.500
This is still how the
code represents them.

00:11:55.500 --> 00:11:59.655
So I'm asking if you had-- if
all these would be possible,

00:11:59.655 --> 00:12:01.880
how many would we get?

00:12:01.880 --> 00:12:04.470
And the answer is that
to map 24 plastic faces

00:12:04.470 --> 00:12:07.050
to 24 wireframe faces.

00:12:07.050 --> 00:12:13.120
So this mapping is called--
anyone good with math?

00:12:13.120 --> 00:12:14.460
AUDIENCE: 1 to 1.

00:12:14.460 --> 00:12:15.560
AUDIENCE: Bijection.

00:12:15.560 --> 00:12:16.450
PROFESSOR: OK.

00:12:16.450 --> 00:12:22.320
So when you're taking-- OK.

00:12:22.320 --> 00:12:26.190
So when we have two sets and you
have a bijection between them

00:12:26.190 --> 00:12:31.270
or 1 to 1 mapping, that
function is also called?

00:12:31.270 --> 00:12:32.270
AUDIENCE: [INAUDIBLE].

00:12:32.270 --> 00:12:34.353
PROFESSOR: You probably
don't know the answer yet.

00:12:34.353 --> 00:12:38.900
You have to wait
until the end of 6042.

00:12:38.900 --> 00:12:41.300
So I'm trying to hint that
right now, if you remember

00:12:41.300 --> 00:12:44.264
the end of 6042, maybe the
answer is somewhere there.

00:12:44.264 --> 00:12:44.930
AUDIENCE: Blur?.

00:12:49.830 --> 00:12:52.770
AUDIENCE: Perfect.

00:12:52.770 --> 00:12:54.919
AUDIENCE: A perfect match

00:12:54.919 --> 00:12:55.710
AUDIENCE: Permut--.

00:12:57.487 --> 00:12:59.820
AUDIENCE: I totally learned
about that in middle school,

00:12:59.820 --> 00:13:01.000
I think.

00:13:01.000 --> 00:13:03.276
PROFESSOR: OK.

00:13:03.276 --> 00:13:03.775
So this is--

00:13:03.775 --> 00:13:05.590
AUDIENCE: Permutations
and combinations.

00:13:05.590 --> 00:13:07.240
PROFESSOR: So this
is a permutation.

00:13:07.240 --> 00:13:08.320
AUDIENCE: Yeah.

00:13:08.320 --> 00:13:11.095
PROFESSOR: How many permutations
do you have out of 24 elements?

00:13:15.100 --> 00:13:17.183
AUDIENCE: Does that order
[? mean ?] [? matters ?]

00:13:17.183 --> 00:13:19.155
[INAUDIBLE] 24 [INAUDIBLE].

00:13:23.110 --> 00:13:25.577
PROFESSOR: So this is a
lot of permutations, right?

00:13:25.577 --> 00:13:27.160
It's a good thing
that we're not going

00:13:27.160 --> 00:13:29.830
to explore most of
these configurations.

00:13:29.830 --> 00:13:31.980
So we said before,
that we're going

00:13:31.980 --> 00:13:36.490
to build a graph where the
vertices are configurations,

00:13:36.490 --> 00:13:38.180
and the edges are
moves that get us

00:13:38.180 --> 00:13:41.460
from one configuration
to another configuration.

00:13:41.460 --> 00:13:43.920
Can they afford to build
this graph first and then run

00:13:43.920 --> 00:13:46.850
BFS on it?

00:13:46.850 --> 00:13:48.190
Not going to work, right?

00:13:48.190 --> 00:13:51.410
We don't have
enough RAM for this.

00:13:51.410 --> 00:13:53.220
So instead we're going
to have to operate

00:13:53.220 --> 00:13:55.580
on an implicit graph
for presentation.

00:13:55.580 --> 00:13:58.340
Well, fortunately, BFS
doesn't want the whole graph.

00:13:58.340 --> 00:14:00.620
The way BFS works is
it has a list of nodes

00:14:00.620 --> 00:14:02.980
that it has to visit, and
when it visits a node,

00:14:02.980 --> 00:14:06.170
it wants to know its neighbors.

00:14:06.170 --> 00:14:08.280
And that's it.

00:14:08.280 --> 00:14:09.400
Yes?

00:14:09.400 --> 00:14:11.290
Everyone happy with it?

00:14:11.290 --> 00:14:14.040
So all they have
to do is, in order

00:14:14.040 --> 00:14:16.030
to build this implicit
graph representation,

00:14:16.030 --> 00:14:18.200
is we have to know
the start node,

00:14:18.200 --> 00:14:20.670
So BFS can start somewhere.

00:14:20.670 --> 00:14:23.190
And we have to be able
to give it a node,

00:14:23.190 --> 00:14:25.860
we have to be able to generate
all the neighbor nodes.

00:14:25.860 --> 00:14:27.360
So given the
configuration, we have

00:14:27.360 --> 00:14:29.276
to be able to generate
the configurations that

00:14:29.276 --> 00:14:33.950
would result by applying
most of that configuration.

00:14:33.950 --> 00:14:36.810
So what are the moves
that you can do with this?

00:14:36.810 --> 00:14:38.440
Suppose you have a cubelet.

00:14:38.440 --> 00:14:40.020
What are the possible moves?

00:14:40.020 --> 00:14:41.030
There aren't that many.

00:14:41.030 --> 00:14:44.840
We're interested in the
simplest kind of moves.

00:14:44.840 --> 00:14:46.766
AUDIENCE: [INAUDIBLE]

00:14:46.766 --> 00:14:49.260
AUDIENCE: Yeah, you
can make the right side

00:14:49.260 --> 00:14:52.760
go right, which is equivalent
to the left side going left.

00:14:52.760 --> 00:14:57.760
And then you can do [INAUDIBLE]
4, left [INAUDIBLE].

00:14:57.760 --> 00:14:59.260
AUDIENCE: It's a nice number.

00:14:59.260 --> 00:15:00.240
PROFESSOR: OK.

00:15:00.240 --> 00:15:04.610
I think there are a few more,
so here's how I look at it.

00:15:04.610 --> 00:15:07.460
You can take the front
face, so these four,

00:15:07.460 --> 00:15:10.430
and do a clockwise
rotation, 90 degrees,

00:15:10.430 --> 00:15:13.260
or you can do a counterclockwise
rotation, 90 degrees.

00:15:13.260 --> 00:15:16.830
And you can do
that for each face.

00:15:16.830 --> 00:15:20.470
AUDIENCE: But doing a front
clockwise rotation is the same

00:15:20.470 --> 00:15:23.499
as doing a back counter
clockwise rotation, which

00:15:23.499 --> 00:15:24.727
is [? it-- ?]

00:15:24.727 --> 00:15:26.700
AUDIENCE: Yeah.

00:15:26.700 --> 00:15:28.170
PROFESSOR: Doing
a front clockwise,

00:15:28.170 --> 00:15:30.400
doing a back counterclockwise
is the same thing

00:15:30.400 --> 00:15:32.990
after you account
for symmetries.

00:15:32.990 --> 00:15:33.490
Yeah.

00:15:33.490 --> 00:15:35.080
AUDIENCE: Exactly.

00:15:35.080 --> 00:15:36.330
AUDIENCE: So it's six?

00:15:36.330 --> 00:15:36.520
PROFESSOR: Yep.

00:15:36.520 --> 00:15:38.728
So there's only six after
you account for symmetries.

00:15:38.728 --> 00:15:40.330
Let's play devil's
advocate and assume

00:15:40.330 --> 00:15:41.620
we don't account for symmetries.

00:15:41.620 --> 00:15:43.286
We're actually doing
the code, because I

00:15:43.286 --> 00:15:45.610
need to teach you something.

00:15:45.610 --> 00:15:47.616
So let's assume we don't apply.

00:15:47.616 --> 00:15:48.990
By the way, how
would you account

00:15:48.990 --> 00:15:51.110
for symmetries, easy way?

00:15:51.110 --> 00:15:52.990
Did anyone read the
comments in the code?

00:15:58.091 --> 00:15:58.590
OK.

00:15:58.590 --> 00:16:03.125
So would you account
for symmetries.

00:16:03.125 --> 00:16:04.610
AUDIENCE: Doesn't
it just happen?

00:16:10.070 --> 00:16:11.850
The permutation is
going to [INAUDIBLE].

00:16:11.850 --> 00:16:13.266
AUDIENCE: Can you
just look at it,

00:16:13.266 --> 00:16:18.430
like, each space is neighboring
faces, and [INAUDIBLE]?

00:16:18.430 --> 00:16:22.580
PROFESSOR: So the way we do
it is we anchor one cubelet.

00:16:22.580 --> 00:16:27.870
So we have one cubelet that
is a plastic cubelet that

00:16:27.870 --> 00:16:30.910
is always going to go here.

00:16:30.910 --> 00:16:34.320
So three plastic
faces here are always

00:16:34.320 --> 00:16:39.339
going to go to three
wireframed faces here.

00:16:39.339 --> 00:16:40.880
And if you fix those
three faces then

00:16:40.880 --> 00:16:43.690
you don't have simple
symmetries anymore.

00:16:43.690 --> 00:16:44.500
All right?

00:16:44.500 --> 00:16:47.684
Three axes of symmetry, so
fixing three faces settles it.

00:16:50.774 --> 00:16:52.940
AUDIENCE: Wait, so then how
many moves are possible?

00:16:52.940 --> 00:16:55.430
12?

00:16:55.430 --> 00:16:56.090
AUDIENCE: No.

00:16:56.090 --> 00:16:57.960
But you only do
one thing, though.

00:16:57.960 --> 00:16:59.980
Now you don't do
counterclock-- you don't do.

00:16:59.980 --> 00:17:01.190
AUDIENCE: If one is
anchored, there's six left.

00:17:01.190 --> 00:17:01.340
AUDIENCE: Yeah.

00:17:01.340 --> 00:17:01.370
Yeah.

00:17:01.370 --> 00:17:02.703
You don't move the anchored one.

00:17:05.259 --> 00:17:07.550
AUDIENCE: Oh yeah, because
you can only [INAUDIBLE] two

00:17:07.550 --> 00:17:11.256
of the-- three of
the faces now, but.

00:17:11.256 --> 00:17:11.839
PROFESSOR: OK.

00:17:11.839 --> 00:17:15.390
So let's look at the left face.

00:17:15.390 --> 00:17:17.660
So you have a configuration.

00:17:17.660 --> 00:17:20.210
So you can move the
left face clockwise,

00:17:20.210 --> 00:17:21.760
left face counterclockwise.

00:17:21.760 --> 00:17:26.910
You can move the top
face clockwise, top face

00:17:26.910 --> 00:17:28.680
counterclockwise,
and a couple more.

00:17:32.240 --> 00:17:35.610
So what does a move look like?

00:17:35.610 --> 00:17:36.670
Someone said it before.

00:17:39.190 --> 00:17:42.550
So when you're doing a move,
what's going to happen is,

00:17:42.550 --> 00:17:44.652
a move doesn't
create plastic faces

00:17:44.652 --> 00:17:46.110
and it doesn't
destroy them, right?

00:17:46.110 --> 00:17:51.580
It just changes their
position on the wireframe.

00:17:51.580 --> 00:17:55.150
So if you have an initial
configuration that

00:17:55.150 --> 00:17:57.560
has plastic faces assigned
to wireframe faces,

00:17:57.560 --> 00:18:02.340
and you have a
final configuration,

00:18:02.340 --> 00:18:09.882
these plastic faces are
going to end up somewhere

00:18:09.882 --> 00:18:10.590
on the wireframe.

00:18:13.380 --> 00:18:15.130
And that's true for
all the plastic faces.

00:18:15.130 --> 00:18:19.270
So the plastic faces are
going to end up somewhere.

00:18:19.270 --> 00:18:22.930
Also, what's nice is if
we look at the wireframe,

00:18:22.930 --> 00:18:27.940
if I do a clockwise rotation
in the front, whatever

00:18:27.940 --> 00:18:31.440
plastic face was here
is going to end up here.

00:18:31.440 --> 00:18:34.520
Whatever plastic face was
here is going to end up here,

00:18:34.520 --> 00:18:37.374
so on and so forth.

00:18:37.374 --> 00:18:41.658
So it's a function of rotation
[INAUDIBLE] inside [INAUDIBLE].

00:18:41.658 --> 00:18:45.693
Like the four faces that
correspond to each other,

00:18:45.693 --> 00:18:46.540
rotate.

00:18:46.540 --> 00:18:47.930
PROFESSOR: OK.

00:18:47.930 --> 00:18:52.010
That's some good-- that's
going deeper than want to go.

00:18:52.010 --> 00:18:55.530
I want to account for
something simpler.

00:18:55.530 --> 00:18:58.120
So my point is that
the arrows will always,

00:18:58.120 --> 00:19:02.030
if I do a right
clockwise rotation,

00:19:02.030 --> 00:19:04.880
the arrows will
always look the same.

00:19:04.880 --> 00:19:08.200
So the only thing that changes
is what's inside the array.

00:19:08.200 --> 00:19:10.670
But if you take one
configuration array

00:19:10.670 --> 00:19:13.750
and you move things
according to the way you're

00:19:13.750 --> 00:19:17.390
supposed to move them for
the front clockwise move,

00:19:17.390 --> 00:19:20.712
you're going to get
the right result.

00:19:20.712 --> 00:19:22.420
So what is this a
bunch of arrows called?

00:19:22.420 --> 00:19:25.510
What does it do?

00:19:25.510 --> 00:19:26.750
What does it do to the faces?

00:19:26.750 --> 00:19:29.286
What does it do to the
elements of the array?

00:19:29.286 --> 00:19:31.120
AUDIENCE: It moves
in different spots.

00:19:31.120 --> 00:19:32.982
PROFESSOR: OK, so
fancy math name?

00:19:32.982 --> 00:19:34.280
AUDIENCE: Shuffle.

00:19:34.280 --> 00:19:35.762
PROFESSOR: OK.

00:19:35.762 --> 00:19:36.970
So this is what I got before.

00:19:36.970 --> 00:19:38.428
This is how you
think of it, right?

00:19:38.428 --> 00:19:42.404
It's a shuffle, so fancy
math name for a shuttle.

00:19:42.404 --> 00:19:43.340
AUDIENCE: [INAUDIBLE].

00:19:43.340 --> 00:19:46.105
PROFESSOR: All right.

00:19:46.105 --> 00:19:48.850
AUDIENCE: Something
going on here.

00:19:48.850 --> 00:19:50.338
PROFESSOR: So then a move is a?

00:19:50.338 --> 00:19:51.838
AUDIENCE: Rotation
[? permutation?].

00:19:54.754 --> 00:19:55.254
[INAUDIBLE]

00:20:00.640 --> 00:20:03.410
PROFESSOR: All right, so the
thing is-- the difficult part

00:20:03.410 --> 00:20:05.190
of the code is you
have two things that

00:20:05.190 --> 00:20:07.320
are represented by permutations.

00:20:07.320 --> 00:20:12.030
Configurations are
permutations of plastic faces

00:20:12.030 --> 00:20:16.540
onto the array, onto the
array of wireframes faces.

00:20:16.540 --> 00:20:20.145
And then a move is a
permutation of a configuration

00:20:20.145 --> 00:20:21.270
into another configuration.

00:20:24.340 --> 00:20:26.420
OK, so now if I want
to compute neighbors,

00:20:26.420 --> 00:20:28.730
I take-- we think
there are six moves,

00:20:28.730 --> 00:20:31.520
so I'm going to take six moves.

00:20:31.520 --> 00:20:33.950
I'm going to type out the
permutations, so 6 times

00:20:33.950 --> 00:20:37.800
24 numbers, and that's it.

00:20:37.800 --> 00:20:39.921
Now I can compute neighbors.

00:20:39.921 --> 00:20:40.795
Does that make sense?

00:20:43.440 --> 00:20:45.942
AUDIENCE: I think you
have all the permutations.

00:20:45.942 --> 00:20:47.650
PROFESSOR: So there
are six moves, right?

00:20:47.650 --> 00:20:48.063
AUDIENCE: Yeah, but
then it's right.

00:20:48.063 --> 00:20:48.780
Oh yeah--

00:20:48.780 --> 00:20:52.720
PROFESSOR: If I take
a configuration,

00:20:52.720 --> 00:20:55.009
and I apply the
permutation for this move,

00:20:55.009 --> 00:20:56.550
I'm going to get a
new configuration,

00:20:56.550 --> 00:20:57.960
and that's its neighbor.

00:20:57.960 --> 00:21:04.600
So if I apply the
permutation for LC 4,

00:21:04.600 --> 00:21:06.780
left clockwise to
this configuration,

00:21:06.780 --> 00:21:08.950
I get the new configuration.

00:21:08.950 --> 00:21:11.790
So all I need to do is hard
code those configurations,

00:21:11.790 --> 00:21:12.540
and then I'm done.

00:21:12.540 --> 00:21:14.350
I can compute neighbors.

00:21:14.350 --> 00:21:15.560
But that's a lot of typing.

00:21:15.560 --> 00:21:17.480
I don't want to type as much.

00:21:17.480 --> 00:21:20.170
I want to reduce my
burden a little bit.

00:21:20.170 --> 00:21:23.830
And we can do that by noticing
that some moves are associated

00:21:23.830 --> 00:21:25.460
with some other moves.

00:21:25.460 --> 00:21:28.357
So, if I go left
clockwise move, that's

00:21:28.357 --> 00:21:30.190
the inverse of a left
counterclockwise move.

00:21:33.110 --> 00:21:37.220
So, if given the permutation,
I could compute its inverse,

00:21:37.220 --> 00:21:40.634
then I wouldn't have to
type as many permutations.

00:21:40.634 --> 00:21:41.599
Right?

00:21:41.599 --> 00:21:42.640
Why do I care about that?

00:21:42.640 --> 00:21:46.121
Did anyone take 6004?

00:21:46.121 --> 00:21:46.620
Remember?

00:21:46.620 --> 00:21:49.570
So at some lab, which
is the dreaded beta lab,

00:21:49.570 --> 00:21:52.657
you have to write the control
block for a processor, right?

00:21:52.657 --> 00:21:54.990
And that's a lot of zeros and
1's that you have to type.

00:21:54.990 --> 00:21:57.858
And if you get one wrong,
good luck to [INAUDIBLE].

00:21:57.858 --> 00:22:00.810
[INTERPOSING VOICES]

00:22:00.810 --> 00:22:03.437
AUDIENCE: 18 wide and 64 tall.

00:22:03.437 --> 00:22:04.411
PROFESSOR: I know.

00:22:04.411 --> 00:22:05.872
AUDIENCE: Copy and paste like.

00:22:05.872 --> 00:22:06.846
AUDIENCE: Yeah, and copy paste.

00:22:06.846 --> 00:22:07.346
[INAUDIBLE]

00:22:10.646 --> 00:22:11.229
PROFESSOR: OK.

00:22:11.229 --> 00:22:12.690
Bad memory.

00:22:12.690 --> 00:22:14.166
Let's move on.

00:22:14.166 --> 00:22:14.980
Let's move on.

00:22:14.980 --> 00:22:17.920
So two good news, two
pieces of good news.

00:22:17.920 --> 00:22:20.629
One, some of these are
redundant in our case, two,

00:22:20.629 --> 00:22:23.170
we wrote everything for you, so
you don't have to write them,

00:22:23.170 --> 00:22:25.741
we're just teaching
you how we did them,

00:22:25.741 --> 00:22:29.030
because the inverse of
a permutation is cool

00:22:29.030 --> 00:22:31.054
and I think it's a
good concept to know.

00:22:31.054 --> 00:22:32.720
So let's look at how
a permutation looks

00:22:32.720 --> 00:22:34.820
like and compute its
inverse and then move on

00:22:34.820 --> 00:22:36.040
to other nice problems.

00:22:43.460 --> 00:22:48.540
OK so let's take a
presentation of five elements,

00:22:48.540 --> 00:22:50.500
not going to go to
24 on the board here.

00:22:53.330 --> 00:22:55.190
3, 5, 1, 2, 4.

00:22:55.190 --> 00:22:57.940
This is how permutations
look like in math mode.

00:22:57.940 --> 00:22:59.520
If you want to be
more explicit, you

00:22:59.520 --> 00:23:01.730
can add a row numbers above.

00:23:04.830 --> 00:23:07.860
And this is a bit more explicit
about what a permutation does.

00:23:07.860 --> 00:23:11.010
So permutation takes an input
list, let's say a b c d e.

00:23:14.351 --> 00:23:16.850
And for this is an output list,
according to the recipe that

00:23:16.850 --> 00:23:17.790
you see here .

00:23:17.790 --> 00:23:21.110
So this pretty much says, the
first element of the output

00:23:21.110 --> 00:23:25.060
is the third element
of the input.

00:23:25.060 --> 00:23:27.850
The second element of the
output is the fifth element

00:23:27.850 --> 00:23:28.655
in the input.

00:23:30.880 --> 00:23:32.380
Wait, this is the
wrong permutation.

00:23:40.257 --> 00:23:42.715
It doesn't look as pretty, so
I'm changing the permutation.

00:23:46.570 --> 00:23:48.970
The third element of the
output is the first element

00:23:48.970 --> 00:23:50.790
in the input.

00:23:50.790 --> 00:23:56.290
The fourth element of the
output is which letter?

00:23:56.290 --> 00:23:57.291
So which letter?

00:23:57.291 --> 00:24:00.060
AUDIENCE: Oh. [INAUDIBLE]

00:24:00.060 --> 00:24:03.215
PROFESSOR: And the fifth element
of the output is which letter?

00:24:06.971 --> 00:24:10.740
AUDIENCE: Did you mean
to get c instead of a?

00:24:10.740 --> 00:24:11.240
No.

00:24:11.240 --> 00:24:12.264
PROFESSOR: Yeah.

00:24:12.264 --> 00:24:13.930
That would make more
sense, wouldn't it?

00:24:13.930 --> 00:24:15.800
Thank you.

00:24:15.800 --> 00:24:16.300
OK.

00:24:16.300 --> 00:24:20.840
So if this is
permutation pi, then this

00:24:20.840 --> 00:24:24.560
is the effect of applying
pi to this original list.

00:24:24.560 --> 00:24:28.980
Now the inverse of a
permutation by minus 1

00:24:28.980 --> 00:24:32.870
is another bunch of arrows,
and what I want to do

00:24:32.870 --> 00:24:36.344
is, if I take this, which
is the output of pi,

00:24:36.344 --> 00:24:37.760
and I run it through
these arrows,

00:24:37.760 --> 00:24:41.810
I want to get back a b c d e.

00:24:41.810 --> 00:24:44.830
So I want to undo
the effect of pi.

00:24:44.830 --> 00:24:45.330
OK.

00:24:45.330 --> 00:24:46.700
How do I compute this inverse?

00:24:46.700 --> 00:24:48.620
How do I compute pi
minus 1 given pi?

00:24:58.500 --> 00:25:00.760
AUDIENCE: Wait, you're
giving us the initial,

00:25:00.760 --> 00:25:03.640
when we start with c d a e b?

00:25:03.640 --> 00:25:05.140
PROFESSOR: You only
start with this.

00:25:05.140 --> 00:25:07.220
This doesn't matter at all.

00:25:07.220 --> 00:25:09.340
A different list would
get different results.

00:25:09.340 --> 00:25:14.920
So this is the permutation,
and I want pi to the minus 1.

00:25:14.920 --> 00:25:20.890
AUDIENCE: So you take the value.

00:25:20.890 --> 00:25:23.150
So you have 3 4 1 5 2.

00:25:23.150 --> 00:25:28.920
So the value at index
1 you put that index,

00:25:28.920 --> 00:25:35.390
that index has a value
of index 3, et cetera.

00:25:35.390 --> 00:25:37.580
AUDIENCE: So c would
go to position 1?

00:25:37.580 --> 00:25:39.822
AUDIENCE: Wait.

00:25:39.822 --> 00:25:41.042
PROFESSOR: OK.

00:25:41.042 --> 00:25:42.750
AUDIENCE: Is it true
that you can run pi,

00:25:42.750 --> 00:25:49.030
so the number of times it will
eventually equal pi inverse?

00:25:49.030 --> 00:25:52.272
PROFESSOR: Yes, but
that's complicated algebra

00:25:52.272 --> 00:25:53.117
to prove that.

00:25:53.117 --> 00:25:54.200
AUDIENCE: Not forget that.

00:25:57.092 --> 00:26:00.650
Just like make that
[INAUDIBLE] thing that you made

00:26:00.650 --> 00:26:02.130
and sort of flip it.

00:26:02.130 --> 00:26:03.000
PROFESSOR: OK.

00:26:03.000 --> 00:26:04.640
I like that.

00:26:04.640 --> 00:26:12.349
So 34152, 1 2 3 4 5.

00:26:12.349 --> 00:26:13.890
Except this doesn't
look very pretty,

00:26:13.890 --> 00:26:15.389
so I need to sort
them again, right?

00:26:15.389 --> 00:26:22.350
So 1 3, 2 5, 3 1, 4 2, 5 4.

00:26:24.871 --> 00:26:25.370
Right?

00:26:25.370 --> 00:26:28.080
Did you guys come
up with it now?

00:26:28.080 --> 00:26:29.990
Congrats.

00:26:29.990 --> 00:26:30.740
So this is good.

00:26:30.740 --> 00:26:32.198
This is how you
compute an inverse.

00:26:32.198 --> 00:26:34.640
Let's figure out why you
compute an inverse that way.

00:26:34.640 --> 00:26:36.200
Let's look at b.

00:26:36.200 --> 00:26:40.730
So b starts out at
position 2, right?

00:26:40.730 --> 00:26:52.030
And then pi of 5 equals 2, which
means that, after applying 5,

00:26:52.030 --> 00:26:55.500
b is going to go to position 5.

00:26:55.500 --> 00:27:00.220
So pi inverse has to
take b and put it where?

00:27:00.220 --> 00:27:01.060
Back to 2, right?

00:27:01.060 --> 00:27:04.160
Otherwise it's not
a good inverse.

00:27:04.160 --> 00:27:08.860
So pi inverse of 2.

00:27:08.860 --> 00:27:10.410
So the second
element in the output

00:27:10.410 --> 00:27:12.374
has to be which
element in the input?

00:27:15.360 --> 00:27:17.160
5, right?

00:27:17.160 --> 00:27:19.840
Otherwise, this wouldn't
undo the effect of pi.

00:27:24.550 --> 00:27:28.140
So if you write out our
permutation and split

00:27:28.140 --> 00:27:31.587
the index and the value, we
get the inverse permutation.

00:27:31.587 --> 00:27:34.170
So you can compute that with a
couple of lines of Python code.

00:27:36.770 --> 00:27:37.270
OK.

00:27:37.270 --> 00:27:41.240
So this lets us now compute
some of the permutations there.

00:27:41.240 --> 00:27:43.460
So we only have to type
up two, three, four,

00:27:43.460 --> 00:27:44.892
or something like that.

00:27:44.892 --> 00:27:46.350
It's a bit nicer
and you guys don't

00:27:46.350 --> 00:27:48.680
have to type up any,
because we gave them to you.

00:27:48.680 --> 00:27:51.200
Aren't we nice?

00:27:51.200 --> 00:27:51.700
All right.

00:27:51.700 --> 00:27:53.783
Any questions about
permutations or Rubik's cubes?

00:27:56.790 --> 00:27:58.620
AUDIENCE: Wait, so
to get high inverse

00:27:58.620 --> 00:28:02.312
based off those numbers,
you just-- well,

00:28:02.312 --> 00:28:03.910
it's the same thing.

00:28:03.910 --> 00:28:06.320
Wait, but 5 got flipped.

00:28:06.320 --> 00:28:09.430
Or you think the maybe if the
inverse of that matrix then?

00:28:09.430 --> 00:28:12.260
PROFESSOR: So you take these
two and you flip them, right?

00:28:12.260 --> 00:28:13.176
AUDIENCE: [INAUDIBLE].

00:28:16.140 --> 00:28:19.530
PROFESSOR: And then you keep
these bound, but you sort them.

00:28:22.700 --> 00:28:28.477
2 5, 3 1, 4, no-- 3 5 1 2 4.

00:28:28.477 --> 00:28:30.518
AUDIENCE: Oh they're still
based off the top row?

00:28:30.518 --> 00:28:31.277
AUDIENCE: Yeah.

00:28:31.277 --> 00:28:31.985
AUDIENCE: Oh, OK.

00:28:31.985 --> 00:28:34.077
AUDIENCE: Wait, how did
he get the second one?

00:28:34.077 --> 00:28:35.410
AUDIENCE: Based off the top row.

00:28:35.410 --> 00:28:39.090
PROFESSOR: So you sort this
one, but you keep the bonds,

00:28:39.090 --> 00:28:42.780
so 3 ends up here and it
gives it 1, 4 ends up here

00:28:42.780 --> 00:28:45.600
and it gives us 2.

00:28:45.600 --> 00:28:46.360
OK.

00:28:46.360 --> 00:28:49.370
So this make sense?

00:28:49.370 --> 00:28:49.870
Good.

00:28:49.870 --> 00:28:51.590
We're remembering
that, that's good.

00:28:51.590 --> 00:28:52.890
Now let's talk about a problem.

00:28:52.890 --> 00:28:54.890
So this is a Rubik's cube,
this is how it works.

00:28:54.890 --> 00:28:57.750
Hopefully we will remember
how to solve game.

00:28:57.750 --> 00:29:05.130
Let's try to solve
StarCraft Well,

00:29:05.130 --> 00:29:06.526
of course we're going to cheat.

00:29:06.526 --> 00:29:08.650
We're going to solve a
simpler version of StarCraft

00:29:08.650 --> 00:29:11.210
because it turns out you
can't really solve StarCraft

00:29:11.210 --> 00:29:14.950
with the computers
that we have now.

00:29:14.950 --> 00:29:17.470
So let's make a few
simplifying assumptions.

00:29:17.470 --> 00:29:20.980
Who play StarCraft, by the way?

00:29:20.980 --> 00:29:21.580
Two?

00:29:21.580 --> 00:29:22.080
OK.

00:29:22.080 --> 00:29:23.817
So you guys, please
pay attention

00:29:23.817 --> 00:29:25.650
to the simplifying
assumptions, because this

00:29:25.650 --> 00:29:26.990
isn't real StarCraft.

00:29:26.990 --> 00:29:31.830
It's a lot easier, so that we
can build a problem out of it.

00:29:31.830 --> 00:29:32.330
All right.

00:29:32.330 --> 00:29:38.070
So we're going to play
with a race called Zerg.

00:29:38.070 --> 00:29:44.230
And so the idea of StarCraft
is you build an army

00:29:44.230 --> 00:29:45.820
and then you take
this army and you

00:29:45.820 --> 00:29:48.140
destroy your opponent,
nice and simple.

00:29:48.140 --> 00:29:50.860
Good old violent games.

00:29:50.860 --> 00:29:54.240
So we're going to look at the
build order part of the game.

00:29:54.240 --> 00:29:56.840
So the build order is the
opening strategy and it takes

00:29:56.840 --> 00:30:00.830
care of the building process,
so it's the strategy that says,

00:30:00.830 --> 00:30:02.820
what are you going
to build and when,

00:30:02.820 --> 00:30:05.760
in order to come up with an
army as quickly as possible?

00:30:05.760 --> 00:30:08.970
So the main goal is to amass
an army quickly and then take

00:30:08.970 --> 00:30:10.732
that army and
destroy the opponent.

00:30:10.732 --> 00:30:12.440
And yes, I know, not
real life StarCraft,

00:30:12.440 --> 00:30:13.780
but let's go with it.

00:30:18.880 --> 00:30:21.660
OK, so these are the
rules in our toy StarCraft

00:30:21.660 --> 00:30:26.690
And the Zerg is started with a
building called the hatchery.

00:30:26.690 --> 00:30:29.810
And out of a hatchery--
the currency of the game,

00:30:29.810 --> 00:30:31.170
by the way, is minerals.

00:30:31.170 --> 00:30:33.510
We'll write that
down as dollars.

00:30:33.510 --> 00:30:38.040
So out of a hatchery
you can build a drone

00:30:38.040 --> 00:30:40.400
by spending 50 minerals.

00:30:40.400 --> 00:30:44.760
You can build an
overlord by spending 100,

00:30:44.760 --> 00:30:49.970
or you can build a
Zergling by spending 50.

00:30:49.970 --> 00:30:51.940
All right, what do
each of these do?

00:30:51.940 --> 00:30:55.180
A drone harvests minerals
for you, so it's a worker.

00:30:55.180 --> 00:30:59.050
So, for every drone
that you have,

00:30:59.050 --> 00:31:00.500
you get eight minerals a second.

00:31:03.220 --> 00:31:06.100
So drone gets you eight
minerals a second.

00:31:06.100 --> 00:31:08.060
As Zergling is your
attack unit, so this

00:31:08.060 --> 00:31:10.130
is the guy that you want
to build in the end.

00:31:10.130 --> 00:31:12.600
So this destroys your opponents.

00:31:12.600 --> 00:31:16.020
I don't know how to make a
nice icon for that, so big

00:31:16.020 --> 00:31:17.540
smiley green.

00:31:17.540 --> 00:31:20.260
This makes it happy.

00:31:20.260 --> 00:31:20.850
All right.

00:31:20.850 --> 00:31:22.680
Overlords help you
control your units,

00:31:22.680 --> 00:31:26.830
so drones and
Zerglings are units.

00:31:26.830 --> 00:31:29.670
You can't build-- for every
eight units that you build,

00:31:29.670 --> 00:31:31.330
you have to have an overlord.

00:31:31.330 --> 00:31:32.960
Otherwise, you can't
build more units

00:31:32.960 --> 00:31:34.710
until you build overlords.

00:31:34.710 --> 00:31:38.000
So if you have eight drones,
you can't build a ninth on one

00:31:38.000 --> 00:31:38.950
you build an overlord.

00:31:38.950 --> 00:31:41.300
If you have eight drones
and these eight Zerglings,

00:31:41.300 --> 00:31:43.020
you have to build
a second overlord

00:31:43.020 --> 00:31:45.840
to be able to build more units.

00:31:45.840 --> 00:31:49.225
So one overlord can help
you control eight units.

00:31:52.130 --> 00:31:53.900
In order to build
a Zergling, which

00:31:53.900 --> 00:31:55.316
is what you want
to do in the end,

00:31:55.316 --> 00:31:57.930
because these are the attack
units, you need to spend $50,

00:31:57.930 --> 00:32:00.280
and you also need to
have one building called

00:32:00.280 --> 00:32:01.090
a spawning pool.

00:32:05.070 --> 00:32:07.250
You what?

00:32:07.250 --> 00:32:07.800
All right.

00:32:07.800 --> 00:32:09.960
So how do you build
that spawning pool?

00:32:09.960 --> 00:32:12.390
Drones can work for
you, but they can also

00:32:12.390 --> 00:32:14.080
transform into buildings.

00:32:14.080 --> 00:32:16.749
So a drone mutates into a
building, and after it mutates,

00:32:16.749 --> 00:32:19.040
it doesn't work for you
anymore, by the way, so no more

00:32:19.040 --> 00:32:20.500
minerals.

00:32:20.500 --> 00:32:28.230
So a drone can mutate into the
spawning pool for 200 minerals,

00:32:28.230 --> 00:32:29.230
I think.

00:32:29.230 --> 00:32:31.740
It can mutate into a hatchery.

00:32:31.740 --> 00:32:35.590
That's the same thing
that you have up here for,

00:32:35.590 --> 00:32:37.230
how much is it?

00:32:37.230 --> 00:32:40.340
$450.

00:32:40.340 --> 00:32:43.590
And it can mutate into
an evolution chamber

00:32:43.590 --> 00:32:51.030
that we'll talk
about soon, for $400.

00:32:51.030 --> 00:32:51.530
OK.

00:32:51.530 --> 00:32:54.360
Why do we care about having
more than one hatchery?

00:32:54.360 --> 00:32:57.650
One hatchery can build one unit
per second, no more than that.

00:33:00.689 --> 00:33:02.480
So once you have a lot
of drones and you're

00:33:02.480 --> 00:33:05.220
making a lot of money, you need
to have a lot of hatcheries

00:33:05.220 --> 00:33:07.180
so that you can spend the money.

00:33:07.180 --> 00:33:09.670
Our goal is not to amass money,
it's to build units, right?

00:33:09.670 --> 00:33:11.004
So money doesn't
help you, I'm going

00:33:11.004 --> 00:33:12.337
to spend it as fast as possible.

00:33:15.140 --> 00:33:16.300
OK.

00:33:16.300 --> 00:33:19.126
An evolution chamber
lets you build-- let's

00:33:19.126 --> 00:33:20.850
you upgrade research
to technologies.

00:33:20.850 --> 00:33:22.600
And these technologies
aren't like badges.

00:33:22.600 --> 00:33:26.420
Once you get them,
you keep them.

00:33:26.420 --> 00:33:28.630
So you can research
an attack upgrade

00:33:28.630 --> 00:33:33.560
and you can research
a defense upgrade.

00:33:33.560 --> 00:33:38.030
They're both 1,000 minerals,
but you only have to do it once.

00:33:38.030 --> 00:33:40.040
Why do I care about these?

00:33:40.040 --> 00:33:43.340
They decide how strong
your Zerglings are.

00:33:43.340 --> 00:33:47.870
So, given a Zergling, at
the beginning of the game,

00:33:47.870 --> 00:33:50.670
you don't have the
attack upgrade,

00:33:50.670 --> 00:33:52.760
and you don't have
a defense upgrade.

00:33:52.760 --> 00:33:55.150
So the Zerglings attack is 1.

00:33:55.150 --> 00:33:57.360
If you research
the attack upgrade,

00:33:57.360 --> 00:33:59.580
but you haven't researched
the defense one,

00:33:59.580 --> 00:34:02.530
their total power is 133.

00:34:02.530 --> 00:34:05.010
If you research the defense
upgrade, but not the attack

00:34:05.010 --> 00:34:07.670
upgrade, their
total power is 1.2.

00:34:07.670 --> 00:34:11.750
And after your research both of
them, their total power is 2.

00:34:11.750 --> 00:34:13.730
Again, oversimplifying.

00:34:13.730 --> 00:34:17.480
So, we have to build an army
that's as powerful as possible.

00:34:17.480 --> 00:34:21.370
So in the end you want to
have both of these researched.

00:34:21.370 --> 00:34:21.870
All right.

00:34:21.870 --> 00:34:24.080
Now there's one more
limitation, that is,

00:34:24.080 --> 00:34:27.280
you cannot control more than
200 of these units total,

00:34:27.280 --> 00:34:29.130
because even if you
have a lot of overlords,

00:34:29.130 --> 00:34:33.100
your brain isn't immensely huge,
so you can only control 200

00:34:33.100 --> 00:34:34.199
units.

00:34:34.199 --> 00:34:40.489
So we want to build these 200
units as fast as possible.

00:34:40.489 --> 00:34:44.699
And out of these
200 units, we want

00:34:44.699 --> 00:34:49.330
to have at least 150 Zerglings.

00:34:49.330 --> 00:34:50.794
If you build 200
drones, you're not

00:34:50.794 --> 00:34:52.460
going to attack your
opponent with that,

00:34:52.460 --> 00:34:54.650
those aren't very useful.

00:34:54.650 --> 00:34:56.650
But you need some drones
in order to make money,

00:34:56.650 --> 00:34:58.280
so you need the balance.

00:34:58.280 --> 00:35:02.170
So the goal is to get to 200
units as quickly as possible,

00:35:02.170 --> 00:35:03.532
and at least 150 Zergs.

00:35:06.160 --> 00:35:07.960
Yes?

00:35:07.960 --> 00:35:10.560
Evolution chamber.

00:35:10.560 --> 00:35:13.811
Easy, that's too much.

00:35:13.811 --> 00:35:14.310
OK.

00:35:14.310 --> 00:35:15.624
So how do we solve this?

00:35:18.500 --> 00:35:19.416
AUDIENCE: [INAUDIBLE].

00:35:23.680 --> 00:35:26.830
PROFESSOR: So how
do we solve this?

00:35:26.830 --> 00:35:29.064
AUDIENCE: Watch the pros play.

00:35:29.064 --> 00:35:31.480
PROFESSOR: Well, they're going
to play real StarCraft this

00:35:31.480 --> 00:35:34.622
is toy StarCraft this is
six-level 6 StarCraft so it's

00:35:34.622 --> 00:35:37.320
not going to work.

00:35:37.320 --> 00:35:39.030
But there is a simple
strategy, because I

00:35:39.030 --> 00:35:42.688
haven't added one
last constraint.

00:35:42.688 --> 00:35:44.700
AUDIENCE: Lets me guess.

00:35:44.700 --> 00:35:45.310
PROFESSOR: No.

00:35:45.310 --> 00:35:48.340
It's going to be
harassing your enemy.

00:35:48.340 --> 00:35:50.590
But if you don't have to
harass your enemy intuitively

00:35:50.590 --> 00:35:53.100
and build your economy
first, so first

00:35:53.100 --> 00:35:54.950
build your drones
and hatcheries,

00:35:54.950 --> 00:35:57.222
and then pop out
Zerglings, right?

00:35:57.222 --> 00:35:58.430
So there's a greedy strategy.

00:35:58.430 --> 00:36:00.450
If you spend about an hour
with a sheet of paper,

00:36:00.450 --> 00:36:02.074
you can realize what
is the right order

00:36:02.074 --> 00:36:05.510
to build drones and
hatcheries and overlords,

00:36:05.510 --> 00:36:08.680
so that you get to a nice
big economy, and then, Bam!

00:36:08.680 --> 00:36:10.944
Build Zerglings.

00:36:10.944 --> 00:36:13.110
Once you get to 50 drones,
you start build Zerglings

00:36:13.110 --> 00:36:14.130
as fast as possible.

00:36:16.670 --> 00:36:19.540
So this is a greedy
strategy, you

00:36:19.540 --> 00:36:21.250
don't need to do a
lot of work for that.

00:36:21.250 --> 00:36:23.041
So we want to make
things more interesting.

00:36:23.041 --> 00:36:25.450
So in order to make
things more interesting,

00:36:25.450 --> 00:36:26.780
the game time goes in seconds.

00:36:26.780 --> 00:36:28.820
Everything that we had
here is in seconds.

00:36:28.820 --> 00:36:36.865
Every two minutes, so two
minutes, which is 120 seconds.

00:36:36.865 --> 00:36:38.490
So every two minutes
I want to assemble

00:36:38.490 --> 00:36:41.570
a small pack of
Zerglings and send them

00:36:41.570 --> 00:36:43.160
to the enemy to harass them.

00:36:43.160 --> 00:36:45.140
And the Antonio enemy
will defend themselves

00:36:45.140 --> 00:36:46.690
and they will
destroy my Zerglings,

00:36:46.690 --> 00:36:49.360
but they won't be able to
focus on the game very well.

00:36:49.360 --> 00:36:52.320
So I need to do this in order
to have a good chance to win.

00:36:52.320 --> 00:36:54.290
If I don't do this, my
strategy is invalid.

00:36:54.290 --> 00:36:57.070
AUDIENCE: Does the enemy,
does it do that to us as well?

00:36:57.070 --> 00:36:58.119
PROFESSOR: No.

00:36:58.119 --> 00:36:59.160
We're sending them facts.

00:36:59.160 --> 00:37:01.230
We are going to have a really
fast strategy, because we're

00:37:01.230 --> 00:37:03.450
computing the optimal
strategy, so they're not

00:37:03.450 --> 00:37:04.410
going to have time.

00:37:04.410 --> 00:37:06.840
They're going to
be fighting us off.

00:37:06.840 --> 00:37:09.330
OK, how many
Zerglings do I send?

00:37:09.330 --> 00:37:12.170
I have to send enough
Zerglings so that the attack

00:37:12.170 --> 00:37:19.198
power at minutes 2m is
6 times log 1 plus m.

00:37:19.198 --> 00:37:21.031
You knew there has to
be some mapping there.

00:37:23.720 --> 00:37:27.080
So the reason for this is, let's
look at the first two minutes.

00:37:27.080 --> 00:37:30.050
After two minutes, if we
haven't researched any upgrades,

00:37:30.050 --> 00:37:32.500
we need to send this
in six Zerglings.

00:37:32.500 --> 00:37:34.800
If we researched both
upgrades, we only

00:37:34.800 --> 00:37:37.379
need to send in three Zerglings.

00:37:37.379 --> 00:37:38.920
If we researched
one of the upgrades,

00:37:38.920 --> 00:37:41.240
we need to send
in five Zerglings.

00:37:41.240 --> 00:37:42.911
So this is the
total attack power,

00:37:42.911 --> 00:37:45.160
not the numbers are of
Zerglings that we need to send.

00:37:50.480 --> 00:37:53.630
AUDIENCE: And is minutes?

00:37:53.630 --> 00:37:55.110
PROFESSOR: Actually,
it's basically

00:37:55.110 --> 00:37:59.810
which attack wave you're
doing, so every two minutes.

00:37:59.810 --> 00:38:00.600
AUDIENCE: Oh, OK.

00:38:00.600 --> 00:38:03.060
So the first one
is m equals zero.

00:38:03.060 --> 00:38:05.064
PROFESSOR: And 1.

00:38:05.064 --> 00:38:07.230
That is not the one attacking
right in the beginning

00:38:07.230 --> 00:38:08.764
when we don't have Zerglings.

00:38:08.764 --> 00:38:09.680
AUDIENCE: [INAUDIBLE].

00:38:09.680 --> 00:38:12.310
PROFESSOR: Equals 1, n equals 2,
n equals 3, so on and so forth.

00:38:12.310 --> 00:38:13.935
AUDIENCE: How did
you get that formula?

00:38:16.978 --> 00:38:18.176
OK.

00:38:18.176 --> 00:38:19.800
PROFESSOR: Is it
making your life hard?

00:38:19.800 --> 00:38:23.233
Would that be logged base
2, or is that log base 10?

00:38:23.233 --> 00:38:24.399
PROFESSOR: Sure, log base 2.

00:38:31.204 --> 00:38:31.704
Fine.

00:38:36.857 --> 00:38:38.440
OK, so how are we
going to solve this?

00:38:38.440 --> 00:38:40.460
Intuitively, how did
we solve all the game

00:38:40.460 --> 00:38:44.660
problems, all the
problems recently?

00:38:44.660 --> 00:38:46.000
What are we going to do?

00:38:46.000 --> 00:38:47.982
AUDIENCE: [INAUDIBLE].

00:38:47.982 --> 00:38:49.440
PROFESSOR: So the
first thing we're

00:38:49.440 --> 00:38:50.993
going to build a graph, right?

00:38:50.993 --> 00:38:51.880
AUDIENCE: Yeah.

00:38:51.880 --> 00:38:53.046
PROFESSOR: So build a graph.

00:38:55.890 --> 00:38:58.240
The vertices are the
states of the game,

00:38:58.240 --> 00:39:00.700
so a vertex shows
me what state I'm in

00:39:00.700 --> 00:39:05.930
and an edge shows
possible moves that I do.

00:39:05.930 --> 00:39:09.792
So what I need to keep track
in the vertex, what's my state?

00:39:09.792 --> 00:39:12.648
AUDIENCE: How much money
you have, and how many units

00:39:12.648 --> 00:39:14.552
you have?

00:39:14.552 --> 00:39:16.932
And maybe how fast
you're making money?

00:39:16.932 --> 00:39:18.870
AUDIENCE: Oh, unless
the states, are

00:39:18.870 --> 00:39:21.274
states-- they're not movable?

00:39:21.274 --> 00:39:23.440
Oh, I guess they could be
moveable [INAUDIBLE] could

00:39:23.440 --> 00:39:25.252
do nothing, in the
next second, right?

00:39:25.252 --> 00:39:27.710
PROFESSOR: So you're saying
you need to keep track of time,

00:39:27.710 --> 00:39:28.475
too?

00:39:28.475 --> 00:39:29.840
AUDIENCE: I don't know.

00:39:29.840 --> 00:39:31.100
PROFESSOR: OK so maybe time.

00:39:33.920 --> 00:39:35.668
What else?

00:39:35.668 --> 00:39:37.120
AUDIENCE: Badge
[INAUDIBLE] thing.

00:39:37.120 --> 00:39:39.116
PROFESSOR: OK so upgrades.

00:39:42.104 --> 00:39:43.895
You said units, I'm
going to say buildings.

00:39:47.380 --> 00:39:50.190
AUDIENCE: Wait, is
Zergling is a building?

00:39:50.190 --> 00:39:53.100
PROFESSOR: A Zergling
is a unit, so-

00:39:53.100 --> 00:39:54.530
AUDIENCE: Overlords.

00:39:54.530 --> 00:39:57.590
PROFESSOR: Unit, unit, unit.

00:39:57.590 --> 00:40:01.510
Building, building,
building, upgrade, upgrade.

00:40:01.510 --> 00:40:04.232
So let's see how are we
going to keep track of them.

00:40:04.232 --> 00:40:05.065
That's a good point.

00:40:05.065 --> 00:40:08.870
We started looking at units,
we started looking at units.

00:40:08.870 --> 00:40:10.850
So how do I keep
track of my units?

00:40:10.850 --> 00:40:13.179
What I need to know?

00:40:13.179 --> 00:40:18.110
AUDIENCE: The number of
drones, overlords, servlings.

00:40:18.110 --> 00:40:21.740
PROFESSOR: Droids, drones,
overlords, Zerglings.

00:40:21.740 --> 00:40:22.240
OK.

00:40:22.240 --> 00:40:23.073
How about buildings?

00:40:26.418 --> 00:40:27.900
AUDIENCE: [INAUDIBLE] PHEC--

00:40:27.900 --> 00:40:29.179
PROFESSOR: Almost.

00:40:29.179 --> 00:40:30.970
So I want to know the
number of hatcheries,

00:40:30.970 --> 00:40:33.280
because this is how
fast I can produce.

00:40:33.280 --> 00:40:37.681
But then how many spawning
pools am I going to build?

00:40:37.681 --> 00:40:38.180
Good.

00:40:38.180 --> 00:40:39.930
So that was StarCraft player 1.

00:40:39.930 --> 00:40:42.300
Once you have a spawning
pool, you can build Zerglings,

00:40:42.300 --> 00:40:44.260
there's no reason to
build more than one.

00:40:44.260 --> 00:40:46.417
So a spawning pool is
going to be like a badge.

00:40:46.417 --> 00:40:48.250
Once you build it, you
have it, you're done.

00:40:48.250 --> 00:40:49.976
So it's Boolean.

00:40:49.976 --> 00:40:51.900
AUDIENCE: Wait, what's
a spawning pool again?

00:40:51.900 --> 00:40:53.280
PROFESSOR: So a spawning
pool is something

00:40:53.280 --> 00:40:55.280
that you build off a drone
and once you have it,

00:40:55.280 --> 00:40:57.940
you can build Zerglings
from a hatchery.

00:40:57.940 --> 00:40:58.987
So that's all it does.

00:40:58.987 --> 00:41:00.612
AUDIENCE: Why would
you want two if you

00:41:00.612 --> 00:41:02.735
can build four Zerglings?

00:41:02.735 --> 00:41:05.110
PROFESSOR: So the spawning
pool doesn't build a Zergling.

00:41:05.110 --> 00:41:07.560
See, the hatchery
builds the Zerglings.

00:41:07.560 --> 00:41:09.019
So the spawning
pool is just there.

00:41:09.019 --> 00:41:10.601
You need to have it
to cross the edge.

00:41:10.601 --> 00:41:11.456
Otherwise you can't.

00:41:11.456 --> 00:41:11.997
AUDIENCE: OK.

00:41:11.997 --> 00:41:13.303
I understand.

00:41:13.303 --> 00:41:13.886
PROFESSOR: OK.

00:41:16.810 --> 00:41:20.720
So what else for buildings?

00:41:20.720 --> 00:41:23.220
Whether you have
it or not, right?

00:41:23.220 --> 00:41:23.830
OK.

00:41:23.830 --> 00:41:26.172
How about upgrades?

00:41:26.172 --> 00:41:28.900
[INAUDIBLE] a u, d u.

00:41:28.900 --> 00:41:33.060
PROFESSOR: So two
flags, a u, d u.

00:41:33.060 --> 00:41:33.560
Cool.

00:41:33.560 --> 00:41:37.540
So now we have the thorny
issues of money and time.

00:41:37.540 --> 00:41:41.460
Let's say that we're going to
have some sort of approximation

00:41:41.460 --> 00:41:44.390
that's going to allow us
to not keep track of money,

00:41:44.390 --> 00:41:47.290
because money is-- you
can have a lot of money,

00:41:47.290 --> 00:41:50.057
so that will give us
an explosion of states.

00:41:50.057 --> 00:41:52.140
So we're going to assume
that we're spending money

00:41:52.140 --> 00:41:54.130
as fast as possible,
because that's

00:41:54.130 --> 00:41:56.054
what you usually want to do.

00:41:56.054 --> 00:41:59.040
AUDIENCE: So should your
money always be zero then?

00:41:59.040 --> 00:42:00.486
PROFESSOR: Almost.

00:42:00.486 --> 00:42:01.920
It's very close to that.

00:42:01.920 --> 00:42:05.840
So you start off with no money.

00:42:05.840 --> 00:42:07.310
You accumulate
money, then you're

00:42:07.310 --> 00:42:10.230
going to issue some build
orders and build something.

00:42:10.230 --> 00:42:12.210
And your money's
going to drop, maybe

00:42:12.210 --> 00:42:14.470
to zero, maybe to almost zero.

00:42:14.470 --> 00:42:16.770
Then you wait to
accumulate more money,

00:42:16.770 --> 00:42:18.630
issue another build order.

00:42:18.630 --> 00:42:22.660
Wait to accumulate more money,
hopefully it goes faster now.

00:42:22.660 --> 00:42:24.456
Issue another build order.

00:42:24.456 --> 00:42:26.330
We're going to approximate
that every time we

00:42:26.330 --> 00:42:27.890
issue a build order,
so every time we

00:42:27.890 --> 00:42:29.350
tell our things to
build something,

00:42:29.350 --> 00:42:32.420
the money will drop to zero.

00:42:32.420 --> 00:42:34.470
So that doesn't mean you
can only build one thing

00:42:34.470 --> 00:42:36.120
and then your money
drops to zero.

00:42:36.120 --> 00:42:39.550
If you wait for a few
seconds and then you

00:42:39.550 --> 00:42:42.390
have two hatcheries and tell
both of them to build drones,

00:42:42.390 --> 00:42:45.640
you build two drones and
then your money goes to zero.

00:42:45.640 --> 00:42:48.909
So that means that if we
model our states carefully,

00:42:48.909 --> 00:42:50.450
we don't have to
keep track of money.

00:42:56.722 --> 00:42:58.763
AUDIENCE: You should
probably keep track of time.

00:43:01.697 --> 00:43:04.000
AUDIENCE: Actually
keep track of the rate

00:43:04.000 --> 00:43:06.470
you're gathering though, right?

00:43:06.470 --> 00:43:08.750
PROFESSOR: So what's the
rate that you're gathering?

00:43:08.750 --> 00:43:11.055
AUDIENCE: It's the number of--

00:43:11.055 --> 00:43:14.440
AUDIENCE: Oh [INAUDIBLE]
drones, yeah. [INAUDIBLE], OK.

00:43:14.440 --> 00:43:17.721
PROFESSOR: So this
multiplied by 8%.

00:43:17.721 --> 00:43:19.947
AUDIENCE: So we should
keep track of time.

00:43:19.947 --> 00:43:20.530
PROFESSOR: OK.

00:43:20.530 --> 00:43:23.441
So how would we solve it
if we keep track of time?

00:43:26.880 --> 00:43:28.449
AUDIENCE: You multiply

00:43:28.449 --> 00:43:30.282
AUDIENCE: Can you do
that layer thing again?

00:43:30.282 --> 00:43:31.190
Where is that?

00:43:31.190 --> 00:43:34.766
PROFESSOR: So you're going
to have-- so what's a layer?

00:43:34.766 --> 00:43:36.057
AUDIENCE: Actually, never mind.

00:43:39.190 --> 00:43:41.240
AUDIENCE: I want to
know what a layer is.

00:43:41.240 --> 00:43:41.968
PROFESSOR: Sorry?

00:43:41.968 --> 00:43:43.676
AUDIENCE: I want to
know what a layer is.

00:43:43.676 --> 00:43:47.000
PROFESSOR: So last time we-- we
solved problems by saying that,

00:43:47.000 --> 00:43:48.680
so we had the graph of streets.

00:43:48.680 --> 00:43:50.000
We had a highway graph.

00:43:50.000 --> 00:43:51.820
And that was a 2D graph.

00:43:51.820 --> 00:43:54.190
And we made it into a
3D graph by adding time

00:43:54.190 --> 00:43:56.260
as a third dimension.

00:43:56.260 --> 00:43:58.570
So we had layers,
where each layer was,

00:43:58.570 --> 00:44:00.310
said that you're at
a point in the graph

00:44:00.310 --> 00:44:03.780
at a certain point in time.

00:44:03.780 --> 00:44:05.769
So there's a layer 4
times 0, layer 4 time 1,

00:44:05.769 --> 00:44:06.560
so on and so forth.

00:44:06.560 --> 00:44:09.250
And you start at time 0 and
kept going up the graph.

00:44:12.687 --> 00:44:14.300
AUDIENCE: You have
a flag that says,

00:44:14.300 --> 00:44:16.180
I've just purchased something?

00:44:16.180 --> 00:44:19.600
Because that way then you'll
know that you've completely

00:44:19.600 --> 00:44:23.420
exhausted your-- that
maybe that will tell you

00:44:23.420 --> 00:44:25.502
that you can't buy
anything for awhile, right?

00:44:25.502 --> 00:44:27.562
Because if we're not
keeping track of money then

00:44:27.562 --> 00:44:28.700
we should know [INAUDIBLE].

00:44:28.700 --> 00:44:29.283
PROFESSOR: OK.

00:44:29.283 --> 00:44:31.200
So that's a good point.

00:44:31.200 --> 00:44:35.280
So if I have-- so suppose here
I have to wait for five seconds

00:44:35.280 --> 00:44:37.060
to get enough
money to do a move.

00:44:37.060 --> 00:44:38.880
If I keep track of
time in my state and I

00:44:38.880 --> 00:44:41.431
have five things here.

00:44:41.431 --> 00:44:43.180
I also have to keep
track of money, right?

00:44:43.180 --> 00:44:44.929
I have to know how
much money I'm getting,

00:44:44.929 --> 00:44:46.600
so that I know where
I'm buying things.

00:44:46.600 --> 00:44:49.020
On the other hand,
in this case, if I

00:44:49.020 --> 00:44:51.620
keep track of both time
and money as states,

00:44:51.620 --> 00:44:53.190
I can implement a
precise strategy.

00:44:53.190 --> 00:44:54.523
I don't need this approximation.

00:44:57.060 --> 00:45:01.610
If I do that, then what
search algorithm would I use?

00:45:01.610 --> 00:45:05.930
So if I have time in states,
so each vertex in my note

00:45:05.930 --> 00:45:09.490
says that I get from some
states to some other state

00:45:09.490 --> 00:45:12.200
in one unit of time.

00:45:12.200 --> 00:45:15.975
What algorithm do I use
to search for my strategy?

00:45:20.100 --> 00:45:20.600
Yeah.

00:45:20.600 --> 00:45:21.659
Why do I use BFS?

00:45:21.659 --> 00:45:23.700
AUDIENCE: Because every
edge has the same weight.

00:45:23.700 --> 00:45:25.450
PROFESSOR: Every edge has
the same weight, right?

00:45:25.450 --> 00:45:27.040
So if we keep
track of time, then

00:45:27.040 --> 00:45:29.970
we-- we keep track of time,
we keep track of money,

00:45:29.970 --> 00:45:32.592
we use BFS, we have a solution.

00:45:32.592 --> 00:45:33.092
So.

00:45:44.240 --> 00:45:46.680
Let's try to not do
it, either of these.

00:45:46.680 --> 00:45:48.290
If I don't want to
keep track of time

00:45:48.290 --> 00:45:50.640
and I don't want to
keep track of money,

00:45:50.640 --> 00:45:53.360
what would an edge be?

00:45:53.360 --> 00:45:57.880
If I want to say that, hey, this
is a state and this is a state.

00:45:57.880 --> 00:45:59.879
What should be the
edge connecting them.

00:45:59.879 --> 00:46:01.420
AUDIENCE: What other
item you got is.

00:46:01.420 --> 00:46:04.170
AUDIENCE: Is that
after a second?

00:46:04.170 --> 00:46:05.930
PROFESSOR: So the
distance between these

00:46:05.930 --> 00:46:07.550
won't be a second, right?

00:46:07.550 --> 00:46:09.130
If I have to wait
for five seconds to

00:46:09.130 --> 00:46:11.670
accumulate enough to
issue this build order

00:46:11.670 --> 00:46:13.825
that would get me
the state then--

00:46:13.825 --> 00:46:15.325
AUDIENCE: The time
you have to wait?

00:46:18.060 --> 00:46:20.221
PROFESSOR: So that's what
I would put on an edge.

00:46:20.221 --> 00:46:22.220
So this way I don't have
to keep track of money,

00:46:22.220 --> 00:46:23.678
I don't have to
keep track of time.

00:46:23.678 --> 00:46:25.130
So the graph is smaller.

00:46:25.130 --> 00:46:27.350
So I can look into
bigger graphs.

00:46:27.350 --> 00:46:30.700
If I do this, what
algorithm do I use?

00:46:30.700 --> 00:46:33.404
To find my strategy?

00:46:33.404 --> 00:46:34.320
AUDIENCE: [INAUDIBLE].

00:46:34.320 --> 00:46:36.310
[INTERPOSING VOICES]

00:46:36.310 --> 00:46:38.100
PROFESSOR: So no time, no money.

00:46:41.650 --> 00:46:43.670
And [? extra ?].

00:46:43.670 --> 00:46:46.010
So this looks
reasonably easy, right?

00:46:46.010 --> 00:46:49.280
I mean, if you want to get
from one state to another,

00:46:49.280 --> 00:46:50.890
you see what you'd
have to build,

00:46:50.890 --> 00:46:52.870
you see how much
it costs, and you

00:46:52.870 --> 00:46:55.910
see how much you have to wait
to accumulate those resources.

00:46:55.910 --> 00:46:57.435
Except there's one glitch.

00:47:01.840 --> 00:47:02.990
How do we deal with this?

00:47:02.990 --> 00:47:05.880
How do we make sure that we do
our attacks on time and how do

00:47:05.880 --> 00:47:10.518
we know that we're-- how
do we keep track of them?

00:47:10.518 --> 00:47:12.881
AUDIENCE: What is this
again representing?

00:47:12.881 --> 00:47:14.880
PROFESSOR: So this is
that every two minutes you

00:47:14.880 --> 00:47:16.930
have to have a
number of Zerglings

00:47:16.930 --> 00:47:19.039
that you're sending
to attack the enemy.

00:47:19.039 --> 00:47:21.080
And the number of Zerglings
that you need to have

00:47:21.080 --> 00:47:23.670
depends on the time and
it depends on the upgrades

00:47:23.670 --> 00:47:24.220
that you got.

00:47:28.650 --> 00:47:30.140
So how do we keep track of this?

00:47:34.830 --> 00:47:37.650
AUDIENCE: If the edges
are a function of time,

00:47:37.650 --> 00:47:46.853
then just know that at radius
120-- at radius 120 over 5,

00:47:46.853 --> 00:47:50.610
then you'd have to
send more Zerglings.

00:47:50.610 --> 00:47:55.110
PROFESSOR: So what if not all
the edges have the same weight.

00:47:55.110 --> 00:47:57.840
So let's look at how a graph
looks like for a little bit.

00:47:57.840 --> 00:48:00.810
So we're going to
have an initial state,

00:48:00.810 --> 00:48:06.710
say one hatchery and six
drones and one overlord.

00:48:06.710 --> 00:48:11.016
And we want to
build a new drone.

00:48:11.016 --> 00:48:12.390
Say we want to
build a new drone.

00:48:12.390 --> 00:48:15.060
A drone costs 50 minerals.

00:48:15.060 --> 00:48:17.730
We have six drones.

00:48:17.730 --> 00:48:19.890
Each drone gets us
eight minerals a second,

00:48:19.890 --> 00:48:22.510
so in one second we're
going to get 48 minerals.

00:48:22.510 --> 00:48:25.180
So bummer, we have to wait for
two seconds to build one drone.

00:48:29.700 --> 00:48:34.660
And now we're going to be in
the state of one hatchery, seven

00:48:34.660 --> 00:48:39.830
drones, one overlord.

00:48:39.830 --> 00:48:45.900
If you said we want to
build a hatchery-- then

00:48:45.900 --> 00:48:50.260
we're going to need to
accumulate 400 or 450.

00:48:50.260 --> 00:48:56.340
Oh, we have to accumulate 450,
using six drones, 48 minerals,

00:48:56.340 --> 00:48:58.222
so I guess nine seconds.

00:48:58.222 --> 00:49:00.180
So we're going to have
to wait for nine seconds

00:49:00.180 --> 00:49:01.070
to get that money.

00:49:03.772 --> 00:49:05.230
And then when we
build, we're going

00:49:05.230 --> 00:49:07.240
to spend the drone
building, because it's

00:49:07.240 --> 00:49:08.500
going to turn into a hatchery.

00:49:08.500 --> 00:49:12.330
And then we're going to end
up with two hatcheries, five

00:49:12.330 --> 00:49:14.820
drones, and one overlord.

00:49:14.820 --> 00:49:17.030
So edges have different weights.

00:49:17.030 --> 00:49:19.937
So I can't look at the radius
in terms of number of his edges.

00:49:19.937 --> 00:49:21.770
AUDIENCE: Everything
builds instantaneously.

00:49:24.750 --> 00:49:25.696
PROFESSOR: Yeah, sure.

00:49:25.696 --> 00:49:28.070
AUDIENCE: You could keep track
of just the total distance

00:49:28.070 --> 00:49:30.370
from whatever starting
build you are?

00:49:30.370 --> 00:49:32.250
AUDIENCE: Actually,
if the distance

00:49:32.250 --> 00:49:35.980
from the origin to where
you're at is a multiple of 120,

00:49:35.980 --> 00:49:38.820
then you should
have another state

00:49:38.820 --> 00:49:42.288
that you have to [INAUDIBLE].

00:49:42.288 --> 00:49:46.240
AUDIENCE: Assuming you have any
drones left, hopefully you do.

00:49:46.240 --> 00:49:48.654
PROFESSOR: So that's modeling.

00:49:48.654 --> 00:49:50.570
One way of doing it is
sure, model every round

00:49:50.570 --> 00:49:53.190
of the attack as one,
every round of harassment

00:49:53.190 --> 00:49:56.460
is one there in the graph,
and we can do it that way.

00:49:56.460 --> 00:49:58.760
Is that what you're saying?

00:49:58.760 --> 00:50:01.562
So you can't-- once
you're at 120 seconds,

00:50:01.562 --> 00:50:04.020
you have to do an attack and
then you get to the next layer

00:50:04.020 --> 00:50:05.320
in the graph.

00:50:05.320 --> 00:50:05.900
AUDIENCE: That makes
a lot of sense.

00:50:05.900 --> 00:50:07.900
AUDIENCE: Of course that's
what we were thinking.

00:50:07.900 --> 00:50:09.524
PROFESSOR: How about
let's not do that.

00:50:09.524 --> 00:50:11.790
How about let's represent
it without layers?

00:50:11.790 --> 00:50:12.610
So that's good.

00:50:12.610 --> 00:50:14.193
You're getting closer
to the solution.

00:50:14.193 --> 00:50:16.620
It is much better than
representing every time.

00:50:16.620 --> 00:50:18.926
Write the number of
layers this time over 120,

00:50:18.926 --> 00:50:20.720
it's a huge improvement.

00:50:20.720 --> 00:50:24.070
Well, we can do it
without any-- we can do it

00:50:24.070 --> 00:50:27.384
without any time
notion whatsoever.

00:50:27.384 --> 00:50:29.050
Let's see, can I let
you think about it?

00:50:29.050 --> 00:50:31.135
Oh, I can let you think
about it for 30 seconds.

00:50:37.490 --> 00:50:39.377
So there's a key
insight here that--

00:50:39.377 --> 00:50:39.960
AUDIENCE: Ooh.

00:50:39.960 --> 00:50:42.256
PROFESSOR: Yeah.

00:50:42.256 --> 00:50:44.740
AUDIENCE: [INAUDIBLE] but if
you figure how much time has

00:50:44.740 --> 00:50:47.050
elapsed, based on
the items we have

00:50:47.050 --> 00:50:48.766
and our starting state, right?

00:50:48.766 --> 00:50:50.140
Because if we have
two hatcheries

00:50:50.140 --> 00:50:51.625
and we started
with one hatchery,

00:50:51.625 --> 00:50:53.730
we know that at least
nine seconds has elapsed.

00:50:53.730 --> 00:50:56.190
PROFESSOR: Well, so I like the
first part of what you said,

00:50:56.190 --> 00:50:58.350
the second part is
too complicated.

00:50:58.350 --> 00:51:01.740
But we can know
what time we're at.

00:51:01.740 --> 00:51:03.190
Why?

00:51:03.190 --> 00:51:05.350
AUDIENCE: Because it takes
a certain amount of time

00:51:05.350 --> 00:51:09.241
to achieve everything,
each thing.

00:51:09.241 --> 00:51:11.366
AUDIENCE: Are we assuming
that we take the shortest

00:51:11.366 --> 00:51:14.931
path to get to each
state that we're at?

00:51:14.931 --> 00:51:16.430
PROFESSOR: So we're
using the extra.

00:51:19.250 --> 00:51:20.510
How does the extra work?

00:51:20.510 --> 00:51:22.630
You have a queue,
a priority queue.

00:51:22.630 --> 00:51:25.140
You extract a node, you
look at the neighbors.

00:51:25.140 --> 00:51:26.650
When you extract
the node, do you

00:51:26.650 --> 00:51:30.557
know the distance to that node?

00:51:30.557 --> 00:51:31.640
AUDIENCE: Can you explain?

00:51:31.640 --> 00:51:33.110
You ask?

00:51:33.110 --> 00:51:34.045
PROFESSOR: I'm asking.

00:51:34.045 --> 00:51:36.220
AUDIENCE: I know, but like
the node asks and says,

00:51:36.220 --> 00:51:39.074
how far away are you?

00:51:39.074 --> 00:51:41.490
PROFESSOR: So you need to keep
that in the priority queue.

00:51:41.490 --> 00:51:44.100
So the extra--
the main invariant

00:51:44.100 --> 00:51:46.330
is that once you
pull out the node,

00:51:46.330 --> 00:51:49.467
you're not going to find any
shorter path to that node.

00:51:49.467 --> 00:51:51.050
So you already know
the shortest path.

00:51:51.050 --> 00:51:53.860
That how you sort the nodes
in the priority queue.

00:51:53.860 --> 00:51:57.920
So when we're at
a configuration--

00:51:57.920 --> 00:52:00.330
Say we're at some
configuration here,

00:52:00.330 --> 00:52:07.090
two hatches, six drones,
and five Zerglings.

00:52:07.090 --> 00:52:11.780
We already know that, say
we're at time 119 seconds.

00:52:11.780 --> 00:52:15.940
If what I want to do next
is build another hatchery,

00:52:15.940 --> 00:52:18.836
then I have to wait, what, six
drones, same thing as before.

00:52:18.836 --> 00:52:20.460
I have to wait for
nine seconds, right?

00:52:23.450 --> 00:52:25.850
So the edge would
look like this.

00:52:25.850 --> 00:52:28.270
And then we're going to get
to three hatcheries, five

00:52:28.270 --> 00:52:31.480
drones, five Zerglings.

00:52:31.480 --> 00:52:35.200
This crosses a one, this crosses
a two-minute boundary, right?

00:52:39.110 --> 00:52:40.810
So when I cross
this boundary, I'd

00:52:40.810 --> 00:52:42.980
better have enough
Zerglings to do an attack.

00:52:42.980 --> 00:52:46.660
Do I have enough
Zerglings to do an attack?

00:52:46.660 --> 00:52:47.520
No.

00:52:47.520 --> 00:52:48.920
So is this a valid move?

00:52:48.920 --> 00:52:52.610
Is this the valid
edge in our graph?

00:52:52.610 --> 00:52:54.480
It's not.

00:52:54.480 --> 00:52:56.700
So when you're at a node,
you already know the time

00:52:56.700 --> 00:52:58.120
that you need to
get to that node,

00:52:58.120 --> 00:53:00.070
so when you generate
the neighbors,

00:53:00.070 --> 00:53:01.630
you can check for
each edge to see

00:53:01.630 --> 00:53:04.149
it crosses that 120 second game.

00:53:04.149 --> 00:53:05.190
Now let's assume it does.

00:53:05.190 --> 00:53:06.564
Let's see how this
works and this

00:53:06.564 --> 00:53:08.350
is the last thing we're doing.

00:53:08.350 --> 00:53:12.260
So suppose you have two
hatcheries, six drones,

00:53:12.260 --> 00:53:14.390
and eight Zerglings.

00:53:14.390 --> 00:53:18.380
And you're going to
build that same hatchery.

00:53:18.380 --> 00:53:22.990
So you're going to go
past this 120 second mark.

00:53:22.990 --> 00:53:24.635
What state are you
going to end up in?

00:53:27.250 --> 00:53:28.707
How many hatcheries?

00:53:28.707 --> 00:53:29.960
AUDIENCE: Three.

00:53:29.960 --> 00:53:31.140
PROFESSOR: OK.

00:53:31.140 --> 00:53:32.330
How many drones.

00:53:32.330 --> 00:53:33.585
AUDIENCE: Five.

00:53:33.585 --> 00:53:34.834
PROFESSOR: How many Zerglings.

00:53:34.834 --> 00:53:37.618
AUDIENCE: Two.

00:53:37.618 --> 00:53:39.010
PROFESSOR: Yes.

00:53:39.010 --> 00:53:42.950
So key elements, two
Zerglings, because this edge

00:53:42.950 --> 00:53:46.200
crosses the 120-second
harassment boundary,

00:53:46.200 --> 00:53:47.800
so you have to send
in six Zerglings

00:53:47.800 --> 00:53:50.370
and you're going to lose them.

00:53:50.370 --> 00:53:53.580
So we're taking advantage of
how the extra works to sort

00:53:53.580 --> 00:53:55.620
of generate our
edges on the fly.

00:53:55.620 --> 00:53:58.390
So we wouldn't be able
to regenerate this graph,

00:53:58.390 --> 00:53:59.610
even if we wanted to have to.

00:53:59.610 --> 00:54:01.610
We have to work with the
implicit representation

00:54:01.610 --> 00:54:04.610
and, as we learn the
distances to the nodes,

00:54:04.610 --> 00:54:07.990
the minimum distances,
we also learned the edges

00:54:07.990 --> 00:54:10.165
that we have coming
out of those nodes.

00:54:10.165 --> 00:54:12.540
AUDIENCE: So it's kinda of
like this graph that's growing

00:54:12.540 --> 00:54:14.373
and we're like as it
gets to a certain point

00:54:14.373 --> 00:54:17.340
we kill a bunch of paths
and then it keeps on going.

00:54:17.340 --> 00:54:19.459
PROFESSOR: Yeah.

00:54:19.459 --> 00:54:20.500
Doesn't this makes sense?

00:54:25.010 --> 00:54:27.420
So the good news is
that this is like we're

00:54:27.420 --> 00:54:29.310
training you to run
a 10-mile marathon,

00:54:29.310 --> 00:54:32.230
so you can run 50
meters for the test.

00:54:32.230 --> 00:54:33.730
Let's still try to
get it, because I

00:54:33.730 --> 00:54:35.880
think it's a cool problem.