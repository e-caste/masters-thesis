WEBVTT

00:00:00.040 --> 00:00:02.460
The following content is
provided under a Creative

00:00:02.460 --> 00:00:03.870
Commons license.

00:00:03.870 --> 00:00:06.910
Your support will help MIT
OpenCourseWare continue to

00:00:06.910 --> 00:00:10.560
offer high quality educational
resources for free.

00:00:10.560 --> 00:00:13.460
To make a donation or view
additional materials from

00:00:13.460 --> 00:00:19.290
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:19.290 --> 00:00:20.540
ocw.mit.edu.

00:00:22.790 --> 00:00:24.880
PROFESSOR: For those of you who
are unaccustomed to seeing

00:00:24.880 --> 00:00:27.325
it, that blue stuff through
the window is called sky.

00:00:32.159 --> 00:00:33.340
OK.

00:00:33.340 --> 00:00:37.220
I left you last time
with a question.

00:00:37.220 --> 00:00:41.680
I'd shown you a bisection search
implementation, or I

00:00:41.680 --> 00:00:44.550
should say putative
implementation of the square

00:00:44.550 --> 00:00:49.400
root, and told you that it was
flawed, and asked you to think

00:00:49.400 --> 00:00:51.610
about what was wrong with it.

00:00:51.610 --> 00:00:53.320
So first, I'd just like
to take a poll.

00:00:53.320 --> 00:00:57.230
How many of you know what the
problem is, or at least what a

00:00:57.230 --> 00:00:59.280
problem is?

00:00:59.280 --> 00:01:01.320
OK well that's a good start.

00:01:01.320 --> 00:01:04.319
And I won't ask how many of
you don't know, because I

00:01:04.319 --> 00:01:06.700
presume that's the
rest of you.

00:01:06.700 --> 00:01:08.760
So let's look at it now.

00:01:08.760 --> 00:01:11.750
I'm not going to ask you the
answer, because I want to show

00:01:11.750 --> 00:01:13.890
people how to find it.

00:01:13.890 --> 00:01:18.500
So here's a slightly simplified
version of it.

00:01:25.920 --> 00:01:28.300
Just get rid of this stuff here,
so it doesn't confuse

00:01:28.300 --> 00:01:29.550
the picture.

00:01:35.070 --> 00:01:38.120
So this is roughly the one we
looked at on Tuesday, but I

00:01:38.120 --> 00:01:40.250
just took out some print
statements and things and

00:01:40.250 --> 00:01:42.230
simplified it.

00:01:42.230 --> 00:01:46.770
And let's just run it.

00:01:46.770 --> 00:01:49.620
And we'll run it with
trying to find the

00:01:49.620 --> 00:01:53.610
square root of 0.5.

00:01:53.610 --> 00:01:55.320
See what happens
when we run it.

00:02:01.730 --> 00:02:04.280
Well, not much happens
when we run it.

00:02:04.280 --> 00:02:05.700
Actually quite a lot
is happening.

00:02:05.700 --> 00:02:08.000
We just can't see it.

00:02:08.000 --> 00:02:12.960
So this program is running
longer than I expected it to.

00:02:12.960 --> 00:02:18.990
So if you go to the keyboard and
you hit Control and C. It

00:02:18.990 --> 00:02:20.190
will interrupt the program.

00:02:20.190 --> 00:02:23.980
It generates what's called
a keyboard interrupt,

00:02:23.980 --> 00:02:27.430
and it stops it.

00:02:27.430 --> 00:02:29.490
And it tells us where it
happened to stop it.

00:02:29.490 --> 00:02:33.300
It happened to stop
it in line seven--

00:02:33.300 --> 00:02:36.030
the test of the while loop.

00:02:36.030 --> 00:02:38.650
And the problem is, the program
just seemed to be

00:02:38.650 --> 00:02:40.740
running forever.

00:02:40.740 --> 00:02:45.240
So despite my, perhaps
persuasive, argument last time

00:02:45.240 --> 00:02:48.070
about the decrementing function,
there's clearly a

00:02:48.070 --> 00:02:50.220
flaw in my logic.

00:02:50.220 --> 00:02:53.730
And, in fact, it does not
always terminate.

00:02:53.730 --> 00:02:57.510
So what do we do about it?

00:02:57.510 --> 00:02:59.260
Well this is the main trick.

00:02:59.260 --> 00:03:03.410
And one of the things I need
you to understand this

00:03:03.410 --> 00:03:08.010
semester is perhaps the most
important thing you'll learn

00:03:08.010 --> 00:03:10.940
is how to debug programs.

00:03:10.940 --> 00:03:14.330
Too many people think the hard
part is done when they write

00:03:14.330 --> 00:03:16.060
the code the first time.

00:03:16.060 --> 00:03:18.500
No, that's actually
the easy part.

00:03:18.500 --> 00:03:22.820
The hard part is actually
getting it to work.

00:03:22.820 --> 00:03:27.600
So the thing you need to learn
is how to debug code, and the

00:03:27.600 --> 00:03:29.580
nice thing is it's a
transferable skill.

00:03:29.580 --> 00:03:34.010
It's also fine for debugging
lab experiences or family

00:03:34.010 --> 00:03:38.290
members or anything else that
can be seriously awry.

00:03:38.290 --> 00:03:41.520
So the way I do it when I
program is typically with

00:03:41.520 --> 00:03:43.660
print statements.

00:03:43.660 --> 00:03:47.950
So the fact that the program was
running forever, suggests

00:03:47.950 --> 00:03:50.510
that I'm not exiting
the while loop.

00:03:50.510 --> 00:03:53.550
So clearly, I need to print
something in the while loop.

00:03:56.350 --> 00:04:00.080
And the only three variables
it seems to be using are

00:04:00.080 --> 00:04:04.280
answer, low, and high.

00:04:04.280 --> 00:04:06.110
Those are the three
that change.

00:04:06.110 --> 00:04:09.680
So let's see what
the value is.

00:04:09.680 --> 00:04:13.430
Notice, by the way, that I
actually went to the trouble

00:04:13.430 --> 00:04:18.899
to type ans equals ans, low
equals low, et cetera.

00:04:18.899 --> 00:04:22.225
A lot of people would just say,
OK I'm going to print and

00:04:22.225 --> 00:04:25.420
they'll ans comma
low comma high.

00:04:25.420 --> 00:04:27.040
And then when they run
the code they'll

00:04:27.040 --> 00:04:29.440
forget which is which.

00:04:29.440 --> 00:04:33.880
The most common problem that
people have in debugging

00:04:33.880 --> 00:04:38.410
programs is that
they are lazy.

00:04:38.410 --> 00:04:41.330
They think they're saving
themselves work, and in fact

00:04:41.330 --> 00:04:42.830
they're creating work.

00:04:42.830 --> 00:04:45.390
So my first piece of
advice to you as

00:04:45.390 --> 00:04:49.100
debuggers is don't be lazy.

00:04:49.100 --> 00:04:51.970
Maybe you heard this from your
mother at some point in life,

00:04:51.970 --> 00:04:53.080
or your father.

00:04:53.080 --> 00:04:55.000
But now you're hearing
it from me.

00:04:55.000 --> 00:04:58.850
Try and just do it right
the first time.

00:04:58.850 --> 00:05:00.985
So let's run it and see
what happens now.

00:05:04.470 --> 00:05:06.085
Well at least it's printing
some output.

00:05:09.550 --> 00:05:13.610
And it's chugging away
and chug-- uh-oh--

00:05:13.610 --> 00:05:18.580
so now, we see we have
a real problem.

00:05:18.580 --> 00:05:22.820
We've reached a fixed point,
where every time through the

00:05:22.820 --> 00:05:25.610
loop, nothing is changing.

00:05:25.610 --> 00:05:27.760
Well the first time we go
through the loop and nothing

00:05:27.760 --> 00:05:31.550
changes we know we're in
trouble, because nothing's

00:05:31.550 --> 00:05:32.620
going to ever change.

00:05:32.620 --> 00:05:35.790
And therefore, we're going to
be in the loop forever.

00:05:35.790 --> 00:05:39.120
So we see, I've gone
to a stage where

00:05:39.120 --> 00:05:42.660
everything equals 0.5.

00:05:42.660 --> 00:05:46.620
And now if I go back and look at
the code, and I ask myself

00:05:46.620 --> 00:05:52.070
the question well what happens
when everything is 0.5, and I

00:05:52.070 --> 00:05:54.040
can see the problem.

00:05:54.040 --> 00:05:55.480
It's this statement here.

00:06:00.270 --> 00:06:01.670
Yep, turn it around maybe.

00:06:04.590 --> 00:06:08.600
But that's never going to change
now, because it's 0.5

00:06:08.600 --> 00:06:15.230
plus 0.5, divided by 2 is 0.5.

00:06:15.230 --> 00:06:17.610
And it'll just stay
there forever.

00:06:17.610 --> 00:06:19.030
So that's my problem.

00:06:19.030 --> 00:06:22.770
I have to somehow change
my code now, so that

00:06:22.770 --> 00:06:24.020
this doesn't happen.

00:06:26.830 --> 00:06:29.610
So what is the problem?

00:06:29.610 --> 00:06:31.950
Now somebody can tell
me, simply.

00:06:31.950 --> 00:06:34.130
What is the problem here?

00:06:34.130 --> 00:06:37.570
What was the flaw in my
reasoning when I first set

00:06:37.570 --> 00:06:41.026
this program up?

00:06:41.026 --> 00:06:42.433
Yeah?

00:06:42.433 --> 00:06:44.652
AUDIENCE: [INAUDIBLE]

00:06:44.652 --> 00:06:46.223
PROFESSOR: Louder please?

00:06:46.223 --> 00:06:48.155
AUDIENCE: You don't have a high
minus low is less than or

00:06:48.155 --> 00:06:52.019
equal to epsilon.

00:06:52.019 --> 00:06:54.700
PROFESSOR: So the comment was I
don't have a high minus low

00:06:54.700 --> 00:06:58.230
is less than or equal
to epsilon.

00:06:58.230 --> 00:07:01.570
True, but that's not really
the real flaw.

00:07:01.570 --> 00:07:03.569
Yeah?

00:07:03.569 --> 00:07:05.048
AUDIENCE: The fraction is
greater than the original

00:07:05.048 --> 00:07:08.499
fraction, so the solution is
not in the search space.

00:07:08.499 --> 00:07:09.980
PROFESSOR: Exactly.

00:07:09.980 --> 00:07:16.700
So the answer is the problem was
that I did a search in a

00:07:16.700 --> 00:07:20.640
region, and the answer wasn't
in that region.

00:07:20.640 --> 00:07:25.770
Because the square root
of 0.5 does not lie

00:07:25.770 --> 00:07:29.650
between 0 and 0.5.

00:07:29.650 --> 00:07:32.860
Silly me, when I thought about
it, I didn't think of finding

00:07:32.860 --> 00:07:36.680
the square root of numbers
less than 1.

00:07:36.680 --> 00:07:40.380
So what's a simple fix?

00:07:40.380 --> 00:07:44.500
Well what I can do is the
following: I'll go back and

00:07:44.500 --> 00:07:48.895
say high is going to be
the max of x and 1.

00:07:54.200 --> 00:07:57.430
So now I'm going to ensure that
the square root actually

00:07:57.430 --> 00:07:59.200
does lie in the region
I'm searching.

00:08:02.050 --> 00:08:02.870
I hope.

00:08:02.870 --> 00:08:05.498
Let's run it.

00:08:05.498 --> 00:08:07.290
Ah.

00:08:07.290 --> 00:08:09.580
All right, well I got to some
stuff at the end which you

00:08:09.580 --> 00:08:14.800
shouldn't worry about, but it
found something that I guess

00:08:14.800 --> 00:08:16.050
is a good enough answer.

00:08:21.724 --> 00:08:38.990
We'll get rid of that code I
put in this morning which

00:08:38.990 --> 00:08:40.289
we'll get to this later.

00:08:48.090 --> 00:08:52.450
OK so I've now fixed
the program.

00:08:52.450 --> 00:08:53.410
Everyone with me on that?

00:08:53.410 --> 00:08:55.750
Any questions?

00:08:55.750 --> 00:08:59.600
And the thing to understand is
conceptually what was wrong

00:08:59.600 --> 00:09:03.290
with my reasoning, that I'm
doing a search in a region

00:09:03.290 --> 00:09:05.140
where the answer doesn't lie.

00:09:05.140 --> 00:09:06.840
So I'm not going to find it.

00:09:06.840 --> 00:09:10.920
And the other thing to
understand is my systematic

00:09:10.920 --> 00:09:13.650
way of finding the bug.

00:09:13.650 --> 00:09:16.120
Now I confess I knew the bug
was there when I wrote the

00:09:16.120 --> 00:09:18.630
code, so I kind of cheated
with the debugging.

00:09:18.630 --> 00:09:20.380
But even if I hadn't
known, this is what

00:09:20.380 --> 00:09:21.490
I would have done.

00:09:21.490 --> 00:09:24.610
I would have put in that
print statement.

00:09:24.610 --> 00:09:28.770
All right, so now we have
actually a pretty good piece

00:09:28.770 --> 00:09:31.580
of code for finding
square roots.

00:09:31.580 --> 00:09:34.540
And as we looked at on Tuesday,
I can use the same

00:09:34.540 --> 00:09:35.890
piece of code.

00:09:35.890 --> 00:09:39.640
I can modify it to get cube
roots, or fourth roots, or

00:09:39.640 --> 00:09:41.160
fifth roots.

00:09:41.160 --> 00:09:46.030
And so I have a general
framework for doing things.

00:09:46.030 --> 00:09:52.020
But it's pretty unsatisfying in
that sense, because let's

00:09:52.020 --> 00:09:54.320
look at it.

00:09:54.320 --> 00:09:58.060
If I wanted to find the square
root of some number other than

00:09:58.060 --> 00:10:04.216
0.5, I have to go and edit the
code, replace the assignment

00:10:04.216 --> 00:10:07.940
to x by whatever I'm
trying to do.

00:10:07.940 --> 00:10:11.880
If I want to do cube roots I
have to cut and paste and edit

00:10:11.880 --> 00:10:13.130
and do things.

00:10:15.180 --> 00:10:19.560
There's no very good way to now
embed this piece of code

00:10:19.560 --> 00:10:22.390
inside a larger computation.

00:10:22.390 --> 00:10:27.330
Imagine that I've got some
10,000 line program that needs

00:10:27.330 --> 00:10:31.010
to find the square root six or
seven times, well now I'm

00:10:31.010 --> 00:10:33.500
going to have six or seven
copies of this code in my

00:10:33.500 --> 00:10:36.440
program, for every time I
need the square root.

00:10:39.230 --> 00:10:41.535
Clearly not what
you want to do.

00:10:44.070 --> 00:10:49.870
In general, having more
code is a bad thing.

00:10:49.870 --> 00:10:53.460
So it's not like you're given an
essay to write and someone

00:10:53.460 --> 00:10:57.030
tells you it's got to be 5,000
words, and you just sweat

00:10:57.030 --> 00:11:01.810
blood trying to figure out how
to stretch it to be that long.

00:11:01.810 --> 00:11:04.020
In code, it's the other
way around.

00:11:04.020 --> 00:11:07.520
Most of the time we want to make
it shorter not longer.

00:11:07.520 --> 00:11:11.330
And the reason we want to do
that is the difficulty of

00:11:11.330 --> 00:11:16.280
getting code to work grows,
maybe even grows

00:11:16.280 --> 00:11:19.860
quadratically, or worse but
the size of the code.

00:11:19.860 --> 00:11:21.820
So the more code you have,
the harder it is

00:11:21.820 --> 00:11:23.370
to get it to work.

00:11:23.370 --> 00:11:26.950
So one of the things good
programmers learn to do is

00:11:26.950 --> 00:11:30.170
write less code.

00:11:30.170 --> 00:11:32.840
And so we don't measure
productivity of a programmer

00:11:32.840 --> 00:11:36.540
by the number of lines of code
they produce each day, but we

00:11:36.540 --> 00:11:38.890
measure it by the amount
of functionality they

00:11:38.890 --> 00:11:40.560
produce each day.

00:11:40.560 --> 00:11:43.390
And we give them bonus points
if they achieve the desired

00:11:43.390 --> 00:11:46.610
functionality with less code.

00:11:46.610 --> 00:11:51.470
So let's talk about how
we can write less code

00:11:51.470 --> 00:11:54.980
and accomplish more.

00:11:54.980 --> 00:11:59.320
Well to do that, we're going
to look at a new language

00:11:59.320 --> 00:12:00.090
mechanism--

00:12:00.090 --> 00:12:03.410
actually not new, but
new to this class--

00:12:03.410 --> 00:12:05.750
called a function.

00:12:05.750 --> 00:12:11.310
But before we do that, I want
to pull back and talk about

00:12:11.310 --> 00:12:14.880
what it is we hope to accomplish
by introducing

00:12:14.880 --> 00:12:18.610
functions into our programming
language.

00:12:18.610 --> 00:12:24.160
We want to provide a mechanism
that provides for two things:

00:12:24.160 --> 00:12:31.900
decomposition and abstraction.

00:12:42.400 --> 00:12:46.590
What decomposition does, is
it creates structure.

00:12:55.770 --> 00:12:59.740
It allows us to break our
program up into something

00:12:59.740 --> 00:13:00.990
called modules.

00:13:04.370 --> 00:13:07.440
And the module we'll focus on
today is function, but later

00:13:07.440 --> 00:13:10.320
we'll see there's another
important kind of module in

00:13:10.320 --> 00:13:13.900
Python called the class.

00:13:13.900 --> 00:13:22.650
And the advantage of a module is
it should be self-contained

00:13:22.650 --> 00:13:23.900
and reusable.

00:13:26.010 --> 00:13:30.510
So it's a self-contained unit
of functionality that can be

00:13:30.510 --> 00:13:32.086
used in multiple contexts.

00:13:35.680 --> 00:13:39.310
Abstraction suppresses
details.

00:13:48.410 --> 00:13:52.620
It allows us to use a piece
of code as if it

00:13:52.620 --> 00:13:55.070
were a black box.

00:13:55.070 --> 00:13:59.870
That is, something whose
interior details we can't see,

00:13:59.870 --> 00:14:03.640
don't need to see, and shouldn't
even want to see.

00:14:06.670 --> 00:14:09.220
We only need to understand
what it does,

00:14:09.220 --> 00:14:11.580
not how it does it.

00:14:11.580 --> 00:14:15.610
And that lets us use code
that other people

00:14:15.610 --> 00:14:18.620
have written easily.

00:14:18.620 --> 00:14:21.095
And, in fact, use code that
we have written easily.

00:14:25.180 --> 00:14:28.790
It's one of those few occasions
where I think Thomas

00:14:28.790 --> 00:14:32.900
Gray was right, when he said,
"ignorance is bliss."

00:14:32.900 --> 00:14:35.505
Sometimes knowing
less is better.

00:14:38.040 --> 00:14:41.400
All right, so let's look at
the way functions work.

00:14:41.400 --> 00:14:44.860
The functions let us
break code into

00:14:44.860 --> 00:14:49.390
reusable, coherent pieces.

00:14:49.390 --> 00:14:52.930
Now we've already looked at
similar kinds of things.

00:14:52.930 --> 00:14:57.090
When we looked at say floating
point numbers, and we wrote

00:14:57.090 --> 00:15:01.050
operations like plus or divide,
whatever, we didn't

00:15:01.050 --> 00:15:03.240
worry about how they
were actually

00:15:03.240 --> 00:15:05.460
implemented in the machine.

00:15:05.460 --> 00:15:08.030
We said OK they do something,
they're kind of like dividing

00:15:08.030 --> 00:15:10.570
real numbers, let's not worry
about the details.

00:15:13.810 --> 00:15:15.420
We do that with a
lot of things.

00:15:15.420 --> 00:15:16.590
We looked at strings.

00:15:16.590 --> 00:15:18.740
We concatenated strings.

00:15:18.740 --> 00:15:21.370
Well we didn't worry about
how did Python

00:15:21.370 --> 00:15:22.590
go about doing that.

00:15:22.590 --> 00:15:25.610
We just assumed it did it,
and it had the meaning

00:15:25.610 --> 00:15:27.710
we wanted it to.

00:15:27.710 --> 00:15:32.100
What functions let us do is
extend the language in some

00:15:32.100 --> 00:15:38.290
sense by adding new primitives
that we can use just the way

00:15:38.290 --> 00:15:39.745
we used the built-in
primitives.

00:15:42.250 --> 00:15:46.060
So let's look at an
example here.

00:15:46.060 --> 00:15:47.625
I've written a very
simple function.

00:15:56.440 --> 00:15:59.670
Does something that we actually
did already when we

00:15:59.670 --> 00:16:02.220
looked at square roots.

00:16:02.220 --> 00:16:06.360
It's a function called
within epsilon.

00:16:06.360 --> 00:16:09.990
And let me comment this out
while I'm thinking about it,

00:16:09.990 --> 00:16:11.435
so we don't have to live
with it later.

00:16:17.150 --> 00:16:21.100
And I now want to walk you,
slowly, through what this

00:16:21.100 --> 00:16:23.550
function does.

00:16:23.550 --> 00:16:30.400
So at the start, it uses the
keyword Def, short for define.

00:16:30.400 --> 00:16:32.850
Following that is a name.

00:16:32.850 --> 00:16:35.520
I chose the name
within epsilon.

00:16:35.520 --> 00:16:40.230
You can choose any name you
want for a function.

00:16:40.230 --> 00:16:43.660
I'm strongly encourage you to
choose mnemonic names, that is

00:16:43.660 --> 00:16:47.200
to say names that
have a meaning.

00:16:47.200 --> 00:16:50.430
So in some sense you see it says
within epsilon, and you

00:16:50.430 --> 00:16:53.430
know what it does already.

00:16:53.430 --> 00:16:57.070
Following that, it has three
things called formal

00:16:57.070 --> 00:16:59.050
parameters.

00:16:59.050 --> 00:17:02.460
I'll come back to in a minute,
what that means.

00:17:02.460 --> 00:17:04.690
And then after that, it's
got something called

00:17:04.690 --> 00:17:07.960
the function body.

00:17:07.960 --> 00:17:21.589
So we see that a function has a
name, it has parameters, and

00:17:21.589 --> 00:17:22.839
it has a body.

00:17:25.119 --> 00:17:28.990
The body is the code that's
part of the function.

00:17:36.380 --> 00:17:41.600
In the body, you can write
any code you want.

00:17:41.600 --> 00:17:44.310
Plus, there's something you
can't write outside of a

00:17:44.310 --> 00:17:48.160
function, called return.

00:17:48.160 --> 00:17:54.760
That's a special command that
says whoever calls me has

00:17:54.760 --> 00:17:57.570
called me to have me
compute a value.

00:17:57.570 --> 00:18:01.570
I'm going to return the value
that this person would want.

00:18:01.570 --> 00:18:05.090
And then here we see something
that's very important.

00:18:05.090 --> 00:18:09.380
This is where we get
abstraction, and that's the

00:18:09.380 --> 00:18:12.420
specification of the function.

00:18:12.420 --> 00:18:15.170
And it says here, there
are two pieces to it.

00:18:15.170 --> 00:18:21.720
One that its parameters x, y,
and epsilon, are all floats.

00:18:21.720 --> 00:18:25.015
And furthermore, epsilon
is greater than 0.

00:18:28.450 --> 00:18:34.790
You can imagine this is
important, and it returns true

00:18:34.790 --> 00:18:38.840
if x is within epsilon of y.

00:18:38.840 --> 00:18:42.450
Otherwise it will
return false.

00:18:42.450 --> 00:18:46.960
If I want to use within epsilon,
I don't need to look

00:18:46.960 --> 00:18:49.130
at the code.

00:18:49.130 --> 00:18:53.190
I look instead at the
specification.

00:18:53.190 --> 00:18:56.730
Now here where the code is one
line, maybe I haven't gained a

00:18:56.730 --> 00:18:58.650
lot by looking at the
specification

00:18:58.650 --> 00:18:59.900
instead of the code.

00:18:59.900 --> 00:19:04.350
But you can imagine if the code
were 1,000 lines, I'd

00:19:04.350 --> 00:19:08.900
much rather read the
specification than the code.

00:19:08.900 --> 00:19:14.920
We'll also see for other reasons
later why it's in fact

00:19:14.920 --> 00:19:16.640
dangerous to look at the code.

00:19:20.210 --> 00:19:23.960
How do I use it?

00:19:23.960 --> 00:19:27.210
I use it by invoking it.

00:19:27.210 --> 00:19:34.560
So I could, for example write
something like print within

00:19:34.560 --> 00:19:45.210
epsilon, of two, three, one.

00:19:45.210 --> 00:19:46.460
What's it going to print?

00:19:48.990 --> 00:19:50.840
Pardon?

00:19:50.840 --> 00:19:52.410
Why is it going to print
an error do you think?

00:19:52.410 --> 00:19:54.390
AUDIENCE: Because you
haven't put epsilon.

00:19:54.390 --> 00:19:55.875
PROFESSOR: Ah, typed it wrong.

00:19:55.875 --> 00:19:58.350
Thank you.

00:19:58.350 --> 00:19:59.340
You're correct.

00:19:59.340 --> 00:20:01.320
It would have printed
an error.

00:20:01.320 --> 00:20:04.785
Now what will it print?

00:20:04.785 --> 00:20:06.035
AUDIENCE: [INAUDIBLE]

00:20:08.270 --> 00:20:09.520
PROFESSOR: Sure enough.

00:20:11.840 --> 00:20:19.850
I could also, if I chose,
write something like val

00:20:19.850 --> 00:20:37.575
equals that, then if I want
I could print val.

00:20:42.750 --> 00:20:44.890
Now it's going to print false.

00:20:44.890 --> 00:20:49.760
So within epsilon is just like
plus or something else, does

00:20:49.760 --> 00:20:52.070
some computation,
returns a value.

00:20:52.070 --> 00:20:56.530
I can use that value any place
I could have used an

00:20:56.530 --> 00:20:57.780
expression.

00:20:59.530 --> 00:21:03.130
Now one more thing to
look at with this.

00:21:03.130 --> 00:21:05.825
Suppose I don't return
anything.

00:21:11.800 --> 00:21:14.910
Anyone want to guess what
it's going to do now?

00:21:14.910 --> 00:21:17.830
I point this out, because this
is a very common error.

00:21:17.830 --> 00:21:22.580
People write lots of code,
calculate some wonderful value

00:21:22.580 --> 00:21:25.060
and then forget to return it.

00:21:25.060 --> 00:21:27.830
What's it going to do now?

00:21:27.830 --> 00:21:29.270
Well let's run it and see.

00:21:29.270 --> 00:21:32.770
That, by the way, is a good
habit to get into.

00:21:32.770 --> 00:21:35.730
It's going to return the
special value none.

00:21:35.730 --> 00:21:38.150
Remember we looked at that
earlier, meaning I

00:21:38.150 --> 00:21:41.180
don't have a value.

00:21:41.180 --> 00:21:45.330
So if you see in your code some
none popping up where you

00:21:45.330 --> 00:21:50.820
don't expect it to, it's
probably because you forgot to

00:21:50.820 --> 00:21:53.630
return a value.

00:21:53.630 --> 00:21:54.900
So just keep that in mind.

00:21:57.980 --> 00:22:04.870
All right, now there's a
big advantage of this.

00:22:04.870 --> 00:22:10.630
Once I've written this code I
can now anywhere I want call

00:22:10.630 --> 00:22:14.760
within epsilon, and I don't have
to duplicate the code.

00:22:14.760 --> 00:22:16.010
I only do it once.

00:22:19.040 --> 00:22:22.010
As I said earlier maybe I'm not
gaining much, because the

00:22:22.010 --> 00:22:25.040
body is so short.

00:22:25.040 --> 00:22:29.490
On the other hand, I'm still
gaining something.

00:22:29.490 --> 00:22:35.880
Notice that when I look at the
code down here, it's easy to

00:22:35.880 --> 00:22:39.080
read, I'm printing within
epsilon two, three, and one.

00:22:42.010 --> 00:22:45.360
And I don't have to decode this
and tell me that that's

00:22:45.360 --> 00:22:47.420
what that's doing.

00:22:47.420 --> 00:22:51.920
So if I have a function and I
choose the names properly,

00:22:51.920 --> 00:22:56.460
code that uses the function
is much easier to read.

00:22:56.460 --> 00:22:57.710
And that can be a big value.

00:23:04.000 --> 00:23:06.620
All right, let's look
at another example.

00:23:12.880 --> 00:23:16.440
So here I've got this
function, f.

00:23:19.470 --> 00:23:22.670
I've chose a non-mnemonic name,
because there isn't much

00:23:22.670 --> 00:23:23.920
meaning to this function.

00:23:27.650 --> 00:23:31.220
What f does, it is a
formal parameter x.

00:23:31.220 --> 00:23:34.220
It sets x to x plus 1.

00:23:34.220 --> 00:23:37.650
Then it prints x
and returns x--

00:23:37.650 --> 00:23:38.900
pretty boring.

00:23:46.340 --> 00:23:47.960
So let's see what
it does here.

00:23:52.300 --> 00:23:58.260
So now I'm going to set x to
three, set z, or zed if you

00:23:58.260 --> 00:24:02.330
happen to be Canadian,
to f of x.

00:24:02.330 --> 00:24:05.900
And then print the values
of z and x.

00:24:05.900 --> 00:24:10.330
Also in f, before I return
x, I'm going to print it.

00:24:14.160 --> 00:24:16.030
So let's see what happens
when I run this one.

00:24:20.210 --> 00:24:25.590
It prints four, four,
and then three.

00:24:25.590 --> 00:24:28.570
All right, what's going on?

00:24:28.570 --> 00:24:31.250
Why did it do that?

00:24:31.250 --> 00:24:36.650
Well it's pretty easy to see
why it printed four here,

00:24:36.650 --> 00:24:46.020
because I called f of x with
an x equal to 3, and then I

00:24:46.020 --> 00:24:47.940
incremented it by one, and
then I printed it.

00:24:51.380 --> 00:25:00.120
It's probably also easy to
understand why z was four,

00:25:00.120 --> 00:25:05.200
because I returned the value of
x here, which was four and

00:25:05.200 --> 00:25:06.870
it printed it.

00:25:06.870 --> 00:25:08.750
But why is this x three?

00:25:12.130 --> 00:25:19.550
And the answer is this x and
that x have nothing to do with

00:25:19.550 --> 00:25:20.800
each other.

00:25:23.540 --> 00:25:24.660
Right?

00:25:24.660 --> 00:25:29.050
I could just as easily have
chosen some other value for

00:25:29.050 --> 00:25:35.340
the formal parameter, say
George, and said George is

00:25:35.340 --> 00:25:38.455
equal to George plus 1, print
George, return George.

00:25:42.550 --> 00:25:48.080
There is no relation between the
name of the formal and, in

00:25:48.080 --> 00:25:54.130
this case, x defined in the
calling environment.

00:25:54.130 --> 00:25:57.180
So now let's think about that
by working slowly and

00:25:57.180 --> 00:26:02.120
carefully through what happens
when we call a function.

00:26:05.440 --> 00:26:09.190
So the first thing that happens
at the call, and I'll

00:26:09.190 --> 00:26:22.910
just work it through this one,
is the formal parameter, x in

00:26:22.910 --> 00:26:29.520
this case, is bound--

00:26:29.520 --> 00:26:32.670
and I'll come back to what
binding means, that's a

00:26:32.670 --> 00:26:34.280
critical concept here--

00:26:37.960 --> 00:26:46.805
to the value of the
actual parameter.

00:26:50.300 --> 00:26:58.550
So these are important terms,
actual and formal, which in

00:26:58.550 --> 00:27:02.065
this case, also happens
to be called x.

00:27:07.130 --> 00:27:20.900
But what's happening here, is
upon entry of a function, a

00:27:20.900 --> 00:27:23.020
new scope is created.

00:27:33.160 --> 00:27:35.340
What's a scope?

00:27:35.340 --> 00:27:45.070
A scope is a mapping from
names to objects.

00:27:57.380 --> 00:28:01.510
So if we look at what's going
on over here, we can draw a

00:28:01.510 --> 00:28:03.420
little picture.

00:28:03.420 --> 00:28:04.910
Well before I draw a picture,
I'm going to look at a

00:28:04.910 --> 00:28:07.860
slightly more complicated
example.

00:28:07.860 --> 00:28:10.740
Well, yeah let's do that.

00:28:10.740 --> 00:28:16.530
This one is not in your
handout, but it is

00:28:16.530 --> 00:28:19.900
illustrative of, I think, what's
really going on here.

00:28:32.590 --> 00:28:35.060
Here I've got another
beautifully named function, in

00:28:35.060 --> 00:28:42.250
this case f1, and inside it,
I've defined another function,

00:28:42.250 --> 00:28:45.406
called g, which takes
no arguments.

00:28:48.720 --> 00:28:51.460
I've set x to abc.

00:28:55.460 --> 00:28:58.550
Then I haven't shown you these
assert statements yet, or

00:28:58.550 --> 00:29:00.480
haven't talked about them.

00:29:00.480 --> 00:29:07.350
Assert is a command in which the
keyword assert is followed

00:29:07.350 --> 00:29:10.040
by an expression that
evaluates to

00:29:10.040 --> 00:29:12.950
either true or false.

00:29:12.950 --> 00:29:16.830
If it evaluates to true,
it does nothing.

00:29:16.830 --> 00:29:18.420
It just continues.

00:29:18.420 --> 00:29:21.610
If it evaluates to false,
it stops your

00:29:21.610 --> 00:29:24.480
program dead in its tracks.

00:29:24.480 --> 00:29:28.140
So I've just used it here as a
trick to make my program stop

00:29:28.140 --> 00:29:30.930
when I run it.

00:29:30.930 --> 00:29:36.140
In general, you'll find that
I use asserts quite a lot.

00:29:36.140 --> 00:29:41.020
So for example, in the next
piece of code, which

00:29:41.020 --> 00:29:43.310
is called find root.

00:29:43.310 --> 00:29:47.150
It takes the root, is it square,
or cube, whatever, the

00:29:47.150 --> 00:29:50.690
value, and epsilon.

00:29:50.690 --> 00:29:53.730
It assumes that powers, and
int, and val, and epsilon

00:29:53.730 --> 00:29:57.880
float, in the specification.

00:29:57.880 --> 00:30:01.320
And then you'll notice, I
start by putting in an

00:30:01.320 --> 00:30:04.250
assertion here.

00:30:04.250 --> 00:30:08.610
And what I'm asserting is that
the actuals to which these

00:30:08.610 --> 00:30:12.530
formals are bound, have the
properties the specification

00:30:12.530 --> 00:30:15.080
says they do.

00:30:15.080 --> 00:30:18.150
This is what's called defensive
programming.

00:30:18.150 --> 00:30:21.760
In principle, I shouldn't have
to do that, because in

00:30:21.760 --> 00:30:27.130
principle, nobody should call
this with incorrect values.

00:30:27.130 --> 00:30:29.490
But, in fact, it can happen.

00:30:29.490 --> 00:30:32.550
Programmers occasionally
make mistakes.

00:30:32.550 --> 00:30:36.190
And so I'm protecting myself
by checking that the

00:30:36.190 --> 00:30:39.060
assumptions are met, and
if they're not, my

00:30:39.060 --> 00:30:41.960
program will just stop.

00:30:41.960 --> 00:30:44.550
Then I can go hunt down the fool
that called it with the

00:30:44.550 --> 00:30:46.390
wrong parameters--

00:30:46.390 --> 00:30:47.640
probably myself.

00:30:49.770 --> 00:30:52.760
So asserts are good for that,
and I'll use them a lot for

00:30:52.760 --> 00:30:54.750
these kinds of things.

00:30:54.750 --> 00:30:58.590
I'll also use them when I
think I know what value

00:30:58.590 --> 00:31:01.030
something should be in a program
at some point, and I'm

00:31:01.030 --> 00:31:02.920
not sure it really is.

00:31:02.920 --> 00:31:05.710
I'll assert that it has the
value I think it is.

00:31:05.710 --> 00:31:09.390
I'll assert that x is six, if I
think it's going to be six.

00:31:09.390 --> 00:31:11.840
And then my program will
conveniently stop for me if

00:31:11.840 --> 00:31:13.490
it's not true.

00:31:13.490 --> 00:31:14.820
All right so that's assert.

00:31:19.970 --> 00:31:22.800
Other than that, I think there's
nothing here you

00:31:22.800 --> 00:31:24.050
haven't seen before.

00:31:27.350 --> 00:31:31.610
So what's going to happen, we're
going to step through

00:31:31.610 --> 00:31:33.645
this piece by piece.

00:31:37.220 --> 00:31:45.250
So initially, as we look at it,
we enter the main body of

00:31:45.250 --> 00:31:49.090
the program, which is not
wrapped in a function.

00:31:49.090 --> 00:31:52.210
So what IDLE will do, or the
interpreter will do, is it

00:31:52.210 --> 00:31:57.730
will start by executing
each def.

00:31:57.730 --> 00:32:01.030
But executing a def doesn't do
anything, but put some names

00:32:01.030 --> 00:32:03.570
in the environment.

00:32:03.570 --> 00:32:05.910
Then it will go and start
actually running and

00:32:05.910 --> 00:32:11.440
interpreting the code that's not
nested inside a function.

00:32:11.440 --> 00:32:15.700
So the first thing that will
happen is the interpreter will

00:32:15.700 --> 00:32:20.240
build for me what's
called the scope.

00:32:20.240 --> 00:32:23.680
I've already mentioned,
that's a mapping

00:32:23.680 --> 00:32:27.260
from names to objects.

00:32:27.260 --> 00:32:35.881
So in the outermost scope, it
will first find the name f1.

00:32:41.140 --> 00:32:46.860
F1 it will tell me that f1 maps
to an object that happens

00:32:46.860 --> 00:32:48.110
to be a function.

00:32:53.180 --> 00:32:56.270
So it will come over here--

00:32:56.270 --> 00:32:59.310
and I'm just going to draw some
picture, we'll assume

00:32:59.310 --> 00:33:02.860
that's the memory of
the computer--

00:33:02.860 --> 00:33:05.590
and it will map to something
that happens to be a bunch of

00:33:05.590 --> 00:33:07.210
code, if you will.

00:33:07.210 --> 00:33:08.460
All right?

00:33:11.190 --> 00:33:13.060
It will then stop.

00:33:16.650 --> 00:33:20.650
It will then notice that it's
got, at the outermost level a

00:33:20.650 --> 00:33:21.985
variable called x.

00:33:26.230 --> 00:33:30.500
And that will map to an integer,
which will initially

00:33:30.500 --> 00:33:32.730
have no value in it.

00:33:32.730 --> 00:33:36.830
And then after the assignment,
it will now be bound to the

00:33:36.830 --> 00:33:38.800
object three.

00:33:43.860 --> 00:33:52.030
It will then create another
object z, but before it can

00:33:52.030 --> 00:33:56.250
bind a value to it, it will
invoke the function f1.

00:33:59.460 --> 00:34:02.245
Now the interpreter starts
to execute f1.

00:34:05.460 --> 00:34:11.659
When it does that, it will
create another scope.

00:34:11.659 --> 00:34:13.805
So this is the main scope.

00:34:18.400 --> 00:34:22.310
It will next create a scope
called the f1 scope.

00:34:26.520 --> 00:34:34.500
In that, it will have another
name g, which will be

00:34:34.500 --> 00:34:35.750
bound to some code.

00:34:42.600 --> 00:34:49.489
It will have a name x, which
will be initially

00:34:49.489 --> 00:34:54.302
bound to the actual.

00:34:54.302 --> 00:34:58.750
So in this case, it will be
bound to the object three.

00:35:06.070 --> 00:35:08.480
We'll then eventually
do a print.

00:35:08.480 --> 00:35:13.205
It will involve g, which will
now create the g scope.

00:35:21.500 --> 00:35:29.640
And the g scope will create a
name x, which in this case

00:35:29.640 --> 00:35:32.030
will be bound to
the string abc.

00:35:38.070 --> 00:35:42.670
It will then start executing
g, and it will stop.

00:35:45.890 --> 00:35:47.670
So let's see what
that looks like.

00:35:53.270 --> 00:35:55.865
Sure enough, it got an
assert false, gave

00:35:55.865 --> 00:35:58.630
an assertion error.

00:35:58.630 --> 00:36:05.120
What I can do now is go up to
this debug here, and go to

00:36:05.120 --> 00:36:08.810
what's called a stack viewer.

00:36:08.810 --> 00:36:15.800
Each of these scopes is what's
called a stack frame.

00:36:15.800 --> 00:36:18.890
Now why are they called
stack frames?

00:36:22.110 --> 00:36:28.105
Because when we do it, we begin
with the main scope.

00:36:32.520 --> 00:36:35.955
We call f, and we
get the scope.

00:36:38.830 --> 00:36:42.190
f calls g and we get
the g scope.

00:36:46.450 --> 00:36:50.060
When g completes, which alas
it doesn't because of the

00:36:50.060 --> 00:36:57.820
error, it pops the stack, and
gets rid of the g scope.

00:36:57.820 --> 00:37:02.690
And now the stack is the f and
the main, and then when f

00:37:02.690 --> 00:37:06.180
completes, it will have
just the main.

00:37:06.180 --> 00:37:09.530
So it's last in, first out,
which is typically called a

00:37:09.530 --> 00:37:11.060
stack in computing--

00:37:13.660 --> 00:37:18.520
or a LIFO, if you're a course
15 major, and do accounting.

00:37:18.520 --> 00:37:22.330
So let's look at the
stack viewer.

00:37:22.330 --> 00:37:25.780
And I apologize for the small
type font, but I was unable to

00:37:25.780 --> 00:37:28.970
make it look bigger.

00:37:28.970 --> 00:37:33.200
So it says at the top we've
got an assertion error.

00:37:33.200 --> 00:37:39.240
And then you'll note it's got
three stacks: the main, the f1

00:37:39.240 --> 00:37:41.390
stack, and the g stack.

00:37:41.390 --> 00:37:44.860
I forgot I called
it f1, not f.

00:37:44.860 --> 00:37:47.670
Then I can inspect
them further.

00:37:47.670 --> 00:37:52.350
So the g stack has local
and global variables.

00:37:52.350 --> 00:37:58.850
The local variables include
x, which is equal to abc.

00:37:58.850 --> 00:38:02.310
Globals we'll get to later.

00:38:02.310 --> 00:38:10.040
If I look at f1, it also has a
local called x, but its value

00:38:10.040 --> 00:38:14.390
is now four, not abc.

00:38:14.390 --> 00:38:16.790
And it has a value called
g, which is a

00:38:16.790 --> 00:38:21.470
function, as we discussed.

00:38:21.470 --> 00:38:32.660
And if I look at main, it has a
bunch of things, but it has

00:38:32.660 --> 00:38:35.480
everything that's available in
the interpreter, which because

00:38:35.480 --> 00:38:38.200
we've looked at within
epsilon it's there.

00:38:38.200 --> 00:38:42.730
But you'll notice it's x is 3.

00:38:42.730 --> 00:38:44.340
All right?

00:38:44.340 --> 00:38:48.860
So the stack viewer can be very
handy, to look at what

00:38:48.860 --> 00:38:50.610
you've got, when you've
got a bunch of calls.

00:38:53.720 --> 00:39:00.010
Now if we go back to our code
here, and we'll take this out.

00:39:00.010 --> 00:39:07.015
And suppose what we do is
we assert false here.

00:39:14.510 --> 00:39:23.980
Now if we look at the stack
viewer, we see that we have f1

00:39:23.980 --> 00:39:27.780
in main, but g is
no longer there.

00:39:27.780 --> 00:39:29.610
It's gone.

00:39:29.610 --> 00:39:32.390
All those variables don't exist
anymore, because I'm no

00:39:32.390 --> 00:39:33.640
longer in g.

00:39:36.090 --> 00:39:38.400
This is the nice thing, because
it means if you call

00:39:38.400 --> 00:39:40.670
something 1,000 times,
it doesn't

00:39:40.670 --> 00:39:42.530
use up all your memory.

00:39:42.530 --> 00:39:44.920
Every time it's finished,
it gets rid of what

00:39:44.920 --> 00:39:46.170
it no longer needs.

00:39:51.580 --> 00:39:52.550
All right?

00:39:52.550 --> 00:39:54.300
Does that make sense?

00:39:54.300 --> 00:39:55.940
This is an important
thing to get--

00:39:55.940 --> 00:39:59.036
yeah, thank you, question.

00:39:59.036 --> 00:39:59.530
AUDIENCE: --the assertion.

00:39:59.530 --> 00:40:00.518
PROFESSOR: Where did I--

00:40:00.518 --> 00:40:03.482
AUDIENCE: Where did you put this
other assertion, when you

00:40:03.482 --> 00:40:04.470
just changed--

00:40:04.470 --> 00:40:05.458
PROFESSOR: Ah, where did I
put the other assertion?

00:40:05.458 --> 00:40:15.850
If we look at the code, you'll
see I put it after I call g,

00:40:15.850 --> 00:40:22.040
and g is by now returned, but
before I left f1, which is why

00:40:22.040 --> 00:40:26.060
the f1 stack is still present.

00:40:26.060 --> 00:40:28.810
That makes sense to you?

00:40:28.810 --> 00:40:34.320
Which stacks exist, which stack
frames exist, depends

00:40:34.320 --> 00:40:37.360
upon which functions
are still active.

00:40:37.360 --> 00:40:38.830
Yeah?

00:40:38.830 --> 00:40:39.679
AUDIENCE: How come
you don't need a

00:40:39.679 --> 00:40:43.430
return under the g function?

00:40:43.430 --> 00:40:44.973
PROFESSOR: Oh, because there's
not going to be anything

00:40:44.973 --> 00:40:46.080
interesting.

00:40:46.080 --> 00:40:47.662
It's useless.

00:40:47.662 --> 00:40:48.010
Right?

00:40:48.010 --> 00:40:49.750
Why don't I need a
return under g?

00:40:49.750 --> 00:40:52.070
Well if I wanted it to do
something useful, I would need

00:40:52.070 --> 00:40:53.385
to return something.

00:40:53.385 --> 00:40:56.260
But I'd probably also want to
pass it some arguments, rather

00:40:56.260 --> 00:40:58.810
than have it take no
arguments, as well.

00:40:58.810 --> 00:41:01.290
So it's here just to be the
simplest thing I could put

00:41:01.290 --> 00:41:03.450
that created a stack frame.

00:41:03.450 --> 00:41:08.250
But don't try and interpre it as
being anything meaningful.

00:41:08.250 --> 00:41:09.414
Yeah?

00:41:09.414 --> 00:41:11.662
AUDIENCE: Would you run into
problems assuming that g did

00:41:11.662 --> 00:41:13.270
something to x and
then returned it?

00:41:13.270 --> 00:41:14.716
Would you run into any problems
that you named the

00:41:14.716 --> 00:41:17.126
variable the same?

00:41:17.126 --> 00:41:18.572
You know, that you
used x twice?

00:41:18.572 --> 00:41:19.054
Would you want to--

00:41:19.054 --> 00:41:20.030
PROFESSOR: No.

00:41:20.030 --> 00:41:24.620
If an x exists, or any variable
exists within a

00:41:24.620 --> 00:41:28.540
function body, when you leave
that function, that variable

00:41:28.540 --> 00:41:31.010
is gone forever.

00:41:31.010 --> 00:41:34.340
These are just names.

00:41:34.340 --> 00:41:36.920
They have no intrinsic
meaning.

00:41:36.920 --> 00:41:40.900
So one of the ways to think
about it, and we'll see this

00:41:40.900 --> 00:41:43.720
later when we get to classes--

00:41:43.720 --> 00:41:45.170
a lot later.

00:41:45.170 --> 00:41:48.860
You could, if you wanted, think
about this as really the

00:41:48.860 --> 00:41:55.000
name g.x, and you could really
think of this as the name of

00:41:55.000 --> 00:42:01.710
f1.x, and you could think of
this as the name of main.x,

00:42:01.710 --> 00:42:06.090
indicating that they're
really not the same.

00:42:06.090 --> 00:42:10.430
But it would be kind of a pain
to write them all that way.

00:42:10.430 --> 00:42:11.670
OK?

00:42:11.670 --> 00:42:13.650
So different scopes have
different names

00:42:13.650 --> 00:42:16.040
available to them.

00:42:16.040 --> 00:42:18.810
You can use the names in the
scope, and you have to keep

00:42:18.810 --> 00:42:20.700
track of what they mean.

00:42:23.990 --> 00:42:24.260
OK?

00:42:24.260 --> 00:42:25.110
Any other questions?

00:42:25.110 --> 00:42:28.200
These are great questions, and
I really do appreciate them.

00:42:28.200 --> 00:42:28.910
Yeah?

00:42:28.910 --> 00:42:30.842
AUDIENCE: Does this also
happen with four loops?

00:42:30.842 --> 00:42:33.257
Like if you say 4x in
range something,

00:42:33.257 --> 00:42:34.706
can you use x later?

00:42:34.706 --> 00:42:35.672
Or is it x--

00:42:35.672 --> 00:42:36.638
PROFESSOR: You can
use x later.

00:42:36.638 --> 00:42:38.087
AUDIENCE: Okay so--

00:42:38.087 --> 00:42:40.140
PROFESSOR: x will be available
outside the loop.

00:42:43.020 --> 00:42:46.470
This was if you said for x in
something, is x available

00:42:46.470 --> 00:42:47.170
outside the loop?

00:42:47.170 --> 00:42:48.600
Yes.

00:42:48.600 --> 00:42:51.130
And in fact, you'll often want
to test what the final value

00:42:51.130 --> 00:42:53.480
of x is, when you
leave the loop.

00:42:56.810 --> 00:42:59.650
OK, the next thing on your
handout, and I'm not going to

00:42:59.650 --> 00:43:05.520
go over it, is using functions
to implement something that

00:43:05.520 --> 00:43:07.480
finds roots.

00:43:07.480 --> 00:43:09.630
There's no real point in
my walking you through

00:43:09.630 --> 00:43:11.570
this code in class.

00:43:11.570 --> 00:43:13.520
I did include it
in the handout.

00:43:13.520 --> 00:43:16.500
And by the way, the handouts
are all available after

00:43:16.500 --> 00:43:18.910
lecture, online.

00:43:18.910 --> 00:43:22.380
Is that, I think you should work
through in your own, and

00:43:22.380 --> 00:43:25.340
make sure you understand it,
to get a sense of how

00:43:25.340 --> 00:43:26.960
functions work.

00:43:26.960 --> 00:43:29.650
And it's certainly related to
the current problem set, which

00:43:29.650 --> 00:43:32.190
would be another good reason
to work through it--

00:43:32.190 --> 00:43:34.430
the problem set that will
be posted today--

00:43:34.430 --> 00:43:38.210
the new problem set, PS 2.

00:43:38.210 --> 00:43:42.750
Note again how careful I am
about the specifications.

00:43:42.750 --> 00:43:56.600
And I should point out something
interesting, if I

00:43:56.600 --> 00:44:02.330
type find root, open para--
well let's do this here.

00:44:14.070 --> 00:44:16.910
Let's clear things up.

00:44:16.910 --> 00:44:22.210
Let's get rid of things
that will cause

00:44:22.210 --> 00:44:23.460
the program to halt.

00:44:33.190 --> 00:44:37.740
Notice that when I type find
root open, open paren, it's

00:44:37.740 --> 00:44:39.230
given me the values--

00:44:39.230 --> 00:44:42.860
the names of the formal
parameters, which I've chosen

00:44:42.860 --> 00:44:46.430
in such way that will remind me
what their value should be.

00:44:46.430 --> 00:44:51.260
And it's also given me part of
the specification, the piece

00:44:51.260 --> 00:44:56.830
in the triple quotation marks
to tell me the rules I'm

00:44:56.830 --> 00:44:59.890
supposed to be following
here on these things.

00:44:59.890 --> 00:45:02.080
So it's a very handy thing.

00:45:02.080 --> 00:45:05.990
And as you use IDLE, you'll get
used to the fact that this

00:45:05.990 --> 00:45:09.480
is a convenience.

00:45:09.480 --> 00:45:12.290
All right, work your way
through that code.

00:45:12.290 --> 00:45:14.820
Make sure you know
what it does.

00:45:14.820 --> 00:45:20.670
Finally, today I want to switch
gears, and talk about

00:45:20.670 --> 00:45:22.870
something else.

00:45:22.870 --> 00:45:26.620
Up till now, all of the programs
we've looked at have

00:45:26.620 --> 00:45:28.590
been numeric--

00:45:28.590 --> 00:45:30.060
they've played with numbers.

00:45:30.060 --> 00:45:33.060
And I've done that, because I
assumed you guys all had some

00:45:33.060 --> 00:45:36.420
intuition about numbers.

00:45:36.420 --> 00:45:39.890
I've use strings as a primitive
data element to

00:45:39.890 --> 00:45:43.250
print things, but we haven't
done anything very interesting

00:45:43.250 --> 00:45:44.500
with strings.

00:45:46.570 --> 00:45:52.590
However strings are indeed quite
interesting, in that

00:45:52.590 --> 00:45:56.910
they're the first non-scalar
value we've looked at.

00:45:56.910 --> 00:46:01.250
You'll recall non-scalar values
are values that can be

00:46:01.250 --> 00:46:03.880
decomposed.

00:46:03.880 --> 00:46:25.110
So if we now look at the code
again, I've got this little

00:46:25.110 --> 00:46:28.530
piece of code called
sumDigits.

00:46:28.530 --> 00:46:31.500
So before, the for statement
we looked at

00:46:31.500 --> 00:46:34.570
was for x in range.

00:46:34.570 --> 00:46:42.850
Well you can apply it to a for
statement to any type that has

00:46:42.850 --> 00:46:46.110
a way to enumerate
its elements.

00:46:46.110 --> 00:46:56.860
So for c in STR, actually of
1952, so I've taken the number

00:46:56.860 --> 00:47:01.240
1952 and converted it to a
string so it will now be quote

00:47:01.240 --> 00:47:07.110
one nine five two, I can now
do something to every

00:47:07.110 --> 00:47:10.780
character in that string.

00:47:10.780 --> 00:47:13.840
And what I'm doing is converting
it back to an int,

00:47:13.840 --> 00:47:16.010
and then adding it.

00:47:16.010 --> 00:47:18.140
So this will give me the
sum of the digits.

00:47:25.290 --> 00:47:26.540
17.

00:47:28.300 --> 00:47:32.500
This is a very convenient
mechanism, and you'll use for

00:47:32.500 --> 00:47:34.270
a lot, this way.

00:47:34.270 --> 00:47:36.830
You'll use it in fact more for
this sort of thing then you

00:47:36.830 --> 00:47:38.480
will for ints.

00:47:41.420 --> 00:47:43.680
Now I can also select values.

00:47:46.370 --> 00:47:48.140
So if I look at--

00:47:57.470 --> 00:47:59.370
I don't know what's
going on here.

00:47:59.370 --> 00:48:02.470
Every once in while when you go
back and forth between the

00:48:02.470 --> 00:48:05.910
editor and the shell, the shell
hangs and you have to go

00:48:05.910 --> 00:48:07.055
try it again.

00:48:07.055 --> 00:48:16.850
If I go to s equals abc, I can
look at individual elements of

00:48:16.850 --> 00:48:22.780
s, for example s sub
0, which will be a.

00:48:22.780 --> 00:48:25.950
I can also look at
slices of s.

00:48:25.950 --> 00:48:28.970
So for example s
from 0 to one.

00:48:33.920 --> 00:48:35.950
That's interesting.

00:48:35.950 --> 00:48:37.080
What is it doing?

00:48:37.080 --> 00:48:38.230
Now try and infer.

00:48:38.230 --> 00:48:39.480
I'll give you another example.

00:48:47.060 --> 00:48:49.990
So you'll remember when we
did range from x to y, it

00:48:49.990 --> 00:48:52.770
went y minus 1.

00:48:52.770 --> 00:48:54.455
Same kind of thing is
happening here.

00:48:58.430 --> 00:49:02.460
So that's why s from 0 to one
gives me only one character,

00:49:02.460 --> 00:49:07.190
but s from 0 to two gives me
the character string ab.

00:49:07.190 --> 00:49:17.800
This is what's called slicing,
and it's very common.

00:49:17.800 --> 00:49:21.540
What a slice does, is it
makes a new copy--

00:49:21.540 --> 00:49:24.970
makes a new object, in this
case-- which is a sub-string

00:49:24.970 --> 00:49:26.220
of the original string.

00:49:30.180 --> 00:49:32.590
There are many other things
I can do on strings.

00:49:32.590 --> 00:49:41.470
I can do something like s.find,
and it will tell me

00:49:41.470 --> 00:49:45.230
that b is at position
number one in s.

00:49:45.230 --> 00:49:51.440
So use Google, whatever you use,
to find the Python web

00:49:51.440 --> 00:49:53.830
page that describe strings, and
it will give you all of

00:49:53.830 --> 00:49:56.880
the operations you can do.

00:49:56.880 --> 00:49:58.130
And they're quite convenient.

00:50:02.310 --> 00:50:05.060
One other scalar type that
you're going to need for the

00:50:05.060 --> 00:50:09.520
problem set is tuples, and
that will be discussed in

00:50:09.520 --> 00:50:12.300
recitation tomorrow.

00:50:12.300 --> 00:50:13.550
OK, thanks a lot.