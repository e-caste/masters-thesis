WEBVTT

00:00:00.790 --> 00:00:03.190
The following content is
provided under a Creative

00:00:03.190 --> 00:00:04.730
Commons license.

00:00:04.730 --> 00:00:07.030
Your support will help
MIT OpenCourseWare

00:00:07.030 --> 00:00:11.390
continue to offer high quality
educational resources for free.

00:00:11.390 --> 00:00:13.990
To make a donation or
view additional materials

00:00:13.990 --> 00:00:17.880
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.880 --> 00:00:18.850
at ocw.mit.edu.

00:00:31.860 --> 00:00:34.800
ERIC GRIMSON: Ladies
and gentlemen, I'd

00:00:34.800 --> 00:00:37.330
like to get started.

00:00:37.330 --> 00:00:38.490
My name's Eric Grimson.

00:00:38.490 --> 00:00:41.280
I have the privilege of
serving as MIT'S chancellor

00:00:41.280 --> 00:00:44.470
for academic advancement, you
can go look up what that means,

00:00:44.470 --> 00:00:48.270
and like John I'm a
former head of course six.

00:00:48.270 --> 00:00:49.860
This term, with
Ana and John, I'm

00:00:49.860 --> 00:00:53.070
going to be splitting the
lectures, so I'm up to date.

00:00:53.070 --> 00:00:58.110
OK last time Ana introduced
the first of the compound data

00:00:58.110 --> 00:01:01.170
types, tuples and lists.

00:01:01.170 --> 00:01:03.700
She showed lots of ways
of manipulating them,

00:01:03.700 --> 00:01:06.754
lots of built in things for
manipulating those structures.

00:01:06.754 --> 00:01:08.670
And the key difference
between the two of them

00:01:08.670 --> 00:01:11.910
was that tuples were immutable,
meaning you could not

00:01:11.910 --> 00:01:14.310
change them, lists
were mutable, they

00:01:14.310 --> 00:01:16.290
could be changed, or mutated.

00:01:16.290 --> 00:01:19.320
And that led to both some nice
power and some opportunities

00:01:19.320 --> 00:01:20.410
for challenges.

00:01:20.410 --> 00:01:23.370
And, in particular, she showed
you things like aliasing,

00:01:23.370 --> 00:01:25.740
where you could have two names
pointing to the same list

00:01:25.740 --> 00:01:27.360
structure, and
because of that, you

00:01:27.360 --> 00:01:29.520
could change the
contents of one,

00:01:29.520 --> 00:01:32.940
it would change the appearance
of the contents of the other,

00:01:32.940 --> 00:01:34.890
and that leads to
some nice challenges.

00:01:34.890 --> 00:01:36.420
So the side effects
of mutability

00:01:36.420 --> 00:01:38.795
are one of the things you're
going to see, both as a plus

00:01:38.795 --> 00:01:42.360
and minus, as we go
through the course.

00:01:42.360 --> 00:01:45.507
Today we're going to take
a different direction

00:01:45.507 --> 00:01:47.840
for a little while, we're
going to talk about recursion.

00:01:47.840 --> 00:01:49.950
It Is a powerful
and wonderful tool

00:01:49.950 --> 00:01:52.950
for solving
computational problems.

00:01:52.950 --> 00:01:56.460
We're then going to look at
another kind of compound data

00:01:56.460 --> 00:01:59.210
structure, a dictionary,
which is also mutable.

00:01:59.210 --> 00:02:01.710
And then we're going to put the
two pieces together and show

00:02:01.710 --> 00:02:03.900
how together they actually
give you a lot of power

00:02:03.900 --> 00:02:08.500
for solving some really neat
problems very effectively.

00:02:08.500 --> 00:02:11.610
But I want to start
with recursion.

00:02:11.610 --> 00:02:13.950
Perhaps one of the most
mysterious, at least according

00:02:13.950 --> 00:02:16.500
to programmer's, concepts in
computer science, one that

00:02:16.500 --> 00:02:18.840
leads to lots of really
bad computer science jokes,

00:02:18.840 --> 00:02:21.090
actually all computer
science jokes are bad,

00:02:21.090 --> 00:02:23.430
but these are particularly bad.

00:02:23.430 --> 00:02:27.390
So let's start with the obvious
question, what is recursion?

00:02:27.390 --> 00:02:31.260
If you go to the ultimate
source of knowledge, Wikipedia,

00:02:31.260 --> 00:02:34.350
you get something that
says, in essence, recursion

00:02:34.350 --> 00:02:39.710
is the process of repeating
items in a self-similar way.

00:02:39.710 --> 00:02:41.796
Well that's really
helpful, right?

00:02:41.796 --> 00:02:43.920
But we're going to see that
idea because recursion,

00:02:43.920 --> 00:02:45.336
as we're going to
see in a second,

00:02:45.336 --> 00:02:50.250
is the idea of taking a problem
and reducing it to a smaller

00:02:50.250 --> 00:02:53.310
version of the same
problem, and using that idea

00:02:53.310 --> 00:02:56.310
to actually tackle a bunch of
really interesting problems.

00:02:56.310 --> 00:02:58.142
But recursion gets used
in a lot of places.

00:02:58.142 --> 00:02:59.850
So it's this idea of
using, or repeating,

00:02:59.850 --> 00:03:01.800
the idea multiple times.

00:03:01.800 --> 00:03:05.700
So wouldn't it be great if your
3D printer printed 3D printers?

00:03:05.700 --> 00:03:09.210
And you could just keep
doing that all the way along.

00:03:09.210 --> 00:03:10.740
Or one that's a
little more common,

00:03:10.740 --> 00:03:12.198
it's actually got
a wonderful name,

00:03:12.198 --> 00:03:14.970
it's called mise en abyme,
in art, sometimes referred

00:03:14.970 --> 00:03:17.142
to as the Droste
effect, pictures

00:03:17.142 --> 00:03:19.350
that have inside them a
picture of the picture, which

00:03:19.350 --> 00:03:22.290
has inside them a picture of the
picture, and you get the idea.

00:03:22.290 --> 00:03:23.790
And of course, one
of the things you

00:03:23.790 --> 00:03:25.414
want to think about
in recursion is not

00:03:25.414 --> 00:03:27.382
to have it go on infinitely.

00:03:27.382 --> 00:03:29.715
And yes there are even light
bulb jokes about recursion,

00:03:29.715 --> 00:03:31.339
if you can't read
it, it says, how many

00:03:31.339 --> 00:03:34.440
twists does it take to
screw in a light bulb?

00:03:34.440 --> 00:03:38.610
And it says, if it's already
screwed in, the answer is 0.

00:03:38.610 --> 00:03:42.780
Otherwise, twist it once, ask
me again, add 1 to my answer.

00:03:42.780 --> 00:03:46.470
And that's actually a nice
description of recursion.

00:03:46.470 --> 00:03:48.150
So let's look at
it more seriously.

00:03:48.150 --> 00:03:50.700
What is recursion?

00:03:50.700 --> 00:03:55.480
I want to describe it both
abstractly, or algorithmically,

00:03:55.480 --> 00:03:59.850
and semantically or, if you
like, in terms of programming.

00:03:59.850 --> 00:04:02.670
Abstractly, this is a
great instance of something

00:04:02.670 --> 00:04:05.770
often called divide-and-conquer,
or sometimes called

00:04:05.770 --> 00:04:07.720
decrease-and-conquer.

00:04:07.720 --> 00:04:09.510
And the idea of
recursion is, I want

00:04:09.510 --> 00:04:13.080
to take a problem I'm trying
to solve and say, how could I

00:04:13.080 --> 00:04:17.149
reduce it to a simpler
version of the same problem,

00:04:17.149 --> 00:04:19.194
plus some things
I know how to do?

00:04:19.194 --> 00:04:20.610
And then that
simpler version, I'm

00:04:20.610 --> 00:04:21.984
going to reduce
it again and keep

00:04:21.984 --> 00:04:24.957
doing that until I get
down to a simple case

00:04:24.957 --> 00:04:26.040
that I can solve directly.

00:04:26.040 --> 00:04:29.700
That is how we're going to
think about designing solutions

00:04:29.700 --> 00:04:31.710
to problems.

00:04:31.710 --> 00:04:35.160
Semantically, this is typically
going to lead to the case

00:04:35.160 --> 00:04:38.220
where a program, a
definition of function,

00:04:38.220 --> 00:04:41.340
will refer to
itself in its body.

00:04:41.340 --> 00:04:44.719
It will call itself
inside its body.

00:04:44.719 --> 00:04:47.010
Now, if you remember your
high school geometry teacher,

00:04:47.010 --> 00:04:48.810
she probably would wrap your
knuckles, which you're not

00:04:48.810 --> 00:04:50.982
allowed to do, because
in things like geometry

00:04:50.982 --> 00:04:53.190
you can't define something
in terms of itself, right?

00:04:53.190 --> 00:04:54.720
That's not allowed.

00:04:54.720 --> 00:04:56.460
In recursion, this is OK.

00:04:56.460 --> 00:05:00.990
Our definition of a procedure
can in its body call itself,

00:05:00.990 --> 00:05:03.840
so long as I have what
I call a base case,

00:05:03.840 --> 00:05:08.100
a way of stopping that
unwinding of the problems,

00:05:08.100 --> 00:05:10.645
when I get to something
I can solve directly.

00:05:10.645 --> 00:05:13.020
And so what we're going to do
is avoid infinite recursion

00:05:13.020 --> 00:05:15.210
by ensuring that we have
at least one or more base

00:05:15.210 --> 00:05:17.070
cases that are easy to solve.

00:05:17.070 --> 00:05:18.570
And then the basic
idea is I just

00:05:18.570 --> 00:05:20.910
want to solve the same
problem on some simpler

00:05:20.910 --> 00:05:23.610
input with the idea
of using that solution

00:05:23.610 --> 00:05:25.870
to solve the larger problem.

00:05:25.870 --> 00:05:27.867
OK, let's look at an
example, and to set

00:05:27.867 --> 00:05:30.450
the stage I'm going to go back
to something you've been doing,

00:05:30.450 --> 00:05:32.100
iterative algorithms.

00:05:32.100 --> 00:05:34.170
For loops, while
loops, they naturally

00:05:34.170 --> 00:05:36.480
lead to what we would
call iterative algorithms,

00:05:36.480 --> 00:05:38.520
and these algorithms
can be described

00:05:38.520 --> 00:05:42.510
as being captured by a
set of state variables,

00:05:42.510 --> 00:05:45.630
meaning one or more variables
that tell us exactly

00:05:45.630 --> 00:05:47.890
the state of the computation.

00:05:47.890 --> 00:05:50.747
That's a lot of words,
let's look at an example.

00:05:50.747 --> 00:05:52.330
I know it's trivial,
but bear with me.

00:05:52.330 --> 00:05:54.420
Suppose I want to do
integer multiplication,

00:05:54.420 --> 00:05:56.820
multiply two integers
together, and all

00:05:56.820 --> 00:05:59.080
I have available
to me is addition.

00:05:59.080 --> 00:06:03.620
So a times b is the same as
adding a to itself b times.

00:06:03.620 --> 00:06:05.940
If I'm thinking about
this iteratively,

00:06:05.940 --> 00:06:10.080
I could capture this computation
with two state variables.

00:06:10.080 --> 00:06:13.200
One we'd just call
the iteration number,

00:06:13.200 --> 00:06:15.420
and it would be
something, for example,

00:06:15.420 --> 00:06:19.420
that starts at b, and each time
through the loop reduces 1.

00:06:19.420 --> 00:06:19.920
One.

00:06:19.920 --> 00:06:22.080
And it will keep doing that
until I've counted down

00:06:22.080 --> 00:06:24.690
b times, and I get down to 0.

00:06:24.690 --> 00:06:26.130
And at the same
time, I would have

00:06:26.130 --> 00:06:28.110
some value of the
computation, I might call it

00:06:28.110 --> 00:06:32.520
result, which starts at 0,
first time through adds an a,

00:06:32.520 --> 00:06:34.320
next time through
adds an a, and it just

00:06:34.320 --> 00:06:36.240
keeps track of how
many things have

00:06:36.240 --> 00:06:38.639
I added up, until I get done.

00:06:38.639 --> 00:06:40.305
And yeah, I know you
could just do mult,

00:06:40.305 --> 00:06:41.850
but this is trying
to get this idea

00:06:41.850 --> 00:06:45.160
of, how would I do
this iteratively.

00:06:45.160 --> 00:06:50.160
So I might start off with i,
saying there are b things still

00:06:50.160 --> 00:06:51.360
to add, and the result is 1.

00:06:51.360 --> 00:06:55.320
The first time through the
loop, I add an a, reduce i by 1.

00:06:55.320 --> 00:06:57.510
Next time through the
loop, I add in another a,

00:06:57.510 --> 00:06:59.680
reduce i by 1, and
you get the idea.

00:06:59.680 --> 00:07:01.980
I just walk down it
until, eventually, I got

00:07:01.980 --> 00:07:05.680
to the end of this computation.

00:07:05.680 --> 00:07:07.690
So we could write code
for this, and, actually,

00:07:07.690 --> 00:07:09.660
it should be pretty
straightforward.

00:07:09.660 --> 00:07:11.170
There it is.

00:07:11.170 --> 00:07:15.254
Going to call it mult_iter,
takes in two arguments a and b,

00:07:15.254 --> 00:07:17.170
and I'm going to capture
exactly that process.

00:07:17.170 --> 00:07:19.330
So notice what I
do, I set up result

00:07:19.330 --> 00:07:20.950
internally as just
a little variable

00:07:20.950 --> 00:07:23.050
I'm going to use to
accumulate things.

00:07:23.050 --> 00:07:25.880
And then, there
is the iteration,

00:07:25.880 --> 00:07:29.320
as long as b is greater
than 0 what do I do?

00:07:29.320 --> 00:07:33.630
Add a to result, store
it away, reduce b by 1,

00:07:33.630 --> 00:07:35.470
and I'll keep doing
that until b gets

00:07:35.470 --> 00:07:37.600
down to being equal
to 0, in which case

00:07:37.600 --> 00:07:43.610
I just return the result.
OK, simple solution.

00:07:43.610 --> 00:07:47.770
Now, let's think about
this a different way.

00:07:47.770 --> 00:07:51.220
A times b is just adding
a to itself b times,

00:07:51.220 --> 00:07:57.920
and that's the same as a
plus adding a to a itself

00:07:57.920 --> 00:08:00.710
b minus 1 times.

00:08:00.710 --> 00:08:02.780
OK, that sounds
like leisure to me,

00:08:02.780 --> 00:08:04.820
that sounds like just
playing with words.

00:08:04.820 --> 00:08:08.200
But it's really important,
because what is this?

00:08:08.200 --> 00:08:12.870
Ah, that's just a
times b minus 1,

00:08:12.870 --> 00:08:15.760
by the definition
of the top point.

00:08:15.760 --> 00:08:17.500
And I know you're
totally impressed,

00:08:17.500 --> 00:08:20.420
but this is actually really
cool, because what have I done?

00:08:20.420 --> 00:08:24.180
I've taken one problem,
this one up here,

00:08:24.180 --> 00:08:27.870
and I've reduced it to a simpler
version of the same problem,

00:08:27.870 --> 00:08:30.020
plus some things
I know how to do.

00:08:30.020 --> 00:08:31.760
And how would I solve this?

00:08:31.760 --> 00:08:36.110
Same trick, that's a
times a times b minus 2,

00:08:36.110 --> 00:08:37.730
I would just unwrap
it one more time,

00:08:37.730 --> 00:08:40.580
and I would just keep
doing that until I get down

00:08:40.580 --> 00:08:43.470
to something I can solve
directly, a base case.

00:08:43.470 --> 00:08:47.240
And that's easy, when b equal
to 1, the answer is just a.

00:08:47.240 --> 00:08:51.730
Or I could do when b is equal
to 0 the answer is just 0.

00:08:51.730 --> 00:08:54.270
And there's code
to capture that.

00:08:54.270 --> 00:08:57.510
Different form, wonderful
compact description,

00:08:57.510 --> 00:08:58.270
what does it say?

00:08:58.270 --> 00:09:03.470
It says, if I'm at the base
case, if b is equal to 1,

00:09:03.470 --> 00:09:05.560
the answer is just a.

00:09:05.560 --> 00:09:09.840
Otherwise, I'm going to solve
the same problem with a smaller

00:09:09.840 --> 00:09:14.760
version and add it to a
and return that result.

00:09:14.760 --> 00:09:18.970
And that's nice, crisp
characterization of a problem.

00:09:18.970 --> 00:09:21.400
Recursive definition that
reduces a problem to a simpler

00:09:21.400 --> 00:09:24.430
version of the same problem.

00:09:24.430 --> 00:09:28.260
OK, let's look at
another example.

00:09:28.260 --> 00:09:30.720
Classic problem in recursion
is to compute factorial,

00:09:30.720 --> 00:09:32.700
right? n factorial,
or n bang if you

00:09:32.700 --> 00:09:35.580
like, n exclamation point
is n times n minus 1,

00:09:35.580 --> 00:09:36.550
all the way down to 1.

00:09:36.550 --> 00:09:38.640
So it's the product of
all the integers from 1

00:09:38.640 --> 00:09:41.900
up to n assuming n is
a positive integer.

00:09:41.900 --> 00:09:43.430
So we can ask the
same question if I

00:09:43.430 --> 00:09:47.690
wanted to solve this recursively
what would the base case be?

00:09:47.690 --> 00:09:52.376
Well, when n is equal
to 1, it's just 1.

00:09:52.376 --> 00:09:55.270
In the recursive case,
will n times n minus 1

00:09:55.270 --> 00:09:58.720
all the way down to 1,
that's the same as n times

00:09:58.720 --> 00:10:02.000
n minus 1 factorial.

00:10:02.000 --> 00:10:06.210
So I can easily write
out the base case,

00:10:06.210 --> 00:10:08.790
and I've got a nice recursive
solution to this problem.

00:10:11.990 --> 00:10:14.839
OK, if you're like me and
this is the first time you've

00:10:14.839 --> 00:10:16.630
seen it, it feels like
I've taken your head

00:10:16.630 --> 00:10:18.340
and twisted it
about 180 degrees.

00:10:18.340 --> 00:10:20.962
I'm going to take it another
180 degrees because you might

00:10:20.962 --> 00:10:22.420
be saying, well,
wait a minute, how

00:10:22.420 --> 00:10:24.080
do you know it really stops.

00:10:24.080 --> 00:10:27.970
How do you know it really
terminates the computation?

00:10:27.970 --> 00:10:29.410
So let's look at it.

00:10:29.410 --> 00:10:33.590
There is my definition for
fact, short for factorial.

00:10:33.590 --> 00:10:36.200
Fact of 1 is, if n is
equal to 1 return 1,

00:10:36.200 --> 00:10:39.900
otherwise return n
times fact of n minus 1.

00:10:39.900 --> 00:10:41.990
And let's use the tools
that Ana talked about,

00:10:41.990 --> 00:10:44.210
in terms of an
environment at a scope,

00:10:44.210 --> 00:10:46.640
and think about
what happens here.

00:10:46.640 --> 00:10:49.070
So when I read that in or I
evaluate that in Python, it

00:10:49.070 --> 00:10:53.880
creates a definition that binds
the name fact to some code,

00:10:53.880 --> 00:10:55.940
just all of that stuff
over here plus the name

00:10:55.940 --> 00:11:00.050
for the formal parameter, hasn't
done anything with it yet.

00:11:00.050 --> 00:11:04.350
And then I'm going to
evaluate print a fact of 4.

00:11:04.350 --> 00:11:07.696
Print needs a value, so it has
to get the value of fact of 4,

00:11:07.696 --> 00:11:08.820
and we know what that does.

00:11:08.820 --> 00:11:13.860
It looks up fact, there it
is, it's procedure definition.

00:11:13.860 --> 00:11:15.990
So it creates a new
frame, a new environment,

00:11:15.990 --> 00:11:19.290
it calls that procedure,
and inside that frame

00:11:19.290 --> 00:11:24.310
the formal parameter for fact
is bound to the value passed in.

00:11:24.310 --> 00:11:26.590
So n is bound to 4.

00:11:26.590 --> 00:11:29.320
That frame is scoped
by this global frame

00:11:29.320 --> 00:11:31.917
meaning it's going to inherit
things in the global frame.

00:11:31.917 --> 00:11:32.750
And what does it do?

00:11:32.750 --> 00:11:38.420
It says, inside of this frame
evaluate the body of fact.

00:11:38.420 --> 00:11:41.330
OK, so it says as n equal to 1?

00:11:41.330 --> 00:11:43.770
Nope, it's not, it's 4.

00:11:43.770 --> 00:11:46.230
So in that case, go to the
else statement and says,

00:11:46.230 --> 00:11:51.000
oh, return n times fact of n
and n as 4, fact of n minus 1

00:11:51.000 --> 00:11:56.530
says I need to return
4 times fact of 3.

00:11:56.530 --> 00:11:59.732
4 is easy, multiplication
is easy, fact of 3,

00:11:59.732 --> 00:12:02.080
ah yes, I look up fact.

00:12:02.080 --> 00:12:04.210
Now I'm in this frame,
I don't see fact there,

00:12:04.210 --> 00:12:05.510
but I go up to that frame.

00:12:05.510 --> 00:12:07.630
There's the definition
for fact, and we're

00:12:07.630 --> 00:12:09.280
going to do the rest of
this a little more quickly,

00:12:09.280 --> 00:12:10.030
what does that do?

00:12:10.030 --> 00:12:13.600
It creates a new
frame called by fact.

00:12:13.600 --> 00:12:17.970
And the argument passed
in for n is n minus 1,

00:12:17.970 --> 00:12:19.420
that value, right there, of 3.

00:12:19.420 --> 00:12:22.290
So 3 is now bound to n.

00:12:22.290 --> 00:12:25.207
Same game, evaluate the
body is n equal to 1?

00:12:25.207 --> 00:12:28.110
No, so in that case, I'm going
to go to the return statement,

00:12:28.110 --> 00:12:31.500
it says return 3
times fact of 2.

00:12:31.500 --> 00:12:33.872
And notice it's only
looking at this value of n

00:12:33.872 --> 00:12:35.580
because that's the
frame in which I'm in.

00:12:35.580 --> 00:12:39.480
It never sees that value of n.

00:12:39.480 --> 00:12:41.850
OK, aren't you glad I
didn't do fact of 400?

00:12:41.850 --> 00:12:44.100
We've only got two more to
go, but you get the idea.

00:12:44.100 --> 00:12:45.770
Same thing, I need
to get fact of 2

00:12:45.770 --> 00:12:48.840
is going to call fact
again with n bound to 2.

00:12:48.840 --> 00:12:51.990
Relative that evaluates the
body and is not yet equal to 1.

00:12:51.990 --> 00:12:53.610
That says I'm going
to the else clause

00:12:53.610 --> 00:12:56.330
and return 2 times fact of 1.

00:12:56.330 --> 00:12:59.650
I call fact again,
now with n bound to 1,

00:12:59.650 --> 00:13:03.090
and, fortunately, now
that clause is true,

00:13:03.090 --> 00:13:07.440
and it says return 1.

00:13:07.440 --> 00:13:10.517
Whoops, sorry, before I do,
so there's the base case.

00:13:10.517 --> 00:13:13.100
And it may seem apparent to you,
but this is important, right?

00:13:13.100 --> 00:13:15.020
I'm unwinding this
till I get to something

00:13:15.020 --> 00:13:17.030
that can stop the computation.

00:13:17.030 --> 00:13:19.190
Now I'm simply going to
gather the computation up,

00:13:19.190 --> 00:13:20.300
because it says return 1.

00:13:20.300 --> 00:13:21.790
Who asked for it?

00:13:21.790 --> 00:13:24.090
Well that call to fact of 1.

00:13:24.090 --> 00:13:27.350
So that reduces to
return 2 times 1.

00:13:27.350 --> 00:13:28.640
And who called for that?

00:13:28.640 --> 00:13:29.870
Fact of 2.

00:13:29.870 --> 00:13:34.220
That reduces to return a 3 times
2, which reduces to 4 times

00:13:34.220 --> 00:13:36.680
6, which reduces
to printing out 24.

00:13:39.280 --> 00:13:42.840
So it unwinds it down to
a base case and it stops.

00:13:42.840 --> 00:13:47.670
A couple of observations, notice
how each recursive call creates

00:13:47.670 --> 00:13:50.120
its own frame, and
as a consequence,

00:13:50.120 --> 00:13:54.140
there's no confusion about
which value of n I'm using.

00:13:54.140 --> 00:13:57.080
Also notice, in the other
frames, n was not changed.

00:13:57.080 --> 00:13:58.010
We did not mutate it.

00:13:58.010 --> 00:14:00.020
So we're literally
creating a local scope

00:14:00.020 --> 00:14:03.930
for that recursive call,
which is exactly what we want.

00:14:03.930 --> 00:14:07.580
Also notice how there was
a sense of flow of control

00:14:07.580 --> 00:14:10.740
in computing fact of something,
that reduces to returning n

00:14:10.740 --> 00:14:15.450
times fact of n minus 1, and
that creates a new scope.

00:14:15.450 --> 00:14:17.100
And that will simply
keep unwinding

00:14:17.100 --> 00:14:19.200
until I get to something
that can return a value

00:14:19.200 --> 00:14:21.850
and then I gather all
those frames back up.

00:14:21.850 --> 00:14:24.400
So there's a natural
flow of control here.

00:14:24.400 --> 00:14:27.390
But most importantly, there's no
confusion about which variable

00:14:27.390 --> 00:14:30.591
I'm using when I'm
looking for a value of n.

00:14:30.591 --> 00:14:32.959
All right, because this
is often a place where

00:14:32.959 --> 00:14:35.500
things get a little confusing,
I want to do one more example.

00:14:35.500 --> 00:14:38.320
But let me first
show you side by side

00:14:38.320 --> 00:14:40.416
the two different
versions of factorial.

00:14:40.416 --> 00:14:43.040
Actually, I have lied slightly,
we didn't show this one earlier

00:14:43.040 --> 00:14:45.331
but there's factorial if I
wanted to do it iteratively.

00:14:45.331 --> 00:14:48.530
I'd set up some
initial variable to 1,

00:14:48.530 --> 00:14:50.300
and then I'd just
run through a loop.

00:14:50.300 --> 00:14:55.180
For example, from 1 up to just
below n minus 1, or 1 up to n,

00:14:55.180 --> 00:15:00.510
multiplying it and putting
it back into return product.

00:15:00.510 --> 00:15:02.820
Which one do you like more?

00:15:02.820 --> 00:15:04.800
You can't say neither
you have to pick one.

00:15:04.800 --> 00:15:08.100
Show of hands, how many
of you like this one?

00:15:08.100 --> 00:15:10.708
Some hesitant ones, how
many prefer this one?

00:15:10.708 --> 00:15:13.850
Yeah, that's my view.

00:15:13.850 --> 00:15:16.130
I'm biased, but I really
like the recursive one.

00:15:16.130 --> 00:15:19.610
It is crisper to look at,
you can see what it's doing.

00:15:19.610 --> 00:15:21.680
I'm reducing this
problem to a simpler

00:15:21.680 --> 00:15:24.146
version of that problem.

00:15:24.146 --> 00:15:25.520
Pick your own
version but I would

00:15:25.520 --> 00:15:27.050
argue that the
recursive version is

00:15:27.050 --> 00:15:29.150
more intuitive to understand.

00:15:29.150 --> 00:15:31.070
From a programmer's
perspective, it's

00:15:31.070 --> 00:15:32.870
actually often more
efficient to write,

00:15:32.870 --> 00:15:36.140
because I don't have to think
about interior variables.

00:15:36.140 --> 00:15:39.260
Depending on the machine,
it may not be as efficient

00:15:39.260 --> 00:15:41.960
when you call it because
in the recursive version

00:15:41.960 --> 00:15:44.360
I've got it set up,
that set of frames.

00:15:44.360 --> 00:15:45.860
And some versions
of these languages

00:15:45.860 --> 00:15:47.401
are actually very
efficient about it,

00:15:47.401 --> 00:15:48.706
some of them a little less so.

00:15:48.706 --> 00:15:50.330
But given the speed
of computers today,

00:15:50.330 --> 00:15:54.790
who cares as long as it actually
just does the computation.

00:15:54.790 --> 00:15:57.370
Right, one more example,
how do we really

00:15:57.370 --> 00:15:59.724
know our recursive code works?

00:15:59.724 --> 00:16:01.390
Well, we just did a
simulation but let's

00:16:01.390 --> 00:16:03.680
look at it one more way.

00:16:03.680 --> 00:16:07.330
The iterative version,
what can I say about it?

00:16:07.330 --> 00:16:09.390
Well, I know it's
going to terminate

00:16:09.390 --> 00:16:11.520
because b is initially
positive, assuming

00:16:11.520 --> 00:16:13.740
I gave it an appropriate value.

00:16:13.740 --> 00:16:16.620
It decreases by 1 every
time around this loop,

00:16:16.620 --> 00:16:19.860
at some point it has to get
less than 1, it's going to stop.

00:16:19.860 --> 00:16:23.050
So I can conclude it's
always going to terminate.

00:16:23.050 --> 00:16:25.700
What about the
recursive version?

00:16:25.700 --> 00:16:30.000
Well, if I call it with
b equal to one, I'm done.

00:16:30.000 --> 00:16:33.160
If I call it with
b greater than one,

00:16:33.160 --> 00:16:35.789
again it's going to reduce it
by one on the recursive call,

00:16:35.789 --> 00:16:38.080
which means on each recursive
call it's going to reduce

00:16:38.080 --> 00:16:39.977
and eventually it
gets down to a place,

00:16:39.977 --> 00:16:41.810
assuming I gave it a
positive integer, where

00:16:41.810 --> 00:16:43.340
b is equal to one.

00:16:43.340 --> 00:16:47.040
So it'll stop, which just good.

00:16:47.040 --> 00:16:49.380
What we just did was
we used the great tool

00:16:49.380 --> 00:16:54.464
from math, second best
department at MIT.

00:16:54.464 --> 00:16:56.630
Wow, I didn't even get any
hisses on that one, John,

00:16:56.630 --> 00:16:58.790
all right, and
I'm now in trouble

00:16:58.790 --> 00:17:01.150
with the head of
the math department.

00:17:01.150 --> 00:17:02.620
So now that I got
your attention,

00:17:02.620 --> 00:17:04.599
and yes, all computer
science jokes are bad,

00:17:04.599 --> 00:17:06.640
and mine are really
bad, but I'm tenured.

00:17:06.640 --> 00:17:10.514
You cannot do a
damn thing about it.

00:17:10.514 --> 00:17:12.680
Let's look at mathematical
induction which turns out

00:17:12.680 --> 00:17:14.900
to be a tool that lets
us think about programs

00:17:14.900 --> 00:17:16.827
in a really nice way.

00:17:16.827 --> 00:17:18.410
You haven't seen
this, here's the idea

00:17:18.410 --> 00:17:19.609
of mathematical induction.

00:17:19.609 --> 00:17:22.280
If I want to prove
a statement, and we

00:17:22.280 --> 00:17:24.420
refer to it as being
indexed on the integers.

00:17:24.420 --> 00:17:26.660
In other words, it's some
mathematical statement

00:17:26.660 --> 00:17:28.300
that runs over integers.

00:17:28.300 --> 00:17:32.660
If I want to prove it's true for
all values of those integers,

00:17:32.660 --> 00:17:34.580
mathematically I'd do
it by simply proving

00:17:34.580 --> 00:17:37.640
it's true for the smallest
value of n typically

00:17:37.640 --> 00:17:41.310
n is equal to 0 or 1, and then
I do an interesting thing.

00:17:41.310 --> 00:17:44.310
I say I need to prove that
if it's true for an arbitrary

00:17:44.310 --> 00:17:47.310
value of n, I'm just going
to prove that it's also then

00:17:47.310 --> 00:17:49.530
true for n plus 1.

00:17:49.530 --> 00:17:51.480
And if I can do those
two things I can then

00:17:51.480 --> 00:17:54.390
conclude for an infinite
number of values of n

00:17:54.390 --> 00:17:56.102
it's always true.

00:17:56.102 --> 00:17:58.310
Then we'll relate it back
to programming in a second,

00:17:58.310 --> 00:18:00.351
but let me show you a
simple example of this, one

00:18:00.351 --> 00:18:02.170
that you may have seen.

00:18:02.170 --> 00:18:05.690
If I had the integers from 0 up
to n, or even from 1 up to n,

00:18:05.690 --> 00:18:10.160
I claim that's the same as
n times n plus 1 over 2.

00:18:10.160 --> 00:18:12.220
So 1, 2, 3, that's 6, right.

00:18:12.220 --> 00:18:14.560
And that's exactly
right, 3 times 4,

00:18:14.560 --> 00:18:17.740
which is divided by 2,
which gives me out 6.

00:18:17.740 --> 00:18:19.840
How would I prove this?

00:18:19.840 --> 00:18:21.556
Well, by induction?

00:18:21.556 --> 00:18:25.180
I need to do the simple
cases if n is equal to 0,

00:18:25.180 --> 00:18:27.070
well then this side is just 0.

00:18:27.070 --> 00:18:29.590
And that's 0 times 1,
which is 0 divided by true.

00:18:29.590 --> 00:18:32.210
So 0 equals 0, it's true.

00:18:32.210 --> 00:18:34.360
Now the inductive step.

00:18:34.360 --> 00:18:36.250
I'm going to assume
it's true for some k,

00:18:36.250 --> 00:18:38.530
I should have picked
n, but for some k,

00:18:38.530 --> 00:18:42.180
and then what I need to show
is it's true for k plus 1.

00:18:42.180 --> 00:18:45.200
Well, there's the
left hand side,

00:18:45.200 --> 00:18:48.850
and I want to show that
this is equal to that.

00:18:48.850 --> 00:18:51.640
And I'm going do it by using
exactly this recursive idea,

00:18:51.640 --> 00:18:55.660
because what do I know, I know
that this sum, in here, I'm

00:18:55.660 --> 00:18:58.100
assuming is true.

00:18:58.100 --> 00:19:01.330
And so that says that the left
hand side, the first portion

00:19:01.330 --> 00:19:04.000
of it, is just k
times k plus 1 over 2,

00:19:04.000 --> 00:19:06.820
that's the definition of the
thing I'm assuming is true.

00:19:06.820 --> 00:19:10.151
To that I'm going
to add k plus 1.

00:19:10.151 --> 00:19:11.650
Well, you can do
the algebra, right?

00:19:11.650 --> 00:19:14.320
That's k plus 1
all times k over 2

00:19:14.320 --> 00:19:18.250
plus 1, which is
k plus 2 over 2.

00:19:18.250 --> 00:19:22.000
Oh cool, it's exactly that.

00:19:22.000 --> 00:19:23.920
Having done that, I
can now conclude this

00:19:23.920 --> 00:19:27.690
is true for all values of n.

00:19:27.690 --> 00:19:30.996
What does it have to
do with programming?

00:19:30.996 --> 00:19:32.870
That's exactly what
we're doing when we think

00:19:32.870 --> 00:19:35.450
about recursive code, right?

00:19:35.450 --> 00:19:38.300
We're saying, show that
it's true for the base case,

00:19:38.300 --> 00:19:40.040
and then what I'm
essentially assuming

00:19:40.040 --> 00:19:44.120
is that, if it works for
values smaller than b,

00:19:44.120 --> 00:19:46.820
then does the code return
the right answer for b?

00:19:46.820 --> 00:19:48.620
And the answer is,
absolutely it does,

00:19:48.620 --> 00:19:51.740
and I'm using induction to
deduce that, in fact, my code

00:19:51.740 --> 00:19:54.600
does the right thing.

00:19:54.600 --> 00:19:57.180
Why am I torturing
you with this?

00:19:57.180 --> 00:20:00.487
Because this is the way I want
you to think about recursion.

00:20:00.487 --> 00:20:02.070
When I'm going to
break a problem down

00:20:02.070 --> 00:20:03.990
into a smaller version
of the same problem,

00:20:03.990 --> 00:20:06.720
I can assume that the smaller
version gives the answer.

00:20:06.720 --> 00:20:09.450
All I have to do is make sure
that what I combined together

00:20:09.450 --> 00:20:12.510
gives me out the right result.

00:20:12.510 --> 00:20:15.950
OK, you may be
wondering what I'm

00:20:15.950 --> 00:20:18.500
doing with these wonderful
high tech toys down here.

00:20:18.500 --> 00:20:20.692
I want to show you another
example of recursion.

00:20:20.692 --> 00:20:23.150
So far we've seen simple things
that have just had one base

00:20:23.150 --> 00:20:25.700
case, and this is a
mythical story called

00:20:25.700 --> 00:20:28.040
The towers of Hanoi and
this story, as I heard it,

00:20:28.040 --> 00:20:30.530
is there's a temporal
somewhere in Hanoi

00:20:30.530 --> 00:20:35.630
with three tall spikes and 64
jewel-encrusted golden disks

00:20:35.630 --> 00:20:37.600
all of a different size.

00:20:37.600 --> 00:20:40.180
They all started out on
one spike with the property

00:20:40.180 --> 00:20:43.570
that they were ordered from
smallest down to largest.

00:20:43.570 --> 00:20:46.420
And there are priests in this
temple who are moving the disks

00:20:46.420 --> 00:20:48.580
one at a time, one per
second, and their goal

00:20:48.580 --> 00:20:53.270
is to move the entire stack
from one spike to another spike.

00:20:53.270 --> 00:20:55.760
And when they do
nirvana is achieved

00:20:55.760 --> 00:20:58.200
and we all get a
really great life.

00:20:58.200 --> 00:20:59.790
We'll talk separately
about how long

00:20:59.790 --> 00:21:02.040
is this going to take because
there's one trick to it.

00:21:02.040 --> 00:21:05.380
They can never cover a smaller
disk with a larger disk

00:21:05.380 --> 00:21:07.380
as they're doing it, so
they've got a third disk

00:21:07.380 --> 00:21:09.161
as a temporary thing.

00:21:09.161 --> 00:21:11.160
And I want to show you
how to solve this problem

00:21:11.160 --> 00:21:13.380
because you're going to write
code with my help in a second,

00:21:13.380 --> 00:21:14.760
or I'm going to write
code with your help

00:21:14.760 --> 00:21:15.760
in a second to solve it.

00:21:15.760 --> 00:21:17.790
So let's look at it,
so watch carefully,

00:21:17.790 --> 00:21:21.960
moving a disk of size one,
well that's pretty easy, right?

00:21:21.960 --> 00:21:23.550
Moving a disk of
size two, we'll just

00:21:23.550 --> 00:21:25.716
put this one on the spare
one while you move it over

00:21:25.716 --> 00:21:26.850
so you don't cover it up.

00:21:26.850 --> 00:21:28.650
That's easy.

00:21:28.650 --> 00:21:30.524
Moving a disk of
size three, you've

00:21:30.524 --> 00:21:32.940
got be a little more careful,
you can't cover up a smaller

00:21:32.940 --> 00:21:34.650
one with a larger one, so
you have to really think

00:21:34.650 --> 00:21:35.745
about where you're putting it.

00:21:35.745 --> 00:21:38.369
It would help with these things
didn't juggle and there you go,

00:21:38.369 --> 00:21:40.066
you got it done.

00:21:40.066 --> 00:21:41.190
All right, you're watching?

00:21:41.190 --> 00:21:41.940
You've got to do four.

00:21:41.940 --> 00:21:44.565
To do four, again, you've got to
be really careful not to cover

00:21:44.565 --> 00:21:46.170
things up as you do this.

00:21:46.170 --> 00:21:48.360
You want to get the bottom
one eventually exposed,

00:21:48.360 --> 00:21:49.810
and so are you going to
pull that one over there.

00:21:49.810 --> 00:21:51.060
If you do the
pattern really well,

00:21:51.060 --> 00:21:53.185
you won't notice if I make
a serious mistake as I'm

00:21:53.185 --> 00:21:54.610
doing this, which I just did.

00:21:54.610 --> 00:21:56.026
But I'm going to
recover from that

00:21:56.026 --> 00:21:58.230
and do it that way to
put this one over here,

00:21:58.230 --> 00:22:00.859
and that one goes there, and
if I did this in Harvard Square

00:22:00.859 --> 00:22:01.650
I could make money.

00:22:01.650 --> 00:22:02.486
There you go, right?

00:22:05.920 --> 00:22:08.930
OK, got the solution?

00:22:08.930 --> 00:22:10.200
See how to solve it?

00:22:10.200 --> 00:22:12.600
Could you write code for this?

00:22:12.600 --> 00:22:15.600
Eh, maybe not.

00:22:15.600 --> 00:22:17.100
That's on the
quiz, thanks, John,

00:22:17.100 --> 00:22:19.200
don't tell them
on the quiz, damn.

00:22:19.200 --> 00:22:23.190
All right, I want to claim
though that in fact there's

00:22:23.190 --> 00:22:26.569
a beautiful recursive solution.

00:22:26.569 --> 00:22:28.610
And here's the way to
think about it recursively.

00:22:28.610 --> 00:22:31.740
I want to move a
tower of size n,

00:22:31.740 --> 00:22:33.757
I'm going to assume I
can move smaller towers

00:22:33.757 --> 00:22:34.840
and then it's really easy.

00:22:34.840 --> 00:22:37.860
What do I do, I take a
stack of size n minus 1,

00:22:37.860 --> 00:22:41.280
I move it onto the spare one,
I move the bottom one over,

00:22:41.280 --> 00:22:44.090
and then I move a
stack of size n minus 1

00:22:44.090 --> 00:22:47.740
to there, beautiful,
recursive solution.

00:22:47.740 --> 00:22:49.240
And how do I move
the smaller stack?

00:22:49.240 --> 00:22:53.010
Just the same way,
I just unwind it,

00:22:53.010 --> 00:22:58.850
simple, and, in fact, the
code follows exactly that.

00:22:58.850 --> 00:23:01.080
OK, I do a little
[INAUDIBLE] domain up here

00:23:01.080 --> 00:23:03.300
to try and get your
attention, but notice

00:23:03.300 --> 00:23:04.881
by doing that what did I do?

00:23:04.881 --> 00:23:06.630
I asked you to think
about it recursively,

00:23:06.630 --> 00:23:08.940
the recursive solution,
when you see it,

00:23:08.940 --> 00:23:13.810
is in fact very straightforward,
and there's the code.

00:23:13.810 --> 00:23:15.760
Dead trivial, well,
that trivial is unfair,

00:23:15.760 --> 00:23:16.840
but it's very simple.

00:23:16.840 --> 00:23:17.440
Right?

00:23:17.440 --> 00:23:20.050
I simply write something,
so let me describe it,

00:23:20.050 --> 00:23:22.240
I need to say how big
of tower am I moving

00:23:22.240 --> 00:23:25.580
and I'm going to label the
three stacks a from, a to,

00:23:25.580 --> 00:23:26.924
and a spare.

00:23:26.924 --> 00:23:28.840
I have a little procedure
that just prints out

00:23:28.840 --> 00:23:32.650
the move for me, and
then what's the solution?

00:23:32.650 --> 00:23:35.350
If it's just a stack of size
one, just print the move,

00:23:35.350 --> 00:23:38.020
take it to from--
from from to to.

00:23:38.020 --> 00:23:41.310
Otherwise, move a
tower of size n minus 1

00:23:41.310 --> 00:23:46.660
from the from spot to
the spare spot, then move

00:23:46.660 --> 00:23:49.630
what's left of tower
size one from to two,

00:23:49.630 --> 00:23:51.850
and then take that
thing are stuck on spare

00:23:51.850 --> 00:23:56.500
and move it over to
two, and I'm done.

00:23:56.500 --> 00:23:59.285
In that code that we handed
out, you'll see this code,

00:23:59.285 --> 00:23:59.910
you can run it.

00:23:59.910 --> 00:24:01.310
I'm not going to print
it out because, if I did,

00:24:01.310 --> 00:24:02.800
you are just going
to say, OK, it

00:24:02.800 --> 00:24:04.970
looks like it does the
right kind of thing.

00:24:04.970 --> 00:24:08.196
Look at the code, nice
and easy, and that's

00:24:08.196 --> 00:24:10.320
what we like you to do when
you're given a problem.

00:24:10.320 --> 00:24:11.986
We asked you to think
about recursively.

00:24:11.986 --> 00:24:13.790
How do I solve
this with a smaller

00:24:13.790 --> 00:24:15.920
version of the same problem?

00:24:15.920 --> 00:24:19.310
And then how do I use that
to build the larger solution?

00:24:19.310 --> 00:24:21.390
This case is a little different.

00:24:21.390 --> 00:24:23.030
You could argue that
this is not really

00:24:23.030 --> 00:24:25.321
a recursive call here, it's
just moving the bottom one,

00:24:25.321 --> 00:24:26.870
I could have done that directly.

00:24:26.870 --> 00:24:31.420
But I've got two recursive
calls in the body here.

00:24:31.420 --> 00:24:33.710
I have to move a
smaller stack twice.

00:24:33.710 --> 00:24:37.870
We're going to come back
to that in a little bit.

00:24:37.870 --> 00:24:40.720
Let me show you one other
example of recursion that

00:24:40.720 --> 00:24:43.215
runs a little bit differently.

00:24:43.215 --> 00:24:45.340
In this case it's going to
have multiple base cases

00:24:45.340 --> 00:24:46.630
and this is another
very old problem,

00:24:46.630 --> 00:24:48.046
it's called the
Fibonacci numbers.

00:24:48.046 --> 00:24:50.350
It's based on something
from several centuries

00:24:50.350 --> 00:24:52.600
ago when a gentleman,
named Leonardo of Pisa,

00:24:52.600 --> 00:24:56.350
also known as Fibonacci,
asked the following challenge.

00:24:56.350 --> 00:24:58.570
He said, I'm going to put
a newborn pair of rabbits,

00:24:58.570 --> 00:25:02.870
one male and one female, into an
enclosure, a pan of some sort.

00:25:02.870 --> 00:25:05.290
And the rabbits have the
following properties,

00:25:05.290 --> 00:25:09.660
they mate at age one month, so
they take a month to mature.

00:25:09.660 --> 00:25:11.650
After a one month
gestation period,

00:25:11.650 --> 00:25:15.550
they produce another pair of
rabbits, a male and a female,

00:25:15.550 --> 00:25:19.030
and he says I'm going to assume
that the rabbits never die.

00:25:19.030 --> 00:25:22.180
So each month mature females are
going to produce another pair.

00:25:22.180 --> 00:25:24.670
And his question was, how
many female rabbits are there

00:25:24.670 --> 00:25:27.410
at the end of a year, or
two years, or three years?

00:25:30.040 --> 00:25:33.690
The idea is, I start off
with two immature rabbits,

00:25:33.690 --> 00:25:36.270
after one month
they've matured, which

00:25:36.270 --> 00:25:41.700
means after another month, they
will have produced a new pair.

00:25:41.700 --> 00:25:44.760
After another month, that mature
pair has produced another pair,

00:25:44.760 --> 00:25:47.940
and the immature
pair has matured.

00:25:47.940 --> 00:25:49.530
Which means, after
another month,

00:25:49.530 --> 00:25:53.770
those two mature pairs are
going to produce offspring,

00:25:53.770 --> 00:25:56.470
and that immature
pair has matured.

00:25:56.470 --> 00:25:59.800
And you get the idea,
and after several months,

00:25:59.800 --> 00:26:01.152
you get to Australia.

00:26:03.175 --> 00:26:05.550
You can also see this is going
to be interesting to think

00:26:05.550 --> 00:26:07.500
about how do you compute this,
but what I want you to see

00:26:07.500 --> 00:26:08.910
is the recursive solution to it.

00:26:08.910 --> 00:26:11.910
So how could we capture this?

00:26:11.910 --> 00:26:14.130
Well here's another way
of thinking about it,

00:26:14.130 --> 00:26:15.540
after the first
month, and I know

00:26:15.540 --> 00:26:16.998
we're going to do
this funny thing,

00:26:16.998 --> 00:26:18.960
we're going to index it
0, so call it month 0.

00:26:18.960 --> 00:26:22.040
There is 1 female
which is immature.

00:26:22.040 --> 00:26:24.280
After the second
month, that female

00:26:24.280 --> 00:26:28.870
is mature and now pregnant which
means after the third month it

00:26:28.870 --> 00:26:31.440
has produced an offspring.

00:26:31.440 --> 00:26:34.740
And more generally,
that the n-th month,

00:26:34.740 --> 00:26:38.260
after we get past the first
few cases, what do we have?

00:26:38.260 --> 00:26:41.470
Any female that was
there two months ago

00:26:41.470 --> 00:26:44.160
has produced an offspring.

00:26:44.160 --> 00:26:46.210
Because it's taken at
least one month to mature,

00:26:46.210 --> 00:26:47.585
if it hasn't
already been mature,

00:26:47.585 --> 00:26:49.570
and then it's going to
produce an offspring.

00:26:49.570 --> 00:26:52.810
And any female that
was around last month

00:26:52.810 --> 00:26:55.330
is still around because
they never die off.

00:26:55.330 --> 00:26:56.610
So this is a little different.

00:26:56.610 --> 00:27:00.070
This is now the number
of females at month n

00:27:00.070 --> 00:27:02.200
is the number of females
T month n minus 1,

00:27:02.200 --> 00:27:05.600
plus the number of females
and month n minus 2.

00:27:05.600 --> 00:27:10.890
So two recursive calls, but
with different arguments.

00:27:10.890 --> 00:27:14.430
Different from towers of Hanoi,
where there were two recursive

00:27:14.430 --> 00:27:16.200
calls, but with the
same sized problem.

00:27:19.670 --> 00:27:22.960
So now I need two
base cases, one

00:27:22.960 --> 00:27:26.960
for when n is equal to 0,
one for when n is equal to 1.

00:27:26.960 --> 00:27:29.810
And then I've got
that recursive case,

00:27:29.810 --> 00:27:34.162
so there's a nice
little piece of code.

00:27:34.162 --> 00:27:36.620
Fibonacci, I'm going to assume
x is an integer greater than

00:27:36.620 --> 00:27:37.260
or equal to 0.

00:27:37.260 --> 00:27:39.410
I'm going to return
Fibonacci of x.

00:27:39.410 --> 00:27:42.860
And you can see now it says,
if either x is equal to 0

00:27:42.860 --> 00:27:45.860
or x is equal to 1
I'm going to return 1,

00:27:45.860 --> 00:27:50.810
otherwise, reduce it to two
simpler versions of the problem

00:27:50.810 --> 00:27:55.470
but with different
arguments, and I add them up.

00:27:55.470 --> 00:27:59.630
OK, and if we go look at this,
we can actually run this,

00:27:59.630 --> 00:28:01.465
if I can find my code.

00:28:01.465 --> 00:28:09.800
Which is right there,
and I'm just going to,

00:28:09.800 --> 00:28:13.010
so we can, for example,
check it by saying fib of 0.

00:28:21.076 --> 00:28:23.300
I just hit a bug
which I don't see.

00:28:27.044 --> 00:28:28.200
Let me try it again.

00:28:32.580 --> 00:28:35.580
I'll try it one more
time with fib of 0.

00:28:41.450 --> 00:28:49.187
Darn, it's wrong, let me try it.

00:28:49.187 --> 00:28:50.770
I've got two different
versions of fib

00:28:50.770 --> 00:28:52.060
in here, that's what
I've got going on.

00:28:52.060 --> 00:28:53.895
So let me do it again,
let's do fib of 1.

00:28:53.895 --> 00:28:59.260
There we go, fib of 2 which
is 2, fib of 3 just three,

00:28:59.260 --> 00:29:01.660
and fib of 4 which should
add the previous two, which

00:29:01.660 --> 00:29:02.491
gives me 5.

00:29:02.491 --> 00:29:02.990
There we go.

00:29:02.990 --> 00:29:05.080
Sorry about that, I
had two versions of fib

00:29:05.080 --> 00:29:07.924
in my file, which is
why it complained at me.

00:29:07.924 --> 00:29:09.340
And which is why
you should always

00:29:09.340 --> 00:29:11.340
read the error instructions
because it tells you

00:29:11.340 --> 00:29:13.760
what you did wrong.

00:29:13.760 --> 00:29:17.327
Let's go on and look at one
more example of doing recursion,

00:29:17.327 --> 00:29:18.785
and we're going to
do dictionaries,

00:29:18.785 --> 00:29:21.420
and then we're going to
pull it all together.

00:29:21.420 --> 00:29:24.940
So far we've been doing
recursion on numerical things,

00:29:24.940 --> 00:29:26.730
we can do it on
non-numerical things.

00:29:26.730 --> 00:29:28.590
So a nice way of
thinking about this is,

00:29:28.590 --> 00:29:31.350
how would I tell if a string
of characters is a palindrome?

00:29:31.350 --> 00:29:34.240
Meaning it reads the same
backwards and forwards.

00:29:34.240 --> 00:29:35.950
Probably the most
famous palindrome

00:29:35.950 --> 00:29:39.940
is attributed to Napoleon
"Able was I ere I saw Elba."

00:29:39.940 --> 00:29:41.770
Given that Napoleon
was French, I really

00:29:41.770 --> 00:29:44.040
doubt he said "Able
was I ere I saw Elba,"

00:29:44.040 --> 00:29:45.990
but it's a great palindrome.

00:29:45.990 --> 00:29:47.860
Or another one attributed
to Anne Michaels

00:29:47.860 --> 00:29:52.930
"Are we not drawn we few
drawn onward to a new era,"

00:29:52.930 --> 00:29:55.420
reads the same
backwards and forwards.

00:29:55.420 --> 00:29:58.560
It's fun to think about how
do you create the palindromes.

00:29:58.560 --> 00:30:01.727
I want to write
code to solve this.

00:30:01.727 --> 00:30:03.560
Again, I want to think
about it recursively,

00:30:03.560 --> 00:30:05.230
so here's what I'm going to do.

00:30:05.230 --> 00:30:08.230
I'm first going to take
a string of characters,

00:30:08.230 --> 00:30:10.930
reduce them all to
lowercase, and strip out

00:30:10.930 --> 00:30:12.290
spaces and punctuation.

00:30:12.290 --> 00:30:15.460
I just want the characters.

00:30:15.460 --> 00:30:17.110
And once I got
that, I want to say,

00:30:17.110 --> 00:30:19.150
is that string, that
list of characters

00:30:19.150 --> 00:30:22.880
or that collection of characters
as I should say, a palindrome?

00:30:22.880 --> 00:30:24.940
And I'm going to think
about it recursively,

00:30:24.940 --> 00:30:27.750
and that's actually pretty easy.

00:30:27.750 --> 00:30:32.320
If it's either 0 or 1
long, it's a palindrome.

00:30:32.320 --> 00:30:34.574
Otherwise you could think
about having an index

00:30:34.574 --> 00:30:36.490
at each end of this thing
and sort of counting

00:30:36.490 --> 00:30:38.320
into the middle,
but it's much easier

00:30:38.320 --> 00:30:41.930
to say take the two at the
end, if they're the same,

00:30:41.930 --> 00:30:44.890
then check to see what's left
in the middle is a palindrome,

00:30:44.890 --> 00:30:48.170
and if those two properties
are true, I'm done.

00:30:48.170 --> 00:30:51.940
And notice what I just did I
nicely reduced a bigger problem

00:30:51.940 --> 00:30:53.190
to a slightly smaller problem.

00:30:53.190 --> 00:30:56.110
It's exactly what I want to do.

00:30:56.110 --> 00:30:57.190
OK?

00:30:57.190 --> 00:31:00.706
So it says to check is
this, I'm going to reduce it

00:31:00.706 --> 00:31:02.080
to just the string
of characters,

00:31:02.080 --> 00:31:04.621
and then I'm going to check if
that's a palindrome by pulling

00:31:04.621 --> 00:31:07.520
those two off and checking
to see they're the same,

00:31:07.520 --> 00:31:10.971
and then checking to see if the
middle is itself a palindrome.

00:31:14.660 --> 00:31:16.044
How would I write it?

00:31:16.044 --> 00:31:19.762
I'm going to create a procedure
up here, isPalindrome.

00:31:19.762 --> 00:31:22.220
I'm going to have inside of it
two internal procedures that

00:31:22.220 --> 00:31:23.030
do the work for me.

00:31:23.030 --> 00:31:26.000
The first one is simply
going to reduce this

00:31:26.000 --> 00:31:28.220
to all lowercase with no spaces.

00:31:28.220 --> 00:31:32.360
And notice what I can do because
s is a string of characters.

00:31:32.360 --> 00:31:35.690
I can use the built in string
method lower, so there's

00:31:35.690 --> 00:31:37.730
that dot notation, s.lower.

00:31:37.730 --> 00:31:40.400
It says. apply the
method lower to a string.

00:31:40.400 --> 00:31:43.040
I need an open and close
per end to actually call

00:31:43.040 --> 00:31:45.380
that procedure, and
that will mutate

00:31:45.380 --> 00:31:48.254
s to just be all lowercase.

00:31:48.254 --> 00:31:49.920
And then I'm going
to run a little loop,

00:31:49.920 --> 00:31:52.500
I'll set up answer or ans
to be an empty string,

00:31:52.500 --> 00:31:56.060
and then, for everything
inside that mutated string,

00:31:56.060 --> 00:32:01.570
I'll simply say, if it's inside
this string, if it's a letter,

00:32:01.570 --> 00:32:03.160
add it into answer.

00:32:03.160 --> 00:32:05.740
If it's a space or comma or
something else I'll ignore it,

00:32:05.740 --> 00:32:07.900
and when I'm done
just return answer,

00:32:07.900 --> 00:32:10.450
strips it down to lowercase.

00:32:10.450 --> 00:32:14.810
And then I'm going to pass that
into isPal which simply says,

00:32:14.810 --> 00:32:17.780
if this is either
0 or 1 long, it's

00:32:17.780 --> 00:32:19.970
a palindrome, returned true.

00:32:19.970 --> 00:32:24.500
Otherwise, check to see that
the first and last element

00:32:24.500 --> 00:32:26.630
of the string are
the same, notice

00:32:26.630 --> 00:32:29.090
the indexing to get
into the last element,

00:32:29.090 --> 00:32:31.310
and similarly just
slice into the string,

00:32:31.310 --> 00:32:34.130
ignoring the first and
last element, and ask

00:32:34.130 --> 00:32:36.880
is that a palindrome.

00:32:36.880 --> 00:32:40.111
And then just call it,
and that will do it.

00:32:40.111 --> 00:32:42.610
And again there's a nice example
of that in the code I'm not

00:32:42.610 --> 00:32:44.110
going to run it, I'll let
you just go look at it,

00:32:44.110 --> 00:32:46.276
but it will actually pull
out something that checks,

00:32:46.276 --> 00:32:48.520
is this a palindrome.

00:32:48.520 --> 00:32:51.410
Notice again, what
I'm doing here.

00:32:51.410 --> 00:32:52.870
I'm doing divide-and-conquer.

00:32:52.870 --> 00:32:55.390
I'm taking a problem reducing
it, I keep saying this,

00:32:55.390 --> 00:32:57.700
to a simpler version
of the same problem.

00:32:57.700 --> 00:32:59.350
Keep unwinding it
till I get down

00:32:59.350 --> 00:33:00.860
to something I can
solve directly,

00:33:00.860 --> 00:33:03.320
my base case and I'm done.

00:33:03.320 --> 00:33:05.170
And that's really
the heart of thinking

00:33:05.170 --> 00:33:08.082
about recursive
solutions to problems.

00:33:08.082 --> 00:33:10.040
I would hope that one of
the things I remember,

00:33:10.040 --> 00:33:12.770
besides my really
lousy patter up here,

00:33:12.770 --> 00:33:15.140
is the idea of Towers of
Hanoi, because to me it's

00:33:15.140 --> 00:33:17.390
one of the nicest
examples of a problem that

00:33:17.390 --> 00:33:20.180
would be hard to
solve iteratively,

00:33:20.180 --> 00:33:22.250
but when you see the
recursive solution is

00:33:22.250 --> 00:33:23.570
pretty straightforward.

00:33:23.570 --> 00:33:28.010
Keep that in mind as you
think about doing recursion.

00:33:28.010 --> 00:33:30.200
OK, let's switch
gears, and let's

00:33:30.200 --> 00:33:32.930
talk very briefly about
another kind of data type

00:33:32.930 --> 00:33:34.677
called a dictionary.

00:33:34.677 --> 00:33:36.260
And the idea of a
dictionary I'm going

00:33:36.260 --> 00:33:38.850
to motivate with
a simple example.

00:33:38.850 --> 00:33:40.580
There's a quiz coming
up on Thursday.

00:33:40.580 --> 00:33:41.550
I know you don't
want to hear that,

00:33:41.550 --> 00:33:44.120
but there is, which means we're
going to be recording grades.

00:33:44.120 --> 00:33:46.580
And so imagine I wanted to
build a little database just

00:33:46.580 --> 00:33:48.926
to keep track of
grades of students.

00:33:48.926 --> 00:33:50.300
So one of the ways
I could do it,

00:33:50.300 --> 00:33:53.130
I could create a list with
the names of the students,

00:33:53.130 --> 00:33:55.580
I could create another
list with their grades,

00:33:55.580 --> 00:33:58.650
and a third list with the
actual subject or course

00:33:58.650 --> 00:34:01.381
from which they got that great.

00:34:01.381 --> 00:34:03.630
I keep a separate list
for each one of them,

00:34:03.630 --> 00:34:05.860
keep them of the same
length, and in essence,

00:34:05.860 --> 00:34:08.790
what I'm doing here is
I'm storing information

00:34:08.790 --> 00:34:13.750
at the same index in each list.

00:34:13.750 --> 00:34:16.900
So Ana, who's going to have to
take the class again, gets a B,

00:34:16.900 --> 00:34:20.750
John, who's created the class,
gets an A plus, Sorry Ana,

00:34:20.750 --> 00:34:23.130
John's had a longer time at it.

00:34:23.130 --> 00:34:24.880
All right, bad jokes
aside, what I'm doing

00:34:24.880 --> 00:34:26.320
is I can imagine
just creating lists.

00:34:26.320 --> 00:34:28.278
I could create lists of
lists, but a simple way

00:34:28.278 --> 00:34:31.360
is to do lists where
basically at each index

00:34:31.360 --> 00:34:34.540
I've got associated information.

00:34:34.540 --> 00:34:37.100
It's a simple way
to deal with it.

00:34:37.100 --> 00:34:39.320
Getting a grade out takes
a little bit of work

00:34:39.320 --> 00:34:41.389
because if I want to
get the grade associated

00:34:41.389 --> 00:34:44.300
with a particular
student, what would I do?

00:34:44.300 --> 00:34:48.610
I would go into the name list
and use the method index, which

00:34:48.610 --> 00:34:50.860
you've seen before, again
notice the dot notation

00:34:50.860 --> 00:34:53.860
it says, this is a list,
use the index method,

00:34:53.860 --> 00:34:56.949
call it on student, and
whatever the value of student

00:34:56.949 --> 00:34:58.390
is, it will find
that in the list,

00:34:58.390 --> 00:35:01.630
return the index at
that point, and then I

00:35:01.630 --> 00:35:04.690
can use that to go in and
get the grade in the course

00:35:04.690 --> 00:35:08.110
and return something out.

00:35:08.110 --> 00:35:11.029
Simple way to do it but
a little ugly, right,

00:35:11.029 --> 00:35:12.820
because among other
things, I've got things

00:35:12.820 --> 00:35:14.932
stored in different
places in the list.

00:35:14.932 --> 00:35:17.140
I've got to think about if
I'm going to add something

00:35:17.140 --> 00:35:20.110
to the list I've got to put them
in the same spot in the list.

00:35:20.110 --> 00:35:22.720
I've got to remember to
always index using integers

00:35:22.720 --> 00:35:27.890
which is what we know how to
do with lists, at least so far.

00:35:27.890 --> 00:35:30.051
It would be nice if I had
a better way to do it,

00:35:30.051 --> 00:35:31.550
and that's exactly
what a dictionary

00:35:31.550 --> 00:35:33.630
is going to provide for me.

00:35:33.630 --> 00:35:36.240
So rather than
indexing on integers

00:35:36.240 --> 00:35:38.790
I'd like to index directly
on the item of interest.

00:35:38.790 --> 00:35:41.340
I'd like to say
where's Ana's record

00:35:41.340 --> 00:35:43.990
and find that in
one data structure.

00:35:43.990 --> 00:35:47.040
And so, whereas a list
is indexed by integers,

00:35:47.040 --> 00:35:50.880
and has elements associated
with it, a dictionary is going

00:35:50.880 --> 00:35:55.670
to combine a key, or if you
like, a name of some sort,

00:35:55.670 --> 00:35:57.200
with an actual value.

00:35:57.200 --> 00:35:59.150
And we're going to
index just by the name

00:35:59.150 --> 00:36:02.560
or the label as we go into it.

00:36:02.560 --> 00:36:05.210
So let me show
you some examples.

00:36:05.210 --> 00:36:07.750
First of all, to create a
dictionary I use curly braces,

00:36:07.750 --> 00:36:09.790
open closed curly brace,
so an empty dictionary

00:36:09.790 --> 00:36:11.550
would be simply that call.

00:36:11.550 --> 00:36:13.900
If I want to create
an actual dictionary,

00:36:13.900 --> 00:36:15.430
before I insert
things into it, I

00:36:15.430 --> 00:36:17.950
use a little bit of
a funky notation.

00:36:17.950 --> 00:36:21.970
It is a key or a label,
a colon, and then

00:36:21.970 --> 00:36:24.250
a value, in this
case the string Ana

00:36:24.250 --> 00:36:28.210
and the string b, followed
by a comma which separates it

00:36:28.210 --> 00:36:32.290
from the next pairing
of a key and a label,

00:36:32.290 --> 00:36:36.080
or a key and a value, and so on.

00:36:36.080 --> 00:36:38.140
So if I do this what it
does in my dictionary

00:36:38.140 --> 00:36:44.140
is it creates pairings of
those labels with the values

00:36:44.140 --> 00:36:47.250
I associated with them.

00:36:47.250 --> 00:36:50.867
OK, these are pretty
simple, but in fact, there's

00:36:50.867 --> 00:36:52.450
lots of nice things
we can do with it.

00:36:52.450 --> 00:36:55.780
So once we've got them indexing
now is similar to a list

00:36:55.780 --> 00:36:58.120
but not done by a number,
it's done by value.

00:36:58.120 --> 00:37:02.350
So if that's my key, I can
say, what's John's grade,

00:37:02.350 --> 00:37:05.230
notice the call, it's grades,
which is in my dictionary,

00:37:05.230 --> 00:37:09.037
open close square brackets,
with the label John.

00:37:09.037 --> 00:37:11.620
And what it does, it goes in and
finds that in the dictionary,

00:37:11.620 --> 00:37:14.102
returns the value
associated with it.

00:37:14.102 --> 00:37:15.980
If I ask for something
not in the dictionary,

00:37:15.980 --> 00:37:19.380
it's going to give
me a key error.

00:37:19.380 --> 00:37:22.330
Other things we can
do with dictionaries,

00:37:22.330 --> 00:37:27.010
we can add entries just
like we would do with lists.

00:37:27.010 --> 00:37:30.460
Grades as a dictionary, in open
and closed square brackets,

00:37:30.460 --> 00:37:34.980
I put in a new
label and a value,

00:37:34.980 --> 00:37:38.480
and that adds that
to the dictionary.

00:37:38.480 --> 00:37:41.780
I can test if something's in
the dictionary by simply saying,

00:37:41.780 --> 00:37:45.440
is this label in
grades, and it simply

00:37:45.440 --> 00:37:49.070
checks all of the labels or
the keys for the dictionary

00:37:49.070 --> 00:37:53.130
to see if it's there, and
if it's not returns false.

00:37:53.130 --> 00:37:56.880
I can remove entries, del,
something we've seen before,

00:37:56.880 --> 00:37:57.859
a very generic thing.

00:37:57.859 --> 00:37:59.650
It will delete something,
and in this case,

00:37:59.650 --> 00:38:01.740
it says, in the
dictionary grades,

00:38:01.740 --> 00:38:05.640
find the entry associated
with that key, sorry, Ana,

00:38:05.640 --> 00:38:09.519
you're about to be
flushed, remove it.

00:38:09.519 --> 00:38:11.810
She's only getting a b in
the class and she teaches it.

00:38:11.810 --> 00:38:15.312
We've got to do something
about this, right?

00:38:15.312 --> 00:38:17.020
So I can add things,
I can delete things,

00:38:17.020 --> 00:38:18.415
I can test if things are there.

00:38:18.415 --> 00:38:20.320
Let me show you a
couple of other things

00:38:20.320 --> 00:38:22.880
about dictionaries.

00:38:22.880 --> 00:38:26.960
I can ask for all of the
keys in the dictionary.

00:38:26.960 --> 00:38:29.390
Notice the format, there is
that dot notation, grades

00:38:29.390 --> 00:38:32.480
as a dictionary, it says, use
the keys method associated

00:38:32.480 --> 00:38:35.030
with this data
structure dictionaries.

00:38:35.030 --> 00:38:37.640
Open close actually
calls it, and it gives me

00:38:37.640 --> 00:38:43.831
back a collection of all the
keys in some arbitrary order.

00:38:43.831 --> 00:38:45.490
I'm going to use
a funny term here

00:38:45.490 --> 00:38:47.330
which I'm not certain
we've seen so far.

00:38:47.330 --> 00:38:50.560
It returns something we call
an iterable, it's like range.

00:38:50.560 --> 00:38:52.900
Think of it as giving us back
the equivalent of a list,

00:38:52.900 --> 00:38:54.316
it's not actually
a list, but it's

00:38:54.316 --> 00:38:55.910
something we can walk down.

00:38:55.910 --> 00:38:58.210
Which is exactly why I
can then say, is something

00:38:58.210 --> 00:39:02.230
in a dictionary, because it
returns this set of keys,

00:39:02.230 --> 00:39:04.300
and I can test to see
something's in there.

00:39:04.300 --> 00:39:06.500
I can similarly get
all of the values

00:39:06.500 --> 00:39:11.470
if I wanted to look at them,
giving us out two iterables.

00:39:11.470 --> 00:39:16.740
Here are the key things to keep
in mind about dictionaries.

00:39:16.740 --> 00:39:20.989
The values can be anything,
any type, mutable, immutable.

00:39:20.989 --> 00:39:22.030
They could be duplicates.

00:39:22.030 --> 00:39:23.800
That'd actually makes sense,
I could have the same value

00:39:23.800 --> 00:39:26.020
associated, for example,
the same grade associated

00:39:26.020 --> 00:39:28.540
with different people,
that's perfectly fine.

00:39:28.540 --> 00:39:31.240
The values could be lists, they
could be other data structures,

00:39:31.240 --> 00:39:32.823
they could even be
other dictionaries.

00:39:32.823 --> 00:39:35.670
They can be anything,
which is great.

00:39:35.670 --> 00:39:40.590
The keys, the first part of it
are a little more structure.

00:39:40.590 --> 00:39:42.750
They need to be unique.

00:39:42.750 --> 00:39:43.890
Well duh, that make sense.

00:39:43.890 --> 00:39:46.500
If I have that same key in
two places in the dictionary,

00:39:46.500 --> 00:39:47.580
when I go to look
it up, how am I

00:39:47.580 --> 00:39:48.871
going to know which one I want?

00:39:48.871 --> 00:39:51.240
So it needs to be
unique, and they also

00:39:51.240 --> 00:39:54.254
need to be immutable,
which also makes sense.

00:39:54.254 --> 00:39:56.420
If I'm storing something
in a key in the dictionary,

00:39:56.420 --> 00:39:59.057
and I can go and change
the value of the key,

00:39:59.057 --> 00:40:01.140
how am I going to remember
what I was looking for?

00:40:01.140 --> 00:40:05.510
So they can only be things like
ints, floats, strings, tuples,

00:40:05.510 --> 00:40:06.792
Booleans.

00:40:06.792 --> 00:40:08.750
I don't recommend using
floats because you need

00:40:08.750 --> 00:40:10.370
to make sure it's
exactly the same float

00:40:10.370 --> 00:40:12.320
and that's sometimes a
little bit challenging,

00:40:12.320 --> 00:40:15.590
but nonetheless, you can have
any immutable type as your key.

00:40:15.590 --> 00:40:18.670
And notice that there's no
order to the keys or the values.

00:40:18.670 --> 00:40:21.110
They are simply stored
arbitrarily by the Python

00:40:21.110 --> 00:40:23.490
as it puts them in.

00:40:23.490 --> 00:40:27.210
So if I compare these two, lists
or ordered sequences indexed

00:40:27.210 --> 00:40:30.480
by integers, I look them
up by integer index,

00:40:30.480 --> 00:40:33.000
and the indices have to have
an order as a consequence.

00:40:33.000 --> 00:40:35.670
Dictionaries are this
nice generalization,

00:40:35.670 --> 00:40:37.830
arbitrarily match
keys to values.

00:40:37.830 --> 00:40:40.470
I simply look up one
item by looking up things

00:40:40.470 --> 00:40:42.450
under the appropriate key.

00:40:42.450 --> 00:40:47.270
All I require is that the
keys have to be immutable.

00:40:47.270 --> 00:40:48.990
OK, I want to do
two last things I've

00:40:48.990 --> 00:40:51.170
got seven minutes to go here.

00:40:51.170 --> 00:40:53.652
I want to show you an example
of using dictionaries,

00:40:53.652 --> 00:40:55.610
and I'm going to do this
with a little bit more

00:40:55.610 --> 00:40:56.818
interesting, I hope, example.

00:40:56.818 --> 00:40:58.571
I want to analyze song lyrics.

00:40:58.571 --> 00:41:00.320
Now I'm going to show
you, you can already

00:41:00.320 --> 00:41:02.460
tell the difference between
my age and Ana's age.

00:41:02.460 --> 00:41:05.832
She used Taylor Swift
and Justin Bieber.

00:41:05.832 --> 00:41:07.040
I'm going to use The Beatles.

00:41:07.040 --> 00:41:08.390
That's more my generation.

00:41:08.390 --> 00:41:09.740
Most of you have never
heard of The Beatles

00:41:09.740 --> 00:41:11.615
unless you watched
Shining Time Station where

00:41:11.615 --> 00:41:13.862
you saw Ringo Starr, right?

00:41:13.862 --> 00:41:15.320
OK, what I'm going
to do is, I want

00:41:15.320 --> 00:41:17.000
to write a little
set of procedures

00:41:17.000 --> 00:41:21.500
that record the frequencies
of words in a song lyric.

00:41:21.500 --> 00:41:24.510
So I'm going to match strings,
or words, to integers.

00:41:24.510 --> 00:41:27.980
How many times did that word
appear in the song lyric?

00:41:27.980 --> 00:41:30.380
And then I want to ask,
can I easily figure out

00:41:30.380 --> 00:41:33.627
which words occur most
often, and how many times.

00:41:33.627 --> 00:41:35.210
Then I'm going to
gather them together

00:41:35.210 --> 00:41:37.127
to see what are the most
common words in here.

00:41:37.127 --> 00:41:39.585
And I'm going to do that where
I'm going to let a user say,

00:41:39.585 --> 00:41:42.530
I want every word that appears
more than some number of times.

00:41:42.530 --> 00:41:44.150
It's a simple
example, but I want

00:41:44.150 --> 00:41:45.980
you to see how a mutation
of the dictionary

00:41:45.980 --> 00:41:49.950
gives you a really powerful
tool for solving this problem.

00:41:49.950 --> 00:41:52.774
So let's write the
code to do that.

00:41:52.774 --> 00:41:55.590
It's also in the
handout, here we go.

00:41:55.590 --> 00:42:00.779
Lyrics to frequency's, lyrics is
just a list of words, strings.

00:42:00.779 --> 00:42:02.570
So I'm going to set up
an empty dictionary,

00:42:02.570 --> 00:42:05.000
there's that open
close curly brace,

00:42:05.000 --> 00:42:06.710
and here's what I want to do.

00:42:06.710 --> 00:42:08.930
I'm going to walk through
all the words in lyrics.

00:42:08.930 --> 00:42:10.596
You've seen this
before, this is looping

00:42:10.596 --> 00:42:12.690
over every word in lyrics.

00:42:12.690 --> 00:42:14.330
Ah, notice what I'm going to do.

00:42:14.330 --> 00:42:17.960
I'm going to simply say-- so
the first part is, I can easily

00:42:17.960 --> 00:42:20.180
iterate over the list,
--but now I'm going to say,

00:42:20.180 --> 00:42:23.400
if the word is in
the dictionary,

00:42:23.400 --> 00:42:25.470
and because the
dictionary is iterable,

00:42:25.470 --> 00:42:27.600
it's simply going to give
me back all of the keys,

00:42:27.600 --> 00:42:29.224
it's simply going to
say, in this case,

00:42:29.224 --> 00:42:32.050
if it's in the dictionary,
it's already there,

00:42:32.050 --> 00:42:33.890
I've got some value
associated with it,

00:42:33.890 --> 00:42:37.040
get the value out, add
1 to it, put it back in.

00:42:39.640 --> 00:42:41.540
If it's not already
in the dictionary,

00:42:41.540 --> 00:42:44.260
this is the first time
I've seen it, just store it

00:42:44.260 --> 00:42:45.860
into the dictionary.

00:42:45.860 --> 00:42:48.575
And when I'm done just
return the dictionary.

00:42:48.575 --> 00:42:50.750
OK?

00:42:50.750 --> 00:42:53.170
So I'm going to, if I can do
this right with my Python,

00:42:53.170 --> 00:42:55.080
show you an example of this.

00:42:55.080 --> 00:43:00.900
I have put in one of the
great classic Beatles songs,

00:43:00.900 --> 00:43:03.319
you might recognize
it right there.

00:43:03.319 --> 00:43:05.860
Mostly because it's got a whole
lot of repetitions of things.

00:43:05.860 --> 00:43:07.832
So she loves you yeah,
yeah, yeah, yeah.

00:43:07.832 --> 00:43:09.790
Sorry, actually they sing
it better than I just

00:43:09.790 --> 00:43:11.350
did it sarcastically.

00:43:11.350 --> 00:43:13.390
Sorry about that, but I
got she loves you there,

00:43:13.390 --> 00:43:15.920
and here's my code up
here, lyrics to frequency.

00:43:15.920 --> 00:43:18.230
So let's see what
happens if we call it.

00:43:18.230 --> 00:43:26.520
And we say lyrics to
frequencies she loves you.

00:43:29.660 --> 00:43:31.360
And it would help
if I can type, all

00:43:31.360 --> 00:43:33.940
right, we'll try it
one more time, lyrics

00:43:33.940 --> 00:43:44.100
to frequency's, she loves you.

00:43:44.100 --> 00:43:47.740
Cool, this gave me
back a dictionary,

00:43:47.740 --> 00:43:49.987
you can see the curly
braces, and there

00:43:49.987 --> 00:43:52.570
are all the words that appear
in there and the number of times

00:43:52.570 --> 00:43:55.360
that they appear.

00:43:55.360 --> 00:43:56.760
What's the order?

00:43:56.760 --> 00:43:57.900
You don't care.

00:43:57.900 --> 00:43:58.590
You don't know.

00:43:58.590 --> 00:44:00.090
What we want to do
is to think about

00:44:00.090 --> 00:44:01.860
how can we analyze
this, so let's go back

00:44:01.860 --> 00:44:04.030
and look at the
last piece of this.

00:44:04.030 --> 00:44:09.810
Which is, OK, I can convert
lyrics to frequencies.

00:44:09.810 --> 00:44:12.560
So here's the next thing
I want to do, how do I

00:44:12.560 --> 00:44:14.660
find the most common words?

00:44:14.660 --> 00:44:16.520
Well, here's what
I'm going to do,

00:44:16.520 --> 00:44:19.160
frequencies is the
dictionary, something

00:44:19.160 --> 00:44:21.570
that I just pulled out.

00:44:21.570 --> 00:44:24.230
So I can use the
values method on it

00:44:24.230 --> 00:44:26.330
which returns and iterable,
as I said earlier,

00:44:26.330 --> 00:44:28.860
again notice the open close
because I got to call it.

00:44:28.860 --> 00:44:31.239
That gives me back
an iterable that

00:44:31.239 --> 00:44:33.030
has all of the frequencies
inside of there,

00:44:33.030 --> 00:44:36.172
because it's an iterable,
I can use max on it,

00:44:36.172 --> 00:44:38.130
and it will take that
editable and give me back

00:44:38.130 --> 00:44:39.445
the biggest value.

00:44:39.445 --> 00:44:41.695
I'm going to call that
best, I'm going to set up

00:44:41.695 --> 00:44:43.320
words to be an empty
list, and then I'm

00:44:43.320 --> 00:44:45.210
just going to walk
through all of the entries

00:44:45.210 --> 00:44:49.680
in the dictionary saying,
if the value at that entry

00:44:49.680 --> 00:44:53.670
is equal to best add
that entry into words,

00:44:53.670 --> 00:44:56.260
just append it onto
the end of the list.

00:44:56.260 --> 00:44:57.760
And when I'm done
all of that loop,

00:44:57.760 --> 00:45:00.960
I'm just going to return a
tuple of both the collections

00:45:00.960 --> 00:45:03.450
of words that period
that many times

00:45:03.450 --> 00:45:05.355
and how often they appeared.

00:45:05.355 --> 00:45:07.230
I'm going to show you
an example in a second,

00:45:07.230 --> 00:45:10.454
but notice I'm simply using the
properties of the dictionary.

00:45:10.454 --> 00:45:12.120
The last thing I want
to do then is say,

00:45:12.120 --> 00:45:14.110
I want to see how
often the words appear.

00:45:14.110 --> 00:45:17.160
So I'm going to give it a
dictionary and a minimum number

00:45:17.160 --> 00:45:18.530
of times.

00:45:18.530 --> 00:45:21.120
And here I'm going to set
result up to be an empty list,

00:45:21.120 --> 00:45:23.100
I'm going to create
a flag called false,

00:45:23.100 --> 00:45:25.140
it's going to keep
track of when I'm done.

00:45:25.140 --> 00:45:27.450
And as long as I'm
not yet done, I'll

00:45:27.450 --> 00:45:28.950
call that previous
procedure that's

00:45:28.950 --> 00:45:31.110
going to give me back
the most common words

00:45:31.110 --> 00:45:33.380
and how often they appeared.

00:45:33.380 --> 00:45:34.920
I check and remember
it was a tuple,

00:45:34.920 --> 00:45:37.211
how often do they appear, if
it's bigger than the thing

00:45:37.211 --> 00:45:41.140
I'm looking for, I'll
add that into my result.

00:45:41.140 --> 00:45:43.300
And then the best
part is, I'm now

00:45:43.300 --> 00:45:44.980
going to walk
through all the words

00:45:44.980 --> 00:45:47.920
that appeared that many
times, and just delete them

00:45:47.920 --> 00:45:49.654
from the dictionary.

00:45:49.654 --> 00:45:50.820
I can mutate the dictionary.

00:45:50.820 --> 00:45:54.342
And by doing that, I can go
back around and do this again,

00:45:54.342 --> 00:45:56.550
and it will pull out how
many times has this appeared

00:45:56.550 --> 00:45:57.540
and keep doing it.

00:45:57.540 --> 00:45:59.250
When I can go all
the way through that,

00:45:59.250 --> 00:46:01.470
if I can't find any
more, I'll set the flag

00:46:01.470 --> 00:46:03.540
to true which means it
will drop out of here

00:46:03.540 --> 00:46:07.207
and return the result. I'm going
to let you run this yourself,

00:46:07.207 --> 00:46:09.290
if you do that, you'll
find that it comes up with,

00:46:09.290 --> 00:46:11.580
not surprisingly, I think
yeah is the most common one

00:46:11.580 --> 00:46:14.434
and she loves you, followed
by loves and a few others.

00:46:14.434 --> 00:46:16.850
What I want you to see here
is how the dictionary captured

00:46:16.850 --> 00:46:19.430
the pieces we wanted to.

00:46:19.430 --> 00:46:23.110
Very last one,
there's Fibonacci,

00:46:23.110 --> 00:46:25.470
as we called it before.

00:46:25.470 --> 00:46:27.540
It's actually
incredibly inefficient,

00:46:27.540 --> 00:46:29.750
because if I call it, I
have to do all the sub

00:46:29.750 --> 00:46:32.880
calls until I get down to
the base case, which is OK.

00:46:32.880 --> 00:46:36.030
But notice, every
other thing I do here,

00:46:36.030 --> 00:46:39.080
I've actually
computed those values.

00:46:39.080 --> 00:46:41.120
I'm wasting measures,
or wasting time,

00:46:41.120 --> 00:46:44.180
it's not so bad with fib of
5, but if this is fib of 20,

00:46:44.180 --> 00:46:46.760
almost everything on the
right hand side of this tree

00:46:46.760 --> 00:46:48.260
I've already computed once.

00:46:48.260 --> 00:46:51.880
That means fibs
very inefficient.

00:46:51.880 --> 00:46:55.930
I can improve it by using a
dictionary, very handy tool.

00:46:55.930 --> 00:46:58.720
I'm going to call fib not
only with a value of n,

00:46:58.720 --> 00:47:00.220
but a dictionary
which initially I'm

00:47:00.220 --> 00:47:03.250
going to initialized
to the base cases.

00:47:03.250 --> 00:47:05.500
And notice what I do, I'm
going to say if I've already

00:47:05.500 --> 00:47:09.580
computed this, just return
the value in the dictionary.

00:47:09.580 --> 00:47:12.670
If I haven't, go ahead
and do the computation,

00:47:12.670 --> 00:47:15.400
store it in the
dictionary at that point,

00:47:15.400 --> 00:47:17.912
and return the answer.

00:47:17.912 --> 00:47:19.370
Different way of
thinking about it,

00:47:19.370 --> 00:47:21.620
and the reason this is really
nice is a method called

00:47:21.620 --> 00:47:26.090
memoization, is if
I call fib of 34

00:47:26.090 --> 00:47:30.650
the standard way it takes 11
million plus recursive calls

00:47:30.650 --> 00:47:31.685
to get the answer out.

00:47:31.685 --> 00:47:32.900
It takes a long time.

00:47:32.900 --> 00:47:34.400
I've given you some
code for it, you

00:47:34.400 --> 00:47:36.860
can try it and see
how long it takes.

00:47:36.860 --> 00:47:40.710
Using the dictionary to keep
track of intermediate values,

00:47:40.710 --> 00:47:42.572
65 calls.

00:47:42.572 --> 00:47:44.780
And if you try it, you'll
see the difference in speed

00:47:44.780 --> 00:47:46.040
as you run this.

00:47:46.040 --> 00:47:47.510
So dictionaries
are valuable, not

00:47:47.510 --> 00:47:49.340
only for just storing
away data, they're

00:47:49.340 --> 00:47:53.750
valuable on procedure calls when
those intermediate values are

00:47:53.750 --> 00:47:55.125
not going to change.

00:47:55.125 --> 00:47:56.750
What you're going to
see as we go along

00:47:56.750 --> 00:47:59.390
is we're going to use exactly
these ideas, using dictionaries

00:47:59.390 --> 00:48:02.600
to capture information, but
especially using recursion

00:48:02.600 --> 00:48:04.490
to break bigger problems
down into smaller

00:48:04.490 --> 00:48:07.160
versions of the same problem,
to use that as a tool

00:48:07.160 --> 00:48:10.430
for solving what turn out
to be really complex things.

00:48:10.430 --> 00:48:13.410
And with that, we'll
see you next time.