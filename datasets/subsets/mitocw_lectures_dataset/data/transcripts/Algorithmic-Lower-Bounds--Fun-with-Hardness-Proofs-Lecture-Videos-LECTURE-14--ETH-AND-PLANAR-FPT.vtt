WEBVTT

00:00:00.080 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.820
Commons license.

00:00:03.820 --> 00:00:06.060
Your support will help
MIT OpenCourseWare

00:00:06.060 --> 00:00:10.150
continue to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.330
at ocw.mit.edu.

00:00:26.510 --> 00:00:29.536
PROFESSOR: Today
we start a-- we're

00:00:29.536 --> 00:00:31.910
going to take a little break
from parametrized complexity

00:00:31.910 --> 00:00:34.830
and talk about something called
exponential time hypothesis,

00:00:34.830 --> 00:00:37.840
which I've mentioned a few
times but we haven't really

00:00:37.840 --> 00:00:40.846
talked about its many
cool consequences.

00:00:51.280 --> 00:00:52.980
I'll abbreviate it ETH.

00:00:56.240 --> 00:01:00.270
And the idea is
think about 3SAT.

00:01:03.000 --> 00:01:12.545
and the claim is it has no 2
the little of n time algorithm.

00:01:18.030 --> 00:01:21.030
So of course you could
make analogous assumptions

00:01:21.030 --> 00:01:26.080
about KSAT set for various K.
But in general, the hypothesis

00:01:26.080 --> 00:01:29.755
is that for any fixed K, there
is no 2 to the little l of n

00:01:29.755 --> 00:01:30.500
time algorithm.

00:01:30.500 --> 00:01:33.530
So 3SAT is the smallest
one where that should hold.

00:01:33.530 --> 00:01:36.050
2SAT, of course, is easy.

00:01:36.050 --> 00:01:40.080
This is not the
maximization version.

00:01:40.080 --> 00:01:42.110
And our evidence
for this is merely

00:01:42.110 --> 00:01:45.570
that we haven't been able
to find such an algorithm.

00:01:45.570 --> 00:01:49.090
There are better than
2 to the n algorithms.

00:01:49.090 --> 00:01:50.590
The obvious algorithm
is 2 to the n,

00:01:50.590 --> 00:01:54.340
try all possible
assignments times n.

00:01:54.340 --> 00:01:58.090
But we won't worry about
the non-exponential part.

00:01:58.090 --> 00:02:03.760
The best algorithm to
date is 1.31 to the n.

00:02:03.760 --> 00:02:05.270
That's just from
three years ago.

00:02:05.270 --> 00:02:06.990
So it's an active
area of research.

00:02:06.990 --> 00:02:09.250
Many people have tried to
find better SAT algorithms.

00:02:09.250 --> 00:02:11.460
But conjecture is
you cannot get, like,

00:02:11.460 --> 00:02:14.890
2 the square root of n, the sum,
and be complete problems have 2

00:02:14.890 --> 00:02:16.770
to the square root of
n time algorithms--

00:02:16.770 --> 00:02:18.270
we'll see some today.

00:02:18.270 --> 00:02:19.970
I'll mention some.

00:02:19.970 --> 00:02:22.200
But seems like 2 to
some constant times

00:02:22.200 --> 00:02:26.190
n or some constant to
the n power equivalently

00:02:26.190 --> 00:02:29.690
is the right answer for 3SAT.

00:02:29.690 --> 00:02:34.250
Now one issue to talk
about very briefly--

00:02:34.250 --> 00:02:36.840
it won't actually
matter-- is what is n?

00:02:36.840 --> 00:02:38.670
Normally n is the
entire problem size,

00:02:38.670 --> 00:02:42.080
which would be the
number of clauses,

00:02:42.080 --> 00:02:45.470
essentially, because each
clause has three variables.

00:02:45.470 --> 00:02:47.490
But the usual
assumption is to say

00:02:47.490 --> 00:02:56.150
this is the number of variables
and m is the number of clauses.

00:02:56.150 --> 00:02:58.020
But these turn out
to be the same thing.

00:03:04.930 --> 00:03:07.390
So one assumption is equivalent
to the other assumption,

00:03:07.390 --> 00:03:10.040
so henceforth we don't
need to worry about this.

00:03:15.220 --> 00:03:17.320
In general, m is
at most n cubed,

00:03:17.320 --> 00:03:20.630
because each clause can have
three different variables,

00:03:20.630 --> 00:03:23.600
so there's only n
cubed possible clauses.

00:03:23.600 --> 00:03:25.970
But when we're worried
about this little o thing,

00:03:25.970 --> 00:03:27.850
we actually care
about polynomials,

00:03:27.850 --> 00:03:29.870
because we're in the exponent.

00:03:29.870 --> 00:03:32.930
So it turns out you can
sort of think of m and n

00:03:32.930 --> 00:03:36.680
as being linearly related--
that's OK-- by something called

00:03:36.680 --> 00:03:38.020
sparsification lemma.

00:03:38.020 --> 00:03:40.870
It says that if you have a
formula with a superlinear

00:03:40.870 --> 00:03:43.010
number of clauses,
you can convert it

00:03:43.010 --> 00:03:47.670
into some vaguely reasonable
number of formulas

00:03:47.670 --> 00:03:51.350
with a linear number of clauses.

00:03:51.350 --> 00:03:53.899
It's, like, 2 to the epsilon
n different formulas,

00:03:53.899 --> 00:03:55.440
each with a linear
number of clauses.

00:03:55.440 --> 00:03:58.740
And so the end effect
we need to know

00:03:58.740 --> 00:04:01.250
is that these two
are equivalent.

00:04:01.250 --> 00:04:03.500
We can think of situations
where clauses and variables

00:04:03.500 --> 00:04:05.400
are linearly related.

00:04:05.400 --> 00:04:07.472
So that's the hypothesis.

00:04:07.472 --> 00:04:09.180
Of course, we don't
know how to prove it.

00:04:09.180 --> 00:04:11.346
If we proved it, it would
imply p does not equal np.

00:04:11.346 --> 00:04:13.440
This is sort of a
strong form of p

00:04:13.440 --> 00:04:15.360
does not equal np from
the SAT perspective.

00:04:15.360 --> 00:04:18.519
Because we have so many
reductions from SAT,

00:04:18.519 --> 00:04:21.230
you can turn this lower bound.

00:04:21.230 --> 00:04:23.100
If you assume this
lower bound about SAT,

00:04:23.100 --> 00:04:24.960
you can prove
corresponding lower bounds

00:04:24.960 --> 00:04:27.910
about other problems we've seen.

00:04:27.910 --> 00:04:30.730
While I'm here, let
me just tell you

00:04:30.730 --> 00:04:35.600
another version of ETH
called strong ETH, which

00:04:35.600 --> 00:04:49.240
is that CNF SAT has no 2 minus
epsilon to the n algorithm.

00:04:52.710 --> 00:04:54.540
So the idea is
there's some ideal

00:04:54.540 --> 00:04:56.880
constant to the n for each KSAT.

00:04:56.880 --> 00:05:00.600
But as K goes to infinity,
that constant goes to 2.

00:05:00.600 --> 00:05:02.200
So if you have
really large clauses,

00:05:02.200 --> 00:05:05.650
you can't be 2 to
the n, roughly.

00:05:05.650 --> 00:05:07.280
This is for all
epsilon greater than 0.

00:05:09.840 --> 00:05:12.670
So I won't talk about anything
that needs this assumption,

00:05:12.670 --> 00:05:15.920
but there is some work on-- you
can get very specific bounds

00:05:15.920 --> 00:05:18.820
on what the constant should
be if you assume strong ETH.

00:05:25.000 --> 00:05:29.160
Let's take a review
of past reductions.

00:05:29.160 --> 00:05:38.450
And I'm going to start with
3-coloring a graph for here.

00:05:38.450 --> 00:05:42.880
So this was our proof
that 3-coloring was hard.

00:05:42.880 --> 00:05:45.140
There was a clause
gadget, variable gadget,

00:05:45.140 --> 00:05:47.310
this thing of constant size.

00:05:47.310 --> 00:05:52.690
And the point is, if I
start with some 3SAT--

00:05:52.690 --> 00:05:55.050
this is a reduction from
3SAT-- if I start with a 3SAT

00:05:55.050 --> 00:05:58.460
instance that has n
variables and m causes,

00:05:58.460 --> 00:06:00.920
the number of vertices
and edges over here

00:06:00.920 --> 00:06:06.940
will be some constant
times n plus m.

00:06:06.940 --> 00:06:14.595
So 3-coloring, we get order
n plus m vertices and edges.

00:06:21.000 --> 00:06:24.080
So what does that give me
in terms of a lower bound?

00:06:24.080 --> 00:06:27.580
Well, if I assume ETH that
there's no 2 to the little of n

00:06:27.580 --> 00:06:33.490
and no 2 to the little of
m time algorithm for 3SAT,

00:06:33.490 --> 00:06:35.940
then I get a corresponding
thing that there's

00:06:35.940 --> 00:06:51.470
no 2 to the little of n
time algorithm for graphs

00:06:51.470 --> 00:06:58.570
with number of vertices and
number of edges linear in n.

00:06:58.570 --> 00:07:01.120
So I state it this way
because for graphs again,

00:07:01.120 --> 00:07:03.310
there's the issue of
sparse versus dense graphs.

00:07:03.310 --> 00:07:05.117
I could just say
for sparse graphs

00:07:05.117 --> 00:07:07.075
here, which each have a
linear number of edges.

00:07:10.020 --> 00:07:18.820
So this is, I should
say, ETH implies this.

00:07:18.820 --> 00:07:23.980
So while I thoroughly
believe p does not equal np,

00:07:23.980 --> 00:07:28.620
p does not equal np, ETH is
a little bit more unknown.

00:07:28.620 --> 00:07:30.210
So I'm going to
explicitly mention

00:07:30.210 --> 00:07:34.670
ETH teach every time I use it.

00:07:34.670 --> 00:07:39.790
And more generally if we look
at various past reductions,

00:07:39.790 --> 00:07:46.580
all we need to measure is
something called size blowup.

00:07:46.580 --> 00:07:49.280
Remember an np
reduction Karp style,

00:07:49.280 --> 00:07:51.850
you start with some instance x,
you make an instance x prime.

00:07:51.850 --> 00:07:57.090
And the size of x prime--
this was our reduction

00:07:57.090 --> 00:08:02.090
f-- the size of x prime should
be polynomial in the size of x.

00:08:02.090 --> 00:08:03.530
What's that polynomial?

00:08:03.530 --> 00:08:05.090
That's your blowup.

00:08:05.090 --> 00:08:11.040
So if we have n, which is
the size of x over here

00:08:11.040 --> 00:08:14.850
and n prime, which is
the size of x prime,

00:08:14.850 --> 00:08:23.354
this was polynomial in n
and that is the size blowup.

00:08:29.290 --> 00:08:36.539
And so in particular, if
we have linear blowup,

00:08:36.539 --> 00:08:38.700
like in this example
of 3-coloring,

00:08:38.700 --> 00:08:44.510
then we preserve
the ETH statement.

00:08:47.320 --> 00:08:54.750
No 2 to the little o
of n time algorithm,

00:08:54.750 --> 00:08:58.070
meaning if there was no 2 to
the little o of n algorithm

00:08:58.070 --> 00:09:00.213
for problem A, then
there'll be no 2

00:09:00.213 --> 00:09:02.830
to the little o of n
algorithm for problem B,

00:09:02.830 --> 00:09:08.050
because you could just convert
to only get a linear size

00:09:08.050 --> 00:09:10.730
blowup, run that
algorithm if there was a 2

00:09:10.730 --> 00:09:12.780
to the little o of n algorithm.

00:09:12.780 --> 00:09:15.730
And then that solves A in 2
to the little o of n time.

00:09:15.730 --> 00:09:17.530
So the usual argument,
but now we're

00:09:17.530 --> 00:09:21.690
giving explicit bounds
on the running time.

00:09:21.690 --> 00:09:24.480
More generally, if you
don't have linear blowup,

00:09:24.480 --> 00:09:29.720
let's call this function b of n.

00:09:29.720 --> 00:09:33.030
Let's say size of x prime is
always at most some function

00:09:33.030 --> 00:09:35.990
b of n, b for blowup.

00:09:35.990 --> 00:09:45.740
Then if there's no 2 to the
little o of n algorithm for A,

00:09:45.740 --> 00:09:51.190
then there will be no
2 to the little o of b

00:09:51.190 --> 00:09:59.220
inverse of n algorithm for B.

00:09:59.220 --> 00:10:02.130
So for example, if you have
quadratic blowup, b of n

00:10:02.130 --> 00:10:04.860
is n squared, then you
will say that there's no 2

00:10:04.860 --> 00:10:07.310
to the square root of
n, no 2 to the little o

00:10:07.310 --> 00:10:09.144
of square root of n algorithm.

00:10:11.780 --> 00:10:14.560
You can imagine how that goes.

00:10:14.560 --> 00:10:18.290
So here are some nice examples
of reductions we've seen.

00:10:18.290 --> 00:10:21.410
This one was from lecture seven.

00:10:21.410 --> 00:10:29.316
Then from lecture 10, we had
dominating set-- oh, sorry.

00:10:29.316 --> 00:10:31.880
I have one more
before dominating set.

00:10:31.880 --> 00:10:33.370
This was in the
context of proving

00:10:33.370 --> 00:10:35.170
planar vertex cover was hard.

00:10:35.170 --> 00:10:37.780
First, planar 3SAT was hard
and then a reduction from 3SAT.

00:10:37.780 --> 00:10:39.760
But ignore the planar
issue, because things

00:10:39.760 --> 00:10:43.320
are going to be a little
different for planar graphs.

00:10:43.320 --> 00:10:46.830
But for general graphs, this
was a reduction from 3SAT.

00:10:46.830 --> 00:10:53.130
And there was a constant
number of vertices and edges

00:10:53.130 --> 00:10:54.600
for each clause.

00:10:54.600 --> 00:10:57.770
And then also here, we had
to make a copy of variable

00:10:57.770 --> 00:11:00.000
for each occurrence,
but the total number

00:11:00.000 --> 00:11:02.070
of recurrences of all
variables is linear,

00:11:02.070 --> 00:11:05.310
because there's only three
occurrences per clause.

00:11:05.310 --> 00:11:09.130
So the total number of vertices
in these variable gadgets

00:11:09.130 --> 00:11:11.620
is also linear, so the
whole thing is linear.

00:11:11.620 --> 00:11:13.000
Size blowup is linear.

00:11:13.000 --> 00:11:26.120
And so vertex cover is another
example of this type of result.

00:11:26.120 --> 00:11:29.140
Assuming ETH, there is
no 2 to the little o

00:11:29.140 --> 00:11:33.041
of an algorithm for graphs whose
number vertices and edges is

00:11:33.041 --> 00:11:33.540
order m.

00:11:33.540 --> 00:11:35.788
AUDIENCE: Is there a
name for that class?

00:11:35.788 --> 00:11:38.530
PROFESSOR: That
should have a class,

00:11:38.530 --> 00:11:43.810
but-- I can make
one up, if you want.

00:11:43.810 --> 00:11:48.300
We could call it an
ETH-style graph problem,

00:11:48.300 --> 00:11:53.350
say sparse graphs no 2 to the
little o of n assuming ETH.

00:11:53.350 --> 00:11:56.250
So it's sort of saying it's
linearly related to SAT,

00:11:56.250 --> 00:11:59.870
but as far as I know it
doesn't have a proper name.

00:11:59.870 --> 00:12:01.600
It should, because
I had to write it

00:12:01.600 --> 00:12:04.700
many times in my notes.

00:12:04.700 --> 00:12:06.327
Another one was dominating set.

00:12:06.327 --> 00:12:08.410
I don't have a slide for
this, because there never

00:12:08.410 --> 00:12:12.420
was one, because the
reduction was so simple.

00:12:12.420 --> 00:12:14.900
It was if you have an edge
in the vertex cover instance,

00:12:14.900 --> 00:12:21.160
you convert it into a subdivided
edge and the original edge

00:12:21.160 --> 00:12:24.530
for dominating set.

00:12:24.530 --> 00:12:27.430
And then you have
the same problem.

00:12:27.430 --> 00:12:28.306
It's the domination.

00:12:28.306 --> 00:12:29.930
So it's the same
thing as vertex cover.

00:12:29.930 --> 00:12:32.221
You never want to put this
thing in the dominating set.

00:12:32.221 --> 00:12:34.300
You might as well move
to one of the neighbors.

00:12:34.300 --> 00:12:38.520
So that's again, a
linear size blowup.

00:12:38.520 --> 00:12:41.510
And so dominating set
is also in this class,

00:12:41.510 --> 00:12:44.660
who shall remain nameless.

00:12:44.660 --> 00:12:46.930
And another one
is Hamiltonicity.

00:12:46.930 --> 00:12:48.490
We saw a couple of
different proofs.

00:12:48.490 --> 00:12:51.340
This one is from lecture seven.

00:12:51.340 --> 00:12:53.300
This was ostensibly
for directed,

00:12:53.300 --> 00:12:58.350
thought it also claims to
work for undirected graphs.

00:12:58.350 --> 00:13:00.846
Linear?

00:13:00.846 --> 00:13:02.720
Maybe I'll jump to the
next one, because it's

00:13:02.720 --> 00:13:04.760
a bit of a stronger result.

00:13:04.760 --> 00:13:08.460
This was maximum degree
3, Hamiltonicity directed.

00:13:08.460 --> 00:13:11.240
This was lecture eight.

00:13:11.240 --> 00:13:14.570
It's also linear.

00:13:14.570 --> 00:13:16.280
I mean, the main
diagram is this.

00:13:16.280 --> 00:13:20.070
It's linear if you're not
aiming for planar graphs.

00:13:20.070 --> 00:13:22.280
And then there's no
crossover gadget here.

00:13:22.280 --> 00:13:25.340
And so the total complexity
of all these things is linear.

00:13:25.340 --> 00:13:26.950
So that's cool.

00:13:26.950 --> 00:13:33.535
So Hamiltonicity
is another example

00:13:33.535 --> 00:13:36.740
of a graph problem with no 2
to the little o of n algorithm,

00:13:36.740 --> 00:13:37.440
assuming ETH.

00:13:40.360 --> 00:13:45.770
And from this proof-- this was
for directed max degree 3--

00:13:45.770 --> 00:13:48.500
and it was also bipartite.

00:13:48.500 --> 00:13:52.380
And then we reduced that
to undirected-- sorry.

00:13:52.380 --> 00:13:55.870
We reduced from planar
directed max degree 3

00:13:55.870 --> 00:14:00.140
to planar bipartite
undirected max degree 3.

00:14:00.140 --> 00:14:01.890
And that's of
course also linear.

00:14:01.890 --> 00:14:05.300
So all these things
we get for free.

00:14:05.300 --> 00:14:06.836
We did them in
different contexts.

00:14:06.836 --> 00:14:07.960
That was for planar graphs.

00:14:07.960 --> 00:14:11.500
This one was for APX
hardness for independent set.

00:14:11.500 --> 00:14:14.510
But we use the same proof.

00:14:14.510 --> 00:14:16.360
And we have this biclique
for the variable.

00:14:16.360 --> 00:14:18.930
Now here you start to worry
this could be quadratic blowup.

00:14:21.450 --> 00:14:25.710
But this was actually a
reduction from 3SAT-3.

00:14:25.710 --> 00:14:28.476
So that we didn't have a
very large clique there.

00:14:28.476 --> 00:14:30.550
It was actually only
three nodes in it,

00:14:30.550 --> 00:14:33.670
so it's more like two edges.

00:14:33.670 --> 00:14:36.030
But in general,
3SAT, any constant

00:14:36.030 --> 00:14:37.910
would suffice for that proof.

00:14:37.910 --> 00:14:41.440
You also have to check that this
reduction from 3SAT to 3SAT-3

00:14:41.440 --> 00:14:42.109
is OK.

00:14:42.109 --> 00:14:44.400
But it's, again, linear blowup
because the total number

00:14:44.400 --> 00:14:47.010
of occurrences of all
variables is linear.

00:14:47.010 --> 00:14:58.770
So that was a whole bunch of
free results-- independent set,

00:14:58.770 --> 00:15:00.080
3SAT-3.

00:15:00.080 --> 00:15:04.060
That's not a graph problem, so
I won't write it in this list.

00:15:04.060 --> 00:15:07.230
Now, normally independent set
is the same thing as clique.

00:15:07.230 --> 00:15:09.420
In this universe,
that's not quite right

00:15:09.420 --> 00:15:11.170
because we're talking
about sparse graphs.

00:15:11.170 --> 00:15:14.410
For clique, it's still
the case that there's

00:15:14.410 --> 00:15:18.360
no 2 to the little o of
number of vertices algorithm.

00:15:18.360 --> 00:15:21.270
But the number of edges used to
be linear for independent set

00:15:21.270 --> 00:15:24.010
and becomes
quadratic for clique.

00:15:24.010 --> 00:15:26.060
So you have to be a little
careful with clique.

00:15:32.830 --> 00:15:35.130
So all is good as
long as we're talking

00:15:35.130 --> 00:15:37.800
about non-planar graphs.

00:15:37.800 --> 00:15:41.490
What about planar graphs?

00:15:41.490 --> 00:15:43.970
Well, this is not true
for planar graphs.

00:15:43.970 --> 00:15:48.110
In general, you tend to get
2 to the square root of n

00:15:48.110 --> 00:15:52.450
algorithms, and that's
tight, assuming ETH.

00:15:52.450 --> 00:15:56.585
So for example, planar 3SAT
we had a crossover gadget.

00:15:56.585 --> 00:15:58.710
And in the worst case,
there are a quadratic number

00:15:58.710 --> 00:16:00.900
of crossings.

00:16:00.900 --> 00:16:03.420
And so the blowup
in our problem size,

00:16:03.420 --> 00:16:05.860
because we spend
some constant number

00:16:05.860 --> 00:16:10.330
of vertices per crossover,
the blowup is quadratic.

00:16:10.330 --> 00:16:26.400
And so for, say,
planar 3SAT, ETH

00:16:26.400 --> 00:16:34.590
implies no 2 to the little o
of n or 2 to the little o of m

00:16:34.590 --> 00:16:38.049
algorithm-- sorry,
with square root.

00:16:44.280 --> 00:16:45.824
So with 3SAT, it's
a little annoying

00:16:45.824 --> 00:16:47.990
because we have to think
about variables and clauses

00:16:47.990 --> 00:16:48.820
separately.

00:16:48.820 --> 00:16:51.980
So the size blowup is not
quite as uniquely defined.

00:16:51.980 --> 00:16:56.050
But just analyzing number of
variables, number of clauses

00:16:56.050 --> 00:16:58.060
separately, the blowup
is quadratic in both.

00:16:58.060 --> 00:17:02.110
So that's the
lower bound we get.

00:17:02.110 --> 00:17:11.329
And then I have planar
3-coloring, vertex cover,

00:17:11.329 --> 00:17:15.855
dominating set, Hamiltonicity,
independent set.

00:17:18.380 --> 00:17:23.806
All of them have the
property that ETH implies.

00:17:23.806 --> 00:17:29.010
No 2 to the little o of
square root of n algorithm

00:17:29.010 --> 00:17:29.760
for planar graphs.

00:17:34.250 --> 00:17:36.290
Now planar graphs
are always sparse,

00:17:36.290 --> 00:17:40.520
so I don't need to worry about
how many edges versus vertices.

00:17:40.520 --> 00:17:44.850
n is within a constant of both.

00:17:44.850 --> 00:17:46.120
How you prove that?

00:17:46.120 --> 00:17:49.600
Exactly the same proofs
that we just looked at.

00:17:49.600 --> 00:17:51.994
They were all actually proofs
for the planar problem,

00:17:51.994 --> 00:17:53.660
but they all had some
kind of crossover.

00:17:53.660 --> 00:17:55.810
Either they started from
planar 3SAT, in which case

00:17:55.810 --> 00:17:57.450
they were already quadratic.

00:17:57.450 --> 00:18:01.950
Like this one was
from planar 3SAT

00:18:01.950 --> 00:18:04.240
and it was a linear
blowup from that.

00:18:04.240 --> 00:18:07.160
So it's only quadratic overall.

00:18:07.160 --> 00:18:12.390
This one was again, from planar
3SAT and linear after that.

00:18:12.390 --> 00:18:15.180
This one was from 3SAT.

00:18:15.180 --> 00:18:17.090
And then there was a
custom crossover gadget,

00:18:17.090 --> 00:18:18.720
which I don't have
the slide for here.

00:18:18.720 --> 00:18:20.095
But for each of
these crossovers,

00:18:20.095 --> 00:18:23.940
we paid something, so we
get quadratic from 3SAT.

00:18:23.940 --> 00:18:26.670
And that's linear, of course.

00:18:26.670 --> 00:18:31.620
And this is not a planar
independent set reduction,

00:18:31.620 --> 00:18:33.012
so I don't have one here.

00:18:33.012 --> 00:18:34.220
You have to fill in your own.

00:18:37.250 --> 00:18:39.030
And one other one was coloring.

00:18:39.030 --> 00:18:40.770
We did the planar
3-coloring gadget.

00:18:40.770 --> 00:18:44.010
Again, you pay constant
for each crossing.

00:18:44.010 --> 00:18:46.680
So quadratic reduction
from 3SAT-- all of them

00:18:46.680 --> 00:18:48.560
end up being quadratic overall.

00:18:48.560 --> 00:18:51.130
Independent set's the only
one I haven't shown you.

00:18:51.130 --> 00:18:53.170
And-- cool.

00:18:53.170 --> 00:18:56.620
So this is a sense in which
even though the planar problems

00:18:56.620 --> 00:18:59.681
are np hard, they a
little bit easier.

00:18:59.681 --> 00:19:00.180
Question?

00:19:00.180 --> 00:19:03.102
AUDIENCE: So you mentioned
that was [INAUDIBLE].

00:19:03.102 --> 00:19:03.950
PROFESSOR: Yeah.

00:19:03.950 --> 00:19:06.019
So I think-- I
should double check.

00:19:06.019 --> 00:19:07.560
I'm pretty sure all
of these problems

00:19:07.560 --> 00:19:13.990
have 2 to the square root
of n time algorithms.

00:19:13.990 --> 00:19:16.560
I'm confident enough that
I will write it down.

00:19:16.560 --> 00:19:20.380
I think the general approach
is Lipton Tarjan separator.

00:19:20.380 --> 00:19:24.730
But that's about the level
of detail I remember.

00:19:24.730 --> 00:19:27.400
Oh, yeah-- also,
all planar graphs

00:19:27.400 --> 00:19:30.140
have tree width order
square root of n.

00:19:30.140 --> 00:19:34.010
And generally, that will
give you such an algorithm.

00:19:40.710 --> 00:19:41.842
So that was-- question?

00:19:41.842 --> 00:19:43.550
AUDIENCE: Are there
any of these problems

00:19:43.550 --> 00:19:48.050
that you can, in a sense,
preserve the difficulty

00:19:48.050 --> 00:19:49.172
in a planar graph?

00:19:53.634 --> 00:19:55.300
PROFESSOR: Yeah,
that's a good question.

00:19:58.030 --> 00:19:59.240
We might get to some.

00:20:01.910 --> 00:20:04.660
I'm about to shift gears
into parametrized complexity.

00:20:04.660 --> 00:20:10.810
And in that setting-- I
would say generally no.

00:20:10.810 --> 00:20:12.940
But there are certainly
some exceptions

00:20:12.940 --> 00:20:14.760
where you can encode
a non-planar problem

00:20:14.760 --> 00:20:17.440
into a planar structure.

00:20:17.440 --> 00:20:19.605
But most natural problems
tend to be like this.

00:20:21.934 --> 00:20:23.350
But there definitely
are examples.

00:20:23.350 --> 00:20:26.700
We might even see one.

00:20:26.700 --> 00:20:30.110
This is sort of-- this could
have been in lecture two,

00:20:30.110 --> 00:20:31.360
and maybe it should have been.

00:20:31.360 --> 00:20:35.150
But ETH is nice
because it gives you

00:20:35.150 --> 00:20:37.030
a bit more of a
quantitative sense

00:20:37.030 --> 00:20:38.989
of how much running time
you should expect out

00:20:38.989 --> 00:20:39.780
of your algorithms.

00:20:39.780 --> 00:20:42.240
It gives you
motivation for going

00:20:42.240 --> 00:20:44.420
for linear blowup when
possible, or at least

00:20:44.420 --> 00:20:47.633
minimizing your blowup and lets
you distinguish between planar

00:20:47.633 --> 00:20:49.450
and non-planar problems.

00:20:49.450 --> 00:20:52.630
But we're in the middle of
parametrized complexity.

00:20:52.630 --> 00:20:54.550
And I mentioned all
this in particular

00:20:54.550 --> 00:20:56.170
because it has an
even bigger impact

00:20:56.170 --> 00:20:57.295
on parametrized complexity.

00:20:59.910 --> 00:21:01.705
So let's shift
over to that world.

00:21:17.810 --> 00:21:22.326
Now first of all, we get two
sort of trivial consequences

00:21:22.326 --> 00:21:23.450
just from these statements.

00:21:31.470 --> 00:21:32.930
They're trivial,
but in some cases

00:21:32.930 --> 00:21:34.150
they're actually interesting.

00:21:34.150 --> 00:21:38.734
So they're easy to prove, but
actually give tight answers

00:21:38.734 --> 00:21:39.525
for a few problems.

00:22:01.730 --> 00:22:05.020
So for the natural
parametrizations,

00:22:05.020 --> 00:22:07.750
a vertex cover is a vertex
cover size at most k.

00:22:07.750 --> 00:22:09.870
Longest path, which
is the optimization

00:22:09.870 --> 00:22:12.451
version of Hamiltonicity,
is their path--

00:22:12.451 --> 00:22:14.200
in the parametrized
version, is their path

00:22:14.200 --> 00:22:15.720
of length at least k?

00:22:15.720 --> 00:22:20.540
Dominating set of size k,
independent set of size k

00:22:20.540 --> 00:22:24.010
upper bound and lower bound.

00:22:24.010 --> 00:22:26.730
In particular, there can't be
a 2 to the little of k times

00:22:26.730 --> 00:22:29.726
polynomial in n algorithm,
because there's no 2

00:22:29.726 --> 00:22:31.220
to the little o of n algorithm.

00:22:31.220 --> 00:22:32.700
This is assuming ETH.

00:22:38.450 --> 00:22:41.510
Because in particular,
kb could be n.

00:22:41.510 --> 00:22:43.390
Now this is not exactly
what we care about.

00:22:43.390 --> 00:22:46.580
What we care about is whether
there's an f of k times

00:22:46.580 --> 00:22:48.350
polynomial in n algorithm.

00:22:48.350 --> 00:22:51.786
But this at least gives
you a lower bound on the f.

00:22:51.786 --> 00:22:55.740
So in particular, for dominating
set and independent set,

00:22:55.740 --> 00:22:57.380
this is not a very
interesting result,

00:22:57.380 --> 00:22:59.960
because in fact we will
show, assuming ETH,

00:22:59.960 --> 00:23:02.780
these do not have FPT
algorithms at all.

00:23:02.780 --> 00:23:04.307
There's nothing of that form.

00:23:04.307 --> 00:23:05.890
But for vertex cover,
it's interesting

00:23:05.890 --> 00:23:07.810
because that is FPT.

00:23:07.810 --> 00:23:10.840
And there is a constant to
the k times polynomial n in n

00:23:10.840 --> 00:23:11.340
algorithm.

00:23:11.340 --> 00:23:14.860
We saw a 2 to the n
times n algorithm.

00:23:14.860 --> 00:23:16.730
And this shows
that that's tight.

00:23:16.730 --> 00:23:20.140
So there's no better-- it
gives you a bound on f.

00:23:20.140 --> 00:23:22.730
For vertex cover, c to
the k is the right answer

00:23:22.730 --> 00:23:24.180
for some constant c.

00:23:24.180 --> 00:23:25.800
And if you assume
strong ETH, you

00:23:25.800 --> 00:23:28.050
can actually figure out what
the-- well, you could try

00:23:28.050 --> 00:23:29.299
to prove with the constant is.

00:23:29.299 --> 00:23:31.640
We don't know the right
answer for vertex cover.

00:23:31.640 --> 00:23:33.480
Some of these problems, we do.

00:23:33.480 --> 00:23:35.820
Longest path, same deal.

00:23:35.820 --> 00:23:41.410
It's FPT, so it's easy
to find short paths.

00:23:41.410 --> 00:23:45.430
And the algorithm is
like 2 to the order k

00:23:45.430 --> 00:23:48.730
times polynomial in n.

00:23:48.730 --> 00:23:53.740
And similarly for planar
problems, if we have ETH,

00:23:53.740 --> 00:23:58.660
there's no 2 to the little
o of square root of k times

00:23:58.660 --> 00:24:02.990
polynomial n for those same
problems on planar graphs.

00:24:10.110 --> 00:24:12.505
For clique, actually
this should also work.

00:24:20.230 --> 00:24:22.190
Clique is OK because
k is the number

00:24:22.190 --> 00:24:23.490
of vertices in the clique.

00:24:23.490 --> 00:24:25.656
And so even though the
number of edges is quadratic,

00:24:25.656 --> 00:24:27.490
this would still hold.

00:24:27.490 --> 00:24:30.590
For a planar clique, of
course it's polynomial.

00:24:30.590 --> 00:24:32.700
So I can't put clique down here.

00:24:39.070 --> 00:24:42.880
The maximum clique
size is 4, so there's

00:24:42.880 --> 00:24:43.940
an n to the 4 algorithm.

00:24:53.050 --> 00:24:57.060
Again, this is interesting
because for dominating

00:24:57.060 --> 00:25:02.120
set, independent set, vertex
cover and longest path,

00:25:02.120 --> 00:25:05.380
there are 2 to the square root
of k times polynomial in n

00:25:05.380 --> 00:25:06.040
algorithms.

00:25:06.040 --> 00:25:07.740
So this is actually
a tightness result.

00:25:10.400 --> 00:25:18.140
There exists 2 to the order
square root of k n to the order

00:25:18.140 --> 00:25:21.840
1 algorithms for planar
graphs for those problems.

00:25:21.840 --> 00:25:25.910
This is called subexponential
fixed parameter tractability.

00:25:25.910 --> 00:25:29.310
And there were a bunch of those
results in the early 2000s.

00:25:29.310 --> 00:25:31.650
And then a theory called
bidimensionality kind

00:25:31.650 --> 00:25:34.300
of characterizes when it's
possible, or gives you

00:25:34.300 --> 00:25:38.602
a big set of examples
where it is possible.

00:25:38.602 --> 00:25:40.560
But that's algorithm, so
we're not covering it.

00:25:44.130 --> 00:25:47.010
So all well and good.

00:25:47.010 --> 00:25:49.410
So for planar or dominating
set, that's interesting.

00:25:49.410 --> 00:25:51.060
But for general
dominating set, we

00:25:51.060 --> 00:25:53.650
know dominating
set is w2 complete,

00:25:53.650 --> 00:25:57.300
we think that means
there's FPT algorithm.

00:25:57.300 --> 00:26:00.030
Independent set in
clique, our w1 complete,

00:26:00.030 --> 00:26:03.560
we also think that
means no FPT algorithm.

00:26:03.560 --> 00:26:06.860
Assuming ETH, we can
actually prove that.

00:26:06.860 --> 00:26:18.560
So let's say there's
no FPT algorithm

00:26:18.560 --> 00:26:29.020
for clique/independent
set assuming ETH.

00:26:35.980 --> 00:26:38.590
So that's a theorem
we will prove.

00:26:38.590 --> 00:26:42.100
If you believe in ETH,
then w1-- these problems

00:26:42.100 --> 00:26:44.600
are complete for w1--
w1 does not equal FPT.

00:26:44.600 --> 00:26:46.455
These are the FPT problems.

00:26:46.455 --> 00:26:49.140
And in fact, we can prove
a much stronger bound.

00:26:55.810 --> 00:26:59.520
Very non-FPT-- these
algorithms generally

00:26:59.520 --> 00:27:03.340
have an n to the order k
algorithm, or if they're in xp,

00:27:03.340 --> 00:27:08.020
then they have some n to the
k to some constant algorithm.

00:27:08.020 --> 00:27:10.510
But we can't even
reduce that exponent

00:27:10.510 --> 00:27:16.947
below k for any-- for clique
and independent set, let's say.

00:27:16.947 --> 00:27:18.780
And if you reduce clique
and independent set

00:27:18.780 --> 00:27:22.314
to some other problem,
you can, just like we've

00:27:22.314 --> 00:27:23.730
been doing over
here, you can keep

00:27:23.730 --> 00:27:25.731
track of the parameter blowup.

00:27:25.731 --> 00:27:27.480
And if it's a quadratic
blowup, then you'd

00:27:27.480 --> 00:27:29.985
get that there's no n to the
square root of k algorithm.

00:27:29.985 --> 00:27:32.110
We'll actually do that in
a moment for planar graph

00:27:32.110 --> 00:27:33.080
problems.

00:27:33.080 --> 00:27:35.260
But for general graphs,
clique and independent set,

00:27:35.260 --> 00:27:38.980
no f of k for any
computable function f times

00:27:38.980 --> 00:27:41.120
n to the little of k algorithm.

00:27:41.120 --> 00:27:46.040
So this is much stronger
than FPT does not equal w1.

00:27:50.440 --> 00:27:58.670
And this is a result from 2006,
so fairly recent by Chen et al.

00:27:58.670 --> 00:28:01.400
So let's prove it.

00:28:01.400 --> 00:28:03.970
It is essentially a
reduction from 3-coloring.

00:28:07.020 --> 00:28:08.840
But it's unlike
most reductions we

00:28:08.840 --> 00:28:13.860
think about,
because-- well, it's

00:28:13.860 --> 00:28:16.440
unlike parametrized reductions.

00:28:16.440 --> 00:28:16.940
Question?

00:28:16.940 --> 00:28:20.170
AUDIENCE: Sorry, so is this
[INAUDIBLE] from claiming

00:28:20.170 --> 00:28:22.407
that the xp hard these problems?

00:28:22.407 --> 00:28:24.805
PROFESSOR: Yeah. xp hard
is really way up there.

00:28:24.805 --> 00:28:26.430
None of the problems
we've talked about

00:28:26.430 --> 00:28:31.498
are xp hard, unless something
happens with p versus np.

00:28:31.498 --> 00:28:33.706
AUDIENCE: But xp [INAUDIBLE]
problems that you have--

00:28:33.706 --> 00:28:38.270
PROFESSOR: These are
in xp, but they're also

00:28:38.270 --> 00:28:41.000
in-- these problems
are actually in w1,

00:28:41.000 --> 00:28:42.250
which is much smaller than xp.

00:28:45.060 --> 00:28:50.200
Yeah, I mentioned xp because of
the n to the k to some constant

00:28:50.200 --> 00:28:52.470
is related in the same vicinity.

00:28:52.470 --> 00:28:56.160
But it's not directly about xp.

00:28:56.160 --> 00:28:58.330
So normally when we do
parametrized reductions,

00:28:58.330 --> 00:28:59.930
we start from a
parametrized problem

00:28:59.930 --> 00:29:02.140
and we reduce to a
parametrized problem.

00:29:02.140 --> 00:29:04.570
Here, we are reducing from
an unparametrized problem.

00:29:04.570 --> 00:29:07.090
3-coloring has no parameter.

00:29:07.090 --> 00:29:09.310
And we are going to
reduce to clique,

00:29:09.310 --> 00:29:11.990
which has a parameter, namely
the size of the clique.

00:29:11.990 --> 00:29:14.300
So it's a little
weird, but you've

00:29:14.300 --> 00:29:16.770
got to get started somehow.

00:29:16.770 --> 00:29:21.840
So we're going to
introduce a quantity k

00:29:21.840 --> 00:29:26.890
and set it how we want to.

00:29:26.890 --> 00:29:29.910
So here's the idea.

00:29:29.910 --> 00:29:32.030
We are given an
instance of 3-coloring.

00:29:32.030 --> 00:29:33.420
We're given a graph.

00:29:33.420 --> 00:29:46.340
We're going to split the
vertices into k groups, each

00:29:46.340 --> 00:29:47.775
of n over k vertices.

00:30:04.540 --> 00:30:06.716
And remember, we know
that 3-coloring has no 2

00:30:06.716 --> 00:30:08.575
to the little of
n time algorithm.

00:30:08.575 --> 00:30:10.575
That's what I just
erased, assuming ETH.

00:30:13.540 --> 00:30:16.530
So I'm going to choose
k in a little bit.

00:30:16.530 --> 00:30:19.140
But let me first tell
you the reduction.

00:30:19.140 --> 00:30:22.175
So we're going to
create a new graph.

00:30:24.740 --> 00:30:35.870
Let's call it g prime, with
k groups of not n over k,

00:30:35.870 --> 00:30:37.910
but 3 to the n over k vertices.

00:30:43.500 --> 00:30:44.660
Why 3?

00:30:44.660 --> 00:30:48.200
Because we are going to think
about all possible 3-colorings

00:30:48.200 --> 00:30:50.194
of those n over k vertices.

00:30:50.194 --> 00:30:51.110
So it's corresponding.

00:30:51.110 --> 00:30:53.720
For every group up here,
we're going to just write down

00:30:53.720 --> 00:30:55.560
every possible 3-coloring.

00:30:55.560 --> 00:30:59.940
So obviously, n over k
has to be quite small,

00:30:59.940 --> 00:31:02.540
every possible 3-coloring of
those and n over k vertices.

00:31:05.210 --> 00:31:22.740
So the intent is that
in our clique problem,

00:31:22.740 --> 00:31:25.210
that we want to choose
exactly one vertex from each

00:31:25.210 --> 00:31:27.440
of these groups.

00:31:27.440 --> 00:31:31.799
So k is supposed to be
the size of our clique.

00:31:31.799 --> 00:31:33.090
That's why I wrote it this way.

00:31:39.140 --> 00:31:42.630
So at the moment, I have
vertices but I have no edges.

00:31:42.630 --> 00:31:44.890
Each of the groups is going
to be an independent set,

00:31:44.890 --> 00:31:47.680
so that means you can
only choose at most one

00:31:47.680 --> 00:31:50.400
vertex from each group,
to make a clique.

00:31:50.400 --> 00:31:53.144
And we are going to
connect to colorings

00:31:53.144 --> 00:31:54.060
if they're compatible.

00:31:59.812 --> 00:32:06.960
by an edge nG prime
if compatible.

00:32:10.290 --> 00:32:15.440
So the idea is, here is
one group, size n over k.

00:32:15.440 --> 00:32:19.200
Here is another group
of size n over k.

00:32:19.200 --> 00:32:24.380
And if you color these
vertices some colors--

00:32:24.380 --> 00:32:28.540
I'm only using one color--
and you color some colors over

00:32:28.540 --> 00:32:32.550
here, now it's coloring
within the group,

00:32:32.550 --> 00:32:35.850
but there are some
cross edges between here

00:32:35.850 --> 00:32:38.000
which may be incorrect.

00:32:38.000 --> 00:32:39.760
They may be monochromatic.

00:32:39.760 --> 00:32:41.572
And so we check
whether the coloring

00:32:41.572 --> 00:32:43.030
of this and the
coloring of this is

00:32:43.030 --> 00:32:45.840
consistent with all the cross
edges between those two groups.

00:32:45.840 --> 00:32:49.480
If it is compatible, if it's a
valid coloring of both groups,

00:32:49.480 --> 00:32:52.040
we connect them by an edge.

00:32:52.040 --> 00:32:54.260
This coloring corresponds
to single vertex in G prime

00:32:54.260 --> 00:32:56.760
and this coloring corresponds
to a single vertex in G prime.

00:32:56.760 --> 00:32:58.460
And we add an edge if it's OK.

00:32:58.460 --> 00:33:00.470
We don't add the
edge it's not OK.

00:33:00.470 --> 00:33:01.960
And if we're looking
for a clique,

00:33:01.960 --> 00:33:05.060
that means we need to choose a
coloring for each of the groups

00:33:05.060 --> 00:33:07.750
where everything is
pairwise compatible.

00:33:07.750 --> 00:33:09.317
And that represents
all the edges.

00:33:09.317 --> 00:33:11.400
Every edge is either within
a group, in which case

00:33:11.400 --> 00:33:14.540
it was taken care
of at this stage.

00:33:14.540 --> 00:33:17.980
I guess I should say is at
most, 3 to the n over k.

00:33:17.980 --> 00:33:20.565
I only want valid 3-colorings.

00:33:24.780 --> 00:33:27.167
Or the edge crosses
between two groups

00:33:27.167 --> 00:33:29.250
and then it will be
considered when we think about

00:33:29.250 --> 00:33:30.390
whether there's an edge.

00:33:30.390 --> 00:33:32.280
In a clique, there
are pairwise edges

00:33:32.280 --> 00:33:35.270
and so everything is
pairwise compatible.

00:33:35.270 --> 00:33:38.640
So never mind the claim.

00:33:38.640 --> 00:33:41.790
You should be convinced this
is a valid reduction, in terms

00:33:41.790 --> 00:33:45.410
of a correctness standpoint,
from 3-coloring to k

00:33:45.410 --> 00:33:48.330
clique for any k.

00:33:48.330 --> 00:33:49.580
The construction depends on k.

00:34:01.210 --> 00:34:02.350
So what do we set k to?

00:34:12.310 --> 00:34:14.872
Here is a setting
for k that will work.

00:34:14.872 --> 00:34:16.830
I don't have a ton of
intuition for this, other

00:34:16.830 --> 00:34:19.880
than the algebra works.

00:34:19.880 --> 00:34:22.070
Essentially, we need
to set it just--

00:34:22.070 --> 00:34:25.870
we want to set k to, like, a
tiny, super-constant thing.

00:34:25.870 --> 00:34:31.330
So just a little bit,
little omega of one.

00:34:31.330 --> 00:34:38.730
And I need to give that
little of k a name.

00:34:38.730 --> 00:34:51.639
So I'm going to say, let's
say k clique could be solved

00:34:51.639 --> 00:35:08.350
in f of k times n to the k
over s of k time, where s of k

00:35:08.350 --> 00:35:19.145
is some monotone, increasing,
and unbounded function.

00:35:22.900 --> 00:35:24.810
I need that s goes to infinity.

00:35:24.810 --> 00:35:26.385
That's the meaning
of little of k

00:35:26.385 --> 00:35:28.636
is that you can
divide by something.

00:35:28.636 --> 00:35:30.510
And you can assume
without loss of generality

00:35:30.510 --> 00:35:32.340
that the something is
monotone increasing,

00:35:32.340 --> 00:35:34.090
but in particular it
should go to infinity

00:35:34.090 --> 00:35:34.900
as k goes to infinity.

00:35:34.900 --> 00:35:36.250
It might go there very slowly.

00:35:36.250 --> 00:35:41.030
It could be, like, 1 over
2 to the k or something.

00:35:41.030 --> 00:35:46.530
But something little--
s is little omega of 1.

00:35:49.400 --> 00:35:51.910
But now I have this quantity s.

00:35:51.910 --> 00:36:12.530
And I'm going to set k as large
as possible so that f of k

00:36:12.530 --> 00:36:22.630
is at most n and k to the
k over s of k is at most n.

00:36:22.630 --> 00:36:24.900
My goal here is to
make k a function of n.

00:36:31.020 --> 00:36:35.850
And so one choice of k is
basically f inverse of n.

00:36:35.850 --> 00:36:40.430
So f, remember, was the
dependence on k, so here.

00:36:40.430 --> 00:36:41.820
This will turn out to work.

00:36:41.820 --> 00:36:46.204
So you can think of k
just being f inverse of n.

00:36:46.204 --> 00:36:47.870
But there's actually
another constraint.

00:36:47.870 --> 00:36:50.290
It's another inverse thing.

00:36:50.290 --> 00:36:55.440
I want k to be at most, the
inverse of this relation.

00:36:55.440 --> 00:36:59.010
So I'm basically taking the
min of these two functions of n

00:36:59.010 --> 00:37:02.864
that will be a function
of n, which is growing.

00:37:02.864 --> 00:37:03.780
I mean, you can check.

00:37:03.780 --> 00:37:06.030
If you set k to be a constant,
of course this is true.

00:37:06.030 --> 00:37:08.660
If you set k to be a constant,
of course this is true.

00:37:08.660 --> 00:37:11.430
So you can set it a
little bit superconstant

00:37:11.430 --> 00:37:13.300
by inverting this relation.

00:37:13.300 --> 00:37:17.070
That gives you some value of
k that would satisfy this,

00:37:17.070 --> 00:37:20.890
some function k equals k of
n that would satisfy this.

00:37:20.890 --> 00:37:23.190
And I want to take
the min of those two.

00:37:23.190 --> 00:37:26.680
Still a growing function of n.

00:37:26.680 --> 00:37:29.080
We'll need that in a moment.

00:37:29.080 --> 00:37:32.460
And I get these
two inequalities.

00:37:32.460 --> 00:37:39.930
Now it is just a computation of
how much running time I have.

00:37:39.930 --> 00:37:42.820
So I want to plug
this algorithm-- this

00:37:42.820 --> 00:37:44.870
was an algorithm for k clique.

00:37:44.870 --> 00:37:46.860
I have this instance
of k clique, which

00:37:46.860 --> 00:37:48.620
looks a little weird
because it's got

00:37:48.620 --> 00:37:50.379
potentially a lot of vertices.

00:37:50.379 --> 00:37:51.670
I'm just going to plug that in.

00:37:51.670 --> 00:37:56.450
This is my n prime, the new--
well, the number of vertices

00:37:56.450 --> 00:38:01.080
is this times k, because
they're k groups.

00:38:01.080 --> 00:38:06.710
So a number of vertices
in G prime is k times 3

00:38:06.710 --> 00:38:10.120
to n over k at most.

00:38:10.120 --> 00:38:13.590
So we just plug that
into this running time.

00:38:13.590 --> 00:38:21.590
And we get f of k times that
number of vertices, k times 3

00:38:21.590 --> 00:38:24.100
n over k at most.

00:38:24.100 --> 00:38:31.650
So less than or equal to
the power k over s of k.

00:38:31.650 --> 00:38:34.190
And now we do some manipulation.

00:38:34.190 --> 00:38:35.764
We know that f of
k is at most n.

00:38:35.764 --> 00:38:37.180
That will be enough
for this term.

00:38:37.180 --> 00:38:41.660
This is at most n times-- I'm
going to split this apart.

00:38:41.660 --> 00:38:46.010
So we have k to the
k over s of k power.

00:38:46.010 --> 00:38:50.850
And then separately, we
have 3 to the n over k

00:38:50.850 --> 00:38:55.190
to the k over s of k.

00:38:55.190 --> 00:38:57.490
Again, k to the k
over s of k, that's

00:38:57.490 --> 00:39:00.080
something I get to assume
is less than or equal to n.

00:39:00.080 --> 00:39:02.680
So this is less than
or equal to n squared.

00:39:02.680 --> 00:39:09.110
And then the k's cancel.

00:39:09.110 --> 00:39:16.440
And we're left with 3
to the n over s of k.

00:39:16.440 --> 00:39:18.350
I'm going to remind you
k is a function of n

00:39:18.350 --> 00:39:22.940
that is unbounded and
monotone increasing.

00:39:22.940 --> 00:39:29.163
So this is 3 to the little
o of n, also known as 2

00:39:29.163 --> 00:39:30.090
to the little o of n.

00:39:37.370 --> 00:39:40.220
So I just needed to choose k
to be slightly superconstant.

00:39:40.220 --> 00:39:43.380
And I wanted to get rid of these
terms, so I made them at most n

00:39:43.380 --> 00:39:45.560
and took those
inverses, took them in.

00:39:45.560 --> 00:39:47.950
And boom, we get
a contradiction.

00:39:47.950 --> 00:39:50.780
This contradicts ETH.

00:39:50.780 --> 00:39:55.450
This implies ETH is false.

00:39:55.450 --> 00:39:58.470
So if you assume ETH, running
backwards you get that k clique

00:39:58.470 --> 00:40:00.570
cannot be solved in
such a running time.

00:40:00.570 --> 00:40:02.950
And so we get this very
strong lower bound.

00:40:02.950 --> 00:40:04.900
There's no f of k
times n to the little o

00:40:04.900 --> 00:40:06.520
of k algorithm for k clique.

00:40:06.520 --> 00:40:10.172
So in particular, k clique is
not fixed parameter tractable.

00:40:10.172 --> 00:40:13.750
I think that's pretty neat.

00:40:13.750 --> 00:40:17.960
And henceforth, you care
about parameter blowup.

00:40:17.960 --> 00:40:21.120
I mentioned it
briefly last class.

00:40:21.120 --> 00:40:26.350
But in general, you map some
problem x with parameter k

00:40:26.350 --> 00:40:30.010
into a new instance x prime
with parameter k prime.

00:40:30.010 --> 00:40:33.030
And k prime just has to be
bounded by any function,

00:40:33.030 --> 00:40:37.070
any computable function of k.

00:40:37.070 --> 00:40:40.250
But if it's a linear function,
you preserve this strong bound.

00:40:40.250 --> 00:40:43.480
If it's quadratic function, then
you get there's no f of k times

00:40:43.480 --> 00:40:46.420
n to the little o
of square root of k.

00:40:46.420 --> 00:40:49.570
If it's an exponential function,
which is fair game here,

00:40:49.570 --> 00:40:51.380
you get a weaker bound.

00:40:51.380 --> 00:40:54.170
You still get that
there's no FPT algorithm.

00:40:54.170 --> 00:40:57.210
But you don't get a nice--
not a very impressive bound

00:40:57.210 --> 00:41:01.210
in terms of n on the right.

00:41:01.210 --> 00:41:05.170
AUDIENCE: Is there a name
for this type of reduction?

00:41:05.170 --> 00:41:06.680
PROFESSOR: I don't have one.

00:41:09.599 --> 00:41:11.140
There's only one
that I know of, so I

00:41:11.140 --> 00:41:15.010
don't think I will try
to come up with a name.

00:41:15.010 --> 00:41:18.540
Once you have this,
you can-- last

00:41:18.540 --> 00:41:22.490
class we reduced k clique
to all sorts of things.

00:41:22.490 --> 00:41:25.580
And so we get a
lot of-- for now,

00:41:25.580 --> 00:41:28.780
you just reduce from
clique or variations.

00:41:28.780 --> 00:41:31.130
And so you get
lots of good stuff.

00:41:34.690 --> 00:41:35.770
What do you get?

00:41:43.490 --> 00:41:46.620
Last time we covered a
reduction from clique

00:41:46.620 --> 00:41:53.000
to multicolored clique
and independent set.

00:41:53.000 --> 00:41:58.600
And if you look at that
proof, k prime equals k.

00:41:58.600 --> 00:42:01.850
We had a quadratic blowup
in the problem size,

00:42:01.850 --> 00:42:06.650
but the parameter
didn't change at all.

00:42:06.650 --> 00:42:07.610
So this is good news.

00:42:07.610 --> 00:42:12.070
That means this problem,
or these two problems,

00:42:12.070 --> 00:42:20.890
has no-- assuming ETH,
there's no f of k times

00:42:20.890 --> 00:42:26.310
n to the little
o of k algorithm.

00:42:26.310 --> 00:42:29.630
And also, we covered a
reduction to dominating set.

00:42:29.630 --> 00:42:34.542
Even though dominating
set was w2 hard,

00:42:34.542 --> 00:42:36.250
we still reduced from
multicolored clique

00:42:36.250 --> 00:42:37.380
to dominating set.

00:42:37.380 --> 00:42:40.640
And then from dominates set,
we could reduce to set cover.

00:42:40.640 --> 00:42:43.210
All of these reductions
preserve k exactly.

00:42:43.210 --> 00:42:45.622
All we need is that they
preserve it linearly.

00:42:45.622 --> 00:42:47.080
But then we get
this kind of result

00:42:47.080 --> 00:42:48.163
for all of those problems.

00:42:50.860 --> 00:42:55.100
We covered a reduction
for partial vertex cover.

00:42:58.050 --> 00:43:01.680
But I think the reduction
we covered was not linear.

00:43:01.680 --> 00:43:02.790
But there is one.

00:43:02.790 --> 00:43:04.350
So I'll just state
this as a result,

00:43:04.350 --> 00:43:06.990
but this is another one
where we covered a reduction,

00:43:06.990 --> 00:43:08.870
but it wasn't the
most efficient one.

00:43:08.870 --> 00:43:10.880
I think we lost a
quadratic amount.

00:43:18.967 --> 00:43:19.550
Any questions?

00:43:19.550 --> 00:43:20.050
Yeah?

00:43:20.050 --> 00:43:23.592
AUDIENCE: Do we happen
to know if FPT and w1 are

00:43:23.592 --> 00:43:25.702
separated assuming
only [INAUDIBLE]

00:43:25.702 --> 00:43:26.576
and not assuming ETH?

00:43:26.576 --> 00:43:27.867
PROFESSOR: We do not know that.

00:43:30.460 --> 00:43:33.750
The best classical
assumption is ETH

00:43:33.750 --> 00:43:35.570
implies w1 does not equal FPT.

00:43:39.350 --> 00:43:41.610
I also don't know offhand
whether FPT does not equal

00:43:41.610 --> 00:43:43.870
w1 implies p does not equal NP.

00:43:43.870 --> 00:43:46.170
I think there's this
result along those lines,

00:43:46.170 --> 00:43:47.930
but I'm not sure if
that's literally true.

00:43:47.930 --> 00:43:54.715
So intuitively it's stronger,
but-- other questions?

00:43:59.470 --> 00:44:02.315
AUDIENCE: So this is
strictly better lower bound

00:44:02.315 --> 00:44:03.752
than those over there?

00:44:06.620 --> 00:44:07.350
PROFESSOR: Right.

00:44:07.350 --> 00:44:08.380
Good question.

00:44:08.380 --> 00:44:11.440
So before we switched
to parametrized land,

00:44:11.440 --> 00:44:14.080
we said-- like over here,
we had there was no 2

00:44:14.080 --> 00:44:16.310
to the little of n algorithm.

00:44:16.310 --> 00:44:19.400
Here we're getting that
there's no f of k times

00:44:19.400 --> 00:44:22.140
n to the little of k algorithm.

00:44:22.140 --> 00:44:26.280
I think that is stronger
than the old bound.

00:44:26.280 --> 00:44:29.310
Though I guess you have to think
about it problem by problem.

00:44:29.310 --> 00:44:32.039
It depends on how k could
relate to n in general.

00:44:32.039 --> 00:44:33.580
I think for these
problems though, it

00:44:33.580 --> 00:44:35.085
is a stronger result.

00:44:42.460 --> 00:44:45.520
Because k is at most n.

00:44:45.520 --> 00:44:47.480
And k can be close to n.

00:44:56.550 --> 00:45:00.620
So the next topic-- just
taking a little breather.

00:45:00.620 --> 00:45:04.990
This is all good for
non-planar graphs.

00:45:04.990 --> 00:45:09.370
For planar graphs, we actually
haven't seen any w1 hardness

00:45:09.370 --> 00:45:10.470
results yet.

00:45:10.470 --> 00:45:14.290
And that's because a lot
of planar problems are FPT.

00:45:14.290 --> 00:45:16.530
There are, in fact, 2 to
the square root of k times

00:45:16.530 --> 00:45:19.470
polynomial in n algorithms for
a ton of planar graph problems.

00:45:19.470 --> 00:45:22.700
But there are some that are
hard, some that are w1 hard.

00:45:22.700 --> 00:45:26.970
And as you might expect, this
k becomes the square root of k

00:45:26.970 --> 00:45:30.390
because we get a quadratic
blowup, for some problems--

00:45:30.390 --> 00:45:32.010
not quite all of them.

00:45:32.010 --> 00:45:34.750
So this comes back
to Jason's question.

00:45:34.750 --> 00:45:36.470
And maybe I'll go up here.

00:45:41.210 --> 00:45:45.540
Let me briefly
mention in general

00:45:45.540 --> 00:45:51.510
if k prime of x prime is at
most some g of k of x, this

00:45:51.510 --> 00:45:54.760
was part of our--
in the definition

00:45:54.760 --> 00:46:02.160
of parametrized reduction,
then if there's no f of k n

00:46:02.160 --> 00:46:09.690
to the little of k
algorithm for problem A,

00:46:09.690 --> 00:46:16.100
then there is no f
prime of k prime times n

00:46:16.100 --> 00:46:26.330
to the little o of g inverse
of k prime algorithm for B.

00:46:26.330 --> 00:46:28.050
So I think the
analogous statement

00:46:28.050 --> 00:46:31.870
was up here for size blowup
and regular np reductions.

00:46:31.870 --> 00:46:35.160
But for parametrized reductions,
I mean, the dependence on k

00:46:35.160 --> 00:46:36.942
is just an arbitrary
computable function.

00:46:36.942 --> 00:46:37.900
So that doesn't change.

00:46:37.900 --> 00:46:39.830
But the exponent
changes correspondingly.

00:46:39.830 --> 00:46:43.430
So if you square k, we get the
square root in the exponent.

00:46:53.940 --> 00:46:56.790
So let's do some
planar problems.

00:47:00.140 --> 00:47:02.740
I'm pretty sure all
of the w1 hardness

00:47:02.740 --> 00:47:06.820
results for planar problems
are within the last five years.

00:47:06.820 --> 00:47:10.210
So it's a pretty
recent direction.

00:47:10.210 --> 00:47:19.240
And the key insight is a
problem called grid tiling,

00:47:19.240 --> 00:47:22.220
which I have a slide for.

00:47:22.220 --> 00:47:30.090
So this is a problem invented
by Daniel Marx in 2007.

00:47:30.090 --> 00:47:35.120
And so the input looks like this
and the output looks like that.

00:47:35.120 --> 00:47:40.790
So in general, you're given
a k by k matrix of sets.

00:47:40.790 --> 00:47:45.650
Each set has some number
of 2D coordinates.

00:47:45.650 --> 00:47:49.070
These coordinates
range between 1 and n.

00:47:49.070 --> 00:47:52.480
So it's k by k, small
matrix, but each cell

00:47:52.480 --> 00:47:57.360
has a ton of stuff in it,
up to n squared pairs.

00:47:59.970 --> 00:48:03.890
And your goal is
to-- in this example,

00:48:03.890 --> 00:48:05.390
all the numbers are
between 1 and 5.

00:48:05.390 --> 00:48:06.680
So n equals 5.

00:48:06.680 --> 00:48:09.820
And it's 3 by 3, so k equals 3.

00:48:09.820 --> 00:48:15.430
Your goal is to choose
exactly one element

00:48:15.430 --> 00:48:20.280
from these sets, such that
if you look in any column

00:48:20.280 --> 00:48:22.940
the first coordinates
are all the same.

00:48:22.940 --> 00:48:25.280
Here, the first
coordinate are all 1.

00:48:25.280 --> 00:48:27.340
Here, first
coordinates are all 2.

00:48:27.340 --> 00:48:29.920
And in any row, the second
coordinate is the same.

00:48:29.920 --> 00:48:31.193
Here they're all 4.

00:48:31.193 --> 00:48:32.980
Here they're all 2.

00:48:32.980 --> 00:48:34.730
Here they're all 3.

00:48:34.730 --> 00:48:36.790
So that's a valid solution.

00:48:36.790 --> 00:48:40.340
As you might expect,
this is np complete.

00:48:40.340 --> 00:48:42.995
But furthermore, it's w1 heart.

00:48:54.760 --> 00:48:59.110
I should say sij--
just gives you

00:48:59.110 --> 00:49:07.360
some notation-- is a subset
of 1 up to n squared for all i

00:49:07.360 --> 00:49:10.880
and j in 1 up to k.

00:49:10.880 --> 00:49:14.450
That's what the
input looks like.

00:49:14.450 --> 00:49:17.660
The squared means you
have ordered pairs.

00:49:17.660 --> 00:49:21.730
And then your goal is to
choose an xij out of each sij

00:49:21.730 --> 00:49:25.500
so that in any row, the first
coordinates match any column.

00:49:25.500 --> 00:49:26.000
Sorry.

00:49:26.000 --> 00:49:28.446
In any row, the second
coordinates match

00:49:28.446 --> 00:49:30.780
and in any column, the
first coordinates match.

00:49:33.860 --> 00:49:35.500
So claim is this is w1 hard.

00:49:35.500 --> 00:49:38.780
And also now, we know w1
hardness is not the most

00:49:38.780 --> 00:49:39.660
we could hope for.

00:49:39.660 --> 00:49:41.830
We also want to know what
the parameter blowup is

00:49:41.830 --> 00:49:44.680
and how we can relate
it back to ETH.

00:49:44.680 --> 00:49:48.840
So here we will
get the same bound.

00:49:48.840 --> 00:49:53.870
There's no f of k times n to
the little o of k algorithm,

00:49:53.870 --> 00:49:54.540
assuming ETH.

00:49:54.540 --> 00:49:56.940
So here we will not
lose a quadratic thing.

00:49:56.940 --> 00:49:59.360
But notice that this
thing is k by k.

00:49:59.360 --> 00:50:04.800
So, while we've defined
the parameter to be k,

00:50:04.800 --> 00:50:07.500
there's kind of a quadratic
amount of stuff going on.

00:50:07.500 --> 00:50:09.680
You're selecting k
squared different things

00:50:09.680 --> 00:50:10.944
in the solution.

00:50:10.944 --> 00:50:11.610
That's still OK.

00:50:11.610 --> 00:50:17.360
I mean, k is still the number of
rows or columns of the matrix.

00:50:17.360 --> 00:50:19.052
But typically, the
reason this problem

00:50:19.052 --> 00:50:21.510
is interesting-- this is, like,
a starting point for planar

00:50:21.510 --> 00:50:23.690
graph problems,
because you can replace

00:50:23.690 --> 00:50:27.130
each of these
cells of the matrix

00:50:27.130 --> 00:50:29.630
with the gadget that
somehow represents

00:50:29.630 --> 00:50:35.350
all the things in that set,
but that now these constraints

00:50:35.350 --> 00:50:36.790
that all the things
in the column

00:50:36.790 --> 00:50:38.470
agree in the first
coordinate, you can

00:50:38.470 --> 00:50:39.850
think of as a local constraint.

00:50:39.850 --> 00:50:42.270
Because really, you just need
that the guy you select here

00:50:42.270 --> 00:50:45.530
has the same first coordinate
as the guy you select here.

00:50:45.530 --> 00:50:47.414
You only need to
constrain adjacent cells.

00:50:47.414 --> 00:50:49.080
Because if his adjacent
cells are equal,

00:50:49.080 --> 00:50:50.860
then the whole
column will be equal.

00:50:50.860 --> 00:50:53.350
And if adjacent rows have
equal second coordinates,

00:50:53.350 --> 00:50:56.640
then the whole column will
have equal second coordinates.

00:50:56.640 --> 00:50:58.510
So as long as you
can build gadgets

00:50:58.510 --> 00:51:00.500
that just check with
their neighbors,

00:51:00.500 --> 00:51:03.900
that will give you a kind of
planar graph structure, or a 2D

00:51:03.900 --> 00:51:07.560
geometry structure if you're
doing a geometric problem

00:51:07.560 --> 00:51:11.650
and it lets you work with
things kind of locally.

00:51:11.650 --> 00:51:14.880
But when you do that, of course,
typically k becomes k squared.

00:51:14.880 --> 00:51:17.220
And that's where you get the
square root of k up here.

00:51:17.220 --> 00:51:18.490
But it won't disappear yet.

00:51:21.220 --> 00:51:23.330
So how do we prove this?

00:51:23.330 --> 00:51:28.390
We're going to reduce from
clique because that is

00:51:28.390 --> 00:51:31.405
our favorite w1 hard problem.

00:51:33.920 --> 00:51:35.434
And it has this kind of bound.

00:51:35.434 --> 00:51:37.225
And so it's going to
be a linear reduction.

00:51:37.225 --> 00:51:43.780
In fact, k prime will equal
k and n prime will equal n.

00:51:43.780 --> 00:51:49.200
n here is the maximum coordinate
values in the original problem.

00:51:49.200 --> 00:51:54.200
n prime is the number of
vertices in the clique.

00:51:54.200 --> 00:51:57.820
And I'm going to write
down the reduction

00:51:57.820 --> 00:52:01.480
and then show you a picture.

00:52:01.480 --> 00:52:03.470
It's hard to actually
draw the full reduction.

00:52:03.470 --> 00:52:09.790
It's easier to write it
down generically and then

00:52:09.790 --> 00:52:12.280
show you kind of a little
slice of a real example.

00:52:32.920 --> 00:52:35.550
It's a little bit
confusing, because there are

00:52:35.550 --> 00:52:38.090
four parameters lying around.

00:52:38.090 --> 00:52:42.310
There's which cell are you
in, which I'm denoting by ij.

00:52:42.310 --> 00:52:46.730
i is which row you're in. j
is which column you're in.

00:52:46.730 --> 00:52:50.130
So this is the set of
things at row i column j.

00:52:50.130 --> 00:52:53.950
But then separately,
there the coordinates

00:52:53.950 --> 00:52:55.790
that are inside the cell.

00:52:55.790 --> 00:52:59.640
And here I'm denoting
that by vertices, because

00:52:59.640 --> 00:53:05.680
for us, what this says is
that the vertices map 1 to 1

00:53:05.680 --> 00:53:11.132
with coordinate values.

00:53:11.132 --> 00:53:13.340
But these coordinate values
are different from the ij

00:53:13.340 --> 00:53:14.090
coordinate values.

00:53:14.090 --> 00:53:15.920
The ij's are always
between 1 and k.

00:53:15.920 --> 00:53:18.597
These coordinate values
are between 1 and m.

00:53:18.597 --> 00:53:20.930
Probably should have a term
for those, that distinction.

00:53:20.930 --> 00:53:24.290
But such as it is, ij
is between 1 and k. v

00:53:24.290 --> 00:53:26.140
and w are between 1 and n.

00:53:26.140 --> 00:53:28.149
So there's two types of cells.

00:53:28.149 --> 00:53:29.940
There's cells on the
diagonal of the matrix

00:53:29.940 --> 00:53:31.340
and cells off the diagonal.

00:53:31.340 --> 00:53:33.010
This is for i not equal to j.

00:53:33.010 --> 00:53:38.400
On the diagonal, you just
have pairs of the form vv.

00:53:38.400 --> 00:53:40.560
So that's supposed to
represent the vertex.

00:53:40.560 --> 00:53:43.140
And so basically what you
choose on the diagonal

00:53:43.140 --> 00:53:46.950
is going to correspond to
the clique that you want.

00:53:46.950 --> 00:53:51.891
Because the diagonal has size
k, and so each diagonal item

00:53:51.891 --> 00:53:53.390
is going to have
to choose a vertex.

00:53:53.390 --> 00:53:56.830
It's going to turn out that
vertex will be in a clique.

00:53:56.830 --> 00:53:58.360
Why will it be in a clique?

00:53:58.360 --> 00:54:00.130
Because the off
diagonal entries are

00:54:00.130 --> 00:54:01.780
going to force that
there are edges

00:54:01.780 --> 00:54:04.507
between corresponding vertices.

00:54:04.507 --> 00:54:06.090
So the off diagonal
entries will have,

00:54:06.090 --> 00:54:10.600
for every edge-- and we're
assuming no loops here--

00:54:10.600 --> 00:54:19.654
for every edge, we put vw
an item in the set of pairs.

00:54:19.654 --> 00:54:21.820
And if this is an undirected
graph, we'll put vwnwv.

00:54:25.910 --> 00:54:31.460
And so in fact, all of the off
diagonal entries look the same,

00:54:31.460 --> 00:54:32.590
I guess.

00:54:32.590 --> 00:54:34.820
And all of the diagonal
entries look the same

00:54:34.820 --> 00:54:37.120
in terms of the s sets.

00:54:37.120 --> 00:54:39.470
So let's look at an example.

00:54:39.470 --> 00:54:46.450
Suppose you choose this 2-2
diagonal entry to be vertex i.

00:54:46.450 --> 00:54:49.000
Didn't assume very much.

00:54:49.000 --> 00:54:51.560
But from the constraints
of the grid tiling problem,

00:54:51.560 --> 00:54:57.300
we know that the whole row here
has the same second coordinate.

00:54:57.300 --> 00:55:00.390
And the whole column here has
the same first coordinate.

00:55:00.390 --> 00:55:02.040
So if you choose
the vertex i here,

00:55:02.040 --> 00:55:06.850
that forces i to appear
throughout there.

00:55:06.850 --> 00:55:12.280
And if you look at some other
vertex, vj on the diagonal,

00:55:12.280 --> 00:55:13.520
then same thing happens.

00:55:13.520 --> 00:55:16.950
You have j second
coordinate here

00:55:16.950 --> 00:55:21.780
and j first coordinate there.

00:55:21.780 --> 00:55:24.100
I see there's a slight
typo on these slides.

00:55:24.100 --> 00:55:25.672
This should be a j.

00:55:25.672 --> 00:55:27.400
That should be an i.

00:55:27.400 --> 00:55:28.676
The colors are right, though.

00:55:28.676 --> 00:55:29.800
So just look at the colors.

00:55:35.490 --> 00:55:38.040
Now, for this to be
in the set, there

00:55:38.040 --> 00:55:41.200
must be an edge
between vi and vj.

00:55:41.200 --> 00:55:44.650
And this is true for all i and
j; therefore you have a clique.

00:55:44.650 --> 00:55:47.899
Now one thing that's important
is that vi is distinct from vj.

00:55:47.899 --> 00:55:50.440
Otherwise, you could just put
vi in all the diagonal entries,

00:55:50.440 --> 00:55:52.750
and everything is vi vi.

00:55:52.750 --> 00:55:56.730
But because we said
v does not equal w

00:55:56.730 --> 00:56:01.330
for these sets, the fact that
there is a valid choice here,

00:56:01.330 --> 00:56:05.600
the fact that vi vj is a
valid thing in this item

00:56:05.600 --> 00:56:10.870
means that vi does not equal vj.

00:56:10.870 --> 00:56:14.080
So these are all
distinct vertices.

00:56:14.080 --> 00:56:15.624
There's exactly k of them.

00:56:15.624 --> 00:56:17.540
And so this problem has
a solution if and only

00:56:17.540 --> 00:56:21.820
if there was a k clique
in the original graph.

00:56:21.820 --> 00:56:23.320
Clear?

00:56:23.320 --> 00:56:26.090
I guess these entries are
technically correct if you

00:56:26.090 --> 00:56:27.522
view these as unordered pairs.

00:56:27.522 --> 00:56:30.105
Because we're in an undirected
graph, everything is flippable.

00:56:34.990 --> 00:56:39.510
So that proves that grid
tiling is as hard as clique.

00:56:39.510 --> 00:56:41.830
And it was a linear reduction.

00:56:41.830 --> 00:56:43.630
We started with value k.

00:56:43.630 --> 00:56:47.684
We ended up with a thing
whose parameter was k.

00:56:47.684 --> 00:56:51.170
AUDIENCE: Say
something again like,

00:56:51.170 --> 00:56:54.180
it just seems like
you've just redefined

00:56:54.180 --> 00:56:59.235
your n and k to be square root
of what you might normally.

00:56:59.235 --> 00:57:01.300
PROFESSOR: Yeah,
so if you prefer,

00:57:01.300 --> 00:57:04.540
you could define k to be the
number of cells in the matrix.

00:57:04.540 --> 00:57:06.930
And then what you would get
here is there's no f of k n

00:57:06.930 --> 00:57:13.270
to the little o of square root
of k algorithm, assuming ETH.

00:57:13.270 --> 00:57:16.290
It's just a matter of
what you define k to be.

00:57:16.290 --> 00:57:19.600
You're going to either lose
a square here or later.

00:57:19.600 --> 00:57:24.375
And I think-- so I'll
show you why in a moment,

00:57:24.375 --> 00:57:25.750
why you might
define it this way.

00:57:25.750 --> 00:57:29.560
Because here's going to be a
planar graph problem, kind of,

00:57:29.560 --> 00:57:33.970
that does not blow up k at all.

00:57:33.970 --> 00:57:35.580
Turns out, sometimes
you don't have

00:57:35.580 --> 00:57:39.760
to blow up-- this k turns
out to be the correct k.

00:57:39.760 --> 00:57:43.950
So let's do that example.

00:57:43.950 --> 00:57:46.789
It's called k outer
planar list coloring.

00:57:46.789 --> 00:57:48.330
There's two things
I need to define--

00:57:48.330 --> 00:57:49.810
list coloring and outer planar.

00:58:17.949 --> 00:58:19.240
Let's start with list coloring.

00:58:32.810 --> 00:58:36.970
So in list coloring, given a
graph and for every vertex,

00:58:36.970 --> 00:58:39.410
you're given a list
of valid colors.

00:58:47.320 --> 00:58:49.870
And your goal is
to color the graph.

00:58:49.870 --> 00:58:52.380
Again, no edge should
be monochromatic.

00:58:52.380 --> 00:58:54.380
And the color you
choose for vertex v

00:58:54.380 --> 00:58:56.500
must be on the list Lv.

00:58:59.220 --> 00:59:01.860
So this is a generalization
of k coloring.

00:59:01.860 --> 00:59:03.980
k coloring is the
case where Lv equals 1

00:59:03.980 --> 00:59:06.430
through k for all vertices.

00:59:06.430 --> 00:59:08.570
This is, of course,
a harder problem.

00:59:08.570 --> 00:59:14.870
And turns out, it's quite hard.

00:59:14.870 --> 00:59:19.170
For example, it's NP
hard for planar graphs.

00:59:19.170 --> 00:59:21.870
That's not surprising,
because 3-coloring is NP

00:59:21.870 --> 00:59:22.850
hard for planar graphs.

00:59:26.630 --> 00:59:29.140
And size of Lv is less
than or equal to 3

00:59:29.140 --> 00:59:32.600
for all v. The hardness
of planar 3-coloring

00:59:32.600 --> 00:59:35.380
gives you that.

00:59:35.380 --> 00:59:38.310
So there's also no
natural parameter here,

00:59:38.310 --> 00:59:40.980
because you can't parametrize
by number of colors you have,

00:59:40.980 --> 00:59:43.720
because even when it's
three, this problem is hard.

00:59:43.720 --> 00:59:48.570
So we're going to parametrize
by something else, namely

00:59:48.570 --> 00:59:51.780
a quantity called
outer planarity.

00:59:54.430 --> 01:00:00.810
If you know what tree width
is, you can think tree width.

01:00:00.810 --> 01:00:03.830
But tree width is a
bit messy to define,

01:00:03.830 --> 01:00:05.750
so I'll stick to
outer planarity, which

01:00:05.750 --> 01:00:08.280
for planar graphs is
within a constant factor.

01:00:08.280 --> 01:00:18.210
So outer planarity-- if
you have a planar graph,

01:00:18.210 --> 01:00:21.680
this would be an example of
a graph of outer planarity 2.

01:00:21.680 --> 01:00:24.316
Let me draw you an example of
a graph of outer planarity 1.

01:00:27.630 --> 01:00:31.950
Suppose all of the vertices
are on the outside face

01:00:31.950 --> 01:00:37.500
of your planar graph, or all
the vertices are on one face.

01:00:37.500 --> 01:00:41.070
Then that's an outer planar
graph, or 1 outer planar graph.

01:00:41.070 --> 01:00:44.410
If you have a graph
where there are

01:00:44.410 --> 01:00:47.190
vertices on the outside
face, and if you remove

01:00:47.190 --> 01:00:49.300
all of those vertices
from the outside face,

01:00:49.300 --> 01:00:52.020
the remaining vertices are
all on the outside face,

01:00:52.020 --> 01:00:53.260
this is 2 outer planar.

01:00:59.140 --> 01:01:02.780
In general, if you have
to remove the vertices

01:01:02.780 --> 01:01:05.140
on the outside face
k times before you're

01:01:05.140 --> 01:01:08.660
left with no vertices, then
your graph is k outer planar.

01:01:08.660 --> 01:01:12.100
And that k is your
outer planarity.

01:01:12.100 --> 01:01:15.787
So this is an example of a
problem that's-- there's no

01:01:15.787 --> 01:01:18.120
natural parametrization because
it's not an optimization

01:01:18.120 --> 01:01:18.620
problem.

01:01:18.620 --> 01:01:20.666
So we're going to throw
in a parametrization that

01:01:20.666 --> 01:01:21.790
often works out quite well.

01:01:21.790 --> 01:01:23.706
Usually if you take
planar graphs parametrized

01:01:23.706 --> 01:01:26.770
by outer planarity, they are
fixed parameter retractable.

01:01:26.770 --> 01:01:30.720
For example, k
coloring, parametrized

01:01:30.720 --> 01:01:34.070
by outer planarity, is FPT.

01:01:34.070 --> 01:01:35.791
But list coloring is not.

01:01:35.791 --> 01:01:36.290
Question?

01:01:36.290 --> 01:01:38.610
AUDIENCE: Doesn't
the outer planarity

01:01:38.610 --> 01:01:40.002
depend on the embedding?

01:01:40.002 --> 01:01:44.980
PROFESSOR: It depends only
slightly on the embedding.

01:01:44.980 --> 01:01:48.580
I think only by an
additive of 1 or something.

01:01:48.580 --> 01:01:51.270
So it won't matter from a
parametrization perspective.

01:01:51.270 --> 01:01:53.417
Definitely within
a constant factor.

01:01:53.417 --> 01:01:54.000
Good question.

01:01:56.910 --> 01:01:59.460
So what we're going to
show is that this problem

01:01:59.460 --> 01:02:02.320
parametrized by
outer planarity--

01:02:02.320 --> 01:02:05.710
so one note is it is in XP.

01:02:05.710 --> 01:02:10.160
There is an n to
the outer planarity

01:02:10.160 --> 01:02:14.940
and to the k algorithm using the
bounded tree width algorithms,

01:02:14.940 --> 01:02:16.270
which I won't go into.

01:02:16.270 --> 01:02:23.090
But we will show that is
w1 hard, and assuming ETH,

01:02:23.090 --> 01:02:28.690
there's no f of k n to
the little of k algorithm.

01:02:28.690 --> 01:02:30.800
So here's an example of
a planar graph problem

01:02:30.800 --> 01:02:33.532
where we do not get square root
of k, which I think would also

01:02:33.532 --> 01:02:34.740
answer your earlier question.

01:02:37.450 --> 01:02:38.575
And this is the reduction.

01:02:38.575 --> 01:02:41.690
It's a reduction
from grid tiling.

01:02:41.690 --> 01:02:44.040
So the idea is if you
have a k by k grid,

01:02:44.040 --> 01:02:48.230
we're going to make something
like a k by k grid graph.

01:02:48.230 --> 01:02:53.580
Now we have to represent
the choice here.

01:02:53.580 --> 01:02:57.620
We're given a set of pairs
for each of these grid

01:02:57.620 --> 01:03:01.280
cells, which we're now
representing as a vertex.

01:03:01.280 --> 01:03:03.790
But conveniently, we have
a choice aspect here.

01:03:03.790 --> 01:03:08.960
So this is not-- this a thin
[? veal ?] for grid tiling.

01:03:08.960 --> 01:03:11.790
We have this list, Lv, for
each vertex of valid choices

01:03:11.790 --> 01:03:13.510
you could make for that vertex.

01:03:13.510 --> 01:03:19.430
So we're going to
let L uij-- so this

01:03:19.430 --> 01:03:25.285
is reduction from grid tiling.

01:03:30.600 --> 01:03:36.910
L sub uij equals sij.

01:03:36.910 --> 01:03:39.120
So that's the
choice that happens.

01:03:39.120 --> 01:03:42.260
For every vertex, we
have to choose one color.

01:03:42.260 --> 01:03:46.700
That mimics the fact that
every grid cell in the matrix,

01:03:46.700 --> 01:03:49.410
we have to choose
one item from sij.

01:03:49.410 --> 01:03:51.640
So most of our work
is already done.

01:03:51.640 --> 01:03:53.720
Now we have to constrain.

01:03:53.720 --> 01:03:56.860
If you look at two
adjacent vertices,

01:03:56.860 --> 01:03:58.820
if they're adjacent
in a row, then they

01:03:58.820 --> 01:04:02.480
must have the same
first coordinate--

01:04:02.480 --> 01:04:05.439
I can never remember.

01:04:05.439 --> 01:04:07.563
They should have the same
second coordinate, sorry,

01:04:07.563 --> 01:04:09.270
if they're in the same row.

01:04:09.270 --> 01:04:10.710
And if they're in
the same column,

01:04:10.710 --> 01:04:13.290
they should have the
same first coordinate.

01:04:13.290 --> 01:04:16.300
So these vertices,
which are called

01:04:16.300 --> 01:04:18.500
v for the vertical
connections and h

01:04:18.500 --> 01:04:23.600
for the horizontal connections,
are going to achieve that.

01:04:23.600 --> 01:04:26.390
And it's a little bit
tedious to write down.

01:04:30.180 --> 01:04:45.690
Basically, let's say
between uij and ui plus 1j,

01:04:45.690 --> 01:04:49.750
so those two vertically
adjacent vertices,

01:04:49.750 --> 01:05:01.310
we're going to add a vertex
vijcd for two colors c and d,

01:05:01.310 --> 01:05:23.910
with list of size 2 c,d for all
colors not agreeing on first

01:05:23.910 --> 01:05:24.410
coordinate.

01:05:31.710 --> 01:05:33.510
Again, this is hard
to draw in the figure,

01:05:33.510 --> 01:05:35.950
but easier to write down.

01:05:35.950 --> 01:05:42.610
So there's a lot of these
vertices in between two

01:05:42.610 --> 01:05:45.240
adjacent ui vertices.

01:05:45.240 --> 01:05:47.240
There's going to be a bunch.

01:05:47.240 --> 01:05:49.230
They're parametrized
by two colors,cd.

01:05:49.230 --> 01:05:51.770
Remember, colors
are pairs of things,

01:05:51.770 --> 01:05:55.550
but colors correspond to the
items that are in the sijs.

01:05:55.550 --> 01:05:58.950
But don't worry about
that so much here,

01:05:58.950 --> 01:06:01.850
except there are colors that
are compatible, that they

01:06:01.850 --> 01:06:03.209
have the same first coordinate.

01:06:03.209 --> 01:06:05.000
And there are colors
that are incompatible.

01:06:05.000 --> 01:06:07.800
For any two incompatible
colors, which is most of them,

01:06:07.800 --> 01:06:10.350
the ones that don't agree
on the first coordinate,

01:06:10.350 --> 01:06:13.240
we are going to add one of these
vertices whose list is exactly

01:06:13.240 --> 01:06:15.690
cd, the two incompatible colors.

01:06:15.690 --> 01:06:20.560
What that means is, suppose
this vertex chooses c.

01:06:20.560 --> 01:06:24.886
Well, then there's a
vertex here with list cd.

01:06:24.886 --> 01:06:27.010
It cannot choose c, because
then that edge would be

01:06:27.010 --> 01:06:27.720
monochromatic.

01:06:27.720 --> 01:06:32.240
So it must choose d, which means
this vertex cannot choose d.

01:06:32.240 --> 01:06:35.540
So overall, what this means
is that these two vertices

01:06:35.540 --> 01:06:38.650
must choose a compatible
color, because we rule out

01:06:38.650 --> 01:06:40.040
all the incompatible pairs.

01:06:40.040 --> 01:06:42.157
So list coloring
you can do a lot,

01:06:42.157 --> 01:06:43.740
but in particular
we can simulate grid

01:06:43.740 --> 01:06:46.262
coloring-- sorry, grid tiling.

01:06:46.262 --> 01:06:48.720
We're not exploiting a ton of
the structure of grid tiling,

01:06:48.720 --> 01:06:51.846
but we get a nice result
here and it's tight.

01:06:51.846 --> 01:06:53.970
I didn't write down what
you do for the horizontal,

01:06:53.970 --> 01:06:56.700
but it's symmetric.

01:06:56.700 --> 01:06:59.342
So that's nice.

01:06:59.342 --> 01:07:01.175
This is one of the few
planar problems where

01:07:01.175 --> 01:07:02.341
you don't get a square root.

01:07:05.520 --> 01:07:07.450
The next two, you will
get a square root.

01:07:07.450 --> 01:07:10.790
But before I get to
the actual problem,

01:07:10.790 --> 01:07:12.730
here's a variation
of grid tiling, which

01:07:12.730 --> 01:07:14.750
is a little tricky
to prove hard,

01:07:14.750 --> 01:07:17.830
but is just as hard
as grid tiling.

01:07:17.830 --> 01:07:21.990
Here we need that in every
row-- here's the input,

01:07:21.990 --> 01:07:23.000
here's the output.

01:07:23.000 --> 01:07:24.760
Easier to look at the output.

01:07:24.760 --> 01:07:28.100
In any row-- sorry,
that's a column.

01:07:28.100 --> 01:07:30.130
In any column, the
first coordinate

01:07:30.130 --> 01:07:31.720
is monotonically increasing.

01:07:31.720 --> 01:07:33.350
Doesn't have to
strictly increase,

01:07:33.350 --> 01:07:34.800
but you have a less than
or equal to constraint.

01:07:34.800 --> 01:07:36.220
This is less than
or equal to this.

01:07:36.220 --> 01:07:37.678
This is less than
or equal to this.

01:07:37.678 --> 01:07:38.562
4,4,4.

01:07:38.562 --> 01:07:39.770
Here they happen to be equal.

01:07:39.770 --> 01:07:40.570
2,3,3.

01:07:40.570 --> 01:07:43.940
Here they increase a little
bit, similarly in every row.

01:07:43.940 --> 01:07:46.690
2,3,5-- they're
monotonically increasing.

01:07:46.690 --> 01:07:49.780
1,2,2, 2,2,3.

01:07:49.780 --> 01:07:53.100
So this is a valid solution
to grid tiling with less than

01:07:53.100 --> 01:07:53.942
or equal to.

01:07:53.942 --> 01:07:54.900
That's how it's called.

01:07:57.420 --> 01:08:00.850
I will not prove
that this is w1 hard.

01:08:00.850 --> 01:08:05.320
I do have a figure for it.

01:08:05.320 --> 01:08:07.900
It turns out to be
a linear expansion.

01:08:07.900 --> 01:08:10.670
If you have a k by k grid,
we're going to end up with a 4k

01:08:10.670 --> 01:08:11.690
by 4k grid.

01:08:11.690 --> 01:08:13.010
That part is important.

01:08:13.010 --> 01:08:16.680
So we get the same kind of
hardness result, no f of k

01:08:16.680 --> 01:08:21.020
and a little o of k, because we
only expand k by a factor of 4.

01:08:21.020 --> 01:08:24.580
And this is a description
of what the sets are.

01:08:24.580 --> 01:08:26.520
It's kind of messy,
but it effectively

01:08:26.520 --> 01:08:29.126
forces that the
choice on the left

01:08:29.126 --> 01:08:31.000
is actually equal to
the choice on the right,

01:08:31.000 --> 01:08:34.240
even though it only has the
ability to specify less than

01:08:34.240 --> 01:08:35.560
or equal to.

01:08:35.560 --> 01:08:39.229
But you-- equal is something
like modulo capital n, where

01:08:39.229 --> 01:08:42.410
n is some really large number,
like 10 times little n--

01:08:42.410 --> 01:08:44.430
something like that.

01:08:44.430 --> 01:08:47.899
The details are kind of messy,
so I will instead-- I mean,

01:08:47.899 --> 01:08:49.279
we could just take
this as given.

01:08:49.279 --> 01:08:51.970
This is, like, a core
problem to start with.

01:08:51.970 --> 01:08:55.229
And you can use it to represent
lots of nice planar graph

01:08:55.229 --> 01:08:57.090
problems and 2D problems.

01:08:57.090 --> 01:09:00.250
So I have one example of each.

01:09:00.250 --> 01:09:03.569
These are all from this
upcoming book on fixed parameter

01:09:03.569 --> 01:09:04.660
tractability.

01:09:04.660 --> 01:09:08.160
So you saw it here first.

01:09:08.160 --> 01:09:11.479
This book will come
out early next year.

01:09:11.479 --> 01:09:13.120
So here's a problem.

01:09:13.120 --> 01:09:15.120
It's called scattered set.

01:09:15.120 --> 01:09:21.180
This is a generalization, in
some sense, of independent set.

01:09:21.180 --> 01:09:22.670
So let me define it over here.

01:09:39.720 --> 01:09:43.407
I would also naturally
call it d independent set.

01:09:43.407 --> 01:09:45.365
It might even be called
that in the literature.

01:09:49.781 --> 01:09:51.489
So in this problem,
you're given a graph.

01:09:55.280 --> 01:10:00.130
And you're given two numbers,
two natural numbers, k and d.

01:10:03.620 --> 01:10:18.790
And you want to find k vertices
with pairwise distances

01:10:18.790 --> 01:10:21.270
greater than or equal to k.

01:10:21.270 --> 01:10:24.420
Sorry, greater
than or equal to d.

01:10:24.420 --> 01:10:28.510
So if d equals 2, this
is independent set.

01:10:28.510 --> 01:10:30.516
Independent set
says the distance

01:10:30.516 --> 01:10:32.890
between any pair of chosen
vertices should be at least 2.

01:10:32.890 --> 01:10:35.370
There's no adjacent
ones of distance 1.

01:10:35.370 --> 01:10:37.170
d equals 1 is not interesting.

01:10:37.170 --> 01:10:41.440
d equals 2 is when this
problem becomes hard.

01:10:41.440 --> 01:10:46.590
Now interestingly, there are
FPT algorithms with respect

01:10:46.590 --> 01:10:50.220
to k and d.

01:10:50.220 --> 01:10:53.840
So if k and d are small,
this problem is easy.

01:10:53.840 --> 01:10:57.086
And for planar graphs, there's
a subexponential FPT algorithm

01:10:57.086 --> 01:10:57.585
as well.

01:11:00.410 --> 01:11:03.990
But when d is unbounded,
if it's not a parameter,

01:11:03.990 --> 01:11:11.110
only k is, then this problem
is hard even for planar graphs.

01:11:11.110 --> 01:11:20.270
So planar is w1
hard with respect

01:11:20.270 --> 01:11:24.470
to k, only when d can be
part of the input arbitrarily

01:11:24.470 --> 01:11:26.590
large function of n.

01:11:26.590 --> 01:11:40.990
And also ETH implies there's
no planar algorithm with time

01:11:40.990 --> 01:11:50.730
2-- sorry, f of k n to the
little o of square root of k.

01:11:54.980 --> 01:11:56.860
And in fact, for
scattered set, there

01:11:56.860 --> 01:12:00.534
is an n to the big O of
square root of k algorithm.

01:12:00.534 --> 01:12:01.950
I don't think it's
been published,

01:12:01.950 --> 01:12:04.990
but it's mentioned in the book.

01:12:04.990 --> 01:12:07.670
And there is-- this is tight.

01:12:07.670 --> 01:12:10.666
This says there is no n to the
little o of square root of k

01:12:10.666 --> 01:12:13.290
algorithm, even when you get an
arbitrary computable function f

01:12:13.290 --> 01:12:15.150
of k in front.

01:12:15.150 --> 01:12:16.660
So this is nice.

01:12:16.660 --> 01:12:19.600
We're planar, so we
lose the square aspect,

01:12:19.600 --> 01:12:25.420
but it's actually a pretty
easy reduction from grid tiling

01:12:25.420 --> 01:12:27.380
with less than or equal to.

01:12:27.380 --> 01:12:33.470
So you can see the grid here,
k equals 3 in this example.

01:12:33.470 --> 01:12:38.290
And here, n equals 5, just like
our earlier example in fact.

01:12:38.290 --> 01:12:41.610
All the information is here, as
represented by these little red

01:12:41.610 --> 01:12:42.550
sticks.

01:12:42.550 --> 01:12:44.880
So we have a 3 by 3 matrix.

01:12:44.880 --> 01:12:47.944
In each matrix cell,
we have a set of items.

01:12:47.944 --> 01:12:49.360
In this case, there
are two items.

01:12:49.360 --> 01:12:50.850
In this case there
are three items.

01:12:50.850 --> 01:12:54.490
The items are encoded by
where the red sticks are

01:12:54.490 --> 01:12:56.700
in this subgrid.

01:12:56.700 --> 01:13:01.400
This is an n by n subgrid
within a k by k matrix.

01:13:01.400 --> 01:13:06.140
So for every present
pair in this set sij,

01:13:06.140 --> 01:13:07.290
we just add a stick.

01:13:07.290 --> 01:13:10.890
Now, the stick is
a really long path.

01:13:10.890 --> 01:13:14.944
It's 100 times n.

01:13:14.944 --> 01:13:16.610
So we have this n by
n grid, and then we

01:13:16.610 --> 01:13:17.910
have these hundred n paths.

01:13:17.910 --> 01:13:19.730
Now this is still planar.

01:13:19.730 --> 01:13:23.200
You can put that path in there.

01:13:23.200 --> 01:13:27.390
And also, this red path is
100, and these are length 1.

01:13:27.390 --> 01:13:29.690
Black edges are length 1.

01:13:29.690 --> 01:13:33.320
So what's shown here is actually
satisfying assignment where

01:13:33.320 --> 01:13:36.396
I choose one of these vertices.

01:13:36.396 --> 01:13:38.020
In scattered set,
our goal is to choose

01:13:38.020 --> 01:13:40.030
vertices that are very
far away from each other.

01:13:40.030 --> 01:13:42.130
How far?

01:13:42.130 --> 01:13:49.800
How far is 301 times n plus 1.

01:13:49.800 --> 01:13:57.060
Roughly, three red
sticks plus one traversal

01:13:57.060 --> 01:14:01.110
of a subgrid plus 1.

01:14:01.110 --> 01:14:02.390
Roughly three red sticks.

01:14:02.390 --> 01:14:09.380
So if I choose this vertex and
I want to choose one in here,

01:14:09.380 --> 01:14:11.390
it's got to be at least
three red sticks away.

01:14:11.390 --> 01:14:14.520
So I'm going to get one red
stick here, one red stick here,

01:14:14.520 --> 01:14:17.290
and one red stick there.

01:14:17.290 --> 01:14:19.230
So that's good.

01:14:19.230 --> 01:14:21.100
But that just says
I choose exactly

01:14:21.100 --> 01:14:22.490
one out of each of these things.

01:14:22.490 --> 01:14:24.421
Once I choose one
of these endpoints,

01:14:24.421 --> 01:14:25.920
I certainly can't
choose another one

01:14:25.920 --> 01:14:28.050
because it's only
two red sticks away.

01:14:28.050 --> 01:14:30.410
I can only choose
one per subgrid.

01:14:30.410 --> 01:14:34.120
But then also, I want the
lesser and equal to constraint.

01:14:34.120 --> 01:14:37.820
And that's the plus n over here.

01:14:37.820 --> 01:14:41.244
So I have three
red sticks plus n.

01:14:41.244 --> 01:14:44.040
That's the 1.

01:14:44.040 --> 01:14:48.500
Because I have plus n, n is the
width, let's say, these guys.

01:14:48.500 --> 01:14:51.050
So once I choose
this guy, I have

01:14:51.050 --> 01:14:53.800
to be three red sticks--
1, 2, 3 red sticks away.

01:14:53.800 --> 01:14:56.520
But I also need to be
an additional n away.

01:14:56.520 --> 01:15:05.310
And here, I am that because
I have 1, 2, 3, 4, 5, 6 away.

01:15:05.310 --> 01:15:09.540
I'm actually one
more than n away.

01:15:09.540 --> 01:15:11.620
And there's a plus 1 over
there, so that's good.

01:15:11.620 --> 01:15:13.150
I'm 6 away.

01:15:13.150 --> 01:15:15.074
I need to be 6 away.

01:15:15.074 --> 01:15:16.490
And that corresponds
to this being

01:15:16.490 --> 01:15:19.350
in the fourth column and this
being in the fourth column.

01:15:19.350 --> 01:15:25.960
In other words, it corresponds
to the second coordinate

01:15:25.960 --> 01:15:29.290
of this guy being less than or
equal to the second coordinate

01:15:29.290 --> 01:15:30.950
of this guy.

01:15:30.950 --> 01:15:33.180
So it's exactly the grid
tiling with less than

01:15:33.180 --> 01:15:36.460
or equal to constraint
horizontally and symmetrically,

01:15:36.460 --> 01:15:37.060
vertically.

01:15:37.060 --> 01:15:39.540
Because the distance between
a point here to point

01:15:39.540 --> 01:15:42.940
here is going to be go straight
down, jump, use the red stick,

01:15:42.940 --> 01:15:46.140
and then go teleport
left right and then

01:15:46.140 --> 01:15:49.570
go straight down from there.

01:15:49.570 --> 01:15:51.920
So that distance
corresponds to exactly when

01:15:51.920 --> 01:15:54.640
all the less than or equal
to constraints are satisfied.

01:15:54.640 --> 01:15:56.690
If and only if, so this
a reduction from grid

01:15:56.690 --> 01:15:59.000
tiling with less than or
equal to to scattered set.

01:15:59.000 --> 01:15:59.980
[INAUDIBLE] is w1 hard.

01:15:59.980 --> 01:16:03.460
Now here, notice k
prime is k squared,

01:16:03.460 --> 01:16:09.430
because we are choosing
one vertex per matrix cell.

01:16:09.430 --> 01:16:10.730
And they're k squared cells.

01:16:10.730 --> 01:16:14.510
So here we are losing
the quadratic blowup.

01:16:17.175 --> 01:16:17.675
Questions?

01:16:20.410 --> 01:16:23.847
One more similar example.

01:16:23.847 --> 01:16:25.430
There aren't a ton
of hardness results

01:16:25.430 --> 01:16:27.142
here, so not a lot
to choose from.

01:16:27.142 --> 01:16:29.350
There are some multi-way
[? Kant and ?] other things.

01:16:29.350 --> 01:16:31.240
But among simple
examples, here's

01:16:31.240 --> 01:16:34.520
another simple example--
very similar looking.

01:16:34.520 --> 01:16:38.440
This is a graph in 2D
plane, so to speak.

01:16:38.440 --> 01:16:41.960
You can also think of it as
a unit disk graph problem.

01:16:41.960 --> 01:16:51.150
So a unit disk graph is I take
some points in the plane, 2D

01:16:51.150 --> 01:16:55.179
coordinates, let's say
given by rational values.

01:16:55.179 --> 01:16:56.970
x and y-coordinates
are given by rationals.

01:16:56.970 --> 01:16:59.310
And if I look at
any two vertices,

01:16:59.310 --> 01:17:03.660
if they live-- if the
distance between them

01:17:03.660 --> 01:17:06.160
is less than or equal to
1, then I add an edge.

01:17:06.160 --> 01:17:10.844
So here, I might
have a graph-- this

01:17:10.844 --> 01:17:13.160
is going to be a lot of
edges with that notion of 1.

01:17:17.820 --> 01:17:19.844
You can have big cliques
in a unit disk graph,

01:17:19.844 --> 01:17:21.010
but it's kind of planar-ish.

01:17:23.394 --> 01:17:25.060
Especially if you
have distant vertices,

01:17:25.060 --> 01:17:26.410
they're not going
to be connected.

01:17:26.410 --> 01:17:28.993
So you have these local cliques,
but they're kind of connected

01:17:28.993 --> 01:17:31.430
in a planar-like way.

01:17:31.430 --> 01:17:32.200
Definition clear?

01:17:32.200 --> 01:17:34.680
Edge if and only if
distance at most 1.

01:17:34.680 --> 01:17:39.570
So what about independent
set in unit disk graphs?

01:17:39.570 --> 01:17:41.550
We know independent
set in general's hard.

01:17:41.550 --> 01:17:43.900
Independent set in unit disk
graphs is almost as hard.

01:17:43.900 --> 01:17:48.290
Again, there's a quadratic
loss in the parameter.

01:17:48.290 --> 01:17:51.100
But problem is, w1 hard
and has the same kind

01:17:51.100 --> 01:17:53.460
of hardness as scattered set.

01:17:53.460 --> 01:17:55.510
By similar kind of
structure, here I'm

01:17:55.510 --> 01:17:57.220
actually giving
you the grid tiling

01:17:57.220 --> 01:17:59.374
with less than or equal to.

01:17:59.374 --> 01:18:01.290
Probably also corresponds
to the last example,

01:18:01.290 --> 01:18:04.660
but here it is in the
independent set unit disk

01:18:04.660 --> 01:18:05.160
problem.

01:18:05.160 --> 01:18:07.640
Independent set in a unit
disk is the same thing

01:18:07.640 --> 01:18:11.030
as choosing some
vertices, like this one,

01:18:11.030 --> 01:18:14.310
as the center of
a radius one half

01:18:14.310 --> 01:18:16.750
disk and then those
radius one half disks

01:18:16.750 --> 01:18:18.500
should not intersect each other.

01:18:18.500 --> 01:18:21.340
Because these two things
will have distance at least 1

01:18:21.340 --> 01:18:23.600
if and only if radius one
half disk and a radius

01:18:23.600 --> 01:18:26.290
one half disk here
do not intersect.

01:18:26.290 --> 01:18:28.110
So it's really about
choosing centers

01:18:28.110 --> 01:18:30.490
for these disks that don't hit.

01:18:30.490 --> 01:18:31.990
And so again, what
we're going to do

01:18:31.990 --> 01:18:38.760
is imagine an n by n subgrid
within each cell of the matrix.

01:18:38.760 --> 01:18:42.620
But not all of those points
are actually in the set,

01:18:42.620 --> 01:18:44.910
only the ones that
are in-- in this case,

01:18:44.910 --> 01:18:49.390
s1,1 these pairs of guys
as written here, so 1,

01:18:49.390 --> 01:18:50.600
1 is in there.

01:18:50.600 --> 01:18:52.250
I guess that's that guy.

01:18:52.250 --> 01:18:54.140
2,5 is this guy.

01:18:54.140 --> 01:18:55.190
3,3 is that guy.

01:18:55.190 --> 01:18:58.090
Those points we'll actually
put in the problem.

01:18:58.090 --> 01:19:02.350
These tiny dots are
just place markers.

01:19:02.350 --> 01:19:04.010
There's no actual point there.

01:19:04.010 --> 01:19:07.670
Then we construct the unit
disk graph on the structure.

01:19:07.670 --> 01:19:10.110
And again, if we
set the unit right,

01:19:10.110 --> 01:19:15.300
and these are super tiny,
in the same way that we

01:19:15.300 --> 01:19:16.800
had the red edges,
which were, like,

01:19:16.800 --> 01:19:21.080
100 times longer than the
small things over here,

01:19:21.080 --> 01:19:26.050
we're going to have, let's say
this thing is 100 times smaller

01:19:26.050 --> 01:19:31.970
than that distance, enough
so that these circles act

01:19:31.970 --> 01:19:32.845
kind of like squares.

01:19:36.040 --> 01:19:39.350
If you look very close to
here, this looks straight.

01:19:39.350 --> 01:19:43.180
So these are very
compressed, so it's probably

01:19:43.180 --> 01:19:47.100
going to be more like
a factor of n smaller.

01:19:47.100 --> 01:19:48.910
These effectively
act like squares.

01:19:48.910 --> 01:19:51.250
It's just a matter of
whether the horizontal extent

01:19:51.250 --> 01:19:54.640
of this disk hits the
horizontal extent of this disk.

01:19:54.640 --> 01:19:56.960
And that is a less than
or equal to constraint.

01:19:56.960 --> 01:20:01.020
Once you choose something
in column 2 here,

01:20:01.020 --> 01:20:03.640
the next one has to
be column at least 2.

01:20:03.640 --> 01:20:06.230
Here, there there's a gap
because we chose column 3.

01:20:06.230 --> 01:20:08.320
Here, there's a gap
because we chose column 5.

01:20:08.320 --> 01:20:10.970
But for example here, we
chose column 2, column 2

01:20:10.970 --> 01:20:13.680
and these guys are
almost touching.

01:20:13.680 --> 01:20:14.690
But barely not touching.

01:20:14.690 --> 01:20:16.731
And as long as you have
the less than or equal to

01:20:16.731 --> 01:20:21.054
constraint on the columns,
then you'll be OK.

01:20:21.054 --> 01:20:23.220
The disk won't intersect
and it's an if and only if.

01:20:23.220 --> 01:20:24.930
So again, we
represent grid tiling

01:20:24.930 --> 01:20:27.250
with less than or equal
to and independent

01:20:27.250 --> 01:20:30.830
set or disk packing
problem in the plane.

01:20:30.830 --> 01:20:32.500
It's kind of cool.

01:20:32.500 --> 01:20:33.000
Questions?

01:20:36.430 --> 01:20:36.930
All right.

01:20:36.930 --> 01:20:40.720
Well-- oh, more fun facts.

01:20:40.720 --> 01:20:54.590
So we have for independent
set in unit disk graphs,

01:20:54.590 --> 01:20:59.170
we have that there
is no f of k n

01:20:59.170 --> 01:21:03.730
to the little o of square
root of k algorithm.

01:21:03.730 --> 01:21:06.310
There actually is
an n to the big O

01:21:06.310 --> 01:21:08.715
of square root of k algorithm.

01:21:12.350 --> 01:21:15.394
We also get-- and I
won't go through this.

01:21:15.394 --> 01:21:16.810
I think it's pretty
trivial, based

01:21:16.810 --> 01:21:19.340
on what I said last class.

01:21:19.340 --> 01:21:21.310
But we get that
there's no efficient p

01:21:21.310 --> 01:21:26.470
test for this problem
unless-- sorry.

01:21:26.470 --> 01:21:29.420
This we definitely
get from last lecture.

01:21:29.420 --> 01:21:33.890
I said if you're w1 hard
or FPT-- if you're w1 hard

01:21:33.890 --> 01:21:37.080
and FPT does not equal
w1, then you are not FPT.

01:21:37.080 --> 01:21:39.190
If you're not FPT, there's
no efficient p test,

01:21:39.190 --> 01:21:43.410
no f of 1 over epsilon
times n to some constant.

01:21:43.410 --> 01:21:46.980
In fact, if you assume ETH,
you get an even stronger form

01:21:46.980 --> 01:21:48.100
of that.

01:21:48.100 --> 01:21:54.590
And in this example, we
get there is no 2 to the 1

01:21:54.590 --> 01:22:01.140
over epsilon to the 1
minus delta power times

01:22:01.140 --> 01:22:04.665
n to the order 1 1 plus
epsilon approximation.

01:22:08.150 --> 01:22:12.790
This is the original result
from the Daniel Marx paper

01:22:12.790 --> 01:22:16.080
that introduced-- this was
his motivation for introducing

01:22:16.080 --> 01:22:17.220
grid tiling.

01:22:17.220 --> 01:22:20.310
So again, you get-- out
of all these lower bounds,

01:22:20.310 --> 01:22:22.590
you also get results about
inapproximability, which

01:22:22.590 --> 01:22:24.442
is another reason to care.

01:22:24.442 --> 01:22:26.650
Even if you don't care about
parametrized complexity,

01:22:26.650 --> 01:22:29.570
these are the only ways known
to prove lower bounds on how

01:22:29.570 --> 01:22:31.746
slow your p test has to be.

01:22:31.746 --> 01:22:33.620
Because there are p
tests for these problems,

01:22:33.620 --> 01:22:37.580
but only so efficient.

01:22:37.580 --> 01:22:40.500
That's it for fixed
parameter tractability.

01:22:40.500 --> 01:22:43.180
Next class, we'll do something
completely different.