WEBVTT

00:00:00.040 --> 00:00:02.460
The following content is
provided under a Creative

00:00:02.460 --> 00:00:03.870
Commons license.

00:00:03.870 --> 00:00:06.910
Your support will help MIT
OpenCourseWare continue to

00:00:06.910 --> 00:00:10.560
offer high quality educational
resources for free.

00:00:10.560 --> 00:00:13.460
To make a donation or view
additional materials from

00:00:13.460 --> 00:00:19.290
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:19.290 --> 00:00:21.860
ocw.mit.edu.

00:00:21.860 --> 00:00:24.570
PROFESSOR: I apologize to
those of you watching on

00:00:24.570 --> 00:00:25.640
OpenCourseWare.

00:00:25.640 --> 00:00:28.240
I forgot to turn on
my microphone.

00:00:28.240 --> 00:00:31.690
And you missed some incredibly
brilliant things.

00:00:31.690 --> 00:00:33.190
But such is life.

00:00:36.430 --> 00:00:39.930
Let me go back to where I was,
which was we we're looking at

00:00:39.930 --> 00:00:44.610
this code to find the cube
root of a perfect cube.

00:00:44.610 --> 00:00:47.880
We saw this last week, and
indeed, you also saw it in

00:00:47.880 --> 00:00:49.300
recitation.

00:00:49.300 --> 00:00:52.800
I'm not going to belabor it.

00:00:52.800 --> 00:00:57.400
I do want to ask you the
question, for what values will

00:00:57.400 --> 00:00:58.705
this program terminate?

00:01:01.710 --> 00:01:04.239
That is to say the only
input is to x.

00:01:04.239 --> 00:01:06.950
For what values of
x is this program

00:01:06.950 --> 00:01:09.453
guaranteed to always stop?

00:01:15.930 --> 00:01:18.050
Anybody want to volunteer
an answer to that?

00:01:21.380 --> 00:01:22.660
Ask a simpler question.

00:01:22.660 --> 00:01:25.360
Let's assume that
x is a number.

00:01:25.360 --> 00:01:27.020
In fact, let's assume
it's an integer.

00:01:29.930 --> 00:01:33.400
Will it terminate for all
positive integers, all

00:01:33.400 --> 00:01:35.900
positive values of x?

00:01:35.900 --> 00:01:36.950
Yeah.

00:01:36.950 --> 00:01:39.890
All negative values?

00:01:39.890 --> 00:01:41.690
As far as I can tell.

00:01:41.690 --> 00:01:43.250
How about 0?

00:01:43.250 --> 00:01:44.300
Yeah.

00:01:44.300 --> 00:01:48.640
So in fact, it terminates
for all values of x.

00:01:48.640 --> 00:01:51.470
How do I know that?

00:01:51.470 --> 00:01:53.560
And that's a key question.

00:01:53.560 --> 00:01:58.120
I know that because I've used,
and I mean by used as a mental

00:01:58.120 --> 00:02:01.620
tool, something in my head,
the notion of a

00:02:01.620 --> 00:02:02.870
decrementing function.

00:02:11.360 --> 00:02:16.250
And every time I write a loop,
I think about one of these,

00:02:16.250 --> 00:02:19.540
because that explains to
me why the loop is

00:02:19.540 --> 00:02:22.900
guaranteed to terminate.

00:02:22.900 --> 00:02:26.920
We'll go over here where we have
a bigger board and look

00:02:26.920 --> 00:02:29.690
at the properties that
a decrementing

00:02:29.690 --> 00:02:30.940
function needs to have.

00:02:35.850 --> 00:02:42.720
One, it will map some
set of program

00:02:42.720 --> 00:02:54.665
variables to an integer.

00:03:04.880 --> 00:03:10.490
Two, when the loop is entered
for the first time or when I

00:03:10.490 --> 00:03:14.070
encountered the test of the loop
for the first time, its

00:03:14.070 --> 00:03:15.710
value is non-negative.

00:03:30.770 --> 00:03:41.930
Three, when its value gets to
be less than or equal to 0,

00:03:41.930 --> 00:03:43.180
the loop terminates.

00:03:49.530 --> 00:03:56.600
And finally four, it's
decreased each

00:03:56.600 --> 00:03:58.566
time through the loop.

00:04:08.430 --> 00:04:13.290
So what we see is if it starts
to be a positive value or

00:04:13.290 --> 00:04:17.839
non-negative, and it's decreased
every time I execute

00:04:17.839 --> 00:04:22.710
the body of a loop, that
eventually, it's got to reach

00:04:22.710 --> 00:04:25.290
0 or something less than 0.

00:04:25.290 --> 00:04:26.720
And when it does,
the loop stops.

00:04:29.820 --> 00:04:33.840
If such a function exists, then
the loop is guaranteed to

00:04:33.840 --> 00:04:35.090
always terminate.

00:04:38.570 --> 00:04:42.190
Now, of course, one can count up
to a value instead of down.

00:04:42.190 --> 00:04:45.180
But there's always a trick we
can use of subtracting to make

00:04:45.180 --> 00:04:46.730
it the same.

00:04:46.730 --> 00:04:50.960
So what's the decrementing
function for this loop?

00:04:50.960 --> 00:04:52.625
How did I know it will
always terminate?

00:04:58.030 --> 00:04:58.460
Yeah?

00:04:58.460 --> 00:05:00.915
AUDIENCE: [INAUDIBLE].

00:05:00.915 --> 00:05:04.760
PROFESSOR: Answer equals
answer plus 1.

00:05:04.760 --> 00:05:07.030
I don't think so.

00:05:07.030 --> 00:05:09.010
Does that satisfy all
of these properties?

00:05:13.870 --> 00:05:17.320
Remember, a function is going
to map some set of program

00:05:17.320 --> 00:05:23.680
variables to an integer.

00:05:23.680 --> 00:05:26.440
So what are the interesting
program variables here?

00:05:26.440 --> 00:05:30.530
Well, there are only
two, ans and x.

00:05:30.530 --> 00:05:31.780
Right?

00:05:33.385 --> 00:05:35.140
At least, that's
all I can see.

00:05:39.270 --> 00:05:40.810
So what would be an interesting
function?

00:05:45.900 --> 00:05:47.150
Somebody?

00:05:48.950 --> 00:05:51.300
Surely, there's someone who
can figure this out.

00:05:55.520 --> 00:05:57.040
Yes?

00:05:57.040 --> 00:05:58.583
Or no, you're just scratching
your head.

00:05:58.583 --> 00:06:00.270
You fooled me.

00:06:00.270 --> 00:06:02.630
I can't see because of the
light, but I'm sure there must

00:06:02.630 --> 00:06:05.241
be dozens of hands up if
I could only see them.

00:06:07.890 --> 00:06:10.460
Actually, I don't see
any hands up.

00:06:13.010 --> 00:06:14.375
This is not so hard, guys.

00:06:19.430 --> 00:06:26.155
It's the absolute value of
x minus answer cubed.

00:06:36.810 --> 00:06:39.850
So what does this
value start at?

00:06:39.850 --> 00:06:41.920
Let's pick a value.

00:06:41.920 --> 00:06:47.080
Suppose that x is equal to 8.

00:06:52.240 --> 00:06:54.690
What is the initial value of
the decrementing function?

00:06:57.250 --> 00:06:59.070
Wow.

00:06:59.070 --> 00:07:00.230
Come on.

00:07:00.230 --> 00:07:02.450
Let's be a little cooperative,
please.

00:07:02.450 --> 00:07:03.030
Yes?

00:07:03.030 --> 00:07:07.022
AUDIENCE: So it's 8, answer
is 0 and absolute

00:07:07.022 --> 00:07:07.521
value of x is 8.

00:07:07.521 --> 00:07:13.140
PROFESSOR: So it's 8 minus
0, which is equal to 8.

00:07:13.140 --> 00:07:17.805
So it satisfies conditions
one and conditions two.

00:07:21.000 --> 00:07:23.695
What happens to this value every
time through the loop?

00:07:29.400 --> 00:07:32.390
Does x change?

00:07:32.390 --> 00:07:35.060
Does answer change?

00:07:35.060 --> 00:07:38.220
And how does it change?

00:07:38.220 --> 00:07:40.490
It's increasing.

00:07:40.490 --> 00:07:41.870
What does answer start at?

00:07:41.870 --> 00:07:44.730
It starts at 0, and
it increases.

00:07:44.730 --> 00:07:48.700
So I know that answer cubed
will always be positive.

00:07:48.700 --> 00:07:49.870
Right?

00:07:49.870 --> 00:07:51.500
So I know that every
time through the

00:07:51.500 --> 00:07:54.840
loop, it will be 8.

00:07:54.840 --> 00:07:57.350
The first time through,
it'll be 8 minus 1

00:07:57.350 --> 00:07:58.600
cubed, which is 7.

00:08:02.150 --> 00:08:06.030
And then the next time through,
it'll be 8 minus 2

00:08:06.030 --> 00:08:09.670
cubed, which is 0.

00:08:09.670 --> 00:08:10.920
And then, I exit the loop.

00:08:14.500 --> 00:08:16.820
And it's that kind of reasoning
that I used to

00:08:16.820 --> 00:08:21.800
convince myself that this
loop terminates.

00:08:21.800 --> 00:08:24.590
And every time I write a loop,
and I hope every time you

00:08:24.590 --> 00:08:29.680
write a loop, you will think
about what's the reason the

00:08:29.680 --> 00:08:31.370
loop is going to terminate.

00:08:31.370 --> 00:08:34.470
And you will do it by thinking
about what the decrementing

00:08:34.470 --> 00:08:35.720
function is.

00:08:37.929 --> 00:08:39.940
People get me on that?

00:08:39.940 --> 00:08:43.520
And whoever finally answered
a question surely

00:08:43.520 --> 00:08:44.770
deserves to be fed.

00:08:49.060 --> 00:08:51.300
I obviously have to bring better
candy to encourage

00:08:51.300 --> 00:08:55.070
better responses.

00:08:55.070 --> 00:08:59.930
Now, let's go back and look
at the program itself.

00:08:59.930 --> 00:09:05.230
Now that we know it stops, and
you can take my word for it

00:09:05.230 --> 00:09:09.350
that it actually computes the
correct answer, let's think

00:09:09.350 --> 00:09:11.200
about what kind of algorithm
this is.

00:09:11.200 --> 00:09:13.240
What's the method?

00:09:13.240 --> 00:09:17.040
This is an example of
guess and check.

00:09:17.040 --> 00:09:20.190
And it's a particular kind
called exhaustive enumeration.

00:09:37.680 --> 00:09:41.130
Each time through the loop, I'm
taking a guess at to what

00:09:41.130 --> 00:09:45.730
the value is, and I'm checking
whether it's true.

00:09:45.730 --> 00:09:48.330
But I'm enumerating
the guesses in a

00:09:48.330 --> 00:09:49.840
very systematic way.

00:09:49.840 --> 00:09:52.050
They're not just
random guesses.

00:09:52.050 --> 00:09:54.520
I'm enumerating all the
possible answers.

00:09:58.670 --> 00:10:02.460
If I get through the entire
space of answers, or possible

00:10:02.460 --> 00:10:06.180
answers, and I don't find a
solution, then I know that it

00:10:06.180 --> 00:10:09.850
doesn't exist, and it's
not a perfect cube.

00:10:09.850 --> 00:10:13.180
So that's why it's called
exhaustive enumeration because

00:10:13.180 --> 00:10:15.740
I'm exhausting the space
of possible answers.

00:10:20.880 --> 00:10:23.130
Does that makes sense
to everyone?

00:10:23.130 --> 00:10:25.350
So let's try it.

00:10:25.350 --> 00:10:31.810
Let's try it with say a very
large value of x, because

00:10:31.810 --> 00:10:34.150
that's always an issue, of
course, when we do exhaustive

00:10:34.150 --> 00:10:35.400
enumeration.

00:10:38.210 --> 00:10:40.160
So I'm going to enter
this value.

00:10:49.360 --> 00:10:51.350
Is that a perfect cube?

00:10:51.350 --> 00:10:52.600
Who thinks it is?

00:10:54.750 --> 00:10:56.330
Who can tell me what it is?

00:10:56.330 --> 00:10:59.140
What's the cube root of that?

00:10:59.140 --> 00:11:02.270
Well, this is a question I did
not expect you to answer.

00:11:02.270 --> 00:11:07.930
But it's 1,251.

00:11:07.930 --> 00:11:10.550
That'll be in the first quiz,
so make a note of it.

00:11:13.320 --> 00:11:16.160
Notice how quickly the
computer did this.

00:11:16.160 --> 00:11:17.920
It found the cube
root of quite a

00:11:17.920 --> 00:11:21.690
large number very quickly.

00:11:21.690 --> 00:11:24.380
And so while one might
initially think that

00:11:24.380 --> 00:11:29.890
exhaustive enumeration is a
silly technique because takes

00:11:29.890 --> 00:11:33.140
a lot of guesses, for an awful
lot of problems, we can

00:11:33.140 --> 00:11:38.230
actually just write a pretty
stupid program that's solves

00:11:38.230 --> 00:11:40.340
it by exhaustive enumeration.

00:11:40.340 --> 00:11:43.330
We typically refer to such
programs as brute force.

00:11:45.980 --> 00:11:48.930
And brute force is often
exactly the right

00:11:48.930 --> 00:11:51.680
way to solve a problem.

00:11:51.680 --> 00:11:53.140
Why does it work?

00:11:53.140 --> 00:11:54.735
Because computers
are really fast.

00:11:57.410 --> 00:11:59.550
How fast are computers?

00:11:59.550 --> 00:12:02.520
Well, today, a good computer
can execute in a single

00:12:02.520 --> 00:12:06.940
processor in the order of 100
million instructions a second.

00:12:06.940 --> 00:12:08.870
How fast is that?

00:12:08.870 --> 00:12:10.830
And now, we're going to see if
Mitchell has answered the

00:12:10.830 --> 00:12:13.620
question I asked in the
way in the class.

00:12:13.620 --> 00:12:17.710
How many instructions can a
computer execute between the

00:12:17.710 --> 00:12:20.240
time I say something and the
time the people in the back

00:12:20.240 --> 00:12:23.780
row hear it?

00:12:23.780 --> 00:12:27.950
Mitch thinks it's 400 million
instructions.

00:12:27.950 --> 00:12:29.370
I think that's about right.

00:12:29.370 --> 00:12:32.220
It's hundreds of millions
at any rate.

00:12:32.220 --> 00:12:34.750
It's kind of amazing between the
time I say something and

00:12:34.750 --> 00:12:39.370
the time you hear it, hundreds
of millions of instructions.

00:12:39.370 --> 00:12:42.900
It's mind boggling
how fast that is.

00:12:42.900 --> 00:12:48.030
And that's why we can often use
these kind of solutions.

00:12:48.030 --> 00:12:50.570
Next lecture, actually, even
a little bit later in this

00:12:50.570 --> 00:12:54.320
lecture, I hope to get to an
example of why that doesn't

00:12:54.320 --> 00:12:58.940
really get the job done,
at least not always.

00:12:58.940 --> 00:13:02.360
Before I do that, I want
to look at one

00:13:02.360 --> 00:13:04.910
more programming construct.

00:13:04.910 --> 00:13:09.070
And that's a variant
on the while loop.

00:13:09.070 --> 00:13:11.560
So if we think about what the
while loop we were just

00:13:11.560 --> 00:13:19.720
looking at did or does, as the
decrementing function told us,

00:13:19.720 --> 00:13:23.040
it's looking at all the possible
values of answer

00:13:23.040 --> 00:13:28.160
ranging from 0 to the
absolute value of x.

00:13:28.160 --> 00:13:32.110
And at each step testing and
doing something, we can

00:13:32.110 --> 00:13:36.575
abstract this process using
something called a for loop.

00:13:54.200 --> 00:13:57.380
So let's look at this code.

00:13:57.380 --> 00:14:01.610
It's essentially exactly
the same algorithm.

00:14:01.610 --> 00:14:05.840
I got bored of typing ans
times ans times ans.

00:14:05.840 --> 00:14:10.990
So I used a Python notation
for exponentiation, which

00:14:10.990 --> 00:14:12.800
you'll see is star, star.

00:14:16.590 --> 00:14:21.930
Now, be easier to read
if I get rid of that.

00:14:21.930 --> 00:14:24.760
But other than that, the
interesting thing I did was

00:14:24.760 --> 00:14:28.890
replace the while
loop by a for.

00:14:28.890 --> 00:14:34.170
So you'll see this line of code
there, for ans in range 0

00:14:34.170 --> 00:14:38.710
to abs of x plus 1.

00:14:38.710 --> 00:14:46.350
What that says is range is a
built-in function of Python

00:14:46.350 --> 00:14:52.130
that generates, in this case,
a sequence of integers,

00:14:52.130 --> 00:14:55.670
something called a tuple, which
we'll be looking at in a

00:14:55.670 --> 00:14:57.360
lecture or so.

00:14:57.360 --> 00:15:01.130
But for now, it's pretty simple
to think about what you

00:15:01.130 --> 00:15:12.230
get is if you look at the
expression range of x to y,

00:15:12.230 --> 00:15:19.605
that gives me a sequence
of values, x, x plus 1

00:15:19.605 --> 00:15:24.550
up to y minus 1.

00:15:24.550 --> 00:15:28.330
Notice not up to y, but
up to y minus 1.

00:15:28.330 --> 00:15:30.900
So it gives me a sequence
of length y--

00:15:34.080 --> 00:15:37.970
well, assuming that's 0.

00:15:37.970 --> 00:15:38.900
Right?

00:15:38.900 --> 00:15:40.880
It doesn't have to be 0.

00:15:40.880 --> 00:15:41.475
It can be anything.

00:15:41.475 --> 00:15:46.210
It can be another
value as well.

00:15:46.210 --> 00:15:48.950
0 in my example.

00:15:48.950 --> 00:15:54.450
And then, the for loop executes
it on this value and

00:15:54.450 --> 00:15:57.910
the next iteration on this
value, and finally, at the

00:15:57.910 --> 00:16:01.400
very end on that value.

00:16:01.400 --> 00:16:06.280
So it executes it one iteration
of the loop on each

00:16:06.280 --> 00:16:10.290
value in this sequence
of values generated

00:16:10.290 --> 00:16:11.540
by the range statement.

00:16:14.100 --> 00:16:16.460
And normally, it does
all of them.

00:16:16.460 --> 00:16:22.290
However, you'll see I've added
something called a break here,

00:16:22.290 --> 00:16:24.460
a command in Python.

00:16:24.460 --> 00:16:27.905
And what break says
is exit the loop.

00:16:30.720 --> 00:16:35.670
So it exits it prematurely
without executing all of the

00:16:35.670 --> 00:16:37.265
values generated by range.

00:16:42.670 --> 00:16:46.310
You can nest loops just like
you nest if statements.

00:16:46.310 --> 00:16:49.880
And if you do that break,
always executes--

00:16:49.880 --> 00:16:52.370
always exits rather the
innermost loop.

00:16:54.940 --> 00:16:57.700
So what this does is it's
generates a set

00:16:57.700 --> 00:17:00.390
of values to test.

00:17:00.390 --> 00:17:03.800
It checks whether or not
it's got the answer.

00:17:03.800 --> 00:17:06.290
If it does, it terminates
the loop.

00:17:09.780 --> 00:17:12.020
And eventually, you
exit the loop.

00:17:12.020 --> 00:17:14.869
And then, it just checks as
before whether or not it found

00:17:14.869 --> 00:17:19.589
a correct answer and does
the right thing.

00:17:19.589 --> 00:17:23.460
So you'll find, particularly
when you're iterating over

00:17:23.460 --> 00:17:26.470
integers, but later we'll see
when you're iterating over a

00:17:26.470 --> 00:17:31.410
lot of other kinds of things,
for loops are a very

00:17:31.410 --> 00:17:34.350
convenient shorthand.

00:17:34.350 --> 00:17:36.540
There's nothing you can't
do with a while loop.

00:17:36.540 --> 00:17:38.640
You don't need for loops.

00:17:38.640 --> 00:17:40.530
But they do make life easy.

00:17:40.530 --> 00:17:44.470
And over the semester, I think
you'll end up writing a lot

00:17:44.470 --> 00:17:47.650
more for loops than you
will while loops.

00:17:50.950 --> 00:17:52.380
Any questions about this?

00:17:55.560 --> 00:17:57.620
If not, I'm going to
move right along.

00:17:57.620 --> 00:18:01.280
So this is the moment.

00:18:01.280 --> 00:18:03.570
I'm going to move right along.

00:18:03.570 --> 00:18:06.840
So we've now got a program that
does something really

00:18:06.840 --> 00:18:08.770
silly, really.

00:18:08.770 --> 00:18:15.160
It finds cube roots
of perfect cubes.

00:18:15.160 --> 00:18:17.220
Well, that's not typically
useful.

00:18:17.220 --> 00:18:17.680
Right?

00:18:17.680 --> 00:18:21.960
You've even got these $0.50 four
function calculators that

00:18:21.960 --> 00:18:23.910
find square roots.

00:18:23.910 --> 00:18:28.570
And they don't insist that you
only give it perfect squares.

00:18:28.570 --> 00:18:31.130
So now, let's think about how
we would take this kind of

00:18:31.130 --> 00:18:36.440
program, and indeed, this kind
of method of writing programs

00:18:36.440 --> 00:18:38.570
and use it to find--

00:18:38.570 --> 00:18:43.610
for now, we'll look at the
square root of any number, of

00:18:43.610 --> 00:18:45.050
any floating point number.

00:18:48.820 --> 00:18:52.450
Well, the first question we need
to ask is what do I mean?

00:18:55.050 --> 00:18:56.930
That's kind of a subtle
question.

00:18:56.930 --> 00:18:58.945
What does it mean to find the
square root of a number?

00:19:01.480 --> 00:19:03.180
What does it mean, for
example, to find the

00:19:03.180 --> 00:19:04.430
square root of 2?

00:19:07.130 --> 00:19:14.340
Well, we know that that was an
endless series of digits

00:19:14.340 --> 00:19:16.190
before we can find the
square root of 2.

00:19:16.190 --> 00:19:16.550
Right?

00:19:16.550 --> 00:19:19.740
It does not have
a nice answer.

00:19:19.740 --> 00:19:23.030
So we can't just say we have to
find something that if we

00:19:23.030 --> 00:19:26.370
multiply it by itself,
it will equal 2.

00:19:26.370 --> 00:19:28.030
Because we can't find
such a thing.

00:19:30.800 --> 00:19:33.170
So we've got to think
about a different

00:19:33.170 --> 00:19:35.590
notion of what we mean.

00:19:35.590 --> 00:19:37.890
Furthermore, even for some
numbers which there is a

00:19:37.890 --> 00:19:42.860
square root, it might be a
million decimal places long,

00:19:42.860 --> 00:19:47.260
and consequently, really
hard to find.

00:19:47.260 --> 00:19:50.270
So we need to think
about a different

00:19:50.270 --> 00:19:53.920
kind of concept here.

00:19:53.920 --> 00:20:11.070
And it's the concept of an
approximation, finding an

00:20:11.070 --> 00:20:14.570
answer that is good enough.

00:20:14.570 --> 00:20:17.560
So what should we do here?

00:20:17.560 --> 00:20:19.770
How do we think about this?

00:20:19.770 --> 00:20:25.690
Typically, what we do when we
think about an approximation

00:20:25.690 --> 00:20:30.110
is we define how good
an approximation

00:20:30.110 --> 00:20:31.360
we're willing to accept.

00:20:35.590 --> 00:20:40.960
So for example, we might want
to say, I want to find a

00:20:40.960 --> 00:20:44.750
square root that lies
within epsilon of

00:20:44.750 --> 00:20:48.120
the true square root.

00:20:48.120 --> 00:21:11.410
So find a y such that y times
y is equal to what?

00:21:11.410 --> 00:21:12.180
What does it mean?

00:21:12.180 --> 00:21:15.605
How would I express it within
epsilon of the perfect answer?

00:21:18.240 --> 00:21:21.860
I don't want to say it's equal
to x, because that may be

00:21:21.860 --> 00:21:26.820
impossible or too time
consuming to find.

00:21:26.820 --> 00:21:30.890
So really, what I mean is
x plus or minus epsilon.

00:21:37.200 --> 00:21:38.350
So that's what I'm asking.

00:21:38.350 --> 00:21:39.930
Find one that's close enough.

00:21:43.290 --> 00:21:45.190
And that's what the next
piece of code I

00:21:45.190 --> 00:21:46.440
want to show you does.

00:22:12.620 --> 00:22:15.490
Excuse me.

00:22:15.490 --> 00:22:19.510
So I'm starting, just giving it
a value for x, so I don't

00:22:19.510 --> 00:22:20.680
have to keep typing one in.

00:22:20.680 --> 00:22:21.930
Let's say it's 25.

00:22:24.290 --> 00:22:28.630
I'm going to take epsilon
to be 0.01.

00:22:28.630 --> 00:22:31.585
So I want it within that
distance of the true answer.

00:22:34.330 --> 00:22:37.810
I'm going to keep track of the
number of guesses here, not

00:22:37.810 --> 00:22:40.540
because we need it to actually
compute the answer, but

00:22:40.540 --> 00:22:43.600
because I want to then discuss
how many iterations of the

00:22:43.600 --> 00:22:46.080
loop we're doing.

00:22:46.080 --> 00:22:51.270
We're going to start by setting
my first guess at 0.0.

00:22:51.270 --> 00:22:55.570
Again, this is going to be
exhaustive enumeration.

00:22:55.570 --> 00:23:00.250
Then, I'm going to essentially
encode this as a test of my

00:23:00.250 --> 00:23:05.280
while loop while the absolute
value of answer squared minus

00:23:05.280 --> 00:23:11.630
x is greater than or equal to
epsilon, and answer is less

00:23:11.630 --> 00:23:13.200
than equal to x.

00:23:13.200 --> 00:23:15.360
So it's now a more
complicated test.

00:23:15.360 --> 00:23:17.180
I've got a Boolean value.

00:23:17.180 --> 00:23:22.180
Two things have to be true to
execute the body of the loop.

00:23:22.180 --> 00:23:28.430
I'm going to increment answer
by a tiny amount, increment

00:23:28.430 --> 00:23:31.140
the number of guesses just so
I can keep track of it.

00:23:34.610 --> 00:23:36.710
Maybe I'm going to comment
this out for the first go

00:23:36.710 --> 00:23:41.850
around just so we don't see too
many print statements and

00:23:41.850 --> 00:23:43.100
keep doing it.

00:23:46.510 --> 00:23:48.370
And then when I'm done I'm going
to see whether or not

00:23:48.370 --> 00:23:54.630
what I found is indeed a square
root or close enough.

00:23:54.630 --> 00:23:58.470
So if we think about why this
loop terminates, why am I

00:23:58.470 --> 00:24:01.600
guaranteed that this loop
will terminate?

00:24:01.600 --> 00:24:03.660
What's my decrementing
function here?

00:24:08.440 --> 00:24:09.690
Somebody?

00:24:11.280 --> 00:24:13.380
What's the decrementing
function?

00:24:13.380 --> 00:24:17.180
What am I guaranteed to reduce
each time through, and when I

00:24:17.180 --> 00:24:18.430
get through, I'm done?

00:24:22.960 --> 00:24:24.250
Yeah?

00:24:24.250 --> 00:24:26.600
AUDIENCE: [INAUDIBLE]

00:24:26.600 --> 00:24:31.458
answer squared minus
x1 times 1.

00:24:31.458 --> 00:24:32.660
PROFESSOR: No.

00:24:32.660 --> 00:24:34.930
Close, sort of.

00:24:34.930 --> 00:24:37.640
But I appreciate
you're trying.

00:24:37.640 --> 00:24:40.840
That's worth something
just for the effort.

00:24:40.840 --> 00:24:43.450
Somebody else.

00:24:43.450 --> 00:24:48.040
Remember, if we look at the
properties it has to have,

00:24:48.040 --> 00:24:50.940
it's going to guarantee me that
when it gets to the right

00:24:50.940 --> 00:24:54.360
value, I exit the loop, which
suggests it's going to

00:24:54.360 --> 00:24:56.420
certainly be part of the
test of the while.

00:25:00.560 --> 00:25:02.790
Just look at this piece
over here at the end.

00:25:06.770 --> 00:25:09.450
Answer starts at 0.

00:25:09.450 --> 00:25:12.940
I keep incrementing it.

00:25:12.940 --> 00:25:20.910
Eventually, answer minus x
will hit a value, right?

00:25:20.910 --> 00:25:23.390
Eventually, I'll get to
the point that this

00:25:23.390 --> 00:25:25.920
condition must be true--

00:25:25.920 --> 00:25:27.150
must be false rather.

00:25:27.150 --> 00:25:28.400
And then, I exit the loop.

00:25:31.590 --> 00:25:35.650
So this piece is not
really the key.

00:25:35.650 --> 00:25:37.940
It's this piece that guarantees
me I'm going to get

00:25:37.940 --> 00:25:39.190
out eventually.

00:25:41.650 --> 00:25:44.090
This piece can get
me out sooner.

00:25:44.090 --> 00:25:45.870
It's kind of an optimization,
if you will.

00:25:49.980 --> 00:25:52.780
So I'm just going to go until
I find the answer.

00:25:52.780 --> 00:25:54.320
Let's see what happens
when I run it.

00:26:00.860 --> 00:26:06.190
It tells me that 4.99, et cetera
is close to the square

00:26:06.190 --> 00:26:09.350
root of 25.

00:26:09.350 --> 00:26:13.210
So there are some things
to note about this.

00:26:13.210 --> 00:26:19.000
First, it didn't find 5, 25
happens to be a perfect

00:26:19.000 --> 00:26:21.790
square, yet I didn't find it.

00:26:21.790 --> 00:26:24.210
Is that OK?

00:26:24.210 --> 00:26:25.050
Yeah.

00:26:25.050 --> 00:26:27.220
Because that wasn't
what I said.

00:26:27.220 --> 00:26:30.050
What I said is find
a y that has these

00:26:30.050 --> 00:26:32.860
properties over here.

00:26:32.860 --> 00:26:34.740
And I did.

00:26:34.740 --> 00:26:37.160
I didn't say find the y that
gets closest to the

00:26:37.160 --> 00:26:38.850
square root of x.

00:26:38.850 --> 00:26:43.340
I said find one that has
these properties.

00:26:43.340 --> 00:26:51.030
Effectively, what this is is a
specification of the problem.

00:26:56.410 --> 00:26:59.150
And I've now written a piece
of code that meets the

00:26:59.150 --> 00:27:00.730
specification.

00:27:00.730 --> 00:27:03.980
It does what I set out to do,
and that's good enough.

00:27:09.060 --> 00:27:15.410
Now, let's turn this print
statement back on.

00:27:20.370 --> 00:27:24.040
It took almost 1/2 million
guesses to get there.

00:27:28.200 --> 00:27:31.280
But it was still blindingly
fast.

00:27:31.280 --> 00:27:36.070
So once again, exhaustive
enumeration seems to be OK.

00:27:36.070 --> 00:27:42.770
Suppose, however, I choose
a bigger number.

00:27:42.770 --> 00:27:49.296
Now, first, let's choose
something that doesn't have a

00:27:49.296 --> 00:27:50.450
good answer.

00:27:50.450 --> 00:27:51.700
Let's see what it
does for that.

00:27:54.140 --> 00:27:55.110
All right.

00:27:55.110 --> 00:27:56.650
Pretty good.

00:27:56.650 --> 00:27:58.640
Also pretty fast.

00:27:58.640 --> 00:28:00.540
Not too many guesses.

00:28:00.540 --> 00:28:02.440
But now, let's try this one.

00:28:12.670 --> 00:28:14.230
Well, it's going to wait.

00:28:14.230 --> 00:28:16.110
It's going to get done, but it's
going to take a little

00:28:16.110 --> 00:28:21.060
bit longer than maybe
we want it to take.

00:28:21.060 --> 00:28:22.940
Why is it taking so long?

00:28:22.940 --> 00:28:23.490
There it is.

00:28:23.490 --> 00:28:28.320
It found an answer, which
I think is good.

00:28:28.320 --> 00:28:30.010
But as you can see, it
took quite a few

00:28:30.010 --> 00:28:33.770
guesses to get there.

00:28:33.770 --> 00:28:35.430
So why?

00:28:35.430 --> 00:28:38.010
Well, let me first ask
this question.

00:28:38.010 --> 00:28:45.710
Can we look at the code and
anticipate how many guesses

00:28:45.710 --> 00:28:49.350
it's going to have to take?

00:28:49.350 --> 00:28:52.650
We're going back to this issue
of computational complexity,

00:28:52.650 --> 00:28:56.390
but here, not of the problem
but of the solution.

00:28:56.390 --> 00:28:59.160
So this is algorithmic
analysis.

00:28:59.160 --> 00:29:03.440
We're analyzing the algorithm,
this exhaustive enumeration

00:29:03.440 --> 00:29:07.430
algorithm, and trying to figure
out how long it's

00:29:07.430 --> 00:29:10.420
likely to take to run.

00:29:10.420 --> 00:29:11.890
Well, what does the running
time of this

00:29:11.890 --> 00:29:13.220
algorithm depend upon?

00:29:16.740 --> 00:29:18.236
Yeah?

00:29:18.236 --> 00:29:19.550
AUDIENCE: [INAUDIBLE].

00:29:19.550 --> 00:29:24.180
PROFESSOR: It depends on
the actual square root.

00:29:24.180 --> 00:29:24.740
Yes.

00:29:24.740 --> 00:29:28.070
But in particular, the distance
of the actual square

00:29:28.070 --> 00:29:30.970
root from the starting point.

00:29:30.970 --> 00:29:33.760
So that's one factor
it depends on.

00:29:33.760 --> 00:29:35.520
But that's not the
only factor.

00:29:35.520 --> 00:29:36.790
What else does it depend on?

00:29:40.630 --> 00:29:45.290
Oh, do we have an injury?

00:29:45.290 --> 00:29:48.420
We had a dropped pass and
a deflection there.

00:29:48.420 --> 00:29:50.300
All right.

00:29:50.300 --> 00:29:51.680
Yes?

00:29:51.680 --> 00:29:54.855
AUDIENCE: It depends on the
level of accuracy, so how you

00:29:54.855 --> 00:29:55.560
define epsilon.

00:29:55.560 --> 00:29:58.790
PROFESSOR: It depends upon
the value of epsilon.

00:29:58.790 --> 00:30:00.040
Absolutely.

00:30:01.670 --> 00:30:03.190
How long it takes to run.

00:30:03.190 --> 00:30:04.440
AUDIENCE: [INAUDIBLE].

00:30:08.514 --> 00:30:10.665
PROFESSOR: Someone with
a concern for safety.

00:30:13.680 --> 00:30:17.040
it depends upon the actual value
of epsilon, because if

00:30:17.040 --> 00:30:22.510
epsilon is small, we may have
to take more steps to get a

00:30:22.510 --> 00:30:24.330
precise enough answer.

00:30:24.330 --> 00:30:27.970
And it depends upon
one more thing.

00:30:27.970 --> 00:30:28.410
Yeah?

00:30:28.410 --> 00:30:30.910
AUDIENCE: [INAUDIBLE] the
increment that [INAUDIBLE]?

00:30:30.910 --> 00:30:32.120
PROFESSOR: The increment.

00:30:32.120 --> 00:30:33.150
Exactly.

00:30:33.150 --> 00:30:36.740
Because the number of times we
go through the loop is going

00:30:36.740 --> 00:30:39.660
to be related to how
big a step we

00:30:39.660 --> 00:30:40.970
take each time through.

00:30:45.900 --> 00:30:47.470
No applause?

00:30:47.470 --> 00:30:50.670
Thank you.

00:30:50.670 --> 00:30:54.080
So it depends upon all
of these things.

00:30:54.080 --> 00:30:59.170
And here, since we're trying
to find a pretty [? big ?]

00:30:59.170 --> 00:31:05.130
square root and a sort of
precise answer, but we're

00:31:05.130 --> 00:31:07.540
taking tiny steps, it's
going to take a

00:31:07.540 --> 00:31:09.950
long time to execute.

00:31:09.950 --> 00:31:12.220
So we could make it faster.

00:31:12.220 --> 00:31:20.240
For example, suppose I change
the step size to this.

00:31:24.850 --> 00:31:28.580
Plus equal by says increment
the value by whatever the

00:31:28.580 --> 00:31:29.920
right side is.

00:31:29.920 --> 00:31:31.690
So I'm going to increment
it by 1.

00:31:44.430 --> 00:31:46.770
Wow, it was really fast.

00:31:46.770 --> 00:31:47.700
But it didn't work.

00:31:47.700 --> 00:31:51.430
It failed.

00:31:51.430 --> 00:31:54.840
That's not so good.

00:31:54.840 --> 00:31:56.410
So I can't just do that.

00:31:56.410 --> 00:31:58.820
And of course, it's not
surprising, because I ended up

00:31:58.820 --> 00:32:02.670
jumping all over the answer.

00:32:02.670 --> 00:32:08.730
I could make epsilon smaller,
but that seems like cheating.

00:32:08.730 --> 00:32:15.030
So really, what I need to do is
find a better algorithm, a

00:32:15.030 --> 00:32:17.040
better way to attack
the problem.

00:32:19.680 --> 00:32:22.420
Fortunately, I don't
have to invent it.

00:32:22.420 --> 00:32:26.880
Some people a lot smarter than
I am figured out a long time

00:32:26.880 --> 00:32:32.340
ago a good method for solving
this kind of problem.

00:32:32.340 --> 00:32:35.360
And they're doing it
using something

00:32:35.360 --> 00:32:36.940
called bisection search.

00:32:49.370 --> 00:32:53.040
As we look at this particular
implementation of it, we're

00:32:53.040 --> 00:32:58.060
going to use two algorithmic
techniques that you'll use

00:32:58.060 --> 00:33:01.930
over and over again because
they're generally useful.

00:33:01.930 --> 00:33:07.810
So the first one related to
bisection search is we'll cut

00:33:07.810 --> 00:33:18.415
the search space in half
each iteration.

00:33:23.720 --> 00:33:27.320
So with my brute force
algorithm, we're trimming the

00:33:27.320 --> 00:33:31.610
search base only a little
bit each step.

00:33:31.610 --> 00:33:38.040
So if we think about it, what it
looks like, we had a space

00:33:38.040 --> 00:33:40.000
of values to search
for the answer.

00:33:42.830 --> 00:33:45.780
And I started here.

00:33:45.780 --> 00:33:49.750
And each step, I just trimmed
off a tiny, tiny little bit,

00:33:49.750 --> 00:33:55.280
0.001, leaving me a lot
of space to search.

00:33:55.280 --> 00:33:57.640
And that's why it
took so long.

00:33:57.640 --> 00:34:05.170
When I do bisection search, the
basic idea is each step I

00:34:05.170 --> 00:34:09.170
want to cut the search
space in half.

00:34:09.170 --> 00:34:13.600
Get rid of half of the search
space each time.

00:34:13.600 --> 00:34:18.540
So one way I could do
it is I start with a

00:34:18.540 --> 00:34:22.870
guess say in the middle.

00:34:22.870 --> 00:34:28.060
Just pick some guess that's in
the middle of my search space.

00:34:28.060 --> 00:34:31.270
And now I say is it too
high or too low?

00:34:34.000 --> 00:34:35.850
I can easily answer
that question.

00:34:35.850 --> 00:34:37.560
I square it.

00:34:37.560 --> 00:34:40.420
See is my result bigger than
the actual square root or

00:34:40.420 --> 00:34:43.199
smaller than the actual
square root?

00:34:43.199 --> 00:34:47.370
That tells me whether my guess
is too big or too small.

00:34:47.370 --> 00:34:51.989
Once I know that, I know which
side of the guess the right

00:34:51.989 --> 00:34:53.239
answer is on.

00:34:55.800 --> 00:35:00.970
So if I knew that my guess was
too big, then I know there's

00:35:00.970 --> 00:35:04.410
no point in looking over
here for my next guess.

00:35:04.410 --> 00:35:07.560
So I can get rid of this
whole half in one step.

00:35:12.160 --> 00:35:13.690
Now, what should my
next guess be?

00:35:16.850 --> 00:35:17.320
Yeah?

00:35:17.320 --> 00:35:19.248
AUDIENCE: [INAUDIBLE].

00:35:19.248 --> 00:35:20.680
PROFESSOR: My next
guess should be

00:35:20.680 --> 00:35:23.960
half way through there.

00:35:23.960 --> 00:35:25.210
Exactly.

00:35:30.230 --> 00:35:37.530
And now, let's say this time
my answer is too small.

00:35:37.530 --> 00:35:39.080
Then I know I can
get rid of this.

00:35:42.820 --> 00:35:46.175
So now, I'm very quickly pruning
my search space.

00:35:52.550 --> 00:35:57.150
If I think about that, how many
times am I likely to have

00:35:57.150 --> 00:35:58.400
to prune it?

00:36:05.300 --> 00:36:08.480
It's much faster, right?

00:36:08.480 --> 00:36:14.680
As we'll see later, it's
basically log base 2.

00:36:14.680 --> 00:36:19.880
If I have some number of
values to look at--

00:36:19.880 --> 00:36:22.770
and by the way, how many values
do I have in my search

00:36:22.770 --> 00:36:26.130
space to start with?

00:36:26.130 --> 00:36:27.520
What determines it?

00:36:27.520 --> 00:36:36.250
Clearly, the first value and the
last value, but also, how

00:36:36.250 --> 00:36:38.425
small I'm dividing it up.

00:36:42.200 --> 00:36:43.080
Right?

00:36:43.080 --> 00:36:45.350
So I have to think
about that too.

00:36:45.350 --> 00:36:50.060
What is the precision with
which I do this.

00:36:50.060 --> 00:36:52.650
Am I looking at every
one millionth of a

00:36:52.650 --> 00:36:55.580
number or every 0.01?

00:36:55.580 --> 00:36:57.940
That will tell me
how big it is.

00:36:57.940 --> 00:37:05.740
Once I know how big my search
space is, I know that if I

00:37:05.740 --> 00:37:09.780
search it linearly looking at
every value, my worst cases, I

00:37:09.780 --> 00:37:11.860
look at everything until
I get to the end.

00:37:15.330 --> 00:37:17.370
Well, my best case is
I get lucky, and my

00:37:17.370 --> 00:37:19.230
first guess is right.

00:37:19.230 --> 00:37:23.700
But if I use bisection search,
my worst case is going to be

00:37:23.700 --> 00:37:27.360
log number of values
in that space.

00:37:27.360 --> 00:37:32.010
Because each time, I throw
half of them away.

00:37:32.010 --> 00:37:35.700
We'll see that in more
detail later on.

00:37:35.700 --> 00:37:37.800
Let's go back and look
at the code now.

00:37:57.980 --> 00:38:01.640
So it starts as before with
a value for epsilon.

00:38:01.640 --> 00:38:06.970
But now, I'm going to take a
lower bound, here, and an

00:38:06.970 --> 00:38:08.705
upper bound on my
search space.

00:38:12.430 --> 00:38:15.840
I'm going to say my initial
guess will be the upper bound

00:38:15.840 --> 00:38:19.100
plus the lower bound
over 2 halfway

00:38:19.100 --> 00:38:20.350
through my search space.

00:38:25.510 --> 00:38:30.390
And then, I'm just going to work
my way through it until I

00:38:30.390 --> 00:38:33.780
get to the answer or
don't find it.

00:38:37.380 --> 00:38:40.050
So should we look at what's
going on here?

00:38:40.050 --> 00:38:41.300
Let's try this.

00:38:43.420 --> 00:38:54.270
Well, let's first make sure it
works for a small value.

00:38:54.270 --> 00:38:57.580
Never test your program first
on something big.

00:38:57.580 --> 00:39:00.040
Always try your program in
something small first.

00:39:02.950 --> 00:39:04.200
Let's try it on that.

00:39:08.100 --> 00:39:09.350
Got an answer.

00:39:11.720 --> 00:39:14.930
Notice that it's different from
the answer we got last

00:39:14.930 --> 00:39:16.535
time we looked for the
square root of 25.

00:39:19.220 --> 00:39:24.830
But that's OK, because it's
still meets the specification.

00:39:24.830 --> 00:39:28.420
It's still within epsilon of
the actual square root.

00:39:28.420 --> 00:39:31.970
And I didn't have to say that
I wanted it below or the

00:39:31.970 --> 00:39:35.390
square root or above, just
said within epsilon.

00:39:35.390 --> 00:39:38.960
Sure enough, different
algorithm, different answer,

00:39:38.960 --> 00:39:44.990
but equally good, but
a lot faster.

00:39:44.990 --> 00:39:47.395
Now let's try it for
the big value.

00:40:04.130 --> 00:40:06.264
Wow, that was a lot
faster, wasn't it?

00:40:11.370 --> 00:40:14.350
It got me an answer.

00:40:14.350 --> 00:40:16.340
Probably, not exactly
the same answer as

00:40:16.340 --> 00:40:19.310
before but pretty close.

00:40:19.310 --> 00:40:23.530
But it did it in only
26 guesses.

00:40:23.530 --> 00:40:25.610
Pretty cool.

00:40:25.610 --> 00:40:30.410
And in fact, we'll see over and
over again that bisection

00:40:30.410 --> 00:40:34.250
search is a really good
technique for

00:40:34.250 --> 00:40:35.980
finding quick answers.

00:40:40.900 --> 00:40:43.850
And again, why is it 26?

00:40:43.850 --> 00:40:48.350
Well, we had some number of
guesses to start with.

00:40:48.350 --> 00:40:52.850
After 1, it was half as big,
then a quarter is big, and

00:40:52.850 --> 00:40:56.430
eventually, log 2 of the size.

00:40:56.430 --> 00:40:59.270
But what was the size?

00:40:59.270 --> 00:41:05.780
Was it the number 12345?

00:41:05.780 --> 00:41:06.380
No.

00:41:06.380 --> 00:41:10.270
We already sort of talked
about that.

00:41:10.270 --> 00:41:11.860
What was it?

00:41:11.860 --> 00:41:16.760
Let's look at the code, and
let's think about what was the

00:41:16.760 --> 00:41:18.465
size of our initial
search space.

00:41:22.320 --> 00:41:24.680
It's a little bit tricky to
think about this, right?

00:41:31.350 --> 00:41:35.830
Now, we have to think a little
bit harder about when we exit

00:41:35.830 --> 00:41:38.940
the loop, because in
fundamentally, that's telling

00:41:38.940 --> 00:41:40.345
me the size of the
search space.

00:41:42.890 --> 00:41:45.410
So what determined the size
of the search space?

00:41:54.386 --> 00:41:57.810
Well, we talked about the upper
and the lower bound.

00:41:57.810 --> 00:42:00.950
But what's telling me
roughly speaking how

00:42:00.950 --> 00:42:05.450
many divisions I have?

00:42:05.450 --> 00:42:06.700
It's epsilon.

00:42:08.700 --> 00:42:13.760
It's not 0.01 because when
I square it, it has to be

00:42:13.760 --> 00:42:16.110
smaller than 0.01.

00:42:16.110 --> 00:42:18.590
But that tells me roughly
how many I have.

00:42:21.740 --> 00:42:27.970
And so it's going to be roughly
12345 divided by 0.01

00:42:27.970 --> 00:42:35.170
squared, which turns out to
be 26.897 more or less.

00:42:35.170 --> 00:42:38.170
So we could predict it.

00:42:38.170 --> 00:42:41.360
And son of a gun, when we ran
it, we actually matched the

00:42:41.360 --> 00:42:43.760
prediction.

00:42:43.760 --> 00:42:46.930
That's the great thing about
algorithmic analysis.

00:42:46.930 --> 00:42:50.320
We can actually get accurate
guesses as to how long a

00:42:50.320 --> 00:42:53.560
program is likely
to take to run.

00:42:53.560 --> 00:42:56.815
This is an important thing
because sometimes we do that

00:42:56.815 --> 00:42:58.480
and we say, oh, it's going
to take a year.

00:42:58.480 --> 00:42:59.990
I better not even try.

00:42:59.990 --> 00:43:02.560
I better find a smarter
algorithm.

00:43:02.560 --> 00:43:05.140
Or we do it and say, well, it's
going to take almost no

00:43:05.140 --> 00:43:06.220
time at all.

00:43:06.220 --> 00:43:07.960
I'm not going to waste
my time looking

00:43:07.960 --> 00:43:09.470
for a smarter algorithm.

00:43:09.470 --> 00:43:12.950
I'm going to live with
the one I've got.

00:43:12.950 --> 00:43:15.530
It's important, and again, as
I said, it's a topic we're

00:43:15.530 --> 00:43:17.720
going to get back to.

00:43:17.720 --> 00:43:21.260
Of course, whether it's
26, 27, or even 50

00:43:21.260 --> 00:43:23.020
doesn't really matter.

00:43:23.020 --> 00:43:26.160
What matters is it's
not a billion.

00:43:26.160 --> 00:43:26.710
Right?

00:43:26.710 --> 00:43:29.640
Because we don't really care
small differences.

00:43:29.640 --> 00:43:32.730
Whether it takes 25 or it
takes 50 will be an

00:43:32.730 --> 00:43:35.140
imperceptible difference.

00:43:35.140 --> 00:43:38.110
It's whether it's a huge
difference that matters.

00:43:38.110 --> 00:43:42.450
And that's really the kind of
things we're going after is

00:43:42.450 --> 00:43:45.530
orders of magnitude.

00:43:45.530 --> 00:43:49.810
Now, I have a question
about this program.

00:43:49.810 --> 00:43:52.330
I've been obsessing about
whether it's fast enough.

00:43:52.330 --> 00:43:54.250
And we've shown it is.

00:43:54.250 --> 00:43:55.980
But does it work?

00:43:55.980 --> 00:43:57.550
Kind of more important.

00:43:57.550 --> 00:44:00.300
It's always possible to write
a really fast program that

00:44:00.300 --> 00:44:02.770
gives you the wrong answer.

00:44:02.770 --> 00:44:04.790
The problem is to write a fast
program that give you the

00:44:04.790 --> 00:44:06.530
right answer.

00:44:06.530 --> 00:44:10.140
Does this program always work?

00:44:10.140 --> 00:44:11.590
Well, it worked for 25.

00:44:11.590 --> 00:44:15.010
It worked for 12345.

00:44:15.010 --> 00:44:16.750
Is that good enough?

00:44:16.750 --> 00:44:17.560
Probably not.

00:44:17.560 --> 00:44:21.360
We might want to try it
in some other values.

00:44:21.360 --> 00:44:23.040
I'll ask a simpler question.

00:44:23.040 --> 00:44:27.215
Does it always work on
positive values?

00:44:34.110 --> 00:44:34.440
All right.

00:44:34.440 --> 00:44:35.680
I'll give you a hint.

00:44:35.680 --> 00:44:37.370
No.

00:44:37.370 --> 00:44:38.620
It does not.

00:44:40.820 --> 00:44:44.190
I'm not going to, however,
tell you why it doesn't,

00:44:44.190 --> 00:44:46.040
because I want you to
think about it.

00:44:46.040 --> 00:44:47.690
And I want you to
tell me why it

00:44:47.690 --> 00:44:49.850
doesn't in the next lecture.

00:44:49.850 --> 00:44:55.810
But because I'm not a complete
sadist, I'll give you a hint.

00:44:55.810 --> 00:45:01.190
When we use bisection search, or
for that matter, any search

00:45:01.190 --> 00:45:08.630
method, we are depending upon
the fact that the answer lies

00:45:08.630 --> 00:45:10.470
somewhere in the region
we're searching.

00:45:13.840 --> 00:45:20.190
If indeed the answer is out
here or out here, then it

00:45:20.190 --> 00:45:24.670
doesn't matter how carefully
I search this region.

00:45:24.670 --> 00:45:26.130
I'm not going to find
the answer.

00:45:28.910 --> 00:45:35.260
And so this program doesn't work
on some potential values

00:45:35.260 --> 00:45:40.250
of x because the actual square
root of x will not lie in the

00:45:40.250 --> 00:45:44.000
region that the program
is searching.

00:45:44.000 --> 00:45:47.790
I leave it to you to think about
what such values are.

00:45:47.790 --> 00:45:52.540
And we can talk about that
on the next lecture.

00:45:55.440 --> 00:45:59.420
Suppose I want to use this
program to find the cube root.

00:45:59.420 --> 00:46:01.180
Suppose it worked, and
I want it to use it

00:46:01.180 --> 00:46:03.150
to find a cube root.

00:46:03.150 --> 00:46:04.170
What would I have to change?

00:46:04.170 --> 00:46:06.890
How would I change it, so it
found cube roots instead of

00:46:06.890 --> 00:46:08.140
square roots?

00:46:11.370 --> 00:46:12.740
Well, I can take it up.

00:46:12.740 --> 00:46:17.060
I could use cut and paste, and
paste it into my editor and

00:46:17.060 --> 00:46:18.670
get a new program.

00:46:18.670 --> 00:46:20.570
And how would I change
that new program to

00:46:20.570 --> 00:46:21.820
make it do cube roots?

00:46:24.480 --> 00:46:27.270
Not very hard.

00:46:27.270 --> 00:46:29.235
Think only two places
have to get changed.

00:46:33.150 --> 00:46:34.940
That's for the simplicity,
say cube

00:46:34.940 --> 00:46:36.305
roots of positive numbers.

00:46:43.220 --> 00:46:46.590
I think you said the
right thing.

00:46:46.590 --> 00:46:52.270
All I have to do is change that
two to a three and that

00:46:52.270 --> 00:46:56.220
two to a three, and I'm done.

00:46:56.220 --> 00:46:59.450
And I should probably change the
message to say cube root.

00:47:02.740 --> 00:47:03.990
Pretty easy.

00:47:06.550 --> 00:47:11.690
On the other hand, suppose I
also want it to find the

00:47:11.690 --> 00:47:15.150
fourth root, and the fifth
root, and the sixth root,

00:47:15.150 --> 00:47:17.180
however many roots.

00:47:17.180 --> 00:47:19.900
Well, I'm going to get pretty
tired of cutting, and pasting,

00:47:19.900 --> 00:47:23.790
and building a whole
bunch of things.

00:47:23.790 --> 00:47:27.590
So really, what I want to do
is find a way to write the

00:47:27.590 --> 00:47:35.100
code that will find the nth root
of a number for any n.

00:47:38.180 --> 00:47:42.270
To do that, I'm going
to introduce a

00:47:42.270 --> 00:47:44.690
new programming concept.

00:47:44.690 --> 00:47:47.670
And that concept is
the function.

00:47:47.670 --> 00:47:50.570
And that will be the main topic
of Thursday's lecture.