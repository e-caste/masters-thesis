WEBVTT

00:00:00.090 --> 00:00:02.500
The following content is
provided under a Creative

00:00:02.500 --> 00:00:04.019
Commons license.

00:00:04.019 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.730
continue to offer high-quality
educational resources for free.

00:00:10.730 --> 00:00:13.340
To make a donation or
view additional materials

00:00:13.340 --> 00:00:17.217
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.217 --> 00:00:17.842
at ocw.mit.edu.

00:00:22.570 --> 00:00:23.760
PROFESSOR: Morning everyone.

00:00:23.760 --> 00:00:28.130
I hope you all had a
great spring break.

00:00:28.130 --> 00:00:33.540
And during which I hope
you can have more of 6.046.

00:00:33.540 --> 00:00:37.484
Today we're going to look at
network flow and two things

00:00:37.484 --> 00:00:38.150
in network flow.

00:00:44.360 --> 00:00:49.370
The first one is
Edmonds-Karp algorithm,

00:00:49.370 --> 00:00:55.380
and after that, we're going
to look at two applications.

00:00:55.380 --> 00:01:04.660
In particular, they are called
bipartite matching and cover.

00:01:09.160 --> 00:01:10.010
OK.

00:01:10.010 --> 00:01:16.101
So we'll start with
a simpler algorithm,

00:01:16.101 --> 00:01:17.100
which is Ford-Fulkerson.

00:01:24.810 --> 00:01:28.520
Can someone remind us
what Ford-Fulkerson does?

00:01:40.970 --> 00:01:41.966
Go ahead.

00:01:41.966 --> 00:01:44.456
AUDIENCE: Every time you
have a augmenting path,

00:01:44.456 --> 00:01:46.470
it gets rid of it.

00:01:46.470 --> 00:01:47.860
PROFESSOR: It gets rid of it?

00:01:47.860 --> 00:01:49.102
Yep.

00:01:49.102 --> 00:01:50.310
What's your name, by the way?

00:01:50.310 --> 00:01:51.298
AUDIENCE: Michelle.

00:01:51.298 --> 00:01:52.780
PROFESSOR: Michelle.

00:01:52.780 --> 00:01:53.610
OK.

00:01:53.610 --> 00:01:56.600
So, Michelle gave a
very brief description.

00:01:56.600 --> 00:01:58.880
But let's be a little
bit more detailed.

00:01:58.880 --> 00:02:02.780
So we have a graph
network flow G,

00:02:02.780 --> 00:02:06.440
and the first thing it's going
to do is that given the flow,

00:02:06.440 --> 00:02:10.660
it will transform G
from a residual graph.

00:02:10.660 --> 00:02:12.510
Everyone remembers that?

00:02:12.510 --> 00:02:22.720
Then F-F algorithm will find
a path going from source

00:02:22.720 --> 00:02:38.060
to sink in this residual graph,
and then augment this path.

00:02:42.430 --> 00:02:46.360
Augmenting just means increasing
the flow on that path.

00:02:46.360 --> 00:02:49.485
By how much?

00:02:49.485 --> 00:02:53.850
AUDIENCE: The minimum edge
on the path [INAUDIBLE].

00:02:53.850 --> 00:02:56.480
PROFESSOR: Yeah, the
minimum edge on the path.

00:02:56.480 --> 00:02:59.980
Let me just define that to be
the capacity of the path, which

00:02:59.980 --> 00:03:03.570
is the capacity of
the weakest link.

00:03:03.570 --> 00:03:04.200
OK.

00:03:04.200 --> 00:03:08.060
Then what's the last
step we're missing here?

00:03:16.230 --> 00:03:24.610
So after augmenting, our flow
changed from f to f prime.

00:03:24.610 --> 00:03:28.260
And then we're
going to look back.

00:03:28.260 --> 00:03:31.970
We have f prime, then Gf
prime, find a path in Gf prime,

00:03:31.970 --> 00:03:34.445
then continue from there.

00:03:37.200 --> 00:03:39.900
So this algorithm,
in some sense,

00:03:39.900 --> 00:03:42.190
is not even a very
detailed algorithm,

00:03:42.190 --> 00:03:47.120
because it doesn't say how to
find a path in the second step.

00:03:49.815 --> 00:03:51.440
And that's indeed a
problem, because we

00:03:51.440 --> 00:04:06.300
have seen a pathologically bad
case where each capacity is

00:04:06.300 --> 00:04:11.760
a billion, and the correct way
to do it is simply augmenting

00:04:11.760 --> 00:04:13.540
this path and then
that path-- oh sorry,

00:04:13.540 --> 00:04:16.790
there's edge one--
then we'll be done.

00:04:16.790 --> 00:04:20.980
But the pathologically
bad case is we keep

00:04:20.980 --> 00:04:24.322
going through this middle edge.

00:04:24.322 --> 00:04:24.822
OK.

00:04:24.822 --> 00:04:29.560
So Edmonds-Karp is an
improvement to this algorithm.

00:04:32.520 --> 00:04:33.716
Let me just write it here.

00:04:42.700 --> 00:04:44.850
Its first step, third,
and fourth steps

00:04:44.850 --> 00:04:46.230
are actually exactly the same.

00:04:46.230 --> 00:04:48.980
No change from Ford-Fulkerson.

00:04:48.980 --> 00:04:54.610
The only thing it does is
that it finds a special path.

00:04:54.610 --> 00:04:58.150
Did Srini cover
this in the lecture?

00:04:58.150 --> 00:05:02.717
What path Edmonds-Karp finds?

00:05:02.717 --> 00:05:03.800
I see some people nodding.

00:05:03.800 --> 00:05:04.060
OK.

00:05:04.060 --> 00:05:04.560
Go ahead.

00:05:04.560 --> 00:05:08.300
AUDIENCE: He ran the first
search from the source

00:05:08.300 --> 00:05:13.150
to the sink in Gf,
take the shortest path.

00:05:13.150 --> 00:05:13.880
PROFESSOR: OK.

00:05:13.880 --> 00:05:16.690
Does everyone agree with that?

00:05:16.690 --> 00:05:19.190
So Edmonds-Karp finds
the shortest path.

00:05:23.180 --> 00:05:29.670
From-- I guess, can
you see that part?

00:05:29.670 --> 00:05:30.170
No?

00:05:30.170 --> 00:05:31.211
Oh, I'm sorry about that.

00:05:50.170 --> 00:05:53.000
Find the shortest path.

00:05:53.000 --> 00:05:56.440
Here, shortest just means
least number of hops.

00:05:56.440 --> 00:05:59.274
Here, in this
pathologically bad example,

00:05:59.274 --> 00:06:00.690
Edmonds-Karp would
do much better,

00:06:00.690 --> 00:06:05.560
because it would find this path,
instead of this weird path.

00:06:05.560 --> 00:06:08.560
Because that path,
its distance is 2,

00:06:08.560 --> 00:06:11.090
and the one going
across the middle is 3.

00:06:13.960 --> 00:06:14.460
OK.

00:06:14.460 --> 00:06:20.120
Now we're going to prove that
this algorithm runs in order

00:06:20.120 --> 00:06:20.885
VE squared.

00:06:24.580 --> 00:06:25.420
So OK.

00:06:25.420 --> 00:06:26.670
So one step back.

00:06:26.670 --> 00:06:30.150
Do we have to prove
that is correct?

00:06:30.150 --> 00:06:34.610
That it indeed finds
the maximum flow?

00:06:40.759 --> 00:06:42.604
AUDIENCE: No, you don't.

00:06:42.604 --> 00:06:43.270
PROFESSOR: Yeah.

00:06:43.270 --> 00:06:45.145
I claim I don't have to
do that, because it's

00:06:45.145 --> 00:06:46.900
the same thing as
Ford-Fulkerson.

00:06:46.900 --> 00:06:49.380
You can find any path.

00:06:49.380 --> 00:06:55.280
Now, we want to show-- we
want to bound this run time.

00:06:55.280 --> 00:06:59.170
So any idea, high-level idea,
how we're going to do that?

00:06:59.170 --> 00:07:02.430
In which several steps?

00:07:34.800 --> 00:07:35.300
OK.

00:07:35.300 --> 00:07:39.396
So, OK, a simpler question.

00:07:39.396 --> 00:07:43.220
What's the complexity of this
second step, find the shortest

00:07:43.220 --> 00:07:45.190
path from source to sink?

00:07:48.850 --> 00:07:49.810
Go ahead.

00:07:49.810 --> 00:07:51.240
AUDIENCE: OV plus E.

00:07:51.240 --> 00:07:54.280
PROFESSOR: OV plus
E. And in this case,

00:07:54.280 --> 00:08:02.310
actually, V is always less than
E, so I can simply say O of E.

00:08:02.310 --> 00:08:07.210
Now, how long does it
take to augment that path,

00:08:07.210 --> 00:08:09.332
if we have found it?

00:08:09.332 --> 00:08:11.160
AUDIENCE: O of E.

00:08:11.160 --> 00:08:13.080
PROFESSOR: O of
E. That's correct.

00:08:17.110 --> 00:08:23.650
But our claim, we can
also say it's O of V,

00:08:23.650 --> 00:08:33.159
because the shortest path
at most has three hops.

00:08:33.159 --> 00:08:37.319
And then, from f
to f prime-- OK.

00:08:37.319 --> 00:08:40.140
So I think in some sense,
these two are the same steps.

00:08:40.140 --> 00:08:43.210
Also O of V, and then
updating the rescue graph

00:08:43.210 --> 00:08:47.580
is also O of V. So one
of these iterations--

00:08:47.580 --> 00:08:52.280
each iteration takes how long?

00:08:52.280 --> 00:08:53.279
AUDIENCE: O of E.

00:08:53.279 --> 00:08:54.320
PROFESSOR: O of E. Right.

00:08:54.320 --> 00:08:59.110
This is the most expensive
step in one iteration.

00:08:59.110 --> 00:08:59.610
OK.

00:08:59.610 --> 00:09:02.452
So what else do we have
to do to prove this bound?

00:09:02.452 --> 00:09:05.310
AUDIENCE: Number of iterations.

00:09:05.310 --> 00:09:08.470
PROFESSOR: We need to show
that the number of iterations

00:09:08.470 --> 00:09:21.420
is O of V times E.
If we can show that,

00:09:21.420 --> 00:09:24.480
then we are pretty much done.

00:09:24.480 --> 00:09:24.980
OK?

00:09:34.900 --> 00:09:35.410
OK.

00:09:35.410 --> 00:09:38.000
Now, to prove that
bound, we first

00:09:38.000 --> 00:09:44.275
need a lemma, which
we call monotonic.

00:09:48.380 --> 00:10:02.640
So let me define delta f v. This
is the length of the shortest

00:10:02.640 --> 00:10:07.030
path from s, from
the source, to v,

00:10:07.030 --> 00:10:12.580
which is a node in a
graph, the length of that

00:10:12.580 --> 00:10:15.530
in rescue graph of f.

00:10:20.479 --> 00:10:21.520
Is that definition clear?

00:10:27.600 --> 00:10:38.530
And this lemma says delta
f v, for any vertex v,

00:10:38.530 --> 00:10:39.500
does not decrease.

00:10:43.780 --> 00:10:48.245
So it can only
monotonically increase.

00:10:51.396 --> 00:10:51.896
OK.

00:10:51.896 --> 00:10:53.020
We are going to prove that.

00:11:01.630 --> 00:11:04.180
So we'll prove by contradiction.

00:11:04.180 --> 00:11:05.760
Assume this is not a case.

00:11:09.310 --> 00:11:17.040
That means there is some
v that in f prime, which

00:11:17.040 --> 00:11:23.520
is the new residual
graph, its shortest

00:11:23.520 --> 00:11:26.450
path from the source in
the new residual graph

00:11:26.450 --> 00:11:30.570
is less than the old one.

00:11:30.570 --> 00:11:31.070
Right?

00:11:36.910 --> 00:11:39.236
We are going to derive
a contradiction to that.

00:11:48.590 --> 00:11:53.220
So there may be many
such vertices that drop.

00:11:53.220 --> 00:12:00.830
But if there's any,
I'm going to define v

00:12:00.830 --> 00:12:15.390
to be the one with
smallest delta in f prime.

00:12:22.030 --> 00:12:22.560
OK.

00:12:22.560 --> 00:12:23.815
Any questions about this step?

00:12:30.750 --> 00:12:35.630
So there could be like v1, v2,
v3-- that all make this happen.

00:12:35.630 --> 00:12:38.740
I'm going to choose
the one among those

00:12:38.740 --> 00:12:42.260
that has the smallest
distance from the source.

00:12:48.040 --> 00:12:48.540
OK?

00:12:51.865 --> 00:12:54.950
Now here is my source.

00:12:54.950 --> 00:13:03.475
We have a path to v
in graph Gf prime.

00:13:07.600 --> 00:13:08.100
OK.

00:13:08.100 --> 00:13:09.070
So this is a path.

00:13:09.070 --> 00:13:13.150
Then I can always
find a predecessor,

00:13:13.150 --> 00:13:14.155
which I'll call u here.

00:13:21.460 --> 00:13:23.960
If this is the
shortest path to v,

00:13:23.960 --> 00:13:34.630
what can I say about
delta of v and delta of u?

00:13:38.071 --> 00:13:39.820
What can I say about
these two quantities?

00:13:47.925 --> 00:13:50.895
AUDIENCE: Can v decrease?

00:13:50.895 --> 00:13:54.152
Can v decrease one
of them, at least?

00:13:54.152 --> 00:13:55.860
PROFESSOR: This one
is greater than that?

00:13:55.860 --> 00:13:58.859
AUDIENCE: One of them must be--

00:13:58.859 --> 00:14:00.900
PROFESSOR: One of them is
greater than the other,

00:14:00.900 --> 00:14:01.890
and that's always true, right?

00:14:01.890 --> 00:14:02.390
For any two?

00:14:06.260 --> 00:14:08.967
AUDIENCE: v is u plus 1.

00:14:08.967 --> 00:14:09.550
PROFESSOR: OK.

00:14:09.550 --> 00:14:11.910
Michelle said v is u plus 1.

00:14:11.910 --> 00:14:13.285
Does that make
sense to everyone?

00:14:21.800 --> 00:14:25.265
That's the shortest path
to v. It goes through u.

00:14:30.110 --> 00:14:30.610
OK.

00:14:30.610 --> 00:14:31.235
That's correct.

00:14:36.220 --> 00:14:39.270
So OK, maybe I wasn't
clear about that.

00:14:39.270 --> 00:14:44.120
I defined u to be v's
predecessor on the shortest

00:14:44.120 --> 00:14:46.338
path.

00:14:46.338 --> 00:14:47.790
OK?

00:14:47.790 --> 00:14:56.180
Then definitely delta f prime
of v is delta f prime u plus 1.

00:14:56.180 --> 00:14:59.500
Now, I'll use u to
be my step stone

00:14:59.500 --> 00:15:02.890
back to the original graph, f.

00:15:02.890 --> 00:15:08.080
I want to say something
about this quantity and delta

00:15:08.080 --> 00:15:10.357
u in graph f.

00:15:10.357 --> 00:15:11.440
What can I say about that?

00:15:34.340 --> 00:15:35.565
This is a tricky part.

00:15:35.565 --> 00:15:39.160
AUDIENCE: It's greater than v?

00:15:39.160 --> 00:15:41.740
PROFESSOR: This one
is greater than that?

00:15:41.740 --> 00:15:43.564
Or the entire thing
is greater than that?

00:15:47.500 --> 00:15:48.000
OK.

00:15:48.000 --> 00:15:55.270
I'm going to claim this one is
greater than delta f u plus 1.

00:15:55.270 --> 00:16:01.030
By which I'm claiming this
quantity is larger than that.

00:16:01.030 --> 00:16:05.350
Can anyone give a reason
why I can claim that?

00:16:10.650 --> 00:16:21.824
So recall how I defined v.

00:16:21.824 --> 00:16:24.449
AUDIENCE: Can you repeat
how you defined v?

00:16:24.449 --> 00:16:25.490
PROFESSOR: Good question.

00:16:25.490 --> 00:16:30.580
So v-- so there are several,
probably several v's that

00:16:30.580 --> 00:16:34.360
have delta f prime
less than delta f.

00:16:34.360 --> 00:16:43.160
I'm going to define v to be
the one with smallest delta f.

00:16:43.160 --> 00:16:47.110
Among all those nodes that have
a job in delta f, in delta.

00:16:51.990 --> 00:16:54.110
This is probably a tricky part.

00:16:54.110 --> 00:17:00.560
Then by definition, since delta
f u is less than delta f v,

00:17:00.560 --> 00:17:07.210
right, and I defined v to
be the one with the smallest

00:17:07.210 --> 00:17:09.490
delta that satisfies that.

00:17:09.490 --> 00:17:12.869
So all the u's-- so u
is a predecessor of v,

00:17:12.869 --> 00:17:19.114
so u shouldn't be one of
those nodes that have a drop

00:17:19.114 --> 00:17:21.175
in delta.

00:17:21.175 --> 00:17:24.722
So I know this is
probably a tricky part.

00:17:24.722 --> 00:17:27.720
Yeah, I'll stop for
questions and make

00:17:27.720 --> 00:17:30.430
sure we resolve this
part before we move on.

00:17:35.480 --> 00:17:38.770
How many people get it?

00:17:38.770 --> 00:17:39.270
OK.

00:17:39.270 --> 00:17:39.794
Only two.

00:17:39.794 --> 00:17:40.460
That's not good.

00:17:40.460 --> 00:17:40.960
OK.

00:17:40.960 --> 00:17:42.815
AUDIENCE: I'm
confused about how v

00:17:42.815 --> 00:17:46.115
can be the one with
the smallest delta f

00:17:46.115 --> 00:17:50.075
if you have a predecessor
with a smaller delta f.

00:17:53.527 --> 00:17:54.110
PROFESSOR: OK.

00:17:54.110 --> 00:18:00.520
So v to be the smallest--
the one with smallest

00:18:00.520 --> 00:18:08.595
f such that delta f prime
is less than delta f.

00:18:08.595 --> 00:18:09.470
AUDIENCE: OK.

00:18:09.470 --> 00:18:13.180
PROFESSOR: OK, maybe, yeah,
that's why I confused you guys.

00:18:13.180 --> 00:18:13.680
Yeah.

00:18:13.680 --> 00:18:15.550
Sorry about that.

00:18:15.550 --> 00:18:19.080
So we have a bunch of nodes
who have a drop in delta,

00:18:19.080 --> 00:18:22.900
and I defined v to be
the one among them that

00:18:22.900 --> 00:18:24.500
has the smallest delta f prime.

00:18:27.000 --> 00:18:27.500
Question?

00:18:27.500 --> 00:18:29.125
AUDIENCE: Sorry, I'm
lost at what delta

00:18:29.125 --> 00:18:31.877
f prime is versus delta.

00:18:31.877 --> 00:18:32.460
PROFESSOR: OK.

00:18:32.460 --> 00:18:37.230
Delta f of a node
is the shortest path

00:18:37.230 --> 00:18:41.440
from source to that
node in G of f,

00:18:41.440 --> 00:18:44.650
which is the residual
graph given a flow.

00:18:44.650 --> 00:18:49.140
So f is, well, some
flow, and f prime

00:18:49.140 --> 00:18:53.870
is the flow after we
augmenting a certain path.

00:18:53.870 --> 00:18:57.901
So f prime is one step after f.

00:18:57.901 --> 00:18:58.400
OK.

00:18:58.400 --> 00:19:01.780
How many people get that now?

00:19:01.780 --> 00:19:02.910
Still not everyone.

00:19:08.110 --> 00:19:08.610
OK.

00:19:08.610 --> 00:19:09.660
Any questions about that?

00:19:13.300 --> 00:19:16.200
How many people still
haven't got that?

00:19:19.200 --> 00:19:23.270
OK, so some people-- it's
like Schrodinger's cat.

00:19:23.270 --> 00:19:24.680
It's in the middle state.

00:19:34.920 --> 00:19:37.540
Well, then I'll have
to move on, and I'll

00:19:37.540 --> 00:19:40.170
assume you all get that one.

00:19:44.570 --> 00:19:48.610
As the last step, so
of course we will ask,

00:19:48.610 --> 00:19:53.530
what's the relation between
this guy and delta f of v?

00:19:56.100 --> 00:19:59.280
Because in the end, we want
to show a contradiction

00:19:59.280 --> 00:20:02.180
that delta f v is
probably greater or equal

00:20:02.180 --> 00:20:07.524
to delta f of v. OK.

00:20:07.524 --> 00:20:08.690
This is another tricky part.

00:20:13.195 --> 00:20:16.580
So let me ask maybe a
simpler question now.

00:20:16.580 --> 00:20:19.840
So that is our G of f prime.

00:20:19.840 --> 00:20:21.500
So we also have G of f.

00:20:21.500 --> 00:20:28.265
It has the source, some u
here, v there, sink there.

00:20:31.630 --> 00:20:35.940
Does this edge
exist in this graph?

00:20:38.470 --> 00:20:41.530
So I know if that edge
exists, because I defined u

00:20:41.530 --> 00:20:45.555
to be the predecessor
of v. But u,

00:20:45.555 --> 00:20:48.315
v is in that graph doesn't
necessarily mean u,

00:20:48.315 --> 00:20:49.810
v is in the old graph.

00:20:53.410 --> 00:20:55.940
It could certainly
exist, but is it possible

00:20:55.940 --> 00:20:59.550
that this edge didn't exist?

00:21:02.080 --> 00:21:07.410
How many people would say
that edge definitely exists?

00:21:10.050 --> 00:21:13.045
How many people would say
maybe it doesn't exist?

00:21:23.320 --> 00:21:23.830
OK.

00:21:23.830 --> 00:21:26.910
It doesn't matter, because
we can prove both cases.

00:21:26.910 --> 00:21:35.480
So let's say case
one, u, v is indeed

00:21:35.480 --> 00:21:38.402
in the original graph, G of f.

00:21:38.402 --> 00:21:38.901
OK.

00:21:38.901 --> 00:21:41.620
In that case, can I say
something about that last step?

00:21:58.945 --> 00:22:03.430
AUDIENCE: It's greater
or equal to delta f v.

00:22:03.430 --> 00:22:09.590
PROFESSOR: Greater or
equal to delta v. OK.

00:22:09.590 --> 00:22:10.940
Why is that?

00:22:10.940 --> 00:22:17.417
AUDIENCE: Because v was
on the shortest path.

00:22:17.417 --> 00:22:19.349
Well-- yeah.

00:22:19.349 --> 00:22:25.708
So the shortest path, either
passed through-- yeah.

00:22:25.708 --> 00:22:28.850
The shortest path to v either
passed through u or didn't.

00:22:28.850 --> 00:22:30.310
PROFESSOR: Correct.

00:22:30.310 --> 00:22:31.370
Does everyone get that?

00:22:31.370 --> 00:22:34.490
So the shortest path
in this graph to v

00:22:34.490 --> 00:22:37.890
is not necessarily
this one, right?

00:22:37.890 --> 00:22:41.430
But if it's some other
one-- OK, so, in case one

00:22:41.430 --> 00:22:45.449
I'm assuming this
edge exists, right?

00:22:45.449 --> 00:22:46.990
Then no matter what
the shortest path

00:22:46.990 --> 00:22:51.430
is, it's definitely shorter
than I first go to-- from s to u

00:22:51.430 --> 00:22:54.650
and then u to v. Right?

00:22:54.650 --> 00:22:58.580
The shortest path between s
to v is definitely shorter

00:22:58.580 --> 00:23:06.180
than I first go from s to u
and then u to v. Make sense?

00:23:06.180 --> 00:23:06.680
OK.

00:23:06.680 --> 00:23:12.310
So case one, then,
is a contradiction,

00:23:12.310 --> 00:23:14.680
because we showed that
delta f prime of v

00:23:14.680 --> 00:23:22.410
is greater or equal to delta f
of v. Any questions about that?

00:23:27.180 --> 00:23:27.680
OK.

00:23:27.680 --> 00:23:37.230
Case two, u, v is not in Gf.

00:23:37.230 --> 00:23:41.070
OK, so, how can
that even happen?

00:23:41.070 --> 00:23:48.760
Is it possible that
this edge didn't exist?

00:23:55.662 --> 00:23:59.113
AUDIENCE: It could be
a backwards-facing edge

00:23:59.113 --> 00:24:04.102
that you add [INAUDIBLE].

00:24:04.102 --> 00:24:05.060
PROFESSOR: Great point.

00:24:05.060 --> 00:24:06.620
That's exactly right.

00:24:06.620 --> 00:24:12.470
So it is possible that this edge
didn't exist, but only appeared

00:24:12.470 --> 00:24:15.360
after we go from f to f prime.

00:24:15.360 --> 00:24:16.870
How can that happen?

00:24:16.870 --> 00:24:21.240
That must mean we are
augmenting a path that

00:24:21.240 --> 00:24:22.621
goes right through it.

00:24:22.621 --> 00:24:23.120
Right?

00:24:23.120 --> 00:24:26.080
But this edge doesn't exist, so
we cannot be augmenting a path

00:24:26.080 --> 00:24:28.210
that crosses this way.

00:24:28.210 --> 00:24:35.990
We must be augmenting a
path that goes like that.

00:24:35.990 --> 00:24:43.910
First from s to v, and then
v to u, and then u to t.

00:24:43.910 --> 00:24:47.270
If we are augmenting
such a path,

00:24:47.270 --> 00:24:52.460
then we're going to remove
this edge from v to u,

00:24:52.460 --> 00:24:57.420
but we will add u to
v to the next graph.

00:25:01.810 --> 00:25:02.310
OK?

00:25:08.563 --> 00:25:09.880
Did everyone get that?

00:25:22.510 --> 00:25:25.570
So now, here--
well, formally I'm

00:25:25.570 --> 00:25:29.540
going to claim if we assume
u, v is not in G of f,

00:25:29.540 --> 00:25:35.640
and we also know u,
v is in Gf prime.

00:25:35.640 --> 00:25:37.260
What does that mean?

00:25:37.260 --> 00:25:43.280
These two can only
be caused by the fact

00:25:43.280 --> 00:25:49.500
that u, v is in G of f.

00:25:49.500 --> 00:25:56.060
Not only in that graph--
it must be on the path

00:25:56.060 --> 00:25:56.870
we are augmenting.

00:26:05.520 --> 00:26:06.020
Make sense?

00:26:16.700 --> 00:26:17.200
OK.

00:26:17.200 --> 00:26:22.130
So given that, can we say
something about delta f

00:26:22.130 --> 00:26:24.040
of u and delta f of v?

00:26:33.520 --> 00:26:36.375
So here is our p.

00:26:36.375 --> 00:26:38.690
Right?

00:26:38.690 --> 00:26:39.660
This entire thing here.

00:26:48.180 --> 00:26:53.112
And p is the augmenting path.

00:26:53.112 --> 00:26:56.521
AUDIENCE: And f u
is just f v plus 1.

00:26:56.521 --> 00:26:57.312
PROFESSOR: Correct.

00:26:57.312 --> 00:26:57.812
Right.

00:26:57.812 --> 00:27:02.300
So if that is the augmenting
path in Edmonds-Karp,

00:27:02.300 --> 00:27:04.030
we are looking for
the shortest path.

00:27:04.030 --> 00:27:05.640
Right?

00:27:05.640 --> 00:27:12.240
So v is the predecessor
of u, then delta of u

00:27:12.240 --> 00:27:14.370
is delta of v plus 1.

00:27:14.370 --> 00:27:26.680
That means that quantity,
here, is delta f of v plus 2.

00:27:31.110 --> 00:27:31.610
OK?

00:27:44.440 --> 00:27:49.320
So it's also a contradiction
to what we assumed.

00:28:02.360 --> 00:28:02.860
OK.

00:28:02.860 --> 00:28:07.100
So that proves our
lemma of every node's

00:28:07.100 --> 00:28:10.156
delta monotonically increases.

00:28:10.156 --> 00:28:15.740
Now here, I'm going to show
that-- our final theorem,

00:28:15.740 --> 00:28:20.365
that we have at most VE
number of iterations.

00:28:27.290 --> 00:28:35.595
So the way we're going
to show that is we

00:28:35.595 --> 00:28:40.530
are going to define a
capacity of the path.

00:28:40.530 --> 00:28:42.790
It must be the capacity
of its weakest link.

00:28:42.790 --> 00:28:48.780
We're going to define its
weakest link is u, v. OK?

00:28:48.780 --> 00:28:52.810
And we're going to
show that u, v--

00:28:52.810 --> 00:28:58.265
we'll call that critical
edge-- we're going to show u,

00:28:58.265 --> 00:29:08.840
v can be critical
only O of V times.

00:29:08.840 --> 00:29:11.710
If that holds for
every edge, then I

00:29:11.710 --> 00:29:15.320
claim all the edges
combined can only

00:29:15.320 --> 00:29:17.790
be augmented O of VE times.

00:29:28.580 --> 00:29:33.270
Now, how do we show that?

00:29:33.270 --> 00:29:39.975
So again, let's assume
we are augmenting

00:29:39.975 --> 00:29:46.890
a path that goes
through u to v. If we

00:29:46.890 --> 00:29:52.490
do that, by our algorithm,
we will get rid of this path,

00:29:52.490 --> 00:29:57.570
and have an edge backwards.

00:29:57.570 --> 00:30:01.140
We go from f to
some other f prime.

00:30:03.730 --> 00:30:07.140
Now, when can I
augment u, v again?

00:30:10.490 --> 00:30:13.910
It can only happen
if at some point,

00:30:13.910 --> 00:30:19.690
I come back to augment the path
going from v to u, because that

00:30:19.690 --> 00:30:29.930
will eliminate this back
edge, and and adds back

00:30:29.930 --> 00:30:34.710
our edge u, v. OK.

00:30:34.710 --> 00:30:36.815
Let's see what happens there.

00:30:40.840 --> 00:30:44.915
Now I'll call this graph
f, this graph f prime.

00:30:50.100 --> 00:30:54.130
So in f prime, we know we are
augmenting the path from v

00:30:54.130 --> 00:30:54.821
to u.

00:30:54.821 --> 00:30:55.320
Right.

00:30:55.320 --> 00:31:02.800
The same argument, delta u,
is delta v plus 1 in f prime.

00:31:02.800 --> 00:31:03.300
Correct?

00:31:05.910 --> 00:31:08.980
And we know this one
doesn't drop, right?

00:31:08.980 --> 00:31:16.050
So it's greater or equal
than delta f of v plus 1.

00:31:16.050 --> 00:31:18.110
OK?

00:31:18.110 --> 00:31:22.210
And we also know in f, v
is the predecessor of u.

00:31:24.820 --> 00:31:34.080
So this one is equal
to delta f of u plus 2.

00:31:34.080 --> 00:31:35.100
What does that mean?

00:31:35.100 --> 00:31:45.550
It means in between two times
u, v is augmented, delta of u

00:31:45.550 --> 00:31:47.200
must increase by at least 2.

00:31:53.210 --> 00:31:58.210
Then how large can delta of
a certain node possibly be?

00:31:58.210 --> 00:32:02.240
It's definitely
bounded by v. So then I

00:32:02.240 --> 00:32:06.080
claim this particular edge,
u, v, can only be involved,

00:32:06.080 --> 00:32:10.030
can only be critical
edge, O of V times.

00:32:10.030 --> 00:32:12.320
Actually, half of V times.

00:32:12.320 --> 00:32:13.860
Strictly.

00:32:13.860 --> 00:32:16.610
So then, every edge
combined, there

00:32:16.610 --> 00:32:22.445
can only be half of V times
E number of augmentations.

00:32:30.660 --> 00:32:31.160
OK.

00:32:31.160 --> 00:32:32.420
Any questions about that part?

00:32:32.420 --> 00:32:33.500
About the entire proof?

00:33:11.044 --> 00:33:11.960
If not, we'll move on.

00:33:19.490 --> 00:33:19.990
OK.

00:33:19.990 --> 00:33:22.780
This is not part of the
required in the recitation,

00:33:22.780 --> 00:33:27.040
but I'll quickly say a few words
about an even better algorithm,

00:33:27.040 --> 00:33:34.290
Dinic, which was in O
of V squared times E.

00:33:34.290 --> 00:33:37.190
So this is an improvement
to Edmonds-Karp,

00:33:37.190 --> 00:33:46.260
and its idea is that I'm
going to find all the shortest

00:33:46.260 --> 00:33:50.050
paths in one go from s to t.

00:33:53.310 --> 00:33:57.320
I'm going to augment all
of them at the same time.

00:34:00.150 --> 00:34:03.900
Then, because they are all
shortest paths, when I augment

00:34:03.900 --> 00:34:06.580
that, each path will be broken.

00:34:06.580 --> 00:34:10.050
Maybe I'll get rid of this
edge, this edge, and that edge.

00:34:10.050 --> 00:34:15.540
And the thesis is that the
shortest path will increase.

00:34:15.540 --> 00:34:17.650
So here, the shortest
path is 3, but I

00:34:17.650 --> 00:34:20.230
have destroyed all the
shortest path of length 3,

00:34:20.230 --> 00:34:23.650
so I'm going to
shortest path of 4.

00:34:23.650 --> 00:34:26.469
If they do that, you can
bound the number of iterations

00:34:26.469 --> 00:34:30.409
to O of V, because your
shortest path can be,

00:34:30.409 --> 00:34:35.179
at most, V. But each iteration
is slightly more complicated,

00:34:35.179 --> 00:34:37.515
because you need to find
all the shortest paths,

00:34:37.515 --> 00:34:39.344
and it happens that
they can show-- you

00:34:39.344 --> 00:34:42.830
can find it in V times E.
That gives the V square of E.

00:34:42.830 --> 00:34:44.757
That's not the important part.

00:34:44.757 --> 00:34:46.590
The more interesting
part is that, actually,

00:34:46.590 --> 00:34:53.658
the author of this algorithm,
his name is Dinitz.

00:34:53.658 --> 00:34:58.006
But his algorithm is
very hard to understand.

00:34:58.006 --> 00:34:59.610
Yeah, nobody got that.

00:34:59.610 --> 00:35:05.000
And there's some other guy
whose name I think is Even.

00:35:05.000 --> 00:35:08.290
He understood the problem and
started advertising to people

00:35:08.290 --> 00:35:12.290
and giving lectures
on Dinitz's algorithm.

00:35:12.290 --> 00:35:15.600
So he popularized the
algorithm, but unfortunately he

00:35:15.600 --> 00:35:17.900
got the name of
the author wrong.

00:35:17.900 --> 00:35:19.900
So that's why this
algorithm is henceforth

00:35:19.900 --> 00:35:22.660
called Dinic's algorithm.

00:35:22.660 --> 00:35:24.330
This is useful to know.

00:35:24.330 --> 00:35:25.370
Why?

00:35:25.370 --> 00:35:28.180
Because you can tell this story
to other people so they will

00:35:28.180 --> 00:35:30.520
assume that you know a lot
about Dinic's algorithm,

00:35:30.520 --> 00:35:32.396
while in fact, you
probably don't.

00:35:32.396 --> 00:35:34.020
And that's exactly
what I'm doing here.

00:35:37.611 --> 00:35:38.110
OK.

00:35:42.374 --> 00:35:43.790
Now let's look at
one application.

00:35:50.690 --> 00:35:53.574
Bipartite matching.

00:35:58.141 --> 00:35:58.640
OK.

00:35:58.640 --> 00:36:04.740
So the problem is that
we have several person

00:36:04.740 --> 00:36:07.300
and several tasks.

00:36:07.300 --> 00:36:08.675
And let me get
rid of one person,

00:36:08.675 --> 00:36:11.440
because I don't want to
draw that many stuff.

00:36:11.440 --> 00:36:15.350
So we have a graph like that.

00:36:15.350 --> 00:36:19.210
And each edge-- if
there is an edge, that

00:36:19.210 --> 00:36:22.680
means this person is capable
of performing that task.

00:36:26.030 --> 00:36:29.310
And the problem is that--
find the matching, which

00:36:29.310 --> 00:36:33.660
means the assignment
from people to tasks,

00:36:33.660 --> 00:36:37.830
such that we get as many
tasks done as possible.

00:36:37.830 --> 00:36:38.330
OK?

00:36:38.330 --> 00:36:40.130
So one person can
only do one task,

00:36:40.130 --> 00:36:42.720
and one task only
needs one person.

00:36:42.720 --> 00:36:45.310
So here you can see
a bad matching, which

00:36:45.310 --> 00:36:50.100
is I assign this
first guy to task one,

00:36:50.100 --> 00:36:54.260
then no one can do task two.

00:36:54.260 --> 00:36:58.210
So if I'm smarter, I'll assign
one of these guys to that task

00:36:58.210 --> 00:37:01.790
and have this person
handle the other task.

00:37:01.790 --> 00:37:02.715
Is the problem clear?

00:37:06.040 --> 00:37:10.610
So this is called bipartite
graph, because-- well,

00:37:10.610 --> 00:37:13.540
which means you can partition
a graph into two parts,

00:37:13.540 --> 00:37:16.340
and within each part,
there's no edge connecting

00:37:16.340 --> 00:37:18.470
any pair of vertices.

00:37:18.470 --> 00:37:22.690
And you can also define this
problem for a general graph.

00:37:27.650 --> 00:37:29.300
The goal is the same.

00:37:29.300 --> 00:37:38.870
Find a subset of edges
such that no two edges are

00:37:38.870 --> 00:37:44.180
connected to the same vertex.

00:37:44.180 --> 00:37:49.340
But we are going to
look at bipartite graph.

00:37:49.340 --> 00:37:52.160
And we claim in
bipartite graph, this

00:37:52.160 --> 00:37:53.975
can be solved using max flow.

00:37:57.791 --> 00:37:58.290
OK.

00:37:58.290 --> 00:38:01.240
I'll give you one minute
to think about that, how

00:38:01.240 --> 00:38:04.635
to transform that problem
to a max flow problem.

00:39:01.210 --> 00:39:01.810
Any ideas?

00:39:51.911 --> 00:39:52.410
OK.

00:39:52.410 --> 00:39:53.770
A hint.

00:39:53.770 --> 00:39:59.384
I will add the source
here, and the sink there,

00:39:59.384 --> 00:40:00.800
and I'll have
created these edges.

00:40:05.570 --> 00:40:06.070
OK.

00:40:06.070 --> 00:40:08.830
How do I restrict the
capacity of all the edges

00:40:08.830 --> 00:40:17.120
such that I can guarantee no
person is taking two tasks,

00:40:17.120 --> 00:40:18.960
and no task is
assigned to two people?

00:40:26.880 --> 00:40:29.360
AUDIENCE: Make all
of them weight 1.

00:40:29.360 --> 00:40:31.959
PROFESSOR: Make all
of them weight 1.

00:40:31.959 --> 00:40:32.458
OK.

00:40:32.458 --> 00:40:32.999
You're right.

00:40:32.999 --> 00:40:36.920
We do that-- 1, 1, 1, 1,
1, and everything here

00:40:36.920 --> 00:40:40.910
is weight 1, then that's
definitely correct.

00:40:40.910 --> 00:40:41.922
What's your name?

00:40:41.922 --> 00:40:42.630
AUDIENCE: Calvin.

00:40:42.630 --> 00:40:43.640
PROFESSOR: Calvin?

00:40:43.640 --> 00:40:46.200
OK.

00:40:46.200 --> 00:40:49.810
If we do that, then, well,
because each person only

00:40:49.810 --> 00:40:54.080
has one incoming edge--
oh, sorry, maybe I

00:40:54.080 --> 00:40:56.294
should have drawn
the arrows here.

00:40:59.230 --> 00:41:00.920
Each person only has
one incoming edge,

00:41:00.920 --> 00:41:05.290
so it cannot take care of
two tasks at the same time.

00:41:05.290 --> 00:41:06.050
Right?

00:41:06.050 --> 00:41:08.890
Same thing for each task.

00:41:08.890 --> 00:41:12.520
It only has one outgoing edge,
so it cannot be taken care

00:41:12.520 --> 00:41:13.774
of by multiple people.

00:41:18.345 --> 00:41:18.845
OK.

00:41:18.845 --> 00:41:21.990
So if we find--
if the max flow is

00:41:21.990 --> 00:41:34.740
k, that means we can find
the max matching is also k.

00:41:34.740 --> 00:41:38.390
We can get k tasks done.

00:41:38.390 --> 00:41:42.990
It's very easy to see because
we can have a cut here,

00:41:42.990 --> 00:41:47.580
and if the max flow is
k, that clearly k tasks

00:41:47.580 --> 00:41:48.370
are taken care of.

00:41:53.562 --> 00:41:54.259
OK.

00:41:54.259 --> 00:41:55.300
Any questions about that?

00:41:59.616 --> 00:42:01.240
AUDIENCE: So, the
question is can we do

00:42:01.240 --> 00:42:04.210
all the assignment [INAUDIBLE]?

00:42:04.210 --> 00:42:07.390
PROFESSOR: Find an assignment
from people to tasks

00:42:07.390 --> 00:42:09.830
to get as many tasks
done as possible.

00:42:09.830 --> 00:42:13.550
So how many tasks can we handle?

00:42:17.621 --> 00:42:18.120
OK.

00:42:18.120 --> 00:42:23.310
So I'm doing a different topic
from the recitation notes.

00:42:23.310 --> 00:42:29.030
In the recitation notes, we
are considering another problem

00:42:29.030 --> 00:42:34.920
called bipartite cover, which is
exactly the same thing as that.

00:42:38.790 --> 00:42:41.990
So cover, also,
bipartite graph, is

00:42:41.990 --> 00:42:50.500
defined too as, let's find
several vertices in this graph

00:42:50.500 --> 00:42:56.060
such that each
node, at least-- OK,

00:42:56.060 --> 00:43:00.140
let me color several
nodes in this graph-- such

00:43:00.140 --> 00:43:04.990
that each edge is connected
to at least one dark node.

00:43:07.890 --> 00:43:08.390
OK.

00:43:08.390 --> 00:43:11.210
And this, the nodes I
colored, is called a cover.

00:43:11.210 --> 00:43:14.750
I want to find a minimum cover.

00:43:14.750 --> 00:43:19.070
You can of course cover all the
nodes, that trivially holds,

00:43:19.070 --> 00:43:20.850
but we are looking
for the minimum cover.

00:43:20.850 --> 00:43:28.890
And the claim is that min
cover is k if and only

00:43:28.890 --> 00:43:43.270
if max flow-- sorry,
max matching-- is k.

00:43:43.270 --> 00:43:44.610
Why is that?

00:43:44.610 --> 00:43:50.680
Because in that matching--
if we have a matching,

00:43:50.680 --> 00:43:55.713
then we have a set of
disjointed edges, right?

00:43:55.713 --> 00:43:59.040
No two edges are connected
to the same node.

00:43:59.040 --> 00:44:02.460
So if we want to
cover these edges,

00:44:02.460 --> 00:44:07.570
we at least have to add
one of these guys-- color

00:44:07.570 --> 00:44:10.070
one of these two,
and one of these two.

00:44:10.070 --> 00:44:10.750
Right?

00:44:10.750 --> 00:44:14.870
So if we have k matching
edges, then we at least

00:44:14.870 --> 00:44:17.408
need k nodes to cover them.

00:44:20.280 --> 00:44:22.920
For example, I can
cover them like that.

00:44:28.280 --> 00:44:31.770
But this is not
foolproof, because I also

00:44:31.770 --> 00:44:36.537
need to show I can indeed
find a cover that is k.

00:44:45.110 --> 00:44:45.610
OK.

00:44:45.610 --> 00:44:48.918
Let me think about whether
I should prove that.

00:44:54.396 --> 00:44:54.900
OK.

00:44:54.900 --> 00:44:56.850
I'm going to give it a try.

00:44:56.850 --> 00:45:00.365
If you don't get
that, that's fine.

00:45:00.365 --> 00:45:02.947
AUDIENCE: Can you say
again what cover is?

00:45:02.947 --> 00:45:03.530
PROFESSOR: OK.

00:45:03.530 --> 00:45:04.030
Cover--

00:45:04.030 --> 00:45:05.210
AUDIENCE: [INAUDIBLE]?

00:45:05.210 --> 00:45:07.990
PROFESSOR: Cover is
a set of nodes such

00:45:07.990 --> 00:45:13.720
that every edge in the graph
is connected to at least one

00:45:13.720 --> 00:45:16.810
of the nodes, in a cover.

00:45:16.810 --> 00:45:17.310
OK?

00:45:17.310 --> 00:45:20.765
So this is not a cover, because
this edge is not covered.

00:45:26.090 --> 00:45:29.940
So in this case I probably
have to add that as well.

00:45:29.940 --> 00:45:33.570
But clearly there's a better
cover, even a smaller cover,

00:45:33.570 --> 00:45:36.199
which is those two.

00:45:36.199 --> 00:45:36.698
Right?

00:45:36.698 --> 00:45:37.197
Yeah.

00:45:40.440 --> 00:45:44.420
So how are we going to transform
that matching to cover?

00:45:44.420 --> 00:45:47.400
So let me first give
a matching here.

00:45:47.400 --> 00:45:51.950
One max matching should
be something like this.

00:45:51.950 --> 00:45:55.470
I have this edge and
one of those two.

00:45:59.640 --> 00:46:01.340
That is a matching.

00:46:01.340 --> 00:46:01.940
Right?

00:46:01.940 --> 00:46:03.290
That is a max matching.

00:46:08.406 --> 00:46:09.405
No questions about that?

00:46:12.810 --> 00:46:15.460
Let me get rid of all this.

00:46:15.460 --> 00:46:18.120
One way to transform
this into a cover

00:46:18.120 --> 00:46:24.230
is that I will first
color these two guys.

00:46:24.230 --> 00:46:27.140
I colored the nodes on
the left where they are

00:46:27.140 --> 00:46:30.620
connected to a matching edge.

00:46:30.620 --> 00:46:33.330
After that, I'm going
to start from this one

00:46:33.330 --> 00:46:38.790
and jump between nodes,
taking an alternating path.

00:46:38.790 --> 00:46:41.850
Meaning I'll take
an unmatched edge,

00:46:41.850 --> 00:46:45.560
and then take a matched edge,
and then take an unmatched edge

00:46:45.560 --> 00:46:47.240
again, but there's
no such thing.

00:47:04.880 --> 00:47:05.410
OK.

00:47:05.410 --> 00:47:09.670
And if I take this jump, I
will swap them, make that dark.

00:47:17.870 --> 00:47:18.370
OK.

00:47:18.370 --> 00:47:19.661
This graph is a little strange.

00:47:26.372 --> 00:47:27.530
Ah, OK.

00:47:27.530 --> 00:47:30.460
Now I claim this is a cover.

00:47:30.460 --> 00:47:31.570
Is that?

00:47:31.570 --> 00:47:32.652
Yeah, that is one, right?

00:47:35.490 --> 00:47:41.380
And if there is another
unmatched edge going out,

00:47:41.380 --> 00:47:44.160
then I'll keep taking
that alternating path.

00:47:44.160 --> 00:47:49.090
But I have to stop, because
there's no such edge anymore.

00:47:49.090 --> 00:47:51.640
How can I say-- why
I can prove-- why can

00:47:51.640 --> 00:47:55.370
I claim this is a cover?

00:47:55.370 --> 00:47:58.410
So clearly if this is a cover,
then it's a cover of size k,

00:47:58.410 --> 00:47:58.910
right?

00:47:58.910 --> 00:48:01.869
So we have proved
the entire thing.

00:48:01.869 --> 00:48:04.160
Then we're going to consider
several things separately.

00:48:09.280 --> 00:48:12.970
So I'm going to first claim
if I have a matched edge,

00:48:12.970 --> 00:48:19.410
then it's definitely covered,
because one of its end points

00:48:19.410 --> 00:48:20.750
is dark.

00:48:20.750 --> 00:48:21.250
Right.

00:48:21.250 --> 00:48:26.040
We only do a switching
between dark and white

00:48:26.040 --> 00:48:28.371
if it's a matched edge itself.

00:48:28.371 --> 00:48:28.870
Right.

00:48:28.870 --> 00:48:33.930
So I only need to show that
this thing doesn't happen.

00:48:33.930 --> 00:48:36.020
There's an edge
that's unmatched,

00:48:36.020 --> 00:48:41.590
and two of its endpoints
are both white.

00:48:41.590 --> 00:48:42.090
OK.

00:48:42.090 --> 00:48:46.740
I'm going to first claim this
node cannot have a matched

00:48:46.740 --> 00:48:48.800
edge.

00:48:48.800 --> 00:48:51.040
Because if it does, then
this is an alternating path,

00:48:51.040 --> 00:48:54.950
and I'm going to
switch this too.

00:48:54.950 --> 00:48:55.450
OK.

00:48:55.450 --> 00:48:57.660
Make sense?

00:48:57.660 --> 00:48:58.160
OK.

00:48:58.160 --> 00:49:01.100
So this doesn't exist.

00:49:01.100 --> 00:49:03.490
So it can only have
an unmatched edge.

00:49:03.490 --> 00:49:06.330
Now what can I say
about this node?

00:49:06.330 --> 00:49:12.230
I claim this node needs at least
one matched edge, because if it

00:49:12.230 --> 00:49:17.890
doesn't, right, then I should
add this guy into my matching.

00:49:17.890 --> 00:49:20.040
It doesn't violate
any constraint.

00:49:20.040 --> 00:49:23.165
I didn't add that because
there's probably a matched

00:49:23.165 --> 00:49:27.080
edge connecting to this guy.

00:49:27.080 --> 00:49:30.030
Then I'm going to--
so, then this guy

00:49:30.030 --> 00:49:33.410
has to be dark, because
this one is not.

00:49:33.410 --> 00:49:35.510
Then how did this
one become dark?

00:49:35.510 --> 00:49:38.020
It must have come from some
other guy on the left, right?

00:49:38.020 --> 00:49:40.460
So there's an alternating
path going back and forth.

00:49:48.840 --> 00:49:50.620
Something like this.

00:49:50.620 --> 00:49:54.010
There is an alternating
path, starting from left,

00:49:54.010 --> 00:49:57.070
but ends here.

00:49:57.070 --> 00:49:59.490
Because we showed that
this guy is not connecting

00:49:59.490 --> 00:50:02.080
to any matched edges.

00:50:02.080 --> 00:50:04.640
In that case, what I'm going
to do is match this edge,

00:50:04.640 --> 00:50:06.350
match this edge,
match this edge,

00:50:06.350 --> 00:50:09.230
then unmatch these two edges.

00:50:09.230 --> 00:50:13.380
And that's a larger matching.

00:50:13.380 --> 00:50:15.331
Because I removed the
two, I added three.

00:50:26.400 --> 00:50:35.720
That means a max matching of k
leads to a minimum cover of k

00:50:35.720 --> 00:50:41.284
as well, which also means max
flow of k in our network flow.

00:50:44.450 --> 00:50:46.585
So this part-- this
equivalence is not required.

00:50:50.050 --> 00:50:54.730
You should know this proof,
the proof of Edmonds-Karp,

00:50:54.730 --> 00:50:57.400
and know that a
matching and cover can

00:50:57.400 --> 00:51:01.380
be solved by network flow,
and that Dinitz's name is

00:51:01.380 --> 00:51:02.925
spelled not as Dinic.

00:51:07.601 --> 00:51:08.100
OK.

00:51:08.100 --> 00:51:11.104
And that's everything for today.