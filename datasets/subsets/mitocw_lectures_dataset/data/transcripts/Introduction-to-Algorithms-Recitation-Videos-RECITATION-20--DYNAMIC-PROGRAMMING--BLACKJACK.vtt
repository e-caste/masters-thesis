WEBVTT

00:00:00.090 --> 00:00:01.770
The following
content is provided

00:00:01.770 --> 00:00:04.000
under a Creative
Commons license.

00:00:04.000 --> 00:00:06.860
Your support will help MIT
OpenCourseWare continue

00:00:06.860 --> 00:00:10.720
to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.330
To make a donation or
view additional materials

00:00:13.330 --> 00:00:17.207
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.207 --> 00:00:17.832
at ocw.mit.edu.

00:00:21.587 --> 00:00:23.170
PROFESSOR: OK so any
pointed questions

00:00:23.170 --> 00:00:26.455
before we go over blackjack?

00:00:26.455 --> 00:00:27.955
AUDIENCE: Before
you start blackjack

00:00:27.955 --> 00:00:31.820
can you go through
the rules again?

00:00:31.820 --> 00:00:33.240
PROFESSOR: The
rules of the game?

00:00:33.240 --> 00:00:33.823
AUDIENCE: Yes.

00:00:33.823 --> 00:00:34.680
PROFESSOR: OK.

00:00:34.680 --> 00:00:36.240
Well I'm going to
do something better

00:00:36.240 --> 00:00:37.448
than going through the rules.

00:00:37.448 --> 00:00:39.060
I'm going to abstract
the rules away.

00:00:41.810 --> 00:00:47.240
So I'm going to say that
a game of blackjack has,

00:00:47.240 --> 00:00:48.300
let's start here.

00:00:53.090 --> 00:00:55.520
So a game of
blackjack has a deck.

00:00:55.520 --> 00:01:00.590
And we have x-ray vision
or some other illegal way

00:01:00.590 --> 00:01:04.640
in which we know what the deck
looks like from the beginning.

00:01:04.640 --> 00:01:06.103
How many cards in a deck?

00:01:06.103 --> 00:01:06.950
AUDIENCE: 52.

00:01:06.950 --> 00:01:08.380
PROFESSOR: OK.

00:01:08.380 --> 00:01:12.455
So say from 0 to 51 because
we like zero-based indexing.

00:01:16.510 --> 00:01:19.100
So the way that the game
starts is you get two cards,

00:01:19.100 --> 00:01:20.640
the dealer gets two cards.

00:01:20.640 --> 00:01:23.780
What is the only decision
that you make in the game

00:01:23.780 --> 00:01:25.490
if you already have
perfect information?

00:01:28.622 --> 00:01:29.830
So you know the deck already.

00:01:29.830 --> 00:01:31.330
You don't need to
wait for each card

00:01:31.330 --> 00:01:33.730
to know what it's going to be.

00:01:33.730 --> 00:01:37.890
So as the game starts you
have to make one decision.

00:01:37.890 --> 00:01:40.232
What's that decision?

00:01:40.232 --> 00:01:41.190
AUDIENCE: Hit or stand.

00:01:41.190 --> 00:01:42.970
PROFESSOR: Well
that's assuming you

00:01:42.970 --> 00:01:45.404
care what you get each time.

00:01:45.404 --> 00:01:46.820
So if you have to
look at the card

00:01:46.820 --> 00:01:49.300
then you have to decide each
time if you hit or stand.

00:01:49.300 --> 00:01:51.100
If you know all the
cards in advance--

00:01:51.100 --> 00:01:53.750
AUDIENCE: How much to bet?

00:01:53.750 --> 00:01:55.967
PROFESSOR: I think our
game has that fixed.

00:01:55.967 --> 00:01:57.050
AUDIENCE: When to restart?

00:01:57.050 --> 00:01:59.300
PROFESSOR: So it
is hit or stand,

00:01:59.300 --> 00:02:01.120
but I want to restate that.

00:02:01.120 --> 00:02:03.560
Because you don't actually
have to decide after every card

00:02:03.560 --> 00:02:05.195
if you want to hit or stand.

00:02:05.195 --> 00:02:07.320
You know what the cards
are going to be in advance.

00:02:07.320 --> 00:02:08.984
AUDIENCE: When to restart?

00:02:08.984 --> 00:02:10.150
Like how many cards to pick?

00:02:10.150 --> 00:02:12.290
PROFESSOR: How
many cards to pick.

00:02:12.290 --> 00:02:13.954
Yeah that's pretty
much the same thing.

00:02:13.954 --> 00:02:16.120
So you don't have to decide
every time hit or stand,

00:02:16.120 --> 00:02:18.161
you know ahead of time I
want to hit three times,

00:02:18.161 --> 00:02:19.255
or I want to hit once.

00:02:19.255 --> 00:02:20.630
Because you know
the entire deck.

00:02:20.630 --> 00:02:23.540
You don't need to actually
look at the cards.

00:02:23.540 --> 00:02:28.317
So each game the only
decision that I make is--

00:02:28.317 --> 00:02:30.150
suppose this is one
game-- the only decision

00:02:30.150 --> 00:02:34.880
that I have is h, how many
cards I'm going to hit.

00:02:34.880 --> 00:02:36.060
Right?

00:02:36.060 --> 00:02:40.660
And then after I
make this decision

00:02:40.660 --> 00:02:42.360
the game will eat up some cards.

00:02:42.360 --> 00:02:44.380
I get two cards, the
dealer gets two cards,

00:02:44.380 --> 00:02:47.320
then I hit some cards then
the dealer gets some cards.

00:02:47.320 --> 00:02:51.950
And this is the number of
cards that have been consumed.

00:02:51.950 --> 00:02:58.930
Some number of cards that
were played in this game.

00:02:58.930 --> 00:03:00.730
And the other thing
that comes out of it

00:03:00.730 --> 00:03:03.090
is how much money I make.

00:03:03.090 --> 00:03:08.510
For our simple rules it's
either I make $1, or nothing,

00:03:08.510 --> 00:03:10.026
or I lose $1.

00:03:13.840 --> 00:03:14.730
Fair enough?

00:03:14.730 --> 00:03:16.430
Everyone follows?

00:03:16.430 --> 00:03:20.800
So I'm going to abstract
all this in a helper method.

00:03:20.800 --> 00:03:24.580
I'm going to say that I have
a method called round outcome.

00:03:29.960 --> 00:03:32.470
Where I say, look out
of the entire deck

00:03:32.470 --> 00:03:37.070
I'm going to start at card i, so
this is where my round starts.

00:03:37.070 --> 00:03:39.430
So I tell it which
cards I start at.

00:03:39.430 --> 00:03:41.820
And how many cards
I'm going to hit.

00:03:41.820 --> 00:03:45.400
And it gives me back a
tuple, where the first item

00:03:45.400 --> 00:03:48.130
is how many cards are played.

00:03:48.130 --> 00:03:51.080
So number of cards played.

00:03:51.080 --> 00:03:54.730
And the second item in the tuple
is how much money do I make.

00:04:07.080 --> 00:04:09.130
h is how many cards
I'm going to hit.

00:04:09.130 --> 00:04:12.050
So i says that I already
played this many cards

00:04:12.050 --> 00:04:14.910
in previous games.

00:04:14.910 --> 00:04:17.660
So a game starts
with a full deck.

00:04:17.660 --> 00:04:20.529
And then I play some rounds.

00:04:20.529 --> 00:04:24.320
Each round I do a whole
exchange with the dealer, where

00:04:24.320 --> 00:04:26.730
I hit some cards, and then
the dealer hits some cards.

00:04:26.730 --> 00:04:30.930
And then I win or
lose some money.

00:04:30.930 --> 00:04:33.719
AUDIENCE: I don't understand
why h and cp are different.

00:04:33.719 --> 00:04:36.010
PROFESSOR: So cp is how many
cards are played in total.

00:04:36.010 --> 00:04:38.880
And this looks at
the initial cards.

00:04:38.880 --> 00:04:42.050
So first I get two cards,
the dealer gets two cards.

00:04:42.050 --> 00:04:46.240
And then after I hit some cards
the dealer also has to hit.

00:04:46.240 --> 00:04:49.410
And the dealer has a pretty
find algorithm, right?

00:04:49.410 --> 00:04:51.240
So the number of
cards played includes

00:04:51.240 --> 00:04:53.480
the cards that were
dealt initially

00:04:53.480 --> 00:04:56.360
and the cars that the
dealer has to hit.

00:04:56.360 --> 00:05:01.880
So this little thing has all the
blackjack rules encoded in it.

00:05:01.880 --> 00:05:04.650
Everything is already there.

00:05:04.650 --> 00:05:06.400
AUDIENCE: So blackjack,
that's roughly 2h?

00:05:06.400 --> 00:05:09.620
cp is 2h, something like that?

00:05:09.620 --> 00:05:12.005
PROFESSOR: 4 plus 2h maybe.

00:05:12.005 --> 00:05:13.880
Because you get two
cards, he gets two cards,

00:05:13.880 --> 00:05:18.975
and if you both deal
h on average then--

00:05:18.975 --> 00:05:21.480
AUDIENCE: So is cp the
number of cards this round?

00:05:21.480 --> 00:05:22.646
PROFESSOR: This round, yeah.

00:05:33.910 --> 00:05:37.944
OK so intuitively
I already know,

00:05:37.944 --> 00:05:39.360
so I already know
the entire deck.

00:05:39.360 --> 00:05:43.450
So the decision that
I have to make is,

00:05:43.450 --> 00:05:45.590
would I play
optimally every round?

00:05:45.590 --> 00:05:48.580
Or do I want to maybe
lose the first round

00:05:48.580 --> 00:05:51.620
and leave some good
cards for later?

00:05:51.620 --> 00:05:53.390
So I have to figure
out how many cards I'm

00:05:53.390 --> 00:05:56.560
going to hit each time so
that overall I make the most

00:05:56.560 --> 00:05:58.530
amount of money when
I leave the table.

00:05:58.530 --> 00:06:01.890
And when I run out of
cards I leave the table.

00:06:01.890 --> 00:06:04.770
The dealer says
shows over, gotta go.

00:06:07.890 --> 00:06:11.220
Do the rules make sense?

00:06:11.220 --> 00:06:14.650
OK so I propose we
approach this in two ways.

00:06:14.650 --> 00:06:16.427
First we model it
as a graph problem,

00:06:16.427 --> 00:06:18.260
because we've already
done this a few times.

00:06:18.260 --> 00:06:20.580
And then we model it as a
dynamic programming problem.

00:06:20.580 --> 00:06:23.630
And we see how the
two are related.

00:06:23.630 --> 00:06:25.110
Make sense?

00:06:25.110 --> 00:06:26.820
Is this too simple for everyone?

00:06:26.820 --> 00:06:29.150
You guys already get everything?

00:06:29.150 --> 00:06:31.290
So how would I model
this is a graph problem?

00:06:36.587 --> 00:06:38.212
AUDIENCE: Do you
already know the order

00:06:38.212 --> 00:06:40.117
that you're going to
get all these cards in?

00:06:40.117 --> 00:06:41.370
PROFESSOR: Yep.

00:06:41.370 --> 00:06:44.300
AUDIENCE: So I in
lecture we briefly

00:06:44.300 --> 00:06:47.220
talked about having
your starting node go

00:06:47.220 --> 00:06:51.940
to a bunch of other
nodes that would

00:06:51.940 --> 00:06:55.096
be your potential
next move, and then

00:06:55.096 --> 00:06:57.012
you just calculate your
shortest path distance

00:06:57.012 --> 00:06:58.940
from there to the x value.

00:06:58.940 --> 00:07:02.320
PROFESSOR: So that's
the general approach.

00:07:02.320 --> 00:07:03.980
How do we do this for cards?

00:07:03.980 --> 00:07:05.210
So what would be nodes?

00:07:05.210 --> 00:07:10.580
What are the most intuitive
nodes you could think about?

00:07:13.260 --> 00:07:16.880
OK maybe intuitive for me.

00:07:16.880 --> 00:07:18.640
So nodes show our state, right?

00:07:18.640 --> 00:07:22.014
Show the state that the
game is currently in.

00:07:22.014 --> 00:07:22.514
Sorry?

00:07:22.514 --> 00:07:23.490
AUDIENCE: Your hand.

00:07:23.490 --> 00:07:25.760
Like your current cards.

00:07:25.760 --> 00:07:28.190
Is that your state?

00:07:30.694 --> 00:07:34.040
So from I guess 2 to ace.

00:07:34.040 --> 00:07:35.910
PROFESSOR: From?

00:07:35.910 --> 00:07:38.860
AUDIENCE: From 2 to ace, in
terms of the number of choices

00:07:38.860 --> 00:07:39.360
you have.

00:07:39.360 --> 00:07:41.860
PROFESSOR: OK so
the problem is you

00:07:41.860 --> 00:07:44.122
have four cards of
each type, right?

00:07:44.122 --> 00:07:46.330
And you don't know where
they show up and everything.

00:07:46.330 --> 00:07:49.380
So I think this my code
more complicated than it

00:07:49.380 --> 00:07:50.854
needs to be.

00:07:50.854 --> 00:07:52.916
AUDIENCE: Like the rest
of the cards in the deck

00:07:52.916 --> 00:07:53.310
that are remaining?

00:07:53.310 --> 00:07:54.155
PROFESSOR: OK.

00:07:54.155 --> 00:07:55.750
AUDIENCE: Is that
a good [INAUDIBLE]?

00:07:55.750 --> 00:07:58.630
PROFESSOR: How many cars I
have left in the deck, right?

00:07:58.630 --> 00:08:03.460
So basically I would have one
node for each of the cards

00:08:03.460 --> 00:08:04.320
here.

00:08:04.320 --> 00:08:07.650
And that says I start a
new game at this card.

00:08:12.130 --> 00:08:15.960
OK so I'm going to
draw some circles.

00:08:21.970 --> 00:08:24.450
Say these are our nodes.

00:08:24.450 --> 00:08:26.390
Maybe I draw a bit
too many of them.

00:08:26.390 --> 00:08:30.291
Where do we always start?

00:08:30.291 --> 00:08:31.290
AUDIENCE: The left side.

00:08:31.290 --> 00:08:32.456
PROFESSOR: First one, right?

00:08:32.456 --> 00:08:33.940
We start with 52 cards.

00:08:33.940 --> 00:08:41.570
So circle 0 means that we played
0 cards, we have 52 cards left.

00:08:41.570 --> 00:08:44.362
When do we draw an
edge between nodes?

00:08:44.362 --> 00:08:45.320
What does an edge mean?

00:08:48.204 --> 00:08:50.120
AUDIENCE: That's how
many cards you've chosen,

00:08:50.120 --> 00:08:53.810
so the number cp.

00:08:53.810 --> 00:08:55.710
PROFESSOR: OK so the number cp.

00:08:55.710 --> 00:08:58.580
It means I played a game, right?

00:08:58.580 --> 00:09:00.220
So one edge is a game.

00:09:00.220 --> 00:09:03.610
And it goes from one
state to the next state.

00:09:03.610 --> 00:09:06.990
So if I'm, say I'm at node i.

00:09:10.880 --> 00:09:13.360
How do I draw the edges?

00:09:13.360 --> 00:09:14.770
Say I'm somewhere here.

00:09:14.770 --> 00:09:17.814
So I already played i cards.

00:09:17.814 --> 00:09:19.480
AUDIENCE: Iterate
through all h's, cp's.

00:09:19.480 --> 00:09:20.850
PROFESSOR: OK.

00:09:20.850 --> 00:09:25.082
So for h in what to what?

00:09:25.082 --> 00:09:27.610
What's the smallest h?

00:09:27.610 --> 00:09:29.992
AUDIENCE: The smallest h is 1.

00:09:29.992 --> 00:09:31.430
PROFESSOR: Really?

00:09:31.430 --> 00:09:34.905
Do I have to hit?

00:09:34.905 --> 00:09:36.390
AUDIENCE: Wait isn't it 4?

00:09:36.390 --> 00:09:38.145
Because you're
always dealing out 4.

00:09:38.145 --> 00:09:40.520
PROFESSOR: Yes, so I might as
well not count them, right?

00:09:40.520 --> 00:09:43.790
So h is how many cards I hit
after the initial ones were

00:09:43.790 --> 00:09:46.050
dealt.

00:09:46.050 --> 00:09:49.340
So that I can start at 0,
a nice and easy number.

00:09:49.340 --> 00:09:50.542
And where do I end?

00:09:50.542 --> 00:09:51.375
Rough approximation.

00:09:54.900 --> 00:09:58.060
AUDIENCE: You could go to
infinity and then break.

00:09:58.060 --> 00:10:02.200
It's still 11 because 11 at
most-- oh no, 11 minus 4, 6.

00:10:02.200 --> 00:10:03.990
You need to know the
rules of the game.

00:10:03.990 --> 00:10:05.320
PROFESSOR: OK if you know the
rules of the game it's that.

00:10:05.320 --> 00:10:08.071
If you don't know the rules
of the game it's 52 minus i.

00:10:12.220 --> 00:10:15.200
OK so what's first thing I do?

00:10:15.200 --> 00:10:16.940
So how do I draw an
edge representing

00:10:16.940 --> 00:10:18.570
a game where I hold h cards?

00:10:23.420 --> 00:10:28.550
AUDIENCE: So you draw an
edge from your current place

00:10:28.550 --> 00:10:32.800
to the output of round
outcome with the 0 element.

00:10:36.472 --> 00:10:38.680
PROFESSOR: So then let's
store this output somewhere.

00:10:38.680 --> 00:10:45.220
Let's say o is round outcome.

00:10:45.220 --> 00:10:49.540
What do I give round outcome?

00:10:49.540 --> 00:10:54.392
AUDIENCE: i and h.

00:10:54.392 --> 00:10:55.850
PROFESSOR: See I
picked good names.

00:10:55.850 --> 00:10:57.620
They're exactly
what I have there.

00:10:57.620 --> 00:10:59.520
So I draw an edge
from i to what?

00:11:02.388 --> 00:11:06.900
AUDIENCE: To the output of
round outcome, which is o.

00:11:06.900 --> 00:11:08.397
So it's 0.

00:11:08.397 --> 00:11:08.980
PROFESSOR: OK.

00:11:12.604 --> 00:11:14.574
AUDIENCE: Or that
the node at o is 0.

00:11:14.574 --> 00:11:15.240
PROFESSOR: Yeah.

00:11:18.740 --> 00:11:20.890
So suppose I'm at i
and I've already played

00:11:20.890 --> 00:11:22.520
five cards, right?

00:11:22.520 --> 00:11:26.050
So say i equals 5, for example.

00:11:26.050 --> 00:11:31.340
And I know that if I hit
once the dealer will also

00:11:31.340 --> 00:11:32.100
have to hit once.

00:11:32.100 --> 00:11:35.250
So in total I've played 6 cards.

00:11:35.250 --> 00:11:39.310
And suppose I won.

00:11:39.310 --> 00:11:42.280
Then the output
would look like this.

00:11:42.280 --> 00:11:44.520
6 cards were played and I won.

00:11:44.520 --> 00:11:47.040
So plus 1.

00:11:47.040 --> 00:11:51.800
So I would draw an
edge from 5 to what?

00:11:51.800 --> 00:11:53.480
AUDIENCE: [INAUDIBLE]

00:11:53.480 --> 00:11:58.480
PROFESSOR: OK, from
5 to 11 hopefully.

00:11:58.480 --> 00:12:00.930
So what's 11?

00:12:00.930 --> 00:12:07.490
11 is 5 plus all of 0.

00:12:07.490 --> 00:12:09.950
OK, what am I missing there?

00:12:15.300 --> 00:12:17.925
AUDIENCE: i to i
plus [INAUDIBLE].

00:12:17.925 --> 00:12:18.550
PROFESSOR: Yep.

00:12:25.870 --> 00:12:31.230
So this tells me how many
cards I played in this game.

00:12:31.230 --> 00:12:33.140
I want to look at
each game separately.

00:12:33.140 --> 00:12:36.200
I don't want to have to keep
track of previous states.

00:12:36.200 --> 00:12:38.770
So this output is
localized to this game.

00:12:38.770 --> 00:12:40.720
It tells me how
many cards have been

00:12:40.720 --> 00:12:42.620
drawn in this game in total.

00:12:42.620 --> 00:12:45.310
And how much money
I made in this game.

00:12:45.310 --> 00:12:50.200
If I already played i cards
before starting the game,

00:12:50.200 --> 00:12:55.550
after I play all of 0, the total
number of cards is i plus 0.

00:12:55.550 --> 00:12:57.720
Tiny detail, but you'd
probably lose a point off

00:12:57.720 --> 00:13:00.680
of an exam or something
if you forget it.

00:13:00.680 --> 00:13:02.000
OK so keep track of your state.

00:13:02.000 --> 00:13:05.170
It makes sense to write
down this is my state,

00:13:05.170 --> 00:13:07.920
and then make sure that
you're always representing it.

00:13:07.920 --> 00:13:09.310
So what's the cost of the edge?

00:13:20.520 --> 00:13:25.120
And then our answer would
be what path do I want?

00:13:28.270 --> 00:13:30.400
I want to make the
most amount of money,

00:13:30.400 --> 00:13:32.600
so that's the longest path.

00:13:32.600 --> 00:13:34.730
How do I convert this to
a shortest path problem,

00:13:34.730 --> 00:13:37.950
because this is what
you know how to solve?

00:13:37.950 --> 00:13:40.084
Where I put it?

00:13:40.084 --> 00:13:42.530
AUDIENCE: There.

00:13:42.530 --> 00:13:44.060
PROFESSOR: Good answer, there.

00:13:44.060 --> 00:13:46.010
Right there.

00:13:46.010 --> 00:13:48.300
OK so this builds
the graph, then

00:13:48.300 --> 00:13:50.810
I run some algorithm on it.

00:13:50.810 --> 00:13:55.210
What's the best algorithm
I can run on it?

00:13:55.210 --> 00:13:59.090
AUDIENCE: Dykstra because
you can [INAUDIBLE].

00:13:59.090 --> 00:14:01.450
But you can add everything on.

00:14:01.450 --> 00:14:05.518
The lowest negative edge
weight is 1, or negative 1.

00:14:09.825 --> 00:14:11.734
PROFESSOR: Are there
negative cycles?

00:14:11.734 --> 00:14:13.694
AUDIENCE: No.

00:14:13.694 --> 00:14:15.360
PROFESSOR: Everything
goes right, right?

00:14:15.360 --> 00:14:18.130
So even if I don't
get hit any card,

00:14:18.130 --> 00:14:19.620
at least four cards
will be played.

00:14:19.620 --> 00:14:22.400
So all these arrows go right.

00:14:26.550 --> 00:14:29.230
So then I heard a
fancy term that I like.

00:14:32.279 --> 00:14:33.320
Can someone say it again?

00:14:33.320 --> 00:14:35.250
What's this graph?

00:14:35.250 --> 00:14:36.190
AUDIENCE: DAG.

00:14:36.190 --> 00:14:37.170
PROFESSOR: DAG.

00:14:37.170 --> 00:14:38.670
All the edges go one way.

00:14:38.670 --> 00:14:41.030
So this is a DAG.

00:14:41.030 --> 00:14:43.385
And that means that I
can run what algorithm?

00:14:47.130 --> 00:14:49.044
Sorry?

00:14:49.044 --> 00:14:50.880
AUDIENCE: [INAUDIBLE].

00:14:50.880 --> 00:14:52.570
PROFESSOR: Topological
sort plus DFS,

00:14:52.570 --> 00:14:55.080
the one that we talked about
last time when everyone was out

00:14:55.080 --> 00:14:56.365
for Thanksgiving.

00:14:56.365 --> 00:14:57.740
So you have to
believe me that it

00:14:57.740 --> 00:15:00.850
exists, or look
at lecture notes.

00:15:00.850 --> 00:15:05.180
So top sort plus
DFS will give me

00:15:05.180 --> 00:15:10.000
the shortest path in
order of V plus E.

00:15:10.000 --> 00:15:16.240
So this is better than Dykstra,
which is E plus V log V. OK?

00:15:19.930 --> 00:15:21.790
OK I'm guessing
most of you don't

00:15:21.790 --> 00:15:23.040
know how that algorithm works.

00:15:23.040 --> 00:15:24.415
Well good news,
we're going to do

00:15:24.415 --> 00:15:25.860
this using dynamic programming.

00:15:25.860 --> 00:15:28.622
So we're going to represent
the graph implicitly.

00:15:28.622 --> 00:15:30.080
And we're going to
write everything

00:15:30.080 --> 00:15:33.270
without needing to
know the algorithm.

00:15:33.270 --> 00:15:35.860
If you know it, it helps because
you can see how they relate.

00:15:35.860 --> 00:15:39.800
But if you don't we should still
be able to solve the problem.

00:15:39.800 --> 00:15:42.900
But before we do that, does
everyone understand this?

00:15:46.550 --> 00:15:50.680
Some nods would be nice
so that I can feel good.

00:15:50.680 --> 00:15:51.180
Yes?

00:15:51.180 --> 00:15:51.680
Almost?

00:15:51.680 --> 00:15:54.095
OK.

00:15:54.095 --> 00:15:54.595
Questions?

00:15:58.740 --> 00:16:00.700
AUDIENCE: Like the
number 5 there,

00:16:00.700 --> 00:16:03.070
that's only if you hit, right?

00:16:03.070 --> 00:16:06.070
Or that's the number
of cards remaining.

00:16:06.070 --> 00:16:09.054
Is there a particular
reason you picked 5?

00:16:09.054 --> 00:16:10.970
PROFESSOR: So I was
choosing an example for i.

00:16:10.970 --> 00:16:13.160
So good question,
what does i mean?

00:16:15.840 --> 00:16:20.130
So this means I'm-- assume
that I'm starting a game.

00:16:20.130 --> 00:16:22.778
So starting-- sorry, a round.

00:16:26.770 --> 00:16:27.380
A new round.

00:16:27.380 --> 00:16:36.400
And I have already played i
cards in the previous round.

00:16:44.590 --> 00:16:48.120
So I started a new round
and the first 5 cards

00:16:48.120 --> 00:16:49.960
are out of the deck.

00:16:49.960 --> 00:16:51.510
What's the best
strategy I can have?

00:16:51.510 --> 00:16:53.273
What's the most
money I can make?

00:16:53.273 --> 00:16:55.125
AUDIENCE: But there's
some nodes that

00:16:55.125 --> 00:16:58.050
connect to the next card
over that won't necessarily

00:16:58.050 --> 00:16:59.972
end the game, so
there aren't going

00:16:59.972 --> 00:17:01.326
to be any earnings, right?

00:17:04.470 --> 00:17:06.901
You could have 5 connect
to 6, and that wouldn't--

00:17:06.901 --> 00:17:09.150
PROFESSOR: Here I'm just
trying to emphasize the point

00:17:09.150 --> 00:17:12.700
that all the edges move,
all the edges point forward.

00:17:12.700 --> 00:17:17.280
But yeah, the edges have to
go at least across four nodes.

00:17:17.280 --> 00:17:19.610
So assume there are some
more nodes around here.

00:17:19.610 --> 00:17:20.151
AUDIENCE: OK.

00:17:23.099 --> 00:17:23.768
PROFESSOR: Yes?

00:17:23.768 --> 00:17:25.143
AUDIENCE: You were
saying how you

00:17:25.143 --> 00:17:25.960
have to be careful
with something

00:17:25.960 --> 00:17:27.430
or else you'll lose a point.

00:17:27.430 --> 00:17:28.900
What was that?

00:17:33.622 --> 00:17:35.080
PROFESSOR: How you
draw your edges.

00:17:35.080 --> 00:17:37.184
Or when we switch to
dynamic programming, what

00:17:37.184 --> 00:17:38.350
you write in your recursion.

00:17:43.620 --> 00:17:45.320
OK so last chance
to ask a question

00:17:45.320 --> 00:17:51.070
before we do a conceptual jump
and use another algorithm.

00:18:01.520 --> 00:18:04.474
OK how do we do this using
the dynamic programming?

00:18:04.474 --> 00:18:06.390
So what are we going to
have instead of nodes?

00:18:09.800 --> 00:18:12.100
Sorry?

00:18:12.100 --> 00:18:14.790
Well so you still have
states in both cases.

00:18:14.790 --> 00:18:18.400
But here you represent
them with nodes in a graph.

00:18:18.400 --> 00:18:23.490
In dynamic programming you
represent them using-- yeah,

00:18:23.490 --> 00:18:25.240
the states are
basically sub-problems.

00:18:25.240 --> 00:18:29.850
And what do we, when we
compute stuff, what do we use?

00:18:34.750 --> 00:18:37.030
Numbers is a vector
or in a matrix.

00:18:37.030 --> 00:18:38.690
So there's no
graph to work with.

00:18:38.690 --> 00:18:40.710
There are no extra
algorithms to call.

00:18:40.710 --> 00:18:43.020
We just straight up
compute to the numbers,

00:18:43.020 --> 00:18:45.430
we trade the answers
to the problem.

00:18:45.430 --> 00:18:46.790
So we're going to have an array.

00:18:54.449 --> 00:18:55.740
How many elements in the array?

00:18:55.740 --> 00:18:58.960
Can anyone guess?

00:18:58.960 --> 00:19:00.380
All right, I heard 52.

00:19:06.660 --> 00:19:12.650
If I'm at element i, say i
equals 5 because we used that

00:19:12.650 --> 00:19:17.041
before, what does this represent
in the dynamic programming

00:19:17.041 --> 00:19:17.540
formulation?

00:19:20.260 --> 00:19:23.940
It's very similar
to node 5 there.

00:19:23.940 --> 00:19:26.930
So what does it represent?

00:19:26.930 --> 00:19:30.110
The fact that we're
starting a game after we

00:19:30.110 --> 00:19:32.252
played the first five cards.

00:19:32.252 --> 00:19:33.960
Sorry, we're starting
a round after we've

00:19:33.960 --> 00:19:35.340
played the first 5 cards.

00:19:35.340 --> 00:19:37.860
And we want to maximize
our earnings from here on.

00:19:40.630 --> 00:19:42.120
So then the problem
is, how do we

00:19:42.120 --> 00:19:45.030
maximize our earnings
starting here?

00:19:45.030 --> 00:19:51.160
So given that the
deck has these cards,

00:19:51.160 --> 00:19:53.420
so the cards from 5 to 51.

00:19:53.420 --> 00:19:55.010
What's the maximum
amount of money

00:19:55.010 --> 00:19:56.590
we can make by
playing optimally?

00:20:02.360 --> 00:20:07.710
So maximum number
of money we can

00:20:07.710 --> 00:20:17.190
win by playing optimally,
starting around at card i.

00:20:21.370 --> 00:20:24.515
Starting at i.

00:20:28.470 --> 00:20:32.680
So if I want to compute
this-- by the way, speaking

00:20:32.680 --> 00:20:36.210
of bad variable names,
we did this before.

00:20:36.210 --> 00:20:38.410
When people don't know
how to name this array

00:20:38.410 --> 00:20:39.550
they name it dpi.

00:20:39.550 --> 00:20:41.670
I think we did that in our PSet.

00:20:41.670 --> 00:20:45.919
So this is the most useless
name you can have for the array.

00:20:45.919 --> 00:20:48.210
It just tells you that we're
using dynamic programming.

00:20:48.210 --> 00:20:49.810
But it doesn't really
tell you what it means.

00:20:49.810 --> 00:20:51.730
So we're going to go
for it, because it's

00:20:51.730 --> 00:20:53.540
nice and easy to write.

00:20:53.540 --> 00:21:00.180
So if I want to compute
dp of i, how do I do that?

00:21:03.270 --> 00:21:05.057
AUDIENCE: x
[INAUDIBLE] problems.

00:21:05.057 --> 00:21:06.890
PROFESSOR: OK, so what
are the sub-problems?

00:21:10.440 --> 00:21:14.440
AUDIENCE: The
function at i's past 5

00:21:14.440 --> 00:21:20.320
where the i's are [INAUDIBLE]
through this manner.

00:21:20.320 --> 00:21:24.010
PROFESSOR: OK so I'd want to
have something very similar

00:21:24.010 --> 00:21:26.500
to this, right?

00:21:26.500 --> 00:21:27.710
What are my decisions?

00:21:27.710 --> 00:21:28.860
So what are my choices?

00:21:28.860 --> 00:21:31.824
What do I iterate over?

00:21:31.824 --> 00:21:33.667
AUDIENCE: How many hits.

00:21:33.667 --> 00:21:36.000
PROFESSOR: Yep, exactly the
same thing as before, right?

00:21:36.000 --> 00:21:37.920
Starting a node at i.

00:21:37.920 --> 00:21:40.100
I was starting a node at i here.

00:21:40.100 --> 00:21:41.670
So the choices are
exactly the same.

00:21:44.260 --> 00:21:47.220
So I'm going to start
by looking at this line.

00:21:47.220 --> 00:21:48.500
Do I need to make any changes?

00:21:48.500 --> 00:21:49.880
Or do I copy straight over?

00:21:59.890 --> 00:22:02.930
So this is the algorithm
for computing dp of i.

00:22:02.930 --> 00:22:08.150
For i in 0 to 52.

00:22:08.150 --> 00:22:11.550
Sorry h in 52 minus i.

00:22:11.550 --> 00:22:12.050
All right.

00:22:20.890 --> 00:22:24.410
I hope we can do a
bit better than that.

00:22:24.410 --> 00:22:26.941
AUDIENCE: So we know that
it's a max of 6, right?

00:22:26.941 --> 00:22:29.200
So can we just put
that in instead?

00:22:29.200 --> 00:22:30.680
That's given the rules.

00:22:30.680 --> 00:22:31.890
PROFESSOR: Sure.

00:22:31.890 --> 00:22:33.170
If you're smart you can.

00:22:33.170 --> 00:22:35.910
I'm not, so I'm
just writing this.

00:22:35.910 --> 00:22:39.340
So this helper function
that I have here,

00:22:39.340 --> 00:22:42.060
that I call the
magic that implements

00:22:42.060 --> 00:22:44.980
the rules of bag
check will save me.

00:22:44.980 --> 00:22:47.270
So if I say that oh, I
want to hit 10 times,

00:22:47.270 --> 00:22:49.970
and that's impossible,
then it'll probably give me

00:22:49.970 --> 00:22:52.860
an earning of minus
infinity, which makes sure

00:22:52.860 --> 00:22:55.390
I never choose that path.

00:22:55.390 --> 00:22:57.650
So all that is hidden in there.

00:22:57.650 --> 00:22:59.880
You're smart enough in
blackjack so you can write 6.

00:22:59.880 --> 00:23:02.370
I'm not so I can't.

00:23:02.370 --> 00:23:05.660
So 52 minus i.

00:23:05.660 --> 00:23:08.600
OK what I do next?

00:23:08.600 --> 00:23:10.770
Do I copy this next line?

00:23:10.770 --> 00:23:11.900
Or do I change it?

00:23:16.520 --> 00:23:17.940
Yeah let's copy it over.

00:23:17.940 --> 00:23:18.440
Sounds good.

00:23:28.480 --> 00:23:29.540
How about this?

00:23:29.540 --> 00:23:32.780
Do I copy this?

00:23:32.780 --> 00:23:35.470
Trick question.

00:23:35.470 --> 00:23:36.210
Come on guys.

00:23:38.830 --> 00:23:41.320
So do I copy this line or not?

00:23:41.320 --> 00:23:43.290
Do I have a graph here?

00:23:43.290 --> 00:23:45.130
Can I draw edges?

00:23:45.130 --> 00:23:46.630
OK so I'm not going to copy it.

00:23:46.630 --> 00:23:49.150
What do I do instead?

00:23:49.150 --> 00:23:51.180
By trick I mean easy.

00:23:51.180 --> 00:23:54.607
So what do I do instead?

00:23:54.607 --> 00:23:55.815
I compute my answer directly.

00:23:58.320 --> 00:24:06.715
So if I hit h cards,
what am I looking at?

00:24:06.715 --> 00:24:09.722
AUDIENCE: Do you
mean like a function?

00:24:09.722 --> 00:24:10.930
PROFESSOR: A function, sorry?

00:24:10.930 --> 00:24:14.910
AUDIENCE: You add the
dp of o 1 or of o 0.

00:24:20.390 --> 00:24:22.950
PROFESSOR: OK so first
let's see if I have i cards,

00:24:22.950 --> 00:24:27.010
and say I hit, I do the same
exact thing that I did before.

00:24:27.010 --> 00:24:31.470
I look at i is 5 and h equals 2.

00:24:31.470 --> 00:24:36.760
So then that function gives
me the same answer, 6 1.

00:24:36.760 --> 00:24:39.420
So then I know that after this
I'm going to end up in a state

00:24:39.420 --> 00:24:43.490
where I played the
first 11 cards.

00:24:43.490 --> 00:24:45.445
So I'm going to end up at 11.

00:24:49.140 --> 00:24:51.750
How much money did
I make overall?

00:24:56.870 --> 00:24:58.000
OK, so 1 in this case.

00:25:00.750 --> 00:25:12.230
So how much money I made is
o of-- I think it's o of 1.

00:25:15.250 --> 00:25:21.050
And after I land here, how
much money I'm going to make?

00:25:21.050 --> 00:25:23.314
Assuming I'm still
playing optimally.

00:25:23.314 --> 00:25:24.230
AUDIENCE: [INAUDIBLE].

00:25:30.230 --> 00:25:31.580
PROFESSOR: dp i plus.

00:25:35.474 --> 00:25:36.390
AUDIENCE: [INAUDIBLE].

00:25:43.620 --> 00:25:45.360
OK.

00:25:45.360 --> 00:25:51.290
So i plus o of 0 is
used to compute--

00:25:51.290 --> 00:25:54.410
so dp of i plus o of 0 is
used to compute dp of i.

00:25:54.410 --> 00:25:55.990
This is the same thing as--

00:25:55.990 --> 00:25:58.027
AUDIENCE: dp is a function here?

00:25:58.027 --> 00:25:58.610
PROFESSOR: No.

00:26:03.450 --> 00:26:05.420
So you're wondering
what the hell?

00:26:05.420 --> 00:26:06.520
Why will that work, right?

00:26:06.520 --> 00:26:08.320
Let's get to that in a minute.

00:26:08.320 --> 00:26:10.030
That will work, we
have to make it work.

00:26:12.730 --> 00:26:17.450
So here I'm drawing an edge
from i to i plus o of 0.

00:26:17.450 --> 00:26:21.870
And the cost of the
edge is minus o of 1.

00:26:21.870 --> 00:26:23.260
So here we're looking at edges.

00:26:23.260 --> 00:26:25.750
Here I'm assuming
that they already

00:26:25.750 --> 00:26:28.370
computed the answer here
using some black magic.

00:26:28.370 --> 00:26:30.390
It's already available.

00:26:30.390 --> 00:26:33.290
And I want to compute
the answer here.

00:26:33.290 --> 00:26:38.370
So I have the cost of the
edge plus whatever I had here.

00:26:41.590 --> 00:26:45.200
So if, suppose I know
that if I start here

00:26:45.200 --> 00:26:50.340
and I finish the
deck, I can make $20.

00:26:50.340 --> 00:26:52.480
So suppose I know
that this is 20.

00:26:52.480 --> 00:26:53.730
What will the answer be here?

00:26:58.420 --> 00:26:59.690
1 plus 20 which is?

00:27:05.550 --> 00:27:10.770
So if I hit-- how many times
did I say there-- if I hit twice

00:27:10.770 --> 00:27:12.920
I guess I'll make 21.

00:27:12.920 --> 00:27:15.780
So this is a possible answer.

00:27:15.780 --> 00:27:18.570
And I have to go over
all possible answers.

00:27:18.570 --> 00:27:24.880
So this is how much I'm making
if I hit h cards, right?

00:27:27.670 --> 00:27:30.810
Now I'm looking at
multiple choices here.

00:27:30.810 --> 00:27:33.310
This is the answer
for each choice.

00:27:33.310 --> 00:27:37.450
Which answer do I
want in the end?

00:27:37.450 --> 00:27:38.330
The largest.

00:27:38.330 --> 00:27:39.340
OK.

00:27:39.340 --> 00:27:44.860
So let's say I'm going to
start with a choices array that

00:27:44.860 --> 00:27:46.730
stores all the answers.

00:27:46.730 --> 00:27:48.970
So here I'm just going
to pend the answer,

00:27:48.970 --> 00:27:51.200
the possible answer.

00:27:51.200 --> 00:27:56.470
Choices append this guy.

00:27:56.470 --> 00:27:58.200
And then at the
end of the for loop

00:27:58.200 --> 00:28:04.820
I'm going to take
the max of choices,

00:28:04.820 --> 00:28:06.370
and I'm going to
assign it where?

00:28:10.314 --> 00:28:11.230
AUDIENCE: [INAUDIBLE].

00:28:15.500 --> 00:28:17.750
PROFESSOR: So I promised I'm
going to compute dp of i.

00:28:17.750 --> 00:28:19.690
I just finished
computing dp of i.

00:28:23.770 --> 00:28:25.380
Now there's a
little problem here.

00:28:25.380 --> 00:28:28.960
In order to compute
this guy, I need

00:28:28.960 --> 00:28:31.240
to already have the
answer for this guy.

00:28:31.240 --> 00:28:35.730
And maybe for some
other guys here.

00:28:39.550 --> 00:28:41.790
So an answer here depends
on future answers.

00:28:44.920 --> 00:28:47.810
The arrows here are the same
as the arrows here, right?

00:28:47.810 --> 00:28:51.760
They represent possible
moves in the game.

00:28:51.760 --> 00:28:55.540
At the same time the arrows
here represent dependencies.

00:28:55.540 --> 00:28:57.580
This answer depends
on this answer,

00:28:57.580 --> 00:29:01.234
this answer depends on this
answer, so on and so forth.

00:29:01.234 --> 00:29:02.650
When we hear the
word dependencies

00:29:02.650 --> 00:29:03.483
what do we think of?

00:29:06.920 --> 00:29:09.670
Topological sort.

00:29:09.670 --> 00:29:10.730
PSet, which one?

00:29:10.730 --> 00:29:13.180
PSet 6 still brings
painful memories?

00:29:13.180 --> 00:29:13.860
Not anymore.

00:29:13.860 --> 00:29:15.580
We have a new one.

00:29:15.580 --> 00:29:17.660
So in order to
compute this I need

00:29:17.660 --> 00:29:21.610
to compute the answer to
a few other sub-problems.

00:29:21.610 --> 00:29:24.870
To make sure that I have these
answers ready by the time

00:29:24.870 --> 00:29:25.640
I compute this.

00:29:25.640 --> 00:29:27.223
So to make sure that
this code doesn't

00:29:27.223 --> 00:29:31.290
crash I have to compute all
the answers to the sub-problems

00:29:31.290 --> 00:29:34.480
in the topological sort order.

00:29:34.480 --> 00:29:36.830
That's where topological
sort fits in here.

00:29:36.830 --> 00:29:38.510
What's an obvious
topological sort,

00:29:38.510 --> 00:29:40.794
if all the edges are
pointing this way?

00:29:40.794 --> 00:29:41.710
AUDIENCE: [INAUDIBLE].

00:29:41.710 --> 00:29:43.150
PROFESSOR: Yep, thank you guys.

00:29:46.340 --> 00:29:48.340
So start at the easiest problem.

00:29:48.340 --> 00:29:50.030
What do you do if
you have one card?

00:29:50.030 --> 00:29:53.220
And then go look at bigger and
bigger and bigger problems,

00:29:53.220 --> 00:29:54.680
until we tackle
the hard problems

00:29:54.680 --> 00:29:57.360
of what I do with
the entire deck.

00:29:57.360 --> 00:30:05.020
So when I compute this problem
I'm going to go to iterate how?

00:30:05.020 --> 00:30:07.364
From where to where?

00:30:07.364 --> 00:30:08.792
AUDIENCE: 52 minus i to the 0.

00:30:08.792 --> 00:30:10.480
You're actually--

00:30:10.480 --> 00:30:11.572
PROFESSOR: So this is i.

00:30:11.572 --> 00:30:12.530
AUDIENCE: Oh, that's i.

00:30:12.530 --> 00:30:14.700
PROFESSOR: So where
do i go from here?

00:30:14.700 --> 00:30:16.025
AUDIENCE: 51 to 0.

00:30:16.025 --> 00:30:16.900
PROFESSOR: All right.

00:30:20.940 --> 00:30:22.930
So now whenever
I access this guy

00:30:22.930 --> 00:30:24.356
I know it's already computed.

00:30:24.356 --> 00:30:25.730
So the code isn't
going to crash.

00:30:30.800 --> 00:30:35.370
OK and this thing is
my topological sort.

00:30:41.920 --> 00:30:43.750
So the advantage of
this is that the code

00:30:43.750 --> 00:30:45.840
is a lot smaller, right?

00:30:45.840 --> 00:30:47.250
Here I'm building the graph.

00:30:47.250 --> 00:30:48.760
So I'm calling
some graph methods.

00:30:48.760 --> 00:30:51.830
And then I would have to
have the code for computing

00:30:51.830 --> 00:30:54.430
the shortest path in a DAG.

00:30:54.430 --> 00:30:57.190
And then I would have to
have some code for extracting

00:30:57.190 --> 00:31:00.490
the answer using that.

00:31:00.490 --> 00:31:02.230
Here this is all the code.

00:31:02.230 --> 00:31:03.010
It's a few lines.

00:31:03.010 --> 00:31:05.960
And it's because the graph
is represented implicitly.

00:31:05.960 --> 00:31:08.550
The topological sort is
represented implicitly.

00:31:08.550 --> 00:31:11.770
The edges are
represented implicitly.

00:31:11.770 --> 00:31:13.710
So this looks like magic.

00:31:13.710 --> 00:31:16.056
But if you know where to
look you'll find the items.

00:31:16.056 --> 00:31:18.680
You'll find the things that tell
you what the graph looks like.

00:31:18.680 --> 00:31:19.958
Yes?

00:31:19.958 --> 00:31:21.768
AUDIENCE: So that tells
you how much money

00:31:21.768 --> 00:31:23.745
you can make, but
does it tell you can--

00:31:23.745 --> 00:31:24.870
PROFESSOR: How you make it?

00:31:24.870 --> 00:31:26.685
Not yet.

00:31:26.685 --> 00:31:29.380
Parent pointers.

00:31:29.380 --> 00:31:32.140
Yeah that's a good point.

00:31:32.140 --> 00:31:33.690
Let me see how
we're doing on time.

00:31:33.690 --> 00:31:35.460
OK.

00:31:35.460 --> 00:31:37.850
I can talk parent pointers.

00:31:37.850 --> 00:31:39.150
Am I missing anything else?

00:31:44.010 --> 00:31:46.170
There's one decision
that I'm missing,

00:31:46.170 --> 00:31:47.500
that I missed here too.

00:31:50.200 --> 00:31:52.710
If things look bad
for you, if you

00:31:52.710 --> 00:31:54.980
know you're going to lose
money, what can you do?

00:31:58.240 --> 00:31:58.900
Walk away.

00:31:58.900 --> 00:32:00.620
How much do you get?

00:32:00.620 --> 00:32:02.500
AUDIENCE: 0.

00:32:02.500 --> 00:32:03.420
PROFESSOR: Yep.

00:32:03.420 --> 00:32:07.510
So you always have an
edge that takes you

00:32:07.510 --> 00:32:11.400
all the way out with cost 0.

00:32:11.400 --> 00:32:15.070
So the way I represent that here
is I start with a choice of 0.

00:32:19.540 --> 00:32:20.970
OK now let's do parent pointers.

00:32:20.970 --> 00:32:23.040
What's the easiest way
of doing parent pointers?

00:32:28.200 --> 00:32:30.625
AUDIENCE: Keep track of
the max of-- [INAUDIBLE].

00:32:37.910 --> 00:32:40.560
PROFESSOR: So I want to keep
track-- for every answer here

00:32:40.560 --> 00:32:44.257
I want to keep back of the h
that led me to that answer.

00:32:46.880 --> 00:32:49.950
So in the dynamic
programming vector,

00:32:49.950 --> 00:32:52.010
instead of just storing
the maximum cost,

00:32:52.010 --> 00:32:55.600
I'm going to store the maximum
cost and the number of hits

00:32:55.600 --> 00:32:57.760
I have to make to get there.

00:32:57.760 --> 00:32:59.911
So instead of having one
number here that's 21

00:32:59.911 --> 00:33:01.160
I'm going to have two numbers.

00:33:01.160 --> 00:33:04.450
I'm going to have
21 and the 1 that

00:33:04.450 --> 00:33:07.850
says you have to hit-- sorry,
2-- you have to hit twice.

00:33:07.850 --> 00:33:12.060
And then you'll go on this
arrow and so on and so forth.

00:33:12.060 --> 00:33:14.630
And if you know
how many hits you

00:33:14.630 --> 00:33:17.010
have to make you
can follow this--

00:33:17.010 --> 00:33:18.540
you can follow these
parent pointers

00:33:18.540 --> 00:33:21.240
and they will tell you how
to play the entire game.

00:33:21.240 --> 00:33:23.760
You start at 0 and
play the entire game.

00:33:23.760 --> 00:33:28.010
Do we want to change the
pseudocode to do that?

00:33:28.010 --> 00:33:30.540
OK, it's not too hard.

00:33:30.540 --> 00:33:34.190
How many people want to
see the pseudocode changes?

00:33:34.190 --> 00:33:37.580
All right, I guess I don't
have to write it then.

00:33:37.580 --> 00:33:40.700
OK any questions on this?

00:33:40.700 --> 00:33:43.150
So the change is really simple.

00:33:43.150 --> 00:33:45.430
Instead of storing one
number you store a tuple.

00:33:45.430 --> 00:33:48.570
And then because
tuples are sorted

00:33:48.570 --> 00:33:50.100
the right way
maximum still works.

00:33:50.100 --> 00:33:51.724
You don't have to
change that, you just

00:33:51.724 --> 00:33:56.152
have to change what
you store down there.

00:33:56.152 --> 00:34:00.080
AUDIENCE: So you just
add h in, into your--

00:34:00.080 --> 00:34:03.100
PROFESSOR: Yeah, you add one
more parentheses for the tuple.

00:34:03.100 --> 00:34:05.665
Wait, I already have
two, OK, never mind.

00:34:05.665 --> 00:34:08.165
AUDIENCE: You have to go through
your choices, so you just--

00:34:10.448 --> 00:34:12.239
AUDIENCE: Is there any
difference in making

00:34:12.239 --> 00:34:13.989
a separate dictionary
for parent pointers?

00:34:13.989 --> 00:34:16.420
Does it make any
difference in run time?

00:34:16.420 --> 00:34:18.461
PROFESSOR: Absolutely no
difference running time.

00:34:18.461 --> 00:34:20.544
The code is, it might
be more complicated,

00:34:20.544 --> 00:34:21.960
it might be more
simple, depending

00:34:21.960 --> 00:34:23.830
on how your brain works.

00:34:23.830 --> 00:34:25.352
It's easier to
patch existing code

00:34:25.352 --> 00:34:26.810
to add in parent
pointers this way.

00:34:26.810 --> 00:34:28.268
If you're writing
new code it might

00:34:28.268 --> 00:34:32.550
be easier for you to have
a separate dictionary.

00:34:32.550 --> 00:34:35.550
This is fewer lines
of code though.

00:34:35.550 --> 00:34:36.810
OK any questions on this?

00:34:41.400 --> 00:34:43.850
Yes?

00:34:43.850 --> 00:34:46.302
AUDIENCE: Could I
generalize and say

00:34:46.302 --> 00:34:47.760
that if you have
a topological sort

00:34:47.760 --> 00:34:49.730
you can do everything backwards.

00:34:49.730 --> 00:34:53.417
Otherwise you should
use memoization.

00:34:53.417 --> 00:34:55.000
PROFESSOR: So actually
you're doing it

00:34:55.000 --> 00:34:56.719
in the order of the
topological sort.

00:34:56.719 --> 00:34:59.450
You're not doing it backwards.

00:34:59.450 --> 00:35:00.720
AUDIENCE: Oh, OK sorry.

00:35:00.720 --> 00:35:02.445
If you have a
topological sort then

00:35:02.445 --> 00:35:03.736
you should do it in that order.

00:35:03.736 --> 00:35:06.300
But if you don't have
a topological sort

00:35:06.300 --> 00:35:08.147
then you should do memoization.

00:35:08.147 --> 00:35:10.230
PROFESSOR: If you don't
know the topological sort.

00:35:10.230 --> 00:35:11.521
But there has to be one, right?

00:35:11.521 --> 00:35:13.970
Because otherwise you
have infinite loops.

00:35:13.970 --> 00:35:16.274
If you have an infinite loop
in your dependency graph,

00:35:16.274 --> 00:35:17.940
then you're not going
to have an answer.

00:35:17.940 --> 00:35:21.634
So that means you're
dp formulation is bad.

00:35:21.634 --> 00:35:23.300
Fortunately for all
the problems that we

00:35:23.300 --> 00:35:26.450
have the topological
sort is pretty obvious.

00:35:26.450 --> 00:35:30.690
It either grows from 0 to the
problem size or the other way

00:35:30.690 --> 00:35:32.890
around.

00:35:32.890 --> 00:35:35.810
AUDIENCE: So then
memoization is?

00:35:35.810 --> 00:35:38.800
PROFESSOR: So
memoization is, it's

00:35:38.800 --> 00:35:40.410
more of a proof
of concept thing.

00:35:40.410 --> 00:35:43.360
It shows you that if
you have the recursion,

00:35:43.360 --> 00:35:45.501
everything else can
be done automatically.

00:35:45.501 --> 00:35:47.750
So like if you build a graph
then you can run top sort

00:35:47.750 --> 00:35:50.470
and get the answer, you
don't have to think about it.

00:35:50.470 --> 00:35:53.230
We think about it because
the code is smaller

00:35:53.230 --> 00:35:55.250
if we do it this way.

00:35:55.250 --> 00:35:56.735
If I'd have to
write memoization I

00:35:56.735 --> 00:35:58.840
would add 4 or 5
more lines, right?

00:35:58.840 --> 00:36:01.920
But the point of doing it
that way is, all you need

00:36:01.920 --> 00:36:02.730
is that recursion.

00:36:02.730 --> 00:36:06.830
If you have this-- so
this is the magic part.

00:36:06.830 --> 00:36:10.460
If you have this, so this line
here of what your choices are

00:36:10.460 --> 00:36:13.350
and max, how you combine
them, then everything else

00:36:13.350 --> 00:36:13.944
is mechanical.

00:36:13.944 --> 00:36:15.360
Once you've solved
enough problems

00:36:15.360 --> 00:36:17.820
everything else is just
follow the process.

00:36:23.210 --> 00:36:25.410
So this is the equivalent
of in graph problems,

00:36:25.410 --> 00:36:27.410
the hard part is figuring
out what the state is.

00:36:27.410 --> 00:36:28.840
Once you know what
the state you know

00:36:28.840 --> 00:36:30.040
that these are the
vertices, and you

00:36:30.040 --> 00:36:31.540
know how to draw
edges between them.

00:36:31.540 --> 00:36:33.560
And then you know
what algorithm to run.

00:36:33.560 --> 00:36:36.520
So the hard part is still
knowing what the state is.

00:36:40.400 --> 00:36:41.050
Anything else?

00:36:45.480 --> 00:36:47.560
So this is dynamic programming.

00:36:47.560 --> 00:36:48.510
Smaller code.

00:36:48.510 --> 00:36:50.480
This is the graph approach.

00:36:50.480 --> 00:36:52.650
They essentially
compute the same thing.

00:36:52.650 --> 00:36:55.714
This is more code,
this is less code.

00:36:55.714 --> 00:36:57.630
And if you see the
correspondence between them

00:36:57.630 --> 00:37:02.996
then you understand the
problem a little bit better.

00:37:02.996 --> 00:37:04.870
The main point is when
you have a new problem

00:37:04.870 --> 00:37:06.030
you can approach it either way.

00:37:06.030 --> 00:37:08.279
If you see the dynamic
programming solution right away

00:37:08.279 --> 00:37:09.610
write it down, you're done.

00:37:09.610 --> 00:37:10.980
If not, draw the graph.

00:37:10.980 --> 00:37:12.840
Think of what the state
is, draw the edges.

00:37:12.840 --> 00:37:14.990
And then after that
you can write the math.

00:37:19.350 --> 00:37:20.890
OK let's talk about
a new problem.

00:37:23.890 --> 00:37:28.080
Let's talk about the problem
that shows up on interviews.

00:37:28.080 --> 00:37:29.550
People excited about interviews?

00:37:43.780 --> 00:37:46.340
OK suppose you have a
sequence of numbers,

00:37:46.340 --> 00:37:47.760
I'm going to draw
a sequence here.

00:37:55.870 --> 00:37:58.560
And you want to
find the shortest

00:37:58.560 --> 00:38:00.720
increasing sub-sequence.

00:38:00.720 --> 00:38:04.040
So you get to choose some
numbers out of these numbers.

00:38:04.040 --> 00:38:07.950
And they have to form
an increasing sequence.

00:38:07.950 --> 00:38:13.750
So for example
this is a sequence.

00:38:13.750 --> 00:38:16.310
It happens to be increasing.

00:38:16.310 --> 00:38:18.790
This is also a sequence,
but it's not increasing.

00:38:18.790 --> 00:38:21.170
So it's not a valid answer.

00:38:21.170 --> 00:38:25.180
And I want the longest sequence,
the longest sub-sequence

00:38:25.180 --> 00:38:26.050
that is increasing.

00:38:31.620 --> 00:38:32.920
Does the problem make sense?

00:38:39.370 --> 00:38:41.110
How do we solve it?

00:38:41.110 --> 00:38:43.200
Do we want to solve it
using dynamic programming

00:38:43.200 --> 00:38:44.060
or using graphs?

00:38:48.600 --> 00:38:52.120
OK so votes for
dynamic programming.

00:38:52.120 --> 00:38:54.740
Votes for graph.

00:38:54.740 --> 00:38:56.820
Well too bad, it looks
prettier as a graph.

00:38:56.820 --> 00:38:59.660
So how do we solve it as a
dynamic programming problem?

00:39:02.407 --> 00:39:03.490
What are the sub-problems?

00:39:09.370 --> 00:39:13.060
AUDIENCE: The
largest sub-sequence

00:39:13.060 --> 00:39:14.812
PROFESSOR: Starting
somewhere, right?

00:39:20.220 --> 00:39:22.060
I'm going to go off
that answer because I

00:39:22.060 --> 00:39:24.990
know how to go off of it better.

00:39:24.990 --> 00:39:27.180
So say start here.

00:39:27.180 --> 00:39:29.940
Say start at 4.

00:39:29.940 --> 00:39:32.460
Or actually say I start at 3.

00:39:36.050 --> 00:39:37.780
I have two choices.

00:39:37.780 --> 00:39:39.520
5, which is closer to me.

00:39:39.520 --> 00:39:40.450
And 4.

00:39:40.450 --> 00:39:42.951
Well I have a few more choices,
but they're further away.

00:39:42.951 --> 00:39:43.450
Whatever.

00:39:47.720 --> 00:39:51.300
So these are my
choices starting at 3.

00:39:51.300 --> 00:39:53.930
If I decide that I'm
going to go from 3 to 4

00:39:53.930 --> 00:39:57.410
and the next number
I choose is 4,

00:39:57.410 --> 00:39:59.260
now I want the
longest sub-sequence

00:39:59.260 --> 00:40:01.180
starting at 4, right?

00:40:01.180 --> 00:40:03.060
It still has to be
longest sub-sequence.

00:40:03.060 --> 00:40:05.090
So from here on, no matter
what happened before,

00:40:05.090 --> 00:40:08.550
my behavior still
has to be optimal.

00:40:08.550 --> 00:40:12.600
If instead I chose 7, I don't
care what happened before.

00:40:12.600 --> 00:40:15.630
The behavior still
has to be optimal.

00:40:15.630 --> 00:40:19.551
So a sub-problem says
start at number i.

00:40:22.270 --> 00:40:27.510
So starting at number i.

00:40:27.510 --> 00:40:29.880
By the way we're going to
use zero-based indexing again

00:40:29.880 --> 00:40:31.770
because we like it.

00:40:36.840 --> 00:40:39.100
So starting at number
i, what's the longest

00:40:39.100 --> 00:40:40.750
increasing
sub-sequence I can get?

00:40:45.590 --> 00:40:49.860
So the length of the
blah, blah, blah.

00:40:49.860 --> 00:40:51.570
The length of,
you get the point.

00:40:56.570 --> 00:41:00.439
OK so I'm going to have
an array again, right?

00:41:00.439 --> 00:41:01.480
Which stores the answers.

00:41:01.480 --> 00:41:05.570
The array is going
to be named dp.

00:41:08.400 --> 00:41:11.580
If I have N numbers I'm going
to have N elements, from 0

00:41:11.580 --> 00:41:14.010
to N minus 1.

00:41:14.010 --> 00:41:17.470
Suppose I'm at element i.

00:41:17.470 --> 00:41:21.940
And suppose this original
array is called a.

00:41:21.940 --> 00:41:26.220
I'm in the mood for good
variable names today.

00:41:26.220 --> 00:41:27.755
So how do I compute dp if i?

00:41:36.700 --> 00:41:38.250
Let's write some
pseudocode for it.

00:41:42.250 --> 00:41:43.750
AUDIENCE: [INAUDIBLE]
N minus i--

00:41:47.242 --> 00:41:48.200
PROFESSOR: So what's h?

00:41:51.134 --> 00:41:56.520
AUDIENCE: The number of
steps we want to take--

00:41:56.520 --> 00:42:01.848
PROFESSOR: So if I'm going
from 3 to 4 h would be what?

00:42:01.848 --> 00:42:02.348
AUDIENCE: 2.

00:42:02.348 --> 00:42:03.894
3.

00:42:03.894 --> 00:42:05.310
PROFESSOR: OK so
I'm going to have

00:42:05.310 --> 00:42:06.740
to do additions
and subtractions,

00:42:06.740 --> 00:42:09.300
and this is going to confuse me.

00:42:09.300 --> 00:42:11.330
So how about I propose this.

00:42:11.330 --> 00:42:14.030
What you say is perfectly
valid, but instead, to make sure

00:42:14.030 --> 00:42:15.867
I don't make too
many mistakes, I'm

00:42:15.867 --> 00:42:17.450
going to look at the
number I land at.

00:42:17.450 --> 00:42:19.130
At the index directly.

00:42:19.130 --> 00:42:23.000
So I'm going to say I
start at i and end at j.

00:42:23.000 --> 00:42:25.590
So the next step is j.

00:42:25.590 --> 00:42:30.580
And then your h is j minus i.

00:42:30.580 --> 00:42:33.440
So I'm not going to look at the
number of numbers I hop over,

00:42:33.440 --> 00:42:36.390
all I care about
is where do I land.

00:42:36.390 --> 00:42:40.170
So what's the next number
in the sub-sequence?

00:42:40.170 --> 00:42:42.195
If I do it that way,
where do I start?

00:42:45.928 --> 00:42:47.910
AUDIENCE: i plus 1.

00:42:47.910 --> 00:42:49.950
So I can choose the same
number twice, right?

00:42:52.960 --> 00:42:54.920
So plus 1 to n.

00:42:54.920 --> 00:42:59.194
And then I'm going to have
a choices array here that I

00:42:59.194 --> 00:43:03.030
start, initialize with nothing.

00:43:03.030 --> 00:43:06.270
And then what's the
candidate, if I'm at j?

00:43:11.770 --> 00:43:16.875
So what answer am I looking at?

00:43:16.875 --> 00:43:19.850
AUDIENCE: dp of j.

00:43:19.850 --> 00:43:21.160
PROFESSOR: OK.

00:43:21.160 --> 00:43:23.690
So if I'm at i, and I'm
considering choosing j

00:43:23.690 --> 00:43:27.390
as the next element, then my
sequence will be-- my sequence

00:43:27.390 --> 00:43:33.490
length will be dp of j almost.

00:43:33.490 --> 00:43:34.970
Plus 1.

00:43:34.970 --> 00:43:40.290
OK, can I choose all the--
can I go through all the j's?

00:43:40.290 --> 00:43:45.670
Can I go from 3 to 2.

00:43:45.670 --> 00:43:47.995
AUDIENCE: No.

00:43:47.995 --> 00:43:52.560
The number at j
is greater than--

00:43:52.560 --> 00:43:58.360
PROFESSOR: If the number at j
is greater than the number at i

00:43:58.360 --> 00:44:01.730
then I have this new
choice, dp of j plus 1.

00:44:01.730 --> 00:44:04.644
What do I do with it?

00:44:04.644 --> 00:44:07.539
AUDIENCE: Stick it in choices.

00:44:07.539 --> 00:44:08.830
PROFESSOR: Stick it in choices.

00:44:13.196 --> 00:44:14.070
Sorry this is append.

00:44:18.300 --> 00:44:20.370
And afterwards?

00:44:20.370 --> 00:44:22.470
And by the way, this
thing is under the if.

00:44:25.047 --> 00:44:25.963
AUDIENCE: [INAUDIBLE].

00:44:37.940 --> 00:44:41.650
PROFESSOR: OK and I'm
missing one choice this way.

00:44:41.650 --> 00:44:45.070
What's my default choice?

00:44:45.070 --> 00:44:50.176
So what's the sequence
length if I just stay there?

00:44:50.176 --> 00:44:51.565
AUDIENCE: [INAUDIBLE].

00:44:51.565 --> 00:44:54.850
PROFESSOR: So if I decide to
not choose anything after 3

00:44:54.850 --> 00:44:58.900
then I have a number, 1.

00:44:58.900 --> 00:45:00.880
Small detail, again
one of those things

00:45:00.880 --> 00:45:05.510
that costs you one point
if you get it wrong.

00:45:05.510 --> 00:45:06.840
OK so I have a default.

00:45:06.840 --> 00:45:08.840
So I know that this is
going to be well-defined,

00:45:08.840 --> 00:45:12.470
and I have all my
possible choices.

00:45:12.470 --> 00:45:13.440
Yes?

00:45:13.440 --> 00:45:16.720
AUDIENCE: dp of j
representing a [INAUDIBLE].

00:45:16.720 --> 00:45:19.410
PROFESSOR: So it's
saying, if I'm at i,

00:45:19.410 --> 00:45:21.100
and the next number
in the sequence

00:45:21.100 --> 00:45:24.460
is j, what's the longest
sub-sequence-- the length

00:45:24.460 --> 00:45:27.090
of the longest
sub-sequence starting at j?

00:45:31.680 --> 00:45:36.260
So let's run the dp for
this example actually.

00:45:36.260 --> 00:45:39.350
Let's get a feel for why
it works and how it works.

00:45:39.350 --> 00:45:41.660
So I'm going to
copy it again here.

00:45:41.660 --> 00:45:44.850
8, 3, 5, 2, 4, 9, 7, 11.

00:45:47.960 --> 00:45:49.100
So this is a.

00:45:54.210 --> 00:45:55.440
And dp is here.

00:45:55.440 --> 00:45:59.130
Where do I start by the way?

00:45:59.130 --> 00:46:01.130
AUDIENCE: [INAUDIBLE].

00:46:01.130 --> 00:46:04.500
PROFESSOR: So I have
the algorithm here,

00:46:04.500 --> 00:46:07.360
how do I iterate?

00:46:07.360 --> 00:46:11.242
For i in--

00:46:11.242 --> 00:46:15.186
AUDIENCE: N minus N is 0.

00:46:15.186 --> 00:46:18.260
PROFESSOR: N minus
1 all the way to 0.

00:46:18.260 --> 00:46:21.164
So in this case we're going
to start at 11, right?

00:46:23.970 --> 00:46:26.810
The default choice is 1.

00:46:26.810 --> 00:46:28.180
Do I have any other choice?

00:46:28.180 --> 00:46:29.180
Can I go forward?

00:46:29.180 --> 00:46:30.630
Nope.

00:46:30.630 --> 00:46:31.740
So this is going to be 1.

00:46:34.510 --> 00:46:38.840
Now for 7 my array of
choices has a default of 1.

00:46:41.600 --> 00:46:46.360
And then for-- let me
write the indices too,

00:46:46.360 --> 00:46:49.160
so I don't get confused.

00:46:49.160 --> 00:46:53.210
0, 1, 2, 3, 4, 5, 6, 7.

00:46:53.210 --> 00:46:53.960
And these are i's.

00:46:56.800 --> 00:46:58.900
So we're at 7, i equals 6.

00:46:58.900 --> 00:47:04.880
For j equals 7, is a of
j greater than a of i?

00:47:04.880 --> 00:47:05.610
OK.

00:47:05.610 --> 00:47:09.890
So then 7, 11 is a
possible choice, right?

00:47:09.890 --> 00:47:14.670
So if I choose 11 as the
next point in my sequence,

00:47:14.670 --> 00:47:17.390
what's the total
sequence length?

00:47:17.390 --> 00:47:18.400
2.

00:47:18.400 --> 00:47:22.130
And 1 plus dp of 7 equals 2.

00:47:22.130 --> 00:47:22.880
So this is good.

00:47:22.880 --> 00:47:24.980
So far the answers add up.

00:47:24.980 --> 00:47:28.420
So I have 1 and 2
as my candidates

00:47:28.420 --> 00:47:30.210
for the answer 2dp of 6.

00:47:30.210 --> 00:47:33.880
What's the maximum?

00:47:33.880 --> 00:47:35.480
All right.

00:47:35.480 --> 00:47:36.800
Works so far.

00:47:36.800 --> 00:47:37.610
How about 9?

00:47:42.180 --> 00:47:43.960
What are the possible
answers for 9?

00:47:43.960 --> 00:47:45.160
So what's choices?

00:47:45.160 --> 00:47:47.520
First there's 1,
there's always 1.

00:47:47.520 --> 00:47:53.540
And then for j equals
6, will the if be true?

00:47:53.540 --> 00:47:54.210
No.

00:47:54.210 --> 00:47:56.020
I can't add a 7
after a 9, right?

00:47:56.020 --> 00:47:57.700
So go to the next one.

00:47:57.700 --> 00:48:02.094
For j equals 7,
will the if be true?

00:48:02.094 --> 00:48:03.510
So this append
will happen, right?

00:48:03.510 --> 00:48:05.430
What will be appended
in the array?

00:48:10.030 --> 00:48:13.940
And this means that if I'm at
9, and then the next element is

00:48:13.940 --> 00:48:17.930
11, the longest sequence
I can get has length 2.

00:48:17.930 --> 00:48:19.860
OK, what's the answer for 9?

00:48:22.740 --> 00:48:25.340
So if I start at 9 the
longest sequence I can make

00:48:25.340 --> 00:48:27.260
has length 2.

00:48:27.260 --> 00:48:28.170
Let's look at 4 now.

00:48:35.240 --> 00:48:37.520
AUDIENCE: [INAUDIBLE].

00:48:37.520 --> 00:48:39.930
PROFESSOR: What is?

00:48:39.930 --> 00:48:42.900
AUDIENCE: Just in general
that's-- the problem is defined

00:48:42.900 --> 00:48:46.170
as, OK in this case
you go from 9 to 11.

00:48:46.170 --> 00:48:49.944
Or do you have to go from
9 to the next element?

00:48:49.944 --> 00:48:51.860
PROFESSOR: So this is
the longest sub-sequence

00:48:51.860 --> 00:48:55.340
if I do-- so the longest
sub-sequence I get overall.

00:48:55.340 --> 00:48:57.960
I don't have to go
to the next element.

00:48:57.960 --> 00:49:01.810
So if my problem looks like
this, what is the best answer?

00:49:01.810 --> 00:49:03.440
AUDIENCE: It's
almost defined as--

00:49:03.440 --> 00:49:04.940
PROFESSOR: So the
problem is defined

00:49:04.940 --> 00:49:08.730
as, this is your first
element in the sub-sequence.

00:49:08.730 --> 00:49:11.154
What's the best
answer you can get?

00:49:11.154 --> 00:49:13.070
AUDIENCE: I thought in
that case it would be 1

00:49:13.070 --> 00:49:15.236
because there's nothing
following it that's greater.

00:49:17.334 --> 00:49:18.750
PROFESSOR: This
is greater, right?

00:49:18.750 --> 00:49:19.950
AUDIENCE: Unless it skips.

00:49:19.950 --> 00:49:22.600
PROFESSOR: So it's a
sub-sequence, not a sub-string,

00:49:22.600 --> 00:49:24.390
which means it can skip.

00:49:24.390 --> 00:49:27.260
I hope I got these right.

00:49:27.260 --> 00:49:29.220
So you can skip,
otherwise the answer

00:49:29.220 --> 00:49:33.370
would be a bit
easier to compute.

00:49:33.370 --> 00:49:34.380
OK how about 4?

00:49:43.230 --> 00:49:45.850
So let's start with 1
because that's the easy one.

00:49:45.850 --> 00:49:48.359
And then?

00:49:48.359 --> 00:49:50.724
AUDIENCE: 1, 3, 3, 2, right?

00:49:50.724 --> 00:49:52.390
Because it's going
to be 3 for that one.

00:49:52.390 --> 00:49:53.104
PROFESSOR: OK.

00:49:53.104 --> 00:49:54.520
AUDIENCE: And then
3 for this one.

00:49:54.520 --> 00:49:55.850
PROFESSOR: 3 for this one.

00:49:55.850 --> 00:49:57.660
AUDIENCE: And then 2.

00:49:57.660 --> 00:50:00.370
PROFESSOR: So all these
are bigger, so all of them

00:50:00.370 --> 00:50:01.740
are possible next candidates.

00:50:01.740 --> 00:50:03.560
And these are the
sequence lengths

00:50:03.560 --> 00:50:05.470
that I can get if I choose them.

00:50:05.470 --> 00:50:06.755
Final answer?

00:50:06.755 --> 00:50:09.030
AUDIENCE: 3.

00:50:09.030 --> 00:50:10.646
PROFESSOR: 3 maximum.

00:50:10.646 --> 00:50:13.170
AUDIENCE: But for setting
the parent pointers

00:50:13.170 --> 00:50:16.330
you'd want to take the
closest thing, right?

00:50:16.330 --> 00:50:18.577
PROFESSOR: As long as it's
a maximum I don't care.

00:50:21.200 --> 00:50:25.140
So what are possible
parent pointers here?

00:50:25.140 --> 00:50:26.460
The 2's, right?

00:50:26.460 --> 00:50:27.910
So either this or this.

00:50:27.910 --> 00:50:29.932
Do I care which one I chose?

00:50:29.932 --> 00:50:31.652
AUDIENCE: No, I guess I don't.

00:50:31.652 --> 00:50:33.110
PROFESSOR: As long
as I choose a 2.

00:50:33.110 --> 00:50:34.650
From a 3 I know I
have to go to a 2.

00:50:34.650 --> 00:50:36.280
I can't go to 1
because otherwise it

00:50:36.280 --> 00:50:38.450
wouldn't be as long as possible.

00:50:38.450 --> 00:50:40.850
And then from 2's
I have to go to 1,

00:50:40.850 --> 00:50:43.700
and I don't care which one.

00:50:43.700 --> 00:50:46.800
OK how about 2, what's dp of 2?

00:50:50.110 --> 00:50:51.250
Does everyone else see it?

00:50:54.880 --> 00:50:57.310
So these are all
possible choices

00:50:57.310 --> 00:50:59.490
because they're
all bigger than 2.

00:50:59.490 --> 00:51:04.750
And I get 1 if I don't
choose anything, 4, 3, 3, 2.

00:51:04.750 --> 00:51:07.727
So 4 is the biggest answer.

00:51:07.727 --> 00:51:10.060
Let's look at this one, this
one's a bit interesting, 5.

00:51:10.060 --> 00:51:12.360
So what are the choices here?

00:51:12.360 --> 00:51:14.115
1 if I don't look
at anything else.

00:51:14.115 --> 00:51:14.615
Then?

00:51:20.740 --> 00:51:24.030
There's a 3, 4, then 9.

00:51:24.030 --> 00:51:24.860
A 3, 4, then 7.

00:51:24.860 --> 00:51:26.710
And?

00:51:26.710 --> 00:51:28.970
And a 2 for the 11.

00:51:28.970 --> 00:51:33.240
So this if is going to skip
these two elements, which

00:51:33.240 --> 00:51:35.770
I can't use to make an
increasing sub-sequence.

00:51:35.770 --> 00:51:37.590
And then it's going
to look at these ones,

00:51:37.590 --> 00:51:41.290
and it's going to add
1 to the numbers here.

00:51:41.290 --> 00:51:41.850
And I get 3.

00:51:44.390 --> 00:51:45.540
OK.

00:51:45.540 --> 00:51:48.031
What is the answer for 3?

00:51:48.031 --> 00:51:50.404
AUDIENCE: 4.

00:51:50.404 --> 00:51:52.070
PROFESSOR: And what
is the answer for 8?

00:51:56.038 --> 00:51:58.520
AUDIENCE: 3.

00:51:58.520 --> 00:52:01.700
PROFESSOR: Right, the
choices are 9 and 11.

00:52:01.700 --> 00:52:04.940
Starting with itself
and then 9 and 11.

00:52:04.940 --> 00:52:08.040
So now what's the longest--
what's the answer overall

00:52:08.040 --> 00:52:08.840
for this problem?

00:52:12.040 --> 00:52:14.330
So it's not dp of 0, right?

00:52:14.330 --> 00:52:15.980
Before when I had
blackjack I knew

00:52:15.980 --> 00:52:18.420
that I have to start
at the first card.

00:52:18.420 --> 00:52:20.780
So the answer was dp of 0.

00:52:20.780 --> 00:52:23.720
In this case it's not
dp 0, it's the maximum

00:52:23.720 --> 00:52:26.290
of all the dp's here.

00:52:26.290 --> 00:52:29.111
Because I can start my
sequence anywhere I want.

00:52:29.111 --> 00:52:30.360
So I have to take the maximum.

00:52:30.360 --> 00:52:32.800
And that's the overall answer,
which in this case is 4.

00:52:35.880 --> 00:52:38.220
OK does it make sense now?

00:52:38.220 --> 00:52:39.910
Somewhat?

00:52:39.910 --> 00:52:41.950
So if you don't
understand please look

00:52:41.950 --> 00:52:44.130
at how you'd represent
this as a graph.

00:52:44.130 --> 00:52:46.260
The idea is that the
numbers are nodes

00:52:46.260 --> 00:52:48.460
and you draw an edge
between numbers,

00:52:48.460 --> 00:52:52.110
where the first number is
smaller than the second number.

00:52:52.110 --> 00:52:55.500
Write that formulation, write
the shortest path for that,

00:52:55.500 --> 00:52:58.310
and see how that
matches to this.