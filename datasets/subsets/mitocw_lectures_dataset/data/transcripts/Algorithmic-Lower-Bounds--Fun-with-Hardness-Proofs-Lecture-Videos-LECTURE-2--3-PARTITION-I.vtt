WEBVTT

00:00:00.080 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.820
Commons license.

00:00:03.820 --> 00:00:06.060
Your support will help
MIT OpenCourseWare

00:00:06.060 --> 00:00:10.150
continue to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.305
at ocw.mit.edu.

00:00:25.634 --> 00:00:27.050
PROFESSOR: All
right, are you guys

00:00:27.050 --> 00:00:30.490
ready for some more
hardness proofs?

00:00:30.490 --> 00:00:32.770
Let's do it.

00:00:32.770 --> 00:00:36.255
So today, we start the
universe of 3 partition.

00:00:38.780 --> 00:00:44.110
And in general, we're
going to see today

00:00:44.110 --> 00:00:48.390
2 plus problems, which
are useful for dealing

00:00:48.390 --> 00:00:57.880
with numbers for reducing
to number problems.

00:00:57.880 --> 00:01:05.610
Numbers here are going to be
integers for the most part.

00:01:05.610 --> 00:01:07.405
Usually in complexity,
it's a lot easier

00:01:07.405 --> 00:01:09.470
to think of all your
numbers being integers.

00:01:09.470 --> 00:01:11.720
If they're not integers, use
fixed point or rationals,

00:01:11.720 --> 00:01:14.340
and then they're
basically integers.

00:01:14.340 --> 00:01:15.730
So we're going to talk.

00:01:15.730 --> 00:01:17.790
My favorite is 3 partition.

00:01:17.790 --> 00:01:21.270
And pretty much all the proofs
we'll do in the number context

00:01:21.270 --> 00:01:24.187
will be reduction
from 3 partition.

00:01:24.187 --> 00:01:26.020
This is all about
NP-hardness, I should say.

00:01:31.840 --> 00:01:33.414
But before we get
to e partition,

00:01:33.414 --> 00:01:35.330
I'm going to talk about
another problem, which

00:01:35.330 --> 00:01:36.525
is called 2 partition.

00:01:45.726 --> 00:01:48.100
First, I'll just have to define
all these problems, which

00:01:48.100 --> 00:01:49.141
will take a little while.

00:01:49.141 --> 00:01:51.400
Then we'll get to all
the fun reductions.

00:01:51.400 --> 00:01:54.545
So in 2 partition,
your given n integers.

00:01:59.470 --> 00:02:02.140
We'll call the set
of them capital A

00:02:02.140 --> 00:02:07.016
and we'll call the integers
themselves little a sub i--

00:02:07.016 --> 00:02:10.259
i from 1 to n, let's say.

00:02:10.259 --> 00:02:14.980
And what we'd like to do is
partition them into two groups.

00:02:19.380 --> 00:02:27.500
Let's say A1 and A2
equals A of equal sum.

00:02:33.710 --> 00:02:35.850
We want the sum of
the integers in A1

00:02:35.850 --> 00:02:38.870
to equal the sum of
the integers in A2.

00:02:38.870 --> 00:02:43.820
And therefore, they will
equal one half the total sum.

00:02:43.820 --> 00:02:46.970
OK, so we just want to find
our choice for each number.

00:02:46.970 --> 00:02:49.310
Should it go in A1 or A2?

00:02:49.310 --> 00:02:51.720
So this problem is NP-hard.

00:02:51.720 --> 00:02:54.650
And it's one of the
original Karp problems.

00:02:54.650 --> 00:02:58.402
There's this famous
paper by Karp in 1972.

00:02:58.402 --> 00:02:59.985
Before that, there
was a paper by Cook

00:02:59.985 --> 00:03:02.220
that proved SAT is NP-complete.

00:03:02.220 --> 00:03:05.990
And then Karp wrote a paper
with a zillion-- not literally,

00:03:05.990 --> 00:03:10.120
but dozens of NP-hardness
proofs from SAT

00:03:10.120 --> 00:03:11.447
to things like 2 partition.

00:03:11.447 --> 00:03:12.780
I will not cover the proof here.

00:03:12.780 --> 00:03:14.960
If you're interested in
it, read Garey and Johnson.

00:03:14.960 --> 00:03:18.630
There's some nice coverage
of this problem and all

00:03:18.630 --> 00:03:21.750
the problems we'll be
talking about today.

00:03:21.750 --> 00:03:22.620
OK.

00:03:22.620 --> 00:03:30.810
As a sideline, I'll mention
there is a generalization

00:03:30.810 --> 00:03:32.560
of this problem.

00:03:32.560 --> 00:03:33.810
So it's also NP-hard.

00:03:33.810 --> 00:03:37.610
Any generalization is
going to be even harder.

00:03:37.610 --> 00:03:38.860
But it's useful to know about.

00:03:38.860 --> 00:03:40.060
It's called subset sum.

00:03:40.060 --> 00:03:42.620
Occasionally it's
easier to think

00:03:42.620 --> 00:03:44.300
about subset sum
instead of partition,

00:03:44.300 --> 00:03:45.680
although it's a generalization.

00:03:45.680 --> 00:03:47.490
So if you can reduce
from subset sum,

00:03:47.490 --> 00:03:50.140
you can also reduce
from partition.

00:03:50.140 --> 00:03:53.260
And here the set up is similar.

00:03:53.260 --> 00:03:57.300
You're given n integers
again, just like before.

00:04:00.340 --> 00:04:01.960
And you're given a target sum.

00:04:01.960 --> 00:04:04.400
This is one other integer.

00:04:04.400 --> 00:04:06.205
We'll call the target sum t.

00:04:06.205 --> 00:04:09.290
I'll also call this t.

00:04:09.290 --> 00:04:17.540
And what we'd like to do is find
a subset S of A whose sum is t.

00:04:24.790 --> 00:04:26.600
OK, this is a strict
generalization here.

00:04:26.600 --> 00:04:29.170
You're not given a number
t, but you're essentially

00:04:29.170 --> 00:04:36.010
choosing a subset A1, whose
sum equals the sum of A over 2.

00:04:36.010 --> 00:04:38.430
So this is really just a
particular choice of t.

00:04:38.430 --> 00:04:41.300
This is the general case
where you're given t.

00:04:41.300 --> 00:04:43.762
So this is harder than that.

00:04:43.762 --> 00:04:44.970
But it's worth knowing about.

00:04:44.970 --> 00:04:47.700
In particular, there's
a problem set problem,

00:04:47.700 --> 00:04:50.460
the problem set will be
out in a couple of hours.

00:04:50.460 --> 00:04:53.490
And it's a little easier
to think about subset sum,

00:04:53.490 --> 00:04:54.020
we think.

00:04:54.020 --> 00:04:54.810
You don't have to.

00:04:57.870 --> 00:05:04.010
All right, so let's
go to 3 partition,

00:05:04.010 --> 00:05:07.670
my favorite NP-complete problem.

00:05:07.670 --> 00:05:18.020
So start is the same,
given integers A1 up to An.

00:05:21.770 --> 00:05:24.210
We're not given a target sum.

00:05:24.210 --> 00:05:26.510
What we'd like to
do is partition

00:05:26.510 --> 00:05:33.720
them-- partition that set
A into how many pieces?

00:05:33.720 --> 00:05:34.250
AUDIENCE: 3.

00:05:34.250 --> 00:05:34.980
PROFESSOR: 3.

00:05:34.980 --> 00:05:35.910
Nope.

00:05:35.910 --> 00:05:36.630
n over 3.

00:05:39.980 --> 00:05:42.380
Kind of like 3.

00:05:42.380 --> 00:05:44.260
Not quite.

00:05:44.260 --> 00:05:52.680
Let's say sets A1,
n over 3 equals

00:05:52.680 --> 00:05:56.740
A. I'm using union with a dot
to indicate it's disjoint union.

00:05:56.740 --> 00:05:59.060
So that's what a
partition means.

00:05:59.060 --> 00:05:59.799
That's redundant.

00:05:59.799 --> 00:06:01.090
This is old fashioned notation.

00:06:01.090 --> 00:06:03.450
You probably haven't seen it,
but when I was growing up,

00:06:03.450 --> 00:06:06.630
that was the
notation of the day.

00:06:06.630 --> 00:06:13.220
Then we have n over 3 sets.

00:06:13.220 --> 00:06:15.270
Cool, yeah, assume
n is divisible by 3.

00:06:15.270 --> 00:06:16.530
Otherwise the answer is no.

00:06:19.160 --> 00:06:22.930
And then this is the
easy case of equal sum.

00:06:27.260 --> 00:06:32.810
So we want the sum of
each Ai to be equal to t,

00:06:32.810 --> 00:06:35.410
which is to the same thing.

00:06:35.410 --> 00:06:38.750
They're just going to be the sum
of the A's divided by n over 3.

00:06:41.530 --> 00:06:44.580
OK, if this problem were
about partitioning to 3 sets,

00:06:44.580 --> 00:06:46.580
it would not be
very interesting.

00:06:46.580 --> 00:06:48.950
It would be basically
identical to 2 partition.

00:06:48.950 --> 00:06:51.530
With n over 3 sets, things
are quite a bit different.

00:06:51.530 --> 00:06:55.000
And we will get to that
difference in a moment.

00:06:55.000 --> 00:06:57.880
But first, let me tell
you about some fun

00:06:57.880 --> 00:07:00.732
facts about 3 partition.

00:07:00.732 --> 00:07:02.440
So we're partitioning
into n over 3 sets,

00:07:02.440 --> 00:07:04.680
so you would expect, on
average, most of these sets

00:07:04.680 --> 00:07:06.390
will have size 3.

00:07:06.390 --> 00:07:09.560
In fact, you could make all
the sets have size exactly 3,

00:07:09.560 --> 00:07:14.060
because if you look at the
reduction for this problem,

00:07:14.060 --> 00:07:27.980
you can assume that each Ai
is strictly between t over 4

00:07:27.980 --> 00:07:31.040
and t over 2.

00:07:31.040 --> 00:07:33.390
OK, if you're going to
have a set of numbers

00:07:33.390 --> 00:07:37.280
that's summed to exactly
t and each of them

00:07:37.280 --> 00:07:38.950
is strictly bigger
than t over 4,

00:07:38.950 --> 00:07:40.620
then that means you
can't have 4 of them

00:07:40.620 --> 00:07:42.230
because you would
sum to too much.

00:07:42.230 --> 00:07:44.299
And they're strictly
less than t over 2.

00:07:44.299 --> 00:07:46.590
And you can't just have 2 of
them and hope to get to t.

00:07:46.590 --> 00:07:49.100
So you have to have
exactly 3 in every set.

00:07:56.181 --> 00:07:57.430
You don't have to assume that.

00:07:57.430 --> 00:07:59.706
In some situations, it's
useful to just say, well,

00:07:59.706 --> 00:08:01.830
the Ai's are sum sets that
sum to the right things.

00:08:01.830 --> 00:08:04.360
Sometimes it useful to
assume that they're triples.

00:08:04.360 --> 00:08:06.240
It's up to you
whether you consider

00:08:06.240 --> 00:08:07.990
that part of the
problem statement,

00:08:07.990 --> 00:08:10.420
to ask for the Ai's
to have size 3 or not.

00:08:10.420 --> 00:08:12.770
And it's useful to have both.

00:08:12.770 --> 00:08:16.020
In fact, once you
have this, you can

00:08:16.020 --> 00:08:17.720
make all the Ai's
very, very close

00:08:17.720 --> 00:08:22.480
to t over 3 using a trick,
which we'll see a bunch of times

00:08:22.480 --> 00:08:23.950
today.

00:08:23.950 --> 00:08:31.820
So let's say you could add--
I'll call it infinity--

00:08:31.820 --> 00:08:32.630
to each Ai.

00:08:35.740 --> 00:08:39.299
In that case, of course, any
solution that you had before

00:08:39.299 --> 00:08:41.990
is still a solution.

00:08:41.990 --> 00:08:45.210
Just think of infinity
is a really large number,

00:08:45.210 --> 00:08:48.700
something like n
to the 100 times

00:08:48.700 --> 00:08:53.470
maximum item in A.
Something like that.

00:08:53.470 --> 00:08:56.265
That's really maybe to the
100th power, if you want,

00:08:56.265 --> 00:08:58.610
but a really big number.

00:08:58.610 --> 00:09:00.100
This will preserve
all solutions,

00:09:00.100 --> 00:09:02.805
because all solutions, every
set has size exactly 3.

00:09:02.805 --> 00:09:04.430
So if you had 3 times
infinity, they'll

00:09:04.430 --> 00:09:06.010
still have the same sums.

00:09:06.010 --> 00:09:08.160
And when you do that,
then all the Ai's

00:09:08.160 --> 00:09:10.240
are basically equal
to each other,

00:09:10.240 --> 00:09:13.380
which means they're
roughly equal to t over 3.

00:09:13.380 --> 00:09:15.942
The leading term is
the same for everybody.

00:09:15.942 --> 00:09:17.400
And then there's
this little noise,

00:09:17.400 --> 00:09:21.770
which was the original integer
that you're adding onto,

00:09:21.770 --> 00:09:24.600
that infinity.

00:09:24.600 --> 00:09:27.060
So then all the adds
are roughly t over 3.

00:09:27.060 --> 00:09:29.770
Cool.

00:09:29.770 --> 00:09:32.090
Let me tell you about a
couple related problems

00:09:32.090 --> 00:09:32.715
to 3 partition.

00:09:32.715 --> 00:09:35.980
And then I'll tell
you why we're even

00:09:35.980 --> 00:09:40.040
bothering to talk about two
problems instead of just one.

00:09:54.310 --> 00:09:57.470
So next problem has a funny
name, especially when you don't

00:09:57.470 --> 00:09:58.970
know what 3 dimensional
matching is,

00:09:58.970 --> 00:10:00.680
but we will get to that second.

00:10:00.680 --> 00:10:03.070
Don't worry about the
name for the moment.

00:10:03.070 --> 00:10:05.800
This is a closely
related problem.

00:10:05.800 --> 00:10:09.285
It's really a specialization
of 3 partition.

00:10:17.836 --> 00:10:20.210
In this case, we're going to
be given 3 sets of integers.

00:10:28.050 --> 00:10:30.720
And what we'd like to
do is-- it's basically

00:10:30.720 --> 00:10:31.590
the same problem.

00:10:31.590 --> 00:10:33.215
Just think of taking
the union of those

00:10:33.215 --> 00:10:36.810
sets, but each of these
sets that we're choosing,

00:10:36.810 --> 00:10:39.790
the Ai's, should consist of
one element from A, one element

00:10:39.790 --> 00:10:42.070
from B, one element from c.

00:10:42.070 --> 00:10:44.714
So how did I formalize that?

00:10:44.714 --> 00:10:45.630
Let's say a partition.

00:10:53.220 --> 00:11:08.040
This is a disjoint union into
triples, Si, and cross product

00:11:08.040 --> 00:11:09.620
ABC.

00:11:09.620 --> 00:11:13.340
So you're choosing one from
each of these guys in each Si,

00:11:13.340 --> 00:11:14.680
and they should be of equal sum.

00:11:20.450 --> 00:11:26.220
And so the sum will be sum of A
plus the sum of B plus sum of C

00:11:26.220 --> 00:11:31.880
divided by n , I think,
because there's 3 of them.

00:11:34.720 --> 00:11:35.940
Cool.

00:11:35.940 --> 00:11:37.720
OK, so almost the
same problem, I just

00:11:37.720 --> 00:11:39.770
changed what n was
by a factor of 3.

00:11:39.770 --> 00:11:44.090
That's why there's n over
3 here and then here.

00:11:44.090 --> 00:11:46.980
But here, we're
specializing in a sense

00:11:46.980 --> 00:11:51.560
to say that we're giving
different types of numbers--

00:11:51.560 --> 00:11:53.180
the red integers,
the green integers,

00:11:53.180 --> 00:11:54.096
and the blue integers.

00:11:54.096 --> 00:11:56.790
You have to choose
one of each color.

00:11:56.790 --> 00:12:06.450
OK, for fun, let me show you why
this problem is, in some sense,

00:12:06.450 --> 00:12:06.950
simpler.

00:12:17.090 --> 00:12:19.670
This also gives you
a useful technique

00:12:19.670 --> 00:12:22.130
for playing with
these number problems.

00:12:22.130 --> 00:12:25.304
So I want to reduce from
this numerical 3 dimensional

00:12:25.304 --> 00:12:27.095
matching problem, which
you might also call

00:12:27.095 --> 00:12:29.740
the ABC version of 3 partition.

00:12:29.740 --> 00:12:31.930
I will reduce it to 3 partition.

00:12:31.930 --> 00:12:36.794
So I'm given an
instance, these numbers.

00:12:36.794 --> 00:12:39.210
So the basic idea is to take
these numbers just throw them

00:12:39.210 --> 00:12:41.870
into one big set, A prime.

00:12:41.870 --> 00:12:44.410
But I want to force
this ABC property

00:12:44.410 --> 00:12:47.170
that I choose one from each.

00:12:47.170 --> 00:12:48.300
Maybe any suggestions how?

00:12:48.300 --> 00:12:48.800
Yeah.

00:12:48.800 --> 00:12:50.622
AUDIENCE: Well, I
just have a question.

00:12:50.622 --> 00:12:51.830
You define these all as sets.

00:12:51.830 --> 00:12:53.614
You can't have
duplicates of an integer?

00:12:53.614 --> 00:12:55.155
PROFESSOR: I didn't
say the word set.

00:12:55.155 --> 00:12:57.990
I actually meant multiset.

00:12:57.990 --> 00:13:01.190
Yeah, so this is a multiset.

00:13:01.190 --> 00:13:04.130
Good question.

00:13:04.130 --> 00:13:05.671
All of them are multisets.

00:13:05.671 --> 00:13:07.920
So it makes the notion of
disunion a little bit weird.

00:13:07.920 --> 00:13:11.100
But you know what I mean.

00:13:11.100 --> 00:13:11.870
Yeah.

00:13:11.870 --> 00:13:13.968
AUDIENCE: Could you add a
really big number to all

00:13:13.968 --> 00:13:16.839
the B's and twice that really
big number to all the C's?

00:13:16.839 --> 00:13:18.880
PROFESSOR: OK, add a--
hadn't thought about this.

00:13:18.880 --> 00:13:21.480
So add a really big number to
all the B's, and then twice

00:13:21.480 --> 00:13:22.850
that big number to all the C's.

00:13:25.680 --> 00:13:29.800
And then the target sum would
be three times the big number,

00:13:29.800 --> 00:13:30.300
plus--

00:13:30.300 --> 00:13:32.872
AUDIENCE: I'm sorry, so
make it three instead,

00:13:32.872 --> 00:13:34.902
so you can't do three
things from each side.

00:13:34.902 --> 00:13:35.860
PROFESSOR: Yeah, right.

00:13:35.860 --> 00:13:41.360
So you don't want take two B's
and then that looks like a C.

00:13:41.360 --> 00:13:46.160
So maybe you want three
times a big number here

00:13:46.160 --> 00:13:49.697
and nine times a
big number here.

00:13:49.697 --> 00:13:50.530
Something like that.

00:13:50.530 --> 00:13:52.880
I think actually one times
a big number and three

00:13:52.880 --> 00:13:54.270
times a big number would do it.

00:13:54.270 --> 00:13:55.930
Yeah, cool.

00:13:55.930 --> 00:13:58.559
So the way I did it in the
notes was adding a small number,

00:13:58.559 --> 00:13:59.600
but either way, it works.

00:13:59.600 --> 00:14:03.070
Let's do it with the big
number, because that's fun.

00:14:09.040 --> 00:14:14.940
So we will construct, I'll
call it A prime to consist

00:14:14.940 --> 00:14:22.010
of a overall little a and big
A. And then we'll say a plus--

00:14:22.010 --> 00:14:24.200
usually big number I
write with a capital B,

00:14:24.200 --> 00:14:26.575
but that's not very good
because we already have a couple

00:14:26.575 --> 00:14:27.210
of B's.

00:14:27.210 --> 00:14:32.460
So I'll call it X. Or I
should call it infinity

00:14:32.460 --> 00:14:34.300
for consistency.

00:14:34.300 --> 00:14:39.680
So for each b and B, I
will add infinity to it.

00:14:39.680 --> 00:14:48.171
And then c is going to be is
3 times-- let's do 4 times

00:14:48.171 --> 00:14:48.670
infinity.

00:14:48.670 --> 00:14:51.810
It makes me feel a
little safer somehow,

00:14:51.810 --> 00:14:54.420
because we're constructing
a set of size 3.

00:14:54.420 --> 00:14:56.970
So if you take 3 of these,
I worry that looks like a C.

00:14:56.970 --> 00:15:00.440
It's not enough,
but we'll be safe.

00:15:00.440 --> 00:15:01.570
Why not?

00:15:01.570 --> 00:15:04.560
We can choose pretty
big numbers here.

00:15:04.560 --> 00:15:07.635
So happy?

00:15:07.635 --> 00:15:09.431
No?

00:15:09.431 --> 00:15:11.379
AUDIENCE: You might be
able to do a couple A's

00:15:11.379 --> 00:15:12.840
in a single set.

00:15:12.840 --> 00:15:17.230
The set should be small, because
they're not-- [INAUDIBLE].

00:15:17.230 --> 00:15:17.930
PROFESSOR: OK.

00:15:17.930 --> 00:15:18.830
a is our problem.

00:15:18.830 --> 00:15:21.950
You could maybe do
more than 3 total.

00:15:21.950 --> 00:15:28.620
So let's do 1 infinity,
then get a proper eraser.

00:15:28.620 --> 00:15:32.970
It's a good thing we have Sarah
here to correct our proofs.

00:15:32.970 --> 00:15:37.672
3 infinity 9.

00:15:37.672 --> 00:15:40.017
AUDIENCE: I think it's
enough, because then we need--

00:15:40.017 --> 00:15:42.100
PROFESSOR: 6 would be bad,
because then 2 of these

00:15:42.100 --> 00:15:43.075
would be 1 of those.

00:15:43.075 --> 00:15:47.040
AUDIENCE: 13 infinities
on [INAUDIBLE].

00:15:47.040 --> 00:15:51.660
PROFESSOR: Right, so this
means the new target sum should

00:15:51.660 --> 00:15:57.160
be the old target sum, which
was the sum of these divided

00:15:57.160 --> 00:16:01.010
by n, plus 13 infinity.

00:16:04.757 --> 00:16:07.080
AUDIENCE: Isn't infinity
a function of the n's?

00:16:07.080 --> 00:16:09.310
PROFESSOR: Infinity
I should define.

00:16:09.310 --> 00:16:16.087
Let's make it, I think,
just like 10 times max

00:16:16.087 --> 00:16:16.920
of A ought to do it.

00:16:19.630 --> 00:16:21.395
You could be it as
a function of n.

00:16:21.395 --> 00:16:23.895
I don't think that's necessary
here, because all of our sets

00:16:23.895 --> 00:16:24.960
are size 3.

00:16:24.960 --> 00:16:27.700
But if you're doing something
like this for 2 partition,

00:16:27.700 --> 00:16:30.340
you'd want to multiply
by n or n squared.

00:16:30.340 --> 00:16:34.110
This is a common trick to
do this kind of scaling

00:16:34.110 --> 00:16:36.416
or offsets or things like that.

00:16:36.416 --> 00:16:37.790
Instead of infinity
here, you can

00:16:37.790 --> 00:16:40.562
write epsilon, where epsilon
is much smaller than 1.

00:16:40.562 --> 00:16:41.770
I think that would also work.

00:16:41.770 --> 00:16:43.390
And that's what's done in this.

00:16:43.390 --> 00:16:45.414
AUDIENCE: So we just
make it the max of the A

00:16:45.414 --> 00:16:47.184
as opposed to A prime?

00:16:47.184 --> 00:16:49.350
PROFESSOR: Oops, this should
probably be max of ABC.

00:16:53.080 --> 00:16:55.410
Yeah, you can't make
it max of A prime.

00:16:55.410 --> 00:16:56.310
That would be cyclic.

00:16:56.310 --> 00:16:58.020
That infinity would
actually be infinite.

00:17:00.530 --> 00:17:01.030
Good.

00:17:01.030 --> 00:17:02.410
So I think that works.

00:17:02.410 --> 00:17:04.220
There are things to
check here, obviously.

00:17:04.220 --> 00:17:06.182
We need to check
that whenever we

00:17:06.182 --> 00:17:07.890
have a solution to
the original instance,

00:17:07.890 --> 00:17:09.390
we have a solution
to this instance.

00:17:09.390 --> 00:17:10.230
That's pretty clear.

00:17:10.230 --> 00:17:14.030
You just take the same choices
of the Ai's, Bi's, and Ci's.

00:17:14.030 --> 00:17:17.940
And the infinities will
always add up to 13.

00:17:17.940 --> 00:17:19.805
The tricky part is
to show that if you

00:17:19.805 --> 00:17:21.680
have a solution to this
3 partition instance,

00:17:21.680 --> 00:17:25.079
you can convert that back into
a solution to the numerical 3

00:17:25.079 --> 00:17:26.949
dimensional matching instance.

00:17:26.949 --> 00:17:28.490
And that's where
you essentially want

00:17:28.490 --> 00:17:30.865
to show that the infinities
can be treated algebraically.

00:17:30.865 --> 00:17:32.770
Because they're so
huge, you could never

00:17:32.770 --> 00:17:34.470
construct an infinity
in another way.

00:17:37.090 --> 00:17:39.910
But I'll leave that as an
exercise to actually proof,

00:17:39.910 --> 00:17:42.410
because we're not really going
to use this problem too much.

00:17:42.410 --> 00:17:44.284
You're welcome to,
maybe on problem sets,

00:17:44.284 --> 00:17:45.950
maybe on open problems
it would be good.

00:17:45.950 --> 00:17:50.290
But most the time, I would
say we use 3 partition.

00:17:50.290 --> 00:17:52.430
I want you to know about
this in particular,

00:17:52.430 --> 00:17:54.520
because it's related to
another problem, which is

00:17:54.520 --> 00:17:55.770
called 3 dimensional matching.

00:18:00.550 --> 00:18:01.220
Yes?

00:18:01.220 --> 00:18:04.100
AUDIENCE: Is the
assumption that the Ai

00:18:04.100 --> 00:18:06.760
is all a cardinality of 3 built
into the problem specification

00:18:06.760 --> 00:18:07.290
here?

00:18:07.290 --> 00:18:07.960
PROFESSOR: You get a choice.

00:18:07.960 --> 00:18:09.660
You can either make
this part of the problem

00:18:09.660 --> 00:18:10.540
specification or not.

00:18:10.540 --> 00:18:11.824
It won't matter.

00:18:11.824 --> 00:18:13.490
AUDIENCE: OK, well I
think in this case,

00:18:13.490 --> 00:18:15.162
if you don't know
the problem specs,

00:18:15.162 --> 00:18:18.320
can you take 12
A's for something?

00:18:18.320 --> 00:18:20.730
And then you get 12
infinities and then

00:18:20.730 --> 00:18:22.200
they add up to another infinity?

00:18:22.200 --> 00:18:23.616
PROFESSOR: Yes,
we definitely want

00:18:23.616 --> 00:18:26.060
to take this as part
of the specification

00:18:26.060 --> 00:18:27.030
for this reduction.

00:18:27.030 --> 00:18:27.940
Yeah.

00:18:27.940 --> 00:18:28.440
Good point.

00:18:32.070 --> 00:18:36.570
OK, so here's a problem.

00:18:36.570 --> 00:18:39.440
You've probably heard
of the matching problem.

00:18:39.440 --> 00:18:42.150
Let's say the perfect matching
problem is you're given a graph

00:18:42.150 --> 00:18:44.480
and you want to find a set
of edges which are disjoint,

00:18:44.480 --> 00:18:48.150
meaning no two edges
share a vertex, that

00:18:48.150 --> 00:18:49.320
covers all the vertices.

00:18:49.320 --> 00:18:50.670
So if you have n
vertices, you'd like

00:18:50.670 --> 00:18:53.060
to find n over 2 edges that
are disjoint from each other.

00:18:53.060 --> 00:18:54.172
That's perfect matching.

00:18:54.172 --> 00:18:55.880
You might call it 2
dimensional matching,

00:18:55.880 --> 00:18:57.930
because an edge has 2 ends.

00:18:57.930 --> 00:19:01.470
3 dimensional matching takes
place in a hyper graph.

00:19:01.470 --> 00:19:07.740
And in this case, it's going
to be a tripartite hyper graph.

00:19:15.970 --> 00:19:17.720
You may not have seen
hyper graphs before.

00:19:17.720 --> 00:19:19.178
They're just like
graphs, but edges

00:19:19.178 --> 00:19:20.680
can have more than 2 endpoints.

00:19:20.680 --> 00:19:23.960
In this case, they
will have exactly 3.

00:19:23.960 --> 00:19:31.280
So let's say the vertices are
A disjoining in B disjoining

00:19:31.280 --> 00:19:35.665
in C. And let's say they
all have like size n.

00:19:39.190 --> 00:19:53.770
And the hyper edge is E.

00:19:53.770 --> 00:19:57.190
OK, maybe it's worth
drawing a picture.

00:20:00.820 --> 00:20:09.570
So you have this set A, set B--
they're all the same size-- set

00:20:09.570 --> 00:20:17.850
C. And an edge might look like
this or like this or so on.

00:20:17.850 --> 00:20:20.050
OK, you take one from each.

00:20:20.050 --> 00:20:29.190
And then your goal is to
find n disjoint edges.

00:20:33.370 --> 00:20:35.120
If we find that many
and they're disjoint,

00:20:35.120 --> 00:20:37.510
that means they will
cover all of the vertices.

00:20:37.510 --> 00:20:41.230
Every vertex will be hit
by exactly one hyper edge.

00:20:45.850 --> 00:20:49.870
OK, so this is the 3 dimensional
version of bipartite matching,

00:20:49.870 --> 00:20:50.370
I guess.

00:20:50.370 --> 00:20:52.790
There's also the
non-bipartite version.

00:20:52.790 --> 00:20:55.960
For extra completeness,
there's something

00:20:55.960 --> 00:21:04.400
called exact cover by 3 sets,
3 meaning the cardinality.

00:21:04.400 --> 00:21:06.060
This is called X3C.

00:21:06.060 --> 00:21:09.090
You do see 3DM
and X3C frequently

00:21:09.090 --> 00:21:11.360
in the literature and
especially in Garey and Johnson.

00:21:11.360 --> 00:21:14.180
So they're good
problems to know about.

00:21:14.180 --> 00:21:20.910
Here is sort of the generalized
version, where you're given

00:21:20.910 --> 00:21:27.880
non-tripartite, just a
3 uniform hyper graph.

00:21:27.880 --> 00:21:30.550
3 uniform just means every
edge has cardinality 3.

00:21:35.010 --> 00:21:47.430
And your goal is to find--
let's say it has n vertices--

00:21:47.430 --> 00:21:50.200
n over 3 disjoin hyper edges.

00:21:57.960 --> 00:22:00.810
OK, many times the
almost same problem.

00:22:00.810 --> 00:22:02.630
How do these relate?

00:22:02.630 --> 00:22:06.290
Well, certainly if you take
a numerical 3 dimensional

00:22:06.290 --> 00:22:09.230
matching problem, that is a 3
dimensional matching problem.

00:22:09.230 --> 00:22:11.920
You can convert it
into a graph like this.

00:22:11.920 --> 00:22:14.140
You're just forgetting the
fact that there's numbers.

00:22:14.140 --> 00:22:15.640
But then when you
draw the edge, you

00:22:15.640 --> 00:22:21.640
draw one of these hyper edges
exactly when Ai plus Bi plus Ci

00:22:21.640 --> 00:22:24.020
equals the targets sum.

00:22:24.020 --> 00:22:26.730
So numerical 3
dimensional matching

00:22:26.730 --> 00:22:28.895
is a special case of 3
dimensional matching.

00:22:28.895 --> 00:22:30.270
Occasionally it's
useful to start

00:22:30.270 --> 00:22:31.436
from 3 dimensional matching.

00:22:31.436 --> 00:22:33.380
Not for number problems though.

00:22:33.380 --> 00:22:37.630
If you have a number problem,
you like the numerical version.

00:22:37.630 --> 00:22:41.920
Personally I prefer 3 partition,
but these two are pretty close.

00:22:41.920 --> 00:22:44.790
We saw one connection
between them.

00:22:44.790 --> 00:22:46.810
Exact cover by 3 sets
is, in some sense,

00:22:46.810 --> 00:22:49.335
even more general than
3 dimensional matching.

00:22:52.350 --> 00:22:56.670
Yeah, it is more general,
because tripartite hyper graph

00:22:56.670 --> 00:22:59.230
like this is 3 uniform.

00:22:59.230 --> 00:23:01.410
So this is a strict
generalization of that.

00:23:01.410 --> 00:23:03.730
But they all appear
somewhat, so I

00:23:03.730 --> 00:23:05.640
thought it'd good for
you to know about them.

00:23:05.640 --> 00:23:10.580
Again, 3 partition is
where the action is.

00:23:10.580 --> 00:23:14.430
All right, let me go
back to this issue of 2

00:23:14.430 --> 00:23:17.320
partition versus 3 partition.

00:23:17.320 --> 00:23:22.700
These are the two main
problems I want to talk about.

00:23:22.700 --> 00:23:33.480
And they relate to an important
distinction in NP-hardness,

00:23:33.480 --> 00:23:37.970
which is weak versus
strong NP-hardness.

00:23:37.970 --> 00:23:42.850
So there are two
types of NP-hardness

00:23:42.850 --> 00:23:45.520
for number problems.

00:23:45.520 --> 00:23:48.460
If your input is a graph,
these two notions are the same,

00:23:48.460 --> 00:23:52.250
so you don't need
to worry about it.

00:23:52.250 --> 00:23:57.290
But when your problem
has integers as input,

00:23:57.290 --> 00:23:58.550
then there are two types.

00:24:08.660 --> 00:24:10.290
Weakly NP-hard
is, in some sense,

00:24:10.290 --> 00:24:12.510
the type you
already know, if you

00:24:12.510 --> 00:24:16.420
think about it in the right
way, in the intended way.

00:24:16.420 --> 00:24:18.160
We haven't been super
formal about how

00:24:18.160 --> 00:24:26.680
numbers getting encoded, but
usually we think of NP-hardness

00:24:26.680 --> 00:24:32.260
in terms of how
hard your problem is

00:24:32.260 --> 00:24:34.570
in terms of the encoding
size, which we usually call

00:24:34.570 --> 00:24:37.500
n, the encoding of your input.

00:24:37.500 --> 00:24:42.680
OK, so in the usual
form, what this means

00:24:42.680 --> 00:24:56.120
is that you allow numbers
to have exponential value,

00:24:56.120 --> 00:24:58.140
because even when their
value is exponential,

00:24:58.140 --> 00:25:00.720
the encoding of that
value is polynomial.

00:25:06.280 --> 00:25:10.050
Coding length of such a number
is, if you read it in binary,

00:25:10.050 --> 00:25:13.340
that's log base 2 of the number
if the number is 2 to the n

00:25:13.340 --> 00:25:15.790
to the c, which is our
definition of exponential.

00:25:15.790 --> 00:25:17.739
That's going to be n to the c.

00:25:17.739 --> 00:25:18.655
And that's polynomial.

00:25:23.120 --> 00:25:26.330
OK, for here, I'm
going to let n be

00:25:26.330 --> 00:25:31.820
the number of numbers to
avoid circular definitions

00:25:31.820 --> 00:25:32.650
or something.

00:25:32.650 --> 00:25:34.510
So I'm saying there are
n different numbers.

00:25:34.510 --> 00:25:37.760
If each of them is at most
2 to the n to the c in value

00:25:37.760 --> 00:25:40.430
and they're integers, then I can
encode them in this many bits.

00:25:40.430 --> 00:25:42.390
And that's a polynomial
number of bits.

00:25:42.390 --> 00:25:46.920
So I consider that a
reasonable encoding.

00:25:46.920 --> 00:25:49.630
And sometimes that's just fine.

00:25:49.630 --> 00:25:51.450
But there's a
stronger notion, which

00:25:51.450 --> 00:25:54.220
is really useful, especially
for a lot of problems

00:25:54.220 --> 00:25:59.030
we will see today
and next class, which

00:25:59.030 --> 00:26:01.480
is called strongly NP-hard.

00:26:01.480 --> 00:26:18.740
And this is NP-hard even when
your problem is restricted

00:26:18.740 --> 00:26:23.100
to numbers of polynomial value.

00:26:27.860 --> 00:26:31.445
So polynomial here
is with respect to n

00:26:31.445 --> 00:26:35.340
and is the number of
integers-- number of numbers.

00:26:35.340 --> 00:26:40.110
OK, so strongly NP-hard is
stronger than weakly NP-hard.

00:26:40.110 --> 00:26:42.700
If you're NP-hard even
when your numbers are

00:26:42.700 --> 00:26:44.510
only polynomial in
size, then of course

00:26:44.510 --> 00:26:46.160
your NP-hard when
you allow the numbers

00:26:46.160 --> 00:26:47.700
to be as large as exponential.

00:26:47.700 --> 00:26:51.450
This is a weaker
constraint on the problem.

00:26:51.450 --> 00:26:56.210
So to cut to the chase,
2 partition up here

00:26:56.210 --> 00:26:58.390
and subset sum are
weakly NP-hard.

00:27:02.130 --> 00:27:05.810
And if you believe that
the P does not equal NP,

00:27:05.810 --> 00:27:08.080
then it's not strongly NP-hard.

00:27:08.080 --> 00:27:10.950
That's the best we can
hope for, whereas 3

00:27:10.950 --> 00:27:13.480
partition in every other
problem we talked about

00:27:13.480 --> 00:27:14.440
is strongly NP-hard.

00:27:23.508 --> 00:27:24.674
AUDIENCE: I have a question.

00:27:24.674 --> 00:27:27.104
What do you mean
exactly by numbers

00:27:27.104 --> 00:27:30.020
having exponential value?

00:27:30.020 --> 00:27:34.560
PROFESSOR: So again, exponential
is like 2 to the n to the c. n

00:27:34.560 --> 00:27:36.570
is the number of
numbers in your input.

00:27:36.570 --> 00:27:37.149
AUDIENCE: OK.

00:27:37.149 --> 00:27:37.815
PROFESSOR: Yeah.

00:27:37.815 --> 00:27:41.679
So that's what I allow.

00:27:41.679 --> 00:27:43.970
I mean, this is what would
be allowed if you didn't say

00:27:43.970 --> 00:27:47.080
anything, if you interpret
complexity theory in a way

00:27:47.080 --> 00:27:48.670
that I haven't
necessarily told you,

00:27:48.670 --> 00:27:51.650
but generally you want to
assume that all your inputs are

00:27:51.650 --> 00:27:53.680
reasonably encoded
in an efficient way

00:27:53.680 --> 00:27:58.100
that most possible input
strings are valid inputs.

00:27:58.100 --> 00:28:00.446
And so if you're encoding,
then in particular,

00:28:00.446 --> 00:28:01.820
you should encode
your numbers in

00:28:01.820 --> 00:28:06.960
binary or ternary or quaternary
or hexadecimal-- anything

00:28:06.960 --> 00:28:08.990
bigger than one is good.

00:28:08.990 --> 00:28:09.490
OK?

00:28:09.490 --> 00:28:11.031
And you should know
if you're writing

00:28:11.031 --> 00:28:12.450
that number, don't use unary.

00:28:12.450 --> 00:28:16.000
But today we're going
to use unary a lot.

00:28:16.000 --> 00:28:20.420
So this is the same thing
as saying encode in unary.

00:28:20.420 --> 00:28:25.010
Strong NP-hardness
is like saying, well,

00:28:25.010 --> 00:28:28.210
my problem is so
hard that even if I

00:28:28.210 --> 00:28:31.310
encode my numbers in unary,
it's still hard in the resulting

00:28:31.310 --> 00:28:32.490
input size.

00:28:32.490 --> 00:28:34.290
The input size would
be if you write down

00:28:34.290 --> 00:28:37.870
every number in unary and
add up all the numbers.

00:28:37.870 --> 00:28:39.720
That's your input size.

00:28:39.720 --> 00:28:42.010
3-partition is that hard.

00:28:42.010 --> 00:28:44.490
2-partition is not.

00:28:44.490 --> 00:28:44.990
OK?

00:28:44.990 --> 00:28:47.860
So if you can prove strong
NP-hardness, you should.

00:28:47.860 --> 00:28:49.116
It's better.

00:28:49.116 --> 00:28:51.470
If you can only prove
weak NP-hardness, it's OK.

00:28:51.470 --> 00:28:54.160
It's still hard.

00:28:54.160 --> 00:28:57.630
Now you should know, there
are corresponding notions

00:28:57.630 --> 00:28:59.580
on the algorithm side.

00:28:59.580 --> 00:29:03.380
So let's talk about
that a little bit.

00:29:03.380 --> 00:29:05.950
So corresponding algorithms
are-- there are actually

00:29:05.950 --> 00:29:07.760
three of them.

00:29:07.760 --> 00:29:10.340
The main ones are
pseudopolynomial

00:29:10.340 --> 00:29:12.105
and weakly polynomial.

00:29:12.105 --> 00:29:12.730
Sorry.

00:29:12.730 --> 00:29:16.550
The weaklies are unrelated to
each other, but that's life.

00:29:22.510 --> 00:29:25.990
There's also a notion called
strongly polynomial-- unrelated

00:29:25.990 --> 00:29:27.936
to strongly NP-hard.

00:29:27.936 --> 00:29:29.442
Well, there you go.

00:29:39.910 --> 00:29:40.410
OK.

00:29:42.930 --> 00:29:46.690
So weakly polynomial is the
usual notion of polynomial

00:29:46.690 --> 00:29:48.040
I should mention.

00:29:48.040 --> 00:29:50.810
When I say I have a polynomial
time algorithm, what you mean

00:29:50.810 --> 00:29:55.125
is weakly, meaning
that, let's say,

00:29:55.125 --> 00:30:00.510
I'll write it as polynomial in
n-- the number of integers--

00:30:00.510 --> 00:30:08.710
and let's say, log of
the largest integer--

00:30:08.710 --> 00:30:11.471
largest number in the input.

00:30:11.471 --> 00:30:11.970
OK?

00:30:11.970 --> 00:30:13.870
That's a reasonable
encoding size.

00:30:13.870 --> 00:30:15.730
You write them in binary.

00:30:15.730 --> 00:30:16.864
You add them all up.

00:30:16.864 --> 00:30:18.530
So you'd multiply
that by n or whatever.

00:30:18.530 --> 00:30:22.730
And the polynomial in that
value is weakly polynomial.

00:30:22.730 --> 00:30:26.078
Pseudopolynomial
you omit the log.

00:30:26.078 --> 00:30:26.578
OK.

00:30:26.578 --> 00:30:29.870
So I want polynomial on
n and the largest number.

00:30:36.230 --> 00:30:38.960
And strongly polynomial, you
omit that term altogether.

00:30:38.960 --> 00:30:43.270
So you just polynomial
n the number of numbers.

00:30:43.270 --> 00:30:43.770
OK?

00:30:43.770 --> 00:30:46.186
So there's a different world
of algorithms which we're not

00:30:46.186 --> 00:30:48.000
going to talk about
here, which is weakly

00:30:48.000 --> 00:30:50.520
polynomial algorithms versus
strongly polynomial algorithms.

00:30:50.520 --> 00:30:52.395
I'm not aware of any
lower bounds about that,

00:30:52.395 --> 00:30:54.150
but there are famous
open questions like,

00:30:54.150 --> 00:30:57.700
can you solve linear programming
in strongly polynomial time?

00:30:57.700 --> 00:30:58.745
We don't know.

00:30:58.745 --> 00:31:00.120
There's no hardness
notion there.

00:31:00.120 --> 00:31:03.580
So we're not going to talk
about it any more than that.

00:31:03.580 --> 00:31:05.470
What we care about more
is this distinction

00:31:05.470 --> 00:31:07.000
between pseudopolynomial.

00:31:07.000 --> 00:31:10.170
This is polynomial when the
numbers are written in unary,

00:31:10.170 --> 00:31:13.040
and this polynomial when the
numbers are written in binary.

00:31:13.040 --> 00:31:16.950
So these two notions correspond
to these two notions.

00:31:16.950 --> 00:31:21.030
So in particular, if you
believe p does not equal NP,

00:31:21.030 --> 00:31:23.640
then weakly NP-hard
means there is

00:31:23.640 --> 00:31:27.820
no weakly polynomial algorithm.

00:31:27.820 --> 00:31:30.890
But there might be a
pseudopolynomial algorithm.

00:31:30.890 --> 00:31:34.130
Strongly NP-hard means there's
no M polynomial algorithm,

00:31:34.130 --> 00:31:36.890
and so therefore there's no
weakly polynomial algorithm.

00:31:36.890 --> 00:31:37.390
Adam.

00:31:37.390 --> 00:31:39.598
AUDIENCE: So the difference
between weakly polynomial

00:31:39.598 --> 00:31:43.260
and strongly polynomial is that
we don't even necessarily give

00:31:43.260 --> 00:31:47.734
ourselves time to read all the
numbers and put it in binary?

00:31:47.734 --> 00:31:49.900
PROFESSOR: I didn't want
to get too much into models

00:31:49.900 --> 00:31:51.733
of computation, but the
model of computation

00:31:51.733 --> 00:31:56.180
here is that you're allowed to
read an entire number in one

00:31:56.180 --> 00:31:56.690
time step.

00:31:56.690 --> 00:31:59.470
So if you've taken 6851
Advanced Data Structures,

00:31:59.470 --> 00:32:01.930
this is like a word RAM.

00:32:01.930 --> 00:32:04.367
So that's the only reason
this would be reasonable.

00:32:04.367 --> 00:32:05.950
Otherwise you couldn't
read the input.

00:32:05.950 --> 00:32:07.350
That would be pretty hard.

00:32:07.350 --> 00:32:10.484
So the model is you could
take a constant number

00:32:10.484 --> 00:32:12.150
of your numbers, do
something with them,

00:32:12.150 --> 00:32:13.840
output another number
of the same type

00:32:13.840 --> 00:32:15.640
roughly in constant time.

00:32:15.640 --> 00:32:18.780
And you want to do a polynomial
number of such steps, usually

00:32:18.780 --> 00:32:21.270
arithmetic operations.

00:32:21.270 --> 00:32:24.450
Here you don't have to be
so careful about the model

00:32:24.450 --> 00:32:27.730
because any reasonable
encoding, you

00:32:27.730 --> 00:32:29.709
could read it and do
whatever you want with it.

00:32:29.709 --> 00:32:32.000
If you don't care about the
exponent in the polynomial,

00:32:32.000 --> 00:32:33.590
like all models are equivalent.

00:32:33.590 --> 00:32:36.952
If you believe the Strong Church
[INAUDIBLE] Thesis-- anyway.

00:32:36.952 --> 00:32:38.660
This one you have to
be a little bit more

00:32:38.660 --> 00:32:41.510
careful what the model is.

00:32:41.510 --> 00:32:42.010
Good.

00:32:42.010 --> 00:32:45.880
So let me draw my
favorite diagram

00:32:45.880 --> 00:32:46.940
with the difficulty axis.

00:32:51.040 --> 00:32:53.560
But now instead of p,
I'm going to distinguish

00:32:53.560 --> 00:32:56.180
between weakly polynomial,
pseudopolynomial,

00:32:56.180 --> 00:32:57.970
and strongly polynomial.

00:32:57.970 --> 00:33:01.690
So these things are pseudopoly.

00:33:05.280 --> 00:33:07.890
These things are weakly poly.

00:33:12.890 --> 00:33:16.940
And these things
are strongly poly.

00:33:16.940 --> 00:33:18.730
This is on the
algorithm side, upper

00:33:18.730 --> 00:33:23.160
bounds-- be on the left of
the particular position.

00:33:23.160 --> 00:33:30.070
And then on the hardness side
we have-- let me use red.

00:33:30.070 --> 00:33:33.050
It's more dramatic.

00:33:33.050 --> 00:33:36.380
This thing is weakly NP-hard.

00:33:41.040 --> 00:33:46.540
This is if p does
not equal NP then

00:33:46.540 --> 00:33:48.600
you're strictly to the
right of pseudopoly.

00:33:48.600 --> 00:33:50.295
So there's no
pseudopoly problem.

00:33:50.295 --> 00:33:52.910
There's also weakly NP-hard.

00:33:52.910 --> 00:33:57.560
And then strongly
NP-hard excludes

00:33:57.560 --> 00:34:05.650
even a weakly polynomial
algorithm, so strictly

00:34:05.650 --> 00:34:07.759
to the right of that position.

00:34:07.759 --> 00:34:09.800
So obviously, strongly
NP-hard is a better result

00:34:09.800 --> 00:34:11.350
because it's smaller
than this class.

00:34:14.010 --> 00:34:18.020
But for example, 2-partition,
which is only weakly NP-hard,

00:34:18.020 --> 00:34:19.850
has a pseudopolynomial
algorithm.

00:34:19.850 --> 00:34:22.305
You've probably even seen
one in your algorithms class

00:34:22.305 --> 00:34:25.060
if you've ever done
anything like Knapsack

00:34:25.060 --> 00:34:27.290
as a dynamic program.

00:34:27.290 --> 00:34:30.516
That is a dynamic program
probably originally done

00:34:30.516 --> 00:34:31.265
for a 2-partition.

00:34:39.960 --> 00:34:40.460
OK.

00:34:40.460 --> 00:34:43.994
So that problem is
somewhere right in here.

00:34:46.560 --> 00:34:49.610
Weakly NP-hard-- whoops.

00:34:49.610 --> 00:34:51.728
AUDIENCE: I think the
diagram that's is backward,

00:34:51.728 --> 00:34:52.269
but I don't--

00:34:52.269 --> 00:34:52.396
AUDIENCE: Yeah.

00:34:52.396 --> 00:34:52.889
Diagram is--

00:34:52.889 --> 00:34:54.305
AUDIENCE: If a
problem is strongly

00:34:54.305 --> 00:34:56.659
polynomial it ends [INAUDIBLE]
a weakly polynomial.

00:34:56.659 --> 00:34:59.470
PROFESSOR: So the
middle one's right.

00:34:59.470 --> 00:35:01.070
Thank you.

00:35:01.070 --> 00:35:02.710
That seemed funny.

00:35:02.710 --> 00:35:05.710
But strongly polynomial
is this tightest class.

00:35:05.710 --> 00:35:07.180
That's the best result.

00:35:07.180 --> 00:35:10.670
And pseudopoly is
the worst result.

00:35:10.670 --> 00:35:14.408
Did I get my arrows
in the right place?

00:35:14.408 --> 00:35:16.800
AUDIENCE: You've
got to shift over.

00:35:16.800 --> 00:35:20.040
PROFESSOR: Shift over one.

00:35:20.040 --> 00:35:22.460
Strongly NP-hard.

00:35:22.460 --> 00:35:22.960
Whoops.

00:35:28.360 --> 00:35:30.220
So weakly NP-hard is here.

00:35:30.220 --> 00:35:32.780
Strongly NP-hard is there.

00:35:32.780 --> 00:35:35.280
OK.

00:35:35.280 --> 00:35:36.110
Cool.

00:35:36.110 --> 00:35:38.280
So let's check.

00:35:38.280 --> 00:35:40.860
So 2-partition
should be pseudopoly,

00:35:40.860 --> 00:35:43.839
so left of this line,
but weakly NP-hard still

00:35:43.839 --> 00:35:44.630
right of that line.

00:35:44.630 --> 00:35:46.132
That looks good.

00:35:46.132 --> 00:35:49.210
So this is 2-partition.

00:35:49.210 --> 00:35:50.730
3-partition is out here.

00:35:54.905 --> 00:35:57.190
I mean, I'd draw
this is a region,

00:35:57.190 --> 00:35:59.990
but it's more like a
point in my old diagram

00:35:59.990 --> 00:36:02.090
because 3-partitions
are actually E and NP.

00:36:02.090 --> 00:36:04.450
So it's strongly NP-complete.

00:36:04.450 --> 00:36:06.180
So it's like right
at the edge there.

00:36:06.180 --> 00:36:09.090
Anyway, there's no
pseudopolynomial algorithm

00:36:09.090 --> 00:36:11.320
for 3-partition,
unlike 2-partition.

00:36:11.320 --> 00:36:13.850
That's the point of all that.

00:36:13.850 --> 00:36:14.460
Let's do some.

00:36:14.460 --> 00:36:16.700
Shall we?

00:36:16.700 --> 00:36:19.400
NP-hardcore time.

00:36:19.400 --> 00:36:22.675
So that'll be over here.

00:36:34.030 --> 00:36:34.530
OK.

00:36:34.530 --> 00:36:36.341
The first reduction is
going to be pretty--

00:36:36.341 --> 00:36:37.796
AUDIENCE: May I ask a
question before we move on?

00:36:37.796 --> 00:36:38.462
PROFESSOR: Yeah.

00:36:38.462 --> 00:36:41.210
AUDIENCE: So why is there
a no corresponding notion

00:36:41.210 --> 00:36:43.230
for problems are not numeric?

00:36:43.230 --> 00:36:45.847
Like why can't for a
graph problem we say,

00:36:45.847 --> 00:36:48.180
well, we're going to examine
this graph problem assuming

00:36:48.180 --> 00:36:50.510
we're using an inefficient
encoding of our graph

00:36:50.510 --> 00:36:52.720
to see how hard it is?

00:36:52.720 --> 00:36:55.150
PROFESSOR: I guess you could
try to define this in terms

00:36:55.150 --> 00:36:56.608
for graphs, but I
don't think there

00:36:56.608 --> 00:37:00.487
is such an obvious
inefficient notion of graphs.

00:37:00.487 --> 00:37:02.070
I mean, the obvious
inefficient notion

00:37:02.070 --> 00:37:04.820
is like use a matrix instead
of an adjacency list.

00:37:04.820 --> 00:37:06.280
But that's polynomially
equivalent.

00:37:06.280 --> 00:37:09.950
So I mean there certainly
are other notions

00:37:09.950 --> 00:37:15.861
you could imagine, but there
aren't any in the literature.

00:37:15.861 --> 00:37:17.470
All right.

00:37:17.470 --> 00:37:19.390
So just to warn you, the
first reduction we do

00:37:19.390 --> 00:37:21.350
is going to be a
little bit trivial.

00:37:21.350 --> 00:37:24.300
So don't get too excited yet.

00:37:24.300 --> 00:37:27.260
But this is where
3-partition comes from.

00:37:27.260 --> 00:37:32.000
Then we'll do lots of cool ones.

00:37:32.000 --> 00:37:35.350
So multiprocessor scheduling.

00:37:35.350 --> 00:37:43.070
Let's say I have n jobs, and
they have completion times.

00:37:43.070 --> 00:37:44.559
And that's it.

00:37:44.559 --> 00:37:46.100
You can start them
whenever you want.

00:37:49.674 --> 00:37:51.090
And then on the
other hand, I have

00:37:51.090 --> 00:37:54.740
p processors to run those jobs.

00:37:54.740 --> 00:37:57.900
Each processor is
sequential and identical.

00:37:57.900 --> 00:38:00.280
So the model is you
assign jobs to processors.

00:38:00.280 --> 00:38:02.192
Job can only be
on one processor,

00:38:02.192 --> 00:38:03.275
and it runs to completion.

00:38:03.275 --> 00:38:05.770
Then it can run
another job, and so on.

00:38:05.770 --> 00:38:10.170
My goal-- I'll state
the decision version--

00:38:10.170 --> 00:38:20.235
is to finish all jobs in
time less than or equal to t.

00:38:23.060 --> 00:38:23.560
OK?

00:38:23.560 --> 00:38:28.850
So I claim this problem is
NP-hard of some variety.

00:38:28.850 --> 00:38:35.830
Let's start with a
reduction from partition.

00:38:40.950 --> 00:38:42.290
Sorry.

00:38:42.290 --> 00:38:45.400
Partition is a synonym
for 2-partition.

00:38:45.400 --> 00:38:46.510
Usually we omit the two.

00:38:49.690 --> 00:38:53.610
So reduction from partition.

00:38:53.610 --> 00:38:55.160
This problem over here.

00:38:55.160 --> 00:38:57.240
So now I'm given some integers.

00:38:57.240 --> 00:39:00.140
I want to split them
in half basically.

00:39:00.140 --> 00:39:01.840
Any suggestions
on what I could do

00:39:01.840 --> 00:39:03.880
to turn that into a
multiprocessor scheduling

00:39:03.880 --> 00:39:05.232
problem?

00:39:05.232 --> 00:39:07.007
AUDIENCE: Two processors.

00:39:07.007 --> 00:39:08.090
PROFESSOR: Two processors.

00:39:08.090 --> 00:39:09.120
Yeah.

00:39:09.120 --> 00:39:10.290
p equals 2.

00:39:10.290 --> 00:39:11.880
That is the reduction.

00:39:11.880 --> 00:39:14.610
I guess, technically, I also
have to specify what t is,

00:39:14.610 --> 00:39:15.920
but it's over there.

00:39:15.920 --> 00:39:20.400
So you set t to be the
sum of the A's over 2.

00:39:20.400 --> 00:39:22.820
And you don't change A.
You just leave it alone.

00:39:22.820 --> 00:39:25.650
So you just feed in the same
A i's into this problem.

00:39:25.650 --> 00:39:27.531
And that is 2-partition.

00:39:27.531 --> 00:39:28.030
OK.

00:39:28.030 --> 00:39:29.800
Let's do a reduction
from-- so now we

00:39:29.800 --> 00:39:32.320
know the problem is at
least weakly NP-hard,

00:39:32.320 --> 00:39:35.090
but in fact, it is strongly
NP-hard, because we

00:39:35.090 --> 00:39:36.700
can reduce from 3-partition.

00:39:36.700 --> 00:39:39.740
What do you do?

00:39:39.740 --> 00:39:41.401
AUDIENCE: P equals n over 3.

00:39:41.401 --> 00:39:44.250
PROFESSOR: P equals n over 3.

00:39:44.250 --> 00:39:45.320
That's it.

00:39:45.320 --> 00:39:46.740
You set t accordingly.

00:39:46.740 --> 00:39:50.230
Sum of the A's over p.

00:39:50.230 --> 00:39:51.740
Done.

00:39:51.740 --> 00:39:52.480
OK.

00:39:52.480 --> 00:39:55.445
So this problem
comes from the paper

00:39:55.445 --> 00:39:57.040
that introduces
3-partition, which

00:39:57.040 --> 00:40:00.050
is by Gary and Johnson, the
same people who wrote the book.

00:40:00.050 --> 00:40:03.419
So, I mean, this
basically is 3-partition.

00:40:03.419 --> 00:40:04.710
That's why they cared about it.

00:40:04.710 --> 00:40:06.732
But here's a practical
motivation for it.

00:40:09.970 --> 00:40:11.520
Cool.

00:40:11.520 --> 00:40:13.129
Let's do something
more interesting.

00:40:13.129 --> 00:40:14.420
And I kind of want a projector.

00:40:23.280 --> 00:40:26.250
Any questions about--
I think you've

00:40:26.250 --> 00:40:29.310
asked enough questions
about pseudopoly,

00:40:29.310 --> 00:40:32.210
weakly poly, strongly
poly, as I erase them.

00:40:32.210 --> 00:40:32.960
Don't forget them.

00:40:35.710 --> 00:40:37.590
But I think for
the rest of today

00:40:37.590 --> 00:40:41.210
we're just going to be doing
strong polynomial reductions

00:40:41.210 --> 00:40:42.965
from 3-partition.

00:40:42.965 --> 00:40:45.200
I think next class we
might do some weak ones,

00:40:45.200 --> 00:40:49.570
but today we're going
to really use the fact

00:40:49.570 --> 00:40:51.350
that it-- use the strongness.

00:40:51.350 --> 00:40:53.200
And you'll see why,
because we really

00:40:53.200 --> 00:40:55.931
want to encode some
numbers in unary.

00:40:55.931 --> 00:40:56.430
OK.

00:40:56.430 --> 00:41:01.130
Let's start with a
problem-- rectangle packing.

00:41:01.130 --> 00:41:03.650
And this is going to lead us
to a whole bunch of other types

00:41:03.650 --> 00:41:05.370
of packing problems.

00:41:05.370 --> 00:41:07.420
So this is what you might
call packing rectangles

00:41:07.420 --> 00:41:09.000
into a rectangle.

00:41:09.000 --> 00:41:18.360
So I'm given n rectangles, and
I'm given a target rectangle.

00:41:23.789 --> 00:41:26.080
So when I say I'm given a
rectangle, what I really mean

00:41:26.080 --> 00:41:28.170
is I'm given the dimensions--
the width and the height--

00:41:28.170 --> 00:41:28.731
as integers.

00:41:28.731 --> 00:41:31.230
We are usually going to assume
all our numbers are integers,

00:41:31.230 --> 00:41:31.820
as I said.

00:41:34.970 --> 00:41:35.510
Do they fit?

00:41:38.650 --> 00:41:43.810
So what I'd like, in a solution,
is to rotate and translate

00:41:43.810 --> 00:41:46.120
the given rectangles
so that they're

00:41:46.120 --> 00:41:48.370
disjointed from each
other, they can't overlap,

00:41:48.370 --> 00:41:51.090
and they all fit inside
the target rectangle.

00:41:51.090 --> 00:41:51.590
All right.

00:41:51.590 --> 00:41:54.780
So this might be the
target rectangle.

00:41:54.780 --> 00:41:56.240
And then, I don't
know, maybe this

00:41:56.240 --> 00:41:59.780
is my set of rectangles
appropriately packed.

00:42:04.810 --> 00:42:06.190
So here maybe the answer is yes.

00:42:06.190 --> 00:42:08.106
If they don't fit inside
the target rectangle,

00:42:08.106 --> 00:42:09.260
the answer is no.

00:42:09.260 --> 00:42:12.130
This problem is
strongly NP-hard,

00:42:12.130 --> 00:42:15.270
but I'm pretty sure we don't
know whether it's E and NP.

00:42:18.880 --> 00:42:20.580
So there are lots
of open problems.

00:42:20.580 --> 00:42:24.680
I don't mean to indicate
everything is known.

00:42:24.680 --> 00:42:27.190
I should double check that
this is definitely not known,

00:42:27.190 --> 00:42:28.640
but I'm pretty sure it's open.

00:42:28.640 --> 00:42:30.140
Because of this
rotation issue there

00:42:30.140 --> 00:42:31.990
are kind of a lot of
things to worry about.

00:42:31.990 --> 00:42:33.400
So it's not clear
how efficiently

00:42:33.400 --> 00:42:35.002
you can encode a solution.

00:42:35.002 --> 00:42:36.710
Maybe you need a ton
of bits of precision

00:42:36.710 --> 00:42:38.089
to say how things are rotated.

00:42:38.089 --> 00:42:39.880
Here they're all rotated
at the same angle.

00:42:39.880 --> 00:42:40.546
They may not be.

00:42:40.546 --> 00:42:42.170
Who knows.

00:42:42.170 --> 00:42:52.290
So we will consider a special
case, which is exact packing.

00:42:52.290 --> 00:42:55.540
This also makes for a
stronger hardness result.

00:42:55.540 --> 00:42:58.655
So exact packing means
there are no gaps.

00:43:02.230 --> 00:43:05.320
None of this stuff.

00:43:05.320 --> 00:43:06.840
That's forbidden.

00:43:06.840 --> 00:43:08.400
So if you have no
gaps and you look

00:43:08.400 --> 00:43:09.820
at a corner of the
rectangle, that

00:43:09.820 --> 00:43:11.903
must mean there is a
rectangle right there filling

00:43:11.903 --> 00:43:14.150
the corner, which means
there's no rotation.

00:43:14.150 --> 00:43:17.520
Well, you could rotate
by multiples of 90.

00:43:17.520 --> 00:43:19.765
But just know there
are four rotations.

00:43:19.765 --> 00:43:26.810
Well, I guess two for
rectangles-- integer

00:43:26.810 --> 00:43:28.190
times 90 degrees.

00:43:30.700 --> 00:43:33.946
So then the problem is an
NP, because also then you

00:43:33.946 --> 00:43:35.445
can show at that
point-- because you

00:43:35.445 --> 00:43:37.903
have integer rectangles packing
into an integer rectangle--

00:43:37.903 --> 00:43:40.960
by induction, the
translations are integers.

00:43:40.960 --> 00:43:43.522
Therefore, there are
succinct encodings of them.

00:43:50.100 --> 00:43:50.600
OK.

00:43:50.600 --> 00:43:52.830
We don't have to do this,
but just to point out,

00:43:52.830 --> 00:43:55.450
this is one way to make
the problem in E and NP.

00:43:55.450 --> 00:43:58.054
Now they are
assisting solutions.

00:43:58.054 --> 00:43:59.970
So we're going to prove
both of these problems

00:43:59.970 --> 00:44:01.280
are strongly NP-hard.

00:44:04.620 --> 00:44:06.570
I think I'll skip
the weak NP-hardness

00:44:06.570 --> 00:44:11.810
proof because it's not really
any harder-- no pun unintended.

00:44:11.810 --> 00:44:15.202
So let's go there.

00:44:31.030 --> 00:44:35.460
So the basic idea again, we're
reducing from 3-partition.

00:44:46.940 --> 00:44:48.780
So that means we're
given, on any instance

00:44:48.780 --> 00:44:51.320
of 3-partition, n integers.

00:44:51.320 --> 00:44:54.160
We want to represent those
integers as rectangles.

00:44:54.160 --> 00:44:57.390
So kind of the obvious way to
do that is we take each a i

00:44:57.390 --> 00:44:59.420
and we convert it
into a rectangle.

00:44:59.420 --> 00:45:02.080
Let's say it's a i by 1.

00:45:02.080 --> 00:45:03.740
That seems pretty obvious.

00:45:03.740 --> 00:45:06.840
This is what you might call
the a i gadget, since we're

00:45:06.840 --> 00:45:09.780
going to map this feature
of our given instance

00:45:09.780 --> 00:45:13.961
to this feature of our
constructed instance.

00:45:13.961 --> 00:45:15.460
All that would be
left at this point

00:45:15.460 --> 00:45:21.120
is what is the target rectangle,
which I didn't give a name.

00:45:21.120 --> 00:45:26.330
So let me call the
target rectangle

00:45:26.330 --> 00:45:29.021
B. I think that's what
I used in my notes.

00:45:29.021 --> 00:45:29.521
Yep.

00:45:32.890 --> 00:45:38.445
So let's say B is going
to be a rectangle.

00:45:42.220 --> 00:45:44.412
What is the height
of the rectangle?

00:45:44.412 --> 00:45:45.650
AUDIENCE: n over 3.

00:45:45.650 --> 00:45:48.410
PROFESSOR: n over 3.

00:45:48.410 --> 00:45:48.910
Yes.

00:45:48.910 --> 00:45:50.040
Right.

00:45:50.040 --> 00:45:51.880
And then the width?

00:45:51.880 --> 00:45:54.960
AUDIENCE: The sum
divided by n over 3.

00:45:54.960 --> 00:45:56.660
PROFESSOR: The target sum, t.

00:46:04.721 --> 00:46:05.220
Cool.

00:46:05.220 --> 00:46:11.660
So the intent is that the
rectangles will look something

00:46:11.660 --> 00:46:14.750
like this.

00:46:14.750 --> 00:46:19.190
And always, however, if I
fit three in here-- or maybe

00:46:19.190 --> 00:46:21.160
I could do more
than three, but we

00:46:21.160 --> 00:46:23.660
know that won't happen with the
actual 3-partition instances

00:46:23.660 --> 00:46:25.980
we get, because we can
assume there are always

00:46:25.980 --> 00:46:28.455
three of them-- but anyway,
we're not constraining

00:46:28.455 --> 00:46:29.330
there are only three.

00:46:29.330 --> 00:46:30.788
You put in however
many rectangles.

00:46:30.788 --> 00:46:32.371
Add up to exactly
the target sum.

00:46:32.371 --> 00:46:32.870
Boom.

00:46:32.870 --> 00:46:34.660
You've got the target sum.

00:46:34.660 --> 00:46:37.220
And there's just enough
space for all of them

00:46:37.220 --> 00:46:38.650
if you pack them this way.

00:46:38.650 --> 00:46:39.606
Question?

00:46:39.606 --> 00:46:42.883
AUDIENCE: Shouldn't we
specify that the a i rectangle

00:46:42.883 --> 00:46:46.394
is a i times n over 3 plus
1 to make sure that we

00:46:46.394 --> 00:46:48.010
can't accidentally rotate them?

00:46:48.010 --> 00:46:48.676
PROFESSOR: Yeah.

00:46:48.676 --> 00:46:52.070
So part of my confusion in
drawing this-- and I worry--

00:46:52.070 --> 00:46:54.470
is you could take one of these
rectangles and rotate it.

00:46:54.470 --> 00:46:56.560
And then this
reduction is wrong.

00:46:56.560 --> 00:46:58.920
So this reduction is wrong.

00:46:58.920 --> 00:47:03.130
So I will cheat and
make this epsilon,

00:47:03.130 --> 00:47:05.020
and then multiply
this by epsilon.

00:47:05.020 --> 00:47:06.527
This is one way to fix it.

00:47:06.527 --> 00:47:08.360
Of course, now I have
to scale everything up

00:47:08.360 --> 00:47:09.130
by 1 over epsilon.

00:47:09.130 --> 00:47:10.950
And I have to tell
you what epsilon is.

00:47:10.950 --> 00:47:12.575
You were suggesting
some multiple of n,

00:47:12.575 --> 00:47:14.320
which is a good suggestion.

00:47:14.320 --> 00:47:18.510
I think as long as we make
this much smaller than 1,

00:47:18.510 --> 00:47:20.170
then it's not
possible to rotate,

00:47:20.170 --> 00:47:22.930
because these guys
are length at least 1,

00:47:22.930 --> 00:47:24.050
because they're integers.

00:47:24.050 --> 00:47:26.550
So if I tried to rotate, it has
to be a multiple 90 degrees.

00:47:26.550 --> 00:47:29.340
So I think as long as this
is strictly less than 1,

00:47:29.340 --> 00:47:31.160
we are OK.

00:47:31.160 --> 00:47:33.450
I didn't change the
intended solution.

00:47:33.450 --> 00:47:36.160
I just made everything narrower.

00:47:36.160 --> 00:47:42.030
And so I just need to set
epsilon less than 3 over n.

00:47:42.030 --> 00:47:45.740
It would be that inequality.

00:47:45.740 --> 00:47:48.340
But I want integers, so I
should scale everything up

00:47:48.340 --> 00:47:49.280
by n over 3.

00:47:49.280 --> 00:47:54.470
So just multiply all the numbers
by n over 3, and you're done.

00:47:54.470 --> 00:47:56.750
In fact, you can be
a little simpler.

00:47:56.750 --> 00:47:59.060
And I drew this
diagram long ago,

00:47:59.060 --> 00:48:00.545
so I might as well
show it to you.

00:48:00.545 --> 00:48:03.350
You can just add n over
3 to all your integers.

00:48:03.350 --> 00:48:06.240
That will also work,
under the assumption

00:48:06.240 --> 00:48:09.750
that you can only take three
numbers and add them up.

00:48:09.750 --> 00:48:13.055
Then you will always be adding
3 times n over 3 horizontally.

00:48:16.050 --> 00:48:18.052
So they a i's here
are the yellow part

00:48:18.052 --> 00:48:19.510
of these rectangles,
and then we're

00:48:19.510 --> 00:48:21.540
just adding this fixed
n over 3 to all of them.

00:48:21.540 --> 00:48:26.880
So this is a 4, a 4, a
4, a 4, a 5, 5, 5, 6, 7.

00:48:26.880 --> 00:48:29.480
And that happens to
be a positive instance

00:48:29.480 --> 00:48:30.110
of 3-partition.

00:48:30.110 --> 00:48:31.580
There is a solution.

00:48:31.580 --> 00:48:33.360
This is one way to do it.

00:48:33.360 --> 00:48:35.630
So we're just adding
n overall here,

00:48:35.630 --> 00:48:37.860
because we have
3 times n over 3.

00:48:37.860 --> 00:48:44.845
And the length of these
is always smaller.

00:48:48.080 --> 00:48:52.340
Rotation should not be possible,
because each of these guys

00:48:52.340 --> 00:48:54.410
is going to be length
strictly larger than n

00:48:54.410 --> 00:48:56.330
over 3 because we add
an integer to n over

00:48:56.330 --> 00:48:59.630
3-- a positive integer-- and
the height here is n over 3.

00:48:59.630 --> 00:49:02.060
So that just barely works.

00:49:02.060 --> 00:49:03.909
Same thing, more
or less, just this

00:49:03.909 --> 00:49:05.700
is scaling by a
multiplicative factor here.

00:49:05.700 --> 00:49:07.170
We're doing an additive
thing, because we

00:49:07.170 --> 00:49:08.711
have this luxury of
knowing there are

00:49:08.711 --> 00:49:11.000
three items in every triple.

00:49:11.000 --> 00:49:11.850
Cool.

00:49:11.850 --> 00:49:12.650
Rectangle packet.

00:49:12.650 --> 00:49:13.151
Question.

00:49:13.151 --> 00:49:15.108
AUDIENCE: This is a
question about 3-partition.

00:49:15.108 --> 00:49:17.170
Is it assuming that they
are positive integers?

00:49:17.170 --> 00:49:17.870
PROFESSOR: Yes.

00:49:17.870 --> 00:49:19.120
All the integers are positive.

00:49:22.730 --> 00:49:24.860
You don't have to, but we can.

00:49:24.860 --> 00:49:26.750
So we will.

00:49:26.750 --> 00:49:29.434
Makes our life a lot easier.

00:49:29.434 --> 00:49:30.100
Other questions?

00:49:32.910 --> 00:49:35.710
OK.

00:49:35.710 --> 00:49:38.550
Time for some puzzles.

00:49:38.550 --> 00:49:43.050
So I think I'll show you
some real life puzzles first.

00:49:43.050 --> 00:49:45.980
There's this notion of
an edge-matching puzzle,

00:49:45.980 --> 00:49:48.600
which goes back to the 1890s.

00:49:48.600 --> 00:49:53.870
I believe this one is from
the late 1890s, early 1900s.

00:49:53.870 --> 00:49:55.300
So it's one of the older ones.

00:49:55.300 --> 00:49:57.425
At least when I was growing
up, we had these puzzle

00:49:57.425 --> 00:49:58.500
all over the place.

00:49:58.500 --> 00:50:02.300
So what's going on here is
you have physical triangles,

00:50:02.300 --> 00:50:06.650
and these half frogs are drawn
on the edges of the triangles.

00:50:06.650 --> 00:50:08.610
And your goal is to pack
all of these triangles

00:50:08.610 --> 00:50:10.000
into the big triangle.

00:50:10.000 --> 00:50:10.630
That's easy.

00:50:10.630 --> 00:50:14.410
It's a regular triangulation.

00:50:14.410 --> 00:50:17.240
But you need to half
frogs to match up.

00:50:19.699 --> 00:50:20.240
I don't know.

00:50:20.240 --> 00:50:26.130
The hind end of the white-- I'm
sorry-- yellow-speckled frog

00:50:26.130 --> 00:50:31.010
matches the front end of the
yellow-black-speckled frog,

00:50:31.010 --> 00:50:32.210
as drawn here.

00:50:32.210 --> 00:50:35.640
This is a valid solution, but
if I rotated this tile 120

00:50:35.640 --> 00:50:38.370
degrees, it's not
a valid solution

00:50:38.370 --> 00:50:41.850
even though it's all hinds
matching to fronts and so on.

00:50:41.850 --> 00:50:42.450
OK?

00:50:42.450 --> 00:50:43.770
Rules clear?

00:50:43.770 --> 00:50:45.440
So these are
edge-matching puzzles.

00:50:45.440 --> 00:50:47.050
This is formulated
in a different way.

00:50:47.050 --> 00:50:48.258
This is not a valid solution.

00:50:48.258 --> 00:50:50.650
The goal is to get these
colors to all match up.

00:50:50.650 --> 00:50:55.530
So in general, you can think of
there being a color on an edge.

00:50:55.530 --> 00:50:58.020
And here it happens to be
composed of these two colors.

00:50:58.020 --> 00:50:59.895
And it would have to
match both of the colors

00:50:59.895 --> 00:51:00.790
on the other side.

00:51:00.790 --> 00:51:03.574
So it's essentially like
having a color on each edge.

00:51:03.574 --> 00:51:05.240
Here, we also have a
color on each edge,

00:51:05.240 --> 00:51:08.530
but we also have a sign, which
is the front or the hind part

00:51:08.530 --> 00:51:09.440
of the frog.

00:51:09.440 --> 00:51:12.080
There's the yellow frog, the
red frog, the green frog,

00:51:12.080 --> 00:51:13.800
the orange frog.

00:51:13.800 --> 00:51:19.310
So in general, we're
going to formulate this.

00:51:19.310 --> 00:51:20.631
I'll get over here.

00:51:29.280 --> 00:51:29.780
OK.

00:51:29.780 --> 00:51:35.140
There are many types of these
puzzles I'll try to capture.

00:51:35.140 --> 00:51:36.870
It's not exactly
either one of those.

00:51:44.240 --> 00:51:47.320
If you've ever studied
something called Wang tiles,

00:51:47.320 --> 00:51:49.810
this is exactly that model.

00:51:49.810 --> 00:51:54.150
So I'll just throw
in the word there.

00:51:54.150 --> 00:52:01.790
But what we have
are n unit squares.

00:52:01.790 --> 00:52:02.915
Those are called the tiles.

00:52:06.800 --> 00:52:14.740
Each one has four
colors-- a, b, c, d.

00:52:14.740 --> 00:52:29.630
So one per edge.

00:52:34.570 --> 00:52:40.665
And you are also given
a target rectangle.

00:52:40.665 --> 00:52:43.040
It's going to be integer,
because these are unit squares.

00:52:47.690 --> 00:52:52.495
And you want to pack-- probably
exactly pack so there are not

00:52:52.495 --> 00:53:00.910
going be any gaps-- the squares
into the rectangle with colors

00:53:00.910 --> 00:53:01.410
matching.

00:53:07.380 --> 00:53:13.290
So whenever I have two
squares that share an edge,

00:53:13.290 --> 00:53:15.090
the color that's
written here better

00:53:15.090 --> 00:53:17.237
be the same color
that's written there.

00:53:17.237 --> 00:53:18.070
Those are the rules.

00:53:18.070 --> 00:53:20.870
If you're on the
boundary, no restriction.

00:53:20.870 --> 00:53:23.650
But if you're an interior
edge, you restrict in that way.

00:53:23.650 --> 00:53:24.340
OK?

00:53:24.340 --> 00:53:27.500
This actually closely
matches what is currently

00:53:27.500 --> 00:53:30.220
maybe the most famous
edge-matching puzzle called

00:53:30.220 --> 00:53:32.170
Eternity II.

00:53:32.170 --> 00:53:33.750
This one is still unsolved.

00:53:33.750 --> 00:53:36.150
Well, the creator
has a solution.

00:53:36.150 --> 00:53:38.710
And if you ever find it, or one
of the many other solutions--

00:53:38.710 --> 00:53:42.090
who knows-- you
win $2 million US.

00:53:42.090 --> 00:53:43.324
So time to get rich.

00:53:43.324 --> 00:53:44.240
AUDIENCE: [INAUDIBLE].

00:53:47.580 --> 00:53:49.060
PROFESSOR: Well, yeah.

00:53:49.060 --> 00:53:52.220
I guess that's the way
to make the most money

00:53:52.220 --> 00:53:53.455
is first solve p equals NP.

00:53:53.455 --> 00:53:56.000
And then solve
Eternity II, I guess.

00:53:56.000 --> 00:53:59.300
But you could easily solve this
puzzle without p equals NP.

00:53:59.300 --> 00:54:02.490
There are actually a lot of
almost solutions out there.

00:54:02.490 --> 00:54:06.210
I believe this is
one of the leaders.

00:54:06.210 --> 00:54:10.670
This guy, Louis
Verhaad, got-- so this

00:54:10.670 --> 00:54:13.430
is a complete solution
with all the pieces,

00:54:13.430 --> 00:54:14.630
but not all the edges match.

00:54:14.630 --> 00:54:16.380
So it's hard to find
them, but here's one,

00:54:16.380 --> 00:54:18.054
for example, that mismatches.

00:54:18.054 --> 00:54:20.220
So I didn't explain, but
everything is a square tile

00:54:20.220 --> 00:54:22.136
here, and there's a
different shape and color.

00:54:22.136 --> 00:54:24.870
But it's basically a color from
a mathematical perspective.

00:54:24.870 --> 00:54:26.020
Have to match them all up.

00:54:26.020 --> 00:54:29.250
Here he got 467 matches
out of the 480 edges.

00:54:29.250 --> 00:54:31.490
And that won him
already $10,000.

00:54:31.490 --> 00:54:34.499
And I believe it's found
with a computer-aided search.

00:54:34.499 --> 00:54:35.290
AUDIENCE: Is that--

00:54:35.290 --> 00:54:36.581
AUDIENCE: [INTERPOSING VOICES].

00:54:36.581 --> 00:54:39.036
AUDIENCE: That's
not the person who--

00:54:39.036 --> 00:54:40.920
PROFESSOR: I don't
know for sure.

00:54:40.920 --> 00:54:44.070
I would guess that
it's Louis's daughter.

00:54:44.070 --> 00:54:45.940
Here's a different
almost solution

00:54:45.940 --> 00:54:49.160
where there are some missing
tiles but everything matches.

00:54:49.160 --> 00:54:50.810
And then at the bottom
of his web page,

00:54:50.810 --> 00:54:51.550
you should check it out.

00:54:51.550 --> 00:54:52.050
It's funny.

00:54:52.050 --> 00:54:54.540
It says, "And here is a
solution to Eternity II."

00:54:54.540 --> 00:54:56.110
I looked at this
for a long time,

00:54:56.110 --> 00:54:59.890
and I was like I don't see any
edge matches, but you guys are

00:54:59.890 --> 00:55:02.360
smart, so you
probably know there's

00:55:02.360 --> 00:55:07.735
one other cheat you could
possibly do in this puzzle.

00:55:07.735 --> 00:55:09.699
AUDIENCE: Add Different tiles?

00:55:09.699 --> 00:55:10.990
PROFESSOR: Add different tiles?

00:55:10.990 --> 00:55:11.674
Maybe.

00:55:11.674 --> 00:55:13.340
Although these are
nicely-printed tiles.

00:55:13.340 --> 00:55:18.540
So I would guess he bought two
sets and just mixed some parts.

00:55:18.540 --> 00:55:20.352
I wrote a program to
check yes, indeed,

00:55:20.352 --> 00:55:21.560
some tiles are repeated here.

00:55:21.560 --> 00:55:23.460
I forget exactly how many.

00:55:23.460 --> 00:55:25.060
10 or 20 or something.

00:55:25.060 --> 00:55:27.000
It's still pretty cool.

00:55:27.000 --> 00:55:28.224
It looks like it's done.

00:55:28.224 --> 00:55:29.140
AUDIENCE: [INAUDIBLE].

00:55:29.140 --> 00:55:31.550
PROFESSOR: But there's no
complete actual solution

00:55:31.550 --> 00:55:33.505
using each piece exactly once.

00:55:33.505 --> 00:55:35.990
It's probably clear
here, but you only

00:55:35.990 --> 00:55:40.030
get one version of each square.

00:55:40.030 --> 00:55:41.390
OK.

00:55:41.390 --> 00:55:44.050
So there's your motivation
for solving edge-matching.

00:55:44.050 --> 00:55:47.790
So you might wonder, oh, can
I solve it in polynomial time?

00:55:47.790 --> 00:55:50.560
And the answer is no
unless p equals NP.

00:55:50.560 --> 00:55:56.130
And here we're going to use
essentially rectangle packing

00:55:56.130 --> 00:55:58.790
and this reduction.

00:55:58.790 --> 00:56:01.240
So how could I--
again, we're going

00:56:01.240 --> 00:56:02.860
to reduce from 3-partition.

00:56:02.860 --> 00:56:06.500
How could I convert a
number a i into something

00:56:06.500 --> 00:56:09.140
like a rectangle
using edge-matching?

00:56:14.580 --> 00:56:17.780
I should probably copy over
the one that we had in the end,

00:56:17.780 --> 00:56:24.859
which was a i goes to
n over 3 plus a i by 1,

00:56:24.859 --> 00:56:25.900
because we want integers.

00:56:29.173 --> 00:56:29.673
Yeah.

00:56:29.673 --> 00:56:34.563
AUDIENCE: So you make it so
that there is sort of one color,

00:56:34.563 --> 00:56:36.519
and that's for
[INAUDIBLE] most things.

00:56:36.519 --> 00:56:38.882
And that's [INAUDIBLE]
kind of on the outside

00:56:38.882 --> 00:56:40.431
of each rectangle.

00:56:40.431 --> 00:56:42.410
And then put together
each rectangle.

00:56:42.410 --> 00:56:48.870
If you need like-- if the
rectangle is like a i by 1,

00:56:48.870 --> 00:56:51.816
you're going to need a i
squares, such that there's

00:56:51.816 --> 00:56:53.780
like one color for
that rectangle that

00:56:53.780 --> 00:56:58.384
is only used to join the other
squares of that rectangle.

00:56:58.384 --> 00:56:59.050
PROFESSOR: Good.

00:56:59.050 --> 00:57:02.750
So we're going to convert this
something by one rectangle

00:57:02.750 --> 00:57:05.060
into something
different squares.

00:57:05.060 --> 00:57:07.220
And we're just going to
sub-divide like that.

00:57:07.220 --> 00:57:10.340
And we're going to
surround all these edges

00:57:10.340 --> 00:57:11.550
with the same color.

00:57:14.940 --> 00:57:16.020
That will work.

00:57:16.020 --> 00:57:18.460
AUDIENCE: And the interior
edges [INAUDIBLE].

00:57:18.460 --> 00:57:20.300
PROFESSOR: The interior
edges-- all right.

00:57:20.300 --> 00:57:22.460
So we're going to
take a i, and we're

00:57:22.460 --> 00:57:31.350
going to convert it into-- OK.

00:57:31.350 --> 00:57:36.270
Don't make me draw all of them--
the width here, let's say,

00:57:36.270 --> 00:57:40.105
will be n over 3 plus a i.

00:57:40.105 --> 00:57:41.980
And we're going to use
a special color-- I'll

00:57:41.980 --> 00:57:43.810
call it black-- on the outside.

00:57:43.810 --> 00:57:47.060
And this color I'm
going to call--

00:57:47.060 --> 00:57:52.770
I need some red so it's slightly
visible-- I'm going to call i.

00:57:52.770 --> 00:57:56.660
This is going to be a
different color for each a i.

00:58:02.122 --> 00:58:03.830
This will require a
little bit more work.

00:58:03.830 --> 00:58:06.930
You could also use a different--
you could use i1, i2, i3--

00:58:06.930 --> 00:58:11.870
but I would really force this
to go together in this way.

00:58:11.870 --> 00:58:13.890
If I'm trying to be
conservative on colors--

00:58:13.890 --> 00:58:18.090
only use n of them-- then
I will put those all i.

00:58:18.090 --> 00:58:21.270
And then as long as none of
these matched to the boundary,

00:58:21.270 --> 00:58:23.860
I'm OK.

00:58:23.860 --> 00:58:25.950
I guess even if I
used the i1, i2, i3,

00:58:25.950 --> 00:58:28.330
it's possible some of
those match the boundary.

00:58:28.330 --> 00:58:30.450
And then weird
stuff could happen.

00:58:30.450 --> 00:58:32.480
But as long as
all these i colors

00:58:32.480 --> 00:58:35.189
match up with each other, you
have to build this rectangle.

00:58:35.189 --> 00:58:37.730
And then we don't care about
how the rectangles are assembled

00:58:37.730 --> 00:58:39.550
with respect to each other.

00:58:39.550 --> 00:58:42.300
So we're basically simulating
this reduction rectangle

00:58:42.300 --> 00:58:43.580
packing.

00:58:43.580 --> 00:58:44.080
OK.

00:58:44.080 --> 00:58:48.520
The one I have drawn here
is slightly different.

00:58:48.520 --> 00:58:50.360
I don't remember why
we did it this way.

00:58:50.360 --> 00:58:54.530
This is [INAUDIBLE] work with
Marty Dumaine, the cameramen.

00:58:54.530 --> 00:58:59.640
And here, just I guess to
be as simple as possible,

00:58:59.640 --> 00:59:02.956
we made the width of each
of the rectangles just a i.

00:59:02.956 --> 00:59:05.170
That has a problem
that you could rotate.

00:59:05.170 --> 00:59:07.240
But to prevent rotation,
we use a different color

00:59:07.240 --> 00:59:08.262
horizontal and vertical.

00:59:08.262 --> 00:59:09.970
So the top edges and
the bottom edges all

00:59:09.970 --> 00:59:11.865
have the colored percent sign.

00:59:11.865 --> 00:59:13.990
I think this is a limitation
of the drawing program

00:59:13.990 --> 00:59:15.720
I was using at
the time actually.

00:59:15.720 --> 00:59:18.170
And dollar signs on the
left and right side.

00:59:18.170 --> 00:59:20.150
And then we're going
to build frame.

00:59:20.150 --> 00:59:23.160
This is what you might call
infrastructure for the proof.

00:59:23.160 --> 00:59:24.950
This is one gadget happens.

00:59:24.950 --> 00:59:26.040
You just execute it once.

00:59:26.040 --> 00:59:27.690
This we execute for
each of the a i's.

00:59:27.690 --> 00:59:30.750
We're just going to have
one copy of this big frame.

00:59:30.750 --> 00:59:34.736
The goal the frame is to hide
the boundary so that none

00:59:34.736 --> 00:59:36.610
of these tiles could
match with the boundary,

00:59:36.610 --> 00:59:38.318
because when they
match the boundary then

00:59:38.318 --> 00:59:40.470
you're breaking a rectangle
in half and bad things

00:59:40.470 --> 00:59:42.190
could happen.

00:59:42.190 --> 00:59:43.680
So instead, what
we're going to do

00:59:43.680 --> 00:59:45.890
is all of these capital
letters on the outside--

00:59:45.890 --> 00:59:49.160
and I ran out of letters and
used a couple of symbols--

00:59:49.160 --> 00:59:51.810
appear exactly once
in the reduction.

00:59:51.810 --> 00:59:53.270
So they can't
match anyone, which

00:59:53.270 --> 00:59:55.670
means they have to
be on the boundary.

00:59:55.670 --> 00:59:58.850
So those guys have to
be on the boundary.

00:59:58.850 --> 01:00:03.070
And then all these other
colors appear exactly twice,

01:00:03.070 --> 01:00:07.190
so you have to join these tiles
together in exactly this way.

01:00:07.190 --> 01:00:09.080
And now the boundary is gone.

01:00:09.080 --> 01:00:11.950
And we have set up dollar
signs on the left side

01:00:11.950 --> 01:00:13.950
and the right side, and
percent signs on the top

01:00:13.950 --> 01:00:15.530
and the bottom sides.

01:00:15.530 --> 01:00:20.940
In reality, these would
be whatever t wide and n

01:00:20.940 --> 01:00:23.310
over 3 tall.

01:00:23.310 --> 01:00:25.340
This is just some
different notation.

01:00:25.340 --> 01:00:26.704
And that's it.

01:00:26.704 --> 01:00:28.370
Now you're simulating
rectangle packing.

01:00:28.370 --> 01:00:28.869
Question?

01:00:28.869 --> 01:00:31.300
AUDIENCE: Why do you need
two rows at the bottom?

01:00:31.300 --> 01:00:33.982
PROFESSOR: So this two rows
is to indicate, for whatever

01:00:33.982 --> 01:00:35.690
reason, because in
edge-matching puzzles,

01:00:35.690 --> 01:00:38.335
usually the target shape is
not a rectangle, but a square.

01:00:38.335 --> 01:00:39.710
And we wanted the
stronger result

01:00:39.710 --> 01:00:41.950
at packing unit
squares into a square

01:00:41.950 --> 01:00:44.460
with edge-matching
results E as NP-hard.

01:00:44.460 --> 01:00:46.690
So the point here is
you just add however

01:00:46.690 --> 01:00:49.550
many rows or columns you
need to make it a square.

01:00:49.550 --> 01:00:50.050
Yep.

01:00:50.050 --> 01:00:50.885
Good question.

01:00:50.885 --> 01:00:51.440
Jason?

01:00:51.440 --> 01:00:53.810
AUDIENCE: So your different
symbols, I believe,

01:00:53.810 --> 01:00:56.495
are also to let you build this
into the rectangle later on.

01:00:56.495 --> 01:01:00.660
Otherwise, you'll run into
issues with rotating things.

01:01:00.660 --> 01:01:01.790
PROFESSOR: We'll get there.

01:01:01.790 --> 01:01:02.290
Yeah.

01:01:02.290 --> 01:01:04.770
So I have different
symbols here and here

01:01:04.770 --> 01:01:06.020
in order to prevent rotation.

01:01:06.020 --> 01:01:06.561
That's right.

01:01:06.561 --> 01:01:07.940
Instead of making them longer.

01:01:07.940 --> 01:01:09.270
I could've, instead,
made these longer

01:01:09.270 --> 01:01:10.811
like we had with
the rectangle thing,

01:01:10.811 --> 01:01:12.809
but I guess, at the
time, I wasn't thinking

01:01:12.809 --> 01:01:14.100
of teaching a class about this.

01:01:14.100 --> 01:01:17.135
So I didn't reuse my previous
reduction for this one.

01:01:17.135 --> 01:01:19.626
But oh, well.

01:01:19.626 --> 01:01:22.050
Yeah.

01:01:22.050 --> 01:01:24.260
But the reason there are
dollar signs in there

01:01:24.260 --> 01:01:29.510
like red or some actual
color is because probably

01:01:29.510 --> 01:01:32.490
black and white printing
was more common then.

01:01:32.490 --> 01:01:34.500
OK.

01:01:34.500 --> 01:01:35.030
Cool.

01:01:35.030 --> 01:01:36.620
That was one puzzle.

01:01:36.620 --> 01:01:39.010
And now key point.

01:01:39.010 --> 01:01:42.560
What if we did this
reduction from partition?

01:01:42.560 --> 01:01:45.590
So with partition, instead
of having n over three groups

01:01:45.590 --> 01:01:48.010
here, we just have two groups?

01:01:48.010 --> 01:01:48.950
And same thing.

01:01:48.950 --> 01:01:51.388
Why not do that?

01:01:51.388 --> 01:01:53.317
AUDIENCE: So that would
be a weakly NP-hard.

01:01:53.317 --> 01:01:55.400
PROFESSOR: That would be
a weak NP-hard reduction.

01:01:55.400 --> 01:01:58.292
Now, this problem here--
edge-matching puzzle,

01:01:58.292 --> 01:02:00.000
n unit squares of four
colors-- are there

01:02:00.000 --> 01:02:02.560
any numbers in this problem?

01:02:02.560 --> 01:02:03.060
AUDIENCE: 4

01:02:03.060 --> 01:02:07.110
PROFESSOR: Other than 4 and n?

01:02:07.110 --> 01:02:09.350
Are there any numbers
that are inputs?

01:02:09.350 --> 01:02:11.252
AUDIENCE: I guess
the colors have

01:02:11.252 --> 01:02:12.460
to be represented as numbers.

01:02:12.460 --> 01:02:14.020
PROFESSOR: The
colors do you have

01:02:14.020 --> 01:02:19.190
to be represented as numbers,
but this is sort of a sideline.

01:02:19.190 --> 01:02:21.320
Usually, when we're
talking about colors,

01:02:21.320 --> 01:02:24.010
all we care about is whether
the colors are equal or not.

01:02:24.010 --> 01:02:27.270
So you don't normally
think of those as numbers.

01:02:27.270 --> 01:02:28.860
You can think of
them as vertices

01:02:28.860 --> 01:02:29.860
in a graph or something.

01:02:29.860 --> 01:02:32.040
I mean, they're more like
combinatorial objects.

01:02:32.040 --> 01:02:34.600
You're never adding
two colors together.

01:02:34.600 --> 01:02:35.364
Yes?

01:02:35.364 --> 01:02:36.756
AUDIENCE: The other
point is that the number

01:02:36.756 --> 01:02:38.256
of different colors
that you can get

01:02:38.256 --> 01:02:39.965
is at most 4 times n
because [INAUDIBLE].

01:02:39.965 --> 01:02:42.172
PROFESSOR: The number of
colors is in most 4 times n.

01:02:42.172 --> 01:02:44.650
Yeah, you could write down
a color as 2 to 2 to the n,

01:02:44.650 --> 01:02:46.320
but why?

01:02:46.320 --> 01:02:48.240
It's supposed to be
an efficient encoding.

01:02:48.240 --> 01:02:50.124
So there are really
no numbers here.

01:02:50.124 --> 01:02:52.290
So it doesn't even make
sense to say this problem is

01:02:52.290 --> 01:02:53.980
strongly NP-hard.

01:02:53.980 --> 01:02:56.770
But even worse, if I
started with 2-partition,

01:02:56.770 --> 01:03:00.680
and I did this reduction exactly
as drawn but not as tall,

01:03:00.680 --> 01:03:06.210
I could still make it a square,
but everything would break.

01:03:06.210 --> 01:03:09.825
Because for 2-partition to
be hard, those numbers--

01:03:09.825 --> 01:03:12.890
the a i's-- have to be
exponential in value.

01:03:12.890 --> 01:03:15.610
If I have an
exponential value a i,

01:03:15.610 --> 01:03:17.350
when I convert it
into a rectangle,

01:03:17.350 --> 01:03:20.260
or actually I convert it
into a bunch of tiles,

01:03:20.260 --> 01:03:23.110
I will have
exponentially many tiles.

01:03:23.110 --> 01:03:25.509
This construction will
be of exponential size.

01:03:25.509 --> 01:03:27.550
So I will get exponentially
many different colors

01:03:27.550 --> 01:03:28.640
on the boundary.

01:03:28.640 --> 01:03:30.514
So that's very bad.

01:03:30.514 --> 01:03:31.930
Even if you're
clever and you say,

01:03:31.930 --> 01:03:33.589
oh, well, these tiles
are all the same,

01:03:33.589 --> 01:03:35.130
so maybe I'll encode
them efficiently

01:03:35.130 --> 01:03:37.849
and say there's an exponentially
many of this one tile.

01:03:37.849 --> 01:03:39.640
The ones in the boundary
are all different.

01:03:39.640 --> 01:03:41.325
So it's not a valid reduction.

01:03:41.325 --> 01:03:42.950
You should always
take a problem that's

01:03:42.950 --> 01:03:44.530
supposed to run
in polynomial time

01:03:44.530 --> 01:03:47.090
and produce a result
of polynomial size.

01:03:47.090 --> 01:03:48.910
So if I start with
something where

01:03:48.910 --> 01:03:50.530
the input is
polynomial size but it

01:03:50.530 --> 01:03:53.000
has exponentially
large a i's, I'd

01:03:53.000 --> 01:03:58.670
get an exponential size puzzle,
which is boring to solve.

01:03:58.670 --> 01:04:00.260
I don't know.

01:04:00.260 --> 01:04:02.590
It's not a valid
NP-hardness reduction.

01:04:02.590 --> 01:04:05.200
This is why we want to
start from 3-partition.

01:04:05.200 --> 01:04:07.440
Because then I know even
if what I'm doing here

01:04:07.440 --> 01:04:09.267
is representing
the a i's in unary.

01:04:09.267 --> 01:04:10.850
I take the a i and
said, OK, I'm going

01:04:10.850 --> 01:04:12.141
to have that many square tiles.

01:04:12.141 --> 01:04:14.720
But that is exactly
unary representation.

01:04:14.720 --> 01:04:17.520
And we know with 3-partition
that will have polynomial size.

01:04:17.520 --> 01:04:19.160
And so we're good.

01:04:19.160 --> 01:04:21.050
This is why we care
about strong NP-hardness

01:04:21.050 --> 01:04:23.550
so much, because a lot
of puzzles you can only

01:04:23.550 --> 01:04:25.107
represent numbers in unary.

01:04:25.107 --> 01:04:26.940
Then you're forced to
work with 3-partition.

01:04:29.590 --> 01:04:31.680
OK.

01:04:31.680 --> 01:04:36.070
Next puzzle is signed
edge-matching puzzles

01:04:36.070 --> 01:04:37.190
like the lizards.

01:04:37.190 --> 01:04:41.194
Suppose same set up,
but now the colors

01:04:41.194 --> 01:04:42.360
aren't supposed to be equal.

01:04:42.360 --> 01:04:44.710
They're supposed
to be opposites.

01:04:44.710 --> 01:04:46.840
So I'm just going to
modify this diagram,

01:04:46.840 --> 01:04:50.390
and I will use capital letters
to denote tails of lizards,

01:04:50.390 --> 01:04:53.660
and lowercase letters to
represent heads of lizards.

01:04:53.660 --> 01:04:55.560
And little b only
matches capital B.

01:04:55.560 --> 01:04:56.770
It does not match little b.

01:04:56.770 --> 01:04:59.630
You can't put two heads
together or two tails together.

01:04:59.630 --> 01:05:03.880
Well, you can
reduce these things,

01:05:03.880 --> 01:05:06.470
which are called unsigned
edge-matching puzzles,

01:05:06.470 --> 01:05:09.020
to these things,
which are called

01:05:09.020 --> 01:05:14.840
signed edge-matching puzzles,
with this easy gadget.

01:05:14.840 --> 01:05:17.680
If you have a tile
with, let's just say,

01:05:17.680 --> 01:05:19.320
colors ABCD-- some
of them might be

01:05:19.320 --> 01:05:23.560
equal-- I'm going to replace
that one tile with these four

01:05:23.560 --> 01:05:26.870
tiles and scale everything
up by a factor of 2-- scale

01:05:26.870 --> 01:05:29.250
the target shape
by a factor of 2.

01:05:29.250 --> 01:05:36.160
These colors appear exactly once
with each sign, and so again,

01:05:36.160 --> 01:05:39.170
because there's a frame and
all the boundary is eaten up,

01:05:39.170 --> 01:05:41.990
you're forced to match
these guys to each other.

01:05:41.990 --> 01:05:45.920
And therefore you're forced
to make this 2 by 2 tile.

01:05:45.920 --> 01:05:48.730
And so that 2 by
2 tile is supposed

01:05:48.730 --> 01:05:50.860
to represent this 1 by 1 tile.

01:05:50.860 --> 01:05:53.820
And the claim is signs
no longer matter,

01:05:53.820 --> 01:05:57.290
because we put little a, big
A, little b, big B, little c

01:05:57.290 --> 01:05:58.850
big C, and so on.

01:05:58.850 --> 01:06:02.460
So if I took another
tile like over here,

01:06:02.460 --> 01:06:05.010
and it has something
like capital D,

01:06:05.010 --> 01:06:07.190
lowercase d, that's
going to match

01:06:07.190 --> 01:06:11.430
with this lowercase b lowercase
b, if and only if b equals d.

01:06:11.430 --> 01:06:14.150
So if the original
colors are equal,

01:06:14.150 --> 01:06:16.950
the resulting colors will
be equal and opposite.

01:06:16.950 --> 01:06:19.430
So it'll be the same
letter of the alphabet,

01:06:19.430 --> 01:06:22.960
but with opposite signs, and
so everything will match up,

01:06:22.960 --> 01:06:25.189
because this capital
letter match here,

01:06:25.189 --> 01:06:26.980
and this lowercase
letter will match there.

01:06:26.980 --> 01:06:28.890
Is that clear?

01:06:28.890 --> 01:06:30.860
So it really becomes
the same puzzle,

01:06:30.860 --> 01:06:34.010
and this one's going to be
solvable only if this one is.

01:06:34.010 --> 01:06:37.010
So we get strong--
well, just NP-hardness

01:06:37.010 --> 01:06:39.290
of signed edge-matching puzzles.

01:06:39.290 --> 01:06:41.100
Cool.

01:06:41.100 --> 01:06:42.585
Next puzzle.

01:06:42.585 --> 01:06:43.960
These were all on
the same paper.

01:06:43.960 --> 01:06:45.010
It was a fun paper.

01:06:45.010 --> 01:06:46.150
This is even older.

01:06:46.150 --> 01:06:46.877
Jigsaw puzzles.

01:06:46.877 --> 01:06:48.460
This is not the
oldest jigsaw puzzles.

01:06:48.460 --> 01:06:50.200
It's one of the newest.

01:06:50.200 --> 01:06:52.880
It's our course poster
turned into a jigsaw puzzle.

01:06:52.880 --> 01:06:55.130
If you want to make your own
jigsaw puzzles, go there.

01:06:55.130 --> 01:06:57.230
They go back to the
1760s when they were made

01:06:57.230 --> 01:07:00.790
with jigsaws, hence the name.

01:07:00.790 --> 01:07:03.200
But basically, we
have square pieces,

01:07:03.200 --> 01:07:05.650
and each side of
the-- I'll assume

01:07:05.650 --> 01:07:07.490
that's a special kind
of jigsaw puzzle,

01:07:07.490 --> 01:07:10.400
most common-- each edge
can either be straight.

01:07:10.400 --> 01:07:12.040
That means it's on the boundary.

01:07:12.040 --> 01:07:15.360
It can be a pocked or a tab.

01:07:15.360 --> 01:07:18.710
And each pocket and tab is
slightly differently shaped,

01:07:18.710 --> 01:07:22.480
although maybe not on this
picture, usually they are.

01:07:22.480 --> 01:07:25.820
I'm going to allow that some
of the pockets and the tabs

01:07:25.820 --> 01:07:27.479
have the same shape.

01:07:27.479 --> 01:07:29.270
That's what you might
call ambiguous mates.

01:07:29.270 --> 01:07:31.510
Most jigsaw puzzles
sold in the world do not

01:07:31.510 --> 01:07:33.680
have ambiguous mates,
but let's say they do.

01:07:33.680 --> 01:07:36.915
And to make it
NP-hardcore, there

01:07:36.915 --> 01:07:38.500
is no image on the pieces.

01:07:38.500 --> 01:07:39.960
It's just a white puzzle.

01:07:39.960 --> 01:07:40.890
Now those are sold.

01:07:40.890 --> 01:07:45.780
You can buy all white or are
all single color puzzles.

01:07:48.357 --> 01:07:50.190
But usually they don't
have ambiguous mates.

01:07:50.190 --> 01:07:51.709
That's like the ultimate combo.

01:07:51.709 --> 01:07:53.500
If you don't assume
either of those things,

01:07:53.500 --> 01:07:54.570
then the problem is easy.

01:07:54.570 --> 01:07:55.797
So we don't care about that.

01:07:55.797 --> 01:07:57.880
But our paper is about how
to solve jigsaw puzzles

01:07:57.880 --> 01:07:59.790
in the practical case.

01:07:59.790 --> 01:08:03.450
But in our situation,
I mean, that basically

01:08:03.450 --> 01:08:05.820
is edge-matching
puzzles with science.

01:08:05.820 --> 01:08:09.340
This is actually probably why
I care about signed puzzles

01:08:09.340 --> 01:08:10.670
the most.

01:08:10.670 --> 01:08:11.970
I have lowercase letters.

01:08:11.970 --> 01:08:13.980
Those are going to
correspond to pockets.

01:08:13.980 --> 01:08:15.070
I have uppercase letters.

01:08:15.070 --> 01:08:16.653
Those are going to
correspond to tabs.

01:08:16.653 --> 01:08:18.620
And of course, a tab
must meet a pocket,

01:08:18.620 --> 01:08:22.279
same as a lowercase letter
must be an uppercase letter.

01:08:22.279 --> 01:08:25.200
And so that is the same thing.

01:08:25.200 --> 01:08:26.790
I would like my
target shape to be

01:08:26.790 --> 01:08:29.069
a square because that's clean.

01:08:29.069 --> 01:08:31.667
So whenever I have a
unique color, which is one

01:08:31.667 --> 01:08:33.250
that I know has to
be on the boundary,

01:08:33.250 --> 01:08:34.666
I'm going to make
it a flat thing.

01:08:34.666 --> 01:08:36.653
And then I know in this
series of reductions,

01:08:36.653 --> 01:08:38.319
I should draw this
series of reductions,

01:08:38.319 --> 01:08:39.360
because it's kind of fun.

01:08:46.080 --> 01:08:51.460
So far I kind of started
with rectangle packing.

01:08:51.460 --> 01:08:54.081
I guess technically we
started with 3-partition.

01:08:54.081 --> 01:08:56.109
I'll draw it like this.

01:08:59.260 --> 01:09:07.990
We reduce that to
edge-matching puzzles.

01:09:07.990 --> 01:09:13.634
Then we reduce that to
signed edge-matching puzzles.

01:09:20.859 --> 01:09:25.090
Then we reduced that
to jigsaw puzzles.

01:09:25.090 --> 01:09:27.319
And if you follow this
series of reductions

01:09:27.319 --> 01:09:29.890
and see what you get, we
know that the boundary shape

01:09:29.890 --> 01:09:33.710
will be a square because that
frame gadget is a square.

01:09:33.710 --> 01:09:35.660
And if we make all the
unique things flat,

01:09:35.660 --> 01:09:37.754
then the shape will
actually be square.

01:09:37.754 --> 01:09:39.920
There's a reason I'm drawing
it this way, because we

01:09:39.920 --> 01:09:43.080
have another one.

01:09:43.080 --> 01:09:46.645
So the next puzzle--
you might ask well,

01:09:46.645 --> 01:09:48.920
if Eternity II was an
edge-matching puzzle,

01:09:48.920 --> 01:09:50.235
what was Eternity I?

01:09:50.235 --> 01:09:54.160
Well, it's something called
a polyform packing puzzle.

01:09:54.160 --> 01:09:57.520
These are-- if you take
an equilateral triangle

01:09:57.520 --> 01:10:00.980
and cut in half like
that, that's a shape.

01:10:00.980 --> 01:10:04.540
If you take k copies
of that shape,

01:10:04.540 --> 01:10:09.132
join them edge to edge
along matching edge lengths,

01:10:09.132 --> 01:10:10.340
you can get all these shapes.

01:10:10.340 --> 01:10:12.810
It's like Tetris, but
instead of the squares

01:10:12.810 --> 01:10:15.400
you start with that shape and
you join a bunch more of them

01:10:15.400 --> 01:10:15.900
together.

01:10:15.900 --> 01:10:17.149
I don't know exactly how many.

01:10:17.149 --> 01:10:18.940
They may not even be
all the same area.

01:10:18.940 --> 01:10:22.770
And your goal is to fit
inside this big dodecagon

01:10:22.770 --> 01:10:25.320
or something.

01:10:25.320 --> 01:10:26.540
This was solved.

01:10:26.540 --> 01:10:31.735
One million pounds were
acquired by two people.

01:10:31.735 --> 01:10:34.995
I think they were
mathematicians,

01:10:34.995 --> 01:10:37.000
Alex and Oliver, in 2000.

01:10:37.000 --> 01:10:39.480
So actually quite soon
after the puzzle was posed,

01:10:39.480 --> 01:10:42.270
I think within less than a year.

01:10:42.270 --> 01:10:47.610
So there were articles about how
the insurance company was not

01:10:47.610 --> 01:10:49.250
happy.

01:10:49.250 --> 01:10:51.791
That's why you get insured
against a puzzle being solved,

01:10:51.791 --> 01:10:52.290
I guess.

01:10:52.290 --> 01:10:55.830
But in Eternity II, as a
consequence, it is much harder.

01:10:55.830 --> 01:10:57.350
So no one had solved
it yet, but it

01:10:57.350 --> 01:10:59.880
will happen someday I'm sure.

01:10:59.880 --> 01:11:03.300
So this gives you a clear sense
of what the shapes look like.

01:11:03.300 --> 01:11:08.090
So I want to prove these puzzles
are NP-hard also by reduction

01:11:08.090 --> 01:11:10.840
from jigsaw puzzles.

01:11:10.840 --> 01:11:13.950
So let's just bring
up the picture.

01:11:13.950 --> 01:11:15.500
So we just did this reduction.

01:11:15.500 --> 01:11:17.260
It actually works in both ways.

01:11:17.260 --> 01:11:18.740
They're really the same puzzle.

01:11:18.740 --> 01:11:21.680
This does not work so
easily in both ways.

01:11:21.680 --> 01:11:23.920
But I'm going to
take a jigsaw piece.

01:11:23.920 --> 01:11:26.360
I'm going to turn it into
roughly a square made up

01:11:26.360 --> 01:11:27.350
of little squares.

01:11:27.350 --> 01:11:29.979
I'm not going to work
on the half triangles,

01:11:29.979 --> 01:11:31.770
although I think it
wouldn't be any harder.

01:11:31.770 --> 01:11:34.360
It's a lot easier to
think about square puzzles

01:11:34.360 --> 01:11:35.160
more like Tetris.

01:11:35.160 --> 01:11:36.570
These are polyominos.

01:11:36.570 --> 01:11:39.560
So polyomino packing
is this type of puzzle.

01:11:39.560 --> 01:11:42.520
They also exist, but no one
has won one million pounds

01:11:42.520 --> 01:11:43.500
from them.

01:11:43.500 --> 01:11:45.490
So that's why I showed Eternity.

01:11:45.490 --> 01:11:48.020
So almost a square, but then
in the middle of the edge

01:11:48.020 --> 01:11:52.470
we're going to write in binary
what this shape was here.

01:11:52.470 --> 01:11:58.440
I mean, if there was a color
over here and a shape here,

01:11:58.440 --> 01:12:01.170
all we care about is whether
they're the same or different.

01:12:01.170 --> 01:12:05.920
So there's only 4n
different colors out there.

01:12:05.920 --> 01:12:08.390
So we're going to
take log of 4n bits

01:12:08.390 --> 01:12:09.950
and write them in this way.

01:12:09.950 --> 01:12:12.900
And if it was indented,
whenever we have a 1,

01:12:12.900 --> 01:12:14.440
we're going to indent here.

01:12:14.440 --> 01:12:18.530
And if it's a tab instead of a
pocket, wherever we have a 1,

01:12:18.530 --> 01:12:20.750
we're going to outdent.

01:12:20.750 --> 01:12:21.400
OK.

01:12:21.400 --> 01:12:25.860
So these are all
different codes.

01:12:25.860 --> 01:12:30.550
And so none of them fit
together, for example.

01:12:30.550 --> 01:12:32.750
And let's see.

01:12:32.750 --> 01:12:34.211
Does anything match up?

01:12:34.211 --> 01:12:36.620
AUDIENCE: Yes.

01:12:36.620 --> 01:12:38.920
PROFESSOR: This one
matches with this one,

01:12:38.920 --> 01:12:42.647
because if I rotate it around,
stick it on, it will match up.

01:12:42.647 --> 01:12:45.230
So you have to make sure you get
the orientations to the codes

01:12:45.230 --> 01:12:47.090
all right, but you can do this.

01:12:47.090 --> 01:12:48.920
And two things will
fit together and make

01:12:48.920 --> 01:12:53.620
a nice clean seem, if and only
if the original colors matched.

01:12:53.620 --> 01:12:56.320
And so this
represents that puzzle

01:12:56.320 --> 01:13:02.100
where we've blown everything
up by like a logarithmic factor

01:13:02.100 --> 01:13:04.900
in each dimension.

01:13:04.900 --> 01:13:09.780
But the number of pieces is
staying the same, in a sense.

01:13:09.780 --> 01:13:13.275
So that was this reduction
to polyomino packing.

01:13:19.640 --> 01:13:23.510
For fun, we close the loop, and
reduce from polyomino packing

01:13:23.510 --> 01:13:26.480
to edge-matching in this way.

01:13:26.480 --> 01:13:28.100
So we're going to
take our polyomino,

01:13:28.100 --> 01:13:29.700
carve it up into
little squares, turn

01:13:29.700 --> 01:13:31.940
them into edge-matching puzzle.

01:13:31.940 --> 01:13:34.670
And here I actually
want to allow rotation,

01:13:34.670 --> 01:13:38.080
so I'm going to change these
colors to all percent signs.

01:13:38.080 --> 01:13:41.434
And now it's just the
same puzzle again.

01:13:41.434 --> 01:13:42.850
So we have to use
the frame again.

01:13:42.850 --> 01:13:44.266
And so if you want,
you could just

01:13:44.266 --> 01:13:46.670
keep following these reductions
over and over and over.

01:13:46.670 --> 01:13:49.170
I think every time you do it,
you increase the scale factor

01:13:49.170 --> 01:13:51.350
by like a log factor.

01:13:51.350 --> 01:13:52.430
But it's kind of fun.

01:13:52.430 --> 01:13:53.971
I mean, it really
shows these puzzles

01:13:53.971 --> 01:13:57.730
are very close to
identical in that

01:13:57.730 --> 01:13:59.990
we didn't have to blow up
the puzzle size by very much

01:13:59.990 --> 01:14:02.060
to go from one
puzzle to the next.

01:14:02.060 --> 01:14:05.137
So usually we're just thinking
about polynomial blow up here.

01:14:05.137 --> 01:14:06.720
We have a very small
notion of blowup,

01:14:06.720 --> 01:14:09.000
which is some tight sense
in which these puzzles are

01:14:09.000 --> 01:14:12.040
almost the same.

01:14:12.040 --> 01:14:13.000
OK.

01:14:13.000 --> 01:14:15.202
End of paper.

01:14:15.202 --> 01:14:21.720
A fun open problem
is this reduction

01:14:21.720 --> 01:14:25.770
used log n by log n-- order
log n by log n pieces.

01:14:25.770 --> 01:14:30.020
What if your pieces
only have area log n?

01:14:30.020 --> 01:14:33.350
So maybe they're root log n by
root log n or something that.

01:14:33.350 --> 01:14:37.210
I'm sure it should still be in
NP-hard, but you never know.

01:14:37.210 --> 01:14:39.480
For example, they're
constant size.

01:14:44.240 --> 01:14:47.920
Actually, well, let's say,
if they're size 2, its easy.

01:14:47.920 --> 01:14:50.340
Leave it at that even if
the shape is very messy.

01:14:50.340 --> 01:14:52.370
But if there are also 2
by 2 blocks it's easy.

01:14:52.370 --> 01:14:54.610
So clearly small
shapes are too easy.

01:14:54.610 --> 01:14:56.460
But probably logarithmic
area is where

01:14:56.460 --> 01:14:57.699
it starts to get interesting.

01:14:57.699 --> 01:14:58.240
I don't know.

01:14:58.240 --> 01:14:59.540
What about log, log area?

01:14:59.540 --> 01:15:04.966
That's probably neither NP-hard
nor polynomial, but oh, well.

01:15:04.966 --> 01:15:05.465
Cool.

01:15:10.220 --> 01:15:15.710
So I want to talk about one
more problem-- one more hardness

01:15:15.710 --> 01:15:20.870
proof in this similar vein.

01:15:20.870 --> 01:15:22.465
It's about packing.

01:15:22.465 --> 01:15:24.650
I already erased
packing rectangles

01:15:24.650 --> 01:15:28.030
into rectangles or
rectangles into a square.

01:15:28.030 --> 01:15:31.409
What about squares
into a square?

01:15:31.409 --> 01:15:33.700
I don't know if you can tell
if that's a square and not

01:15:33.700 --> 01:15:34.810
a rectangle.

01:15:34.810 --> 01:15:35.310
OK.

01:15:35.310 --> 01:15:38.220
This is a nice paper.

01:15:38.220 --> 01:15:40.855
We've used it for other hardness
proofs, which we'll probably

01:15:40.855 --> 01:15:42.020
talk about next class.

01:15:42.020 --> 01:15:45.120
So I'm given a bunch of squares,
and I'm given a target square.

01:15:45.120 --> 01:15:46.870
Do these squares fit in there?

01:15:46.870 --> 01:15:50.260
And again, we will
probably use exact-- well,

01:15:50.260 --> 01:15:52.400
initially we won't
be exact packing.

01:15:52.400 --> 01:15:55.160
But let's say that
the squares can only

01:15:55.160 --> 01:15:56.430
rotate by a multiple of 90.

01:15:56.430 --> 01:15:59.090
In other words,
they can't rotate.

01:15:59.090 --> 01:16:03.280
We will fix that by
making exact packing.

01:16:03.280 --> 01:16:07.530
Why don't I jump
to the reduction?

01:16:07.530 --> 01:16:10.920
The heart of the reduction
is this idea-- we're just

01:16:10.920 --> 01:16:12.352
going to add a big number here.

01:16:12.352 --> 01:16:14.310
I am going to use capital
B for the big number.

01:16:14.310 --> 01:16:15.770
That's what's in the paper.

01:16:15.770 --> 01:16:18.310
This is a paper from 1990.

01:16:18.310 --> 01:16:22.200
Motivation here is you have a
big grid supercomputer, which

01:16:22.200 --> 01:16:25.090
were popular in
the '80s and '90s.

01:16:25.090 --> 01:16:28.550
And you have a job, which was
a square grid of processors,

01:16:28.550 --> 01:16:29.340
let's say.

01:16:29.340 --> 01:16:31.582
And you want to execute
them all in parallel,

01:16:31.582 --> 01:16:33.040
but they're not
allowed to overlap,

01:16:33.040 --> 01:16:35.520
because that would slow
your supercomputing down.

01:16:35.520 --> 01:16:38.240
But you are allowed
gaps, let's say.

01:16:38.240 --> 01:16:42.930
So I'm just going to take
each of my a i numbers,

01:16:42.930 --> 01:16:45.270
add this huge number to it.

01:16:45.270 --> 01:16:46.970
So they're all
roughly the same size.

01:16:46.970 --> 01:16:49.053
This is the trick we did
at the beginning of class

01:16:49.053 --> 01:16:50.220
with the 3-partition.

01:16:50.220 --> 01:16:50.720
All right.

01:16:50.720 --> 01:16:53.110
All these numbers-- all these
sizes are almost the same.

01:16:53.110 --> 01:16:55.485
I've drawn them quite different,
but imagine they're just

01:16:55.485 --> 01:16:57.210
like tiny fluctuations.

01:16:57.210 --> 01:16:59.940
And then I make the
height of this rectangle.

01:16:59.940 --> 01:17:02.010
For whatever reason I
transposed my image.

01:17:02.010 --> 01:17:04.095
That's probably why I
was confused earlier.

01:17:04.095 --> 01:17:08.050
And I just make the height
three times the big number--

01:17:08.050 --> 01:17:10.900
because I want three pieces
to come together-- plus t,

01:17:10.900 --> 01:17:12.820
my target sum of the a i's.

01:17:12.820 --> 01:17:15.660
So this is a huge thing
plus a super tiny thing.

01:17:15.660 --> 01:17:18.157
But what it's saying is
well, you could have slop.

01:17:18.157 --> 01:17:19.865
They're almost the
same size, but there's

01:17:19.865 --> 01:17:21.510
that little bit of extra.

01:17:21.510 --> 01:17:23.880
And that little bit of extra
has to add up to exactly t.

01:17:23.880 --> 01:17:27.990
So this is one triple with
the desired target sum.

01:17:27.990 --> 01:17:31.369
And then I want to get
n over three of them.

01:17:31.369 --> 01:17:33.160
Now here's where things
get a little dicey.

01:17:33.160 --> 01:17:36.770
You say, OK, let's just
say I take the largest one,

01:17:36.770 --> 01:17:39.155
or actually I'll go all
the way up to B plus t.

01:17:39.155 --> 01:17:42.350
I know that every number
I have is smaller than t,

01:17:42.350 --> 01:17:44.850
because I just saw the
sum of three of them is t.

01:17:44.850 --> 01:17:47.440
So I'm always going
to have a gap here.

01:17:47.440 --> 01:17:49.770
And let's say I just
packed the next three there

01:17:49.770 --> 01:17:50.600
and then the next three there.

01:17:50.600 --> 01:17:52.840
And so I'll leave enough
room that even with the slop

01:17:52.840 --> 01:17:54.390
I could fit everything in.

01:17:54.390 --> 01:17:57.870
So each one is B plus t, and
the number of them is n over 3.

01:17:57.870 --> 01:17:59.780
So that'll be the
width of my rectangle.

01:17:59.780 --> 01:18:01.440
Looks like a lot
of slop, but that's

01:18:01.440 --> 01:18:05.050
because I drew this with the
squares very different in size.

01:18:05.050 --> 01:18:10.580
If we compute the
amount of slop,

01:18:10.580 --> 01:18:16.110
the maximum, if you
look at this distance,

01:18:16.110 --> 01:18:18.360
it's at most t, certainly.

01:18:18.360 --> 01:18:21.260
Even if a i were 0,
which is not allowed,

01:18:21.260 --> 01:18:22.610
then this distance would be t.

01:18:22.610 --> 01:18:24.500
So it's going to be
even smaller than that.

01:18:24.500 --> 01:18:28.170
But the gaps here
are always at most t.

01:18:28.170 --> 01:18:37.650
So we can take-- so
this is total slop

01:18:37.650 --> 01:18:43.640
is t times the height.

01:18:43.640 --> 01:18:46.840
So that was like the width
of one sliver of slop,

01:18:46.840 --> 01:18:48.660
and then the height
is 3B plus t.

01:18:54.234 --> 01:18:55.900
And then times n over
3, because there's

01:18:55.900 --> 01:18:57.910
n over 3 of those things.

01:18:57.910 --> 01:19:01.320
And hopefully this works.

01:19:01.320 --> 01:19:05.320
I want to say this is
less than B squared

01:19:05.320 --> 01:19:13.710
if B is bigger than t times n.

01:19:13.710 --> 01:19:14.820
3s cancel.

01:19:14.820 --> 01:19:16.930
So if B is, I think
this term won't matter,

01:19:16.930 --> 01:19:19.870
because B is going
to be bigger than t.

01:19:19.870 --> 01:19:25.210
So maybe put a 2 there
for extra safety.

01:19:25.210 --> 01:19:27.070
Then you're totally dwarfed.

01:19:27.070 --> 01:19:29.420
So just dividing
both sides by B we're

01:19:29.420 --> 01:19:32.050
getting 3 times t
times n over part 3.

01:19:32.050 --> 01:19:33.000
That's 2 times n.

01:19:33.000 --> 01:19:35.350
OK.

01:19:35.350 --> 01:19:35.890
Cool.

01:19:35.890 --> 01:19:38.544
So the point is the
total area of slop

01:19:38.544 --> 01:19:40.460
that I have here is less
than a single square,

01:19:40.460 --> 01:19:42.994
because a single square
is even bigger than this.

01:19:42.994 --> 01:19:44.910
So you're not going to
be able to pack anymore

01:19:44.910 --> 01:19:49.460
squares, and that's
a vague argument,

01:19:49.460 --> 01:19:51.710
but enough hand-waving
later, and you've

01:19:51.710 --> 01:19:54.390
proved that, in fact, any
packing of these squares

01:19:54.390 --> 01:19:56.120
will give you 3-partition.

01:19:56.120 --> 01:19:59.600
That requires more
work, but this is

01:19:59.600 --> 01:20:04.300
some intuition why it is true.

01:20:04.300 --> 01:20:04.800
OK.

01:20:04.800 --> 01:20:08.339
So this was actually packing
squares into a rectangle.

01:20:08.339 --> 01:20:10.130
But that wasn't the
problem I started with.

01:20:10.130 --> 01:20:13.050
I wanted to pack
squares into a square.

01:20:13.050 --> 01:20:15.580
So for that you need an
infrastructure gadget

01:20:15.580 --> 01:20:17.850
like the frame that
we made before.

01:20:17.850 --> 01:20:22.920
And this is kind of acute
number theory-ish trick.

01:20:22.920 --> 01:20:24.960
I'm going to take
some integer x.

01:20:24.960 --> 01:20:26.000
We'll choose it later.

01:20:26.000 --> 01:20:29.190
It's just going to be big
enough-- something like n.

01:20:29.190 --> 01:20:32.080
And we have one
giant square, which

01:20:32.080 --> 01:20:35.080
is x times x plus 1 minus 1.

01:20:35.080 --> 01:20:37.930
But they're all squares,
so by the same amount.

01:20:37.930 --> 01:20:40.305
And then we're going to take
these medium-sized squares

01:20:40.305 --> 01:20:42.800
of size x plus 1 and the
small squares-- so much

01:20:42.800 --> 01:20:45.470
smaller-- of size x.

01:20:45.470 --> 01:20:48.596
And because this
is just one smaller

01:20:48.596 --> 01:20:50.220
than what it's supposed
to be-- I mean,

01:20:50.220 --> 01:20:55.300
if it was x times x plus 1 it
would sort of come to here.

01:20:55.300 --> 01:20:59.090
So when you pack these guys up
you go just one too far there.

01:20:59.090 --> 01:21:01.940
But there's exactly
enough room for one more.

01:21:01.940 --> 01:21:04.790
If I put x plus one
extra, this is x.

01:21:04.790 --> 01:21:08.110
That's the one, and so on.

01:21:08.110 --> 01:21:12.435
So this leaves, as
a gap, a rectangle.

01:21:12.435 --> 01:21:13.810
Now this is not
the only solution

01:21:13.810 --> 01:21:15.470
these guys could
slide down, but you

01:21:15.470 --> 01:21:17.480
can show that will only
make your life harder.

01:21:17.480 --> 01:21:19.770
And the paper does that.

01:21:19.770 --> 01:21:21.540
That's sort of the
easy part of the proof.

01:21:21.540 --> 01:21:23.710
And so now you're
left with a rectangle,

01:21:23.710 --> 01:21:27.210
which is 1 by this thing.

01:21:27.210 --> 01:21:35.020
You multiply everything
by the 3B plus t,

01:21:35.020 --> 01:21:37.860
because that was what we
wanted one of our dimensions

01:21:37.860 --> 01:21:39.850
to be-- the smaller one.

01:21:39.850 --> 01:21:41.530
So that scaled up the rectangle.

01:21:41.530 --> 01:21:45.510
And then the horizontal-- the
width may not match exactly.

01:21:45.510 --> 01:21:47.592
But if there's too
much space here,

01:21:47.592 --> 01:21:49.300
and let me just set
x to be large enough,

01:21:49.300 --> 01:21:50.760
then there will be extra space.

01:21:50.760 --> 01:21:52.946
And just throw in a
bunch of B by B blocks

01:21:52.946 --> 01:21:54.320
there to fill up
the extra space.

01:21:54.320 --> 01:21:56.320
So you can figure out how
much extra space there

01:21:56.320 --> 01:21:57.960
is and fill it in.

01:21:57.960 --> 01:22:00.450
So they you go-- packing
squares into a square.

01:22:00.450 --> 01:22:02.560
And this is strong
NP-hardness of this.

01:22:02.560 --> 01:22:05.770
Even when the squares are
only of polynomial area,

01:22:05.770 --> 01:22:07.430
this problem is hard,
which is actually

01:22:07.430 --> 01:22:10.280
the case you care about when
each of these 1 by 1 squares

01:22:10.280 --> 01:22:11.940
is a processor.

01:22:11.940 --> 01:22:14.916
Now this is not exact packing,
and so you might wonder oh,

01:22:14.916 --> 01:22:17.040
what if I rotate the squares,
and then crazy things

01:22:17.040 --> 01:22:18.060
could happen.

01:22:18.060 --> 01:22:21.230
Probably not, but you
could also just compute

01:22:21.230 --> 01:22:23.013
how much extra slop
there is, because you

01:22:23.013 --> 01:22:24.969
know the area of
the input squares,

01:22:24.969 --> 01:22:26.760
and you know the area
of the target square.

01:22:26.760 --> 01:22:30.520
And just add a whole bunch
of 1 by 1 little chips,

01:22:30.520 --> 01:22:32.320
and that will fill
in exactly the space.

01:22:32.320 --> 01:22:33.486
Then you have exact packing.

01:22:33.486 --> 01:22:35.560
Then you don't even have
to worry about rotation.

01:22:35.560 --> 01:22:37.301
So that makes
proof even cleaner.

01:22:37.301 --> 01:22:39.050
I think that wasn't
in the original paper,

01:22:39.050 --> 01:22:41.280
but it's a nice little addition.

01:22:41.280 --> 01:22:44.730
And that is our packing
through 3-partition.

01:22:44.730 --> 01:22:47.800
Next class we'll
do more 3-partition

01:22:47.800 --> 01:22:50.480
for different types of problems.

01:22:50.480 --> 01:22:53.220
So in case you lose lots of
pieces in your jigsaw puzzle,

01:22:53.220 --> 01:22:57.180
we have the one-piece
jigsaw puzzle.

01:22:57.180 --> 01:23:01.190
This is all the pieces are
in one giant connected mess.

01:23:01.190 --> 01:23:07.512
And still it is not
so trivial to solve.

01:23:07.512 --> 01:23:08.011
Wow.

01:23:11.901 --> 01:23:13.150
AUDIENCE: [INTERPOSING VOICES]

01:23:13.150 --> 01:23:14.025
PROFESSOR: All right.

01:23:14.025 --> 01:23:17.454
This is the one-piece jigsaw
puzzle in solve state.

01:23:17.454 --> 01:23:19.845
It's the Simpson's addition.

01:23:19.845 --> 01:23:22.240
It's-- you get it.

01:23:22.240 --> 01:23:23.490
AUDIENCE: [INTERPOSING VOICES]

01:23:23.490 --> 01:23:25.290
AUDIENCE: And then
you put that in.

01:23:25.290 --> 01:23:26.790
And then you put
it in your slop.

01:23:26.790 --> 01:23:28.290
AUDIENCE: Yep. [INAUDIBLE].

01:23:28.290 --> 01:23:29.840
PROFESSOR: Ta-da.