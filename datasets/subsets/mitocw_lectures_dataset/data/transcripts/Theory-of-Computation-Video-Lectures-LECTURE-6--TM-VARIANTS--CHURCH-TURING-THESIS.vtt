WEBVTT

00:00:00.000 --> 00:00:02.475
[SQUEAKING]

00:00:02.475 --> 00:00:03.960
[RUSTLING]

00:00:03.960 --> 00:00:05.940
[CLICKING]

00:00:25.762 --> 00:00:26.970
MICHAEL SIPSER: OK, everyone.

00:00:26.970 --> 00:00:28.920
Let's get started.

00:00:28.920 --> 00:00:36.290
Welcome back to Theory of
Computation lecture number six.

00:00:36.290 --> 00:00:46.990
So we have been looking at
a number of different models

00:00:46.990 --> 00:00:49.250
of computation.

00:00:49.250 --> 00:00:54.410
And last lecture actually
was an important one for us,

00:00:54.410 --> 00:01:01.520
because we shifted gears
from our restricted models,

00:01:01.520 --> 00:01:03.830
finite automata,
pushdown automata,

00:01:03.830 --> 00:01:09.270
and their associated generative
models, regular expressions,

00:01:09.270 --> 00:01:14.480
and context-free grammars
to Turing machines, which

00:01:14.480 --> 00:01:16.688
are going to be the model
that we're going to-- which

00:01:16.688 --> 00:01:18.522
is the model that we're
going to be sticking

00:01:18.522 --> 00:01:20.090
with for the rest
of the semester,

00:01:20.090 --> 00:01:22.250
because that's going to
be our model, as we're

00:01:22.250 --> 00:01:26.930
going to argue today, for
a general purpose computer.

00:01:26.930 --> 00:01:29.470
So in a sense, everything
we've been doing up till now

00:01:29.470 --> 00:01:32.650
or up until that point has
been kind of a warm up.

00:01:32.650 --> 00:01:36.280
But it's been nevertheless
has gotten a chance for us

00:01:36.280 --> 00:01:38.950
to introduce some
important concepts that

00:01:38.950 --> 00:01:42.970
are used in practice and also
will serve as good examples

00:01:42.970 --> 00:01:44.170
for us moving forward.

00:01:44.170 --> 00:01:53.360
And also just to get kind of
in a sense on the same page.

00:01:53.360 --> 00:01:57.250
So what we're going
to be doing today

00:01:57.250 --> 00:02:05.060
is looking at the
Turing machine model

00:02:05.060 --> 00:02:07.770
in a little bit more depth.

00:02:07.770 --> 00:02:12.410
One can define Turing machines
in all sorts of different ways.

00:02:12.410 --> 00:02:14.270
But it's going to turn
out not to matter,

00:02:14.270 --> 00:02:16.070
because all of
those different ways

00:02:16.070 --> 00:02:18.570
are going to be
equivalent to one another.

00:02:18.570 --> 00:02:23.300
And so we are going to stick
with the very simplest version,

00:02:23.300 --> 00:02:27.050
the one we've already
defined, namely the simple one

00:02:27.050 --> 00:02:28.250
tape Turing machine.

00:02:28.250 --> 00:02:32.870
But we're going to
basically justify that

00:02:32.870 --> 00:02:34.570
by looking at some
of these other models

00:02:34.570 --> 00:02:35.570
and proving equivalence.

00:02:35.570 --> 00:02:41.010
So we will look at
multi-tape Turing machines,

00:02:41.010 --> 00:02:43.262
we'll look at non-deterministic
Turing machines,

00:02:43.262 --> 00:02:45.720
and we'll look at another model
which is slightly different

00:02:45.720 --> 00:02:49.340
but it's still based on Turing
machines called an enumerator.

00:02:49.340 --> 00:02:52.490
And we'll show that
those all in the end

00:02:52.490 --> 00:02:55.370
give you the same
class of languages.

00:02:55.370 --> 00:02:59.040
And so in that sense, they're
all equivalent to one another.

00:02:59.040 --> 00:03:03.860
And that's going to be-- serve
as a kind of a motivator, kind

00:03:03.860 --> 00:03:08.510
of in a sense recapitulate some
of the history of the subject,

00:03:08.510 --> 00:03:12.620
and going to lead to our
discussion of what's called

00:03:12.620 --> 00:03:14.030
the Church Turing thesis.

00:03:14.030 --> 00:03:19.620
So we will get to
that in due course.

00:03:19.620 --> 00:03:27.770
And we'll also talk about
some notation for notations

00:03:27.770 --> 00:03:30.980
for Turing machines and
for encoding objects

00:03:30.980 --> 00:03:32.990
to feed into Turing
machines as input,

00:03:32.990 --> 00:03:36.540
but we'll get to
that shortly as well.

00:03:36.540 --> 00:03:38.420
So let's move on, then.

00:03:38.420 --> 00:03:46.220
We will next go into a
little review of what

00:03:46.220 --> 00:03:48.020
we did with Turing machines.

00:03:48.020 --> 00:03:50.840
And just want to make sure
we're all together on that.

00:03:50.840 --> 00:03:53.520
It's a very important
concept for us this term.

00:03:53.520 --> 00:03:55.070
So the Turing
machine model looks

00:03:55.070 --> 00:03:57.590
like there's going to
be this finite control.

00:03:57.590 --> 00:04:01.790
There's a tape with a head that
can read and write on the tape,

00:04:01.790 --> 00:04:03.020
can move in both directions.

00:04:03.020 --> 00:04:05.990
The tape is infinite
to one side and so on,

00:04:05.990 --> 00:04:07.610
as I mentioned last time.

00:04:10.210 --> 00:04:13.990
The output of the Turing machine
is either going to be a halt,

00:04:13.990 --> 00:04:17.350
accepting or rejecting, or
loop that the machine may

00:04:17.350 --> 00:04:18.220
run forever.

00:04:18.220 --> 00:04:21.519
With three possible outcomes
for any particular input.

00:04:21.519 --> 00:04:25.030
The machine may accept that
input by entering q accept.

00:04:25.030 --> 00:04:28.300
May halt and reject
by entering q reject.

00:04:28.300 --> 00:04:30.670
And it might reject
by looping, which

00:04:30.670 --> 00:04:32.590
means it just never
gets to the accept state

00:04:32.590 --> 00:04:36.070
or it never gets
any halting state.

00:04:36.070 --> 00:04:37.210
It just goes forever.

00:04:37.210 --> 00:04:39.550
But we still consider that
to be rejecting the input,

00:04:39.550 --> 00:04:41.620
just it's rejecting by looping.

00:04:45.310 --> 00:04:48.730
And as we defined last
time, a language is Turing

00:04:48.730 --> 00:04:51.010
recognizable, or as
we typically write,

00:04:51.010 --> 00:04:53.920
T recognizable, if it's
the language of some Turing

00:04:53.920 --> 00:04:57.760
machine, the collection
of accepted strings

00:04:57.760 --> 00:04:59.140
from that Turing machine.

00:04:59.140 --> 00:05:01.240
Again, just as
before, the machine

00:05:01.240 --> 00:05:05.380
may accept 0 strings,
one string, many strings,

00:05:05.380 --> 00:05:09.670
but it always has one
language, the collection of all

00:05:09.670 --> 00:05:12.010
accepted strings.

00:05:12.010 --> 00:05:14.380
Now, if you have
a decider, which

00:05:14.380 --> 00:05:16.240
is a machine that
never loops, which

00:05:16.240 --> 00:05:19.930
always halts on
every input, then we

00:05:19.930 --> 00:05:23.470
say its language is
a decidable language.

00:05:23.470 --> 00:05:25.810
So we'll say a language
is Turing decidable

00:05:25.810 --> 00:05:31.660
or simply decidable if it's the
language of some decider, which

00:05:31.660 --> 00:05:36.140
is a Turing machine that
always halts on all inputs.

00:05:36.140 --> 00:05:38.230
So we have those two
distinct notions,

00:05:38.230 --> 00:05:40.420
Turing recognizable
languages and Turning

00:05:40.420 --> 00:05:41.620
decidable languages.

00:05:44.260 --> 00:05:46.870
Now, as we're going
to argue this lecture,

00:05:46.870 --> 00:05:49.900
Turing machines are going to be
our model of a general purpose

00:05:49.900 --> 00:05:50.540
computer.

00:05:50.540 --> 00:05:52.665
So that's the way we're
going to think of computers

00:05:52.665 --> 00:05:54.840
as Turing machines.

00:05:54.840 --> 00:05:57.720
And why Turing machines?

00:05:57.720 --> 00:05:59.670
Why didn't we pick
something else?

00:05:59.670 --> 00:06:01.500
Well, the fact is,
it doesn't matter.

00:06:01.500 --> 00:06:04.290
And that's going to be
the point of this lecture.

00:06:04.290 --> 00:06:08.550
All reasonable models of
general purpose computation,

00:06:08.550 --> 00:06:15.150
unrestricted computation in the
sense of not limited memory,

00:06:15.150 --> 00:06:17.190
are all going to be--

00:06:17.190 --> 00:06:20.670
all have been shown,
all the models

00:06:20.670 --> 00:06:22.260
that we've ever
encountered have all

00:06:22.260 --> 00:06:24.940
been shown to be
equivalent to one another.

00:06:24.940 --> 00:06:27.930
And so you're free to
pick any one you like.

00:06:27.930 --> 00:06:29.760
And so for this
course, we're going

00:06:29.760 --> 00:06:32.010
to pick Turing machines
because they're

00:06:32.010 --> 00:06:34.980
very simple to argue
about mathematically,

00:06:34.980 --> 00:06:40.310
and also they have some
element of familiarity

00:06:40.310 --> 00:06:44.150
in that they feel like--

00:06:44.150 --> 00:06:49.160
well, they're more familiar than
some of the other models that

00:06:49.160 --> 00:06:52.140
have been proposed
that are out there,

00:06:52.140 --> 00:06:56.425
such as rewriting systems,
lambda calculus, and so on.

00:06:56.425 --> 00:06:59.390
Turing machines feel like a
primitive kind of computer.

00:06:59.390 --> 00:07:03.070
And in that sense, they
have a certain familiarity.

00:07:03.070 --> 00:07:07.990
OK, so let's start
talking about variations

00:07:07.990 --> 00:07:09.460
on the Turing machine model.

00:07:09.460 --> 00:07:14.425
And we're going to argue that
it doesn't make any difference.

00:07:14.425 --> 00:07:15.800
And then this is
going to be kind

00:07:15.800 --> 00:07:19.160
of a precursor to a discussion
of a bit of the history

00:07:19.160 --> 00:07:20.810
of the subject that
we're gonna get to

00:07:20.810 --> 00:07:22.830
in the second half
of the lecture.

00:07:22.830 --> 00:07:27.170
So a multi-tape Turing
machine is a Turing machine,

00:07:27.170 --> 00:07:29.960
as you might imagine,
that has more than one--

00:07:29.960 --> 00:07:32.930
well, has one or
possibly more tapes.

00:07:32.930 --> 00:07:34.700
And so a single
tape Turing machine

00:07:34.700 --> 00:07:38.660
would be a special version of
a multi-tape Turing machine.

00:07:38.660 --> 00:07:39.890
That's OK.

00:07:39.890 --> 00:07:42.080
But you might have
more than one tape,

00:07:42.080 --> 00:07:45.020
as I've shown in this diagram.

00:07:45.020 --> 00:07:49.340
Now, how do we actually use
a multi-tape Turing machine?

00:07:49.340 --> 00:07:50.690
Well, you present the--

00:07:50.690 --> 00:07:53.180
and we're going to see these
coming up for convenience.

00:07:53.180 --> 00:07:56.390
Sometimes it's nice to be
working with multiple tapes.

00:07:56.390 --> 00:07:58.610
So we're going to see these
later on in the semester

00:07:58.610 --> 00:08:00.240
a couple of times as well.

00:08:00.240 --> 00:08:04.100
But for now, we're
setting the model up

00:08:04.100 --> 00:08:08.060
so that the input is going to
be presented on a special input

00:08:08.060 --> 00:08:09.170
tape.

00:08:09.170 --> 00:08:10.700
So that's where
the input appears,

00:08:10.700 --> 00:08:14.130
and it's going to be followed by
blanks, just as we had before.

00:08:14.130 --> 00:08:16.820
And now we have these
potentially other tapes,

00:08:16.820 --> 00:08:20.540
possibly other tapes, which
we call them work tapes

00:08:20.540 --> 00:08:25.850
where the machine can write
other stuff as it wishes.

00:08:25.850 --> 00:08:28.190
And those tapes are going
to be initially blank.

00:08:28.190 --> 00:08:31.690
So just all blanks on them.

00:08:31.690 --> 00:08:33.880
All of the tapes are going
to be read and write.

00:08:33.880 --> 00:08:35.710
So you can write
on the input tape.

00:08:35.710 --> 00:08:37.900
Obviously you can read
off on the input tape,

00:08:37.900 --> 00:08:42.289
and you can read and write
on the other tapes as well.

00:08:42.289 --> 00:08:45.010
So what we want to
first establish that

00:08:45.010 --> 00:08:47.260
by having these
additional tapes,

00:08:47.260 --> 00:08:51.430
you don't get additional power
for the machine in the sense

00:08:51.430 --> 00:08:52.990
that you're not going to have--

00:08:56.680 --> 00:09:00.880
you won't have
additional languages

00:09:00.880 --> 00:09:03.310
that you can recognize
by virtue of having

00:09:03.310 --> 00:09:04.770
these additional tapes.

00:09:04.770 --> 00:09:07.540
I mean, you can imagine
that having more tapes

00:09:07.540 --> 00:09:10.630
will allow you to
do more things.

00:09:10.630 --> 00:09:14.440
For example, if you have
a pushdown automaton

00:09:14.440 --> 00:09:18.070
with two stacks, you
can do more languages

00:09:18.070 --> 00:09:19.960
than you can with one stack.

00:09:19.960 --> 00:09:22.510
So it's conceivable that
by having more tapes,

00:09:22.510 --> 00:09:27.450
you can do more languages
than you could with one tape.

00:09:27.450 --> 00:09:29.410
But in fact, that's
not the case.

00:09:29.410 --> 00:09:32.560
One tape is as good
as having many tapes.

00:09:32.560 --> 00:09:33.810
And we're going to prove that.

00:09:33.810 --> 00:09:39.670
We're going to quickly sketch
through the proof of that fact.

00:09:39.670 --> 00:09:43.830
So the theorem is
that a language

00:09:43.830 --> 00:09:45.240
is Turing recognizable.

00:09:45.240 --> 00:09:47.460
And when we say Turing
recognizable, for now

00:09:47.460 --> 00:09:49.380
we mean just with one tape.

00:09:49.380 --> 00:09:52.200
So that's the way
we've defined it.

00:09:52.200 --> 00:09:55.440
So a language is Turing
recognizable if and only

00:09:55.440 --> 00:09:57.840
if some multi-tape
Turing machine recognizes

00:09:57.840 --> 00:10:00.670
that language.

00:10:00.670 --> 00:10:03.610
So really another
way of saying that is

00:10:03.610 --> 00:10:06.250
if you have a language that
you can do with a single tape,

00:10:06.250 --> 00:10:09.720
you can do it with a
multi-tape and vice versa.

00:10:09.720 --> 00:10:12.020
So one direction of
that is immediate,

00:10:12.020 --> 00:10:15.020
because a single tape
Turing machine is already

00:10:15.020 --> 00:10:17.120
a multi-tape Turing machine
that just so happens

00:10:17.120 --> 00:10:19.070
to have one tape.

00:10:19.070 --> 00:10:23.330
So the forward
direction of that is--

00:10:23.330 --> 00:10:25.130
there's nothing to say.

00:10:25.130 --> 00:10:28.440
That's just immediately true.

00:10:28.440 --> 00:10:30.170
But if we want to
prove the reverse,

00:10:30.170 --> 00:10:32.660
then we're going to
have to do some work.

00:10:32.660 --> 00:10:34.160
And the work is
going to be showing

00:10:34.160 --> 00:10:37.580
how do you convert a multi-tape
Turing machine to a single tape

00:10:37.580 --> 00:10:39.350
Turing machine.

00:10:39.350 --> 00:10:41.200
So if we have something
that's recognized

00:10:41.200 --> 00:10:44.460
by a multi-tape Turing machine,
it's still Turing recognizable.

00:10:44.460 --> 00:10:46.960
And what that means is that you
can do it with a single tape

00:10:46.960 --> 00:10:47.720
Turing machine.

00:10:47.720 --> 00:10:51.010
So we have to show how
to do the conversion.

00:10:51.010 --> 00:10:55.630
And I'll show you that I
think in a convincing way

00:10:55.630 --> 00:10:58.970
but without getting
into too much detail.

00:10:58.970 --> 00:11:03.370
So here is an image of a
multi-tape Turing machine

00:11:03.370 --> 00:11:05.380
during the course of its input.

00:11:05.380 --> 00:11:08.860
So we've already started it off.

00:11:08.860 --> 00:11:12.340
Initially it starts off
with the other tapes,

00:11:12.340 --> 00:11:13.870
the work tapes being all blank.

00:11:13.870 --> 00:11:16.600
But now it's
processed for a while

00:11:16.600 --> 00:11:19.900
and the head on
the input tape now

00:11:19.900 --> 00:11:22.720
has moved off from its starting
position at the left end.

00:11:22.720 --> 00:11:24.010
It's somewhere in the middle.

00:11:24.010 --> 00:11:28.000
It's written stuff
on the other tapes.

00:11:28.000 --> 00:11:30.220
And what we want
to do is show how

00:11:30.220 --> 00:11:36.530
to represent that same
information on a single tape

00:11:36.530 --> 00:11:40.460
Turing machine in a way which
allows the single tape Turing

00:11:40.460 --> 00:11:46.250
machine to carry out the
steps of the multi-tape Turing

00:11:46.250 --> 00:11:50.060
machine but using only
a single tape by virtue

00:11:50.060 --> 00:11:53.330
of some kind of a data structure
which allows for the simulation

00:11:53.330 --> 00:11:56.760
to go forward.

00:11:56.760 --> 00:12:01.050
So how is the single tape Turing
machine going to be simulating,

00:12:01.050 --> 00:12:06.000
going to be carrying out
the same effect of having

00:12:06.000 --> 00:12:09.000
these multiple tapes on the
multi-tape Turing machine?

00:12:09.000 --> 00:12:11.250
So here's a picture of the
single tape Turing machine.

00:12:11.250 --> 00:12:13.787
It just has one tape.

00:12:13.787 --> 00:12:15.870
By the way, I should mention
that all of the tapes

00:12:15.870 --> 00:12:19.680
are infinite to the right in
the multi-tape Turing machine,

00:12:19.680 --> 00:12:22.170
just as we had for the
single tape Turing machine.

00:12:22.170 --> 00:12:25.500
And now with this single
tape Turing machine,

00:12:25.500 --> 00:12:29.550
it's going to represent
the information that's

00:12:29.550 --> 00:12:33.060
present on these multiple tapes
but using only the single tape.

00:12:33.060 --> 00:12:34.530
And the way I'm
choosing to do that

00:12:34.530 --> 00:12:36.840
is going to be
particularly simple.

00:12:36.840 --> 00:12:41.310
I'm going to just divide up,
so here I'm saying it in words.

00:12:41.310 --> 00:12:43.140
It's going to
simulate m by storing

00:12:43.140 --> 00:12:46.230
the contents of the
multi-tape on the single tape

00:12:46.230 --> 00:12:47.940
in separate blocks.

00:12:47.940 --> 00:12:52.740
So I'm basically going to
divide up the single tape Turing

00:12:52.740 --> 00:12:57.030
machines tape into
separate regions where

00:12:57.030 --> 00:12:58.920
each one of those
regions is going

00:12:58.920 --> 00:13:01.170
to have the information
that was on one

00:13:01.170 --> 00:13:07.340
of the tapes in the
multi-tape machine.

00:13:07.340 --> 00:13:11.740
So for example, on the first
tape it's got a, a, b, a.

00:13:11.740 --> 00:13:13.210
Well, that's going
to appear here

00:13:13.210 --> 00:13:15.700
in that first block on the
single tape Turing machine.

00:13:18.420 --> 00:13:20.580
Sort of seeing it
float down to suggest

00:13:20.580 --> 00:13:23.190
that it's coming from this
multi-tape Turing machine.

00:13:23.190 --> 00:13:26.653
But that's really been
developed by the simulation

00:13:26.653 --> 00:13:28.320
that the single tape
Turing machine has.

00:13:28.320 --> 00:13:30.030
Obviously the single
tape Turing machine

00:13:30.030 --> 00:13:33.390
doesn't have any direct access
to the multi-tape machine.

00:13:33.390 --> 00:13:35.490
But it's going to be simulating.

00:13:35.490 --> 00:13:38.010
So this is how we're
showing the data is

00:13:38.010 --> 00:13:40.950
being stored on the
single tape machines tape.

00:13:40.950 --> 00:13:42.450
So in the second
block, it's going

00:13:42.450 --> 00:13:46.470
to have the contents of the
second tape of the Turing

00:13:46.470 --> 00:13:49.150
multi-tape machine.

00:13:49.150 --> 00:13:55.970
And the final region
of the single tapes,

00:13:55.970 --> 00:14:00.600
the final block so-called of
the single tape's tape is going

00:14:00.600 --> 00:14:02.350
to have-- the single
tape machine's tape--

00:14:02.350 --> 00:14:07.170
it's going to have the
rest of the contents

00:14:07.170 --> 00:14:09.863
of the last tape of m.

00:14:09.863 --> 00:14:11.280
And then it's going
to be followed

00:14:11.280 --> 00:14:17.520
by the same infinitely many
blanks that each of these tapes

00:14:17.520 --> 00:14:20.820
are going to have
following the portion

00:14:20.820 --> 00:14:23.220
that they may have
written during the course

00:14:23.220 --> 00:14:26.460
of their computation.

00:14:26.460 --> 00:14:29.010
So that's what the single
tape Turing machine's tape

00:14:29.010 --> 00:14:32.073
is going to look like during
the course of its computation.

00:14:32.073 --> 00:14:33.990
It's going to have the
information represented

00:14:33.990 --> 00:14:35.550
in these blocks.

00:14:35.550 --> 00:14:38.010
Capturing all of the information
that the multi-tape Turing

00:14:38.010 --> 00:14:41.100
machine has in a perhaps
somewhat less convenient way,

00:14:41.100 --> 00:14:43.500
because the multi-tape
Turing machine,

00:14:43.500 --> 00:14:45.355
we didn't really
make this explicit.

00:14:45.355 --> 00:14:47.230
And in part because it
doesn't really matter,

00:14:47.230 --> 00:14:49.890
we didn't say exactly how the
multi tape machine operates.

00:14:49.890 --> 00:14:52.860
What I have in mind is that
the multi-tape Turing machine

00:14:52.860 --> 00:14:56.730
can read and move
all of its heads

00:14:56.730 --> 00:15:00.620
from all of its
heads in one step.

00:15:00.620 --> 00:15:02.740
So in a single step of
the multi-tape machine,

00:15:02.740 --> 00:15:05.440
it can obtain the
information that's

00:15:05.440 --> 00:15:08.320
underneath each of
its heads, feed that

00:15:08.320 --> 00:15:10.400
in through its
transition function,

00:15:10.400 --> 00:15:13.340
and then together with the
state of the multi-tape machine

00:15:13.340 --> 00:15:16.370
decide how to change
each of those locations

00:15:16.370 --> 00:15:19.058
and then how to move
each one of those heads.

00:15:19.058 --> 00:15:21.475
So it's kind of operating on
all of the tapes in parallel.

00:15:24.860 --> 00:15:29.300
So now how does the actual
steps of the simulation

00:15:29.300 --> 00:15:31.610
of the single tape--

00:15:31.610 --> 00:15:35.760
by the single tape
machine, how does it go?

00:15:35.760 --> 00:15:42.270
So first of all, besides
storing the contents

00:15:42.270 --> 00:15:48.312
of each of the tapes
in S's single tape,

00:15:48.312 --> 00:15:49.770
there's some
additional information

00:15:49.770 --> 00:15:50.770
that it needs to record.

00:15:50.770 --> 00:16:00.690
Namely, M has a head for
each one of its tapes.

00:16:00.690 --> 00:16:03.780
But S has just a single head.

00:16:03.780 --> 00:16:06.960
And each of M's heads could
be in some different location.

00:16:06.960 --> 00:16:10.890
In this case, as I've shown
it, on the first tape,

00:16:10.890 --> 00:16:12.540
its head is in location three.

00:16:12.540 --> 00:16:14.310
On the second tape,
it's in location two.

00:16:14.310 --> 00:16:16.740
On the third tape, it's on
location-- on the last tape,

00:16:16.740 --> 00:16:19.080
it's in location one.

00:16:19.080 --> 00:16:21.030
So where were we?

00:16:21.030 --> 00:16:24.210
We were simulating the
multi-tape Turing machine

00:16:24.210 --> 00:16:26.490
with the single
tape Turing machine.

00:16:26.490 --> 00:16:30.413
And we had to keep track
of where the heads are.

00:16:30.413 --> 00:16:32.080
And so we're going
to do that by writing

00:16:32.080 --> 00:16:36.130
the locations on those blocks.

00:16:36.130 --> 00:16:43.040
So we're going to have a
special dot, as I've shown here,

00:16:43.040 --> 00:16:47.480
to represent the location of the
head in that very first block.

00:16:47.480 --> 00:16:48.650
So the head's on the b.

00:16:48.650 --> 00:16:50.150
I'm going to dot the b.

00:16:50.150 --> 00:16:53.510
And I'm going to do the
same thing for the locations

00:16:53.510 --> 00:16:57.450
of the other heads.

00:16:57.450 --> 00:16:59.250
And how am I
getting that effect?

00:16:59.250 --> 00:17:01.620
Well, we've seen
something like that

00:17:01.620 --> 00:17:06.000
before, where we just expand
the tape alphabet of S

00:17:06.000 --> 00:17:09.480
to allow for these
dotted symbols as well

00:17:09.480 --> 00:17:11.579
as the irregular symbols.

00:17:11.579 --> 00:17:14.550
We also have expanded it to
include the delimiter markers

00:17:14.550 --> 00:17:16.170
that separate the
blocks from one

00:17:16.170 --> 00:17:18.849
another, which I'm
writing as a pound sign.

00:17:18.849 --> 00:17:20.819
So we can just get
that effect simply

00:17:20.819 --> 00:17:24.940
by expanding the
tape alphabet of S.

00:17:24.940 --> 00:17:28.530
A few more details of S that
are just worth looking at,

00:17:28.530 --> 00:17:30.630
just to make sure we're
kind of all understanding

00:17:30.630 --> 00:17:32.910
what's happening.

00:17:32.910 --> 00:17:37.170
So for every time
M takes one step,

00:17:37.170 --> 00:17:39.030
S has actually a
lot of work to do.

00:17:39.030 --> 00:17:43.020
Because one step of M can
read and move all of those

00:17:43.020 --> 00:17:44.475
heads all at one shot.

00:17:44.475 --> 00:17:50.910
S has to scan the
entire tape to see

00:17:50.910 --> 00:17:54.510
what's underneath those in
effect virtual heads, which

00:17:54.510 --> 00:17:57.540
are the locations of
the dotted symbols.

00:17:57.540 --> 00:18:02.860
It has to see what's underneath
each one of those heads

00:18:02.860 --> 00:18:07.510
to see how to update its
state to the next state.

00:18:07.510 --> 00:18:14.590
And then it has to scan
again to change the location,

00:18:14.590 --> 00:18:17.560
change the contents of
those tape locations,

00:18:17.560 --> 00:18:20.890
and also to move the head left
or right by effectively now

00:18:20.890 --> 00:18:22.420
moving the dot left or right.

00:18:22.420 --> 00:18:24.363
So that's pretty
straightforward.

00:18:27.190 --> 00:18:31.810
There's one complication
that can occur, however,

00:18:31.810 --> 00:18:38.680
which is that what happens if
on one of the tapes, let's say,

00:18:38.680 --> 00:18:44.770
M starts writing
more content than you

00:18:44.770 --> 00:18:51.280
have room in that block
to store that information?

00:18:51.280 --> 00:18:55.990
So if M, it has
1, 0, 1, suppose M

00:18:55.990 --> 00:18:59.050
after a few steps moves its
head into the originally

00:18:59.050 --> 00:19:01.540
blank portion of the tape and
writes another symbol there.

00:19:01.540 --> 00:19:03.362
We have to put that
symbol somewhere,

00:19:03.362 --> 00:19:05.320
because we have to record
all that information.

00:19:05.320 --> 00:19:07.420
And the block is full.

00:19:07.420 --> 00:19:09.020
So what do we do?

00:19:09.020 --> 00:19:13.120
Well, in that case, S goes
to a little interrupt routine

00:19:13.120 --> 00:19:22.660
and moves, shifts all of the
symbols to the right one place

00:19:22.660 --> 00:19:27.790
to open up a location here
where it can write a new symbol

00:19:27.790 --> 00:19:33.260
for continuing the simulation.

00:19:33.260 --> 00:19:39.500
So with that in mind, S can
maintain the current contents

00:19:39.500 --> 00:19:40.940
of each of of M's tapes.

00:19:40.940 --> 00:19:43.880
And let me just note that here.

00:19:43.880 --> 00:19:46.510
Shift to add room is needed.

00:19:46.510 --> 00:19:49.000
And that's all that
happens during the course

00:19:49.000 --> 00:19:50.860
of the simulation.

00:19:50.860 --> 00:19:56.320
And of course, if S
as it's simulating M

00:19:56.320 --> 00:20:00.040
observes that M comes to
an accept or reject state,

00:20:00.040 --> 00:20:03.260
S should do the same.

00:20:03.260 --> 00:20:07.550
So that's our description
of how the single tape

00:20:07.550 --> 00:20:11.850
simulation of the
multi-tape machine works.

00:20:11.850 --> 00:20:14.160
Let's turn to
non-deterministic machines.

00:20:14.160 --> 00:20:17.840
Now, if you remember
for finite, and I

00:20:17.840 --> 00:20:19.820
hope you do, for
finite automata,

00:20:19.820 --> 00:20:22.760
we had equivalence between
non-deterministic and

00:20:22.760 --> 00:20:25.310
deterministic.

00:20:25.310 --> 00:20:26.510
Finite automata.

00:20:26.510 --> 00:20:29.600
For pushdown automata, we
did not have the equivalence.

00:20:29.600 --> 00:20:32.300
We didn't prove that, but
we just stated it as a fact.

00:20:32.300 --> 00:20:33.800
There are certain
languages that you

00:20:33.800 --> 00:20:36.320
can do with non-deterministic
pushdown automata, which

00:20:36.320 --> 00:20:38.930
is the model we typically
hold as our standard.

00:20:38.930 --> 00:20:41.960
So that some things you can do
with non-deterministic automata

00:20:41.960 --> 00:20:44.420
that you cannot do with
deterministic pushdown

00:20:44.420 --> 00:20:45.680
automata.

00:20:45.680 --> 00:20:47.420
You really need the
non-determinism.

00:20:47.420 --> 00:20:49.340
They're not equivalent.

00:20:49.340 --> 00:20:54.050
For Turing machines, we're going
to get the equivalence back.

00:20:54.050 --> 00:20:56.455
So we'll show that
anything you can

00:20:56.455 --> 00:20:58.580
do with a non-deterministic
Turing machine in terms

00:20:58.580 --> 00:21:00.410
of language recognition,
you can also

00:21:00.410 --> 00:21:02.040
do with a deterministic
Turing machine.

00:21:02.040 --> 00:21:03.957
So remember, we kind of
mentioned this briefly

00:21:03.957 --> 00:21:07.430
last time, the
non-deterministic Turing machine

00:21:07.430 --> 00:21:10.160
looks exactly like a
deterministic Turing machine

00:21:10.160 --> 00:21:11.690
except for the
transition function

00:21:11.690 --> 00:21:13.670
where we have this
power set, which

00:21:13.670 --> 00:21:17.960
allows for multiple
different outcomes at a given

00:21:17.960 --> 00:21:19.790
step instead of just
a single outcome

00:21:19.790 --> 00:21:22.220
that you would have in
a deterministic machine.

00:21:22.220 --> 00:21:27.200
So we represent that
with this power set here

00:21:27.200 --> 00:21:30.980
applied to the possibilities
that the machine would

00:21:30.980 --> 00:21:33.800
have as the next step.

00:21:36.295 --> 00:21:38.420
So now we're going to prove
a very similar theorem,

00:21:38.420 --> 00:21:42.300
that A is Turing recognizable
by an ordinary one tape Turing

00:21:42.300 --> 00:21:42.800
machine.

00:21:42.800 --> 00:21:44.175
That kind of goes
without saying,

00:21:44.175 --> 00:21:45.560
since that's how we defined it.

00:21:45.560 --> 00:21:47.420
It's Turing
recognizable if and only

00:21:47.420 --> 00:21:49.250
of some non-deterministic
Turing machine

00:21:49.250 --> 00:21:50.510
recognizes the language.

00:21:53.870 --> 00:21:55.970
Again, remember we're
using non-determinism

00:21:55.970 --> 00:21:57.410
in the way we always do.

00:21:57.410 --> 00:22:00.590
Namely that a
non-deterministic machine

00:22:00.590 --> 00:22:03.620
accepts if there is some
branch or some thread

00:22:03.620 --> 00:22:06.350
of its computation
ends up at an accept.

00:22:06.350 --> 00:22:11.240
Other branches might go forever
or might reject part of the way

00:22:11.240 --> 00:22:12.800
through.

00:22:12.800 --> 00:22:16.490
But acceptance always overrules
then if any branch accepts.

00:22:16.490 --> 00:22:19.370
That's how non-determinism
works for us.

00:22:19.370 --> 00:22:23.160
So now the forward
direction of this

00:22:23.160 --> 00:22:25.320
is, again, just like
before, immediate

00:22:25.320 --> 00:22:27.240
because a deterministic
Turing machine

00:22:27.240 --> 00:22:30.090
is a special kind of
non-deterministic Turing

00:22:30.090 --> 00:22:33.150
machine which never branches
non-deterministically

00:22:33.150 --> 00:22:35.580
on any of its steps.

00:22:35.580 --> 00:22:38.165
So that forward
direction is immediate.

00:22:38.165 --> 00:22:39.540
The backwards
definition is where

00:22:39.540 --> 00:22:41.880
we're going to have to
do some work converting

00:22:41.880 --> 00:22:43.410
our non-deterministic
Turing machine

00:22:43.410 --> 00:22:44.970
to a deterministic
Turing machine.

00:22:44.970 --> 00:22:46.180
And we'll do so as follows.

00:22:46.180 --> 00:22:49.260
We'll take a non-deterministic
Turing machine.

00:22:49.260 --> 00:22:50.160
Here is our picture.

00:22:50.160 --> 00:22:54.570
And we're going to now
imagine its computation

00:22:54.570 --> 00:22:57.130
in terms of a tree.

00:22:57.130 --> 00:23:00.090
And so here is the
non-deterministic computation

00:23:00.090 --> 00:23:03.030
tree for n on some input w.

00:23:03.030 --> 00:23:06.880
So n for non-deterministic.

00:23:06.880 --> 00:23:08.920
Here is the tree.

00:23:08.920 --> 00:23:11.470
Somewhere down here it
might end up accepting.

00:23:11.470 --> 00:23:13.480
And as I mentioned,
that is going

00:23:13.480 --> 00:23:17.440
to be defining the
overall computation

00:23:17.440 --> 00:23:21.070
to be accepting if there is some
place here that's accepting.

00:23:21.070 --> 00:23:24.460
And the only way it can be
non-accepting computation

00:23:24.460 --> 00:23:28.620
if there is no accept
that occurs anywhere.

00:23:28.620 --> 00:23:30.360
And somehow if you're
going to convert

00:23:30.360 --> 00:23:33.540
this non-deterministic machine
to a deterministic machine,

00:23:33.540 --> 00:23:35.430
the deterministic
machine is going

00:23:35.430 --> 00:23:36.825
to have to get that same effect.

00:23:39.660 --> 00:23:41.470
It doesn't have the
non-determinism.

00:23:41.470 --> 00:23:43.170
So how does it manage that?

00:23:43.170 --> 00:23:47.340
Well, it's really going to be
carrying out the simulation

00:23:47.340 --> 00:23:52.410
kind of as you would imagine
doing it yourself if you were

00:23:52.410 --> 00:23:54.900
told you had to simulate
a non-deterministic Turing

00:23:54.900 --> 00:23:57.240
machine, which is
you're going to search

00:23:57.240 --> 00:23:59.790
that tree of
possibilities looking

00:23:59.790 --> 00:24:01.440
to see if you find and accept.

00:24:01.440 --> 00:24:02.730
If you do, then you accept.

00:24:02.730 --> 00:24:05.670
If you don't, well,
maybe you'll go forever

00:24:05.670 --> 00:24:08.430
or maybe you'll manage to
search the entire tree,

00:24:08.430 --> 00:24:15.420
and then you will say, no,
I accept, no, I reject.

00:24:15.420 --> 00:24:18.030
So let's just see,
again, what the data

00:24:18.030 --> 00:24:20.490
structure of that
deterministic machine's tape

00:24:20.490 --> 00:24:23.170
is going to look like.

00:24:23.170 --> 00:24:26.270
So the way this simulation
is going to carry out,

00:24:26.270 --> 00:24:29.500
and you could program this
in a host of different ways.

00:24:29.500 --> 00:24:32.490
And in fact, the textbook has a
somewhat different simulation.

00:24:32.490 --> 00:24:36.720
But I think this one here lends
itself a little bit better

00:24:36.720 --> 00:24:39.750
and maybe it's a little
simpler for description

00:24:39.750 --> 00:24:43.740
in this setting.

00:24:43.740 --> 00:24:46.350
But there's lots of different
ways of improving these things.

00:24:46.350 --> 00:24:50.730
So m is going to simulate
n kind of a little bit

00:24:50.730 --> 00:24:53.580
similar to the
previous simulation.

00:24:53.580 --> 00:24:57.740
It's going to break the
tape up into blocks,

00:24:57.740 --> 00:25:02.480
and it's going to now
store in each block

00:25:02.480 --> 00:25:06.530
a different thread at a
particular point in time

00:25:06.530 --> 00:25:09.750
of n's computation.

00:25:09.750 --> 00:25:13.620
So you imagine where m
is going to be simulating

00:25:13.620 --> 00:25:20.480
n sort of doing the
same parallelism

00:25:20.480 --> 00:25:24.500
but getting the effect
of the parallelism

00:25:24.500 --> 00:25:28.640
not through the non-determinism
but by maintaining copies

00:25:28.640 --> 00:25:31.310
of each of the
threads on its tape

00:25:31.310 --> 00:25:34.790
and then updating
them accordingly.

00:25:34.790 --> 00:25:39.351
So the idea is, I think,
not too complicated.

00:25:39.351 --> 00:25:41.940
So let's just see some
of the details here.

00:25:41.940 --> 00:25:48.260
So here populating those
blocks with the contents of n's

00:25:48.260 --> 00:25:51.410
tape on different threads.

00:25:51.410 --> 00:25:56.360
Maybe that corresponds
to n's tape

00:25:56.360 --> 00:26:01.760
after the fifth step of n
on each of those threads.

00:26:01.760 --> 00:26:04.530
You have these three
possibilities, let's say,

00:26:04.530 --> 00:26:06.155
written down as three
different blocks.

00:26:09.890 --> 00:26:15.170
Now, remember in the case of
the multi-tape simulation,

00:26:15.170 --> 00:26:18.890
we needed to record
some extra information.

00:26:18.890 --> 00:26:22.790
In particular, we had to record
the location of the heads

00:26:22.790 --> 00:26:24.170
by using those dotted symbols.

00:26:24.170 --> 00:26:26.307
We're going to do that
again because each one

00:26:26.307 --> 00:26:27.890
of these threads
might have their head

00:26:27.890 --> 00:26:29.090
in some different location.

00:26:29.090 --> 00:26:31.650
But we're going to
have to do more.

00:26:31.650 --> 00:26:33.320
So let's do one thing at a time.

00:26:33.320 --> 00:26:36.050
We're going to store
the head location.

00:26:36.050 --> 00:26:40.220
Here they are all written
down as dotted symbols.

00:26:40.220 --> 00:26:42.620
But now there's something
that goes further.

00:26:42.620 --> 00:26:49.930
Because in a multi-tape case,
there was one global state

00:26:49.930 --> 00:26:52.090
that the multi-tape
machine was in,

00:26:52.090 --> 00:26:53.320
of course, at any given time.

00:26:53.320 --> 00:26:55.180
It's just that one has
one finite control.

00:26:55.180 --> 00:26:55.960
It's in one state.

00:26:59.950 --> 00:27:02.500
But in the case of the
non-deterministic machine

00:27:02.500 --> 00:27:05.500
that we're simulating
now, each thread

00:27:05.500 --> 00:27:06.805
can be in a different state.

00:27:09.590 --> 00:27:12.100
So whereas before,
we could keep track

00:27:12.100 --> 00:27:16.960
of the multi-tape machine's
state inside the single tape

00:27:16.960 --> 00:27:19.090
machine's finite control.

00:27:19.090 --> 00:27:21.190
Now there could be many,
many different states

00:27:21.190 --> 00:27:22.780
to keep track of.

00:27:22.780 --> 00:27:25.030
So you won't be able to store
that in a finite control

00:27:25.030 --> 00:27:27.488
anymore, because there could
be some huge number of threads

00:27:27.488 --> 00:27:28.833
active at any given stage.

00:27:28.833 --> 00:27:30.250
And some of them
can be one state.

00:27:30.250 --> 00:27:31.625
Others can be in
different state.

00:27:31.625 --> 00:27:33.220
And how do you keep
track of all that?

00:27:33.220 --> 00:27:35.320
So we're going to
have to use the tape.

00:27:35.320 --> 00:27:38.680
We're going to actually write
down which state a given

00:27:38.680 --> 00:27:41.770
thread is in on that block.

00:27:41.770 --> 00:27:42.640
And we'll do that.

00:27:42.640 --> 00:27:44.960
I'll show it like this.

00:27:44.960 --> 00:27:48.700
So writing down the state
of each thread in the block

00:27:48.700 --> 00:27:56.180
by writing down symbols which
correspond to those states.

00:27:56.180 --> 00:27:58.760
So we're actually in a sense
writing the states down right

00:27:58.760 --> 00:28:00.855
on top of the block
using symbols that

00:28:00.855 --> 00:28:01.980
correspond to those states.

00:28:01.980 --> 00:28:04.250
So again, we're
getting that effect

00:28:04.250 --> 00:28:08.360
by increasing the
tape alphabet of M

00:28:08.360 --> 00:28:13.190
to include symbols
that correspond

00:28:13.190 --> 00:28:15.067
to each of its states.

00:28:15.067 --> 00:28:16.900
And we're going to write
those symbols down.

00:28:16.900 --> 00:28:19.360
So here's the
symbol for state q8

00:28:19.360 --> 00:28:23.440
that says, well, that very
first thread of n's computation

00:28:23.440 --> 00:28:24.730
is in state q8.

00:28:24.730 --> 00:28:30.100
It's in this third
position on its tape.

00:28:30.100 --> 00:28:31.840
The head is on the
third position there.

00:28:31.840 --> 00:28:34.190
And the tape contents
is a, a, b, a.

00:28:34.190 --> 00:28:39.100
That's how we represent that
thread of the computation

00:28:39.100 --> 00:28:40.000
including the state.

00:28:44.450 --> 00:28:48.800
So M is going to carry out
that step by step maintaining

00:28:48.800 --> 00:28:50.780
that information on its tape.

00:28:50.780 --> 00:28:53.060
Again, similar to
before, there might

00:28:53.060 --> 00:28:54.920
be some special
situations arising.

00:28:54.920 --> 00:28:57.590
So for example, n is
non-deterministic.

00:28:57.590 --> 00:29:02.900
So a thread might
fork into two threads.

00:29:02.900 --> 00:29:04.650
What do we do then?

00:29:04.650 --> 00:29:08.570
Well, sort of the
reasonable thing.

00:29:08.570 --> 00:29:11.570
If there's a forking
thread, M then

00:29:11.570 --> 00:29:15.090
copies that block, makes
two copies of the block

00:29:15.090 --> 00:29:18.950
to correspond, or however
many copies you need,

00:29:18.950 --> 00:29:21.200
to correspond to
the possibilities

00:29:21.200 --> 00:29:24.260
that that thread
is branching into.

00:29:24.260 --> 00:29:26.840
So you want to represent
them all on different blocks

00:29:26.840 --> 00:29:29.000
of M's tape.

00:29:29.000 --> 00:29:30.380
All right?

00:29:30.380 --> 00:29:34.670
And then if M ever finds out
that on one of the threads

00:29:34.670 --> 00:29:36.830
it's entering the
accept state, it

00:29:36.830 --> 00:29:39.140
can just shut down the whole
computation at that point

00:29:39.140 --> 00:29:40.055
and say accept.

00:29:43.770 --> 00:29:47.550
So perhaps a little elaborate,
but I think conceptually,

00:29:47.550 --> 00:29:52.420
hopefully, not too bad.

00:29:52.420 --> 00:29:59.730
Now, let's move on then
to talk about somewhat

00:29:59.730 --> 00:30:02.640
of a different looking--

00:30:02.640 --> 00:30:05.850
well, sort of a different
model, in a way, which

00:30:05.850 --> 00:30:08.670
has some historical significance
and sometimes is a helpful way

00:30:08.670 --> 00:30:11.940
to look at Turing
recognizability.

00:30:11.940 --> 00:30:15.810
And incidentally, you
have a homework problem

00:30:15.810 --> 00:30:20.310
on this model called
an enumerator or Turing

00:30:20.310 --> 00:30:22.920
enumerator.

00:30:22.920 --> 00:30:30.310
So here it's going to
operate somewhat differently.

00:30:30.310 --> 00:30:33.280
First of all, we're going to
enhance the Turing machine

00:30:33.280 --> 00:30:33.780
model.

00:30:33.780 --> 00:30:35.490
It's going to now have
just a single tape.

00:30:35.490 --> 00:30:37.073
But it's going to
also have a printer.

00:30:39.760 --> 00:30:44.080
So we're now adding
in this new device

00:30:44.080 --> 00:30:47.560
into the Turing machine
called a printer.

00:30:47.560 --> 00:30:54.820
And the Turing machine
has tape as before,

00:30:54.820 --> 00:30:59.250
except we never provide
any input to the machine.

00:30:59.250 --> 00:31:02.160
The tape always starts
out fully blank.

00:31:02.160 --> 00:31:04.860
It's only used for
reading and writing.

00:31:04.860 --> 00:31:10.650
Only used for work.

00:31:10.650 --> 00:31:12.730
It's not where you
present the input.

00:31:12.730 --> 00:31:15.420
So how do you talk about
the language of the machine?

00:31:15.420 --> 00:31:17.700
Well, the way you work
this machine is you

00:31:17.700 --> 00:31:19.325
take this enumerator.

00:31:19.325 --> 00:31:21.450
It's a deterministic Turing
machine with a printer,

00:31:21.450 --> 00:31:22.290
as I mentioned.

00:31:22.290 --> 00:31:24.150
You started off in blank tape.

00:31:24.150 --> 00:31:28.260
And it runs and runs and
runs and periodically it

00:31:28.260 --> 00:31:32.692
can print a string under some
sort of program control, which

00:31:32.692 --> 00:31:34.150
I'm not going to
spell out for you.

00:31:34.150 --> 00:31:35.760
But you can imagine
you might have

00:31:35.760 --> 00:31:38.010
to define the
machine in such a way

00:31:38.010 --> 00:31:40.710
that when it goes into
a certain print state,

00:31:40.710 --> 00:31:43.290
we're not going to set
that all up, then whatever

00:31:43.290 --> 00:31:45.540
string is in a certain
region of the tape

00:31:45.540 --> 00:31:49.710
maybe from the start point up
into the head location, that

00:31:49.710 --> 00:31:53.160
gets printed out on the printer.

00:31:53.160 --> 00:31:57.010
And then it can print out
other strings in due course.

00:31:57.010 --> 00:32:00.750
And so periodically, you
think of this printer

00:32:00.750 --> 00:32:07.200
as printing out a string under
the control of the Turing

00:32:07.200 --> 00:32:09.600
machine enumerator.

00:32:09.600 --> 00:32:12.810
And so these print strings,
these strings that could

00:32:12.810 --> 00:32:16.620
print out w1, w2, they appear.

00:32:16.620 --> 00:32:20.910
And the machine might
possibly go forever and print

00:32:20.910 --> 00:32:22.530
infinitely many strings.

00:32:22.530 --> 00:32:26.700
Or it might go forever and only
print finitely many strings.

00:32:26.700 --> 00:32:30.258
Or it might stop after a while
by entering a halting state.

00:32:30.258 --> 00:32:31.800
Accepting or rejecting
is irrelevant,

00:32:31.800 --> 00:32:33.510
but it enters a halting state.

00:32:33.510 --> 00:32:36.600
And then the strings
that it's print out,

00:32:36.600 --> 00:32:38.940
the finitely many
strings it printed out,

00:32:38.940 --> 00:32:40.840
that's the output
of the machine.

00:32:40.840 --> 00:32:43.860
Now, the language of the
machine is the collection

00:32:43.860 --> 00:32:46.020
of all strings that
it ever prints out.

00:32:49.740 --> 00:32:52.240
So we're defining language in
a somewhat different way here.

00:32:52.240 --> 00:32:54.580
It's not the strings
that it accepts.

00:32:54.580 --> 00:32:57.580
It's the strings that it prints.

00:32:57.580 --> 00:32:59.950
So we think of this
machine almost a little bit

00:32:59.950 --> 00:33:02.530
analogous to the
regular expression

00:33:02.530 --> 00:33:05.620
or the grammar in the sense
that it's a generative model.

00:33:05.620 --> 00:33:09.550
It produces the language
rather than accepts the strings

00:33:09.550 --> 00:33:10.240
in the language.

00:33:13.490 --> 00:33:15.050
It's not really a recognizer.

00:33:15.050 --> 00:33:16.070
It's a generator.

00:33:16.070 --> 00:33:18.950
And the language of the
machine, as writing over here,

00:33:18.950 --> 00:33:22.340
for an enumerator here, we say
its language is a collection

00:33:22.340 --> 00:33:23.510
of strings that it prints.

00:33:26.390 --> 00:33:29.810
Now we will show that a
language is Turing recognizable

00:33:29.810 --> 00:33:34.760
in the previous sense recognized
by some ordinary Turing

00:33:34.760 --> 00:33:39.432
machine if and only if it's the
language of some enumerator.

00:33:39.432 --> 00:33:41.140
And actually this is
kind of a little bit

00:33:41.140 --> 00:33:42.430
of an interesting proof.

00:33:42.430 --> 00:33:43.720
You have to do some work.

00:33:43.720 --> 00:33:44.710
It's an if only if.

00:33:44.710 --> 00:33:46.630
Now neither direction
is immediate.

00:33:46.630 --> 00:33:49.620
You're going to have to do
some work in both directions.

00:33:49.620 --> 00:33:51.620
One direction is a little
harder than the other.

00:33:51.620 --> 00:33:53.500
We'll start off with
the easier direction.

00:33:53.500 --> 00:33:55.390
Let's say we have an enumerator.

00:33:58.620 --> 00:34:01.170
Hopefully you got this
concept of this Turing machine

00:34:01.170 --> 00:34:05.040
which periodically prints
strings when you started it off

00:34:05.040 --> 00:34:06.240
on the empty tape.

00:34:09.800 --> 00:34:12.909
So now what I'm going
to construct for you

00:34:12.909 --> 00:34:17.290
is that Turing
machine recognizer

00:34:17.290 --> 00:34:20.260
defined from the enumerator.

00:34:20.260 --> 00:34:24.800
So this recognizer is going to
be simulating the enumerator.

00:34:24.800 --> 00:34:30.350
So basically that recognizer is
going to launch the enumerator.

00:34:30.350 --> 00:34:34.570
It's going to start
off simulating it.

00:34:34.570 --> 00:34:36.280
Now, if you want,
if it's convenient,

00:34:36.280 --> 00:34:37.840
we could use several tapes.

00:34:37.840 --> 00:34:40.570
We can use one tape to
simulate the recognizer

00:34:40.570 --> 00:34:43.150
and you have other tapes
available for convenience

00:34:43.150 --> 00:34:44.830
if you want, because
we already showed

00:34:44.830 --> 00:34:46.760
multi-tape and single
tape are equivalent.

00:34:46.760 --> 00:34:49.530
So if you want, you can think
of M as having multiple tapes.

00:34:49.530 --> 00:34:53.800
It's not going to really be that
relevant to my conversation.

00:34:53.800 --> 00:34:56.679
But you're going to simulate
E starting on the blank input,

00:34:56.679 --> 00:34:58.480
as you're supposed to.

00:34:58.480 --> 00:35:01.780
And then you're going to
see whenever E prints in x,

00:35:01.780 --> 00:35:04.870
you're going to see
if x is the same

00:35:04.870 --> 00:35:07.890
as the input to the recognizer.

00:35:07.890 --> 00:35:09.280
You get the idea?

00:35:09.280 --> 00:35:10.500
So we have a recognizer.

00:35:10.500 --> 00:35:14.760
It has an input string,
maybe like 1, 1, 0, 1.

00:35:14.760 --> 00:35:15.810
And I want to know.

00:35:15.810 --> 00:35:18.600
I want to accept that string
if it's one of the strings

00:35:18.600 --> 00:35:22.650
that the enumerator E
prints out, because that's

00:35:22.650 --> 00:35:23.680
what the recognizer do.

00:35:23.680 --> 00:35:25.305
It's supposed to
accept all the strings

00:35:25.305 --> 00:35:26.820
that the enumerator prints out.

00:35:26.820 --> 00:35:28.575
So I got this 1, 1, 0, 1.

00:35:28.575 --> 00:35:29.940
What do I do?

00:35:29.940 --> 00:35:32.800
I fire up that numerator,
I get it going,

00:35:32.800 --> 00:35:35.340
and I start watching the
strings it prints out,

00:35:35.340 --> 00:35:39.110
comparing them with my
input string, 1, 1, 0, 1.

00:35:39.110 --> 00:35:44.140
If I ever see it print
out a 1, 1, 0, 1, great.

00:35:44.140 --> 00:35:45.970
I know I can accept,
because I know it's

00:35:45.970 --> 00:35:48.350
in the enumerator's language.

00:35:48.350 --> 00:35:50.470
But if I compare and
compare and compare,

00:35:50.470 --> 00:35:54.940
I never see the enumerator
ever printing out

00:35:54.940 --> 00:35:57.550
my input string 1, 1, 0, 1.

00:35:57.550 --> 00:35:58.930
Well, I just keep simulating.

00:35:58.930 --> 00:36:02.080
If E halts, well then
I can halt and reject

00:36:02.080 --> 00:36:06.130
if I've never seen that string
coming out as an output.

00:36:06.130 --> 00:36:08.950
If E doesn't halt, well, I'm
just not going to halt either.

00:36:08.950 --> 00:36:10.120
I'm going to go forever.

00:36:10.120 --> 00:36:14.740
But then I'm going to be
rejecting my input by looping.

00:36:14.740 --> 00:36:17.770
So that's the
proof of converting

00:36:17.770 --> 00:36:20.643
in this backward direction,
which is the easier direction.

00:36:20.643 --> 00:36:22.310
Now let's look at the
forward direction,

00:36:22.310 --> 00:36:24.640
which has a certain
wrinkle in it that we're

00:36:24.640 --> 00:36:27.120
going to have to get to.

00:36:27.120 --> 00:36:29.310
So now we're going to be
building our enumerator

00:36:29.310 --> 00:36:32.280
to simulate our recognizer.

00:36:32.280 --> 00:36:36.400
And the way we'll do
that is the enumerator

00:36:36.400 --> 00:36:39.820
has to print out
all of the strings

00:36:39.820 --> 00:36:42.370
that the recognizer
would ever accept.

00:36:45.060 --> 00:36:47.040
So you kind of do
the obvious thing.

00:36:47.040 --> 00:36:48.930
You're going to take--

00:36:48.930 --> 00:36:53.160
the enumerator is going to
start simulating the recognizer

00:36:53.160 --> 00:36:56.130
M on all possible strings.

00:36:56.130 --> 00:37:01.650
Sort of one by one, doing them
in parallel, taking turns.

00:37:01.650 --> 00:37:04.080
Maybe we didn't make
this so explicit.

00:37:04.080 --> 00:37:07.410
But you can sort of timeshare
among several different

00:37:07.410 --> 00:37:09.060
possibilities.

00:37:09.060 --> 00:37:12.310
Sort of like having different
blocks for the machine.

00:37:15.870 --> 00:37:21.360
The enumerator is going
to run the recognizer on--

00:37:21.360 --> 00:37:23.440
well, let's just say it
does it sequentially.

00:37:23.440 --> 00:37:24.930
It runs it on the empty string.

00:37:24.930 --> 00:37:26.640
It runs it on the string 0.

00:37:26.640 --> 00:37:28.140
It runs it on the string one.

00:37:28.140 --> 00:37:30.450
Runs it on the string 0, 0.

00:37:30.450 --> 00:37:32.700
These are all the possible
strings of sigma star.

00:37:32.700 --> 00:37:35.010
You run on all of them.

00:37:35.010 --> 00:37:39.390
And whenever the enumerator--

00:37:42.900 --> 00:37:44.790
uh oh.

00:37:44.790 --> 00:37:45.420
This is wrong.

00:37:53.810 --> 00:38:05.310
So whenever M
accepts, then print--

00:38:05.310 --> 00:38:07.710
I can't write very well.

00:38:07.710 --> 00:38:14.385
Print w, wi.

00:38:14.385 --> 00:38:14.885
Oops.

00:38:18.910 --> 00:38:19.930
OK.

00:38:19.930 --> 00:38:22.700
So I'm going to just
say it in words.

00:38:22.700 --> 00:38:25.300
I'm want to simulate
M on each wi.

00:38:25.300 --> 00:38:30.190
Whenever you notice M accepting
wi, you just print out wi.

00:38:33.580 --> 00:38:36.280
Because you want to print
out all of the strings

00:38:36.280 --> 00:38:38.500
that M accepts.

00:38:38.500 --> 00:38:41.150
Now, there is a problem here.

00:38:41.150 --> 00:38:43.855
So hopefully you're not
confused by this typo.

00:38:46.640 --> 00:38:48.980
Doing it sequentially
like I just described

00:38:48.980 --> 00:38:50.340
doesn't quite work.

00:38:50.340 --> 00:38:52.390
So let me just
back that up here.

00:38:52.390 --> 00:38:54.680
Doing it sequentially
doesn't quite work,

00:38:54.680 --> 00:39:00.140
because M might get stuck
looping on one of the wi's.

00:39:00.140 --> 00:39:07.550
Like maybe when I feed 0
into M, M goes forever.

00:39:07.550 --> 00:39:10.190
Because M is rejecting
0 by looping.

00:39:10.190 --> 00:39:12.950
But maybe it also
accepts this next string

00:39:12.950 --> 00:39:15.320
in the list, the string one.

00:39:15.320 --> 00:39:19.070
I'll never get to one by just
feeding the strings into M one

00:39:19.070 --> 00:39:21.320
by one like this.

00:39:21.320 --> 00:39:24.020
What I really have to do
is run all of the strings

00:39:24.020 --> 00:39:26.390
in M in parallel.

00:39:26.390 --> 00:39:27.920
And the way I'm
going to indicate

00:39:27.920 --> 00:39:33.830
that is I want to simulate
M on w1 to wi for i steps

00:39:33.830 --> 00:39:35.180
for each possible i.

00:39:35.180 --> 00:39:42.990
So I'm going to run M on more
and more strings for more

00:39:42.990 --> 00:39:43.815
and more steps.

00:39:47.590 --> 00:39:49.870
And every time I notice
that M accepts something,

00:39:49.870 --> 00:39:50.680
I print it out.

00:39:57.870 --> 00:40:02.910
So I will fix this in
the version of the file

00:40:02.910 --> 00:40:06.640
that I publish on the website.

00:40:06.640 --> 00:40:11.490
So if you're still not getting
it, you can look there.

00:40:11.490 --> 00:40:12.960
But just to make
things even worse,

00:40:12.960 --> 00:40:15.900
I have a check in, which is
going to be about this one

00:40:15.900 --> 00:40:17.767
little point here.

00:40:17.767 --> 00:40:18.600
So I got a question.

00:40:18.600 --> 00:40:20.400
Where do we get the wi strings?

00:40:20.400 --> 00:40:22.560
The wi strings are
simply the list

00:40:22.560 --> 00:40:25.180
of all strings in sigma star.

00:40:25.180 --> 00:40:31.960
So under program
control, we can make M go

00:40:31.960 --> 00:40:33.280
through every possible string.

00:40:33.280 --> 00:40:34.810
Like if you had an
odometer, you're

00:40:34.810 --> 00:40:36.640
going to first get
to the empty string.

00:40:36.640 --> 00:40:39.070
Then you go to the string
0, then the string one.

00:40:39.070 --> 00:40:42.310
You can write a program
which is going to do that.

00:40:42.310 --> 00:40:43.810
And the Turing
machine can similarly

00:40:43.810 --> 00:40:48.310
write code to do that, to get
to each possible string one

00:40:48.310 --> 00:40:49.090
by one.

00:40:49.090 --> 00:40:52.240
And then that's what
the enumerator is doing.

00:40:52.240 --> 00:40:53.740
It's obtaining each
of those strings

00:40:53.740 --> 00:40:57.790
and then feeding them into
M, seeing what M does.

00:40:57.790 --> 00:40:59.590
What I'm trying
to get at here is

00:40:59.590 --> 00:41:03.250
that it's not good to
feed them in, run M

00:41:03.250 --> 00:41:06.070
to completion on each one
before going to the next one.

00:41:06.070 --> 00:41:11.050
You really kind of have
to do them all in parallel

00:41:11.050 --> 00:41:14.680
to avoid the problem of
getting stuck on one string

00:41:14.680 --> 00:41:17.380
that M is looping on.

00:41:17.380 --> 00:41:18.130
All right.

00:41:18.130 --> 00:41:22.790
So this is relevant to
your homework, in fact.

00:41:22.790 --> 00:41:27.970
If I convert em to an
enumerator in this way,

00:41:27.970 --> 00:41:30.430
does that enumerator always
print the strings out

00:41:30.430 --> 00:41:32.240
in string order.

00:41:32.240 --> 00:41:33.725
String order is this order here.

00:41:36.950 --> 00:41:39.140
Having the shorter
strings coming up

00:41:39.140 --> 00:41:41.390
before the longer strings
and within strings

00:41:41.390 --> 00:41:44.060
of a certain length, just doing
them in lexicographical order.

00:41:48.000 --> 00:41:50.510
So hopefully you follow that.

00:41:50.510 --> 00:41:56.600
But since these are not correct,
this doesn't matter for us.

00:41:56.600 --> 00:41:57.680
Let me launch that poll.

00:41:57.680 --> 00:42:00.830
I'll see how random
the answer is here.

00:42:05.980 --> 00:42:07.620
So a fair amount of confusion.

00:42:07.620 --> 00:42:11.760
If you're confused, obviously
you're in good company there.

00:42:11.760 --> 00:42:13.980
About to shut this down.

00:42:13.980 --> 00:42:16.960
Five seconds to go.

00:42:16.960 --> 00:42:18.280
OK, ending it now.

00:42:22.920 --> 00:42:23.560
All right.

00:42:23.560 --> 00:42:26.160
So the correct answer, as
the majority of you did get,

00:42:26.160 --> 00:42:30.870
is in fact that the order is
not going to be respected here

00:42:30.870 --> 00:42:33.910
when E prints things out.

00:42:33.910 --> 00:42:36.250
It might print out some
things later in the order

00:42:36.250 --> 00:42:38.320
before earlier
things in the order.

00:42:38.320 --> 00:42:44.250
What's going to control when
E is going to print it out?

00:42:44.250 --> 00:42:50.220
If M accepts some strings
more quickly in fewer steps,

00:42:50.220 --> 00:42:54.990
then E might end up printing
out that string earlier

00:42:54.990 --> 00:42:59.310
in the list than some
other string that

00:42:59.310 --> 00:43:02.030
might be a shorter string.

00:43:02.030 --> 00:43:09.050
Because the order in which
E is going to now identify

00:43:09.050 --> 00:43:13.250
that M is accepting
those strings

00:43:13.250 --> 00:43:16.670
depends upon the speed
with which M is actually

00:43:16.670 --> 00:43:18.840
doing the accepting.

00:43:18.840 --> 00:43:22.980
So this is relevant to
one of your homeworks,

00:43:22.980 --> 00:43:27.420
because what you're
going to have to show

00:43:27.420 --> 00:43:32.160
is that if you start with a
decidable language instead

00:43:32.160 --> 00:43:36.180
of a recognizable
language, then you

00:43:36.180 --> 00:43:40.110
can make an enumerator, which
always prints out things

00:43:40.110 --> 00:43:41.970
in order, in the string order.

00:43:44.700 --> 00:43:48.630
And vice versa.

00:43:48.630 --> 00:43:51.990
And if you have an enumerator
which prints that things out

00:43:51.990 --> 00:43:57.060
in string order, then the
language is decidable.

00:43:57.060 --> 00:44:01.090
So need to think about that.

00:44:01.090 --> 00:44:04.030
One direction is a fairly
simple modification

00:44:04.030 --> 00:44:06.220
of what I just showed.

00:44:06.220 --> 00:44:09.530
The other direction is a
little bit of more work.

00:44:09.530 --> 00:44:17.660
So anyway, why don't we take
our little coffee break here?

00:44:17.660 --> 00:44:19.140
So that's an
interesting question.

00:44:19.140 --> 00:44:23.300
So one question is because
sigma has an infinite-- sigma

00:44:23.300 --> 00:44:27.440
star is infinite,
if I understand

00:44:27.440 --> 00:44:29.660
this question
correctly, which says

00:44:29.660 --> 00:44:32.330
it's an infinite
number of strings here.

00:44:32.330 --> 00:44:35.480
How does the machine
even get started

00:44:35.480 --> 00:44:37.760
because it has to go through
and enumerate all of it?

00:44:37.760 --> 00:44:43.560
No, it's not first writing
down all of those strings.

00:44:43.560 --> 00:44:45.060
Because yeah, you
can't write down--

00:44:45.060 --> 00:44:47.018
you can't do this infinite
step of writing down

00:44:47.018 --> 00:44:47.730
all the strings.

00:44:47.730 --> 00:44:49.500
What I had in mind
is you're going

00:44:49.500 --> 00:44:51.458
to take each string in turn.

00:44:51.458 --> 00:44:53.250
First you're going to
take the first string

00:44:53.250 --> 00:44:57.925
on the list of sigma star,
run M on that string,

00:44:57.925 --> 00:44:59.550
and then the next
string in sigma star,

00:44:59.550 --> 00:45:03.090
run it on that string, and
so on, string after string.

00:45:03.090 --> 00:45:05.488
And so you're never going to
have infinitely many strings

00:45:05.488 --> 00:45:06.030
to deal with.

00:45:06.030 --> 00:45:07.822
It's just going to be
more and more strings

00:45:07.822 --> 00:45:09.000
as you're going along.

00:45:09.000 --> 00:45:12.360
And the question I
was trying to get at

00:45:12.360 --> 00:45:16.990
is whether you're going to
run each one to completion

00:45:16.990 --> 00:45:19.540
before you get to the next one
or you're going to kind of try

00:45:19.540 --> 00:45:21.430
to do them all in
parallel, which is what you

00:45:21.430 --> 00:45:26.350
need to do to prove this there.

00:45:26.350 --> 00:45:28.270
Won't there be
infinitely many wi?

00:45:28.270 --> 00:45:30.070
Yes, so there are
a-- similar question.

00:45:30.070 --> 00:45:31.060
Infinitely many wi.

00:45:31.060 --> 00:45:32.770
There are infinitely many wi.

00:45:32.770 --> 00:45:35.380
But it's just an infinite
loop that we're in.

00:45:35.380 --> 00:45:40.300
One by one, you're taking
care of more and more wi

00:45:40.300 --> 00:45:40.990
as you're going.

00:45:44.590 --> 00:45:47.170
Let's see here.

00:45:47.170 --> 00:45:47.670
Yes.

00:45:47.670 --> 00:45:50.685
So another question
is are we running

00:45:50.685 --> 00:45:52.110
all the strings in parallel?

00:45:52.110 --> 00:45:55.740
Yes, we are running all of
the strings in parallel.

00:45:55.740 --> 00:46:02.175
But it's running them in
parallel, but these are--

00:46:05.430 --> 00:46:08.670
we're not defining a
parallel Turing machine.

00:46:08.670 --> 00:46:11.115
It's running them in
parallel using time sharing.

00:46:11.115 --> 00:46:13.350
It runs a little
bit in this block,

00:46:13.350 --> 00:46:16.170
runs a little bit in that
block and another block,

00:46:16.170 --> 00:46:17.940
and sort of shifts
around and sort of does

00:46:17.940 --> 00:46:18.780
a few steps of each.

00:46:18.780 --> 00:46:21.600
And that's how it's getting
the effect of the parallelism.

00:46:36.640 --> 00:46:39.370
Question is would the
enumerator essentially

00:46:39.370 --> 00:46:41.110
have a print tape
and a work tape?

00:46:41.110 --> 00:46:43.540
Yeah, you can think of it
as having a print tape.

00:46:43.540 --> 00:46:45.970
However you want
to formalize it.

00:46:45.970 --> 00:46:47.770
It doesn't matter.

00:46:47.770 --> 00:46:50.020
I mean, I'm being a little
whimsical with attaching it

00:46:50.020 --> 00:46:54.160
to a picture of a real printer.

00:46:54.160 --> 00:46:58.130
But yeah, you think conceptually
you can have a print tape.

00:46:58.130 --> 00:47:02.320
However you like to
think about it is fine.

00:47:02.320 --> 00:47:05.260
How can we directly say
that without knowing

00:47:05.260 --> 00:47:06.580
the program of the printer?

00:47:13.410 --> 00:47:16.500
We don't have to get into
the structure of the printer.

00:47:16.500 --> 00:47:20.880
The printer is just something
where you say print a string

00:47:20.880 --> 00:47:22.908
and a string comes out.

00:47:22.908 --> 00:47:24.450
That's all we know
about the printer,

00:47:24.450 --> 00:47:27.060
and that's all we need to know.

00:47:27.060 --> 00:47:29.910
So there's no program
for the printer.

00:47:29.910 --> 00:47:32.760
Sorry if I'm not
understanding your question.

00:47:32.760 --> 00:47:34.920
But the question
literally says, how can we

00:47:34.920 --> 00:47:37.200
say that without knowing
the name of the printer?

00:47:40.100 --> 00:47:42.140
So if the machine
is decidable, why

00:47:42.140 --> 00:47:44.790
does it have to print
all strings in order?

00:47:44.790 --> 00:47:46.520
For example, if one
string is shorter,

00:47:46.520 --> 00:47:48.860
can it be decided later?

00:47:48.860 --> 00:47:51.960
Well, yeah.

00:47:51.960 --> 00:47:54.570
The reason why we want--

00:47:54.570 --> 00:47:56.750
so the question is, if
the machine is decidable,

00:47:56.750 --> 00:48:01.010
why does it have to print
all strings in order?

00:48:01.010 --> 00:48:04.100
Because that's what I'm asking
you to do in the problem.

00:48:04.100 --> 00:48:08.665
If you read the problem, I think
it's number five on the P set.

00:48:08.665 --> 00:48:10.040
That's what I'm
asking you to do.

00:48:10.040 --> 00:48:11.868
That's why you have
to print it in order.

00:48:11.868 --> 00:48:14.410
Otherwise you wouldn't have to
worry about printing in order.

00:48:14.410 --> 00:48:17.120
It's just because
I'm asking you to.

00:48:17.120 --> 00:48:21.542
OK, so I think
we're out of time.

00:48:21.542 --> 00:48:25.820
Let us move back
into our material.

00:48:29.000 --> 00:48:32.660
Second half,
Church-Turing thesis.

00:48:32.660 --> 00:48:36.290
So Church, this is
going back into the bit

00:48:36.290 --> 00:48:41.200
of the history of the
subject back to the 1930s.

00:48:41.200 --> 00:48:45.820
Back then people were
interested in formulating

00:48:45.820 --> 00:48:47.890
the notion of what do
we mean by algorithm.

00:48:47.890 --> 00:48:51.370
They didn't even
call it algorithm.

00:48:51.370 --> 00:48:52.960
Some people call it procedure.

00:48:52.960 --> 00:48:56.170
Some people called it
effective procedure.

00:48:56.170 --> 00:49:01.390
Some people called it
effective calculation.

00:49:01.390 --> 00:49:04.060
But people had in their
minds-- mathematicians

00:49:04.060 --> 00:49:06.460
have been dealing for
centuries, thousands of years,

00:49:06.460 --> 00:49:08.500
with procedures
for doing things.

00:49:08.500 --> 00:49:10.240
That's a very natural thing.

00:49:10.240 --> 00:49:15.310
And mathematical logicians, in
particular Church and Turing,

00:49:15.310 --> 00:49:17.980
Turing somebody surely
obviously you've

00:49:17.980 --> 00:49:21.400
heard of, Church maybe not.

00:49:21.400 --> 00:49:24.490
Church was Turing's
thesis advisor, in fact.

00:49:24.490 --> 00:49:30.040
And they both were coming
out of the mathematical logic

00:49:30.040 --> 00:49:34.900
field of mathematics and trying
to use mathematical logic

00:49:34.900 --> 00:49:37.900
to formalize this
intuitive notion of what

00:49:37.900 --> 00:49:43.150
we have had for centuries
about what a procedure is,

00:49:43.150 --> 00:49:46.380
what is an algorithm.

00:49:46.380 --> 00:49:49.500
And back in those
days, they came up

00:49:49.500 --> 00:49:52.680
with different ways
of formalizing it.

00:49:52.680 --> 00:49:54.960
So here we had this
notion of algorithm, which

00:49:54.960 --> 00:49:57.300
is kind of intuitive concept.

00:49:57.300 --> 00:49:59.250
Turing proposed Turing
machine as a way

00:49:59.250 --> 00:50:01.080
of capturing that
in a formal way,

00:50:01.080 --> 00:50:03.480
a mathematically precise way.

00:50:03.480 --> 00:50:08.150
Other people came up with
other ways of doing it.

00:50:08.150 --> 00:50:11.150
And back then, it
wasn't obvious that all

00:50:11.150 --> 00:50:13.700
of those different
formulations would end up

00:50:13.700 --> 00:50:18.080
giving you equivalent
concepts, equivalent notions.

00:50:18.080 --> 00:50:21.950
And in fact, they proved
in fairly elaborate detail

00:50:21.950 --> 00:50:24.230
that the different methods
that people came up

00:50:24.230 --> 00:50:26.040
with, there was the
lambda calculus,

00:50:26.040 --> 00:50:29.510
there was rewriting systems,
there were several methods

00:50:29.510 --> 00:50:32.600
that were proposed for
formalizing this notion,

00:50:32.600 --> 00:50:36.350
and they all turned out to
be equivalent to one another.

00:50:36.350 --> 00:50:39.320
Today that seems
kind of obvious,

00:50:39.320 --> 00:50:40.700
even though I went
to some effort

00:50:40.700 --> 00:50:43.040
to prove that just to
give you a feeling for how

00:50:43.040 --> 00:50:46.460
those things go.

00:50:46.460 --> 00:50:51.170
If you have programs, if
you have Pascal and Java,

00:50:51.170 --> 00:50:54.290
say, and thinking about what
you can do mathematically

00:50:54.290 --> 00:50:54.902
in those--

00:50:54.902 --> 00:50:56.360
I'm not talking
about their ability

00:50:56.360 --> 00:50:59.960
to interface with Windows
and so on, but just

00:50:59.960 --> 00:51:03.290
the mathematical capabilities.

00:51:03.290 --> 00:51:06.110
The capability of doing
mathematical calculations

00:51:06.110 --> 00:51:11.625
or functions with a Pascal
program or a Java program.

00:51:11.625 --> 00:51:14.000
It would be absurd to think
there's some program that you

00:51:14.000 --> 00:51:18.620
can write in Java that you
can't write in Pascal or Python.

00:51:21.180 --> 00:51:25.260
And the reason is we know you
can compile Python into Java

00:51:25.260 --> 00:51:27.210
and you can compile
Java back into Python.

00:51:27.210 --> 00:51:30.390
That tells you that the two
systems, two programming

00:51:30.390 --> 00:51:32.580
languages are
equivalent in power.

00:51:32.580 --> 00:51:35.040
That wasn't obvious from
the get go to these folks.

00:51:35.040 --> 00:51:40.320
So they observed that all of
the different efforts that

00:51:40.320 --> 00:51:42.120
came at formalizing
algorithm, all

00:51:42.120 --> 00:51:44.180
were equivalent to one another.

00:51:44.180 --> 00:51:46.340
That was kind of a
breakthrough moment

00:51:46.340 --> 00:51:51.085
when they realized that all of
the ways that they've come up

00:51:51.085 --> 00:51:52.460
with, and once
they got the idea,

00:51:52.460 --> 00:51:54.500
they realized all
reasonable ways of doing it

00:51:54.500 --> 00:51:56.810
are always going
to be equivalent.

00:51:56.810 --> 00:52:00.980
And so that suggested
that they've really

00:52:00.980 --> 00:52:03.740
captured this
notion of algorithm

00:52:03.740 --> 00:52:06.440
by any one of those methods,
say a Turing machine.

00:52:06.440 --> 00:52:07.790
And that's what they took.

00:52:07.790 --> 00:52:10.700
You can't prove that, because
algorithms are an intuitive

00:52:10.700 --> 00:52:11.840
notion.

00:52:11.840 --> 00:52:14.845
But the fact that we're able to
capture that in a formal way,

00:52:14.845 --> 00:52:16.970
that's what we call today
the Church-Turing thesis.

00:52:25.230 --> 00:52:30.000
So any of these methods
captured the notion of algorithm

00:52:30.000 --> 00:52:32.270
as we described.

00:52:32.270 --> 00:52:34.700
And that has had a big
impact on mathematics.

00:52:38.830 --> 00:52:40.480
Just give me one second here.

00:52:42.720 --> 00:52:43.220
All right.

00:52:43.220 --> 00:52:45.260
Here's a check in on this one.

00:52:45.260 --> 00:52:46.430
So you know Alan Turing.

00:52:46.430 --> 00:52:50.060
So here are some facts
which may or may not

00:52:50.060 --> 00:52:52.850
be true about Alan Turing.

00:52:52.850 --> 00:52:56.120
So now you get to pick
all of the ones that

00:52:56.120 --> 00:52:58.010
apply based on your knowledge.

00:52:58.010 --> 00:53:06.080
Obviously this is more for
fun or historical interest.

00:53:06.080 --> 00:53:09.650
But let's launch that poll.

00:53:09.650 --> 00:53:12.620
See how much you know
about Mr. Turing.

00:53:18.230 --> 00:53:19.220
Check all that apply.

00:53:24.840 --> 00:53:26.340
OK, almost done?

00:53:26.340 --> 00:53:29.870
Please let's wrap it up.

00:53:29.870 --> 00:53:32.300
I think that's everybody.

00:53:32.300 --> 00:53:34.040
OK, two seconds.

00:53:34.040 --> 00:53:35.570
Please get credit
for doing this.

00:53:35.570 --> 00:53:36.380
End polling.

00:53:36.380 --> 00:53:38.450
In fact, it's kind
of interesting here.

00:53:46.640 --> 00:53:49.520
You all do know that
he was a code breaker.

00:53:49.520 --> 00:53:54.930
He worked, in fact,
was part of a team,

00:53:54.930 --> 00:53:58.130
I think led the team,
which broke the German code

00:53:58.130 --> 00:54:00.050
during World War II.

00:54:00.050 --> 00:54:03.170
The Turing test
is a famous thing

00:54:03.170 --> 00:54:04.910
for how do you
characterize when you

00:54:04.910 --> 00:54:06.650
have an intelligent machine.

00:54:06.650 --> 00:54:08.690
So he definitely worked in AI.

00:54:08.690 --> 00:54:10.490
He worked in biology as well.

00:54:10.490 --> 00:54:13.460
He has a paper less well
known to computer scientists.

00:54:13.460 --> 00:54:16.760
But if you look him
up on Wikipedia,

00:54:16.760 --> 00:54:21.200
where I get all my
information, he actually,

00:54:21.200 --> 00:54:23.930
and I knew this anyway, he
has a very famous paper,

00:54:23.930 --> 00:54:29.240
an influential paper, on
how, for example, spots

00:54:29.240 --> 00:54:35.870
arise on leopards and
stripes on tigers and so on.

00:54:35.870 --> 00:54:37.850
Gave a kind of
mathematical model for that

00:54:37.850 --> 00:54:38.990
which actually proves--

00:54:38.990 --> 00:54:41.420
actually is quite--
does capture things

00:54:41.420 --> 00:54:45.770
in an accurate way, as was
shown subsequent to that.

00:54:45.770 --> 00:54:47.300
Was imprisoned for being gay.

00:54:47.300 --> 00:54:49.370
In fact, as far as I
know from his history,

00:54:49.370 --> 00:54:52.220
he was not in prison
for being gay.

00:54:52.220 --> 00:54:57.290
He was convicted of being
gay and was given a choice

00:54:57.290 --> 00:54:59.990
to go to prison or
to take chemicals

00:54:59.990 --> 00:55:03.740
to cure him from being gay.

00:55:03.740 --> 00:55:07.850
And he opted not to go to
prison and take the chemicals.

00:55:07.850 --> 00:55:13.620
And sadly, he committed
suicide two years after that.

00:55:13.620 --> 00:55:21.090
So he was treated very
badly by British society

00:55:21.090 --> 00:55:24.750
and British government despite
having the great work that he

00:55:24.750 --> 00:55:26.770
had done.

00:55:26.770 --> 00:55:30.720
And you might think that he
has been honored by appearing

00:55:30.720 --> 00:55:31.830
on a British banknote.

00:55:31.830 --> 00:55:34.560
That's also not true.

00:55:34.560 --> 00:55:37.680
But the good news is
he's not currently

00:55:37.680 --> 00:55:39.240
on a British banknote,
but he's going

00:55:39.240 --> 00:55:42.270
to be on a British banknote
starting next year.

00:55:47.370 --> 00:55:52.110
So that's along with Winston
Churchill and a number

00:55:52.110 --> 00:55:54.060
of other notable Brits.

00:55:54.060 --> 00:55:58.260
He's going to be on
the 50 pound banknote.

00:55:58.260 --> 00:56:03.050
OK, so let us continue.

00:56:03.050 --> 00:56:05.610
So as I mentioned,
the Church-Turing

00:56:05.610 --> 00:56:07.850
was important for mathematics.

00:56:07.850 --> 00:56:09.775
And it has to do with
these Hilbert problems.

00:56:09.775 --> 00:56:11.900
I don't know how many of
you have encountered that.

00:56:11.900 --> 00:56:13.610
David Hilbert was
widely considered

00:56:13.610 --> 00:56:17.840
to be the perhaps the greatest
mathematician of his day.

00:56:17.840 --> 00:56:21.860
And every four
years, mathematicians

00:56:21.860 --> 00:56:23.990
get together for an
international congress,

00:56:23.990 --> 00:56:28.160
well, the International
Congress of Mathematicians.

00:56:28.160 --> 00:56:30.050
That's been going on
for over 100 years.

00:56:30.050 --> 00:56:33.470
And he was invited
to the 1900 meeting

00:56:33.470 --> 00:56:35.400
to give a talk about
anything he wanted.

00:56:35.400 --> 00:56:39.710
And what he decided to do
during that presentation

00:56:39.710 --> 00:56:44.930
is present 23
problems that would

00:56:44.930 --> 00:56:47.130
be a challenge for
mathematicians for the coming

00:56:47.130 --> 00:56:47.630
century.

00:56:51.150 --> 00:56:55.925
And we're running a
little short on time,

00:56:55.925 --> 00:56:57.300
so I'm not going
to go into them.

00:56:57.300 --> 00:56:59.410
Some of these we'll
talk about later.

00:56:59.410 --> 00:57:02.490
But the 10th problem
here is about algorithms.

00:57:02.490 --> 00:57:05.010
The 10th problem
on Hilbert's list

00:57:05.010 --> 00:57:08.790
called Hilbert's 10th problem
is a problem about algorithms.

00:57:08.790 --> 00:57:11.310
And it says give an algorithm
for solving what are

00:57:11.310 --> 00:57:15.118
called Diophantine equations.

00:57:15.118 --> 00:57:16.410
He didn't call it an algorithm.

00:57:16.410 --> 00:57:21.240
He called it some finite
procedure or something

00:57:21.240 --> 00:57:22.170
like that.

00:57:22.170 --> 00:57:25.320
But what are
Diophantine equations?

00:57:25.320 --> 00:57:28.050
I'm glad you asked.

00:57:28.050 --> 00:57:30.310
Diophantine equations.

00:57:30.310 --> 00:57:30.937
What are they?

00:57:30.937 --> 00:57:32.020
Well, they're very simple.

00:57:32.020 --> 00:57:33.750
They're just
polynomial equations,

00:57:33.750 --> 00:57:38.550
like does this polynomial equal
some constant, for example.

00:57:38.550 --> 00:57:41.610
But where you're looking
for the solutions,

00:57:41.610 --> 00:57:43.130
the polynomials are variables.

00:57:43.130 --> 00:57:44.505
You're looking
for the solutions,

00:57:44.505 --> 00:57:47.730
but you're only allowing the
solutions to be integers.

00:57:47.730 --> 00:57:50.040
So here's an example.

00:57:50.040 --> 00:57:52.550
So I give you this polynomial.

00:57:52.550 --> 00:57:54.590
Here I'm setting it equal to 7.

00:57:54.590 --> 00:57:57.390
And I want to solve
that equation.

00:57:57.390 --> 00:58:00.110
So it has these three
variables, x, y, and z.

00:58:00.110 --> 00:58:02.100
So you have to find
a solution there.

00:58:02.100 --> 00:58:05.360
But I'm only going to allow
you to have plug in integers.

00:58:05.360 --> 00:58:07.370
And in fact, there is
a solution in integers.

00:58:07.370 --> 00:58:08.810
1, 2, and minus 2.

00:58:08.810 --> 00:58:11.450
If you plug it in,
you'll see it works.

00:58:11.450 --> 00:58:12.440
All right.

00:58:12.440 --> 00:58:14.690
Now, the general problem
that Hilbert was addressing

00:58:14.690 --> 00:58:18.630
is suppose I give
you a polynomial.

00:58:18.630 --> 00:58:20.205
Let's say it's set to 0.

00:58:20.205 --> 00:58:22.080
So we're looking for
roots of the polynomial.

00:58:22.080 --> 00:58:23.370
But just some
polynomial equation.

00:58:23.370 --> 00:58:24.930
You can always put
it in this form.

00:58:24.930 --> 00:58:29.840
And I want to know does it
have a solution in integers?

00:58:29.840 --> 00:58:33.520
And what I'm looking
for is a procedure

00:58:33.520 --> 00:58:36.040
which will tell me yes or no.

00:58:36.040 --> 00:58:37.870
I want to know.

00:58:37.870 --> 00:58:40.840
Give an algorithm to answer
that question for a given

00:58:40.840 --> 00:58:41.710
polynomial.

00:58:41.710 --> 00:58:43.650
Or using the language
of this course,

00:58:43.650 --> 00:58:49.060
defining this in terms of a
language, decide this language.

00:58:49.060 --> 00:58:52.030
Give a Turing machine which will
decide yes or no for any given

00:58:52.030 --> 00:58:53.060
polynomial.

00:58:53.060 --> 00:58:54.970
Yes there is a
solution in integers.

00:58:54.970 --> 00:58:56.530
No, there is no
solution in integers.

00:59:07.970 --> 00:59:13.310
That was what Hilbert
asked in his 10th problem.

00:59:13.310 --> 00:59:14.540
Give an algorithm.

00:59:14.540 --> 00:59:18.080
Now, as we know now,
it took seven years

00:59:18.080 --> 00:59:22.880
to get the answer that
there is no such algorithm.

00:59:22.880 --> 00:59:24.525
It's an undecidable problem.

00:59:24.525 --> 00:59:26.900
And we'll talk about that a
little bit later in the term.

00:59:26.900 --> 00:59:32.960
But D is not a
decidable language.

00:59:32.960 --> 00:59:39.790
Now, there was no hope of coming
up with that answer in 1900

00:59:39.790 --> 00:59:42.610
or even in 1910,
because we didn't

00:59:42.610 --> 00:59:45.550
have a formal idea of
what an algorithm is.

00:59:45.550 --> 00:59:50.350
That had to wait until the
Church-Turing thesis told us

00:59:50.350 --> 00:59:53.080
that algorithms really
are Turing machines,

00:59:53.080 --> 00:59:57.300
that there is a formal way of
saying what an algorithm is.

00:59:57.300 --> 00:59:59.210
And once you had
that notion, then you

00:59:59.210 --> 01:00:01.850
could prove that there
is no Turing machine.

01:00:01.850 --> 01:00:04.580
But before that, you had only
this vague notion, intuitive

01:00:04.580 --> 01:00:06.140
notion of what an algorithm is.

01:00:06.140 --> 01:00:08.000
And so there was no
hope of ever answering

01:00:08.000 --> 01:00:09.830
that, because in
fact, the answer is

01:00:09.830 --> 01:00:13.350
there is no such algorithm.

01:00:13.350 --> 01:00:16.110
Now, I'll give this as a
little exercise to you.

01:00:16.110 --> 01:00:17.970
We're a little bit
running short on time.

01:00:17.970 --> 01:00:22.630
But this language D is in
fact a recognizable language.

01:00:22.630 --> 01:00:25.730
So I would suggest you
think about that offline.

01:00:25.730 --> 01:00:29.470
But basically, you can try
plugging in different values

01:00:29.470 --> 01:00:30.710
for these variables.

01:00:30.710 --> 01:00:35.710
And if you ever find
that it evaluates to 0,

01:00:35.710 --> 01:00:36.880
then you can accept.

01:00:36.880 --> 01:00:39.220
But otherwise, you just have
to keep going and looking.

01:00:39.220 --> 01:00:42.940
So showing recognizability
is very simple,

01:00:42.940 --> 01:00:47.040
but decidability is false.

01:00:47.040 --> 01:00:50.460
Now let's talk a little
bit about encodings

01:00:50.460 --> 01:00:52.330
for Turing machines.

01:00:52.330 --> 01:00:54.750
So we're going to be working--

01:00:54.750 --> 01:00:56.140
encodings and Turing machines.

01:00:56.140 --> 01:01:00.370
So we're now going to be working
with Turing machines going

01:01:00.370 --> 01:01:00.870
forward.

01:01:05.240 --> 01:01:08.300
The input to those Turing
machines might be polynomials,

01:01:08.300 --> 01:01:09.740
might be strings.

01:01:09.740 --> 01:01:11.210
They might be other things too.

01:01:11.210 --> 01:01:14.610
We might want to feed automata
into the Turing machines.

01:01:14.610 --> 01:01:17.990
So the Turing machine can answer
questions about the automata.

01:01:17.990 --> 01:01:20.300
Well, don't forget, Turing
machines take as their input

01:01:20.300 --> 01:01:21.840
just strings.

01:01:21.840 --> 01:01:23.480
So we have to think
about how we're

01:01:23.480 --> 01:01:26.450
going to represent
something more complicated

01:01:26.450 --> 01:01:28.760
like an automaton as a string.

01:01:28.760 --> 01:01:30.860
And I'm not going to get
into the details of that.

01:01:30.860 --> 01:01:33.260
You could spell
it out in detail.

01:01:33.260 --> 01:01:36.030
But I think that's not too
interesting to get into that.

01:01:36.030 --> 01:01:38.030
We're just going to
develop a notation that

01:01:38.030 --> 01:01:43.023
says if you have some object,
it could be a polynomial.

01:01:43.023 --> 01:01:44.190
There could be an automaton.

01:01:44.190 --> 01:01:45.000
It could be a graph.

01:01:45.000 --> 01:01:46.708
It could be whatever
you're working with.

01:01:46.708 --> 01:01:47.600
A table.

01:01:47.600 --> 01:01:51.170
I'm going to write that
O in these brackets

01:01:51.170 --> 01:01:54.505
to mean an encoding of
that object into a string.

01:01:54.505 --> 01:01:56.880
And then you can feed the
string into the Turing machine.

01:02:00.448 --> 01:02:02.990
So that's how we're going to be
thinking of presenting Turing

01:02:02.990 --> 01:02:07.210
machines with more complicated
objects and strings as input,

01:02:07.210 --> 01:02:08.960
because we're just
going to represent them

01:02:08.960 --> 01:02:11.900
as strings using ways in which
I'm sure you're all familiar.

01:02:11.900 --> 01:02:14.420
I mean, that's how you deal
with representing stuff when

01:02:14.420 --> 01:02:16.805
you write your programs anyway.

01:02:16.805 --> 01:02:18.680
But just to make it
formal and that's the way

01:02:18.680 --> 01:02:20.638
we're going to write it
down in these brackets.

01:02:20.638 --> 01:02:22.430
And if you have a list
of several objects

01:02:22.430 --> 01:02:25.820
that you want to present
together to a Turing machine,

01:02:25.820 --> 01:02:29.570
we'll just write them together
within brackets like this.

01:02:29.570 --> 01:02:33.810
Now, for writing Turing
machines down, going forward,

01:02:33.810 --> 01:02:37.070
we're going to be using high
level English descriptions.

01:02:37.070 --> 01:02:39.320
We're not going to be
worrying about managing--

01:02:39.320 --> 01:02:41.330
like the stuff we've been
doing up till now, I'm

01:02:41.330 --> 01:02:42.320
not going to ask you to do it.

01:02:42.320 --> 01:02:43.650
We're not going to
do that anymore,

01:02:43.650 --> 01:02:45.233
and I'm not going
to ask you to do it.

01:02:45.233 --> 01:02:47.870
Managing where stuff goes on
the tapes and all that stuff,

01:02:47.870 --> 01:02:49.610
that's too low level.

01:02:49.610 --> 01:02:52.640
Because really now that we
have the Church-Turing thesis,

01:02:52.640 --> 01:02:55.100
we're really interested in
talking about algorithms.

01:02:55.100 --> 01:02:56.960
We're not that interested in
talking about Turing machines,

01:02:56.960 --> 01:02:57.460
per se.

01:02:57.460 --> 01:02:59.510
We're interested in
algorithms and what

01:02:59.510 --> 01:03:01.460
the power of computation is.

01:03:01.460 --> 01:03:04.700
So we're going to only be
talking about Turing machines

01:03:04.700 --> 01:03:06.560
now in a higher level way.

01:03:06.560 --> 01:03:10.348
And only when we need to prove
something about capabilities,

01:03:10.348 --> 01:03:12.140
we're going to come
back to Turing machines

01:03:12.140 --> 01:03:14.840
and we're going to be proving
things about their limitations

01:03:14.840 --> 01:03:16.170
and so on.

01:03:16.170 --> 01:03:18.470
So our notation for
running Turing machines

01:03:18.470 --> 01:03:20.800
is going to be--

01:03:20.800 --> 01:03:23.010
we're basically going to
put the Turing machine

01:03:23.010 --> 01:03:25.170
inside these quotation marks.

01:03:25.170 --> 01:03:29.100
And we're going to know that
we could in principle write out

01:03:29.100 --> 01:03:31.890
the Turing machine in a
precise way in terms of states

01:03:31.890 --> 01:03:33.340
and transition
function and so on,

01:03:33.340 --> 01:03:35.160
but we'll never
actually go ahead

01:03:35.160 --> 01:03:38.610
and do that lengthy exercise.

01:03:38.610 --> 01:03:42.180
So quick check in here.

01:03:42.180 --> 01:03:45.540
So one of the features-- well,
OK, let me not give this away.

01:03:45.540 --> 01:03:49.670
So if x and y are
strings, I want

01:03:49.670 --> 01:03:53.690
to now have a way of presenting
two strings as a single string

01:03:53.690 --> 01:03:56.900
as input to my machine, because
I always think of my machine

01:03:56.900 --> 01:03:59.320
as getting a single input.

01:03:59.320 --> 01:04:04.270
So would you suggest one way of
combining two strings into one

01:04:04.270 --> 01:04:07.570
which would be a good encoding
is just to concatenate

01:04:07.570 --> 01:04:08.695
those two strings together.

01:04:13.560 --> 01:04:15.510
Would that be the
way you would do it?

01:04:15.510 --> 01:04:19.560
Is that a good way to do it or
not such a good way to do it?

01:04:19.560 --> 01:04:26.300
So let's see here.

01:04:26.300 --> 01:04:27.365
I can get to that next.

01:04:32.633 --> 01:04:34.300
And think of what you
would want to have

01:04:34.300 --> 01:04:36.190
happen in a good encoding.

01:04:41.770 --> 01:04:44.920
Ready, set, sold.

01:04:44.920 --> 01:04:46.490
Share results.

01:04:46.490 --> 01:04:46.990
Yeah.

01:04:46.990 --> 01:04:49.150
I think most of you get
the idea that this is not

01:04:49.150 --> 01:04:52.600
a good way of combining
two strings into one,

01:04:52.600 --> 01:04:58.060
because the problem is it's
kind of ambiguous in a sense.

01:04:58.060 --> 01:04:59.890
If you combine two
strings this way,

01:04:59.890 --> 01:05:03.400
what's important in an
encoding is that the machine

01:05:03.400 --> 01:05:06.160
when it gets the encoding,
it can decode them back

01:05:06.160 --> 01:05:07.472
into the original objects.

01:05:07.472 --> 01:05:09.430
And if you're just going
to be sticking the two

01:05:09.430 --> 01:05:12.850
strings together, you don't
know where one string ends

01:05:12.850 --> 01:05:14.450
and the next string begins.

01:05:14.450 --> 01:05:17.170
And so it's not going to be a
good way of combining things.

01:05:17.170 --> 01:05:19.840
You should find a little
bit more clever way

01:05:19.840 --> 01:05:22.210
of either introducing
another symbol

01:05:22.210 --> 01:05:24.590
or doing something a little
bit more sophisticated,

01:05:24.590 --> 01:05:27.010
which would allow you to
be able to do the decoding

01:05:27.010 --> 01:05:31.340
as well as the encoding
in a unique way.

01:05:31.340 --> 01:05:34.950
So getting back to that
notation for a Turing machine.

01:05:34.950 --> 01:05:36.830
So here is the
machine we've already

01:05:36.830 --> 01:05:41.540
seen once before for a to the
k, b to the k, c to the k.

01:05:41.540 --> 01:05:44.673
I would write it now more simply
than managing all of the tapes

01:05:44.673 --> 01:05:46.340
that we had the first
time around, which

01:05:46.340 --> 01:05:47.630
we did last lecture.

01:05:47.630 --> 01:05:50.570
I would just say we
give it an input w,

01:05:50.570 --> 01:05:52.850
check if w's of the right
form with the things

01:05:52.850 --> 01:05:53.870
in the right order.

01:05:53.870 --> 01:05:55.400
Reject if it's not.

01:05:55.400 --> 01:05:57.950
Count the number of
a's b's and c's in w.

01:05:57.950 --> 01:06:01.580
Accept if all the counts
are equal and reject if not.

01:06:01.580 --> 01:06:04.550
That's going to be good
enough to be writing things

01:06:04.550 --> 01:06:06.860
at that higher level when
you're going to be writing

01:06:06.860 --> 01:06:08.750
your algorithm descriptions.

01:06:08.750 --> 01:06:11.000
You just have to make sure
that whatever you're doing

01:06:11.000 --> 01:06:11.950
you can implement.

01:06:15.140 --> 01:06:18.320
You don't want to be doing
tests which are impossible

01:06:18.320 --> 01:06:22.250
or doing infinitely
much work in one stage.

01:06:22.250 --> 01:06:24.390
That's not good.

01:06:24.390 --> 01:06:26.503
But as long as it's clear
that what you're doing

01:06:26.503 --> 01:06:28.670
is doing only a finite
amount of work in every stage

01:06:28.670 --> 01:06:30.320
and it's something that
you could really implement,

01:06:30.320 --> 01:06:32.060
you can write it
in a high level.

01:06:35.590 --> 01:06:38.230
I wanted to spend a few minutes
talking about problem set two,

01:06:38.230 --> 01:06:42.100
but we're a little bit
running out of time here.

01:06:42.100 --> 01:06:44.890
Particularly there was
this problem number five

01:06:44.890 --> 01:06:48.010
where you show that a language
is Turing recognizable if

01:06:48.010 --> 01:06:52.240
and only if there's
a decidable D. Where

01:06:52.240 --> 01:06:56.960
C is Turing recognizable where
D is now a collection of pairs.

01:06:56.960 --> 01:06:59.110
We've got some questions
about the notation, which

01:06:59.110 --> 01:07:01.270
I've hopefully answered now.

01:07:01.270 --> 01:07:07.870
So C is a set of x's
such that there exists

01:07:07.870 --> 01:07:10.690
a string you can pair it with.

01:07:10.690 --> 01:07:15.322
So that the string xy is in D.

01:07:15.322 --> 01:07:17.030
Let me try to give
you a picture of that.

01:07:19.910 --> 01:07:23.720
So I want to think of D as a
collection of pairs of strings.

01:07:23.720 --> 01:07:28.530
And it might be helpful to think
of D kind of on the axes here.

01:07:28.530 --> 01:07:32.540
So if we have a pair of strings
xy, which I have not yet

01:07:32.540 --> 01:07:34.190
packaged into a
single string, I'm

01:07:34.190 --> 01:07:38.090
thinking of them as a pair of
two objects at this moment,

01:07:38.090 --> 01:07:39.620
think of D as--

01:07:39.620 --> 01:07:45.580
so just the x part is just
below here on the x-axis.

01:07:45.580 --> 01:07:48.140
D you might just
conceptually want

01:07:48.140 --> 01:07:50.510
to think of it as a
collection of pairs.

01:07:50.510 --> 01:07:53.780
So it's like a subset
of all of these pairs.

01:07:53.780 --> 01:08:03.350
And C is all of the x's that
correspond to any pair in here.

01:08:03.350 --> 01:08:05.630
Sometimes we call
that the projection,

01:08:05.630 --> 01:08:09.080
because it's all the things
that are below or the shadow.

01:08:09.080 --> 01:08:11.570
If you had a light
sitting up here,

01:08:11.570 --> 01:08:15.090
it's all the things that
are kind of underneath a D.

01:08:15.090 --> 01:08:17.090
So I've written C here
kind of a little thicker,

01:08:17.090 --> 01:08:17.970
if you can see that.

01:08:17.970 --> 01:08:19.670
So that's the C language.

01:08:19.670 --> 01:08:24.750
And there's two directions here.

01:08:24.750 --> 01:08:26.210
One is a lot easier
than the other.

01:08:26.210 --> 01:08:30.060
If I give you a
decidable D and I

01:08:30.060 --> 01:08:33.899
want to test whether something's
in C, so I'll give you an x,

01:08:33.899 --> 01:08:38.700
I want to know is x in C?

01:08:38.700 --> 01:08:42.300
Well, you now have to test is
there some y that I can pair

01:08:42.300 --> 01:08:46.819
with x where the pair is in D?

01:08:46.819 --> 01:08:48.979
So you can start
looking for that y.

01:08:48.979 --> 01:08:51.890
If you ever find
one, you know that x

01:08:51.890 --> 01:08:55.729
is in C. There are infinitely
many y's to look for.

01:08:55.729 --> 01:09:03.120
But don't forget, you're only
looking for a recognizer for C.

01:09:03.120 --> 01:09:06.479
So on the rejecting side,
you're allowed to go forever.

01:09:06.479 --> 01:09:09.180
So I'm kind of giving
you a way to think

01:09:09.180 --> 01:09:10.680
about the easy direction.

01:09:10.680 --> 01:09:16.710
The hard direction, you need
to think about how are you

01:09:16.710 --> 01:09:19.979
going to come up with that
decidable D. If I give you C,

01:09:19.979 --> 01:09:22.859
you have to find a
decidable D. And now

01:09:22.859 --> 01:09:24.720
you're bringing
something down lower.

01:09:24.720 --> 01:09:27.810
You're starting with a
recognizable language

01:09:27.810 --> 01:09:29.460
and a decidable
language, which is

01:09:29.460 --> 01:09:31.800
going to sort of be counterpart
to that and in a sense

01:09:31.800 --> 01:09:33.120
is a simpler language.

01:09:33.120 --> 01:09:34.649
And the way it
becomes simpler is

01:09:34.649 --> 01:09:41.960
that y is going to help you
determine whether x is in C.

01:09:41.960 --> 01:09:45.649
And I guess the thing that
I'll leave you with is,

01:09:45.649 --> 01:09:48.620
and maybe we can talk about this
a little bit more on Tuesday,

01:09:48.620 --> 01:09:53.520
I'll try to leave a
little more time if you

01:09:53.520 --> 01:09:57.507
want to test if something
is in C, x is in C,

01:09:57.507 --> 01:10:00.090
but I don't want to let you go
forever anymore, because I want

01:10:00.090 --> 01:10:02.450
to be a decidable language.

01:10:02.450 --> 01:10:05.040
And I'm going to
use y to help you.

01:10:05.040 --> 01:10:09.350
What information would
help you guarantee

01:10:09.350 --> 01:10:13.040
you get the right
answer for x being in C?

01:10:13.040 --> 01:10:16.070
But that you would
have to be sure

01:10:16.070 --> 01:10:17.921
you're getting the right answer.

01:10:17.921 --> 01:10:20.330
So y could just be the answer.

01:10:20.330 --> 01:10:23.120
But then you don't know
that that's-- you have to be

01:10:23.120 --> 01:10:25.670
convinced that you
have the right answer.

01:10:25.670 --> 01:10:28.250
y just saying what
it is, I mean,

01:10:28.250 --> 01:10:32.300
y could say that x is in
D even when it's not true.

01:10:32.300 --> 01:10:34.700
x is in C even when
that's not true.

01:10:34.700 --> 01:10:40.190
So what information would allow
you to check that x is in C?

01:10:40.190 --> 01:10:41.660
What would be
helpful information

01:10:41.660 --> 01:10:45.050
to check that x is in C
where you would avoid ever

01:10:45.050 --> 01:10:47.270
having to go forever?

01:10:47.270 --> 01:10:49.750
A little bit too rushed
here for that to be helpful.

01:10:49.750 --> 01:10:54.190
Anyway, let's just
conclude what we've done.

01:10:54.190 --> 01:10:56.800
Just brief summary here.

01:10:56.800 --> 01:11:03.660
And I don't want to
keep you over time.

01:11:03.660 --> 01:11:06.150
So I'll just leave
this up on the board.

01:11:06.150 --> 01:11:14.430
I will see if there's any--
so the lecture is over

01:11:14.430 --> 01:11:17.397
and you can take
off as you wish.

01:11:17.397 --> 01:11:19.230
I will stick around for
a couple of minutes.

01:11:19.230 --> 01:11:22.845
I have another meeting soon, but
I'll try to answer some chats.

01:11:28.270 --> 01:11:30.850
All right.

01:11:30.850 --> 01:11:33.700
People are commenting about
this movie about Turing,

01:11:33.700 --> 01:11:35.320
The Imitation Game.

01:11:35.320 --> 01:11:37.450
If you haven't seen
that, I recommend it.

01:11:40.760 --> 01:11:47.204
And is it a good idea to make
y to be equal to the repeated

01:11:47.204 --> 01:11:48.930
looped string?

01:11:48.930 --> 01:11:49.920
Hm.

01:11:49.920 --> 01:11:50.970
I'm not sure about that.

01:11:53.970 --> 01:11:57.105
Thank you, everybody, for
sending your kind notes.

01:12:02.410 --> 01:12:03.363
Church-Turing thesis.

01:12:03.363 --> 01:12:04.780
The question is
is it in the book?

01:12:04.780 --> 01:12:05.280
Yes.

01:12:05.280 --> 01:12:06.100
It's in the book.

01:12:06.100 --> 01:12:08.275
Kind of similar to what
I've already said, but yes.

01:12:16.630 --> 01:12:19.870
OK, this is a good
question here.

01:12:19.870 --> 01:12:21.130
The Church-Turing thesis.

01:12:21.130 --> 01:12:24.280
Somebody asked me, is
it proved in the book?

01:12:24.280 --> 01:12:26.050
There's nothing to prove.

01:12:26.050 --> 01:12:29.140
The Church-Turing
thesis is an equivalence

01:12:29.140 --> 01:12:32.290
between the intuitive
and the formal.

01:12:32.290 --> 01:12:35.230
You can't prove
something like that.

01:12:35.230 --> 01:12:36.710
You can just make--

01:12:36.710 --> 01:12:39.070
it's really in a
sense a hypothesis

01:12:39.070 --> 01:12:42.670
that the only thing you'll
ever be able to compute

01:12:42.670 --> 01:12:46.000
is something that you can
do with a Turing machine.

01:12:46.000 --> 01:12:48.460
I mean, that has something
to do with the nature

01:12:48.460 --> 01:12:49.450
of the physical world.

01:12:49.450 --> 01:12:52.480
And I don't really think
that's what people had in mind.

01:12:52.480 --> 01:12:55.480
It's that the kinds of
things that we normally

01:12:55.480 --> 01:12:59.830
think of being able
to do with a procedure

01:12:59.830 --> 01:13:01.727
mathematically is exactly
the kinds of things

01:13:01.727 --> 01:13:03.310
that you can do with
a Turing machine.

01:13:06.880 --> 01:13:10.050
So somebody's pointing out,
trying to be helpful here,

01:13:10.050 --> 01:13:12.750
maybe these folks are
asking about equivalents

01:13:12.750 --> 01:13:15.330
of various different
computation models being

01:13:15.330 --> 01:13:18.120
proved in the book, not the
Church-Turing thesis itself.

01:13:18.120 --> 01:13:22.980
Well, I mean, the things
that we proved in lecture

01:13:22.980 --> 01:13:24.480
are also proved in the book.

01:13:24.480 --> 01:13:26.850
About the equivalence
of single tape machines,

01:13:26.850 --> 01:13:30.090
multi-tape machines,
non-deterministic machines,

01:13:30.090 --> 01:13:32.400
those are all
proved in the book.

01:13:32.400 --> 01:13:34.540
I mean, there's lots
of models out there.

01:13:34.540 --> 01:13:37.398
So we could spend a lot of
time proving equivalences.

01:13:37.398 --> 01:13:39.690
And there are books that do
spend a lot of time proving

01:13:39.690 --> 01:13:40.590
equivalences.

01:13:46.040 --> 01:13:48.125
But I think what we've
given is probably enough.

01:13:53.672 --> 01:13:54.630
That's a good question.

01:13:54.630 --> 01:13:59.950
If you give an
algorithm, you don't

01:13:59.950 --> 01:14:03.790
need to give the actual machine
going forward unless you're

01:14:03.790 --> 01:14:07.270
explicitly asked to.

01:14:07.270 --> 01:14:13.360
But yes, you don't have to
give the states and transitions

01:14:13.360 --> 01:14:14.367
anymore.

01:14:18.000 --> 01:14:18.500
OK.

01:14:18.500 --> 01:14:19.667
So it's a little after 4:00.

01:14:19.667 --> 01:14:24.530
I think I'm going to move
on to my next meeting.

01:14:24.530 --> 01:14:30.610
So thank you for being here,
and I will see you on Tuesday.