WEBVTT

00:00:00.000 --> 00:00:02.445
[SQUEAKING]

00:00:02.445 --> 00:00:04.401
[RUSTLING]

00:00:04.401 --> 00:00:06.357
[CLICKING]

00:00:18.600 --> 00:00:21.660
MICHAEL SIPSER: So,
welcome, everybody,

00:00:21.660 --> 00:00:28.140
to the Fall 2020 online
Introduction to the Theory

00:00:28.140 --> 00:00:33.770
of Computing 18.404/6.840.

00:00:33.770 --> 00:00:36.290
My name is Mike Sipser.

00:00:36.290 --> 00:00:41.850
I'm going to be your instructor
for the semester in this class.

00:00:41.850 --> 00:00:45.020
So let me just tell you
what the course is about.

00:00:45.020 --> 00:00:47.625
Basically, it's going
to be in two halves.

00:00:47.625 --> 00:00:50.000
We're going to be talking
about what are the capabilities

00:00:50.000 --> 00:00:52.850
and limitations of computers--
of computer algorithms,

00:00:52.850 --> 00:00:55.130
really, computation.

00:00:55.130 --> 00:00:59.240
And the two parts of the
course are more or less divided

00:00:59.240 --> 00:01:01.568
in half.

00:01:01.568 --> 00:01:03.110
The first half of
the course is going

00:01:03.110 --> 00:01:06.275
to talk about a subject called
computability theory, which

00:01:06.275 --> 00:01:08.810
it really asks what
you can compute

00:01:08.810 --> 00:01:12.080
with an algorithm in principle.

00:01:12.080 --> 00:01:15.710
That's-- was an active area of
research in the earlier part

00:01:15.710 --> 00:01:17.090
of the 20th century.

00:01:17.090 --> 00:01:20.060
It's pretty much closed
off as a research subject

00:01:20.060 --> 00:01:23.330
these days, mainly
because they answered

00:01:23.330 --> 00:01:25.260
all of their big questions.

00:01:25.260 --> 00:01:28.850
And so a mathematical
field really only

00:01:28.850 --> 00:01:32.450
stays vital when it
has problems to solve,

00:01:32.450 --> 00:01:35.810
and they really solved all of
their interesting problems--

00:01:35.810 --> 00:01:37.280
for the most part, not 100%.

00:01:37.280 --> 00:01:42.383
But for the most part, it sort
of finished off in the 1950s--

00:01:42.383 --> 00:01:44.300
just to say a little bit
more about what we're

00:01:44.300 --> 00:01:45.800
going to talk about there.

00:01:45.800 --> 00:01:48.410
When you're interested to
know what kinds of problems

00:01:48.410 --> 00:01:50.540
you can solve with
an algorithm--

00:01:50.540 --> 00:01:52.280
there are problems
that you might

00:01:52.280 --> 00:01:54.350
want to solve that
you just can't solve.

00:01:54.350 --> 00:02:00.650
For example, given a
specification for a computer

00:02:00.650 --> 00:02:03.860
problem you want
to solve, whatever

00:02:03.860 --> 00:02:05.510
that specification might be--

00:02:05.510 --> 00:02:07.790
say your algorithm
actually is a sorting

00:02:07.790 --> 00:02:09.360
algorithm, for example--

00:02:09.360 --> 00:02:11.390
and you want to write
down that specification

00:02:11.390 --> 00:02:13.490
and have an automatic
verifier that's

00:02:13.490 --> 00:02:16.830
going to check whether a
program meets the specification.

00:02:16.830 --> 00:02:20.330
Well, that's just in
principle impossible.

00:02:20.330 --> 00:02:26.360
You cannot make a verifier
which is going to answer,

00:02:26.360 --> 00:02:29.360
in all cases, whether or not
a program meets a certain

00:02:29.360 --> 00:02:30.950
specification.

00:02:30.950 --> 00:02:35.030
So with things like that,
we will prove this semester.

00:02:35.030 --> 00:02:37.730
Questions about
mathematical truth--

00:02:37.730 --> 00:02:39.980
if you're given a mathematical
statement, is it true

00:02:39.980 --> 00:02:41.870
or is it false?

00:02:41.870 --> 00:02:45.027
It'd be great if you can
write a computer program that

00:02:45.027 --> 00:02:46.110
would answer that problem.

00:02:46.110 --> 00:02:47.930
Well, it would not be great
if you were a mathematician,

00:02:47.930 --> 00:02:49.847
because that would put
us all out of business.

00:02:49.847 --> 00:02:53.390
But you can imagine that
might be a nice thing to have,

00:02:53.390 --> 00:02:54.200
but you can't.

00:02:54.200 --> 00:02:56.742
I mean, there is no algorithm
which can answer that question.

00:02:59.090 --> 00:03:01.610
Well, along the way, we're
going to introduce models

00:03:01.610 --> 00:03:03.920
of computation, like finite
automata, which we'll

00:03:03.920 --> 00:03:07.160
see today, Turing machines,
and some other models

00:03:07.160 --> 00:03:08.990
that we'll see along the way.

00:03:08.990 --> 00:03:10.490
The second half of
the course, which

00:03:10.490 --> 00:03:11.960
is going to be
after the midterm,

00:03:11.960 --> 00:03:13.418
we're going to
shift gears and talk

00:03:13.418 --> 00:03:16.400
about complexity theory, which
is instead of looking at what's

00:03:16.400 --> 00:03:18.080
computable in
principle, you're going

00:03:18.080 --> 00:03:20.900
to look at what's computable
in practice, so things

00:03:20.900 --> 00:03:23.700
that you can solve in a
reasonable amount of time.

00:03:23.700 --> 00:03:27.080
And, for example,
I'm sure many of you

00:03:27.080 --> 00:03:30.260
are aware of the factoring
problem, which has connections

00:03:30.260 --> 00:03:38.720
to the RSA cryptosystem,
cryptography, and asks

00:03:38.720 --> 00:03:42.860
whether you can factor
big numbers quickly.

00:03:42.860 --> 00:03:46.470
That's a problem we
don't know the answer to.

00:03:46.470 --> 00:03:48.750
We just don't know how to
factor big numbers quickly.

00:03:48.750 --> 00:03:51.000
But it's possible that there
are algorithms out there

00:03:51.000 --> 00:03:53.220
that we haven't discovered
yet that can do so.

00:03:53.220 --> 00:03:55.290
It's connected with
this very famous problem

00:03:55.290 --> 00:03:57.780
in the intersection
of computer science

00:03:57.780 --> 00:04:00.060
and mathematics called the
P versus NP problem, which

00:04:00.060 --> 00:04:01.310
many of you may have heard of.

00:04:01.310 --> 00:04:02.400
We'll talk about that.

00:04:02.400 --> 00:04:06.300
We'll spend a lot of
time on that this term.

00:04:06.300 --> 00:04:08.580
And along the way, we'll
talk about different measures

00:04:08.580 --> 00:04:12.120
of complexity, of
computation, time and space,

00:04:12.120 --> 00:04:16.709
time and memory, theoretical
memory, electrical space.

00:04:16.709 --> 00:04:20.250
That's going to be a big part
of the course in the complexity

00:04:20.250 --> 00:04:21.120
theory part--

00:04:21.120 --> 00:04:23.070
introduce other
models of computation,

00:04:23.070 --> 00:04:27.000
such as probabilistic and
interactive computation.

00:04:27.000 --> 00:04:29.200
Talk about the
expectations of the course.

00:04:29.200 --> 00:04:31.860
First of all, prerequisites.

00:04:31.860 --> 00:04:35.770
There are a bunch of
prerequisites listed, 6.042,

00:04:35.770 --> 00:04:39.810
18.062 , or maybe some
other subject as well.

00:04:39.810 --> 00:04:43.140
The real thing is that
this is a math class.

00:04:43.140 --> 00:04:45.000
This is a class where--

00:04:45.000 --> 00:04:46.530
and it's not a
beginning math class,

00:04:46.530 --> 00:04:49.170
this is a moderate-to-advanced
math class.

00:04:49.170 --> 00:04:51.210
And I'm expecting
people to have had

00:04:51.210 --> 00:04:55.290
some prior experience,
of a substantial nature,

00:04:55.290 --> 00:05:00.090
with mathematical
theorems and proofs.

00:05:00.090 --> 00:05:02.820
We'll start off slow, but we're
going to ramp up pretty fast.

00:05:02.820 --> 00:05:06.940
So if you haven't
really got the idea

00:05:06.940 --> 00:05:09.550
or gotten comfortable with
doing proofs, coming up

00:05:09.550 --> 00:05:12.010
with proofs to
mathematical statements,

00:05:12.010 --> 00:05:14.530
that's going to be a concern.

00:05:14.530 --> 00:05:16.600
I would just be
monitoring yourself

00:05:16.600 --> 00:05:18.250
and seeing how you're doing.

00:05:18.250 --> 00:05:21.430
Because the homeworks
and the exams

00:05:21.430 --> 00:05:23.470
are going to count on
your being able to produce

00:05:23.470 --> 00:05:28.090
proofs, and so you're
going to be struggling

00:05:28.090 --> 00:05:30.010
if that's going to be a real--

00:05:30.010 --> 00:05:33.670
something that you haven't
had experience with.

00:05:33.670 --> 00:05:35.740
And let me talk a little
bit about the role

00:05:35.740 --> 00:05:39.070
of theory in computer science.

00:05:39.070 --> 00:05:43.330
This is a theory
class, as you know.

00:05:43.330 --> 00:05:47.150
So before we jump
into the material,

00:05:47.150 --> 00:05:48.970
I just thought it would
be worth it for you

00:05:48.970 --> 00:05:50.560
to give you at
least my perspective

00:05:50.560 --> 00:05:52.510
on the role of theoretical
computer science

00:05:52.510 --> 00:05:55.150
within the field.

00:05:55.150 --> 00:06:00.700
So I've been in computer
science for a long time.

00:06:00.700 --> 00:06:03.880
I go back-- I'm sure I'm
getting to be a dinosaur here--

00:06:03.880 --> 00:06:06.880
but I go back to the days
when you had punch cards.

00:06:06.880 --> 00:06:08.980
That's what we did when
I was an undergraduate.

00:06:08.980 --> 00:06:13.600
And, obviously, things
are very different now.

00:06:13.600 --> 00:06:17.560
And you can argue
that computer science

00:06:17.560 --> 00:06:21.970
as a discipline has matured,
and sort of the basic stuff

00:06:21.970 --> 00:06:23.770
has all been solved.

00:06:23.770 --> 00:06:25.870
Well, I would say there's
a certain truth to that,

00:06:25.870 --> 00:06:27.340
but there's a
certain way in which

00:06:27.340 --> 00:06:29.130
I would say that's not true.

00:06:29.130 --> 00:06:30.880
I think we're still
at the very beginning,

00:06:30.880 --> 00:06:33.790
at least in certain
respects, of computer science

00:06:33.790 --> 00:06:35.410
as a discipline.

00:06:35.410 --> 00:06:37.270
For one thing, there
are a lot of things

00:06:37.270 --> 00:06:42.490
that we do, a lot of things
relating to computation,

00:06:42.490 --> 00:06:45.160
that we just don't know
the answer to-- very

00:06:45.160 --> 00:06:46.120
fundamental things.

00:06:46.120 --> 00:06:49.840
Let's take as an example,
how does the brain work?

00:06:49.840 --> 00:06:52.180
Obviously, the brain computes
in a certain fashion.

00:06:56.190 --> 00:06:58.560
And we've made good
progress, you can argue,

00:06:58.560 --> 00:07:04.030
with machine learning and all
of those things that have very--

00:07:04.030 --> 00:07:06.090
very powerful and
doing very cool things.

00:07:06.090 --> 00:07:15.030
But I would also say that at
some deeper level, the methods

00:07:15.030 --> 00:07:23.250
that we have so far don't allow
us to understand creativity.

00:07:23.250 --> 00:07:27.360
We're not close to being able to
create a computer program that

00:07:27.360 --> 00:07:29.550
can do mathematics
or that can do

00:07:29.550 --> 00:07:31.260
many of the creative
kinds of things

00:07:31.260 --> 00:07:32.400
that human beings can do.

00:07:34.950 --> 00:07:37.170
I think machine learning,
powerful as it is,

00:07:37.170 --> 00:07:41.800
is really successful only for
a very narrow set of tasks.

00:07:41.800 --> 00:07:48.870
And so I think there's probably
something deeper and more

00:07:48.870 --> 00:07:51.060
fundamental going on
that we're missing.

00:07:51.060 --> 00:07:52.890
That would be my hunch.

00:07:52.890 --> 00:07:56.670
Now, whether something like
theoretical computer science is

00:07:56.670 --> 00:07:59.130
going to give you an answer
there-- or this kind of theory,

00:07:59.130 --> 00:08:00.810
or some kind of theory--

00:08:00.810 --> 00:08:04.500
I think some kind of theory
has at least a decent shot

00:08:04.500 --> 00:08:07.680
at playing a role in helping
us to understand computation

00:08:07.680 --> 00:08:09.240
in a deeper way.

00:08:09.240 --> 00:08:11.970
And the fact that we can't
understand something as basic

00:08:11.970 --> 00:08:16.260
as, can you factor a big
number quickly or not?

00:08:16.260 --> 00:08:18.600
You can't really say you
understand computation

00:08:18.600 --> 00:08:21.760
until you can answer
questions like that.

00:08:21.760 --> 00:08:24.210
So I would argue that
we have a really very

00:08:24.210 --> 00:08:27.090
primitive understanding of
computation at this stage

00:08:27.090 --> 00:08:32.490
and that there is a lot that
has yet to be discovered,

00:08:32.490 --> 00:08:34.169
not just on the
technological side,

00:08:34.169 --> 00:08:36.870
but just on the very fundamental
theoretical side that

00:08:36.870 --> 00:08:39.330
has a real shot at playing
a role in affecting

00:08:39.330 --> 00:08:42.600
the practice of how
we use computers.

00:08:42.600 --> 00:08:44.670
And so I think for
that reason-- again,

00:08:44.670 --> 00:08:47.340
I'm not sure what kind of theory
is going to be the most useful,

00:08:47.340 --> 00:08:49.560
but the theory we're going
to cover in this course

00:08:49.560 --> 00:08:51.270
is a particularly
elegant theory,

00:08:51.270 --> 00:08:54.240
and it has already paid
off in many applications

00:08:54.240 --> 00:08:56.860
and in terms of our
understanding of computation.

00:08:56.860 --> 00:09:00.360
And I think, at least
as a starting point,

00:09:00.360 --> 00:09:03.990
it's a good subject to learn.

00:09:03.990 --> 00:09:06.960
Certainly, I enjoy it, and
I've spent a good chunk

00:09:06.960 --> 00:09:11.140
of my career doing that.

00:09:11.140 --> 00:09:24.770
So let's move on then and begin
with the subject material.

00:09:24.770 --> 00:09:29.770
So we're going to talk
about models of computation,

00:09:29.770 --> 00:09:31.480
as I mentioned.

00:09:31.480 --> 00:09:34.310
We want to try to
understand computers,

00:09:34.310 --> 00:09:36.310
and we want to understand
what computers can do.

00:09:36.310 --> 00:09:39.160
But computers in the real world
are pretty complicated objects,

00:09:39.160 --> 00:09:41.900
and they're really not nice
to talk about mathematically.

00:09:41.900 --> 00:09:44.950
So we're going to talk about
abstract models of computers

00:09:44.950 --> 00:09:47.500
that are much simpler
but really capture--

00:09:47.500 --> 00:09:49.090
just like models in general--

00:09:49.090 --> 00:09:51.310
capture the important
aspects of the thing

00:09:51.310 --> 00:09:53.560
we're trying to understand.

00:09:53.560 --> 00:09:57.430
And so we're going to look
at several different kinds

00:09:57.430 --> 00:10:00.550
of models that vary in their
capabilities and the way

00:10:00.550 --> 00:10:03.900
they approximate
the real computers

00:10:03.900 --> 00:10:05.710
that we deal with every day.

00:10:05.710 --> 00:10:10.200
And for starters, we're going
to look at a very simple model

00:10:10.200 --> 00:10:12.000
called the finite automaton.

00:10:12.000 --> 00:10:15.210
And that's going to represent--

00:10:15.210 --> 00:10:17.370
you can think of it as
representing a computer that

00:10:17.370 --> 00:10:20.670
has a very small
amount of memory

00:10:20.670 --> 00:10:23.190
and a very limited and
small amount of memory.

00:10:23.190 --> 00:10:25.050
And we're going to look
at the capabilities

00:10:25.050 --> 00:10:26.610
of those kinds of machines.

00:10:26.610 --> 00:10:29.070
And what's nice about them is
that you can understand them

00:10:29.070 --> 00:10:30.700
very well.

00:10:30.700 --> 00:10:35.760
And so more powerful models that
we're going to look at later

00:10:35.760 --> 00:10:38.850
are going to be harder to
understand in as deep a way.

00:10:38.850 --> 00:10:46.015
But for these, we can develop
a very comprehensive theory.

00:10:46.015 --> 00:10:48.390
And so that's what we're going
to do for the next lecture

00:10:48.390 --> 00:10:50.540
and a half.

00:10:50.540 --> 00:10:53.370
So I'm starting off
with an example.

00:10:53.370 --> 00:10:58.430
I'm presenting a finite
automaton as a diagram--

00:10:58.430 --> 00:11:00.050
we call it a state diagram.

00:11:00.050 --> 00:11:07.670
It has these circles and
lines and labels on the lines

00:11:07.670 --> 00:11:09.720
and also on these circles.

00:11:09.720 --> 00:11:11.550
So what's going on here?

00:11:11.550 --> 00:11:13.220
So this is a finite automaton.

00:11:13.220 --> 00:11:14.960
I'm giving it the name M1.

00:11:14.960 --> 00:11:22.070
And it has-- these
circles are called states.

00:11:22.070 --> 00:11:25.240
So in this case, there were
three states, q1, q2, and q3.

00:11:25.240 --> 00:11:26.920
Those are the labels there.

00:11:26.920 --> 00:11:31.700
There are arrows connecting
states with each other.

00:11:31.700 --> 00:11:34.690
So these we'll call transitions.

00:11:34.690 --> 00:11:36.430
And they're going
to tell you how

00:11:36.430 --> 00:11:38.950
to compute with this device.

00:11:38.950 --> 00:11:42.250
And there's going to be a
specially-designated starting

00:11:42.250 --> 00:11:47.410
state, which has an arrow
coming in from nowhere.

00:11:47.410 --> 00:11:50.800
And there are other
specially-designated states

00:11:50.800 --> 00:11:52.390
called accepting
states, and that's

00:11:52.390 --> 00:11:54.490
going to have to do with
how the machine computes.

00:11:54.490 --> 00:11:57.700
But those are the ones that
have these double circles.

00:11:57.700 --> 00:12:00.730
And so talking about
the way it computes,

00:12:00.730 --> 00:12:02.870
the idea is pretty simple.

00:12:02.870 --> 00:12:04.990
The input is going to
be some finite string

00:12:04.990 --> 00:12:06.860
of 0's and 1's, in this case.

00:12:06.860 --> 00:12:09.610
We might have other types
of symbols that are allowed

00:12:09.610 --> 00:12:13.690
for other automata, but the
example that I have here,

00:12:13.690 --> 00:12:15.890
it's going to be 0's and 1's.

00:12:15.890 --> 00:12:17.740
And the way you
compute with the thing

00:12:17.740 --> 00:12:20.780
is you first put your finger--

00:12:20.780 --> 00:12:24.730
which I can't do on Zoom,
so I'll use the pointer--

00:12:24.730 --> 00:12:27.370
you put your pointer
on the starting state,

00:12:27.370 --> 00:12:30.430
the one that has the arrow
coming in from nowhere.

00:12:30.430 --> 00:12:33.880
First, you put
your pointer there.

00:12:33.880 --> 00:12:37.640
And then are you
start reading symbols

00:12:37.640 --> 00:12:40.170
from the input,
one after the next.

00:12:40.170 --> 00:12:44.180
So let's take an
example here, 01101.

00:12:44.180 --> 00:12:46.790
So you start reading
those symbols,

00:12:46.790 --> 00:12:48.810
and you follow
those transitions.

00:12:48.810 --> 00:12:50.900
So you go 0--

00:12:50.900 --> 00:12:52.550
and you go back
to the same state.

00:12:52.550 --> 00:12:54.890
Then you go-- the
next symbol is a 1,

00:12:54.890 --> 00:12:58.910
so you go over to this
state, from q1 to q2.

00:12:58.910 --> 00:13:01.110
Now you have another
one that comes in.

00:13:01.110 --> 00:13:03.770
So now you're starting at
q2, you have another one,

00:13:03.770 --> 00:13:06.150
so you follow its
associated transition.

00:13:06.150 --> 00:13:09.710
So if you notice,
every state has

00:13:09.710 --> 00:13:13.640
an outgoing transition for 1
and another outgoing transition

00:13:13.640 --> 00:13:14.330
for 0.

00:13:14.330 --> 00:13:17.690
So there's always somewhere to
go every time you read symbols

00:13:17.690 --> 00:13:18.660
from the input.

00:13:18.660 --> 00:13:20.270
So now you're at q2.

00:13:20.270 --> 00:13:23.420
You read that next, that
third symbol, which is a 1.

00:13:23.420 --> 00:13:25.760
That's going to
take you over to q3.

00:13:25.760 --> 00:13:28.040
And now you have a
0, which loops you

00:13:28.040 --> 00:13:32.840
back to where you were, and
another 1, which loops you

00:13:32.840 --> 00:13:34.010
back to where you were.

00:13:34.010 --> 00:13:39.920
And because you ended
up at an accept,

00:13:39.920 --> 00:13:44.180
you say we accept that string.

00:13:44.180 --> 00:13:49.100
So that's going to be the
output of this finite automaton.

00:13:49.100 --> 00:13:50.840
For each string,
it's either going

00:13:50.840 --> 00:13:52.650
to accept it or reject it.

00:13:52.650 --> 00:13:55.620
So it's just a binary decision
that is going to be made.

00:13:55.620 --> 00:13:57.410
It's sort of like
a 1 or a 0 output,

00:13:57.410 --> 00:13:59.850
but we're calling
it accept or reject.

00:13:59.850 --> 00:14:03.080
So this one here,
because it ended up

00:14:03.080 --> 00:14:05.430
at the accepting
state, is accepted.

00:14:05.430 --> 00:14:10.560
But if you look at the
second example, 00101,

00:14:10.560 --> 00:14:16.310
so you're going to
have 0, 0, 1, 0, 1.

00:14:16.310 --> 00:14:18.500
Now we ended up at q2.

00:14:18.500 --> 00:14:20.760
That's not an accepting state.

00:14:20.760 --> 00:14:25.350
So therefore, we say
we reject this input.

00:14:25.350 --> 00:14:25.850
OK?

00:14:25.850 --> 00:14:27.540
Very simple.

00:14:27.540 --> 00:14:29.390
And now, for example,
one of the questions

00:14:29.390 --> 00:14:31.432
you might want to ask,
given one of these things,

00:14:31.432 --> 00:14:34.100
is, well, which are
exactly those strings

00:14:34.100 --> 00:14:36.560
that the machine accepts?

00:14:36.560 --> 00:14:42.730
And a little bit of
thought will help

00:14:42.730 --> 00:14:46.060
you understand that
the only strings which

00:14:46.060 --> 00:14:49.000
are going to take you over
to q3 are those strings that

00:14:49.000 --> 00:14:52.510
have a 11 appearing
somewhere along the way, two

00:14:52.510 --> 00:14:55.810
consecutive 1's, and you will
end up at the accepting state.

00:14:58.820 --> 00:15:01.180
I encourage you to think
about that for a minute

00:15:01.180 --> 00:15:02.890
if not immediately obvious.

00:15:02.890 --> 00:15:05.170
But those are the
strings that are going

00:15:05.170 --> 00:15:08.470
to be accepted by this machine.

00:15:08.470 --> 00:15:11.860
And we call that
collection of strings

00:15:11.860 --> 00:15:15.680
the language of the machine.

00:15:15.680 --> 00:15:19.880
So that set A of
those strings that

00:15:19.880 --> 00:15:24.680
have a 11, for this particular
machine, is the language of M1.

00:15:24.680 --> 00:15:30.000
We also say that M1 recognizes
that language, recognizes A.

00:15:30.000 --> 00:15:34.460
And in terms of notation,
we write that A is L of M1.

00:15:34.460 --> 00:15:36.290
A is the language of M1.

00:15:36.290 --> 00:15:39.470
So the language of a machine
is exactly the set of strings

00:15:39.470 --> 00:15:42.810
that machine accepts.

00:15:42.810 --> 00:15:43.995
OK?

00:15:43.995 --> 00:15:46.620
So one of the first things we're
going to want to be able to do

00:15:46.620 --> 00:15:48.720
is take a machine
and understand what

00:15:48.720 --> 00:15:50.580
its language is, what's
the set of strings

00:15:50.580 --> 00:15:51.900
that that machine accepts.

00:15:51.900 --> 00:15:54.300
Another thing we might want
to do is, given a language,

00:15:54.300 --> 00:15:59.370
build a machine which
recognizes that language.

00:15:59.370 --> 00:16:01.980
And then understanding, what
are the class of languages?

00:16:01.980 --> 00:16:04.038
Can you get any language
from some machine,

00:16:04.038 --> 00:16:06.330
or are there going to be some
languages that you can do

00:16:06.330 --> 00:16:08.172
and other languages
that you cannot do?

00:16:08.172 --> 00:16:09.630
So those are the
kinds of questions

00:16:09.630 --> 00:16:12.540
we're going to be asking
about these finite automata.

00:16:12.540 --> 00:16:15.180
What kinds of things
can those machines do,

00:16:15.180 --> 00:16:18.240
and what can they not do?

00:16:18.240 --> 00:16:20.520
OK.

00:16:20.520 --> 00:16:23.565
Here's our next check-in.

00:16:27.300 --> 00:16:30.960
So wake up, everybody
who's not paying attention.

00:16:30.960 --> 00:16:33.180
A check-in is coming.

00:16:33.180 --> 00:16:34.950
So we have more
questions, though I

00:16:34.950 --> 00:16:39.550
can't keep-- are these
three statements equivalent?

00:16:39.550 --> 00:16:42.730
What three statements?

00:16:42.730 --> 00:16:45.580
AUDIENCE: At the
bottom of the slide.

00:16:45.580 --> 00:16:47.350
MICHAEL SIPSER: Oh,
oh, oh, oh, oh, yes.

00:16:47.350 --> 00:16:49.570
Those three are equivalent.

00:16:49.570 --> 00:16:52.010
A is the language-- yeah,
those mean the same thing.

00:16:52.010 --> 00:16:54.790
Not only are they equivalent,
but they're just different ways

00:16:54.790 --> 00:16:57.730
of saying the same thing.

00:16:57.730 --> 00:16:59.650
That M1 recognizes
the language is

00:16:59.650 --> 00:17:02.120
the same as saying that's
the language of the machine

00:17:02.120 --> 00:17:05.650
and that A equals
that L of M. That's

00:17:05.650 --> 00:17:09.310
all the same way of saying they
all-- six of one, half a dozen

00:17:09.310 --> 00:17:09.910
of the other.

00:17:09.910 --> 00:17:12.339
It's two ways of
saying the same thing.

00:17:12.339 --> 00:17:18.315
OK, so let's pop up our
poll and get that started.

00:17:18.315 --> 00:17:18.815
Whoops.

00:17:21.430 --> 00:17:23.770
Still showing the old
one-- oh, here we go.

00:17:23.770 --> 00:17:26.015
Move it to the next question.

00:17:26.015 --> 00:17:26.515
OK.

00:17:31.810 --> 00:17:37.410
OK, so you understand
the question here?

00:17:37.410 --> 00:17:40.645
Where do we end up
after we read 101?

00:17:40.645 --> 00:17:41.520
What state are we in?

00:17:46.280 --> 00:17:49.625
Do we end up in
state q1, q2, or q3?

00:17:52.300 --> 00:17:54.970
OK?

00:17:54.970 --> 00:17:57.120
Go fast.

00:17:57.120 --> 00:17:57.780
This is a--

00:18:01.520 --> 00:18:08.200
OK, so I think we got
pretty much converged here.

00:18:08.200 --> 00:18:12.280
I think almost
everybody got it right.

00:18:12.280 --> 00:18:16.480
The answer is indeed that
you ended up in state q2.

00:18:16.480 --> 00:18:19.780
Because you go 1,
0, 1, and that's

00:18:19.780 --> 00:18:21.550
where you ended up, in state q2.

00:18:21.550 --> 00:18:24.190
So is this string accepted?

00:18:24.190 --> 00:18:27.220
No, because you didn't
end up at an accept state.

00:18:27.220 --> 00:18:30.520
So this machine rejects 101.

00:18:30.520 --> 00:18:35.050
OK, let's keep going.

00:18:35.050 --> 00:18:38.610
So now-- yeah.

00:18:41.680 --> 00:18:45.100
OK, so now we gave
it this informal idea

00:18:45.100 --> 00:18:46.420
of a finite automaton.

00:18:46.420 --> 00:18:49.300
We're going to have to try to
get a formal definition now,

00:18:49.300 --> 00:18:52.570
which is going to be a more
mathematical way of saying

00:18:52.570 --> 00:18:56.250
the same thing that I just said.

00:18:56.250 --> 00:18:59.130
And the reason for having
a formal definition

00:18:59.130 --> 00:19:02.370
is, for one thing, it allows
us to be very precise.

00:19:02.370 --> 00:19:05.280
Then we'll know exactly what
we mean by a finite automaton,

00:19:05.280 --> 00:19:07.470
and it should answer any
questions about what counts

00:19:07.470 --> 00:19:08.790
and what doesn't count.

00:19:08.790 --> 00:19:12.970
It also is a way of
providing notation.

00:19:12.970 --> 00:19:15.540
So it'll help us
describe finite automata.

00:19:15.540 --> 00:19:19.860
And sometimes there might be an
automaton where the picture is

00:19:19.860 --> 00:19:22.530
just too big, so you might
want to be able to describe it

00:19:22.530 --> 00:19:25.530
in some mathematical
terminology rather

00:19:25.530 --> 00:19:26.670
than by giving a picture.

00:19:26.670 --> 00:19:28.045
Or maybe you're
going to be asked

00:19:28.045 --> 00:19:30.960
to give a family
of automata, where

00:19:30.960 --> 00:19:35.400
there is going to be a
parameter, N, associated

00:19:35.400 --> 00:19:38.190
with the class of
languages you're trying

00:19:38.190 --> 00:19:39.840
to describe with the automaton.

00:19:39.840 --> 00:19:42.870
And then it'll be more
helpful to describe it

00:19:42.870 --> 00:19:46.920
in this formal notation rather
than as a kind of a picture,

00:19:46.920 --> 00:19:49.980
because it might be
infinitely many pictures that

00:19:49.980 --> 00:19:52.000
are being needed.

00:19:52.000 --> 00:19:55.420
So maybe examples of
that will come up now.

00:19:55.420 --> 00:19:58.530
So a finite automaton,
we call it a 5-tuple.

00:19:58.530 --> 00:20:00.030
Don't be put off by that.

00:20:00.030 --> 00:20:02.490
A 5-tuple is just a
list of five things.

00:20:02.490 --> 00:20:06.480
So a finite automaton,
in our definition,

00:20:06.480 --> 00:20:09.090
is going to have
five components.

00:20:09.090 --> 00:20:11.970
It's going to have
Q, which is going

00:20:11.970 --> 00:20:13.650
to be a finite set
of states, so it's

00:20:13.650 --> 00:20:17.400
going to be a finite set,
which we'll designate

00:20:17.400 --> 00:20:19.890
as the states of the automaton.

00:20:19.890 --> 00:20:23.040
Sigma is the alphabet
symbols of the automaton,

00:20:23.040 --> 00:20:24.240
another finite set.

00:20:26.790 --> 00:20:29.460
Delta is the
transition function.

00:20:29.460 --> 00:20:33.300
That tells us how the automaton
moves from state to state.

00:20:33.300 --> 00:20:37.650
Those describes how
those transition arrows--

00:20:37.650 --> 00:20:41.410
those arrows which connected
the states with each other--

00:20:41.410 --> 00:20:43.290
it describes them in
a mathematical way

00:20:43.290 --> 00:20:45.510
instead in terms of a picture.

00:20:45.510 --> 00:20:48.250
And the way I'm doing
that is with a function.

00:20:48.250 --> 00:20:51.430
So delta is a function
which takes two things.

00:20:51.430 --> 00:20:53.790
So I'm hoping you've seen
this notation before.

00:20:53.790 --> 00:20:56.502
I'll help you through
it once, but this

00:20:56.502 --> 00:20:57.960
is the kind of
thing I would expect

00:20:57.960 --> 00:20:59.290
you to have seen already.

00:20:59.290 --> 00:21:01.920
So we have Q cross sigma.

00:21:01.920 --> 00:21:09.150
So I'm going to give delta a
state and an alphabet symbol.

00:21:09.150 --> 00:21:11.880
So Q is states, sigma
is alphabet symbols.

00:21:11.880 --> 00:21:15.510
So you're going to get a
state and an alphabet symbol,

00:21:15.510 --> 00:21:18.040
and it's going to
give you back a state.

00:21:18.040 --> 00:21:26.980
So describing it kind of
a little bit more detail,

00:21:26.980 --> 00:21:33.400
delta, if you give it state
q and symbol a equals r,

00:21:33.400 --> 00:21:38.010
that means q, when you
read an a, you go to r.

00:21:38.010 --> 00:21:40.950
So that's the way this
picture gets translated

00:21:40.950 --> 00:21:44.490
into a mathematical
function, which

00:21:44.490 --> 00:21:47.420
describes those transitions.

00:21:47.420 --> 00:21:50.600
And then now q0 is going
to be the starting state.

00:21:50.600 --> 00:21:53.060
That's the one with the
arrow coming in from nowhere.

00:21:53.060 --> 00:21:56.510
And F is the set of
accepting states.

00:21:56.510 --> 00:21:59.360
So there's only going to
be one starting state,

00:21:59.360 --> 00:22:00.980
but there might be
several different--

00:22:00.980 --> 00:22:02.450
or possibly even 0--

00:22:02.450 --> 00:22:03.500
accepting states.

00:22:03.500 --> 00:22:07.550
That's all legal when we
have a finite automaton.

00:22:07.550 --> 00:22:09.520
And so in terms of
using the notation--

00:22:09.520 --> 00:22:12.020
going back to the machine that
we just had from the previous

00:22:12.020 --> 00:22:14.240
slide, which I've
given you here again--

00:22:14.240 --> 00:22:15.740
let me show you how
I would describe

00:22:15.740 --> 00:22:18.960
this using this notation that
comes out of the definition.

00:22:18.960 --> 00:22:21.050
So here is M1 again.

00:22:21.050 --> 00:22:26.330
It's this 5-tuple where Q
now is the set-- q1, q2, q3--

00:22:26.330 --> 00:22:29.480
that's the set of states.

00:22:29.480 --> 00:22:32.210
The input alphabet is 0, 1.

00:22:32.210 --> 00:22:34.730
It might vary in other automata.

00:22:34.730 --> 00:22:38.180
And f is the set q3,
which has only the element

00:22:38.180 --> 00:22:43.040
q3, because this has just
one accept state, q3.

00:22:43.040 --> 00:22:46.080
So I hope that's helpful.

00:22:46.080 --> 00:22:49.430
Oh, of course, I forgot the
transition function, which

00:22:49.430 --> 00:22:51.720
here I'm describing as a table.

00:22:51.720 --> 00:22:58.430
So the transition
function says if you

00:22:58.430 --> 00:23:01.580
have a state and
an input alphabet,

00:23:01.580 --> 00:23:04.070
you can look up in
the table where you're

00:23:04.070 --> 00:23:06.740
supposed to go under
the transition function

00:23:06.740 --> 00:23:12.440
according to the state
and the alphabet symbol

00:23:12.440 --> 00:23:13.830
that you're given.

00:23:13.830 --> 00:23:22.730
So, for example, if we were
in state q2 here getting a 0,

00:23:22.730 --> 00:23:27.590
then q2 goes back to q1
so that q2 on 0 is q1.

00:23:27.590 --> 00:23:32.080
But q2 on 1 here is q3.

00:23:32.080 --> 00:23:32.580
OK?

00:23:32.580 --> 00:23:36.990
So that's how that table
captures this picture.

00:23:36.990 --> 00:23:37.538
OK?

00:23:37.538 --> 00:23:38.580
And it's just a function.

00:23:38.580 --> 00:23:45.360
It's a way of representing a
function, a finite function,

00:23:45.360 --> 00:23:48.430
in terms of this table here.

00:23:48.430 --> 00:23:53.920
So I realize, for some
of you, this may be slow.

00:23:53.920 --> 00:23:55.410
We will ramp up
in speed, but I'm

00:23:55.410 --> 00:23:57.780
trying to get us all
together in terms

00:23:57.780 --> 00:24:01.620
of the language of the
course here at the beginning.

00:24:01.620 --> 00:24:07.800
OK, so now let's
talk about some more

00:24:07.800 --> 00:24:15.130
the computation, so
strings and languages.

00:24:15.130 --> 00:24:16.660
A string is just
a finite sequence

00:24:16.660 --> 00:24:18.490
of symbols from the alphabet.

00:24:21.730 --> 00:24:25.000
This class is not going to
talk about infinite strings.

00:24:25.000 --> 00:24:28.490
All of our strings are
going to be finite.

00:24:28.490 --> 00:24:31.330
There's other mathematical
theories of automata

00:24:31.330 --> 00:24:33.280
and so on that talk
about infinite inputs

00:24:33.280 --> 00:24:34.210
and infinite strings.

00:24:34.210 --> 00:24:35.800
We're not going to
talk about that.

00:24:39.120 --> 00:24:41.760
Maybe rarely, we'll
make it very clear,

00:24:41.760 --> 00:24:43.260
we'll talk about
an infinite string,

00:24:43.260 --> 00:24:46.140
but that's going
to be an exception.

00:24:46.140 --> 00:24:48.730
And a language is
a set of strings.

00:24:48.730 --> 00:24:56.190
That's the traditional way
that people in this subject

00:24:56.190 --> 00:24:57.510
refer to a set of strings.

00:24:57.510 --> 00:25:00.270
They call it a language--
really because the subject

00:25:00.270 --> 00:25:02.958
had its roots in
linguistics, actually.

00:25:02.958 --> 00:25:04.500
And they were talking
about-- they're

00:25:04.500 --> 00:25:08.620
trying to understand
languages, human languages.

00:25:08.620 --> 00:25:10.500
So this is just a
historical fact,

00:25:10.500 --> 00:25:13.230
and that's the
terminology that's stuck.

00:25:13.230 --> 00:25:15.540
OK, so two special string--

00:25:15.540 --> 00:25:17.850
a special string and
a special language.

00:25:17.850 --> 00:25:20.400
The empty string is
the string of length 0.

00:25:20.400 --> 00:25:23.040
This is a totally
legitimate string

00:25:23.040 --> 00:25:25.350
that you are going to
run into now and then.

00:25:25.350 --> 00:25:27.210
And there's the
empty language, which

00:25:27.210 --> 00:25:29.740
is the set with no strings.

00:25:29.740 --> 00:25:31.310
These are not the same.

00:25:31.310 --> 00:25:34.040
They're not even of the
same type of object.

00:25:34.040 --> 00:25:37.220
So don't confuse them
with one another.

00:25:37.220 --> 00:25:40.000
I mean, you can have
a set, a language,

00:25:40.000 --> 00:25:43.030
which has just one element,
which is the empty string.

00:25:43.030 --> 00:25:44.680
That is not the empty set.

00:25:44.680 --> 00:25:46.870
That is a set-- that is
not the empty language.

00:25:46.870 --> 00:25:49.400
That is a language that
has one element in it,

00:25:49.400 --> 00:25:51.010
namely, the empty string.

00:25:51.010 --> 00:25:54.020
So those are separate things.

00:25:54.020 --> 00:25:58.430
OK, so here's a little bit of
a mouthful here on the slide,

00:25:58.430 --> 00:26:03.590
defining what it means for an
automaton to accept its input--

00:26:03.590 --> 00:26:06.940
accepts its input string w.

00:26:06.940 --> 00:26:08.620
And we can define that formally.

00:26:08.620 --> 00:26:11.260
And it's a little
technical looking,

00:26:11.260 --> 00:26:14.150
it's really not that bad.

00:26:14.150 --> 00:26:17.740
So if you have your
input string w,

00:26:17.740 --> 00:26:19.870
which you can write as
a sequence of symbols

00:26:19.870 --> 00:26:26.740
in the alphabet-- w1, w2, dot
dot dot, wn, so like 01001.

00:26:26.740 --> 00:26:30.880
I'm just writing it out
symbol by symbol here.

00:26:30.880 --> 00:26:35.080
So what does it mean for the
machine to accept that input?

00:26:35.080 --> 00:26:38.130
So that means that there's
a sequence of states

00:26:38.130 --> 00:26:44.025
in the machine, sequence of
states of members of Q. So

00:26:44.025 --> 00:26:45.650
a sequence from Q,
these are the states

00:26:45.650 --> 00:26:50.450
of the machine that satisfy
these three properties down

00:26:50.450 --> 00:26:51.230
here.

00:26:51.230 --> 00:26:55.220
First of all-- and I'm
thinking about the sequence

00:26:55.220 --> 00:27:01.980
that the machine goes through
as it's processing the input w.

00:27:01.980 --> 00:27:04.770
So when does it accept w?

00:27:04.770 --> 00:27:08.220
If that sequence has the feature
that it starts at the start

00:27:08.220 --> 00:27:13.730
state, each state legally
follows the previous state

00:27:13.730 --> 00:27:17.420
according to the
transition function.

00:27:17.420 --> 00:27:22.570
So that says the i-th
member of the sequence

00:27:22.570 --> 00:27:25.300
is obtained by looking
at the previous one--

00:27:25.300 --> 00:27:29.320
the i minus first member of
that sequence, the i minus

00:27:29.320 --> 00:27:31.690
first state in that
sequence-- and then

00:27:31.690 --> 00:27:36.270
looking at what happens when
you take the i-th input symbol.

00:27:36.270 --> 00:27:39.330
So as you look at the previous
state and the next input

00:27:39.330 --> 00:27:41.158
symbol, you should
get the next state.

00:27:41.158 --> 00:27:42.450
That's all that this is saying.

00:27:42.450 --> 00:27:45.630
And this should happen for
each one of these guys.

00:27:45.630 --> 00:27:48.570
And lastly, for
this to be accepted,

00:27:48.570 --> 00:27:50.970
the very last member
here, where we ended up

00:27:50.970 --> 00:27:52.870
at the end of the input--

00:27:52.870 --> 00:27:55.170
so you only care about this
at the end of the input--

00:27:55.170 --> 00:27:58.780
you have to be in
an accepting state.

00:27:58.780 --> 00:28:01.290
So you can mathematically
capture this notion

00:28:01.290 --> 00:28:02.715
of going along this path.

00:28:05.600 --> 00:28:07.300
And that's what--

00:28:07.300 --> 00:28:09.990
I'm just trying to illustrate
that we could describe

00:28:09.990 --> 00:28:10.990
all this very formally--

00:28:10.990 --> 00:28:12.760
I'm not saying that's the
best way to think about it all

00:28:12.760 --> 00:28:13.360
the time--

00:28:13.360 --> 00:28:15.350
but that it can be done.

00:28:15.350 --> 00:28:19.240
And I think that's something
worth appreciating.

00:28:19.240 --> 00:28:20.860
OK.

00:28:20.860 --> 00:28:23.110
So now in terms of, again,
getting back-- we've

00:28:23.110 --> 00:28:24.610
said this once
already, but in terms

00:28:24.610 --> 00:28:27.010
of the languages that
the machine recognizes,

00:28:27.010 --> 00:28:30.710
it's the collection of strings
that the machine accepts.

00:28:30.710 --> 00:28:35.240
Every machine accepts-- it
might accept many strings,

00:28:35.240 --> 00:28:39.890
but it always recognizes
one particular language,

00:28:39.890 --> 00:28:41.740
even if the machine
accepts no strings--

00:28:41.740 --> 00:28:44.330
then it recognizes
the empty language.

00:28:44.330 --> 00:28:48.430
So a machine always
recognizes one language,

00:28:48.430 --> 00:28:51.970
but it may have many, many
strings that it's accepting.

00:28:51.970 --> 00:28:54.760
And we call that language
the language of the machine.

00:28:54.760 --> 00:28:57.820
And we say that M
recognizes that language.

00:28:57.820 --> 00:28:59.650
These three things
mean the same thing.

00:29:02.280 --> 00:29:02.880
OK?

00:29:02.880 --> 00:29:04.170
And now important definition--

00:29:04.170 --> 00:29:06.330
I try to reserve the
most important things

00:29:06.330 --> 00:29:09.180
or the highlighted things to
be in this light blue color,

00:29:09.180 --> 00:29:10.530
if you can see that.

00:29:10.530 --> 00:29:14.310
We say a language is
a regular language

00:29:14.310 --> 00:29:19.250
if there's some finite
automaton that recognizes it.

00:29:19.250 --> 00:29:20.090
OK?

00:29:20.090 --> 00:29:23.030
So there are going to be some
languages that have associated

00:29:23.030 --> 00:29:26.120
to them finite automata that
actually solve those languages,

00:29:26.120 --> 00:29:27.590
that recognize those languages.

00:29:27.590 --> 00:29:29.090
But there might be
other languages--

00:29:29.090 --> 00:29:31.520
and we'll see examples-- where
you just can't solve them.

00:29:31.520 --> 00:29:33.980
You can't recognize them
with a finite automaton.

00:29:33.980 --> 00:29:36.440
Those languages will not
be regular languages.

00:29:36.440 --> 00:29:38.270
The regular ones are
the ones that you

00:29:38.270 --> 00:29:40.100
can do with a finite automaton.

00:29:40.100 --> 00:29:43.770
That's the traditional
terminology.

00:29:43.770 --> 00:29:45.390
OK, so let's continue.

00:29:45.390 --> 00:29:46.450
Let's go on from there.

00:29:46.450 --> 00:29:48.450
So let's do a
couple of examples.

00:29:48.450 --> 00:29:50.010
Here, again, is that same--

00:29:50.010 --> 00:29:53.730
getting to be an old
friend, that automaton M1.

00:29:56.280 --> 00:29:58.770
Remember, its language
here is the set

00:29:58.770 --> 00:30:02.520
of strings that have
the substring 11.

00:30:02.520 --> 00:30:08.050
That is that
language A. Now, what

00:30:08.050 --> 00:30:12.570
do we know about A from
the previous slide?

00:30:12.570 --> 00:30:13.690
Think with me.

00:30:13.690 --> 00:30:14.820
Don't just listen.

00:30:14.820 --> 00:30:18.900
A is a regular language
now, because it's

00:30:18.900 --> 00:30:22.660
recognized by some automaton.

00:30:22.660 --> 00:30:27.910
So whenever you
find an automaton

00:30:27.910 --> 00:30:30.130
for a language, a finite
automaton for language,

00:30:30.130 --> 00:30:34.568
we know that that language
is a regular language.

00:30:34.568 --> 00:30:36.360
So let's look at a
couple of more examples.

00:30:36.360 --> 00:30:38.090
So if you take the language--

00:30:38.090 --> 00:30:42.350
let's call this one B, which
is the strings that have

00:30:42.350 --> 00:30:45.060
an even number of 1's in them.

00:30:45.060 --> 00:30:51.370
So like the string 1101,
would that be in B?

00:30:51.370 --> 00:30:54.070
No, because it has
an odd number of 1's.

00:30:54.070 --> 00:30:57.860
So the string 1111
has four 1's in it.

00:30:57.860 --> 00:31:00.730
That's an even number, so
that string would be in B.

00:31:00.730 --> 00:31:04.000
The 0's don't matter
for this language.

00:31:04.000 --> 00:31:13.760
So strings that have
an even number of 1's,

00:31:13.760 --> 00:31:16.520
that's a regular language.

00:31:16.520 --> 00:31:18.200
And the way you would
know that is you

00:31:18.200 --> 00:31:20.390
would have to make a
finite automaton that

00:31:20.390 --> 00:31:21.750
recognizes that language.

00:31:21.750 --> 00:31:25.430
And I would encourage you to
go and make that automaton.

00:31:25.430 --> 00:31:26.690
You can do it with two states.

00:31:26.690 --> 00:31:28.280
It's a very simple automaton.

00:31:28.280 --> 00:31:30.560
But if you haven't had
practice with these,

00:31:30.560 --> 00:31:32.070
I encourage you to do that.

00:31:32.070 --> 00:31:34.220
And actually, there
are lots of examples

00:31:34.220 --> 00:31:38.930
that I ask you to solve at the
end of chapter 1 in the book,

00:31:38.930 --> 00:31:42.320
and you definitely should
spend some time playing with it

00:31:42.320 --> 00:31:47.450
if you have not yet seen
finite automata before.

00:31:47.450 --> 00:31:50.790
You need to get comfortable with
these and be able to make them.

00:31:50.790 --> 00:31:53.157
So we're going to start
making some of them,

00:31:53.157 --> 00:31:54.740
but we're going to
be talking about it

00:31:54.740 --> 00:31:56.750
at a sort of a more
abstract level in a minute.

00:31:59.710 --> 00:32:03.220
Basically, the reason why
you can solve this problem,

00:32:03.220 --> 00:32:07.540
you can make a finite automaton
which recognizes the language

00:32:07.540 --> 00:32:09.850
B, is because that
finite automaton

00:32:09.850 --> 00:32:14.590
is going to keep track of the
parity of the number of 1's

00:32:14.590 --> 00:32:16.120
it's seen before.

00:32:16.120 --> 00:32:18.408
This has two states,
one of them remembering

00:32:18.408 --> 00:32:20.200
that it's seen an odd
number of 1's so far,

00:32:20.200 --> 00:32:21.658
the other one
remembering it's seen

00:32:21.658 --> 00:32:24.080
an even number of 1's before.

00:32:24.080 --> 00:32:26.380
And that's going to be
typical for these automata,

00:32:26.380 --> 00:32:27.490
finite automata.

00:32:27.490 --> 00:32:30.130
There's going to be several
different possibilities

00:32:30.130 --> 00:32:34.060
that you may have to keep track
of as you're reading the input,

00:32:34.060 --> 00:32:36.340
and there's going to
be a state associated

00:32:36.340 --> 00:32:38.790
with each one of
those possibilities.

00:32:38.790 --> 00:32:40.730
So if you're designing
an automaton,

00:32:40.730 --> 00:32:42.200
you have to think about--

00:32:42.200 --> 00:32:44.030
as you're processing the input--

00:32:44.030 --> 00:32:45.650
what things you have
to keep track of.

00:32:45.650 --> 00:32:47.525
And you're going to make
a state for each one

00:32:47.525 --> 00:32:49.470
of those possibilities.

00:32:49.470 --> 00:32:49.970
OK?

00:32:49.970 --> 00:32:54.230
So you need to get
comfortable with that.

00:32:54.230 --> 00:32:58.940
Let's look at another example,
the language C where the inputs

00:32:58.940 --> 00:33:02.640
have an equal number
of 0's and 1's.

00:33:02.640 --> 00:33:06.760
That turns out to be
not a regular language.

00:33:06.760 --> 00:33:09.210
So, in other words,
what that means

00:33:09.210 --> 00:33:12.420
is there's no way to
recognize that language

00:33:12.420 --> 00:33:13.590
with a finite automaton.

00:33:13.590 --> 00:33:15.070
You just can't do it.

00:33:15.070 --> 00:33:17.820
That's beyond the capabilities
of finite automata.

00:33:17.820 --> 00:33:23.460
And that's a statement
we will prove later.

00:33:23.460 --> 00:33:25.050
OK.

00:33:25.050 --> 00:33:29.160
And our goal over the
next lecture or so

00:33:29.160 --> 00:33:31.950
is to understand the regular
languages, which you can

00:33:31.950 --> 00:33:34.750
do in a very comprehensive way.

00:33:34.750 --> 00:33:38.030
So we're going to
start to do that now.

00:33:38.030 --> 00:33:40.300
So first, we're going to
introduce this concept

00:33:40.300 --> 00:33:42.663
of regular expressions--

00:33:42.663 --> 00:33:44.080
which, again, these
are things you

00:33:44.080 --> 00:33:47.210
may have run into in one
way or another before.

00:33:47.210 --> 00:33:52.700
So we're going to
introduce something

00:33:52.700 --> 00:33:54.650
called the regular operations.

00:33:54.650 --> 00:33:59.210
Now, I'm sure
you're familiar with

00:33:59.210 --> 00:34:04.490
the arithmetical operations,
like plus and times.

00:34:04.490 --> 00:34:08.110
Those apply to numbers.

00:34:08.110 --> 00:34:09.880
The operations we're
going to talk about

00:34:09.880 --> 00:34:12.639
are operations that
apply to languages.

00:34:12.639 --> 00:34:16.000
So they're going to take,
let's say, two languages,

00:34:16.000 --> 00:34:17.500
you apply an
operation, you're going

00:34:17.500 --> 00:34:19.000
to get back another language.

00:34:19.000 --> 00:34:21.730
Like the union
operation, for example,

00:34:21.730 --> 00:34:25.179
that's one you probably
have seen before.

00:34:25.179 --> 00:34:27.130
The union of two
languages here is

00:34:27.130 --> 00:34:29.949
a collection of strings that
are in either one or the other.

00:34:33.078 --> 00:34:34.620
But there are other
operations, which

00:34:34.620 --> 00:34:37.469
you may not have seen before,
that we're going to look at--

00:34:37.469 --> 00:34:40.090
the concatenation
operation, for example.

00:34:40.090 --> 00:34:41.670
So that says you're
going to take

00:34:41.670 --> 00:34:45.090
a string from the first
language and another string

00:34:45.090 --> 00:34:49.370
from the second language
and stick them together.

00:34:49.370 --> 00:34:52.409
And it's called
concatenating them.

00:34:52.409 --> 00:34:54.679
And you do that in
all possible ways,

00:34:54.679 --> 00:34:56.900
and you're going to get
the concatenation language

00:34:56.900 --> 00:34:59.090
from these two languages
that you're starting with,

00:34:59.090 --> 00:35:02.930
A and B. The symbol we
use for concatenation

00:35:02.930 --> 00:35:04.070
is this little circle.

00:35:04.070 --> 00:35:06.410
But often, we don't.

00:35:06.410 --> 00:35:09.470
We just suppress that and
we write the two languages

00:35:09.470 --> 00:35:12.580
next to one another with
the little circle implied.

00:35:12.580 --> 00:35:17.510
So this also means concatenation
over here, just like this does.

00:35:17.510 --> 00:35:20.750
And the last of the
regular operations

00:35:20.750 --> 00:35:24.680
is the so-called star operation,
which is a unary operation.

00:35:24.680 --> 00:35:27.180
It applies to just
a single language.

00:35:27.180 --> 00:35:31.460
And so what you do is now
you're going to take--

00:35:31.460 --> 00:35:34.610
to get a member of
the star language,

00:35:34.610 --> 00:35:36.380
you're going to take
a bunch of strings

00:35:36.380 --> 00:35:39.980
in the original language,
A, you stick them together.

00:35:39.980 --> 00:35:43.500
Any number of members of
A, you stick them together,

00:35:43.500 --> 00:35:46.550
and that becomes an element
of the star language.

00:35:46.550 --> 00:35:49.430
And we'll do an example in a
second if you didn't get that.

00:35:49.430 --> 00:35:52.250
But one important element is
that when you have the star

00:35:52.250 --> 00:35:54.530
language, you can
also allow it to stick

00:35:54.530 --> 00:36:00.090
zero elements together, and
then you get the empty string.

00:36:00.090 --> 00:36:02.780
So that's always a
member of the star

00:36:02.780 --> 00:36:05.730
language, the empty string.

00:36:05.730 --> 00:36:08.160
OK, so let's look
at some examples.

00:36:08.160 --> 00:36:10.620
Let's say A is the
language-- these are

00:36:10.620 --> 00:36:12.510
two strings here-- good, bad.

00:36:12.510 --> 00:36:14.280
And B is the language boy, girl.

00:36:17.800 --> 00:36:21.380
Now, if we take the
union of those two,

00:36:21.380 --> 00:36:25.740
we get good, bad, boy, girl.

00:36:25.740 --> 00:36:29.380
That's kind of
what you'd expect.

00:36:29.380 --> 00:36:38.170
And now let's take a look
at the concatenation.

00:36:38.170 --> 00:36:41.260
Now, if you concatenate
the A and the B language,

00:36:41.260 --> 00:36:44.200
you're going to get all
possible ways of having an A

00:36:44.200 --> 00:36:46.850
string followed by all possible
ways of having a B string.

00:36:46.850 --> 00:36:49.960
So you can get goodboy,
goodgirl, badboy, badgirl.

00:36:53.990 --> 00:37:01.240
Now, looking at the
star, well, that

00:37:01.240 --> 00:37:02.900
applies to just one language.

00:37:02.900 --> 00:37:07.600
So let's say it's the
good, bad language from A.

00:37:07.600 --> 00:37:10.270
And so the A star
that you get from that

00:37:10.270 --> 00:37:14.710
is all possible ways of sticking
together the strings from A.

00:37:14.710 --> 00:37:18.260
So using no strings, you
always get the empty string.

00:37:18.260 --> 00:37:20.380
That's always guaranteed
to be a member of A.

00:37:20.380 --> 00:37:22.530
And then just taking
one element of A,

00:37:22.530 --> 00:37:24.790
you get good, or
another element, bad.

00:37:24.790 --> 00:37:28.090
But now two elements of A,
you get goodgood or goodbad,

00:37:28.090 --> 00:37:29.530
and so on.

00:37:29.530 --> 00:37:32.920
Or three elements of A,
goodgoodgood, goodgoodbad.

00:37:32.920 --> 00:37:37.130
And so, in fact, A star is
going to be an infinite language

00:37:37.130 --> 00:37:46.530
if A itself contains
any non-empty member.

00:37:46.530 --> 00:37:50.390
So if A is the empty
language or if A contains

00:37:50.390 --> 00:37:54.170
just the language empty
string, then A star

00:37:54.170 --> 00:37:56.480
will be not an
infinite language.

00:37:56.480 --> 00:37:59.000
It'll just be the
language empty string.

00:37:59.000 --> 00:38:02.020
But otherwise, it'll be
an infinite language.

00:38:02.020 --> 00:38:02.890
I'm not even sure--

00:38:07.780 --> 00:38:08.650
OK.

00:38:08.650 --> 00:38:09.880
I'm not-- [LAUGHS]

00:38:09.880 --> 00:38:11.020
I'm ignoring the chat here.

00:38:11.020 --> 00:38:12.670
I'm hoping people
are getting-- are you

00:38:12.670 --> 00:38:15.850
guys are getting your
questions answered by our TAs?

00:38:15.850 --> 00:38:17.440
How are we doing, Thomas?

00:38:17.440 --> 00:38:21.177
AUDIENCE: One question is, are
the slides going to be posted?

00:38:21.177 --> 00:38:23.260
MICHAEL SIPSER: Are the
slides going to be posted?

00:38:23.260 --> 00:38:28.147
Well, the whole lecture
is going to be recorded.

00:38:28.147 --> 00:38:29.980
Is it helpful to have
the slides separately?

00:38:29.980 --> 00:38:33.130
I can post the slides.

00:38:33.130 --> 00:38:34.360
Sure.

00:38:34.360 --> 00:38:36.460
Remind me if I don't,
but I'll try to do that.

00:38:36.460 --> 00:38:37.360
Yes, it is helpful.

00:38:37.360 --> 00:38:38.530
I will do that.

00:38:41.580 --> 00:38:43.440
Yeah.

00:38:43.440 --> 00:38:44.690
Yeah, I will post the slides.

00:38:44.690 --> 00:38:47.808
Just, Thomas, it's
your job to remind me.

00:38:47.808 --> 00:38:48.350
AUDIENCE: OK.

00:38:51.820 --> 00:38:53.830
MICHAEL SIPSER: All right, good.

00:38:53.830 --> 00:38:55.610
So we talked about the
regular operations.

00:38:55.610 --> 00:38:57.740
Let's talk about the
regular expressions.

00:38:57.740 --> 00:38:59.500
So regular
expressions are-- just

00:38:59.500 --> 00:39:01.570
like you have the
arithmetical operations,

00:39:01.570 --> 00:39:03.550
then you can get
arithmetical expressions,

00:39:03.550 --> 00:39:07.320
like 1 plus 3 times 7.

00:39:07.320 --> 00:39:09.070
So now we're going to
make expressions out

00:39:09.070 --> 00:39:10.240
of these operations.

00:39:10.240 --> 00:39:13.120
First of all, you have,
the more atomic things,

00:39:13.120 --> 00:39:15.130
the building blocks of
the expressions, which

00:39:15.130 --> 00:39:23.330
are going to be like elements of
sigma, elements of the alphabet

00:39:23.330 --> 00:39:27.860
or the sigma itself
as an alphabet symbol,

00:39:27.860 --> 00:39:33.502
or the empty language
or the empty string.

00:39:33.502 --> 00:39:35.210
These are going to be
the building blocks

00:39:35.210 --> 00:39:36.470
for the regular expressions.

00:39:36.470 --> 00:39:38.550
We'll do an example in a second.

00:39:38.550 --> 00:39:42.530
And then you combine
those basic elements

00:39:42.530 --> 00:39:45.860
using the regular operations of
union, concatenation, and star.

00:39:45.860 --> 00:39:48.320
So these are the
atomic expressions,

00:39:48.320 --> 00:39:50.070
these are the
composite expressions.

00:39:50.070 --> 00:39:57.940
So, for example, if you look at
the expression 0 union 1 star--

00:39:57.940 --> 00:40:00.400
so we can also write
that as sigma star.

00:40:00.400 --> 00:40:04.540
Because if sigma is 0
and 1, then sigma star

00:40:04.540 --> 00:40:08.440
is the same thing as 0 union 1--
sigma is the same as 0 union 1.

00:40:08.440 --> 00:40:11.763
And that just gives all
possible strings over sigma.

00:40:11.763 --> 00:40:13.930
So this is something you're
going to see frequently.

00:40:13.930 --> 00:40:16.720
Sigma star means
this is the language

00:40:16.720 --> 00:40:18.850
of all strings over
the alphabet we're

00:40:18.850 --> 00:40:22.340
working with at that moment.

00:40:22.340 --> 00:40:26.270
Now, if you take
sigma star 1, you just

00:40:26.270 --> 00:40:30.350
concatenate 1 onto all of
the elements of sigma star,

00:40:30.350 --> 00:40:34.100
and that's going to give you
all strings that end with a 1.

00:40:34.100 --> 00:40:36.200
Technically, you might
imagine writing this

00:40:36.200 --> 00:40:40.880
with braces around the 1, but
generally, we don't do that.

00:40:40.880 --> 00:40:45.380
We just-- single element
sets, single element strings,

00:40:45.380 --> 00:40:47.900
we write without the
braces, because it's

00:40:47.900 --> 00:40:50.790
clear enough without them,
and it gets messy with them.

00:40:50.790 --> 00:40:53.780
So sigma star 1 is all
strings that end with 1.

00:40:53.780 --> 00:40:57.830
Or, for example,
you take sigma star

00:40:57.830 --> 00:41:03.020
11 sigma star, that is all
strings that contain 11.

00:41:03.020 --> 00:41:05.000
And we already saw that
language once before.

00:41:05.000 --> 00:41:06.830
That's the language
of that other machine

00:41:06.830 --> 00:41:10.960
that we presented one
or two slides back.

00:41:10.960 --> 00:41:11.460
OK?

00:41:14.945 --> 00:41:15.445
Right.

00:41:20.377 --> 00:41:22.210
Yeah, but in terms of
readings-- by the way,

00:41:22.210 --> 00:41:23.640
sorry, I don't know
if it's helpful to you

00:41:23.640 --> 00:41:25.110
for me to do these
interjections--

00:41:25.110 --> 00:41:30.240
but the readings are listed
also on the homework.

00:41:30.240 --> 00:41:33.570
So if you look at the
posted homework 1,

00:41:33.570 --> 00:41:38.910
it tells you which chapters
you should be reading now.

00:41:38.910 --> 00:41:42.420
And also, if you look at the
course schedule, which is also

00:41:42.420 --> 00:41:47.520
on the home page, it has the
whole course plan and which

00:41:47.520 --> 00:41:49.890
readings are for which dates.

00:41:49.890 --> 00:41:51.570
So it's all there for you.

00:41:54.470 --> 00:41:57.110
And so our goal here--
this is not an accident

00:41:57.110 --> 00:42:00.290
that sigma star 11
sigma star happens

00:42:00.290 --> 00:42:03.140
to be the same language
as we saw before

00:42:03.140 --> 00:42:07.430
from the language of
that finite automaton M1.

00:42:07.430 --> 00:42:10.250
In fact, that's a
general phenomenon.

00:42:10.250 --> 00:42:12.780
Anything you can do with
a regular expression,

00:42:12.780 --> 00:42:16.800
you can also do with a finite
automaton and vice versa.

00:42:16.800 --> 00:42:19.670
They are equivalent
in power with respect

00:42:19.670 --> 00:42:23.030
to the class of
languages they describe.

00:42:23.030 --> 00:42:24.370
And we'll prove that.

00:42:26.680 --> 00:42:27.180
OK?

00:42:30.540 --> 00:42:35.010
So if you step back for
a second and just let

00:42:35.010 --> 00:42:38.190
yourself appreciate this,
it's kind of an amazing thing.

00:42:38.190 --> 00:42:41.160
Because finite automata, with
the states and transitions,

00:42:41.160 --> 00:42:45.090
and the regular expressions,
with these operations of union,

00:42:45.090 --> 00:42:47.670
concatenation, and star,
they look totally different

00:42:47.670 --> 00:42:48.437
from one another.

00:42:48.437 --> 00:42:50.770
They look like they have
nothing to do with one another.

00:42:50.770 --> 00:42:53.880
But, in fact, they both describe
exactly the regular languages,

00:42:53.880 --> 00:42:56.250
the same class of languages.

00:42:56.250 --> 00:42:58.980
And so it's kind of a cool
fact that you can prove,

00:42:58.980 --> 00:43:01.500
that these two very
different looking systems

00:43:01.500 --> 00:43:03.240
actually are equivalent
to one another.

00:43:07.140 --> 00:43:10.780
Can we get empty
string from empty set?

00:43:10.780 --> 00:43:11.440
Yeah.

00:43:11.440 --> 00:43:15.520
There are a bunch of
exotic cases, by the way.

00:43:15.520 --> 00:43:19.270
So empty language star
is the language which

00:43:19.270 --> 00:43:21.190
has just the empty string.

00:43:21.190 --> 00:43:23.650
If you don't get that,
chew on that one.

00:43:23.650 --> 00:43:25.390
But that is true.

00:43:28.210 --> 00:43:30.850
OK, let's move on.

00:43:30.850 --> 00:43:32.903
OK, let's talk about
closure properties now.

00:43:32.903 --> 00:43:35.320
We're going to start doing
something that has a little bit

00:43:35.320 --> 00:43:37.630
more meat to it,
in terms of we're

00:43:37.630 --> 00:43:41.080
going to have our first theorem
of the course coming here.

00:43:41.080 --> 00:43:43.400
And this is not a baby theorem.

00:43:43.400 --> 00:43:46.030
This is actually-- there's
going to be some meat to this.

00:43:46.030 --> 00:43:53.080
And you're going to
have to not totally--

00:43:53.080 --> 00:43:54.280
this is not a toy.

00:43:54.280 --> 00:43:58.010
We're proving something
that has real substance.

00:43:58.010 --> 00:44:02.120
And the statement
of this theorem

00:44:02.120 --> 00:44:08.120
says that the regular languages
are closed, that really,

00:44:08.120 --> 00:44:11.510
the class of regular languages
are closed under union, closed

00:44:11.510 --> 00:44:13.980
under the union operation.

00:44:13.980 --> 00:44:16.160
So what do I mean by that?

00:44:16.160 --> 00:44:20.930
So when you say a
collection of objects

00:44:20.930 --> 00:44:23.420
is closed under
some operation, that

00:44:23.420 --> 00:44:26.480
means applying that
operation to those objects

00:44:26.480 --> 00:44:29.850
leaves you in the
same class of objects.

00:44:29.850 --> 00:44:37.790
Like the positive integers,
the natural numbers,

00:44:37.790 --> 00:44:39.680
that's closed under addition.

00:44:39.680 --> 00:44:42.950
Because when you add
two positive integers,

00:44:42.950 --> 00:44:44.870
you get back a positive integer.

00:44:44.870 --> 00:44:47.390
But they're not closed
under subtraction.

00:44:47.390 --> 00:44:50.990
Because 2 minus 4, you
get something which

00:44:50.990 --> 00:44:52.830
is not a positive integer.

00:44:52.830 --> 00:44:56.490
So closed means you leave
yourself in the collection.

00:44:56.490 --> 00:45:00.570
And the fact is that if you look
at all the regular languages--

00:45:00.570 --> 00:45:05.130
these are the languages that the
finite automata can recognize--

00:45:05.130 --> 00:45:07.470
they are closed under
the union operation.

00:45:07.470 --> 00:45:10.020
So if you start off with
two regular languages

00:45:10.020 --> 00:45:13.528
and you apply the union, you get
back another regular language.

00:45:13.528 --> 00:45:15.570
And that's what the
statement of this theorem is.

00:45:15.570 --> 00:45:18.690
I hope that's clear enough
in the way I've written it.

00:45:18.690 --> 00:45:23.940
If A1 and A2 are regular, then
A1 union A2 is also regular.

00:45:23.940 --> 00:45:25.710
That's what the
statement of this is.

00:45:25.710 --> 00:45:28.020
And it's just simply that--

00:45:28.020 --> 00:45:30.210
that's proving that the
class of regular language

00:45:30.210 --> 00:45:31.200
is closed under union.

00:45:31.200 --> 00:45:33.970
So we're going to prove that.

00:45:33.970 --> 00:45:36.500
So how do you
prove such a thing?

00:45:36.500 --> 00:45:40.810
So the way we're going
to prove that is you

00:45:40.810 --> 00:45:43.190
start off with what
we're assuming.

00:45:43.190 --> 00:45:47.300
So our hypothesis is that we
have two regular languages.

00:45:47.300 --> 00:45:49.420
And we have to prove
our conclusion,

00:45:49.420 --> 00:45:52.300
that the union is also regular.

00:45:52.300 --> 00:45:55.000
Now, the hypothesis
that they're regular,

00:45:55.000 --> 00:45:58.780
you have to unpack that and
understand, what does that

00:45:58.780 --> 00:46:00.010
get you?

00:46:00.010 --> 00:46:03.970
And them being regular means
that there are finite automata

00:46:03.970 --> 00:46:05.750
that recognize those languages.

00:46:05.750 --> 00:46:08.260
So let's give those two
finite automata names.

00:46:08.260 --> 00:46:11.740
So M1 and M2 are the
two final automata

00:46:11.740 --> 00:46:13.998
that recognize those two
languages, A1 and A2.

00:46:13.998 --> 00:46:15.790
That's what it means,
that they're regular,

00:46:15.790 --> 00:46:19.050
that these automata exist.

00:46:19.050 --> 00:46:22.160
So let's have those two
automata, M1 and M2,

00:46:22.160 --> 00:46:26.120
using the components as we've
described, the respective state

00:46:26.120 --> 00:46:29.360
sets, input alphabet,
transition functions, the two

00:46:29.360 --> 00:46:31.880
starting states and the two
collections of accepting

00:46:31.880 --> 00:46:32.390
states.

00:46:32.390 --> 00:46:34.970
Here I'm assuming that they're
over the same alphabet.

00:46:34.970 --> 00:46:36.890
You could have
automata which operate

00:46:36.890 --> 00:46:38.180
over different alphabets.

00:46:38.180 --> 00:46:40.160
It's not interesting to do that.

00:46:40.160 --> 00:46:41.370
It doesn't add anything.

00:46:41.370 --> 00:46:43.200
The proof would be
exactly the same.

00:46:43.200 --> 00:46:46.040
So let's just not overcomplicate
our lives and focus

00:46:46.040 --> 00:46:47.840
on the more interesting
case, so assuming

00:46:47.840 --> 00:46:51.990
that the two input alphabets
are going to be the same.

00:46:51.990 --> 00:46:53.870
And from these two
automata, we have

00:46:53.870 --> 00:46:56.480
to show that this
language here, the union,

00:46:56.480 --> 00:46:58.220
is also a regular language.

00:46:58.220 --> 00:47:02.450
And we're going to do that
by constructing the automaton

00:47:02.450 --> 00:47:03.980
which recognizes the union.

00:47:03.980 --> 00:47:07.250
That's really the only
thing that we can do.

00:47:07.250 --> 00:47:11.210
So we're going to build an
automaton out of M1 and M2

00:47:11.210 --> 00:47:15.240
which recognizes the union
language A1 union A2.

00:47:15.240 --> 00:47:19.560
And the task of M is that
it should accept its input

00:47:19.560 --> 00:47:22.973
if either M1 or M2 accept.

00:47:22.973 --> 00:47:24.390
And now what I'd
like you to think

00:47:24.390 --> 00:47:26.370
about doing that,
how in the world

00:47:26.370 --> 00:47:30.360
are we going to come up with
this finite automaton M?

00:47:30.360 --> 00:47:42.730
And the way we do that is
to think about, how would

00:47:42.730 --> 00:47:46.110
you do that union language?

00:47:46.110 --> 00:47:47.550
If I ask you--

00:47:47.550 --> 00:47:50.850
I give you two automata,
M1 and M2, and I say,

00:47:50.850 --> 00:47:52.020
here's an input, w.

00:47:54.820 --> 00:47:57.070
Is w in the union language?

00:47:57.070 --> 00:47:59.770
That's the job that M
is supposed to solve.

00:47:59.770 --> 00:48:01.450
And I suggest you
try to figure out

00:48:01.450 --> 00:48:03.820
how you would solve it first.

00:48:03.820 --> 00:48:06.308
I mean, this is a good
strategy for solving a lot

00:48:06.308 --> 00:48:07.600
of the problems in this course.

00:48:07.600 --> 00:48:10.830
Put yourself in the place of the
machine you're trying to build.

00:48:10.830 --> 00:48:14.270
And so if you want to try to
figure out how to do that,

00:48:14.270 --> 00:48:18.410
a natural thing is, well, you
take w, you feed it into M1,

00:48:18.410 --> 00:48:20.330
and then you feed it into M2.

00:48:20.330 --> 00:48:22.617
And if M1 accepts
it, great, then you

00:48:22.617 --> 00:48:23.780
know it's in the union.

00:48:23.780 --> 00:48:28.718
And if not, you try it out in
M2 and see if M2 accepts it.

00:48:28.718 --> 00:48:30.260
Now, you have to be
a little careful,

00:48:30.260 --> 00:48:32.750
because you want to have a
strategy that you can also

00:48:32.750 --> 00:48:37.440
implement in a finite automaton.

00:48:37.440 --> 00:48:42.180
And a finite automaton
only gets one shot

00:48:42.180 --> 00:48:43.320
at looking at the input.

00:48:43.320 --> 00:48:45.240
You can't sort of
rewind the input.

00:48:45.240 --> 00:48:48.990
You feed it first into M1
and then you feed it into M2

00:48:48.990 --> 00:48:53.010
and operate in a
sequential way like that.

00:48:53.010 --> 00:48:57.690
That's not going to be allowed
in the way finite automata

00:48:57.690 --> 00:48:58.480
work.

00:48:58.480 --> 00:49:01.950
So you're going to have to
take it to the next level,

00:49:01.950 --> 00:49:03.330
be a little bit more clever.

00:49:03.330 --> 00:49:05.880
And instead of feeding
it first into M1

00:49:05.880 --> 00:49:07.950
and then and then
into M2, you feed them

00:49:07.950 --> 00:49:11.480
into both in parallel.

00:49:11.480 --> 00:49:14.060
So you take M1 and
M2, and you run them

00:49:14.060 --> 00:49:20.180
both in parallel on the input
w, keeping track of which state

00:49:20.180 --> 00:49:24.450
each of those two
automata are in.

00:49:24.450 --> 00:49:28.070
And then at the end, you see
if either one of those machines

00:49:28.070 --> 00:49:31.243
is in an accepting state,
and then you accept.

00:49:31.243 --> 00:49:32.660
So that's the
strategy we're going

00:49:32.660 --> 00:49:38.430
to employ in building the finite
automaton M out of M1 and M2.

00:49:38.430 --> 00:49:43.150
So in terms of a picture,
here's M1 and M2.

00:49:43.150 --> 00:49:45.673
Here is the automaton
we're trying to build.

00:49:45.673 --> 00:49:47.590
We don't know how it's
going to look like yet.

00:49:47.590 --> 00:49:51.760
And yeah, so kind of getting
ahead of myself, but here

00:49:51.760 --> 00:50:00.700
is a strategy, as I
just described, for M.

00:50:00.700 --> 00:50:05.800
M is going to keep track of
which state that M1 is in

00:50:05.800 --> 00:50:08.740
and which state M2 is
in at any given moment.

00:50:08.740 --> 00:50:11.080
As we're reading
the symbols of w,

00:50:11.080 --> 00:50:16.210
we're going to feed that
into M1 and also into M2.

00:50:16.210 --> 00:50:21.340
And so the possibilities we
have to keep track of in M

00:50:21.340 --> 00:50:25.380
are all the pairs of states
that are in M1 and M2,

00:50:25.380 --> 00:50:27.130
because you're going
to really be tracking

00:50:27.130 --> 00:50:29.120
M1 and M2 simultaneously.

00:50:29.120 --> 00:50:31.570
So you have to remember
which state M1 is in and also

00:50:31.570 --> 00:50:32.920
which state M2 is in.

00:50:32.920 --> 00:50:35.170
And so that really corresponds
to what pair of states

00:50:35.170 --> 00:50:38.380
to remember, one from M1
and one from M2, and that's

00:50:38.380 --> 00:50:40.130
why I've indicated it like that.

00:50:40.130 --> 00:50:42.970
So M1 is in state
q, M2 is in state r

00:50:42.970 --> 00:50:44.890
at some given point in time.

00:50:44.890 --> 00:50:48.240
And that's going to correspond
to M being in the pair q comma

00:50:48.240 --> 00:50:49.000
r.

00:50:49.000 --> 00:50:52.300
That's just the label of
this particular state of m

00:50:52.300 --> 00:50:55.915
that we're going to apply here.

00:50:55.915 --> 00:50:56.415
OK?

00:50:59.130 --> 00:51:03.570
And then M is going
to accept if either M1

00:51:03.570 --> 00:51:06.010
and M2 is an accepting state.

00:51:06.010 --> 00:51:09.930
So it's going to be if either
q or r is an accepting state,

00:51:09.930 --> 00:51:13.840
we're going to make this
into an accepting state too.

00:51:13.840 --> 00:51:15.420
OK?

00:51:15.420 --> 00:51:16.050
Whoops.

00:51:16.050 --> 00:51:16.620
There we go.

00:51:19.725 --> 00:51:21.350
So let's describe
this formally instead

00:51:21.350 --> 00:51:23.757
of by a picture, because
we can do it both ways.

00:51:23.757 --> 00:51:26.090
And sometimes it's better to
do it one way and sometimes

00:51:26.090 --> 00:51:27.810
the other way.

00:51:27.810 --> 00:51:29.150
So now if we take--

00:51:29.150 --> 00:51:34.820
the components of M now are the
pairs of states from M1 and M2.

00:51:34.820 --> 00:51:38.400
Again, I'm writing this out
literally, explicitly here,

00:51:38.400 --> 00:51:40.490
but you should make sure
you're comfortable with

00:51:40.490 --> 00:51:42.330
this cross product notation.

00:51:42.330 --> 00:51:45.260
So this is the collection of
pairs of states, q1 and q2,

00:51:45.260 --> 00:51:47.660
where q1 is in the state
of the first machine,

00:51:47.660 --> 00:51:50.600
q2 is the state of
the second machine.

00:51:50.600 --> 00:51:53.630
The start state is you
start at the two start

00:51:53.630 --> 00:51:55.850
states of the two machines.

00:51:55.850 --> 00:51:57.530
So this is q1, q2--

00:51:57.530 --> 00:52:01.100
probably I should have
not reused the Q notation.

00:52:01.100 --> 00:52:02.532
I should have called these r's--

00:52:02.532 --> 00:52:03.740
now that I'm looking at that.

00:52:03.740 --> 00:52:06.500
But, anyway, I hope you're
not confused by reusing this.

00:52:06.500 --> 00:52:09.890
q1 and q2 here are the
specific start states

00:52:09.890 --> 00:52:12.150
of the two machines.

00:52:12.150 --> 00:52:15.650
These are just two other
states, representative states

00:52:15.650 --> 00:52:17.780
of those machines.

00:52:17.780 --> 00:52:20.623
Now, the transition
function for the new machine

00:52:20.623 --> 00:52:22.790
is going to be built out
of the transition functions

00:52:22.790 --> 00:52:24.870
from the previous machines.

00:52:24.870 --> 00:52:30.500
So when I have a pair, q,
r, and I have the symbol a,

00:52:30.500 --> 00:52:31.520
where do we go?

00:52:31.520 --> 00:52:33.270
Which new pair do we get?

00:52:33.270 --> 00:52:35.930
Well, we just update
the state from M1

00:52:35.930 --> 00:52:38.510
and update the state
from M2 according

00:52:38.510 --> 00:52:40.273
to their respective
transition functions,

00:52:40.273 --> 00:52:41.690
and that's what's
shown over here.

00:52:45.410 --> 00:52:50.080
Now let's take a look at
the accepting states for M.

00:52:50.080 --> 00:52:54.430
The natural thing to do is look
at the set of pairs of states,

00:52:54.430 --> 00:52:57.400
where we have a pair of states--

00:52:57.400 --> 00:53:02.830
a pair of accepting states,
one from the first machine

00:53:02.830 --> 00:53:05.430
and one from the second machine.

00:53:05.430 --> 00:53:07.470
But if you're
thinking with me, you

00:53:07.470 --> 00:53:09.585
realize that this is
not the right thing.

00:53:12.510 --> 00:53:13.170
What is DFAs?

00:53:16.570 --> 00:53:18.760
Did I would call
them DFA somewhere?

00:53:18.760 --> 00:53:22.516
Oh, somebody else is probably
doing that in the chat.

00:53:22.516 --> 00:53:25.540
The DFA-- careful what
notation you're using.

00:53:25.540 --> 00:53:28.430
We haven't introduced DFAs yet.

00:53:28.430 --> 00:53:30.370
We'll do that next on Thursday.

00:53:30.370 --> 00:53:31.300
But these are DFAs.

00:53:31.300 --> 00:53:34.300
These are just finite automata,
Deterministic Finite Automata.

00:53:34.300 --> 00:53:35.680
That's why the D.

00:53:35.680 --> 00:53:38.342
Anyway, so this is
actually not right,

00:53:38.342 --> 00:53:40.300
because if you think
about what this is saying,

00:53:40.300 --> 00:53:44.260
it says that both components
have to be accepting.

00:53:44.260 --> 00:53:47.900
And you want either
one to be accepting.

00:53:47.900 --> 00:53:50.050
So this is not good.

00:53:50.050 --> 00:53:53.560
This would be the wrong
way of defining it.

00:53:53.560 --> 00:53:55.510
That actually gives the
intersection language.

00:53:55.510 --> 00:53:56.927
And really, kind
of along the way,

00:53:56.927 --> 00:53:58.762
it's proving closure
under intersection,

00:53:58.762 --> 00:54:00.220
which we don't care
about but might

00:54:00.220 --> 00:54:04.690
be useful to have in our back
pocket sometime in the future.

00:54:04.690 --> 00:54:07.000
In order to get
closure under a union,

00:54:07.000 --> 00:54:09.100
we have to write it this
slightly more complicated

00:54:09.100 --> 00:54:14.710
looking way, which says the
pair, what you want to have is

00:54:14.710 --> 00:54:18.940
either the first state is
an accepting state and then

00:54:18.940 --> 00:54:21.490
any state for the
second element,

00:54:21.490 --> 00:54:23.680
or any state for
the first element

00:54:23.680 --> 00:54:26.290
and an accepting state
for the second element.

00:54:26.290 --> 00:54:31.090
That's what it means to have the
union, to be doing the union.

00:54:31.090 --> 00:54:31.690
OK?

00:54:31.690 --> 00:54:35.020
So let's do-- oh,
here's a quick check-in.

00:54:38.020 --> 00:54:40.360
So let's do another poll here.

00:54:40.360 --> 00:54:41.995
We thought we were
done with these.

00:54:44.660 --> 00:54:50.450
Again-- oh, here we go.

00:54:50.450 --> 00:54:53.320
So it was too complicated to
write it out in the polls,

00:54:53.320 --> 00:54:55.480
so I actually put it up
on the slide for you.

00:54:58.400 --> 00:55:02.410
So all I'm asking is
that if M1 has k1 states

00:55:02.410 --> 00:55:05.290
and M2 has k2 states, how
many states does M have?

00:55:08.810 --> 00:55:12.255
Is it the sum, the sum of
the squares, or the product?

00:55:17.450 --> 00:55:20.330
OK, you have to think
about the states of M, what

00:55:20.330 --> 00:55:22.790
do they look like?

00:55:22.790 --> 00:55:26.720
And come on, guys.

00:55:29.330 --> 00:55:33.560
All right, ending the
poll, sharing results.

00:55:33.560 --> 00:55:37.460
Yes, indeed, it is-- most
of you got it correct.

00:55:37.460 --> 00:55:40.040
It is C, the product.

00:55:40.040 --> 00:55:42.830
Because when you look at the
number of pairs of states

00:55:42.830 --> 00:55:46.280
from M1 and M2, you
need all possible pairs.

00:55:46.280 --> 00:55:48.950
And so it's the number of
states in M1 times the number

00:55:48.950 --> 00:55:49.950
of states in M2.

00:55:49.950 --> 00:55:55.610
So make sure you understand
that and think about that

00:55:55.610 --> 00:55:59.780
so that you're
following and get this.

00:55:59.780 --> 00:56:04.370
All right, so
let's move on here.

00:56:04.370 --> 00:56:06.070
So we have another
five minutes or so.

00:56:06.070 --> 00:56:11.640
Let's start thinking about
closure under concatenation.

00:56:11.640 --> 00:56:13.410
So if we have two
regular languages,

00:56:13.410 --> 00:56:17.400
so is the
concatenation language.

00:56:17.400 --> 00:56:18.810
We're going to
try to prove that.

00:56:18.810 --> 00:56:21.780
We won't finish, but we'll at
least get our creative juices

00:56:21.780 --> 00:56:23.620
going about it.

00:56:23.620 --> 00:56:25.620
So we're going to do
the same scheme here.

00:56:25.620 --> 00:56:29.610
We're going to take two
machines for A1 and A2

00:56:29.610 --> 00:56:31.890
and build a machine for the
concatenation language out

00:56:31.890 --> 00:56:32.790
of those two.

00:56:32.790 --> 00:56:38.220
So here are the two machines
for A1 and A2 written down.

00:56:38.220 --> 00:56:43.320
And now here is the
concatenation language.

00:56:43.320 --> 00:56:46.240
And I'm going to propose
to you a strategy--

00:56:46.240 --> 00:56:48.150
which is not going
to work, but it still

00:56:48.150 --> 00:56:50.590
is going to be a good
intuition to have.

00:56:50.590 --> 00:56:53.550
So what I'm going to do is
I'm going to make a copy of--

00:56:53.550 --> 00:56:56.530
OK, let's understand what
M is supposed to do first.

00:56:56.530 --> 00:56:58.170
So M should accept its input.

00:56:58.170 --> 00:56:59.040
So think about this.

00:56:59.040 --> 00:57:01.050
M is doing the
concatenation language.

00:57:01.050 --> 00:57:02.610
So it's given a string.

00:57:02.610 --> 00:57:07.380
And it has to answer, is it
in the concatenation language

00:57:07.380 --> 00:57:09.030
A1A2 or not?

00:57:09.030 --> 00:57:13.560
So it should accept it if
there's some way to divide w

00:57:13.560 --> 00:57:17.250
into two pieces where M1 accepts
the first piece and M2 accepts

00:57:17.250 --> 00:57:20.540
the second piece.

00:57:20.540 --> 00:57:23.290
So here would be the picture.

00:57:23.290 --> 00:57:23.800
OK?

00:57:23.800 --> 00:57:27.550
And now we have to try to
make a machine which is

00:57:27.550 --> 00:57:29.170
going to solve this intuition.

00:57:29.170 --> 00:57:32.341
So how would you
do that yourself?

00:57:32.341 --> 00:57:34.580
I'm giving you w.

00:57:34.580 --> 00:57:37.410
And you can simulate M1 and M2.

00:57:37.410 --> 00:57:39.410
So the natural thing
is you're going

00:57:39.410 --> 00:57:41.780
to start out by
simulating M1 for a while

00:57:41.780 --> 00:57:44.600
and then shift into
simulating M2 for a while,

00:57:44.600 --> 00:57:47.960
because that's what's
supposed to be happening

00:57:47.960 --> 00:57:49.260
as you're processing the input.

00:57:49.260 --> 00:57:54.580
So I'm going to suggest that in
terms of the diagram like this.

00:57:54.580 --> 00:58:01.500
So we have here M1
and M2 copied here.

00:58:01.500 --> 00:58:08.940
And what I propose doing
is connecting M1 to M2

00:58:08.940 --> 00:58:13.230
so that when M1 has
accepted its input,

00:58:13.230 --> 00:58:16.410
we're going to jump to
M2, because that's perhaps

00:58:16.410 --> 00:58:17.850
the first part of w.

00:58:17.850 --> 00:58:20.495
And now we're going to have M2
process the second part of w.

00:58:20.495 --> 00:58:21.870
So the way I'm
going to implement

00:58:21.870 --> 00:58:26.100
that is by declassifying
the start state of M2,

00:58:26.100 --> 00:58:29.880
having transition symbols from
the accepting states of M1

00:58:29.880 --> 00:58:37.225
to M2, and then removing these
guys here as accepting states.

00:58:37.225 --> 00:58:39.350
And we would have to figure
out what sort of labels

00:58:39.350 --> 00:58:40.400
to apply here.

00:58:40.400 --> 00:58:44.970
But, actually, this
reasoning doesn't work.

00:58:44.970 --> 00:58:47.400
It's tempting, but flawed.

00:58:47.400 --> 00:58:50.520
Because-- what goes wrong?

00:58:50.520 --> 00:58:52.260
What happens is that--

00:58:52.260 --> 00:58:59.300
it might be that when M1 has
accepted an initial part of w

00:58:59.300 --> 00:59:03.980
and then it wants M2
to accept the rest,

00:59:03.980 --> 00:59:08.000
it might fail because M2
doesn't accept the rest.

00:59:08.000 --> 00:59:10.190
And what you might have
been better off doing

00:59:10.190 --> 00:59:13.370
is waiting longer
in M1, because there

00:59:13.370 --> 00:59:15.440
might have been some
other later place

00:59:15.440 --> 00:59:20.010
to split w, which
is still valid.

00:59:20.010 --> 00:59:22.710
Splitting w in the
first place where

00:59:22.710 --> 00:59:25.020
you have M1 accepting
an initial part

00:59:25.020 --> 00:59:27.870
may not be the optimal
place to split w.

00:59:27.870 --> 00:59:29.850
You might want to wait
later, and then you'll

00:59:29.850 --> 00:59:34.230
have a better chance
of accepting w.

00:59:34.230 --> 00:59:38.310
So I'm not sure if
you quite follow that.

00:59:38.310 --> 00:59:41.230
But, in fact, it doesn't work.

00:59:41.230 --> 00:59:42.780
The question is
where to split w,

00:59:42.780 --> 00:59:46.050
and it's challenging,
because how do you

00:59:46.050 --> 00:59:47.370
know where to split w?

00:59:47.370 --> 00:59:50.040
Because it depends upon what--

00:59:50.040 --> 00:59:54.490
it depends on y, and
you haven't seen y yet.

00:59:54.490 --> 00:59:57.980
So when you try to think about
it that way, it looks hopeless.

00:59:57.980 --> 00:59:59.840
But, in fact, it's still true.

00:59:59.840 --> 01:00:03.270
And we'll see how to
do that on Thursday.

01:00:03.270 --> 01:00:08.030
So just to recap
what we did today,

01:00:08.030 --> 01:00:10.550
we did our
introductory stuff, we

01:00:10.550 --> 01:00:14.250
defined finite automata,
regular languages.

01:00:14.250 --> 01:00:17.630
We defined the regular
operations and expressions.

01:00:17.630 --> 01:00:19.130
We showed that the
regular languages

01:00:19.130 --> 01:00:20.960
are closed under union.

01:00:20.960 --> 01:00:24.640
We started closure under
intersection, to be continued.