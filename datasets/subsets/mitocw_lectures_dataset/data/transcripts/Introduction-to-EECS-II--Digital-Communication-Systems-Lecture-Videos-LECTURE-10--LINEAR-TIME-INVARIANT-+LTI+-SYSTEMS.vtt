WEBVTT

00:00:00.000 --> 00:00:02.520
The following content is
provided under a Creative

00:00:02.520 --> 00:00:03.970
Commons license.

00:00:03.970 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.690
continue to offer high-quality
educational resources for free.

00:00:10.690 --> 00:00:13.350
To make a donation or
view additional materials

00:00:13.350 --> 00:00:17.190
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.190 --> 00:00:18.318
at ocw.mit.edu.

00:00:26.403 --> 00:00:28.570
PROFESSOR: Thank you for
coming out here in the rain

00:00:28.570 --> 00:00:33.800
and the day before a quiz, but
this is stuff we need to know.

00:00:33.800 --> 00:00:38.410
So I'm going to be talking
about a powerful class of models

00:00:38.410 --> 00:00:40.780
for communication channels.

00:00:40.780 --> 00:00:44.630
We've already seen the kind of
setup that we're talking about.

00:00:44.630 --> 00:00:46.300
And so what we're
looking to do is

00:00:46.300 --> 00:00:51.310
model a channel
between this point xn,

00:00:51.310 --> 00:00:53.860
I think my pointer is--

00:00:53.860 --> 00:00:54.760
OK, there we go.

00:00:54.760 --> 00:00:58.540
Between xn and yn
out there, so what

00:00:58.540 --> 00:01:01.600
we refer to as the
baseband channel.

00:01:01.600 --> 00:01:09.640
So we've got xn coming in,
various things being done

00:01:09.640 --> 00:01:12.310
to it, and then yn coming out.

00:01:17.590 --> 00:01:21.430
And we refer to this as
the baseband channel.

00:01:26.050 --> 00:01:28.570
So what's happening in
here is things like--

00:01:28.570 --> 00:01:33.520
let's see-- D to A
conversion, Digital to Analog.

00:01:33.520 --> 00:01:35.740
And then there is
the modulation.

00:01:40.640 --> 00:01:42.265
And then there is
the physical channel.

00:01:47.500 --> 00:01:49.570
I may not have left
enough space in this box.

00:01:49.570 --> 00:01:59.590
But here is the demodulation
and whatever filtering,

00:01:59.590 --> 00:02:03.910
demodulation and filtering
that happens in there.

00:02:03.910 --> 00:02:05.990
So there is distortion--
oh, I'm sorry.

00:02:05.990 --> 00:02:09.130
I forgot the A to D, didn't I?

00:02:09.130 --> 00:02:11.940
So let's stick
that back in here.

00:02:14.700 --> 00:02:17.860
We're doing all our demodulation
and filtering in discrete time,

00:02:17.860 --> 00:02:20.220
so we have an A to D
converter here, and then

00:02:20.220 --> 00:02:27.180
D mod and filtering.

00:02:27.180 --> 00:02:29.260
And there is various
places here that you

00:02:29.260 --> 00:02:30.630
can get distortion and noise.

00:02:30.630 --> 00:02:34.860
So for instance, the physical
channel is a source of noise.

00:02:34.860 --> 00:02:36.810
But the discrete time
operations as well,

00:02:36.810 --> 00:02:39.332
the computational pieces
can also introduce noise.

00:02:39.332 --> 00:02:41.790
You could have numerical noise,
because you're sounding off

00:02:41.790 --> 00:02:43.660
numbers, and so on.

00:02:43.660 --> 00:02:46.290
So there are various places
that noise can originate.

00:02:46.290 --> 00:02:50.100
And there are various places
that distortion of the signal

00:02:50.100 --> 00:02:50.980
can originate.

00:02:50.980 --> 00:02:54.690
So in the filtering
process, for instance,

00:02:54.690 --> 00:02:59.490
or the channel
process, you can get

00:02:59.490 --> 00:03:02.790
phenomena that will take what
started out as a straight edge

00:03:02.790 --> 00:03:10.530
here and cause it to now get a
little bit spread out and not

00:03:10.530 --> 00:03:11.560
so clean at the edge.

00:03:14.600 --> 00:03:17.005
OK, so that's what we
refer to as a distortion.

00:03:17.005 --> 00:03:18.630
So there is all sorts
of things in here

00:03:18.630 --> 00:03:20.010
that can account for that.

00:03:20.010 --> 00:03:21.630
Now, when we say
baseband channel,

00:03:21.630 --> 00:03:24.600
we're actually trying to
distinguish it from the channel

00:03:24.600 --> 00:03:28.050
that you see after
the modulation.

00:03:28.050 --> 00:03:30.480
So once you've
modulated, you typically

00:03:30.480 --> 00:03:32.880
move things to some
other frequency range.

00:03:32.880 --> 00:03:35.700
And so the actual transmission
across the physical channel

00:03:35.700 --> 00:03:38.260
happens in some other
frequency range.

00:03:38.260 --> 00:03:40.860
And so the word
"baseband" here is

00:03:40.860 --> 00:03:44.220
used to distinguish the
channel that we're talking

00:03:44.220 --> 00:03:47.133
about from that channel.

00:03:47.133 --> 00:03:49.050
So this is what we're
going to be focusing on.

00:03:49.050 --> 00:03:52.920
And then will later come back
to talking about the modulation

00:03:52.920 --> 00:03:55.140
and demodulation pieces.

00:03:55.140 --> 00:04:00.090
So last time, I introduced
a way to represent

00:04:00.090 --> 00:04:05.850
such models just as systems
with an input and an output.

00:04:05.850 --> 00:04:08.730
One thing I made
a point of saying

00:04:08.730 --> 00:04:13.917
was that when we look
at a figure like this--

00:04:13.917 --> 00:04:14.625
here is a system.

00:04:17.459 --> 00:04:20.670
We've got some input sequence
that's actually going in

00:04:20.670 --> 00:04:23.680
and maps to some
output sequence.

00:04:23.680 --> 00:04:25.140
So I use this
notation with a dot

00:04:25.140 --> 00:04:28.680
there to indicate the
entire time function.

00:04:28.680 --> 00:04:31.410
So I've got some entire
time function here

00:04:31.410 --> 00:04:35.045
that goes through the system and
gets mapped to some entire time

00:04:35.045 --> 00:04:35.670
function there.

00:04:35.670 --> 00:04:37.128
And I'm not telling
you the details

00:04:37.128 --> 00:04:39.270
of how that mapping
happens yet, but this

00:04:39.270 --> 00:04:40.680
is my abstract picture.

00:04:40.680 --> 00:04:44.826
Now, in many places you'll
see people writing--

00:04:44.826 --> 00:04:46.620
and again, I said
this last time.

00:04:46.620 --> 00:04:49.050
But I want to remind
you, you'll see

00:04:49.050 --> 00:04:52.980
them labeling xn going into
the system and yn coming out.

00:04:52.980 --> 00:04:54.390
And when you see
that, you've got

00:04:54.390 --> 00:04:55.890
to think that what
you're looking at

00:04:55.890 --> 00:04:57.720
is just a snapshot at time n.

00:04:57.720 --> 00:05:07.500
So this picture is what you
get in a snapshot at time n,

00:05:07.500 --> 00:05:09.360
whereas this picture
is the picture that

00:05:09.360 --> 00:05:16.320
refers to actually mapping the
input signal, the entire input

00:05:16.320 --> 00:05:21.780
signal to the output signal.

00:05:26.500 --> 00:05:31.230
OK, so these are two different
ways of representing things.

00:05:33.840 --> 00:05:36.640
In this system, I'm not
taking the value of time n

00:05:36.640 --> 00:05:38.310
and producing a value at time n.

00:05:38.310 --> 00:05:41.220
I typically will need to look
at lots of values of the input

00:05:41.220 --> 00:05:43.920
to figure out any particular
value of the output.

00:05:48.000 --> 00:05:53.130
All right, I did mention
briefly the notion of causality.

00:05:53.130 --> 00:05:54.910
And we'll come
back to that later.

00:05:54.910 --> 00:05:57.090
But the rough notion is that--

00:05:57.090 --> 00:06:00.960
or a good enough notion is that
the system is called causal

00:06:00.960 --> 00:06:03.480
if the response at
any time depends only

00:06:03.480 --> 00:06:07.590
on present and past inputs
and not on future inputs.

00:06:07.590 --> 00:06:08.550
That's easy enough.

00:06:12.600 --> 00:06:13.800
And then there were--

00:06:13.800 --> 00:06:15.600
we were going to
specialize, actually,

00:06:15.600 --> 00:06:18.410
to the case of linear and
time-invariant systems.

00:06:18.410 --> 00:06:22.770
And so I want to first introduce
the notion of time invariance.

00:06:22.770 --> 00:06:25.740
Time invariance says basically
that, if you shift the input

00:06:25.740 --> 00:06:28.938
by a certain amount, then
the output gets just shifted

00:06:28.938 --> 00:06:29.730
by the same amount.

00:06:29.730 --> 00:06:32.797
But the same input-output
pair works as before.

00:06:32.797 --> 00:06:34.380
So what you're really
trying to get at

00:06:34.380 --> 00:06:39.060
is a time-invariant system is
one where the laws by which you

00:06:39.060 --> 00:06:42.360
compose the values of the
input to get the output

00:06:42.360 --> 00:06:45.740
don't change with time.

00:06:45.740 --> 00:06:47.500
So let's see.

00:06:47.500 --> 00:06:50.600
Let me give you an example here.

00:06:50.600 --> 00:06:55.630
Suppose I had a system
whose input and output

00:06:55.630 --> 00:06:57.000
were related in this fashion.

00:07:02.750 --> 00:07:05.600
Would that, do you think,
be a time-invariant system

00:07:05.600 --> 00:07:06.790
or a time-varying system?

00:07:14.020 --> 00:07:16.810
I seem to have functions
of time in here.

00:07:16.810 --> 00:07:18.520
Does that make it a
time-varying system?

00:07:18.520 --> 00:07:21.070
Or is it perhaps time invariant?

00:07:21.070 --> 00:07:21.885
Yeah?

00:07:21.885 --> 00:07:25.280
AUDIENCE: Time invariant,
because of the law [INAUDIBLE]..

00:07:28.115 --> 00:07:29.490
PROFESSOR: OK, so
time invariant,

00:07:29.490 --> 00:07:31.730
because the law by which
you're composing things

00:07:31.730 --> 00:07:34.470
to get the output
doesn't depend on time.

00:07:34.470 --> 00:07:39.515
So the point is that these
coefficients are constant.

00:07:45.950 --> 00:07:47.630
So because these are
constant, what you

00:07:47.630 --> 00:07:50.330
have is actually a
time-invariant system.

00:07:50.330 --> 00:07:52.700
So to get the
output at any time,

00:07:52.700 --> 00:07:55.490
you're taking 1/3 of the
output of the previous time

00:07:55.490 --> 00:07:58.010
plus twice the input
of the present time.

00:07:58.010 --> 00:08:01.350
And that prescription holds
along the entire time axis.

00:08:01.350 --> 00:08:05.010
So the actual value
of n doesn't matter.

00:08:05.010 --> 00:08:06.980
But if I had here
some function of n,

00:08:06.980 --> 00:08:13.730
if, instead of 1/3, I had
something like 1/3 to the n,

00:08:13.730 --> 00:08:16.190
now I've got a
time-varying system,

00:08:16.190 --> 00:08:19.100
because the law by which
I combine things actually

00:08:19.100 --> 00:08:21.320
depends on my position
along the time axis.

00:08:26.650 --> 00:08:28.780
So this would be time invariant.

00:08:28.780 --> 00:08:30.640
This would be not.

00:08:35.669 --> 00:08:38.010
So that's what this
is trying to get at.

00:08:38.010 --> 00:08:38.580
Easy enough.

00:08:41.539 --> 00:08:45.520
The other notion was
that of linearity.

00:08:45.520 --> 00:08:47.092
By the way, if you
read the chapter,

00:08:47.092 --> 00:08:48.550
you'll see some
other examples that

00:08:48.550 --> 00:08:51.520
will help you hone your
intuition for what's

00:08:51.520 --> 00:08:52.840
time invariant and what's not.

00:08:55.960 --> 00:08:57.910
For linearity,
the basic idea was

00:08:57.910 --> 00:09:01.990
that you can superpose
inputs and find

00:09:01.990 --> 00:09:04.940
the corresponding
responses by superposition.

00:09:04.940 --> 00:09:07.600
So if you've got the
results of two experiments,

00:09:07.600 --> 00:09:10.930
the input in one experiment
and the output, the input

00:09:10.930 --> 00:09:13.192
in a second experiment
and the output,

00:09:13.192 --> 00:09:15.400
and then you take a new
experiment in which the input

00:09:15.400 --> 00:09:18.250
is a linear combination
of the previous two ones,

00:09:18.250 --> 00:09:22.060
the response will be the
same linear combination

00:09:22.060 --> 00:09:24.550
of the previous two responses.

00:09:24.550 --> 00:09:26.350
So that's the basic idea here.

00:09:26.350 --> 00:09:30.800
So linearity means that
superposition works.

00:09:30.800 --> 00:09:33.460
And so this is another
feature that we'll use.

00:09:33.460 --> 00:09:39.670
And for this example on top, do
you think it's linear or not?

00:09:45.590 --> 00:09:46.750
So what you really--

00:09:46.750 --> 00:09:48.670
the way to think
about it is, suppose

00:09:48.670 --> 00:09:51.970
I had an experiment A
in which my output was

00:09:51.970 --> 00:09:57.610
y, in which I fed in xA,
some time signal, and I got

00:09:57.610 --> 00:10:01.520
a response, some time signal.

00:10:01.520 --> 00:10:03.940
So what that means
is that this is true.

00:10:08.860 --> 00:10:11.200
This is what it means
to say that this

00:10:11.200 --> 00:10:13.690
is an input-output
pair in experiment A.

00:10:13.690 --> 00:10:16.330
And now in experiment
B, similarly, I

00:10:16.330 --> 00:10:25.465
have yB n satisfying
this equation.

00:10:28.660 --> 00:10:30.490
So the subscript here
just means experiment

00:10:30.490 --> 00:10:43.222
A, experiment B. So this is an
experiment A and experiment B.

00:10:43.222 --> 00:10:44.680
So now the question
you want to ask

00:10:44.680 --> 00:10:51.790
yourself is, is it true that, if
I defined a new input xn to be,

00:10:51.790 --> 00:10:52.990
let's say--

00:10:52.990 --> 00:10:56.350
what notation did I use there?

00:10:56.350 --> 00:10:58.180
Well, I didn't want
an A and a B, did I?

00:11:00.840 --> 00:11:03.120
OK, if you ignore the
notation on my slides,

00:11:03.120 --> 00:11:14.460
let's say that this is an
alpha x A plus beta x B.

00:11:14.460 --> 00:11:16.170
OK, so here is a new
experiment in which

00:11:16.170 --> 00:11:19.260
I'm going to use an input
that's a linear combination

00:11:19.260 --> 00:11:23.880
of the previous two inputs with
some arbitrary weights alpha

00:11:23.880 --> 00:11:25.110
and beta.

00:11:25.110 --> 00:11:30.660
And the question then is, is
the corresponding combination

00:11:30.660 --> 00:11:33.330
of the outputs in the
previous experiment,

00:11:33.330 --> 00:11:44.580
so alpha yA n plus beta yB
n, does this x and y end pair

00:11:44.580 --> 00:11:47.300
satisfy the same equation?

00:11:47.300 --> 00:11:52.000
OK, so what we want to
check now is, is it true--

00:11:52.000 --> 00:11:55.080
well, is it true
that the xn here,

00:11:55.080 --> 00:11:58.530
the yn here will satisfy
the equation on top?

00:11:58.530 --> 00:12:01.540
And you can see very
quickly that it will.

00:12:01.540 --> 00:12:04.260
And the reason is
that yn here is

00:12:04.260 --> 00:12:07.860
expressed as a linear
function of the yn minus 1

00:12:07.860 --> 00:12:08.940
and xn minus 1.

00:12:08.940 --> 00:12:10.800
So when you substitute
these in, you'll

00:12:10.800 --> 00:12:14.610
find that xn defined this way
and yn defined this way will

00:12:14.610 --> 00:12:17.760
actually satisfy that equation.

00:12:17.760 --> 00:12:20.990
So this is what superposition
requires you to test.

00:12:20.990 --> 00:12:23.920
So if it's true for every
possible pair of experiments

00:12:23.920 --> 00:12:29.110
here and every pair of
weights alpha and beta

00:12:29.110 --> 00:12:33.407
that the superposition satisfies
the equations governing

00:12:33.407 --> 00:12:35.490
the system, then what you
have is a linear system.

00:12:41.120 --> 00:12:45.770
What about if I had to change
this to 1/3 to the power n?

00:12:45.770 --> 00:12:49.085
So I had a time-varying
expression of this type.

00:12:49.085 --> 00:12:51.380
So I have a time-varying
system, do you

00:12:51.380 --> 00:12:54.470
think this system
would still be linear?

00:12:57.225 --> 00:12:58.600
So if you work
through it, you'll

00:12:58.600 --> 00:13:01.520
see, for the same reason, that
superposition still works.

00:13:01.520 --> 00:13:04.933
So if I had 1/3 to the
n there instead of 1/3,

00:13:04.933 --> 00:13:06.850
I get a time-varying
system, but I could still

00:13:06.850 --> 00:13:07.810
superimpose solutions.

00:13:07.810 --> 00:13:09.520
It would be a linear
time-varying system.

00:13:12.930 --> 00:13:16.230
Now, we don't want to
spend too much time

00:13:16.230 --> 00:13:19.620
teasing all these apart,
because what we'll be focused on

00:13:19.620 --> 00:13:21.480
is linear and
time-invariant systems.

00:13:21.480 --> 00:13:25.530
And you'll actually come
quickly to recognize them.

00:13:25.530 --> 00:13:31.980
OK, I defined last time also
a pair of special signals

00:13:31.980 --> 00:13:34.800
which you've seen before,
the unit sample signal

00:13:34.800 --> 00:13:38.100
which has the value 1 just at
one point and the unit step

00:13:38.100 --> 00:13:39.790
signal.

00:13:39.790 --> 00:13:42.670
So let me just sketch
them out for you here.

00:13:42.670 --> 00:13:52.180
So the unit sample,
this is a signal delta n

00:13:52.180 --> 00:13:53.590
which is an entire signal.

00:13:53.590 --> 00:13:56.410
It's not just the
number 1 at time 0.

00:13:56.410 --> 00:13:58.730
It's the entire signal.

00:13:58.730 --> 00:14:01.000
That's the unit sample function.

00:14:01.000 --> 00:14:03.320
There is another notation
that's also sometimes used,

00:14:03.320 --> 00:14:06.945
which is delta sub 0 and dot.

00:14:06.945 --> 00:14:11.540
So this notation is a little bit
more evocative of a function,

00:14:11.540 --> 00:14:13.240
whereas here, you
are often tempted

00:14:13.240 --> 00:14:15.400
to think of it as a number.

00:14:15.400 --> 00:14:18.260
This says, what I'm
looking at is a function.

00:14:18.260 --> 00:14:20.860
It's a unit sample function.

00:14:20.860 --> 00:14:23.380
And the 1 is at the value 0.

00:14:26.050 --> 00:14:29.830
So if you had
delta of n minus 3,

00:14:29.830 --> 00:14:34.060
that would be this function
shifted from 0 to 1, 2, 3.

00:14:34.060 --> 00:14:38.110
So the 1, value 1
would sit at time 3.

00:14:38.110 --> 00:14:42.940
Another notation for that
would have been this.

00:14:42.940 --> 00:14:44.830
Sometimes that
notation is useful also

00:14:44.830 --> 00:14:49.630
in making sense of expressions
that you're looking at.

00:14:49.630 --> 00:14:54.550
OK, so this was the
unit sample function.

00:14:54.550 --> 00:15:05.360
And then the unit step function
steps up from 0 to 1 at time 0.

00:15:12.450 --> 00:15:13.700
That's the unit step function.

00:15:19.730 --> 00:15:23.930
And we also talked about the
response to these two inputs.

00:15:23.930 --> 00:15:25.620
So you see them up there.

00:15:25.620 --> 00:15:33.290
And now my question is, if a
unit sample signal at the input

00:15:33.290 --> 00:15:43.390
produces the unit sample
response hn at the output

00:15:43.390 --> 00:15:48.110
and un produces
the step response,

00:15:48.110 --> 00:15:52.570
and if what you have is
an LTI system in here--

00:15:52.570 --> 00:15:55.240
so it's the same LTI system
that we're talking about--

00:15:55.240 --> 00:15:57.410
can you actually relate the two?

00:15:57.410 --> 00:16:01.780
So the question is, can
you relate the unit sample

00:16:01.780 --> 00:16:04.150
response and the step response?

00:16:04.150 --> 00:16:06.430
Do I need to give you both
if I have an LTI system?

00:16:06.430 --> 00:16:07.888
Or does it suffice
to give you one?

00:16:13.710 --> 00:16:15.750
So here is one way
to think of that.

00:16:15.750 --> 00:16:17.530
This, by the way, is
the same LTI system.

00:16:17.530 --> 00:16:23.190
Maybe I should indicate
that more explicitly by,

00:16:23.190 --> 00:16:27.570
let's say, it's a specific
system, system zero.

00:16:27.570 --> 00:16:29.790
And with the same
system, I'm trying

00:16:29.790 --> 00:16:34.603
to deduce the results
of another experiment.

00:16:40.030 --> 00:16:41.640
So if we're thinking
superposition,

00:16:41.640 --> 00:16:45.810
can you tell me how to
write the unit sample

00:16:45.810 --> 00:16:52.800
function as a linear combination
of unit step functions,

00:16:52.800 --> 00:16:54.390
maybe delayed unit
step functions,

00:16:54.390 --> 00:16:55.860
scaled unit step functions?

00:16:55.860 --> 00:16:56.836
Yeah?

00:16:56.836 --> 00:16:59.276
AUDIENCE: [INAUDIBLE]

00:17:02.700 --> 00:17:06.644
PROFESSOR: OK, would it be--

00:17:06.644 --> 00:17:12.960
you said un minus un plus 1?

00:17:12.960 --> 00:17:15.210
Or is it un minus 1?

00:17:15.210 --> 00:17:15.990
n minus 1?

00:17:18.579 --> 00:17:22.119
So what we're saying
is, take this unit step

00:17:22.119 --> 00:17:26.950
and then subtract from it
a unit step delayed by 1.

00:17:29.500 --> 00:17:33.310
OK, so here is u of n minus 1.

00:17:33.310 --> 00:17:35.560
If we took the unit step
and subtracted from it

00:17:35.560 --> 00:17:38.830
a delayed unit
step, delayed by 1,

00:17:38.830 --> 00:17:42.760
the result will be just that
value 1 at time 0 will survive.

00:17:42.760 --> 00:17:44.530
Everything else will cancel out.

00:17:44.530 --> 00:17:45.950
Is that what you had in mind?

00:17:45.950 --> 00:17:47.020
OK.

00:17:47.020 --> 00:17:51.310
So if delta of n can be written
as that linear combination

00:17:51.310 --> 00:17:54.910
of unit steps, can
you tell me how

00:17:54.910 --> 00:18:03.050
to write hn in terms
of unit step responses?

00:18:03.050 --> 00:18:04.760
We're talking about
an LTI system.

00:18:07.550 --> 00:18:10.830
I took that out, but we're still
talking about an LTI system

00:18:10.830 --> 00:18:11.330
here.

00:18:15.260 --> 00:18:16.760
Somebody who hasn't
spoken maybe?

00:18:19.640 --> 00:18:20.300
Yeah?

00:18:20.300 --> 00:18:23.390
AUDIENCE: It should just be
x of n minus s of n minus 1.

00:18:23.390 --> 00:18:24.620
PROFESSOR: Yeah, OK.

00:18:24.620 --> 00:18:27.560
So superposition
says that, if you've

00:18:27.560 --> 00:18:30.860
got an input that's a
linear combination of inputs

00:18:30.860 --> 00:18:33.230
for which you know the
results of the experiment,

00:18:33.230 --> 00:18:36.560
then the corresponding output
is the same linear combination

00:18:36.560 --> 00:18:38.310
of the outputs for
that experiment.

00:18:38.310 --> 00:18:43.100
So this is going to be
sn minus s n minus 1.

00:18:48.390 --> 00:18:50.280
So you can actually
deduce the unit sample

00:18:50.280 --> 00:18:54.280
response, given the unit setup
response for an LTI system.

00:18:54.280 --> 00:18:55.050
So let's see.

00:18:55.050 --> 00:18:56.310
We've used linearity.

00:18:56.310 --> 00:18:59.010
Have we use time invariance?

00:18:59.010 --> 00:19:00.780
We used linearity
because we said,

00:19:00.780 --> 00:19:03.570
here is an experiment
in which the input

00:19:03.570 --> 00:19:06.150
is a linear
combination of inputs

00:19:06.150 --> 00:19:07.950
that we know the responses to.

00:19:07.950 --> 00:19:10.175
Where have we invoked
time invariance?

00:19:17.930 --> 00:19:18.430
Anyone?

00:19:21.520 --> 00:19:24.820
The superposition idea was part
of the definition of linearity.

00:19:24.820 --> 00:19:28.030
Because a system is
linear, if the input is

00:19:28.030 --> 00:19:31.060
a superposition of two
inputs for which you know

00:19:31.060 --> 00:19:34.780
the response, then the output is
the corresponding superposition

00:19:34.780 --> 00:19:36.550
of the responses.

00:19:36.550 --> 00:19:40.210
That seems like I've only
used superposition there.

00:19:40.210 --> 00:19:42.100
Have I actually use
time invariance as well?

00:19:42.100 --> 00:19:44.460
Yeah?

00:19:44.460 --> 00:19:44.960
Sorry?

00:19:44.960 --> 00:19:47.850
AUDIENCE: [INAUDIBLE]

00:19:47.850 --> 00:19:50.220
PROFESSOR: I've used
it in concluding

00:19:50.220 --> 00:19:52.770
that, if I put in
u of n minus 1,

00:19:52.770 --> 00:19:55.380
the response is s of n minus 1.

00:19:55.380 --> 00:19:58.680
So I've used time invariance
as well as linearity

00:19:58.680 --> 00:20:01.230
here to come up
with this statement.

00:20:01.230 --> 00:20:03.990
OK, good.

00:20:03.990 --> 00:20:07.860
So this is what I
have on the slide.

00:20:07.860 --> 00:20:09.810
And you've figured
it all out already.

00:20:09.810 --> 00:20:13.290
We've arrived at this equation.

00:20:13.290 --> 00:20:16.620
Now, if I want to turn
it around and write sn

00:20:16.620 --> 00:20:18.540
in terms of the unit
sample response,

00:20:18.540 --> 00:20:20.940
I can do that as
well, except this

00:20:20.940 --> 00:20:23.640
is analogous to integrating
a differential equation.

00:20:23.640 --> 00:20:25.890
What we have is a
difference equation here.

00:20:25.890 --> 00:20:28.050
And when you come
to integrate, well,

00:20:28.050 --> 00:20:29.940
in discrete time, what
you do is summation

00:20:29.940 --> 00:20:31.500
instead of integration.

00:20:31.500 --> 00:20:34.480
You need to assume an initial
condition of some kind.

00:20:34.480 --> 00:20:35.880
And so it turns
out if you assume

00:20:35.880 --> 00:20:39.210
that, way back in the past,
the value of the step response

00:20:39.210 --> 00:20:45.600
was 0, then you can actually
go from this description

00:20:45.600 --> 00:20:48.780
to a description the other
way, relating the step response

00:20:48.780 --> 00:20:50.490
to the unit sample response.

00:20:50.490 --> 00:20:55.590
OK, so if I have a causal
system, for instance, so

00:20:55.590 --> 00:20:58.350
the causal system,
it's got no response

00:20:58.350 --> 00:20:59.880
until the input hits it.

00:20:59.880 --> 00:21:02.940
So when I put a
unit step in, I'm

00:21:02.940 --> 00:21:04.870
not going to get a
response until time 0.

00:21:04.870 --> 00:21:08.610
And so I know at minus infinity,
the step response was 0.

00:21:08.610 --> 00:21:11.550
And I can move
forward from there.

00:21:11.550 --> 00:21:15.180
OK, so you can actually
relate the step response

00:21:15.180 --> 00:21:17.520
to the unit sample
response the other way

00:21:17.520 --> 00:21:20.040
as well here, where
the summation is

00:21:20.040 --> 00:21:24.390
from minus infinity to the
n that you're interested in.

00:21:24.390 --> 00:21:27.885
We'll be dealing right
through with causal systems.

00:21:30.390 --> 00:21:32.980
If there are any deviations
from that, we'll point them out.

00:21:32.980 --> 00:21:36.090
But basically, we'll be
dealing with causal systems.

00:21:36.090 --> 00:21:40.530
OK, so let's-- this is an
identity we'll be wanting

00:21:40.530 --> 00:21:42.030
to play with a bit.

00:21:45.770 --> 00:21:47.110
So let me put it up here.

00:21:47.110 --> 00:21:53.380
So the step response, let's
say, for a causal system

00:21:53.380 --> 00:21:57.700
is going to be summation
from k equals minus infinity

00:21:57.700 --> 00:22:01.510
to n h of k.

00:22:01.510 --> 00:22:05.380
So I take all the values
of the unit sample response

00:22:05.380 --> 00:22:07.812
up to the present time
and sum them together

00:22:07.812 --> 00:22:10.270
to get the value of the setup
response at the present time.

00:22:13.430 --> 00:22:16.930
OK, so let's look
at an example here.

00:22:16.930 --> 00:22:23.090
Here is the unit sample response
of a particular LTI system.

00:22:23.090 --> 00:22:25.940
Is this a causal system?

00:22:31.050 --> 00:22:33.230
So this is the response
to a unit sample.

00:22:33.230 --> 00:22:37.610
So the input was 0 everywhere
except for a value of 1 here.

00:22:37.610 --> 00:22:40.100
And you see that the
response actually happens

00:22:40.100 --> 00:22:41.700
subsequent to that input.

00:22:41.700 --> 00:22:44.090
So if the response
starts at time 0

00:22:44.090 --> 00:22:47.780
or later for an input that
started at time 0 or later,

00:22:47.780 --> 00:22:51.110
then what you are looking
at is a causal system here,

00:22:51.110 --> 00:22:54.200
certainly in the case of
a unit sample response.

00:22:54.200 --> 00:22:58.220
OK, so what's the step response
going to look like, then?

00:23:04.510 --> 00:23:06.960
Anyone want to say in words?

00:23:06.960 --> 00:23:07.460
Yeah?

00:23:07.460 --> 00:23:12.810
AUDIENCE: [INAUDIBLE]

00:23:12.810 --> 00:23:14.820
PROFESSOR: OK, so
the step response,

00:23:14.820 --> 00:23:16.800
if we're evaluating
it at times over here,

00:23:16.800 --> 00:23:19.980
we're summing all the values
of hk from minus infinity

00:23:19.980 --> 00:23:21.410
up to the present time.

00:23:21.410 --> 00:23:24.240
So the step response is 0
here, is 0 here, is 0 here.

00:23:24.240 --> 00:23:25.920
And then a time 3,
the step response

00:23:25.920 --> 00:23:31.530
jumps to 1, and from
then on stays at 1.

00:23:31.530 --> 00:23:36.030
So the step response is
just that delayed step.

00:23:36.030 --> 00:23:39.750
And it kind of makes sense,
because the kind of system

00:23:39.750 --> 00:23:43.530
we're talking about must
be a delayed by 3 system

00:23:43.530 --> 00:23:51.940
here, because we put in a unit
sample input, a unit sample

00:23:51.940 --> 00:23:52.440
function.

00:23:52.440 --> 00:23:54.600
And what came out,
if you look at it,

00:23:54.600 --> 00:23:57.540
was actually delta of n minus 3.

00:23:57.540 --> 00:24:01.170
It was the unit sample
function delayed by 3 steps.

00:24:01.170 --> 00:24:03.240
Is the height-- the height
is unchanged, right?

00:24:03.240 --> 00:24:04.330
The height of still 1.

00:24:04.330 --> 00:24:07.110
So this must be a delay by
3 system we're looking at.

00:24:07.110 --> 00:24:10.430
And sure, if we put in a
unit step, we're getting--

00:24:10.430 --> 00:24:12.300
or sorry, yeah, if we
put in the unit step,

00:24:12.300 --> 00:24:13.800
we're going to get
a response that's

00:24:13.800 --> 00:24:15.600
just the step delayed by 3.

00:24:19.180 --> 00:24:20.764
I'm going-- sorry, yeah?

00:24:20.764 --> 00:24:23.134
AUDIENCE: Yeah, maybe I'm
just a little confused here.

00:24:23.134 --> 00:24:24.880
But why is it from
negative infinity

00:24:24.880 --> 00:24:27.970
to n and not like from
n to positive infinity.

00:24:27.970 --> 00:24:37.030
PROFESSOR: This is because of my
assumption assuming s of minus

00:24:37.030 --> 00:24:39.070
infinity was 0.

00:24:39.070 --> 00:24:41.650
So I need to have a
boundary condition

00:24:41.650 --> 00:24:44.410
from which I start inverting.

00:24:44.410 --> 00:24:48.470
So just to go back-- let me
just go back a second here.

00:24:48.470 --> 00:24:50.410
Oh, where am I going?

00:24:54.380 --> 00:24:58.070
OK, so we derived
this first expression.

00:24:58.070 --> 00:25:03.020
If we want to turn it around,
well, sn is hn plus sn minus 1.

00:25:03.020 --> 00:25:05.210
And then I can solve
for sn minus 1.

00:25:05.210 --> 00:25:06.890
I can keep stepping backwards.

00:25:06.890 --> 00:25:08.850
But at some point, I
need an actual value

00:25:08.850 --> 00:25:11.630
so that I can close
off that expression.

00:25:11.630 --> 00:25:14.003
And if you're talking
about a causal system,

00:25:14.003 --> 00:25:15.920
then what you're guaranteed
is that the step--

00:25:15.920 --> 00:25:19.670
if you're talking about
a causal linear system,

00:25:19.670 --> 00:25:22.550
because the all-zero input
produces the all-zero output,

00:25:22.550 --> 00:25:24.080
and it's causal,
you can actually

00:25:24.080 --> 00:25:27.890
deduce that the step response at
time minus infinity must be 0.

00:25:27.890 --> 00:25:29.100
The input hasn't yet arrived.

00:25:29.100 --> 00:25:30.433
Therefore, the output must be 0.

00:25:30.433 --> 00:25:37.380
AUDIENCE: So h of 5, does
that mean [INAUDIBLE]??

00:25:37.380 --> 00:25:40.330
PROFESSOR: H of 5
is just a number.

00:25:40.330 --> 00:25:41.880
It's not a function, right?

00:25:41.880 --> 00:25:45.370
If I write something like
h of 5, it's just a number.

00:25:45.370 --> 00:25:50.040
So it means the value of the
unit sample response at time 5.

00:25:50.040 --> 00:25:52.290
OK, this takes a
little getting used to,

00:25:52.290 --> 00:25:55.540
but let's do another
example here.

00:25:55.540 --> 00:25:57.600
So here is another
unit sample response.

00:25:57.600 --> 00:25:59.590
This is more
complicated, though.

00:25:59.590 --> 00:26:00.870
I put in a unit sample.

00:26:00.870 --> 00:26:05.670
And what comes out
is a response that--

00:26:05.670 --> 00:26:07.140
well, it still starts at time 0.

00:26:07.140 --> 00:26:09.840
So I'm talking about
a causal system.

00:26:09.840 --> 00:26:11.970
Everything to the left is 0.

00:26:11.970 --> 00:26:15.940
And the stakes a value 0.2
for some number of steps

00:26:15.940 --> 00:26:18.210
and then settles to 0.

00:26:18.210 --> 00:26:22.043
So the question then is,
what is the step response?

00:26:22.043 --> 00:26:23.460
So if you imagine
that what you're

00:26:23.460 --> 00:26:25.830
doing to find the step
response at any time

00:26:25.830 --> 00:26:29.530
is summing this from minus
infinity up to that time,

00:26:29.530 --> 00:26:31.830
you will see that
the step response

00:26:31.830 --> 00:26:35.970
is linearized like that.

00:26:35.970 --> 00:26:37.740
And then it settles out.

00:26:37.740 --> 00:26:40.688
OK, so you can get
one or the other.

00:26:40.688 --> 00:26:42.480
And there are other
examples on the slides.

00:26:42.480 --> 00:26:43.830
I won't go through all of them.

00:26:43.830 --> 00:26:45.497
I'm going a little
slow here, because we

00:26:45.497 --> 00:26:47.520
miss a recitation tomorrow.

00:26:47.520 --> 00:26:49.225
Recitations tomorrow
are office hours,

00:26:49.225 --> 00:26:52.120
so I wanted to actually
give you a few examples.

00:26:52.120 --> 00:26:56.700
Here is a case where the unit
sample response increases

00:26:56.700 --> 00:26:59.100
linearly and then stops.

00:26:59.100 --> 00:27:01.260
And so the unit step
response actually

00:27:01.260 --> 00:27:04.980
starts to accelerate
quadratically and then stops.

00:27:04.980 --> 00:27:07.763
This is the discrete time
version of integration

00:27:07.763 --> 00:27:08.680
that we're looking at.

00:27:08.680 --> 00:27:09.441
Yeah?

00:27:09.441 --> 00:27:12.267
AUDIENCE: [INAUDIBLE]

00:27:14.275 --> 00:27:15.650
PROFESSOR: Oh,
sorry, this thing?

00:27:15.650 --> 00:27:16.275
AUDIENCE: Yeah.

00:27:16.275 --> 00:27:20.030
PROFESSOR: Ah, OK,
ignore that notation.

00:27:20.030 --> 00:27:21.410
First of all, it's bad notation.

00:27:21.410 --> 00:27:23.510
But these are figures
that I got from somewhere.

00:27:23.510 --> 00:27:27.920
If I was doing it from scratch,
I wouldn't have put it in.

00:27:27.920 --> 00:27:29.630
But I'll explain it.

00:27:29.630 --> 00:27:31.830
That's the notation
for convolution.

00:27:31.830 --> 00:27:34.970
I don't actually
like that notation.

00:27:34.970 --> 00:27:37.010
OK, examples of this type--

00:27:37.010 --> 00:27:41.210
now, here is one important
thing for you to get a feel for.

00:27:41.210 --> 00:27:45.110
Notice in all these examples,
the unit sample response

00:27:45.110 --> 00:27:47.930
settles down to zero
after some time.

00:27:47.930 --> 00:27:50.930
So you hit the system with
a unit sample function

00:27:50.930 --> 00:27:51.650
at the input.

00:27:51.650 --> 00:27:55.180
So you hit it with a value 1
at time 0 and nothing else.

00:27:55.180 --> 00:27:56.060
And it responds.

00:27:56.060 --> 00:27:58.208
And it response for
a while and settles.

00:27:58.208 --> 00:27:59.750
Now, that's not true
for all systems,

00:27:59.750 --> 00:28:02.020
that they settle in finite time.

00:28:02.020 --> 00:28:05.000
A typical system might
ring indefinitely,

00:28:05.000 --> 00:28:07.880
might respond
indefinitely to a kick.

00:28:07.880 --> 00:28:09.920
Here, are all these
examples are ones

00:28:09.920 --> 00:28:14.930
where the system has a
transient and then settles down.

00:28:14.930 --> 00:28:17.135
And so what you expect to
see in the step response

00:28:17.135 --> 00:28:18.980
is there is a transient.

00:28:18.980 --> 00:28:20.480
And then it settles down.

00:28:20.480 --> 00:28:22.310
The difference is,
in the step response,

00:28:22.310 --> 00:28:23.550
it settles to another value.

00:28:23.550 --> 00:28:25.010
It doesn't come back down to 0.

00:28:25.010 --> 00:28:27.260
So when this comes
back down to zero,

00:28:27.260 --> 00:28:31.430
what this is settled up to is
sort of the integral of this.

00:28:31.430 --> 00:28:33.303
It's the area under
this, but we're

00:28:33.303 --> 00:28:35.720
talking about discrete time
functions, not continuous time

00:28:35.720 --> 00:28:36.680
functions.

00:28:36.680 --> 00:28:40.130
So the value that it's settled
to here is the area under this.

00:28:40.130 --> 00:28:43.250
So the duration of a
unit sample response

00:28:43.250 --> 00:28:46.580
gives you some feel for
how long a transient lasts.

00:28:46.580 --> 00:28:49.790
So if you've got a channel
and you hit it with an input,

00:28:49.790 --> 00:28:52.370
you know that the
transient will last about

00:28:52.370 --> 00:28:55.250
as long as the unit
sample response lasts.

00:28:55.250 --> 00:28:58.130
So the transient and the step
response shows that clearly.

00:29:01.830 --> 00:29:06.840
You can get more elaborate
sorts of unit sample responses.

00:29:06.840 --> 00:29:09.030
Here is one that changes sign.

00:29:09.030 --> 00:29:11.790
And correspondingly, what you
find with the step response

00:29:11.790 --> 00:29:14.910
is that it's not a
monotonic increase

00:29:14.910 --> 00:29:16.320
to the final steady state.

00:29:16.320 --> 00:29:17.760
There is actually
some oscillation

00:29:17.760 --> 00:29:20.210
before it settles down.

00:29:20.210 --> 00:29:21.260
But it's the same idea.

00:29:21.260 --> 00:29:23.580
You're computing
the area under this,

00:29:23.580 --> 00:29:25.380
if you like, but the
area goes positive,

00:29:25.380 --> 00:29:27.960
and then slightly
negative, and so on--

00:29:27.960 --> 00:29:30.500
well, positive and
then less positive.

00:29:30.500 --> 00:29:32.250
And so that's what
you're seeing up there.

00:29:34.860 --> 00:29:38.860
Now, why do we talk about
step responses so much?

00:29:38.860 --> 00:29:40.800
Well, it turns out
that for a lot of what

00:29:40.800 --> 00:29:44.040
we do with signaling on
communication channels,

00:29:44.040 --> 00:29:48.450
we're signaling with signals of
this type, on-off-type signals,

00:29:48.450 --> 00:29:51.750
or plus-minus signals, the sort
of square-wave-type signals

00:29:51.750 --> 00:29:54.330
or rectangular-wave signals.

00:29:54.330 --> 00:29:57.150
And these can be thought
of as combinations

00:29:57.150 --> 00:29:58.920
of unit step functions.

00:29:58.920 --> 00:30:01.400
You may have seen this in
recitation last time as well.

00:30:01.400 --> 00:30:03.330
So you can take an
input of this type

00:30:03.330 --> 00:30:06.930
and write it as a linear
combination of unit step

00:30:06.930 --> 00:30:08.340
functions.

00:30:08.340 --> 00:30:11.190
A unit step function
that has its step at 0,

00:30:11.190 --> 00:30:15.150
minus 1 that has its step at 4,
plus 1 that has its step at 12,

00:30:15.150 --> 00:30:18.700
minus 1 that has its step at 24.

00:30:18.700 --> 00:30:22.500
So if you combine those,
if you add up all of these,

00:30:22.500 --> 00:30:24.550
you're going to get that input.

00:30:24.550 --> 00:30:27.870
So then it's back
to this game again.

00:30:27.870 --> 00:30:29.760
If the input is a
linear combination

00:30:29.760 --> 00:30:34.380
of unit steps
scaled and delayed,

00:30:34.380 --> 00:30:37.780
then the response is going to
be the same combination of unit

00:30:37.780 --> 00:30:40.650
steps.

00:30:40.650 --> 00:30:42.790
So that's what the
response will look like.

00:30:42.790 --> 00:30:47.340
So here is the step
un gives rise to sn.

00:30:47.340 --> 00:30:51.142
Therefore, minus un minus
4 will give rise to minus s

00:30:51.142 --> 00:30:53.740
of n minus 4, and so on.

00:30:53.740 --> 00:30:55.770
So knowing the
step response, you

00:30:55.770 --> 00:30:58.745
can actually say what the
response of the channel

00:30:58.745 --> 00:30:59.370
is going to be.

00:31:04.040 --> 00:31:05.810
All right, we've seen
this visually too.

00:31:05.810 --> 00:31:08.210
I did an example
last time where what

00:31:08.210 --> 00:31:12.050
went in was that square
wave and what came out

00:31:12.050 --> 00:31:14.330
after we had done the
demodulation of the filtering

00:31:14.330 --> 00:31:17.600
was a response that sort of had
the features of what went in,

00:31:17.600 --> 00:31:20.400
but it was a little distorted.

00:31:20.400 --> 00:31:22.790
So you can see that what
we're looking at here,

00:31:22.790 --> 00:31:27.020
for instance, is the character
of the step response,

00:31:27.020 --> 00:31:29.420
because what went
in at this point--

00:31:29.420 --> 00:31:32.900
right now the input on
the output are at rest.

00:31:32.900 --> 00:31:35.540
You've forgotten about
what happened before.

00:31:35.540 --> 00:31:37.365
And now the input jumps up.

00:31:37.365 --> 00:31:39.740
Well, the output doesn't jump
up all the way immediately.

00:31:39.740 --> 00:31:42.482
It's got a little transient
before it settles.

00:31:42.482 --> 00:31:43.940
So what you're
looking at is really

00:31:43.940 --> 00:31:47.300
the step response of the
channel, where the channel

00:31:47.300 --> 00:31:48.890
includes all these pieces.

00:31:48.890 --> 00:31:52.610
It's everything
including the filtering.

00:31:52.610 --> 00:31:54.710
In this particular
example, if you

00:31:54.710 --> 00:31:56.360
go back and look
at those slides,

00:31:56.360 --> 00:32:00.860
this was all entirely due
to the local averaging

00:32:00.860 --> 00:32:03.050
that we were doing in
the filtering here.

00:32:03.050 --> 00:32:06.120
But it does give you some
kind of a distortion.

00:32:06.120 --> 00:32:10.670
OK, so the step response is
important to figuring out

00:32:10.670 --> 00:32:13.880
the shape of the
output of a channel.

00:32:13.880 --> 00:32:16.880
Here is another example that
has a more rounded kind of step

00:32:16.880 --> 00:32:19.460
response, but it's
still the setup response

00:32:19.460 --> 00:32:20.190
we're looking at.

00:32:20.190 --> 00:32:22.520
So here is the input step.

00:32:22.520 --> 00:32:24.950
And here is the
response to the step.

00:32:24.950 --> 00:32:26.660
Again, there is this notation.

00:32:26.660 --> 00:32:28.970
And I've said,
ignore this for now.

00:32:28.970 --> 00:32:30.110
We'll explain it shortly.

00:32:32.630 --> 00:32:35.120
OK, and once you've got the
step response at the output,

00:32:35.120 --> 00:32:36.920
you're ready to start
thinking about how

00:32:36.920 --> 00:32:40.520
you'll detect whether it
was a 0 or a 1 that went in.

00:32:40.520 --> 00:32:44.090
So you might set a threshold,
pick times at which

00:32:44.090 --> 00:32:47.060
you're going to sample.

00:32:47.060 --> 00:32:51.350
And then you come
up with your call

00:32:51.350 --> 00:32:57.280
of what the input is,
so 1, 0, 0, and so on.

00:32:57.280 --> 00:32:59.500
So this seems all benign enough.

00:32:59.500 --> 00:33:01.060
But now what if
you decide you want

00:33:01.060 --> 00:33:05.000
to get that information
across the channel faster?

00:33:05.000 --> 00:33:07.100
So you want to signal faster?

00:33:07.100 --> 00:33:08.800
So what you're
going to want to do

00:33:08.800 --> 00:33:16.440
is put that same information,
the transition from 1

00:33:16.440 --> 00:33:19.680
to 0 to 1, 1, 1,
0, 1, and so on,

00:33:19.680 --> 00:33:23.520
you want to squeeze that into
a shorter length of time.

00:33:23.520 --> 00:33:26.700
So suppose this is what you
send over that same channel.

00:33:26.700 --> 00:33:29.280
Well, now you, again, are
going to superpose the step

00:33:29.280 --> 00:33:30.533
responses.

00:33:30.533 --> 00:33:31.950
But what's happening
now is you've

00:33:31.950 --> 00:33:33.810
gotten so ambitious
with how fast you

00:33:33.810 --> 00:33:37.140
want to get the bits across
that you're not giving the step

00:33:37.140 --> 00:33:38.460
response time to settle.

00:33:38.460 --> 00:33:41.130
So over here, yes,
there is time.

00:33:41.130 --> 00:33:42.990
The step response
went up and settled

00:33:42.990 --> 00:33:45.990
because you had three
1's in a row over there.

00:33:45.990 --> 00:33:48.990
But now you're going down
to 0 for one time instant

00:33:48.990 --> 00:33:51.060
and then jumping
right back again.

00:33:51.060 --> 00:33:54.352
Well, here is the flipped
over step response.

00:33:54.352 --> 00:33:56.560
And it doesn't have time to
make it all the way down.

00:33:56.560 --> 00:33:57.990
It's jumped up again.

00:33:57.990 --> 00:34:00.960
OK, so if you get very
ambitious with your signaling

00:34:00.960 --> 00:34:04.050
to try and get more
of the bits across,

00:34:04.050 --> 00:34:06.450
you're going to start seeing
the limitations imposed

00:34:06.450 --> 00:34:07.590
by the channel.

00:34:07.590 --> 00:34:09.449
The channel can only
respond so fast.

00:34:09.449 --> 00:34:12.840
And you can drive it faster.

00:34:12.840 --> 00:34:15.370
So it's important to have
a feel for that as well.

00:34:18.250 --> 00:34:20.730
So when the channel starts
to respond like this,

00:34:20.730 --> 00:34:22.929
you become much more
susceptible to noise.

00:34:22.929 --> 00:34:25.860
So for instance, if there was
a noise spike at this point,

00:34:25.860 --> 00:34:27.850
you could well end up
with a received sample

00:34:27.850 --> 00:34:29.460
that was above the threshold.

00:34:29.460 --> 00:34:33.090
And then you'd wrongly
decode the 0 as a 1.

00:34:33.090 --> 00:34:35.340
So taking account of the
channel characteristics

00:34:35.340 --> 00:34:38.370
is important when you're
setting a signaling rate.

00:34:38.370 --> 00:34:40.500
You might want to get
information across quickly,

00:34:40.500 --> 00:34:42.719
but you have to take
account of the fact

00:34:42.719 --> 00:34:47.070
that the channel
needs some time.

00:34:47.070 --> 00:34:48.389
OK, so much for steps.

00:34:48.389 --> 00:34:50.940
We'll come back to that later.

00:34:50.940 --> 00:34:55.290
We can do the same kind of
thing with unit samples.

00:34:55.290 --> 00:34:59.230
So here is-- and in fact,
the rest of the lecture,

00:34:59.230 --> 00:35:03.360
we're going to be
talking about making up

00:35:03.360 --> 00:35:06.420
a signal as a weighted
combination of unit sample

00:35:06.420 --> 00:35:07.020
functions.

00:35:07.020 --> 00:35:09.600
So take an arbitrary
signal like this.

00:35:09.600 --> 00:35:11.940
Think of it as--

00:35:11.940 --> 00:35:16.770
let's see, this starts with
the value of something, 0.75,

00:35:16.770 --> 00:35:20.295
I guess, at time minus 2,
and then a value of minus 0.5

00:35:20.295 --> 00:35:21.980
at minus 1, and so on.

00:35:21.980 --> 00:35:24.510
So here is your input signal xn.

00:35:24.510 --> 00:35:26.250
And I want to think
of it as made up

00:35:26.250 --> 00:35:28.660
of a bunch of unit
sample functions.

00:35:28.660 --> 00:35:30.300
So what are the unit
sample functions?

00:35:30.300 --> 00:35:33.960
Well, here is one that's
centered at minus 2

00:35:33.960 --> 00:35:36.390
but scaled by the
value that the input

00:35:36.390 --> 00:35:39.150
signal has at time minus 2.

00:35:39.150 --> 00:35:42.450
Here is another one
centered at minus 1,

00:35:42.450 --> 00:35:45.100
but scaled by the value
that the input signal has

00:35:45.100 --> 00:35:47.530
at time minus 1, and so on.

00:35:47.530 --> 00:35:52.380
So what I'm basically doing
is decomposing the input

00:35:52.380 --> 00:35:57.270
into a weighted combination
of unit samples.

00:35:57.270 --> 00:35:58.540
And you can always do that.

00:35:58.540 --> 00:36:02.400
And it looks a little magical
when you put it into notation

00:36:02.400 --> 00:36:05.973
like this, but that's
basically all that it's saying.

00:36:05.973 --> 00:36:07.890
So to make sense of this,
think, for instance,

00:36:07.890 --> 00:36:10.120
of putting in an
actual number here.

00:36:10.120 --> 00:36:13.170
So if I wanted x at
time 3, well, I'm

00:36:13.170 --> 00:36:15.990
going to set n equals 3
on the right-hand side

00:36:15.990 --> 00:36:18.150
and evaluate the sum.

00:36:18.150 --> 00:36:20.280
Well, the only
value that survives

00:36:20.280 --> 00:36:23.250
is the value for
which k equals 3.

00:36:23.250 --> 00:36:25.230
So I'll pull out x3.

00:36:25.230 --> 00:36:28.830
So this kind of
seems tautologous.

00:36:28.830 --> 00:36:32.370
But it's a way to
represent a general input

00:36:32.370 --> 00:36:36.780
as a weighted combination
of delayed unit samples.

00:36:36.780 --> 00:36:41.310
OK, so if that was what went
in, you're in the position now

00:36:41.310 --> 00:36:42.540
to tell me what comes out.

00:36:46.230 --> 00:36:48.255
So I'm talking
about an LTI system.

00:36:54.620 --> 00:36:57.560
I'm talking about an LTI system.

00:36:57.560 --> 00:37:02.900
And the input xn is a
weighted combination

00:37:02.900 --> 00:37:08.453
with these weights of a bunch
of unit sample functions.

00:37:16.860 --> 00:37:19.560
Well, let's actually--
well, let me actually

00:37:19.560 --> 00:37:22.000
write this the
other way as well.

00:37:22.000 --> 00:37:25.560
Another way to say this is, here
is a time function going in.

00:37:25.560 --> 00:37:28.380
It's a weighted combination
over all possible values

00:37:28.380 --> 00:37:33.040
of k of xk times--

00:37:33.040 --> 00:37:34.830
and this is my other
notation, remember,

00:37:34.830 --> 00:37:36.550
for unit sample functions.

00:37:36.550 --> 00:37:37.800
So I'm saying this is a unit--

00:37:37.800 --> 00:37:39.420
sorry, this should
be delta sub n.

00:37:46.240 --> 00:37:47.080
What should it be?

00:37:49.930 --> 00:37:55.810
Yeah, OK, so this is another
way to write the same thing.

00:37:55.810 --> 00:37:57.290
We've chosen to
write it this way.

00:37:57.290 --> 00:37:58.850
And actually, I
find that simpler.

00:37:58.850 --> 00:38:01.060
But if you want to be
reminded that what we're

00:38:01.060 --> 00:38:03.375
talking about here is
an entire time function,

00:38:03.375 --> 00:38:05.250
then this is a notation
that you might go to.

00:38:05.250 --> 00:38:06.290
Yeah?

00:38:06.290 --> 00:38:13.480
AUDIENCE: Why is the
first sum [INAUDIBLE]

00:38:13.480 --> 00:38:14.980
PROFESSOR: OK, good question.

00:38:14.980 --> 00:38:19.750
Because I'm right now allowing
my input to have values

00:38:19.750 --> 00:38:22.220
that extend from minus
infinity to plus infinity.

00:38:22.220 --> 00:38:24.055
So I'm taking an
arbitrary function.

00:38:24.055 --> 00:38:26.020
If we're talking about
an experiment in which

00:38:26.020 --> 00:38:30.340
the input starts at time 0, then
we can actually simplify these.

00:38:30.340 --> 00:38:31.840
I'll show you that.

00:38:31.840 --> 00:38:35.680
OK, let me actually erase
this, because I don't

00:38:35.680 --> 00:38:37.400
want to confuse you with that.

00:38:37.400 --> 00:38:40.210
OK, so if this is what goes in--

00:38:40.210 --> 00:38:48.310
it's a weighted combination of
unit sample functions delayed--

00:38:48.310 --> 00:38:51.850
what is it that must come out?

00:38:51.850 --> 00:38:53.480
OK, so what are we working with?

00:38:53.480 --> 00:38:56.740
We're working with the
fact that, if delta of n

00:38:56.740 --> 00:39:00.610
goes into our system,
what comes out is hn.

00:39:03.940 --> 00:39:05.860
So if it's a
weighted combination

00:39:05.860 --> 00:39:08.530
of deltas that goes in,
what's the response, given

00:39:08.530 --> 00:39:09.910
that this is an LTI system?

00:39:16.235 --> 00:39:17.860
Someone who hasn't
spoken today, maybe?

00:39:22.690 --> 00:39:24.166
Do you want to try? yeah?

00:39:24.166 --> 00:39:25.990
AUDIENCE: [INAUDIBLE]

00:39:25.990 --> 00:39:27.860
PROFESSOR: The Same
weighted combination

00:39:27.860 --> 00:39:31.100
of those responses-- so
it's going to be summation

00:39:31.100 --> 00:39:35.080
over all k, the same weight.

00:39:35.080 --> 00:39:36.980
So it's going to be the xk's.

00:39:36.980 --> 00:39:39.470
But now here is the responses.

00:39:46.700 --> 00:39:48.360
So what have we been able to do?

00:39:48.360 --> 00:39:51.380
We've been able to write
down what the output looks

00:39:51.380 --> 00:39:58.050
like for an arbitrary input
in terms of the unit sample

00:39:58.050 --> 00:39:58.550
response.

00:39:58.550 --> 00:40:01.880
If you give me the unit sample
response for an LTI system,

00:40:01.880 --> 00:40:04.370
I can write down the general
response, the response

00:40:04.370 --> 00:40:05.330
to a general input.

00:40:09.860 --> 00:40:17.210
And this is what we refer to as
a convolution or a convolution

00:40:17.210 --> 00:40:17.710
sum.

00:40:21.100 --> 00:40:22.602
That's a convolution.

00:40:34.670 --> 00:40:35.630
It may look mysterious.

00:40:35.630 --> 00:40:38.330
So let's actually do it.

00:40:38.330 --> 00:40:43.190
Let's do it step by step again.

00:40:43.190 --> 00:40:44.255
Here is our LTI system.

00:40:47.450 --> 00:40:51.422
If I put in a unit
sample function--

00:40:55.580 --> 00:40:58.430
OK, so this is the unit
sample function going in--

00:40:58.430 --> 00:40:59.345
I get some response.

00:41:08.690 --> 00:41:10.170
And let's say this is 0.

00:41:10.170 --> 00:41:12.380
This is 1, 2, and so on.

00:41:16.520 --> 00:41:20.660
The response, we refer to as
the unit sample response hn.

00:41:20.660 --> 00:41:21.800
So what is this value?

00:41:21.800 --> 00:41:24.320
This is the value h0.

00:41:24.320 --> 00:41:27.050
This is the value h1.

00:41:27.050 --> 00:41:30.250
This is the value h2, and so on.

00:41:32.810 --> 00:41:37.670
OK, what if what
goes in is actually

00:41:37.670 --> 00:41:44.610
the value x0 at this time
and 0 everywhere else?

00:41:48.730 --> 00:41:50.230
What's the response
in that case?

00:41:54.430 --> 00:41:57.300
So this is just a scaled version
of the unit sample function.

00:41:57.300 --> 00:42:00.510
Instead of 1 going in,
I'm having x0 go in.

00:42:00.510 --> 00:42:02.190
So the response is going to be--

00:42:06.253 --> 00:42:06.920
what do we have?

00:42:10.608 --> 00:42:12.960
The same response?

00:42:12.960 --> 00:42:16.090
Twice the response?

00:42:16.090 --> 00:42:18.133
What comes out?

00:42:18.133 --> 00:42:19.888
AUDIENCE: x0 times that.

00:42:19.888 --> 00:42:20.930
PROFESSOR: I didn't hear.

00:42:20.930 --> 00:42:21.610
Where did that come from?

00:42:21.610 --> 00:42:21.930
Yeah?

00:42:21.930 --> 00:42:22.997
AUDIENCE: x0 times that.

00:42:22.997 --> 00:42:24.080
PROFESSOR: X0 times that--

00:42:24.080 --> 00:42:27.770
OK, so what we'll
get is x0 times h0

00:42:27.770 --> 00:42:30.740
coming out at the
first time, and then

00:42:30.740 --> 00:42:35.870
x0 times h1 coming out
of the second time,

00:42:35.870 --> 00:42:42.350
and then x0 h2 at the next time.

00:42:42.350 --> 00:42:55.720
And if I keep going, I get x0,
let's say, hn at this time,

00:42:55.720 --> 00:42:56.340
and so on.

00:42:59.790 --> 00:43:03.930
What happens if
now it's not that,

00:43:03.930 --> 00:43:08.790
but it's some value x1
going in at time 1 and 0

00:43:08.790 --> 00:43:09.480
everywhere else?

00:43:14.320 --> 00:43:16.750
So this is starting-- this
is centered at a time 1,

00:43:16.750 --> 00:43:18.090
not at time 0.

00:43:18.090 --> 00:43:21.135
And it's scaled by x1.

00:43:21.135 --> 00:43:23.010
So what is it I'm going
to see at the output?

00:43:25.707 --> 00:43:27.540
There was a hand somewhere
there previously.

00:43:27.540 --> 00:43:28.370
Maybe you can answer now.

00:43:28.370 --> 00:43:29.033
Yeah?

00:43:29.033 --> 00:43:31.751
AUDIENCE: The same
graph translated 1 over

00:43:31.751 --> 00:43:32.897
and scaled by x1.

00:43:32.897 --> 00:43:33.980
PROFESSOR: Right, exactly.

00:43:33.980 --> 00:43:37.040
So what's going to happen
is, nothing will happen here.

00:43:37.040 --> 00:43:53.910
I'll get x1 h0, x1 h1, and
so on, x1 h of n minus 1.

00:43:53.910 --> 00:43:54.960
And it keeps going.

00:43:58.380 --> 00:44:01.500
And you keep going here as well.

00:44:01.500 --> 00:44:04.626
You keep stringing in these.

00:44:04.626 --> 00:44:07.620
Each one of these will fire
off a scale of the unit sample

00:44:07.620 --> 00:44:10.570
response, but delayed
appropriately.

00:44:10.570 --> 00:44:13.770
And so at the next time,
what you're going to get here

00:44:13.770 --> 00:44:18.780
is x2 h of n minus 2.

00:44:18.780 --> 00:44:19.740
And it keeps going.

00:44:23.210 --> 00:44:26.900
And what if you're interested
in the value at time n?

00:44:26.900 --> 00:44:28.460
OK, so you look along here.

00:44:28.460 --> 00:44:32.300
And you've come to
the value of time n.

00:44:32.300 --> 00:44:34.550
So it's going to be the
sum of all of these,

00:44:34.550 --> 00:44:37.460
if your input is the sum
of all of these, right?

00:44:37.460 --> 00:44:40.730
If your input is the sum of
all of these x's, your response

00:44:40.730 --> 00:44:43.063
is going to be the
sum of all of these.

00:44:43.063 --> 00:44:44.480
So what's the sum
of all of these?

00:44:44.480 --> 00:44:49.497
Well, xk h of n minus k.

00:44:49.497 --> 00:44:50.330
That's all there is.

00:44:50.330 --> 00:44:52.205
There is nothing-- there
is no magic to this.

00:44:52.205 --> 00:44:54.800
It's just invoking linearity--

00:44:54.800 --> 00:44:56.690
that's the scaling part of it--

00:44:56.690 --> 00:44:59.030
and time invariance, which
is the delaying part of it.

00:45:02.830 --> 00:45:05.240
It's as simple as that.

00:45:05.240 --> 00:45:07.720
All right, so we'll be
seeing this notation a lot.

00:45:07.720 --> 00:45:10.480
You probably recognize
this kind of notation

00:45:10.480 --> 00:45:12.460
from the convolutional
coder as well.

00:45:16.280 --> 00:45:18.160
And we don't want to
keep writing these sums.

00:45:18.160 --> 00:45:19.720
So here is the
notation that we use.

00:45:19.720 --> 00:45:24.250
We say that x is
convolved with h.

00:45:24.250 --> 00:45:28.090
And we are interested
in the value at time n.

00:45:28.090 --> 00:45:31.300
So this operation of--

00:45:31.300 --> 00:45:35.330
this summation here is referred
to as a convolution, as I said.

00:45:35.330 --> 00:45:38.830
I'm telling you what value
of time I'm interested

00:45:38.830 --> 00:45:39.700
and the response at.

00:45:39.700 --> 00:45:40.810
That's the n.

00:45:40.810 --> 00:45:44.010
So that's what this notation is.

00:45:44.010 --> 00:45:46.083
The k here is just
a dummy index.

00:45:46.083 --> 00:45:47.125
We're summing over the k.

00:45:47.125 --> 00:45:48.583
It doesn't matter
what I called it.

00:45:48.583 --> 00:45:49.620
I can call it j.

00:45:49.620 --> 00:45:50.340
I can call it l.

00:45:50.340 --> 00:45:51.340
It doesn't matter.

00:45:51.340 --> 00:45:54.450
The important thing is this
n here tells me at what time

00:45:54.450 --> 00:45:56.730
I'm looking for the response.

00:45:56.730 --> 00:45:59.370
And that's why that's the
argument that I stick in here.

00:46:05.080 --> 00:46:06.910
All right, so all
that's on the slides,

00:46:06.910 --> 00:46:09.760
but we've actually
derived it ourselves here.

00:46:14.270 --> 00:46:21.590
Now, again, some
gripes about notation--

00:46:21.590 --> 00:46:24.260
you'll find, if you look in
most engineering textbooks,

00:46:24.260 --> 00:46:32.030
that this would be
written xn star hn.

00:46:32.030 --> 00:46:34.370
And I can't tell you how
much I detest that notation.

00:46:34.370 --> 00:46:38.360
You'll never find
it in a math book.

00:46:38.360 --> 00:46:40.610
The problem here is
that this n is being

00:46:40.610 --> 00:46:42.260
asked to do too many things.

00:46:42.260 --> 00:46:45.080
The n is supposed to suggest--

00:46:45.080 --> 00:46:46.580
the xn here is
supposed to suggest

00:46:46.580 --> 00:46:49.190
we're interested in the
whole time function.

00:46:49.190 --> 00:46:50.930
You would have been
better off calling it

00:46:50.930 --> 00:46:54.320
x dot, but, OK, we're
used to thinking of xn

00:46:54.320 --> 00:46:56.720
as also denoting an
entire time function.

00:46:56.720 --> 00:46:59.210
This h is supposed-- the h
of n is supposed to denote

00:46:59.210 --> 00:47:00.920
an entire time function.

00:47:00.920 --> 00:47:03.260
But the n is also supposed
to tell you at what time

00:47:03.260 --> 00:47:04.980
you're interested
in the response.

00:47:04.980 --> 00:47:07.940
So that index is just
doing too much work.

00:47:07.940 --> 00:47:13.230
And it ends up being confused
and confusing notation.

00:47:13.230 --> 00:47:17.228
So when you're in your
downstream classes from here,

00:47:17.228 --> 00:47:18.770
if you find an
instructor using that,

00:47:18.770 --> 00:47:20.767
make sure that you
give him or her

00:47:20.767 --> 00:47:22.850
grief and say you really
can't make sense of that,

00:47:22.850 --> 00:47:25.910
because this is much
cleaner notation.

00:47:25.910 --> 00:47:30.260
This is what conveys
what's actually going on.

00:47:30.260 --> 00:47:38.500
All right, I'm going to
skip over a few things.

00:47:38.500 --> 00:47:42.460
I just want to suggest
some properties here.

00:47:42.460 --> 00:47:46.300
And then we'll come back
to more of this next time.

00:47:50.090 --> 00:47:52.130
OK, so it turns out
that convolution

00:47:52.130 --> 00:47:54.260
has nice properties.

00:47:54.260 --> 00:47:56.910
For instance, the
order doesn't matter.

00:47:56.910 --> 00:48:02.090
You can write x star h here,
but it's the same as h star x.

00:48:02.090 --> 00:48:05.120
And that just comes from making
a change of variables in here.

00:48:05.120 --> 00:48:11.690
If I call this m, then
k is equal to n minus m.

00:48:11.690 --> 00:48:15.478
And I get something
that looks different.

00:48:15.478 --> 00:48:16.770
But it's really the same thing.

00:48:16.770 --> 00:48:18.410
So this is the same as h star x.

00:48:22.000 --> 00:48:24.435
So convolution, you
can interchange orders.

00:48:24.435 --> 00:48:25.810
There is some
conditions on this,

00:48:25.810 --> 00:48:28.070
but we can talk
about them later.

00:48:28.070 --> 00:48:29.140
You can associate them.

00:48:29.140 --> 00:48:31.000
You can group them arbitrarily.

00:48:31.000 --> 00:48:32.650
And you can
distribute convolution

00:48:32.650 --> 00:48:34.460
over additional functions.

00:48:34.460 --> 00:48:36.735
So all of this
actually makes it--

00:48:36.735 --> 00:48:38.110
this is very
powerful, because it

00:48:38.110 --> 00:48:41.612
allows you to deal with
combinations of systems.

00:48:41.612 --> 00:48:43.070
And I'll just give
you one example.

00:48:43.070 --> 00:48:45.100
And then we'll quit.

00:48:45.100 --> 00:48:49.400
So here is an example of the
kind of thing you can do.

00:48:49.400 --> 00:48:53.350
Suppose you have an input
going into one system, LTI,

00:48:53.350 --> 00:48:56.440
with a unit sample
response h1, and then

00:48:56.440 --> 00:48:59.680
the output of that going into
a second system, LTI with unit

00:48:59.680 --> 00:49:04.870
sample response h2, and then
producing an overall output yn.

00:49:04.870 --> 00:49:07.060
Well, so how do you get y?

00:49:07.060 --> 00:49:09.370
It's h2 convolved with w.

00:49:09.370 --> 00:49:11.320
I've dropped the
argument n because I

00:49:11.320 --> 00:49:14.230
want to do this just
for general values.

00:49:14.230 --> 00:49:18.940
But w itself is h1
convolved with x.

00:49:18.940 --> 00:49:20.780
Now, I can group
these any way I want.

00:49:20.780 --> 00:49:23.620
So I can, because
convolution is associative,

00:49:23.620 --> 00:49:25.700
I can put those
parentheses where I want.

00:49:25.700 --> 00:49:29.020
So this is equal to the
expression at the end.

00:49:29.020 --> 00:49:30.640
But that's the
same result I'd get

00:49:30.640 --> 00:49:35.530
by putting this input into
a single LTI system whose

00:49:35.530 --> 00:49:38.140
unit sample response was
the convolution of the two

00:49:38.140 --> 00:49:39.280
individual ones.

00:49:39.280 --> 00:49:43.450
So I can start to collapse two
systems into one equivalent LTI

00:49:43.450 --> 00:49:44.230
system.

00:49:44.230 --> 00:49:47.080
And that kind of thing
ends up being powerful.

00:49:47.080 --> 00:49:49.040
But I can also
interchange orders.

00:49:49.040 --> 00:49:52.180
So from here, you can go to
this, which then tells you

00:49:52.180 --> 00:49:56.260
that, for an LTI system, if
you've got systems in cascade,

00:49:56.260 --> 00:49:59.080
if you've got two LTI
systems in cascade, actually,

00:49:59.080 --> 00:50:02.140
the effect on the output
is the same, whatever

00:50:02.140 --> 00:50:03.160
order the input--

00:50:03.160 --> 00:50:05.620
the systems are connected in.

00:50:05.620 --> 00:50:08.080
You might ask yourself whether
the same is true if this

00:50:08.080 --> 00:50:11.380
was linear but time varying.

00:50:11.380 --> 00:50:13.270
And you should
hopefully find out

00:50:13.270 --> 00:50:15.820
that, in general, for linear
but time-varying systems,

00:50:15.820 --> 00:50:16.570
you can't do this.

00:50:16.570 --> 00:50:19.000
So really, linearity
and time invariance

00:50:19.000 --> 00:50:22.120
is what it takes to be
able to attain this.

00:50:22.120 --> 00:50:23.720
OK, let's leave it
at this for now.

00:50:23.720 --> 00:50:25.360
And we'll pick up again--

00:50:25.360 --> 00:50:28.240
well, you pick up some in
problem set four and also

00:50:28.240 --> 00:50:30.060
next week.