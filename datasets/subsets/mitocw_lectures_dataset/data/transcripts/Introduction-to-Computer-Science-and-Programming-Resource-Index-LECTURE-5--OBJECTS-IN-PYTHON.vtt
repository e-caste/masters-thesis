WEBVTT

00:00:00.040 --> 00:00:02.460
The following content is
provided under a Creative

00:00:02.460 --> 00:00:03.870
Commons license.

00:00:03.870 --> 00:00:06.910
Your support will help MIT
OpenCourseWare continue to

00:00:06.910 --> 00:00:10.560
offer high quality educational
resources for free.

00:00:10.560 --> 00:00:13.460
To make a donation or view
additional materials from

00:00:13.460 --> 00:00:19.290
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:19.290 --> 00:00:21.421
ocw.mit.edu.

00:00:21.421 --> 00:00:24.970
PROFESSOR: Happy Valentine's
Day 11.

00:00:24.970 --> 00:00:26.850
Actually, maybe it's a
little smiley face

00:00:26.850 --> 00:00:28.530
combined with an 11.

00:00:28.530 --> 00:00:30.310
Did any of you leave
this here for me?

00:00:30.310 --> 00:00:33.480
Or am I just stroking
my ego and this was

00:00:33.480 --> 00:00:36.380
left for someone yesterday?

00:00:36.380 --> 00:00:40.050
Stroking my ego, all right.

00:00:40.050 --> 00:00:47.350
OK, last lecture, we looked at
a program for finding roots

00:00:47.350 --> 00:00:50.610
and put in a little debugging
statement that, along the way,

00:00:50.610 --> 00:00:54.960
printed various approximations
to the root.

00:00:54.960 --> 00:00:59.400
Now, suppose that instead of
printing things, we actually

00:00:59.400 --> 00:01:02.770
wanted to collect the
approximations.

00:01:02.770 --> 00:01:05.800
For example, to be able to go
back and look at them later

00:01:05.800 --> 00:01:09.820
and analyze them, do various
kinds of things.

00:01:09.820 --> 00:01:13.580
To do this, and this is the sort
of thing we do a lot, we

00:01:13.580 --> 00:01:17.660
need some data structures that
can be used for amassing

00:01:17.660 --> 00:01:20.560
collections of items.

00:01:20.560 --> 00:01:26.520
There are 3 data structures
in Python that are used to

00:01:26.520 --> 00:01:28.150
collect items.

00:01:28.150 --> 00:01:30.130
I'm going to try and cover
all of them today.

00:01:33.050 --> 00:01:38.306
Tuples, lists, and
dictionaries.

00:01:49.270 --> 00:01:52.870
We'll start with tuples
and lists.

00:01:52.870 --> 00:02:02.610
And what they have in common is
they are ordered sequences

00:02:02.610 --> 00:02:03.860
of objects.

00:02:11.840 --> 00:02:14.750
So the key notion here
is they're ordered.

00:02:14.750 --> 00:02:18.400
It makes sense to talk about the
first object, the second

00:02:18.400 --> 00:02:21.660
object, the last object,
et cetera.

00:02:21.660 --> 00:02:25.380
When we get to dictionaries, or
dicts as they're spelled in

00:02:25.380 --> 00:02:29.200
Python, we'll see that
they're not ordered.

00:02:29.200 --> 00:02:31.030
All right, let's look
at tuples first.

00:02:31.030 --> 00:02:32.280
They're the simplest.

00:02:34.540 --> 00:02:45.700
So if we look at it, there's
a very simple

00:02:45.700 --> 00:02:47.500
example at the top.

00:02:47.500 --> 00:02:50.150
I have this tuple called test.

00:02:50.150 --> 00:02:52.220
And I just said that's
the sequence of

00:02:52.220 --> 00:02:56.210
ints 1, 2, 3, 4, 5.

00:02:56.210 --> 00:02:58.670
I can then index into it.

00:02:58.670 --> 00:03:01.110
For example, look at
the first element,

00:03:01.110 --> 00:03:04.540
which is the 0th element.

00:03:04.540 --> 00:03:07.940
Or I could look at
the next element.

00:03:07.940 --> 00:03:08.850
And we can print them.

00:03:08.850 --> 00:03:10.100
So let's just do that.

00:03:13.030 --> 00:03:18.940
And you can see it prints 1
and 2, not surprisingly.

00:03:18.940 --> 00:03:20.760
I can print the whole
thing if I want.

00:03:25.330 --> 00:03:30.950
That lets me look at
the entire tuple.

00:03:30.950 --> 00:03:32.495
I can also look at this.

00:03:38.660 --> 00:03:42.300
And that gives me the last
element without my having to

00:03:42.300 --> 00:03:46.010
know what the last element is.

00:03:46.010 --> 00:03:47.910
I can ask about the
length of a tuple.

00:03:53.120 --> 00:03:54.370
And it tells me it's five.

00:03:57.820 --> 00:03:59.880
Similarly, I could write
something like this.

00:04:04.800 --> 00:04:06.050
Print test.

00:04:15.500 --> 00:04:16.990
Why was that out of range?

00:04:21.757 --> 00:04:22.743
Yeah?

00:04:22.743 --> 00:04:24.495
AUDIENCE: Because you're
indexing from 0?

00:04:24.495 --> 00:04:26.510
PROFESSOR: Because I'm
indexing from 0.

00:04:26.510 --> 00:04:29.780
So that's why I have this
more convenient way of

00:04:29.780 --> 00:04:31.780
writing minus 1.

00:04:31.780 --> 00:04:34.160
Otherwise, I'd have to
do len minus one.

00:04:34.160 --> 00:04:37.170
Good grab.

00:04:37.170 --> 00:04:42.320
OK, let's look at a little
example of how we might use

00:04:42.320 --> 00:04:43.570
this sort of thing.

00:04:52.270 --> 00:04:55.310
So here, I've just written a
little piece of code that

00:04:55.310 --> 00:04:56.560
finds divisors.

00:05:03.000 --> 00:05:07.040
Going to find all of the divisor
of 100, collect them

00:05:07.040 --> 00:05:09.990
into a tuple.

00:05:09.990 --> 00:05:23.930
Notice this kind of funny piece
of syntax here, i comma.

00:05:23.930 --> 00:05:28.170
I need to do that to say it's
a tuple of length one.

00:05:31.290 --> 00:05:36.870
Why can't I just write open
paren, i, comma, open paren?

00:05:36.870 --> 00:05:40.640
Because that would just take
the expression, i, and

00:05:40.640 --> 00:05:44.800
parenthesize it as we often use
parentheses for grouping

00:05:44.800 --> 00:05:47.470
when we write things.

00:05:47.470 --> 00:05:51.790
So by inserting this comma, I
say, I don't just mean the--

00:05:51.790 --> 00:05:54.510
in this case-- say
the number i.

00:05:54.510 --> 00:05:57.950
I mean the tuple
of length one.

00:05:57.950 --> 00:06:02.130
So it's sort of a special case
piece of syntax that you need

00:06:02.130 --> 00:06:04.050
for tuples of length one.

00:06:04.050 --> 00:06:06.490
Then, I can print
the divisors.

00:06:06.490 --> 00:06:07.740
So let's run that.

00:06:11.800 --> 00:06:14.340
And it now prints the
tuple for me.

00:06:14.340 --> 00:06:15.370
So I've run through.

00:06:15.370 --> 00:06:16.860
I've computed all
the divisors.

00:06:16.860 --> 00:06:18.110
And I've collected them.

00:06:21.890 --> 00:06:26.200
Nothing very interesting,
but kind of useful.

00:06:26.200 --> 00:06:27.660
We can also--

00:06:27.660 --> 00:06:31.420
I've shown you how to select
elements of tuples.

00:06:31.420 --> 00:06:35.670
I can also, if I choose,
get what are

00:06:35.670 --> 00:06:37.210
called slices of tuples.

00:06:44.370 --> 00:06:51.100
So a slice gives me a range of
values, or in this case, a

00:06:51.100 --> 00:06:57.100
subsequence of the tuple.

00:06:57.100 --> 00:06:59.400
As we'll see, we can
also slice lists.

00:07:11.540 --> 00:07:12.370
So let's see.

00:07:12.370 --> 00:07:14.425
We have a tuple called
divisors here.

00:07:19.640 --> 00:07:21.620
Yeah, OK, I'll save
the source.

00:07:21.620 --> 00:07:22.870
Oh, come on!

00:07:33.010 --> 00:07:35.660
So if I wanted to do--

00:07:35.660 --> 00:07:36.210
what did I call it?

00:07:36.210 --> 00:07:37.460
I called it divisors.

00:07:40.040 --> 00:07:44.760
So I can do something
like divisors 1:3.

00:07:48.380 --> 00:07:53.680
And you'll note that gives me
those two elements at the

00:07:53.680 --> 00:07:56.620
appropriate places.

00:07:56.620 --> 00:08:00.320
And so it's a very convenient
way to take pieces of it.

00:08:04.280 --> 00:08:08.710
All right, any questions
about tuples?

00:08:08.710 --> 00:08:10.400
Not very deep.

00:08:10.400 --> 00:08:17.600
Lists are, I think, more useful
than tuples and also,

00:08:17.600 --> 00:08:20.850
alas, more complicated.

00:08:20.850 --> 00:08:25.440
And they're complicated because
the big difference is

00:08:25.440 --> 00:08:32.679
that tuples are immutable.

00:08:32.679 --> 00:08:37.840
And by that, I mean once you've
created a tuple, you

00:08:37.840 --> 00:08:41.409
cannot change its value.

00:08:41.409 --> 00:08:44.070
You can create a new tuple.

00:08:44.070 --> 00:08:48.140
but you can't change the
value of the old tuple.

00:08:48.140 --> 00:08:54.920
In contrast, lists
are mutable.

00:08:54.920 --> 00:08:59.650
Once you've created a list, you
can actually change it.

00:08:59.650 --> 00:09:04.340
It's the first mutable type
we've looked at because you'll

00:09:04.340 --> 00:09:08.570
recall assignment didn't
actually change

00:09:08.570 --> 00:09:10.550
the value of an object.

00:09:10.550 --> 00:09:16.780
It just changed the object to
which an identifier was bound.

00:09:16.780 --> 00:09:21.470
Mutability is the first time
we've seen a way to actually

00:09:21.470 --> 00:09:24.520
change the value of
an object itself.

00:09:27.380 --> 00:09:34.050
And that's, as we'll see, both
a powerful concept and an

00:09:34.050 --> 00:09:38.660
opportunity to mess yourself
up by committing serious

00:09:38.660 --> 00:09:39.910
programming blunders.

00:09:42.470 --> 00:09:48.530
All right, so let's look at an
example here, first of many

00:09:48.530 --> 00:09:49.780
we'll be looking at.

00:09:53.490 --> 00:09:56.620
So first, we won't worry too
much about the mutability.

00:10:02.190 --> 00:10:09.250
So here, I'm creating a list
called techs, which happens to

00:10:09.250 --> 00:10:12.320
be, in this case, a
list of strings.

00:10:12.320 --> 00:10:14.990
Lists need not be homogeneous.

00:10:14.990 --> 00:10:18.420
As we'll see, you can mix
strings, and floats, and ints.

00:10:18.420 --> 00:10:22.860
And most interestingly, you
can have lists of list.

00:10:22.860 --> 00:10:24.870
And then, another list
called ivies.

00:10:27.590 --> 00:10:31.390
And then, I'm going to say I'm
going to have these univs, yet

00:10:31.390 --> 00:10:32.170
another list.

00:10:32.170 --> 00:10:34.350
This list empty, containing
no elements.

00:10:36.960 --> 00:10:43.380
Then, I'm going to append
techs to ivies.

00:10:43.380 --> 00:10:45.020
Notice this syntax--

00:10:45.020 --> 00:10:46.270
univs.append.

00:10:49.300 --> 00:10:57.250
What that means here is
that append is what

00:10:57.250 --> 00:10:59.085
Python calls a method.

00:11:04.610 --> 00:11:09.260
As we'll see when we get to
classes, methods play a very

00:11:09.260 --> 00:11:12.430
important role in Python.

00:11:12.430 --> 00:11:17.220
But to a first approximation,
it's quite safe to think of a

00:11:17.220 --> 00:11:21.600
method as an alternative syntax
for writing function.

00:11:24.240 --> 00:11:32.620
So instead of writing something
like append a list

00:11:32.620 --> 00:11:46.140
and an element, I write
l.append the element.

00:11:46.140 --> 00:11:50.990
And just think of this l over
here as a fancy way of

00:11:50.990 --> 00:11:55.170
denoting the first argument to
the function append, the first

00:11:55.170 --> 00:11:57.020
actual parameter.

00:11:57.020 --> 00:12:02.210
When we get to classes in a few
weeks, we'll see why it's

00:12:02.210 --> 00:12:06.170
highly useful to have this
specialized syntax.

00:12:06.170 --> 00:12:10.520
But for now, just think of it as
a piece of syntactic sugar,

00:12:10.520 --> 00:12:11.770
if you will.

00:12:13.910 --> 00:12:19.320
The thing I want you to think
about, though, is this is not

00:12:19.320 --> 00:12:23.010
equivalent to assigning
something to l.

00:12:23.010 --> 00:12:25.615
This actually mutates
the list.

00:12:35.340 --> 00:12:38.060
And we say it has
a side effect.

00:12:44.400 --> 00:12:47.550
Up till now, since we've only
been dealing with immutable

00:12:47.550 --> 00:12:54.365
types, every function we've
looked at, its job was to take

00:12:54.365 --> 00:12:59.330
in a bunch of values, do some
computation, return a value.

00:12:59.330 --> 00:13:01.600
It didn't change anything.

00:13:01.600 --> 00:13:04.650
And then, if we wanted to take
advantage of what the function

00:13:04.650 --> 00:13:08.590
did, we had to assign the value
it returned to some

00:13:08.590 --> 00:13:11.010
variable, and then we
could manipulate it.

00:13:11.010 --> 00:13:13.330
Or we could print the
value it returned.

00:13:13.330 --> 00:13:16.990
We had to do something with
the value it returned.

00:13:16.990 --> 00:13:21.120
Here, we invoke append.

00:13:21.120 --> 00:13:25.920
And rather than worrying about
what it returns, we're

00:13:25.920 --> 00:13:29.740
invoking it for the purpose
of its side effect--

00:13:29.740 --> 00:13:35.460
the modification it performs
on the list.

00:13:35.460 --> 00:13:37.570
So let's look at what we
get when we run this.

00:13:44.000 --> 00:13:47.610
So you'll notice what
univs is now.

00:13:47.610 --> 00:13:52.250
It's a list of length one.

00:13:52.250 --> 00:13:57.890
And the one element in it is
itself a list because I have

00:13:57.890 --> 00:14:02.820
appended a list to the end
of the empty list--

00:14:02.820 --> 00:14:08.340
not the elements of the list,
but the list itself, OK?

00:14:08.340 --> 00:14:12.200
So it's important to notice the
difference between a list

00:14:12.200 --> 00:14:18.170
that contained the elements MIT
and Cal Tech, and a list

00:14:18.170 --> 00:14:20.850
that contained a list
which contains the

00:14:20.850 --> 00:14:23.215
elements MIT and Cal Tech.

00:14:30.900 --> 00:14:32.294
Yes?

00:14:32.294 --> 00:14:36.760
AUDIENCE: Previously, you added
two tuples together.

00:14:36.760 --> 00:14:41.470
And that's not like
appending, right?

00:14:41.470 --> 00:14:45.770
PROFESSOR: Because when I
concatenated two tuples, in

00:14:45.770 --> 00:14:48.670
order to do something useful
with that value, I had to

00:14:48.670 --> 00:14:50.620
assign it to something.

00:14:50.620 --> 00:14:53.830
It did not modify anything.

00:14:53.830 --> 00:14:56.800
It produced a new tuple
which was the value

00:14:56.800 --> 00:14:59.040
of appending them.

00:14:59.040 --> 00:15:01.100
And then, it assigned
it to a new tuple.

00:15:01.100 --> 00:15:05.850
So it's quite different from
append, which is actually

00:15:05.850 --> 00:15:08.650
having a side effect
on the list.

00:15:08.650 --> 00:15:13.290
Does not produce a new list,
it modifies the old list.

00:15:13.290 --> 00:15:19.530
So we can look at this, draw
a little picture here.

00:15:19.530 --> 00:15:20.780
So we had techs.

00:15:25.190 --> 00:15:31.000
And that pointed to a list with
two elements in it, which

00:15:31.000 --> 00:15:33.990
I'll abbreviated as
MIT and Cal Tech.

00:15:33.990 --> 00:15:35.625
Both of these elements
were strings.

00:15:40.190 --> 00:15:44.285
Then, I created a new
list called univs.

00:15:47.450 --> 00:15:54.860
And that was initially bound to
the empty list, a list with

00:15:54.860 --> 00:15:56.110
no elements in it.

00:15:58.420 --> 00:16:01.010
I then did an append.

00:16:01.010 --> 00:16:05.220
And the effect of the
append was to modify

00:16:05.220 --> 00:16:07.340
univs so that it pointed--

00:16:10.520 --> 00:16:12.280
now, I had one element.

00:16:12.280 --> 00:16:16.430
And the element it was
was this list.

00:16:16.430 --> 00:16:19.160
Notice it didn't
copy this list.

00:16:19.160 --> 00:16:22.720
It actually included
the list itself.

00:16:26.490 --> 00:16:29.150
So let's look at the
ramifications of

00:16:29.150 --> 00:16:30.400
doing it that way.

00:16:38.960 --> 00:16:40.210
Whoops.

00:16:43.950 --> 00:16:46.810
So what I'm going to do
now is append another

00:16:46.810 --> 00:16:49.770
element called ivies.

00:16:49.770 --> 00:16:52.820
I'm going to then print it.

00:16:52.820 --> 00:16:56.470
And then, for e in univs-- so
here's kind of a nice thing

00:16:56.470 --> 00:16:57.720
you can do with lists.

00:17:01.860 --> 00:17:05.670
You can iterate over the
elements in the list.

00:17:05.670 --> 00:17:08.849
So you might think that the way
to do that is, well, I'll

00:17:08.849 --> 00:17:13.780
go for i index in range
0 to length of list.

00:17:13.780 --> 00:17:15.450
That would be equivalent.

00:17:15.450 --> 00:17:18.349
But it's, in fact, much easier
to just write this way--

00:17:18.349 --> 00:17:20.500
for e in univs.

00:17:20.500 --> 00:17:23.890
That will do something to every
element of the list.

00:17:23.890 --> 00:17:26.400
I'm going to print what
the element is.

00:17:26.400 --> 00:17:27.650
So let's look at that.

00:17:36.370 --> 00:17:43.550
So now, I have a list, as we
see here, of length two.

00:17:43.550 --> 00:17:45.660
It contains two lists.

00:17:45.660 --> 00:17:49.930
And if I print the elements, I
print each of those lists.

00:17:49.930 --> 00:17:51.795
Nothing very magical there.

00:17:56.190 --> 00:18:02.520
Now, suppose I wanted
it flattened.

00:18:02.520 --> 00:18:04.800
You asked the question about
the tuples where I did

00:18:04.800 --> 00:18:06.150
concatenation.

00:18:06.150 --> 00:18:07.905
Well, I can do the
same thing here.

00:18:11.650 --> 00:18:16.050
I'll let flat equal
techs plus ivies.

00:18:16.050 --> 00:18:17.300
And then, I'll print flat.

00:18:23.620 --> 00:18:29.110
And you'll note here what
concatenation does is it just

00:18:29.110 --> 00:18:34.180
takes the elements of the list
and creates a new list and

00:18:34.180 --> 00:18:35.430
appends it.

00:18:37.690 --> 00:18:39.900
Not append it-- in this
case, it assigns it to

00:18:39.900 --> 00:18:42.650
flat, excuse me.

00:18:42.650 --> 00:18:44.970
So that's convenient.

00:18:44.970 --> 00:18:49.410
Poor old plus is overloaded
with yet another meaning.

00:18:49.410 --> 00:18:51.430
All right, let's keep
on trucking.

00:19:06.460 --> 00:19:08.300
I, of course, can
do this myself.

00:19:08.300 --> 00:19:11.010
So here, I've got another
list called artSchools.

00:19:11.010 --> 00:19:13.630
It includes RISD and Harvard.

00:19:13.630 --> 00:19:18.310
For u2 in artSchools, if u2 in
flat, I'm going to remove it.

00:19:24.190 --> 00:19:26.680
All right, so again, I'm going
to iterate over everything in

00:19:26.680 --> 00:19:27.930
artSchools.

00:19:29.560 --> 00:19:31.045
What's this going to
do, do you think?

00:19:35.410 --> 00:19:37.840
What will I get when
I print it here?

00:19:40.970 --> 00:19:42.180
No new concepts here.

00:19:42.180 --> 00:19:45.680
This is all stuff we've seen.

00:19:45.680 --> 00:19:46.540
Somebody up there?

00:19:46.540 --> 00:19:47.922
Yeah.

00:19:47.922 --> 00:19:49.275
AUDIENCE: Flat without
Harvard in it?

00:19:49.275 --> 00:19:51.710
PROFESSOR: Yes.

00:19:51.710 --> 00:19:54.160
The correct answer was flat
without Harvard in it.

00:19:57.630 --> 00:20:01.920
Wow, almost a good catch.

00:20:01.920 --> 00:20:03.370
Just almost there.

00:20:03.370 --> 00:20:07.310
All right, so let's confirm.

00:20:07.310 --> 00:20:08.220
Yes, we'll save it.

00:20:08.220 --> 00:20:09.470
Thank you.

00:20:13.500 --> 00:20:16.715
All right, so we've now removed
the art school.

00:20:21.640 --> 00:20:24.620
All right, we'll look
at one more thing.

00:20:24.620 --> 00:20:26.790
Actually, we'll look at far
more than one more thing.

00:20:26.790 --> 00:20:30.235
But we'll look at one more
thing for the moment.

00:20:37.420 --> 00:20:39.790
So I'm going to invoke
another method.

00:20:39.790 --> 00:20:42.020
This is a built-in method
of Python that

00:20:42.020 --> 00:20:46.490
works on sequence types.

00:20:46.490 --> 00:20:49.330
And it's called sort.

00:20:49.330 --> 00:20:52.175
So you can do-- this will have
a side effect on flat.

00:20:55.220 --> 00:20:59.440
And it will, as you might guess,
put them in order.

00:20:59.440 --> 00:21:01.642
So let's run that.

00:21:01.642 --> 00:21:03.480
Actually, we'll comment this
out for the moment.

00:21:11.440 --> 00:21:13.600
So you'll now note that
it's put them in

00:21:13.600 --> 00:21:14.890
alphabetical order.

00:21:18.670 --> 00:21:21.020
This is something, again, that
you'll find convenient

00:21:21.020 --> 00:21:24.170
throughout the term, the ability
to have the side

00:21:24.170 --> 00:21:25.770
effect of sorting a list.

00:21:35.320 --> 00:21:43.475
Now, I'm going to assign
something to flat sub 1.

00:21:46.510 --> 00:21:51.010
So let's think about what this
is going to be doing.

00:21:51.010 --> 00:21:55.840
It's going to replace
the first element of

00:21:55.840 --> 00:21:58.155
flat by a new value.

00:22:01.770 --> 00:22:07.740
So it's having, again, a
side effect on flat.

00:22:07.740 --> 00:22:10.430
So you have to be a little bit
careful as you think about

00:22:10.430 --> 00:22:14.580
this, that I've written
something that looks like a

00:22:14.580 --> 00:22:17.370
conventional assignment
statement.

00:22:17.370 --> 00:22:21.190
But in fact, flat sub 1
is not an identifier.

00:22:23.800 --> 00:22:29.780
So this is not binding the name,
flat sub 1, To UMass.

00:22:29.780 --> 00:22:34.730
It's actually modifying the
object that is the first

00:22:34.730 --> 00:22:36.072
element of flat.

00:22:41.740 --> 00:22:44.800
AUDIENCE: So would an identifier
just be a name,

00:22:44.800 --> 00:22:47.178
flat, for example?

00:22:47.178 --> 00:22:49.160
PROFESSOR: Well, I
think the way--

00:22:49.160 --> 00:22:55.160
the question is, would the
identifier just be "flat?" No.

00:22:55.160 --> 00:22:58.450
Don't think of this as
an assignment at all.

00:22:58.450 --> 00:23:02.410
Because remember, what an
assignment does is swing one

00:23:02.410 --> 00:23:06.190
of these pointers to point
to a different object.

00:23:06.190 --> 00:23:08.170
We'll see an example of that.

00:23:08.170 --> 00:23:13.010
Whereas here, I'm actually
modifying a piece of the

00:23:13.010 --> 00:23:18.490
object that the identifier
points to.

00:23:18.490 --> 00:23:23.230
So it's not an assignment in
the sense of a re-binding.

00:23:23.230 --> 00:23:25.560
It's actually having
a side effect of

00:23:25.560 --> 00:23:26.810
modifying the object.

00:23:32.590 --> 00:23:33.320
Let's just run it.

00:23:33.320 --> 00:23:36.000
And then, I'll be happy
with the question.

00:23:36.000 --> 00:23:42.110
So here, you'll see I changed
flat sub 1 to now be UMass.

00:23:42.110 --> 00:23:44.684
Yeah, question?

00:23:44.684 --> 00:23:48.596
AUDIENCE: As you've drawn on
the blackboard here, you've

00:23:48.596 --> 00:23:52.060
drawn an arrow to the actual
object that's techs.

00:23:52.060 --> 00:23:54.340
So if we change techs,
will we change univs?

00:23:54.340 --> 00:23:55.570
PROFESSOR: Yes.

00:23:55.570 --> 00:24:00.140
The question was if we change
techs, will we change univs?

00:24:00.140 --> 00:24:03.670
Now, in some sense, that's
a philosophical question.

00:24:03.670 --> 00:24:06.530
From the philosophical
point of view, maybe,

00:24:06.530 --> 00:24:07.410
you could say no.

00:24:07.410 --> 00:24:10.290
Univs is still the
same object.

00:24:10.290 --> 00:24:12.670
So the binding has
not been changed.

00:24:12.670 --> 00:24:18.490
But the object to which it has
been bound is now different.

00:24:18.490 --> 00:24:23.220
Same object, but it has a
new value, all right?

00:24:23.220 --> 00:24:25.320
So this is the key thing
to keep in mind.

00:24:25.320 --> 00:24:32.050
Assignment has to do with the
binding of names to objects.

00:24:32.050 --> 00:24:38.930
Mutation has to do with changing
the value of objects.

00:24:38.930 --> 00:24:41.870
We'll see that pretty
graphically in the next

00:24:41.870 --> 00:24:46.170
example that I wanted to
work my way through.

00:24:46.170 --> 00:24:50.220
So I'm going to work through
a dull example.

00:24:50.220 --> 00:24:51.770
But I think it illustrates
the points.

00:25:02.360 --> 00:25:05.240
And I do, by the way, very much
appreciate the questions,

00:25:05.240 --> 00:25:09.440
even if I forget to throw you
candy in return for asking.

00:25:09.440 --> 00:25:10.720
But it's good.

00:25:10.720 --> 00:25:13.695
If you have questions,
please do ask them.

00:25:13.695 --> 00:25:15.660
And I'll try and remember
to feed you.

00:25:25.020 --> 00:25:28.776
So let's work through what
this code is going to do.

00:25:28.776 --> 00:25:32.680
So first, I'm going to
have the list L1.

00:25:46.460 --> 00:25:50.020
So the first thing, I'm going to
create an object which is a

00:25:50.020 --> 00:25:53.630
list of length one containing
the integer 2.

00:25:53.630 --> 00:25:59.480
So L1 will be bound to the
list of length one

00:25:59.480 --> 00:26:00.920
containing the int 2.

00:26:04.250 --> 00:26:12.550
I'm then going to create another
list, L2, which is

00:26:12.550 --> 00:26:15.660
going to be of length two.

00:26:15.660 --> 00:26:19.290
And the first element
will be L1.

00:26:19.290 --> 00:26:21.535
And the second element
will be L1.

00:26:29.150 --> 00:26:32.510
So what will happen
if I print L2?

00:26:32.510 --> 00:26:33.760
What will I get?

00:26:37.090 --> 00:26:40.600
I'll get list two, comma,
list two, right?

00:26:40.600 --> 00:26:41.850
We can look at it.

00:26:48.720 --> 00:26:50.000
If I print L2, excuse me.

00:26:59.000 --> 00:27:04.120
All right, just what we
would have expected.

00:27:04.120 --> 00:27:11.135
Now, I'm going to change the
0th value of L1 to be 3.

00:27:14.370 --> 00:27:16.120
So I'm going to mutate L1.

00:27:22.660 --> 00:27:38.970
Now, if I print L2, I will get
a different value, 3, 3.

00:27:38.970 --> 00:27:40.220
Not surprising.

00:27:48.550 --> 00:27:54.890
It's something to keep in mind
that can be useful, but can

00:27:54.890 --> 00:27:57.210
also be confusing.

00:27:57.210 --> 00:28:01.300
Because if I'm looking at my
code, it doesn't look like I

00:28:01.300 --> 00:28:07.390
changed L2 when I have
a side effect on L1.

00:28:07.390 --> 00:28:10.740
And so it can be mystifying when
you're trying to debug.

00:28:10.740 --> 00:28:11.740
You print L2.

00:28:11.740 --> 00:28:13.330
You do a bunch of--

00:28:13.330 --> 00:28:15.360
execute a bunch of statements,
none of which

00:28:15.360 --> 00:28:18.080
apparently deals with L2.

00:28:18.080 --> 00:28:22.260
Then, you print L2 again and
get a different value.

00:28:22.260 --> 00:28:25.930
This is both the beauty and
the peril of mutation.

00:28:30.170 --> 00:28:31.420
Now, let's see what this does.

00:28:35.950 --> 00:28:45.830
So here, I've now mutated L2 so
that its first element is

00:28:45.830 --> 00:28:52.820
no longer the list, L1, but
is now the string a.

00:29:07.330 --> 00:29:09.690
And we'll just do a bunch of
these all at once here.

00:29:15.390 --> 00:29:25.040
Now, I'm going to change
L1 to be 2, length one.

00:29:25.040 --> 00:29:27.860
So what do you think will
happen, by the way, if, after

00:29:27.860 --> 00:29:31.840
this, I print L2?

00:29:45.790 --> 00:29:47.040
Whoops.

00:29:50.030 --> 00:29:51.670
What do you think is going
to get printed here?

00:29:58.770 --> 00:29:59.550
This is important.

00:29:59.550 --> 00:30:00.800
You need to figure this out.

00:30:05.630 --> 00:30:07.380
What's going to get
printed here?

00:30:07.380 --> 00:30:08.590
A volunteer, please.

00:30:08.590 --> 00:30:09.946
Yes?

00:30:09.946 --> 00:30:13.074
AUDIENCE: it's going to print
"a" in the first slot and then

00:30:13.074 --> 00:30:16.448
L1 in the second slot.

00:30:16.448 --> 00:30:17.412
PROFESSOR: Well--

00:30:17.412 --> 00:30:19.340
AUDIENCE: So it's "a"
and then "2."

00:30:19.340 --> 00:30:24.040
PROFESSOR: "a" and then
"2" is one conjecture.

00:30:24.040 --> 00:30:25.290
Let's find out.

00:30:33.090 --> 00:30:38.340
"a" and then "3." Why?

00:30:38.340 --> 00:30:45.530
Because what happened here is,
when I did the assignment to

00:30:45.530 --> 00:30:54.740
L1, what that effectively did
was swing this pointer to

00:30:54.740 --> 00:31:00.900
point to the new list containing
the element 2, but

00:31:00.900 --> 00:31:03.010
had no effect on this object.

00:31:07.170 --> 00:31:10.150
I was changing the binding
of the identifier.

00:31:10.150 --> 00:31:14.050
I was not mutating
this object.

00:31:14.050 --> 00:31:19.590
And so this element still points
to the same list, which

00:31:19.590 --> 00:31:22.300
was not mutated.

00:31:22.300 --> 00:31:25.290
That makes sense now?

00:31:25.290 --> 00:31:27.590
So you have to get your
head around the way

00:31:27.590 --> 00:31:28.840
all this stuff works.

00:31:33.810 --> 00:31:37.610
Anybody have a question about
why this is what it did?

00:31:43.260 --> 00:31:47.615
All right, if not, we'll
just roar right along.

00:31:56.840 --> 00:32:02.790
So now, we can do
various things.

00:32:02.790 --> 00:32:04.040
And we'll get some stuff.

00:32:12.640 --> 00:32:14.365
All right, moving right along.

00:32:17.870 --> 00:32:21.690
Here's an interesting little
program not in your hand out.

00:32:29.220 --> 00:32:31.035
Let me get rid of
all this cruft.

00:32:40.170 --> 00:32:42.680
So here's a function,
copylist.

00:32:42.680 --> 00:32:47.170
It takes a source list and
a destination list.

00:32:47.170 --> 00:32:50.960
And for e in the source list, it
appends it to whatever the

00:32:50.960 --> 00:32:52.820
destination list used to be.

00:32:58.120 --> 00:33:00.660
And then, I'm just putting in
a little print statement so

00:33:00.660 --> 00:33:05.340
we'll be able to see as it
runs what it's doing.

00:33:05.340 --> 00:33:08.670
So I'm going to say L1 is
equal to the empty list.

00:33:08.670 --> 00:33:11.900
L2 is 1, 2, 3.

00:33:11.900 --> 00:33:15.530
And I'm going to copylist
L2 to L1.

00:33:15.530 --> 00:33:18.270
Print L1 and L2.

00:33:18.270 --> 00:33:20.245
So what am I going to get when
I print those things?

00:33:23.490 --> 00:33:24.740
This is the easy question.

00:33:28.730 --> 00:33:30.790
Don't tell me I have you
so intimidated that

00:33:30.790 --> 00:33:31.530
you think I'm playing.

00:33:31.530 --> 00:33:33.570
This is not a trick question.

00:33:33.570 --> 00:33:34.050
Pardon?

00:33:34.050 --> 00:33:36.080
AUDIENCE: 1, 2, 3 for
both of them?

00:33:36.080 --> 00:33:38.110
PROFESSOR: 1, 2, 3
for both of them.

00:33:38.110 --> 00:33:39.920
Who said that?

00:33:39.920 --> 00:33:41.170
Raise your hand.

00:33:43.080 --> 00:33:44.000
Someone back--

00:33:44.000 --> 00:33:46.210
oh, good grief, all the
way in the back.

00:33:46.210 --> 00:33:48.720
All right.

00:33:48.720 --> 00:33:52.420
Oh no, not even close!

00:33:52.420 --> 00:33:56.410
Off by a row, and about
four people, too.

00:33:56.410 --> 00:33:57.740
OK.

00:33:57.740 --> 00:33:58.990
so let's try it.

00:34:03.980 --> 00:34:07.340
1, 2, 3, 1, 2, 3.

00:34:07.340 --> 00:34:08.974
So exactly as predicted.

00:34:14.610 --> 00:34:17.320
Now comes the trick question.

00:34:21.699 --> 00:34:23.000
What is this going to do?

00:34:26.400 --> 00:34:27.650
Pardon?

00:34:38.239 --> 00:34:40.190
Well, we'll print L1 here.

00:34:44.750 --> 00:34:46.199
What do you think it'll
do when it gets

00:34:46.199 --> 00:34:47.449
to that print statement?

00:34:55.630 --> 00:34:57.160
Will it get to that
print statement?

00:34:57.160 --> 00:34:59.490
Let me ask that question.

00:34:59.490 --> 00:35:00.740
Will it ever get there?

00:35:08.905 --> 00:35:09.880
AUDIENCE: No.

00:35:09.880 --> 00:35:10.960
PROFESSOR: No.

00:35:10.960 --> 00:35:12.450
Bingo.

00:35:12.450 --> 00:35:13.700
Let's run it.

00:35:20.600 --> 00:35:25.215
And you'll see LDest just gets
longer and longer and longer.

00:35:28.040 --> 00:35:29.290
Why is that happening?

00:35:32.490 --> 00:35:39.030
Because what it's attempting to
do is look at LSource and

00:35:39.030 --> 00:35:43.600
copy the remaining elements
of LSource to LDest.

00:35:43.600 --> 00:35:48.540
But every time I go through the
loop, what we have is a

00:35:48.540 --> 00:36:01.580
situation where the formal
LSource and LDest are now

00:36:01.580 --> 00:36:03.840
pointing to the same object.

00:36:09.260 --> 00:36:13.340
So every time I modify LDest,
I am modifying the object to

00:36:13.340 --> 00:36:16.360
which LSource points to.

00:36:16.360 --> 00:36:18.660
And I keep finding yet another
thing to copy.

00:36:21.830 --> 00:36:29.130
This is an example of what's
called an alias, one object

00:36:29.130 --> 00:36:33.815
with two names, or in general
multiple names.

00:36:52.090 --> 00:36:56.420
When you have immutable
objects, aliasing

00:36:56.420 --> 00:36:59.260
is perfectly harmless.

00:36:59.260 --> 00:37:05.070
If you have 58 different names
for the object 3, it doesn't

00:37:05.070 --> 00:37:08.580
matter because you can never
change what 3 means.

00:37:11.310 --> 00:37:14.780
Here, where you have multiple
names for the same mutable

00:37:14.780 --> 00:37:21.790
object, you can get massive
confusion when you modify it

00:37:21.790 --> 00:37:26.360
through one name and then
forget that it's being

00:37:26.360 --> 00:37:27.610
accessed through another.

00:37:30.030 --> 00:37:32.590
So it's something
to worry about.

00:37:37.820 --> 00:37:41.020
As with tuples, you
can slice lists.

00:37:41.020 --> 00:37:43.640
You can index into lists.

00:37:43.640 --> 00:37:45.410
You can concatenate lists.

00:37:45.410 --> 00:37:47.850
You can do all the
usual things.

00:37:47.850 --> 00:37:49.980
I'm not going to list all
of the operators.

00:37:49.980 --> 00:37:52.390
And there are a lot of
very nice operators.

00:37:52.390 --> 00:37:56.860
But we'll post readings where
you can find what operators

00:37:56.860 --> 00:37:58.190
are available.

00:37:58.190 --> 00:38:03.360
I now want to move on to the
third built-in type that

00:38:03.360 --> 00:38:06.330
collects values, and that's
a dictionary.

00:38:10.120 --> 00:38:17.880
A dictionary differs from
a list in two ways.

00:38:17.880 --> 00:38:21.800
One, the elements
are not ordered.

00:38:21.800 --> 00:38:28.796
And two, more profoundly, the
indices need not be integers.

00:38:40.640 --> 00:38:42.460
And they're not called
indices.

00:38:42.460 --> 00:38:43.710
They're called keys.

00:38:52.370 --> 00:38:57.245
They can be any immutable
type.

00:39:06.740 --> 00:39:08.790
So we'll look at a simple
example first.

00:39:25.990 --> 00:39:29.860
So here, I'm creating
a new dict.

00:39:29.860 --> 00:39:34.290
We use set braces rather than
square braces to remind

00:39:34.290 --> 00:39:39.010
ourselves that the elements
are not ordered.

00:39:39.010 --> 00:39:44.100
And I'm saying the first
key is the number 1.

00:39:44.100 --> 00:39:52.640
And that's bound to the string
object "1, 1." And then the

00:39:52.640 --> 00:39:58.140
second key is the string object
deux, which is bound to

00:39:58.140 --> 00:40:01.100
the string object 2.

00:40:01.100 --> 00:40:04.210
And the third one is the string
object pi which is

00:40:04.210 --> 00:40:11.670
bound to the float 3.14159.

00:40:11.670 --> 00:40:16.280
Now I can then index into it.

00:40:16.280 --> 00:40:22.870
So for example, if I choose to,
I can write something like

00:40:22.870 --> 00:40:27.700
print d sub pi.

00:40:32.010 --> 00:40:34.970
I'll just stop it here with my
old trick of asserting false.

00:40:40.230 --> 00:40:43.440
And you'll see it will
print the value with

00:40:43.440 --> 00:40:46.040
which the key is bound--

00:40:46.040 --> 00:40:47.290
to which the key is bound.

00:40:51.600 --> 00:41:07.935
So what we have here is a dict
is a set of key value pairs.

00:41:15.410 --> 00:41:19.620
And I can access it by
looking at the keys.

00:41:27.730 --> 00:41:31.300
I can do an assignment,
d1 equals d, just

00:41:31.300 --> 00:41:32.340
as I can with lists.

00:41:32.340 --> 00:41:35.100
And now, I remember this
is a real assignment.

00:41:35.100 --> 00:41:39.990
So now, I have an alias,
two identifiers

00:41:39.990 --> 00:41:42.420
pointing to the same dict.

00:41:42.420 --> 00:41:49.340
I can then print d1 sub 1,
either print it or I could

00:41:49.340 --> 00:41:51.060
assign to it.

00:41:51.060 --> 00:41:52.250
So let's do that.

00:41:52.250 --> 00:42:00.770
First, we'll print it just
to show what we get.

00:42:00.770 --> 00:42:05.620
Then, I'm going to do an
assignment, saying, OK, I want

00:42:05.620 --> 00:42:11.940
to now change the binding in
d of the key one to be uno

00:42:11.940 --> 00:42:14.040
rather than one.

00:42:14.040 --> 00:42:15.480
And we'll get something
different.

00:42:15.480 --> 00:42:16.730
Let's just run this.

00:42:23.340 --> 00:42:27.340
So you'll note, as we would have
guessed, with mutability,

00:42:27.340 --> 00:42:28.590
we see it showing up.

00:42:35.570 --> 00:42:41.290
So far, just like lists, the
difference being we have key

00:42:41.290 --> 00:42:45.530
value pairs rather than you
could think of a list as being

00:42:45.530 --> 00:42:47.330
int value pairs.

00:42:47.330 --> 00:42:49.950
The indices of a list
are always ints.

00:42:49.950 --> 00:42:54.120
Associated with each of those
ints, we have a value.

00:42:54.120 --> 00:42:59.810
Let's look at a more fun example
showing what we can do

00:42:59.810 --> 00:43:02.360
with dictionaries.

00:43:02.360 --> 00:43:09.130
So here, I have a very simple
dictionary called EtoF, for

00:43:09.130 --> 00:43:11.810
English to French.

00:43:11.810 --> 00:43:13.610
And we can do some
things with it.

00:43:29.670 --> 00:43:31.980
So I can print it.

00:43:31.980 --> 00:43:33.420
And that's kind of
interesting.

00:43:33.420 --> 00:43:35.160
Let's see what we get
when we print it.

00:43:49.770 --> 00:43:50.840
So it's printing it.

00:43:50.840 --> 00:43:54.020
And you'll notice the order in
which it's printed, the key

00:43:54.020 --> 00:43:59.590
value pairs, is not the order
in which I typed them.

00:44:07.950 --> 00:44:09.510
That's OK.

00:44:09.510 --> 00:44:14.710
The order in which it prints
them is not defined by Python.

00:44:14.710 --> 00:44:17.860
So there's no way to
predict the order.

00:44:17.860 --> 00:44:22.110
And that makes sense because, by
specification, dictionaries

00:44:22.110 --> 00:44:23.250
are unordered.

00:44:23.250 --> 00:44:24.730
They're sets, not sequences.

00:44:33.970 --> 00:44:41.980
I can print keys, EtoF
keys, open, close.

00:44:41.980 --> 00:44:47.850
Keys is a method on dicts
that returns the keys.

00:44:47.850 --> 00:44:50.660
And then, just for fun, I'm
going to try to print

00:44:50.660 --> 00:44:53.600
EtoF.keys without
the open, close.

00:45:01.640 --> 00:45:05.030
So you'll see when I first
printed it with the open,

00:45:05.030 --> 00:45:11.380
closed, I got all of the keys
in an order that was not

00:45:11.380 --> 00:45:13.330
necessarily predictable.

00:45:13.330 --> 00:45:15.720
Certainly not the order
in which I typed them.

00:45:15.720 --> 00:45:16.670
But that's nice.

00:45:16.670 --> 00:45:21.310
I now have this sequence
of keys that I

00:45:21.310 --> 00:45:24.370
could do things with.

00:45:24.370 --> 00:45:27.500
When I typed it without the
open, close, and I wanted you

00:45:27.500 --> 00:45:33.610
to see this, it just says it's
a method, a built-in method.

00:45:33.610 --> 00:45:37.380
It does not execute
the method, right?

00:45:37.380 --> 00:45:39.350
That's fine.

00:45:39.350 --> 00:45:43.960
But again, you have to be
careful that you'll find this

00:45:43.960 --> 00:45:46.060
happening when you write code.

00:45:46.060 --> 00:45:49.250
You'll forget to write
the open, close.

00:45:49.250 --> 00:45:51.460
And you'll wonder why your
program isn't doing what you

00:45:51.460 --> 00:45:53.690
expect it to do.

00:45:53.690 --> 00:45:56.440
Remember, it's not saying
that the method,

00:45:56.440 --> 00:45:58.560
keys, has no argument.

00:45:58.560 --> 00:46:00.450
It has one argument.

00:46:00.450 --> 00:46:03.000
In this case, EtoF.

00:46:03.000 --> 00:46:07.000
And the open, close is basically
saying, all right,

00:46:07.000 --> 00:46:12.110
call the method rather than
the method itself.

00:46:12.110 --> 00:46:13.780
Again, this will be
very important

00:46:13.780 --> 00:46:19.790
when we get to classes.

00:46:19.790 --> 00:46:22.160
Let's get rid of some of these
print statements now.

00:46:36.570 --> 00:46:40.460
Suppose I want to delete
something.

00:46:47.840 --> 00:46:56.150
I can delete something, so
delete EtoF sub 1 del is a

00:46:56.150 --> 00:47:00.460
command, much like print,
that says remove

00:47:00.460 --> 00:47:02.140
something from EtoF.

00:47:05.100 --> 00:47:06.350
So I can do that.

00:47:11.020 --> 00:47:13.640
And now, something
has disappeared.

00:47:13.640 --> 00:47:18.910
The key value pair where
the key is one is gone.

00:47:18.910 --> 00:47:20.770
So that's how I remove things.

00:47:20.770 --> 00:47:22.150
AUDIENCE: Question.

00:47:22.150 --> 00:47:23.026
PROFESSOR: Yes?

00:47:23.026 --> 00:47:25.822
AUDIENCE: Are the keys of
dictionaries mutable?

00:47:25.822 --> 00:47:29.340
PROFESSOR: The keys have
to be immutable.

00:47:29.340 --> 00:47:32.000
You cannot use a mutable
type for a key.

00:47:34.910 --> 00:47:39.060
We'll see the reason for that in
a couple of lectures when I

00:47:39.060 --> 00:47:43.680
talk about how dictionaries
are implemented in Python.

00:47:43.680 --> 00:47:46.990
They use a very clever technique
called hashing which

00:47:46.990 --> 00:47:49.880
would not work if the
keys were mutable.

00:47:52.480 --> 00:47:55.740
So in order to get an efficient
implementation of

00:47:55.740 --> 00:48:00.540
dictionary look-up, we need
to have immutable keys.

00:48:00.540 --> 00:48:01.790
And so that's required.

00:48:14.830 --> 00:48:16.080
Let's look at another example.

00:48:19.260 --> 00:48:23.500
So here, I'm again setting
a dictionary.

00:48:23.500 --> 00:48:27.190
And now, what I'm going to show
you is that I can iterate

00:48:27.190 --> 00:48:31.785
through the keys and
print the values.

00:48:34.950 --> 00:48:38.715
For key in d1.keys, nothing
very fancy here.

00:48:46.290 --> 00:48:47.540
OK?

00:48:49.700 --> 00:48:56.560
one equals uno, pi equals
3.1459, and deux equals 2.

00:48:56.560 --> 00:48:59.480
All right?

00:48:59.480 --> 00:49:03.010
So nothing very dramatic
happening here.

00:49:03.010 --> 00:49:06.920
Finally, just to illustrate
why this sort of thing is

00:49:06.920 --> 00:49:09.270
particularly useful.

00:49:09.270 --> 00:49:12.240
And in fact, you'll find it
quite useful in the upcoming

00:49:12.240 --> 00:49:13.490
problem set.

00:49:17.240 --> 00:49:19.930
I'm going to do some
translations.

00:49:19.930 --> 00:49:23.900
This, by the way, is not the
way Google Translate works.

00:49:23.900 --> 00:49:25.150
It's a bit more sophisticated.

00:49:35.410 --> 00:49:39.860
So I'm going to have two
functions, translateword,

00:49:39.860 --> 00:49:44.020
which, if it finds the word in
the dictionary, returns the

00:49:44.020 --> 00:49:46.480
value associated with the key.

00:49:46.480 --> 00:49:50.050
So note, if word in dictionary
says is there a key whose

00:49:50.050 --> 00:49:52.140
value is word?

00:49:52.140 --> 00:49:55.940
If so, return the value
associated with that key.

00:49:55.940 --> 00:49:58.440
Otherwise, don't even try
and translate it.

00:49:58.440 --> 00:50:01.660
Just leave it the way it was.

00:50:01.660 --> 00:50:07.670
And then, translatesentence will
set the translation equal

00:50:07.670 --> 00:50:11.530
to the empty string
and wordequals

00:50:11.530 --> 00:50:13.810
to the empty string.

00:50:13.810 --> 00:50:16.550
Then, it'll just collect all the
characters until it finds

00:50:16.550 --> 00:50:20.080
a blank, translate
the word using

00:50:20.080 --> 00:50:23.060
translateword, and append it.

00:50:23.060 --> 00:50:25.630
And when it's done,
it will print it.

00:50:25.630 --> 00:50:30.355
So we can now do these
translations quite simply.

00:50:35.980 --> 00:50:37.270
What could be easier?

00:50:37.270 --> 00:50:39.940
You never again have to learn
a foreign language.

00:50:39.940 --> 00:50:43.300
Just use Python to do the
translations for you.

00:50:43.300 --> 00:50:45.120
All right, that's
it for today.

00:50:48.590 --> 00:50:51.520
Remember, there is a problem set
you should be working on

00:50:51.520 --> 00:50:53.960
and another one that
will be posted.

00:50:53.960 --> 00:50:55.210
Take care.