WEBVTT

00:00:00.000 --> 00:00:01.950
The following
content is provided

00:00:01.950 --> 00:00:06.120
by MIT OpenCourseWare under
a Creative Commons license.

00:00:06.120 --> 00:00:08.230
Additional information
about our license

00:00:08.230 --> 00:00:10.490
and MIT OpenCourseWare
in general

00:00:10.490 --> 00:00:11.930
is available at ocw.mit.edu.

00:00:16.620 --> 00:00:18.120
PROFESSOR: This
morning's SIAM News.

00:00:20.820 --> 00:00:22.460
Well, it's an
article on something

00:00:22.460 --> 00:00:26.210
that's not totally up to date
because it's a method that

00:00:26.210 --> 00:00:30.140
was developed 50 years ago
called alternating direction

00:00:30.140 --> 00:00:32.950
and it was exactly
developed-- first

00:00:32.950 --> 00:00:39.330
you did an iteration
in the x direction.

00:00:39.330 --> 00:00:42.610
Of course, we're
tridiagonal along every row,

00:00:42.610 --> 00:00:44.460
we're one-dimensional.

00:00:44.460 --> 00:00:49.810
And then the second
half-step is an iteration

00:00:49.810 --> 00:00:51.040
in the y direction.

00:00:51.040 --> 00:00:54.360
Again, tridiagonal, so
the iteration's very fast.

00:00:54.360 --> 00:00:58.200
You flip-- alternating direction
describes it perfectly.

00:00:58.200 --> 00:01:00.210
And that method is still used.

00:01:00.210 --> 00:01:05.450
It got developed in the oil
reservoir simulation world.

00:01:05.450 --> 00:01:07.410
That is, Houston.

00:01:07.410 --> 00:01:12.740
And the article
says the evolution

00:01:12.740 --> 00:01:18.190
of techniques for oil reservoir
simulation has continued.

00:01:18.190 --> 00:01:24.210
And then mentions 3-- so it went
from this alternating direction

00:01:24.210 --> 00:01:32.430
to line overrelaxation,
LSOR, overrelaxation,

00:01:32.430 --> 00:01:36.250
and I only spoke
briefly about that.

00:01:36.250 --> 00:01:37.600
What's that word line mean?

00:01:37.600 --> 00:01:42.160
That means that we're
taking whole rows at once,

00:01:42.160 --> 00:01:43.520
working with blocks.

00:01:43.520 --> 00:01:48.130
And I'll add some
notes about that today.

00:01:48.130 --> 00:01:52.160
So that was the
next step, line SOR.

00:01:52.160 --> 00:01:56.770
Then to the Newton-Krylov
schemes, that's what's coming,

00:01:56.770 --> 00:02:03.440
Krylov, Conjugate gradients,
with ILU type preconditioners.

00:02:03.440 --> 00:02:06.390
So again, we're talking
about preconditioners

00:02:06.390 --> 00:02:13.120
and one important choice
is this incomplete LU.

00:02:13.120 --> 00:02:19.970
So notes on Gauss-Seidel and I
should maybe add incomplete LU.

00:02:19.970 --> 00:02:24.330
By the way, experiments
badly needed here too.

00:02:24.330 --> 00:02:32.090
Because incomplete LU has
this tolerance and as you

00:02:32.090 --> 00:02:37.470
move the tolerance you
get closer or far away

00:02:37.470 --> 00:02:43.530
to the exact L and U, but
you get faster or slower.

00:02:43.530 --> 00:02:45.580
So what's the balance?

00:02:45.580 --> 00:02:47.920
What's the right tolerance?

00:02:47.920 --> 00:02:51.620
How do these methods
compare-- and overall,

00:02:51.620 --> 00:02:55.260
how do these iterative methods
that we're speaking about

00:02:55.260 --> 00:02:58.390
compare with these
direct methods?

00:02:58.390 --> 00:03:04.670
So we really are in this new
chapter, solving large systems,

00:03:04.670 --> 00:03:10.080
facing a whole lot of
possible new experiments.

00:03:10.080 --> 00:03:14.940
So just to continue the history
or the future as described

00:03:14.940 --> 00:03:19.230
in SIAM News, so there was
alternating direction, line

00:03:19.230 --> 00:03:20.460
SOR.

00:03:20.460 --> 00:03:28.700
Then to Krylov schemes with ILU
preconditioners in use today.

00:03:28.700 --> 00:03:31.120
So this is a big use area.

00:03:31.120 --> 00:03:38.170
And the multiscale, multigrid
solvers that are quote,

00:03:38.170 --> 00:03:41.140
now starting to come of age.

00:03:41.140 --> 00:03:47.180
So that's a third topic for
today's lecture, multigrid.

00:03:47.180 --> 00:03:52.300
That-- of course, it's
been around for some time,

00:03:52.300 --> 00:03:56.730
but it involved,
especially at the start,

00:03:56.730 --> 00:04:01.420
more effort in programming.

00:04:04.040 --> 00:04:09.460
So it didn't quickly-- I
mean, it gave great results

00:04:09.460 --> 00:04:12.970
on model problems.

00:04:12.970 --> 00:04:15.290
On other problems,
too, but still

00:04:15.290 --> 00:04:19.790
it kind of hasn't yet,
but is penetrating

00:04:19.790 --> 00:04:23.430
into production code,
where the oil reservoir

00:04:23.430 --> 00:04:26.420
industry or other big
industries would use it.

00:04:26.420 --> 00:04:33.520
So here you see, really, a
pretty fair picture of where we

00:04:33.520 --> 00:04:36.800
are today with large solvers.

00:04:36.800 --> 00:04:39.760
These are very important.

00:04:39.760 --> 00:04:44.830
Minimum degree-- if the
size is not overwhelming,

00:04:44.830 --> 00:04:48.700
direct methods are going
to be right up there.

00:04:48.700 --> 00:04:53.850
And these are the
pure iterations,

00:04:53.850 --> 00:05:01.050
stationary iterations that, with
this idea, this incomplete LU

00:05:01.050 --> 00:05:04.620
idea, get pretty good.

00:05:04.620 --> 00:05:07.410
But the formula's
always simple there.

00:05:07.410 --> 00:05:13.730
The new x comes from the old
x by the same iterations.

00:05:13.730 --> 00:05:18.450
Whereas, if we use
the ideas there as

00:05:18.450 --> 00:05:25.060
preconditioners and look
to see-- so the point was,

00:05:25.060 --> 00:05:28.840
and I'll repeat it again,
that Gauss-Seidel and Jacobi,

00:05:28.840 --> 00:05:32.760
the standard iterations,
were quite satisfactory

00:05:32.760 --> 00:05:34.810
on high frequencies.

00:05:34.810 --> 00:05:37.960
They damped those out
quite well in the error,

00:05:37.960 --> 00:05:42.290
but they don't tackle the low
frequency, the smooth part

00:05:42.290 --> 00:05:44.560
of the error, very efficiently.

00:05:44.560 --> 00:05:49.470
And that's what multigrid
does incredibly well, so it's

00:05:49.470 --> 00:05:51.890
a nice mixture of the two.

00:05:51.890 --> 00:05:55.300
These are the smoothers,
this is the change

00:05:55.300 --> 00:06:00.170
of scale, change of grid that's
coming now and will come.

00:06:00.170 --> 00:06:06.190
So all this will be my subject
for this week and next,

00:06:06.190 --> 00:06:07.350
prior to spring break.

00:06:07.350 --> 00:06:13.390
And I think you will have enough
to go on to do experiments.

00:06:13.390 --> 00:06:15.570
It could be highly interesting.

00:06:15.570 --> 00:06:20.810
OK, so that's the
SIAM News report.

00:06:20.810 --> 00:06:26.910
OK, what do I want to
say about minimum degree?

00:06:26.910 --> 00:06:29.440
And more will go on the web.

00:06:29.440 --> 00:06:37.100
Just a few more notes about what
we did on Monday after class.

00:06:37.100 --> 00:06:43.710
If you take a matrix like
that, you take a matrix

00:06:43.710 --> 00:06:47.940
and-- how is it described
in sparse format?

00:06:47.940 --> 00:06:52.290
Sparse format you can
see-- normally you

00:06:52.290 --> 00:06:54.490
don't have to see
it, it's usually

00:06:54.490 --> 00:06:58.230
inside the sparse
MATLAB, but if you

00:06:58.230 --> 00:07:03.970
want to see what's happening,
you could ask for i, j, and s.

00:07:03.970 --> 00:07:05.930
Now what are those?

00:07:05.930 --> 00:07:10.660
What will that
produce? i will be

00:07:10.660 --> 00:07:14.140
the list of nonzeros,
the list of the row

00:07:14.140 --> 00:07:16.420
numbers of the nonzeros.

00:07:16.420 --> 00:07:23.060
So i will be-- maybe I'll write
it as a row so I'm transposing,

00:07:23.060 --> 00:07:28.820
So the row numbers would
be row 1, row 2, not row 3.

00:07:28.820 --> 00:07:32.270
Row 1, 2, 3, row 2, 3.

00:07:35.320 --> 00:07:39.890
The column numbers
would be-- these

00:07:39.890 --> 00:07:42.040
are going to be
the pairs (i, j).

00:07:42.040 --> 00:07:48.010
So that's column 1 twice,
column 2 three times.

00:07:48.010 --> 00:07:49.070
Column 3 twice.

00:07:52.520 --> 00:07:58.440
And what's s? s is the actual
numbers in position (i, j),

00:07:58.440 --> 00:08:00.340
is the number 2.

00:08:00.340 --> 00:08:04.240
In position (2, 1) is
the number minus 1.

00:08:04.240 --> 00:08:08.720
So those numbers, minus 1,
2, minus 1 is that column.

00:08:08.720 --> 00:08:12.810
And then minus 1,
2 is that column.

00:08:12.810 --> 00:08:16.290
So of course, we've got all
the information in the matrix.

00:08:16.290 --> 00:08:23.190
We know every nonzero position
and we know what that entry is.

00:08:23.190 --> 00:08:27.180
And of course, our matrices
are much bigger than this one,

00:08:27.180 --> 00:08:35.370
but already we can see
one useful point-- point

00:08:35.370 --> 00:08:41.170
being that key word-- that the
column numbers, this-- I mean,

00:08:41.170 --> 00:08:45.940
imagine we have a large
matrix, so this j is not

00:08:45.940 --> 00:08:52.610
very efficiently recorded
here because what's j?

00:08:52.610 --> 00:08:55.600
We're looking at nonzeros
a column at a time,

00:08:55.600 --> 00:09:00.090
so of course, we'll have a few
ones for the nonzeros in column

00:09:00.090 --> 00:09:07.340
1 and then some twos and then
some threes and some fours,

00:09:07.340 --> 00:09:14.650
but all this row is-- the
real information in that row

00:09:14.650 --> 00:09:20.290
is a pointer to--
in other words,

00:09:20.290 --> 00:09:24.330
I don't have to
repeat 2 three times.

00:09:24.330 --> 00:09:30.780
So really, if I put inside
here a compressed version

00:09:30.780 --> 00:09:36.720
of j, a pointer, would be a
short factor that just has a 1.

00:09:36.720 --> 00:09:42.860
It says look in position 1
for the start of column 1.

00:09:42.860 --> 00:09:48.610
Then a 3-- see, I didn't
need that because that just

00:09:48.610 --> 00:09:49.830
continued column 1.

00:09:49.830 --> 00:09:52.660
That just repeated
the j I already had.

00:09:52.660 --> 00:09:57.700
But this tells me that
in the third position

00:09:57.700 --> 00:09:59.850
I start down column 2.

00:09:59.850 --> 00:10:04.230
And this would tell me that
in position number 4, 5, 6,

00:10:04.230 --> 00:10:09.540
I guess, I start down column 3.

00:10:09.540 --> 00:10:11.030
You see the point of that 6.

00:10:11.030 --> 00:10:15.670
That 6 picks out--
yes-- 1, 2, 3, 4, 5,

00:10:15.670 --> 00:10:20.400
the sixth row number
is the beginning

00:10:20.400 --> 00:10:22.670
of information on column 3.

00:10:22.670 --> 00:10:25.110
And then it's
conventional to have

00:10:25.110 --> 00:10:31.010
a pointer, 8, to say finish.

00:10:31.010 --> 00:10:36.100
So that's pointing
to empty space.

00:10:36.100 --> 00:10:40.080
So in other words, j got
compressed to 1, 3, 6, 8

00:10:40.080 --> 00:10:44.690
and in a large problem it
would get seriously compressed.

00:10:44.690 --> 00:10:54.800
OK, so that's the form in
which the code keeps the matrix

00:10:54.800 --> 00:11:00.490
and does the reorderings.

00:11:00.490 --> 00:11:05.190
Let me just mention that
the opposite of this

00:11:05.190 --> 00:11:09.630
would create the matrix
out of these i, j, s.

00:11:09.630 --> 00:11:12.870
What command would that be?

00:11:12.870 --> 00:11:18.450
You could create the matrix
A out of-- the command sparse

00:11:18.450 --> 00:11:19.960
would be good.

00:11:19.960 --> 00:11:25.110
Sparse of the inputs,
now, would be i, j, s.

00:11:25.110 --> 00:11:31.670
If I input i, j, and s then
that lab creates a matrix.

00:11:31.670 --> 00:11:33.900
And sometimes I
may want to include

00:11:33.900 --> 00:11:41.970
the m and n, the shape of the
matrix, as further parameters,

00:11:41.970 --> 00:11:45.340
but actually here
I wouldn't have to.

00:11:45.340 --> 00:11:48.970
So this is the opposite
command from this one

00:11:48.970 --> 00:11:52.920
that we're interested in.

00:11:52.920 --> 00:11:53.770
You can imagine.

00:11:53.770 --> 00:12:04.250
Suppose by using minimum
degree or some other decision,

00:12:04.250 --> 00:12:07.010
I've eliminated up
to a certain point

00:12:07.010 --> 00:12:11.420
and I want to put the remaining
columns in a different order.

00:12:11.420 --> 00:12:15.950
I can do that just by
playing with the pointers.

00:12:15.950 --> 00:12:21.130
So it's a very efficient
structure for sparse matrices.

00:12:27.690 --> 00:12:31.110
And then comes the question,
OK, what's the good order?

00:12:34.270 --> 00:12:39.150
I was surprised to realize
how open a problem that

00:12:39.150 --> 00:12:47.720
still is, even from the expert
who's developing the key code.

00:12:52.470 --> 00:12:56.340
So approximate minimum degree,
of course, by that word

00:12:56.340 --> 00:13:00.370
you see that it allows freedom.

00:13:00.370 --> 00:13:02.140
There are also
decisions to be made

00:13:02.140 --> 00:13:06.340
when minimum degree is a
tie between several nodes,

00:13:06.340 --> 00:13:08.080
as it commonly is.

00:13:08.080 --> 00:13:12.430
And it's rather nice to
get a MATLAB movie that

00:13:12.430 --> 00:13:18.260
shows the order
in which nodes are

00:13:18.260 --> 00:13:24.670
eliminated, edges are removed
from the graph, from the mesh.

00:13:24.670 --> 00:13:27.040
You'll see that.

00:13:27.040 --> 00:13:30.900
All right, I'm ready to go
ahead now to some comment

00:13:30.900 --> 00:13:32.190
on Gauss-Seidel.

00:13:32.190 --> 00:13:35.110
Maybe I'll put that here.

00:13:35.110 --> 00:13:37.780
In fact, maybe I'll just
take the same matrix.

00:13:37.780 --> 00:13:43.880
So now I want to remember,
what is the Gauss-Seidel method

00:13:43.880 --> 00:13:45.830
for A*x equal b.

00:13:45.830 --> 00:13:47.430
What's the iteration now?

00:13:47.430 --> 00:13:52.230
And again, A will be the same:
2, minus 1, zero; minus 1,

00:13:52.230 --> 00:13:53.890
2, minus 1.

00:13:53.890 --> 00:13:57.620
My favorite, OK.

00:13:57.620 --> 00:14:00.850
So all these iterations,
you remember,

00:14:00.850 --> 00:14:04.720
are splittings of the matrix.

00:14:04.720 --> 00:14:07.470
Some of the matrix goes
on the left-hand side.

00:14:07.470 --> 00:14:09.700
That's the preconditioner.

00:14:09.700 --> 00:14:11.940
So it's P, the
preconditioner that's

00:14:11.940 --> 00:14:16.970
sort of close to A in some
sense, but easy to work with,

00:14:16.970 --> 00:14:21.550
multiplies the new thing
and on the other side

00:14:21.550 --> 00:14:25.890
is A minus A-- the rest
of the matrix-- that

00:14:25.890 --> 00:14:31.900
multiplies the old plus
the right-hand side b.

00:14:31.900 --> 00:14:36.750
Let's just remember again, that
if we converge to the point

00:14:36.750 --> 00:14:42.300
where this is the same as this,
then we have the right answer.

00:14:42.300 --> 00:14:45.510
We have the right answer because
if that's the same as that,

00:14:45.510 --> 00:14:49.780
P*x is the same as P*x, this
comes over on the other side,

00:14:49.780 --> 00:14:51.830
A*x equals b.

00:14:51.830 --> 00:14:56.870
So when it converges, it
converges to the right answer,

00:14:56.870 --> 00:14:59.300
but you remember that
the key equation was

00:14:59.300 --> 00:15:06.920
that the new error is
the old error multiplied

00:15:06.920 --> 00:15:14.240
by this matrix I minus P inverse
A. That's the iteration matrix,

00:15:14.240 --> 00:15:17.190
you could say.

00:15:17.190 --> 00:15:21.400
I just get it when I multiply
both sides by P inverse.

00:15:21.400 --> 00:15:30.240
And so the problem is choose
P so that this is easy to do

00:15:30.240 --> 00:15:34.310
and at the same time,
this has small eigenvalues

00:15:34.310 --> 00:15:35.820
or as small as you can get.

00:15:35.820 --> 00:15:38.810
So the Gauss-Seidel is
a particular choice,

00:15:38.810 --> 00:15:43.430
which takes the lower-- P is
the lower triangular part here.

00:15:43.430 --> 00:15:48.030
So P is, so I just thought I'd
better write down, explicitly:

00:15:48.030 --> 00:15:55.020
Gauss-Seidel takes
that, with zeros there,

00:15:55.020 --> 00:16:00.200
as multiplying-- that's
P. And what's P minus A?

00:16:00.200 --> 00:16:02.730
It's the rest.

00:16:02.730 --> 00:16:05.640
And it's been moved
to the other side

00:16:05.640 --> 00:16:10.740
so the rest is going to be the
strictly upper triangular part.

00:16:10.740 --> 00:16:12.840
And because it's moved
over to the other side

00:16:12.840 --> 00:16:14.430
it'll have a plus sign.

00:16:14.430 --> 00:16:15.750
It'll be 1 and 1.

00:16:20.600 --> 00:16:24.740
x_k plus b.

00:16:24.740 --> 00:16:31.810
I just write it out so that
you see, totally explicitly,

00:16:31.810 --> 00:16:41.420
how being triangular makes
the solution step immediate.

00:16:41.420 --> 00:16:45.060
Because the first equation will
tell us the first component,

00:16:45.060 --> 00:16:46.680
right?

00:16:46.680 --> 00:16:49.340
The first equation,
because it's triangular

00:16:49.340 --> 00:16:51.150
there's only an entry here.

00:16:51.150 --> 00:16:57.860
And by the way, all these
codes, including Tim Davis's

00:16:57.860 --> 00:17:00.870
minimum degree codes,
their very first step

00:17:00.870 --> 00:17:05.100
is reorder the
equations if necessary

00:17:05.100 --> 00:17:09.870
to guarantee that the main
diagonal has no zeros.

00:17:09.870 --> 00:17:13.250
We want to know that in advance.

00:17:13.250 --> 00:17:16.320
So that you just
do, let's assume it.

00:17:16.320 --> 00:17:18.690
Of course, for us it
happens automatically.

00:17:18.690 --> 00:17:21.320
OK, so that's not zero.

00:17:21.320 --> 00:17:24.580
And that first equation
gives us the first component,

00:17:24.580 --> 00:17:28.690
then we know the first
component so we use it here,

00:17:28.690 --> 00:17:32.470
and the second equation tells
us what the second component is.

00:17:32.470 --> 00:17:35.940
We use that second component
in the third equation

00:17:35.940 --> 00:17:40.590
to find the third component.

00:17:40.590 --> 00:17:45.700
So there's no loss of
speed compared to diagonal

00:17:45.700 --> 00:17:50.030
and actually, it's faster
because the storage--

00:17:50.030 --> 00:17:55.210
we're changing-- we're using
the new first component to find

00:17:55.210 --> 00:17:59.000
the second and the new second
component to find the third,

00:17:59.000 --> 00:18:04.920
so we can overwrite
x_k by x_(k+1).

00:18:08.330 --> 00:18:08.900
Let's see.

00:18:08.900 --> 00:18:13.490
I guess if I had space and had
prepared I would figure out

00:18:13.490 --> 00:18:16.700
what this matrix is.

00:18:16.700 --> 00:18:19.000
Maybe you could do that.

00:18:19.000 --> 00:18:23.080
Figure out what-- here's
P. It's invertible.

00:18:23.080 --> 00:18:26.170
P inverse is going
to be quite simple.

00:18:26.170 --> 00:18:30.080
Actually, it would
be extremely simple.

00:18:30.080 --> 00:18:32.800
You'll be able to see its
eigenvalues immediately.

00:18:35.590 --> 00:18:38.940
We could stop to do it,
but I think if you do it,

00:18:38.940 --> 00:18:41.960
it's more valuable.

00:18:41.960 --> 00:18:45.510
So we would find that its
eigenvalues were below 1

00:18:45.510 --> 00:18:52.360
and that they were the squares
of the Jacobi eigenvalues,

00:18:52.360 --> 00:18:55.890
so the method is twice
as fast as Jacobi.

00:18:55.890 --> 00:19:02.180
But it has the same good feature
of damping the high frequencies

00:19:02.180 --> 00:19:07.420
and the same bad feature
of not very much damping

00:19:07.420 --> 00:19:12.080
the low, smooth
part of the error.

00:19:12.080 --> 00:19:16.180
Now we're ready for multigrid,
which is intended to solve it.

00:19:16.180 --> 00:19:28.570
So multigrid is going to be--
the point is, by changing grid,

00:19:28.570 --> 00:19:38.270
by changing from the fine
grid to a coarse grid,

00:19:38.270 --> 00:19:42.060
the smooth oscillation
doesn't look so smooth.

00:19:42.060 --> 00:19:48.620
On the coarse grid,
its effective frequency

00:19:48.620 --> 00:19:55.060
is effectively doubled and it's
moving over in the direction

00:19:55.060 --> 00:19:58.750
where the smoother
can attack it.

00:19:58.750 --> 00:20:01.100
We'll see that happen.

00:20:01.100 --> 00:20:04.450
So now, I have to, really--
this begins the lecture

00:20:04.450 --> 00:20:07.470
on multigrid, which
is going to take,

00:20:07.470 --> 00:20:09.270
certainly, today and Friday.

00:20:12.700 --> 00:20:17.010
There's a very good book
by Briggs and others.

00:20:24.110 --> 00:20:29.910
He wrote the first
edition of the book

00:20:29.910 --> 00:20:33.470
and coauthored the second one.

00:20:33.470 --> 00:20:36.560
And it's beautifully
short and clear and simple

00:20:36.560 --> 00:20:45.750
and this presentation will
follow the same exposition

00:20:45.750 --> 00:20:47.282
that the book does.

00:20:51.400 --> 00:21:00.380
So the key idea is
to see what-- how

00:21:00.380 --> 00:21:03.260
to go from a fine
grid problem, so this

00:21:03.260 --> 00:21:07.670
is on the fine grid
with step size h.

00:21:07.670 --> 00:21:09.810
So this A_h is our problem.

00:21:09.810 --> 00:21:16.490
A_h is A. A_h, b
sub h, we're looking

00:21:16.490 --> 00:21:20.430
for u_h on the fine grid.

00:21:20.430 --> 00:21:24.040
Fine grid means
lots of mesh points,

00:21:24.040 --> 00:21:26.840
lots of unknowns, big problem.

00:21:26.840 --> 00:21:30.760
OK, so the idea is
going to be, somehow,

00:21:30.760 --> 00:21:35.220
to-- let me just
start with two grids.

00:21:39.310 --> 00:21:46.820
Well, you can see what you do
on the fine grid at the start.

00:21:46.820 --> 00:21:47.700
You iterate.

00:21:47.700 --> 00:21:51.210
You use Gauss-Seidel
or Jacobi, whatever.

00:21:51.210 --> 00:21:52.940
Maybe three times.

00:21:52.940 --> 00:21:54.930
Maybe three
iterations, but don't

00:21:54.930 --> 00:21:56.650
continue to a
thousand iterations,

00:21:56.650 --> 00:21:59.450
it's a waste of time.

00:21:59.450 --> 00:22:03.530
Then, here is the real--
this is the multigrid part.

00:22:07.460 --> 00:22:09.580
The multigrid part
is going-- you

00:22:09.580 --> 00:22:14.070
get an answer after
a few iterations,

00:22:14.070 --> 00:22:16.040
after you've smoothed it.

00:22:16.040 --> 00:22:21.390
You compute this
residual, which is

00:22:21.390 --> 00:22:27.410
the amount you're wrong in
the equation, the difference

00:22:27.410 --> 00:22:32.950
between the right side
and the left side.

00:22:32.950 --> 00:22:35.710
I can put h's here
too, to emphasize.

00:22:35.710 --> 00:22:39.430
This is residuals being
computed with what we have,

00:22:39.430 --> 00:22:42.920
which is on the fine grid.

00:22:42.920 --> 00:22:45.620
Now here's the change of grid.

00:22:45.620 --> 00:22:50.160
Number two says, restrict
to a coarse grid.

00:22:50.160 --> 00:22:57.000
Take that r_h, that residual
which is probably a bit smooth,

00:22:57.000 --> 00:23:01.310
and move it to the coarse grid.

00:23:01.310 --> 00:23:05.490
So the coarse grid we
identify by the fact

00:23:05.490 --> 00:23:11.630
that its mesh width
is twice as big, 2h.

00:23:11.630 --> 00:23:14.730
And so we're going to
need some restriction,

00:23:14.730 --> 00:23:18.550
so the input to
this multigrid is

00:23:18.550 --> 00:23:24.880
to decide on a restriction
matrix, how shall we take

00:23:24.880 --> 00:23:27.800
values that are
given on a fine grid

00:23:27.800 --> 00:23:33.340
and restrict them
to a coarse grid?

00:23:33.340 --> 00:23:37.270
Of course, one restriction
is-- and it's not

00:23:37.270 --> 00:23:42.670
that bad-- is just to
take the values of r

00:23:42.670 --> 00:23:46.300
that are on the coarse grid
at every other grid point,

00:23:46.300 --> 00:23:48.910
use those.

00:23:48.910 --> 00:23:54.020
Or we could take into
account the neighbors.

00:23:54.020 --> 00:23:56.090
You see the question.

00:23:56.090 --> 00:24:00.130
So this is coming now
in this restriction.

00:24:00.130 --> 00:24:04.070
So the restriction
is, restriction R,

00:24:04.070 --> 00:24:11.110
this is fine to coarse,
and we have this question

00:24:11.110 --> 00:24:18.310
of use neighbors or not?

00:24:18.310 --> 00:24:21.760
That will enter.

00:24:21.760 --> 00:24:25.680
Well, the decision on
what the matrix R is.

00:24:25.680 --> 00:24:27.130
That's the key.

00:24:27.130 --> 00:24:30.840
OK, so we choose
an R, we restrict,

00:24:30.840 --> 00:24:33.630
and we have now a
half-size problem.

00:24:33.630 --> 00:24:37.570
Well, half-size in 1D,
quarter-size in 2D,

00:24:37.570 --> 00:24:44.130
eighth-size in 3D because
the mesh width has

00:24:44.130 --> 00:24:46.290
doubled in every coordinate.

00:24:48.880 --> 00:24:51.030
Now I've put solve.

00:24:51.030 --> 00:24:54.080
I better put quotes around that.

00:24:54.080 --> 00:24:58.500
Well, solve the problem
on the coarse mesh.

00:24:58.500 --> 00:25:02.420
So the idea is that
that's much faster.

00:25:02.420 --> 00:25:04.540
Well, you might
say, what problem?

00:25:04.540 --> 00:25:10.080
Well, we have to
create, somehow,

00:25:10.080 --> 00:25:12.730
the matrix on the coarse mesh.

00:25:12.730 --> 00:25:17.400
That's not necessarily
given to us.

00:25:17.400 --> 00:25:20.070
We start the
problem with A, A_h,

00:25:20.070 --> 00:25:23.030
the matrix on the fine grid.

00:25:23.030 --> 00:25:28.450
Can I just mention
that this is probably,

00:25:28.450 --> 00:25:33.740
this v-cycle-- that
letter v is supposed

00:25:33.740 --> 00:25:38.300
to suggest going down to
the coarse mesh and back up

00:25:38.300 --> 00:25:41.360
to the fine mesh.

00:25:41.360 --> 00:25:47.540
And the standard
notation in all the

00:25:47.540 --> 00:25:54.400
multigrid books is a capital
V. And why do I use a small v?

00:25:54.400 --> 00:26:00.010
This is my educational
contribution.

00:26:00.010 --> 00:26:06.410
Capital V is appropriate
when you have several meshes.

00:26:06.410 --> 00:26:11.560
You go to 2h, you go to 4h,
you go to 8h, back to 4h, back

00:26:11.560 --> 00:26:13.390
to 2h, back to h.

00:26:13.390 --> 00:26:16.130
So a deeper multigrid.

00:26:16.130 --> 00:26:19.250
So it would look
more complicated.

00:26:19.250 --> 00:26:24.370
I would repeat this idea
instead of solve here.

00:26:24.370 --> 00:26:27.420
Instead of solve at the 2h
level, which of course, I'm

00:26:27.420 --> 00:26:29.560
not going to do exactly anyway.

00:26:29.560 --> 00:26:36.530
But if I was in a
big V-cycle I would

00:26:36.530 --> 00:26:42.000
iterate a few times to smooth
here, just as I did here.

00:26:42.000 --> 00:26:47.620
I would iterate using
weighted Jacobi or something

00:26:47.620 --> 00:26:51.490
and then go down to the 4h mesh.

00:26:51.490 --> 00:26:53.540
So restrict to the 4h mesh.

00:26:53.540 --> 00:26:57.840
So you can see that I would
stay in this little loop

00:26:57.840 --> 00:27:03.570
to get to the bottom, 8h, and
then I would start back up.

00:27:03.570 --> 00:27:07.780
So I think it's a good
idea to use a small letter

00:27:07.780 --> 00:27:14.010
v to tell us-- rather than
saying two-grid capital

00:27:14.010 --> 00:27:19.000
V-cycle, I'm just going
to use a small v to signal

00:27:19.000 --> 00:27:21.870
right away that it's two grids.

00:27:21.870 --> 00:27:23.690
Fine, coarse, fine.

00:27:23.690 --> 00:27:31.330
OK, so we have some solution,
not necessarily exact

00:27:31.330 --> 00:27:34.550
and actually, there
isn't that much point

00:27:34.550 --> 00:27:39.450
in getting it exact
because what we want

00:27:39.450 --> 00:27:42.380
is to move toward
the right answer.

00:27:44.890 --> 00:27:48.440
And notice that I'm
looking here at the error,

00:27:48.440 --> 00:27:54.170
rather than looking at A_(2h),
u_(2h), the actual solution.

00:27:54.170 --> 00:27:58.180
What I'm computing with
is the correction term.

00:27:58.180 --> 00:28:03.150
So this is the correction
term that I find.

00:28:03.150 --> 00:28:07.650
So this is the
residual over here.

00:28:07.650 --> 00:28:11.220
this is the A_(2h) that
I still have to choose,

00:28:11.220 --> 00:28:15.740
and then solving that
will give me a correction,

00:28:15.740 --> 00:28:21.370
but that correction
is on coarse mesh.

00:28:21.370 --> 00:28:29.210
I've only had that correction
E_(2h) defined on the 2h mesh.

00:28:29.210 --> 00:28:35.000
So now comes the other
part of multigrid.

00:28:35.000 --> 00:28:40.210
Get back to the fine
mesh, climb back up.

00:28:40.210 --> 00:28:44.820
I take that E_(2h) and
apply an interpolation.

00:28:44.820 --> 00:28:49.210
I need to create
an interpolation.

00:28:49.210 --> 00:28:51.860
This is going to
be coarse to fine.

00:28:56.420 --> 00:29:00.560
And I have to decide
how to do that.

00:29:00.560 --> 00:29:05.280
Once I've decided
it that gives me

00:29:05.280 --> 00:29:08.170
a correction at the
fine mesh level, which

00:29:08.170 --> 00:29:13.470
is where I'm really working,
so I make the correction

00:29:13.470 --> 00:29:16.100
and I have a better answer.

00:29:16.100 --> 00:29:21.720
And probably, I
iterate a few times--

00:29:21.720 --> 00:29:25.590
that would be called
a post-smoother--

00:29:25.590 --> 00:29:26.510
on that correction.

00:29:26.510 --> 00:29:32.790
And maybe that's where I stop or
maybe I repeat little v-cycles,

00:29:32.790 --> 00:29:36.380
but that's not brilliant.

00:29:36.380 --> 00:29:40.930
If you're going to do
multiple-- if you're

00:29:40.930 --> 00:29:44.740
going to repeat multigrid,
it's much more efficient

00:29:44.740 --> 00:29:52.430
to move to more and
more coarse meshes

00:29:52.430 --> 00:29:56.710
because the
calculations on these

00:29:56.710 --> 00:30:02.310
are way faster than
on the fine mesh.

00:30:02.310 --> 00:30:07.370
You see, rather
than-- I much prefer

00:30:07.370 --> 00:30:10.770
to go way down and back
up than a lot of v-cycles.

00:30:10.770 --> 00:30:16.780
I mean, that would
be a small w-cycle.

00:30:16.780 --> 00:30:19.370
And not brilliant.

00:30:19.370 --> 00:30:25.610
Much better to use a big
V-cycle or a big W-cycle.

00:30:25.610 --> 00:30:28.830
There's a place for W-cycles,
but they're capital W-cycles,

00:30:28.830 --> 00:30:31.450
because you want
to get down where

00:30:31.450 --> 00:30:35.400
it is very fast, very
inexpensive and in fact,

00:30:35.400 --> 00:30:40.060
so efficient that
multigrid achieves

00:30:40.060 --> 00:30:48.940
this holy grail of giving you
an answer with whatever accuracy

00:30:48.940 --> 00:30:54.560
you want-- giving you an
answer in O of n operations.

00:30:54.560 --> 00:30:57.290
n being the matrix size.

00:30:57.290 --> 00:31:00.430
Capital N squared
in our example.

00:31:00.430 --> 00:31:07.340
So that's the fantastic
result from multigrid.

00:31:07.340 --> 00:31:17.450
So I'll come back to this,
but just say if the size of A

00:31:17.450 --> 00:31:22.770
is n, which is capital N in 1D,
capital N squared, capital N

00:31:22.770 --> 00:31:35.260
cubed, then the multigrid
works in O of n flops,

00:31:35.260 --> 00:31:36.390
floating points operations.

00:31:39.480 --> 00:31:44.985
Not even log n, which we
think of for the-- n log

00:31:44.985 --> 00:31:52.470
n we think of for the FFT, for
the Fast Fourier Transform.

00:31:52.470 --> 00:31:58.730
But here's it's
actually order of n.

00:31:58.730 --> 00:32:01.650
That really is a
goal worth achieving.

00:32:06.680 --> 00:32:09.870
So we know what the
smoothers might be.

00:32:09.870 --> 00:32:14.580
It's the I and the
R that are new.

00:32:14.580 --> 00:32:16.890
And then the analysis
of convergence,

00:32:16.890 --> 00:32:19.130
why does it converge?

00:32:19.130 --> 00:32:22.220
But to use the method,
and-- so by the way,

00:32:22.220 --> 00:32:25.030
projects using multigrid
are totally welcome also.

00:32:28.860 --> 00:32:33.720
So let me take the
interpolation I. So what's that?

00:32:33.720 --> 00:32:35.110
Coarse to fine.

00:32:35.110 --> 00:32:39.850
Let me imagine I'm in 1D,
so there's the x direction.

00:32:39.850 --> 00:32:42.650
Here's one end of the
interval, here's the other end

00:32:42.650 --> 00:32:45.380
of the interval and suppose my
boundary conditions are zero.

00:32:50.370 --> 00:32:58.630
So this is the coarse mesh
and let me put in here,

00:32:58.630 --> 00:33:02.670
make it the fine mesh.

00:33:02.670 --> 00:33:04.400
So at this point,
I have an answer

00:33:04.400 --> 00:33:08.150
on the coarse mesh, which
satisfies the boundary

00:33:08.150 --> 00:33:14.890
condition, and let's say
it's there, there, and there.

00:33:17.580 --> 00:33:23.170
OK, and I need values on the
fine mesh at the other points.

00:33:23.170 --> 00:33:26.730
Of course, I'm going
to use these values

00:33:26.730 --> 00:33:27.930
when I interpolate them.

00:33:27.930 --> 00:33:31.200
That word interpolation
means-- implies,

00:33:31.200 --> 00:33:34.440
keep what you have
on the given points.

00:33:34.440 --> 00:33:38.030
And I'm just going to
do linear interpolation.

00:33:38.030 --> 00:33:46.270
So halfway there, halfway
there, and halfway there.

00:33:46.270 --> 00:33:51.810
So I'm inputting-- ignoring the
boundary conditions, the zeros,

00:33:51.810 --> 00:33:59.410
I'm-- it's going to
be 5 by 2 I think,

00:33:59.410 --> 00:34:07.990
this matrix I in this example
will be 5 by 2 because it has 2

00:34:07.990 --> 00:34:11.320
inputs, these, and
it has 5 outputs.

00:34:11.320 --> 00:34:12.660
And what's the matrix?

00:34:16.590 --> 00:34:21.050
Well, for the second
and fourth outputs

00:34:21.050 --> 00:34:32.300
it uses exactly--
this multiplies x,

00:34:32.300 --> 00:34:38.750
or I should say u, u_1 and u_2.

00:34:38.750 --> 00:34:45.010
Let me see if I'm-- if I'll
follow the notes in-- the notes

00:34:45.010 --> 00:34:55.520
use v_1 and v_2 for the coarse
mesh values to avoid h, 2h,

00:34:55.520 --> 00:34:56.850
extra subscripts.

00:34:56.850 --> 00:35:00.560
So this height is v_1,
this height is v_2,

00:35:00.560 --> 00:35:07.910
and I'm going to take-- this'll
be the new u_1, u_3, and u_5.

00:35:07.910 --> 00:35:10.850
And u_2 I'm going to save.

00:35:14.600 --> 00:35:20.260
I better put I and make this
into a true equation, I*v.

00:35:20.260 --> 00:35:26.200
This is going to give me the
values u_1, u_2, u_3, u_4,

00:35:26.200 --> 00:35:29.500
and u_5.

00:35:29.500 --> 00:35:34.720
So u_2 is just v_1.

00:35:34.720 --> 00:35:39.010
u_4 is just v_2.

00:35:39.010 --> 00:35:41.050
No problem.

00:35:41.050 --> 00:35:43.381
And what do I do
with the other ones?

00:35:43.381 --> 00:35:43.880
Let's see.

00:35:43.880 --> 00:35:53.150
I guess u_1 is halfway
between v_1 and 0.

00:35:53.150 --> 00:35:54.840
OK, so it's 1/2.

00:35:58.280 --> 00:36:04.490
u_1 is just 1/2 v_1,
it doesn't involve v_2.

00:36:04.490 --> 00:36:09.010
u_3, which is sitting
here is half of these,

00:36:09.010 --> 00:36:14.510
so it's half of this and half
of that where this was nothing.

00:36:14.510 --> 00:36:19.630
Then u_4 was the same
as v_2, just take v_2.

00:36:19.630 --> 00:36:20.940
And what's u_5?

00:36:20.940 --> 00:36:23.980
u_5 is half of v_2
and half of zero.

00:36:29.200 --> 00:36:36.110
So it's a simple matrix,
the interpolation matrix.

00:36:36.110 --> 00:36:38.670
It's just reasonable
to use the letter I

00:36:38.670 --> 00:36:42.670
and we all recognize, here
it's a rectangular matrix, not

00:36:42.670 --> 00:36:44.280
the identity.

00:36:44.280 --> 00:36:45.970
I doesn't stand
for identity here,

00:36:45.970 --> 00:36:48.500
it stands for interpolation.

00:36:48.500 --> 00:36:52.340
OK, so I hope you can
focus on the matrix.

00:36:57.650 --> 00:37:02.510
And if it was much, much
bigger, but still in 1D,

00:37:02.510 --> 00:37:04.210
it wouldn't look very different.

00:37:04.210 --> 00:37:07.420
Each column would
have a 1/2, 1, 1/2.

00:37:07.420 --> 00:37:12.010
That's a typical part of
the interpolation matrix.

00:37:12.010 --> 00:37:17.760
It uses the value v_1, saves
it at the center point,

00:37:17.760 --> 00:37:20.830
uses half of it at the
previous point, and half of it

00:37:20.830 --> 00:37:23.800
at the right-hand point.

00:37:23.800 --> 00:37:34.120
And similarly, you see it's sort
of a typical rectangular matrix

00:37:34.120 --> 00:37:36.560
in signal processing as well.

00:37:39.720 --> 00:37:43.410
I have to say something
about what happens in 2D

00:37:43.410 --> 00:37:47.500
because our problems are in 2D.

00:37:47.500 --> 00:37:52.520
Maybe I just draw
a typical 2D mesh.

00:37:55.940 --> 00:38:00.160
These are the coarse values,
this is the coarse mesh and now

00:38:00.160 --> 00:38:03.270
I'll-- and of course,
we'll save those values.

00:38:03.270 --> 00:38:07.040
I will have a 1, so
it'll save those values

00:38:07.040 --> 00:38:13.670
when it goes to the fine mesh,
the fine mesh being half.

00:38:13.670 --> 00:38:16.530
So I just have to
decide what to do there.

00:38:16.530 --> 00:38:18.160
So question mark.

00:38:18.160 --> 00:38:21.350
What value shall I
take-- oh, I suppose

00:38:21.350 --> 00:38:23.520
I have to decide there, too.

00:38:23.520 --> 00:38:28.890
These are all new points
and what shall I do.

00:38:28.890 --> 00:38:31.400
I'm just going to stay with
linear interpolation, which

00:38:31.400 --> 00:38:34.250
is quite fast and satisfactory.

00:38:34.250 --> 00:38:37.650
This value will be the
average of those two.

00:38:37.650 --> 00:38:39.754
This value will be
the average of those

00:38:39.754 --> 00:38:41.420
and what will this
one be in the center?

00:38:41.420 --> 00:38:49.060
It's the average of
these four, of course.

00:38:49.060 --> 00:38:50.490
And that's what we'll get.

00:38:50.490 --> 00:38:56.910
Actually, that Kronecker product
business, a Kronecker product

00:38:56.910 --> 00:39:01.350
of a 1D matrix like
that with itself

00:39:01.350 --> 00:39:05.590
would be a 2D interpolation
that would do exactly this.

00:39:05.590 --> 00:39:08.260
We can write it out
more fully, but it's not

00:39:08.260 --> 00:39:13.630
fun to write out really fully
because if this is 5 by 2,

00:39:13.630 --> 00:39:17.970
then I2D would be 25 by 4.

00:39:20.970 --> 00:39:24.700
So we're right away, even
on this tiny, tiny problem,

00:39:24.700 --> 00:39:28.510
we're right away up
to 25 internal mesh

00:39:28.510 --> 00:39:29.680
points on the fine mesh.

00:39:32.850 --> 00:39:34.920
That's the matrix that
I want you to see.

00:39:34.920 --> 00:39:43.760
And, the natural choice
for R is the transpose.

00:39:46.450 --> 00:39:50.890
So one possible choice-- and it
will, the answer will be yes,

00:39:50.890 --> 00:39:52.540
we do use neighbors.

00:39:52.540 --> 00:40:00.530
So R will be the
transpose of I. Actually,

00:40:00.530 --> 00:40:03.620
I'll need a factor here.

00:40:03.620 --> 00:40:06.740
I think it's 1/2.

00:40:06.740 --> 00:40:09.390
Let me just see what it is.

00:40:09.390 --> 00:40:18.180
Let me see why we need a little
multiple there to make things

00:40:18.180 --> 00:40:20.310
right.

00:40:20.310 --> 00:40:23.170
So there's my matrix
I, so I'm just

00:40:23.170 --> 00:40:31.310
going to transpose it and
let me factor 1/2 out of that

00:40:31.310 --> 00:40:34.760
so you see these matrices
without fractions inside.

00:40:34.760 --> 00:40:37.280
That would be 1, 2, 1.

00:40:37.280 --> 00:40:38.640
So I'm going to transpose that.

00:40:38.640 --> 00:40:41.340
1, 2, 1, 0, 0.

00:40:41.340 --> 00:40:43.210
0, 0, 1, 2, 1.

00:40:45.800 --> 00:40:49.550
So I factored 1/2 out
of I when I did that.

00:40:49.550 --> 00:40:52.060
And then I believe that
I need another 1/2 here.

00:40:52.060 --> 00:40:54.410
I think I need 1/4.

00:40:54.410 --> 00:40:56.660
And what do I mean
by needing 1/4?

00:41:02.010 --> 00:41:04.810
Of course, the main
point is that this

00:41:04.810 --> 00:41:07.330
is the transpose of this.

00:41:07.330 --> 00:41:12.310
And you'll see that that
preserves the symmetry.

00:41:12.310 --> 00:41:17.910
That's just sort of the
natural thing to pick.

00:41:17.910 --> 00:41:20.580
Not the only possibility,
but it's very good

00:41:20.580 --> 00:41:25.190
to connect the restriction
with the interpolation.

00:41:25.190 --> 00:41:28.790
Of course, you can't
take the restriction

00:41:28.790 --> 00:41:31.140
to be the inverse of
the interpolation.

00:41:31.140 --> 00:41:32.970
Why not?

00:41:32.970 --> 00:41:39.990
I mean that sort of mental idea
is that the restriction goes

00:41:39.990 --> 00:41:41.970
in one direction and
the interpolation

00:41:41.970 --> 00:41:43.010
in the other direction.

00:41:43.010 --> 00:41:45.800
So why not just let one be
the inverse of the other?

00:41:45.800 --> 00:41:50.100
Well of course, that matrix
doesn't have an inverse.

00:41:54.680 --> 00:41:57.540
I mean its rank is only 2.

00:41:57.540 --> 00:42:01.450
When we do a restriction we're
going to lose information,

00:42:01.450 --> 00:42:04.080
the interpolation
can't put it all back

00:42:04.080 --> 00:42:10.430
because we threw it away when we
restricted to the coarse mesh.

00:42:10.430 --> 00:42:12.030
Now why 1/4?

00:42:12.030 --> 00:42:17.970
I think it's just if we had
all constants, like all ones,

00:42:17.970 --> 00:42:22.280
as our mesh values,
we would want

00:42:22.280 --> 00:42:26.910
to get all ones for
the restriction.

00:42:26.910 --> 00:42:31.890
So if I multiply this matrix
by the vector of all ones--

00:42:31.890 --> 00:42:37.670
so assuming you remember
where R comes in,

00:42:37.670 --> 00:42:43.540
if I just copy
this equation, you

00:42:43.540 --> 00:42:51.170
remember that I go from the
h mesh, it's fine to coarse.

00:42:55.770 --> 00:43:09.110
So R times ones on the fine
mesh, all ones on the fine mesh

00:43:09.110 --> 00:43:13.410
gives ones on the coarse mesh.

00:43:13.410 --> 00:43:20.980
That's why I wanted that-- you
see, if I multiply by all ones

00:43:20.980 --> 00:43:25.080
then that multiplication gives
me 1 plus 2 plus 1 equal 4

00:43:25.080 --> 00:43:30.550
and I need to divide by
4 to get back to the 1.

00:43:30.550 --> 00:43:35.550
You quickly discover
that that just arises

00:43:35.550 --> 00:43:37.760
because of a change of scale.

00:43:37.760 --> 00:43:40.200
It's just a factor of 1/2.

00:43:40.200 --> 00:43:45.730
In 2D that 1/2 there
would change to 1/4.

00:43:45.730 --> 00:43:48.740
In 3D it'd be 1/8.

00:43:48.740 --> 00:43:54.550
It's just the scaling
to preserve constants.

00:43:57.880 --> 00:44:01.650
And now the remaining
question is, what's A_(2h).

00:44:01.650 --> 00:44:08.810
That's the other matrix
here that we're not given.

00:44:08.810 --> 00:44:13.030
We're given the
A_h, our problem.

00:44:13.030 --> 00:44:17.240
We choose an R and we choose
an I and if we're smart,

00:44:17.240 --> 00:44:19.620
one's the transpose
of the other.

00:44:19.620 --> 00:44:21.920
And then the question
is, what's A_(2h)?

00:44:21.920 --> 00:44:27.680
And there's a beautiful answer,
so let me just say what it is.

00:44:27.680 --> 00:44:46.240
A_(2h), the coarse mesh matrix,
is the fine mesh matrix,

00:44:46.240 --> 00:44:57.330
but I need to do first-- if this
is going to apply to the coarse

00:44:57.330 --> 00:45:03.660
mesh guys, the v's, I have
to do an interpolation.

00:45:06.539 --> 00:45:07.330
You'll see it here.

00:45:07.330 --> 00:45:12.710
This is 5 by 5 in my problem.

00:45:12.710 --> 00:45:17.510
So I need to first
do the interpolation

00:45:17.510 --> 00:45:22.670
to get from a vector of length
2 up to a vector of length 5.

00:45:22.670 --> 00:45:25.330
Then this and then
the restriction.

00:45:25.330 --> 00:45:26.770
That's terrific.

00:45:26.770 --> 00:45:27.520
That's A_(2h).

00:45:32.900 --> 00:45:40.550
So this is A_(2h) and
we'd better do an example.

00:45:40.550 --> 00:45:42.090
I guess it's going
to be next time.

00:45:42.090 --> 00:45:46.160
So that'll be the first thing
for next time, would be to see,

00:45:46.160 --> 00:45:50.690
okay, for the standard
second difference A_h,

00:45:50.690 --> 00:45:55.630
for these piecewise linear
interpolation and restriction,

00:45:55.630 --> 00:45:59.380
what comes out as A_(2h)?

00:45:59.380 --> 00:46:03.760
Do we get the standard
second difference

00:46:03.760 --> 00:46:10.640
on the coarse mesh, which you
really hope we do and we do.

00:46:10.640 --> 00:46:15.300
This will be the second
difference, in our example,

00:46:15.300 --> 00:46:16.810
on the coarse mesh.

00:46:21.130 --> 00:46:26.390
So that this middle step of
multigrid is exactly what

00:46:26.390 --> 00:46:29.630
we would have expected.

00:46:29.630 --> 00:46:32.330
What we would've had if we
set up the problem originally

00:46:32.330 --> 00:46:33.940
on the coarse mesh.

00:46:33.940 --> 00:46:37.260
But now we're going to get
an answer that we take back

00:46:37.260 --> 00:46:38.560
to the fine mesh.

00:46:38.560 --> 00:46:41.260
OK, so I'll do that next time.

00:46:41.260 --> 00:46:45.990
Some homeworks here that I
held for an extra two days

00:46:45.990 --> 00:46:50.780
and now I'm returning and
some thoughts to go up

00:46:50.780 --> 00:46:54.340
on to the website about
possible projects,

00:46:54.340 --> 00:46:57.210
but actually, I
expressed a lot of them

00:46:57.210 --> 00:46:59.280
at the beginning of the lecture.

00:46:59.280 --> 00:47:00.510
OK, thanks.

00:47:00.510 --> 00:47:01.760
Good.