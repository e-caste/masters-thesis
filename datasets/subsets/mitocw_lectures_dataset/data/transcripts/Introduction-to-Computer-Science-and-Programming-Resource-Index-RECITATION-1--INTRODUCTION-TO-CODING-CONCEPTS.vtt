WEBVTT

00:00:00.530 --> 00:00:02.960
The following content is
provided under a Creative

00:00:02.960 --> 00:00:04.370
Commons license.

00:00:04.370 --> 00:00:07.410
Your support will help MIT
OpenCourseWare continue to

00:00:07.410 --> 00:00:11.060
offer high-quality educational
resources for free.

00:00:11.060 --> 00:00:13.960
To make a donation or view
additional materials from

00:00:13.960 --> 00:00:17.890
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:17.890 --> 00:00:19.140
ocw.mit.edu.

00:00:23.370 --> 00:00:25.940
PROFESSOR: So the way that I
envision recitations going is

00:00:25.940 --> 00:00:29.100
I'll start off kind of reviewing
some of the points,

00:00:29.100 --> 00:00:33.380
some of the high points from
lectures, might go into detail

00:00:33.380 --> 00:00:35.430
on some of the more
important topics.

00:00:35.430 --> 00:00:38.450
And this is also a time for
you to ask questions.

00:00:38.450 --> 00:00:43.830
There's only 25-30 of you here,
so you should feel a

00:00:43.830 --> 00:00:45.440
little bit more comfortable
asking questions.

00:00:45.440 --> 00:00:49.490
And there are no stupid
questions here.

00:00:49.490 --> 00:00:52.960
For the most part, you're all
beginners at programming.

00:00:52.960 --> 00:00:53.780
Am I wrong?

00:00:53.780 --> 00:00:57.450
Has anyone programmed
here before?

00:00:57.450 --> 00:00:57.770
OK.

00:00:57.770 --> 00:01:01.000
So presumably, none of you have
any experience with what

00:01:01.000 --> 00:01:01.820
we're talking about.

00:01:01.820 --> 00:01:05.620
And so if you ask a question, no
matter how basic you think

00:01:05.620 --> 00:01:07.140
it is, it's not stupid.

00:01:07.140 --> 00:01:10.190
Because everyone's been there,
including me and the professor

00:01:10.190 --> 00:01:11.930
when we started programing.

00:01:11.930 --> 00:01:15.480
And we've made, ourselves,
really stupid mistakes too.

00:01:15.480 --> 00:01:16.800
So.

00:01:16.800 --> 00:01:17.820
That said.

00:01:17.820 --> 00:01:19.940
We started out by talking
about the purpose of the

00:01:19.940 --> 00:01:23.080
class, which is to teach you
how to take problems, real

00:01:23.080 --> 00:01:26.940
world problems, break them down,
abstract them, and divvy

00:01:26.940 --> 00:01:29.450
them up so that you can solve
them with a computer.

00:01:29.450 --> 00:01:32.600
And when we talk about computer,
we're talking about

00:01:32.600 --> 00:01:36.100
a very simple model where--

00:01:36.100 --> 00:01:39.570
and this is the only time you'll
see anything related to

00:01:39.570 --> 00:01:41.980
hardware in this class.

00:01:41.980 --> 00:01:43.830
When we talk about a computer,
we're talking about something

00:01:43.830 --> 00:01:49.810
very simple with a CPU and
memory and maybe some input

00:01:49.810 --> 00:01:52.646
and output.

00:01:52.646 --> 00:01:54.580
All right.

00:01:54.580 --> 00:01:57.880
And when we talk about programs,
these are sequences

00:01:57.880 --> 00:02:01.370
of instructions that are loaded
into the computer's

00:02:01.370 --> 00:02:05.760
memory which can be divided up
into little cells like this.

00:02:05.760 --> 00:02:07.020
All right.

00:02:07.020 --> 00:02:08.935
And what they might
look like is--

00:02:14.690 --> 00:02:16.826
This actually doesn't mean
anything, but it's just, you

00:02:16.826 --> 00:02:20.330
know, for the sake
of demonstration.

00:02:20.330 --> 00:02:22.860
This is what a computer
would see.

00:02:22.860 --> 00:02:26.150
As the CPU starts running
a program, it looks at

00:02:26.150 --> 00:02:28.710
whatever's in this memory
location and says, this is an

00:02:28.710 --> 00:02:30.770
instruction I can handle,
so I'm gonna go do this.

00:02:30.770 --> 00:02:34.890
So this might be like add
two numbers together

00:02:34.890 --> 00:02:36.190
and produce a result.

00:02:36.190 --> 00:02:38.540
Something very simple,
very basic.

00:02:38.540 --> 00:02:41.140
And as it moves along in a
straight line fashion, it just

00:02:41.140 --> 00:02:42.890
executes this instruction,
this instruction, this

00:02:42.890 --> 00:02:44.380
instruction, et cetera,
et cetera.

00:02:44.380 --> 00:02:46.370
The problem is is that while
the computer is perfectly

00:02:46.370 --> 00:02:49.940
happy to look at this, this
is gibberish to us.

00:02:49.940 --> 00:02:53.870
And most people, most sane
people, if they're actually

00:02:53.870 --> 00:02:56.920
looking at computer code,
can't decipher this.

00:02:56.920 --> 00:03:01.470
So this is where programming
languages come in.

00:03:01.470 --> 00:03:02.940
We can move up a level.

00:03:02.940 --> 00:03:06.100
We can abstract away from this,
and maybe say something

00:03:06.100 --> 00:03:08.330
like this stands for --

00:03:08.330 --> 00:03:11.470
move a number into a register
or something like that.

00:03:11.470 --> 00:03:13.190
You don't have to know
what this means.

00:03:13.190 --> 00:03:15.430
All you have to know is that
this is a little bit more

00:03:15.430 --> 00:03:16.610
readable than this.

00:03:16.610 --> 00:03:18.720
And it represents an instruction
that the computer

00:03:18.720 --> 00:03:19.910
can understand.

00:03:19.910 --> 00:03:22.420
The problem is that even at this
level, this is still very

00:03:22.420 --> 00:03:25.080
atomic and very low level, and
really you can't understand

00:03:25.080 --> 00:03:26.210
what's going on.

00:03:26.210 --> 00:03:27.460
So--

00:03:29.190 --> 00:03:31.370
just so I can fill this in.

00:03:36.660 --> 00:03:42.250
We move into say, I'm gonna say
x is equal to 1 and I'm

00:03:42.250 --> 00:03:47.850
gonna add x plus 5 and
then multiply by 2.

00:03:47.850 --> 00:03:50.230
This is a lot easier for
us to understand.

00:03:50.230 --> 00:03:53.330
And this is what we're talking
about when we're talking about

00:03:53.330 --> 00:03:55.540
any sort of programming
language that we'll be

00:03:55.540 --> 00:03:56.720
studying in this course.

00:03:56.720 --> 00:03:58.760
And we're studying Python.

00:03:58.760 --> 00:04:01.280
So there are hundreds of
languages that allow you to

00:04:01.280 --> 00:04:06.070
express these concepts in
a form similar to that.

00:04:06.070 --> 00:04:08.780
And all it does is it allows us
to talk to the computer in

00:04:08.780 --> 00:04:11.260
this language.

00:04:11.260 --> 00:04:12.530
So everyone good with that?

00:04:12.530 --> 00:04:13.764
Cool?

00:04:13.764 --> 00:04:15.014
All right.

00:04:18.850 --> 00:04:26.710
So when we have these
programming languages, they're

00:04:26.710 --> 00:04:30.760
put together in specific ways.

00:04:30.760 --> 00:04:35.510
So does everyone remember
the term syntax?

00:04:35.510 --> 00:04:38.930
Can anyone tell me what it meant
or means in terms of

00:04:38.930 --> 00:04:40.180
programming languages?

00:04:43.800 --> 00:04:44.160
AUDIENCE: I could guess.

00:04:44.160 --> 00:04:48.130
It is the way that the
string is structured?

00:04:48.130 --> 00:04:48.470
PROFESSOR: Yeah.

00:04:48.470 --> 00:04:50.870
It's the way the parts of the
language are put together.

00:04:50.870 --> 00:05:03.390
So let's say that I take a
very simple statement.

00:05:03.390 --> 00:05:06.110
I'm taking a variable
plus this variable.

00:05:06.110 --> 00:05:09.390
This is a valid piece of
syntax for Python, for

00:05:09.390 --> 00:05:13.260
example, or, say, arithmetic,
or a bunch

00:05:13.260 --> 00:05:15.270
of different languages.

00:05:15.270 --> 00:05:16.520
So this is good.

00:05:24.430 --> 00:05:25.680
I can't write.

00:05:29.270 --> 00:05:32.360
On the other hand, if we say
variable variable plus, this

00:05:32.360 --> 00:05:35.140
isn't valid in Python,
for example.

00:05:35.140 --> 00:05:38.250
It might be valid in another
language, but the syntax of

00:05:38.250 --> 00:05:39.560
Python won't allow this.

00:05:39.560 --> 00:05:42.350
So this is bad syntax.

00:05:42.350 --> 00:05:43.600
So.

00:05:45.810 --> 00:05:46.690
All right.

00:05:46.690 --> 00:05:50.512
So is everyone kind of
understand what syntax is?

00:05:50.512 --> 00:05:51.390
All right.

00:05:51.390 --> 00:05:53.850
What about static semantics?

00:05:53.850 --> 00:05:57.370
Talked about that in class.

00:05:57.370 --> 00:06:02.520
Can anyone give me kind of a
rough view of what that is?

00:06:02.520 --> 00:06:03.623
Can I choose someone?

00:06:03.623 --> 00:06:05.890
All right.

00:06:05.890 --> 00:06:15.370
When we talk about static
semantics, we're talking about

00:06:15.370 --> 00:06:18.350
syntactically valid statements
that mean something.

00:06:18.350 --> 00:06:25.310
So let's say that I have
variable a is equal to 5 and b

00:06:25.310 --> 00:06:26.560
is equal to 2.

00:06:29.750 --> 00:06:32.260
A statement that's syntactically
correct and is

00:06:32.260 --> 00:06:36.240
also meaningful with respect to
static semantics could be

00:06:36.240 --> 00:06:40.570
something like a divided
by 2, right.

00:06:40.570 --> 00:06:43.250
Or a divided by b.

00:06:43.250 --> 00:06:46.160
They're valid statements
syntactically.

00:06:46.160 --> 00:06:49.660
And we know that 5 divided by
2 or a divided by b, they're

00:06:49.660 --> 00:06:50.820
both numbers.

00:06:50.820 --> 00:06:51.670
They mean something.

00:06:51.670 --> 00:06:55.750
On the other hand, let's
say that I had this.

00:07:01.070 --> 00:07:04.370
I'm gonna say that this variable
d is a string 'foo'.

00:07:04.370 --> 00:07:06.610
All right.

00:07:06.610 --> 00:07:13.560
This c divided by d where c is
a number and d is a string,

00:07:13.560 --> 00:07:15.690
that's something that's
not meaningful, right.

00:07:15.690 --> 00:07:18.472
What does a number divided
by a string mean?

00:07:18.472 --> 00:07:19.920
Nothing.

00:07:19.920 --> 00:07:23.220
So that's what we're talking
about with static semantics.

00:07:23.220 --> 00:07:26.490
So bad.

00:07:26.490 --> 00:07:29.960
These two aspects of computer
programs are pretty easy to

00:07:29.960 --> 00:07:34.320
check for a compiler interpreter
because they're

00:07:34.320 --> 00:07:37.390
pretty explicit rules, right.

00:07:37.390 --> 00:07:43.430
The part that we spend most
of our time in is

00:07:43.430 --> 00:07:44.680
the semantic part.

00:07:49.050 --> 00:07:54.950
And this is where the syntax
checks out, the statements are

00:07:54.950 --> 00:07:58.130
meaningful in and of themselves,
but the program as

00:07:58.130 --> 00:08:02.010
a whole, or the whole kind
of recipe, doesn't work.

00:08:02.010 --> 00:08:13.620
So as an example, so this,
as we know is fine.

00:08:13.620 --> 00:08:14.900
That's correct.

00:08:14.900 --> 00:08:16.155
But let's say we have this.

00:08:20.540 --> 00:08:24.930
So a is 6, c is 0.

00:08:24.930 --> 00:08:29.280
I do that, what's
6 divided by 0?

00:08:29.280 --> 00:08:30.290
It's an error.

00:08:30.290 --> 00:08:33.260
But syntactically
this is fine.

00:08:33.260 --> 00:08:35.200
And by static semantics,
this is fine.

00:08:35.200 --> 00:08:38.490
So this is the type of thing
we're talking about with the

00:08:38.490 --> 00:08:42.299
semantic aspects of a program.

00:08:42.299 --> 00:08:45.090
Does it work properly?

00:08:45.090 --> 00:08:53.040
And before I jump into Python,
one tip to keep in mind is

00:08:53.040 --> 00:08:55.590
that when you're writing
programs and you're trying to

00:08:55.590 --> 00:09:01.660
do your problem sets, your
program is very explicit.

00:09:01.660 --> 00:09:03.060
It's not ambiguous.

00:09:03.060 --> 00:09:08.210
So a program will do what
you tell it to do and

00:09:08.210 --> 00:09:09.460
no more and no less.

00:09:11.800 --> 00:09:15.550
And a statement doesn't
mean two things.

00:09:15.550 --> 00:09:19.450
So like if I make the statement
in English, I cannot

00:09:19.450 --> 00:09:21.610
say enough good things or
recommend this person highly

00:09:21.610 --> 00:09:26.320
enough, if you write that out
that can be considered a

00:09:26.320 --> 00:09:27.900
statement with two different
meanings.

00:09:27.900 --> 00:09:29.870
One of them is not too
complimentary.

00:09:29.870 --> 00:09:31.500
All right.

00:09:31.500 --> 00:09:35.390
So when you're writing your
programs, if it's not doing

00:09:35.390 --> 00:09:38.900
what you think it's doing, one
of the skills that you need to

00:09:38.900 --> 00:09:42.040
learn throughout the semester is
to be able to read the code

00:09:42.040 --> 00:09:45.040
and try to follow along in your
mind what's going on.

00:09:45.040 --> 00:09:46.840
It's not magic.

00:09:46.840 --> 00:09:47.760
OK.

00:09:47.760 --> 00:09:49.590
So now we're at Python.

00:09:49.590 --> 00:09:51.510
We're past kind of the generic

00:09:51.510 --> 00:09:53.460
introductory scaffolding stuff.

00:09:53.460 --> 00:09:55.580
Now we're onto something that's
actually gonna be

00:09:55.580 --> 00:10:01.350
meaningful for you for the
next 12, 13, 14 weeks.

00:10:01.350 --> 00:10:01.650
All right.

00:10:01.650 --> 00:10:05.490
So Python is a general
purpose language.

00:10:05.490 --> 00:10:11.190
It's used for all sorts of
things, web development, small

00:10:11.190 --> 00:10:16.180
device development, desktop
programs, et cetera.

00:10:16.180 --> 00:10:21.480
It's an interpreted language,
which means that if I have a

00:10:21.480 --> 00:10:32.070
program, blah, blah, blah, blah,
then Python executes it

00:10:32.070 --> 00:10:33.840
for me straight away.

00:10:33.840 --> 00:10:39.630
Some languages, compiled
languages, have to go through

00:10:39.630 --> 00:10:47.592
a compiler, and then you
have to run them.

00:10:47.592 --> 00:10:48.550
All right.

00:10:48.550 --> 00:10:50.470
It's an extra step.

00:10:50.470 --> 00:10:52.840
The nice thing about having an
interpreted language is that

00:10:52.840 --> 00:10:55.860
as you may changes to the code,
you can instantly see

00:10:55.860 --> 00:10:58.060
what's going on with
your program.

00:10:58.060 --> 00:11:00.280
So.

00:11:00.280 --> 00:11:01.180
See.

00:11:01.180 --> 00:11:02.820
It's got a very simple syntax.

00:11:02.820 --> 00:11:06.820
And it's also very widely used
and has been getting--

00:11:06.820 --> 00:11:08.470
more and more people have
started using it, oh, for the

00:11:08.470 --> 00:11:10.690
past, say, 15 years.

00:11:10.690 --> 00:11:11.760
So.

00:11:11.760 --> 00:11:14.220
10 years ago when I first heard
about it, it was kind of

00:11:14.220 --> 00:11:15.730
like this little
cute language.

00:11:15.730 --> 00:11:17.800
Now it's kind of blossomed into
this wonderful language

00:11:17.800 --> 00:11:19.495
that everyone uses and loves.

00:11:22.450 --> 00:11:23.770
So.

00:11:23.770 --> 00:11:29.140
Programs in Python, and in all
languages, are sequences of

00:11:29.140 --> 00:11:31.350
expressions.

00:11:31.350 --> 00:11:35.065
So this is getting
back to syntax.

00:11:42.800 --> 00:11:47.660
And these expressions, they are
composed of operands and

00:11:47.660 --> 00:11:49.650
operators and functions.

00:11:49.650 --> 00:12:03.970
So let's say, for example,
this is an expression.

00:12:03.970 --> 00:12:05.240
This is a variable name.

00:12:05.240 --> 00:12:08.270
This is the assignment
operator, and

00:12:08.270 --> 00:12:10.830
this is a string literal.

00:12:10.830 --> 00:12:15.580
When I say operand, what
I'm referring to are

00:12:15.580 --> 00:12:17.030
things in the language.

00:12:17.030 --> 00:12:19.470
That's what a literal
and a variable are.

00:12:19.470 --> 00:12:24.290
And then if I say operator, this
is something that does

00:12:24.290 --> 00:12:26.100
something to things.

00:12:26.100 --> 00:12:27.940
So it's--

00:12:27.940 --> 00:12:32.170
this is an example of what we
call an assignment operator.

00:12:32.170 --> 00:12:36.650
What it does is it says, take
what I'm referring to my right

00:12:36.650 --> 00:12:41.920
hand side here, create a name
called myvar, and say that

00:12:41.920 --> 00:12:47.050
every time that I reference
myvar, I get this value.

00:12:47.050 --> 00:12:50.620
We'll talk more about
that later on.

00:12:50.620 --> 00:12:51.606
Um.

00:12:51.606 --> 00:12:52.102
Let's see.

00:12:52.102 --> 00:12:55.330
Where am I going?

00:12:55.330 --> 00:13:00.880
So one important thing to know
about Python is that

00:13:00.880 --> 00:13:01.700
everything--

00:13:01.700 --> 00:13:03.720
so these things--

00:13:03.720 --> 00:13:04.970
are objects.

00:13:19.650 --> 00:13:22.430
For now, you don't have to get
too familiar with what an

00:13:22.430 --> 00:13:24.000
object is just--

00:13:24.000 --> 00:13:27.540
if you know anything, especially
for the first quiz,

00:13:27.540 --> 00:13:28.790
this is something to know.

00:13:33.590 --> 00:13:35.940
These objects, they
have types, right.

00:13:35.940 --> 00:13:38.940
So some types that we have
in Python are ints.

00:13:38.940 --> 00:13:43.182
What are examples of
ints or integers?

00:13:43.182 --> 00:13:43.600
What?

00:13:43.600 --> 00:13:44.870
AUDIENCE: 7.

00:13:44.870 --> 00:13:45.340
PROFESSOR: Yeah.

00:13:45.340 --> 00:13:45.940
Just rattle a few off.

00:13:45.940 --> 00:13:49.970
So 7, 0, negative
1, 2, et cetera.

00:13:49.970 --> 00:13:54.760
Now there's another number
type, floats, right.

00:13:54.760 --> 00:13:58.800
So this is what we normally
think of as real numbers.

00:13:58.800 --> 00:14:02.000
But when you're talking about
real numbers on the computer,

00:14:02.000 --> 00:14:05.240
they are kind of dicey to deal
with-- and we'll actually

00:14:05.240 --> 00:14:07.610
cover that later on in the
semester when we talk about

00:14:07.610 --> 00:14:10.010
kind of the inexactness
of these.

00:14:10.010 --> 00:14:14.020
But for now, just know that
these are numbers with like

00:14:14.020 --> 00:14:14.840
decimal points.

00:14:14.840 --> 00:14:16.090
All right.

00:14:18.620 --> 00:14:19.090
OK.

00:14:19.090 --> 00:14:20.305
Where am I going next?

00:14:20.305 --> 00:14:23.260
AUDIENCE: [INAUDIBLE]?

00:14:23.260 --> 00:14:26.390
PROFESSOR: Actually,
syntactically, yes.

00:14:26.390 --> 00:14:31.300
So one thing that you might
encounter when you're dealing

00:14:31.300 --> 00:14:33.430
with your programs-- this is
kind of off on a tangent--

00:14:33.430 --> 00:14:47.260
is when you say assign a number
to a variable, when you

00:14:47.260 --> 00:14:52.090
have a literal like this number
here, 0, Python infers

00:14:52.090 --> 00:14:53.700
what type you're
talking about.

00:14:53.700 --> 00:14:56.930
So in this case, it's gonna
create a number, and it's

00:14:56.930 --> 00:14:59.030
gonna call it a type integer.

00:14:59.030 --> 00:15:00.530
All right.

00:15:00.530 --> 00:15:08.820
If it sees this, it's gonna
create this variable, and it's

00:15:08.820 --> 00:15:11.020
gonna have a type of float.

00:15:11.020 --> 00:15:13.280
Now, it might seem like
something minor to you right

00:15:13.280 --> 00:15:17.280
now, but when you start doing
some of the math on problem

00:15:17.280 --> 00:15:23.260
set one, if you divide by an
integer, you might run into

00:15:23.260 --> 00:15:31.420
problems, right, because in
computer-land 5 integer

00:15:31.420 --> 00:15:36.700
divided by 2 integer
is equal to 2.

00:15:36.700 --> 00:15:43.920
Whereas in the real world,
it's equal to that.

00:15:43.920 --> 00:15:46.800
So just be aware when you're
working with numbers that you

00:15:46.800 --> 00:15:49.790
need to be aware of their type,
all right, especially

00:15:49.790 --> 00:15:52.210
when you're talking about the
different operations you can

00:15:52.210 --> 00:15:52.790
do on them.

00:15:52.790 --> 00:15:54.040
So.

00:15:59.500 --> 00:16:04.990
So for these number types, you
have addition, subtraction,

00:16:04.990 --> 00:16:07.540
multiplication, division.

00:16:07.540 --> 00:16:11.910
For integers, exponentiation,
which is

00:16:11.910 --> 00:16:15.750
represented by two asterisks.

00:16:15.750 --> 00:16:19.220
And for integers, modulo.

00:16:19.220 --> 00:16:22.900
And then for floats
plus, minus, same

00:16:22.900 --> 00:16:25.020
thing except no modulo.

00:16:27.790 --> 00:16:29.240
All right.

00:16:29.240 --> 00:16:30.920
So back to the list.

00:16:30.920 --> 00:16:31.980
AUDIENCE: Can I ask
a quick question?

00:16:31.980 --> 00:16:32.722
PROFESSOR: Yes.

00:16:32.722 --> 00:16:36.096
AUDIENCE: Could you explain
why like maybe briefly 5

00:16:36.096 --> 00:16:37.542
divided by 2 is 2?

00:16:37.542 --> 00:16:39.470
You said in computer-land,
like what?

00:16:39.470 --> 00:16:40.930
Is it doing some sort
of weird rounding?

00:16:40.930 --> 00:16:44.810
Or like why, why is that
different than--?

00:16:44.810 --> 00:16:47.270
PROFESSOR: This is because
the type of the

00:16:47.270 --> 00:16:48.980
variable is an integer.

00:16:48.980 --> 00:16:52.180
And when you say something is
an integer, you're talking

00:16:52.180 --> 00:16:54.100
about only these
numbers, right.

00:16:54.100 --> 00:16:59.800
So 2 and a 1/2 as an integer
doesn't exist.

00:16:59.800 --> 00:17:01.460
It only exists as a float.

00:17:01.460 --> 00:17:06.770
But when you have an operand
like this that takes two

00:17:06.770 --> 00:17:10.750
numbers on both sides, if both
numbers are integers, this

00:17:10.750 --> 00:17:13.410
produces a result that
is an integer.

00:17:13.410 --> 00:17:20.020
So when you have these math
operators, these produce a

00:17:20.020 --> 00:17:22.010
result, right.

00:17:22.010 --> 00:17:25.900
So that result has
a type as well.

00:17:25.900 --> 00:17:29.860
Because I can take that
result and I say c is

00:17:29.860 --> 00:17:31.650
equal to 5 and 1/2.

00:17:31.650 --> 00:17:33.750
C is now a variable
in the language.

00:17:33.750 --> 00:17:35.610
That means that it has
to have a type.

00:17:35.610 --> 00:17:39.280
And Python says that because I
did this operation with two

00:17:39.280 --> 00:17:42.460
integers, I'm gonna give it
a type as an integer.

00:17:42.460 --> 00:17:44.990
And the closest representation
to 2 and 1/2 in

00:17:44.990 --> 00:17:46.734
integer terms is 2.

00:17:46.734 --> 00:17:49.204
AUDIENCE: I thought it
would round up to 3.

00:17:49.204 --> 00:17:51.593
I assumed that it would round
up to [UNINTELLIGIBLE].

00:17:51.593 --> 00:17:52.840
PROFESSOR: Oh, yeah.

00:17:52.840 --> 00:17:55.310
You're talking about
a separate issue.

00:17:55.310 --> 00:17:58.980
It's not necessarily that it's
closest, but it truncates.

00:17:58.980 --> 00:17:59.380
AUDIENCE: OK.

00:17:59.380 --> 00:18:00.880
PROFESSOR: So when
it converts--

00:18:00.880 --> 00:18:02.987
yeah, it just truncates
the decimal.

00:18:02.987 --> 00:18:04.935
AUDIENCE: What happens if you
have 5 divided by 2--

00:18:04.935 --> 00:18:06.185
[UNINTELLIGIBLE]?

00:18:08.350 --> 00:18:10.530
PROFESSOR: So when you get into
stuff like that, Python's

00:18:10.530 --> 00:18:15.180
gonna look at, see it's an
integer and a float, and--

00:18:15.180 --> 00:18:16.760
this is something that we're
gonna have to actually test

00:18:16.760 --> 00:18:19.370
out when I turn on
the computer.

00:18:19.370 --> 00:18:21.580
It should convert to a float,
but it might not.

00:18:21.580 --> 00:18:21.855
So.

00:18:21.855 --> 00:18:23.510
We'll test that out, actually.

00:18:23.510 --> 00:18:26.170
That's one of the nice things
about Python is that if you

00:18:26.170 --> 00:18:28.370
have a question like that,
you can test it out

00:18:28.370 --> 00:18:29.570
instantaneously.

00:18:29.570 --> 00:18:37.760
So remind me ints divided
by float, and

00:18:37.760 --> 00:18:39.332
we'll demonstrate it.

00:18:39.332 --> 00:18:42.170
OK.

00:18:42.170 --> 00:18:42.790
All right.

00:18:42.790 --> 00:18:47.670
So another data type, string.

00:18:47.670 --> 00:18:50.680
Anyone know what a string
is or can tell me?

00:18:50.680 --> 00:18:52.256
Shout it out.

00:18:52.256 --> 00:18:52.890
Pantomime it.

00:18:52.890 --> 00:18:54.140
AUDIENCE: Sequence
of characters.

00:18:54.140 --> 00:18:55.100
PROFESSOR: OK.

00:18:55.100 --> 00:18:56.945
So it's something like this.

00:19:00.952 --> 00:19:01.870
All right.

00:19:01.870 --> 00:19:02.890
And you can--

00:19:02.890 --> 00:19:04.400
does anyone mind if
I erase this?

00:19:09.480 --> 00:19:12.740
So in Python, you can specify
strings a couple ways.

00:19:12.740 --> 00:19:14.900
One is with single quotes
on the sides.

00:19:14.900 --> 00:19:16.585
And the other is with
double quotes.

00:19:22.280 --> 00:19:25.260
This is useful, for example,
if you need to embed quotes

00:19:25.260 --> 00:19:26.340
inside a string.

00:19:26.340 --> 00:19:40.970
So if I need to, say, have this
as a quoted string, I

00:19:40.970 --> 00:19:42.910
would have single quotes on the
outside and then double

00:19:42.910 --> 00:19:44.910
quotes on the inside,
or vice versa.

00:19:44.910 --> 00:19:47.500
I could do double quotes
and then single quotes.

00:19:47.500 --> 00:19:51.160
The point is that Python needs
to know when and where the

00:19:51.160 --> 00:19:55.060
string starts and where
the string ends.

00:19:55.060 --> 00:19:56.452
We good?

00:19:56.452 --> 00:19:58.340
All right.

00:19:58.340 --> 00:19:59.590
AUDIENCE: [UNINTELLIGIBLE].

00:20:03.060 --> 00:20:10.250
PROFESSOR: So if you put that?

00:20:10.250 --> 00:20:12.600
If you write this, Python's
gonna call that a string.

00:20:12.600 --> 00:20:15.286
It's a string that contains
the character two, though.

00:20:15.286 --> 00:20:16.536
All right.

00:20:18.530 --> 00:20:20.950
I guess you're asking
because of the input

00:20:20.950 --> 00:20:21.830
with the problem set?

00:20:21.830 --> 00:20:24.144
AUDIENCE: --divide that by a
string, by an integer that

00:20:24.144 --> 00:20:25.780
would [UNINTELLIGIBLE].

00:20:25.780 --> 00:20:27.830
PROFESSOR: So in your program,
there's a point where you have

00:20:27.830 --> 00:20:32.080
to enter in numbers
for problem set 1.

00:20:32.080 --> 00:20:33.330
Oh, you didn't start?

00:20:35.470 --> 00:20:38.270
Well there is a place where
you have to enter numbers.

00:20:38.270 --> 00:20:58.260
So raw_input, for example, is
gonna return a variable, and

00:20:58.260 --> 00:21:00.260
the type of this is
gonna be a string.

00:21:00.260 --> 00:21:04.440
So if you need to use it as an
integer or as a float, you can

00:21:04.440 --> 00:21:05.690
convert it.

00:21:15.610 --> 00:21:20.760
So now this is an integer, and
you can do math with it.

00:21:20.760 --> 00:21:22.280
Or you can also say--

00:21:34.700 --> 00:21:36.450
Does that make sense?

00:21:36.450 --> 00:21:39.160
That's something that'll be
useful in your problem set.

00:21:39.160 --> 00:21:42.719
So just FYI.

00:21:42.719 --> 00:21:44.110
All right.

00:21:44.110 --> 00:21:47.050
Another data type, Boolean.

00:21:50.250 --> 00:21:53.620
Does anyone know what
a Boolean is?

00:21:53.620 --> 00:21:55.970
AUDIENCE: [UNINTELLIGIBLE].

00:21:55.970 --> 00:21:56.780
PROFESSOR: What's that?

00:21:56.780 --> 00:21:58.082
AUDIENCE: It's like an
if-then statement?

00:21:58.082 --> 00:21:59.660
PROFESSOR: It has to
do with if-then

00:21:59.660 --> 00:22:02.300
statements, but it's a variable.

00:22:02.300 --> 00:22:08.108
It's a type that only has two
values, true or false.

00:22:08.108 --> 00:22:09.530
OK.

00:22:09.530 --> 00:22:12.870
And we'll talk about this, all
of these, when I start talking

00:22:12.870 --> 00:22:16.570
about operations on them.

00:22:16.570 --> 00:22:21.750
Last one that you need to know
of right now is the none type.

00:22:21.750 --> 00:22:23.420
The way to think about none
is that it's sort

00:22:23.420 --> 00:22:27.070
of like dark matter.

00:22:27.070 --> 00:22:27.810
It's there.

00:22:27.810 --> 00:22:28.700
We know it's there.

00:22:28.700 --> 00:22:33.920
It holds a place, but we can't
do anything with it.

00:22:33.920 --> 00:22:37.140
It's there just so that you know
that there's a variable

00:22:37.140 --> 00:22:38.900
that should refer to something
but that something doesn't

00:22:38.900 --> 00:22:41.650
exactly exist.

00:22:41.650 --> 00:22:42.580
OK.

00:22:42.580 --> 00:22:43.430
You'll see more of it.

00:22:43.430 --> 00:22:47.550
But it's nothing,
but it's there.

00:22:47.550 --> 00:22:50.670
And then later on
in the semester,

00:22:50.670 --> 00:22:51.910
there's other data types.

00:22:51.910 --> 00:22:54.350
I mean, there's a lot of data
types, but these are the big

00:22:54.350 --> 00:22:56.050
ones that you need to
know right now.

00:22:56.050 --> 00:23:01.680
Other data types that we might
look at are lists, tuples, and

00:23:01.680 --> 00:23:02.930
dictionaries.

00:23:07.500 --> 00:23:09.610
These are other major data
types in Python.

00:23:09.610 --> 00:23:12.040
You don't need to know them
right now 'cause Professor

00:23:12.040 --> 00:23:14.420
Guttag will go over
them in lecture.

00:23:14.420 --> 00:23:18.840
But just keep them
in your brain.

00:23:18.840 --> 00:23:19.230
OK.

00:23:19.230 --> 00:23:22.650
So we've already talked about
the operations that we can do

00:23:22.650 --> 00:23:23.100
on numbers.

00:23:23.100 --> 00:23:25.150
We can also do operations
on strings.

00:23:25.150 --> 00:23:27.630
So we can do something
called concatenation.

00:23:32.960 --> 00:23:35.780
So concatenation is just
a big word for

00:23:35.780 --> 00:23:37.270
sticking two things together.

00:23:37.270 --> 00:23:52.130
So if I have s1 and s2 and I
want to concatenate them to

00:23:52.130 --> 00:23:58.710
together, I use the
plus operator.

00:23:58.710 --> 00:24:05.050
So the other thing, too, that I
want to point out is that we

00:24:05.050 --> 00:24:06.410
have a plus operator for ints.

00:24:06.410 --> 00:24:07.680
We got a plus operator
for float.

00:24:07.680 --> 00:24:10.598
We've got one for strings.

00:24:10.598 --> 00:24:13.030
I don't think they work for
bools, but they work for lists

00:24:13.030 --> 00:24:14.280
and tuples.

00:24:17.020 --> 00:24:19.410
This is what's known as an
overloaded operator.

00:24:19.410 --> 00:24:23.810
So it changes shape or changes
its behavior depending on the

00:24:23.810 --> 00:24:26.890
data types of its operands.

00:24:26.890 --> 00:24:32.460
So that's why when you're
dividing an ints by a float,

00:24:32.460 --> 00:24:35.260
some languages will convert
it to a float for you.

00:24:35.260 --> 00:24:37.800
Other languages will
convert to an ints.

00:24:40.410 --> 00:24:41.820
It's something that varies.

00:24:41.820 --> 00:24:44.464
That's why I'm not sure of
my answer right now.

00:24:44.464 --> 00:24:45.358
So.

00:24:45.358 --> 00:24:47.600
AUDIENCE: [INAUDIBLE]?

00:24:47.600 --> 00:24:47.980
PROFESSOR: No.

00:24:47.980 --> 00:24:49.430
If your computer blows
up in your face,

00:24:49.430 --> 00:24:52.890
then that's an issue.

00:24:52.890 --> 00:24:54.140
That's a separate issue.

00:24:57.363 --> 00:24:58.860
All right.

00:24:58.860 --> 00:25:07.320
So some other operations that
we have, and they relate to

00:25:07.320 --> 00:25:15.750
Booleans, are comparison
operations.

00:25:22.060 --> 00:25:27.920
What these mean are these take
two operands and compare them.

00:25:27.920 --> 00:25:30.397
So if I want to see if--

00:25:38.190 --> 00:25:42.420
if I say a less than b and a is
2 and b is 3, then this is

00:25:42.420 --> 00:25:45.040
gonna return true.

00:25:45.040 --> 00:25:49.830
The value of this expression
becomes true.

00:25:49.830 --> 00:25:53.550
And if I say a greater than
b, obviously it's

00:25:53.550 --> 00:25:56.270
gonna be false, right.

00:25:56.270 --> 00:25:59.640
And all of these operators
work in

00:25:59.640 --> 00:26:01.020
basically the same way.

00:26:01.020 --> 00:26:02.690
They take two operations,
and they give you a

00:26:02.690 --> 00:26:04.215
Boolean value back.

00:26:04.215 --> 00:26:05.465
All right.

00:26:08.040 --> 00:26:09.197
Any questions on that?

00:26:09.197 --> 00:26:11.385
AUDIENCE: So are Boolean values
always true or false?

00:26:11.385 --> 00:26:14.470
PROFESSOR: Always
true or false.

00:26:14.470 --> 00:26:16.560
And I'm actually gonna
get to that now.

00:26:16.560 --> 00:26:21.720
So Boolean values-- and this is
kind of the last major one

00:26:21.720 --> 00:26:22.960
we're gonna talk about--

00:26:22.960 --> 00:26:32.500
have three operators,
AND, OR, and NOT.

00:26:32.500 --> 00:26:33.900
Actually, these should
be lowercase.

00:26:36.900 --> 00:26:45.250
These, AND and OR, take two
operands, NOT takes one.

00:26:45.250 --> 00:26:57.940
And what they do is if you have
something like a is true,

00:26:57.940 --> 00:27:08.400
b is true, c is false, if you
say like a AND b, then this

00:27:08.400 --> 00:27:11.050
entire expression is gonna
return true, right.

00:27:13.630 --> 00:27:19.940
If I say a AND c, this
will be false.

00:27:19.940 --> 00:27:25.360
AND returns true, if and only
if both operands are true,

00:27:25.360 --> 00:27:27.310
false otherwise.

00:27:27.310 --> 00:27:40.270
If you say a OR c, OR returns
true if both operands or one

00:27:40.270 --> 00:27:41.280
operand is true.

00:27:41.280 --> 00:27:43.780
So if any of them are true
or both are true.

00:27:43.780 --> 00:27:45.495
If they're both false, then
it returns false.

00:27:48.700 --> 00:27:57.100
And NOT, all this does is if I
say NOT a, it'll return false.

00:27:57.100 --> 00:27:59.690
It reverses it.

00:27:59.690 --> 00:28:01.290
Now we can combine
these together.

00:28:01.290 --> 00:28:08.310
So these are very simple
expressions, but we can also

00:28:08.310 --> 00:28:08.910
combine them.

00:28:08.910 --> 00:28:16.590
So we can say like a
AND b OR c, right.

00:28:16.590 --> 00:28:20.480
So if both a amd b are true,
then this becomes true.

00:28:20.480 --> 00:28:24.430
And then this entire expression
becomes true if

00:28:24.430 --> 00:28:27.140
this part is true or
this part is true.

00:28:27.140 --> 00:28:31.550
So you can build up pretty
complicated expressions.

00:28:31.550 --> 00:28:33.980
And then the way that they
relate to these logical

00:28:33.980 --> 00:28:38.460
operators is, remember, these
take numbers on either side

00:28:38.460 --> 00:28:40.170
and they produce
Boolean values.

00:28:40.170 --> 00:28:42.730
So if I have--

00:28:49.900 --> 00:28:52.950
I can say d is less than e.

00:28:52.950 --> 00:28:58.410
This is gonna give me a Boolean
value, right, which I

00:28:58.410 --> 00:29:03.480
can then use the AND operator
on and I can say--

00:29:07.080 --> 00:29:11.460
So what this does is it says if
d is less than e and e is

00:29:11.460 --> 00:29:15.720
less than f, then return true.

00:29:15.720 --> 00:29:18.250
This, by the way, would check to
see that these numbers are

00:29:18.250 --> 00:29:24.350
in order, so 3, 4, 5, as
opposed to 5, 4, 3.

00:29:24.350 --> 00:29:26.550
So is everyone good
on all that?

00:29:26.550 --> 00:29:28.070
Did I lose anyone?

00:29:28.070 --> 00:29:30.020
No questions?

00:29:30.020 --> 00:29:31.270
All right.

00:29:34.700 --> 00:29:37.730
So the last couple of things and
then I'm gonna turn on the

00:29:37.730 --> 00:29:40.130
computer and actually walk
through some code with you and

00:29:40.130 --> 00:29:41.870
we'll be done for the day.

00:29:41.870 --> 00:29:47.870
So this is kind of the crash
course in basic syntax for our

00:29:47.870 --> 00:29:50.680
basic types for Python.

00:29:50.680 --> 00:29:53.690
So there were three--

00:29:59.520 --> 00:30:03.500
So what we have now is a way to
create programs that run in

00:30:03.500 --> 00:30:04.870
a straight line, right.

00:30:04.870 --> 00:30:09.120
So can anyone give me kind of a
synopsis of what a straight

00:30:09.120 --> 00:30:10.370
line program is?

00:30:12.520 --> 00:30:13.960
AUDIENCE: Go down
line by line.

00:30:13.960 --> 00:30:14.440
PROFESSOR: What's that?

00:30:14.440 --> 00:30:16.370
AUDIENCE: Everything one--
go down line by line.

00:30:16.370 --> 00:30:19.100
PROFESSOR: Go down line by
line, do everything once.

00:30:19.100 --> 00:30:20.610
All right.

00:30:20.610 --> 00:30:22.590
The problem is that this
doesn't allow us to do

00:30:22.590 --> 00:30:23.600
anything, right.

00:30:23.600 --> 00:30:24.850
So we have branching.

00:30:30.930 --> 00:30:34.000
This is implemented
by something

00:30:34.000 --> 00:30:36.700
called an IF statement.

00:30:36.700 --> 00:30:38.930
Now, the way you use an
IF statement is--

00:30:59.846 --> 00:31:02.580
all right.

00:31:02.580 --> 00:31:04.510
This is the full version
of the IF statement.

00:31:04.510 --> 00:31:08.440
It's saying, if this condition
is true, I'm gonna execute the

00:31:08.440 --> 00:31:11.250
code in this block.

00:31:11.250 --> 00:31:14.140
If this condition is true, if
this condition is false and

00:31:14.140 --> 00:31:15.410
this condition is true,
then I'm gonna

00:31:15.410 --> 00:31:17.840
execute the code here.

00:31:17.840 --> 00:31:20.135
And if none of those
were true, then I

00:31:20.135 --> 00:31:23.350
execute what's here.

00:31:23.350 --> 00:31:25.440
You don't need to have an ELIF,
and you don't need to

00:31:25.440 --> 00:31:25.970
have an ELSE.

00:31:25.970 --> 00:31:30.180
You can just have an IF
or an IF and an ELSE.

00:31:30.180 --> 00:31:36.870
So the three versions
of this branching--

00:31:45.210 --> 00:31:48.470
Now when I, just by way of
explanation, when I draw like

00:31:48.470 --> 00:31:52.250
a line like that, I'm talking
about a block of code.

00:31:52.250 --> 00:31:56.531
Can anyone tell me how Python
represents blocks of code?

00:31:56.531 --> 00:31:56.980
AUDIENCE: Indents?

00:31:56.980 --> 00:31:58.140
PROFESSOR: Yeah.

00:31:58.140 --> 00:31:59.570
So indentation, right.

00:31:59.570 --> 00:32:03.030
We kind of talked about
that on Thursday.

00:32:03.030 --> 00:32:08.070
So blocks of code are chunks
of code that belong kind of

00:32:08.070 --> 00:32:08.990
logically together.

00:32:08.990 --> 00:32:13.240
So what this saying is that if I
execute this, all this block

00:32:13.240 --> 00:32:15.620
is gonna get executed, all this
block is going to get

00:32:15.620 --> 00:32:16.870
executed, et cetera.

00:32:27.270 --> 00:32:35.460
So if I were to represent this
pictorially, then this is kind

00:32:35.460 --> 00:32:38.250
of the main part of the program
and then this is the

00:32:38.250 --> 00:32:40.685
if statement and the block.

00:32:40.685 --> 00:32:42.840
And then it goes back
to whatever code

00:32:42.840 --> 00:32:44.610
is down here, right.

00:32:44.610 --> 00:32:49.010
If I represent this
pictorially, this

00:32:49.010 --> 00:32:52.000
would be the true part.

00:32:52.000 --> 00:32:58.190
So this part of code,
this would be else.

00:33:02.770 --> 00:33:06.410
And then this part would
be multiple excursions.

00:33:06.410 --> 00:33:10.660
So it would look a little
bit like a tree.

00:33:33.200 --> 00:33:33.730
All right.

00:33:33.730 --> 00:33:39.286
So different branches for the
different bits of code.

00:33:39.286 --> 00:33:40.640
Is everyone puzzled on that?

00:33:40.640 --> 00:33:42.800
Or anyone puzzled on that?

00:33:42.800 --> 00:33:43.870
OK.

00:33:43.870 --> 00:33:45.820
And there was a last
bit of flow control

00:33:45.820 --> 00:33:47.160
that we talked about.

00:33:47.160 --> 00:33:49.940
What was it?

00:33:49.940 --> 00:33:52.938
So if we want to do something
multiple times?

00:33:52.938 --> 00:33:54.240
AUDIENCE: Iterations or loops

00:33:54.240 --> 00:33:57.030
PROFESSOR: Iterations
or loops, right.

00:33:57.030 --> 00:34:11.510
So it's called a loop because
it looks like a loop in the

00:34:11.510 --> 00:34:13.230
code, right.

00:34:13.230 --> 00:34:15.429
And there's two variants.

00:34:15.429 --> 00:34:17.449
There's a WHILE loop and
there's a FOR loop.

00:34:25.609 --> 00:34:29.600
A FOR loop is when you want
to iterate over a

00:34:29.600 --> 00:34:30.850
finite set of elements.

00:34:34.030 --> 00:34:46.250
So what this FOR loop does is
it says I'm gonna take--

00:34:46.250 --> 00:34:50.440
this is the range function,
so we'll talk about this

00:34:50.440 --> 00:34:51.440
a little bit later.

00:34:51.440 --> 00:34:55.809
But all it does is it gives me
all the numbers from 1 to 9.

00:34:55.809 --> 00:34:58.530
It goes 1 past.

00:34:58.530 --> 00:34:59.260
So.

00:34:59.260 --> 00:35:02.150
But you don't need to
know it just yet.

00:35:02.150 --> 00:35:04.290
What this is telling Python,
though, is that we're gonna

00:35:04.290 --> 00:35:10.270
execute this block of code
9 times, all right.

00:35:10.270 --> 00:35:14.070
And on each iteration through
this block of code, we're

00:35:14.070 --> 00:35:19.440
gonna set i to 1, and then set
it to 2, set it to 3, 4, 5, 6,

00:35:19.440 --> 00:35:22.080
7, 8, 9, 10.

00:35:22.080 --> 00:35:25.050
Anyone lost by that?

00:35:25.050 --> 00:35:27.900
We'll see an example of
it pretty shortly.

00:35:27.900 --> 00:35:32.066
And then the last one
is a WHILE loop.

00:35:32.066 --> 00:35:37.710
A WHILE loop executes as long
as a condition is true.

00:35:37.710 --> 00:35:39.633
So it's useful--

00:35:43.130 --> 00:35:44.380
don't want to do that.

00:35:49.090 --> 00:35:54.210
It's useful when you're not
necessarily iterating over

00:35:54.210 --> 00:35:59.210
this finite set of elements or
you don't necessarily know how

00:35:59.210 --> 00:36:02.040
many times you need to execute
a specific loop.

00:36:02.040 --> 00:36:04.500
You just know that you need to
keep executing this code while

00:36:04.500 --> 00:36:06.420
something is true.

00:36:06.420 --> 00:36:09.470
And we'll see an example
of that pretty quickly.

00:36:09.470 --> 00:36:15.140
So I basically shotgun blasted a
whole bunch of stuff at you.

00:36:15.140 --> 00:36:17.890
Is there anything that people
want me to touch on before I

00:36:17.890 --> 00:36:21.580
pull down the screen and we
start looking at code?

00:36:21.580 --> 00:36:22.460
All right.

00:36:22.460 --> 00:36:28.468
So has everyone been able
to get Python set up?

00:36:28.468 --> 00:36:29.810
All right.

00:36:29.810 --> 00:36:32.010
So you'll know that this is
the editor window, right.

00:36:32.010 --> 00:36:34.440
So what we use to edit
longer scripts in?

00:36:34.440 --> 00:36:36.310
And you know that this is
the interactive prompt.

00:36:36.310 --> 00:36:40.230
Before I forget, let's see what
happens if I divide the

00:36:40.230 --> 00:36:44.070
integer 5 by the float 2.

00:36:44.070 --> 00:36:46.130
So Python does what you would
hope it would do.

00:36:46.130 --> 00:36:47.955
It turns it into a float.

00:36:47.955 --> 00:36:52.670
If I do this, though,
it gives me 2.

00:36:52.670 --> 00:36:53.240
All right.

00:36:53.240 --> 00:36:54.490
So it's an easy way to test.

00:36:57.320 --> 00:37:00.650
So we've got two chunks
of code here that

00:37:00.650 --> 00:37:01.900
I want to go over.

00:37:04.350 --> 00:37:06.670
One of them, you've
already seen.

00:37:06.670 --> 00:37:11.040
It's the program that tries
to find the cube root of a

00:37:11.040 --> 00:37:12.900
perfect cube.

00:37:12.900 --> 00:37:18.900
And why don't we just walk
through it and read the code?

00:37:18.900 --> 00:37:19.940
All right.

00:37:19.940 --> 00:37:21.470
So here's that raw_input
function

00:37:21.470 --> 00:37:24.170
that I told you about.

00:37:24.170 --> 00:37:26.840
Now, it's gonna take a string
and it's gonna print the

00:37:26.840 --> 00:37:28.010
string out on the screen
and it's gonna

00:37:28.010 --> 00:37:30.500
say enter an integer.

00:37:30.500 --> 00:37:34.890
And, comment this out.

00:37:41.550 --> 00:37:42.920
So let's enter--

00:37:42.920 --> 00:37:46.376
what's a perfect cube?

00:37:46.376 --> 00:37:54.010
All right, the return type of
raw_input is a string, right.

00:37:54.010 --> 00:37:58.730
So that int will convert to x.

00:37:58.730 --> 00:38:03.890
Now, here's an example of
a loop, the WHILE loop.

00:38:03.890 --> 00:38:08.600
And because we don't have
knowledge of what the user's

00:38:08.600 --> 00:38:12.850
gonna input when the program
is run, a while loop is an

00:38:12.850 --> 00:38:17.850
appropriate kind of control
loop to use, right.

00:38:17.850 --> 00:38:25.770
Because we can test a condition
where our guess,

00:38:25.770 --> 00:38:29.440
which is what's represented by
ans, if we cube it, is it

00:38:29.440 --> 00:38:32.432
still less than x.

00:38:32.432 --> 00:38:33.370
All right.

00:38:33.370 --> 00:38:37.070
I explained that a little
bit incorrectly.

00:38:37.070 --> 00:38:40.040
What we're doing here is we're
making a guess, and we're

00:38:40.040 --> 00:38:42.390
calling it ans right now,
and we're gonna set it

00:38:42.390 --> 00:38:45.290
initially to zero.

00:38:45.290 --> 00:38:47.200
And then we're gonna enter
this WHILE loop and we're

00:38:47.200 --> 00:38:49.920
gonna say we're gonna take
answer and we're gonna

00:38:49.920 --> 00:38:51.000
multiply it three times.

00:38:51.000 --> 00:38:53.400
We're gonna cube it.

00:38:53.400 --> 00:38:59.190
And if the value of ans cubed
is less than whatever input

00:38:59.190 --> 00:39:03.160
the user gave us, then we're
gonna keep looping.

00:39:03.160 --> 00:39:07.380
And on each loop, we're gonna
increase the value of our

00:39:07.380 --> 00:39:10.590
guess for ans, right.

00:39:10.590 --> 00:39:16.780
And if it turns out that x is a
perfect cube, eventually, by

00:39:16.780 --> 00:39:22.450
just iterating through all the
integers from 1 to whatever,

00:39:22.450 --> 00:39:27.810
whatever the cube root of x is,
we will find the answer.

00:39:27.810 --> 00:39:32.310
And we'll know we find the
answer because answer cubed is

00:39:32.310 --> 00:39:35.180
going be less than x.

00:39:35.180 --> 00:39:39.910
Now, can anyone tell me
why we have abs here?

00:39:42.784 --> 00:39:44.700
AUDIENCE: The absolute value.

00:39:44.700 --> 00:39:45.250
PROFESSOR: Right.

00:39:45.250 --> 00:39:51.036
So let's say that the user
entered in like negative 27.

00:39:51.036 --> 00:39:53.220
It still has a cube, right.

00:39:53.220 --> 00:39:57.060
It's still negative 3.

00:39:57.060 --> 00:40:00.750
But the way that we set up our
loop, if we were to take this

00:40:00.750 --> 00:40:05.500
out, the program would just
continue executing forever.

00:40:05.500 --> 00:40:09.140
Well, for actually a very,
very long time, but--

00:40:09.140 --> 00:40:10.845
the universe would die
before this finished.

00:40:13.850 --> 00:40:15.340
So we have this absolute
value here.

00:40:15.340 --> 00:40:16.405
Is anyone puzzled by this?

00:40:16.405 --> 00:40:19.322
Do I need to belabor
the point?

00:40:19.322 --> 00:40:21.310
OK.

00:40:21.310 --> 00:40:27.370
So eventually I've entered
27 and we can actually--

00:40:27.370 --> 00:40:29.800
a good way to kind of check
ourselves is to print out

00:40:29.800 --> 00:40:31.050
diagnostic input.

00:40:33.300 --> 00:40:37.620
So if guess is 1, that's not--

00:40:37.620 --> 00:40:39.660
1 cubed is obviously not 27.

00:40:39.660 --> 00:40:40.890
2 cubed is not 27.

00:40:40.890 --> 00:40:42.100
3 cubed is 27.

00:40:42.100 --> 00:40:46.330
And when we get to that point,
we leave the loop.

00:40:46.330 --> 00:40:49.510
And now we're down in
this bit of code.

00:40:49.510 --> 00:40:50.980
All right.

00:40:50.980 --> 00:40:56.660
Now, because we're asking for
cube roots, we need to check

00:40:56.660 --> 00:41:04.150
the condition for when the--

00:41:04.150 --> 00:41:08.440
sorry, I'm kind of
mixed up here.

00:41:08.440 --> 00:41:10.950
Sorry.

00:41:10.950 --> 00:41:17.530
So when we exit the WHILE loop,
if we've had a number

00:41:17.530 --> 00:41:23.810
that's not a perfect cube, then
we know that the value

00:41:23.810 --> 00:41:31.670
the answer stopped on is not
going to equal the cube of it,

00:41:31.670 --> 00:41:32.920
by way of explanation.

00:41:51.060 --> 00:41:54.960
So my last guess
3 cubed is 27.

00:41:54.960 --> 00:41:57.650
Let's run it again.

00:41:57.650 --> 00:42:06.280
Let's say that I
have 20, right.

00:42:06.280 --> 00:42:08.460
So what happens is
it gets to 4.

00:42:08.460 --> 00:42:11.310
So 4 cubed is 64, right.

00:42:11.310 --> 00:42:12.560
That's obviously not 28.

00:42:16.340 --> 00:42:18.480
And that's what this
condition checks.

00:42:18.480 --> 00:42:20.570
And so it knows that if it gets
to that point, it's not a

00:42:20.570 --> 00:42:21.820
perfect cube.

00:42:24.180 --> 00:42:32.830
Now, this ELIF statement here
says, OK, so if this turns out

00:42:32.830 --> 00:42:35.830
to be true, that means that
it wasn't a perfect cube.

00:42:35.830 --> 00:42:39.850
But let's say that it was a
perfect cube, this will be

00:42:39.850 --> 00:42:43.530
true, and Python will then start
to look at this and say,

00:42:43.530 --> 00:42:46.070
well, let's look at this if
condition, or actually--

00:42:46.070 --> 00:42:48.340
I'm sorry.

00:42:48.340 --> 00:42:51.860
This condition will be false if
it's a perfect cube, right.

00:42:54.990 --> 00:42:57.330
And Python will say, OK, look
at the next part of the

00:42:57.330 --> 00:43:01.420
IF-ELIF statement and will say,
well, was x less than 0?

00:43:01.420 --> 00:43:06.580
What it's doing here, it's
checking whether or not we've

00:43:06.580 --> 00:43:09.350
entered a negative
number or not.

00:43:09.350 --> 00:43:19.560
So if we enter negative 27, what
it would do is it would

00:43:19.560 --> 00:43:22.040
to enter this branch, and then
it would negate whatever

00:43:22.040 --> 00:43:22.780
answer it got.

00:43:22.780 --> 00:43:25.320
Because we found the answer
for a positive

00:43:25.320 --> 00:43:26.944
perfect cube, right.

00:43:34.324 --> 00:43:35.646
Did I break it?

00:43:47.570 --> 00:43:48.820
We are having technical
difficulties.

00:43:52.896 --> 00:43:55.895
Oh, OK.

00:43:55.895 --> 00:43:58.382
I'm not sure what
happened there.

00:43:58.382 --> 00:44:01.340
So anyway.

00:44:01.340 --> 00:44:06.620
So we go about trying to find
the cube root of 27, which is

00:44:06.620 --> 00:44:08.340
the absolute value of 27.

00:44:08.340 --> 00:44:10.060
And we, of course, find it.

00:44:10.060 --> 00:44:11.270
It's 3.

00:44:11.270 --> 00:44:15.790
But then because we've entered
a negative number, Python's

00:44:15.790 --> 00:44:18.240
gonna enter this branch and
negate whatever answer we got.

00:44:18.240 --> 00:44:21.110
Because we know that in order
for it to be negative, then it

00:44:21.110 --> 00:44:24.800
would have to have been a
negative number, right.

00:44:24.800 --> 00:44:25.930
Is anyone lost?

00:44:25.930 --> 00:44:27.180
Everyone good?

00:44:30.052 --> 00:44:33.810
AUDIENCE: Do you need an
exclamation mark for the--?

00:44:33.810 --> 00:44:34.840
PROFESSOR: Oh, this one?

00:44:34.840 --> 00:44:35.980
AUDIENCE: Yeah.

00:44:35.980 --> 00:44:39.150
PROFESSOR: So this is one of
the comparison operators.

00:44:39.150 --> 00:44:41.580
This stands for not equal to.

00:44:41.580 --> 00:44:44.470
So if I have--

00:44:47.360 --> 00:44:50.355
do a little Python work here--
if I have a is equal to 5 and

00:44:50.355 --> 00:44:56.330
b is equal to 6, if I say a is
double equal, that's gonna

00:44:56.330 --> 00:44:58.560
check and see if they're
the same value.

00:44:58.560 --> 00:45:00.490
Obviously, they're not, so
it's gonna return false.

00:45:00.490 --> 00:45:05.620
On the other hand, if I say
not equal-- or bang equal

00:45:05.620 --> 00:45:08.060
sometimes we call--

00:45:08.060 --> 00:45:10.852
this will return true.

00:45:10.852 --> 00:45:13.330
OK.

00:45:13.330 --> 00:45:15.305
Any other questions?

00:45:15.305 --> 00:45:19.570
AUDIENCE: The one that you did
28 for, shouldn't it not print

00:45:19.570 --> 00:45:22.930
the cube root of 28 is 4?

00:45:26.770 --> 00:45:27.700
PROFESSOR: Oh.

00:45:27.700 --> 00:45:29.140
Yeah.

00:45:29.140 --> 00:45:37.720
So yeah.

00:45:37.720 --> 00:45:39.620
Should it be indented?

00:45:39.620 --> 00:45:42.010
Because if we indented
here, right, then

00:45:42.010 --> 00:45:42.680
what's gonna happen?

00:45:42.680 --> 00:45:44.200
It's only gonna print
out the cube root

00:45:44.200 --> 00:45:45.890
for negative numbers.

00:45:45.890 --> 00:45:48.940
So what--

00:45:48.940 --> 00:45:49.250
what's that?

00:45:49.250 --> 00:45:50.540
AUDIENCE: [INAUDIBLE].

00:45:50.540 --> 00:45:54.240
PROFESSOR: Well, again, if we
put an ELSE statement, then it

00:45:54.240 --> 00:45:56.580
won't print out the cube root
for negative numbers.

00:45:56.580 --> 00:46:01.800
What we could do, and this is
kind of a hackish way, is

00:46:01.800 --> 00:46:04.250
write it like this.

00:46:04.250 --> 00:46:06.250
But that's kind of ugly,
right, because you're

00:46:06.250 --> 00:46:08.390
repeating yourself.

00:46:08.390 --> 00:46:12.720
And one thing about computer
programmers is that we are the

00:46:12.720 --> 00:46:15.030
laziest people on the
face of the earth.

00:46:15.030 --> 00:46:19.340
Like, we'll spend 20 hours
writing a program to do

00:46:19.340 --> 00:46:23.640
something in five minutes that
we could have originally done

00:46:23.640 --> 00:46:25.670
in 10 minutes.

00:46:25.670 --> 00:46:27.190
It's just our nature.

00:46:27.190 --> 00:46:29.400
So anyway.

00:46:29.400 --> 00:46:30.460
So we're repeating ourselves.

00:46:30.460 --> 00:46:33.530
And while I'm speaking,
this is the

00:46:33.530 --> 00:46:34.740
solution I came up with.

00:46:34.740 --> 00:46:39.210
If I were to go back and rewrite
this, I'd probably

00:46:39.210 --> 00:46:44.740
make it a little bit
less convoluted.

00:46:44.740 --> 00:46:46.110
So maybe, let's try this.

00:46:51.860 --> 00:46:54.680
So we're gonna check if we
were successful, and then

00:46:54.680 --> 00:46:57.530
we're gonna check if
x is less than 0.

00:47:14.890 --> 00:47:18.300
Now we're not repeating
ourselves.

00:47:18.300 --> 00:47:21.630
And we catch all the cases.

00:47:21.630 --> 00:47:24.920
So let's make sure that my fix
works because oftentimes when

00:47:24.920 --> 00:47:28.190
you write programs, you'll
introduced bugs of your own.

00:47:28.190 --> 00:47:30.220
So we've tested when
it is a cube.

00:47:30.220 --> 00:47:33.030
Let's test it when it's not.

00:47:33.030 --> 00:47:34.280
OK.

00:47:38.000 --> 00:47:42.150
So there we fixed it, I think.

00:47:42.150 --> 00:47:45.050
One thing about computer
programs is that this is a

00:47:45.050 --> 00:47:48.690
very simple case, but for
longer, more complicated

00:47:48.690 --> 00:47:50.465
programs, it's almost
impossible to get

00:47:50.465 --> 00:47:51.150
out all of the bugs.

00:47:51.150 --> 00:47:53.250
But in this case, pretty
confident that we were

00:47:53.250 --> 00:47:56.040
successful, right.

00:47:56.040 --> 00:47:58.670
So does anyone else have
any other questions

00:47:58.670 --> 00:48:01.740
on this bit, right?

00:48:01.740 --> 00:48:02.212
All right.

00:48:02.212 --> 00:48:04.820
The last thing that I'm gonna go
over is something called a

00:48:04.820 --> 00:48:07.860
fizzbuzz program.

00:48:07.860 --> 00:48:10.960
This is just a silly
little program.

00:48:10.960 --> 00:48:12.870
This is the English
specification.

00:48:12.870 --> 00:48:16.560
And this is kind of a first
instance of where we're gonna

00:48:16.560 --> 00:48:20.410
take English and kind of break
it down into code, figure out

00:48:20.410 --> 00:48:22.990
how to break it up, chunk it
up, and abstract it into

00:48:22.990 --> 00:48:25.150
something that actually works.

00:48:25.150 --> 00:48:27.960
So the problem is to write a
program the prints the numbers

00:48:27.960 --> 00:48:31.980
from 1 to 100, but for multiples
of three, print fizz

00:48:31.980 --> 00:48:32.710
instead of the number.

00:48:32.710 --> 00:48:34.880
And for multiples of
5, print buzz.

00:48:34.880 --> 00:48:40.170
And if there are multiples are
both 3 and 5, print fizzbuzz.

00:48:40.170 --> 00:48:45.030
So if it says numbers from 1 to
100, when you see something

00:48:45.030 --> 00:48:48.460
like this when you're trying
to figure out how to write

00:48:48.460 --> 00:48:50.400
your programs, the first thing
that should go off in your

00:48:50.400 --> 00:48:53.950
mind is, I probably need a for
loop because I'm iterating

00:48:53.950 --> 00:48:56.990
over a set of numbers.

00:48:56.990 --> 00:49:02.260
So we happen to know the
numbers 1 to 100.

00:49:02.260 --> 00:49:04.030
And here's a range
function again.

00:49:04.030 --> 00:49:08.190
And we'll talk about range
next week most likely.

00:49:08.190 --> 00:49:13.380
And all we're gonna do is first
we're gonna get the

00:49:13.380 --> 00:49:14.990
string value of this number.

00:49:14.990 --> 00:49:19.810
So remember how earlier you
asked if, or one of the

00:49:19.810 --> 00:49:23.150
students asked, if we had a
number in the string, if that

00:49:23.150 --> 00:49:24.400
was a number or not?

00:49:27.250 --> 00:49:28.500
So like this.

00:49:32.280 --> 00:49:34.540
That's what that STR
function does.

00:49:34.540 --> 00:49:39.840
So if I have a variable a is
equal to 1, I can say s is

00:49:39.840 --> 00:49:47.106
equal to STR a, and s is
now gonna be that.

00:49:47.106 --> 00:49:49.040
All right.

00:49:49.040 --> 00:49:52.660
And then what I'm gonna do here
is I'm gonna check the

00:49:52.660 --> 00:49:58.500
integer value, so i, and
see if it's evenly

00:49:58.500 --> 00:50:00.720
divisible by 3 or 5.

00:50:00.720 --> 00:50:02.250
And the way that I
checked that is I

00:50:02.250 --> 00:50:03.800
use a modulo operator.

00:50:03.800 --> 00:50:05.700
That's what that percent
sign is.

00:50:05.700 --> 00:50:10.220
What this operator does is it
takes two integer values and

00:50:10.220 --> 00:50:14.790
it returns the remainder after
you've divided the left

00:50:14.790 --> 00:50:16.910
integer by the right integer.

00:50:16.910 --> 00:50:25.176
So if I have 6 modulo 3,
what's that gonna be?

00:50:25.176 --> 00:50:28.980
It should be 0, right, because
you can divide 6 evenly by 3.

00:50:28.980 --> 00:50:33.390
The other hand, if I say 5
modulo 3, then that's going to

00:50:33.390 --> 00:50:36.064
be 2, right.

00:50:36.064 --> 00:50:40.450
Yeah, I had to think about
it for a second.

00:50:40.450 --> 00:50:40.830
OK.

00:50:40.830 --> 00:50:42.520
So that's all this does.

00:50:42.520 --> 00:50:48.210
And these are two expressions
that return a

00:50:48.210 --> 00:50:49.740
Boolean value, right.

00:50:49.740 --> 00:50:54.250
Because this modulo operation
is gonna return an integer,

00:50:54.250 --> 00:50:57.540
and I'm gonna use the equality
operator to compare it to a

00:50:57.540 --> 00:51:01.020
number, another integer, 0,
and that's gonna give me a

00:51:01.020 --> 00:51:03.580
Boolean value.

00:51:03.580 --> 00:51:06.310
This expression also gives
me a Boolean value.

00:51:06.310 --> 00:51:08.620
And then I'm gonna combine
them into--

00:51:08.620 --> 00:51:11.780
using the or operator
for Boolean values--

00:51:11.780 --> 00:51:14.032
into a larger expression.

00:51:14.032 --> 00:51:18.625
And then if this is true, then
I know that I'm gonna have to

00:51:18.625 --> 00:51:21.210
at lease print fizz,
buzz, or fizzbuzz.

00:51:21.210 --> 00:51:24.110
Because I'm not gonna print
the number, right, because

00:51:24.110 --> 00:51:26.550
it's a multiple of 3 or 5.

00:51:26.550 --> 00:51:32.890
And so all this code does is
just figures out if it's

00:51:32.890 --> 00:51:35.930
evenly divisible by 3, then
I know I print fizz.

00:51:35.930 --> 00:51:38.970
So I'm gonna concatenate my
final string onto it.

00:51:38.970 --> 00:51:44.570
And then if it's evenly
divisible by 5, then I know I

00:51:44.570 --> 00:51:45.530
need to print buzz.

00:51:45.530 --> 00:51:48.620
So then I'm gonna attach
buzz onto my output.

00:51:48.620 --> 00:51:52.250
And then I'm just gonna print
whatever I'm left over with.

00:51:52.250 --> 00:51:56.480
So to see this in action
because we are way out

00:51:56.480 --> 00:51:57.730
of time right now.

00:52:06.980 --> 00:52:12.740
So 1, 2, fizz, 4, buzz,
6, fizz, 7, 8.

00:52:12.740 --> 00:52:14.310
Then we have fizzbuzz for 15.

00:52:14.310 --> 00:52:17.860
So it seems to work.

00:52:17.860 --> 00:52:18.900
Everyone follow that?

00:52:18.900 --> 00:52:20.500
We good?

00:52:20.500 --> 00:52:23.970
So I'm done for this
recitation.