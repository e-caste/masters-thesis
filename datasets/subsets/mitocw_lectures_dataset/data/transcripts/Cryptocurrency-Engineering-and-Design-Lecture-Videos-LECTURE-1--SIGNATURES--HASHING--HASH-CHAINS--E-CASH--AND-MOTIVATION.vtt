WEBVTT

00:00:00.845 --> 00:00:03.220
WOMAN: The following content
is provided under a Creative

00:00:03.220 --> 00:00:04.610
Commons license.

00:00:04.610 --> 00:00:06.820
Your support will help
MIT Open Courseware

00:00:06.820 --> 00:00:10.910
continue to offer high quality
educational resources for free.

00:00:10.910 --> 00:00:13.480
To make a donation or to
view additional materials

00:00:13.480 --> 00:00:15.970
from hundreds of
MIT courses, visit

00:00:15.970 --> 00:00:17.820
mitopencourseware@ocw.mit.edu.

00:00:22.780 --> 00:00:24.850
NEHA NARULA: OK, so
let's get started.

00:00:24.850 --> 00:00:25.430
OK?

00:00:25.430 --> 00:00:26.630
So great.

00:00:26.630 --> 00:00:28.700
We're here to talk
about cryptocurrency

00:00:28.700 --> 00:00:30.009
engineering and design.

00:00:30.009 --> 00:00:32.509
I think the first question that
comes up that's very obvious

00:00:32.509 --> 00:00:34.940
is what is a cryptocurrency?

00:00:34.940 --> 00:00:39.892
So this word was kind of
invented 10 years ago when--

00:00:39.892 --> 00:00:42.350
I don't know how many of you
know the origin story of where

00:00:42.350 --> 00:00:45.800
bitcoin came from, but basically
a pseudonym on the internet

00:00:45.800 --> 00:00:49.700
dropped a paper and
some open source code

00:00:49.700 --> 00:00:52.530
in a forum on an email
list, and said, hey,

00:00:52.530 --> 00:00:55.040
I have this idea for this
thing called bitcoin.

00:00:55.040 --> 00:00:57.055
It's kind of like
electronic cash.

00:00:57.055 --> 00:00:58.430
Here's how I think
it could work,

00:00:58.430 --> 00:01:01.100
and here is some code if you
want to run it and become part

00:01:01.100 --> 00:01:02.820
of this peer-to-peer network.

00:01:02.820 --> 00:01:04.220
We don't know who
this person is.

00:01:04.220 --> 00:01:06.710
This person has basically
virtually disappeared

00:01:06.710 --> 00:01:09.350
from the internet
and from the world.

00:01:09.350 --> 00:01:12.470
But it's created something
that has captured

00:01:12.470 --> 00:01:16.160
so many people's imaginations
and has sort of, depending

00:01:16.160 --> 00:01:18.200
on how you measure
it, created billions

00:01:18.200 --> 00:01:20.690
and billions of dollars
of economic value

00:01:20.690 --> 00:01:24.320
and inspired a lot of
people to think about how

00:01:24.320 --> 00:01:27.710
to use this technology to solve
a myriad of different problems,

00:01:27.710 --> 00:01:30.080
not just electronic payments.

00:01:30.080 --> 00:01:34.160
So cryptocurrencies and
the technology behind them

00:01:34.160 --> 00:01:39.440
are inspiring people to think
about how to bank the unbanked,

00:01:39.440 --> 00:01:43.430
add more auditability and
traceability to our world,

00:01:43.430 --> 00:01:46.730
get rid of trusted
intermediaries and institutions

00:01:46.730 --> 00:01:51.260
in certain situations,
and basically solve

00:01:51.260 --> 00:01:54.770
every problem, if you read
about what blockchains

00:01:54.770 --> 00:01:56.180
can do on the internet.

00:01:56.180 --> 00:01:58.790
Now that's not exactly
what this class is about.

00:01:58.790 --> 00:02:01.670
This class is not going
to be about applications.

00:02:01.670 --> 00:02:04.970
This class is going to be about
technology and infrastructure.

00:02:04.970 --> 00:02:08.120
You're going to learn how to
create a cryptocurrency, what

00:02:08.120 --> 00:02:10.190
goes inside a cryptocurrency,
what's important,

00:02:10.190 --> 00:02:12.050
what are the techniques.

00:02:12.050 --> 00:02:16.408
And what application you choose
to apply that to down the line,

00:02:16.408 --> 00:02:17.450
that's kind of up to you.

00:02:17.450 --> 00:02:20.630
But we're not going to be doing
digital identity or health care

00:02:20.630 --> 00:02:22.250
records or something like that.

00:02:22.250 --> 00:02:25.070
We're going to be talking
about the technology.

00:02:25.070 --> 00:02:28.340
So a big question is
how are cryptocurrencies

00:02:28.340 --> 00:02:30.560
different from
regular currencies?

00:02:30.560 --> 00:02:33.020
And another thing that I
want to make really clear

00:02:33.020 --> 00:02:36.870
is that the terms in this
space are still being defined.

00:02:36.870 --> 00:02:38.660
So you will hear
people throw around

00:02:38.660 --> 00:02:42.140
all sorts of terms--
cryptocurrency, blockchain,

00:02:42.140 --> 00:02:43.000
consensus.

00:02:43.000 --> 00:02:47.060
And these words kind of have
floating, evolving meanings

00:02:47.060 --> 00:02:47.870
right now.

00:02:47.870 --> 00:02:51.590
Part of that is because bitcoin,
the first cryptocurrency,

00:02:51.590 --> 00:02:54.200
didn't come from academia,
as far as we know.

00:02:54.200 --> 00:02:57.590
It came from a community of
enthusiasts on the internet.

00:02:57.590 --> 00:03:01.070
And so it doesn't necessarily
have the same basis and rigor

00:03:01.070 --> 00:03:03.590
that we might expect from
most of our academic fields

00:03:03.590 --> 00:03:04.340
of study.

00:03:04.340 --> 00:03:05.840
It's totally OK.

00:03:05.840 --> 00:03:08.360
We're figuring it
out as we go along.

00:03:08.360 --> 00:03:11.750
And academia is really
embracing this topic.

00:03:11.750 --> 00:03:13.730
So if any of you are
graduate students who

00:03:13.730 --> 00:03:16.220
are looking for an area
in which to do research,

00:03:16.220 --> 00:03:19.148
I think basically,
the number of papers

00:03:19.148 --> 00:03:21.440
published on cryptocurrencies
and blockchain technology

00:03:21.440 --> 00:03:24.630
in respected academic venues
is doubling every year.

00:03:24.630 --> 00:03:27.610
So there's huge
opportunity here.

00:03:27.610 --> 00:03:31.390
So cryptocurrencies are
not regular currencies.

00:03:31.390 --> 00:03:33.880
They're not $1.00 or
a pound or a euro,

00:03:33.880 --> 00:03:35.473
what we normally
think of as currency.

00:03:35.473 --> 00:03:36.640
They're something different.

00:03:36.640 --> 00:03:40.600
Bitcoin was sort of
created out of nowhere.

00:03:40.600 --> 00:03:44.290
And what does it mean to
create a cryptocurrency?

00:03:44.290 --> 00:03:46.240
Who says you can create
a cryptocurrency?

00:03:46.240 --> 00:03:47.860
What backs a cryptocurrency?

00:03:47.860 --> 00:03:49.840
Why is it valuable?

00:03:49.840 --> 00:03:53.663
Well, first, before we
answer that question,

00:03:53.663 --> 00:03:55.330
I just want to make
it really clear what

00:03:55.330 --> 00:03:58.250
this course is not about, OK?

00:03:58.250 --> 00:04:00.520
We are not going
to help you ICO.

00:04:00.520 --> 00:04:04.240
If you are interested
in ICO'ing, just go.

00:04:04.240 --> 00:04:07.210
That's not what this class
is going to be about.

00:04:07.210 --> 00:04:09.910
We are not going to
offer any trading advice.

00:04:09.910 --> 00:04:13.600
We have zero opinions on
whether you should buy bitcoin

00:04:13.600 --> 00:04:16.394
now or sell or
whatever, or zen cash,

00:04:16.394 --> 00:04:17.769
or whatever all
these things are.

00:04:17.769 --> 00:04:19.029
So none of that.

00:04:19.029 --> 00:04:20.050
Don't even ask us.

00:04:20.050 --> 00:04:21.203
We're not interested.

00:04:21.203 --> 00:04:22.620
And this class is
not really going

00:04:22.620 --> 00:04:24.670
to be about permissioned
blockchains either.

00:04:24.670 --> 00:04:27.310
Now you might not know
what this term means yet,

00:04:27.310 --> 00:04:29.770
and that's totally
OK, but I just

00:04:29.770 --> 00:04:32.410
want to make it clear that
what we're talking about here

00:04:32.410 --> 00:04:33.940
are cryptocurrencies.

00:04:33.940 --> 00:04:36.640
They're open permission with
systems in which there is

00:04:36.640 --> 00:04:39.920
a token which has some value.

00:04:39.920 --> 00:04:43.030
So that's what we're not
going to do in the class.

00:04:43.030 --> 00:04:44.780
So going back to--

00:04:44.780 --> 00:04:46.810
and let me just pause
there for a moment.

00:04:46.810 --> 00:04:50.405
Let me pause and ask you if
there are any questions so far

00:04:50.405 --> 00:04:51.280
about what I've said.

00:04:54.930 --> 00:04:55.887
Yeah.

00:04:55.887 --> 00:04:57.720
AUDIENCE: Do they always
have to have value?

00:04:57.720 --> 00:04:58.530
NEHA NARULA: No, not at all.

00:04:58.530 --> 00:04:59.910
And let's start
to get into that.

00:04:59.910 --> 00:05:02.243
So the question was do tokens
always have to have value?

00:05:02.243 --> 00:05:04.830
So I think, really,
to understand

00:05:04.830 --> 00:05:07.680
what are cryptocurrencies, what
are tokens, what do they mean,

00:05:07.680 --> 00:05:10.410
we have to talk about money.

00:05:10.410 --> 00:05:14.970
And we have to talk about what
money is and what it means.

00:05:14.970 --> 00:05:17.730
So this is going to
be very hand-wavy

00:05:17.730 --> 00:05:21.480
and I'm sure not very satisfying
to a real monetary economist.

00:05:21.480 --> 00:05:24.420
But money developed-- there
are a few different theories

00:05:24.420 --> 00:05:26.670
about how money developed.

00:05:26.670 --> 00:05:29.640
There is this thing called
the coincidence of wants.

00:05:29.640 --> 00:05:33.440
So maybe I have a sheep
and Tadge has some wheat.

00:05:33.440 --> 00:05:35.490
I am hungry and would
like to make bread.

00:05:35.490 --> 00:05:38.460
Tadge would really
like to make a sweater.

00:05:38.460 --> 00:05:41.170
And so we can
barter, we can trade.

00:05:41.170 --> 00:05:44.060
I have one set of goods
that is useful to Tadge.

00:05:44.060 --> 00:05:46.380
Tadge has another set of
goods that are useful to me.

00:05:46.380 --> 00:05:49.020
We can get together
and make an exchange.

00:05:49.020 --> 00:05:50.130
So that's fantastic.

00:05:50.130 --> 00:05:51.540
Barter is incredibly important.

00:05:51.540 --> 00:05:53.890
Barter has existed
for a long time.

00:05:53.890 --> 00:05:59.673
But what if Tadge doesn't have
wheat, Tadge has vegetables,

00:05:59.673 --> 00:06:00.840
and I don't want vegetables.

00:06:00.840 --> 00:06:01.440
I want wheat.

00:06:01.440 --> 00:06:04.200
But Tadge still wants
the wool from the sheep.

00:06:04.200 --> 00:06:05.640
How do we execute this trade?

00:06:05.640 --> 00:06:08.010
We don't have a
coincidence of wants.

00:06:08.010 --> 00:06:11.050
We don't actually want the exact
same thing from each other.

00:06:11.050 --> 00:06:16.050
So some theories are that money
evolved out of this problem.

00:06:16.050 --> 00:06:21.540
And money can be represented
in so many different ways.

00:06:21.540 --> 00:06:25.830
Money, I think, was first
created around 5000 BC,

00:06:25.830 --> 00:06:28.680
so it's really,
really, really old.

00:06:28.680 --> 00:06:30.420
The things that
represented money usually

00:06:30.420 --> 00:06:32.250
had certain properties.

00:06:32.250 --> 00:06:33.930
They were rare.

00:06:33.930 --> 00:06:37.800
They were not
easily reproducible.

00:06:37.800 --> 00:06:42.330
People, at times, used things
like shells or beads for money.

00:06:42.330 --> 00:06:45.180
The first coins-- this is
like a really interesting coin

00:06:45.180 --> 00:06:46.320
that was developed.

00:06:46.320 --> 00:06:48.720
Precious metals were
often used for money.

00:06:48.720 --> 00:06:50.700
And then eventually
we sort of evolved

00:06:50.700 --> 00:06:52.920
into what we think
of as money now,

00:06:52.920 --> 00:06:56.790
which is paper bills, currency.

00:06:56.790 --> 00:06:59.340
Another theory of
how money came about

00:06:59.340 --> 00:07:03.840
is this idea of receipts,
debt and credit.

00:07:03.840 --> 00:07:08.400
So maybe I have a sheep,
and I shear all of my sheep

00:07:08.400 --> 00:07:09.990
and collect a lot of wool.

00:07:09.990 --> 00:07:12.810
What I can do is I can
store that wool somewhere.

00:07:12.810 --> 00:07:14.850
And I can get a
receipt from someone

00:07:14.850 --> 00:07:19.440
from having stored that wool,
and that receipt is of value.

00:07:19.440 --> 00:07:23.460
It entitles the person who holds
the receipt to the good that

00:07:23.460 --> 00:07:24.580
is being stored.

00:07:24.580 --> 00:07:27.150
And so another
theory of money is

00:07:27.150 --> 00:07:28.950
that money evolved
out of these receipts,

00:07:28.950 --> 00:07:30.602
trading these receipts
back and forth.

00:07:30.602 --> 00:07:32.310
Instead of taking all
that wool with you,

00:07:32.310 --> 00:07:34.860
you leave it in one
place in a depository,

00:07:34.860 --> 00:07:37.050
and the receipt acts
as a bearer instrument.

00:07:37.050 --> 00:07:42.030
Whoever owns it has access to
the wool in the depository.

00:07:42.030 --> 00:07:44.340
And so you can kind of
see two different ideas

00:07:44.340 --> 00:07:46.560
about what money is
develop from this.

00:07:46.560 --> 00:07:50.160
One is, well, it's
a bead or a coin,

00:07:50.160 --> 00:07:52.050
or something that
I hold, something

00:07:52.050 --> 00:07:55.980
physical that we've
decided to assign value to

00:07:55.980 --> 00:07:57.180
in and of itself.

00:07:57.180 --> 00:08:01.380
And another idea is I'm going
to use a trusted institution.

00:08:01.380 --> 00:08:04.110
I'm going to deposit something
with that institution,

00:08:04.110 --> 00:08:08.010
and they are going to ensure
the validity of that deposit

00:08:08.010 --> 00:08:10.440
and manage who has
access to that deposit.

00:08:13.720 --> 00:08:17.050
So this doesn't really
get at the question

00:08:17.050 --> 00:08:21.550
that was originally asked, which
is why do tokens have value.

00:08:21.550 --> 00:08:25.467
But one thing I want
to point out is--

00:08:25.467 --> 00:08:27.550
well, a question I want
to ask you guys, actually,

00:08:27.550 --> 00:08:29.350
is why do these
things have value?

00:08:29.350 --> 00:08:30.475
Does anyone have any ideas?

00:08:33.679 --> 00:08:34.302
Yes.

00:08:34.302 --> 00:08:36.260
AUDIENCE: Because everyone
agrees that they do.

00:08:36.260 --> 00:08:38.343
NEHA NARULA: Because
everyone agrees that they do.

00:08:38.343 --> 00:08:40.770
Any other thoughts on why
those things have value?

00:08:40.770 --> 00:08:41.270
Yeah.

00:08:41.270 --> 00:08:43.145
AUDIENCE: They're also
backed by institutions

00:08:43.145 --> 00:08:44.147
like the government.

00:08:44.147 --> 00:08:45.980
NEHA NARULA: They're
backed by institutions.

00:08:45.980 --> 00:08:47.355
Say a little bit
more about that.

00:08:47.355 --> 00:08:48.360
What does that mean?

00:08:48.360 --> 00:08:49.777
AUDIENCE: So the
government's kind

00:08:49.777 --> 00:08:52.873
of promising you to
respect the value of that.

00:08:52.873 --> 00:08:53.540
NEHA NARULA: OK.

00:08:53.540 --> 00:08:56.168
The government's promising
to respect the value of that.

00:08:56.168 --> 00:08:58.460
Does anyone want to add to
that or have another reason?

00:08:58.460 --> 00:08:59.600
Yes.

00:08:59.600 --> 00:09:00.350
And say your name.

00:09:00.350 --> 00:09:01.760
I'm sorry, yeah.

00:09:01.760 --> 00:09:03.230
AUDIENCE: Jared Thompson.

00:09:03.230 --> 00:09:05.690
In the example of the
dollar, the government

00:09:05.690 --> 00:09:08.118
is willing to accept it
as payment for taxes.

00:09:08.118 --> 00:09:09.410
NEHA NARULA: Payment for taxes.

00:09:09.410 --> 00:09:09.910
OK.

00:09:09.910 --> 00:09:12.678
So that kind of connects
the government thing.

00:09:12.678 --> 00:09:14.845
AUDIENCE: Even if it had
no value of any other sort,

00:09:14.845 --> 00:09:16.490
it has value in that sense.

00:09:16.490 --> 00:09:19.820
It's the last thing
that holds up its value.

00:09:19.820 --> 00:09:21.380
NEHA NARULA: OK, great.

00:09:21.380 --> 00:09:22.850
Anybody else?

00:09:22.850 --> 00:09:23.420
Yes.

00:09:23.420 --> 00:09:24.380
AUDIENCE: I'm Paul.

00:09:24.380 --> 00:09:28.080
I think those the three on
the front of the dollar,

00:09:28.080 --> 00:09:29.870
those have inherent
value because they

00:09:29.870 --> 00:09:31.610
might be more rare.

00:09:31.610 --> 00:09:33.900
NEHA NARULA: They have
value because they're rare.

00:09:33.900 --> 00:09:34.400
OK.

00:09:34.400 --> 00:09:35.180
Interesting.

00:09:35.180 --> 00:09:37.310
All right.

00:09:37.310 --> 00:09:39.975
So those are all really
interesting ideas.

00:09:39.975 --> 00:09:41.850
I think that those are
all sort of properties

00:09:41.850 --> 00:09:45.153
of what makes things valuable.

00:09:45.153 --> 00:09:47.820
There are definitely things that
are rare that are not valuable,

00:09:47.820 --> 00:09:49.830
right?

00:09:49.830 --> 00:09:53.800
I can think of some things that
might be extraordinarily rare.

00:09:53.800 --> 00:09:55.800
There's only one or two
of them in the universe,

00:09:55.800 --> 00:09:58.410
and you would have no interest
in owning them whatsoever.

00:09:58.410 --> 00:10:00.750
You wouldn't assign
value to them.

00:10:00.750 --> 00:10:03.720
Certainly it's really important
that you can pay taxes

00:10:03.720 --> 00:10:06.870
with this stuff because taxes
is pretty much a requirement

00:10:06.870 --> 00:10:08.942
of living in any country.

00:10:08.942 --> 00:10:11.400
There are things that have
value that you don't necessarily

00:10:11.400 --> 00:10:12.310
use for taxes.

00:10:12.310 --> 00:10:14.280
So that's a little confusing.

00:10:14.280 --> 00:10:16.980
And then there's this
idea that it's backed,

00:10:16.980 --> 00:10:20.100
that it's backed by something.

00:10:20.100 --> 00:10:25.482
And the dollar used to
be backed by something.

00:10:25.482 --> 00:10:26.940
And actually, if
you look at $1.00,

00:10:26.940 --> 00:10:28.357
I think it still
says this, right?

00:10:28.357 --> 00:10:31.020
It's backed by the full faith
and credit of the United States

00:10:31.020 --> 00:10:31.742
government.

00:10:31.742 --> 00:10:33.450
TADGE DRYJA: They
don't say that anymore.

00:10:33.450 --> 00:10:34.200
NEHA NARULA: They
don't say that anymore?

00:10:34.200 --> 00:10:35.117
They used to say that.

00:10:35.117 --> 00:10:37.718
But that's what a lot of
people say about money.

00:10:37.718 --> 00:10:40.260
It's backed by the full faith
and credit of the United States

00:10:40.260 --> 00:10:41.895
government.

00:10:41.895 --> 00:10:43.020
What does that really mean?

00:10:43.020 --> 00:10:45.420
I think what it
all goes back to is

00:10:45.420 --> 00:10:46.920
these things are
valuable because we

00:10:46.920 --> 00:10:47.940
think they're valuable.

00:10:47.940 --> 00:10:49.710
We've all decided
they're valuable.

00:10:49.710 --> 00:10:53.430
And you know that if you have a
$1.00 bill and you want to buy

00:10:53.430 --> 00:10:56.370
something from someone,
they're going to take it,

00:10:56.370 --> 00:10:58.077
that you can make that exchange.

00:10:58.077 --> 00:10:59.910
And the reason that
they're going to take it

00:10:59.910 --> 00:11:01.920
is because they know
that someone else is

00:11:01.920 --> 00:11:03.450
going to take it.

00:11:03.450 --> 00:11:06.660
These things hold value because
we think that they hold value.

00:11:06.660 --> 00:11:12.150
It's a collective
story that we all tell.

00:11:12.150 --> 00:11:14.880
So I think once you
look at money that way,

00:11:14.880 --> 00:11:18.360
then when you start to look at
tokens, which are essentially

00:11:18.360 --> 00:11:20.970
digital representations
of these things, things

00:11:20.970 --> 00:11:24.300
that are rare and a
little bit special, then

00:11:24.300 --> 00:11:27.580
when you ask, well, why
does this token have value,

00:11:27.580 --> 00:11:30.760
because we think it has value.

00:11:30.760 --> 00:11:34.040
So what makes a token
inherently valuable?

00:11:34.040 --> 00:11:36.272
The fact that we
think it's valuable.

00:11:36.272 --> 00:11:38.230
And a lot of different
things can go into that.

00:11:38.230 --> 00:11:43.660
Maybe we think it's valuable
because it's very rare.

00:11:43.660 --> 00:11:47.260
Or maybe we think it's
valuable because someone's

00:11:47.260 --> 00:11:49.240
promised that you
can use it to pay

00:11:49.240 --> 00:11:51.130
for storage, like with Dropbox.

00:11:51.130 --> 00:11:53.890
Or maybe we think it's valuable
for a completely different

00:11:53.890 --> 00:11:55.300
reason, because
we like the name,

00:11:55.300 --> 00:11:57.383
or we like the people who
are running the network.

00:11:57.383 --> 00:11:59.200
But ultimately
tokens are valuable.

00:11:59.200 --> 00:12:00.880
These digital
representations are

00:12:00.880 --> 00:12:03.500
valuable because we
think they're valuable.

00:12:03.500 --> 00:12:04.420
Yes.

00:12:04.420 --> 00:12:05.820
AUDIENCE: And also because
they're a limited amount.

00:12:05.820 --> 00:12:06.790
NEHA NARULA: Name.

00:12:06.790 --> 00:12:07.760
AUDIENCE: [INAUDIBLE].

00:12:07.760 --> 00:12:09.630
Because they're
a limited amount.

00:12:09.630 --> 00:12:11.038
NEHA NARULA: Well,
so my argument

00:12:11.038 --> 00:12:12.580
is that the fact
that they're limited

00:12:12.580 --> 00:12:14.590
is something that goes
into our perception that

00:12:14.590 --> 00:12:15.340
makes it valuable.

00:12:18.100 --> 00:12:18.610
Great.

00:12:18.610 --> 00:12:19.120
OK.

00:12:19.120 --> 00:12:22.630
So now that we've learned
a little bit about money,

00:12:22.630 --> 00:12:24.820
talked a little
bit about money, I

00:12:24.820 --> 00:12:28.665
want to go into how payments
work because ultimately, we're

00:12:28.665 --> 00:12:30.040
going to get to
cryptocurrencies.

00:12:30.040 --> 00:12:34.090
And cryptocurrencies
are electronic cash.

00:12:34.090 --> 00:12:38.420
So here's the way that digital
payments kind of work right

00:12:38.420 --> 00:12:38.920
now.

00:12:38.920 --> 00:12:42.070
You have an institution
called a bank.

00:12:42.070 --> 00:12:45.340
You have Alice and you
have Bob, and Alice and Bob

00:12:45.340 --> 00:12:47.800
have accounts at this bank.

00:12:47.800 --> 00:12:51.840
And so the bank is keeping
track of who owns what.

00:12:51.840 --> 00:12:53.228
And these are these are records.

00:12:53.228 --> 00:12:54.520
These might be digital records.

00:12:54.520 --> 00:12:57.190
They might be paper
records, whatever

00:12:57.190 --> 00:12:59.440
the bank is using
to keep track of who

00:12:59.440 --> 00:13:00.778
has what in their account.

00:13:00.778 --> 00:13:03.070
And so the way that I've set
up this example right now,

00:13:03.070 --> 00:13:04.990
Alice and Bob both
have bank accounts.

00:13:04.990 --> 00:13:07.810
Alice has $10.00 with the bank
and Bob does not have any money

00:13:07.810 --> 00:13:09.850
with the bank.

00:13:09.850 --> 00:13:12.340
So let's say that
Alice wants to pay Bob.

00:13:12.340 --> 00:13:15.250
Let's say that Alice and
Bob have gotten together.

00:13:15.250 --> 00:13:17.560
Maybe they're in the
same coffee shop.

00:13:17.560 --> 00:13:20.260
And Alice wants to buy
a sandwich from Bob.

00:13:20.260 --> 00:13:23.680
And Bob says, OK, you
need to pay me $1.00.

00:13:23.680 --> 00:13:26.690
If you give me $1.00, then
I'll give you the sandwich.

00:13:26.690 --> 00:13:28.460
So how can Alice do this?

00:13:28.460 --> 00:13:31.130
How can she transfer
$1.00 to Bob?

00:13:31.130 --> 00:13:34.220
Well, if she had a paper
dollar, she could just do that.

00:13:34.220 --> 00:13:37.970
But let's say that she
doesn't have a paper dollar.

00:13:37.970 --> 00:13:43.100
So Alice can ask the bank to
make this transfer for her--or

00:13:43.100 --> 00:13:44.450
$5.00.

00:13:44.450 --> 00:13:46.220
So Alice sends a
message to the bank

00:13:46.220 --> 00:13:48.783
and authenticates with
the bank to show the bank

00:13:48.783 --> 00:13:50.450
that she is, in fact,
Alice, but I'm not

00:13:50.450 --> 00:13:52.650
going to go into the
details on how that works.

00:13:52.650 --> 00:13:57.230
And then the bank confirms
that, makes the transfer in its

00:13:57.230 --> 00:14:02.510
ledger, says Alice now has
$5.00 and Bob now has $5.00.

00:14:02.510 --> 00:14:04.995
Alice tells Bob,
hey, I did this.

00:14:04.995 --> 00:14:05.870
I talked to the bank.

00:14:05.870 --> 00:14:06.410
Go check.

00:14:06.410 --> 00:14:08.960
You can verify it for yourself.

00:14:08.960 --> 00:14:12.140
Bob checks with the bank
and sees, yes, in fact,

00:14:12.140 --> 00:14:14.090
the bank is saying
that he has $5.00 now,

00:14:14.090 --> 00:14:16.250
whereas before he had zero.

00:14:16.250 --> 00:14:19.280
And then Bob gives Alice the
sandwich because he believes

00:14:19.280 --> 00:14:20.980
that he now has $5.00.

00:14:20.980 --> 00:14:24.580
And the bank sort of
preserved the property

00:14:24.580 --> 00:14:27.880
that money was not created out
of nowhere, that the balance

00:14:27.880 --> 00:14:29.680
was ultimately maintained.

00:14:29.680 --> 00:14:32.260
So the bank is very
important in this scenario.

00:14:32.260 --> 00:14:33.830
The bank is critical.

00:14:33.830 --> 00:14:35.500
This is how digital
payments work.

00:14:35.500 --> 00:14:39.003
Credit cards, Venmo,
banks, kind of all sort

00:14:39.003 --> 00:14:41.170
of based on the same idea,
that there's some trusted

00:14:41.170 --> 00:14:44.230
institution that is
handling that payment for us

00:14:44.230 --> 00:14:47.110
and that is keeping
track of everything.

00:14:47.110 --> 00:14:51.700
Now what are the pros and
cons of this scenario?

00:14:51.700 --> 00:14:54.560
Anyone want to
throw a couple out?

00:14:54.560 --> 00:14:55.440
Yeah.

00:14:55.440 --> 00:14:56.980
AUDIENCE: The bank
can get hacked

00:14:56.980 --> 00:14:59.608
and people could move money
around between the accounts.

00:14:59.608 --> 00:15:00.400
NEHA NARULA: Right.

00:15:00.400 --> 00:15:02.290
So we're putting a lot
of trust in this bank.

00:15:02.290 --> 00:15:04.360
And maybe should
we trust the bank?

00:15:04.360 --> 00:15:06.490
Banks fail sometimes.

00:15:06.490 --> 00:15:07.780
Banks are hacked.

00:15:07.780 --> 00:15:10.198
Banks have humans
who are running them

00:15:10.198 --> 00:15:11.740
who occasionally
might want to change

00:15:11.740 --> 00:15:14.440
those balances in their favor.

00:15:14.440 --> 00:15:15.550
This has all happened.

00:15:15.550 --> 00:15:17.910
Anything else?

00:15:17.910 --> 00:15:18.450
Yeah.

00:15:18.450 --> 00:15:19.390
And say your name.

00:15:19.390 --> 00:15:21.330
AUDIENCE: Brittany.

00:15:21.330 --> 00:15:24.160
If it's urgent, sometimes
you might run into a delay

00:15:24.160 --> 00:15:26.730
or it might take time
with the process.

00:15:26.730 --> 00:15:27.480
NEHA NARULA: Yeah.

00:15:27.480 --> 00:15:30.490
Alice has to talk to the banks,
and that's kind of annoying.

00:15:30.490 --> 00:15:33.150
So there's that.

00:15:33.150 --> 00:15:33.880
Anything else?

00:15:33.880 --> 00:15:34.447
Yeah.

00:15:34.447 --> 00:15:36.030
AUDIENCE: And if
everyone can actually

00:15:36.030 --> 00:15:38.238
withdraw at the same time,
then the bank can actually

00:15:38.238 --> 00:15:40.590
get money into the system.

00:15:40.590 --> 00:15:41.430
NEHA NARULA: So OK.

00:15:41.430 --> 00:15:43.590
So this is getting a little
bit more advanced here.

00:15:43.590 --> 00:15:47.790
What if everyone takes their
balances out at the same time?

00:15:47.790 --> 00:15:51.030
Well, we need to make sure
that the bank actually

00:15:51.030 --> 00:15:53.262
has that money, so to speak.

00:15:53.262 --> 00:15:55.720
We're not going to be talking
about that problem right now.

00:15:55.720 --> 00:15:57.900
But very good problem.

00:15:57.900 --> 00:15:59.730
So to kind of talk
through some of the pros

00:15:59.730 --> 00:16:03.600
and cons of this situation,
one of the big pros, I think,

00:16:03.600 --> 00:16:06.210
is, that even if
Alice and Bob are not

00:16:06.210 --> 00:16:09.480
in the same physical location,
Alice can still pay Bob

00:16:09.480 --> 00:16:10.688
if they can talk to the bank.

00:16:10.688 --> 00:16:12.397
So it's pretty cool,
and that's something

00:16:12.397 --> 00:16:15.000
you can't do with dollar bills
or with coins or with bars

00:16:15.000 --> 00:16:16.180
of gold.

00:16:16.180 --> 00:16:18.480
So having this
trusted institution

00:16:18.480 --> 00:16:20.670
that you can communicate
with electronically

00:16:20.670 --> 00:16:22.378
means that Alice and
Bob could be halfway

00:16:22.378 --> 00:16:24.503
around the world from each
other and they can still

00:16:24.503 --> 00:16:25.200
pay each other.

00:16:25.200 --> 00:16:27.870
So that's pretty awesome, and
that is definitely a property

00:16:27.870 --> 00:16:29.940
that we want to have.

00:16:29.940 --> 00:16:33.330
In terms of cons, I think we
covered quite a few of them,

00:16:33.330 --> 00:16:37.020
which is we're really
putting this bank

00:16:37.020 --> 00:16:38.760
kind of in the middle
of everything here.

00:16:38.760 --> 00:16:42.600
And there are a few different
ways that can cause us trouble.

00:16:42.600 --> 00:16:46.142
So the bank needs to be online
during every transaction.

00:16:46.142 --> 00:16:47.850
If the bank is offline,
then how does Bob

00:16:47.850 --> 00:16:50.250
know whether he got paid or not?

00:16:50.250 --> 00:16:52.710
The bank could fail at
some point in time, which

00:16:52.710 --> 00:16:54.060
is kind of related to that.

00:16:54.060 --> 00:16:56.610
The bank could simply
decide that they

00:16:56.610 --> 00:16:59.010
don't want to do this anymore
and can block transactions.

00:16:59.010 --> 00:17:00.180
And then privacy.

00:17:00.180 --> 00:17:03.000
The bank has kind of
insight into everyone

00:17:03.000 --> 00:17:03.970
and their payments.

00:17:03.970 --> 00:17:05.849
And this is incredibly
sensitive information.

00:17:05.849 --> 00:17:08.618
Payments are quite important.

00:17:08.618 --> 00:17:10.410
And we're going to be
talking about privacy

00:17:10.410 --> 00:17:13.119
a lot in this class, during
the second half of this class.

00:17:13.119 --> 00:17:16.050
So just an example, a couple
of visual examples of that.

00:17:16.050 --> 00:17:17.880
The bank could just
totally go away,

00:17:17.880 --> 00:17:20.099
and then what happens
to that ledger?

00:17:20.099 --> 00:17:21.240
Who knows, right?

00:17:21.240 --> 00:17:23.579
I mean, literally, it
could just disappear.

00:17:23.579 --> 00:17:25.079
Maybe it's paper
and it gets burnt,

00:17:25.079 --> 00:17:29.598
or maybe it's bits on a computer
and it wasn't replicated.

00:17:29.598 --> 00:17:31.140
The bank could decide
that they don't

00:17:31.140 --> 00:17:33.090
like Alice for some
reason, and that they

00:17:33.090 --> 00:17:35.880
don't feel like processing
Alice's transactions.

00:17:35.880 --> 00:17:39.940
This happens all the
time in the real world.

00:17:39.940 --> 00:17:44.830
So there have been designs
for electronic cash

00:17:44.830 --> 00:17:46.320
that work a little
bit differently.

00:17:46.320 --> 00:17:47.737
And we're going
to kind of step up

00:17:47.737 --> 00:17:53.245
to the design that came
right before bitcoin,

00:17:53.245 --> 00:17:54.870
and we're going to
do that iteratively.

00:17:54.870 --> 00:17:57.810
So let's talk about e-cash
and how e-cash works.

00:17:57.810 --> 00:18:01.980
So the way that
e-cash works is Alice

00:18:01.980 --> 00:18:03.450
tells the bank--
instead of saying,

00:18:03.450 --> 00:18:05.040
hey, bank, do this
transfer for me,

00:18:05.040 --> 00:18:08.370
Alice says, hey, I would
like a digital representation

00:18:08.370 --> 00:18:09.540
of a coin.

00:18:09.540 --> 00:18:12.607
Can you give me
something that is digital

00:18:12.607 --> 00:18:14.940
so I don't have to be in the
same physical place as you,

00:18:14.940 --> 00:18:19.920
and that I can use in such a
way that I can prove to someone

00:18:19.920 --> 00:18:22.950
else that I have this thing and
that I haven't double spent it,

00:18:22.950 --> 00:18:25.380
because that's the problem
with digital representations

00:18:25.380 --> 00:18:26.220
of coins.

00:18:26.220 --> 00:18:29.370
A fundamental problem is
that bits can be copied.

00:18:29.370 --> 00:18:33.450
So whatever system you use to
design your electronic cash,

00:18:33.450 --> 00:18:35.820
you need to make sure
that people can't just

00:18:35.820 --> 00:18:41.825
copy coins and give what is the
same coin to multiple people.

00:18:41.825 --> 00:18:43.200
In the previous
example, the bank

00:18:43.200 --> 00:18:44.450
was making sure this happened.

00:18:44.450 --> 00:18:46.650
The bank was
maintaining balances

00:18:46.650 --> 00:18:51.500
and debiting Alice's account
and crediting Bob's account.

00:18:51.500 --> 00:18:54.000
But if we want to think about
something that doesn't involve

00:18:54.000 --> 00:18:56.100
the bank, and we're
starting to get there,

00:18:56.100 --> 00:18:59.520
then we need to think about how
to ensure that a coin can't be

00:18:59.520 --> 00:19:02.210
what is known as double spent.

00:19:02.210 --> 00:19:03.800
So Alice asks the bank for coin.

00:19:03.800 --> 00:19:07.040
And maybe she has an account
with a bank like before.

00:19:07.040 --> 00:19:10.400
Or maybe she gives the bank
teller actual physical money

00:19:10.400 --> 00:19:13.310
in order to get
one of these coins.

00:19:13.310 --> 00:19:17.030
So the bank generates
a unique number--

00:19:17.030 --> 00:19:19.430
SN stands for serial number--

00:19:19.430 --> 00:19:22.880
and decides that this is
the digital representation

00:19:22.880 --> 00:19:24.620
of the coin.

00:19:24.620 --> 00:19:28.430
The bank then gives that
coin to Alice in a way

00:19:28.430 --> 00:19:31.175
that it's clear that
the bank did this.

00:19:31.175 --> 00:19:33.050
Usually this is done
using a technique called

00:19:33.050 --> 00:19:34.490
digital signatures.

00:19:34.490 --> 00:19:37.550
We're going to get to
that as class progresses,

00:19:37.550 --> 00:19:40.070
but not right now.

00:19:40.070 --> 00:19:44.270
Once Alice has this coin,
then she can give it to Bob.

00:19:44.270 --> 00:19:46.633
And Bob can take a
look at this coin,

00:19:46.633 --> 00:19:48.800
and hopefully there's enough
going on with this coin

00:19:48.800 --> 00:19:52.280
that Bob can be convinced
that this is a real coin.

00:19:52.280 --> 00:19:54.360
Alice didn't make it
up out of nowhere.

00:19:54.360 --> 00:19:58.670
She actually had the funds,
so to speak, to give to Bob,

00:19:58.670 --> 00:20:00.530
and that it hasn't
been double spent.

00:20:03.610 --> 00:20:05.270
And once Bob is
convinced of that,

00:20:05.270 --> 00:20:06.883
he can give Alice the sandwich.

00:20:06.883 --> 00:20:09.050
Now in traditional e-cash,
the way that this is done

00:20:09.050 --> 00:20:11.450
is Bob actually goes
back to the bank

00:20:11.450 --> 00:20:13.580
and says, here's this coin.

00:20:13.580 --> 00:20:15.850
Alice just gave me this coin.

00:20:15.850 --> 00:20:17.870
Is this an OK coin?

00:20:17.870 --> 00:20:21.170
But the fact of the matter is
that the bank, in this case,

00:20:21.170 --> 00:20:23.210
has a serial number
and knows that it

00:20:23.210 --> 00:20:25.430
gave that unique
serial number to Alice,

00:20:25.430 --> 00:20:28.040
and then Bob is showing
up with a coin that

00:20:28.040 --> 00:20:30.050
is that serial number.

00:20:30.050 --> 00:20:32.390
And what the bank is doing
here, in this example,

00:20:32.390 --> 00:20:36.532
is the way that the
bank checks to make sure

00:20:36.532 --> 00:20:38.990
that this coin is correct is
it looks at the serial number,

00:20:38.990 --> 00:20:42.110
and it makes sure that it
hasn't been spent before.

00:20:42.110 --> 00:20:46.100
So the bank can link the
coin between Alice and Bob,

00:20:46.100 --> 00:20:47.570
which is unfortunate.

00:20:47.570 --> 00:20:51.410
The also still sort
of has to be online,

00:20:51.410 --> 00:20:53.780
not to do the actual payment
between Alice and Bob,

00:20:53.780 --> 00:20:56.270
but in order for Bob
to have confidence

00:20:56.270 --> 00:20:58.850
that this coin is real.

00:20:58.850 --> 00:21:03.678
And later on Bob can say, I
would like $1.00 for this coin

00:21:03.678 --> 00:21:05.720
that I've just given you,
or something like that.

00:21:05.720 --> 00:21:07.940
Or Bob can have an
account with the bank

00:21:07.940 --> 00:21:09.320
and can maintain
a balance there.

00:21:11.940 --> 00:21:17.720
So just to go through some
of the pros and cons here,

00:21:17.720 --> 00:21:21.020
OK, we've kind of done
something where the bank's not

00:21:21.020 --> 00:21:23.600
in the middle, except the bank
is still really in the middle.

00:21:23.600 --> 00:21:28.850
We're getting a step
closer, but we're not there.

00:21:28.850 --> 00:21:33.080
Alice can technically give
Bob this electronic thing that

00:21:33.080 --> 00:21:35.530
represents value,
but Bob still needs

00:21:35.530 --> 00:21:37.280
to talk to the bank
to make sure it's real

00:21:37.280 --> 00:21:38.660
and it hasn't been double spent.

00:21:38.660 --> 00:21:41.330
And we still have this problem
where the bank is the one who's

00:21:41.330 --> 00:21:42.740
minting these things.

00:21:42.740 --> 00:21:44.600
The bank can decide
not to give Alice

00:21:44.600 --> 00:21:46.490
a coin if it feels like it.

00:21:46.490 --> 00:21:48.080
And we still have
this privacy problem

00:21:48.080 --> 00:21:51.500
because the secret number,
the serial number that we

00:21:51.500 --> 00:21:54.410
invent for the coin, can be
linked across these payments.

00:21:57.660 --> 00:22:00.530
So there's this
notion of something

00:22:00.530 --> 00:22:01.870
called Chaumian e-cash.

00:22:01.870 --> 00:22:04.070
So David Chaumian
is a cryptographer,

00:22:04.070 --> 00:22:06.590
and he developed
this system which

00:22:06.590 --> 00:22:12.170
has slightly nicer properties
than previous forms of e-cash.

00:22:12.170 --> 00:22:15.290
So the idea here,
which is really key,

00:22:15.290 --> 00:22:18.770
is instead of the bank
choosing the secret number,

00:22:18.770 --> 00:22:20.990
Alice chooses the secret number.

00:22:20.990 --> 00:22:23.780
And we have ways of
generating random numbers

00:22:23.780 --> 00:22:26.070
that we can be fairly
sure are unique.

00:22:26.070 --> 00:22:29.700
So we can let everybody generate
their own random numbers.

00:22:29.700 --> 00:22:33.140
So in Chaumian e-cash, Alice
chooses the secret number

00:22:33.140 --> 00:22:34.760
that represents a coin.

00:22:34.760 --> 00:22:37.880
And then Alice
blinds her message.

00:22:37.880 --> 00:22:42.020
So Alice adds some randomness
to the secret number such

00:22:42.020 --> 00:22:45.230
that the bank doesn't know
what that number actually is.

00:22:45.230 --> 00:22:48.140
And we'll get into more detail
about exactly what that means.

00:22:48.140 --> 00:22:50.150
It's all in the paper
that was assigned

00:22:50.150 --> 00:22:51.710
reading for this
class, so make sure

00:22:51.710 --> 00:22:54.450
that you take a look at it.

00:22:54.450 --> 00:22:58.640
So when the bank verifies that
the secret number is a real

00:22:58.640 --> 00:23:00.260
secret number and
it's really a coin,

00:23:00.260 --> 00:23:03.530
and Alice gave the bank
$1.00 or something like that,

00:23:03.530 --> 00:23:06.500
the bank does so on the
blinded secret number.

00:23:06.500 --> 00:23:08.180
And Alice actually
has the ability

00:23:08.180 --> 00:23:11.330
to remove that randomness,
or that blinding, later

00:23:11.330 --> 00:23:16.760
and end up with a valid
signature on a secret number.

00:23:16.760 --> 00:23:19.040
So Alice does the same
thing that she did before.

00:23:19.040 --> 00:23:22.400
She gives Bob a representation
of that electronic coin.

00:23:22.400 --> 00:23:25.820
And when Bob redeems it,
note that the bank never

00:23:25.820 --> 00:23:28.340
sees what the number is,
so when Bob redeems it,

00:23:28.340 --> 00:23:31.490
the bank has no way of linking
the payment between Alice

00:23:31.490 --> 00:23:33.250
and Bob.

00:23:33.250 --> 00:23:36.220
So just to get into how
this works visually,

00:23:36.220 --> 00:23:39.700
Alice will talk to
the bank, and Alice

00:23:39.700 --> 00:23:43.660
will use a blinding factor
on the secret number.

00:23:43.660 --> 00:23:45.430
And so when Alice
talked to the bank,

00:23:45.430 --> 00:23:47.763
the bank doesn't actually see
what the secret number is.

00:23:47.763 --> 00:23:49.000
They can't decode it.

00:23:49.000 --> 00:23:52.810
Again, Alice gives $1.00 or
something like that to get this

00:23:52.810 --> 00:23:54.640
coin from the bank.

00:23:54.640 --> 00:23:57.040
And the bank signs this.

00:23:57.040 --> 00:24:00.940
Alice can remove the
blinding factor later.

00:24:00.940 --> 00:24:02.560
And this is what the coin is.

00:24:02.560 --> 00:24:05.110
The coin is a valid
bank signature

00:24:05.110 --> 00:24:08.440
on the secret number, and
also the number itself,

00:24:08.440 --> 00:24:11.500
which Alice can
then send to Bob.

00:24:11.500 --> 00:24:14.740
Bob can check and make sure
that this is a valid signature

00:24:14.740 --> 00:24:16.690
from the bank.

00:24:16.690 --> 00:24:22.360
And if that's correct, then
Bob can give Alice a sandwich.

00:24:22.360 --> 00:24:26.650
In order to redeem this, Bob
gives this coin to the bank.

00:24:26.650 --> 00:24:33.190
The bank says, OK, I've never
seen the secret number before,

00:24:33.190 --> 00:24:35.000
and you have my signature on it.

00:24:35.000 --> 00:24:37.292
So I'm going to assume that
I went through this process

00:24:37.292 --> 00:24:39.700
with somebody and
signed something.

00:24:39.700 --> 00:24:42.370
And now I'm going to
record that secret number.

00:24:42.370 --> 00:24:43.870
Once that happens,
Bob can be sure

00:24:43.870 --> 00:24:46.060
that this coin hasn't
been spent before.

00:24:46.060 --> 00:24:48.620
The bank keeps a running list
of all the secret numbers

00:24:48.620 --> 00:24:53.050
it's seen, and it makes sure
that if it ever sees one again,

00:24:53.050 --> 00:24:56.260
it can say no, this
is not correct.

00:24:56.260 --> 00:24:59.260
I should never see a secret
number more than once.

00:24:59.260 --> 00:25:00.190
Now, OK.

00:25:00.190 --> 00:25:04.900
But know what about Alice
could give one version of that

00:25:04.900 --> 00:25:05.470
to Bob.

00:25:05.470 --> 00:25:08.230
Alice could also give a
version of that to Charlie.

00:25:08.230 --> 00:25:10.870
And how are Charlie
and Bob supposed

00:25:10.870 --> 00:25:15.010
to know whose coin is correct?

00:25:15.010 --> 00:25:17.260
Because remember, we wanted
to try to get the bank out

00:25:17.260 --> 00:25:19.210
of the way when doing this.

00:25:19.210 --> 00:25:21.250
And so in Chaumian
e-cash, the way

00:25:21.250 --> 00:25:22.990
that this works is
the bank actually

00:25:22.990 --> 00:25:26.150
keeps a bit more information.

00:25:26.150 --> 00:25:29.920
And the information
that the bank is keeping

00:25:29.920 --> 00:25:33.370
won't let the bank link
these transactions together

00:25:33.370 --> 00:25:37.570
unless Alice happens to
give this to two people.

00:25:37.570 --> 00:25:41.260
And so if Alice gives the same
coin to two different people,

00:25:41.260 --> 00:25:43.330
the bank will be
able to detect it

00:25:43.330 --> 00:25:46.060
and the bank will be able
to know it was Alice.

00:25:46.060 --> 00:25:50.200
And so this is kind of
a motivator for Alice

00:25:50.200 --> 00:25:51.740
not to do that.

00:25:51.740 --> 00:25:55.180
So the idea being here is that
the way that we get around

00:25:55.180 --> 00:25:59.860
the fact that we don't know if
a coin has been double spent

00:25:59.860 --> 00:26:05.140
or not is we add punishment
if the coin is double spent.

00:26:05.140 --> 00:26:08.050
So Bob doesn't know for sure
that this coin he receives

00:26:08.050 --> 00:26:11.590
hasn't been double spent, but
he does know that if it was,

00:26:11.590 --> 00:26:13.480
someone's going to
know it was Alice,

00:26:13.480 --> 00:26:17.480
and they're going to punish her.

00:26:17.480 --> 00:26:19.460
So this is a pretty
clever scheme.

00:26:19.460 --> 00:26:24.820
And this actually gets us
around a lot of problems.

00:26:24.820 --> 00:26:26.260
We have digital payments.

00:26:26.260 --> 00:26:30.340
We can make the actual transfer
without the bank in the middle.

00:26:30.340 --> 00:26:33.250
We have some privacy now
because the bank can't

00:26:33.250 --> 00:26:36.160
link transactions together.

00:26:36.160 --> 00:26:39.010
And we have this way of
doing double spend detection.

00:26:39.010 --> 00:26:41.050
We have a way of
motivating people

00:26:41.050 --> 00:26:43.780
not to double spend their coins,
which means that you probably

00:26:43.780 --> 00:26:46.120
don't have to check
at the time you

00:26:46.120 --> 00:26:49.420
receive a coin whether or
not it's been double spent.

00:26:49.420 --> 00:26:53.990
Of course, this still suffers
from a really big problem,

00:26:53.990 --> 00:26:56.950
which is that a bank can
still decide that they just

00:26:56.950 --> 00:26:58.242
don't want to do this with you.

00:26:58.242 --> 00:26:59.950
They can just decide
that they don't want

00:26:59.950 --> 00:27:01.090
to play this game with you.

00:27:01.090 --> 00:27:03.755
They don't want to issue coins.

00:27:03.755 --> 00:27:05.380
Maybe they don't like
you specifically.

00:27:05.380 --> 00:27:07.870
Maybe they don't want to take
your coins and exchange them.

00:27:07.870 --> 00:27:12.310
So this scheme, Chaumian e-cash,
solves quite a bit of problems

00:27:12.310 --> 00:27:15.820
when it comes to how do
we have electronic money

00:27:15.820 --> 00:27:20.110
with some nice features,
but it doesn't quite

00:27:20.110 --> 00:27:22.240
get to all of them.

00:27:22.240 --> 00:27:25.080
And so the real
question in this class

00:27:25.080 --> 00:27:28.350
is how do we do
electronic money, really,

00:27:28.350 --> 00:27:29.970
in a peer-to-peer
way, where there's

00:27:29.970 --> 00:27:31.680
no institution in the way.

00:27:31.680 --> 00:27:35.768
There's no sort of
entity that can say no.

00:27:35.768 --> 00:27:38.060
TADGE DRYJA: So e-cash, the
math is really interesting.

00:27:38.060 --> 00:27:42.050
It kept relying on these
banks and so it never quite

00:27:42.050 --> 00:27:43.190
got off the ground.

00:27:43.190 --> 00:27:47.240
So I'm willing to talk about
somewhat more abstract and low

00:27:47.240 --> 00:27:49.400
level primitives.

00:27:49.400 --> 00:27:55.490
I'm not going to quite get into
cash or tokens or transfers

00:27:55.490 --> 00:27:57.530
or anything this lecture.

00:27:57.530 --> 00:27:59.960
But I'm going to talk about
the really basic primitives

00:27:59.960 --> 00:28:02.990
that you need that we
already sort of mentioned,

00:28:02.990 --> 00:28:04.880
hash functions and signatures.

00:28:04.880 --> 00:28:07.790
Signatures, obviously, we
talked about a little bit,

00:28:07.790 --> 00:28:10.070
what you need to be able
to sign messages in order

00:28:10.070 --> 00:28:11.510
to send these tokens around.

00:28:11.510 --> 00:28:14.900
But first I'll talk about hash
functions, which are basically

00:28:14.900 --> 00:28:18.980
the most fundamental basic
thing we use in these systems.

00:28:18.980 --> 00:28:21.345
And I think if you've
used computers,

00:28:21.345 --> 00:28:22.720
or if you've
programmed a little,

00:28:22.720 --> 00:28:24.590
you probably have
some familiarity

00:28:24.590 --> 00:28:26.540
with hash functions.

00:28:26.540 --> 00:28:29.460
They're simple, but they're
actually extremely powerful.

00:28:29.460 --> 00:28:31.160
The hash function
is basically you

00:28:31.160 --> 00:28:32.990
have some data,
a bunch of bytes,

00:28:32.990 --> 00:28:34.333
a bunch of ones and zeros.

00:28:34.333 --> 00:28:35.750
You run it through
a hash function

00:28:35.750 --> 00:28:38.930
and you get an output that's
also a bunch of ones and zeros.

00:28:38.930 --> 00:28:42.120
Generally, the input
data can be of any size.

00:28:42.120 --> 00:28:43.460
You can hash something--

00:28:43.460 --> 00:28:45.290
put in a megabyte,
put in a gigabyte,

00:28:45.290 --> 00:28:47.900
or put in a single byte,
and generally the output

00:28:47.900 --> 00:28:49.500
is of a fixed size.

00:28:49.500 --> 00:28:52.730
So in the case of
bitcoin, we use Sha-256.

00:28:52.730 --> 00:28:58.280
The output size is 32 bytes
long, or 256 bits long.

00:28:58.280 --> 00:29:03.050
And this is used for lots
of things in computers.

00:29:03.050 --> 00:29:05.300
I guess the reason they call
it a hash is because it's

00:29:05.300 --> 00:29:07.580
like when you take the
potatoes and chop them up

00:29:07.580 --> 00:29:11.630
into little squares and
grill them for breakfast,

00:29:11.630 --> 00:29:14.180
it's sort of that idea,
that we're taking this data.

00:29:14.180 --> 00:29:17.780
And the data going in gets
chopped up and smushed around

00:29:17.780 --> 00:29:21.260
and then comes out
into an output.

00:29:21.260 --> 00:29:24.290
So this is not a sufficient
different definition.

00:29:24.290 --> 00:29:27.320
But I will say that you
can sort of do everything

00:29:27.320 --> 00:29:28.660
with hash functions.

00:29:28.660 --> 00:29:30.410
There's some fun things
that you can't do,

00:29:30.410 --> 00:29:33.110
but you could make a
cryptocurrency only using

00:29:33.110 --> 00:29:34.940
a single hash function.

00:29:34.940 --> 00:29:38.720
And I think people have, sort
of for experimental reasons.

00:29:38.720 --> 00:29:43.460
You limit the fun stuff you can
do, but you can do signatures.

00:29:43.460 --> 00:29:45.070
You can do encryption.

00:29:45.070 --> 00:29:47.460
You can do all sorts
of things like that.

00:29:47.460 --> 00:29:47.960
OK.

00:29:47.960 --> 00:29:50.960
So this is not a
sufficient definition,

00:29:50.960 --> 00:29:55.310
that there's any size
input, a fixed size output,

00:29:55.310 --> 00:29:57.580
and the output is
random-looking.

00:29:57.580 --> 00:29:58.940
That's sort of wishy-washy.

00:29:58.940 --> 00:30:02.540
But what does
random-looking mean?

00:30:02.540 --> 00:30:03.890
It's not actually random.

00:30:03.890 --> 00:30:06.328
If you put in the
same input, everyone

00:30:06.328 --> 00:30:07.370
will get the same output.

00:30:07.370 --> 00:30:10.010
So if you say, OK, well,
what's the hash of one,

00:30:10.010 --> 00:30:11.280
you'll get some output.

00:30:11.280 --> 00:30:13.640
And if someone else says,
OK, what's the hash of one,

00:30:13.640 --> 00:30:15.810
you'll get the same thing.

00:30:15.810 --> 00:30:19.820
However, the output,
while it is deterministic,

00:30:19.820 --> 00:30:23.270
it's sort of high
entropy in that

00:30:23.270 --> 00:30:26.840
the output should have about as
many as one bits as zero bits.

00:30:26.840 --> 00:30:28.400
If you take the
hash of one, it's

00:30:28.400 --> 00:30:30.233
just going to look like
a big random number.

00:30:30.233 --> 00:30:32.690
And the hash of two will look
like a completely unrelated

00:30:32.690 --> 00:30:34.643
random number.

00:30:34.643 --> 00:30:35.810
The outputs look like noise.

00:30:35.810 --> 00:30:37.760
So if you've ever
seen hash functions,

00:30:37.760 --> 00:30:39.810
you can run it on your computer.

00:30:39.810 --> 00:30:41.280
You say echo.

00:30:41.280 --> 00:30:44.180
Hello, pipe Sha-256
sum, and you'll just

00:30:44.180 --> 00:30:46.580
get some kind of
crazy, random thing.

00:30:46.580 --> 00:30:50.680
There doesn't seem to be
any order to the outputs.

00:30:50.680 --> 00:30:52.368
A little bit more well-defined.

00:30:52.368 --> 00:30:54.160
We usually talk about
the avalanche effect,

00:30:54.160 --> 00:30:57.250
in that changing a
single bit in the input

00:30:57.250 --> 00:31:00.250
should change about half
the bits of the output.

00:31:00.250 --> 00:31:04.440
So even though you have
extremely similar inputs,

00:31:04.440 --> 00:31:07.090
they should be completely
dissimilar outputs--

00:31:07.090 --> 00:31:08.980
well, completely
dissimilar, as in about half

00:31:08.980 --> 00:31:09.910
the output changed.

00:31:09.910 --> 00:31:11.770
If every bit
changes, then it just

00:31:11.770 --> 00:31:15.910
is the inverse of what you had,
and so it's easily correlated.

00:31:15.910 --> 00:31:18.040
But the avalanche
effect is sort of how

00:31:18.040 --> 00:31:20.950
hash functions are constructed,
where generally they're

00:31:20.950 --> 00:31:22.137
iterative rounds.

00:31:22.137 --> 00:31:24.220
And so you say, OK, I'm
going to swap these things

00:31:24.220 --> 00:31:27.340
and multiply these things and
shift these bits around such

00:31:27.340 --> 00:31:30.280
that if any change
in the beginning

00:31:30.280 --> 00:31:32.230
will sort of propagate
an avalanche, too,

00:31:32.230 --> 00:31:35.940
so that all the output bits
have been affected by it.

00:31:35.940 --> 00:31:36.440
OK.

00:31:36.440 --> 00:31:38.602
And a little bit
more well-defined.

00:31:38.602 --> 00:31:40.310
Generally, the hash
functions are defined

00:31:40.310 --> 00:31:42.080
by what they should not do.

00:31:42.080 --> 00:31:44.420
So the three main things
they should have--

00:31:44.420 --> 00:31:47.390
preimage resistance,
second preimage resistance,

00:31:47.390 --> 00:31:50.900
which I'll sort of skip over,
and collision resistance.

00:31:50.900 --> 00:31:54.020
And we can define
what these things are.

00:31:54.020 --> 00:31:59.600
So a preimage is the thing
that came before the output.

00:31:59.600 --> 00:32:00.890
So it's sort of a math-y term.

00:32:00.890 --> 00:32:06.410
But the idea is OK, if you know
y, you can't find any x such

00:32:06.410 --> 00:32:08.870
that the hash of
x is equal to y.

00:32:08.870 --> 00:32:13.640
So if I give you a hash output,
and that's all I give you,

00:32:13.640 --> 00:32:16.610
you should not be able
to find an input that

00:32:16.610 --> 00:32:18.017
leads to that output.

00:32:18.017 --> 00:32:19.850
So if I just say, hey,
here's a hash output.

00:32:19.850 --> 00:32:25.250
It's 35021FF-- whatever,
some long string,

00:32:25.250 --> 00:32:26.750
you won't be able
to figure out what

00:32:26.750 --> 00:32:30.650
I used to put in to get that.

00:32:30.650 --> 00:32:32.810
Of course, you can
find it eventually.

00:32:32.810 --> 00:32:37.100
For any given y,
there's probably some x.

00:32:37.100 --> 00:32:38.990
In fact, there's probably
a lot of x's that

00:32:38.990 --> 00:32:40.460
will lead to that y.

00:32:40.460 --> 00:32:43.290
Since y is a fixed
length and there's

00:32:43.290 --> 00:32:47.900
two to the 256 possible
y's, but there's

00:32:47.900 --> 00:32:50.210
an infinite number of
x's because x is not

00:32:50.210 --> 00:32:51.200
bounded in length.

00:32:51.200 --> 00:32:56.000
You can have a megabyte or a
gigabyte or a terabyte size x.

00:32:56.000 --> 00:32:58.700
So since there are sort of
infinite numbers of x's,

00:32:58.700 --> 00:33:03.290
and a fixed, though very
large number of y's, as long

00:33:03.290 --> 00:33:05.300
as it is a random
mapping, there will

00:33:05.300 --> 00:33:08.300
be lots of different x's
that can lead to this y.

00:33:08.300 --> 00:33:11.030
And so you should
be able to find it.

00:33:11.030 --> 00:33:12.647
It's just impractical.

00:33:12.647 --> 00:33:14.480
It's like, yeah, you
may be able to find it,

00:33:14.480 --> 00:33:17.680
but it's going to take
you two to the 256 tries

00:33:17.680 --> 00:33:20.560
to find any specific y value.

00:33:20.560 --> 00:33:23.140
And that's about
10 to the 78, which

00:33:23.140 --> 00:33:25.930
is a number that's big enough
that you can sort of round it

00:33:25.930 --> 00:33:27.240
up to infinity.

00:33:27.240 --> 00:33:30.468
Well, I mean, not
quite, but big enough

00:33:30.468 --> 00:33:32.260
that you're not going
to be able to compute

00:33:32.260 --> 00:33:34.920
that, the sun'll burnout
and the universe'll die

00:33:34.920 --> 00:33:37.520
and stuff like that.

00:33:37.520 --> 00:33:38.770
So that's preimage resistance.

00:33:38.770 --> 00:33:41.170
You can't go backwards.

00:33:41.170 --> 00:33:43.970
Given the hash, you can't
find what led to that.

00:33:43.970 --> 00:33:44.470
OK.

00:33:44.470 --> 00:33:48.770
Any questions about
preimage resistance?

00:33:48.770 --> 00:33:50.780
Seems reasonable?

00:33:50.780 --> 00:33:55.713
It's a little interesting
in that given y is

00:33:55.713 --> 00:33:57.630
a little tricky, and
that it's like, OK, well,

00:33:57.630 --> 00:34:03.420
someone might know x in order
for them to have computed y.

00:34:03.420 --> 00:34:05.550
Or maybe it's just
completely random,

00:34:05.550 --> 00:34:08.820
and no one actually
knows what the x is.

00:34:08.820 --> 00:34:11.340
So there's a sort of
loss of information

00:34:11.340 --> 00:34:13.139
in the idea of a preimage stack.

00:34:13.139 --> 00:34:13.770
OK.

00:34:13.770 --> 00:34:15.270
Second preimage resistance.

00:34:15.270 --> 00:34:19.650
This one's a little
trickier and can get messy.

00:34:19.650 --> 00:34:22.290
So I'll define it, but we
won't go into it too much.

00:34:22.290 --> 00:34:25.739
The idea is given x and
y such that the hash of x

00:34:25.739 --> 00:34:30.000
is equal to y, you can't find
x prime where x prime is not

00:34:30.000 --> 00:34:31.080
equal to x.

00:34:31.080 --> 00:34:33.780
And the hash of x
prime is equal to y.

00:34:33.780 --> 00:34:35.429
So we're sort of
giving you a preimage.

00:34:35.429 --> 00:34:38.159
We're saying, hey, here's
this number x and here's

00:34:38.159 --> 00:34:39.199
this result y.

00:34:41.760 --> 00:34:47.250
I bet you can't find
another x that leads to it.

00:34:47.250 --> 00:34:49.929
This one is actually poorly
defined in the literature.

00:34:49.929 --> 00:34:52.650
And so it's a little
like, well, who

00:34:52.650 --> 00:34:56.225
made x, and who gets to
choose, and is it any x prime

00:34:56.225 --> 00:34:57.100
and things like that.

00:34:57.100 --> 00:34:59.830
So it's not actually
that useful.

00:34:59.830 --> 00:35:02.580
So we can just sort of
gloss over that one,

00:35:02.580 --> 00:35:04.540
just sort of mentioning it.

00:35:04.540 --> 00:35:08.310
And then the other one that's
very important is collision

00:35:08.310 --> 00:35:13.050
resistance, where the idea is
that nobody can find any x,z

00:35:13.050 --> 00:35:16.170
pair such that x
is not equal to z,

00:35:16.170 --> 00:35:19.940
but the hash of x is
equal to the hash of z.

00:35:19.940 --> 00:35:22.160
And this one's a
lot cleaner in that

00:35:22.160 --> 00:35:24.480
there's no lack of information.

00:35:24.480 --> 00:35:26.130
There's no secrets or anything.

00:35:26.130 --> 00:35:29.060
It's just like, look,
no one can find this.

00:35:29.060 --> 00:35:31.587
And so it's really
easy to disprove.

00:35:31.587 --> 00:35:33.920
You can just say, hey, look,
here's an x and here's a z.

00:35:33.920 --> 00:35:34.910
Try hashing them.

00:35:34.910 --> 00:35:37.643
Oh, shoot, the hashes are equal.

00:35:37.643 --> 00:35:39.560
And it doesn't really
matter how you got these

00:35:39.560 --> 00:35:40.880
or who's doing it.

00:35:40.880 --> 00:35:45.030
So that's a really nice,
easy, clear property.

00:35:45.030 --> 00:35:47.490
And again, you can
find this eventually.

00:35:47.490 --> 00:35:50.830
So if your output
size is 256 bits long,

00:35:50.830 --> 00:35:52.650
you'll be able to
find two inputs that

00:35:52.650 --> 00:35:55.110
map to the same output.

00:35:55.110 --> 00:35:59.860
In fact, you do not
need to try 256 times.

00:35:59.860 --> 00:36:01.740
I'm not going to go
into the details,

00:36:01.740 --> 00:36:05.970
but you actually only
have to try 128 times.

00:36:05.970 --> 00:36:07.320
Sorry, two to the 128.

00:36:07.320 --> 00:36:10.740
So you need to take the square
root of the number of attempts

00:36:10.740 --> 00:36:14.880
in order to find this collision
because the intuitive reason

00:36:14.880 --> 00:36:17.790
is, well, you just start
trying things and keeping

00:36:17.790 --> 00:36:19.680
track of all their hashes.

00:36:19.680 --> 00:36:23.340
And there's what's called
the birthday attack, which,

00:36:23.340 --> 00:36:26.310
as you keep trying them,
there's more possibilities.

00:36:26.310 --> 00:36:28.110
The next thing you
try, you can collide

00:36:28.110 --> 00:36:30.248
with any of these things
you've tried before.

00:36:30.248 --> 00:36:32.415
And so you actually only
have to do the square root.

00:36:32.415 --> 00:36:33.873
And it's called
the birthday attack

00:36:33.873 --> 00:36:37.050
because there's the birthday
paradox, which is not really

00:36:37.050 --> 00:36:40.290
a paradox, but the idea
is so in this room,

00:36:40.290 --> 00:36:42.540
there's people that
have the same birthday.

00:36:42.540 --> 00:36:44.910
It's almost certain,
which seems kind of weird

00:36:44.910 --> 00:36:47.760
because the intuitive thing is,
like, well, there's 365 days

00:36:47.760 --> 00:36:48.420
a year.

00:36:48.420 --> 00:36:52.878
Maybe once you get 160,
170 people in a room,

00:36:52.878 --> 00:36:55.170
you're going to have two
people with the same birthday.

00:36:55.170 --> 00:36:58.870
But actually, it's
like 22 or something--

00:36:58.870 --> 00:37:01.320
anyway, that it becomes
likely that people

00:37:01.320 --> 00:37:02.550
have the same birthday.

00:37:02.550 --> 00:37:03.990
So it's kind of
counterintuitive,

00:37:03.990 --> 00:37:05.740
and it applies in
this case as well.

00:37:05.740 --> 00:37:08.190
So to find a collision,
you need the square root

00:37:08.190 --> 00:37:10.860
of the output space.

00:37:10.860 --> 00:37:14.070
But a hash function should
not have collisions.

00:37:14.070 --> 00:37:16.170
If you can find a
collision, if any collision

00:37:16.170 --> 00:37:18.180
exists for this
hash function, you

00:37:18.180 --> 00:37:20.753
can consider the
hash function broken.

00:37:20.753 --> 00:37:22.920
It's a little bit different
than preimage resistance

00:37:22.920 --> 00:37:25.800
because it's hard to
definitively prove

00:37:25.800 --> 00:37:27.180
that you've broken preimages.

00:37:27.180 --> 00:37:29.190
That's something of an
interactive process where

00:37:29.190 --> 00:37:31.722
you say, hey, here's a y,
and then someone comes back

00:37:31.722 --> 00:37:33.180
with an x, and
you're like, oh, OK,

00:37:33.180 --> 00:37:36.120
you prove to me that
you can find preimages.

00:37:36.120 --> 00:37:38.130
But that's hard to tell
to the rest of the world

00:37:38.130 --> 00:37:40.230
because it was sort
of interactive,

00:37:40.230 --> 00:37:43.290
whereas collisions are very
clear and non-interactive.

00:37:43.290 --> 00:37:45.990
You can just say, hey,
here's an x and here's a z.

00:37:45.990 --> 00:37:47.320
Anyone can verify these.

00:37:47.320 --> 00:37:49.450
Didn't really matter
how you got it.

00:37:49.450 --> 00:37:49.950
OK.

00:37:49.950 --> 00:37:55.360
So some practical, how
do these functions work.

00:37:55.360 --> 00:37:57.850
Practically speaking,
the collision resistance

00:37:57.850 --> 00:37:59.830
is a harder property.

00:37:59.830 --> 00:38:03.130
So there are many functions
where the collision resistance

00:38:03.130 --> 00:38:06.670
has been broken where the
preimage resistance has not

00:38:06.670 --> 00:38:07.510
been broken.

00:38:07.510 --> 00:38:10.270
So examples are Sha-1 and MD5.

00:38:10.270 --> 00:38:15.250
MD5's a fairly old one written
by Ron Rivest over at--

00:38:15.250 --> 00:38:17.350
well, I guess it wasn't
at the Stata Center

00:38:17.350 --> 00:38:18.880
because it was in the '80s.

00:38:18.880 --> 00:38:21.100
But this was message digest 5.

00:38:21.100 --> 00:38:23.500
I guess there were
several before that.

00:38:23.500 --> 00:38:25.780
And that is quite broken.

00:38:25.780 --> 00:38:26.680
You shouldn't use it.

00:38:26.680 --> 00:38:30.790
Its collision resistance
is trivially broken.

00:38:30.790 --> 00:38:34.710
You can find collisions in under
a second on a modern computer.

00:38:34.710 --> 00:38:39.910
Sha-1 happened later, in
the late '90s, I think,

00:38:39.910 --> 00:38:41.290
and NSA made it.

00:38:41.290 --> 00:38:43.220
And there have been
collisions found.

00:38:43.220 --> 00:38:45.220
I think there's really
only one collision that's

00:38:45.220 --> 00:38:48.250
been found, basically,
by a team at Google

00:38:48.250 --> 00:38:51.730
and some Italian
university last year.

00:38:51.730 --> 00:38:55.390
And they spent a lot of computer
time to find this collision.

00:38:55.390 --> 00:38:56.530
But they did find it.

00:38:56.530 --> 00:38:58.210
And then once you find one,
it's sort of like, oh, yeah,

00:38:58.210 --> 00:39:00.100
we really shouldn't
use this anymore.

00:39:00.100 --> 00:39:03.100
But in both of these
cases, sha-1 and MD5,

00:39:03.100 --> 00:39:05.620
there's no feasible
preimage attack.

00:39:05.620 --> 00:39:07.812
So given a hash output
for either of these,

00:39:07.812 --> 00:39:09.520
you can't find what
the input was, or you

00:39:09.520 --> 00:39:11.260
can't find a different input.

00:39:11.260 --> 00:39:14.410
So generally, it's a lot
easier to make a function

00:39:14.410 --> 00:39:16.240
strong against preimages.

00:39:16.240 --> 00:39:20.800
Collisions is sort of
harder to deal with.

00:39:20.800 --> 00:39:24.260
Also, practically speaking, how
do these hash functions work?

00:39:24.260 --> 00:39:26.690
It's a little bit
of black magic.

00:39:26.690 --> 00:39:31.450
There's no proofs that a
hash function can even exist.

00:39:31.450 --> 00:39:35.050
So if you could prove that
there is a one-way function,

00:39:35.050 --> 00:39:37.150
you get the Fields Medal, right?

00:39:37.150 --> 00:39:38.890
It's like a million
dollar prize.

00:39:38.890 --> 00:39:40.390
So if you can prove
it there is such

00:39:40.390 --> 00:39:42.310
a thing as a hash
function, you will be

00:39:42.310 --> 00:39:44.410
a super famous mathematician.

00:39:44.410 --> 00:39:47.250
We have no idea that this is
even mathematically possible.

00:39:47.250 --> 00:39:49.520
Or maybe the universe
doesn't work this way.

00:39:49.520 --> 00:39:50.980
It seems to, though.

00:39:50.980 --> 00:39:53.110
It seems like there
are these things that

00:39:53.110 --> 00:39:55.780
work like hash functions, that
work like one-way functions,

00:39:55.780 --> 00:39:57.300
but we have no proof of that.

00:39:57.300 --> 00:40:02.517
So even the most fundamental
part that everything hinges on,

00:40:02.517 --> 00:40:03.850
we don't even know if it exists.

00:40:03.850 --> 00:40:06.670
And then this is sort
of closely related,

00:40:06.670 --> 00:40:08.530
if you're in the
computer science-y stuff,

00:40:08.530 --> 00:40:11.670
like p and mp--

00:40:11.670 --> 00:40:15.400
anyway, so we don't know
that these actually work.

00:40:15.400 --> 00:40:18.190
And also, in practice,
hash functions

00:40:18.190 --> 00:40:21.610
are not nice math, cool
things like elliptic curves

00:40:21.610 --> 00:40:24.370
and RSA, prime numbers
and stuff like that.

00:40:24.370 --> 00:40:27.700
They're really, if you look at
the code, it's sort of like,

00:40:27.700 --> 00:40:29.260
well, I'm going to
take these bytes

00:40:29.260 --> 00:40:30.397
and I'm going to swap them.

00:40:30.397 --> 00:40:32.230
And then I'm going to
add these two numbers,

00:40:32.230 --> 00:40:34.900
and then I'm going to
rotate the bits over here,

00:40:34.900 --> 00:40:36.880
and then I'm going to
x over these things.

00:40:36.880 --> 00:40:39.100
And then I'm going
to do that 50 times.

00:40:39.100 --> 00:40:39.820
And why 50?

00:40:39.820 --> 00:40:42.290
Well, it seems like
50 is a good number.

00:40:42.290 --> 00:40:43.810
It's not too slow.

00:40:43.810 --> 00:40:44.650
No, really.

00:40:44.650 --> 00:40:50.180
It's sort of black magic,
Sha-256 uses 64 rounds.

00:40:50.180 --> 00:40:52.120
Nice even number.

00:40:52.120 --> 00:40:55.222
Different functions like
Blake 2B uses 20 rounds.

00:40:55.222 --> 00:40:56.930
But then there's also
a version that uses

00:40:56.930 --> 00:40:58.510
12 rounds, which is faster.

00:40:58.510 --> 00:41:02.710
And people think, well, it's
still seems quite secure.

00:41:02.710 --> 00:41:04.370
But if you want to
be really secure,

00:41:04.370 --> 00:41:05.440
use the 20-round variant.

00:41:05.440 --> 00:41:07.148
If you want to be
probably secure enough,

00:41:07.148 --> 00:41:08.300
use the 12-round variant.

00:41:08.300 --> 00:41:11.830
So there's no proofs.

00:41:11.830 --> 00:41:15.460
There's heuristics and things
like that, and best practices.

00:41:15.460 --> 00:41:20.440
But this kind of cryptography
is a little bit of black magic.

00:41:20.440 --> 00:41:24.580
And it's not based on any cool
mathematical number theory

00:41:24.580 --> 00:41:27.130
stuff, either, the way
that elliptic curve

00:41:27.130 --> 00:41:29.800
cryptography or RSA stuff is.

00:41:29.800 --> 00:41:31.330
So if you break
RSA, you can say,

00:41:31.330 --> 00:41:34.960
hey, I can now factor
these composite numbers

00:41:34.960 --> 00:41:37.300
very quickly, that's,
in and of itself,

00:41:37.300 --> 00:41:39.040
a cool mathematical discovery.

00:41:39.040 --> 00:41:43.000
The breaking of Sha-1,
there's not really

00:41:43.000 --> 00:41:44.530
any cool math insight.

00:41:44.530 --> 00:41:47.020
It was just like, yeah, we
found this fairly specific,

00:41:47.020 --> 00:41:50.080
weird path that we were
able to break Sha-1

00:41:50.080 --> 00:41:52.830
after a couple of
years of computer.

00:41:52.830 --> 00:41:56.900
So it's cool, and some
people are super into it.

00:41:56.900 --> 00:41:59.960
But it's something of a niche to
actually build hash functions.

00:41:59.960 --> 00:42:02.630
I would recommend not building
your own hash function.

00:42:02.630 --> 00:42:03.170
Yes.

00:42:03.170 --> 00:42:04.670
AUDIENCE: I'm Wayne,
and my question

00:42:04.670 --> 00:42:08.020
is, is breaking a hash function
literally just guess and check,

00:42:08.020 --> 00:42:10.118
or is there more
of a method to it?

00:42:10.118 --> 00:42:10.910
TADGE DRYJA: So no.

00:42:10.910 --> 00:42:16.490
If you say, hey, I
found a collision

00:42:16.490 --> 00:42:19.700
by doing two to
the 128 attempts.

00:42:19.700 --> 00:42:21.980
One, nobody's done two
to the 128 attempts.

00:42:21.980 --> 00:42:25.162
That's still seen as like
beyond technology today.

00:42:25.162 --> 00:42:27.620
But if that's how you break
the function, that's not really

00:42:27.620 --> 00:42:29.995
considered a break because
that's sort of the definition,

00:42:29.995 --> 00:42:33.260
is yeah, well, we know
this is 256 bits long.

00:42:33.260 --> 00:42:36.950
So to find a preimage, if you
do two to the 256 attempts,

00:42:36.950 --> 00:42:37.700
you'll find it.

00:42:37.700 --> 00:42:39.170
So that's not
considered a break.

00:42:39.170 --> 00:42:43.310
A break is considered, hey,
I found a preimage in two

00:42:43.310 --> 00:42:45.560
to the 240 attempts.

00:42:45.560 --> 00:42:49.040
Or I have a proof
that you will be

00:42:49.040 --> 00:42:51.950
able to find a preimage in
two to the 240 attempts,

00:42:51.950 --> 00:42:53.150
and here's how to do it.

00:42:53.150 --> 00:42:55.070
And that's considered a break.

00:42:55.070 --> 00:42:56.210
It's still impractical.

00:42:56.210 --> 00:42:58.580
Two to the 240's still
impossible in today's

00:42:58.580 --> 00:43:00.020
technology.

00:43:00.020 --> 00:43:01.985
But if you had a paper
and people looked at it,

00:43:01.985 --> 00:43:04.610
like, oh, yeah, that would work,
you wouldn't be able to do it.

00:43:04.610 --> 00:43:07.190
But that's still
considered broken.

00:43:07.190 --> 00:43:13.480
And so something like
MD5, MD5 output size

00:43:13.480 --> 00:43:15.810
was 16 bytes or 128 bits.

00:43:15.810 --> 00:43:19.790
So collisions, even
if it were strong,

00:43:19.790 --> 00:43:22.370
it would still be
too short today

00:43:22.370 --> 00:43:26.390
that collisions would be able
to be found in two to the 64

00:43:26.390 --> 00:43:29.540
iterations, which is doable
on today's computers.

00:43:29.540 --> 00:43:33.230
If you run a bunch of stuff on
AWS, you can do two to the 64

00:43:33.230 --> 00:43:35.840
in a couple of days.

00:43:35.840 --> 00:43:37.700
But that's the
different definitions

00:43:37.700 --> 00:43:40.690
of breaking the function.

00:43:40.690 --> 00:43:41.900
Sort of fun.

00:43:41.900 --> 00:43:44.120
Ethan Hellman,
who's at BU and we

00:43:44.120 --> 00:43:49.070
work with, he-- and we all broke
the IOTA wrote their own hash

00:43:49.070 --> 00:43:51.050
function, which is like
some cryptocurrency.

00:43:51.050 --> 00:43:52.980
And we found collisions in it.

00:43:52.980 --> 00:43:55.180
And it was kind of fun.

00:43:55.180 --> 00:43:57.072
But yeah, it was weird.

00:43:57.072 --> 00:43:58.280
It wasn't like number theory.

00:43:58.280 --> 00:44:00.650
It was just like, oh, well,
I wrote this Python script

00:44:00.650 --> 00:44:03.740
and we have this go script,
and we tried this thing

00:44:03.740 --> 00:44:05.153
and we got a collision.

00:44:05.153 --> 00:44:06.070
So it was kind of fun.

00:44:06.070 --> 00:44:07.400
So usages.

00:44:07.400 --> 00:44:10.070
What do you use
these hashes for?

00:44:10.070 --> 00:44:12.230
There's lots of cool things
you can use them for.

00:44:12.230 --> 00:44:14.870
use them sort of as
names or references,

00:44:14.870 --> 00:44:19.850
where instead of naming
a file, you can just

00:44:19.850 --> 00:44:21.620
take the hash of a file.

00:44:21.620 --> 00:44:27.770
And that is a good, compact
representation so you can point

00:44:27.770 --> 00:44:29.450
to what you're talking about .

00:44:29.450 --> 00:44:32.660
So the hash of a file is
a unique representation.

00:44:32.660 --> 00:44:35.360
And if you change
any bit in that file,

00:44:35.360 --> 00:44:36.770
the hash will change.

00:44:36.770 --> 00:44:41.180
And so you know that, OK, here's
this way to point to a file.

00:44:41.180 --> 00:44:43.520
You can also use it as sort
of a reference or pointer

00:44:43.520 --> 00:44:46.320
in different algorithms.

00:44:46.320 --> 00:44:50.420
So you can say, anything
you're using pointers for,

00:44:50.420 --> 00:44:53.760
linked lists or maps and
stuff like that, you can say,

00:44:53.760 --> 00:44:56.900
well, I'm going to use
a hash as a pointer

00:44:56.900 --> 00:45:00.540
and then be able to sort
through it that way.

00:45:00.540 --> 00:45:05.690
So anytime you think of pointers
and graph theory and stuff

00:45:05.690 --> 00:45:08.330
like that in computer
science, think, well,

00:45:08.330 --> 00:45:11.170
could I use a hash function
here instead of just

00:45:11.170 --> 00:45:12.740
like regular memory pointer?

00:45:12.740 --> 00:45:14.390
And in many cases, you can.

00:45:14.390 --> 00:45:15.710
In some cases, you can't.

00:45:15.710 --> 00:45:17.920
So you can't have cycles.

00:45:17.920 --> 00:45:20.270
So the idea is you
can't find preimages,

00:45:20.270 --> 00:45:22.340
you won't be able to find a--

00:45:22.340 --> 00:45:26.930
whereas you could make a cycle
of pointers in a computer,

00:45:26.930 --> 00:45:28.595
where A points to
B, B points to C,

00:45:28.595 --> 00:45:31.460
C points back to
A. You shouldn't

00:45:31.460 --> 00:45:34.010
be able to produce that
with hash functions

00:45:34.010 --> 00:45:37.130
because having that cycle
means, OK, well, somehow you

00:45:37.130 --> 00:45:38.330
found this preimage.

00:45:41.230 --> 00:45:43.350
But in many cases,
you can do this.

00:45:43.350 --> 00:45:46.290
And another way to look at it
is the hash is a commitment.

00:45:46.290 --> 00:45:48.960
You can say, well, I'm not
going to tell you what x is,

00:45:48.960 --> 00:45:53.400
but I'll tell you what y is,
and I can reveal x later.

00:45:53.400 --> 00:45:55.590
And then, since
everyone remembers y,

00:45:55.590 --> 00:45:59.042
they can be sure that yeah,
he's revealing the right thing.

00:45:59.042 --> 00:46:00.750
There are no collisions
in this function,

00:46:00.750 --> 00:46:02.310
so we can be sure,
if we're presented

00:46:02.310 --> 00:46:06.680
with x, that this was the x
that was committed to yesterday.

00:46:06.680 --> 00:46:11.280
So I'll give a little example
of that, of commit and reveal.

00:46:11.280 --> 00:46:13.640
So you can commit to some
kind of secret or something

00:46:13.640 --> 00:46:15.910
you want to reveal later
and reveal the preimage.

00:46:15.910 --> 00:46:18.260
So here's my commitment.

00:46:18.260 --> 00:46:21.950
This is an actual hash, Sha-256.

00:46:21.950 --> 00:46:23.780
I just made it on my computer.

00:46:23.780 --> 00:46:25.220
And there is a string.

00:46:25.220 --> 00:46:28.550
There's an Ascii string
that maps into this,

00:46:28.550 --> 00:46:31.490
and it is a prediction
about the weather,

00:46:31.490 --> 00:46:32.510
but that's all I'll say.

00:46:32.510 --> 00:46:35.330
And given that information
and given this hash,

00:46:35.330 --> 00:46:38.060
you probably can't
find my prediction.

00:46:38.060 --> 00:46:40.610
You can try to try all these
different Ascii strings

00:46:40.610 --> 00:46:44.930
about the weather today,
but I'll reveal it.

00:46:44.930 --> 00:46:47.550
So I think it won't
snow Wednesday.

00:46:47.550 --> 00:46:49.370
But I think it
actually-- anyway,

00:46:49.370 --> 00:46:50.630
and then I put this number in.

00:46:50.630 --> 00:46:53.900
And so if you put this in
your computer in Linux--

00:46:53.900 --> 00:46:56.450
I think in Mac it's a
slightly different command.

00:46:56.450 --> 00:46:59.993
It's like Sha-2 or something.

00:46:59.993 --> 00:47:01.910
But in Linux, this will
work, and you can say,

00:47:01.910 --> 00:47:03.860
I think it won't snow Wednesday.

00:47:03.860 --> 00:47:06.860
And then I put some
random numbers here

00:47:06.860 --> 00:47:10.100
because if I had committed
to just the phrase,

00:47:10.100 --> 00:47:12.380
I think it won't
snow Wednesday, you

00:47:12.380 --> 00:47:14.330
might have been
able to guess that.

00:47:14.330 --> 00:47:16.580
You could say, well, he said
it was about the weather.

00:47:16.580 --> 00:47:19.760
I'm going to take
all sorts of millions

00:47:19.760 --> 00:47:21.770
of different strings
related to days

00:47:21.770 --> 00:47:23.725
and weather and
common English words,

00:47:23.725 --> 00:47:25.100
and I'm going to
try hashing them

00:47:25.100 --> 00:47:26.720
and see if I find a collision.

00:47:26.720 --> 00:47:28.340
And you might be able to.

00:47:28.340 --> 00:47:30.920
But I added this four
bytes of randomness

00:47:30.920 --> 00:47:33.390
at the end to make
that difficult.

00:47:33.390 --> 00:47:35.600
It doesn't really
contribute to my commitment.

00:47:35.600 --> 00:47:38.480
And you know this doesn't
really mean anything.

00:47:38.480 --> 00:47:43.610
But it makes it harder to
guess what my input was

00:47:43.610 --> 00:47:45.410
because I've already
revealed that it's not

00:47:45.410 --> 00:47:46.910
a fully random input.

00:47:46.910 --> 00:47:48.920
So you might be able
to guess things.

00:47:48.920 --> 00:47:50.810
So I could say, hey,
I'm going to make

00:47:50.810 --> 00:47:55.160
a prediction about the
weather, commit to it,

00:47:55.160 --> 00:47:57.260
and then reveal my
prediction tomorrow.

00:47:57.260 --> 00:47:59.990
And we'll see if I was right.

00:47:59.990 --> 00:48:03.747
This can be useful
in the case where--

00:48:03.747 --> 00:48:05.330
not the weather, but
in other things--

00:48:05.330 --> 00:48:10.130
if knowing my prediction could
influence the actual events,

00:48:10.130 --> 00:48:13.422
this would be a nice way to
commit to what my prediction is

00:48:13.422 --> 00:48:15.380
without everyone knowing
what the prediction is

00:48:15.380 --> 00:48:17.260
and then revealing
it the next day.

00:48:17.260 --> 00:48:17.760
Yes.

00:48:17.760 --> 00:48:19.927
AUDIENCE: What are the use
cases for double hashing,

00:48:19.927 --> 00:48:22.000
like where you would
hash that hash?

00:48:22.000 --> 00:48:24.840
TADGE DRYJA: Hashing this again?

00:48:24.840 --> 00:48:29.210
Well, so in bitcoin they
hash everything twice.

00:48:33.330 --> 00:48:36.180
Generally, you don't need to.

00:48:36.180 --> 00:48:39.870
There's no explanation for
why they do that in bitcoin.

00:48:39.870 --> 00:48:40.950
You could.

00:48:40.950 --> 00:48:42.780
But there are things
you can construct

00:48:42.780 --> 00:48:45.908
where you can, say,
append some extra data

00:48:45.908 --> 00:48:46.950
and then hash this again.

00:48:46.950 --> 00:48:51.180
So you can say, here's my
prediction for next week.

00:48:51.180 --> 00:48:54.180
And this is the hash,
and then hash it again.

00:48:54.180 --> 00:48:56.850
So you can make
chains of commitments

00:48:56.850 --> 00:49:00.150
and then reveal
iterations of it.

00:49:00.150 --> 00:49:01.530
Actually, I had
some slides where

00:49:01.530 --> 00:49:05.280
you can sort of hash
something again and again,

00:49:05.280 --> 00:49:09.190
and start revealing
it incrementally.

00:49:09.190 --> 00:49:10.390
That might be useful.

00:49:10.390 --> 00:49:12.350
I actually have stuff
like that in software.

00:49:12.350 --> 00:49:16.200
I've written where you
want to reveal secrets.

00:49:16.200 --> 00:49:18.520
But let's say I want
to reveal secrets,

00:49:18.520 --> 00:49:21.310
but I don't want everyone to
have to store all of them.

00:49:21.310 --> 00:49:26.080
So I can make a chain of
hashes, commit to the last one,

00:49:26.080 --> 00:49:28.870
and then as I reveal
successive preimages,

00:49:28.870 --> 00:49:30.370
you don't have to
store all of them.

00:49:30.370 --> 00:49:34.210
You can just store
the latest preimage,

00:49:34.210 --> 00:49:37.150
and you can reconstruct
all the hashes from that.

00:49:37.150 --> 00:49:38.850
Yes.

00:49:38.850 --> 00:49:40.308
AUDIENCE: But is
it computationally

00:49:40.308 --> 00:49:42.730
difficult to run double hashes?

00:49:42.730 --> 00:49:44.110
TADGE DRYJA: So to evaluate--

00:49:44.110 --> 00:49:46.720
if you want to try this,
it's imperceptible.

00:49:46.720 --> 00:49:50.798
To perform one
Sha-256 hash is, I

00:49:50.798 --> 00:49:52.840
don't know, a billionth
of a second or something.

00:49:52.840 --> 00:49:57.850
You can generally do,
like, 100 megabytes

00:49:57.850 --> 00:50:01.455
to a gigabyte of hash
output on a regular CPU.

00:50:01.455 --> 00:50:02.830
NEHA NARULA: I
think she's asking

00:50:02.830 --> 00:50:05.830
does it make it harder to find
a preimage if you hash twice,

00:50:05.830 --> 00:50:06.838
and the answer's no.

00:50:06.838 --> 00:50:08.380
TADGE DRYJA: The
answer's sort of no.

00:50:08.380 --> 00:50:10.480
It might.

00:50:10.480 --> 00:50:14.410
So I don't know, chained MD5,
can you still find collisions?

00:50:14.410 --> 00:50:15.640
I'm not sure.

00:50:15.640 --> 00:50:19.540
But generally the thinking is,
if the hash function is broken,

00:50:19.540 --> 00:50:22.160
and you can either find
collisions or preimages, yeah,

00:50:22.160 --> 00:50:25.450
maybe it gets a little
harder by iterating it.

00:50:25.450 --> 00:50:27.040
But you should
just stop using it

00:50:27.040 --> 00:50:29.640
and use something that's secure.

00:50:29.640 --> 00:50:32.937
But yeah, it seems
that finding preimages

00:50:32.937 --> 00:50:35.020
would be harder since it's
essentially adding more

00:50:35.020 --> 00:50:38.290
rounds by hashing it twice.

00:50:38.290 --> 00:50:41.290
And then there are some attacks,
so it's fairly out there.

00:50:41.290 --> 00:50:43.870
But it's called length
extension attacks

00:50:43.870 --> 00:50:46.150
due to how hash functions
are constructed,

00:50:46.150 --> 00:50:48.280
where if you do say, OK,
I'm going to take the hash

00:50:48.280 --> 00:50:50.410
and then take the
hash of that, you

00:50:50.410 --> 00:50:54.970
do prevent certain types of
attacks that are fairly niche.

00:50:54.970 --> 00:50:57.150
But a length
extinction attack in

00:50:57.150 --> 00:51:00.640
a Merkle-Damgard construction
will be prevented by this.

00:51:00.640 --> 00:51:01.838
So generally, no.

00:51:01.838 --> 00:51:03.380
Generally, you don't
need to do this.

00:51:03.380 --> 00:51:05.170
But there are different
constructions where you're

00:51:05.170 --> 00:51:06.610
going to hash a bunch of times.

00:51:06.610 --> 00:51:09.250
I don't have the slides
here but, like a Merkle tree

00:51:09.250 --> 00:51:11.745
is a binary tree of
hashes where you're

00:51:11.745 --> 00:51:13.120
taking the hashes
of these things

00:51:13.120 --> 00:51:14.680
and then hashing
it again and again,

00:51:14.680 --> 00:51:16.540
and that's a really
useful data structure.

00:51:16.540 --> 00:51:20.950
And a blockchain is
essentially a chain of hashes.

00:51:20.950 --> 00:51:24.460
And that's what we'll
talk about next week.

00:51:24.460 --> 00:51:24.980
But yeah.

00:51:24.980 --> 00:51:25.480
OK.

00:51:25.480 --> 00:51:27.040
So I'm going to go
a little faster.

00:51:27.040 --> 00:51:28.810
So that's an interesting
use case where

00:51:28.810 --> 00:51:30.160
you can commit and reveal.

00:51:30.160 --> 00:51:34.950
And yeah, adding randomness so
you can't guess the preimage.

00:51:34.950 --> 00:51:38.880
This is called a hash-based
message authentication

00:51:38.880 --> 00:51:43.380
code where part of it is
secret and part of it is not.

00:51:43.380 --> 00:51:47.640
And this is getting towards a
signature, where I've committed

00:51:47.640 --> 00:51:49.350
to something, and
then I reveal it,

00:51:49.350 --> 00:51:51.270
and everyone knows,
yeah, that must be what

00:51:51.270 --> 00:51:53.220
he committed to the day before.

00:51:53.220 --> 00:51:57.760
It's not quite a signature, but
it's getting to that direction.

00:51:57.760 --> 00:52:01.440
And so next I'm going to
talk about signatures.

00:52:01.440 --> 00:52:03.510
What is a signature?

00:52:03.510 --> 00:52:07.410
It's useful, and it's a
message signed by someone.

00:52:07.410 --> 00:52:09.370
And so I'll define
what a signature

00:52:09.370 --> 00:52:12.753
is through the
functions that it uses.

00:52:12.753 --> 00:52:14.170
There's three
functions will allow

00:52:14.170 --> 00:52:16.480
you to create a
signature scheme,

00:52:16.480 --> 00:52:20.050
generate keys, sign, and verify.

00:52:20.050 --> 00:52:22.060
And these different things.

00:52:22.060 --> 00:52:26.230
Generate keys, you make a
secret key and a public key.

00:52:26.230 --> 00:52:28.720
And so the idea is there's
some public key which is

00:52:28.720 --> 00:52:33.160
your identity , and there's
some secret key which you only

00:52:33.160 --> 00:52:33.700
control.

00:52:33.700 --> 00:52:36.670
And you use that to
prove your identity

00:52:36.670 --> 00:52:40.480
and prove that these
messages are signed by you.

00:52:40.480 --> 00:52:43.210
So yeah, you
generate a key pair.

00:52:43.210 --> 00:52:46.960
The holder of the secret
key can sign a message.

00:52:46.960 --> 00:52:49.930
And then anyone
possessing a public key

00:52:49.930 --> 00:52:53.230
can verify a message
signature pair.

00:52:53.230 --> 00:52:57.500
So I'll go into detail
on these three functions.

00:52:57.500 --> 00:52:58.930
And this applies generally.

00:52:58.930 --> 00:53:03.160
So I'm going to talk about a
hash-based signature in detail,

00:53:03.160 --> 00:53:05.980
but there are many
different signature schemes.

00:53:05.980 --> 00:53:11.860
DSA, ElGamal, RSA signatures,
elliptic curve signatures.

00:53:11.860 --> 00:53:16.120
There's tons of different
cool math systems that

00:53:16.120 --> 00:53:19.450
allow these kinds of functions.

00:53:19.450 --> 00:53:20.950
And I'll talk
about in some ways,

00:53:20.950 --> 00:53:23.445
this is one of
the simplest ones.

00:53:23.445 --> 00:53:25.070
So yeah, there's
these three functions.

00:53:25.070 --> 00:53:26.690
The first one is generate keys.

00:53:26.690 --> 00:53:29.860
And it returns a private
key public key pair.

00:53:29.860 --> 00:53:32.500
And it generally doesn't
take any arguments,

00:53:32.500 --> 00:53:34.030
but it takes in randomness.

00:53:34.030 --> 00:53:35.020
You need to flip coins.

00:53:35.020 --> 00:53:38.200
You need to find random
one and zero bits.

00:53:38.200 --> 00:53:40.300
And it has to be long
enough that no one else can

00:53:40.300 --> 00:53:42.040
guess what your private key is.

00:53:44.737 --> 00:53:46.320
So you have a private
key, public key.

00:53:46.320 --> 00:53:47.220
Public key is public.

00:53:47.220 --> 00:53:48.080
You tell everyone.

00:53:48.080 --> 00:53:50.868
Private key is more secret key.

00:53:50.868 --> 00:53:53.160
Actually, I think in the
code, I always say secret key.

00:53:53.160 --> 00:53:55.290
It's usually better to say
secret key because at least it

00:53:55.290 --> 00:53:56.707
starts with a
letter that's not p.

00:53:59.200 --> 00:53:59.700
OK.

00:53:59.700 --> 00:54:01.440
And then the signing
function, where

00:54:01.440 --> 00:54:03.360
you take your secret
key and your message,

00:54:03.360 --> 00:54:08.160
and it signs a message
and returns a signature.

00:54:08.160 --> 00:54:10.890
All these things are just
strings of ones and zeros.

00:54:10.890 --> 00:54:12.720
It's just a bunch of bytes.

00:54:12.720 --> 00:54:15.780
Public key, a private key,
a signature, a message.

00:54:15.780 --> 00:54:17.950
These are all just bytes.

00:54:17.950 --> 00:54:20.780
And then the verify function,
which is the most complex.

00:54:20.780 --> 00:54:24.550
A verify function takes a
public key that you've seen,

00:54:24.550 --> 00:54:26.920
a message, and a signature.

00:54:26.920 --> 00:54:31.000
And it returns a Boolean
whether this was valid or not.

00:54:31.000 --> 00:54:32.455
So it returns a single bit.

00:54:32.455 --> 00:54:34.330
If it's zero, it says,
yeah, these two things

00:54:34.330 --> 00:54:36.820
don't match up.

00:54:36.820 --> 00:54:39.300
Maybe the message just
changed, or maybe the signature

00:54:39.300 --> 00:54:41.550
has changed, or maybe it's
from a different public key

00:54:41.550 --> 00:54:42.100
or something.

00:54:42.100 --> 00:54:44.830
But if all three of
these are correct,

00:54:44.830 --> 00:54:47.780
and the signing function
was the private key--

00:54:47.780 --> 00:54:50.050
the secret key associated
with this public key--

00:54:50.050 --> 00:54:52.860
was signed to this message
and produce this signature,

00:54:52.860 --> 00:54:55.810
then it will return true.

00:54:55.810 --> 00:54:58.120
And so you get into
the math properties

00:54:58.120 --> 00:55:01.090
of what does it mean
to forge a signature,

00:55:01.090 --> 00:55:04.480
and can they be forgeable
computationally?

00:55:04.480 --> 00:55:07.330
Eventually a lot of these
things, since it's bits,

00:55:07.330 --> 00:55:09.190
you could eventually
guess the forgery.

00:55:09.190 --> 00:55:12.780
But maybe that takes two to
the 256 attempts or something.

00:55:12.780 --> 00:55:13.280
OK.

00:55:13.280 --> 00:55:17.108
So any questions about the
basic structure of what

00:55:17.108 --> 00:55:18.400
constitutes a signature scheme?

00:55:21.430 --> 00:55:22.780
Mostly make sense?

00:55:22.780 --> 00:55:25.480
And you can see
how this is useful.

00:55:25.480 --> 00:55:27.730
You can publish a public
key and say, hey, I'm Tadge.

00:55:27.730 --> 00:55:28.840
This is my public key.

00:55:28.840 --> 00:55:33.630
And in fact, on my business
card, I have a RSA public key.

00:55:33.630 --> 00:55:36.477
And so if people get my business
card and then I sign a message

00:55:36.477 --> 00:55:38.560
and email it to them, they
could be sure that, oh,

00:55:38.560 --> 00:55:40.660
this is probably the same guy.

00:55:40.660 --> 00:55:42.440
Nobody ever cares.

00:55:42.440 --> 00:55:49.810
But it's useful for the
stuff we were talking about

00:55:49.810 --> 00:55:53.740
before with Chaumian cash, where
Alice needs to authenticate

00:55:53.740 --> 00:55:56.290
to the bank, and one way to
do it is to sign a message

00:55:56.290 --> 00:55:59.590
and say, hey, I'm
Alice, give me a coin.

00:55:59.590 --> 00:56:03.070
And then Alice can sign a
message to Bob and so on.

00:56:03.070 --> 00:56:05.620
So this is really useful as a
basic building block for all

00:56:05.620 --> 00:56:08.090
these kinds of messages.

00:56:08.090 --> 00:56:11.710
So I'll talk in
the last 14 minutes

00:56:11.710 --> 00:56:13.600
about signatures from hashes.

00:56:13.600 --> 00:56:14.440
This is doable.

00:56:14.440 --> 00:56:18.550
Using just hash functions, you
can construct a signatures key.

00:56:18.550 --> 00:56:21.760
And in fact, that's
the first problem set.

00:56:21.760 --> 00:56:25.390
And you implement a signature
system using only hashes.

00:56:25.390 --> 00:56:27.700
And the hash function is
already defined for you.

00:56:27.700 --> 00:56:28.990
It's in the standard library.

00:56:28.990 --> 00:56:32.000
It's just Sha-256, the
same thing bitcoin uses.

00:56:32.000 --> 00:56:33.850
And this is called
Lamport signatures.

00:56:33.850 --> 00:56:37.090
Leslie Lamport wrote
about this late '70s.

00:56:37.090 --> 00:56:39.850
I forget exactly when
the paper came out.

00:56:39.850 --> 00:56:43.420
But this was one of the
earliest cryptographic signature

00:56:43.420 --> 00:56:45.260
schemes.

00:56:45.260 --> 00:56:47.150
And it's kind of cool.

00:56:47.150 --> 00:56:51.280
And another fun thing is
it's quantum resistant.

00:56:51.280 --> 00:56:53.410
So if you know about
quantum computers,

00:56:53.410 --> 00:56:55.960
quantum computers kind
of ruin all the fun

00:56:55.960 --> 00:56:57.880
in terms of cryptography.

00:56:57.880 --> 00:57:00.335
All the cool things we can do
with cryptography-- not all,

00:57:00.335 --> 00:57:01.960
but most of them get
ruined by quantum.

00:57:01.960 --> 00:57:04.960
Computers but hash
functions are quite

00:57:04.960 --> 00:57:07.720
resistant to quantum
computers because they're not

00:57:07.720 --> 00:57:08.715
based on any fun math.

00:57:08.715 --> 00:57:10.090
They're based on
this black magic

00:57:10.090 --> 00:57:14.740
of just XORing and
shifting numbers around.

00:57:14.740 --> 00:57:18.495
That's a huge
oversimplification.

00:57:18.495 --> 00:57:19.870
But yeah, so those
hash functions

00:57:19.870 --> 00:57:21.590
are generally seen to
be quantum-resistance.

00:57:21.590 --> 00:57:23.230
So if you have a
signature scheme that

00:57:23.230 --> 00:57:25.120
only uses hash
functions, well, it still

00:57:25.120 --> 00:57:27.238
works, even if someone
invents a quantum computer

00:57:27.238 --> 00:57:28.780
and can break all
these other things,

00:57:28.780 --> 00:57:31.690
like RSA and elliptic curves.

00:57:31.690 --> 00:57:33.250
So there's actually
renewed interest

00:57:33.250 --> 00:57:36.200
in these kinds of
systems recently.

00:57:36.200 --> 00:57:36.700
OK.

00:57:36.700 --> 00:57:41.570
So how do you make a signature
scene with just hash functions?

00:57:41.570 --> 00:57:43.960
So how do you generate
a key, in this case?

00:57:43.960 --> 00:57:47.740
So a public key and a private
key you want to generate.

00:57:47.740 --> 00:57:49.390
So first we generate
our private key.

00:57:49.390 --> 00:57:55.910
Now these squares
are 32 bytes each,

00:57:55.910 --> 00:57:59.130
and you generate 256
of them on this row,

00:57:59.130 --> 00:58:00.990
256 of them on that row.

00:58:00.990 --> 00:58:08.220
So you're generating 256 times
two, or 512 32-byte blocks.

00:58:08.220 --> 00:58:11.550
And these blocks are each
256 bits or 32 bytes.

00:58:11.550 --> 00:58:13.890
So in total, that's what, 8K?

00:58:13.890 --> 00:58:15.480
Eight kilobytes, I think.

00:58:15.480 --> 00:58:16.400
Pretty big.

00:58:16.400 --> 00:58:18.810
But anyway, you're saying,
OK, here's my private key.

00:58:18.810 --> 00:58:20.310
It's all completely random.

00:58:20.310 --> 00:58:24.060
I just take slash dev
slash urandom or whatever,

00:58:24.060 --> 00:58:29.610
just flip coins 8,000 times,
or however many this is total,

00:58:29.610 --> 00:58:31.320
and generate all
these different blocks

00:58:31.320 --> 00:58:34.460
and store them on my hard
drive and keep it secret.

00:58:34.460 --> 00:58:37.150
Then I want to generate
the public key.

00:58:37.150 --> 00:58:39.810
So for each of these
32-byte blocks,

00:58:39.810 --> 00:58:42.290
I take the hash of it,
which will also be 32 bytes.

00:58:45.570 --> 00:58:52.020
So there's now 512 hashes, 256
on this row, 256 on this row.

00:58:52.020 --> 00:58:55.740
The green will be my public key.

00:58:55.740 --> 00:58:58.410
And the gray one
is my secret key.

00:58:58.410 --> 00:58:59.910
So they all look the same.

00:58:59.910 --> 00:59:03.000
They all look like just a
bunch of random ones and zeros.

00:59:03.000 --> 00:59:06.300
The gray ones actually are a
bunch of random ones and zeros.

00:59:06.300 --> 00:59:08.700
The green ones are
actually hashes, though,

00:59:08.700 --> 00:59:10.260
of all the gray ones.

00:59:10.260 --> 00:59:12.830
And I publish the green ones.

00:59:12.830 --> 00:59:15.270
Just to serialize it,
I just put in a row.

00:59:15.270 --> 00:59:18.210
I say, OK, here's this first
32-bit, second, third, fourth,

00:59:18.210 --> 00:59:22.660
and then go to this row or
whatever scheme you want.

00:59:22.660 --> 00:59:24.190
So how is this useful?

00:59:24.190 --> 00:59:27.670
Now everyone knows
a bunch of hashes,

00:59:27.670 --> 00:59:31.480
and I know a bunch
of the preimages.

00:59:31.480 --> 00:59:34.120
So now it's sort of this
commit reveal thing, where

00:59:34.120 --> 00:59:38.590
if I reveal to you this,
you can verify that, oh,

00:59:38.590 --> 00:59:43.450
yeah, that mapped to
this one later on.

00:59:43.450 --> 00:59:46.910
Any questions so far
about this process?

00:59:46.910 --> 00:59:49.550
Seems sort of useless but
fairly straightforward.

00:59:49.550 --> 00:59:50.100
OK.

00:59:50.100 --> 00:59:51.390
Then I want to sign.

00:59:51.390 --> 00:59:54.830
So first, to sign a
message, I'm going

00:59:54.830 --> 00:59:57.220
to take the hash of
the message to sign.

00:59:57.220 --> 00:59:58.940
And this is often done.

00:59:58.940 --> 00:59:59.870
It's done in bitcoin.

00:59:59.870 --> 01:00:02.870
It's done in most signature
schemes, where I want

01:00:02.870 --> 01:00:05.780
a fixed length number to sign.

01:00:05.780 --> 01:00:07.410
It's annoying to
have to say, well,

01:00:07.410 --> 01:00:09.380
what if I want to sign
a megabyte long file,

01:00:09.380 --> 01:00:13.145
or what if I want to sign
of 10-byte long string?

01:00:13.145 --> 01:00:14.270
You want to standardize it.

01:00:14.270 --> 01:00:18.950
So whatever I'm signing,
it's always 256 bits long.

01:00:18.950 --> 01:00:22.100
So if I want to just sign
the message hi, first

01:00:22.100 --> 01:00:25.460
I take the hash of the message
hi, which in Sha-256, this

01:00:25.460 --> 01:00:29.180
is the hash of hi.

01:00:29.180 --> 01:00:32.630
And so I look at this
as 256 bits, and I say,

01:00:32.630 --> 01:00:35.510
OK, I'm going to pick the
private key blocks to reveal

01:00:35.510 --> 01:00:37.740
based on the bits here.

01:00:37.740 --> 01:00:44.550
So the first bit here is
a one, because it's an 8.

01:00:44.550 --> 01:00:46.380
And so I'll reveal.

01:00:46.380 --> 01:00:49.170
And I indicated
before that there's

01:00:49.170 --> 01:00:52.080
this zero row and this one row.

01:00:52.080 --> 01:00:54.990
And now what that means
is, well, the first bit

01:00:54.990 --> 01:00:57.520
of my message to sign is a one.

01:00:57.520 --> 01:01:00.750
So I'm going to reveal
this gray square.

01:01:00.750 --> 01:01:03.970
And the next bit, the
next four bits, actually,

01:01:03.970 --> 01:01:05.720
since it's an eight,
are going to be zero.

01:01:05.720 --> 01:01:07.760
So I'll reveal
this and then I'll

01:01:07.760 --> 01:01:11.030
reveal this, this, and this.

01:01:11.030 --> 01:01:12.090
And I just made it up.

01:01:12.090 --> 01:01:13.100
But yeah.

01:01:13.100 --> 01:01:18.650
So for example, if I'm signing,
and it starts with 01101110,

01:01:18.650 --> 01:01:21.200
I reveal this preimage, this
preimage, this preimage,

01:01:21.200 --> 01:01:23.060
this preimage, these
three, this one.

01:01:23.060 --> 01:01:27.710
And so I reveal preimages
based on the bit representation

01:01:27.710 --> 01:01:32.230
of the message I'm
trying to sign, and then

01:01:32.230 --> 01:01:34.060
give everyone these.

01:01:34.060 --> 01:01:38.030
So my signature will
just be this sequence.

01:01:38.030 --> 01:01:40.125
I can go in row order here.

01:01:40.125 --> 01:01:41.500
Yeah, it's probably
a lot easier.

01:01:41.500 --> 01:01:42.340
So I go in sequence.

01:01:42.340 --> 01:01:44.997
I say, OK, here's the first
32 bytes of my signature.

01:01:44.997 --> 01:01:47.080
Here's the next, here's
the next, here's the next.

01:01:47.080 --> 01:01:51.970
And so my signature ends
up being 256 blocks long,

01:01:51.970 --> 01:01:54.580
each of which are 256 bits.

01:01:54.580 --> 01:01:56.850
So it's like 8K.

01:01:56.850 --> 01:01:59.520
The keys are 16K and
this is 8K or something.

01:01:59.520 --> 01:02:02.580
Fairly big but totally
doable on a computer today.

01:02:02.580 --> 01:02:05.300
Eight kilobytes is no big deal.

01:02:05.300 --> 01:02:05.800
OK.

01:02:05.800 --> 01:02:10.500
Now to verify,
take the signature,

01:02:10.500 --> 01:02:13.140
hash each block
of the signature,

01:02:13.140 --> 01:02:16.290
and see that it maps into
that part of the public key.

01:02:16.290 --> 01:02:18.327
So the people who are
verifying the signature,

01:02:18.327 --> 01:02:19.410
they have your public key.

01:02:19.410 --> 01:02:21.450
They have all the green squares.

01:02:21.450 --> 01:02:23.730
And now they have been
given a signature, which

01:02:23.730 --> 01:02:25.470
is these gray squares,
and they say, OK,

01:02:25.470 --> 01:02:26.595
well, let me hash this one.

01:02:26.595 --> 01:02:29.338
Oh, it maps to that,
so it maps to a zero.

01:02:29.338 --> 01:02:31.130
Oh, this maps to a one,
this maps to a one,

01:02:31.130 --> 01:02:32.430
this maps to a zero.

01:02:32.430 --> 01:02:34.020
And they can go
through and say yeah,

01:02:34.020 --> 01:02:38.513
this is a signature
on that message.

01:02:38.513 --> 01:02:39.930
In the case of
Lamport signatures,

01:02:39.930 --> 01:02:43.290
you can actually determine
what the message is just

01:02:43.290 --> 01:02:46.932
from the signature
in the public key.

01:02:46.932 --> 01:02:48.390
If you're given
this and you're not

01:02:48.390 --> 01:02:51.690
told whether it's a one or
a zero, well, just compare.

01:02:51.690 --> 01:02:54.420
Hash it and compare to
these two green ones.

01:02:54.420 --> 01:02:57.270
You'll be able to see.

01:02:57.270 --> 01:03:01.840
And that's a useful
signature because no one

01:03:01.840 --> 01:03:04.870
can forge that
because no one knows

01:03:04.870 --> 01:03:06.760
these preimages except
for the person who

01:03:06.760 --> 01:03:09.120
holds the secret key.

01:03:09.120 --> 01:03:12.180
So given your public key,
I can't forge a signature

01:03:12.180 --> 01:03:13.560
from you.

01:03:13.560 --> 01:03:17.130
Once the signature is issued,
I also can't forge a signature.

01:03:17.130 --> 01:03:21.510
The only bit sequence I know
is the one that you revealed.

01:03:21.510 --> 01:03:24.270
And so I know part
of your private key.

01:03:24.270 --> 01:03:25.650
I know half of it.

01:03:25.650 --> 01:03:31.170
But that half only lets me sign
the message you just signed.

01:03:31.170 --> 01:03:34.110
So I can't really do
anything extra with this.

01:03:34.110 --> 01:03:36.660
So this is a usable
signature scheme.

01:03:39.480 --> 01:03:40.830
I think I just showed it.

01:03:40.830 --> 01:03:44.146
But any downsides that you
can think of with this?

01:03:44.146 --> 01:03:45.505
AUDIENCE: You can only sign one.

01:03:45.505 --> 01:03:46.080
TADGE DRYJA: Yeah,
you can only sign one.

01:03:46.080 --> 01:03:47.111
Is that what you were--

01:03:47.111 --> 01:03:49.028
AUDIENCE: You could also
send the same message

01:03:49.028 --> 01:03:51.540
on to someone else with
different signatures.

01:03:51.540 --> 01:03:54.350
TADGE DRYJA: Yeah, but
signatures are sort of public.

01:03:54.350 --> 01:03:56.670
So yes, you're
saying that you can

01:03:56.670 --> 01:04:00.690
sign a message once and give
it to a bunch of people.

01:04:00.690 --> 01:04:02.880
And that's sort of a
feature, not a bug, I guess.

01:04:02.880 --> 01:04:05.760
There are different signature
schemes where you want,

01:04:05.760 --> 01:04:09.785
I only want this signature
to be valid to this person.

01:04:09.785 --> 01:04:11.160
There's different
ways to do that

01:04:11.160 --> 01:04:12.952
with Diffie-Hellman
key exchange and stuff.

01:04:12.952 --> 01:04:15.770
But the signature scheme
we've talked about here

01:04:15.770 --> 01:04:18.270
with these three functions, the
public key is really public,

01:04:18.270 --> 01:04:19.740
and anyone can verify.

01:04:19.740 --> 01:04:21.810
And that's something we want.

01:04:21.810 --> 01:04:24.360
If you don't want that,
there's other ways to do it.

01:04:24.360 --> 01:04:29.190
But yeah, the big one is,
wait, you can only sign once.

01:04:29.190 --> 01:04:32.070
Once you generate a key
pair, your private key,

01:04:32.070 --> 01:04:34.680
your public key, and you tell
everyone these green squares,

01:04:34.680 --> 01:04:40.050
if you're try to sign again,
you will reveal more pieces

01:04:40.050 --> 01:04:42.060
of your private key.

01:04:42.060 --> 01:04:43.850
So if I sign two
different messages,

01:04:43.850 --> 01:04:45.960
sometimes it's the same bit.

01:04:45.960 --> 01:04:47.340
Sometimes it's different bits.

01:04:47.340 --> 01:04:51.220
And now I start revealing
more pieces of my private key.

01:04:51.220 --> 01:04:53.430
And now people can start
to forge signatures

01:04:53.430 --> 01:04:58.500
because I can say, OK,
well, the first bit,

01:04:58.500 --> 01:05:00.660
I can sign anything
on the first bit.

01:05:00.660 --> 01:05:04.980
I'm still constrained
here and here and here.

01:05:04.980 --> 01:05:11.470
But in several locations, I
can sign whichever bit I want.

01:05:11.470 --> 01:05:15.750
And so the basic thing is,
if there's one signature,

01:05:15.750 --> 01:05:16.920
I can't forge anything.

01:05:16.920 --> 01:05:20.400
If you give me two signatures,
since it's generally random,

01:05:20.400 --> 01:05:22.860
on average, half of the
bits of the signature

01:05:22.860 --> 01:05:23.700
will be constrained.

01:05:23.700 --> 01:05:27.240
So in this case, if it's 256
bits long and you sign twice,

01:05:27.240 --> 01:05:32.670
I probably still can't forge
anything because 128 bits,

01:05:32.670 --> 01:05:34.510
I have the freedom
to pick either.

01:05:34.510 --> 01:05:39.810
And the other 128 bits, I'm
stuck with the one or the zero

01:05:39.810 --> 01:05:41.160
and I don't get to choose.

01:05:41.160 --> 01:05:45.060
So that means most
messages I want to sign,

01:05:45.060 --> 01:05:50.100
I won't be able to because if I
tried two to the 128 attempts,

01:05:50.100 --> 01:05:52.480
I'll be able to find
a forged signature.

01:05:52.480 --> 01:05:53.550
But that's a lot.

01:05:53.550 --> 01:05:55.830
And so maybe you can sign twice.

01:05:55.830 --> 01:05:57.450
But again, it's probabilistic.

01:05:57.450 --> 01:06:00.390
You might get unlucky
and reveal quite a bit

01:06:00.390 --> 01:06:05.010
more than 128 bits,
where you get both.

01:06:05.010 --> 01:06:08.790
But on average-- and then once
you have three signatures, OK,

01:06:08.790 --> 01:06:14.320
now I've probably revealed
3/4 of the locations

01:06:14.320 --> 01:06:16.540
you're going to have both
the one and zero row.

01:06:16.540 --> 01:06:18.250
And you can start--
and this starts

01:06:18.250 --> 01:06:23.140
to be practical
because in this case,

01:06:23.140 --> 01:06:27.280
you'd need a 2 two the 64
attempts to forge a signature.

01:06:27.280 --> 01:06:31.250
And that's doable on
today's computers.