WEBVTT

00:00:00.140 --> 00:00:02.470
The following content is
provided under a Creative

00:00:02.470 --> 00:00:03.860
Commons license.

00:00:03.860 --> 00:00:06.090
Your support will help
MIT OpenCourseWare

00:00:06.090 --> 00:00:10.180
continue to offer high quality,
educational resources for free.

00:00:10.180 --> 00:00:12.730
To make a donation or to
view additional materials

00:00:12.730 --> 00:00:16.630
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.630 --> 00:00:17.337
at ocw.mit.edu.

00:00:26.560 --> 00:00:28.760
PROFESSOR: All right,
welcome back to 6.890.

00:00:28.760 --> 00:00:31.920
Today we continue our theme
of reductions-- NP-hardness

00:00:31.920 --> 00:00:34.820
reductions from three partition.

00:00:34.820 --> 00:00:37.614
Yesterday we saw a couple of
different reductions from three

00:00:37.614 --> 00:00:39.280
partition and then a
bunch of reductions

00:00:39.280 --> 00:00:41.900
from those problems,
various puzzles.

00:00:41.900 --> 00:00:45.200
The last one we covered was
packing squares into a square.

00:00:45.200 --> 00:00:48.010
This is just a reminder
visually of what it looks like.

00:00:48.010 --> 00:00:51.120
But we're going to just
take this result as given.

00:00:51.120 --> 00:00:53.460
And our first
NP-hardness reduction

00:00:53.460 --> 00:00:55.800
will be from packing
squares into a square.

00:00:55.800 --> 00:00:58.310
And then we will see
a bunch of-- possibly

00:00:58.310 --> 00:01:01.630
as many as eight-- reductions
from three partition.

00:01:01.630 --> 00:01:05.620
So without further
ado, let's get started.

00:01:05.620 --> 00:01:09.100
The first problem we're
going to talk about

00:01:09.100 --> 00:01:11.080
is edge-unfolding polyhedra.

00:01:11.080 --> 00:01:14.680
This is a geometric
folding problem.

00:01:14.680 --> 00:01:19.400
So if you're interested in
more, you can take 6.849.

00:01:19.400 --> 00:01:22.400
But here's a simple-- if you've
ever made a cube out of paper,

00:01:22.400 --> 00:01:25.270
probably you cut
out a cross shape

00:01:25.270 --> 00:01:28.030
and then folded
it into the cube.

00:01:28.030 --> 00:01:30.840
But if you want to know
what shape should I cut out

00:01:30.840 --> 00:01:32.510
to make a cube, then
you want to know

00:01:32.510 --> 00:01:35.600
where should I cut, which
edges of the cube should I cut?

00:01:35.600 --> 00:01:36.980
They're drawn in red here.

00:01:36.980 --> 00:01:39.820
So that, when I unfold it,
I get one connected piece

00:01:39.820 --> 00:01:42.000
without overlap.

00:01:42.000 --> 00:01:45.440
So for surfaces that are
topologically a sphere,

00:01:45.440 --> 00:01:48.720
you want to cut along a
spanning tree of the edges.

00:01:48.720 --> 00:01:50.530
And for a cube, that
will always work.

00:01:50.530 --> 00:01:53.970
But for some polyhedra like
these two, when you unfold,

00:01:53.970 --> 00:01:55.140
you get overlap.

00:01:55.140 --> 00:01:56.850
And in fact, no
matter which spanning

00:01:56.850 --> 00:02:00.850
tree of the edges you take for
either of these two polyhedra,

00:02:00.850 --> 00:02:02.140
you're guaranteed to fail.

00:02:02.140 --> 00:02:05.680
You cannot make these out of
one piece of paper by folding

00:02:05.680 --> 00:02:07.830
and get an exact cover.

00:02:07.830 --> 00:02:08.710
So that's bad news.

00:02:08.710 --> 00:02:09.793
And these are old results.

00:02:09.793 --> 00:02:12.180
These are back in 1998.

00:02:12.180 --> 00:02:15.520
But it remained an
open problem, how many

00:02:15.520 --> 00:02:16.970
other examples are there?

00:02:16.970 --> 00:02:20.000
If I give you a polyhedron, I
want to know is there an edge

00:02:20.000 --> 00:02:20.550
unfolding?

00:02:20.550 --> 00:02:22.720
We only cut along the edges.

00:02:22.720 --> 00:02:24.540
What's the complexity of that?

00:02:24.540 --> 00:02:28.540
And the answer is, it's
NP-complete, strongly

00:02:28.540 --> 00:02:30.460
NP-complete, slightly stronger.

00:02:30.460 --> 00:02:32.610
This is not, obviously,
a number problem.

00:02:32.610 --> 00:02:34.667
But in geometry,
you have this issue

00:02:34.667 --> 00:02:36.500
of what are the coordinates
of the vertices.

00:02:36.500 --> 00:02:38.530
So the coordinates could
be exponentially large

00:02:38.530 --> 00:02:40.570
or they could just be
polynomially large.

00:02:40.570 --> 00:02:44.020
Here they only be polynomially
large, so strongly NP-complete.

00:02:44.020 --> 00:02:47.020
This is a complicated
proof so I'm just

00:02:47.020 --> 00:02:51.112
going to sketch the
idea of how it works.

00:02:51.112 --> 00:02:52.570
At the beginning,
like most proofs,

00:02:52.570 --> 00:02:54.570
there's some kind of like
overall infrastructure

00:02:54.570 --> 00:02:56.490
the holds all the
pieces together.

00:02:56.490 --> 00:02:58.570
This is one part of that.

00:02:58.570 --> 00:03:00.120
Well, this is the
main infrastructure

00:03:00.120 --> 00:03:01.800
in this reduction.

00:03:01.800 --> 00:03:03.710
There's some stuff
around the side.

00:03:03.710 --> 00:03:08.220
This is mainly to make the
surface topologically a sphere.

00:03:08.220 --> 00:03:13.160
The focus is on a
square face here

00:03:13.160 --> 00:03:15.060
that has a little slit in it.

00:03:15.060 --> 00:03:16.520
And there's a tower coming out.

00:03:16.520 --> 00:03:18.980
It's drawn edge-on here.

00:03:18.980 --> 00:03:21.510
This is the part we
actually care about.

00:03:21.510 --> 00:03:23.990
I think, actually, it
will be redrawn here.

00:03:23.990 --> 00:03:25.980
So we'll really just
be thinking about this.

00:03:25.980 --> 00:03:27.950
And then, there's some
stuff that wraps around

00:03:27.950 --> 00:03:30.350
it makes it a sphere
without changing unfoldings

00:03:30.350 --> 00:03:32.780
So don't worry too
much about that.

00:03:32.780 --> 00:03:35.920
Mainly we have this
giant-- think of it

00:03:35.920 --> 00:03:37.400
as an obstacle
because we are not

00:03:37.400 --> 00:03:40.400
allowed to overlap when
we unfold this thing.

00:03:40.400 --> 00:03:42.569
So this shape can't
be cut up because it

00:03:42.569 --> 00:03:43.867
has no edges except for here.

00:03:43.867 --> 00:03:45.200
So this part can move around it.

00:03:45.200 --> 00:03:47.070
It turns out that it
can just stay in there

00:03:47.070 --> 00:03:48.170
but it might move up.

00:03:48.170 --> 00:03:50.570
So we'll make a little
bit of space here.

00:03:50.570 --> 00:03:53.630
There's this hole of this face.

00:03:53.630 --> 00:03:55.730
Then there is this tower
that is sticking out

00:03:55.730 --> 00:03:58.215
into the third dimension and
we need to somehow unfold

00:03:58.215 --> 00:04:00.040
that thing and fit it in here.

00:04:00.040 --> 00:04:02.530
Doesn't look possible
because this is not

00:04:02.530 --> 00:04:04.260
quite drawn to scale.

00:04:04.260 --> 00:04:06.380
This is going to be super long.

00:04:06.380 --> 00:04:09.365
So a lot of the stuff here
is just going to be stuffed

00:04:09.365 --> 00:04:12.990
up the chimney, so to speak,
but also on the surface

00:04:12.990 --> 00:04:14.650
there is more stuff going on.

00:04:14.650 --> 00:04:17.200
So let's zoom into this thing.

00:04:17.200 --> 00:04:20.600
If we unfold that
tower into a plus sign.

00:04:20.600 --> 00:04:23.840
Most of it is lots
of tiny stuff called

00:04:23.840 --> 00:04:27.050
atoms, which we will get to.

00:04:27.050 --> 00:04:30.070
And then, the interesting
part from a three partition

00:04:30.070 --> 00:04:32.950
standpoint-- or sorry, from
a square packing standpoint--

00:04:32.950 --> 00:04:34.640
is there are some square faces.

00:04:34.640 --> 00:04:38.080
And because we're edge
cutting our surface

00:04:38.080 --> 00:04:39.860
those squares will
remain squares.

00:04:39.860 --> 00:04:41.160
There's no edges on them.

00:04:41.160 --> 00:04:45.880
So those guys somehow have to
move around when you unfold.

00:04:45.880 --> 00:04:48.560
And it's not drawn this
way, but the squares

00:04:48.560 --> 00:04:51.710
are large enough that they
can't fit up the chimney.

00:04:51.710 --> 00:04:55.650
OK, this chimney's actually
pretty narrow, constant width,

00:04:55.650 --> 00:04:58.220
and those guys are
all really big.

00:04:58.220 --> 00:05:01.090
So this other stuff can
move up the chimney,

00:05:01.090 --> 00:05:03.320
but the squares will have
to stay in this square.

00:05:03.320 --> 00:05:04.694
And that's how
we're going to get

00:05:04.694 --> 00:05:06.380
packing squares into squares.

00:05:06.380 --> 00:05:07.140
OK?

00:05:07.140 --> 00:05:10.090
Now, the challenge is, what
we want to be able to do

00:05:10.090 --> 00:05:12.800
is move the squares
around freely.

00:05:12.800 --> 00:05:16.310
But in reality, we need to
make a connected 2D shape.

00:05:16.310 --> 00:05:19.610
So somehow, we need to
connect together these squares

00:05:19.610 --> 00:05:24.840
by some stuff-- that's
the mystery atoms--

00:05:24.840 --> 00:05:26.970
so that, basically,
for any square packing,

00:05:26.970 --> 00:05:29.330
we can arrange to
have those faces

00:05:29.330 --> 00:05:31.167
in that rough arrangement.

00:05:31.167 --> 00:05:33.750
And then the other stuff somehow
connects everything together.

00:05:33.750 --> 00:05:37.030
And whatever doesn't fit in
here goes up the chimney.

00:05:37.030 --> 00:05:38.700
So that's the plan.

00:05:38.700 --> 00:05:41.740
If we zoom in--
all right, so this

00:05:41.740 --> 00:05:43.930
is sort of the
diagram of that plan.

00:05:43.930 --> 00:05:48.180
Imagine you have some
placement of the squares.

00:05:48.180 --> 00:05:51.850
And we're going to try to
connect all the pieces together

00:05:51.850 --> 00:05:55.290
maybe to some common root
in the lower left corner.

00:05:55.290 --> 00:05:58.730
First we're just going to
draw some L's conceptually

00:05:58.730 --> 00:06:01.420
to connect them all to here.

00:06:01.420 --> 00:06:03.550
Those cross, which
is not allowed.

00:06:03.550 --> 00:06:05.970
But then we're going to
reroute the L's to go around

00:06:05.970 --> 00:06:08.220
the-- so, to get up
to this box, we're

00:06:08.220 --> 00:06:12.260
going to go around all
the other boxes below it.

00:06:12.260 --> 00:06:14.920
And in this way, we get a
non-crossing arrangement.

00:06:14.920 --> 00:06:17.270
If we zoom in even closer,
these, I've drawn as lines,

00:06:17.270 --> 00:06:19.190
but really they're
little strips of paper.

00:06:19.190 --> 00:06:22.710
And they may do weird things
like zigzag back and forth.

00:06:22.710 --> 00:06:25.650
How that happens
we'll see in a moment.

00:06:25.650 --> 00:06:27.340
But this is to
convince you that,

00:06:27.340 --> 00:06:28.780
at least if we
could place squares

00:06:28.780 --> 00:06:31.560
and they're not like
right touching each other.

00:06:31.560 --> 00:06:33.610
So we're going to shrink
each square a tiny bit,

00:06:33.610 --> 00:06:35.068
which I won't get
into the details.

00:06:35.068 --> 00:06:38.250
But if they're integer
square, let's say,

00:06:38.250 --> 00:06:42.240
then we'll shrink them, maybe,
by minus 1 over n or something

00:06:42.240 --> 00:06:45.130
polynomially small.

00:06:45.130 --> 00:06:47.430
And then, that gives
us a little bit of room

00:06:47.430 --> 00:06:50.160
to route all of these paths
if make them like 1 over n

00:06:50.160 --> 00:06:52.570
squared or 1 over n
cubed in thickness.

00:06:52.570 --> 00:06:54.660
Still polynomial, so
still strongly NP-hard.

00:06:57.260 --> 00:07:00.360
So if we have a
square packing, we

00:07:00.360 --> 00:07:02.900
can connect them
all up in this way

00:07:02.900 --> 00:07:04.790
if we have these
magical atoms that

00:07:04.790 --> 00:07:07.640
can do whatever we want freely.

00:07:07.640 --> 00:07:14.630
And that's the-- so, in a little
more detail, in this picture,

00:07:14.630 --> 00:07:17.920
we imagine the atoms as somehow
being connected together

00:07:17.920 --> 00:07:19.520
in a chain, potentially.

00:07:19.520 --> 00:07:22.440
And then when they unfold,
this is the fun part.

00:07:22.440 --> 00:07:26.020
So we maybe-- for
connectivity purposes,

00:07:26.020 --> 00:07:28.930
maybe first we want to visit
B1, then we want to visit B2,

00:07:28.930 --> 00:07:29.440
and so on.

00:07:32.730 --> 00:07:34.320
And that corresponds
to some traversal

00:07:34.320 --> 00:07:38.550
on the surface of this
plus sign or the tower

00:07:38.550 --> 00:07:40.230
that's sticking out.

00:07:40.230 --> 00:07:42.210
And then, in 2D
when we unfold it,

00:07:42.210 --> 00:07:44.234
we have a different thing
in mind of whether we

00:07:44.234 --> 00:07:45.400
want it to go left or right.

00:07:45.400 --> 00:07:48.730
So there's moving left or right
intrinsically on the surface.

00:07:48.730 --> 00:07:51.640
And then there's moving left
and right in the unfolding.

00:07:51.640 --> 00:07:53.160
So two separate things.

00:07:53.160 --> 00:07:56.320
And conveniently,
this one structure

00:07:56.320 --> 00:07:59.870
is one of these boxes-- this
is what we call the atom- can

00:07:59.870 --> 00:08:02.120
do all of those things.

00:08:02.120 --> 00:08:04.090
Certainly not obvious
from the picture,

00:08:04.090 --> 00:08:06.650
it's just a little bumpy square.

00:08:06.650 --> 00:08:10.580
But you just trial the cases,
these are three of the cases.

00:08:10.580 --> 00:08:12.840
Not obvious, but there
turn out to be 10

00:08:12.840 --> 00:08:16.640
after you remove
reflections and rotations.

00:08:16.640 --> 00:08:19.420
There's a few things going on,
but the main thing going on

00:08:19.420 --> 00:08:26.160
is whether you're going left or
right in the-- let me get this

00:08:26.160 --> 00:08:28.742
straight-- whether you're going
left or right intrinsically

00:08:28.742 --> 00:08:30.950
on the surface and whether
you're going left or right

00:08:30.950 --> 00:08:33.200
or straight in the unfolding.

00:08:33.200 --> 00:08:35.820
So here you can see you're
turning left in the unfolding,

00:08:35.820 --> 00:08:37.610
you're going straight
in the unfolding,

00:08:37.610 --> 00:08:39.510
and you're turning
left in the unfolding.

00:08:39.510 --> 00:08:42.480
So the second coordinate
is L, S, and L.

00:08:42.480 --> 00:08:44.510
What's less obvious
is if you fold this up

00:08:44.510 --> 00:08:48.400
and you get the atom
structure, but the thing

00:08:48.400 --> 00:08:51.690
that you attach to here
is on the folded structure

00:08:51.690 --> 00:08:57.240
either to the left or to
the left or to the right.

00:08:57.240 --> 00:08:59.180
So you just check
all these things.

00:08:59.180 --> 00:09:01.780
And then, this is like
a universal glue that

00:09:01.780 --> 00:09:04.800
can connect together the
squares however you want,

00:09:04.800 --> 00:09:08.630
both on the surface where they
have to be connected originally

00:09:08.630 --> 00:09:11.540
and in the unfolding
where you want

00:09:11.540 --> 00:09:13.600
to match some square packing.

00:09:13.600 --> 00:09:16.640
So we'll have a little bit of
hand waving there, lots of hand

00:09:16.640 --> 00:09:20.170
waving, but in the end, you
get NP-strong, NP-completeness

00:09:20.170 --> 00:09:21.840
of edge-unfolding polyhedra.

00:09:24.970 --> 00:09:25.590
Any questions?

00:09:29.920 --> 00:09:32.410
All right, perfectly
clear, then?

00:09:32.410 --> 00:09:34.530
Let's move to another puzzle.

00:09:34.530 --> 00:09:38.760
This is called the snake cube
puzzle or the cubra puzzle.

00:09:38.760 --> 00:09:41.240
Here is one instantiation of it.

00:09:41.240 --> 00:09:46.837
So we have-- it's
a chain of blocks--

00:09:46.837 --> 00:09:48.420
I'm going to try to
unfold it in a way

00:09:48.420 --> 00:09:50.669
that I can put it back
together, because it's actually

00:09:50.669 --> 00:09:51.940
quite tricky to solve.

00:09:51.940 --> 00:09:53.356
It's a chain of
blocks and there's

00:09:53.356 --> 00:09:56.260
an elastic through the centers,
going through the center

00:09:56.260 --> 00:09:56.920
of the faces.

00:09:56.920 --> 00:10:00.360
And so, the result is you can't
really pull the squares apart,

00:10:00.360 --> 00:10:01.720
it's a pretty tights elastic.

00:10:01.720 --> 00:10:02.564
But you can spin.

00:10:02.564 --> 00:10:04.230
Because from the
elastics point-of-view,

00:10:04.230 --> 00:10:07.080
these are all equally happy.

00:10:07.080 --> 00:10:10.170
So you're basically told
that-- I could also spin here,

00:10:10.170 --> 00:10:13.110
but it doesn't do anything if
I stop at a 90 degree angle.

00:10:13.110 --> 00:10:14.990
So I'm forced to
be straight here.

00:10:14.990 --> 00:10:17.452
And then I'm forced to
have a 90 degree turn.

00:10:17.452 --> 00:10:19.660
And then I'm forced to go
straight and then have a 90

00:10:19.660 --> 00:10:22.550
degree turn and then go straight
and then have a 90 degree turn.

00:10:22.550 --> 00:10:26.580
Here I have a few 90
degree turns in a row.

00:10:26.580 --> 00:10:28.245
And that's the
general structure.

00:10:28.245 --> 00:10:29.700
And can I still solve it?

00:10:29.700 --> 00:10:30.770
Maybe.

00:10:30.770 --> 00:10:34.740
The goal is to get into a cube.

00:10:34.740 --> 00:10:38.140
And there are a bunch of
different versions, plastic,

00:10:38.140 --> 00:10:38.820
wood, whatever.

00:10:38.820 --> 00:10:41.490
This one is not solved and
so I will not do so well,

00:10:41.490 --> 00:10:43.640
but you get an idea
of what it looks

00:10:43.640 --> 00:10:47.240
like in its sort of flat state.

00:10:47.240 --> 00:10:49.630
I can make it into
a kind of staircase.

00:10:49.630 --> 00:10:53.570
So in general, this puzzle
is specified by a sequence

00:10:53.570 --> 00:10:55.520
of lengths of straits.

00:10:55.520 --> 00:10:57.130
And then, in between
those lengths

00:10:57.130 --> 00:10:58.660
are the 90 degree turns.

00:10:58.660 --> 00:10:59.160
OK?

00:10:59.160 --> 00:11:01.804
So that's the puzzle,
pretty simple specification.

00:11:01.804 --> 00:11:03.470
And your goal is to
fold it into a cube.

00:11:03.470 --> 00:11:04.678
You know how big the cube is.

00:11:04.678 --> 00:11:06.820
You just take the
number of little cubes

00:11:06.820 --> 00:11:09.150
and take the cube root.

00:11:09.150 --> 00:11:16.040
So this puzzle maybe goes, is at
least 1990, but could be older.

00:11:16.040 --> 00:11:18.680
We don't know exactly.

00:11:18.680 --> 00:11:23.250
And this puzzle is
also NP-complete.

00:11:23.250 --> 00:11:26.420
And this proof is
also complicated

00:11:26.420 --> 00:11:27.880
so we won't see all the details.

00:11:27.880 --> 00:11:31.840
But this one, we'll probably
see a little bit clearer.

00:11:31.840 --> 00:11:35.230
This is a proof by, in
particular, the three of us

00:11:35.230 --> 00:11:39.190
and Marty in the back,
so all four of us.

00:11:39.190 --> 00:11:43.010
And let's see, so this
doesn't look like a cube.

00:11:43.010 --> 00:11:46.250
So lets-- before we try to
solve the problem of folding

00:11:46.250 --> 00:11:49.880
into a cube shape, let's suppose
I give you one of these chains

00:11:49.880 --> 00:11:52.690
and I want to know, can
it fold into this shape?

00:11:52.690 --> 00:11:54.240
Let's say this is the target.

00:11:54.240 --> 00:11:56.740
So it's a big box down here.

00:11:56.740 --> 00:11:58.000
I think we call it the hub.

00:11:58.000 --> 00:12:01.530
And then there are these
spokes, or just big boxes,

00:12:01.530 --> 00:12:04.320
long boxes, sticking
out of the hub.

00:12:04.320 --> 00:12:05.470
There's a hold here.

00:12:05.470 --> 00:12:08.090
They're connected to
the main structure.

00:12:08.090 --> 00:12:10.650
And you want to fold that.

00:12:10.650 --> 00:12:15.650
And let's see, so
the big idea-- we're

00:12:15.650 --> 00:12:17.570
reducing from three
partition here--

00:12:17.570 --> 00:12:23.560
we're going to represent a
number, ai, as a zigzag--

00:12:23.560 --> 00:12:26.530
well, sorry, shouldn't
call it a zigzag--

00:12:26.530 --> 00:12:30.290
but we have a really long
bar, then a length 1 bar.

00:12:30.290 --> 00:12:32.600
And then a really long
bar and a length 1 bar.

00:12:32.600 --> 00:12:34.540
I'm drawing sort of
the thinned version.

00:12:34.540 --> 00:12:36.070
This is really a little cube.

00:12:36.070 --> 00:12:37.200
This is a little cube.

00:12:37.200 --> 00:12:40.920
These are lots of cubes,
huge number of cubes.

00:12:40.920 --> 00:12:41.990
OK?

00:12:41.990 --> 00:12:44.510
So that's really, really big.

00:12:44.510 --> 00:12:46.220
So big that the only
place it could fit

00:12:46.220 --> 00:12:48.420
is down one of these spokes.

00:12:48.420 --> 00:12:52.060
So of course, the idea is
these represent our triples

00:12:52.060 --> 00:12:55.370
whose sum is equal to t.

00:12:55.370 --> 00:12:57.830
And so, we have to
take these things

00:12:57.830 --> 00:13:00.410
and because these
are so short, you

00:13:00.410 --> 00:13:03.360
can't like go out of one
hub and jump to the next one

00:13:03.360 --> 00:13:07.070
because there's a gap
there that's bigger than 1.

00:13:07.070 --> 00:13:10.340
So once you commit to having
one of these long bars

00:13:10.340 --> 00:13:13.024
into one of these
pockets, then all of them

00:13:13.024 --> 00:13:14.190
have to go into the pockets.

00:13:14.190 --> 00:13:17.910
So this is, in general, a big
issue with three partition

00:13:17.910 --> 00:13:20.980
proofs is you want to
represent the number ai

00:13:20.980 --> 00:13:25.050
in some way that's
not divisible.

00:13:25.050 --> 00:13:26.605
If you could take
ai and split it

00:13:26.605 --> 00:13:28.980
into two parts, than the
packing problem becomes trivial.

00:13:28.980 --> 00:13:31.510
You'd split everything
into units or something.

00:13:31.510 --> 00:13:35.080
So we have to make sure
ai remains a single chunk.

00:13:35.080 --> 00:13:37.320
We are, of course, encoding
ai in your unary here,

00:13:37.320 --> 00:13:39.930
because we have one
long bar per each ai.

00:13:39.930 --> 00:13:43.350
But for three
partition, unary is OK.

00:13:43.350 --> 00:13:46.920
There's some things going
on here a little bit weird.

00:13:46.920 --> 00:13:50.870
So you see this thing is
occupying the full length.

00:13:50.870 --> 00:13:55.320
And the length here is going
to be 8 times the target sum

00:13:55.320 --> 00:13:57.090
instead of just the target sum.

00:13:57.090 --> 00:13:58.730
And we're multiplying this by 8.

00:13:58.730 --> 00:14:00.850
So those are equal, we're fine.

00:14:00.850 --> 00:14:03.970
There's a reason for the
8 which we will get to.

00:14:03.970 --> 00:14:06.770
OK, now, like the
previous proof,

00:14:06.770 --> 00:14:11.700
the edge-unfolding polyhedra,
we have these great units.

00:14:11.700 --> 00:14:13.790
And we just like them
to be free floating.

00:14:13.790 --> 00:14:16.830
And if you generalize this
puzzle little bit and say,

00:14:16.830 --> 00:14:19.150
well, actually, I don't
just have one chain.

00:14:19.150 --> 00:14:20.410
I have two chains.

00:14:20.410 --> 00:14:22.360
Or I have n chains.

00:14:22.360 --> 00:14:25.540
And together, collectively, they
have to fold into this shape,

00:14:25.540 --> 00:14:29.280
then we're done except that
you would remove the box,

00:14:29.280 --> 00:14:32.539
the box over here.

00:14:32.539 --> 00:14:34.080
Because then, these
guys just somehow

00:14:34.080 --> 00:14:38.160
have to be assigned to these
little pockets and we're happy.

00:14:38.160 --> 00:14:39.607
OK.

00:14:39.607 --> 00:14:41.190
All of these numbers--
although again,

00:14:41.190 --> 00:14:42.890
not drawn to scale--
all these numbers

00:14:42.890 --> 00:14:44.520
are much smaller than huge.

00:14:44.520 --> 00:14:47.550
So you can't like take
this guy and put it here,

00:14:47.550 --> 00:14:49.050
even though in this
picture it looks

00:14:49.050 --> 00:14:50.700
like you might be able to.

00:14:50.700 --> 00:14:51.200
All right.

00:14:51.200 --> 00:14:53.690
So the issue is, now we want
to connect this together

00:14:53.690 --> 00:14:55.050
into one big chain.

00:14:55.050 --> 00:14:56.190
We have these units.

00:14:56.190 --> 00:14:59.070
For each i, we have
one of these units.

00:14:59.070 --> 00:15:00.400
That's cool.

00:15:00.400 --> 00:15:02.090
And we want to
attach them together

00:15:02.090 --> 00:15:03.670
in a way that is
super flexible, just

00:15:03.670 --> 00:15:06.117
like the atoms we had before.

00:15:06.117 --> 00:15:07.700
Now we're going to
use something which

00:15:07.700 --> 00:15:09.408
we called the zigzag,
that's why I didn't

00:15:09.408 --> 00:15:11.580
want to call this a zigzag.

00:15:11.580 --> 00:15:13.470
This is all unit segments.

00:15:13.470 --> 00:15:15.970
So you have 90 degree turn, 90
degree turn, 90 degree turn,

00:15:15.970 --> 00:15:16.640
90 degree turn.

00:15:16.640 --> 00:15:18.070
No straits.

00:15:18.070 --> 00:15:21.080
This turns out to be
universal in a strong sense.

00:15:21.080 --> 00:15:23.860
It can fold into anything.

00:15:23.860 --> 00:15:27.950
And so, we can use it to
connect these parts together.

00:15:27.950 --> 00:15:31.249
So what we're going to
do is have the A1 gadget.

00:15:31.249 --> 00:15:33.290
Then we're going to have
a whole bunch of zigzags

00:15:33.290 --> 00:15:35.374
so you can go wherever
you need to go.

00:15:35.374 --> 00:15:36.790
And then we'll
have the A2 gadget.

00:15:36.790 --> 00:15:38.740
And then we'll have
the universal zigzag

00:15:38.740 --> 00:15:41.760
gadget for a long length of it.

00:15:41.760 --> 00:15:42.770
And then the A3.

00:15:42.770 --> 00:15:46.480
And then alternating
between zigzags and the ai.

00:15:46.480 --> 00:15:48.600
And at the end, we'll
have enough zigzag

00:15:48.600 --> 00:15:51.950
that we can fill all this
sort of extra garbage space.

00:15:51.950 --> 00:15:55.400
But we will use this garbage
space in order to route around.

00:15:55.400 --> 00:15:57.240
So maybe A1's going to go here.

00:15:57.240 --> 00:16:01.620
And so we do this
thing, this, yeah,

00:16:01.620 --> 00:16:03.300
looks like some kind of cooker.

00:16:03.300 --> 00:16:05.240
We go back and forth like that.

00:16:05.240 --> 00:16:06.970
Then we'll have the
zigzag and say, OK, I

00:16:06.970 --> 00:16:08.200
want to go over here next.

00:16:08.200 --> 00:16:10.260
And then we'll do A2 there.

00:16:10.260 --> 00:16:11.830
And then we'll route over here.

00:16:11.830 --> 00:16:14.140
And because this is in 3D,
crossings are not an issue.

00:16:14.140 --> 00:16:17.700
I can just got out into
the third dimension.

00:16:17.700 --> 00:16:20.580
We don't need much of a
third dimension, 8 is enough.

00:16:20.580 --> 00:16:24.240
You can just, enough
to go over each other.

00:16:24.240 --> 00:16:24.740
OK.

00:16:24.740 --> 00:16:27.550
And then at the end,
we're going to fill in all

00:16:27.550 --> 00:16:29.590
this space with the zigzag.

00:16:29.590 --> 00:16:31.990
So let's talk about the zigzag.

00:16:31.990 --> 00:16:34.410
What we claim-- there's
a couple different senses

00:16:34.410 --> 00:16:37.160
in which it's universal.

00:16:37.160 --> 00:16:42.220
But the key idea are
these sets of gadgets.

00:16:42.220 --> 00:16:43.760
So we're drawing
here a two by two

00:16:43.760 --> 00:16:51.070
by two cube made up
of 8 little cubes.

00:16:51.070 --> 00:16:55.360
And if you look at the--
what we've drawn here

00:16:55.360 --> 00:16:57.920
is the elastic that goes through
the centers of the cubes.

00:16:57.920 --> 00:17:01.300
And notice it turns 90
degrees at every voxel,

00:17:01.300 --> 00:17:03.050
at every little cube.

00:17:03.050 --> 00:17:07.089
So this is part of-- these
are zigzag constructions.

00:17:07.089 --> 00:17:11.180
So what we want to
say is that, if you

00:17:11.180 --> 00:17:16.030
sort of-- so one
sense of universality

00:17:16.030 --> 00:17:18.250
is that the zigzag
structure can fold

00:17:18.250 --> 00:17:19.950
into any polycube structure.

00:17:19.950 --> 00:17:22.530
Polycube is the 3D
generalization of polyominoes

00:17:22.530 --> 00:17:27.650
that we saw last time
from polyominoe packing.

00:17:27.650 --> 00:17:28.980
That's not true.

00:17:28.980 --> 00:17:31.710
But if you take any
polycube structure

00:17:31.710 --> 00:17:33.680
and you just scale
it by a factor of 2--

00:17:33.680 --> 00:17:35.520
so you replace
every cube with a 2

00:17:35.520 --> 00:17:38.450
by 2 by 2 grid
like this picture--

00:17:38.450 --> 00:17:40.660
then it's still not true.

00:17:40.660 --> 00:17:42.770
But it's better.

00:17:42.770 --> 00:17:47.150
So what's true at that point
is if you take any path of two

00:17:47.150 --> 00:17:49.780
by two by two
cubes, this is what

00:17:49.780 --> 00:17:51.260
we would call a
Hamiltonian shape,

00:17:51.260 --> 00:17:53.350
because there's one path
that visits everything

00:17:53.350 --> 00:17:54.400
with no collisions.

00:17:54.400 --> 00:17:58.470
So it has to be a path that
does not hit itself in 3D.

00:17:58.470 --> 00:18:01.100
Then you can follow
these gadgets

00:18:01.100 --> 00:18:03.110
in order to make any
turns you need to do.

00:18:03.110 --> 00:18:06.520
Or you can go straight,
everything is possible.

00:18:06.520 --> 00:18:09.040
I will talk a little bit
more about that in a moment.

00:18:09.040 --> 00:18:11.980
So 2 by 2 by 2 refinement,
meaning scaling everything

00:18:11.980 --> 00:18:14.670
by a factor of 2,
allows the zigzag

00:18:14.670 --> 00:18:17.780
to make any Hamiltonian
shape scaled by 2.

00:18:20.380 --> 00:18:21.887
But that's Hamiltonian shapes.

00:18:21.887 --> 00:18:23.470
Now conveniently,
there's this theorem

00:18:23.470 --> 00:18:25.345
which is used a lot in
computational geometry

00:18:25.345 --> 00:18:27.780
and we use it in
this harness proof,

00:18:27.780 --> 00:18:30.590
that if you take any shape and
you refine it by two by two

00:18:30.590 --> 00:18:33.190
by two, every scale
by a factor of 2, then

00:18:33.190 --> 00:18:36.190
it becomes Hamiltonian
by a similar kind

00:18:36.190 --> 00:18:37.170
of gadget construction.

00:18:37.170 --> 00:18:39.682
Although it's easier-- if you
just want Hamiltonian paths,

00:18:39.682 --> 00:18:41.390
you don't care about
where you're turning

00:18:41.390 --> 00:18:45.150
and where you're not turning,
so that's a pretty easy proof

00:18:45.150 --> 00:18:48.530
left as an exercise to
you and sort of an aside

00:18:48.530 --> 00:18:49.610
from this issue.

00:18:49.610 --> 00:18:52.510
So we take any shape we 2 by
2 by 2, refine it, we make it

00:18:52.510 --> 00:18:53.400
Hamiltonian.

00:18:53.400 --> 00:18:55.830
Then we two by two
refine it again.

00:18:55.830 --> 00:18:57.930
In total 4 by 4 by 4 refinement.

00:18:57.930 --> 00:19:02.130
And then, a zigzag path can
make that polycube shape.

00:19:02.130 --> 00:19:03.960
And this is for any polycube.

00:19:03.960 --> 00:19:05.700
So that's cool.

00:19:05.700 --> 00:19:08.610
Now, I'll mention
here in this proof,

00:19:08.610 --> 00:19:12.750
one of the issues which
we'll see a bunch of times,

00:19:12.750 --> 00:19:15.070
I'm just going to
mention it here,

00:19:15.070 --> 00:19:22.700
is we have a parity issue
because the cubicle grid is

00:19:22.700 --> 00:19:25.350
two-colorable, right,
you can checkerboard

00:19:25.350 --> 00:19:29.040
the 3D grid of squares.

00:19:29.040 --> 00:19:30.780
And so, what that
means is every time

00:19:30.780 --> 00:19:33.321
you go from one cube on the grid
to another cube on the grid,

00:19:33.321 --> 00:19:34.340
you're switching parity.

00:19:34.340 --> 00:19:37.139
If you checkerboard the
3D space black and white,

00:19:37.139 --> 00:19:39.680
you're always going from white
to black, then black to white,

00:19:39.680 --> 00:19:44.520
then black to white, sorry,
alternating black and white,

00:19:44.520 --> 00:19:46.370
easier to do than to say.

00:19:46.370 --> 00:19:49.410
And so, that's a constraint.

00:19:49.410 --> 00:19:58.790
So for example, it is impossible
in a 2 by 2 by 2 thing,

00:19:58.790 --> 00:20:02.600
to enter from this
cube, the front cube,

00:20:02.600 --> 00:20:07.370
and exit from this one just
by a counting argument.

00:20:07.370 --> 00:20:09.360
So you start, let's say
this is a black cube.

00:20:09.360 --> 00:20:10.841
This one also a black cube.

00:20:10.841 --> 00:20:13.340
And so, you start black and
then you alternate black, white,

00:20:13.340 --> 00:20:14.805
black, white, and
there's 8 things to visit

00:20:14.805 --> 00:20:16.790
and you want to end black,
that's not possible.

00:20:16.790 --> 00:20:18.250
You have to end white.

00:20:18.250 --> 00:20:21.090
So if you enter on a black cube,
you will leave on a white cube.

00:20:21.090 --> 00:20:22.240
And if you enter
on a while cube,

00:20:22.240 --> 00:20:23.550
you will leave on a black cube.

00:20:23.550 --> 00:20:25.982
So that's a constraint.

00:20:25.982 --> 00:20:27.440
Doesn't really get
in the way here,

00:20:27.440 --> 00:20:28.770
but it's something you
have to keep track of.

00:20:28.770 --> 00:20:30.262
And the theorem
wouldn't be-- what

00:20:30.262 --> 00:20:32.470
you'd like to say is, well,
I can enter from any cube

00:20:32.470 --> 00:20:33.770
and leave from any cube.

00:20:33.770 --> 00:20:36.540
And you could actually
prove that by induction,

00:20:36.540 --> 00:20:38.400
except the base
case would be wrong.

00:20:38.400 --> 00:20:40.300
So this is something
to be careful about.

00:20:40.300 --> 00:20:41.260
This is the base case.

00:20:41.260 --> 00:20:43.580
This is 1 cube, can I
enter from anywhere?

00:20:43.580 --> 00:20:45.779
One 2 by 2 by 2
super cube, can I

00:20:45.779 --> 00:20:47.070
enter anywhere, leave anywhere?

00:20:47.070 --> 00:20:50.120
The answer is no, but
I can enter and exit

00:20:50.120 --> 00:20:52.040
anywhere that have
the right parity.

00:20:52.040 --> 00:20:54.115
So if the entrance
cubes and the exit cubes

00:20:54.115 --> 00:20:58.030
have opposite parity, then this
is actually all of the cases.

00:20:58.030 --> 00:21:00.470
These four are where the
entrance and exit cube

00:21:00.470 --> 00:21:02.760
are adjacent to each other.

00:21:02.760 --> 00:21:05.450
And these two cases are
where they're opposite

00:21:05.450 --> 00:21:07.770
from each other, not touching.

00:21:07.770 --> 00:21:10.600
And that's all the cases
with all the rotations

00:21:10.600 --> 00:21:12.570
and reflections.

00:21:12.570 --> 00:21:15.130
So once you prove that, base
case is actually really easy

00:21:15.130 --> 00:21:17.550
to do by induction, you
just are essentially

00:21:17.550 --> 00:21:21.126
pasting all these things
together to make any path.

00:21:21.126 --> 00:21:23.000
And then we could make
any Hamiltonian shape.

00:21:23.000 --> 00:21:26.530
And then further refinement,
any shape becomes Hamiltonian.

00:21:26.530 --> 00:21:28.830
So that's how we prove
zigzags are universal.

00:21:28.830 --> 00:21:34.742
And this connects together
all of these gadgets.

00:21:34.742 --> 00:21:36.450
There's really two
gadgets in this proof,

00:21:36.450 --> 00:21:39.630
the ai gadgets--
there's n of n copies

00:21:39.630 --> 00:21:41.270
of that-- and the
zigzag gadget--

00:21:41.270 --> 00:21:45.012
there's n copies
of that as well.

00:21:45.012 --> 00:21:46.470
Now there are some
details to check

00:21:46.470 --> 00:21:49.610
here, of course, that the
zigzag gadgets can actually

00:21:49.610 --> 00:21:54.790
navigate around and not cross
each other with height, 8,

00:21:54.790 --> 00:21:57.040
and that at the end, you can
fill all the blank space.

00:21:57.040 --> 00:21:59.640
If you're just organized
about how you traverse each

00:21:59.640 --> 00:22:02.170
of the ai's and where
you put the blank space,

00:22:02.170 --> 00:22:03.800
I think we just
leave some headroom.

00:22:03.800 --> 00:22:06.020
So you can just go
up, walk over to where

00:22:06.020 --> 00:22:08.600
all the blank space is, just
serve do a scan line traversal.

00:22:08.600 --> 00:22:10.990
Wherever there's blank
space, you eat it up

00:22:10.990 --> 00:22:12.740
with your zigzag at the end.

00:22:12.740 --> 00:22:15.600
So what this does is it
let's the ai's move around

00:22:15.600 --> 00:22:17.230
completely freely.

00:22:17.230 --> 00:22:19.630
There shouldn't be any
constraints on how the ai's

00:22:19.630 --> 00:22:21.927
are assigned to these pockets.

00:22:21.927 --> 00:22:24.510
Because we want every solution
to the three partition instance

00:22:24.510 --> 00:22:25.920
to work here.

00:22:25.920 --> 00:22:30.640
And the zigzags let us do that
because they're so universal.

00:22:30.640 --> 00:22:32.200
Cool?

00:22:32.200 --> 00:22:37.370
So I think that's what I
wanted to say about this proof.

00:22:37.370 --> 00:22:39.085
Double check my notes.

00:22:39.085 --> 00:22:42.640
Ah, there was one
other thing which

00:22:42.640 --> 00:22:47.274
I found a little funny
re-reading this paper is why 8?

00:22:47.274 --> 00:22:51.340
Because we know everything has
to scale up by a factor of 4.

00:22:51.340 --> 00:22:53.500
And that's all we're
doing in some sense.

00:22:53.500 --> 00:22:59.030
But we do make these-- we scale
all the ai's by a factor of 8.

00:22:59.030 --> 00:23:01.760
Not a big deal, but
there's a reason for 8.

00:23:01.760 --> 00:23:12.200
If we just did 4 and
say-- so we want to go,

00:23:12.200 --> 00:23:15.360
so this thing gets mapped onto
here and we go out and back

00:23:15.360 --> 00:23:16.100
and out and back.

00:23:16.100 --> 00:23:18.320
If we just did it
four times, we would

00:23:18.320 --> 00:23:22.220
be arriving at basically
the same position in the 4

00:23:22.220 --> 00:23:23.550
by 4 by 4 block.

00:23:23.550 --> 00:23:25.910
Or sorry, we would be
arriving at the same 4

00:23:25.910 --> 00:23:27.890
by 4 by 4 block that
we started from.

00:23:27.890 --> 00:23:30.580
And that's not good because we
can only visit a block once.

00:23:30.580 --> 00:23:33.449
So this is sort of an interface
issue between the zigzag--

00:23:33.449 --> 00:23:35.240
which is nice and
universal, you can always

00:23:35.240 --> 00:23:37.120
paste two of these
chains together,

00:23:37.120 --> 00:23:39.825
no problem-- with this thing,
which is not universal.

00:23:39.825 --> 00:23:42.500
It folds into
basically this shape.

00:23:42.500 --> 00:23:43.270
That's it.

00:23:43.270 --> 00:23:46.880
So we need to make
sure that, I mean,

00:23:46.880 --> 00:23:49.914
we can universally do
whatever we want in here.

00:23:49.914 --> 00:23:51.330
But we need to
make sure that when

00:23:51.330 --> 00:23:53.590
we connect between this
zigzag structure and then

00:23:53.590 --> 00:23:56.180
we paste in one of these
and then we come back,

00:23:56.180 --> 00:23:58.620
that we do that in a valid
way from the perspective

00:23:58.620 --> 00:24:01.630
of this big trunk
So the factor of 8

00:24:01.630 --> 00:24:06.310
makes sure that if we leave
from one 4 by 4 by 4 chunk,

00:24:06.310 --> 00:24:07.780
we come back on a different one.

00:24:07.780 --> 00:24:11.120
And then it's easy to paste
all the paths together.

00:24:11.120 --> 00:24:14.470
So that is [INAUDIBLE].

00:24:14.470 --> 00:24:15.344
Yeah.

00:24:15.344 --> 00:24:17.080
AUDIENCE: So, I don't
quite see that this

00:24:17.080 --> 00:24:18.952
proves that snake cube is NP.

00:24:18.952 --> 00:24:19.660
PROFESSOR: Right.

00:24:19.660 --> 00:24:21.250
Ah, yeah there's one
more issue, which

00:24:21.250 --> 00:24:23.160
is this was folding this shape.

00:24:23.160 --> 00:24:25.160
But we want to fold a cube.

00:24:25.160 --> 00:24:26.520
Yeah.

00:24:26.520 --> 00:24:29.190
This is the kind of
annoying part of the proof.

00:24:29.190 --> 00:24:31.350
It's very hard to draw.

00:24:31.350 --> 00:24:33.380
This isn't my attempt
at drawing it.

00:24:33.380 --> 00:24:40.230
And yeah, I will
sketch the idea.

00:24:40.230 --> 00:24:43.530
I tell you, the first part is
conceptually easy, again, hard

00:24:43.530 --> 00:24:45.160
to draw.

00:24:45.160 --> 00:24:48.870
The issue is forcing this
chain of blocks to do anything.

00:24:48.870 --> 00:24:50.540
And one key idea is
if you want to fold,

00:24:50.540 --> 00:24:54.170
let's say, a k by
k by k box, if you

00:24:54.170 --> 00:24:57.982
have a straight
path of length k,

00:24:57.982 --> 00:24:59.940
there aren't very many
places you can put that.

00:24:59.940 --> 00:25:04.340
I mean, I guess there are still
k or there's k squared of them.

00:25:04.340 --> 00:25:07.750
But you have to start
and end at the beginning

00:25:07.750 --> 00:25:09.670
and end of the
overall cube, if you

00:25:09.670 --> 00:25:12.360
have a full length of straight.

00:25:12.360 --> 00:25:16.330
So the first step we do
is take your-- sorry,

00:25:16.330 --> 00:25:17.810
this is the first step.

00:25:17.810 --> 00:25:20.730
It's upside down because we're
doing things in reverse order.

00:25:20.730 --> 00:25:23.080
First thing we do is
we take a target cube

00:25:23.080 --> 00:25:26.380
and we're basically going to
have a lot of really long guys

00:25:26.380 --> 00:25:28.954
will force you to in a row.

00:25:28.954 --> 00:25:30.620
And you see then these
kinds of puzzles.

00:25:30.620 --> 00:25:36.090
You tend to have straits
of length 3 like this.

00:25:36.090 --> 00:25:38.150
These are three 3's in a row.

00:25:38.150 --> 00:25:39.740
And we're making a
3 by 3 by 3 cube.

00:25:39.740 --> 00:25:45.890
So that sort of has to live in,
well, it can do weird things.

00:25:45.890 --> 00:25:47.660
But it's relatively restricted.

00:25:47.660 --> 00:25:49.370
Maybe you can do
something like this.

00:25:49.370 --> 00:25:52.650
But then, these must be the
edges of the cube in that case.

00:25:52.650 --> 00:25:57.150
So we have a bunch of
those and lots of care,

00:25:57.150 --> 00:26:00.050
and we end up reducing
the cube to a box,

00:26:00.050 --> 00:26:02.620
meaning we cover
all of the cube.

00:26:02.620 --> 00:26:04.290
We're forced to cover
all of the cubic

00:26:04.290 --> 00:26:06.660
and leave exactly a box behind.

00:26:06.660 --> 00:26:09.390
Sort of like what we did when we
were doing squares into square.

00:26:09.390 --> 00:26:12.980
We put a bunch of big boxes
that were relatively constrained

00:26:12.980 --> 00:26:15.170
and it just left empty
space, which is a box.

00:26:15.170 --> 00:26:17.820
Here it's actually
forced exactly.

00:26:17.820 --> 00:26:21.380
Then, once we have a box, so
the box will be this wide.

00:26:21.380 --> 00:26:24.240
And it will go over this way.

00:26:24.240 --> 00:26:26.830
But it won't have this
sort of fine feature stuff.

00:26:26.830 --> 00:26:29.860
This will just all be
filled in as a box.

00:26:29.860 --> 00:26:35.480
Then this step that's drawn
is to carve out this hub

00:26:35.480 --> 00:26:37.430
and spoke shape.

00:26:37.430 --> 00:26:39.460
And that's based on a
structure like this.

00:26:39.460 --> 00:26:41.560
We have a huge thing.

00:26:41.560 --> 00:26:44.710
And then a relatively
short thing of length

00:26:44.710 --> 00:26:47.202
about 8t, And then we go down.

00:26:47.202 --> 00:26:48.410
And then immediately back up.

00:26:48.410 --> 00:26:51.310
And then over and
down and up and so on.

00:26:51.310 --> 00:26:55.636
And that roughly carves
out this structure.

00:26:55.636 --> 00:26:58.010
Now, you have to be careful
that this is actually unique.

00:27:00.530 --> 00:27:03.799
This is why we only want the
height of this box to be 8,

00:27:03.799 --> 00:27:05.840
because then you can't go
out of plane very much.

00:27:05.840 --> 00:27:08.680
And while this is short,
it's longer than 8

00:27:08.680 --> 00:27:10.100
if t is bigger than 1.

00:27:10.100 --> 00:27:14.390
So you can't have
this spoke go up.

00:27:14.390 --> 00:27:18.260
So it does have to
live in a plane.

00:27:18.260 --> 00:27:19.070
Sounds right.

00:27:19.070 --> 00:27:20.540
And this is much
smaller than huge,

00:27:20.540 --> 00:27:23.132
so you can't fold
it some other way.

00:27:23.132 --> 00:27:24.340
So that's pretty much forced.

00:27:24.340 --> 00:27:28.030
And then we have to get rid of
the other seven planes, which

00:27:28.030 --> 00:27:30.372
we do with really long guys.

00:27:30.372 --> 00:27:32.330
Unfortunately, we don't
have all of that drawn,

00:27:32.330 --> 00:27:34.460
so it's especially hard to see.

00:27:34.460 --> 00:27:37.450
But this is a rough idea
of how you start with a box

00:27:37.450 --> 00:27:40.290
and you do these sort of
infrastructure gadgets

00:27:40.290 --> 00:27:42.280
to just carve out
the shape you want.

00:27:42.280 --> 00:27:46.150
And then you go into the
interesting part of the chain.

00:27:46.150 --> 00:27:47.900
This is all at the
beginning of the chain.

00:27:47.900 --> 00:27:49.890
And as you show, it's
forced to do all this.

00:27:49.890 --> 00:27:52.840
And then we start say here
with some zigzag and then

00:27:52.840 --> 00:27:56.526
an ai gadget and so on.

00:27:56.526 --> 00:27:58.380
Whew.

00:27:58.380 --> 00:28:00.170
Easy, right?

00:28:00.170 --> 00:28:03.570
So, you do see
here, I would say,

00:28:03.570 --> 00:28:06.090
a very algorithmic approach.

00:28:06.090 --> 00:28:09.510
I mean, this idea of showing
that zigzags are universal,

00:28:09.510 --> 00:28:11.260
they can make any
shape, this is something

00:28:11.260 --> 00:28:13.160
we do in computational
geometry all the time.

00:28:13.160 --> 00:28:14.743
We prove that these
folding structures

00:28:14.743 --> 00:28:16.250
fold into whatever we want.

00:28:16.250 --> 00:28:18.510
So we're-- and we hadn't
prove this one before,

00:28:18.510 --> 00:28:21.570
but we were armed with a lot of
algorithmic tools to do this.

00:28:21.570 --> 00:28:23.400
And that let us
do this reduction.

00:28:23.400 --> 00:28:25.370
So lower bounds in
our case is really

00:28:25.370 --> 00:28:29.320
all about designing the
right algorithms to give you

00:28:29.320 --> 00:28:31.660
powerful gadgets like this.

00:28:31.660 --> 00:28:35.820
That's why this is the class
called algorithmic lower bound.

00:28:35.820 --> 00:28:39.151
Other questions
about snake cubes?

00:28:39.151 --> 00:28:39.650
Adam.

00:28:39.650 --> 00:28:42.650
AUDIENCE: Why 8 instead of 6?

00:28:42.650 --> 00:28:46.450
PROFESSOR: I think we want
it to be a multiple of 4

00:28:46.450 --> 00:28:48.600
so that it's compatible
with the grid.

00:28:48.600 --> 00:28:50.900
6, yeah, that seems cleaner.

00:28:53.650 --> 00:28:55.800
That way we can predict
if we leave on this 4 by 4

00:28:55.800 --> 00:28:57.841
by 4 thing, we know which
one we'll come back on.

00:28:57.841 --> 00:29:00.190
Whereas, if it could be
in a half-grid position,

00:29:00.190 --> 00:29:02.300
that would be messy.

00:29:02.300 --> 00:29:04.035
Other questions?

00:29:04.035 --> 00:29:05.660
You might be able to
make that to work,

00:29:05.660 --> 00:29:08.370
but the advantage of hardness
proofs, because it's not

00:29:08.370 --> 00:29:09.470
a real algorithm.

00:29:09.470 --> 00:29:10.860
I mean, it's an algorithm
that you'd want to run.

00:29:10.860 --> 00:29:12.700
The point is to show
this problem is hard.

00:29:12.700 --> 00:29:14.436
You can be inefficient
in lots of places.

00:29:14.436 --> 00:29:15.810
As long as it's
still polynomial,

00:29:15.810 --> 00:29:17.380
it doesn't really matter.

00:29:17.380 --> 00:29:19.290
Except for drawing
the pictures, that's

00:29:19.290 --> 00:29:22.390
one place where it matters.

00:29:22.390 --> 00:29:23.200
All right.

00:29:23.200 --> 00:29:25.680
That's snake cubes.

00:29:25.680 --> 00:29:28.450
I'm gonna go on to
another packing problem.

00:29:28.450 --> 00:29:32.480
So we've seen rectangles into
squares, squares into squares,

00:29:32.480 --> 00:29:36.120
how about circles into squares?

00:29:36.120 --> 00:29:39.560
So this is a real
life puzzle where

00:29:39.560 --> 00:29:44.230
you have these-- I think they're
water jet cut or laser cut--

00:29:44.230 --> 00:29:45.610
metal disks.

00:29:45.610 --> 00:29:48.160
And you have to fit
them into this box.

00:29:48.160 --> 00:29:49.770
So these are real life puzzles.

00:29:49.770 --> 00:29:51.047
That's one motivation.

00:29:51.047 --> 00:29:53.380
There's a stronger motivation
for studying this problem,

00:29:53.380 --> 00:29:55.950
because it's related to
computational origami.

00:29:55.950 --> 00:29:58.842
There's this method called the
tree method of origami design.

00:29:58.842 --> 00:30:00.300
If you're interested
in it, you can

00:30:00.300 --> 00:30:04.810
take 6.849 or read Robert Lang's
book, Origami Design Secrets.

00:30:04.810 --> 00:30:08.400
And basically, it lets
you fold things like this.

00:30:08.400 --> 00:30:10.580
That's at a high level.

00:30:10.580 --> 00:30:15.330
And a key component of it is
to pack disks into a square.

00:30:15.330 --> 00:30:16.980
The square is your
piece of paper.

00:30:16.980 --> 00:30:21.070
The disks correspond to sort
of the limbs of your creature.

00:30:21.070 --> 00:30:23.649
And you can't use the
same piece of paper

00:30:23.649 --> 00:30:25.190
to represent this
limb and this limb,

00:30:25.190 --> 00:30:27.100
so the disks have
to be disjoint.

00:30:27.100 --> 00:30:31.140
So it's all about packing
those disks into given square.

00:30:31.140 --> 00:30:34.450
And yeah, so that's
at a high level

00:30:34.450 --> 00:30:36.710
why we care about disk packing.

00:30:36.710 --> 00:30:39.714
And people have thought
about disk packing a lot.

00:30:39.714 --> 00:30:41.380
But surprisingly, it
hadn't been proofed

00:30:41.380 --> 00:30:43.890
hard until four years ago.

00:30:43.890 --> 00:30:49.650
So this proof is
also complicated.

00:30:49.650 --> 00:30:51.900
And it involves a lot of
geometry and trigonometry

00:30:51.900 --> 00:30:54.250
and some calculus and fun stuff.

00:30:54.250 --> 00:30:56.120
So I'm going to give
you a sketch of it.

00:30:56.120 --> 00:30:58.100
You should be believable
that this works,

00:30:58.100 --> 00:31:01.070
but the details,
again, are messy.

00:31:01.070 --> 00:31:03.070
For starters, let's say
that we're packing disks

00:31:03.070 --> 00:31:05.010
into an equilateral triangle.

00:31:05.010 --> 00:31:07.390
This is much easier
to work with.

00:31:07.390 --> 00:31:09.200
I'll go to a square in a second.

00:31:09.200 --> 00:31:11.290
So if I have this
equilateral triangle, what

00:31:11.290 --> 00:31:12.320
I'm going to do is,
first, I'm going

00:31:12.320 --> 00:31:13.810
to give you a
bunch of disks that

00:31:13.810 --> 00:31:18.690
are forced to pack in this nice,
triangular, grid arrangement,

00:31:18.690 --> 00:31:21.944
leaving these dark holes.

00:31:21.944 --> 00:31:23.485
And I'm going to
give you more disks,

00:31:23.485 --> 00:31:25.680
and so the more disks have
to go into those holes.

00:31:25.680 --> 00:31:28.750
And these are actually kissing
disks, they're touching.

00:31:28.750 --> 00:31:32.110
So you can only put-- every
disk you put from now on

00:31:32.110 --> 00:31:33.830
will be in one of these holes.

00:31:33.830 --> 00:31:37.500
And I'm just going to do this
big enough so that I have

00:31:37.500 --> 00:31:39.840
at least n over three holes.

00:31:39.840 --> 00:31:42.280
Each hole is going
to represent a bin

00:31:42.280 --> 00:31:44.730
that I'm trying to put a
triple of numbers into.

00:31:44.730 --> 00:31:50.470
And then, here is the
construction for, I guess,

00:31:50.470 --> 00:31:52.990
this would be a three
partition gadget.

00:31:52.990 --> 00:31:58.380
We want to get that-- oh, slight
typo there-- ai plus aj plus ak

00:31:58.380 --> 00:32:01.190
is less than or equal to t.

00:32:01.190 --> 00:32:03.740
And so, these are
the three disks

00:32:03.740 --> 00:32:06.510
representing ai, aj, and ak.

00:32:06.510 --> 00:32:09.970
And there's an extra
disk in the center.

00:32:09.970 --> 00:32:12.790
And what's drawn here is
everything is maybe tight,

00:32:12.790 --> 00:32:14.370
almost as touching.

00:32:14.370 --> 00:32:17.790
But we're going to shrink
these disks a little bit--

00:32:17.790 --> 00:32:20.240
or rather, I'm going
to shrink-- yeah,

00:32:20.240 --> 00:32:23.530
I guess I'll shrink--
I'll get this right-- I'm

00:32:23.530 --> 00:32:25.724
going to shrink this
disk a little bit.

00:32:25.724 --> 00:32:27.640
And I'm going to make
these one's a little bit

00:32:27.640 --> 00:32:32.280
bigger according
to the ai values.

00:32:32.280 --> 00:32:36.004
So this one will be
proportional to ak larger

00:32:36.004 --> 00:32:37.420
than the disk that
would perfectly

00:32:37.420 --> 00:32:40.660
fit here if this one
was maximally-sized.

00:32:40.660 --> 00:32:45.060
And so, that's going to
force this guy to move away.

00:32:45.060 --> 00:32:47.580
Well, he's a little
bit shrunk, so maybe he

00:32:47.580 --> 00:32:49.460
doesn't have to move away.

00:32:49.460 --> 00:32:51.290
But this center disk,
when it shrunk down,

00:32:51.290 --> 00:32:52.280
it has a little
bit of flexibility.

00:32:52.280 --> 00:32:53.700
It could move more this way.

00:32:53.700 --> 00:32:56.033
And if this disk is smaller,
it will move more this way.

00:32:56.033 --> 00:32:58.030
It could move more this
way, more this way.

00:32:58.030 --> 00:33:01.755
And in general, you show
that-- so these guys

00:33:01.755 --> 00:33:04.130
are sort of placing demands
by being a little bit bigger.

00:33:04.130 --> 00:33:06.800
They need to push out.

00:33:06.800 --> 00:33:10.270
And this one is a
little bit smaller.

00:33:10.270 --> 00:33:13.560
And its size is just
a function of t.

00:33:13.560 --> 00:33:15.630
And so, it's going
to move around.

00:33:15.630 --> 00:33:18.700
And the claim is, it has a
valid position if and only

00:33:18.700 --> 00:33:21.812
if ai plus aj plus ak is
less than or equal to t.

00:33:21.812 --> 00:33:24.135
I have written down a
little bit of the details.

00:33:36.370 --> 00:33:39.180
So we're going to choose some
big number capital N, maybe

00:33:39.180 --> 00:33:41.980
it's like n to the 100,
little n to the 100, something

00:33:41.980 --> 00:33:42.760
like that.

00:33:42.760 --> 00:33:45.970
And we'll shrink the
big disk by that amount.

00:33:45.970 --> 00:33:49.985
I'm going to scale everything
so that t equals 1.

00:33:49.985 --> 00:33:52.020
That will simplify
things a little bit.

00:33:52.020 --> 00:33:54.910
So just shrink everything,
all the values, down,

00:33:54.910 --> 00:33:59.240
divide everything
by t, ai's in the t.

00:33:59.240 --> 00:34:11.929
And then, I think we're going
to shrink the ai disk by minus 1

00:34:11.929 --> 00:34:18.110
over n squared plus ai over n.

00:34:18.110 --> 00:34:20.050
This is a funny
notion of shrink.

00:34:20.050 --> 00:34:22.739
I'm going to first make it
smaller by 1 over n squared.

00:34:22.739 --> 00:34:26.070
And then I'm going to
grow it by ai over n.

00:34:26.070 --> 00:34:29.969
This term, I believe,
is to get rid

00:34:29.969 --> 00:34:32.290
of smaller things in
the Taylor expansion.

00:34:32.290 --> 00:34:36.699
So disks are annoying
because they're circular.

00:34:36.699 --> 00:34:38.820
Because they're
quadratic curves.

00:34:38.820 --> 00:34:43.090
And so, you get-- you know, it's
an awkward shape to deal with.

00:34:43.090 --> 00:34:45.210
And you're worried about
how I move this center

00:34:45.210 --> 00:34:46.639
relative to how I
move the other centers

00:34:46.639 --> 00:34:48.010
and whether they're
hitting each other.

00:34:48.010 --> 00:34:50.280
And whether hitting each other
is a quadratic constraint.

00:34:50.280 --> 00:34:52.696
You have to measure the distance
between these two points.

00:34:52.696 --> 00:34:57.220
It should be greater than or
equal to the sum of the radii.

00:34:57.220 --> 00:34:59.630
So that's tough to work with.

00:34:59.630 --> 00:35:02.080
So to simplify things,
we take first derivatives

00:35:02.080 --> 00:35:04.550
and say, well, to the first
order, what's happening

00:35:04.550 --> 00:35:06.100
when I move these disks around?

00:35:06.100 --> 00:35:08.180
And when you say
first derivatives,

00:35:08.180 --> 00:35:10.240
you get an approximation
to the truth.

00:35:10.240 --> 00:35:12.810
And the second derivative, it
tells you a little bit more

00:35:12.810 --> 00:35:13.690
of the truth.

00:35:13.690 --> 00:35:16.470
And if you've ever
done Taylor series,

00:35:16.470 --> 00:35:18.367
you know you get
something like 1

00:35:18.367 --> 00:35:20.950
over n, something times 1 over
n plus something times 1 over n

00:35:20.950 --> 00:35:22.880
squared and so on.

00:35:22.880 --> 00:35:25.150
And so, if we just
subtract off this term,

00:35:25.150 --> 00:35:28.010
make these disks a little bit
smaller than they need to be,

00:35:28.010 --> 00:35:30.690
that lets you deal with all
those terms all at once.

00:35:30.690 --> 00:35:34.240
So it lets us focus
on the lead term.

00:35:34.240 --> 00:35:37.600
And to the first order, the
claim is, what happens is,

00:35:37.600 --> 00:35:39.370
well, we made this
disk smaller by 1.

00:35:39.370 --> 00:35:40.990
Remember 1 is t.

00:35:40.990 --> 00:35:44.020
We made the other
guys larger by ai.

00:35:44.020 --> 00:35:46.790
So that's going to
work out exactly

00:35:46.790 --> 00:35:49.630
when the sum of the three ai's
is less than or equal to 1.

00:35:49.630 --> 00:35:50.852
Then this will have room.

00:35:50.852 --> 00:35:52.310
And that's true to
the first order.

00:35:52.310 --> 00:35:53.900
And you have to do
this ugly business

00:35:53.900 --> 00:35:56.160
to make it true exactly.

00:35:56.160 --> 00:35:59.240
So I think, without going
into vector algebra,

00:35:59.240 --> 00:36:03.560
this is the intuition
of what's going on.

00:36:03.560 --> 00:36:07.810
And that's that proof.

00:36:07.810 --> 00:36:09.315
Any questions?

00:36:09.315 --> 00:36:11.690
The point here is to expose
you to lots of different ways

00:36:11.690 --> 00:36:15.600
to represent numbers
and three partition.

00:36:15.600 --> 00:36:19.550
And a lot of times it comes
up in geometric settings.

00:36:19.550 --> 00:36:22.200
But so far, we've seen rather
different ways to represent it.

00:36:22.200 --> 00:36:24.920
We'll see graph
theory in a moment.

00:36:24.920 --> 00:36:27.830
Probably, next up is
games and puzzles.

00:36:27.830 --> 00:36:29.330
So let's play some games.

00:36:32.530 --> 00:36:35.129
Right, there was one more
part of this proof I forgot.

00:36:35.129 --> 00:36:36.670
What if you're
packing into a square?

00:36:36.670 --> 00:36:38.690
This is particularly
important for origami.

00:36:38.690 --> 00:36:40.640
This paper appeared in
an origami conference,

00:36:40.640 --> 00:36:44.360
so we needed to solve the
case of square packing.

00:36:44.360 --> 00:36:46.760
This is more awkward.

00:36:46.760 --> 00:36:50.860
The idea, because you can't make
a nice, regular grid on a-- you

00:36:50.860 --> 00:36:54.290
know, square grid packing is
not very efficient for disks.

00:36:54.290 --> 00:36:56.652
But if you have these
four really big disks,

00:36:56.652 --> 00:36:58.610
I should mention here
the goal is for the disks

00:36:58.610 --> 00:37:01.252
to fit-- the centers of the
disks to fit inside the square.

00:37:01.252 --> 00:37:02.960
That turns out to be
the right constraint

00:37:02.960 --> 00:37:06.150
from an origami perspective.

00:37:06.150 --> 00:37:07.790
So, we would make
these four big disks,

00:37:07.790 --> 00:37:09.350
they have to be at the corners.

00:37:09.350 --> 00:37:11.700
Then we make this big disk,
it has to be in the center.

00:37:11.700 --> 00:37:13.570
These are all
perfectly touching.

00:37:13.570 --> 00:37:15.209
Then we add these
four disks and it

00:37:15.209 --> 00:37:16.750
forces a particular
arrangement here,

00:37:16.750 --> 00:37:19.980
which is a little awkward
to compute but you can.

00:37:19.980 --> 00:37:23.657
And yes, we do that four times.

00:37:23.657 --> 00:37:25.240
Then, for each of
these constructions,

00:37:25.240 --> 00:37:26.810
this is the shape that we want.

00:37:26.810 --> 00:37:31.305
We want these kind of
equilateral triangle-ish gaps.

00:37:31.305 --> 00:37:33.180
I say ish because they're
not straight sides,

00:37:33.180 --> 00:37:34.620
they're arc sides.

00:37:34.620 --> 00:37:39.210
But it is-- the centers form an
equilateral triangle perfectly.

00:37:39.210 --> 00:37:40.750
Then we recurse.

00:37:40.750 --> 00:37:45.770
So wherever we have a gap like
that, which is this thing,

00:37:45.770 --> 00:37:47.320
then we add the center guy.

00:37:47.320 --> 00:37:49.320
And then we add these
four disks again,

00:37:49.320 --> 00:37:52.285
just like over here,
three times now.

00:37:52.285 --> 00:37:55.660
Now, of course, we can't
force the disks to go here.

00:37:55.660 --> 00:37:59.590
But they will.

00:37:59.590 --> 00:38:01.430
This is a very
symmetric construction.

00:38:01.430 --> 00:38:03.346
So we're going to do
this symmetrically in all

00:38:03.346 --> 00:38:04.590
the things.

00:38:04.590 --> 00:38:08.260
The other challenge is we left
these rather large gaps here.

00:38:08.260 --> 00:38:09.890
I mean, relative to
these tiny disks,

00:38:09.890 --> 00:38:14.190
which are all fit inside that
gap, this is pretty big gap.

00:38:14.190 --> 00:38:15.850
So we also have
to make these gaps

00:38:15.850 --> 00:38:18.002
unusable by adding
a maximal disk

00:38:18.002 --> 00:38:19.210
and then adding maximal disk.

00:38:19.210 --> 00:38:21.700
And just recursively
adding maximal disks

00:38:21.700 --> 00:38:24.870
until the gaps that are left
are tinier than all the ones

00:38:24.870 --> 00:38:26.960
that we're going to
produce in this recursion.

00:38:26.960 --> 00:38:30.540
This recursion has depth
like log n, so in the end,

00:38:30.540 --> 00:38:35.160
we get roughly n of
these things or n over 3.

00:38:35.160 --> 00:38:37.700
If we have extras, we'll
just throw in maximum disks

00:38:37.700 --> 00:38:40.690
and make them unusable.

00:38:40.690 --> 00:38:43.012
So that's it.

00:38:43.012 --> 00:38:44.470
So this is a lot
harder because you

00:38:44.470 --> 00:38:45.944
have to fill in
all of these gaps

00:38:45.944 --> 00:38:47.860
and make sure everything
is going to be happy.

00:38:47.860 --> 00:38:49.540
And no disk can go
in the wrong place.

00:38:49.540 --> 00:38:51.620
But if you sort of do
it in the right order,

00:38:51.620 --> 00:38:53.460
you can be convinced
at every stage

00:38:53.460 --> 00:38:55.884
you're disk has to go
where you're putting it.

00:38:55.884 --> 00:38:57.800
Except at the very end
where you have freedom.

00:38:57.800 --> 00:39:00.420
The freedom you have is where
the ai's go, which pocket they

00:39:00.420 --> 00:39:01.660
belong to.

00:39:01.660 --> 00:39:03.260
That's the only
freedom you have.

00:39:03.260 --> 00:39:05.900
It's the only freedom
we want you to have.

00:39:05.900 --> 00:39:07.610
OK.

00:39:07.610 --> 00:39:09.460
So that was disk packing.

00:39:09.460 --> 00:39:11.550
Next is Clickomania .

00:39:11.550 --> 00:39:13.430
How many people have
played Clickomania?

00:39:13.430 --> 00:39:14.400
A few.

00:39:14.400 --> 00:39:15.420
Good.

00:39:15.420 --> 00:39:18.800
It's not completely obscure yet.

00:39:18.800 --> 00:39:20.750
So here I have the
real thing, I think

00:39:20.750 --> 00:39:23.192
this is called Clickomania,
Next Generation.

00:39:23.192 --> 00:39:24.650
And I want to start
a new game so I

00:39:24.650 --> 00:39:26.700
don't have a really bad score.

00:39:26.700 --> 00:39:28.200
So the idea is
you're going to click

00:39:28.200 --> 00:39:30.920
on a group, a connected
group, of one color.

00:39:30.920 --> 00:39:32.150
That group is destroyed.

00:39:32.150 --> 00:39:35.790
And then things fall vertically.

00:39:35.790 --> 00:39:37.530
So column-by-column.

00:39:40.250 --> 00:39:42.020
Rules clear?

00:39:42.020 --> 00:39:49.560
Your goal is to remove all of
the blocks, which I probably

00:39:49.560 --> 00:39:51.110
won't succeed in doing.

00:39:51.110 --> 00:39:53.840
I haven't played in a long time.

00:39:53.840 --> 00:39:56.980
But let's-- I would like
to show you one other rule,

00:39:56.980 --> 00:39:58.430
but I may fail to do so.

00:40:04.830 --> 00:40:09.250
This kind of
checkerboarding, not so good.

00:40:09.250 --> 00:40:11.480
Don't do that when you play.

00:40:11.480 --> 00:40:12.980
Also very bad.

00:40:12.980 --> 00:40:13.960
OK.

00:40:13.960 --> 00:40:16.720
The one rule, which I
won't demonstrate here,

00:40:16.720 --> 00:40:20.010
is if you clear a
column, then these guys

00:40:20.010 --> 00:40:21.390
just sort of eat the column.

00:40:21.390 --> 00:40:23.140
They just move
closer to each other.

00:40:23.140 --> 00:40:25.650
I think usually the right
moves to the left one step.

00:40:25.650 --> 00:40:30.570
OK, so that's-- here's a
successful execution from

00:40:30.570 --> 00:40:32.230
the Clickomania website.

00:40:32.230 --> 00:40:34.240
But I have done it a few times.

00:40:34.240 --> 00:40:35.490
I just haven't in a long time.

00:40:35.490 --> 00:40:38.310
The only rule is, the
group that you click on,

00:40:38.310 --> 00:40:41.770
the connected color chunk has
to be of size greater than 1.

00:40:41.770 --> 00:40:44.870
Otherwise you could just
keep clicking on everything.

00:40:44.870 --> 00:40:47.590
So that's why the
checkerboarding is bad,

00:40:47.590 --> 00:40:51.020
because there you
have singleton guys.

00:40:51.020 --> 00:40:52.520
So you may have
some singleton guys.

00:40:52.520 --> 00:40:55.030
But if you're careful, you
sometimes can get rid of them.

00:40:55.030 --> 00:40:57.160
The question is, when can you?

00:40:57.160 --> 00:40:59.510
And the answer is,
it's NP-complete.

00:40:59.510 --> 00:41:05.060
So this is actually my
first NP-hardness proof,

00:41:05.060 --> 00:41:05.840
I think ever.

00:41:05.840 --> 00:41:08.040
Definitely of a game.

00:41:08.040 --> 00:41:09.200
I think ever.

00:41:09.200 --> 00:41:10.660
So there's a few results here.

00:41:10.660 --> 00:41:14.030
One is that, if you have
a single column, that case

00:41:14.030 --> 00:41:14.650
we can solve.

00:41:14.650 --> 00:41:19.840
A single row actually behaves
the same as a single column,

00:41:19.840 --> 00:41:22.480
because even though they're
asymmetric in general, for when

00:41:22.480 --> 00:41:24.200
it's 1, they're the same.

00:41:24.200 --> 00:41:26.670
And if you happen to know
context-free grammars,

00:41:26.670 --> 00:41:29.800
then here's the answer.

00:41:29.800 --> 00:41:31.560
It's not obvious that
this is the answer.

00:41:31.560 --> 00:41:33.689
But this is saying something
like, well, it could

00:41:33.689 --> 00:41:34.980
be you already solved the game.

00:41:34.980 --> 00:41:36.270
That's the empty string.

00:41:36.270 --> 00:41:38.299
Or it could be you have
a solvable game followed

00:41:38.299 --> 00:41:39.090
by a solvable game.

00:41:39.090 --> 00:41:40.930
You could just sort
of do them separately.

00:41:40.930 --> 00:41:43.370
And if you're careful, they
won't mess each other up.

00:41:43.370 --> 00:41:45.250
And then you solve
the overall game.

00:41:45.250 --> 00:41:47.300
Or it could be you
have a solvable game

00:41:47.300 --> 00:41:51.140
and you have the same color,
one block of the same color,

00:41:51.140 --> 00:41:52.077
on either side.

00:41:52.077 --> 00:41:54.160
That would also be solvable
because you could just

00:41:54.160 --> 00:41:55.320
solve the center thing.

00:41:55.320 --> 00:41:56.890
Then these two
guys come together.

00:41:56.890 --> 00:41:59.300
And then you click
that group of size 2.

00:41:59.300 --> 00:42:01.730
Or this could also happen
where you solve two things

00:42:01.730 --> 00:42:03.376
and then three
blocks come together.

00:42:03.376 --> 00:42:05.000
And you could also
imagine other rules.

00:42:05.000 --> 00:42:06.625
But it turns out
these are enough rules

00:42:06.625 --> 00:42:09.780
to capture all solvable
puzzles for one row or column.

00:42:09.780 --> 00:42:13.110
But that's not a hardness proof
so we won't talk about it.

00:42:13.110 --> 00:42:15.510
We have two NP hardness results.

00:42:15.510 --> 00:42:19.640
One is for two columns
and five colors.

00:42:19.640 --> 00:42:21.460
And the other one
is a hardness proof

00:42:21.460 --> 00:42:26.310
for five columns
and three colors.

00:42:26.310 --> 00:42:28.880
And these are the proofs.

00:42:28.880 --> 00:42:30.730
This one is three partition.

00:42:30.730 --> 00:42:32.047
This one is three set.

00:42:32.047 --> 00:42:33.880
So we might talk about
that in the three set

00:42:33.880 --> 00:42:35.700
section of the class.

00:42:35.700 --> 00:42:38.160
But I'm going to focus here
on the three partition--

00:42:38.160 --> 00:42:40.250
two columns, five colors.

00:42:40.250 --> 00:42:43.140
Open problem is
whether two colors,

00:42:43.140 --> 00:42:44.570
you can get any hardness.

00:42:44.570 --> 00:42:46.303
Question?

00:42:46.303 --> 00:42:48.887
AUDIENCE: Is it obvious
that S to SS is--

00:42:48.887 --> 00:42:49.470
PROFESSOR: No.

00:42:49.470 --> 00:42:51.610
It's not obvious that
S to SS is valid.

00:42:51.610 --> 00:42:53.880
Because you worry that
when you solve one of them,

00:42:53.880 --> 00:42:56.986
you might eat a group
from the right-hand side.

00:42:56.986 --> 00:42:58.610
But you can prove
it's always possible.

00:42:58.610 --> 00:43:00.193
I don't remember how
that proof works,

00:43:00.193 --> 00:43:03.210
but you can check the paper.

00:43:03.210 --> 00:43:04.320
Yeah.

00:43:04.320 --> 00:43:07.160
If you look at the-- if you
ever go to the course website

00:43:07.160 --> 00:43:09.130
and watch this lecture
or click around

00:43:09.130 --> 00:43:11.580
the slides of this lecture,
it has links to all the papers

00:43:11.580 --> 00:43:12.580
that I'm talking about.

00:43:12.580 --> 00:43:14.540
So if you ever want to know
more details, just go there.

00:43:14.540 --> 00:43:15.420
Link is right there.

00:43:15.420 --> 00:43:20.160
You don't have to type in all
these names and Google for it.

00:43:20.160 --> 00:43:20.660
Cool.

00:43:20.660 --> 00:43:24.140
So this is my attempt at
drawing the hardness proof.

00:43:27.130 --> 00:43:28.830
This was challenging.

00:43:28.830 --> 00:43:32.990
And I should say, it's
not drawn to scale.

00:43:32.990 --> 00:43:34.510
So it's not exactly right.

00:43:34.510 --> 00:43:36.840
But it gives you a
flavor of what happens.

00:43:36.840 --> 00:43:39.900
And I believe all the
braces are correct.

00:43:39.900 --> 00:43:41.890
But it just wouldn't
fit on the screen

00:43:41.890 --> 00:43:45.080
if we drew everything
properly to scale.

00:43:45.080 --> 00:43:48.410
So reduction from
three partition.

00:43:48.410 --> 00:43:51.760
We have n numbers, ai
through an integers.

00:43:51.760 --> 00:43:53.250
We're going to
scale everything up.

00:43:53.250 --> 00:43:57.900
We're going to scale the
ai's and t by a factor of b.

00:43:57.900 --> 00:43:59.780
b is 4/3n.

00:43:59.780 --> 00:44:03.680
I don't totally know
why, but you know.

00:44:03.680 --> 00:44:06.825
It's n plus the
number of groups.

00:44:06.825 --> 00:44:08.700
I'm guessing a larger
number would also work,

00:44:08.700 --> 00:44:12.780
but that's definitely enough.

00:44:12.780 --> 00:44:13.290
OK.

00:44:13.290 --> 00:44:15.632
So basically, there's
two columns, remember.

00:44:15.632 --> 00:44:17.340
It's always going to
stay in two columns.

00:44:17.340 --> 00:44:19.480
It never increases.

00:44:19.480 --> 00:44:22.460
There are some clickable
blocks, clickable groups,

00:44:22.460 --> 00:44:23.880
which correspond to the ai's.

00:44:23.880 --> 00:44:26.440
So for every day ai, we're
going to have exactly one block,

00:44:26.440 --> 00:44:30.706
which is b times ai by 1.

00:44:30.706 --> 00:44:32.080
Don't draw the
lines when they're

00:44:32.080 --> 00:44:35.080
in the same connected component.

00:44:35.080 --> 00:44:38.820
But technically, these
are separate squares.

00:44:38.820 --> 00:44:42.020
There's also some
clickable things up here.

00:44:42.020 --> 00:44:43.500
Those are not too essential.

00:44:43.500 --> 00:44:47.450
They're basically to spread
out these red blocks.

00:44:47.450 --> 00:44:49.280
There are n over
three red blocks here.

00:44:49.280 --> 00:44:52.120
And there are n over
3 red blocks here.

00:44:52.120 --> 00:44:53.830
You will never win
the game unless you

00:44:53.830 --> 00:44:56.360
destroy these red blocks.

00:44:56.360 --> 00:44:59.621
So for example, you could
click all these blue things,

00:44:59.621 --> 00:45:01.620
make the red together,
and then destroy the red.

00:45:01.620 --> 00:45:04.270
But that's not a good idea.

00:45:04.270 --> 00:45:07.980
Because these are only,
this is a very small space.

00:45:07.980 --> 00:45:09.680
This is a relatively large gap.

00:45:09.680 --> 00:45:11.380
I know it doesn't
look like it, but this

00:45:11.380 --> 00:45:13.340
is only n over 3 total.

00:45:13.340 --> 00:45:15.180
The gap between
these two things is

00:45:15.180 --> 00:45:19.110
b times t, which is way
bigger than n over 3.

00:45:19.110 --> 00:45:22.770
OK, so there's big gaps
between these red guys.

00:45:22.770 --> 00:45:24.870
So what you're
basically going to do

00:45:24.870 --> 00:45:29.790
is make this column fall down
until the first red guy aligns

00:45:29.790 --> 00:45:30.580
with this one.

00:45:30.580 --> 00:45:32.155
Then you delete those two.

00:45:32.155 --> 00:45:33.530
Then you're going
to make it fall

00:45:33.530 --> 00:45:36.794
down farther until this
red guy hits this one.

00:45:36.794 --> 00:45:38.210
And then you can
delete those two.

00:45:38.210 --> 00:45:39.846
Just two at a time.

00:45:39.846 --> 00:45:42.220
And we're going to bring it
down until the third guy hits

00:45:42.220 --> 00:45:45.500
third guy, and then the fourth
guy hits the fourth guy.

00:45:45.500 --> 00:45:47.956
Then the reds are gone.

00:45:47.956 --> 00:45:49.330
Before I get to
how that happens,

00:45:49.330 --> 00:45:51.850
let me tell you what happens
when the reds are gone.

00:45:51.850 --> 00:45:53.750
When the reds are gone, I mean,
if there are any purples left--

00:45:53.750 --> 00:45:55.760
turns out there won't be--
but you could click them all.

00:45:55.760 --> 00:45:57.176
Then you could
click all the blue.

00:45:57.176 --> 00:45:59.110
Then you're done on
the right column.

00:45:59.110 --> 00:46:02.480
So right column was
finishable, no problem,

00:46:02.480 --> 00:46:05.160
once you've gotten
rid of the red.

00:46:05.160 --> 00:46:10.615
Now the left column is
mostly checkerboard.

00:46:10.615 --> 00:46:14.320
And if you remove
the red pixels,

00:46:14.320 --> 00:46:18.420
you're left with exactly a
checkerboard except here,

00:46:18.420 --> 00:46:19.930
the topmost red guy.

00:46:19.930 --> 00:46:22.390
It's white on either side.

00:46:22.390 --> 00:46:24.820
And in general, everything
below this point

00:46:24.820 --> 00:46:27.601
is the same as everything
above this point upside down.

00:46:27.601 --> 00:46:30.100
And so then you can always just
click on the center, center,

00:46:30.100 --> 00:46:30.730
center, center.

00:46:30.730 --> 00:46:33.105
I guess you have to move your
mouse down as that happens,

00:46:33.105 --> 00:46:37.400
but you will then destroy
the black and white part.

00:46:37.400 --> 00:46:38.670
Total is five colors.

00:46:38.670 --> 00:46:42.440
We've got red, purple,
blue, black and white.

00:46:42.440 --> 00:46:46.260
OK, now this is my
attempt at showing you

00:46:46.260 --> 00:46:49.090
how we get the red
things to align.

00:46:49.090 --> 00:46:50.680
But the idea is simple.

00:46:53.260 --> 00:46:55.201
The initial gap from
this guy to this guy.

00:46:55.201 --> 00:46:56.950
And then, the gap
henceforth from this one

00:46:56.950 --> 00:46:58.445
to this one to
this one is always

00:46:58.445 --> 00:47:01.220
b times t plus some constant.

00:47:01.220 --> 00:47:03.970
The constants are just annoying.

00:47:03.970 --> 00:47:05.350
So they're not essential.

00:47:05.350 --> 00:47:08.155
The idea is, well, I've got
to bring this down b times t.

00:47:08.155 --> 00:47:09.530
So in order to do
that, I'm going

00:47:09.530 --> 00:47:13.540
to click on some purple things
whose total size is b times t.

00:47:13.540 --> 00:47:16.300
In other words, the sum of
the ai's that I'm clicking on

00:47:16.300 --> 00:47:18.740
should be equal to t.

00:47:18.740 --> 00:47:20.740
And we happen to know
that will be three things,

00:47:20.740 --> 00:47:22.624
but that's not essential here.

00:47:22.624 --> 00:47:24.040
We can just use
the simple version

00:47:24.040 --> 00:47:26.270
of three partition, where
you're asking for sets

00:47:26.270 --> 00:47:28.910
that happened to sum to t.

00:47:28.910 --> 00:47:32.005
Because everything is scaled up
so big by these factors of b,

00:47:32.005 --> 00:47:34.320
I mean, these
gaps-- you have to,

00:47:34.320 --> 00:47:37.660
even to get in the right
proximity, you have to choose

00:47:37.660 --> 00:47:40.520
ai's that sum to exactly t.

00:47:43.340 --> 00:47:44.610
Yes.

00:47:44.610 --> 00:47:48.980
So the constants are annoying
because you want to make sure--

00:47:48.980 --> 00:47:50.280
so here's an example.

00:47:50.280 --> 00:47:52.480
Here are, in this
particular picture,

00:47:52.480 --> 00:47:55.670
the height of one of
these things is 6.

00:47:55.670 --> 00:47:58.640
And so, I click on one
purple thing of size 4

00:47:58.640 --> 00:48:00.012
and one purple thing of size 2.

00:48:00.012 --> 00:48:01.970
In reality, these numbers
would be much bigger,

00:48:01.970 --> 00:48:03.770
but for the picture, that works.

00:48:03.770 --> 00:48:05.520
Then things fall.

00:48:05.520 --> 00:48:07.590
And we get this picture.

00:48:07.590 --> 00:48:10.380
And these red things are almost
aligned, but they're off by 2,

00:48:10.380 --> 00:48:13.080
so I click on this
little 1 by 2 block.

00:48:13.080 --> 00:48:14.290
And then they're aligned.

00:48:14.290 --> 00:48:16.560
Then I can click
on the red thing.

00:48:16.560 --> 00:48:19.320
I also click on this blue
thing to sort of advance

00:48:19.320 --> 00:48:20.470
to the next red thing.

00:48:20.470 --> 00:48:23.270
And then these guys fall
and I get this picture.

00:48:23.270 --> 00:48:25.460
I could click on the
white but it won't matter.

00:48:25.460 --> 00:48:27.560
That's just, I could do
that all at the end later.

00:48:27.560 --> 00:48:30.430
Now my goal is to get
this red thing to here.

00:48:30.430 --> 00:48:33.580
Again, the gap is exactly 5.

00:48:33.580 --> 00:48:38.400
So I click on, let's say, 6.

00:48:38.400 --> 00:48:41.780
Let's say I click on
2 things of size 3.

00:48:41.780 --> 00:48:44.480
And so then everything falls.

00:48:44.480 --> 00:48:45.480
And the reds align.

00:48:45.480 --> 00:48:46.490
Then I delete it.

00:48:46.490 --> 00:48:49.670
I also delete the
blue thing to advance.

00:48:49.670 --> 00:48:51.810
And I think that works.

00:48:51.810 --> 00:48:52.756
Yeah, question.

00:48:52.756 --> 00:48:53.640
AUDIENCE: How do you
ensure that it's always

00:48:53.640 --> 00:48:55.444
the leading red
block that has to go

00:48:55.444 --> 00:48:57.212
with the trailing red
block on the left?

00:48:57.212 --> 00:48:57.920
PROFESSOR: Right.

00:48:57.920 --> 00:49:01.240
So it could be you take some
other block, other red block,

00:49:01.240 --> 00:49:03.880
and align it with this one.

00:49:03.880 --> 00:49:08.780
That is mostly a worry from
a construction standpoint.

00:49:08.780 --> 00:49:11.380
If you did that,
you might get stuck.

00:49:11.380 --> 00:49:14.710
But I claim if I did that, it's
never a problem to do that.

00:49:14.710 --> 00:49:19.770
Because this length is, this
total extent of these red guys,

00:49:19.770 --> 00:49:21.520
is relatively small.

00:49:21.520 --> 00:49:24.290
The whole length here is n.

00:49:24.290 --> 00:49:27.330
Sorry, it's 3 times n over 3.

00:49:27.330 --> 00:49:29.070
Whole length is n
whereas all these ai's

00:49:29.070 --> 00:49:31.940
are scaled by a factor
of much bigger than n.

00:49:31.940 --> 00:49:34.210
Well, not a huge amount
bigger, but bigger than n.

00:49:34.210 --> 00:49:36.010
So even to get them
vaguely to the right--

00:49:36.010 --> 00:49:38.850
this is what I was saying--
to get this red block or any

00:49:38.850 --> 00:49:41.030
of these red blocks
near this one,

00:49:41.030 --> 00:49:45.200
because these things
are scaled so huge,

00:49:45.200 --> 00:49:49.440
to get one close is the same
as getting all of them close.

00:49:49.440 --> 00:49:53.080
If you happen to succeed in a
way that gets the reds to align

00:49:53.080 --> 00:49:56.132
in an out of order, that would
still give a valid solution

00:49:56.132 --> 00:49:57.090
to the three partition.

00:49:57.090 --> 00:49:57.780
That's the point.

00:49:57.780 --> 00:49:59.321
Because we scaled
everything so huge.

00:50:03.016 --> 00:50:05.640
To do the other direction, say,
if you have a solution of three

00:50:05.640 --> 00:50:08.420
partition, then there's a
solution to this instance,

00:50:08.420 --> 00:50:11.050
there we do it in order so that
we're in control and make sure

00:50:11.050 --> 00:50:14.040
all the constants add up right.

00:50:14.040 --> 00:50:16.420
And that's sort of the
annoying part of this proof.

00:50:16.420 --> 00:50:19.380
But this is a
relatively easy proof,

00:50:19.380 --> 00:50:21.360
except for these little
additive constants

00:50:21.360 --> 00:50:22.910
to make sure
everything lines up.

00:50:22.910 --> 00:50:24.630
It would be great if I
could just put these reds

00:50:24.630 --> 00:50:25.480
on top of each other.

00:50:25.480 --> 00:50:27.950
But then they're one group and
you delete them all at once.

00:50:27.950 --> 00:50:29.850
So I have to put these
things in between.

00:50:29.850 --> 00:50:31.975
They have to be length 2
so that I can destroy them

00:50:31.975 --> 00:50:33.270
whenever I want to.

00:50:33.270 --> 00:50:34.850
And so, all these
additive constants

00:50:34.850 --> 00:50:35.808
kind of get in the way.

00:50:35.808 --> 00:50:39.180
But it's not too bad.

00:50:39.180 --> 00:50:40.600
Other questions
about this proof?

00:50:43.199 --> 00:50:43.990
That's Clickomania.

00:50:48.850 --> 00:50:50.060
Cool.

00:50:50.060 --> 00:50:59.280
Next is Tetris, as advertised
in the original, first lecture.

00:50:59.280 --> 00:51:02.480
So if you haven't
played Tetris, here

00:51:02.480 --> 00:51:05.520
is the-- I hope
you've played Tetris.

00:51:05.520 --> 00:51:07.590
I played a lot as a kid.

00:51:07.590 --> 00:51:09.110
You have these
tetragonal blocks.

00:51:09.110 --> 00:51:10.560
You can rotate them.

00:51:10.560 --> 00:51:14.040
And then you can force
drop them or you can slowly

00:51:14.040 --> 00:51:16.135
drop them and do weird
things like that,

00:51:16.135 --> 00:51:20.036
you know, sort of
last minute moves.

00:51:20.036 --> 00:51:22.260
Let's see.

00:51:22.260 --> 00:51:25.660
I don't think that's-- yeah,
the rotation centers are always

00:51:25.660 --> 00:51:28.260
a bit funny, so you
can do cool things.

00:51:28.260 --> 00:51:30.140
So let's have some fun.

00:51:36.041 --> 00:51:38.040
I'll just play Tetris for
the rest of the class.

00:51:41.210 --> 00:51:43.950
So important rule is
when you complete a line,

00:51:43.950 --> 00:51:45.310
then that line disappears.

00:51:45.310 --> 00:51:49.174
Although in the proof, we will
prevent that from happening,

00:51:49.174 --> 00:51:52.300
it is a rule of the game.

00:51:52.300 --> 00:51:55.040
That's annoying.

00:51:55.040 --> 00:51:57.750
Also annoying.

00:51:57.750 --> 00:51:59.460
OK, well, you get the idea.

00:51:59.460 --> 00:52:01.360
You're super impressed
by my Tetris skills.

00:52:04.320 --> 00:52:07.080
All right, so cool.

00:52:07.080 --> 00:52:10.890
I used to play it on
GameBoy and then NES.

00:52:10.890 --> 00:52:13.500
You can play it on
the green building.

00:52:13.500 --> 00:52:16.540
This happened in 2012
finally, after it

00:52:16.540 --> 00:52:19.360
was dreamed for many years.

00:52:19.360 --> 00:52:24.260
I am a Tetris master according
to the Harvard Tetris Society.

00:52:24.260 --> 00:52:26.460
This was a for proving.

00:52:26.460 --> 00:52:30.840
I didn't have to play a game
to win this as you can tell,

00:52:30.840 --> 00:52:34.390
for proofing NP-completeness and
maximization of aligns Tetris's

00:52:34.390 --> 00:52:36.390
pieces played, or
minimization of square height,

00:52:36.390 --> 00:52:38.432
we masters of the
Harvard Tetris Society

00:52:38.432 --> 00:52:40.640
hereby confer the title of
Tetris Master upon Erik D.

00:52:40.640 --> 00:52:43.290
Demaine on the 16th day of
the 12 month in the year 17

00:52:43.290 --> 00:52:48.684
Ano Tetri, which is since
the invention of Tetris.

00:52:48.684 --> 00:52:50.980
OK.

00:52:50.980 --> 00:52:53.930
This is a proof done
early in my career

00:52:53.930 --> 00:52:57.690
at MIT with two MIT students,
David Liben-Nowell and Susan

00:52:57.690 --> 00:53:01.510
Hohenberger, now professors
at other schools.

00:53:01.510 --> 00:53:03.460
This was a first
attempt at a proof.

00:53:03.460 --> 00:53:06.280
We had many attempts at
a proof, all of which

00:53:06.280 --> 00:53:09.370
were wrong except the last one.

00:53:09.370 --> 00:53:11.230
Yeah, anyway, you
could try to see

00:53:11.230 --> 00:53:12.580
what's wrong with that proof.

00:53:12.580 --> 00:53:14.510
But here is a working proof.

00:53:14.510 --> 00:53:18.240
This is actually not the
first working proof we had.

00:53:18.240 --> 00:53:20.900
So there is me,
David, and Susan.

00:53:20.900 --> 00:53:23.890
And then we published a much
harder version of the proof,

00:53:23.890 --> 00:53:27.440
with like 500 cases, and then
these three guys read our paper

00:53:27.440 --> 00:53:29.710
and said, hey, I think we
can simplify it like this.

00:53:29.710 --> 00:53:31.540
And then we wrote a
joint, journal version.

00:53:31.540 --> 00:53:37.330
So reduction is from
three partition, surprise.

00:53:37.330 --> 00:53:38.720
So I should say,
what does Tetris

00:53:38.720 --> 00:53:41.000
mean from a computational
complexity standpoint?

00:53:41.000 --> 00:53:42.900
There are multiple
interpretations.

00:53:42.900 --> 00:53:45.190
Our interpretation is, I
give you an initial board.

00:53:45.190 --> 00:53:46.940
If you've already been
playing for awhile,

00:53:46.940 --> 00:53:48.420
here's what you have.

00:53:48.420 --> 00:53:50.200
And then I give you
the entire sequence

00:53:50.200 --> 00:53:51.750
of pieces that's going to come.

00:53:51.750 --> 00:53:53.570
And I want to know,
can you survive

00:53:53.570 --> 00:53:55.764
maximized number of lines.

00:53:55.764 --> 00:53:57.430
This is not yet the
approximability part

00:53:57.430 --> 00:53:59.888
of the class, but we get some
really easy inapproximability

00:53:59.888 --> 00:54:01.250
results, so I will mention them.

00:54:01.250 --> 00:54:03.200
For now, it's just
can you survive.

00:54:03.200 --> 00:54:07.660
The ceiling is like
here, a couple rows

00:54:07.660 --> 00:54:08.900
above this initial picture.

00:54:08.900 --> 00:54:10.200
So you're almost dead.

00:54:10.200 --> 00:54:12.510
So it's like every
second counts.

00:54:12.510 --> 00:54:13.320
All right?

00:54:13.320 --> 00:54:19.390
Your goal is to fill up
these chambers, these bins,

00:54:19.390 --> 00:54:21.350
exactly, with no holes.

00:54:21.350 --> 00:54:23.450
So if you could
do it, at the end

00:54:23.450 --> 00:54:24.972
I'm going to give
you a T and then

00:54:24.972 --> 00:54:26.740
a whole bunch of straights.

00:54:26.740 --> 00:54:29.760
And then you can win the game.

00:54:29.760 --> 00:54:31.970
All right?

00:54:31.970 --> 00:54:36.450
So we have n over
3 of these buckets.

00:54:36.450 --> 00:54:40.200
Each one is roughly t tall.

00:54:40.200 --> 00:54:42.600
There's some additive constant
to deal with some stuff,

00:54:42.600 --> 00:54:45.760
but there's t notches.

00:54:45.760 --> 00:54:47.780
Each of these is
basically counting

00:54:47.780 --> 00:54:50.200
one unit of an integer.

00:54:50.200 --> 00:54:52.541
OK?

00:54:52.541 --> 00:54:53.040
Yeah.

00:54:53.040 --> 00:54:55.910
The point is, if you
don't open this thing,

00:54:55.910 --> 00:54:57.630
where are the i's going to go?

00:54:57.630 --> 00:55:00.600
And you will only be able to
open this thing if this is full

00:55:00.600 --> 00:55:02.910
and this is full and this
is full and this is full.

00:55:02.910 --> 00:55:06.350
So you've got to get these
perfect so that at the top,

00:55:06.350 --> 00:55:10.852
you can open this and
then clear everything.

00:55:10.852 --> 00:55:12.260
OK.

00:55:12.260 --> 00:55:16.150
So here are the gadgets
from the piece perspective.

00:55:16.150 --> 00:55:17.920
That was the initial
configuration.

00:55:17.920 --> 00:55:19.820
Of course, there
are no ai's yet.

00:55:19.820 --> 00:55:24.090
So the piece sequence has
to encode the ai's in unary.

00:55:24.090 --> 00:55:25.960
Because if there are
only a constant number

00:55:25.960 --> 00:55:30.600
of different tetromino pieces,
so you have to encode-- well,

00:55:30.600 --> 00:55:32.500
I guess you could try
to encode in binary.

00:55:32.500 --> 00:55:35.740
It's very hard to add when
you're working with tetrominoes

00:55:35.740 --> 00:55:37.420
unless you do it in unary.

00:55:37.420 --> 00:55:39.840
So here's the idea.

00:55:39.840 --> 00:55:41.560
We have an initial
set-up like this.

00:55:41.560 --> 00:55:43.860
It will always have this
little thing in the corner.

00:55:43.860 --> 00:55:46.250
And so to say, hey,
a new ai is starting,

00:55:46.250 --> 00:55:48.530
we're going to
give you, you might

00:55:48.530 --> 00:55:50.630
call this a
right-ward pointing L.

00:55:50.630 --> 00:55:53.120
If you look from the
barrel of the gun,

00:55:53.120 --> 00:55:55.350
then it goes to the right.

00:55:55.350 --> 00:55:58.020
So that makes a
nice flat face here.

00:55:58.020 --> 00:56:01.060
Because the next piece that's
coming is a 2 by 2 square.

00:56:01.060 --> 00:56:03.310
So what you're going to do
is let it drop all the way.

00:56:03.310 --> 00:56:04.780
And then at the
very last second,

00:56:04.780 --> 00:56:06.300
you slide it to the right.

00:56:06.300 --> 00:56:07.694
OK?

00:56:07.694 --> 00:56:09.360
And in general, we're
going to represent

00:56:09.360 --> 00:56:13.750
ai by this pattern--
square, left

00:56:13.750 --> 00:56:16.680
L, square, to the power ai.

00:56:16.680 --> 00:56:18.690
Like we're going to
repeat that ai times.

00:56:18.690 --> 00:56:21.860
So here I repeated it twice
and then dot, dot, dot.

00:56:21.860 --> 00:56:22.360
OK?

00:56:22.360 --> 00:56:24.515
That is encoding
ai in unary-- or I

00:56:24.515 --> 00:56:26.640
don't know if there's
something smaller than unary,

00:56:26.640 --> 00:56:31.060
where you use three objects
to represent one unit,

00:56:31.060 --> 00:56:32.650
but there you go.

00:56:32.650 --> 00:56:35.310
And then at the end
of the ai, we're

00:56:35.310 --> 00:56:37.550
going to sort of finish
things off and reset

00:56:37.550 --> 00:56:43.150
to this original kind of
configuration by saying square

00:56:43.150 --> 00:56:45.680
and straight.

00:56:45.680 --> 00:56:46.180
OK?

00:56:46.180 --> 00:56:47.830
So the square nestles in there.

00:56:47.830 --> 00:56:49.430
We get a straight.

00:56:49.430 --> 00:56:51.910
And if all goes according
to plan, what you've done

00:56:51.910 --> 00:56:55.290
is filled up basically
ai units of this thing.

00:56:55.290 --> 00:56:57.510
And maybe plus 1.

00:56:57.510 --> 00:56:59.990
But we know there's only three
ai's going into each bucket,

00:56:59.990 --> 00:57:04.090
so we can deal with a plus
additive 3, that's no big deal.

00:57:04.090 --> 00:57:07.460
And that's good.

00:57:07.460 --> 00:57:09.290
So now you have a choice.

00:57:09.290 --> 00:57:11.540
You have this long sequence
of pieces representing ai.

00:57:11.540 --> 00:57:14.081
In general, the piece sequences
is the piece sequence for a1,

00:57:14.081 --> 00:57:16.540
the piece sequence for
a2, piece sequence for a3.

00:57:16.540 --> 00:57:19.120
The intent is, you put
all of these pieces

00:57:19.120 --> 00:57:23.120
into one column, one
of these buckets.

00:57:23.120 --> 00:57:26.760
The claim is you can't against
the divisibility issue.

00:57:26.760 --> 00:57:29.992
The big issue is, can we
divide ai into two parts?

00:57:29.992 --> 00:57:32.450
Put part of it in one bucket,
part of it in another bucket.

00:57:32.450 --> 00:57:35.220
That would not give us a
solution to three partition.

00:57:35.220 --> 00:57:37.300
But the claim is you can't.

00:57:37.300 --> 00:57:40.380
And the proof of this claim is
not too hard for this proof.

00:57:40.380 --> 00:57:43.850
It was much more tedious
for the original proof.

00:57:43.850 --> 00:57:46.240
But basically, you
try everything else

00:57:46.240 --> 00:57:48.460
and show that you're doomed.

00:57:48.460 --> 00:57:51.380
So every other possible move.

00:57:51.380 --> 00:57:57.480
So one type of bad
move, so when you

00:57:57.480 --> 00:58:01.830
do this thing of putting
in the right-ward facing L,

00:58:01.830 --> 00:58:04.060
remember, there's only
right-ward facing L's, there's

00:58:04.060 --> 00:58:06.661
only n of them, one per ai.

00:58:06.661 --> 00:58:08.570
So that's the only
sort of nice piece.

00:58:08.570 --> 00:58:11.520
We call this priming a bucket.

00:58:11.520 --> 00:58:14.240
Because now it has a
nice flat bottom and so,

00:58:14.240 --> 00:58:17.110
these pieces fit nicely,
especially the squares.

00:58:17.110 --> 00:58:19.400
So one issue is, what if
you have an unprimed bucket?

00:58:19.400 --> 00:58:21.630
It still has this
stuff over on the left,

00:58:21.630 --> 00:58:23.430
and you try to just
insert into it.

00:58:23.430 --> 00:58:26.610
Because the first ai comes,
you prime one of the buckets.

00:58:26.610 --> 00:58:28.120
What if you switch
midstream and try

00:58:28.120 --> 00:58:30.260
to move the rest into
an unprimed bucket?

00:58:30.260 --> 00:58:31.575
The claim is, you die.

00:58:31.575 --> 00:58:33.200
You look at the
squares, you say, well,

00:58:33.200 --> 00:58:35.620
if could go here
or here or higher.

00:58:35.620 --> 00:58:37.270
And they're all bad.

00:58:37.270 --> 00:58:40.200
This one means you'll
never fill this stuff,

00:58:40.200 --> 00:58:42.300
so you're basically
going to run out of area.

00:58:42.300 --> 00:58:45.060
Something's going to
have to go into the sky.

00:58:45.060 --> 00:58:47.290
If you put this here, you'll
never get anything here.

00:58:47.290 --> 00:58:49.630
Put that there, you'll
never get anything here.

00:58:49.630 --> 00:58:52.510
The squares won't fit
anymore and so on.

00:58:52.510 --> 00:58:55.110
L's can't go pass
through that thing.

00:58:55.110 --> 00:58:55.610
OK.

00:58:55.610 --> 00:58:57.960
Similarly, if you try to
put a straight away in,

00:58:57.960 --> 00:58:59.480
something bad happens.

00:58:59.480 --> 00:59:02.540
I don't quite remember
what the bad thing is here,

00:59:02.540 --> 00:59:05.360
but that looks-- right.

00:59:05.360 --> 00:59:07.810
Once you cover one, you
can't cover the other.

00:59:07.810 --> 00:59:08.310
Yeah.

00:59:08.310 --> 00:59:10.185
It's not even obvious
you can cover this one,

00:59:10.185 --> 00:59:13.491
but I think with some
clever rotation you can.

00:59:13.491 --> 00:59:16.560
Tetris is a little
weird in that respect.

00:59:16.560 --> 00:59:19.622
And then, with the
left-ward facing L's, you

00:59:19.622 --> 00:59:20.580
can try all the things.

00:59:20.580 --> 00:59:23.010
And again, you're toast.

00:59:23.010 --> 00:59:27.040
So that's one type of bad thing,
where you switch midstream

00:59:27.040 --> 00:59:29.932
from one of-- you start
putting an ai into a bucket,

00:59:29.932 --> 00:59:31.890
and then you try to put
it into a bucket that's

00:59:31.890 --> 00:59:34.800
currently unprimed.

00:59:34.800 --> 00:59:42.240
So what's left is, if
you stick to one bucket,

00:59:42.240 --> 00:59:44.970
do you have to play
like we want to play?

00:59:44.970 --> 00:59:47.956
And so, in the
sequence of pieces,

00:59:47.956 --> 00:59:49.330
when you haven't
placed anything,

00:59:49.330 --> 00:59:51.788
well, maybe you try to prime
it in a different way and then

00:59:51.788 --> 00:59:53.017
that opens up something else.

00:59:53.017 --> 00:59:55.100
Then you'd have to go
through that entire analysis

00:59:55.100 --> 00:59:59.360
in the last side again for
however the unprimed bucket

00:59:59.360 --> 01:00:00.180
might look.

01:00:00.180 --> 01:00:03.640
But it turns out, however
you do it, you're toast.

01:00:03.640 --> 01:00:08.560
You've hidden some square which
you won't be able to open up.

01:00:08.560 --> 01:00:10.300
Unless you do it the right way.

01:00:10.300 --> 01:00:11.930
And once you've
done that piece, you

01:00:11.930 --> 01:00:14.840
check that the next piece
has only one place to go.

01:00:14.840 --> 01:00:17.780
Obviously if it's to the
left, then those are not good.

01:00:17.780 --> 01:00:19.290
And then, the next
piece and so on.

01:00:19.290 --> 01:00:20.857
So you check all these things.

01:00:20.857 --> 01:00:22.690
And you conclude there's
really only one way

01:00:22.690 --> 01:00:24.500
to play this sequence.

01:00:24.500 --> 01:00:27.760
Except for the flexibility of
when a new ai stream comes,

01:00:27.760 --> 01:00:29.600
which bucket do I put it in?

01:00:29.600 --> 01:00:31.240
We're assuming here
infinite dexterity.

01:00:31.240 --> 01:00:33.250
So you can slide to
the left and right,

01:00:33.250 --> 01:00:36.910
pick the bucket you want,
and then let it fall.

01:00:36.910 --> 01:00:38.000
Questions?

01:00:38.000 --> 01:00:38.500
Yeah.

01:00:38.500 --> 01:00:40.740
AUDIENCE: So you set
up the infrastructure

01:00:40.740 --> 01:00:44.899
so that if you leave even
one space unfilled, then

01:00:44.899 --> 01:00:47.450
you're going to die
before you get the T?

01:00:47.450 --> 01:00:49.470
PROFESSOR: Yes.

01:00:49.470 --> 01:00:55.760
So the idea is that if you
leave any square out here,

01:00:55.760 --> 01:00:59.180
you will be in trouble.

01:00:59.180 --> 01:01:03.190
And there are probably
many ways to do this.

01:01:03.190 --> 01:01:05.380
And I forget exactly
what we do in the paper.

01:01:05.380 --> 01:01:10.030
I think the easy one would be
that, if you put any square up

01:01:10.030 --> 01:01:11.860
here, you die.

01:01:11.860 --> 01:01:14.450
So you're right at
the limit of the game.

01:01:14.450 --> 01:01:17.030
If anything doesn't go into
a bucket, you're in trouble.

01:01:17.030 --> 01:01:18.929
And then it's just
a volume argument.

01:01:18.929 --> 01:01:20.220
So you've got all these pieces.

01:01:20.220 --> 01:01:21.990
The total volume
of them is exactly

01:01:21.990 --> 01:01:24.050
the sum of the bucket sizes.

01:01:24.050 --> 01:01:27.040
So if you leave any
blank space, that

01:01:27.040 --> 01:01:29.300
means that the
material that was there

01:01:29.300 --> 01:01:31.050
is going to somehow
end up on the top row.

01:01:31.050 --> 01:01:33.082
And then you're dead.

01:01:33.082 --> 01:01:35.040
I don't remember if that's
exactly what we did,

01:01:35.040 --> 01:01:36.860
but that certainly
seems to work.

01:01:36.860 --> 01:01:38.220
Adam?

01:01:38.220 --> 01:01:42.530
AUDIENCE: If you place something
to high, but at the same time

01:01:42.530 --> 01:01:44.690
finish a line, do you die?

01:01:44.690 --> 01:01:48.940
And assuming not,
could we force our way

01:01:48.940 --> 01:01:51.940
through the block early?

01:01:51.940 --> 01:01:53.710
PROFESSOR: I believe
in real Tetris,

01:01:53.710 --> 01:01:56.250
if you clear a line, that
happens before you potentially

01:01:56.250 --> 01:01:57.100
die.

01:01:57.100 --> 01:01:58.710
I don't think that's
an issue here,

01:01:58.710 --> 01:02:01.430
because you won't be
able to clear anything

01:02:01.430 --> 01:02:02.710
until the T piece.

01:02:02.710 --> 01:02:06.940
So I think you use the
argument I said up to here.

01:02:06.940 --> 01:02:09.190
There are no other T's
in the construction.

01:02:09.190 --> 01:02:12.020
So any other piece you try
to put in here, I think,

01:02:12.020 --> 01:02:14.370
will get you above this row.

01:02:14.370 --> 01:02:15.560
And then you die.

01:02:15.560 --> 01:02:18.184
So that's essentially
unusable space until the T

01:02:18.184 --> 01:02:19.600
And then, up until
that point, you

01:02:19.600 --> 01:02:21.840
have to exactly
fill all the stuff.

01:02:21.840 --> 01:02:22.750
Yeah.

01:02:22.750 --> 01:02:25.320
AUDIENCE: So if we
ignore filling the lower

01:02:25.320 --> 01:02:30.420
stuff in the main
gadgets and just

01:02:30.420 --> 01:02:32.240
stick something up
high and just try

01:02:32.240 --> 01:02:35.070
to fill just the
tops of each of them,

01:02:35.070 --> 01:02:41.086
so that with and L or something
we can clear one space of the--

01:02:41.086 --> 01:02:41.960
PROFESSOR: Oh, I see.

01:02:41.960 --> 01:02:44.495
You could try to put an
L like that or like this.

01:02:49.530 --> 01:02:52.770
Yeah, but it if the row
clears first-- all right.

01:02:52.770 --> 01:02:56.390
Now I have to look up
the rules, I guess.

01:02:56.390 --> 01:02:56.890
Yeah.

01:02:56.890 --> 01:02:59.390
AUDIENCE: I think it might be
OK because then there's no way

01:02:59.390 --> 01:03:01.652
ever to fill the next part.

01:03:01.652 --> 01:03:03.360
PROFESSOR: Let's talk
about this offline.

01:03:03.360 --> 01:03:06.382
I think there's something to
check here, which hopefully we

01:03:06.382 --> 01:03:07.090
did in the paper.

01:03:07.090 --> 01:03:10.150
But I've by now forgotten.

01:03:10.150 --> 01:03:13.000
Just for fun, if you
succeed, at the end,

01:03:13.000 --> 01:03:15.130
you get all of these
right-ward facing L's.

01:03:15.130 --> 01:03:17.014
Then you get the T.
Those lines clear

01:03:17.014 --> 01:03:19.180
and then you get all the
I's and it's so satisfying,

01:03:19.180 --> 01:03:20.120
all those Tetrises.

01:03:22.940 --> 01:03:26.920
And then, if you're-- so a
Tetris is when you get four

01:03:26.920 --> 01:03:31.450
rows in one move, which can
only be done with the straights.

01:03:31.450 --> 01:03:33.630
So this is, if you
survive, then you

01:03:33.630 --> 01:03:35.890
clear a whole bunch of columns.

01:03:35.890 --> 01:03:38.750
But if you want to make
it really embarrassing,

01:03:38.750 --> 01:03:40.520
then you put this
entire construction

01:03:40.520 --> 01:03:44.520
over a nice big wall,
big empty space,

01:03:44.520 --> 01:03:47.290
and you put a whole bunch
of pieces at the end,

01:03:47.290 --> 01:03:51.550
like let's say L's all of the
same orientation or something.

01:03:51.550 --> 01:03:53.150
Those are really easy to pack.

01:03:53.150 --> 01:03:55.270
So if you want to
maximize your score

01:03:55.270 --> 01:03:57.870
and you don't solve
this thing, then you're

01:03:57.870 --> 01:03:59.150
really going to lose bad.

01:03:59.150 --> 01:04:00.804
Because if you do
solve this thing,

01:04:00.804 --> 01:04:02.220
you're going to
get tons of points

01:04:02.220 --> 01:04:05.010
by just playing in here forever.

01:04:05.010 --> 01:04:09.170
So n to the 1 minus epsilon
of the game is down here.

01:04:09.170 --> 01:04:11.870
And if you can't solve
this thing at the top,

01:04:11.870 --> 01:04:14.820
then you're getting a
score of basically zero.

01:04:14.820 --> 01:04:16.580
I mean, you do
place a few pieces,

01:04:16.580 --> 01:04:19.045
but very small compared to the
number of things down here,

01:04:19.045 --> 01:04:20.670
you place like n to
the epsilon pieces.

01:04:20.670 --> 01:04:25.665
Whereas if you do succeed, then
you get to place all n pieces.

01:04:29.760 --> 01:04:31.810
This is just the
initial configuration,

01:04:31.810 --> 01:04:34.110
or which floating square?

01:04:34.110 --> 01:04:36.130
This thing?

01:04:36.130 --> 01:04:37.880
Oh, this one.

01:04:37.880 --> 01:04:40.650
That is possible to
construct, I believe.

01:04:44.200 --> 01:04:45.100
This is a challenge.

01:04:45.100 --> 01:04:48.070
It's a whole industry of
making cool initial patterns

01:04:48.070 --> 01:04:49.570
by playing a lot of things.

01:04:49.570 --> 01:04:52.030
So in fact, there's a paper
by Hoogeboom and Kosters

01:04:52.030 --> 01:04:54.150
that shows that any
reasonable Tetris

01:04:54.150 --> 01:04:58.000
configuration can be constructed
from an initially empty board.

01:04:58.000 --> 01:05:05.370
And so, what we get is
to approximate Tetris,

01:05:05.370 --> 01:05:16.400
let's say the number of pieces
that you play, less than n

01:05:16.400 --> 01:05:25.740
to the 1 minus epsilon
factor is NP-hard.

01:05:25.740 --> 01:05:28.710
That's what we just
showed or sketched.

01:05:28.710 --> 01:05:31.370
So this is an example of an
inapproximability result.

01:05:31.370 --> 01:05:32.620
This is a relatively easy one.

01:05:32.620 --> 01:05:34.937
We just need to assume
P does not equal NP.

01:05:34.937 --> 01:05:36.770
And we get that you
really can't approximate

01:05:36.770 --> 01:05:38.050
within a very good factor.

01:05:38.050 --> 01:05:41.070
It's sort of all or
nothing in this game.

01:05:41.070 --> 01:05:43.940
Later in the class, we'll
see much more subtle

01:05:43.940 --> 01:05:45.045
inapproximability results.

01:05:48.370 --> 01:05:49.080
Other questions?

01:05:49.080 --> 01:05:52.220
Hopefully no more issues.

01:05:52.220 --> 01:05:55.010
There are a lot of other
open problems about Tetris.

01:05:55.010 --> 01:05:56.720
You mentioned construction.

01:05:56.720 --> 01:05:58.640
What if the board
is initially empty?

01:05:58.640 --> 01:06:00.991
Seems like quite a challenging
problem, constant number

01:06:00.991 --> 01:06:01.990
of rows or columns here.

01:06:01.990 --> 01:06:04.440
We assume that both dimensions
are arbitrarily large,

01:06:04.440 --> 01:06:05.880
it's part of the input.

01:06:05.880 --> 01:06:09.310
But these seem very annoying.

01:06:09.310 --> 01:06:10.400
Interesting.

01:06:10.400 --> 01:06:13.560
If you just have straights, I
imagine Tetris is pretty easy.

01:06:13.560 --> 01:06:15.840
So how many of the
Tetris pieces do you

01:06:15.840 --> 01:06:18.770
need to get a harness
proof or are there certain

01:06:18.770 --> 01:06:20.870
small combinations
that are easy?

01:06:20.870 --> 01:06:22.912
We need this ability to
slide at the last minute.

01:06:22.912 --> 01:06:25.120
Be nice if you could just
always be hitting space bar

01:06:25.120 --> 01:06:27.246
and always drop your pieces
from positive infinity.

01:06:27.246 --> 01:06:29.328
We don't know whether that
problem is NP-complete.

01:06:29.328 --> 01:06:30.860
That might be the
most tractable,

01:06:30.860 --> 01:06:33.260
but it's proof would have
to be a little different.

01:06:33.260 --> 01:06:35.599
Two-player Tetris,
online Tetris where

01:06:35.599 --> 01:06:37.140
you don't know the
pieces in advance,

01:06:37.140 --> 01:06:40.440
that's something we might
get to later in the class.

01:06:40.440 --> 01:06:43.260
But these are all open.

01:06:43.260 --> 01:06:45.560
OK.

01:06:45.560 --> 01:06:48.570
So next topic is
in graph theory.

01:06:48.570 --> 01:06:51.810
So suppose you have a
graph, vertices and edges,

01:06:51.810 --> 01:06:54.890
you want to draw it in the
plane of no two vertices

01:06:54.890 --> 01:06:56.330
touching, no vertex on an edge.

01:06:56.330 --> 01:06:57.990
That's a regular
notion I'm drawing,

01:06:57.990 --> 01:06:59.450
but edges are allowed to cross.

01:06:59.450 --> 01:07:01.320
If you're lucky,
graph is planar.

01:07:01.320 --> 01:07:02.410
Don't need any crossings.

01:07:02.410 --> 01:07:04.730
There's this notion of
1-planarity, which goes back

01:07:04.730 --> 01:07:06.980
to the '80s, where
every edge can

01:07:06.980 --> 01:07:09.900
cross at most one other edge.

01:07:09.900 --> 01:07:11.950
So this is an example
of a one-planar drawing.

01:07:11.950 --> 01:07:14.945
Some edges don't cross
anything, but any edge that

01:07:14.945 --> 01:07:17.520
has a crossing only has one.

01:07:17.520 --> 01:07:18.020
OK?

01:07:18.020 --> 01:07:22.716
So this is NP-complete.

01:07:22.716 --> 01:07:25.930
On a notion of strong
here, there's no numbers.

01:07:25.930 --> 01:07:30.440
This is from 2007 and a
reduction from three partition.

01:07:30.440 --> 01:07:35.100
So here are two gadgets.

01:07:35.100 --> 01:07:37.350
This is a double--
well, OK, we'll

01:07:37.350 --> 01:07:40.340
get to this one in a moment.

01:07:40.340 --> 01:07:42.290
Here's a gadget which
is the complete graph

01:07:42.290 --> 01:07:44.400
on six vertices, K6.

01:07:44.400 --> 01:07:48.310
And the idea is that we're
going to plug this in instead

01:07:48.310 --> 01:07:50.080
of a single, bold edge.

01:07:50.080 --> 01:07:52.770
So wherever there's a bold
edge here, what it really means

01:07:52.770 --> 01:07:54.160
is this gadget.

01:07:54.160 --> 01:07:54.660
OK?

01:07:54.660 --> 01:07:56.850
This is meant to be
an uncrossable edge,

01:07:56.850 --> 01:07:59.470
because usually an edge can
take up to one crossing.

01:07:59.470 --> 01:08:01.720
What we're going to replace
this edge with this thing,

01:08:01.720 --> 01:08:03.600
which has a bunch
of crossings in it,

01:08:03.600 --> 01:08:04.700
no matter how you draw it.

01:08:04.700 --> 01:08:06.120
K6 is very symmetric,
so it's not

01:08:06.120 --> 01:08:08.710
too hard to argue about
the different drawings.

01:08:08.710 --> 01:08:10.930
We see a crossing
there, a crossing there,

01:08:10.930 --> 01:08:12.460
and a crossing there.

01:08:12.460 --> 01:08:15.140
And in general, if you look
at any path from this vertex

01:08:15.140 --> 01:08:18.939
to this vertex, you
visit a crossing.

01:08:18.939 --> 01:08:24.109
There's no way to get--
wait, what about this one?

01:08:24.109 --> 01:08:24.920
What do I mean?

01:08:24.920 --> 01:08:28.580
If I attempt to draw
an edge through here,

01:08:28.580 --> 01:08:30.899
I will hit an edge that
has a crossing on it.

01:08:30.899 --> 01:08:32.069
That's what I want.

01:08:32.069 --> 01:08:34.420
So in other words, it's
not possible to draw

01:08:34.420 --> 01:08:36.810
an edge across here
and still be 1-planer

01:08:36.810 --> 01:08:39.080
So this effectively becomes
an uncrossable edge.

01:08:39.080 --> 01:08:39.950
This is notation.

01:08:39.950 --> 01:08:41.330
This is super useful.

01:08:41.330 --> 01:08:43.420
When you have a
complicated construction,

01:08:43.420 --> 01:08:45.240
if you use the
right notation, it's

01:08:45.240 --> 01:08:46.899
not necessarily so complicated.

01:08:46.899 --> 01:08:49.130
If we drew this everywhere
in these pictures,

01:08:49.130 --> 01:08:51.229
it would be really hard
to see what's going on.

01:08:51.229 --> 01:08:55.560
So we use this visual idea
that this is a symbol for that.

01:08:55.560 --> 01:08:57.560
And then we can draw
really simple pictures,

01:08:57.560 --> 01:08:58.838
relatively simple pictures.

01:10:49.030 --> 01:10:54.809
the thing to the end of
the thing over there.

01:10:54.809 --> 01:10:56.350
I mean, this looks
a little bit weird

01:10:56.350 --> 01:10:59.379
like, OK, how do the ai's choose
which side they're on here?

01:10:59.379 --> 01:11:01.420
Well, they just choose
whichever side they're on.

01:11:01.420 --> 01:11:04.410
If they're in the
bottom chunk over here,

01:11:04.410 --> 01:11:06.840
then they'll just connect to
the bottom chunk over here.

01:11:06.840 --> 01:11:08.423
If they're in the
top chunk over here,

01:11:08.423 --> 01:11:11.340
they'll connect to the
corresponding chunk over there.

01:11:11.340 --> 01:11:13.830
This is basically
to force the ai's

01:11:13.830 --> 01:11:17.610
to start on the outside
of this construction.

01:11:17.610 --> 01:11:20.444
So there's a lot of, again,
there's a lot of cases

01:11:20.444 --> 01:11:22.860
here to worry about, about
other ways you might draw this.

01:11:22.860 --> 01:11:24.710
Maybe you'd take
this entire picture

01:11:24.710 --> 01:11:26.720
and stuff it into
this little triangle.

01:11:26.720 --> 01:11:30.260
They all end up with lots of
crossings on a single edge.

01:11:30.260 --> 01:11:32.290
If you do that,
then you have to go,

01:11:32.290 --> 01:11:36.250
you have to cross this edge
many times, for example.

01:11:36.250 --> 01:11:38.990
I think we convinced ourselves
that with a single wheel,

01:11:38.990 --> 01:11:44.307
without this extra thing,
the construction, I think,

01:11:44.307 --> 01:11:46.640
we are not certain about
whether the construction works.

01:11:46.640 --> 01:11:48.954
There's definitely
more cases to consider.

01:11:48.954 --> 01:11:50.620
So at the very least,
it simplify things

01:11:50.620 --> 01:11:52.120
by adding a second wheel.

01:11:52.120 --> 01:11:55.040
It would also mean you'd have
to have multiple edges here

01:11:55.040 --> 01:11:56.330
between the same two vertices.

01:11:56.330 --> 01:11:58.960
So maybe that's why they
did the double wheel,

01:11:58.960 --> 01:12:01.130
so that you have these
paths of length 2 connecting

01:12:01.130 --> 01:12:05.020
the same thing instead
of the exact same edge.

01:12:05.020 --> 01:12:08.420
Anyway, so again,
you have to proof.

01:12:08.420 --> 01:12:10.310
This is essentially
only one planar bedding

01:12:10.310 --> 01:12:13.280
for each of these wheels.

01:12:13.280 --> 01:12:15.660
And for these things to
connect them together.

01:12:15.660 --> 01:12:17.870
And so, the ai's have the
freedom of which bucket

01:12:17.870 --> 01:12:18.850
they go into.

01:12:18.850 --> 01:12:22.530
But because each of these
edges can only be crossed once,

01:12:22.530 --> 01:12:26.810
each unit of each
ai-- only one unit

01:12:26.810 --> 01:12:28.840
can occupy each of these cells.

01:12:28.840 --> 01:12:31.200
So you get three partition.

01:12:31.200 --> 01:12:32.420
Cool?

01:12:32.420 --> 01:12:36.580
Yet another way to
represent numbers in unary.

01:12:36.580 --> 01:12:38.384
Question?

01:12:38.384 --> 01:12:41.660
AUDIENCE: I don't understand
how-- what those numbers are.

01:12:41.660 --> 01:12:46.040
PROFESSOR: So OK, so these are
the ai's-- A1 is 2, A2 is 3,

01:12:46.040 --> 01:12:50.040
A3 is 3, A4 is 3, A5
is 4, and A6 is 5.

01:12:50.040 --> 01:12:54.950
And they are represented
by, this thing is a 2,

01:12:54.950 --> 01:12:58.820
this thing is a 3, this thing
is 3, this thing is a 4,

01:12:58.820 --> 01:13:02.160
and this is a 5.

01:13:02.160 --> 01:13:04.510
And that should be
in the same sequence.

01:13:04.510 --> 01:13:05.510
I think I missed this 3.

01:13:08.310 --> 01:13:10.820
Good.

01:13:10.820 --> 01:13:12.190
OK, that was 1-planarity.

01:13:16.930 --> 01:13:18.890
Four minutes-- which
proofs to cover?

01:13:21.670 --> 01:13:25.610
I will wave my
hands at this one.

01:13:25.610 --> 01:13:28.690
This is a chain of blocks
with hinges on them.

01:13:28.690 --> 01:13:29.790
And it has colors on it.

01:13:29.790 --> 01:13:33.560
Your goal is to form a
particular pattern of colors.

01:13:33.560 --> 01:13:36.760
I find it interesting,
this is our hardness proof.

01:13:36.760 --> 01:13:39.295
It's interesting in that
it's-- a lot of the proofs

01:13:39.295 --> 01:13:41.630
you've seen, it's all
about making the ai's being

01:13:41.630 --> 01:13:42.790
a straight line.

01:13:42.790 --> 01:13:44.510
Here, that's not a big deal.

01:13:44.510 --> 01:13:49.057
We've sort of drawn out--
this is, again, a kind

01:13:49.057 --> 01:13:50.140
of universal construction.

01:13:50.140 --> 01:13:51.870
You could build any
polyomino with it.

01:13:51.870 --> 01:13:53.510
It's all about the colors.

01:13:53.510 --> 01:13:55.000
And so, the idea
is that the ai's

01:13:55.000 --> 01:13:57.160
are represented by how
long of a blue segment

01:13:57.160 --> 01:14:00.750
you have here in the
overall chain of pieces.

01:14:00.750 --> 01:14:03.090
And these are the buckets.

01:14:03.090 --> 01:14:05.360
And so, you just
come in at some point

01:14:05.360 --> 01:14:08.945
and fill in however big
your ai is and then leave.

01:14:08.945 --> 01:14:11.070
And there's just enough
blue to cover all the blue.

01:14:11.070 --> 01:14:13.039
So you'd better not waste it.

01:14:13.039 --> 01:14:15.330
But all the other stuff, you
have a lot of flexibility.

01:14:15.330 --> 01:14:19.610
So it's all about just kind of
filling these amorphous blobs

01:14:19.610 --> 01:14:22.410
that have exactly the right
area to fill these blue regions.

01:14:22.410 --> 01:14:24.500
And there's three times
you're allowed to visit.

01:14:24.500 --> 01:14:25.958
And that gives you
three partition.

01:14:25.958 --> 01:14:27.347
So I want-- it's
hard, especially

01:14:27.347 --> 01:14:29.180
without a physical
model, to understand what

01:14:29.180 --> 01:14:30.304
the rules are at this game.

01:14:30.304 --> 01:14:32.032
But it gives you some
idea of another way

01:14:32.032 --> 01:14:33.240
to represent three partition.

01:14:36.300 --> 01:14:39.520
Next, you may have seen
this kind of object.

01:14:39.520 --> 01:14:43.410
It is called a
carpenter's ruler or rule.

01:14:43.410 --> 01:14:44.550
It's got hinges.

01:14:44.550 --> 01:14:45.860
It's got rigid bars.

01:14:45.860 --> 01:14:47.900
And usually, when you're
not using it-- I mean,

01:14:47.900 --> 01:14:50.240
you can measure lengths,
that's the ruler part.

01:14:50.240 --> 01:14:51.950
And when you're not
using it, it folds

01:14:51.950 --> 01:14:53.640
into this nice, compact form.

01:14:53.640 --> 01:14:54.300
It's great.

01:14:54.300 --> 01:14:56.240
And everyone used these
until the invention

01:14:56.240 --> 01:14:57.570
of the retractable one.

01:14:57.570 --> 01:15:00.780
Though they still use
these a lot in Europe.

01:15:00.780 --> 01:15:03.170
So has unit length in this case.

01:15:03.170 --> 01:15:07.100
But what if you have a really
annoying carpenter's rule

01:15:07.100 --> 01:15:08.710
and the lengths
are not all equal?

01:15:11.510 --> 01:15:14.380
And you have this nice box which
is unit length or, you know,

01:15:14.380 --> 01:15:15.250
some length.

01:15:15.250 --> 01:15:20.000
You'd like to fit your ruler
into that one-dimensional box.

01:15:20.000 --> 01:15:21.880
Let's ignore the thickness here.

01:15:21.880 --> 01:15:22.790
OK?

01:15:22.790 --> 01:15:26.310
Then this problem is hard.

01:15:26.310 --> 01:15:27.800
It is weakly NP-hard.

01:15:27.800 --> 01:15:30.360
You can solve it in
pseudo-polynomial time.

01:15:30.360 --> 01:15:33.340
So this is what-- this is like
one of the very few problems

01:15:33.340 --> 01:15:35.020
we'll see of this type.

01:15:35.020 --> 01:15:36.240
And this is the proof.

01:15:36.240 --> 01:15:40.480
It's one of the simplest proofs
from reduction from partition,

01:15:40.480 --> 01:15:43.621
which is two partition, which
is divide your numbers into two

01:15:43.621 --> 01:15:44.120
groups.

01:15:44.120 --> 01:15:45.100
And I apologize here.

01:15:45.100 --> 01:15:48.270
In this book of ours,
we use x instead of a.

01:15:48.270 --> 01:15:50.030
So those are ai's.

01:15:50.030 --> 01:15:51.140
So you're given some ai's.

01:15:51.140 --> 01:15:53.410
And the idea is,
well, if I would

01:15:53.410 --> 01:15:56.800
like to partition the ai's
into two groups of equal sums,

01:15:56.800 --> 01:15:59.110
like so, that's
the same as saying,

01:15:59.110 --> 01:16:02.530
well, some of the ai's, or the
xi's, are going to go left.

01:16:02.530 --> 01:16:04.080
Some of them are
going to go right.

01:16:04.080 --> 01:16:07.330
And whether I fold something--
I could either leave it

01:16:07.330 --> 01:16:10.279
at 180 degrees or I could
fold it to 0 degrees, that's

01:16:10.279 --> 01:16:11.820
sort of my binary
choice if I'm going

01:16:11.820 --> 01:16:14.260
to go into one-dimensional
box-- if I fold it,

01:16:14.260 --> 01:16:15.540
I change direction.

01:16:15.540 --> 01:16:17.720
If I don't fold it, I stay
in the same direction.

01:16:17.720 --> 01:16:21.800
But what that really means is,
by something running summation

01:16:21.800 --> 01:16:25.550
thing, I can choose for each ai
whether it goes left or right.

01:16:25.550 --> 01:16:26.050
OK?

01:16:26.050 --> 01:16:28.590
And then, this is
gonna-- if this happens,

01:16:28.590 --> 01:16:31.940
what it means is my starting
point is equal to my ending

01:16:31.940 --> 01:16:32.760
point.

01:16:32.760 --> 01:16:33.850
Now, could be in between.

01:16:33.850 --> 01:16:35.920
I go left and right and
who knows what happens.

01:16:35.920 --> 01:16:39.970
But the point is, if they sum up
to the lefts equal the rights,

01:16:39.970 --> 01:16:42.830
then my starting point will
be horizontally aligned

01:16:42.830 --> 01:16:44.750
with my ending point.

01:16:44.750 --> 01:16:46.520
So that's not the problem.

01:16:46.520 --> 01:16:49.390
The problem is to fit into
a box of a given size.

01:16:49.390 --> 01:16:51.470
So this says nothing
about the box.

01:16:51.470 --> 01:16:53.640
But, if you do this very
simple construction,

01:16:53.640 --> 01:16:56.540
which is add a super-long
length and then add

01:16:56.540 --> 01:16:58.650
half of that at the beginning.

01:16:58.650 --> 01:17:00.310
And then, at the
end, you add half

01:17:00.310 --> 01:17:03.950
of the long length and
then the super-long length,

01:17:03.950 --> 01:17:06.360
and your goal is to fit
it in a box of equal

01:17:06.360 --> 01:17:09.460
to the super-long length, that
will be possible if and only

01:17:09.460 --> 01:17:10.640
if these are aligned.

01:17:10.640 --> 01:17:14.832
If they're not aligned, then
if you go halfway left or right

01:17:14.832 --> 01:17:16.290
and then add the
super-long length,

01:17:16.290 --> 01:17:17.780
if it's not aligned
with this one,

01:17:17.780 --> 01:17:19.279
then you'll be a
little bit too big.

01:17:19.279 --> 01:17:20.550
And you won't fit in the box.

01:17:20.550 --> 01:17:21.050
OK?

01:17:21.050 --> 01:17:24.180
So that represents
two partition.

01:17:24.180 --> 01:17:25.610
Cool.

01:17:25.610 --> 01:17:29.380
20 seconds, one more proof.

01:17:29.380 --> 01:17:30.970
So here's another problem.

01:17:30.970 --> 01:17:33.325
Map folding.

01:17:33.325 --> 01:17:34.700
You've probably
done this before.

01:17:34.700 --> 01:17:38.504
Easiest way to refold a
roadmap is differently.

01:17:38.504 --> 01:17:40.170
Generally, what we're
interested in here

01:17:40.170 --> 01:17:41.440
is just very simple folds.

01:17:41.440 --> 01:17:44.270
Fold along one line, then fold
along another line and so on.

01:17:44.270 --> 01:17:44.970
OK?

01:17:44.970 --> 01:17:48.150
So, this is NP-hard.

01:17:48.150 --> 01:17:49.680
If I give you a
crease pattern, this

01:17:49.680 --> 01:17:53.720
doesn't look much like a map,
but we can talk about that.

01:17:53.720 --> 01:17:58.150
If I give you a map, a polygon,
and some creases on it.

01:17:58.150 --> 01:18:00.770
And I want to fold
all of these creases,

01:18:00.770 --> 01:18:04.850
this is possible if and only
if two partition is solvable.

01:18:04.850 --> 01:18:07.250
Notice these lengths--
here we used a's.

01:18:07.250 --> 01:18:08.710
That's smart of us.

01:18:08.710 --> 01:18:11.700
So these are the ai's
down the distances

01:18:11.700 --> 01:18:13.630
between these creases,
consecutive creases.

01:18:13.630 --> 01:18:17.080
And again, the idea is, well,
I can fold each one or not.

01:18:17.080 --> 01:18:19.840
And just like the carpenters
rule, I can fold or not.

01:18:19.840 --> 01:18:24.060
And if I am clever and I do
it with the right choice,

01:18:24.060 --> 01:18:25.880
then this endpoint.

01:18:25.880 --> 01:18:29.560
Will be vertically aligned,
have the same y-coordinate

01:18:29.560 --> 01:18:31.880
as this endpoint.

01:18:31.880 --> 01:18:34.547
And if I do that--
and again, we've

01:18:34.547 --> 01:18:36.380
added half of the
super-long length and then

01:18:36.380 --> 01:18:37.750
the super-long length here.

01:18:37.750 --> 01:18:39.900
There's also the half
of the super-long length

01:18:39.900 --> 01:18:41.730
and the super-long length there.

01:18:41.730 --> 01:18:43.910
And now I can fold
these two folds.

01:18:43.910 --> 01:18:46.320
So when I fold one,
it's going to go here.

01:18:46.320 --> 01:18:50.710
And it won't hit anything if and
only if I solve two partition.

01:18:50.710 --> 01:18:51.210
Right?

01:18:51.210 --> 01:18:54.780
Again, this is the box that I'm
trying to fit everything into

01:18:54.780 --> 01:18:56.639
and this is the
thing that I'm trying

01:18:56.639 --> 01:18:58.930
to shift up and down to be
perfectly aligned with that.

01:18:58.930 --> 01:19:00.520
If I can perfectly
aligned it, then I

01:19:00.520 --> 01:19:05.610
fold this, miss, then fold
this and it's out again.

01:19:05.610 --> 01:19:07.570
And then I can finish
these other creases

01:19:07.570 --> 01:19:09.250
that I haven't folded yet.

01:19:09.250 --> 01:19:09.750
OK?

01:19:09.750 --> 01:19:13.115
So it's all about when do
you execute these two folds?

01:19:13.115 --> 01:19:16.380
And so I'm going to do some
of the horizontal folds

01:19:16.380 --> 01:19:17.920
so that things fit nicely.

01:19:17.920 --> 01:19:19.830
Then I'll do the
two vertical folds.

01:19:19.830 --> 01:19:21.980
Then I'll do the rest
of the horizontal folds.

01:19:21.980 --> 01:19:25.150
And that will work if and only
if two partition is solvable.

01:19:25.150 --> 01:19:27.310
Now, this may look
like a weird map,

01:19:27.310 --> 01:19:33.633
but it turns out if you have a
regular rectangular map-- this

01:19:33.633 --> 01:19:36.370
is not maybe a regular
one, but-- and you

01:19:36.370 --> 01:19:41.750
have some diagonal
folds, 45 degree, then

01:19:41.750 --> 01:19:54.610
that will basically force you
to fold something like this.

01:19:58.080 --> 01:19:59.590
Oops, I did it again.

01:20:04.000 --> 01:20:08.910
One, two, and then here.

01:20:08.910 --> 01:20:10.650
So you can put in
diagonal faults

01:20:10.650 --> 01:20:13.520
to force you to fold into
this initial structure.

01:20:13.520 --> 01:20:15.710
And then add folds
on top of that.

01:20:15.710 --> 01:20:17.811
So this is like
composing two gadgets.

01:20:17.811 --> 01:20:19.560
Then you add horizontal
and vertical folds

01:20:19.560 --> 01:20:20.960
just like that picture.

01:20:20.960 --> 01:20:22.900
And then you'll have
a rectangular map

01:20:22.900 --> 01:20:25.560
with horizontal, vertical,
and diagonal creases

01:20:25.560 --> 01:20:28.170
that you can fold all the
creases by simple folds if

01:20:28.170 --> 01:20:30.720
and only if two
partition is solvable.

01:20:30.720 --> 01:20:33.430
Open problem, is this
strongly NP-hard?

01:20:33.430 --> 01:20:34.275
We don't know.

01:20:34.275 --> 01:20:35.900
Is there a
pseudo-polynomial algorithm?

01:20:35.900 --> 01:20:38.470
Obviously we don't know.

01:20:38.470 --> 01:20:40.580
It's quite tantalizing.

01:20:40.580 --> 01:20:43.260
But this is basically why maps
don't have diagonal folds.

01:20:45.960 --> 01:20:48.630
And that's it for today.