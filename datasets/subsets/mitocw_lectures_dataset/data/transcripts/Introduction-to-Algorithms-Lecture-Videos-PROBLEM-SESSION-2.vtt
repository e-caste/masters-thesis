WEBVTT

00:00:00.500 --> 00:00:02.000
[SQUEAKING]

00:00:02.000 --> 00:00:03.500
[RUSTLING]

00:00:03.500 --> 00:00:05.500
[CLICKING]

00:00:12.443 --> 00:00:13.610
PROFESSOR: All right, folks.

00:00:13.610 --> 00:00:16.079
I think it's about
time to get started.

00:00:16.079 --> 00:00:18.270
Thank you guys for making
it to our problem session

00:00:18.270 --> 00:00:20.557
and I guess talking
to many of you guys

00:00:20.557 --> 00:00:22.640
virtually, given the number
of people in the room.

00:00:22.640 --> 00:00:24.680
But that's perfectly fine.

00:00:24.680 --> 00:00:25.180
Right.

00:00:25.180 --> 00:00:28.190
So we're in problem session
number two for 6.006.

00:00:28.190 --> 00:00:30.050
Hopefully you're all
in the right place.

00:00:30.050 --> 00:00:31.853
I'm Justin.

00:00:31.853 --> 00:00:33.770
I was looking at a little
spreadsheet of who's

00:00:33.770 --> 00:00:35.978
teaching what, and I think
you guys are stuck with me

00:00:35.978 --> 00:00:38.725
in a lot of these problem
sessions, which actually, I

00:00:38.725 --> 00:00:40.100
think in terms of
hours of video,

00:00:40.100 --> 00:00:43.430
means that you're stuck
listening to my voice the most.

00:00:43.430 --> 00:00:45.350
So sorry in advance.

00:00:45.350 --> 00:00:48.020
But in any event, it's always
fun to do this kind of thing.

00:00:48.020 --> 00:00:51.140
And it gave me the opportunity
to do homework, which I have

00:00:51.140 --> 00:00:54.230
not done in a very long time.

00:00:54.230 --> 00:00:58.040
So last night, I worked through
all these problems and came up

00:00:58.040 --> 00:01:00.247
with my own hacked-together
answers for these,

00:01:00.247 --> 00:01:02.330
which thankfully more or
less agreed with what was

00:01:02.330 --> 00:01:05.030
in the answer key, which
I have and you don't.

00:01:05.030 --> 00:01:06.960
I think that we release on--

00:01:06.960 --> 00:01:10.160
so there's a bit of
a known bug in 6.006,

00:01:10.160 --> 00:01:13.670
which is that this instructor
has horrible handwriting.

00:01:13.670 --> 00:01:14.600
I'm working on it.

00:01:14.600 --> 00:01:17.750
I went to the classroom and
practiced the other day.

00:01:17.750 --> 00:01:21.860
But in the meantime, there
are horrible handwritten notes

00:01:21.860 --> 00:01:24.440
that are posted in the
learning module, at least

00:01:24.440 --> 00:01:26.150
for the duration
of the talk today.

00:01:26.150 --> 00:01:28.067
And we'll decide whether
we want to leave them

00:01:28.067 --> 00:01:30.300
up or not because they're
not super exciting.

00:01:30.300 --> 00:01:32.675
Just so you can make sure you
can follow along with that,

00:01:32.675 --> 00:01:33.717
I'm writing on the board.

00:01:33.717 --> 00:01:36.253
And as with before, if
there's ever anything

00:01:36.253 --> 00:01:37.670
that you can't
read, just stop me.

00:01:37.670 --> 00:01:40.140
And I'll gladly fix.

00:01:40.140 --> 00:01:40.640
Cool.

00:01:40.640 --> 00:01:42.890
So right, so hopefully,
does everybody

00:01:42.890 --> 00:01:45.603
have a copy of the problems?

00:01:45.603 --> 00:01:47.270
It'll look a little
different from this.

00:01:47.270 --> 00:01:48.562
The green stuff is the answers.

00:01:48.562 --> 00:01:50.738
I get those, and you don't.

00:01:50.738 --> 00:01:53.030
Or sorry, I always ask this
question when I'm teaching,

00:01:53.030 --> 00:01:54.197
and you never get an answer.

00:01:54.197 --> 00:01:56.720
Does anybody not have a copy
of the problems and the problem

00:01:56.720 --> 00:01:58.030
session?

00:01:58.030 --> 00:01:58.700
Fabulous.

00:01:58.700 --> 00:01:59.730
OK.

00:01:59.730 --> 00:02:01.880
If you don't, there's a
pile of handouts up here.

00:02:01.880 --> 00:02:03.060
Here, I'll grab one for you.

00:02:06.560 --> 00:02:08.220
Yeah.

00:02:08.220 --> 00:02:08.720
Great.

00:02:08.720 --> 00:02:11.150
So the basic goal of
the problem sessions

00:02:11.150 --> 00:02:13.820
is to go over a bunch of example
problems, which I believe

00:02:13.820 --> 00:02:17.330
are mostly lifted from past
years' homeworks and exams,

00:02:17.330 --> 00:02:20.030
and work through how
we went about thinking

00:02:20.030 --> 00:02:23.390
about them and a solution or
at least just kind of sketch

00:02:23.390 --> 00:02:25.400
out enough that we're
confident you could fill

00:02:25.400 --> 00:02:26.817
in the blanks of
a solution, given

00:02:26.817 --> 00:02:28.010
our limited time together.

00:02:30.860 --> 00:02:31.550
Right.

00:02:31.550 --> 00:02:33.177
And of course, one
of the pleasures

00:02:33.177 --> 00:02:35.510
of teaching this problem
session is this is not normally

00:02:35.510 --> 00:02:36.468
the class that I teach.

00:02:36.468 --> 00:02:38.780
So these really are problems
I haven't seen before.

00:02:38.780 --> 00:02:39.980
And indeed, in the
middle of the night

00:02:39.980 --> 00:02:41.397
last night, I woke
up and realized

00:02:41.397 --> 00:02:44.160
my answer to the last
problem was totally wrong.

00:02:44.160 --> 00:02:46.800
So if you feel
that way sometimes,

00:02:46.800 --> 00:02:49.310
the feeling is mutual.

00:02:49.310 --> 00:02:52.970
So in any event, there are
four problems on your handout

00:02:52.970 --> 00:02:54.830
that roughly, I think,
are in correspondence

00:02:54.830 --> 00:02:57.180
with the stuff we've taught
over the last week or so.

00:02:57.180 --> 00:02:59.150
So the first problem
involves recurrences.

00:02:59.150 --> 00:03:02.390
The second involves
Infinity Stones.

00:03:02.390 --> 00:03:07.610
The third involves some kind
of a queue stack structure.

00:03:07.610 --> 00:03:10.700
And the fourth
involves all kinds

00:03:10.700 --> 00:03:14.310
of things talking to each other
in a way that I got wrong.

00:03:14.310 --> 00:03:17.150
So I guess for lack of
a more creative thing,

00:03:17.150 --> 00:03:19.165
we'll just go through
these guys in order.

00:03:19.165 --> 00:03:20.540
And essentially,
this is supposed

00:03:20.540 --> 00:03:22.940
to be an interactive session,
although it doesn't really

00:03:22.940 --> 00:03:24.570
look that way.

00:03:24.570 --> 00:03:26.490
But since you guys are
the people in the room,

00:03:26.490 --> 00:03:29.120
you have the advantage of being
able to stop me the second

00:03:29.120 --> 00:03:31.343
that I, A, make a
mistake or, B, say

00:03:31.343 --> 00:03:32.510
something that confuses you.

00:03:32.510 --> 00:03:35.010
And I'm relying on
you to do that, OK?

00:03:35.010 --> 00:03:35.510
Nods.

00:03:35.510 --> 00:03:36.893
That's our deal today.

00:03:36.893 --> 00:03:38.060
Some kind of acknowledgment.

00:03:38.060 --> 00:03:40.200
Noses out of the laptops,
maybe, for a second.

00:03:40.200 --> 00:03:40.700
Cool.

00:03:40.700 --> 00:03:41.210
Thank you.

00:03:41.210 --> 00:03:41.930
See, thumbs up.

00:03:41.930 --> 00:03:43.230
That's what I'm looking for.

00:03:43.230 --> 00:03:44.090
OK.

00:03:44.090 --> 00:03:46.160
All right, folks.

00:03:46.160 --> 00:03:48.500
Right, so let's start with
the problem number one here.

00:03:48.500 --> 00:03:50.630
So problem number one
is solving recurrences,

00:03:50.630 --> 00:03:52.490
which is our favorite
way to torture

00:03:52.490 --> 00:03:55.830
undergrads in algorithms classes
in the first couple of weeks.

00:03:55.830 --> 00:03:59.540
And in particular, applying
this master theorem.

00:03:59.540 --> 00:04:02.870
So I thought I'd spent about
82 seconds reviewing master

00:04:02.870 --> 00:04:06.680
theorem because this is sort
of the giant sledgehammer

00:04:06.680 --> 00:04:09.680
for solving recurrences
without understanding why you

00:04:09.680 --> 00:04:11.300
got the answer that you did.

00:04:11.300 --> 00:04:13.692
And then for each
of these problems,

00:04:13.692 --> 00:04:15.150
conveniently, this
homework problem

00:04:15.150 --> 00:04:19.010
asks you to do each big
O thing twice, right?

00:04:19.010 --> 00:04:21.230
Once using master theorem
to kind of get you

00:04:21.230 --> 00:04:24.045
used to just applying
this little set of rules,

00:04:24.045 --> 00:04:25.670
which is sort of the
most efficient way

00:04:25.670 --> 00:04:26.720
to solve recurrences.

00:04:26.720 --> 00:04:28.920
It just gives you a
formula to look at.

00:04:28.920 --> 00:04:32.240
In addition to that, drawing
a tree of computation

00:04:32.240 --> 00:04:34.860
and counting the number
of computations you do.

00:04:34.860 --> 00:04:38.030
So the first two are basically
straightforward applications

00:04:38.030 --> 00:04:39.440
of master theorem.

00:04:39.440 --> 00:04:41.940
The third one requires a
little bit of thinking.

00:04:41.940 --> 00:04:44.210
So naturally, I got stuck
and wasted an hour yesterday

00:04:44.210 --> 00:04:46.700
trying to convince myself
the answer was right.

00:04:46.700 --> 00:04:47.270
OK.

00:04:47.270 --> 00:04:49.970
So for a tiny bit of
review, I know that you also

00:04:49.970 --> 00:04:51.660
did this in recitation.

00:04:51.660 --> 00:04:54.230
But it can't hurt to
bring it up again.

00:04:54.230 --> 00:04:55.850
Remember that master theorem--

00:05:02.970 --> 00:05:05.470
I believe that "master" really
is just because it's general,

00:05:05.470 --> 00:05:05.690
right?

00:05:05.690 --> 00:05:07.232
There's not a guy
named Master, but I

00:05:07.232 --> 00:05:10.390
notice that it was capitalized
a lot in the course notes.

00:05:10.390 --> 00:05:12.910
But in any event,
the basic idea is

00:05:12.910 --> 00:05:14.830
that it has some
recurrence that looks

00:05:14.830 --> 00:05:22.480
like the following, which
is T of n equals aT of n/b

00:05:22.480 --> 00:05:27.370
plus f of n.

00:05:27.370 --> 00:05:31.630
So for instance, in merge
sort, for a tiny bit of review,

00:05:31.630 --> 00:05:34.040
remember that we kind of
split into two pieces.

00:05:34.040 --> 00:05:36.430
So both a and b in
merge sort would be 2.

00:05:36.430 --> 00:05:37.120
Yeah.

00:05:37.120 --> 00:05:39.490
And the amount of work
that I do in the merge step

00:05:39.490 --> 00:05:40.840
is kind of like n.

00:05:40.840 --> 00:05:43.570
So that's how to fill in these
different constants there.

00:05:43.570 --> 00:05:45.280
And the question
is, asymptotically,

00:05:45.280 --> 00:05:47.530
what does this
function look like?

00:05:47.530 --> 00:05:49.930
And of course, it's not totally
obvious from this formula

00:05:49.930 --> 00:05:52.240
because I've defined T in
terms of itself, right?

00:05:52.240 --> 00:05:55.600
And that's the sort of annoying
part of solving recurrences.

00:05:55.600 --> 00:05:58.180
And so master theorem, and
I'll let you guys review

00:05:58.180 --> 00:06:02.020
your section notes about
precisely how this gets proved,

00:06:02.020 --> 00:06:05.980
essentially divides
into three cases.

00:06:05.980 --> 00:06:08.980
And the relevant numbers
here are as follows, right?

00:06:08.980 --> 00:06:10.618
There's an a, a b, and an f.

00:06:10.618 --> 00:06:12.910
And so the a is kind of like
a branching factor, right?

00:06:12.910 --> 00:06:14.890
So if you remember
your computation tree,

00:06:14.890 --> 00:06:19.640
like in merge sort, you
split into two pieces, right?

00:06:19.640 --> 00:06:21.310
So that number is
kind of like a.

00:06:21.310 --> 00:06:24.250
It's the number of splits
that you make, right?

00:06:24.250 --> 00:06:27.700
b is the amount that your
problem size reduces when

00:06:27.700 --> 00:06:29.412
you go to each of those leaves.

00:06:29.412 --> 00:06:31.120
And then finally, f
is the amount of work

00:06:31.120 --> 00:06:32.280
that you do at each node.

00:06:32.280 --> 00:06:35.510
Yeah, so hopefully that
basic language makes sense.

00:06:35.510 --> 00:06:38.680
And then essentially what
you learn from master theorem

00:06:38.680 --> 00:06:40.460
is that there's three cases.

00:06:40.460 --> 00:06:46.012
The first is that
f of n looks like--

00:06:46.012 --> 00:06:48.220
by the way, in the recitation
notes, for some reason,

00:06:48.220 --> 00:06:49.470
it's kind of written backward.

00:06:49.470 --> 00:06:52.060
They give the answer to master
theorem and then the condition.

00:06:52.060 --> 00:06:54.480
I'm going to write
in the other order.

00:06:54.480 --> 00:06:54.980
Right.

00:06:54.980 --> 00:06:58.090
Looks like the following,
which is n to the log

00:06:58.090 --> 00:07:06.958
base b of a minus epsilon
for some positive epsilon.

00:07:06.958 --> 00:07:09.250
I'm going to try to be very
conscientious about reading

00:07:09.250 --> 00:07:12.620
my writing out loud
as I write it down.

00:07:12.620 --> 00:07:13.120
All right.

00:07:13.120 --> 00:07:15.338
And in that case,
what we find is notice

00:07:15.338 --> 00:07:16.880
there's something
kind of magic here,

00:07:16.880 --> 00:07:18.730
which is that this is
just an upper bound.

00:07:18.730 --> 00:07:20.450
There's not a theta here.

00:07:20.450 --> 00:07:23.920
So it's OK if f is
below this thing.

00:07:23.920 --> 00:07:29.290
But in any event, the
conclusion then is that T of n

00:07:29.290 --> 00:07:36.443
is big theta of n to
the log base b of a.

00:07:36.443 --> 00:07:38.110
It's kind of cool if
you think about it.

00:07:38.110 --> 00:07:39.568
You only have an
upper bound for f,

00:07:39.568 --> 00:07:43.013
but you get a nice theta bound
for T, which is pretty cool.

00:07:43.013 --> 00:07:44.680
The reason for that
is essentially the f

00:07:44.680 --> 00:07:46.570
is sort of insignificant
relative to the work

00:07:46.570 --> 00:07:49.980
of just traversing
up and down the tree.

00:07:49.980 --> 00:07:51.990
That's case one.

00:07:51.990 --> 00:07:55.710
Case two-- I'm going to try and
leave this on the board as we

00:07:55.710 --> 00:07:57.360
actually solve these problems--

00:07:57.360 --> 00:07:59.950
is the following,
which is f of n

00:07:59.950 --> 00:08:04.920
is big theta of
n to the log base

00:08:04.920 --> 00:08:13.020
b of a multiplied by log
to the k-th power of n.

00:08:13.020 --> 00:08:16.140
This is a super weird
form, but for example, it's

00:08:16.140 --> 00:08:18.640
perfectly kosher to take
k equals 0, in which case

00:08:18.640 --> 00:08:21.210
it starts to look
like case one, right?

00:08:21.210 --> 00:08:27.450
For some positive k or
non-negative k, rather,

00:08:27.450 --> 00:08:32.100
in which case what we
learn is that T of n

00:08:32.100 --> 00:08:43.919
is theta of n to the log base
b of a times log to the k

00:08:43.919 --> 00:08:47.405
plus 1 of n.

00:08:47.405 --> 00:08:49.530
You can see why we don't
love applying this theorem

00:08:49.530 --> 00:08:50.947
in this course
because I feel just

00:08:50.947 --> 00:08:53.460
staring at these formulas
is totally unenlightening.

00:08:53.460 --> 00:08:55.860
But it is a giant sledgehammer
for solving recurrences

00:08:55.860 --> 00:08:57.090
quickly.

00:08:57.090 --> 00:09:00.733
And then finally, case three--

00:09:00.733 --> 00:09:02.400
I'm going to slide
the board up, and I'm

00:09:02.400 --> 00:09:03.942
going to slide it
back down because I

00:09:03.942 --> 00:09:05.220
don't want to bend over.

00:09:05.220 --> 00:09:12.690
OK-- is the following, which
is f of n is omega, right,

00:09:12.690 --> 00:09:18.270
meaning that it's lower
bounded by n to the log base

00:09:18.270 --> 00:09:28.380
b of a plus epsilon for
some epsilon greater than 0.

00:09:28.380 --> 00:09:30.375
And we needed a second case.

00:09:33.540 --> 00:09:41.550
What's it called? af of
n over b is less than cfn

00:09:41.550 --> 00:09:45.900
for some c between 0 and 1.

00:09:49.510 --> 00:09:51.010
And what's the conclusion there?

00:09:51.010 --> 00:09:53.670
Then it turns out that the
f term sort of dominates,

00:09:53.670 --> 00:09:59.610
and what we get is that T
of n is theta of f of n.

00:10:03.750 --> 00:10:04.860
OK.

00:10:04.860 --> 00:10:08.280
So essentially, this
covers three major cases

00:10:08.280 --> 00:10:09.570
that you see in recurrences.

00:10:09.570 --> 00:10:13.005
There are other more generic
versions of the master theorem

00:10:13.005 --> 00:10:14.880
out there where essentially,
rather than just

00:10:14.880 --> 00:10:18.210
having one term with the T in
it, maybe use more than one

00:10:18.210 --> 00:10:19.380
term with a T in it.

00:10:19.380 --> 00:10:21.510
I don't think those are
covered in this class.

00:10:21.510 --> 00:10:23.850
I always confuse the name
of the more general one.

00:10:23.850 --> 00:10:25.230
I want to say it's
Arzela-Ascoli,

00:10:25.230 --> 00:10:27.230
but I know that that's
from functional analysis.

00:10:27.230 --> 00:10:31.103
[INAUDIBLE] theorem, if you
want to Google that, learn more.

00:10:31.103 --> 00:10:33.270
But in any event, that's
going to be enough for most

00:10:33.270 --> 00:10:36.810
of the recurrences
we care about in 006.

00:10:36.810 --> 00:10:38.685
So I've at least written
our conditions down.

00:10:38.685 --> 00:10:40.768
And now they're going to
sit on the left-hand side

00:10:40.768 --> 00:10:42.540
while we do three
example problems to show

00:10:42.540 --> 00:10:43.990
how they show up in practice.

00:10:43.990 --> 00:10:46.770
Are there any questions about
what this theorem is telling us

00:10:46.770 --> 00:10:48.180
about life or how to apply it?

00:10:50.833 --> 00:10:52.000
Don't all speak at once now.

00:10:52.000 --> 00:10:52.450
Yes.

00:10:52.450 --> 00:10:53.770
AUDIENCE: Sorry, I have
a handwriting question.

00:10:53.770 --> 00:10:54.687
PROFESSOR: No problem.

00:10:54.687 --> 00:10:57.100
AUDIENCE: What's after
"some," the last line?

00:10:57.100 --> 00:11:02.260
PROFESSOR: Oh, for some
c in 0, 1, not inclusive.

00:11:02.260 --> 00:11:04.060
Fabulous question.

00:11:04.060 --> 00:11:04.690
Any others?

00:11:07.370 --> 00:11:08.000
OK.

00:11:08.000 --> 00:11:11.430
So let's do an
example problem here.

00:11:11.430 --> 00:11:13.910
So let's do part a.

00:11:13.910 --> 00:11:15.780
So in part a, they
give you a recurrence,

00:11:15.780 --> 00:11:17.950
which isn't all that
different from merge

00:11:17.950 --> 00:11:19.320
sort or any of the other ones.

00:11:19.320 --> 00:11:20.720
It looks something like this.

00:11:20.720 --> 00:11:29.218
T of n is equal to
2T of n/2 plus--

00:11:29.218 --> 00:11:31.760
and then they have some other
term, which they don't tell you

00:11:31.760 --> 00:11:37.367
anything about beyond that
it's big O of square root of n.

00:11:37.367 --> 00:11:39.200
By the way, this might
mean that it actually

00:11:39.200 --> 00:11:40.670
does order 1 work, right?

00:11:40.670 --> 00:11:42.920
It just has to be upper
bounded by a square root of n.

00:11:42.920 --> 00:11:44.960
That's the only thing that
problem's telling you.

00:11:44.960 --> 00:11:46.190
I'm going to keep
kind of driving home

00:11:46.190 --> 00:11:48.705
that point because I think
everybody, including myself,

00:11:48.705 --> 00:11:50.580
gets really sloppy about,
like, when is it O?

00:11:50.580 --> 00:11:51.320
When is it theta?

00:11:51.320 --> 00:11:52.208
When's it omega?

00:11:52.208 --> 00:11:54.500
And so every single time you
write one of those letters

00:11:54.500 --> 00:11:56.838
down, you should step back
50 feet and look at it

00:11:56.838 --> 00:11:58.380
and think, like,
did I do that right?

00:11:58.380 --> 00:12:00.410
Or did I just write a
Greek letter, right?

00:12:00.410 --> 00:12:02.060
And make sure that
you're actually

00:12:02.060 --> 00:12:04.610
thinking through it logically.

00:12:04.610 --> 00:12:05.390
OK.

00:12:05.390 --> 00:12:11.240
So when I apply master theorem
in my everyday life, what

00:12:11.240 --> 00:12:13.490
I like to do is to
say, OK, somehow,

00:12:13.490 --> 00:12:16.490
the really key quantity
in master theorem

00:12:16.490 --> 00:12:20.780
is this dude, right, n
to the log base b of a.

00:12:20.780 --> 00:12:23.700
He just keeps showing up in
all these different cases.

00:12:23.700 --> 00:12:28.250
So I might as well figure what
that is for my recurrence,

00:12:28.250 --> 00:12:31.750
yeah, and then plug it in
and check which case I'm in.

00:12:31.750 --> 00:12:33.360
Does that make sense?

00:12:33.360 --> 00:12:35.310
So let's do that.

00:12:35.310 --> 00:12:40.160
So first of all, what is a for
this particular recurrence?

00:12:40.160 --> 00:12:40.668
AUDIENCE: 2.

00:12:40.668 --> 00:12:41.210
PROFESSOR: 2.

00:12:43.760 --> 00:12:46.060
What's b?

00:12:46.060 --> 00:12:47.060
You're killing me, guys.

00:12:47.060 --> 00:12:47.560
On 3.

00:12:47.560 --> 00:12:48.560
1, 2, 3.

00:12:48.560 --> 00:12:49.430
AUDIENCE: 2.

00:12:49.430 --> 00:12:51.020
PROFESSOR: OK.

00:12:51.020 --> 00:12:53.180
The enthusiasm is overwhelming.

00:12:53.180 --> 00:12:55.190
OK, and what do we know
about the function f?

00:12:55.190 --> 00:12:56.660
AUDIENCE: [INAUDIBLE]

00:12:56.660 --> 00:12:58.430
PROFESSOR: Yeah,
it's big O of root n.

00:12:58.430 --> 00:13:00.020
We don't know that
it equals root n.

00:13:00.020 --> 00:13:02.538
But we do know that it's at
most upper bounded by something

00:13:02.538 --> 00:13:03.830
that kind of looks like root n.

00:13:07.380 --> 00:13:09.130
Eric gave me a whole
lesson on this chalk,

00:13:09.130 --> 00:13:10.730
and I'm still failing at it.

00:13:10.730 --> 00:13:11.230
OK.

00:13:11.230 --> 00:13:15.475
So now that gives us
everything we need to compute n

00:13:15.475 --> 00:13:16.745
to the log base b of a.

00:13:16.745 --> 00:13:18.370
We're going to do
this one real slowly,

00:13:18.370 --> 00:13:20.912
and then we're going to do the
next one a little more fastly,

00:13:20.912 --> 00:13:22.540
quickly.

00:13:22.540 --> 00:13:26.740
So n to the log base b of a.

00:13:26.740 --> 00:13:34.355
Well, that's n to
the log base 2 of 2.

00:13:34.355 --> 00:13:35.230
Anybody have an idea?

00:13:35.230 --> 00:13:38.158
What's the log base 2 of 2?

00:13:38.158 --> 00:13:39.878
AUDIENCE: 1.

00:13:39.878 --> 00:13:40.420
PROFESSOR: 1.

00:13:40.420 --> 00:13:41.920
OK, I'll take it this time.

00:13:41.920 --> 00:13:43.320
OK.

00:13:43.320 --> 00:13:43.820
Right.

00:13:43.820 --> 00:13:47.320
And so then what does
master theorem tell you?

00:13:47.320 --> 00:13:49.060
Well, in some sense,
I want to know

00:13:49.060 --> 00:13:52.660
what f is, which in this case
looks like square root of n,

00:13:52.660 --> 00:13:56.140
compared to what this
is, n to the first.

00:13:56.140 --> 00:13:57.010
Yeah?

00:13:57.010 --> 00:14:02.140
Now, first of all, which of
these two things grows faster?

00:14:02.140 --> 00:14:03.430
This guy, right?

00:14:03.430 --> 00:14:07.960
So what we know is that f is
really upper bounded by this n

00:14:07.960 --> 00:14:08.590
here.

00:14:08.590 --> 00:14:09.910
"Upper bounded" is not
quite the right term

00:14:09.910 --> 00:14:11.660
because big O allows
for some wiggle room,

00:14:11.660 --> 00:14:12.640
but asymptotically.

00:14:12.640 --> 00:14:14.740
Hopefully you guys
get this concept.

00:14:14.740 --> 00:14:19.750
OK, so in particular, let's see.

00:14:19.750 --> 00:14:21.547
So remember that f of--

00:14:21.547 --> 00:14:22.880
let's maybe just write it again.

00:14:22.880 --> 00:14:26.860
So f of n is big O
of square root of n.

00:14:26.860 --> 00:14:32.050
But let's write that in a
suggestive way as n to the 1/2.

00:14:32.050 --> 00:14:33.220
Yeah.

00:14:33.220 --> 00:14:38.740
In particular, this is equal to
big O of n to the 1 minus 1/2.

00:14:38.740 --> 00:14:42.590
It's the beautiful
thing about 1/2.

00:14:42.590 --> 00:14:43.090
Yeah.

00:14:43.090 --> 00:14:45.490
But what is n to the 1?

00:14:45.490 --> 00:14:48.410
Well, that's n to the
log base b of a, right?

00:14:48.410 --> 00:14:51.910
That's what we just
showed here, right?

00:14:51.910 --> 00:14:57.970
So this is really
O of n to the log b

00:14:57.970 --> 00:15:01.180
of a-- that's a complicated
way of writing the number 1,

00:15:01.180 --> 00:15:02.260
right--

00:15:02.260 --> 00:15:03.380
minus 1/2.

00:15:03.380 --> 00:15:05.630
Let's give 1/2 a special
name, too, while we're at it.

00:15:05.630 --> 00:15:09.370
Let's call him
epsilon or her, yeah,

00:15:09.370 --> 00:15:14.730
where we take epsilon equals--

00:15:14.730 --> 00:15:17.540
see what I did there?

00:15:17.540 --> 00:15:19.510
Now, what does it tell me?

00:15:19.510 --> 00:15:21.597
There are three different
cases of master theorem.

00:15:21.597 --> 00:15:23.180
And take a look at
what I just showed.

00:15:23.180 --> 00:15:26.290
I showed that f of n is equal
to big O of n to the log base

00:15:26.290 --> 00:15:31.270
b of a minus epsilon for some
epsilon that's equal to 1/2.

00:15:31.270 --> 00:15:35.030
The beautiful thing about 1/2
is that it is greater than 0.

00:15:35.030 --> 00:15:35.920
Yeah.

00:15:35.920 --> 00:15:40.000
So I think we have somewhat
laboriously checked

00:15:40.000 --> 00:15:41.480
that we are in case one.

00:15:41.480 --> 00:15:43.930
Any dissidents here?

00:15:43.930 --> 00:15:44.780
Fabulous.

00:15:44.780 --> 00:15:45.280
OK.

00:15:45.280 --> 00:15:48.040
So in that case, master
theorem, basically,

00:15:48.040 --> 00:15:49.120
you're just done, right?

00:15:49.120 --> 00:15:50.660
So what is the conclusion?

00:15:50.660 --> 00:15:52.648
AUDIENCE: T of n is theta of n.

00:15:52.648 --> 00:15:53.440
PROFESSOR: Exactly.

00:15:53.440 --> 00:15:56.320
So T of n is theta of n
to the log base b of a.

00:15:56.320 --> 00:16:00.040
But we already showed
that's equal to n.

00:16:00.040 --> 00:16:02.870
So we're done.

00:16:02.870 --> 00:16:03.370
All right.

00:16:03.370 --> 00:16:08.170
Any questions about how we
apply master theorem here?

00:16:08.170 --> 00:16:08.720
OK.

00:16:08.720 --> 00:16:10.907
So now here's the thing
about master theorem.

00:16:10.907 --> 00:16:13.240
Did we learn anything about
what this recursive function

00:16:13.240 --> 00:16:14.095
is doing?

00:16:14.095 --> 00:16:16.720
No, we just did a bunch of work,
plugged in some Greek symbols,

00:16:16.720 --> 00:16:18.510
and out came a big theta.

00:16:18.510 --> 00:16:20.110
Yeah.

00:16:20.110 --> 00:16:23.140
So what we might
want to do instead

00:16:23.140 --> 00:16:27.040
is to use a method that
I'm still learning myself

00:16:27.040 --> 00:16:29.020
because I'm not used to
presenting it this way,

00:16:29.020 --> 00:16:31.660
but that's OK, which
is to actually draw out

00:16:31.660 --> 00:16:33.030
the tree of computation.

00:16:33.030 --> 00:16:34.097
Yeah.

00:16:34.097 --> 00:16:35.180
So let's actually do that.

00:16:35.180 --> 00:16:39.100
So let's say that I
call my function T of n.

00:16:39.100 --> 00:16:40.083
So what does T of n do?

00:16:40.083 --> 00:16:42.250
Well, in some sense, it
does work that kind of looks

00:16:42.250 --> 00:16:44.380
like the square
root of n, right,

00:16:44.380 --> 00:16:48.490
and then it makes two
function calls, each of which

00:16:48.490 --> 00:16:50.860
has n/2 amount of data.

00:16:50.860 --> 00:16:51.550
Yeah.

00:16:51.550 --> 00:16:53.030
So let's draw what
this looks like.

00:16:53.030 --> 00:16:55.810
So the first thing that
my function might do

00:16:55.810 --> 00:16:59.320
is work square root of n much.

00:16:59.320 --> 00:17:01.540
Going to put a little
square root of n there.

00:17:01.540 --> 00:17:04.599
And now it makes
two function calls.

00:17:04.599 --> 00:17:06.480
And how much work does
each of these guys do?

00:17:09.300 --> 00:17:14.819
So when it calls T,
what goes into T?

00:17:14.819 --> 00:17:15.329
n/2.

00:17:15.329 --> 00:17:16.950
AUDIENCE: So square root of n/2.

00:17:16.950 --> 00:17:17.760
PROFESSOR: Exactly.

00:17:17.760 --> 00:17:22.470
So it does square root
of n/2 amount of work

00:17:22.470 --> 00:17:26.033
at each of these two nodes.

00:17:26.033 --> 00:17:26.700
That make sense?

00:17:29.912 --> 00:17:32.370
AUDIENCE: That's determined by
the branching number, right?

00:17:32.370 --> 00:17:33.280
PROFESSOR: You
have to be careful.

00:17:33.280 --> 00:17:34.720
So the branching
number, in this case,

00:17:34.720 --> 00:17:35.845
it happened to be the same.

00:17:35.845 --> 00:17:37.920
The next problem we do,
they'll be different.

00:17:37.920 --> 00:17:39.330
So they're both 2 here.

00:17:39.330 --> 00:17:42.390
The outside 2 refers to the
fact that there's two children.

00:17:42.390 --> 00:17:42.690
AUDIENCE: Yeah, never mind.

00:17:42.690 --> 00:17:44.460
PROFESSOR: And inside
2 refers to the fact

00:17:44.460 --> 00:17:45.357
that I divided by 2.

00:17:45.357 --> 00:17:47.940
It's a fabulous question because
it's exactly what I got wrong

00:17:47.940 --> 00:17:49.600
when I did this problem.

00:17:49.600 --> 00:17:50.550
OK.

00:17:50.550 --> 00:17:55.100
So now each of these guys
calls one of their children.

00:17:55.100 --> 00:17:55.600
Yeah.

00:17:55.600 --> 00:17:58.920
And so again, the
data divides by 2.

00:17:58.920 --> 00:18:08.070
So now I have the square
root of n/4, like this.

00:18:08.070 --> 00:18:08.570
Yeah.

00:18:13.002 --> 00:18:15.210
If you're wondering, inside
of each of these circles,

00:18:15.210 --> 00:18:16.320
it says square root of n/4.

00:18:16.320 --> 00:18:16.820
OK.

00:18:21.960 --> 00:18:24.380
So let's say that--

00:18:24.380 --> 00:18:27.750
so now meanwhile, in our
function call tree here,

00:18:27.750 --> 00:18:31.710
how many nodes are in just the
first level at the very top?

00:18:31.710 --> 00:18:32.670
One, right?

00:18:32.670 --> 00:18:33.630
Just this dude.

00:18:33.630 --> 00:18:34.860
Yeah.

00:18:34.860 --> 00:18:36.630
One node.

00:18:39.590 --> 00:18:42.600
How many nodes are
in the second level?

00:18:42.600 --> 00:18:44.220
Two.

00:18:44.220 --> 00:18:49.710
Or if we want, 2 to the 1 nodes.

00:18:49.710 --> 00:18:57.040
Here, there's four, yeah, which
is 2 squared nodes, and so on.

00:18:57.040 --> 00:18:57.540
OK.

00:18:57.540 --> 00:19:00.180
So now we have some
pictorial representation

00:19:00.180 --> 00:19:03.327
of what's going on
inside of our recurrence.

00:19:03.327 --> 00:19:05.160
If you look at the
course notes I wrote out,

00:19:05.160 --> 00:19:09.308
I wrote out one more layer
just for fun and profit.

00:19:09.308 --> 00:19:11.100
So now let's see how
this helps us actually

00:19:11.100 --> 00:19:12.900
solve our recurrence.

00:19:12.900 --> 00:19:16.620
So what do we know?

00:19:16.620 --> 00:19:18.090
How many levels
are in this tree?

00:19:18.090 --> 00:19:20.490
Well, our algorithm kind of
stops when the input to T

00:19:20.490 --> 00:19:23.220
looks like 1, right?

00:19:23.220 --> 00:19:28.350
So since this divides
by 2 each time,

00:19:28.350 --> 00:19:35.920
the tree has log base 2
of n levels in the tree.

00:19:35.920 --> 00:19:37.200
Yeah.

00:19:37.200 --> 00:19:40.410
And each level
does how much work?

00:19:43.770 --> 00:19:44.490
So be careful.

00:19:44.490 --> 00:19:51.660
So each level-- let's
call that level l, right?

00:19:51.660 --> 00:19:59.063
So we'll say l equals 0,
l equals 1, and so on.

00:19:59.063 --> 00:20:00.480
So there's two
different things we

00:20:00.480 --> 00:20:01.938
have to account
for when we account

00:20:01.938 --> 00:20:03.240
for the work in this level.

00:20:03.240 --> 00:20:05.623
One is the square root
of n/2 in a single node.

00:20:05.623 --> 00:20:08.040
And the other is the fact that
there's two different nodes

00:20:08.040 --> 00:20:09.490
in the level.

00:20:09.490 --> 00:20:15.660
So in level l, so the
amount of work in level

00:20:15.660 --> 00:20:17.770
l is equal to the product
of those two things.

00:20:17.770 --> 00:20:20.470
So how many nodes
are in level l?

00:20:20.470 --> 00:20:22.330
2 to the l, yeah?

00:20:22.330 --> 00:20:22.830
OK.

00:20:25.470 --> 00:20:30.210
And how much work does
each one of those nodes do?

00:20:30.210 --> 00:20:34.008
It's like n/2 to the l.

00:20:34.008 --> 00:20:36.930
So a different way
of writing that

00:20:36.930 --> 00:20:42.270
is the square root of n times
2 to the minus l, like that.

00:20:42.270 --> 00:20:44.950
This is just n/2 to the l.

00:20:44.950 --> 00:20:45.450
Fabulous.

00:20:45.450 --> 00:20:47.970
So now we have everything
we need to actually work out

00:20:47.970 --> 00:20:50.200
our solution to the recurrence.

00:20:50.200 --> 00:20:50.700
OK.

00:20:50.700 --> 00:20:51.520
Yes?

00:20:51.520 --> 00:20:53.250
AUDIENCE: What does that say?

00:20:53.250 --> 00:20:58.050
PROFESSOR: This is n
times 2 to the minus l.

00:20:58.050 --> 00:20:59.370
I appreciate the [INAUDIBLE].

00:20:59.370 --> 00:21:03.097
I'm going to work on this more.

00:21:03.097 --> 00:21:04.680
And that's why I
also share it online.

00:21:04.680 --> 00:21:05.820
The handwritten notes is--

00:21:05.820 --> 00:21:07.320
this is literally
a scan of the page

00:21:07.320 --> 00:21:09.060
that I'm holding in front of me.

00:21:09.060 --> 00:21:10.560
OK.

00:21:10.560 --> 00:21:14.520
So if we want the total
amount of work in our tree,

00:21:14.520 --> 00:21:17.280
right, if we want to account
for all of T of n, then what

00:21:17.280 --> 00:21:18.280
are we going to do?

00:21:18.280 --> 00:21:22.140
Well, we have to sum
starting at level 0.

00:21:22.140 --> 00:21:25.260
I'm using l instead of i
because I'm an analysis person,

00:21:25.260 --> 00:21:26.760
and i is the square
root of minus 1.

00:21:26.760 --> 00:21:28.840
And I don't like i's
in my algorithms.

00:21:28.840 --> 00:21:32.430
But in any event, how many total
levels are there in my tree?

00:21:32.430 --> 00:21:38.810
Well, we know that there's
log base 2 of n, right?

00:21:38.810 --> 00:21:42.270
And now we have to sum this
quantity for all those levels.

00:21:42.270 --> 00:21:48.810
2 to the l, the square root
of n times 2 to the minus l,

00:21:48.810 --> 00:21:50.630
like that.

00:21:50.630 --> 00:21:51.130
OK.

00:21:51.130 --> 00:21:53.970
And then what do we know
secretly from the master

00:21:53.970 --> 00:21:55.920
theorem is that we're
suspecting that this is

00:21:55.920 --> 00:21:57.170
going to be theta of n, right?

00:21:57.170 --> 00:21:58.590
So that's all
we've got to check.

00:21:58.590 --> 00:22:02.230
OK, so let's do that real fast.

00:22:02.230 --> 00:22:05.790
So first of all,
notice that this n term

00:22:05.790 --> 00:22:07.600
doesn't depend on the summand.

00:22:07.600 --> 00:22:09.690
So I can just pull
them out, right?

00:22:09.690 --> 00:22:15.240
So this is really the square
root of n times the sum over l

00:22:15.240 --> 00:22:22.425
equals 0 to the
log 2 of n of what?

00:22:25.580 --> 00:22:28.300
Oh, and there's a
mistake in my notes.

00:22:28.300 --> 00:22:28.800
Oh, man.

00:22:32.940 --> 00:22:34.280
Oh, no, this is--

00:22:34.280 --> 00:22:35.667
AUDIENCE: [INAUDIBLE]

00:22:35.667 --> 00:22:36.750
PROFESSOR: Oh, right, duh.

00:22:36.750 --> 00:22:37.050
OK.

00:22:37.050 --> 00:22:39.342
So you have 2 to the l, and
you have a square root of 2

00:22:39.342 --> 00:22:41.430
to the minus l.

00:22:41.430 --> 00:22:45.340
So this is really
2 to the minus l/2.

00:22:45.340 --> 00:22:47.730
So you have l minus l/2.

00:22:47.730 --> 00:22:52.486
And this quantity is really
2 to the l/2, like that.

00:22:52.486 --> 00:22:53.880
Does that make sense?

00:22:53.880 --> 00:22:56.790
So this is just properties
of exponents from high school

00:22:56.790 --> 00:22:58.210
class.

00:22:58.210 --> 00:23:01.680
And in fact, I don't like
this because it's l/2,

00:23:01.680 --> 00:23:03.240
and I want to blindly
apply a formula

00:23:03.240 --> 00:23:04.800
without thinking about it.

00:23:04.800 --> 00:23:07.860
And so of course, this
is really the same

00:23:07.860 --> 00:23:13.915
as the square root of
2 to the l-th power.

00:23:13.915 --> 00:23:16.020
This is just properties
of exponents.

00:23:16.020 --> 00:23:16.950
OK.

00:23:16.950 --> 00:23:19.043
So what is this sum called?

00:23:19.043 --> 00:23:19.960
Do you recognize this?

00:23:19.960 --> 00:23:21.210
So there's some constant here.

00:23:21.210 --> 00:23:22.668
You're taking it
to the l-th power,

00:23:22.668 --> 00:23:25.200
and then you're
summing it over l's.

00:23:25.200 --> 00:23:27.840
This is called a
geometric series, right?

00:23:27.840 --> 00:23:30.450
So it would be like 1
plus x plus x squared

00:23:30.450 --> 00:23:32.670
plus x to the third
and dot dot dot, x

00:23:32.670 --> 00:23:35.440
to the, I guess in this
case, log base 2 of n.

00:23:35.440 --> 00:23:36.630
Yeah?

00:23:36.630 --> 00:23:39.420
So conveniently, there's a
geometrics series formula

00:23:39.420 --> 00:23:41.220
out there.

00:23:41.220 --> 00:23:43.188
I wrote it down in
the handwritten notes,

00:23:43.188 --> 00:23:45.480
but maybe for now, because
I'm moving slowly as always,

00:23:45.480 --> 00:23:47.100
so we'll skip that part.

00:23:47.100 --> 00:23:51.810
And what you could
is as follows,

00:23:51.810 --> 00:23:53.820
that this is the square
root of n, right--

00:23:53.820 --> 00:23:55.320
that's just this outer part--

00:23:55.320 --> 00:24:00.720
times-- and the inside are going
to get the square root of 2

00:24:00.720 --> 00:24:11.250
to the log base 2
of n plus 1 minus 1

00:24:11.250 --> 00:24:15.720
divided by the square
root of 2 minus 1.

00:24:15.720 --> 00:24:18.602
And this is the
geometric series formula.

00:24:18.602 --> 00:24:21.060
So I encourage you guys to go
back home and Google that one

00:24:21.060 --> 00:24:21.643
if you forgot.

00:24:21.643 --> 00:24:22.200
Yes.

00:24:22.200 --> 00:24:24.030
AUDIENCE: Wait, why
are we calculating

00:24:24.030 --> 00:24:24.947
the sum of the series?

00:24:24.947 --> 00:24:26.447
PROFESSOR: Because
what we're trying

00:24:26.447 --> 00:24:29.260
to do is figure out the total
amount of work in this tree,

00:24:29.260 --> 00:24:30.330
right?

00:24:30.330 --> 00:24:32.310
So what we've done
so far, we know

00:24:32.310 --> 00:24:35.230
that a single level in
this tree is this value.

00:24:35.230 --> 00:24:37.410
And now we have to sum
over all the levels from 0

00:24:37.410 --> 00:24:39.060
to log base 2 of n.

00:24:39.060 --> 00:24:41.340
AUDIENCE: OK, and what do
we use this number for?

00:24:41.340 --> 00:24:43.632
PROFESSOR: Because we're
trying to actually approximate

00:24:43.632 --> 00:24:45.390
or at least bound T of n, right?

00:24:45.390 --> 00:24:47.990
And T of n is the sum
of all these values.

00:24:47.990 --> 00:24:48.850
AUDIENCE: Oh, OK.

00:24:48.850 --> 00:24:50.760
And theta of n is not
a sufficient bound.

00:24:50.760 --> 00:24:52.260
PROFESSOR: It is a
sufficient bound.

00:24:52.260 --> 00:24:54.273
We just got it from
kind of a boring way.

00:24:54.273 --> 00:24:55.690
This is a second
way that we could

00:24:55.690 --> 00:24:56.800
have proved the same formula.

00:24:56.800 --> 00:24:57.250
AUDIENCE: Oh, OK.

00:24:57.250 --> 00:24:58.020
PROFESSOR: Yeah.

00:24:58.020 --> 00:24:59.940
I see a question over here.

00:24:59.940 --> 00:25:02.672
AUDIENCE: Can you go over
the root n, 2 minus l part?

00:25:02.672 --> 00:25:04.380
I understand the 2 to
the l is the number

00:25:04.380 --> 00:25:06.340
of nodes second part.

00:25:06.340 --> 00:25:07.170
Does that work?

00:25:07.170 --> 00:25:08.790
PROFESSOR: Oh.

00:25:08.790 --> 00:25:10.930
OK, this is the number of nodes.

00:25:10.930 --> 00:25:12.780
This is the quantity
inside of the circle.

00:25:12.780 --> 00:25:14.520
So notice that it's
square root of n

00:25:14.520 --> 00:25:17.130
and then square root of n/2
and then square root of n/4

00:25:17.130 --> 00:25:19.500
and then square
root of n/8, right?

00:25:19.500 --> 00:25:25.140
So 2 to the minus l here is like
1/2 and then 1/4 and then 1/8.

00:25:25.140 --> 00:25:26.490
Yeah.

00:25:26.490 --> 00:25:26.990
Fabulous.

00:25:26.990 --> 00:25:27.823
Any other questions?

00:25:27.823 --> 00:25:28.350
Yes.

00:25:28.350 --> 00:25:30.470
AUDIENCE: So if we
have log base 2n levels

00:25:30.470 --> 00:25:33.410
and we started indexing
at 0, doesn't it

00:25:33.410 --> 00:25:36.710
go from l equals 0 to
l equals 2n minus 1?

00:25:36.710 --> 00:25:37.820
PROFESSOR: Oh, boy.

00:25:37.820 --> 00:25:38.970
I'm bad at this stuff.

00:25:41.580 --> 00:25:42.210
No, right?

00:25:42.210 --> 00:25:45.730
I think this is correct.

00:25:45.730 --> 00:25:46.230
Let's see.

00:25:46.230 --> 00:25:51.660
So let's say that I
have n equals 2, right?

00:25:51.660 --> 00:25:52.830
Then what's going to happen?

00:25:55.407 --> 00:25:56.490
Yeah, no, this is correct.

00:25:56.490 --> 00:26:00.130
So as a sanity check,
think about n equals 2.

00:26:00.130 --> 00:26:01.570
So how many levels should it be?

00:26:01.570 --> 00:26:04.100
It should go from l equals
0 and then l equals 1.

00:26:04.100 --> 00:26:06.730
Then I'm done because I have T.

00:26:06.730 --> 00:26:09.160
And then I think--

00:26:09.160 --> 00:26:12.430
yeah, so the log
base 2 of 2 is 1.

00:26:12.430 --> 00:26:15.670
So yeah, this
formula checks out.

00:26:15.670 --> 00:26:18.500
OK, any other questions?

00:26:18.500 --> 00:26:19.750
These are all great questions.

00:26:19.750 --> 00:26:22.210
You guys are keeping me honest.

00:26:22.210 --> 00:26:23.650
OK.

00:26:23.650 --> 00:26:26.810
So we have this giant
ugly expression here.

00:26:26.810 --> 00:26:29.110
And so our final job here
is just to simplify it.

00:26:29.110 --> 00:26:29.933
That's it.

00:26:29.933 --> 00:26:32.350
And then what we're going to
find is that this is secretly

00:26:32.350 --> 00:26:33.770
just theta of n.

00:26:33.770 --> 00:26:37.760
A little surprising, given
that this is kind of ugly.

00:26:37.760 --> 00:26:38.627
OK.

00:26:38.627 --> 00:26:40.460
And by the way, this
was just the constants.

00:26:40.460 --> 00:26:42.043
So this term on the
denominator is not

00:26:42.043 --> 00:26:45.590
going to end up mattering for
our asymptotic calculation.

00:26:45.590 --> 00:26:46.090
OK.

00:26:49.400 --> 00:26:49.900
Cool.

00:26:49.900 --> 00:26:51.260
So let's see here.

00:26:51.260 --> 00:26:55.690
So remember that the square
root of 2 is 2 to the 1/2.

00:26:55.690 --> 00:26:56.190
Yeah.

00:26:56.190 --> 00:26:58.482
So I can do a little bit of
reshuffling on our formula.

00:26:58.482 --> 00:27:01.600
And what I'm going to find
is that this is exactly

00:27:01.600 --> 00:27:05.830
the square root of n times
1 over the square root

00:27:05.830 --> 00:27:07.270
of 2 minus 1.

00:27:07.270 --> 00:27:08.870
That's just this constant here.

00:27:08.870 --> 00:27:12.380
Now I just have to cope with
this funny term inside of here.

00:27:12.380 --> 00:27:13.630
I'm going to do the following.

00:27:13.630 --> 00:27:17.110
I'm going to say, well, square
root of 2 is the same as 2

00:27:17.110 --> 00:27:18.400
to the 1/2.

00:27:18.400 --> 00:27:22.340
So I'm going to write this by
moving that 1/2 upstairs here,

00:27:22.340 --> 00:27:22.840
right?

00:27:22.840 --> 00:27:25.690
So what am I going to get at
the end of the day is that this

00:27:25.690 --> 00:27:36.400
is the same as 2 to the log base
2 of n plus 1 and all of that--

00:27:36.400 --> 00:27:39.195
oops, plus 1/2, right, because
there's the 1/2 exponent that

00:27:39.195 --> 00:27:41.140
got multiplied by the 1--

00:27:41.140 --> 00:27:42.850
minus 1.

00:27:42.850 --> 00:27:45.290
So this is just an identical
expression to this one.

00:27:45.290 --> 00:27:46.915
All I've done is move
the 1/2 upstairs.

00:27:49.620 --> 00:27:52.890
And finally, now there's
some order in the universe,

00:27:52.890 --> 00:27:55.206
because what is 2 to
the log base 2 of n?

00:27:55.206 --> 00:27:57.030
AUDIENCE: n.

00:27:57.030 --> 00:27:58.950
PROFESSOR: n, exactly.

00:27:58.950 --> 00:28:00.900
That's a very complicated
way of writing n.

00:28:00.900 --> 00:28:04.980
So this is equal to the
square root of n times

00:28:04.980 --> 00:28:07.380
1 over the square
root of 2 minus 1,

00:28:07.380 --> 00:28:09.000
which is just a constant.

00:28:09.000 --> 00:28:09.780
I see your hand.

00:28:09.780 --> 00:28:12.060
I'm going to write, and
then I'll catch up with you.

00:28:12.060 --> 00:28:15.900
And now this whole quantity is
n times the square root of 2,

00:28:15.900 --> 00:28:18.430
right?

00:28:18.430 --> 00:28:19.370
Oops, wait.

00:28:23.690 --> 00:28:24.660
AUDIENCE: [INAUDIBLE]

00:28:24.660 --> 00:28:26.130
PROFESSOR: Oh, I'm sorry.

00:28:26.130 --> 00:28:28.140
That should be--
right, because we

00:28:28.140 --> 00:28:32.080
moved the 1/2 into the exponent,
and I didn't account for it.

00:28:32.080 --> 00:28:35.850
So this is the square
root of n multiplied

00:28:35.850 --> 00:28:37.350
by the square root of 2.

00:28:37.350 --> 00:28:38.822
AUDIENCE: [INAUDIBLE]

00:28:38.822 --> 00:28:39.780
PROFESSOR: What's that?

00:28:39.780 --> 00:28:44.330
AUDIENCE: It'd be n/2
to the square root of n.

00:28:44.330 --> 00:28:46.197
PROFESSOR: n/2 to
the square root of n.

00:28:46.197 --> 00:28:47.280
No, I think this is right.

00:28:47.280 --> 00:28:48.113
AUDIENCE: Oh, sorry.

00:28:48.113 --> 00:28:50.340
PROFESSOR: Yeah.

00:28:50.340 --> 00:28:51.650
You guys are making me nervous.

00:28:51.650 --> 00:28:54.520
OK, so finally, now we can
start to see the big O come out,

00:28:54.520 --> 00:28:55.020
right?

00:28:55.020 --> 00:28:57.830
Because now we have the
square root of n times itself

00:28:57.830 --> 00:29:00.740
plus some other stuff, which is
obviously going to grow slower

00:29:00.740 --> 00:29:02.880
than the remaining terms here.

00:29:02.880 --> 00:29:05.968
So we're good.

00:29:05.968 --> 00:29:07.760
If you're wondering,
the official solutions

00:29:07.760 --> 00:29:08.718
are actually incorrect.

00:29:08.718 --> 00:29:10.610
They, too, get this
a little bit wrong.

00:29:10.610 --> 00:29:12.485
I'm going to fix that
tonight, and then we'll

00:29:12.485 --> 00:29:14.878
post them for you guys.

00:29:14.878 --> 00:29:16.670
And this unfortunately
is the kind of thing

00:29:16.670 --> 00:29:18.560
you do a lot of, where you're
going to take your tree.

00:29:18.560 --> 00:29:20.720
You write down this
giant tree formula here.

00:29:20.720 --> 00:29:22.815
You write down a geometric
series of some sort

00:29:22.815 --> 00:29:24.440
and then start bounding
terms until you

00:29:24.440 --> 00:29:25.610
get to the expression you want.

00:29:25.610 --> 00:29:27.402
So now you can see why
master theorem maybe

00:29:27.402 --> 00:29:29.970
is kind of valuable because it
saves you a lot of headache.

00:29:29.970 --> 00:29:30.470
Yes.

00:29:30.470 --> 00:29:32.178
AUDIENCE: When we
write up our piece sets

00:29:32.178 --> 00:29:34.260
and we have to write
up trees like this,

00:29:34.260 --> 00:29:36.020
can we hand draw them
and take pictures?

00:29:36.020 --> 00:29:37.562
PROFESSOR: Yeah, I
don't see why not.

00:29:37.562 --> 00:29:40.560
They don't have to draw
it in Dixie or something.

00:29:40.560 --> 00:29:42.450
AUDIENCE: You can take
pictures of diagrams

00:29:42.450 --> 00:29:43.940
as long as the math
doesn't [INAUDIBLE]..

00:29:43.940 --> 00:29:44.720
PROFESSOR: Yeah.

00:29:44.720 --> 00:29:46.790
I think if you're just
writing out your math,

00:29:46.790 --> 00:29:49.640
taking a photo of it, and
then, like, backslash include

00:29:49.640 --> 00:29:51.020
graphics of your photo-- yeah.

00:29:51.020 --> 00:29:52.895
But just for the figure,
I think that's fine.

00:29:52.895 --> 00:29:53.900
AUDIENCE: [INAUDIBLE]

00:29:53.900 --> 00:29:54.350
PROFESSOR: Yeah.

00:29:54.350 --> 00:29:55.520
In fact, when I write
research papers,

00:29:55.520 --> 00:29:57.320
that's how I do it
until the final draft.

00:29:57.320 --> 00:29:58.500
Yeah.

00:29:58.500 --> 00:29:59.120
OK.

00:29:59.120 --> 00:30:00.578
So essentially,
what did we just do

00:30:00.578 --> 00:30:03.200
in this problem, which
is part a of one problem,

00:30:03.200 --> 00:30:06.110
is essentially just showed
two different ways of solving

00:30:06.110 --> 00:30:06.860
recurrence, right?

00:30:06.860 --> 00:30:09.350
One is the sledgehammer
that's very efficient but not

00:30:09.350 --> 00:30:10.520
terribly illustrative.

00:30:10.520 --> 00:30:12.020
The other is really
working out all

00:30:12.020 --> 00:30:14.420
of the work that happens
at every level of our tree,

00:30:14.420 --> 00:30:16.820
doing a giant sum,
and then just actually

00:30:16.820 --> 00:30:18.292
deriving the proper formula.

00:30:18.292 --> 00:30:20.000
And both of these are
just different ways

00:30:20.000 --> 00:30:21.230
to skin the same cat.

00:30:21.230 --> 00:30:23.030
Is that a weird phrase?

00:30:23.030 --> 00:30:24.390
I don't know.

00:30:24.390 --> 00:30:24.890
OK.

00:30:24.890 --> 00:30:29.300
So right, so actually,
part two, I believe,

00:30:29.300 --> 00:30:32.240
ends up being easier
by a funny fluke

00:30:32.240 --> 00:30:34.220
even though it looks
like it's harder.

00:30:34.220 --> 00:30:36.360
So let's do that next here.

00:30:36.360 --> 00:30:39.033
So I'm going to leave master
theorem on the left-hand side.

00:30:39.033 --> 00:30:40.700
I really want to say
"master's theorem,"

00:30:40.700 --> 00:30:41.570
but I guess that's not right.

00:30:41.570 --> 00:30:44.240
I'm going to leave the master
theorem on the left-hand side.

00:30:47.820 --> 00:30:49.590
Just do the problem over here.

00:30:53.148 --> 00:30:55.440
I'm going to do this one a
little bit quicker because I

00:30:55.440 --> 00:30:57.990
prefer not to spend the
whole session on one problem.

00:30:57.990 --> 00:30:58.800
OK.

00:30:58.800 --> 00:31:01.050
But I do think it's worth
spending a few minutes going

00:31:01.050 --> 00:31:03.008
over this theorem and
how to apply it carefully

00:31:03.008 --> 00:31:07.480
because, well,
otherwise, you won't.

00:31:07.480 --> 00:31:07.980
OK.

00:31:16.300 --> 00:31:18.070
All right, folks.

00:31:18.070 --> 00:31:19.301
It's a workout up here.

00:31:24.220 --> 00:31:27.640
So in part b, we
have a version where

00:31:27.640 --> 00:31:31.480
the branching factor and the
amount that the work reduces

00:31:31.480 --> 00:31:32.360
are not the same.

00:31:32.360 --> 00:31:35.080
So now we have to be a little
bit more careful in the way

00:31:35.080 --> 00:31:36.580
that we apply master
theorem, right?

00:31:36.580 --> 00:31:43.510
So now in part b,
we have that T of n

00:31:43.510 --> 00:31:53.440
here is equal to
8T of n/4 plus--

00:31:53.440 --> 00:31:56.290
and now in the problem,
they write big O of n times

00:31:56.290 --> 00:31:57.918
the square root of n.

00:31:57.918 --> 00:31:58.960
We're all grown-ups here.

00:31:58.960 --> 00:32:03.557
That's the same as
big O of n to the 3/2.

00:32:05.960 --> 00:32:06.460
Yeah.

00:32:06.460 --> 00:32:08.180
That's just arithmetic.

00:32:08.180 --> 00:32:08.680
OK.

00:32:08.680 --> 00:32:12.560
So first, let's apply
the master theorem.

00:32:12.560 --> 00:32:13.060
Let's see.

00:32:13.060 --> 00:32:17.710
So what is n to the log
base b of a, in this case?

00:32:17.710 --> 00:32:21.725
Well, what is b?

00:32:21.725 --> 00:32:22.225
4.

00:32:25.180 --> 00:32:26.270
What is a?

00:32:26.270 --> 00:32:26.770
8.

00:32:29.560 --> 00:32:31.390
Anybody know log base 4 of 8?

00:32:31.390 --> 00:32:32.593
AUDIENCE: 3/2.

00:32:32.593 --> 00:32:33.760
PROFESSOR: Wow, you're good.

00:32:33.760 --> 00:32:37.081
Yeah, so this is
equal to n to the 3/2.

00:32:37.081 --> 00:32:39.860
And notice that these
two things agree now.

00:32:39.860 --> 00:32:40.360
Yeah.

00:32:40.360 --> 00:32:45.880
So which of the three cases of
the master theorem are we in?

00:32:45.880 --> 00:32:48.610
Are we in the first one, where
one of these kind of dwarfs the

00:32:48.610 --> 00:32:50.560
other?

00:32:50.560 --> 00:32:51.070
No.

00:32:51.070 --> 00:32:53.290
We're in case two, right,
where they both kind of

00:32:53.290 --> 00:32:54.880
behave similarly.

00:32:54.880 --> 00:32:55.390
Yeah.

00:32:55.390 --> 00:32:58.120
So this is case two.

00:33:00.790 --> 00:33:04.600
And what is the value of k for
case two that's relevant here?

00:33:04.600 --> 00:33:06.865
Do I need a log factor?

00:33:06.865 --> 00:33:08.740
No, these two terms are
just the same, right?

00:33:08.740 --> 00:33:10.120
They're both n to the 3/2.

00:33:10.120 --> 00:33:14.530
So this is case two
with k equals 0.

00:33:14.530 --> 00:33:23.810
And in particular, immediately,
we get that T of n is--

00:33:23.810 --> 00:33:24.310
let's see.

00:33:24.310 --> 00:33:29.100
We're in case two, so we have
theta of n to the log base

00:33:29.100 --> 00:33:34.500
b of a times log to
the k plus 1 of n.

00:33:34.500 --> 00:33:40.570
So you have to account for
that term, so it's like that.

00:33:40.570 --> 00:33:43.480
That make sense, how we applied
master theorem in that case?

00:33:43.480 --> 00:33:44.160
Yes.

00:33:44.160 --> 00:33:46.660
AUDIENCE: So how can we apply
case two if it's big O and not

00:33:46.660 --> 00:33:47.740
big theta?

00:33:47.740 --> 00:33:52.060
PROFESSOR: How can we
apply case two if f of n

00:33:52.060 --> 00:33:55.163
is big O and not big theta?

00:33:55.163 --> 00:33:56.830
Well, that's coming
from a grad student.

00:33:56.830 --> 00:33:59.470
So why don't I ping it back
to the students in the class

00:33:59.470 --> 00:34:00.977
rather than answering myself?

00:34:00.977 --> 00:34:02.560
AUDIENCE: Can you
repeat the question?

00:34:02.560 --> 00:34:03.227
PROFESSOR: Sure.

00:34:03.227 --> 00:34:05.020
So let's say that we
just have a big O. We

00:34:05.020 --> 00:34:06.369
don't have a big theta here.

00:34:10.875 --> 00:34:13.000
Or at least a simple answer,
which maybe is the one

00:34:13.000 --> 00:34:15.058
that you're looking for.

00:34:15.058 --> 00:34:15.850
So what do we know?

00:34:15.850 --> 00:34:17.225
In that case, we
know that f of n

00:34:17.225 --> 00:34:19.097
might grow more slowly
than this function.

00:34:19.097 --> 00:34:21.139
But it doesn't grow more
quickly than this thing.

00:34:21.139 --> 00:34:21.653
Yeah.

00:34:21.653 --> 00:34:24.070
AUDIENCE: Would T of n just
be big O instead of big theta?

00:34:24.070 --> 00:34:24.370
PROFESSOR: That's exactly right.

00:34:24.370 --> 00:34:26.380
So you can just replace
big theta with big O,

00:34:26.380 --> 00:34:27.463
and that's perfectly fine.

00:34:27.463 --> 00:34:29.797
So I don't know if that's the
answer you're looking for.

00:34:29.797 --> 00:34:32.000
But at least you get a
loose bound this way.

00:34:32.000 --> 00:34:32.500
Yeah.

00:34:32.500 --> 00:34:34.309
AUDIENCE: You should probably
write it big O in the answer

00:34:34.309 --> 00:34:34.809
then.

00:34:34.809 --> 00:34:36.370
PROFESSOR: Oops.

00:34:36.370 --> 00:34:37.520
Oh, I'm sorry.

00:34:37.520 --> 00:34:38.150
I see.

00:34:38.150 --> 00:34:39.929
We're being pedantic.

00:34:39.929 --> 00:34:40.900
OK.

00:34:40.900 --> 00:34:42.969
You can just tell me
if I made a mistake.

00:34:42.969 --> 00:34:43.594
It happens.

00:34:43.594 --> 00:34:44.969
I think it's
correct in my notes.

00:34:44.969 --> 00:34:46.150
It is.

00:34:46.150 --> 00:34:46.750
OK.

00:34:46.750 --> 00:34:49.120
So the reason our colleague
brings it up in the back

00:34:49.120 --> 00:34:50.703
is that I made a
slight mistake, which

00:34:50.703 --> 00:34:55.000
is that this is a big O,
not a big theta, right?

00:34:55.000 --> 00:34:57.400
In which case, the only
thing I can draw down here

00:34:57.400 --> 00:34:58.990
is that this is
also a big O. So I

00:34:58.990 --> 00:35:02.390
made exactly the mistake I
told you guys to avoid before.

00:35:02.390 --> 00:35:02.890
Yes.

00:35:02.890 --> 00:35:08.237
AUDIENCE: So then over there,
would those also be big O?

00:35:08.237 --> 00:35:08.820
PROFESSOR: No.

00:35:08.820 --> 00:35:10.660
Yeah, now I've managed
to confuse you.

00:35:10.660 --> 00:35:11.947
This is correct.

00:35:11.947 --> 00:35:13.780
This entire statement
of the master theorem,

00:35:13.780 --> 00:35:16.513
assuming I copied it
correctly, is right.

00:35:16.513 --> 00:35:17.930
But there's a bit
of a difference.

00:35:17.930 --> 00:35:20.330
Remember, we wanted
to apply case two.

00:35:20.330 --> 00:35:21.560
And look at case two.

00:35:21.560 --> 00:35:23.767
So there's a theta here.

00:35:23.767 --> 00:35:25.600
But in the problem, in
the homework problem,

00:35:25.600 --> 00:35:26.920
they were sneaky.

00:35:26.920 --> 00:35:29.943
And they only said that f
of T is big O of something.

00:35:29.943 --> 00:35:31.360
So remember, what's
the difference

00:35:31.360 --> 00:35:34.300
between big O and big theta?

00:35:34.300 --> 00:35:37.030
Well, intuitively, big theta
says that my function really

00:35:37.030 --> 00:35:38.420
does look like this guy.

00:35:38.420 --> 00:35:42.280
Somehow, it's bounded above and
below as I go far enough out.

00:35:42.280 --> 00:35:45.430
In big O, there's just
a bound above, right?

00:35:45.430 --> 00:35:47.350
So this is somehow looser.

00:35:47.350 --> 00:35:49.910
And so the way to apply master
theorem in this case is say,

00:35:49.910 --> 00:35:51.535
well, at least f of
n is upper bounded.

00:35:51.535 --> 00:35:52.600
It looks like this.

00:35:52.600 --> 00:35:54.940
So the best that I can do
is to replace this guy also

00:35:54.940 --> 00:35:55.870
with an upper bound.

00:35:55.870 --> 00:35:56.560
Yeah.

00:35:56.560 --> 00:35:57.280
That's a great question.

00:35:57.280 --> 00:35:58.655
AUDIENCE: So the
reason you chose

00:35:58.655 --> 00:36:01.330
two is that [INAUDIBLE]
construction of the math

00:36:01.330 --> 00:36:02.418
is similar to [INAUDIBLE]?

00:36:02.418 --> 00:36:03.210
PROFESSOR: Exactly.

00:36:03.210 --> 00:36:05.370
You got to kind of stand back
and squint at it a little bit,

00:36:05.370 --> 00:36:06.660
make sure that it fits.

00:36:06.660 --> 00:36:09.450
But certainly, it's the case
that the other two parts

00:36:09.450 --> 00:36:11.246
of this theorem don't apply.

00:36:11.246 --> 00:36:13.080
So we might as well try
to squeeze this part

00:36:13.080 --> 00:36:14.430
into the right form.

00:36:14.430 --> 00:36:14.930
All right.

00:36:19.160 --> 00:36:20.702
So let's do the tree
version of this.

00:36:20.702 --> 00:36:22.077
And then I think
what we're going

00:36:22.077 --> 00:36:24.230
to do is skip part three
for now of this problem

00:36:24.230 --> 00:36:26.372
because it's mostly a fun
kind of vectorial problem

00:36:26.372 --> 00:36:27.830
rather than something
that actually

00:36:27.830 --> 00:36:29.540
is going to help your
understanding of algorithms.

00:36:29.540 --> 00:36:31.998
And then if we have time at
the end, we'll come back to it.

00:36:31.998 --> 00:36:33.090
OK.

00:36:33.090 --> 00:36:33.590
All right.

00:36:33.590 --> 00:36:36.020
So that was the easy way
to solve the problem.

00:36:36.020 --> 00:36:38.420
Now let's do the painful
one where we draw the tree.

00:36:38.420 --> 00:36:39.560
I shouldn't say
that because I think

00:36:39.560 --> 00:36:41.477
it's something we want
to encourage-- the more

00:36:41.477 --> 00:36:44.090
enlightening version, yeah?

00:36:44.090 --> 00:36:51.170
So now at the top of my
tree, I do n to the 3/2 work.

00:36:51.170 --> 00:36:54.690
And now how many children
does this guy have?

00:36:54.690 --> 00:36:55.610
AUDIENCE: [INAUDIBLE]

00:36:55.610 --> 00:36:56.402
PROFESSOR: Careful.

00:36:56.402 --> 00:37:00.740
You have 1 in 2
chances, either 8 or 4.

00:37:00.740 --> 00:37:01.890
8, right?

00:37:01.890 --> 00:37:04.340
So the outer coefficient
is the number of children

00:37:04.340 --> 00:37:06.260
because it's like the number of
function calls you make, right?

00:37:06.260 --> 00:37:08.240
That's the way to
think about it, right?

00:37:08.240 --> 00:37:10.640
So there's eight of these guys.

00:37:15.020 --> 00:37:15.650
OK.

00:37:15.650 --> 00:37:16.935
And each one of these guys--

00:37:16.935 --> 00:37:19.100
I'm only going to do
one level of these.

00:37:19.100 --> 00:37:21.488
Wait, that should
not be connected--

00:37:21.488 --> 00:37:22.280
does how much work?

00:37:22.280 --> 00:37:25.400
Well, remember that it's
divided by 4 here, right?

00:37:25.400 --> 00:37:27.275
So it looks like n/4 to the 3/2.

00:37:34.730 --> 00:37:39.650
That make sense, how we got this
picture from our recurrence?

00:37:39.650 --> 00:37:41.360
Let me switch to
another piece of chalk.

00:37:41.360 --> 00:37:42.900
OK.

00:37:42.900 --> 00:37:43.400
Right.

00:37:43.400 --> 00:37:49.790
So in other words, if I
look at level l of my tree,

00:37:49.790 --> 00:37:51.860
assuming we're going to
index from 0 at the top,

00:37:51.860 --> 00:37:55.890
how many nodes are in level l?

00:37:55.890 --> 00:37:58.860
Remember, it branches
by 8 each time.

00:37:58.860 --> 00:38:05.540
So it has 8 to the l nodes.

00:38:05.540 --> 00:38:06.860
Yeah.

00:38:06.860 --> 00:38:10.550
And how much work does each do?

00:38:18.410 --> 00:38:22.880
Well, in each level,
I divide by 4, right?

00:38:22.880 --> 00:38:27.814
So this is going to look like n
times 1/4 to the l to the 3/2.

00:38:32.640 --> 00:38:33.140
Right.

00:38:33.140 --> 00:38:33.640
Where am I?

00:38:36.770 --> 00:38:38.060
There we are.

00:38:38.060 --> 00:38:41.600
So that's n times
4 to the minus l.

00:38:41.600 --> 00:38:47.177
That's fancy notation for
1/4 to the l to the 3/2.

00:38:47.177 --> 00:38:49.010
Notice that this is
exactly the same pattern

00:38:49.010 --> 00:38:50.160
as the previous problem.

00:38:50.160 --> 00:38:53.150
I'm just plugging in
some different constants.

00:38:53.150 --> 00:38:53.690
Yes.

00:38:53.690 --> 00:38:55.607
AUDIENCE: I have a
question about the diagram.

00:38:55.607 --> 00:38:58.605
If you have a really
large a and you're

00:38:58.605 --> 00:39:00.230
trying to do the
recursion tree method,

00:39:00.230 --> 00:39:03.500
is this type of work OK
with where you have--

00:39:03.500 --> 00:39:05.750
PROFESSOR: If I were grading
your papers, it would be.

00:39:05.750 --> 00:39:08.340
But you should probably
check with your TAs on Piazza

00:39:08.340 --> 00:39:08.840
on that one.

00:39:08.840 --> 00:39:10.910
AUDIENCE: All right.

00:39:10.910 --> 00:39:13.818
PROFESSOR: But I've
learned my license.

00:39:13.818 --> 00:39:15.110
I'm not sure you guys have yet.

00:39:15.110 --> 00:39:17.810
And also, I am not
sure I have, either.

00:39:17.810 --> 00:39:18.710
All right, folks.

00:39:18.710 --> 00:39:23.150
So now we need to do our total
amount of work here, right?

00:39:23.150 --> 00:39:26.750
So how many levels are
there in our tree here?

00:39:26.750 --> 00:39:29.990
Well, the amount of data
divides by 4 each time.

00:39:29.990 --> 00:39:34.300
And when the amount of data
is 1, then I'm done, right?

00:39:34.300 --> 00:39:42.573
So the total number of levels
is equal to the log base 4 of n.

00:39:42.573 --> 00:39:44.990
The basic thing to get right
in this problem is just where

00:39:44.990 --> 00:39:47.350
there should be 4's and
where there should be 8's.

00:39:47.350 --> 00:39:48.140
OK.

00:39:48.140 --> 00:39:50.760
So now what am I going to do?

00:39:50.760 --> 00:39:53.210
Well, again, as our colleague
in the back points out,

00:39:53.210 --> 00:39:56.900
we only have big O. So we can
only upper bound our work.

00:39:56.900 --> 00:40:03.295
But our work in the tree
is less than or equal to--

00:40:03.295 --> 00:40:04.670
really, there's
a proportion here

00:40:04.670 --> 00:40:06.275
because this is just
up to a multiple.

00:40:06.275 --> 00:40:07.650
I guess that's
why, in the notes,

00:40:07.650 --> 00:40:11.750
they put a little c in
front, which I can do.

00:40:11.750 --> 00:40:14.240
Let's do c like that.

00:40:14.240 --> 00:40:17.690
Well, we're going to have
the sum from l equals 0

00:40:17.690 --> 00:40:25.190
to log base 4 of n of exactly
the quantity, this guy.

00:40:25.190 --> 00:40:27.830
Multiply it by the number
of nodes in the row.

00:40:27.830 --> 00:40:28.700
Yes.

00:40:28.700 --> 00:40:30.890
AUDIENCE: Is the reason
why you made this work

00:40:30.890 --> 00:40:32.780
an inequality because of the--

00:40:32.780 --> 00:40:35.660
PROFESSOR: Because of the
big O. That's exactly right.

00:40:35.660 --> 00:40:36.960
Yeah.

00:40:36.960 --> 00:40:38.190
OK.

00:40:38.190 --> 00:40:38.690
All right.

00:40:38.690 --> 00:40:40.520
So what do I get here?

00:40:40.520 --> 00:40:43.550
Well, let's write it out
the big ugly way first.

00:40:43.550 --> 00:40:46.670
So this is n times
4 to the minus l.

00:40:46.670 --> 00:40:48.990
This is to the 3/2.

00:40:48.990 --> 00:40:51.350
And then this is
multiplied by 8 to the l.

00:40:51.350 --> 00:40:54.270
But whoever designed this
problem was really sneaky,

00:40:54.270 --> 00:40:54.890
right?

00:40:54.890 --> 00:40:57.920
So what's 4 to the
minus l to the 3/2?

00:41:00.660 --> 00:41:01.445
Any guesses?

00:41:01.445 --> 00:41:02.570
AUDIENCE: 8 to the minus l.

00:41:02.570 --> 00:41:04.715
PROFESSOR: Yeah, this is
exactly 8 to the minus l

00:41:04.715 --> 00:41:07.470
if we work through all of
your exponent arithmetic.

00:41:07.470 --> 00:41:07.970
Yeah.

00:41:07.970 --> 00:41:08.845
Why does that matter?

00:41:08.845 --> 00:41:11.120
Well, it exactly cancels
this 8 to the l term here.

00:41:11.120 --> 00:41:13.490
This is actually exactly what
case two in master theorem

00:41:13.490 --> 00:41:15.740
is trying to capture.

00:41:15.740 --> 00:41:24.470
So this whole thing is equal
to, really, just n to the 3/2

00:41:24.470 --> 00:41:30.110
from l equals 0 to
the log base 4 of n.

00:41:30.110 --> 00:41:31.340
All these constants go away.

00:41:31.340 --> 00:41:32.790
Isn't that beautiful?

00:41:32.790 --> 00:41:33.934
Yes.

00:41:33.934 --> 00:41:34.760
AUDIENCE: Quick question
about the tree again.

00:41:34.760 --> 00:41:35.270
PROFESSOR: No problem.

00:41:35.270 --> 00:41:36.100
Uh-huh.

00:41:36.100 --> 00:41:40.575
AUDIENCE: So do people ever
use these for optimization

00:41:40.575 --> 00:41:43.630
in terms of trying to
write a better algorithm,

00:41:43.630 --> 00:41:48.620
trying to minimize
the work per level?

00:41:48.620 --> 00:41:51.623
Yeah, I'm just curious if
that's an application that's--

00:41:51.623 --> 00:41:52.790
PROFESSOR: Sure, I guess so.

00:41:52.790 --> 00:41:54.500
I mean, this is
somehow a visualization

00:41:54.500 --> 00:41:57.170
of how your algorithm is
making function costs, right?

00:41:57.170 --> 00:42:00.050
So every node here kind
of looks like a call

00:42:00.050 --> 00:42:02.283
to your piece of code.

00:42:02.283 --> 00:42:04.700
So every time you make a new
one, it's like making a call.

00:42:04.700 --> 00:42:07.670
And then the divide here is
kind of like how much data

00:42:07.670 --> 00:42:09.193
goes into that function call.

00:42:09.193 --> 00:42:11.360
So I think this is a useful
way to kind of visualize

00:42:11.360 --> 00:42:13.010
what's going on
inside of your code.

00:42:13.010 --> 00:42:15.010
And then if you're trying
to optimize your code,

00:42:15.010 --> 00:42:17.600
you're trying to basically
reduce the number of nodes

00:42:17.600 --> 00:42:20.220
and/or the amount of work
that each node does, right?

00:42:20.220 --> 00:42:20.720
Yeah.

00:42:20.720 --> 00:42:23.060
So this is just a nice
way to kind of visualize

00:42:23.060 --> 00:42:25.310
what's going on in a
recursive algorithm.

00:42:25.310 --> 00:42:26.060
Yeah.

00:42:26.060 --> 00:42:27.440
Great question.

00:42:27.440 --> 00:42:29.030
All right.

00:42:29.030 --> 00:42:31.430
So here's a really nice thing.

00:42:31.430 --> 00:42:34.590
Does n to the 3/2 depend on l?

00:42:34.590 --> 00:42:35.370
No, right?

00:42:35.370 --> 00:42:40.848
So this whole thing is equal
to c times n to the 3/2.

00:42:40.848 --> 00:42:42.390
And my colleague in
the back is going

00:42:42.390 --> 00:42:45.380
to catch me if I don't make
the off by 1 error here.

00:42:45.380 --> 00:42:52.810
So this is log base 4 of n plus
1 because my sum started at 0.

00:42:52.810 --> 00:42:54.180
Yeah.

00:42:54.180 --> 00:43:02.940
And notice that this is exactly
big O of n to the 3/2 log

00:43:02.940 --> 00:43:06.430
n, which agrees with what we
did in a much more easy case

00:43:06.430 --> 00:43:07.430
with the master theorem.

00:43:07.430 --> 00:43:08.305
Does that make sense?

00:43:08.305 --> 00:43:09.010
Yeah.

00:43:09.010 --> 00:43:11.170
AUDIENCE: So if I'm
doing the exact bound,

00:43:11.170 --> 00:43:14.240
can we say that it's theta
of n to the [INAUDIBLE]??

00:43:14.240 --> 00:43:16.110
PROFESSOR: Oh, great question.

00:43:16.110 --> 00:43:18.960
This is where this notation
is going to be misleading.

00:43:18.960 --> 00:43:24.080
This expression in a vacuum
is theta of this value.

00:43:24.080 --> 00:43:25.610
But the reason
that I wrote big O

00:43:25.610 --> 00:43:27.985
is because I only have an
inequality all the way up here.

00:43:27.985 --> 00:43:30.153
So if I'm worried about
bounding this work,

00:43:30.153 --> 00:43:31.820
there's no reason to
write a theta there

00:43:31.820 --> 00:43:33.830
because it's just telling me
some kind of intermediate piece

00:43:33.830 --> 00:43:34.670
of information.

00:43:34.670 --> 00:43:36.200
Yeah.

00:43:36.200 --> 00:43:37.460
OK, fabulous.

00:43:37.460 --> 00:43:40.144
So yes.

00:43:40.144 --> 00:43:41.894
AUDIENCE: Does the
base of the log matter?

00:43:41.894 --> 00:43:43.686
PROFESSOR: Does the
base of the log matter?

00:43:43.686 --> 00:43:44.520
Ah.

00:43:44.520 --> 00:43:47.640
This is a nice formula here.

00:43:47.640 --> 00:43:54.740
So remember that log base
b of a is the same as log a

00:43:54.740 --> 00:43:58.680
over log b, if I got that right.

00:43:58.680 --> 00:43:59.180
Yeah.

00:43:59.180 --> 00:44:01.055
So the base of the log
when it comes to big O

00:44:01.055 --> 00:44:03.380
doesn't matter because
it's a constant factor.

00:44:03.380 --> 00:44:04.710
Yeah.

00:44:04.710 --> 00:44:05.210
OK.

00:44:05.210 --> 00:44:06.668
So that's part two
of this problem.

00:44:06.668 --> 00:44:08.150
Part three is a
little bit annoying

00:44:08.150 --> 00:44:10.160
because it has two
branches in it.

00:44:10.160 --> 00:44:12.560
I wrote out a careful solution.

00:44:12.560 --> 00:44:14.090
It does not apply
the master theorem

00:44:14.090 --> 00:44:15.965
because it's irrelevant,
at least the version

00:44:15.965 --> 00:44:18.088
that we know in this class.

00:44:18.088 --> 00:44:19.880
So we're going to kind
of skip that for now

00:44:19.880 --> 00:44:21.338
because I don't
think it's terribly

00:44:21.338 --> 00:44:22.970
relevant to most
of the algorithms

00:44:22.970 --> 00:44:24.320
that we'll see in 6.006.

00:44:24.320 --> 00:44:26.330
But we'll come back
to it if we have time.

00:44:26.330 --> 00:44:26.990
Yes.

00:44:26.990 --> 00:44:29.198
AUDIENCE: Can we make that
a lower bound and an upper

00:44:29.198 --> 00:44:33.080
bound using master theorem,
knowing that T of n/4

00:44:33.080 --> 00:44:35.377
is smaller than T of n/3?

00:44:35.377 --> 00:44:37.460
PROFESSOR: I'm going to
refer you to the solutions

00:44:37.460 --> 00:44:39.502
rather than talking about
that problem right now.

00:44:39.502 --> 00:44:40.490
Yeah.

00:44:40.490 --> 00:44:42.640
OK, cool.

00:44:42.640 --> 00:44:43.140
All right.

00:44:43.140 --> 00:44:45.015
So that's how you apply
master theorem, which

00:44:45.015 --> 00:44:46.287
is mildly painful.

00:44:46.287 --> 00:44:48.620
The good news is the rest of
this problem set, actually,

00:44:48.620 --> 00:44:50.690
I consider to be much easier
than the first one, which

00:44:50.690 --> 00:44:53.060
is why I think it's OK to
spend a little bit extra time

00:44:53.060 --> 00:44:56.078
here because I think this stuff
is confusing to get right.

00:44:56.078 --> 00:44:58.370
Mostly for me, and hopefully
I've conveyed my confusion

00:44:58.370 --> 00:44:59.640
to the rest of you.

00:44:59.640 --> 00:45:00.140
OK.

00:45:00.140 --> 00:45:02.167
So let's erase this.

00:45:02.167 --> 00:45:04.250
And while we're doing that,
why don't you guys all

00:45:04.250 --> 00:45:06.560
give problem number two a read?

00:45:06.560 --> 00:45:09.840
So one of the big skills that
we need to cover in 6.83--

00:45:09.840 --> 00:45:17.270
not 6.837, 6.006 and 6.837, but
I'm not quite as evil about it

00:45:17.270 --> 00:45:19.670
in that class--

00:45:19.670 --> 00:45:21.680
is as follows, which
is you read a problem.

00:45:21.680 --> 00:45:24.680
And for some reason,
your instructors

00:45:24.680 --> 00:45:26.300
have some sick sense of humor.

00:45:26.300 --> 00:45:30.110
And they encode it in this
totally weird, goofy language

00:45:30.110 --> 00:45:31.610
which somehow, to
a theoretician,

00:45:31.610 --> 00:45:34.290
makes your problem
feel more practical.

00:45:34.290 --> 00:45:37.700
So in any event, when you
read all of this paragraph,

00:45:37.700 --> 00:45:40.610
the very first skill that you
have to do is to figure out,

00:45:40.610 --> 00:45:43.538
OK, like, this is cute notation,
and it's about Infinity Stones.

00:45:43.538 --> 00:45:45.080
And if I watch Star
Wars or whatever,

00:45:45.080 --> 00:45:46.700
I would know what that meant.

00:45:46.700 --> 00:45:50.840
But in any event,
what really matters

00:45:50.840 --> 00:45:53.060
is understanding, OK,
but algorithmically,

00:45:53.060 --> 00:45:54.450
what are they asking?

00:45:54.450 --> 00:45:54.972
Yeah.

00:45:54.972 --> 00:45:56.930
So I'm going to try and
talk about this problem

00:45:56.930 --> 00:45:58.320
as I erase the board.

00:45:58.320 --> 00:46:02.810
So I believe, what, like, Mickey
Mouse or whatever has a bunch,

00:46:02.810 --> 00:46:05.510
has some planet that
he's looking for.

00:46:05.510 --> 00:46:09.530
I'm going to open
the problem now.

00:46:09.530 --> 00:46:11.990
Right, she's a super
villain on a quest.

00:46:11.990 --> 00:46:13.970
She's looking for a
stone on a planet,

00:46:13.970 --> 00:46:16.640
and the planet has some index k.

00:46:16.640 --> 00:46:20.600
And unfortunately for
us, the number of planets

00:46:20.600 --> 00:46:22.290
is quite large.

00:46:22.290 --> 00:46:27.050
It's infinity, in fact, because
it's the Infinity Stone.

00:46:27.050 --> 00:46:28.420
Or, sorry, did I say that?

00:46:28.420 --> 00:46:30.300
I think it's the Infinity
Phone or something.

00:46:30.300 --> 00:46:31.050
I forget.

00:46:31.050 --> 00:46:33.650
But in any event, the
only thing that you

00:46:33.650 --> 00:46:37.820
can do when you land on a
planet is ask an oracle,

00:46:37.820 --> 00:46:40.700
is the index of my
planet bigger or smaller

00:46:40.700 --> 00:46:44.300
than the index of the planet
that I'm standing on, right?

00:46:44.300 --> 00:46:46.910
And then the question
is in log k time where

00:46:46.910 --> 00:46:48.648
k is the index of the planet.

00:46:48.648 --> 00:46:50.690
Notice that's already a
little weird because it's

00:46:50.690 --> 00:46:54.020
not the size of
your data, quite.

00:46:54.020 --> 00:46:56.390
Can you find the planet?

00:46:56.390 --> 00:46:58.820
Now, what does this
kind of problem--

00:46:58.820 --> 00:47:01.370
like, what is it screaming
out for you to use?

00:47:01.370 --> 00:47:02.320
You see a log k.

00:47:02.320 --> 00:47:03.740
You're looking for something.

00:47:03.740 --> 00:47:04.613
AUDIENCE: Bisection.

00:47:04.613 --> 00:47:05.780
PROFESSOR: Bisection, right?

00:47:05.780 --> 00:47:06.080
AUDIENCE: Binary search.

00:47:06.080 --> 00:47:07.290
PROFESSOR: Or binary search.

00:47:07.290 --> 00:47:08.300
That's absolutely right.

00:47:08.300 --> 00:47:10.820
Those are both great answers.

00:47:10.820 --> 00:47:13.940
But there's a bit
of a problem, which

00:47:13.940 --> 00:47:16.910
is that the number of
planets is unbounded.

00:47:16.910 --> 00:47:18.410
We don't know how
many planets there

00:47:18.410 --> 00:47:25.840
are in this little universe
that problem 1.2 sets up.

00:47:25.840 --> 00:47:26.340
Yeah.

00:47:26.340 --> 00:47:28.640
So our intuition is that we
want to use binary search.

00:47:28.640 --> 00:47:29.960
But in order to
do binary search,

00:47:29.960 --> 00:47:32.293
I need to have a left- and a
right-hand side and divide,

00:47:32.293 --> 00:47:34.710
and I have no right-hand side.

00:47:34.710 --> 00:47:36.010
So what can I do?

00:47:36.010 --> 00:47:38.830
How's a supervillain
to solve this problem?

00:47:42.730 --> 00:47:45.660
Well, remember that each planet
has an oracle on it telling me.

00:47:45.660 --> 00:47:47.410
Is there something to
my left or my right?

00:47:47.410 --> 00:47:48.480
Yeah.

00:47:48.480 --> 00:47:50.130
So I could start at
planet number one,

00:47:50.130 --> 00:47:52.740
and I could just start walking
from planet one to planet two

00:47:52.740 --> 00:47:56.250
to planet three, planet four,
and asking, am I there yet?

00:47:56.250 --> 00:47:57.030
Am I there yet?

00:47:57.030 --> 00:47:58.530
How much time is
that going to take?

00:47:58.530 --> 00:48:00.450
AUDIENCE: Infinite, eventually.

00:48:00.450 --> 00:48:02.650
PROFESSOR: Actually, it
won't take infinite time.

00:48:02.650 --> 00:48:03.915
I caught you.

00:48:03.915 --> 00:48:05.040
How much time will it take?

00:48:05.040 --> 00:48:07.500
When will I stop?

00:48:07.500 --> 00:48:09.990
When I hit planet k, right,
because I know that planet k

00:48:09.990 --> 00:48:11.340
is out there somewhere.

00:48:11.340 --> 00:48:12.690
The truth is out there.

00:48:12.690 --> 00:48:15.360
And when I find it and
I step on it, I stop.

00:48:15.360 --> 00:48:18.300
And I took exactly k
steps, maybe k minus 1,

00:48:18.300 --> 00:48:19.770
depending on how you count.

00:48:19.770 --> 00:48:22.000
But we need a log k algorithm.

00:48:22.000 --> 00:48:22.500
Yeah.

00:48:22.500 --> 00:48:24.330
So what can I do?

00:48:24.330 --> 00:48:27.215
AUDIENCE: You start at some k,
and then if it's to your right,

00:48:27.215 --> 00:48:29.705
you multiply by another k?

00:48:29.705 --> 00:48:31.080
PROFESSOR: Multiply
by another k.

00:48:31.080 --> 00:48:32.220
AUDIENCE: [INAUDIBLE]
essentially perceived

00:48:32.220 --> 00:48:33.210
by another k planets.

00:48:33.210 --> 00:48:36.900
So it's like you're
at index k squared.

00:48:36.900 --> 00:48:38.091
PROFESSOR: Interesting.

00:48:40.737 --> 00:48:42.356
Hmm.

00:48:42.356 --> 00:48:44.370
AUDIENCE: Couldn't you
go from i to i squared?

00:48:44.370 --> 00:48:45.288
AUDIENCE: Yeah.

00:48:45.288 --> 00:48:46.830
PROFESSOR: OK, so
you got the right--

00:48:46.830 --> 00:48:48.622
you're in the right
church, wrong pew here.

00:48:48.622 --> 00:48:51.030
So the basic intuition
here is that stepping

00:48:51.030 --> 00:48:53.713
one planet at a time
doesn't step fast enough.

00:48:53.713 --> 00:48:55.380
If you work out the
details on that one,

00:48:55.380 --> 00:48:57.005
you're going to find
that you'll end up

00:48:57.005 --> 00:49:00.580
with a runtime that still goes
a little bit too quickly in k

00:49:00.580 --> 00:49:01.680
here.

00:49:01.680 --> 00:49:04.340
In some sense, if you
were to reverse engineer

00:49:04.340 --> 00:49:06.840
this problem, which isn't really
a great way to problem set,

00:49:06.840 --> 00:49:08.760
you really do expect
there to be powers of 2

00:49:08.760 --> 00:49:10.690
in every step of your algorithm.

00:49:10.690 --> 00:49:11.567
Yes.

00:49:11.567 --> 00:49:13.270
AUDIENCE: Could you
do the binary search

00:49:13.270 --> 00:49:15.470
and start in the
middle and then ask

00:49:15.470 --> 00:49:19.980
the oracle if it's higher or
lower and then [INAUDIBLE]??

00:49:19.980 --> 00:49:21.480
PROFESSOR: It's the
right intuition.

00:49:21.480 --> 00:49:23.313
But I have a philosophical
question for you,

00:49:23.313 --> 00:49:26.298
which is, what is the middle
of an infinite set of planets?

00:49:26.298 --> 00:49:27.090
AUDIENCE: Infinite.

00:49:27.090 --> 00:49:28.110
PROFESSOR: Infinite, exactly.

00:49:28.110 --> 00:49:28.770
It's a problem.

00:49:28.770 --> 00:49:29.910
Yes.

00:49:29.910 --> 00:49:31.530
AUDIENCE: We could use--

00:49:31.530 --> 00:49:34.110
and I don't know who it
was back there who was

00:49:34.110 --> 00:49:36.480
suggesting doing i squareds--

00:49:36.480 --> 00:49:39.467
except for doing i squared,
replace it with 2 to the i.

00:49:39.467 --> 00:49:40.800
PROFESSOR: That's exactly right.

00:49:40.800 --> 00:49:42.130
That's a great intuition.

00:49:42.130 --> 00:49:44.350
So let's formalize
that a little bit,

00:49:44.350 --> 00:49:46.320
which is like, I could
do binary search if I

00:49:46.320 --> 00:49:47.237
had a right-hand side.

00:49:47.237 --> 00:49:48.960
I have a left-hand
side because it's 1.

00:49:48.960 --> 00:49:49.800
So what I'm going
to do, I'm going

00:49:49.800 --> 00:49:51.480
to keep trying right-hand sides.

00:49:51.480 --> 00:49:53.330
And the oracle is
going to tell me,

00:49:53.330 --> 00:49:55.595
is this a valid
right-hand side, right,

00:49:55.595 --> 00:49:56.970
because the oracle
is telling me,

00:49:56.970 --> 00:49:59.120
is there a planet to my left?

00:49:59.120 --> 00:49:59.700
Yeah.

00:49:59.700 --> 00:50:01.440
So here's what I'm going to do.

00:50:01.440 --> 00:50:02.830
Again, I don't like the index i.

00:50:02.830 --> 00:50:04.455
In the official
solution, there's an i.

00:50:04.455 --> 00:50:07.950
But I'm going to use the
letter m because I can--

00:50:07.950 --> 00:50:09.517
which is the following.

00:50:09.517 --> 00:50:10.350
I'm going to visit--

00:50:13.010 --> 00:50:15.727
I hate teaching.

00:50:15.727 --> 00:50:16.560
No, that's not true.

00:50:16.560 --> 00:50:17.227
I like teaching.

00:50:17.227 --> 00:50:19.920
I just don't like chalk.

00:50:19.920 --> 00:50:25.890
I'm going to visit
planet 2 to the m

00:50:25.890 --> 00:50:34.680
for each m starting
with m equals 0

00:50:34.680 --> 00:50:36.405
and essentially until--

00:50:39.300 --> 00:50:42.280
remember that k is the index
of the planet I'm looking for.

00:50:42.280 --> 00:50:45.120
So eventually, I'm going to
reach the point where k is less

00:50:45.120 --> 00:50:46.810
than or equal to 2 to the m.

00:50:46.810 --> 00:50:48.870
And I know that I
can query my oracle,

00:50:48.870 --> 00:50:52.600
and they're going to tell
me when that's the case.

00:50:52.600 --> 00:50:54.918
So how much time does this take?

00:50:54.918 --> 00:50:57.210
So I'm going to try planet
1 and then planet 2 and then

00:50:57.210 --> 00:51:02.970
planet 4 and then 8 and
16 all the way up until k.

00:51:02.970 --> 00:51:03.830
AUDIENCE: Log k.

00:51:03.830 --> 00:51:06.210
PROFESSOR: So it's going
to take log k time.

00:51:06.210 --> 00:51:08.280
AUDIENCE: Can't you also
have a stronger or lower

00:51:08.280 --> 00:51:11.380
bound now to the m minus 1?

00:51:11.380 --> 00:51:13.050
PROFESSOR: Yeah,
that's sort of right.

00:51:13.050 --> 00:51:14.467
Right, so eventually,
what's going

00:51:14.467 --> 00:51:17.820
to happen when you stop here
is that 2 to the m minus 1

00:51:17.820 --> 00:51:19.650
is going to be less
than or equal to k.

00:51:19.650 --> 00:51:23.490
This one equals the 2
to the m because this

00:51:23.490 --> 00:51:25.650
is the condition for stopping.

00:51:25.650 --> 00:51:27.760
This is a condition
for not stopping.

00:51:27.760 --> 00:51:31.540
So when you stop k, this
little sandwich is true.

00:51:31.540 --> 00:51:32.040
Yeah.

00:51:32.040 --> 00:51:34.740
So if I take the log,
essentially, what I've shown

00:51:34.740 --> 00:51:36.690
is that I've taken,
right-- because m

00:51:36.690 --> 00:51:39.265
is the number of steps in
this part of my algorithm.

00:51:39.265 --> 00:51:40.890
So if I take the log,
I'm going to find

00:51:40.890 --> 00:51:43.530
that I took log k steps.

00:51:43.530 --> 00:51:44.930
Yeah, nods, acknowledgment.

00:51:44.930 --> 00:51:45.430
Yeah.

00:51:45.430 --> 00:51:46.530
OK.

00:51:46.530 --> 00:51:51.210
And then, well, now I have an
upper bound and a lower bound.

00:51:51.210 --> 00:51:52.520
So now what can I do?

00:51:52.520 --> 00:51:53.520
AUDIENCE: Binary search.

00:51:53.520 --> 00:51:53.850
PROFESSOR: Yeah.

00:51:53.850 --> 00:51:55.080
Now I can binary search.

00:51:55.080 --> 00:51:56.967
And that also takes log k time.

00:51:56.967 --> 00:52:01.260
AUDIENCE: Is it 2 times
log k [INAUDIBLE]??

00:52:01.260 --> 00:52:03.570
PROFESSOR: That's exactly right.

00:52:03.570 --> 00:52:05.820
Oops.

00:52:05.820 --> 00:52:08.490
So now I have step two
is also binary search.

00:52:08.490 --> 00:52:11.790
And it's also a log k time,
and our problem is solved.

00:52:11.790 --> 00:52:13.920
So problem number
two is not so hard.

00:52:13.920 --> 00:52:14.842
Is everybody with me?

00:52:14.842 --> 00:52:16.050
Any questions about that one?

00:52:16.050 --> 00:52:17.700
That's a quick one.

00:52:17.700 --> 00:52:18.620
OK.

00:52:18.620 --> 00:52:21.120
Now, problem three really spoke
to me as a computer graphics

00:52:21.120 --> 00:52:21.960
professor.

00:52:24.340 --> 00:52:24.840
Right.

00:52:24.840 --> 00:52:27.570
So now I am running Fadobe.

00:52:34.440 --> 00:52:37.970
I collaborate a lot
with Fadobe Fresearch.

00:52:37.970 --> 00:52:38.470
Right.

00:52:38.470 --> 00:52:41.400
So Fadobe is trying to
make a piece of software

00:52:41.400 --> 00:52:42.540
for image editing.

00:52:42.540 --> 00:52:45.120
And what does my
piece of software do?

00:52:45.120 --> 00:52:49.973
Well, my image, or
I guess my document,

00:52:49.973 --> 00:52:51.390
consists of a bunch
of images that

00:52:51.390 --> 00:52:53.500
are overlaid with one another.

00:52:53.500 --> 00:52:54.000
OK.

00:52:54.000 --> 00:52:55.667
And essentially,
what's happening inside

00:52:55.667 --> 00:52:58.290
of the software is I want to
keep all the images in order

00:52:58.290 --> 00:53:01.050
from top to bottom,
OK, because when I

00:53:01.050 --> 00:53:02.665
render my photo, what do I do?

00:53:02.665 --> 00:53:04.540
I render the bottom one
and then the next one

00:53:04.540 --> 00:53:06.300
and so on and just layer
them on top of each other,

00:53:06.300 --> 00:53:08.467
like if you ever played
with PowerPoint or Photoshop

00:53:08.467 --> 00:53:11.470
or I guess whatever fake
name they're giving here.

00:53:11.470 --> 00:53:16.760
That's a pretty common user
interface to encounter.

00:53:16.760 --> 00:53:19.170
And so what they've
asked you to do

00:53:19.170 --> 00:53:21.900
is to come up with
essentially a data structure.

00:53:21.900 --> 00:53:23.730
And your data structure
has to support

00:53:23.730 --> 00:53:27.150
a few different operations.

00:53:27.150 --> 00:53:29.760
In particular, you have to
be able to make a document,

00:53:29.760 --> 00:53:34.140
import an image and then
stick it on top, display,

00:53:34.140 --> 00:53:38.770
which returns all the IDs in the
order that you've stored them.

00:53:38.770 --> 00:53:40.990
And then there's
the real kicker,

00:53:40.990 --> 00:53:45.300
which is that you need to be
able to take one of the layers

00:53:45.300 --> 00:53:47.850
and stick it
underneath another one.

00:53:47.850 --> 00:53:49.770
But you have to do
that in log n time.

00:53:49.770 --> 00:53:51.645
It's that "but" that
makes this whole problem

00:53:51.645 --> 00:53:53.020
kind of a pain in the tuchus.

00:53:53.020 --> 00:53:54.490
Yeah.

00:53:54.490 --> 00:53:54.990
Right.

00:53:54.990 --> 00:53:57.010
So again, here our operations.

00:53:57.010 --> 00:54:01.957
We've got to make an empty doc.

00:54:04.880 --> 00:54:07.650
This is supposed to
take order 1 time.

00:54:07.650 --> 00:54:15.900
We're going to import,
which adds an x on top,

00:54:15.900 --> 00:54:18.750
and that this should
take order n time.

00:54:18.750 --> 00:54:21.300
Notice that this is already
a little suspicious.

00:54:21.300 --> 00:54:23.640
If I were trying to
psychologically diagnose

00:54:23.640 --> 00:54:28.470
my professors, I would look
at this order n with some--

00:54:28.470 --> 00:54:31.860
like, with a raised eyebrow,
because probably what would you

00:54:31.860 --> 00:54:34.440
have in mind if you're talking
about stacks of photographs?

00:54:34.440 --> 00:54:37.230
It would be a stack or a
queue or some data structure

00:54:37.230 --> 00:54:38.490
like that.

00:54:38.490 --> 00:54:40.740
But then insertion would
be like order 1 time.

00:54:40.740 --> 00:54:42.990
So there's clearly something
a little more complicated

00:54:42.990 --> 00:54:44.670
going on.

00:54:44.670 --> 00:54:46.830
OK.

00:54:46.830 --> 00:54:49.395
What's number three is display.

00:54:54.420 --> 00:54:56.490
This has to happen
in order n time.

00:54:56.490 --> 00:54:57.990
This one kind of
makes sense, right,

00:54:57.990 --> 00:54:59.550
because in order to
display n things,

00:54:59.550 --> 00:55:02.500
you kind of expect to
take at least n time.

00:55:02.500 --> 00:55:07.065
And then finally, we
have to move below.

00:55:10.950 --> 00:55:13.080
And this has to take
order log n time.

00:55:15.822 --> 00:55:18.030
And this is going to be the
kicker, right, because we

00:55:18.030 --> 00:55:18.660
really--

00:55:18.660 --> 00:55:21.180
this is somehow not totally
obvious from the way

00:55:21.180 --> 00:55:24.268
that we set up our problem.

00:55:24.268 --> 00:55:26.310
So everybody understand
the problem setup so far?

00:55:26.310 --> 00:55:28.450
We just keep adding
objects with IDs,

00:55:28.450 --> 00:55:30.450
and we need to be able
to insert them on the top

00:55:30.450 --> 00:55:32.010
and then kind of reorder them.

00:55:32.010 --> 00:55:34.710
And the problem has given
you runtime for each

00:55:34.710 --> 00:55:37.910
of these different operations.

00:55:37.910 --> 00:55:39.220
OK.

00:55:39.220 --> 00:55:39.720
Right.

00:55:39.720 --> 00:55:41.030
So here's the thing.

00:55:41.030 --> 00:55:45.110
There's kind of a sequence
aspect to our problem and kind

00:55:45.110 --> 00:55:48.030
of a set aspect to our problem.

00:55:48.030 --> 00:55:49.100
Does that make sense?

00:55:49.100 --> 00:55:50.600
The sequence aspect
to our problem

00:55:50.600 --> 00:55:52.520
is that we're going to have
to display stuff in order n

00:55:52.520 --> 00:55:53.210
time, right?

00:55:53.210 --> 00:55:55.668
We've got to iterate over our
whole list, put stuff on top,

00:55:55.668 --> 00:55:56.720
and so on.

00:55:56.720 --> 00:55:58.250
And the set aspect
is that we'd like

00:55:58.250 --> 00:56:02.290
to move stuff on top of
each other in log n time.

00:56:02.290 --> 00:56:05.420
And the reason that I say that
this is somehow set aspect

00:56:05.420 --> 00:56:09.260
is that I need to be able to put
any x underneath any y, which

00:56:09.260 --> 00:56:11.960
means that I need to be able to
quickly find what layer the x

00:56:11.960 --> 00:56:12.770
and the y is in.

00:56:15.423 --> 00:56:17.090
Any ideas how we can
solve this problem?

00:56:17.090 --> 00:56:19.215
How about from some folks
I haven't heard from yet?

00:56:22.640 --> 00:56:24.398
Yes.

00:56:24.398 --> 00:56:26.947
AUDIENCE: [INAUDIBLE]

00:56:26.947 --> 00:56:28.780
PROFESSOR: Yeah, that's
a really great idea.

00:56:28.780 --> 00:56:30.655
So maybe I'm going to
maintain-- so remember,

00:56:30.655 --> 00:56:31.700
we've talked about--

00:56:31.700 --> 00:56:32.200
let's see.

00:56:32.200 --> 00:56:34.340
In my lecture two
lectures ago, we

00:56:34.340 --> 00:56:39.840
kind of thought of a sorted
list as a set data structure.

00:56:39.840 --> 00:56:41.817
So yeah, that's a fabulous idea.

00:56:41.817 --> 00:56:43.775
Why don't we, for the
set part of our problem--

00:56:48.330 --> 00:56:57.930
we're going to store in
particular a sorted array of--

00:56:57.930 --> 00:57:02.400
and for now, let's think of
it like a sorted array of x's.

00:57:02.400 --> 00:57:05.460
And so this is going to be able
to help us answer questions

00:57:05.460 --> 00:57:10.105
like, is this ID in my
set of images or not?

00:57:10.105 --> 00:57:12.480
But there's also going to be
a second part of my problem,

00:57:12.480 --> 00:57:14.325
which is in addition
to that, I need

00:57:14.325 --> 00:57:16.200
to be able to keep a
different ordering other

00:57:16.200 --> 00:57:18.870
than being just ordered by
x, which is the ordering

00:57:18.870 --> 00:57:21.090
that they're being drawn
on the screen, right?

00:57:21.090 --> 00:57:24.690
That's different than the
ordering of their IDs.

00:57:24.690 --> 00:57:26.274
So for that--

00:57:26.274 --> 00:57:27.316
AUDIENCE: Quick question.

00:57:27.316 --> 00:57:30.230
We're going to be building a
sorted array with nothing in it

00:57:30.230 --> 00:57:32.700
and it's going to be
O of n log n time.

00:57:32.700 --> 00:57:34.450
But that's undefined.

00:57:34.450 --> 00:57:37.526
So can we build a sorted
array with nothing in it?

00:57:37.526 --> 00:57:38.280
PROFESSOR: Hmm.

00:57:38.280 --> 00:57:38.780
OK.

00:57:41.500 --> 00:57:43.990
No, I'm not sure I quite follow.

00:57:43.990 --> 00:57:46.920
AUDIENCE: It's building
an empty sorted array

00:57:46.920 --> 00:57:49.840
O of n log n time, which
is O of 0 log 0 time.

00:57:49.840 --> 00:57:51.000
And log 0 time [INAUDIBLE].

00:57:51.000 --> 00:57:52.120
AUDIENCE: Empty sorted array?

00:57:52.120 --> 00:57:53.912
PROFESSOR: Yeah, building
an empty anything

00:57:53.912 --> 00:57:54.730
that takes 1 time.

00:57:54.730 --> 00:57:55.150
AUDIENCE: Oh.

00:57:55.150 --> 00:57:55.817
PROFESSOR: Yeah.

00:57:55.817 --> 00:57:57.153
AUDIENCE: OK, cool.

00:57:57.153 --> 00:57:57.820
PROFESSOR: Cool.

00:57:57.820 --> 00:57:58.598
All right.

00:57:58.598 --> 00:58:00.640
So in addition to this,
we have a sequence aspect

00:58:00.640 --> 00:58:01.265
of our problem.

00:58:05.790 --> 00:58:08.880
And for that, maybe we'll
use a linked list, right?

00:58:08.880 --> 00:58:13.620
That's a pretty reasonable
sequence data structure.

00:58:13.620 --> 00:58:16.030
And in fact, let's
think for a second.

00:58:16.030 --> 00:58:18.453
Now, we're going to need this
move below operation, right?

00:58:18.453 --> 00:58:20.370
So our linked list is
going to store the order

00:58:20.370 --> 00:58:22.420
of the images in our document.

00:58:22.420 --> 00:58:24.420
In order to move something
below something else,

00:58:24.420 --> 00:58:26.640
we're going to have to splice
an image in between two

00:58:26.640 --> 00:58:28.790
other guys.

00:58:28.790 --> 00:58:31.210
So for convenience, maybe
we have a doubly-linked list

00:58:31.210 --> 00:58:33.030
so that we can move
backward and forward so

00:58:33.030 --> 00:58:34.380
that we can insert stuff.

00:58:34.380 --> 00:58:35.462
Yeah.

00:58:35.462 --> 00:58:36.920
So we'll have a
doubly-linked list.

00:58:45.330 --> 00:58:47.500
OK.

00:58:47.500 --> 00:58:48.000
Right.

00:58:48.000 --> 00:58:50.400
So let's start
solving our problem

00:58:50.400 --> 00:58:53.040
and then thinking
about where things

00:58:53.040 --> 00:58:56.083
are going to go wrong
with our setup here.

00:58:56.083 --> 00:58:57.750
So first of all, I
don't think we really

00:58:57.750 --> 00:58:59.970
have to write
anything for part one

00:58:59.970 --> 00:59:03.330
because making an empty anything
is a pretty easy algorithm.

00:59:03.330 --> 00:59:06.430
On your homework, of course, you
should write that and tell us

00:59:06.430 --> 00:59:08.640
that it takes order 1 time.

00:59:08.640 --> 00:59:11.310
Now, how about
importing an object?

00:59:11.310 --> 00:59:17.890
Remember, that puts it on
the top of our linked list.

00:59:17.890 --> 00:59:22.860
And we have to insert it
into our sorted array, right?

00:59:22.860 --> 00:59:33.150
So when we do that, our insert
algorithm is super simple,

00:59:33.150 --> 00:59:33.720
right?

00:59:33.720 --> 00:59:40.500
We're going to add x to the set,
which we talked about in class

00:59:40.500 --> 00:59:41.670
for a sorted array.

00:59:41.670 --> 00:59:45.144
How long does this take for a
sorted array to add something?

00:59:45.144 --> 00:59:46.325
AUDIENCE: Order n time.

00:59:46.325 --> 00:59:47.700
PROFESSOR: Exactly,
order n time.

00:59:47.700 --> 00:59:49.710
But that's actually
OK because that's

00:59:49.710 --> 00:59:52.980
our criterion for number two.

00:59:52.980 --> 00:59:53.490
Yeah.

00:59:53.490 --> 00:59:57.220
And in addition
to that, we'll put

00:59:57.220 --> 01:00:04.140
x on the top of the
linked list, right?

01:00:04.140 --> 01:00:05.484
That's order 1 time.

01:00:05.484 --> 01:00:06.870
That's easy.

01:00:06.870 --> 01:00:08.370
I'm adding space
because we're going

01:00:08.370 --> 01:00:09.720
to see that we made
a slight mistake

01:00:09.720 --> 01:00:12.345
and that we're going to need to
modify our algorithm a tiny bit

01:00:12.345 --> 01:00:14.470
to solve this problem.

01:00:14.470 --> 01:00:18.745
OK, so how do we display?

01:00:18.745 --> 01:00:20.370
I think that's the
simplest one, right?

01:00:20.370 --> 01:00:22.578
I'm just going to iterate
over the entire linked list

01:00:22.578 --> 01:00:25.313
and just, one by one, output
the order because, remember,

01:00:25.313 --> 01:00:26.730
the whole point
of the linked list

01:00:26.730 --> 01:00:30.870
is to keep track of all
of our documents in order.

01:00:30.870 --> 01:00:41.340
So display, all you have to do
is loop over the linked list.

01:00:41.340 --> 01:00:41.880
OK.

01:00:41.880 --> 01:00:43.770
And the real kicker is
the last part, right,

01:00:43.770 --> 01:00:45.610
which is how do you
move something below?

01:00:45.610 --> 01:00:46.920
So let's think for a minute.

01:00:46.920 --> 01:00:51.160
What's moving below
going to entail?

01:00:51.160 --> 01:00:53.190
So is it going to
affect the set of keys

01:00:53.190 --> 01:00:55.140
that are in my document?

01:00:55.140 --> 01:00:56.260
No, actually, right?

01:00:56.260 --> 01:00:57.677
It's just changing
their ordering,

01:00:57.677 --> 01:01:00.030
but both of those keys
are already there.

01:01:00.030 --> 01:01:00.640
Yeah.

01:01:00.640 --> 01:01:03.240
So the only thing
it's going to do

01:01:03.240 --> 01:01:06.990
is effect where they
are in the sequence.

01:01:06.990 --> 01:01:10.320
But there's something
really, really annoying.

01:01:10.320 --> 01:01:12.060
How do I find something
in this sequence?

01:01:12.060 --> 01:01:14.295
Let's say that I tell
you that document 75 has

01:01:14.295 --> 01:01:18.540
to move below document 352.

01:01:18.540 --> 01:01:20.550
Well, so far in
my data structure,

01:01:20.550 --> 01:01:23.372
what's my only option?

01:01:23.372 --> 01:01:25.080
Does the set tell me
anything about where

01:01:25.080 --> 01:01:27.820
stuff is in the linked list?

01:01:27.820 --> 01:01:28.320
No.

01:01:28.320 --> 01:01:30.800
So how much time is it going
to take for me to find a key?

01:01:30.800 --> 01:01:31.560
AUDIENCE: Order n.

01:01:31.560 --> 01:01:32.760
PROFESSOR: Order n,
right, because I've

01:01:32.760 --> 01:01:34.800
got to loop over this
whole linked list

01:01:34.800 --> 01:01:37.140
and find the item
that I'm missing.

01:01:37.140 --> 01:01:38.970
Is that allowed?

01:01:38.970 --> 01:01:40.470
No, the problem
tells me that I have

01:01:40.470 --> 01:01:43.000
to do this in order log n time.

01:01:43.000 --> 01:01:45.060
So somehow in our head,
we should be thinking,

01:01:45.060 --> 01:01:50.400
OK, well, we want to
kind of use this set here

01:01:50.400 --> 01:01:53.600
to help us find stuff in
the doubly-linked list.

01:01:53.600 --> 01:01:56.130
Does that make sense,
that intuition?

01:01:56.130 --> 01:01:58.060
So here's how we're
going to do it.

01:01:58.060 --> 01:01:59.840
Actually, before I
do that, any ideas?

01:01:59.840 --> 01:02:01.620
How can we solve that?

01:02:01.620 --> 01:02:02.640
Yes.

01:02:02.640 --> 01:02:04.580
AUDIENCE: Maybe the [INAUDIBLE].

01:02:07.700 --> 01:02:09.210
PROFESSOR: That's
a fabulous idea.

01:02:09.210 --> 01:02:10.550
So here's what I'm going to do.

01:02:10.550 --> 01:02:12.170
Remember that when
we make a set,

01:02:12.170 --> 01:02:13.670
we don't just have
to sort the keys.

01:02:13.670 --> 01:02:15.250
We can attach data to our keys.

01:02:15.250 --> 01:02:15.750
Yeah.

01:02:15.750 --> 01:02:21.650
And in particular, I am going to
attach a pointer into my linked

01:02:21.650 --> 01:02:22.430
list.

01:02:22.430 --> 01:02:24.780
Really sneaky answer.

01:02:24.780 --> 01:02:25.940
So let's say that I have--

01:02:25.940 --> 01:02:27.188
let's do a quick example.

01:02:27.188 --> 01:02:28.730
So let's say that
I have my documents

01:02:28.730 --> 01:02:35.455
are 1, 5, 3, 2,
and 7, like that.

01:02:35.455 --> 01:02:37.330
So my linked list is
going to be real simple.

01:02:37.330 --> 01:02:38.240
It's doubly linked.

01:02:38.240 --> 01:02:43.040
See, there's two arrows
here, just like that, right?

01:02:43.040 --> 01:02:47.192
And now my sorted array is going
to store all the keys in order.

01:02:47.192 --> 01:02:48.650
Let's see if I can
do this with me.

01:02:48.650 --> 01:02:52.430
1, 2, 3, 5, 7, right?

01:02:52.430 --> 01:02:55.040
So this is my linked list.

01:02:55.040 --> 01:03:02.030
And here's my sorted array
is going to be 1, 2, 3, 5, 7.

01:03:02.030 --> 01:03:04.520
But then what I'm going to
attach to each of these guys

01:03:04.520 --> 01:03:09.090
is a pointer to the element
of the linked list, right?

01:03:09.090 --> 01:03:12.110
So he is going to additionally
contain an arrow here.

01:03:12.110 --> 01:03:13.820
The 2 will contain
an arrow there.

01:03:13.820 --> 01:03:16.460
The 3 will contain
an arrow there.

01:03:16.460 --> 01:03:21.543
The 5-- this is ugly, I'm sorry.

01:03:21.543 --> 01:03:22.460
Now, here's the thing.

01:03:22.460 --> 01:03:25.250
Let's say that I
remove this 3 here.

01:03:25.250 --> 01:03:29.210
Does that actually
affect 7's pointer?

01:03:29.210 --> 01:03:30.080
No, right?

01:03:30.080 --> 01:03:32.030
So these pointers
remain valid even if I

01:03:32.030 --> 01:03:33.650
edit other parts of the list.

01:03:33.650 --> 01:03:35.710
Really sneaky trick.

01:03:35.710 --> 01:03:36.992
OK.

01:03:36.992 --> 01:03:38.450
So that is going
to be our solution

01:03:38.450 --> 01:03:41.840
to this problem is to store not
just the sorted array of x's

01:03:41.840 --> 01:03:44.070
but x's and pointers.

01:03:44.070 --> 01:03:50.330
So now we have to modify
a tiny bit, right?

01:03:50.330 --> 01:03:54.320
And now what can we do
to move something below?

01:03:54.320 --> 01:03:57.200
Well, it's going to happen in
sort of three steps, right?

01:03:57.200 --> 01:04:02.120
So our first step,
well, we've got to first

01:04:02.120 --> 01:04:06.020
find keys x and y, right?

01:04:06.020 --> 01:04:16.740
So we're going to find x,
vx, and y, vy in the set.

01:04:16.740 --> 01:04:18.970
How long does this take?

01:04:18.970 --> 01:04:21.680
Now we can do it in
binary search, right?

01:04:21.680 --> 01:04:22.250
Exactly.

01:04:22.250 --> 01:04:27.440
So this is O, like that.

01:04:27.440 --> 01:04:30.350
And now what's my next step?

01:04:32.930 --> 01:04:35.000
Well, remember, the
move below operator

01:04:35.000 --> 01:04:37.940
sort of removes x from where it
currently is and then puts it

01:04:37.940 --> 01:04:40.680
underneath y, right?

01:04:40.680 --> 01:04:43.340
And both of those are like
linked list editing operations,

01:04:43.340 --> 01:04:44.150
right?

01:04:44.150 --> 01:04:45.980
So I'm going to kind of--

01:04:45.980 --> 01:04:53.360
if I have a linked list,
like 1, 2, 3, 4, right,

01:04:53.360 --> 01:04:55.395
and let's say I
want to erase the 2,

01:04:55.395 --> 01:04:57.020
I think you guys have
all coded this up

01:04:57.020 --> 01:04:58.187
at some point in your lives.

01:04:58.187 --> 01:05:01.412
Then what I'll do is add
links like that, which

01:05:01.412 --> 01:05:02.870
I can do because
I can move forward

01:05:02.870 --> 01:05:05.140
and backward in the list, right?

01:05:05.140 --> 01:05:06.890
And similarly, if I
want to add something,

01:05:06.890 --> 01:05:08.682
then I'll erase the
links, put it in there,

01:05:08.682 --> 01:05:10.370
and update the links.

01:05:10.370 --> 01:05:12.797
How much time does that take?

01:05:12.797 --> 01:05:14.630
That's just order 1
time, right, because now

01:05:14.630 --> 01:05:17.450
that I have the pointers
to these two locations,

01:05:17.450 --> 01:05:20.450
I'm just doing a lot of
rewiring in my linked list.

01:05:20.450 --> 01:05:21.950
But it's all kind
of local stuff.

01:05:21.950 --> 01:05:24.533
If you're coding in C, this is
where your memory leak happens,

01:05:24.533 --> 01:05:25.790
and your company gets hacked.

01:05:25.790 --> 01:05:27.150
OK.

01:05:27.150 --> 01:05:29.960
Right, so that is what
we're going to do next

01:05:29.960 --> 01:05:33.050
is update the linked list.

01:05:33.050 --> 01:05:34.463
And that takes order 1 time.

01:05:34.463 --> 01:05:36.630
On your homework, if you're
writing out your answer,

01:05:36.630 --> 01:05:39.297
you should have an answer closer
to what I've written on my page

01:05:39.297 --> 01:05:42.030
than the two words that I've
written on the board here.

01:05:42.030 --> 01:05:44.180
And then finally,
in step three--

01:05:46.877 --> 01:05:49.460
well, actually, there is no step
three that I've written here.

01:05:49.460 --> 01:05:52.058
Sorry.

01:05:52.058 --> 01:05:54.350
There's actually two parts
to updating the linked list,

01:05:54.350 --> 01:05:54.850
right?

01:05:54.850 --> 01:06:00.440
One is to remove
the old x position

01:06:00.440 --> 01:06:05.140
and then insert in the
proper position, right?

01:06:05.140 --> 01:06:08.653
And when I do that, my
whole update happened.

01:06:08.653 --> 01:06:10.070
Notice that there's
something kind

01:06:10.070 --> 01:06:12.920
of interesting about this move
below operation, which is that,

01:06:12.920 --> 01:06:15.890
did I actually edit
the set at all?

01:06:15.890 --> 01:06:16.550
No, right?

01:06:16.550 --> 01:06:18.550
That kind of makes sense
because the set is just

01:06:18.550 --> 01:06:19.760
a set of keys in my document.

01:06:19.760 --> 01:06:21.200
And just by changing
the ordering,

01:06:21.200 --> 01:06:22.980
it doesn't affect
what's in my document.

01:06:22.980 --> 01:06:25.860
So somehow, it's a sanity
check that that works out.

01:06:25.860 --> 01:06:27.890
So this entire algorithm
takes how long?

01:06:27.890 --> 01:06:29.570
Well, there's order log n.

01:06:29.570 --> 01:06:30.470
There's order 1.

01:06:30.470 --> 01:06:32.120
And there's another order 1.

01:06:32.120 --> 01:06:33.740
So the whole thing is log n.

01:06:33.740 --> 01:06:35.750
And life is good for
our problem here.

01:06:35.750 --> 01:06:36.860
Yes.

01:06:36.860 --> 01:06:39.440
AUDIENCE: So how we can put
such pointers in real life?

01:06:39.440 --> 01:06:41.065
PROFESSOR: How do we
input such point--

01:06:41.065 --> 01:06:43.232
AUDIENCE: [INAUDIBLE] like
a set with pointers in it

01:06:43.232 --> 01:06:43.790
in real life?

01:06:43.790 --> 01:06:44.540
PROFESSOR: Got it.

01:06:44.540 --> 01:06:46.640
So I only know the
C++ version of this.

01:06:46.640 --> 01:06:49.590
I'm going to get it
wrong for Python.

01:06:49.590 --> 01:06:51.840
But I'm not sure that I quite
understand the question.

01:06:51.840 --> 01:06:54.090
So it's just like pointers
anywhere else in real life.

01:06:54.090 --> 01:06:57.170
So I guess in
Python, what you'll

01:06:57.170 --> 01:06:58.903
do is you'll create
a new, right-- as you

01:06:58.903 --> 01:07:00.320
add these guys to
your set, you'll

01:07:00.320 --> 01:07:01.538
create a new object here.

01:07:01.538 --> 01:07:03.080
And in addition to
that, you're going

01:07:03.080 --> 01:07:05.840
to create a new vx that
you add to the linked list.

01:07:05.840 --> 01:07:08.267
And the pointer is just an
address in memory, right?

01:07:08.267 --> 01:07:09.725
So essentially,
what you'll store--

01:07:09.725 --> 01:07:13.310
AUDIENCE: [INAUDIBLE] linked
list nodes are the pointers.

01:07:13.310 --> 01:07:14.810
PROFESSOR: The
linked list nodes are

01:07:14.810 --> 01:07:20.930
pairs, a pair of an x value
and a-- well, oh, I'm sorry.

01:07:20.930 --> 01:07:22.760
Yeah, actually, I
guess that's right.

01:07:22.760 --> 01:07:24.680
No.

01:07:24.680 --> 01:07:28.422
The linked list just contains
a long list of x's, right?

01:07:28.422 --> 01:07:30.380
But they don't have to
be in contiguous memory.

01:07:30.380 --> 01:07:31.270
That's the only difference.

01:07:31.270 --> 01:07:33.320
So you make them one
linked list item a time.

01:07:33.320 --> 01:07:34.970
But it's just like constructing
any other linked list.

01:07:34.970 --> 01:07:35.470
Yeah.

01:07:35.470 --> 01:07:37.580
In fact, there's
pseudocode in the solutions

01:07:37.580 --> 01:07:39.242
that are distributed.

01:07:39.242 --> 01:07:40.450
So you can take a look there.

01:07:40.450 --> 01:07:40.760
Yeah.

01:07:40.760 --> 01:07:42.177
AUDIENCE: Yeah,
speaking of which,

01:07:42.177 --> 01:07:45.080
for implementing these
database operations,

01:07:45.080 --> 01:07:47.638
can we pseudocode the
algorithms for them?

01:07:47.638 --> 01:07:50.180
PROFESSOR: I think the official
answer is no, that you really

01:07:50.180 --> 01:07:53.090
are supposed to write out in
words what your thing is doing.

01:07:53.090 --> 01:07:54.840
Now, there's a weird
gray area, of course,

01:07:54.840 --> 01:07:55.985
which is that the words
that you write out

01:07:55.985 --> 01:07:58.460
are going to look an
awful lot like pseudocode.

01:07:58.460 --> 01:08:01.120
But you should make an
effort to try and write it

01:08:01.120 --> 01:08:03.620
out a little bit in paragraph
form, be descriptive about it.

01:08:03.620 --> 01:08:04.730
This is a good skill to learn.

01:08:04.730 --> 01:08:06.147
At the beginning
of this course, I

01:08:06.147 --> 01:08:08.720
think it'll feel a little
pedantic at points.

01:08:08.720 --> 01:08:10.970
And that's good
because it should,

01:08:10.970 --> 01:08:13.190
and you should deal with it.

01:08:13.190 --> 01:08:13.910
Yeah.

01:08:13.910 --> 01:08:15.770
But really, try and
write things out

01:08:15.770 --> 01:08:18.920
in a way that captures
your logic rather than just

01:08:18.920 --> 01:08:19.880
Python code.

01:08:19.880 --> 01:08:21.779
Yeah.

01:08:21.779 --> 01:08:22.279
Cool.

01:08:22.279 --> 01:08:22.700
All right.

01:08:22.700 --> 01:08:23.270
So let's see.

01:08:23.270 --> 01:08:26.420
We've got approximately
17 minutes

01:08:26.420 --> 01:08:29.271
left in class, which is
approximately 1/8 of the time

01:08:29.271 --> 01:08:31.729
it took me to figure out the
solution to this last homework

01:08:31.729 --> 01:08:32.460
problem.

01:08:32.460 --> 01:08:33.590
But we'll get started.

01:08:33.590 --> 01:08:37.310
And I've written out a careful
answer because essentially,

01:08:37.310 --> 01:08:40.640
in problem four, I
found myself getting

01:08:40.640 --> 01:08:41.930
stuck in a few little details.

01:08:41.930 --> 01:08:43.638
And so I figured the
way that I write out

01:08:43.638 --> 01:08:45.830
my little hand-scribbled
chicken scratch

01:08:45.830 --> 01:08:49.279
answer online was to
just basically give you

01:08:49.279 --> 01:08:52.071
an internal dialogue
of my brain and how

01:08:52.071 --> 01:08:53.779
I went about solving
these things and all

01:08:53.779 --> 01:08:55.760
the stupid missteps that I made.

01:08:55.760 --> 01:08:56.720
Yeah.

01:08:56.720 --> 01:08:58.130
Because I think that's
actually quite valuable.

01:08:58.130 --> 01:09:00.529
Essentially, it's often you
see in these problems sessions

01:09:00.529 --> 01:09:01.439
just like, oh, here's a problem.

01:09:01.439 --> 01:09:01.740
Here's the answer.

01:09:01.740 --> 01:09:02.100
Here's a problem.

01:09:02.100 --> 01:09:03.015
Here's the answer.

01:09:03.015 --> 01:09:04.640
But the reality is
even your professor,

01:09:04.640 --> 01:09:07.279
especially because he's used
to thinking about rendering,

01:09:07.279 --> 01:09:09.979
occasionally gets confused
about these algorithms

01:09:09.979 --> 01:09:12.439
problems, especially when
they're frankly written

01:09:12.439 --> 01:09:14.720
in a bit of a confusing way.

01:09:14.720 --> 01:09:17.192
And I heard some war stories
about this problem actually

01:09:17.192 --> 01:09:18.109
being on the homework.

01:09:18.109 --> 01:09:20.819
Apparently, I'm in good company.

01:09:20.819 --> 01:09:23.660
So let's take a look at this
last homework problem, 1-4.

01:09:23.660 --> 01:09:26.390
So this is on brick blowing.

01:09:26.390 --> 01:09:29.720
And this is a great exercise
in taking a problem that

01:09:29.720 --> 01:09:32.660
is described in really long,
nasty, useless language

01:09:32.660 --> 01:09:36.029
and then extracting the
two words that matter.

01:09:36.029 --> 01:09:37.850
By the way, I'm making
a joke about that.

01:09:37.850 --> 01:09:40.490
I can tell you that about
82% of my time as a professor

01:09:40.490 --> 01:09:41.960
is spent with
people from industry

01:09:41.960 --> 01:09:44.300
visiting my office with
exactly this kind of scenario

01:09:44.300 --> 01:09:46.670
where it has a really
complicated thing.

01:09:46.670 --> 01:09:49.198
They've been thinking
about their construction

01:09:49.198 --> 01:09:51.740
problem for years, and they have
all these details and tables

01:09:51.740 --> 01:09:52.407
and flow charts.

01:09:52.407 --> 01:09:54.800
And then it turns out that
their problem can be captured

01:09:54.800 --> 01:09:56.225
in about two sentences.

01:09:56.225 --> 01:09:58.400
So it's a good skill
to have and one

01:09:58.400 --> 01:10:00.508
that can get you a lot
of money as a consultant.

01:10:00.508 --> 01:10:02.550
So it's one that's worth
practicing in this class

01:10:02.550 --> 01:10:07.700
even if we're doing it
for Porkland with a wolf

01:10:07.700 --> 01:10:10.080
that blows only to the east.

01:10:10.080 --> 01:10:10.580
OK.

01:10:10.580 --> 01:10:12.038
So what's going on
in this problem?

01:10:12.038 --> 01:10:15.470
There's a wolf, and the
wolf can blow on houses.

01:10:15.470 --> 01:10:19.370
But for some reason, the wolf
likes to blow to the right.

01:10:19.370 --> 01:10:21.470
And to make matters even
more complicated, whoever

01:10:21.470 --> 01:10:23.270
wrote this problem
occasionally ordered things

01:10:23.270 --> 01:10:24.650
from east to west
and other times

01:10:24.650 --> 01:10:26.480
ordered them from west to east.

01:10:26.480 --> 01:10:28.610
If I were your instructor
at the time, that,

01:10:28.610 --> 01:10:32.750
I would have at least gotten
rid of because that's just mean.

01:10:32.750 --> 01:10:34.670
But in any event,
I believe the story

01:10:34.670 --> 01:10:41.570
goes as the apocryphal
house-blowing pork wolf

01:10:41.570 --> 01:10:43.970
story that we all know and
love from our childhood

01:10:43.970 --> 01:10:47.540
is there's a row of
houses, each of which

01:10:47.540 --> 01:10:49.430
has a different
number of bricks.

01:10:49.430 --> 01:10:50.660
Yeah.

01:10:50.660 --> 01:10:55.060
And now there's a wind which
is blowing from west to east.

01:10:55.060 --> 01:10:57.560
I remember all this because I
was staring at it this morning

01:10:57.560 --> 01:10:58.580
in my office.

01:10:58.580 --> 01:11:03.530
And essentially, the wolf, being
the big, bad wolf that he is,

01:11:03.530 --> 01:11:07.010
says, aha, if I, too,
blow from west to east,

01:11:07.010 --> 01:11:11.060
I can knock over more
houses more efficiently

01:11:11.060 --> 01:11:12.410
because the wind is helping me.

01:11:12.410 --> 01:11:13.952
You don't want to
blow into the wind.

01:11:13.952 --> 01:11:15.900
You get your spit in your face.

01:11:15.900 --> 01:11:18.650
OK, so the wolf does that.

01:11:18.650 --> 01:11:22.790
And then what happens is that
the wolf not only knocks down

01:11:22.790 --> 01:11:25.640
the house upon
which the wolf blows

01:11:25.640 --> 01:11:29.420
but also all the houses to
the east of that house that

01:11:29.420 --> 01:11:32.330
have fewer bricks.

01:11:32.330 --> 01:11:33.523
Why, you might ask?

01:11:33.523 --> 01:11:35.690
I don't know, because whoever
wrote this problem was

01:11:35.690 --> 01:11:36.560
being a goofball.

01:11:36.560 --> 01:11:38.430
But that's the basic
setup of this problem.

01:11:38.430 --> 01:11:40.250
And you can see that,
essentially, this

01:11:40.250 --> 01:11:42.500
is just a long, convoluted
way of describing something

01:11:42.500 --> 01:11:43.910
pretty straightforward.

01:11:43.910 --> 01:11:46.280
And so at the end of
the day, the wolf,

01:11:46.280 --> 01:11:48.710
being kind of an
adversarial wolf,

01:11:48.710 --> 01:11:50.840
wants to blow down as
many bricks as possible.

01:11:50.840 --> 01:11:53.390
And we are providing the wolf
with the analytical tools

01:11:53.390 --> 01:11:54.950
needed to do so.

01:11:54.950 --> 01:11:55.515
Yeah.

01:11:55.515 --> 01:11:57.890
So in case you didn't think
we covered anything practical

01:11:57.890 --> 01:12:02.000
in 6.006, now you know
that we actually are doing

01:12:02.000 --> 01:12:05.880
state-of-the-art wolf
brick-blowing pig analysis.

01:12:05.880 --> 01:12:06.380
OK.

01:12:08.670 --> 01:12:09.170
Right.

01:12:09.170 --> 01:12:13.110
So let's do an example because
this is weirdly complicated.

01:12:13.110 --> 01:12:15.217
So in the first
part of the problem,

01:12:15.217 --> 01:12:16.800
it asks you to just
do an example out.

01:12:16.800 --> 01:12:19.215
And I think if I were
psychologically diagnosing

01:12:19.215 --> 01:12:21.590
the person who wrote this
problem, probably the reason is

01:12:21.590 --> 01:12:22.860
that they stood
back, and they said,

01:12:22.860 --> 01:12:24.990
nobody's going to understand
this unless I force

01:12:24.990 --> 01:12:27.370
them to do one example by hand.

01:12:27.370 --> 01:12:27.870
Right?

01:12:27.870 --> 01:12:29.450
And so the basic
problem is asking,

01:12:29.450 --> 01:12:32.900
I could choose to
blow on each house.

01:12:32.900 --> 01:12:36.092
Which one should I choose
to cause the most damage?

01:12:36.092 --> 01:12:38.550
Or in fact, they actually ask
a slightly different problem,

01:12:38.550 --> 01:12:41.510
which is if I were to blow on
each house, how much damage

01:12:41.510 --> 01:12:43.337
would I cause?

01:12:43.337 --> 01:12:44.920
OK, so let's step
through the problem.

01:12:44.920 --> 01:12:56.698
So they give you an example, a
set of numbers, 34, 57, 70, 19,

01:12:56.698 --> 01:12:58.177
48, 2.

01:12:58.177 --> 01:12:59.510
Actually, let's just stop there.

01:12:59.510 --> 01:13:00.650
I don't think there's
any reason to do

01:13:00.650 --> 01:13:02.650
a list of a million numbers
like in the problem.

01:13:02.650 --> 01:13:04.650
That was just like, the
more times you do it,

01:13:04.650 --> 01:13:07.580
the more you convince
yourself how useless 6.006 is.

01:13:07.580 --> 01:13:08.760
OK.

01:13:08.760 --> 01:13:09.260
Right.

01:13:09.260 --> 01:13:13.727
So how much damage does blowing
on house number one cause?

01:13:13.727 --> 01:13:15.060
Well, let's make a little table.

01:13:15.060 --> 01:13:18.170
So if I blow on house
number one, just by default,

01:13:18.170 --> 01:13:19.820
house number one falls.

01:13:19.820 --> 01:13:22.190
I'll pull an x there,
meaning I blew it over.

01:13:22.190 --> 01:13:24.810
And then the rule is
any house to the right

01:13:24.810 --> 01:13:26.638
which has fewer bricks--

01:13:26.638 --> 01:13:28.430
the physics of this
problem drives me nuts.

01:13:28.430 --> 01:13:30.138
I thought about it
for quite a long time,

01:13:30.138 --> 01:13:33.320
and I can't think of a wind
that actually has this property.

01:13:33.320 --> 01:13:37.160
But any house that has fewer
bricks and is to the east

01:13:37.160 --> 01:13:38.120
also gets blown down.

01:13:38.120 --> 01:13:40.100
So 57 does not, right?

01:13:40.100 --> 01:13:41.540
That's bigger than 34.

01:13:41.540 --> 01:13:42.650
Similarly for 70.

01:13:42.650 --> 01:13:46.610
Aha, the 19 goes with the wind.

01:13:46.610 --> 01:13:49.070
48's bigger, and
the 2 goes, right?

01:13:49.070 --> 01:13:53.300
So the element number one of
my array would be 3, right?

01:13:53.300 --> 01:13:55.640
Three things get blown over.

01:13:55.640 --> 01:13:57.710
OK, for the next guy, right?

01:13:57.710 --> 01:13:59.390
So the 57 gets blown over.

01:13:59.390 --> 01:14:02.450
It does not blow over the
34 because my wolf only

01:14:02.450 --> 01:14:04.964
knows how to blow to the right.

01:14:04.964 --> 01:14:07.460
Uh.

01:14:07.460 --> 01:14:09.560
So it does not blow over the 70.

01:14:09.560 --> 01:14:12.740
It does blow over the 19.

01:14:12.740 --> 01:14:14.100
It does blow over the 48.

01:14:14.100 --> 01:14:15.320
It does, right?

01:14:15.320 --> 01:14:16.980
So here, there'd be a 4.

01:14:16.980 --> 01:14:18.980
These numbers do not match
the ones in the notes

01:14:18.980 --> 01:14:21.938
because this is a shorter list
of numbers, I should point out.

01:14:21.938 --> 01:14:23.480
OK, let's do one
more, and then we're

01:14:23.480 --> 01:14:25.770
going to stop because this
is laborious and boring.

01:14:25.770 --> 01:14:28.790
So the 70 blows over everything.

01:14:28.790 --> 01:14:30.320
Yeah.

01:14:30.320 --> 01:14:34.243
But only everything to its
right because, as we all know,

01:14:34.243 --> 01:14:35.285
wolves only blow to the--

01:14:35.285 --> 01:14:36.530
OK, I'll shut up.

01:14:36.530 --> 01:14:40.200
So there's four things
that get blown over here.

01:14:40.200 --> 01:14:41.762
But you guys get
the point, right?

01:14:41.762 --> 01:14:43.220
And so essentially,
this problem is

01:14:43.220 --> 01:14:44.803
asking you to fill
in arrays that look

01:14:44.803 --> 01:14:47.600
like this for your problem.

01:14:47.600 --> 01:14:49.550
Everybody on board
with the problem?

01:14:49.550 --> 01:14:52.370
Now, notice that just by
virtue of doing this example,

01:14:52.370 --> 01:14:53.840
let's think about
this abstractly

01:14:53.840 --> 01:14:55.507
because I think this
is a problem that's

01:14:55.507 --> 01:14:58.580
just coded in so many words
and made-up weird TA garbage.

01:14:58.580 --> 01:15:01.370
But at the end of
the day, this problem

01:15:01.370 --> 01:15:03.830
as an algorithmic
problem is not so bad.

01:15:03.830 --> 01:15:07.025
Essentially, what I'm asking
you to do is I look at that 57,

01:15:07.025 --> 01:15:08.900
and I look to the right,
and I count how many

01:15:08.900 --> 01:15:10.760
things are smaller than 57.

01:15:10.760 --> 01:15:11.870
And I add 1 to it.

01:15:11.870 --> 01:15:13.370
And that's the
number that should go

01:15:13.370 --> 01:15:14.787
in that element in the array.

01:15:14.787 --> 01:15:16.370
So notice that those
three paragraphs,

01:15:16.370 --> 01:15:17.310
that's what they're
communicating.

01:15:17.310 --> 01:15:19.250
You didn't need wolves
blowing and winds

01:15:19.250 --> 01:15:23.100
and trees and houses and Dorothy
and all that kind of stuff.

01:15:23.100 --> 01:15:24.010
Yeah.

01:15:24.010 --> 01:15:24.510
Right.

01:15:24.510 --> 01:15:27.177
So at the end of the day, that's
the problem we can think about.

01:15:27.177 --> 01:15:30.330
And we no longer have to think
about Porkland ever again.

01:15:30.330 --> 01:15:30.830
OK.

01:15:30.830 --> 01:15:32.690
So maybe in the
remaining 10 minutes

01:15:32.690 --> 01:15:35.180
here, I think we can
feasibly do part b.

01:15:35.180 --> 01:15:39.170
And then part c is an
extension of part b.

01:15:39.170 --> 01:15:42.110
I got myself confused on part
c, so the handwritten solutions

01:15:42.110 --> 01:15:44.960
have an incorrect answer,
and then an oops, and then

01:15:44.960 --> 01:15:46.200
a correct answer in it.

01:15:46.200 --> 01:15:48.770
So you can see where
my logic went wrong.

01:15:48.770 --> 01:15:51.770
To be fair, I already
knew the full answer

01:15:51.770 --> 01:15:55.710
and wrote out both because
I thought that was useful.

01:15:55.710 --> 01:15:56.210
OK.

01:15:56.210 --> 01:15:59.275
So in case our problem
wasn't contrived enough,

01:15:59.275 --> 01:16:01.400
we're going to add a little
bit of condition to it.

01:16:01.400 --> 01:16:03.150
And then what we're
going to see in part c

01:16:03.150 --> 01:16:06.080
is that's somehow a stepping
stone toward solving the bigger

01:16:06.080 --> 01:16:07.920
problem.

01:16:07.920 --> 01:16:12.560
So in part c, they say
that a house in Porkland

01:16:12.560 --> 01:16:16.850
is special if it has
one of two properties.

01:16:16.850 --> 01:16:20.660
Either it has no
easterly neighbor,

01:16:20.660 --> 01:16:24.890
meaning it's just
the rightmost house,

01:16:24.890 --> 01:16:28.940
or its adjacent
neighbor to the east

01:16:28.940 --> 01:16:33.680
contains at least as
many bricks as it does.

01:16:33.680 --> 01:16:34.280
Right.

01:16:34.280 --> 01:16:37.940
So what does that mean in
terms of this list of numbers?

01:16:37.940 --> 01:16:40.130
Which one of these
guys is special?

01:16:40.130 --> 01:16:42.960
So the easterly guy is special.

01:16:42.960 --> 01:16:45.530
We just know that by
default. And other

01:16:45.530 --> 01:16:47.480
than that, this
special property is

01:16:47.480 --> 01:16:50.390
saying that the guy
immediately to the right

01:16:50.390 --> 01:16:55.850
has a bigger number or at least
equal to or larger to the one

01:16:55.850 --> 01:16:56.840
right before it.

01:16:56.840 --> 01:16:57.740
Yeah.

01:16:57.740 --> 01:17:02.492
So 57 is bigger than 34,
so this guy is special.

01:17:02.492 --> 01:17:03.950
By the way, the
problem doesn't ask

01:17:03.950 --> 01:17:05.158
you to do this as an example.

01:17:05.158 --> 01:17:07.010
But I totally would if
I were solving this.

01:17:07.010 --> 01:17:08.270
Yeah.

01:17:08.270 --> 01:17:11.090
70 is bigger than
57, so it's special.

01:17:11.090 --> 01:17:13.740
19 is smaller than 70,
so it's not special.

01:17:13.740 --> 01:17:15.110
I'm sorry.

01:17:15.110 --> 01:17:17.810
40 is bigger than 19.

01:17:17.810 --> 01:17:20.930
And I guess 2 is special just
because things on the right

01:17:20.930 --> 01:17:22.520
are special.

01:17:22.520 --> 01:17:25.130
OK, so do we all
get the definition?

01:17:25.130 --> 01:17:25.850
Fabulous.

01:17:25.850 --> 01:17:32.360
So in this problem, now what
we're given is that I guess,

01:17:32.360 --> 01:17:36.860
what, our evil wolf takes
a walk down the block

01:17:36.860 --> 01:17:37.780
and takes a look at--

01:17:37.780 --> 01:17:39.530
counts the number of
bricks at each house.

01:17:39.530 --> 01:17:42.510
And he or she makes
an observation,

01:17:42.510 --> 01:17:45.215
which is that all but
one house is special.

01:17:47.935 --> 01:17:49.560
Now, let's think
about what that means.

01:17:49.560 --> 01:17:51.435
Let's think about the
structure of our array.

01:17:51.435 --> 01:17:54.232
So what happens as I
walk along my right?

01:17:54.232 --> 01:17:56.690
If a house is special, what do
I know about the next house?

01:17:56.690 --> 01:17:58.910
AUDIENCE: It won't get blown if
you blow a special house down.

01:17:58.910 --> 01:17:59.900
PROFESSOR: That's
true, but we're already

01:17:59.900 --> 01:18:00.710
solving the problem there.

01:18:00.710 --> 01:18:03.080
Let's think qualitatively for
a second, like just in terms

01:18:03.080 --> 01:18:04.040
of the number of bricks, right?

01:18:04.040 --> 01:18:05.207
I'm walking down the street.

01:18:05.207 --> 01:18:05.720
I'm looking.

01:18:05.720 --> 01:18:07.940
And the number of
bricks increases

01:18:07.940 --> 01:18:10.515
until I get to the one
house that isn't special.

01:18:10.515 --> 01:18:11.390
AUDIENCE: [INAUDIBLE]

01:18:11.390 --> 01:18:14.180
PROFESSOR: And then it
decreases, potentially,

01:18:14.180 --> 01:18:15.080
or it's the last one.

01:18:15.080 --> 01:18:17.160
And then it starts
increasing again.

01:18:17.160 --> 01:18:17.660
Yeah.

01:18:17.660 --> 01:18:19.610
So in other words,
my array kind of

01:18:19.610 --> 01:18:23.330
looks like the following,
which is that it basically

01:18:23.330 --> 01:18:27.000
has two different pieces
that are both sorted.

01:18:27.000 --> 01:18:27.500
Yeah.

01:18:27.500 --> 01:18:29.270
That's what this long
paragraph is saying.

01:18:29.270 --> 01:18:31.100
It's saying suppose
that the list of houses

01:18:31.100 --> 01:18:32.890
is sorted except for one thing.

01:18:32.890 --> 01:18:33.390
Yeah.

01:18:33.390 --> 01:18:34.807
That's how you
could have said it.

01:18:34.807 --> 01:18:36.450
OK, so here's an example.

01:18:36.450 --> 01:18:44.390
So maybe we have 1, 2, 3, 4, and
then, I don't know, 2, 3, 4, 5.

01:18:44.390 --> 01:18:47.510
So all of these is special
with the exception of this guy,

01:18:47.510 --> 01:18:49.160
sadly for him.

01:18:49.160 --> 01:18:53.090
And so there's kind of
a little dividing line

01:18:53.090 --> 01:18:55.310
that happens, to the left
of which, it's sorted,

01:18:55.310 --> 01:18:56.750
and to the right.

01:18:56.750 --> 01:18:58.160
Yeah.

01:18:58.160 --> 01:18:59.660
OK, and then the
question is, can we

01:18:59.660 --> 01:19:03.110
predict the damage
for each house

01:19:03.110 --> 01:19:05.400
based on this information?

01:19:05.400 --> 01:19:08.090
So I want as output to my
code an array that says,

01:19:08.090 --> 01:19:10.880
this guy causes so much damage,
this guy causes so much damage,

01:19:10.880 --> 01:19:12.440
and so on.

01:19:12.440 --> 01:19:16.298
And I want to get
it in order n time.

01:19:16.298 --> 01:19:17.340
Let's think for a second.

01:19:17.340 --> 01:19:19.030
So how are we going to do that?

01:19:19.030 --> 01:19:20.670
So order n time
means that I can't

01:19:20.670 --> 01:19:24.170
afford to do sorting and all
that kind of fancy stuff.

01:19:24.170 --> 01:19:26.650
So basically, all I can do is
walk up and down the array.

01:19:26.650 --> 01:19:31.320
So we should think a bit about,
what's special about special--

01:19:31.320 --> 01:19:32.670
oy vey.

01:19:32.670 --> 01:19:34.590
What's special about
this configuration

01:19:34.590 --> 01:19:36.360
that we wouldn't normally have?

01:19:36.360 --> 01:19:39.330
AUDIENCE: Anything before the
non-special node should have

01:19:39.330 --> 01:19:40.356
the same--

01:19:40.356 --> 01:19:42.390
or I'm sorry.

01:19:42.390 --> 01:19:43.470
PROFESSOR: Not quite.

01:19:43.470 --> 01:19:45.570
AUDIENCE: Everything
after the non-special node

01:19:45.570 --> 01:19:47.682
causes only one damage.

01:19:47.682 --> 01:19:49.890
PROFESSOR: Yeah, so let's
think about this carefully.

01:19:49.890 --> 01:19:53.560
I think that's right, but
I'm bad at parsing sentences.

01:19:53.560 --> 01:19:55.590
Remember that I always
blow to the right,

01:19:55.590 --> 01:19:58.570
and I only blow short stuff.

01:19:58.570 --> 01:20:04.500
So if I blow on
this 2 here, will

01:20:04.500 --> 01:20:07.920
anything before that vertical
line ever get blown over?

01:20:07.920 --> 01:20:10.170
No, because by property
of being special,

01:20:10.170 --> 01:20:11.670
we know that the
list is increasing.

01:20:11.670 --> 01:20:14.028
But it has to decrease
to blow something over.

01:20:14.028 --> 01:20:16.020
That make sense?

01:20:16.020 --> 01:20:19.050
So for each one of these guys,
the only stuff we can blow

01:20:19.050 --> 01:20:21.168
is in the second array.

01:20:21.168 --> 01:20:22.590
Does that make sense?

01:20:22.590 --> 01:20:23.800
So we made an observation.

01:20:23.800 --> 01:20:25.550
Notice that it is
special to the structure

01:20:25.550 --> 01:20:26.730
that we gave to our problem.

01:20:26.730 --> 01:20:27.230
Yeah.

01:20:27.230 --> 01:20:30.927
And moreover, so in both
parts of this problem,

01:20:30.927 --> 01:20:32.760
we're going to look at
two parts of an array

01:20:32.760 --> 01:20:34.990
and then merge them
together in a smart way.

01:20:34.990 --> 01:20:37.470
Let's look on the
right-hand side.

01:20:37.470 --> 01:20:38.730
Does any of these things--

01:20:38.730 --> 01:20:40.140
if I blow on any
of these houses,

01:20:40.140 --> 01:20:42.490
what's the damage that I do?

01:20:42.490 --> 01:20:43.198
1.

01:20:43.198 --> 01:20:43.740
You see that?

01:20:43.740 --> 01:20:46.320
Because this is an increasing
list, I only blow to the right,

01:20:46.320 --> 01:20:47.830
and it has to get shorter.

01:20:47.830 --> 01:20:48.330
Yeah.

01:20:48.330 --> 01:20:51.040
So if I want partial credit
on my homework problem--

01:20:51.040 --> 01:20:53.910
probably very little partial
credit, but spiritually,

01:20:53.910 --> 01:20:56.370
it's half of your credit--

01:20:56.370 --> 01:21:01.470
we know the second half of my
array is just a bunch of 1's.

01:21:01.470 --> 01:21:04.200
Incidentally, one detail which
I bet would get a minus 1

01:21:04.200 --> 01:21:05.910
on your homework,
we didn't tell you

01:21:05.910 --> 01:21:08.070
that-- all we told you
is that there existed

01:21:08.070 --> 01:21:09.630
one house that wasn't
special, but we

01:21:09.630 --> 01:21:11.220
didn't tell you which one.

01:21:11.220 --> 01:21:13.580
But notice that I can find
it in order n time, right?

01:21:13.580 --> 01:21:15.872
I can just walk along my
array and find the first place

01:21:15.872 --> 01:21:18.000
where it decreases, and
that's a special house.

01:21:18.000 --> 01:21:20.460
So I can kind of assume that
I know where this line is.

01:21:20.460 --> 01:21:23.070
That's kosher.

01:21:23.070 --> 01:21:29.850
So then the only question is,
how do I fill in my array here?

01:21:29.850 --> 01:21:30.747
How do I count--

01:21:30.747 --> 01:21:32.580
and so let's think about
this mathematically

01:21:32.580 --> 01:21:35.542
because porks and blowing and
stuff is kind of confusing.

01:21:35.542 --> 01:21:37.500
So let's think about it
in terms of this array.

01:21:37.500 --> 01:21:39.070
Essentially, what
am I trying to do?

01:21:39.070 --> 01:21:41.640
So for this 2,
I'm trying to look

01:21:41.640 --> 01:21:44.580
in the second half of my array
and find all the numbers here

01:21:44.580 --> 01:21:47.050
that are less than 2, right?

01:21:47.050 --> 01:21:49.650
That's essentially what this
problem is asking you to do.

01:21:49.650 --> 01:21:50.970
You see that?

01:21:50.970 --> 01:21:52.800
OK.

01:21:52.800 --> 01:21:54.420
I'm going to make
one-- so here's

01:21:54.420 --> 01:21:56.640
a simple kind of n
squared algorithm, right,

01:21:56.640 --> 01:22:00.120
which is I could iterate
over every item here

01:22:00.120 --> 01:22:02.370
and just loop over here and
count the number of things

01:22:02.370 --> 01:22:04.405
that are less than that, right?

01:22:04.405 --> 01:22:06.780
That's a double for loop, each
of which could be up to n.

01:22:06.780 --> 01:22:08.168
So that's n squared.

01:22:08.168 --> 01:22:09.210
That's against the rules.

01:22:09.210 --> 01:22:11.270
Can't do it.

01:22:11.270 --> 01:22:13.330
So we need one more
additional observation.

01:22:13.330 --> 01:22:14.940
OK.

01:22:14.940 --> 01:22:16.600
Let's think about
this for a second.

01:22:16.600 --> 01:22:19.830
Let's say I'm the wolf,
the pork-blowing wolf.

01:22:19.830 --> 01:22:22.510
And I walk from one
house to the next.

01:22:22.510 --> 01:22:27.450
And I keep track of what
houses get blown over here.

01:22:27.450 --> 01:22:28.200
Now, what happens?

01:22:28.200 --> 01:22:33.642
As I walk from one house to
the next on the left-hand side,

01:22:33.642 --> 01:22:35.100
they're only getting
taller, right?

01:22:35.100 --> 01:22:38.210
That's what it
means to be special.

01:22:38.210 --> 01:22:42.360
So the houses that get blown
over here, the set of those

01:22:42.360 --> 01:22:43.350
only grows larger.

01:22:43.350 --> 01:22:45.060
Does that make sense?

01:22:45.060 --> 01:22:46.560
Because as these
guys get taller,

01:22:46.560 --> 01:22:48.630
more stuff falls over
on the right-hand side.

01:22:48.630 --> 01:22:51.850
It's like a total goofball
talking about this problem.

01:22:51.850 --> 01:22:55.860
Moreover, these guys
are in sorted order.

01:22:55.860 --> 01:22:57.300
Yeah.

01:22:57.300 --> 01:23:01.140
So what's going to
end up happening

01:23:01.140 --> 01:23:04.142
is that, always, there's
just some interval of houses

01:23:04.142 --> 01:23:05.100
that gets knocked over.

01:23:05.100 --> 01:23:08.832
So for example, the 4 blows
over the 2 and the 3, I guess.

01:23:08.832 --> 01:23:11.040
Notice that that always
starts on the left-hand side.

01:23:11.040 --> 01:23:13.140
And that's because
these guys are sorted.

01:23:13.140 --> 01:23:14.760
The 3 just blows
over the 2, which

01:23:14.760 --> 01:23:15.968
is kind of a subset of the 4.

01:23:15.968 --> 01:23:18.052
This isn't a great example
because those first two

01:23:18.052 --> 01:23:19.410
guys don't blow over anything.

01:23:19.410 --> 01:23:21.730
That make sense?

01:23:21.730 --> 01:23:22.230
Any ideas?

01:23:22.230 --> 01:23:25.110
How could I use that observation
to make an order n algorithm

01:23:25.110 --> 01:23:29.310
for counting blowiness damage?

01:23:32.747 --> 01:23:34.110
I've heard a lot from you.

01:23:34.110 --> 01:23:36.193
Let's hear from some of
our other colleagues here.

01:23:36.193 --> 01:23:38.480
Another person.

01:23:38.480 --> 01:23:38.980
Yes.

01:23:38.980 --> 01:23:40.320
AUDIENCE: Binary search.

01:23:40.320 --> 01:23:42.578
PROFESSOR: Binary search.

01:23:42.578 --> 01:23:43.120
Tell me more.

01:23:43.120 --> 01:23:44.120
What would I search for?

01:23:44.120 --> 01:23:46.080
AUDIENCE: So let's
say you have 4,

01:23:46.080 --> 01:23:48.545
and you move by
yourself from the right,

01:23:48.545 --> 01:23:51.402
take the index of that, and
then you take the number.

01:23:51.402 --> 01:23:53.110
PROFESSOR: It's an
interesting intuition.

01:23:53.110 --> 01:23:54.960
And it's, like, 82% right.

01:23:54.960 --> 01:23:58.327
So to repeat our colleague's
suggestion, which is a good one

01:23:58.327 --> 01:23:59.910
and will make your
code a lot faster--

01:23:59.910 --> 01:24:01.470
in fact, in practical
terms, it would probably

01:24:01.470 --> 01:24:02.040
be about the same.

01:24:02.040 --> 01:24:03.720
It would be I'm going
to move from the left

01:24:03.720 --> 01:24:05.553
to the right-hand side
unless there's a very

01:24:05.553 --> 01:24:06.900
large neighborhood of pigs.

01:24:06.900 --> 01:24:08.520
I'm going to move
across this array.

01:24:08.520 --> 01:24:11.670
I'm going to binary
search this other side

01:24:11.670 --> 01:24:14.265
and find the first house
that shouldn't get blown over

01:24:14.265 --> 01:24:15.300
or something.

01:24:15.300 --> 01:24:18.150
And now I know the total number
of things that get blown over.

01:24:18.150 --> 01:24:19.710
Now, unfortunately
for you, what's

01:24:19.710 --> 01:24:21.720
the runtime of that algorithm?

01:24:21.720 --> 01:24:22.860
n log n, right?

01:24:22.860 --> 01:24:25.080
Because for every
single guy here,

01:24:25.080 --> 01:24:27.973
I incur a binary search
there, which is log n time.

01:24:27.973 --> 01:24:29.640
So you're in the
church, wrong pew here.

01:24:32.022 --> 01:24:33.980
But there's an observation
we haven't used yet,

01:24:33.980 --> 01:24:38.270
which is as I move to the
right, these numbers increase.

01:24:38.270 --> 01:24:38.900
Yeah.

01:24:38.900 --> 01:24:42.140
So what's going to happen to
the index of the stuff that

01:24:42.140 --> 01:24:44.270
gets blown over?

01:24:44.270 --> 01:24:46.190
It's always going
to move this way.

01:24:46.190 --> 01:24:48.440
Is it ever going to
move to the left?

01:24:48.440 --> 01:24:48.980
No.

01:24:48.980 --> 01:24:52.280
So there is a term that we
used in two lectures ago, which

01:24:52.280 --> 01:24:54.530
is a term I never heard
before, but I kind of like it.

01:24:54.530 --> 01:24:57.560
It's called a
two-finger algorithm.

01:24:57.560 --> 01:24:58.220
Yeah.

01:24:58.220 --> 01:24:59.990
What does the
two-finger algorithm do?

01:24:59.990 --> 01:25:00.780
Looks like this.

01:25:00.780 --> 01:25:01.730
Two fingers.

01:25:01.730 --> 01:25:02.930
Yeah.

01:25:02.930 --> 01:25:04.850
So what I'm going
to do is I'm going

01:25:04.850 --> 01:25:07.820
to keep my finger on
the right pointing

01:25:07.820 --> 01:25:11.100
at the very first thing
that doesn't get blown over.

01:25:11.100 --> 01:25:11.690
OK.

01:25:11.690 --> 01:25:14.250
So here, right, the 1
doesn't blow over anything.

01:25:14.250 --> 01:25:15.338
So it stays here.

01:25:15.338 --> 01:25:16.880
I'm going to iterate
to the next guy.

01:25:16.880 --> 01:25:18.980
Does the 2 blow over anything?

01:25:18.980 --> 01:25:21.290
No, by the way the
problem is written.

01:25:21.290 --> 01:25:23.510
Now I'm going to
move this guy here.

01:25:23.510 --> 01:25:25.580
Well, now the 3 blows
over the 2 here.

01:25:25.580 --> 01:25:29.420
So I'm going to move my right
finger one thing to the right

01:25:29.420 --> 01:25:31.370
and move the guy to 4.

01:25:31.370 --> 01:25:33.320
The 4 also doesn't
blow over anything,

01:25:33.320 --> 01:25:34.740
and then I guess I'm done.

01:25:34.740 --> 01:25:36.770
But the basic point
here is that I'm always

01:25:36.770 --> 01:25:39.200
going to be incrementing
two different pointers

01:25:39.200 --> 01:25:40.752
and moving to the right.

01:25:40.752 --> 01:25:41.960
And so what am I going to do?

01:25:41.960 --> 01:25:52.850
If I call this finger
i and this finger j,

01:25:52.850 --> 01:25:55.670
will i or j ever decrease?

01:25:55.670 --> 01:25:56.660
No.

01:25:56.660 --> 01:25:59.090
So if my algorithm is looping
over all of these guys

01:25:59.090 --> 01:26:01.310
and they only ever touch
each of these indices once,

01:26:01.310 --> 01:26:03.850
I'm going to get an
order n technique.

01:26:03.850 --> 01:26:04.685
Yeah.

01:26:04.685 --> 01:26:07.310
And that's going to be the basic
trick to solving this problem.

01:26:07.310 --> 01:26:11.130
Now, I've managed to
talk myself out of time.

01:26:11.130 --> 01:26:12.240
But basically, that's it.

01:26:12.240 --> 01:26:15.590
So what I'm going to do if
we have 10 extra seconds

01:26:15.590 --> 01:26:17.000
is I'm going to initialize.

01:26:22.130 --> 01:26:34.760
Essentially, for each i,
I'm going to increment j

01:26:34.760 --> 01:26:43.250
until the number of
bricks at j is greater

01:26:43.250 --> 01:26:45.310
than the number of bricks at i.

01:26:45.310 --> 01:26:47.840
I guess that should be
greater than or equal to.

01:26:47.840 --> 01:26:48.920
Right?

01:26:48.920 --> 01:26:51.507
And the reason to do that is
that now the number of houses

01:26:51.507 --> 01:26:53.090
that get blown over
is just this index

01:26:53.090 --> 01:26:56.300
j minus the index of
the first guy, right?

01:26:56.300 --> 01:26:59.060
And then I'll increment
i and continue.

01:26:59.060 --> 01:27:01.130
That make any sense?

01:27:01.130 --> 01:27:02.090
Fabulous.

01:27:02.090 --> 01:27:04.490
So I managed by some
miracle to make it

01:27:04.490 --> 01:27:06.210
to almost the end
of this problem set

01:27:06.210 --> 01:27:07.910
minus one part of one problem.

01:27:07.910 --> 01:27:10.885
Of course, that's the hardest
part of the whole problem set.

01:27:10.885 --> 01:27:12.260
But there's an
answer written out

01:27:12.260 --> 01:27:14.540
where, essentially, now
the question is, can you

01:27:14.540 --> 01:27:16.790
do exactly the same algorithm
but I don't give you

01:27:16.790 --> 01:27:22.155
this special assumption that it
increases and then decreases?

01:27:22.155 --> 01:27:24.530
And it's going to be basically
an extension of this idea,

01:27:24.530 --> 01:27:27.580
as we're going to use this plus
a little bit of merge sort.

01:27:27.580 --> 01:27:28.080
OK.

01:27:28.080 --> 01:27:30.000
So with that, we'll
see you guys next week.

01:27:30.000 --> 01:27:30.958
It's always a pleasure.

01:27:30.958 --> 01:27:34.180
And yeah, have a lovely weekend.