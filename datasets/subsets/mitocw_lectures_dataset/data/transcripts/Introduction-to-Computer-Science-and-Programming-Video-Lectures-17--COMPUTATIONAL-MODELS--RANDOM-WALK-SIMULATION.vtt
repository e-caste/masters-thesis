WEBVTT

00:00:00.000 --> 00:00:01.990
OPERATOR: The following content
is provided under a

00:00:01.990 --> 00:00:03.840
Creative Commons license.

00:00:03.840 --> 00:00:06.840
Your support will help MIT
OpenCourseWare continue to

00:00:06.840 --> 00:00:10.530
offer high quality educational
resources for free.

00:00:10.530 --> 00:00:13.390
To make a donation, or view
additional materials from

00:00:13.390 --> 00:00:17.490
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:17.490 --> 00:00:21.640
ocw.mit.edu.

00:00:21.640 --> 00:00:25.210
PROFESSOR: OK, we're now, kind
of on the home stretch, and

00:00:25.210 --> 00:00:28.430
we're entering the part of the
course, that's actually my

00:00:28.430 --> 00:00:30.440
favorite part of the course.

00:00:30.440 --> 00:00:32.770
I can't promise it will be
your favorite part of the

00:00:32.770 --> 00:00:37.180
course, but I hope so, at
least for many of you.

00:00:37.180 --> 00:00:40.930
Throughout the term, we've been
talking about ways to

00:00:40.930 --> 00:00:45.490
solve problems using
computation.

00:00:45.490 --> 00:00:49.450
And one of the key lessons that
I hope you're beginning

00:00:49.450 --> 00:00:53.970
to absorb is that we might use
a completely different way to

00:00:53.970 --> 00:00:57.070
solve a problem with the
computer than we would have

00:00:57.070 --> 00:01:02.600
used if we didn't have
a computer handy.

00:01:02.600 --> 00:01:07.270
In particular, we might often
use brute force, which you've

00:01:07.270 --> 00:01:11.740
never use with a pencil and
paper, we might not do the

00:01:11.740 --> 00:01:15.110
mental gyrations required to
try and formulate a closed

00:01:15.110 --> 00:01:18.550
form solution, but just guess
a bunch of answers using

00:01:18.550 --> 00:01:22.200
successive approximation
until we got there.

00:01:22.200 --> 00:01:25.070
A number of different
techniques.

00:01:25.070 --> 00:01:28.060
And that's really what we're
going to be doing for the rest

00:01:28.060 --> 00:01:30.720
of the term now.

00:01:30.720 --> 00:01:34.610
Except we won't be talking about
algorithms per se, or

00:01:34.610 --> 00:01:36.410
not very much.

00:01:36.410 --> 00:01:41.170
Instead we'll be talking about
more general techniques for

00:01:41.170 --> 00:01:45.340
using computers to solve
problems that

00:01:45.340 --> 00:01:46.610
are actually hard.

00:01:46.610 --> 00:01:48.450
They don't just look
hard, they in many

00:01:48.450 --> 00:01:51.360
cases really are hard.

00:01:51.360 --> 00:01:55.480
The plan of the next set of
lectures is, I want to start

00:01:55.480 --> 00:01:58.810
with a simple example to
give you a flavor of

00:01:58.810 --> 00:02:02.020
some of these issues.

00:02:02.020 --> 00:02:07.010
In the course of going through
that example, I'll illustrate

00:02:07.010 --> 00:02:11.560
some both thinking tools and
some software tools that can

00:02:11.560 --> 00:02:14.790
be used for tackling
the example.

00:02:14.790 --> 00:02:20.290
Then abstract from the example
to try and put in a more

00:02:20.290 --> 00:02:23.210
general framework.

00:02:23.210 --> 00:02:27.910
And then, dive back down and use
that framework to tackle a

00:02:27.910 --> 00:02:31.880
series of other interesting
problems.

00:02:31.880 --> 00:02:35.660
Some things I would like you do
think about learning along

00:02:35.660 --> 00:02:54.730
the way, is moving from an
informal problem description

00:02:54.730 --> 00:03:06.900
to a more formal problem
statement.

00:03:06.900 --> 00:03:09.830
So that's, in part, what we
did with the optimization

00:03:09.830 --> 00:03:10.690
problems, right?

00:03:10.690 --> 00:03:13.980
We looked at an informal
description about optimizing

00:03:13.980 --> 00:03:16.930
your way through the MIT
curriculum, and then could

00:03:16.930 --> 00:03:21.660
formulate it using sigmas and
other bizarre notation to try

00:03:21.660 --> 00:03:25.090
and formalize what we were
really trying to do.

00:03:25.090 --> 00:03:29.180
And we did that as a preamble
to writing any code.

00:03:29.180 --> 00:03:32.460
First understand the problem,
formally, and then

00:03:32.460 --> 00:03:34.040
move on to the code.

00:03:34.040 --> 00:03:36.910
And we won't always
be totally formal.

00:03:36.910 --> 00:03:44.910
I often like to use the word
rigorous instead of formal.

00:03:44.910 --> 00:03:48.380
Implying that it won't look like
math, per se, but it'll

00:03:48.380 --> 00:03:53.330
be precise and relatively
unambiguous.

00:03:53.330 --> 00:03:56.720
So that will be one thing that
I want you to think about as

00:03:56.720 --> 00:04:02.460
we go through these problems.

00:04:02.460 --> 00:04:19.680
Another thing is inventing
computational models.

00:04:19.680 --> 00:04:22.920
Almost every meaningful program
we write is in some

00:04:22.920 --> 00:04:26.900
sense modeling the
actual world.

00:04:26.900 --> 00:04:29.250
For writing a program to figure
out how to keep a

00:04:29.250 --> 00:04:32.500
bridge from falling down, we're
modeling the physics of

00:04:32.500 --> 00:04:34.780
bridges and wind and
things like that.

00:04:34.780 --> 00:04:39.090
If we're writing a program to
try and help us decide what

00:04:39.090 --> 00:04:43.250
stocks to buy or sell, we're
trying to model the stock

00:04:43.250 --> 00:04:45.710
market in some sense.

00:04:45.710 --> 00:04:48.485
If we're trying to figure out
who's going to win the Super

00:04:48.485 --> 00:04:53.350
Bowl, we're modeling football
teams. But almost every

00:04:53.350 --> 00:04:58.450
problem, you build a piece of
software, and you hope that it

00:04:58.450 --> 00:05:02.290
has some ability to
mimic the actual

00:05:02.290 --> 00:05:05.050
situation you care about.

00:05:05.050 --> 00:05:09.400
And it's not the program we care
about, per se, it's the

00:05:09.400 --> 00:05:14.090
world, and the program is merely
a mechanism to help us

00:05:14.090 --> 00:05:16.520
understand the world better.

00:05:16.520 --> 00:05:19.220
And so we're going to ask the
question, have we built a good

00:05:19.220 --> 00:05:23.200
model, in the computation,
that gives us

00:05:23.200 --> 00:05:27.620
insight into the world?

00:05:27.620 --> 00:05:35.330
As we do this, we'll see that
we'll be dealing with and

00:05:35.330 --> 00:05:51.010
exploiting randomness.

00:05:51.010 --> 00:05:54.570
Depending upon your outlook of
life, one of the sad things in

00:05:54.570 --> 00:05:57.610
the world or one of the happy
things in the world, is that

00:05:57.610 --> 00:06:00.610
it's unpredictable.

00:06:00.610 --> 00:06:07.860
And things happen either at
random or seemingly at random.

00:06:07.860 --> 00:06:12.800
It may be that if we had a deep
enough understanding at

00:06:12.800 --> 00:06:17.040
the level of single atoms of
the way the world works, we

00:06:17.040 --> 00:06:20.530
could model the weather and
discover that, in fact, the

00:06:20.530 --> 00:06:24.220
weather patterns are not
random but entirely

00:06:24.220 --> 00:06:25.490
predictable.

00:06:25.490 --> 00:06:29.300
Since we can't do that, we
have to assume that they

00:06:29.300 --> 00:06:33.150
really are random, and we build
models of the weather

00:06:33.150 --> 00:06:37.080
that assume a certain amount
of randomness in it.

00:06:37.080 --> 00:06:39.870
Maybe if we understood the stock
market well enough, we

00:06:39.870 --> 00:06:44.850
could have predicted the
collapse in October.

00:06:44.850 --> 00:06:48.050
But since nobody does understand
it well enough,

00:06:48.050 --> 00:06:50.600
when people model the stock
market they assume that

00:06:50.600 --> 00:06:53.030
there's a certain amount of
randomness, certain amount of

00:06:53.030 --> 00:06:55.620
stochastic things.

00:06:55.620 --> 00:07:00.380
So, as far as we can observe
the world, almost every

00:07:00.380 --> 00:07:05.310
interesting part of the world
has randomness in it.

00:07:05.310 --> 00:07:09.860
And so when we build models, we
will have to build models

00:07:09.860 --> 00:07:13.600
that are, if we want to be
formal, we'll talk about a

00:07:13.600 --> 00:07:18.150
stochastic, which is just a
fancy way of saying they

00:07:18.150 --> 00:07:22.080
incorporate randomness.

00:07:22.080 --> 00:07:25.280
So we haven't yet done that
this semester, but almost

00:07:25.280 --> 00:07:28.310
everything we do from here on
in, we will deal with a

00:07:28.310 --> 00:07:32.940
certain amount of randomness.

00:07:32.940 --> 00:07:36.910
What else are we going
to be looking at?

00:07:36.910 --> 00:07:44.840
We'll be looking at the notion
of making sense of data.

00:07:44.840 --> 00:07:49.210
As we look at, again, modeling
the world, what we discover,

00:07:49.210 --> 00:07:51.730
there's a lot of
data out there.

00:07:51.730 --> 00:07:55.330
If you work at Walmart and
you're trying to decide what

00:07:55.330 --> 00:07:59.660
to stock on the shelves, you're
building a model of

00:07:59.660 --> 00:08:03.510
what the customers might buy
under certain circumstances,

00:08:03.510 --> 00:08:06.170
and that model is going to
take account the entire

00:08:06.170 --> 00:08:10.490
history of what customer's have
bought in the past. And

00:08:10.490 --> 00:08:13.670
that's, if you're Walmart,
a lot of data.

00:08:13.670 --> 00:08:17.270
And so given that you have a
lot of data about what's

00:08:17.270 --> 00:08:20.890
happened in the past, how can
we interpret that, for

00:08:20.890 --> 00:08:25.080
example, to get insight
into the future?

00:08:25.080 --> 00:08:27.320
And we do a lot of that.

00:08:27.320 --> 00:08:30.670
And so we will, for example,
look at how can we draw

00:08:30.670 --> 00:08:34.580
pictures that help us visualize
what's going on with

00:08:34.580 --> 00:08:37.770
the data, rather than trying to
read say, a million numbers

00:08:37.770 --> 00:08:40.250
and inferring something
from them.

00:08:40.250 --> 00:08:43.400
This is a big part of what
people do with computers, is

00:08:43.400 --> 00:08:46.240
try and figure out
how to understand

00:08:46.240 --> 00:08:48.810
large amounts of data.

00:08:48.810 --> 00:08:53.010
And then finally, as we go
through this last third of the

00:08:53.010 --> 00:09:00.910
course, I want to spend
time in evaluating

00:09:00.910 --> 00:09:09.190
the quality of answers.

00:09:09.190 --> 00:09:13.000
It's easy to write a program
that spits out a number, or

00:09:13.000 --> 00:09:15.380
string, or anything else.

00:09:15.380 --> 00:09:18.490
What's hard is to convince
yourself that what it's

00:09:18.490 --> 00:09:23.410
spitting out is actually
telling you the truth.

00:09:23.410 --> 00:09:27.050
And so we're going to look at
the question about, you've

00:09:27.050 --> 00:09:29.240
written a program to do
something relatively

00:09:29.240 --> 00:09:33.220
complicated, you get
an answer out.

00:09:33.220 --> 00:09:35.340
You wouldn't have written the
program if you knew what the

00:09:35.340 --> 00:09:37.790
answer was in advance, right?

00:09:37.790 --> 00:09:40.920
This is not like a high school
physics experiment where you

00:09:40.920 --> 00:09:43.570
know what the answer
should be.

00:09:43.570 --> 00:09:45.975
Here you went to the trouble of
writing the program because

00:09:45.975 --> 00:09:48.070
you didn't know what
the answer was.

00:09:48.070 --> 00:09:51.110
Now the program gives you an
answer, should you believe it,

00:09:51.110 --> 00:09:54.250
or shouldn't you believe it?

00:09:54.250 --> 00:09:56.530
There are people who say, well,
that's what the computer

00:09:56.530 --> 00:09:58.440
said, it must be true.

00:09:58.440 --> 00:10:01.540
By now you all have enough
experience with programs that

00:10:01.540 --> 00:10:05.420
lie to know that's
not the case.

00:10:05.420 --> 00:10:08.220
And so we'll be talking about
how do you go about looking at

00:10:08.220 --> 00:10:11.090
the results, and deciding
whether to

00:10:11.090 --> 00:10:13.100
believe them or not.

00:10:13.100 --> 00:10:17.470
This is a lot of stuff, and
we'll be coming back to this.

00:10:17.470 --> 00:10:22.380
I'll be skipping around
from topic this topic.

00:10:22.380 --> 00:10:26.380
It may seem a little bit random,
but there's actually a

00:10:26.380 --> 00:10:29.670
method to my madness.

00:10:29.670 --> 00:10:32.630
Part of it is, I believe that
repeated exposure to some of

00:10:32.630 --> 00:10:35.090
these things is a good
way to learn it.

00:10:35.090 --> 00:10:38.260
And so I'll be revisiting the
same topic in more and more

00:10:38.260 --> 00:10:41.210
depth as we go, rather
than taking a topic

00:10:41.210 --> 00:10:42.820
and exhausting it.

00:10:42.820 --> 00:10:45.450
So if you think about searches,
this is more of a

00:10:45.450 --> 00:10:49.460
breadth first search than
a depth first search.

00:10:49.460 --> 00:10:51.250
All right.

00:10:51.250 --> 00:10:54.380
Think about these things
as we now go through

00:10:54.380 --> 00:10:56.340
the next set of lectures.

00:10:56.340 --> 00:10:59.250
So, on for the first example.

00:10:59.250 --> 00:11:07.310
Consider the following
situation: a seriously drunken

00:11:07.310 --> 00:11:10.300
university student, and I
emphasize university as

00:11:10.300 --> 00:11:13.370
opposed to institute here,
is standing in

00:11:13.370 --> 00:11:15.000
the middle of a field.

00:11:15.000 --> 00:11:18.960
Every second, he takes a step in
some direction or another,

00:11:18.960 --> 00:11:23.260
but, you know, just sort of
pretty random, because he's

00:11:23.260 --> 00:11:27.140
really out of it.

00:11:27.140 --> 00:11:30.230
But the field is constrained
that for the moment we'll

00:11:30.230 --> 00:11:32.940
assume that, well, we'll
come back to that.

00:11:32.940 --> 00:11:34.750
Now I'm going to ask you
just a question.

00:11:34.750 --> 00:11:37.800
So you've got this student who,
every second or so, takes

00:11:37.800 --> 00:11:40.370
a step in some direction
or another.

00:11:40.370 --> 00:11:45.270
If the student did this for 500
seconds or 1000 seconds,

00:11:45.270 --> 00:11:48.180
how far do you expect
the student would be

00:11:48.180 --> 00:11:50.470
from where he started?

00:11:50.470 --> 00:11:52.320
And I say he because
most of the drunks

00:11:52.320 --> 00:11:56.200
are, of course, males.

00:11:56.200 --> 00:11:57.540
Anybody want to, what
do you think?

00:11:57.540 --> 00:11:59.620
STUDENT: Back where
he started.

00:11:59.620 --> 00:12:01.850
PROFESSOR: So we have a thing
that, on average, and of

00:12:01.850 --> 00:12:04.210
course since there's randomness
it won't be the

00:12:04.210 --> 00:12:06.470
same every time.

00:12:06.470 --> 00:12:09.840
Pretty much where he started.

00:12:09.840 --> 00:12:10.890
Let me ask a question.

00:12:10.890 --> 00:12:13.970
So if you believe that, you
believe he'd be probably the

00:12:13.970 --> 00:12:19.400
same distance in 1000 seconds
as in 500 seconds.

00:12:19.400 --> 00:12:22.230
Anyone want to posit the
counterposition?

00:12:22.230 --> 00:12:24.980
That in fact, the longer the
clock runs, the further the

00:12:24.980 --> 00:12:29.890
student will be from
where he started?

00:12:29.890 --> 00:12:31.460
Nobody?

00:12:31.460 --> 00:12:32.870
All right, what do you think?

00:12:32.870 --> 00:12:49.810
STUDENT: [INAUDIBLE]

00:12:49.810 --> 00:12:52.100
PROFESSOR: All right, that's
a good answer.

00:12:52.100 --> 00:12:57.090
So the answer there was, well,
if you asked for your best

00:12:57.090 --> 00:13:00.910
guess of where the student was,
the best guess is where

00:13:00.910 --> 00:13:03.000
the student started.

00:13:03.000 --> 00:13:07.720
On the other hand, if you ask
how far was the student from

00:13:07.720 --> 00:13:11.560
where he started, the best
guess wouldn't be zero.

00:13:11.560 --> 00:13:15.250
That's a great answer, because
it addresses the fact that you

00:13:15.250 --> 00:13:18.800
have to be very careful what
question you're asking.

00:13:18.800 --> 00:13:20.960
And there are subtle differences
between those two

00:13:20.960 --> 00:13:24.780
questions, and they might have
very different answers.

00:13:24.780 --> 00:13:29.760
So that's part of that first
step, going from an informal

00:13:29.760 --> 00:13:33.730
description, to trying to
formalize it or be more

00:13:33.730 --> 00:13:36.840
rigorous about what is
exactly the problem

00:13:36.840 --> 00:13:40.020
you're trying to solve.

00:13:40.020 --> 00:13:43.400
All right, we'll take a vote.

00:13:43.400 --> 00:13:47.530
And everyone has to vote here,
because it's not a democracy

00:13:47.530 --> 00:13:51.240
where you're allowed
to not vote.

00:13:51.240 --> 00:13:56.310
And the question I'm asking
is, is the expected

00:13:56.310 --> 00:14:03.080
difference, does the expected
distance from the origin grow

00:14:03.080 --> 00:14:10.520
over time, or remain
constant, roughly?

00:14:10.520 --> 00:14:14.180
Who thinks it grows over time?

00:14:14.180 --> 00:14:18.340
Who thinks it remains
constant?

00:14:18.340 --> 00:14:21.290
Well, the constants have it.

00:14:21.290 --> 00:14:23.690
But just because that's the
way most people vote, it

00:14:23.690 --> 00:14:26.630
doesn't make it true.

00:14:26.630 --> 00:14:30.660
Now let's find out what
the actual truth is.

00:14:30.660 --> 00:14:33.190
All right.

00:14:33.190 --> 00:14:38.910
So let's start by sketching a
simple model of the situation.

00:14:38.910 --> 00:14:43.370
And, one of the things I want
to stress as we do these

00:14:43.370 --> 00:14:55.520
things, in developing anything
of this nature, start simple.

00:14:55.520 --> 00:14:57.120
So start with some simple

00:14:57.120 --> 00:15:00.280
approximation to the real problem.

00:15:00.280 --> 00:15:05.050
Check that out, and then, if it
turns out not to be a good

00:15:05.050 --> 00:15:09.840
enough model of the world, add
some complications, but don't

00:15:09.840 --> 00:15:11.690
start with the complicated
model.

00:15:11.690 --> 00:15:14.360
Always start with the
simple model.

00:15:14.360 --> 00:15:16.860
So I'm going to start with
the simple model.

00:15:16.860 --> 00:15:20.150
And I'm going to assume, as
we've seen before, that we

00:15:20.150 --> 00:15:30.490
have Cartesian coordinates and
that the player is, or the

00:15:30.490 --> 00:15:33.580
drunk is, standing on a field
that has been cut to resemble

00:15:33.580 --> 00:15:36.080
a piece of graph paper.

00:15:36.080 --> 00:15:38.560
They got the groundskeeper from
Fenway Park or something,

00:15:38.560 --> 00:15:41.760
there, and it looks like a
beautiful piece of paper.

00:15:41.760 --> 00:15:46.630
Furthermore, I'm going to assume
for simplicity, that

00:15:46.630 --> 00:15:50.900
the student can only go in one
of four directions: north,

00:15:50.900 --> 00:15:57.770
south, east, or west. OK, we
could certainly generalize

00:15:57.770 --> 00:16:00.420
that, and we will, to something
more complicated,

00:16:00.420 --> 00:16:03.510
but for now we'll
keep it simple.

00:16:03.510 --> 00:16:05.840
And we'll try and go
to the board and

00:16:05.840 --> 00:16:08.240
draw what might happen.

00:16:08.240 --> 00:16:14.140
So the student starts here and
takes a step in one direction

00:16:14.140 --> 00:16:15.850
or another.

00:16:15.850 --> 00:16:19.770
So as the mathematicians say,
without loss of generality,

00:16:19.770 --> 00:16:25.300
let's just assume that the
first step is here.

00:16:25.300 --> 00:16:31.580
Well what we know for sure, is
after one step the student is

00:16:31.580 --> 00:16:35.880
further from the origin
than at the start.

00:16:35.880 --> 00:16:38.530
But, that doesn't
tell us a lot.

00:16:38.530 --> 00:16:41.110
What happens after
the second step?

00:16:41.110 --> 00:16:44.010
Well, the student could come
back to the origin and be

00:16:44.010 --> 00:16:49.630
closer, that's one possibility,
the student could

00:16:49.630 --> 00:16:54.690
go up here, in which case the
student is a little further,

00:16:54.690 --> 00:16:58.730
the student could go down
here, in which case the

00:16:58.730 --> 00:17:02.790
student is a little further, or
the student could go over

00:17:02.790 --> 00:17:06.550
here, in which case the student
is twice as far.

00:17:06.550 --> 00:17:09.480
So we see for the second step,
three times out of four you

00:17:09.480 --> 00:17:12.530
get further away.

00:17:12.530 --> 00:17:15.110
What happens in the
third step?

00:17:15.110 --> 00:17:17.810
So let's look at this one.

00:17:17.810 --> 00:17:22.310
Well, the student could come
here, which is closer, could

00:17:22.310 --> 00:17:27.090
come here, which is closer,
could go there, which is

00:17:27.090 --> 00:17:29.620
further, or could go there,
which is further.

00:17:29.620 --> 00:17:33.910
So the third step, with equal
probability, the student is

00:17:33.910 --> 00:17:38.430
further or closer if the
student is here.

00:17:38.430 --> 00:17:40.040
And we could continue.

00:17:40.040 --> 00:17:46.240
So as you can see, it gets
pretty complicated, as you

00:17:46.240 --> 00:17:49.420
project how far out it
could always get.

00:17:49.420 --> 00:17:52.550
All right, and this is symmetric
to this, but this is

00:17:52.550 --> 00:17:55.640
yet a different case.

00:17:55.640 --> 00:18:00.540
So, this sort of says, OK, I'm
going to get tired of drawing

00:18:00.540 --> 00:18:02.370
things on the board.

00:18:02.370 --> 00:18:05.410
So, being who I am, I
say, let's write a

00:18:05.410 --> 00:18:07.330
program to do this.

00:18:07.330 --> 00:18:11.620
And in fact, what I'm going to
write a program to do, is

00:18:11.620 --> 00:18:28.360
simulate what is called
a random walk.

00:18:28.360 --> 00:18:30.540
And these will be two themes
we're going to spend

00:18:30.540 --> 00:18:31.630
a lot of time on.

00:18:31.630 --> 00:18:37.610
Simulation, where we try and
build the model that pretends

00:18:37.610 --> 00:18:41.870
it's the real world and
simulates what goes on, and a

00:18:41.870 --> 00:18:43.870
random walk.

00:18:43.870 --> 00:18:46.880
Now, I'm giving you the classic
story about a random

00:18:46.880 --> 00:18:50.850
walk which you can visualize, at
least I hope, but as we'll

00:18:50.850 --> 00:18:55.330
see, random walks are very
general, and are used to

00:18:55.330 --> 00:18:59.630
address a lot of real problems.
So we'll write this

00:18:59.630 --> 00:19:04.250
program, and I want to start
by thinking about designing

00:19:04.250 --> 00:19:07.030
the structure of the solution.

00:19:07.030 --> 00:19:11.590
Because one of the things I'm
trying to do in this next set

00:19:11.590 --> 00:19:16.140
of lectures is bring together
a lot of the things we have

00:19:16.140 --> 00:19:19.610
talked about over the course of
the semester, about how we

00:19:19.610 --> 00:19:23.410
go about designing and building
programs. Trying to

00:19:23.410 --> 00:19:26.220
give you a case study,
if you will.

00:19:26.220 --> 00:19:30.030
So let's begin in line with what
Professor Grimson talked

00:19:30.030 --> 00:19:32.980
about, about thinking about what
might be the appropriate

00:19:32.980 --> 00:19:36.490
data abstractions.

00:19:36.490 --> 00:19:41.450
Well, so, I think it would be
good to have a location, since

00:19:41.450 --> 00:19:44.910
after all the whole problem
talks about

00:19:44.910 --> 00:19:49.190
where the drunk is.

00:19:49.190 --> 00:19:52.780
I decided I also wanted to
introduce an abstraction

00:19:52.780 --> 00:19:57.880
called compass point to capture
the notion that the

00:19:57.880 --> 00:20:03.750
student is going north, south,
east, or west. And later,

00:20:03.750 --> 00:20:06.440
maybe I'll decide that needs
to be more complicated and

00:20:06.440 --> 00:20:11.100
that the student can go north
by northwest, or maybe all

00:20:11.100 --> 00:20:12.690
sorts of things.

00:20:12.690 --> 00:20:17.260
But that it would probably pay
to separate the notion of

00:20:17.260 --> 00:20:21.430
direction, which is what
this is, from location.

00:20:21.430 --> 00:20:23.410
Maybe I should have called
this direction instead of

00:20:23.410 --> 00:20:26.220
compass point, but I didn't.

00:20:26.220 --> 00:20:29.570
But, I thought about the problem
and said, well, these

00:20:29.570 --> 00:20:31.610
things really are separate
locations.

00:20:31.610 --> 00:20:35.020
Where you are and where you
might head from there are not

00:20:35.020 --> 00:20:39.130
the same, so let's
separate them.

00:20:39.130 --> 00:20:43.080
Then I said, well of course,
there is this notion that the

00:20:43.080 --> 00:20:48.590
person is in the field, so maybe
I want to have field as

00:20:48.590 --> 00:20:49.870
a separate thing.

00:20:49.870 --> 00:20:54.120
So think of that as the whole
Cartesian plain, as opposed to

00:20:54.120 --> 00:20:58.420
a point in the plane, which
is what the location is.

00:20:58.420 --> 00:21:03.500
And finally, I better have a
drunk, because after all this

00:21:03.500 --> 00:21:07.340
problem is all about drunks.

00:21:07.340 --> 00:21:10.180
All right, so we're now going
to look at some code.

00:21:10.180 --> 00:21:14.790
I made this code as simple as
I could to illustrate the

00:21:14.790 --> 00:21:17.730
points I wanted to illustrate.

00:21:17.730 --> 00:21:22.050
This means I left out a lot
of things that ought to be

00:21:22.050 --> 00:21:23.900
included in a good program.

00:21:23.900 --> 00:21:25.330
So I want to just warn you.

00:21:25.330 --> 00:21:27.830
So for example, I've already
told you that when I build

00:21:27.830 --> 00:21:31.530
data abstractions, I always put
in an underbar underbar

00:21:31.530 --> 00:21:35.540
str function so that I can print
them when I'm debugging.

00:21:35.540 --> 00:21:38.540
Well, you won't see that in this
code, because I felt it

00:21:38.540 --> 00:21:41.380
just cluttered the code
up to make the points.

00:21:41.380 --> 00:21:43.740
You'll see less defensive
programming than I would

00:21:43.740 --> 00:21:45.110
normally use.

00:21:45.110 --> 00:21:47.620
But again I wanted to sort of
pare things down to the

00:21:47.620 --> 00:21:51.270
essence, since the essence is,
all by itself, probably

00:21:51.270 --> 00:21:58.020
confusing enough.

00:21:58.020 --> 00:22:00.000
All right.

00:22:00.000 --> 00:22:00.970
So let's look at it.

00:22:00.970 --> 00:22:04.920
You have this on your
double-sided handout.

00:22:04.920 --> 00:22:09.550
This is on side 1one So at the
top, you'll see that I'm

00:22:09.550 --> 00:22:11.720
importing three things.

00:22:11.720 --> 00:22:14.640
Well, math you've heard about.

00:22:14.640 --> 00:22:16.180
And I'm importing that
because I'm going to

00:22:16.180 --> 00:22:18.440
need a square root.

00:22:18.440 --> 00:22:22.210
Random, you haven't
heard about.

00:22:22.210 --> 00:22:27.720
This is a package that lets me
choose things at random, and

00:22:27.720 --> 00:22:31.820
I'll show you some of the ways
we can use it, but it actually

00:22:31.820 --> 00:22:43.560
provides something that
technically is pseudo-random.

00:22:43.560 --> 00:22:46.640
Which means that as far as we
can tell, it's behaving

00:22:46.640 --> 00:22:51.400
randomly, but since the computer
is in itself a

00:22:51.400 --> 00:22:56.850
deterministic machine, it's
not really random.

00:22:56.850 --> 00:22:59.910
But it's so close to random that
we might as well pretend

00:22:59.910 --> 00:23:04.080
it is, you can't tell
that it isn't.

00:23:04.080 --> 00:23:05.700
So we'll import random.

00:23:05.700 --> 00:23:08.590
That will let us make random
guesses of things like, give

00:23:08.590 --> 00:23:11.300
me a random number
between 0 and 1.

00:23:11.300 --> 00:23:13.500
And it will give you
a random number.

00:23:13.500 --> 00:23:16.460
And finally something
called Pylab.

00:23:16.460 --> 00:23:19.770
Anyone here use Matlab?

00:23:19.770 --> 00:23:23.840
All right, well then, you'll
find Pylab kind of comforting.

00:23:23.840 --> 00:23:32.500
Pylab brings into Python a lot
of the features of Matlab And

00:23:32.500 --> 00:23:34.450
if you haven't used Matlab,
don't worry, because we'll

00:23:34.450 --> 00:23:36.090
explain everything.

00:23:36.090 --> 00:23:39.660
For the purposes of this set
of lectures, the next few

00:23:39.660 --> 00:23:42.090
lectures, at least, the only
thing we're going to get out

00:23:42.090 --> 00:23:46.200
of this is a bunch of tools
for drawing pretty graphs.

00:23:46.200 --> 00:23:48.760
And we won't get to those today,
probably, so don't

00:23:48.760 --> 00:23:50.840
worry about it.

00:23:50.840 --> 00:23:55.570
But it's a nice package, which
you'll be glad to learn.

00:23:55.570 --> 00:23:59.230
OK, now let's move on to the
code, which has got things

00:23:59.230 --> 00:24:01.850
that should look familiar
to you.

00:24:01.850 --> 00:24:03.290
And I know there used
to be a laser -- ah,

00:24:03.290 --> 00:24:05.380
here's the laser pointer.

00:24:05.380 --> 00:24:12.790
So we'll see at the top
location, it is a class.

00:24:12.790 --> 00:24:16.200
By now you've gotten as familiar
as you want to be in

00:24:16.200 --> 00:24:18.200
many senses, with classes.

00:24:18.200 --> 00:24:22.260
It's got an underbar underbar
init that gives me,

00:24:22.260 --> 00:24:24.530
essentially, a point with
an x-coordinate and a

00:24:24.530 --> 00:24:28.290
y-coordinate.

00:24:28.290 --> 00:24:32.730
It's got get coords, the third
function, or method, and what

00:24:32.730 --> 00:24:34.930
you can see what that does
is it's returning a

00:24:34.930 --> 00:24:36.860
tuple of two values.

00:24:36.860 --> 00:24:41.030
I could have had it get x and
get y, but it turned out, in

00:24:41.030 --> 00:24:43.800
fact, my first iteration of this
it did have a get x and

00:24:43.800 --> 00:24:48.020
get y, and when I looked at the
code that was using it, I

00:24:48.020 --> 00:24:51.840
realized whenever I got one,
I wanted both, and it just

00:24:51.840 --> 00:24:54.980
seemed kind of silly, so I did
something that made the using

00:24:54.980 --> 00:24:59.080
code a little bit better.

00:24:59.080 --> 00:25:02.360
It's got get distance,
the last method.

00:25:02.360 --> 00:25:05.470
You saw this in Professor
Grimson's lecture, where he

00:25:05.470 --> 00:25:09.090
used the Pythagorean theorem
to basically compute the

00:25:09.090 --> 00:25:13.050
distance on a hypotenuse, to
tell you how far a point was

00:25:13.050 --> 00:25:15.290
from the origin.

00:25:15.290 --> 00:25:17.410
That's why I wanted math.

00:25:17.410 --> 00:25:20.600
And then the one thing it has
that it's unlike the example

00:25:20.600 --> 00:25:22.980
you saw from Professor
Grimson, was

00:25:22.980 --> 00:25:25.510
up here, this move.

00:25:25.510 --> 00:25:29.740
And this basically takes a
point, a location, and an x-

00:25:29.740 --> 00:25:34.690
and a y- coordinate, and returns
another location, in

00:25:34.690 --> 00:25:40.730
which I've incremented the
x and the y, perhaps

00:25:40.730 --> 00:25:43.600
incrementing by 0.

00:25:43.600 --> 00:25:47.960
And so now you can see how I'm
going to be able to mimic 1

00:25:47.960 --> 00:25:53.930
step or any number of steps
by using this move.

00:25:53.930 --> 00:25:59.680
Any questions about this?

00:25:59.680 --> 00:26:01.700
Great, all right.

00:26:01.700 --> 00:26:06.230
The next one you'll see
is compass point.

00:26:06.230 --> 00:26:08.230
Remember, this was the
abstraction that was going to

00:26:08.230 --> 00:26:12.230
let me conveniently deal
with directions.

00:26:12.230 --> 00:26:18.060
The first thing you'll see is,
there's a global variable in

00:26:18.060 --> 00:26:22.980
the sense that it's external
to any of the methods, and

00:26:22.980 --> 00:26:28.460
you'll note it's not self dot
possibles, but just possibles.

00:26:28.460 --> 00:26:30.210
Because I don't want
a new copy of

00:26:30.210 --> 00:26:34.110
this for every instance.

00:26:34.110 --> 00:26:37.810
And this tells me the possible
directions, which I've

00:26:37.810 --> 00:26:40.930
abbreviated as n, s, e, and w.

00:26:40.930 --> 00:26:43.970
And I leave it to you to
figure out what those

00:26:43.970 --> 00:26:47.540
abbreviations stand for.

00:26:47.540 --> 00:26:52.900
Then I've got init, which takes
a point and it first

00:26:52.900 --> 00:26:59.010
checks to see if the point
is in self dot possibles.

00:26:59.010 --> 00:27:01.460
Should I have bothered
saying self?

00:27:01.460 --> 00:27:03.690
Do I need to write self there?

00:27:03.690 --> 00:27:05.460
This is a test of classes.

00:27:05.460 --> 00:27:09.240
It'll work.

00:27:09.240 --> 00:27:11.760
What do you think?

00:27:11.760 --> 00:27:16.270
Who thinks I need to write self,
and who thinks I don't?

00:27:16.270 --> 00:27:19.850
Who thinks I need to write
self, raise your hand?

00:27:19.850 --> 00:27:22.460
Who thinks I don't need
to write self?

00:27:22.460 --> 00:27:24.490
The don't needs have it.

00:27:24.490 --> 00:27:27.750
So in an act of intense bravery,
since I have not run

00:27:27.750 --> 00:27:33.010
it without this, we'll see what
happens when it comes

00:27:33.010 --> 00:27:38.050
time to run the program.

00:27:38.050 --> 00:27:42.960
So if point is in possibles, it
will take self dot p t will

00:27:42.960 --> 00:27:45.690
be assigned p t.

00:27:45.690 --> 00:27:49.610
Otherwise, I'll raise
a value error.

00:27:49.610 --> 00:27:52.790
And this is a little piece of
programming, and what I

00:27:52.790 --> 00:27:56.420
typically do at a minimum, when
I raise these exceptions,

00:27:56.420 --> 00:28:00.700
is make sure that it says
where it's coming from.

00:28:00.700 --> 00:28:04.210
So this says it's gonna raise
this value error in the method

00:28:04.210 --> 00:28:06.680
compass point dot underbar
underbar

00:28:06.680 --> 00:28:09.300
init, underbar underbar.

00:28:09.300 --> 00:28:13.140
This is so when I run the
program, and I see a message,

00:28:13.140 --> 00:28:15.320
I don't have to scratch my head
figuring out where did

00:28:15.320 --> 00:28:17.690
things go wrong?

00:28:17.690 --> 00:28:21.680
So just a convention
I follow a lot.

00:28:21.680 --> 00:28:25.510
And then I've got move here.

00:28:25.510 --> 00:28:30.730
And I'll move self some
distance, and you can

00:28:30.730 --> 00:28:31.570
see what I'm doing.

00:28:31.570 --> 00:28:41.000
If self is north, I'm going
to return 0 in distance.

00:28:41.000 --> 00:28:45.200
So I'm now getting a tuple,
which will basically be used

00:28:45.200 --> 00:28:49.190
to say, all right, we're going
to implement x by 0 and y by

00:28:49.190 --> 00:28:51.630
distance, which is
what you think of

00:28:51.630 --> 00:28:54.670
about moving due north.

00:28:54.670 --> 00:28:59.820
And if it's south, we'll
increment x by 0, and

00:28:59.820 --> 00:29:05.560
increment y by minus distance,
heading down the graph.

00:29:05.560 --> 00:29:11.220
And similarly for east and west.
And in the sad event I

00:29:11.220 --> 00:29:13.930
call this with something that's
not north, south, east,

00:29:13.930 --> 00:29:20.390
or west, again I'll raise
an exception.

00:29:20.390 --> 00:29:22.820
OK, little bit at a time.

00:29:22.820 --> 00:29:25.080
So I hope that nothing here
looks complicated.

00:29:25.080 --> 00:29:29.850
In fact, it should all
look kind of boring.

00:29:29.850 --> 00:29:34.490
Now we'll get to field,
which should look

00:29:34.490 --> 00:29:38.950
a little less boring.

00:29:38.950 --> 00:29:43.650
So now I've got a field.

00:29:43.650 --> 00:29:53.080
And, well, before I get to
field, I want to go back to

00:29:53.080 --> 00:29:56.450
something about the first 2
abstractions: compass point

00:29:56.450 --> 00:29:58.000
and location.

00:29:58.000 --> 00:30:02.950
Whenever we design one of these
abstractions, we're

00:30:02.950 --> 00:30:06.880
making some things possible and
some things impossible.

00:30:06.880 --> 00:30:10.850
We're making decisions, and
so what decisions are

00:30:10.850 --> 00:30:16.280
encapsulated in these
first two classes?

00:30:16.280 --> 00:30:22.430
Well, one decision is that it's
a 2-dimensional space.

00:30:22.430 --> 00:30:24.440
I basically said we've
got x and y and

00:30:24.440 --> 00:30:26.580
that's all we've got.

00:30:26.580 --> 00:30:29.690
This student cannot fly.

00:30:29.690 --> 00:30:33.610
The student cannot dig a hole
and go into the ground, we're

00:30:33.610 --> 00:30:37.960
only moving in 2 dimensions,
so that's fixed.

00:30:37.960 --> 00:30:41.520
The other decision I made is
that this student can only

00:30:41.520 --> 00:30:45.720
move in 1 of 4 directions.

00:30:45.720 --> 00:30:48.510
So, couple of good
things here.

00:30:48.510 --> 00:30:50.700
One, I've simplified the world,
which will make it

00:30:50.700 --> 00:30:53.940
easier for us to see
what's going on.

00:30:53.940 --> 00:30:57.730
But two, I know where I've
made those decisions, and

00:30:57.730 --> 00:31:01.680
later if I want to go back and
say, you know it'd be fun if

00:31:01.680 --> 00:31:04.990
the student could fly, let's
say we're a drunken pigeon

00:31:04.990 --> 00:31:07.630
instead of a drunken student.

00:31:07.630 --> 00:31:11.350
Or it would be a good idea to
realize that, in fact, they

00:31:11.350 --> 00:31:13.520
might head off at
any weird angle.

00:31:13.520 --> 00:31:16.260
I know what code I
have to change.

00:31:16.260 --> 00:31:20.000
It's encapsulated in
a single place.

00:31:20.000 --> 00:31:26.110
So that's why possibles is part
of compass point, rather

00:31:26.110 --> 00:31:31.350
than scattered throughout
the program.

00:31:31.350 --> 00:31:33.920
So this is nice way
to think about it.

00:31:33.920 --> 00:31:37.940
All right, let's move on
and look at field.

00:31:37.940 --> 00:31:41.170
So field, it's got an init, it
takes a self, a drunk, and a

00:31:41.170 --> 00:31:52.150
location, and puts the drunk in
the field at that location.

00:31:52.150 --> 00:31:54.310
It can move.

00:31:54.310 --> 00:31:59.300
So let's look at what happens
when we try and move self in

00:31:59.300 --> 00:32:02.430
some direction, in
some distance.

00:32:02.430 --> 00:32:10.860
We say the old location is the
current location, and then x c

00:32:10.860 --> 00:32:16.810
and y c, think of that as
x-change and y-change, get c p

00:32:16.810 --> 00:32:28.980
dot move of dist. Where is it
gonna find c p dot move?

00:32:28.980 --> 00:32:32.310
It's going to use compass point
dot move, because as

00:32:32.310 --> 00:32:38.800
we'll see, c p is an object of
type, of class, compass point.

00:32:38.800 --> 00:32:42.270
So this is a normal and typical
way we structure

00:32:42.270 --> 00:32:44.570
things with classes.

00:32:44.570 --> 00:32:47.715
The move of one class is defined
using the move of

00:32:47.715 --> 00:32:51.460
another class.

00:32:51.460 --> 00:32:56.560
This gives us the modularity
we so prize.

00:32:56.560 --> 00:33:02.460
And then I'll say self dot
location is old loc dot move

00:33:02.460 --> 00:33:05.510
of x c and x c.

00:33:05.510 --> 00:33:10.170
Now this is oldloc dot move is
going to get the move from

00:33:10.170 --> 00:33:14.400
class location.

00:33:14.400 --> 00:33:17.030
And you'll remember, that was
the thing that just added

00:33:17.030 --> 00:33:22.500
appropriate values to x and y.

00:33:22.500 --> 00:33:26.030
So I'll use compass point to
get those values, and then

00:33:26.030 --> 00:33:30.930
oldloc to get the
new location.

00:33:30.930 --> 00:33:32.510
Then I'll be able to get
the loc and I'll be

00:33:32.510 --> 00:33:35.330
able to get the drunk.

00:33:35.330 --> 00:33:38.670
So, let me ask the same question
about field I've

00:33:38.670 --> 00:33:41.930
asked about the others?

00:33:41.930 --> 00:33:47.190
What interesting decisions, if
any, have I embodied in the

00:33:47.190 --> 00:33:52.180
way I've designed and
implemented this abstraction?

00:33:52.180 --> 00:34:00.270
There's at least one pretty
interesting decision here.

00:34:00.270 --> 00:34:03.010
Just interesting to me because
my first version was far more

00:34:03.010 --> 00:34:06.540
complicated.

00:34:06.540 --> 00:34:12.860
Well, how many drunks can I
have in a field at a time?

00:34:12.860 --> 00:34:15.430
We have an answer which will
not be recorded, because it

00:34:15.430 --> 00:34:18.280
was merely raising a finger,
but it happened to be the

00:34:18.280 --> 00:34:23.280
correct number of
fingers: one.

00:34:23.280 --> 00:34:29.280
And it was this finger that
got pointed at me.

00:34:29.280 --> 00:34:33.340
We've embodied the fact that
you can have one drunk,

00:34:33.340 --> 00:34:35.400
exactly one drunk
in the field.

00:34:35.400 --> 00:34:41.450
This is a solitary alcoholic.

00:34:41.450 --> 00:34:43.670
Later we might say, well, it
would be fun to put a whole

00:34:43.670 --> 00:34:45.930
bunch of drunken students in
and watch what happens when

00:34:45.930 --> 00:34:48.000
they bump into each other.

00:34:48.000 --> 00:34:50.710
And we'll actually later give
you a problem set, not with

00:34:50.710 --> 00:34:53.650
students, but with other things
where there might be

00:34:53.650 --> 00:34:55.750
more than one in a field.

00:34:55.750 --> 00:34:57.750
But here, I've made
that decision.

00:34:57.750 --> 00:35:00.970
But again, I know where I've
made it, and if later I go

00:35:00.970 --> 00:35:04.160
back and say let's put a bunch
of them in, I don't have to

00:35:04.160 --> 00:35:07.460
change compass point, I don't
have to change location, I

00:35:07.460 --> 00:35:10.670
only have to change field.

00:35:10.670 --> 00:35:13.610
And we'll also see, I don't
have to change drunk.

00:35:13.610 --> 00:35:18.500
So again, it's very nice that
the class structure, the

00:35:18.500 --> 00:35:22.220
modularity let's us have
decisions in exactly one place

00:35:22.220 --> 00:35:24.030
in our code.

00:35:24.030 --> 00:35:26.690
Usually important.

00:35:26.690 --> 00:35:31.720
All right, now let's
look at drunk.

00:35:31.720 --> 00:35:37.540
So the drunk has a name.

00:35:37.540 --> 00:35:41.060
And, like everything else,
a move operation.

00:35:41.060 --> 00:35:44.390
This is the most complicated
and interesting move.

00:35:44.390 --> 00:35:48.630
Because here is where I'm
encapsulating the decisions

00:35:48.630 --> 00:35:52.170
about what the drunk
actually does.

00:35:52.170 --> 00:35:54.940
That the drunk, for example,
doesn't head north and just

00:35:54.940 --> 00:35:57.870
keep on going.

00:35:57.870 --> 00:36:02.850
So, let's look at what
happens here.

00:36:02.850 --> 00:36:09.430
It's got three parameters: self,
the field the drunk is

00:36:09.430 --> 00:36:11.540
moving in, and time.

00:36:11.540 --> 00:36:13.960
How long the drunk
is going to move.

00:36:13.960 --> 00:36:16.760
And you may notice something
that you haven't seen before,

00:36:16.760 --> 00:36:20.310
at least some of you,
time equals one

00:36:20.310 --> 00:36:26.620
is sitting up there.

00:36:26.620 --> 00:36:32.820
There.

00:36:32.820 --> 00:36:45.020
Python allows us to have what
are called default values for

00:36:45.020 --> 00:36:48.200
parameters.

00:36:48.200 --> 00:36:54.310
What this says is that if I call
this method without that

00:36:54.310 --> 00:36:57.970
last argument, rather than
getting an error message

00:36:57.970 --> 00:37:02.090
saying it expects three
arguments it only got two, it

00:37:02.090 --> 00:37:04.850
chooses the default value,
in this case one

00:37:04.850 --> 00:37:08.330
for the third argument.

00:37:08.330 --> 00:37:13.450
This is actually a pretty useful
programming paradigm,

00:37:13.450 --> 00:37:18.290
because there's often a
very sensible default.

00:37:18.290 --> 00:37:21.080
And it can simplify things.

00:37:21.080 --> 00:37:24.250
It's not an intrinsically
interesting or important part

00:37:24.250 --> 00:37:26.130
of what I'm showing you here.

00:37:26.130 --> 00:37:28.980
The reason I'm showing it is,
you'll be getting a problem

00:37:28.980 --> 00:37:33.410
set in which default values are
there because we're using

00:37:33.410 --> 00:37:35.180
some other things.

00:37:35.180 --> 00:37:39.270
And as you bring in libraries
and modules from elsewhere,

00:37:39.270 --> 00:37:42.160
you'll find that there are
a lot of these things.

00:37:42.160 --> 00:37:44.590
And in fact a lot of the
functions you've already been

00:37:44.590 --> 00:37:49.410
using for the built-in types
happen to have default values.

00:37:49.410 --> 00:37:54.940
For example, when you look at
things in the init part of a

00:37:54.940 --> 00:38:01.090
range, it's actually choosing,
say, 0 as a start.

00:38:01.090 --> 00:38:02.110
But don't worry about it.

00:38:02.110 --> 00:38:06.570
This just says if you don't
pass it a time, use 1.

00:38:06.570 --> 00:38:16.440
And then what it does, is it
says, if field dot get drunk

00:38:16.440 --> 00:38:25.020
is not equal to self,
raise an exception.

00:38:25.020 --> 00:38:28.060
OK, you've asked me to move a
drunk, it doesn't happen to be

00:38:28.060 --> 00:38:31.190
in the field.

00:38:31.190 --> 00:38:33.430
That's not very interesting.

00:38:33.430 --> 00:38:35.570
But now we come to the
interesting part.

00:38:35.570 --> 00:38:40.790
For i in range time, here by
the way range does have a

00:38:40.790 --> 00:38:44.630
default value of 0,
and since I didn't

00:38:44.630 --> 00:38:48.260
supply it, it used it.

00:38:48.260 --> 00:38:51.770
Point equals compass point,
and here's the most

00:38:51.770 --> 00:38:55.420
interesting thing, random
dot choice of

00:38:55.420 --> 00:38:58.370
compass point dot possibles.

00:38:58.370 --> 00:39:03.470
Random dot choice is a function
in the random module

00:39:03.470 --> 00:39:08.010
which we've imported and it
takes as an argument a

00:39:08.010 --> 00:39:12.680
sequence, a list of some sort,
a container, and it picks a

00:39:12.680 --> 00:39:15.450
random element out of that.

00:39:15.450 --> 00:39:21.800
So here we're passing it in,
four possible values, and it's

00:39:21.800 --> 00:39:25.300
just going to pick one
of them at random.

00:39:25.300 --> 00:39:31.210
So you can see by my having
encapsulated the possibles

00:39:31.210 --> 00:39:37.610
array in compass point, I don't
have to worry in drunk

00:39:37.610 --> 00:39:41.330
about how many possible
directions this person could

00:39:41.330 --> 00:39:44.350
head off in.

00:39:44.350 --> 00:39:49.970
And then it calls field dot
move, with the resultant

00:39:49.970 --> 00:39:54.890
point, and in this case one.

00:39:54.890 --> 00:39:57.860
All right?

00:39:57.860 --> 00:40:02.620
We've now finished all of this
sort of groundwork that we

00:40:02.620 --> 00:40:06.060
need to go and actually build
the simulation that will model

00:40:06.060 --> 00:40:09.920
our problem.

00:40:09.920 --> 00:40:13.790
So let's look at how
we use all of this.

00:40:13.790 --> 00:40:20.420
I've now got a function perform
trial, which will take

00:40:20.420 --> 00:40:26.630
a time in a field.

00:40:26.630 --> 00:40:31.200
So I'll get a starting point of
f dot getloc, wherever the

00:40:31.200 --> 00:40:35.030
drunk happens to be at this
point in time in the field.

00:40:35.030 --> 00:40:42.380
And then for t in range 1 to
time plus 1, I'm going to call

00:40:42.380 --> 00:40:46.930
field dot get drunk, that will
give me the drunk that's in

00:40:46.930 --> 00:40:54.310
the field, and then
I'll get the move

00:40:54.310 --> 00:40:56.210
function for that drunk.

00:40:56.210 --> 00:41:00.120
So what you see here is I can
actually, in this dot

00:41:00.120 --> 00:41:08.390
notation, take advantage of the
fact, where are we, we're

00:41:08.390 --> 00:41:12.290
down here, I've got to get
far enough away that

00:41:12.290 --> 00:41:16.560
I can see it --

00:41:16.560 --> 00:41:17.490
Where was I?

00:41:17.490 --> 00:41:19.118
STUDENT: You were in
the right place

00:41:19.118 --> 00:41:21.620
right there, down slightly.

00:41:21.620 --> 00:41:24.810
PROFESSOR: -- down slightly,
here, right.

00:41:24.810 --> 00:41:29.630
I've called the function, which
has returned an object,

00:41:29.630 --> 00:41:35.230
f dot get drunk returns an
object of class drunk.

00:41:35.230 --> 00:41:39.360
And then I can select the method
associated with that

00:41:39.360 --> 00:41:44.980
object, the move method,
and move the drunk.

00:41:44.980 --> 00:41:49.690
This gets back to a point that
we've emphasized before, that

00:41:49.690 --> 00:41:53.440
these objects are first class
citizens in Python.

00:41:53.440 --> 00:41:56.220
You can use functions and
methods to generate them, and

00:41:56.220 --> 00:42:01.160
use them just as if
you'd typed them.

00:42:01.160 --> 00:42:07.210
So that will get me that, and
then I'll call the move of

00:42:07.210 --> 00:42:11.720
that drunk with the field.

00:42:11.720 --> 00:42:18.640
Then I'll get the location,
the new location, and then

00:42:18.640 --> 00:42:24.490
I'll say, distance equals new
loc dot get distance of start,

00:42:24.490 --> 00:42:28.090
how far is the new location
from wherever the starting

00:42:28.090 --> 00:42:30.560
location was?

00:42:30.560 --> 00:42:35.850
I'll append it to a list,
and then I'll return it.

00:42:35.850 --> 00:42:43.360
So now I have a list, and in the
list I have how far away

00:42:43.360 --> 00:42:46.800
the drunk is after
each time step.

00:42:46.800 --> 00:42:49.470
I'm just collecting the
list of distances.

00:42:49.470 --> 00:42:51.960
So I don't have a list of
locations, I don't know where,

00:42:51.960 --> 00:43:00.700
I can't plot the trajectory, but
I can plot the distances.

00:43:00.700 --> 00:43:10.620
OK, now, let's put
it all together.

00:43:10.620 --> 00:43:15.580
So I'll say the drunk is equal
to, is drunk of Homer Simpson.

00:43:15.580 --> 00:43:18.650
I had thought about using the
name of someone on campus and

00:43:18.650 --> 00:43:21.300
decided that, since it was
going to be taped for

00:43:21.300 --> 00:43:26.170
OpenCourseWare, I didn't
want to go there.

00:43:26.170 --> 00:43:29.890
Sometimes I lack courage.

00:43:29.890 --> 00:43:33.670
Then for i in range 3, and all
this says is I'm going to

00:43:33.670 --> 00:43:36.680
test, I'm going to run the
simulation three different

00:43:36.680 --> 00:43:44.060
times, f is equal to field of
drunk and location 0, 0,

00:43:44.060 --> 00:43:47.230
starting in the middle
of the field.

00:43:47.230 --> 00:43:55.640
Distances equal perform trial
500, 500 steps on that field,

00:43:55.640 --> 00:43:58.610
and the rest of it is magic you
don't need to understand

00:43:58.610 --> 00:44:01.550
because we'll come back to next
lecture, which is, how do

00:44:01.550 --> 00:44:04.540
I put all this in a
pretty picture?

00:44:04.540 --> 00:44:08.160
So ignore all of that for now,
and that's just the Pylab

00:44:08.160 --> 00:44:11.380
stuff for plotting
the pictures.

00:44:11.380 --> 00:44:22.320
All right, we're there,
let's run it.

00:44:22.320 --> 00:44:24.470
Huh.

00:44:24.470 --> 00:44:27.800
Remember the change we made?

00:44:27.800 --> 00:44:31.230
Guess what?

00:44:31.230 --> 00:44:40.120
Well, we know how to fix that.

00:44:40.120 --> 00:44:42.780
And we'll come back to
it and ask what's

00:44:42.780 --> 00:44:46.870
really going on here.

00:44:46.870 --> 00:44:52.570
What does self refer to here?

00:44:52.570 --> 00:44:58.610
It refers to the class compass
point, rather than an instance

00:44:58.610 --> 00:45:00.470
of the class.

00:45:00.470 --> 00:45:05.050
Again, driving home the point
that classes are objects just

00:45:05.050 --> 00:45:05.960
like everything else.

00:45:05.960 --> 00:45:13.660
STUDENT: [INAUDIBLE]

00:45:13.660 --> 00:45:15.200
PROFESSOR: Oh, sorry.

00:45:15.200 --> 00:45:16.850
Thank you.

00:45:16.850 --> 00:45:23.310
It did it have in here, right.

00:45:23.310 --> 00:45:28.740
All right, now let's run
it, see what we get.

00:45:28.740 --> 00:45:32.330
We get a picture.

00:45:32.330 --> 00:45:37.690
Well, so we see that, at least
for these three tests, the

00:45:37.690 --> 00:45:43.060
majority of the public
was wrong.

00:45:43.060 --> 00:45:47.960
It seems that the longer we run
it, the further from the

00:45:47.960 --> 00:45:52.580
origin Homer seems
to be getting.

00:45:52.580 --> 00:45:53.960
Well, let's try it again.

00:45:53.960 --> 00:45:56.030
Maybe we just got unlucky
three times.

00:45:56.030 --> 00:45:59.070
You can see from the divergence
here, that, of

00:45:59.070 --> 00:46:01.460
course, a lot of things go on.

00:46:01.460 --> 00:46:10.260
I hope you can also see the
advantage of being able to

00:46:10.260 --> 00:46:17.520
plot it rather than having
to look at those arrays.

00:46:17.520 --> 00:46:19.690
Well, we get different answers,
but you know what?

00:46:19.690 --> 00:46:25.460
The trend still seems
pretty clear.

00:46:25.460 --> 00:46:30.580
It does seem over time, that
we wander further away.

00:46:30.580 --> 00:46:33.820
I know, further away.

00:46:33.820 --> 00:46:40.880
So, looks at least for
the moment, that

00:46:40.880 --> 00:46:43.190
perhaps we were wrong.

00:46:43.190 --> 00:46:46.040
Well, this is rather silly for
me to keep running it over and

00:46:46.040 --> 00:46:47.890
over again.

00:46:47.890 --> 00:46:54.090
So clearly what I ought
to do is, do it in a

00:46:54.090 --> 00:46:56.120
more organized way.

00:46:56.120 --> 00:47:26.010
So now if we go back, and see
the, kind of the right way to

00:47:26.010 --> 00:47:29.200
do it, I'm going to get rid of
this stuff here, which was

00:47:29.200 --> 00:47:34.800
used just to stop the previous
computation.

00:47:34.800 --> 00:47:40.650
I'm going to write a function
called perform sim.

00:47:40.650 --> 00:47:44.640
And what that does, is it takes
the time and the number

00:47:44.640 --> 00:47:49.720
of trials that we
wanted to do.

00:47:49.720 --> 00:47:54.860
It takes distlist equals the
empty list in this case, to

00:47:54.860 --> 00:48:00.130
start with, and then it is
basically going to call

00:48:00.130 --> 00:48:02.930
perform trial, the function we
already looked at over and

00:48:02.930 --> 00:48:04.840
over again.

00:48:04.840 --> 00:48:07.920
And get a whole bunch of
lists back, a list each

00:48:07.920 --> 00:48:10.930
time it calls it.

00:48:10.930 --> 00:48:18.230
And then, compute an average.

00:48:18.230 --> 00:48:21.840
Well, not yet, so it says, it
says d equals drunk, field

00:48:21.840 --> 00:48:26.710
start in zero, distances equals
perform trial, append

00:48:26.710 --> 00:48:28.180
the new list, and what
it does, is it

00:48:28.180 --> 00:48:32.200
returns a list of lists.

00:48:32.200 --> 00:48:37.240
Where each list is what we had
for the previous trials.

00:48:37.240 --> 00:48:49.400
Make sense?

00:48:49.400 --> 00:48:51.750
And then I'm going to
have 1 more function

00:48:51.750 --> 00:48:53.980
call, answer a question.

00:48:53.980 --> 00:48:58.430
Which takes the maximum time and
the number of trials, and

00:48:58.430 --> 00:49:00.220
it's going to do
some statistics

00:49:00.220 --> 00:49:03.110
on all of the lists.

00:49:03.110 --> 00:49:08.180
We'll come back to this
a week from today.

00:49:08.180 --> 00:49:11.690
If you are, have absolutely
nothing to do for the next

00:49:11.690 --> 00:49:14.350
week, I'll give you a hint.

00:49:14.350 --> 00:49:19.340
I have salted a bug here in
this latest code, and you

00:49:19.340 --> 00:49:22.590
might have some fun looking
at what that bug is.