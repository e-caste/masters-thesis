WEBVTT

00:00:00.040 --> 00:00:02.460
The following content is
provided under a Creative

00:00:02.460 --> 00:00:03.870
Commons license.

00:00:03.870 --> 00:00:06.910
Your support will help MIT
OpenCourseWare continue to

00:00:06.910 --> 00:00:10.560
offer high quality educational
resources for free.

00:00:10.560 --> 00:00:13.460
To make a donation or view
additional materials from

00:00:13.460 --> 00:00:19.290
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:19.290 --> 00:00:20.540
ocw.mit.edu.

00:00:23.850 --> 00:00:25.660
PROFESSOR: Good morning,
everybody.

00:00:25.660 --> 00:00:27.910
Let's go back to
where we were.

00:00:27.910 --> 00:00:32.619
We were talking about abstract
data types and the notion of

00:00:32.619 --> 00:00:33.955
object oriented programming.

00:00:37.710 --> 00:00:42.640
And in particular, the role
of classes in all of that.

00:00:42.640 --> 00:00:45.940
A lot of people think this
notion of object oriented

00:00:45.940 --> 00:00:48.030
programming is a new notion.

00:00:48.030 --> 00:00:49.440
In fact, it's not.

00:00:49.440 --> 00:00:52.320
It's been around for probably
at least 35

00:00:52.320 --> 00:00:55.470
years, maybe even longer.

00:00:55.470 --> 00:00:59.230
But it's only been widely
practiced for maybe 15 years.

00:00:59.230 --> 00:01:02.270
Even that to most of you will
seem like a long time.

00:01:04.800 --> 00:01:08.250
It started in the mid 1970s
when people began to write

00:01:08.250 --> 00:01:11.290
articles explaining this
advantage of the approach to

00:01:11.290 --> 00:01:12.680
programming.

00:01:12.680 --> 00:01:17.000
And at about the same time,
the language Smalltalk was

00:01:17.000 --> 00:01:22.710
developed at Xerox Park and
CLU developed at MIT.

00:01:22.710 --> 00:01:25.320
And they were the first
languages that, in an elegant

00:01:25.320 --> 00:01:29.020
way, provided linguistic support
for this style of

00:01:29.020 --> 00:01:30.630
programming.

00:01:30.630 --> 00:01:34.090
But it didn't really take off
in the public until the

00:01:34.090 --> 00:01:37.160
introduction of Java,
considerably later.

00:01:37.160 --> 00:01:40.870
And Java was the first popular
language to support object

00:01:40.870 --> 00:01:42.630
oriented programming.

00:01:42.630 --> 00:01:46.840
After that there was C++, which
supports it in not a

00:01:46.840 --> 00:01:49.190
very elegant but a usable way.

00:01:49.190 --> 00:01:52.940
And today probably Python is the
fastest growing language

00:01:52.940 --> 00:01:55.570
supporting object oriented
programming.

00:01:55.570 --> 00:01:57.250
It's used widely, and
that's one of the

00:01:57.250 --> 00:01:58.920
reasons we teach it here.

00:02:01.640 --> 00:02:06.950
As I said, at the bottom of it
all, the most fundamental

00:02:06.950 --> 00:02:09.289
notion is that of an
abstract data type.

00:02:13.920 --> 00:02:17.160
And the idea is that we can
extend our programming

00:02:17.160 --> 00:02:20.440
language by adding user
defined types.

00:02:20.440 --> 00:02:24.150
And we'll shortly see why that's
such a useful thing.

00:02:24.150 --> 00:02:27.970
And that these types can be used
just as easily as any of

00:02:27.970 --> 00:02:30.500
the built in types.

00:02:30.500 --> 00:02:34.490
Why do we call them abstract
data types rather than just

00:02:34.490 --> 00:02:35.740
data types?

00:02:38.190 --> 00:02:42.250
We do that because we are
essentially going to define

00:02:42.250 --> 00:02:43.850
for each type an interface.

00:02:49.660 --> 00:02:58.940
And essentially, what the
interface does is it explains

00:02:58.940 --> 00:03:04.860
what the methods do.

00:03:04.860 --> 00:03:07.990
What do I mean by
what they do?

00:03:07.990 --> 00:03:15.970
What they do at the level of the
user, not how they do it.

00:03:22.290 --> 00:03:25.480
That, of course, is the way
the built in types work.

00:03:25.480 --> 00:03:30.020
It wasn't until Tuesday that you
understood how Python made

00:03:30.020 --> 00:03:32.530
dicts do what they do.

00:03:32.530 --> 00:03:36.170
Before then, I just explained,
that you could put in a key

00:03:36.170 --> 00:03:39.340
and a value, and you could
look it up and do an

00:03:39.340 --> 00:03:41.070
associative retrieval.

00:03:41.070 --> 00:03:45.660
It was maybe not magic, but it
was wonderful that you could

00:03:45.660 --> 00:03:49.450
do this and not have to bother
your heads with how it was

00:03:49.450 --> 00:03:51.360
made to work.

00:03:51.360 --> 00:03:54.480
And that was because we
provided, or the designers of

00:03:54.480 --> 00:03:59.510
Python provided, an interface
that lets you use it.

00:03:59.510 --> 00:04:03.700
We'll do the same thing with
the abstract data types.

00:04:03.700 --> 00:04:09.180
The key idea here is one we've
talked about before and that's

00:04:09.180 --> 00:04:10.430
a specification.

00:04:13.680 --> 00:04:18.720
It is the specification of a
type, or of a function, or of

00:04:18.720 --> 00:04:23.780
a method, that tells us
what that thing does.

00:04:23.780 --> 00:04:27.760
And we'll now until the end of
the term try and maintain a

00:04:27.760 --> 00:04:31.430
very clear distinction between
specifications and

00:04:31.430 --> 00:04:32.680
implementations.

00:04:38.530 --> 00:04:42.000
Let's look at an example.

00:04:42.000 --> 00:04:45.210
So the example should
be familiar to you.

00:04:45.210 --> 00:04:48.410
You will remember that on
Tuesday at the start of the

00:04:48.410 --> 00:04:53.410
lecture, we looked at how we
could use hashing to implement

00:04:53.410 --> 00:04:55.410
a set of integers.

00:04:55.410 --> 00:04:58.770
And I explained to you that I
wasn't very happy with the

00:04:58.770 --> 00:05:00.820
implementation because
of the way it

00:05:00.820 --> 00:05:03.840
used this global variable.

00:05:03.840 --> 00:05:08.450
Now we're going to see a much
more elegant approach.

00:05:08.450 --> 00:05:13.710
So I'm going to define a new
abstract type called intSet.

00:05:13.710 --> 00:05:19.070
I do that by writing the word,
class, followed by

00:05:19.070 --> 00:05:21.130
the name of the class.

00:05:21.130 --> 00:05:27.010
And then there's this funny
thing saying that it is a

00:05:27.010 --> 00:05:30.140
subclass of objects.

00:05:30.140 --> 00:05:31.420
Ignore that for now.

00:05:31.420 --> 00:05:34.150
And I'm going to come
back to it later.

00:05:34.150 --> 00:05:37.480
But fundamentally what it's
saying is that every instance

00:05:37.480 --> 00:05:40.560
of intSet is an object.

00:05:40.560 --> 00:05:45.080
That's not very interesting
because everything in Python

00:05:45.080 --> 00:05:46.230
is an object.

00:05:46.230 --> 00:05:49.160
So from an information theoretic
point of view,

00:05:49.160 --> 00:05:51.600
there's no information here.

00:05:51.600 --> 00:05:54.700
Later we'll see that we can use
this mechanism in a more

00:05:54.700 --> 00:05:55.950
interesting way.

00:05:58.810 --> 00:06:02.160
Now let's look at the methods.

00:06:02.160 --> 00:06:06.450
So first I tell you a comment,
it's a set of integers.

00:06:06.450 --> 00:06:09.350
Then I've got this funny
method called underbar

00:06:09.350 --> 00:06:12.690
underbar init.

00:06:12.690 --> 00:06:15.950
Whenever you see something with
an underbar underbar in

00:06:15.950 --> 00:06:21.180
its name, it has a special
status in Python that lets us

00:06:21.180 --> 00:06:23.595
do elegant things
with the syntax.

00:06:26.960 --> 00:06:32.820
What will happen every time I
create a new object of type

00:06:32.820 --> 00:06:41.135
intSet, the underbar underbar
init method, or function, of

00:06:41.135 --> 00:06:44.330
the class will be executed
on that object.

00:06:49.280 --> 00:06:57.810
What it will do, in this case,
is introduce two attributes of

00:06:57.810 --> 00:07:00.090
the object.

00:07:00.090 --> 00:07:05.380
The attributes are numBuckets
which is now replacing the

00:07:05.380 --> 00:07:07.440
global variable we looked
at last time.

00:07:07.440 --> 00:07:11.170
And I've arbitrarily
chosen 47.

00:07:11.170 --> 00:07:12.420
And Vals.

00:07:14.720 --> 00:07:20.780
This will be the hash table
itself containing the values.

00:07:20.780 --> 00:07:26.500
And then, exactly as we did
on Tuesday, I'm going to

00:07:26.500 --> 00:07:32.880
initialize the values so that
each element of this list is

00:07:32.880 --> 00:07:34.400
now an empty list.

00:07:39.710 --> 00:07:42.890
Now what's going on with this
funny notion of self.

00:07:42.890 --> 00:07:44.430
Let's look at an example here.

00:07:48.520 --> 00:07:53.840
I'm going to say s equals
intSet open close.

00:07:58.840 --> 00:08:03.160
This will create a new intSet
object, execute the underbar

00:08:03.160 --> 00:08:04.820
underbar init.

00:08:04.820 --> 00:08:08.835
So if, for example, I print
self.numBuckets--

00:08:13.580 --> 00:08:18.470
whoops, can't do that because
self is not defined in this

00:08:18.470 --> 00:08:19.900
environment.

00:08:19.900 --> 00:08:23.830
Self was a local variable to
underbar underbar init.

00:08:23.830 --> 00:08:26.140
In fact, the formal parameter.

00:08:26.140 --> 00:08:34.035
But I can write s.numBuckets,
and I'll see it's 47.

00:08:44.110 --> 00:08:51.470
NumBuckets and Val are
now attributes of s.

00:08:54.140 --> 00:08:58.340
Attributes of the instance
s of the class intSet.

00:09:07.550 --> 00:09:08.800
And I [[UNINTELLIGIBLE]

00:09:12.860 --> 00:09:14.260
what we would expect.

00:09:14.260 --> 00:09:15.790
Yes?

00:09:15.790 --> 00:09:21.776
AUDIENCE: You didn't put any
object in between the

00:09:21.776 --> 00:09:22.730
parentheses.

00:09:22.730 --> 00:09:23.530
PROFESSOR: Yes.

00:09:23.530 --> 00:09:25.050
So that--

00:09:25.050 --> 00:09:29.660
the question is well, it looks
like underbar underbar intSet

00:09:29.660 --> 00:09:33.820
or underbar underbar init
has a formal parameter.

00:09:33.820 --> 00:09:34.660
And I've given it no

00:09:34.660 --> 00:09:36.220
corresponding actual parameter.

00:09:36.220 --> 00:09:37.055
AUDIENCE: [INAUDIBLE]

00:09:37.055 --> 00:09:38.020
PROFESSOR: Yes.

00:09:38.020 --> 00:09:38.860
Let me finish.

00:09:38.860 --> 00:09:40.840
So that's what it looks like.

00:09:40.840 --> 00:09:46.670
And that's the magic
of this syntax.

00:09:46.670 --> 00:09:53.290
It automatically passes
an implicit object,

00:09:53.290 --> 00:09:54.300
or it creates one.

00:09:54.300 --> 00:09:57.580
It's a very special role for
underbar underbar init.

00:10:01.620 --> 00:10:05.670
Self is used to refer to the
object being created.

00:10:09.560 --> 00:10:13.980
I'm going to come back in a
minute to discuss more fully

00:10:13.980 --> 00:10:17.960
the concept of self and
how it's used here.

00:10:17.960 --> 00:10:22.620
So just give me a minute
to get there.

00:10:22.620 --> 00:10:26.860
The next thing we
see is hashE.

00:10:26.860 --> 00:10:28.875
This is something we looked
at again on Tuesday.

00:10:34.270 --> 00:10:38.830
It's a private function in this
case that I don't intend

00:10:38.830 --> 00:10:41.910
to be used outside the class.

00:10:41.910 --> 00:10:44.570
So if we think of the
specifications here, the

00:10:44.570 --> 00:10:50.530
interface of the class, it
does not include hashE.

00:10:50.530 --> 00:10:52.800
That's what private
means here.

00:10:52.800 --> 00:10:53.990
This is a convention.

00:10:53.990 --> 00:10:56.370
It's not enforced
by the language.

00:10:56.370 --> 00:10:59.540
And unfortunately, as we'll see,
a lot of useful things

00:10:59.540 --> 00:11:01.890
are not enforced by
the language.

00:11:01.890 --> 00:11:04.960
But nevertheless, good
programmers follow the

00:11:04.960 --> 00:11:06.460
conventions.

00:11:06.460 --> 00:11:10.050
And we expect you guys to do so
as well because, of course,

00:11:10.050 --> 00:11:12.550
you're good programmers.

00:11:12.550 --> 00:11:14.765
So this doesn't do anything
very exciting.

00:11:14.765 --> 00:11:18.130
It's just what we saw.

00:11:18.130 --> 00:11:19.650
Insert is more interesting.

00:11:19.650 --> 00:11:22.460
Let's look at what that does.

00:11:22.460 --> 00:11:28.930
It apparently takes two
arguments, the formals named

00:11:28.930 --> 00:11:36.055
self and E and inserts
E into self.vals.

00:11:40.340 --> 00:11:49.670
However, if we go look at the
code that uses it in say

00:11:49.670 --> 00:11:57.120
testone what you'll note is I'm
saying for i in range 40--

00:11:57.120 --> 00:12:00.810
this is just like the testone
we looked at Tuesday.

00:12:00.810 --> 00:12:04.520
I'm going to say
s.insert of i.

00:12:04.520 --> 00:12:08.060
It looks like I'm calling insert
with only one argument,

00:12:08.060 --> 00:12:13.920
but as we discussed last time,
this s before the dot is

00:12:13.920 --> 00:12:19.040
actually the first argument
to the method insert.

00:12:19.040 --> 00:12:21.220
And so it's getting two
arguments really.

00:12:25.160 --> 00:12:31.660
And by convention, that implicit
first argument is

00:12:31.660 --> 00:12:35.125
always called self in Python.

00:12:40.840 --> 00:12:42.040
It's not enforced.

00:12:42.040 --> 00:12:45.440
You could call it George if you
preferred, or Alice, or

00:12:45.440 --> 00:12:48.170
whatever you like.

00:12:48.170 --> 00:12:51.160
But if you do, you will confuse
the heck out of

00:12:51.160 --> 00:12:54.090
anybody who ever reads your
code, including any

00:12:54.090 --> 00:12:56.360
TA you ask for help.

00:12:56.360 --> 00:12:59.810
So please do use self.

00:12:59.810 --> 00:13:01.900
It's just a name.

00:13:01.900 --> 00:13:05.630
It has nothing to do with
what a philosopher, or a

00:13:05.630 --> 00:13:09.800
psychologist, or an ethicist
might think as the concept of

00:13:09.800 --> 00:13:12.960
self, this wonderful
elevated concept.

00:13:12.960 --> 00:13:13.820
It's none of those.

00:13:13.820 --> 00:13:15.450
It's just a name.

00:13:15.450 --> 00:13:17.540
But stick to using that name.

00:13:21.660 --> 00:13:28.580
So if we go back, I can insert
a bunch of things.

00:13:32.040 --> 00:13:34.340
I'm going to then print s.

00:13:34.340 --> 00:13:35.590
That's kind of interesting.

00:13:39.150 --> 00:13:45.090
UnderBar underbar STR, underbar
underbar is one of

00:13:45.090 --> 00:13:49.180
those special names as well.

00:13:49.180 --> 00:13:52.310
The code is pretty simple.

00:13:52.310 --> 00:13:54.350
All it is is returning a string

00:13:54.350 --> 00:13:55.820
representation of the set.

00:13:59.390 --> 00:14:00.880
And it could be anything
you want.

00:14:00.880 --> 00:14:05.260
I chose sort of a conventional
way of denoting sets.

00:14:05.260 --> 00:14:09.420
What's interesting
is that it gets

00:14:09.420 --> 00:14:13.230
automatically called by print.

00:14:13.230 --> 00:14:19.110
So when I write the command,
print s, in test one, the

00:14:19.110 --> 00:14:22.970
Python interpreter is smart
enough to know oh, I better

00:14:22.970 --> 00:14:26.765
take s, convert it to a string,
and then print it.

00:14:30.060 --> 00:14:32.100
How does it know to convert
it to a string?

00:14:32.100 --> 00:14:36.850
It automatically invokes the
underbar underbar STR method.

00:14:44.510 --> 00:14:47.560
And then the other operation
is member, which again is

00:14:47.560 --> 00:14:49.145
exactly what we looked
at before.

00:14:51.680 --> 00:14:58.530
But you'll notice in this code
that uses intSets, I make no

00:14:58.530 --> 00:15:04.010
reference to the data attributes
of the class

00:15:04.010 --> 00:15:07.540
directly, or I shouldn't.

00:15:07.540 --> 00:15:12.040
You'll notice that I wrote
evil next to s.vals.

00:15:12.040 --> 00:15:15.130
Python will let me do
it, but I shouldn't.

00:15:15.130 --> 00:15:16.590
Why shouldn't I do it?

00:15:19.350 --> 00:15:21.010
Why am I saying this is evil?

00:15:27.601 --> 00:15:34.360
Well, would you be happy if you
got a message saying IDLE

00:15:34.360 --> 00:15:35.245
was changed.

00:15:35.245 --> 00:15:40.453
Please download a new version
and the new version happened

00:15:40.453 --> 00:15:41.700
to have a different

00:15:41.700 --> 00:15:44.580
implementation of lists or dicts.

00:15:44.580 --> 00:15:49.640
And it caused all of your
programs to stop working.

00:15:49.640 --> 00:15:51.780
You would be pretty unhappy.

00:15:51.780 --> 00:15:54.500
Now why won't that happen?

00:15:54.500 --> 00:15:59.700
Because your programs don't
depend, in any way, on the way

00:15:59.700 --> 00:16:05.560
in which people chose to
implement those built in types

00:16:05.560 --> 00:16:09.510
because you programmed to the
specification of the types,

00:16:09.510 --> 00:16:10.760
not to the implementation.

00:16:12.900 --> 00:16:17.640
The specification of intSet
did not mention Vals or

00:16:17.640 --> 00:16:18.890
numBuckets.

00:16:20.850 --> 00:16:25.500
Therefore, as the implementer of
that class, I'm entitled to

00:16:25.500 --> 00:16:27.970
go back and change it.

00:16:27.970 --> 00:16:30.780
So I'm not going to use
a hash table at all.

00:16:30.780 --> 00:16:31.900
I'm going to do something
else.

00:16:31.900 --> 00:16:35.280
I'm going to use a red, black
tree, or some other fancy

00:16:35.280 --> 00:16:36.880
implementation.

00:16:36.880 --> 00:16:38.810
I'm allowed to do that.

00:16:38.810 --> 00:16:43.640
And if I make that change, and
Vals disappears and numBuckets

00:16:43.640 --> 00:16:47.960
disappears, your program should
continue to work so

00:16:47.960 --> 00:16:51.700
long as I still meet
the specification.

00:16:51.700 --> 00:16:55.990
The minute you go in and
directly access the variables

00:16:55.990 --> 00:17:00.700
of the class, those attributes,
you have used

00:17:00.700 --> 00:17:04.000
things that do not appear
in this specification.

00:17:04.000 --> 00:17:06.270
And if I change the
implementation, your program

00:17:06.270 --> 00:17:07.520
might break.

00:17:09.690 --> 00:17:11.369
So you shouldn't do that.

00:17:11.369 --> 00:17:13.660
Does that make sense
to everybody?

00:17:13.660 --> 00:17:15.900
It's a very important concept.

00:17:15.900 --> 00:17:18.750
The concept is known
as data hiding.

00:17:38.700 --> 00:17:44.930
It is really the most important
development that

00:17:44.930 --> 00:17:48.200
makes abstract data
types useful.

00:17:48.200 --> 00:17:52.960
It gives them the same status
as the built in types.

00:17:52.960 --> 00:17:57.190
The minute you choose to
ignore this, you do

00:17:57.190 --> 00:17:59.640
so at your own peril.

00:17:59.640 --> 00:18:03.880
Some programming languages, like
Java, provide a mechanism

00:18:03.880 --> 00:18:07.250
to enforce data hiding.

00:18:07.250 --> 00:18:11.490
The designers of Python, for
reasons I do not understand,

00:18:11.490 --> 00:18:13.170
chose not to.

00:18:13.170 --> 00:18:15.210
I think it is a flaw
in the language.

00:18:21.260 --> 00:18:25.980
The things we're hiding are
the instance variable.

00:18:46.190 --> 00:18:50.770
Those are the variables
associated with each instance

00:18:50.770 --> 00:18:52.020
of the class.

00:19:01.320 --> 00:19:06.275
We should also hide
class variables.

00:19:09.780 --> 00:19:13.445
We haven't seen those yet,
and we'll see them later.

00:19:16.670 --> 00:19:22.250
The instance variables, we get
a new copy of each time we

00:19:22.250 --> 00:19:24.400
created a new instance
of the class, a new

00:19:24.400 --> 00:19:26.400
intSet in this case.

00:19:26.400 --> 00:19:29.520
The class variables
are associated

00:19:29.520 --> 00:19:31.130
with the class itself.

00:19:31.130 --> 00:19:34.530
And you get only one
copy of them.

00:19:34.530 --> 00:19:37.180
Later on, we'll see an
example where class

00:19:37.180 --> 00:19:40.500
variables are useful.

00:19:40.500 --> 00:19:40.930
All right.

00:19:40.930 --> 00:19:43.010
So let's run this just to
make sure it works.

00:19:50.330 --> 00:19:51.850
It does what we would expect.

00:19:51.850 --> 00:19:52.820
True/False.

00:19:52.820 --> 00:19:56.230
And then you'll see
this nice string

00:19:56.230 --> 00:19:58.340
representation of the set.

00:19:58.340 --> 00:20:00.970
And then just to show you what
happens when you do the evil

00:20:00.970 --> 00:20:04.400
thing, I printed as we did
last time the actual

00:20:04.400 --> 00:20:07.600
list that came out.

00:20:13.660 --> 00:20:16.960
Let's now look at a more
interesting example.

00:20:24.880 --> 00:20:28.770
And the idea I want to convey
here is how we use classes and

00:20:28.770 --> 00:20:33.340
abstract data types to
design programs.

00:20:33.340 --> 00:20:37.040
So imagine that you're writing a
program to keep track of all

00:20:37.040 --> 00:20:41.440
the students, faculty, and
maybe staff at MIT.

00:20:41.440 --> 00:20:44.040
It's certainly possible to write
that program without

00:20:44.040 --> 00:20:46.080
using any classes.

00:20:46.080 --> 00:20:48.830
For each student, you might
give them a family name, a

00:20:48.830 --> 00:20:53.290
given name, a home address,
years, grades, et cetera.

00:20:53.290 --> 00:20:56.260
And you could do this with some
complicated combination

00:20:56.260 --> 00:20:57.510
of lists and dictionaries.

00:20:59.930 --> 00:21:02.750
But it wouldn't be
very elegant.

00:21:02.750 --> 00:21:06.040
So what I want to do before
writing that program--

00:21:06.040 --> 00:21:08.190
and I won't actually
write that program.

00:21:08.190 --> 00:21:11.330
I'll just write some of the
classes we can use--

00:21:11.330 --> 00:21:13.720
I want to pull back and
think about what

00:21:13.720 --> 00:21:17.360
abstractions would be useful.

00:21:17.360 --> 00:21:20.880
So this style of programming
in which you organize your

00:21:20.880 --> 00:21:26.840
programs around abstract data
types says before we write the

00:21:26.840 --> 00:21:32.280
code in detail, we think about
these types that would make it

00:21:32.280 --> 00:21:34.770
easy to write the code.

00:21:34.770 --> 00:21:38.810
So for example, if you were
a finance student, and you

00:21:38.810 --> 00:21:43.310
wanted to write some code
dealing with markets, you

00:21:43.310 --> 00:21:45.530
might want to have an
abstraction of a government

00:21:45.530 --> 00:21:48.650
bond, and another abstraction
of an equity, and an

00:21:48.650 --> 00:21:50.960
extraction of a call option.

00:21:50.960 --> 00:21:52.580
Whatever you want it.

00:21:52.580 --> 00:21:56.060
But you'd say I want to think at
that level of abstraction.

00:21:56.060 --> 00:21:59.840
I don't want to think about
lists, and dicts, and floats.

00:21:59.840 --> 00:22:03.860
I just want to think about
options, which have a strike

00:22:03.860 --> 00:22:07.830
price, a date, and
things like that.

00:22:07.830 --> 00:22:11.900
Similarly, as I'm working on
this database for MIT, I want

00:22:11.900 --> 00:22:17.470
to think about abstractions
of students, and

00:22:17.470 --> 00:22:18.720
faculty, and staff.

00:22:22.540 --> 00:22:29.420
I'm also going to use what's
called inheritance to set up a

00:22:29.420 --> 00:22:32.920
hierarchy of these.

00:22:32.920 --> 00:22:37.240
And the reason I'm going to do
that is I want to be able to

00:22:37.240 --> 00:22:39.950
share a code.

00:22:39.950 --> 00:22:44.330
I know that there will be
certain similarities between

00:22:44.330 --> 00:22:46.490
students and faculty.

00:22:46.490 --> 00:22:49.910
Some differences too.

00:22:49.910 --> 00:22:53.990
But I want to begin by saying
what's not different?

00:22:53.990 --> 00:22:55.170
What's similar?

00:22:55.170 --> 00:22:56.580
What's the same?

00:22:56.580 --> 00:22:59.970
So that I only have to
implement it once and

00:22:59.970 --> 00:23:03.460
get to reuse it.

00:23:03.460 --> 00:23:08.290
So if I pull back and say is
there an abstraction that

00:23:08.290 --> 00:23:11.740
covers the shared attributes of
students, and faculty, and

00:23:11.740 --> 00:23:15.890
staff, I might say
it's a person.

00:23:15.890 --> 00:23:18.490
They're all people.

00:23:18.490 --> 00:23:21.970
And it's arguable whether every
faculty member is a

00:23:21.970 --> 00:23:26.490
human being, but for
now let's pretend.

00:23:26.490 --> 00:23:29.760
And so I'm going to start with
this abstraction person.

00:23:32.650 --> 00:23:35.910
I'm going to import something
called DateTime.

00:23:35.910 --> 00:23:38.360
I'll show you what we're doing
when we get there.

00:23:38.360 --> 00:23:41.110
But it's like we've imported
math before.

00:23:41.110 --> 00:23:46.000
This is a class somebody else
wrote that deals with dates

00:23:46.000 --> 00:23:49.430
and time in a fairly
reasonable way.

00:23:53.540 --> 00:23:58.610
So I'm going to import that
here into person.

00:23:58.610 --> 00:24:01.200
Probably didn't need
to import it twice.

00:24:01.200 --> 00:24:03.840
Maybe I'll just simplify it by
getting rid of this one.

00:24:08.220 --> 00:24:11.450
UnderBar underbar init
here will create a

00:24:11.450 --> 00:24:15.740
person with name 'Name'.

00:24:15.740 --> 00:24:23.660
And you'll notice what I'm doing
here is introducing an

00:24:23.660 --> 00:24:25.050
extra attribute lastName
-- self.lastName.

00:24:29.680 --> 00:24:32.790
And that's because I just want
to make life easy for myself.

00:24:32.790 --> 00:24:35.830
I figure I'll want to find
the last name frequently.

00:24:35.830 --> 00:24:38.940
Let's once and for all get it
and put it in something.

00:24:41.920 --> 00:24:44.540
And I'm going to initialize
birthday to none.

00:24:49.540 --> 00:24:56.020
The next attribute, or the next
method, is get lastName.

00:24:56.020 --> 00:25:04.660
I have that here because I
don't want users of this

00:25:04.660 --> 00:25:08.450
abstraction to even know that
I have an attribute

00:25:08.450 --> 00:25:09.770
self.lastname.

00:25:09.770 --> 00:25:12.080
That's part of the
implementation.

00:25:12.080 --> 00:25:15.620
And so I have this method
that fetches it.

00:25:15.620 --> 00:25:19.490
And you'll see as you build
classes that you often have

00:25:19.490 --> 00:25:22.140
things called get.

00:25:22.140 --> 00:25:25.440
And those are typically methods
that return some

00:25:25.440 --> 00:25:27.860
information about an instance
of the class.

00:25:31.860 --> 00:25:36.580
You'll also frequently have set
methods, for example, set

00:25:36.580 --> 00:25:45.990
birthday that gives values to
instances of the class.

00:25:49.280 --> 00:25:51.230
More interestingly,
I have get age.

00:25:54.300 --> 00:25:58.370
And that's using some of the
built in operations on

00:25:58.370 --> 00:26:00.890
DateTime conveniently.

00:26:00.890 --> 00:26:07.370
It allows me to subtract one
date from another and get a

00:26:07.370 --> 00:26:08.620
number of days.

00:26:11.980 --> 00:26:15.390
So this will allow me to return
somebody's age in days.

00:26:20.330 --> 00:26:23.520
Then I've got another underbar
underbar method we

00:26:23.520 --> 00:26:24.990
haven't seen yet.

00:26:24.990 --> 00:26:28.210
lt stands for less than.

00:26:28.210 --> 00:26:31.140
Not a big surprise.

00:26:31.140 --> 00:26:39.240
And I'm going to use this to
order names, or order people.

00:26:39.240 --> 00:26:42.580
Why am I using a special
operator rather than just

00:26:42.580 --> 00:26:48.650
putting in the method
L-E-S-S-T-H. A-N?

00:26:48.650 --> 00:26:49.900
E-N?

00:26:53.074 --> 00:26:57.230
I'm doing that because I want
to be able to write things

00:26:57.230 --> 00:27:04.260
like p1 less than
p2 in my code.

00:27:04.260 --> 00:27:09.890
And Python will take that and
turn it into the underbar

00:27:09.890 --> 00:27:11.140
underbar LT.

00:27:14.750 --> 00:27:21.350
Better yet, if I have a list say
of person's, I can use the

00:27:21.350 --> 00:27:26.330
built in sort operator on that
list, and it will be smart

00:27:26.330 --> 00:27:29.100
enough to know when it's
comparing two people to do the

00:27:29.100 --> 00:27:32.120
sort to use the underbar
underbar LT.

00:27:35.760 --> 00:27:37.350
Very convenient kind of thing.

00:27:40.450 --> 00:27:41.800
Let's look at an example.

00:27:41.800 --> 00:27:43.050
Let's look at some code.

00:27:51.380 --> 00:27:56.485
So I'm going to set me to John
Guttag, and him to Barack

00:27:56.485 --> 00:27:59.670
Hussein Obama, her to Madonna.

00:27:59.670 --> 00:28:00.920
And we'll print some things.

00:28:18.410 --> 00:28:20.840
So I printed him, and I printed
him.getlastName.

00:28:26.990 --> 00:28:31.805
I can now set some birthdays.

00:28:43.500 --> 00:28:46.840
Let's look at this line.

00:28:46.840 --> 00:28:49.757
How do you feel about
him.birthday equals 8/4/61?

00:28:59.170 --> 00:29:00.270
We'll come back to it.

00:29:00.270 --> 00:29:02.340
But I want you to
think about it.

00:29:11.630 --> 00:29:15.210
And we see that Obama is--

00:29:15.210 --> 00:29:17.710
well, we see their ages here.

00:29:17.710 --> 00:29:21.510
Actually, we see that
Madonna is older.

00:29:21.510 --> 00:29:23.740
She looks really old when you
look at that number of days,

00:29:23.740 --> 00:29:26.300
doesn't it.

00:29:26.300 --> 00:29:28.890
Maybe she is.

00:29:28.890 --> 00:29:30.250
Now what's going
to happen here?

00:29:41.510 --> 00:29:42.760
I messed up.

00:29:46.240 --> 00:29:50.700
And I messed up because I went
in and directly accessed the

00:29:50.700 --> 00:29:54.400
instance variable and assigned
it what I thought was a

00:29:54.400 --> 00:29:56.190
reasonable representation
of a birthdate.

00:29:59.130 --> 00:30:01.530
But I shouldn't have because
that's not even the

00:30:01.530 --> 00:30:04.740
appropriate type.

00:30:04.740 --> 00:30:08.850
It's a string rather than
something from DateTime.

00:30:08.850 --> 00:30:13.530
So again, we see the impact of
my having done this evil thing

00:30:13.530 --> 00:30:20.860
of violating the abstraction
boundary and stuck in there

00:30:20.860 --> 00:30:23.135
try to directly access
an instance variable.

00:30:28.010 --> 00:30:29.260
We can do some comparisons.

00:30:37.320 --> 00:30:44.370
And what we see is that I'm
not less than Madonna.

00:30:44.370 --> 00:30:45.620
I guess that's OK.

00:30:50.780 --> 00:30:52.030
You with me so far?

00:30:57.500 --> 00:31:07.590
I can make a list of these
things and print the list.

00:31:15.880 --> 00:31:19.490
So it does a fairly nice job
calling the underbar underbar

00:31:19.490 --> 00:31:22.320
STR operator.

00:31:22.320 --> 00:31:27.100
And you'll note I had no trouble
throwing objects of

00:31:27.100 --> 00:31:28.580
type person into the list.

00:31:28.580 --> 00:31:31.210
No different than putting
ints, or floats,

00:31:31.210 --> 00:31:32.210
or any of the built-ins.

00:31:32.210 --> 00:31:35.040
So it all works nicely.

00:31:35.040 --> 00:31:37.630
And then I can sort
it and print that.

00:31:47.560 --> 00:31:50.700
And now the lists come out in a
different order because it's

00:31:50.700 --> 00:31:55.790
using the underbar underbar LT
operator to sort the elements.

00:31:55.790 --> 00:31:58.750
All of this is just by way of
showing you how convenient it

00:31:58.750 --> 00:32:01.986
is to write code that uses
a data abstraction.

00:32:07.690 --> 00:32:11.430
If we go back and look at the
code, we'll see that once

00:32:11.430 --> 00:32:18.000
again person was a subclass
of object.

00:32:18.000 --> 00:32:19.640
That's why we can do all
these things we've

00:32:19.640 --> 00:32:21.180
been doing with it.

00:32:21.180 --> 00:32:23.820
But now I'm going to start
using the hierarchy.

00:32:33.830 --> 00:32:36.940
MIT people are special.

00:32:36.940 --> 00:32:39.490
I hate to say that because
I know we have non-MIT

00:32:39.490 --> 00:32:40.670
people in the room.

00:32:40.670 --> 00:32:43.810
But MIT people are special.

00:32:43.810 --> 00:32:46.290
Well here's at least
one of the special

00:32:46.290 --> 00:32:48.490
attributes of MIT people.

00:32:48.490 --> 00:32:49.740
They all have an ID.

00:32:52.540 --> 00:32:56.020
So I'm now going to say
an MIT person is a

00:32:56.020 --> 00:33:00.920
special subclass of person.

00:33:00.920 --> 00:33:05.290
So it has all of the properties
of a person.

00:33:05.290 --> 00:33:13.010
And the way we describe that is
it inherits the properties

00:33:13.010 --> 00:33:14.260
of the super class.

00:33:27.840 --> 00:33:29.090
And it adds a property.

00:33:32.090 --> 00:33:39.160
We can now assign
an ID number.

00:33:39.160 --> 00:33:43.510
And now we're going to see the
thing I promised to show you,

00:33:43.510 --> 00:33:44.785
which is a class variable.

00:33:48.190 --> 00:33:53.800
Next ID num is not associated
with an instance of MIT

00:33:53.800 --> 00:33:58.830
person, but it's associated
with the class itself.

00:33:58.830 --> 00:34:01.110
It's a class variable.

00:34:01.110 --> 00:34:06.215
I can do that because classes
are themselves objects.

00:34:09.280 --> 00:34:13.070
And the advantage of this is
every time I get a new

00:34:13.070 --> 00:34:17.010
instance of this class, I
can assign a unique ID.

00:34:21.770 --> 00:34:25.130
Similar to the way we were using
global variables earlier

00:34:25.130 --> 00:34:30.020
in the term, typically once we
have classes, we'd stop using

00:34:30.020 --> 00:34:34.489
global variables because we have
these class variables,

00:34:34.489 --> 00:34:39.320
which can serve very much the
same purpose in many cases.

00:34:39.320 --> 00:34:44.290
And so now every time I get a
new MIT person, I give them an

00:34:44.290 --> 00:34:48.210
ID and then increment the ID
number so that the next person

00:34:48.210 --> 00:34:49.460
will get a different one.

00:34:52.040 --> 00:34:59.090
So I added a property, this ID
number property, which I find

00:34:59.090 --> 00:35:02.140
by get ID num.

00:35:02.140 --> 00:35:06.405
I've also overwritten an
existing property.

00:35:24.890 --> 00:35:29.510
You'll note that I've changed
the definition of underbar

00:35:29.510 --> 00:35:32.480
underbar LT.

00:35:32.480 --> 00:35:36.820
So it's now saying we're going
to compare two people not on

00:35:36.820 --> 00:35:39.010
the basis of their
names but on the

00:35:39.010 --> 00:35:40.545
basis of their ID numbers.

00:35:46.270 --> 00:35:48.540
So let's look at some
code that uses this.

00:36:00.980 --> 00:36:02.710
Get rid of the other
code so it doesn't

00:36:02.710 --> 00:36:03.960
clutter up the screen.

00:36:33.520 --> 00:36:36.400
So we'll look at some
things here.

00:36:36.400 --> 00:36:42.300
We'll get some MIT people
called p1, p2, and p3.

00:36:42.300 --> 00:36:48.420
And we'll print their ID nums
by calling get ID num.

00:36:51.200 --> 00:36:54.480
And you can see that Barbara
Beaver gets 0, and the first

00:36:54.480 --> 00:36:58.230
Sue Wong gets 1, and the second
Sue Wong has ID 2.

00:37:04.290 --> 00:37:07.840
I can create even a
third such person.

00:37:07.840 --> 00:37:09.815
And now let's think about
what happens here.

00:37:15.280 --> 00:37:23.340
I'm going to print whether or
not p1 is less than p2 and

00:37:23.340 --> 00:37:25.400
whether or not p3
is less than p2.

00:37:28.680 --> 00:37:30.150
What should we get
when we do this?

00:37:33.580 --> 00:37:34.830
Somebody?

00:37:37.420 --> 00:37:39.264
Pardon?

00:37:39.264 --> 00:37:40.870
AUDIENCE: True and false.

00:37:40.870 --> 00:37:44.316
PROFESSOR: I heard
a true false.

00:37:44.316 --> 00:37:48.370
And indeed that's right because
it's comparing IDs.

00:37:48.370 --> 00:37:50.885
Now, suppose I want
to compare names.

00:37:53.920 --> 00:37:56.965
I could if I chose do this.

00:38:01.380 --> 00:38:07.250
I could call person underbar
underbar LT.

00:38:07.250 --> 00:38:12.120
And what this says
is don't use the

00:38:12.120 --> 00:38:15.940
less than of the subclass.

00:38:15.940 --> 00:38:18.380
Go up and use the super class
one to do the comparison.

00:38:32.950 --> 00:38:34.670
So it's going up
and doing that.

00:38:38.660 --> 00:38:41.120
I can do other things.

00:38:41.120 --> 00:38:42.940
I can compare things
for equality.

00:38:45.980 --> 00:38:51.585
Let me just rip through all of
these and see what we get.

00:38:54.720 --> 00:38:56.290
Whoops.

00:38:56.290 --> 00:38:58.920
Surprise!

00:38:58.920 --> 00:39:01.290
Well, before we get
to that surprise--

00:39:01.290 --> 00:39:02.930
and it's not actually
a surprise.

00:39:02.930 --> 00:39:04.750
I shouldn't have
uncommented it.

00:39:04.750 --> 00:39:06.000
Let's look at the other ones.

00:39:20.720 --> 00:39:24.710
We can say is p1 equal to p4?

00:39:24.710 --> 00:39:27.250
And we discover it's not.

00:39:27.250 --> 00:39:29.400
That's good.

00:39:29.400 --> 00:39:33.230
And we can say is
p4 less than p3?

00:39:33.230 --> 00:39:34.670
That all works.

00:39:34.670 --> 00:39:36.300
It's not.

00:39:36.300 --> 00:39:40.950
But I can't say p3
less than p4.

00:39:44.010 --> 00:39:45.740
And why can't I do that?

00:39:48.730 --> 00:39:51.380
Why did I get an error message
when I did that?

00:40:01.530 --> 00:40:02.024
Yes?

00:40:02.024 --> 00:40:04.494
Someone wanted to answer that?

00:40:04.494 --> 00:40:07.952
AUDIENCE: That's because you
mix [UNINTELLIGIBLE]?

00:40:07.952 --> 00:40:10.916
PROFESSOR: Can you say
that more loudly?

00:40:10.916 --> 00:40:12.398
AUDIENCE: She's a person,
not an MIT person.

00:40:12.398 --> 00:40:14.265
So you didn't assign
her an ID number.

00:40:14.265 --> 00:40:16.390
PROFESSOR: Exactly right.

00:40:16.390 --> 00:40:17.640
The answer--

00:40:21.940 --> 00:40:24.820
I hit somebody right
on the head.

00:40:24.820 --> 00:40:26.630
Now there's going to be a
traumatic brain injury.

00:40:26.630 --> 00:40:27.590
I'm going to get sued.

00:40:27.590 --> 00:40:30.530
It's going to be messy.

00:40:30.530 --> 00:40:31.780
Time to leave the country.

00:40:37.450 --> 00:40:37.722
All right.

00:40:37.722 --> 00:40:43.500
Because it looks at p3 less than
p4, looks at the first

00:40:43.500 --> 00:40:47.670
argument, which is p3, and says
OK, what's the underbar

00:40:47.670 --> 00:40:51.760
underbar LT associated
with p3?

00:40:51.760 --> 00:40:55.210
It's the one associated
with an MIT person.

00:40:55.210 --> 00:40:57.340
Let's go execute that.

00:40:57.340 --> 00:41:03.310
And then it tries to retrieve
the ID number of p4, which is

00:41:03.310 --> 00:41:07.070
not an MIT person, and it
gets an error message.

00:41:10.820 --> 00:41:11.140
All right.

00:41:11.140 --> 00:41:11.690
Nothing subtle.

00:41:11.690 --> 00:41:14.590
It's the same kind of thing
we've seen all along when we

00:41:14.590 --> 00:41:17.100
use type errors.

00:41:17.100 --> 00:41:20.610
In this case it's called an
attribute error because we've

00:41:20.610 --> 00:41:23.630
attempted to access an attribute
of an instance that

00:41:23.630 --> 00:41:26.045
doesn't exist.

00:41:26.045 --> 00:41:28.740
And so we could catch it.

00:41:28.740 --> 00:41:29.900
It's raised an exception.

00:41:29.900 --> 00:41:33.090
We could catch it as we looked
at Tuesday, but we're not

00:41:33.090 --> 00:41:35.970
going to do that because it's
really a programming bug when

00:41:35.970 --> 00:41:37.220
that happens.

00:41:39.500 --> 00:41:41.180
OK, let's continue.

00:41:45.330 --> 00:41:46.710
We were interested
in students.

00:41:49.960 --> 00:41:54.040
So we're going to continue
our hierarchy here.

00:41:54.040 --> 00:41:58.130
And now I'm going to introduce
a subclass of an MIT person

00:41:58.130 --> 00:42:00.895
called an UG, short
for undergraduate.

00:42:04.880 --> 00:42:09.730
Underbar underbar init is
going to call MIT person

00:42:09.730 --> 00:42:14.790
underbar underbar init, which
will give the UG an ID number

00:42:14.790 --> 00:42:16.090
and a name.

00:42:16.090 --> 00:42:19.090
And it's going to introduce
yet another instance

00:42:19.090 --> 00:42:22.330
attribute, or field,
called the year.

00:42:22.330 --> 00:42:26.080
And so the year, initially,
is none.

00:42:26.080 --> 00:42:27.405
Then I can set the year.

00:42:30.650 --> 00:42:33.400
Though if I try and set it as
something greater than 5, I'm

00:42:33.400 --> 00:42:38.350
going to raise an overflow
error called too many.

00:42:38.350 --> 00:42:41.990
No undergraduate should be
a year greater than 5.

00:42:41.990 --> 00:42:45.070
And I can get the year.

00:42:45.070 --> 00:42:47.095
Let's look at what happens
when we do that.

00:42:55.540 --> 00:42:57.230
So I'll have two UG's.

00:42:57.230 --> 00:42:59.630
Both happen to be
named Jane Doe.

00:42:59.630 --> 00:43:03.640
And then the same MIT
person as before.

00:43:03.640 --> 00:43:08.100
Let's run this code and see--
well, what's going to happen?

00:43:08.100 --> 00:43:11.720
What's going to happen
when I say print UG1?

00:43:11.720 --> 00:43:15.200
The first thing it's going to do
is going to say is there an

00:43:15.200 --> 00:43:20.440
underbar underbar STR
associated with UGs?

00:43:20.440 --> 00:43:23.600
And the answer is no.

00:43:23.600 --> 00:43:27.820
That's OK because I know an
UG is also an MIT person.

00:43:27.820 --> 00:43:31.870
If I don't find it at the
lowest level class, I'll

00:43:31.870 --> 00:43:35.860
bounce up and say all right, is
there an underbar underbar

00:43:35.860 --> 00:43:38.975
STR associated with
an MIT person?

00:43:42.240 --> 00:43:43.350
No.

00:43:43.350 --> 00:43:44.640
That's OK.

00:43:44.640 --> 00:43:48.670
I'll go up another level and
say, well, I know an MIT

00:43:48.670 --> 00:43:51.630
person happens to be a person.

00:43:51.630 --> 00:43:54.870
And then they'll say oh, good
there is an underbar underbar

00:43:54.870 --> 00:43:57.500
STR associated with person.

00:43:57.500 --> 00:44:00.070
So I'll use that one.

00:44:00.070 --> 00:44:02.210
So it looks at the class.

00:44:02.210 --> 00:44:04.640
If it doesn't find it, it
goes to the super class.

00:44:04.640 --> 00:44:07.230
If it doesn't find it, it
goes to the super class.

00:44:07.230 --> 00:44:10.770
And it does that all the way
up until the end, where at

00:44:10.770 --> 00:44:13.140
worst, it will use the built-in
thing for printing

00:44:13.140 --> 00:44:16.960
objects because remember
everything is

00:44:16.960 --> 00:44:19.530
a subclass of objects.

00:44:19.530 --> 00:44:21.000
You don't want to do that.

00:44:21.000 --> 00:44:23.380
You want to have something more
elegant than object at

00:44:23.380 --> 00:44:27.730
location xe345, or whatever
if would have printed.

00:44:37.910 --> 00:44:40.530
Then we'll do some
comparisons.

00:44:40.530 --> 00:44:43.220
It will first look for the most
local and then work its

00:44:43.220 --> 00:44:44.470
way up as needed.

00:44:50.240 --> 00:44:51.490
OK?

00:44:54.000 --> 00:44:55.530
Let's keep going.

00:44:55.530 --> 00:44:58.490
We're going to introduce another
kind of person called

00:44:58.490 --> 00:45:00.800
a graduate student.

00:45:00.800 --> 00:45:03.240
And I'm going to write pass.

00:45:03.240 --> 00:45:10.700
What that means is a G is an
MIT person with no special

00:45:10.700 --> 00:45:16.960
properties, all the usual
properties of an MIT person.

00:45:16.960 --> 00:45:19.360
Does not have a year because
graduate students could be

00:45:19.360 --> 00:45:23.140
here more or less forever,
which goes like

00:45:23.140 --> 00:45:24.390
this when I say that.

00:45:27.470 --> 00:45:29.630
Why did I introduce the type
in the first place?

00:45:33.590 --> 00:45:38.110
Because it lets me
do type checking.

00:45:38.110 --> 00:45:44.880
I can now check whether or not a
person is a graduate student

00:45:44.880 --> 00:45:51.210
because an instance of G will
have all of the properties of

00:45:51.210 --> 00:45:55.650
an MIT person, but it will
have a different type.

00:45:55.650 --> 00:45:58.310
It will be type G.

00:45:58.310 --> 00:46:01.440
And so I can now ask the
question is the type of this

00:46:01.440 --> 00:46:05.660
object a G. Or is it
an MIT person and

00:46:05.660 --> 00:46:06.910
get a different answer.

00:46:14.480 --> 00:46:15.730
So I can do this.

00:46:19.600 --> 00:46:21.990
And if I go type of G1--

00:46:24.890 --> 00:46:27.530
well, that's interesting.

00:46:27.530 --> 00:46:33.280
It says classmain.G.

00:46:33.280 --> 00:46:36.000
It's going to upset its class.

00:46:36.000 --> 00:46:39.060
And the class is defined at the
outermost level, which is

00:46:39.060 --> 00:46:40.270
called main.

00:46:40.270 --> 00:46:45.630
And the classes name is G,
which is what we expect.

00:46:50.330 --> 00:46:52.350
And so I could write something
like that.

00:46:57.180 --> 00:47:03.630
Type of G1 equals equals
G. And I get True.

00:47:07.000 --> 00:47:07.140
Ok.

00:47:07.140 --> 00:47:09.310
So it's a handy thing
to be able to do.

00:47:12.350 --> 00:47:19.670
And in fact, I'm now going to
bounce back to MIT person and

00:47:19.670 --> 00:47:21.390
add another method to it.

00:47:24.000 --> 00:47:29.540
And this happens all the time
when I'm programming that I go

00:47:29.540 --> 00:47:33.290
define a class, think I'm done,
and then some time later

00:47:33.290 --> 00:47:35.400
decide that it would be
convenient to add something

00:47:35.400 --> 00:47:37.480
new, another method.

00:47:37.480 --> 00:47:41.370
In this case, I'm now adding the
method is student, which

00:47:41.370 --> 00:47:45.420
returns type of self equal equal
UG or type of self equal

00:47:45.420 --> 00:47:47.140
equals G.

00:47:47.140 --> 00:47:52.490
So this will let me distinguish
a student from

00:47:52.490 --> 00:47:53.900
another kind of MIT person.

00:47:58.450 --> 00:48:03.150
So for example, if I want
to have a course list--

00:48:03.150 --> 00:48:07.770
another class, this is
a subclass of object.

00:48:07.770 --> 00:48:11.250
You'll note I have an add
student method, which takes

00:48:11.250 --> 00:48:14.740
self and who, maybe
it should be whom.

00:48:14.740 --> 00:48:18.760
And it says, if not
who.isstudent raise type error

00:48:18.760 --> 00:48:21.570
not a student.

00:48:21.570 --> 00:48:25.580
So I'm getting some leverage
now out of this.

00:48:25.580 --> 00:48:28.690
Now I wouldn't need to
necessarily do this.

00:48:28.690 --> 00:48:37.600
I could have said if not type
of who equals G, or type of

00:48:37.600 --> 00:48:39.730
who equals UG.

00:48:39.730 --> 00:48:42.180
But I chose not to.

00:48:42.180 --> 00:48:46.980
The reason I chose not to is
looking ahead, I might want to

00:48:46.980 --> 00:48:48.250
add some other students.

00:48:48.250 --> 00:48:51.950
I might want to add special
student, for example.

00:48:51.950 --> 00:48:55.080
Or I might want to add cross
registering student as

00:48:55.080 --> 00:48:57.930
separate types.

00:48:57.930 --> 00:49:03.660
Now, the nice thing is I don't
have to make a lot of changes.

00:49:03.660 --> 00:49:07.790
I know there's exactly one place
in my code that defines

00:49:07.790 --> 00:49:10.440
what it means to be
an MIT student.

00:49:10.440 --> 00:49:13.010
I go back and I change
that method.

00:49:13.010 --> 00:49:16.140
And even if I asked whether
somebody's a student in a 100

00:49:16.140 --> 00:49:18.920
different places, I only
have to make one

00:49:18.920 --> 00:49:21.520
change to fix my code.

00:49:21.520 --> 00:49:26.940
So I'm getting some modularity
by associating the method with

00:49:26.940 --> 00:49:32.110
the class MIT person rather
than every time

00:49:32.110 --> 00:49:33.360
I need to use it.