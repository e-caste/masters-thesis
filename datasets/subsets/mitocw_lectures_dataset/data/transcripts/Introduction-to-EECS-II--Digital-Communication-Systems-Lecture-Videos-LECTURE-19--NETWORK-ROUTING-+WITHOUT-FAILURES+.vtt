WEBVTT

00:00:00.000 --> 00:00:02.490
The following content is
provided under a Creative

00:00:02.490 --> 00:00:04.059
Commons license.

00:00:04.059 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.720
continue to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.350
To make a donation or
view additional materials

00:00:13.350 --> 00:00:17.290
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.290 --> 00:00:18.294
at ocw.mit.edu.

00:00:27.883 --> 00:00:28.800
HARI BALAKRISHNAN: OK.

00:00:28.800 --> 00:00:30.508
So today, we're going
to continue talking

00:00:30.508 --> 00:00:31.800
about multi-hop networks.

00:00:31.800 --> 00:00:33.720
And in particular,
I'm going to talk

00:00:33.720 --> 00:00:37.830
about a fairly fundamental
problem in multi-hop networks

00:00:37.830 --> 00:00:40.120
called network routing.

00:00:40.120 --> 00:00:44.820
And that's the topic for today
and through most of, half of,

00:00:44.820 --> 00:00:46.110
next week.

00:00:46.110 --> 00:00:48.880
And today, this week,
we'll talk about network

00:00:48.880 --> 00:00:52.860
routing in networks where
there are no failures.

00:00:52.860 --> 00:00:54.870
So in real networks,
of course, things fail.

00:00:54.870 --> 00:00:55.860
Packets get dropped.

00:00:55.860 --> 00:00:56.700
Nodes may fail.

00:00:56.700 --> 00:00:57.480
Switches may fail.

00:00:57.480 --> 00:00:58.610
Links may fail.

00:00:58.610 --> 00:01:00.360
We'll just worry about
the case when there

00:01:00.360 --> 00:01:02.740
are no failures for this week.

00:01:02.740 --> 00:01:05.040
Next week, we'll add
some more complexity

00:01:05.040 --> 00:01:07.420
and talk about how we
deal with failures.

00:01:07.420 --> 00:01:09.190
So the abstract problem
is pretty simple.

00:01:09.190 --> 00:01:11.700
You have a set of
nodes in the network.

00:01:11.700 --> 00:01:13.481
And there's some
network topology.

00:01:27.240 --> 00:01:29.530
And every source
in the network--

00:01:29.530 --> 00:01:31.680
you have sources, and
you have destinations,

00:01:31.680 --> 00:01:32.820
nodes in the network.

00:01:32.820 --> 00:01:36.050
And they wish to send
packets to each other.

00:01:36.050 --> 00:01:37.800
And we're going to
decompose this problem,

00:01:37.800 --> 00:01:42.687
these endpoints,
which actually want

00:01:42.687 --> 00:01:45.270
to communicate with each other,
as we've already talked about,

00:01:45.270 --> 00:01:49.800
do so by sending
packets via switches.

00:01:49.800 --> 00:01:51.840
And the problem we're
going to worry about

00:01:51.840 --> 00:01:59.260
is what happens inside the
network in these switches.

00:01:59.260 --> 00:02:02.240
The switches solve
the following problem.

00:02:02.240 --> 00:02:05.210
If things work correctly
and if things work well,

00:02:05.210 --> 00:02:09.020
when a switch receives a
packet with a destination

00:02:09.020 --> 00:02:11.270
address specifying
that that packet has

00:02:11.270 --> 00:02:14.800
to be sent to a particular named
destination to the network,

00:02:14.800 --> 00:02:17.960
the switch figures out
how to ship that packet.

00:02:17.960 --> 00:02:20.720
It figures out whether
to send it along--

00:02:20.720 --> 00:02:21.500
I need a better--

00:02:21.500 --> 00:02:22.568
here.

00:02:22.568 --> 00:02:24.110
This switch, for
example, figures out

00:02:24.110 --> 00:02:27.530
whether a package should go
along that link, or this link,

00:02:27.530 --> 00:02:30.410
or this link, or this
link, or that link,

00:02:30.410 --> 00:02:32.120
given any package
that it receives.

00:02:32.120 --> 00:02:35.350
And every switch in the
network performs this task.

00:02:37.930 --> 00:02:40.620
Now, when a switch gets
a packet and the packet

00:02:40.620 --> 00:02:44.580
has a destination address
in it, what the switch does

00:02:44.580 --> 00:02:47.370
is some sort of a lookup.

00:02:47.370 --> 00:02:52.230
It looks up that destination
in some sort of a table.

00:02:52.230 --> 00:02:55.740
And that table maintains
information about which

00:02:55.740 --> 00:02:59.910
of the links to use
in sending that packet

00:02:59.910 --> 00:03:01.710
toward the destination.

00:03:01.710 --> 00:03:04.044
And this step is
called forwarding.

00:03:11.630 --> 00:03:15.380
Packets are forwarded
by switches.

00:03:15.380 --> 00:03:16.970
Technically, packets
aren't routed.

00:03:16.970 --> 00:03:19.490
Everybody says packet
routing, and I say it, too.

00:03:19.490 --> 00:03:22.030
But it's important to realize
packets aren't routed.

00:03:22.030 --> 00:03:24.440
Packets are forwarded.

00:03:24.440 --> 00:03:28.080
The forwarding process is pretty
straightforward at slow speeds.

00:03:28.080 --> 00:03:29.060
You get a packet.

00:03:29.060 --> 00:03:30.350
You take the destination.

00:03:30.350 --> 00:03:32.960
You look up that
packet in a table.

00:03:32.960 --> 00:03:35.750
And that table tells you what
you do with the packet, which

00:03:35.750 --> 00:03:38.310
link to use.

00:03:38.310 --> 00:03:41.900
Routing is the problem
that the switches solve

00:03:41.900 --> 00:03:43.600
of constructing these tables.

00:03:43.600 --> 00:03:50.050
So forwarding is simply
lookup in a table.

00:03:50.050 --> 00:03:51.800
And the table is called
the routing table.

00:03:55.130 --> 00:03:57.130
Sometimes it's also called
the forwarding table.

00:03:57.130 --> 00:03:58.830
And there's a technical
difference between them that's

00:03:58.830 --> 00:04:00.400
not that important for us.

00:04:00.400 --> 00:04:06.450
So forwarding is the process
of looking up the destination

00:04:06.450 --> 00:04:07.530
in the routing table.

00:04:07.530 --> 00:04:09.810
Routing is the
distributed process,

00:04:09.810 --> 00:04:11.700
the algorithm that's
used or the protocol

00:04:11.700 --> 00:04:14.500
that's used, to build
up these routing tables.

00:04:14.500 --> 00:04:17.430
So it's the
construction process,

00:04:17.430 --> 00:04:20.550
how to construct
these routing tables

00:04:20.550 --> 00:04:24.500
at each switch in the network.

00:04:24.500 --> 00:04:25.820
That's done in the background.

00:04:25.820 --> 00:04:27.830
That's usually done in software.

00:04:27.830 --> 00:04:31.033
Switches at high speeds involve
a fair amount of hardware.

00:04:31.033 --> 00:04:32.825
Routing itself is
usually done in software.

00:04:36.490 --> 00:04:39.470
And so a typical switch has
a lot of different processing

00:04:39.470 --> 00:04:40.303
elements in it.

00:04:40.303 --> 00:04:41.720
A lot of those
processing elements

00:04:41.720 --> 00:04:43.460
are high speed
hardware that deals

00:04:43.460 --> 00:04:45.303
with the process of forwarding.

00:04:45.303 --> 00:04:47.220
And then you have software
sitting on the side

00:04:47.220 --> 00:04:50.540
where all of the complexity is.

00:04:50.540 --> 00:04:52.790
And all that complexity
deals with all sorts

00:04:52.790 --> 00:04:55.370
of complicated rules that
you have to come up with

00:04:55.370 --> 00:04:57.892
in order to decide how to
construct these routing tables.

00:04:57.892 --> 00:05:00.350
And we're going to talk about
the world's simplest networks

00:05:00.350 --> 00:05:01.318
today.

00:05:01.318 --> 00:05:03.110
And you'll find that
even that's reasonably

00:05:03.110 --> 00:05:06.300
sophisticated and complicated.

00:05:06.300 --> 00:05:08.930
So just for
concreteness, an example

00:05:08.930 --> 00:05:11.820
of a picture of a
topology is like this.

00:05:11.820 --> 00:05:13.730
And for reasons that
will become apparent

00:05:13.730 --> 00:05:17.030
as we talk this through,
we'll model the network

00:05:17.030 --> 00:05:18.650
as a set of nodes
and a set of links.

00:05:18.650 --> 00:05:20.900
And so far, there's
nothing new about this.

00:05:20.900 --> 00:05:23.960
But we'll model links
as having a cost.

00:05:23.960 --> 00:05:28.820
And this cost might reflect, for
example, the delay or latency

00:05:28.820 --> 00:05:30.890
to send a packet
along that link.

00:05:30.890 --> 00:05:34.130
The cost might reflect
the real dollar cost

00:05:34.130 --> 00:05:35.895
of shipping data along links.

00:05:35.895 --> 00:05:38.270
Internet service providers
might charge different amounts

00:05:38.270 --> 00:05:40.730
of money for different
types of data, for example.

00:05:40.730 --> 00:05:44.660
Or the cost might just reflect
your own internal preferences

00:05:44.660 --> 00:05:46.940
as to which links
you might prefer

00:05:46.940 --> 00:05:48.175
based on whatever concerns.

00:05:48.175 --> 00:05:50.300
Maybe some links are slow,
and some links are fast.

00:05:50.300 --> 00:05:52.758
Maybe there are higher speed
links, lower speed links, that

00:05:52.758 --> 00:05:54.440
cost more or less, et cetera.

00:05:54.440 --> 00:05:56.270
So these costs are
abstract numbers.

00:05:56.270 --> 00:05:59.210
And we'll just assume that
we're interested in finding

00:05:59.210 --> 00:06:03.320
minimum cost paths between
senders and receivers.

00:06:03.320 --> 00:06:05.270
So every switch
solves the problem

00:06:05.270 --> 00:06:09.110
of finding the minimum cost
path to a destination where

00:06:09.110 --> 00:06:12.200
the cost along a path is
simply the sum of the costs

00:06:12.200 --> 00:06:14.660
along the links on that path.

00:06:14.660 --> 00:06:17.380
This is just standard
shortest path routing.

00:06:17.380 --> 00:06:19.190
We'll use shortest
path even though we

00:06:19.190 --> 00:06:21.500
don't mean literally the
shortest number of hops,

00:06:21.500 --> 00:06:22.970
but the minimum cost path.

00:06:22.970 --> 00:06:25.430
And where that distinction is
important between the number

00:06:25.430 --> 00:06:27.925
of hops and the cost, et
cetera, we'll clarify.

00:06:30.440 --> 00:06:33.000
So the routing table
looks something like this.

00:06:33.000 --> 00:06:35.030
In fact, it looks like this.

00:06:35.030 --> 00:06:35.900
There's destination.

00:06:35.900 --> 00:06:36.930
Every switch has this.

00:06:36.930 --> 00:06:38.930
So this is an example of
a routing table at node

00:06:38.930 --> 00:06:42.800
B. Node B maintains all the
destinations in the network.

00:06:42.800 --> 00:06:45.630
And we're dealing with small
networks so far in our class.

00:06:45.630 --> 00:06:47.960
So we'll just assume that
every node in the network

00:06:47.960 --> 00:06:51.500
has a unique name
or a unique address,

00:06:51.500 --> 00:06:54.110
and that the routing
tables contain

00:06:54.110 --> 00:06:56.790
an entry for every
destination in the network.

00:06:56.790 --> 00:06:59.012
So the routing table
has three columns.

00:06:59.012 --> 00:07:00.470
It's a database
with three columns.

00:07:00.470 --> 00:07:02.733
And every switch in
the network or a node--

00:07:02.733 --> 00:07:05.150
I'm going to use the word node
and switch interchangeably.

00:07:05.150 --> 00:07:06.608
Every switch or
node in the network

00:07:06.608 --> 00:07:09.210
has one of these if the
network is working correctly.

00:07:09.210 --> 00:07:11.420
So if the routing
protocol does its job,

00:07:11.420 --> 00:07:13.800
every node comes up with its
own version of this table.

00:07:13.800 --> 00:07:15.140
There is a destination.

00:07:15.140 --> 00:07:17.180
There is the link
you need to use

00:07:17.180 --> 00:07:21.560
that is the next hop, if you get
a packet to this destination,

00:07:21.560 --> 00:07:24.180
what link would you
use, and a cost.

00:07:24.180 --> 00:07:26.910
So in this table,
if node B or switch

00:07:26.910 --> 00:07:30.950
B received a packet
destined for destination A,

00:07:30.950 --> 00:07:33.230
it would use link L1.

00:07:33.230 --> 00:07:34.880
Each link is named locally.

00:07:34.880 --> 00:07:37.640
So B would have its
own L0, L2, and L1.

00:07:37.640 --> 00:07:40.427
You know, your own computer
has a bunch of links.

00:07:40.427 --> 00:07:42.260
I don't know what the
command is in Windows,

00:07:42.260 --> 00:07:46.220
but in all other sensible
platforms, if you do IF Config,

00:07:46.220 --> 00:07:47.000
you can get it.

00:07:47.000 --> 00:07:48.830
I think it's called IP
config on a Windows.

00:07:48.830 --> 00:07:50.540
But you can actually
see a list of links.

00:07:50.540 --> 00:07:52.490
So switches have many,
many, many links.

00:07:52.490 --> 00:07:55.200
And so you'll find, for
example, for destination A

00:07:55.200 --> 00:07:56.180
you use link L1.

00:07:56.180 --> 00:07:57.560
The cost is 18.

00:07:57.560 --> 00:08:01.475
In fact, you'll see here that,
when B receives a packet for A,

00:08:01.475 --> 00:08:03.950
it doesn't use the direct link
because the direct link has

00:08:03.950 --> 00:08:07.310
a cost of 19, whereas
going through L1,

00:08:07.310 --> 00:08:09.080
this link has a cost of 11.

00:08:09.080 --> 00:08:14.720
And if B believes that the
path toward A along this link

00:08:14.720 --> 00:08:17.300
has a cost of 11 plus 7 is
18, that's what it thinks.

00:08:17.300 --> 00:08:19.240
And, therefore, it
would use that link.

00:08:22.210 --> 00:08:22.710
OK?

00:08:22.710 --> 00:08:24.000
It's very simple.

00:08:24.000 --> 00:08:25.500
Now, routing is the
process by which

00:08:25.500 --> 00:08:27.180
these different nodes
talk to each other

00:08:27.180 --> 00:08:30.350
and build up these tables.

00:08:30.350 --> 00:08:33.740
When I say a route to a
destination, I mean this.

00:08:33.740 --> 00:08:37.549
I mean the route to a
destination at a switch

00:08:37.549 --> 00:08:41.030
or at a node is the link
that that destination would

00:08:41.030 --> 00:08:44.850
use to send packets
to the destination.

00:08:44.850 --> 00:08:46.673
This is important
technically for us.

00:08:46.673 --> 00:08:48.590
Because, otherwise, we
will get all tangled up

00:08:48.590 --> 00:08:52.240
getting confused between
routes and paths.

00:08:52.240 --> 00:08:52.740
OK.

00:08:52.740 --> 00:08:54.320
For the purposes
of our discussion,

00:08:54.320 --> 00:08:56.455
a route is the next
hop link, is the link

00:08:56.455 --> 00:08:58.580
that you're going to use
to get to the destination.

00:08:58.580 --> 00:09:00.890
The path is a sequence of links.

00:09:00.890 --> 00:09:03.920
So I don't want people telling
me that the route from B to E

00:09:03.920 --> 00:09:08.480
is whatever, is BCE.

00:09:08.480 --> 00:09:11.310
I'd like people to tell me
that the route at node B

00:09:11.310 --> 00:09:14.852
to destination E is L1.

00:09:14.852 --> 00:09:16.310
Or if you wish to
be clear, you can

00:09:16.310 --> 00:09:18.770
say, it's link L1 which
takes it to next hop

00:09:18.770 --> 00:09:23.340
C. The path from B
to E might BCE, OK?

00:09:27.070 --> 00:09:29.480
All right, so that's what
the routing table structure

00:09:29.480 --> 00:09:29.980
looks like.

00:09:29.980 --> 00:09:33.070
And we're interested
in minimum cost paths

00:09:33.070 --> 00:09:36.160
to go from places to places.

00:09:36.160 --> 00:09:38.080
So normally, traditionally,
we sit around

00:09:38.080 --> 00:09:40.070
and try to now dive
into protocols.

00:09:40.070 --> 00:09:41.860
But I think here what
we're going to do

00:09:41.860 --> 00:09:45.063
is since our notes are all
so nice and written up,

00:09:45.063 --> 00:09:47.480
I actually don't have to tell
you everything that's there.

00:09:47.480 --> 00:09:48.897
So what we're
actually going to do

00:09:48.897 --> 00:09:52.510
is something we call
the routing game, which

00:09:52.510 --> 00:09:55.630
is an experiment in
social networking.

00:09:55.630 --> 00:09:58.180
What it means is that
each of you or some of you

00:09:58.180 --> 00:10:02.530
will act as nodes and
start computing routes

00:10:02.530 --> 00:10:04.007
to different destinations.

00:10:04.007 --> 00:10:05.840
OK, so that's what this
game is going to be.

00:10:05.840 --> 00:10:09.520
So what I have in my hand
is 40 slips of paper.

00:10:09.520 --> 00:10:13.360
And I hope there are 40 people
here, 40 slips of paper.

00:10:13.360 --> 00:10:17.920
And each of these slips of
paper has some information

00:10:17.920 --> 00:10:18.940
that looks like this.

00:10:23.420 --> 00:10:27.220
It says you are node X, and
you're connected to nodes Y, Z,

00:10:27.220 --> 00:10:29.470
W, et cetera, OK?

00:10:29.470 --> 00:10:34.423
And there's a set of rules that
I will go through in a minute.

00:10:34.423 --> 00:10:36.340
First of all, these were
all in perfect order.

00:10:36.340 --> 00:10:38.923
So I need to shuffle them a few
times carefully without losing

00:10:38.923 --> 00:10:39.475
them.

00:10:39.475 --> 00:10:42.850
I think Perci Diaconis,
the famous probabilist,

00:10:42.850 --> 00:10:46.750
said that you've got
to do this seven times.

00:10:46.750 --> 00:10:48.200
Maybe this is close to seven.

00:10:48.200 --> 00:10:48.700
OK.

00:10:48.700 --> 00:10:52.180
So what I'm going to do is
I'm going to pass this around.

00:10:52.180 --> 00:10:53.140
There's no bag here.

00:10:53.140 --> 00:10:54.110
The bag's cumbersome.

00:10:54.110 --> 00:10:55.570
So what I'd like you
to do-- actually,

00:10:55.570 --> 00:10:57.220
I'll put it in the envelope
and pass it around.

00:10:57.220 --> 00:10:58.930
Just kind of close
your eyes or something.

00:10:58.930 --> 00:10:59.710
Don't look at the number.

00:10:59.710 --> 00:11:00.585
And just pick one up.

00:11:00.585 --> 00:11:03.130
And don't look at it
until I tell you, OK?

00:11:03.130 --> 00:11:05.050
So we'll start here and
just pass it around.

00:11:05.050 --> 00:11:08.242
I'd like 40 different
people to have them.

00:11:08.242 --> 00:11:10.450
You don't have to feel
compelled to take it, but just

00:11:10.450 --> 00:11:11.075
pass it around.

00:11:11.075 --> 00:11:13.120
And try to do it
quickly because I'd

00:11:13.120 --> 00:11:15.820
like that to happen faster than
the time it's going to take

00:11:15.820 --> 00:11:17.825
for us to compute these routes.

00:11:17.825 --> 00:11:20.200
So why don't you just pick
one sheet of paper up and just

00:11:20.200 --> 00:11:22.000
pass it around, please?

00:11:22.000 --> 00:11:25.450
OK, so I picked 7 minutes.

00:11:25.450 --> 00:11:27.530
It sometimes works a
little faster than 7.

00:11:27.530 --> 00:11:31.600
The best that the class has
done is about 5 minutes.

00:11:31.600 --> 00:11:34.790
Last time, they did it very
quickly, but they got it wrong.

00:11:34.790 --> 00:11:36.838
So I don't think that counts.

00:11:36.838 --> 00:11:38.380
But I've been told
that they've tried

00:11:38.380 --> 00:11:39.547
this experiment at Berkeley.

00:11:39.547 --> 00:11:41.577
It's taken usually
more than 7 minutes.

00:11:41.577 --> 00:11:43.160
And I figure MIT
students are smarter.

00:11:43.160 --> 00:11:48.100
So let's see if you can do
it faster than 7 minutes.

00:11:48.100 --> 00:11:50.480
Now, your job is to find
a path from a source

00:11:50.480 --> 00:11:55.790
node to a destination node
as quickly as possible, OK?

00:11:55.790 --> 00:11:58.352
And I mean, as a
bonus, if you actually

00:11:58.352 --> 00:12:00.560
find the path with the
minimum number of hops, that's

00:12:00.560 --> 00:12:04.662
even better, but
we'll take any path.

00:12:04.662 --> 00:12:05.870
Now, there's some rules here.

00:12:10.908 --> 00:12:12.200
Now, there are some rules here.

00:12:12.200 --> 00:12:13.930
So you may not
actually kind of get up

00:12:13.930 --> 00:12:17.210
and run around and try to do
things that a normal network

00:12:17.210 --> 00:12:18.730
switch wouldn't do.

00:12:18.730 --> 00:12:21.010
So you're allowed to
stay in one place.

00:12:21.010 --> 00:12:23.258
And what you're
actually allowed to do

00:12:23.258 --> 00:12:25.300
is you're not allowed to
pass your sheet of paper

00:12:25.300 --> 00:12:28.100
to other people because you
have information about yourself.

00:12:28.100 --> 00:12:30.100
And that piece tells you
who your neighbors are,

00:12:30.100 --> 00:12:31.390
the numbers of your neighbors.

00:12:31.390 --> 00:12:34.240
So you can't actually kind
of send your piece of paper

00:12:34.240 --> 00:12:34.900
to other nodes.

00:12:34.900 --> 00:12:36.070
That's not allowed.

00:12:36.070 --> 00:12:39.560
And don't let people copy
what's on your sheet of paper.

00:12:39.560 --> 00:12:42.050
Now, here's some
things you can do.

00:12:42.050 --> 00:12:43.540
You can read them.

00:12:43.540 --> 00:12:44.770
Ask your friends for advice.

00:12:44.770 --> 00:12:46.600
You can shout to
other participants.

00:12:46.600 --> 00:12:49.120
We're allowing you
to yell and scream,

00:12:49.120 --> 00:12:51.610
but do so in a way that's
somewhat civilized.

00:12:51.610 --> 00:12:54.550
And you can wish that
you didn't pick up a slip

00:12:54.550 --> 00:12:56.180
or pick up a slip or whatever.

00:12:56.180 --> 00:12:57.308
But try to act generally--

00:12:57.308 --> 00:12:58.600
I mean, this class is recorded.

00:12:58.600 --> 00:13:01.600
So you know, what you
say might be heard.

00:13:01.600 --> 00:13:04.240
Now, if you get a slip,
there's some ground rules.

00:13:04.240 --> 00:13:05.630
You can't cheat.

00:13:05.630 --> 00:13:07.360
We're not dealing
with security here

00:13:07.360 --> 00:13:10.330
where a node that's 17
and connected to 27 and 29

00:13:10.330 --> 00:13:11.413
tells people that it's 14.

00:13:11.413 --> 00:13:12.580
I mean, you don't want that.

00:13:12.580 --> 00:13:14.680
It's hard enough to do
when you tell the truth.

00:13:14.680 --> 00:13:16.690
So don't cheat.

00:13:16.690 --> 00:13:18.250
There's probably
a variant of this

00:13:18.250 --> 00:13:20.417
we can come up with where
some fraction of the nodes

00:13:20.417 --> 00:13:22.900
are adversarial and one can't
see if this stuff even works.

00:13:22.900 --> 00:13:24.735
But right now, don't cheat.

00:13:24.735 --> 00:13:26.110
If you've got a
slip, you kind of

00:13:26.110 --> 00:13:28.540
have to really try to
participate in whatever

00:13:28.540 --> 00:13:30.040
protocol you come up with.

00:13:30.040 --> 00:13:33.040
And this experiment has no
human subjects approval.

00:13:35.540 --> 00:13:36.040
OK.

00:13:36.040 --> 00:13:40.330
So who has the envelope?

00:13:40.330 --> 00:13:41.800
Is it empty?

00:13:41.800 --> 00:13:43.470
Oh my goodness, it's
7 minutes already.

00:13:43.470 --> 00:13:44.670
Let's move it around.

00:13:49.400 --> 00:13:49.900
OK.

00:13:49.900 --> 00:13:52.150
When the envelope gets empty,
we can start this thing.

00:13:52.150 --> 00:13:55.456
So we should try
to move it along.

00:13:55.456 --> 00:13:57.100
Is everyone clear on the rules?

00:13:57.100 --> 00:14:00.910
What you're trying to do is to
find a path between the source

00:14:00.910 --> 00:14:03.190
node, which was numbered
1, and the destination

00:14:03.190 --> 00:14:04.660
node that was numbered 40.

00:14:04.660 --> 00:14:07.113
The source and the destination
know who they each are.

00:14:07.113 --> 00:14:08.530
And then we're
just going to wait.

00:14:08.530 --> 00:14:10.113
This is the easiest
lecture to prepare

00:14:10.113 --> 00:14:14.120
for because I just have to
keep quiet for a few minutes.

00:14:14.120 --> 00:14:14.660
OK.

00:14:14.660 --> 00:14:16.910
And if things don't work
out or things don't work,

00:14:16.910 --> 00:14:18.010
whatever it is, I'm
assuming that you'll

00:14:18.010 --> 00:14:20.800
come up with some variant of
a reasonable routing protocol.

00:14:20.800 --> 00:14:23.230
And odds are, it'll
be a variant of one

00:14:23.230 --> 00:14:24.640
of the ones we're
going to study.

00:14:24.640 --> 00:14:27.100
You know, the gentleman
here who suggested

00:14:27.100 --> 00:14:29.110
something was a reasonable
idea, which is you

00:14:29.110 --> 00:14:34.113
go and you pick one
neighbor and you go through.

00:14:34.113 --> 00:14:36.030
But you get stuck in a
loop, and then the idea

00:14:36.030 --> 00:14:37.330
is you come back
to where you start.

00:14:37.330 --> 00:14:38.740
And then you go
through the next.

00:14:38.740 --> 00:14:41.083
And that principle
could work, but you

00:14:41.083 --> 00:14:43.500
got to remember a lot of stuff
and tends to make mistakes.

00:14:43.500 --> 00:14:45.597
And in fact, this
was an easy network

00:14:45.597 --> 00:14:47.680
where every node had one,
two, or three neighbors.

00:14:47.680 --> 00:14:49.722
I mean, there's a few with
more, but most of them

00:14:49.722 --> 00:14:51.070
had a small number of neighbors.

00:14:51.070 --> 00:14:52.330
What you guys were
going after was

00:14:52.330 --> 00:14:53.980
a sort of better plan,
which everybody yells out

00:14:53.980 --> 00:14:54.550
their neighbors.

00:14:54.550 --> 00:14:56.967
And then they yell out their
neighbors and their neighbors

00:14:56.967 --> 00:14:57.675
and so forth.

00:14:57.675 --> 00:14:59.800
And that particular protocol
has a nice name to it.

00:14:59.800 --> 00:15:04.960
It's called link-state routing,
where you broadcast and flood

00:15:04.960 --> 00:15:08.140
your own neighbor
information, OK?

00:15:08.140 --> 00:15:10.930
That's the second of the two
protocols we're going to study.

00:15:10.930 --> 00:15:15.400
What you were trying to go
after was link-state routing.

00:15:15.400 --> 00:15:19.235
Now, the first protocol
we're going to study

00:15:19.235 --> 00:15:20.360
has a different name to it.

00:15:20.360 --> 00:15:22.000
It's called distance
vector routing.

00:15:27.200 --> 00:15:30.230
And these are the two routing
protocols we're going to study.

00:15:30.230 --> 00:15:32.150
Almost all routing
protocols in practice

00:15:32.150 --> 00:15:35.160
are variants of either
a vector protocol or one

00:15:35.160 --> 00:15:36.410
of these link-state protocols.

00:15:36.410 --> 00:15:39.375
There's lots of variance.

00:15:39.375 --> 00:15:41.260
And there's hundreds
of routing protocols,

00:15:41.260 --> 00:15:45.140
but these cover
the main concepts.

00:15:45.140 --> 00:15:47.820
So let me tell you how
distance vector protocols

00:15:47.820 --> 00:15:50.103
or how these vector
protocols work.

00:15:50.103 --> 00:15:52.270
They're a little different
from the kind of approach

00:15:52.270 --> 00:15:56.350
you were going after in
solving this problem.

00:15:56.350 --> 00:16:00.220
Had you gone after an
approach where you started

00:16:00.220 --> 00:16:03.030
at the destination, at 40--

00:16:03.030 --> 00:16:06.780
and 40 simply said, I'm 40.

00:16:06.780 --> 00:16:11.650
And then the neighbors next to
40 then said, I'm connected 40.

00:16:11.650 --> 00:16:13.750
To get to 40, come through me.

00:16:13.750 --> 00:16:16.780
And the cost is, let's
say, whatever the cost

00:16:16.780 --> 00:16:19.730
of their link to 40 is, right?

00:16:19.730 --> 00:16:22.990
Then, now, initially, nodes
only knew about themselves.

00:16:22.990 --> 00:16:24.370
But, now, you have
a destination.

00:16:24.370 --> 00:16:25.745
And you have a
set of nodes going

00:16:25.745 --> 00:16:26.925
to get to the destination.

00:16:26.925 --> 00:16:27.925
Let's call these nodes--

00:16:30.700 --> 00:16:36.100
let's just say n1, n2, and n3.

00:16:36.100 --> 00:16:39.940
Initially, the only thing
that D says is I am D.

00:16:39.940 --> 00:16:42.580
And it says that to its
neighbors along these links.

00:16:46.010 --> 00:16:47.510
This saying has a name to it.

00:16:47.510 --> 00:16:49.193
It's an advertisement.

00:16:53.270 --> 00:16:57.140
Now, when anyone hears
about destination D,

00:16:57.140 --> 00:16:59.421
it can do the same
thing to its neighbors.

00:17:02.580 --> 00:17:07.190
So let's say these
are n4 and n5 here.

00:17:07.190 --> 00:17:09.829
What n1 can do is to
say that, to get to D,

00:17:09.829 --> 00:17:13.280
let's imagine that
this cost here is 6.

00:17:13.280 --> 00:17:16.099
So D says, I'm D. And
the cost to get to me

00:17:16.099 --> 00:17:18.910
is 0 because I'm D.

00:17:18.910 --> 00:17:20.760
n1 here's that.

00:17:20.760 --> 00:17:23.000
And it says, I'm n1.

00:17:23.000 --> 00:17:23.569
That's true.

00:17:23.569 --> 00:17:27.109
But to get to D, come
through me and the cost is 6.

00:17:27.109 --> 00:17:28.670
So it now puts
out advertisements

00:17:28.670 --> 00:17:30.020
along these links.

00:17:30.020 --> 00:17:40.910
But it says, D:6, D:6, D:6,
where 6 is the cost of that

00:17:40.910 --> 00:17:42.960
link.

00:17:42.960 --> 00:17:45.360
Now, let's imagine that
these other links have cost.

00:17:45.360 --> 00:17:47.570
So let's say this
link has a cost of 8.

00:17:47.570 --> 00:17:49.730
This link has a cost of 2.

00:17:49.730 --> 00:17:53.830
Let's say this link
has a cost of 9.

00:17:53.830 --> 00:17:55.290
Sorry, I should
draw this better.

00:17:55.290 --> 00:17:56.360
Let's put a 9 here.

00:17:56.360 --> 00:17:57.880
So the link cost is 8.

00:17:57.880 --> 00:17:58.850
The link cost is 9.

00:17:58.850 --> 00:18:00.310
And the link cost is 2.

00:18:00.310 --> 00:18:02.970
And let's say for a minute here
that this cost of this link

00:18:02.970 --> 00:18:05.570
is 10.

00:18:05.570 --> 00:18:10.660
Now, n1 advertises to
everybody saying, to get to D,

00:18:10.660 --> 00:18:11.680
the cost is 6.

00:18:11.680 --> 00:18:13.030
To get to D, the cost to 6.

00:18:13.030 --> 00:18:15.220
And to get to D, the cost of 6.

00:18:15.220 --> 00:18:17.950
Each of those guys, when
they get this information,

00:18:17.950 --> 00:18:24.250
now know that they can get
a route to destination D.

00:18:24.250 --> 00:18:29.110
Because now n4 knows that, if
it used this link to get to D,

00:18:29.110 --> 00:18:33.250
the cost would be 6 plus
the cost of that link.

00:18:33.250 --> 00:18:34.400
So it's 14.

00:18:34.400 --> 00:18:39.107
So it would have a routing table
entry that says D is cost 14.

00:18:39.107 --> 00:18:40.690
And of course, its
routing table entry

00:18:40.690 --> 00:18:45.370
would have an entry saying this
is the link that it should use.

00:18:45.370 --> 00:18:51.720
Similarly, n5 here
would take destination D

00:18:51.720 --> 00:18:53.550
and say that the
cost to destination D

00:18:53.550 --> 00:18:57.360
is 9 plus the
advertisement, which was 6.

00:18:57.360 --> 00:19:01.750
And so it would say D is 15.

00:19:01.750 --> 00:19:04.200
And n2, which previously
had it a route to D, which

00:19:04.200 --> 00:19:08.190
was this link at cost 10, would
look at this new advertisement

00:19:08.190 --> 00:19:14.530
coming in here saying that
the cost on this from n1 is 6.

00:19:14.530 --> 00:19:18.070
Add that cost to the cost
of the link, which is 2,

00:19:18.070 --> 00:19:22.560
and have now a different way
to get to D whose cost is 8.

00:19:22.560 --> 00:19:24.530
And compare that
cost against the cost

00:19:24.530 --> 00:19:27.320
it previously held
to destination D.

00:19:27.320 --> 00:19:30.060
And because we're interested
in minimum cost routing,

00:19:30.060 --> 00:19:31.450
8 is smaller than 10.

00:19:31.450 --> 00:19:36.660
So n2, which previously had a
cost to destination D of 10,

00:19:36.660 --> 00:19:40.540
would throw that route out
and replace it with a route

00:19:40.540 --> 00:19:44.160
to destination D
going along this link

00:19:44.160 --> 00:19:48.740
with the cost of, now, 8,
which is smaller than 10.

00:19:48.740 --> 00:19:51.820
And this process just continues
through as it goes along.

00:19:51.820 --> 00:19:54.750
So you might end up in a
situation quite easily, as we

00:19:54.750 --> 00:19:56.760
just went through here,
where, let's say, n3

00:19:56.760 --> 00:19:58.260
were connected to n5.

00:19:58.260 --> 00:20:00.346
If this link had a
cost of 1 and this link

00:20:00.346 --> 00:20:02.460
had a cost of 4,
what would eventually

00:20:02.460 --> 00:20:05.760
happen is that n5, which
ended up with a cost of 15

00:20:05.760 --> 00:20:07.740
to go like that,
would, when it hears

00:20:07.740 --> 00:20:10.080
an advertisement from
this node, replace

00:20:10.080 --> 00:20:14.430
that route with a cost of 4
and use this link as its route

00:20:14.430 --> 00:20:18.240
to get to destination D. And
this process just continues

00:20:18.240 --> 00:20:21.510
until everybody has
initially some route to D.

00:20:21.510 --> 00:20:24.300
And then if the process
continues a little bit longer,

00:20:24.300 --> 00:20:28.320
everybody will have a
minimum cost route to D.

00:20:28.320 --> 00:20:32.580
This step, where nodes
evaluate an advertisement

00:20:32.580 --> 00:20:35.560
that they hear
about a destination

00:20:35.560 --> 00:20:37.560
against their current
route and the current cost

00:20:37.560 --> 00:20:41.460
to the destination,
and replace it

00:20:41.460 --> 00:20:44.880
if they end up finding
a route with smaller

00:20:44.880 --> 00:20:48.998
cost or an advertisement
with smaller cost, when

00:20:48.998 --> 00:20:51.540
the cost you have to compare is
the cost of the advertisement

00:20:51.540 --> 00:20:55.440
plus the cost of the link along
which that advertisement came

00:20:55.440 --> 00:20:57.240
and you compare that
cost against the cost

00:20:57.240 --> 00:20:59.520
of the route you already
hold, if it's smaller,

00:20:59.520 --> 00:21:01.290
you replace it.

00:21:01.290 --> 00:21:06.310
That algorithm is called the
Bellman-Ford for algorithm.

00:21:06.310 --> 00:21:09.000
And you might have seen
centralized implementations

00:21:09.000 --> 00:21:11.680
of shortest path routing
using this algorithm.

00:21:11.680 --> 00:21:14.160
And if you have, it
actually turns out

00:21:14.160 --> 00:21:16.360
it's a little less efficient
than another algorithm,

00:21:16.360 --> 00:21:18.300
another one we'll the
study called Dijkstra,

00:21:18.300 --> 00:21:19.680
if you're doing it centralized.

00:21:19.680 --> 00:21:21.870
But it's very, very elegant
elegant for distributed

00:21:21.870 --> 00:21:25.950
computation because the routes
to different destinations

00:21:25.950 --> 00:21:29.010
are being computed in a
completely distributed way.

00:21:29.010 --> 00:21:31.680
These nodes far away
here have no idea

00:21:31.680 --> 00:21:33.623
what the network
topology looks like.

00:21:33.623 --> 00:21:35.790
They couldn't even reconstruct
the network topology.

00:21:35.790 --> 00:21:37.748
The best they could do
is to find their own way

00:21:37.748 --> 00:21:39.540
to get their linked to use.

00:21:39.540 --> 00:21:41.370
The only information
they have is what

00:21:41.370 --> 00:21:43.080
they hear from their neighbors.

00:21:43.080 --> 00:21:45.673
But, yet, they're
able to find an answer

00:21:45.673 --> 00:21:47.340
because all they have
to do is to listen

00:21:47.340 --> 00:21:50.820
to all their neighbors and,
among the set of neighbors,

00:21:50.820 --> 00:21:54.720
pick that neighbor
who's advertised

00:21:54.720 --> 00:21:57.630
cost plus the cost of
the link to that neighbor

00:21:57.630 --> 00:22:00.670
is minimum across
all of the neighbors.

00:22:00.670 --> 00:22:02.190
So the computation
that's being done

00:22:02.190 --> 00:22:03.510
is a very simple computation.

00:22:03.510 --> 00:22:05.340
It's a very elegant
computation, which

00:22:05.340 --> 00:22:10.890
is the min over all of the
neighbors of the link cost LIJ

00:22:10.890 --> 00:22:15.540
plus the advertised cost from J
where the minimum is done over

00:22:15.540 --> 00:22:22.500
that all J, where J is
the set of neighbors of I.

00:22:22.500 --> 00:22:24.810
So you minimize over the
set of the neighbors.

00:22:24.810 --> 00:22:25.890
Each node I does this.

00:22:25.890 --> 00:22:29.650
You minimize over the
set of neighbors J of I.

00:22:29.650 --> 00:22:33.720
The link cost from I to J
plus the advertised cost

00:22:33.720 --> 00:22:36.950
to destination D of J.

00:22:36.950 --> 00:22:38.630
And you take the minimum cost.

00:22:38.630 --> 00:22:39.630
That's the minimum cost.

00:22:39.630 --> 00:22:41.830
And then you take the link
corresponding to that neighbor.

00:22:41.830 --> 00:22:43.247
And that's the
route that you use.

00:22:47.020 --> 00:22:49.400
Now, this algorithm gets
more complicated and tricky

00:22:49.400 --> 00:22:51.140
to argue that it's correct
when there are failures.

00:22:51.140 --> 00:22:52.515
But today, there
are no failures.

00:22:55.562 --> 00:22:57.520
There's another wrinkle
in the algorithm, which

00:22:57.520 --> 00:23:02.860
is I mentioned that what are the
conditions under which a node

00:23:02.860 --> 00:23:06.350
changes its route
to a destination.

00:23:06.350 --> 00:23:08.320
So I went through one rule.

00:23:08.320 --> 00:23:12.280
I mentioned a rule that
said, if the current route

00:23:12.280 --> 00:23:14.860
to the destination does
not exist, in which case

00:23:14.860 --> 00:23:17.470
the cost is assumed
to be infinity,

00:23:17.470 --> 00:23:20.770
or if the current cost
to the destination

00:23:20.770 --> 00:23:24.700
is smaller than the cost of
the advertisement plus the cost

00:23:24.700 --> 00:23:27.310
of the link along which
the advertisement came,

00:23:27.310 --> 00:23:30.743
then you replace the
route to the destination.

00:23:30.743 --> 00:23:32.410
But there's actually
one other condition

00:23:32.410 --> 00:23:35.000
under which you should replace
that route to the destination.

00:23:38.840 --> 00:23:39.800
Yeah.

00:23:39.800 --> 00:23:42.035
AUDIENCE: [INAUDIBLE]

00:23:42.035 --> 00:23:43.660
HARI BALAKRISHNAN:
If it's equal, well,

00:23:43.660 --> 00:23:45.410
technically, you don't
have to replace it.

00:23:45.410 --> 00:23:47.020
You still have a
good path, right?

00:23:47.020 --> 00:23:49.120
You could replace it,
but it doesn't matter.

00:23:49.120 --> 00:23:50.620
There might be a
case where you have

00:23:50.620 --> 00:23:55.450
to replace the link,
the route, when

00:23:55.450 --> 00:23:58.000
in fact the cost increases.

00:23:58.000 --> 00:24:02.320
There might be a case where
you have a current cost

00:24:02.320 --> 00:24:05.068
to the destination
and some current route

00:24:05.068 --> 00:24:05.860
to the destination.

00:24:05.860 --> 00:24:07.240
And you hear an
advertisement, and you

00:24:07.240 --> 00:24:08.240
take that advertisement.

00:24:08.240 --> 00:24:10.600
And you add the link cost,
and you find a bigger number.

00:24:10.600 --> 00:24:12.670
And you might sometimes
have to replace it.

00:24:15.760 --> 00:24:17.106
Yes.

00:24:17.106 --> 00:24:23.358
AUDIENCE: [INAUDIBLE]

00:24:23.358 --> 00:24:24.400
HARI BALAKRISHNAN: Right.

00:24:24.400 --> 00:24:27.430
It could be that what's going
on here is that the cost

00:24:27.430 --> 00:24:30.100
to the destination, a link--

00:24:30.100 --> 00:24:32.768
I previously told you that my
cost to the destination is 17.

00:24:32.768 --> 00:24:34.060
And, now, I've changed my mind.

00:24:34.060 --> 00:24:36.045
I tell you that
it's actually 19.

00:24:36.045 --> 00:24:38.170
And I could change my mind
for a variety of reasons

00:24:38.170 --> 00:24:39.400
usually having to
do with failure.

00:24:39.400 --> 00:24:41.650
So I guess this is a little
bit of a cheating question

00:24:41.650 --> 00:24:43.390
because I told you
there's no failures.

00:24:43.390 --> 00:24:47.092
But it could be that
perhaps the cost of a link

00:24:47.092 --> 00:24:49.300
changed because it became
more expensive or something

00:24:49.300 --> 00:24:50.290
like that.

00:24:50.290 --> 00:24:51.810
And that's the only
sort of case you

00:24:51.810 --> 00:24:54.550
have to worry about where
a cost of the advertisement

00:24:54.550 --> 00:24:55.760
could increase.

00:24:55.760 --> 00:25:00.070
And if that cost increases
along your current route,

00:25:00.070 --> 00:25:02.710
like you think that the route
to the destination is 17,

00:25:02.710 --> 00:25:06.657
the cost is 17, but in
fact, it turns out to be 24.

00:25:06.657 --> 00:25:08.740
That's the time when you
have to change your entry

00:25:08.740 --> 00:25:09.615
in the routing table.

00:25:09.615 --> 00:25:11.900
You have to change the
cost associated with it.

00:25:11.900 --> 00:25:15.580
But, otherwise, it's basically
that's the algorithm.

00:25:15.580 --> 00:25:19.750
And it's summarized
over in this chart here.

00:25:19.750 --> 00:25:24.530
And I've gone through
pretty much all of it.

00:25:24.530 --> 00:25:26.146
Does anyone have any questions?

00:25:29.800 --> 00:25:32.900
No questions?

00:25:32.900 --> 00:25:37.220
How long does it take before
every node in the network--

00:25:37.220 --> 00:25:39.290
actually, before I get
to that, the reason

00:25:39.290 --> 00:25:41.210
it's called a
vector protocol is I

00:25:41.210 --> 00:25:43.990
showed you a picture
for one destination.

00:25:43.990 --> 00:25:46.310
But in fact, each
switch or each node

00:25:46.310 --> 00:25:48.030
does it for all destinations.

00:25:48.030 --> 00:25:53.990
So the general form of a
distance vector advertisement

00:25:53.990 --> 00:25:54.900
looks like this.

00:25:54.900 --> 00:26:02.150
It has a destination,
destination 1 colon cost 1,

00:26:02.150 --> 00:26:07.340
destination 2 colon cost 2,
destination 3 colon cost 3,

00:26:07.340 --> 00:26:09.080
and so forth for
all the destinations

00:26:09.080 --> 00:26:10.900
to which you have a cost.

00:26:10.900 --> 00:26:12.483
And initially when
you start, you

00:26:12.483 --> 00:26:14.150
don't know about any
of the other nodes.

00:26:14.150 --> 00:26:17.060
If you have a route to some
destination in general,

00:26:17.060 --> 00:26:19.130
then there's some cost
associated with it.

00:26:19.130 --> 00:26:21.680
If you know about a destination
but have no route to it,

00:26:21.680 --> 00:26:23.850
the cost is infinity.

00:26:23.850 --> 00:26:27.020
It'll turn out next week we'll
find that the value of infinity

00:26:27.020 --> 00:26:29.390
in this network has
to be pretty small,

00:26:29.390 --> 00:26:31.430
but that's because
this algorithm is not

00:26:31.430 --> 00:26:33.960
the world's best algorithm
for big networks.

00:26:33.960 --> 00:26:36.650
And I'll explain why infinity
has to be a small number,

00:26:36.650 --> 00:26:41.733
but theoretically we can
assume it's infinite.

00:26:41.733 --> 00:26:43.400
The reason it's called
a vector protocol

00:26:43.400 --> 00:26:47.060
is because the advertisements
are a vector of destination

00:26:47.060 --> 00:26:48.830
cost tuples.

00:26:48.830 --> 00:26:50.330
And so you send
these tuples around.

00:26:50.330 --> 00:26:51.872
And this is a vector
of these tuples.

00:26:51.872 --> 00:26:53.750
And, hence, this is
called a vector protocol.

00:26:53.750 --> 00:26:55.910
It really should be called
cost vector protocol.

00:26:55.910 --> 00:26:58.630
But initially, they ran this
thing where all of the links

00:26:58.630 --> 00:26:59.960
had cost of 1.

00:26:59.960 --> 00:27:01.910
And, therefore, they
were minimizing distance.

00:27:01.910 --> 00:27:03.420
And the name stuck.

00:27:03.420 --> 00:27:05.188
But if we wanted to
be perfectly precise,

00:27:05.188 --> 00:27:06.230
we would say cost vector.

00:27:06.230 --> 00:27:07.605
But then no one
else in the world

00:27:07.605 --> 00:27:09.150
would understand what you meant.

00:27:09.150 --> 00:27:11.590
So we say distance vector.

00:27:11.590 --> 00:27:14.690
OK, any questions?

00:27:14.690 --> 00:27:18.945
All right, for some
destination, how long

00:27:18.945 --> 00:27:20.820
does it take before
every node in the network

00:27:20.820 --> 00:27:24.310
has a route to that destination?

00:27:24.310 --> 00:27:27.087
By how long, I mean, how
many advertisement cycles

00:27:27.087 --> 00:27:28.170
do you have to go through?

00:27:28.170 --> 00:27:30.720
How many of these
advertisements?

00:27:30.720 --> 00:27:33.180
Let's say that the way
our world is going to work

00:27:33.180 --> 00:27:35.700
is initially every
node advertises

00:27:35.700 --> 00:27:37.680
its own advertisement to itself.

00:27:37.680 --> 00:27:39.720
Then at the next
time step, every node

00:27:39.720 --> 00:27:41.850
advertises the routes
that it knows about.

00:27:41.850 --> 00:27:43.650
And then it does
that periodically.

00:27:43.650 --> 00:27:46.918
So let's say that, every t
seconds, a node sends out

00:27:46.918 --> 00:27:48.960
an advertisement where an
advertisement basically

00:27:48.960 --> 00:27:54.330
contains this vector of tuples
for all of the destination

00:27:54.330 --> 00:27:55.747
it knows about, right?

00:27:55.747 --> 00:27:57.330
So let me explain
this protocol again,

00:27:57.330 --> 00:28:00.150
and then I'll ask
you the question.

00:28:00.150 --> 00:28:01.750
The protocol is very simple.

00:28:01.750 --> 00:28:09.990
Every t seconds, what
the node is doing

00:28:09.990 --> 00:28:12.670
is looking at two columns
in its routing table.

00:28:12.670 --> 00:28:15.390
It's looking at the destination
column and the cost column.

00:28:15.390 --> 00:28:17.490
And it's just taking
that information out.

00:28:17.490 --> 00:28:20.790
And it sends out
an advertisement,

00:28:20.790 --> 00:28:26.190
the distance vector
advertisement, every t seconds.

00:28:26.190 --> 00:28:27.130
How long does it take?

00:28:27.130 --> 00:28:30.505
Now, let's focus on one
destination D, some destination

00:28:30.505 --> 00:28:31.320
D in the network.

00:28:31.320 --> 00:28:32.850
And you have some network.

00:28:32.850 --> 00:28:35.190
How long does it take
before every node has

00:28:35.190 --> 00:28:37.350
some route to the destination?

00:28:37.350 --> 00:28:38.053
Yes.

00:28:38.053 --> 00:28:41.952
AUDIENCE: [INAUDIBLE] up to
the number of [INAUDIBLE]..

00:28:41.952 --> 00:28:44.410
HARI BALAKRISHNAN: Up to the
number of edges in my network?

00:28:44.410 --> 00:28:46.390
AUDIENCE: Yeah, because
if you're [INAUDIBLE]..

00:28:46.390 --> 00:28:47.800
HARI BALAKRISHNAN: All right.

00:28:47.800 --> 00:28:50.008
So let's say you have a
network that looks like this.

00:28:56.045 --> 00:28:57.670
How long does it take
before every node

00:28:57.670 --> 00:28:58.878
has a route to destination D?

00:28:58.878 --> 00:29:00.940
AUDIENCE: So in that
case, it only takes one--

00:29:00.940 --> 00:29:02.190
HARI BALAKRISHNAN: Therefore--

00:29:02.190 --> 00:29:04.800
AUDIENCE: [INAUDIBLE] worst
case everything is in a line.

00:29:04.800 --> 00:29:05.400
HARI BALAKRISHNAN:
Well, I'm asking

00:29:05.400 --> 00:29:07.567
for an answer that holds
for all networks, not for--

00:29:07.567 --> 00:29:08.440
AUDIENCE: Oh, OK.

00:29:08.440 --> 00:29:10.320
What do you call the worst
case, like how fast [INAUDIBLE]..

00:29:10.320 --> 00:29:12.112
HARI BALAKRISHNAN:
Sure, in the worst case,

00:29:12.112 --> 00:29:16.090
it could-- well, yes.

00:29:16.090 --> 00:29:17.770
In the absolute worst
case, it is true

00:29:17.770 --> 00:29:19.950
that it'll always take time
smaller than the number

00:29:19.950 --> 00:29:20.950
of edges in the network.

00:29:20.950 --> 00:29:23.122
But you can come up with
a much better bound.

00:29:23.122 --> 00:29:24.580
So let's try to
come up-- yes, sir.

00:29:24.580 --> 00:29:26.970
AUDIENCE: What if you did the
number of nodes [INAUDIBLE]

00:29:26.970 --> 00:29:28.753
longest length chain?

00:29:28.753 --> 00:29:30.420
HARI BALAKRISHNAN:
Longest length chain,

00:29:30.420 --> 00:29:32.130
so that's not completely true.

00:29:32.130 --> 00:29:34.930
Longest, what kind
of longest length?

00:29:34.930 --> 00:29:37.110
So another counter
example, let's

00:29:37.110 --> 00:29:39.930
say that I have this network.

00:29:39.930 --> 00:29:43.397
The longest length chain
is 1, 2, 3, 4, 5, 6.

00:29:43.397 --> 00:29:45.480
But, yet, you guys just
told me that, in one shot,

00:29:45.480 --> 00:29:48.170
you get the answer.

00:29:48.170 --> 00:29:50.590
So you have to clarify what
you meant a little bit.

00:29:50.590 --> 00:29:53.242
You're almost right.

00:29:53.242 --> 00:29:54.976
[INTERPOSING VOICES]

00:29:54.976 --> 00:29:57.226
AUDIENCE: In this cast, it
might actually be 6, right?

00:29:57.226 --> 00:29:58.470
Because you want to find
that path of the top one

00:29:58.470 --> 00:29:59.262
and the bottom one?

00:29:59.262 --> 00:30:01.290
HARI BALAKRISHNAN:
I said find a path

00:30:01.290 --> 00:30:03.120
or find a route,
not the best route.

00:30:03.120 --> 00:30:04.443
AUDIENCE: [INAUDIBLE]

00:30:04.443 --> 00:30:06.110
HARI BALAKRISHNAN:
How long does it take

00:30:06.110 --> 00:30:07.318
to find a route in a network?

00:30:07.318 --> 00:30:08.570
You said this almost.

00:30:08.570 --> 00:30:11.030
The longest path-- but it's
not quite the longest path.

00:30:11.030 --> 00:30:13.670
It's the longest something path.

00:30:13.670 --> 00:30:14.655
Yes?

00:30:14.655 --> 00:30:15.530
AUDIENCE: [INAUDIBLE]

00:30:15.530 --> 00:30:17.405
HARI BALAKRISHNAN: The
longest shortest path,

00:30:17.405 --> 00:30:20.540
that is the the
longest path when

00:30:20.540 --> 00:30:22.190
you compute the
longest over all paths

00:30:22.190 --> 00:30:24.680
with a minimum number of hops
between one place to another.

00:30:24.680 --> 00:30:27.140
That's also called the
diameter of the network.

00:30:27.140 --> 00:30:28.620
OK?

00:30:28.620 --> 00:30:29.120
Yes?

00:30:29.120 --> 00:30:30.550
Yes?

00:30:30.550 --> 00:30:31.510
OK.

00:30:31.510 --> 00:30:35.020
All right, now, that's the time
it takes a multiplied by t.

00:30:35.020 --> 00:30:36.130
And I might be off by 1.

00:30:36.130 --> 00:30:37.978
You know, it's that minus 1.

00:30:37.978 --> 00:30:38.770
Actually, it's not.

00:30:38.770 --> 00:30:43.150
It is the number of hops along
the longest shortest path.

00:30:43.150 --> 00:30:48.730
Now, how long does it take
to find the minimum cost

00:30:48.730 --> 00:30:53.620
path to some destination
D at all of the nodes?

00:30:57.548 --> 00:30:59.003
AUDIENCE: [INAUDIBLE]

00:30:59.003 --> 00:31:00.003
HARI BALAKRISHNAN: What?

00:31:00.003 --> 00:31:01.705
AUDIENCE: [INAUDIBLE]

00:31:01.705 --> 00:31:03.330
HARI BALAKRISHNAN:
t times-- no, that's

00:31:03.330 --> 00:31:04.913
true that you can
find it within that.

00:31:04.913 --> 00:31:07.590
That's too long.

00:31:07.590 --> 00:31:09.570
So I'm going to come
back to this question.

00:31:09.570 --> 00:31:14.457
It's probably answered
in chapter 18, I think.

00:31:14.457 --> 00:31:16.040
But we've come back
to that next time.

00:31:16.040 --> 00:31:17.320
It'll become a
little bit clearer.

00:31:17.320 --> 00:31:18.130
But you should think about it.

00:31:18.130 --> 00:31:20.310
There's a nice, succinct
answer to this question.

00:31:20.310 --> 00:31:21.917
And generally speaking,
in every quiz,

00:31:21.917 --> 00:31:23.500
there's some variant
of this question.

00:31:23.500 --> 00:31:25.500
So you know, it's not
explicit, but there's

00:31:25.500 --> 00:31:27.660
some story that requires--
yes, you have an answer?

00:31:27.660 --> 00:31:28.680
AUDIENCE: No, I have a question.

00:31:28.680 --> 00:31:29.320
HARI BALAKRISHNAN: Oh, you do.

00:31:29.320 --> 00:31:30.020
OK.

00:31:30.020 --> 00:31:31.530
I'll come back to that
question next time.

00:31:31.530 --> 00:31:32.070
But yes?

00:31:32.070 --> 00:31:33.945
AUDIENCE: Can you go
over again what you mean

00:31:33.945 --> 00:31:35.380
by the longest shortest path?

00:31:35.380 --> 00:31:37.470
HARI BALAKRISHNAN: Yeah,
I can go over that.

00:31:37.470 --> 00:31:42.860
So let's say you have D here.

00:31:48.640 --> 00:31:51.130
You look at this destination
D. And you look at,

00:31:51.130 --> 00:31:54.810
from every node, what's
the path with the smallest

00:31:54.810 --> 00:31:56.220
number of hops--

00:31:56.220 --> 00:31:58.680
number of hops, not cost--

00:31:58.680 --> 00:32:00.990
to get to that
destination, right?

00:32:00.990 --> 00:32:03.480
For this guy, it's 1, 2, 3.

00:32:03.480 --> 00:32:07.680
For this guy, it's
1, 2, 3, et cetera.

00:32:07.680 --> 00:32:12.130
Whatever that biggest number is
multiplied by t is the answer.

00:32:12.130 --> 00:32:16.420
That's how long it takes before
every node hears some path.

00:32:16.420 --> 00:32:18.930
But it's not quite the right
answer for the best path.

00:32:18.930 --> 00:32:23.220
Because as you saw in this
example here, it took us

00:32:23.220 --> 00:32:26.980
one step before n2 got a
route to the destination.

00:32:26.980 --> 00:32:30.000
But it took us two time steps
before it got its best route

00:32:30.000 --> 00:32:30.823
to the destination.

00:32:30.823 --> 00:32:32.490
And the reason was
that it has something

00:32:32.490 --> 00:32:36.805
to do with the length of the
minimum cost path, right?

00:32:36.805 --> 00:32:39.180
Because in this case, the
length of the minimum cost path

00:32:39.180 --> 00:32:40.200
is 2 plus 6, 8.

00:32:40.200 --> 00:32:43.320
It took 2 hops, which is
different from the length

00:32:43.320 --> 00:32:45.870
of some shortest hop
path, which was one hop.

00:32:45.870 --> 00:32:49.120
So if I look at this picture,
n2 hears about some route

00:32:49.120 --> 00:32:52.110
to the destination in
the first advertisement.

00:32:52.110 --> 00:32:54.750
But then to find its best
route to the destination

00:32:54.750 --> 00:32:56.970
requires us to
actually wait around

00:32:56.970 --> 00:33:01.170
until we find this 2 plus
6 path, which took 2 hops.

00:33:01.170 --> 00:33:04.380
So it's a little longer, but
it's not enormously long.

00:33:04.380 --> 00:33:06.090
It's just a little bit longer.

00:33:06.090 --> 00:33:07.790
And the answer, of
course, depends.

00:33:07.790 --> 00:33:09.790
In the worst case, it
could be quite long.

00:33:09.790 --> 00:33:12.150
But it depends on
the number of hops

00:33:12.150 --> 00:33:14.400
along the minimum cost path.

00:33:14.400 --> 00:33:15.930
And if you minimize
that quantity,

00:33:15.930 --> 00:33:18.645
you'll find the answer
to the question,

00:33:18.645 --> 00:33:20.520
how long does it take
before every node finds

00:33:20.520 --> 00:33:23.010
the minimum cost path
to the destination.

00:33:23.010 --> 00:33:26.110
OK, is that clear?

00:33:26.110 --> 00:33:29.760
Any questions about
distance vector?

00:33:29.760 --> 00:33:31.330
Crystal clear?

00:33:31.330 --> 00:33:33.370
OK.

00:33:33.370 --> 00:33:35.950
We'll see when the
lab comes around.

00:33:35.950 --> 00:33:36.970
It is crystal.

00:33:36.970 --> 00:33:39.557
Everybody really, really
does well in these labs.

00:33:39.557 --> 00:33:41.390
And it's a lot of fun
hacking this stuff up.

00:33:41.390 --> 00:33:43.887
So you'll implement
both protocols.

00:33:43.887 --> 00:33:45.970
And you'll actually look
at all sorts of failures.

00:33:45.970 --> 00:33:47.838
And it'll just be
sometimes miraculous

00:33:47.838 --> 00:33:49.630
that it actually works
even when you didn't

00:33:49.630 --> 00:33:51.940
consider some failure cases.

00:33:51.940 --> 00:33:52.440
OK.

00:33:52.440 --> 00:33:54.440
Now, I'm going to talk
about link-state routing.

00:33:54.440 --> 00:33:56.630
And this is the routing
protocol that you guys

00:33:56.630 --> 00:33:59.710
were sort of attempting
to implement,

00:33:59.710 --> 00:34:01.570
attempting to come up with.

00:34:01.570 --> 00:34:04.180
This is a radically
different approach

00:34:04.180 --> 00:34:06.070
from the vector protocols.

00:34:06.070 --> 00:34:09.040
In a vector protocol,
everybody advertises,

00:34:09.040 --> 00:34:12.610
for each destination, a
vector of tuples where it's

00:34:12.610 --> 00:34:15.340
the destination and the cost.

00:34:15.340 --> 00:34:17.560
In a link-state protocol,
we don't do that.

00:34:17.560 --> 00:34:21.130
The link-state protocol does not
compute in a distributed way.

00:34:21.130 --> 00:34:24.670
In a link-state protocol, every
node just says, I am node 17.

00:34:24.670 --> 00:34:27.670
And I'm connected
to 16, 45, and 44.

00:34:27.670 --> 00:34:31.300
And the cost of my
link to 16 is 7.

00:34:31.300 --> 00:34:33.340
The cost of my link
to 45 is something.

00:34:33.340 --> 00:34:36.940
And my cost of my link to this
other neighbor that I have

00:34:36.940 --> 00:34:38.030
is something else.

00:34:38.030 --> 00:34:42.100
So every node advertises what
I've shown up on this slide.

00:34:42.100 --> 00:34:44.500
Every node advertises
a neighbor,

00:34:44.500 --> 00:34:48.900
its immediate neighbor, and
the link cost to that neighbor.

00:34:48.900 --> 00:34:50.800
OK.

00:34:50.800 --> 00:34:53.620
In addition, in each of these
link-state advertisements,

00:34:53.620 --> 00:34:55.429
there is a sequence number.

00:34:55.429 --> 00:34:57.610
The sequence number starts
at some initial value,

00:34:57.610 --> 00:34:58.690
like, say, zero.

00:34:58.690 --> 00:35:02.050
And every time one of these
link-state advertisements

00:35:02.050 --> 00:35:03.760
is sent-- and that's
done periodically

00:35:03.760 --> 00:35:05.552
as well, every t seconds.

00:35:05.552 --> 00:35:07.510
Every time you send a
link-state advertisement,

00:35:07.510 --> 00:35:10.810
you increment the
sequence number by one.

00:35:10.810 --> 00:35:12.670
Now, here's the key step.

00:35:12.670 --> 00:35:19.180
The key step here is
that, if I receive

00:35:19.180 --> 00:35:21.610
a link-state
advertisement from you,

00:35:21.610 --> 00:35:24.190
I just send that
to my neighbors.

00:35:24.190 --> 00:35:26.770
And then my neighbors will
send it to their neighbors

00:35:26.770 --> 00:35:27.400
and so on.

00:35:27.400 --> 00:35:30.400
So it's a very this
nice flooding protocol.

00:35:30.400 --> 00:35:34.420
Every node sends out its
link-state advertisement.

00:35:34.420 --> 00:35:38.110
And every neighbor that receives
it processes that and then

00:35:38.110 --> 00:35:40.990
turns around and ships
it to their neighbors.

00:35:40.990 --> 00:35:44.510
And they do the same thing to
their neighbors and so forth.

00:35:44.510 --> 00:35:46.960
Now, when this flooding process
completes and every node

00:35:46.960 --> 00:35:49.150
is originating its own
link-state advertisement--

00:35:49.150 --> 00:35:51.570
so you're telling
them your neighbors

00:35:51.570 --> 00:35:52.570
who you're connected to.

00:35:52.570 --> 00:35:54.850
She's telling her neighbors
who she's connected to.

00:35:54.850 --> 00:35:56.998
And we all do that.

00:35:56.998 --> 00:35:58.540
And we're all doing
this in parallel.

00:35:58.540 --> 00:36:00.040
It's all happening
at the same time.

00:36:00.040 --> 00:36:02.140
And all our neighbors
are rebroadcasting this.

00:36:02.140 --> 00:36:03.760
And eventually,
every node is going

00:36:03.760 --> 00:36:08.455
to get one or more copies of
every link-state advertisement,

00:36:08.455 --> 00:36:10.330
which means that every
node can now construct

00:36:10.330 --> 00:36:12.220
an entire map of the network.

00:36:12.220 --> 00:36:15.370
Every node can construct
this entire graph.

00:36:15.370 --> 00:36:16.930
And once they
construct that graph,

00:36:16.930 --> 00:36:20.260
every node can implement some
shortest path routing protocol

00:36:20.260 --> 00:36:22.707
to compute the paths
over that graph.

00:36:22.707 --> 00:36:24.790
This is very different
from the previous protocol.

00:36:24.790 --> 00:36:26.920
In vector routing
protocols, the nodes

00:36:26.920 --> 00:36:29.470
actually have no idea what the
topology of the network is.

00:36:29.470 --> 00:36:32.270
All they know is they trust
what the neighbors tell them.

00:36:32.270 --> 00:36:37.540
Here, under the basic
model, every node

00:36:37.540 --> 00:36:41.420
has complete knowledge of
the overall network topology.

00:36:41.420 --> 00:36:44.800
So let me show this
by example, and it

00:36:44.800 --> 00:36:46.250
will become completely clear.

00:36:46.250 --> 00:36:50.370
So let's imagine that this is
what the network looks like.

00:36:50.370 --> 00:36:54.820
I'm going to show you a
picture of node F. Node F

00:36:54.820 --> 00:36:56.905
originates its initial
link-state advertisement.

00:36:56.905 --> 00:36:59.530
And then every advertisement, it
increments the sequence number

00:36:59.530 --> 00:37:00.580
by 1.

00:37:00.580 --> 00:37:06.220
And it says, I'm connected
to node G with a cost of 8

00:37:06.220 --> 00:37:07.780
and to node C with a cost of 2.

00:37:07.780 --> 00:37:10.390
And it spits it out
to its neighbors.

00:37:10.390 --> 00:37:13.240
Each of those neighbors turns
around and does the same thing.

00:37:13.240 --> 00:37:17.170
You rebroadcast a link-state
advertisement along the links

00:37:17.170 --> 00:37:18.970
that you are connected to.

00:37:18.970 --> 00:37:20.977
And they rebroadcast
it and so forth.

00:37:20.977 --> 00:37:22.060
And eventually, B gets it.

00:37:22.060 --> 00:37:23.727
And he broadcasts it,
too, though it was

00:37:23.727 --> 00:37:25.995
completely useless to do so.

00:37:25.995 --> 00:37:26.870
Well, not completely.

00:37:26.870 --> 00:37:28.990
If packets are lost,
it's pretty useful.

00:37:28.990 --> 00:37:31.120
Anyway, when this
flooding completes,

00:37:31.120 --> 00:37:34.900
which takes some
number of steps,

00:37:34.900 --> 00:37:37.720
every node now has at least
one-- if no packets are lost,

00:37:37.720 --> 00:37:39.400
every node has a
bunch of copies of

00:37:39.400 --> 00:37:40.810
this link-state advertisement.

00:37:40.810 --> 00:37:44.050
If packets can get lost, as
long as the loss rates are not

00:37:44.050 --> 00:37:47.530
enormous, every node
might have one copy

00:37:47.530 --> 00:37:49.270
of a link-state advertisement.

00:37:49.270 --> 00:37:51.820
And, now, every node
originates its own link-state

00:37:51.820 --> 00:37:52.420
advertisement.

00:37:52.420 --> 00:37:55.903
And, therefore, they end up
with a map of the network.

00:37:55.903 --> 00:37:57.820
By the way, why do we
have the sequence number

00:37:57.820 --> 00:37:59.326
in the link-state advertisement?

00:38:03.520 --> 00:38:04.069
Yes?

00:38:04.069 --> 00:38:08.460
AUDIENCE: I don't know, if F
broadcasts its advertisement

00:38:08.460 --> 00:38:11.010
and something changes and it
broadcasts a new advertisement,

00:38:11.010 --> 00:38:13.110
by the time the two
advertisements get to B,

00:38:13.110 --> 00:38:14.250
you don't know which
one gets there first.

00:38:14.250 --> 00:38:15.600
So you want to [INAUDIBLE].

00:38:15.600 --> 00:38:17.370
HARI BALAKRISHNAN: That
is one of the two reasons

00:38:17.370 --> 00:38:18.037
why you have it.

00:38:18.037 --> 00:38:20.007
That's actually
the second reason.

00:38:20.007 --> 00:38:21.090
And that's a valid reason.

00:38:21.090 --> 00:38:22.710
But the main reason
you have it is

00:38:22.710 --> 00:38:26.610
that, if C gets a link-state
advertisement originating

00:38:26.610 --> 00:38:30.180
from F with sequence number
17, and then eventually C

00:38:30.180 --> 00:38:32.740
is also going to
get D rebroadcasting

00:38:32.740 --> 00:38:33.990
that link-state advertisement.

00:38:33.990 --> 00:38:37.050
Because F sends it this way,
but F also sends it this way.

00:38:37.050 --> 00:38:39.060
And that goes up here,
and that comes down here.

00:38:39.060 --> 00:38:40.530
And then D rebroadcasts it.

00:38:40.530 --> 00:38:43.290
C needs a way of telling whether
this link-state advertisement

00:38:43.290 --> 00:38:45.865
is new or old, right?

00:38:45.865 --> 00:38:47.490
And the way it tells
if it's new or old

00:38:47.490 --> 00:38:50.100
is it considers a
link-state advertisement

00:38:50.100 --> 00:38:53.760
to be new if it's bigger
than the last sequence number

00:38:53.760 --> 00:38:56.805
it received from that origin.

00:38:56.805 --> 00:38:58.680
So, now, every node has
a map of the network.

00:38:58.680 --> 00:39:01.762
And, now, we run
this integration step

00:39:01.762 --> 00:39:03.720
where we actually take
this map of the network,

00:39:03.720 --> 00:39:05.730
and we find shortest
paths to the network.

00:39:05.730 --> 00:39:06.880
I need a show of hands.

00:39:06.880 --> 00:39:08.755
How many people know
how Dijkstra's algorithm

00:39:08.755 --> 00:39:09.780
works from class?

00:39:09.780 --> 00:39:12.113
How many people don't
know how it works?

00:39:12.113 --> 00:39:13.530
All right, what
I'm going to do is

00:39:13.530 --> 00:39:14.790
it's described very
well in the notes.

00:39:14.790 --> 00:39:16.457
We'll talk about in
recitation tomorrow,

00:39:16.457 --> 00:39:18.630
but I'm going to
show it by example.

00:39:18.630 --> 00:39:20.760
And then we'll come back
to this again on Monday.

00:39:20.760 --> 00:39:23.343
But I'm going to tell you this
now because you kind of need it

00:39:23.343 --> 00:39:24.090
for the lab.

00:39:24.090 --> 00:39:25.680
And it is described very
well in the readings.

00:39:25.680 --> 00:39:27.310
And we'll do it in
recitation as well.

00:39:27.310 --> 00:39:28.930
So here's how it works.

00:39:28.930 --> 00:39:30.510
Let's imagine we
want to find paths

00:39:30.510 --> 00:39:34.270
from A to all of the other
nodes in the network.

00:39:34.270 --> 00:39:36.990
Now, initially, A doesn't
know paths to anyone

00:39:36.990 --> 00:39:38.040
except for itself.

00:39:38.040 --> 00:39:40.440
But what A knows is
this map of the network.

00:39:40.440 --> 00:39:42.540
And what A is trying
to do is to find routes

00:39:42.540 --> 00:39:45.070
to all the other destinations.

00:39:45.070 --> 00:39:47.100
The way it does that
is it keeps building up

00:39:47.100 --> 00:39:51.720
in non-decreasing order of the
cost of the minimum cost back

00:39:51.720 --> 00:39:52.530
to the destination.

00:39:52.530 --> 00:39:55.070
It starts building up
information about the routes

00:39:55.070 --> 00:39:56.320
to the different destinations.

00:39:56.320 --> 00:39:58.200
So initially, it
looks at this table.

00:39:58.200 --> 00:40:00.240
And it says, it's
connected to C.

00:40:00.240 --> 00:40:02.580
And it's to get to
B with a cost of 6.

00:40:02.580 --> 00:40:04.745
So what it does is it
says, all right, among all

00:40:04.745 --> 00:40:06.120
of the people out
here, I'm going

00:40:06.120 --> 00:40:10.920
to pull in the person with
the minimum cost path.

00:40:10.920 --> 00:40:14.532
And in this case, it might
just pick the node C.

00:40:14.532 --> 00:40:15.990
Because between C
and B, it doesn't

00:40:15.990 --> 00:40:17.430
matter which one it picks.

00:40:17.430 --> 00:40:19.380
Now, the cost to all
of the other guys

00:40:19.380 --> 00:40:23.370
is considered to be infinity.

00:40:23.370 --> 00:40:26.540
So it has costs of 6 and 6,
so it pulls in one of them

00:40:26.540 --> 00:40:27.665
without loss of generality.

00:40:27.665 --> 00:40:29.150
It just picks one of them.

00:40:29.150 --> 00:40:30.890
And, now, it has
costs to both of them.

00:40:30.890 --> 00:40:34.760
And it says that the route from
A itself, at A, the route to C

00:40:34.760 --> 00:40:36.850
is this link.

00:40:36.850 --> 00:40:38.840
What it then does
is it goes and looks

00:40:38.840 --> 00:40:41.230
at all of the neighbors
connected to A and C.

00:40:41.230 --> 00:40:44.160
And in fact, it only has to look
at the new node it pulled in.

00:40:44.160 --> 00:40:47.210
And it has to adjust the
cost of the minimum cost path

00:40:47.210 --> 00:40:49.610
to the destination
that's connected to that.

00:40:49.610 --> 00:40:52.190
In this case, it
adjusts from infinity.

00:40:52.190 --> 00:40:54.440
It brings down the
cost to D to 13.

00:40:54.440 --> 00:40:57.060
Because it knows that
it can get to C in 6.

00:40:57.060 --> 00:40:58.310
6 plus 7 is 13.

00:40:58.310 --> 00:41:01.220
Similarly, it does
that for E at 10.

00:41:01.220 --> 00:41:03.590
And then it does that to F at 8.

00:41:03.590 --> 00:41:07.610
So, now, it has costs of 6,
6-- that 6 is already in--

00:41:07.610 --> 00:41:10.770
6, 13, 10, and 8, and infinity.

00:41:10.770 --> 00:41:13.130
So, now, it has to decide
what node to pull in next.

00:41:13.130 --> 00:41:16.040
And it pulls in the node
with the minimum cost

00:41:16.040 --> 00:41:18.140
among the costs that
you have so far.

00:41:18.140 --> 00:41:20.270
And that's this node over here.

00:41:20.270 --> 00:41:24.120
So it pulls that in
if my wireless works.

00:41:24.120 --> 00:41:25.170
There we go.

00:41:25.170 --> 00:41:28.090
And then once it pulls that
in, it adjusts the route

00:41:28.090 --> 00:41:29.870
to that to be that green link.

00:41:29.870 --> 00:41:32.780
And then it goes ahead and
looks at the neighbors of B.

00:41:32.780 --> 00:41:35.090
And it adjusts the
shortest path cost.

00:41:35.090 --> 00:41:37.730
In this case, that
13 now becomes 11

00:41:37.730 --> 00:41:41.330
because 6 plus 5 going through
B is shorter than 6 plus 7

00:41:41.330 --> 00:41:43.967
going through C.
And, now, it repeats.

00:41:43.967 --> 00:41:45.050
It pulls down the minimum.

00:41:45.050 --> 00:41:46.520
The minimum, in this case, is 8.

00:41:46.520 --> 00:41:49.610
It pulls in F, makes
that be the route to F.

00:41:49.610 --> 00:41:51.830
Now, the route to
F is not that link.

00:41:51.830 --> 00:41:55.070
The route to F is, in fact,
this link at the routing table.

00:41:55.070 --> 00:41:58.280
But it knows that because it
knows that F is connected to C.

00:41:58.280 --> 00:42:00.140
And, therefore,
the route to F is

00:42:00.140 --> 00:42:03.040
equal to the route to the
parent, which is C. Therefore,

00:42:03.040 --> 00:42:05.210
in its routing table
entry, it makes the route

00:42:05.210 --> 00:42:08.053
to F be that link, which
is exactly the link to C.

00:42:08.053 --> 00:42:10.220
So that's the subtlety you
have to keep in mind when

00:42:10.220 --> 00:42:12.890
you implement this
stuff in the lab.

00:42:12.890 --> 00:42:14.600
It goes ahead and
adjusts that to 16.

00:42:14.600 --> 00:42:18.690
It now pulls the minimum,
which will be 10,

00:42:18.690 --> 00:42:21.300
and then adjusts the cost
of the guys connected to it.

00:42:21.300 --> 00:42:24.590
So D changes to 10.

00:42:24.590 --> 00:42:27.070
And then it now goes ahead
and pulls the minimum in.

00:42:27.070 --> 00:42:31.870
In this case, it's D
with the cost of 10.

00:42:31.870 --> 00:42:33.290
That's the link to use.

00:42:33.290 --> 00:42:36.065
And that link,
therefore, the route to D

00:42:36.065 --> 00:42:37.940
is the same as the route
to E. The route to E

00:42:37.940 --> 00:42:40.500
is the same as the route
to C, which is that link.

00:42:40.500 --> 00:42:42.650
And, now, you finally
conclude the algorithm

00:42:42.650 --> 00:42:44.250
by getting that last node in.

00:42:46.870 --> 00:42:48.180
So I'm going to stop here.

00:42:48.180 --> 00:42:50.680
That was Dijkstra's algorithm
and the two routing protocols.

00:42:50.680 --> 00:42:53.230
We'll pick it up in
recitation tomorrow.