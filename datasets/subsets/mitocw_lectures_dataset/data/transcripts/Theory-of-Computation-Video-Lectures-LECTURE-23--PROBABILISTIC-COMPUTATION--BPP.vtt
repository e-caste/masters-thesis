WEBVTT

00:00:00.000 --> 00:00:04.990
[SQUEAKING]
[RUSTLING] [CLICKING]

00:00:24.980 --> 00:00:27.500
PROFESSOR: OK, hello, everybody.

00:00:27.500 --> 00:00:28.315
We'll get started.

00:00:31.780 --> 00:00:46.586
So just recapping what we did
in the last lecture on Tuesday,

00:00:46.586 --> 00:00:50.510
it was the second part
of a two-lecture sequence

00:00:50.510 --> 00:00:57.260
on the hierarchy theorems
for time and space

00:00:57.260 --> 00:01:00.320
and using the hierarchy
theorems to show

00:01:00.320 --> 00:01:04.730
that there is a problem,
which is intractable,

00:01:04.730 --> 00:01:08.600
that's provably outside
of polynomial time.

00:01:08.600 --> 00:01:11.960
And that was this equivalence
problem for regular expressions

00:01:11.960 --> 00:01:13.820
with exponentiation.

00:01:13.820 --> 00:01:18.200
And then we had a short
discussion about oracles

00:01:18.200 --> 00:01:22.730
and the possibility that similar
methods might be used to show

00:01:22.730 --> 00:01:25.790
that satisfiability
is outside of P,

00:01:25.790 --> 00:01:28.730
which would then of course
solve the P versus NP problem

00:01:28.730 --> 00:01:34.070
and argue that it seems unlikely
this kind of a meta theorem--

00:01:34.070 --> 00:01:38.330
not a well-defined notion--

00:01:38.330 --> 00:01:40.610
but it seems unlikely
that the methods that

00:01:40.610 --> 00:01:50.240
were used for proving the
intractability of equivalence

00:01:50.240 --> 00:01:52.010
of regular expressions
with explanation

00:01:52.010 --> 00:01:55.820
could be used to solve
P versus NP, at least

00:01:55.820 --> 00:02:00.380
the diagonalization method in a
pure form, whatever that means,

00:02:00.380 --> 00:02:04.770
that's not going to be enough.

00:02:04.770 --> 00:02:08.780
So today, we're going to
shift gears again, begin

00:02:08.780 --> 00:02:11.930
a somewhat different
topic, which is really

00:02:11.930 --> 00:02:17.060
going to be our,
again, a few lectures

00:02:17.060 --> 00:02:20.720
on probabilistic computation,
which is going to round out

00:02:20.720 --> 00:02:23.342
the semester for us.

00:02:23.342 --> 00:02:24.800
And we're going to
start by talking

00:02:24.800 --> 00:02:27.800
about a different model
of computation which

00:02:27.800 --> 00:02:32.332
allows for probabilism
in the measuring

00:02:32.332 --> 00:02:34.040
the amount of probabilism
we're measuring

00:02:34.040 --> 00:02:37.430
the probabilities allowing for
probabilism in the computation

00:02:37.430 --> 00:02:39.650
defined an associated
complexity class--

00:02:39.650 --> 00:02:45.710
this class BPP-- and then start
the discussion of an example

00:02:45.710 --> 00:02:48.410
about something called
branching programs.

00:02:48.410 --> 00:02:52.640
OK, so with that in mind--

00:03:01.800 --> 00:03:03.870
so we're going to
start off by defining

00:03:03.870 --> 00:03:09.644
the notion of a Probabilistic
Turing Machine or PTM.

00:03:09.644 --> 00:03:11.880
The Probabilistic
Turing Machine is

00:03:11.880 --> 00:03:14.070
a lot like the way
we have thought

00:03:14.070 --> 00:03:17.580
about not deterministic
Turing machines in that it's

00:03:17.580 --> 00:03:21.180
a kind of a machine that
can have multiple choices,

00:03:21.180 --> 00:03:24.400
multiple ways to go
in its computation.

00:03:24.400 --> 00:03:28.608
So there's not just going to
be a fixed deterministic path

00:03:28.608 --> 00:03:30.150
of its computation,
but there's going

00:03:30.150 --> 00:03:32.620
to be a tree of possibilities.

00:03:32.620 --> 00:03:34.710
And for our
purposes, we're going

00:03:34.710 --> 00:03:37.140
to limit the
branching in that tree

00:03:37.140 --> 00:03:40.910
to be either a step
of the computation

00:03:40.910 --> 00:03:42.680
where there's no
branching, where

00:03:42.680 --> 00:03:46.590
it's a deterministic
step, as shown over here.

00:03:46.590 --> 00:03:50.510
So every step of the way leads
uniquely to the next step.

00:03:50.510 --> 00:03:53.090
Or there might be some
steps which have a choice.

00:03:53.090 --> 00:03:56.510
And we're only going to
allow for these purposes

00:03:56.510 --> 00:04:00.470
to keep life simple,
having only a choice

00:04:00.470 --> 00:04:03.590
among two possibilities.

00:04:03.590 --> 00:04:10.610
And we'll associate
to that the notion

00:04:10.610 --> 00:04:17.060
of a probability that each
choice will have a 50-50 chance

00:04:17.060 --> 00:04:18.470
of getting taken.

00:04:18.470 --> 00:04:22.160
And this kind of corresponds
with the way some of us

00:04:22.160 --> 00:04:24.560
or some of you think about
non-determinism, which

00:04:24.560 --> 00:04:27.170
is not exactly right
up until this point,

00:04:27.170 --> 00:04:30.085
is that the machine is kind
of taking a random branch.

00:04:30.085 --> 00:04:32.210
Really, we don't think
about it randomly until now.

00:04:32.210 --> 00:04:33.960
Now we're going to
think about the machine

00:04:33.960 --> 00:04:37.880
as actually picking a
random choice among all

00:04:37.880 --> 00:04:40.380
the different branches
that it could make

00:04:40.380 --> 00:04:43.550
and picking that choice
uniformly by flipping

00:04:43.550 --> 00:04:47.790
a coin every time it has an
option of which way to go.

00:04:47.790 --> 00:04:49.400
Now you could define--

00:04:49.400 --> 00:04:52.190
I'm getting a question here--

00:04:52.190 --> 00:04:54.740
a machine that has several
different ways to--

00:04:54.740 --> 00:04:56.178
more than two ways to go.

00:04:56.178 --> 00:04:58.220
And then you would need
to have a three-way coin,

00:04:58.220 --> 00:04:59.760
a four-way coin, and so on.

00:04:59.760 --> 00:05:02.580
And you could define it
all that way as well.

00:05:02.580 --> 00:05:05.720
But it doesn't end up giving you
anything different or anything

00:05:05.720 --> 00:05:08.960
interesting or new for
the kinds of things

00:05:08.960 --> 00:05:10.400
we're going to be discussing.

00:05:10.400 --> 00:05:11.775
And it's just
going to be simpler

00:05:11.775 --> 00:05:13.790
to keep the discussion
limited to the case

00:05:13.790 --> 00:05:17.090
where the machine can only
have two possibilities if it's

00:05:17.090 --> 00:05:20.570
going to be having a choice
at all or just one possibility

00:05:20.570 --> 00:05:23.220
when there's no choice.

00:05:23.220 --> 00:05:26.040
OK, so now, we're
going to have to talk

00:05:26.040 --> 00:05:28.980
about the probability
of the machine

00:05:28.980 --> 00:05:31.590
taking some branch
of its computation.

00:05:31.590 --> 00:05:34.740
So you imagine here, here
is the same computation tree

00:05:34.740 --> 00:05:36.660
that we've seen
before in the case

00:05:36.660 --> 00:05:39.150
of ordinary
non-deterministic machines,

00:05:39.150 --> 00:05:41.190
where you have M on w.

00:05:41.190 --> 00:05:43.200
There could be several
different ways to go.

00:05:43.200 --> 00:05:45.240
And there might be
some particular branch.

00:05:45.240 --> 00:05:47.520
But now, we want to talk
about the probability

00:05:47.520 --> 00:05:52.510
that the machine actually
ends up picking that branch.

00:05:52.510 --> 00:05:59.530
And it's going to be when we
talk about the machine having

00:05:59.530 --> 00:06:01.510
a choice of ways
to go, we're going

00:06:01.510 --> 00:06:03.140
to associate that
with a coin flip.

00:06:03.140 --> 00:06:05.140
So we're going to call
that a coin flip step

00:06:05.140 --> 00:06:07.720
when the machine has a
possibility of ways to go.

00:06:07.720 --> 00:06:11.500
And so on a particular
branch, the probability

00:06:11.500 --> 00:06:15.490
of that branch occurring
is going to be 1 over 2

00:06:15.490 --> 00:06:22.000
to the number of coin flip
states on that branch.

00:06:22.000 --> 00:06:23.240
and the reason for--

00:06:23.240 --> 00:06:29.210
I mean, this is kind of the
definition that makes sense

00:06:29.210 --> 00:06:33.050
in that if you imagine looking
at the computation tree here--

00:06:33.050 --> 00:06:37.880
and here is the branch that
we're focusing on of interest--

00:06:37.880 --> 00:06:41.150
every time there's a
coin flip on that branch,

00:06:41.150 --> 00:06:44.540
there's a 50-50 chance of
taking a different branch

00:06:44.540 --> 00:06:46.770
or staying on that branch.

00:06:46.770 --> 00:06:50.510
So the more coin flips there
are on some particular branch,

00:06:50.510 --> 00:06:52.070
the less likely
that branch would

00:06:52.070 --> 00:06:55.940
be the one that the machine
actually ends up taking.

00:06:55.940 --> 00:06:59.480
And so it's going to be 1 over
2 to the number of coin flips.

00:06:59.480 --> 00:07:02.530
And that's the way
we're defining it.

00:07:02.530 --> 00:07:05.860
Now once we have that
notion, we can also

00:07:05.860 --> 00:07:08.710
talk about the probability
that the machine ends up

00:07:08.710 --> 00:07:12.280
accepting because as before,
each of these branches

00:07:12.280 --> 00:07:16.120
is going to end up at an
accept state or reject state,

00:07:16.120 --> 00:07:19.030
thinking about this only
in terms of deciders.

00:07:19.030 --> 00:07:25.130
And the probability of
the machine accepting here

00:07:25.130 --> 00:07:28.370
is just going to be the
sum over all probabilities

00:07:28.370 --> 00:07:32.210
of the branches that
end up accepting.

00:07:32.210 --> 00:07:34.640
So just add up all of those
probabilities of a branch

00:07:34.640 --> 00:07:37.880
leading to an accept, and
we'll call that the probability

00:07:37.880 --> 00:07:39.350
that the machine
accepts its input.

00:07:42.820 --> 00:07:46.180
And the probability
that the machine rejects

00:07:46.180 --> 00:07:47.980
is going to be 1
minus the probability

00:07:47.980 --> 00:07:52.900
that it accepts because the
machine, on every branch,

00:07:52.900 --> 00:07:59.230
is either going to do
one or the other, OK?

00:07:59.230 --> 00:08:02.680
Now if you're thinking
about a particular language

00:08:02.680 --> 00:08:04.990
that the machine is
trying to decide,

00:08:04.990 --> 00:08:12.238
this probabilistic machine
now is trying to decide,

00:08:12.238 --> 00:08:16.210
on each input, some of the
branches of the machine

00:08:16.210 --> 00:08:17.710
may give the correct answer.

00:08:17.710 --> 00:08:20.502
They're going to accept when
the input is in the language.

00:08:20.502 --> 00:08:22.210
Other branches may
give the wrong answer.

00:08:22.210 --> 00:08:24.880
They may reject when the input
is in the language and vise

00:08:24.880 --> 00:08:26.590
versa.

00:08:26.590 --> 00:08:28.840
So there's going to be
a possibility of error

00:08:28.840 --> 00:08:31.020
now in the machine in
any particular branch.

00:08:31.020 --> 00:08:33.309
It might actually
give the wrong answer.

00:08:33.309 --> 00:08:35.230
And what we're going
to say is bound

00:08:35.230 --> 00:08:40.730
that error over all
possible inputs,

00:08:40.730 --> 00:08:44.510
and we'll say that the
machine for any epsilon

00:08:44.510 --> 00:08:47.180
greater than or
equal to 0, we will

00:08:47.180 --> 00:08:50.750
say that the machine decides the
language with error probability

00:08:50.750 --> 00:08:54.940
epsilon if that's the
worst that can possibly

00:08:54.940 --> 00:08:59.230
happen if, for every
input, the machine gives

00:08:59.230 --> 00:09:03.150
the wrong answer with
probability at most epsilon.

00:09:05.910 --> 00:09:09.600
Equivalently, if you like to
spell it out a little bit more,

00:09:09.600 --> 00:09:16.280
a little differently,
for strings

00:09:16.280 --> 00:09:18.500
that are in the
language, the probability

00:09:18.500 --> 00:09:20.720
that the machine
rejects that input

00:09:20.720 --> 00:09:22.130
is going to be at most epsilon.

00:09:22.130 --> 00:09:24.690
And for strings in the
language the probability

00:09:24.690 --> 00:09:27.620
for strings not in the language,
the probability that accepts

00:09:27.620 --> 00:09:29.720
is at most epsilon.

00:09:29.720 --> 00:09:34.280
So again, this is the machine
doing the thing that it's not

00:09:34.280 --> 00:09:35.660
supposed to be doing.

00:09:35.660 --> 00:09:37.610
For things in the
language, it should

00:09:37.610 --> 00:09:39.230
be rejecting very rarely.

00:09:39.230 --> 00:09:40.880
For things not in
the language, it

00:09:40.880 --> 00:09:42.410
should be accepting very rarely.

00:09:42.410 --> 00:09:48.550
And that's what this bound
is doing for you, OK?

00:09:48.550 --> 00:09:51.260
So let's just see.

00:09:51.260 --> 00:09:54.020
So we'll talk about-- so I'm
getting some questions here

00:09:54.020 --> 00:09:54.520
about--

00:09:59.810 --> 00:10:01.120
so let me just look at these.

00:10:01.120 --> 00:10:02.080
One second here.

00:10:11.510 --> 00:10:14.570
Yeah, so probability 0--

00:10:14.570 --> 00:10:16.700
so there's a possibility
that the machine

00:10:16.700 --> 00:10:20.210
might have a probability
0, say, of accepting.

00:10:20.210 --> 00:10:23.000
That means there are no
branches that end up accepting

00:10:23.000 --> 00:10:24.410
or probability 0 of rejecting.

00:10:24.410 --> 00:10:27.050
There were no
rejecting branches.

00:10:27.050 --> 00:10:28.730
I think we're going
to talk in a minute

00:10:28.730 --> 00:10:30.170
about the connection
between this

00:10:30.170 --> 00:10:33.170
and the standard notion of NP.

00:10:33.170 --> 00:10:35.840
So just hold off on
that for a second.

00:10:38.470 --> 00:10:43.090
Also, what about the
possibility that the machine

00:10:43.090 --> 00:10:49.010
is being a decider or running
in a certain amount of time?

00:10:49.010 --> 00:10:53.710
So we will look at time-bounded
machines in a second

00:10:53.710 --> 00:10:56.980
on the next slide or two,
talking about machines

00:10:56.980 --> 00:10:58.550
that run in polynomial time.

00:10:58.550 --> 00:11:00.520
So that means all
branches have to halt

00:11:00.520 --> 00:11:03.860
within some polynomial
number of steps.

00:11:03.860 --> 00:11:05.780
So that's where we're going.

00:11:05.780 --> 00:11:07.750
But for the time
being, we're the only

00:11:07.750 --> 00:11:09.790
looking at deciders,
where the machine has

00:11:09.790 --> 00:11:12.280
to hold on every branch.

00:11:12.280 --> 00:11:14.780
But some branches might
run for a long time.

00:11:14.780 --> 00:11:18.970
But for now, we're not going to
be thinking about machines that

00:11:18.970 --> 00:11:21.850
have branches that run forever.

00:11:21.850 --> 00:11:23.410
All of our machines
are deciders,

00:11:23.410 --> 00:11:26.480
so they hold on every branch.

00:11:26.480 --> 00:11:27.890
See, is there
anything else here?

00:11:27.890 --> 00:11:28.430
No.

00:11:28.430 --> 00:11:30.000
So why don't I move on?

00:11:30.000 --> 00:11:34.100
So let's define now
the class BPP using

00:11:34.100 --> 00:11:36.770
this notion of a
probabilistic Turing

00:11:36.770 --> 00:11:40.140
machine, which is now going to
be running in polynomial time.

00:11:40.140 --> 00:11:42.380
So BPP is going to be another
one of this complexity

00:11:42.380 --> 00:11:44.810
classes, a collection
of languages, like P,

00:11:44.810 --> 00:11:48.140
and NP, and PSPACE, and so on.

00:11:48.140 --> 00:11:49.790
But it's going to
be now associated

00:11:49.790 --> 00:11:52.430
with the capabilities of
these probabilistic machines,

00:11:52.430 --> 00:11:55.880
the kinds of languages
that they can do.

00:11:55.880 --> 00:12:02.460
So we'll say, the class BPP
is the set of languages, A,

00:12:02.460 --> 00:12:06.590
that there's some probabilistic
polynomial time Turing

00:12:06.590 --> 00:12:08.750
machines, so all branches
have to hold within--

00:12:08.750 --> 00:12:11.480
into the k for some k.

00:12:11.480 --> 00:12:15.980
So some polynomial time
probabilistic Turing machine

00:12:15.980 --> 00:12:19.550
decides A with error
possibility, at most, 1/3.

00:12:22.530 --> 00:12:26.400
So in other words,
when it's accepting

00:12:26.400 --> 00:12:28.860
for strings in the
language, the machine

00:12:28.860 --> 00:12:31.170
has to reject
with, at most, 1/3.

00:12:31.170 --> 00:12:32.622
So it's saying it equivalently.

00:12:32.622 --> 00:12:34.080
For strings in the
language, it has

00:12:34.080 --> 00:12:36.960
to accept with 2/3 probability.

00:12:36.960 --> 00:12:38.830
And for strings not
in the language,

00:12:38.830 --> 00:12:40.530
it has to reject
with 2/3 probability,

00:12:40.530 --> 00:12:42.465
at least, in both cases.

00:12:45.990 --> 00:12:48.460
OK.

00:12:48.460 --> 00:12:50.725
Somehow, I ended up with--

00:12:50.725 --> 00:12:52.100
I didn't check my
animation here.

00:12:52.100 --> 00:12:52.933
But OK, that's fine.

00:12:52.933 --> 00:12:53.930
So there is a--

00:12:57.080 --> 00:13:02.870
now if you look at the 1/3
here in the definition,

00:13:02.870 --> 00:13:05.690
it seems strange to
define a complexity

00:13:05.690 --> 00:13:08.780
class in terms of some
arbitrary content like 1/3.

00:13:08.780 --> 00:13:17.000
Why didn't we use 1/4 or
1/10 in the definition of BPP

00:13:17.000 --> 00:13:20.180
and say the machine has to
get have an error with at most

00:13:20.180 --> 00:13:22.760
1/10 or 1/100?

00:13:22.760 --> 00:13:24.260
Well, it doesn't matter.

00:13:24.260 --> 00:13:28.220
And that's the point
of this next statement

00:13:28.220 --> 00:13:31.520
called the amplification
lemma, which

00:13:31.520 --> 00:13:34.860
says that you can always--

00:13:34.860 --> 00:13:37.070
if you have a machine
that's running

00:13:37.070 --> 00:13:40.790
in a certain
polynomial time that's

00:13:40.790 --> 00:13:45.140
running with a certain error,
which is, at most, 1/2.

00:13:45.140 --> 00:13:47.390
If you have an error
1/2, it's not interesting

00:13:47.390 --> 00:13:51.920
because the machine could just
flip a coin for every input,

00:13:51.920 --> 00:13:55.670
and it could get the right
answer with probability of 1/2.

00:13:55.670 --> 00:13:58.010
So probability 1/2
is not interesting.

00:13:58.010 --> 00:14:01.070
You have to have probability
strictly less than 1/2

00:14:01.070 --> 00:14:04.070
for the machine to actually
be doing something that's

00:14:04.070 --> 00:14:06.630
meaningful about that language.

00:14:06.630 --> 00:14:13.480
So if you have a probabilistic
Turing machine that has error,

00:14:13.480 --> 00:14:15.880
let's say, epsilon 1,
which is, at most, 1/2--

00:14:15.880 --> 00:14:20.790
which is less than
1/2, then you can

00:14:20.790 --> 00:14:23.850
convert that to any
error probability

00:14:23.850 --> 00:14:28.020
you want for some
other polynomial time

00:14:28.020 --> 00:14:29.980
probabilistic Turing machine.

00:14:29.980 --> 00:14:33.270
So you can make that error,
which maybe starts out as 1/3,

00:14:33.270 --> 00:14:39.023
and you can drive that error
down to 1 over a googol.

00:14:39.023 --> 00:14:40.440
And seriously, you
can really make

00:14:40.440 --> 00:14:46.540
the error extremely,
extremely small

00:14:46.540 --> 00:14:48.910
using a very simple procedure.

00:14:48.910 --> 00:14:51.450
And that's simply this--

00:14:51.450 --> 00:14:53.340
so if you're starting
out with a machine that

00:14:53.340 --> 00:14:55.530
has an error
possibility of 1/3, say,

00:14:55.530 --> 00:14:58.050
so that means 2/3
of the time it's

00:14:58.050 --> 00:15:00.882
going to get the right answer,
and, at most, 1/3 of the time--

00:15:00.882 --> 00:15:03.090
the least 2/3 of the time,
the right answer, at most,

00:15:03.090 --> 00:15:05.070
1/3 of the time, the
incorrect answer,

00:15:05.070 --> 00:15:07.933
whether that's
accepting or rejecting.

00:15:07.933 --> 00:15:09.600
And now you want to
get that answer down

00:15:09.600 --> 00:15:11.970
to be something much-- that
error down to something

00:15:11.970 --> 00:15:14.040
much smaller.

00:15:14.040 --> 00:15:19.500
The idea is, you're going
to take that machine,

00:15:19.500 --> 00:15:24.570
and you're going to
run it multiple times

00:15:24.570 --> 00:15:27.870
with independent runs, if you
want to think about it more

00:15:27.870 --> 00:15:28.650
formally speaking.

00:15:28.650 --> 00:15:29.850
But it's intuitive.

00:15:29.850 --> 00:15:33.240
You're just going to run the
machine, tossing your coins.

00:15:35.725 --> 00:15:37.350
Instead of just
running it once, you're

00:15:37.350 --> 00:15:40.320
going to run the machine 100
times or a million times.

00:15:40.320 --> 00:15:43.060
But you can do it at just,
say, it's a constant factor.

00:15:43.060 --> 00:15:44.940
And even 1,000
times is going to be

00:15:44.940 --> 00:15:47.610
enough to increase your
confidence in the result

00:15:47.610 --> 00:15:53.690
tremendously because if you
run the machine 1,000 times,

00:15:53.690 --> 00:15:58.280
and 600 of those times, the
machine accepts, and 400

00:15:58.280 --> 00:16:02.630
of the times, the
machine rejects,

00:16:02.630 --> 00:16:05.990
it's very powerful
evidence that this machine

00:16:05.990 --> 00:16:08.000
is biased toward
accepting, that it's

00:16:08.000 --> 00:16:10.290
accepting most of the time.

00:16:10.290 --> 00:16:16.710
So if it had an error
probability, at most,

00:16:16.710 --> 00:16:23.850
1/3, the probability
that you're seeing

00:16:23.850 --> 00:16:28.350
it accept 600 times when,
really, 2/3 of the time,

00:16:28.350 --> 00:16:32.640
it's rejecting overall,
is extremely unlikely.

00:16:32.640 --> 00:16:34.507
And you can calculate that--

00:16:34.507 --> 00:16:36.090
which we're not going
to bother to do,

00:16:36.090 --> 00:16:38.670
but it's a routine
probability calculation--

00:16:38.670 --> 00:16:41.370
to show that the
probability that if you

00:16:41.370 --> 00:16:44.970
run it a whole bunch of times,
and you see the majority coming

00:16:44.970 --> 00:16:53.310
up, which is not the right
answer, the probability of that

00:16:53.310 --> 00:16:56.550
is extremely small.

00:16:56.550 --> 00:16:58.050
So I'm not saying
that very clearly.

00:16:58.050 --> 00:17:04.020
But the method here
is you're going

00:17:04.020 --> 00:17:10.829
to take your original machine,
which has error probability 1/3

00:17:10.829 --> 00:17:12.900
or whatever it is--

00:17:12.900 --> 00:17:17.310
maybe has error probability 49%.

00:17:17.310 --> 00:17:20.880
And you run it for a
large number of times.

00:17:20.880 --> 00:17:23.510
And then you take
the majority vote.

00:17:23.510 --> 00:17:28.460
And you're sampling the
outcomes of this machine.

00:17:28.460 --> 00:17:32.390
And if you take enough samples,
it's overwhelmingly likely--

00:17:32.390 --> 00:17:34.760
since you're just
doing them uniformly--

00:17:34.760 --> 00:17:36.867
you're taking those
samples uniformly,

00:17:36.867 --> 00:17:38.450
it's overwhelmingly
likely that you're

00:17:38.450 --> 00:17:41.960
going to be seeing the
predominant one come up

00:17:41.960 --> 00:17:43.850
more often.

00:17:43.850 --> 00:17:46.220
And exactly what
that right value is,

00:17:46.220 --> 00:17:48.020
we're not going to
bother to calculate.

00:17:48.020 --> 00:17:52.430
But that's something that, I
will refer you to the textbook,

00:17:52.430 --> 00:17:54.110
or this is the
kind of thing that

00:17:54.110 --> 00:17:56.225
comes up in any elementary
probability book

00:17:56.225 --> 00:17:57.350
and sort of very intuitive.

00:17:57.350 --> 00:17:58.725
So I don't want
to spend the time

00:17:58.725 --> 00:18:01.541
and do that calculation, which
is not all that interesting.

00:18:05.310 --> 00:18:09.270
OK, so just one quick question
here that I'm getting--

00:18:09.270 --> 00:18:11.640
what happens if you
bound-- if the error is

00:18:11.640 --> 00:18:12.840
greater than a half?

00:18:12.840 --> 00:18:15.970
I don't think that because
we're bounding the error,

00:18:15.970 --> 00:18:19.110
so we're not saying the
error actually is one, like,

00:18:19.110 --> 00:18:22.320
60% on everything because
then if you knew the error was

00:18:22.320 --> 00:18:27.300
60% guaranteed, you can always
just flip your answer around

00:18:27.300 --> 00:18:30.150
and get your error to be 40%.

00:18:30.150 --> 00:18:35.390
But I'm saying the error's
at most whatever epsilon is.

00:18:35.390 --> 00:18:38.717
And so if you're saying
the error is, at most, 60%,

00:18:38.717 --> 00:18:39.925
it doesn't tell you anything.

00:18:43.135 --> 00:18:43.635
OK.

00:18:51.970 --> 00:18:54.820
Another question is, does
the amplification lemma also

00:18:54.820 --> 00:18:58.810
justify that the choice of model
with binary branching choices

00:18:58.810 --> 00:19:00.820
is equivalent to any other?

00:19:00.820 --> 00:19:05.320
Perhaps, you could say that
because you can change those.

00:19:05.320 --> 00:19:08.950
If you had three-way
branching, you

00:19:08.950 --> 00:19:12.370
can simulate that with two-way
branching to any accuracy

00:19:12.370 --> 00:19:14.036
that you want.

00:19:14.036 --> 00:19:16.420
You're not going to
get it down to zero,

00:19:16.420 --> 00:19:18.700
but you're going to
get it very close.

00:19:18.700 --> 00:19:21.400
So maybe it's the
amplification lemma.

00:19:21.400 --> 00:19:26.090
Maybe it's, yeah,
sort of all related.

00:19:26.090 --> 00:19:28.830
OK, let's move on.

00:19:28.830 --> 00:19:35.990
So the way that it's helpful
to think about this class,

00:19:35.990 --> 00:19:39.873
let's contrast it
with the other model

00:19:39.873 --> 00:19:41.540
of non-deterministic
computation that we

00:19:41.540 --> 00:19:44.720
have is non-determinism, is NP.

00:19:44.720 --> 00:19:46.910
So non-deterministic,
the model of

00:19:46.910 --> 00:19:49.040
non-deterministic
polynomial time computation

00:19:49.040 --> 00:19:52.250
was NP, the other class.

00:19:52.250 --> 00:19:57.390
And so the way--

00:19:57.390 --> 00:19:59.220
I think one way to
look at or think

00:19:59.220 --> 00:20:01.860
about non-determinism
in the case of NP

00:20:01.860 --> 00:20:08.310
is, for strings in the language
for your NP Turing machine,

00:20:08.310 --> 00:20:10.540
there's at least one
accepting branch.

00:20:10.540 --> 00:20:13.020
So I'm indicating the
accepting ones in green

00:20:13.020 --> 00:20:17.050
and the non-accepting one,
the rejecting branches in red.

00:20:17.050 --> 00:20:22.050
So you could have almost all
of the branches be rejecting

00:20:22.050 --> 00:20:25.470
branches for strings
in the language

00:20:25.470 --> 00:20:27.600
as long as there is at
least one accepting branch.

00:20:27.600 --> 00:20:29.700
That's just the way
non-determinism works.

00:20:29.700 --> 00:20:33.000
The accepting branch
overrules all of the others.

00:20:33.000 --> 00:20:34.800
It's only when you're
not in the language

00:20:34.800 --> 00:20:38.280
that all of the branches turn
out to have to be rejecting.

00:20:38.280 --> 00:20:42.450
That's when the rejecting
has no accepting branch

00:20:42.450 --> 00:20:44.370
to overrule it.

00:20:44.370 --> 00:20:46.750
But the situation for BPP
is a little different--

00:20:46.750 --> 00:20:48.780
is different.

00:20:48.780 --> 00:20:53.280
There, it's kind of
the majority rules.

00:20:53.280 --> 00:20:58.370
So in the case for
strings in the language,

00:20:58.370 --> 00:21:00.620
you need to have a large--

00:21:00.620 --> 00:21:05.900
or the overwhelming
majority of the branches

00:21:05.900 --> 00:21:07.040
have to be accepting.

00:21:07.040 --> 00:21:08.660
And for strings not
in the language,

00:21:08.660 --> 00:21:11.970
the overwhelming majority
have to be rejected.

00:21:11.970 --> 00:21:15.600
What you're not going to
allow in the case of BPP

00:21:15.600 --> 00:21:23.490
is kind of an in-between
state where it's sort of 50-50

00:21:23.490 --> 00:21:25.830
or very, very close to 50-50.

00:21:25.830 --> 00:21:29.670
Those kinds of
machines don't qualify

00:21:29.670 --> 00:21:35.390
as designing a language in BPP.

00:21:35.390 --> 00:21:38.120
They always have to
lean one way or lean

00:21:38.120 --> 00:21:41.352
the other way for every input.

00:21:41.352 --> 00:21:43.560
Otherwise, you won't be able
to do the amplification.

00:21:43.560 --> 00:21:47.090
So you need to have
some bias away from half

00:21:47.090 --> 00:21:51.890
in accepting or rejecting.

00:21:51.890 --> 00:21:55.897
So let me-- so I was going
to ask a check-in, I think,

00:21:55.897 --> 00:21:56.480
at this point.

00:21:56.480 --> 00:21:57.770
Yes, let's.

00:21:57.770 --> 00:22:00.910
So just thinking about
BPP, I hope I was clear.

00:22:00.910 --> 00:22:02.750
So if there's
questions about that,

00:22:02.750 --> 00:22:04.430
I think I've somehow didn't--

00:22:07.320 --> 00:22:10.240
I'm not sure I described
it totally well here.

00:22:10.240 --> 00:22:12.390
So I'm going to ask a
few questions about BPP.

00:22:12.390 --> 00:22:15.600
But if you have any questions
for me first, go ahead.

00:22:20.355 --> 00:22:21.980
OK, why don't we just
run the check-in?

00:22:31.685 --> 00:22:33.810
Let me launch this, and
then I can answer questions

00:22:33.810 --> 00:22:36.171
as you're asking.

00:22:36.171 --> 00:22:37.560
Did I start that?

00:22:37.560 --> 00:22:39.240
Yeah.

00:22:39.240 --> 00:22:44.520
OK, so you have to check all of
these that you think are true.

00:22:48.072 --> 00:22:49.780
Can you think of
non-deterministic Turing

00:22:49.780 --> 00:22:54.310
machines as try all branches at
once and get the right answer?

00:22:59.370 --> 00:23:03.582
And BP gets only one branch?

00:23:03.582 --> 00:23:04.082
No.

00:23:06.680 --> 00:23:08.250
I would say a
little differently.

00:23:08.250 --> 00:23:10.790
I would say, I would
think of non-determinism

00:23:10.790 --> 00:23:12.710
as you can still
just try one branch,

00:23:12.710 --> 00:23:16.320
but you always
guess the right one.

00:23:16.320 --> 00:23:20.122
So there's some sort
of magical power

00:23:20.122 --> 00:23:22.580
that allows you always to guess
the right answer if there's

00:23:22.580 --> 00:23:25.350
a right guess If
you're in the language.

00:23:25.350 --> 00:23:29.450
In the case of BPP,
you're going to be picking

00:23:29.450 --> 00:23:32.010
a random branch no matter what.

00:23:32.010 --> 00:23:33.870
And you know that
the random branch

00:23:33.870 --> 00:23:37.860
is likely to give the right
answer but not guaranteed.

00:23:37.860 --> 00:23:40.800
And the amplification
lemma tells you

00:23:40.800 --> 00:23:42.660
you can arrange
things so that it's

00:23:42.660 --> 00:23:46.650
extremely likely that the
random branch is going

00:23:46.650 --> 00:23:49.220
to give you the right answer.

00:23:49.220 --> 00:23:49.880
OK, let's see.

00:23:49.880 --> 00:23:52.100
How we doing on
our check-in here?

00:23:54.890 --> 00:23:57.860
Got a lot of support
for all candidates.

00:24:01.140 --> 00:24:06.065
And I'll give you another--

00:24:08.970 --> 00:24:10.800
a little bit of time
here because there's

00:24:10.800 --> 00:24:11.675
a bunch of questions.

00:24:11.675 --> 00:24:14.850
It's almost like four
check-ins at once.

00:24:14.850 --> 00:24:17.805
But we have two more real
check-ins coming later.

00:24:20.490 --> 00:24:25.162
OK, so why don't we
come and let's give it

00:24:25.162 --> 00:24:27.120
another 10 seconds, and
then I'm going to stop.

00:24:31.190 --> 00:24:35.390
Closing down-- 1, 2, 3, close.

00:24:38.510 --> 00:24:42.140
OK, so we've got a
lot of support here.

00:24:42.140 --> 00:24:47.270
And in fact that's good
because all of them are true.

00:24:47.270 --> 00:24:50.160
Some of them are easier
to see than others.

00:24:50.160 --> 00:24:54.320
So first of all, c is very
easy to see because that's

00:24:54.320 --> 00:24:57.860
going to be a machine that
has the correct answer all

00:24:57.860 --> 00:24:58.920
of the time.

00:24:58.920 --> 00:25:02.600
So that's error
probability zero on both

00:25:02.600 --> 00:25:03.830
accepting and rejecting.

00:25:06.680 --> 00:25:07.700
This is a little harder.

00:25:07.700 --> 00:25:10.790
D is a little bit harder
to see that it's in PSPACE.

00:25:10.790 --> 00:25:15.320
But you could calculate
for every branch

00:25:15.320 --> 00:25:16.787
what its probability is.

00:25:16.787 --> 00:25:18.620
And you can just go
through all the branches

00:25:18.620 --> 00:25:21.080
and add up all those
probabilities in a PSPACE

00:25:21.080 --> 00:25:21.890
machine.

00:25:21.890 --> 00:25:24.680
So you have to think
about it a little bit.

00:25:24.680 --> 00:25:28.250
But d is not too
hard to see either.

00:25:28.250 --> 00:25:33.380
Closure under complement-- if
you just take your BPP machine

00:25:33.380 --> 00:25:38.570
and you flip the answer on
every branch, that's typically

00:25:38.570 --> 00:25:41.150
doesn't work in ordinary
non-determinism,

00:25:41.150 --> 00:25:43.100
but it does work
here because it's

00:25:43.100 --> 00:25:45.170
going to change a
bias toward accepting

00:25:45.170 --> 00:25:48.000
into a bias toward
rejecting and vice versa.

00:25:48.000 --> 00:25:50.840
So BPP is closed
under complement.

00:25:50.840 --> 00:25:52.410
And closure under a union--

00:25:52.410 --> 00:25:54.410
it kind of follows from
the amplification lemma.

00:25:54.410 --> 00:25:58.110
As long as you can make the
probability extremely small,

00:25:58.110 --> 00:26:00.830
then you can just run the
two different machines.

00:26:00.830 --> 00:26:03.140
And even though
the they each may

00:26:03.140 --> 00:26:06.170
make a mistake
cumulatively, the total,

00:26:06.170 --> 00:26:09.320
the probability that each one
of them-- that either of them

00:26:09.320 --> 00:26:10.880
will make a mistake
is still small.

00:26:10.880 --> 00:26:12.770
And so you can just
run the two machines

00:26:12.770 --> 00:26:14.907
and take the or of the
responses that they get,

00:26:14.907 --> 00:26:16.490
and it's still very
likely to give you

00:26:16.490 --> 00:26:18.920
the right answer for the union.

00:26:18.920 --> 00:26:24.480
OK, let's continue.

00:26:24.480 --> 00:26:28.958
So what I'm going to do now for
the rest of the lecture is--

00:26:28.958 --> 00:26:30.500
and it's actually
going to spill over

00:26:30.500 --> 00:26:32.743
into the lecture
after Thanksgiving

00:26:32.743 --> 00:26:34.160
because this is
going to introduce

00:26:34.160 --> 00:26:36.560
an important method for us--

00:26:36.560 --> 00:26:41.960
is to look at an example
of a problem that's in BPP.

00:26:41.960 --> 00:26:45.080
I love to teach things
by using examples,

00:26:45.080 --> 00:26:46.850
and so this is a
very good example

00:26:46.850 --> 00:26:49.990
because it has a
lot of meat to it.

00:26:49.990 --> 00:26:52.450
And it's a very
interesting example.

00:26:52.450 --> 00:26:56.680
In general, proving things in
BPP, which are not trivially

00:26:56.680 --> 00:26:58.390
there because
they're already in P,

00:26:58.390 --> 00:27:00.850
they tend to be
somewhat more involved

00:27:00.850 --> 00:27:04.540
than some of the other
algorithms we've seen.

00:27:04.540 --> 00:27:09.370
So there are no simple
examples of problems in BPP

00:27:09.370 --> 00:27:12.550
which are not already in P.

00:27:12.550 --> 00:27:16.840
So this is one
example that we're

00:27:16.840 --> 00:27:19.330
going to go through of
a problem in BPP that's

00:27:19.330 --> 00:27:23.330
not known to be in P. Of course,
things could collapse down,

00:27:23.330 --> 00:27:30.033
but as far as we know,
this language is not in P.

00:27:30.033 --> 00:27:31.450
So let's see what
the language is.

00:27:31.450 --> 00:27:34.360
It has to do with these things
called branching programs.

00:27:34.360 --> 00:27:37.970
The branching program is a
structure that looks like this.

00:27:37.970 --> 00:27:40.390
So let's understand
what the pieces are.

00:27:40.390 --> 00:27:42.595
First of all, it's
a directed graph.

00:27:46.300 --> 00:27:49.360
And we're not going to allow--

00:27:49.360 --> 00:27:51.880
there are no cycles
allowed in this graph.

00:27:51.880 --> 00:27:56.650
It's a directed acyclic graph--

00:27:56.650 --> 00:27:58.590
so no loops allowed.

00:27:58.590 --> 00:28:02.790
And the nodes are
in two categories.

00:28:02.790 --> 00:28:08.280
There are query nodes, which are
labeled with a variable letter,

00:28:08.280 --> 00:28:13.920
and output nodes, which
are labeled either 0 or 1.

00:28:13.920 --> 00:28:17.160
And lastly, one of the
query nodes is going to be--

00:28:17.160 --> 00:28:23.440
or one of the nodes is going to
be designated as a start, OK?

00:28:23.440 --> 00:28:29.390
And so what you do is, the way--

00:28:29.390 --> 00:28:31.820
this is a model of computation.

00:28:31.820 --> 00:28:39.470
And the way we actually use
a branching program is we

00:28:39.470 --> 00:28:41.930
have some assignment
to the variables.

00:28:41.930 --> 00:28:43.560
That's going to be the input.

00:28:43.560 --> 00:28:45.450
So you take all
of the variables.

00:28:45.450 --> 00:28:47.420
There are three
variables in this case--

00:28:47.420 --> 00:28:49.520
x1, x2, and x3.

00:28:49.520 --> 00:28:51.800
You give them some
truth assignment.

00:28:51.800 --> 00:28:54.110
So let's say, zero's a 1.

00:28:54.110 --> 00:28:56.120
And so x1 is 0.

00:28:56.120 --> 00:28:57.480
x1 is 1, or whatever.

00:28:57.480 --> 00:29:00.710
And once you have
the truth assignment,

00:29:00.710 --> 00:29:08.270
you start at the start variable,
and you look at its label.

00:29:10.810 --> 00:29:15.800
And you see what value the input
has assigned to that variable.

00:29:15.800 --> 00:29:18.823
So if x1 is assigned
a 1, you're going

00:29:18.823 --> 00:29:19.990
to follow down the 1 branch.

00:29:19.990 --> 00:29:22.930
If it assigned a 0, you
go down the 0 branch.

00:29:22.930 --> 00:29:27.680
And then when you get
down to the next node,

00:29:27.680 --> 00:29:29.540
that's another
variable that you're

00:29:29.540 --> 00:29:32.660
going to have to query
depending upon what the input

00:29:32.660 --> 00:29:33.890
assignment is.

00:29:33.890 --> 00:29:37.790
And you're just going to
continue that process.

00:29:37.790 --> 00:29:39.770
Because there are
no cycles, you're

00:29:39.770 --> 00:29:42.170
going to end up at one
of the output nodes

00:29:42.170 --> 00:29:44.030
because all of the
variable nodes--

00:29:44.030 --> 00:29:48.050
all the query nodes
have two outgoing edges,

00:29:48.050 --> 00:29:50.900
one labeled 0 and one labeled 1.

00:29:50.900 --> 00:29:53.210
So you're going to eventually
end up at an output node,

00:29:53.210 --> 00:29:54.585
and that's going
to be the output

00:29:54.585 --> 00:29:56.390
of the branching program.

00:29:56.390 --> 00:30:00.180
So let's do a quick example.

00:30:00.180 --> 00:30:04.580
So if x1 is 1, x2
is 0, and x3 is 1--

00:30:04.580 --> 00:30:07.550
so again, we start at
the start variable--

00:30:07.550 --> 00:30:11.240
the start node that has the
indicated with the arrow

00:30:11.240 --> 00:30:12.350
coming in from nowhere.

00:30:12.350 --> 00:30:19.470
So you're going to start
at the nose labeled x1.

00:30:19.470 --> 00:30:21.840
So you have to look and see,
what is x1 in the input?

00:30:21.840 --> 00:30:22.530
It's a 1.

00:30:22.530 --> 00:30:24.690
So you're going to
follow down the 1 branch.

00:30:24.690 --> 00:30:26.040
Now you see the next node.

00:30:26.040 --> 00:30:27.705
Oh, that's an x3.

00:30:27.705 --> 00:30:31.320
We see, what's x3 in
the input? x3 is a 1.

00:30:31.320 --> 00:30:33.480
So go down to 1 branch again.

00:30:33.480 --> 00:30:35.700
Now we have an x2 node.

00:30:35.700 --> 00:30:37.720
Take a look at the
input. x2 is a 0.

00:30:37.720 --> 00:30:39.330
We follow the 0 branch.

00:30:39.330 --> 00:30:41.860
Now, you're at an output
branch, an output node.

00:30:41.860 --> 00:30:46.420
So that's a 0, and that's the
output of this computation.

00:30:46.420 --> 00:30:49.710
So writing it this way
and thinking about it

00:30:49.710 --> 00:30:53.700
as a Boolean function which
maps strings of zeros and ones,

00:30:53.700 --> 00:30:58.440
we have f of 101 representing
those that assignment.

00:30:58.440 --> 00:30:59.460
That equals 0.

00:30:59.460 --> 00:31:00.570
That was the output.

00:31:00.570 --> 00:31:06.795
And that's the output
of this computation, OK?

00:31:06.795 --> 00:31:07.920
So important to understand.

00:31:07.920 --> 00:31:10.410
We're going to
spend a lot of time

00:31:10.410 --> 00:31:13.050
talking about branching
programs-- so critical

00:31:13.050 --> 00:31:14.475
to understand this model.

00:31:14.475 --> 00:31:15.600
I think it's fairly simple.

00:31:15.600 --> 00:31:17.325
But if you didn't
get it, please ask.

00:31:20.400 --> 00:31:22.950
We can easily correct up any
misunderstanding at this point.

00:31:28.920 --> 00:31:31.830
It's not exactly
the same as a DFA.

00:31:31.830 --> 00:31:36.220
DFAs, for one thing, can
take inputs of any length.

00:31:36.220 --> 00:31:40.470
This has inputs of
some particular length,

00:31:40.470 --> 00:31:45.198
where the branching program has
some fixed number of variables.

00:31:45.198 --> 00:31:45.990
This one has three.

00:31:45.990 --> 00:31:49.500
So this only takes
inputs of length 3.

00:31:49.500 --> 00:31:52.870
So there's maybe some connection
to thinking of these as states

00:31:52.870 --> 00:31:56.040
and so on, but it's
a different model.

00:31:56.040 --> 00:31:59.580
So now, we'll say that
two branching programs--

00:32:02.027 --> 00:32:03.610
OK, let me just ask
one more question.

00:32:03.610 --> 00:32:05.920
Not all nodes need
to be used, right?

00:32:09.710 --> 00:32:11.600
Yeah, I mean, there's
no requirement

00:32:11.600 --> 00:32:13.250
that all nodes need to be used.

00:32:13.250 --> 00:32:15.140
And there even could
be inaccessible nodes.

00:32:15.140 --> 00:32:17.450
I'm not preventing that.

00:32:17.450 --> 00:32:19.163
That could be OK.

00:32:19.163 --> 00:32:21.080
So on the particular
branch, certainly, you're

00:32:21.080 --> 00:32:23.030
not going to-- when
you're executing

00:32:23.030 --> 00:32:25.783
this branching
program on an input,

00:32:25.783 --> 00:32:27.200
obviously, certainly,
you're going

00:32:27.200 --> 00:32:29.840
to have a path that's
going to only use

00:32:29.840 --> 00:32:35.390
some part of the tree,
a part of the graph.

00:32:35.390 --> 00:32:41.410
But there might be some
paths that can never occur.

00:32:41.410 --> 00:32:46.390
So if you went down x equal to
1 here, and then x3 was 0, now,

00:32:46.390 --> 00:32:52.830
you're re-reading x1, so you
wouldn't go down this branch

00:32:52.830 --> 00:32:53.587
unless you--

00:32:53.587 --> 00:32:55.920
I think all of the branches
in this particular branching

00:32:55.920 --> 00:32:57.490
program could get used.

00:32:57.490 --> 00:33:00.720
But I didn't check that,
so maybe I'm wrong.

00:33:00.720 --> 00:33:02.340
OK, so let's continue.

00:33:02.340 --> 00:33:05.370
Two branching programs
may or may not

00:33:05.370 --> 00:33:07.813
compute the same function.

00:33:07.813 --> 00:33:09.480
We'll say they're
equivalent if they do.

00:33:13.550 --> 00:33:18.515
Now two branching
programs can be equivalent

00:33:18.515 --> 00:33:20.390
even though they
superficially look different

00:33:20.390 --> 00:33:22.480
from one another.

00:33:22.480 --> 00:33:25.570
And we're interested in the
computational problem of,

00:33:25.570 --> 00:33:27.730
given two of these
branching programs,

00:33:27.730 --> 00:33:29.800
do they compute
the same function?

00:33:29.800 --> 00:33:32.980
In other words, do they
always give the same answer

00:33:32.980 --> 00:33:36.140
on the setting of the input?

00:33:36.140 --> 00:33:38.860
So we'll define the
associated language.

00:33:38.860 --> 00:33:40.900
Equivalence problem
for branching programs

00:33:40.900 --> 00:33:44.020
says that you're given two
of these branching programs,

00:33:44.020 --> 00:33:46.330
and they're equivalent
to be in the language.

00:33:46.330 --> 00:33:48.550
We're going to sometimes
write equivalents

00:33:48.550 --> 00:33:53.380
using the mathematical notation
of the three-lined equals sign,

00:33:53.380 --> 00:33:56.043
equivalence sign.

00:33:56.043 --> 00:33:57.960
OK, that means a computer
saying-- they always

00:33:57.960 --> 00:34:00.220
give the same answer.

00:34:00.220 --> 00:34:05.960
Now that problem turns
out to be coNP-complete,

00:34:05.960 --> 00:34:10.440
as I've asked you to show
on your homework, I believe.

00:34:10.440 --> 00:34:13.530
This is not a super
hard reduction.

00:34:13.530 --> 00:34:15.870
And coNP complete, by the
way, is the complement

00:34:15.870 --> 00:34:17.370
of an NP-complete problem.

00:34:17.370 --> 00:34:21.389
Or equivalently, it's a problem
to which all coNP problems are

00:34:21.389 --> 00:34:23.570
polynomial time-reducible,
and it's in coNP.

00:34:26.780 --> 00:34:38.810
So this is coNP-complete,
and that's for you to show.

00:34:38.810 --> 00:34:41.540
But that has an important
significance for us

00:34:41.540 --> 00:34:45.830
right now because if--

00:34:45.830 --> 00:34:50.630
looking at the question of
whether this problem is in BPP,

00:34:50.630 --> 00:34:54.469
the fact that it's
coNP-complete suggests

00:34:54.469 --> 00:35:02.210
that the answer is no because if
a coNP-complete or NP-complete

00:35:02.210 --> 00:35:06.050
problem more in BPP because
everything else in NP or coNP

00:35:06.050 --> 00:35:10.280
is reducible to that problem,
then all of those NP or coNP

00:35:10.280 --> 00:35:13.580
problems would be in BPP
for exactly the same reason

00:35:13.580 --> 00:35:15.720
that we've seen before.

00:35:15.720 --> 00:35:17.360
And that's not
known to be the case

00:35:17.360 --> 00:35:20.040
and not believed to be the case.

00:35:20.040 --> 00:35:25.960
So we don't expect that
coNP-complete problem

00:35:25.960 --> 00:35:27.670
is going to be in BPP.

00:35:27.670 --> 00:35:32.930
That would be an amazing
and surprising result.

00:35:32.930 --> 00:35:40.680
So because I hope I made it
clear in my previous discussion

00:35:40.680 --> 00:35:44.400
that the BPP, from a
practical standpoint,

00:35:44.400 --> 00:35:48.660
is very close to being like P
because you can make the error

00:35:48.660 --> 00:35:53.970
probability of the machine
so incredibly low that it's

00:35:53.970 --> 00:35:55.020
a comparable--

00:35:57.560 --> 00:36:00.470
if you run the machine
and the error probability

00:36:00.470 --> 00:36:04.910
is like 1 over googol, then
it's sort of even greater

00:36:04.910 --> 00:36:07.250
than the probability
that some alpha particle

00:36:07.250 --> 00:36:12.590
came in and flipped the
value of some internal memory

00:36:12.590 --> 00:36:14.947
cell in your computation.

00:36:14.947 --> 00:36:17.030
So if you have an extremely
low error probability,

00:36:17.030 --> 00:36:21.590
it's pretty good from
a practical standpoint.

00:36:21.590 --> 00:36:26.650
So it would be amazing if NP
problems were solvable in BPP.

00:36:26.650 --> 00:36:28.780
So this is not
the language we're

00:36:28.780 --> 00:36:30.020
going to use as our example.

00:36:30.020 --> 00:36:32.590
We're going to look at a
related, restricted version

00:36:32.590 --> 00:36:34.450
of this problem
about equivalence

00:36:34.450 --> 00:36:35.800
for branching programs.

00:36:35.800 --> 00:36:38.210
And that, I'm going to
introduce right now.

00:36:38.210 --> 00:36:40.476
OK, any questions here?

00:36:40.476 --> 00:36:42.080
I don't see any questions.

00:36:44.702 --> 00:36:47.750
I'm fading out.

00:36:47.750 --> 00:36:51.870
OK, so let's move on.

00:36:54.610 --> 00:36:57.180
So we're going to talk
about branching programs

00:36:57.180 --> 00:36:59.940
that are what are
called read-once,

00:36:59.940 --> 00:37:02.260
read-once branching programs.

00:37:02.260 --> 00:37:05.130
And those are simply
branching programs

00:37:05.130 --> 00:37:10.350
that are not allowed to
reread an input that they've

00:37:10.350 --> 00:37:13.180
previously read.

00:37:13.180 --> 00:37:16.950
So for example, is
this branching program

00:37:16.950 --> 00:37:19.490
a read-once branching program?

00:37:19.490 --> 00:37:20.530
No.

00:37:20.530 --> 00:37:23.030
This branching program is not
a read-once branching program

00:37:23.030 --> 00:37:29.760
because you can
find a path that's

00:37:29.760 --> 00:37:33.340
going to cause you to read the
same variable more than once.

00:37:33.340 --> 00:37:35.910
So it's not going
to be a read-once.

00:37:35.910 --> 00:37:40.200
So over here, it's not read-once
because there's two occurrences

00:37:40.200 --> 00:37:43.320
of an x1 on the same branch.

00:37:43.320 --> 00:37:44.820
Now you might ask,
why would anybody

00:37:44.820 --> 00:37:47.320
want to do that because you've
already read the value of x1?

00:37:47.320 --> 00:37:51.563
Well, in the case of this
particular branching program,

00:37:51.563 --> 00:37:52.980
there might be a
value because you

00:37:52.980 --> 00:37:57.420
could have got to this x1 branch
by going this way or that way.

00:38:00.120 --> 00:38:02.420
But that's a separate question.

00:38:02.420 --> 00:38:06.680
If we restrict our attention to
read-once branching programs,

00:38:06.680 --> 00:38:08.780
then the problem of
testing equivalence

00:38:08.780 --> 00:38:13.620
becomes very different
in character.

00:38:13.620 --> 00:38:19.440
And in fact, we're going to
give a probabilistic algorithm--

00:38:19.440 --> 00:38:22.300
a BPP algorithm to
solve that problem.

00:38:22.300 --> 00:38:26.220
So the equivalence problem for
read-once branching programs,

00:38:26.220 --> 00:38:28.050
which are not allowed
to reread variables

00:38:28.050 --> 00:38:31.720
on any path, that's
interestingly

00:38:31.720 --> 00:38:36.070
going to be solvable with a
probabilistic polynomial time

00:38:36.070 --> 00:38:41.132
algorithm with a small
error probability.

00:38:41.132 --> 00:38:42.590
So I'm going to
run a check-in now.

00:38:42.590 --> 00:38:44.548
But let's make sure we're
all together on this.

00:38:44.548 --> 00:38:46.190
So I've got a good
question here.

00:38:46.190 --> 00:38:49.310
Can every Boolean
function be described

00:38:49.310 --> 00:38:50.360
by a branching program?

00:38:50.360 --> 00:38:51.290
Yes.

00:38:51.290 --> 00:38:52.700
That's an easy exercise.

00:38:52.700 --> 00:38:54.800
But you can make--

00:38:54.800 --> 00:38:59.210
branching programs are--
they may be a large,

00:38:59.210 --> 00:39:01.940
but you can describe
any Boolean function

00:39:01.940 --> 00:39:04.130
with some branching program.

00:39:04.130 --> 00:39:07.270
That's not hard to show.

00:39:07.270 --> 00:39:08.770
Other question--
are we all together

00:39:08.770 --> 00:39:10.878
on understanding
what read-once means,

00:39:10.878 --> 00:39:12.670
and branching programs,
and all that stuff?

00:39:12.670 --> 00:39:14.378
This is a good time
to ask if you're not.

00:39:17.230 --> 00:39:18.470
OK, so let's do the check-in.

00:39:21.260 --> 00:39:25.322
So as I pointed
out, we will show

00:39:25.322 --> 00:39:27.530
that the equivalence for
read-once branching programs

00:39:27.530 --> 00:39:29.750
is solvable in BPP.

00:39:29.750 --> 00:39:33.470
Can we use that to solve the
general case for branching

00:39:33.470 --> 00:39:36.920
programs by converting
general branching programs

00:39:36.920 --> 00:39:39.080
to read-once branching
programs and then

00:39:39.080 --> 00:39:41.720
running the read-once test?

00:39:41.720 --> 00:39:46.300
So what do you think?

00:39:46.300 --> 00:39:51.100
OK, I'm seeing a lot of
correct answers here.

00:39:51.100 --> 00:39:53.095
So let's wrap this
one up quickly.

00:39:58.120 --> 00:39:59.530
So another 10 seconds, please.

00:40:06.860 --> 00:40:08.060
OK?

00:40:08.060 --> 00:40:09.800
Are we all ready?

00:40:09.800 --> 00:40:11.105
1, 2, 3, closing.

00:40:17.410 --> 00:40:19.330
All right, yes.

00:40:19.330 --> 00:40:24.610
Most of you have
answered correctly.

00:40:24.610 --> 00:40:27.580
Well, answer A is not a very
good answer because we already

00:40:27.580 --> 00:40:30.310
commented on the previous
slide that we don't know

00:40:30.310 --> 00:40:33.550
how to do the
general case in BPP,

00:40:33.550 --> 00:40:36.040
so it would be kind of
surprising if, right here, I'm

00:40:36.040 --> 00:40:42.010
saying, yes, we could do it
by using the restricted case.

00:40:42.010 --> 00:40:48.920
So I think a better
answer would be

00:40:48.920 --> 00:40:52.520
to one of the no's,
but as I did comment,

00:40:52.520 --> 00:40:53.810
you can always convert--

00:40:53.810 --> 00:40:59.588
you can always do any
Boolean function with a--

00:40:59.588 --> 00:41:02.130
well, maybe I didn't say it for
read-once branching programs.

00:41:02.130 --> 00:41:03.890
But even read-once
branching programs

00:41:03.890 --> 00:41:06.720
can compute any
Boolean function.

00:41:06.720 --> 00:41:09.840
So the conversion is
possible but, in general,

00:41:09.840 --> 00:41:11.270
will not be polynomial time.

00:41:11.270 --> 00:41:14.570
And if you imagine even trying
to do the conversion over here,

00:41:14.570 --> 00:41:18.080
you could convert this
branching program to read-once,

00:41:18.080 --> 00:41:20.945
but you'd have to
basically separate the two.

00:41:23.450 --> 00:41:25.340
You know, instead
of rereading the x1,

00:41:25.340 --> 00:41:27.960
you could remember
that x1 value.

00:41:27.960 --> 00:41:30.900
But then you would not be-- you
couldn't converge over here.

00:41:30.900 --> 00:41:34.460
You'd have to keep those two
threads of the-- those two

00:41:34.460 --> 00:41:36.830
branches of the
computation apart--

00:41:36.830 --> 00:41:38.660
those two paths apart
from one another.

00:41:38.660 --> 00:41:40.400
And already, the
branching program

00:41:40.400 --> 00:41:43.770
would start to increase
in size by doing that.

00:41:43.770 --> 00:41:49.550
And so, in general,
converting is possible,

00:41:49.550 --> 00:41:53.660
but it requires a big
increase in the size.

00:41:53.660 --> 00:41:56.960
And then it will not allow
a polynomial time algorithm

00:41:56.960 --> 00:42:02.690
anymore, even in the
probabilistic case.

00:42:02.690 --> 00:42:07.400
OK, so now, let's start
to look at the possibility

00:42:07.400 --> 00:42:12.410
of showing that this equivalence
problem is solvable in BPP.

00:42:12.410 --> 00:42:15.860
And it's going to take us in
a kind of a strange direction,

00:42:15.860 --> 00:42:18.590
but let's try to get our
intuition going first

00:42:18.590 --> 00:42:24.030
by doing something which seems
like the most obvious approach.

00:42:24.030 --> 00:42:32.290
So here, so we're going to
give an algorithm now, which

00:42:32.290 --> 00:42:34.270
is going to be an attempt.

00:42:34.270 --> 00:42:36.400
This is not going to work,
but nevertheless, it's

00:42:36.400 --> 00:42:40.530
going to have the germ of the
right idea or not the germ

00:42:40.530 --> 00:42:43.930
but the beginning of the
right way to think about it.

00:42:43.930 --> 00:42:46.680
So here are the two
read-once branching programs,

00:42:46.680 --> 00:42:49.160
B,1 and B,2.

00:42:49.160 --> 00:42:51.680
And I want to see,
do they compute

00:42:51.680 --> 00:42:54.780
the same function or not?

00:42:54.780 --> 00:42:57.170
So one thing you
might try is just

00:42:57.170 --> 00:43:02.300
running them on a bunch of
randomly selected assignments

00:43:02.300 --> 00:43:04.640
or inputs.

00:43:04.640 --> 00:43:09.140
So you can just take two
random input assignments.

00:43:09.140 --> 00:43:14.300
Just take x1, flip a
coin to say it's 1 or 0.

00:43:14.300 --> 00:43:17.600
Do the same for x2 and so on.

00:43:17.600 --> 00:43:19.880
Then you get some
input assignment.

00:43:19.880 --> 00:43:22.820
You run the two branching
programs on that assignment.

00:43:22.820 --> 00:43:24.260
And maybe that
doesn't give-- even

00:43:24.260 --> 00:43:26.510
if they agree, it doesn't
give you a lot of confidence

00:43:26.510 --> 00:43:30.070
that you get the right answer,
that they're really equivalent.

00:43:30.070 --> 00:43:32.150
So you do it 100
times, whatever--

00:43:32.150 --> 00:43:34.580
some number of times.

00:43:34.580 --> 00:43:42.423
And of course, if
they ever disagree

00:43:42.423 --> 00:43:43.965
on one of those
assignments, then you

00:43:43.965 --> 00:43:48.630
know they're not equivalent,
and you can immediately reject.

00:43:48.630 --> 00:43:52.500
But what I'd like
to say is if they

00:43:52.500 --> 00:44:02.300
agree on those 100 tries or
those 100 assignments there,

00:44:02.300 --> 00:44:09.990
then they are, at least
I haven't found a place

00:44:09.990 --> 00:44:12.180
where they disagree,
so I'm going

00:44:12.180 --> 00:44:15.540
to say that they're equivalent.

00:44:15.540 --> 00:44:18.460
Is that a reasonable
thing to do?

00:44:18.460 --> 00:44:20.190
Well, it might be.

00:44:20.190 --> 00:44:22.830
It depends on k.

00:44:22.830 --> 00:44:26.070
So the critical thing
is, what value of k

00:44:26.070 --> 00:44:29.100
should you pick which is
going to be big enough

00:44:29.100 --> 00:44:32.250
to allow us to draw the
conclusion that if you run it

00:44:32.250 --> 00:44:34.680
for k times, and you
never see a difference,

00:44:34.680 --> 00:44:39.630
then you can conclude,
with good confidence,

00:44:39.630 --> 00:44:43.230
that the two branching programs
are equivalent because you

00:44:43.230 --> 00:44:46.800
tried to look for a difference,
and you never found one.

00:44:46.800 --> 00:44:52.740
Well, the thing is that k is
going to have to be pretty big.

00:44:55.690 --> 00:44:59.460
So looking at it this way, if
the two branching programs were

00:44:59.460 --> 00:45:03.640
equivalent, then,
certainly, they're

00:45:03.640 --> 00:45:05.380
always going to
give the same value.

00:45:07.900 --> 00:45:09.930
So the probability that
the machine accepts

00:45:09.930 --> 00:45:10.860
is going to be one.

00:45:10.860 --> 00:45:14.070
And that's good
because we want for--

00:45:14.070 --> 00:45:15.820
this is a case when
we're in the language.

00:45:15.820 --> 00:45:18.100
We want the probability
of acceptance to be high.

00:45:18.100 --> 00:45:21.760
And here, the probability
of acceptance is actually 1.

00:45:21.760 --> 00:45:25.540
So it's always going to accept
when the two branching programs

00:45:25.540 --> 00:45:26.613
were equivalent.

00:45:26.613 --> 00:45:28.780
But what happens when the
branching programs are not

00:45:28.780 --> 00:45:29.870
equivalent?

00:45:29.870 --> 00:45:32.290
Now, we want the probability
of rejection to be high.

00:45:32.290 --> 00:45:37.540
The probably of acceptance
should be very low, right?

00:45:37.540 --> 00:45:40.660
So if they're not equivalent,
what we want-- the probability

00:45:40.660 --> 00:45:42.910
that the machine
rejects is going

00:45:42.910 --> 00:45:46.720
to be high if they're not
equivalent because that's

00:45:46.720 --> 00:45:48.520
what the correct answer is.

00:45:48.520 --> 00:45:52.130
Well, the only way the
machine is going to reject--

00:45:52.130 --> 00:45:56.090
if it finds a
place where the two

00:45:56.090 --> 00:45:59.540
branching programs disagree.

00:45:59.540 --> 00:46:02.540
But those two
branching programs,

00:46:02.540 --> 00:46:08.340
even though not equivalent,
might disagree rarely.

00:46:08.340 --> 00:46:11.850
They might only disagree on one
input assignment out of the 2

00:46:11.850 --> 00:46:15.020
to the n possibilities.

00:46:15.020 --> 00:46:17.290
So these two in-equivalent
branching programs

00:46:17.290 --> 00:46:20.350
might agree almost everywhere,
just except at one place.

00:46:20.350 --> 00:46:22.850
And then that's enough for
them not to be equivalent.

00:46:22.850 --> 00:46:24.700
But the problem is
that if you're just

00:46:24.700 --> 00:46:29.230
going to do random
sampling, the likelihood

00:46:29.230 --> 00:46:33.040
of finding that one exceptional
place where the two disagree

00:46:33.040 --> 00:46:33.737
is very low.

00:46:33.737 --> 00:46:36.070
You're going to have to do
an enormous number of samples

00:46:36.070 --> 00:46:43.100
before you're likely to find
that point of difference.

00:46:43.100 --> 00:46:49.360
And so in order to be
confident that you're

00:46:49.360 --> 00:46:51.670
going to find that
difference, if there is one,

00:46:51.670 --> 00:46:54.250
you're going to have to do
exponentially many samples.

00:46:54.250 --> 00:46:56.800
And you don't have time to do
that with a polynomial time

00:46:56.800 --> 00:46:57.798
algorithm.

00:47:02.318 --> 00:47:04.360
You're just going to have
to flip too many coins.

00:47:04.360 --> 00:47:08.980
You have to run too
many different samples,

00:47:08.980 --> 00:47:12.190
different assignments
through these two machines.

00:47:12.190 --> 00:47:18.470
And because they're different,
but they're almost the same.

00:47:18.470 --> 00:47:21.130
So we're going to need to
find a different method.

00:47:21.130 --> 00:47:26.300
And the idea is
we're going to run

00:47:26.300 --> 00:47:32.140
these two branching
programs in some crazy way.

00:47:32.140 --> 00:47:34.570
Instead of running them
on 0's and 1's that we've

00:47:34.570 --> 00:47:36.130
been doing it so
far, we're going

00:47:36.130 --> 00:47:39.640
to feed in values for
the variables which

00:47:39.640 --> 00:47:41.320
are non-Boolean.

00:47:41.320 --> 00:47:42.760
They are going to be--

00:47:42.760 --> 00:47:50.950
we're going to set x1
to 2, x3 to 7, x4 to 15.

00:47:50.950 --> 00:47:53.960
Of course, that doesn't
seem to make any sense.

00:47:53.960 --> 00:47:56.620
But it's nevertheless going to
turn out to be a useful thing

00:47:56.620 --> 00:47:58.495
to do, and it's going
to give us some insight

00:47:58.495 --> 00:48:00.178
into the equivalence
or in-equivalence

00:48:00.178 --> 00:48:01.345
of these branching programs.

00:48:04.230 --> 00:48:06.660
OK, so let's just--

00:48:06.660 --> 00:48:07.980
I think-- are we at the end of?

00:48:07.980 --> 00:48:09.430
Yeah, we're at the break here.

00:48:09.430 --> 00:48:12.970
So I'm getting some questions
coming in, which is great.

00:48:12.970 --> 00:48:14.220
I will answer those questions.

00:48:14.220 --> 00:48:18.600
But why don't I start
off our break and then--

00:48:23.295 --> 00:48:23.795
OK.

00:48:29.880 --> 00:48:35.370
OK, so there's a question
about whether this machine runs

00:48:35.370 --> 00:48:36.720
deterministically or not.

00:48:36.720 --> 00:48:39.220
So which machine are
we talking about?

00:48:39.220 --> 00:48:41.760
So the branching
programs themselves,

00:48:41.760 --> 00:48:43.050
they run deterministically.

00:48:43.050 --> 00:48:47.370
You give them an assignment
to the input variables

00:48:47.370 --> 00:48:51.600
that's going to determine a path
through each branching program,

00:48:51.600 --> 00:48:54.420
which is eventually going
to output a 0 or a 1.

00:48:54.420 --> 00:48:57.210
And you want to know, do those
two branching programs always

00:48:57.210 --> 00:49:00.240
give the same value no
matter what the input was?

00:49:00.240 --> 00:49:04.950
But the branching programs
themselves were deterministic.

00:49:04.950 --> 00:49:08.210
Now the machine
that's trying to make

00:49:08.210 --> 00:49:11.120
the determination of whether
those two branching programs

00:49:11.120 --> 00:49:14.360
are equivalent, that machine
that we're going to be arguing

00:49:14.360 --> 00:49:16.760
is going to be a
probabilistic machine.

00:49:16.760 --> 00:49:18.890
So it's a kind of
non-deterministic machine

00:49:18.890 --> 00:49:21.950
that's going to have different
possible ways to go depending

00:49:21.950 --> 00:49:25.540
upon the outcome
of its coin tosses.

00:49:25.540 --> 00:49:28.710
So you can think of
as non-determinism

00:49:28.710 --> 00:49:33.920
in the ordinary sense, that it
has a tree of possibilities.

00:49:33.920 --> 00:49:39.290
But now the way we're thinking
about acceptance is different.

00:49:39.290 --> 00:49:43.610
Instead of accepting, if
there's just one accept branch,

00:49:43.610 --> 00:49:46.190
the machine, for
it to accept, has

00:49:46.190 --> 00:49:50.240
to have a majority of the
branches be accepting.

00:49:50.240 --> 00:49:56.600
And so there's some similarities
but some differences

00:49:56.600 --> 00:49:59.640
with the usual way we
think of non-determinism.

00:49:59.640 --> 00:50:01.790
So what's the motivation
behind introducing

00:50:01.790 --> 00:50:03.530
this type of Turing machine?

00:50:03.530 --> 00:50:09.050
Well, I mean, I guess
there are two motivations.

00:50:12.230 --> 00:50:15.020
Probabilistic algorithms,
sometimes called Monte Carlo

00:50:15.020 --> 00:50:18.650
algorithms, turn out to
be useful in practice

00:50:18.650 --> 00:50:20.310
for a variety of things.

00:50:20.310 --> 00:50:26.540
And so that led to people
to think about them

00:50:26.540 --> 00:50:29.120
in the context of complexity.

00:50:29.120 --> 00:50:31.470
They're related in some
ways to quantum computers,

00:50:31.470 --> 00:50:35.060
which are also probabilistic
in a somewhat different way.

00:50:35.060 --> 00:50:44.640
But they also have a
very nice formulation

00:50:44.640 --> 00:50:46.270
in complexity theory.

00:50:46.270 --> 00:50:48.600
So complexity
theorists like to think

00:50:48.600 --> 00:50:51.270
about probabilistic
computation because, I mean,

00:50:51.270 --> 00:50:53.880
you can do interesting things
with probabilistic machines.

00:50:53.880 --> 00:50:55.740
And the complexity
classes associated

00:50:55.740 --> 00:50:56.890
are also interesting.

00:50:56.890 --> 00:51:00.330
So as you'll see, it leads us
in an interesting direction

00:51:00.330 --> 00:51:03.130
to consider how to
solve this problem,

00:51:03.130 --> 00:51:06.810
this read-once branching
program problem equivalence

00:51:06.810 --> 00:51:08.040
with a probabilistic machine.

00:51:08.040 --> 00:51:10.565
It's just an
interesting algorithm

00:51:10.565 --> 00:51:11.940
that we're going
to come up with.

00:51:19.200 --> 00:51:21.390
So in our proof
attempt, where did we

00:51:21.390 --> 00:51:24.120
use the probabilistic
nature for BPP?

00:51:24.120 --> 00:51:26.250
Because we're running the
two branching programs

00:51:26.250 --> 00:51:27.390
on a random input.

00:51:32.720 --> 00:51:35.660
I mean, so you have your
two branching programs.

00:51:35.660 --> 00:51:39.440
You pick a random input to run
those two branching programs,

00:51:39.440 --> 00:51:41.420
and you see what they do.

00:51:41.420 --> 00:51:43.220
That's why it's probabilistic.

00:51:43.220 --> 00:51:47.606
When you think about random
behavior of the machine,

00:51:47.606 --> 00:51:49.680
that's a probabilistic machine.

00:51:49.680 --> 00:51:53.900
So each branch of
the machine is going

00:51:53.900 --> 00:51:56.750
to be like the way we normally
think about non-determinism.

00:51:56.750 --> 00:51:59.392
Somebody is asking
whether we think

00:51:59.392 --> 00:52:01.100
of the complexity of
the machine in terms

00:52:01.100 --> 00:52:05.780
of all of the branches of
the machine or each branch

00:52:05.780 --> 00:52:06.470
separately.

00:52:06.470 --> 00:52:09.140
We always think about, for
non-deterministic machines,

00:52:09.140 --> 00:52:11.665
each branch separately.

00:52:11.665 --> 00:52:12.540
I'm not totally sure.

00:52:12.540 --> 00:52:13.873
I understand the question there.

00:52:13.873 --> 00:52:16.280
So are all the inputs
built-in, and we randomly

00:52:16.280 --> 00:52:19.548
choose one through coin flips?

00:52:19.548 --> 00:52:21.340
Not sure I understand
that question either.

00:52:21.340 --> 00:52:25.070
We're given as input the
two branching programs.

00:52:25.070 --> 00:52:30.670
And then we flip coins
using our non-determinism--

00:52:30.670 --> 00:52:32.420
you can think about
it equivalent in terms

00:52:32.420 --> 00:52:33.440
of coin flips--

00:52:33.440 --> 00:52:36.060
to choose the values
of the variables.

00:52:36.060 --> 00:52:38.480
So now, we have a set
of variable inputs

00:52:38.480 --> 00:52:41.420
to the values of the variables.

00:52:41.420 --> 00:52:47.540
And we use that as input
to the branching programs

00:52:47.540 --> 00:52:49.740
to see whether they--

00:52:49.740 --> 00:52:51.860
to see what answers they
give, and, in particular,

00:52:51.860 --> 00:52:53.300
whether they give
the same answer

00:52:53.300 --> 00:52:57.030
on that randomly-chosen input.

00:52:57.030 --> 00:52:57.720
Let's move on.

00:53:01.480 --> 00:53:09.760
All right, so now moving us
toward the actual BPP algorithm

00:53:09.760 --> 00:53:17.590
for read-once branching
program equivalence testing,

00:53:17.590 --> 00:53:21.315
we have to think about
a different way to--

00:53:24.610 --> 00:53:28.450
we need an alternate way of
thinking about the computation

00:53:28.450 --> 00:53:30.940
of a branching program.

00:53:30.940 --> 00:53:33.160
It's going to look
very similar, but it's

00:53:33.160 --> 00:53:34.810
going to lead us in
a direction that's

00:53:34.810 --> 00:53:39.760
going to allow us to talk
about these non-Boolean inputs

00:53:39.760 --> 00:53:41.500
that I referred to.

00:53:41.500 --> 00:53:43.180
Just kind of where
we're going-- we're

00:53:43.180 --> 00:53:45.040
going to be simulating
branching programs

00:53:45.040 --> 00:53:50.080
with polynomials, if that helps
you as an overarching plan.

00:53:50.080 --> 00:53:52.900
But we'll get there
a little slowly.

00:53:52.900 --> 00:53:58.150
So OK, here's a read-once
branching program.

00:53:58.150 --> 00:54:01.840
We're not going to use the
read-once feature just yet,

00:54:01.840 --> 00:54:03.530
but that'll come later.

00:54:03.530 --> 00:54:05.155
But anyway, here's
a branching program.

00:54:12.710 --> 00:54:14.760
Oh, here's my branch and my--

00:54:14.760 --> 00:54:16.350
I crashed here.

00:54:16.350 --> 00:54:17.660
I'll start that again.

00:54:22.720 --> 00:54:27.990
OK, so we take an
input, whatever it is,

00:54:27.990 --> 00:54:31.002
and thinking about the
computation of the branching--

00:54:31.002 --> 00:54:33.210
so we're not thinking about
the algorithm, right now.

00:54:33.210 --> 00:54:35.043
We're just thinking
about branching programs

00:54:35.043 --> 00:54:35.880
for the minute.

00:54:35.880 --> 00:54:39.860
We're going to get back
to the algorithm later.

00:54:39.860 --> 00:54:43.870
So the branching program
follows a path, as I indicated,

00:54:43.870 --> 00:54:45.340
when you have a
particular input.

00:54:45.340 --> 00:54:51.310
If x1 is 0, x2 is 1,
x3 is 1, so the output

00:54:51.310 --> 00:54:53.270
is going to be 1 in this case.

00:54:53.270 --> 00:54:53.770
OK?

00:54:56.580 --> 00:55:02.040
So the way I want to think about
this a little differently is I

00:55:02.040 --> 00:55:07.170
want to label all of the
nodes and all of the edges

00:55:07.170 --> 00:55:11.130
with a value that
tells me whether or not

00:55:11.130 --> 00:55:15.590
this yellow path went
through that node or edge.

00:55:15.590 --> 00:55:17.540
It's going to be
just doing the same,

00:55:17.540 --> 00:55:21.370
but you may think this
is no difference at all.

00:55:21.370 --> 00:55:25.200
But I want to label all of
the things on the yellow path,

00:55:25.200 --> 00:55:27.300
I'm going to label
them with a 1.

00:55:27.300 --> 00:55:30.120
And all of the things that
are not on the yellow path,

00:55:30.120 --> 00:55:33.340
I'm going to label with a 0.

00:55:33.340 --> 00:55:35.860
So I'm trying to keep
those labels apart

00:55:35.860 --> 00:55:38.525
from the original
branching program, which

00:55:38.525 --> 00:55:39.400
are written in white.

00:55:39.400 --> 00:55:41.990
These labels are
written in yellow.

00:55:41.990 --> 00:55:44.120
But these labels have
to do with the execution

00:55:44.120 --> 00:55:48.050
of the branching
program on an input.

00:55:48.050 --> 00:55:52.100
So once I have an input, that's
going to determine a 1 or a 0

00:55:52.100 --> 00:55:55.070
label for every node and edge.

00:56:00.130 --> 00:56:03.007
Now if we want to
look at the output

00:56:03.007 --> 00:56:05.340
from this branching program
after we have that labeling,

00:56:05.340 --> 00:56:09.000
we only have to look at the
label of the one output node

00:56:09.000 --> 00:56:11.790
because if that
one has a 1 on it,

00:56:11.790 --> 00:56:14.310
that means that the path
went through that 1.

00:56:14.310 --> 00:56:18.600
And so therefore,
the output is 1.

00:56:23.310 --> 00:56:26.820
So I'm going to give you
another way of assigning that.

00:56:26.820 --> 00:56:30.060
Instead of just coming
finding the path first

00:56:30.060 --> 00:56:32.267
and then coming up with
the labeling afterward,

00:56:32.267 --> 00:56:34.350
I'm going to give you a
different way of coming up

00:56:34.350 --> 00:56:37.140
with that labeling, kind of
building it up inductively,

00:56:37.140 --> 00:56:41.550
starting at the start node
and building up that labeling.

00:56:41.550 --> 00:56:45.190
You'll see what I
mean by my example.

00:56:45.190 --> 00:56:49.040
So if I have a
label on this node,

00:56:49.040 --> 00:56:52.480
so I already know whether
or not the path went

00:56:52.480 --> 00:56:56.740
through that node, label 1
means the path went through it.

00:56:56.740 --> 00:56:59.830
Label 0 means the path
does not go through it.

00:57:03.720 --> 00:57:08.060
That's going to tell me how to
label the two outgoing edges.

00:57:08.060 --> 00:57:09.990
So if I've already
labeled this with a,

00:57:09.990 --> 00:57:16.070
where a is a 0 or a 1, then
what expression should I use?

00:57:19.640 --> 00:57:22.250
Under what circumstances
will I label--

00:57:22.250 --> 00:57:26.940
what's the right label for
this one outgoing edge here?

00:57:26.940 --> 00:57:31.780
Well, if a is 0, that means
we know the path did not

00:57:31.780 --> 00:57:33.410
go through this node.

00:57:33.410 --> 00:57:36.190
So there's no way it could
go through that a edge.

00:57:36.190 --> 00:57:42.400
Similarly, if xi
is a 0, that means,

00:57:42.400 --> 00:57:44.320
even if we did go
through that node,

00:57:44.320 --> 00:57:48.700
the path would go through the
other outgoing edge and not

00:57:48.700 --> 00:57:49.640
through this one.

00:57:49.640 --> 00:57:53.860
So that tells us that the
Boolean expression which

00:57:53.860 --> 00:57:59.080
describes the label of
this node in the execution

00:57:59.080 --> 00:58:03.610
is going to be the and
of the value on the node

00:58:03.610 --> 00:58:08.080
and the query
variable of that node.

00:58:08.080 --> 00:58:10.720
Now think about,
what's the right way

00:58:10.720 --> 00:58:14.380
to label the other
edge, the execution

00:58:14.380 --> 00:58:17.110
value of the other edge?

00:58:17.110 --> 00:58:18.400
Again, you have to have--

00:58:18.400 --> 00:58:20.890
go through this node,
so a has to be 1.

00:58:20.890 --> 00:58:24.790
But now, you want xi to be 0 in
order to go through that edge.

00:58:24.790 --> 00:58:28.000
So that means it's going to
be a and the complement of xi.

00:58:30.390 --> 00:58:30.890
OK?

00:58:30.890 --> 00:58:32.790
So this is going to
just tell me this.

00:58:32.790 --> 00:58:38.530
I'm writing a formula for how
we labeling these edges based

00:58:38.530 --> 00:58:41.500
on the label of the parent node.

00:58:41.500 --> 00:58:45.640
Similarly, if I have a bunch
of edges where I already

00:58:45.640 --> 00:58:50.740
know the values, the labels,
the execution labels there,

00:58:50.740 --> 00:58:53.800
let's say, so I have a1, a2,
and a3, what is the right label

00:58:53.800 --> 00:58:55.030
to put on this node?

00:58:58.550 --> 00:59:00.710
Well, if any one
of those is a 1,

00:59:00.710 --> 00:59:03.750
that means the path
went through that edge.

00:59:03.750 --> 00:59:06.360
And so therefore, it's going
to go through that node.

00:59:06.360 --> 00:59:09.470
So that tells us that the
label to put on that node

00:59:09.470 --> 00:59:14.900
is the or of the labels
on the incoming edges.

00:59:14.900 --> 00:59:17.060
OK?

00:59:17.060 --> 00:59:18.050
Questions on this?

00:59:21.270 --> 00:59:27.040
So now this is setting
the stage for starting

00:59:27.040 --> 00:59:31.810
to think about this
more toward polynomials

00:59:31.810 --> 00:59:33.835
instead of using
a Boolean algebra.

00:59:36.360 --> 00:59:41.150
So I'm getting a question-- how
do we know what the execution

00:59:41.150 --> 00:59:43.490
path is, which nodes to label?

00:59:43.490 --> 00:59:46.640
We're going to be
labeling all of the nodes.

00:59:46.640 --> 00:59:50.690
So we start off
with labeling the--

00:59:50.690 --> 00:59:51.830
did I say that here?

00:59:51.830 --> 00:59:54.380
We start up-- I didn't
say it, but I should have.

00:59:54.380 --> 00:59:58.130
We labeled the start node
with 1 because the path always

00:59:58.130 --> 00:59:59.460
goes through the start node.

00:59:59.460 --> 01:00:01.550
So without even
talking about a path,

01:00:01.550 --> 01:00:04.400
we just label the start node 1.

01:00:04.400 --> 01:00:07.340
Well, maybe we'll do an
example of this also.

01:00:07.340 --> 01:00:11.660
But now, once we label
this start-- this node 1,

01:00:11.660 --> 01:00:14.810
we have an expression
that tells us

01:00:14.810 --> 01:00:21.860
how to label the two outgoing
edges, this edge and that edge.

01:00:21.860 --> 01:00:26.600
And I'm doing it without knowing
the values of the variables.

01:00:26.600 --> 01:00:28.337
I'm just making an
expression, which

01:00:28.337 --> 01:00:30.170
is going to describe
what those labels would

01:00:30.170 --> 01:00:33.380
be once you tell me what
the input assignment is.

01:00:35.890 --> 01:00:37.750
OK so I'm just sort of--

01:00:37.750 --> 01:00:40.420
it's almost like a
symbolic execution here.

01:00:40.420 --> 01:00:42.430
I'm just writing down
the different expressions

01:00:42.430 --> 01:00:45.280
for how to calculate what
these things should be.

01:00:47.980 --> 01:00:55.570
Let me-- maybe this will
become clearer as we continue.

01:00:55.570 --> 01:01:00.930
So now this is the big
idea of this proof.

01:01:00.930 --> 01:01:04.530
We're going to use something
called arithmetization.

01:01:04.530 --> 01:01:07.290
We're going to convert
from thinking about things

01:01:07.290 --> 01:01:09.660
in the Boolean world to
thinking about things

01:01:09.660 --> 01:01:13.050
in the arithmetical world,
where we have arithmetic

01:01:13.050 --> 01:01:16.050
over integers,
let's say, for now.

01:01:16.050 --> 01:01:17.483
So instead of ands
and ors, we're

01:01:17.483 --> 01:01:19.275
going to be talking
about pluses and times.

01:01:22.580 --> 01:01:27.730
And the way we're going
to make the bridge

01:01:27.730 --> 01:01:33.880
is by showing how to simulate
the and and or operations

01:01:33.880 --> 01:01:37.180
with the plus and
times operations.

01:01:37.180 --> 01:01:45.490
So assuming 1 means
true and 0 means false,

01:01:45.490 --> 01:01:52.630
if you have the expression a
and b as a Boolean expression,

01:01:52.630 --> 01:01:57.890
we can represent that as
a times b using arithmetic

01:01:57.890 --> 01:02:04.600
because it computes
exactly the same value when

01:02:04.600 --> 01:02:09.310
we have the Boolean
representation

01:02:09.310 --> 01:02:12.430
of true and false being 1 and 0.

01:02:12.430 --> 01:02:16.180
So 1 and 1 is 1.

01:02:16.180 --> 01:02:18.640
And 1 times 1 is 1.

01:02:18.640 --> 01:02:20.230
And anything else--

01:02:20.230 --> 01:02:24.670
1 and 0, 0 and 1, 0 and 0--

01:02:24.670 --> 01:02:26.170
if you applied the
times operator,

01:02:26.170 --> 01:02:27.628
you're going to
get the same value.

01:02:27.628 --> 01:02:32.060
So times is very much
like and in this sense.

01:02:32.060 --> 01:02:33.800
OK, we're going to
write it as just ab,

01:02:33.800 --> 01:02:37.460
usually, without
the time symbol.

01:02:37.460 --> 01:02:40.720
So if we have a
complement, how would we

01:02:40.720 --> 01:02:44.050
simulate that with arithmetic?

01:02:44.050 --> 01:02:50.200
Well, again, here we're
just flipping one and 0

01:02:50.200 --> 01:02:52.990
in using the complement
operation that's

01:02:52.990 --> 01:02:55.180
going to be the
same as subtracting

01:02:55.180 --> 01:02:59.740
the value from one that also
flips it from between 1 and 0.

01:03:02.390 --> 01:03:05.270
How about or-- if
you have a or b?

01:03:05.270 --> 01:03:09.320
Well, it's slightly
more complicated

01:03:09.320 --> 01:03:14.840
because you use
a plus b, but you

01:03:14.840 --> 01:03:18.890
have to subtract off
the product because what

01:03:18.890 --> 01:03:24.140
you want is this
simulation should give you

01:03:24.140 --> 01:03:25.710
exactly the same value.

01:03:25.710 --> 01:03:31.850
So if you have 1 or 1, you
want that to be a 1 answer.

01:03:31.850 --> 01:03:33.378
You don't want it to be a 2.

01:03:33.378 --> 01:03:35.045
So you have to subtract
off the product.

01:03:39.340 --> 01:03:43.480
And the goal is to have a
faithful simulation of the and

01:03:43.480 --> 01:03:44.960
or by using plus and times.

01:03:44.960 --> 01:03:47.620
So you get exactly
the same answers out

01:03:47.620 --> 01:03:52.020
when you put in
Boolean values here.

01:03:52.020 --> 01:03:58.215
OK, so just to say where we're
going, what this is going to--

01:04:01.782 --> 01:04:03.740
superficially, we haven't
really done anything.

01:04:06.890 --> 01:04:10.850
But what this is going
to enable us to do

01:04:10.850 --> 01:04:16.630
is plug in values which are
not Boolean because it doesn't

01:04:16.630 --> 01:04:17.980
make sense to talk about--

01:04:17.980 --> 01:04:20.410
it makes sense to
talk about 1 and 0,

01:04:20.410 --> 01:04:24.370
but it doesn't make sense
to talk about 2 and 3.

01:04:24.370 --> 01:04:28.590
But it does make sense
to talk about 2 times 3.

01:04:28.590 --> 01:04:33.490
And that's going to be useful.

01:04:33.490 --> 01:04:34.730
OK, so let's just see.

01:04:39.520 --> 01:04:46.110
Remember that inductive
labeling procedure

01:04:46.110 --> 01:04:51.390
that I described before,
where I gave the execution

01:04:51.390 --> 01:04:55.440
labels on the edges depending
upon the label of the parent

01:04:55.440 --> 01:04:59.340
node and which node, which
variable is being queried.

01:04:59.340 --> 01:05:03.570
So if I know that this
value is an a, but now the--

01:05:06.350 --> 01:05:08.210
OK, so I'm just
going to write this

01:05:08.210 --> 01:05:14.520
down using arithmetic instead
of using Boolean operations.

01:05:14.520 --> 01:05:18.560
So before, we have-- this
was a and xi, If you remember

01:05:18.560 --> 01:05:20.307
from the previous slide.

01:05:20.307 --> 01:05:22.640
Now what are we going to use
instead because we're going

01:05:22.640 --> 01:05:24.350
to use this conversion here?

01:05:24.350 --> 01:05:28.050
Instead of and, we're going
to use multiplication.

01:05:28.050 --> 01:05:30.560
That's just a times xi.

01:05:30.560 --> 01:05:31.940
What about on this side?

01:05:31.940 --> 01:05:36.670
Here was and a and
the complement of xi.

01:05:36.670 --> 01:05:42.340
Now the complement of xi is
1 minus xi arithmetically.

01:05:42.340 --> 01:05:49.330
So this becomes a
times 1 minus xi, OK?

01:05:49.330 --> 01:05:56.240
Similarly, here, we did the or
to get the label on the node

01:05:56.240 --> 01:05:59.600
from the labels of
its incoming edges.

01:05:59.600 --> 01:06:02.810
Now, we're going do something
a little strange because we

01:06:02.810 --> 01:06:04.550
have a formula here for or.

01:06:04.550 --> 01:06:07.650
But for technical reasons
that will come up later,

01:06:07.650 --> 01:06:11.090
this is not a convenient
representation for us.

01:06:11.090 --> 01:06:13.610
What I'm going to use
instead of this one--

01:06:13.610 --> 01:06:18.310
I'm just going to simply
say, let's take the sum.

01:06:18.310 --> 01:06:19.375
Why is that good enough?

01:06:22.100 --> 01:06:24.380
In this case, this
is still going

01:06:24.380 --> 01:06:27.920
to be a faithful representation
and give the right answer all

01:06:27.920 --> 01:06:29.190
of the time.

01:06:29.190 --> 01:06:35.360
And that's because for
our branching programs,

01:06:35.360 --> 01:06:40.940
read-once or otherwise,
read-once is not coming in yet,

01:06:40.940 --> 01:06:45.410
for our branching
programs, they're acyclic.

01:06:45.410 --> 01:06:50.440
So they can never enter a
node on two different paths.

01:06:50.440 --> 01:06:54.170
There's, at most, one way to
come into a node on a path

01:06:54.170 --> 01:06:56.240
through the-- on
an execution path

01:06:56.240 --> 01:06:57.560
through the branching program.

01:06:57.560 --> 01:07:02.390
If it comes in
through this edge,

01:07:02.390 --> 01:07:05.510
there's no way for this edge to
also have a path because that

01:07:05.510 --> 01:07:11.870
means you have to go out
and come back and have

01:07:11.870 --> 01:07:15.440
a cycle in the branching
program, which is disallowed.

01:07:15.440 --> 01:07:18.440
So at most, one
of these edges can

01:07:18.440 --> 01:07:20.310
have the path go through it.

01:07:20.310 --> 01:07:23.490
So at most, one of
these a's can be a 1.

01:07:23.490 --> 01:07:25.010
The others are going to be 0.

01:07:25.010 --> 01:07:27.140
And therefore,
just taking the sum

01:07:27.140 --> 01:07:29.960
is going to give us a
value of either 0 or 1,

01:07:29.960 --> 01:07:32.000
but it's never going
to give a value higher.

01:07:32.000 --> 01:07:34.130
And so you don't
have to subtract off

01:07:34.130 --> 01:07:36.130
these product terms.

01:07:36.130 --> 01:07:37.380
A little bit complicated here.

01:07:37.380 --> 01:07:41.070
If you didn't totally get
that, don't worry for now.

01:07:41.070 --> 01:07:45.810
We're more concerned that you
get the big picture of what's

01:07:45.810 --> 01:07:46.410
going on.

01:07:49.850 --> 01:07:55.174
OK, so I think we're almost--

01:07:55.174 --> 01:07:58.600
let me just see how far we are.

01:07:58.600 --> 01:07:59.290
Yeah.

01:07:59.290 --> 01:08:01.630
So I'm just going to
work through an example.

01:08:01.630 --> 01:08:04.500
And I think that'll bring us--

01:08:04.500 --> 01:08:08.070
let's just see, Do we
have any questions here?

01:08:08.070 --> 01:08:09.320
Not seeing any.

01:08:09.320 --> 01:08:13.530
That means you're either
all totally understanding,

01:08:13.530 --> 01:08:15.270
or you're totally lost.

01:08:15.270 --> 01:08:17.460
I never can tell.

01:08:17.460 --> 01:08:21.990
So feel free to ask a question,
even if you're confused.

01:08:21.990 --> 01:08:24.750
I'll do my best.

01:08:24.750 --> 01:08:26.939
OK, maybe this
example might help.

01:08:29.880 --> 01:08:31.609
So now, what we're
going to do is,

01:08:31.609 --> 01:08:39.380
using this arithmetical view of
the way a branching program's

01:08:39.380 --> 01:08:46.550
computation is executed
when we're running

01:08:46.550 --> 01:08:49.729
an input through
it, this is going

01:08:49.729 --> 01:08:52.250
to allow us now
to give a meaning

01:08:52.250 --> 01:08:55.380
to running the branching
program on non-Boolean inputs.

01:08:55.380 --> 01:08:57.410
So maybe this example
will illustrate that.

01:09:00.479 --> 01:09:03.140
So let's just take this
particular branching program

01:09:03.140 --> 01:09:06.870
here, OK?

01:09:06.870 --> 01:09:09.960
This branching program it's just
on two variables, x1 and x2,

01:09:09.960 --> 01:09:12.430
and it actually computes
a familiar function.

01:09:12.430 --> 01:09:14.130
This is the
exclusive or function

01:09:14.130 --> 01:09:15.580
if you look at it for a minute.

01:09:15.580 --> 01:09:20.670
You'll see that this is going
to give you x1 exclusive or x2.

01:09:20.670 --> 01:09:25.439
So it's going to be 1 if
either of the x1 or x2 are 1,

01:09:25.439 --> 01:09:27.660
but it's going to be
0 if they're both 1.

01:09:27.660 --> 01:09:30.720
That's what this branching
program computes.

01:09:30.720 --> 01:09:35.899
Now, but let's take a look at
running this branching program

01:09:35.899 --> 01:09:39.109
instead of on the
usual Boolean values,

01:09:39.109 --> 01:09:45.189
let's run it on x1 equal
to 2 and x2 equal to 3.

01:09:45.189 --> 01:09:52.370
Now a common confusion might
be that you're looking--

01:09:52.370 --> 01:09:55.370
when you do the x1
query, you're looking

01:09:55.370 --> 01:10:00.140
for another outgoing
edge, which is labeled 2.

01:10:00.140 --> 01:10:02.000
No, that's not what I'm doing.

01:10:02.000 --> 01:10:05.150
What I'm doing here
is, I'm somehow,

01:10:05.150 --> 01:10:08.990
through this execution, by
assigning these other values,

01:10:08.990 --> 01:10:11.900
I'm blending together
the computation

01:10:11.900 --> 01:10:18.098
of x1 equal to 0 and
x1 equal to 1 together.

01:10:18.098 --> 01:10:19.640
I don't know if that
makes any sense.

01:10:19.640 --> 01:10:22.890
But let's look
through the example.

01:10:22.890 --> 01:10:25.400
So first of all, these
are the labeling rules

01:10:25.400 --> 01:10:29.990
that I had from
the previous slide

01:10:29.990 --> 01:10:35.108
when I used plus and times
instead of and and or, OK?

01:10:35.108 --> 01:10:36.650
Now, I'm going to
show you how to use

01:10:36.650 --> 01:10:41.060
that to label the nodes
and edges of this graph

01:10:41.060 --> 01:10:44.190
based on this input.

01:10:44.190 --> 01:10:46.580
And that will determine
an output would

01:10:46.580 --> 01:10:50.590
be the value on the 1 node.

01:10:50.590 --> 01:10:54.960
OK, so we always start out
by labeling the start with 1.

01:10:54.960 --> 01:10:55.830
That's just a rule.

01:10:59.410 --> 01:11:02.680
And OK, sorry.

01:11:02.680 --> 01:11:06.640
Let's think about it together
before I blurt out the answer.

01:11:06.640 --> 01:11:11.640
What's going to be the
label on this edge?

01:11:11.640 --> 01:11:15.440
So this is one of the outgoing
edges from a node that

01:11:15.440 --> 01:11:16.710
already has a label.

01:11:16.710 --> 01:11:19.900
So that's going to
be this case, here.

01:11:19.900 --> 01:11:24.190
And what we do is if we
take the label of that node,

01:11:24.190 --> 01:11:27.370
and since it's a 1
edge that's outgoing,

01:11:27.370 --> 01:11:32.590
we multiply that
label by the value

01:11:32.590 --> 01:11:42.290
of that variable of the
assignment to that variable.

01:11:42.290 --> 01:11:44.520
So x1 is 2.

01:11:44.520 --> 01:11:48.690
So we take-- the a here is 1.

01:11:48.690 --> 01:11:50.730
x1 is assigned to 2.

01:11:50.730 --> 01:11:56.550
So it's going to be 1 times 2
is going to be the execution

01:11:56.550 --> 01:11:58.543
value we put on this edge.

01:11:58.543 --> 01:11:59.460
So it's going to be 2.

01:12:02.570 --> 01:12:06.110
What's going to be the value
we put on the other edge, the 0

01:12:06.110 --> 01:12:08.952
outgoing edge from x1?

01:12:08.952 --> 01:12:10.910
So I want you to think
about that for a second.

01:12:15.930 --> 01:12:18.290
So now, we're going to
use this expression.

01:12:18.290 --> 01:12:20.390
It's a times 1 minus xi.

01:12:23.050 --> 01:12:25.630
And so xi, again, is 2.

01:12:25.630 --> 01:12:28.330
So 1 minus xi is 1 minus 2.

01:12:31.210 --> 01:12:33.850
That's how compliment--
OK, well, let's save that.

01:12:33.850 --> 01:12:35.740
So it's 1 minus 2.

01:12:35.740 --> 01:12:39.740
So that's minus 1
times the label 1 here.

01:12:39.740 --> 01:12:41.920
So you get minus 1 is
the label on this edge.

01:12:45.460 --> 01:12:51.370
Now keep in mind that
if I had plugged in--

01:12:51.370 --> 01:12:54.700
and this is very important-- if
I had plugged in Boolean values

01:12:54.700 --> 01:12:57.860
here, I would be getting
out the same Boolean

01:12:57.860 --> 01:13:01.950
values that you would get just
by following through the path.

01:13:01.950 --> 01:13:04.080
The things on the
path would be 1.

01:13:04.080 --> 01:13:05.550
The things off the
path would be 0.

01:13:10.750 --> 01:13:16.390
But what's happening here
is that there's still

01:13:16.390 --> 01:13:19.882
a meaning when the
inputs are not Boolean.

01:13:19.882 --> 01:13:20.840
So let's continue here.

01:13:20.840 --> 01:13:23.090
How about-- what's going to
be the value on this node?

01:13:25.832 --> 01:13:26.540
So think with me.

01:13:26.540 --> 01:13:27.900
I think it'll help you.

01:13:27.900 --> 01:13:30.170
So now, we're using
this rule here.

01:13:30.170 --> 01:13:33.170
We add up all the values
on the incoming edges.

01:13:33.170 --> 01:13:36.050
There's only one incoming
edge, which is value 2.

01:13:36.050 --> 01:13:38.050
So that means this guy
is going to get a 2.

01:13:38.050 --> 01:13:39.050
And similar on this one.

01:13:39.050 --> 01:13:41.810
This guy is going
to get a minus 1.

01:13:41.810 --> 01:13:44.180
Now, let's take a
look at this edge.

01:13:44.180 --> 01:13:48.280
So this is the 0 outgoing
edge from a node labeled 2

01:13:48.280 --> 01:13:50.880
with label x2.

01:13:50.880 --> 01:13:54.160
So this is the 0 outgoing edge.

01:13:54.160 --> 01:13:55.950
The label is 2, so
it's going to be

01:13:55.950 --> 01:13:59.790
2 times 1 minus the x2 value.

01:13:59.790 --> 01:14:00.930
x2 is 3.

01:14:00.930 --> 01:14:02.730
So 1 minus 3 is minus 2.

01:14:02.730 --> 01:14:07.680
It's going to be 2 times
minus 2, which is minus 4.

01:14:07.680 --> 01:14:10.800
So similarly, you can
get the value here,

01:14:10.800 --> 01:14:14.490
the value on the
one outgoing edge

01:14:14.490 --> 01:14:20.250
is going to be 2 times
the x2 value, which is 3,

01:14:20.250 --> 01:14:23.120
so that's going to be 6.

01:14:23.120 --> 01:14:24.280
And these two here--

01:14:29.270 --> 01:14:32.110
so now, we have a minus 1.

01:14:32.110 --> 01:14:37.180
And the outgoing is a 0
edge, so it's 1 minus 3.

01:14:37.180 --> 01:14:41.620
And here, it's going
to be 1 times minus 3.

01:14:41.620 --> 01:14:42.640
No.

01:14:42.640 --> 01:14:43.430
1 times 3.

01:14:43.430 --> 01:14:43.930
I'm sorry.

01:14:43.930 --> 01:14:44.770
1 times 3.

01:14:47.760 --> 01:14:49.030
The answer's minus 3.

01:14:49.030 --> 01:14:53.630
So now what's the label
on the 0 output edge?

01:14:53.630 --> 01:14:57.080
So you have to aid up the
two incoming edges here.

01:14:57.080 --> 01:15:04.100
So we have this
edge here was a 2.

01:15:04.100 --> 01:15:08.870
This edge coming in here is a
6, so it's going to be 2 plus 6.

01:15:08.870 --> 01:15:10.400
It's 8.

01:15:10.400 --> 01:15:11.360
What about this edge--

01:15:11.360 --> 01:15:12.140
this node here?

01:15:12.140 --> 01:15:13.970
This is an important
node because this

01:15:13.970 --> 01:15:15.870
is going to be the output.

01:15:15.870 --> 01:15:26.040
So it has minus 3 coming
in and a minus 4 coming in,

01:15:26.040 --> 01:15:28.220
so you add those together.

01:15:28.220 --> 01:15:30.440
You get a minus 7.

01:15:30.440 --> 01:15:32.336
I mean, you may wonder, what--

01:15:32.336 --> 01:15:36.971
[LAUGHS] what in the
world is going on here?

01:15:36.971 --> 01:15:39.620
Is this a lot of mumbo jumbo?

01:15:39.620 --> 01:15:42.740
But we're going to make sense
of all this-- not today.

01:15:42.740 --> 01:15:45.590
We're going to have
to argue why this is--

01:15:45.590 --> 01:15:47.540
what the meaning that
we're going to get out

01:15:47.540 --> 01:15:49.250
of this is going to be.

01:15:49.250 --> 01:15:53.450
But the point is that
this is going to lead

01:15:53.450 --> 01:15:56.880
to a new algorithm for testing.

01:15:56.880 --> 01:16:00.390
This is, again, getting
back to what we were doing.

01:16:00.390 --> 01:16:02.850
This is the
equivalence problem for

01:16:02.850 --> 01:16:04.275
read-once branching programs.

01:16:04.275 --> 01:16:06.150
So now, what the new
algorithm is going to do

01:16:06.150 --> 01:16:10.270
is going to pick a random
non-Boolean assignment.

01:16:10.270 --> 01:16:12.760
So it's going to
randomly assign values

01:16:12.760 --> 01:16:16.797
to the x's and to some
non-Boolean values.

01:16:16.797 --> 01:16:18.380
Instead of zeros and
ones, we're going

01:16:18.380 --> 01:16:21.680
to plug in random
integer values.

01:16:21.680 --> 01:16:25.430
We'll make that clear next time
what the domain is going to be.

01:16:28.180 --> 01:16:31.260
And then once we have that
non-Boolean assignment,

01:16:31.260 --> 01:16:34.950
we're going to value B1 and B2.

01:16:34.950 --> 01:16:39.793
And if they disagree out
there in that extended domain,

01:16:39.793 --> 01:16:41.835
then we have to show that
they're not equivalent,

01:16:41.835 --> 01:16:43.910
and then we'll reject.

01:16:43.910 --> 01:16:48.380
And we'll also show that if
they were equivalent, then even

01:16:48.380 --> 01:16:55.190
when we evaluate them, we have
to show that if they're not

01:16:55.190 --> 01:16:58.340
equivalent, that they're
very likely to have

01:16:58.340 --> 01:17:01.380
a difference in the
non-Boolean domain.

01:17:01.380 --> 01:17:07.190
And so if they agree,
it gives you evidence

01:17:07.190 --> 01:17:10.820
that the two are
really equivalent.

01:17:10.820 --> 01:17:13.480
So the completeness proof
will come after Thanksgiving.

01:17:13.480 --> 01:17:19.360
So with that, I'm going to
wish you all a nice break.

01:17:19.360 --> 01:17:20.560
Oh, we have a check-in here.

01:17:20.560 --> 01:17:21.490
Sorry.

01:17:21.490 --> 01:17:23.420
Oh, yeah, this is a good one.

01:17:23.420 --> 01:17:31.490
I don't know if you're following
me, but if I plug in 1 for x1

01:17:31.490 --> 01:17:35.060
and y for x2--

01:17:35.060 --> 01:17:37.610
do the inputs in the
assignment need to be distinct?

01:17:37.610 --> 01:17:38.860
No.

01:17:38.860 --> 01:17:40.690
It could be the same value.

01:17:40.690 --> 01:17:43.450
I could be 2 and 2 here.

01:17:43.450 --> 01:17:45.360
That's perfectly valid.

01:17:45.360 --> 01:17:47.480
But here, I'm going
to plug in 1 for x1,

01:17:47.480 --> 01:17:50.640
and I'm going to plug
in a variable for x2--

01:17:50.640 --> 01:17:52.100
y.

01:17:52.100 --> 01:17:54.680
And I'm going to do the whole
calculation that I just did.

01:17:54.680 --> 01:17:56.305
And now, what's going
to be the output?

01:17:59.140 --> 01:18:01.870
And I mean, this looks
like a pain to figure out.

01:18:01.870 --> 01:18:02.705
You could do it.

01:18:02.705 --> 01:18:03.580
It looks like a pain.

01:18:03.580 --> 01:18:04.990
But let me give you a big hint.

01:18:08.390 --> 01:18:13.220
Remember that this thing is
supposed to be calculating.

01:18:13.220 --> 01:18:15.575
The original branching program
calculates the exclusive

01:18:15.575 --> 01:18:17.920
or function.

01:18:17.920 --> 01:18:23.170
And that means when I
plug in a Boolean value,

01:18:23.170 --> 01:18:27.400
I should get the exclusive
or value coming out.

01:18:27.400 --> 01:18:31.990
So if I already know that
x1 is 1, which of these

01:18:31.990 --> 01:18:36.850
is consistent with
getting a value

01:18:36.850 --> 01:18:40.615
that the exclusive or
function would compute?

01:18:40.615 --> 01:18:45.030
So let me launch a poll on that.

01:18:45.030 --> 01:18:45.960
So we're out of time.

01:18:50.730 --> 01:18:55.570
So let's just let this run
for another 10 seconds.

01:18:55.570 --> 01:18:58.475
OK, I'm going to close this.

01:18:58.475 --> 01:18:58.975
Ready?

01:19:04.010 --> 01:19:06.370
Yes, indeed, a is
the right answer

01:19:06.370 --> 01:19:09.400
because that's one-- if I know
that one variable is 1, then

01:19:09.400 --> 01:19:12.160
the exclusive or is going
to be the complement

01:19:12.160 --> 01:19:15.050
of the other variable,
which is 1 minus y.

01:19:15.050 --> 01:19:19.590
So that's what you would
get if you calculated this.

01:19:19.590 --> 01:19:21.810
OK, so this is
what we did today.

01:19:21.810 --> 01:19:26.010
And feel free to ask questions.

01:19:26.010 --> 01:19:27.870
So we're going to
spend a good chunk--

01:19:27.870 --> 01:19:30.630
I'll review this, what
we've done so far,

01:19:30.630 --> 01:19:33.270
but then we're going to
carry it forward and spend

01:19:33.270 --> 01:19:35.520
a good chunk of
Tuesday's lecture

01:19:35.520 --> 01:19:38.850
after the Thanksgiving
break proving

01:19:38.850 --> 01:19:42.660
that this procedure that I just
described worked and works.

01:19:42.660 --> 01:19:46.860
And it's an interesting
but somewhat--

01:19:46.860 --> 01:19:49.298
it's not such an easy proof.

01:19:49.298 --> 01:19:50.340
So we're going to spend--

01:19:50.340 --> 01:19:53.340
try to do it slowly and clearly.

01:19:53.340 --> 01:19:55.590
But this notion
of arithmetization

01:19:55.590 --> 01:19:57.990
is going to be--

01:19:57.990 --> 01:20:02.430
it's an important
notion in complexity.

01:20:02.430 --> 01:20:08.550
And so we'll see it again coming
up in another proof afterward

01:20:08.550 --> 01:20:10.710
about interactive proof systems.

01:20:10.710 --> 01:20:14.560
OK, so please ask questions.

01:20:14.560 --> 01:20:19.710
So the output is the value
of the output 1 state, yes.

01:20:19.710 --> 01:20:22.540
There was a question I got.

01:20:22.540 --> 01:20:24.600
Other questions?

01:20:24.600 --> 01:20:28.240
Somebody saying, minus 7
is not the XOR of 2 and 2.

01:20:28.240 --> 01:20:33.590
[LAUGHS] What is
the XOR of 2 and 3?

01:20:33.590 --> 01:20:36.290
So by the way, I should say,
we kind of ran a little short

01:20:36.290 --> 01:20:38.510
on time, I'm not saying
that we discovered

01:20:38.510 --> 01:20:42.950
some fundamental new
truth about XOR here

01:20:42.950 --> 01:20:45.140
because that would be bizarre.

01:20:45.140 --> 01:20:47.480
It really depends on
the arbitrary decision

01:20:47.480 --> 01:20:52.322
that we made to say true
is 1 and false is 0.

01:20:52.322 --> 01:20:54.530
We could have come up with
a different representation

01:20:54.530 --> 01:20:55.680
for true and false.

01:20:55.680 --> 01:20:57.620
And then you would
get a different value

01:20:57.620 --> 01:21:00.650
for XOR coming out of that--
from the arithmetization

01:21:00.650 --> 01:21:03.110
that I just described.

01:21:03.110 --> 01:21:07.250
But for this particular way of
representing true and false,

01:21:07.250 --> 01:21:09.890
that's how XOR and this
particular branching program,

01:21:09.890 --> 01:21:14.060
that's how XOR evaluates.

01:21:14.060 --> 01:21:15.720
The remainder of the proof--

01:21:15.720 --> 01:21:17.990
so somebody is
asking, which is true,

01:21:17.990 --> 01:21:19.710
the fundamental
theorem of algebra,

01:21:19.710 --> 01:21:22.250
which talks about polynomials
and the number of routes

01:21:22.250 --> 01:21:23.438
that you can have--

01:21:23.438 --> 01:21:24.605
that's going to be critical.

01:21:27.360 --> 01:21:29.578
So that is the fundamental
theorem of algebra.

01:21:29.578 --> 01:21:30.620
That's where we're going.

01:21:30.620 --> 01:21:31.280
Good question.

01:21:34.090 --> 01:21:36.010
Somebody is complaining
that we're not

01:21:36.010 --> 01:21:41.020
taking the digit binary
representation of 2 and 3

01:21:41.020 --> 01:21:47.530
and taking the bit by bit XOR.

01:21:47.530 --> 01:21:50.890
Binary representation
is not a part of this.

01:21:50.890 --> 01:21:55.900
We're thinking of these as two
elements of a finite field,

01:21:55.900 --> 01:21:59.050
which we'll talk about later.

01:21:59.050 --> 01:22:03.972
The binary representation is not
entering into this discussion.

01:22:06.690 --> 01:22:10.235
So I'll talk about why just
doing the sum is enough.

01:22:16.320 --> 01:22:18.200
I think that was--

01:22:18.200 --> 01:22:18.830
so why is it--

01:22:18.830 --> 01:22:19.730
I mean, here it is.

01:22:19.730 --> 01:22:23.480
Why is just doing
the sum when I'm

01:22:23.480 --> 01:22:29.000
looking at how to describe
the value of this node

01:22:29.000 --> 01:22:32.060
based upon the values of
all the incoming nodes.

01:22:32.060 --> 01:22:35.120
And remember, the
starting point of this

01:22:35.120 --> 01:22:38.450
is that we have to faithfully
represent the Boolean

01:22:38.450 --> 01:22:42.070
logic with the arithmetic.

01:22:42.070 --> 01:22:44.020
And then we're going to
use that and extend it

01:22:44.020 --> 01:22:45.437
to non-Boolean values.

01:22:45.437 --> 01:22:47.770
But as a starting point, we
have to faithfully represent

01:22:47.770 --> 01:22:49.210
the Boolean values.

01:22:49.210 --> 01:22:52.960
Now the Boolean values,
on the incoming edges,

01:22:52.960 --> 01:22:57.970
at most, one of them can
be a 1 because the 1's

01:22:57.970 --> 01:23:04.240
correspond to the edges
of the execution path.

01:23:04.240 --> 01:23:07.450
And you can't make an
execution path that's

01:23:07.450 --> 01:23:10.365
going to have two branches--

01:23:10.365 --> 01:23:11.740
that's going to
go through a node

01:23:11.740 --> 01:23:14.170
twice because then
you have a loop.

01:23:14.170 --> 01:23:17.520
And we don't have--
there's no cycles allowed.

01:23:17.520 --> 01:23:22.230
OK, so I think
we're-- it's at 4:00.

01:23:22.230 --> 01:23:23.850
I want to say
farewell to you all.

01:23:23.850 --> 01:23:25.800
Have a great week.

01:23:25.800 --> 01:23:29.120
And I'll see you
when you get back.