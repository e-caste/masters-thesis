WEBVTT

00:00:00.000 --> 00:00:02.450
[SQUEAKING]

00:00:02.450 --> 00:00:04.410
[RUSTLING]

00:00:04.410 --> 00:00:05.880
[CLICKING]

00:00:25.030 --> 00:00:28.220
MICHAEL SIPSER: Why
don't we get started.

00:00:28.220 --> 00:00:31.270
So as I like to do,
let's just review

00:00:31.270 --> 00:00:34.780
where we have been
recently, which

00:00:34.780 --> 00:00:41.020
is to discuss
context-free languages.

00:00:41.020 --> 00:00:44.020
We talked about the context-free
grammars and the pushdown

00:00:44.020 --> 00:00:49.210
automata as a way of describing
the context-free languages.

00:00:49.210 --> 00:00:52.540
As you remember, the
context-free languages

00:00:52.540 --> 00:00:55.643
are a larger class of languages
than the regular languages,

00:00:55.643 --> 00:00:57.310
which is where we
started, the languages

00:00:57.310 --> 00:00:58.400
of the finite automata.

00:00:58.400 --> 00:01:00.910
So when you add a stack,
you get more power.

00:01:00.910 --> 00:01:03.700
You get more languages
that you can do.

00:01:06.860 --> 00:01:09.890
And we're very rapidly
going to be moving on today

00:01:09.890 --> 00:01:13.130
to our main model for
the semester, which

00:01:13.130 --> 00:01:14.730
is called the Turing machine.

00:01:14.730 --> 00:01:18.200
So let's just take
a look at what we're

00:01:18.200 --> 00:01:19.790
going to be covering today.

00:01:19.790 --> 00:01:24.110
And that is, first,
we're going to show

00:01:24.110 --> 00:01:30.470
that a technique analogous
to the one we use for proving

00:01:30.470 --> 00:01:33.470
that languages are not regular,
but this time for proving

00:01:33.470 --> 00:01:35.630
languages are not context-free.

00:01:35.630 --> 00:01:38.390
So the pushdown
automata and the grammar

00:01:38.390 --> 00:01:41.270
still have their limitations
in terms of what we normally

00:01:41.270 --> 00:01:43.590
think a computer can do.

00:01:43.590 --> 00:01:46.370
And with that, we're going to
use that as a kind of a lead-in

00:01:46.370 --> 00:01:51.320
to our general-purpose model,
which is the Turing machine.

00:01:51.320 --> 00:01:56.290
And so we're going
to talk about Turing

00:01:56.290 --> 00:02:03.260
machines and aspects of that.

00:02:03.260 --> 00:02:05.030
I would want to comment--

00:02:05.030 --> 00:02:08.820
so I have posted the solutions
for the first problem set.

00:02:08.820 --> 00:02:11.320
I know you're starting to think
about the second problem set

00:02:11.320 --> 00:02:14.980
now, which I have
posted as well.

00:02:14.980 --> 00:02:17.500
If you want to get a sense of
what I'm looking for in terms

00:02:17.500 --> 00:02:20.290
of the level of detail, you
can look at the solutions

00:02:20.290 --> 00:02:22.120
to problem set one,
because I consider

00:02:22.120 --> 00:02:23.630
those to be model solutions.

00:02:23.630 --> 00:02:25.733
That's part of the reason
why I post them, just

00:02:25.733 --> 00:02:28.400
to give you a sense of the level
of detail that I'm looking for,

00:02:28.400 --> 00:02:29.600
which is not a whole lot.

00:02:29.600 --> 00:02:31.630
But I do want to
make sure you're

00:02:31.630 --> 00:02:35.560
capturing the main
ideas of what's involved

00:02:35.560 --> 00:02:37.620
in solving the problem.

00:02:37.620 --> 00:02:40.220
So have a look at those.

00:02:40.220 --> 00:02:44.992
And for problem set two, which
I'll talk about in a second--

00:02:44.992 --> 00:02:46.200
so I'll just say a few words.

00:02:46.200 --> 00:02:49.603
If you want to pull that
up, you can do that.

00:02:49.603 --> 00:02:51.770
But just to get you started
on a few of the problems

00:02:51.770 --> 00:02:54.530
if you're finding some
challenges there--

00:02:54.530 --> 00:02:56.300
I don't want you
to get stuck really

00:02:56.300 --> 00:02:59.630
before you even understand
what the problem is saying.

00:02:59.630 --> 00:03:02.697
So for problem number one,
if you looked at that,

00:03:02.697 --> 00:03:04.280
so that's a problem
where you're asked

00:03:04.280 --> 00:03:08.930
to prove a certain language
is not context free.

00:03:08.930 --> 00:03:11.720
And by the way, all of the
problems in this problem set

00:03:11.720 --> 00:03:15.500
except perhaps for the
last, for number six,

00:03:15.500 --> 00:03:16.850
you'll be able to solve.

00:03:16.850 --> 00:03:19.340
We'll have enough material
at the end of today's lecture

00:03:19.340 --> 00:03:21.750
to solve all of them.

00:03:21.750 --> 00:03:25.040
I believe that's right.

00:03:25.040 --> 00:03:27.020
Yeah, so number
six, you should have

00:03:27.020 --> 00:03:31.020
enough as of Thursday's
lecture to solve that.

00:03:31.020 --> 00:03:37.850
So problem number one,
it's proving a language

00:03:37.850 --> 00:03:38.870
is not context free.

00:03:38.870 --> 00:03:41.037
So we're going to introduce
a method for doing that.

00:03:41.037 --> 00:03:43.160
That method is going
to come in handy.

00:03:43.160 --> 00:03:46.400
For parts B and C, if you
look at the problem set,

00:03:46.400 --> 00:03:48.830
it has this strange-looking
thing, sigma sigma

00:03:48.830 --> 00:03:50.930
sigma in parenthesis star.

00:03:50.930 --> 00:03:55.308
It's really just a regular
expression that's very simple.

00:03:55.308 --> 00:03:56.975
You should just make
sure you understand

00:03:56.975 --> 00:04:00.890
that that's a way of
representing all strings whose

00:04:00.890 --> 00:04:04.070
length is a multiple of 3.

00:04:04.070 --> 00:04:06.710
And if I stick a sigma
in front of that,

00:04:06.710 --> 00:04:12.560
it's all strings whose length
is 1 plus a multiple of 3.

00:04:12.560 --> 00:04:16.880
So once you understand
that, and if you

00:04:16.880 --> 00:04:20.420
think about what kinds of
strings are in the language C2,

00:04:20.420 --> 00:04:22.460
it'll help you to
understand what happens

00:04:22.460 --> 00:04:24.470
when you take those unions.

00:04:24.470 --> 00:04:29.300
And parts B and C are not
intended to be very hard,

00:04:29.300 --> 00:04:32.540
but you just have to
understand what's going on.

00:04:32.540 --> 00:04:34.850
Problem number two is
about ambiguous grammars.

00:04:34.850 --> 00:04:38.310
I touched on that
briefly in lecture.

00:04:38.310 --> 00:04:40.580
It's enough to
solve the problem.

00:04:40.580 --> 00:04:42.200
The book has a little
bit more detail

00:04:42.200 --> 00:04:48.470
about ambiguous languages,
ambiguous grammars--

00:04:48.470 --> 00:04:51.510
ambiguous grammars,
I should say.

00:04:51.510 --> 00:04:55.040
And so this is a
grammar that's supposed

00:04:55.040 --> 00:04:58.580
to represent a fragment
of a programming language

00:04:58.580 --> 00:05:03.140
with if thens and if then elses.

00:05:03.140 --> 00:05:06.860
I'm sure you're all familiar
with those kinds of constructs

00:05:06.860 --> 00:05:09.200
in programming languages.

00:05:09.200 --> 00:05:12.140
And there is a natural
ambiguity that comes up

00:05:12.140 --> 00:05:13.730
in a programming language.

00:05:13.730 --> 00:05:18.500
If you have if some
condition then statement one,

00:05:18.500 --> 00:05:20.240
else statement
two, I presume you

00:05:20.240 --> 00:05:24.320
understand what the semantics
of that is, what that means.

00:05:24.320 --> 00:05:27.210
And the tricky thing
is that if you have--

00:05:27.210 --> 00:05:29.660
those statements can
themselves be if statements.

00:05:29.660 --> 00:05:34.460
And so if you have the
situation where you have if then

00:05:34.460 --> 00:05:39.930
and if then else is what
follows that, the question is,

00:05:39.930 --> 00:05:41.120
where does the else attach?

00:05:41.120 --> 00:05:43.790
Is it to the second
if or to the first if?

00:05:43.790 --> 00:05:46.715
So that's kind of a big hint
on this problem, but that's OK.

00:05:52.680 --> 00:05:55.040
You need to take
that and figure out

00:05:55.040 --> 00:05:58.340
how to get an actual member
of the language which

00:05:58.340 --> 00:06:02.240
is ambiguously generated,
and then show that it has--

00:06:02.240 --> 00:06:07.070
show that it is by showing
two parse trees or two

00:06:07.070 --> 00:06:07.953
leftmost derivations.

00:06:07.953 --> 00:06:10.370
If you read the book, you'll
see that's an alternative way

00:06:10.370 --> 00:06:12.960
of representing a parse tree.

00:06:12.960 --> 00:06:15.740
So and then what
you're supposed to do

00:06:15.740 --> 00:06:20.213
is give a grammar for the same
language which is unambiguous.

00:06:20.213 --> 00:06:22.130
You don't have to prove
that it's unambiguous,

00:06:22.130 --> 00:06:23.463
because that's a bit of a chore.

00:06:23.463 --> 00:06:25.490
But as long as you
understand what's going on,

00:06:25.490 --> 00:06:28.160
you should be able to come up
with an unambiguous grammar

00:06:28.160 --> 00:06:30.530
which resolves that ambiguity.

00:06:30.530 --> 00:06:33.140
And I don't have in mind
changing the language

00:06:33.140 --> 00:06:36.170
by introducing new
programming language

00:06:36.170 --> 00:06:38.930
constructs like a "begin end."

00:06:38.930 --> 00:06:40.670
That's not in the
spirit of this problem,

00:06:40.670 --> 00:06:43.160
because that's a
different-- it's grammar

00:06:43.160 --> 00:06:44.400
for a different language.

00:06:44.400 --> 00:06:47.240
So you need to be
generating the same language

00:06:47.240 --> 00:06:50.000
without any other extraneous
things going on that are

00:06:50.000 --> 00:06:51.428
going to resolve the ambiguity.

00:06:51.428 --> 00:06:53.720
The ambiguity needs to be
resolved within the structure

00:06:53.720 --> 00:06:55.860
of the grammar itself.

00:06:55.860 --> 00:06:58.570
So keep that in mind.

00:06:58.570 --> 00:07:01.900
For problem number three
about the queue automata,

00:07:01.900 --> 00:07:06.070
you know, that came up actually
as a suggestion last lecture,

00:07:06.070 --> 00:07:07.810
I believe, or two lectures back.

00:07:07.810 --> 00:07:10.750
What happens if you take a
pushdown automaton, but instead

00:07:10.750 --> 00:07:12.520
of a pushdown--

00:07:12.520 --> 00:07:15.520
instead of a stack,
you add a queue.

00:07:15.520 --> 00:07:16.527
What happens then?

00:07:16.527 --> 00:07:18.610
Well actually, it turns
out that the model you get

00:07:18.610 --> 00:07:19.350
is very powerful.

00:07:19.350 --> 00:07:21.100
And it turns out to
be equivalent in power

00:07:21.100 --> 00:07:22.280
to a Turing machine.

00:07:22.280 --> 00:07:24.130
So you'll see
arguments of that kind

00:07:24.130 --> 00:07:28.820
today, how you show that other
models are equivalent-- no, not

00:07:28.820 --> 00:07:29.320
today.

00:07:33.460 --> 00:07:34.660
So I apologize.

00:07:34.660 --> 00:07:38.080
This is going to be
something that you'll--

00:07:38.080 --> 00:07:41.320
I'm confusing myself here.

00:07:41.320 --> 00:07:43.870
Problem number three actually
needs Thursday's lecture

00:07:43.870 --> 00:07:47.347
as well to really at
least see examples of how

00:07:47.347 --> 00:07:48.430
you do that kind of thing.

00:07:54.490 --> 00:07:58.270
Yeah, so I'll try to send
out a note clarifying this.

00:07:58.270 --> 00:08:01.030
By the end of Thursday, you'll
be able to do everything,

00:08:01.030 --> 00:08:02.530
except for problem six.

00:08:02.530 --> 00:08:05.560
And for problem six, you'll
need Tuesday's lecture, a week

00:08:05.560 --> 00:08:06.730
from today's lecture, to do.

00:08:11.840 --> 00:08:15.980
So problem number
four, that one you'll

00:08:15.980 --> 00:08:18.200
be able to do at
the end of today.

00:08:18.200 --> 00:08:19.670
That's also going
to-- the problem

00:08:19.670 --> 00:08:22.543
is I'm working on preparing
Thursday's lecture too.

00:08:22.543 --> 00:08:23.585
So I'm getting a little--

00:08:23.585 --> 00:08:25.402
I'm confusing myself.

00:08:25.402 --> 00:08:27.110
Problem number four,
you'll be able to do

00:08:27.110 --> 00:08:28.152
after Thursday's lecture.

00:08:28.152 --> 00:08:33.470
Maybe we should talk
about that next lecture.

00:08:33.470 --> 00:08:39.620
Problem number five,
you can do today,

00:08:39.620 --> 00:08:41.913
but maybe I'm not going to
say anything about that.

00:08:41.913 --> 00:08:44.330
And problem number six, I won't
say anything about either.

00:08:44.330 --> 00:08:46.850
OK, so why don't we
just jump in then

00:08:46.850 --> 00:08:49.920
and look at today's material.

00:08:49.920 --> 00:08:52.490
What about seven?

00:08:52.490 --> 00:08:54.410
Oh, seven is an
optional problem.

00:08:54.410 --> 00:08:56.270
Oh, I should have
mentioned that.

00:08:56.270 --> 00:08:58.020
Seven is always going
to be an option.

00:08:58.020 --> 00:08:59.810
I indicate that
with a star I should

00:08:59.810 --> 00:09:03.260
have made that clear on the
actual description here,

00:09:03.260 --> 00:09:04.980
but seven is optional.

00:09:04.980 --> 00:09:06.860
It's just like we had
for problem set one.

00:09:09.382 --> 00:09:10.840
OK, let's move
let's move on, then,

00:09:10.840 --> 00:09:14.830
to what we're going
to talk about today.

00:09:14.830 --> 00:09:17.750
And just a little
bit of review--

00:09:17.750 --> 00:09:19.900
so we talked about
the equivalence

00:09:19.900 --> 00:09:22.600
of context-free grammars
and pushdown automata,

00:09:22.600 --> 00:09:23.380
as you remember.

00:09:23.380 --> 00:09:27.190
Oops, let me get myself
out of the picture here.

00:09:27.190 --> 00:09:29.620
As we mentioned last
time, we actually proved

00:09:29.620 --> 00:09:32.033
one direction, but the
other direction of that,

00:09:32.033 --> 00:09:33.700
you just have to know
it's true, but you

00:09:33.700 --> 00:09:34.908
don't have to know the proof.

00:09:34.908 --> 00:09:36.910
The proof is a little
bit lengthy, I would say.

00:09:36.910 --> 00:09:40.420
It's a nice proof,
but it's pretty long.

00:09:40.420 --> 00:09:46.398
And there are two important
corollaries to that.

00:09:46.398 --> 00:09:47.940
If you know what a
corollary is, it's

00:09:47.940 --> 00:09:49.770
just a simple
consequence which doesn't

00:09:49.770 --> 00:09:52.410
need much of a
proof, sort of a very

00:09:52.410 --> 00:09:54.060
straightforward consequence.

00:09:54.060 --> 00:09:58.030
First of all, I think we
pointed out last time,

00:09:58.030 --> 00:10:00.120
one conclusion, one
corollary you get

00:10:00.120 --> 00:10:03.240
is that every regular language
is a context-free language,

00:10:03.240 --> 00:10:10.110
because a finite automaton is
a pushdown automaton that just

00:10:10.110 --> 00:10:12.150
happens not to use its stack.

00:10:12.150 --> 00:10:15.630
So immediately, you get that
every language is context free.

00:10:15.630 --> 00:10:19.770
And second of all, you
also immediately get

00:10:19.770 --> 00:10:24.000
that whenever you have
a context-free language

00:10:24.000 --> 00:10:27.830
and a regular language and
you take their intersection,

00:10:27.830 --> 00:10:31.770
you get back a
context-free language.

00:10:31.770 --> 00:10:36.960
So context free intersect
regular is context free.

00:10:36.960 --> 00:10:40.020
That's actually mentioned in
your homework as well as one

00:10:40.020 --> 00:10:45.960
of the 0.x problems which
I give to try to get you--

00:10:45.960 --> 00:10:48.840
you don't have to turn those in,
but I suggest you look at them.

00:10:48.840 --> 00:10:50.890
I don't know how many of
you are looking at them.

00:10:50.890 --> 00:10:52.980
But this is a useful fact.

00:10:52.980 --> 00:10:57.250
And some of those other facts
in 0.x problems are useful.

00:10:57.250 --> 00:10:59.700
So I encourage you
to look at them.

00:10:59.700 --> 00:11:02.790
But anyway, intersection
of context free and regular

00:11:02.790 --> 00:11:04.060
is context free.

00:11:04.060 --> 00:11:06.450
You might ask, what about
intersection of context

00:11:06.450 --> 00:11:08.070
free and context free?

00:11:08.070 --> 00:11:09.990
Do we have closure
under intersection?

00:11:09.990 --> 00:11:12.570
The answer is, no,
we do not have close

00:11:12.570 --> 00:11:14.340
to closure under intersection.

00:11:14.340 --> 00:11:16.330
We'll talk about that shortly.

00:11:16.330 --> 00:11:19.800
So here is the
proof sketch for--

00:11:19.800 --> 00:11:22.170
I wanted to say that the
intersection of context

00:11:22.170 --> 00:11:25.260
free and regular, why do we
know that's still context free?

00:11:25.260 --> 00:11:30.990
Because the pushdown
automaton for A

00:11:30.990 --> 00:11:34.080
can be simulating
the finite automaton

00:11:34.080 --> 00:11:40.020
for B inside its finite control,
inside its finite memory.

00:11:40.020 --> 00:11:42.690
The problem is, if you have
two context-free languages,

00:11:42.690 --> 00:11:44.760
you have two pushdown
automata, you

00:11:44.760 --> 00:11:47.190
can't simulate that with
one pushdown automaton,

00:11:47.190 --> 00:11:49.925
because it has only
a single stack.

00:11:49.925 --> 00:11:52.050
So if you're trying to take
the intersection of two

00:11:52.050 --> 00:11:55.440
context-free languages
with only a single stack,

00:11:55.440 --> 00:11:58.470
you're going to be in trouble,
because it's hard to--

00:11:58.470 --> 00:12:00.878
anyway, that's not a
proof, but at least it

00:12:00.878 --> 00:12:03.420
shows you what goes wrong if
you try to do the obvious thing.

00:12:06.220 --> 00:12:14.738
OK, so if-- and just,
here is an important point

00:12:14.738 --> 00:12:16.030
that was trying to make before.

00:12:16.030 --> 00:12:18.010
If A and B are both
context free and you're

00:12:18.010 --> 00:12:22.060
taking the intersection, the
result may not necessarily

00:12:22.060 --> 00:12:24.770
be a context-free language.

00:12:24.770 --> 00:12:26.860
So the class of
context-free languages

00:12:26.860 --> 00:12:28.570
is not closed under
its intersection.

00:12:28.570 --> 00:12:31.060
We'll comment on that in a bit.

00:12:34.590 --> 00:12:38.000
The context-free languages
are closed under the regular

00:12:38.000 --> 00:12:40.790
operations, however,
union, intersection--

00:12:40.790 --> 00:12:42.560
union, concatenation, and star.

00:12:42.560 --> 00:12:45.210
So you should feel
comfortable that you

00:12:45.210 --> 00:12:47.300
know how to prove that.

00:12:47.300 --> 00:12:50.240
Again, it's one of the--

00:12:50.240 --> 00:12:52.333
I think it's problem 0.2.

00:12:52.333 --> 00:12:54.750
And I think the solution is
even given in the book for it.

00:12:54.750 --> 00:12:58.610
So you just should
know how to prove that.

00:12:58.610 --> 00:13:00.710
It's pretty straightforward.

00:13:00.710 --> 00:13:08.750
OK, so let's move on then
to basically conclude

00:13:08.750 --> 00:13:12.170
our work on
context-free languages,

00:13:12.170 --> 00:13:17.600
to understand the limitations
of context-free grammars,

00:13:17.600 --> 00:13:21.227
and what kinds of languages
may not be context free.

00:13:21.227 --> 00:13:22.310
And how do you prove that?

00:13:22.310 --> 00:13:24.290
So how do you prove
that, for some language,

00:13:24.290 --> 00:13:26.660
there is no grammar?

00:13:26.660 --> 00:13:28.310
Again, you know,
it's not enough just

00:13:28.310 --> 00:13:36.880
to, say, give an informal
comment that, I couldn't

00:13:36.880 --> 00:13:38.837
think of a grammar, or some--

00:13:38.837 --> 00:13:39.670
things of that kind.

00:13:39.670 --> 00:13:41.128
That's not going
to be good enough.

00:13:41.128 --> 00:13:42.600
We need to have a proof.

00:13:42.600 --> 00:13:46.355
So if we take the language
here, 0 to the k, 1 to the k,

00:13:46.355 --> 00:13:48.650
2 to the k, so those
are strings which

00:13:48.650 --> 00:13:51.350
are runs of 0's followed
by an equal number of 1's

00:13:51.350 --> 00:13:54.320
followed by an equal
number of 2's, so just 0's,

00:13:54.320 --> 00:13:58.920
then 1's, then 2's,
all the same length.

00:13:58.920 --> 00:14:01.020
That's a language
which is not going

00:14:01.020 --> 00:14:02.270
to be a context-free language.

00:14:02.270 --> 00:14:05.700
And we'll give a method
for proving that.

00:14:05.700 --> 00:14:10.110
If you had a stack, you can
match the 1's with the 0's, but

00:14:10.110 --> 00:14:12.900
then once you're done with
that, the stack is empty.

00:14:12.900 --> 00:14:16.380
And how do you now make
sure that the number of 2's

00:14:16.380 --> 00:14:18.670
corresponds to the number
of 1's that you had?

00:14:18.670 --> 00:14:21.060
So again, that's an
informal argument

00:14:21.060 --> 00:14:23.980
that's not good
enough to be a proof,

00:14:23.980 --> 00:14:26.220
but it sort of
gives an intuition.

00:14:26.220 --> 00:14:32.670
So we're going to give a method
for proving non-context-free--

00:14:32.670 --> 00:14:38.130
languages are not context free
using, again, a pumping lemma.

00:14:38.130 --> 00:14:40.290
But this is going to
be a pumping lemma that

00:14:40.290 --> 00:14:41.910
applies to
context-free language,

00:14:41.910 --> 00:14:43.720
not to regular languages.

00:14:43.720 --> 00:14:46.320
It looks very similar, but
it has some extra wrinkles

00:14:46.320 --> 00:14:50.640
thrown in, because the other
older pumping lemma was

00:14:50.640 --> 00:14:52.203
specific to the
regular languages.

00:14:52.203 --> 00:14:54.120
And this is going to be
something that applies

00:14:54.120 --> 00:14:56.900
to the context-free languages.

00:14:56.900 --> 00:14:59.930
OK, so now let's just read it.

00:14:59.930 --> 00:15:03.480
And then we'll try to
interpret it again.

00:15:03.480 --> 00:15:04.910
It's very similar in spirit.

00:15:04.910 --> 00:15:06.470
Basically, it says
that, whenever

00:15:06.470 --> 00:15:08.150
you have a
context-free language,

00:15:08.150 --> 00:15:10.850
all long strings
in the language can

00:15:10.850 --> 00:15:13.428
be pumped in some kind of way.

00:15:13.428 --> 00:15:15.220
So it's going to be a
little different kind

00:15:15.220 --> 00:15:17.890
of pumping than we had before.

00:15:17.890 --> 00:15:20.360
And you stay in the language.

00:15:20.360 --> 00:15:25.540
OK, so before, we broke the
string into three pieces

00:15:25.540 --> 00:15:28.510
where we could repeat that
centerpiece as many times

00:15:28.510 --> 00:15:29.890
as you like.

00:15:29.890 --> 00:15:31.210
And you stay in the language.

00:15:31.210 --> 00:15:32.740
Here, we're going
to end up breaking

00:15:32.740 --> 00:15:36.140
the string into five pieces.

00:15:36.140 --> 00:15:38.005
So s is going to be
broken up into uvxyz.

00:15:45.604 --> 00:15:48.910
And the way it's going to work
here-- so here is a picture.

00:15:48.910 --> 00:15:50.605
So all long strings--
again, there

00:15:50.605 --> 00:15:51.752
is going to be a threshold.

00:15:51.752 --> 00:15:53.335
So whenever you have
a language, there

00:15:53.335 --> 00:15:55.630
is going to be some
cut-off length.

00:15:55.630 --> 00:15:58.472
So all the longer strings in
that language can be pumped.

00:15:58.472 --> 00:15:59.680
And you stay in the language.

00:15:59.680 --> 00:16:02.995
But the shorter strings,
there is no guarantee.

00:16:02.995 --> 00:16:05.620
So if you have a long string in
the language of length at least

00:16:05.620 --> 00:16:08.440
this pumping length p,
then you can break it up

00:16:08.440 --> 00:16:09.710
into five pieces.

00:16:09.710 --> 00:16:14.770
But now it's that second
and fourth string that

00:16:14.770 --> 00:16:19.630
are going to play that special
pumping role, which means that,

00:16:19.630 --> 00:16:24.200
what you can do is
you can repeat those

00:16:24.200 --> 00:16:26.660
and you stay in the language.

00:16:26.660 --> 00:16:28.280
And it's important
that you repeat

00:16:28.280 --> 00:16:31.557
them both, that v and that
y, the same number of times.

00:16:31.557 --> 00:16:33.140
So you're going to
have a picture that

00:16:33.140 --> 00:16:35.870
looks something like this.

00:16:35.870 --> 00:16:39.480
And that is going to you repeat.

00:16:42.430 --> 00:16:44.935
If you repeat the v and you
repeat the y, you get uvvxyyz.

00:16:48.580 --> 00:16:50.545
Or if you look at
over here, it would

00:16:50.545 --> 00:16:54.820
be uv squared xy squared z.

00:16:54.820 --> 00:16:58.500
And that's going to
still be in the language.

00:16:58.500 --> 00:17:00.080
And then we have--

00:17:00.080 --> 00:17:01.080
so that's one condition.

00:17:01.080 --> 00:17:02.955
We'll have to look at
all of these conditions

00:17:02.955 --> 00:17:04.380
when we do the
proof, but we just

00:17:04.380 --> 00:17:06.505
want to understand what
the statement is right now.

00:17:06.505 --> 00:17:10.589
So the second condition is
that v and y together cannot be

00:17:10.589 --> 00:17:11.310
empty.

00:17:11.310 --> 00:17:13.859
And really, that's another
way of saying, they can't both

00:17:13.859 --> 00:17:15.869
be the empty string,
because if they

00:17:15.869 --> 00:17:17.940
were both the empty
string, then repeating

00:17:17.940 --> 00:17:21.297
them wouldn't change s.

00:17:21.297 --> 00:17:23.339
And then of course it
would stay in the language.

00:17:23.339 --> 00:17:24.839
So it would be
kind of meaningless

00:17:24.839 --> 00:17:26.880
if they were
allowed to be empty.

00:17:26.880 --> 00:17:28.380
And the last thing
is, again, going

00:17:28.380 --> 00:17:30.930
to be there as a
matter of convenience

00:17:30.930 --> 00:17:37.980
for proving languages are not
context free, because you have

00:17:37.980 --> 00:17:40.710
to make sure there is no
possible way of cutting up

00:17:40.710 --> 00:17:41.652
the string.

00:17:41.652 --> 00:17:44.110
When you're trying to prove a
language is not context free,

00:17:44.110 --> 00:17:45.568
you have to show
the pumping fails.

00:17:48.690 --> 00:17:51.240
It's going to be
helpful sometimes

00:17:51.240 --> 00:17:54.060
to limit the ways in which
the string can be cut up,

00:17:54.060 --> 00:17:55.290
because then you have--

00:17:55.290 --> 00:17:58.690
it's an easier job for
you to work with it.

00:17:58.690 --> 00:18:00.660
So here, it's a little
different than before,

00:18:00.660 --> 00:18:06.040
but sort of similar, that
vxy combine as a substring.

00:18:06.040 --> 00:18:07.900
So I show that over here.

00:18:07.900 --> 00:18:12.600
vxy together is not too long.

00:18:12.600 --> 00:18:15.570
So the vxy-- maybe it's
better seen up here--

00:18:15.570 --> 00:18:18.240
is going to be, at most, p.

00:18:18.240 --> 00:18:21.000
We'll do an example in
a minute of using this.

00:18:21.000 --> 00:18:23.640
OK, so again, here
is our pumping lemma.

00:18:23.640 --> 00:18:25.020
I've just restated it.

00:18:25.020 --> 00:18:29.240
So we have it in front of us.

00:18:29.240 --> 00:18:31.078
And we're going to do a proof.

00:18:31.078 --> 00:18:33.370
I'm just going to give you
the idea of the proof first.

00:18:33.370 --> 00:18:35.287
And then we'll go through
some of the details.

00:18:35.287 --> 00:18:39.270
The idea is actually
pretty simple.

00:18:39.270 --> 00:18:41.060
We give it-- call it
a proof by picture.

00:18:43.953 --> 00:18:45.620
Again, remember what
we're trying to do.

00:18:45.620 --> 00:18:48.700
We're trying to show that we
have this context-free language

00:18:48.700 --> 00:18:55.240
A. And now all long strings in
A have this pumping quality,

00:18:55.240 --> 00:18:58.750
that you can break them
up into five pieces so

00:18:58.750 --> 00:19:01.880
that the second and the
fourth piece can be repeated.

00:19:01.880 --> 00:19:04.900
And you stay in the language.

00:19:04.900 --> 00:19:07.450
So how do we know that
that's going to be true?

00:19:07.450 --> 00:19:08.950
Let's take a look
at the proof here.

00:19:08.950 --> 00:19:11.270
And why is that
going to be true?

00:19:11.270 --> 00:19:16.100
So first of all, I'd like to
do it qualitatively rather

00:19:16.100 --> 00:19:17.280
than quantitatively.

00:19:17.280 --> 00:19:20.210
So let's just imagine,
instead of thinking-- we'll

00:19:20.210 --> 00:19:21.740
calculate what p is later.

00:19:21.740 --> 00:19:25.623
But just imagine that s is some
really, really long string.

00:19:25.623 --> 00:19:27.290
That's the way I like
to think about it.

00:19:27.290 --> 00:19:29.110
So s is just really long.

00:19:29.110 --> 00:19:31.480
What is that going to tell us?

00:19:31.480 --> 00:19:37.120
It's going to tell us something
important about the way

00:19:37.120 --> 00:19:41.980
the grammar produces s, which
is going to be useful in getting

00:19:41.980 --> 00:19:45.240
a way of pumping it.

00:19:45.240 --> 00:19:49.110
So if s is really
long, we're going

00:19:49.110 --> 00:19:50.880
to look at the parse tree for s.

00:19:50.880 --> 00:19:53.580
And we're going to conclude
that the parse tree has

00:19:53.580 --> 00:19:58.300
to be really tall, because
it's impossible for a very

00:19:58.300 --> 00:20:03.880
shallow parse tree to
generate a very long string.

00:20:03.880 --> 00:20:05.930
And again, we'll quantify
that in a second.

00:20:05.930 --> 00:20:07.840
But intuitively,
I think that's not

00:20:07.840 --> 00:20:10.430
too hard to see why
that ought to be true.

00:20:10.430 --> 00:20:13.390
So if you have a long
s, the parse tree

00:20:13.390 --> 00:20:16.090
has to be really tall,
because the parse tree can't

00:20:16.090 --> 00:20:18.040
generate very many--
it can't expand

00:20:18.040 --> 00:20:20.603
by very much at each level.

00:20:20.603 --> 00:20:22.270
So we'll look at how
much it can expand.

00:20:22.270 --> 00:20:25.390
But it depends on the
grammar, how much expansion

00:20:25.390 --> 00:20:26.660
have at each level.

00:20:26.660 --> 00:20:30.250
And it's going to be-- you
can't have just in three levels

00:20:30.250 --> 00:20:34.030
some small grammar generating
a string of length 1 million.

00:20:34.030 --> 00:20:37.480
You'll see that that's
just impossible.

00:20:37.480 --> 00:20:43.710
So once you know that the
parse tree is really tall here,

00:20:43.710 --> 00:20:47.908
then you're actually
almost done, because what

00:20:47.908 --> 00:20:49.200
does it mean to be really tall?

00:20:49.200 --> 00:20:52.800
It means that there is some path
starting at the start variable

00:20:52.800 --> 00:20:57.240
E, I'm calling it in this
parse tree, which goes down

00:20:57.240 --> 00:21:04.500
to some terminal symbol in s,
which goes through many steps.

00:21:04.500 --> 00:21:06.960
That's what it means for
the tree to be very tall.

00:21:06.960 --> 00:21:09.930
And each one of those
steps is a variable

00:21:09.930 --> 00:21:13.930
until you get down
to the very end.

00:21:13.930 --> 00:21:15.850
OK, so that's the
way parse trees look.

00:21:15.850 --> 00:21:19.490
You keep expanding variables
until you get to a terminal.

00:21:19.490 --> 00:21:25.130
So here, you get some path
that's really a long path.

00:21:25.130 --> 00:21:27.410
And once you have
a long path that

00:21:27.410 --> 00:21:30.270
has many, many variables
appearing on here,

00:21:30.270 --> 00:21:33.320
well, the grammar itself
has only some fixed number

00:21:33.320 --> 00:21:35.120
of variables in
it, so you're going

00:21:35.120 --> 00:21:39.800
to have to have a repetition
coming among the variables that

00:21:39.800 --> 00:21:41.330
occur on that long path.

00:21:44.610 --> 00:21:45.780
Got that?

00:21:45.780 --> 00:21:49.600
So a long string forces
a tall parse tree,

00:21:49.600 --> 00:21:53.610
forces a repetition on
some path coming out

00:21:53.610 --> 00:22:00.120
of the start variable of some
other variable that comes out.

00:22:00.120 --> 00:22:03.840
Now that's going to
tell us how to cut up s,

00:22:03.840 --> 00:22:06.570
because if you look
at the subtrees of s

00:22:06.570 --> 00:22:13.430
that those two R variables are
generating, shown like this,

00:22:13.430 --> 00:22:15.270
I'm going to use that--

00:22:15.270 --> 00:22:17.130
so you have to follow
what I'm saying here.

00:22:17.130 --> 00:22:21.170
So R here is generating
this portion of s.

00:22:21.170 --> 00:22:24.260
And the lower R is generating
a smaller portion of s,

00:22:24.260 --> 00:22:27.980
just looking at the
subtree that you get here.

00:22:27.980 --> 00:22:34.260
And that's going to tell us that
we can cut up s accordingly.

00:22:34.260 --> 00:22:38.280
So u was that very first
part out here generated

00:22:38.280 --> 00:22:41.670
by E, but not by the
first R. R is generated--

00:22:41.670 --> 00:22:44.910
v is generated by the first
R, but not by the second R.

00:22:44.910 --> 00:22:47.310
The second R
generates exactly x.

00:22:47.310 --> 00:22:52.040
And then we have y
and z, similarly.

00:22:52.040 --> 00:22:57.200
So that all follows from
having a tall parse tree.

00:22:57.200 --> 00:22:58.700
And now we're finished.

00:22:58.700 --> 00:23:00.330
Now we know how to cut up s.

00:23:00.330 --> 00:23:04.880
How do we know we
can repeat v and y

00:23:04.880 --> 00:23:06.290
and still be in the language?

00:23:06.290 --> 00:23:09.050
Well, I'll actually show you
that you're in the language

00:23:09.050 --> 00:23:11.795
by exhibiting a parse tree
for the string uvvxyyz.

00:23:14.450 --> 00:23:15.260
Here it is.

00:23:17.840 --> 00:23:22.850
I'm going to get that parse tree
by, when I expand this lower R,

00:23:22.850 --> 00:23:25.010
instead of expanding
it to get x,

00:23:25.010 --> 00:23:28.700
I'm going to follow the same
substitutions that I had when

00:23:28.700 --> 00:23:33.035
I expanded the upper R. So
it's as if I took this larger

00:23:33.035 --> 00:23:38.900
subtree here and I substituted
it in for the smaller subtree

00:23:38.900 --> 00:23:42.260
under the second R. And so I get
a picture that looks like this.

00:23:45.480 --> 00:23:49.710
So here I'm substituting under
the second R the same subtree

00:23:49.710 --> 00:23:54.290
that I had originally coming
out of the upper R, the first R.

00:23:54.290 --> 00:23:59.770
And so now this parse tree is
generating the string uvvxyyz,

00:23:59.770 --> 00:24:01.020
which is what I'm looking for.

00:24:01.020 --> 00:24:03.230
And of course, you can
do that again and again.

00:24:03.230 --> 00:24:06.380
And you're going to keep getting
higher and higher exponents

00:24:06.380 --> 00:24:09.020
of v and y.

00:24:09.020 --> 00:24:11.910
And in fact, you can
even get the 0 exponent,

00:24:11.910 --> 00:24:15.500
which means that v and y
both disappear altogether.

00:24:15.500 --> 00:24:18.060
And for that, you do
something slightly different,

00:24:18.060 --> 00:24:22.080
which is that you replace the
larger subtree by the smaller

00:24:22.080 --> 00:24:22.580
subtree.

00:24:25.400 --> 00:24:29.270
OK so here, which was originally
that larger tree generating

00:24:29.270 --> 00:24:32.580
vxy, I stick instead
the smaller subtree.

00:24:32.580 --> 00:24:34.880
I do the substitutions
from the smaller subtree.

00:24:34.880 --> 00:24:37.195
And I just get x there.

00:24:37.195 --> 00:24:38.570
And so now the
string I generated

00:24:38.570 --> 00:24:44.740
is uxz, which is the same as
uv to the 0 xy to the 0 z.

00:24:44.740 --> 00:24:48.650
And that is the
idea of the proof.

00:24:48.650 --> 00:24:55.930
Now, I think you could work out
the quantities that you need

00:24:55.930 --> 00:24:58.150
in order to drive this proof.

00:24:58.150 --> 00:24:59.530
I'm going to do that for you.

00:24:59.530 --> 00:25:03.610
I actually hate writing
down lots of inequalities,

00:25:03.610 --> 00:25:06.892
and equations, and
so on, on the board,

00:25:06.892 --> 00:25:08.350
because I think
they're just almost

00:25:08.350 --> 00:25:09.505
incomprehensible to follow.

00:25:09.505 --> 00:25:10.880
Or at least they
would be for me.

00:25:10.880 --> 00:25:12.520
But I'm going to put
them up there just

00:25:12.520 --> 00:25:15.082
for completeness sake.

00:25:15.082 --> 00:25:17.290
So here we're going to give
the details of this proof

00:25:17.290 --> 00:25:19.592
on the next slide here.

00:25:19.592 --> 00:25:21.550
Oh yeah, so I just want
to give a name to this.

00:25:21.550 --> 00:25:23.890
I'm going to call this the
cutting and pasting argument,

00:25:23.890 --> 00:25:27.850
because I'm cutting apart
pieces of this parse tree

00:25:27.850 --> 00:25:30.910
and I'm pasting them in to other
places within the parse tree

00:25:30.910 --> 00:25:34.570
to get new strings
being generated.

00:25:34.570 --> 00:25:36.320
So this is a cutting
and pasting argument.

00:25:36.320 --> 00:25:40.733
So OK, let's take a look
at the details here, just,

00:25:40.733 --> 00:25:42.150
well, we have to
understand, well,

00:25:42.150 --> 00:25:46.110
how big does p actually need
to be in order for this thing

00:25:46.110 --> 00:25:46.860
to kick in?

00:25:49.800 --> 00:25:52.080
Well, first of all,
we have to understand

00:25:52.080 --> 00:25:55.530
how fast that parse
tree can be growing

00:25:55.530 --> 00:25:57.070
as we go level to level.

00:25:57.070 --> 00:26:01.860
And that's going to be dependent
on how big the right-hand sides

00:26:01.860 --> 00:26:02.850
of rules are.

00:26:02.850 --> 00:26:06.120
I mean, that really
tells you how many--

00:26:06.120 --> 00:26:09.540
what's the fan out
you know of each node?

00:26:09.540 --> 00:26:10.890
What's the maximum fan out?

00:26:10.890 --> 00:26:14.130
And that's going to
be the maximum length

00:26:14.130 --> 00:26:17.280
of a right-hand
side of any rule.

00:26:17.280 --> 00:26:18.960
So for example, in
that other grammar

00:26:18.960 --> 00:26:22.890
we had seen last time for
arithmetic expressions,

00:26:22.890 --> 00:26:27.030
we had this E goes to E
plus T, this rule here.

00:26:27.030 --> 00:26:28.620
And in terms of the
parse tree, that

00:26:28.620 --> 00:26:32.520
would look like a little
element like that.

00:26:32.520 --> 00:26:35.520
And that's actually the
longest right-hand side

00:26:35.520 --> 00:26:36.700
that you can get.

00:26:36.700 --> 00:26:39.900
And so the parse tree can
be growing by a factor of 3

00:26:39.900 --> 00:26:41.470
each time.

00:26:41.470 --> 00:26:46.410
Now, that's going to tell
us how big the string needs

00:26:46.410 --> 00:26:49.440
to be that's being generated,
what is the value of p

00:26:49.440 --> 00:26:52.965
in order to get a high enough
parse tree so that you're going

00:26:52.965 --> 00:26:54.090
to get a repeated variable.

00:26:57.440 --> 00:27:01.850
Let's call the height of
the parse tree for S h.

00:27:01.850 --> 00:27:04.550
So now if you-- this is just
repeating what I just said.

00:27:04.550 --> 00:27:07.430
If you have a tree of height
h and the maximum branching

00:27:07.430 --> 00:27:10.190
is b, then you get, at
most, b to the h leaves,

00:27:10.190 --> 00:27:14.660
because each level, you get
another factor of b coming up,

00:27:14.660 --> 00:27:17.630
because that's how much
branching you have.

00:27:17.630 --> 00:27:20.330
So each node at one
level can become b nodes

00:27:20.330 --> 00:27:21.470
at the next level down.

00:27:21.470 --> 00:27:23.277
So you're multiplying
by b each time.

00:27:23.277 --> 00:27:24.860
And if you have h
levels, you're going

00:27:24.860 --> 00:27:28.290
to have b to the h leaves.

00:27:28.290 --> 00:27:31.440
So the length of s, which
are really the leaves here,

00:27:31.440 --> 00:27:33.098
is at most b to the h.

00:27:33.098 --> 00:27:34.890
The reason why it's at
most and not exactly

00:27:34.890 --> 00:27:37.050
is you might be doing
some substitutions which

00:27:37.050 --> 00:27:40.380
are shorter right-hand sides.

00:27:40.380 --> 00:27:42.450
OK, so to try to show
this as a picture

00:27:42.450 --> 00:27:46.290
here, pulling that same
picture we had before,

00:27:46.290 --> 00:27:51.180
we want h, the
height, to be bigger

00:27:51.180 --> 00:27:56.100
than the number of variables
to force a repetition.

00:27:56.100 --> 00:27:59.310
So the number of variables is
going to be written this way.

00:27:59.310 --> 00:28:01.440
V is the variables.

00:28:01.440 --> 00:28:04.488
V with bars around it is going
to be the number of variables.

00:28:04.488 --> 00:28:06.030
And we want that
height to be greater

00:28:06.030 --> 00:28:07.810
than the number of variables.

00:28:07.810 --> 00:28:10.770
So once you know how high you
want that tree to be in order

00:28:10.770 --> 00:28:15.210
to force a repetition, then it
tells you how big s has to be.

00:28:15.210 --> 00:28:22.560
So V has to be bigger than b
to the V, b to the size of V,

00:28:22.560 --> 00:28:26.820
because then the height
that you're going to get

00:28:26.820 --> 00:28:33.060
is going to be greater
than the size of V, which

00:28:33.060 --> 00:28:34.660
is-- so that's what you want.

00:28:34.660 --> 00:28:36.960
You want h to be greater
than the size of V.

00:28:36.960 --> 00:28:41.180
So you're going to set p to
be one more than b to the V.

00:28:41.180 --> 00:28:43.698
And so if s is at
least that length,

00:28:43.698 --> 00:28:45.240
this whole thing is
going to kick in.

00:28:45.240 --> 00:28:48.460
And you're going to get
that repeated variable.

00:28:48.460 --> 00:28:51.150
So we'll let p to
be that value where

00:28:51.150 --> 00:28:53.230
V is the number of
variables in the grammar.

00:28:53.230 --> 00:28:59.654
And so if s is at least p, which
is greater than b to the V,

00:28:59.654 --> 00:29:04.710
then the length of s is going
to be greater than b to the V.

00:29:04.710 --> 00:29:09.810
So h is going to be what you
want to make this thing work.

00:29:09.810 --> 00:29:12.180
If you don't follow
that, those inequalities,

00:29:12.180 --> 00:29:13.470
I sympathize with you.

00:29:13.470 --> 00:29:15.450
I would never follow
that either in a lecture.

00:29:15.450 --> 00:29:19.840
So but I hope you get the idea.

00:29:19.840 --> 00:29:21.690
But we're not
quite finished yet,

00:29:21.690 --> 00:29:25.110
because I want to now circle
back, and look at these three

00:29:25.110 --> 00:29:29.520
conditions, and make sure
that we've captured them all,

00:29:29.520 --> 00:29:34.950
because actually, it's not
totally obvious in each

00:29:34.950 --> 00:29:36.850
of those cases that
we've got them.

00:29:36.850 --> 00:29:41.460
So there is a few extra
things we need to do.

00:29:41.460 --> 00:29:43.653
OK, so this is
concluding the argument.

00:29:43.653 --> 00:29:46.320
There are going to be at least V
plus 1 variables in the longest

00:29:46.320 --> 00:29:46.590
path.

00:29:46.590 --> 00:29:48.210
So there is going
to be a repetition.

00:29:48.210 --> 00:29:50.430
So now let's go back
here and see, now

00:29:50.430 --> 00:29:56.280
that we have this picture
with a repeated variable,

00:29:56.280 --> 00:29:58.807
how do we know we can
get condition one?

00:29:58.807 --> 00:30:00.890
Well, that's just the
cutting and pasting argument

00:30:00.890 --> 00:30:01.970
from the previous slide.

00:30:05.090 --> 00:30:08.830
How do we know that v
and y are not both empty?

00:30:08.830 --> 00:30:11.800
Well actually, that's
not totally obvious,

00:30:11.800 --> 00:30:16.210
because it's possible that,
when you generated v here

00:30:16.210 --> 00:30:21.010
and you generated y, maybe
going from this R to that R,

00:30:21.010 --> 00:30:23.930
you got nothing new.

00:30:23.930 --> 00:30:27.130
You know, it could have been
that R got replaced by T,

00:30:27.130 --> 00:30:29.350
another variable with
nothing new coming out,

00:30:29.350 --> 00:30:31.580
and then T got replaced by R.

00:30:31.580 --> 00:30:35.187
You substituted T for
R and then R for T.

00:30:35.187 --> 00:30:36.770
And you've got nothing
new coming out.

00:30:36.770 --> 00:30:40.420
And in that case, v and y
would both be the empty string.

00:30:40.420 --> 00:30:44.280
And that would
violate what we want.

00:30:44.280 --> 00:30:47.413
The way you get around-- that
and these are details here.

00:30:47.413 --> 00:30:49.830
If you're not totally following
these points, don't worry.

00:30:52.470 --> 00:30:53.580
They're easy to describe.

00:30:53.580 --> 00:30:56.038
So I figure, let me present
the whole thing in full detail.

00:30:59.720 --> 00:31:03.440
So if going from this R to that
R doesn't generate anything

00:31:03.440 --> 00:31:06.470
new, you're getting exactly
the same things coming out--

00:31:06.470 --> 00:31:10.040
v and y are just
the empty string--

00:31:10.040 --> 00:31:12.950
how do we avoid
that from happening?

00:31:12.950 --> 00:31:18.450
There is a simple way to
address that, which is to say,

00:31:18.450 --> 00:31:23.720
if you have this string s,
when you take a parse tree,

00:31:23.720 --> 00:31:27.950
make sure you take a
small-as-possible parse tree.

00:31:27.950 --> 00:31:31.550
You're not allowed to start off
with an inefficient parse tree

00:31:31.550 --> 00:31:34.430
that can be shortened
and still generate s.

00:31:34.430 --> 00:31:36.590
I want the smallest
possible parse tree.

00:31:36.590 --> 00:31:38.540
And that smallest
possible parse tree

00:31:38.540 --> 00:31:41.720
can't have an R going
to another R which

00:31:41.720 --> 00:31:44.210
is generating nothing new,
because then you could always

00:31:44.210 --> 00:31:45.770
have eliminated that step.

00:31:45.770 --> 00:31:47.870
And you would still
have a parse tree for s,

00:31:47.870 --> 00:31:49.550
but it would be a
smaller parse tree.

00:31:49.550 --> 00:31:50.300
So that would be--

00:31:50.300 --> 00:31:54.170
I want you to start off with the
smallest possible parse tree.

00:31:54.170 --> 00:31:57.020
And then you're going to be
guaranteed that v or y is going

00:31:57.020 --> 00:32:00.170
to be something not empty.

00:32:00.170 --> 00:32:05.770
So that takes care
of condition two.

00:32:05.770 --> 00:32:13.300
Condition three-- you know, how
do we know that vxy together

00:32:13.300 --> 00:32:15.280
is not very long?

00:32:15.280 --> 00:32:18.490
And basically, it's the same
argument all over again.

00:32:18.490 --> 00:32:20.500
You just want to make
sure that, when you're

00:32:20.500 --> 00:32:23.380
picking the repetition
R, the two R's here,

00:32:23.380 --> 00:32:26.080
you pick the lowest possible
repetitions that occur,

00:32:26.080 --> 00:32:28.550
if you have many choices.

00:32:28.550 --> 00:32:30.800
And those lowest two,
those lowest repetitions,

00:32:30.800 --> 00:32:33.080
there is not going to be
any lower repetition here.

00:32:33.080 --> 00:32:38.390
And then by the same
argument, since once you

00:32:38.390 --> 00:32:41.210
have that very first R, there
is no more repetitions occurring

00:32:41.210 --> 00:32:46.190
below, the vxy
can't be very long,

00:32:46.190 --> 00:32:51.890
because that would, again, force
another repetition to occur.

00:32:51.890 --> 00:32:54.110
So anyway, those are
the three conditions.

00:32:54.110 --> 00:32:56.680
And that's the proof
of the pumping lemma

00:32:56.680 --> 00:32:57.760
for h free languages.

00:32:57.760 --> 00:33:01.030
Let's see how we use that.

00:33:01.030 --> 00:33:03.190
OK, so let's do an example
of proving a language

00:33:03.190 --> 00:33:05.892
not context free using
the pumping lemma.

00:33:05.892 --> 00:33:07.600
How are you going to
go about doing that?

00:33:07.600 --> 00:33:10.710
Because that's the kind of
thing, at the very least,

00:33:10.710 --> 00:33:13.210
you need to know how to do this
in order to do the homework.

00:33:15.690 --> 00:33:17.440
I'd like to motivate
you that the stuff is

00:33:17.440 --> 00:33:20.780
so interesting and fun, but
it doesn't work for everybody.

00:33:20.780 --> 00:33:25.990
So for you practical people
out there, pay attention

00:33:25.990 --> 00:33:28.453
so you can do the homework.

00:33:28.453 --> 00:33:29.870
OK, let's go back
to that language

00:33:29.870 --> 00:33:33.110
we had a couple of slides
back, 0 to the k, 1 to the k,

00:33:33.110 --> 00:33:33.740
2 to the k.

00:33:33.740 --> 00:33:35.630
It's not a
context-free language.

00:33:35.630 --> 00:33:38.210
We're going to show that
now using the pumping lemma

00:33:38.210 --> 00:33:41.970
for context-free languages.

00:33:41.970 --> 00:33:46.160
So it's going to do,
similar to the proofs using

00:33:46.160 --> 00:33:51.990
for non-regular languages,
proof by contradiction.

00:33:51.990 --> 00:33:55.640
So you, first you assume the
language is context-free.

00:33:55.640 --> 00:33:58.760
And then we're going to
apply the pumping lemma.

00:33:58.760 --> 00:34:02.580
And then we're going
to get a contradiction.

00:34:02.580 --> 00:34:04.580
So the pumping lemma
gives that pumping length,

00:34:04.580 --> 00:34:06.170
as we described above.

00:34:06.170 --> 00:34:09.500
And now we just want to pick a
longer string in the language

00:34:09.500 --> 00:34:12.770
and show that that
longer string, which

00:34:12.770 --> 00:34:15.643
is supposed to be pumpable and
stay in the language, in fact

00:34:15.643 --> 00:34:16.310
is not pumpable.

00:34:19.600 --> 00:34:21.100
So the pumping
lemma says that you

00:34:21.100 --> 00:34:23.949
can divide it into five
pieces satisfying the three

00:34:23.949 --> 00:34:25.060
conditions.

00:34:25.060 --> 00:34:28.153
Condition three implies that--

00:34:28.153 --> 00:34:30.070
so now I'm going to I'm
going to work through.

00:34:30.070 --> 00:34:32.780
I'm going to show you
get a contradiction.

00:34:32.780 --> 00:34:37.270
So condition three implies
that you cannot contain both

00:34:37.270 --> 00:34:38.020
0's and--

00:34:38.020 --> 00:34:39.409
let's pull up a picture here.

00:34:39.409 --> 00:34:45.100
So here is s, 0's, 1's, and then
2's, all of the same length.

00:34:45.100 --> 00:34:51.139
Condition three-- so
if you break it up,

00:34:51.139 --> 00:34:55.340
condition three says, vxy
together cannot be too long.

00:34:55.340 --> 00:34:58.670
Well, if vxy together
is not too long,

00:34:58.670 --> 00:35:02.660
how could it be that, when
you're repeating v and y,

00:35:02.660 --> 00:35:05.380
you stay in the language?

00:35:05.380 --> 00:35:09.940
For one thing, you can't
have 0's, 1's, and 2's all

00:35:09.940 --> 00:35:12.100
occurring within v, x, and y.

00:35:16.020 --> 00:35:18.430
Some symbol is going
to get left out.

00:35:18.430 --> 00:35:20.470
So then when you
pump up, you're going

00:35:20.470 --> 00:35:22.138
to have unequal
numbers of symbols.

00:35:22.138 --> 00:35:24.055
And so you're going to
be out of the language.

00:35:27.360 --> 00:35:30.570
OK, so no matter how
you try to cut it up

00:35:30.570 --> 00:35:33.930
following condition three,
which is one of the things that

00:35:33.930 --> 00:35:36.990
restricts the ways
to cut it up, you're

00:35:36.990 --> 00:35:41.290
going to end up, when you pump
up, going out of the language.

00:35:41.290 --> 00:35:45.690
And so therefore, it's not in--

00:35:45.690 --> 00:35:46.230
D?

00:35:46.230 --> 00:35:49.030
D is wrong.

00:35:49.030 --> 00:35:50.280
B, should say "B."

00:35:56.610 --> 00:35:58.660
I'm supposed to be able
to write on this thing.

00:35:58.660 --> 00:36:00.320
I guess not.

00:36:00.320 --> 00:36:02.350
I didn't test that.

00:36:02.350 --> 00:36:08.320
Oh well, that's
supposed to be a B.

00:36:08.320 --> 00:36:10.880
So B is a context-free
language, which includes--

00:36:10.880 --> 00:36:13.390
so that's the assumption, that
B is a context-free language.

00:36:13.390 --> 00:36:13.932
That's false.

00:36:13.932 --> 00:36:17.170
And we conclude that it's
not a context-free language.

00:36:17.170 --> 00:36:22.910
Let's do-- oh yeah, I
have a check in here.

00:36:22.910 --> 00:36:28.540
So let's see what I'm going
to ask you to think about.

00:36:32.190 --> 00:36:37.558
OK, my head is blocking
part of the text?

00:36:37.558 --> 00:36:38.600
Oh, that was a while ago.

00:36:43.580 --> 00:36:46.260
Yes, so just one
question by the way,

00:36:46.260 --> 00:36:50.990
in terms of applying the
pumping lemma-- either v or y

00:36:50.990 --> 00:36:53.507
can be empty, but not both.

00:36:53.507 --> 00:36:55.340
But anyway, let's get
to this check in here.

00:36:58.450 --> 00:37:01.320
So let's look at these
two languages, A1 and A2,

00:37:01.320 --> 00:37:05.410
which look very similar to
B, but a little different.

00:37:05.410 --> 00:37:08.760
So it's A1 is 0 to
the k, 1 to the k, 2

00:37:08.760 --> 00:37:13.120
to the l, where k and
l could be any numbers,

00:37:13.120 --> 00:37:16.850
any positive,
non-negative numbers.

00:37:16.850 --> 00:37:18.820
So basically what
this is saying is

00:37:18.820 --> 00:37:21.280
that the number of 0's and
1's are going to be equal,

00:37:21.280 --> 00:37:26.830
but the number of 2's can be
anything, whereas A2, similar,

00:37:26.830 --> 00:37:28.510
but here, we're
requiring the number

00:37:28.510 --> 00:37:31.877
of 1's and 2's to be equal.

00:37:31.877 --> 00:37:33.460
And the number of
0's can be anything.

00:37:36.810 --> 00:37:40.050
Now, you can easily
make, I hope--

00:37:40.050 --> 00:37:41.940
you should make sure you can--

00:37:41.940 --> 00:37:47.310
pushdown automata that
can recognize A1 and A2,

00:37:47.310 --> 00:37:49.760
because let's just take A1.

00:37:49.760 --> 00:37:55.520
The pushdown automaton can push
the 0's as it's reading them,

00:37:55.520 --> 00:37:57.920
pop them as it's reading
the 1's to match them off

00:37:57.920 --> 00:38:00.620
and make sure that they're
the same number of them.

00:38:00.620 --> 00:38:04.105
And then the 2's, it doesn't
care how many there are.

00:38:04.105 --> 00:38:06.230
It just has to make sure
that there are no strings,

00:38:06.230 --> 00:38:08.310
there are no letters
coming out of order.

00:38:08.310 --> 00:38:09.848
But any number of 2's is fine.

00:38:09.848 --> 00:38:12.140
So you can easily make a
pushdown automaton recognizing

00:38:12.140 --> 00:38:15.230
A1, similarly for A2.

00:38:15.230 --> 00:38:19.725
So what can we
conclude from that?

00:38:19.725 --> 00:38:21.100
Here are the three
possibilities.

00:38:21.100 --> 00:38:24.180
Let me-- so look at that, the
class of context-free languages

00:38:24.180 --> 00:38:26.700
is not closed
under intersection.

00:38:26.700 --> 00:38:28.140
You can read it.

00:38:28.140 --> 00:38:33.720
So I want to pull up the
poll and launch that.

00:38:38.330 --> 00:38:39.290
Please fill that out.

00:38:43.420 --> 00:38:43.975
10 seconds.

00:38:46.890 --> 00:38:50.100
Again, just, if you
don't know the answer,

00:38:50.100 --> 00:38:51.895
just give any answers so that--

00:38:51.895 --> 00:38:53.520
because we're not
counting correctness.

00:38:56.719 --> 00:38:58.870
There is still a
few dribbling in.

00:38:58.870 --> 00:39:04.720
OK, five seconds.

00:39:04.720 --> 00:39:06.580
OK, end polling.

00:39:06.580 --> 00:39:07.750
Most of you got that right.

00:39:10.468 --> 00:39:11.010
I don't know.

00:39:11.010 --> 00:39:12.302
Is it OK to share these things?

00:39:12.302 --> 00:39:15.660
I don't want to make people who
didn't get the right feel bad.

00:39:15.660 --> 00:39:17.160
You know, but you
should understand,

00:39:17.160 --> 00:39:18.750
I think if you're
missing something,

00:39:18.750 --> 00:39:21.540
you should understand
what you're missing.

00:39:21.540 --> 00:39:24.270
The pumping lemma shows
that A1 union A2 is not

00:39:24.270 --> 00:39:25.330
a context-free language?

00:39:25.330 --> 00:39:25.830
No.

00:39:25.830 --> 00:39:29.520
As I mentioned at the beginning,
the context-free languages

00:39:29.520 --> 00:39:31.380
are closed under union.

00:39:31.380 --> 00:39:34.843
So the pumping lemma had
better not show that these--

00:39:34.843 --> 00:39:36.510
we already know that
these two languages

00:39:36.510 --> 00:39:40.080
are context free, because we get
them from pushdown automaton.

00:39:40.080 --> 00:39:42.600
And we said at the beginning
that context-free language

00:39:42.600 --> 00:39:43.740
is closed under union.

00:39:43.740 --> 00:39:45.660
So we know that these
two are context free.

00:39:45.660 --> 00:39:47.160
So the pumping lemma
better not show

00:39:47.160 --> 00:39:48.410
that they're not context free.

00:39:48.410 --> 00:39:52.410
Something would be terribly--
have gone terribly wrong

00:39:52.410 --> 00:39:53.550
if that were true.

00:39:53.550 --> 00:39:59.910
And also we know also from a
little bit of further reasoning

00:39:59.910 --> 00:40:01.680
that the context-free
languages is not

00:40:01.680 --> 00:40:06.420
closed under complement by
what we've already discussed,

00:40:06.420 --> 00:40:08.610
because they are
closed under union.

00:40:08.610 --> 00:40:12.330
And as I pointed out, they're
not closed under intersection.

00:40:12.330 --> 00:40:15.060
And so if they were
closed under complement,

00:40:15.060 --> 00:40:17.280
De Morgan's Laws
would say that closure

00:40:17.280 --> 00:40:19.050
under union and closure
under complement

00:40:19.050 --> 00:40:21.595
would give you closure
under intersection.

00:40:21.595 --> 00:40:23.470
But we don't have closure
under intersection.

00:40:23.470 --> 00:40:27.600
So in fact, they're not
closed under complement.

00:40:27.600 --> 00:40:30.025
OK, so in fact,
this does show us

00:40:30.025 --> 00:40:31.650
that the class of
context-free language

00:40:31.650 --> 00:40:33.330
is not closed
under intersection,

00:40:33.330 --> 00:40:35.640
because the intersection
of A1 and A2,

00:40:35.640 --> 00:40:41.620
two context-free languages, is
B. And B is not context free.

00:40:41.620 --> 00:40:44.290
So it shows that this is--

00:40:44.290 --> 00:40:49.810
the closure under
intersection does not hold.

00:40:49.810 --> 00:40:53.650
So let us continue, then.

00:40:53.650 --> 00:40:55.690
We have one more example.

00:40:55.690 --> 00:40:58.850
Then we'll take a break.

00:40:58.850 --> 00:41:00.880
So the pumping lemma for
context-free languages,

00:41:00.880 --> 00:41:04.180
again, here is the
second example.

00:41:04.180 --> 00:41:07.360
Here is the language F. We
have actually seen this before.

00:41:07.360 --> 00:41:16.077
ww, two copies of a string,
two copies of any string--

00:41:16.077 --> 00:41:18.535
and we're going to show that's
not a context-free language.

00:41:22.200 --> 00:41:25.020
Assume that it is context
free, the pumping lemma

00:41:25.020 --> 00:41:26.380
gives pumping length.

00:41:26.380 --> 00:41:28.380
Now, here you have to do
a little bit more work.

00:41:28.380 --> 00:41:33.180
Often, the challenge in
applying the pumping lemma

00:41:33.180 --> 00:41:36.690
in either case that
we've seen involves

00:41:36.690 --> 00:41:38.820
choosing that string
that you need to pump,

00:41:38.820 --> 00:41:40.180
that you're going to pump.

00:41:40.180 --> 00:41:43.410
So you have to choose
s in F, which is longer

00:41:43.410 --> 00:41:45.460
than p, which s to go with.

00:41:45.460 --> 00:41:48.103
So you might try this
one, first glance.

00:41:48.103 --> 00:41:49.770
Here is a string
that's in the language,

00:41:49.770 --> 00:41:53.955
because it's two copies of
the string 0 to the p1 0

00:41:53.955 --> 00:41:55.140
to-- and then 0 to the p1.

00:41:55.140 --> 00:41:57.945
So that's in the language,
but it's a bad choice.

00:42:00.530 --> 00:42:02.240
Before I get ahead
of myself, let's

00:42:02.240 --> 00:42:06.060
draw a picture of s, which I
think is always helpful to see.

00:42:06.060 --> 00:42:10.490
So here is runs of 0's and then
a 1, runs of 0's and then a 1.

00:42:10.490 --> 00:42:12.200
Why is this a bad choice?

00:42:12.200 --> 00:42:16.850
Because you can pump that string
and you remain in the language.

00:42:16.850 --> 00:42:19.807
There is a way to
cut that string up

00:42:19.807 --> 00:42:21.140
and you'll stay in the language.

00:42:21.140 --> 00:42:23.510
And the way to cut
it up is to let

00:42:23.510 --> 00:42:28.070
the x be just that substring
which is just the 1.

00:42:28.070 --> 00:42:32.540
And the v and y can be a
couple of 0's or a single 0

00:42:32.540 --> 00:42:34.280
on either side of that 1.

00:42:34.280 --> 00:42:38.840
And now that's going
to be a small vxy.

00:42:38.840 --> 00:42:41.990
But if you repeat
v and y, you're

00:42:41.990 --> 00:42:50.800
going to stay in the
language, because you'll just

00:42:50.800 --> 00:42:51.910
be adding 0's here.

00:42:51.910 --> 00:42:54.100
You'll be adding same
number of 0's there.

00:42:54.100 --> 00:42:57.280
And then you're going
to have a string which

00:42:57.280 --> 00:42:58.630
still looks like ww.

00:42:58.630 --> 00:43:00.310
And you'll still
be in the language.

00:43:00.310 --> 00:43:03.700
So that means that cutting
it up doesn't get you out

00:43:03.700 --> 00:43:06.430
of the language under pumping.

00:43:06.430 --> 00:43:09.948
And the fact is that
that's a bad choice for s,

00:43:09.948 --> 00:43:11.740
because there is that
way of cutting it up.

00:43:11.740 --> 00:43:14.170
So you have to show
there's no way--

00:43:14.170 --> 00:43:16.960
you don't get to pick
the way to cut it up.

00:43:16.960 --> 00:43:21.100
You have to show that there is
no way to cut it up in order

00:43:21.100 --> 00:43:25.640
to violate the pumping lemma.

00:43:25.640 --> 00:43:29.830
So if instead you use the
string 0 to the p, 1 to the p,

00:43:29.830 --> 00:43:33.100
0 to the p, 1 to the p-- so this
is 0's followed by 1's followed

00:43:33.100 --> 00:43:36.400
by 0's followed by 1's, all
the same number of them--

00:43:36.400 --> 00:43:40.840
that can't be pumped satisfying
the three conditions.

00:43:40.840 --> 00:43:42.730
And just going through that--

00:43:46.160 --> 00:43:49.370
now if you try to break it
up, you're going to lose.

00:43:49.370 --> 00:43:51.105
Or the lemma is going to lose.

00:43:51.105 --> 00:43:52.730
You're going to be
happy, but the lemma

00:43:52.730 --> 00:43:55.160
is not going to be happy,
because it's not going-- it's

00:43:55.160 --> 00:43:58.400
going to violate the condition.

00:43:58.400 --> 00:44:03.290
Condition three
says vxy is not--

00:44:03.290 --> 00:44:05.390
doesn't span too
much, and in fact,

00:44:05.390 --> 00:44:11.360
can't span two runs of
0's or two runs of 1's.

00:44:11.360 --> 00:44:13.460
It's just not big
enough, because they're

00:44:13.460 --> 00:44:16.010
more than p things--
they're p things apart.

00:44:16.010 --> 00:44:20.420
And this one string, this
string vxy is only p long.

00:44:20.420 --> 00:44:25.620
And so therefore, if
you repeat v and y,

00:44:25.620 --> 00:44:27.810
you're going to have two
runs of 0's or two 1's

00:44:27.810 --> 00:44:28.920
that have unequal length.

00:44:28.920 --> 00:44:32.160
And now that's not
going to be the form ww.

00:44:32.160 --> 00:44:35.300
You're going to be
out of the language.

00:44:35.300 --> 00:44:38.300
So I hope that's--

00:44:38.300 --> 00:44:40.470
you've got a little
practice with that.

00:44:40.470 --> 00:44:43.130
I think we're at our break.

00:44:43.130 --> 00:44:48.420
And I will see you back
here in five minutes,

00:44:48.420 --> 00:44:53.630
if I can get my
timer launched here.

00:44:53.630 --> 00:44:55.040
OK, so see you soon.

00:44:58.120 --> 00:45:03.730
This is a good time, by the
way, to message me or the TAs.

00:45:03.730 --> 00:45:08.770
And I'll try to be looking
for if you have any questions.

00:45:08.770 --> 00:45:10.540
In the pumping lemma, can x--

00:45:10.540 --> 00:45:15.190
yeah, x can be epsilon
in the pumping lemma.

00:45:15.190 --> 00:45:16.300
x can be epsilon.

00:45:16.300 --> 00:45:22.420
y can be epsilon, but x and
y cannot both be epsilon,

00:45:22.420 --> 00:45:25.720
because then, when you pump,
you'll get nothing new.

00:45:25.720 --> 00:45:30.320
Technically, v and y can
include both 0's and 1's.

00:45:30.320 --> 00:45:33.560
Yeah, v and y can
include both 0's and 1's.

00:45:38.550 --> 00:45:46.075
So let me try to put that
back, if that's will--

00:45:50.960 --> 00:45:55.940
so v and y can have both 0's
and 1's, but they can't have

00:45:55.940 --> 00:45:58.040
0's from two different blocks.

00:46:01.180 --> 00:46:03.530
And you can't have 1's
from two different blocks.

00:46:03.530 --> 00:46:05.680
So what's going to
happen is either you're

00:46:05.680 --> 00:46:08.050
going to get things out
of order when you repeat--

00:46:08.050 --> 00:46:10.090
like, a v has both
0's and 1's in it.

00:46:10.090 --> 00:46:14.320
When you repeat v,
you're going to have

00:46:14.320 --> 00:46:16.810
0's and 1's, and 0's and
1's, and 0's and 1's.

00:46:16.810 --> 00:46:19.990
That's clearly out of the
language, so that's no good.

00:46:19.990 --> 00:46:23.440
Your only hope is to have v
to be sticking only inside

00:46:23.440 --> 00:46:27.220
the 0's and y to be sticking
only inside 0's or only inside

00:46:27.220 --> 00:46:28.152
1's.

00:46:28.152 --> 00:46:29.860
But now, if you repeat
that and just look

00:46:29.860 --> 00:46:31.510
at what you're
going to get, you're

00:46:31.510 --> 00:46:35.050
going to have a string
which is going to be--

00:46:35.050 --> 00:46:36.940
if you try to cut
that string in half,

00:46:36.940 --> 00:46:38.930
it's not going to be
of the right form.

00:46:38.930 --> 00:46:41.055
It's not going to be two
copies of the same string,

00:46:41.055 --> 00:46:46.900
because it's going to have a
run of 0's followed by a longer

00:46:46.900 --> 00:46:49.298
or shorter run of
0's, or a run of 1's

00:46:49.298 --> 00:46:51.340
followed by another run
of 1's of unequal length.

00:46:51.340 --> 00:46:56.620
So there is no way this
can be two strings, two

00:46:56.620 --> 00:46:59.530
copies of the same
string, because that's

00:46:59.530 --> 00:47:00.430
what you required.

00:47:00.430 --> 00:47:02.290
F has to be two copies
of the same string

00:47:02.290 --> 00:47:05.580
to be in the language.

00:47:05.580 --> 00:47:08.850
OK, let me just see where--
we're running out of time here.

00:47:08.850 --> 00:47:17.400
Let me just put my timer here.

00:47:17.400 --> 00:47:18.795
We've only got 30 seconds.

00:47:25.230 --> 00:47:29.640
And I'm sorry I'm not getting to
answer all the questions here.

00:47:29.640 --> 00:47:37.500
OK, we are done with our break.

00:47:37.500 --> 00:47:38.500
It's going to come back.

00:47:41.500 --> 00:47:45.490
And now we're shifting
gears in a major way,

00:47:45.490 --> 00:47:47.860
because in a sense,
everything we've

00:47:47.860 --> 00:47:53.080
done so far has been
kind of a warm up.

00:47:53.080 --> 00:47:57.850
These limited
computational models

00:47:57.850 --> 00:48:00.940
really are kind of
helping us to set

00:48:00.940 --> 00:48:03.760
our understanding of
automata and the definitions

00:48:03.760 --> 00:48:05.500
and the notation.

00:48:05.500 --> 00:48:08.170
And they're also going to be
helpful in providing examples

00:48:08.170 --> 00:48:10.270
later on in the term.

00:48:10.270 --> 00:48:12.820
But really, in terms of
a model of computation,

00:48:12.820 --> 00:48:17.890
they don't cut it, because they
cannot do very simple things

00:48:17.890 --> 00:48:20.800
that we normally think of a
computer as being able to do.

00:48:20.800 --> 00:48:24.610
So here we're introducing
another model of computation,

00:48:24.610 --> 00:48:25.750
called the Turing machine.

00:48:25.750 --> 00:48:27.840
And that's really going to
be the model of what we're

00:48:27.840 --> 00:48:29.920
going to stick with for
the rest of the semester,

00:48:29.920 --> 00:48:32.410
because that's going
to be our model

00:48:32.410 --> 00:48:35.413
of a general-purpose
computer, the way

00:48:35.413 --> 00:48:36.580
you normally think about it.

00:48:39.380 --> 00:48:41.960
So let's-- we'll spend a
little time introducing it.

00:48:41.960 --> 00:48:50.100
And then we we'll continue
that discussion next time.

00:48:50.100 --> 00:48:52.550
So in terms of a
schematic, actually,

00:48:52.550 --> 00:48:54.410
the Turing machine
model is pretty simple.

00:49:01.850 --> 00:49:04.520
It's going to have states
and all that stuff.

00:49:04.520 --> 00:49:07.092
So there is going to be a
finite control here, which

00:49:07.092 --> 00:49:09.300
is going to include states
and a transition function,

00:49:09.300 --> 00:49:11.540
as we'll describe in a minute.

00:49:11.540 --> 00:49:13.730
The point is that
it's going to have

00:49:13.730 --> 00:49:17.420
the input appearing on a tape.

00:49:17.420 --> 00:49:20.510
The key difference now
is that the machine

00:49:20.510 --> 00:49:24.380
is going to be able to change
the symbols on the tape.

00:49:24.380 --> 00:49:27.650
And so we think of the machine
as being able to write as well

00:49:27.650 --> 00:49:29.480
as read the tape.

00:49:29.480 --> 00:49:36.740
So that's really the key
feature of a Turing machine,

00:49:36.740 --> 00:49:38.810
is the ability to
write on the tape.

00:49:38.810 --> 00:49:41.630
Everything else, in a
sense, follows from that,

00:49:41.630 --> 00:49:43.730
and a few other differences.

00:49:43.730 --> 00:49:48.530
But so the fact that the
head can read and write

00:49:48.530 --> 00:49:52.610
so that we can use
the tape as storage

00:49:52.610 --> 00:49:54.620
much as we use the
stack of storage,

00:49:54.620 --> 00:49:58.100
but it's not limited in the
way we can access it the way a

00:49:58.100 --> 00:49:59.090
stack is--

00:49:59.090 --> 00:50:02.930
so we kind of have
very flexible access

00:50:02.930 --> 00:50:05.150
of the information on the tape.

00:50:05.150 --> 00:50:08.120
Now, being able to
write on the tape

00:50:08.120 --> 00:50:10.730
doesn't do any good if
you can't go back and read

00:50:10.730 --> 00:50:12.420
what you've written later on.

00:50:12.420 --> 00:50:15.290
So we're going to make the
head to be able to be two way.

00:50:15.290 --> 00:50:17.510
So the head can move
left to right as before,

00:50:17.510 --> 00:50:19.520
but it can also move back left.

00:50:19.520 --> 00:50:21.770
And that's going to be under
control of the transition

00:50:21.770 --> 00:50:26.180
function, so under program
control, essentially.

00:50:26.180 --> 00:50:28.160
The tape is going to be--

00:50:28.160 --> 00:50:30.270
oops, sorry.

00:50:30.270 --> 00:50:34.210
The tape is infinite
to the right.

00:50:34.210 --> 00:50:38.650
And so we're not going to limit
how much storage the machine

00:50:38.650 --> 00:50:39.440
can have.

00:50:39.440 --> 00:50:41.898
So the tape is going to-- we'll
think of as having, instead

00:50:41.898 --> 00:50:44.600
of just having the input on it,
it's going to have the input.

00:50:44.600 --> 00:50:46.142
But then the rest,
it's going to have

00:50:46.142 --> 00:50:50.110
infinitely many blanks, blank
symbols following the input.

00:50:50.110 --> 00:50:57.410
So the tape is infinite in
the right-hand direction.

00:50:57.410 --> 00:51:00.640
And so there is
infinitely many blanks.

00:51:00.640 --> 00:51:04.180
I'm going to use that symbol for
the blank to follow the input.

00:51:04.180 --> 00:51:05.530
You can accept or reject.

00:51:05.530 --> 00:51:07.930
Oh yeah, so that's another
thing that's important.

00:51:07.930 --> 00:51:09.940
Normally, we think of--

00:51:09.940 --> 00:51:13.810
in the previous machines, finite
automata, pushdown automata,

00:51:13.810 --> 00:51:15.610
when you got to the
end of the input,

00:51:15.610 --> 00:51:18.418
that's when the acceptance
or rejection was decided.

00:51:18.418 --> 00:51:20.710
If you were going to accept
it at the end of the input,

00:51:20.710 --> 00:51:21.850
then you accepted.

00:51:21.850 --> 00:51:25.060
But you have to be
in that location

00:51:25.060 --> 00:51:27.700
at the end of the input in
order for that to take effect.

00:51:27.700 --> 00:51:29.200
That doesn't make
any sense anymore,

00:51:29.200 --> 00:51:32.740
because the machine
might go off beyond that,

00:51:32.740 --> 00:51:35.860
and still be computing, and come
back and read the tape later

00:51:35.860 --> 00:51:36.470
on.

00:51:36.470 --> 00:51:38.410
So it only really
makes sense to let

00:51:38.410 --> 00:51:44.040
the machine accept or reject
upon entering the accept

00:51:44.040 --> 00:51:45.070
or reject state.

00:51:45.070 --> 00:51:47.280
So we're going to have
a special accept state

00:51:47.280 --> 00:51:49.680
and a special reject
state, which is also

00:51:49.680 --> 00:51:51.540
a little different than before.

00:51:51.540 --> 00:51:53.940
And when the machine
enters those states,

00:51:53.940 --> 00:51:55.110
then the machine--

00:51:55.110 --> 00:51:57.210
then the action takes effect.

00:51:57.210 --> 00:52:02.010
The machine halts and then
accepts or halts and then

00:52:02.010 --> 00:52:03.000
rejects.

00:52:03.000 --> 00:52:06.030
So we'll make that absolutely
clear in the formal definition

00:52:06.030 --> 00:52:10.000
in a second, but just
to get the spirit of it.

00:52:10.000 --> 00:52:13.890
So I'm going to give you an
example of the thing running.

00:52:13.890 --> 00:52:17.970
Sorry, me too-- again, my
PowerPoint is having issues.

00:52:21.950 --> 00:52:26.600
OK, so here is a Turing machine
recognizing that language b.

00:52:26.600 --> 00:52:28.180
Actually, I switched
gears on you.

00:52:28.180 --> 00:52:30.680
Instead of 0's, 1's, and 2's,
I made them a's, b's, and c's,

00:52:30.680 --> 00:52:31.745
but the same idea.

00:52:35.790 --> 00:52:38.630
So I'm going to show you how
the Turing machine operates.

00:52:38.630 --> 00:52:41.760
And then we'll give
a formal definition.

00:52:41.760 --> 00:52:43.610
I hope that's on here.

00:52:43.610 --> 00:52:45.550
I think it is.

00:52:45.550 --> 00:52:46.550
In a second, but let's--

00:52:46.550 --> 00:52:48.967
this is an informal discussion
of how the machine is going

00:52:48.967 --> 00:52:52.130
to operate to do this language,
a to the k, b to the k, c

00:52:52.130 --> 00:52:55.100
to the k, using its ability
to write on the tape

00:52:55.100 --> 00:52:58.050
as well as read and move
its head in both directions.

00:52:58.050 --> 00:53:02.690
OK, so let me just first
describe in English

00:53:02.690 --> 00:53:06.880
how this machine operates.

00:53:06.880 --> 00:53:10.690
And then we will
see it in action

00:53:10.690 --> 00:53:14.460
on this little picture
I have over here.

00:53:14.460 --> 00:53:16.210
So the way the machine
is going to operate

00:53:16.210 --> 00:53:19.240
is the very first thing is the
head is going to start here.

00:53:19.240 --> 00:53:22.530
And the head is going to
scan off to the right,

00:53:22.530 --> 00:53:25.950
making sure that the symbols
appear in the correct order.

00:53:25.950 --> 00:53:29.750
So it's seeing that there
are a's and b's and then c's,

00:53:29.750 --> 00:53:33.230
without checking the quantities,
just that the order is correct.

00:53:33.230 --> 00:53:35.240
For that, you don't
need to write.

00:53:35.240 --> 00:53:38.450
A finite automaton can check
that the input is of the form

00:53:38.450 --> 00:53:40.920
a star, b star, c star.

00:53:40.920 --> 00:53:45.570
So writing is not necessary.

00:53:45.570 --> 00:53:48.760
The machine, if it detects
symbols out of order,

00:53:48.760 --> 00:53:52.320
it immediately rejects by going
into a special reject state.

00:53:52.320 --> 00:53:55.710
Otherwise, it's going to return
its head back to the left end.

00:53:55.710 --> 00:53:59.680
And let me just show that here.

00:53:59.680 --> 00:54:01.470
So here is-- oh no.

00:54:04.835 --> 00:54:06.210
Before I illustrate
it over here,

00:54:06.210 --> 00:54:08.258
let's go through
the whole algorithm.

00:54:08.258 --> 00:54:10.800
So the next thing that happens
is you're going to scan right.

00:54:10.800 --> 00:54:12.570
And now you want
to do the counting.

00:54:12.570 --> 00:54:14.370
So you're going to
scan right again,

00:54:14.370 --> 00:54:16.110
but this time,
you're going to make

00:54:16.110 --> 00:54:19.710
a bunch of passes over the
input, a bunch of scans.

00:54:19.710 --> 00:54:21.600
And each time you
make a scan, you're

00:54:21.600 --> 00:54:25.540
going to cross off one
symbol of each type.

00:54:25.540 --> 00:54:27.000
So you're going
to cross off an a.

00:54:27.000 --> 00:54:28.380
You'll cross off a b.

00:54:28.380 --> 00:54:30.930
You'll cross off a
c on a single scan.

00:54:30.930 --> 00:54:33.780
And then you repeat that,
crossing off the next a,

00:54:33.780 --> 00:54:35.130
the next b, the next c.

00:54:35.130 --> 00:54:37.680
And you want to make
sure that you've

00:54:37.680 --> 00:54:40.920
crossed off all of the
symbols on the same run

00:54:40.920 --> 00:54:43.950
and not crossing off some
symbols before other symbols,

00:54:43.950 --> 00:54:46.710
while other symbols will
remain, because that would mean

00:54:46.710 --> 00:54:48.210
that the counts were not equal.

00:54:48.210 --> 00:54:50.370
If you cross them
off and they're all

00:54:50.370 --> 00:54:54.270
run out on the same
scan, same pass,

00:54:54.270 --> 00:54:57.630
then we know that the numbers
had to start off being equal.

00:54:57.630 --> 00:55:00.090
So I mean, this is a
sort of baby stuff here,

00:55:00.090 --> 00:55:01.650
but I hope you get the idea.

00:55:01.650 --> 00:55:03.545
And we'll kind of
illustrate it in a second.

00:55:05.250 --> 00:55:08.500
If you have the last
one of each symbol--

00:55:08.500 --> 00:55:10.530
so what I mean by
that is you just

00:55:10.530 --> 00:55:13.620
crossed off the last a, the
last b, and the last c--

00:55:13.620 --> 00:55:17.523
then that you originally
had an equal number.

00:55:17.523 --> 00:55:19.440
And so you accept, because
you're crossing off

00:55:19.440 --> 00:55:21.570
one of each on each scan.

00:55:21.570 --> 00:55:25.020
So if you cross off, on the
last scan, each one of them

00:55:25.020 --> 00:55:29.080
gets crossed off,
then you accept.

00:55:29.080 --> 00:55:32.370
But if it was the last of
some symbol but not of other

00:55:32.370 --> 00:55:37.170
symbols, so you crossed off the
last a, but there were several

00:55:37.170 --> 00:55:40.080
b's remaining, then you started
off with an unequal number

00:55:40.080 --> 00:55:42.610
of a's, b's, and c's.

00:55:42.610 --> 00:55:43.650
Then you can reject.

00:55:43.650 --> 00:55:48.400
Or if all symbols still remain
after you have crossed them,

00:55:48.400 --> 00:55:52.560
one on each off, then you
haven't done enough passes.

00:55:52.560 --> 00:55:56.040
And you're going to
repeat from stage three

00:55:56.040 --> 00:55:59.280
and do that again another scan.

00:55:59.280 --> 00:56:02.460
OK, so here is a
little animation

00:56:02.460 --> 00:56:04.870
which shows this
happening on this diagram.

00:56:04.870 --> 00:56:08.640
So here is the very first stage
where you're scanning across,

00:56:08.640 --> 00:56:11.220
making sure things are
in the right order.

00:56:11.220 --> 00:56:12.840
I didn't have to
write on the tape.

00:56:12.840 --> 00:56:16.451
And now you're going to reset
the head back to the beginning.

00:56:19.040 --> 00:56:21.860
This is, by the way, not
the most efficient procedure

00:56:21.860 --> 00:56:22.670
for doing this.

00:56:29.330 --> 00:56:31.950
Now we're going to do
a scan crossing off

00:56:31.950 --> 00:56:35.000
a single a, a single
b, and a single c.

00:56:35.000 --> 00:56:38.390
So here, I'm going to show that
here, a single a, a single b,

00:56:38.390 --> 00:56:39.703
single c.

00:56:39.703 --> 00:56:41.870
And now as soon as you have
crossed out that last c,

00:56:41.870 --> 00:56:44.570
we can return back
to the beginning.

00:56:44.570 --> 00:56:46.430
So scan right across--

00:56:49.020 --> 00:56:51.150
so if all symbols remain,
so there are still

00:56:51.150 --> 00:56:52.890
symbols remaining
of each type, we're

00:56:52.890 --> 00:56:54.515
going to return to
the left and repeat.

00:56:57.590 --> 00:57:01.010
Now we're getting another
pass, single a, single b,

00:57:01.010 --> 00:57:03.260
single c get crossed off.

00:57:03.260 --> 00:57:04.970
Have we crossed
them all off yet?

00:57:04.970 --> 00:57:09.210
No, there is-- of each type,
there still are remaining ones.

00:57:09.210 --> 00:57:11.580
So again, we return
back to the beginning.

00:57:11.580 --> 00:57:14.000
Now we have a last
pass, cross off

00:57:14.000 --> 00:57:16.190
the last a, the
last b, the last c.

00:57:16.190 --> 00:57:18.420
The last one of each
type was crossed off.

00:57:18.420 --> 00:57:22.100
So now we know we can accept,
because the original string

00:57:22.100 --> 00:57:23.770
was in the language.

00:57:23.770 --> 00:57:28.920
OK, so that's to give you at
least some idea how the Turing

00:57:28.920 --> 00:57:31.680
machine can operate,
more like the way

00:57:31.680 --> 00:57:33.910
you would think of a
computer operating.

00:57:33.910 --> 00:57:35.220
Maybe it's very primitive.

00:57:35.220 --> 00:57:37.740
You could imagine counting also.

00:57:37.740 --> 00:57:39.450
And a Turing machine
can count as well.

00:57:39.450 --> 00:57:43.200
But this is the
simplest procedure

00:57:43.200 --> 00:57:49.470
that I can just describe
for you without making

00:57:49.470 --> 00:57:51.900
it too complicated.

00:57:51.900 --> 00:57:55.550
OK, so let's do a
little checking on that.

00:57:55.550 --> 00:58:00.890
OK, so the way I'm describing
this, how do you think?

00:58:00.890 --> 00:58:03.350
And in a sense, you don't
quite know enough yet.

00:58:03.350 --> 00:58:09.520
But how do you think we're going
to get this effect of crossing

00:58:09.520 --> 00:58:12.400
off with the Turing machine?

00:58:12.400 --> 00:58:15.490
Are we going to get that
by changing the model

00:58:15.490 --> 00:58:19.360
and adding that ability
to cross off to the model?

00:58:19.360 --> 00:58:21.040
Are we going to use
a tape alphabet that

00:58:21.040 --> 00:58:24.370
includes those crossed-off
symbols among them?

00:58:24.370 --> 00:58:27.050
Or we'll just assume
that all Turing

00:58:27.050 --> 00:58:29.050
machines come with an
eraser and they can always

00:58:29.050 --> 00:58:30.850
cross off stuff.

00:58:30.850 --> 00:58:34.780
So what do you think is the nice
way, sort of mathematically,

00:58:34.780 --> 00:58:45.240
to describe this ability
to cross things off?

00:58:56.180 --> 00:59:01.780
Yeah, again, most of you,
again, I think are getting this.

00:59:01.780 --> 00:59:07.630
So there are, like,
10 laggards here.

00:59:07.630 --> 00:59:14.280
So please wrap it up so
we can close the poll.

00:59:14.280 --> 00:59:15.420
Five seconds to go.

00:59:18.800 --> 00:59:25.550
OK, polling ending, get
your last-- last call.

00:59:25.550 --> 00:59:28.420
All right, share the results.

00:59:28.420 --> 00:59:31.370
So most of you got that right.

00:59:31.370 --> 00:59:33.120
All Turing machines
come with the eraser--

00:59:33.120 --> 00:59:33.480
I don't know.

00:59:33.480 --> 00:59:35.910
That was thrown in there as a
joke, but it came in second.

00:59:35.910 --> 00:59:38.970
So don't feel bad if
you got it, but that's

00:59:38.970 --> 00:59:41.180
not what I had in mind.

00:59:41.180 --> 00:59:44.190
The way the Turing machine is
going to be writing on the tape

00:59:44.190 --> 00:59:50.160
is to write a crossed-off
symbol instead of the symbol

00:59:50.160 --> 00:59:51.473
that was originally there.

00:59:51.473 --> 00:59:53.640
So we're going to add these
new crossed-off symbols.

00:59:53.640 --> 00:59:57.855
And that's going to be a
common thing for us to do

00:59:57.855 --> 00:59:59.688
when we design Turing machines.

00:59:59.688 --> 01:00:01.980
We're not going to get down
to the implementation level

01:00:01.980 --> 01:00:02.610
for very long.

01:00:02.610 --> 01:00:03.990
We're going to
very quickly shift

01:00:03.990 --> 01:00:07.567
to a higher level of
discussion about the machines.

01:00:07.567 --> 01:00:09.150
But anyway, that's
how you would do it

01:00:09.150 --> 01:00:11.670
if you were going to
actually build a machine.

01:00:11.670 --> 01:00:15.575
So let us then look at
the formal definition.

01:00:15.575 --> 01:00:17.700
And personally, maybe I
should have done that check

01:00:17.700 --> 01:00:19.050
in after the formal definition.

01:00:19.050 --> 01:00:22.538
That might have been
clearer, but oh well.

01:00:22.538 --> 01:00:24.330
OK, Turing-- here is
the formal definition.

01:00:24.330 --> 01:00:26.310
This time, a Turing
machine is a 7-tuple.

01:00:28.950 --> 01:00:38.090
And there is-- now
here, we have sigma,

01:00:38.090 --> 01:00:39.490
which is the input alphabet.

01:00:39.490 --> 01:00:42.070
Gamma is the tape alphabet.

01:00:42.070 --> 01:00:45.640
So now you're a little
bit analogous to the stack

01:00:45.640 --> 01:00:47.920
from before where gamma
was the stack alphabet.

01:00:47.920 --> 01:00:49.690
But these are the
symbols that you're

01:00:49.690 --> 01:00:52.570
allowed to write on the tape--

01:00:52.570 --> 01:00:55.120
that are allowed
to be on the tape.

01:00:55.120 --> 01:00:58.600
So obviously, all
of the input symbols

01:00:58.600 --> 01:01:02.440
are among the tape
symbols, because they

01:01:02.440 --> 01:01:03.490
can appear on the tape.

01:01:03.490 --> 01:01:07.893
So you have sigma is
a subset of gamma.

01:01:07.893 --> 01:01:09.310
One thing I didn't
mention here is

01:01:09.310 --> 01:01:13.690
that the input alphabet, we
don't allow the blank symbol

01:01:13.690 --> 01:01:18.310
to be in the input alphabet,
so that you can actually

01:01:18.310 --> 01:01:20.110
use the blank symbol
as a delimiter

01:01:20.110 --> 01:01:23.910
for the end of the
input, a marker

01:01:23.910 --> 01:01:25.870
for the end of the input.

01:01:25.870 --> 01:01:28.010
So in fact, and the
blank symbol is always

01:01:28.010 --> 01:01:29.385
going to be in
the tape alphabet.

01:01:33.460 --> 01:01:36.660
This is actually always going
to be a proper subset because

01:01:36.660 --> 01:01:38.235
of the blank symbol.

01:01:38.235 --> 01:01:40.360
But we're just allowing--
it doesn't really matter.

01:01:40.360 --> 01:01:43.230
We're allowing the
tape alphabet to have

01:01:43.230 --> 01:01:45.600
other symbols for
convenience, so for example,

01:01:45.600 --> 01:01:47.430
these crossed-off symbols.

01:01:47.430 --> 01:01:49.620
Now let's look at what
the transition function,

01:01:49.620 --> 01:01:50.718
how that operates.

01:01:50.718 --> 01:01:52.260
So the transition
function, remember,

01:01:52.260 --> 01:01:55.020
tells how the machine is
actually doing its computation.

01:01:55.020 --> 01:01:59.430
And it says that, if you're in
a certain state and the head

01:01:59.430 --> 01:02:03.780
is looking at a
certain tape symbol,

01:02:03.780 --> 01:02:06.300
then you can go to a new state.

01:02:06.300 --> 01:02:10.320
You write a new symbol at
that location on the tape.

01:02:10.320 --> 01:02:13.688
And you can move the head
either left or right.

01:02:13.688 --> 01:02:15.480
So that's how we get
the effect of the head

01:02:15.480 --> 01:02:19.230
being able to be bi-directional.

01:02:19.230 --> 01:02:21.375
And here is the
writing on the tape.

01:02:21.375 --> 01:02:22.552
It comes up right here.

01:02:22.552 --> 01:02:26.295
So just an example
here which says

01:02:26.295 --> 01:02:29.820
that, if we're in state two
and the head is looking at an a

01:02:29.820 --> 01:02:32.400
currently on the tape, then
we can move the state r.

01:02:32.400 --> 01:02:33.450
We change that a to a b.

01:02:33.450 --> 01:02:35.490
And we move the
head right 1 square.

01:02:39.990 --> 01:02:41.430
Now, this is important.

01:02:44.740 --> 01:02:48.430
When you give a certain input
here to the Turing machine,

01:02:48.430 --> 01:02:50.680
it may compute
around for a while,

01:02:50.680 --> 01:02:53.290
moving its head back and
forth, as we were showing.

01:02:53.290 --> 01:02:55.270
And it may eventually
halt by either

01:02:55.270 --> 01:02:57.610
entering the q
accept state or the q

01:02:57.610 --> 01:03:01.000
reject state, which I
didn't bring out here,

01:03:01.000 --> 01:03:02.150
but that's important.

01:03:02.150 --> 01:03:04.630
These are the accepting,
rejecting, special states

01:03:04.630 --> 01:03:06.130
of the machine.

01:03:06.130 --> 01:03:08.145
Or the machine may never
enter one of those.

01:03:08.145 --> 01:03:09.520
It may just go
on, and on, and on

01:03:09.520 --> 01:03:13.880
and never halt. We call
that looping, a little bit

01:03:13.880 --> 01:03:16.550
of a misnomer, because
looping implies

01:03:16.550 --> 01:03:18.020
some sort of a repetition.

01:03:18.020 --> 01:03:22.370
For us, looping just
means not halting.

01:03:22.370 --> 01:03:27.910
And so therefore, M has
three possible outcomes

01:03:27.910 --> 01:03:32.440
for each input, this w.

01:03:32.440 --> 01:03:38.290
It might accept w by
entering the accept state.

01:03:38.290 --> 01:03:41.620
It could reject w by entering
the reject state, which

01:03:41.620 --> 01:03:44.540
means it's going to
reject it by halting.

01:03:44.540 --> 01:03:47.960
Or we also say we can
reject by looping.

01:03:47.960 --> 01:03:51.920
You can reject the string
by running forever.

01:03:51.920 --> 01:03:54.740
That's just the terminology
that's common in the subject.

01:03:54.740 --> 01:03:59.480
So you either accept it
by halting and accepting

01:03:59.480 --> 01:04:02.660
or rejecting it by either
halting and rejecting

01:04:02.660 --> 01:04:04.190
or by just going forever.

01:04:04.190 --> 01:04:06.230
That's also considered
to be rejecting,

01:04:06.230 --> 01:04:09.350
sort of rejecting in
a sense by default.

01:04:09.350 --> 01:04:11.223
If you never actually
have accepted it,

01:04:11.223 --> 01:04:12.515
then it's going to be rejected.

01:04:15.520 --> 01:04:18.280
OK, check in three here--

01:04:18.280 --> 01:04:23.030
all right, so now our
last check in for the day,

01:04:23.030 --> 01:04:28.030
we say, this Turing machine
model is deterministic.

01:04:28.030 --> 01:04:29.000
I'm just saying that.

01:04:29.000 --> 01:04:33.010
But if you look at
the way we set it up,

01:04:33.010 --> 01:04:35.680
if you've been following the
formal definition so far,

01:04:35.680 --> 01:04:38.080
you would understand
why it's deterministic.

01:04:38.080 --> 01:04:41.080
So let's just, as a
way of checking that,

01:04:41.080 --> 01:04:43.030
how would we change
this definition?

01:04:43.030 --> 01:04:45.428
Because we will look
at the next lecture

01:04:45.428 --> 01:04:46.970
at non-deterministic
Turing machines.

01:04:46.970 --> 01:04:48.760
So a little bit of
a lead in to that,

01:04:48.760 --> 01:04:52.000
how would we change
this definition

01:04:52.000 --> 01:04:54.340
to make it a non-deterministic
Turing machine?

01:04:54.340 --> 01:04:58.760
Which of those three
options would we use?

01:04:58.760 --> 01:05:00.340
So here, I'll launch that poll.

01:05:07.775 --> 01:05:09.602
I've got about 10 people left.

01:05:09.602 --> 01:05:11.060
Let's give them
another 10 seconds.

01:05:17.670 --> 01:05:20.865
OK, I think that's everybody
who has answered it from before.

01:05:23.710 --> 01:05:26.760
So here, I think you pretty
much almost all of you

01:05:26.760 --> 01:05:28.230
got the right idea.

01:05:28.230 --> 01:05:32.190
It is B, in fact, because when
we have the power set symbol

01:05:32.190 --> 01:05:34.200
here, that means there
might be several--

01:05:34.200 --> 01:05:36.130
there is a subset
of possibilities.

01:05:36.130 --> 01:05:38.580
So that indicates several
different ways to go.

01:05:42.010 --> 01:05:44.380
And that's the essence
of non-determinism.

01:05:44.380 --> 01:05:48.040
OK, so I think we're--

01:05:48.040 --> 01:05:48.540
whoops.

01:05:53.990 --> 01:05:59.060
All right, so look, this is
also kind of setting us up

01:05:59.060 --> 01:06:04.090
for next lecture and where we're
going to be going with this.

01:06:04.090 --> 01:06:08.670
So these are basically two
in a-- well, two or three

01:06:08.670 --> 01:06:11.560
important definitions here.

01:06:11.560 --> 01:06:16.710
One is-- we talked about
the regular languages

01:06:16.710 --> 01:06:18.090
from finite automata.

01:06:18.090 --> 01:06:21.060
We talked about the
context-free languages

01:06:21.060 --> 01:06:23.100
from the grammars and
the pushdown automata.

01:06:23.100 --> 01:06:28.170
What are the languages that
the Turing machines can do?

01:06:28.170 --> 01:06:30.870
Those are called, in
this course, anyway,

01:06:30.870 --> 01:06:36.420
Turing-recognizable
languages, or T recognizable.

01:06:36.420 --> 01:06:40.870
Those are the languages that the
Turing machine can recognize.

01:06:40.870 --> 01:06:46.710
And so just to make sure we
were on the same page on this,

01:06:46.710 --> 01:06:50.070
the language of the machine
is the collection of strings

01:06:50.070 --> 01:06:53.020
that the machine accepts.

01:06:53.020 --> 01:06:54.770
So the things that are
not in the language

01:06:54.770 --> 01:06:57.320
are the things that are
rejected either by looping

01:06:57.320 --> 01:06:59.840
or by halting and rejecting.

01:06:59.840 --> 01:07:03.320
So only the ones that are
accepted is the language.

01:07:03.320 --> 01:07:05.480
Every machine has just
a single language.

01:07:05.480 --> 01:07:08.840
It's the language of all strings
that that machine accepts.

01:07:08.840 --> 01:07:11.360
And we'll say that and
recognize that language,

01:07:11.360 --> 01:07:14.150
if that language is the
collection of such strings

01:07:14.150 --> 01:07:15.800
that are accepted.

01:07:15.800 --> 01:07:21.980
And we will call that language
a Turing-recognizable language,

01:07:21.980 --> 01:07:24.230
if there is some Turing
machine that can recognize it.

01:07:28.090 --> 01:07:35.940
Now, this feature of being able
to reject by running forever

01:07:35.940 --> 01:07:37.310
is a little bit weird, perhaps.

01:07:40.010 --> 01:07:46.370
And from the standpoint
of practicality,

01:07:46.370 --> 01:07:50.000
it's more convenient if the
machine always makes a decision

01:07:50.000 --> 01:07:52.940
to accept or reject
in finite time

01:07:52.940 --> 01:07:55.580
and doesn't just reject
by going forever.

01:07:55.580 --> 01:07:59.630
And so we're going to bring
out a special class of Turing

01:07:59.630 --> 01:08:05.090
machines that have that
feature, that they always halt.

01:08:05.090 --> 01:08:07.130
The halting states,
by the way-- maybe it

01:08:07.130 --> 01:08:09.590
didn't say this explicitly--
are the q accept

01:08:09.590 --> 01:08:10.670
and the q reject states.

01:08:10.670 --> 01:08:13.610
The accept and reject states
are the halting states.

01:08:13.610 --> 01:08:15.888
So if the machine
halts, that means

01:08:15.888 --> 01:08:17.180
it ends up in one of those two.

01:08:17.180 --> 01:08:19.580
So it has made a
decision of accepting

01:08:19.580 --> 01:08:25.490
or rejecting at the point
at which it has halted.

01:08:25.490 --> 01:08:28.970
So we'll say a machine
is a decider if it always

01:08:28.970 --> 01:08:32.260
halts on every input.

01:08:32.260 --> 01:08:34.510
So for every w fed
in, the machine

01:08:34.510 --> 01:08:38.660
is eventually going to come
to a q accept or a q reject.

01:08:38.660 --> 01:08:41.170
We call such a
machine a decider.

01:08:41.170 --> 01:08:46.279
And now we're going to
say, a language is--

01:08:46.279 --> 01:08:50.463
so we'll say that the machine
decides a language if it's

01:08:50.463 --> 01:08:52.880
the language of the machine,
so the collection of accepted

01:08:52.880 --> 01:08:55.760
strings, and the
machine is the decider.

01:08:55.760 --> 01:08:59.060
We'll say that, instead of
just recognizing the language,

01:08:59.060 --> 01:09:02.729
we'll say that it
decides the language.

01:09:02.729 --> 01:09:07.439
And the Turing-decidable
language is a language that

01:09:07.439 --> 01:09:08.640
the machine--

01:09:08.640 --> 01:09:11.939
of all strings the machine
accepts for some Turing machine

01:09:11.939 --> 01:09:14.040
which is a decider, which
is a Turing machine that

01:09:14.040 --> 01:09:15.960
always halts.

01:09:15.960 --> 01:09:19.370
So if a Turing machine may
sometimes reject by looping,

01:09:19.370 --> 01:09:21.470
then it's only
recognizing its language.

01:09:21.470 --> 01:09:23.810
If the Turing machine
is always halting,

01:09:23.810 --> 01:09:26.779
so it's always rejecting
by explicitly coming

01:09:26.779 --> 01:09:29.779
to a reject state and
halting, then we'll

01:09:29.779 --> 01:09:32.399
say it's actually
deciding the language.

01:09:32.399 --> 01:09:34.268
So then, in a sense,
that's better.

01:09:34.268 --> 01:09:36.310
And we're going to
distinguish between those two,

01:09:36.310 --> 01:09:40.430
because they're not the same.

01:09:40.430 --> 01:09:42.520
There are some languages
which can be recognized,

01:09:42.520 --> 01:09:44.340
but not decided.

01:09:44.340 --> 01:09:47.500
And so in fact, we're going to
get the following picture here,

01:09:47.500 --> 01:09:50.870
that the Turing-recognizable
languages are a proper subset.

01:09:50.870 --> 01:09:52.077
They include all of--

01:09:52.077 --> 01:09:53.660
everything that's
decidable, certainly

01:09:53.660 --> 01:10:00.500
is going to be recognizable,
because being a decider

01:10:00.500 --> 01:10:02.630
is an additional
restriction to impose,

01:10:02.630 --> 01:10:04.615
an additional requirement.

01:10:04.615 --> 01:10:05.990
So everything
that's decidable is

01:10:05.990 --> 01:10:07.725
going to be automatically
recognizable.

01:10:07.725 --> 01:10:10.100
But there are things which
are recognizable which are not

01:10:10.100 --> 01:10:13.031
decidable, as we'll see.

01:10:13.031 --> 01:10:14.630
I'll actually give
an example of that,

01:10:14.630 --> 01:10:17.270
but not prove it next lecture.

01:10:17.270 --> 01:10:20.600
And just for, just to
complete out this picture,

01:10:20.600 --> 01:10:25.790
I'm going to also point out--
we haven't proven this yet,

01:10:25.790 --> 01:10:29.080
but we will prove it--

01:10:29.080 --> 01:10:30.910
that the decidable
languages also

01:10:30.910 --> 01:10:34.150
include all the
context-free languages,

01:10:34.150 --> 01:10:36.070
which, in turn, include
the regular languages,

01:10:36.070 --> 01:10:37.180
as was already seen.

01:10:37.180 --> 01:10:39.400
So we haven't shown
this inclusion yet.

01:10:39.400 --> 01:10:42.400
But actually, this is
the picture that we get.

01:10:42.400 --> 01:10:45.640
So there is actually a
hierarchy of containments here.

01:10:45.640 --> 01:10:50.170
Regular languages are a subset
of the context-free languages,

01:10:50.170 --> 01:10:53.050
which are, in turn, a subset of
the decidable languages, which

01:10:53.050 --> 01:10:57.850
in turn, are a subset of the
Turing-recognizable languages.

01:10:57.850 --> 01:11:00.070
And so with that,
I think we're going

01:11:00.070 --> 01:11:02.110
to move to our little
bit of a review of what

01:11:02.110 --> 01:11:04.290
we've done today.

01:11:04.290 --> 01:11:06.800
So we proved that
pumping lemma as a tool

01:11:06.800 --> 01:11:10.790
for showing that languages are
not context-free languages.

01:11:10.790 --> 01:11:12.500
We defined Turing
machines, which

01:11:12.500 --> 01:11:17.285
is going to be our model that
we're going to be focusing

01:11:17.285 --> 01:11:20.750
on for the rest of the term,
not forgetting the other models,

01:11:20.750 --> 01:11:23.930
because they're going to
be useful examples for us.

01:11:23.930 --> 01:11:27.650
And we defined Turing deciders,
Turing machine deciders

01:11:27.650 --> 01:11:29.810
that halt on all inputs.

01:11:29.810 --> 01:11:33.050
OK, so I think, with
that, we have come

01:11:33.050 --> 01:11:35.282
to the end of today's lecture.

01:11:35.282 --> 01:11:37.490
I will stick around a little
bit and answer questions

01:11:37.490 --> 01:11:38.720
in the chat.

01:11:38.720 --> 01:11:40.705
I will try to share
them with everybody

01:11:40.705 --> 01:11:43.205
as I'm answering them so I'm
not just talking to one person.

01:11:46.530 --> 01:11:49.470
How is the concept applied in--

01:11:49.470 --> 01:11:52.860
so I'm getting one question
about the practicality

01:11:52.860 --> 01:11:54.270
of all this.

01:11:54.270 --> 01:11:56.010
Bunches of questions
are coming in.

01:12:00.380 --> 01:12:06.080
So look, is this
stuff all practical?

01:12:06.080 --> 01:12:09.920
I would say, yes and no.

01:12:15.236 --> 01:12:17.130
I don't know which
concept you have in mind.

01:12:17.130 --> 01:12:19.890
We're going to introduce lots
of concepts in this course.

01:12:19.890 --> 01:12:30.870
And the concept of the finite
automata, and the pushdown

01:12:30.870 --> 01:12:34.560
automata, and context-free
languages, definitely

01:12:34.560 --> 01:12:39.330
used in other subjects, in
other fields in computer science

01:12:39.330 --> 01:12:43.680
and elsewhere-- these are very
basic and fundamental notions.

01:12:43.680 --> 01:12:46.227
And so yes, and Turing
machines-- well,

01:12:46.227 --> 01:12:48.060
I mean that's a model
of a general computer.

01:12:48.060 --> 01:12:50.190
If you want to
understand computation,

01:12:50.190 --> 01:12:52.133
you're going to need to
understand some model.

01:12:52.133 --> 01:12:54.300
And a Turing machine is a
particularly simple model.

01:12:54.300 --> 01:12:55.770
And that's why we use it.

01:12:55.770 --> 01:12:56.730
As it turns out,
it doesn't really

01:12:56.730 --> 01:12:58.230
matter what model
you use, but we'll

01:12:58.230 --> 01:13:00.720
talk about that next time.

01:13:00.720 --> 01:13:03.120
But yeah, I would say there
is a lot of applied material

01:13:03.120 --> 01:13:07.530
in this course, as time
has shown, whether it's

01:13:07.530 --> 01:13:10.500
led to things like public
key cryptography, which

01:13:10.500 --> 01:13:15.420
is used on the internet,
or understanding

01:13:15.420 --> 01:13:17.010
various algorithms.

01:13:17.010 --> 01:13:19.410
I mean, that's not
the reason I study it.

01:13:19.410 --> 01:13:22.260
I study it because I'm
more coming at it from more

01:13:22.260 --> 01:13:23.730
of a mathematical perspective.

01:13:23.730 --> 01:13:26.790
I just find the material very
beautiful, and interesting,

01:13:26.790 --> 01:13:30.330
and challenging, but it
does have applications.

01:13:33.010 --> 01:13:34.210
Any other questions here?

01:13:34.210 --> 01:13:35.710
I think I'm going
to sign off, then,

01:13:35.710 --> 01:13:38.060
to get myself set up
for my office hours,

01:13:38.060 --> 01:13:40.600
which is on a
different Zoom link.

01:13:40.600 --> 01:13:42.220
OK, so thank you, everybody.

01:13:42.220 --> 01:13:44.770
And see you on Thursday.

01:13:44.770 --> 01:13:46.440
Bye bye.