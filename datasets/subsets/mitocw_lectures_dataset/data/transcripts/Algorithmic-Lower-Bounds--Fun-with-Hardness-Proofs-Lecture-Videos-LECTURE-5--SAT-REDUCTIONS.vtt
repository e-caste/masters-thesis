WEBVTT

00:00:00.080 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.840
Commons license.

00:00:03.840 --> 00:00:06.050
Your support will help
MIT OpenCourseWare

00:00:06.050 --> 00:00:10.150
continue to offer high-quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.522
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.522 --> 00:00:17.146
at ocw.mit.edu.

00:00:26.170 --> 00:00:28.310
PROFESSOR: Welcome
back to 6.890.

00:00:28.310 --> 00:00:31.880
Today, we will do many more
hardness proofs, mostly

00:00:31.880 --> 00:00:36.950
of games and puzzles and some
graph theoretic problems, all

00:00:36.950 --> 00:00:38.990
reducing from 3SAT.

00:00:38.990 --> 00:00:41.860
We're going to continue where
we left off last time, which

00:00:41.860 --> 00:00:44.190
was with this picture,
which also comes

00:00:44.190 --> 00:00:47.400
from lecture 1, which is how to
prove Super Mario Brothers is

00:00:47.400 --> 00:00:47.990
NP-hard.

00:00:47.990 --> 00:00:50.960
We had two main gadgets,
the variable gadget,

00:00:50.960 --> 00:00:55.340
which forces your player to
choose going left or right,

00:00:55.340 --> 00:00:58.330
and the clause
gadget, which could

00:00:58.330 --> 00:01:02.160
be visited in three different
ways in order to enable it.

00:01:02.160 --> 00:01:05.069
These each contained
an invincibility star,

00:01:05.069 --> 00:01:08.146
so that if later, you come
through to traverse the gadget,

00:01:08.146 --> 00:01:10.270
you can get through all
these fire bars if and only

00:01:10.270 --> 00:01:12.590
if there was at
least one star there.

00:01:12.590 --> 00:01:15.284
So that was a
regular 3SAT clause.

00:01:15.284 --> 00:01:17.200
And then, there's the
connectivity in between.

00:01:17.200 --> 00:01:19.680
And so in particular, you
need a crossover gadget

00:01:19.680 --> 00:01:20.520
with this set-up.

00:01:20.520 --> 00:01:22.610
But the general idea
is you visit variable,

00:01:22.610 --> 00:01:24.570
visit all the clauses
that are in it

00:01:24.570 --> 00:01:27.619
that include that literal-- you
get to choose only one-- then

00:01:27.619 --> 00:01:29.410
you go to the next
variable, next variable.

00:01:29.410 --> 00:01:30.993
And then, you traverse
all the clauses

00:01:30.993 --> 00:01:32.570
and you can get to
finish if and only

00:01:32.570 --> 00:01:36.240
if the 3SAT formula
was satisfiable.

00:01:36.240 --> 00:01:39.800
This is a general
construction or approach

00:01:39.800 --> 00:01:41.550
for platform video games.

00:01:41.550 --> 00:01:46.260
That's what we were presenting
it as in a recent paper.

00:01:46.260 --> 00:01:49.380
I thought I'd show you a few
other Nintendo games you can

00:01:49.380 --> 00:01:51.290
prove hard with this technique.

00:01:51.290 --> 00:01:55.900
This is the clause gadget
for Super Mario World.

00:01:55.900 --> 00:01:57.990
So in Super Mario
World, there are

00:01:57.990 --> 00:02:02.980
these great question-mark blocks
and in particular, POW blocks,

00:02:02.980 --> 00:02:06.397
which go back to the
original Mario Brothers

00:02:06.397 --> 00:02:07.230
without the "Super."

00:02:07.230 --> 00:02:09.449
How many people
played Mario Brothers?

00:02:09.449 --> 00:02:12.470
Really old-school,
pre-Super Mario.

00:02:12.470 --> 00:02:15.240
And anyway, it doesn't matter
exactly where it comes from.

00:02:15.240 --> 00:02:18.200
It does something completely
different in Super Mario World,

00:02:18.200 --> 00:02:21.510
which is turns all
coins into things

00:02:21.510 --> 00:02:24.520
you can walk on for 10 seconds.

00:02:24.520 --> 00:02:26.630
But you can't normally
hit a question-mark block

00:02:26.630 --> 00:02:27.749
except from the bottom.

00:02:27.749 --> 00:02:29.040
There's no way to do that here.

00:02:29.040 --> 00:02:31.840
But if you can visit one
of these three places,

00:02:31.840 --> 00:02:34.840
you can send one of these
turtle shells flying

00:02:34.840 --> 00:02:37.850
and it will hit this and bring
the POW block off and then

00:02:37.850 --> 00:02:40.800
disappear, so that later when
you try to traverse this clause

00:02:40.800 --> 00:02:43.100
gadget, if there's a POW
block, you can turn these

00:02:43.100 --> 00:02:46.750
into solid things for
long enough to get across

00:02:46.750 --> 00:02:48.000
but no longer than that.

00:02:48.000 --> 00:02:50.660
So in the next gadget, you need
another POW block, and so on.

00:02:50.660 --> 00:02:54.759
So that's clause gadget
for Super Mario World.

00:02:54.759 --> 00:02:56.300
The other gadgets
are pretty similar,

00:02:56.300 --> 00:02:57.591
so I'll just show you that one.

00:02:57.591 --> 00:03:01.234
AUDIENCE: Does the
star trick not work?

00:03:01.234 --> 00:03:03.400
PROFESSOR: I guess you could
also do the star trick,

00:03:03.400 --> 00:03:06.374
but I think we drew this figure
before we did the star trick.

00:03:06.374 --> 00:03:07.790
So we thought, oh,
this is cooler.

00:03:11.580 --> 00:03:14.720
Now, one thing I thought
I'd mention briefly

00:03:14.720 --> 00:03:18.480
is some fun glitches you can
do in the real Super Mario

00:03:18.480 --> 00:03:22.200
Brothers, as
implemented on the ROMs.

00:03:22.200 --> 00:03:25.712
You can do these crazy things
like jump off of walls.

00:03:25.712 --> 00:03:27.420
You're not supposed
to be able to do this

00:03:27.420 --> 00:03:29.820
and this level would be
unsolvable in the way you would

00:03:29.820 --> 00:03:32.430
normally think about
Super Mario Brothers,

00:03:32.430 --> 00:03:36.100
but there happens to be this
fun subpixel resolution.

00:03:36.100 --> 00:03:39.340
I think this is
usually very hard to do

00:03:39.340 --> 00:03:42.020
with a real controller,
but much easier

00:03:42.020 --> 00:03:45.780
to do when you can slow things
down 100 times and every frame,

00:03:45.780 --> 00:03:48.440
you have a choice of whether
to push a particular button.

00:03:48.440 --> 00:03:51.370
That's called tool-assisted
speed runs, usually.

00:03:54.230 --> 00:03:56.720
I don't know if you consider
this real Super Mario

00:03:56.720 --> 00:03:57.610
Brothers or not.

00:03:57.610 --> 00:03:59.180
It depends on your
notion of reality,

00:03:59.180 --> 00:04:01.390
whether you're more of a
mathematician or a gamer,

00:04:01.390 --> 00:04:02.680
I guess.

00:04:02.680 --> 00:04:06.590
But you can try to modify
the gadget so that wall

00:04:06.590 --> 00:04:08.100
jumping doesn't help you.

00:04:08.100 --> 00:04:10.419
So you could imagine trying
to jump up these walls.

00:04:10.419 --> 00:04:12.460
But if there's things in
the way, it prevents it.

00:04:12.460 --> 00:04:14.850
So if you just add that
to every vertical tunnel,

00:04:14.850 --> 00:04:17.850
that will prevent going
back up the tunnels, which

00:04:17.850 --> 00:04:19.600
is important for the
variable gadgets.

00:04:19.600 --> 00:04:21.600
We don't want to be able
to reverse our decision

00:04:21.600 --> 00:04:24.640
and later choose the
opposite variable setting.

00:04:24.640 --> 00:04:31.260
Here's another fun set of cheats
where you jump through walls.

00:04:31.260 --> 00:04:35.800
This one is apparently somewhat
doable on a real controller,

00:04:35.800 --> 00:04:38.730
but still quite challenging.

00:04:38.730 --> 00:04:41.170
I think that one of
the general ideas

00:04:41.170 --> 00:04:45.050
is the collision detection
is not super good in the game

00:04:45.050 --> 00:04:46.550
as implemented.

00:04:46.550 --> 00:04:49.940
So if you get just
the right geometry,

00:04:49.940 --> 00:04:51.410
you can walk through the walls.

00:04:51.410 --> 00:04:55.120
There's instructions for you.

00:04:55.120 --> 00:04:57.940
So this is obviously problematic
because all of our gadgets

00:04:57.940 --> 00:04:58.680
involve walls.

00:04:58.680 --> 00:05:01.890
So if you can walk through
them, not very interesting.

00:05:01.890 --> 00:05:07.020
So a general approach is to
just add lots of monsters

00:05:07.020 --> 00:05:07.950
into the walls.

00:05:07.950 --> 00:05:10.790
So even if you could walk
through, you become small Mario

00:05:10.790 --> 00:05:13.145
and then that's not an option.

00:05:13.145 --> 00:05:15.270
I should say these have
not been thoroughly tested,

00:05:15.270 --> 00:05:17.811
so it's plausible you can walk
through the wall in such a way

00:05:17.811 --> 00:05:21.120
that maybe you kill the monster
or there may be other glitches

00:05:21.120 --> 00:05:22.170
that we don't know about.

00:05:22.170 --> 00:05:26.050
And so you might consider
this a work in progress.

00:05:26.050 --> 00:05:28.930
But generally, I would believe
you can modify the proof

00:05:28.930 --> 00:05:32.170
to work on real Super Mario
Brothers as implemented

00:05:32.170 --> 00:05:35.470
in real physics, of course,
generalized to an n by n screen

00:05:35.470 --> 00:05:37.720
and so on.

00:05:37.720 --> 00:05:41.780
What exactly you call
"real" is challenging there.

00:05:41.780 --> 00:05:44.730
But that's Super Mario
Brothers-- just some more fun

00:05:44.730 --> 00:05:48.100
stuff in the paper.

00:05:48.100 --> 00:05:50.466
Let me talk a little bit
about Legend of Zelda.

00:05:50.466 --> 00:05:52.840
This is what it looks like,
in case you've never seen it.

00:05:52.840 --> 00:05:55.407
And this is the original
Legend of Zelda.

00:05:55.407 --> 00:05:56.490
You're a little character.

00:05:56.490 --> 00:05:57.323
You can walk around.

00:05:57.323 --> 00:06:01.170
And this is what I would say is
a typical block-pushing puzzle

00:06:01.170 --> 00:06:04.960
in Legend of Zelda, which
is try all the blocks

00:06:04.960 --> 00:06:07.190
and hope that one
of then pushes.

00:06:07.190 --> 00:06:12.130
And I have to say, I
watched an entire-- I

00:06:12.130 --> 00:06:14.530
don't know how long it was--
five hours of walkthrough

00:06:14.530 --> 00:06:16.070
of Legend of Zelda
wanting to find

00:06:16.070 --> 00:06:17.430
whether there are
any more complicated

00:06:17.430 --> 00:06:18.346
block-pushing puzzles.

00:06:18.346 --> 00:06:21.260
I swear I remember a slightly
more complicated one,

00:06:21.260 --> 00:06:22.940
but I could not find it.

00:06:22.940 --> 00:06:26.850
It's possible it skipped in
this particular walkthrough.

00:06:26.850 --> 00:06:29.310
Well, it just takes a long time.

00:06:29.310 --> 00:06:29.980
But you get it.

00:06:29.980 --> 00:06:31.360
All right, we're almost done.

00:06:31.360 --> 00:06:34.520
You get an idea of
what the game is like.

00:06:34.520 --> 00:06:35.810
You've got a sword, whatever.

00:06:35.810 --> 00:06:38.060
That won't be particularly
relevant to our reductions.

00:06:38.060 --> 00:06:39.893
There will be no monsters
in our reductions.

00:06:39.893 --> 00:06:42.500
In this case, I think you just
have to wait a really long time

00:06:42.500 --> 00:06:44.861
or possibly kill the
hand that comes out.

00:06:44.861 --> 00:06:46.110
Then, you can push that block.

00:06:46.110 --> 00:06:48.026
He actually tried to
push it in the beginning,

00:06:48.026 --> 00:06:49.010
but it wouldn't move.

00:06:49.010 --> 00:06:50.880
Anyway, that's Legend of Zelda.

00:06:53.476 --> 00:06:55.100
Here's a slightly
more interesting one.

00:06:55.100 --> 00:06:56.010
This is what I remember.

00:06:56.010 --> 00:06:57.540
Normally, you push one,
two, three, and then

00:06:57.540 --> 00:06:58.860
you push this to the side.

00:06:58.860 --> 00:07:02.219
In this particular case, blocks
are not pushable sideways,

00:07:02.219 --> 00:07:03.260
which is really annoying.

00:07:03.260 --> 00:07:05.301
So you actually have to
solve it a different way.

00:07:05.301 --> 00:07:08.830
If you watch this video, at this
point, he's like, oh, my god.

00:07:08.830 --> 00:07:12.150
This was the simplest
block-pushing puzzle ever

00:07:12.150 --> 00:07:12.900
and I solved it.

00:07:12.900 --> 00:07:15.110
Yea!

00:07:15.110 --> 00:07:19.000
It's after half an hour
of trying other things.

00:07:19.000 --> 00:07:23.090
That's the joy of Legend
of Zelda, very fun puzzles,

00:07:23.090 --> 00:07:24.720
so to speak.

00:07:24.720 --> 00:07:26.720
So the point is, you have
block-pushing puzzles.

00:07:26.720 --> 00:07:28.590
We already know-- oh, sorry.

00:07:28.590 --> 00:07:29.660
Here's one more, I guess.

00:07:29.660 --> 00:07:32.270
These are in Legend of
Zelda-- A Link to the Past.

00:07:32.270 --> 00:07:33.920
So it has a slightly
more com-- there's

00:07:33.920 --> 00:07:37.480
an actual slightly nontrivial
block-pushing puzzle.

00:07:37.480 --> 00:07:42.190
But in general, we
know push-one is hard.

00:07:42.190 --> 00:07:45.320
Most versions of Legend of Zelda
are slightly more restrictive

00:07:45.320 --> 00:07:46.580
than push-one.

00:07:46.580 --> 00:07:48.920
I would call them
"push-once" blocks,

00:07:48.920 --> 00:07:51.980
where you can only
push one at a time.

00:07:51.980 --> 00:07:53.070
That's your strength.

00:07:53.070 --> 00:07:54.910
But also, you can only
push a block once.

00:07:54.910 --> 00:07:56.480
You can never push
it a second time

00:07:56.480 --> 00:07:58.510
or push it back or do
anything like that.

00:07:58.510 --> 00:08:01.610
And with some slight-- this
is the gadget we saw before.

00:08:01.610 --> 00:08:04.680
With some slight tweaks,
you can make the locks still

00:08:04.680 --> 00:08:07.870
work when you're only allowed
to push each block once.

00:08:07.870 --> 00:08:11.740
So that proves that most
versions of Legend of Zelda

00:08:11.740 --> 00:08:16.560
are at least NP-hard, because
they include block pushing.

00:08:16.560 --> 00:08:19.900
But it would be
nice to understand

00:08:19.900 --> 00:08:22.230
other senses in which
these kinds of games

00:08:22.230 --> 00:08:23.950
are hard without
using block pushing.

00:08:23.950 --> 00:08:29.370
So here's another feature
called the hookshot.

00:08:29.370 --> 00:08:31.170
So you select it
and then if there's

00:08:31.170 --> 00:08:34.690
an object on the other side,
you can hookshot to that side.

00:08:34.690 --> 00:08:36.380
So you can't walk
over the cavern,

00:08:36.380 --> 00:08:38.000
but you can hookshot across.

00:08:38.000 --> 00:08:39.012
Here it is again.

00:08:39.012 --> 00:08:40.720
As long as there's an
object over there--

00:08:40.720 --> 00:08:44.250
you can also pick up
objects and destroy them.

00:08:44.250 --> 00:08:47.440
So does that make it hard
with no pushing blocks?

00:08:47.440 --> 00:08:50.310
Well, a little bit
of pushing blocks.

00:08:50.310 --> 00:08:53.140
Here's a simple proof
using that structure.

00:08:53.140 --> 00:08:55.080
So here's a variable.

00:08:55.080 --> 00:08:56.480
I go from top to bottom.

00:08:56.480 --> 00:08:58.850
You see over here a
treasure chest or something

00:08:58.850 --> 00:09:01.454
that you can hookshot onto
to go over the cavern.

00:09:01.454 --> 00:09:02.620
And here, you have a choice.

00:09:02.620 --> 00:09:04.120
You can go left or
you can go right,

00:09:04.120 --> 00:09:07.180
but then you can't back up,
because there's no object

00:09:07.180 --> 00:09:08.320
here to hookshot onto.

00:09:08.320 --> 00:09:10.560
You can only do it orthogonally.

00:09:10.560 --> 00:09:11.304
Here's a clause.

00:09:11.304 --> 00:09:12.970
If you come down any
one of these paths,

00:09:12.970 --> 00:09:15.970
then you can push
this block one step.

00:09:15.970 --> 00:09:18.980
And then, you'll be able
to hookshot from the right

00:09:18.980 --> 00:09:22.690
to get onto this platform and
then continue to the left.

00:09:22.690 --> 00:09:25.320
And a crossover is really
easy in this world.

00:09:25.320 --> 00:09:28.210
So you could come up with
lots of different NP-hardness

00:09:28.210 --> 00:09:28.710
proofs.

00:09:28.710 --> 00:09:32.470
So this is a fun one
for A Link to the Past,

00:09:32.470 --> 00:09:34.840
which is the first game
that has that hookshot.

00:09:34.840 --> 00:09:35.620
This is Metroid.

00:09:35.620 --> 00:09:37.286
If you've never played,
most of the time

00:09:37.286 --> 00:09:40.900
you spend going up and
down elevator shafts.

00:09:40.900 --> 00:09:43.642
And there are these monsters
which you can shoot.

00:09:43.642 --> 00:09:45.100
And then, there's
also this ability

00:09:45.100 --> 00:09:48.290
to become a one-by-one block
instead of a two-by-one block

00:09:48.290 --> 00:09:50.020
and roll through small things.

00:09:50.020 --> 00:09:53.300
When you're in that position,
in a certain part of the game,

00:09:53.300 --> 00:09:55.350
you are not allowed to shoot.

00:09:55.350 --> 00:09:59.490
So that's the situation
we're going to imagine.

00:09:59.490 --> 00:10:02.270
So here is a clause
in a crossover.

00:10:02.270 --> 00:10:04.384
The variable gadget
is the same as Mario.

00:10:04.384 --> 00:10:05.550
You fall left or fall right.

00:10:05.550 --> 00:10:09.140
You can't go back up, because
you have a limited jump height.

00:10:09.140 --> 00:10:11.510
So let's do the clause first.

00:10:11.510 --> 00:10:14.150
There are three different
ways to visit it.

00:10:14.150 --> 00:10:16.980
When you're setting your
variables, if you can get here,

00:10:16.980 --> 00:10:19.480
you can aim upwards and just
shoot all of these things.

00:10:19.480 --> 00:10:21.200
It would take a few
minutes, but you'd

00:10:21.200 --> 00:10:22.730
get rid of all these guys.

00:10:22.730 --> 00:10:25.772
These guys just walk
around constantly.

00:10:25.772 --> 00:10:27.230
And then, to
traverse, you're going

00:10:27.230 --> 00:10:29.040
to be coming through
here in ball mode.

00:10:29.040 --> 00:10:30.240
There's no way
to-- I guess, here,

00:10:30.240 --> 00:10:32.406
you could briefly stand up,
but you can't shoot down

00:10:32.406 --> 00:10:33.510
in original Metroid.

00:10:33.510 --> 00:10:35.425
So you want to roll
over here, but you

00:10:35.425 --> 00:10:37.460
would take too much damage.

00:10:37.460 --> 00:10:39.130
You maybe only have
one hit point left,

00:10:39.130 --> 00:10:40.690
so if there's any
of these guys left,

00:10:40.690 --> 00:10:42.315
you have to visit at
least one of these

00:10:42.315 --> 00:10:45.040
to kill all the monsters
and then get through.

00:10:45.040 --> 00:10:46.420
That's clause.

00:10:46.420 --> 00:10:49.760
Crossover is a little
more challenging.

00:10:49.760 --> 00:10:53.350
In this case, we set things up--
the idea is you come in here

00:10:53.350 --> 00:10:55.990
and you want to leave out there.

00:10:55.990 --> 00:10:57.130
So it's uni-directional.

00:10:57.130 --> 00:10:59.510
You can't go up in this gadget.

00:10:59.510 --> 00:11:02.090
And the idea is
there's a little gap

00:11:02.090 --> 00:11:05.330
and it's moving this way as
the monsters move around.

00:11:05.330 --> 00:11:07.510
So you wait for the
gap to come here.

00:11:07.510 --> 00:11:09.080
Then, you go down
and then, you're

00:11:09.080 --> 00:11:13.650
basically forced in timing
when you fall down this cavern.

00:11:13.650 --> 00:11:19.330
And it's set up so that by the
time this thing gets to here,

00:11:19.330 --> 00:11:21.630
these guys will have
come to the other side.

00:11:21.630 --> 00:11:23.275
Then, you have to
roll to the right

00:11:23.275 --> 00:11:25.400
in order to avoid taking
damage from these guys who

00:11:25.400 --> 00:11:28.000
are going around the
other way and similarly

00:11:28.000 --> 00:11:30.010
in the other direction.

00:11:30.010 --> 00:11:32.710
So you have to get the timing
right and we haven't exactly

00:11:32.710 --> 00:11:36.210
tested this yet, but it should
be approximately correct.

00:11:36.210 --> 00:11:38.670
And that will force a crossover.

00:11:38.670 --> 00:11:41.170
Should be a simpler way, but
that's the best crossover

00:11:41.170 --> 00:11:43.430
we have currently.

00:11:43.430 --> 00:11:45.350
So Metroid is NP.

00:11:45.350 --> 00:11:48.190
Here, we actually
claim NP-completeness,

00:11:48.190 --> 00:11:51.800
because there isn't too
much state to the game.

00:11:51.800 --> 00:11:54.800
So the issue here is the
length of a solution polynomial

00:11:54.800 --> 00:11:55.300
length.

00:11:55.300 --> 00:12:00.100
If it is, then it's
in NP and NP-complete.

00:12:00.100 --> 00:12:03.830
And here, you can kill
each monster only once.

00:12:03.830 --> 00:12:07.912
So that's the idea for--
and the amount of state

00:12:07.912 --> 00:12:10.370
you have is just your position
and what items you currently

00:12:10.370 --> 00:12:10.870
have.

00:12:10.870 --> 00:12:13.024
So you should be able
to solve this in NP

00:12:13.024 --> 00:12:14.690
and that sort of
settles the complexity.

00:12:14.690 --> 00:12:17.023
Most of these other problems
could potentially be harder

00:12:17.023 --> 00:12:19.540
than NP and we have
some other results

00:12:19.540 --> 00:12:21.166
like that, which
we may get to when

00:12:21.166 --> 00:12:22.290
we're talking about PSPACE.

00:12:22.290 --> 00:12:24.706
But today is about NP.

00:12:24.706 --> 00:12:25.830
Here's Donkey Kong Country.

00:12:25.830 --> 00:12:29.820
If you haven't played,
this is a speed run

00:12:29.820 --> 00:12:33.130
and you can kill
monsters by rolling.

00:12:33.130 --> 00:12:37.410
Most of the time, you're
jumping and collecting bananas.

00:12:37.410 --> 00:12:39.750
There are these bees
that if you touch them,

00:12:39.750 --> 00:12:43.796
you die or you sort of
have two hit points.

00:12:43.796 --> 00:12:45.170
And then, there
are these barrels

00:12:45.170 --> 00:12:47.470
you can pick up-- that's a
giant bee-- you can pick up

00:12:47.470 --> 00:12:50.080
certain barrels and then
throw them at a monster

00:12:50.080 --> 00:12:52.435
and, in this case,
damage, usually kill them.

00:12:52.435 --> 00:12:53.810
Then, there are
these other types

00:12:53.810 --> 00:12:55.309
of barrels that
when you touch them,

00:12:55.309 --> 00:12:57.070
they shoot you in a
predefined direction

00:12:57.070 --> 00:12:59.600
and let you collect
lots of bananas.

00:12:59.600 --> 00:13:03.620
So those are the rules of
Donkey Kong in a nutshell,

00:13:03.620 --> 00:13:05.386
in a banana shell.

00:13:05.386 --> 00:13:06.510
AUDIENCE: In a banana peel?

00:13:06.510 --> 00:13:09.560
PROFESSOR: Sorry, in a
banana peel, thank you.

00:13:09.560 --> 00:13:13.141
So here's a simple
crossover with that setup.

00:13:13.141 --> 00:13:14.890
You just have these
barrels that shoot you

00:13:14.890 --> 00:13:16.380
in a predefined
direction and force

00:13:16.380 --> 00:13:17.838
you to go through
this intersection

00:13:17.838 --> 00:13:18.810
without any choice.

00:13:18.810 --> 00:13:22.080
When you're being
shot, you cannot move.

00:13:22.080 --> 00:13:24.540
So that's easy.

00:13:24.540 --> 00:13:26.110
Again, variables
the same as Mario,

00:13:26.110 --> 00:13:27.560
you fall left or fall right.

00:13:27.560 --> 00:13:30.430
And a clause-- it's a little
hard to see with the background

00:13:30.430 --> 00:13:33.220
here, but there's a
little ledge here.

00:13:33.220 --> 00:13:36.980
And you can come down this
way, pick up this barrel,

00:13:36.980 --> 00:13:39.230
and throw it over here.

00:13:39.230 --> 00:13:42.620
And it will eventually
hit this bee,

00:13:42.620 --> 00:13:45.390
so that later, you can
traverse this gadget

00:13:45.390 --> 00:13:46.770
without dying from the bee.

00:13:46.770 --> 00:13:50.850
So not drawn is a platform
that you need to-- or maybe

00:13:50.850 --> 00:13:53.300
you're falling all the
way through these things

00:13:53.300 --> 00:13:55.200
if you set up all the
clauses vertically.

00:13:55.200 --> 00:13:57.669
And if there's any bee left,
you will die, otherwise not,

00:13:57.669 --> 00:13:59.210
and so you have to
visit at least one

00:13:59.210 --> 00:14:01.144
of these three barrels
to kill the bee.

00:14:04.050 --> 00:14:06.760
And I think this is a
mechanism to prevent you

00:14:06.760 --> 00:14:10.340
from carrying this barrel
anywhere else, like climbing up

00:14:10.340 --> 00:14:12.550
or something.

00:14:12.550 --> 00:14:14.720
Anyway, that's
Donkey Kong Country.

00:14:14.720 --> 00:14:18.020
I think there's
one more, Pokemon.

00:14:18.020 --> 00:14:19.020
I'm kind of embarrassed.

00:14:19.020 --> 00:14:20.740
I've never actually
played a Pokemon game.

00:14:20.740 --> 00:14:22.240
I don't know if I
should admit this,

00:14:22.240 --> 00:14:27.870
but I need to sit down and
play them all some weekend.

00:14:27.870 --> 00:14:30.939
I did watch Twitch
play it for a while.

00:14:30.939 --> 00:14:32.730
AUDIENCE: Going back
to the previous slide,

00:14:32.730 --> 00:14:38.650
in some of the other gadgets,
if we satisfied a clause,

00:14:38.650 --> 00:14:44.340
there was no way to--
there was a barrier

00:14:44.340 --> 00:14:47.560
between setting the
clause and going

00:14:47.560 --> 00:14:49.580
through the rest of that thing.

00:14:49.580 --> 00:14:52.000
So potentially, you could
get to the last clause

00:14:52.000 --> 00:14:56.480
here, kill the bee, and just
walk forward without-- can

00:14:56.480 --> 00:15:00.690
we with the rest of the stuff?

00:15:00.690 --> 00:15:02.890
PROFESSOR: Good question.

00:15:02.890 --> 00:15:04.550
Yeah, I think
probably the right way

00:15:04.550 --> 00:15:07.970
to set this up-- I'm not quite
sure how to do it directly

00:15:07.970 --> 00:15:11.210
from the drawing, but an easy
way to do it would be there's

00:15:11.210 --> 00:15:13.440
no floor below here.

00:15:13.440 --> 00:15:16.370
And at the end, when you
solved all the things,

00:15:16.370 --> 00:15:17.990
there is one of
these barrels that

00:15:17.990 --> 00:15:21.264
shoots you straight to the left
until you get to the finish.

00:15:21.264 --> 00:15:22.020
AUDIENCE: Ah.

00:15:22.020 --> 00:15:24.714
PROFESSOR: So if you tried
to exit the clause early,

00:15:24.714 --> 00:15:26.130
you would just
fall to your death,

00:15:26.130 --> 00:15:28.500
because there's only one barrel
shooting way over on the right.

00:15:28.500 --> 00:15:29.600
That would be one solution.

00:15:29.600 --> 00:15:31.141
I forget exactly
what's in the paper,

00:15:31.141 --> 00:15:33.487
but it wouldn't surprise
me if it's that.

00:15:33.487 --> 00:15:34.320
Yeah, good question.

00:15:34.320 --> 00:15:36.403
You definitely don't want
to be able to just visit

00:15:36.403 --> 00:15:39.150
the last clause, kill
the guy, and then exit.

00:15:39.150 --> 00:15:42.174
That would be cheating.

00:15:42.174 --> 00:15:43.590
But in these proofs,
that's always

00:15:43.590 --> 00:15:45.980
what you have to worry about
is this type of cheating.

00:15:45.980 --> 00:15:48.380
Other questions?

00:15:48.380 --> 00:15:50.500
Cool.

00:15:50.500 --> 00:15:58.387
Pokemon time-- so Pokemon is
a somewhat complicated game.

00:15:58.387 --> 00:16:00.220
It's a lot of different
abilities and so on.

00:16:00.220 --> 00:16:03.080
So we had to abstract things
away and in these pictures,

00:16:03.080 --> 00:16:05.630
there are two types
of-- I haven't

00:16:05.630 --> 00:16:06.840
defined any of the rules yet.

00:16:06.840 --> 00:16:10.900
You are a little person
walking around here.

00:16:10.900 --> 00:16:12.960
You're carrying
Pokemon, whatever.

00:16:12.960 --> 00:16:15.530
And there are these
characters called

00:16:15.530 --> 00:16:20.770
trainers and the red trainers
are called "weak" trainers.

00:16:20.770 --> 00:16:22.502
These are people
that when you visit,

00:16:22.502 --> 00:16:23.710
they just sort of deactivate.

00:16:23.710 --> 00:16:24.730
You beat them.

00:16:24.730 --> 00:16:26.374
And then, there's blue trainers.

00:16:26.374 --> 00:16:27.790
We'll call them
"strong" trainers.

00:16:27.790 --> 00:16:31.190
Those are ones that no
matter when or how you try

00:16:31.190 --> 00:16:32.920
to play them, you always die.

00:16:32.920 --> 00:16:37.210
And so you fail, so you never
want to visit a blue trainer.

00:16:37.210 --> 00:16:39.900
Now, trainers have two
kinds of-- let's talk

00:16:39.900 --> 00:16:40.830
about variables maybe.

00:16:40.830 --> 00:16:43.490
This is an easy situation.

00:16:43.490 --> 00:16:46.429
So a variable, you want
to come in the "in"

00:16:46.429 --> 00:16:48.720
and either leave in the
"false" or leave in the "true."

00:16:48.720 --> 00:16:50.830
And there are two ways
to activate a trainer.

00:16:50.830 --> 00:16:53.940
One is to walk into their
field of view, which are

00:16:53.940 --> 00:16:55.490
drawn with these rectangles.

00:16:55.490 --> 00:16:59.070
If you walk to this position,
the trainer will walk to you

00:16:59.070 --> 00:17:01.330
and then you fight the trainer.

00:17:01.330 --> 00:17:04.099
And because it's
red, you'll win.

00:17:04.099 --> 00:17:06.230
And so in that case,
the trainers moved here.

00:17:06.230 --> 00:17:09.900
Trainers are obstacles, so you
can't get to the true anymore.

00:17:09.900 --> 00:17:11.719
You have to go around to false.

00:17:11.719 --> 00:17:13.260
The other way you
can visit a trainer

00:17:13.260 --> 00:17:16.160
is to talk to them from
the side or from behind.

00:17:16.160 --> 00:17:18.720
So you can walk here, talk
to the trainer, beat them,

00:17:18.720 --> 00:17:19.710
then they deactivate.

00:17:19.710 --> 00:17:21.599
Then, you can walk this way.

00:17:21.599 --> 00:17:23.000
And you can only
fight them once.

00:17:23.000 --> 00:17:23.790
Then, it's over.

00:17:23.790 --> 00:17:25.099
They won't move anymore.

00:17:25.099 --> 00:17:27.275
So that forces you
to do true or false

00:17:27.275 --> 00:17:28.650
and then commit
to that decision.

00:17:31.530 --> 00:17:34.530
And these are obviously
obstacles that are immovable.

00:17:34.530 --> 00:17:35.030
All right.

00:17:35.030 --> 00:17:41.090
So the idea with the
clause is the following.

00:17:41.090 --> 00:17:43.500
When you're traversing
the clause at the end,

00:17:43.500 --> 00:17:46.110
you want to walk
through here and leave.

00:17:46.110 --> 00:17:48.450
And the worry is this position.

00:17:48.450 --> 00:17:54.740
If this trainer can come
to you, you will die.

00:17:54.740 --> 00:18:01.460
So that will be possible
exactly when all of these guys

00:18:01.460 --> 00:18:02.372
are out of the way.

00:18:02.372 --> 00:18:03.830
When will they come
out of the way?

00:18:03.830 --> 00:18:06.051
When you walk through
them-- and none of them

00:18:06.051 --> 00:18:07.050
have been activated yet.

00:18:07.050 --> 00:18:08.758
So then, they will
walk one space to you.

00:18:08.758 --> 00:18:11.630
You'll win, but it's temporary.

00:18:11.630 --> 00:18:14.420
You win the battle, lose the
war, because when you get here,

00:18:14.420 --> 00:18:16.236
then this guy can walk through.

00:18:16.236 --> 00:18:17.860
But these serve as
obstacles otherwise.

00:18:17.860 --> 00:18:21.820
So if you can come
down one of these paths

00:18:21.820 --> 00:18:24.260
and visit the trainer
early, then later when

00:18:24.260 --> 00:18:26.260
you come through, they
will not move toward you.

00:18:26.260 --> 00:18:28.870
They will stay an obstacle for
this guy in, so this guy cannot

00:18:28.870 --> 00:18:30.000
walk to you.

00:18:30.000 --> 00:18:32.190
This is just to make a barrier.

00:18:32.190 --> 00:18:36.200
And then, you can get through.

00:18:36.200 --> 00:18:40.060
Crossover, you get
the idea, right?

00:18:40.060 --> 00:18:42.860
We could try to walk through
it, but it's definitely

00:18:42.860 --> 00:18:43.620
complicated.

00:18:43.620 --> 00:18:46.810
In general, we want to go from
x to x prime or y to y prime.

00:18:46.810 --> 00:18:48.941
Again, it's directional.

00:18:48.941 --> 00:18:50.940
And now that I know the
right color assignment--

00:18:50.940 --> 00:18:58.750
red is weak-- I would guess
this guy is an obstacle.

00:18:58.750 --> 00:19:01.510
But as soon as you go this way,
this guy moves out of the way.

00:19:01.510 --> 00:19:05.010
So it kind of closes off
trying to return this way.

00:19:05.010 --> 00:19:07.170
So once you come
through here, this

00:19:07.170 --> 00:19:08.690
would be a problem to come back.

00:19:08.690 --> 00:19:10.880
So that kind of cuts
you off from going back

00:19:10.880 --> 00:19:13.320
and it's kind of
like the crossover

00:19:13.320 --> 00:19:18.140
we saw with push-one
2D, I believe.

00:19:18.140 --> 00:19:20.695
Then, you probably go here.

00:19:20.695 --> 00:19:23.980
A similar thing happens.

00:19:23.980 --> 00:19:31.020
This guy will approach, come to
you, and then you can escape.

00:19:31.020 --> 00:19:33.860
When you get here, this guy
will come all the way down.

00:19:33.860 --> 00:19:35.716
Oh, that looks bad.

00:19:35.716 --> 00:19:36.967
AUDIENCE: Can you [INAUDIBLE]?

00:19:36.967 --> 00:19:38.549
PROFESSOR: Yeah, so
probably we should

00:19:38.549 --> 00:19:39.640
have talked to him early.

00:19:39.640 --> 00:19:42.510
So then, we can come through
here without any trouble,

00:19:42.510 --> 00:19:44.031
succeed in getting
down to y prime.

00:19:44.031 --> 00:19:46.030
You have to check that
you can't get to x prime.

00:19:46.030 --> 00:19:48.930
This looks like an impossible
nexus to get through,

00:19:48.930 --> 00:19:50.290
but these guys can walk through.

00:19:50.290 --> 00:19:52.581
That's the reason
they're there instead

00:19:52.581 --> 00:19:53.580
of just being obstacles.

00:19:56.380 --> 00:19:58.110
Left to right should be-- sorry?

00:19:58.110 --> 00:20:00.680
AUDIENCE: They can only see
you five or six tiles away.

00:20:00.680 --> 00:20:03.920
PROFESSOR: This is a
generalized Pokemon.

00:20:03.920 --> 00:20:05.700
Yeah, it would be nice.

00:20:05.700 --> 00:20:08.900
Obviously, this is a
bounded visibility.

00:20:08.900 --> 00:20:12.710
It would be nice to
get that down smaller,

00:20:12.710 --> 00:20:15.790
but at least this shows
constant visibility is enough,

00:20:15.790 --> 00:20:19.180
because these gadgets
are all local.

00:20:19.180 --> 00:20:20.550
It would maybe also be nice.

00:20:20.550 --> 00:20:22.396
Are they all the
same visibility?

00:20:22.396 --> 00:20:24.604
AUDIENCE: Yeah, it's just
some fixed amount of tiles.

00:20:24.604 --> 00:20:27.700
PROFESSOR: So it would be nice
if they were also all the same.

00:20:27.700 --> 00:20:33.360
That does not currently hold,
but it wouldn't surprise me

00:20:33.360 --> 00:20:37.212
if that-- well, yeah, tricky.

00:20:37.212 --> 00:20:38.660
All right.

00:20:38.660 --> 00:20:41.970
I'll just mention for a
little bit of Pokemon cred,

00:20:41.970 --> 00:20:45.550
this is one paragraph
of our paper

00:20:45.550 --> 00:20:54.070
where we construct the weak
and the strong trainers

00:20:54.070 --> 00:20:57.000
using exactly the setup that's
available in various Pokemon

00:20:57.000 --> 00:20:59.030
games.

00:20:59.030 --> 00:21:02.160
I believe in every
single game there

00:21:02.160 --> 00:21:06.150
are enough abilities that you
can set up so that you either

00:21:06.150 --> 00:21:09.080
force the bad guy to all
he can do is self-destruct

00:21:09.080 --> 00:21:14.140
or all he can do is kill you and
you lose, that sort of thing.

00:21:14.140 --> 00:21:18.860
But it requires some
Pokemon expertise which

00:21:18.860 --> 00:21:20.520
Alan Guo had in this case.

00:21:20.520 --> 00:21:22.590
He's a PhD student
in C-Cell here.

00:21:25.710 --> 00:21:28.750
Any other questions
about Nintendo games

00:21:28.750 --> 00:21:30.010
before we move on?

00:21:30.010 --> 00:21:32.180
AUDIENCE: This is a common
sort of Pokemon specific.

00:21:32.180 --> 00:21:36.080
In Generation One, moves
can miss with a one and two

00:21:36.080 --> 00:21:39.344
[INAUDIBLE] even if
their accuracy is 100%.

00:21:39.344 --> 00:21:40.332
Are you good with this?

00:21:43.296 --> 00:21:45.272
AUDIENCE: It's self-destructing.

00:21:45.272 --> 00:21:46.669
AUDIENCE: [INAUDIBLE].

00:21:46.669 --> 00:21:48.710
AUDIENCE: The self-destruct
means he doesn't die.

00:21:48.710 --> 00:21:50.195
AUDIENCE: No, the
self-destruct doesn't matter

00:21:50.195 --> 00:21:51.680
whether he does damage, right?

00:21:51.680 --> 00:21:54.592
It's just
self-destruct, you die.

00:21:54.592 --> 00:21:57.050
AUDIENCE: I think self-destruct,
the death doesn't actually

00:21:57.050 --> 00:21:58.460
happen if the attack misses.

00:21:58.460 --> 00:21:59.102
Can you?

00:21:59.102 --> 00:22:00.060
PROFESSOR: No, it does.

00:22:00.060 --> 00:22:00.610
It does.

00:22:00.610 --> 00:22:00.880
AUDIENCE: Really?

00:22:00.880 --> 00:22:01.380
OK.

00:22:01.380 --> 00:22:04.370
PROFESSOR: Yeah, it does.

00:22:04.370 --> 00:22:05.450
We'll have to go play.

00:22:08.240 --> 00:22:08.749
All right.

00:22:08.749 --> 00:22:10.290
The next game I'm
going to talk about

00:22:10.290 --> 00:22:14.250
is a sort of physical game
that you play on usually a go

00:22:14.250 --> 00:22:15.970
board with go stones.

00:22:15.970 --> 00:22:18.360
So they're white stones
and black stones.

00:22:18.360 --> 00:22:21.600
It was invented by
this guy, John Conway.

00:22:21.600 --> 00:22:24.267
And so if you've ever played
Conway's Game of Life,

00:22:24.267 --> 00:22:25.350
that's a zero-player game.

00:22:25.350 --> 00:22:28.270
This is an actual two-player
game and quite challenging.

00:22:28.270 --> 00:22:30.210
Here's the general idea.

00:22:30.210 --> 00:22:33.820
There's a right player trying
to get the white ball-- that's

00:22:33.820 --> 00:22:35.030
the "football."

00:22:35.030 --> 00:22:37.496
This is philosophers'
football, if you will.

00:22:37.496 --> 00:22:40.200
You're trying to get this
ball over to that goal

00:22:40.200 --> 00:22:42.860
and the left player's trying to
get the ball to the right goal.

00:22:42.860 --> 00:22:45.480
Then, there are these black
pieces, which are called "men."

00:22:45.480 --> 00:22:48.860
Those are the players of
the game, so to speak.

00:22:48.860 --> 00:22:51.240
And there are two types
of moves in this game.

00:22:51.240 --> 00:22:55.380
One move you can do is just
place a black stone anywhere

00:22:55.380 --> 00:22:57.759
on the board that's
currently empty.

00:22:57.759 --> 00:23:00.050
And the other type of move
is the more complicated one.

00:23:00.050 --> 00:23:01.810
This is called
"kicking the ball."

00:23:01.810 --> 00:23:04.420
You can take the
white piece and you

00:23:04.420 --> 00:23:08.120
can jump it over a string
of consecutive black pieces.

00:23:08.120 --> 00:23:10.130
Those pieces are
immediately removed,

00:23:10.130 --> 00:23:12.280
so this gray shading
means they've

00:23:12.280 --> 00:23:13.980
been removed from the board.

00:23:13.980 --> 00:23:17.060
But in the same move, you
can do several such jumps.

00:23:17.060 --> 00:23:18.470
So I can jump here.

00:23:18.470 --> 00:23:20.380
Then, I can jump here.

00:23:20.380 --> 00:23:22.580
Then, I can jump here.

00:23:22.580 --> 00:23:24.040
Then, I can jump here.

00:23:24.040 --> 00:23:27.240
And everything I jump
over-- in this case, I won.

00:23:27.240 --> 00:23:29.850
If I'm the right player,
I got to that position.

00:23:29.850 --> 00:23:31.350
So this is why
the right player--

00:23:31.350 --> 00:23:32.933
from the original
position, maybe they

00:23:32.933 --> 00:23:36.130
wanted to place this stone
because that would enable

00:23:36.130 --> 00:23:38.980
in their next move-- you
can't place a black stone

00:23:38.980 --> 00:23:39.620
and then jump.

00:23:39.620 --> 00:23:41.010
You can do one or the other.

00:23:41.010 --> 00:23:43.040
So you could try to
place this position,

00:23:43.040 --> 00:23:46.160
place this stone hoping
that in your next turn,

00:23:46.160 --> 00:23:48.580
you'll be able to do
this jump and win.

00:23:48.580 --> 00:23:52.990
But instead from this position,
the left player could say,

00:23:52.990 --> 00:23:56.750
oh, well, I'll just add this
stone and then in my next move,

00:23:56.750 --> 00:23:59.110
I'll be able to jump
to the right side.

00:23:59.110 --> 00:24:01.540
And that's, I
think, unblockable.

00:24:01.540 --> 00:24:03.945
So left wins.

00:24:03.945 --> 00:24:04.445
Yea!

00:24:07.130 --> 00:24:09.190
So that's the setup.

00:24:09.190 --> 00:24:12.360
This is a fairly
complicated game.

00:24:12.360 --> 00:24:15.530
You can get to the same
position multiple times

00:24:15.530 --> 00:24:19.310
and so it's actually open
how hard this game is.

00:24:19.310 --> 00:24:20.810
I think there's an
upper bound of it

00:24:20.810 --> 00:24:23.615
being solvable in exponential
time, so it's in EXP.

00:24:23.615 --> 00:24:25.590
AUDIENCE: What do you
mean by "solvable?"

00:24:25.590 --> 00:24:27.450
PROFESSOR: So given
a position, you

00:24:27.450 --> 00:24:29.180
want to know whether
left or right will

00:24:29.180 --> 00:24:30.795
win from this position.

00:24:30.795 --> 00:24:33.340
AUDIENCE: Is it possible
that it doesn't terminate?

00:24:33.340 --> 00:24:37.110
PROFESSOR: I could be a
tie is the right answer.

00:24:37.110 --> 00:24:38.940
So that's tricky.

00:24:38.940 --> 00:24:41.980
There is a piece-base hardness
result relatively recent,

00:24:41.980 --> 00:24:45.860
but an old result of
ours with David Eppstein

00:24:45.860 --> 00:24:50.100
is that just determining
whether you can win in one move

00:24:50.100 --> 00:24:51.810
is NP-complete.

00:24:51.810 --> 00:24:53.310
So that's a relatively
clean thing.

00:24:53.310 --> 00:24:55.444
You don't have to worry
about non-termination

00:24:55.444 --> 00:24:56.360
or that sort of thing.

00:24:56.360 --> 00:24:58.480
It's just one player's move.

00:24:58.480 --> 00:25:00.785
Here, everything is reversed.

00:25:03.830 --> 00:25:05.620
The ball is black in this case.

00:25:05.620 --> 00:25:09.950
I'm not sure if there's a
consistent notion, anyway.

00:25:09.950 --> 00:25:13.250
And this is actually a
reduction all on one slide.

00:25:13.250 --> 00:25:14.340
It's pretty simple.

00:25:14.340 --> 00:25:16.704
So this is what we call
the mate in one problem.

00:25:16.704 --> 00:25:18.370
And you can take lots
of different games

00:25:18.370 --> 00:25:20.870
and make them really
clean, well-defined puzzles

00:25:20.870 --> 00:25:23.070
if you just ask, can
I win in one move?

00:25:23.070 --> 00:25:26.720
Even games that involve cards
and randomness and weird stuff.

00:25:26.720 --> 00:25:29.450
And one movie usually
doesn't involve those at all.

00:25:29.450 --> 00:25:32.570
Anyway, here, we're getting rid
of the loopiness of the game

00:25:32.570 --> 00:25:34.580
and not having to
worry about that.

00:25:34.580 --> 00:25:37.500
So there's sort of two
parts to this proof,

00:25:37.500 --> 00:25:39.504
the variable traversal
and the clause traversal.

00:25:39.504 --> 00:25:41.420
But here, we have a kind
of very different way

00:25:41.420 --> 00:25:42.669
of connecting things together.

00:25:42.669 --> 00:25:45.880
We have a giant
matrix, if you will.

00:25:45.880 --> 00:25:48.130
We're starting up
here and we have

00:25:48.130 --> 00:25:51.190
a choice whether-- if we
want to set x1 to true,

00:25:51.190 --> 00:25:54.350
we're just going to go to the
right by a sequence of jumps.

00:25:54.350 --> 00:25:56.800
We jump here, then
here, then here.

00:25:56.800 --> 00:25:59.290
Every time we stop,
we have no choice.

00:25:59.290 --> 00:26:01.800
If we want to keep
going, our goal

00:26:01.800 --> 00:26:06.830
is to get to somewhere, one
of the edges of the board,

00:26:06.830 --> 00:26:08.800
I think the bottom edge.

00:26:08.800 --> 00:26:12.534
Bottom edge is the one
that's hard to get to.

00:26:12.534 --> 00:26:14.200
So every time we jump
to the right here,

00:26:14.200 --> 00:26:15.158
we don't have a choice.

00:26:15.158 --> 00:26:17.150
We have to keep
jumping to the right.

00:26:17.150 --> 00:26:18.530
But over here, we have a choice.

00:26:18.530 --> 00:26:22.611
We could go down and then jump
to the right and get over here

00:26:22.611 --> 00:26:24.610
and that will do different
things in the middle.

00:26:24.610 --> 00:26:26.807
In general, that is
our setting of x1.

00:26:26.807 --> 00:26:28.890
Then, we're going to do
the same thing coming back

00:26:28.890 --> 00:26:30.630
for x2 of two choices.

00:26:30.630 --> 00:26:33.390
Then, the same thing
going back for x3

00:26:33.390 --> 00:26:35.370
and then we get to this corner.

00:26:35.370 --> 00:26:37.780
So that's forced other
than these two choices,

00:26:37.780 --> 00:26:39.950
binary choices.

00:26:39.950 --> 00:26:43.230
Now, we have our first clause.

00:26:43.230 --> 00:26:47.540
Let's say x1 negated or
x2 negated or x3 negated.

00:26:47.540 --> 00:26:49.830
We want one of those
things to be true.

00:26:49.830 --> 00:26:52.750
And so the idea is we're
going to choose whichever

00:26:52.750 --> 00:26:57.089
one has been set correctly and
then we will go up that channel

00:26:57.089 --> 00:26:57.880
and get to the top.

00:26:57.880 --> 00:26:59.920
Again, it's pretty
much symmetric.

00:26:59.920 --> 00:27:02.100
So every time we jump
over a bunch of pieces,

00:27:02.100 --> 00:27:04.300
whenever we stop, we
can't go left or right.

00:27:04.300 --> 00:27:05.500
We have to keep going up.

00:27:05.500 --> 00:27:08.060
So we have to make
it all the way.

00:27:08.060 --> 00:27:11.710
In fact, each of these columns
will be completely filled

00:27:11.710 --> 00:27:14.140
except for one
intersection, which is

00:27:14.140 --> 00:27:16.400
the thing that makes it false.

00:27:16.400 --> 00:27:19.590
So here, we want x2 to be false.

00:27:19.590 --> 00:27:24.050
So if we happen to follow the
true path where x2 is true,

00:27:24.050 --> 00:27:26.840
we won't make it because
this piece will already

00:27:26.840 --> 00:27:29.170
have been removed when
we came through here.

00:27:29.170 --> 00:27:31.600
And so if we try to take this
path, we'll get stuck here.

00:27:31.600 --> 00:27:34.780
There won't be any
piece above us.

00:27:34.780 --> 00:27:38.680
As long as that didn't happen,
as long as this row was not

00:27:38.680 --> 00:27:40.830
chosen, then we can
take this column

00:27:40.830 --> 00:27:43.094
and just make it all
the way up to the top.

00:27:43.094 --> 00:27:45.510
So we're going to be able to
take one of these three paths

00:27:45.510 --> 00:27:48.140
if and only if at least one
of these things is true.

00:27:48.140 --> 00:27:49.970
That's the first clause.

00:27:49.970 --> 00:27:52.380
Then, we do the same thing
for the second clause.

00:27:52.380 --> 00:27:53.860
And if all of the
clauses are true,

00:27:53.860 --> 00:27:55.930
we will be able to
get here and then

00:27:55.930 --> 00:27:59.010
we can jump down and
get to the finish line

00:27:59.010 --> 00:28:03.440
and win in one move, one move.

00:28:03.440 --> 00:28:07.560
So mate in one is NP-complete.

00:28:07.560 --> 00:28:09.740
I have one other example
of a mate in one result.

00:28:09.740 --> 00:28:12.156
It's actually not a hardness
result, but it's kind of fun,

00:28:12.156 --> 00:28:15.150
so I thought I would talk about
a non-hardness result for once,

00:28:15.150 --> 00:28:16.560
which is checkers.

00:28:16.560 --> 00:28:18.370
Checkers is another
game where in one move,

00:28:18.370 --> 00:28:19.580
you can do a lot of jumps.

00:28:19.580 --> 00:28:22.010
Especially if you
have a king, then you

00:28:22.010 --> 00:28:26.960
can potentially win by killing
a lot of pieces all at once.

00:28:26.960 --> 00:28:28.860
And this is considered
back in 1978.

00:28:28.860 --> 00:28:30.360
This is the same
paper that proves

00:28:30.360 --> 00:28:33.300
checkers is
EXPTIME-complete, which

00:28:33.300 --> 00:28:35.569
we will get to at some point.

00:28:35.569 --> 00:28:37.860
But for now, let's think
about the mate in one problem.

00:28:37.860 --> 00:28:41.780
This turns out to be
easy, unlike phutball.

00:28:41.780 --> 00:28:46.820
So checkers-- I assume
you've all played checkers.

00:28:46.820 --> 00:28:50.530
You can only move diagonally
on the black squares.

00:28:50.530 --> 00:28:54.420
So you can recast that
into an orthogonal problem

00:28:54.420 --> 00:28:58.230
where the pieces can only
move orthogonally up or right

00:28:58.230 --> 00:29:00.797
or vice versa,
except king pieces.

00:29:00.797 --> 00:29:02.130
They can just move orthogonally.

00:29:02.130 --> 00:29:04.409
And the interesting part
is when you can jump over

00:29:04.409 --> 00:29:05.450
a piece of another color.

00:29:05.450 --> 00:29:09.810
So if there was a black piece
here, this one can jump over.

00:29:09.810 --> 00:29:13.180
And in general, if you have a
sequence of jumps you can make,

00:29:13.180 --> 00:29:15.412
then you can do all
of them at once.

00:29:15.412 --> 00:29:17.120
So the problem looks
something like this.

00:29:17.120 --> 00:29:21.290
If you have a black piece and
let's say a black to move,

00:29:21.290 --> 00:29:25.400
if there are a bunch of white
pieces, you can jump over them.

00:29:25.400 --> 00:29:27.370
And the key thing
to notice-- again,

00:29:27.370 --> 00:29:29.370
as soon as you jump over
a piece, it disappears.

00:29:29.370 --> 00:29:31.630
So you can reuse
it in the same move

00:29:31.630 --> 00:29:34.390
or I guess you can't
reuse it in general.

00:29:34.390 --> 00:29:37.640
The key thing is that the jumps
preserve the parity, the even

00:29:37.640 --> 00:29:40.220
or oddness of both
your x-coordinate

00:29:40.220 --> 00:29:41.390
and your y-coordinate.

00:29:41.390 --> 00:29:43.610
So you're moving around
on this reduced grid.

00:29:43.610 --> 00:29:45.830
And so you can take
a picture like this

00:29:45.830 --> 00:29:49.160
and turn it into a graph
where the potential positions

00:29:49.160 --> 00:29:52.810
for you, which are drawn
with this kind of pattern,

00:29:52.810 --> 00:29:58.150
same parity of rows and columns.

00:29:58.150 --> 00:30:00.170
You could make those the
vertices of your graph.

00:30:00.170 --> 00:30:01.753
And then, there's
an edge between them

00:30:01.753 --> 00:30:04.480
if there's a white stone
in between that you

00:30:04.480 --> 00:30:06.420
could jump over.

00:30:06.420 --> 00:30:08.120
So then, given this
graph, the question

00:30:08.120 --> 00:30:10.440
is, can you visit all of
the edges of the graph

00:30:10.440 --> 00:30:12.000
with a single path?

00:30:12.000 --> 00:30:14.420
And that is the Euler tour
problem or the Euler path

00:30:14.420 --> 00:30:15.320
problem.

00:30:15.320 --> 00:30:17.770
And it's easy to solve
that in polynomial time.

00:30:17.770 --> 00:30:19.230
You look for
odd-degree vertices.

00:30:19.230 --> 00:30:21.820
There should be at most two of
them and you better be at one

00:30:21.820 --> 00:30:23.870
of them.

00:30:23.870 --> 00:30:25.050
Or there's zero of them.

00:30:25.050 --> 00:30:26.830
Then, you're happy.

00:30:26.830 --> 00:30:28.799
So that's how to
solve mate in one

00:30:28.799 --> 00:30:31.340
in checkers, in case you ever
get to those difficult checkers

00:30:31.340 --> 00:30:32.160
endgames.

00:30:32.160 --> 00:30:36.930
And now, you can decide how
to win or not in one move.

00:30:36.930 --> 00:30:40.690
Two moves is left to you.

00:30:40.690 --> 00:30:41.930
All right.

00:30:41.930 --> 00:30:45.760
So next topic is
called cryptarithms.

00:30:45.760 --> 00:30:48.950
This comes from the
recreational math world

00:30:48.950 --> 00:30:49.970
and they're kind of fun.

00:30:49.970 --> 00:30:52.261
You've probably seen this or
you may have seen this one

00:30:52.261 --> 00:30:53.765
if you've seen any cryptarithm.

00:30:53.765 --> 00:30:54.390
It's a classic.

00:30:54.390 --> 00:30:58.310
It goes back to 1979 from
this book by Madachy.

00:30:58.310 --> 00:31:01.490
And the idea is this is
an arithmetic formula,

00:31:01.490 --> 00:31:04.070
SEND plus MORE equals MONEY.

00:31:04.070 --> 00:31:07.300
And each of these letters
represents a digit zero

00:31:07.300 --> 00:31:08.230
through nine.

00:31:08.230 --> 00:31:13.200
And so these two M's represent
the same digit and so on.

00:31:13.200 --> 00:31:15.105
Two n's represent
the same digits.

00:31:15.105 --> 00:31:17.280
Those two O's represent
the same digit.

00:31:17.280 --> 00:31:20.390
And furthermore, M is different
from O is differ from R.

00:31:20.390 --> 00:31:23.180
So it's a bijection
between the letters that

00:31:23.180 --> 00:31:27.340
appear in this puzzle and some
subset of zero through nine.

00:31:27.340 --> 00:31:29.100
And it actually has
a unique solution.

00:31:29.100 --> 00:31:29.640
This is it.

00:31:29.640 --> 00:31:31.320
You could verify it,
but I'll leave it

00:31:31.320 --> 00:31:33.980
as a puzzle so don't look at
that too long, in case you

00:31:33.980 --> 00:31:35.620
want to solve it.

00:31:35.620 --> 00:31:37.430
It is doable, but
the tricky part

00:31:37.430 --> 00:31:39.560
are things like the carries
in the addition, which

00:31:39.560 --> 00:31:43.280
make it not just a simple
linear system to solve.

00:31:43.280 --> 00:31:46.820
And in fact, these puzzles,
generalized to an arbitrary

00:31:46.820 --> 00:31:48.630
base, are NP-complete.

00:31:48.630 --> 00:31:51.310
If you do it in base
10, then there's

00:31:51.310 --> 00:31:54.900
only at most 10 factorial
possible solutions.

00:31:54.900 --> 00:31:57.404
So that's constant and
that's considered fast.

00:31:57.404 --> 00:31:58.820
And indeed, in
real computers, you

00:31:58.820 --> 00:32:03.370
can solve 10
factorial reasonably.

00:32:03.370 --> 00:32:07.060
So for generalized
base, here is a proof.

00:32:07.060 --> 00:32:08.630
This is actually
David Eppstein, who

00:32:08.630 --> 00:32:10.255
was a co-author in
the previous result.

00:32:10.255 --> 00:32:14.100
This is his first theory
paper, "SIGACT News."

00:32:14.100 --> 00:32:16.710
And it proved that it's
strongly NP-complete,

00:32:16.710 --> 00:32:20.130
meaning even if the
base is polynomial,

00:32:20.130 --> 00:32:22.490
the problem is NP-hard.

00:32:22.490 --> 00:32:27.010
And it looks really messy, but
actually, it's fairly simple.

00:32:27.010 --> 00:32:31.530
So let me start
with this gadget.

00:32:31.530 --> 00:32:33.110
This is an easy one.

00:32:33.110 --> 00:32:36.290
So there's no notion of
zero or one in this gadget,

00:32:36.290 --> 00:32:39.870
but zero is just a letter
and one is just a letter.

00:32:39.870 --> 00:32:42.390
But with this gadget
in place, 0 is

00:32:42.390 --> 00:32:48.270
0 and 1 is 1, because 0's
the only possible digit when

00:32:48.270 --> 00:32:50.780
you add it with yourself,
you get it again.

00:32:50.780 --> 00:32:54.340
It is the identity
in additive ring.

00:32:54.340 --> 00:32:56.980
So that forces 0 to be 0.

00:32:56.980 --> 00:33:01.632
And then, here, we're
adding p with p.

00:33:01.632 --> 00:33:03.180
P are just arbitrary things.

00:33:03.180 --> 00:33:04.920
We sort of don't
care what they are.

00:33:04.920 --> 00:33:06.420
We get something q.

00:33:06.420 --> 00:33:09.307
And over here, we add
0 to 0 and we get 1.

00:33:09.307 --> 00:33:11.015
That's only going to
be possible if there

00:33:11.015 --> 00:33:12.560
was a carry in this column.

00:33:12.560 --> 00:33:14.069
And carries can be only 1.

00:33:14.069 --> 00:33:14.860
They can be 0 or 1.

00:33:14.860 --> 00:33:16.680
So that forces--
we know it's not 0

00:33:16.680 --> 00:33:18.370
because 1 is different from 0.

00:33:18.370 --> 00:33:20.640
Therefore, 1 is 1.

00:33:20.640 --> 00:33:24.251
The symbol 1 is the value
one, the number one.

00:33:24.251 --> 00:33:24.750
All right.

00:33:24.750 --> 00:33:26.340
So that gives us
some infrastructure.

00:33:26.340 --> 00:33:27.756
And the zeroes are
really helpful,

00:33:27.756 --> 00:33:30.050
because it lets us space
out gadgets and guarantee

00:33:30.050 --> 00:33:31.990
that there's no
carry between them.

00:33:31.990 --> 00:33:33.730
This is supposed to
be a variable gadget.

00:33:33.730 --> 00:33:38.180
There's vi and there's vi bar.

00:33:38.180 --> 00:33:40.340
So let's see what happens.

00:33:40.340 --> 00:33:42.690
Let's do the vi part first.

00:33:42.690 --> 00:33:48.550
So this formula says
that bi equals twice ai.

00:33:48.550 --> 00:33:51.132
And there's guaranteed to
be no carry because of this.

00:33:51.132 --> 00:33:52.340
Now, this is a little tricky.

00:33:52.340 --> 00:33:54.750
We add yi to yi until we get zi.

00:33:54.750 --> 00:33:58.460
So there may be a
carry or not here.

00:33:58.460 --> 00:34:01.410
Then, we add bi to
bi and we get vi.

00:34:01.410 --> 00:34:07.780
So vi is going to be 2
times bi plus either 0 or 1.

00:34:07.780 --> 00:34:09.830
That's going to be
our binary choice.

00:34:09.830 --> 00:34:13.090
We can set up the yi's
to either carry or not.

00:34:13.090 --> 00:34:16.409
We'll call that C.
In this formulation,

00:34:16.409 --> 00:34:18.950
C is the carry in
that operation.

00:34:23.870 --> 00:34:25.380
And bi is 2 times ai.

00:34:25.380 --> 00:34:30.440
So this is 4 times ai
plus C, which is 0 or 1.

00:34:30.440 --> 00:34:34.530
And what we're going to
think about is modulo four.

00:34:34.530 --> 00:34:37.850
This is congruent
to C. So we're going

00:34:37.850 --> 00:34:40.440
to treat all of our variable
assignments modulo four

00:34:40.440 --> 00:34:43.290
and they're always
going to be 0 or 1.

00:34:43.290 --> 00:34:47.320
vi became this and the claim
is that this part makes

00:34:47.320 --> 00:34:49.940
vi bar the opposite.

00:34:49.940 --> 00:34:52.480
And you can work
through the arithmetic

00:34:52.480 --> 00:34:54.320
as I did in the notes.

00:34:54.320 --> 00:35:00.905
You end up vi bar has to be 4
times something, which is Ci.

00:35:00.905 --> 00:35:03.250
So we don't care what that is.

00:35:03.250 --> 00:35:08.600
We'll set it at the very
end, plus 3C plus 1.

00:35:08.600 --> 00:35:13.170
C is 1, this is 4,
and this becomes 0.

00:35:13.170 --> 00:35:17.410
If C is 0, this becomes 1 mod 4.

00:35:17.410 --> 00:35:19.420
So in general, it's
1 minus C. It's

00:35:19.420 --> 00:35:24.000
the opposite choice from what
vi was that becomes vi bar.

00:35:24.000 --> 00:35:24.690
So that's cool.

00:35:24.690 --> 00:35:25.440
We've got vi.

00:35:25.440 --> 00:35:26.540
We've got vi bar.

00:35:26.540 --> 00:35:28.820
We can duplicate our
variables for free,

00:35:28.820 --> 00:35:30.780
because we can just
use that same letter

00:35:30.780 --> 00:35:33.710
vi in many different
places and then

00:35:33.710 --> 00:35:36.540
we just need a clause gadget.

00:35:36.540 --> 00:35:42.380
And so the work is
similar kind of tricks.

00:35:42.380 --> 00:35:45.760
We add fi to itself, we get gi.

00:35:45.760 --> 00:35:48.200
We add gi to itself, we get hi.

00:35:48.200 --> 00:35:53.640
So at this point, we have 4
times fi plus possibly one

00:35:53.640 --> 00:35:54.490
carry.

00:35:54.490 --> 00:35:56.880
This wi might carry or not.

00:35:56.880 --> 00:36:09.060
So we get hi is 4
times fi plus 0 or 1.

00:36:09.060 --> 00:36:13.650
Then, we add hi to
1 and we get ti,

00:36:13.650 --> 00:36:17.230
plus there might be a
carry from this column.

00:36:17.230 --> 00:36:25.960
So that's ti is going to be hi
plus 1 plus a potential carry.

00:36:25.960 --> 00:36:34.520
hi is this thing, so we end up
with 4 times fi plus 1 plus 0

00:36:34.520 --> 00:36:39.770
or 1 or 2, depending on how many
carries we've had total, which

00:36:39.770 --> 00:36:46.480
is 4 times fi plus 1 or 2 or 3.

00:36:46.480 --> 00:36:49.360
And modulo four, that
is one or two or three.

00:36:49.360 --> 00:36:51.660
This is going to be the
number of true variables

00:36:51.660 --> 00:36:55.440
in our clause, because in the
end, we just add vi plus vb.

00:36:55.440 --> 00:36:56.470
We get this thing.

00:36:56.470 --> 00:37:00.640
We add vc for our three
variables, a, b, and c.

00:37:00.640 --> 00:37:03.090
We get ti.

00:37:03.090 --> 00:37:05.550
And ti was that thing.

00:37:05.550 --> 00:37:10.460
So if we just think about things
modulo four, that means va

00:37:10.460 --> 00:37:16.320
plus vb plus vc should
be 1, 2, or 3 mod four.

00:37:16.320 --> 00:37:20.490
Now, the reason we have this
junk-- and the junk's-- well,

00:37:20.490 --> 00:37:20.990
OK.

00:37:20.990 --> 00:37:23.050
There's the not
modulo four part,

00:37:23.050 --> 00:37:24.300
the part when you divide by 4.

00:37:24.300 --> 00:37:25.974
That's sort of tricky.

00:37:25.974 --> 00:37:28.140
But at this point, at least,
you should be convinced

00:37:28.140 --> 00:37:32.240
that if there's a solution
to this problem, then

00:37:32.240 --> 00:37:36.200
there must be a solution to
the original 3SAT instance.

00:37:36.200 --> 00:37:37.350
The reverse is less clear.

00:37:37.350 --> 00:37:39.090
If you have a solution
to the 3SAT instance,

00:37:39.090 --> 00:37:41.339
you have to be able to set
all these variables to make

00:37:41.339 --> 00:37:42.260
everything work out.

00:37:42.260 --> 00:37:44.760
That's a little more tedious.

00:37:44.760 --> 00:37:48.570
For fun, and this
is an old proof 1987

00:37:48.570 --> 00:37:51.780
and I was just looking
at it again today,

00:37:51.780 --> 00:37:54.360
I think, or I think
it was yesterday.

00:37:54.360 --> 00:37:56.650
I think I can simplify
it a little bit.

00:37:56.650 --> 00:37:59.390
Instead of using
regular 3SAT where

00:37:59.390 --> 00:38:02.260
you have all these choices, one,
two, or three things are true,

00:38:02.260 --> 00:38:05.440
if you use exactly
one 3SAT, one in 3SAT,

00:38:05.440 --> 00:38:07.100
it should be a lot easier.

00:38:07.100 --> 00:38:09.770
So gadgets are smaller.

00:38:09.770 --> 00:38:12.010
With one in 3SAT, we
don't need negation.

00:38:12.010 --> 00:38:13.810
So I just need
the vi part, which

00:38:13.810 --> 00:38:16.520
we did explicitly over here.

00:38:16.520 --> 00:38:19.300
So that's kind of nifty.

00:38:19.300 --> 00:38:22.280
And for exactly
one 3SAT, we don't

00:38:22.280 --> 00:38:23.610
need to have all those carries.

00:38:23.610 --> 00:38:27.310
We just need to build
four times something--

00:38:27.310 --> 00:38:30.150
sorry, that should be fi here.

00:38:30.150 --> 00:38:31.700
We add fi to itself.

00:38:31.700 --> 00:38:32.860
We add gi to itself.

00:38:32.860 --> 00:38:35.470
So here, we have 4 times fi.

00:38:35.470 --> 00:38:37.790
And then, we add 1.

00:38:37.790 --> 00:38:40.905
So this ti will be one mod four.

00:38:40.905 --> 00:38:42.280
And then, we add
the variables up

00:38:42.280 --> 00:38:44.347
and we should get
exactly one mod four.

00:38:44.347 --> 00:38:46.430
Now, admittedly, I haven't
checked the second half

00:38:46.430 --> 00:38:48.720
of the proof with
this construction,

00:38:48.720 --> 00:38:50.360
but it seems
plausible this would

00:38:50.360 --> 00:38:52.370
be a somewhat simpler proof.

00:38:52.370 --> 00:38:55.720
So it shows you the power of all
the different versions of 3SAT

00:38:55.720 --> 00:38:57.320
we saw last class.

00:39:00.150 --> 00:39:04.080
Now, I can tell you a little
bit about the other direction.

00:39:10.214 --> 00:39:13.540
I have some of the
details written down here.

00:39:13.540 --> 00:39:15.280
So the other
direction is we need

00:39:15.280 --> 00:39:18.545
to check if there's a satisfying
assignment to 3SAT or one

00:39:18.545 --> 00:39:20.740
in 3SAT, that we can
actually construct

00:39:20.740 --> 00:39:25.580
these numbers that the
base is only polynomial.

00:39:25.580 --> 00:39:28.270
The trickiest part is to
get all of these numbers

00:39:28.270 --> 00:39:29.670
to be distinct from each other.

00:39:32.920 --> 00:39:34.720
AUDIENCE: What base do you do?

00:39:34.720 --> 00:39:38.506
PROFESSOR: The base will
be something like n cubed,

00:39:38.506 --> 00:39:39.950
it turns out.

00:39:39.950 --> 00:39:43.770
And I'll tell you, one
trick is we have all these

00:39:43.770 --> 00:39:45.387
ai's, bi's, and ci's.

00:39:45.387 --> 00:39:47.720
We can guarantee they are all
different from each other,

00:39:47.720 --> 00:39:50.261
that all the a's are different
from all the b's are different

00:39:50.261 --> 00:39:55.610
from all the c's by saying all
a's-- let me get this right--

00:39:55.610 --> 00:40:01.510
all a's will be 2,
34, 66, or 98 mod 128.

00:40:01.510 --> 00:40:04.500
And in general, those
are particular numbers

00:40:04.500 --> 00:40:08.010
set up to make this
construction work out.

00:40:08.010 --> 00:40:11.431
I didn't check them
all but I believe them.

00:40:11.431 --> 00:40:13.680
In general, we're going to
distinguish all the letters

00:40:13.680 --> 00:40:17.020
by what they are mod 128.

00:40:17.020 --> 00:40:19.670
So given a number
between zero and 127,

00:40:19.670 --> 00:40:23.030
there's a unique letter of
the regular English letter

00:40:23.030 --> 00:40:26.900
alphabet, the a's, the b's,
the y's, the z's, and so on

00:40:26.900 --> 00:40:27.920
that it is assigned to.

00:40:27.920 --> 00:40:33.450
And I'll tell you in particular,
the vi's and the vi bars

00:40:33.450 --> 00:40:41.770
are going to be, I
think, 8 or 9 mod 128.

00:40:41.770 --> 00:40:47.365
And the 8 is if
it's false and the 9

00:40:47.365 --> 00:40:49.790
is if it's true, because
remember, modulo 4,

00:40:49.790 --> 00:40:52.610
we want this to be zero
and we want this to be one.

00:40:52.610 --> 00:40:54.277
So there's a bunch
of choices like that.

00:40:54.277 --> 00:40:55.276
Some of them are unique.

00:40:55.276 --> 00:40:56.700
We can always
guarantee-- I forget

00:40:56.700 --> 00:41:00.420
which ones-- the ci's are
all something mod 128.

00:41:00.420 --> 00:41:02.130
So the mod 128
will tell you sort

00:41:02.130 --> 00:41:04.300
of what letter of
the English alphabet

00:41:04.300 --> 00:41:07.110
it is and then it's
a matter of deciding

00:41:07.110 --> 00:41:10.550
the high-order bits, your
number divided by 128

00:41:10.550 --> 00:41:11.960
and take the floor.

00:41:11.960 --> 00:41:16.690
What that is we set to
make everybody distinct.

00:41:16.690 --> 00:41:20.340
And the heart of the
proof, I will say,

00:41:20.340 --> 00:41:24.705
is to make sure that the
vi's are all different.

00:41:28.640 --> 00:41:31.370
Or let's say that the
ti's are different.

00:41:31.370 --> 00:41:33.750
So we have the variables here.

00:41:33.750 --> 00:41:39.110
We're adding them up and
we get ti and we need all

00:41:39.110 --> 00:41:41.680
of the ti's-- there's
one ti per clause.

00:41:41.680 --> 00:41:43.390
We need them all
to be different,

00:41:43.390 --> 00:41:46.990
which means no matter which
triple of vi's we get,

00:41:46.990 --> 00:41:49.230
we should get a different
sum of the triples.

00:41:49.230 --> 00:41:57.490
So this is a problem of
set vi and vi prime divided

00:41:57.490 --> 00:42:10.070
by 128 so that vi plus vj
plus vk are all distinct.

00:42:15.856 --> 00:42:17.230
And at this point,
Eppstein says,

00:42:17.230 --> 00:42:20.380
oh, there's a result by Bose
and Chowla from 1959 the

00:42:20.380 --> 00:42:24.300
says you can always choose these
guys-- if there's n of them

00:42:24.300 --> 00:42:27.250
that you need to choose, then
n-cubed different integers

00:42:27.250 --> 00:42:29.970
suffice to make this true.

00:42:29.970 --> 00:42:32.630
That's if you know the
literature super well,

00:42:32.630 --> 00:42:36.570
but there's an easy proof
that polynomials enough here.

00:42:36.570 --> 00:42:39.380
And those of you
who are in 6.851

00:42:39.380 --> 00:42:41.960
should be able to construct
one, because this is essentially

00:42:41.960 --> 00:42:43.480
fusion trees.

00:42:43.480 --> 00:42:54.570
But in general, imagine that
you've chosen by induction

00:42:54.570 --> 00:42:57.314
I'll call them v less than i.

00:42:57.314 --> 00:42:58.480
And let's ignore the primes.

00:42:58.480 --> 00:43:00.770
Let's just say we've
constructed all the things up

00:43:00.770 --> 00:43:02.290
to the vi minus 1.

00:43:02.290 --> 00:43:07.450
And now, we want
to choose vi and it

00:43:07.450 --> 00:43:12.780
needs to avoid certain values.

00:43:12.780 --> 00:43:22.900
I think if it avoids vj plus
vk minus vl minus vm minus vp

00:43:22.900 --> 00:43:31.360
for all j, k, l,
m, p less than i,

00:43:31.360 --> 00:43:35.340
then no triple should
sum to any other triple,

00:43:35.340 --> 00:43:38.790
because if we
add-- I think maybe

00:43:38.790 --> 00:43:40.980
I have the signs slightly off.

00:43:40.980 --> 00:43:47.250
So I wanted to do this.

00:43:47.250 --> 00:43:50.100
Yeah, so this is one more plus.

00:43:50.100 --> 00:43:53.170
So suppose I had an
equation like this.

00:43:53.170 --> 00:43:55.900
I claim that's bad because
if I move these guys over

00:43:55.900 --> 00:43:59.220
to the left-hand side, that's
a triple of v's that sums

00:43:59.220 --> 00:44:01.000
to another triple of v's.

00:44:01.000 --> 00:44:04.230
So as long as I choose
my new value v-- sorry,

00:44:04.230 --> 00:44:06.520
this should vi.

00:44:06.520 --> 00:44:08.380
That's the one I'm choosing.

00:44:08.380 --> 00:44:14.540
As long as I choose vi to be
different from all such sums

00:44:14.540 --> 00:44:19.010
and they're only less than
n to the fifth such sums,

00:44:19.010 --> 00:44:21.720
because there are only n
of these different things,

00:44:21.720 --> 00:44:23.382
then I'm OK.

00:44:23.382 --> 00:44:24.840
And so by the
pigeonhole principle,

00:44:24.840 --> 00:44:26.710
as long as I have
a range that is

00:44:26.710 --> 00:44:29.350
at least n to the
fifth in size, then

00:44:29.350 --> 00:44:32.960
I can always choose vi to
avoid all those conflicts.

00:44:32.960 --> 00:44:35.460
So that's a really easy proof
that n to the fifth is enough.

00:44:35.460 --> 00:44:38.650
In fact, n cubed is enough,
but this is a hardness proof.

00:44:38.650 --> 00:44:40.270
All we need is strong hardness.

00:44:40.270 --> 00:44:41.560
We just need n cubed.

00:44:41.560 --> 00:44:44.080
That's just fine
or n to the fifth.

00:44:44.080 --> 00:44:47.350
Any polynomial would be OK.

00:44:47.350 --> 00:44:49.546
So that's a sketch of
the reverse direction

00:44:49.546 --> 00:44:50.170
for this proof.

00:44:50.170 --> 00:44:51.836
There are some more
details to make sure

00:44:51.836 --> 00:44:54.050
everything adds up right
mod 128 and that you

00:44:54.050 --> 00:44:56.420
can make all the ai's
different and so on,

00:44:56.420 --> 00:45:00.912
but the hard part is the
vi's, which seems believable.

00:45:00.912 --> 00:45:02.120
Questions about cryptarithms?

00:45:09.460 --> 00:45:10.620
Cool.

00:45:10.620 --> 00:45:13.830
Next is an origami proof.

00:45:13.830 --> 00:45:16.660
So here's the
motivating problem.

00:45:16.660 --> 00:45:18.390
I give you some
crease pattern, which

00:45:18.390 --> 00:45:20.930
is just a graph drawn in
a plane, no crossings,

00:45:20.930 --> 00:45:23.170
and all the edges are
straight segments.

00:45:23.170 --> 00:45:27.690
And you want to fold
it into a flat origami

00:45:27.690 --> 00:45:30.080
or a flat folded state would
be the more technical term.

00:45:30.080 --> 00:45:33.510
So this is an example of what's
called an origami tessellation.

00:45:33.510 --> 00:45:35.460
But in general, what
you're allowed to do,

00:45:35.460 --> 00:45:37.540
the red lines here
mean that you fold

00:45:37.540 --> 00:45:41.850
as a mountain by 180
degrees and the blue lines

00:45:41.850 --> 00:45:44.162
mean you fold a
valley 180 degrees.

00:45:44.162 --> 00:45:46.120
So they're specifying
the relative orientation.

00:45:46.120 --> 00:45:47.786
But in flat-folding,
you're only allowed

00:45:47.786 --> 00:45:50.350
to go plus or minus 180.

00:45:50.350 --> 00:45:53.770
And then, it has to exist.

00:45:53.770 --> 00:45:56.000
Now, the rules for
paper are twofold.

00:45:56.000 --> 00:45:57.440
One is that it doesn't stretch.

00:45:57.440 --> 00:46:00.050
It's an isometric mapping
of the piece of paper.

00:46:00.050 --> 00:46:03.250
Each of these little
polygons is just rotated,

00:46:03.250 --> 00:46:06.850
translated, reflected
possibly over here.

00:46:06.850 --> 00:46:08.990
They fit together, so
you don't tear the paper.

00:46:08.990 --> 00:46:11.590
They fit together
at all the creases

00:46:11.590 --> 00:46:14.180
and there are no
crossings, because paper

00:46:14.180 --> 00:46:16.380
can't intersect itself.

00:46:16.380 --> 00:46:21.280
So the geometry is basically
determined if you say,

00:46:21.280 --> 00:46:23.850
OK, I'm going to view
this panel as being fixed.

00:46:23.850 --> 00:46:24.872
It doesn't move.

00:46:24.872 --> 00:46:26.830
Then, this one is just
going to be a reflection

00:46:26.830 --> 00:46:28.840
through this line flipped over.

00:46:28.840 --> 00:46:30.760
And in general, all of
these other polygons

00:46:30.760 --> 00:46:32.630
just have to be reflections,
because every time you

00:46:32.630 --> 00:46:34.380
fold on a line-- and
the rules of the game

00:46:34.380 --> 00:46:38.140
here is you have to fold
everywhere there's a crease.

00:46:38.140 --> 00:46:43.140
You can figure out this polygon
will end up here relative

00:46:43.140 --> 00:46:44.840
to some original polygon.

00:46:44.840 --> 00:46:46.740
So you can figure out
pretty much what this

00:46:46.740 --> 00:46:49.710
looks like as an x-ray diagram.

00:46:49.710 --> 00:46:52.910
And the hard part becomes
how are layers stacked.

00:46:52.910 --> 00:46:54.410
Is this one on top
of this one or is

00:46:54.410 --> 00:46:56.390
this one on top of that one?

00:46:56.390 --> 00:46:59.040
That's why the problem
is NP-complete is

00:46:59.040 --> 00:47:02.090
that last step, deciding which
layers are on top of the other.

00:47:02.090 --> 00:47:04.750
In general, whenever two layers
of paper partially overlap,

00:47:04.750 --> 00:47:06.850
you have to decide which
is on top of the other.

00:47:06.850 --> 00:47:08.599
And then, there's some
obvious constraints

00:47:08.599 --> 00:47:13.300
like-- let me get my hands
oriented-- this is OK

00:47:13.300 --> 00:47:15.980
but this is not OK.

00:47:15.980 --> 00:47:18.430
If there's one
crease of paper here

00:47:18.430 --> 00:47:20.070
and another crease
of paper here,

00:47:20.070 --> 00:47:22.050
then these locally intersect.

00:47:22.050 --> 00:47:23.260
So this is OK.

00:47:23.260 --> 00:47:24.510
This is OK.

00:47:24.510 --> 00:47:26.150
This is not OK.

00:47:26.150 --> 00:47:27.639
That's the rules.

00:47:27.639 --> 00:47:29.680
We don't need to know
those rules super precisely

00:47:29.680 --> 00:47:32.120
to understand this
proof fairly intuitively

00:47:32.120 --> 00:47:35.490
because everything's going
to be small and quite local.

00:47:35.490 --> 00:47:37.730
The basic idea is the following.

00:47:37.730 --> 00:47:43.200
You take a piece of
paper and you fold it

00:47:43.200 --> 00:47:46.180
along two parallel lines.

00:47:46.180 --> 00:47:50.780
So fold along this line
and then along this line.

00:47:53.550 --> 00:47:56.907
And this is called a pleat and
there are two ways to do it.

00:47:56.907 --> 00:47:58.490
You could do one
mountain, one valley,

00:47:58.490 --> 00:48:00.940
or you could do the other one
mountain and the other one

00:48:00.940 --> 00:48:01.990
valley.

00:48:01.990 --> 00:48:04.240
You can't make them both
mountains because then, you'd

00:48:04.240 --> 00:48:06.820
locally intersect yourself.

00:48:06.820 --> 00:48:09.080
So it could be this
way or it could

00:48:09.080 --> 00:48:12.172
be the other way I just had it.

00:48:12.172 --> 00:48:14.590
It's a little tedious.

00:48:14.590 --> 00:48:16.090
And so you have to
make that choice.

00:48:16.090 --> 00:48:17.214
Which one is a mountain?

00:48:17.214 --> 00:48:18.130
Which one is a valley?

00:48:21.190 --> 00:48:22.880
That's going to be
our true signal.

00:48:22.880 --> 00:48:25.270
We're going to consider one
option true, the other option

00:48:25.270 --> 00:48:26.440
false.

00:48:26.440 --> 00:48:29.640
And as a point of
notation, we're

00:48:29.640 --> 00:48:32.500
going to have an arrow
in every one of these--

00:48:32.500 --> 00:48:33.590
we call them wire gadgets.

00:48:33.590 --> 00:48:39.210
In general, wires are how
we have truth settings.

00:48:39.210 --> 00:48:42.740
And so relative to the
orientation of this arrow,

00:48:42.740 --> 00:48:44.750
if it's valley on
the left-- blue

00:48:44.750 --> 00:48:48.710
is valley because I guess
rivers are in valleys--

00:48:48.710 --> 00:48:50.400
then we'll consider it true.

00:48:50.400 --> 00:48:53.200
If there's blue on the right,
we'll consider it false.

00:48:53.200 --> 00:48:53.700
Question?

00:48:53.700 --> 00:48:55.390
AUDIENCE: Just a
question about the SAT.

00:48:55.390 --> 00:48:57.140
Once you draw all the
red and blue lines,

00:48:57.140 --> 00:48:59.760
there's just one unique answer?

00:48:59.760 --> 00:49:02.620
PROFESSOR: No, the answer's
not necessarily unique,

00:49:02.620 --> 00:49:05.520
but there will be a
unique yes or no answer.

00:49:05.520 --> 00:49:07.747
Either it will be
flat-foldable or not,

00:49:07.747 --> 00:49:09.580
but there actually may
be many flat foldings

00:49:09.580 --> 00:49:12.370
consistent with a given
mountain-valley assignment

00:49:12.370 --> 00:49:13.100
in general.

00:49:13.100 --> 00:49:16.060
So we're not worrying
about that too much here.

00:49:16.060 --> 00:49:18.370
We're just worrying about
whether it is feasible,

00:49:18.370 --> 00:49:23.520
whether there's some ordering
that makes things work out.

00:49:23.520 --> 00:49:26.090
So the idea is this
could be your variable.

00:49:26.090 --> 00:49:27.680
Some reductions have
variable gadgets.

00:49:27.680 --> 00:49:28.197
Some don't.

00:49:28.197 --> 00:49:29.780
This one is just
going to have a wire.

00:49:29.780 --> 00:49:31.321
The idea is if you
say, well, there's

00:49:31.321 --> 00:49:33.260
a pleat over here
in the paper, then

00:49:33.260 --> 00:49:35.360
it could be pleated
one way or the other.

00:49:35.360 --> 00:49:39.310
And that serves as
a variable, as you

00:49:39.310 --> 00:49:40.520
make one choice or the other.

00:49:40.520 --> 00:49:44.290
What we'd like is to take that
truth value and duplicate it,

00:49:44.290 --> 00:49:45.390
make many copies.

00:49:45.390 --> 00:49:46.730
But that's not the next gadget.

00:49:46.730 --> 00:49:49.264
The next gadget is a not
all equal clause gadget.

00:49:49.264 --> 00:49:50.680
So this is going
to be a reduction

00:49:50.680 --> 00:49:53.100
from not all equal 3SAT.

00:49:53.100 --> 00:49:58.180
And I have the gadget
pre-folded here.

00:49:58.180 --> 00:50:02.050
So this is what in origami world
is called a triangular twist.

00:50:02.050 --> 00:50:04.160
It's a slightly weird
triangular twist,

00:50:04.160 --> 00:50:10.130
in that this is 35
degrees instead of 30

00:50:10.130 --> 00:50:11.630
being the usual one.

00:50:11.630 --> 00:50:13.980
And so it's just a
little bit larger

00:50:13.980 --> 00:50:15.110
and that causes a problem.

00:50:15.110 --> 00:50:20.860
So this is an example of a valid
flat-folding of that gadget.

00:50:20.860 --> 00:50:24.040
And if you look at the three
pleats that are coming in,

00:50:24.040 --> 00:50:25.920
notice the arrows
are all pointing in.

00:50:25.920 --> 00:50:27.930
So it's sort of symmetric.

00:50:27.930 --> 00:50:31.830
It's going to be one
of the valid ones.

00:50:31.830 --> 00:50:34.360
So I guess it's actually
written on the diagram here.

00:50:34.360 --> 00:50:36.780
This one is considered
true because there's

00:50:36.780 --> 00:50:41.790
a valley on your right,
this one is considered false

00:50:41.790 --> 00:50:45.435
because there's a
valley on your-- oh

00:50:45.435 --> 00:50:51.320
I'm so confused-- on
your right, and this one

00:50:51.320 --> 00:50:53.050
is considered true
because there's

00:50:53.050 --> 00:50:55.740
a valley on your left-- oh,
sorry, false because there's

00:50:55.740 --> 00:50:57.446
a valley on your right.

00:50:57.446 --> 00:50:58.820
If you're walking
down the arrow,

00:50:58.820 --> 00:51:01.470
then the right-hand
side has a valley.

00:51:01.470 --> 00:51:03.830
And so this happens to
fold because they're not

00:51:03.830 --> 00:51:04.445
all the same.

00:51:04.445 --> 00:51:06.320
If you tried to make
them all the same, which

00:51:06.320 --> 00:51:11.090
should be like
reversing the true,

00:51:11.090 --> 00:51:20.960
it's going to look something
like this, which is actually

00:51:20.960 --> 00:51:22.360
easier to see back here.

00:51:22.360 --> 00:51:25.690
So now, they're all trying
to fold the same way.

00:51:25.690 --> 00:51:28.320
But the problem is on this side.

00:51:28.320 --> 00:51:31.680
These guys will all come
and intersect in the center.

00:51:31.680 --> 00:51:34.860
And I think we
have a diagram Here

00:51:34.860 --> 00:51:37.529
And in x-ray, this
is what must happen.

00:51:37.529 --> 00:51:40.070
And there's this little area of
intersection where you cannot

00:51:40.070 --> 00:51:42.630
resolve which of these three
things are on top of each other

00:51:42.630 --> 00:51:44.660
because this one wants be on
top of this one who wants to be

00:51:44.660 --> 00:51:47.020
on top of this one who wants
to be on top of this one.

00:51:47.020 --> 00:51:48.436
So there's a cycle
of constraints.

00:51:48.436 --> 00:51:51.831
No one can be on top of each
other in this little region.

00:51:51.831 --> 00:51:53.330
Then, in the regular
triangle twist,

00:51:53.330 --> 00:51:55.211
this is a point and
everything's fine.

00:51:55.211 --> 00:51:56.710
But the way these
angles are set up,

00:51:56.710 --> 00:51:58.340
there's this area of overlap.

00:51:58.340 --> 00:51:59.920
And in that one
situation, you're

00:51:59.920 --> 00:52:02.675
toast So if they're all
true-- but of course,

00:52:02.675 --> 00:52:03.550
everything symmetric.

00:52:03.550 --> 00:52:06.091
If you flip it over, then it's
the same if they're all false.

00:52:06.091 --> 00:52:07.445
So you forbid all true.

00:52:07.445 --> 00:52:08.320
You forbid all false.

00:52:08.320 --> 00:52:11.380
Everything else will work
so this is not all equal.

00:52:11.380 --> 00:52:13.290
This will be
flat-foldable locally

00:52:13.290 --> 00:52:18.720
if and only if those variable
assignments are not all equal.

00:52:18.720 --> 00:52:21.690
Now, we need a couple more
gadgets for this to work.

00:52:21.690 --> 00:52:24.680
One is the ability
to duplicate a signal

00:52:24.680 --> 00:52:27.010
and the other is a crossover.

00:52:27.010 --> 00:52:30.440
So here, this is a proof by
Burn and Hayes, by the way.

00:52:30.440 --> 00:52:33.010
This is, I think, the
first or second paper

00:52:33.010 --> 00:52:34.130
in computational origami.

00:52:34.130 --> 00:52:37.140
So it got things off
to an exciting start.

00:52:37.140 --> 00:52:41.796
This is a
splitter/negation gadget.

00:52:41.796 --> 00:52:42.920
This is what it folds like.

00:52:42.920 --> 00:52:46.920
It looks a little bit weird
because my paper's a little bit

00:52:46.920 --> 00:52:50.290
small, but the point
is there's essentially

00:52:50.290 --> 00:52:52.080
only one way to fold this.

00:52:52.080 --> 00:52:55.200
And if you take 6,849, you'll
know this little local analysis

00:52:55.200 --> 00:52:57.910
that forces different mountains
and valleys to be the same.

00:52:57.910 --> 00:52:59.285
For example, these
two have to be

00:52:59.285 --> 00:53:01.510
opposite, which forces
if this is a true,

00:53:01.510 --> 00:53:03.760
this one must be a false.

00:53:03.760 --> 00:53:05.390
So that's your negation.

00:53:05.390 --> 00:53:08.660
And also from a local
analysis of this vertex,

00:53:08.660 --> 00:53:11.800
if this one is true,
this one must be true.

00:53:11.800 --> 00:53:16.020
And it works and it also
works in the inverse setup.

00:53:16.020 --> 00:53:18.090
That's always going to be true.

00:53:18.090 --> 00:53:21.090
A natural reason for us to
be using not all equal 3SAT

00:53:21.090 --> 00:53:22.990
here is there's
really no preference

00:53:22.990 --> 00:53:24.030
between true and false.

00:53:24.030 --> 00:53:26.690
They're not really
a logical notion.

00:53:26.690 --> 00:53:30.630
It's more like red and blue,
literally red and blue.

00:53:30.630 --> 00:53:33.250
So not all equal is the one
that's nice and symmetric.

00:53:33.250 --> 00:53:35.290
It has no preference
between red and blue.

00:53:35.290 --> 00:53:36.250
And so we're seeing that here.

00:53:36.250 --> 00:53:37.780
Because everything's
invertible, we

00:53:37.780 --> 00:53:39.570
want that symmetry
between red and blue.

00:53:39.570 --> 00:53:41.070
So that would be
one reason to guest

00:53:41.070 --> 00:53:44.390
not all equal 3SAT is
a good choice here,

00:53:44.390 --> 00:53:46.150
at least for that wire.

00:53:46.150 --> 00:53:48.810
So cool, if we have a
signal, we can make a copy.

00:53:48.810 --> 00:53:52.020
We also get two copies.

00:53:52.020 --> 00:53:53.760
One of them happens
to be negated

00:53:53.760 --> 00:53:56.945
with this particular choice
of arrow orientation.

00:53:56.945 --> 00:53:58.570
If we oriented the
arrow the other way,

00:53:58.570 --> 00:54:00.232
you could call
that a copy, but we

00:54:00.232 --> 00:54:01.940
don't want to take a
wire that's pointing

00:54:01.940 --> 00:54:06.060
backwards because we need to
attach this to something else.

00:54:06.060 --> 00:54:07.670
These all have very
particular angles,

00:54:07.670 --> 00:54:09.660
but it turns out
that will be OK.

00:54:09.660 --> 00:54:12.820
One more gadget is
a crossover gadget.

00:54:12.820 --> 00:54:13.780
This is very simple.

00:54:13.780 --> 00:54:17.820
It is just one-- this is
not the pre-folded one-- you

00:54:17.820 --> 00:54:21.274
do one pleat and then
you do the other pleat.

00:54:21.274 --> 00:54:22.940
And you can see from
the crease pattern,

00:54:22.940 --> 00:54:25.230
you have to do this pleat
and then do this pleat.

00:54:25.230 --> 00:54:26.620
But it's completely independent.

00:54:26.620 --> 00:54:27.994
I could do each
pleat either way.

00:54:27.994 --> 00:54:29.450
It doesn't affect the other one.

00:54:29.450 --> 00:54:31.900
So that's crossover, done, easy.

00:54:31.900 --> 00:54:34.842
This works with pretty
much any angles.

00:54:34.842 --> 00:54:37.050
And then, it's just a matter
of checking that you can

00:54:37.050 --> 00:54:38.770
fit all the gadgets together.

00:54:38.770 --> 00:54:41.090
This is something
we did in our book

00:54:41.090 --> 00:54:43.765
to get a picture of
how everything works.

00:54:43.765 --> 00:54:46.140
But in general, the idea is
on the left side of the page,

00:54:46.140 --> 00:54:47.348
we have all of our variables.

00:54:47.348 --> 00:54:50.620
Those are just wires so they
can go one way or the other.

00:54:50.620 --> 00:54:53.590
So the idea is here is x2.

00:54:53.590 --> 00:54:55.670
I just want to bend it so
it's pointing downwards

00:54:55.670 --> 00:54:58.760
so I'm going to use the
splitter/negation gadget.

00:54:58.760 --> 00:55:02.060
So we get this copy
of x2 just going off.

00:55:02.060 --> 00:55:04.720
It's going to go up to the
top of the page, no big deal.

00:55:04.720 --> 00:55:05.954
Just throw it away.

00:55:05.954 --> 00:55:07.370
Then, we're going
to go over here.

00:55:07.370 --> 00:55:10.000
Something happens to cross
us, but we don't care.

00:55:10.000 --> 00:55:12.420
Now, what I would
like to do-- looks

00:55:12.420 --> 00:55:15.200
like this clause involves x2.

00:55:15.200 --> 00:55:19.860
So I'm going to do this funny
kind of turnaround thingy

00:55:19.860 --> 00:55:22.420
which will end up making a
copy of this variable pointing

00:55:22.420 --> 00:55:26.380
straight up and also will make
a copy of the variable pointing

00:55:26.380 --> 00:55:27.420
in this direction.

00:55:27.420 --> 00:55:29.870
And so in general, I'm
going to keep doing that.

00:55:29.870 --> 00:55:31.810
And whenever I need
a copy, I'll just

00:55:31.810 --> 00:55:36.570
use an appropriate parity of
turns to get a positive copy.

00:55:36.570 --> 00:55:41.295
So this is negated and then
this is a copy of the negation

00:55:41.295 --> 00:55:44.169
and then we flip it
one, two, three times.

00:55:44.169 --> 00:55:45.710
So in the end, it
should be positive.

00:55:45.710 --> 00:55:47.470
So this is the
tricky part to check.

00:55:47.470 --> 00:55:50.996
Here, we have a not all
equal 3SAT clause where

00:55:50.996 --> 00:55:52.120
three things come together.

00:55:52.120 --> 00:55:53.911
And that's going to be
foldable if and only

00:55:53.911 --> 00:55:55.750
if the three variables
that we're combining

00:55:55.750 --> 00:55:57.840
have a reasonable assignment.

00:55:57.840 --> 00:55:59.990
And then, we just have
to copy all these things

00:55:59.990 --> 00:56:04.210
and get them to meet all at
those nexuses at the top.

00:56:04.210 --> 00:56:06.880
So definitely tricky
to make sure this works

00:56:06.880 --> 00:56:08.660
to guarantee all
the coordinates can

00:56:08.660 --> 00:56:11.150
be encoded with a
polynomial number of bits.

00:56:11.150 --> 00:56:15.720
And therefore, this is a
strongly NP-hard proof.

00:56:15.720 --> 00:56:17.720
But I'm going to wave my
hands of those details.

00:56:20.550 --> 00:56:22.780
Questions?

00:56:22.780 --> 00:56:24.845
If it's any consolation,
the original proof

00:56:24.845 --> 00:56:26.530
also waves its hand
at these details.

00:56:26.530 --> 00:56:28.550
AUDIENCE: If you have a
fold pattern like this,

00:56:28.550 --> 00:56:31.500
can you tell what order you
would need to do the folds in?

00:56:31.500 --> 00:56:34.000
PROFESSOR: There's no such thing
as order of the folds here.

00:56:34.000 --> 00:56:36.757
All of the folds would be folded
simultaneously, more or less.

00:56:36.757 --> 00:56:37.840
AUDIENCE: Instantaneously.

00:56:37.840 --> 00:56:40.726
PROFESSOR: Instantaneously,
to make it even more precise.

00:56:40.726 --> 00:56:42.100
So here, it was
really a question

00:56:42.100 --> 00:56:43.880
of whether there is
a flat-folded state.

00:56:43.880 --> 00:56:45.470
We're not worried about
the motion to get there.

00:56:45.470 --> 00:56:47.660
That's another topic
which you should take 8.49

00:56:47.660 --> 00:56:49.600
if you're curious about.

00:56:49.600 --> 00:56:52.360
But these kinds of patterns,
you can't do one thing

00:56:52.360 --> 00:56:55.011
because there's no pleat
that goes all the way.

00:56:55.011 --> 00:56:57.880
And that's life, unlike
the folding problem

00:56:57.880 --> 00:57:02.500
we saw two classes ago, the map
folding where we were doing one

00:57:02.500 --> 00:57:03.430
and then the other.

00:57:03.430 --> 00:57:05.686
In the notion of simple
folds, there's an ordering,

00:57:05.686 --> 00:57:07.560
but in general origami,
there is no ordering.

00:57:10.090 --> 00:57:12.280
Cool.

00:57:12.280 --> 00:57:17.100
Good, that is origami stuff.

00:57:17.100 --> 00:57:21.730
The next topic is a more graph
theoretic basic question,

00:57:21.730 --> 00:57:24.670
but it will also
relate to a puzzle.

00:57:24.670 --> 00:57:26.830
And this is the idea of
vertex disjoint paths.

00:57:26.830 --> 00:57:29.960
This is in Jason
Lynch's early work,

00:57:29.960 --> 00:57:34.560
before he was born, no relation.

00:57:34.560 --> 00:57:40.230
1975, so early days of
NP-completeness-- this problem,

00:57:40.230 --> 00:57:45.130
vertex disjoint paths in a
graph is proved NP-complete.

00:57:45.130 --> 00:57:49.990
So the problem is, I give you
a bunch of terminal pairs, v1,

00:57:49.990 --> 00:57:54.340
v1 prime, v2, v2 prime,
and so on, c1, c1 prime,

00:57:54.340 --> 00:57:55.980
a bunch of pairs of vertices.

00:57:55.980 --> 00:57:58.650
And I want to connect
the pairs by paths.

00:57:58.650 --> 00:58:02.220
So I want to find a path
from v1 to v1 prime and so

00:58:02.220 --> 00:58:06.710
on so that those paths
are all vertex disjoint.

00:58:06.710 --> 00:58:08.130
Here's the hardness proof.

00:58:08.130 --> 00:58:12.442
Super simple-- this is one of
the easiest 3SAT reductions.

00:58:12.442 --> 00:58:13.900
This is not the
end of their paper.

00:58:13.900 --> 00:58:16.290
They do more interesting
things, which I will get to,

00:58:16.290 --> 00:58:18.560
but first, let's
understand this one.

00:58:18.560 --> 00:58:22.890
So this is a graph and I've
drawn it in a funny way.

00:58:22.890 --> 00:58:24.050
These are vertices.

00:58:24.050 --> 00:58:25.180
These are vertices.

00:58:25.180 --> 00:58:26.730
These are not vertices.

00:58:26.730 --> 00:58:28.900
Those are just in the
plane, they happen to cross,

00:58:28.900 --> 00:58:30.066
but there's no vertex there.

00:58:30.066 --> 00:58:33.880
So it's just a straight
path all the way through.

00:58:33.880 --> 00:58:37.620
Kind of similar to what we
did with phutball-- the idea

00:58:37.620 --> 00:58:41.600
is that from v1 to v1
prime, there are two paths,

00:58:41.600 --> 00:58:42.850
at least if you stay here.

00:58:42.850 --> 00:58:45.730
You could try to go into a
clause path and wreak havoc,

00:58:45.730 --> 00:58:49.080
but I think you will
be doomed, I hope.

00:58:49.080 --> 00:58:52.440
So the idea is v1, maybe
you choose the blue path.

00:58:52.440 --> 00:58:56.146
That will prevent c3 from
using that path because there's

00:58:56.146 --> 00:58:57.020
an intersection here.

00:58:57.020 --> 00:58:58.894
It won't prevent anybody
else because there's

00:58:58.894 --> 00:59:01.130
no other vertices here.

00:59:01.130 --> 00:59:04.420
So I use the blue path,
c3 cannot use that path.

00:59:04.420 --> 00:59:06.440
If I use the red path,
c1 can't use this

00:59:06.440 --> 00:59:08.770
one. c2 can't use this one.

00:59:08.770 --> 00:59:10.770
So again, we are
blocking the thing

00:59:10.770 --> 00:59:12.800
that it would be setting false.

00:59:12.800 --> 00:59:16.960
So that means, let's say red--
I forget in this picture-- let's

00:59:16.960 --> 00:59:20.020
say red is true.

00:59:20.020 --> 00:59:24.690
Then, c1 has v1 bar in it.

00:59:24.690 --> 00:59:27.320
c1 is happy if you
choose the blue path

00:59:27.320 --> 00:59:29.530
but it's not happy if
you choose the red path.

00:59:29.530 --> 00:59:32.880
Now, c1 to c1 prime
only has to be happy

00:59:32.880 --> 00:59:36.480
if one of these three things
are happy and that's 3SAT.

00:59:36.480 --> 00:59:38.770
At least one of the things
should be set correctly.

00:59:38.770 --> 00:59:41.047
Then, there is a path
from c1 to c1 prime.

00:59:41.047 --> 00:59:42.880
Otherwise, there'll be
vertex intersections.

00:59:42.880 --> 00:59:45.630
You won't have vertex
disjoint paths.

00:59:45.630 --> 00:59:48.090
So in a graph, done.

00:59:48.090 --> 00:59:52.250
Now, let's make it a planar
graph, where things get fun.

00:59:52.250 --> 00:59:54.470
So this is the original gadget.

00:59:54.470 --> 00:59:57.240
I've stared at it
for many hours,

00:59:57.240 --> 00:59:59.530
but it's actually
pretty simple after you

00:59:59.530 --> 01:00:01.920
stare at it for enough hours.

01:00:01.920 --> 01:00:05.250
Let me try to
convince you of that.

01:00:05.250 --> 01:00:09.952
So I'm going to follow the
same kind of outline here,

01:00:09.952 --> 01:00:11.285
but we have to get rid of these.

01:00:11.285 --> 01:00:12.050
These are fine.

01:00:12.050 --> 01:00:13.710
Those are intersections.

01:00:13.710 --> 01:00:17.410
But these crossovers, we need
to build a crossover gadget.

01:00:17.410 --> 01:00:20.530
So the idea is
instead of v1 to v1

01:00:20.530 --> 01:00:24.290
prime being a single path--
that's going to be a problem.

01:00:24.290 --> 01:00:27.220
Instead of that, I'm going
to have it be several paths

01:00:27.220 --> 01:00:30.540
and they're going to
be nested brackets.

01:00:35.354 --> 01:00:48.120
Chalk-- this is the kind
of thing we're imagining.

01:00:48.120 --> 01:00:54.120
We have some vertex pairs
which can connect like this.

01:00:54.120 --> 01:00:57.140
And there are two ways
to connect them in what

01:00:57.140 --> 01:00:58.660
will end up being the diagram.

01:00:58.660 --> 01:01:02.625
We could connect them like this.

01:01:07.750 --> 01:01:10.540
Notice I'm still connecting the
same pairs if I do it right.

01:01:14.510 --> 01:01:16.630
And the whites do not
intersect each other.

01:01:16.630 --> 01:01:17.630
They're vertex disjoint.

01:01:17.630 --> 01:01:19.590
The reds do not
intersect each other.

01:01:19.590 --> 01:01:20.590
They're vertex disjoint.

01:01:20.590 --> 01:01:22.480
But if you tried to
switch from white to red,

01:01:22.480 --> 01:01:23.479
you'd get intersections.

01:01:25.960 --> 01:01:27.620
There's exactly
two settings here.

01:01:27.620 --> 01:01:29.490
So this is a wire.

01:01:29.490 --> 01:01:32.740
Once I choose over
here white or red,

01:01:32.740 --> 01:01:35.480
all the others are
forced to alternate.

01:01:35.480 --> 01:01:36.340
Oh, sorry.

01:01:36.340 --> 01:01:38.470
Once I choose up
or down, the rest

01:01:38.470 --> 01:01:40.150
are forced to
alternate up or down.

01:01:40.150 --> 01:01:41.900
If I choose white here,
they're all white.

01:01:41.900 --> 01:01:44.060
If I choose red,
they're all red.

01:01:44.060 --> 01:01:45.820
This is independent
for each variable,

01:01:45.820 --> 01:01:47.221
so independent for each wire.

01:01:47.221 --> 01:01:49.470
So that's what's going on
here and if you look closely

01:01:49.470 --> 01:01:54.600
at the bold lines, you've got
a bracket here from v1 to x1.

01:01:54.600 --> 01:01:57.940
Then, you've got a bracket
here from x2 to x3, then

01:01:57.940 --> 01:01:59.660
a bracket here from x4.

01:01:59.660 --> 01:02:03.080
But in general, there would be
lots of those brackets going

01:02:03.080 --> 01:02:06.340
all the way down the picture.

01:02:06.340 --> 01:02:10.100
And the cool thing about
this is you get the ability

01:02:10.100 --> 01:02:12.840
to crossover,
because now if I just

01:02:12.840 --> 01:02:15.080
restrict this picture--
it's hard to see-- if I just

01:02:15.080 --> 01:02:19.580
restrict to the white part,
you can go from top to bottom.

01:02:19.580 --> 01:02:24.250
You just need an
appropriate kind of zigzag.

01:02:24.250 --> 01:02:26.740
That will let you go from
up here to down there

01:02:26.740 --> 01:02:29.770
without intersections
and that's what's

01:02:29.770 --> 01:02:31.660
happening with this line.

01:02:31.660 --> 01:02:35.120
It's going over, around
the brackets, and down.

01:02:35.120 --> 01:02:38.990
And so the c1 to c1 prime
can remain a single path.

01:02:38.990 --> 01:02:41.050
It can always get through.

01:02:41.050 --> 01:02:42.520
If you have this
gadget, then you

01:02:42.520 --> 01:02:45.280
can have an intersection
with no trouble.

01:02:45.280 --> 01:02:47.900
But v1 is still
communicating information

01:02:47.900 --> 01:02:53.320
down the line of one setting
or the other, 0 or 1.

01:02:53.320 --> 01:02:58.880
There's some details to check
there, but that's the idea.

01:02:58.880 --> 01:03:01.410
And that's the end
of the Lynch paper.

01:03:01.410 --> 01:03:06.480
Now, we were looking at
this earlier this year

01:03:06.480 --> 01:03:09.780
and we can prove an even
stronger result, which

01:03:09.780 --> 01:03:12.020
is what you might call
planar vertex disjoint

01:03:12.020 --> 01:03:13.140
paths in a rectangle.

01:03:16.210 --> 01:03:18.345
So the idea is you
have a rectangle

01:03:18.345 --> 01:03:20.950
of one-by-one squares.

01:03:20.950 --> 01:03:25.405
Each one-by-one square could be
a terminal and a terminal pair

01:03:25.405 --> 01:03:26.780
or it could just
be a blank space

01:03:26.780 --> 01:03:28.720
so you can route paths through.

01:03:28.720 --> 01:03:33.910
And my goal is to find vertex
disjoint paths connecting

01:03:33.910 --> 01:03:35.230
all the terminal pairs.

01:03:35.230 --> 01:03:38.300
But furthermore, I want
every square of the grid

01:03:38.300 --> 01:03:41.000
to be occupied by a path.

01:03:41.000 --> 01:03:43.230
So it's not quite
Hamiltonian path.

01:03:43.230 --> 01:03:47.190
It's like you have a bunch
of paths that collectively

01:03:47.190 --> 01:03:49.350
fill the entire grid.

01:03:49.350 --> 01:03:50.240
Why?

01:03:50.240 --> 01:03:52.890
It's motivated by a puzzle,
but it's natural enough.

01:03:52.890 --> 01:03:55.290
This is a more
specialized version.

01:03:55.290 --> 01:03:56.760
So this is also
NP-hard and we're

01:03:56.760 --> 01:03:58.810
going to mimic the same proof.

01:03:58.810 --> 01:04:00.890
And this, for
example, is a gadget

01:04:00.890 --> 01:04:05.260
to do, say, this little picture
where you have two choices.

01:04:05.260 --> 01:04:08.350
So maybe the v1 dot
is actually here

01:04:08.350 --> 01:04:10.620
and the idea is you could
either follow this path

01:04:10.620 --> 01:04:12.960
or you can follow this path.

01:04:12.960 --> 01:04:16.880
And what's also drawn here are
lots of other terminal pairs.

01:04:16.880 --> 01:04:20.530
These are what you might
call adjacent terminal pairs,

01:04:20.530 --> 01:04:22.870
what you might also
call obstacles.

01:04:22.870 --> 01:04:25.240
Because the paths have
to be vertex disjoint,

01:04:25.240 --> 01:04:29.000
no path can go
through a terminal.

01:04:29.000 --> 01:04:30.860
Any of these dots
serve as obstacles

01:04:30.860 --> 01:04:33.880
so we effectively simulate this
blank space that you're not

01:04:33.880 --> 01:04:34.760
allowed to touch.

01:04:37.610 --> 01:04:40.050
Now, the fun part is
maybe those terminal

01:04:40.050 --> 01:04:42.510
pairs are connected by
the single edge that

01:04:42.510 --> 01:04:44.765
joins them and doesn't
get in the way.

01:04:44.765 --> 01:04:46.140
But there are
other possibilities

01:04:46.140 --> 01:04:47.860
drawn with these blue lines.

01:04:47.860 --> 01:04:50.860
So instead of going
here, I could do this.

01:04:50.860 --> 01:04:53.007
Instead of going here, I
could do this and this.

01:04:53.007 --> 01:04:54.590
And then, if you
look at this picture,

01:04:54.590 --> 01:05:01.090
every pixel has a path
through it in this case.

01:05:01.090 --> 01:05:03.390
And then, here's
the other case again

01:05:03.390 --> 01:05:07.240
and now I'll fill these
two pixels with this pair.

01:05:07.240 --> 01:05:10.164
And now, every pixel
has a path through it.

01:05:10.164 --> 01:05:12.080
That's my goal is to
make sure every pixel has

01:05:12.080 --> 01:05:12.520
a path through it.

01:05:12.520 --> 01:05:14.020
So we're just trying
to preserve all

01:05:14.020 --> 01:05:15.556
of the solutions
we have here but

01:05:15.556 --> 01:05:17.180
with the additional
constraint that all

01:05:17.180 --> 01:05:20.540
of the-- because we already
know this is simulating 3SAT.

01:05:20.540 --> 01:05:22.150
We already know it's hard.

01:05:22.150 --> 01:05:24.320
We just now want to have
this extra constraint

01:05:24.320 --> 01:05:26.600
that every pixel has
a path through it

01:05:26.600 --> 01:05:28.690
and that we live in a rectangle.

01:05:28.690 --> 01:05:31.582
So this looks good.

01:05:31.582 --> 01:05:33.790
As you might imagine, there's
a little bit of finesse

01:05:33.790 --> 01:05:35.527
to make these gadgets work.

01:05:35.527 --> 01:05:37.860
You notice some of these guys
are oriented horizontally.

01:05:37.860 --> 01:05:39.401
Some of them are
oriented vertically.

01:05:39.401 --> 01:05:43.660
That's to make it
work, but this is easy.

01:05:43.660 --> 01:05:47.170
What you're about
to see is less easy.

01:05:47.170 --> 01:05:49.960
So let's do the crossover
gadget, because that's

01:05:49.960 --> 01:05:51.060
the heart of everything.

01:05:51.060 --> 01:05:53.090
And when we were
starting on this--

01:05:53.090 --> 01:05:57.520
I think this was in
May-- I was very happy

01:05:57.520 --> 01:06:00.354
when I could finally
draw this picture.

01:06:00.354 --> 01:06:02.020
Sorry, this is actually
the final gadget

01:06:02.020 --> 01:06:07.010
which works but you can see
the same kind of picture.

01:06:07.010 --> 01:06:09.640
I've got a bracket here that
corresponds to this bracket

01:06:09.640 --> 01:06:11.500
here and there's
another bracket here.

01:06:11.500 --> 01:06:14.090
I've just rounded it
to integer coordinates

01:06:14.090 --> 01:06:17.520
and made sure that everything
else can be filled in.

01:06:17.520 --> 01:06:18.450
Easy, right?

01:06:22.020 --> 01:06:24.650
In the sake of education, let
me show you all the things that

01:06:24.650 --> 01:06:25.879
went wrong in this proof.

01:06:25.879 --> 01:06:27.420
Because it was only
a few months ago,

01:06:27.420 --> 01:06:30.170
I mostly remember
everything that went wrong,

01:06:30.170 --> 01:06:32.450
which was a lot.

01:06:32.450 --> 01:06:34.830
So this was an early
version of the gadget,

01:06:34.830 --> 01:06:38.960
not actually the first one
but it serves its purpose.

01:06:38.960 --> 01:06:40.540
So here, we have
the two settings.

01:06:40.540 --> 01:06:42.710
It's corresponding to
these two settings, the up

01:06:42.710 --> 01:06:45.710
and the down setting, the
true and the false setting.

01:06:45.710 --> 01:06:48.770
We've got this path coming
through in both cases.

01:06:48.770 --> 01:06:52.620
It takes a slightly
different path over here.

01:06:52.620 --> 01:06:54.657
The brackets are flipped.

01:06:54.657 --> 01:06:56.240
So the first thing
I want to point out

01:06:56.240 --> 01:06:59.310
are these circled nodes.

01:06:59.310 --> 01:07:01.326
The obvious way to
draw this picture

01:07:01.326 --> 01:07:05.299
is with all of the
terminals in the center row.

01:07:05.299 --> 01:07:06.340
That would be reasonable.

01:07:06.340 --> 01:07:09.410
They're not drawn that way here
because imagine at this point,

01:07:09.410 --> 01:07:12.900
we're down here and we have
this big path over here.

01:07:12.900 --> 01:07:15.280
Then, there'll be
three pixels here which

01:07:15.280 --> 01:07:17.670
somehow have to be filled.

01:07:17.670 --> 01:07:21.740
And that is trouble
because three is odd.

01:07:21.740 --> 01:07:25.550
So this is what you
might call issue one.

01:07:25.550 --> 01:07:27.550
Wherever you have
empty space, any group

01:07:27.550 --> 01:07:32.170
should have even area because
if you look at two guys that

01:07:32.170 --> 01:07:36.890
are adjacent and you replace
them with some other path,

01:07:36.890 --> 01:07:38.280
together, that forms a polygon.

01:07:38.280 --> 01:07:42.590
And in the square grid
every polygon has even area.

01:07:42.590 --> 01:07:46.420
So you will never fill
exactly three spaces.

01:07:46.420 --> 01:07:50.400
So the major revolution which
I spent many hours figuring out

01:07:50.400 --> 01:07:52.370
is if I just move these
points up one spot,

01:07:52.370 --> 01:07:53.420
everything just works.

01:07:53.420 --> 01:07:55.190
I was so happy.

01:07:55.190 --> 01:07:56.700
So I figured, OK, proof's done.

01:07:56.700 --> 01:08:00.420
I drew these two figures
and forgot about it.

01:08:00.420 --> 01:08:04.250
Then, a couple months later,
we want to write the paper

01:08:04.250 --> 01:08:05.840
and then we get to issue two.

01:08:05.840 --> 01:08:08.490
So issue two is
well, this is great.

01:08:08.490 --> 01:08:14.590
This works fine if the
clause path is present.

01:08:14.590 --> 01:08:17.010
If the clause chooses
this vertical path,

01:08:17.010 --> 01:08:18.220
this will fill everything.

01:08:18.220 --> 01:08:19.720
This will fill everything.

01:08:19.720 --> 01:08:22.430
But what if the
clause path is absent?

01:08:22.430 --> 01:08:23.580
Clause has three choices.

01:08:23.580 --> 01:08:25.920
It may not choose
this vertical path.

01:08:25.920 --> 01:08:29.790
So then, somehow, this stuff
has to be covered using

01:08:29.790 --> 01:08:33.700
all the extra filler stuff.

01:08:33.700 --> 01:08:37.269
And here, I couldn't
quite figure out

01:08:37.269 --> 01:08:38.310
how to fill these things.

01:08:38.310 --> 01:08:41.470
Well, maybe I should add a
couple more rows in the middle.

01:08:41.470 --> 01:08:44.380
That didn't seem to help.

01:08:44.380 --> 01:08:45.930
I thought this one was OK.

01:08:45.930 --> 01:08:49.540
It looks fine until I
notice that well, either I

01:08:49.540 --> 01:08:52.700
connect these two dots
by a length two path

01:08:52.700 --> 01:08:53.979
or I connect it by this path.

01:08:53.979 --> 01:08:59.950
But in that case, this
pixel is uncovered by paths.

01:08:59.950 --> 01:09:03.000
And this is bad, because there's
exactly one such pixel, which

01:09:03.000 --> 01:09:06.350
means I have another
parity problem again.

01:09:06.350 --> 01:09:11.529
So I think what we
ended up doing--

01:09:11.529 --> 01:09:13.950
and when you're really doing
it, you don't immediately

01:09:13.950 --> 01:09:16.630
realize it's a parity problem.

01:09:16.630 --> 01:09:18.520
I tried trying to fix
this many, many times

01:09:18.520 --> 01:09:21.229
and every single time, I
had one pixel uncovered.

01:09:21.229 --> 01:09:22.620
Oh, bet there's a theorem here.

01:09:22.620 --> 01:09:25.800
And then, I proved, oh, yeah,
it's got to change parity.

01:09:25.800 --> 01:09:29.670
So what we ended up doing
was adding a row down here.

01:09:29.670 --> 01:09:31.399
Make this path slightly longer.

01:09:31.399 --> 01:09:33.330
That adds exactly
one uncovered pixel

01:09:33.330 --> 01:09:35.810
so it should fix
the parity problem.

01:09:35.810 --> 01:09:39.540
Many hours later, we
came up with this.

01:09:39.540 --> 01:09:42.500
So this is good.

01:09:42.500 --> 01:09:46.149
Every pixel is covered
in all four cases.

01:09:46.149 --> 01:09:50.529
The bottom row is that
the clause path is in

01:09:50.529 --> 01:09:53.450
and the top row is the
clause path is out.

01:09:53.450 --> 01:09:56.580
And as you can see, lots
of careful orientations

01:09:56.580 --> 01:09:59.460
of these little terminal pairs
to make sure in all cases,

01:09:59.460 --> 01:10:00.630
you can cover everything.

01:10:00.630 --> 01:10:02.500
This was frustrating
because you'd fix one

01:10:02.500 --> 01:10:04.083
and then you switch
to the other layer

01:10:04.083 --> 01:10:05.850
and say, oh, I broke
this other one.

01:10:05.850 --> 01:10:09.150
I rotated these guys and now,
it's not possible to do this,

01:10:09.150 --> 01:10:10.760
so you better-- and
it would be like,

01:10:10.760 --> 01:10:13.051
you'd rotate this and then
rotate that and rotate this.

01:10:13.051 --> 01:10:16.250
And luckily, no bad
cycles happened.

01:10:16.250 --> 01:10:18.160
You could always resolve it.

01:10:18.160 --> 01:10:20.670
And so finally, we
got this picture,

01:10:20.670 --> 01:10:26.070
except for issue three, which
is another parity problem.

01:10:26.070 --> 01:10:26.910
I was blown away.

01:10:26.910 --> 01:10:31.070
It was like every day, there
was another parity problem.

01:10:31.070 --> 01:10:34.160
Of course, the deadline
is tomorrow at this point.

01:10:34.160 --> 01:10:35.910
Luckily, I started
three days ahead

01:10:35.910 --> 01:10:40.530
so there were
exactly three issues.

01:10:40.530 --> 01:10:43.840
So remember this gadget,
which was the choice.

01:10:43.840 --> 01:10:45.695
I didn't say this is
a variable choice.

01:10:45.695 --> 01:10:46.570
You have two choices.

01:10:46.570 --> 01:10:49.370
If you want a clause choice,
you connect two of these gadgets

01:10:49.370 --> 01:10:51.370
together and then you
have three different paths

01:10:51.370 --> 01:10:52.430
you might follow.

01:10:52.430 --> 01:10:54.960
If you stare at this
enough-- and I just

01:10:54.960 --> 01:10:57.500
wanted to make sure, OK,
can I plug these together?

01:10:57.500 --> 01:11:01.126
I thought, OK, I'll just copy
and paste and lay things out

01:11:01.126 --> 01:11:02.250
and I had a parity problem.

01:11:02.250 --> 01:11:04.120
I was like, oh, man,
what's going on?

01:11:04.120 --> 01:11:07.600
Well, if you look here,
this is at one column

01:11:07.600 --> 01:11:10.870
and this is a column
four positions over.

01:11:10.870 --> 01:11:12.360
So in particular,
the two choices

01:11:12.360 --> 01:11:15.110
here have the same parity.

01:11:15.110 --> 01:11:18.920
I think it's mod 2 not mod
4 but I could double-check.

01:11:18.920 --> 01:11:21.800
And you just cannot build this
if you want these things to be

01:11:21.800 --> 01:11:26.220
an odd distance
apart because parity.

01:11:26.220 --> 01:11:29.460
So then, you look at
this gadget and you

01:11:29.460 --> 01:11:33.070
realize it has an odd
number of columns.

01:11:33.070 --> 01:11:34.770
We've made it an
even number of rows

01:11:34.770 --> 01:11:37.020
when we added that
last row but now

01:11:37.020 --> 01:11:40.150
it has an odd number of
columns, which is kind of weird

01:11:40.150 --> 01:11:42.140
but that's life.

01:11:42.140 --> 01:11:45.630
So we need to make it even.

01:11:45.630 --> 01:11:48.710
And so I think if
you focus right here,

01:11:48.710 --> 01:11:51.210
we add another column.

01:11:51.210 --> 01:11:53.397
It's now right here so
where there used to be two,

01:11:53.397 --> 01:11:54.230
now there are three.

01:11:54.230 --> 01:11:57.600
We have this little trick
to fill things in and not

01:11:57.600 --> 01:11:58.501
too much changed.

01:11:58.501 --> 01:12:00.000
I think I also
cleaned up the gadget

01:12:00.000 --> 01:12:01.960
or removed a couple extra
columns on the right,

01:12:01.960 --> 01:12:05.150
but the key thing was
to add a new column that

01:12:05.150 --> 01:12:06.240
fixed the parity.

01:12:06.240 --> 01:12:08.030
Now, the number
of columns is even

01:12:08.030 --> 01:12:09.710
and now, I have to prove this.

01:12:09.710 --> 01:12:13.040
But it's pretty easy to check.

01:12:13.040 --> 01:12:17.870
You can combine these gadgets
together and they match up.

01:12:17.870 --> 01:12:19.550
And then, if you
have blank space,

01:12:19.550 --> 01:12:23.390
it's also even by even and so
it always has a perfect matching

01:12:23.390 --> 01:12:26.960
and so you can fill in any
blank space with extra pairs.

01:12:30.140 --> 01:12:35.480
Those are the gadgets
except there's one more

01:12:35.480 --> 01:12:36.734
issue I haven't mentioned.

01:12:36.734 --> 01:12:38.400
AUDIENCE: Yeah, there's
a parity problem

01:12:38.400 --> 01:12:39.200
with your parity problems.

01:12:39.200 --> 01:12:40.640
There's only an
odd number of them.

01:12:40.640 --> 01:12:42.070
PROFESSOR: Only an odd
number of parity problems--

01:12:42.070 --> 01:12:44.210
luckily, the next problem
is not a parity problem

01:12:44.210 --> 01:12:47.040
or unluckily-- I don't know.

01:12:47.040 --> 01:12:48.720
And this wasn't
really a problem.

01:12:48.720 --> 01:12:49.970
I knew it was going to happen.

01:12:49.970 --> 01:12:53.720
I just had to draw the figure
but it's good for an exercise.

01:12:53.720 --> 01:12:56.780
Think about what could
possibly be missing.

01:12:56.780 --> 01:12:59.950
We spent all this time
doing crossover gadgets

01:12:59.950 --> 01:13:03.190
but there's also the case
where the wires cross

01:13:03.190 --> 01:13:05.060
and we actually want
the vertical wire

01:13:05.060 --> 01:13:08.530
to block the horizontal
wire in a particular choice.

01:13:08.530 --> 01:13:10.550
This is actually
really easy to do.

01:13:10.550 --> 01:13:12.467
So here's the gadget
I was just showing you

01:13:12.467 --> 01:13:13.800
without all the stuff filled in.

01:13:13.800 --> 01:13:15.600
Those are just the
terminal pairs.

01:13:15.600 --> 01:13:18.130
And this guy goes to the left.

01:13:18.130 --> 01:13:19.350
This guy goes to here.

01:13:19.350 --> 01:13:21.770
This guy goes to the right.

01:13:21.770 --> 01:13:27.000
If you just add in an extra
pair here or an extra pair here,

01:13:27.000 --> 01:13:29.640
you will block blue or
red, correspondingly.

01:13:29.640 --> 01:13:31.720
So if we go to the
previous slide here,

01:13:31.720 --> 01:13:35.370
blue goes through this
position but red does not.

01:13:35.370 --> 01:13:40.240
And down here, blue does
not go through this position

01:13:40.240 --> 01:13:41.850
but red does.

01:13:41.850 --> 01:13:44.090
And so if you add in
this extra little pair,

01:13:44.090 --> 01:13:47.660
you will force red or
blue at that intersection.

01:13:47.660 --> 01:13:50.260
And that was the little
squares in the overall diagram.

01:13:50.260 --> 01:13:52.370
So if you choose
this vertical path,

01:13:52.370 --> 01:13:57.100
you force the horizontal
path to be the other thing.

01:13:57.100 --> 01:14:00.330
That's the proof.

01:14:00.330 --> 01:14:05.070
I hope there are no more
issues but it was exciting.

01:14:05.070 --> 01:14:07.100
So just to give you a
flavor for parity issues,

01:14:07.100 --> 01:14:09.266
there are all over the
place, especially when you're

01:14:09.266 --> 01:14:09.960
on a grid.

01:14:09.960 --> 01:14:11.780
Be careful of them.

01:14:11.780 --> 01:14:13.210
That's the life lesson.

01:14:16.150 --> 01:14:18.890
I'll tell you a little bit
about where this kind of problem

01:14:18.890 --> 01:14:19.580
comes from.

01:14:19.580 --> 01:14:22.700
The earliest reference we know
is by Sam Loyd, a famous puzzle

01:14:22.700 --> 01:14:23.440
designer.

01:14:23.440 --> 01:14:28.100
In 1897, he posed this puzzle,
an incredibly complicated

01:14:28.100 --> 01:14:31.140
puzzle, lots of stuff in it.

01:14:31.140 --> 01:14:33.080
And then, I think
the next issue,

01:14:33.080 --> 01:14:35.939
he published the
solution, which is this.

01:14:35.939 --> 01:14:37.355
Hopefully, I
remember the problem.

01:14:37.355 --> 01:14:39.950
So you have these
houses and you'll notice

01:14:39.950 --> 01:14:44.640
each house faces an exit.

01:14:44.640 --> 01:14:48.250
And what you'd like
is for each house

01:14:48.250 --> 01:14:52.394
to be connected by a
pathway to the exit.

01:14:52.394 --> 01:14:54.810
But if you just did that, they
would intersect each other.

01:14:54.810 --> 01:14:56.810
So you want vertex
disjoint paths

01:14:56.810 --> 01:15:00.120
in the grid from the houses
to the exit that they face.

01:15:00.120 --> 01:15:03.990
So that is a terminal pair
vertex disjoint path problem.

01:15:03.990 --> 01:15:07.880
Now, he didn't specify
that those paths should

01:15:07.880 --> 01:15:11.160
fill the entire grid
but they almost do.

01:15:11.160 --> 01:15:13.390
Other than this
little corner, they

01:15:13.390 --> 01:15:16.440
do and a few little
corners at the extremes.

01:15:16.440 --> 01:15:17.260
And you can fix it.

01:15:17.260 --> 01:15:18.730
Instead of going
like this, you can

01:15:18.730 --> 01:15:22.750
go zig, zig, zig, zig, and
zig, zig, zig, zig, zig

01:15:22.750 --> 01:15:29.000
and make it into a solution
to the problem I just said.

01:15:29.000 --> 01:15:32.120
So that's 1897.

01:15:32.120 --> 01:15:36.220
In modern terms, this is known
as the Numberlink puzzle.

01:15:36.220 --> 01:15:41.040
Nikoli is a famous
Japanese puzzle publisher.

01:15:41.040 --> 01:15:44.900
These are two Nikoli books
that we got in our last trip

01:15:44.900 --> 01:15:46.972
to Japan a couple months ago.

01:15:46.972 --> 01:15:48.680
These are both for
the Numberlink puzzle.

01:15:48.680 --> 01:15:54.490
So you turn to an arbitrary
page and you have some picture

01:15:54.490 --> 01:15:57.730
like this, which
here's an example.

01:15:57.730 --> 01:15:58.700
You have pairs.

01:15:58.700 --> 01:16:01.050
You have a bunch of
numbers and blank spaces.

01:16:01.050 --> 01:16:04.270
The idea is that there's
exactly two of each number.

01:16:04.270 --> 01:16:05.700
Those are your terminal pairs.

01:16:05.700 --> 01:16:08.335
You want to find vertex
disjoint paths that connect them

01:16:08.335 --> 01:16:10.620
and in the back,
there's solutions

01:16:10.620 --> 01:16:12.960
if you can't solve one.

01:16:12.960 --> 01:16:17.060
They have easy ones,
medium ones, hard ones.

01:16:17.060 --> 01:16:18.550
So how hard is it?

01:16:18.550 --> 01:16:21.930
NP-hard because this is exactly
the problem we were just

01:16:21.930 --> 01:16:24.170
solving, if you want
to find vertex disjoint

01:16:24.170 --> 01:16:26.690
paths in the grid.

01:16:26.690 --> 01:16:29.340
There is this issue
of whether you

01:16:29.340 --> 01:16:31.530
are specified as one
of the constraints

01:16:31.530 --> 01:16:36.030
that you must
visit every square.

01:16:36.030 --> 01:16:43.370
But do a quick visual scan
here-- in every solution

01:16:43.370 --> 01:16:47.710
that I see, every square
happens to be filled.

01:16:47.710 --> 01:16:50.410
Now, that might be the
way that they designed

01:16:50.410 --> 01:16:53.260
the puzzles, the only way to
solve them is for every square

01:16:53.260 --> 01:16:55.230
to be filled or it might
be that's a constraint

01:16:55.230 --> 01:16:55.813
to the puzzle.

01:16:55.813 --> 01:16:58.260
And different write-ups
suggest different ways.

01:16:58.260 --> 01:17:00.770
But what we proved is,
both ways, it's hard.

01:17:00.770 --> 01:17:03.740
Whether you give that as a
specification or you make

01:17:03.740 --> 01:17:07.550
it possible to do, it is
NP-hard because we started

01:17:07.550 --> 01:17:10.070
from a reduction that didn't
have to fill every pixel

01:17:10.070 --> 01:17:11.569
and we turned it
into one that could

01:17:11.569 --> 01:17:13.590
fill every pixel if you wanted.

01:17:13.590 --> 01:17:14.130
Yeah?

01:17:14.130 --> 01:17:17.330
AUDIENCE: There's a sense
in which these puzzles are

01:17:17.330 --> 01:17:20.760
sparser, in terms of
the number of vertices

01:17:20.760 --> 01:17:22.110
than your reduction.

01:17:22.110 --> 01:17:25.277
Is it possible that you
could define it in such a way

01:17:25.277 --> 01:17:27.140
that these are unsolvable?

01:17:27.140 --> 01:17:29.500
PROFESSOR: It's an
interesting question.

01:17:29.500 --> 01:17:36.640
So our reduction has most of
the cells filled with numbers.

01:17:36.640 --> 01:17:39.330
These you could say, if you
have an n by n grid, maybe

01:17:39.330 --> 01:17:41.890
these only have order
n numbers, whereas we

01:17:41.890 --> 01:17:43.640
have order n squared numbers.

01:17:43.640 --> 01:17:44.730
That would be interesting.

01:17:44.730 --> 01:17:46.380
I don't know the complexity.

01:17:46.380 --> 01:17:49.430
The one thing that's known
is for one terminal pair,

01:17:49.430 --> 01:17:52.490
it's polynomial time.

01:17:52.490 --> 01:17:55.590
I think even two terminal
pairs is an open problem.

01:17:55.590 --> 01:17:58.350
So you need to solve that
before you could solve

01:17:58.350 --> 01:18:01.739
n terminal pairs for an n by n.

01:18:01.739 --> 01:18:04.280
So I don't know how many people
worked on two terminal pairs.

01:18:04.280 --> 01:18:05.738
I've thought about
it a little bit.

01:18:05.738 --> 01:18:08.100
It seems very difficult.

01:18:08.100 --> 01:18:09.650
Anyway, a little
more to this story.

01:18:13.454 --> 01:18:15.120
In fact, we first
encountered Numberlink

01:18:15.120 --> 01:18:17.680
in the form of an Android
game called Flow Free, which

01:18:17.680 --> 01:18:19.010
some of you may have played.

01:18:19.010 --> 01:18:22.670
It became popular for
a few months there

01:18:22.670 --> 01:18:25.670
but it is exactly Numberlink
as I have defined it.

01:18:25.670 --> 01:18:28.950
And once you know
that, then there's

01:18:28.950 --> 01:18:31.580
also Number Link and a
zillion other clones.

01:18:31.580 --> 01:18:34.080
And I don't think Nikoli
publishes any of these.

01:18:34.080 --> 01:18:36.490
But it's all from
1897, so unclear

01:18:36.490 --> 01:18:38.937
what the copyright is here.

01:18:38.937 --> 01:18:40.520
But in particular,
Number Link I like.

01:18:40.520 --> 01:18:42.860
It has the nicest GUI.

01:18:42.860 --> 01:18:44.760
But in the beginning
tutorial, it

01:18:44.760 --> 01:18:47.000
says, well, there's actually
two modes you can play.

01:18:47.000 --> 01:18:49.210
There's zigzag mode, where
you can draw paths however

01:18:49.210 --> 01:18:49.710
you want.

01:18:49.710 --> 01:18:51.680
That's what I've been
talking about because

01:18:51.680 --> 01:18:53.720
graphed theoretically,
that's the natural thing.

01:18:53.720 --> 01:18:57.060
Then, there's this other
modes called classic mode

01:18:57.060 --> 01:19:01.560
where if you draw
a complicated path,

01:19:01.560 --> 01:19:06.020
it gets-- "autoshrinked"
is the general term.

01:19:06.020 --> 01:19:08.140
Now, again, it's hard to
have an authority here

01:19:08.140 --> 01:19:10.830
in what are the
rules of Number Link?

01:19:10.830 --> 01:19:13.440
But one definition
is you consider

01:19:13.440 --> 01:19:16.950
all possible paths
between these pairs that

01:19:16.950 --> 01:19:18.146
have the same topology.

01:19:20.442 --> 01:19:22.900
You can try to go this way or
you could try to go this way.

01:19:22.900 --> 01:19:25.230
Here, you have these two
guys on your right-hand side.

01:19:25.230 --> 01:19:26.980
Here, you have them
on the left-hand side.

01:19:26.980 --> 01:19:29.730
In general, that's called a
homotopy type of that path.

01:19:29.730 --> 01:19:33.960
Consider all paths with
the same homotopy type.

01:19:33.960 --> 01:19:38.330
Your path should be shortest
among all such paths.

01:19:38.330 --> 01:19:40.503
That is one notion
of autoshrinked.

01:19:40.503 --> 01:19:42.753
I don't know if that's the
official one, but it is a--

01:19:42.753 --> 01:19:44.919
AUDIENCE: That has to do
with the order in which you

01:19:44.919 --> 01:19:46.340
set the things.

01:19:46.340 --> 01:19:50.150
PROFESSOR: This description
suggests a particular order.

01:19:50.150 --> 01:19:52.504
So you'd also maybe
need a proper ordering.

01:19:52.504 --> 01:19:53.452
Yeah?

01:19:53.452 --> 01:19:56.296
AUDIENCE: So the
1 to the 1 here,

01:19:56.296 --> 01:19:58.713
there's multiple ways--
well, the other way,

01:19:58.713 --> 01:20:00.963
there's multiple ways to get
through that square grid,

01:20:00.963 --> 01:20:01.463
I think.

01:20:01.463 --> 01:20:03.950
You can go down and all the
way around or you could go--

01:20:03.950 --> 01:20:04.260
PROFESSOR: Right.

01:20:04.260 --> 01:20:05.850
These would both
be the same length.

01:20:05.850 --> 01:20:07.700
And I think those are
both considered valid,

01:20:07.700 --> 01:20:09.400
although you'd have to
play in this particular--

01:20:09.400 --> 01:20:10.576
AUDIENCE: So it wouldn't
change either of those.It

01:20:10.576 --> 01:20:11.850
would take the one you chose.

01:20:11.850 --> 01:20:13.020
PROFESSOR: Right.

01:20:13.020 --> 01:20:14.580
So you still have
some flexibility.

01:20:14.580 --> 01:20:16.579
There are multiple shortest
paths in this world,

01:20:16.579 --> 01:20:19.020
because we're Manhattan metric.

01:20:19.020 --> 01:20:24.092
So this raises the issue
of classic Number Link.

01:20:24.092 --> 01:20:26.300
And most of the puzzles--
I think all the puzzles-- I

01:20:26.300 --> 01:20:28.280
haven't checked every
single one-- actually

01:20:28.280 --> 01:20:30.080
follow these rules.

01:20:30.080 --> 01:20:33.390
But again, I'm not clear
what the rules actually

01:20:33.390 --> 01:20:35.840
are, whether they
require this or this.

01:20:35.840 --> 01:20:39.060
But luckily, there's another
paper the covers that case.

01:20:39.060 --> 01:20:50.050
It's in Japanese but it
considers the classic mode,

01:20:50.050 --> 01:20:53.780
where you have to do some kind
of locally shortest paths.

01:20:53.780 --> 01:20:57.060
And the gadgets critically
exploit that feature.

01:20:57.060 --> 01:20:58.540
It's a reduction
from planar 3SAT.

01:20:58.540 --> 01:21:00.770
We might look at it when
we get to planar 3SAT,

01:21:00.770 --> 01:21:03.300
which is the next class or two.

01:21:03.300 --> 01:21:05.810
Or not-- there's a ton
of planar 3SAT proofs.

01:21:05.810 --> 01:21:07.980
But anyway, that's
been covered already.

01:21:07.980 --> 01:21:10.080
The actual order of events
is we proved our result

01:21:10.080 --> 01:21:11.540
and then we're like, uh
oh, this is Numberlink.

01:21:11.540 --> 01:21:13.248
Uh oh, Numberlink is
NP-complete and that

01:21:13.248 --> 01:21:14.780
was known a few years ago.

01:21:14.780 --> 01:21:18.270
Oh, good thing it's a
different game that we studied.

01:21:18.270 --> 01:21:20.240
So there are two versions
of Numberlink now.

01:21:20.240 --> 01:21:21.480
They're both hard.

01:21:21.480 --> 01:21:25.590
So that's the good news
and that's all for today.

01:21:25.590 --> 01:21:29.220
This is the Super Mario
Brothers edition of 6.890.