WEBVTT

00:00:00.040 --> 00:00:02.470
The following content is
provided under a Creative

00:00:02.470 --> 00:00:03.880
Commons license.

00:00:03.880 --> 00:00:06.920
Your support will help MIT
OpenCourseWare continue to

00:00:06.920 --> 00:00:10.570
offer high-quality educational
resources for free.

00:00:10.570 --> 00:00:13.470
To make a donation or view
additional materials from

00:00:13.470 --> 00:00:21.260
hundreds of MIT courses, visit
MIT OpenCourseWare at MIT.edu.

00:00:21.260 --> 00:00:23.400
PROFESSOR: Ladies and gentlemen,
welcome to lecture

00:00:23.400 --> 00:00:24.640
number five.

00:00:24.640 --> 00:00:27.630
In the previous lectures we
talked about the formulation

00:00:27.630 --> 00:00:30.680
of the finite element method,
and we derived already some

00:00:30.680 --> 00:00:31.850
element matrices.

00:00:31.850 --> 00:00:34.200
I want to continue that

00:00:34.200 --> 00:00:35.955
discussion in the next lecture.

00:00:35.955 --> 00:00:39.770
However, now I would like to
spend some time with you and

00:00:39.770 --> 00:00:42.280
discuss with you the
implementation of the finite

00:00:42.280 --> 00:00:43.340
element method.

00:00:43.340 --> 00:00:46.720
I would like to present to
you some important aspect

00:00:46.720 --> 00:00:49.600
regarding the implementation
of the procedures that we

00:00:49.600 --> 00:00:51.450
talked about already.

00:00:51.450 --> 00:00:54.450
We derived the equilibrium
equations KU equals R in the

00:00:54.450 --> 00:00:57.770
earlier lectures, where R, of
course, contains various

00:00:57.770 --> 00:01:01.770
contributions due to body load,
surface load, and so on.

00:01:01.770 --> 00:01:04.510
And we particularly pointed
out that that the total

00:01:04.510 --> 00:01:07.570
structural stiffness matrix
is obtained by summing the

00:01:07.570 --> 00:01:11.820
element stiffness matrices, as
schematically shown here.

00:01:11.820 --> 00:01:16.140
This we refer to as the direct
stiffness procedure, and that

00:01:16.140 --> 00:01:19.430
direct stiffness procedure is
also applicable to the load

00:01:19.430 --> 00:01:23.490
contributions, where we sum the
element load contribution

00:01:23.490 --> 00:01:29.160
into a total nodal point load
vector RB, and similarly for

00:01:29.160 --> 00:01:32.570
RS and so on, which then
together make up the total

00:01:32.570 --> 00:01:35.140
load vector R.

00:01:35.140 --> 00:01:38.870
We pointed out that the
stiffness matrix of a typical

00:01:38.870 --> 00:01:43.900
element M is obtained via
this relationship here.

00:01:43.900 --> 00:01:47.930
Notice in this integer, BM is
the strain displacement

00:01:47.930 --> 00:01:51.870
transformation matrix, CM is
the stress-strain law, and

00:01:51.870 --> 00:01:53.880
here we have Bm transposed.

00:01:53.880 --> 00:01:55.900
We're integrating this
part over the total

00:01:55.900 --> 00:01:58.240
volume of the element.

00:01:58.240 --> 00:02:03.080
The RB vector for element M
was written as shown here,

00:02:03.080 --> 00:02:09.190
where FB are the body loads
per unit volume into the

00:02:09.190 --> 00:02:11.580
coordinate directions
considered.

00:02:11.580 --> 00:02:15.620
Of course, these FB loads are
a function of the coordinate

00:02:15.620 --> 00:02:19.340
is the element, and HM
is the displacement

00:02:19.340 --> 00:02:20.860
interpolation matrix.

00:02:20.860 --> 00:02:24.110
We are once again integrating
this product over the total

00:02:24.110 --> 00:02:26.320
volume of the element.

00:02:26.320 --> 00:02:32.960
In both of these equations, we
have been dealing with the HM

00:02:32.960 --> 00:02:35.340
matrix and the BM matrix.

00:02:35.340 --> 00:02:38.290
Of course, the BM matrix, as we
discussed, is obtained from

00:02:38.290 --> 00:02:42.660
the HM matrix by appropriate
differentiations and so on.

00:02:42.660 --> 00:02:47.710
Now we pointed out that if we
had N number of degrees of

00:02:47.710 --> 00:02:52.960
freedom in the total structure,
then our HM matrix

00:02:52.960 --> 00:02:58.620
is of order k by N. Capital N,
the same N that we're talking

00:02:58.620 --> 00:03:00.410
about here.

00:03:00.410 --> 00:03:04.790
k is equal to 1, 2, or 3,
depending on whether we are

00:03:04.790 --> 00:03:08.140
dealing with a 1, 2, or
3-dimensional analysis.

00:03:08.140 --> 00:03:13.890
The BM matrix is of order l by
N, where l is equal to the

00:03:13.890 --> 00:03:17.200
number of strain components
that we are

00:03:17.200 --> 00:03:18.860
including in the element.

00:03:18.860 --> 00:03:22.110
In a 3-dimensional element, for
example, we would have l

00:03:22.110 --> 00:03:26.320
being equal to 6, because there
are 6 strain components.

00:03:26.320 --> 00:03:29.970
It's important that we talk
here about capital N being

00:03:29.970 --> 00:03:33.040
equal to the total number
of degrees of freedom.

00:03:33.040 --> 00:03:39.420
This way, this KM matrix here is
a matrix of order capital N

00:03:39.420 --> 00:03:45.130
by capital N. In other words,
this is an N-by-N matrix, and

00:03:45.130 --> 00:03:52.480
this RB vector here is a vector
of length N. It's has N

00:03:52.480 --> 00:03:57.320
entries this way, and of
course only one column.

00:03:57.320 --> 00:04:02.030
Having here an N-by-N matrix and
an N-by-1 vector here, we

00:04:02.030 --> 00:04:08.790
can directly assemble the
element contributions into the

00:04:08.790 --> 00:04:13.410
global structural matrices
and vectors.

00:04:13.410 --> 00:04:17.670
We can do this because this
matrix here has the same order

00:04:17.670 --> 00:04:22.460
at that matrix here, or each
of the element matrices has

00:04:22.460 --> 00:04:25.810
the same order as the total
structure matrix.

00:04:25.810 --> 00:04:28.960
Well, in practice, this is,
of course, not efficient.

00:04:28.960 --> 00:04:31.450
We are dealing with a
very large system.

00:04:31.450 --> 00:04:34.210
The capital N that we're talking
about here might be

00:04:34.210 --> 00:04:38.980
2,000, 3,000, 10,000, and it is
not efficient to calculate

00:04:38.980 --> 00:04:44.640
here in a capital N-by-N matrix
for each element,

00:04:44.640 --> 00:04:49.970
because we recognized already
earlier that a large number of

00:04:49.970 --> 00:04:54.390
rows and columns are simply
zeros in this matrix here.

00:04:54.390 --> 00:04:58.490
In fact, only those rows and
columns contain non-zero

00:04:58.490 --> 00:05:02.170
contributions or non-zero
elements which correspond to

00:05:02.170 --> 00:05:04.610
the element degrees
of freedom.

00:05:04.610 --> 00:05:06.690
In practice, therefore,
we calculate

00:05:06.690 --> 00:05:08.450
compacted element matrices.

00:05:08.450 --> 00:05:12.760
We are calculating for element
M or for typical element M

00:05:12.760 --> 00:05:16.270
matrix o order little n-by-n.

00:05:16.270 --> 00:05:19.680
Notice that I left out
the superscript here.

00:05:19.680 --> 00:05:24.490
And our RV vector would be an
n-by-1, lower case n, where n

00:05:24.490 --> 00:05:27.760
is now the number of element
degrees of freedom.

00:05:27.760 --> 00:05:31.140
The H matrix that we're using
and the B matrix that we're

00:05:31.140 --> 00:05:37.426
using now is a k-by-little n,
l-by-little n, versus here,

00:05:37.426 --> 00:05:43.710
k-by-capital N, l-by-capital
N. We talk here about the

00:05:43.710 --> 00:05:48.270
compacted matrices, and these
compacted matrices contain

00:05:48.270 --> 00:05:53.720
really all the information of
these, which we might call

00:05:53.720 --> 00:05:55.490
blown-up matrices.

00:05:55.490 --> 00:05:59.770
Because the non-zero entries in
these blown-up matrices are

00:05:59.770 --> 00:06:06.250
all contained in the K matrix
that I talked about here.

00:06:06.250 --> 00:06:09.650
What we need, then, in practice
is the K matrix, the

00:06:09.650 --> 00:06:13.800
compacted matrix, with
connectivity arrays, in order

00:06:13.800 --> 00:06:16.650
to be able to go through
this process here.

00:06:16.650 --> 00:06:19.940
In order to be able to assemble
the compacted element

00:06:19.940 --> 00:06:23.440
matrices into a global
structural stiffness matrix.

00:06:23.440 --> 00:06:26.750
That is done by a connectivity
array, as I will be

00:06:26.750 --> 00:06:27.890
discussing just now.

00:06:27.890 --> 00:06:30.420
That is one of the important
aspects that I would like to

00:06:30.420 --> 00:06:33.430
discuss with you in
this lecture.

00:06:33.430 --> 00:06:37.290
Well, I have prepared here some
view graphs as before,

00:06:37.290 --> 00:06:40.960
and let us look at the first
one here, in which I simply

00:06:40.960 --> 00:06:44.500
summarize one through three
phases that we are going

00:06:44.500 --> 00:06:46.520
through in a finite
element analysis.

00:06:46.520 --> 00:06:49.350
The first phase consists of
the calculation of the

00:06:49.350 --> 00:06:52.240
structure matrices K, M,
C, and R, whichever are

00:06:52.240 --> 00:06:53.100
applicable.

00:06:53.100 --> 00:06:57.010
Here I mean static dynamic
analysis, et cetera.

00:06:57.010 --> 00:07:00.000
The second phase, then, once
we have established these

00:07:00.000 --> 00:07:02.730
global structural stiffness
matrices, consists of the

00:07:02.730 --> 00:07:05.280
solution of the equilibrium
equation.

00:07:05.280 --> 00:07:09.170
Of course, this solution is
carried out differently in

00:07:09.170 --> 00:07:12.370
static analysis and in dynamic
analysis, and I will be

00:07:12.370 --> 00:07:15.650
discussing the solution
procedures that we're using in

00:07:15.650 --> 00:07:17.100
later lectures.

00:07:17.100 --> 00:07:19.560
Once we have solid state
equilibrium equations for the

00:07:19.560 --> 00:07:22.180
displacements, velocities,
accelerations, we can

00:07:22.180 --> 00:07:23.920
calculate the element
stresses.

00:07:23.920 --> 00:07:26.380
The element stresses are then
obtained from the strain

00:07:26.380 --> 00:07:30.010
displacement matrices and the
stress-strain law, together

00:07:30.010 --> 00:07:33.020
with the displacement as a nodal
point displacement that

00:07:33.020 --> 00:07:35.300
we have evaluated.

00:07:35.300 --> 00:07:39.430
In this lecture, I really
want to discuss with

00:07:39.430 --> 00:07:41.680
you only phase one.

00:07:41.680 --> 00:07:43.510
In other words, how do we
calculate the structure

00:07:43.510 --> 00:07:46.950
matrices whichever
are applicable?

00:07:46.950 --> 00:07:50.720
This phase one can be
subdivided, again, into three

00:07:50.720 --> 00:07:53.060
different steps, and
I summarize these

00:07:53.060 --> 00:07:54.250
on this view graph.

00:07:54.250 --> 00:07:57.730
The nodal point on element
information are read and/or

00:07:57.730 --> 00:07:58.970
generated first.

00:07:58.970 --> 00:08:03.120
Notice that I also included
generated here, because there

00:08:03.120 --> 00:08:07.370
is much repetitiveness in many
finite element analyses, and

00:08:07.370 --> 00:08:09.990
we want to take advantage of
that repetitiveness, therefore

00:08:09.990 --> 00:08:14.220
generate information data
whenever is possible.

00:08:14.220 --> 00:08:17.860
Then once we had the nodal point
in element information

00:08:17.860 --> 00:08:20.920
read into the computer program,
we calculate the

00:08:20.920 --> 00:08:23.510
element stiffness matrices.

00:08:23.510 --> 00:08:26.530
The mass and damping matrices,
if they are applicable, and

00:08:26.530 --> 00:08:29.010
equivalent node upon loads.

00:08:29.010 --> 00:08:32.500
Once we calculated the element
stiffness matrices, we can

00:08:32.500 --> 00:08:35.780
assemble math and damping
matrices, of course.

00:08:35.780 --> 00:08:39.480
Also, we can assemble all of
these contributions here into

00:08:39.480 --> 00:08:44.910
the global structure matrices,
K, M, C, and R. And I would

00:08:44.910 --> 00:08:48.710
like to discuss this process
in detail with you.

00:08:48.710 --> 00:08:51.590
Before going into the details,
let me mention that the

00:08:51.590 --> 00:08:54.080
procedures which I will be
discussing this you are really

00:08:54.080 --> 00:08:56.550
the procedures that are
used in the computer

00:08:56.550 --> 00:08:59.040
program Sab and ADINA.

00:08:59.040 --> 00:09:03.160
But very similar procedures
are also used in other

00:09:03.160 --> 00:09:05.440
computer programs.

00:09:05.440 --> 00:09:09.090
The first important aspect that
I like to mention to you

00:09:09.090 --> 00:09:12.580
is that in a finite element
analysis, we have to define

00:09:12.580 --> 00:09:15.560
what degrees of freedom
we want to admit

00:09:15.560 --> 00:09:16.820
at the nodal point.

00:09:16.820 --> 00:09:20.370
In other words, if we have a
finite element mesh such as

00:09:20.370 --> 00:09:24.890
this one here, I will be talking
about that mesh in

00:09:24.890 --> 00:09:26.260
more detail later.

00:09:26.260 --> 00:09:29.315
Then if this is a plane stress
analysis, in other words, here

00:09:29.315 --> 00:09:32.640
we have a cantilever plate,
say, subjected to a load

00:09:32.640 --> 00:09:35.660
there, if it's a plane stress
analysis, I only want to admit

00:09:35.660 --> 00:09:39.630
certain degrees of freedom
at each of these nodes.

00:09:39.630 --> 00:09:41.640
We have nine nodes here.

00:09:41.640 --> 00:09:45.560
For example, at these nodes,
there shall be no degrees of

00:09:45.560 --> 00:09:48.440
freedom admitted, or else I want
to knock out all of the

00:09:48.440 --> 00:09:52.070
degrees of freedom to simulate
the boundary condition along

00:09:52.070 --> 00:09:56.070
here, and at these degrees of
freedom here, away from the

00:09:56.070 --> 00:10:00.220
edge, I have two degrees of
freedom to correspond to a

00:10:00.220 --> 00:10:01.760
plane stress condition.

00:10:01.760 --> 00:10:06.920
Well, if I want to do that for
this analysis and similarly,

00:10:06.920 --> 00:10:12.170
of course, I proceed in other
analyses, then I want to deal

00:10:12.170 --> 00:10:14.450
with each nodal point in turn.

00:10:14.450 --> 00:10:18.460
And here I have a typical nodal
point i, say, at which

00:10:18.460 --> 00:10:21.910
we can have altogether a certain
number of degrees of

00:10:21.910 --> 00:10:24.340
freedom, the maximum that I
might want to admit in a

00:10:24.340 --> 00:10:25.550
computer program.

00:10:25.550 --> 00:10:30.030
Now in Sab and ADINA, we admit
a maximum of 6 degrees of

00:10:30.030 --> 00:10:32.180
freedom, however, we
might have more.

00:10:32.180 --> 00:10:35.070
In piping analysis, we might
have generalized organization

00:10:35.070 --> 00:10:39.100
degrees of freedom, such as we
are using in ADINA P, and then

00:10:39.100 --> 00:10:42.350
we would have more degrees of
freedom at the nodal point i.

00:10:42.350 --> 00:10:46.050
But let's talk now only
about 6 degrees of

00:10:46.050 --> 00:10:48.650
freedom and the maximum.

00:10:48.650 --> 00:10:51.840
I denote the first degree of
freedom as the U degree of

00:10:51.840 --> 00:10:54.510
freedom, the second degree of
freedom as the V degree of

00:10:54.510 --> 00:10:58.360
freedom, the third degree of
freedom as the W degree of

00:10:58.360 --> 00:11:02.940
freedom, the fourth one as the
rotation about the x-axis,

00:11:02.940 --> 00:11:04.400
shown by this vector.

00:11:04.400 --> 00:11:07.710
Notice that here I'm talking
about a vector such as this

00:11:07.710 --> 00:11:09.400
one here shown.

00:11:09.400 --> 00:11:12.970
And theta Y is the fifth degree
of freedom, theta Z is

00:11:12.970 --> 00:11:14.850
the sixth degree of freedom.

00:11:14.850 --> 00:11:19.660
What we are doing then is to
define a matrix ID, or we call

00:11:19.660 --> 00:11:23.320
it the ID array, identification
array, which

00:11:23.320 --> 00:11:26.540
has a certain number
of rows and a

00:11:26.540 --> 00:11:28.710
certain number also columns.

00:11:28.710 --> 00:11:32.600
The number of rows is equal to
the maximum number of degrees

00:11:32.600 --> 00:11:36.260
of freedom that we can
have in the analysis.

00:11:36.260 --> 00:11:42.720
Now in this particular case,
we have 6 as the maximum--

00:11:42.720 --> 00:11:45.510
1, 2, 3, 4, 5, 6.

00:11:45.510 --> 00:11:47.880
The number of nodal points,
of course, vary

00:11:47.880 --> 00:11:49.800
from analysis to analysis.

00:11:49.800 --> 00:11:55.800
They might be 1,000, 5,000,
or even more.

00:11:55.800 --> 00:12:02.100
For each nodal point, we have 1
column, therefore 6 entries.

00:12:02.100 --> 00:12:05.820
And for each nodal point, we
can use these 6 entries to

00:12:05.820 --> 00:12:10.130
define whether a degree of
freedom is active or

00:12:10.130 --> 00:12:11.110
non-active.

00:12:11.110 --> 00:12:15.690
A degree of freedom is active if
stiffness is put into that

00:12:15.690 --> 00:12:18.500
degree of freedom, if stiffness
is defined in that

00:12:18.500 --> 00:12:20.290
degree of freedom.

00:12:20.290 --> 00:12:24.760
Well, let us go through
a specific example.

00:12:24.760 --> 00:12:29.310
Here we have a cantilever
analysis, cantilever plate

00:12:29.310 --> 00:12:37.390
analysis, and here we have a
2-by-2 elements idealization

00:12:37.390 --> 00:12:41.910
of that plate, containing
altogether 4 elements.

00:12:41.910 --> 00:12:43.860
It's a plane stress analysis.

00:12:43.860 --> 00:12:48.360
The loading on this plate is
while at temperature 100

00:12:48.360 --> 00:12:52.680
degrees Celsius top, 70 degrees
Celsius bottom.

00:12:52.680 --> 00:12:56.500
And there might be a
concentrated load, such as

00:12:56.500 --> 00:12:58.620
shown here.

00:12:58.620 --> 00:12:59.490
Et cetera.

00:12:59.490 --> 00:13:02.600
But let us now focus our
attention on, how do we

00:13:02.600 --> 00:13:06.080
generate the element matrices,
and how do we assemble these

00:13:06.080 --> 00:13:09.780
element matrices into the
global structure matrix?

00:13:09.780 --> 00:13:13.270
Well, this is a 2-by-2 element
idealization .

00:13:13.270 --> 00:13:14.920
We notice the following.

00:13:14.920 --> 00:13:23.780
We notice that we have
altogether 9 nodal points--

00:13:23.780 --> 00:13:28.340
and let me use the
pointer here.

00:13:28.340 --> 00:13:34.350
1, 2, 3, 4, 5, 6, 7,
8, 9 nodal points--

00:13:34.350 --> 00:13:38.050
that with these 9
nodal points, we

00:13:38.050 --> 00:13:41.110
have defined 4 elements--

00:13:41.110 --> 00:13:44.980
element 1, 2, 3, 4--

00:13:44.980 --> 00:13:53.700
that element 1 and 2 have the
same material properties, and

00:13:53.700 --> 00:13:57.200
element 3 and 4 have the same
material properties.

00:13:57.200 --> 00:14:00.870
Notice the Young's modulus is
here 2 times 10 to the sixth,

00:14:00.870 --> 00:14:06.850
whereas it is 1 times 10 to the
sixth for element 1 and 2.

00:14:06.850 --> 00:14:10.450
Therefore, we will have to
define two sets of material

00:14:10.450 --> 00:14:11.150
properties--

00:14:11.150 --> 00:14:13.430
one set for these elements,
and one

00:14:13.430 --> 00:14:15.990
set for these elements.

00:14:15.990 --> 00:14:20.130
We also notice that since
we have 9 nodal points

00:14:20.130 --> 00:14:24.890
altogether, we could have a
maximum of 18 degrees of

00:14:24.890 --> 00:14:28.280
freedom in a plane stress
analysis, because there are

00:14:28.280 --> 00:14:32.300
two degrees of freedom in a
plane stress analysis for each

00:14:32.300 --> 00:14:33.570
nodal point.

00:14:33.570 --> 00:14:37.280
However, these 18, of course,
represent the absolute

00:14:37.280 --> 00:14:41.550
maximum, which in a static
analysis, we could not use,

00:14:41.550 --> 00:14:45.350
because we would have to also
constrain the element mesh

00:14:45.350 --> 00:14:48.090
sufficiently to obtain a
solution, to have a stable

00:14:48.090 --> 00:14:51.720
structure, in other words, while
the constraints here are

00:14:51.720 --> 00:14:55.380
that at these nodal points, that
all displacement shall be

00:14:55.380 --> 00:14:57.080
equal to 0.

00:14:57.080 --> 00:15:00.270
Now let us look at our ID array,
the ID array which I

00:15:00.270 --> 00:15:02.120
mentioned right here.

00:15:02.120 --> 00:15:06.180
We will have, in other words,
9 columns here, because we

00:15:06.180 --> 00:15:11.470
have 9 nodal points, and we have
our 6 rows here, because

00:15:11.470 --> 00:15:13.740
we have a maximum of 6
degrees of freedom.

00:15:16.930 --> 00:15:23.510
An active degree of freedom we
denote by a 0 in this matrix.

00:15:23.510 --> 00:15:26.590
A non-active degree of
freedom we denote by

00:15:26.590 --> 00:15:28.790
1 in this ID matrix.

00:15:28.790 --> 00:15:30.150
We notice the following.

00:15:30.150 --> 00:15:34.802
If I put here the number of
nodal points along, we have 1,

00:15:34.802 --> 00:15:39.970
2, 3, 4, 5, 6, 7, 8, 9.

00:15:39.970 --> 00:15:45.010
Of course, the degrees of
freedom here are U, V, W,

00:15:45.010 --> 00:15:49.250
theta X, theta Y, theta Z.

00:15:49.250 --> 00:15:53.550
Now, notice that what we are
saying is that only for nodal

00:15:53.550 --> 00:15:58.740
points 4, 5, 6, 7, 8, and 9,
we have these as active

00:15:58.740 --> 00:16:00.160
degrees of freedom.

00:16:00.160 --> 00:16:09.760
In other words, At nodal point
4, 5, 6, 7, 8, 9, we have

00:16:09.760 --> 00:16:11.470
active degrees of freedom.

00:16:11.470 --> 00:16:13.730
These will be active
degrees of freedom.

00:16:19.230 --> 00:16:23.440
And let me finish these
here too on this side.

00:16:23.440 --> 00:16:26.610
So we have these as active
degrees of freedom.

00:16:26.610 --> 00:16:31.040
These degrees of freedom and on
this side are interactive,

00:16:31.040 --> 00:16:34.000
because their constraint.

00:16:34.000 --> 00:16:35.650
They are no displacement.

00:16:35.650 --> 00:16:39.620
Of course, stiffness is coming
into these degrees of freedom

00:16:39.620 --> 00:16:40.640
through, yes.

00:16:40.640 --> 00:16:43.510
So we could have made these
active degrees of freedom.

00:16:43.510 --> 00:16:46.360
However, in addition, we also
know that the displacements

00:16:46.360 --> 00:16:50.615
are 0 there, so we make them
inactive on that basis.

00:16:53.470 --> 00:16:57.190
The result, then, is that we
have to read into the ID array

00:16:57.190 --> 00:16:58.330
as shown here.

00:16:58.330 --> 00:17:01.680
This is the typical reading
that you would use in the

00:17:01.680 --> 00:17:03.090
ADINA computer program.

00:17:03.090 --> 00:17:07.790
Once in all of those entries
here, and zeros there.

00:17:07.790 --> 00:17:12.630
Now the program knows that
corresponding to these zeros

00:17:12.630 --> 00:17:16.869
here, we will have to set
up element equations.

00:17:16.869 --> 00:17:20.069
In other words, actually, we
have to set up for each zero

00:17:20.069 --> 00:17:24.849
one equation, one global
degree of freedom.

00:17:24.849 --> 00:17:28.109
And the program that
goes through

00:17:28.109 --> 00:17:29.650
this process as follows.

00:17:29.650 --> 00:17:32.130
It searches through--

00:17:32.130 --> 00:17:33.750
let me go once more back--

00:17:33.750 --> 00:17:39.820
through these elements of the
ID matrix product that you

00:17:39.820 --> 00:17:42.140
have been feeding into
the program.

00:17:42.140 --> 00:17:46.050
It searches through it, and
replaces each one by a zero,

00:17:46.050 --> 00:17:50.370
going down column-wise, and
each zero by a number.

00:17:50.370 --> 00:17:55.650
It starts with 1 and goes on
consecutively to the maximum

00:17:55.650 --> 00:17:58.400
number of zeros that
it encounters.

00:17:58.400 --> 00:18:00.930
The final result, then,
is this one.

00:18:00.930 --> 00:18:06.340
Maybe I can just put it on top,
only to signify here that

00:18:06.340 --> 00:18:10.430
we had all of these now zeros
which we are ones before, and

00:18:10.430 --> 00:18:12.690
some numbers in this
corner here where

00:18:12.690 --> 00:18:14.200
we had zeros before.

00:18:14.200 --> 00:18:18.240
Let me take the bottom view
graph out, and so now we see

00:18:18.240 --> 00:18:19.250
what has happened.

00:18:19.250 --> 00:18:25.710
We have 0s everywhere here and
equation numbers up here,

00:18:25.710 --> 00:18:29.770
which have been generated by
going through the original

00:18:29.770 --> 00:18:34.770
columns of the ID array from top
to bottom, and replacing

00:18:34.770 --> 00:18:36.490
the zeros by numbers--

00:18:36.490 --> 00:18:40.220
1, 2-- these were all ones,
we put zeros here--

00:18:40.220 --> 00:18:41.810
3, 4--

00:18:41.810 --> 00:18:43.120
put zeros here--

00:18:43.120 --> 00:18:44.060
5, 6--

00:18:44.060 --> 00:18:45.840
put zeros here-- et cetera.

00:18:45.840 --> 00:18:49.010
Now, these are the degrees of
freedom that the structure

00:18:49.010 --> 00:18:54.470
will actually have, and they are
defined because stiffness

00:18:54.470 --> 00:18:57.120
is coming into each of these
degrees of freedom from the

00:18:57.120 --> 00:19:02.060
plane stress element, and we
know them to be non-zero.

00:19:02.060 --> 00:19:07.640
In other words, if we look at
our final element idealization

00:19:07.640 --> 00:19:13.120
again, we find that these
vectors here are active

00:19:13.120 --> 00:19:16.370
degrees of freedom, which
I pointed out earlier.

00:19:16.370 --> 00:19:20.890
In fact, this is here degree of
freedom 1, this is degree

00:19:20.890 --> 00:19:26.910
of freedom 2, which is at nodal
point 4, and here we

00:19:26.910 --> 00:19:31.530
have degree of freedom 3, and
then 4, at nodal point 5.

00:19:31.530 --> 00:19:35.000
And those entries are
just those here.

00:19:35.000 --> 00:19:38.550
At nodal point 4, remember
nodal points along here.

00:19:38.550 --> 00:19:40.220
So this is nodal point 4.

00:19:40.220 --> 00:19:42.940
We have the first and second
degree of freedom of the

00:19:42.940 --> 00:19:44.420
structural model.

00:19:44.420 --> 00:19:47.960
At nodal point 5, we have the
third and fourth degree of

00:19:47.960 --> 00:19:50.470
freedom of the total
structural model.

00:19:50.470 --> 00:19:51.690
Et cetera.

00:19:51.690 --> 00:19:54.110
Well, this is an important
aspect.

00:19:54.110 --> 00:19:56.490
Let us now go on
to some further

00:19:56.490 --> 00:19:58.720
aspects of the analyses.

00:19:58.720 --> 00:20:01.880
We will use this later on, once
again, when we set up the

00:20:01.880 --> 00:20:04.330
connectivity arrays
of the element.

00:20:04.330 --> 00:20:08.170
Here is our finite element
idealization, once again.

00:20:08.170 --> 00:20:12.170
And the next step now is to read
in also the coordinates

00:20:12.170 --> 00:20:14.140
of all the elements and
the temperatures

00:20:14.140 --> 00:20:15.510
at the nodal points.

00:20:15.510 --> 00:20:21.230
Now with this coordinate system,
x, y, and z, as shown

00:20:21.230 --> 00:20:25.380
here, the coordinate of all of
these nodal points can be read

00:20:25.380 --> 00:20:26.400
indirectly.

00:20:26.400 --> 00:20:28.990
You can read them up. if you
know the length from here to

00:20:28.990 --> 00:20:32.470
there, being 60 centimeters and
being from here to there

00:20:32.470 --> 00:20:35.940
40 centimeters, surely all the
coordinates can be defined.

00:20:35.940 --> 00:20:38.610
And knowing that the temperature
is given here at

00:20:38.610 --> 00:20:41.840
70 degrees Celsius and 100
degrees Celsius there, and

00:20:41.840 --> 00:20:45.110
there's a linear variation
from top to bottom in

00:20:45.110 --> 00:20:48.690
temperature, we directly also
define the temperature array,

00:20:48.690 --> 00:20:49.890
as shown here.

00:20:49.890 --> 00:20:54.160
These are the temperatures at
nodal point 1 to 9, x, y, z

00:20:54.160 --> 00:20:57.600
coordinates at nodal
point 1 to 9.

00:20:57.600 --> 00:20:58.950
Of course, this is input.

00:20:58.950 --> 00:21:03.770
You have to input this to the
computer program, just the

00:21:03.770 --> 00:21:05.790
same way as you have to
input to the computer

00:21:05.790 --> 00:21:07.660
program the ID array.

00:21:07.660 --> 00:21:15.230
But then the computer program
figures out what coordinates

00:21:15.230 --> 00:21:20.290
of these arrays pertain to
the specific elements.

00:21:20.290 --> 00:21:22.630
And that is done in
the following way.

00:21:22.630 --> 00:21:26.610
Once again, here is our
element idealization.

00:21:26.610 --> 00:21:31.130
Now we have read in the fact
that we want to have this as

00:21:31.130 --> 00:21:36.010
the first 2 degrees
of freedom, then

00:21:36.010 --> 00:21:37.040
this degree of freedom.

00:21:37.040 --> 00:21:39.770
That we have already all
established, that we have

00:21:39.770 --> 00:21:42.360
these degrees of freedom in
the finite element mesh.

00:21:42.360 --> 00:21:44.110
The program knows
that already.

00:21:44.110 --> 00:21:47.750
That it does know via the
reading of the information in

00:21:47.750 --> 00:21:49.830
the ID array.

00:21:49.830 --> 00:21:52.710
We also have all the coordinates
of the nodal

00:21:52.710 --> 00:21:55.050
points, and we also have
the temperatures of

00:21:55.050 --> 00:21:56.540
all the nodal points.

00:21:56.540 --> 00:22:00.660
What we still have to now read
in is how an element is

00:22:00.660 --> 00:22:04.940
connected to the various nodal
points given in the structure.

00:22:04.940 --> 00:22:08.660
And that is the next
important reading.

00:22:08.660 --> 00:22:13.590
Here for element 1, we know that
the node numbers are 5,

00:22:13.590 --> 00:22:18.090
2, 1, and 4, and the material
property is number 1.

00:22:18.090 --> 00:22:19.590
Let's go back once more.

00:22:19.590 --> 00:22:24.190
For element 1, that is, this
element here, I want to use

00:22:24.190 --> 00:22:27.520
this material property
set, and I call that

00:22:27.520 --> 00:22:29.120
property set number 1.

00:22:29.120 --> 00:22:31.660
Property set number 1,
also, for element 2.

00:22:31.660 --> 00:22:37.120
But property set number 2 for
elements 3 and for element 4,

00:22:37.120 --> 00:22:39.210
because these element
properties are

00:22:39.210 --> 00:22:41.410
different from these.

00:22:41.410 --> 00:22:44.650
Well, so element one
has nodal points--

00:22:44.650 --> 00:22:46.710
I use the following
convention--

00:22:46.710 --> 00:22:49.040
5, 2, 1, 4.

00:22:49.040 --> 00:22:51.080
I go counterclockwise around.

00:22:51.080 --> 00:22:56.350
So locally, I'm thinking of a
coordinate system lying in the

00:22:56.350 --> 00:22:58.350
elements, such as shown here.

00:22:58.350 --> 00:23:03.370
And this one here being in the
positive quadrant is my first

00:23:03.370 --> 00:23:07.440
nodal point that I assign
to the element.

00:23:07.440 --> 00:23:11.500
This is, therefore, the
local nodal point 1.

00:23:11.500 --> 00:23:14.310
Let's put another little
picture here.

00:23:14.310 --> 00:23:16.060
This is a local nodal point 1.

00:23:16.060 --> 00:23:17.650
That's local nodal point 2.

00:23:17.650 --> 00:23:19.510
That's local nodal point 3.

00:23:19.510 --> 00:23:23.630
That's local nodal point 4 for
any one of these elements.

00:23:23.630 --> 00:23:27.160
The local nodal point 1
corresponds to the global

00:23:27.160 --> 00:23:28.900
nodal point 5.

00:23:28.900 --> 00:23:31.000
2 corresponds to 2.

00:23:31.000 --> 00:23:36.890
3 here corresponds to 1 there, 4
here corresponds to 4 there.

00:23:36.890 --> 00:23:41.185
I say, therefore, that the node
numbers of the element

00:23:41.185 --> 00:23:44.380
are 5, 2, 1, 4.

00:23:44.380 --> 00:23:48.070
The element number 2, then, with
this convention that I'm

00:23:48.070 --> 00:23:54.900
using, has nodal point
6, 3, 2, 5.

00:23:54.900 --> 00:23:56.510
Well, let's look here.

00:23:56.510 --> 00:23:58.550
We have here 6, 3, 2, 5.

00:23:58.550 --> 00:24:00.320
Also properties at 1.

00:24:00.320 --> 00:24:02.900
Let's go on to element
number 3.

00:24:02.900 --> 00:24:04.900
Here with this convention,
once again, we

00:24:04.900 --> 00:24:07.770
have 8, 5, 4, 7.

00:24:11.210 --> 00:24:15.180
And now, however, the material
property set number 2.

00:24:15.180 --> 00:24:16.160
Et cetera.

00:24:16.160 --> 00:24:23.270
Now, once the program knows
these nodal point numbers, it

00:24:23.270 --> 00:24:25.990
can figure out a connectivity
array.

00:24:25.990 --> 00:24:33.050
And that is done using the ID
array that the program has

00:24:33.050 --> 00:24:34.710
already established.

00:24:34.710 --> 00:24:37.120
It's being done in the
following way.

00:24:37.120 --> 00:24:45.460
Remember that, once again, nodal
point 1, 2, 3, 4, 5, 6,

00:24:45.460 --> 00:24:50.950
7, 8, and 9 correspond
to these columns?

00:24:50.950 --> 00:24:55.880
Now, we know from this
information here that element

00:24:55.880 --> 00:25:00.490
1 couples into nodal
point 5, 2, 1, 4.

00:25:00.490 --> 00:25:07.470
Let's keep that in mind, now, 5,
2, 1, 4, and circle here 5,

00:25:07.470 --> 00:25:14.720
2, 1, and 4, where this one here
is the first local nodal

00:25:14.720 --> 00:25:21.620
point, this is the second local
nodal point, this is the

00:25:21.620 --> 00:25:25.060
third local nodal point,
and that is the

00:25:25.060 --> 00:25:26.950
fourth local nodal point.

00:25:26.950 --> 00:25:28.300
That's important.

00:25:28.300 --> 00:25:33.200
Well, if we look at that
information, then, recognizing

00:25:33.200 --> 00:25:37.430
that the local nodal point 1
corresponds to the global

00:25:37.430 --> 00:25:44.440
nodal point 5, we have to use
these two equation numbers

00:25:44.440 --> 00:25:48.560
corresponding to the
first nodal points.

00:25:48.560 --> 00:25:51.330
Let's put a little
picture up here.

00:25:51.330 --> 00:25:53.670
You see what I'm saying
here is the following.

00:25:53.670 --> 00:25:57.980
If this is local nodal point
1, that's 2, that's 3, and

00:25:57.980 --> 00:26:03.900
that's 4, and if I know that
this local nodal point with

00:26:03.900 --> 00:26:09.170
degrees of freedom, let's call
them little u and little v,

00:26:09.170 --> 00:26:14.830
corresponds really to the global
point 5 with degrees of

00:26:14.830 --> 00:26:22.080
freedom 3 and 4, then this u
must correspond to 3 here, and

00:26:22.080 --> 00:26:26.260
that v must correspond
to that 4 here.

00:26:26.260 --> 00:26:30.800
In other words, our connectivity
array which we

00:26:30.800 --> 00:26:34.810
will be using is established
as follows.

00:26:34.810 --> 00:26:40.670
For our compact matrix, we have
8 rows and columns, and

00:26:40.670 --> 00:26:45.500
for our actual matrix that we
want to add into the structure

00:26:45.500 --> 00:26:51.240
matrix, we notice that what we
want to do is take the first

00:26:51.240 --> 00:26:55.440
row and column here, and add
it into the third row and

00:26:55.440 --> 00:26:58.510
column of the structure
matrix.

00:26:58.510 --> 00:27:04.990
The first one here, u here,
corresponds to 3 here.

00:27:04.990 --> 00:27:08.270
The second one here,
which is the v,

00:27:08.270 --> 00:27:11.360
corresponds to the 4 here.

00:27:11.360 --> 00:27:13.390
In other words, the first
degree of freedom of the

00:27:13.390 --> 00:27:16.340
element corresponds to the
third in the structure.

00:27:16.340 --> 00:27:19.200
The second degree of freedom of
the element corresponds to

00:27:19.200 --> 00:27:21.000
the fourth in the structure.

00:27:21.000 --> 00:27:23.390
And that is shown right here.

00:27:23.390 --> 00:27:26.690
The first one corresponds to
the third in the structure.

00:27:26.690 --> 00:27:30.810
The second one in the compact
element stiffness matrix

00:27:30.810 --> 00:27:32.460
corresponds to the
fourth degree of

00:27:32.460 --> 00:27:34.290
freedom in the structure.

00:27:34.290 --> 00:27:40.880
Now if we go onto the second
local nodal point, we see

00:27:40.880 --> 00:27:45.490
zeros here, and these zeros
go directly into the

00:27:45.490 --> 00:27:46.670
connectivity array.

00:27:46.670 --> 00:27:49.450
The third one has also zeros
here, and the fourth

00:27:49.450 --> 00:27:51.160
one has 1 and 2.

00:27:51.160 --> 00:27:54.890
So our connectivity array, then,
proceeding in the same

00:27:54.890 --> 00:27:58.290
way, is shown as given here.

00:27:58.290 --> 00:28:01.920
These are the degrees of freedom
at the first nodal

00:28:01.920 --> 00:28:05.270
point, this first local
nodal point.

00:28:05.270 --> 00:28:08.690
These are the degrees of freedom
at the second local

00:28:08.690 --> 00:28:09.710
nodal point.

00:28:09.710 --> 00:28:12.350
These are the degrees of freedom
at the third local

00:28:12.350 --> 00:28:14.630
nodal point, and these are the
degrees of freedom at the

00:28:14.630 --> 00:28:16.550
fourth local nodal point.

00:28:16.550 --> 00:28:18.250
In other words, what
I'm saying here

00:28:18.250 --> 00:28:19.870
really is the following.

00:28:19.870 --> 00:28:23.540
You see this here is
the third degree of

00:28:23.540 --> 00:28:25.490
freedom in the structure.

00:28:25.490 --> 00:28:27.830
This is the fourth degree of
freedom in the structure.

00:28:27.830 --> 00:28:30.660
There is no degree of freedom
here because we

00:28:30.660 --> 00:28:32.500
have a support there.

00:28:32.500 --> 00:28:34.535
That is that zero
and that zero.

00:28:34.535 --> 00:28:37.270
There is no degree of freedom
here because we

00:28:37.270 --> 00:28:38.792
have a support here.

00:28:38.792 --> 00:28:40.340
0, 0.

00:28:40.340 --> 00:28:43.980
At this node, we are talking
about the first degree of

00:28:43.980 --> 00:28:47.380
freedom here and the second
degree of freedom here of this

00:28:47.380 --> 00:28:49.940
structure, and that
is given here.

00:28:49.940 --> 00:28:54.030
So if I have established the
8-by-8 stiffness matrix of the

00:28:54.030 --> 00:28:59.070
element, I can directly use that
8-by-8 stiffness matrix

00:28:59.070 --> 00:29:02.770
with this connectivity array,
and assemble the appropriate

00:29:02.770 --> 00:29:06.580
contributions from that 8-by-8
matrix into the global

00:29:06.580 --> 00:29:10.600
structure stiffness matrix.

00:29:10.600 --> 00:29:13.290
The same process that
is applied to all

00:29:13.290 --> 00:29:15.300
of the other elements--

00:29:15.300 --> 00:29:18.320
let's look at one more
element here.

00:29:18.320 --> 00:29:23.095
And element 2, as we pointed out
earlier, has nodal point

00:29:23.095 --> 00:29:24.880
6, 3, 2, 5.

00:29:24.880 --> 00:29:29.050
Well, what we then have to do
is look at our ID array.

00:29:29.050 --> 00:29:32.300
6, 3, 2, 5.

00:29:32.300 --> 00:29:34.330
And what we are seeing
immediately is that we have a

00:29:34.330 --> 00:29:39.340
5, 6 here and a 3, 4 here.

00:29:39.340 --> 00:29:41.920
So the first two entries in the
element array should be 5,

00:29:41.920 --> 00:29:44.820
6, and the last two entries
should be 3, 4, because we

00:29:44.820 --> 00:29:46.330
have all these zeros there.

00:29:46.330 --> 00:29:50.590
And indeed, if we look at
our LM vector here,

00:29:50.590 --> 00:29:52.280
that's what we obtain.

00:29:52.280 --> 00:29:55.170
Similarly, we proceed for
the other elements.

00:29:55.170 --> 00:30:01.610
This is the connectivity array
for element 2, for element 3,

00:30:01.610 --> 00:30:03.140
and for element 4.

00:30:03.140 --> 00:30:06.220
We can use that now to assemble
the element stiffness

00:30:06.220 --> 00:30:10.080
matrices into the global
structural stiffness matrix.

00:30:10.080 --> 00:30:14.820
Of course, the program figures
these out automatically from

00:30:14.820 --> 00:30:20.290
the ID array and from you having
put into the program

00:30:20.290 --> 00:30:23.990
the nodal points of
each element.

00:30:23.990 --> 00:30:28.730
Let us look now at how do we
actually deal with the

00:30:28.730 --> 00:30:30.110
stiffness matrix?

00:30:30.110 --> 00:30:35.040
Well, if we look at a typical
stiffness matrix--

00:30:35.040 --> 00:30:37.690
this might be a typical
one here--

00:30:37.690 --> 00:30:39.200
we have this pattern.

00:30:39.200 --> 00:30:44.210
Of course the matrix is
symmetric, and what we have

00:30:44.210 --> 00:30:49.760
are some non-zero elements
clustered to the diagonal, and

00:30:49.760 --> 00:30:53.030
some 0 elements out there.

00:30:53.030 --> 00:30:57.480
It is convenient at this point
to define a half bandwidth of

00:30:57.480 --> 00:30:58.820
the stiffness matrix.

00:30:58.820 --> 00:31:02.720
That half bandwidth is defined
in the following way.

00:31:02.720 --> 00:31:09.970
We ignore, first of all, the
diagonal element, and then we

00:31:09.970 --> 00:31:15.050
identify the furthest off
diagonal element from that

00:31:15.050 --> 00:31:16.240
diagonal element.

00:31:16.240 --> 00:31:19.650
The furthest one from the
diagonal element defines the

00:31:19.650 --> 00:31:22.190
half bandwidth of the matrix.

00:31:22.190 --> 00:31:26.340
mK is the half bandwidth
of the matrix.

00:31:26.340 --> 00:31:29.550
In some literature, we also
refer to the half bandwidth of

00:31:29.550 --> 00:31:32.750
the matrix as mK plus 1.

00:31:32.750 --> 00:31:35.950
But then remember that the total
bandwidth off the matrix

00:31:35.950 --> 00:31:40.180
is simply 2 mK plus 1, because
the diagonal element only

00:31:40.180 --> 00:31:41.830
occurs once.

00:31:41.830 --> 00:31:45.280
Another way of looking at the
definition of the half

00:31:45.280 --> 00:31:47.230
bandwidth is as follows.

00:31:47.230 --> 00:31:52.890
If we go from the diagonal up
in each column, we will come

00:31:52.890 --> 00:31:57.590
to an element above which
only zeros are.

00:31:57.590 --> 00:32:00.730
Like in this case, for example,
there are only zeros

00:32:00.730 --> 00:32:03.610
above K 4, 5.

00:32:03.610 --> 00:32:08.105
And we do the same for each
all of the columns, and we

00:32:08.105 --> 00:32:15.010
define the last non-zero
element, this one here, above

00:32:15.010 --> 00:32:18.160
which all elements are
zero, as the skyline.

00:32:18.160 --> 00:32:21.520
So the skyline is defined
as shown here.

00:32:24.080 --> 00:32:26.780
This is the skyline
of the matrix.

00:32:26.780 --> 00:32:31.000
The half bandwidth, then, is
equal to the maximum column

00:32:31.000 --> 00:32:34.100
height minus 1.

00:32:34.100 --> 00:32:36.770
In this particular case, you see
the maximum column height

00:32:36.770 --> 00:32:39.690
is 1, 2, 3, 4, which
we have here also--

00:32:39.690 --> 00:32:40.970
1, 2, 3, 4.

00:32:40.970 --> 00:32:45.860
We subtract 1 and we
get mK equal to 3.

00:32:45.860 --> 00:32:50.320
So this is the pattern that we
observe in an actual finite

00:32:50.320 --> 00:32:51.290
element analysis.

00:32:51.290 --> 00:32:55.320
What we would like to achieve is
that the half bandwidth is

00:32:55.320 --> 00:32:59.390
as small as possible, because
then we know that our

00:32:59.390 --> 00:33:01.750
numerical operations
is a solution of KU

00:33:01.750 --> 00:33:04.730
equals R are small.

00:33:04.730 --> 00:33:09.060
Well, the actual storage that
we're using, however, is a

00:33:09.060 --> 00:33:11.200
little different.

00:33:11.200 --> 00:33:16.560
Namely, it is effective to store
the total information as

00:33:16.560 --> 00:33:18.430
a one-dimensional array.

00:33:18.430 --> 00:33:21.640
And the storage, then, is
carried out as follows.

00:33:21.640 --> 00:33:25.190
Notice that in a one-dimensional
array, I am

00:33:25.190 --> 00:33:27.180
using now the following
convention.

00:33:27.180 --> 00:33:31.320
This here is the first element
in the one-dimensional array.

00:33:31.320 --> 00:33:35.440
The second element is this
k22, which is a2.

00:33:35.440 --> 00:33:38.700
The third element is k12.

00:33:38.700 --> 00:33:42.360
The fourth element is
k33, and so on.

00:33:42.360 --> 00:33:47.160
In other words, the A vector
here, being a one-dimensional

00:33:47.160 --> 00:33:51.840
vector, stores all of the
information here in a

00:33:51.840 --> 00:33:56.680
one-dimensional order, where we
simply go from the diagonal

00:33:56.680 --> 00:33:59.890
upwards to store all
of the elements.

00:33:59.890 --> 00:34:05.790
So a6 is the diagonal element
that is the fourth column

00:34:05.790 --> 00:34:11.199
here, a6 corresponds to k44, and
a7 then stores this one,

00:34:11.199 --> 00:34:13.780
a8 stores that one, a9
stores that one.

00:34:13.780 --> 00:34:16.290
Notice that we do carry
along these zeros.

00:34:16.290 --> 00:34:19.199
And the reason for it is that
when we do perform our

00:34:19.199 --> 00:34:22.480
solution of the equation, in
general, but not always, in

00:34:22.480 --> 00:34:26.040
general, this zero becomes
a non-zero element, and

00:34:26.040 --> 00:34:29.540
therefore it is effective to
just carry it along, because

00:34:29.540 --> 00:34:32.219
we will have to later on
store some non-zero

00:34:32.219 --> 00:34:34.639
information in it.

00:34:34.639 --> 00:34:40.510
Notice that this is the total
array, and we have altogether,

00:34:40.510 --> 00:34:46.449
in this particular case, 21
entries here, in addition to

00:34:46.449 --> 00:34:49.750
storing the stiffness matrix in
this one-dimensional array.

00:34:49.750 --> 00:34:55.670
However, we also have to have
an identification array that

00:34:55.670 --> 00:35:00.270
tells us which elements in this
one-dimensional array are

00:35:00.270 --> 00:35:02.160
diagonal elements.

00:35:02.160 --> 00:35:04.710
Of course, here from this
picture, we see immediately

00:35:04.710 --> 00:35:07.200
that these are the diagonal
elements of

00:35:07.200 --> 00:35:09.250
the stiffness matrix.

00:35:09.250 --> 00:35:13.210
However, imagine that we
simply store A as a

00:35:13.210 --> 00:35:15.650
one-dimensional array
[? alone, ?]

00:35:15.650 --> 00:35:19.310
then we would have to know that
a2 corresponds to the

00:35:19.310 --> 00:35:23.080
second diagonal element, a6
corresponds to the fourth

00:35:23.080 --> 00:35:24.800
diagonal element, and so on.

00:35:24.800 --> 00:35:27.620
And that is done by
as a MAXA array.

00:35:27.620 --> 00:35:30.460
You see, MAXA here stores
the addresses of

00:35:30.460 --> 00:35:32.420
the diagonal elements.

00:35:32.420 --> 00:35:38.980
Having MAXA, the array MAXA, and
having the one-dimensional

00:35:38.980 --> 00:35:41.600
array that contains all the
elements of the stiffness

00:35:41.600 --> 00:35:47.360
matrix strung out in one
dimension, we can access any

00:35:47.360 --> 00:35:51.090
element in here during
the solution of the

00:35:51.090 --> 00:35:52.730
equation as is required.

00:35:57.570 --> 00:35:59.100
Let me mention one
more point--

00:35:59.100 --> 00:36:04.297
that the length of this array
here is not equal to n, but

00:36:04.297 --> 00:36:09.820
it's n plus 1, because this last
element here gives us a

00:36:09.820 --> 00:36:14.070
diagonal element that would
occur out here.

00:36:14.070 --> 00:36:18.450
So 22 really is this diagonal
element, which we really don't

00:36:18.450 --> 00:36:19.210
have, of course.

00:36:19.210 --> 00:36:22.550
But when we subtract 1 from it,
we get this element here,

00:36:22.550 --> 00:36:26.170
or the address of this element
here, and then we know how

00:36:26.170 --> 00:36:27.320
long this column is.

00:36:27.320 --> 00:36:29.170
We have to know how long
this column is.

00:36:29.170 --> 00:36:33.130
And for that reason, we need
this last entry here.

00:36:33.130 --> 00:36:36.570
In practice, of course, what
we might find is that we

00:36:36.570 --> 00:36:39.700
cannot store this total
matrix in [? core, ?]

00:36:39.700 --> 00:36:40.980
because it's just too big.

00:36:40.980 --> 00:36:45.970
There are just too many elements
in the matrix.

00:36:45.970 --> 00:36:49.680
If we talk about a 5,000 degree
of freedom model with a

00:36:49.680 --> 00:36:54.490
bandwidth of 1,000, then we
have 5 million elements in

00:36:54.490 --> 00:36:55.290
that matrix.

00:36:55.290 --> 00:37:00.730
And even on the very large-scale
computers now, you

00:37:00.730 --> 00:37:04.420
have to somehow block that
information in order to be

00:37:04.420 --> 00:37:06.260
able to deal with it.

00:37:06.260 --> 00:37:08.430
And that we do in the
following way.

00:37:08.430 --> 00:37:10.850
If a certain amount of
high-speed storage is

00:37:10.850 --> 00:37:16.010
available, then based on that
high-speed storage available,

00:37:16.010 --> 00:37:19.590
we simply block the total
stiffness matrix.

00:37:19.590 --> 00:37:20.810
Once again, shown here.

00:37:20.810 --> 00:37:23.700
Here is the skyline, or the
column heights are given by

00:37:23.700 --> 00:37:24.710
that skyline.

00:37:24.710 --> 00:37:26.340
We block it as shown here.

00:37:26.340 --> 00:37:30.300
This is here block 1, this is
here block 2, this is here

00:37:30.300 --> 00:37:32.420
block 3, and that is block 4.

00:37:32.420 --> 00:37:35.710
In fact we will see, later on,
when we talk about the

00:37:35.710 --> 00:37:42.300
solution of equations, it is
necessary that we can keep two

00:37:42.300 --> 00:37:44.910
blocks at a time in the
high-speed storage.

00:37:44.910 --> 00:37:47.810
In other words, if we have a
total high-speed storage of

00:37:47.810 --> 00:37:52.420
40,000 elements, then 20,000
elements would be this, and

00:37:52.420 --> 00:37:54.660
20,000 elements would be this.

00:37:54.660 --> 00:37:57.100
Or in practice, of course, these
might be slightly less

00:37:57.100 --> 00:37:58.780
than 20,000, and these
might also be

00:37:58.780 --> 00:38:00.780
slightly less than 20,000.

00:38:00.780 --> 00:38:04.420
But we have to be able to keep
two blocks in core, and that

00:38:04.420 --> 00:38:08.130
is our criteria to determine
the block size.

00:38:08.130 --> 00:38:10.970
Of course, the computer program,
once again, does all

00:38:10.970 --> 00:38:12.040
that automatically.

00:38:12.040 --> 00:38:14.900
It just knows how much storage
there is available, because

00:38:14.900 --> 00:38:19.460
you have a specified amount of
storage that is available, and

00:38:19.460 --> 00:38:22.780
then it allocates the
appropriate amount for each

00:38:22.780 --> 00:38:27.030
block and calculates the block
size, the column heights in

00:38:27.030 --> 00:38:28.340
each block, and so on.

00:38:31.300 --> 00:38:35.200
Once again, I'm showing here
zero elements in a column.

00:38:35.200 --> 00:38:41.080
When we actually decompose the
matrix as we do in Gauss

00:38:41.080 --> 00:38:45.370
elimination into an LDA
transport form--

00:38:45.370 --> 00:38:47.040
I will be discussing
that later--

00:38:47.040 --> 00:38:51.180
we fill up these zero elements
in general, and that is the

00:38:51.180 --> 00:38:55.000
reason why we carry them along
in the solution phase.

00:38:55.000 --> 00:39:00.690
Let me make a few remarks on the
bandwidth, the use of an

00:39:00.690 --> 00:39:02.280
effective bandwidth.

00:39:02.280 --> 00:39:05.950
Here we have a finite element
model of a cantilever, a plane

00:39:05.950 --> 00:39:08.480
stress finite element model
of a cantilever.

00:39:08.480 --> 00:39:12.640
At each node, we have two
degrees of freedom, just as in

00:39:12.640 --> 00:39:15.420
this earlier model that
we considered.

00:39:15.420 --> 00:39:18.090
Notice these are now 8-node
elements, isoparametric

00:39:18.090 --> 00:39:21.300
elements that I will be
discussing later.

00:39:21.300 --> 00:39:24.220
We have constraint, of course,
at this end, all degrees of

00:39:24.220 --> 00:39:28.600
freedom, because the cantilever
is 6 there.

00:39:28.600 --> 00:39:33.450
In this particular layout,
notice we have used the

00:39:33.450 --> 00:39:36.240
following element or nodal
point numbering.

00:39:36.240 --> 00:39:41.010
1, 2, 3, 4, 5, 6 up to 13,
then from 14 to 20,

00:39:41.010 --> 00:39:44.930
then from 21 to 33.

00:39:44.930 --> 00:39:52.600
Well, this then means that
our bandwidth here, or

00:39:52.600 --> 00:39:57.810
half-bandwidth, I should rather
say, and now let's

00:39:57.810 --> 00:39:59.540
simply include the diagonal.

00:39:59.540 --> 00:40:00.780
It doesn't make much
difference.

00:40:00.780 --> 00:40:04.400
We are talking, in practical
analysis, about a bandwidth,

00:40:04.400 --> 00:40:06.660
or half bandwidth, of 300.

00:40:06.660 --> 00:40:11.160
So having 300 or 301, really, in
a practical analysis, makes

00:40:11.160 --> 00:40:13.310
very little difference.

00:40:13.310 --> 00:40:17.360
Our half bandwidth, including
the diagonal element here,

00:40:17.360 --> 00:40:19.090
would be 46.

00:40:19.090 --> 00:40:20.540
How would we obtain that?

00:40:20.540 --> 00:40:25.240
Well, if we look at the coupling
between nodal points

00:40:25.240 --> 00:40:29.030
that is due to the element
stiffnesses, we recognize that

00:40:29.030 --> 00:40:33.420
for a typical element, let's
look at this element, we have

00:40:33.420 --> 00:40:38.210
a maximum nodal 25 here, a
minimum nodal point 3.

00:40:38.210 --> 00:40:45.900
Now, 25 minus 3 is
equal to 22.

00:40:45.900 --> 00:40:51.940
However, we now have to add 1 on
because all of the diagonal

00:40:51.940 --> 00:40:55.210
part, and that together,
then, gives 23.

00:40:57.750 --> 00:41:02.970
This 1 I'm adding on because
of the diagonal element--

00:41:02.970 --> 00:41:06.880
and if you where to look at the
stiffness matrix in its

00:41:06.880 --> 00:41:09.730
assembled form-- of this element
in its assembled form,

00:41:09.730 --> 00:41:13.280
you would see that this part
here is to be added on,

00:41:13.280 --> 00:41:17.390
because you had also the
diagonal contribution.

00:41:17.390 --> 00:41:22.600
So the maximum difference
between the nodal points plus

00:41:22.600 --> 00:41:24.500
1 gives us 23.

00:41:24.500 --> 00:41:30.930
Now, that 23 is a maximum if 1
degree of freedom were at 1

00:41:30.930 --> 00:41:31.750
nodal point.

00:41:31.750 --> 00:41:36.130
However, we take that 23 and we
have to multiply it by 2,

00:41:36.130 --> 00:41:39.230
because we have 2 degrees of
freedom per nodal point, and

00:41:39.230 --> 00:41:41.740
that then gives us 46.

00:41:41.740 --> 00:41:47.730
So the half bandwidth, including
the diagonal, is 46.

00:41:47.730 --> 00:41:50.910
Well, that is a very
large bandwidth, in

00:41:50.910 --> 00:41:52.650
this particular case.

00:41:52.650 --> 00:41:56.610
And let us now try to rearrange
the nodal point

00:41:56.610 --> 00:41:58.850
numbering to come up with
a smaller bandwidth.

00:41:58.850 --> 00:42:00.710
And the better nodal
point numbering

00:42:00.710 --> 00:42:04.820
here is shown in layout.

00:42:04.820 --> 00:42:10.230
1, 2, 3, 4, 5, 6, 7, 8, and
so on, down this way.

00:42:10.230 --> 00:42:13.430
If we now look at the same
element again, the maximum

00:42:13.430 --> 00:42:17.480
difference in nodal
points is 7.

00:42:17.480 --> 00:42:21.150
We add 1 again to get 8, and we
have 2 degrees of freedom

00:42:21.150 --> 00:42:22.240
per nodal point.

00:42:22.240 --> 00:42:26.590
That gives us a half
bandwidth of 16.

00:42:26.590 --> 00:42:30.240
And therefore, we have reduced
the bandwidth by almost a

00:42:30.240 --> 00:42:32.180
factor of 3.

00:42:32.180 --> 00:42:37.340
Now this means that the solution
effort will go down,

00:42:37.340 --> 00:42:40.190
in the equation solution phase,
will go down by a

00:42:40.190 --> 00:42:41.570
factor of 9.

00:42:41.570 --> 00:42:44.270
Because he would see that
our solution effort is

00:42:44.270 --> 00:42:48.820
proportional to the half
bandwidth squared.

00:42:48.820 --> 00:42:53.060
So if there's a factor of 3
here, the solution will

00:42:53.060 --> 00:42:57.040
actually be reduced
by a factor of 9.

00:42:57.040 --> 00:43:00.210
Therefore, it is very important
to use minimum

00:43:00.210 --> 00:43:05.020
bandwidth in the finite element
mesh, or rather number

00:43:05.020 --> 00:43:07.720
the nodal point in such
a way as to obtain a

00:43:07.720 --> 00:43:10.830
minimum half bandwidth.

00:43:10.830 --> 00:43:13.860
If we actually deal with column
solvers, we will see

00:43:13.860 --> 00:43:17.820
that in some cases we quite
don't want to have the minimum

00:43:17.820 --> 00:43:21.090
bandwidth because we have a
column solver, about but these

00:43:21.090 --> 00:43:26.790
are details that we will be
addressing in a little bit.

00:43:26.790 --> 00:43:30.410
In general, we want to have
really a minimum bandwidth.

00:43:30.410 --> 00:43:38.710
Let us look now at the overall
solution phase once more.

00:43:38.710 --> 00:43:42.170
This is a solution phase in
the computer program STAP,

00:43:42.170 --> 00:43:48.140
which is in the textbook that
you are using in this course.

00:43:48.140 --> 00:43:51.330
You might look at the
description of this computer

00:43:51.330 --> 00:43:55.940
program in more detail, but the
overall solution set is as

00:43:55.940 --> 00:43:57.100
shown here.

00:43:57.100 --> 00:44:01.700
We start the program, and we
have to read a nodal point

00:44:01.700 --> 00:44:04.940
data, which involves
coordinates, boundary

00:44:04.940 --> 00:44:07.340
conditions, and we established
the equation

00:44:07.340 --> 00:44:10.350
numbers in an ID array.

00:44:10.350 --> 00:44:12.190
I'll discuss that with you.

00:44:12.190 --> 00:44:16.610
We then would calculate and
store load vectors for our

00:44:16.610 --> 00:44:17.810
load cases.

00:44:17.810 --> 00:44:19.880
We write these on tape.

00:44:19.880 --> 00:44:24.040
If we have a typical analysis,
three, four load cases, we

00:44:24.040 --> 00:44:26.860
calculate all of these
load vectors and

00:44:26.860 --> 00:44:29.120
store them on tape.

00:44:29.120 --> 00:44:35.420
Then we continue to read,
generate, and store element

00:44:35.420 --> 00:44:40.530
data the way I've been
discussing this with you, and

00:44:40.530 --> 00:44:45.070
in the actual analysis, we
loop over element groups.

00:44:45.070 --> 00:44:48.610
By that I mean that the total
elements are subdivided into

00:44:48.610 --> 00:44:50.300
element groups.

00:44:50.300 --> 00:44:53.110
This is an effective concept
because in an actual

00:44:53.110 --> 00:44:55.860
structural analysis, we deal
with plane stress elements,

00:44:55.860 --> 00:44:58.960
beam elements, truss elements,
three-dimensional shell

00:44:58.960 --> 00:45:00.340
elements, and so on.

00:45:00.340 --> 00:45:04.320
And it is effective to just
group all of these elements

00:45:04.320 --> 00:45:09.470
together into specific groups.

00:45:09.470 --> 00:45:12.380
In other words, put the shell
elements together in one

00:45:12.380 --> 00:45:14.720
group, the beam elements
together in another

00:45:14.720 --> 00:45:16.350
group, and so on.

00:45:16.350 --> 00:45:20.140
In fact, this is a very
effective way of proceeding

00:45:20.140 --> 00:45:22.460
also in non-linear
analysis, in a

00:45:22.460 --> 00:45:24.120
more complicated analysis.

00:45:24.120 --> 00:45:26.720
If you're familiar a little
bit with ADINA, what we do

00:45:26.720 --> 00:45:30.440
there is that we are grouping
elements not just together

00:45:30.440 --> 00:45:34.310
according to the kinds of
kinematics that they're

00:45:34.310 --> 00:45:37.990
representing, but also the
material models they are

00:45:37.990 --> 00:45:42.970
containing, the kind of
descriptions we want to use

00:45:42.970 --> 00:45:46.230
for non-linearities,
et cetera.

00:45:46.230 --> 00:45:51.580
Well, having then generated and
stored the element data,

00:45:51.580 --> 00:45:55.380
we can read it and calculate
the element stiffness

00:45:55.380 --> 00:45:58.790
matrices, and assemble these
in a global structural

00:45:58.790 --> 00:45:59.830
stiffness matrix.

00:45:59.830 --> 00:46:03.760
Here we loop over all element
groups once again.

00:46:03.760 --> 00:46:08.910
And this means generally we are
storing this element data

00:46:08.910 --> 00:46:12.790
on tape, and then we are reading
it and going over all

00:46:12.790 --> 00:46:15.250
of the element group data,
as shown here.

00:46:15.250 --> 00:46:20.030
Then next we can factorize
the stiffness matrix.

00:46:20.030 --> 00:46:23.380
This is a basic step in the
Gauss elimination procedure,

00:46:23.380 --> 00:46:25.880
as I will be discussing
with you later.

00:46:25.880 --> 00:46:32.670
And now we loop over the load
vectors for each load case,

00:46:32.670 --> 00:46:35.370
read the load vector, and
calculate the nodal point

00:46:35.370 --> 00:46:36.660
displacement.

00:46:36.660 --> 00:46:40.240
We then read the element
group data and

00:46:40.240 --> 00:46:41.620
calculate the element stresses.

00:46:41.620 --> 00:46:44.440
Print out the element stresses,
and if there is

00:46:44.440 --> 00:46:46.990
another load case to be
considered, we go back from

00:46:46.990 --> 00:46:47.990
here into there.

00:46:47.990 --> 00:46:51.150
So the LDA transport
factorization of the stiffness

00:46:51.150 --> 00:46:55.310
matrix which was outside this
loop is only done once.

00:46:55.310 --> 00:46:58.110
A forward reduction and back
substitution of the load

00:46:58.110 --> 00:47:02.220
vector is done for each load
case, as shown here.

00:47:02.220 --> 00:47:08.260
I will be discussing those
aspects in more detail later.

00:47:08.260 --> 00:47:12.190
Let us now look at some typical
effective elements.

00:47:12.190 --> 00:47:18.290
We have been discussing so far
some simple elements, just to

00:47:18.290 --> 00:47:24.620
expose you to the basic concepts
that are being used.

00:47:24.620 --> 00:47:27.070
And for that reason, we
discussed some very simple

00:47:27.070 --> 00:47:28.620
elements in the earlier
lectures.

00:47:28.620 --> 00:47:31.020
What I want to do now in the
next lectures is to discuss

00:47:31.020 --> 00:47:35.390
this you modern, effective
isoparametric elements.

00:47:35.390 --> 00:47:39.910
These are also the elements that
we are using in the ADINA

00:47:39.910 --> 00:47:40.990
computer program.

00:47:40.990 --> 00:47:45.930
Here we have a one-dimensional
truss element which can be

00:47:45.930 --> 00:47:47.860
used as a cable element.

00:47:47.860 --> 00:47:50.850
As a simplest element, it would
be 2-noded element.

00:47:50.850 --> 00:47:55.210
We would only assign this
node and that node.

00:47:55.210 --> 00:47:58.030
And then it would be, of course,
a simple 2-noded

00:47:58.030 --> 00:48:03.990
truss, a very common element,
2-node truss.

00:48:03.990 --> 00:48:09.530
However, as shown here, we can
also have a third note, which

00:48:09.530 --> 00:48:12.350
is this one.

00:48:12.350 --> 00:48:13.880
And we can have a fourth note.

00:48:13.880 --> 00:48:17.650
In other words, what we will be
dealing with, really, are

00:48:17.650 --> 00:48:21.250
variable number node elements,
which have two nodes, three

00:48:21.250 --> 00:48:27.370
nodes, or four nodes for the
one-dimensional truss element.

00:48:27.370 --> 00:48:31.610
A ring element is obtained from
the truss element in this

00:48:31.610 --> 00:48:32.430
very simple way.

00:48:32.430 --> 00:48:34.880
It's really an axis-symmetric
truss, you might call it an

00:48:34.880 --> 00:48:37.380
axis-symmetric truss, with only
one degree of freedom.

00:48:37.380 --> 00:48:41.140
It has only stiffness in its
circumferential direction.

00:48:41.140 --> 00:48:44.090
So this is a truss element.

00:48:44.090 --> 00:48:46.930
And the basic concept that we
are using is that we can have

00:48:46.930 --> 00:48:49.730
a variable number of nodes.

00:48:49.730 --> 00:48:53.920
Similarly for this element, this
is a plane stress, plane

00:48:53.920 --> 00:48:56.130
strain, or axis-symmetric
element.

00:48:56.130 --> 00:48:58.110
Notice that the only
displacement that we are

00:48:58.110 --> 00:49:00.780
talking about in this particular
case are two

00:49:00.780 --> 00:49:06.570
displacements, u and v, or in
ADINA, we call this the V and

00:49:06.570 --> 00:49:08.610
W degree of freedom,
corresponding

00:49:08.610 --> 00:49:10.320
to the y- and z-axis.

00:49:10.320 --> 00:49:12.740
The z-axis is, in an
axis-symmetric case, the axis

00:49:12.740 --> 00:49:14.320
of revolution.

00:49:14.320 --> 00:49:19.420
And with this degree of freedom,
the kinematics of the

00:49:19.420 --> 00:49:23.500
element are defined when
we talk about a

00:49:23.500 --> 00:49:25.780
specific number of nodes.

00:49:25.780 --> 00:49:28.520
And then the element can be used
for plane stress, plane

00:49:28.520 --> 00:49:31.990
strain, and axis-symmetric
analysis, depending on which

00:49:31.990 --> 00:49:36.040
stress-strain law you're
using, and which strain

00:49:36.040 --> 00:49:38.070
components and stress
components

00:49:38.070 --> 00:49:39.940
you're dealing with.

00:49:39.940 --> 00:49:44.280
Here, too, we can use the
element simply with 4 nodes,

00:49:44.280 --> 00:49:48.140
so we would have this
4-noded element.

00:49:48.140 --> 00:49:53.250
We can also add another note,
make it a 5-noded element.

00:49:53.250 --> 00:49:56.170
We can add this node, we have
a 6-noded element, now a

00:49:56.170 --> 00:49:59.330
7-noded element, and finally
an 8-noded element.

00:49:59.330 --> 00:50:02.530
The variable number node concept
is a very effective

00:50:02.530 --> 00:50:06.150
way of formulating elements,
because the same basic

00:50:06.150 --> 00:50:09.680
sub-protein basic element can
be used for all sorts of

00:50:09.680 --> 00:50:11.420
different applications.

00:50:11.420 --> 00:50:16.340
The same holds for
three-dimensional analysis.

00:50:16.340 --> 00:50:21.080
There's also a bit of a number
node 3-dimensional element

00:50:21.080 --> 00:50:26.820
where we have a basic number of
nodes being 8, and then we

00:50:26.820 --> 00:50:29.950
would have this brick
element here--

00:50:29.950 --> 00:50:33.910
let me just quickly
sketch it out.

00:50:33.910 --> 00:50:35.710
This is the basic
brick element.

00:50:35.710 --> 00:50:41.690
And now we can simply add
additional nodes in to obtain

00:50:41.690 --> 00:50:43.390
higher-order elements.

00:50:43.390 --> 00:50:49.050
And the 21-noded element here
is a very effective element

00:50:49.050 --> 00:50:52.110
for general three-dimensional
analysis.

00:50:52.110 --> 00:50:55.100
However, in some other
applications, even the 8-noded

00:50:55.100 --> 00:50:59.530
element is quite effective,
effectiveness, of course,

00:50:59.530 --> 00:51:03.310
being always measured by the
computational effort involved

00:51:03.310 --> 00:51:07.360
in dealing with such an element,
and the accuracy that

00:51:07.360 --> 00:51:11.110
the element can give us
in actual analysis.

00:51:11.110 --> 00:51:15.880
So this being one element,
again, that can contain from 8

00:51:15.880 --> 00:51:19.270
up to 21 notes, being a variable
number node element,

00:51:19.270 --> 00:51:22.530
and being very effectively
formulated using the

00:51:22.530 --> 00:51:24.300
isoparametric concept
that I will be

00:51:24.300 --> 00:51:25.880
discussing in the next lecture.

00:51:25.880 --> 00:51:28.880
Notice that in that concept,
we can have curved element

00:51:28.880 --> 00:51:33.660
sides, as shown here, for the
higher order elements.

00:51:33.660 --> 00:51:39.090
Finally there is, of course,
our beam element.

00:51:39.090 --> 00:51:43.160
The beam element, which I'm sure
you are quite familiar

00:51:43.160 --> 00:51:48.720
with, a simple 2-noded element
which might not be referred to

00:51:48.720 --> 00:51:54.250
as a finite element, but on the
other side, we might also

00:51:54.250 --> 00:51:55.800
call it a finite element.

00:51:55.800 --> 00:51:59.720
Originally, it was not called
a finite element, but now if

00:51:59.720 --> 00:52:02.290
we look at the basic
interpolation procedures that

00:52:02.290 --> 00:52:05.230
we are employing, we may
very well refer to

00:52:05.230 --> 00:52:07.880
it at a finite element.

00:52:07.880 --> 00:52:12.210
Then the shell element that
I also will be discussing.

00:52:12.210 --> 00:52:18.530
Here we have a basic shell
element that is shown here,

00:52:18.530 --> 00:52:21.430
having 16 nodes.

00:52:21.430 --> 00:52:25.620
At each nodal point, we have
now 5 degrees of freedom.

00:52:25.620 --> 00:52:30.360
The 5 degrees of freedom being 3
translations, as shown here.

00:52:30.360 --> 00:52:37.700
And in addition, 2 rotations,
these being the 2 rotations.

00:52:37.700 --> 00:52:42.940
The 16-node element is the
highest order element that I

00:52:42.940 --> 00:52:44.680
can recommend for practical
analysis.

00:52:44.680 --> 00:52:47.840
It's a quite expensive element,
but very accurate,

00:52:47.840 --> 00:52:52.160
because it admits curvature
into all directions.

00:52:52.160 --> 00:52:56.510
So for curvatures, it can be a
very effective element to use.

00:52:56.510 --> 00:53:00.530
Notice that at each node, we
have 5 degrees of freedom

00:53:00.530 --> 00:53:05.980
where these translations are
defined in the xyz global

00:53:05.980 --> 00:53:11.000
coordinate system, whereas the
rotations are not necessarily

00:53:11.000 --> 00:53:13.190
aligned with the
x- and y-axes.

00:53:13.190 --> 00:53:16.740
I will be discussing that
later on in detail.

00:53:16.740 --> 00:53:21.170
But then with 16 notes and 5
degrees of freedom, we are

00:53:21.170 --> 00:53:24.390
talking about 80 degrees of
freedom altogether, a very

00:53:24.390 --> 00:53:27.280
considerable number for
a single element.

00:53:27.280 --> 00:53:30.170
In practice, therefore, we
want to possibly use less

00:53:30.170 --> 00:53:34.450
nodes on the element, and an
effective element that

00:53:34.450 --> 00:53:36.150
directly is obtained
from this one is

00:53:36.150 --> 00:53:40.090
simply the 9-noded element.

00:53:40.090 --> 00:53:41.650
I will be discussing
that element.

00:53:41.650 --> 00:53:47.550
And of course, this element and
other elements from this

00:53:47.550 --> 00:53:51.260
one are directly obtained by
simply assigning certain nodes

00:53:51.260 --> 00:53:52.700
to the element.

00:53:52.700 --> 00:53:56.640
We use here again the variable
number node concept as we use

00:53:56.640 --> 00:53:59.530
it for the truss element, the
2-dimensional, and the

00:53:59.530 --> 00:54:01.410
3-dimensional element.

00:54:01.410 --> 00:54:04.660
Another important feature that I
like to also just mention to

00:54:04.660 --> 00:54:08.790
you is the fact that this
element can be used as a

00:54:08.790 --> 00:54:10.220
transition element.

00:54:10.220 --> 00:54:14.870
You might have a shell here,
and you might have a solid

00:54:14.870 --> 00:54:19.530
here to be idealized, and
there's a transition region.

00:54:19.530 --> 00:54:23.490
The solid element here would
have, in general, 3 degrees of

00:54:23.490 --> 00:54:24.820
freedom at a node.

00:54:24.820 --> 00:54:28.490
The shell element here has 5
degrees of freedom at this

00:54:28.490 --> 00:54:32.530
node, 5 degrees of freedom at
this node, and here we have a

00:54:32.530 --> 00:54:36.800
transition element that has
shell degrees of freedom at

00:54:36.800 --> 00:54:40.740
these nodes, and solid degrees
of freedom at these top and

00:54:40.740 --> 00:54:42.430
bottom nodes.

00:54:42.430 --> 00:54:46.770
Here altogether at this line, 6
degrees of freedom, 3 here,

00:54:46.770 --> 00:54:50.130
3 there, whereas at this line,
5 degrees of freedom.

00:54:50.130 --> 00:54:54.510
So this is an effective way of
modeling a transition region

00:54:54.510 --> 00:54:59.940
between a shell and a solid
in a compatible way.

00:54:59.940 --> 00:55:05.810
In other words, preserving full
compatibility between the

00:55:05.810 --> 00:55:09.140
elements, and not using any
constraint equations.

00:55:09.140 --> 00:55:12.342
I will be also talking further
about this element later.

00:55:15.050 --> 00:55:18.370
In this lecture, then, what I
wanted to discuss with you

00:55:18.370 --> 00:55:22.345
were some basic concepts
regarding the formulation of

00:55:22.345 --> 00:55:27.770
the finite element methods, in
particular regarding the

00:55:27.770 --> 00:55:29.860
implementation of the finite
element method.

00:55:29.860 --> 00:55:33.260
In other words, how do we
actually implement what we

00:55:33.260 --> 00:55:36.760
formulated in the earlier
lectures?

00:55:36.760 --> 00:55:41.170
Some of these concepts are very
important concepts when

00:55:41.170 --> 00:55:44.410
it comes to actual practical
implementation of the finite

00:55:44.410 --> 00:55:47.270
element method, particularly
the one that I discussed

00:55:47.270 --> 00:55:50.020
regarding the connectivity
arrays that are

00:55:50.020 --> 00:55:52.720
formulated, and so on.

00:55:52.720 --> 00:55:54.050
This is all I wanted to say.

00:55:54.050 --> 00:55:55.300
Thank you for your attention.