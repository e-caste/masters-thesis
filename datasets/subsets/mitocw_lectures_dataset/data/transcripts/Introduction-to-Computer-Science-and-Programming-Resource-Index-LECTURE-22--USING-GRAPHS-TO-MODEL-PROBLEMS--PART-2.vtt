WEBVTT

00:00:00.040 --> 00:00:02.490
The following content is
provided under a Creative

00:00:02.490 --> 00:00:03.900
Commons license.

00:00:03.900 --> 00:00:06.940
Your support will help MIT
OpenCourseWare continue to

00:00:06.940 --> 00:00:10.580
offer high quality educational
resources for free.

00:00:10.580 --> 00:00:13.490
To make a donation or view
additional materials from

00:00:13.490 --> 00:00:19.320
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:19.320 --> 00:00:21.200
ocw.mit.edu.

00:00:21.200 --> 00:00:27.010
PROFESSOR: OK so we're
going to test it.

00:00:27.010 --> 00:00:28.930
Here's testOne.

00:00:28.930 --> 00:00:32.360
It just says for name and range
10, I'm going to build

00:00:32.360 --> 00:00:35.560
some nodes, put in a few edges,
and then I'm going to

00:00:35.560 --> 00:00:37.160
print the graph.

00:00:37.160 --> 00:00:41.940
And all I really want to show
you here, is that if we run it

00:00:41.940 --> 00:00:44.665
for digraph or we run
it for graph, we'll

00:00:44.665 --> 00:00:45.915
get something different.

00:00:48.560 --> 00:00:52.550
Yes, I'm happy to
save the source.

00:00:52.550 --> 00:00:59.733
Oh, and now the syntax.

00:01:03.200 --> 00:01:05.450
It was valid last time I looked,
what have we done

00:01:05.450 --> 00:01:08.450
wrong here?

00:01:08.450 --> 00:01:10.900
I edit something badly?

00:01:10.900 --> 00:01:14.350
Sort of looks valid
to me, doesn't it?

00:01:14.350 --> 00:01:15.600
We'll retype it.

00:01:18.900 --> 00:01:21.520
Yes, we'll save.

00:01:21.520 --> 00:01:22.960
Nope.

00:01:22.960 --> 00:01:26.450
Well, it's one of those
days, isn't it?

00:01:26.450 --> 00:01:30.950
All right this is a good
debugging exercise for us.

00:01:30.950 --> 00:01:32.875
Let's think about how
we go and find this.

00:01:32.875 --> 00:01:35.710
I'm sure you've all had
this sort of problem.

00:01:35.710 --> 00:01:38.690
Well the first thing to do is I
think I'll just comment out

00:01:38.690 --> 00:01:39.940
all of this.

00:01:46.270 --> 00:01:47.520
Let's see if I still
get an error.

00:01:52.130 --> 00:01:52.640
I do.

00:01:52.640 --> 00:01:55.420
All right, well that suggests
that, that wasn't the problem,

00:01:55.420 --> 00:01:56.700
so I can put it back.

00:01:59.590 --> 00:02:01.855
Now it shows a problem all
the way down there.

00:02:05.280 --> 00:02:07.870
So let's see what's
going on here.

00:02:07.870 --> 00:02:11.300
Or maybe, I'll just skip this,
but doubtless I'll get in

00:02:11.300 --> 00:02:12.550
trouble if I do.

00:02:18.448 --> 00:02:22.440
So let's see.

00:02:22.440 --> 00:02:25.560
I must have just made a sloppy
editing error somewhere this

00:02:25.560 --> 00:02:28.280
morning in commenting things
out for the lecture.

00:02:36.710 --> 00:02:42.180
Well, I think what we're going
to do, for the moment, is move

00:02:42.180 --> 00:02:45.260
on and hope it goes away.

00:02:45.260 --> 00:02:46.940
Now that seems silly.

00:02:46.940 --> 00:02:50.450
Sorry about this everybody.

00:02:50.450 --> 00:02:53.470
People should look with me, and
someone may see it more

00:02:53.470 --> 00:02:55.432
quickly than I can.

00:02:55.432 --> 00:02:57.630
In fact, I'm hoping someone
sees it more

00:02:57.630 --> 00:02:58.880
quickly than I can.

00:03:27.580 --> 00:03:30.761
We've now got a microphone,
and the embarrassment of a

00:03:30.761 --> 00:03:32.870
code with syntax error,
[UNINTELLIGIBLE].

00:03:32.870 --> 00:03:34.130
MALE SPEAKER: You've
got a sign.

00:03:34.130 --> 00:03:36.870
For some reason it wasn't
on the schedule, so--

00:03:36.870 --> 00:03:38.140
PROFESSOR: Well just
because we've been

00:03:38.140 --> 00:03:39.790
teaching at 10 o'clock.

00:03:39.790 --> 00:03:40.203
MALE SPEAKER: Yeah, I know.

00:03:40.203 --> 00:03:41.400
Yeah.

00:03:41.400 --> 00:03:42.160
[UNINTELLIGIBLE].

00:03:42.160 --> 00:03:42.620
PROFESSOR: February.

00:03:42.620 --> 00:03:44.780
There's no reason to suspect
that we would teach at 10

00:03:44.780 --> 00:03:45.430
o'clock today.

00:03:45.430 --> 00:03:45.906
MALE SPEAKER: I actually
looked.

00:03:45.906 --> 00:03:47.156
I double checked.

00:03:53.050 --> 00:03:54.830
PROFESSOR: Well this is
embarrassing, folks.

00:03:54.830 --> 00:03:56.980
And I wish one of you would
bail me out by telling me

00:03:56.980 --> 00:03:58.345
where my syntax error is.

00:04:06.900 --> 00:04:09.250
Well random looks OK, right?

00:04:09.250 --> 00:04:10.500
Node looks OK.

00:04:19.230 --> 00:04:22.095
And it gets more complicated.

00:04:22.095 --> 00:04:23.275
MALE SPEAKER: Hey professor,
can you turn on the

00:04:23.275 --> 00:04:24.310
transmitter?

00:04:24.310 --> 00:04:25.173
PROFESSOR: No.

00:04:25.173 --> 00:04:25.880
[LAUGHTER]

00:04:25.880 --> 00:04:27.130
PROFESSOR: OK, I'll turn
on the transmitter.

00:04:29.760 --> 00:04:33.150
But I'm really focused on a
different problem right now.

00:04:40.940 --> 00:04:42.190
Guys help!

00:04:44.120 --> 00:04:45.370
Where are my TAs?

00:04:53.510 --> 00:04:55.620
Why does it keep doing
that to me?

00:04:55.620 --> 00:05:00.020
Maybe there's something just
funny going on here.

00:05:00.020 --> 00:05:00.420
Pardon?

00:05:00.420 --> 00:05:02.560
AUDIENCE: Restart IDLE.

00:05:02.560 --> 00:05:03.300
PROFESSOR: Restarting IDLE?

00:05:03.300 --> 00:05:06.320
You think maybe that's
the issue?

00:05:06.320 --> 00:05:07.570
We could try that.

00:05:32.920 --> 00:05:33.950
Ha!

00:05:33.950 --> 00:05:38.930
So it looks like IDLE was
just in some ugly state.

00:05:38.930 --> 00:05:40.180
Let's hope.

00:05:56.880 --> 00:05:59.720
Yes, all right, so I
didn't have a bug.

00:05:59.720 --> 00:06:01.900
It was just IDLE had a bug.

00:06:01.900 --> 00:06:03.340
All right, phew.

00:06:03.340 --> 00:06:05.170
But we did squander
ten minutes.

00:06:05.170 --> 00:06:06.200
Oh well.

00:06:06.200 --> 00:06:09.050
So we have the graph, and you
can see when we look at a

00:06:09.050 --> 00:06:12.400
graph, we have a node from 1
to 2, an edge from 1 to 2,

00:06:12.400 --> 00:06:15.030
from 1 to 1, et cetera.

00:06:15.030 --> 00:06:16.890
And that's the digraph.

00:06:16.890 --> 00:06:20.600
When we look at the graph, we'll
see that in fact we have

00:06:20.600 --> 00:06:23.110
a lot more nodes, because
everything goes in both

00:06:23.110 --> 00:06:25.110
directions.

00:06:25.110 --> 00:06:27.900
But that's what we expected--

00:06:27.900 --> 00:06:29.320
nothing very interesting.

00:06:29.320 --> 00:06:32.760
All I want you to do is notice
the difference here between

00:06:32.760 --> 00:06:35.730
graphs and digraphs.

00:06:35.730 --> 00:06:42.450
Now getting to the whole point,
once we have this

00:06:42.450 --> 00:06:46.230
mechanism set up to think about
graphs, we can now think

00:06:46.230 --> 00:06:49.010
about interesting problems
and formulate

00:06:49.010 --> 00:06:50.420
them as graph problems.

00:06:50.420 --> 00:06:53.320
And I want to list a few of the
interesting problems, and

00:06:53.320 --> 00:06:56.480
then we'll look at how to
solve some of them.

00:06:56.480 --> 00:06:59.820
So probably the most common
graph problem that people

00:06:59.820 --> 00:07:01.920
solve, is called the shortest
path problem.

00:07:05.640 --> 00:07:08.590
We talked about this
briefly last time.

00:07:08.590 --> 00:07:14.210
The notion here is for some pair
of nodes, n1 and n2, we

00:07:14.210 --> 00:07:18.040
want to find the shortest
sequence of edges that

00:07:18.040 --> 00:07:19.390
connects those two nodes.

00:07:22.160 --> 00:07:22.670
All right?

00:07:22.670 --> 00:07:25.110
So that's very straightforward.

00:07:25.110 --> 00:07:38.390
Then there is the shortest
weighted path, where instead

00:07:38.390 --> 00:07:42.530
of trying to find the shortest
sequence of edges, we want to

00:07:42.530 --> 00:07:46.610
find the smallest
total weight.

00:07:46.610 --> 00:07:50.690
So it may be that we traverse
a few extra edges, but since

00:07:50.690 --> 00:07:52.700
they have a shorter
weights, we end up

00:07:52.700 --> 00:07:53.950
getting a shorter path.

00:07:56.550 --> 00:08:01.410
So we might indirect to
do the shortest path.

00:08:01.410 --> 00:08:06.100
This is probably the more
common problem.

00:08:06.100 --> 00:08:09.360
So for example, that's the
problem that Google Maps

00:08:09.360 --> 00:08:16.580
solves, when you ask it to give
you driving directions.

00:08:16.580 --> 00:08:19.960
And you'll notice when you use
something like Google Maps or

00:08:19.960 --> 00:08:26.990
MapQuest, you can tell it to
minimize the time, in which

00:08:26.990 --> 00:08:31.320
case maybe it will route you
on a freeway, where you can

00:08:31.320 --> 00:08:33.909
drive at 80 miles an hour, even
though you drive a few

00:08:33.909 --> 00:08:35.390
extra miles.

00:08:35.390 --> 00:08:39.789
Or you can tell it to minimize
the distance in which case it

00:08:39.789 --> 00:08:42.350
may take you on these crummy
little surface roads where you

00:08:42.350 --> 00:08:46.180
have to drive slowly, but you'll
cover fewer miles and

00:08:46.180 --> 00:08:48.410
use less gas.

00:08:48.410 --> 00:08:52.220
So you get to tell it which set
of weights you care about,

00:08:52.220 --> 00:08:54.510
and then it finds
you the shortest

00:08:54.510 --> 00:08:57.990
path, given those weights.

00:08:57.990 --> 00:09:00.430
We'll come back to this since
we're going to look at some

00:09:00.430 --> 00:09:02.720
code to implement it.

00:09:02.720 --> 00:09:06.080
Another slightly more
complicated problem to

00:09:06.080 --> 00:09:09.620
understand is finding cliques.

00:09:12.280 --> 00:09:17.460
So to find a clique, we're
looking to find a set of

00:09:17.460 --> 00:09:34.800
nodes, such that there exists
a path connecting

00:09:34.800 --> 00:09:38.210
each node in the set.

00:09:44.730 --> 00:09:50.180
So you can think of this
as similar to,

00:09:50.180 --> 00:09:52.750
say a social clique--

00:09:52.750 --> 00:09:55.100
who your friends are.

00:09:55.100 --> 00:09:59.780
It's a group of nodes or group
of people that somehow can get

00:09:59.780 --> 00:10:01.970
to each other.

00:10:01.970 --> 00:10:04.590
It's not saying you can't
get outside the clique.

00:10:04.590 --> 00:10:07.910
But it is guaranteeing that from
any member of the clique,

00:10:07.910 --> 00:10:10.235
you can reach any other
member of the clique.

00:10:18.330 --> 00:10:23.610
And so well, we'll look at some
examples of where finding

00:10:23.610 --> 00:10:26.260
a clique is useful.

00:10:26.260 --> 00:10:36.420
And the final kind of problem
I want to mention is the

00:10:36.420 --> 00:10:38.250
minimum cut problem--

00:10:38.250 --> 00:10:41.870
often abbreviated mincut.

00:10:41.870 --> 00:10:50.300
So the problem here, is given a
graph, and given two sets of

00:10:50.300 --> 00:11:11.650
nodes, you want to find the
minimum number of edges such

00:11:11.650 --> 00:11:19.780
that if those edges are removed,
the two sets are

00:11:19.780 --> 00:11:21.030
disconnected.

00:11:25.020 --> 00:11:25.490
i.e.

00:11:25.490 --> 00:11:28.360
you can't get from a member
of one set to a member

00:11:28.360 --> 00:11:29.610
of the other set.

00:11:36.090 --> 00:11:39.100
This is often a question
that gets asked.

00:11:39.100 --> 00:11:43.760
For example, imagine that you
were the government of Syria

00:11:43.760 --> 00:11:45.490
and you want to ensure
that nobody can

00:11:45.490 --> 00:11:49.200
post a video on YouTube.

00:11:49.200 --> 00:11:52.520
You would take the set of nodes
in Syria, and you would

00:11:52.520 --> 00:11:57.580
take the set of nodes probably
outside Syria, and ask what's

00:11:57.580 --> 00:12:00.910
the minimum number of
communication links you'd have

00:12:00.910 --> 00:12:05.230
to cut to ensure that you can't
get from a node in Syria

00:12:05.230 --> 00:12:06.480
to a node outside Syria.

00:12:08.960 --> 00:12:14.330
People who do things like plan
power lines worry about that.

00:12:14.330 --> 00:12:17.590
They want to say what's the
minimum number of links such

00:12:17.590 --> 00:12:21.220
that if they're cut, you can't
get any electricity from this

00:12:21.220 --> 00:12:24.330
power plant to say, this city.

00:12:24.330 --> 00:12:28.050
And they'll typically design
their network with redundancy

00:12:28.050 --> 00:12:30.685
in it, so that the mincut
is not too small.

00:12:33.550 --> 00:12:37.110
And so people frequently are
worried about mincut problems,

00:12:37.110 --> 00:12:41.390
and trying to see
what that is.

00:12:41.390 --> 00:12:46.470
All right, now let's look at
a couple of examples, in

00:12:46.470 --> 00:12:48.520
slightly more detail.

00:12:48.520 --> 00:12:56.880
So what we see here is a
pictorial representation of a

00:12:56.880 --> 00:12:59.950
weighted graph generated by
the Centers for Disease

00:12:59.950 --> 00:13:05.740
Control, CDC, in Atlanta in 2003
when they were studying

00:13:05.740 --> 00:13:09.790
an outbreak of tuberculosis
in the United States--

00:13:09.790 --> 00:13:13.720
a virulent and bad infectious
disease.

00:13:13.720 --> 00:13:18.380
Each node, and you can see
these little dots are the

00:13:18.380 --> 00:13:24.480
nodes, represents a person.

00:13:24.480 --> 00:13:28.940
And each node is labeled by a
color, indicating whether the

00:13:28.940 --> 00:13:33.220
person has active tuberculosis,
has tested

00:13:33.220 --> 00:13:38.340
positive for exposure, but
doesn't have the disease, or

00:13:38.340 --> 00:13:43.530
tested negative for exposure,
or not been tested.

00:13:43.530 --> 00:13:47.700
So you'll remember when we
looked last time at class

00:13:47.700 --> 00:13:51.110
node, and asked why did I bother
creating a class for

00:13:51.110 --> 00:13:54.260
something so simple, it was
because I said well maybe we

00:13:54.260 --> 00:13:57.090
would add extra properties
to a node.

00:13:57.090 --> 00:14:01.670
So now in some sense these
colors would be easy to add.

00:14:01.670 --> 00:14:04.690
So I could add to class node--

00:14:04.690 --> 00:14:06.930
well I could attribute
color, and call it

00:14:06.930 --> 00:14:08.560
red or blue or green--

00:14:08.560 --> 00:14:12.640
or more likely an attribute
saying TB state, which would

00:14:12.640 --> 00:14:16.300
indicate active not
active, et cetera.

00:14:16.300 --> 00:14:22.430
The edges, which you can see
here, represent connections

00:14:22.430 --> 00:14:24.905
among pairs of people.

00:14:29.400 --> 00:14:31.830
What I didn't bother, you can't
see on these pictures,

00:14:31.830 --> 00:14:34.980
is the edges are actually
weighted.

00:14:34.980 --> 00:14:37.750
And the weights there
are about how

00:14:37.750 --> 00:14:40.320
closely people are connected.

00:14:40.320 --> 00:14:43.240
And there are really only two
weights I think they used:

00:14:43.240 --> 00:14:47.790
close, someone who say lives in
your house or works in the

00:14:47.790 --> 00:14:51.540
same office, or casual, a
neighbor you might have

00:14:51.540 --> 00:14:54.210
encountered, but you wouldn't
expect to necessarily

00:14:54.210 --> 00:14:57.110
see them every day.

00:14:57.110 --> 00:15:00.940
So I've taken a fairly
complicated set of information

00:15:00.940 --> 00:15:05.290
and represented it as a graph.

00:15:05.290 --> 00:15:07.890
Now what are some of the
interesting graph theoretic

00:15:07.890 --> 00:15:12.280
questions we might proceed
to ask about this?

00:15:12.280 --> 00:15:17.050
So an important question they
typically ask when diseases

00:15:17.050 --> 00:15:23.060
break out unexpectedly is, is
there an index patient?

00:15:23.060 --> 00:15:26.570
The index patient is the
patient who brought the

00:15:26.570 --> 00:15:29.250
disease into the community--

00:15:29.250 --> 00:15:31.970
so somebody who visited some
country, picked up

00:15:31.970 --> 00:15:36.130
tuberculosis, flew back to their
neighborhood in the US

00:15:36.130 --> 00:15:38.470
and started spreading it.

00:15:41.160 --> 00:15:44.750
How would we formulate that
as a graph question?

00:15:44.750 --> 00:15:48.020
Again, quite simply.

00:15:48.020 --> 00:16:05.630
We would say does there exist a
node such that node has TB,

00:16:05.630 --> 00:16:11.230
or maybe not even that,
no, let's simplify it.

00:16:11.230 --> 00:16:13.660
You might say, "or tested
positive" because maybe you

00:16:13.660 --> 00:16:16.940
can communicate it without
having it--

00:16:16.940 --> 00:16:30.840
has TB and is connected
to every node with TB.

00:16:35.730 --> 00:16:37.350
Now this doesn't guarantee
that the

00:16:37.350 --> 00:16:39.600
patient is an index patient.

00:16:39.600 --> 00:16:43.410
But if there is no such patient,
no such node, then

00:16:43.410 --> 00:16:46.380
you know that there's not a
single source of this disease

00:16:46.380 --> 00:16:47.630
in the community.

00:16:51.460 --> 00:16:56.180
How would we change the graph to
model it in a more detailed

00:16:56.180 --> 00:16:59.640
way, and remember this is all
about modeling, so that we

00:16:59.640 --> 00:17:03.995
could ask a question
or more precisely?

00:17:06.589 --> 00:17:11.240
Well we'd have to change to a
more complex coloring scheme,

00:17:11.240 --> 00:17:15.400
if you will, in which we'd
include the date of when

00:17:15.400 --> 00:17:20.440
somebody acquired the disease,
or tested positive.

00:17:20.440 --> 00:17:22.990
And then we could ask those
kinds of questions in a little

00:17:22.990 --> 00:17:24.700
bit more detail.

00:17:24.700 --> 00:17:29.050
But again once we've built the
model, we can then go and ask

00:17:29.050 --> 00:17:32.080
a lot of interesting
questions.

00:17:32.080 --> 00:17:34.370
By the way the answer to
this question, for

00:17:34.370 --> 00:17:36.830
this graph, is almost.

00:17:42.390 --> 00:17:47.920
There is an index patient that's
connected to every node

00:17:47.920 --> 00:17:51.285
in the graph, except for the
nodes in this black circle.

00:17:53.980 --> 00:18:00.780
They are not connected
to any index patient.

00:18:00.780 --> 00:18:04.690
So the CDC actually did that
analysis, and they reached

00:18:04.690 --> 00:18:07.620
that conclusion that there
didn't seem to be.

00:18:07.620 --> 00:18:11.550
And then later, it came to
light, in fact, that this

00:18:11.550 --> 00:18:13.640
particular graph is
missing an edge.

00:18:16.210 --> 00:18:19.250
Somebody had moved from
neighborhood A to neighborhood

00:18:19.250 --> 00:18:22.670
B, and they had not kept
track of that.

00:18:22.670 --> 00:18:24.720
And if they had, they would have
discovered there was a

00:18:24.720 --> 00:18:27.140
link that's missing--
an edge that's

00:18:27.140 --> 00:18:28.830
missing from this graph--

00:18:28.830 --> 00:18:31.000
which in fact would've connected
everybody to the

00:18:31.000 --> 00:18:34.230
index patient.

00:18:34.230 --> 00:18:35.380
It was an interesting
question.

00:18:35.380 --> 00:18:38.600
They only found that, because
they were puzzled about this

00:18:38.600 --> 00:18:41.270
tiny little black circle
out here, and started

00:18:41.270 --> 00:18:44.290
investigating all the people
in the black circle, and

00:18:44.290 --> 00:18:47.260
discovered that one of
them had moved from

00:18:47.260 --> 00:18:50.350
one place to another.

00:18:50.350 --> 00:18:52.570
What's another question you
might ask once you've built

00:18:52.570 --> 00:18:54.220
this model?

00:18:54.220 --> 00:18:58.230
Well suppose this is the current
state of the world,

00:18:58.230 --> 00:19:03.340
and I want to reduce the spread
of the disease, by

00:19:03.340 --> 00:19:06.950
vaccinating uninfected people
so that they don't contract

00:19:06.950 --> 00:19:09.390
tuberculosis.

00:19:09.390 --> 00:19:13.780
But I have a minimum, it's
expensive to do this, I only

00:19:13.780 --> 00:19:15.280
have so much vaccine.

00:19:15.280 --> 00:19:17.280
Who should get it?

00:19:17.280 --> 00:19:21.460
What's the graph theory problem
that I would solve to

00:19:21.460 --> 00:19:24.540
address the question of what's
the best way to allocate my

00:19:24.540 --> 00:19:25.790
limited supply a vaccine?

00:19:29.670 --> 00:19:30.820
Exactly.

00:19:30.820 --> 00:19:34.150
I, by the way, have much
better candy now.

00:19:34.150 --> 00:19:39.850
So I think that's where the
minimum cut came from.

00:19:39.850 --> 00:19:40.820
Well, all right.

00:19:40.820 --> 00:19:42.650
It's better for eating.

00:19:42.650 --> 00:19:43.900
It's just worse for throwing.

00:19:47.030 --> 00:19:48.740
That's easier to throw.

00:19:48.740 --> 00:19:50.920
All right.

00:19:50.920 --> 00:19:53.610
It's the minimum cut problem.

00:19:53.610 --> 00:19:59.610
I take the people who are
already infected, view them as

00:19:59.610 --> 00:20:01.450
one set of nodes.

00:20:01.450 --> 00:20:04.040
I take the people who are not
infected, and view them as

00:20:04.040 --> 00:20:09.400
another set of nodes, find the
edges that I need to cut to

00:20:09.400 --> 00:20:12.400
separate them, and then
vaccinated somebody on one

00:20:12.400 --> 00:20:16.550
side of the edge, so that they
don't contract the disease.

00:20:16.550 --> 00:20:21.200
So again a nice, easily
formalized, problem.

00:20:21.200 --> 00:20:24.590
All right, so that's
an example.

00:20:24.590 --> 00:20:27.040
Let's look at another example.

00:20:27.040 --> 00:20:30.730
Let's think about the shortest
path problem here.

00:20:30.730 --> 00:20:34.120
And we'll do that by thinking
about social networks.

00:20:34.120 --> 00:20:38.580
So I suspect that at least a few
of you have used Facebook,

00:20:38.580 --> 00:20:41.730
and you have friends--

00:20:41.730 --> 00:20:43.070
some of you more, than others.

00:20:46.760 --> 00:20:47.810
I see people laughing.

00:20:47.810 --> 00:20:50.700
This is someone who probably has
two friends, and is said.

00:20:50.700 --> 00:20:55.030
I don't know, or 1,000
friends and is happy.

00:20:55.030 --> 00:20:55.630
Who knows--

00:20:55.630 --> 00:20:56.880
I don't want to know please.

00:20:59.120 --> 00:21:00.240
And I'm not going to
tell you how many

00:21:00.240 --> 00:21:03.250
friends I have either.

00:21:03.250 --> 00:21:09.790
But you might ask the question,
suppose you wanted

00:21:09.790 --> 00:21:11.750
to reach Donald Trump --

00:21:11.750 --> 00:21:14.630
erstwhile Republican, vice
presidential candidate, or

00:21:14.630 --> 00:21:16.510
presidential candidate.

00:21:16.510 --> 00:21:20.170
Say is there a connection from
you to Donald Trump?

00:21:20.170 --> 00:21:22.140
Do you have a friend, who has
a friend, who has a friend,

00:21:22.140 --> 00:21:24.150
who is a friend with
Donald Trump?

00:21:24.150 --> 00:21:27.480
Or for Barack Obama, or
anyone else you'd ask.

00:21:27.480 --> 00:21:30.600
Well what's the shortest path?

00:21:30.600 --> 00:21:34.790
How many friends do you
have to go through?

00:21:34.790 --> 00:21:39.250
This is what's called the six
degrees of separation problem.

00:21:39.250 --> 00:21:43.840
In the 1990s, the playwright
John Guare published a play

00:21:43.840 --> 00:21:47.440
called Six Degrees of
Separation, under the slightly

00:21:47.440 --> 00:21:50.780
dubious premise, that everybody
in the world was

00:21:50.780 --> 00:21:52.580
connected to everybody
else in the world

00:21:52.580 --> 00:21:55.120
with at most six hops.

00:21:55.120 --> 00:21:57.070
If you took all the people you
knew, all the people they

00:21:57.070 --> 00:22:00.500
knew, et cetera, you could reach
any person in the world

00:22:00.500 --> 00:22:02.100
in six phone calls--

00:22:02.100 --> 00:22:04.040
say any person who
has a phone.

00:22:04.040 --> 00:22:08.630
I don't know whether that's
true, but this is the whole

00:22:08.630 --> 00:22:11.910
notion of a social network.

00:22:11.910 --> 00:22:14.880
So if we wanted to look at that
in Facebook, we could

00:22:14.880 --> 00:22:18.700
either assume that the friend
relation is symmetric--

00:22:18.700 --> 00:22:22.260
if I'm your friend, you're
my friend, which it is.

00:22:22.260 --> 00:22:24.690
Or you could imagine a different
model, in which it's

00:22:24.690 --> 00:22:26.090
asymmetric.

00:22:26.090 --> 00:22:28.670
If it's symmetric you
have a graph.

00:22:28.670 --> 00:22:32.590
If it's asymmetric you have
a directed graph.

00:22:32.590 --> 00:22:34.950
And then you just ask
the question.

00:22:34.950 --> 00:22:37.830
What's the shortest
path from you to

00:22:37.830 --> 00:22:40.150
whomever you care about?

00:22:40.150 --> 00:22:43.280
And you get that.

00:22:43.280 --> 00:22:46.030
You could imagine that Facebook
already knows the

00:22:46.030 --> 00:22:49.540
answer to that question, but
just won't tell you.

00:22:49.540 --> 00:22:52.880
But they'll sell it to somebody
who has enough money.

00:22:52.880 --> 00:22:58.370
All right, So how does Facebook
solve this problem?

00:22:58.370 --> 00:23:01.480
They have a very simple piece of
code, which we'll now look

00:23:01.480 --> 00:23:03.300
at which solves the
shortest path.

00:23:10.310 --> 00:23:11.560
So let's go back.

00:23:19.000 --> 00:23:21.870
So here's a recursive

00:23:21.870 --> 00:23:26.640
implementation of shortest path.

00:23:26.640 --> 00:23:28.365
Comment this out while I'm
in the neighborhood.

00:23:33.890 --> 00:23:39.800
It takes the graph, a start node
and end node to print,

00:23:39.800 --> 00:23:42.530
and this extra argument
call visited.

00:23:42.530 --> 00:23:45.200
We'll see why that's
gets used.

00:23:45.200 --> 00:23:48.970
And we'll think about
the algorithm.

00:23:48.970 --> 00:23:52.990
This particular algorithm is
what's called a depth first

00:23:52.990 --> 00:23:55.350
search algorithm.

00:23:55.350 --> 00:23:57.710
It's a recursive depth
first search.

00:23:57.710 --> 00:24:13.185
We've seen these before,
often abbreviated DFS.

00:24:15.730 --> 00:24:20.110
So if you think about having
a graph of a bunch of nodes

00:24:20.110 --> 00:24:30.140
connected to one another, just
for fun we'll say it does

00:24:30.140 --> 00:24:33.230
something like this.

00:24:33.230 --> 00:24:37.040
What depth first search does
is it starts at the source

00:24:37.040 --> 00:24:43.030
node for the shortest path,
let's called it this one, it

00:24:43.030 --> 00:24:48.080
first visits one child, then
visits all the children of

00:24:48.080 --> 00:24:51.250
those children.

00:24:51.250 --> 00:24:54.160
This one has no children.

00:24:54.160 --> 00:24:59.200
Visits this child, picks one of
its children, visits all of

00:24:59.200 --> 00:25:01.970
its children-- let's say it
had another one here--

00:25:01.970 --> 00:25:06.330
and goes on until it's done.

00:25:06.330 --> 00:25:12.530
And then it back tracks, comes
back and takes the next child.

00:25:12.530 --> 00:25:14.865
Then we have to be a little bit
careful about the circle.

00:25:17.440 --> 00:25:28.060
So to summarize it, first thing
we have to say is the

00:25:28.060 --> 00:25:41.060
recursion ends, when
start equals end.

00:25:41.060 --> 00:25:47.290
That is to say I've called it
and I've asked is there a path

00:25:47.290 --> 00:25:49.770
from A to A, and the answer
is yes, there is.

00:25:49.770 --> 00:25:52.150
I'm already there.

00:25:52.150 --> 00:25:54.940
Now you could argue, and in some
formulations the answer

00:25:54.940 --> 00:25:58.590
is not necessarily, you'd say
there's only a path if there's

00:25:58.590 --> 00:26:03.370
an edge from A to A. But I've
chosen to make the simpler

00:26:03.370 --> 00:26:05.440
assertion that if you want to
get to A, and you're already

00:26:05.440 --> 00:26:07.070
there, you're done.

00:26:07.070 --> 00:26:10.360
Kind of seems reasonable.

00:26:10.360 --> 00:26:29.060
So then the recursive part,
starts by choosing one child

00:26:29.060 --> 00:26:33.080
of the node you're
currently at.

00:26:33.080 --> 00:26:38.180
And it keeps doing that until
either it reaches a node with

00:26:38.180 --> 00:26:47.280
no children, or it reaches the
node you're trying to get to,

00:26:47.280 --> 00:26:51.910
or, and here's an important
part, it reaches a node it's

00:26:51.910 --> 00:26:53.980
already seen.

00:26:53.980 --> 00:26:56.210
And that's what visited
is about.

00:26:56.210 --> 00:27:00.100
Because I want to make sure
that when I explore this

00:27:00.100 --> 00:27:02.950
graph, I don't go from here to
here to here to here to here

00:27:02.950 --> 00:27:06.350
to here ad nauseum, because
I'm stuck in

00:27:06.350 --> 00:27:07.600
what's called a cycle.

00:27:14.170 --> 00:27:15.490
You have to avoid the cycles.

00:27:22.250 --> 00:27:28.110
Once it's got to a node that has
no children, if that's not

00:27:28.110 --> 00:27:32.990
the node it's trying to get to,
it back tracks and takes

00:27:32.990 --> 00:27:38.885
the next child of the
node it was at.

00:27:46.840 --> 00:27:52.200
And in that way, it
systematically explores all

00:27:52.200 --> 00:27:58.800
possible paths, and along the
way, it chooses the best one.

00:27:58.800 --> 00:28:00.390
So we can look at
the code here.

00:28:03.030 --> 00:28:05.970
I've just commented out
something we'll look at later

00:28:05.970 --> 00:28:08.000
just as we try and instrument
it to see

00:28:08.000 --> 00:28:11.380
how fast it's working.

00:28:11.380 --> 00:28:14.700
I've got a debugging statement
just to say whether I'm going

00:28:14.700 --> 00:28:16.865
to print what I've been
asked to do, in

00:28:16.865 --> 00:28:18.830
case it's not working.

00:28:18.830 --> 00:28:21.000
And then the real work starts.

00:28:21.000 --> 00:28:25.060
I get the original path is just
the node we're starting

00:28:25.060 --> 00:28:27.620
at, if start is end, I stop.

00:28:30.450 --> 00:28:33.680
If I get to here, or say
shortest equals none, I

00:28:33.680 --> 00:28:35.240
haven't found any paths yet.

00:28:35.240 --> 00:28:38.000
So there is no shortest path.

00:28:38.000 --> 00:28:44.350
And then for node in the
children of start, if I

00:28:44.350 --> 00:28:45.820
haven't already visited
the node--

00:28:45.820 --> 00:28:48.170
this is to avoid cycles--

00:28:48.170 --> 00:28:52.910
I create a visited list that
contains whatever used to

00:28:52.910 --> 00:28:56.090
contain plus the node.

00:28:56.090 --> 00:29:00.080
Notice that I'm creating a new
list here, rather than

00:29:00.080 --> 00:29:02.340
mutating the old list.

00:29:02.340 --> 00:29:05.930
And that's because when I
unravel my recursion, and back

00:29:05.930 --> 00:29:10.170
track to where I was, I don't
want to have think I visited

00:29:10.170 --> 00:29:13.040
something I haven't
visited, right?

00:29:13.040 --> 00:29:16.900
If I had only one list, and I
mutated each time, then as I

00:29:16.900 --> 00:29:19.950
go down the recursion and back
up the recursion, I'm always

00:29:19.950 --> 00:29:22.880
dealing with the same list.

00:29:22.880 --> 00:29:26.550
By getting a new list, I'm
ensuring that I don't have

00:29:26.550 --> 00:29:29.480
that problem.

00:29:29.480 --> 00:29:33.270
Then I say the new path is
whatever the shortest path is,

00:29:33.270 --> 00:29:37.340
from the node I'm currently at
to the desired end node.

00:29:37.340 --> 00:29:40.580
And I use the current set of
visited nodes to indicate

00:29:40.580 --> 00:29:43.760
where I've already been at this
part of the recursion.

00:29:47.550 --> 00:29:51.600
If the new path is none, well
didn't find one, I continue.

00:29:51.600 --> 00:29:55.060
Otherwise, I found a path, and
now I just want to check is it

00:29:55.060 --> 00:30:00.910
better, or worse, or the same,
as the previous shortest path.

00:30:00.910 --> 00:30:03.120
And then I'm done.

00:30:03.120 --> 00:30:05.390
Very straightforward.

00:30:05.390 --> 00:30:08.690
The only really tricky part was
making sure that I kept

00:30:08.690 --> 00:30:14.250
track of visited properly, and
didn't get stuck in cycles.

00:30:14.250 --> 00:30:17.720
OK let's run it.

00:30:17.720 --> 00:30:19.880
So here's testTwo --

00:30:19.880 --> 00:30:23.310
builds the same kind of graph
we've built before.

00:30:23.310 --> 00:30:26.135
And then it tries to find
the shortest path.

00:30:28.700 --> 00:30:33.790
And I'm going to do it for the
same input, essentially, the

00:30:33.790 --> 00:30:37.400
same at edge operations, but
once when it's a graph and

00:30:37.400 --> 00:30:38.650
once when it's a digraph.

00:30:45.410 --> 00:30:47.785
So you'll notice that it found
two different answers.

00:30:52.050 --> 00:30:56.860
When it was a graph, it could
get from 0 to 4 in

00:30:56.860 --> 00:30:58.125
essentially one hop.

00:31:02.250 --> 00:31:08.690
But when it was a digraph,
it took longer.

00:31:08.690 --> 00:31:12.050
It had to go from 0
to two to 3 to 4.

00:31:12.050 --> 00:31:13.790
And that's not surprising,
because the

00:31:13.790 --> 00:31:15.135
graph has more edges.

00:31:17.890 --> 00:31:21.950
And in fact, what we saw is that
in the graph there was an

00:31:21.950 --> 00:31:25.020
edge from 4 to 0, but there
was no such edge in the

00:31:25.020 --> 00:31:26.990
directed graph.

00:31:26.990 --> 00:31:28.510
So again you'll get,

00:31:28.510 --> 00:31:33.560
unsurprisingly, different answers--

00:31:33.560 --> 00:31:36.440
but very straightforwardly.

00:31:36.440 --> 00:31:40.000
Now let's try it on
a bigger problem.

00:31:51.010 --> 00:31:53.930
So I've called this big test.

00:31:53.930 --> 00:31:56.270
And what this does, is rather
than my sitting there and

00:31:56.270 --> 00:32:01.080
typing a bunch of at edge
commands, it just generates

00:32:01.080 --> 00:32:03.830
edges at random.

00:32:03.830 --> 00:32:07.580
So I tell it whether I want it
to be a graph or digraph, and

00:32:07.580 --> 00:32:10.870
then I give it the number
of nodes I want, and

00:32:10.870 --> 00:32:11.760
the number of edges.

00:32:11.760 --> 00:32:14.570
And it just generates, at
random, a graph in this case

00:32:14.570 --> 00:32:19.430
with 25 nodes and 200 edges.

00:32:19.430 --> 00:32:21.550
So let's see what
happens here.

00:32:28.670 --> 00:32:35.630
So it's printed out the
graph, and now we're

00:32:35.630 --> 00:32:38.650
waiting a little bit.

00:32:38.650 --> 00:32:41.350
It will eventually
finish, there.

00:32:41.350 --> 00:32:43.550
I can get from 0 to 4.

00:32:43.550 --> 00:32:46.520
It turns out there's a short
path for this random graph

00:32:46.520 --> 00:32:48.800
from 0 to 14 to 4.

00:32:48.800 --> 00:32:50.980
It's not so surprising that
there's a short path.

00:32:50.980 --> 00:32:55.180
Why is it not surprising that
there's a pretty short path?

00:32:55.180 --> 00:32:56.400
It had a lot of edges, right?

00:32:56.400 --> 00:32:59.140
I had 200 edges in my graph.

00:32:59.140 --> 00:33:01.125
So things are pretty
densely connected.

00:33:03.640 --> 00:33:05.125
Why did it take so long?

00:33:08.540 --> 00:33:14.310
Well remember what it's doing is
exploring all the possible

00:33:14.310 --> 00:33:17.560
paths from 0 to 4,
in this case.

00:33:21.220 --> 00:33:23.530
This is very much like what we
saw when we looked at the

00:33:23.530 --> 00:33:25.530
knapsack problem, right?

00:33:25.530 --> 00:33:29.100
Where, there when we looked at
the recursive implementation,

00:33:29.100 --> 00:33:32.670
we saw that well all right,
generating all possibilities,

00:33:32.670 --> 00:33:35.310
there were an exponential number
of possibilities there

00:33:35.310 --> 00:33:37.720
in the number of items.

00:33:37.720 --> 00:33:42.440
Here, depending upon the number
of nodes and the number

00:33:42.440 --> 00:33:46.330
of edges, it's also large,
and in fact, exponential.

00:33:50.390 --> 00:33:56.380
We could explore a lot of
different paths, but let's see

00:33:56.380 --> 00:34:00.610
what's going on when
we explore those.

00:34:00.610 --> 00:34:04.500
So what I'm going to
do now, is go back

00:34:04.500 --> 00:34:05.760
to our small example.

00:34:08.380 --> 00:34:13.239
We'll run testTwo That was the
small one we looked at.

00:34:13.239 --> 00:34:18.090
But I'm going to set to print
onto true, and if you remember

00:34:18.090 --> 00:34:22.920
what that code did is they told
us what each recursive

00:34:22.920 --> 00:34:26.274
call was, what the start node
was and what the end node was.

00:34:31.280 --> 00:34:34.429
So it found the same
shortest path.

00:34:34.429 --> 00:34:37.090
That's a good thing, 0 to 4.

00:34:37.090 --> 00:34:39.989
But how did it do that?

00:34:39.989 --> 00:34:45.730
Well it first got called with
the question of starting at 0

00:34:45.730 --> 00:34:48.000
find me a path to 4.

00:34:48.000 --> 00:34:51.300
It visited the first child
of 0, which was 1.

00:34:51.300 --> 00:34:54.239
It said, all right see if you
can find a path from 1 to 4.

00:34:56.940 --> 00:35:01.120
It then backtracked and sort
of asked the same question,

00:35:01.120 --> 00:35:03.750
can I get from 2 to 4?

00:35:03.750 --> 00:35:04.720
From 0 to 4?

00:35:04.720 --> 00:35:07.130
And then it said well I can get
from 0 to 2, let me try 2

00:35:07.130 --> 00:35:13.370
to 4, 3 to 4, 4 to
4, that's good.

00:35:13.370 --> 00:35:17.040
Get to 5 to 4, and then it tried
to find 4 to 4 again.

00:35:17.040 --> 00:35:19.730
Here it tried to find
2 to 4 again.

00:35:19.730 --> 00:35:25.420
So what you can see, is as I
do that backtracking, I'm

00:35:25.420 --> 00:35:30.750
solving the same problem
multiple times.

00:35:30.750 --> 00:35:32.760
Why am I doing that?

00:35:32.760 --> 00:35:38.920
Because there may be multiple
ways to get to the same node.

00:35:38.920 --> 00:35:47.950
So if, for example, I looked at
this graph, what we would

00:35:47.950 --> 00:35:52.882
see is I would try and let's
say I want to get to here,

00:35:52.882 --> 00:35:57.050
just for the sake of argument,
I'd first say can I get to

00:35:57.050 --> 00:35:58.420
here from here.

00:35:58.420 --> 00:36:02.520
I'd try this, then I'd
solve here to here.

00:36:02.520 --> 00:36:05.830
And I'd do that.

00:36:05.830 --> 00:36:10.290
I'd also go from here to here
to here, and then for the

00:36:10.290 --> 00:36:14.670
second time, I'd try and solve
the problem here to here.

00:36:14.670 --> 00:36:16.860
Now here since it's only
one connection,

00:36:16.860 --> 00:36:18.620
it's a short thing.

00:36:18.620 --> 00:36:22.350
But you can see if I have
multiple ways to get to the

00:36:22.350 --> 00:36:26.520
same intermediate node, each
time I get there I'm going to

00:36:26.520 --> 00:36:30.070
solve a problem I have
already solved--

00:36:30.070 --> 00:36:32.570
how to get from that
intermediate node to the final

00:36:32.570 --> 00:36:34.490
destination.

00:36:34.490 --> 00:36:37.310
So I'm doing work I've
already done before.

00:36:41.390 --> 00:36:45.740
This is obviously troublesome.

00:36:45.740 --> 00:36:47.720
Nobody likes to solve
a problem they've

00:36:47.720 --> 00:36:49.290
already solved before.

00:36:49.290 --> 00:36:50.990
So what do you think
the solution is?

00:36:53.720 --> 00:36:55.500
How would you solve this
sort of thing yourself?

00:36:58.460 --> 00:36:59.710
What would you do?

00:37:03.940 --> 00:37:06.320
Well what you'd--
yeah, thank you.

00:37:06.320 --> 00:37:07.240
This guy is hungry.

00:37:07.240 --> 00:37:08.017
Go ahead.

00:37:08.017 --> 00:37:11.052
AUDIENCE: Some way of storing
information that you've

00:37:11.052 --> 00:37:12.220
already looked at.

00:37:12.220 --> 00:37:14.100
PROFESSOR: Exactly.

00:37:14.100 --> 00:37:23.330
What you try and do, is remember
what you did before,

00:37:23.330 --> 00:37:26.320
and just look it up.

00:37:26.320 --> 00:37:30.730
This is a very common
technique.

00:37:30.730 --> 00:37:32.790
It's called memoization.

00:37:41.350 --> 00:37:45.280
We use this to solve a lot of
problems where you remember

00:37:45.280 --> 00:37:48.500
what the answer was, and rather
than recalculating it,

00:37:48.500 --> 00:37:51.590
you just look it up.

00:37:51.590 --> 00:37:55.780
And that can, of course,
be much faster.

00:37:55.780 --> 00:37:58.140
So it's a fancy way
to say we're going

00:37:58.140 --> 00:37:59.390
to use a table look-up.

00:38:03.840 --> 00:38:09.750
This concept of memoization
is at the heart of a very

00:38:09.750 --> 00:38:13.040
important programming technique
called dynamic

00:38:13.040 --> 00:38:14.290
programming.

00:38:22.090 --> 00:38:24.870
In the algorithms class that's
taught in this room

00:38:24.870 --> 00:38:28.080
immediately following this
class, they have spent at

00:38:28.080 --> 00:38:32.120
least four lectures on the topic
of dynamic programming.

00:38:32.120 --> 00:38:34.910
But since you guys are much
smarter than those guys taking

00:38:34.910 --> 00:38:38.530
that class, we're going to do
it in about 20 minutes, in

00:38:38.530 --> 00:38:43.140
today and a little bit
in the next lecture.

00:38:43.140 --> 00:38:46.935
All right, so let's look
at an example.

00:38:50.490 --> 00:38:51.660
We'll look at a solution.

00:38:51.660 --> 00:39:02.420
So I've taken the recursive
implementation we had before,

00:39:02.420 --> 00:39:08.880
and rewritten it just a little
bit, to call dp, dynamic

00:39:08.880 --> 00:39:13.140
programming shortest path.

00:39:13.140 --> 00:39:17.500
And the most important thing
to notice is I've given yet

00:39:17.500 --> 00:39:22.590
another argument to the
function, and that's the memo,

00:39:22.590 --> 00:39:25.360
which is initially an
empty dictionary.

00:39:28.150 --> 00:39:33.440
The rest of the algorithm
proceeds as before, except

00:39:33.440 --> 00:39:41.330
what happens here is when I want
to get from a path, the

00:39:41.330 --> 00:39:46.170
first question I ask is I say
new path is equal to the memo

00:39:46.170 --> 00:39:48.540
of node to end.

00:39:48.540 --> 00:39:52.320
So when I get to one of these
interior nodes, and I want to

00:39:52.320 --> 00:39:55.760
say what's the shortest path
from here to here, the first

00:39:55.760 --> 00:39:59.980
question I ask is do I already
know the answer?

00:39:59.980 --> 00:40:02.160
Is it already in my memo?

00:40:02.160 --> 00:40:08.130
If so, I just look it
up, and I'm done.

00:40:08.130 --> 00:40:11.220
I found it, and I proceed
as before.

00:40:11.220 --> 00:40:17.370
If it's not in the memo, well
this look up will fail, and

00:40:17.370 --> 00:40:22.970
I'll enter the except clause,
and I'll make a call again.

00:40:22.970 --> 00:40:26.290
So this is a very conventional
way of using try, except as a

00:40:26.290 --> 00:40:28.010
control structure.

00:40:28.010 --> 00:40:31.150
Failing to find in the memo is
not an error, it just means I

00:40:31.150 --> 00:40:33.980
haven't yet stored it away.

00:40:33.980 --> 00:40:36.840
And as I go, I'll build up the
memo, and then I'm done.

00:40:41.470 --> 00:40:45.660
So it's very simple.

00:40:45.660 --> 00:40:49.380
So I should ask the question.

00:40:49.380 --> 00:40:52.010
Does anyone need me to explain
this again, or does it makes

00:40:52.010 --> 00:40:53.720
sense what we're doing
here with a memo?

00:40:56.990 --> 00:40:59.450
OK, I'm assuming
it makes sense.

00:40:59.450 --> 00:41:01.370
Let's test it.

00:41:01.370 --> 00:41:04.330
And we'll first do a
very simple test.

00:41:04.330 --> 00:41:06.560
We're just going to use
the same little

00:41:06.560 --> 00:41:09.620
graph we used before.

00:41:09.620 --> 00:41:13.330
And I'm going to run shortest
path, and dp_shortest path,

00:41:13.330 --> 00:41:16.110
and at least confirm that
for one search I

00:41:16.110 --> 00:41:18.142
get the same answer.

00:41:18.142 --> 00:41:21.380
It's just fire testing it to
make sure that it's not a

00:41:21.380 --> 00:41:22.630
complete disaster.

00:41:25.380 --> 00:41:27.010
And we do.

00:41:27.010 --> 00:41:30.190
We get 0234, 0234.

00:41:30.190 --> 00:41:33.210
So at least for one thing,
it's the same thing.

00:41:36.830 --> 00:41:39.500
Let's see about performance,
because that's really what we

00:41:39.500 --> 00:41:40.750
got interested in.

00:41:43.090 --> 00:41:47.640
So we'll go back to
our big test.

00:41:50.220 --> 00:41:58.720
And let's go back and for both
of these, I'm going to

00:41:58.720 --> 00:42:04.980
uncomment, tracking this global
variable, just keeping

00:42:04.980 --> 00:42:09.630
track of the number of calls,
and we'll see whether we get a

00:42:09.630 --> 00:42:14.970
substantially different amount
of recursion, in

00:42:14.970 --> 00:42:16.390
one versus the other.

00:42:38.260 --> 00:42:40.150
So it's built some random
graph again.

00:42:44.620 --> 00:42:48.170
This is the non-dynamic
programming one, which as we

00:42:48.170 --> 00:42:50.390
recall, takes a bit longer.

00:42:54.090 --> 00:42:56.960
I probably should have said--
all right, so it's pretty big

00:42:56.960 --> 00:42:58.310
difference.

00:42:58.310 --> 00:43:01.300
They found the same
path, 0, 2,3, 4.

00:43:01.300 --> 00:43:05.630
But you'll notice the
straightforward depth first

00:43:05.630 --> 00:43:12.380
search took over 800,000
recursive calls, whereas the

00:43:12.380 --> 00:43:17.380
dynamic programming one took
only an order of 2000--

00:43:17.380 --> 00:43:18.630
a huge difference.

00:43:23.180 --> 00:43:26.340
If I ran it again, I might see a
slightly smaller difference.

00:43:26.340 --> 00:43:28.070
I might even see a considerably
larger

00:43:28.070 --> 00:43:29.410
difference.

00:43:29.410 --> 00:43:33.230
I've run this on some examples
where the recursive search

00:43:33.230 --> 00:43:37.450
depth first took a million, and
got through the dynamic

00:43:37.450 --> 00:43:39.960
programming in 50, 60.

00:43:39.960 --> 00:43:44.480
But what you can see is there's
a huge improvement in

00:43:44.480 --> 00:43:47.370
going from one to the other.

00:43:47.370 --> 00:43:50.960
Dynamic programming was invented
in the 1950s by

00:43:50.960 --> 00:43:52.210
someone named Richard Bellman.

00:43:55.290 --> 00:43:58.860
Many a student has wasted
a lot of time trying to

00:43:58.860 --> 00:44:02.080
understand why it's called
dynamic programming.

00:44:02.080 --> 00:44:05.630
And you or I could invent
lots of theories.

00:44:05.630 --> 00:44:08.850
Relatively recently, I found out
why it was called dynamic

00:44:08.850 --> 00:44:13.620
programming, and this is
a quote from Bellman.

00:44:13.620 --> 00:44:15.860
"It was an attempt to hide
what I was doing from

00:44:15.860 --> 00:44:18.160
government sponsors.

00:44:18.160 --> 00:44:20.640
The fact that I was really
doing mathematics was

00:44:20.640 --> 00:44:24.240
something not even a congressman
could object to."

00:44:24.240 --> 00:44:27.960
So he was doing this thing that
was pretty evil, which

00:44:27.960 --> 00:44:31.510
was mathematics, which is what
he thought this was-- the math

00:44:31.510 --> 00:44:33.330
of dynamic programming.

00:44:33.330 --> 00:44:35.600
And he just didn't
want to admit it.

00:44:35.600 --> 00:44:38.340
So he made up a name out of
nothing, and it fooled the

00:44:38.340 --> 00:44:40.550
government, and he
got to do it.

00:44:40.550 --> 00:44:43.430
Now why do I teach you
dynamic programming?

00:44:43.430 --> 00:44:45.690
And we're going to talk a little
bit more about it, the

00:44:45.690 --> 00:44:47.730
next lecture.

00:44:47.730 --> 00:44:52.380
It's because it is one of the
most important algorithms that

00:44:52.380 --> 00:44:54.980
we know today.

00:44:54.980 --> 00:45:01.330
It's used over and over again
to provide practical,

00:45:01.330 --> 00:45:07.850
efficient solutions to
optimization problems that on

00:45:07.850 --> 00:45:11.470
their surface appear
intractable.

00:45:11.470 --> 00:45:13.610
They appear exponential.

00:45:13.610 --> 00:45:16.120
It says there is no good
way to solve it.

00:45:16.120 --> 00:45:21.830
In fact, if it has certain kinds
of properties, it will

00:45:21.830 --> 00:45:24.620
always be amenable to
solutions by dynamic

00:45:24.620 --> 00:45:28.360
programming, which will most
of the time-- and I'll come

00:45:28.360 --> 00:45:30.390
back to the most of the time--

00:45:30.390 --> 00:45:35.110
end up taking an exponential
problem, and solving it really

00:45:35.110 --> 00:45:38.560
quickly, as we did here.

00:45:38.560 --> 00:45:41.240
I could have made this graph
enormous, and dynamic

00:45:41.240 --> 00:45:45.590
programming would have given us
a very fast solution to it.

00:45:45.590 --> 00:45:47.600
So when can we use dynamic
programming?

00:45:50.270 --> 00:45:51.543
Not all the time.

00:45:54.420 --> 00:46:02.500
We can use it on problems that
exhibit two properties.

00:46:02.500 --> 00:46:05.086
The problem must have optimal
substructure.

00:46:15.070 --> 00:46:20.060
What this means is that you can
find a globally optimal

00:46:20.060 --> 00:46:25.505
solution by combining locally
optimal solutions.

00:46:54.400 --> 00:46:59.540
So we can again see that with
our graph problem, that we can

00:46:59.540 --> 00:47:04.230
combine the solutions from nodes
at a distance from the

00:47:04.230 --> 00:47:08.020
root node to get the solution
of getting there

00:47:08.020 --> 00:47:09.840
from the root node.

00:47:09.840 --> 00:47:13.720
If I know I can get from A to B,
and I can find the optimal

00:47:13.720 --> 00:47:17.350
solution from B to C, then I
can use that to find the

00:47:17.350 --> 00:47:23.020
optimal solution from A to
C. So it has optimal

00:47:23.020 --> 00:47:24.270
substructure.

00:47:25.990 --> 00:47:32.350
The other thing it has to have
is overlapping sub-problems.

00:47:32.350 --> 00:47:34.380
And that's the thing I
emphasized earlier--

00:47:41.800 --> 00:47:46.120
that finding the optimal
solution involves finding

00:47:46.120 --> 00:47:51.930
optimal solution to the same
sub-problem multiple times.

00:47:51.930 --> 00:47:55.180
Otherwise, we could build this
memo, but we'd never

00:47:55.180 --> 00:47:57.790
successfully look up
anything in it.

00:47:57.790 --> 00:47:59.910
And so the algorithm would give
us the right answer, but

00:47:59.910 --> 00:48:01.160
we'd get no speedup,.

00:48:03.850 --> 00:48:07.710
So it's this property that we
need to know that we'll get

00:48:07.710 --> 00:48:10.260
the correct answer--

00:48:10.260 --> 00:48:12.980
that when we combine the local
solutions, we'll get the right

00:48:12.980 --> 00:48:14.750
global solution.

00:48:14.750 --> 00:48:18.570
It's this property that gives
us an indication of how much

00:48:18.570 --> 00:48:22.100
of a speedup we can
expect to achieve.

00:48:22.100 --> 00:48:25.300
How many problems will we not
have to solve, because we can

00:48:25.300 --> 00:48:27.390
look up the solution?

00:48:27.390 --> 00:48:29.270
We'll come back to this.

00:48:29.270 --> 00:48:33.260
And we'll see how it applies to
another problem that you've

00:48:33.260 --> 00:48:36.590
already looked at say the
knapsack problem, to give us a

00:48:36.590 --> 00:48:40.700
fast solution to that, so that
if you want a answer, go back

00:48:40.700 --> 00:48:44.360
to a previous problem set, and
take the full database of

00:48:44.360 --> 00:48:47.540
classes, you'll be able to solve
it quickly using dynamic

00:48:47.540 --> 00:48:48.690
programming.

00:48:48.690 --> 00:48:50.460
OK, see you next time.