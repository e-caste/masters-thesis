WEBVTT

00:00:00.000 --> 00:00:01.964
[SQUEAKING]

00:00:01.964 --> 00:00:03.437
[RUSTLING]

00:00:03.437 --> 00:00:05.401
[CLICKING]

00:00:25.550 --> 00:00:27.330
MICHAEL SIPSER: Hi, everybody.

00:00:27.330 --> 00:00:29.608
I hope you can hear me.

00:00:29.608 --> 00:00:30.900
Give me a thumbs up if you can.

00:00:30.900 --> 00:00:31.400
Good.

00:00:34.140 --> 00:00:36.805
I see them coming through.

00:00:36.805 --> 00:00:38.055
So we're going to get started.

00:00:41.280 --> 00:00:44.820
So getting back to
what we've been doing.

00:00:44.820 --> 00:00:48.270
We've been talking
about space complexity.

00:00:48.270 --> 00:00:51.630
Measures how much memory
the algorithm requires

00:00:51.630 --> 00:00:53.850
or various problems require.

00:00:53.850 --> 00:01:02.850
And we defined the space
complexity classes,

00:01:02.850 --> 00:01:05.010
space f of n and
non-deterministic space

00:01:05.010 --> 00:01:09.930
f of n, the polynomial space
and non-deterministic space

00:01:09.930 --> 00:01:13.230
classes, and gave some
examples and so on.

00:01:13.230 --> 00:01:17.070
And today we're going to pick
up where we left off last time.

00:01:17.070 --> 00:01:18.630
One of the examples,
which is going

00:01:18.630 --> 00:01:22.320
to be an important one for
us, concerns this latter DFA

00:01:22.320 --> 00:01:23.120
problem.

00:01:23.120 --> 00:01:25.680
So I'm going to go over that
again, give a little bit more

00:01:25.680 --> 00:01:30.210
emphasis to the space
analysis, which I got

00:01:30.210 --> 00:01:32.010
some questions about last time.

00:01:32.010 --> 00:01:34.560
And then we are going
to move on from there

00:01:34.560 --> 00:01:36.660
and prove Savitch's
theorem and then

00:01:36.660 --> 00:01:40.380
talk about a complete
problems for PSPACE

00:01:40.380 --> 00:01:43.650
and show that this problem TQBF,
which we introduced last time,

00:01:43.650 --> 00:01:47.160
is actually a PSPACE
complete problem.

00:01:47.160 --> 00:01:50.740
But all in due course.

00:01:50.740 --> 00:01:52.420
A little bit of review.

00:01:52.420 --> 00:01:54.900
So we defined what we
mean by a Turing machine

00:01:54.900 --> 00:01:57.450
to run in a certain
amount of space.

00:01:57.450 --> 00:02:00.900
That means it uses
at most f of n.

00:02:00.900 --> 00:02:04.740
If it's running in space f of
n, uses at most f of n cells,

00:02:04.740 --> 00:02:07.980
tape cells, on every
input of length n.

00:02:07.980 --> 00:02:11.430
And similarly, a
non-deterministic Turing

00:02:11.430 --> 00:02:12.750
machine does the same.

00:02:12.750 --> 00:02:18.150
But in addition to that, the
non-deterministic machine

00:02:18.150 --> 00:02:21.720
has to halt on every
branch of its computation.

00:02:21.720 --> 00:02:23.580
And each branch
of its computation

00:02:23.580 --> 00:02:29.833
has to use at most that
bounded amount of tape cells.

00:02:29.833 --> 00:02:32.250
So we're going to be talking
about non-deterministic space

00:02:32.250 --> 00:02:34.200
computation today as well.

00:02:34.200 --> 00:02:37.960
It's going to be relevant to us.

00:02:37.960 --> 00:02:41.610
So we defined the
classes, as I mentioned,

00:02:41.610 --> 00:02:45.660
and the polynomial
and the PSPACE

00:02:45.660 --> 00:02:47.580
and non-deterministic
PSPACE classes.

00:02:47.580 --> 00:02:53.670
And this is how we believe
they relate to one another.

00:02:53.670 --> 00:02:56.950
The classes coNP and NP as well.

00:02:56.950 --> 00:03:01.440
And of course, as I
mentioned last time,

00:03:01.440 --> 00:03:05.440
there are some very major
unsolved problems in this area.

00:03:05.440 --> 00:03:07.620
So everything could
conceivably collapse down

00:03:07.620 --> 00:03:10.950
to P, which would, of
course, be very surprising.

00:03:10.950 --> 00:03:14.770
But we don't know how
to prove otherwise.

00:03:14.770 --> 00:03:17.070
And the big theorem that
we're going to prove today

00:03:17.070 --> 00:03:20.640
is that polynomial space and
non-deterministic polynomial

00:03:20.640 --> 00:03:25.050
space actually do collapse
down to each other.

00:03:25.050 --> 00:03:28.998
And being the same class.

00:03:28.998 --> 00:03:31.040
So in contrast with the
situation that we believe

00:03:31.040 --> 00:03:33.710
to be the case for
time complexity

00:03:33.710 --> 00:03:36.920
where we believe converting
non-deterministic

00:03:36.920 --> 00:03:41.420
to deterministic gives an
exponential increase for space

00:03:41.420 --> 00:03:44.900
complexity, it only gives
a squaring increase,

00:03:44.900 --> 00:03:47.520
as we'll see.

00:03:47.520 --> 00:03:54.110
So any questions on any of this?

00:03:54.110 --> 00:03:57.635
We will just march into a little
review of this latter problem.

00:04:01.500 --> 00:04:05.570
So reviewing some
of the notation.

00:04:05.570 --> 00:04:07.447
And let me emphasize that.

00:04:07.447 --> 00:04:09.530
So the big theorem we're
going to be proving today

00:04:09.530 --> 00:04:14.563
is that PSPACE and
NPSPACE are equal.

00:04:14.563 --> 00:04:15.980
And also we're
going to be talking

00:04:15.980 --> 00:04:20.990
about PSPACE completeness.

00:04:20.990 --> 00:04:26.180
But both of those
involve proving theorems.

00:04:26.180 --> 00:04:29.180
In the first case,
Savitch's theorem

00:04:29.180 --> 00:04:31.610
that converting
non-deterministic to

00:04:31.610 --> 00:04:34.010
deterministic
spaces is squaring.

00:04:34.010 --> 00:04:38.870
And in the second case, proving
that TQBF is PSPACE complete.

00:04:38.870 --> 00:04:42.650
Both of those theorems can be
thought of as generalizations

00:04:42.650 --> 00:04:51.110
of this theorem here that
the latter DFA problem can

00:04:51.110 --> 00:04:55.905
be done in the deterministic
polynomial space or n squared

00:04:55.905 --> 00:04:56.405
space.

00:05:00.410 --> 00:05:04.580
So it really pays
to try to understand

00:05:04.580 --> 00:05:07.460
how the proof of
this theorem works.

00:05:07.460 --> 00:05:11.210
Because in a sense, this theorem
is a more concrete version

00:05:11.210 --> 00:05:14.210
of what we're going to be seeing
in those other two theorems

00:05:14.210 --> 00:05:16.550
in a somewhat more
abstract form.

00:05:16.550 --> 00:05:20.570
So I like understanding things
in a more concrete way first.

00:05:20.570 --> 00:05:23.570
So that's why this is a good
example to start out with.

00:05:23.570 --> 00:05:25.350
But really in the
end of the day,

00:05:25.350 --> 00:05:27.620
it's the same
proof just repeated

00:05:27.620 --> 00:05:28.970
for those three theorems.

00:05:28.970 --> 00:05:32.750
So this is really three
for the price of one.

00:05:32.750 --> 00:05:35.630
Three theorems, one proof here.

00:05:35.630 --> 00:05:38.750
So you're going to be seeing
the same proof repeated

00:05:38.750 --> 00:05:43.910
three times but in different
levels of abstraction.

00:05:43.910 --> 00:05:46.990
So let's review again.

00:05:46.990 --> 00:05:52.290
I know some of you got it,
but maybe some of you didn't.

00:05:52.290 --> 00:05:58.160
And let's just try to be
clear on the algorithm

00:05:58.160 --> 00:06:00.480
to solve the ladder DFA problem.

00:06:00.480 --> 00:06:03.260
So if you remember, first of
all, let me just jump on ahead.

00:06:03.260 --> 00:06:05.810
The ladder problem is--

00:06:05.810 --> 00:06:08.270
a ladder, first of
all, is a sequence

00:06:08.270 --> 00:06:13.790
of strings that change one
symbol at a time that perhaps

00:06:13.790 --> 00:06:16.230
connect, go from one
string to another.

00:06:16.230 --> 00:06:18.050
So you're going to
go from work to play,

00:06:18.050 --> 00:06:19.920
changing one symbol at a time.

00:06:19.920 --> 00:06:21.770
So we gave an example
of this or you

00:06:21.770 --> 00:06:25.010
can easily come up with
an example of doing this.

00:06:25.010 --> 00:06:29.270
But the computational
problem is can you do it?

00:06:29.270 --> 00:06:32.270
Can you get from this
string to that string

00:06:32.270 --> 00:06:34.460
and stay within a
certain language?

00:06:34.460 --> 00:06:36.710
So it might be the
language of English words

00:06:36.710 --> 00:06:38.930
or it might be the
language of all strings

00:06:38.930 --> 00:06:47.990
that some specific
DFA recognizes.

00:06:47.990 --> 00:06:50.700
So it might be
all of the string.

00:06:50.700 --> 00:06:52.700
These might all be
strings that some DFA

00:06:52.700 --> 00:06:58.280
accepts or might be English
words or some other rule.

00:06:58.280 --> 00:07:04.640
And so that's what
we mean by trying

00:07:04.640 --> 00:07:07.130
to test if there's a ladder.

00:07:07.130 --> 00:07:12.800
And so the ladder problem
is, well, I don't think I

00:07:12.800 --> 00:07:14.870
wrote down the ladder
problem itself.

00:07:14.870 --> 00:07:18.960
But the bounded ladder problem
is basically the same idea.

00:07:18.960 --> 00:07:20.390
You're given the DFA.

00:07:20.390 --> 00:07:22.490
You're given the
strings u and v.

00:07:22.490 --> 00:07:24.650
And now this is
the bounded version

00:07:24.650 --> 00:07:26.720
of the problem where
I'm going to give you

00:07:26.720 --> 00:07:29.750
a limit on the number
of steps you can take.

00:07:29.750 --> 00:07:31.080
So I'm illustrating that here.

00:07:31.080 --> 00:07:32.540
So you're going to be given a b.

00:07:32.540 --> 00:07:34.820
And you want to say, can
I get from this string

00:07:34.820 --> 00:07:36.785
to that string within b steps?

00:07:40.620 --> 00:07:43.920
And we had a notation
for writing that.

00:07:43.920 --> 00:07:48.720
Going from u to v, if there's
a ladder that connects

00:07:48.720 --> 00:07:51.550
u to v within at most b steps.

00:07:51.550 --> 00:07:53.140
And so the bounded
ladder problem,

00:07:53.140 --> 00:07:54.900
which I'm introducing
because I'm

00:07:54.900 --> 00:07:57.270
going to be aiming toward
a recursive algorithm

00:07:57.270 --> 00:08:04.320
to solve this problem is can
I get from u to v by a ladder,

00:08:04.320 --> 00:08:08.340
changing one symbol at a time,
where each string along the way

00:08:08.340 --> 00:08:12.390
is accepted by b, and
I'm only allowed b steps.

00:08:12.390 --> 00:08:13.110
Little b steps.

00:08:16.200 --> 00:08:19.170
So that is the
computational problem

00:08:19.170 --> 00:08:21.930
that I'm going to be
solving with the algorithm

00:08:21.930 --> 00:08:24.570
that I'm going to describe.

00:08:24.570 --> 00:08:26.310
So the algorithm
I'm going to call

00:08:26.310 --> 00:08:30.090
BL for bounded ladder problem.

00:08:30.090 --> 00:08:33.150
And here is the input.

00:08:33.150 --> 00:08:36.000
And the algorithm
is, first of all,

00:08:36.000 --> 00:08:38.850
going to look to
see if b equals 1.

00:08:38.850 --> 00:08:42.870
If I'm just trying to get
from u to v in a single step.

00:08:42.870 --> 00:08:45.810
In that case, it's a
very simple problem,

00:08:45.810 --> 00:08:50.400
because you want to test,
obviously, that u and v are

00:08:50.400 --> 00:08:53.400
accepted by the automaton.

00:08:53.400 --> 00:08:55.920
And they just have to
differ in one place.

00:08:55.920 --> 00:08:58.620
And then you have a
very simple one step

00:08:58.620 --> 00:09:02.820
ladder that takes u to v.
So for the case b equals 1,

00:09:02.820 --> 00:09:05.280
it's very simple.

00:09:05.280 --> 00:09:09.450
For larger values
of b, we're going

00:09:09.450 --> 00:09:11.640
to solve the problem
recursively in terms

00:09:11.640 --> 00:09:15.330
of smaller values of b.

00:09:15.330 --> 00:09:24.180
So for b greater than 1, we're
going to recursively test.

00:09:24.180 --> 00:09:27.330
If you're trying to solve the
problem can I get from u to v,

00:09:27.330 --> 00:09:33.443
instead we're going to try
each possible halfway through.

00:09:33.443 --> 00:09:35.110
We don't know that
it's halfway through.

00:09:35.110 --> 00:09:37.380
So we're just going to
try each possible string.

00:09:37.380 --> 00:09:43.290
And we're going to test can we
get from u, the initial string,

00:09:43.290 --> 00:09:48.670
to that new string, that w,
in half the number of steps.

00:09:48.670 --> 00:09:50.770
And can I get to
the final string

00:09:50.770 --> 00:09:52.750
v in half the number of steps?

00:09:52.750 --> 00:09:58.010
If I can do that, then
I can get from u to v

00:09:58.010 --> 00:09:59.810
the total number of steps b.

00:09:59.810 --> 00:10:03.620
So I'm just going to
try to do this one w

00:10:03.620 --> 00:10:06.500
at a time for every possible w.

00:10:06.500 --> 00:10:09.500
This is going to be very
expensive in terms of time,

00:10:09.500 --> 00:10:11.352
but we're not worried
about time right now.

00:10:11.352 --> 00:10:13.310
We're trying to cut down
on the amount of space

00:10:13.310 --> 00:10:14.112
that we're using.

00:10:14.112 --> 00:10:16.070
And this is going to be
a big savings in space.

00:10:19.750 --> 00:10:22.600
Let's not worry about the
division, b over 2 here.

00:10:22.600 --> 00:10:24.010
All of the divisions,
we're going

00:10:24.010 --> 00:10:28.047
to be seeing this several times
going forward in the lecture,

00:10:28.047 --> 00:10:29.380
we'll think of them rounding up.

00:10:29.380 --> 00:10:32.470
But I'm not going to
make the notation look

00:10:32.470 --> 00:10:36.160
cumbersome by writing
that every time.

00:10:36.160 --> 00:10:36.760
OK.

00:10:36.760 --> 00:10:37.750
So here we go.

00:10:37.750 --> 00:10:42.370
Here is some candidate w string,
which is halfway through.

00:10:46.070 --> 00:10:47.180
Recursively test.

00:10:47.180 --> 00:10:51.410
Can I get from the starting
string to that w and from w

00:10:51.410 --> 00:10:54.060
to that ending string?

00:10:54.060 --> 00:10:57.760
If I can, if I find
such a w, then I accept.

00:10:57.760 --> 00:11:04.930
And if I try all possible w and
I never manage to find a way

00:11:04.930 --> 00:11:06.760
to make both the top
and the bottom work,

00:11:06.760 --> 00:11:10.840
then I know I cannot get
from the starting string

00:11:10.840 --> 00:11:12.940
to the ending string
within b steps.

00:11:12.940 --> 00:11:15.100
And so I reject.

00:11:15.100 --> 00:11:19.150
And now I'm going to solve
the original unbounded ladder

00:11:19.150 --> 00:11:22.000
problem by simply
putting the biggest

00:11:22.000 --> 00:11:25.900
possible bound into the
bounded ladder problem.

00:11:25.900 --> 00:11:32.350
And that's this value t, which
gives the very trivial bound

00:11:32.350 --> 00:11:35.950
of the total number
of possible strings

00:11:35.950 --> 00:11:41.070
that I can write down within my
length m that I'm working with.

00:11:41.070 --> 00:11:44.630
So this if sigma is the
alphabet of these strings,

00:11:44.630 --> 00:11:46.520
it's just sigma to the m.

00:11:46.520 --> 00:11:47.900
That's all possible strings.

00:11:47.900 --> 00:11:51.740
Of course, that's going to be
a maximum size on the ladder.

00:11:56.080 --> 00:11:58.600
So now how much
space does this take?

00:11:58.600 --> 00:12:03.250
And I think this is where
people got a little bit lost

00:12:03.250 --> 00:12:05.390
in the lecture last time.

00:12:05.390 --> 00:12:07.817
So I'm going to try
to animate this.

00:12:07.817 --> 00:12:09.650
I don't know if that's
going to help or not.

00:12:09.650 --> 00:12:11.130
But in the end of
the day, you're

00:12:11.130 --> 00:12:14.500
just going to have to think
through how do you account

00:12:14.500 --> 00:12:16.450
for the cost of this recursion.

00:12:19.330 --> 00:12:21.250
But the main thing,
to start off,

00:12:21.250 --> 00:12:23.410
you have to make sure you
understand the algorithm.

00:12:23.410 --> 00:12:25.210
And if you get
from here to there,

00:12:25.210 --> 00:12:28.510
we're going to try
all possible midpoints

00:12:28.510 --> 00:12:33.220
and then solve the upper part
and the lower part recursively,

00:12:33.220 --> 00:12:36.190
reusing the space.

00:12:36.190 --> 00:12:38.140
That's the way we're
going to get a saving.

00:12:38.140 --> 00:12:41.170
By solving this problem,
reusing the space

00:12:41.170 --> 00:12:45.100
that we use to
solve this problem.

00:12:45.100 --> 00:12:48.550
So I'm going to try to show
this to you on actually

00:12:48.550 --> 00:12:50.800
how the space gets used
on the Turing machine.

00:12:50.800 --> 00:12:53.080
You can kind of think
of here's the input

00:12:53.080 --> 00:12:55.960
and then after that is going to
be the stack for the recursion.

00:12:55.960 --> 00:12:58.460
If you're not that familiar
with how to implement recursion,

00:12:58.460 --> 00:13:00.160
it doesn't really matter.

00:13:00.160 --> 00:13:03.890
But you can just think about
what the algorithm needs

00:13:03.890 --> 00:13:05.000
to keep track of.

00:13:07.960 --> 00:13:11.700
And so as it's trying
every possible w,

00:13:11.700 --> 00:13:16.740
so just in order like
an odometer, just

00:13:16.740 --> 00:13:21.090
trying every possible
string, eventually maybe it

00:13:21.090 --> 00:13:24.480
finds a string that's
in the language that

00:13:24.480 --> 00:13:26.940
hears an English word, one
of the first English words

00:13:26.940 --> 00:13:30.160
of length 4 that
you might run into.

00:13:30.160 --> 00:13:34.750
And so now it makes sense,
actually, to do the recursion.

00:13:34.750 --> 00:13:36.810
So that's all.

00:13:36.810 --> 00:13:40.050
Every time you're going
to have to have a register

00:13:40.050 --> 00:13:43.140
or a location on the tape where
you're going to be writing down

00:13:43.140 --> 00:13:44.970
those different w's.

00:13:44.970 --> 00:13:46.770
So let's say it's over here.

00:13:46.770 --> 00:13:48.570
And we're just
going to go through.

00:13:48.570 --> 00:13:50.910
I hope that's not too
small for you to see.

00:13:50.910 --> 00:13:55.300
That's really where that
action is happening.

00:13:55.300 --> 00:13:57.480
And finally, maybe you
got to the string w.

00:13:57.480 --> 00:13:59.740
Now you're going to try
to do the recursion.

00:13:59.740 --> 00:14:06.930
So here as you're doing the
recursion on the top half

00:14:06.930 --> 00:14:08.440
again, you're going
to be cutting--

00:14:08.440 --> 00:14:13.830
you're going to be finding a
new w for the intermediate point

00:14:13.830 --> 00:14:17.848
just solving this upper
problem where we're testing

00:14:17.848 --> 00:14:19.140
if I can get from work to able.

00:14:19.140 --> 00:14:21.870
Later I'm going to have to deal
with getting from able to play.

00:14:29.010 --> 00:14:30.120
Good.

00:14:30.120 --> 00:14:34.650
So here, again, we're
going to be fixing able,

00:14:34.650 --> 00:14:38.010
fixing the first w.

00:14:38.010 --> 00:14:40.530
We're going to try
every possible way

00:14:40.530 --> 00:14:46.240
of getting from the start
string to that middle string.

00:14:46.240 --> 00:14:48.670
So we're going to try
every possible thing here.

00:14:48.670 --> 00:14:52.920
Eventually maybe we find some
other string in the language.

00:14:52.920 --> 00:14:55.920
We get down to the string book.

00:14:55.920 --> 00:15:00.420
And that's all
going to get stored.

00:15:00.420 --> 00:15:03.020
You can't forget
the string able.

00:15:03.020 --> 00:15:04.770
But now we're going
to use some more space

00:15:04.770 --> 00:15:08.160
to store those candidates.

00:15:08.160 --> 00:15:13.230
So that's a second version
of w deeper in the recursion.

00:15:13.230 --> 00:15:16.880
So here we're going to be
triangle to possible strings

00:15:16.880 --> 00:15:17.570
here.

00:15:17.570 --> 00:15:21.860
Again, eventually we
get to some string book.

00:15:21.860 --> 00:15:29.030
And if that succeeds in getting
us from work to able via book,

00:15:29.030 --> 00:15:31.820
now we're going to jump
down to do the bottom half,

00:15:31.820 --> 00:15:34.490
to see if I can get
from able to play

00:15:34.490 --> 00:15:39.150
as a separate problem, which
gets solved in the same space.

00:15:39.150 --> 00:15:43.850
So now here we're going to try
all these possibilities getting

00:15:43.850 --> 00:15:44.750
from able to play.

00:15:44.750 --> 00:15:47.970
Maybe call is the right
intermediate string there.

00:15:47.970 --> 00:15:51.662
And so now we're going
to erase the book

00:15:51.662 --> 00:15:53.412
and now we're going
to solve the lower sub

00:15:53.412 --> 00:15:55.440
problem in the same location.

00:15:55.440 --> 00:15:56.892
I hope this is helpful.

00:15:56.892 --> 00:15:58.850
This was a lot of work
making these animations.

00:16:05.970 --> 00:16:09.060
So the point of all
this is every time

00:16:09.060 --> 00:16:11.460
we go down the level
of the recursion,

00:16:11.460 --> 00:16:15.210
there's another
register whose size

00:16:15.210 --> 00:16:20.870
is big enough to hold one
of the strings, is needed.

00:16:20.870 --> 00:16:30.460
And that register
gets reused times

00:16:30.460 --> 00:16:35.410
throughout as we're going
through this recursion.

00:16:35.410 --> 00:16:39.820
So anyway, I hope
that's helpful.

00:16:39.820 --> 00:16:40.420
Anyway.

00:16:40.420 --> 00:16:46.450
So each level of the recursion
adds another order in

00:16:46.450 --> 00:16:48.100
to record the w.

00:16:48.100 --> 00:16:51.470
And so you have to do--
how many levels do we get.

00:16:51.470 --> 00:16:52.960
Well, the depth of
the recursion is

00:16:52.960 --> 00:16:55.630
going to be how
many times we end up

00:16:55.630 --> 00:17:01.120
having to divide this picture
in half until we get down to 1.

00:17:01.120 --> 00:17:04.569
And so the height of
this when we start off

00:17:04.569 --> 00:17:09.565
is going to be basically
an exponential in m. m

00:17:09.565 --> 00:17:11.410
is roughly the size of n.

00:17:11.410 --> 00:17:15.175
So when you take the log of
that, you're going to get--

00:17:18.950 --> 00:17:21.950
you're going to pull
down the exponential.

00:17:21.950 --> 00:17:24.109
So it's going to be
order m or, which is,

00:17:24.109 --> 00:17:26.150
again, roughly the
same size as the input.

00:17:26.150 --> 00:17:29.416
m is like half the input
because the whole input is u

00:17:29.416 --> 00:17:32.492
and v. m is just the size of u.

00:17:32.492 --> 00:17:36.140
And so each level
requires order n,

00:17:36.140 --> 00:17:39.230
and the depth is going
to be order n deep.

00:17:39.230 --> 00:17:44.630
The log of the initial
height of this ladder.

00:17:44.630 --> 00:17:49.480
And so the total space used is
going to be order n squared.

00:17:49.480 --> 00:17:51.600
So why don't we
just take a minute?

00:17:51.600 --> 00:17:54.510
I'm happy to spend a little
time going through this,

00:17:54.510 --> 00:17:57.990
either the algorithm's
correctness,

00:17:57.990 --> 00:18:00.690
understanding recursion,
or understanding the space

00:18:00.690 --> 00:18:01.260
analysis.

00:18:01.260 --> 00:18:02.802
If there's any
question that you feel

00:18:02.802 --> 00:18:07.950
you can ask that would be
clarifying for you, jump in.

00:18:07.950 --> 00:18:10.740
I'll set aside a few minutes
just to answer questions here.

00:18:13.640 --> 00:18:15.100
So I've got a question here.

00:18:15.100 --> 00:18:19.030
In step five, why
do we reject if all

00:18:19.030 --> 00:18:21.565
fail instead of just one fails?

00:18:25.520 --> 00:18:29.870
Well, here, so remember
what we're trying to do.

00:18:29.870 --> 00:18:34.110
We're trying to say can I
get from u to v in b steps?

00:18:36.910 --> 00:18:39.340
The way I'm going
to be doing that is

00:18:39.340 --> 00:18:42.490
trying every possible
intermediate string w.

00:18:45.750 --> 00:18:52.130
If I find some w
which does not work,

00:18:52.130 --> 00:18:53.980
that doesn't mean
that there's not

00:18:53.980 --> 00:18:55.630
some other w which might work.

00:18:55.630 --> 00:18:59.230
All I need is one
w for which I can

00:18:59.230 --> 00:19:02.230
get from u to w in half
the number of steps and w

00:19:02.230 --> 00:19:04.070
to v in half the
number of steps.

00:19:04.070 --> 00:19:06.160
So I'm going to try
every possible w.

00:19:06.160 --> 00:19:09.580
If any one of them is
good, then I can accept.

00:19:09.580 --> 00:19:12.370
If any one of them
succeeds where

00:19:12.370 --> 00:19:14.620
I can get from u to
w in half the steps

00:19:14.620 --> 00:19:17.875
and to w to v in half
the steps, then I

00:19:17.875 --> 00:19:22.070
know I can get from u to v
in the full number of steps.

00:19:22.070 --> 00:19:24.820
So I only need to find one.

00:19:24.820 --> 00:19:27.370
If one particular
one doesn't work,

00:19:27.370 --> 00:19:28.750
I'll just go on to the next one.

00:19:37.460 --> 00:19:37.975
OK.

00:19:37.975 --> 00:19:38.975
This is a good question.

00:19:41.820 --> 00:19:44.570
Do we have to save
the word book?

00:19:44.570 --> 00:19:47.750
So once we succeed in
getting from work to able,

00:19:47.750 --> 00:19:51.050
let's say via book, do
we need to save that word

00:19:51.050 --> 00:19:51.920
book anywhere?

00:19:51.920 --> 00:19:52.970
No.

00:19:52.970 --> 00:19:56.060
All we need to remember
is that we've succeeded

00:19:56.060 --> 00:19:58.550
in getting from work to able.

00:19:58.550 --> 00:20:00.780
We don't need to
remember book anymore.

00:20:00.780 --> 00:20:04.640
We just remember
that we've succeeded.

00:20:04.640 --> 00:20:09.560
And that is by virtue of
where we are in the algorithm.

00:20:09.560 --> 00:20:12.350
If we have succeeded,
then we move

00:20:12.350 --> 00:20:18.350
on to the second recursion,
second call, recursive call.

00:20:18.350 --> 00:20:20.700
So we found some way to do it.

00:20:20.700 --> 00:20:24.290
So we found some
intermediate point

00:20:24.290 --> 00:20:26.030
which succeeds for this one.

00:20:26.030 --> 00:20:27.320
So we move on to that one.

00:20:27.320 --> 00:20:29.430
We don't have to keep
any of that work anymore.

00:20:29.430 --> 00:20:31.160
All you have to do
is remember, yes,

00:20:31.160 --> 00:20:33.840
I can get from work to able
in half the number of steps.

00:20:33.840 --> 00:20:37.820
Now all that's left is
to get from able to play

00:20:37.820 --> 00:20:39.860
in half the number of steps.

00:20:39.860 --> 00:20:43.110
It doesn't matter how I got
to able in the first place.

00:20:43.110 --> 00:20:45.177
So we don't have
to remember that.

00:20:45.177 --> 00:20:46.510
That was a good question though.

00:20:49.300 --> 00:20:52.750
So I think I understand this.

00:20:52.750 --> 00:21:00.430
Before we replace the
value for book with call

00:21:00.430 --> 00:21:04.390
with the work
involved to find call,

00:21:04.390 --> 00:21:06.910
yeah, we have to check that
we can get from work to book

00:21:06.910 --> 00:21:08.810
and book to able.

00:21:08.810 --> 00:21:14.140
So we keep onto book while
we're working on the upper half.

00:21:14.140 --> 00:21:17.110
And only when we've
finally succeeded

00:21:17.110 --> 00:21:20.440
in getting from work to
able, let's say via book,

00:21:20.440 --> 00:21:24.380
then you can throw a book away.

00:21:24.380 --> 00:21:27.020
But while you're working on
the upper half, you try book,

00:21:27.020 --> 00:21:31.770
you try different strings of
length four until one of them

00:21:31.770 --> 00:21:32.270
works.

00:21:39.230 --> 00:21:39.800
I'm not sure.

00:21:39.800 --> 00:21:42.560
Somebody is asking me about
breadth first search and depth

00:21:42.560 --> 00:21:43.070
for search.

00:21:43.070 --> 00:21:44.300
I'm not sure I see it.

00:21:49.595 --> 00:21:51.970
I'm not sure that's going to
be a helpful way of thinking

00:21:51.970 --> 00:21:52.550
about this.

00:21:52.550 --> 00:21:54.300
So I'm not going to
answer that right now.

00:21:54.300 --> 00:22:00.730
But you can ask that
offline later if you want.

00:22:00.730 --> 00:22:06.340
Why is the recursion depth
log t instead of log m?

00:22:06.340 --> 00:22:08.500
Well, how high is this thing?

00:22:08.500 --> 00:22:13.280
Initially it's t high.

00:22:13.280 --> 00:22:16.310
But every time
we're doing a level,

00:22:16.310 --> 00:22:19.160
we're calling the recursion,
we're cutting t in half.

00:22:22.120 --> 00:22:24.070
I'm solving this
in general for b,

00:22:24.070 --> 00:22:28.980
but we starting off with b equal
to t. t is the maximum size.

00:22:28.980 --> 00:22:32.200
So initially this
is going to be t,

00:22:32.200 --> 00:22:35.200
and then it's going to be
t over 2, then t over 4.

00:22:35.200 --> 00:22:39.160
So it's going to be log t
levels before we get down to 1.

00:22:46.720 --> 00:22:47.220
Yeah.

00:22:47.220 --> 00:22:48.690
So somebody is
asking, can we think

00:22:48.690 --> 00:22:49.830
of this as a memory stack?

00:22:49.830 --> 00:22:51.247
Yes, this is like--
that's the way

00:22:51.247 --> 00:22:53.010
your typical
implementation of recursion

00:22:53.010 --> 00:22:56.010
is kind of with a stack, where
you push when you make a call

00:22:56.010 --> 00:22:57.780
and you pop when you
return from the call.

00:23:02.320 --> 00:23:08.990
Is it possible that v can
appear during BL procedure on t?

00:23:08.990 --> 00:23:12.652
Is it possible
that v can appear?

00:23:12.652 --> 00:23:13.860
I'm not sure what that means.

00:23:13.860 --> 00:23:16.200
It can reappear.

00:23:16.200 --> 00:23:19.127
So I'm starting with
u to v. Is it possible

00:23:19.127 --> 00:23:21.210
that v might be one of
these intermediate strings?

00:23:21.210 --> 00:23:21.710
Yeah.

00:23:25.020 --> 00:23:27.930
You're going to try every
possible intermediate stream

00:23:27.930 --> 00:23:29.250
blindly.

00:23:29.250 --> 00:23:30.510
Including v is one of them.

00:23:33.330 --> 00:23:39.030
If you can reach v more
quickly, well, great.

00:23:39.030 --> 00:23:41.550
I guess I have not dealt
with the issue of what

00:23:41.550 --> 00:23:43.875
happens if you get to a--

00:23:50.950 --> 00:23:52.750
technically it's
going to work out

00:23:52.750 --> 00:23:56.080
because I'm allowing
the difference

00:23:56.080 --> 00:23:57.590
to be in at most one place.

00:23:57.590 --> 00:23:59.290
So even if you get
there early, you're

00:23:59.290 --> 00:24:02.020
allowed to not change
anything, and that still

00:24:02.020 --> 00:24:03.670
is a legal step in the ladder.

00:24:08.280 --> 00:24:08.780
Yeah.

00:24:08.780 --> 00:24:11.710
I don't see how to do this
from a bottom up perspective.

00:24:11.710 --> 00:24:14.540
Somebody's is asking is there
a bottom up version of this.

00:24:14.540 --> 00:24:18.290
I don't think so.

00:24:18.290 --> 00:24:20.500
No, I don't think so.

00:24:20.500 --> 00:24:21.000
All right.

00:24:21.000 --> 00:24:23.710
Why don't we move on?

00:24:23.710 --> 00:24:28.050
So now we're going to
see this proof again.

00:24:28.050 --> 00:24:34.120
But this time we're
going to be proving

00:24:34.120 --> 00:24:39.460
that you can convert
any NFA to a DFA

00:24:39.460 --> 00:24:41.590
with only a squaring increase.

00:24:41.590 --> 00:24:50.600
So really, well, let me
just put that up there.

00:24:50.600 --> 00:24:53.270
So this is going to be
Savitch's theorem, that

00:24:53.270 --> 00:24:57.470
among other things proves
that PSPACE equals NPSPACE.

00:24:57.470 --> 00:25:02.000
So it says that you can convert
a non-deterministic machine

00:25:02.000 --> 00:25:05.553
to a deterministic machine only
squaring the amount of space.

00:25:05.553 --> 00:25:07.470
So you're comfortable
with this notation here.

00:25:07.470 --> 00:25:10.910
Anything that you can do in f
of n space non-deterministically

00:25:10.910 --> 00:25:15.860
you can do in f squared of
n based deterministically.

00:25:15.860 --> 00:25:17.660
And we're going
to accomplish that

00:25:17.660 --> 00:25:24.050
by converting an NTM
to a deterministic TM

00:25:24.050 --> 00:25:25.970
but only squaring
the space used.

00:25:25.970 --> 00:25:28.880
So n is going to
convert it to an m.

00:25:28.880 --> 00:25:31.250
And now this proof
is going to look

00:25:31.250 --> 00:25:35.890
very similar to the proof
in the previous slide.

00:25:35.890 --> 00:25:36.940
It's the same proof.

00:25:42.130 --> 00:25:45.850
And the fact from the
previous slide about ladder

00:25:45.850 --> 00:25:49.090
really is implied
by this, because we

00:25:49.090 --> 00:25:52.420
had an easy algorithm to show
that the latter problem is

00:25:52.420 --> 00:25:56.980
solvable in
non-deterministic, in NPSPACE.

00:25:56.980 --> 00:26:01.570
So ladder problem was
easily shown to be in here.

00:26:01.570 --> 00:26:06.300
If you remember, you
just basically guess

00:26:06.300 --> 00:26:07.830
the steps of the ladder.

00:26:07.830 --> 00:26:10.560
So non-deterministically,
you can easily check,

00:26:10.560 --> 00:26:13.500
can I get from the
start to the end?

00:26:13.500 --> 00:26:18.210
But Savitch's theorem
tells us that anything

00:26:18.210 --> 00:26:20.670
you can do non-deterministically
in polynomial space you

00:26:20.670 --> 00:26:22.870
can do deterministically
in polynomial space.

00:26:22.870 --> 00:26:25.320
So what we showed in
the previous slide

00:26:25.320 --> 00:26:28.080
follows from this
slide, but this slide

00:26:28.080 --> 00:26:30.390
is really just a generalization
of the same proof.

00:26:32.970 --> 00:26:35.550
Maybe I've said it
too many times now.

00:26:35.550 --> 00:26:40.140
So we're going to
introduce a notation very

00:26:40.140 --> 00:26:42.125
similar to the notation
we had last time.

00:26:42.125 --> 00:26:43.500
But now we're
going to be talking

00:26:43.500 --> 00:26:47.130
about simulating this
non-deterministic machine

00:26:47.130 --> 00:26:49.350
with a deterministic machine.

00:26:49.350 --> 00:26:51.570
And we're going to
take two configurations

00:26:51.570 --> 00:26:56.180
of this non-deterministic
machine, ci and cj,

00:26:56.180 --> 00:27:03.120
and say can I get from ci
to cj in at most b steps?

00:27:03.120 --> 00:27:05.160
I'm going to have a notation.

00:27:05.160 --> 00:27:08.580
Very similar to the notation
for the ladder where

00:27:08.580 --> 00:27:11.400
I can get from this word
to that word in at most b

00:27:11.400 --> 00:27:12.750
steps by a ladder.

00:27:12.750 --> 00:27:15.335
Here can I get from
this word to that--

00:27:15.335 --> 00:27:16.710
can I get from
this configuration

00:27:16.710 --> 00:27:18.600
to that configuration
with at most

00:27:18.600 --> 00:27:23.900
b steps of the Turing
machine's operation?

00:27:23.900 --> 00:27:28.540
So these are two
configurations now of n.

00:27:28.540 --> 00:27:32.260
So can n go from
this configuration ci

00:27:32.260 --> 00:27:35.710
to that other
configuration cj but only

00:27:35.710 --> 00:27:37.780
taking b steps along the way?

00:27:37.780 --> 00:27:39.820
That's now the
computational problem

00:27:39.820 --> 00:27:41.950
that I'm going to solve
for you with an algorithm.

00:27:41.950 --> 00:27:44.890
And it's going to be a recursion
exactly like the previous one.

00:27:47.940 --> 00:27:51.920
So n gets its input
the two configurations

00:27:51.920 --> 00:27:56.060
ci and cj and the bound
b and want to check

00:27:56.060 --> 00:27:59.620
can I get from i to j within b?

00:27:59.620 --> 00:28:04.430
So now the picture is a little
different but very similar.

00:28:04.430 --> 00:28:08.800
So instead of a
ladder appearing here,

00:28:08.800 --> 00:28:10.390
it's really something
that's basically

00:28:10.390 --> 00:28:16.580
a tableau for the
machine n where

00:28:16.580 --> 00:28:20.750
I have an initial configuration
and an ending configuration.

00:28:20.750 --> 00:28:27.505
This would happen to
be the starting point

00:28:27.505 --> 00:28:28.880
for the whole
procedure if you're

00:28:28.880 --> 00:28:31.890
testing whether n accepts w.

00:28:31.890 --> 00:28:35.390
But we would be solving
this in general for any--

00:28:35.390 --> 00:28:38.780
so that case, so I have the
start configuration of n on w

00:28:38.780 --> 00:28:42.650
and the accepting configuration
or an accepting configuration.

00:28:42.650 --> 00:28:48.420
But in general, what
I will be solving

00:28:48.420 --> 00:28:50.850
is starting with
any configuration ci

00:28:50.850 --> 00:28:54.160
and going to any
configuration cj.

00:28:54.160 --> 00:28:58.150
So I want to test
can I get from ci

00:28:58.150 --> 00:29:01.730
to cj within at most b steps.

00:29:01.730 --> 00:29:08.280
So first of all, if b is 1, you
can just check that directly.

00:29:08.280 --> 00:29:12.420
And now, again, we're
operating deterministically

00:29:12.420 --> 00:29:15.430
to simulate the
non-deterministic machine.

00:29:15.430 --> 00:29:17.760
So this is the
deterministic machine m.

00:29:17.760 --> 00:29:21.637
So m can easily, if it's
given two configurations of n

00:29:21.637 --> 00:29:23.220
and says, can I get
from the first one

00:29:23.220 --> 00:29:24.940
to the second one in one step?

00:29:24.940 --> 00:29:26.280
Well, that's an easy check.

00:29:26.280 --> 00:29:28.620
You just lay out those
two configurations,

00:29:28.620 --> 00:29:31.170
look at the n's transition
function, and say

00:29:31.170 --> 00:29:32.790
is this a legal move for n?

00:29:37.140 --> 00:29:37.800
Yes or no?

00:29:37.800 --> 00:29:40.700
And you accept or
reject accordingly.

00:29:40.700 --> 00:29:44.910
Now, if b is larger
than 1, you're

00:29:44.910 --> 00:29:52.340
going to try all possible
intermediate configurations,

00:29:52.340 --> 00:29:53.350
calling them c mid.

00:29:53.350 --> 00:29:57.400
This was like the w from
the previous theorem.

00:29:57.400 --> 00:30:00.130
This is all possible strings c--

00:30:00.130 --> 00:30:02.840
all possible
configurations c mid.

00:30:02.840 --> 00:30:06.170
And a configuration is
just going to be a--

00:30:11.370 --> 00:30:12.780
so far so-- OK.

00:30:12.780 --> 00:30:15.180
This is all possible.

00:30:15.180 --> 00:30:19.650
Looked like my PowerPoint
crashed, but it seems OK.

00:30:19.650 --> 00:30:21.970
This is all possible
configurations,

00:30:21.970 --> 00:30:24.420
which is just a string
with a string of tape

00:30:24.420 --> 00:30:26.610
symbols with a state
symbol appearing somewhere.

00:30:26.610 --> 00:30:28.420
That's all it is.

00:30:28.420 --> 00:30:34.720
Going to try all possible
configurations as candidate

00:30:34.720 --> 00:30:35.950
middle configurations.

00:30:35.950 --> 00:30:39.820
And say can I get from the upper
one to this candidate middle

00:30:39.820 --> 00:30:42.950
one and from that middle one
to the lower one within half

00:30:42.950 --> 00:30:44.200
the number of steps each time.

00:30:47.420 --> 00:30:49.336
And solving that
problem recursively.

00:30:56.320 --> 00:30:58.510
So I got a question here
about the possibility

00:30:58.510 --> 00:31:00.220
of looping forever.

00:31:03.310 --> 00:31:06.640
First of all, if n is
going to be looping,

00:31:06.640 --> 00:31:11.950
I don't have to worry about
it, because I'm starting off,

00:31:11.950 --> 00:31:16.360
I only need to simulate
machines that are deciders.

00:31:16.360 --> 00:31:18.730
Because I'm trying to show
that any language in here

00:31:18.730 --> 00:31:22.660
has to be accepted,
has to be decided

00:31:22.660 --> 00:31:25.823
by some non-deterministic
machine.

00:31:25.823 --> 00:31:28.240
So I'm not going to worry about
machines that are looping.

00:31:28.240 --> 00:31:33.820
If they're looping, m may
misbehave in some way,

00:31:33.820 --> 00:31:36.230
but that's not going
to be a problem for me.

00:31:36.230 --> 00:31:38.620
So let's keep life simple.

00:31:38.620 --> 00:31:41.350
Think about the deciders only.

00:31:44.800 --> 00:31:46.910
So we're going to
recursively test here.

00:31:46.910 --> 00:31:50.650
So that means I'm going to
try every possible middle,

00:31:50.650 --> 00:31:53.980
see if I can get from the start
to the middle and the middle

00:31:53.980 --> 00:31:56.500
to the end.

00:31:56.500 --> 00:32:02.110
If both of them work after
I test them recursively,

00:32:02.110 --> 00:32:03.280
then I'm going to accept.

00:32:03.280 --> 00:32:05.140
If not, I'm going to continue.

00:32:05.140 --> 00:32:08.410
And I reject if I try them all
and none of them have worked.

00:32:08.410 --> 00:32:12.310
Then I know there's no way for
n to get from this configuration

00:32:12.310 --> 00:32:14.500
to that configuration
in b steps.

00:32:18.580 --> 00:32:21.880
And the overall picture, I
test whether n accepts w,

00:32:21.880 --> 00:32:25.450
as I mentioned, by
starting with ci

00:32:25.450 --> 00:32:31.190
is the start configuration and
cj is the accept configuration.

00:32:31.190 --> 00:32:33.010
And now how big is t?

00:32:33.010 --> 00:32:38.560
Because I need to calculate
a bound on how deep

00:32:38.560 --> 00:32:41.950
the recursions are going to be.

00:32:41.950 --> 00:32:46.480
So t here is going to
be the total number

00:32:46.480 --> 00:32:48.940
of possible configurations.

00:32:48.940 --> 00:32:51.790
If this is the whole thing, it
never repeats a configuration.

00:32:51.790 --> 00:32:55.160
So this is going to be a
bound on how many steps

00:32:55.160 --> 00:32:56.650
then can be taken.

00:32:56.650 --> 00:33:00.220
And that's simply we
calculated this before.

00:33:00.220 --> 00:33:04.780
It's the number of
states times the number

00:33:04.780 --> 00:33:08.830
of head positions times the
number of tape contents.

00:33:08.830 --> 00:33:12.160
And this is really going to
be the dominant consideration

00:33:12.160 --> 00:33:13.040
anyway.

00:33:13.040 --> 00:33:17.595
And so now each recursive
level, and maybe I

00:33:17.595 --> 00:33:19.470
should have emphasized
this at the beginning,

00:33:19.470 --> 00:33:20.970
how wide is this picture?

00:33:20.970 --> 00:33:23.535
It's big enough to
store a configuration.

00:33:23.535 --> 00:33:27.360
A configuration is
essentially a tape contents.

00:33:27.360 --> 00:33:30.890
So that's going
to be f of n wide.

00:33:30.890 --> 00:33:34.360
So each recursive level
stores one configuration.

00:33:34.360 --> 00:33:39.490
Now the w costs f of
n space to write down.

00:33:39.490 --> 00:33:41.500
And the number of
levels is going

00:33:41.500 --> 00:33:45.640
to be the log of the initial
height, which is this.

00:33:45.640 --> 00:33:50.270
So this is going to be
the dominating part of it.

00:33:50.270 --> 00:33:53.710
So the log of this is going
to be, again, order f of n.

00:33:53.710 --> 00:33:56.830
So each one takes f of
n space to write down.

00:33:56.830 --> 00:33:59.920
The depth of the recursion
is going to be order f of n.

00:33:59.920 --> 00:34:02.470
So the total is going to
be order f squared of n,

00:34:02.470 --> 00:34:05.370
and that's how much
space this uses.

00:34:05.370 --> 00:34:09.000
And that's the proof
of Savitch's theorem.

00:34:09.000 --> 00:34:13.170
So yeah, so this is
a good point there.

00:34:13.170 --> 00:34:15.210
Somebody asks can
there be multiple

00:34:15.210 --> 00:34:17.250
accepting configurations.

00:34:17.250 --> 00:34:19.800
I should have made the--

00:34:19.800 --> 00:34:22.739
I forgot to say this and
I was just realizing it

00:34:22.739 --> 00:34:24.570
as I was explaining it.

00:34:24.570 --> 00:34:26.639
One of the things
I should have--

00:34:26.639 --> 00:34:30.090
you can enforce that there
is just a single accepting

00:34:30.090 --> 00:34:31.500
configuration.

00:34:31.500 --> 00:34:33.810
This is kind of a
detail, so don't worry

00:34:33.810 --> 00:34:37.260
about it if you don't want to.

00:34:37.260 --> 00:34:40.199
But you can make sure that
there's a single accepting

00:34:40.199 --> 00:34:44.130
configuration by telling
the machine when it accepts,

00:34:44.130 --> 00:34:47.040
it should erase its
tape and move its head

00:34:47.040 --> 00:34:50.110
into the left most cell in
the accept configuration.

00:34:50.110 --> 00:34:52.830
So there's just going to be a
single accepting configuration

00:34:52.830 --> 00:34:57.618
to worry about instead of having
to try multiple possibilities,

00:34:57.618 --> 00:34:59.160
which you could do
in this algorithm,

00:34:59.160 --> 00:35:00.960
but it would just
be annoying to have

00:35:00.960 --> 00:35:02.160
to write that down that way.

00:35:02.160 --> 00:35:04.140
So we often assume
there's just going

00:35:04.140 --> 00:35:05.883
to be a single
accepting configuration

00:35:05.883 --> 00:35:06.675
for these machines.

00:35:14.310 --> 00:35:17.580
How do you know f of n?

00:35:17.580 --> 00:35:22.840
So that's actually a little
bit of a delicate issue.

00:35:22.840 --> 00:35:25.980
I mean, if you could
compute f of n,

00:35:25.980 --> 00:35:28.470
the bound, which is,
for example, if it's

00:35:28.470 --> 00:35:31.680
going to be a polynomial bound,
you can just compute f of n.

00:35:31.680 --> 00:35:35.160
It's very easy to compute
n squared or n cubed.

00:35:35.160 --> 00:35:42.210
And so you can just
compute that and then use

00:35:42.210 --> 00:35:45.750
that as the size
of the registers

00:35:45.750 --> 00:35:48.720
you're going to be writing down.

00:35:48.720 --> 00:35:51.330
If you want to prove this
in general for f of n,

00:35:51.330 --> 00:35:54.270
it's a little bit technical
to have to deal with it.

00:35:54.270 --> 00:35:56.910
And I'm going to have to refer
you to the book on that one.

00:35:56.910 --> 00:35:59.820
The book tells you how solve
this for a general f of n.

00:35:59.820 --> 00:36:04.950
You basically have to try
every possible value from one

00:36:04.950 --> 00:36:07.000
until it works.

00:36:07.000 --> 00:36:14.310
And I'm afraid that's
going to derail

00:36:14.310 --> 00:36:16.680
us trying to decipher that.

00:36:16.680 --> 00:36:19.260
So let's not worry
about that aspect of it.

00:36:19.260 --> 00:36:23.082
But you can handle
general f of n here.

00:36:23.082 --> 00:36:25.040
You don't need to put
any conditions on f of n.

00:36:28.850 --> 00:36:32.640
Can we go over this term here?

00:36:32.640 --> 00:36:35.180
So we've seen this
term once before when

00:36:35.180 --> 00:36:40.850
we talked about LBAs and
seeing that LBAs always--

00:36:40.850 --> 00:36:42.920
we can solve the ALBA problem.

00:36:42.920 --> 00:36:45.470
This is simply the number
of different configurations

00:36:45.470 --> 00:36:48.140
the machine can have.

00:36:48.140 --> 00:36:50.390
Because the
configuration is a state.

00:36:50.390 --> 00:36:53.270
It's a head position and
a contents of the tape.

00:36:53.270 --> 00:36:56.330
And this is the number
of each of those

00:36:56.330 --> 00:36:58.280
that you can possibly have.

00:36:58.280 --> 00:37:00.380
Number of states.

00:37:00.380 --> 00:37:05.350
A head position, the size of
the tape of f of n is f of n.

00:37:05.350 --> 00:37:07.850
So this is that many
different head positions.

00:37:07.850 --> 00:37:09.550
And this is the number--

00:37:09.550 --> 00:37:12.220
if d is the size of
the tape alphabet,

00:37:12.220 --> 00:37:15.340
this is the number of tape
contents that you can have.

00:37:21.450 --> 00:37:24.690
How is seeing if n accepts
w with this algorithm

00:37:24.690 --> 00:37:26.490
convert a
non-deterministic Turing

00:37:26.490 --> 00:37:28.650
machine to some
deterministic Turing machine?

00:37:28.650 --> 00:37:31.560
Well, n is the
non-deterministic Turing.

00:37:31.560 --> 00:37:35.550
So n is we're converting
non-deterministic Turing

00:37:35.550 --> 00:37:40.050
machine n to deterministic
Turing machine m.

00:37:40.050 --> 00:37:42.930
So m is a deterministic
simulator of n.

00:37:42.930 --> 00:37:45.260
That's what this whole m is.

00:37:45.260 --> 00:37:51.020
So if we can do this for any n,
then we've proved our theorem.

00:37:55.590 --> 00:37:58.018
Why don't we defer.

00:37:58.018 --> 00:38:00.060
I think I got through most
of the questions here.

00:38:00.060 --> 00:38:01.920
If there's other
things, we can save them

00:38:01.920 --> 00:38:06.180
for the coffee break,
which is coming soon.

00:38:06.180 --> 00:38:10.050
I think we have one
more slide before that.

00:38:10.050 --> 00:38:12.640
So I'm going to define
PSPACE completeness I think.

00:38:12.640 --> 00:38:13.140
Yeah.

00:38:13.140 --> 00:38:18.010
And then I think after
that we have the break.

00:38:18.010 --> 00:38:25.040
So PSPACE completeness is
defined and very much inspired

00:38:25.040 --> 00:38:28.680
similarly to NP completeness.

00:38:28.680 --> 00:38:33.980
So a problem is PSPACE
complete if it's in NPSPACE

00:38:33.980 --> 00:38:38.420
and every other member of
PSPACE is reducible to it

00:38:38.420 --> 00:38:40.510
in polynomial time.

00:38:40.510 --> 00:38:44.530
And we'll say a bit about
why we choose polynomial time

00:38:44.530 --> 00:38:46.970
reducibility here.

00:38:46.970 --> 00:38:50.850
So here's kind of a
picture of how PSPACE--

00:38:50.850 --> 00:38:59.940
how complete problems relate
to their complexity classes.

00:38:59.940 --> 00:39:03.990
So you kind of think of a
complete problem for a class.

00:39:03.990 --> 00:39:06.420
It's kind of the hardest
problem in that class

00:39:06.420 --> 00:39:08.640
because you can convert.

00:39:08.640 --> 00:39:11.430
You can reduce any other
problem in that class

00:39:11.430 --> 00:39:13.060
to the complete problem.

00:39:13.060 --> 00:39:15.540
So here are the NP
complete problems.

00:39:15.540 --> 00:39:17.260
Sort of the hardest for NP.

00:39:17.260 --> 00:39:19.260
You have the PSPACE
complete problems,

00:39:19.260 --> 00:39:23.190
kind of the hardest for PSPACE.

00:39:23.190 --> 00:39:26.760
If an NP complete
problem goes into P,

00:39:26.760 --> 00:39:30.600
that pulls down all of NP to P.
If any PSPACE complete problem

00:39:30.600 --> 00:39:33.180
goes into P, it pulls
down all the PSPACE into P

00:39:33.180 --> 00:39:35.970
by following the
chain of reductions,

00:39:35.970 --> 00:39:38.070
because any PSPACE
problem is reducible

00:39:38.070 --> 00:39:39.400
to the complete problem.

00:39:39.400 --> 00:39:42.900
Which in turn if it's in P,
then everything goes into P.

00:39:42.900 --> 00:39:47.600
So if you have a PSPACE
complete problem which is in P,

00:39:47.600 --> 00:39:51.620
then all the PSPACE goes into P.

00:39:51.620 --> 00:39:57.290
So why do we use polynomial time
reducibility instead of, say,

00:39:57.290 --> 00:40:03.530
polynomial space reducibility
when we define this notion?

00:40:03.530 --> 00:40:06.030
It's kind of a very
reasonable question.

00:40:06.030 --> 00:40:09.350
But if you think about it, using
polynomial space reducibility

00:40:09.350 --> 00:40:10.550
would be a terrible idea.

00:40:14.260 --> 00:40:17.920
And we've seen this
phenomenon happen before.

00:40:17.920 --> 00:40:21.430
Every two problems
in PSPACE are going

00:40:21.430 --> 00:40:23.303
to be PSPACE reducible
to one another.

00:40:23.303 --> 00:40:24.970
We haven't even defined
that notion yet,

00:40:24.970 --> 00:40:26.980
but you can imagine
what it would be.

00:40:26.980 --> 00:40:32.080
Because a PSPACE reduction
can solve the problem

00:40:32.080 --> 00:40:34.390
for a problem in PSPACE.

00:40:34.390 --> 00:40:38.050
And then it can direct its
answer anywhere that it likes.

00:40:38.050 --> 00:40:42.070
So in general, when we
think about reductions,

00:40:42.070 --> 00:40:46.330
the reduction should be not
capable of solving the problems

00:40:46.330 --> 00:40:47.230
in the class.

00:40:47.230 --> 00:40:51.940
Because if they could, then
every two problems in the class

00:40:51.940 --> 00:40:53.913
would be reducible
to one another.

00:40:53.913 --> 00:40:55.330
And then all
problems in the class

00:40:55.330 --> 00:40:57.890
would be complete, because
everything in the class

00:40:57.890 --> 00:41:00.800
would be reducible to any
one of the other problems.

00:41:00.800 --> 00:41:02.590
So it would not be an
interesting notion.

00:41:02.590 --> 00:41:06.760
What you want to have happen
is that the reductions

00:41:06.760 --> 00:41:10.375
should be weaker than
the power of the class.

00:41:17.690 --> 00:41:20.240
And if you look
at the reductions

00:41:20.240 --> 00:41:23.720
that we've defined so far,
they're actually very simple.

00:41:23.720 --> 00:41:25.880
The only thing is they
have to make sure that they

00:41:25.880 --> 00:41:29.780
can make the output big enough.

00:41:29.780 --> 00:41:31.430
But actually
constructing the output,

00:41:31.430 --> 00:41:33.500
they're very simple
transformations.

00:41:33.500 --> 00:41:36.590
In fact, even polynomial time
is more than you typically need.

00:41:36.590 --> 00:41:38.750
There's even much
more limited classes

00:41:38.750 --> 00:41:42.450
that are capable of doing
the reductions, as we'll see.

00:41:42.450 --> 00:41:44.450
So having powerful
reductions is really

00:41:44.450 --> 00:41:47.270
not in the spirit of what
reductions are all about.

00:41:47.270 --> 00:41:51.980
You want very, very
simple transformations

00:41:51.980 --> 00:41:53.210
to be the reductions.

00:41:53.210 --> 00:41:55.400
Anyway, I hope that's helpful.

00:41:55.400 --> 00:41:58.100
So what we're going to be
aiming for in the second part

00:41:58.100 --> 00:42:03.200
of the lecture is showing
that TQBF is PSPACE complete.

00:42:03.200 --> 00:42:05.630
And let me-- here
is the check in.

00:42:10.020 --> 00:42:12.560
So this is our first
check in, coming

00:42:12.560 --> 00:42:14.040
a little late in the lecture.

00:42:14.040 --> 00:42:17.690
Suppose we have proven
that, as we will,

00:42:17.690 --> 00:42:21.130
that TQBF is PSPACE complete.

00:42:21.130 --> 00:42:26.290
What can we conclude if TQBF is
actually not necessarily in P,

00:42:26.290 --> 00:42:28.852
only goes to NP?

00:42:28.852 --> 00:42:30.560
And this is relevant
to a question that's

00:42:30.560 --> 00:42:33.810
coming in from the chat,
but I'll answer that later.

00:42:33.810 --> 00:42:38.390
So suppose TQBF
ends up being an NP

00:42:38.390 --> 00:42:40.940
and not in P. What
can we conclude?

00:42:40.940 --> 00:42:46.400
Remember, if TQBF
is in P, then PSPACE

00:42:46.400 --> 00:42:51.870
equals P. Suppose it goes to NP.

00:42:51.870 --> 00:42:54.700
What happens then?

00:42:54.700 --> 00:42:57.370
There may be several
correct answers here.

00:43:00.050 --> 00:43:01.910
Check all that apply.

00:43:05.270 --> 00:43:11.930
All right, so we're near
the end of the poll.

00:43:11.930 --> 00:43:14.348
So let me give you
another 10 seconds

00:43:14.348 --> 00:43:15.890
and then we're going
to shut it down.

00:43:20.510 --> 00:43:23.420
OK, are we all in?

00:43:23.420 --> 00:43:24.200
Closing it down.

00:43:27.520 --> 00:43:28.490
Here are the results.

00:43:28.490 --> 00:43:33.910
So yes, so first of all, the
most reasonable solution,

00:43:33.910 --> 00:43:38.740
most reasonable answer is
b, which I think most of you

00:43:38.740 --> 00:43:39.700
have gotten.

00:43:39.700 --> 00:43:45.250
That if a PSPACE complete
problem goes down to NP,

00:43:45.250 --> 00:43:48.790
well, NP is capable of
simulating the polynomial time

00:43:48.790 --> 00:43:50.380
reduction.

00:43:50.380 --> 00:43:55.210
And so any other
problem in PSPACE

00:43:55.210 --> 00:43:56.710
would then also be in NP.

00:43:56.710 --> 00:43:58.540
And PSPACE would equal NP.

00:43:58.540 --> 00:44:02.050
But note if PSPACE
equals NP, they're

00:44:02.050 --> 00:44:08.800
also NP equals coNP,
because PSPACE itself is

00:44:08.800 --> 00:44:11.300
closed under complementation.

00:44:11.300 --> 00:44:14.890
So that was kind of a
little bit extra fact

00:44:14.890 --> 00:44:17.960
that you could conclude
from this as well.

00:44:17.960 --> 00:44:22.420
So let's move on then
to our coffee break,

00:44:22.420 --> 00:44:28.180
and we'll pick up the proof
that TQBF is PSPACE complete

00:44:28.180 --> 00:44:29.200
after that.

00:44:43.860 --> 00:44:47.070
So was d true or not?

00:44:47.070 --> 00:44:48.660
D was P equal NP.

00:44:48.660 --> 00:44:57.930
No, we cannot conclude that
P equals NP from PSPACE equal

00:44:57.930 --> 00:45:00.480
to NP.

00:45:00.480 --> 00:45:05.190
So if TQBF is in NP, it
doesn't tell us anything.

00:45:05.190 --> 00:45:06.570
For all we know, P equals NP.

00:45:06.570 --> 00:45:11.710
But from the stuff
that we know so far,

00:45:11.710 --> 00:45:13.410
we cannot conclude
that P equals NP.

00:45:17.630 --> 00:45:21.350
Oh, and yeah, so you can
conclude-- oh, I'm sorry.

00:45:21.350 --> 00:45:25.190
B and d are both correct here.

00:45:27.800 --> 00:45:29.810
Let me just shut this thing off.

00:45:32.950 --> 00:45:34.330
So b and d are correct.

00:45:34.330 --> 00:45:37.750
So if a PSPACE complete
problem goes to NP,

00:45:37.750 --> 00:45:41.740
then NP equals
PSPACE, N equals coNP.

00:45:41.740 --> 00:45:44.810
So the correct answer, b and d.

00:45:44.810 --> 00:45:45.310
Sorry.

00:45:45.310 --> 00:45:47.380
I got myself confused.

00:45:47.380 --> 00:45:50.470
But c is not something
you can conclude or a.

00:45:55.640 --> 00:46:00.950
So somebody is asking
me a fair question.

00:46:00.950 --> 00:46:03.860
I say the reduction
method should be weaker

00:46:03.860 --> 00:46:07.400
than the class.

00:46:07.400 --> 00:46:10.430
But for example, even
in the case of PSPACE,

00:46:10.430 --> 00:46:14.030
PSPACE might be
equal to P. And then

00:46:14.030 --> 00:46:16.370
it wouldn't be
weaker than the class

00:46:16.370 --> 00:46:18.500
if we use polynomial
time reductions.

00:46:18.500 --> 00:46:22.880
But I think maybe I should
say apparently weaker.

00:46:22.880 --> 00:46:24.620
As far as we know, it's weaker.

00:46:24.620 --> 00:46:27.650
But we believe it to be weaker.

00:46:27.650 --> 00:46:32.060
It's true if P equals PSPACE,
then every problem in P

00:46:32.060 --> 00:46:34.010
is going to be PSPACE complete.

00:46:34.010 --> 00:46:36.740
It's just going to be a weird
world if P equals PSPACE.

00:46:36.740 --> 00:46:40.020
Same thing for NP and NP.

00:46:40.020 --> 00:46:42.060
So I'm getting a
number of questions

00:46:42.060 --> 00:46:45.330
also about other
possible reducibilities

00:46:45.330 --> 00:46:50.150
that are even weaker than
polynomial time reducibility.

00:46:50.150 --> 00:46:55.790
So we're going to see
very soon weaker reduce--

00:46:55.790 --> 00:46:59.630
complexity classes within
P. So first of all, PSPACE

00:46:59.630 --> 00:47:01.610
seems to be bigger
than P. We're also

00:47:01.610 --> 00:47:03.650
going to look at log space.

00:47:03.650 --> 00:47:07.100
But that's going to be
actually in Thursday's lecture.

00:47:07.100 --> 00:47:11.870
These are classes that
seem to be inside.

00:47:11.870 --> 00:47:14.120
Well, they're
inside P. We believe

00:47:14.120 --> 00:47:16.880
they're properly inside P.
But we'll see that later.

00:47:20.900 --> 00:47:22.270
Let me just see here.

00:47:25.290 --> 00:47:28.110
So we're almost out of time.

00:47:28.110 --> 00:47:30.580
Let me put our timer back.

00:47:30.580 --> 00:47:33.100
In fact, our timer is
showing us out of time.

00:47:33.100 --> 00:47:39.300
So why don't we get going?

00:47:39.300 --> 00:47:43.970
Let me move this back to--

00:47:46.830 --> 00:47:48.000
OK.

00:47:48.000 --> 00:47:48.780
Continuing.

00:47:51.300 --> 00:47:52.680
TQBF is PSPACE complete.

00:47:52.680 --> 00:47:54.240
So first of all,
let's remember TQBF.

00:47:58.330 --> 00:48:03.230
These are all of the quantified
Boolean formulas that are true.

00:48:03.230 --> 00:48:08.005
So TQBF stands for True
Quantified Boolean Formulas.

00:48:11.800 --> 00:48:13.940
And remember, we
saw these examples

00:48:13.940 --> 00:48:22.430
from the previous lecture that
these are two quantified--

00:48:22.430 --> 00:48:24.620
these are two QBFs.

00:48:24.620 --> 00:48:25.600
The first one is true.

00:48:25.600 --> 00:48:26.600
The second one is false.

00:48:26.600 --> 00:48:29.150
And it's going to be
interesting to think about.

00:48:29.150 --> 00:48:31.460
Here they're exactly
the same except

00:48:31.460 --> 00:48:33.840
for the order of
the quantifiers.

00:48:33.840 --> 00:48:37.770
And so what's really
going on here?

00:48:37.770 --> 00:48:41.550
I think it's good to
understand these expressions.

00:48:41.550 --> 00:48:47.610
They come up everywhere in
mathematics, these quantifiers.

00:48:47.610 --> 00:48:51.790
In the upper one, when
we say for every x,

00:48:51.790 --> 00:48:57.690
there exists a y, that y can
depend on the choice of x.

00:48:57.690 --> 00:48:59.640
You choose to make
a different x.

00:48:59.640 --> 00:49:02.220
You're allowed to
pick a different y.

00:49:02.220 --> 00:49:06.810
But the lower expression
says there's a universal y.

00:49:06.810 --> 00:49:12.080
There's one particular y
that works for every x.

00:49:12.080 --> 00:49:15.620
So in a sense, the
lower statement

00:49:15.620 --> 00:49:19.130
is a stronger statement.

00:49:19.130 --> 00:49:23.690
Whatever you have in the
quantifier free part.

00:49:23.690 --> 00:49:25.850
So the lower one
implies the upper one.

00:49:25.850 --> 00:49:28.310
Happens that the lower
one in this case is false

00:49:28.310 --> 00:49:29.540
and the upper one is true.

00:49:29.540 --> 00:49:34.070
But in general, when
you have this change

00:49:34.070 --> 00:49:38.510
of quantifiers like
this, the lower one

00:49:38.510 --> 00:49:40.850
would imply the upper one.

00:49:40.850 --> 00:49:42.530
Anyway, that's sort
of a side remark.

00:49:42.530 --> 00:49:47.000
So let's get back to the proof
that TQBF is PSPACE complete.

00:49:47.000 --> 00:49:50.600
That's what our goal is.

00:49:50.600 --> 00:49:52.100
All right.

00:49:52.100 --> 00:49:55.660
Now, as I mentioned,
this is the same proof.

00:49:55.660 --> 00:49:58.250
You're going to be seeing
it for the third time today.

00:49:58.250 --> 00:50:04.780
But there's a certain amount
of-- it's sort of the context

00:50:04.780 --> 00:50:08.210
changes in each case.

00:50:08.210 --> 00:50:11.930
So now we want to show that
TQBF is PSPACE complete.

00:50:11.930 --> 00:50:14.620
So it's one of these
hardest problems

00:50:14.620 --> 00:50:20.060
now but for PSPACE,
where satisfiability

00:50:20.060 --> 00:50:22.325
was the hardest problem for NP.

00:50:25.580 --> 00:50:30.590
So we want to show that
every language in PSPACE

00:50:30.590 --> 00:50:32.390
is reducible to TQBF.

00:50:35.660 --> 00:50:39.280
And so we're going to give
polynomial time reductions

00:50:39.280 --> 00:50:44.030
that map some particular problem
a, which can be done in space n

00:50:44.030 --> 00:50:44.530
to the k.

00:50:44.530 --> 00:50:48.440
It's a problem
solvable in PSPACE.

00:50:48.440 --> 00:50:53.120
We're going to show
how f maps a to TQBF.

00:50:53.120 --> 00:50:56.300
We have to construct the f.

00:50:56.300 --> 00:50:59.840
So f is going to be a
mapping that map strings

00:50:59.840 --> 00:51:01.580
which may or may not be in a.

00:51:01.580 --> 00:51:08.270
So strings w, which may or may
not be in a, to these formulas,

00:51:08.270 --> 00:51:11.430
these quantified formulas.

00:51:11.430 --> 00:51:17.540
So w is going to get mapped
to some formula phi sub mw.

00:51:17.540 --> 00:51:20.240
It had exactly the
same even symbols

00:51:20.240 --> 00:51:23.600
we used when the proof of
the Cook-Levin theorem about

00:51:23.600 --> 00:51:25.340
SAT being NP complete.

00:51:25.340 --> 00:51:29.300
This is a very similar proof.

00:51:29.300 --> 00:51:32.922
But you'll see that we have
to do something more in order

00:51:32.922 --> 00:51:34.130
to make it work in this case.

00:51:37.270 --> 00:51:43.890
So w is in a if and only if this
formula is going to be in TQBF.

00:51:43.890 --> 00:51:46.740
In other words, if and only
if this formula is true.

00:51:49.840 --> 00:51:54.810
So this formula is going
to kind of express the fact

00:51:54.810 --> 00:51:58.050
that m accepts w,
which means that w

00:51:58.050 --> 00:52:00.330
is in a, because
m is the machine,

00:52:00.330 --> 00:52:04.470
is the PSPACE machine for a.

00:52:04.470 --> 00:52:08.820
So this formula
says m accepts w,

00:52:08.820 --> 00:52:17.870
and it achieves that by building
in a simulation of m on w.

00:52:17.870 --> 00:52:21.260
It kind of describes a
simulation for m on w

00:52:21.260 --> 00:52:23.930
which ends up accepting.

00:52:23.930 --> 00:52:28.760
And if m does not accept
w, that description

00:52:28.760 --> 00:52:31.025
is going to inevitably be false.

00:52:34.710 --> 00:52:39.010
So let's just see what
that's going to look like.

00:52:39.010 --> 00:52:41.010
So we're going to
use the same idea

00:52:41.010 --> 00:52:44.730
that we used for the
Cook-Levin theorem

00:52:44.730 --> 00:52:46.440
that SAT is NP complete.

00:52:46.440 --> 00:52:49.050
This notion of a tableau.

00:52:49.050 --> 00:52:51.270
So if you remember,
it was basically

00:52:51.270 --> 00:52:56.830
a table which was just
simply a way of writing down

00:52:56.830 --> 00:53:01.290
a computation
history for m on w.

00:53:01.290 --> 00:53:06.060
So the rows are the
steps of the machine.

00:53:06.060 --> 00:53:08.640
The top row is the
start configuration.

00:53:08.640 --> 00:53:14.150
The bottom row is, let's
say, some particular accept

00:53:14.150 --> 00:53:16.970
configuration such as
I just described where

00:53:16.970 --> 00:53:21.350
the machine clears its tapes and
moves its head to the left end.

00:53:21.350 --> 00:53:23.272
So there's only one
accepting configuration

00:53:23.272 --> 00:53:24.230
we have to worry about.

00:53:27.700 --> 00:53:30.810
And each of the rows here
is a configuration of m.

00:53:37.090 --> 00:53:40.180
Because m runs in
space into the k,

00:53:40.180 --> 00:53:43.630
the tableau kind of similarly
to what I described before

00:53:43.630 --> 00:53:45.670
has width n to the k.

00:53:45.670 --> 00:53:50.570
So now we're talking about
polynomial time machines.

00:53:50.570 --> 00:53:53.920
So the f, which is the
bound, the space bound,

00:53:53.920 --> 00:53:56.500
is going to be some
polynomial n to the k.

00:53:56.500 --> 00:54:00.190
So the width of this
tableau, the size

00:54:00.190 --> 00:54:04.420
of these configurations
are going to be n to the k.

00:54:04.420 --> 00:54:07.700
How high is this
tableau going to be?

00:54:07.700 --> 00:54:11.050
Well, that's going to be
limited by the possible running

00:54:11.050 --> 00:54:19.330
time of the machine, which is
similar to what we saw before.

00:54:19.330 --> 00:54:23.050
It's going to be exponential
in the space bound.

00:54:23.050 --> 00:54:25.530
So it's going to be d
to the n to the k, where

00:54:25.530 --> 00:54:29.100
d is essentially the tape
alphabet of the machine.

00:54:32.230 --> 00:54:36.580
So are we all together on this?

00:54:36.580 --> 00:54:43.660
This is very similar to the
proof of SAT is NP complete.

00:54:43.660 --> 00:54:49.473
The key difference there
was m was non-deterministic,

00:54:49.473 --> 00:54:51.390
which might be something
to think about later.

00:54:51.390 --> 00:54:53.940
But let's not focus
on that right now.

00:54:53.940 --> 00:54:55.380
This m is deterministic.

00:54:58.650 --> 00:55:01.830
But the important difference
was the shape of the tableau.

00:55:01.830 --> 00:55:05.010
The size of the tableau
was very different.

00:55:05.010 --> 00:55:07.590
In the case of SAT
is NP complete,

00:55:07.590 --> 00:55:11.430
we started off with a polynomial
time non-deterministic machine.

00:55:11.430 --> 00:55:14.460
So it only could run for a
polynomial number of steps.

00:55:14.460 --> 00:55:16.320
Here is a polynomial
space machine,

00:55:16.320 --> 00:55:18.810
which can run for an
exponential number of steps.

00:55:18.810 --> 00:55:23.940
That's going to be an
important difference here.

00:55:23.940 --> 00:55:25.020
So let's see why.

00:55:29.320 --> 00:55:36.705
The reduction has to
construct this formula phi

00:55:36.705 --> 00:55:43.990
sub of mw, which basically
says that this tableau exists.

00:55:43.990 --> 00:55:46.180
Now, we already saw
how to do that when

00:55:46.180 --> 00:55:52.060
we proved the Cook-Levin
theorem that SAT is NP complete.

00:55:52.060 --> 00:55:53.620
Remember, we had all of those.

00:55:53.620 --> 00:55:57.100
We had variables for each
cell that told us what

00:55:57.100 --> 00:55:59.410
the contents of that cell was.

00:55:59.410 --> 00:56:01.580
And then we had a
lot of logic here.

00:56:01.580 --> 00:56:03.430
We had a bunch of
logic that said

00:56:03.430 --> 00:56:06.970
that all those
neighborhoods were correct,

00:56:06.970 --> 00:56:10.420
which basically says that
the tableau corresponds

00:56:10.420 --> 00:56:15.550
to a correct computation
of the machine.

00:56:15.550 --> 00:56:17.350
So why don't we just
do the same thing?

00:56:21.100 --> 00:56:24.550
Why don't we just
build our formula

00:56:24.550 --> 00:56:26.800
using exactly the
same process that we

00:56:26.800 --> 00:56:32.860
used to build the formula when
we had SAT being NP complete?

00:56:32.860 --> 00:56:34.450
Something goes wrong.

00:56:34.450 --> 00:56:37.610
We can't quite do that.

00:56:37.610 --> 00:56:41.470
The problem is that if
you remember the formula

00:56:41.470 --> 00:56:46.800
that we built before was really
about as big as the tableau is.

00:56:46.800 --> 00:56:49.830
Because it had some logic
for each one of the cells.

00:56:49.830 --> 00:56:52.140
It had a set of some
of the variables

00:56:52.140 --> 00:56:54.660
for each one of the cells
and it had some logic

00:56:54.660 --> 00:56:56.850
for each of those
neighborhoods, basically.

00:56:56.850 --> 00:57:00.660
So it says that each of the
cells does the right thing.

00:57:03.260 --> 00:57:07.300
So it was a pretty big formula,
but it was still polynomial.

00:57:07.300 --> 00:57:11.980
The problem is that tableau is
now n to the k by d to the n

00:57:11.980 --> 00:57:13.210
to the k.

00:57:13.210 --> 00:57:14.830
That's an exponentially
big object.

00:57:18.230 --> 00:57:21.940
So if your formula is going
to be as big as the tableau,

00:57:21.940 --> 00:57:24.850
there's no way you can hope
to produce that formula

00:57:24.850 --> 00:57:26.080
in polynomial time.

00:57:31.110 --> 00:57:32.660
And that's the problem.

00:57:32.660 --> 00:57:36.062
The formula is
going to be too big.

00:57:36.062 --> 00:57:38.020
Remember, we're trying
to get a polynomial time

00:57:38.020 --> 00:57:42.060
reduction from this language a.

00:57:42.060 --> 00:57:44.790
So we have an input
to a, a string that

00:57:44.790 --> 00:57:48.900
might be an a, which is
simulating the machine.

00:57:48.900 --> 00:57:53.670
And the size of the
tableau relative to w

00:57:53.670 --> 00:57:56.870
is going to be
something enormous.

00:57:56.870 --> 00:57:58.843
And so the formula is
as big as the tableau.

00:57:58.843 --> 00:58:01.260
There's no way to produce that
formula in polynomial time.

00:58:01.260 --> 00:58:05.390
So this is not going to work.

00:58:05.390 --> 00:58:06.770
Let's try again.

00:58:06.770 --> 00:58:07.990
So now we have here--

00:58:11.260 --> 00:58:16.045
now, so remember this notation
from ci to cj in b steps.

00:58:19.750 --> 00:58:25.470
So we're going to give a general
way of constructing formulas

00:58:25.470 --> 00:58:28.920
which express this
fact that I can

00:58:28.920 --> 00:58:35.280
get from configuration i of
m to configuration j of m

00:58:35.280 --> 00:58:37.310
in b steps.

00:58:37.310 --> 00:58:39.830
Whatever that b is. b is
going to be some bound.

00:58:39.830 --> 00:58:42.890
And I want to know can I
get from this configuration

00:58:42.890 --> 00:58:43.940
to that configuration.

00:58:43.940 --> 00:58:46.700
And I want to write that
down as a formula, which

00:58:46.700 --> 00:58:47.990
is going to express that fact.

00:58:47.990 --> 00:58:49.407
And it'll be either
true or false.

00:58:52.340 --> 00:58:56.170
And I'm going to give you
a recursive construction

00:58:56.170 --> 00:58:57.080
for this formula.

00:58:57.080 --> 00:59:01.810
So I'm going to build
that formula for a value

00:59:01.810 --> 00:59:09.390
b out of formulas for
smaller values of b.

00:59:09.390 --> 00:59:11.580
So this is going to be
a way of constructing

00:59:11.580 --> 00:59:14.010
that formula in terms
of other formulas

00:59:14.010 --> 00:59:15.150
that I'm going to build.

00:59:15.150 --> 00:59:17.220
And there's going to be
a basis for the recursion

00:59:17.220 --> 00:59:19.620
when b equals 1.

00:59:19.620 --> 00:59:20.900
So that's the big picture.

00:59:20.900 --> 00:59:23.050
So let's see how does
this formula look.

00:59:27.110 --> 00:59:31.100
So let's not worry about the
case for b equal 1 right now.

00:59:31.100 --> 00:59:35.500
This is the case for
larger values of b.

00:59:35.500 --> 00:59:42.080
So the fact that I can get
from ci to cj within b steps.

00:59:42.080 --> 00:59:45.600
I'm going to write
this down in this way.

00:59:45.600 --> 00:59:52.400
And let's try to unpack that
and see what it's saying.

00:59:56.050 --> 01:00:00.340
Without worrying about how are
we going to carry this out,

01:00:00.340 --> 01:00:02.830
let's just try to understand
at a high level of semantics

01:00:02.830 --> 01:00:05.890
of this thing what it's
trying to say to you.

01:00:05.890 --> 01:00:10.880
It's going to say, well, I can
get from ci to cj in b steps.

01:00:10.880 --> 01:00:14.750
So m can get from
ci to cj in b steps.

01:00:14.750 --> 01:00:18.020
If there is some
other configuration c

01:00:18.020 --> 01:00:20.860
mid, some other
configuration, I'm

01:00:20.860 --> 01:00:27.100
calling it c mid, very much
inspired by the previous proof

01:00:27.100 --> 01:00:28.790
of Savitch's
theorem, where there

01:00:28.790 --> 01:00:31.430
was c mid was that
intermediate configuration.

01:00:31.430 --> 01:00:33.730
So now instead of trying
them all, I'm saying

01:00:33.730 --> 01:00:37.500
does there exist one
where I can get from ci

01:00:37.500 --> 01:00:39.480
to c mid in half
the number of steps

01:00:39.480 --> 01:00:42.120
and from c mid to cj in
half the number of steps?

01:00:45.220 --> 01:00:50.100
So if I can build
these two formulas,

01:00:50.100 --> 01:00:53.520
then I can combine them with
this sort of extra stuff

01:00:53.520 --> 01:00:57.520
out here, and them together,
and put an exist quantifier

01:00:57.520 --> 01:01:00.810
that says, does there exist
some configuration, some way

01:01:00.810 --> 01:01:05.460
to find a configuration
such that it works

01:01:05.460 --> 01:01:08.410
as these formulas require?

01:01:08.410 --> 01:01:10.930
If I can do that, then
I'm going to be good.

01:01:10.930 --> 01:01:13.810
Because then I can--

01:01:13.810 --> 01:01:14.667
well, good.

01:01:14.667 --> 01:01:16.750
At least I'll be good in
terms of making something

01:01:16.750 --> 01:01:19.160
that is going to work.

01:01:19.160 --> 01:01:21.280
So first of all,
let's understand

01:01:21.280 --> 01:01:24.610
what I mean by writing down
does there exist c mid.

01:01:24.610 --> 01:01:28.680
It's really if
you're thinking back

01:01:28.680 --> 01:01:30.780
to the way we did the
Cook-Levin theorem,

01:01:30.780 --> 01:01:33.750
we represented
these configurations

01:01:33.750 --> 01:01:38.040
by variables which were
indicator variables for each

01:01:38.040 --> 01:01:38.845
of the cells.

01:01:38.845 --> 01:01:40.720
And we're going to do
exactly the same thing.

01:01:40.720 --> 01:01:42.845
So we're going to have a
bunch of Boolean variables

01:01:42.845 --> 01:01:47.810
which are going to represent
some configuration.

01:01:47.810 --> 01:01:53.000
So more formally, or
in more detail, what

01:01:53.000 --> 01:01:54.680
this does, there
exists a c mid, really

01:01:54.680 --> 01:01:58.490
is an assignment to all
of those variables that

01:01:58.490 --> 01:02:06.080
represent the contents of the
cells of that configuration.

01:02:06.080 --> 01:02:10.670
OK, so now let's see how to--

01:02:10.670 --> 01:02:12.440
how will the recursion work?

01:02:12.440 --> 01:02:17.300
So to get this value
here, I'm going

01:02:17.300 --> 01:02:19.640
to do the recursion further.

01:02:19.640 --> 01:02:21.680
So does there exist a c mid?

01:02:21.680 --> 01:02:26.870
And now for getting
from ci to this c mid,

01:02:26.870 --> 01:02:28.310
is there some other c mid?

01:02:28.310 --> 01:02:32.212
This is like another value of
w from the previous slide where

01:02:32.212 --> 01:02:34.670
I'm getting, again, I'm cutting
the number of steps in half

01:02:34.670 --> 01:02:35.170
again.

01:02:35.170 --> 01:02:38.480
So going from b over 2
steps to b over 4 steps.

01:02:38.480 --> 01:02:42.580
And I'm going to do the
same thing over here.

01:02:42.580 --> 01:02:49.920
So I'm just unraveling
the construction

01:02:49.920 --> 01:02:54.390
of this formula in
terms of building--

01:02:54.390 --> 01:02:55.860
by building it up recursively.

01:02:59.820 --> 01:03:03.450
And then I'm just going to keep
doing that until I get down

01:03:03.450 --> 01:03:05.010
to the case where b equals 1.

01:03:07.760 --> 01:03:12.410
And if I'm now trying to make
a formula that's going to be,

01:03:12.410 --> 01:03:17.030
say I can get from ci to
cj in just a single step.

01:03:17.030 --> 01:03:19.510
So this is really
talking about a tableau

01:03:19.510 --> 01:03:22.180
of height 1 or height 2.

01:03:22.180 --> 01:03:26.110
Then I can just directly
write that down the way

01:03:26.110 --> 01:03:27.830
I-- now the tableau
is not very big.

01:03:27.830 --> 01:03:30.430
So now I can write that
down using the neighborhoods

01:03:30.430 --> 01:03:33.520
and so on that I did in the
Cook-Levin theorem proof.

01:03:36.933 --> 01:03:38.600
And this is how you
put it all together.

01:03:42.200 --> 01:03:49.400
And now if you want to
talk about the getting from

01:03:49.400 --> 01:03:51.860
does m accept w.

01:03:51.860 --> 01:03:54.530
So I initially say, can I get
from the start configuration

01:03:54.530 --> 01:03:57.320
to the accept configuration
in t steps, which

01:03:57.320 --> 01:03:59.130
is the maximum running
time of the machine?

01:03:59.130 --> 01:04:00.110
So again.

01:04:00.110 --> 01:04:03.920
And if you followed me, what
happened in Savitch's theorem,

01:04:03.920 --> 01:04:06.140
it's the same values.

01:04:08.860 --> 01:04:10.630
Now, the thing is we
have to understand

01:04:10.630 --> 01:04:12.490
how big this formula is.

01:04:12.490 --> 01:04:28.950
And if you think it
through, there's a problem.

01:04:28.950 --> 01:04:30.770
Because what's going on here?

01:04:30.770 --> 01:04:34.610
I'm expressing this formula
in terms of formulas

01:04:34.610 --> 01:04:39.410
where the size of
b is cut in half.

01:04:39.410 --> 01:04:41.710
But now there are two of them.

01:04:41.710 --> 01:04:45.180
So it's two formulas
on half the value of b.

01:04:45.180 --> 01:04:47.460
That's not going to
be a recursion that's

01:04:47.460 --> 01:04:49.960
going to work in our favor.

01:04:49.960 --> 01:04:52.030
So let's just see what happens.

01:04:52.030 --> 01:04:59.160
So each recursive level
doubles the number of formulas.

01:04:59.160 --> 01:05:00.990
Here we have two formulas.

01:05:00.990 --> 01:05:05.340
Here we're going to have
four formulas and so on.

01:05:05.340 --> 01:05:08.280
So the number of formulas
doubles each time.

01:05:08.280 --> 01:05:12.080
So the length of the thing
that we're writing down

01:05:12.080 --> 01:05:16.860
is doubling in size each time
we go down the recursion.

01:05:16.860 --> 01:05:19.068
That's going to be OK if we
don't go too many levels.

01:05:19.068 --> 01:05:21.193
But unfortunately, we are
going quite a few levels,

01:05:21.193 --> 01:05:22.760
because the number
of levels is going

01:05:22.760 --> 01:05:27.120
to be log of this initial
exponential size thing.

01:05:27.120 --> 01:05:29.430
So it's going to be
n to the k levels.

01:05:29.430 --> 01:05:31.970
And so if you're doubling
something n to the k times,

01:05:31.970 --> 01:05:36.150
you're going to end up with an
exponentially sized formula.

01:05:36.150 --> 01:05:40.430
And again, we failed.

01:05:43.450 --> 01:05:45.880
OK, so I have a
check in on this.

01:05:45.880 --> 01:05:47.470
But maybe we should
spend a couple

01:05:47.470 --> 01:05:49.900
of minutes just
trying to understand

01:05:49.900 --> 01:05:52.180
what's going on here.

01:05:52.180 --> 01:05:55.030
Because the next slide
is really my last slide,

01:05:55.030 --> 01:05:57.320
and it's going to
fix this problem.

01:05:57.320 --> 01:06:00.700
But let's make sure we
understand what the problem is

01:06:00.700 --> 01:06:02.260
before we try to fix it.

01:06:07.260 --> 01:06:10.350
Why can we no longer write over
each layer of the recursion

01:06:10.350 --> 01:06:11.280
as we did in ladder?

01:06:11.280 --> 01:06:12.840
Oh, that's kind of
a cool question.

01:06:12.840 --> 01:06:20.280
What does it even mean to write
over the different-- well,

01:06:20.280 --> 01:06:23.500
so that's kind of an
interesting question here.

01:06:23.500 --> 01:06:27.070
So in a sense, that's
going to be the solution.

01:06:27.070 --> 01:06:35.020
We're going to reuse
things in a certain way.

01:06:35.020 --> 01:06:42.010
But I want you to understand
that this method itself

01:06:42.010 --> 01:06:45.760
does not work, because
this recursion here where

01:06:45.760 --> 01:06:47.770
I'm writing the
formula, I'm building

01:06:47.770 --> 01:06:51.130
the formula for
b out of formulas

01:06:51.130 --> 01:06:55.000
for smaller values of b.

01:06:55.000 --> 01:06:59.470
If I do it that way,
I'm going to end up--

01:06:59.470 --> 01:07:03.310
if I do it as it's described
in this procedure here,

01:07:03.310 --> 01:07:06.630
I'm going to end up with an
exponentially big formula.

01:07:06.630 --> 01:07:10.110
And that's not good enough.

01:07:10.110 --> 01:07:12.660
So if you cut the formula
in half each time,

01:07:12.660 --> 01:07:14.460
even though you
have two formulas,

01:07:14.460 --> 01:07:15.855
won't the length be the same?

01:07:19.240 --> 01:07:20.740
I'm not cutting the
formula in half.

01:07:20.740 --> 01:07:22.410
I'm cutting the
value of b in half.

01:07:25.150 --> 01:07:26.530
So you have to
say b is initially

01:07:26.530 --> 01:07:29.150
an exponentially big value.

01:07:29.150 --> 01:07:32.810
So we're going to end up with
an exponentially big formula.

01:07:32.810 --> 01:07:35.210
So it's not really cutting
the formula in half.

01:07:35.210 --> 01:07:36.890
Cutting the b in half.

01:07:36.890 --> 01:07:39.320
b starts out big.

01:07:39.320 --> 01:07:43.320
I mean, b is initially
this value here,

01:07:43.320 --> 01:07:44.460
d to the n to the k.

01:07:47.480 --> 01:07:47.990
I'm worried.

01:07:47.990 --> 01:07:49.157
Not too many questions here.

01:07:49.157 --> 01:07:52.715
I have a feeling that's
probably not a good sign.

01:07:57.980 --> 01:08:00.110
Well, I mean, if you're
hopelessly confused,

01:08:00.110 --> 01:08:02.640
maybe I can't fix it quickly.

01:08:02.640 --> 01:08:08.630
So anyway, why don't we move
on and see how to repair this,

01:08:08.630 --> 01:08:09.740
how to fix this problem.

01:08:12.950 --> 01:08:15.530
And that is going
to be by a trick.

01:08:18.490 --> 01:08:21.147
In fact, I know the
people who were involved

01:08:21.147 --> 01:08:22.189
with coming up with this.

01:08:22.189 --> 01:08:27.370
This was actually, this proof
was done originally at MIT

01:08:27.370 --> 01:08:30.160
many years ago in the 1970s.

01:08:30.160 --> 01:08:32.710
And the folks who
were involved with it

01:08:32.710 --> 01:08:34.840
called it the
abbreviation trick.

01:08:34.840 --> 01:08:38.750
So that's what we're going
to do on the next slide.

01:08:38.750 --> 01:08:41.800
Oh no, there's a check in first.

01:08:41.800 --> 01:08:45.370
Why shouldn't we be surprised
that this construction fails?

01:08:49.560 --> 01:08:51.450
A, well, we can't--

01:08:51.450 --> 01:08:55.260
just the notion of defining
a quantified Boolean formula

01:08:55.260 --> 01:09:01.710
by using recursion
is just not allowed.

01:09:01.710 --> 01:09:06.590
So you can't define
formulas that way.

01:09:06.590 --> 01:09:09.319
Doesn't use the for all
quantifier anywhere.

01:09:09.319 --> 01:09:16.790
Or because we know that TQBF is
not in P. You can see we do--

01:09:16.790 --> 01:09:18.470
what do you think?

01:09:18.470 --> 01:09:24.510
Why should we not be surprised?

01:09:24.510 --> 01:09:26.840
I guess I could have
put a d in there.

01:09:26.840 --> 01:09:33.710
Not surprised because you
don't know what's going on.

01:09:33.710 --> 01:09:35.540
That's another reason
not to be surprised.

01:09:35.540 --> 01:09:40.700
But anyway, hopefully
you have some glimmer

01:09:40.700 --> 01:09:42.979
of what's happening here.

01:09:42.979 --> 01:09:45.200
And why don't we just--

01:09:45.200 --> 01:09:47.069
almost finished.

01:09:47.069 --> 01:09:51.220
So I'm going to shut
this down in a second.

01:09:51.220 --> 01:09:51.774
Last call.

01:09:54.410 --> 01:09:57.330
OK, ending.

01:09:57.330 --> 01:09:59.650
All right.

01:09:59.650 --> 01:10:03.700
So in fact, the
right answer is b.

01:10:03.700 --> 01:10:09.280
I mean, one should be suspicious
that if there's no for alls

01:10:09.280 --> 01:10:11.890
appearing in this
construction anywhere.

01:10:11.890 --> 01:10:13.570
So really what
we're doing is we're

01:10:13.570 --> 01:10:16.550
constructing a formula that
has only exist qualifiers.

01:10:16.550 --> 01:10:18.650
So it's a
satisfiability problem.

01:10:18.650 --> 01:10:22.810
So really what we just
did was we constructed--

01:10:22.810 --> 01:10:28.360
we did in a more complicated
way the Cook-Levin construction,

01:10:28.360 --> 01:10:31.750
because we end up
with a SAT formula

01:10:31.750 --> 01:10:33.340
only with exist quantifiers.

01:10:33.340 --> 01:10:37.577
And so really try one and
try two were the same.

01:10:37.577 --> 01:10:39.160
So it's not surprising
that you end up

01:10:39.160 --> 01:10:44.260
with an exponentially
big formula as a result.

01:10:44.260 --> 01:10:45.430
I don't know.

01:10:45.430 --> 01:10:47.920
A lot of you answered
we know that TQBF

01:10:47.920 --> 01:10:51.100
is in P. It's not in
P. We don't know that.

01:10:51.100 --> 01:10:53.800
I don't know where you--

01:10:53.800 --> 01:10:57.280
what's happening with you guys?

01:10:57.280 --> 01:10:58.540
But no.

01:10:58.540 --> 01:11:00.490
Maybe that was a protest vote.

01:11:00.490 --> 01:11:04.840
But anyway, we don't know that.

01:11:04.840 --> 01:11:06.940
And what has that got to
do with anything anyway?

01:11:06.940 --> 01:11:09.360
So anyway, let's see.

01:11:09.360 --> 01:11:13.195
We solve this in our
remaining few minutes here.

01:11:20.170 --> 01:11:21.265
So here is the solution.

01:11:24.090 --> 01:11:28.365
Remember, this part where we're
saying we're trying to find c

01:11:28.365 --> 01:11:31.802
mid, does there
exist a c mid such

01:11:31.802 --> 01:11:34.260
that I can get from ci to c
mid in half the number of steps

01:11:34.260 --> 01:11:37.260
and c mid to cj in half
the number of steps.

01:11:37.260 --> 01:11:41.040
I'm expressing one formula
in terms of two formulas.

01:11:41.040 --> 01:11:43.230
That's where the
blow up is occurring.

01:11:43.230 --> 01:11:47.130
Because these two are then
in terms are going to each--

01:11:47.130 --> 01:11:50.440
so these two are going to
become 4, become 8, and that's

01:11:50.440 --> 01:11:50.940
not good.

01:11:50.940 --> 01:11:54.750
Can I express this fact in
terms of just one formula?

01:11:54.750 --> 01:11:57.870
And this kind of a little bit in
the spirit of your suggestions.

01:11:57.870 --> 01:12:00.510
Can we kind of reuse
things in a way?

01:12:00.510 --> 01:12:03.360
And that's what we're
actually going to kind do.

01:12:03.360 --> 01:12:05.910
So here's another way
of saying the same thing

01:12:05.910 --> 01:12:07.710
but with just a single formula.

01:12:07.710 --> 01:12:09.270
And it uses a for all.

01:12:09.270 --> 01:12:12.750
And the idea behind
it is that an and

01:12:12.750 --> 01:12:14.850
is kind of like a for all.

01:12:14.850 --> 01:12:17.070
Or a for all is
kind of like an and.

01:12:17.070 --> 01:12:19.530
Just like in exist as
kind of like an or.

01:12:19.530 --> 01:12:23.060
So when you're saying
does something exist,

01:12:23.060 --> 01:12:25.760
is it this thing or that thing
or that thing or that thing?

01:12:25.760 --> 01:12:27.530
And when you're
saying for all, it

01:12:27.530 --> 01:12:31.570
has this thing and that thing
and that thing and that thing.

01:12:31.570 --> 01:12:34.100
Ands and for alls are
very much related.

01:12:34.100 --> 01:12:36.950
And so we're going to convert
this and into a for all.

01:12:36.950 --> 01:12:42.820
We're going to say for all
configuration cg and ch that

01:12:42.820 --> 01:12:50.380
are either set to ci c mid or
to c mid cj, the formula cg ch--

01:12:50.380 --> 01:12:53.690
I can get from cg to ch in
half the number of steps.

01:12:53.690 --> 01:12:55.930
So you have to think about
what this is meaning here.

01:12:59.000 --> 01:13:00.910
And I also want to
make sure that you

01:13:00.910 --> 01:13:04.630
don't feel I'm cheating you,
because well, first of all,

01:13:04.630 --> 01:13:07.850
so now we have just
a single formula.

01:13:07.850 --> 01:13:10.370
We're going to go down
to the case b equals 1,

01:13:10.370 --> 01:13:12.300
as we did before.

01:13:12.300 --> 01:13:17.490
You have to make sure that
saying this restricted for all

01:13:17.490 --> 01:13:18.650
is not a cheat.

01:13:18.650 --> 01:13:23.780
When you have for all x is
in s, like we have over here,

01:13:23.780 --> 01:13:27.920
is equivalent to saying for
all x if x happens to be in s,

01:13:27.920 --> 01:13:29.510
then the other thing follows.

01:13:29.510 --> 01:13:34.960
And this implication can be
expressed using ands and ors.

01:13:34.960 --> 01:13:39.910
And as before, the
initial starting point

01:13:39.910 --> 01:13:44.870
is going to be going from c
start to c accept in t steps.

01:13:44.870 --> 01:13:47.530
And so the analysis
that we get is

01:13:47.530 --> 01:13:51.700
that because there's
no longer a blow up,

01:13:51.700 --> 01:13:59.060
each recursive level just
adds this stuff here in front.

01:13:59.060 --> 01:14:02.310
The exist c mid and
this for all part.

01:14:02.310 --> 01:14:08.120
So that's going to be adding
order n to the formula instead

01:14:08.120 --> 01:14:11.870
of multiplying because
we have two formulas.

01:14:11.870 --> 01:14:14.810
And now the total number of
levels is order n to the k,

01:14:14.810 --> 01:14:15.900
as before.

01:14:15.900 --> 01:14:21.410
So the size is going to be n to
the k times n to the k order n

01:14:21.410 --> 01:14:23.450
to the 2k.

01:14:23.450 --> 01:14:26.490
I actually I had a
brief check in here,

01:14:26.490 --> 01:14:31.850
which I'd like you to do just
in our remaining few seconds.

01:14:31.850 --> 01:14:36.650
Does this construction depend
on m being deterministic?

01:14:36.650 --> 01:14:39.380
So let me just launch that.

01:14:39.380 --> 01:14:43.590
I want you to guys to get
your check in credit here.

01:14:43.590 --> 01:14:53.880
But in fact, you have
to think this through.

01:14:53.880 --> 01:14:59.485
That formula says that the
tableau, you get a tableau.

01:14:59.485 --> 01:15:00.860
Is that going to
matter depending

01:15:00.860 --> 01:15:03.350
upon whether it's deterministic
or non-deterministic?

01:15:03.350 --> 01:15:09.840
It's actually, well, it's
kind of running 50/50 here.

01:15:12.263 --> 01:15:13.680
Why don't you just
pick something?

01:15:13.680 --> 01:15:17.220
Because I'd like to just
close this out and just

01:15:17.220 --> 01:15:19.360
get to our last slide.

01:15:19.360 --> 01:15:21.990
So if you don't
follow, don't worry.

01:15:21.990 --> 01:15:27.270
But it's actually an interesting
point that the fact that this--

01:15:27.270 --> 01:15:28.770
so I'm going to end this.

01:15:28.770 --> 01:15:29.310
All in?

01:15:33.750 --> 01:15:36.660
So in fact, the right
answer is it still would

01:15:36.660 --> 01:15:38.790
work if it's non-deterministic.

01:15:38.790 --> 01:15:40.920
And this would give
you an alternative way

01:15:40.920 --> 01:15:42.510
of proving Savitch's theorem.

01:15:42.510 --> 01:15:46.080
So really this all comes
down to this proof,

01:15:46.080 --> 01:15:48.900
which implies Savitch's
theorem and then in turn

01:15:48.900 --> 01:15:52.150
implies the ladder DFA problem.

01:15:52.150 --> 01:15:55.320
So anyway, that's side note,
not critical for understanding,

01:15:55.320 --> 01:15:55.830
really.

01:15:55.830 --> 01:15:58.530
You can take those as all
separate, the results,

01:15:58.530 --> 01:16:00.780
and that's good enough.

01:16:00.780 --> 01:16:09.370
All right, so coming back.

01:16:09.370 --> 01:16:10.450
Whoops.

01:16:10.450 --> 01:16:11.020
Coming back.

01:16:15.650 --> 01:16:17.480
This is what we did.

01:16:17.480 --> 01:16:22.310
And so each recursive
level, the size of the QBF

01:16:22.310 --> 01:16:23.265
is not the same.

01:16:23.265 --> 01:16:25.640
Somebody's asking is it the
same at each recursive level.

01:16:25.640 --> 01:16:27.200
No, we had to add in--

01:16:33.530 --> 01:16:35.360
let's just see.

01:16:35.360 --> 01:16:36.380
Each recursion.

01:16:39.095 --> 01:16:41.990
This is recursively
built here, but now we

01:16:41.990 --> 01:16:46.380
have to add this part in front
and this part here in front.

01:16:46.380 --> 01:16:49.760
So the quantifier
which is quantified

01:16:49.760 --> 01:16:51.710
over a bunch of
variables representing

01:16:51.710 --> 01:16:55.320
the configuration, that
gets added on at each level.

01:16:55.320 --> 01:16:58.373
So it's not just
it stays the same.

01:16:58.373 --> 01:16:59.790
There's stuff
that's get added in.

01:16:59.790 --> 01:17:05.470
But what's important is that it
doesn't blow up exponentially.

01:17:05.470 --> 01:17:09.100
The stuff gets added in every
time but not multiplied.

01:17:14.030 --> 01:17:14.530
OK.

01:17:14.530 --> 01:17:15.770
So we're done here.

01:17:15.770 --> 01:17:17.440
So anybody, you
can all take off.

01:17:17.440 --> 01:17:19.690
I think many of
you already have.

01:17:19.690 --> 01:17:21.920
Bye bye.

01:17:21.920 --> 01:17:23.680
Thank you.