WEBVTT

00:00:00.070 --> 00:00:01.770
The following
content is provided

00:00:01.770 --> 00:00:04.010
under a Creative
Commons license.

00:00:04.010 --> 00:00:06.860
Your support will help MIT
OpenCourseWare continue

00:00:06.860 --> 00:00:10.720
to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.330
To make a donation or
view additional materials

00:00:13.330 --> 00:00:17.207
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.207 --> 00:00:17.832
at ocw.mit.edu.

00:00:21.800 --> 00:00:22.500
PROFESSOR: OK.

00:00:22.500 --> 00:00:25.150
Who's going to lecture?

00:00:25.150 --> 00:00:26.642
Wow.

00:00:26.642 --> 00:00:27.290
Nice.

00:00:27.290 --> 00:00:29.500
Does lecture make sense?

00:00:29.500 --> 00:00:31.720
One, two, three-- sort of.

00:00:31.720 --> 00:00:32.759
OK.

00:00:32.759 --> 00:00:35.080
Then I'm going to
have an easy job.

00:00:35.080 --> 00:00:38.020
So any pointed questions?

00:00:38.020 --> 00:00:40.510
Any specific pinpoints?

00:00:40.510 --> 00:00:43.540
We talked about DFS, but DFS
and BFS are sort of related,

00:00:43.540 --> 00:00:45.642
so I'm happy to take both.

00:00:45.642 --> 00:00:47.800
AUDIENCE: The
classification of edges?

00:00:47.800 --> 00:00:48.474
PROFESSOR: OK.

00:00:48.474 --> 00:00:50.140
We're going to talk
about that for sure.

00:01:02.050 --> 00:01:04.459
Anything else?

00:01:04.459 --> 00:01:07.710
AUDIENCE: I thought it was
funny that in undirected graphs,

00:01:07.710 --> 00:01:10.745
you could have a backward--
or something like that.

00:01:10.745 --> 00:01:12.620
PROFESSOR: You don't
have to give a radiance.

00:01:12.620 --> 00:01:14.120
I will derive it.

00:01:14.120 --> 00:01:20.290
OK So what edges do we have
in directed versus undirected.

00:01:24.630 --> 00:01:25.130
OK.

00:01:25.130 --> 00:01:25.629
What else?

00:01:30.370 --> 00:01:30.950
Cool.

00:01:30.950 --> 00:01:34.260
So I'm going to go through the
concepts in DFS really quickly.

00:01:34.260 --> 00:01:36.160
And we're going
to focus on this.

00:01:36.160 --> 00:01:38.960
Because it seems like this
is where the issues are.

00:01:41.500 --> 00:01:42.310
I want this.

00:01:42.310 --> 00:01:43.235
So what's a graph?

00:01:46.262 --> 00:01:48.367
AUDIENCE: Interconnected notes.

00:01:48.367 --> 00:01:48.950
PROFESSOR: OK.

00:01:48.950 --> 00:01:49.620
Fancy names.

00:01:49.620 --> 00:01:49.940
Come on.

00:01:49.940 --> 00:01:51.315
We had this in
the last workshop.

00:01:51.315 --> 00:01:54.810
AUDIENCE: A set of
edges and vertices.

00:01:54.810 --> 00:01:56.100
PROFESSOR: All right.

00:01:56.100 --> 00:01:58.426
How do I draw my vertices?

00:01:58.426 --> 00:01:59.302
AUDIENCE: Dots.

00:01:59.302 --> 00:02:01.098
Circles.

00:02:01.098 --> 00:02:02.562
PROFESSOR: Dots.

00:02:02.562 --> 00:02:05.978
How do I draw my edges?

00:02:05.978 --> 00:02:06.942
AUDIENCE: Dots.

00:02:06.942 --> 00:02:07.442
Lines.

00:02:10.050 --> 00:02:10.550
Oops.

00:02:42.960 --> 00:02:44.580
PROFESSOR: Looks like a graph?

00:02:44.580 --> 00:02:47.460
What kind of graph?

00:02:47.460 --> 00:02:47.960
Directed.

00:02:47.960 --> 00:02:50.500
Because there are arrows
and not straight up lines.

00:02:50.500 --> 00:02:51.400
Right?

00:02:51.400 --> 00:02:53.620
How do we store
graphs in Python?

00:02:57.300 --> 00:03:00.450
Fancy name first and
then implementation.

00:03:00.450 --> 00:03:01.580
AUDIENCE: [INAUDIBLE] list.

00:03:01.580 --> 00:03:02.163
PROFESSOR: OK.

00:03:09.020 --> 00:03:12.300
What's an adjacency
list in Python?

00:03:12.300 --> 00:03:14.940
AUDIENCE: It just
shows what notes

00:03:14.940 --> 00:03:16.807
are adjacent to other notes.

00:03:16.807 --> 00:03:17.390
PROFESSOR: OK.

00:03:17.390 --> 00:03:19.710
So what data
structure do we use?

00:03:19.710 --> 00:03:22.442
What elementary python
data structure do we use?

00:03:22.442 --> 00:03:23.400
AUDIENCE: A dictionary?

00:03:23.400 --> 00:03:24.420
PROFESSOR: All right.

00:03:24.420 --> 00:03:29.298
So an adjacency list is a
dictionary that keys our--

00:03:29.298 --> 00:03:30.760
AUDIENCE: [INAUDIBLE].

00:03:30.760 --> 00:03:32.500
PROFESSOR: OK.

00:03:32.500 --> 00:03:35.520
So the keys are the vertices.

00:03:39.284 --> 00:03:41.365
So on and so forth.

00:03:41.365 --> 00:03:42.365
And what are the values?

00:03:45.508 --> 00:03:48.376
AUDIENCE: The nodes?

00:03:48.376 --> 00:03:50.097
Adjacent nodes?

00:03:50.097 --> 00:03:50.680
PROFESSOR: OK.

00:03:54.160 --> 00:03:57.840
A list of something.

00:03:57.840 --> 00:03:59.970
So after our presentation,
is the object the one

00:03:59.970 --> 00:04:02.550
that has edges
and the simplified

00:04:02.550 --> 00:04:04.640
one that has vertices.

00:04:04.640 --> 00:04:07.220
So suppose I want to
go for the simple one.

00:04:07.220 --> 00:04:10.840
Where vertices do
I have in A's list?

00:04:10.840 --> 00:04:12.420
AUDIENCE: B and G. Right?

00:04:15.940 --> 00:04:17.606
PROFESSOR: B and G. Sounds good.

00:04:20.152 --> 00:04:20.652
Right.

00:04:20.652 --> 00:04:24.466
What vertices do I
have in B's list?

00:04:24.466 --> 00:04:28.920
AUDIENCE: C.

00:04:28.920 --> 00:04:32.094
PROFESSOR: Why do I not have A?

00:04:32.094 --> 00:04:36.714
AUDIENCE: Because it's an
arrow, so it can't get to A.

00:04:36.714 --> 00:04:37.380
PROFESSOR: Yeah.

00:04:37.380 --> 00:04:39.625
So the nodes that
I have in the list

00:04:39.625 --> 00:04:42.860
are the nodes that are
reachable from that node.

00:04:42.860 --> 00:04:45.610
I have an edge from B to C,
so C is reachable from B.

00:04:45.610 --> 00:04:48.510
I do not have an
edge from B to A

00:04:48.510 --> 00:04:49.760
because my edges are directed.

00:04:49.760 --> 00:04:51.881
So A is not there.

00:04:51.881 --> 00:04:52.380
OK.

00:04:52.380 --> 00:04:56.480
Let's write a bit of pseudo-
So although it's Python,

00:04:56.480 --> 00:05:01.480
let's say our graph is
represented by a class G. Let's

00:05:01.480 --> 00:05:05.450
say in this class I
have a dictionary called

00:05:05.450 --> 00:05:09.420
al, which has what we want.

00:05:09.420 --> 00:05:12.820
If I want to get all the
vertices in the graph,

00:05:12.820 --> 00:05:15.300
I want to write the method
that returns all the vertices.

00:05:19.040 --> 00:05:21.650
What should it look like?

00:05:21.650 --> 00:05:24.784
Just to make sure that we're
all getting the data structure.

00:05:24.784 --> 00:05:25.700
AUDIENCE: [INAUDIBLE].

00:05:25.700 --> 00:05:26.283
PROFESSOR: OK.

00:05:28.417 --> 00:05:29.750
So the keys are in the vertices.

00:05:34.840 --> 00:05:37.110
Now, given the vertex,
I want its neighbors.

00:05:42.240 --> 00:05:44.278
How do I write that?

00:05:44.278 --> 00:05:47.632
AUDIENCE: You mean only the
vertices that it can go to?

00:05:47.632 --> 00:05:48.298
PROFESSOR: Yeah.

00:05:51.526 --> 00:05:52.150
AUDIENCE: Yeah.

00:05:52.150 --> 00:05:54.400
Dictionary and that vertex.

00:05:54.400 --> 00:05:58.955
PROFESSOR: So
return dictionary--

00:05:58.955 --> 00:06:04.244
AUDIENCE: al bracket vertex v.

00:06:04.244 --> 00:06:05.760
PROFESSOR: Cool.

00:06:05.760 --> 00:06:06.260
OK.

00:06:06.260 --> 00:06:07.926
So this makes sense
for everyone, right?

00:06:12.110 --> 00:06:13.920
Let's start writing
DFS because no one

00:06:13.920 --> 00:06:15.960
said they don't understand DFS.

00:06:15.960 --> 00:06:22.320
So let's say we have
a DFS procedure.

00:06:22.320 --> 00:06:25.930
And it gets a graph.

00:06:25.930 --> 00:06:27.040
And it has to do DFS.

00:06:29.840 --> 00:06:31.070
What do you need for DFS?

00:06:33.680 --> 00:06:36.240
Starting points would be good.

00:06:36.240 --> 00:06:39.060
Just like for DFS, right?

00:06:39.060 --> 00:06:41.740
So how do we do DFS?

00:06:47.030 --> 00:06:49.700
AUDIENCE: Start with
one node and then we

00:06:49.700 --> 00:06:53.220
keep on following a path down
by picking the first vertex.

00:06:53.220 --> 00:06:55.870
So like for A,
we'd start with A.

00:06:55.870 --> 00:06:58.715
Then we'd pick the first
vertex in its list.

00:06:58.715 --> 00:07:02.600
And then we pick the first
vertex in that one's list,

00:07:02.600 --> 00:07:05.243
first vertex in that one's
list, until we run out.

00:07:05.243 --> 00:07:05.826
PROFESSOR: OK.

00:07:05.826 --> 00:07:08.890
So basically you start today.

00:07:08.890 --> 00:07:12.220
And for every neighbor,
you recursively

00:07:12.220 --> 00:07:14.500
do DFS on that neighbor.

00:07:14.500 --> 00:07:15.000
Right?

00:07:15.000 --> 00:07:17.700
So since this is
recursive, let's write it

00:07:17.700 --> 00:07:20.190
in a recursive
manner, nice and easy.

00:07:20.190 --> 00:07:29.090
So say DFS calls DFS
visit of g and s.

00:07:29.090 --> 00:07:37.990
And let's say DFS
visit takes the graph,

00:07:37.990 --> 00:07:40.020
takes the node that
we're visiting,

00:07:40.020 --> 00:07:43.030
and how are we
implementing this?

00:07:46.530 --> 00:07:50.270
AUDIENCE: Just
return [INAUDIBLE].

00:07:50.270 --> 00:07:50.770
No.

00:07:50.770 --> 00:07:53.197
It marks as visited.

00:07:53.197 --> 00:07:53.780
PROFESSOR: OK.

00:07:53.780 --> 00:07:56.870
Marking something as visited
is important to lead this.

00:07:56.870 --> 00:08:00.910
So what's the main thing
that you do in DFS?

00:08:00.910 --> 00:08:02.750
Iterate over the
neighbors and recurse.

00:08:02.750 --> 00:08:03.380
Right?

00:08:03.380 --> 00:08:25.950
So for n in g neighbors of v
called DFS visit of g and n.

00:08:25.950 --> 00:08:29.870
So this is the basic idea.

00:08:29.870 --> 00:08:33.140
It has some holes that we need
to fill because otherwise it

00:08:33.140 --> 00:08:34.080
doesn't quite work.

00:08:34.080 --> 00:08:36.330
This is going to
recurse forever,

00:08:36.330 --> 00:08:38.940
which is not very good
if you have a time

00:08:38.940 --> 00:08:41.549
limit that your
code needs to obey.

00:08:41.549 --> 00:08:45.529
So how do I make it
not recurse forever?

00:08:45.529 --> 00:08:48.070
AUDIENCE: Every time you visit,
you're about to visit a node,

00:08:48.070 --> 00:08:51.215
check if you've
already visited it.

00:08:51.215 --> 00:08:52.090
PROFESSOR: All right.

00:08:52.090 --> 00:08:53.589
So we should keep
track of the nodes

00:08:53.589 --> 00:08:56.690
that we've already visited
and not visit them again.

00:08:56.690 --> 00:08:57.190
Right.

00:08:57.190 --> 00:09:02.332
So you start with
A, go to B, go to C,

00:09:02.332 --> 00:09:04.540
you'd better not go to A
again because you've already

00:09:04.540 --> 00:09:06.980
been there.

00:09:06.980 --> 00:09:08.420
So let's implement
that this way.

00:09:08.420 --> 00:09:12.650
Let's make a new object
called DFS result that

00:09:12.650 --> 00:09:17.560
is sort of that
drawer that you have

00:09:17.560 --> 00:09:19.160
where you stick
everything in where

00:09:19.160 --> 00:09:20.564
you don't have a good place.

00:09:20.564 --> 00:09:22.230
So everything I do
not have a good place

00:09:22.230 --> 00:09:24.240
to put it, you just
stick it in a drawer.

00:09:24.240 --> 00:09:25.512
And then you can close
the drawing that be like,

00:09:25.512 --> 00:09:26.180
it's clean.

00:09:26.180 --> 00:09:27.430
Everything's clean.

00:09:27.430 --> 00:09:29.777
So let's say DFS
result is that drawer.

00:09:29.777 --> 00:09:31.360
Everything that they
need from now on,

00:09:31.360 --> 00:09:33.130
we're just going
to stick in there.

00:09:33.130 --> 00:09:39.100
So I have an object DFS result.

00:09:39.100 --> 00:09:41.100
And we're going to figure
out what we put in it.

00:09:41.100 --> 00:09:44.995
But at the beginning of DFS,
I'm going to create that.

00:09:49.060 --> 00:09:50.490
So create the new object.

00:09:50.490 --> 00:09:54.110
And then I'm going to
pass it onto to DFS visit.

00:09:59.740 --> 00:10:04.790
So now we have a drawer where
we can put everything we want.

00:10:04.790 --> 00:10:10.610
So let's keep track of the
visited information here.

00:10:10.610 --> 00:10:14.770
How would I keep track
of what nodes I visited?

00:10:14.770 --> 00:10:16.150
AUDIENCE: In a list?

00:10:16.150 --> 00:10:17.910
PROFESSOR: In a list.

00:10:17.910 --> 00:10:22.530
So if I do a list, it
turns out that in DFS,

00:10:22.530 --> 00:10:24.170
and VFS, for that
matter, you check

00:10:24.170 --> 00:10:25.760
if you visited a
node pretty often.

00:10:25.760 --> 00:10:28.130
So it would be kind of slow.

00:10:28.130 --> 00:10:29.270
So let's have a dictionary.

00:10:29.270 --> 00:10:31.103
What are we going to
put in that dictionary?

00:10:33.694 --> 00:10:37.422
AUDIENCE: The node [INAUDIBLE]
and listed [INAUDIBLE].

00:10:37.422 --> 00:10:38.005
PROFESSOR: OK.

00:10:38.005 --> 00:10:43.710
So we're going to have
a visited dictionary.

00:10:43.710 --> 00:10:46.040
And then the keys are
going to be nodes.

00:10:46.040 --> 00:10:49.320
And let's say we're only going
to put the nodes that we visit

00:10:49.320 --> 00:10:52.080
in it so we don't
have to initialize it.

00:10:52.080 --> 00:10:53.580
And the values are
going to be true.

00:10:53.580 --> 00:10:55.288
Because if the node
is in the dictionary,

00:10:55.288 --> 00:10:59.090
it means we visited it.

00:10:59.090 --> 00:11:00.920
So for all the nodes
that are in there,

00:11:00.920 --> 00:11:02.500
visited is going to be true.

00:11:06.024 --> 00:11:06.523
Sorry.

00:11:10.140 --> 00:11:10.640
OK.

00:11:10.640 --> 00:11:14.490
So where do I fill this in?

00:11:14.490 --> 00:11:15.060
Let's use it.

00:11:19.090 --> 00:11:26.470
AUDIENCE: Four n and g
neighbors, set it to true.

00:11:26.470 --> 00:11:27.910
But before that--

00:11:27.910 --> 00:11:29.920
PROFESSOR: So here?

00:11:29.920 --> 00:11:33.280
AUDIENCE: R not.

00:11:33.280 --> 00:11:36.047
Um.

00:11:36.047 --> 00:11:36.630
PROFESSOR: OK.

00:11:40.530 --> 00:11:41.430
So let's say this.

00:11:41.430 --> 00:11:44.090
Let's say these
are lines 1, 2, 3.

00:11:44.090 --> 00:11:47.920
Line 1.5 or 2.5?

00:11:47.920 --> 00:11:54.840
AUDIENCE: So at n 1.5, check
if v is in the dictionary.

00:11:54.840 --> 00:11:55.520
PROFESSOR: Here?

00:11:55.520 --> 00:11:57.110
OK.

00:11:57.110 --> 00:12:06.646
If v in r dot visited, then--

00:12:09.017 --> 00:12:09.725
AUDIENCE: Return.

00:12:19.360 --> 00:12:26.750
Then 2.5, set r dot n to true.

00:12:26.750 --> 00:12:31.114
You would only do it n times--

00:12:31.114 --> 00:12:31.780
PROFESSOR: Wait.

00:12:31.780 --> 00:12:35.983
So here you're saying say r
dot visited of n equals true?

00:12:35.983 --> 00:12:37.462
AUDIENCE: Oh, no.

00:12:37.462 --> 00:12:40.913
Change the v in
v visited return,

00:12:40.913 --> 00:12:42.885
change that into a loop.

00:12:42.885 --> 00:12:44.910
Put that after the loop.

00:12:44.910 --> 00:12:48.392
Put that into the loop.

00:12:48.392 --> 00:12:52.368
And it's n visited
to the [INAUDIBLE].

00:12:59.350 --> 00:13:08.804
PROFESSOR: n in r dot visited--
we probably want not n, right?

00:13:08.804 --> 00:13:09.720
AUDIENCE: [INAUDIBLE].

00:13:14.147 --> 00:13:14.730
PROFESSOR: OK.

00:13:19.670 --> 00:13:28.637
R dot visited is true
and then the DFS.

00:13:28.637 --> 00:13:31.220
So will this achieve the thing
that I wanted at the beginning.

00:13:31.220 --> 00:13:33.080
You start at A, you
go to B, you go to C,

00:13:33.080 --> 00:13:35.280
and then you do not go to A?

00:13:35.280 --> 00:13:37.000
Not quite.

00:13:37.000 --> 00:13:39.020
AUDIENCE: We haven't
had our starting yet.

00:13:39.020 --> 00:13:39.520
Yeah.

00:13:43.414 --> 00:13:48.529
We could add V at the
beginning and check at the end.

00:13:48.529 --> 00:13:52.310
Because that's only
the visited, right?

00:13:52.310 --> 00:13:54.860
PROFESSOR: So I think I
like Christian's suggestion.

00:13:54.860 --> 00:14:02.760
r dot visited of v is true.

00:14:02.760 --> 00:14:04.260
And then we can
remove it from here.

00:14:07.704 --> 00:14:11.640
AUDIENCE: It has
to be [INAUDIBLE]

00:14:11.640 --> 00:14:14.840
because the other
case is going to cover

00:14:14.840 --> 00:14:16.405
for if you visited again.

00:14:16.405 --> 00:14:21.855
But the first time it's being
called, it's not checking--

00:14:21.855 --> 00:14:23.730
PROFESSOR: Well you mean
the first time here?

00:14:23.730 --> 00:14:26.000
AUDIENCE: The first
call that's being made,

00:14:26.000 --> 00:14:27.914
and the recursive
call, it's going

00:14:27.914 --> 00:14:30.434
to be as if it's not
into the visited node.

00:14:30.434 --> 00:14:31.100
PROFESSOR: Yeah.

00:14:31.100 --> 00:14:34.090
But this is at the beginning.

00:14:34.090 --> 00:14:35.130
Right?

00:14:35.130 --> 00:14:38.210
So this calls DFS visit
to the starting node.

00:14:38.210 --> 00:14:38.810
Do we care?

00:14:42.340 --> 00:14:43.550
So I think this should work.

00:14:43.550 --> 00:14:46.091
It's not the only way to write
it, but it's reasonably clean.

00:14:46.091 --> 00:14:50.370
It's easy to reason
about, and it works.

00:14:50.370 --> 00:14:52.630
Does it make sense to everyone?

00:14:52.630 --> 00:14:53.130
OK.

00:14:53.130 --> 00:14:54.879
We're going to change
things a little bit.

00:14:54.879 --> 00:14:56.690
So instead of using
visited, we're

00:14:56.690 --> 00:15:00.050
going to keep track for
every node of its parent.

00:15:00.050 --> 00:15:03.000
So the node that
we visited from.

00:15:03.000 --> 00:15:04.750
So we're not going to
use visited anymore.

00:15:04.750 --> 00:15:10.220
Instead we're going
to use parent of v

00:15:10.220 --> 00:15:13.370
is going to be some other node.

00:15:17.930 --> 00:15:21.130
So what I want is
for this graph,

00:15:21.130 --> 00:15:24.220
I said I'm going to go from
A to B, and then from B to C.

00:15:24.220 --> 00:15:32.340
So I want the parent of B to be
A, and the parent of C to be B.

00:15:32.340 --> 00:15:34.020
Make sense for everyone?

00:15:34.020 --> 00:15:36.230
So what's the parent of A?

00:15:36.230 --> 00:15:37.110
AUDIENCE: None.

00:15:37.110 --> 00:15:39.180
PROFESSOR: None's a
good value, right?

00:15:39.180 --> 00:15:41.100
There's no parent.

00:15:41.100 --> 00:15:42.090
OK.

00:15:42.090 --> 00:15:44.880
So how would I modify
this code to write that?

00:15:52.730 --> 00:15:59.940
AUDIENCE: Stick a line
in 2.75 and establish 3b

00:15:59.940 --> 00:16:03.370
as the parent of n.

00:16:03.370 --> 00:16:08.300
PROFESSOR: So r dot parent?

00:16:08.300 --> 00:16:12.700
AUDIENCE: Yeah, of n is v.

00:16:12.700 --> 00:16:15.480
PROFESSOR: Of n is v. Good.

00:16:15.480 --> 00:16:17.200
And I don't have
visited anymore,

00:16:17.200 --> 00:16:19.050
so this line is
going to blow up.

00:16:19.050 --> 00:16:20.250
So what do I do instead?

00:16:23.080 --> 00:16:24.510
AUDIENCE: Oh.

00:16:24.510 --> 00:16:28.030
It doesn't have a parent?

00:16:28.030 --> 00:16:28.700
PROFESSOR: Yep.

00:16:28.700 --> 00:16:31.525
So if it doesn't have a
parent, we didn't visit it.

00:16:31.525 --> 00:16:33.150
So the parents works
just like visited,

00:16:33.150 --> 00:16:35.108
except the values are
not going to be all true.

00:16:35.108 --> 00:16:38.015
They're going to be
something a bit more useful.

00:16:38.015 --> 00:16:41.232
AUDIENCE: We can't test for
none because the first one has

00:16:41.232 --> 00:16:41.899
a value of none.

00:16:41.899 --> 00:16:43.731
PROFESSOR: But they're
not testing for none,

00:16:43.731 --> 00:16:45.689
we're saying is it in
the dictionary or not?

00:16:45.689 --> 00:16:46.230
AUDIENCE: Oh.

00:16:46.230 --> 00:16:46.730
OK.

00:16:52.359 --> 00:16:53.650
PROFESSOR: That's a good point.

00:16:53.650 --> 00:16:54.230
You could be testing for none.

00:16:54.230 --> 00:16:55.640
That wouldn't work.

00:16:55.640 --> 00:16:58.370
So you have to write
the check like this.

00:16:58.370 --> 00:17:00.954
And we're going to erase
this because otherwise, it's

00:17:00.954 --> 00:17:02.120
going to throw an exception.

00:17:06.210 --> 00:17:08.955
And what else do we need?

00:17:08.955 --> 00:17:10.079
There's one missing parent.

00:17:14.534 --> 00:17:15.937
AUDIENCE: Inverse form?

00:17:15.937 --> 00:17:16.520
PROFESSOR: OK.

00:17:16.520 --> 00:17:18.696
Where do I say that?

00:17:18.696 --> 00:17:21.460
AUDIENCE: In DFS.

00:17:21.460 --> 00:17:23.060
PROFESSOR: OK.

00:17:23.060 --> 00:17:26.599
One, two, three, which line?

00:17:26.599 --> 00:17:30.380
1.5, 2.5, 3.5?

00:17:30.380 --> 00:17:31.375
AUDIENCE: 2.5.

00:17:31.375 --> 00:17:32.000
PROFESSOR: 2.5.

00:17:32.000 --> 00:17:34.476
All right, so here.

00:17:34.476 --> 00:17:36.023
What do I write?

00:17:39.470 --> 00:17:39.970
Yes?

00:17:42.538 --> 00:17:44.980
AUDIENCE: Parent of s is none.

00:17:44.980 --> 00:17:46.700
PROFESSOR: OK.

00:17:46.700 --> 00:17:54.890
So r dot parent s is none.

00:17:54.890 --> 00:17:57.820
So now this works.

00:17:57.820 --> 00:17:58.510
Right?

00:17:58.510 --> 00:17:59.650
Any questions so far?

00:18:03.470 --> 00:18:03.970
Nope.

00:18:03.970 --> 00:18:05.360
Basic DFS works.

00:18:05.360 --> 00:18:06.650
Everyone's happy with it?

00:18:11.460 --> 00:18:16.970
Let's try to track it
for this graph here.

00:18:16.970 --> 00:18:19.180
And you're going to be in
a better position than me

00:18:19.180 --> 00:18:21.480
because I'm not sure I
can see the graph all

00:18:21.480 --> 00:18:23.990
the way from here.

00:18:23.990 --> 00:18:25.460
Almost.

00:18:25.460 --> 00:18:30.750
So let's have the parents or
the parent's dictionary here.

00:18:35.560 --> 00:18:39.830
And here, let's write the call
structure as it will happen.

00:18:39.830 --> 00:18:43.920
So where do I start?

00:18:43.920 --> 00:18:46.840
DFS of A, right?

00:18:46.840 --> 00:18:56.130
DFS of A. And this is
going to call DFS visit A.

00:18:56.130 --> 00:18:57.130
What are A's neighbors?

00:18:59.890 --> 00:19:00.872
AUDIENCE: b and g.

00:19:03.914 --> 00:19:04.580
PROFESSOR: Cool.

00:19:04.580 --> 00:19:07.480
Is b in parents?

00:19:07.480 --> 00:19:09.802
What's in parents,
at this point?

00:19:09.802 --> 00:19:12.122
AUDIENCE: Just a.

00:19:12.122 --> 00:19:14.770
Oh.

00:19:14.770 --> 00:19:16.020
PROFESSOR: A is none.

00:19:16.020 --> 00:19:16.666
Good.

00:19:16.666 --> 00:19:18.290
Excellent.

00:19:18.290 --> 00:19:21.560
So B is not in parents,
so what am I going to do?

00:19:21.560 --> 00:19:23.572
And it's the parents in visited.

00:19:23.572 --> 00:19:24.530
Right?

00:19:24.530 --> 00:19:25.767
What's B's parents?

00:19:28.629 --> 00:19:31.500
AUDIENCE: A.

00:19:31.500 --> 00:19:32.380
PROFESSOR: OK.

00:19:32.380 --> 00:19:38.480
I'm going to call DFS
visit of B. These children.

00:19:43.360 --> 00:19:45.940
C. Is C parents?

00:19:45.940 --> 00:19:46.440
No?

00:19:46.440 --> 00:19:47.022
What happens?

00:19:47.022 --> 00:19:47.980
Feel free to take over.

00:19:47.980 --> 00:19:49.813
When you get it, feel
free to start talking,

00:19:49.813 --> 00:19:51.263
and I can just write.

00:19:51.263 --> 00:19:52.347
AUDIENCE: Of C.

00:19:52.347 --> 00:19:52.930
PROFESSOR: OK.

00:19:56.660 --> 00:19:58.737
What else?

00:19:58.737 --> 00:20:03.860
PROFESSOR: C's
parent is B. So I'm

00:20:03.860 --> 00:20:06.810
in B. The only child is
C. C is not in parents.

00:20:06.810 --> 00:20:07.960
C gets in parent.

00:20:07.960 --> 00:20:13.270
C's parent is B. Call DFS visit
of C, what are C's children?

00:20:13.270 --> 00:20:14.770
AUDIENCE: [INAUDIBLE] and d.

00:20:17.002 --> 00:20:19.210
PROFESSOR: So we're wondering
about the order, right?

00:20:19.210 --> 00:20:20.980
Let's assume that in
the adjacency list,

00:20:20.980 --> 00:20:24.500
all the nodes are in
alphabetical order.

00:20:24.500 --> 00:20:34.930
So I'm going to have
A, D, and F. OK.

00:20:34.930 --> 00:20:37.870
Is A in parents?

00:20:37.870 --> 00:20:39.960
AUDIENCE: Yes.

00:20:39.960 --> 00:20:42.729
PROFESSOR: Is D in parents?

00:20:42.729 --> 00:20:43.270
AUDIENCE: No.

00:20:43.270 --> 00:20:45.543
PROFESSOR: So what happens?

00:20:45.543 --> 00:20:54.390
AUDIENCE: Parents visit
D. D's parent is C.

00:20:54.390 --> 00:20:56.664
PROFESSOR: D's neighbors?

00:20:56.664 --> 00:21:02.400
AUDIENCE: E and F.

00:21:02.400 --> 00:21:04.800
PROFESSOR: E is in the-- no.

00:21:11.354 --> 00:21:12.270
AUDIENCE: [INAUDIBLE].

00:21:19.140 --> 00:21:19.980
PROFESSOR: Cool.

00:21:19.980 --> 00:21:21.790
Does E have any children?

00:21:21.790 --> 00:21:22.610
AUDIENCE: No.

00:21:22.610 --> 00:21:23.760
PROFESSOR: So I'm done.

00:21:23.760 --> 00:21:27.310
I get out of it, right?

00:21:27.310 --> 00:21:30.112
Is F in parents?

00:21:30.112 --> 00:21:33.088
AUDIENCE: No.

00:21:33.088 --> 00:21:36.460
PROFESSOR: F's parent is?

00:21:36.460 --> 00:21:36.960
Cool.

00:21:43.464 --> 00:21:44.630
F doesn't have any children.

00:21:44.630 --> 00:21:45.220
Right?

00:21:45.220 --> 00:21:49.210
So I get out of this DFS visit.

00:21:49.210 --> 00:21:51.800
I'm done with F. So I
get out of this visit.

00:21:51.800 --> 00:21:53.655
And I get back to this one.

00:21:53.655 --> 00:21:58.060
I'm done with D, and I'm
at F. Is F in parents?

00:21:58.060 --> 00:21:59.240
OK.

00:21:59.240 --> 00:22:05.594
So what kind of edge is C to F?

00:22:05.594 --> 00:22:06.344
AUDIENCE: Forward.

00:22:08.812 --> 00:22:09.395
PROFESSOR: OK.

00:22:12.690 --> 00:22:14.569
So forward maybe tree.

00:22:14.569 --> 00:22:15.860
Let's start with the easy ones.

00:22:15.860 --> 00:22:20.790
So now we've gone forward
with AB, BC, CD, DE, and DF.

00:22:20.790 --> 00:22:22.792
What kind of edges
are these ones?

00:22:26.520 --> 00:22:27.020
Tree edges.

00:22:32.540 --> 00:22:34.520
Does anyone know why
they're called tree edges?

00:22:38.504 --> 00:22:41.970
So if you look at the parent
pointers that they have there,

00:22:41.970 --> 00:22:46.280
they're going to end
up defining a tree.

00:22:46.280 --> 00:22:48.530
And the tree is, the
tree shows the order

00:22:48.530 --> 00:22:51.350
in which DFS looked
at the notes.

00:22:51.350 --> 00:22:56.330
So let me erase this and
draw the tree for DFS

00:22:56.330 --> 00:22:57.210
that we had so far.

00:23:01.480 --> 00:23:05.450
So we started at A, then we went
to B. Then we went to C, then

00:23:05.450 --> 00:23:12.200
we went to D, E, F. So this is
all part of the DFS tree.You

00:23:12.200 --> 00:23:13.940
can see that for
all these nodes,

00:23:13.940 --> 00:23:17.090
their parent pointers
point the right way.

00:23:17.090 --> 00:23:19.010
So if you have parent
pointers for every node,

00:23:19.010 --> 00:23:21.940
this is going to
give you a tree.

00:23:21.940 --> 00:23:24.950
So these are tree edges because
they're part of this tree.

00:23:24.950 --> 00:23:30.270
So now we have this
edge from C to F.

00:23:30.270 --> 00:23:32.780
And this is what kind of edge?

00:23:36.127 --> 00:23:36.668
Forward edge.

00:23:36.668 --> 00:23:39.752
Why is it a forward edge?

00:23:39.752 --> 00:23:42.142
AUDIENCE: Somewhere
up higher in the tree

00:23:42.142 --> 00:23:45.010
is trying to get somewhere
lower on the tree.

00:23:45.010 --> 00:23:46.560
It's going forward in time.

00:23:46.560 --> 00:23:49.740
PROFESSOR: So it's going
from a node in the tree

00:23:49.740 --> 00:23:53.142
to a node's child in the tree.

00:23:53.142 --> 00:23:53.850
Sorry, not child.

00:23:53.850 --> 00:23:54.710
Descendant.

00:23:54.710 --> 00:23:59.250
So F is strictly
under C. So yeah.

00:23:59.250 --> 00:24:00.480
It takes us forward in time.

00:24:00.480 --> 00:24:02.240
It's a shortcut in the tree.

00:24:02.240 --> 00:24:05.400
So that's why it's
a forward edge.

00:24:05.400 --> 00:24:07.260
So we now have two
types of edges so far.

00:24:07.260 --> 00:24:09.650
Tree edges and forward edges.

00:24:09.650 --> 00:24:13.370
AUDIENCE: So tree
edges [INAUDIBLE]?

00:24:13.370 --> 00:24:14.151
PROFESSOR: Yep.

00:24:14.151 --> 00:24:16.150
So the tree edges are the
ones that DFS follows.

00:24:19.640 --> 00:24:21.730
All of these are tree edges.

00:24:21.730 --> 00:24:22.230
Yes.

00:24:22.230 --> 00:24:25.831
AUDIENCE: So like
an edge from B to C,

00:24:25.831 --> 00:24:28.186
why can't that be
a forward edge?

00:24:28.186 --> 00:24:29.128
Because technically it's
not a shortcut, right?

00:24:29.128 --> 00:24:31.044
But it's saying it's
pointing to the children,

00:24:31.044 --> 00:24:32.430
but it only has one child.

00:24:32.430 --> 00:24:35.810
PROFESSOR: Because that's
the edge that DFS took.

00:24:35.810 --> 00:24:38.180
So the edges that we
actually follow in DFS

00:24:38.180 --> 00:24:41.980
have a special name,
and they're tree edges.

00:24:41.980 --> 00:24:43.680
So first off, the
most important edges

00:24:43.680 --> 00:24:46.480
are the edges that
make up your DFS tree.

00:24:46.480 --> 00:24:49.867
And that's why those
are tree edges.

00:24:49.867 --> 00:24:51.450
We don't even look
at the other types.

00:24:51.450 --> 00:24:54.310
If you have an edge and DFS
followed it, it's a tree edge.

00:24:54.310 --> 00:24:56.340
Done.

00:24:56.340 --> 00:24:57.930
So these are all tree edges.

00:24:57.930 --> 00:24:59.679
We don't care about
the other definitions.

00:25:03.810 --> 00:25:06.140
So don't be ashamed to
ask questions about this

00:25:06.140 --> 00:25:08.220
because this is
hard to understand.

00:25:08.220 --> 00:25:10.410
It's an issue we're
trying to clarify here.

00:25:10.410 --> 00:25:12.370
So the point, why we're
doing that example,

00:25:12.370 --> 00:25:15.150
is to figure this out.

00:25:15.150 --> 00:25:16.770
So please do ask your questions.

00:25:16.770 --> 00:25:17.520
Yes?

00:25:17.520 --> 00:25:21.036
AUDIENCE: So is it edges that
are followed at any point

00:25:21.036 --> 00:25:23.358
during the search process?

00:25:23.358 --> 00:25:26.985
I guess they're edges
that never get touched.

00:25:26.985 --> 00:25:27.770
Right?

00:25:27.770 --> 00:25:28.395
PROFESSOR: Yep.

00:25:28.395 --> 00:25:31.320
So when I'm at C, and
I look at this edge,

00:25:31.320 --> 00:25:32.990
F is already in parents.

00:25:32.990 --> 00:25:35.622
So this edge is not going
to be followed by DFS.

00:25:35.622 --> 00:25:37.080
There are some
other types of edges

00:25:37.080 --> 00:25:38.163
that will not be followed.

00:25:38.163 --> 00:25:41.812
And we'll get to that by
the time DFS completes.

00:25:41.812 --> 00:25:44.282
Yes.

00:25:44.282 --> 00:25:48.710
AUDIENCE: You mean that
like G to C is not--

00:25:48.710 --> 00:25:50.460
PROFESSOR: You're
ruining my example, man.

00:25:50.460 --> 00:25:53.670
I'm supposed to ask
you that later on.

00:25:53.670 --> 00:25:56.360
So let's let go through it and
see what kind of edge it is.

00:25:56.360 --> 00:25:58.790
You're right, but let's
pretend we don't know that.

00:25:58.790 --> 00:26:01.720
And we'll see as
we follow the DFS.

00:26:01.720 --> 00:26:02.220
OK.

00:26:02.220 --> 00:26:04.107
So yep.

00:26:04.107 --> 00:26:05.190
That one's a forward edge.

00:26:05.190 --> 00:26:06.900
We'll deal with it later.

00:26:06.900 --> 00:26:08.380
We're here.

00:26:08.380 --> 00:26:12.510
We decided that C to
F is a forward edge.

00:26:12.510 --> 00:26:13.630
F is already in parents.

00:26:13.630 --> 00:26:15.420
So we're going to
return from DFS visit

00:26:15.420 --> 00:26:21.530
C. We're in DFS visit
V. We're done with C.

00:26:21.530 --> 00:26:24.830
Do we have anything
else to do here?

00:26:24.830 --> 00:26:31.790
So we go up to A. We're done
with B. And we look at G. A

00:26:31.790 --> 00:26:35.490
to G. Is G in parents?

00:26:35.490 --> 00:26:35.990
No.

00:26:35.990 --> 00:26:40.060
So we're going to call it.

00:26:40.060 --> 00:26:52.955
So A, B. DFS visit G.
What are G's neighbors?

00:26:52.955 --> 00:26:58.410
AUDIENCE: C.

00:26:58.410 --> 00:27:00.330
PROFESSOR: OK.

00:27:00.330 --> 00:27:05.090
So is C in parents?

00:27:07.776 --> 00:27:08.650
Actually I was wrong.

00:27:08.650 --> 00:27:09.780
Sorry.

00:27:09.780 --> 00:27:13.275
So C is in parents, so
we're not going to visit it.

00:27:13.275 --> 00:27:15.400
So let's see how the tree
looks like at this point.

00:27:20.000 --> 00:27:23.090
So it looks like this.

00:27:23.090 --> 00:27:27.995
Is C a child of G?

00:27:31.480 --> 00:27:35.270
So I'm wondering about this edge
that we chose not to follow.

00:27:35.270 --> 00:27:39.400
We followed A to G so we know
this is actually the edge.

00:27:39.400 --> 00:27:43.640
So from this edge, G to C, I'm
wondering what kind of edge

00:27:43.640 --> 00:27:44.626
it is.

00:27:49.560 --> 00:27:52.490
So C is not G's child, right?

00:27:52.490 --> 00:27:53.770
So another forward edge.

00:27:53.770 --> 00:27:54.270
Sorry.

00:27:54.270 --> 00:27:55.728
I got confused
earlier because they

00:27:55.728 --> 00:27:58.140
look the same in a drawing.

00:27:58.140 --> 00:28:02.220
So it's not a forward edge,
then it's a cross edge.

00:28:06.629 --> 00:28:08.170
There's one more
edge that we haven't

00:28:08.170 --> 00:28:10.770
talked about because it was
too early in the search.

00:28:10.770 --> 00:28:18.000
And that edge is from C
to A. So if you remember

00:28:18.000 --> 00:28:23.310
there, we were in DFS visit
C. And the first thing we did

00:28:23.310 --> 00:28:26.410
was we looked at A, we said,
hey it's already in parents,

00:28:26.410 --> 00:28:28.170
so we're not going to visit it.

00:28:28.170 --> 00:28:31.557
So DFS did not follow
the edge C to A.

00:28:31.557 --> 00:28:32.640
That edge looks like this.

00:28:32.640 --> 00:28:35.398
What kind of edge is it?

00:28:35.398 --> 00:28:37.749
Back edge.

00:28:37.749 --> 00:28:38.374
AUDIENCE: Wait.

00:28:38.374 --> 00:28:41.040
So it has to be direct
descendant in order

00:28:41.040 --> 00:28:42.946
to be a forward edge?

00:28:42.946 --> 00:28:47.810
Because they are related
through A, right?

00:28:47.810 --> 00:28:49.357
C and G?

00:28:49.357 --> 00:28:51.940
PROFESSOR: So you have to look
and which direction does it go?

00:28:51.940 --> 00:28:54.900
Does it go down the
tree or up the tree?

00:28:54.900 --> 00:29:00.460
AUDIENCE: It's going down if you
consider G to C. From G to C,

00:29:00.460 --> 00:29:02.334
so it's a cross edge.

00:29:02.334 --> 00:29:03.000
PROFESSOR: Yeah.

00:29:03.000 --> 00:29:07.139
But is C G's descendant?

00:29:07.139 --> 00:29:07.680
AUDIENCE: No.

00:29:07.680 --> 00:29:10.790
But they are related.

00:29:10.790 --> 00:29:13.090
PROFESSOR: They're
related, but they're just

00:29:13.090 --> 00:29:15.621
related because
they're in the tree.

00:29:15.621 --> 00:29:16.162
AUDIENCE: OK.

00:29:16.162 --> 00:29:18.820
So it's only
directly descendants?

00:29:18.820 --> 00:29:20.140
PROFESSOR: Yep.

00:29:20.140 --> 00:29:22.900
So DFS puts together a tree.

00:29:22.900 --> 00:29:25.910
A forward edge is a
shortcut in that tree.

00:29:25.910 --> 00:29:29.160
It lets you go
forward in the VFS.

00:29:29.160 --> 00:29:32.660
A backward edge points
to a parent in the tree,

00:29:32.660 --> 00:29:34.860
so it lets you go back in time.

00:29:34.860 --> 00:29:37.950
A cross edge takes you from
one point to another point.

00:29:37.950 --> 00:29:40.120
And it's not a forward
edge, not a backward edge.

00:29:40.120 --> 00:29:44.180
So it takes you in a
whole different world.

00:29:44.180 --> 00:29:49.500
So C, A, G, has-- A,
G is the sub-tree,

00:29:49.500 --> 00:29:51.880
and then this guy's
this other sub-tree,

00:29:51.880 --> 00:29:54.660
and they're different
little worlds.

00:29:54.660 --> 00:29:57.500
And this edge goes
from one to the other.

00:30:00.161 --> 00:30:02.660
So the algorithm to decide what
kind of an edge it is, let's

00:30:02.660 --> 00:30:04.380
put it together.

00:30:04.380 --> 00:30:08.800
Which edge do we look at, which
type do we think about first?

00:30:08.800 --> 00:30:09.400
Tree edge.

00:30:09.400 --> 00:30:10.920
So DFS followed the edge.

00:30:10.920 --> 00:30:12.940
It's a tree edge.

00:30:12.940 --> 00:30:15.980
So we have tree edges.

00:30:15.980 --> 00:30:18.730
What do we do next?

00:30:18.730 --> 00:30:25.420
So say we have an edge from
u to v. If DFS follows it,

00:30:25.420 --> 00:30:26.620
it's a tree edge.

00:30:26.620 --> 00:30:31.228
If not, then what
question do I ask myself?

00:30:31.228 --> 00:30:33.713
AUDIENCE: It could be
one of three edges then,

00:30:33.713 --> 00:30:34.877
back, forward, or cross.

00:30:34.877 --> 00:30:35.460
PROFESSOR: OK.

00:30:35.460 --> 00:30:37.380
So let's try to write
a simple algorithm

00:30:37.380 --> 00:30:38.880
so that if I ask
you this on a quiz,

00:30:38.880 --> 00:30:40.846
you can decide which is which.

00:30:40.846 --> 00:30:44.916
AUDIENCE: So I think
that you look forward

00:30:44.916 --> 00:30:47.627
if u is the parent of v.

00:30:47.627 --> 00:30:48.210
PROFESSOR: OK.

00:30:48.210 --> 00:30:58.852
So if u is a parent of v--
well, let's say ascendant.

00:30:58.852 --> 00:31:02.860
It's not just the
direct parent, but this

00:31:02.860 --> 00:31:04.180
is the right intuition.

00:31:04.180 --> 00:31:06.200
Then what kind of edge is it?

00:31:06.200 --> 00:31:08.760
AUDIENCE: Then it's
the forward edge.

00:31:08.760 --> 00:31:12.360
PROFESSOR: So the edge is from
u to v. If u is a parent of v,

00:31:12.360 --> 00:31:13.040
forward edge.

00:31:13.040 --> 00:31:13.540
Good.

00:31:17.076 --> 00:31:17.575
Otherwise?

00:31:20.960 --> 00:31:21.876
AUDIENCE: [INAUDIBLE].

00:31:25.557 --> 00:31:26.140
PROFESSOR: OK.

00:31:35.400 --> 00:31:36.429
Then?

00:31:36.429 --> 00:31:39.363
AUDIENCE: Then backward edge.

00:31:39.363 --> 00:31:40.830
Else cross edge.

00:31:48.380 --> 00:31:50.060
PROFESSOR: Does this make sense?

00:31:50.060 --> 00:31:52.130
So these are the
four types of edges.

00:31:52.130 --> 00:31:54.690
DFS takes the edge,
it's a forward edge.

00:31:54.690 --> 00:31:56.560
If not, we draw the DFS tree.

00:31:56.560 --> 00:31:59.510
And we see does
the edge go forward

00:31:59.510 --> 00:32:00.880
in the tree, forward edge.

00:32:00.880 --> 00:32:03.160
Does it go backward,
backward edge.

00:32:03.160 --> 00:32:07.935
Does it grow between completely
unrelated nodes, cross edge.

00:32:11.351 --> 00:32:11.850
OK.

00:32:11.850 --> 00:32:13.710
Now let me ask another question.

00:32:13.710 --> 00:32:16.870
Let's suppose we do
this DFS thing again,

00:32:16.870 --> 00:32:19.830
but let's suppose we do
it on an undirected graph.

00:32:19.830 --> 00:32:23.582
What types of edges do I have?

00:32:23.582 --> 00:32:26.954
Anyone remember off
the top of their heads?

00:32:26.954 --> 00:32:27.870
Don't think so, right?

00:32:27.870 --> 00:32:29.036
So let's do it and find out.

00:32:44.740 --> 00:32:51.350
So let me see where
do I get some room.

00:32:55.380 --> 00:32:55.880
Here.

00:33:02.364 --> 00:33:04.280
Let's write the tree
that's we're going to go.

00:33:04.280 --> 00:33:07.310
So let's do a VFS of this
quickly and write the tree.

00:33:07.310 --> 00:33:10.630
So we start at A, then what?

00:33:14.362 --> 00:33:14.862
Then?

00:33:18.280 --> 00:33:19.990
Then?

00:33:19.990 --> 00:33:25.445
D. E.

00:33:25.445 --> 00:33:33.637
AUDIENCE: And go back to
D. It could go from C to A.

00:33:33.637 --> 00:33:34.220
PROFESSOR: OK.

00:33:34.220 --> 00:33:38.330
So we have C to A. What
kind of edge is this?

00:33:38.330 --> 00:33:40.387
AUDIENCE: Backward edge.

00:33:40.387 --> 00:33:40.970
PROFESSOR: OK.

00:33:40.970 --> 00:33:44.550
So we still have tree edges
for sure and backward edges.

00:33:47.872 --> 00:33:51.210
AUDIENCE: How do
you get from C to A?

00:33:51.210 --> 00:33:53.570
PROFESSOR: This was supposed
to happen way before.

00:33:53.570 --> 00:33:59.644
So we went A, B, C, and
then when we were at C, oh.

00:33:59.644 --> 00:34:01.910
Sorry.

00:34:01.910 --> 00:34:04.970
My bad.

00:34:04.970 --> 00:34:07.280
So we went from A to
B, B to C, and then A

00:34:07.280 --> 00:34:09.179
was the first thing
in C's adjacency list.

00:34:09.179 --> 00:34:10.980
So we saw this back edge.

00:34:10.980 --> 00:34:14.204
So C to D, D to E, D to F.

00:34:14.204 --> 00:34:15.638
AUDIENCE: E to F?

00:34:15.638 --> 00:34:17.550
Or F to C?

00:34:17.550 --> 00:34:20.334
PROFESSOR: And then F to C.
So what kind of edge is this?

00:34:20.334 --> 00:34:21.125
AUDIENCE: Backward.

00:34:23.690 --> 00:34:26.560
PROFESSOR: So none
of these guys.

00:34:26.560 --> 00:34:32.883
And then we're all the
way back at A, right?

00:34:32.883 --> 00:34:37.521
A to-- oh.

00:34:37.521 --> 00:34:38.020
Sorry.

00:34:38.020 --> 00:34:40.800
No we're not done.

00:34:40.800 --> 00:34:50.070
So C to D, D to E, D to F, then
we're back at C. And C to G.

00:34:50.070 --> 00:34:53.719
AUDIENCE: There's supposed
to be a line between C and F?

00:34:53.719 --> 00:34:54.860
PROFESSOR: Oh, yeah.

00:34:54.860 --> 00:34:55.480
Sorry.

00:34:55.480 --> 00:34:57.410
I guess I can't copy.

00:34:57.410 --> 00:35:01.382
One, two, three, four, five,
six, seven, eight, nine.

00:35:01.382 --> 00:35:03.590
One, two, three, four, five,
six, seven, eight, nine.

00:35:03.590 --> 00:35:05.880
Now it's right.

00:35:05.880 --> 00:35:07.350
Thank you.

00:35:07.350 --> 00:35:07.850
OK.

00:35:07.850 --> 00:35:09.860
So what am I missing?

00:35:09.860 --> 00:35:18.795
Edge from C to G.
What kind of edge?

00:35:18.795 --> 00:35:20.194
AUDIENCE: C and G?

00:35:22.607 --> 00:35:23.190
PROFESSOR: OK.

00:35:23.190 --> 00:35:28.460
So we have tree edges and
we have backward edges.

00:35:28.460 --> 00:35:29.630
What do we not have?

00:35:29.630 --> 00:35:32.520
Forward edges and
cross edges, right?

00:35:32.520 --> 00:35:39.392
AUDIENCE: You need one from
A to G. A and G are related.

00:35:39.392 --> 00:35:40.600
PROFESSOR: What edge is this?

00:35:43.030 --> 00:35:43.530
Cool.

00:35:43.530 --> 00:35:44.210
Thanks.

00:35:44.210 --> 00:35:47.030
AUDIENCE: You never add
those, though, right?

00:35:47.030 --> 00:35:51.814
You just see that A was in the
parent's list, and be like, OK.

00:35:51.814 --> 00:35:52.480
PROFESSOR: Yeah.

00:35:52.480 --> 00:35:54.570
So for all the edges
that are not tree edges,

00:35:54.570 --> 00:35:57.540
DFS doesn't actually
follow them.

00:35:57.540 --> 00:35:59.720
We just care about them
because other algorithms

00:35:59.720 --> 00:36:00.620
care about them.

00:36:00.620 --> 00:36:03.640
They let you compute
fancy things on the graph.

00:36:03.640 --> 00:36:05.640
OK.

00:36:05.640 --> 00:36:09.270
So are we good with the types?

00:36:09.270 --> 00:36:13.165
So why can't I have
a forward edge?

00:36:13.165 --> 00:36:15.040
So there are two types
of edges I can't have,

00:36:15.040 --> 00:36:18.110
cross edges and forward edges.

00:36:18.110 --> 00:36:20.770
Why can't I have a forward edge?

00:36:24.109 --> 00:36:26.017
On an undirected graph?

00:36:28.880 --> 00:36:30.740
So in order to have
a forward edge,

00:36:30.740 --> 00:36:37.060
I would have to go C, D, F.
And then not follow this edge.

00:36:37.060 --> 00:36:39.410
I mean not see this edge here.

00:36:39.410 --> 00:36:42.240
Right?

00:36:42.240 --> 00:36:43.760
If this edge would
be undirected,

00:36:43.760 --> 00:36:47.520
I would say, hey, it goes from
F to C. It's a background edge.

00:36:47.520 --> 00:36:50.660
So I would have seen this edge
when I would have been in C.

00:36:50.660 --> 00:36:52.450
So I'm comparing this
tree with this tree,

00:36:52.450 --> 00:36:54.408
and trying to figure out
why they're different.

00:36:57.250 --> 00:37:00.033
How does a forward
edge look like?

00:37:00.033 --> 00:37:05.480
You have a node u, then you
have some more tree stuff.

00:37:05.480 --> 00:37:09.000
And from here, you got to v.
And then when you're at v,

00:37:09.000 --> 00:37:11.421
you didn't see the edge.

00:37:11.421 --> 00:37:11.920
Right?

00:37:11.920 --> 00:37:13.336
Because if you
would have seen it,

00:37:13.336 --> 00:37:15.330
it would have been
a background edge.

00:37:15.330 --> 00:37:18.470
So you can only see the
edge from u to v later on.

00:37:18.470 --> 00:37:21.160
So this is tree edges,
a bunch of tree edges,

00:37:21.160 --> 00:37:23.010
and this is a forward edge.

00:37:23.010 --> 00:37:24.480
In an undirected
graph, this never

00:37:24.480 --> 00:37:27.325
happens because
when you're at v,

00:37:27.325 --> 00:37:29.070
you're going to see the edge.

00:37:29.070 --> 00:37:32.120
And you're going to mark
it as a backward edge.

00:37:32.120 --> 00:37:33.550
So forward edges
can ever happen.

00:37:37.490 --> 00:37:38.210
Yes?

00:37:38.210 --> 00:37:40.130
No?

00:37:40.130 --> 00:37:42.680
Is everyone happy?

00:37:42.680 --> 00:37:43.450
So cross edges.

00:37:43.450 --> 00:37:45.400
Why can't they happen?

00:37:45.400 --> 00:37:48.070
A cross edge can never
happen because in order

00:37:48.070 --> 00:37:51.740
for a cross edge to happen,
I would have to go A, B, C,

00:37:51.740 --> 00:37:56.750
visit C's children, then go
up and go somewhere else.

00:37:56.750 --> 00:37:59.200
And then see this edge.

00:37:59.200 --> 00:38:02.420
But, hey, when I was at C,
why didn't I see this edge?

00:38:02.420 --> 00:38:03.930
Why did I only see it later?

00:38:03.930 --> 00:38:07.140
If it's an undirected graph,
I would see this edge here

00:38:07.140 --> 00:38:09.230
and it would be a forward edge.

00:38:09.230 --> 00:38:09.730
Sorry.

00:38:09.730 --> 00:38:12.580
A tree edge, because
that would take it.

00:38:12.580 --> 00:38:13.170
Yes?

00:38:13.170 --> 00:38:15.169
AUDIENCE: So is it just
when you're-- is it just

00:38:15.169 --> 00:38:17.850
because it's the way you
traverse in DFS or would it

00:38:17.850 --> 00:38:20.920
apply generally to VFS as well?

00:38:20.920 --> 00:38:24.130
PROFESSOR: VFS doesn't
have forward and backward.

00:38:24.130 --> 00:38:24.630
Yeah.

00:38:24.630 --> 00:38:27.390
VFS is completely different.

00:38:27.390 --> 00:38:31.730
So these are all DFS
terms, purely DFS.

00:38:31.730 --> 00:38:32.230
OK.

00:38:32.230 --> 00:38:34.400
So no forward edges,
no cross edges.

00:38:34.400 --> 00:38:36.930
And if you forget which
ones you can and can't have,

00:38:36.930 --> 00:38:40.830
now you know how to reason
about it quickly and remember.

00:38:40.830 --> 00:38:42.770
Yes?

00:38:42.770 --> 00:38:45.480
OK.

00:38:45.480 --> 00:38:46.440
So this is DFS.

00:38:46.440 --> 00:38:49.130
Are we all happy with DFS?

00:38:49.130 --> 00:38:51.890
Let's talk about
topological sorting then.

00:38:51.890 --> 00:38:53.180
Because it's really useful.

00:38:53.180 --> 00:38:55.400
It's one of the few algorithms
that is really useful

00:38:55.400 --> 00:38:58.330
and that you might have
to write yourself later.

00:38:58.330 --> 00:39:01.650
So suppose these are classes.

00:39:01.650 --> 00:39:03.390
So let's get back to
this oriented thing

00:39:03.390 --> 00:39:05.390
and suppose these are classes.

00:39:05.390 --> 00:39:08.670
And the edges show
prerequisites.

00:39:08.670 --> 00:39:13.590
So A is a prerequisite
of B. Like say A is 601

00:39:13.590 --> 00:39:14.880
and B is 6006.

00:39:14.880 --> 00:39:17.610
And you have to take 601
before you take 6006.

00:39:17.610 --> 00:39:21.690
Otherwise you will cry during
programming assignments.

00:39:21.690 --> 00:39:24.190
So what we want
to do is these are

00:39:24.190 --> 00:39:27.030
all the classes you
need to graduate.

00:39:27.030 --> 00:39:30.027
We need to come up with an
order in which you can take them

00:39:30.027 --> 00:39:32.610
so that when you take a class,
you took all the prerequisites.

00:39:32.610 --> 00:39:35.790
So you don't cry while
you're taking that class.

00:39:35.790 --> 00:39:37.480
How do we do that?

00:39:37.480 --> 00:39:39.435
And let's use this
graph as an example.

00:39:43.167 --> 00:39:48.477
AUDIENCE: Use a directed
graph that's acyclic?

00:39:48.477 --> 00:39:49.060
PROFESSOR: OK.

00:39:49.060 --> 00:39:52.520
Is this graph acyclic?

00:39:52.520 --> 00:39:54.247
AUDIENCE: No.

00:39:54.247 --> 00:39:54.830
PROFESSOR: OK.

00:39:54.830 --> 00:39:57.089
So what then?

00:39:57.089 --> 00:39:58.005
AUDIENCE: [INAUDIBLE].

00:40:03.190 --> 00:40:06.054
PROFESSOR: So if the
graph has a cycle,

00:40:06.054 --> 00:40:07.220
you can't solve the problem.

00:40:07.220 --> 00:40:09.432
It has no solution.

00:40:09.432 --> 00:40:11.140
AUDIENCE: It's like
those cardboard boxes

00:40:11.140 --> 00:40:13.640
that [INAUDIBLE].

00:40:13.640 --> 00:40:16.140
It's really annoying.

00:40:16.140 --> 00:40:21.015
PROFESSOR: I don't know
the cardboard box problem.

00:40:21.015 --> 00:40:21.640
AUDIENCE: Yeah.

00:40:21.640 --> 00:40:25.510
You know those cardboard
boxes with the four flaps

00:40:25.510 --> 00:40:31.110
when you close them, and
they close like-- Yeah.

00:40:31.110 --> 00:40:33.900
Those are so annoying.

00:40:33.900 --> 00:40:36.462
That's just what
this reminds me of.

00:40:36.462 --> 00:40:37.040
That's all.

00:40:37.040 --> 00:40:37.380
Continue.

00:40:37.380 --> 00:40:38.506
PROFESSOR: There's
a cycle there,

00:40:38.506 --> 00:40:40.000
so you can't just
put them in an order.

00:40:40.000 --> 00:40:40.500
Right?

00:40:40.500 --> 00:40:42.870
You have to violate the
repeating variance somehow.

00:40:42.870 --> 00:40:45.950
And you do that by
twisting the edges.

00:40:45.950 --> 00:40:50.160
So if we had classes A, B, C,
you cannot take them in any

00:40:50.160 --> 00:40:50.660
order.

00:40:50.660 --> 00:40:51.220
Right?

00:40:51.220 --> 00:40:54.790
If you take A first, you would
need C. If you take B first,

00:40:54.790 --> 00:40:58.090
you would need A. If you take
C first, you would need B.

00:40:58.090 --> 00:41:00.820
So you can't start
with any of them.

00:41:00.820 --> 00:41:03.340
So if you have a
cycle in a graph,

00:41:03.340 --> 00:41:04.580
it's not a dependency graph.

00:41:04.580 --> 00:41:07.540
You can't compute dependencies.

00:41:07.540 --> 00:41:11.040
So topological sorts only
works on cyclic graphs.

00:41:15.610 --> 00:41:19.900
So acyclic graph.

00:41:19.900 --> 00:41:21.360
And what else?

00:41:21.360 --> 00:41:25.220
So a dependency graph is
a special kind of graph.

00:41:25.220 --> 00:41:28.106
And I'm looking for
three fancy words.

00:41:28.106 --> 00:41:28.980
You already have two.

00:41:28.980 --> 00:41:31.635
So we have acyclic
and we have graph.

00:41:31.635 --> 00:41:32.135
Directed.

00:41:36.144 --> 00:41:37.560
So you have to
have a directed, so

00:41:37.560 --> 00:41:40.060
that you know which
class goes first.

00:41:40.060 --> 00:41:42.582
Needs to be acyclic,
otherwise there's no solution.

00:41:42.582 --> 00:41:44.040
Needs to be a graph,
because that's

00:41:44.040 --> 00:41:45.081
what we're talking about.

00:41:48.600 --> 00:41:50.490
So the shortening
for this is a DAG.

00:41:53.030 --> 00:41:53.530
OK.

00:41:53.530 --> 00:41:55.820
How do you compute an order?

00:41:55.820 --> 00:41:57.570
So say we remove that edge.

00:42:06.408 --> 00:42:09.767
How do we compute an order?

00:42:09.767 --> 00:42:16.134
AUDIENCE: You run DFS and
then print out the reverse.

00:42:16.134 --> 00:42:17.883
PROFESSOR: And then
print out the reverse?

00:42:17.883 --> 00:42:20.520
AUDIENCE: Of your final output.

00:42:20.520 --> 00:42:22.928
PROFESSOR: Which is?

00:42:22.928 --> 00:42:24.720
AUDIENCE: Your final output?

00:42:24.720 --> 00:42:29.180
You want me to do it on a graph?

00:42:29.180 --> 00:42:31.825
PROFESSOR: You can tell me
how to change the codes, too.

00:42:31.825 --> 00:42:34.450
So I'm not sure what-- you said
print the reverse of something,

00:42:34.450 --> 00:42:35.672
but what's that thing?

00:42:35.672 --> 00:42:37.640
AUDIENCE: So I go
down a path, right,

00:42:37.640 --> 00:42:39.517
until you've hit
all the nodes, then

00:42:39.517 --> 00:42:41.689
basically you start
from the last node

00:42:41.689 --> 00:42:44.930
you visited and print
out the reverse of that.

00:42:44.930 --> 00:42:46.350
Go back to the first node.

00:42:46.350 --> 00:42:46.933
PROFESSOR: OK.

00:42:46.933 --> 00:42:53.050
So you're saying I go
A, B, C, D, E, and then

00:42:53.050 --> 00:42:55.631
I print E, D, C, B, A?

00:42:55.631 --> 00:42:56.553
AUDIENCE: No.

00:42:56.553 --> 00:42:58.532
Because that wouldn't
hit all the nodes.

00:42:58.532 --> 00:42:59.115
PROFESSOR: OK.

00:43:02.763 --> 00:43:07.130
He's on the right track, by
the way, so that's why we're--

00:43:07.130 --> 00:43:10.700
AUDIENCE: You go
A, B, C, D, E, F,

00:43:10.700 --> 00:43:15.860
G, and you print G,
F, E, D, C, B, A.

00:43:15.860 --> 00:43:19.480
PROFESSOR: OK so we print
them in the reverse.

00:43:19.480 --> 00:43:22.250
So you're printing them in
the order in which you're

00:43:22.250 --> 00:43:24.760
done with them after DFS?

00:43:24.760 --> 00:43:25.260
No.

00:43:25.260 --> 00:43:26.968
You're printing them
in the reverse order

00:43:26.968 --> 00:43:30.090
of the order which
you visited them?

00:43:30.090 --> 00:43:33.101
So you visited A,
B, C, D, E, F, G,

00:43:33.101 --> 00:43:35.920
so you're saying print
G, F, E, D, C, B, A.

00:43:35.920 --> 00:43:37.889
AUDIENCE: Yeah.

00:43:37.889 --> 00:43:39.430
Because in lecture
wasn't it flipped,

00:43:39.430 --> 00:43:44.805
so if an arrow points from
A to B then A depends on B.

00:43:44.805 --> 00:43:47.180
And we're looking at
the other way around.

00:43:50.130 --> 00:43:51.730
In lecture, based
on the graph you

00:43:51.730 --> 00:43:55.572
gave, if the arrow goes from
A to B, then A depends on B.

00:43:55.572 --> 00:43:58.906
PROFESSOR: If the arrow
goes from A to B, then what?

00:43:58.906 --> 00:44:02.045
AUDIENCE: If you're saying A
is a prerequisite for B and G,

00:44:02.045 --> 00:44:05.450
then we just sweep from
left to right and say,

00:44:05.450 --> 00:44:06.610
I have to do this.

00:44:06.610 --> 00:44:08.309
And then those two.

00:44:08.309 --> 00:44:08.892
PROFESSOR: No.

00:44:08.892 --> 00:44:11.808
They have to--

00:44:11.808 --> 00:44:15.585
AUDIENCE: It's the order that--
because when you're doing DFS,

00:44:15.585 --> 00:44:16.440
you recurse.

00:44:16.440 --> 00:44:19.364
It's the order that they
finished the recurse.

00:44:19.364 --> 00:44:20.030
PROFESSOR: Yeah.

00:44:20.030 --> 00:44:21.250
You have the right answer.

00:44:21.250 --> 00:44:23.440
I'm just trying to build
out the annotation for it.

00:44:23.440 --> 00:44:27.510
I'm pretty sure this
is the right way.

00:44:27.510 --> 00:44:30.761
I can look at this,
but I can't promise you

00:44:30.761 --> 00:44:32.635
that this is the right
way because I coded it

00:44:32.635 --> 00:44:34.526
and it works.

00:44:34.526 --> 00:44:36.740
So no.

00:44:36.740 --> 00:44:39.990
This is the right way.

00:44:39.990 --> 00:44:40.490
Yes.

00:44:40.490 --> 00:44:42.156
This is the right way
to represent them.

00:44:42.156 --> 00:44:50.880
So forward edge
means B depends on A.

00:44:50.880 --> 00:44:51.380
OK.

00:44:51.380 --> 00:44:54.139
So let's figure
out how we do this.

00:44:54.139 --> 00:44:55.930
Let's do this in
pseudo-code and then build

00:44:55.930 --> 00:44:57.340
the intuition for it.

00:44:57.340 --> 00:45:01.200
So you said reverse of
the finishing times.

00:45:01.200 --> 00:45:04.960
So let's build a list
that has all the nodes

00:45:04.960 --> 00:45:07.190
in the order of their
finishing times.

00:45:07.190 --> 00:45:14.852
So let's build a list finished
that is empty at first.

00:45:14.852 --> 00:45:16.810
Then I'm going to add
all the nodes in the list

00:45:16.810 --> 00:45:18.080
as I'm done with them.

00:45:18.080 --> 00:45:21.420
And then I'll reverse the list.

00:45:21.420 --> 00:45:23.452
Where do I add
nodes to the list?

00:45:28.272 --> 00:45:29.718
AUDIENCE: In the check.

00:45:33.650 --> 00:45:38.366
Line 2.75.

00:45:38.366 --> 00:45:39.241
PROFESSOR: Not quite.

00:45:42.400 --> 00:45:46.814
So line 4.

00:45:46.814 --> 00:45:50.180
So I'm adding them in the order
in which I'm done with them.

00:45:50.180 --> 00:45:53.410
So when I'm about to
leave a node completely,

00:45:53.410 --> 00:45:54.576
I'll add it to that list.

00:46:02.680 --> 00:46:03.730
Which node?

00:46:03.730 --> 00:46:05.615
What's the name?

00:46:05.615 --> 00:46:08.390
AUDIENCE: V.

00:46:08.390 --> 00:46:09.420
PROFESSOR: OK.

00:46:09.420 --> 00:46:12.858
And then where can
I reverse the list?

00:46:12.858 --> 00:46:16.050
AUDIENCE: Line 4 of the first--

00:46:16.050 --> 00:46:17.300
PROFESSOR: OK.

00:46:17.300 --> 00:46:20.110
How would I do this?

00:46:20.110 --> 00:46:29.130
r dot finished dot reverse.

00:46:29.130 --> 00:46:31.203
Like this?

00:46:31.203 --> 00:46:33.090
AUDIENCE: I think
that's OK in Python.

00:46:33.090 --> 00:46:35.460
PROFESSOR: I think so, too.

00:46:35.460 --> 00:46:39.610
So this will give me
a topological sort.

00:46:39.610 --> 00:46:43.650
Let's figure out why
this works intuitively.

00:46:43.650 --> 00:46:45.820
Yes?

00:46:45.820 --> 00:46:50.330
So while we're building
the topological sort,

00:46:50.330 --> 00:46:54.480
while we're building the
inverse of the final list.

00:46:54.480 --> 00:46:56.250
So the first thing
that we put in the list

00:46:56.250 --> 00:46:59.060
is the last class
we're going to take.

00:46:59.060 --> 00:47:02.040
So as I go forward
in this graph,

00:47:02.040 --> 00:47:09.940
my VFS is going to go A, B, C,
D, E. There's nothing after E.

00:47:09.940 --> 00:47:11.920
And it's done with E.

00:47:11.920 --> 00:47:15.710
So this means there is no class
that depends on E. Otherwise,

00:47:15.710 --> 00:47:18.410
DFS would keep recursing.

00:47:18.410 --> 00:47:20.690
So E is the last class I take.

00:47:20.690 --> 00:47:23.730
If I take this last, there's
definitely no dependencies

00:47:23.730 --> 00:47:25.450
that I'm violating.

00:47:25.450 --> 00:47:26.260
All right?

00:47:26.260 --> 00:47:35.310
So it's safe to start with E.

00:47:35.310 --> 00:47:42.470
Now I'm out of E, I'm back to D.
I go from D to F, I print that.

00:47:42.470 --> 00:47:46.550
Let's not worry about
this for a little bit.

00:47:46.550 --> 00:47:52.410
And let's go back
to D. When DFS comes

00:47:52.410 --> 00:47:55.630
back, it's going
to print D. So I

00:47:55.630 --> 00:47:59.470
know that by the
time DFS is out,

00:47:59.470 --> 00:48:04.270
I printed all the classes
that depend on D. Right?

00:48:04.270 --> 00:48:06.510
So when I'm at D,
whenever I have forward

00:48:06.510 --> 00:48:08.450
edges that I
haven't visited yet,

00:48:08.450 --> 00:48:11.250
I will call DFS visit on them.

00:48:11.250 --> 00:48:16.170
DFS visit returns before
I can get out of D.

00:48:16.170 --> 00:48:20.040
So all the edges that depend
on D have been printed.

00:48:20.040 --> 00:48:20.540
Sorry.

00:48:20.540 --> 00:48:23.950
All the nodes that depend
on D have been printed.

00:48:23.950 --> 00:48:27.000
So when I get out of D, I
know that all the nodes that

00:48:27.000 --> 00:48:29.300
depend on D have
been printed, so it's

00:48:29.300 --> 00:48:33.080
safe to print D.
This is the intuition

00:48:33.080 --> 00:48:36.450
behind topological sort.

00:48:36.450 --> 00:48:41.580
So you can build sort of an
induction proof based on this.

00:48:41.580 --> 00:48:46.590
So whenever I'm here, I
assume that all the nodes

00:48:46.590 --> 00:48:49.670
that I have forward edges to
are somewhere in my results.

00:48:49.670 --> 00:48:51.770
So I can include my nodes.

00:48:51.770 --> 00:48:56.170
So this means that whenever
you put a node here,

00:48:56.170 --> 00:49:00.020
all the nodes that have
forward edges to this node

00:49:00.020 --> 00:49:03.590
have already been output.

00:49:03.590 --> 00:49:06.020
So this means that no
dependency relationships

00:49:06.020 --> 00:49:08.350
are going to be violated.

00:49:08.350 --> 00:49:08.850
OK.

00:49:08.850 --> 00:49:11.230
Let's keep building
this and see the result.

00:49:11.230 --> 00:49:14.410
So D, E, F, we get
out of B. We get out

00:49:14.410 --> 00:49:18.960
of C. What do we do here?

00:49:18.960 --> 00:49:19.800
Print C, right?

00:49:25.260 --> 00:49:27.126
What classes depend on C?

00:49:27.126 --> 00:49:33.630
D, E, and F. I had
a tree edge to D.

00:49:33.630 --> 00:49:37.400
I had DFS visit here, so I
know that all the classes that

00:49:37.400 --> 00:49:41.670
depend on C because they
depend on D have been output.

00:49:41.670 --> 00:49:44.780
And then I have a
forward edge on F.

00:49:44.780 --> 00:49:48.280
So I didn't recurse
from C to F, but I

00:49:48.280 --> 00:49:50.291
know that has been
covered somewhere.

00:49:50.291 --> 00:49:50.790
Right?

00:49:50.790 --> 00:49:54.220
Forward edge means that
I've already seen it in DFS,

00:49:54.220 --> 00:49:55.930
and that I've already
returned from it.

00:49:55.930 --> 00:49:57.760
So it has already been printed.

00:50:02.800 --> 00:50:05.670
So I'm going to write this.

00:50:05.670 --> 00:50:14.390
Now I get out of C. I get out of
B. I go into G. I get out of B,

00:50:14.390 --> 00:50:20.820
and I go into A. And I go
out of A, and I print it.

00:50:20.820 --> 00:50:21.320
OK.

00:50:21.320 --> 00:50:24.540
So I have tree edges
that I can handle.

00:50:29.020 --> 00:50:30.260
So these are all tree edges.

00:50:33.930 --> 00:50:40.310
And the reason that topological
sorting works on tree edges

00:50:40.310 --> 00:50:46.480
is that I call DFS
visit on the tree edge,

00:50:46.480 --> 00:50:49.120
and I know it returns
by the time I return.

00:50:49.120 --> 00:50:51.310
So I know that
whatever's underneath

00:50:51.310 --> 00:50:53.670
that tree has
already been printed.

00:50:53.670 --> 00:50:58.450
I have forward edges that
will just take me forward

00:50:58.450 --> 00:50:59.930
in the DFS.

00:50:59.930 --> 00:51:03.490
So I know that by the
time I return from a node,

00:51:03.490 --> 00:51:05.447
I've already returned
from all the nodes

00:51:05.447 --> 00:51:07.280
that I have forward
edges to because they're

00:51:07.280 --> 00:51:08.190
lower in the tree.

00:51:08.190 --> 00:51:08.690
Right?

00:51:08.690 --> 00:51:10.360
Forward edges work like this.

00:51:10.360 --> 00:51:11.900
So by the time
I'm out of C, I've

00:51:11.900 --> 00:51:21.240
definitely printed F. Now I have
this cross edge from G to C.

00:51:21.240 --> 00:51:27.210
A cross edge means that there
is no direct relationship here,

00:51:27.210 --> 00:51:32.250
but I've already visited C. If
there's no direct relationship,

00:51:32.250 --> 00:51:34.760
it means that for sure
I'm done visiting C

00:51:34.760 --> 00:51:39.575
and I've returned so
that I can get to G.

00:51:39.575 --> 00:51:44.410
So there's some common
parent between C and G.

00:51:44.410 --> 00:51:46.850
I'm already done with C, and
I've returned to that parent.

00:51:46.850 --> 00:51:49.450
And then I went to G.

00:51:49.450 --> 00:51:53.840
So all the nodes that are
pointed to my cross edges

00:51:53.840 --> 00:51:59.671
have also been printed
in topological sort.

00:51:59.671 --> 00:52:00.170
OK.

00:52:00.170 --> 00:52:01.560
Now what about back edges?

00:52:01.560 --> 00:52:02.915
What if I had a back edge?

00:52:05.420 --> 00:52:08.510
What if I had this back
edge between C and A?

00:52:08.510 --> 00:52:09.410
What happens then?

00:52:09.410 --> 00:52:15.590
If I had a back edge, then that
would break topological sort.

00:52:15.590 --> 00:52:16.090
Right?

00:52:16.090 --> 00:52:18.580
Because this is
saying that hey, you

00:52:18.580 --> 00:52:22.000
should print A
before you print C.

00:52:22.000 --> 00:52:24.110
But I know that I'm going
to come out of C way

00:52:24.110 --> 00:52:27.040
before I have a chance
to come out of A.

00:52:27.040 --> 00:52:30.470
So if I have a back edge,
topological sort doesn't work.

00:52:30.470 --> 00:52:33.740
When do I have a back edge?

00:52:33.740 --> 00:52:35.200
When I have a cycle.

00:52:35.200 --> 00:52:37.650
So this is why I don't
care about back edges.

00:52:37.650 --> 00:52:41.300
Back edges [INAUDIBLE] cycles.

00:52:41.300 --> 00:52:44.470
So back edge means I
have a path forward.

00:52:44.470 --> 00:52:47.120
And I have a path backward.

00:52:47.120 --> 00:52:48.060
That does a cycle.

00:52:53.820 --> 00:52:54.320
OK.

00:52:54.320 --> 00:52:57.890
There's an awful
lot of silence here.

00:52:57.890 --> 00:52:59.290
Does everything makes sense or?

00:53:02.911 --> 00:53:03.410
OK.

00:53:03.410 --> 00:53:03.993
Any questions?

00:53:06.691 --> 00:53:07.190
Nope?

00:53:07.190 --> 00:53:08.050
Everyone's happy?

00:53:10.961 --> 00:53:12.960
So you don't need to
reason about this formally.

00:53:12.960 --> 00:53:16.750
Just remember the intuition that
the reason we're printing them

00:53:16.750 --> 00:53:20.320
in this order is
the first thing you

00:53:20.320 --> 00:53:23.040
print is the last class
you're going to take.

00:53:23.040 --> 00:53:27.620
Because for sure there are
no dependencies left on it,

00:53:27.620 --> 00:53:29.380
otherwise DFS would
keep recursing.

00:53:29.380 --> 00:53:32.070
And then there's that recursive
structure that makes this work.

00:53:35.800 --> 00:53:36.300
OK.

00:53:36.300 --> 00:53:37.784
Cool.