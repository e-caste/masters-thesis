WEBVTT

00:00:00.090 --> 00:00:02.490
The following content is
provided under a Creative

00:00:02.490 --> 00:00:04.030
Commons license.

00:00:04.030 --> 00:00:06.330
Your support will help
MIT OpenCourseWare

00:00:06.330 --> 00:00:10.720
continue to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.320
To make a donation or
view additional materials

00:00:13.320 --> 00:00:17.280
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.280 --> 00:00:18.450
at ocw.mit.edu.

00:00:22.510 --> 00:00:25.940
[MUSIC PLAYING]

00:00:48.484 --> 00:00:50.150
ALAN OPPENHEIM: Last
time, we introduced

00:00:50.150 --> 00:00:52.430
the topic of digital
filter design,

00:00:52.430 --> 00:00:55.790
and we discussed two
design techniques which

00:00:55.790 --> 00:00:59.900
permitted us to obtain digital
filter designs from analog

00:00:59.900 --> 00:01:02.360
or continuous time designs.

00:01:02.360 --> 00:01:06.770
In particular, the first
technique that we discussed

00:01:06.770 --> 00:01:09.860
was basically
mapping differentials

00:01:09.860 --> 00:01:13.375
in a linear constant coefficient
differential equation

00:01:13.375 --> 00:01:17.000
to differences in a linear
constant coefficient difference

00:01:17.000 --> 00:01:18.620
equation.

00:01:18.620 --> 00:01:21.320
We found that that
corresponded basically

00:01:21.320 --> 00:01:25.070
to a mapping from the
s plane to the z plane.

00:01:25.070 --> 00:01:30.110
But we saw also that it
was not a good technique

00:01:30.110 --> 00:01:32.190
for two basic reasons.

00:01:32.190 --> 00:01:36.740
One is that it didn't correspond
to mapping the frequency

00:01:36.740 --> 00:01:41.960
characteristic from the j
omega axis to the unit circle.

00:01:41.960 --> 00:01:45.230
And second of all, and
perhaps even more serious,

00:01:45.230 --> 00:01:49.370
it didn't result in a mapping
of stable analog filters

00:01:49.370 --> 00:01:52.700
to stable digital filters.

00:01:52.700 --> 00:01:55.040
The second technique
that we discussed

00:01:55.040 --> 00:01:57.830
was the technique of
impulse and invariance,

00:01:57.830 --> 00:02:01.160
where basically, the
discrete time filter

00:02:01.160 --> 00:02:05.810
is designed by
sampling periodically

00:02:05.810 --> 00:02:09.650
the impulse response of
the continuous time filter.

00:02:09.650 --> 00:02:13.280
And we saw that what
this corresponded to

00:02:13.280 --> 00:02:16.430
was basically a
mapping of the system

00:02:16.430 --> 00:02:20.690
function for the continuous
time filter to a system

00:02:20.690 --> 00:02:26.330
function for the digital filter,
which preserved the residues

00:02:26.330 --> 00:02:32.060
and mapped the poles of the
continuous time filter at poles

00:02:32.060 --> 00:02:35.810
at s sub k to poles of
the digital filter at e

00:02:35.810 --> 00:02:38.570
to the s sub k capital T.

00:02:38.570 --> 00:02:43.040
Well, let me remind you
again of the advantages

00:02:43.040 --> 00:02:45.440
and disadvantages
of this technique

00:02:45.440 --> 00:02:47.450
by illustrating it
with a simple example.

00:02:50.420 --> 00:02:55.690
Let's take the case of a simple,
second order analog filter,

00:02:55.690 --> 00:02:58.720
let's say with one
0 and two poles,

00:02:58.720 --> 00:03:01.060
so that the analog
system function

00:03:01.060 --> 00:03:05.820
is given by S plus a divided
by S plus a squared plus

00:03:05.820 --> 00:03:07.900
b squared.

00:03:07.900 --> 00:03:10.660
For the impulse invariant
design procedure,

00:03:10.660 --> 00:03:15.550
we want to expand this into
a partial fraction expansion.

00:03:15.550 --> 00:03:20.350
And in that form, this system
function becomes a 1/2--

00:03:20.350 --> 00:03:22.090
1/2 as the residu3--

00:03:22.090 --> 00:03:25.120
divided by S plus a plus jb.

00:03:25.120 --> 00:03:31.600
The pole is then at minus a
minus jb, plus a residue of 1/2

00:03:31.600 --> 00:03:35.050
over S plus a minus
jb, in other words,

00:03:35.050 --> 00:03:39.530
a pole at minus a plus jb.

00:03:39.530 --> 00:03:40.030
All right.

00:03:40.030 --> 00:03:44.860
Well, mapping this analog system
function to the digital system

00:03:44.860 --> 00:03:49.060
function, we
maintain the residue

00:03:49.060 --> 00:03:53.350
and map the pole
at minus a minus jb

00:03:53.350 --> 00:03:56.890
to a pole in the z plane
at e to the minus a capital

00:03:56.890 --> 00:04:00.760
T e to the minus
jb capital T. So

00:04:00.760 --> 00:04:04.240
the resulting digital
transfer function

00:04:04.240 --> 00:04:07.390
has these same
residues, and it has

00:04:07.390 --> 00:04:13.330
poles which are at e to the
minus aT e to the minus jgT,

00:04:13.330 --> 00:04:18.399
and e to the minus
aT e to the plus jbT.

00:04:18.399 --> 00:04:23.320
And this system function,
we can now recombine.

00:04:23.320 --> 00:04:25.510
We can recombine the two terms.

00:04:25.510 --> 00:04:28.870
And the resulting
digital transfer function

00:04:28.870 --> 00:04:31.490
is as I've indicated here.

00:04:31.490 --> 00:04:35.380
Now, this illustrates one of
the important points, which

00:04:35.380 --> 00:04:40.150
is the fact that the
poles got mapped according

00:04:40.150 --> 00:04:43.270
to a mapping which
is of the form z

00:04:43.270 --> 00:04:47.290
equals e to the s
capital T. But notice

00:04:47.290 --> 00:04:50.770
that, in fact, the 0 didn't
get mapped in the same way.

00:04:50.770 --> 00:04:55.450
The 0 at minus a got mapped,
for this particular example,

00:04:55.450 --> 00:05:00.070
to a 0 at e to the
minus aT t cosine bT.

00:05:00.070 --> 00:05:03.820
So in fact, it's not
a mapping of S to z,

00:05:03.820 --> 00:05:07.420
although the poles of the
analog system function

00:05:07.420 --> 00:05:10.180
get mapped to poles of the
digital system function

00:05:10.180 --> 00:05:13.790
according to the mapping
z equals e to the sT.

00:05:13.790 --> 00:05:21.640
Well, what this example looks
like in the frequency domain,

00:05:21.640 --> 00:05:23.500
I've indicated here.

00:05:23.500 --> 00:05:26.920
Here is the s plane
plot of the two poles

00:05:26.920 --> 00:05:30.250
and the 0 from the
analog system function.

00:05:30.250 --> 00:05:35.320
And the result of the
mapping or the result

00:05:35.320 --> 00:05:40.180
of applying the impulse
invariant procedure

00:05:40.180 --> 00:05:46.830
are the poles and 0s, which are
indicated here in the z plane.

00:05:46.830 --> 00:05:50.400
Well, to see what happens
to the frequency response,

00:05:50.400 --> 00:05:53.340
for this particular
analog example,

00:05:53.340 --> 00:05:57.900
we have a resonance at a
frequency corresponding

00:05:57.900 --> 00:06:01.020
to the vertical
position of these poles.

00:06:01.020 --> 00:06:03.630
And that's the resonance
that we have here

00:06:03.630 --> 00:06:07.640
in the magnitude of the
analog system function.

00:06:07.640 --> 00:06:12.000
And one of the important
aspects of the impulse invariant

00:06:12.000 --> 00:06:16.860
procedure, which I pointed
out last time, is that,

00:06:16.860 --> 00:06:19.980
except for aliasing-- and
that's a big except for--

00:06:19.980 --> 00:06:24.750
except for aliasing,
the frequency response

00:06:24.750 --> 00:06:28.470
has the same general shape
in the discrete domain

00:06:28.470 --> 00:06:31.020
as it does in the
continuous domain.

00:06:31.020 --> 00:06:35.400
So the corresponding discrete
time frequency response

00:06:35.400 --> 00:06:38.070
is as I've indicated here.

00:06:38.070 --> 00:06:40.380
We have a resonance
corresponding

00:06:40.380 --> 00:06:43.470
to these pole locations.

00:06:43.470 --> 00:06:46.380
But whereas this
frequency response

00:06:46.380 --> 00:06:52.320
drops off asymptotically to 0,
this frequency response drops

00:06:52.320 --> 00:06:55.380
off to some value,
non-zero value,

00:06:55.380 --> 00:06:57.270
and then continues
back up again,

00:06:57.270 --> 00:07:02.100
basically because this frequency
response has to be periodic.

00:07:02.100 --> 00:07:06.870
But in particular, the value
which this frequency response

00:07:06.870 --> 00:07:15.140
decays to is dictated in part
by the effect of aliasing.

00:07:15.140 --> 00:07:18.830
And you can see here that
in comparing this value

00:07:18.830 --> 00:07:21.260
to this one, this is higher.

00:07:21.260 --> 00:07:23.000
And the reason it's
higher is because

00:07:23.000 --> 00:07:25.040
of the effect of aliasing.

00:07:25.040 --> 00:07:28.610
So there is the advantage
to impulse invariance

00:07:28.610 --> 00:07:33.260
that the frequency axis
is a scaled replica

00:07:33.260 --> 00:07:35.630
of the analog frequency axis.

00:07:35.630 --> 00:07:38.750
But then there's a
distortion that's introduced,

00:07:38.750 --> 00:07:42.460
which is the effect of aliasing.

00:07:42.460 --> 00:07:45.280
There's another
technique which is

00:07:45.280 --> 00:07:47.770
a very important
and commonly used

00:07:47.770 --> 00:07:52.420
technique for designing
digital filters, which

00:07:52.420 --> 00:07:55.210
avoids the problem the
problem of aliasing,

00:07:55.210 --> 00:07:58.480
but it avoids that
problem at a price.

00:07:58.480 --> 00:08:05.350
That technique is referred to
as the bilinear transformation

00:08:05.350 --> 00:08:10.960
and basically involves mapping
from the s plane to the z plane

00:08:10.960 --> 00:08:14.770
by applying-- by
relating s and z

00:08:14.770 --> 00:08:17.830
according to the bilinear
transformation, a bilinear

00:08:17.830 --> 00:08:20.110
transformation.

00:08:20.110 --> 00:08:22.930
There, in fact, is
an interesting way

00:08:22.930 --> 00:08:25.780
of deriving this
technique, which

00:08:25.780 --> 00:08:28.750
is somewhat similar
to the technique

00:08:28.750 --> 00:08:31.660
involving mapping
differentials to differences.

00:08:31.660 --> 00:08:34.090
But of course, the
bilinear transformation

00:08:34.090 --> 00:08:37.940
will turn out to be a much
more useful technique.

00:08:37.940 --> 00:08:39.340
This technique can be derived--

00:08:39.340 --> 00:08:41.200
and we won't be going
through this in detail

00:08:41.200 --> 00:08:45.040
here, although we
do in the text--

00:08:45.040 --> 00:08:49.390
this can be derived
essentially by beginning

00:08:49.390 --> 00:08:53.830
with a continuous time
differential equation,

00:08:53.830 --> 00:08:58.160
integrating the equation to
obtain an integral equation,

00:08:58.160 --> 00:09:01.570
and then approximating
the integrals,

00:09:01.570 --> 00:09:03.250
using the trapezoidal rule.

00:09:03.250 --> 00:09:06.250
In other words, replacing
the integrals by sums,

00:09:06.250 --> 00:09:09.010
using the trapezoidal
rule for integration,

00:09:09.010 --> 00:09:13.300
the resulting equation is
then a difference equation.

00:09:13.300 --> 00:09:16.090
And that difference
equation will then

00:09:16.090 --> 00:09:20.230
represent the digital filter,
and that digital filter,

00:09:20.230 --> 00:09:23.320
as it turns out, can be related
back to the analog filter.

00:09:23.320 --> 00:09:25.570
The system functions
can be related

00:09:25.570 --> 00:09:28.970
through a transformation
from s to z,

00:09:28.970 --> 00:09:32.910
which is, in fact, the
bilinear transformation.

00:09:32.910 --> 00:09:37.130
So the technique
then is basically

00:09:37.130 --> 00:09:40.520
to begin with an
analog system function,

00:09:40.520 --> 00:09:44.900
convert that to a
digital system function,

00:09:44.900 --> 00:09:51.230
and do that by replacing s
by a bilinear transformation,

00:09:51.230 --> 00:09:53.060
where the bilinear
transformation

00:09:53.060 --> 00:09:55.700
is as I've indicated here.

00:09:55.700 --> 00:09:59.480
There's a parameter, capital
T, that I've introduced,

00:09:59.480 --> 00:10:02.720
and it's a parameter
that comes in, basically,

00:10:02.720 --> 00:10:06.950
because of what's involved
in applying the integration

00:10:06.950 --> 00:10:10.370
or applying the trapezoidal
rule to implementing

00:10:10.370 --> 00:10:12.380
the integration.

00:10:12.380 --> 00:10:17.300
But this then is the general
form of the transformation.

00:10:17.300 --> 00:10:21.380
Or expressing z instead
as a function of s,

00:10:21.380 --> 00:10:25.340
we obtain z equals
1 plus sT over 2

00:10:25.340 --> 00:10:28.980
divided by 1 minus sT over 2.

00:10:28.980 --> 00:10:31.950
So one important
aspect of this then,

00:10:31.950 --> 00:10:35.130
which, in fact, is different
than the impulse invariant

00:10:35.130 --> 00:10:39.720
procedure, is that it,
in fact, does correspond

00:10:39.720 --> 00:10:42.240
to a mapping from s to z.

00:10:42.240 --> 00:10:45.120
It's a mapping of the s
plane to the z plane, which

00:10:45.120 --> 00:10:48.760
is not quite what the
impulse invariant method is.

00:10:48.760 --> 00:10:53.970
Well, recalling that there are
two guidelines that we set down

00:10:53.970 --> 00:10:58.930
last time, we'd like to
verify, first of all,

00:10:58.930 --> 00:11:02.430
whether the bilinear
transformation in fact

00:11:02.430 --> 00:11:06.210
preserves the characteristics,
the frequency characteristics--

00:11:06.210 --> 00:11:09.090
that is, whether it maps
from the j omega axis

00:11:09.090 --> 00:11:11.250
to the unit circle, first.

00:11:11.250 --> 00:11:15.000
And second of all, does it
map stable analog filters

00:11:15.000 --> 00:11:17.730
to stable digital filters?

00:11:17.730 --> 00:11:21.150
Well, let's look at the
first question first.

00:11:21.150 --> 00:11:24.510
Let's look at the unit
circle and inquire as to what

00:11:24.510 --> 00:11:29.580
part of the s plane the
unit circle came from.

00:11:29.580 --> 00:11:35.380
So we have, then, z equals e to
the j omega on the unit circle.

00:11:35.380 --> 00:11:42.245
And so we want to inquire
as to what values of s

00:11:42.245 --> 00:11:46.610
land on the unit circle through
the bilinear transformation.

00:11:46.610 --> 00:11:49.210
And we do that simply
by substituting

00:11:49.210 --> 00:11:54.110
z equals e to the
j omega, so that s

00:11:54.110 --> 00:11:57.060
is equal to 2 over
capital T times 1 minus e

00:11:57.060 --> 00:12:02.030
to the minus j omega divided by
1 plus e to the minus j omega.

00:12:02.030 --> 00:12:09.270
And now we can change
this term and likewise

00:12:09.270 --> 00:12:13.065
the denominator term
by factoring out e

00:12:13.065 --> 00:12:18.630
to the minus j omega over 2.

00:12:18.630 --> 00:12:21.980
And then this
numerator term becomes

00:12:21.980 --> 00:12:27.260
e to the plus j
omega over 2 minus

00:12:27.260 --> 00:12:32.190
e to the minus j omega over 2.

00:12:32.190 --> 00:12:34.920
And we recognize
this numerator then

00:12:34.920 --> 00:12:38.490
as 2j times sine omega over 2.

00:12:38.490 --> 00:12:42.360
Well, likewise, we can carry
out a similar manipulation

00:12:42.360 --> 00:12:44.580
with the denominator term.

00:12:44.580 --> 00:12:48.240
The result then is that
this can be rewritten

00:12:48.240 --> 00:12:54.090
as 2 over capital T times j
times the tangent of omega

00:12:54.090 --> 00:12:55.980
over 2.

00:12:55.980 --> 00:13:00.840
Well, since omega
ranges from 0 to 2 pi,

00:13:00.840 --> 00:13:05.460
this is always a real
number, tangent omega over 2.

00:13:05.460 --> 00:13:10.290
And consequently, we can rewrite
this as j times a real number

00:13:10.290 --> 00:13:12.310
capital Omega.

00:13:12.310 --> 00:13:12.810
All right.

00:13:12.810 --> 00:13:14.080
Well, what does that say?

00:13:14.080 --> 00:13:18.000
It says that if z is
on the unit circle,

00:13:18.000 --> 00:13:23.040
then s is going to be of the
form j times a real number.

00:13:23.040 --> 00:13:26.490
And that has to have been,
then, the j omega axis.

00:13:26.490 --> 00:13:33.090
So s equal to j omega means z
equals e to the j omega, where

00:13:33.090 --> 00:13:37.650
capital Omega and little
omega are related by capital

00:13:37.650 --> 00:13:41.310
Omega equal to 2
over capital T times

00:13:41.310 --> 00:13:44.820
the tangent of
little omega over 2.

00:13:44.820 --> 00:13:48.990
Well, that says that,
indeed, the j omega axis

00:13:48.990 --> 00:13:52.260
gets mapped to the unit
circle, and vice versa.

00:13:52.260 --> 00:13:57.090
And in fact, the
entire j omega axis

00:13:57.090 --> 00:14:01.300
gets mapped to exactly once
around the unit circle.

00:14:01.300 --> 00:14:06.850
Well, let's look at the mapping
in a little more detail.

00:14:06.850 --> 00:14:12.970
Here we have the s plane,
and here we have the z plane.

00:14:12.970 --> 00:14:17.710
We have the relationship between
the j omega axis and the unit

00:14:17.710 --> 00:14:24.010
circle, that the j omega axis
gets mapped to the unit circle.

00:14:24.010 --> 00:14:29.680
And in fact, as capital Omega
runs from minus infinity

00:14:29.680 --> 00:14:39.090
to plus infinity, we map exactly
once around the unit circle.

00:14:39.090 --> 00:14:42.800
Now, that's an important
point for two reasons.

00:14:42.800 --> 00:14:46.760
One is that, obviously, there's
no aliasing involved anymore,

00:14:46.760 --> 00:14:51.740
because the entire j
omega axis ended up once

00:14:51.740 --> 00:14:52.760
around the unit circle.

00:14:52.760 --> 00:14:54.218
That is, there was
nothing that got

00:14:54.218 --> 00:14:57.230
added on to something else that
got added on to something else,

00:14:57.230 --> 00:15:01.500
as it did with the
impulse invariant method.

00:15:01.500 --> 00:15:07.200
The second point is that
that axis is infinitely long.

00:15:07.200 --> 00:15:11.020
The unit circle only has
a finite circumference.

00:15:11.020 --> 00:15:13.650
So clearly, something
has to happen.

00:15:13.650 --> 00:15:17.520
Something has to be distorted
in order to fit all of that

00:15:17.520 --> 00:15:19.590
onto just this little bit.

00:15:19.590 --> 00:15:23.430
In particular,
the mapping, if we

00:15:23.430 --> 00:15:27.060
draw it, between little
omega, angular frequency

00:15:27.060 --> 00:15:30.420
around the unit circle, and
distance along the j omega

00:15:30.420 --> 00:15:34.680
axis, looks as I've indicated
here, which, of course, is

00:15:34.680 --> 00:15:37.250
a nonlinear curve.

00:15:37.250 --> 00:15:40.810
Well, let me return
to that in a second.

00:15:40.810 --> 00:15:43.850
An additional point about
the bilinear transformation,

00:15:43.850 --> 00:15:49.000
which I'll state simply and
leave it to you to verify,

00:15:49.000 --> 00:15:51.460
is that the bilinear
transformation has

00:15:51.460 --> 00:15:55.930
the property that the
left 1/2 of the s plane

00:15:55.930 --> 00:15:59.500
gets mapped to the interior
of the unit circle,

00:15:59.500 --> 00:16:01.630
and the right half
of the s plane

00:16:01.630 --> 00:16:05.450
gets mapped to the exterior
of the unit circle.

00:16:05.450 --> 00:16:08.900
Well, that's good,
because that says

00:16:08.900 --> 00:16:11.840
that, if we have poles or 0s--

00:16:11.840 --> 00:16:14.630
but poles is what we really
care about right now--

00:16:14.630 --> 00:16:17.570
we have poles in the
left 1/2 of the s plane,

00:16:17.570 --> 00:16:20.190
they'll end up inside
the unit circle.

00:16:20.190 --> 00:16:23.030
So if we have a
stable analog filter,

00:16:23.030 --> 00:16:26.120
we'll end up with a
stable digital filter.

00:16:26.120 --> 00:16:28.550
If we have an unstable
analog filter,

00:16:28.550 --> 00:16:31.640
corresponding to poles on
the right 1/2 of the s plane,

00:16:31.640 --> 00:16:35.090
then we'll end up with an
unstable digital filter,

00:16:35.090 --> 00:16:39.110
corresponding to poles
outside the unit circle.

00:16:39.110 --> 00:16:39.610
All right.

00:16:39.610 --> 00:16:45.790
Well, now, returning to the
mapping of the j omega axis

00:16:45.790 --> 00:16:50.110
to digital frequency, the
mapping from analog frequency

00:16:50.110 --> 00:16:53.770
to digital frequency, one
of the important aspects

00:16:53.770 --> 00:16:58.600
of the bilinear transformation
is that that mapping ends up

00:16:58.600 --> 00:17:02.340
as a nonlinear mapping.

00:17:02.340 --> 00:17:04.800
Well, what are the
consequences of that?

00:17:04.800 --> 00:17:09.540
Let's take a look at it
in a little more detail.

00:17:09.540 --> 00:17:12.899
And in addition to pointing
out some of the problems

00:17:12.899 --> 00:17:17.550
that that raises, this
offers us an opportunity

00:17:17.550 --> 00:17:21.990
to indicate how, in
fact, this distortion can

00:17:21.990 --> 00:17:25.680
be taken into account in
implementing a digital filter

00:17:25.680 --> 00:17:27.490
design.

00:17:27.490 --> 00:17:34.060
So here is the frequency mapping
of the bilinear transformation.

00:17:34.060 --> 00:17:35.940
This is digital frequency.

00:17:35.940 --> 00:17:38.280
Here is analog frequency.

00:17:38.280 --> 00:17:42.300
And this curve, of course,
goes out to infinity in capital

00:17:42.300 --> 00:17:46.530
Omega and asymptotically
approaches pi, as it does that,

00:17:46.530 --> 00:17:47.820
in little omega.

00:17:47.820 --> 00:17:51.000
That says that the top
1/2 of the j omega axis

00:17:51.000 --> 00:17:55.260
gets mapped to the upper
1/2 of the unit circle.

00:17:55.260 --> 00:18:00.780
Well, suppose that we had,
say, an analog filter frequency

00:18:00.780 --> 00:18:06.720
response that was, let's
say, linear in frequency.

00:18:06.720 --> 00:18:10.830
Would the corresponding
digital frequency response

00:18:10.830 --> 00:18:13.150
also be linear in frequency?

00:18:13.150 --> 00:18:16.650
Well, the answer to that,
unfortunately, is no.

00:18:16.650 --> 00:18:22.800
In other words, a frequency
characteristic along this axis

00:18:22.800 --> 00:18:25.750
will get distorted
as it gets reflected

00:18:25.750 --> 00:18:28.500
through this nonlinear curve.

00:18:28.500 --> 00:18:32.670
For example, let's
look specifically

00:18:32.670 --> 00:18:39.120
at a linear analog
frequency characteristic,

00:18:39.120 --> 00:18:42.450
as I've indicated here
which might, for example, be

00:18:42.450 --> 00:18:44.820
the frequency response
of a differentiator.

00:18:44.820 --> 00:18:47.610
That, in fact, is the
kind of frequency response

00:18:47.610 --> 00:18:50.700
that a differentiator
might have.

00:18:50.700 --> 00:18:55.140
As we reflect that through
this nonlinear curve,

00:18:55.140 --> 00:18:57.750
because of the fact
that that's nonlinear,

00:18:57.750 --> 00:19:02.640
we don't maintain the linearity
of the analog frequency

00:19:02.640 --> 00:19:04.050
response.

00:19:04.050 --> 00:19:06.990
Now, if it happened that this
was the kind of frequency

00:19:06.990 --> 00:19:10.080
response that we wanted,
we could get that

00:19:10.080 --> 00:19:12.880
from an analog differentiator.

00:19:12.880 --> 00:19:17.160
But more typically, what
we might be interested in

00:19:17.160 --> 00:19:20.310
is a digital
differentiator which

00:19:20.310 --> 00:19:23.740
would have, say, a linear
frequency characteristic.

00:19:23.740 --> 00:19:28.200
And one of the important aspects
of the bilinear transformation

00:19:28.200 --> 00:19:33.540
is that we couldn't design that
by designing-- by mapping over

00:19:33.540 --> 00:19:38.610
an analog differentiator to
a digital differentiator,

00:19:38.610 --> 00:19:40.770
using the bilinear
transformation.

00:19:40.770 --> 00:19:43.800
Now, that's in contrast to
the impulse invariant design

00:19:43.800 --> 00:19:49.050
procedure, where, in fact,
for an impulse invariant

00:19:49.050 --> 00:19:53.220
design, if we have a
band-limited filter that

00:19:53.220 --> 00:19:56.700
is linear over some part
of the frequency band,

00:19:56.700 --> 00:19:58.710
impulse invariance
would maintain

00:19:58.710 --> 00:20:01.690
the linearity of the
frequency characteristics.

00:20:01.690 --> 00:20:05.070
So that's an important
distinction between these two

00:20:05.070 --> 00:20:09.890
methods and, in fact, a drawback
to the bilinear transformation.

00:20:09.890 --> 00:20:12.560
Well, where might we
be able to tolerate

00:20:12.560 --> 00:20:14.700
this kind of a
nonlinear distortion

00:20:14.700 --> 00:20:16.760
in the frequency axis?

00:20:16.760 --> 00:20:23.830
One place we could is when
the desired digital filter

00:20:23.830 --> 00:20:27.490
is piecewise constant,
in which case

00:20:27.490 --> 00:20:31.390
that will get reflected into
a piecewise constant analog

00:20:31.390 --> 00:20:32.350
filter.

00:20:32.350 --> 00:20:34.630
And let me indicate
that more explicitly.

00:20:42.130 --> 00:20:47.970
Let's suppose that we were
interested in designing

00:20:47.970 --> 00:20:52.150
a digital filter, which
was a low pass filter.

00:20:52.150 --> 00:20:56.260
Here's the magnitude axis,
and here's the frequency axis.

00:20:56.260 --> 00:21:00.310
And the digital low
pass filter was unity,

00:21:00.310 --> 00:21:06.080
say, in the passband, a rapid
cutoff at the passband edge,

00:21:06.080 --> 00:21:07.810
and then 0.

00:21:07.810 --> 00:21:12.750
Well, clearly, this
part being constant

00:21:12.750 --> 00:21:16.530
gets reflected through this
nonlinear frequency curve

00:21:16.530 --> 00:21:22.590
into a constant analog
frequency characteristic.

00:21:22.590 --> 00:21:25.750
Similarly, the
stopband gets reflected

00:21:25.750 --> 00:21:30.930
into a constant amplitude,
in this case, 0,

00:21:30.930 --> 00:21:33.090
in the analog
frequency response.

00:21:33.090 --> 00:21:37.680
And what's the effect of
this nonlinear distortion

00:21:37.680 --> 00:21:39.540
in the frequency axis?

00:21:39.540 --> 00:21:44.280
The only effect that it has
is that the cutoff frequency

00:21:44.280 --> 00:21:49.140
of the filter or, in the more
general case, the frequencies

00:21:49.140 --> 00:21:54.810
at which the piecewise constant
characteristic changes from one

00:21:54.810 --> 00:22:00.870
piece to another gets changed
according to this frequency

00:22:00.870 --> 00:22:02.560
warping characteristic.

00:22:02.560 --> 00:22:08.070
So this cutoff frequency gets
converted into a new cutoff

00:22:08.070 --> 00:22:11.670
frequency, where the
analog cutoff frequency is

00:22:11.670 --> 00:22:14.370
related to the digital
cutoff frequency

00:22:14.370 --> 00:22:17.620
according to that curve.

00:22:17.620 --> 00:22:23.540
Now-- and so one of the
things that that says is that

00:22:23.540 --> 00:22:31.040
for the filter design, if
we wanted to design an ideal

00:22:31.040 --> 00:22:35.330
digital filter, an ideal
digital low pass filter,

00:22:35.330 --> 00:22:39.140
then to decide on the
specifications for the ideal

00:22:39.140 --> 00:22:42.590
analog filter, we
would simply pre-warp--

00:22:42.590 --> 00:22:47.210
what's called pre-warping--
pre-warp the cutoff frequency

00:22:47.210 --> 00:22:51.080
to an analog cutoff frequency,
which would get unraveled back

00:22:51.080 --> 00:22:55.310
to the right cutoff frequency
when we go through the bilinear

00:22:55.310 --> 00:22:57.410
transformation.

00:22:57.410 --> 00:23:00.700
Now, we know that there
aren't ideal filters.

00:23:00.700 --> 00:23:03.230
And so, in fact,
we're, in general,

00:23:03.230 --> 00:23:07.310
faced with the problem of
approximating a characteristic

00:23:07.310 --> 00:23:08.540
like that.

00:23:08.540 --> 00:23:11.750
But if the specifications
for the filter

00:23:11.750 --> 00:23:16.410
are still piecewise
constant, then, in fact,

00:23:16.410 --> 00:23:21.690
we can still concentrate
just simply on a pre-warping

00:23:21.690 --> 00:23:24.060
of the critical frequencies.

00:23:24.060 --> 00:23:28.560
And the piecewise
constant portions

00:23:28.560 --> 00:23:30.480
of the frequency
response will then

00:23:30.480 --> 00:23:32.490
fall in the correct places.

00:23:32.490 --> 00:23:38.400
And let me illustrate that by
showing a more realistic kind

00:23:38.400 --> 00:23:40.120
of filter frequency response.

00:23:53.250 --> 00:23:55.740
Well, that's pretty close.

00:23:55.740 --> 00:23:56.370
All right.

00:23:56.370 --> 00:24:02.580
Here we have what would be more
typical of the digital filter

00:24:02.580 --> 00:24:05.940
that we would design
and implement--

00:24:05.940 --> 00:24:09.070
some allowed tolerance
in the passband,

00:24:09.070 --> 00:24:13.680
some allowed tolerance in the
stopband, a passband cutoff

00:24:13.680 --> 00:24:17.680
frequency, and a stopband
cutoff frequency.

00:24:17.680 --> 00:24:21.900
Well, if that was our
desired digital filter,

00:24:21.900 --> 00:24:23.700
then how would
those specifications

00:24:23.700 --> 00:24:26.500
translate to an analog filter?

00:24:26.500 --> 00:24:30.780
Well, if the deviation
in the digital filter

00:24:30.780 --> 00:24:34.860
was between 1 and 1
minus delta sub p,

00:24:34.860 --> 00:24:38.880
then that would get
converted into specifications

00:24:38.880 --> 00:24:41.970
on the analog filter,
likewise between 1 and 1

00:24:41.970 --> 00:24:44.880
minus delta sub p.

00:24:44.880 --> 00:24:47.820
The passband cutoff
edge would get

00:24:47.820 --> 00:24:50.840
reflected through
this nonlinear curve

00:24:50.840 --> 00:24:54.390
to a new analog
cutoff frequency.

00:24:54.390 --> 00:24:58.350
Likewise, the transition
region would get reflected

00:24:58.350 --> 00:25:00.780
into a new transition region.

00:25:00.780 --> 00:25:03.540
If this frequency
characteristic was, let's say,

00:25:03.540 --> 00:25:06.210
linear in the transition
region, of course,

00:25:06.210 --> 00:25:09.120
it wouldn't end up linear
in this transition region.

00:25:09.120 --> 00:25:11.430
But who cares?

00:25:11.430 --> 00:25:14.160
The stopband edge
would get reflected

00:25:14.160 --> 00:25:16.170
into a new stopband edge.

00:25:16.170 --> 00:25:19.950
And finally, the
stopband specifications,

00:25:19.950 --> 00:25:22.200
let's say, delta
sub s, would get

00:25:22.200 --> 00:25:26.710
mapped to the same stopband
specifications, delta sub s.

00:25:26.710 --> 00:25:30.090
Furthermore, notice
that if, let's say,

00:25:30.090 --> 00:25:32.580
we had an optimum
filter which turns out

00:25:32.580 --> 00:25:36.450
to be equal ripple for
the digital case, then

00:25:36.450 --> 00:25:40.590
that would correspond to
an equal ripple filter

00:25:40.590 --> 00:25:42.000
in the analog case.

00:25:42.000 --> 00:25:45.420
Or said another way, if
we were able to design

00:25:45.420 --> 00:25:47.850
an equal ripple
analog filter, then

00:25:47.850 --> 00:25:50.220
map through the bilinear
transformation, that

00:25:50.220 --> 00:25:55.480
would likewise result in an
equal ripple digital filter.

00:25:55.480 --> 00:26:01.050
So the important point
here then is that we can,

00:26:01.050 --> 00:26:05.280
for piecewise constant
frequency characteristics

00:26:05.280 --> 00:26:09.000
and specifications, it really
is only the critical frequencies

00:26:09.000 --> 00:26:11.280
that we care about, the edge
of the passband, the edge

00:26:11.280 --> 00:26:13.960
of the stopband, and in the
multiple band case, of course,

00:26:13.960 --> 00:26:15.990
there will be a number of those.

00:26:15.990 --> 00:26:20.670
By pre-warping those through
this arctangent curve

00:26:20.670 --> 00:26:25.770
into the corresponding
analog critical frequencies,

00:26:25.770 --> 00:26:30.600
if this filter is then designed
and mapped to a digital filter,

00:26:30.600 --> 00:26:33.060
using the bilinear
transformation,

00:26:33.060 --> 00:26:35.910
then the passband
and stopband edges

00:26:35.910 --> 00:26:39.240
will fall at the
frequencies that we want.

00:26:39.240 --> 00:26:43.680
And this point again
will be emphasized

00:26:43.680 --> 00:26:51.750
in the next lecture, when I
show a design example comparing

00:26:51.750 --> 00:26:55.060
impulse invariance in the
bilinear transformation.

00:26:55.060 --> 00:27:01.110
So the key point then about
the bilinear transformation

00:27:01.110 --> 00:27:05.460
is that it avoids the problem
of aliasing at a price.

00:27:05.460 --> 00:27:08.130
The price is that there's a
distortion in the frequency

00:27:08.130 --> 00:27:09.090
axis.

00:27:09.090 --> 00:27:13.650
And so consequently, we can only
use the bilinear transformation

00:27:13.650 --> 00:27:17.460
to design filters that can
tolerate that distortion.

00:27:17.460 --> 00:27:21.450
Typically, that means designing
piecewise constant digital

00:27:21.450 --> 00:27:21.950
filters.

00:27:24.410 --> 00:27:24.910
All right.

00:27:24.910 --> 00:27:32.260
Well, that basically concludes
the discussion of the design

00:27:32.260 --> 00:27:38.080
techniques that correspond to
mapping analog filter designs

00:27:38.080 --> 00:27:41.110
to digital filter designs.

00:27:41.110 --> 00:27:44.590
There is one final
class of techniques

00:27:44.590 --> 00:27:49.450
that I would like to just
comment on somewhat briefly.

00:27:49.450 --> 00:27:53.380
And that is the class of
techniques that correspond

00:27:53.380 --> 00:27:55.780
to algorithmic design.

00:27:55.780 --> 00:28:00.730
Now, there are algorithmic
design procedures

00:28:00.730 --> 00:28:02.690
for analog filters.

00:28:02.690 --> 00:28:06.970
And the same
algorithmic procedures

00:28:06.970 --> 00:28:09.760
can likewise be used
for digital filters.

00:28:09.760 --> 00:28:12.770
Since we have to go through
an algorithmic procedure--

00:28:12.770 --> 00:28:16.830
in fact, there is no
advantage, in that case,

00:28:16.830 --> 00:28:19.330
to first designing
the analog filter

00:28:19.330 --> 00:28:22.150
and then mapping that over
to the digital filter.

00:28:22.150 --> 00:28:24.650
Rather, for these
algorithmic techniques,

00:28:24.650 --> 00:28:27.490
it makes more sense to
just simply apply them

00:28:27.490 --> 00:28:31.460
directly to the design
of a digital filter.

00:28:31.460 --> 00:28:34.030
Well, there are a number
of techniques, actually

00:28:34.030 --> 00:28:39.940
a fairly long list, many of them
simple modifications of others.

00:28:39.940 --> 00:28:44.650
There are only two that I want
to point to in this lecture.

00:28:44.650 --> 00:28:47.590
When we talk about the design
of finite impulse response

00:28:47.590 --> 00:28:51.190
filters, there are some
additional algorithmic design

00:28:51.190 --> 00:28:54.400
procedures that we'll point to.

00:28:54.400 --> 00:28:57.910
Well, the first algorithmic
design procedure,

00:28:57.910 --> 00:29:01.930
which I am restricting,
in my discussion here,

00:29:01.930 --> 00:29:06.260
to the design of infinite
impulse response filters,

00:29:06.260 --> 00:29:10.630
the first is simply
designing the filter

00:29:10.630 --> 00:29:14.800
to minimize the mean square
error between the desired

00:29:14.800 --> 00:29:17.410
frequency characteristic,
the desired frequency

00:29:17.410 --> 00:29:22.340
response, and the actual
frequency response.

00:29:22.340 --> 00:29:25.690
So let's assume that we
have some desired frequency

00:29:25.690 --> 00:29:29.080
response, H sub d
of e to the j omega.

00:29:29.080 --> 00:29:33.070
We would like to match
that with the frequency

00:29:33.070 --> 00:29:39.100
response of the rational
transfer function.

00:29:39.100 --> 00:29:43.360
It, of course, isn't
possible to attempt

00:29:43.360 --> 00:29:47.180
to do that at an arbitrary
number of frequencies.

00:29:47.180 --> 00:29:52.450
So we can pick out some set
of frequencies, omega sub

00:29:52.450 --> 00:29:56.710
i, at which we would
like to minimize

00:29:56.710 --> 00:29:59.530
the error between
the desired frequency

00:29:59.530 --> 00:30:04.100
response and the actual
frequency response.

00:30:04.100 --> 00:30:07.310
The error, then,
which we'll be using,

00:30:07.310 --> 00:30:10.240
or one error which
is used, is the error

00:30:10.240 --> 00:30:13.310
that corresponds to minimization
of the mean square error

00:30:13.310 --> 00:30:18.320
is the mean square difference
between the magnitude

00:30:18.320 --> 00:30:23.150
of the actual transfer
function and the magnitude

00:30:23.150 --> 00:30:26.670
of the desired
transfer function.

00:30:26.670 --> 00:30:31.880
So this error, then, summed over
the frequency points at which

00:30:31.880 --> 00:30:36.740
we specify the desired
frequency response, this error,

00:30:36.740 --> 00:30:39.320
m is to be minimized.

00:30:39.320 --> 00:30:42.260
Well, how do we pick H?

00:30:42.260 --> 00:30:47.190
Well, the general form for H
is as a rational function--

00:30:47.190 --> 00:30:49.370
that's what we've been
restricting ourselves

00:30:49.370 --> 00:30:51.560
to throughout the discussion--

00:30:51.560 --> 00:30:56.660
the rational function of z,
and expressed, for example,

00:30:56.660 --> 00:31:00.830
in cascade form, involving
second order sections,

00:31:00.830 --> 00:31:05.060
that is, two coefficients
for the 0s and two

00:31:05.060 --> 00:31:09.290
coefficients for the poles,
with capital K sections

00:31:09.290 --> 00:31:11.240
all together.

00:31:11.240 --> 00:31:13.970
So basically what the
procedure then consists

00:31:13.970 --> 00:31:16.370
of-- it's somewhat brute force--

00:31:16.370 --> 00:31:20.720
is to specify the
order of the filter.

00:31:20.720 --> 00:31:23.240
We then have a set
of coefficients

00:31:23.240 --> 00:31:26.030
which we need to solve for.

00:31:26.030 --> 00:31:34.130
We have a set of equations
which result from minimizing

00:31:34.130 --> 00:31:36.960
this error function.

00:31:36.960 --> 00:31:40.050
And by solving that
set of equations,

00:31:40.050 --> 00:31:46.130
by minimizing this
error, what results then

00:31:46.130 --> 00:31:48.350
are values for the
parameters, which

00:31:48.350 --> 00:31:50.750
provide the parameters
for the filter

00:31:50.750 --> 00:31:53.520
that we want to implement.

00:31:53.520 --> 00:31:57.060
Well, one of the issues
with this method,

00:31:57.060 --> 00:32:00.600
one of the difficulties with
it, of course, is that--

00:32:00.600 --> 00:32:02.340
and you can kind of
imagine that this

00:32:02.340 --> 00:32:04.020
is what's going to happen--

00:32:04.020 --> 00:32:09.570
is that, if you take
this rational function

00:32:09.570 --> 00:32:14.430
and put it into this equation
and minimize this error,

00:32:14.430 --> 00:32:16.020
you end up with a
set of equations

00:32:16.020 --> 00:32:19.500
for the a sub k's, b sub
k, c sub k, and d sub k,

00:32:19.500 --> 00:32:22.870
but it's a set of
nonlinear equations.

00:32:22.870 --> 00:32:25.740
And basically what the
algorithmic part of this design

00:32:25.740 --> 00:32:29.640
procedure amounts to
is algorithmically

00:32:29.640 --> 00:32:33.910
solving this nonlinear
set of equations.

00:32:33.910 --> 00:32:38.160
Well, let me just illustrate,
with one simple example,

00:32:38.160 --> 00:32:43.710
how this procedure-- what
type of filter this procedure

00:32:43.710 --> 00:32:44.580
might lead to.

00:32:44.580 --> 00:32:47.730
I don't want to, obviously,
go through all the details

00:32:47.730 --> 00:32:49.780
of solving the equations.

00:32:49.780 --> 00:32:53.650
But let's just quickly
look at an example.

00:32:53.650 --> 00:32:59.730
This is an example incidentally
that is taken from a paper

00:32:59.730 --> 00:33:03.870
by Professor Kenneth Steiglitz,
at Princeton University.

00:33:03.870 --> 00:33:06.600
And the objective
here was to design

00:33:06.600 --> 00:33:09.000
what's called a
format filter, which

00:33:09.000 --> 00:33:11.610
is used for speech synthesis.

00:33:11.610 --> 00:33:15.990
And the frequency
characteristic--

00:33:15.990 --> 00:33:18.120
the aspects of the
frequency characteristic

00:33:18.120 --> 00:33:23.640
that were important were to
have peaks at this frequency

00:33:23.640 --> 00:33:26.455
and this frequency
and this frequency--

00:33:26.455 --> 00:33:28.080
those are the peaks
that, incidentally,

00:33:28.080 --> 00:33:31.140
correspond to the resonances
of the vocal tract--

00:33:31.140 --> 00:33:35.580
and to have valleys in
between those peaks.

00:33:35.580 --> 00:33:39.360
Well, one of the things that you
can see from the kind of filter

00:33:39.360 --> 00:33:42.390
that we're talking
about designing here

00:33:42.390 --> 00:33:46.750
is that this isn't
piecewise constant.

00:33:46.750 --> 00:33:49.410
And in fact, it's
not band-limited.

00:33:49.410 --> 00:33:52.770
And it tends to have-- it's
not arbitrary, of course,

00:33:52.770 --> 00:33:56.700
but it's a much more general
frequency characteristic

00:33:56.700 --> 00:33:59.790
shape than we had
been talking about

00:33:59.790 --> 00:34:03.270
in discussing the previous
methods, in particular,

00:34:03.270 --> 00:34:05.960
than we had been talking about
in discussing the bilinear

00:34:05.960 --> 00:34:08.310
transformation.

00:34:08.310 --> 00:34:10.920
Well, the procedure
that was used, then,

00:34:10.920 --> 00:34:17.760
was to specify the values of
the desired frequency response

00:34:17.760 --> 00:34:20.100
and to try to specify
them in such a way

00:34:20.100 --> 00:34:23.100
that the frequency
characteristic was more

00:34:23.100 --> 00:34:27.929
or less forced to go
through the proper values

00:34:27.929 --> 00:34:29.980
at the important frequencies.

00:34:29.980 --> 00:34:32.940
So what was specified,
then, was a point here.

00:34:32.940 --> 00:34:34.620
The frequency
response was specified

00:34:34.620 --> 00:34:38.670
to have that value
there, one here to get

00:34:38.670 --> 00:34:40.889
us heading toward
the resonance, three

00:34:40.889 --> 00:34:46.250
points at the peak of the
resonance there, three points

00:34:46.250 --> 00:34:49.770
to force the frequency
response back down again,

00:34:49.770 --> 00:34:51.270
another three to
bring it back up

00:34:51.270 --> 00:34:55.530
for the second resonance, a few
points distributed along here

00:34:55.530 --> 00:35:00.420
to provide a general
characteristic to tend

00:35:00.420 --> 00:35:04.080
toward the next resonance,
three points at this resonance,

00:35:04.080 --> 00:35:07.110
and then a few points to have
the frequency response taper

00:35:07.110 --> 00:35:09.350
off.

00:35:09.350 --> 00:35:14.990
Well, what was used was a total
of three second order sections.

00:35:14.990 --> 00:35:18.860
And the resulting frequency
response that was obtained

00:35:18.860 --> 00:35:23.910
is what is shown
here in solid lines.

00:35:23.910 --> 00:35:25.940
And you can see
that, in fact, that's

00:35:25.940 --> 00:35:30.530
a reasonably good fit to the
points that were specified.

00:35:30.530 --> 00:35:35.570
This particular example I
chose to illustrate primarily,

00:35:35.570 --> 00:35:39.890
because it is one of the
harder examples involving

00:35:39.890 --> 00:35:42.500
the minimization of
mean square error.

00:35:42.500 --> 00:35:48.830
And in fact, in terms of
computer time on an IBM 36065,

00:35:48.830 --> 00:35:52.280
this particular example
required approximately 2 and 1/2

00:35:52.280 --> 00:35:53.280
minutes.

00:35:53.280 --> 00:35:57.030
So that's a reasonable
amount of computation,

00:35:57.030 --> 00:36:00.200
but one of the
important aspects to it

00:36:00.200 --> 00:36:04.400
is that it allows the design,
and it allowed the design,

00:36:04.400 --> 00:36:08.240
of a somewhat general
frequency shape,

00:36:08.240 --> 00:36:10.970
frequency characteristic.

00:36:10.970 --> 00:36:11.470
All right.

00:36:11.470 --> 00:36:15.670
So that is one
algorithmic method.

00:36:15.670 --> 00:36:18.580
And it, in fact,
is a good method.

00:36:18.580 --> 00:36:21.520
It's one of the methods
that is commonly used,

00:36:21.520 --> 00:36:23.050
particularly when
the frequency--

00:36:23.050 --> 00:36:24.670
when some of the other methods--

00:36:24.670 --> 00:36:27.550
the bilinear transformation
or impulse invariance

00:36:27.550 --> 00:36:32.530
can't be used, because the
filter isn't of a simple form.

00:36:32.530 --> 00:36:36.700
But one of the major
disadvantages to it

00:36:36.700 --> 00:36:40.840
is the fact that the
equations that result

00:36:40.840 --> 00:36:42.790
are not linear equations.

00:36:42.790 --> 00:36:45.610
And in general, solving
nonlinear equations

00:36:45.610 --> 00:36:49.970
is a fairly difficult
algorithmic job.

00:36:49.970 --> 00:36:53.300
Well, there's an
alternative to that,

00:36:53.300 --> 00:36:58.250
which is a method which is
commonly referred to as least

00:36:58.250 --> 00:37:01.790
squares inverse design.

00:37:01.790 --> 00:37:06.900
And in that design
procedure, we can

00:37:06.900 --> 00:37:12.540
imagine specifying a
desired impulse response.

00:37:12.540 --> 00:37:19.490
And in this case, we restrict
the filter transfer function

00:37:19.490 --> 00:37:24.430
to have no 0s and only poles.

00:37:24.430 --> 00:37:27.510
Well, it turns out-- and
I don't want to elaborate

00:37:27.510 --> 00:37:28.890
on the details--

00:37:28.890 --> 00:37:32.490
but basically, the way
this procedure is set up

00:37:32.490 --> 00:37:39.120
is to consider a system
whose system function is

00:37:39.120 --> 00:37:45.320
the inverse of H of z, so that
that system is in all 0 system,

00:37:45.320 --> 00:37:48.500
and then choose as an
input to that system

00:37:48.500 --> 00:37:51.290
the desired unit
sample response.

00:37:51.290 --> 00:37:56.660
Now, we have the desired unit
sample response is the input.

00:37:56.660 --> 00:38:00.140
We've got the
reciprocal of the filter

00:38:00.140 --> 00:38:06.950
that we're going to implement
in this as the system function.

00:38:06.950 --> 00:38:11.900
And if, in fact, the
realized unit sample response

00:38:11.900 --> 00:38:15.920
was exactly equal to the desired
unit sample response, what

00:38:15.920 --> 00:38:18.360
would the output be?

00:38:18.360 --> 00:38:21.180
Well, it would be a unit
sample, because this

00:38:21.180 --> 00:38:25.590
would be exactly the inverse
of this unit sample response.

00:38:25.590 --> 00:38:29.670
Well, let's think of
the output as g of n.

00:38:29.670 --> 00:38:36.390
And ideally, g of n should
be an impulse, a unit sample.

00:38:36.390 --> 00:38:40.560
Well, in general, of course,
it won't be, since H sub d of n

00:38:40.560 --> 00:38:44.530
we won't be able to fit exactly
by a model of that form.

00:38:44.530 --> 00:38:47.610
So let's consider
the error, which

00:38:47.610 --> 00:38:50.165
is the mean square
difference between g

00:38:50.165 --> 00:38:53.280
of n and a unit sample.

00:38:53.280 --> 00:38:57.150
And that then is the
error that we minimize.

00:38:57.150 --> 00:39:00.930
So the idea behind the
least squares inverse design

00:39:00.930 --> 00:39:07.410
is basically to design the
inverse to the desired unit

00:39:07.410 --> 00:39:10.590
sample response, do
that by minimizing

00:39:10.590 --> 00:39:13.710
the mean square error
between the output

00:39:13.710 --> 00:39:16.590
of this inverse system
and the desired output.

00:39:16.590 --> 00:39:21.030
And the desired output, of
course, is a unit sample.

00:39:21.030 --> 00:39:24.300
Well, there's the
legitimate question

00:39:24.300 --> 00:39:28.680
as to whether that is a
reasonable error criterion

00:39:28.680 --> 00:39:29.730
to use.

00:39:29.730 --> 00:39:33.360
It's, of course, a possible
error criterion to use.

00:39:33.360 --> 00:39:35.310
But one could ask,
why in the world

00:39:35.310 --> 00:39:38.160
would you want to set
up the problem that way?

00:39:38.160 --> 00:39:40.200
Well, there's a
very good reason.

00:39:40.200 --> 00:39:43.250
The reason is that,
if you do that,

00:39:43.250 --> 00:39:48.820
minimize this error in
terms of these coefficients,

00:39:48.820 --> 00:39:52.360
the equations that result
are linear equations.

00:39:52.360 --> 00:39:55.990
And linear equations are
simple equations to solve,

00:39:55.990 --> 00:39:58.340
as opposed to
nonlinear equations.

00:39:58.340 --> 00:40:01.180
So this is a technique
that, in fact, turns out

00:40:01.180 --> 00:40:06.190
to be a good technique for
a wide variety of filters.

00:40:06.190 --> 00:40:09.100
It has the important
advantage that it

00:40:09.100 --> 00:40:12.340
leads to a set of
linear equations,

00:40:12.340 --> 00:40:16.330
as opposed to the minimization
of mean square error,

00:40:16.330 --> 00:40:19.430
which leads to a set
of nonlinear equations.

00:40:19.430 --> 00:40:21.730
Well, this is just
a very quick glimpse

00:40:21.730 --> 00:40:25.210
at two algorithmic
design procedures.

00:40:25.210 --> 00:40:28.000
As I said previously,
there are some others,

00:40:28.000 --> 00:40:30.070
which we won't be going
into, some of which

00:40:30.070 --> 00:40:31.840
are described in the text.

00:40:31.840 --> 00:40:36.610
And there are a few related to
finite impulse response filters

00:40:36.610 --> 00:40:39.820
that we'll be discussing
in a number of lectures.

00:40:39.820 --> 00:40:42.940
In the next lecture,
what I would like to do

00:40:42.940 --> 00:40:48.790
is review the impulse invariant
and bilinear design procedures,

00:40:48.790 --> 00:40:51.670
since those are the
two major design

00:40:51.670 --> 00:40:55.240
procedures for infinite
impulse response filters,

00:40:55.240 --> 00:40:58.800
review those two procedures
through a design example.

00:40:58.800 --> 00:40:59.300
Thank you.

00:41:04.100 --> 00:41:07.150
[MUSIC PLAYING]