WEBVTT

00:00:00.000 --> 00:00:02.490
The following content is
provided under a Creative

00:00:02.490 --> 00:00:04.059
Commons license.

00:00:04.059 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.720
continue to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.350
To make a donation or
view additional materials

00:00:13.350 --> 00:00:17.290
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.290 --> 00:00:18.294
at ocw.mit.edu.

00:00:26.493 --> 00:00:27.410
HARI BALAKRISHNAN: Hi.

00:00:27.410 --> 00:00:28.670
My name is Hari Balakrishnan.

00:00:28.670 --> 00:00:30.380
I'm your replacement professor.

00:00:30.380 --> 00:00:32.240
You guys know about
replacement referees?

00:00:32.240 --> 00:00:32.843
AUDIENCE: Yes.

00:00:32.843 --> 00:00:33.760
HARI BALAKRISHNAN: No.

00:00:33.760 --> 00:00:36.080
So I'm the other
professor in the class.

00:00:36.080 --> 00:00:39.910
And I generally start with
materials that's a little bit

00:00:39.910 --> 00:00:40.410
later.

00:00:40.410 --> 00:00:41.840
But what we thought
we'd do today

00:00:41.840 --> 00:00:44.720
is to talk about this
Audiocom library.

00:00:44.720 --> 00:00:46.220
So before I get
started and show you

00:00:46.220 --> 00:00:49.550
how to use this and all the
different ways in which things

00:00:49.550 --> 00:00:52.190
will break because it's
something the real world,

00:00:52.190 --> 00:00:53.550
let me see a show of hands.

00:00:53.550 --> 00:00:56.720
How many people have tried to
install or run or do something

00:00:56.720 --> 00:00:58.230
with it?

00:00:58.230 --> 00:01:00.450
OK, how many people
don't have any idea

00:01:00.450 --> 00:01:02.470
of what I'm talking about?

00:01:02.470 --> 00:01:03.290
OK.

00:01:03.290 --> 00:01:05.770
And how many people have managed
to get something to work?

00:01:05.770 --> 00:01:07.940
By "work," it's if you got
the preamble to decode,

00:01:07.940 --> 00:01:09.880
it means something is working.

00:01:09.880 --> 00:01:13.110
All right how many
people have got nothing?

00:01:13.110 --> 00:01:14.580
OK.

00:01:14.580 --> 00:01:16.050
Well, it'll all work.

00:01:16.050 --> 00:01:19.830
It's just a question of figuring
out how to get it to work.

00:01:19.830 --> 00:01:21.185
OK, so here's the story.

00:01:25.640 --> 00:01:27.980
In order to do something
practical with all the theory

00:01:27.980 --> 00:01:29.772
that you're learning,
it's important to try

00:01:29.772 --> 00:01:31.160
to implement something.

00:01:31.160 --> 00:01:34.307
Now, the theory we're learning
applies to a wide range

00:01:34.307 --> 00:01:35.390
of communication channels.

00:01:35.390 --> 00:01:38.210
It applies to radio.

00:01:38.210 --> 00:01:43.580
It applies to wired links--
you know, ethernets or cables.

00:01:43.580 --> 00:01:49.460
It applies to optical links
like infrared or free-space

00:01:49.460 --> 00:01:50.990
optical links.

00:01:50.990 --> 00:01:53.420
And it also applies to audio.

00:01:53.420 --> 00:01:56.150
And we've decided to
use audio as the vehicle

00:01:56.150 --> 00:01:59.730
to bring these ideas into
the lab for two reasons.

00:01:59.730 --> 00:02:02.480
The first and most
important reason

00:02:02.480 --> 00:02:05.380
is that it turns out it's the
easiest piece of hardware.

00:02:05.380 --> 00:02:07.130
It's the most convenient
piece of hardware

00:02:07.130 --> 00:02:09.181
that everybody has access to.

00:02:09.181 --> 00:02:10.639
All you actually
need is a computer

00:02:10.639 --> 00:02:12.620
with a microphone and a speaker.

00:02:12.620 --> 00:02:15.470
And in fact, I would imagine
that in the next couple

00:02:15.470 --> 00:02:17.550
of years, it'll run
on this thing too.

00:02:17.550 --> 00:02:20.330
So you could write apps on
this that will make this work.

00:02:20.330 --> 00:02:24.380
Already, we have stuff working
on an Android and iPhone

00:02:24.380 --> 00:02:26.518
to do much of the stuff.

00:02:26.518 --> 00:02:28.310
So the first one is
just-- it's everywhere.

00:02:28.310 --> 00:02:29.120
Everybody has it.

00:02:29.120 --> 00:02:31.660
You don't have to do
anything special to get it.

00:02:31.660 --> 00:02:34.160
The second is that it turns out
it actually illustrates many

00:02:34.160 --> 00:02:35.910
of the problems that
we're talking about--

00:02:35.910 --> 00:02:42.280
noise and this idea of how
linear time-invariant systems--

00:02:42.280 --> 00:02:44.330
an understanding of linear
time-invariant systems

00:02:44.330 --> 00:02:49.520
applies to what we're trying to
build to communication channels

00:02:49.520 --> 00:02:53.030
and how you use the ideas
you've learned about LTI systems

00:02:53.030 --> 00:02:56.308
to improve the performance
of whatever you implement.

00:02:59.060 --> 00:03:01.920
I'm going to restrict myself
to this Audiocom system,

00:03:01.920 --> 00:03:04.490
but these ideas apply
across the board.

00:03:04.490 --> 00:03:07.988
So let me tell you how
this system does its job.

00:03:07.988 --> 00:03:10.030
And this goes back to what
Professor Verghese was

00:03:10.030 --> 00:03:11.920
telling you before.

00:03:11.920 --> 00:03:13.900
Ultimately, all
of the information

00:03:13.900 --> 00:03:17.720
is modulated on
top of a carrier.

00:03:17.720 --> 00:03:21.939
And a carrier, as you
know, are sinusoid.

00:03:29.763 --> 00:03:36.310
So time goes this way, and
this is the amplitude, or which

00:03:36.310 --> 00:03:38.303
we also call the voltage.

00:03:38.303 --> 00:03:39.720
So it's a
time-invariant waveform.

00:03:43.990 --> 00:03:46.440
What your receiver
is capable-- so

00:03:46.440 --> 00:03:48.490
the transmitter is
capable of generating

00:03:48.490 --> 00:03:51.410
these kinds of waveforms
at different frequencies.

00:03:51.410 --> 00:03:59.860
So this might be, for example,
1 kilohertz or 1,000 hertz.

00:03:59.860 --> 00:04:01.240
We can go up to--

00:04:01.240 --> 00:04:04.420
I've got mine to work up to 20
kilohertz, which is fortunate

00:04:04.420 --> 00:04:06.820
because I can't hear it.

00:04:06.820 --> 00:04:10.795
And there's a wide range of
frequencies this could work in.

00:04:10.795 --> 00:04:12.700
In the lab, I found
that things tend

00:04:12.700 --> 00:04:15.360
to work between 1 kilohertz and
only about 3 or 4 kilohertz.

00:04:15.360 --> 00:04:17.829
So that's the range
we're talking about.

00:04:17.829 --> 00:04:22.350
So you pick a carrier waveform
for your transmission.

00:04:22.350 --> 00:04:24.730
What the receiver's
capable of doing is--

00:04:24.730 --> 00:04:25.910
it's a digital receiver.

00:04:25.910 --> 00:04:29.140
So what it's capable of
doing is receiving data,

00:04:29.140 --> 00:04:32.020
receiving signals from the
sound card at a certain number

00:04:32.020 --> 00:04:34.090
of samples per second.

00:04:34.090 --> 00:04:37.540
We're going to call
that the sampling rate.

00:04:37.540 --> 00:04:39.660
We've used this term before.

00:04:39.660 --> 00:04:46.060
The sampling rate
can be anything.

00:04:46.060 --> 00:04:47.890
By default in the
system, we've picked

00:04:47.890 --> 00:04:52.570
the highest possible sampling
rate of 48 kilohertz.

00:04:52.570 --> 00:04:54.670
In some cases, you might
have to yank it down.

00:04:54.670 --> 00:04:56.980
You might have to go
as low as 8 kilohertz.

00:04:56.980 --> 00:04:58.840
But 48 kilohertz seems
to work in the lab.

00:04:58.840 --> 00:05:02.493
It works on a bunch of
machines that I've looked at.

00:05:02.493 --> 00:05:03.410
So we have two things.

00:05:03.410 --> 00:05:06.720
We have the 1 kilohertz,
which is the carrier waveform.

00:05:06.720 --> 00:05:09.020
We'll use the
notation FC for that.

00:05:09.020 --> 00:05:11.980
And we can receive
samples at 48 kilohertz.

00:05:11.980 --> 00:05:13.480
And that's how the
transmitter also,

00:05:13.480 --> 00:05:16.270
when it wants to send
stuff on the air,

00:05:16.270 --> 00:05:17.400
it picks a sampling rate.

00:05:17.400 --> 00:05:18.733
It's going to pick 48 kilohertz.

00:05:18.733 --> 00:05:22.210
The receiver and sender need
to agree on the sampling rate.

00:05:22.210 --> 00:05:24.052
What happens then is
very straightforward.

00:05:24.052 --> 00:05:25.510
If you have a
carrier waveform that

00:05:25.510 --> 00:05:27.730
looks like this, what
1 kilohertz means

00:05:27.730 --> 00:05:30.940
is that we do the cycle
1,000 times a second, which

00:05:30.940 --> 00:05:36.520
means that one period of the
cycle is 1/1000th of a second,

00:05:36.520 --> 00:05:37.773
or 1 millisecond.

00:05:42.980 --> 00:05:47.430
Now, if I sample this at
48,000, or 48 kilohertz,

00:05:47.430 --> 00:05:51.190
or 48,000 times a second,
in one of these periods,

00:05:51.190 --> 00:05:53.330
how many samples do I get?

00:05:53.330 --> 00:05:54.865
AUDIENCE: [INAUDIBLE]

00:05:54.865 --> 00:05:57.490
HARI BALAKRISHNAN: This is where
you have to tell me something.

00:06:00.920 --> 00:06:01.713
Sorry?

00:06:01.713 --> 00:06:02.640
AUDIENCE: 48.

00:06:02.640 --> 00:06:03.880
HARI BALAKRISHNAN: 48.

00:06:03.880 --> 00:06:04.380
Great.

00:06:04.380 --> 00:06:06.320
So I sample at 48,000
times a second.

00:06:06.320 --> 00:06:09.150
Each of these things is 1/1000th
of a second, so I get 48.

00:06:09.150 --> 00:06:12.450
What that means is that
we pick a sample here.

00:06:12.450 --> 00:06:13.440
We pick a sample here.

00:06:13.440 --> 00:06:15.360
We pick a sample here.

00:06:15.360 --> 00:06:20.640
1, 2, 3, 4, 5, 6, 7, 8, 9,
10, 11, 12, and we keep going.

00:06:20.640 --> 00:06:22.560
12, 12, et cetera.

00:06:22.560 --> 00:06:25.290
So we get 48, OK?

00:06:25.290 --> 00:06:29.980
So if I were to send a pure
sinusoid at the receiver--

00:06:29.980 --> 00:06:32.730
and the way the
sinusoid is transmitted

00:06:32.730 --> 00:06:36.570
is by providing these
samples, each sample

00:06:36.570 --> 00:06:39.270
being equal to this voltage
value picked from this curve.

00:06:39.270 --> 00:06:40.890
And I send each
of those samples,

00:06:40.890 --> 00:06:42.810
and each of those in
our implementation

00:06:42.810 --> 00:06:45.030
is a floating-point number, OK?

00:06:45.030 --> 00:06:46.740
Like a 32-bit
floating-point number.

00:06:46.740 --> 00:06:48.000
I pick a number here, 0.

00:06:48.000 --> 00:06:49.542
And then I pick
something here, which

00:06:49.542 --> 00:06:52.445
is the value of the sinusoid
at this point in time,

00:06:52.445 --> 00:06:54.570
and this, and this, and
this, and all the way down.

00:06:54.570 --> 00:06:56.190
And I send those samples.

00:06:56.190 --> 00:06:58.740
The receiver is going to be
listening at 48 kilohertz

00:06:58.740 --> 00:07:01.320
and picking up whatever it's
getting on the audio channel.

00:07:01.320 --> 00:07:04.040
And that's what it's
going to be assuming.

00:07:04.040 --> 00:07:05.790
That's what it's going
to assume was sent.

00:07:05.790 --> 00:07:07.207
Of course, in the
real world, if I

00:07:07.207 --> 00:07:08.850
send at 1 volt, what
might be received

00:07:08.850 --> 00:07:11.220
is 0.01 volts, or 0.2
volts, or whatever,

00:07:11.220 --> 00:07:16.950
because signals may,
in fact, lose amplitude

00:07:16.950 --> 00:07:19.150
as you transmit
them over the air.

00:07:19.150 --> 00:07:20.880
So that's the overall context.

00:07:20.880 --> 00:07:23.625
I'm going to start by showing
you a few things here.

00:07:27.430 --> 00:07:31.690
The first thing I'll show
is this grapher program

00:07:31.690 --> 00:07:33.290
that actually is
part of the package.

00:07:33.290 --> 00:07:36.330
But you need some GTK
toolkits for this to work.

00:07:36.330 --> 00:07:40.990
So you need this for the lab,
but this is just a useful test.

00:07:40.990 --> 00:07:43.010
If I transmit a
waveform, this program

00:07:43.010 --> 00:07:46.580
assumes that I'm transmitting
data at 1 kilohertz.

00:07:46.580 --> 00:07:50.390
If I send data at 1 kilohertz--
and this is a pure sinusoid.

00:07:50.390 --> 00:07:53.000
Let me do that I'll explain
its parameters in a bit.

00:08:01.347 --> 00:08:02.329
[TONE PLAYS]

00:08:02.329 --> 00:08:08.050
You can see that what's going
on here is if I'm silent,

00:08:08.050 --> 00:08:10.660
the points get
demodulated at plus 1

00:08:10.660 --> 00:08:12.490
and minus 1 that
correspond to the top

00:08:12.490 --> 00:08:14.510
and the bottom of the waveform.

00:08:14.510 --> 00:08:17.510
[CLAPPING]

00:08:17.510 --> 00:08:21.042
And if I make a noise, the
effect of noise get visible.

00:08:21.042 --> 00:08:23.500
And in fact, you can see that
sometimes the guy on the left

00:08:23.500 --> 00:08:26.315
goes to the right,
and vice versa, OK?

00:08:26.315 --> 00:08:27.940
So that's actually
a very visual effect

00:08:27.940 --> 00:08:29.607
of what noise does
to your transmission.

00:08:29.607 --> 00:08:31.120
I'm going to show this again.

00:08:31.120 --> 00:08:33.700
I'm going to do this again so
you can see what's going on.

00:08:33.700 --> 00:08:35.330
As the amount of
noise increases,

00:08:35.330 --> 00:08:36.789
you can see that-- you
can imagine that what's

00:08:36.789 --> 00:08:38.372
going on here in the
signal-- and this

00:08:38.372 --> 00:08:40.120
is called bipolar
signaling, where

00:08:40.120 --> 00:08:45.520
you might send bit 0 as a
particular kind of sinusoid,

00:08:45.520 --> 00:08:48.220
and a bit 1 at the other
way, as the other kind.

00:08:48.220 --> 00:08:50.617
So the idea would be that the
0's get mapped to the left.

00:08:50.617 --> 00:08:51.950
The 1's get mapped to the right.

00:08:51.950 --> 00:08:53.200
And as we increase
the amount of noise,

00:08:53.200 --> 00:08:55.180
you can start to see
that they cross over,

00:08:55.180 --> 00:08:58.263
and we'd be making
errors in our estimation.

00:09:03.939 --> 00:09:04.890
[TONE PLAYS]

00:09:04.890 --> 00:09:06.200
So things are working fine now.

00:09:06.200 --> 00:09:10.280
But as I [CLAPS] make noise,
or as you start talking,

00:09:10.280 --> 00:09:11.922
and you create
additional noise, we're

00:09:11.922 --> 00:09:13.880
going to start to see
the effects of the noise.

00:09:13.880 --> 00:09:16.250
And this is annoying, so
I'm going to turn it off.

00:09:16.250 --> 00:09:16.760
OK?

00:09:16.760 --> 00:09:19.460
So that's the first order
way in which you determine

00:09:19.460 --> 00:09:21.020
that things are working.

00:09:21.020 --> 00:09:23.455
You don't need to use the
graphing program to do that.

00:09:23.455 --> 00:09:25.205
And this is actually
annoying to the eyes,

00:09:25.205 --> 00:09:27.980
so let me turn that off too.

00:09:27.980 --> 00:09:30.740
So you run, and the
documentation we've given you

00:09:30.740 --> 00:09:34.300
tells you how you go about step
by step trying to debug this.

00:09:34.300 --> 00:09:36.730
So let me tell you what
these options mean.

00:09:36.730 --> 00:09:38.762
It's all written
up, so you don't

00:09:38.762 --> 00:09:39.970
have to take notes right now.

00:09:39.970 --> 00:09:42.490
Everything is there.

00:09:42.490 --> 00:09:45.850
In that command
line, the dash little

00:09:45.850 --> 00:09:48.940
s 256 refers to the
number of samples per bit.

00:09:48.940 --> 00:09:51.050
I'll get to that
point in a second.

00:09:51.050 --> 00:09:54.550
The dash capital S 1
means that we send--

00:09:54.550 --> 00:09:56.230
capital S is the kind of source.

00:09:56.230 --> 00:09:59.050
You know, it's something about
the nature of the source.

00:09:59.050 --> 00:10:01.450
Capital S 1 means that
my entire information

00:10:01.450 --> 00:10:03.940
is sent as 1's, which
means that I'm sending

00:10:03.940 --> 00:10:05.320
a pure sinusoidal carrier.

00:10:05.320 --> 00:10:08.636
All I'm doing is sending
the sinusoidal carrier.

00:10:08.636 --> 00:10:10.930
Dash g just means,
show me some graphs.

00:10:10.930 --> 00:10:14.530
And n refers to the number
of bits I wish to send, OK?

00:10:14.530 --> 00:10:16.500
So these are all
documented, and you

00:10:16.500 --> 00:10:18.050
don't have to worry about it.

00:10:18.050 --> 00:10:21.430
So what we're going to do
now is actually to show you

00:10:21.430 --> 00:10:26.450
what happens when we
transmit some data.

00:10:26.450 --> 00:10:28.450
This is actually the very
first task in the lab.

00:10:28.450 --> 00:10:31.148
You transmit some
data, and you plot what

00:10:31.148 --> 00:10:32.440
the noise histogram looks like.

00:10:38.200 --> 00:10:39.640
[TONE PLAYS]

00:10:41.512 --> 00:10:42.970
So what we did was
we sent a couple

00:10:42.970 --> 00:10:48.200
hundred bits at some appropriate
number of samples per bit.

00:10:48.200 --> 00:10:50.200
You know, the way you
tell if stuff's working is

00:10:50.200 --> 00:10:51.350
that line there.

00:10:51.350 --> 00:10:54.790
If it received the preamble--
and there's this long preamble.

00:10:54.790 --> 00:10:56.590
I'll explain what
that word means.

00:10:56.590 --> 00:10:59.980
But if you receive the preamble,
it means that stuff's working.

00:10:59.980 --> 00:11:02.697
If you didn't get the
preamble, it means that--

00:11:02.697 --> 00:11:04.780
it doesn't mean that things
are completely broken.

00:11:04.780 --> 00:11:07.660
It just means you got to
do a little bit more work.

00:11:07.660 --> 00:11:09.760
We also plot out the
signal-to-noise ratio

00:11:09.760 --> 00:11:10.830
of the transmission.

00:11:10.830 --> 00:11:11.830
And that shows up there.

00:11:11.830 --> 00:11:16.780
If that signal-to-noise ratio is
something like 20 dB or 15 dB,

00:11:16.780 --> 00:11:18.280
things are fine.

00:11:18.280 --> 00:11:21.340
This system doesn't really
work below 15 or 10 decibels.

00:11:21.340 --> 00:11:23.470
It means that the
signal-to-noise ratio

00:11:23.470 --> 00:11:25.000
is too low, which
means you either

00:11:25.000 --> 00:11:26.625
have to yank up the
volume, or you have

00:11:26.625 --> 00:11:28.030
to go to a quieter location.

00:11:28.030 --> 00:11:30.070
Or-- and I'll explain
this-- you have

00:11:30.070 --> 00:11:32.890
to change some of the
parameters in the program.

00:11:32.890 --> 00:11:36.050
Now, what does this
graph look like?

00:11:36.050 --> 00:11:38.990
We'll ignore this for a second.

00:11:38.990 --> 00:11:42.260
For this number of samples, that
was the normal distribution.

00:11:42.260 --> 00:11:45.817
At 0.44, you could look at it,
and it sort of looks Gaussian.

00:11:45.817 --> 00:11:46.900
It's not quite a Gaussian.

00:11:46.900 --> 00:11:48.970
I'll explain why
in a little bit.

00:11:48.970 --> 00:11:51.730
What this picture show is
this is what the noise--

00:11:51.730 --> 00:11:54.085
this is what the received
samples look like.

00:11:54.085 --> 00:11:58.850
And it has a mean value
that's in the center.

00:11:58.850 --> 00:12:02.740
And then it's kind of got
a shape on both sides.

00:12:02.740 --> 00:12:06.610
This picture in the middle are
the samples post-demodulation.

00:12:06.610 --> 00:12:08.860
It's actually want you
received at the receiver

00:12:08.860 --> 00:12:11.710
after we ran the
demodulation step.

00:12:11.710 --> 00:12:13.300
And the stuff on top--

00:12:13.300 --> 00:12:15.820
the blue refers to what was
transmitted, which in this case

00:12:15.820 --> 00:12:17.350
was a pure carrier.

00:12:17.350 --> 00:12:19.460
The green shows
what was received,

00:12:19.460 --> 00:12:22.210
which is some noisy
version of the carrier,

00:12:22.210 --> 00:12:24.820
because we didn't send
information other than just

00:12:24.820 --> 00:12:27.340
the carrier.

00:12:27.340 --> 00:12:29.030
This is effectively
the first lab task.

00:12:29.030 --> 00:12:31.238
We have to do nothing more
than run this a few times.

00:12:31.238 --> 00:12:34.870
And most of the first task
in the lab, the first two

00:12:34.870 --> 00:12:38.140
tasks in the lab is just making
sure that the stuff works.

00:12:40.940 --> 00:12:43.310
Now, this entire system--

00:12:43.310 --> 00:12:45.300
you know, everything
works if this thing

00:12:45.300 --> 00:12:46.610
called the preamble is decoded.

00:12:46.610 --> 00:12:47.652
So what is this preamble?

00:12:47.652 --> 00:12:49.315
And why do we need it?

00:12:49.315 --> 00:12:50.690
Well, the problem
is that, as you

00:12:50.690 --> 00:12:55.790
saw in this graphing receiver
when I showed this to you,

00:12:55.790 --> 00:12:58.500
the audio hardware
is going to be--

00:12:58.500 --> 00:13:00.278
what it's doing is
it's always listening.

00:13:00.278 --> 00:13:01.820
When you run the
program, it's always

00:13:01.820 --> 00:13:03.440
listening on the channel.

00:13:03.440 --> 00:13:05.492
So it's getting data.

00:13:05.492 --> 00:13:06.950
Even when I'm not
sending anything,

00:13:06.950 --> 00:13:08.760
it's getting something.

00:13:08.760 --> 00:13:11.240
There's always something
on the audio channel.

00:13:11.240 --> 00:13:13.490
So the question is,
how does the receiver

00:13:13.490 --> 00:13:15.220
know that what it's
receiving is part

00:13:15.220 --> 00:13:17.690
of a legitimate transmission?

00:13:17.690 --> 00:13:19.320
All communication
systems need to solve

00:13:19.320 --> 00:13:21.320
this problem of synchronizing
between the sender

00:13:21.320 --> 00:13:23.840
and receiver, and that's
done using the preamble.

00:13:23.840 --> 00:13:28.010
The preamble is nothing more
than a well-known bit sequence,

00:13:28.010 --> 00:13:30.080
sequence of bits, that
the sender and receiver

00:13:30.080 --> 00:13:31.372
both agree on.

00:13:31.372 --> 00:13:33.830
So in this case, our preamble
is that long sequence there--

00:13:33.830 --> 00:13:37.000
1 0 1 1 0 1 1 1, et cetera.

00:13:37.000 --> 00:13:39.200
And there's some guidelines
and rules of thumb

00:13:39.200 --> 00:13:41.390
that go into what
makes a preamble good

00:13:41.390 --> 00:13:42.950
and what makes it not so good.

00:13:42.950 --> 00:13:44.658
We're not going to
worry about that here.

00:13:44.658 --> 00:13:46.430
I'm just telling you
that's the preamble.

00:13:46.430 --> 00:13:48.440
So as long as the
receiver is successfully

00:13:48.440 --> 00:13:50.533
able to decode the
preamble, it means

00:13:50.533 --> 00:13:52.700
that it knows that there's
a legitimate transmission

00:13:52.700 --> 00:13:55.590
over the air, and it can
start listening to it.

00:13:55.590 --> 00:13:57.710
So if you don't
get the preamble,

00:13:57.710 --> 00:14:01.300
all bets are off as to what the
heck's going on on the channel.

00:14:01.300 --> 00:14:04.670
And sometimes, you may
not get the preamble.

00:14:04.670 --> 00:14:07.630
Now, one of the things
you would have to do,

00:14:07.630 --> 00:14:14.210
you would want to do, is when
don't get a preamble, usually,

00:14:14.210 --> 00:14:16.910
it's a sign that
either some samples are

00:14:16.910 --> 00:14:20.180
being lost because the
audio hardware isn't

00:14:20.180 --> 00:14:21.350
able to cope with it.

00:14:21.350 --> 00:14:25.130
And the documentation describes
how you deal with that problem.

00:14:25.130 --> 00:14:27.290
Or it means that the
sampling rate is too high,

00:14:27.290 --> 00:14:30.078
and maybe something is running
on your computer that's--

00:14:30.078 --> 00:14:30.620
I don't know.

00:14:30.620 --> 00:14:32.578
You have some video going
on in the background,

00:14:32.578 --> 00:14:35.885
and it's not keeping up
to read at 48,000 hertz.

00:14:35.885 --> 00:14:37.760
Or it's a sign that the
signal-to-noise ratio

00:14:37.760 --> 00:14:38.523
is too low.

00:14:38.523 --> 00:14:40.190
Maybe you're in a
very crowded location,

00:14:40.190 --> 00:14:42.177
or maybe the volume is too low.

00:14:42.177 --> 00:14:43.760
So those are usually
the ways in which

00:14:43.760 --> 00:14:48.690
you go about fixing this
problem with the preamble.

00:14:48.690 --> 00:14:50.960
Now I want to show you
one more noise graph.

00:14:50.960 --> 00:14:54.550
What I'd like you to do
now is actually make--

00:14:54.550 --> 00:14:57.972
we're going to try to do this
with some music on the side.

00:14:57.972 --> 00:14:59.930
What I want to show you
is that as you increase

00:14:59.930 --> 00:15:01.670
the amount of
noise, the noise is

00:15:01.670 --> 00:15:05.500
captured in the variance of
the Gaussian distribution.

00:15:05.500 --> 00:15:07.870
The more the noise,
the bigger the variance

00:15:07.870 --> 00:15:09.090
in the distribution.

00:15:09.090 --> 00:15:12.370
So I'm going to try to do
this by sending 1,000 bits.

00:15:12.370 --> 00:15:16.520
So this will take a
little bit of time.

00:15:16.520 --> 00:15:18.318
So let's go send it without--

00:15:18.318 --> 00:15:21.734
[TONE PLAYS]

00:15:24.627 --> 00:15:26.710
So we'll send this without
a huge amount of noise.

00:15:26.710 --> 00:15:29.705
I mean, there's some
ambient noise in the room.

00:15:29.705 --> 00:15:31.330
And this will take
a little bit of time

00:15:31.330 --> 00:15:36.285
to demodulate and get working.

00:15:36.285 --> 00:15:37.980
There's a couple of errors.

00:15:37.980 --> 00:15:40.840
The bit error rate is 0.002
bits, so we had an error here.

00:15:43.698 --> 00:15:44.990
And we saw something like this.

00:15:44.990 --> 00:15:46.480
It isn't quite a
Gaussian in this case.

00:15:46.480 --> 00:15:47.772
But we saw something like that.

00:15:51.290 --> 00:15:58.100
Now, what I'd like you
to do is kind of start--

00:15:58.100 --> 00:16:00.500
when I say yes, just
start making some noise.

00:16:00.500 --> 00:16:02.840
Just clap, or just
talk, or whatever.

00:16:02.840 --> 00:16:04.620
Just turn on your phones.

00:16:04.620 --> 00:16:05.170
Do something.

00:16:05.170 --> 00:16:07.162
[CHUCKLING]

00:16:08.158 --> 00:16:09.121
[TONE PLAYS]

00:16:09.121 --> 00:16:09.621
Yeah.

00:16:09.621 --> 00:16:10.579
[CHEERING AND APPLAUSE]

00:16:10.579 --> 00:16:12.447
All right, let's see what--

00:16:16.690 --> 00:16:19.320
All right, we're done.

00:16:19.320 --> 00:16:19.820
All right.

00:16:19.820 --> 00:16:21.218
[LAUGHTER]

00:16:21.218 --> 00:16:22.150
AUDIENCE: I had to.

00:16:22.150 --> 00:16:23.988
[CHUCKLING]

00:16:23.988 --> 00:16:26.030
HARI BALAKRISHNAN: I was
actually going to play--

00:16:26.030 --> 00:16:27.980
I found some nice
YouTube clips of a music

00:16:27.980 --> 00:16:30.520
group, one of the MIT a
cappella music groups.

00:16:30.520 --> 00:16:33.090
OK, we really got toasted
here because you guys started

00:16:33.090 --> 00:16:35.530
talking, and we couldn't
recover the preamble.

00:16:35.530 --> 00:16:36.952
But we've probably got--

00:16:36.952 --> 00:16:38.185
AUDIENCE: [LAUGHTER]

00:16:38.185 --> 00:16:40.810
HARI BALAKRISHNAN: That was the
noise distribution that we saw.

00:16:40.810 --> 00:16:43.143
And you can see that it's
actually kind of a [INAUDIBLE]

00:16:43.143 --> 00:16:44.040
distribution.

00:16:44.040 --> 00:16:45.810
I'll show you what
this picture is.

00:16:45.810 --> 00:16:48.210
This is a picture
that essentially

00:16:48.210 --> 00:16:53.400
will become your best friend,
or maybe your worst enemy.

00:16:53.400 --> 00:16:55.200
This is called an eye diagram.

00:16:55.200 --> 00:16:57.247
And it looks
completely messed up.

00:16:57.247 --> 00:16:58.830
So I'm going to show
you what that is.

00:16:58.830 --> 00:17:01.380
And we're going
to talk about it.

00:17:01.380 --> 00:17:02.710
So let me explain to you--

00:17:02.710 --> 00:17:03.990
but this noise was too high.

00:17:03.990 --> 00:17:05.790
And the point here is that
that's shown in this picture

00:17:05.790 --> 00:17:08.490
here where we ended up with
enough of a variation that we

00:17:08.490 --> 00:17:10.230
couldn't distinguish
between 0's and 1's.

00:17:10.230 --> 00:17:12.020
We sent something
which had a little bit

00:17:12.020 --> 00:17:13.020
of 0's in the beginning.

00:17:13.020 --> 00:17:15.270
And then the entire
1 distribution

00:17:15.270 --> 00:17:18.430
was spread between 0.1
volts to 0.9 volts.

00:17:18.430 --> 00:17:19.950
So the variance
is extremely high.

00:17:22.710 --> 00:17:24.822
Now let's do one thing.

00:17:24.822 --> 00:17:26.530
I'm going to change
this to just transmit

00:17:26.530 --> 00:17:29.260
random pieces of
information here.

00:17:29.260 --> 00:17:31.390
When I don't give anything,
it means that the data

00:17:31.390 --> 00:17:34.360
that's being sent is just a
random sequence of 0's and 1's.

00:17:34.360 --> 00:17:35.950
Let me change this to 200 bits.

00:17:39.429 --> 00:17:40.920
[TONE PLAYS]

00:17:45.890 --> 00:17:47.930
All right, so we got
those bits through.

00:17:47.930 --> 00:17:52.372
And that's a
beautiful eye diagram.

00:17:52.372 --> 00:17:53.580
I'll explain what this means.

00:17:53.580 --> 00:17:56.030
But the point is that when
you see the separation,

00:17:56.030 --> 00:17:57.680
and you see a
point in the middle

00:17:57.680 --> 00:18:02.277
here with a big gap on
this eye diagram graph.

00:18:02.277 --> 00:18:03.860
And then you see a
separation between,

00:18:03.860 --> 00:18:05.420
these were the
0's, and those were

00:18:05.420 --> 00:18:07.520
the 1's, which means you
could threshold somewhere

00:18:07.520 --> 00:18:10.550
in the middle and separate out
which bits were 0's and which

00:18:10.550 --> 00:18:11.540
bits were 1.

00:18:11.540 --> 00:18:14.210
It means you're cooking
things a bit, OK?

00:18:14.210 --> 00:18:19.050
So you can see that
there's a distribution here

00:18:19.050 --> 00:18:21.440
of what the 1's looked
like in the empirical data.

00:18:21.440 --> 00:18:24.380
There's a distribution here
of what the 0's look like.

00:18:24.380 --> 00:18:26.660
This is not going to
be a Gaussian at all.

00:18:26.660 --> 00:18:30.327
I'll explain why that
is in a moment, OK?

00:18:30.327 --> 00:18:31.910
So I have to do two
more things today,

00:18:31.910 --> 00:18:34.010
and then I'll turn it over
to Professor Verghese.

00:18:34.010 --> 00:18:35.593
The first one I want
to explain to you

00:18:35.593 --> 00:18:40.400
is what this eye diagram is
and why it's kind of useful.

00:18:40.400 --> 00:18:42.860
And why, as you add more
noise into the system,

00:18:42.860 --> 00:18:46.215
the combination of something
called intersymbol interference

00:18:46.215 --> 00:18:49.580
when noise gets in the
way of decoding the bits.

00:18:52.780 --> 00:18:55.750
Now, on this channel,
there are two things

00:18:55.750 --> 00:18:57.770
that distort the quality
of communication.

00:18:57.770 --> 00:19:00.442
The first is noise, and you
kind of saw the effect of that.

00:19:00.442 --> 00:19:01.900
The second is this
thing that we've

00:19:01.900 --> 00:19:06.740
been studying by modeling it as
a linear time-invariant system.

00:19:06.740 --> 00:19:11.560
The idea is that when you have
a sequence of 0's on the input,

00:19:11.560 --> 00:19:15.880
and then you go into a
sequence of 1 samples,

00:19:15.880 --> 00:19:19.930
that sudden sharp input
transition does not immediately

00:19:19.930 --> 00:19:21.610
get captured at the receiver.

00:19:21.610 --> 00:19:24.640
It takes time for the 0
to settle into a 1 and a 1

00:19:24.640 --> 00:19:25.510
to settle into a 0.

00:19:25.510 --> 00:19:28.870
And you can see that
in this picture here.

00:19:28.870 --> 00:19:30.460
Now let's focus
in in this picture

00:19:30.460 --> 00:19:36.380
here and look carefully
at this place here.

00:19:41.540 --> 00:19:42.040
Oops.

00:19:44.640 --> 00:19:46.200
All right, let's do this again.

00:19:46.200 --> 00:19:48.550
I learned about this,
like, 15 minutes ago.

00:19:48.550 --> 00:19:49.650
So bear with me.

00:20:02.320 --> 00:20:04.360
All right, so they
were 0's at the bottom,

00:20:04.360 --> 00:20:06.370
and then we bumped
up to 1 on the input.

00:20:06.370 --> 00:20:09.640
The input bumped from 0 to a 1.

00:20:09.640 --> 00:20:11.230
This is after we demodulate it.

00:20:11.230 --> 00:20:13.570
So if things work
perfectly, you would

00:20:13.570 --> 00:20:15.670
see at the output the 0
immediately goes to a 1.

00:20:15.670 --> 00:20:17.050
But what do you actually see?

00:20:17.050 --> 00:20:18.850
You see that it takes
a while for the 1

00:20:18.850 --> 00:20:20.830
to settle down, right?

00:20:20.830 --> 00:20:22.900
It goes from 0 to 1
sharply on the input,

00:20:22.900 --> 00:20:24.670
but it takes a while
to go from 0 to 1.

00:20:24.670 --> 00:20:26.440
And then I go up like that.

00:20:26.440 --> 00:20:28.000
And then I want
to go from 1 to 0.

00:20:28.000 --> 00:20:30.227
And you can see that
as it comes down to 0,

00:20:30.227 --> 00:20:31.560
it takes a while to settle down.

00:20:35.160 --> 00:20:37.912
Do you guys all understand
why that happens?

00:20:37.912 --> 00:20:40.250
Like, I don't mean the
physics of why it happens.

00:20:40.250 --> 00:20:44.380
But what I mean is
how that idea relates

00:20:44.380 --> 00:20:47.500
to this idea of the unit step
response and the unit sample

00:20:47.500 --> 00:20:48.140
response?

00:20:48.140 --> 00:20:50.140
This is nothing more than
the unit step response

00:20:50.140 --> 00:20:51.460
of this channel, right?

00:20:51.460 --> 00:20:54.370
I have a 0, and I've assumed
I'm on 0 for a while.

00:20:54.370 --> 00:20:58.220
I bump up to a 1, and it takes a
while for it to go from 0 to 1.

00:20:58.220 --> 00:21:00.670
And similarly, it takes a while
for it to go from a 1 back

00:21:00.670 --> 00:21:02.560
to a 0.

00:21:02.560 --> 00:21:09.590
Now, suppose I end up switching
0, 1, 1, 0, 0, 1, 0, 1,

00:21:09.590 --> 00:21:11.440
0, 1 very, very quickly.

00:21:11.440 --> 00:21:14.240
And I don't give enough time for
the whole thing to settle down.

00:21:14.240 --> 00:21:20.830
In other words, as I
go from a 0 to a 1,

00:21:20.830 --> 00:21:23.762
before it settles down into
1, if the next bit is a 0,

00:21:23.762 --> 00:21:24.970
and then I start coming down.

00:21:24.970 --> 00:21:28.270
And before the next bit settles
down to 0, I get to a 1.

00:21:28.270 --> 00:21:30.040
And before it comes back to 0--

00:21:30.040 --> 00:21:31.370
I keep doing that.

00:21:31.370 --> 00:21:34.480
What I'm going to end up
with is this combination

00:21:34.480 --> 00:21:38.140
of 0's and 1's that are
sort of random start

00:21:38.140 --> 00:21:40.900
confusing the receiver because
we're not giving enough time

00:21:40.900 --> 00:21:42.770
for the 0 to settle down.

00:21:42.770 --> 00:21:44.620
And similarly, when
we go from 0 to 1,

00:21:44.620 --> 00:21:48.910
we're not giving enough time
for the 1 to settle down.

00:21:48.910 --> 00:21:51.010
That's what this eye
diagram was referring

00:21:51.010 --> 00:21:53.070
to where we found in
this confused case--

00:21:53.070 --> 00:21:55.570
and then when you have noise,
some of the 0's get moved to 1

00:21:55.570 --> 00:21:57.580
anyway, and 1's get moved to 0.

00:21:57.580 --> 00:22:01.180
And we end up with this
very crowded picture.

00:22:01.180 --> 00:22:02.860
The way you tackle
this problem is it

00:22:02.860 --> 00:22:04.750
all has to do with
the number of samples

00:22:04.750 --> 00:22:07.690
that you decide to
use within 1 bit.

00:22:07.690 --> 00:22:09.820
So coming back to
this picture, if I

00:22:09.820 --> 00:22:11.990
do this at 48,000
samples per second,

00:22:11.990 --> 00:22:17.530
in any one of these carriers,
I have 48 samples that I use.

00:22:17.530 --> 00:22:23.140
But now I get to decide how
many samples corresponds

00:22:23.140 --> 00:22:25.390
to 1 bit of information?

00:22:25.390 --> 00:22:28.060
When I have a bit that I want
to transmit-- let's say a 1--

00:22:31.860 --> 00:22:37.065
how many samples?

00:22:39.960 --> 00:22:43.410
What that effectively
means is to transmit a 1,

00:22:43.410 --> 00:22:48.540
how many of these
periods of this waveform

00:22:48.540 --> 00:22:51.090
do I want to use
to transmit a 1?

00:22:51.090 --> 00:22:57.970
So for example, if I
decide I want to send a 1

00:22:57.970 --> 00:23:00.730
as three carriers
of the waveform,

00:23:00.730 --> 00:23:04.750
then in any one of these
carriers, I have 48 samples.

00:23:04.750 --> 00:23:07.720
Therefore, I represent
a 1 as 48 times 3,

00:23:07.720 --> 00:23:13.762
which is 144 samples per bit.

00:23:17.210 --> 00:23:20.560
Now, to transmit a 0, I could
do a bunch of different things.

00:23:20.560 --> 00:23:24.520
I could decide to keep
the channel silent.

00:23:24.520 --> 00:23:26.270
If I do that, it's
called on-off keying.

00:23:26.270 --> 00:23:27.740
And that's what
we're using here.

00:23:27.740 --> 00:23:30.910
So we're sending 1 as--

00:23:30.910 --> 00:23:33.730
if we decide to use
144 samples per bit,

00:23:33.730 --> 00:23:37.660
then it means we represent
a 1 as 124 samples, which

00:23:37.660 --> 00:23:40.110
corresponds to three of these.

00:23:40.110 --> 00:23:44.017
And then we represent
0 as nothing.

00:23:44.017 --> 00:23:45.100
So we don't send anything.

00:23:47.680 --> 00:23:49.840
If we do that, this is
called on-off keying

00:23:49.840 --> 00:23:52.930
because we send on for 1,
where we send a sinusoid.

00:23:52.930 --> 00:23:56.700
And for sending us a 0
bit, we send nothing.

00:23:56.700 --> 00:24:01.600
Now, if the number of samples
I select per bit is too small,

00:24:01.600 --> 00:24:04.330
you end up with this effect
that I don't give enough time

00:24:04.330 --> 00:24:06.240
for the 0 to settle down to--

00:24:06.240 --> 00:24:09.130
when I make the transition
from a 0 to a 1,

00:24:09.130 --> 00:24:14.350
if I pick too small samples per
bit, before we settle into a 1,

00:24:14.350 --> 00:24:16.163
the next bit may show up as a 0.

00:24:16.163 --> 00:24:17.830
And then before we
settle down into a 0,

00:24:17.830 --> 00:24:19.750
the next bit shows
up perhaps as a 1.

00:24:19.750 --> 00:24:22.660
And we end up commingling
the 0's and the 1's.

00:24:22.660 --> 00:24:24.880
And we're not able
at the receiver

00:24:24.880 --> 00:24:28.510
to tell the difference between
these different-volted samples

00:24:28.510 --> 00:24:29.530
after we demodulate.

00:24:29.530 --> 00:24:31.910
So we don't know what happened.

00:24:31.910 --> 00:24:34.540
So if the eye diagram
is a way to capture

00:24:34.540 --> 00:24:36.950
that, what the eye
diagram does is--

00:24:36.950 --> 00:24:38.620
it's a kind of a clever hack.

00:24:38.620 --> 00:24:41.140
What it does is--

00:24:41.140 --> 00:24:42.370
thought I had it somewhere.

00:24:42.370 --> 00:24:43.202
There it is.

00:24:46.028 --> 00:24:47.570
The way you generate
an eye diagram--

00:24:47.570 --> 00:24:49.987
you don't have to worry about
writing the software for it.

00:24:49.987 --> 00:24:52.450
But you will look at a lot
of these kinds of pictures

00:24:52.450 --> 00:24:55.000
in lab 5.

00:24:55.000 --> 00:24:57.630
You transmit a random
sequence of bits.

00:24:57.630 --> 00:24:59.770
And then you look
at the samples that

00:24:59.770 --> 00:25:02.550
were received at the receiver
after demodulation was done.

00:25:07.100 --> 00:25:10.205
The output of the demodulation
is a set of voltage values.

00:25:14.020 --> 00:25:18.910
What you do is you look
at three bit periods.

00:25:18.910 --> 00:25:20.740
In other words, you
look at a sequence

00:25:20.740 --> 00:25:23.250
of time, a number of samples
that corresponds to three bit

00:25:23.250 --> 00:25:23.750
periods.

00:25:23.750 --> 00:25:27.370
So for example, if I pick 144
samples per bit, what I do

00:25:27.370 --> 00:25:32.155
is I take 144 and multiply
that by 3 bit periods.

00:25:34.720 --> 00:25:37.850
And I look at that many samples.

00:25:37.850 --> 00:25:42.510
So for every three bit periods,
I take all the samples,

00:25:42.510 --> 00:25:44.590
and I plot them, OK?

00:25:44.590 --> 00:25:47.660
So a particular sequence
of bits-- in this case,

00:25:47.660 --> 00:25:50.080
it might be a 0 and a 1 and a 0.

00:25:50.080 --> 00:25:54.330
This is a 0 followed
by a 1 followed by a 0.

00:25:54.330 --> 00:25:56.860
A different sequence of
bits could be a 1 followed

00:25:56.860 --> 00:25:58.392
by 1 followed by 1.

00:25:58.392 --> 00:26:00.100
A different sequence
of bits could be a 0

00:26:00.100 --> 00:26:01.840
followed by 0 followed by 0.

00:26:01.840 --> 00:26:03.730
So there are eight
combinations of sequences

00:26:03.730 --> 00:26:05.020
of three bits each.

00:26:05.020 --> 00:26:05.915
So there are eight--

00:26:05.915 --> 00:26:08.800
you have this clean
eye diagram like this.

00:26:08.800 --> 00:26:12.640
You're going to see a variety
of different lines corresponding

00:26:12.640 --> 00:26:16.410
to all the places where
different 3-bit sequences

00:26:16.410 --> 00:26:17.900
appeared in your input.

00:26:17.900 --> 00:26:20.410
So for any given 3-bit
sequence of the input,

00:26:20.410 --> 00:26:23.860
there's a 3-bit sample sequence
at the output that corresponds

00:26:23.860 --> 00:26:28.120
to a number of samples equal to
the samples per bit multiplied

00:26:28.120 --> 00:26:29.420
by 3.

00:26:29.420 --> 00:26:33.010
And each of those generates
one of those trajectories

00:26:33.010 --> 00:26:36.430
through this picture.

00:26:36.430 --> 00:26:38.110
If you generate that
picture, and you

00:26:38.110 --> 00:26:40.090
find that there's
a very clean gap

00:26:40.090 --> 00:26:43.120
between all possible
combinations of these bit

00:26:43.120 --> 00:26:46.420
sequences, as is
in this case here,

00:26:46.420 --> 00:26:50.380
then it means that you're very
likely to be able to decode.

00:26:50.380 --> 00:26:52.660
Because what you can do is,
essentially, the receiver

00:26:52.660 --> 00:26:56.230
can decide that
when 1's happen, it

00:26:56.230 --> 00:27:00.250
corresponds to something over
here at 0.35 or 0.4 volts.

00:27:00.250 --> 00:27:02.620
When a 0 happens,
it may not be a 0,

00:27:02.620 --> 00:27:04.840
but it may correspond to
something like a 0.1 volt

00:27:04.840 --> 00:27:07.060
here, which means I can
pick the middle point

00:27:07.060 --> 00:27:09.250
and slice it at
that middle point

00:27:09.250 --> 00:27:13.192
to determine whether the
received bits were 0 or 1.

00:27:13.192 --> 00:27:15.400
Now, if we were to run this
experiment again and make

00:27:15.400 --> 00:27:17.350
a lot of noise--

00:27:17.350 --> 00:27:19.630
let's try that--
what would happen

00:27:19.630 --> 00:27:22.870
is we may not be able
to decode at all.

00:27:22.870 --> 00:27:25.900
So I'm going to request you guys
to make a little bit of noise

00:27:25.900 --> 00:27:28.000
after I start.

00:27:28.000 --> 00:27:29.630
And then we'll see how it goes.

00:27:29.630 --> 00:27:30.661
All right, start.

00:27:30.661 --> 00:27:31.623
[WHISTLING]

00:27:31.623 --> 00:27:32.585
[TONE PLAYS]

00:27:32.585 --> 00:27:35.070
[APPLAUSE]

00:27:35.070 --> 00:27:37.570
AUDIENCE: [SCREAMS]

00:27:37.615 --> 00:27:38.990
HARI BALAKRISHNAN:
You know what?

00:27:38.990 --> 00:27:40.040
It wasn't loud enough.

00:27:40.040 --> 00:27:41.350
It worked great.

00:27:41.350 --> 00:27:44.920
But let's look at what the
eye diagram looks like.

00:27:44.920 --> 00:27:47.267
Well, it's a little
worse than the other one,

00:27:47.267 --> 00:27:49.100
but I think the energy
is down in this room.

00:27:49.100 --> 00:27:51.970
So let's do it one more time.

00:27:51.970 --> 00:27:54.880
I want to be in a position
where nothing decodes.

00:27:54.880 --> 00:27:55.780
[TONE PLAYS]

00:27:55.780 --> 00:27:59.210
[SCREAMING AND APPLAUSE]

00:28:02.130 --> 00:28:05.160
Well, 15% better is, in
fact, my preamble decoded,

00:28:05.160 --> 00:28:05.970
which is amazing.

00:28:05.970 --> 00:28:08.167
[INTERPOSING VOICES]

00:28:08.167 --> 00:28:10.250
HARI BALAKRISHNAN: And
that's what it looked like.

00:28:10.250 --> 00:28:15.570
OK, this is an eye diagram
even a mother wouldn't like.

00:28:15.570 --> 00:28:17.367
All right, so I'm
going to stop here.

00:28:17.367 --> 00:28:19.200
Before I turn it over
to Professor Verghese,

00:28:19.200 --> 00:28:20.623
are there any questions?

00:28:20.623 --> 00:28:21.290
Anything at all.

00:28:21.290 --> 00:28:22.748
I know some of you
have had issues.

00:28:22.748 --> 00:28:25.570
And I met one or two of you this
morning to fix your computers.

00:28:25.570 --> 00:28:26.970
And I'm happy to do that.

00:28:26.970 --> 00:28:28.795
I'll be in the lab
from 4 o'clock.

00:28:28.795 --> 00:28:30.420
We'll get it working
on your computers.

00:28:30.420 --> 00:28:31.962
If it doesn't work,
then you're going

00:28:31.962 --> 00:28:34.080
to have to use the lab machines.

00:28:34.080 --> 00:28:35.920
Let's take some
questions or comments.

00:28:35.920 --> 00:28:38.070
Any people have any
questions about this stuff?

00:28:38.070 --> 00:28:39.780
Do people get an idea
of what's going on

00:28:39.780 --> 00:28:41.070
and what do you need to do?

00:28:41.070 --> 00:28:44.346
Once you get this working,
the labs sort of--

00:28:44.346 --> 00:28:45.390
they'll write themselves.

00:28:45.390 --> 00:28:48.615
You just have to do
a little bit of work.

00:28:48.615 --> 00:28:51.420
Questions?

00:28:51.420 --> 00:28:53.370
This can go up to
higher frequencies too.

00:28:53.370 --> 00:28:54.967
So if the sound's
annoying your ears,

00:28:54.967 --> 00:28:56.300
you can actually get it to work.

00:28:56.300 --> 00:28:58.820
I know one of you guys is
trying to get this to work

00:28:58.820 --> 00:29:03.170
with ultrasonic reception.

00:29:03.170 --> 00:29:06.530
That's challenging, but we
can probably help you on.

00:29:06.530 --> 00:29:07.138
Yeah.

00:29:07.138 --> 00:29:09.130
AUDIENCE: What do we get
for the uniform noise

00:29:09.130 --> 00:29:12.145
since [INAUDIBLE]?

00:29:12.145 --> 00:29:13.520
HARI BALAKRISHNAN:
Uniform noise?

00:29:13.520 --> 00:29:14.145
AUDIENCE: Yeah.

00:29:14.145 --> 00:29:17.795
So if we just have another
tone on the other side,

00:29:17.795 --> 00:29:21.610
how do we get to [INAUDIBLE]?

00:29:21.610 --> 00:29:22.990
HARI BALAKRISHNAN:
Yeah, you mean

00:29:22.990 --> 00:29:25.115
if you were to make another
transmission at exactly

00:29:25.115 --> 00:29:26.110
the same frequency?

00:29:26.110 --> 00:29:28.930
The beauty of this is that
there's different demodulation

00:29:28.930 --> 00:29:29.853
schemes.

00:29:29.853 --> 00:29:32.020
Right now, we're using
something called the envelope

00:29:32.020 --> 00:29:35.290
demodulation, which Professor
Verghese talked about before.

00:29:35.290 --> 00:29:37.780
All that's doing is it's
taking the absolute value

00:29:37.780 --> 00:29:41.140
of every received sample and
then running a simple averaging

00:29:41.140 --> 00:29:41.910
filter.

00:29:41.910 --> 00:29:43.520
And that's what you
write in the lab.

00:29:43.520 --> 00:29:45.760
It's a very, very
simple demodulation.

00:29:45.760 --> 00:29:48.200
We'll study something called
quadrature demodulation

00:29:48.200 --> 00:29:51.310
in probably next
lecture or the one

00:29:51.310 --> 00:29:54.370
after that, which means that'll
have the property that, if you

00:29:54.370 --> 00:29:57.340
transmit at a certain frequency,
and somebody else interferes

00:29:57.340 --> 00:29:59.680
and transmits at a
different carrier frequency,

00:29:59.680 --> 00:30:02.710
you're still going to be able
to recover your transmission.

00:30:02.710 --> 00:30:07.353
But if the other transmitter
has significant signal strength

00:30:07.353 --> 00:30:09.520
in the same frequencies
that you're transmitting in,

00:30:09.520 --> 00:30:12.170
then he's going to start
to look like noise to you,

00:30:12.170 --> 00:30:13.460
and that's going to not work.

00:30:13.460 --> 00:30:15.418
So what happened here is
when you guys were all

00:30:15.418 --> 00:30:19.150
whistling and were
clapping and so on,

00:30:19.150 --> 00:30:21.580
there were signals generated
across all frequencies,

00:30:21.580 --> 00:30:23.890
including the frequency at
which I was transmitting.

00:30:23.890 --> 00:30:27.130
And that's what caused
the signal to have noise.

00:30:27.130 --> 00:30:29.680
It's not like you were all
transmitting at 1,000 hertz.

00:30:29.680 --> 00:30:32.530
It just so happens
that that combination

00:30:32.530 --> 00:30:35.840
of noise you were making had
a component at 1,000 hertz.

00:30:35.840 --> 00:30:37.141
Does that answer your question?

00:30:37.141 --> 00:30:38.323
AUDIENCE: Yeah.

00:30:38.323 --> 00:30:40.740
HARI BALAKRISHNAN: Any other
questions, comments, remarks?

00:30:45.610 --> 00:30:46.580
OK.

00:30:46.580 --> 00:30:47.955
GEORGE VERGHESE:
Yeah, we've been

00:30:47.955 --> 00:30:50.170
talking about modeling
the baseband channel.

00:30:50.170 --> 00:30:52.870
And we've said we'll
focus on LTI channels.

00:30:52.870 --> 00:30:55.480
So I just wanted to take
advantage of this being

00:30:55.480 --> 00:30:58.840
up here to have you think
about what this tells you

00:30:58.840 --> 00:31:01.330
about how close to
linear this channel is,

00:31:01.330 --> 00:31:03.370
and how close to
time-invariant it is.

00:31:03.370 --> 00:31:04.120
What do you think?

00:31:04.120 --> 00:31:06.830
What we're seeing
here is, for instance,

00:31:06.830 --> 00:31:09.730
a step response to
something that's at 0

00:31:09.730 --> 00:31:12.250
and then goes up to
1 and stays at 1.

00:31:12.250 --> 00:31:16.070
We're seeing a superposition of
many such 0-to-1 transitions,

00:31:16.070 --> 00:31:21.630
some 1-to-0 transitions, later
1-to-0 transitions, and so on.

00:31:21.630 --> 00:31:23.380
So we're really looking
at a superposition

00:31:23.380 --> 00:31:27.250
of step responses staggered in
time and going from 0 to or 1

00:31:27.250 --> 00:31:28.870
to 0.

00:31:28.870 --> 00:31:32.450
Do you think time invariance
is maybe a good assumption

00:31:32.450 --> 00:31:35.252
for this channel?

00:31:35.252 --> 00:31:35.960
Plausible, right?

00:31:35.960 --> 00:31:39.470
Because the stuff that we get
here looks a lot like the stuff

00:31:39.470 --> 00:31:41.180
we're getting here.

00:31:41.180 --> 00:31:45.200
The deviations might be noise,
but the more structured parts

00:31:45.200 --> 00:31:48.900
of the waveform here match the
structured part of the waveform

00:31:48.900 --> 00:31:49.400
here.

00:31:49.400 --> 00:31:53.090
And what you're really seeing
is the loudspeaker here

00:31:53.090 --> 00:31:54.920
reverberating through the room.

00:31:54.920 --> 00:31:57.620
You're all staying
fixed, so the echoes

00:31:57.620 --> 00:31:58.910
are from fixed locations.

00:31:58.910 --> 00:32:00.470
The walls are fixed.

00:32:00.470 --> 00:32:04.340
And so what we're seeing is
the step response of the room,

00:32:04.340 --> 00:32:05.330
in effect.

00:32:05.330 --> 00:32:07.610
If you hit the room
a little bit later,

00:32:07.610 --> 00:32:10.550
well, you get the same
response, but a little later.

00:32:10.550 --> 00:32:12.250
Does this look like
it's very linear?

00:32:12.250 --> 00:32:14.880
Would linearity be a good
assumption for this channel?

00:32:17.760 --> 00:32:19.740
I mean this is very
partial information,

00:32:19.740 --> 00:32:22.930
but does it give
you enough to judge?

00:32:22.930 --> 00:32:25.825
So why do you think
linearity might be good here?

00:32:25.825 --> 00:32:27.700
Were you saying, yes,
it's a good assumption?

00:32:27.700 --> 00:32:29.510
AUDIENCE: Yeah, because
time is a pattern.

00:32:29.510 --> 00:32:30.760
GEORGE VERGHESE: Because what?

00:32:30.760 --> 00:32:34.696
AUDIENCE: Like, if you have
a signal go five seconds

00:32:34.696 --> 00:32:37.877
from a different signal, it'll
still appear in the center.

00:32:37.877 --> 00:32:40.210
GEORGE VERGHESE: But that's
the time-invariance argument

00:32:40.210 --> 00:32:41.127
that you're giving me.

00:32:41.127 --> 00:32:42.680
What's the linearity argument?

00:32:42.680 --> 00:32:43.294
Yeah.

00:32:43.294 --> 00:32:45.270
AUDIENCE: When you
scale the intact input,

00:32:45.270 --> 00:32:46.878
the output gets
scaled accordingly.

00:32:46.878 --> 00:32:48.670
GEORGE VERGHESE: OK,
so when you scale it--

00:32:48.670 --> 00:32:50.173
so we're not really
seeing too much.

00:32:50.173 --> 00:32:51.340
Well, we are seeing scaling.

00:32:51.340 --> 00:32:55.080
What kind of scaling
are you seeing here?

00:32:55.080 --> 00:32:57.330
We have 0-to-1
transitions, but we also

00:32:57.330 --> 00:33:00.150
have 1-to-0 kinds of
transitions, right?

00:33:00.150 --> 00:33:02.910
What would you want to see
for a linear channel for how

00:33:02.910 --> 00:33:05.310
the 1-to-0 transition
behaves relative

00:33:05.310 --> 00:33:07.410
to the 0-to-1 transition?

00:33:07.410 --> 00:33:10.264
What would you expect
on the linear channel?

00:33:10.264 --> 00:33:10.764
Yeah.

00:33:10.764 --> 00:33:12.165
AUDIENCE: [INAUDIBLE]

00:33:12.165 --> 00:33:13.790
GEORGE VERGHESE: So
from superposition,

00:33:13.790 --> 00:33:17.020
you would really expect to see
the same shape on the downslope

00:33:17.020 --> 00:33:18.880
that you see on
the upslope, right?

00:33:18.880 --> 00:33:21.070
So when you look at the
upward transition here,

00:33:21.070 --> 00:33:22.140
you see a certain shape.

00:33:22.140 --> 00:33:26.120
Well, it's not quite matched
on the downward slope here.

00:33:26.120 --> 00:33:28.900
And the reason is that the
particular simple demodulation

00:33:28.900 --> 00:33:31.630
that we're using here
for this on-off scheme

00:33:31.630 --> 00:33:35.652
actually makes that not
look very linear for signals

00:33:35.652 --> 00:33:37.360
that are for channels
that have this kind

00:33:37.360 --> 00:33:38.592
of an overshoot to them.

00:33:38.592 --> 00:33:40.300
But the other scheme
that Hari mentioned,

00:33:40.300 --> 00:33:43.570
the quadrature demodulation,
will actually do a lot better.

00:33:43.570 --> 00:33:44.780
We, in fact, saw that, right?

00:33:44.780 --> 00:33:52.990
We saw that there was modulation
that essentially pulled out

00:33:52.990 --> 00:33:56.050
the absolute value of
what you were sending.

00:33:56.050 --> 00:33:59.380
And then there was another
modulation scheme that actually

00:33:59.380 --> 00:34:01.350
pulled out the signal itself.

00:34:01.350 --> 00:34:03.820
And so if you're doing things
like taking absolute values

00:34:03.820 --> 00:34:05.570
somewhere in the middle
there, then you're

00:34:05.570 --> 00:34:09.150
going to start losing the
ability to model it as linear.

00:34:09.150 --> 00:34:12.250
OK, so linear
time-invariant models

00:34:12.250 --> 00:34:14.260
are not necessarily
good for all channels.

00:34:14.260 --> 00:34:17.150
It's something that
you've got to look for.

00:34:17.150 --> 00:34:20.132
There are good reasons to
try and structure a channel

00:34:20.132 --> 00:34:22.090
so that it's close to
linear and time-invariant

00:34:22.090 --> 00:34:26.679
because then you can do a lot
of analysis and design for it.

00:34:26.679 --> 00:34:28.330
OK, so I want to
continue talking

00:34:28.330 --> 00:34:33.520
about our models
for LTI channels.

00:34:33.520 --> 00:34:35.800
And still in the time
domain, next time,

00:34:35.800 --> 00:34:38.510
we'll start to look at this
in the frequency domain.

00:34:38.510 --> 00:34:42.400
Hari mentioned frequency
several times here.

00:34:42.400 --> 00:34:45.880
So we're talking about
an LTI channel, Linear

00:34:45.880 --> 00:34:47.440
and Time-Invariant.

00:34:47.440 --> 00:34:51.560
We talked about characterizing
it by its unit sample response.

00:34:51.560 --> 00:34:52.600
And so let's see.

00:34:52.600 --> 00:34:58.760
Unit sample response means
put in a unit sample function.

00:34:58.760 --> 00:35:00.280
You get out an
output that you're

00:35:00.280 --> 00:35:03.040
going to call the
unit sample response.

00:35:03.040 --> 00:35:06.490
Put in an input x(n).

00:35:06.490 --> 00:35:08.950
That is a summation
of such things.

00:35:08.950 --> 00:35:18.330
Let's say x(k) delta of n minus
k summed over all k, right?

00:35:18.330 --> 00:35:20.170
That's the general
input represented

00:35:20.170 --> 00:35:22.870
as a weighted combination
of unit samples.

00:35:22.870 --> 00:35:25.730
Well, what comes
out in that case?

00:35:25.730 --> 00:35:26.470
What is y of n?

00:35:29.480 --> 00:35:31.730
If we're talking about a
linear time-invariant system,

00:35:31.730 --> 00:35:33.400
then it's the same
weighted combination

00:35:33.400 --> 00:35:36.620
of the responses to
these unit samples.

00:35:36.620 --> 00:35:43.885
So we're going to get summation
x(k) h of n minus k, right?

00:35:43.885 --> 00:35:46.780
So this is the
convolution expression

00:35:46.780 --> 00:35:48.440
that we talked about last time.

00:35:48.440 --> 00:35:50.470
So what I want to do in
the rest of the lecture

00:35:50.470 --> 00:35:53.770
is give you some other
ways to think about this.

00:35:56.752 --> 00:36:01.870
Our notation for this
was y of n equals

00:36:01.870 --> 00:36:08.460
x convolved with h
evaluated at time n, right?

00:36:14.010 --> 00:36:16.140
Another way to think
about this-- let's see.

00:36:16.140 --> 00:36:19.100
Let me actually
first do an example

00:36:19.100 --> 00:36:22.780
and then give you another
way to think about this.

00:36:22.780 --> 00:36:26.370
Suppose I have a
system whose effect

00:36:26.370 --> 00:36:32.350
is to multiply the input
by A, some number A,

00:36:32.350 --> 00:36:38.350
and delay by some number D.

00:36:38.350 --> 00:36:41.358
And I tell you that this is LTI.

00:36:41.358 --> 00:36:43.400
Actually, I don't have to
tell you that it's LTI.

00:36:43.400 --> 00:36:45.320
You can prove that it's LTI.

00:36:45.320 --> 00:36:48.260
If I tell you have a system
whose only action on the input

00:36:48.260 --> 00:36:51.140
is to delay the
input by capital D

00:36:51.140 --> 00:36:53.540
and scale the
input by capital A,

00:36:53.540 --> 00:36:56.690
you can actually prove that
it satisfies time-invariance

00:36:56.690 --> 00:37:00.020
and that you can
superimpose, OK?

00:37:00.020 --> 00:37:01.397
So this is LTI.

00:37:01.397 --> 00:37:02.855
So what's the unit
sample response?

00:37:06.967 --> 00:37:09.050
If I put in the unit sample
function of the input,

00:37:09.050 --> 00:37:09.860
what's the output?

00:37:17.918 --> 00:37:18.870
AUDIENCE: A delta n.

00:37:18.870 --> 00:37:20.060
GEORGE VERGHESE: Anyone?

00:37:20.060 --> 00:37:21.440
AUDIENCE: A delta n minus D.

00:37:21.440 --> 00:37:28.630
GEORGE VERGHESE: Yeah, A
delta of n minus d, right?

00:37:28.630 --> 00:37:32.930
And if I put some
general input function

00:37:32.930 --> 00:37:36.028
in here, what's the output?

00:37:36.028 --> 00:37:37.480
AUDIENCE: [INAUDIBLE]

00:37:37.480 --> 00:37:40.077
GEORGE VERGHESE: Without
telling you about convolution.

00:37:40.077 --> 00:37:41.410
Somebody-- I heard a voice here.

00:37:41.410 --> 00:37:42.036
Yeah.

00:37:42.036 --> 00:37:43.994
AUDIENCE: A of s
times [INAUDIBLE] D.

00:37:43.994 --> 00:37:44.952
GEORGE VERGHESE: Right.

00:37:49.280 --> 00:37:50.780
We didn't have to
do any convolution

00:37:50.780 --> 00:37:54.260
to figure this out, right,
because I described the system

00:37:54.260 --> 00:37:56.210
to you in a simple way.

00:37:56.210 --> 00:37:58.440
You could tell me what
it does to the output.

00:37:58.440 --> 00:38:00.350
All right, so I want
to give you another way

00:38:00.350 --> 00:38:07.050
to think about a system
where the unit sample

00:38:07.050 --> 00:38:12.590
response of h events.

00:38:12.590 --> 00:38:16.000
I'm talking about a system
with the unit sample response

00:38:16.000 --> 00:38:16.900
h of n.

00:38:20.130 --> 00:38:21.220
So what does that mean?

00:38:21.220 --> 00:38:25.020
That means that at
time 0, I evaluate 0.

00:38:25.020 --> 00:38:31.300
When I put out and put in
a unit sample at time 1,

00:38:31.300 --> 00:38:32.490
I get some h1.

00:38:32.490 --> 00:38:37.910
At time 2, get
some h2, and so on.

00:38:37.910 --> 00:38:42.320
This is a hn, OK?

00:38:42.320 --> 00:38:49.040
So if I give you a system and
tell you that the unit sample

00:38:49.040 --> 00:38:53.420
response is this
function, h, Here's

00:38:53.420 --> 00:38:55.640
a way to think of what it is.

00:38:55.640 --> 00:39:00.170
Inside there, here's
what my system

00:39:00.170 --> 00:39:01.460
can be thought of as doing.

00:39:04.040 --> 00:39:06.140
Inside here, I've got
many parallel paths.

00:39:06.140 --> 00:39:27.980
I've got a system that
scales by h0, delays by 0,

00:39:27.980 --> 00:39:35.172
and in parallel with the
system that scales by--

00:39:35.172 --> 00:39:36.130
let me put it up here--

00:39:39.190 --> 00:39:49.180
scales by h1, delay
by 1, and so on.

00:39:54.330 --> 00:39:57.490
OK, so all of
these in parallel--

00:39:57.490 --> 00:39:58.790
each one is very simple.

00:39:58.790 --> 00:40:00.970
Each one is as simple as
the example I showed you.

00:40:04.000 --> 00:40:07.060
OK, I've got a whole bunch
of these parallel systems,

00:40:07.060 --> 00:40:09.430
each one as simple as this.

00:40:09.430 --> 00:40:13.120
If I put a unit sample
in here, what comes out?

00:40:13.120 --> 00:40:15.370
It's going to be exactly
that, right, because the unit

00:40:15.370 --> 00:40:19.050
sample would get scaled
by 0, delayed by nothing,

00:40:19.050 --> 00:40:20.040
will come out there.

00:40:20.040 --> 00:40:24.220
Then unit sample will get
through this path scaled by h1,

00:40:24.220 --> 00:40:26.020
delayed by 1, come out there.

00:40:26.020 --> 00:40:29.830
When you assemble all of
these with this summer here,

00:40:29.830 --> 00:40:32.360
you're going to get
exactly that response.

00:40:32.360 --> 00:40:34.930
So here's another way to think
about what's sitting inside

00:40:34.930 --> 00:40:38.300
a system, an LTI system
whose unit sample response

00:40:38.300 --> 00:40:42.130
is given to be that, OK?

00:40:42.130 --> 00:40:45.410
So if I put x and n, what is
it that's going to come out?

00:40:52.580 --> 00:40:55.070
If I put x and n,
what comes out?

00:40:55.070 --> 00:40:57.950
Well, through this path,
I get x(n) scaled by 0

00:40:57.950 --> 00:40:59.690
and delayed by nothing.

00:40:59.690 --> 00:41:01.970
Through this path, I
get x(n) scaled by h1

00:41:01.970 --> 00:41:04.280
and delayed by 1, and so on.

00:41:04.280 --> 00:41:23.000
So what comes out? y of n is
equal to h(m) x of n minus m

00:41:23.000 --> 00:41:26.310
over all m, OK?

00:41:26.310 --> 00:41:28.050
So I take x(n).

00:41:28.050 --> 00:41:29.200
I shift it by nothing.

00:41:29.200 --> 00:41:30.390
I scale by h0.

00:41:30.390 --> 00:41:31.600
That's one of these terms.

00:41:31.600 --> 00:41:34.110
The term corresponding
to m equals 0.

00:41:34.110 --> 00:41:37.800
I take x(n), scale it
by h1, delay it by 1.

00:41:37.800 --> 00:41:40.360
That gives me the
term with m equals 1.

00:41:40.360 --> 00:41:42.870
So here's another
way to write it, OK?

00:41:42.870 --> 00:41:44.400
Last time, I said
that actually you

00:41:44.400 --> 00:41:46.890
can write convolution
in this form

00:41:46.890 --> 00:41:49.423
or with the operation reversed.

00:41:49.423 --> 00:41:51.840
So it actually doesn't matter
which order you write things

00:41:51.840 --> 00:41:52.800
in.

00:41:52.800 --> 00:41:55.890
This would be something
you might write as h

00:41:55.890 --> 00:42:00.150
convolved with x at time n.

00:42:00.150 --> 00:42:03.210
So two different ways of
writing the convolution and two

00:42:03.210 --> 00:42:06.390
different ways of thinking
about how the output gets

00:42:06.390 --> 00:42:09.410
represented that way.

00:42:09.410 --> 00:42:11.960
You can easily get from one
representation to the other

00:42:11.960 --> 00:42:14.080
by just making a
change of variables.

00:42:14.080 --> 00:42:17.380
Like, let n minus
k equals m, and you

00:42:17.380 --> 00:42:19.130
get from this
representation to the other.

00:42:19.130 --> 00:42:21.800
This is a more mechanistic
way of thinking about why

00:42:21.800 --> 00:42:24.680
these two representations work.

00:42:24.680 --> 00:42:28.040
OK, so with that is a
given, let me show you

00:42:28.040 --> 00:42:34.160
how to actually carry out
these operations graphically.

00:42:34.160 --> 00:42:37.158
In either form, here is
a simple graphical way

00:42:37.158 --> 00:42:38.450
to think about what's going on.

00:42:48.450 --> 00:42:50.770
So to determine
y at time n, this

00:42:50.770 --> 00:42:53.410
is the operation that I have
to carry out, all right?

00:42:53.410 --> 00:42:57.040
To define y at time n,
the output at time n,

00:42:57.040 --> 00:42:59.950
I've got to find a way to
implement this operation.

00:43:09.460 --> 00:43:12.420
So how are we going to
think of this graphically?

00:43:12.420 --> 00:43:14.500
I want to sketch the signal x.

00:43:14.500 --> 00:43:16.800
I want to sketch the
signal h and then

00:43:16.800 --> 00:43:21.480
do something with these two
signals to construct this, OK?

00:43:21.480 --> 00:43:26.280
So when I plot x, and
I plot h to implement

00:43:26.280 --> 00:43:31.680
this operation, what's
the name on my time axis?

00:43:31.680 --> 00:43:36.790
Is it m that I'm going to
stick here or k or what?

00:43:36.790 --> 00:43:37.970
I want to implement this.

00:43:37.970 --> 00:43:41.740
I want to draw these two time
functions, the functions of k,

00:43:41.740 --> 00:43:42.500
right?

00:43:42.500 --> 00:43:46.610
And it's just the number
that I'm specifying here.

00:43:46.610 --> 00:43:52.550
OK, so on the k-axis, I'm
going to take x and plot it.

00:43:52.550 --> 00:43:53.840
So x is some time function.

00:44:01.430 --> 00:44:02.180
Here's my x.

00:44:07.830 --> 00:44:11.110
I won't label them all because
that would get crowded.

00:44:11.110 --> 00:44:14.380
And just to keep things clean,
let's change colors here.

00:44:16.970 --> 00:44:19.150
How am I going to
plot h of n minus k?

00:44:19.150 --> 00:44:21.910
Well, let's start thinking
about the n equals 0 case.

00:44:21.910 --> 00:44:26.275
So for n equals 0, I've
got to plot h of minus k.

00:44:26.275 --> 00:44:30.310
So how does h of minus k relate
to the unit sample response

00:44:30.310 --> 00:44:31.480
h of k or h of n?

00:44:36.350 --> 00:44:40.010
If I tell you that
I have a system--

00:44:40.010 --> 00:44:42.870
we had an example
up here, didn't we?

00:44:42.870 --> 00:44:45.710
I lost it.

00:44:45.710 --> 00:44:55.920
If I tell you that I have a
system with this unit sample

00:44:55.920 --> 00:44:56.700
response--

00:44:59.830 --> 00:45:01.040
let's do something simple.

00:45:01.040 --> 00:45:09.330
Let's say that this is
1/2 to the n times u of n.

00:45:09.330 --> 00:45:13.325
So for positive time, it's kind
of a decaying geometric series.

00:45:16.450 --> 00:45:19.860
And for negative
time, it's 0, OK?

00:45:19.860 --> 00:45:23.690
So that's an example of a unit
sample response of a system.

00:45:23.690 --> 00:45:27.040
So if that's h of n, what
does h of minus k look like?

00:45:29.670 --> 00:45:30.385
Yeah, anyone?

00:45:30.385 --> 00:45:31.260
AUDIENCE: Reflection.

00:45:31.260 --> 00:45:31.540
GEORGE VERGHESE: Sorry?

00:45:31.540 --> 00:45:32.750
AUDIENCE: Reflection
[INAUDIBLE]..

00:45:32.750 --> 00:45:34.458
GEORGE VERGHESE: It's
the reflection, OK?

00:45:34.458 --> 00:45:38.660
So if I want for n equals 0
to plot just the h of minus k

00:45:38.660 --> 00:45:42.800
that I need here, it's
that reversed and plotted.

00:45:47.590 --> 00:45:49.490
OK, so this is an
h of minus k here.

00:45:53.330 --> 00:45:55.040
What about h of minus k?

00:45:55.040 --> 00:45:56.630
Sorry, what about
h of n minus k?

00:45:56.630 --> 00:46:01.880
Suppose I had n equals 3 now.

00:46:01.880 --> 00:46:03.630
How do I get h of 3 minus k?

00:46:10.520 --> 00:46:15.900
So I want to get h of 3 minus k.

00:46:15.900 --> 00:46:18.800
So that corresponds
to sliding this over.

00:46:18.800 --> 00:46:21.620
Do I slide it to the right
by 3, to the left by 3?

00:46:25.850 --> 00:46:28.160
You can tell by looking
at the argument here.

00:46:28.160 --> 00:46:32.030
Whatever used to happen at 0 has
now got to happen k equals 3.

00:46:32.030 --> 00:46:34.350
So that means a rightward shift.

00:46:34.350 --> 00:46:40.490
OK, so you flip this over, and
then you slide it by n steps,

00:46:40.490 --> 00:46:41.450
OK?

00:46:41.450 --> 00:46:45.860
So you take the h of k, flip
it around to get h of minus k,

00:46:45.860 --> 00:46:48.343
slide it by n steps.

00:46:48.343 --> 00:46:50.510
So if n is positive, you're
sliding it to the right.

00:46:50.510 --> 00:46:53.095
If n is negative, you're
sliding it to the left.

00:46:53.095 --> 00:46:54.470
So now you're on
a single figure.

00:46:54.470 --> 00:46:56.660
You've managed to
plot these two.

00:46:56.660 --> 00:46:58.448
What's the remaining operation?

00:47:01.140 --> 00:47:03.600
What you've got to do is
the point-by-point product

00:47:03.600 --> 00:47:06.360
of these two waveforms and
sum over the entire time axis.

00:47:06.360 --> 00:47:08.910
It's like taking a
dot product, right?

00:47:08.910 --> 00:47:12.420
So you're going to take this
value of the red curve--

00:47:12.420 --> 00:47:15.910
well, actually, let
me slide it over.

00:47:15.910 --> 00:47:17.280
Let's do this case.

00:47:17.280 --> 00:47:19.770
This is the slid-over
case, right?

00:47:22.950 --> 00:47:26.130
You're going to take every one
of the purple values multiplied

00:47:26.130 --> 00:47:29.250
by the white and sum over
the entire time axis.

00:47:29.250 --> 00:47:31.880
That's an
implementation of this.

00:47:31.880 --> 00:47:35.745
So in recitation tomorrow,
you'll get practice on this.

00:47:35.745 --> 00:47:38.090
But what you want
to think of, sort

00:47:38.090 --> 00:47:44.120
of the mantra for graphical
implementation of convolution

00:47:44.120 --> 00:47:48.680
is you've got to do the flip
of one of the time functions,

00:47:48.680 --> 00:48:00.030
slide by n, and then
the product, OK?

00:48:00.030 --> 00:48:03.053
So you slide it to get
one particular value of n.

00:48:03.053 --> 00:48:05.220
If you want the next value
of n, you slide it 1 over

00:48:05.220 --> 00:48:06.553
and go through this whole thing.

00:48:06.553 --> 00:48:09.380
So it's flipping, sliding by
the right number of spots,

00:48:09.380 --> 00:48:10.380
doing the inner product.

00:48:10.380 --> 00:48:12.490
That gives you one
value of the answer.

00:48:12.490 --> 00:48:13.600
And then you repeat.

00:48:13.600 --> 00:48:17.210
All right, you'll get more
practice in recitation.