WEBVTT

00:00:12.837 --> 00:00:13.670
JASON KU: I'm Jason.

00:00:13.670 --> 00:00:16.110
Hopefully you guys
saw me on Tuesday.

00:00:16.110 --> 00:00:20.900
This is our first ever
6.006 problem session

00:00:20.900 --> 00:00:22.910
that we'll be having
on Fridays this term.

00:00:22.910 --> 00:00:25.100
It's really an experiment.

00:00:25.100 --> 00:00:27.100
We've never done this before.

00:00:27.100 --> 00:00:29.600
But one of the things that we
were discussed while preparing

00:00:29.600 --> 00:00:34.310
for this class is that we
have two different methods

00:00:34.310 --> 00:00:38.300
of instruction, formally,
usually in this class--

00:00:38.300 --> 00:00:41.240
a lecture, which is
there to present you with

00:00:41.240 --> 00:00:44.630
the fundamental material,
the data structures,

00:00:44.630 --> 00:00:49.210
and the algorithms that are the
base, the foundation of what--

00:00:49.210 --> 00:00:52.740
how you will be approaching
problems in this class;

00:00:52.740 --> 00:00:58.440
and then the problem sets
that you will work on,

00:00:58.440 --> 00:01:01.310
our applications
of that material.

00:01:01.310 --> 00:01:04.250
But there's usually
a much different feel

00:01:04.250 --> 00:01:07.190
between those problems
that we'll give you then

00:01:07.190 --> 00:01:09.640
the underlying
foundational material.

00:01:09.640 --> 00:01:11.580
So the application
of that material

00:01:11.580 --> 00:01:12.830
will feel very different.

00:01:12.830 --> 00:01:14.330
And a lot of times,
there are tricks

00:01:14.330 --> 00:01:18.560
to approaching the problems
or ways of approaching

00:01:18.560 --> 00:01:21.560
the problems that
you kind of just

00:01:21.560 --> 00:01:23.820
have to figure out by
working on the problem,

00:01:23.820 --> 00:01:26.170
sometimes going to office hours.

00:01:26.170 --> 00:01:30.170
But what we want to
do this term was to--

00:01:30.170 --> 00:01:33.470
since we had the opportunity
to be recorded by OCW,

00:01:33.470 --> 00:01:37.520
was to record us going
through some problems

00:01:37.520 --> 00:01:39.620
that we've had on
problem sets in the past

00:01:39.620 --> 00:01:42.650
so you could see how
we would approach

00:01:42.650 --> 00:01:46.100
working on these problems
that you'll be working on,

00:01:46.100 --> 00:01:47.660
at least in a similar vein.

00:01:47.660 --> 00:01:50.240
So that's the goal of
these problem sessions.

00:01:50.240 --> 00:01:55.020
In the past, for OCW, we
have recorded a recitation,

00:01:55.020 --> 00:01:58.250
but we felt that that was
a little less useful to you

00:01:58.250 --> 00:01:59.960
guys, because
recitation is meant

00:01:59.960 --> 00:02:03.260
for interaction, questions--
one-on-one questions.

00:02:03.260 --> 00:02:05.480
We want to be a safe
space for you guys

00:02:05.480 --> 00:02:08.060
to interact with
the material with--

00:02:08.060 --> 00:02:11.570
in a smaller environment
that might not be recorded.

00:02:11.570 --> 00:02:14.460
So that's the goal of this--

00:02:14.460 --> 00:02:17.660
these sessions that we
will be doing on Fridays.

00:02:17.660 --> 00:02:22.080
Any questions about what
we're going to be doing today?

00:02:22.080 --> 00:02:22.580
OK.

00:02:22.580 --> 00:02:28.240
So we do have a handout up
here by the door, which we may

00:02:28.240 --> 00:02:29.490
or may not have in the future.

00:02:29.490 --> 00:02:30.990
This is all an
experiment, so you'll

00:02:30.990 --> 00:02:34.280
have to work with us as
we figure this stuff out.

00:02:34.280 --> 00:02:39.150
They were posted on LMOD about
an hour before this session.

00:02:39.150 --> 00:02:43.190
We'll try to keep
that as a standard.

00:02:43.190 --> 00:02:45.740
But it just shows
you the questions

00:02:45.740 --> 00:02:48.935
we'll work on today
in the session.

00:02:52.205 --> 00:02:55.520
It isn't just the problem
set from last term.

00:02:55.520 --> 00:02:57.800
It's a selection of problems
from previous terms,

00:02:57.800 --> 00:02:59.420
and some of them
have been edited

00:02:59.420 --> 00:03:02.880
to be maybe a little shorter
and things like that.

00:03:02.880 --> 00:03:04.340
So what we're
going to do is just

00:03:04.340 --> 00:03:05.810
go through the
problems one by one.

00:03:05.810 --> 00:03:10.370
I'll try to just show you how
I'm approaching the problems,

00:03:10.370 --> 00:03:12.920
but at any point, if you want
to, you can ask questions.

00:03:12.920 --> 00:03:13.960
That's fine.

00:03:13.960 --> 00:03:15.380
OK?

00:03:15.380 --> 00:03:18.035
All right, so the first
question we have is--

00:03:18.035 --> 00:03:20.870
has a setup that's
very similar to what

00:03:20.870 --> 00:03:23.180
you will have on your Pset1.

00:03:23.180 --> 00:03:28.670
It's essentially saying that
it has usually many parts.

00:03:28.670 --> 00:03:32.780
This has two parts, an
A part and a B part.

00:03:32.780 --> 00:03:35.780
I've omitted a B
and a C that that

00:03:35.780 --> 00:03:37.400
was on last term's problem set.

00:03:37.400 --> 00:03:40.940
And it has five functions
each, and you're trying

00:03:40.940 --> 00:03:44.540
to order them increasing as--

00:03:44.540 --> 00:03:46.350
based on their
asymptotic behavior.

00:03:46.350 --> 00:03:50.990
So here are the
functions that we have.

00:03:50.990 --> 00:03:52.400
Maybe I'll stick it up instead.

00:03:58.300 --> 00:04:01.388
All right, so we have a
few sets of functions,

00:04:01.388 --> 00:04:02.680
and we just want to order them.

00:04:02.680 --> 00:04:09.730
And some of the functions may
be asymptotically equivalent--

00:04:09.730 --> 00:04:12.280
in which case, when we
are ordering these things,

00:04:12.280 --> 00:04:14.720
we're going to put
those numbers in a set.

00:04:14.720 --> 00:04:19.480
So what we have as an
example are three functions--

00:04:19.480 --> 00:04:24.490
n, root n, and n plus root n.

00:04:24.490 --> 00:04:26.510
This is one, two, three.

00:04:26.510 --> 00:04:28.450
And what we're going
to ask you to do

00:04:28.450 --> 00:04:32.740
is order those functions based
on their asymptotic complexity.

00:04:32.740 --> 00:04:35.410
So hopefully you guys
can get this one.

00:04:35.410 --> 00:04:39.730
Which one's the slowest
growth in terms--

00:04:39.730 --> 00:04:41.410
root n, so number two.

00:04:41.410 --> 00:04:45.340
So if we say f of 2
will be our first one.

00:04:45.340 --> 00:04:48.070
And then, how about
the other two?

00:04:48.070 --> 00:04:49.030
STUDENT: [INAUDIBLE]

00:04:49.030 --> 00:04:50.155
JASON KU: They're the same.

00:04:50.155 --> 00:04:52.060
They're both order n.

00:04:52.060 --> 00:04:57.660
So we would put in set
brackets f1 and f3.

00:04:57.660 --> 00:05:01.420
And on your problem set, if you
put just 2, and 1, and 3 here,

00:05:01.420 --> 00:05:04.120
that would probably be fine.

00:05:04.120 --> 00:05:07.780
But if you were to
put 2 over here or not

00:05:07.780 --> 00:05:11.210
have these curly
braces around here,

00:05:11.210 --> 00:05:14.170
those would not be correct, and
you'd get points marked off.

00:05:14.170 --> 00:05:15.370
Does that make sense?

00:05:15.370 --> 00:05:20.000
OK, so we're going to approach
the first set of problems--

00:05:20.000 --> 00:05:22.150
first set of functions,
which is a little

00:05:22.150 --> 00:05:24.290
different than the
second set of functions.

00:05:24.290 --> 00:05:25.832
Hopefully this one's
a little easier.

00:05:28.130 --> 00:05:30.130
One of the common
approaches that I have

00:05:30.130 --> 00:05:32.650
in going through these things--

00:05:32.650 --> 00:05:35.260
some of these are in a
form that is hard for me

00:05:35.260 --> 00:05:39.430
to tell how they would
compare to other things.

00:05:39.430 --> 00:05:43.750
Actually, most of these
are fine, but in general--

00:05:43.750 --> 00:05:46.600
can anyone, just by
eyeballing, tell me

00:05:46.600 --> 00:05:48.340
an order that works for them?

00:05:51.820 --> 00:05:52.660
Yeah?

00:05:52.660 --> 00:05:54.460
STUDENT: OK--

00:05:54.460 --> 00:05:56.710
JASON KU: This is
a little difficult

00:05:56.710 --> 00:05:58.427
to do on the spot
with five functions.

00:05:58.427 --> 00:05:59.010
STUDENT: Yeah.

00:05:59.010 --> 00:06:00.180
A little iffy about f1.

00:06:00.180 --> 00:06:00.930
JASON KU: OK.

00:06:00.930 --> 00:06:04.370
STUDENT: But f5 is definitely
smaller than f2, which is--

00:06:04.370 --> 00:06:06.625
smaller than f2 which
is smaller than f4.

00:06:06.625 --> 00:06:08.620
And f1 in iffy.

00:06:08.620 --> 00:06:09.910
JASON KU: OK, great.

00:06:09.910 --> 00:06:10.750
That's excellent.

00:06:10.750 --> 00:06:16.150
So what we've got here
is, on f2, f3, and f5,

00:06:16.150 --> 00:06:18.460
you kind of have
this n leading term.

00:06:18.460 --> 00:06:24.700
If we factor an n out of that,
then we're comparing log with--

00:06:24.700 --> 00:06:27.940
basically, we look over here
at the polynomial function.

00:06:27.940 --> 00:06:32.140
This one's smallest out of
them, and then the log factor

00:06:32.140 --> 00:06:34.330
is smaller than a
polynomial factor.

00:06:34.330 --> 00:06:36.810
Log grows slower than linear.

00:06:36.810 --> 00:06:42.250
And so this guy is smaller
than f2 is smaller than f3.

00:06:42.250 --> 00:06:44.500
That's great-- that
your colleague said.

00:06:47.170 --> 00:06:50.080
Hopefully proved in
recitation today--

00:06:50.080 --> 00:07:03.340
no, Wednesday-- this nice fact,
I guess, that a is less than,

00:07:03.340 --> 00:07:06.820
asymptotically,
this polynomial--

00:07:06.820 --> 00:07:11.050
this log n to any power
is asymptotically less

00:07:11.050 --> 00:07:14.800
than any polynomial for
any positive a and b.

00:07:14.800 --> 00:07:17.170
And in particular, there's
actually a stronger thing

00:07:17.170 --> 00:07:20.020
you can say, which is little o.

00:07:20.020 --> 00:07:23.230
Did you guys talk about
little o in recitation at all?

00:07:23.230 --> 00:07:24.400
Probably not.

00:07:24.400 --> 00:07:29.930
It's kind of the same as big
O, except is big O minus theta.

00:07:29.930 --> 00:07:33.610
So things that are
asymptotically equivalent

00:07:33.610 --> 00:07:35.380
are not going to be
included in this set.

00:07:35.380 --> 00:07:37.330
So actually, these
things are strictly

00:07:37.330 --> 00:07:39.790
asymptotic-- grow
strictly asymptotically

00:07:39.790 --> 00:07:41.510
slower than any polynomial.

00:07:41.510 --> 00:07:42.680
Does that make sense?

00:07:42.680 --> 00:07:43.180
OK.

00:07:43.180 --> 00:07:49.262
So knowing this identity,
or this relation,

00:07:49.262 --> 00:07:50.470
can we say anything about f1?

00:07:54.557 --> 00:07:55.390
Maybe someone else--

00:07:55.390 --> 00:07:56.680
STUDENT: Any a and b, right?

00:07:56.680 --> 00:07:59.330
JASON KU: Any a and b--
any positive a and B--

00:07:59.330 --> 00:08:01.670
anyone else have a guess?

00:08:01.670 --> 00:08:03.530
Yeah?

00:08:03.530 --> 00:08:05.630
STUDENT: That f1
is less than f5--

00:08:05.630 --> 00:08:08.150
JASON KU: Yeah, f1 is
less than f5, right?

00:08:08.150 --> 00:08:10.310
Because just using that
identity, this-- sorry--

00:08:10.310 --> 00:08:15.560
a here that erased, stupidly,
is smaller than, say--

00:08:15.560 --> 00:08:23.600
this is bigger than n, and n
to the b, being 1, is bigger.

00:08:23.600 --> 00:08:27.600
And then, as your colleague
pointed out before,

00:08:27.600 --> 00:08:30.840
this thing is exponential,
so definitely higher

00:08:30.840 --> 00:08:31.590
than a polynomial.

00:08:31.590 --> 00:08:32.965
OK, so that was
very easy, right?

00:08:32.965 --> 00:08:36.590
So the answer here
is, if I got--

00:08:36.590 --> 00:08:45.320
if I remember correctly, f1,
f5, f2, f3, and then f4--

00:08:45.320 --> 00:08:47.710
great.

00:08:47.710 --> 00:08:49.480
So that one was pretty easy.

00:08:49.480 --> 00:08:53.360
How about b-- or d, I guess?

00:08:53.360 --> 00:08:53.860
Yeah?

00:08:53.860 --> 00:08:55.210
STUDENT: Can I just
another question--

00:08:55.210 --> 00:08:55.835
JASON KU: Sure.

00:08:55.835 --> 00:08:58.300
STUDENT: [INAUDIBLE] How would
you go about proving that?

00:08:58.300 --> 00:09:00.217
JASON KU: How would you
go about proving that?

00:09:00.217 --> 00:09:04.240
So there is a proof in your
recitation handout there.

00:09:04.240 --> 00:09:08.260
The method in which they proved
that in the recitation handout

00:09:08.260 --> 00:09:15.100
was putting the two--

00:09:15.100 --> 00:09:18.250
taking a ratio of
the two functions

00:09:18.250 --> 00:09:21.580
and taking their limit
as n goes to infinity.

00:09:21.580 --> 00:09:24.480
And if the top one--

00:09:24.480 --> 00:09:29.020
it grows arbitrarily, then
the top one would be--

00:09:29.020 --> 00:09:30.670
grow asymptotically faster.

00:09:30.670 --> 00:09:33.670
And if the it went
to 0, the bottom one

00:09:33.670 --> 00:09:35.530
would grow
asymptotically faster.

00:09:35.530 --> 00:09:37.750
And if it went to
some constant, then

00:09:37.750 --> 00:09:40.810
that would be
asymptotically equivalent.

00:09:40.810 --> 00:09:42.190
Does that make sense?

00:09:42.190 --> 00:09:45.580
In actuality, to make
the limit easier to take,

00:09:45.580 --> 00:09:49.270
we take the limit of the
logarithm of the ratio.

00:09:49.270 --> 00:09:50.890
It just made it easier.

00:09:50.890 --> 00:09:53.470
Does that makes sense?

00:09:53.470 --> 00:09:56.875
OK, so let's move on to b.

00:09:56.875 --> 00:09:59.770
b-- we have a polynomial,
and an exponential,

00:09:59.770 --> 00:10:02.940
and then we have these
things down here.

00:10:02.940 --> 00:10:06.953
What do these things
in parentheses mean?

00:10:06.953 --> 00:10:07.620
STUDENT: Choose.

00:10:07.620 --> 00:10:08.620
JASON KU: Choose, right.

00:10:08.620 --> 00:10:11.190
It's a binomial coefficient.

00:10:11.190 --> 00:10:14.040
Does anyone know the
binomial coefficient is?

00:10:14.040 --> 00:10:14.820
Yeah?

00:10:14.820 --> 00:10:16.470
Hopefully from
6.042 or something

00:10:16.470 --> 00:10:18.510
like that, or whatever
your competition math

00:10:18.510 --> 00:10:20.320
background is--

00:10:20.320 --> 00:10:23.490
but in general, we
have this definition.

00:10:23.490 --> 00:10:24.660
This thing is what?

00:10:24.660 --> 00:10:26.370
Does anyone remember?

00:10:26.370 --> 00:10:29.900
What does n choose k mean?

00:10:29.900 --> 00:10:30.400
Yeah?

00:10:30.400 --> 00:10:33.520
STUDENT: The number of ways
to choose k objects from n

00:10:33.520 --> 00:10:34.020
[INAUDIBLE]

00:10:34.020 --> 00:10:35.853
JASON KU: Yeah, the
number of ways to choose

00:10:35.853 --> 00:10:38.190
k objects from n things--

00:10:38.190 --> 00:10:41.820
I never remember this formula.

00:10:41.820 --> 00:10:45.723
And probably, a lot of you
have memorized this formula.

00:10:45.723 --> 00:10:47.140
I'm not going to
ask you to do it.

00:10:47.140 --> 00:10:50.950
I'm going to tell you
how I think about this.

00:10:50.950 --> 00:10:54.570
What if I want to know the
number of permutations of n

00:10:54.570 --> 00:10:58.190
choose k-- or I mean of n?

00:10:58.190 --> 00:10:58.690
Sorry.

00:10:58.690 --> 00:11:01.680
Just how many permutations
are there of n items?

00:11:01.680 --> 00:11:02.730
What is that?

00:11:02.730 --> 00:11:04.890
That's just n factorial, right?

00:11:04.890 --> 00:11:08.400
So what we do here is
we'd want to choose

00:11:08.400 --> 00:11:11.510
some n number of things.

00:11:14.130 --> 00:11:17.370
I have n factorial different
ways of choosing those,

00:11:17.370 --> 00:11:24.090
but then, essentially, in here
and in here, k and n minus k--

00:11:24.090 --> 00:11:26.940
I don't really care
what their order is.

00:11:26.940 --> 00:11:30.360
So I'm going to divide
out the permutations

00:11:30.360 --> 00:11:32.050
of this stuff and this stuff.

00:11:32.050 --> 00:11:33.520
Does that makes sense?

00:11:33.520 --> 00:11:36.540
So the formula here
as I remember it,

00:11:36.540 --> 00:11:42.300
that hopefully is correct,
is n minus k factorial.

00:11:42.300 --> 00:11:46.440
So I'm getting all of the
permutations of the whole thing

00:11:46.440 --> 00:11:48.930
divided by their constituents.

00:11:48.930 --> 00:11:51.410
Does that make sense?

00:11:51.410 --> 00:11:53.260
Did I do that right?

00:11:53.260 --> 00:11:56.330
OK, cool-- so that's
a nice transformation.

00:11:56.330 --> 00:11:59.152
So the first step is writing
these in terms of factorials.

00:11:59.152 --> 00:12:01.360
That doesn't really help me
any, because I don't know

00:12:01.360 --> 00:12:03.760
how big factorial is based--

00:12:03.760 --> 00:12:06.190
with respect to
these other things.

00:12:06.190 --> 00:12:09.930
Does anyone know how
big factorial is?

00:12:09.930 --> 00:12:10.530
Yeah?

00:12:10.530 --> 00:12:11.820
STUDENT: You can use
Sterling's approximation.

00:12:11.820 --> 00:12:13.778
JASON KU: You can use
Sterling's approximation.

00:12:13.778 --> 00:12:14.670
So that's nice.

00:12:14.670 --> 00:12:18.240
Does anyone remember what
Sterling's approximation is?

00:12:18.240 --> 00:12:19.170
No.

00:12:19.170 --> 00:12:20.280
I don't remember either.

00:12:20.280 --> 00:12:22.380
I always have to look it up.

00:12:22.380 --> 00:12:30.720
Sterling's approximation says
n factorial is approximately--

00:12:30.720 --> 00:12:33.210
and this approximately
is much stronger

00:12:33.210 --> 00:12:38.700
than an asymptotic behavior.

00:12:38.700 --> 00:12:40.860
It's actually, as these things--

00:12:40.860 --> 00:12:43.650
as n approaches infinity,
these things are equal.

00:12:43.650 --> 00:12:46.170
The limit is the identity.

00:12:46.170 --> 00:12:48.660
But the approximation
is the square root

00:12:48.660 --> 00:12:53.760
of 2 pi n n/3 to the n.

00:12:53.760 --> 00:12:54.660
OK, that's fun.

00:12:57.850 --> 00:12:59.260
So what kind of growth is this?

00:13:03.400 --> 00:13:05.620
Super bad, right?

00:13:05.620 --> 00:13:11.190
It's definitely exponential
or higher than exponential.

00:13:11.190 --> 00:13:13.410
It's n to the n--
something like that--

00:13:13.410 --> 00:13:15.360
dividing out an e--

00:13:15.360 --> 00:13:21.890
this is e, the base of
the natural logarithm.

00:13:21.890 --> 00:13:24.015
And this is a
constant, and so is pi.

00:13:24.015 --> 00:13:25.905
Pi is a constant--
kind of interesting

00:13:25.905 --> 00:13:27.780
that we have two
transcendental numbers here.

00:13:27.780 --> 00:13:31.050
That's kind of fun mathematics.

00:13:31.050 --> 00:13:33.690
I'm sure some-- one of
your 6.042 instructors

00:13:33.690 --> 00:13:35.340
could tell you why.

00:13:35.340 --> 00:13:38.370
I can't right now off
the top of my head.

00:13:38.370 --> 00:13:42.330
But this is an approximation
that's very good.

00:13:42.330 --> 00:13:45.510
And actually,
sometimes other people

00:13:45.510 --> 00:13:50.380
will think-- this is what people
call Sterling's approximation.

00:13:50.380 --> 00:13:54.390
One weaker notion that
sometimes is useful for you

00:13:54.390 --> 00:14:01.280
is, if you take the
logarithm of both sides,

00:14:01.280 --> 00:14:03.980
this is asymptotically what?

00:14:08.800 --> 00:14:10.790
If I took the log
of this thing--

00:14:10.790 --> 00:14:12.470
STUDENT: Polynomial--

00:14:12.470 --> 00:14:15.957
JASON KU: It is a
polynomial thing.

00:14:15.957 --> 00:14:16.790
STUDENT: [INAUDIBLE]

00:14:16.790 --> 00:14:20.180
JASON KU: It's
basically n log n.

00:14:20.180 --> 00:14:26.270
If we take a log of this thing,
it would be various things.

00:14:26.270 --> 00:14:28.550
All right, let's do it out.

00:14:28.550 --> 00:14:33.110
2 pi n n/e to the n--

00:14:33.110 --> 00:14:36.710
so when we're inside a
logarithm, multiplication--

00:14:36.710 --> 00:14:38.060
we can split it out--

00:14:38.060 --> 00:14:39.410
becomes addition.

00:14:39.410 --> 00:14:44.150
Division becomes subtraction.

00:14:44.150 --> 00:14:47.880
And this thing grows faster
than all these other things,

00:14:47.880 --> 00:14:51.230
so we can ignore them when we
add them out asymptotically.

00:14:51.230 --> 00:14:53.900
And so what we end up
getting is this n to the n.

00:14:53.900 --> 00:14:55.820
The n comes out
on the logarithm,

00:14:55.820 --> 00:15:00.890
and you get something
that's theta n log n.

00:15:00.890 --> 00:15:03.180
Oh, that's fun.

00:15:03.180 --> 00:15:07.190
This is something we might
use later on in the class.

00:15:07.190 --> 00:15:12.110
OK, but when we are
comparing these functions,

00:15:12.110 --> 00:15:14.750
one of the nice things
to do is convert them

00:15:14.750 --> 00:15:17.090
into something
that's familiar to us

00:15:17.090 --> 00:15:19.400
so that we can
compare them easily.

00:15:19.400 --> 00:15:25.490
So here, this thing is
whatever that thing is, roughly

00:15:25.490 --> 00:15:31.370
square root n n/e to the n.

00:15:31.370 --> 00:15:36.260
This is, I'm going
to say, theta.

00:15:36.260 --> 00:15:38.870
That's a little
bit more precise.

00:15:38.870 --> 00:15:41.227
All right, then what
about these two things?

00:15:41.227 --> 00:15:42.560
Let's start with the bottom one.

00:15:42.560 --> 00:15:45.240
Can someone tell me what
this is, asymptotically?

00:15:45.240 --> 00:15:45.740
Yeah?

00:15:45.740 --> 00:15:46.760
STUDENT: n cubed--

00:15:46.760 --> 00:15:47.630
JASON KU: n cubed--

00:15:47.630 --> 00:15:48.470
why is that?

00:15:48.470 --> 00:15:52.700
Well, if we plug this stuff
into that definition here,

00:15:52.700 --> 00:16:01.100
we have n factorial over 3
factorial n minus 3 factorial.

00:16:01.100 --> 00:16:04.280
n factorial over n
minus 3 factorial

00:16:04.280 --> 00:16:06.620
just leaves us with
an n, an n minus 1,

00:16:06.620 --> 00:16:10.100
and an n minus 2 over 6.

00:16:10.100 --> 00:16:11.900
And if you multiply
all that out,

00:16:11.900 --> 00:16:16.760
the leading term is an
n cubed, so this thing

00:16:16.760 --> 00:16:20.460
is asymptotically n cubed.

00:16:20.460 --> 00:16:23.060
I skipped some steps,
but hopefully you

00:16:23.060 --> 00:16:25.720
could follow that.

00:16:25.720 --> 00:16:32.550
And then the last thing to
remain is this one right there.

00:16:32.550 --> 00:16:35.830
That one's a little tricky.

00:16:35.830 --> 00:16:37.780
Anyone want to help me out here?

00:16:37.780 --> 00:16:41.980
What we can do is we can
stick it into this formula,

00:16:41.980 --> 00:16:44.590
and then apply
Sterling's approximation

00:16:44.590 --> 00:16:47.020
to replace the factorials.

00:16:47.020 --> 00:16:48.280
That makes sense?

00:16:48.280 --> 00:16:50.680
OK, so what I'm going to do is--

00:16:50.680 --> 00:16:53.000
let's do this in two steps.

00:16:53.000 --> 00:16:57.760
This is going to be
n factorial over--

00:16:57.760 --> 00:16:59.800
what is this? n/2
factorial-- and then

00:16:59.800 --> 00:17:02.330
what is n minus n over 2?

00:17:02.330 --> 00:17:03.490
That's also n/2.

00:17:03.490 --> 00:17:10.720
So this is going to be
n/2 factorial squared.

00:17:10.720 --> 00:17:12.099
Is that OK?

00:17:12.099 --> 00:17:13.430
Yeah?

00:17:13.430 --> 00:17:17.119
Now let's replace this stuff
with Sterling's approximation

00:17:17.119 --> 00:17:19.310
and see if we can simplify.

00:17:19.310 --> 00:17:25.940
So on the top, we have 2
pi n n/e to the n over--

00:17:25.940 --> 00:17:31.460
and then we've got
a square here, pi n.

00:17:31.460 --> 00:17:33.860
I cancelled the 2--

00:17:33.860 --> 00:17:37.880
n/2 over e to the n/2.

00:17:40.520 --> 00:17:42.360
Did I do that right?

00:17:42.360 --> 00:17:42.860
OK.

00:17:42.860 --> 00:17:45.110
I can't spell, and
a lot of times,

00:17:45.110 --> 00:17:50.090
I make arithmetic errors, so
catch me if I am doing one.

00:17:50.090 --> 00:17:53.965
OK, so let's simplify
this bottom here.

00:17:53.965 --> 00:17:55.340
I'm not going to
rewrite the top.

00:17:55.340 --> 00:17:57.860
The bottom here--
we square this guy.

00:17:57.860 --> 00:18:00.350
It's the pi times n.

00:18:00.350 --> 00:18:03.470
And then this guy, n/2 squared--

00:18:03.470 --> 00:18:07.010
that just stays is an n.

00:18:07.010 --> 00:18:11.360
Then we have n/2 to the n/e--

00:18:14.540 --> 00:18:18.020
something like that. n/2 over
e to the n-- that makes more--

00:18:18.020 --> 00:18:19.340
me happier.

00:18:19.340 --> 00:18:21.710
OK, so now we have
this over this.

00:18:21.710 --> 00:18:23.130
How do we simplify?

00:18:23.130 --> 00:18:27.230
Well, we can cancel out
one of the root n's.

00:18:27.230 --> 00:18:34.010
So we've got square root of pi
n down here and square root of 2

00:18:34.010 --> 00:18:36.870
up top.

00:18:36.870 --> 00:18:40.590
And then what have we got?

00:18:40.590 --> 00:18:45.030
We've got n to the n down here
and n to the n down-- up there,

00:18:45.030 --> 00:18:46.070
so those cancel.

00:18:46.070 --> 00:18:50.240
We got 1 over e to the n,
1 over e to the n up there.

00:18:50.240 --> 00:18:51.410
Those cancel.

00:18:51.410 --> 00:18:55.240
What's left in this term,
when-- after we cancel?

00:18:55.240 --> 00:18:58.630
1 over 2 to the n in the
denominator, which is

00:18:58.630 --> 00:19:02.080
2 to the n in the numerator--

00:19:02.080 --> 00:19:07.170
so this thing is what
this thing is right.

00:19:07.170 --> 00:19:07.793
Asymptote.

00:19:07.793 --> 00:19:09.210
We can get rid of
these constants.

00:19:09.210 --> 00:19:10.110
And it's root n--

00:19:10.110 --> 00:19:15.520
I mean, it's 2 to the n
over root n, asymptotically.

00:19:15.520 --> 00:19:16.910
Does that makes
sense, everybody?

00:19:16.910 --> 00:19:17.500
OK.

00:19:17.500 --> 00:19:22.930
With that knowledge-- and I'm
sorry for my messy board work--

00:19:22.930 --> 00:19:25.150
what is the ordering of
these functions then?

00:19:25.150 --> 00:19:27.850
Can someone help me out?

00:19:27.850 --> 00:19:34.410
Someone else-- Eric, I'm sorry.

00:19:34.410 --> 00:19:36.210
You can't answer.

00:19:36.210 --> 00:19:37.050
Come on, guys.

00:19:37.050 --> 00:19:38.160
You followed what I said.

00:19:40.740 --> 00:19:44.020
Start it out for me.

00:19:44.020 --> 00:19:49.783
STUDENT: I think [INAUDIBLE]
f2 and f5 [INAUDIBLE]

00:19:49.783 --> 00:19:50.450
JASON KU: Right.

00:19:50.450 --> 00:19:53.120
So both of these things are
asymptotically equivalent,

00:19:53.120 --> 00:19:56.080
so we should put
those in brackets--

00:19:56.080 --> 00:19:59.790
f2, f5.

00:19:59.790 --> 00:20:04.266
STUDENT: And then
it would go f--

00:20:04.266 --> 00:20:07.158
[INAUDIBLE] 3.

00:20:07.158 --> 00:20:07.700
JASON KU: f3.

00:20:07.700 --> 00:20:09.020
This one?

00:20:09.020 --> 00:20:10.504
Why this one?

00:20:10.504 --> 00:20:11.360
STUDENT: Nevermind.

00:20:11.360 --> 00:20:14.540
JASON KU: I'm just asking you
to justify what you're saying.

00:20:14.540 --> 00:20:17.372
STUDENT: Well, because I feel
like we have the [INAUDIBLE]

00:20:17.372 --> 00:20:18.080
JASON KU: Uh-huh.

00:20:18.080 --> 00:20:19.520
STUDENT: [INAUDIBLE]

00:20:19.520 --> 00:20:22.640
JASON KU: This
one's the biggest?

00:20:22.640 --> 00:20:24.512
STUDENT: [INAUDIBLE]

00:20:24.512 --> 00:20:25.970
JASON KU: f4 is
the biggest, right?

00:20:25.970 --> 00:20:28.760
So this one's definitely
bigger than this,

00:20:28.760 --> 00:20:34.790
because it's n to the n,
as opposed to 2 to the n.

00:20:34.790 --> 00:20:40.250
So for any n larger
than 2 plus e

00:20:40.250 --> 00:20:43.680
is fairly obvious
that that's bigger.

00:20:43.680 --> 00:20:45.980
STUDENT: So wouldn't
f3 be before f1?

00:20:45.980 --> 00:20:47.540
JASON KU: Why would
f3 be before f1?

00:20:47.540 --> 00:20:49.790
STUDENT: [INAUDIBLE] 2 to
the n divided by [INAUDIBLE]

00:20:49.790 --> 00:20:52.490
JASON KU: But we're dividing
by a polynomial factor, right?

00:20:52.490 --> 00:20:56.900
So it's going to be
slower asymptotically

00:20:56.900 --> 00:20:59.140
than the first one right there.

00:20:59.140 --> 00:21:01.250
So you got it right.

00:21:01.250 --> 00:21:01.790
What is it?

00:21:01.790 --> 00:21:07.970
F3, f1, and f4--

00:21:07.970 --> 00:21:09.030
OK?

00:21:09.030 --> 00:21:13.040
Cool-- so it's a
little complicated,

00:21:13.040 --> 00:21:17.180
but just applying some
logarithm an exponent rules,

00:21:17.180 --> 00:21:20.840
understanding that logarithmic
factors grow slower

00:21:20.840 --> 00:21:24.140
than polynomial ones,
and again, grow slower

00:21:24.140 --> 00:21:26.090
than exponential ones.

00:21:26.090 --> 00:21:28.310
And being able to do some
transformations of some

00:21:28.310 --> 00:21:30.260
of these mathematical
quantities to get them

00:21:30.260 --> 00:21:33.620
in a polynomial-like
looking form

00:21:33.620 --> 00:21:35.750
is how you're going to
approach these problems.

00:21:35.750 --> 00:21:37.100
Does that make sense?

00:21:37.100 --> 00:21:41.513
All right, so we're going to
move on to question 2 now.

00:21:41.513 --> 00:21:42.680
Yeah, you've got a question?

00:21:42.680 --> 00:21:44.055
STUDENT: Yeah, I
have a question.

00:21:44.055 --> 00:21:46.790
What did you say the
theta bound was for 4?

00:21:46.790 --> 00:21:48.620
JASON KU: Theta bound for 4?

00:21:48.620 --> 00:21:49.170
This guy?

00:21:49.170 --> 00:21:51.870
STUDENT: [INAUDIBLE]

00:21:51.870 --> 00:21:53.750
JASON KU: So it's just that.

00:21:53.750 --> 00:21:56.120
I don't know how to
simplify that any further.

00:21:56.120 --> 00:21:58.180
You've got a
polynomial factor here,

00:21:58.180 --> 00:22:02.450
and then this is an n to the n
term divided by an exponential.

00:22:02.450 --> 00:22:02.950
Yeah?

00:22:02.950 --> 00:22:05.820
STUDENT: For f3,
which one did you--

00:22:05.820 --> 00:22:07.160
how did you reduce--

00:22:07.160 --> 00:22:09.530
which one is f3 [INAUDIBLE]

00:22:09.530 --> 00:22:15.140
JASON KU: f3 took this
little cycle here.

00:22:15.140 --> 00:22:20.720
What we did was we
expanded out the definition

00:22:20.720 --> 00:22:23.150
of the binomial
coefficient here.

00:22:23.150 --> 00:22:25.220
Then we applied
Sterling, and then we

00:22:25.220 --> 00:22:26.880
simplified and got back.

00:22:26.880 --> 00:22:27.920
Does that make sense?

00:22:27.920 --> 00:22:28.662
Yeah?

00:22:28.662 --> 00:22:29.605
STUDENT: [INAUDIBLE]

00:22:29.605 --> 00:22:30.230
JASON KU: Sure.

00:22:30.230 --> 00:22:34.000
STUDENT: Is there a reason
that f3 is before f1?

00:22:34.000 --> 00:22:37.760
JASON KU: Why is f3 before f1?

00:22:37.760 --> 00:22:44.140
If I erase the 2 and the pi,
this thing is theta of that--

00:22:44.140 --> 00:22:47.590
2 to the n over a
polynomial factor.

00:22:47.590 --> 00:22:51.280
It's over n to the 1/2.

00:22:51.280 --> 00:22:55.800
n to the 1/2 grows
non-trivially.

00:22:55.800 --> 00:22:56.440
Right?

00:22:56.440 --> 00:22:59.890
And so this is going to decrease
the running time of this thing

00:22:59.890 --> 00:23:01.590
by a polynomial factor.

00:23:01.590 --> 00:23:02.710
You could think about--

00:23:02.710 --> 00:23:07.220
we're multiplying this by
n to the minus 1/2 as well.

00:23:07.220 --> 00:23:09.550
That's another way
of thinking about it.

00:23:09.550 --> 00:23:12.490
Any other questions?

00:23:12.490 --> 00:23:22.140
OK, so we're going to move
on to problem 2, I guess.

00:23:22.140 --> 00:23:23.630
I need a eraser.

00:23:30.500 --> 00:23:36.150
So problem 2 is kind of
a funny looking problem.

00:23:36.150 --> 00:23:41.960
The point of this
problem is to get

00:23:41.960 --> 00:23:44.600
you to think about using
some of the things we're

00:23:44.600 --> 00:23:48.680
going to be using in this
class as a black box.

00:23:48.680 --> 00:23:50.750
What using something
as a black box

00:23:50.750 --> 00:23:53.780
means is that has a kind of a
public interface that you're

00:23:53.780 --> 00:23:56.180
allowed to work with,
but I'm not allowed

00:23:56.180 --> 00:23:58.370
to see what's inside of it.

00:23:58.370 --> 00:24:00.770
And a lot of times, what
we'll do in this class

00:24:00.770 --> 00:24:04.610
is try to use a
black box and just

00:24:04.610 --> 00:24:09.380
try to use the abstracted
outer functions so that we

00:24:09.380 --> 00:24:10.790
can prove things about it.

00:24:10.790 --> 00:24:13.460
We can just accept
those as true,

00:24:13.460 --> 00:24:17.130
and then use those to
deal with our analysis.

00:24:17.130 --> 00:24:18.860
So what we're given
in this problem

00:24:18.860 --> 00:24:25.190
is a data structure supporting
a sequence interface

00:24:25.190 --> 00:24:27.260
that you heard about yesterday.

00:24:27.260 --> 00:24:28.760
What's a sequence
interface again?

00:24:31.560 --> 00:24:34.110
How does it store items?

00:24:34.110 --> 00:24:35.490
Anyone remember?

00:24:35.490 --> 00:24:36.454
Yeah?

00:24:36.454 --> 00:24:37.780
STUDENT: [INAUDIBLE]

00:24:37.780 --> 00:24:38.750
JASON KU: Well, it--

00:24:38.750 --> 00:24:39.250
OK.

00:24:39.250 --> 00:24:40.637
STUDENT: [INAUDIBLE]

00:24:40.637 --> 00:24:41.470
JASON KU: All right.

00:24:41.470 --> 00:24:43.900
So what your colleague
is saying here

00:24:43.900 --> 00:24:47.410
is we list them in
a contiguous array.

00:24:47.410 --> 00:24:50.100
Does anyone have a problem
with that definition?

00:24:50.100 --> 00:24:51.415
Yeah, up there--

00:24:51.415 --> 00:24:54.980
STUDENT: [INAUDIBLE]

00:24:54.980 --> 00:24:56.530
JASON KU: OK.

00:24:56.530 --> 00:25:01.490
So one of the important
things about this class

00:25:01.490 --> 00:25:03.920
is abstracting this
idea of an interface

00:25:03.920 --> 00:25:05.090
versus an implementation.

00:25:05.090 --> 00:25:08.630
And so what this student
down here was talking

00:25:08.630 --> 00:25:11.958
to me about an array as an
underlying implementation,

00:25:11.958 --> 00:25:14.000
and what the student back
there was talking about

00:25:14.000 --> 00:25:14.940
is a linked list.

00:25:14.940 --> 00:25:19.310
These are both things that
can implement that interface.

00:25:19.310 --> 00:25:22.610
But in reality, the interface
is something abstracted outside

00:25:22.610 --> 00:25:23.840
of those ideas.

00:25:23.840 --> 00:25:27.530
We could implement with either
of those data structures.

00:25:27.530 --> 00:25:31.440
So what makes the sequence
interface a sequence interface?

00:25:31.440 --> 00:25:31.940
Yeah?

00:25:31.940 --> 00:25:33.607
STUDENT: It's in
order, or at least it's

00:25:33.607 --> 00:25:38.570
indexed in a specific way
that allows for [INAUDIBLE]

00:25:38.570 --> 00:25:42.260
JASON KU: So it's about the
data that we're storing.

00:25:42.260 --> 00:25:45.980
We're storing some
number of things,

00:25:45.980 --> 00:25:49.010
and the important thing
is that the data structure

00:25:49.010 --> 00:25:53.090
is maintaining being
able to find items

00:25:53.090 --> 00:25:57.920
in that set by maintaining
an order on them.

00:25:57.920 --> 00:26:00.290
I usually like to call
it an extrinsic order

00:26:00.290 --> 00:26:01.370
on these things.

00:26:01.370 --> 00:26:04.070
It has nothing to do
with what the items are.

00:26:04.070 --> 00:26:06.410
It has to do with how
I put them in order.

00:26:06.410 --> 00:26:08.360
There's a first thing,
there's a 10th thing,

00:26:08.360 --> 00:26:09.410
there's a last thing.

00:26:09.410 --> 00:26:10.130
Right?

00:26:10.130 --> 00:26:13.520
That's what a sequence
of items is right.

00:26:13.520 --> 00:26:16.340
And so what this
data structure is

00:26:16.340 --> 00:26:21.950
doing, that's the input that
is what we have available to us

00:26:21.950 --> 00:26:25.340
in this problem, is some
kind of data structure

00:26:25.340 --> 00:26:28.130
storing a sequence of things.

00:26:28.130 --> 00:26:30.770
And it can support
these four operations--

00:26:30.770 --> 00:26:36.290
an insert first, insert last,
delete first, and delete last.

00:26:36.290 --> 00:26:40.160
And it supports each of those
things in constant time.

00:26:40.160 --> 00:26:44.760
You don't a data structure
that does that yet.

00:26:44.760 --> 00:26:47.790
You will on your
problem set 1, and we'll

00:26:47.790 --> 00:26:51.540
talk about another
way to do that today.

00:26:51.540 --> 00:26:54.550
But we don't care
how it's implemented.

00:26:54.550 --> 00:26:57.090
We just give you this black
box that achieves these things.

00:26:57.090 --> 00:26:59.430
Yay-- awesome.

00:26:59.430 --> 00:27:03.690
And so what we're trying to
do is, we have this thing,

00:27:03.690 --> 00:27:06.570
and I want to be able to
manipulate the sequence stored

00:27:06.570 --> 00:27:12.690
inside, but all I have access to
are these external operations.

00:27:12.690 --> 00:27:19.260
So the idea is going to be
let's implement algorithms

00:27:19.260 --> 00:27:22.080
for these-- some
higher level operations

00:27:22.080 --> 00:27:25.500
in terms of these lower level
things that are given to us.

00:27:25.500 --> 00:27:27.070
Does that makes sense?

00:27:27.070 --> 00:27:29.760
And this is actually a
pretty easy question.

00:27:29.760 --> 00:27:33.180
Hopefully we'll have slightly
more difficult ones for you

00:27:33.180 --> 00:27:33.900
on--

00:27:33.900 --> 00:27:37.200
in a different context
on problem set 1.

00:27:37.200 --> 00:27:42.150
OK, so the first operation
we're going to support--

00:27:42.150 --> 00:27:44.220
or try to support--

00:27:44.220 --> 00:27:49.080
is an operation
called swap_ends.

00:27:49.080 --> 00:27:51.540
And what this is going to do
is take the data structure

00:27:51.540 --> 00:27:52.290
that we gave--

00:27:52.290 --> 00:27:55.530
another way you could do this
is put this as a method on that

00:27:55.530 --> 00:27:57.960
data structure, but let's
do this separately--

00:27:57.960 --> 00:28:00.840
it's going to take that data
structure that we gave--

00:28:00.840 --> 00:28:05.850
that I gave you, that's
storing the sequence,

00:28:05.850 --> 00:28:07.620
as the only argument.

00:28:07.620 --> 00:28:10.470
And what we're
asking you to do is

00:28:10.470 --> 00:28:13.320
describe an algorithm to swap
the first and the last items.

00:28:17.470 --> 00:28:21.660
I it was an array, I could just
look at index 0, look at that,

00:28:21.660 --> 00:28:25.080
look at the last one look
at that, and swap them.

00:28:25.080 --> 00:28:29.010
But I don't have access to what
that underlying representation

00:28:29.010 --> 00:28:33.090
is, so how would I do that
using the things that we

00:28:33.090 --> 00:28:35.470
have available to us?

00:28:35.470 --> 00:28:38.130
This is a pretty easy question.

00:28:38.130 --> 00:28:39.120
What have we got?

00:28:39.120 --> 00:28:39.900
STUDENT: Just a quick question.

00:28:39.900 --> 00:28:40.440
JASON KU: Yeah.

00:28:40.440 --> 00:28:42.232
STUDENT: Does the delete
method also return

00:28:42.232 --> 00:28:43.277
whatever it deletes?

00:28:43.277 --> 00:28:43.860
JASON KU: Yes.

00:28:43.860 --> 00:28:44.440
Yes, it does.

00:28:44.440 --> 00:28:47.490
So in general, if you actually
take a look at the session

00:28:47.490 --> 00:28:49.680
notes, it's giving you
a nice little reminder--

00:28:49.680 --> 00:28:52.770
recall, the delete operations
return the deleted item.

00:28:52.770 --> 00:28:55.380
OK?

00:28:55.380 --> 00:28:56.880
It says it right
there on the thing.

00:28:59.550 --> 00:29:00.960
Yeah?

00:29:00.960 --> 00:29:02.580
STUDENT: Oh, I also
had a question.

00:29:02.580 --> 00:29:03.620
JASON KU: Sure.

00:29:03.620 --> 00:29:05.240
STUDENT: And this
actually [INAUDIBLE]

00:29:05.240 --> 00:29:05.948
JASON KU: Mm-hmm.

00:29:05.948 --> 00:29:08.070
STUDENT: It's not
related [INAUDIBLE]

00:29:08.070 --> 00:29:12.334
if they don't specify a space
[INAUDIBLE] does that mean

00:29:12.334 --> 00:29:13.050
[INAUDIBLE]

00:29:13.050 --> 00:29:14.550
JASON KU: Yeah, so
one of the things

00:29:14.550 --> 00:29:18.760
that Eric talked about yesterday
was generally, in this class,

00:29:18.760 --> 00:29:19.680
if you have--

00:29:19.680 --> 00:29:21.805
usually what we'll give
you is a running time

00:29:21.805 --> 00:29:23.430
bound on the things
that you asked for.

00:29:23.430 --> 00:29:26.970
And because allocation
of space by our model

00:29:26.970 --> 00:29:31.080
takes that amount of
time, the amount of time--

00:29:31.080 --> 00:29:34.020
the amount of space
that we are using

00:29:34.020 --> 00:29:36.690
is going to be asymptotically
upper bounded by the time

00:29:36.690 --> 00:29:39.120
that we're going to
use for the algorithm.

00:29:39.120 --> 00:29:42.840
And so generally, we'll ask you
to stay within a time bound,

00:29:42.840 --> 00:29:45.900
and not ask you to do
something separate with space,

00:29:45.900 --> 00:29:48.960
but there are problems probably
at the end of this unit

00:29:48.960 --> 00:29:52.290
where we might talk
about space complexity.

00:29:52.290 --> 00:29:55.350
But usually, we will
be very specific

00:29:55.350 --> 00:29:58.380
if we want you to
think about space.

00:29:58.380 --> 00:30:00.030
Any other questions?

00:30:00.030 --> 00:30:02.800
All right, so how do we
implement this swap_ends thing?

00:30:02.800 --> 00:30:03.300
Yeah.

00:30:03.300 --> 00:30:05.560
This is a pretty easy one.

00:30:05.560 --> 00:30:06.430
Yeah?

00:30:06.430 --> 00:30:10.140
STUDENT: [INAUDIBLE] say
first equals [INAUDIBLE]

00:30:10.140 --> 00:30:14.850
JASON KU: OK, so another
thing about this class--

00:30:14.850 --> 00:30:17.010
your colleague
over here is trying

00:30:17.010 --> 00:30:23.190
to write code to me, which
is great for a computer,

00:30:23.190 --> 00:30:25.510
and that's great if
you're taking 6.009.

00:30:25.510 --> 00:30:27.510
It's not great if you're
talking to your friends

00:30:27.510 --> 00:30:30.360
or if you're talking to me.

00:30:30.360 --> 00:30:34.460
I can't parse code in my head
and compile it all the time.

00:30:34.460 --> 00:30:37.303
Sometimes I can, but
not all the time,

00:30:37.303 --> 00:30:39.220
especially when it gets
to be a large program.

00:30:39.220 --> 00:30:41.430
So I want you to
explain in words to me,

00:30:41.430 --> 00:30:46.440
and we want you to explain in
words in your LaTeX submissions

00:30:46.440 --> 00:30:49.320
what it is the
algorithm is doing.

00:30:49.320 --> 00:30:52.717
So can you start over
with your description?

00:30:52.717 --> 00:30:53.828
STUDENT: Words are hard.

00:30:53.828 --> 00:30:54.870
JASON KU: Words are hard.

00:30:54.870 --> 00:30:55.780
I agree with you.

00:30:55.780 --> 00:30:57.530
STUDENT: This is a
computer science class.

00:30:57.530 --> 00:31:01.500
STUDENT: I would delete
the last [INAUDIBLE]

00:31:01.500 --> 00:31:04.170
and then take that
value [INAUDIBLE]

00:31:04.170 --> 00:31:05.010
JASON KU: OK.

00:31:05.010 --> 00:31:09.420
So proposal-- we have
a sequence of things.

00:31:09.420 --> 00:31:13.410
Again, as Eric was doing
in lecture yesterday,

00:31:13.410 --> 00:31:15.090
this isn't
representing an array.

00:31:15.090 --> 00:31:16.390
It's representing a sequence.

00:31:16.390 --> 00:31:22.440
So this is the front
first I guessed and last.

00:31:22.440 --> 00:31:28.860
And what your colleague was
saying was to delete this guy

00:31:28.860 --> 00:31:33.870
and stick it on the front,
maybe by using delete last

00:31:33.870 --> 00:31:34.710
and insert first.

00:31:37.230 --> 00:31:39.570
That sounds pretty good.

00:31:39.570 --> 00:31:41.460
Does that do what
swap_ends is doing?

00:31:41.460 --> 00:31:44.490
Swap_ends-- swap the first and
last items in the sequence.

00:31:46.917 --> 00:31:49.000
STUDENT: It's probably
better if we first store it

00:31:49.000 --> 00:31:52.242
in some other variable, so that
way we can get the-- delete

00:31:52.242 --> 00:31:54.030
the n [INAUDIBLE]

00:31:54.030 --> 00:31:56.250
JASON KU: So what your
colleague is saying is,

00:31:56.250 --> 00:31:59.670
well, we've done kind
of half of our work.

00:31:59.670 --> 00:32:01.980
The first one's still over here.

00:32:01.980 --> 00:32:03.075
That's no good.

00:32:03.075 --> 00:32:06.300
Does someone have a
way to modify this?

00:32:06.300 --> 00:32:06.810
Yeah?

00:32:06.810 --> 00:32:10.440
STUDENT: Before modifying,
you can [INAUDIBLE] to modify.

00:32:10.440 --> 00:32:13.085
[INAUDIBLE] about the amount
of things we're storing.

00:32:13.085 --> 00:32:13.710
JASON KU: Yeah.

00:32:13.710 --> 00:32:16.595
So how much extra space
can we use, for example?

00:32:16.595 --> 00:32:17.970
STUDENT: The
easiest way would be

00:32:17.970 --> 00:32:21.030
to delete the last
[INAUDIBLE] the first,

00:32:21.030 --> 00:32:24.370
and then just, if we have
them already kept [INAUDIBLE]

00:32:24.370 --> 00:32:27.232
but I don't know if I can
keep two different variables

00:32:27.232 --> 00:32:27.940
at the same time.

00:32:27.940 --> 00:32:31.650
JASON KU: Good question--
so the question-- can I

00:32:31.650 --> 00:32:32.980
use additional space?

00:32:32.980 --> 00:32:35.040
And in general, if
we don't give you

00:32:35.040 --> 00:32:40.860
any restrictions on what you
can store, then you can go wild.

00:32:40.860 --> 00:32:44.130
Do whatever you want, outside
of this data structure.

00:32:44.130 --> 00:32:49.820
One of the things you
could do is remove first

00:32:49.820 --> 00:32:54.410
all of these things, store
it and some data structure

00:32:54.410 --> 00:32:57.420
you like, manipulate
it as much as you want,

00:32:57.420 --> 00:33:00.170
and then insert first
all the way back in

00:33:00.170 --> 00:33:01.393
and rewrite the thing.

00:33:01.393 --> 00:33:03.560
But that's not going to
give us constant time, which

00:33:03.560 --> 00:33:05.390
is what we're asking for.

00:33:05.390 --> 00:33:10.047
But if we don't tell you
otherwise, feel free to--

00:33:10.047 --> 00:33:12.380
probably, you're only allowed
to store a constant number

00:33:12.380 --> 00:33:14.300
of things, since we
have constant time,

00:33:14.300 --> 00:33:17.420
but generally, unless
we say, no, you

00:33:17.420 --> 00:33:20.690
can't use additional space,
you can use additional space.

00:33:20.690 --> 00:33:21.290
OK?

00:33:21.290 --> 00:33:22.805
So how would you do that?

00:33:22.805 --> 00:33:25.430
STUDENT: I would probably erase
the last one and the first one,

00:33:25.430 --> 00:33:27.980
keep them both, then
answer the first one,

00:33:27.980 --> 00:33:30.188
answer everything else, and
then answer the last one.

00:33:30.188 --> 00:33:31.147
JASON KU: That's great.

00:33:31.147 --> 00:33:32.570
So what your
colleague is saying--

00:33:32.570 --> 00:33:36.830
we delete both of them, we store
them in temporary variables,

00:33:36.830 --> 00:33:39.380
and then, one at a time,
we insert each of them

00:33:39.380 --> 00:33:41.512
in their corresponding
place using the functions

00:33:41.512 --> 00:33:42.470
that we have available.

00:33:42.470 --> 00:33:47.270
OK, so if I were to write
little pseudocode for this,

00:33:47.270 --> 00:33:52.010
I might take the first one--

00:33:52.010 --> 00:33:59.180
I'd delete first.

00:33:59.180 --> 00:34:02.500
I'm really abusing
notation here.

00:34:02.500 --> 00:34:03.110
That's OK.

00:34:03.110 --> 00:34:05.060
You get what I'm saying.

00:34:05.060 --> 00:34:12.350
Delete the last,
and then store them

00:34:12.350 --> 00:34:14.389
in their respective places.

00:34:14.389 --> 00:34:17.040
Insert at the front--

00:34:17.040 --> 00:34:20.380
which one am I going to insert?

00:34:20.380 --> 00:34:20.880
What's up?

00:34:24.989 --> 00:34:26.440
Speak up, guys.

00:34:26.440 --> 00:34:27.120
STUDENT: x2--

00:34:27.120 --> 00:34:28.130
JASON KU: x2-- yes.

00:34:28.130 --> 00:34:29.739
Thank you.

00:34:29.739 --> 00:34:35.500
And insert last, x1--

00:34:35.500 --> 00:34:38.159
OK, that's pretty easy.

00:34:38.159 --> 00:34:39.425
Yeah?

00:34:39.425 --> 00:34:40.800
STUDENT: In this
case, what would

00:34:40.800 --> 00:34:43.000
[INAUDIBLE] I think
this might be relevant.

00:34:43.000 --> 00:34:45.150
[INAUDIBLE] What would
constitute a pseudocode

00:34:45.150 --> 00:34:47.040
versus [INAUDIBLE]
accidentally writing

00:34:47.040 --> 00:34:48.360
Python syntax [INAUDIBLE]

00:34:48.360 --> 00:34:50.429
JASON KU: All right,
so for this problem,

00:34:50.429 --> 00:34:53.310
you'll see the solutions
posted to this later on.

00:34:53.310 --> 00:34:56.828
In that one, I wrote
up a description

00:34:56.828 --> 00:34:59.370
of what I was going to do, and
then I actually-- because this

00:34:59.370 --> 00:35:02.550
was pretty easy, I actually
wrote down some Python code

00:35:02.550 --> 00:35:05.410
to do whatever this thing was.

00:35:05.410 --> 00:35:08.460
But in general--
and it's actually

00:35:08.460 --> 00:35:13.920
OK to write Python or pseudocode
of this form on your problem

00:35:13.920 --> 00:35:15.970
sets, or on an exam,
or something like that.

00:35:15.970 --> 00:35:20.160
But if we can't understand
what your variables mean,

00:35:20.160 --> 00:35:23.910
if we can't understand what
your pseudocode is doing,

00:35:23.910 --> 00:35:26.250
then that's not sufficient.

00:35:26.250 --> 00:35:28.590
So the reason why
we ask for words

00:35:28.590 --> 00:35:33.132
is so that you can
communicate those ideas well.

00:35:33.132 --> 00:35:34.590
STUDENT: Just a
follow-up on that--

00:35:34.590 --> 00:35:36.270
so can you also
have a combination

00:35:36.270 --> 00:35:37.520
of pseudocode and description?

00:35:37.520 --> 00:35:37.885
JASON KU: Sure.

00:35:37.885 --> 00:35:38.385
STUDENT: OK.

00:35:38.385 --> 00:35:40.170
JASON KU: Yeah--
including both of them

00:35:40.170 --> 00:35:44.490
can be clarifying
for you, potentially.

00:35:44.490 --> 00:35:45.833
Any other questions?

00:35:51.810 --> 00:35:55.050
This is not such an
interesting question

00:35:55.050 --> 00:35:56.960
from an algorithm standpoint.

00:35:56.960 --> 00:36:00.150
This is a constant
size problem kind of.

00:36:00.150 --> 00:36:02.520
I have this data structure.

00:36:02.520 --> 00:36:03.660
I do two operations.

00:36:03.660 --> 00:36:05.580
I need to do something.

00:36:05.580 --> 00:36:08.520
And this is so easy that
I'm really not even going

00:36:08.520 --> 00:36:10.000
to argue correctness--

00:36:10.000 --> 00:36:12.390
I'm not even going to
have to argue correctness

00:36:12.390 --> 00:36:14.310
to you, because we're
essentially just doing

00:36:14.310 --> 00:36:17.432
exactly what we asked for.

00:36:17.432 --> 00:36:19.890
Most of the time in this class,
when you're doing something

00:36:19.890 --> 00:36:23.010
non-trivial-- especially when
you're doing something that

00:36:23.010 --> 00:36:25.020
has to recurse in
some way-- we do

00:36:25.020 --> 00:36:27.690
want you to argue correctness.

00:36:27.690 --> 00:36:32.730
But in this case, for example,
the time analysis is very easy.

00:36:32.730 --> 00:36:34.320
We do for operations.

00:36:34.320 --> 00:36:36.690
They each take constant
time, so this operation

00:36:36.690 --> 00:36:37.680
takes constant time--

00:36:37.680 --> 00:36:38.550
done.

00:36:38.550 --> 00:36:39.450
Yeah?

00:36:39.450 --> 00:36:42.810
All right, so how about
the second operation?

00:36:42.810 --> 00:36:48.480
Second operation at least allows
us to use a little bit more.

00:36:48.480 --> 00:36:49.140
So

00:36:49.140 --> 00:36:59.970
Shift_left D, K-- this is the
operation we're supporting now

00:36:59.970 --> 00:37:02.610
is we are given this sequence,
and what we want to do is take

00:37:02.610 --> 00:37:14.730
the first K, here and stick it
over here at the back so that

00:37:14.730 --> 00:37:15.876
the--

00:37:15.876 --> 00:37:17.380
these K go here.

00:37:17.380 --> 00:37:20.580
So the K-th item ends
up being the last item

00:37:20.580 --> 00:37:24.380
and the K plus 1th item
now becomes the first item.

00:37:24.380 --> 00:37:25.900
Does that makes sense?

00:37:25.900 --> 00:37:26.450
OK.

00:37:26.450 --> 00:37:29.650
Again, this is actually not
such an interesting algorithm

00:37:29.650 --> 00:37:34.030
from an algorithm standpoint,
but it's hopefully

00:37:34.030 --> 00:37:37.220
helpful to talk about from an
instructional point of view.

00:37:37.220 --> 00:37:37.750
OK?

00:37:37.750 --> 00:37:39.760
So how would I
approach this problem?

00:37:39.760 --> 00:37:47.350
I need this operation to
happen in order K time.

00:37:47.350 --> 00:37:47.890
Yeah?

00:37:47.890 --> 00:37:48.390
STUDENT: OK.

00:37:48.390 --> 00:37:50.680
So first, go and delete--

00:37:50.680 --> 00:37:55.810
set a variable x1 to be the
d dot delete first element.

00:37:55.810 --> 00:38:01.990
Then do d dot insert at the
last x1, write a for loop,

00:38:01.990 --> 00:38:03.250
and then do that K times.

00:38:03.250 --> 00:38:05.588
And that should take
2K steps, which is OK.

00:38:05.588 --> 00:38:06.130
JASON KU: OK.

00:38:06.130 --> 00:38:08.020
So what your
colleague was saying

00:38:08.020 --> 00:38:12.400
is that we're just going
to delete this guy,

00:38:12.400 --> 00:38:16.900
stick it on there,
do it K times.

00:38:16.900 --> 00:38:18.160
That sound good?

00:38:18.160 --> 00:38:19.390
Yeah.

00:38:19.390 --> 00:38:22.180
One of the things in this
class that you have, in terms

00:38:22.180 --> 00:38:24.340
of implementation--

00:38:24.340 --> 00:38:26.950
usually there are two ways--

00:38:26.950 --> 00:38:28.720
at least two ways you
could do something

00:38:28.720 --> 00:38:31.210
that takes longer
than constant time.

00:38:31.210 --> 00:38:34.180
You could write a four loop
where you could use recursion.

00:38:37.070 --> 00:38:40.610
Sometimes approaching a
problem would be good one way,

00:38:40.610 --> 00:38:42.440
rather than another.

00:38:42.440 --> 00:38:47.030
Why is it that a lot
of computer scientists,

00:38:47.030 --> 00:38:49.730
as opposed to coding
engineers, prefer to think

00:38:49.730 --> 00:38:51.200
about an algorithm recursively?

00:38:51.200 --> 00:38:52.820
Does anyone know why?

00:38:52.820 --> 00:38:55.640
At least I do, when
I'm explaining it

00:38:55.640 --> 00:38:57.290
from a theory standpoint.

00:38:57.290 --> 00:38:59.480
It actually might not be
good from an implementation

00:38:59.480 --> 00:39:02.383
standpoint, because your
computer can vectorized

00:39:02.383 --> 00:39:04.550
for loops and things like--
but that's not something

00:39:04.550 --> 00:39:06.470
we need to talk about.

00:39:06.470 --> 00:39:10.250
Why would we want to talk
about a recursive algorithm

00:39:10.250 --> 00:39:11.270
maybe more?

00:39:11.270 --> 00:39:13.770
STUDENT: It lets you break up
the problem into much smaller,

00:39:13.770 --> 00:39:14.960
more manageable pieces.

00:39:14.960 --> 00:39:18.320
JASON KU: OK, so recursion
lets you break up the problem

00:39:18.320 --> 00:39:20.720
into small measurable pieces.

00:39:20.720 --> 00:39:25.670
That's actually true
in some context.

00:39:25.670 --> 00:39:28.190
How I like to think about
recursion a lot of times is,

00:39:28.190 --> 00:39:31.760
if I have a non-constant amount
of work that I have to do,

00:39:31.760 --> 00:39:33.530
usually easy for me--

00:39:33.530 --> 00:39:35.810
it's hard for me to hold
a non-constant amount

00:39:35.810 --> 00:39:38.317
of information in my head.

00:39:38.317 --> 00:39:40.400
What I want to do is think
about a constant amount

00:39:40.400 --> 00:39:43.730
of information at any
given point in time,

00:39:43.730 --> 00:39:46.220
because that's easier
for me to argue on.

00:39:46.220 --> 00:39:51.080
It's easier for me to think
about making arguments, case

00:39:51.080 --> 00:39:54.120
analysis on these
small amount of things.

00:39:54.120 --> 00:39:56.360
And so one of the
things you can do

00:39:56.360 --> 00:40:01.040
is, if you break it down
so that I solve a slightly

00:40:01.040 --> 00:40:03.650
smaller problem
recursively, and then

00:40:03.650 --> 00:40:09.150
do a constant amount of work
and maintain some invariant,

00:40:09.150 --> 00:40:12.600
then it's very easy to
argue things about it.

00:40:12.600 --> 00:40:14.990
It's very easy for
me to convince myself

00:40:14.990 --> 00:40:17.240
that this thing's correct.

00:40:17.240 --> 00:40:21.770
So I'm going to
provide a recursive way

00:40:21.770 --> 00:40:23.120
of solving this problem.

00:40:23.120 --> 00:40:25.630
Can anyone set up
maybe a recursive way

00:40:25.630 --> 00:40:27.380
of thinking about this
problem, instead of

00:40:27.380 --> 00:40:30.050
putting this inside a for loop,
like your colleague was saying?

00:40:37.810 --> 00:40:39.430
Yeah?

00:40:39.430 --> 00:40:40.965
STUDENT: [INAUDIBLE]
people do is

00:40:40.965 --> 00:40:45.270
just consider what will happen
when k equals 0 you're not

00:40:45.270 --> 00:40:46.328
[INAUDIBLE] it at all.

00:40:46.328 --> 00:40:46.870
JASON KU: OK.

00:40:46.870 --> 00:40:49.870
STUDENT: [INAUDIBLE]
what it originally was.

00:40:49.870 --> 00:40:51.830
And then-- but if that
k is greater than 0,

00:40:51.830 --> 00:40:57.010
you just [INAUDIBLE] and
then [INAUDIBLE] k is 1 less

00:40:57.010 --> 00:40:59.830
[INAUDIBLE]

00:40:59.830 --> 00:41:01.580
JASON KU: So what your
colleague is saying

00:41:01.580 --> 00:41:04.760
is setting up the--
a very nice thing.

00:41:04.760 --> 00:41:09.590
She's saying that, if we
think about this recursively,

00:41:09.590 --> 00:41:11.610
we'll think about a base case--

00:41:11.610 --> 00:41:14.300
which, your colleague was
saying maybe K equals 0.

00:41:16.820 --> 00:41:19.910
And otherwise, if
we're not at 0,

00:41:19.910 --> 00:41:25.220
what we'll do is we'll start
it out, move one of these guys

00:41:25.220 --> 00:41:29.740
over, and then we have
an instance where we want

00:41:29.740 --> 00:41:32.440
to shift K minus 1 things over.

00:41:35.680 --> 00:41:39.050
Want to do the same thing,
but with K minus 1 things.

00:41:39.050 --> 00:41:42.160
And so we can just call this
thing for a smaller value

00:41:42.160 --> 00:41:43.450
of K. Does that makes sense?

00:41:46.010 --> 00:41:47.760
All right, so let's
try to write that out.

00:41:54.180 --> 00:41:58.926
The first thing I'm going to
write out is kind of a break.

00:41:58.926 --> 00:42:03.480
If I'm at a base case, let's
not do anything to this thing.

00:42:03.480 --> 00:42:04.920
And maybe I also
want some bounce

00:42:04.920 --> 00:42:07.980
checking to make sure
that we're in range.

00:42:07.980 --> 00:42:14.917
OK, so I'm going to say,
if our K is less than 1,

00:42:14.917 --> 00:42:17.250
I don't think we should be
doing anything to this array.

00:42:17.250 --> 00:42:19.260
So let's just not do anything.

00:42:19.260 --> 00:42:26.700
If K is less than
1 or K is bigger

00:42:26.700 --> 00:42:32.040
than the length of D minus
1-- so I don't know what

00:42:32.040 --> 00:42:36.620
to do if you're asking me to
shift more than the things I

00:42:36.620 --> 00:42:39.560
have, so let's not do that.

00:42:45.980 --> 00:42:48.980
Yeah-- because if
it was length of D,

00:42:48.980 --> 00:42:51.140
we would just not
move anything anyway,

00:42:51.140 --> 00:42:52.727
because we'd shift
the whole thing.

00:42:52.727 --> 00:42:54.060
So we don't have to do anything.

00:42:54.060 --> 00:42:54.410
All right.

00:42:54.410 --> 00:42:55.830
If we're in either
of these cases,

00:42:55.830 --> 00:43:00.042
we're just going to return,
because I either shouldn't

00:43:00.042 --> 00:43:02.000
do anything to the array
or I have no idea what

00:43:02.000 --> 00:43:04.100
you're talking about,
if it's negative

00:43:04.100 --> 00:43:05.710
or something like that.

00:43:05.710 --> 00:43:07.480
OK, so that's the first thing.

00:43:07.480 --> 00:43:09.760
Otherwise, what do we do?

00:43:09.760 --> 00:43:14.350
We shift one thing over and
then we make a recursive call.

00:43:14.350 --> 00:43:16.050
Does that make sense?

00:43:16.050 --> 00:43:18.920
OK.

00:43:18.920 --> 00:43:27.890
So we'll delete the first
thing as a temporary variable--

00:43:27.890 --> 00:43:28.865
delete first.

00:43:31.910 --> 00:43:40.220
And then we'll insert last, x.

00:43:44.732 --> 00:43:46.770
And then we need to
do the recursive call.

00:43:46.770 --> 00:43:49.040
So what's a recursive
call look like?

00:43:49.040 --> 00:43:49.540
Yeah?

00:43:49.540 --> 00:43:51.995
STUDENT: Shift_left
D, K minus 1--

00:43:51.995 --> 00:43:52.620
JASON KU: Yeah.

00:43:52.620 --> 00:44:00.540
So shift_left D, K minus 1--

00:44:00.540 --> 00:44:02.550
OK?

00:44:02.550 --> 00:44:04.808
And then we can return.

00:44:04.808 --> 00:44:06.600
This thing doesn't need
to return anything.

00:44:06.600 --> 00:44:08.310
It's just doing
stuff to the thing.

00:44:08.310 --> 00:44:09.910
Right?

00:44:09.910 --> 00:44:13.090
And whenever we
get this K, we make

00:44:13.090 --> 00:44:17.830
a call, that gets down
to 0, we will terminate

00:44:17.830 --> 00:44:19.780
because we will return.

00:44:19.780 --> 00:44:22.180
We're in this range
somewhere between we--

00:44:22.180 --> 00:44:24.860
have an input after this line.

00:44:24.860 --> 00:44:30.070
We know that K is somewhere
between 1 and n minus 1.

00:44:30.070 --> 00:44:33.160
And what we'll do is, every
time through this recursion,

00:44:33.160 --> 00:44:36.800
we will subtract 1
from K. So this is

00:44:36.800 --> 00:44:40.270
a nice, well-ordered sequence.

00:44:40.270 --> 00:44:45.150
We do the correct thing
obviously in the base case,

00:44:45.150 --> 00:44:48.270
and as long as this thing
was correct for a smaller

00:44:48.270 --> 00:44:52.650
value of K, this thing also
does the correct thing,

00:44:52.650 --> 00:44:55.710
because we're shifting
over one, as we are asked,

00:44:55.710 --> 00:44:59.460
and we're letting this
do the work of the rest.

00:44:59.460 --> 00:45:01.110
I don't have to
think about that.

00:45:01.110 --> 00:45:04.990
I just have to think about
this one loop, this one part

00:45:04.990 --> 00:45:06.520
of the thing that I'm doing.

00:45:06.520 --> 00:45:08.890
Constant amount of work
is done in this section.

00:45:08.890 --> 00:45:12.430
And how many times
do I call a function?

00:45:12.430 --> 00:45:13.545
STUDENT: [INAUDIBLE]

00:45:13.545 --> 00:45:14.170
JASON KU: Yeah.

00:45:14.170 --> 00:45:15.818
I think K minus 1 times, or--

00:45:15.818 --> 00:45:16.360
I don't know.

00:45:16.360 --> 00:45:16.900
I forget.

00:45:16.900 --> 00:45:18.940
But it's ordered
K for sure, right?

00:45:18.940 --> 00:45:22.090
And we do a constant
amount of work per call,

00:45:22.090 --> 00:45:24.340
ignoring this extra call.

00:45:24.340 --> 00:45:26.230
Does that make sense?

00:45:26.230 --> 00:45:31.330
So this thing runs in
order K, as desired.

00:45:31.330 --> 00:45:32.140
OK?

00:45:32.140 --> 00:45:33.700
Does that make sense?

00:45:33.700 --> 00:45:34.900
All right.

00:45:34.900 --> 00:45:39.090
So now we will move
on to question 3.

00:45:43.000 --> 00:45:45.190
Any questions about question 2?

00:45:45.190 --> 00:45:48.190
That one's really probably
one of the easiest problems

00:45:48.190 --> 00:45:51.490
we've ever had on a problem set.

00:45:51.490 --> 00:45:54.750
Sorry to scare you.

00:45:54.750 --> 00:45:55.950
So problem 3--

00:45:55.950 --> 00:46:00.000
OK, so this is a little
block of text right here.

00:46:00.000 --> 00:46:02.430
A dynamic array can support
a sequence interface

00:46:02.430 --> 00:46:04.380
supporting worst case
constant time indexing

00:46:04.380 --> 00:46:06.210
as well as insertion
and removal of items

00:46:06.210 --> 00:46:09.570
at the back of the array
in amortized constant time.

00:46:09.570 --> 00:46:12.420
So this is what we did
yesterday in lecture, right?

00:46:12.420 --> 00:46:14.670
We showed how a dynamic array--

00:46:14.670 --> 00:46:19.800
it's fast to do dynamic
operations at the end.

00:46:19.800 --> 00:46:20.610
OK.

00:46:20.610 --> 00:46:22.620
However, insertion and
deletion at the front

00:46:22.620 --> 00:46:25.360
is not very efficient because,
if you tried to do that,

00:46:25.360 --> 00:46:27.150
you'd have to shift
everything over.

00:46:27.150 --> 00:46:28.440
That makes sense?

00:46:28.440 --> 00:46:30.960
All right, on the other hand,
what we talked about yesterday

00:46:30.960 --> 00:46:32.790
was linked lists.

00:46:32.790 --> 00:46:37.530
They can be made to support
insertion and deletion

00:46:37.530 --> 00:46:38.998
at both ends in constant time.

00:46:38.998 --> 00:46:41.040
OK, so that's a little
foreshadowing of something

00:46:41.040 --> 00:46:43.470
you're going to do on Pset1.

00:46:43.470 --> 00:46:47.880
But in lecture, we talked
about that operation--

00:46:47.880 --> 00:46:50.280
that data structure,
a singly linked list,

00:46:50.280 --> 00:46:53.760
being good at dynamic operations
at the front of the list,

00:46:53.760 --> 00:46:55.440
because essentially,
we could just

00:46:55.440 --> 00:46:57.030
remember where the
front of the list

00:46:57.030 --> 00:47:01.050
was and swap things
in as needed.

00:47:01.050 --> 00:47:01.852
That makes sense?

00:47:01.852 --> 00:47:03.810
So on your problem set,
what you're going to do

00:47:03.810 --> 00:47:09.120
is make end operations good
on the linked list as well,

00:47:09.120 --> 00:47:13.320
as well as supporting
another operation.

00:47:13.320 --> 00:47:17.340
But what's the problem
with linked lists,

00:47:17.340 --> 00:47:20.890
as compared to dynamic arrays?

00:47:20.890 --> 00:47:21.390
Yeah?

00:47:21.390 --> 00:47:25.110
STUDENT: Linked list lookups
can take up to linear time.

00:47:25.110 --> 00:47:26.610
JASON KU: Yeah,
linked lists lookups

00:47:26.610 --> 00:47:29.220
can take linear time,
because I have no--

00:47:29.220 --> 00:47:32.520
I don't have the benefit of
an array, where I can randomly

00:47:32.520 --> 00:47:36.480
access something in the middle
by essentially just doing

00:47:36.480 --> 00:47:38.820
one arithmetic
offset calculation

00:47:38.820 --> 00:47:43.920
from the front address and be
able to find this thing further

00:47:43.920 --> 00:47:47.520
down in constant time using
our model of computation

00:47:47.520 --> 00:47:49.770
of the random net
access machine.

00:47:49.770 --> 00:47:51.510
In a linked list,
these things could

00:47:51.510 --> 00:47:53.220
be stored all over
the place in memory,

00:47:53.220 --> 00:47:57.810
and I have to traverse those
pointers until I get to the one

00:47:57.810 --> 00:47:59.790
that I'm looking for.

00:47:59.790 --> 00:48:03.030
That's a benefit of
an array-based data

00:48:03.030 --> 00:48:07.170
structure versus a
linked, pointer-based one.

00:48:07.170 --> 00:48:11.280
OK, so then we get to the
meat of this question.

00:48:11.280 --> 00:48:14.250
Show that we can have
the best of both worlds--

00:48:14.250 --> 00:48:17.250
we can have a data
structure that

00:48:17.250 --> 00:48:20.700
supports worst case
constant time lookup, just

00:48:20.700 --> 00:48:25.790
like an array, but amortized
constant time dynamic

00:48:25.790 --> 00:48:31.220
operations from the back and
the front of the sequence.

00:48:31.220 --> 00:48:33.220
Does that make sense?

00:48:33.220 --> 00:48:34.420
All right.

00:48:34.420 --> 00:48:35.630
Is this question or a--

00:48:35.630 --> 00:48:36.130
OK.

00:48:36.130 --> 00:48:38.088
STUDENT: Can you define
amortize one more time?

00:48:38.088 --> 00:48:39.070
JASON KU: Yes.

00:48:39.070 --> 00:48:40.540
Sorry about that.

00:48:40.540 --> 00:48:42.550
Can I define amortize
one more time?

00:48:42.550 --> 00:48:50.260
OK, so this is a tough
thing to define in general,

00:48:50.260 --> 00:48:52.090
but not that much.

00:48:52.090 --> 00:48:56.602
All right, so amortization
usually you put in--

00:48:56.602 --> 00:48:58.060
at least in this
class, we're going

00:48:58.060 --> 00:49:00.520
to put in terms of
a data structure.

00:49:00.520 --> 00:49:02.110
So you have this thing.

00:49:02.110 --> 00:49:03.880
It supports some
operations, and you're

00:49:03.880 --> 00:49:06.850
going to do a bunch of
operations on that thing.

00:49:06.850 --> 00:49:09.100
There's not really a reason
to have a data structure,

00:49:09.100 --> 00:49:11.740
unless you're going to
do lots of things to it.

00:49:11.740 --> 00:49:14.530
Otherwise, you just
write a single algorithm

00:49:14.530 --> 00:49:18.745
to do whatever it is
that you want to do.

00:49:18.745 --> 00:49:20.830
The value of the
data structure is

00:49:20.830 --> 00:49:23.590
that you can do
some work up front

00:49:23.590 --> 00:49:28.090
by making this thing make some
of these operations faster.

00:49:28.090 --> 00:49:28.720
OK?

00:49:28.720 --> 00:49:33.100
So what amortization
means is, OK,

00:49:33.100 --> 00:49:36.790
if I have, say, a
dynamic array, where

00:49:36.790 --> 00:49:42.190
I'm going to be inserting
things at the end,

00:49:42.190 --> 00:49:45.070
sometimes, when I
add something, I'm

00:49:45.070 --> 00:49:47.430
going to spend a lot of
time to add that thing.

00:49:47.430 --> 00:49:49.540
I'm going to spend linear time.

00:49:49.540 --> 00:49:51.992
But what's the
point of this data

00:49:51.992 --> 00:49:53.200
structure in the first place?

00:49:53.200 --> 00:49:56.500
The point is that I want to
be able to potentially add

00:49:56.500 --> 00:49:58.330
a lot of things to this thing.

00:49:58.330 --> 00:50:00.430
Does that make sense?

00:50:00.430 --> 00:50:03.310
Amortization is saying
that, even though sometimes

00:50:03.310 --> 00:50:09.007
this operation will be bad,
averaged over many operations,

00:50:09.007 --> 00:50:10.840
this is going to have
a better running time.

00:50:10.840 --> 00:50:11.840
That's the amortization.

00:50:11.840 --> 00:50:14.590
So more formally, what
that's going to say is,

00:50:14.590 --> 00:50:17.920
if I have an operation, the
definition of it running

00:50:17.920 --> 00:50:23.850
in amortized some amount
of time-- say K time or--

00:50:23.850 --> 00:50:30.080
yeah, sure-- that means
that, if I do n operations,

00:50:30.080 --> 00:50:32.870
generally for large N--

00:50:32.870 --> 00:50:36.380
if I do that operation n
times, the total time it takes

00:50:36.380 --> 00:50:39.410
me to do all of those
operations is not

00:50:39.410 --> 00:50:42.290
going to be more than n
times K. So on average,

00:50:42.290 --> 00:50:44.300
it's going to take me K time.

00:50:44.300 --> 00:50:48.230
Now, in O-4-6 you'll get a
more formal definition of that

00:50:48.230 --> 00:50:52.640
and you'll get a lot of
ways of analyzing things,

00:50:52.640 --> 00:50:55.680
like a potential function and--

00:50:55.680 --> 00:50:58.130
we're going to use in what
we call charging arguments

00:50:58.130 --> 00:51:01.430
even today.

00:51:01.430 --> 00:51:05.370
So it's a much broader
analysis paradigm

00:51:05.370 --> 00:51:06.870
than what we're
going to talk about.

00:51:06.870 --> 00:51:08.245
We're only going
to talk about it

00:51:08.245 --> 00:51:10.880
for this material
with dynamic arrays,

00:51:10.880 --> 00:51:12.320
and we'll just kind of--

00:51:12.320 --> 00:51:14.488
it's just kind of an
introduction to that.

00:51:14.488 --> 00:51:15.530
But does that make sense?

00:51:15.530 --> 00:51:16.072
STUDENT: Yes.

00:51:16.072 --> 00:51:19.790
JASON KU: Amortized as
a financial term, if you

00:51:19.790 --> 00:51:24.690
know from financial term,
means over the long term,

00:51:24.690 --> 00:51:26.030
this is what it is on average.

00:51:26.030 --> 00:51:27.110
You can think about--

00:51:27.110 --> 00:51:29.090
but that's different
than running time.

00:51:29.090 --> 00:51:33.380
That's average running
time of an algorithm.

00:51:33.380 --> 00:51:35.330
It's a much different concept.

00:51:35.330 --> 00:51:38.000
What is an average running time?

00:51:38.000 --> 00:51:40.310
Well, that's hard to
define, because it's

00:51:40.310 --> 00:51:44.315
talking about an average over
all possible inputs, and then--

00:51:44.315 --> 00:51:47.660
OK, so maybe some inputs
are more likely than others,

00:51:47.660 --> 00:51:49.670
and so you've got a
distribution on the inputs

00:51:49.670 --> 00:51:53.330
and you're trying to average
the running time of--

00:51:53.330 --> 00:51:55.160
this has nothing
to do with that.

00:51:55.160 --> 00:51:58.280
Amortization means that
you have a-- usually a data

00:51:58.280 --> 00:52:00.650
structure that
you're operating on,

00:52:00.650 --> 00:52:03.080
and you're doing an
operation multiple times,

00:52:03.080 --> 00:52:05.390
and you're getting a
benefit because you're doing

00:52:05.390 --> 00:52:07.200
that operation lots of times.

00:52:07.200 --> 00:52:11.120
And so when you are
instantiating a Python list

00:52:11.120 --> 00:52:15.590
and you're doing push and
pop operations on the back,

00:52:15.590 --> 00:52:16.250
that's--

00:52:16.250 --> 00:52:17.370
or is it append--

00:52:17.370 --> 00:52:18.203
STUDENT: [INAUDIBLE]

00:52:18.203 --> 00:52:19.880
JASON KU: Append and pop?

00:52:19.880 --> 00:52:20.420
OK.

00:52:20.420 --> 00:52:25.820
I've been writing JavaScript
a little bit recently.

00:52:25.820 --> 00:52:28.250
But so append and pop--

00:52:28.250 --> 00:52:32.660
those operations, while
not cheap all the time,

00:52:32.660 --> 00:52:37.070
are cheap well enough that, when
we analyze an entire algorithm

00:52:37.070 --> 00:52:42.350
that might do a linear number
of appends to this list,

00:52:42.350 --> 00:52:44.450
all of those appends
added together

00:52:44.450 --> 00:52:46.352
will only take linear
time, because I've

00:52:46.352 --> 00:52:47.560
done a linear number of them.

00:52:47.560 --> 00:52:48.140
Does that make sense?

00:52:48.140 --> 00:52:48.490
STUDENT: Yeah.

00:52:48.490 --> 00:52:49.190
Thank you.

00:52:49.190 --> 00:52:52.520
JASON KU: OK-- long-winded
answer to your question.

00:52:52.520 --> 00:52:54.350
Sorry about that.

00:52:54.350 --> 00:52:57.730
Any other questions
before we get going?

00:52:57.730 --> 00:52:59.500
All right.

00:52:59.500 --> 00:53:02.200
Anyone have any
ideas of how we can

00:53:02.200 --> 00:53:07.330
use the ideas of a dynamic array
and make it good for operations

00:53:07.330 --> 00:53:08.826
on both ends?

00:53:08.826 --> 00:53:11.690
I'll let someone else answer.

00:53:11.690 --> 00:53:14.350
I'll give a second, and
then go to you in a sec.

00:53:14.350 --> 00:53:15.574
Yeah?

00:53:15.574 --> 00:53:19.438
STUDENT: So [INAUDIBLE] dynamic
[INAUDIBLE] left true on one

00:53:19.438 --> 00:53:20.750
end [INAUDIBLE]

00:53:20.750 --> 00:53:21.480
JASON KU: Sure.

00:53:21.480 --> 00:53:24.250
STUDENT: [INAUDIBLE] here we
could leave some [INAUDIBLE]

00:53:24.250 --> 00:53:28.100
JASON KU: That's
an excellent idea.

00:53:28.100 --> 00:53:31.390
We're going to talk about
two ways of doing this.

00:53:31.390 --> 00:53:31.890
Right.

00:53:31.890 --> 00:53:34.730
So what your colleague was
saying was that, in lecture,

00:53:34.730 --> 00:53:37.730
when we're talking about
dynamic ways and we want to make

00:53:37.730 --> 00:53:41.720
operations on the
right side-- the end--

00:53:41.720 --> 00:53:46.100
fast, what we did was we
allocated some extra space

00:53:46.100 --> 00:53:49.152
at the end, and then,
when we added things,

00:53:49.152 --> 00:53:50.360
we didn't have to reallocate.

00:53:50.360 --> 00:53:52.700
We had space to
put those things.

00:53:52.700 --> 00:53:55.850
So what your colleague
was saying was,

00:53:55.850 --> 00:53:58.730
let's just do the same
thing on both ends.

00:53:58.730 --> 00:54:01.970
Let's leave some extra space
on the front and extra space

00:54:01.970 --> 00:54:04.490
on the back when we
instantiate this thing,

00:54:04.490 --> 00:54:09.650
and then we can rebuild
less frequently than if we

00:54:09.650 --> 00:54:11.140
didn't have that extra space.

00:54:11.140 --> 00:54:12.140
Does that makes sense?

00:54:12.140 --> 00:54:18.000
OK, so what we had for,
let's say, down here--

00:54:18.000 --> 00:54:20.000
so this is question 3--

00:54:20.000 --> 00:54:22.640
the idea of the
dynamic array right

00:54:22.640 --> 00:54:29.600
was that we left some
extra space here at the end

00:54:29.600 --> 00:54:34.700
so that, sure, we allocated
more than we needed to,

00:54:34.700 --> 00:54:38.570
but when we insert
things now, it's cheap.

00:54:38.570 --> 00:54:42.410
And we don't have to allocate
more space for this thing

00:54:42.410 --> 00:54:46.130
until we've done a linear
number of insertions.

00:54:46.130 --> 00:54:47.510
This was n.

00:54:47.510 --> 00:54:48.410
This was n.

00:54:48.410 --> 00:54:51.200
Really any constant
factor will do here.

00:54:51.200 --> 00:54:52.910
But if you had n
things here, we'd

00:54:52.910 --> 00:54:55.700
be assured that I
wouldn't need to rebuild

00:54:55.700 --> 00:54:59.870
this thing until I've done a
linear number of operations.

00:54:59.870 --> 00:55:04.970
And so in a sense, I can charge
the linear time operation

00:55:04.970 --> 00:55:09.140
of re-expanding this thing to
each one of those operations.

00:55:09.140 --> 00:55:11.180
And so on average,
it'll be constant.

00:55:11.180 --> 00:55:12.300
Does that makes sense?

00:55:12.300 --> 00:55:12.800
Right.

00:55:12.800 --> 00:55:16.430
So instead, what your
colleague was saying--

00:55:16.430 --> 00:55:19.550
let's instantiate this
thing with some extra space

00:55:19.550 --> 00:55:21.870
on both sides.

00:55:21.870 --> 00:55:23.100
OK?

00:55:23.100 --> 00:55:27.060
So now, as I insert thing here,
insert thing here-- blah, blah,

00:55:27.060 --> 00:55:28.470
blah, blah, blah--

00:55:28.470 --> 00:55:32.430
I'll definitely know that, after
a linear number of insertions,

00:55:32.430 --> 00:55:34.170
when I rebuild this
thing, I'll have

00:55:34.170 --> 00:55:37.170
done enough operations to pay
for that expensive operation.

00:55:37.170 --> 00:55:38.860
Does that makes sense?

00:55:38.860 --> 00:55:43.890
So that's the idea behind
expanding this dynamic array

00:55:43.890 --> 00:55:48.520
to be kind of this dynamic deck.

00:55:48.520 --> 00:55:51.120
It's a doubly ended
queue kind of system

00:55:51.120 --> 00:55:55.670
where I can do dynamic
operations efficiently

00:55:55.670 --> 00:55:57.170
on both ends.

00:55:57.170 --> 00:56:01.890
So one of the things that
we talked about yesterday

00:56:01.890 --> 00:56:06.290
was also removing
right at the end.

00:56:06.290 --> 00:56:11.620
Removing items from
the back of this thing

00:56:11.620 --> 00:56:14.290
will decrease the number of
items we're storing, right?

00:56:14.290 --> 00:56:17.340
That makes sense.

00:56:17.340 --> 00:56:19.970
And maybe we're just
fine with that right.

00:56:23.210 --> 00:56:27.260
As a programmer, why
might you not like

00:56:27.260 --> 00:56:30.710
just removing items
until you got to nothing,

00:56:30.710 --> 00:56:32.940
and just leaving the
space where it is?

00:56:32.940 --> 00:56:33.440
Yeah?

00:56:33.440 --> 00:56:35.480
STUDENT: Might lock up a
lot of memory [INAUDIBLE]

00:56:35.480 --> 00:56:36.105
JASON KU: Yeah.

00:56:36.105 --> 00:56:38.670
So let's say, over the
course of my program,

00:56:38.670 --> 00:56:40.580
I use this data structure.

00:56:40.580 --> 00:56:43.310
I'm just trying to
fill it up with stuff,

00:56:43.310 --> 00:56:47.570
and then I remove all
but like two things,

00:56:47.570 --> 00:56:48.980
and then I go about my business.

00:56:48.980 --> 00:56:50.270
I run through the program.

00:56:50.270 --> 00:56:53.690
But I'm never really using
any but those two things

00:56:53.690 --> 00:56:56.330
for the rest of my program.

00:56:56.330 --> 00:56:57.350
But now I've got--

00:56:57.350 --> 00:57:00.500
I don't know-- maybe I did
put 1,000, or a million,

00:57:00.500 --> 00:57:03.335
or a billion things in that
thing, and then, when I--

00:57:03.335 --> 00:57:08.160
as I decreased, as I removed
things from that item,

00:57:08.160 --> 00:57:10.760
I still have all that
space there being taken up

00:57:10.760 --> 00:57:14.780
by essentially nothing, because
I've removed everything from

00:57:14.780 --> 00:57:15.620
it--

00:57:15.620 --> 00:57:18.230
at least in my conception.

00:57:18.230 --> 00:57:22.700
So what I would really like
to maintain with this data

00:57:22.700 --> 00:57:26.060
structure is that
at no point in time

00:57:26.060 --> 00:57:30.370
am I using more than a
linear amount of space

00:57:30.370 --> 00:57:34.530
with respect to the number of
things that are stored in it.

00:57:34.530 --> 00:57:37.100
Does that make sense?

00:57:37.100 --> 00:57:43.780
So in a dynamic
array, what we do

00:57:43.780 --> 00:57:51.260
is, when we get small enough,
let's resize this thing down

00:57:51.260 --> 00:57:52.610
so that we have--

00:57:52.610 --> 00:57:53.825
we're using less space.

00:57:57.080 --> 00:57:59.330
As I'm decreasing,
as I'm popping things

00:57:59.330 --> 00:58:03.030
from the end of this
thing, at what point

00:58:03.030 --> 00:58:06.870
do you think I should
rebuild my array?

00:58:06.870 --> 00:58:10.140
When I'm no longer
a linear amount?

00:58:10.140 --> 00:58:13.560
Well, that's a little hard to
tell what that is in real life,

00:58:13.560 --> 00:58:15.480
because our ends
aren't arbitrary.

00:58:15.480 --> 00:58:21.420
We need to actually have a time
at which we need to transition

00:58:21.420 --> 00:58:22.710
over and copy things over.

00:58:22.710 --> 00:58:25.030
So when might we
want to do that?

00:58:25.030 --> 00:58:26.267
STUDENT: [INAUDIBLE]

00:58:26.267 --> 00:58:27.100
JASON KU: Say again.

00:58:27.100 --> 00:58:29.440
STUDENT: After n/2 [INAUDIBLE]

00:58:29.440 --> 00:58:31.840
JASON KU: After n/2 removals--

00:58:31.840 --> 00:58:32.620
OK.

00:58:32.620 --> 00:58:35.890
So I remove n/2 things.

00:58:35.890 --> 00:58:40.570
OK, so now we're kind
of at a n/4 fill--

00:58:40.570 --> 00:58:44.140
so we're using a
fourth of the space.

00:58:44.140 --> 00:58:45.250
And now-- great.

00:58:45.250 --> 00:58:46.390
So you're saying rebuild.

00:58:46.390 --> 00:58:51.490
OK, so I'll stick everything
in something that's now--

00:58:51.490 --> 00:58:52.870
this is m.

00:58:52.870 --> 00:58:54.910
I'm going to call
this m, and now we're

00:58:54.910 --> 00:58:59.200
sticking it into something
that has size m/4.

00:58:59.200 --> 00:59:01.020
Sound good?

00:59:01.020 --> 00:59:01.520
Yeah?

00:59:04.270 --> 00:59:04.853
Yeah?

00:59:04.853 --> 00:59:05.770
Everyone OK with this?

00:59:05.770 --> 00:59:09.200
STUDENT: [INAUDIBLE]
m/4 [INAUDIBLE]

00:59:09.200 --> 00:59:10.660
JASON KU: Oh, OK.

00:59:10.660 --> 00:59:14.050
So what you're saying
is that we actually

00:59:14.050 --> 00:59:17.470
want to keep some
extra space back here.

00:59:17.470 --> 00:59:18.280
And why is that?

00:59:21.630 --> 00:59:25.470
Because imagine if we just
allocated this amount of space,

00:59:25.470 --> 00:59:30.720
and I removed the m/4
plus 1th item here,

00:59:30.720 --> 00:59:34.040
we resized down to
this thing, and then I

00:59:34.040 --> 00:59:35.290
want to do an insertion again.

00:59:37.820 --> 00:59:41.300
Well, then I have to re expand
out to something like this,

00:59:41.300 --> 00:59:44.495
and that's maybe not
going to be a good thing.

00:59:44.495 --> 00:59:46.370
We might have to bounce
back and forth a lot.

00:59:46.370 --> 00:59:50.000
That's hard for me to think
about what we're going to do.

00:59:50.000 --> 00:59:55.340
But if we always resize
to a fill ratio that

00:59:55.340 --> 00:59:58.550
includes a linear amount
of things on the end,

00:59:58.550 --> 01:00:02.810
then I know that,
when I resize down,

01:00:02.810 --> 01:00:05.780
I'll be doing either a
linear number of deletions

01:00:05.780 --> 01:00:09.890
or a linear number of insertions
before I have to rebuild again.

01:00:09.890 --> 01:00:11.807
So this charging
argument again--

01:00:11.807 --> 01:00:13.640
I have to do a linear
number of cheap things

01:00:13.640 --> 01:00:15.930
before I have to do an
expensive thing again.

01:00:15.930 --> 01:00:16.790
OK?

01:00:16.790 --> 01:00:20.300
So I resize down to be--

01:00:20.300 --> 01:00:23.660
still keep a linear amount
of extra space at the end.

01:00:23.660 --> 01:00:26.960
And with the double
ended thing, you

01:00:26.960 --> 01:00:29.900
can write the same
kind of policy.

01:00:29.900 --> 01:00:32.930
With the extra space, as
your colleague was saying,

01:00:32.930 --> 01:00:39.920
we can just resize down always
to shift these things to be

01:00:39.920 --> 01:00:44.865
placed in the middle with a
linear amount of extra space

01:00:44.865 --> 01:00:45.365
on the ends.

01:00:48.390 --> 01:00:51.390
Does that make sense?

01:00:51.390 --> 01:00:53.180
No questions?

01:00:53.180 --> 01:00:54.600
All right.

01:00:54.600 --> 01:00:58.650
That was a way in which
we had to redefine

01:00:58.650 --> 01:01:01.380
an entirely new data structure.

01:01:01.380 --> 01:01:04.770
We took the ideas
behind dynamic arrays

01:01:04.770 --> 01:01:08.340
and we extended those ideas
to make this thing have

01:01:08.340 --> 01:01:09.660
extra space on both ends.

01:01:09.660 --> 01:01:12.480
But we kind of had to do
that re-implementation

01:01:12.480 --> 01:01:13.530
all by ourselves.

01:01:13.530 --> 01:01:17.700
If we were doing code, that
would be kind of gnarly.

01:01:17.700 --> 01:01:21.480
But what if someone just
gave us a dynamic array?

01:01:21.480 --> 01:01:23.640
What if someone gave
you a Python list,

01:01:23.640 --> 01:01:27.810
and you wanted
this functionality?

01:01:27.810 --> 01:01:29.700
I don't want to reimplement
a dynamic array,

01:01:29.700 --> 01:01:31.590
but I want this
behavior, so how--

01:01:31.590 --> 01:01:34.080
any way that I could
do that by reducing

01:01:34.080 --> 01:01:37.860
to using a dynamic array--

01:01:37.860 --> 01:01:39.110
get this kind of running time?

01:01:42.890 --> 01:01:43.520
No?

01:01:43.520 --> 01:01:46.630
No one thinks that
we can do this.

01:01:46.630 --> 01:01:48.760
This is impossible.

01:01:48.760 --> 01:01:49.260
No?

01:01:49.260 --> 01:01:49.950
No ideas?

01:01:53.500 --> 01:01:57.640
No ideas-- let's say I had--

01:01:57.640 --> 01:02:05.690
I have a dynamic array
that's good on one side.

01:02:08.400 --> 01:02:11.393
Is there anything I can do
to support dynamic operations

01:02:11.393 --> 01:02:12.560
on both sides of a sequence?

01:02:15.070 --> 01:02:15.570
Yeah?

01:02:15.570 --> 01:02:24.450
STUDENT: Are we able
to just use [INAUDIBLE]

01:02:24.450 --> 01:02:27.000
JASON KU: Oh, that's
supposed to be empty, right?

01:02:30.590 --> 01:02:31.090
Yeah.

01:02:31.090 --> 01:02:34.170
So what your colleague is
saying-- yeah, let's do that.

01:02:34.170 --> 01:02:35.740
Let's have one
pointing forwards,

01:02:35.740 --> 01:02:37.090
one pointing backwards.

01:02:37.090 --> 01:02:39.550
This is the first
of a certain thing.

01:02:39.550 --> 01:02:42.970
When we were doing just
a dynamic array here,

01:02:42.970 --> 01:02:44.920
where we had to
rebuild everything,

01:02:44.920 --> 01:02:46.720
it was important
that we kept track

01:02:46.720 --> 01:02:52.630
of where the front thing was so
that we could do time indexing.

01:02:52.630 --> 01:02:55.540
As this thing
changed, we would now

01:02:55.540 --> 01:02:58.450
have to compute where our
index was in this thing

01:02:58.450 --> 01:03:02.280
by adding it to
where the front was.

01:03:02.280 --> 01:03:05.760
On this one, we've got
some similar problems.

01:03:05.760 --> 01:03:07.260
So what I'm going
to do is I'm going

01:03:07.260 --> 01:03:09.690
to divide the
sequence I'm trying

01:03:09.690 --> 01:03:17.050
to store up into two sections,
maybe about the same size.

01:03:17.050 --> 01:03:19.922
So each of these contains
a linear number of items.

01:03:19.922 --> 01:03:21.380
That's how I'm
going to instantiate

01:03:21.380 --> 01:03:24.710
my thing with a linear amount
of extra space on both ends.

01:03:24.710 --> 01:03:28.160
So now, as I insert
on either side

01:03:28.160 --> 01:03:30.980
or delete from either side,
it's going to work just

01:03:30.980 --> 01:03:32.720
like a dynamic array.

01:03:32.720 --> 01:03:36.290
I have to do some arithmetic
here to figure out where--

01:03:36.290 --> 01:03:38.720
if I was trying to
access these items,

01:03:38.720 --> 01:03:42.530
I'd have to subtract from
wherever this thing--

01:03:42.530 --> 01:03:46.250
I have to do some index
arithmetic, but that's tedious,

01:03:46.250 --> 01:03:49.400
but you could do it.

01:03:49.400 --> 01:03:50.450
OK.

01:03:50.450 --> 01:03:53.480
There's one caveat,
one problem that you

01:03:53.480 --> 01:03:56.400
run into in using
something like this.

01:03:56.400 --> 01:03:58.540
And what would that be?

01:03:58.540 --> 01:03:59.110
Yeah?

01:03:59.110 --> 01:04:01.400
STUDENT: I'm not
sure, but you store

01:04:01.400 --> 01:04:06.430
things in the second
half of a dynamic array.

01:04:06.430 --> 01:04:07.180
JASON KU: In here?

01:04:07.180 --> 01:04:08.560
STUDENT: In the first one.

01:04:08.560 --> 01:04:09.310
JASON KU: In here?

01:04:09.310 --> 01:04:10.343
STUDENT: [INAUDIBLE]

01:04:10.343 --> 01:04:11.010
JASON KU: Right.

01:04:11.010 --> 01:04:12.670
So what I'm doing
here is actually,

01:04:12.670 --> 01:04:17.290
I'm thinking of this
as two dynamic arrays,

01:04:17.290 --> 01:04:20.980
but I'm viewing
this one in reverse.

01:04:20.980 --> 01:04:26.530
So this is actually the
last of this dynamic array.

01:04:26.530 --> 01:04:27.740
Does that make sense?

01:04:27.740 --> 01:04:28.480
All right.

01:04:28.480 --> 01:04:33.370
So if that's the
situation I'm in, is--

01:04:33.370 --> 01:04:34.440
am I done?

01:04:34.440 --> 01:04:38.060
Do I have to care
about anything else?

01:04:38.060 --> 01:04:39.920
You guys are all
like, we're done,

01:04:39.920 --> 01:04:43.178
and I would not give
you full points.

01:04:43.178 --> 01:04:43.970
Why aren't we done?

01:04:48.230 --> 01:04:48.730
Yeah?

01:04:48.730 --> 01:04:59.953
STUDENT: [INAUDIBLE]

01:04:59.953 --> 01:05:02.120
JASON KU: OK, so what your
colleague is saying is we

01:05:02.120 --> 01:05:04.440
somehow got to merge
these into one array.

01:05:04.440 --> 01:05:08.000
So we're getting around that
by keeping indexes to here

01:05:08.000 --> 01:05:11.630
and being able to do index
arithmetic to kind of simulate

01:05:11.630 --> 01:05:13.280
an array underneath.

01:05:13.280 --> 01:05:17.880
So we can compute where
these indices should be.

01:05:17.880 --> 01:05:22.005
Anyone have another problem
with an underspecified data

01:05:22.005 --> 01:05:22.630
structure here?

01:05:22.630 --> 01:05:23.130
Yeah?

01:05:23.130 --> 01:05:29.263
STUDENT: [INAUDIBLE] it
could be that [INAUDIBLE]

01:05:29.263 --> 01:05:29.930
JASON KU: I see.

01:05:29.930 --> 01:05:31.560
So what your
colleague is saying,

01:05:31.560 --> 01:05:33.300
which is exactly correct--

01:05:33.300 --> 01:05:35.390
if I were removing
things, removing things,

01:05:35.390 --> 01:05:39.230
removing things, I have
nothing else in here.

01:05:39.230 --> 01:05:40.993
If I try to pop
from this end again,

01:05:40.993 --> 01:05:43.410
I'm going to have to pop from
the beginning of this thing,

01:05:43.410 --> 01:05:45.350
which I don't really--

01:05:45.350 --> 01:05:47.998
that's going to break
something of what I'm doing.

01:05:47.998 --> 01:05:49.790
It's not maintaining
the invariants of what

01:05:49.790 --> 01:05:51.540
I want on my data structure.

01:05:51.540 --> 01:05:55.190
And so the only caveat here
is that, when I reduce down

01:05:55.190 --> 01:05:59.180
to one of these is
empty, what do I do?

01:05:59.180 --> 01:06:01.960
STUDENT: You have to cut the
other one in half [INAUDIBLE]

01:06:01.960 --> 01:06:05.553
JASON KU: You cut this thing in
half, move these elements over.

01:06:05.553 --> 01:06:07.720
But that's going to leave
these things in the middle

01:06:07.720 --> 01:06:09.990
here, right?

01:06:09.990 --> 01:06:12.270
The nice thing that
happens here is

01:06:12.270 --> 01:06:14.880
I've done a linear
number of options--

01:06:14.880 --> 01:06:16.965
operations.

01:06:16.965 --> 01:06:21.420
I now have an
amortized cost build-up

01:06:21.420 --> 01:06:25.860
that I can spend to now rebuild
the entire data structure.

01:06:25.860 --> 01:06:27.390
Does that make sense?

01:06:27.390 --> 01:06:30.630
I can now, once I get down
to this thing, take whatever

01:06:30.630 --> 01:06:33.000
the remaining things
are, split it in half,

01:06:33.000 --> 01:06:36.210
put it into two entirely new
arrays, copy them all over,

01:06:36.210 --> 01:06:39.190
and now I've restored my
invariant, where I'm, again,

01:06:39.190 --> 01:06:41.310
a linear amount
of operations away

01:06:41.310 --> 01:06:45.690
from having to do an
expensive operation again.

01:06:45.690 --> 01:06:48.400
Does that make sense?

01:06:48.400 --> 01:06:52.470
So while we were able to reduce
to using these dynamic arrays

01:06:52.470 --> 01:06:56.130
for a lot of the
cases, we actually

01:06:56.130 --> 01:07:01.140
had to do a little bit more
work to make this work out.

01:07:01.140 --> 01:07:03.090
That make sense?

01:07:03.090 --> 01:07:08.430
OK, cool-- so that's two ways
of approaching problem 3.

01:07:08.430 --> 01:07:11.340
In the last little
bit, we're going

01:07:11.340 --> 01:07:14.900
to talk about the last problem.

01:07:14.900 --> 01:07:16.450
All right, that makes sense.

01:07:16.450 --> 01:07:18.420
I'm going to erase this picture,
if that's all right with you

01:07:18.420 --> 01:07:18.920
guys.

01:07:21.570 --> 01:07:22.457
STUDENT: [INAUDIBLE]

01:07:22.457 --> 01:07:23.290
JASON KU: What's up?

01:07:23.290 --> 01:07:24.940
It's not all right?

01:07:24.940 --> 01:07:28.270
Well, too bad-- watch the video.

01:07:28.270 --> 01:07:31.240
OK, so problem 4--

01:07:31.240 --> 01:07:39.940
also a fairly accessible,
shall we say, coding question--

01:07:39.940 --> 01:07:41.770
what we're doing on
problem 4 is we've

01:07:41.770 --> 01:07:44.890
got this nice little story
at the beginning, which

01:07:44.890 --> 01:07:48.250
is about this woman
Jen and her friend

01:07:48.250 --> 01:07:51.370
Barry, who are trying to sell
ice cream to elementary school

01:07:51.370 --> 01:07:52.100
kids.

01:07:52.100 --> 01:07:54.010
They're basically lined
up at Jen's truck,

01:07:54.010 --> 01:07:56.650
and she's like, oh, there's
too many students here.

01:07:56.650 --> 01:07:58.075
So she calls up
her friend Barry.

01:07:58.075 --> 01:08:02.050
He has another ice cream truck,
parts at the end of the line,

01:08:02.050 --> 01:08:03.760
and the students--
what they want to do

01:08:03.760 --> 01:08:06.160
is, to make it more
fair, is they're

01:08:06.160 --> 01:08:08.530
going to take the
last half of the line,

01:08:08.530 --> 01:08:12.070
reverse it to make it more fair.

01:08:12.070 --> 01:08:12.670
I don't know.

01:08:12.670 --> 01:08:16.330
It's a stupid situation, but
the underlying thing is what

01:08:16.330 --> 01:08:20.529
we're doing is-- part
A here is we have--

01:08:20.529 --> 01:08:23.410
we're giving you a linked list--

01:08:23.410 --> 01:08:31.000
a singly linked list, and
what I want you to do--

01:08:31.000 --> 01:08:32.500
the singly linked list--

01:08:32.500 --> 01:08:37.810
all it has is a notion
of size, how long it is.

01:08:37.810 --> 01:08:42.819
It has a size and it
has a head this list--

01:08:42.819 --> 01:08:46.750
it has a size and it has a head.

01:08:46.750 --> 01:08:48.790
And this head is a
pointer to a node,

01:08:48.790 --> 01:08:52.890
and the node has just one--

01:08:52.890 --> 01:08:54.680
two things stored in it.

01:08:54.680 --> 01:08:59.580
It has who-- the name of
the child that's there,

01:08:59.580 --> 01:09:01.950
and the next pointer
to the next node.

01:09:01.950 --> 01:09:03.510
That's what a singly
linked list is.

01:09:03.510 --> 01:09:10.843
So node has an item
key and a next pointer.

01:09:10.843 --> 01:09:13.260
This next pointer points to
the next node in the sequence.

01:09:13.260 --> 01:09:14.990
OK?

01:09:14.990 --> 01:09:22.229
And the question is asking, if
we give you a linked list that

01:09:22.229 --> 01:09:28.330
has 2n nodes, I want you
to take the last n nodes,

01:09:28.330 --> 01:09:33.910
and reverse their order, and
do this to the data structure.

01:09:33.910 --> 01:09:38.020
You're not going to return
a new data structure.

01:09:38.020 --> 01:09:40.149
You're going to modify
the existing nodes.

01:09:40.149 --> 01:09:42.805
And actually, here is--
goes back to your question.

01:09:46.510 --> 01:09:50.229
What are we limited to in
how we approach this problem?

01:09:50.229 --> 01:09:53.200
What this problem serves as
your algorithm should not

01:09:53.200 --> 01:09:57.370
make any new linked list nodes
or instantiate any new non

01:09:57.370 --> 01:09:59.390
constant sized data structures.

01:09:59.390 --> 01:10:03.580
So it's not like I can write
through this whole thing,

01:10:03.580 --> 01:10:06.820
find out where the
n plus 1th node is,

01:10:06.820 --> 01:10:09.940
read out all of those
names, store them

01:10:09.940 --> 01:10:14.230
in an array somewhere, and
then rewrite them back out.

01:10:14.230 --> 01:10:17.410
I'm not allowed to store
more than a constant amount

01:10:17.410 --> 01:10:19.390
of stuff outside of
this linked list,

01:10:19.390 --> 01:10:21.430
and I'm not able to
make any new nodes.

01:10:21.430 --> 01:10:24.400
Essentially, I just have to
probably keep these items

01:10:24.400 --> 01:10:27.040
where they are and
move around the nodes.

01:10:27.040 --> 01:10:27.867
Yeah?

01:10:27.867 --> 01:10:29.695
STUDENT: Can you use
non-constant space

01:10:29.695 --> 01:10:32.440
without creating
a data structure?

01:10:32.440 --> 01:10:36.280
JASON KU: So if you're
using non-constant space,

01:10:36.280 --> 01:10:38.470
you're instantiating some
kind of data structure,

01:10:38.470 --> 01:10:41.380
whether it be in an array or--

01:10:41.380 --> 01:10:46.150
STUDENT: [INAUDIBLE]

01:10:46.150 --> 01:10:46.840
JASON KU: Sure.

01:10:46.840 --> 01:10:49.630
I'm wanting you not to do that.

01:10:49.630 --> 01:10:50.130
Yeah.

01:10:54.600 --> 01:10:58.250
Any other questions?

01:10:58.250 --> 01:11:03.590
So how are we going
to do this problem?

01:11:08.940 --> 01:11:10.740
Anybody?

01:11:10.740 --> 01:11:13.590
Anyone have approach for how
I might approach this problem?

01:11:13.590 --> 01:11:15.330
Yeah?

01:11:15.330 --> 01:11:18.000
STUDENT: In order to
get to the second half

01:11:18.000 --> 01:11:21.095
you don't have to do
all of that [INAUDIBLE]

01:11:21.095 --> 01:11:21.720
JASON KU: Sure.

01:11:21.720 --> 01:11:22.803
STUDENT: Could you start--

01:11:25.410 --> 01:11:27.120
probably start
counting backwards so

01:11:27.120 --> 01:11:29.310
that you can get them
in the back order,

01:11:29.310 --> 01:11:31.783
and then meet it in the
middle so [INAUDIBLE]

01:11:31.783 --> 01:11:32.700
JASON KU: Interesting.

01:11:32.700 --> 01:11:36.103
So there's a lot of things--

01:11:36.103 --> 01:11:37.020
let's break this down.

01:11:37.020 --> 01:11:38.580
So a lot of times,
when we're asking

01:11:38.580 --> 01:11:42.710
you to construct an
algorithm-- a lot of times,

01:11:42.710 --> 01:11:45.650
it makes sense to develop
an outline or a game

01:11:45.650 --> 01:11:48.980
plan of constituent
parts that you might want

01:11:48.980 --> 01:11:51.050
to approach this problem with.

01:11:51.050 --> 01:11:53.810
So the first thing that your
colleague over here was saying

01:11:53.810 --> 01:11:56.000
was, at some point, we
need to find out where

01:11:56.000 --> 01:11:58.306
the middle of this thing is.

01:11:58.306 --> 01:12:00.320
Does that makes sense?

01:12:00.320 --> 01:12:06.350
So maybe the first thing we want
to do to approach this problem

01:12:06.350 --> 01:12:12.890
is, one, find n-th node.

01:12:15.410 --> 01:12:18.180
That's the end of the
first set of children.

01:12:18.180 --> 01:12:18.680
OK?

01:12:22.400 --> 01:12:28.812
Then I have a second
thing that I want to do.

01:12:28.812 --> 01:12:30.270
What's the next
thing I have to do?

01:12:30.270 --> 01:12:33.870
I have to reverse the
pointers of everything

01:12:33.870 --> 01:12:36.030
after the n-th node, right?

01:12:36.030 --> 01:12:40.080
OK, so second thing--

01:12:40.080 --> 01:12:58.470
reverse, I guess, next pointers
of everything after the n-th

01:12:58.470 --> 01:13:00.810
node--

01:13:00.810 --> 01:13:03.345
the nodes n plus 1 to 2n.

01:13:03.345 --> 01:13:04.220
Does that make sense?

01:13:06.980 --> 01:13:10.850
And after I reversed all of
those things, what do I have?

01:13:10.850 --> 01:13:13.690
I have a first block.

01:13:13.690 --> 01:13:15.310
This points like that.

01:13:15.310 --> 01:13:20.380
And now we've got this
thing, and we've reversed

01:13:20.380 --> 01:13:24.880
all the pointers like this.

01:13:27.460 --> 01:13:30.160
That's after step 2.

01:13:30.160 --> 01:13:31.750
Is that what we want?

01:13:35.060 --> 01:13:35.560
Yeah?

01:13:35.560 --> 01:13:44.020
STUDENT: Step 3
would be [INAUDIBLE]

01:13:44.020 --> 01:13:47.170
JASON KU: So this is my new end.

01:13:47.170 --> 01:13:52.810
I'm going to call this
node a, and this node b,

01:13:52.810 --> 01:13:58.658
and this node C. So tell
me, in terms of a, b,

01:13:58.658 --> 01:13:59.950
and c, what I'm supposed to do.

01:13:59.950 --> 01:14:00.310
Yeah?

01:14:00.310 --> 01:14:01.893
STUDENT: Quick
question-- how would we

01:14:01.893 --> 01:14:04.410
reverse the next pointer?

01:14:04.410 --> 01:14:05.770
I get what you're saying, but--

01:14:05.770 --> 01:14:06.437
JASON KU: Right.

01:14:06.437 --> 01:14:08.170
STUDENT: --to actually
made that happen--

01:14:08.170 --> 01:14:08.795
JASON KU: Yeah.

01:14:08.795 --> 01:14:12.190
So to actually make that happen,
this thing has an next pointer.

01:14:12.190 --> 01:14:15.160
It's pointed to--
pointing to some node.

01:14:15.160 --> 01:14:17.710
I'm needing to relink it
to the thing before me,

01:14:17.710 --> 01:14:20.380
so I better remember
what was before me

01:14:20.380 --> 01:14:25.380
so I can set node b.next
equals the thing before me,

01:14:25.380 --> 01:14:26.630
instead of the thing after me.

01:14:26.630 --> 01:14:27.590
Does that make sense?

01:14:27.590 --> 01:14:28.600
So that would be relinking the--

01:14:28.600 --> 01:14:30.220
STUDENT: And then it
disconnects the linked list.

01:14:30.220 --> 01:14:31.887
JASON KU: It disconnects
the linked list

01:14:31.887 --> 01:14:32.993
possibly temporarily.

01:14:32.993 --> 01:14:33.660
STUDENT: Oh, OK.

01:14:33.660 --> 01:14:36.250
It's temporary, and therefore,
it still works out [INAUDIBLE]

01:14:36.250 --> 01:14:38.530
JASON KU: Well, we have
to relink everything

01:14:38.530 --> 01:14:40.050
to make sure it's temporary.

01:14:42.870 --> 01:14:45.510
It's very possible, when
you're dealing with linked data

01:14:45.510 --> 01:14:49.080
structures, to unlink something
and not have a reference back

01:14:49.080 --> 01:14:51.570
to it, and now this
thing is in memory

01:14:51.570 --> 01:14:55.110
that your garbage collector
hopefully will pick up.

01:14:55.110 --> 01:14:56.880
But if you're writing
in a language that's

01:14:56.880 --> 01:15:01.290
not garbage collected, then
that's called a memory leak.

01:15:01.290 --> 01:15:03.500
That's no good.

01:15:03.500 --> 01:15:05.930
OK, so how do I
relink these things?

01:15:11.380 --> 01:15:13.480
This is the picture
that I have right now.

01:15:13.480 --> 01:15:16.588
How do I make this into
a linked list, where

01:15:16.588 --> 01:15:17.755
it's here and then reversed?

01:15:20.610 --> 01:15:21.830
Yeah?

01:15:21.830 --> 01:15:25.795
STUDENT: You can link
a to c [INAUDIBLE]

01:15:25.795 --> 01:15:26.420
JASON KU: Yeah.

01:15:26.420 --> 01:15:29.270
So I replace this
pointer from a to b

01:15:29.270 --> 01:15:32.120
to make it point to
c instead, and then,

01:15:32.120 --> 01:15:33.800
whatever my pointer is to b--

01:15:33.800 --> 01:15:36.590
from b-- b is reversed--
it's pointing to a--

01:15:36.590 --> 01:15:39.480
let's set that equal to none.

01:15:39.480 --> 01:15:48.480
So basically, the last
step here is clean up ends.

01:15:48.480 --> 01:15:53.430
And in LaTeX
write-up, you'd want

01:15:53.430 --> 01:15:57.600
to specify, what are the
things that you're relinking?

01:15:57.600 --> 01:16:00.480
But this was a coding
question, and so we actually

01:16:00.480 --> 01:16:02.910
gave you code to work with.

01:16:02.910 --> 01:16:08.400
So I'm going to see whether
I can live code this for you

01:16:08.400 --> 01:16:09.180
in front of you.

01:16:13.740 --> 01:16:14.240
OK.

01:16:14.240 --> 01:16:21.050
So here was our code
submission site from last term.

01:16:21.050 --> 01:16:25.580
And what I have here is my
template from last term, Pset1.

01:16:25.580 --> 01:16:27.410
It opens this folder.

01:16:27.410 --> 01:16:30.020
It's got a bunch
of things in it,

01:16:30.020 --> 01:16:32.330
the LaTeX template
that you have,

01:16:32.330 --> 01:16:34.790
and then a bunch of
these Python files.

01:16:34.790 --> 01:16:37.050
So I'm going to--

01:16:37.050 --> 01:16:38.340
where is it?

01:16:38.340 --> 01:16:38.840
Here.

01:16:38.840 --> 01:16:41.630
OK, so these are the files
that are in my directory.

01:16:41.630 --> 01:16:45.650
I've given you a version of
this linked list sequence.

01:16:45.650 --> 01:16:48.290
And then we have two more
code questions-- a tests file

01:16:48.290 --> 01:16:50.570
and a reorder_students file.

01:16:50.570 --> 01:16:54.950
So reorder_students look
something like this.

01:16:54.950 --> 01:16:57.260
It has a template of
the code that we're

01:16:57.260 --> 01:16:59.630
going to want you to write,
with inputs and outputs.

01:16:59.630 --> 01:17:02.000
And you're putting
your code here.

01:17:02.000 --> 01:17:04.340
And this function doesn't
need to return anything.

01:17:04.340 --> 01:17:06.290
All right, and then
we also give you

01:17:06.290 --> 01:17:08.210
this linked list
implementation, which

01:17:08.210 --> 01:17:11.960
is what's in your
recitation handout.

01:17:11.960 --> 01:17:14.210
I'm actually going to
ignore most of this stuff--

01:17:14.210 --> 01:17:18.290
really just that this thing
contains an item in next

01:17:18.290 --> 01:17:19.640
in your node--

01:17:19.640 --> 01:17:21.950
I'm not actually going to
look at the items at all--

01:17:21.950 --> 01:17:25.470
and a head and size in my
linked list at the top level.

01:17:25.470 --> 01:17:26.300
OK?

01:17:26.300 --> 01:17:29.300
But this is just to tell
you what's in there.

01:17:29.300 --> 01:17:32.030
So that's what's going
to be input to my thing,

01:17:32.030 --> 01:17:36.470
and if I go here
and I run the tests

01:17:36.470 --> 01:17:38.775
document that you
gave me, it fails

01:17:38.775 --> 01:17:40.025
because I don't have anything.

01:17:40.025 --> 01:17:41.990
It didn't do
anything to the list.

01:17:41.990 --> 01:17:43.300
OK?

01:17:43.300 --> 01:17:44.690
All right.

01:17:44.690 --> 01:17:52.404
And in fact, if I go into
here to the tests and I--

01:17:52.404 --> 01:17:53.110
what is it?

01:17:53.110 --> 01:17:54.580
It's reordering
the students here.

01:17:54.580 --> 01:17:58.600
I print the linked
list that you gave me.

01:17:58.600 --> 01:18:02.930
I'm going to have
a line break here.

01:18:02.930 --> 01:18:09.280
What we can see is,
when I do this--

01:18:09.280 --> 01:18:10.780
here are my test cases.

01:18:10.780 --> 01:18:12.830
Here's a linked list.

01:18:12.830 --> 01:18:14.580
And what's happening
is it's just spitting

01:18:14.580 --> 01:18:15.780
out the same linked lists.

01:18:15.780 --> 01:18:18.630
I haven't done anything to it.

01:18:18.630 --> 01:18:21.090
All right, so we need
to do something to it.

01:18:21.090 --> 01:18:22.740
How are we going to do that?

01:18:22.740 --> 01:18:25.200
All right, so let's
implement this function.

01:18:25.200 --> 01:18:28.193
And I'm going to get rid
of this stuff, because--

01:18:28.193 --> 01:18:28.860
get rid of that.

01:18:28.860 --> 01:18:31.113
All right, so we need
to reorder the students.

01:18:31.113 --> 01:18:33.030
So I'm going to break
this up into three parts

01:18:33.030 --> 01:18:33.780
that we have here.

01:18:33.780 --> 01:18:36.510
We're going to
find the n-th node.

01:18:36.510 --> 01:18:40.230
So how do we find the n-th node?

01:18:40.230 --> 01:18:42.840
This thing has a size
on it, so let's at least

01:18:42.840 --> 01:18:44.210
figure out what n is.

01:18:44.210 --> 01:18:47.880
So let's set n equal to--

01:18:47.880 --> 01:18:50.557
I think I can use
length, because I've

01:18:50.557 --> 01:18:52.140
implemented that on
my thing, and it's

01:18:52.140 --> 01:18:53.890
going to be whatever
the length is over 2.

01:18:53.890 --> 01:18:55.590
And I'm defined by
the problem statement

01:18:55.590 --> 01:18:58.530
that I'm only going
to have even inputs.

01:18:58.530 --> 01:19:08.205
And I'm going to set, at first,
my a to be the starting place.

01:19:08.205 --> 01:19:10.580
I'm going to just have a little
temporary variable that's

01:19:10.580 --> 01:19:14.480
going to say this is going to
be equal to the head of my list.

01:19:14.480 --> 01:19:17.300
And what I'm going to do is
what your colleague was saying--

01:19:17.300 --> 01:19:20.540
is I'm just going to
loop through n times

01:19:20.540 --> 01:19:23.060
until I reach the n-th thing.

01:19:23.060 --> 01:19:24.560
Actually, how many
times do I have

01:19:24.560 --> 01:19:29.170
to travel through next
pointers to get to node a?

01:19:29.170 --> 01:19:31.050
n minus 1, actually-- yep.

01:19:31.050 --> 01:19:32.760
So this is going to be for.

01:19:32.760 --> 01:19:35.680
I don't care about
this loop variable,

01:19:35.680 --> 01:19:40.483
so I'm going to just use
that n minus 1 times.

01:19:40.483 --> 01:19:41.400
What am I going to do?

01:19:41.400 --> 01:19:44.960
I want to replace a with
the thing it's pointed to,

01:19:44.960 --> 01:19:47.790
so I'm going to just walk down
this thing. a equals a.next.

01:19:51.060 --> 01:19:56.430
And now, after the end
of this loop, what is a?

01:19:56.430 --> 01:19:58.930
a is the n-th node.

01:19:58.930 --> 01:20:03.190
I've now made it the
n-th node-- fantastic.

01:20:03.190 --> 01:20:06.700
And now I'm going to say that
b is going to be the next one.

01:20:06.700 --> 01:20:09.790
Just in terms of my write-up,
I labeled these things

01:20:09.790 --> 01:20:13.150
as a, and b, and c,
and so in my mind,

01:20:13.150 --> 01:20:15.880
I'm going to want to use
the same kind of notation

01:20:15.880 --> 01:20:17.900
here so that I can
understand my code.

01:20:17.900 --> 01:20:20.690
OK, so b is going to
be the next thing.

01:20:23.420 --> 01:20:26.340
And now, in this process, as
I'm going to flip things around,

01:20:26.340 --> 01:20:27.715
what I'm going to
do is I'm going

01:20:27.715 --> 01:20:29.420
to keep track of three nodes.

01:20:29.420 --> 01:20:33.500
I'm going to keep track of
x, which is the node that I'm

01:20:33.500 --> 01:20:35.182
going to be relinking.

01:20:35.182 --> 01:20:36.890
And what else do I
need to keep track of?

01:20:40.310 --> 01:20:40.975
If I'm--

01:20:40.975 --> 01:20:42.350
STUDENT: [INAUDIBLE]
destination.

01:20:42.350 --> 01:20:43.820
JASON KU: Yeah,
where I came from

01:20:43.820 --> 01:20:46.520
and where I'm going
to, because that's what

01:20:46.520 --> 01:20:47.900
I'm going to need to relink.

01:20:47.900 --> 01:20:51.000
In particular, I'm going to
have someone pointing to me,

01:20:51.000 --> 01:20:55.050
which I'm going to
call next previous--

01:20:55.050 --> 01:20:58.250
or the x previous.

01:20:58.250 --> 01:21:01.470
When I'm going to label it,
it's going to be the next thing.

01:21:01.470 --> 01:21:01.970
All right?

01:21:01.970 --> 01:21:03.380
Does that make sense?

01:21:03.380 --> 01:21:08.850
So in my first situation, I'm--

01:21:08.850 --> 01:21:10.340
the first thing I
need to relink is

01:21:10.340 --> 01:21:13.160
b, so that's going to be my x.

01:21:13.160 --> 01:21:15.500
And x previous is going to be a.

01:21:15.500 --> 01:21:16.560
Does that makes sense?

01:21:16.560 --> 01:21:19.470
So I'm going to instantiate
those two variables.

01:21:19.470 --> 01:21:24.950
x and x_p are going
to be b and a.

01:21:24.950 --> 01:21:25.490
Sorry.

01:21:25.490 --> 01:21:26.630
That's right.

01:21:26.630 --> 01:21:27.320
Yeah.

01:21:27.320 --> 01:21:32.900
Maybe it makes more sense to
have x previous and x equal ab.

01:21:32.900 --> 01:21:36.380
All right, that's
in the right order.

01:21:36.380 --> 01:21:38.040
Either way is fine.

01:21:38.040 --> 01:21:40.160
And then I want to
go through a loop.

01:21:40.160 --> 01:21:41.630
I'm going to be
doing a loop way.

01:21:41.630 --> 01:21:44.540
You can do it a recursive
way, if you want.

01:21:44.540 --> 01:21:46.820
Here's a loop way, in
which I'm just going

01:21:46.820 --> 01:21:48.470
to loop through how many times?

01:21:48.470 --> 01:21:54.520
How many pointers am I going to
relink as I go down this thing?

01:21:54.520 --> 01:21:57.430
I need to relink the pointers
of all of these guys.

01:21:57.430 --> 01:21:58.590
How many are there?

01:21:58.590 --> 01:21:59.590
STUDENT: [INAUDIBLE]

01:21:59.590 --> 01:22:00.382
JASON KU: How many?

01:22:00.382 --> 01:22:01.400
STUDENT: [INAUDIBLE]

01:22:01.400 --> 01:22:03.040
JASON KU: n-- there
are n of them.

01:22:03.040 --> 01:22:08.160
So for-- I don't care about
the loop variable here either.

01:22:08.160 --> 01:22:10.080
I'm going to do this n times.

01:22:10.080 --> 01:22:11.440
And what am I going to do?

01:22:11.440 --> 01:22:16.320
I'm going to first figure
out who my next guy is.

01:22:16.320 --> 01:22:21.610
I'm going to set x_n
equals what? x.next--

01:22:21.610 --> 01:22:25.450
all right, so now I know
who's next to me right,

01:22:25.450 --> 01:22:29.080
so I can go there later
after I relink my pointer.

01:22:29.080 --> 01:22:31.510
I'm remembering that.

01:22:31.510 --> 01:22:37.990
Now, I don't care about what's
stored in x.next, because I've

01:22:37.990 --> 01:22:39.610
stored it locally.

01:22:39.610 --> 01:22:40.900
That makes sense.

01:22:40.900 --> 01:22:45.100
All right, so now I am free
to relink that next pointer

01:22:45.100 --> 01:22:46.450
to my previous guy.

01:22:50.510 --> 01:22:56.790
And now I can essentially
shift my perspective over,

01:22:56.790 --> 01:23:01.560
so the thing that I'm going
to relink now is the next one.

01:23:01.560 --> 01:23:09.660
So x previous and x
now equals x, x_next.

01:23:09.660 --> 01:23:11.930
Does that make sense?

01:23:11.930 --> 01:23:15.130
Just relinked things over--

01:23:15.130 --> 01:23:16.840
so that's the end of step 2.

01:23:16.840 --> 01:23:21.160
Now, as I got down this at
the end of this for loop,

01:23:21.160 --> 01:23:22.030
where is x?

01:23:25.240 --> 01:23:29.260
What is x_p, x, and
x_next-- or x_n?

01:23:29.260 --> 01:23:33.170
Really, I'm only keeping
track of x and x_p here.

01:23:33.170 --> 01:23:36.100
So what are x_p and x
at the end of this loop?

01:23:39.630 --> 01:23:41.940
I've done this n times.

01:23:41.940 --> 01:23:44.925
I started with b at x.

01:23:49.698 --> 01:23:50.960
So what is x?

01:23:50.960 --> 01:23:53.840
Yeah?

01:23:53.840 --> 01:23:57.260
So we have a vote that x is c.

01:23:57.260 --> 01:23:59.411
STUDENT: [INAUDIBLE]

01:23:59.411 --> 01:24:01.730
JASON KU: So this is
a little interesting.

01:24:01.730 --> 01:24:03.050
All right.

01:24:03.050 --> 01:24:08.750
I will tell you that c
is either x_p, x, or x_n.

01:24:08.750 --> 01:24:10.310
So we have one vote for x.

01:24:10.310 --> 01:24:11.420
Who says something else?

01:24:16.840 --> 01:24:18.130
Eric doesn't like x.

01:24:21.790 --> 01:24:24.310
There are only
two other choices.

01:24:24.310 --> 01:24:27.400
Does someone say something?

01:24:27.400 --> 01:24:31.220
x_p-- I will argue
that it is x_p.

01:24:31.220 --> 01:24:31.720
Why?

01:24:31.720 --> 01:24:33.880
Because I'm at b.

01:24:33.880 --> 01:24:36.040
There are n things.

01:24:36.040 --> 01:24:41.590
I did n operations, and every
operation, I move 1 over.

01:24:41.590 --> 01:24:46.180
So when I've done n minus 1
things, I'm at c, the n-th one.

01:24:46.180 --> 01:24:48.310
Now x is none, because
there's null pointer

01:24:48.310 --> 01:24:49.670
at the end of the list.

01:24:49.670 --> 01:24:55.465
So x_p is c, so I'm going to
set p equal to x_p, which is--

01:24:55.465 --> 01:24:58.360
it's just for me to remember
what these things are.

01:24:58.360 --> 01:25:01.150
And I just relink
these two pointers.

01:25:01.150 --> 01:25:08.710
a.next should be c and
b.next should be none.

01:25:12.490 --> 01:25:13.990
Does that make sense, everybody?

01:25:13.990 --> 01:25:15.520
Let's see if we did it right.

01:25:15.520 --> 01:25:22.510
So we save that thing and we
run Python on the test cases,

01:25:22.510 --> 01:25:26.950
and it did the right
thing apparently-- maybe.

01:25:26.950 --> 01:25:29.290
Let's see-- ran
five test cases--

01:25:29.290 --> 01:25:30.880
OK.

01:25:30.880 --> 01:25:32.740
All right, so let's
take a look at this.

01:25:32.740 --> 01:25:35.170
We had this linked list--

01:25:35.170 --> 01:25:38.820
Lilly, Sally, Cindy,
Maisy, Sammy, Davey.

01:25:38.820 --> 01:25:43.648
And what it turns into is Lilly,
Sally, Cindy, which is correct.

01:25:43.648 --> 01:25:45.690
And then it reverses this
last part of the list--

01:25:45.690 --> 01:25:50.830
Danny, Sammy, Maisy--
cool, awesome.

01:25:50.830 --> 01:25:53.560
But these are the test
cases we gave you.

01:25:53.560 --> 01:25:56.430
So let's try this
against our code checker.

01:25:56.430 --> 01:25:58.630
So I select the file.

01:25:58.630 --> 01:25:59.410
Where do I go?

01:25:59.410 --> 01:26:04.390
I think I'm in my desktop here
in session 1, and template,

01:26:04.390 --> 01:26:06.130
and reorder students.

01:26:06.130 --> 01:26:07.600
I submit it.

01:26:07.600 --> 01:26:08.110
Please work.

01:26:08.110 --> 01:26:08.610
Please work.

01:26:08.610 --> 01:26:09.578
Please work.

01:26:15.390 --> 01:26:19.140
And 100%-- and now we're
happy, and we can go party.

01:26:19.140 --> 01:26:20.580
OK.

01:26:20.580 --> 01:26:23.250
All right, so that's
the first problem.

01:26:23.250 --> 01:26:25.380
Hopefully this was
helpful to you.

01:26:25.380 --> 01:26:31.580
We will release problem set 1
tomorrow, and good luck on it.