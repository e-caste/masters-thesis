WEBVTT

00:00:00.000 --> 00:00:02.400
The following content is
provided under a Creative

00:00:02.400 --> 00:00:03.830
Commons license.

00:00:03.830 --> 00:00:06.250
Your support will help
MIT OpenCourseware

00:00:06.250 --> 00:00:10.510
continue to offer high-quality
educational resources for free.

00:00:10.510 --> 00:00:13.230
To make a donation, or
view additional materials

00:00:13.230 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseware

00:00:16.600 --> 00:00:17.490
at ocw.mit.edu.

00:00:17.490 --> 00:00:22.080
PROFESSOR ERIC
GRIMSON: All right, I'm

00:00:22.080 --> 00:00:24.680
going to start today
by talking about,

00:00:24.680 --> 00:00:26.080
so what have we been doing?

00:00:26.080 --> 00:00:28.840
What have we actually done
over the last few lectures?

00:00:28.840 --> 00:00:30.590
And I want to suggest
that what we've done

00:00:30.590 --> 00:00:34.825
is, we've outlined a lot of the
basic elements of programming.

00:00:34.825 --> 00:00:36.200
A lot of the basic
elements we're

00:00:36.200 --> 00:00:37.890
going to need to write code.

00:00:37.890 --> 00:00:39.675
And I want to just highlight
it for you because we're going

00:00:39.675 --> 00:00:40.540
to come back and look at it.

00:00:40.540 --> 00:00:42.120
So I'm going to
suggest that we've

00:00:42.120 --> 00:00:45.530
looked at three different
kinds of things.

00:00:45.530 --> 00:00:51.480
We've talked about data,
we've talked about operations,

00:00:51.480 --> 00:00:59.310
and we've talked about
commands or statements.

00:00:59.310 --> 00:01:00.350
All right?

00:01:00.350 --> 00:01:01.860
Data's what we expect.

00:01:01.860 --> 00:01:04.570
It's our way of
representing fundamentally

00:01:04.570 --> 00:01:06.800
the kinds of information
we want to move around.

00:01:06.800 --> 00:01:11.010
And here, I'm going to
suggest we've seen numbers,

00:01:11.010 --> 00:01:14.740
we've seen strings,
and I'm going

00:01:14.740 --> 00:01:16.250
to add Booleans here as well.

00:01:16.250 --> 00:01:18.290
They're a third kind
of value that we

00:01:18.290 --> 00:01:21.840
saw when we started
talking about conditions.

00:01:21.840 --> 00:01:23.680
We saw, associated with
that primitive data,

00:01:23.680 --> 00:01:25.880
we have ways of taking
data in and creating

00:01:25.880 --> 00:01:28.400
new kinds of data out, or
new versions of data out,

00:01:28.400 --> 00:01:31.150
so we have operations.

00:01:31.150 --> 00:01:32.860
Things like addition
and multiplication,

00:01:32.860 --> 00:01:34.870
which we saw not only
apply to numbers,

00:01:34.870 --> 00:01:36.660
but we can use them
on things like strings

00:01:36.660 --> 00:01:38.630
and we're going to come
back to them again.

00:01:38.630 --> 00:01:41.296
Can't use them on Booleans, they
have a different set of things.

00:01:41.296 --> 00:01:45.162
They do things like AND, and OR.

00:01:45.162 --> 00:01:47.370
And of course there's a
bunch of other ones in there,

00:01:47.370 --> 00:01:48.320
I'm not going to
put them all up,

00:01:48.320 --> 00:01:50.611
but we're building up a little
collection, if you like,

00:01:50.611 --> 00:01:51.824
of those operations.

00:01:51.824 --> 00:01:53.240
And then the main
thing we've done

00:01:53.240 --> 00:01:54.750
is, we've talked about commands.

00:01:54.750 --> 00:01:57.640
So I'm going to suggest we've
seen now four different things.

00:01:57.640 --> 00:02:04.580
We've seen assignment, how
to bind a name to a value.

00:02:04.580 --> 00:02:10.660
We've seen input and output.

00:02:10.660 --> 00:02:15.090
Print for output, for example,
and raw input for input.

00:02:15.090 --> 00:02:23.430
We've seen conditionals, or
said another way, branches,

00:02:23.430 --> 00:02:26.170
ways of changing
the flow of control

00:02:26.170 --> 00:02:28.940
through that sequence of
instructions we're building up.

00:02:28.940 --> 00:02:31.540
And the last thing we
added were loop mechanisms.

00:02:31.540 --> 00:02:40.320
And here we saw, while.

00:02:40.320 --> 00:02:44.520
It's the first
example we've seen.

00:02:44.520 --> 00:02:46.520
So what've we done so far?

00:02:46.520 --> 00:02:50.257
Now, interestingly,
this set of instructions

00:02:50.257 --> 00:02:51.840
was actually quite
powerful, and we're

00:02:51.840 --> 00:02:53.715
going to come back to
that later on, in terms

00:02:53.715 --> 00:02:56.250
of what we can do with it,
but what we've really done

00:02:56.250 --> 00:02:58.510
is, given that basis,
we're now talking about,

00:02:58.510 --> 00:03:00.796
how do we write common
patterns of code,

00:03:00.796 --> 00:03:02.170
how do we write
things that solve

00:03:02.170 --> 00:03:03.795
particular kinds of problems.

00:03:03.795 --> 00:03:05.920
So what I want you to do,
is to keep in mind, those

00:03:05.920 --> 00:03:07.340
are the bases, we
ought to be able to do

00:03:07.340 --> 00:03:09.756
a lot with that bases, but
what we're really interested in

00:03:09.756 --> 00:03:12.320
is not filling out a whole
bunch of other things in here,

00:03:12.320 --> 00:03:14.570
but how do we put them
together into common templates.

00:03:14.570 --> 00:03:16.529
And we're going
to do that today.

00:03:16.529 --> 00:03:18.070
Second thing we've
been doing, I want

00:03:18.070 --> 00:03:21.169
to highlight for you is, we've
along the way, mostly just

00:03:21.169 --> 00:03:22.710
verbally rather than
writing it down,

00:03:22.710 --> 00:03:27.160
but we've been talking
about good style.

00:03:27.160 --> 00:03:28.431
Good programming style.

00:03:28.431 --> 00:03:28.930
All right?

00:03:28.930 --> 00:03:30.510
Things that we
ought to do, as you

00:03:30.510 --> 00:03:32.020
put these pieces
together, in order

00:03:32.020 --> 00:03:33.010
to give you really good code.

00:03:33.010 --> 00:03:34.892
And you should be
collecting those together.

00:03:34.892 --> 00:03:35.850
Give you some examples.

00:03:35.850 --> 00:03:36.933
What have we talked about?

00:03:36.933 --> 00:03:39.139
We've talked about things
like using comments

00:03:39.139 --> 00:03:40.930
to highlight what you're
doing in the code,

00:03:40.930 --> 00:03:42.890
to make it easier to debug.

00:03:42.890 --> 00:03:46.260
We talked about type
discipline, the notion

00:03:46.260 --> 00:03:49.669
that you should check
the types of operands

00:03:49.669 --> 00:03:52.210
before you apply operators to
them, to make sure that they're

00:03:52.210 --> 00:03:54.270
what the code is expecting.

00:03:54.270 --> 00:03:57.300
We talked about descriptive
use of good variable names,

00:03:57.300 --> 00:04:00.177
as a way, in essence, of
documenting your code.

00:04:00.177 --> 00:04:02.010
The fourth one we talked
about was this idea

00:04:02.010 --> 00:04:05.800
of testing all possible branches
through a piece of code,

00:04:05.800 --> 00:04:08.070
if it's got conditionals
in it, to make sure

00:04:08.070 --> 00:04:09.700
that every possible
input is going

00:04:09.700 --> 00:04:11.990
to give you an output that
you actually want to see.

00:04:11.990 --> 00:04:14.240
So, you know, you can start
writing your own, kind of,

00:04:14.240 --> 00:04:15.864
Miss Manners book,
if you like, I mean,

00:04:15.864 --> 00:04:17.350
are what are good
programming, you

00:04:17.350 --> 00:04:18.635
know-- I wonder what
you'd call them,

00:04:18.635 --> 00:04:20.100
John, good programming hygiene?

00:04:20.100 --> 00:04:21.300
Good programming style?

00:04:21.300 --> 00:04:23.520
Good programming
practices?-- Things that you

00:04:23.520 --> 00:04:26.190
want to do to write good code.

00:04:26.190 --> 00:04:26.807
OK.

00:04:26.807 --> 00:04:28.390
What we're going to
do today is, we're

00:04:28.390 --> 00:04:32.160
going to start now building
up, beyond just these pieces,

00:04:32.160 --> 00:04:35.840
although they're valuable, to
start creating two things: one,

00:04:35.840 --> 00:04:37.750
common patterns of
code that tackle

00:04:37.750 --> 00:04:40.680
certain classes of
problems, and secondly we're

00:04:40.680 --> 00:04:43.100
going to talk about tools you
can use to help understand

00:04:43.100 --> 00:04:45.040
those pieces of things.

00:04:45.040 --> 00:04:46.270
OK.

00:04:46.270 --> 00:04:49.340
So last time around, we talked
about, or introduced if you

00:04:49.340 --> 00:04:52.310
like, iterative programs.

00:04:52.310 --> 00:05:00.210
And I want to generalize
that for a second,

00:05:00.210 --> 00:05:08.090
because we're going to come
back and use this a lot.

00:05:08.090 --> 00:05:10.206
And I want to do a very
high-level description

00:05:10.206 --> 00:05:11.830
of what goes into an
iterative program,

00:05:11.830 --> 00:05:13.690
or how I would think
about this, all right?

00:05:13.690 --> 00:05:15.894
And I know if John disagrees
with me he'll tell me,

00:05:15.894 --> 00:05:17.560
but this is my way
of thinking about it.

00:05:17.560 --> 00:05:19.450
If I want to try and
decide how to tackle

00:05:19.450 --> 00:05:21.980
a problem in an iterative
matter, here the steps

00:05:21.980 --> 00:05:23.102
I'm going to go through.

00:05:23.102 --> 00:05:24.560
First thing I'm
going to do, is I'm

00:05:24.560 --> 00:05:35.825
going to choose a variable
that's going to count.

00:05:35.825 --> 00:05:37.950
What I meant-- what in the
world do I mean by that?

00:05:37.950 --> 00:05:39.150
I'm thinking about
a problem, I'm

00:05:39.150 --> 00:05:41.190
going to show you an example
in a second, first thing I'm

00:05:41.190 --> 00:05:43.023
going to do is say,
what is the thing that's

00:05:43.023 --> 00:05:46.190
going to change every time I run
through the same set of code?

00:05:46.190 --> 00:05:48.880
What is counting my way
through this process?

00:05:48.880 --> 00:05:51.400
Now I'm putting count
in double quotes,

00:05:51.400 --> 00:05:54.232
not to make it a string, but to
say, this is count generically.

00:05:54.232 --> 00:05:56.440
It could be counting one by
one through the integers,

00:05:56.440 --> 00:05:58.940
it could also be taking
a collection of data

00:05:58.940 --> 00:06:00.640
and going through
them one by one.

00:06:00.640 --> 00:06:02.765
It could be doing counting
in some other mechanism.

00:06:02.765 --> 00:06:05.080
But what's the
variable I want to use?

00:06:05.080 --> 00:06:11.210
Second thing I do, I
need to initialize it.

00:06:11.210 --> 00:06:16.510
And I need to initialize
it outside of the loop.

00:06:16.510 --> 00:06:18.260
That is, where do
I want to start?

00:06:18.260 --> 00:06:21.330
And I need to make sure I have
a command that sets that up.

00:06:21.330 --> 00:06:23.350
The third thing
I'm going to do, is

00:06:23.350 --> 00:06:28.280
I need to set up
the right end test.

00:06:28.280 --> 00:06:31.691
How do I know when I'm
done with the loop?

00:06:31.691 --> 00:06:33.190
And obviously, that
ought to involve

00:06:33.190 --> 00:06:34.731
the variable in some
way, or it's not

00:06:34.731 --> 00:06:37.910
going to make a lot of sense,
so this includes the variable,

00:06:37.910 --> 00:06:40.640
since that's the
thing that's changing.

00:06:40.640 --> 00:06:41.140
All right.

00:06:41.140 --> 00:06:43.140
The fourth thing
I'm going to do,

00:06:43.140 --> 00:06:51.177
is I'm going to then
construct the block of code.

00:06:51.177 --> 00:06:53.010
And I want to remind
you, that block of code

00:06:53.010 --> 00:06:55.980
is a set of instructions,
the same set of instructions

00:06:55.980 --> 00:06:58.200
that are going to be done
each time through the loop.

00:06:58.200 --> 00:07:00.408
All that's going to change,
is the value the variable

00:07:00.408 --> 00:07:02.280
or the value of some
data structures.

00:07:02.280 --> 00:07:05.570
And remind you that
inside of here,

00:07:05.570 --> 00:07:10.677
I'd better be
changing the variable.

00:07:10.677 --> 00:07:12.760
All right, if that variable
that's counting is not

00:07:12.760 --> 00:07:14.926
changing, I'm going to be
stuck in an infinite loop,

00:07:14.926 --> 00:07:16.860
so I ought to
[UNINTELLIGIBLE PHRASE] that ,

00:07:16.860 --> 00:07:18.720
right, expect
somewhere in there,

00:07:18.720 --> 00:07:20.570
a change of that variable.

00:07:20.570 --> 00:07:21.070
All right?

00:07:21.070 --> 00:07:22.611
And then the last
thing I want to do,

00:07:22.611 --> 00:07:32.611
is just decide, you know,
what do I do when I'm done.

00:07:32.611 --> 00:07:33.110
OK.

00:07:33.110 --> 00:07:33.680
I know.

00:07:33.680 --> 00:07:35.310
It looks boring.

00:07:35.310 --> 00:07:36.790
But it's a structure
of the things

00:07:36.790 --> 00:07:38.710
I want to think about
when I go through trying

00:07:38.710 --> 00:07:41.420
to take a problem and mapping
it into a iterative program.

00:07:41.420 --> 00:07:43.461
Those are the things I
want to see if I go along.

00:07:43.461 --> 00:07:44.380
All right.

00:07:44.380 --> 00:07:47.880
So let me give you an example.

00:07:47.880 --> 00:07:50.739
I'm given an integer
that's a perfect square,

00:07:50.739 --> 00:07:53.030
and I want to write a little
piece of code that's going

00:07:53.030 --> 00:07:54.730
to find the square root of it.

00:07:54.730 --> 00:07:55.560
All right, so I'm
cheating a little,

00:07:55.560 --> 00:07:56.890
I know it's a perfect
square, somebody's

00:07:56.890 --> 00:07:59.514
given it to me, we'll come back
in a second to generalizing it,

00:07:59.514 --> 00:08:02.480
so what would the steps be that
I'd use to walk through it?

00:08:02.480 --> 00:08:04.650
Well if you think
about these steps,

00:08:04.650 --> 00:08:06.540
here's an easy way to do it.

00:08:06.540 --> 00:08:07.530
Let's start at 1.

00:08:07.530 --> 00:08:08.570
Let's call x the
thing I'm trying

00:08:08.570 --> 00:08:09.694
to find the square root of.

00:08:09.694 --> 00:08:10.780
Let's start at 1.

00:08:10.780 --> 00:08:12.740
Square it.

00:08:12.740 --> 00:08:16.620
If it's not greater
than x, take 2.

00:08:16.620 --> 00:08:17.682
Square it.

00:08:17.682 --> 00:08:19.140
If it's not greater
than x, take 3.

00:08:19.140 --> 00:08:19.640
Square it.

00:08:19.640 --> 00:08:22.580
And keep going, until the
square of one of those integers

00:08:22.580 --> 00:08:27.390
is greater than or equal to--
sorry, just greater than x.

00:08:27.390 --> 00:08:28.590
OK, why am I doing that?

00:08:28.590 --> 00:08:31.210
When I get greater than x,
I've gone past the place

00:08:31.210 --> 00:08:32.527
where I want to be.

00:08:32.527 --> 00:08:34.110
And obviously, when
I get to something

00:08:34.110 --> 00:08:36.900
whose square is equal to x,
I've got the answer I want,

00:08:36.900 --> 00:08:37.944
and I kick it out.

00:08:37.944 --> 00:08:39.110
So who knows what I've done?

00:08:39.110 --> 00:08:41.276
I've identified the thing
I'm going to use to count,

00:08:41.276 --> 00:08:43.870
something some variable is going
to just count the integers,

00:08:43.870 --> 00:08:45.570
I've identified
the end test, which

00:08:45.570 --> 00:08:48.370
is when that square is bigger
than the thing I'm looking

00:08:48.370 --> 00:08:51.260
for, I've identified
basically what I want

00:08:51.260 --> 00:08:53.930
to do inside the
loop, which is simply

00:08:53.930 --> 00:08:55.669
keep changing that
variable, and I

00:08:55.669 --> 00:08:57.460
didn't say what I want
to do when I'm done,

00:08:57.460 --> 00:09:00.220
essentially print
out the answer.

00:09:00.220 --> 00:09:01.580
OK, so how can I code this up?

00:09:01.580 --> 00:09:02.900
Well, you might think,
let's just jump in

00:09:02.900 --> 00:09:04.600
and write some code, I don't
want to quite do that though,

00:09:04.600 --> 00:09:06.516
because I want to show
you another tool that's

00:09:06.516 --> 00:09:10.100
valuable for thinking about
how to structure the code,

00:09:10.100 --> 00:09:15.680
and that is a something
called a flow chart.

00:09:15.680 --> 00:09:17.790
Now.

00:09:17.790 --> 00:09:19.640
People of Professor
Guttag's and my age,

00:09:19.640 --> 00:09:22.060
unfortunately remember flow
charts back-- as they say,

00:09:22.060 --> 00:09:24.962
on the Simpsons, back in the
day, back in the 1960's, John,

00:09:24.962 --> 00:09:27.420
right?-- really good programmers
had these wonderful little

00:09:27.420 --> 00:09:29.120
plastic stencils, I
tried to find one,

00:09:29.120 --> 00:09:31.680
I couldn't find it It's a little
stencil with little cut-out

00:09:31.680 --> 00:09:33.680
shapes on it, that you
used to draw flow charts,

00:09:33.680 --> 00:09:34.780
I'm going to show
you in a second,

00:09:34.780 --> 00:09:37.010
and you tucked it right in here
next to your pocket protector

00:09:37.010 --> 00:09:38.468
with all your pens
in it, you know,

00:09:38.468 --> 00:09:40.130
so, your belt was
also about this high,

00:09:40.130 --> 00:09:41.921
and your glasses were
this thick, you know,

00:09:41.921 --> 00:09:43.804
we have a few of
those nerds left,

00:09:43.804 --> 00:09:45.220
we mostly keep
them in the museum,

00:09:45.220 --> 00:09:48.120
but that was what you
did with the flow chart.

00:09:48.120 --> 00:09:49.720
Despite making a
bad joke about it,

00:09:49.720 --> 00:09:50.780
we're going to do
the same thing here.

00:09:50.780 --> 00:09:50.965
We're going to do
the same thing here,

00:09:50.965 --> 00:09:53.330
we're going to chart
out a little bit of what

00:09:53.330 --> 00:09:56.780
should go into actually
making this thing work.

00:09:56.780 --> 00:09:58.456
So here's a simple
flow chart that I'm

00:09:58.456 --> 00:10:01.059
going to use to capture
what I just described.

00:10:01.059 --> 00:10:02.600
And I'm going to,
again, I'm actually

00:10:02.600 --> 00:10:06.090
going to do it the way they
used to do it, and draw

00:10:06.090 --> 00:10:09.730
a rectangle with
rounded corners, that's

00:10:09.730 --> 00:10:12.540
my starting point, and
then what did I say to do?

00:10:12.540 --> 00:10:14.350
I said I need to
identify a variable,

00:10:14.350 --> 00:10:16.391
I'm going to give it a
name, let's just call ANS,

00:10:16.391 --> 00:10:19.250
for answer, and I
need to initialize it,

00:10:19.250 --> 00:10:22.170
so I'm going to come
down, and in a square box,

00:10:22.170 --> 00:10:29.815
I'm going to
initialize ANS to 0.

00:10:29.815 --> 00:10:31.440
And now I want to
run through the loop.

00:10:31.440 --> 00:10:33.023
What's the first
thing I do in a loop?

00:10:33.023 --> 00:10:34.110
I test an end test.

00:10:34.110 --> 00:10:36.830
So the flow chart says,
and the tradition was

00:10:36.830 --> 00:10:40.190
to do this in a
diamond shape, I'm

00:10:40.190 --> 00:10:44.770
going to check if
ANS times ANS-- oh,

00:10:44.770 --> 00:10:47.390
which way did I want to
do this-- is less than

00:10:47.390 --> 00:10:51.840
or equal to x.

00:10:51.840 --> 00:10:52.780
Now that's a test.

00:10:52.780 --> 00:10:54.570
There are two possibilities.

00:10:54.570 --> 00:11:00.535
If the answer is yes, then I'm
still looking for the answer,

00:11:00.535 --> 00:11:01.410
what do I want to do?

00:11:01.410 --> 00:11:03.034
Well, I don't have
to do anything other

00:11:03.034 --> 00:11:04.270
than change the counter.

00:11:04.270 --> 00:11:09.770
So I'm going to go
to ANS is ANS plus 1,

00:11:09.770 --> 00:11:17.240
and I'm going to do it again.

00:11:17.240 --> 00:11:22.559
Eventually, if I've done
this right, that test is no--

00:11:22.559 --> 00:11:24.850
and I wonderfully ran out of
room here-- in which case,

00:11:24.850 --> 00:11:27.100
I'm going to go to a print
statement, which was always

00:11:27.100 --> 00:11:32.930
done in a trapezoid,
and print out ANS.

00:11:32.930 --> 00:11:36.550
I should have put a box
below it that says stop.

00:11:36.550 --> 00:11:38.420
OK?

00:11:38.420 --> 00:11:39.735
While.

00:11:39.735 --> 00:11:40.860
And notice what I got here.

00:11:40.860 --> 00:11:43.010
Actually, this is a useful
tool for visualizing

00:11:43.010 --> 00:11:44.590
how I'm trying to
put it together,

00:11:44.590 --> 00:11:47.640
because it lets me
see where the loop is,

00:11:47.640 --> 00:11:50.530
right there, it lets
me see the end test,

00:11:50.530 --> 00:11:53.200
it lets me make sure that I'm in
fact initializing the variable

00:11:53.200 --> 00:11:55.722
and I'm checking the right
things as I go along.

00:11:55.722 --> 00:11:58.180
And the idea of this flow chart
is, if you start, you know,

00:11:58.180 --> 00:12:01.632
a little ball bearing here, it's
going to roll down, setting up

00:12:01.632 --> 00:12:03.840
an assignment statement,
and then, depending on here,

00:12:03.840 --> 00:12:05.130
it's like there's a pair
of flippers in there,

00:12:05.130 --> 00:12:06.921
it does the test, it
sets the ball this way

00:12:06.921 --> 00:12:09.415
to change it to ANS plus
1, and comes back around,

00:12:09.415 --> 00:12:11.540
eventually it's going to
drop through and print out

00:12:11.540 --> 00:12:12.040
the answer.

00:12:12.040 --> 00:12:14.514
The reason I'm going to
show you this flow chart,

00:12:14.514 --> 00:12:16.430
I'm going to do one other
example in a second,

00:12:16.430 --> 00:12:17.710
but I want to show
you a comparison.

00:12:17.710 --> 00:12:19.959
Remember last time, we wrote
this simple piece of code

00:12:19.959 --> 00:12:21.690
to print out even or odd.

00:12:21.690 --> 00:12:25.321
If, you know, x, it was
in fact, even or odd.

00:12:25.321 --> 00:12:26.820
So let me show you
what a flow chart

00:12:26.820 --> 00:12:28.820
for that would look like,
because I want to make

00:12:28.820 --> 00:12:35.140
a comparison point here.

00:12:35.140 --> 00:12:40.050
If I were to do a flow chart for
that one, I'd do the following.

00:12:40.050 --> 00:12:48.527
It reminds you,
that the test here

00:12:48.527 --> 00:12:50.610
was, we took x if that's
what we were looking for,

00:12:50.610 --> 00:12:54.360
it did integer division
by 2, multiplied it by 2,

00:12:54.360 --> 00:12:58.740
and we check to see if
that was the same as x.

00:12:58.740 --> 00:13:10.580
If the answer is yes, then
we did a print of even.

00:13:10.580 --> 00:13:21.240
If the answer was no,
we did a print of odd,

00:13:21.240 --> 00:13:27.000
and we then carried on.

00:13:27.000 --> 00:13:28.160
Again, while.

00:13:28.160 --> 00:13:30.515
But there's an
important point here.

00:13:30.515 --> 00:13:32.140
Remember last time,
I said that there's

00:13:32.140 --> 00:13:35.660
different kinds of
complexity in our code,

00:13:35.660 --> 00:13:39.720
and I suggested for simple
branching programs, the amount

00:13:39.720 --> 00:13:41.650
of time it takes
to run that program

00:13:41.650 --> 00:13:44.370
is, in essence, bounded by
the number of instructions,

00:13:44.370 --> 00:13:47.540
because you only execute each
instruction at most once.

00:13:47.540 --> 00:13:49.970
It didn't depend on
the size of the input.

00:13:49.970 --> 00:13:52.660
And you can see that there.

00:13:52.660 --> 00:13:57.060
I start off, either I take
this path and carry on,

00:13:57.060 --> 00:14:01.340
or I take that path and carry
on, but each box, if you like,

00:14:01.340 --> 00:14:02.580
gets touched exactly once.

00:14:02.580 --> 00:14:06.370
On the other hand,
look at this one.

00:14:06.370 --> 00:14:10.290
This depends now
on the size of x.

00:14:10.290 --> 00:14:11.801
All right?

00:14:11.801 --> 00:14:13.050
Because what am I going to do?

00:14:13.050 --> 00:14:15.383
I'm going to come down and
say, is ANS squared less than

00:14:15.383 --> 00:14:15.970
or equal to x?

00:14:15.970 --> 00:14:18.190
If it is, I'm going to
go around, and execute

00:14:18.190 --> 00:14:21.300
that statement, check it again,
and go around and execute that.

00:14:21.300 --> 00:14:24.400
So I'm going to cycle
around that loop there

00:14:24.400 --> 00:14:26.120
enough times to
get to the answer,

00:14:26.120 --> 00:14:28.500
and that number of times is
going to depend on the input,

00:14:28.500 --> 00:14:30.920
so as I change the
input, I'm going

00:14:30.920 --> 00:14:33.380
to change the
complexity of the code.

00:14:33.380 --> 00:14:37.060
Now this happens to be what we
would call a linear process,

00:14:37.060 --> 00:14:39.260
because the number of
times I go around the loop

00:14:39.260 --> 00:14:41.467
is directly related to
the size of the argument.

00:14:41.467 --> 00:14:42.925
If I double the
argument, I'm going

00:14:42.925 --> 00:14:45.273
to double the number of
times I go around the loop.

00:14:45.273 --> 00:14:46.731
If I increase it
by five, I'm going

00:14:46.731 --> 00:14:49.330
to increase by five the number
of times I go around the loop.

00:14:49.330 --> 00:14:51.650
We'll see later on, there
are classes of computation

00:14:51.650 --> 00:14:54.059
that are inherently
much more complex.

00:14:54.059 --> 00:14:55.600
We hate them, because
they're costly,

00:14:55.600 --> 00:14:57.830
but they're sometimes
inherently that way.

00:14:57.830 --> 00:15:01.150
But you can see the
comparison between these two.

00:15:01.150 --> 00:15:01.850
OK.

00:15:01.850 --> 00:15:07.400
Now, having done that,
let's build this code.

00:15:07.400 --> 00:15:11.660
Yeah, if my machine will
come back up, there we go.

00:15:11.660 --> 00:15:14.285
So, I'm going to now
go ahead and write

00:15:14.285 --> 00:15:16.100
a little piece of
code, and I put it here

00:15:16.100 --> 00:15:20.190
and I hope you can actually
see these better this time,

00:15:20.190 --> 00:15:23.140
let me uncomment that region.

00:15:23.140 --> 00:15:25.600
All right.

00:15:25.600 --> 00:15:28.080
So, there's basically an
encapsulation of that code,

00:15:28.080 --> 00:15:29.060
right?

00:15:29.060 --> 00:15:32.819
It says-- what, look
at this, where am I,

00:15:32.819 --> 00:15:34.860
right here-- I've got some
value for x initially,

00:15:34.860 --> 00:15:37.850
I'm going to set ANS
to 0, just like there,

00:15:37.850 --> 00:15:41.770
and there's my loop, there's the
test, which is right like that,

00:15:41.770 --> 00:15:43.820
is ANS squared less
than or equal to x,

00:15:43.820 --> 00:15:48.140
if it is, there's the block
corresponding to the loop,

00:15:48.140 --> 00:15:50.810
change ANS, and eventually when
I'm done with all this thing,

00:15:50.810 --> 00:15:53.090
I'm just going to print ANS out.

00:15:53.090 --> 00:15:53.590
OK.

00:15:53.590 --> 00:15:57.430
All right, let me show you one
other tool that I want to use.

00:15:57.430 --> 00:16:00.000
Which is, I've written
that piece of code,

00:16:00.000 --> 00:16:01.030
I ought to check it.

00:16:01.030 --> 00:16:04.150
Well, I could just run it,
but another useful thing to do

00:16:04.150 --> 00:16:07.020
is, I'm, especially as I
want to debug these things,

00:16:07.020 --> 00:16:08.310
is to simulate that code.

00:16:08.310 --> 00:16:12.890
And I'm going to do this
because, as Professor

00:16:12.890 --> 00:16:15.320
Guttag noticed to me, students
seem reluctant to do this.

00:16:15.320 --> 00:16:16.950
I guess it's not
macho enough, John,

00:16:16.950 --> 00:16:19.894
to just, you know, you know,
go off and do things by hand,

00:16:19.894 --> 00:16:22.060
you ought to just run them,
but it's a valuable tool

00:16:22.060 --> 00:16:23.560
to get into, so let
me do that here.

00:16:23.560 --> 00:16:25.905
STUDENT: [UNINTELLIGIBLE]

00:16:25.905 --> 00:16:28.030
PROFESSOR ERIC GRIMSON:
I'm doing such a great job.

00:16:28.030 --> 00:16:30.590
I've got to say, when my, I've
got two sons, now aged eighteen

00:16:30.590 --> 00:16:31.880
and twenty, they
used to think I had

00:16:31.880 --> 00:16:33.463
the coolest job in
the world because I

00:16:33.463 --> 00:16:34.820
came home covered in chalk.

00:16:34.820 --> 00:16:37.111
Now they have a different
opinion that you can probably

00:16:37.111 --> 00:16:39.450
figure out.

00:16:39.450 --> 00:16:40.060
All right.

00:16:40.060 --> 00:16:41.650
Simulate the code.

00:16:41.650 --> 00:16:43.920
What I mean by that is,
pick a simple set of values,

00:16:43.920 --> 00:16:46.014
and let's walk through
it to see what happens.

00:16:46.014 --> 00:16:47.555
And this is useful
because it's going

00:16:47.555 --> 00:16:50.379
to allow me to A, make sure
that I've got something that's

00:16:50.379 --> 00:16:51.920
going to terminate,
it's going to let

00:16:51.920 --> 00:16:53.430
me make sure that
in fact I'm doing

00:16:53.430 --> 00:16:54.830
the right kinds of updates.

00:16:54.830 --> 00:16:57.000
I could do this, by the
way, by running the code

00:16:57.000 --> 00:16:59.350
and putting print statements
in various places as well,

00:16:59.350 --> 00:17:00.870
but the hand
simulation is valuable,

00:17:00.870 --> 00:17:02.280
so let me just start it.

00:17:02.280 --> 00:17:03.300
What do I have here?

00:17:03.300 --> 00:17:10.030
I need the variable,
ANS, I need x,

00:17:10.030 --> 00:17:11.780
and I need ANS times
ANS, ANS times ANS.

00:17:11.780 --> 00:17:12.280
Right.

00:17:12.280 --> 00:17:13.738
Those are the three
things that are

00:17:13.738 --> 00:17:15.760
involved in this
computation. and I pick

00:17:15.760 --> 00:17:17.050
something reasonably simple.

00:17:17.050 --> 00:17:19.780
The ANS starts at 0.

00:17:19.780 --> 00:17:22.417
I set up x, I think,
to be 16 there.

00:17:22.417 --> 00:17:23.500
So what does the loop say?

00:17:23.500 --> 00:17:24.740
I can either look
at my flow chart,

00:17:24.740 --> 00:17:25.520
or I can look at the code.

00:17:25.520 --> 00:17:28.060
If I look at the flow chart,
it says, I'm at this point.

00:17:28.060 --> 00:17:29.071
Look at ANS squared.

00:17:29.071 --> 00:17:30.570
Is it less than or
equal to-- sorry,

00:17:30.570 --> 00:17:33.300
first of all, ANS squared is 0,
is it less than or equal to x,

00:17:33.300 --> 00:17:34.170
yes.

00:17:34.170 --> 00:17:35.610
So what do I do?

00:17:35.610 --> 00:17:36.360
Change ANS.

00:17:36.360 --> 00:17:39.810
X doesn't change.

00:17:39.810 --> 00:17:41.660
Back around to the test.

00:17:41.660 --> 00:17:42.840
What's ANS squared?

00:17:42.840 --> 00:17:43.870
It's 1.

00:17:43.870 --> 00:17:45.260
Is it less than or equal to 16?

00:17:45.260 --> 00:17:46.250
Sure.

00:17:46.250 --> 00:17:47.210
Run the loop again.

00:17:47.210 --> 00:17:49.640
ANS becomes 2.

00:17:49.640 --> 00:17:50.950
X stays 16.

00:17:50.950 --> 00:17:53.200
ANS squared is 4.

00:17:53.200 --> 00:17:55.250
Is that less than
or equal to 16?

00:17:55.250 --> 00:17:55.750
Yes.

00:17:55.750 --> 00:17:58.650
Aren't you glad I didn't
pick x equals 500?

00:17:58.650 --> 00:18:00.430
All right.

00:18:00.430 --> 00:18:02.040
ANS goes up by 0.

00:18:02.040 --> 00:18:03.970
ANS squared is nine.

00:18:03.970 --> 00:18:06.390
Still less than or equal to 16.

00:18:06.390 --> 00:18:07.370
ANS goes to 4.

00:18:07.370 --> 00:18:10.490
X stays the same.

00:18:10.490 --> 00:18:12.500
4 squared is 16.

00:18:12.500 --> 00:18:14.540
Is 16 less than or equal to 16?

00:18:14.540 --> 00:18:15.490
Yes.

00:18:15.490 --> 00:18:17.380
So ANS goes to five.

00:18:17.380 --> 00:18:19.030
ANS squared becomes 25.

00:18:19.030 --> 00:18:19.920
Ah!

00:18:19.920 --> 00:18:25.340
That is now no longer true
here, so I print out 5.

00:18:25.340 --> 00:18:27.110
Right.

00:18:27.110 --> 00:18:27.610
Sure.

00:18:27.610 --> 00:18:28.780
Square root of 16 is 5.

00:18:28.780 --> 00:18:31.050
It's Bush economics.

00:18:31.050 --> 00:18:33.350
OK?

00:18:33.350 --> 00:18:33.920
I know.

00:18:33.920 --> 00:18:37.070
I'm not supposed to make
bad jokes like that.

00:18:37.070 --> 00:18:38.740
What happened?

00:18:38.740 --> 00:18:39.240
Yeah.

00:18:39.240 --> 00:18:47.904
STUDENT: It doesn't
stop at the right place.

00:18:47.904 --> 00:18:49.320
PROFESSOR ERIC
GRIMSON: It doesn't

00:18:49.320 --> 00:18:49.650
stop at the right place.

00:18:49.650 --> 00:18:49.971
Thank you.

00:18:49.971 --> 00:18:50.080
Exactly.

00:18:50.080 --> 00:18:50.620
Right?

00:18:50.620 --> 00:18:53.680
My bug here is right there.

00:18:53.680 --> 00:18:58.070
Ah, let me find my cursor.

00:18:58.070 --> 00:18:59.920
I probably want that.

00:18:59.920 --> 00:19:00.420
Right?

00:19:00.420 --> 00:19:02.820
I want less than, rather
than less than or equal to.

00:19:02.820 --> 00:19:05.360
This is an easy bug
to come up with.

00:19:05.360 --> 00:19:07.140
But imagine, if you
don't do the test,

00:19:07.140 --> 00:19:09.389
you're going to get answers
that don't make any sense.

00:19:09.389 --> 00:19:11.820
And in fact, if we just
go ahead and run this now,

00:19:11.820 --> 00:19:17.532
hopefully we get
out-- oops, sorry,

00:19:17.532 --> 00:19:19.240
I'm going to have to
change this quickly,

00:19:19.240 --> 00:19:20.900
I still have some
things uncommented

00:19:20.900 --> 00:19:23.010
at the bottom, yeah,
there they are,

00:19:23.010 --> 00:19:25.460
I don't think we
need that yet, all

00:19:25.460 --> 00:19:32.660
right, we will
comment those out.

00:19:32.660 --> 00:19:35.460
OK.

00:19:35.460 --> 00:19:38.250
So.

00:19:38.250 --> 00:19:39.060
Why did I do it?

00:19:39.060 --> 00:19:41.970
It's a simple example, I agree,
but notice what I just did.

00:19:41.970 --> 00:19:44.780
It allowed me to highlight, is
the code doing the right thing?

00:19:44.780 --> 00:19:47.317
I spotted an error here,
I could have spotted it

00:19:47.317 --> 00:19:49.900
by running it on different test
sets, and using prints things,

00:19:49.900 --> 00:19:51.483
another way of doing
it, but this idea

00:19:51.483 --> 00:19:53.530
of at least simulating
it on simple examples

00:19:53.530 --> 00:19:56.402
lets you check a couple
of important questions.

00:19:56.402 --> 00:19:58.360
And in fact, now let me
ask those two questions

00:19:58.360 --> 00:20:00.240
about this piece of code.

00:20:00.240 --> 00:20:03.630
First question is, for
what values of integers--

00:20:03.630 --> 00:20:06.810
we're going to assume integers--
but for what values of x

00:20:06.810 --> 00:20:09.470
does this code terminate?

00:20:09.470 --> 00:20:12.670
And the second question
is, for what values of x

00:20:12.670 --> 00:20:14.690
does it give me back
the right answer?

00:20:14.690 --> 00:20:18.370
All right, first question.

00:20:18.370 --> 00:20:22.270
What values of x
does it terminate?

00:20:22.270 --> 00:20:26.230
Again, assume x is an integer.

00:20:26.230 --> 00:20:27.840
Well, break it down into pieces.

00:20:27.840 --> 00:20:29.770
Suppose x is positive.

00:20:29.770 --> 00:20:32.380
Does it terminate?

00:20:32.380 --> 00:20:33.031
Sure.

00:20:33.031 --> 00:20:33.530
All right?

00:20:33.530 --> 00:20:37.760
Because ANS starts out
as 0, so ANS squared is

00:20:37.760 --> 00:20:41.580
0, and each time through
the loop, ANS is increasing.

00:20:41.580 --> 00:20:44.410
That means, at some point, in
some finite number of steps,

00:20:44.410 --> 00:20:47.860
ANS squared has got to get
bigger than x if x is positive.

00:20:47.860 --> 00:20:50.360
So for positive
integers, it terminates.

00:20:50.360 --> 00:20:52.510
And it probably, I
think we can deduce,

00:20:52.510 --> 00:20:54.281
returns the right answer here.

00:20:54.281 --> 00:20:54.780
Right.

00:20:54.780 --> 00:20:56.530
X is negative.

00:20:56.530 --> 00:20:59.570
X is -16.

00:20:59.570 --> 00:21:05.080
Does this code terminate?

00:21:05.080 --> 00:21:08.940
Boy, I feel like
Arnold Schwarzenegger.

00:21:08.940 --> 00:21:11.050
Does this terminate?

00:21:11.050 --> 00:21:11.550
Somebody.

00:21:11.550 --> 00:21:13.947
STUDENT: [UNINTELLIGIBLE]

00:21:13.947 --> 00:21:15.530
PROFESSOR ERIC
GRIMSON: Ah, thank you,

00:21:15.530 --> 00:21:16.740
so it does terminate, right?

00:21:16.740 --> 00:21:21.090
You're sitting too far back, let
me try-- oh, too far!-- Sorry.

00:21:21.090 --> 00:21:23.200
Come get me one later
if you can't find it.

00:21:23.200 --> 00:21:25.790
Yes, it stops at the
first step, right?

00:21:25.790 --> 00:21:26.700
Let's look at it.

00:21:26.700 --> 00:21:30.910
It says, if answer, sorry,
imagine x is -16, ANS is 0,

00:21:30.910 --> 00:21:35.950
is 0 less than -16, no.

00:21:35.950 --> 00:21:37.450
So what does it do?

00:21:37.450 --> 00:21:39.860
It prints out 0.

00:21:39.860 --> 00:21:40.400
Ah!

00:21:40.400 --> 00:21:43.980
So that now answers my second
question, it does terminate,

00:21:43.980 --> 00:21:46.630
but does it give me
the right answer?

00:21:46.630 --> 00:21:47.280
No.

00:21:47.280 --> 00:21:47.590
Right?

00:21:47.590 --> 00:21:49.006
It gives me an
answer, and imagine

00:21:49.006 --> 00:21:51.970
I'm using this somewhere else,
you know, it's going to go off

00:21:51.970 --> 00:21:54.502
and say, gee, the
square root of -16 is 0.

00:21:54.502 --> 00:21:56.960
Well, it really should be a,
you know, an imaginary number,

00:21:56.960 --> 00:21:59.220
but this is not a valuable
thing to have come back.

00:21:59.220 --> 00:22:01.470
So that's the second thing
I've just highlighted here,

00:22:01.470 --> 00:22:05.255
is that I now have the
ability to check whether it

00:22:05.255 --> 00:22:06.130
does the right thing.

00:22:06.130 --> 00:22:08.297
And those are two
things that you'd

00:22:08.297 --> 00:22:10.380
like to do with every
looping construct you write:

00:22:10.380 --> 00:22:13.320
you'd like to be able to assure
yourself that they will always

00:22:13.320 --> 00:22:16.040
terminate, and then the
second thing you'd like to do,

00:22:16.040 --> 00:22:18.040
is to assure yourself
that it does give you back

00:22:18.040 --> 00:22:19.860
a reasonable answer.

00:22:19.860 --> 00:22:21.970
We started to talk about
ways to do the former.

00:22:21.970 --> 00:22:22.920
It's looking at the end test.

00:22:22.920 --> 00:22:24.300
It's looking at the
kinds of conditions

00:22:24.300 --> 00:22:25.430
you're going to put in.

00:22:25.430 --> 00:22:27.520
For the latter, this
is a place where

00:22:27.520 --> 00:22:31.170
running test cases would do a
good job of helping with that.

00:22:31.170 --> 00:22:34.550
Nonetheless, having done that,
let's look at a better way

00:22:34.550 --> 00:22:35.850
to write this.

00:22:35.850 --> 00:22:40.980
Which is right here, it is
also, I think, on your sheet,

00:22:40.980 --> 00:22:47.650
I'm going to uncomment that,
and comment this one out, yeah.

00:22:47.650 --> 00:22:50.500
All right?

00:22:50.500 --> 00:22:53.360
So let's look at this
code for a second.

00:22:53.360 --> 00:22:54.420
Notice what this does.

00:22:54.420 --> 00:22:57.100
Certainly the heart
of it, right in here,

00:22:57.100 --> 00:22:59.800
is still the same thing.

00:22:59.800 --> 00:23:00.930
But notice what this does.

00:23:00.930 --> 00:23:02.930
The first thing it does
is, it says, let's check

00:23:02.930 --> 00:23:05.470
and make sure x is greater
than or equal to 0.

00:23:05.470 --> 00:23:07.770
If it isn't, notice
what's going to happen.

00:23:07.770 --> 00:23:09.984
None of that block is
going to get executed,

00:23:09.984 --> 00:23:11.900
and it's going to come
down here and print out

00:23:11.900 --> 00:23:13.858
a useful piece of
information, which says, hey,

00:23:13.858 --> 00:23:15.500
you gave me a negative number.

00:23:15.500 --> 00:23:17.901
I don't know how to do this.

00:23:17.901 --> 00:23:20.400
If it is, in fact, positive,
then we're going to go in here,

00:23:20.400 --> 00:23:21.840
but now notice what
we're doing here.

00:23:21.840 --> 00:23:23.820
There is the basic thing
we did before, right?

00:23:23.820 --> 00:23:25.734
We're checking the end
test and incrementing,

00:23:25.734 --> 00:23:28.150
actually I was going to, I
commented that out for a reason

00:23:28.150 --> 00:23:29.450
you'll see in a second,
but I, normally I

00:23:29.450 --> 00:23:31.658
would keep this on, which
would let me, at each step,

00:23:31.658 --> 00:23:33.510
see what it's doing.

00:23:33.510 --> 00:23:35.880
If I ran this, it would
print out each step.

00:23:35.880 --> 00:23:37.505
Which is helping me
make sure that it's

00:23:37.505 --> 00:23:38.772
incrementing the right way.

00:23:38.772 --> 00:23:41.230
OK, once it gets to the end of
that, what's it going to do?

00:23:41.230 --> 00:23:44.280
It's going to come
down here and, oh.

00:23:44.280 --> 00:23:46.609
What's that doing?

00:23:46.609 --> 00:23:47.900
Well, I cheated when I started.

00:23:47.900 --> 00:23:49.460
I said, somebody's giving
me a perfect square,

00:23:49.460 --> 00:23:51.250
I'm looking for the
square root of it.

00:23:51.250 --> 00:23:55.402
But suppose I gave this thing
15, and asked it to run.

00:23:55.402 --> 00:23:56.610
It'd still give me an answer.

00:23:56.610 --> 00:23:59.630
It just would not be the
answer I'm looking for.

00:23:59.630 --> 00:24:02.307
So now, in this case, this code
is going to, when we get here,

00:24:02.307 --> 00:24:04.640
check, and if you haven't
seen that strange thing there,

00:24:04.640 --> 00:24:07.950
that exclamation point in
computer-ese called a bang,

00:24:07.950 --> 00:24:13.557
it says if ANS star ANS is
not equal to x, all right?

00:24:13.557 --> 00:24:15.140
What's that say, it
says, I've already

00:24:15.140 --> 00:24:16.320
gotten to the end
of the loop, I'm now

00:24:16.320 --> 00:24:17.760
past where I wanted
to be, and I'm

00:24:17.760 --> 00:24:19.760
going to check to make sure
that, in fact, this really

00:24:19.760 --> 00:24:20.593
is a perfect square.

00:24:20.593 --> 00:24:22.580
If it isn't, print
out something says,

00:24:22.580 --> 00:24:25.390
ah, you gave me something
that wasn't a perfect square.

00:24:25.390 --> 00:24:32.210
And only if that is true, am I
going to print out the answer.

00:24:32.210 --> 00:24:34.810
It's the same computation.

00:24:34.810 --> 00:24:36.420
But this is a nice
way of writing it,

00:24:36.420 --> 00:24:47.091
often called
defensive programming.

00:24:47.091 --> 00:24:49.340
And I think we have lots of
variations on it-- I don't

00:24:49.340 --> 00:24:50.965
know about John, what
your favorite is,

00:24:50.965 --> 00:24:54.010
for the definition of defensive
programming-- for me it says,

00:24:54.010 --> 00:24:56.500
make sure that I'm going
through all possible paths

00:24:56.500 --> 00:24:59.930
through the code, make sure
I'm printing out, or returning

00:24:59.930 --> 00:25:02.600
if you like, useful information
for each style, sorry,

00:25:02.600 --> 00:25:04.790
for each path through
the code, make sure

00:25:04.790 --> 00:25:06.490
that for all
possible inputs there

00:25:06.490 --> 00:25:08.122
is a path through
the code, or a way

00:25:08.122 --> 00:25:10.330
to get through the code,
that does not cause an error

00:25:10.330 --> 00:25:11.600
or infinite loop.

00:25:11.600 --> 00:25:12.850
What else would you add, John?

00:25:12.850 --> 00:25:15.980
PROFESSOR JOHN
GUTTAG: Well, we'll

00:25:15.980 --> 00:25:18.320
come back to this
later in the term,

00:25:18.320 --> 00:25:22.590
and talk in some detail
about particular techniques.

00:25:22.590 --> 00:25:25.230
The basic idea of
defensive programming

00:25:25.230 --> 00:25:28.740
is, to assume that A, if you're
getting inputs from a user,

00:25:28.740 --> 00:25:31.690
they won't necessarily give
you the input you've asked for,

00:25:31.690 --> 00:25:33.270
so if you ask for
a positive number,

00:25:33.270 --> 00:25:36.390
don't count on them
giving you one, and B,

00:25:36.390 --> 00:25:38.450
if you're using a piece
of a program written

00:25:38.450 --> 00:25:41.740
by a programmer
who is not perfect,

00:25:41.740 --> 00:25:46.600
perhaps yourself, there could
be mistakes in that program,

00:25:46.600 --> 00:25:49.760
and so you write your program
under the assumption that,

00:25:49.760 --> 00:25:52.110
not only might the
user make a mistake,

00:25:52.110 --> 00:25:54.970
other parts of your program
might make a mistake,

00:25:54.970 --> 00:25:57.880
and you just put in
lots of different tests

00:25:57.880 --> 00:26:00.060
under the assumption
that you'd rather catch

00:26:00.060 --> 00:26:01.980
that something has gone wrong,

00:26:01.980 --> 00:26:04.680
then have it go wrong
and not know it.

00:26:04.680 --> 00:26:06.960
And we'll talk later in
the term about dozens

00:26:06.960 --> 00:26:09.860
of different tricks, but the
main thing to keep in mind

00:26:09.860 --> 00:26:14.450
is the general principle
that people are dumb.

00:26:14.450 --> 00:26:16.140
And will make mistakes.

00:26:16.140 --> 00:26:17.960
And therefore, you
write your programs

00:26:17.960 --> 00:26:22.600
so that catastrophes don't occur
when those mistakes are made.

00:26:22.600 --> 00:26:24.245
PROFESSOR ERIC GRIMSON: Good.

00:26:24.245 --> 00:26:26.120
As John said, we're
going to come back to it.

00:26:26.120 --> 00:26:28.100
But that's what,
basically the goal here.

00:26:28.100 --> 00:26:30.980
And you saw me put my hands up
when I said stupid programmer?

00:26:30.980 --> 00:26:33.360
I've certainly written
code that has this problem,

00:26:33.360 --> 00:26:35.930
I've tried to use my own
code that has this problem,

00:26:35.930 --> 00:26:38.737
and good to us,
right, good hygiene,

00:26:38.737 --> 00:26:40.320
I'm going to use
that word again here,

00:26:40.320 --> 00:26:42.600
of getting into the habit
of writing defensive code up

00:26:42.600 --> 00:26:44.474
front, it's part of that
collection of things

00:26:44.474 --> 00:26:46.710
that you ought to do,
is a great thing to do.

00:26:46.710 --> 00:26:48.876
I stress it in
particular because, I

00:26:48.876 --> 00:26:50.750
know you're all going
to get into this stage;

00:26:50.750 --> 00:26:54.070
you've got a problem set
due in a couple of hours,

00:26:54.070 --> 00:26:56.847
you're still writing the code,
you don't want to waste time,

00:26:56.847 --> 00:26:59.180
and I'm going to use quotes
on "waste time", doing those

00:26:59.180 --> 00:27:01.054
extra things to do the
defensive programming,

00:27:01.054 --> 00:27:02.887
you just want to get
the darn thing done.

00:27:02.887 --> 00:27:05.220
It's a bad habit to get into,
because when you come back

00:27:05.220 --> 00:27:07.100
to it, it may haunt you
later on down the road.

00:27:07.100 --> 00:27:08.766
So really get into
that notion of trying

00:27:08.766 --> 00:27:11.460
to be defensive as you program.

00:27:11.460 --> 00:27:12.052
OK.

00:27:12.052 --> 00:27:13.510
The other thing I
want to say here,

00:27:13.510 --> 00:27:17.660
is that this style of
program we just wrote,

00:27:17.660 --> 00:27:18.910
is actually a very common one.

00:27:18.910 --> 00:27:26.550
And we're going to give it
a nice little name, often

00:27:26.550 --> 00:27:29.387
referred to as
exhaustive enumeration.

00:27:29.387 --> 00:27:30.220
What does that mean?

00:27:30.220 --> 00:27:34.872
It says, I'm literally walking
through all possible values

00:27:34.872 --> 00:27:38.359
of some parameter, some
element of the computation,

00:27:38.359 --> 00:27:40.400
testing everything until
I find the right answer.

00:27:40.400 --> 00:27:42.290
All right, so it's,
you know, again, I

00:27:42.290 --> 00:27:44.550
can even write that
down, essentially saying,

00:27:44.550 --> 00:28:01.305
try all reasonable values
until you find the solution.

00:28:01.305 --> 00:28:02.930
And you might say,
well, wait a minute,

00:28:02.930 --> 00:28:05.497
isn't that going to
be really expensive?

00:28:05.497 --> 00:28:07.830
And the answer is, yeah, I
guess, if you want to search,

00:28:07.830 --> 00:28:10.460
you know, all the pages
on Google, one by one,

00:28:10.460 --> 00:28:12.290
yes, probably, it's
going to take a while.

00:28:12.290 --> 00:28:14.370
But there are an awful lot of
computations for which this

00:28:14.370 --> 00:28:15.453
is the right way to do it.

00:28:15.453 --> 00:28:17.630
You just want to exhaustively
go through things.

00:28:17.630 --> 00:28:19.550
And just to give
you a sense of that,

00:28:19.550 --> 00:28:20.740
let me show you an example.

00:28:20.740 --> 00:28:25.430
I'm going to change
this, all right?

00:28:25.430 --> 00:28:30.340
Nice big number.

00:28:30.340 --> 00:28:32.060
You know, computers
are fast these days.

00:28:32.060 --> 00:28:33.200
I can make this
even bigger, it's

00:28:33.200 --> 00:28:34.991
going to do it fairly
quickly, so it really

00:28:34.991 --> 00:28:35.910
is quick to do this.

00:28:35.910 --> 00:28:38.400
It doesn't mean that exhaustive
enumeration is a bad idea,

00:28:38.400 --> 00:28:40.970
it is often the
right idea to use.

00:28:40.970 --> 00:28:42.570
So we've seen one
example of this,

00:28:42.570 --> 00:28:44.778
this idea of walking through
all the integers looking

00:28:44.778 --> 00:28:46.090
for the square root.

00:28:46.090 --> 00:28:47.820
Let's look at some
other examples,

00:28:47.820 --> 00:28:52.000
in order to try and see other
ways in which we could do it.

00:28:52.000 --> 00:28:52.500
OK.

00:28:52.500 --> 00:28:55.770
In particular, let's
go over to here,

00:28:55.770 --> 00:28:58.770
and let me show you
a second example.

00:28:58.770 --> 00:29:07.750
And let me comment that out.

00:29:07.750 --> 00:29:11.230
Here's another problem
that I'd like to solve.

00:29:11.230 --> 00:29:13.810
Suppose I want to find all
the divisors of some integer,

00:29:13.810 --> 00:29:17.080
I want to figure out
what all the divisors are

00:29:17.080 --> 00:29:19.180
that go evenly into it.

00:29:19.180 --> 00:29:21.384
Again, same kind of reasoning
says, given some value

00:29:21.384 --> 00:29:23.800
x, I happened to pick a small
one here, what's an easy way

00:29:23.800 --> 00:29:24.900
to do this?

00:29:24.900 --> 00:29:27.430
Well, let's just start at one.

00:29:27.430 --> 00:29:29.680
That's my variable I'm
going to change and check.

00:29:29.680 --> 00:29:32.010
Does it divide evenly into x?

00:29:32.010 --> 00:29:33.410
If it does, print it out.

00:29:33.410 --> 00:29:35.470
Move on to the next
one, print it out.

00:29:35.470 --> 00:29:37.480
So again, I can do the
same kind of thing here,

00:29:37.480 --> 00:29:39.480
you can see that,
in fact, let's just

00:29:39.480 --> 00:29:44.960
run it to make sure it
does the right thing, OK?

00:29:44.960 --> 00:29:47.452
In fact, if I go
back to the code,

00:29:47.452 --> 00:29:48.660
what did I decide to do here?

00:29:48.660 --> 00:29:51.920
I say, starting with
an initialization of I,

00:29:51.920 --> 00:29:53.736
there's my first
step, as equal to 1,

00:29:53.736 --> 00:29:55.360
I'm going to walk
through a little loop

00:29:55.360 --> 00:29:57.370
where I check, as
long-- first of all,

00:29:57.370 --> 00:29:59.660
as long as I is less than
x, so there's my end test,

00:29:59.660 --> 00:30:00.510
I'm going to do something.

00:30:00.510 --> 00:30:02.050
And in this case,
the something is,

00:30:02.050 --> 00:30:06.255
I'm going to look to see
if I divides x evenly.

00:30:06.255 --> 00:30:07.880
So I'll remind you
of that amp-- sorry,

00:30:07.880 --> 00:30:11.170
that percent sign there,
that says if x divided by I

00:30:11.170 --> 00:30:13.760
has a 0 remainder, because this
gives me back the remainder,

00:30:13.760 --> 00:30:16.410
if that's equal to 0,
print something out.

00:30:16.410 --> 00:30:19.774
And there's my nice increment.

00:30:19.774 --> 00:30:20.940
Simple little piece of code.

00:30:20.940 --> 00:30:22.840
Notice again, exactly
the same form:

00:30:22.840 --> 00:30:24.340
I picked the thing
I wanted to vary,

00:30:24.340 --> 00:30:26.610
I initialized it
outside the loop,

00:30:26.610 --> 00:30:28.335
I have a test to
see when I'm done,

00:30:28.335 --> 00:30:29.960
and then I've got a
set of instructions

00:30:29.960 --> 00:30:31.330
I'm doing every time
inside the loop.

00:30:31.330 --> 00:30:33.454
In this case, it's doing
the check on the remainder

00:30:33.454 --> 00:30:34.415
and printing them out.

00:30:34.415 --> 00:30:36.040
And when I'm done
with the whole thing,

00:30:36.040 --> 00:30:38.057
before I end the
increment of the variable,

00:30:38.057 --> 00:30:40.390
you know, when I'm done, I'm
just not returning anything

00:30:40.390 --> 00:30:42.210
out.

00:30:42.210 --> 00:30:42.710
OK.

00:30:42.710 --> 00:30:45.320
So now you've seen
two simple examples.

00:30:45.320 --> 00:30:47.710
Let me generalize this.

00:30:47.710 --> 00:30:51.530
In this case, my incrementer
was just adding 1 to an integer,

00:30:51.530 --> 00:30:53.870
it's a pretty
straightforward thing to do.

00:30:53.870 --> 00:30:55.870
But you can imagine
thinking about this a little

00:30:55.870 --> 00:30:56.369
differently.

00:30:56.369 --> 00:30:59.810
If I somehow had a collection,
an ordered collection of all

00:30:59.810 --> 00:31:02.770
the integers, from
1 to 10, I could

00:31:02.770 --> 00:31:05.020
imagine doing the same thing,
where now what I'm doing

00:31:05.020 --> 00:31:07.490
is, I'm starting with the first
element of that collection,

00:31:07.490 --> 00:31:09.000
doing something, going
to the next element,

00:31:09.000 --> 00:31:10.850
doing something, going to the
next element, doing something,

00:31:10.850 --> 00:31:12.933
I'm just walking through
the sequence of elements.

00:31:12.933 --> 00:31:13.972
Right?

00:31:13.972 --> 00:31:16.180
And I haven't said yet, how
do I get that collection,

00:31:16.180 --> 00:31:17.721
but you could
certainly conceptualize

00:31:17.721 --> 00:31:21.120
that, if I had that collection,
that would be nice thing to do.

00:31:21.120 --> 00:31:23.110
That is a more common pattern.

00:31:23.110 --> 00:31:27.650
That is basically saying,
given some collection of data,

00:31:27.650 --> 00:31:29.810
I want to have again a
looping mechanism, where

00:31:29.810 --> 00:31:32.790
now my process is, walk
through this, the collection,

00:31:32.790 --> 00:31:33.880
one element at a time.

00:31:33.880 --> 00:31:41.070
And for that, we have
a particular construct,

00:31:41.070 --> 00:31:42.360
called a FOR loop.

00:31:42.360 --> 00:31:44.424
It's going to do
exactly that for us.

00:31:44.424 --> 00:31:46.090
It's going to be more
general than this,

00:31:46.090 --> 00:31:47.020
and we're going to
come back to that,

00:31:47.020 --> 00:31:48.630
in fact, Professor Guttag's
going to pick this up

00:31:48.630 --> 00:31:50.713
in a couple of lectures,
but we can talk right now

00:31:50.713 --> 00:31:51.750
about the basic form.

00:31:51.750 --> 00:31:54.240
The form of a FOR
loop says, FOR,

00:31:54.240 --> 00:31:56.240
and I'm going to put
little angle braces in here

00:31:56.240 --> 00:31:57.614
again, to say,
for some variable,

00:31:57.614 --> 00:32:08.200
like a name I want to get
to it, in some collection,

00:32:08.200 --> 00:32:14.470
and then I have a block of code.

00:32:14.470 --> 00:32:17.250
And what it's saying
semantically is,

00:32:17.250 --> 00:32:19.560
using that variable
as my placeholder,

00:32:19.560 --> 00:32:21.140
have it walk through
this collection,

00:32:21.140 --> 00:32:23.490
starting at the first thing,
execute that code, then

00:32:23.490 --> 00:32:26.480
the next thing, execute
that code, and so on.

00:32:26.480 --> 00:32:29.450
One of the advantages
of this is,

00:32:29.450 --> 00:32:32.050
that I don't have to
worry about explicitly

00:32:32.050 --> 00:32:33.624
updating my variable.

00:32:33.624 --> 00:32:35.040
That happens for
me automatically.

00:32:35.040 --> 00:32:36.530
And that's very
nice, because this

00:32:36.530 --> 00:32:39.750
allows me to be sure that my
FOR loop is going to terminate.

00:32:39.750 --> 00:32:43.562
And because, as long as
this collection is finite,

00:32:43.562 --> 00:32:45.270
this thing is just
going to walk through.

00:32:45.270 --> 00:32:46.760
All right?

00:32:46.760 --> 00:32:48.310
So, if I show you,
for example, I'm

00:32:48.310 --> 00:32:53.030
going to comment this one
out in the usual manner,

00:32:53.030 --> 00:33:03.860
and let's look at
uncommenting that, there

00:33:03.860 --> 00:33:07.000
is the same piece of code.

00:33:07.000 --> 00:33:09.252
Now, I slung something by
you, or snuck something

00:33:09.252 --> 00:33:10.710
by you, which is,
I hadn't said how

00:33:10.710 --> 00:33:14.610
to generate the set of
integers from 1 to 10.

00:33:14.610 --> 00:33:16.782
So, range is a built-in
Python function.

00:33:16.782 --> 00:33:18.490
I'm going to come back
to it in a second.

00:33:18.490 --> 00:33:20.240
For now, just think
of it as saying, it

00:33:20.240 --> 00:33:25.690
gives you all the integers from
1 up to, but not including, x.

00:33:25.690 --> 00:33:26.642
OK.

00:33:26.642 --> 00:33:27.850
But now you can see the form.

00:33:27.850 --> 00:33:30.360
This now says, OK, let I start
as the first thing in there,

00:33:30.360 --> 00:33:32.760
which is 1, and then do
exactly as I did before,

00:33:32.760 --> 00:33:34.590
the same thing, but
notice I don't need

00:33:34.590 --> 00:33:36.317
to say how to increment it.

00:33:36.317 --> 00:33:38.970
It's happening
automatically for me.

00:33:38.970 --> 00:33:40.360
OK.

00:33:40.360 --> 00:33:45.230
In fact, if I run it,
it does the same thing,

00:33:45.230 --> 00:33:47.860
which is what I would expect.

00:33:47.860 --> 00:33:49.650
OK.

00:33:49.650 --> 00:33:54.670
Now, the advantage of the FOR,
as I said, is that it has,

00:33:54.670 --> 00:33:57.470
then, if you like, a
cleaner way of reading it.

00:33:57.470 --> 00:33:59.552
I don't have to worry
about, do I initialize it,

00:33:59.552 --> 00:34:01.510
did I forget to initialize
it outside the loop,

00:34:01.510 --> 00:34:03.724
it happens automatically
just by the syntax of it,

00:34:03.724 --> 00:34:06.140
right there, that's going to
start with the first element.

00:34:06.140 --> 00:34:07.220
I don't have to
worry about, did I

00:34:07.220 --> 00:34:08.678
remember to put
the incrementer in,

00:34:08.678 --> 00:34:11.230
it's going to automatically
walk it's way through there.

00:34:11.230 --> 00:34:13.630
Second advantage of the FOR
is, that right now, we're

00:34:13.630 --> 00:34:15.671
thinking about it just as
a sequence of integers.

00:34:15.671 --> 00:34:17.860
We could imagine it's just
counting its way through.

00:34:17.860 --> 00:34:19.401
But we're going to
see, very shortly,

00:34:19.401 --> 00:34:21.670
that in fact those collections
could be arbitrary.

00:34:21.670 --> 00:34:23.670
We're going to have other
ways of building them,

00:34:23.670 --> 00:34:25.661
but it could be a collection
of all the primes.

00:34:25.661 --> 00:34:26.160
Hm.

00:34:26.160 --> 00:34:27.970
There's an interesting
thing to do.

00:34:27.970 --> 00:34:30.770
It could be a collection of,
ah, you know, I don't know,

00:34:30.770 --> 00:34:32.690
batting averages of
somebody or other.

00:34:32.690 --> 00:34:34.186
It could be
arbitrary collections

00:34:34.186 --> 00:34:35.810
that you've come up
with in other ways.

00:34:35.810 --> 00:34:38.090
The FOR is, again, going to let
you walk through that thing.

00:34:38.090 --> 00:34:39.680
So it does not have
to be something

00:34:39.680 --> 00:34:43.790
that could be described
procedurally, such as add 1

00:34:43.790 --> 00:34:45.230
just to the previous element.

00:34:45.230 --> 00:34:47.470
It could be any
arbitrary collection.

00:34:47.470 --> 00:34:48.970
And if I were to
use that again, I'd

00:34:48.970 --> 00:34:50.570
just put it on your
handout, I could go back

00:34:50.570 --> 00:34:52.403
and rewrite that thing
that I had previously

00:34:52.403 --> 00:34:55.020
for finding the square roots
of the perfect squares,

00:34:55.020 --> 00:34:57.970
just using the FOR loop.

00:34:57.970 --> 00:34:58.976
OK.

00:34:58.976 --> 00:35:01.100
What I want to do, though,
is go on to-- or, sorry,

00:35:01.100 --> 00:35:07.730
go back to-- my divisor example.
[UNINTELLIGIBLE PHRASE] OK.

00:35:07.730 --> 00:35:08.230
Try again.

00:35:08.230 --> 00:35:09.720
I've got a number, I want
to find the divisors.

00:35:09.720 --> 00:35:11.220
Right now, what my
code is doing is,

00:35:11.220 --> 00:35:14.520
it's printing them up
for me, which is useful.

00:35:14.520 --> 00:35:17.430
But imagine I actually wanted
to gather them together.

00:35:17.430 --> 00:35:20.054
I wanted to collect them, so I
could do something with them.

00:35:20.054 --> 00:35:21.220
I might want to add them up.

00:35:21.220 --> 00:35:22.440
Might want to multiply
them together.

00:35:22.440 --> 00:35:24.814
Might want to do, I don't
know, something else with them,

00:35:24.814 --> 00:35:27.760
find common divisors, of
things by looking at them.

00:35:27.760 --> 00:35:30.092
I need, in fact, a
way to make explicit,

00:35:30.092 --> 00:35:31.550
what I can't do
that with range, is

00:35:31.550 --> 00:35:34.970
I need a way to collect
things together.

00:35:34.970 --> 00:35:37.520
And that's going to be the
first of our more compound data

00:35:37.520 --> 00:35:40.480
structures, and we have
exactly such a structure,

00:35:40.480 --> 00:35:49.680
and it's called a tuple.

00:35:49.680 --> 00:35:59.884
This is an ordered
sequence of elements.

00:35:59.884 --> 00:36:01.550
Now, I'm going to
actually add something

00:36:01.550 --> 00:36:03.675
to it that's going to make
sense in a little while,

00:36:03.675 --> 00:36:09.506
or in a couple of lectures,
which is, it is immutable.

00:36:09.506 --> 00:36:12.130
Meaning, I cannot change it, and
we'll see why that's important

00:36:12.130 --> 00:36:12.629
later on.

00:36:12.629 --> 00:36:17.730
But for now, tuple is this
ordered sequence of structures.

00:36:17.730 --> 00:36:18.500
OK.

00:36:18.500 --> 00:36:20.600
And how do I create them?

00:36:20.600 --> 00:36:32.370
Well, the representation is,
following a square bracket,

00:36:32.370 --> 00:36:35.150
followed by a sequence of
elements, separated by commas,

00:36:35.150 --> 00:36:38.074
followed by a closed
square bracket.

00:36:38.074 --> 00:36:39.490
And that is literally
what I said,

00:36:39.490 --> 00:36:41.860
it is an ordered
sequence of elements,

00:36:41.860 --> 00:36:44.080
you can see where they are.

00:36:44.080 --> 00:36:44.580
OK?

00:36:44.580 --> 00:36:46.204
So, let me do a little
example of this.

00:36:46.204 --> 00:36:53.140
If I go back over here,
let's define-- er,

00:36:53.140 --> 00:37:02.150
can't type-- I can look
at the value of test,

00:37:02.150 --> 00:37:03.960
it's an ordered sequence.

00:37:03.960 --> 00:37:05.900
I need to get
elements out of it.

00:37:05.900 --> 00:37:07.490
So again, I have a
way of doing that.

00:37:07.490 --> 00:37:12.330
In particular, I can ask for
the zeroth element of test.

00:37:12.330 --> 00:37:16.230
OK, notice, I'm putting a
square bracket around it,

00:37:16.230 --> 00:37:18.800
and it gives me-- I know
this sounds confusing,

00:37:18.800 --> 00:37:21.150
but this is a long tradition,
it gives me-- ah, yes.

00:37:21.150 --> 00:37:24.820
STUDENT: [UNINTELLIGIBLE]

00:37:24.820 --> 00:37:31.619
PROFESSOR ERIC GRIMSON: Sorry?

00:37:31.619 --> 00:37:32.660
STUDENT: [UNINTELLIGIBLE]

00:37:32.660 --> 00:37:33.230
PROFESSOR ERIC GRIMSON:
I created a list here?

00:37:33.230 --> 00:37:35.120
Ah, thank you.

00:37:35.120 --> 00:37:37.850
I'm glad you guys
are on top of it.

00:37:37.850 --> 00:37:40.460
You're saying I want that.

00:37:40.460 --> 00:37:43.040
Is that right, John?

00:37:43.040 --> 00:37:43.720
Yes?

00:37:43.720 --> 00:37:44.220
OK.

00:37:44.220 --> 00:37:45.549
Sorry.

00:37:45.549 --> 00:37:48.090
You're going to see why this
was a mistake in a little while.

00:37:48.090 --> 00:37:49.470
I did not want to
make a list, I wanted

00:37:49.470 --> 00:37:51.303
to create a tuple thank
you for catching it.

00:37:51.303 --> 00:37:53.704
I want parens, not
square brackets there.

00:37:53.704 --> 00:37:56.120
You'll also see in a little
while why both of these things

00:37:56.120 --> 00:37:58.430
would work this way, but
it's not what I wanted.

00:37:58.430 --> 00:37:59.400
OK?

00:37:59.400 --> 00:38:00.900
So I guess I should
go back, and let

00:38:00.900 --> 00:38:09.720
me do this correctly this way.

00:38:09.720 --> 00:38:13.470
Again, I can look at
test, and I guess test now

00:38:13.470 --> 00:38:16.450
if I want to get the
element out-- angle

00:38:16.450 --> 00:38:18.020
bracket or square bracket?

00:38:18.020 --> 00:38:21.395
I still want square bracket,
that's what I thought-- OK.

00:38:21.395 --> 00:38:22.770
Now I can go back
to where I was,

00:38:22.770 --> 00:38:24.520
which is a strange
piece of history, which

00:38:24.520 --> 00:38:27.090
is, we start counting at 0.

00:38:27.090 --> 00:38:29.310
So the-- I hate to
say it this way,

00:38:29.310 --> 00:38:33.520
the first element of this tuple
is at position 0, or index 0,

00:38:33.520 --> 00:38:39.240
OK?-- so I can get the zeroth
one out, I can get, if I do 2,

00:38:39.240 --> 00:38:42.710
I get the third thing out,
because it goes 0, 1, 2--

00:38:42.710 --> 00:38:46.670
notice, however, if I do
something that tries to go

00:38:46.670 --> 00:38:53.272
outside the length of the tuple
it complains, which is right.

00:38:53.272 --> 00:38:54.980
Tuples? also have
another nice structure,

00:38:54.980 --> 00:38:56.854
which is, I can go the
other direction, which

00:38:56.854 --> 00:39:02.130
is, if I want to get the
last element of that tuple

00:39:02.130 --> 00:39:03.256
I give it a negative index.

00:39:03.256 --> 00:39:05.713
So, imagine, you think of it
as, is it starting right, just

00:39:05.713 --> 00:39:07.160
before the beginning
of the thing,

00:39:07.160 --> 00:39:09.010
if I give it a 0 it's going
to take the first one,

00:39:09.010 --> 00:39:11.093
if I give it a 1, it's
going to take the next one,

00:39:11.093 --> 00:39:14.010
but I can go the other
direction, if I give it a -1,

00:39:14.010 --> 00:39:15.830
it picks up the last
element of the tuple.

00:39:15.830 --> 00:39:21.760
And again, I can go -2, go back.

00:39:21.760 --> 00:39:27.250
So this is what we
would call selection.

00:39:27.250 --> 00:39:31.650
We can do things like
foo of 0 to get out

00:39:31.650 --> 00:39:34.600
the particular element.

00:39:34.600 --> 00:39:38.110
I can also pick up
pieces of that tuple.

00:39:38.110 --> 00:39:40.850
Again I want to show
you the format here.

00:39:40.850 --> 00:39:45.360
If I give it this
strange expression,

00:39:45.360 --> 00:39:47.880
this is saying I want to
get the piece of the tuple

00:39:47.880 --> 00:39:51.300
starting at index 1, it's
going to be the second element,

00:39:51.300 --> 00:39:53.750
and going up to but
not including index 3.

00:39:53.750 --> 00:39:58.760
And it gives me back that piece.

00:39:58.760 --> 00:40:02.840
Actually a copy of that
piece of the tuple.

00:40:02.840 --> 00:40:13.620
This is called slicing.

00:40:13.620 --> 00:40:15.190
And then just to complete this.

00:40:15.190 --> 00:40:18.150
Two other nice things you
can do with slices are you

00:40:18.150 --> 00:40:22.510
can get the beginning
or the end of tuple.

00:40:22.510 --> 00:40:25.200
So, for example, if I say TEST
and I don't give it a start

00:40:25.200 --> 00:40:28.300
but I give it an end, then
it gives me all the elements

00:40:28.300 --> 00:40:30.720
up to that point.

00:40:30.720 --> 00:40:32.600
And I can obviously
do the other direction

00:40:32.600 --> 00:40:42.410
which is I can say skip to index
2 and all the remaining pieces.

00:40:42.410 --> 00:40:45.310
This lets me slice
out, if you like,

00:40:45.310 --> 00:40:48.370
the front part or back part or
a middle part of the tuple as I

00:40:48.370 --> 00:40:50.770
go along.

00:40:50.770 --> 00:40:55.090
What in the world does that have
to do with my divisor example?

00:40:55.090 --> 00:40:57.800
Well, actually, before I do that
let me in fact fill in a piece

00:40:57.800 --> 00:40:57.940
here.

00:40:57.940 --> 00:41:00.610
Which is remember I said range
we could think of conceptually

00:41:00.610 --> 00:41:07.330
as a tuple -- or sorry as
a sequence of these things.

00:41:07.330 --> 00:41:09.610
In fact it gives me
back, now I hate this,

00:41:09.610 --> 00:41:12.390
it's actually a list
it's not a tuple.

00:41:12.390 --> 00:41:13.960
But for now think
of it as giving you

00:41:13.960 --> 00:41:17.400
back an explicit version of
that representation of all

00:41:17.400 --> 00:41:18.079
those elements.

00:41:18.079 --> 00:41:20.120
You'll see why I'm going
to make that distinction

00:41:20.120 --> 00:41:22.510
in a couple of lectures.

00:41:22.510 --> 00:41:23.450
All right.

00:41:23.450 --> 00:41:25.690
What does this have to do
with my divisor example?

00:41:25.690 --> 00:41:28.560
This says I can make tuples,
but imagine now going back

00:41:28.560 --> 00:41:31.360
to my divisor example
and I want to gather up

00:41:31.360 --> 00:41:33.560
the elements as I go along.

00:41:33.560 --> 00:41:36.540
I ought to be able to do
that by in fact just adding

00:41:36.540 --> 00:41:38.040
the pieces in.

00:41:38.040 --> 00:41:42.590
And that's what I'm
going to do over here.

00:41:42.590 --> 00:41:56.090
Which is, let me comment that
out, let me uncomment that.

00:41:56.090 --> 00:41:58.290
And I guess I need the
same thing here, right?

00:41:58.290 --> 00:42:04.720
I need parens not, thank you.

00:42:04.720 --> 00:42:06.700
You can tell I'm an
old time list packer.

00:42:06.700 --> 00:42:08.880
I really do love these things.

00:42:08.880 --> 00:42:15.150
And is that right, John?

00:42:15.150 --> 00:42:17.280
OK, so my apologies that
your handout is wrong.

00:42:17.280 --> 00:42:19.155
I did not think to check
about the difference

00:42:19.155 --> 00:42:20.511
between these things.

00:42:20.511 --> 00:42:22.010
Nonetheless, having
done that, let's

00:42:22.010 --> 00:42:24.170
look at what I'm going to do.

00:42:24.170 --> 00:42:26.570
I now want to run
a loop where I need

00:42:26.570 --> 00:42:28.075
to collect things together.

00:42:28.075 --> 00:42:29.450
I'm going to give
a name to that.

00:42:29.450 --> 00:42:31.616
And what you see there is
I'm going to call divisors

00:42:31.616 --> 00:42:35.170
initially an empty tuple,
something has nothing in it.

00:42:35.170 --> 00:42:35.912
Right here.

00:42:35.912 --> 00:42:37.870
And then I'm going to
run through the same loop

00:42:37.870 --> 00:42:40.320
as before, going through this
set of things, doing the check.

00:42:40.320 --> 00:42:41.778
Now what I'd like
to do, every time

00:42:41.778 --> 00:42:44.330
I find a divisor I'd like
to gather it together.

00:42:44.330 --> 00:42:49.360
So I'm going to create a tuple
of one element, the value of i.

00:42:49.360 --> 00:42:51.630
And then, ah, cool.

00:42:51.630 --> 00:42:54.410
Here's that addition operation
that's badly overloaded.

00:42:54.410 --> 00:42:56.990
This is why Professor
Guttag likes and I don't.

00:42:56.990 --> 00:43:01.472
Because given that this is
a tuple and that's a tuple,

00:43:01.472 --> 00:43:02.680
I can just add them together.

00:43:02.680 --> 00:43:06.820
That is concatenate them, if
you like, one on the end of it.

00:43:06.820 --> 00:43:09.500
And if I keep doing that,
when I'm done divisor

00:43:09.500 --> 00:43:10.830
will be a collection of things.

00:43:10.830 --> 00:43:15.330
So let me just run it.

00:43:15.330 --> 00:43:17.330
All right.

00:43:17.330 --> 00:43:20.825
This is what I get
for trying to --

00:43:20.825 --> 00:43:22.200
STUDENT There
should be a comment

00:43:22.200 --> 00:43:22.660
after the i in parentheses.

00:43:22.660 --> 00:43:24.690
PROFESSOR ERIC
GRIMSON: Thank you.

00:43:24.690 --> 00:43:26.240
Right there.

00:43:26.240 --> 00:43:31.510
All right, we'll try this again.

00:43:31.510 --> 00:43:35.695
OK.

00:43:35.695 --> 00:43:37.070
And there are the
set of devices.

00:43:37.070 --> 00:43:37.570
Thank you.

00:43:37.570 --> 00:43:38.120
Who did that?

00:43:38.120 --> 00:43:41.080
Somebody gets, no?

00:43:41.080 --> 00:43:41.610
Yours?

00:43:41.610 --> 00:43:42.680
Thank you.

00:43:42.680 --> 00:43:44.351
Nice catch too by the way.

00:43:44.351 --> 00:43:46.600
All right, so now that you
can see that I can screw up

00:43:46.600 --> 00:43:47.876
programming, which I just did.

00:43:47.876 --> 00:43:49.000
But we fixed it on the fly.

00:43:49.000 --> 00:43:49.840
Thank you.

00:43:49.840 --> 00:43:51.160
What have we done?

00:43:51.160 --> 00:43:54.220
We've now got a way of
collecting things together,

00:43:54.220 --> 00:43:55.110
right?

00:43:55.110 --> 00:43:58.000
And this is the first version
of something we'd like to use.

00:43:58.000 --> 00:43:59.767
Now that I've gotten
that bound as a name,

00:43:59.767 --> 00:44:01.350
I could go in and
do things with that.

00:44:01.350 --> 00:44:04.030
I could go in and say give
me the fourth divisor,

00:44:04.030 --> 00:44:06.260
give me the second
through fifth divisor.

00:44:06.260 --> 00:44:08.800
Again as I suggested if
I've got two integers

00:44:08.800 --> 00:44:10.260
and I want to find
common divisors

00:44:10.260 --> 00:44:11.910
I could take those two
lists and walk through them.

00:44:11.910 --> 00:44:12.480
I shouldn't say list,
those two tuples,

00:44:12.480 --> 00:44:15.680
and walk through them to find
the pieces that match up.

00:44:15.680 --> 00:44:19.151
So I've got a way now of
gathering data together.

00:44:19.151 --> 00:44:21.150
The last thing I want to
do is to say all right,

00:44:21.150 --> 00:44:25.890
now that we've got this idea
of being able to collect things

00:44:25.890 --> 00:44:29.010
into collections, we've got
the ability now to use looping

00:44:29.010 --> 00:44:33.680
structures as we did before
but we can walk down then doing

00:44:33.680 --> 00:44:37.580
things to them, where else might
we have this need to do things

00:44:37.580 --> 00:44:40.290
with looping structures?

00:44:40.290 --> 00:44:43.210
And I'm going to suggest
you've already seen it.

00:44:43.210 --> 00:44:45.570
What's a string?

00:44:45.570 --> 00:44:49.540
Well at some level it is an
ordered sequence of characters.

00:44:49.540 --> 00:44:51.090
Right?

00:44:51.090 --> 00:44:53.170
Now it is not represented
this same way.

00:44:53.170 --> 00:44:55.130
You don't see strings
inside these open parens

00:44:55.130 --> 00:44:56.330
and closed parens.

00:44:56.330 --> 00:44:59.650
You don't see strings
with commas between them,

00:44:59.650 --> 00:45:01.860
but it has the same
kind of property.

00:45:01.860 --> 00:45:04.440
It is in ordered
sequence of characters.

00:45:04.440 --> 00:45:07.019
We'd like to do the
same thing with strings.

00:45:07.019 --> 00:45:09.310
That is we'd like to be able
to get pieces of them out.

00:45:09.310 --> 00:45:11.450
We'd like to be able add them
together or concatenate them

00:45:11.450 --> 00:45:11.949
together.

00:45:11.949 --> 00:45:13.580
We'd like to be
able to slice them.

00:45:13.580 --> 00:45:17.710
And in fact we can.

00:45:17.710 --> 00:45:33.150
So strings also support things
like selection, slicing,

00:45:33.150 --> 00:45:35.310
and a set of other
parameters, other properties.

00:45:35.310 --> 00:45:36.720
And let's just look at that.

00:45:36.720 --> 00:45:47.850
Again if I go back here,
let me comment this out.

00:45:47.850 --> 00:45:55.810
Right here are a pair of strings
that I've set up, s 1 and s 2.

00:45:55.810 --> 00:45:57.090
Let me just run these.

00:45:57.090 --> 00:46:00.310
We can go back over here.

00:46:00.310 --> 00:46:03.530
So I can see the value
of s 1, it's a string.

00:46:03.530 --> 00:46:07.501
I can do things
like s 1 and s 2.

00:46:07.501 --> 00:46:09.750
As we saw before, it simply
concatenates them together

00:46:09.750 --> 00:46:11.450
and gives me back
a longer string.

00:46:11.450 --> 00:46:13.940
But I can also ask
for parts of this.

00:46:13.940 --> 00:46:20.720
So I can, for example, say
give me the first element

00:46:20.720 --> 00:46:23.720
of string 1, s 1.

00:46:23.720 --> 00:46:25.951
Ah, that's exactly
what we would have

00:46:25.951 --> 00:46:28.200
thought if this was represented
as an ordered sequence

00:46:28.200 --> 00:46:29.030
of things.

00:46:29.030 --> 00:46:32.190
Again I should have said
first, index 0, the first one.

00:46:32.190 --> 00:46:34.170
I can similarly
go in and say I'd

00:46:34.170 --> 00:46:41.442
like all the things between
index 2 and index 4.

00:46:41.442 --> 00:46:42.900
And again, remember
what that does.

00:46:42.900 --> 00:46:44.350
Index 2 says start a 0.

00:46:44.350 --> 00:46:44.850
1, 2.

00:46:44.850 --> 00:46:47.430
So a, b, c.

00:46:47.430 --> 00:46:49.600
And then it goes up to
but not including index 4

00:46:49.600 --> 00:46:53.070
so it gets c and d
and then it stops.

00:46:53.070 --> 00:46:55.690
I can similarly, just as
I did with the tuples,

00:46:55.690 --> 00:47:01.372
I can ask for everything
up to some point

00:47:01.372 --> 00:47:03.455
or I can ask for everything
starting at some point

00:47:03.455 --> 00:47:06.650
and carrying on.

00:47:06.650 --> 00:47:09.410
Now what you're seeing
here then is the beginning

00:47:09.410 --> 00:47:11.660
of complex data structures.

00:47:11.660 --> 00:47:13.910
And the nice thing
is that there's

00:47:13.910 --> 00:47:14.990
a shared behavior there.

00:47:14.990 --> 00:47:17.940
Just as I can have tuples as an
ordered collection of things,

00:47:17.940 --> 00:47:20.390
strings behave as an ordered
collection of things.

00:47:20.390 --> 00:47:23.550
So I can start thinking about
doing manipulation on strings.

00:47:23.550 --> 00:47:27.004
I can concatenate them together,
I can find pieces inside

00:47:27.004 --> 00:47:28.920
of them, I could actually
do things with them.

00:47:28.920 --> 00:47:30.920
And let me show you just
a simple little example

00:47:30.920 --> 00:47:35.960
of something I might want to do.

00:47:35.960 --> 00:47:42.800
Suppose I take, I better
comment this one out

00:47:42.800 --> 00:47:44.350
or it's going to spit it out.

00:47:44.350 --> 00:47:47.070
Let me comment that out.

00:47:47.070 --> 00:47:50.720
Suppose I take a number.

00:47:50.720 --> 00:47:53.460
I'd like to add up all the
digits inside of the number.

00:47:53.460 --> 00:47:55.300
I can use the tools
I've just described

00:47:55.300 --> 00:47:56.120
in order to capture that.

00:47:56.120 --> 00:47:57.244
So what would I want to do?

00:47:57.244 --> 00:47:59.410
I'd like to somehow walk
down each of the digits

00:47:59.410 --> 00:48:02.330
one at a time and add them up.

00:48:02.330 --> 00:48:04.610
Ah, that's a looping
mechanism, right?

00:48:04.610 --> 00:48:06.770
I need to have some way
of walking through them.

00:48:06.770 --> 00:48:08.954
An easy way to do it
would be inside of a FOR.

00:48:08.954 --> 00:48:10.120
And what would I like to do?

00:48:10.120 --> 00:48:12.280
Well I need to take
that number and I'm

00:48:12.280 --> 00:48:13.890
going to turn it into a string.

00:48:13.890 --> 00:48:16.530
So notice what I'm
going to do right here.

00:48:16.530 --> 00:48:19.580
I take that number and
convert it into a string.

00:48:19.580 --> 00:48:22.510
That's an example of that type
conversion we did earlier on.

00:48:22.510 --> 00:48:25.540
By doing that it makes it
possible for me to treat it

00:48:25.540 --> 00:48:27.732
as an ordered sequence
of characters.

00:48:27.732 --> 00:48:29.190
And so what's the
loop going to do?

00:48:29.190 --> 00:48:30.606
It's going to say
FOR c, which was

00:48:30.606 --> 00:48:32.730
my name for the
character in that string.

00:48:32.730 --> 00:48:34.487
That means starting
at the first one,

00:48:34.487 --> 00:48:35.820
I'm going to do something to it.

00:48:35.820 --> 00:48:37.040
And what am I'm going to do?

00:48:37.040 --> 00:48:38.680
I'm going to take
that character,

00:48:38.680 --> 00:48:43.886
convert it back into an integer,
and add it into some digits.

00:48:43.886 --> 00:48:45.510
And I've done a little
short hand here,

00:48:45.510 --> 00:48:47.550
which is I should have
said some digits is

00:48:47.550 --> 00:48:49.962
equal to some digits plus this.

00:48:49.962 --> 00:48:51.420
But that little
short hand there is

00:48:51.420 --> 00:48:52.700
doing exactly the same thing.

00:48:52.700 --> 00:48:54.910
It is adding that
value into some digits

00:48:54.910 --> 00:48:57.734
and putting it back or signing
it back into some digits.

00:48:57.734 --> 00:48:59.400
And I'll walk through
that loop and when

00:48:59.400 --> 00:49:04.140
I'm done I can print out
the total thing does.

00:49:04.140 --> 00:49:10.470
And if I do that, I get
out what I would expect.

00:49:10.470 --> 00:49:12.800
So what have I done?

00:49:12.800 --> 00:49:15.900
We've now generalized
the idea of iteration

00:49:15.900 --> 00:49:17.354
into this little pattern.

00:49:17.354 --> 00:49:19.770
Again as I said this is my
version of it, but you can see,

00:49:19.770 --> 00:49:21.590
every one of the examples
we've used so far

00:49:21.590 --> 00:49:22.999
has that pattern to it.

00:49:22.999 --> 00:49:24.790
Figure out what I'm
trying to walk through.

00:49:24.790 --> 00:49:26.920
What's the collection of things
I'm trying to walk through.

00:49:26.920 --> 00:49:28.590
Figure out what I want
to do at each stage.

00:49:28.590 --> 00:49:29.780
Figure out what the end test is.

00:49:29.780 --> 00:49:31.821
Figure out what I'm going
to do at the end of it.

00:49:31.821 --> 00:49:32.930
I can write it explicitly.

00:49:32.930 --> 00:49:34.852
I can write it
inside of a FOR loop.

00:49:34.852 --> 00:49:36.310
And we've started
to add, and we'll

00:49:36.310 --> 00:49:40.142
see a lot more of this, examples
of collections of structures

00:49:40.142 --> 00:49:42.100
so that we don't just
have to do something that

00:49:42.100 --> 00:49:44.660
can be easily described as
walking through a set of things

00:49:44.660 --> 00:49:47.342
but can actually be a collection
that you walk through.

00:49:47.342 --> 00:49:49.050
The last thing I want
to point out to you

00:49:49.050 --> 00:49:54.150
is, I started out
with this list.

00:49:54.150 --> 00:49:58.230
I haven't added anything
to the list, right?

00:49:58.230 --> 00:50:00.979
I mean I've got a different
kind of looping mechanism.

00:50:00.979 --> 00:50:02.770
I guess I should say
that's not quite true.

00:50:02.770 --> 00:50:04.940
I've added the ability
to have more complex data

00:50:04.940 --> 00:50:06.820
structures here.

00:50:06.820 --> 00:50:08.570
But I dropped a hint
in the first lecture

00:50:08.570 --> 00:50:10.319
about what you could
computer with things.

00:50:10.319 --> 00:50:13.050
In fact if you think for
a second about that list,

00:50:13.050 --> 00:50:15.060
you could ask what can
I compute with just

00:50:15.060 --> 00:50:17.120
that set of constructs?

00:50:17.120 --> 00:50:19.810
And the answer is
basically anything.

00:50:19.810 --> 00:50:21.980
This is an example
of what is referred

00:50:21.980 --> 00:50:26.500
to frequently as being a
Turing complete language.

00:50:26.500 --> 00:50:29.360
That is to say with just those
set of constructs, anything

00:50:29.360 --> 00:50:32.110
you can describe
algorithmically you can compute

00:50:32.110 --> 00:50:34.230
with that set of constructs.

00:50:34.230 --> 00:50:36.170
So there's good
news and bad news.

00:50:36.170 --> 00:50:38.240
The good news is it
sounds like we're done.

00:50:38.240 --> 00:50:41.570
Class is cancelled until final
exam because this is all you

00:50:41.570 --> 00:50:43.150
need to know, right?

00:50:43.150 --> 00:50:44.900
The bad news is of
course that's not true.

00:50:44.900 --> 00:50:48.014
The real issue is to figure
out how to build constructs out

00:50:48.014 --> 00:50:49.680
of this that tackle
particular problems,

00:50:49.680 --> 00:50:52.120
but the fundamental
basics of computation

00:50:52.120 --> 00:50:55.260
are just captured in
that set of mechanisms.

00:50:55.260 --> 00:50:57.280
All right, we'll
see you next time.