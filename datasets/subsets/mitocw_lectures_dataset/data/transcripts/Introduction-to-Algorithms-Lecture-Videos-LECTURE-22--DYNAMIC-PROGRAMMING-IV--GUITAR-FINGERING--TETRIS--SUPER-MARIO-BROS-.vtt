WEBVTT

00:00:00.050 --> 00:00:01.770
The following
content is provided

00:00:01.770 --> 00:00:04.010
under a Creative
Commons license.

00:00:04.010 --> 00:00:06.860
Your support will help MIT
OpenCourseWare continue

00:00:06.860 --> 00:00:10.720
to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.330
To make a donation or
view additional materials

00:00:13.330 --> 00:00:17.207
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.207 --> 00:00:17.832
at ocw.mit.edu.

00:00:27.322 --> 00:00:28.780
PROFESSOR: Today's
our last lecture

00:00:28.780 --> 00:00:31.270
on dynamic programming,
the grand finale.

00:00:31.270 --> 00:00:35.550
And we have a bunch of fun
examples today on piano,

00:00:35.550 --> 00:00:39.440
guitar, Tetris and
Super Mario Brothers.

00:00:39.440 --> 00:00:42.090
What could be better?

00:00:42.090 --> 00:00:44.830
We are, again, going to
follow this five-step plan

00:00:44.830 --> 00:00:48.260
to dynamic programming, define
sub-problems, guess something

00:00:48.260 --> 00:00:51.110
in order to solve a sub-problem,
write a recurrence that

00:00:51.110 --> 00:00:53.920
uses that guessing to relate
different sub-problems,

00:00:53.920 --> 00:00:56.220
then build your dynamic
programming either

00:00:56.220 --> 00:00:58.130
by just implementing as
a recursive algorithm

00:00:58.130 --> 00:01:01.940
and memorizing or
building it bottom up.

00:01:01.940 --> 00:01:05.360
For the first, you need to check
with the recurrence is acyclic.

00:01:05.360 --> 00:01:08.020
For the second, you need an
actual topological order.

00:01:08.020 --> 00:01:10.880
These are, of course,
equivalent constraints.

00:01:10.880 --> 00:01:13.220
Personally, I like to write
down on topological order

00:01:13.220 --> 00:01:15.310
because that proves to
me that it is acyclic,

00:01:15.310 --> 00:01:17.400
if I think about it.

00:01:17.400 --> 00:01:19.955
But either way is fine.

00:01:19.955 --> 00:01:21.580
Then we get that the
total running time

00:01:21.580 --> 00:01:24.292
is number of sub-problems
times time per sub-problems,

00:01:24.292 --> 00:01:26.250
and then we need to solve
our original problem.

00:01:26.250 --> 00:01:27.999
Usually it's just one
of the sub-problems,

00:01:27.999 --> 00:01:31.056
but sometimes we have to
look at a few of them.

00:01:31.056 --> 00:01:32.430
So that's what
we're going to do.

00:01:32.430 --> 00:01:34.320
And we have one
new concept today

00:01:34.320 --> 00:01:38.200
that all these examples
will illustrate,

00:01:38.200 --> 00:01:41.570
which is a kind of
second kind of guessing.

00:01:41.570 --> 00:01:44.270
We've talked about
guessing in part two

00:01:44.270 --> 00:01:46.620
here in which we saw
the obvious thing.

00:01:46.620 --> 00:01:48.400
In the recurrence, we
usually take the min

00:01:48.400 --> 00:01:51.830
of a bunch of options or the
max of a bunch of options.

00:01:51.830 --> 00:01:54.744
And those options correspond
to a guessed feature.

00:01:54.744 --> 00:01:56.660
We don't know whether
the go left or go right,

00:01:56.660 --> 00:01:57.493
so we try them both.

00:01:57.493 --> 00:01:59.000
That's guessing.

00:01:59.000 --> 00:02:02.110
But there's another
way to guess.

00:02:02.110 --> 00:02:11.640
So two kinds of guessing.

00:02:17.590 --> 00:02:21.377
So you can do it in step two.

00:02:21.377 --> 00:02:23.085
Let's see what I have
to say about these.

00:02:26.320 --> 00:02:36.270
In step two and three,
you are guessing usually

00:02:36.270 --> 00:02:38.250
which sub-problems
to use in order

00:02:38.250 --> 00:02:44.140
to solve your
bigger sub-problem.

00:02:50.470 --> 00:02:52.720
So that's what we've seen
many, many times by now.

00:02:52.720 --> 00:02:55.940
Every DP that we've covered
except for Fibonacci numbers

00:02:55.940 --> 00:02:58.020
has used this kind of guessing.

00:02:58.020 --> 00:03:00.980
And it's sort of the most
common, I guess you might say.

00:03:00.980 --> 00:03:03.160
But there's a higher
level of guessing

00:03:03.160 --> 00:03:05.750
that you can use, which
we've sort of seen

00:03:05.750 --> 00:03:09.200
in the knapsack dynamic
programming, dynamic program,

00:03:09.200 --> 00:03:13.680
which is when you define your
sub-problems, you can add more.

00:03:21.140 --> 00:03:26.350
Add more sub-problems to
guess or you can think of it

00:03:26.350 --> 00:03:31.315
as remembering more
features of the solution.

00:03:38.820 --> 00:03:40.300
And we just leave it at that.

00:03:43.240 --> 00:03:49.400
Essentially what this does--
so remember with knapsack,

00:03:49.400 --> 00:03:50.950
we had a sequence of items.

00:03:50.950 --> 00:03:54.460
They had values and sizes.

00:03:54.460 --> 00:03:57.115
And we had some target
knapsack, some capacity.

00:03:57.115 --> 00:03:59.340
We wanted to pack those
items into that knapsack.

00:03:59.340 --> 00:04:02.370
And the obvious sub-problems
were suffixes of the items.

00:04:02.370 --> 00:04:04.620
Because we always know
suffixes, prefixes, substrings,

00:04:04.620 --> 00:04:06.370
those are the obvious
things to try.

00:04:06.370 --> 00:04:07.970
But suffixes wasn't
quite enough.

00:04:07.970 --> 00:04:09.630
Because if we
looked at a suffix,

00:04:09.630 --> 00:04:12.290
we didn't know of
the prefix that we've

00:04:12.290 --> 00:04:14.251
skipped over how
many of those items

00:04:14.251 --> 00:04:16.459
were in-- and in particular,
how much of the capacity

00:04:16.459 --> 00:04:17.722
we'd used up.

00:04:17.722 --> 00:04:19.430
And so we needed to
add more sub-problems

00:04:19.430 --> 00:04:23.440
to remember how much capacity
had we used up in the prefix.

00:04:23.440 --> 00:04:25.610
We did that by multiplying
every sub-problem

00:04:25.610 --> 00:04:32.190
by s different choices, which is
how many units of the knapsack

00:04:32.190 --> 00:04:34.234
still remain.

00:04:34.234 --> 00:04:35.900
So in some sense,
we're remembering more

00:04:35.900 --> 00:04:37.460
about the prefix.

00:04:37.460 --> 00:04:41.110
You can also think of it as--
in the more forward direction,

00:04:41.110 --> 00:04:42.480
we have the suffix problem.

00:04:42.480 --> 00:04:44.420
I'm going to solve
it s different times,

00:04:44.420 --> 00:04:45.664
or s plus 1 different times.

00:04:45.664 --> 00:04:46.580
I'm going to solve it.

00:04:46.580 --> 00:04:47.816
What if I had a big knapsack?

00:04:47.816 --> 00:04:49.190
What if I had a
smaller knapsack?

00:04:49.190 --> 00:04:50.780
What if I had a
zero-size knapsack?

00:04:50.780 --> 00:04:53.130
All of those different
versions of the problem.

00:04:53.130 --> 00:04:57.270
In some sense, you were
solving more sub-problems.

00:04:57.270 --> 00:04:59.330
You're, in some, sense
finding more solutions

00:04:59.330 --> 00:05:00.286
to that sub-problem.

00:05:00.286 --> 00:05:01.410
You're looking at a suffix.

00:05:01.410 --> 00:05:04.750
And I want to know all these
different solutions that

00:05:04.750 --> 00:05:07.619
use different amounts
of the knapsack.

00:05:07.619 --> 00:05:09.910
So in that sense, you're just
adding more sub-problems.

00:05:09.910 --> 00:05:11.534
But from a guessing
perspective, you're

00:05:11.534 --> 00:05:12.980
remembering more about the past.

00:05:12.980 --> 00:05:16.220
We're going to see a bunch of
examples of this type today.

00:05:16.220 --> 00:05:18.780
We'll always use
this type, but we'll

00:05:18.780 --> 00:05:23.230
see more of this where the
obvious sub-problems don't work

00:05:23.230 --> 00:05:25.940
and we need to add more.

00:05:25.940 --> 00:05:33.080
So the first example is
piano and guitar fingering.

00:05:38.030 --> 00:05:42.940
This is a practical problem for
any musicians in the audience.

00:05:42.940 --> 00:05:45.770
How many people here play
piano, or have played piano?

00:05:45.770 --> 00:05:46.740
OK, about a quarter.

00:05:46.740 --> 00:05:49.740
How many people
have played guitar?

00:05:49.740 --> 00:05:51.560
A few, all right.

00:05:51.560 --> 00:05:52.480
I brought my guitar.

00:05:52.480 --> 00:05:53.855
I've been learning
this semester.

00:05:53.855 --> 00:05:56.320
I'm not very good yet,
but we'll fool around

00:05:56.320 --> 00:05:58.010
with it a little bit.

00:05:58.010 --> 00:06:03.553
So the general idea is you're
given some musical piece

00:06:03.553 --> 00:06:05.810
that you want to play.

00:06:05.810 --> 00:06:07.870
And on a piano, there's
a bunch of keys.

00:06:07.870 --> 00:06:09.480
You have all these
keyboards, so you

00:06:09.480 --> 00:06:11.045
know what a piano looks
like, more or less.

00:06:11.045 --> 00:06:12.711
It's just like a
keyboard, but only row.

00:06:12.711 --> 00:06:13.470
It's crazy.

00:06:16.910 --> 00:06:18.930
Each key that you
press makes a note,

00:06:18.930 --> 00:06:20.800
and every key has
a different note.

00:06:20.800 --> 00:06:23.900
So it's very simple from
a computer scientist's

00:06:23.900 --> 00:06:24.480
perspective.

00:06:24.480 --> 00:06:26.229
You want to play a
note, you push the key.

00:06:26.229 --> 00:06:29.630
But you could push it with
any one of these fingers.

00:06:29.630 --> 00:06:30.840
Humans have 10 fingers.

00:06:30.840 --> 00:06:31.940
Most humans.

00:06:31.940 --> 00:06:33.560
I guess a few have more.

00:06:33.560 --> 00:06:37.800
But you want to know,
which finger should I

00:06:37.800 --> 00:06:39.340
use to play each note?

00:06:39.340 --> 00:06:40.680
It may not seem like a big deal.

00:06:40.680 --> 00:06:43.140
And if you're only playing
one note, it's not a big deal.

00:06:43.140 --> 00:06:46.250
But if you're going to play
a long sequence of notes,

00:06:46.250 --> 00:06:48.760
some transitions are
easier than others.

00:06:48.760 --> 00:06:55.620
So let's say we're given
a sequence of n notes

00:06:55.620 --> 00:06:58.470
we want to play.

00:06:58.470 --> 00:07:07.060
And we want to find a
fingering for each note.

00:07:12.100 --> 00:07:15.780
So fingering, so let's
say there are-- I'm

00:07:15.780 --> 00:07:21.540
going to label the fingers
on your hand, 1 up to f.

00:07:21.540 --> 00:07:24.820
For humans, f is
5 or 10, depending

00:07:24.820 --> 00:07:27.480
on if you're doing one
hand or two hand stuff.

00:07:27.480 --> 00:07:33.040
I think to keep it simple, let's
think about piano, right hand

00:07:33.040 --> 00:07:36.320
only, and just you're playing
one note at the time, OK?

00:07:36.320 --> 00:07:38.320
We're going to make it
more complicated later.

00:07:38.320 --> 00:07:41.470
But let's just think of a
note as being a single note.

00:07:44.816 --> 00:07:48.710
OK, or you can think of
guitar, single note, left hand

00:07:48.710 --> 00:07:50.590
is playing things.

00:07:50.590 --> 00:07:54.160
You want to assign one of
these fingers to each node.

00:07:54.160 --> 00:08:04.870
And then you have a
difficulty measure, d.

00:08:04.870 --> 00:08:06.850
And this you need to
think about for awhile

00:08:06.850 --> 00:08:12.620
musically, or anatomically,
how to define.

00:08:12.620 --> 00:08:16.380
If we have some note p
and we're on finger f

00:08:16.380 --> 00:08:20.980
and we want to transition
to note q using figure g,

00:08:20.980 --> 00:08:23.410
how hard is that?

00:08:23.410 --> 00:08:28.280
So this is-- the p and
q are notes to play.

00:08:28.280 --> 00:08:30.730
I guess p stands for pitch.

00:08:30.730 --> 00:08:34.400
And f and g are fingers.

00:08:34.400 --> 00:08:39.340
So this is how hard is it
to transition from f on p

00:08:39.340 --> 00:08:40.470
to g on q.

00:08:43.580 --> 00:08:47.960
There's a huge
literature on for piano.

00:08:47.960 --> 00:08:51.350
There are a lot of
rules like, well,

00:08:51.350 --> 00:08:55.420
if p is much smaller than
q, unless they're stretched,

00:08:55.420 --> 00:08:58.370
then that becomes hard.

00:08:58.370 --> 00:09:00.520
And if you want to
stretch, you probably

00:09:00.520 --> 00:09:04.230
need to use fingers that are
far away from each other.

00:09:04.230 --> 00:09:07.460
If your playing legato-- so you
have to smoothly go from one

00:09:07.460 --> 00:09:10.150
note the other-- you can't use
the same finger on both keys.

00:09:10.150 --> 00:09:13.950
So if f equals g and
you're playing legato,

00:09:13.950 --> 00:09:17.680
then p better be the
same as q sort of thing.

00:09:20.166 --> 00:09:21.290
There's a weak finger rule.

00:09:21.290 --> 00:09:25.730
You tend to avoid fingers
four and five, these two.

00:09:25.730 --> 00:09:29.120
Apparently going from-- I'm
not much of a pianist-- so

00:09:29.120 --> 00:09:31.547
going from between
three and four,

00:09:31.547 --> 00:09:33.880
which I can barely hold them
up, it's kind of difficult,

00:09:33.880 --> 00:09:34.975
is "annoying."

00:09:34.975 --> 00:09:36.880
That's what I wrote down.

00:09:36.880 --> 00:09:40.170
So between three and four
transitions you try and avoid.

00:09:40.170 --> 00:09:42.210
And so you can encode
into this function.

00:09:42.210 --> 00:09:43.190
It's a giant table.

00:09:43.190 --> 00:09:44.720
You can just put
in whatever values

00:09:44.720 --> 00:09:46.690
you want that you're
most comfortable with.

00:09:46.690 --> 00:09:48.940
And music theorists
work a lot on trying

00:09:48.940 --> 00:09:51.735
to define these function so.

00:09:51.735 --> 00:09:53.880
So you can do that.

00:09:53.880 --> 00:09:58.736
And for guitar, maybe I
should do a little example.

00:09:58.736 --> 00:10:01.770
Get this out.

00:10:01.770 --> 00:10:04.605
I can't play much,
so bear with me.

00:10:07.984 --> 00:10:09.900
Bet you didn't think
this would happen in 006.

00:10:09.900 --> 00:10:12.220
[LAUGHTER]

00:10:12.220 --> 00:10:15.100
So let's see.

00:10:15.100 --> 00:10:17.670
So let's say you're trying
to play your favorite song.

00:10:17.670 --> 00:10:20.484
[STRUMS "SUPER MARIO BROTHERS"
 THEME]

00:10:20.484 --> 00:10:22.360
[LAUGHTER]

00:10:22.360 --> 00:10:23.300
OK.

00:10:23.300 --> 00:10:26.530
So when I'm playing that, I have
to think about the fingering.

00:10:26.530 --> 00:10:29.060
Which finger is going to
go where to play each note?

00:10:29.060 --> 00:10:31.920
OK, so the first notes
are actually open,

00:10:31.920 --> 00:10:33.230
so it's really easy.

00:10:33.230 --> 00:10:40.730
And then I go up to holding the
first fret on the fifth string.

00:10:40.730 --> 00:10:43.840
OK, and I'm using my index
finger because everyone

00:10:43.840 --> 00:10:45.230
loves to use their index finger.

00:10:45.230 --> 00:10:48.010
And in particular because
the very next note

00:10:48.010 --> 00:10:50.720
I'm going to play-- well,
actually it's down here.

00:10:50.720 --> 00:10:53.640
Then the next note is
going to be this one.

00:10:53.640 --> 00:10:57.860
So I'm holding on the third
fret of the bottom string.

00:10:57.860 --> 00:10:59.770
And then I've got to
transition over here.

00:10:59.770 --> 00:11:02.370
And actually, usually I do
it with my middle finger.

00:11:02.370 --> 00:11:05.553
I don't know quite why I
find that easier, but I do.

00:11:05.553 --> 00:11:09.731
OK, and so I've actually
played that opening a zillion

00:11:09.731 --> 00:11:11.230
times with lots of
different things.

00:11:11.230 --> 00:11:13.355
This is the one I found to
be the most comfortable.

00:11:13.355 --> 00:11:14.604
And there's this issue, right?

00:11:14.604 --> 00:11:17.150
If your pinky is here, where
can I reach with this finger?

00:11:17.150 --> 00:11:19.690
Where can I reach
with this finger?

00:11:19.690 --> 00:11:20.444
It gets difficult.

00:11:20.444 --> 00:11:22.110
And in particular,
it's very hard for me

00:11:22.110 --> 00:11:25.440
to reach down here
when my pink is there.

00:11:25.440 --> 00:11:28.440
And so you can encode
that in this d function

00:11:28.440 --> 00:11:30.410
however you want.

00:11:30.410 --> 00:11:33.038
You get the idea.

00:11:33.038 --> 00:11:35.930
[APPLAUSE]

00:11:35.930 --> 00:11:37.499
Thanks.

00:11:37.499 --> 00:11:39.540
I'll skip to our lessons.
[? We're ?] [? worth ?]

00:11:39.540 --> 00:11:46.350
[? it. ?] So let's solve this
with dynamic programming, OK?

00:11:46.350 --> 00:11:47.420
That's the cool thing.

00:11:47.420 --> 00:11:49.710
So we can do it.

00:11:49.710 --> 00:11:54.450
And we follow our
five step procedure.

00:11:54.450 --> 00:11:56.340
So the first thing is
to define sub-problems.

00:11:56.340 --> 00:11:59.530
What are the sub-problems
for a set-up like this?

00:12:04.710 --> 00:12:06.370
What are the three
obvious candidates?

00:12:20.990 --> 00:12:22.400
Do you remember last lecture?

00:12:27.367 --> 00:12:28.700
How many people know the answer?

00:12:28.700 --> 00:12:29.283
Just checking.

00:12:32.544 --> 00:12:34.432
One person.

00:12:34.432 --> 00:12:35.376
Go for it.

00:12:35.376 --> 00:12:37.262
AUDIENCE: Prefixes,
suffixes, and substrings.

00:12:37.262 --> 00:12:37.970
PROFESSOR: Right.

00:12:37.970 --> 00:12:39.428
Prefixes, suffixes,
and substrings.

00:12:39.428 --> 00:12:40.595
We have a sequence of notes.

00:12:40.595 --> 00:12:42.886
We're not going to worry
about the sequence of fingers.

00:12:42.886 --> 00:12:44.530
I don't think that's
too big a deal.

00:12:44.530 --> 00:12:45.800
That's what we're finding.

00:12:45.800 --> 00:12:48.030
What we're given is
a sequence of notes,

00:12:48.030 --> 00:12:50.530
so we should try suffixes,
prefixes, or substrings.

00:12:50.530 --> 00:12:54.318
I'll just tell you,
suffixes are fine.

00:12:54.318 --> 00:12:55.690
Kind of.

00:12:55.690 --> 00:13:01.500
So a sub-problem
will be suffixes,

00:13:01.500 --> 00:13:10.440
so how to play notes
from i onwards.

00:13:10.440 --> 00:13:12.120
Intuitively, we
want to figure out,

00:13:12.120 --> 00:13:13.782
how should we play
the first note?

00:13:13.782 --> 00:13:15.740
And then we go on to the
second note and so on.

00:13:15.740 --> 00:13:17.770
So we're applying
them one by one

00:13:17.770 --> 00:13:19.930
from left to right
from the prefix side.

00:13:19.930 --> 00:13:22.040
And so we'll always
be left with a suffix.

00:13:24.940 --> 00:13:28.340
OK, then we need
to guess something.

00:13:28.340 --> 00:13:30.510
What's the obvious
thing to guess,

00:13:30.510 --> 00:13:32.390
given I need to
play notes i onward?

00:13:36.315 --> 00:13:38.939
Think little harder.

00:13:38.939 --> 00:13:40.480
This one you shouldn't
have to think.

00:13:40.480 --> 00:13:43.080
That's what I tell you.

00:13:43.080 --> 00:13:45.195
Try suffixes, try
prefixes, try substrings.

00:13:55.121 --> 00:13:55.621
Yeah?

00:13:55.621 --> 00:13:58.050
AUDIENCE: Maybe which
finger to just put around i?

00:13:58.050 --> 00:14:00.330
PROFESSOR: Yeah, which we're
going to use for note i.

00:14:00.330 --> 00:14:02.555
Our whole point is
to assign fingering.

00:14:02.555 --> 00:14:03.850
The first note here is i.

00:14:03.850 --> 00:14:06.090
So let's think about i,
what could you do for i?

00:14:06.090 --> 00:14:07.960
We'll try all the possibilities.

00:14:07.960 --> 00:14:14.660
Which finger to use for note i?

00:14:19.460 --> 00:14:22.680
OK, now the really hard part--
because it's impossible--

00:14:22.680 --> 00:14:23.960
is to write a recurrence.

00:14:23.960 --> 00:14:28.936
This is wrong, by the way, but
it's the first thing to try.

00:14:28.936 --> 00:14:30.310
So this is what
I want to ask you

00:14:30.310 --> 00:14:31.980
to do because it's not possible.

00:14:31.980 --> 00:14:34.060
But intuitively, what
we might try to do

00:14:34.060 --> 00:14:37.930
is we're trying
to solve DP for i.

00:14:37.930 --> 00:14:40.110
And we want to find--
this is difficulty,

00:14:40.110 --> 00:14:42.450
so you want to
minimize difficulty.

00:14:42.450 --> 00:14:45.550
So we'll take a min
over all of our guesses

00:14:45.550 --> 00:14:50.730
of what it would take to
solve the rest of the notes,

00:14:50.730 --> 00:14:53.720
to play the rest of the
notes, plus somehow the cost

00:14:53.720 --> 00:14:56.640
of playing the first note.

00:14:56.640 --> 00:14:59.750
So what's the cost of
playing the first note?

00:14:59.750 --> 00:15:01.770
And then is going to be
a for loop over fingers.

00:15:05.649 --> 00:15:06.940
OK, that's going to be the min.

00:15:06.940 --> 00:15:11.700
We want to try all possible
fingers for note i.

00:15:11.700 --> 00:15:13.700
Then we have to play
all the remaining notes.

00:15:13.700 --> 00:15:15.241
And then there's
this transition cost

00:15:15.241 --> 00:15:17.300
where you're going from
note i to i plus 1.

00:15:17.300 --> 00:15:19.470
So it's going to
be something like d

00:15:19.470 --> 00:15:23.010
of if-- we know that we use
finger f to play i-- then

00:15:23.010 --> 00:15:25.720
we have to go to note i plus 1.

00:15:25.720 --> 00:15:28.515
But then the problem is we have
no idea what to write here,

00:15:28.515 --> 00:15:30.140
because we don't know
what finger we're

00:15:30.140 --> 00:15:34.200
going to guess
for note i plus 1.

00:15:34.200 --> 00:15:38.535
So this cannot be known.

00:15:38.535 --> 00:15:41.470
OK, but it's the
first thing you should

00:15:41.470 --> 00:15:43.940
try, because often this works.

00:15:43.940 --> 00:15:47.320
For simple DPs, that's
enough for sub-problems.

00:15:47.320 --> 00:15:49.640
But we need to know
more information

00:15:49.640 --> 00:15:52.150
about what we're
going to do next.

00:15:52.150 --> 00:15:54.120
And this seems very
worrisome, maybe

00:15:54.120 --> 00:15:55.715
now we have to guess two things.

00:15:55.715 --> 00:15:57.900
Do we have to guess
more than two things?

00:15:57.900 --> 00:15:59.210
Turns out two things is enough.

00:15:59.210 --> 00:16:01.160
But we cannot use
this type of guessing.

00:16:01.160 --> 00:16:05.000
We need to use-- we need
to add more sub-problems.

00:16:05.000 --> 00:16:08.560
More sub-problem, more power.

00:16:08.560 --> 00:16:12.850
So any guesses what we
could do for sub-problem?

00:16:15.680 --> 00:16:17.180
A couple of right answers here.

00:16:23.485 --> 00:16:24.940
Yeah?

00:16:24.940 --> 00:16:28.820
AUDIENCE: Maybe like all
the suffixes [INAUDIBLE]

00:16:28.820 --> 00:16:32.640
like the i, for all written i's,
like all the possible fingers

00:16:32.640 --> 00:16:33.552
for i?

00:16:33.552 --> 00:16:35.010
PROFESSOR: All the
possible fingers

00:16:35.010 --> 00:16:36.051
for i in the sub-problem.

00:16:36.051 --> 00:16:37.980
Yeah, good.

00:16:37.980 --> 00:16:43.781
How to play-- it's still
about the suffixes.

00:16:43.781 --> 00:16:45.030
We're still going to use that.

00:16:52.709 --> 00:16:54.250
But we're going to
suppose we already

00:16:54.250 --> 00:17:02.230
know what finger to use
for the first note, note i.

00:17:02.230 --> 00:17:04.700
OK, this is a little weird,
because we were guessing that

00:17:04.700 --> 00:17:05.970
before.

00:17:05.970 --> 00:17:07.589
Now we're just
supposing someone tells

00:17:07.589 --> 00:17:11.760
us, use finger f for that note.

00:17:11.760 --> 00:17:12.869
This will work.

00:17:12.869 --> 00:17:15.042
That's the one I had in mind.

00:17:15.042 --> 00:17:17.000
But the question becomes,
what should we guess?

00:17:21.329 --> 00:17:22.731
Anyone else?

00:17:22.731 --> 00:17:24.105
You clearly get
[? a pillow. ?] I

00:17:24.105 --> 00:17:25.985
don't know how many
you have by now.

00:17:25.985 --> 00:17:28.170
Have another one.

00:17:28.170 --> 00:17:28.950
That's tough.

00:17:28.950 --> 00:17:30.560
This is not easy to figure out.

00:17:33.377 --> 00:17:35.210
Now, given that that's
our sub-problem, what

00:17:35.210 --> 00:17:36.470
is the next thing to guess?

00:17:46.844 --> 00:17:47.773
Do you have an idea?

00:17:47.773 --> 00:17:49.314
AUDIENCE: I got an
idea to define it.

00:17:49.314 --> 00:17:51.445
Like either the next or
previous finger for the--

00:17:51.445 --> 00:17:53.070
PROFESSOR: The next
or previous finger.

00:17:53.070 --> 00:17:54.360
Well, I'm looking at suffixes.

00:17:54.360 --> 00:17:56.431
So I only care
about the next one.

00:17:56.431 --> 00:17:56.930
Yeah.

00:17:59.504 --> 00:18:01.170
I see what you mean
by next or previous.

00:18:01.170 --> 00:18:03.320
But what we mean
is note i plus 1,

00:18:03.320 --> 00:18:05.260
that's the next thing
we don't know about.

00:18:05.260 --> 00:18:08.540
So we're going to
guess finger-- we'll

00:18:08.540 --> 00:18:12.600
call it g-- for note i plus 1.

00:18:17.460 --> 00:18:19.750
And now magically,
this recurrence

00:18:19.750 --> 00:18:22.030
becomes easy to write.

00:18:22.030 --> 00:18:23.540
So it's almost the same thing.

00:18:28.090 --> 00:18:31.850
I wish I could just copy and
paste this over, but I can't.

00:18:31.850 --> 00:18:35.580
It's not a digital blackboard.

00:18:35.580 --> 00:18:36.830
Are there digital blackboards?

00:18:36.830 --> 00:18:39.080
That would be cool.

00:18:39.080 --> 00:18:41.140
Someone should make that.

00:18:41.140 --> 00:18:43.795
I don't know why switched from
open parens to square brackets,

00:18:43.795 --> 00:18:45.440
but I did.

00:18:45.440 --> 00:18:51.601
Then we have-- I think it's just
the obvious thing, if i plus 1

00:18:51.601 --> 00:18:52.100
g.

00:18:52.100 --> 00:18:55.010
Ahh, this is a
slightly wrong, though.

00:18:55.010 --> 00:18:57.050
It's a copy paste error.

00:18:57.050 --> 00:19:00.420
This should really
be DP of i comma

00:19:00.420 --> 00:19:03.020
f, because now sub-problem
consists of two things-- which

00:19:03.020 --> 00:19:07.260
suffix am I in, and what's
my finger for note I?

00:19:07.260 --> 00:19:11.290
And so when I call DP, I also
have to provide two arguments.

00:19:11.290 --> 00:19:16.250
It's going to be DP
of i plus 1 comma g.

00:19:16.250 --> 00:19:17.630
And then I'm looping over g.

00:19:17.630 --> 00:19:20.790
I'm trying all
possibilities for g.

00:19:24.920 --> 00:19:27.600
That's the recurrence.

00:19:27.600 --> 00:19:30.870
So if I want starting
with finger f on note i,

00:19:30.870 --> 00:19:32.870
how do I solve
the suffix from i?

00:19:32.870 --> 00:19:36.110
Well, I guess what
finger am I going

00:19:36.110 --> 00:19:39.120
to use for the very next note.

00:19:39.120 --> 00:19:42.650
Then I have to pay this
transition cost for f on i

00:19:42.650 --> 00:19:44.570
to g on i plus 1.

00:19:48.746 --> 00:19:50.670
Yeah, OK.

00:19:50.670 --> 00:19:53.430
So slightly, I'm cheating
the notation here.

00:19:53.430 --> 00:19:58.730
This probably should be
the note, what is note i,

00:19:58.730 --> 00:20:01.180
and this thing should be
what is note i plus 1.

00:20:04.320 --> 00:20:07.100
If you think of this d
function just being given

00:20:07.100 --> 00:20:09.180
notes, pitches that
you need to play,

00:20:09.180 --> 00:20:11.235
instead of indices
into the array.

00:20:11.235 --> 00:20:14.790
It doesn't really matter, but
that's how I defined it before.

00:20:14.790 --> 00:20:16.540
OK, so I have to pay
this transition cost.

00:20:16.540 --> 00:20:19.910
What does it take to make that
transition from i to i plus 1?

00:20:19.910 --> 00:20:24.480
And then what does it take to
do the rest of the notes, given

00:20:24.480 --> 00:20:29.320
that now my finger is-- or now
finger g is playing the note

00:20:29.320 --> 00:20:30.310
i plus 1?

00:20:30.310 --> 00:20:32.910
So we transition from
f to g, and that's now

00:20:32.910 --> 00:20:35.310
kept track of in
the sub-problem.

00:20:35.310 --> 00:20:37.640
This is the magic of
defining more sub-problem.

00:20:37.640 --> 00:20:39.830
We needed to know where
our finger used to be.

00:20:39.830 --> 00:20:42.280
And now we're telling it,
oh, your finger right now

00:20:42.280 --> 00:20:44.120
is finger f.

00:20:44.120 --> 00:20:46.372
Finger f is the one that's
currently playing the note.

00:20:46.372 --> 00:20:48.580
And then afterwards, g is
the finger that's currently

00:20:48.580 --> 00:20:50.960
playing the note, and we
can keep track of that.

00:20:50.960 --> 00:20:52.810
You could also define
this to say, oh,

00:20:52.810 --> 00:20:55.860
f was the finger that was
used for the previous note,

00:20:55.860 --> 00:20:56.940
note i minus 1.

00:20:56.940 --> 00:21:00.800
But it's just a shifting
of the indices here.

00:21:00.800 --> 00:21:04.730
You can do i minus 1 to i
instead of i to i plus 1.

00:21:04.730 --> 00:21:06.930
But this is, I think,
slightly cleaner.

00:21:09.550 --> 00:21:11.310
OK, and then we
have a DP, right?

00:21:11.310 --> 00:21:13.760
We've just memoized
that recurrence.

00:21:13.760 --> 00:21:16.324
We get a recursive DP, or
you could build it bottom up.

00:21:16.324 --> 00:21:17.740
If you were building
it bottom up,

00:21:17.740 --> 00:21:19.680
you'd want to know
a topological order.

00:21:22.650 --> 00:21:25.120
And this requires a
little bit of care

00:21:25.120 --> 00:21:26.860
because there's two parameters.

00:21:26.860 --> 00:21:28.290
And so it's going
to be a for loop

00:21:28.290 --> 00:21:30.480
over those two
parameters in some order.

00:21:30.480 --> 00:21:33.980
And I believe the
right order is for i

00:21:33.980 --> 00:21:37.230
has to go from right to left
because this is suffixes.

00:21:37.230 --> 00:21:46.260
So I would write reversed range
n python if there are n notes.

00:21:46.260 --> 00:21:49.260
And then within that loop, I
would do a for loop over f.

00:21:52.557 --> 00:21:54.390
If you reverse the order
of these for loops,

00:21:54.390 --> 00:21:57.450
it would not be in the right
order, I'm pretty sure.

00:21:57.450 --> 00:21:58.740
But this one will work.

00:21:58.740 --> 00:21:59.970
You can check it.

00:21:59.970 --> 00:22:07.130
And then to solve our
original problem, here

00:22:07.130 --> 00:22:13.480
we require a little
more work because none

00:22:13.480 --> 00:22:14.880
of these sub-problems
are what we

00:22:14.880 --> 00:22:19.899
want to solve because we don't
know what the first finger is.

00:22:19.899 --> 00:22:21.190
We know what the first note is.

00:22:21.190 --> 00:22:22.570
That's note 0.

00:22:22.570 --> 00:22:24.350
But what finger goes there?

00:22:24.350 --> 00:22:24.980
I don't know.

00:22:24.980 --> 00:22:30.780
And DP of 0 requires
us to give it a finger.

00:22:30.780 --> 00:22:32.650
Give it the finger, ha.

00:22:32.650 --> 00:22:36.990
Give it the finger for
whatever is the first note.

00:22:36.990 --> 00:22:38.250
So this is pretty easy though.

00:22:38.250 --> 00:22:40.505
We just take a min
over those choices.

00:22:43.390 --> 00:22:44.995
Which finger should we give it?

00:22:53.100 --> 00:22:54.200
That should do it.

00:22:54.200 --> 00:22:56.070
So we don't know what
finger to start with.

00:22:56.070 --> 00:22:58.140
Just try them all, take the min.

00:22:58.140 --> 00:23:00.710
This is just like the
guessing that we did here,

00:23:00.710 --> 00:23:02.840
just a slightly simpler version.

00:23:02.840 --> 00:23:05.245
There's no transition cost
because there's no transition.

00:23:05.245 --> 00:23:06.882
We weren't anywhere before.

00:23:06.882 --> 00:23:08.340
Just what finger
do you start with?

00:23:08.340 --> 00:23:09.923
I don't care what
finger I start with.

00:23:09.923 --> 00:23:13.730
It's how I transition from one
note to the next that's hard.

00:23:13.730 --> 00:23:17.030
OK, done.

00:23:17.030 --> 00:23:17.815
That's the DP.

00:23:17.815 --> 00:23:21.330
Now, if this is not
obvious or not clear,

00:23:21.330 --> 00:23:26.470
I think it's easier to think
about it in the DAG form.

00:23:26.470 --> 00:23:28.390
So let's draw all
the sub problems.

00:23:28.390 --> 00:23:32.110
We have here a two dimensional
matrix of sub-problems.

00:23:32.110 --> 00:23:35.260
We have the different
suffixes on the one hand.

00:23:35.260 --> 00:23:41.230
So this is it, it stats
a 9, goes to n minus 1.

00:23:41.230 --> 00:23:43.110
And then in the
other dimension, we

00:23:43.110 --> 00:23:49.020
have what finger
to use from 1 to f.

00:23:49.020 --> 00:23:51.654
And so in each of these
positions, there a note.

00:23:51.654 --> 00:23:52.570
There's a sub-problem.

00:23:59.526 --> 00:24:00.025
Race.

00:24:04.840 --> 00:24:07.730
I wanted to get five rows
because there are five fingers.

00:24:07.730 --> 00:24:09.940
And then our
transitions basically

00:24:09.940 --> 00:24:13.360
look-- if we're at
finger one on this note,

00:24:13.360 --> 00:24:16.040
we can go to finger
one on the next note.

00:24:16.040 --> 00:24:17.940
Or we can go, if
we're not legato,

00:24:17.940 --> 00:24:19.910
or we can go to finger
two on the next note,

00:24:19.910 --> 00:24:22.870
or finger three or finger
four or finger five.

00:24:22.870 --> 00:24:25.367
And then if we're
starting with finger two,

00:24:25.367 --> 00:24:26.700
we could go to any one of these.

00:24:26.700 --> 00:24:30.270
So you get a complete
bipartite graph,

00:24:30.270 --> 00:24:33.670
which you usually
draw like this.

00:24:33.670 --> 00:24:38.398
That is how graph theorists
draw complete bipartite graphs.

00:24:38.398 --> 00:24:40.750
OK, but I tried to draw a
little more explicitly here.

00:24:40.750 --> 00:24:42.220
It's just any
possible transition.

00:24:42.220 --> 00:24:43.870
And for each of
these, the point is

00:24:43.870 --> 00:24:45.817
you can compute the
D cost, because you

00:24:45.817 --> 00:24:47.210
know what figure you were at.

00:24:47.210 --> 00:24:49.674
You know what finger
you are going to

00:24:49.674 --> 00:24:51.090
and what note
you're starting from

00:24:51.090 --> 00:24:52.780
and what note you're going to.

00:24:52.780 --> 00:24:55.580
Those are the four
arguments you need for D.

00:24:55.580 --> 00:24:57.370
So you put those
weights on, and then

00:24:57.370 --> 00:25:00.480
you solve shortest
paths on this DAG.

00:25:00.480 --> 00:25:06.350
And that is exactly what
this DP is doing, OK?

00:25:06.350 --> 00:25:08.590
Except there's no
single source here,

00:25:08.590 --> 00:25:09.950
which is kind of annoying.

00:25:09.950 --> 00:25:12.691
And so you need to take
this min over what's

00:25:12.691 --> 00:25:14.690
the shortest path from
here, what's the shortest

00:25:14.690 --> 00:25:16.754
path from here, from here,
from here, from here.

00:25:16.754 --> 00:25:18.170
Of course, you
don't actually need

00:25:18.170 --> 00:25:23.830
to do that by running single
source shortest paths f times.

00:25:23.830 --> 00:25:26.660
If you're a clever
shortest paths person,

00:25:26.660 --> 00:25:29.190
you would add an extra
source note, connect

00:25:29.190 --> 00:25:35.460
that with 0 weight to
all of these sources.

00:25:35.460 --> 00:25:38.090
So put 0s on there.

00:25:38.090 --> 00:25:40.650
And then do single
shortest paths from here.

00:25:40.650 --> 00:25:42.040
And you will find the best way.

00:25:42.040 --> 00:25:43.706
You don't really care
where you started,

00:25:43.706 --> 00:25:45.660
so this is trying
all the options.

00:25:45.660 --> 00:25:47.754
That's exactly what
we're doing here.

00:25:47.754 --> 00:25:49.920
But here I'm doing it with
the shortest paths trick,

00:25:49.920 --> 00:25:56.030
here I'm doing it with guessing
and taking a min like DP style.

00:25:56.030 --> 00:26:01.560
OK, so that's how to do
piano figuring and guitar

00:26:01.560 --> 00:26:04.660
fingering for single
hand, one note at time.

00:26:04.660 --> 00:26:05.799
Questions?

00:26:05.799 --> 00:26:07.340
And this even worse
for aliens if you

00:26:07.340 --> 00:26:09.570
have arbitrarily many
fingers on your hand.

00:26:09.570 --> 00:26:13.130
I guess we should figure
out what's the running time.

00:26:13.130 --> 00:26:15.670
So we have sub-problems.

00:26:15.670 --> 00:26:17.920
We see how many
sub-problems there are here.

00:26:17.920 --> 00:26:22.000
There's n times f sub-problems.

00:26:22.000 --> 00:26:24.810
How much time, or how
many choices are there

00:26:24.810 --> 00:26:26.160
for our guess?

00:26:26.160 --> 00:26:31.800
Well there's f different
choices for what finger we use.

00:26:31.800 --> 00:26:35.640
And when we do this min,
we spend theta F time.

00:26:40.710 --> 00:26:42.220
Because there's a
for loop over F,

00:26:42.220 --> 00:26:43.636
we're doing constant
work assuming

00:26:43.636 --> 00:26:45.760
D lookups take constant time.

00:26:45.760 --> 00:26:46.800
This is theta F time.

00:26:46.800 --> 00:26:49.520
So we multiply those
two things together,

00:26:49.520 --> 00:26:53.570
and we get the total time, the
number of sub-problems which

00:26:53.570 --> 00:26:56.320
is n times F, and
we multiply them

00:26:56.320 --> 00:26:58.840
by theta F for each sub-problem.

00:26:58.840 --> 00:27:02.510
So this is nF squared.

00:27:02.510 --> 00:27:09.100
And given F is usually pretty
small, it's almost linear time.

00:27:09.100 --> 00:27:10.530
So that's a pretty
good algorithm.

00:27:18.460 --> 00:27:22.202
But in reality, you tend
to play multiple notes

00:27:22.202 --> 00:27:22.910
at the same time.

00:27:26.035 --> 00:27:29.270
In music, typically
you're playing a chord.

00:27:29.270 --> 00:27:33.550
With piano, you're
playing several notes

00:27:33.550 --> 00:27:36.840
with one hand, maybe several
notes with another hand.

00:27:36.840 --> 00:27:38.360
Two handed piano, it's crazy.

00:27:38.360 --> 00:27:41.000
You could do four handed piano,
make it a little more exciting.

00:27:41.000 --> 00:27:44.393
With the guitar, play-- I
don't know very many chords,

00:27:44.393 --> 00:27:47.290
but I know at least one.

00:27:47.290 --> 00:27:49.000
You play, I don't know.

00:27:49.000 --> 00:27:52.115
This looks like something.

00:27:52.115 --> 00:27:53.702
That's a G chord.

00:27:53.702 --> 00:27:56.700
Do I know any others?

00:27:56.700 --> 00:27:59.499
And that's an E chord.

00:27:59.499 --> 00:28:03.585
All right, you get the idea.

00:28:03.585 --> 00:28:04.960
I mean, for each
of these chords,

00:28:04.960 --> 00:28:06.260
different people use
different fingers,

00:28:06.260 --> 00:28:07.260
even for a single cord.

00:28:07.260 --> 00:28:09.010
So it's sort of a
personal taste how

00:28:09.010 --> 00:28:11.490
you're going to define
your difficulty measure.

00:28:11.490 --> 00:28:15.150
But I could play an E like
this, or I could-- I don't know,

00:28:15.150 --> 00:28:17.040
play it like this.

00:28:17.040 --> 00:28:21.180
Or I could play like this.

00:28:21.180 --> 00:28:24.100
And there's lots of crazy
ways to put your finger here

00:28:24.100 --> 00:28:26.120
and your finger here
and your finger here.

00:28:26.120 --> 00:28:28.480
And for each of them, you
could define some difficulty.

00:28:28.480 --> 00:28:29.979
And then, of course,
is a transition

00:28:29.979 --> 00:28:31.530
from one chord to another.

00:28:31.530 --> 00:28:33.290
And because there's different
ways to play different chords,

00:28:33.290 --> 00:28:35.290
that wasn't a very good
example because they all

00:28:35.290 --> 00:28:37.730
look pretty bad.

00:28:37.730 --> 00:28:41.320
Well, this one for example,
this is the G again.

00:28:41.320 --> 00:28:45.630
I could use my-- one, two,
three, four-- fourth finger

00:28:45.630 --> 00:28:48.645
here, or I could
use my fifth finger.

00:28:48.645 --> 00:28:51.020
My instructor says we should
use our pinky because people

00:28:51.020 --> 00:28:52.186
tend not to use their pinky.

00:28:52.186 --> 00:28:53.834
But it makes a
difference what I'm

00:28:53.834 --> 00:28:55.000
going to transition to next.

00:28:55.000 --> 00:28:56.999
Maybe my pinky really
needs to go over here next

00:28:56.999 --> 00:28:58.480
and I should free
it up for later,

00:28:58.480 --> 00:29:01.060
or maybe it's better if this
one's freed because then I

00:29:01.060 --> 00:29:02.620
can move it somewhere else.

00:29:02.620 --> 00:29:04.640
So that's what we'd
like to capture

00:29:04.640 --> 00:29:07.010
in a generalized form
or this dynamic program,

00:29:07.010 --> 00:29:08.980
and we can do it.

00:29:08.980 --> 00:29:12.360
So I'll try to do
it quickly so we

00:29:12.360 --> 00:29:14.320
can get on to the
other examples.

00:29:14.320 --> 00:29:16.142
All right, other fun stuff.

00:29:16.142 --> 00:29:17.600
Actually, there's
another fun thing

00:29:17.600 --> 00:29:20.310
with guitar, which
is that there's

00:29:20.310 --> 00:29:22.740
more than one way
to play each note.

00:29:22.740 --> 00:29:24.330
There are six strings here.

00:29:24.330 --> 00:29:29.530
And you could play like this
note for the Super Mario

00:29:29.530 --> 00:29:30.460
Brothers.

00:29:30.460 --> 00:29:34.720
I could also play that
doing the fifth thing here.

00:29:34.720 --> 00:29:39.970
It's slightly out of tune, but
those sound almost the same.

00:29:39.970 --> 00:29:44.850
Or I could play on the 10th
fret on the third string.

00:29:44.850 --> 00:29:46.300
That's the same as bottom one.

00:29:46.300 --> 00:29:50.710
So a lot of options, so you
also like to capture that.

00:29:50.710 --> 00:29:52.260
This is actually not too hard.

00:29:52.260 --> 00:30:02.000
You just need to generalize
the notion of finger

00:30:02.000 --> 00:30:07.570
to what finger you're using
and what string you're using.

00:30:07.570 --> 00:30:10.744
So there are f different choices
for what finger you're using.

00:30:10.744 --> 00:30:12.410
If you use a generalized
guitar, there's

00:30:12.410 --> 00:30:14.145
s choices for what
string you're playing.

00:30:14.145 --> 00:30:16.436
There's a lot of different
guitars with various numbers

00:30:16.436 --> 00:30:18.451
of strings, so we can
just generalize that.

00:30:18.451 --> 00:30:20.700
And now it's not only, which
finger am I going to use,

00:30:20.700 --> 00:30:22.220
but what sting
will I play it on?

00:30:22.220 --> 00:30:26.390
And then you can still
define a difficulty measure

00:30:26.390 --> 00:30:29.704
like this for this
set up, depending

00:30:29.704 --> 00:30:31.120
both on the finger
and the string.

00:30:31.120 --> 00:30:34.890
And then the running
time grows slightly.

00:30:34.890 --> 00:30:39.320
It's now n times F
squared S squared,

00:30:39.320 --> 00:30:41.760
because now I have to take
the product of F and S. OK,

00:30:41.760 --> 00:30:42.950
so that's first thing.

00:30:42.950 --> 00:30:50.990
But then if I wanted
to do multiple notes,

00:30:50.990 --> 00:30:54.390
well, you can imagine it's
a similar type of deal.

00:30:54.390 --> 00:30:56.992
It's going to get harder though.

00:30:56.992 --> 00:30:58.950
First thing we need to
generalize is the input.

00:30:58.950 --> 00:31:02.190
Before the input was
a sequence of notes.

00:31:02.190 --> 00:31:05.780
Now it's going to be a
sequence of multi-notes.

00:31:05.780 --> 00:31:11.110
So notes of i is now
going to be, let's say,

00:31:11.110 --> 00:31:16.400
a list of notes that all
need to be played at once.

00:31:16.400 --> 00:31:19.330
And conveniently, it's probably
going to be, at most, F notes,

00:31:19.330 --> 00:31:23.260
because you really can only
play one note with each finger

00:31:23.260 --> 00:31:24.110
pretty much.

00:31:24.110 --> 00:31:26.220
I guess you could try to
play two notes at once

00:31:26.220 --> 00:31:28.477
on a piano with
a finger, but eh.

00:31:28.477 --> 00:31:29.310
It sounds difficult.

00:31:29.310 --> 00:31:33.980
For a guitar, it's
at most s notes.

00:31:33.980 --> 00:31:38.330
You can only play one note
per string, more or less.

00:31:38.330 --> 00:31:42.660
So that's our input.

00:31:42.660 --> 00:31:45.550
And now we need to adjust
the dynamic program.

00:31:49.910 --> 00:31:52.240
And I think I'll tell
you how to do this.

00:32:24.410 --> 00:32:26.870
Basically, now you need to know
where all your fingers are.

00:32:26.870 --> 00:32:31.140
So you go from one
pose to another pose,

00:32:31.140 --> 00:32:32.760
from one chord to another.

00:32:32.760 --> 00:32:34.062
Different ways to finger that.

00:32:34.062 --> 00:32:35.520
Which fingers are
and which strings

00:32:35.520 --> 00:32:39.040
and which frets on the
guitar, which fingers

00:32:39.040 --> 00:32:41.220
are on which keys
on the keyboard.

00:32:41.220 --> 00:32:43.140
But you just need
to know all that.

00:32:43.140 --> 00:32:46.540
And all your fingers
might be doing something,

00:32:46.540 --> 00:32:49.080
and you've got to know for
each finger what note is it on,

00:32:49.080 --> 00:32:51.290
or is it not being used at all.

00:32:51.290 --> 00:32:54.370
So how many different ways to
do such a mapping are there?

00:32:54.370 --> 00:32:56.240
I mean, this is just a function.

00:32:56.240 --> 00:32:59.250
So it's the number of
targets of the function.

00:32:59.250 --> 00:33:03.110
So how many of these are there.

00:33:03.110 --> 00:33:06.880
Gosh, well, I guess we said
there are, at most, f notes.

00:33:06.880 --> 00:33:12.530
So f plus 1 is the maximum
number of possible things

00:33:12.530 --> 00:33:13.660
each finger can do.

00:33:13.660 --> 00:33:16.520
And we raise that to the power
of the number of fingers.

00:33:16.520 --> 00:33:19.470
That's the possible mappings
of what all of my fingers

00:33:19.470 --> 00:33:20.375
could be doing.

00:33:20.375 --> 00:33:22.300
It's exponential
in f, not so great.

00:33:22.300 --> 00:33:25.140
But if f is 5, it's all right.

00:33:25.140 --> 00:33:28.050
And then-- well, then you
just generalize the rest.

00:33:28.050 --> 00:33:30.890
I don't think I'll
write it down in detail.

00:33:30.890 --> 00:33:33.030
But our sub-problems
now are going

00:33:33.030 --> 00:33:37.000
to be-- let me
switch boards here.

00:33:40.700 --> 00:33:46.130
How do we play these
multi-notes from i onwards,

00:33:46.130 --> 00:33:48.930
given that we're going to
use that pose-- or I called

00:33:48.930 --> 00:33:54.540
it the state of all my fingers--
for the first notes of i

00:33:54.540 --> 00:33:56.160
is now a whole bunch of notes.

00:33:56.160 --> 00:33:57.909
So given I'm now going
to play those notes

00:33:57.909 --> 00:34:01.910
with this particular
finger assignment,

00:34:01.910 --> 00:34:04.280
how do I play the rest?

00:34:04.280 --> 00:34:07.560
And then what we'll guess is
the entire finger assignment

00:34:07.560 --> 00:34:09.630
for the next set of
notes, i plus 1--

00:34:09.630 --> 00:34:11.929
the next chord, if you will.

00:34:11.929 --> 00:34:17.071
And that guessing involves
now F plus 1 to the F time.

00:34:17.071 --> 00:34:19.320
And then we just write the
recurrence in the same way.

00:34:19.320 --> 00:34:22.480
So we're basically generalizing
here we call the finger,

00:34:22.480 --> 00:34:25.760
now it's an entire
pose for your hand.

00:34:25.760 --> 00:34:28.949
Instead of F, you might write
H for hand or something.

00:34:28.949 --> 00:34:31.969
And so the running
time in this situation

00:34:31.969 --> 00:34:36.630
is going to go up to something
like n times F of plus

00:34:36.630 --> 00:34:42.382
1 to the F. Did I miss anything?

00:34:42.382 --> 00:34:43.590
Probably have to square that.

00:34:46.270 --> 00:34:47.766
2F.

00:34:47.766 --> 00:34:49.140
Before it was F
squared, now it's

00:34:49.140 --> 00:34:51.360
just F plus 1 to the F squared.

00:34:51.360 --> 00:34:52.860
So if F is small,
this is all right.

00:34:52.860 --> 00:34:53.900
Otherwise, not so great.

00:34:53.900 --> 00:34:58.180
This is the best algorithm
I know for chord fingering.

00:34:58.180 --> 00:34:59.676
Questions?

00:34:59.676 --> 00:35:02.364
Just trying to
make it practical,

00:35:02.364 --> 00:35:03.530
solve the real life problem.

00:35:03.530 --> 00:35:05.000
I would love, I
think-- I don't know

00:35:05.000 --> 00:35:06.708
if this has been
implemented, but someone

00:35:06.708 --> 00:35:12.220
should implement this
in some-- I don't know,

00:35:12.220 --> 00:35:15.920
score program,
musical score program.

00:35:15.920 --> 00:35:17.864
I would love as
learning guitar, it'd

00:35:17.864 --> 00:35:20.280
be great for someone to just
tell me how to finger things.

00:35:20.280 --> 00:35:21.738
Then I can
retroactively figure out

00:35:21.738 --> 00:35:23.812
why using the dynamic program.

00:35:23.812 --> 00:35:25.270
All right, let's
move on to Tetris.

00:35:33.662 --> 00:35:35.870
All these problems are going
to have the same flavor.

00:35:35.870 --> 00:35:37.130
You can solve them
with basically

00:35:37.130 --> 00:35:38.171
the same dynamic program.

00:35:38.171 --> 00:35:41.900
It's all about figuring out
what should the sub-problems be.

00:35:41.900 --> 00:35:45.312
So let me-- does anyone
here not know Tetris?

00:35:45.312 --> 00:35:45.980
OK, good.

00:35:45.980 --> 00:35:47.595
No one's willing to admit it.

00:35:47.595 --> 00:35:49.170
So you've got these
blocks falling.

00:35:49.170 --> 00:35:53.640
But I'm going to make several
artificial constraints.

00:35:53.640 --> 00:35:56.426
First of all, I tell
you the entire sequence

00:35:56.426 --> 00:35:57.800
of pieces that
are going to come.

00:35:57.800 --> 00:35:59.220
This is more like
a Tetris puzzle.

00:36:02.320 --> 00:36:08.510
OK, we're given sequence
of n pieces that will fall.

00:36:08.510 --> 00:36:12.090
For each of them, we must
drop the piece from the top.

00:36:15.660 --> 00:36:18.900
OK, and if you're a
fancy Tetris player,

00:36:18.900 --> 00:36:21.500
you can let a piece fall and
then rotate it at very end

00:36:21.500 --> 00:36:23.610
to do some clever, clever thing.

00:36:23.610 --> 00:36:24.464
I disallow that.

00:36:24.464 --> 00:36:26.130
You always have to
push the drop button.

00:36:26.130 --> 00:36:29.330
So the piece starts here, it
goes instantly to the ground.

00:36:29.330 --> 00:36:30.400
This will be necessary.

00:36:30.400 --> 00:36:31.941
I don't know how to
solve the problem

00:36:31.941 --> 00:36:33.740
without this constraint.

00:36:33.740 --> 00:36:37.410
OK, and then the
other weird thing--

00:36:37.410 --> 00:36:41.710
this is very weird for Tetris--
full rows normally clear,

00:36:41.710 --> 00:36:44.880
but now they don't clear.

00:36:44.880 --> 00:36:46.700
This is like hardcore Tetris.

00:36:46.700 --> 00:36:48.640
You're guaranteed
to die eventually.

00:36:48.640 --> 00:36:53.287
The question is, can you
survive these n pieces?

00:36:53.287 --> 00:36:54.120
That's the question.

00:36:54.120 --> 00:36:54.786
Can you survive?

00:36:57.462 --> 00:36:59.310
Oh, I've got one
other constraint.

00:36:59.310 --> 00:37:02.240
This is actually
kind of natural.

00:37:02.240 --> 00:37:07.200
The width of the board is
small, relatively small,

00:37:07.200 --> 00:37:09.410
because we're going to
be exponential in w.

00:37:09.410 --> 00:37:12.137
In real life it's 12, I think?

00:37:12.137 --> 00:37:12.720
AUDIENCE: Ten.

00:37:12.720 --> 00:37:13.865
PROFESSOR: Ten, sorry.

00:37:13.865 --> 00:37:17.030
It's been a while since
I wrote my Tetris paper.

00:37:17.030 --> 00:37:20.070
So all right, these are all
kind of weird constraints.

00:37:20.070 --> 00:37:22.730
If you don't make all of
these constraints-- oh,

00:37:22.730 --> 00:37:25.110
also the board is
initially empty.

00:37:25.110 --> 00:37:26.770
That's like level one of Tetris.

00:37:34.170 --> 00:37:36.460
If all of these things
are not the case, which

00:37:36.460 --> 00:37:39.314
is regular Tetris, if you
just have the first thing

00:37:39.314 --> 00:37:40.980
then this problem is
called NP-complete.

00:37:40.980 --> 00:37:42.730
We'll be defining
that next class.

00:37:42.730 --> 00:37:45.562
So it's computationally
intractable.

00:37:45.562 --> 00:37:47.270
But if you make all
of these assumptions,

00:37:47.270 --> 00:37:49.940
the problem becomes
easy, and you

00:37:49.940 --> 00:37:53.260
can do it by
dynamic programming.

00:37:53.260 --> 00:37:57.240
So how do we do it?

00:37:57.240 --> 00:38:00.490
We define sub-problems
just like before.

00:38:00.490 --> 00:38:02.080
The obvious thing
to try is suffixes.

00:38:07.230 --> 00:38:13.900
How do we play a suffix
of pieces i onwards?

00:38:13.900 --> 00:38:18.330
How to play those guys.

00:38:18.330 --> 00:38:23.600
And just like fingering, this is
not enough information, right?

00:38:23.600 --> 00:38:26.130
Because if we're going to play
from pieces i onward, what

00:38:26.130 --> 00:38:28.410
we need to now is what the
board currently looks like.

00:38:28.410 --> 00:38:30.312
I said here the board
is initially empty.

00:38:30.312 --> 00:38:32.020
That's not going to
be the case after you

00:38:32.020 --> 00:38:33.672
place the very first piece.

00:38:33.672 --> 00:38:35.880
So in general, after we've
placed the first i pieces,

00:38:35.880 --> 00:38:38.972
we need to know what
the board looks like.

00:38:38.972 --> 00:38:41.430
And here's where I'm going to
use all of these assumptions.

00:38:41.430 --> 00:38:46.380
If you always drop things from
the top and rows don't clear,

00:38:46.380 --> 00:38:51.455
then all you really care about
is how high each column is.

00:38:51.455 --> 00:38:54.980
This is what you might call
the skyline of the board.

00:38:58.140 --> 00:39:02.220
OK, now in reality,
there might be holes here

00:39:02.220 --> 00:39:03.885
because you drop
things in silly ways.

00:39:03.885 --> 00:39:07.030
Maybe you drop a
piece like this.

00:39:07.030 --> 00:39:09.090
And then I claim, because
I'm dropping things

00:39:09.090 --> 00:39:12.339
from infinity from
the sky, I really

00:39:12.339 --> 00:39:14.130
don't care about that
there's a whole here.

00:39:14.130 --> 00:39:17.150
I can just fill that in and
say, OK, that's my new skyline.

00:39:17.150 --> 00:39:19.300
Because if you can't do
these last minute twists

00:39:19.300 --> 00:39:22.580
and if lines never clear,
that's going to be gone.

00:39:22.580 --> 00:39:25.380
That material is wasted.

00:39:25.380 --> 00:39:30.630
OK, so all I need to remember
is how high is each column.

00:39:30.630 --> 00:39:38.882
So I should say given
the board skyline.

00:39:38.882 --> 00:39:40.590
Now, how many choices
are there for that?

00:39:40.590 --> 00:39:45.220
It's quite similar to this
function, the fingering.

00:39:45.220 --> 00:39:45.720
Let's see.

00:39:45.720 --> 00:39:48.970
There's the height of the
board, different choices.

00:39:48.970 --> 00:39:50.892
It's going to be h.

00:39:50.892 --> 00:39:53.100
For each column it could be
anywhere between 0 and h,

00:39:53.100 --> 00:39:56.090
so I guess h plus 1 if
you want to get technical.

00:39:56.090 --> 00:39:57.840
And then we raise
it to the power w,

00:39:57.840 --> 00:40:00.860
because there's w different
columns and each of them

00:40:00.860 --> 00:40:03.697
is independent choice.

00:40:03.697 --> 00:40:06.030
So this is going to n times
that different sub-problems.

00:40:10.870 --> 00:40:12.850
And here's what I
need the is small

00:40:12.850 --> 00:40:14.330
because this is
exponential in w.

00:40:14.330 --> 00:40:18.780
So it's reasonable in
h, but exponential in w.

00:40:18.780 --> 00:40:21.880
OK, then what do I guess?

00:40:21.880 --> 00:40:23.265
Any suggestions what to guess?

00:40:38.380 --> 00:40:43.184
AUDIENCE: So where the new
piece falls, as in [INAUDIBLE]?

00:40:43.184 --> 00:40:43.850
PROFESSOR: Yeah.

00:40:43.850 --> 00:40:46.530
What should I do with piece i?

00:40:46.530 --> 00:40:47.980
There's not that many choices.

00:40:47.980 --> 00:40:51.640
I can rotate it zero,
one, two, or three times.

00:40:51.640 --> 00:40:53.170
I can choose
someplace to drop it,

00:40:53.170 --> 00:40:55.456
but those are my only choices.

00:40:55.456 --> 00:41:01.060
So it's just how
to play piece i.

00:41:01.060 --> 00:41:02.870
And given that guess,
you can figure out

00:41:02.870 --> 00:41:05.900
how the skyline updates,
like I did here.

00:41:05.900 --> 00:41:08.730
If I drop that piece like
that, then I fill in this part

00:41:08.730 --> 00:41:09.965
and recompute my new skyline.

00:41:12.590 --> 00:41:14.120
So it's going to
be something like 4

00:41:14.120 --> 00:41:19.705
times w different choices,
roughly-- 4 for the rotation,

00:41:19.705 --> 00:41:20.663
w for the x-coordinate.

00:41:23.170 --> 00:41:24.840
And so the running
time is just going

00:41:24.840 --> 00:41:26.010
to be the product of these.

00:41:42.220 --> 00:41:49.030
n times w times h
plus 1 to the w.

00:41:49.030 --> 00:41:53.810
Open problem, if I drop any
one of these assumptions,

00:41:53.810 --> 00:41:56.400
can you get a dynamic
program that's reasonable?

00:41:56.400 --> 00:41:58.040
Could you do it if w is large?

00:41:58.040 --> 00:41:58.955
I don't know.

00:41:58.955 --> 00:42:02.220
Could you do if rows do clear?

00:42:02.220 --> 00:42:04.779
That's the least
natural constraint here.

00:42:04.779 --> 00:42:05.320
I don't know.

00:42:07.850 --> 00:42:09.330
Puzzle for you to think about.

00:42:09.330 --> 00:42:10.496
I'd love to know the answer.

00:42:16.780 --> 00:42:19.004
You can obviously do the
rest of the steps, right?

00:42:19.004 --> 00:42:20.420
You can write down
the recurrence.

00:42:20.420 --> 00:42:21.253
It's the same thing.

00:42:21.253 --> 00:42:23.850
You take the min
over all guesses.

00:42:23.850 --> 00:42:25.080
What are we minimizing?

00:42:25.080 --> 00:42:25.710
Hmm.

00:42:25.710 --> 00:42:29.700
I guess here the
question is survival.

00:42:29.700 --> 00:42:31.580
Can you survive?

00:42:31.580 --> 00:42:34.270
So this is one of the first
examples where the answer is

00:42:34.270 --> 00:42:37.470
a Boolean value, true or false.

00:42:37.470 --> 00:42:40.050
But if you think of true
or false as 0 and 1,

00:42:40.050 --> 00:42:43.086
then it's still a
maximization problem.

00:42:43.086 --> 00:42:43.960
You want to maximize.

00:42:43.960 --> 00:42:45.120
You want 1 if possible.

00:42:45.120 --> 00:42:47.630
Otherwise, you'll get
0 when you maximize.

00:42:47.630 --> 00:42:50.320
So you can write the
recurrence using max.

00:42:50.320 --> 00:42:53.880
And in the base case, you have
truth values, true or false.

00:42:53.880 --> 00:42:55.530
And you'll see, did I survive?

00:42:55.530 --> 00:42:56.980
Did I die?

00:42:56.980 --> 00:42:58.860
That sort of thing.

00:42:58.860 --> 00:43:00.707
I want to go on to
Super Mario Brothers,

00:43:00.707 --> 00:43:02.540
because everyone loves
Super Mario Brothers.

00:43:10.091 --> 00:43:10.590
has?

00:43:10.590 --> 00:43:14.010
Anyone not played NES
Super Mario Brothers 1?

00:43:14.010 --> 00:43:17.315
Aww, you got to play it, man.

00:43:17.315 --> 00:43:19.080
You're the only one.

00:43:19.080 --> 00:43:20.980
You can play it on an emulator.

00:43:20.980 --> 00:43:23.700
Maybe not legally, but you
can play it on an emulator

00:43:23.700 --> 00:43:27.430
and just see how it is.

00:43:27.430 --> 00:43:29.520
So what I'm going
to talk about next,

00:43:29.520 --> 00:43:31.900
in theory, works for many
different platform games,

00:43:31.900 --> 00:43:34.320
side-scrolling platform games.

00:43:34.320 --> 00:43:39.140
But Super Mario Brothers
1 has some nice features.

00:43:39.140 --> 00:43:41.840
In particular, a nice feature
is that whenever anything

00:43:41.840 --> 00:43:46.460
moves off of the screen, it
disappears from the world.

00:43:46.460 --> 00:43:48.190
So the monster moves
off, it's gone.

00:43:51.410 --> 00:43:53.560
You can think of there's
a static level there.

00:43:53.560 --> 00:43:56.140
When the level comes into
screen, when a monster comes

00:43:56.140 --> 00:43:58.389
on screen, then
it starts acting.

00:43:58.389 --> 00:44:00.680
But as soon as you move the
screen-- you can't actually

00:44:00.680 --> 00:44:02.513
move backwards in Super
Mario 1, but as soon

00:44:02.513 --> 00:44:05.570
as you move forwards and
that character is offscreen,

00:44:05.570 --> 00:44:06.630
it's gone.

00:44:06.630 --> 00:44:08.171
So in a sense, that
part of the level

00:44:08.171 --> 00:44:09.560
reset to its initial state.

00:44:09.560 --> 00:44:12.960
Now, as long as your screen is
not too big-- and thankfully,

00:44:12.960 --> 00:44:14.700
on NES screens
were not very big.

00:44:14.700 --> 00:44:18.030
It's 320p, or whatever.

00:44:18.030 --> 00:44:21.270
This will work.

00:44:21.270 --> 00:44:27.430
If you are given
the entire level--

00:44:27.430 --> 00:44:30.900
so let's say there's n
bits of information there--

00:44:30.900 --> 00:44:38.000
and you have a small screen,
w by h screen, w and h

00:44:38.000 --> 00:44:39.580
are not too big.

00:44:39.580 --> 00:44:42.100
Then I claim we can
solve Super Mario

00:44:42.100 --> 00:44:43.440
Brothers by dynamic programming.

00:44:43.440 --> 00:44:46.101
So let's say we want
to maximize our score.

00:44:46.101 --> 00:44:48.350
Want to run through the level
and maximize your score,

00:44:48.350 --> 00:44:50.160
or you want to minimize
the amount of time you use.

00:44:50.160 --> 00:44:51.230
You're doing level runs.

00:44:51.230 --> 00:44:54.515
Pick your favorite measure,
all of those can be solved.

00:44:54.515 --> 00:44:56.640
And the way to do it, this
sort of general approach

00:44:56.640 --> 00:44:58.840
to all these DPs is
we need to write down

00:44:58.840 --> 00:45:01.325
what do I need to know
about the game state.

00:45:01.325 --> 00:45:02.616
I'll call that a configuration.

00:45:05.780 --> 00:45:07.780
What can we care about
for Super Mario Brothers?

00:45:07.780 --> 00:45:13.190
Well, I guess
everything on screen.

00:45:17.280 --> 00:45:20.629
This is a bit tricky, but
there's stuff on screen.

00:45:20.629 --> 00:45:21.920
There are monsters and objects.

00:45:21.920 --> 00:45:24.253
For the monsters, I need to
know their current position.

00:45:24.253 --> 00:45:26.292
For the objects, I
need to know-- like,

00:45:26.292 --> 00:45:27.500
is there a question mark box?

00:45:27.500 --> 00:45:28.910
Did I hit it already?

00:45:28.910 --> 00:45:31.880
Did I already get the coin or
did I already get the mushroom?

00:45:31.880 --> 00:45:33.910
So for each of those
things, there's

00:45:33.910 --> 00:45:35.940
some amount of information
you need to store.

00:45:35.940 --> 00:45:38.980
How much information?

00:45:38.980 --> 00:45:45.000
I think something like constant
to the w times h should do.

00:45:45.000 --> 00:45:47.084
That's saying for every
pixel on the screen

00:45:47.084 --> 00:45:48.500
or for every square
on the screen,

00:45:48.500 --> 00:45:50.790
however you-- whatever you
define the resolution here

00:45:50.790 --> 00:45:51.290
to be.

00:45:51.290 --> 00:45:54.800
Let's say for every little
unit square in Mario land,

00:45:54.800 --> 00:45:56.750
is it a brick?

00:45:56.750 --> 00:46:01.640
Is it a hard brick, or has
it been a destroyed brick?

00:46:01.640 --> 00:46:03.490
Is a monster there right now?

00:46:03.490 --> 00:46:04.850
Is Mario there right now?

00:46:04.850 --> 00:46:07.300
All these kinds of information.

00:46:07.300 --> 00:46:10.580
OK, so there's a cost number
of choices for each pixel.

00:46:10.580 --> 00:46:12.340
You can write them all down.

00:46:12.340 --> 00:46:16.880
You might also want
Mario's velocity.

00:46:16.880 --> 00:46:18.860
I had to play it
again just to check

00:46:18.860 --> 00:46:20.400
that there is indeed velocity.

00:46:20.400 --> 00:46:23.260
Turning around is slower
than going forward.

00:46:23.260 --> 00:46:24.700
You do accelerate a little bit.

00:46:24.700 --> 00:46:25.790
So you've got to remember that.

00:46:25.790 --> 00:46:27.415
There's probably only
a constant number

00:46:27.415 --> 00:46:30.840
of choices for what
your velocity is.

00:46:30.840 --> 00:46:33.408
What else?

00:46:33.408 --> 00:46:36.710
Ah, I want to
remember the score.

00:46:36.710 --> 00:46:38.120
You want to maximize score.

00:46:38.120 --> 00:46:40.577
And let's say you also--
how much time is left.

00:46:40.577 --> 00:46:41.535
There's a time counter.

00:46:41.535 --> 00:46:43.510
If it hits zero, you die.

00:46:43.510 --> 00:46:46.460
Now, these are kind of annoying,
because they're integers.

00:46:46.460 --> 00:46:48.300
They could be kind of large.

00:46:48.300 --> 00:46:51.010
So I'm going to say the
score could be capital S big,

00:46:51.010 --> 00:46:53.510
and time could be capital T big.

00:46:53.510 --> 00:46:56.720
So this'll be a
pseudopolynomial algorithm.

00:46:56.720 --> 00:46:58.520
The number of
configurations in total

00:46:58.520 --> 00:47:00.320
here is the product
of these things.

00:47:00.320 --> 00:47:03.980
It's exponential in w and h.

00:47:03.980 --> 00:47:09.420
And then multiply by
S and T. So that's

00:47:09.420 --> 00:47:11.390
the number of configurations.

00:47:11.390 --> 00:47:13.500
And that's also going
to be our sub-problem.

00:47:13.500 --> 00:47:15.910
I guess we should
also write down

00:47:15.910 --> 00:47:21.310
where is the screen
relative to the level.

00:47:21.310 --> 00:47:24.270
OK, how far to the
right have you gone?

00:47:24.270 --> 00:47:25.420
That's another w.

00:47:28.710 --> 00:47:30.030
That's not a big deal.

00:47:30.030 --> 00:47:32.270
OK, given this information,
you know everything

00:47:32.270 --> 00:47:35.580
you need to know about
playing from here on.

00:47:35.580 --> 00:47:38.140
And the time counter's
always going to keep ticking.

00:47:38.140 --> 00:47:41.190
So you can draw a graph
of all configurations,

00:47:41.190 --> 00:47:42.800
just enumerate all
of these things.

00:47:42.800 --> 00:47:44.550
It's this many of them.

00:47:44.550 --> 00:47:47.240
And then draw, for
every configuration,

00:47:47.240 --> 00:47:48.960
what are the possible
things I can do?

00:47:48.960 --> 00:47:50.040
I could push this button.

00:47:50.040 --> 00:47:52.080
I can push the A button, I
can release the A button.

00:47:52.080 --> 00:47:54.246
I can push the B button, I
can release the B button.

00:47:54.246 --> 00:47:55.487
I can push the up arrow.

00:47:55.487 --> 00:47:57.070
Those are all the
things you could do.

00:47:57.070 --> 00:47:58.820
It's a constant
number of choices.

00:47:58.820 --> 00:48:01.500
So each vertex will have
constant out degree.

00:48:01.500 --> 00:48:04.335
If you did this, what
configuration would I reach?

00:48:04.335 --> 00:48:05.620
Just draw that whole graph.

00:48:05.620 --> 00:48:07.840
Do shortest paths.

00:48:07.840 --> 00:48:11.626
Or dynamic programming,
these are your sub-problems.

00:48:11.626 --> 00:48:12.750
There are no suffixes here.

00:48:12.750 --> 00:48:14.760
These are your sub-problem.

00:48:14.760 --> 00:48:18.410
And then you take
a max, if you're

00:48:18.410 --> 00:48:20.910
trying to maximize score or max
if you're trying to maximize

00:48:20.910 --> 00:48:23.440
time, minimize the time you use.

00:48:23.440 --> 00:48:25.580
This is time remaining.

00:48:25.580 --> 00:48:27.229
And you can relate
each sub-problem

00:48:27.229 --> 00:48:29.020
to a constant number
of other sub-problems.

00:48:29.020 --> 00:48:30.436
So your running
time will be this,

00:48:30.436 --> 00:48:33.270
because you only pay constant
time per sub-problem.

00:48:33.270 --> 00:48:35.540
And now you can solve Super
Mario Brothers optimally,

00:48:35.540 --> 00:48:37.957
as long as your screen is
not too big and as long

00:48:37.957 --> 00:48:40.040
as your scores and times
don't get too big either,

00:48:40.040 --> 00:48:42.040
because we're only
pseudopolynomial with respect

00:48:42.040 --> 00:48:43.990
to S and T.

00:48:43.990 --> 00:48:46.700
Questions?

00:48:46.700 --> 00:48:47.200
All right.

00:48:47.200 --> 00:48:48.140
That's-- yeah?

00:48:48.140 --> 00:48:51.593
AUDIENCE: So are we
going to be trying

00:48:51.593 --> 00:48:56.059
to memoize all of these
possible configurations?

00:48:56.059 --> 00:48:57.850
PROFESSOR: If you do
the recursive version,

00:48:57.850 --> 00:49:00.820
you will end up memoizing all
of these configuration values.

00:49:00.820 --> 00:49:04.009
Well, anyone that's reachable
from the initial state.

00:49:04.009 --> 00:49:05.800
Some configurations
might not be reachable,

00:49:05.800 --> 00:49:08.090
but the ones that
are reachable you're

00:49:08.090 --> 00:49:09.380
going to start doing them.

00:49:09.380 --> 00:49:13.530
When you finish doing them,
you will memoize the result.