WEBVTT

00:00:00.090 --> 00:00:02.490
The following content is
provided under a Creative

00:00:02.490 --> 00:00:04.030
Commons license.

00:00:04.030 --> 00:00:06.330
Your support will help
MIT OpenCourseWare

00:00:06.330 --> 00:00:10.720
continue to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.320
To make a donation, or
view additional materials

00:00:13.320 --> 00:00:17.280
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.280 --> 00:00:18.450
at ocw.mit.edu.

00:00:25.494 --> 00:00:29.940
[MUSIC PLAYING]

00:00:55.630 --> 00:00:59.320
PROFESSOR: When we introduced
the discrete Fourier transform,

00:00:59.320 --> 00:01:04.390
one of the important aspects of
that transform that I stressed

00:01:04.390 --> 00:01:08.260
was the fact that the
discrete Fourier transform,

00:01:08.260 --> 00:01:11.800
as opposed to the
Fourier or z transform,

00:01:11.800 --> 00:01:16.180
actually has implications
in terms of implementing

00:01:16.180 --> 00:01:19.330
discrete time linear systems.

00:01:19.330 --> 00:01:25.540
I commented, or suggested,
that in fact, a linear system,

00:01:25.540 --> 00:01:31.000
or a digital filter could
be implemented explicitly

00:01:31.000 --> 00:01:35.110
by computing the discrete
Fourier transform of a unit

00:01:35.110 --> 00:01:38.560
sample response and
an input sequence,

00:01:38.560 --> 00:01:41.920
multiplying these transforms
together, and then computing

00:01:41.920 --> 00:01:46.300
the inverse discrete
Fourier transform.

00:01:46.300 --> 00:01:50.980
There is a very efficient
algorithm, in fact,

00:01:50.980 --> 00:01:54.710
for computing the discrete
Fourier transform.

00:01:54.710 --> 00:01:58.060
And so it will turn out, and
we won't see this right away,

00:01:58.060 --> 00:02:00.970
but we'll see it toward the
end of this set of lectures,

00:02:00.970 --> 00:02:02.830
it will turn out
that, in fact, that's

00:02:02.830 --> 00:02:08.110
a very efficient way, often
of implementing a convolution

00:02:08.110 --> 00:02:11.660
or implementing
a digital filter.

00:02:11.660 --> 00:02:14.590
Well, in the last
lecture, we saw

00:02:14.590 --> 00:02:18.070
that computing discrete
Fourier transforms,

00:02:18.070 --> 00:02:20.770
multiplying those together,
and then computing

00:02:20.770 --> 00:02:23.800
the inverse discrete
Fourier transform

00:02:23.800 --> 00:02:28.010
doesn't give us a convolution
in the usual sense.

00:02:28.010 --> 00:02:31.000
In other words, it doesn't
give us a linear convolution,

00:02:31.000 --> 00:02:33.990
it gives us a
circular convolution.

00:02:33.990 --> 00:02:36.370
And one of the
important considerations

00:02:36.370 --> 00:02:38.560
in using the discrete
Fourier transform

00:02:38.560 --> 00:02:42.310
to implement a digital filter
or a discrete time system

00:02:42.310 --> 00:02:45.340
is to account for
this circularity,

00:02:45.340 --> 00:02:50.260
or to modify the circular
convolution so that it looks

00:02:50.260 --> 00:02:52.840
like a linear convolution.

00:02:52.840 --> 00:02:56.590
So in this lecture, what I would
like to concentrate on, in fact

00:02:56.590 --> 00:03:00.730
entirely for the whole
lecture, is a discussion

00:03:00.730 --> 00:03:03.310
of circular convolution,
with the hope

00:03:03.310 --> 00:03:05.470
that at the end of
this lecture there

00:03:05.470 --> 00:03:08.830
will be a very intuitive
feeling for what

00:03:08.830 --> 00:03:11.200
circular convolution means.

00:03:11.200 --> 00:03:14.920
And then also, how you can
use circular convolution

00:03:14.920 --> 00:03:17.380
to implement a
linear convolution,

00:03:17.380 --> 00:03:20.530
and consequently, to
implement a discrete time

00:03:20.530 --> 00:03:25.250
linear system, for example,
to implement a digital filter.

00:03:25.250 --> 00:03:31.300
Well, first of all, to remind
you of the convolution property

00:03:31.300 --> 00:03:36.090
that we derived last time, we
found that multiplying discrete

00:03:36.090 --> 00:03:40.150
Fourier transforms leads to
a circular convolution, which

00:03:40.150 --> 00:03:43.540
we denoted with
an n and a circle

00:03:43.540 --> 00:03:48.130
around it, meaning an N
point circular convolution.

00:03:48.130 --> 00:03:52.480
And what that basically
corresponded to

00:03:52.480 --> 00:03:57.910
was a periodic convolution of
two periodic sequences, which

00:03:57.910 --> 00:04:02.170
are generated from these
finite length sequences,

00:04:02.170 --> 00:04:07.630
by periodically repeating them
with a period of capital N.

00:04:07.630 --> 00:04:12.880
And then finally, extracting
one N point period from that.

00:04:12.880 --> 00:04:17.890
The result being the circular
convolution of x1 of n

00:04:17.890 --> 00:04:20.649
with x2 of n.

00:04:20.649 --> 00:04:23.980
Notationally, also
sometimes we wrote

00:04:23.980 --> 00:04:27.370
this in a slightly
different way where

00:04:27.370 --> 00:04:31.960
the periodic sequence,
x1 tilde of m or n

00:04:31.960 --> 00:04:34.675
could also be written
with a modular notation,

00:04:34.675 --> 00:04:38.680
a double parentheses, and
a subscript capital N,

00:04:38.680 --> 00:04:43.396
indicating that x1 of n or m--

00:04:43.396 --> 00:04:47.270
x1 tilde of m is
generated from x1 of m

00:04:47.270 --> 00:04:50.790
by simply taking this
argument, modulo capital M--

00:04:50.790 --> 00:04:52.610
capital N.

00:04:52.610 --> 00:04:56.090
So this is an alternative
way of writing this.

00:04:56.090 --> 00:04:59.360
And finally, I pointed
out in the last lecture,

00:04:59.360 --> 00:05:03.030
that if we just look
at this expression,

00:05:03.030 --> 00:05:09.440
we see that x1 tilde of m, or
equivalently x1 of m, modulo

00:05:09.440 --> 00:05:15.350
capital N, only involves
values of this argument from 0

00:05:15.350 --> 00:05:19.890
to capital N minus 1 and
consequently as an alternative,

00:05:19.890 --> 00:05:24.710
we can replace here x1 of m.

00:05:24.710 --> 00:05:29.810
So this was an expression
for circular convolution

00:05:29.810 --> 00:05:35.370
of the two finite length
sequences x1 of n and x2 of n.

00:05:35.370 --> 00:05:38.940
To remind you of
how the mechanics

00:05:38.940 --> 00:05:43.080
of the circular convolution
are carried out,

00:05:43.080 --> 00:05:46.980
I showed you last time
the circular convolution

00:05:46.980 --> 00:05:52.470
of one finite length
sequence, x1 of m and x2 of m.

00:05:52.470 --> 00:05:56.830
And let me re-stress a
couple of important points.

00:05:56.830 --> 00:06:02.610
First of all, we form from x1
of m, rather from x2 two of m,

00:06:02.610 --> 00:06:08.740
x2 of n minus m modulo
capital N. And for example,

00:06:08.740 --> 00:06:10.470
if little n equals
0, so that we're

00:06:10.470 --> 00:06:14.580
looking at x2 of minus
m modulo capital N,

00:06:14.580 --> 00:06:18.390
that corresponds to
flipping this over and then

00:06:18.390 --> 00:06:23.730
taking the values, module
capital N, which basically

00:06:23.730 --> 00:06:26.100
corresponds to
flipping this over,

00:06:26.100 --> 00:06:28.260
the points that
come off the end get

00:06:28.260 --> 00:06:33.690
wrapped around back onto this
side, as I've illustrated here.

00:06:33.690 --> 00:06:36.420
Then if we shift,
and I've indicated

00:06:36.420 --> 00:06:39.180
with these dashed lines
what would correspond

00:06:39.180 --> 00:06:41.980
to the periodic
extension of this,

00:06:41.980 --> 00:06:46.660
although it's the interval
from 0 to capital N minus 1,

00:06:46.660 --> 00:06:49.121
which is the interval
that I want to focus on.

00:06:49.121 --> 00:06:49.620
All right.

00:06:49.620 --> 00:06:54.390
Well, now as we change n, if
this is generally n minus m,

00:06:54.390 --> 00:06:58.560
that corresponds to a shift
left or right of this sequence.

00:06:58.560 --> 00:07:03.440
And if, let's say we
look at x2 of 1 minus m,

00:07:03.440 --> 00:07:06.840
modulo capital N.
That corresponds

00:07:06.840 --> 00:07:11.040
to shifting this sequence
to the right by one point.

00:07:11.040 --> 00:07:13.950
And as this point
falls off the end,

00:07:13.950 --> 00:07:16.770
it wraps around to
the other side, which

00:07:16.770 --> 00:07:18.810
is what I've illustrated here.

00:07:18.810 --> 00:07:23.100
And then if we shift so
that little n is equal to 2,

00:07:23.100 --> 00:07:26.280
another point wraps
around the end,

00:07:26.280 --> 00:07:28.320
as I've indicated, et cetera.

00:07:28.320 --> 00:07:31.540
And that's the kind of
shifting that gets carried out.

00:07:31.540 --> 00:07:34.510
In other words, it's a circular
shift that's implemented.

00:07:34.510 --> 00:07:38.010
To form the convolution, then
for example, for little n

00:07:38.010 --> 00:07:44.670
equals 1, we multiply this set
of values by this set of values

00:07:44.670 --> 00:07:46.740
and carry out the sum.

00:07:46.740 --> 00:07:48.870
And as I indicated
last time, it's

00:07:48.870 --> 00:07:51.240
straightforward to see
that the answer comes out

00:07:51.240 --> 00:07:56.220
to be unity over the interval
0 to capital N minus 1.

00:07:56.220 --> 00:07:58.710
But the important point,
and the important picture

00:07:58.710 --> 00:08:01.080
that I tried to
stress last time,

00:08:01.080 --> 00:08:04.950
was the notion of
thinking of the sequences

00:08:04.950 --> 00:08:07.530
as being wrapped around
a cylinder, x1 of n

00:08:07.530 --> 00:08:11.280
wrapped around a
cylinder, x2 of minus n

00:08:11.280 --> 00:08:15.330
wrapped around a cylinder, one
cylinder put inside the other,

00:08:15.330 --> 00:08:17.520
and then as we form
the convolution,

00:08:17.520 --> 00:08:20.700
the cylinders are turned
with respect to each other,

00:08:20.700 --> 00:08:23.640
and the values multiplied--

00:08:23.640 --> 00:08:27.810
successive values multiplied and
then added around the cylinder.

00:08:27.810 --> 00:08:32.630
And that's the picture
of circular convolution.

00:08:32.630 --> 00:08:35.679
Now there are other
ways of looking

00:08:35.679 --> 00:08:37.780
at circular convolution.

00:08:37.780 --> 00:08:43.600
And one of them can be
suggested by referring back

00:08:43.600 --> 00:08:46.310
to this view graph.

00:08:46.310 --> 00:08:51.440
We saw that we could express
the circular convolution

00:08:51.440 --> 00:08:55.880
in this form, or
equivalently, what

00:08:55.880 --> 00:09:01.070
this means, what this equation
means, or can be interpreted

00:09:01.070 --> 00:09:09.760
as, is as the linear convolution
of x1 of n and x2 tilde of n,

00:09:09.760 --> 00:09:14.600
or equivalently, x2 to
of n modulo capital N,

00:09:14.600 --> 00:09:18.740
and then one period
extracted from that.

00:09:18.740 --> 00:09:22.460
So in fact, another way of
looking at circular convolution

00:09:22.460 --> 00:09:26.810
would be to form the linear
convolution of x1 of n

00:09:26.810 --> 00:09:31.580
with the periodic
counterpart of x2 of n,

00:09:31.580 --> 00:09:34.130
carry out that
linear convolution

00:09:34.130 --> 00:09:38.070
and then extract one period,
which is what this function r

00:09:38.070 --> 00:09:41.520
sub capital N of n is doing.

00:09:41.520 --> 00:09:45.710
How can we get the periodic
sequence from x2 of n?

00:09:45.710 --> 00:09:51.620
Well, we could do that, for
example, by convolving x2 of n

00:09:51.620 --> 00:09:55.790
with a pulse train where
the spacing of the pulses

00:09:55.790 --> 00:10:01.220
is capital N. And that's
illustrated on the next view

00:10:01.220 --> 00:10:04.140
graph.

00:10:04.140 --> 00:10:08.190
So that from the equation
that we just saw,

00:10:08.190 --> 00:10:14.310
one possible way of thinking
of circular convolution

00:10:14.310 --> 00:10:22.410
is as the generation of the
periodic function x2 of n.

00:10:22.410 --> 00:10:26.370
By convolving x2 of
n with a pulse train,

00:10:26.370 --> 00:10:30.490
then a linear convolution
of that with x1 of n,

00:10:30.490 --> 00:10:33.220
and then finally,
extracting one period,

00:10:33.220 --> 00:10:37.990
which is what this function,
multiplying x3 tilde of n does.

00:10:37.990 --> 00:10:41.130
So we could generate
a pulse train

00:10:41.130 --> 00:10:47.040
by taking a system whose
unit sample response is

00:10:47.040 --> 00:10:53.610
1 at a spacing of capital
N, and it's 0 otherwise.

00:10:53.610 --> 00:10:57.190
Kicking that system with the
unit sample, in which case,

00:10:57.190 --> 00:11:00.900
we get this pulse train out.

00:11:00.900 --> 00:11:04.680
Using that as the
excitation to a system

00:11:04.680 --> 00:11:09.450
whose unit sample response is
x2 of n, and what we'll get then

00:11:09.450 --> 00:11:14.040
is x2 of n convolved
with this pulse train,

00:11:14.040 --> 00:11:19.710
or x2 of n repeated at
intervals of capital N,

00:11:19.710 --> 00:11:23.710
but that's x2 tilde of n, that's
the periodic sequence that we

00:11:23.710 --> 00:11:24.210
want.

00:11:24.210 --> 00:11:27.480
That's the periodic
counterpart of x2 of n.

00:11:27.480 --> 00:11:31.650
And so that is
what we have here.

00:11:31.650 --> 00:11:34.080
Using that as the
input to a system

00:11:34.080 --> 00:11:37.590
whose unit sample
response is x1 of n,

00:11:37.590 --> 00:11:42.900
and then the output is the
periodic convolution of x1

00:11:42.900 --> 00:11:44.850
of n with x2 of n.

00:11:44.850 --> 00:11:47.550
We extract one period
and we get finally,

00:11:47.550 --> 00:11:52.090
the circular convolution of the
finite length sequences x1 of n

00:11:52.090 --> 00:11:54.900
an x2 of n.

00:11:54.900 --> 00:11:58.880
Well, the fact that we could
view the circular convolution

00:11:58.880 --> 00:12:02.390
in terms of a cascade
of systems of this type

00:12:02.390 --> 00:12:06.950
leads to a very important and
interesting interpretation

00:12:06.950 --> 00:12:10.060
of circular convolution.

00:12:10.060 --> 00:12:20.660
In particular, let's
look at these systems,

00:12:20.660 --> 00:12:23.720
cascaded as they are here.

00:12:23.720 --> 00:12:28.910
So we have then, the cascade
of these three systems

00:12:28.910 --> 00:12:32.960
to generate the circular
convolution, which is x3 of n,

00:12:32.960 --> 00:12:37.820
the circular convolution
of x1 of n and x2 of n.

00:12:37.820 --> 00:12:42.740
So this then is three systems
linear shift invariant systems

00:12:42.740 --> 00:12:44.900
and cascade.

00:12:44.900 --> 00:12:49.550
And one of the important things
that we know about linear shift

00:12:49.550 --> 00:12:53.090
invariant systems
which are cascaded

00:12:53.090 --> 00:12:57.800
is that the order in which
they're cascaded is irrelevant.

00:12:57.800 --> 00:13:00.590
That's something we showed
in one of the early lectures.

00:13:00.590 --> 00:13:04.370
So in fact, we can interchange
the order of these systems

00:13:04.370 --> 00:13:07.430
any way that we want to.

00:13:07.430 --> 00:13:09.740
And in particular,
let's interchange

00:13:09.740 --> 00:13:13.370
the order of these systems
by taking this system which

00:13:13.370 --> 00:13:16.370
generates the pulse
train, putting that

00:13:16.370 --> 00:13:19.700
at the end of this
cascade chain so

00:13:19.700 --> 00:13:22.880
that instead of
this cascade then,

00:13:22.880 --> 00:13:27.170
we have x2 of n
cascaded with x1 of n,

00:13:27.170 --> 00:13:30.590
cascaded with p
sub capital N of n.

00:13:30.590 --> 00:13:35.430
And then of course, r sub n
to extract the single period.

00:13:35.430 --> 00:13:37.980
Well, what does this mean?

00:13:37.980 --> 00:13:41.390
This means that I
can equivalently

00:13:41.390 --> 00:13:46.910
form the circular convolution
of x1 of n and x2 of n

00:13:46.910 --> 00:13:51.650
by first forming the linear
convolution of x1 and x2.

00:13:51.650 --> 00:13:54.050
That's of course, what the
impulse response of these two

00:13:54.050 --> 00:13:57.470
systems and cascade is.

00:13:57.470 --> 00:14:00.170
And then using that
as the excitation

00:14:00.170 --> 00:14:05.480
to a system whose unit sample
response is a pulse train.

00:14:05.480 --> 00:14:10.740
So I can think of this then
as the linear convolution.

00:14:10.740 --> 00:14:17.920
That convolved with a pulse
train, one period extracted,

00:14:17.920 --> 00:14:21.450
and the result is a
circular convolution.

00:14:21.450 --> 00:14:24.420
That's a very useful and
important interpretation

00:14:24.420 --> 00:14:26.460
of circular convolution.

00:14:26.460 --> 00:14:29.040
And the way to sort of
say it in words, this

00:14:29.040 --> 00:14:32.490
isn't exactly correct,
but more or less

00:14:32.490 --> 00:14:36.930
the way to say it in words is
that the circular convolution

00:14:36.930 --> 00:14:42.900
can be formed from a linear
convolution plus aliasing.

00:14:42.900 --> 00:14:46.320
You see this linear
convolution in general,

00:14:46.320 --> 00:14:48.120
is going to be
longer than capital

00:14:48.120 --> 00:14:52.800
N. The output of this system
is this linear convolution

00:14:52.800 --> 00:14:56.610
repeated over and over again,
added up over and over again

00:14:56.610 --> 00:14:59.940
with a spacing of capital N.
So there is an interference,

00:14:59.940 --> 00:15:04.200
if you want to call it that,
between the successive replicas

00:15:04.200 --> 00:15:07.890
of this linear convolution as
they come out of this system.

00:15:07.890 --> 00:15:10.320
That's the aliasing,
that's why aliasing

00:15:10.320 --> 00:15:13.140
is stuck into that phrase.

00:15:13.140 --> 00:15:17.760
But the way to summarize
it or think about it

00:15:17.760 --> 00:15:21.240
is as circular
convolution corresponding

00:15:21.240 --> 00:15:25.980
to linear convolution
plus aliasing.

00:15:25.980 --> 00:15:30.150
So here it is said again,
circular convolution

00:15:30.150 --> 00:15:33.900
equals linear convolution
plus aliasing.

00:15:33.900 --> 00:15:39.780
What I mean by that is that if
I have the linear convolution

00:15:39.780 --> 00:15:47.040
of x1 of n and x2 of n, which
I'm denoting by x3 hat of n,

00:15:47.040 --> 00:15:49.410
and I want the
circular convolution,

00:15:49.410 --> 00:15:56.820
the N point circular convolution
of x1 of n with x2 of n,

00:15:56.820 --> 00:15:59.190
I can get the
circular convolution

00:15:59.190 --> 00:16:04.110
from the linear convolution by
taking the linear convolution

00:16:04.110 --> 00:16:07.560
and convolving it with a
pulse train with a spacing

00:16:07.560 --> 00:16:12.600
of capital N, or equivalently
adding it to itself,

00:16:12.600 --> 00:16:16.050
delayed by capital N, 2
capital N minus capital N,

00:16:16.050 --> 00:16:19.980
minus 2 capital N, et
cetera, and then extracting

00:16:19.980 --> 00:16:21.780
a single period.

00:16:21.780 --> 00:16:26.310
And often when you carry out
a circular convolution of two

00:16:26.310 --> 00:16:29.310
sequences or want to
examine properties

00:16:29.310 --> 00:16:34.530
of circular convolution,
the notion or interpretation

00:16:34.530 --> 00:16:38.130
of circular convolution
as linear convolution

00:16:38.130 --> 00:16:45.540
plus aliasing is an extremely
useful sort of picture to have.

00:16:45.540 --> 00:16:47.850
So it's the kind
of phrase that you

00:16:47.850 --> 00:16:50.880
should repeat to yourself
two or three times for a week

00:16:50.880 --> 00:16:52.410
before you go to bed.

00:16:52.410 --> 00:16:56.340
And in a short time, you'll
understand the relationship

00:16:56.340 --> 00:17:00.120
between circular convolution and
linear convolution very well.

00:17:00.120 --> 00:17:05.780
Well, let's look at a
couple of examples of this.

00:17:05.780 --> 00:17:12.280
Here is a sequence, x1 of n,
it's a six-point sequence.

00:17:12.280 --> 00:17:16.430
And let's carry out the
circular convolution

00:17:16.430 --> 00:17:19.700
of this sequence
with itself, that

00:17:19.700 --> 00:17:23.480
makes it a relatively
straightforward example.

00:17:23.480 --> 00:17:26.900
And let's do that
by using the notion

00:17:26.900 --> 00:17:29.570
that circular convolution
is linear convolution

00:17:29.570 --> 00:17:31.790
plus aliasing.

00:17:31.790 --> 00:17:36.650
So we want first of all, to
form the linear convolution

00:17:36.650 --> 00:17:40.280
of x1 of n and x2 of n.

00:17:40.280 --> 00:17:44.360
And as you should recall from
similar examples in the earlier

00:17:44.360 --> 00:17:47.090
lectures, and examples that
you've worked in the study

00:17:47.090 --> 00:17:51.770
guide, the linear convolution
of this sequence with itself

00:17:51.770 --> 00:17:55.160
is a triangular sequence.

00:17:55.160 --> 00:17:56.720
We of course, take
this sequence,

00:17:56.720 --> 00:17:59.870
flip it over, and
slide it past itself.

00:17:59.870 --> 00:18:02.540
And as we slide along, we
accumulate more and more

00:18:02.540 --> 00:18:04.460
points.

00:18:04.460 --> 00:18:10.820
And so, the linear convolution
of x1 of n with x2 of n

00:18:10.820 --> 00:18:16.130
is a triangular sequence,
as I've indicated here.

00:18:16.130 --> 00:18:20.345
Well, now to form the
circular convolution of x of n

00:18:20.345 --> 00:18:23.030
and x2 of n.

00:18:23.030 --> 00:18:28.820
What we need to do is repeat
this triangular sequence over

00:18:28.820 --> 00:18:35.630
and over again, add it to itself
with a delay of capital N.

00:18:35.630 --> 00:18:39.030
And capital N in this case is 6.

00:18:39.030 --> 00:18:43.310
So we want this sequence
repeated over and over again

00:18:43.310 --> 00:18:47.540
and added to itself with a
spacing of six and then 12

00:18:47.540 --> 00:18:50.030
and then 18, et cetera.

00:18:50.030 --> 00:18:55.160
Or equivalently, we want the
linear convolution convolved

00:18:55.160 --> 00:18:59.960
with a pulse train where
the spacing of the pulses

00:18:59.960 --> 00:19:03.020
is capital N, which
in this case is 6.

00:19:03.020 --> 00:19:07.880
So I've indicated here, the
envelope of the triangular

00:19:07.880 --> 00:19:11.180
sequence, that's
the envelope here,

00:19:11.180 --> 00:19:15.080
the envelope of the
triangular sequence.

00:19:15.080 --> 00:19:20.330
And you can see that if
we overlap these triangles

00:19:20.330 --> 00:19:24.860
by a spacing of
six, then in fact,

00:19:24.860 --> 00:19:28.460
these points will get
added to these points.

00:19:28.460 --> 00:19:35.460
Or when we add up the triangles,
they'll always add up to 1.

00:19:35.460 --> 00:19:39.770
So when we carry out
this convolution,

00:19:39.770 --> 00:19:44.750
what we end up with are
values that are constant

00:19:44.750 --> 00:19:47.270
from minus infinity
to plus infinity,

00:19:47.270 --> 00:19:50.840
that's due to the
convolution with this term.

00:19:50.840 --> 00:19:53.840
Finally, to form the
N point, or six-point

00:19:53.840 --> 00:19:56.930
in this case, circular
convolution, what

00:19:56.930 --> 00:20:01.160
we want to extract
are the six points

00:20:01.160 --> 00:20:03.980
of this sequence one,
two, three, four, five,

00:20:03.980 --> 00:20:08.360
six, those six points,
set the rest to 0,

00:20:08.360 --> 00:20:11.360
and the result is, as
I've indicated here.

00:20:11.360 --> 00:20:15.110
So this then is the N
point circular convolution

00:20:15.110 --> 00:20:17.960
of x1 of n with x2 of n.

00:20:17.960 --> 00:20:24.500
This is the linear convolution
of x1 of n with x2 of n.

00:20:24.500 --> 00:20:28.220
It should be clear that,
or relatively clear

00:20:28.220 --> 00:20:31.970
that this is, in fact, the way
the circular convolution comes

00:20:31.970 --> 00:20:37.310
out, because if you imagine
flipping this and sliding

00:20:37.310 --> 00:20:41.120
it, modulo capital N,
or equivalently taking

00:20:41.120 --> 00:20:44.330
this sequence and wrapping
it around the cylinder,

00:20:44.330 --> 00:20:46.610
no matter how you twist
the cylinder you always

00:20:46.610 --> 00:20:48.140
see the same points.

00:20:48.140 --> 00:20:52.790
So in fact, by evaluating
the circular convolution

00:20:52.790 --> 00:20:55.580
using modulus arguments,
you would of course,

00:20:55.580 --> 00:20:58.220
come up with the same
result. But we see here,

00:20:58.220 --> 00:21:02.240
how it comes out of this
notion of linear convolution

00:21:02.240 --> 00:21:04.730
plus aliasing.

00:21:04.730 --> 00:21:07.670
All right, well let's
look at another example.

00:21:10.490 --> 00:21:14.810
Actually, it's the same example,
but with one slight change

00:21:14.810 --> 00:21:16.010
to it.

00:21:16.010 --> 00:21:21.530
Here again, I have the example
of x1 of n equal to x2 of n.

00:21:21.530 --> 00:21:25.910
And again, we take both of
them as a boxcar sequence.

00:21:25.910 --> 00:21:29.060
In other words, rectangular or
constant value in the interval

00:21:29.060 --> 00:21:34.290
0 to n minus 1, and 0
outside that interval.

00:21:34.290 --> 00:21:38.190
Again of course, then we
have the linear convolution

00:21:38.190 --> 00:21:43.400
of these two as
a triangle, which

00:21:43.400 --> 00:21:46.890
is what I've denoted here.

00:21:46.890 --> 00:21:51.960
And now let's look, not at the
N point circular convolution,

00:21:51.960 --> 00:21:56.820
but at the 2n point
circular convolution

00:21:56.820 --> 00:22:00.990
of x1 of with x2 of n.

00:22:00.990 --> 00:22:06.030
In that case, we want this
triangular sequence repeated

00:22:06.030 --> 00:22:09.780
and added to itself, not
with a spacing of capital N

00:22:09.780 --> 00:22:15.365
as in the previous example,
but with a spacing of 2 capital

00:22:15.365 --> 00:22:19.750
N because we're doing
a 2 capital N point

00:22:19.750 --> 00:22:21.450
circular convolution.

00:22:21.450 --> 00:22:24.210
Well if we do that, then we
end up with this triangular

00:22:24.210 --> 00:22:28.410
sequence added to itself
starting here, finishing over

00:22:28.410 --> 00:22:28.920
there.

00:22:28.920 --> 00:22:33.900
Or in general, if we convolve
it with this pulse train,

00:22:33.900 --> 00:22:39.700
then the resulting periodic
sequence that we end up with

00:22:39.700 --> 00:22:43.920
has triangular periods
to it with a period now,

00:22:43.920 --> 00:22:47.030
not have capital N as we
had in the previous example,

00:22:47.030 --> 00:22:50.020
but of 2 capital N.

00:22:50.020 --> 00:22:54.820
Finally, to get the circular
convolution, we see that,

00:22:54.820 --> 00:22:59.890
or we recall that we want to
extract one period of this.

00:22:59.890 --> 00:23:06.680
So we extract a period from
0 to 2 capital N minus 1.

00:23:06.680 --> 00:23:10.210
So we have 0 to 2
capital N minus 1.

00:23:10.210 --> 00:23:14.830
And this result then is the 2
N point circular convolution

00:23:14.830 --> 00:23:19.370
of x1 of n with x2 two of n.

00:23:19.370 --> 00:23:23.080
It's interesting to
note that in this case,

00:23:23.080 --> 00:23:26.320
the circular
convolution in fact,

00:23:26.320 --> 00:23:29.250
came out looking like the
linear convolution of x

00:23:29.250 --> 00:23:32.230
of n and x2 of n.

00:23:32.230 --> 00:23:34.810
And the reason for
that we see, is

00:23:34.810 --> 00:23:39.460
that when we did the convolution
with this pulse train,

00:23:39.460 --> 00:23:42.580
we chose the spacing
of the pulse train

00:23:42.580 --> 00:23:46.780
large enough so that
there was no interference

00:23:46.780 --> 00:23:51.810
from successive replicas
of this linear convolution.

00:23:51.810 --> 00:23:54.360
Well, that suggests
an interesting thing.

00:23:54.360 --> 00:23:58.230
It suggests that
we could in fact,

00:23:58.230 --> 00:24:04.140
implement a linear convolution
from a circular convolution

00:24:04.140 --> 00:24:07.740
if we're careful enough
to pick the length

00:24:07.740 --> 00:24:11.250
of the circular
convolution long enough.

00:24:11.250 --> 00:24:12.900
Now what does long enough mean?

00:24:12.900 --> 00:24:16.170
Well, long enough
means that the length

00:24:16.170 --> 00:24:20.790
of the circular convolution
has to be longer

00:24:20.790 --> 00:24:24.870
than the length of the
linear convolution.

00:24:24.870 --> 00:24:26.760
You can show
incidentally, and you'll

00:24:26.760 --> 00:24:29.460
see this in more
detail in the text,

00:24:29.460 --> 00:24:33.690
that if you have sequence
of length capital N

00:24:33.690 --> 00:24:36.930
and another sequence
of length capital M,

00:24:36.930 --> 00:24:39.060
then the linear
convolution of the two

00:24:39.060 --> 00:24:43.500
is always going to be
shorter than or equal to n

00:24:43.500 --> 00:24:46.020
plus m minus one points.

00:24:46.020 --> 00:24:47.850
So if we do the
circular convolution

00:24:47.850 --> 00:24:51.930
on the basis of n plus
m minus 1, or n plus m--

00:24:51.930 --> 00:24:55.080
well, take n plus m,
that will certainly work,

00:24:55.080 --> 00:25:00.060
then the circular convolution
will end up corresponding

00:25:00.060 --> 00:25:02.190
to a linear convolution.

00:25:02.190 --> 00:25:08.820
And this is the way that we can
carry out a linear convolution

00:25:08.820 --> 00:25:11.220
using circular convolution.

00:25:11.220 --> 00:25:16.530
This is commonly referred
to as padding with zeros.

00:25:16.530 --> 00:25:22.440
And what that means is treating
this N point sequence not as

00:25:22.440 --> 00:25:24.060
an N point sequence
when we compute

00:25:24.060 --> 00:25:30.240
the DFT, but as a sequence
of length 2 capital N,

00:25:30.240 --> 00:25:33.930
so that if we computed
a 2 capital N point

00:25:33.930 --> 00:25:40.050
DFT of this sequence, padding
out with capital N zeroes,

00:25:40.050 --> 00:25:44.010
multiplied that DFT
together with itself

00:25:44.010 --> 00:25:47.790
and then computed the inverse
DFT, what we would get,

00:25:47.790 --> 00:25:51.600
in fact, because of the fact
that we padded out with zeroes

00:25:51.600 --> 00:25:55.680
is a 2 N point
circular convolution,

00:25:55.680 --> 00:25:59.340
which would correspond to
the linear convolution.

00:25:59.340 --> 00:26:03.360
So this is the way,
then that we can

00:26:03.360 --> 00:26:06.870
modify a circular convolution
so that it implements

00:26:06.870 --> 00:26:09.510
for us a linear convolution.

00:26:09.510 --> 00:26:14.880
And when we actually
implement a digital filter,

00:26:14.880 --> 00:26:18.630
or a discrete time system
using an explicit computation

00:26:18.630 --> 00:26:21.690
of the discrete Fourier
transform, then of course,

00:26:21.690 --> 00:26:26.190
this is what we have to do to
avoid the circular convolution

00:26:26.190 --> 00:26:30.210
since what we want in that
case is a linear convolution.

00:26:30.210 --> 00:26:33.090
Well, it's important,
very important

00:26:33.090 --> 00:26:36.000
to keep straight first
of all, the properties

00:26:36.000 --> 00:26:37.650
of circular convolution.

00:26:37.650 --> 00:26:39.980
Sometimes in fact,
circular convolution

00:26:39.980 --> 00:26:42.420
is what you would like to get.

00:26:42.420 --> 00:26:45.300
The notion, the relationship
between circular and linear

00:26:45.300 --> 00:26:49.080
convolution, mainly this
notion of circular convolution

00:26:49.080 --> 00:26:52.230
being equal to linear
convolution plus aliasing.

00:26:52.230 --> 00:26:54.120
And then finally
the way in which

00:26:54.120 --> 00:26:57.750
you can use a circular
convolution to actually

00:26:57.750 --> 00:27:01.570
implement a linear convolution.

00:27:01.570 --> 00:27:03.930
Now what I'd like
to do is really

00:27:03.930 --> 00:27:10.200
cement this by illustrating
these notions, finally,

00:27:10.200 --> 00:27:14.140
with a film which will
depict a number of things.

00:27:14.140 --> 00:27:16.830
It's actually the
continuation of a film

00:27:16.830 --> 00:27:19.560
that you saw in
the first lecture

00:27:19.560 --> 00:27:22.810
that we had on discrete
time convolution.

00:27:22.810 --> 00:27:27.450
We'll show first of
all, linear convolution

00:27:27.450 --> 00:27:30.450
just exactly as you
had seen before.

00:27:30.450 --> 00:27:34.140
Second of all, periodic
or circular convolution

00:27:34.140 --> 00:27:36.580
and the difference between them.

00:27:36.580 --> 00:27:38.940
The third thing that
the film will illustrate

00:27:38.940 --> 00:27:42.720
is the relationship
between linear convolution

00:27:42.720 --> 00:27:45.720
and periodic or circular
convolution, namely,

00:27:45.720 --> 00:27:47.730
the notion of
circular convolution

00:27:47.730 --> 00:27:51.840
as linear convolution
plus aliasing.

00:27:51.840 --> 00:27:56.340
And finally, the fourth
thing that it will illustrate

00:27:56.340 --> 00:28:00.720
is this notion of
padding with zeros

00:28:00.720 --> 00:28:03.750
so that a circular
convolution can

00:28:03.750 --> 00:28:07.060
be used to implement
a linear convolution.

00:28:07.060 --> 00:28:09.330
So let's go to the
film now and go

00:28:09.330 --> 00:28:12.300
through these various
examples with the hope

00:28:12.300 --> 00:28:17.580
that at the end of this, the
notion and relationships will

00:28:17.580 --> 00:28:18.500
really be very, vivid.

00:28:29.680 --> 00:28:32.590
OK the convolutions sum
then, we have is the sum

00:28:32.590 --> 00:28:35.560
of x of k, h of n minus k.

00:28:35.560 --> 00:28:38.200
And so what we would
like to illustrate

00:28:38.200 --> 00:28:42.460
is the operation of
evaluating this sum.

00:28:42.460 --> 00:28:46.750
On the top we have x of k,
on the bottom we have h of k,

00:28:46.750 --> 00:28:49.390
h of k being an exponential.

00:28:49.390 --> 00:28:55.030
And now we see h of minus k,
namely h of k flipped over.

00:28:55.030 --> 00:28:58.600
As we shift h of k to the
left, corresponding to n

00:28:58.600 --> 00:29:03.355
equals minus 1, then back
to 0, and now to the right.

00:29:06.050 --> 00:29:09.010
So we have h of 1 minus k.

00:29:09.010 --> 00:29:13.000
And then to form y of
n, we want the product

00:29:13.000 --> 00:29:17.200
of h of minus k
shifted with x of k,

00:29:17.200 --> 00:29:21.440
that product summed from minus
infinity to plus infinity.

00:29:21.440 --> 00:29:27.010
" here we see x of k times
h of 1 minus k, 2 minus k,

00:29:27.010 --> 00:29:31.170
3 minus k, et cetera, those
multiplied and then summed from

00:29:31.170 --> 00:29:33.480
minus infinity to plus infinity.

00:29:33.480 --> 00:29:37.330
We see during this portion
that more and more values of h

00:29:37.330 --> 00:29:39.880
are engaged with
non-zero values of x.

00:29:39.880 --> 00:29:44.320
And so y of n grows until we
reach the point where values

00:29:44.320 --> 00:29:49.780
fall off the end of the non-zero
values of x, where y of n

00:29:49.780 --> 00:29:51.400
decays.

00:29:51.400 --> 00:29:56.890
So this then is an illustration
of the linear convolution

00:29:56.890 --> 00:29:59.425
of x of k with h of k.

00:30:07.760 --> 00:30:10.100
Now what we'd like
to compare this with

00:30:10.100 --> 00:30:15.110
is periodic convolution where
the sum is of a similar form,

00:30:15.110 --> 00:30:20.310
but the arguments are
taken modulo capital M.

00:30:20.310 --> 00:30:22.380
And in this case
then, the shifting

00:30:22.380 --> 00:30:25.470
is a circular shifting rather
than a linear shifting.

00:30:25.470 --> 00:30:29.100
On the top again, we
have x of k, modulo M.

00:30:29.100 --> 00:30:31.830
On the bottom, h of k, modulo m.

00:30:31.830 --> 00:30:38.340
Now h minus k, modulo m,
and we see that as we shift,

00:30:38.340 --> 00:30:41.820
the shift is circular
modulo capital M.

00:30:41.820 --> 00:30:48.540
So there's 0, h of 0 minus
k, modulo capital M, h of 1

00:30:48.540 --> 00:30:51.630
minus k, modulo capital
M that was shifted

00:30:51.630 --> 00:30:54.810
to the right circularly by 1.

00:30:54.810 --> 00:30:59.360
And now we want to look at
the sum from 0 to m minus 1

00:30:59.360 --> 00:31:02.060
of the product of those.

00:31:02.060 --> 00:31:06.800
And the thing to notice
is that since x of k

00:31:06.800 --> 00:31:10.380
is of length capital
M, as we implement

00:31:10.380 --> 00:31:16.220
the circular shift of h of
minus k, the values of h of k,

00:31:16.220 --> 00:31:20.930
or h if minus k are always
engaged with unity values of x,

00:31:20.930 --> 00:31:26.240
and consequently, y always comes
out to have the same value.

00:31:26.240 --> 00:31:29.720
To see the relationship between
the periodic and aperiodic

00:31:29.720 --> 00:31:34.280
convolution, namely the
aliasing relationship,

00:31:34.280 --> 00:31:39.720
we can simply look at the
aperiodic convolution,

00:31:39.720 --> 00:31:44.000
or linear convolution,
take the second m values,

00:31:44.000 --> 00:31:47.600
added to the first
m values, and when

00:31:47.600 --> 00:31:51.230
we carry out that sum,
what we get is a constant.

00:31:51.230 --> 00:31:55.790
In general, the relationship is
that the circular convolution

00:31:55.790 --> 00:31:59.100
is y of n plus y of n
plus capital M, y of n

00:31:59.100 --> 00:32:01.850
plus 2 capital M, et cetera.

00:32:01.850 --> 00:32:05.060
Next, what we would
like to illustrate

00:32:05.060 --> 00:32:09.320
is the fact that the
linear convolution

00:32:09.320 --> 00:32:11.690
can be obtained from
a circular convolution

00:32:11.690 --> 00:32:13.940
if we pad out with zeros.

00:32:13.940 --> 00:32:17.960
So now we're going to implement
the circular convolution,

00:32:17.960 --> 00:32:21.920
but notice that
we've padded x of k

00:32:21.920 --> 00:32:25.130
out with a number of zeros.

00:32:25.130 --> 00:32:29.240
In that case, as we do the
circular shifting of h,

00:32:29.240 --> 00:32:33.440
the values on the right
are multiplied only

00:32:33.440 --> 00:32:36.710
by the zero values that
we appended x with,

00:32:36.710 --> 00:32:40.790
and so this looks exactly the
same as if we were sliding h

00:32:40.790 --> 00:32:43.230
in from the left-hand end.

00:32:43.230 --> 00:32:48.890
And so what results then
is the linear convolution.

00:32:48.890 --> 00:32:53.090
Although we're implementing a
circular convolution, because

00:32:53.090 --> 00:32:56.150
of the fact that we've
augmented with zeros,

00:32:56.150 --> 00:32:59.900
the resulting answer
is exactly the same

00:32:59.900 --> 00:33:04.670
as the linear convolution
of x of n with h of n.

00:33:10.420 --> 00:33:15.730
All right, well hopefully,
through the film

00:33:15.730 --> 00:33:19.000
you got to see the
dynamics of convolution

00:33:19.000 --> 00:33:24.760
in these relationships that I've
been trying so hard to stress.

00:33:24.760 --> 00:33:29.440
And now if we return
to the example

00:33:29.440 --> 00:33:33.910
that we were talking
about before the film,

00:33:33.910 --> 00:33:38.230
it should be clear that
through this notion of padding

00:33:38.230 --> 00:33:41.830
with zeros, we can implement
a linear convolution,

00:33:41.830 --> 00:33:45.850
and thereby implement
a discrete time

00:33:45.850 --> 00:33:49.900
linear shift invariant system
using circular convolution,

00:33:49.900 --> 00:33:54.160
or equivalently, computing
DFTs, multiplying and computing

00:33:54.160 --> 00:33:55.010
the inverse DFT.

00:33:57.650 --> 00:34:01.350
Well there's only
one hitch to that,

00:34:01.350 --> 00:34:03.150
and that's the
following, suppose

00:34:03.150 --> 00:34:10.530
that what I wanted to implement
was a discrete time system.

00:34:10.530 --> 00:34:15.480
Let's take the impulse response
as this sequence x1 of n.

00:34:15.480 --> 00:34:20.130
And let's say that the
input to the filter

00:34:20.130 --> 00:34:24.780
was also a sequence of length
capital N, or capital M.

00:34:24.780 --> 00:34:26.550
Then, on the basis
of everything we've

00:34:26.550 --> 00:34:28.860
been saying in this
lecture, clearly we

00:34:28.860 --> 00:34:33.900
could do the convolution by
padding out with enough zeros,

00:34:33.900 --> 00:34:35.880
computing the discrete
Fourier transform,

00:34:35.880 --> 00:34:39.250
multiplying and
inverse transforming.

00:34:39.250 --> 00:34:42.750
However, in order to
do that, obviously

00:34:42.750 --> 00:34:47.610
for the input, before we compute
the discrete Fourier transform,

00:34:47.610 --> 00:34:50.250
we have to wait until the
entire input comes in.

00:34:50.250 --> 00:34:53.820
In other words, we need a
buffer that's long enough

00:34:53.820 --> 00:34:55.929
to hold the entire input.

00:34:55.929 --> 00:35:01.920
Furthermore what we need to do
is compute a Fourier transform,

00:35:01.920 --> 00:35:07.320
discrete Fourier transform,
that is at least as long

00:35:07.320 --> 00:35:09.340
as the input data.

00:35:09.340 --> 00:35:11.610
In fact, as long
as the input data,

00:35:11.610 --> 00:35:15.390
plus the length of the
unit sample response.

00:35:15.390 --> 00:35:21.210
Now obviously, if we want to
filter some signal like, let's

00:35:21.210 --> 00:35:24.510
say, one of
Beethoven's symphonies,

00:35:24.510 --> 00:35:26.490
clearly we're not
first of all, going

00:35:26.490 --> 00:35:30.180
to want to buffer the
entire input signal.

00:35:30.180 --> 00:35:33.480
Second of all, you can imagine
computationally that at,

00:35:33.480 --> 00:35:36.540
say a 10 kilohertz or 20
kilohertz sampling rate,

00:35:36.540 --> 00:35:39.900
we'd be talking about a discrete
Fourier transform that's

00:35:39.900 --> 00:35:42.640
astronomical in length.

00:35:42.640 --> 00:35:48.870
So if we want to implement
a digital filter,

00:35:48.870 --> 00:35:55.080
or a discrete time system
using this kind of approach,

00:35:55.080 --> 00:35:59.460
then we would like to
have some strategy that

00:35:59.460 --> 00:36:03.060
avoids the problem of having
to buffer the entire input.

00:36:03.060 --> 00:36:08.970
And one way of doing that is
by sectioning the input signal.

00:36:08.970 --> 00:36:16.200
So that, suppose we had as
an example, a unit sample

00:36:16.200 --> 00:36:20.340
response which was
of length capital M,

00:36:20.340 --> 00:36:23.970
so it runs from 0 to
capital M minus 1.

00:36:23.970 --> 00:36:28.760
We have an input signal that's
arbitrarily long, starts at 0,

00:36:28.760 --> 00:36:33.900
let's say, and runs on
for an indefinite length.

00:36:33.900 --> 00:36:39.330
We can imagine sectioning
the input, sectioning x of n

00:36:39.330 --> 00:36:42.660
into sections of some length,
and let's call the length

00:36:42.660 --> 00:36:47.820
capital L, so that we
have a number of sections

00:36:47.820 --> 00:36:51.120
of length capital L.

00:36:51.120 --> 00:36:53.040
Now we know, and
you should recall

00:36:53.040 --> 00:36:55.560
from when we
discussed convolution,

00:36:55.560 --> 00:36:59.190
that the convolution of a
sum, the convolution of h

00:36:59.190 --> 00:37:02.250
of n with the sum of
things is equal to the sum

00:37:02.250 --> 00:37:03.930
of the convolutions.

00:37:03.930 --> 00:37:08.850
So that if we generated a
set of sequences, each one

00:37:08.850 --> 00:37:13.680
corresponding to a different
section of the input,

00:37:13.680 --> 00:37:17.460
we could convolve each
of those with h of n,

00:37:17.460 --> 00:37:21.780
and then add the resulting
convolutions together

00:37:21.780 --> 00:37:24.390
to form the output y of n.

00:37:24.390 --> 00:37:28.600
So if we section
the input, x of n,

00:37:28.600 --> 00:37:31.750
we can then form a set of
sequences, each one of which

00:37:31.750 --> 00:37:34.210
corresponds to one
of these sections

00:37:34.210 --> 00:37:38.350
and is 0 outside the
interval that I've

00:37:38.350 --> 00:37:41.650
indicated for each one of
these colored sections.

00:37:41.650 --> 00:37:47.680
And we would end up with
a set of sub sequences

00:37:47.680 --> 00:37:52.300
which would, for example,
look like this, x 0 of n,

00:37:52.300 --> 00:37:57.960
corresponding to the first
l points, and 0 afterwards.

00:37:57.960 --> 00:38:01.990
X1 of n corresponding
to the second l points,

00:38:01.990 --> 00:38:04.620
and 0 afterwards and before.

00:38:04.620 --> 00:38:07.270
X two of n, the next
set of l points.

00:38:07.270 --> 00:38:09.220
X3 of n, the next
set of l points.

00:38:09.220 --> 00:38:12.250
And we could continue
on like that.

00:38:12.250 --> 00:38:17.200
Implement the convolution of
each one of these sections

00:38:17.200 --> 00:38:20.180
with the unit sample response.

00:38:20.180 --> 00:38:23.780
And then add the resulting
outputs together.

00:38:23.780 --> 00:38:26.390
In that case, the
length transform

00:38:26.390 --> 00:38:30.680
that we would need to compute
the linear convolution

00:38:30.680 --> 00:38:35.900
of this l point section
with the input h of n,

00:38:35.900 --> 00:38:38.450
would be where h of
n was of length m,

00:38:38.450 --> 00:38:41.990
would be a DFT of
length l plus m minus 1.

00:38:41.990 --> 00:38:43.970
L plus m certainly
works, but it turns out

00:38:43.970 --> 00:38:47.790
l plus m minus 1 is enough.

00:38:47.790 --> 00:38:51.560
Now obviously we have to
make sure that we line up.

00:38:51.560 --> 00:38:55.100
If we have the input sections
delayed by a certain amount,

00:38:55.100 --> 00:38:59.060
we have to make sure that we
line up the output sections.

00:38:59.060 --> 00:39:11.170
And what we end up with then is
a set of output sub sequences

00:39:11.170 --> 00:39:14.050
which correspond
to the convolution

00:39:14.050 --> 00:39:19.240
of each one of the input
sections with h of n.

00:39:19.240 --> 00:39:26.020
Now we started out with sections
of length L. We convolved those

00:39:26.020 --> 00:39:31.860
with a unit sample
response of length m.

00:39:31.860 --> 00:39:34.980
The resulting length
of the convolution

00:39:34.980 --> 00:39:37.290
will be L plus m minus 1.

00:39:37.290 --> 00:39:41.010
We've seen that in
a variety of ways.

00:39:41.010 --> 00:39:46.590
And consequently, when we
consider adding up the outputs

00:39:46.590 --> 00:39:51.960
from the convolution with
each one of the subsections,

00:39:51.960 --> 00:39:54.300
if this is the point
that corresponds

00:39:54.300 --> 00:39:58.800
to l, this is just
exactly the right delay,

00:39:58.800 --> 00:40:00.840
we notice that
there's a tail out

00:40:00.840 --> 00:40:03.180
of the convolution
in this section

00:40:03.180 --> 00:40:07.830
that overlaps into
the first m minus 1,

00:40:07.830 --> 00:40:11.270
or N points of it's
m minus 1 points,

00:40:11.270 --> 00:40:14.970
actually, of this section.

00:40:14.970 --> 00:40:17.790
Likewise, there are
m minus 1 points

00:40:17.790 --> 00:40:21.960
at the tail of this one that
overlap into the first m points

00:40:21.960 --> 00:40:23.100
here.

00:40:23.100 --> 00:40:28.350
So that when we add up
the output sub sequences,

00:40:28.350 --> 00:40:32.910
what we have is an
overlap between the tail

00:40:32.910 --> 00:40:34.990
of this section and the
beginning of this one,

00:40:34.990 --> 00:40:39.210
since this starts at l and
this runs longer than l.

00:40:39.210 --> 00:40:42.240
Similarly, an overlap
from the tail of this

00:40:42.240 --> 00:40:44.070
into the beginning of this one.

00:40:44.070 --> 00:40:45.990
And that continues on.

00:40:45.990 --> 00:40:49.170
Because of that, this technique
for suctioning and then

00:40:49.170 --> 00:40:51.510
adding the results
together is often

00:40:51.510 --> 00:40:55.200
referred to as the
overlap add method

00:40:55.200 --> 00:40:59.850
because we overlap the outputs
and then add these together.

00:40:59.850 --> 00:41:01.980
These pieces will add.

00:41:01.980 --> 00:41:07.330
These blue pieces will add,
et cetera, down the line.

00:41:07.330 --> 00:41:10.920
There's also another
method for sectioning

00:41:10.920 --> 00:41:15.130
using circular convolution and
fitting the outputs together,

00:41:15.130 --> 00:41:19.770
which is a method that is
referred to as the overlap

00:41:19.770 --> 00:41:21.090
save method.

00:41:21.090 --> 00:41:26.910
And that method is discussed
in some detail in the text,

00:41:26.910 --> 00:41:29.490
and corresponds
basically, to implementing

00:41:29.490 --> 00:41:32.190
a circular convolution
of the sections

00:41:32.190 --> 00:41:35.464
rather than a linear
convolution as we did here.

00:41:35.464 --> 00:41:38.130
The linear convolution, we could
get from a circular convolution

00:41:38.130 --> 00:41:39.930
by padding with zeros.

00:41:39.930 --> 00:41:43.500
Alternatively, we can take
the circular convolution

00:41:43.500 --> 00:41:46.050
and discard the points
that don't correspond

00:41:46.050 --> 00:41:48.120
to a linear convolution.

00:41:48.120 --> 00:41:52.120
Well, there are a variety
of techniques of this type.

00:41:52.120 --> 00:41:56.940
The important point though,
is that circular convolution

00:41:56.940 --> 00:42:02.010
can, in fact, be used to
implement linear convolution.

00:42:02.010 --> 00:42:06.440
It can be used to
implement digital filters

00:42:06.440 --> 00:42:08.790
or discrete time linear systems.

00:42:08.790 --> 00:42:11.400
And in fact, although this--

00:42:11.400 --> 00:42:14.010
there's nothing that we've
said that clearly makes this

00:42:14.010 --> 00:42:17.670
obvious, in fact, there
are very efficient ways

00:42:17.670 --> 00:42:21.520
of computing the discrete
Fourier transform,

00:42:21.520 --> 00:42:24.060
which in fact make this
notion of computing

00:42:24.060 --> 00:42:28.950
the transform, multiplying
and inverse transforming,

00:42:28.950 --> 00:42:34.260
an efficient method for
implementing a digital filter.

00:42:34.260 --> 00:42:37.500
All right, well this
concludes our discussion

00:42:37.500 --> 00:42:40.350
of the discrete
Fourier transform.

00:42:40.350 --> 00:42:42.660
Toward the end of
this set of lectures,

00:42:42.660 --> 00:42:45.540
we'll return actually,
to the discrete Fourier

00:42:45.540 --> 00:42:49.330
transform again, where
at that time, what we'll

00:42:49.330 --> 00:42:51.870
want to talk about
is specifically

00:42:51.870 --> 00:42:55.740
the computation of the discrete
Fourier transform, which

00:42:55.740 --> 00:42:58.740
leads to notions such as
the fast Fourier transform

00:42:58.740 --> 00:43:00.060
algorithm.

00:43:00.060 --> 00:43:02.280
It's that computational
efficiency

00:43:02.280 --> 00:43:04.290
that makes some of
these ideas that we've

00:43:04.290 --> 00:43:07.740
talked about in the last
few lectures so important

00:43:07.740 --> 00:43:10.290
in terms of implementing
digital filters.

00:43:10.290 --> 00:43:12.930
Thank you.

00:43:12.930 --> 00:43:15.080
[MUSIC PLAYING]