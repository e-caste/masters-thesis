WEBVTT

00:00:00.000 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.730
Commons license.

00:00:03.730 --> 00:00:06.030
Your support will help
MIT OpenCourseWare

00:00:06.030 --> 00:00:10.060
continue to offer high quality
educational resources for free.

00:00:10.060 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.560
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.560 --> 00:00:17.892
at ocw.mit.edu.

00:00:22.155 --> 00:00:24.570
DAVID HARDT: Good morning,
everyone here in Cambridge,

00:00:24.570 --> 00:00:27.660
and happy holidays to
you guys in Singapore.

00:00:27.660 --> 00:00:28.650
What's the holiday?

00:00:28.650 --> 00:00:31.220
I had it on my PDA, but
I've forgotten what it is.

00:00:31.220 --> 00:00:32.580
Let's see if I can tell you.

00:00:35.100 --> 00:00:38.430
Labor Day, it's Labor
Day in Singapore.

00:00:38.430 --> 00:00:39.630
OK?

00:00:39.630 --> 00:00:42.360
Somebody was asking me when
Labor Day is in the US,

00:00:42.360 --> 00:00:44.500
and you think of
labor, of course,

00:00:44.500 --> 00:00:46.170
it means something
different than this.

00:00:46.170 --> 00:00:47.310
But do you think of
labor as something

00:00:47.310 --> 00:00:49.800
that's kind of onerous and
something you don't always

00:00:49.800 --> 00:00:51.450
look forward to doing.

00:00:51.450 --> 00:00:53.640
And that's, for an
academic at least,

00:00:53.640 --> 00:00:56.050
that's September, when you
have to go back to work.

00:00:56.050 --> 00:00:59.010
So it's in September in the US.

00:00:59.010 --> 00:01:00.630
OK.

00:01:00.630 --> 00:01:01.530
Excuse me.

00:01:01.530 --> 00:01:05.470
My voice is shot, so you may be
lucky, and I may finish early.

00:01:05.470 --> 00:01:10.910
It's never happened
before but might today.

00:01:10.910 --> 00:01:12.680
What I've been asked
to talk about today

00:01:12.680 --> 00:01:15.740
is this concept
of using feedback

00:01:15.740 --> 00:01:20.360
to improve the statistical
performance of a process,

00:01:20.360 --> 00:01:26.630
and it's got this title,
Cycle to Cycle Control.

00:01:26.630 --> 00:01:29.150
Just a little caveat,
this whole lecture

00:01:29.150 --> 00:01:32.030
and the material behind it
and two research projects

00:01:32.030 --> 00:01:36.470
that came out of it were spawned
about eight or nine years ago,

00:01:36.470 --> 00:01:39.800
when I was preparing a
lecture for this class,

00:01:39.800 --> 00:01:43.660
pre-internet transmission,
that kind of stuff.

00:01:43.660 --> 00:01:47.240
And I thought, gee, what
would happen if we--

00:01:47.240 --> 00:01:49.900
we used to do a lot of stuff on
feedback control in the class

00:01:49.900 --> 00:01:51.025
but for a different reason.

00:01:51.025 --> 00:01:53.470
I said, how about if we
applied it here and came up

00:01:53.470 --> 00:01:55.742
with this idea of
cycle to cycle control.

00:01:55.742 --> 00:01:57.700
One of the problems was,
of course, I found out

00:01:57.700 --> 00:01:58.930
that it was old material.

00:01:58.930 --> 00:02:00.760
It was actually
hidden in textbooks.

00:02:00.760 --> 00:02:03.240
It was treated in
a different way.

00:02:03.240 --> 00:02:06.100
So this is, let's just
say, a different spin

00:02:06.100 --> 00:02:09.699
on a somewhat well-known
topic but usually

00:02:09.699 --> 00:02:14.230
under the heading of advanced
material on the use of feedback

00:02:14.230 --> 00:02:19.090
control in the context of a
statistical process control

00:02:19.090 --> 00:02:19.792
problem.

00:02:19.792 --> 00:02:22.000
Now, I'm going to go through
a couple of slides which

00:02:22.000 --> 00:02:29.130
were from day one of the
class, and to emphasize,

00:02:29.130 --> 00:02:31.950
I think what we said back then
is that, in effect, there's

00:02:31.950 --> 00:02:33.910
always feedback going on.

00:02:33.910 --> 00:02:38.040
Now, most of the stuff we've
done in the class so far on SPC

00:02:38.040 --> 00:02:41.400
and designed experiments has
been, in the classical feedback

00:02:41.400 --> 00:02:42.630
control sense, open loop.

00:02:42.630 --> 00:02:45.930
You do something, you
record what happens,

00:02:45.930 --> 00:02:50.950
but there's no necessarily
algorithmic approach to saying,

00:02:50.950 --> 00:02:53.310
OK, what if it's not right?

00:02:53.310 --> 00:02:56.010
I don't what Professor
Bohning said about SPC,

00:02:56.010 --> 00:02:58.830
but SPC doesn't
necessarily tell you

00:02:58.830 --> 00:03:02.220
what actions to do to
correct what's wrong.

00:03:02.220 --> 00:03:04.470
What it does is it
tells you the process

00:03:04.470 --> 00:03:07.980
is not following the model, the
statistical model that you had.

00:03:07.980 --> 00:03:12.180
And are designed experiments and
process optimization is indeed

00:03:12.180 --> 00:03:15.450
falls into the larger context
of open-loop optimization.

00:03:15.450 --> 00:03:20.460
How can I run a process in
effect unattended open loop

00:03:20.460 --> 00:03:25.200
and still have it be robust
to things trying to deter it

00:03:25.200 --> 00:03:28.320
from its proper course?

00:03:28.320 --> 00:03:30.290
We talked at the
beginning of the term

00:03:30.290 --> 00:03:33.320
about this idea of the general
process control problem,

00:03:33.320 --> 00:03:37.520
and I'm sure you remember
like it was yesterday

00:03:37.520 --> 00:03:43.140
that I referred to this process
control loop is the Holy Grail.

00:03:43.140 --> 00:03:45.463
Boy, if we could do that,
all this other stuff

00:03:45.463 --> 00:03:46.130
wouldn't matter.

00:03:46.130 --> 00:03:48.482
Because it would mean that
I would have in some way

00:03:48.482 --> 00:03:50.690
the ability to interact with
a process and say here's

00:03:50.690 --> 00:03:51.950
what I want.

00:03:51.950 --> 00:03:54.050
Here's a dimension that I want.

00:03:54.050 --> 00:03:57.170
Maybe here's a variability
that I can tolerate.

00:03:57.170 --> 00:04:02.840
Here's a property strength or a
reactivity or something I want.

00:04:02.840 --> 00:04:07.190
If I simply measure it and
apply correctly feedback control

00:04:07.190 --> 00:04:12.080
principles, compare the two,
somehow with the magic control

00:04:12.080 --> 00:04:15.800
algorithm, everything
will be fine.

00:04:15.800 --> 00:04:18.649
And feedback control,
if it's successful,

00:04:18.649 --> 00:04:21.709
always seeks to make the
difference between those two

00:04:21.709 --> 00:04:24.900
close to zero and as
quickly as possible.

00:04:24.900 --> 00:04:28.580
So the concept of
process output control

00:04:28.580 --> 00:04:31.280
or controlling the product
geometry and properties

00:04:31.280 --> 00:04:33.330
was put forward.

00:04:33.330 --> 00:04:35.780
And at the time, we probably
said, but it doesn't work,

00:04:35.780 --> 00:04:38.190
or it can't happen,
or it's very rare.

00:04:38.190 --> 00:04:43.550
So what motivates this
particular concept is the idea

00:04:43.550 --> 00:04:47.432
that this is indeed
very hard to do,

00:04:47.432 --> 00:04:49.140
and it's very hard to
do for two reasons.

00:04:49.140 --> 00:04:53.120
One is you seldom can find out
what's wrong with the product,

00:04:53.120 --> 00:04:54.737
until it's too late.

00:04:54.737 --> 00:04:56.570
When you think about
most of the processes--

00:04:56.570 --> 00:04:59.980
there are a few exceptions
to this-- but most processes,

00:04:59.980 --> 00:05:01.780
semiconductor is
a great example,

00:05:01.780 --> 00:05:06.730
but every kind of mechanical
and thermal process around,

00:05:06.730 --> 00:05:10.460
basically you have to make
something, put it down,

00:05:10.460 --> 00:05:11.230
oh, we're done.

00:05:11.230 --> 00:05:11.500
OK.

00:05:11.500 --> 00:05:12.040
Let's measure it.

00:05:12.040 --> 00:05:12.670
Did it fit?

00:05:12.670 --> 00:05:14.770
Is it the right shape?

00:05:14.770 --> 00:05:16.390
Does it have the
right properties?

00:05:16.390 --> 00:05:17.270
And it's too late.

00:05:17.270 --> 00:05:20.410
So if it's wrong,
what do you do?

00:05:20.410 --> 00:05:21.422
OK?

00:05:21.422 --> 00:05:22.450
So what do you do?

00:05:22.450 --> 00:05:25.480
If you run the process, you pick
up the product, you measure it,

00:05:25.480 --> 00:05:26.680
it's not right.

00:05:26.680 --> 00:05:27.698
What do you do?

00:05:27.698 --> 00:05:28.990
It's not a rhetorical question.

00:05:28.990 --> 00:05:30.550
It's a question.

00:05:30.550 --> 00:05:32.297
What do I do?

00:05:32.297 --> 00:05:33.297
AUDIENCE: Throw it away.

00:05:33.297 --> 00:05:34.580
Or redo your work.

00:05:34.580 --> 00:05:36.440
DAVID HARDT: Throw it away.

00:05:36.440 --> 00:05:39.280
Rework it.

00:05:39.280 --> 00:05:41.260
And that's what we do now right.

00:05:41.260 --> 00:05:44.175
You got pass/fail, throw it
away if it's a low value added.

00:05:44.175 --> 00:05:45.550
If it's a high
value added thing,

00:05:45.550 --> 00:05:47.425
like an airplane or
something like that, then

00:05:47.425 --> 00:05:48.910
you do rework it.

00:05:48.910 --> 00:05:49.780
Richard, what else?

00:05:49.780 --> 00:05:51.822
AUDIENCE: Well, if the
[INAUDIBLE] is big enough,

00:05:51.822 --> 00:05:55.240
or the production
is big enough, you

00:05:55.240 --> 00:05:57.160
could try to adjust
your process.

00:05:57.160 --> 00:05:59.770
For example, when you have
a C and C turning process,

00:05:59.770 --> 00:06:01.300
you could try to
make adjustments

00:06:01.300 --> 00:06:02.500
for the true position.

00:06:02.500 --> 00:06:03.410
DAVID HARDT: Yep.

00:06:03.410 --> 00:06:03.910
Oh, yeah.

00:06:03.910 --> 00:06:06.143
So you can do all
three of those things.

00:06:06.143 --> 00:06:07.810
And what we're going
to talk about today

00:06:07.810 --> 00:06:10.750
is more towards what Richard
was saying, which is you learn.

00:06:10.750 --> 00:06:15.350
You take that as data and say,
oh, something's not right here.

00:06:15.350 --> 00:06:18.040
And the question now is we
can always take that data--

00:06:18.040 --> 00:06:20.510
and I made it sound black
or white-- it's a good part

00:06:20.510 --> 00:06:21.640
or it's a bad part.

00:06:21.640 --> 00:06:23.470
But indeed, as you know, is it--

00:06:23.470 --> 00:06:25.420
from the concept of
process capability,

00:06:25.420 --> 00:06:28.070
is it falling where
I expected it to?

00:06:28.070 --> 00:06:30.700
Is it falling outside there
or is it tending there--

00:06:30.700 --> 00:06:31.720
to there?

00:06:31.720 --> 00:06:34.480
And how quickly
do I take action?

00:06:34.480 --> 00:06:37.840
Now, SPC in general is
about-- you, in effect,

00:06:37.840 --> 00:06:40.870
sit back, measure the
statistical performance

00:06:40.870 --> 00:06:45.200
of the process and say, OK,
is this matching my model?

00:06:45.200 --> 00:06:46.660
If it's not, pull the cord.

00:06:46.660 --> 00:06:49.300
Make some changes.

00:06:49.300 --> 00:06:50.050
Something's wrong.

00:06:50.050 --> 00:06:51.400
Investigate.

00:06:51.400 --> 00:06:54.260
What we're going to talk about
today is the extreme of that,

00:06:54.260 --> 00:06:57.880
which is to say every single
part that comes out we will

00:06:57.880 --> 00:07:00.270
assume should be correct.

00:07:00.270 --> 00:07:02.910
But it will be off
by some amount--

00:07:02.910 --> 00:07:06.420
based on that error,
on a production cycle

00:07:06.420 --> 00:07:08.280
to cycle basis.

00:07:08.280 --> 00:07:10.500
Every time we make
something, we'll measure it.

00:07:10.500 --> 00:07:14.350
Every time we measure it, we'll
compare it to the target value.

00:07:14.350 --> 00:07:18.070
And if it's wrong, we'll
make an adjustment.

00:07:18.070 --> 00:07:20.590
Now, I can guarantee you
there are a number of papers--

00:07:20.590 --> 00:07:23.080
many papers, probably
thousands-- hundreds,

00:07:23.080 --> 00:07:24.490
I should say--

00:07:24.490 --> 00:07:29.120
and many textbooks that will
tell you, that's crazy talk.

00:07:29.120 --> 00:07:36.320
It's nuts-- should never do
that, because you'll never

00:07:36.320 --> 00:07:38.360
you'll get it better.

00:07:38.360 --> 00:07:42.230
Now, based on what you know so
far about statistical processes

00:07:42.230 --> 00:07:47.000
and the nature of these
techniques that we've done,

00:07:47.000 --> 00:07:49.790
as well as a little bit
on physical processes,

00:07:49.790 --> 00:07:53.240
why would you imagine
the statistics community

00:07:53.240 --> 00:07:55.040
in particular would
have that attitude

00:07:55.040 --> 00:07:59.212
towards this approach of what
we call constant adjustment?

00:07:59.212 --> 00:08:00.920
Can you think why
that's not a good idea?

00:08:00.920 --> 00:08:01.500
Yeah?

00:08:01.500 --> 00:08:04.530
AUDIENCE: Instead of some
underlying median [INAUDIBLE]

00:08:04.530 --> 00:08:08.020
process, and you continuously
keep changing the mean,

00:08:08.020 --> 00:08:11.340
then you're
continuously changing

00:08:11.340 --> 00:08:13.410
the balance of the median.

00:08:13.410 --> 00:08:16.980
So unless it is
statistically significant

00:08:16.980 --> 00:08:19.860
outside some bounds, I
guess they would object

00:08:19.860 --> 00:08:23.325
to making changes based
on something that's

00:08:23.325 --> 00:08:25.243
the normal expected means,

00:08:25.243 --> 00:08:25.910
DAVID HARDT: OK.

00:08:25.910 --> 00:08:27.590
Yeah, yeah.

00:08:27.590 --> 00:08:29.810
Richard-- same thing?

00:08:29.810 --> 00:08:31.840
Yeah, that's basically right.

00:08:31.840 --> 00:08:33.950
I'm going to state it a
little bit differently.

00:08:33.950 --> 00:08:37.632
Everything could be
fine, and your process

00:08:37.632 --> 00:08:39.299
is following a nice
normal distribution,

00:08:39.299 --> 00:08:41.355
and here's your target--

00:08:41.355 --> 00:08:43.230
basically says you will
always have an error.

00:08:43.230 --> 00:08:44.370
It will always be wrong.

00:08:44.370 --> 00:08:47.880
You'll always be
adjusting the process.

00:08:47.880 --> 00:08:51.180
It's the concept of a
dog chasing its tail.

00:08:51.180 --> 00:08:53.350
How can that possibly
make it better?

00:08:53.350 --> 00:08:54.690
So they just say, don't do it.

00:08:54.690 --> 00:08:56.490
And they're actually
studies out there.

00:08:56.490 --> 00:08:57.907
There's a wonderful
study that was

00:08:57.907 --> 00:09:03.300
done by a professor at
Harvard Business School on--

00:09:03.300 --> 00:09:05.970
I've forgotten what the--
do you know this one?

00:09:05.970 --> 00:09:07.364
The [INAUDIBLE]?

00:09:10.050 --> 00:09:13.890
I think it was a big basic
material, basic mineral

00:09:13.890 --> 00:09:16.370
processing plant, one of
these huge things with lots

00:09:16.370 --> 00:09:17.370
of different set points.

00:09:17.370 --> 00:09:19.890
And the operators had
control over this thing,

00:09:19.890 --> 00:09:21.792
and they were always
looking at things.

00:09:21.792 --> 00:09:23.250
And they could type
the new numbers

00:09:23.250 --> 00:09:25.920
and change the change the
set points in the plant,

00:09:25.920 --> 00:09:27.420
and that sort of
thing, and they all

00:09:27.420 --> 00:09:30.990
had their idea of how
they could make it better.

00:09:30.990 --> 00:09:34.800
And he had this hypothesis that
they were chasing their tail.

00:09:34.800 --> 00:09:36.330
They were looking
at these things,

00:09:36.330 --> 00:09:38.600
and they were always
adjusting the process.

00:09:38.600 --> 00:09:42.283
So one day, with the
concurrence of the management,

00:09:42.283 --> 00:09:43.700
from the operator's
point of view,

00:09:43.700 --> 00:09:46.330
everything was still the
same, but they disconnected it

00:09:46.330 --> 00:09:48.130
so that the operators
were making changes

00:09:48.130 --> 00:09:50.890
to all the set points in
the machines-- nothing

00:09:50.890 --> 00:09:52.840
was actually changing.

00:09:52.840 --> 00:09:55.760
And guess what happened.

00:09:55.760 --> 00:09:57.020
It got better.

00:09:57.020 --> 00:09:59.000
The variance went down.

00:09:59.000 --> 00:10:01.940
And so that kind of
circumstantial stuff says,

00:10:01.940 --> 00:10:03.260
OK, it is crazy talk.

00:10:03.260 --> 00:10:06.860
Why should I bother to do that?

00:10:06.860 --> 00:10:10.530
But-- there's an important
but here-- is that,

00:10:10.530 --> 00:10:12.930
if that's all the
information you have--

00:10:12.930 --> 00:10:19.300
if your idea is, OK, based on
the error, make an adjustment,

00:10:19.300 --> 00:10:21.990
if you have any schooling
in feedback control,

00:10:21.990 --> 00:10:25.510
you know that just closing
the loop is not success.

00:10:25.510 --> 00:10:27.330
In fact, closing the
loop, as I was once

00:10:27.330 --> 00:10:29.470
chastised by one
of my professors--

00:10:29.470 --> 00:10:32.700
all that guarantees is that you
can take a nice stable process

00:10:32.700 --> 00:10:34.852
and eventually make
it go unstable.

00:10:34.852 --> 00:10:36.810
But you have to close
the loop with a knowledge

00:10:36.810 --> 00:10:38.790
of what's going on and
a knowledge of what

00:10:38.790 --> 00:10:39.532
the limits are.

00:10:39.532 --> 00:10:41.490
And in the end, what that
means is you've got--

00:10:41.490 --> 00:10:43.800
if you're going to have an
operator making adjustments

00:10:43.800 --> 00:10:45.720
to the process based
on measurements,

00:10:45.720 --> 00:10:49.560
they should have some basis--

00:10:49.560 --> 00:10:50.530
for a basis for that.

00:10:50.530 --> 00:10:52.650
So that's what this
whole thing is about is,

00:10:52.650 --> 00:10:57.600
what is that basis, and
how good could it be?

00:10:57.600 --> 00:10:58.100
OK.

00:11:03.610 --> 00:11:04.690
OK, wake up now.

00:11:08.510 --> 00:11:09.800
All right.

00:11:09.800 --> 00:11:13.370
And just to tie this back
in with what we talked about

00:11:13.370 --> 00:11:16.350
in the beginning, if you look
at this variability equation--

00:11:16.350 --> 00:11:18.517
which, I don't know how
much you've used that during

00:11:18.517 --> 00:11:22.160
the term-- it's not important--
but the whole idea is that what

00:11:22.160 --> 00:11:25.070
we'd like to do is
change the variability,

00:11:25.070 --> 00:11:27.260
reduce the variability
of a process,

00:11:27.260 --> 00:11:28.400
and we'd like to do it--

00:11:28.400 --> 00:11:32.060
SPC does it by reducing
the disturbance,

00:11:32.060 --> 00:11:34.490
design experiments does it
reducing the sensitivity,

00:11:34.490 --> 00:11:38.550
and feedback control does it by
trying to offset the problems.

00:11:38.550 --> 00:11:41.240
So if there is something
that's causing a mean shift,

00:11:41.240 --> 00:11:44.870
you want to push it back
by making an offset change,

00:11:44.870 --> 00:11:47.330
and that's all that
this is relating to.

00:11:50.030 --> 00:11:52.603
And so in effect, we
get to the third level

00:11:52.603 --> 00:11:54.270
of this process control
hierarchy that--

00:11:54.270 --> 00:11:56.930
talked about on day 1, which
is-- the first one is basically

00:11:56.930 --> 00:11:59.480
good housekeeping, standard
operating procedures,

00:11:59.480 --> 00:12:01.940
statistical analysis,
and identification

00:12:01.940 --> 00:12:03.890
of whether everything
is in a state

00:12:03.890 --> 00:12:07.760
of stationary
statistical control.

00:12:07.760 --> 00:12:09.890
Second one is
reducing sensitivity

00:12:09.890 --> 00:12:11.120
or increasing robustness.

00:12:11.120 --> 00:12:15.260
That's the whole
designed experiment area.

00:12:15.260 --> 00:12:18.440
And then finally--
this gets it as good

00:12:18.440 --> 00:12:21.230
as it can be without
active manipulation--

00:12:21.230 --> 00:12:25.230
and then finally, we actively
manipulate and see what we do.

00:12:25.230 --> 00:12:28.130
So I do think I've come
to firmly believe--

00:12:28.130 --> 00:12:30.440
even though I came
to this whole thing

00:12:30.440 --> 00:12:33.590
from a feedback control can
solve any problem in the world

00:12:33.590 --> 00:12:35.390
point of view--

00:12:35.390 --> 00:12:38.900
this is the last thing you do
after you've tried these far

00:12:38.900 --> 00:12:44.990
cheaper, far more robust,
and far more, in some ways,

00:12:44.990 --> 00:12:50.350
in depth knowledge of
the process approaches.

00:12:50.350 --> 00:12:54.802
OK, so I have to take
a moment to just review

00:12:54.802 --> 00:12:55.510
feedback control.

00:12:55.510 --> 00:12:57.843
How many of you guys have had
a feedback control course?

00:13:00.870 --> 00:13:03.510
OK.

00:13:03.510 --> 00:13:05.405
Hayden, you've never
had a feedback control--

00:13:05.405 --> 00:13:05.988
AUDIENCE: Yes.

00:13:05.988 --> 00:13:08.140
DAVID HARDT: OK.

00:13:08.140 --> 00:13:11.460
If the TA hasn't had the
course, we're in trouble.

00:13:11.460 --> 00:13:16.620
And we often use this generic
feedback control regulator

00:13:16.620 --> 00:13:18.512
approach, and I want
to do this because I'm

00:13:18.512 --> 00:13:20.220
going to use a little
bit of terminology.

00:13:20.220 --> 00:13:22.750
This is stuff we've
already used in the class,

00:13:22.750 --> 00:13:25.450
but I want to look at a
little bit differently.

00:13:25.450 --> 00:13:28.290
So let me just define
the terms here.

00:13:28.290 --> 00:13:31.240
Whoops-- this box right here--

00:13:31.240 --> 00:13:32.300
that's the process.

00:13:32.300 --> 00:13:33.700
That's the
manufacturing process.

00:13:33.700 --> 00:13:35.950
That's the machine, the
material, all that other stuff

00:13:35.950 --> 00:13:36.910
we talked about.

00:13:36.910 --> 00:13:39.880
And the input to that is
something that I can change--

00:13:39.880 --> 00:13:42.730
temperature, pressure,
a feed, a time--

00:13:42.730 --> 00:13:43.960
something like that.

00:13:43.960 --> 00:13:46.570
The output of the process is
the output of the process.

00:13:46.570 --> 00:13:48.967
It's what we care about.

00:13:48.967 --> 00:13:51.550
Actually, I'm going to put the
output of the process over here

00:13:51.550 --> 00:13:54.270
for the moment.

00:13:54.270 --> 00:13:57.720
The key thing is
that the process--

00:13:57.720 --> 00:14:00.090
there are two things
that make the process not

00:14:00.090 --> 00:14:01.880
always do the same thing.

00:14:01.880 --> 00:14:04.650
In other words, if I hold the
inputs the same all the time,

00:14:04.650 --> 00:14:05.730
the output still varies.

00:14:05.730 --> 00:14:06.900
We know that.

00:14:06.900 --> 00:14:09.960
We know that from SPC. You know
it from data that you've taken.

00:14:09.960 --> 00:14:12.540
Where is that other
thing coming from?

00:14:12.540 --> 00:14:15.420
Well, in a control system
sense, one of the sources

00:14:15.420 --> 00:14:16.700
is the disturbance.

00:14:16.700 --> 00:14:20.490
We just kind of think of it
as an external factor, this D1

00:14:20.490 --> 00:14:22.500
or D2.

00:14:22.500 --> 00:14:25.620
The classic example of
that is a flight control,

00:14:25.620 --> 00:14:28.700
altitude, autopilot.

00:14:28.700 --> 00:14:30.450
What's a good disturbance
to an autopilot?

00:14:30.450 --> 00:14:32.580
Well, a wind current
or something like that

00:14:32.580 --> 00:14:34.140
is external to the machine.

00:14:34.140 --> 00:14:38.910
It causes it to change and
causes the output of the flight

00:14:38.910 --> 00:14:40.500
control system to change.

00:14:40.500 --> 00:14:44.150
The purpose of the
controller in that case,

00:14:44.150 --> 00:14:46.210
and the purpose of the
controller primarily

00:14:46.210 --> 00:14:49.450
for manufacturing, is to
minimize the effective these

00:14:49.450 --> 00:14:50.110
disturbances.

00:14:50.110 --> 00:14:53.440
You'd like to make it look
like they aren't there so

00:14:53.440 --> 00:14:56.380
that you're flying the plane,
and wind's blowing up and down,

00:14:56.380 --> 00:14:57.760
and it still keeps going level.

00:14:57.760 --> 00:15:00.340
You're machining
something, and the material

00:15:00.340 --> 00:15:01.330
gets harder or softer.

00:15:01.330 --> 00:15:05.210
You just keep
going the same way.

00:15:05.210 --> 00:15:08.360
You're etching something,
and maybe your solution

00:15:08.360 --> 00:15:10.970
is losing strength, but
it still etches enough--

00:15:10.970 --> 00:15:13.670
all those sorts of things.

00:15:13.670 --> 00:15:15.980
That's a standard way of
modeling things in control,

00:15:15.980 --> 00:15:19.620
and that's the way we'll
do it for this approach.

00:15:19.620 --> 00:15:22.490
In fact, what happens more often
than not in manufacturing--

00:15:22.490 --> 00:15:26.660
it's captured by this
crazy little arrow here,

00:15:26.660 --> 00:15:28.520
the dark one, which
basically says, yeah,

00:15:28.520 --> 00:15:31.250
well, this input-output
relationship

00:15:31.250 --> 00:15:33.920
between the settings
on the machine

00:15:33.920 --> 00:15:36.988
and the output of the material
is, in fact, never a constant.

00:15:36.988 --> 00:15:38.780
We're always putting
in different material.

00:15:38.780 --> 00:15:40.260
The machine is
changing over time.

00:15:40.260 --> 00:15:42.740
This is all the stuff we
talked about in the first days.

00:15:42.740 --> 00:15:44.960
So in fact, we have two
types of disturbances--

00:15:44.960 --> 00:15:48.620
these external ones and
these internal ones.

00:15:48.620 --> 00:15:51.110
The problem is that, from
a control system theory

00:15:51.110 --> 00:15:54.110
point of view, the external ones
are easy to model and analyze.

00:15:54.110 --> 00:15:58.910
The internal ones are very
uneasy to model and analyze.

00:15:58.910 --> 00:16:02.120
So we will actually
look more at this one,

00:16:02.120 --> 00:16:06.850
even though we'll pretend that
we're looking at both of these.

00:16:06.850 --> 00:16:08.700
So again, the purpose
of the control system

00:16:08.700 --> 00:16:14.100
is to make this output
quantity stay exactly

00:16:14.100 --> 00:16:16.500
in line with what the
input quantity is,

00:16:16.500 --> 00:16:19.080
which, of course, would be some
sort of a desired dimension--

00:16:19.080 --> 00:16:19.913
something like that.

00:16:29.300 --> 00:16:32.000
Again, if any of you have
studied control systems

00:16:32.000 --> 00:16:34.580
in any advanced way, we
have this-- one aspect

00:16:34.580 --> 00:16:37.160
of control systems is
called stochastic control

00:16:37.160 --> 00:16:41.032
systems, which is where the
control theory actually assumes

00:16:41.032 --> 00:16:43.490
that the variables that you're
controlling and other things

00:16:43.490 --> 00:16:45.480
have some randomness
associated with it.

00:16:45.480 --> 00:16:49.380
Most control is done, of course,
for deterministic quantities,

00:16:49.380 --> 00:16:52.280
but in fact, most things
have these random components.

00:16:52.280 --> 00:16:56.270
And when you do that,
you find that what

00:16:56.270 --> 00:17:00.290
you're taught on that is
that, well, if I use feedback,

00:17:00.290 --> 00:17:04.490
I can minimize mean
shifts in the process,

00:17:04.490 --> 00:17:06.470
or mean shifts in
the disturbance.

00:17:06.470 --> 00:17:10.160
And I can often reduce
so-called dynamic disturbances.

00:17:10.160 --> 00:17:12.260
If things are changing
from time to time,

00:17:12.260 --> 00:17:14.220
I should be able
to reduce those.

00:17:14.220 --> 00:17:17.060
So if I translate
that into the lexicon

00:17:17.060 --> 00:17:19.369
of this class, that kind
of means-- well, look here.

00:17:19.369 --> 00:17:20.900
Here's a distribution.

00:17:20.900 --> 00:17:24.970
Let me-- I'm drawing too
many lines here, hang on.

00:17:24.970 --> 00:17:32.880
I can't-- This
distribution on the left--

00:17:32.880 --> 00:17:36.060
well, first of all, let me point
out what I tried to draw here.

00:17:36.060 --> 00:17:38.550
Here you see this is your
process capability window.

00:17:38.550 --> 00:17:40.490
That's where you want to be.

00:17:40.490 --> 00:17:42.440
So ideally, we're
centered on that, and well

00:17:42.440 --> 00:17:44.570
within the bounds of that.

00:17:44.570 --> 00:17:48.130
Imagine you have a process
that's operating over here.

00:17:48.130 --> 00:17:52.360
So it's obviously got
terrible process capability.

00:17:52.360 --> 00:17:54.970
The mean is way
over here, and even

00:17:54.970 --> 00:17:57.693
if I were to send it
within the target window,

00:17:57.693 --> 00:17:59.110
it would probably
be outside that,

00:17:59.110 --> 00:18:02.120
and I'd have a low
process capability.

00:18:02.120 --> 00:18:04.780
So wouldn't it be nice
to have a controller that

00:18:04.780 --> 00:18:08.220
can take this
distribution, center it,

00:18:08.220 --> 00:18:10.028
and even make it narrower?

00:18:10.028 --> 00:18:12.570
Well, there's a suggestion that
feedback control can do that,

00:18:12.570 --> 00:18:15.390
because we know we can eliminate
mean errors with feedback

00:18:15.390 --> 00:18:16.430
control.

00:18:16.430 --> 00:18:18.660
The question is, what
happens with the variance?

00:18:18.660 --> 00:18:23.010
And as we thought about this
idea of chasing your tail--

00:18:23.010 --> 00:18:28.250
excuse me-- how can I be
measuring a random variable,

00:18:28.250 --> 00:18:30.290
particularly an uncorrelated
random variable,

00:18:30.290 --> 00:18:33.290
and use that knowledge
to actually reduce

00:18:33.290 --> 00:18:35.070
the degree of randomness?

00:18:35.070 --> 00:18:36.520
Keep thinking about that.

00:18:36.520 --> 00:18:38.560
But we can analyze it,
and then, of course,

00:18:38.560 --> 00:18:42.513
the proof of the pudding will
be to actually do an experiment.

00:18:49.016 --> 00:18:53.248
Oops-- OK, so what do
we want to look at--

00:18:53.248 --> 00:18:55.540
in trying to understand this,
what kind of disturbances

00:18:55.540 --> 00:18:58.540
do we expect to see, or how do
we want to model disturbances?

00:18:58.540 --> 00:19:01.450
Well, we know so far that,
to capture the process,

00:19:01.450 --> 00:19:04.480
we're going to have to model
disturbances as being random.

00:19:04.480 --> 00:19:07.600
Our whole premise for
the statistical models

00:19:07.600 --> 00:19:11.120
is that the process has some
randomness associated with it.

00:19:11.120 --> 00:19:14.470
And then we have things
like unexpected mean shifts,

00:19:14.470 --> 00:19:18.400
which, in control lexicon,
we call infrequent stepwise.

00:19:18.400 --> 00:19:20.680
And then we might have
things like tool wear

00:19:20.680 --> 00:19:24.260
or just degradation of
solutions and things over time,

00:19:24.260 --> 00:19:30.340
and so there's a slowly
varying change of the process.

00:19:30.340 --> 00:19:31.660
And then, of course, cyclic--

00:19:31.660 --> 00:19:35.290
things that are happening
because of shift changes, time

00:19:35.290 --> 00:19:37.460
of day, other things like that.

00:19:37.460 --> 00:19:39.130
It would be nice to
deal with all those.

00:19:39.130 --> 00:19:41.380
For the moment, we're
going to deal primarily

00:19:41.380 --> 00:19:46.890
with infrequent stepwise
random disturbances.

00:19:46.890 --> 00:19:49.620
There are more
advanced topics on this

00:19:49.620 --> 00:19:51.210
that will deal with
these too, but we

00:19:51.210 --> 00:19:52.335
won't get into those today.

00:19:55.170 --> 00:19:58.440
OK, so cycle-to-cycle
control is simply

00:19:58.440 --> 00:20:02.020
defined as doing the best
you can with this situation

00:20:02.020 --> 00:20:04.030
that we have now.

00:20:04.030 --> 00:20:06.760
So the ideal thing is to have
a full measure of how you're

00:20:06.760 --> 00:20:08.600
doing on your production.

00:20:08.600 --> 00:20:10.270
You can always make
that measurement

00:20:10.270 --> 00:20:14.943
after the cycle of
production has finished.

00:20:14.943 --> 00:20:16.360
Maybe an injection
molding machine

00:20:16.360 --> 00:20:18.190
is a good model for
this, or something

00:20:18.190 --> 00:20:20.170
that happens kind of
quick, or a metal stamping

00:20:20.170 --> 00:20:23.560
operation or high-speed forging
operation-- any of these things

00:20:23.560 --> 00:20:26.320
where you can't get in
there with your gauge

00:20:26.320 --> 00:20:28.810
while it's happening,
unless you're crazy.

00:20:28.810 --> 00:20:31.630
And even if you did, you
wouldn't-- it wouldn't tell you

00:20:31.630 --> 00:20:33.100
what you wanted to know.

00:20:33.100 --> 00:20:35.050
Like an injection molded part--

00:20:35.050 --> 00:20:37.465
until it's popped out-- in
fact, until it's cooled off,

00:20:37.465 --> 00:20:38.590
you don't know how you did.

00:20:41.660 --> 00:20:44.470
So it's finally
there, you measure it,

00:20:44.470 --> 00:20:47.510
and then you say, oh, I
have to make a change.

00:20:47.510 --> 00:20:48.970
Can I make a change?

00:20:48.970 --> 00:20:51.730
And most machines will allow
you to make a change somewhere.

00:20:51.730 --> 00:20:53.620
You did your
designed experiments,

00:20:53.620 --> 00:20:55.330
and the whole idea
of that was to say,

00:20:55.330 --> 00:20:58.210
what are the significant inputs
to change significantly--

00:20:58.210 --> 00:21:00.800
have a significant
change in the output?

00:21:00.800 --> 00:21:02.710
So we find out what
those significant ones

00:21:02.710 --> 00:21:04.097
are and try to match them.

00:21:04.097 --> 00:21:05.680
So if the dimension
is wrong, you say,

00:21:05.680 --> 00:21:09.590
OK, here's what I want
to adjust to change it.

00:21:09.590 --> 00:21:11.840
Now, the key thing is this--

00:21:11.840 --> 00:21:13.775
or think of it this way.

00:21:13.775 --> 00:21:15.650
Take injection molding,
because I'll give you

00:21:15.650 --> 00:21:17.900
some data on that in a moment.

00:21:17.900 --> 00:21:19.370
You set it up.

00:21:19.370 --> 00:21:20.510
You run a part.

00:21:20.510 --> 00:21:21.920
You take it onto the bench.

00:21:21.920 --> 00:21:23.390
You measure it.

00:21:23.390 --> 00:21:25.900
You say, it's not right.

00:21:25.900 --> 00:21:30.940
How soon can I make a change
in the process to improve it?

00:21:30.940 --> 00:21:34.730
Next cycle-- so before I say go
again, I make a little change.

00:21:34.730 --> 00:21:37.127
I increase the hold time,
I decrease the pressure--

00:21:37.127 --> 00:21:37.960
something like that.

00:21:37.960 --> 00:21:39.340
Then I say, go.

00:21:39.340 --> 00:21:43.870
And I keep doing that, and
it's cycle to cycle the cycle.

00:21:43.870 --> 00:21:47.630
But within each cycle, when
I say change the whole time

00:21:47.630 --> 00:21:52.440
or I say change the pressure,
during the actual cycle

00:21:52.440 --> 00:21:55.500
of injection-- of melding,
and injecting, and cooling

00:21:55.500 --> 00:21:57.810
the material, nothing changes.

00:21:57.810 --> 00:22:00.690
So from the injection molding
machine process point of view,

00:22:00.690 --> 00:22:03.405
it's still this
fixed input process.

00:22:05.820 --> 00:22:07.070
So that's the important thing.

00:22:07.070 --> 00:22:11.360
The dynamics occurs between the
cycles, not during the cycles.

00:22:11.360 --> 00:22:13.280
So what this allows
us to do is treat this

00:22:13.280 --> 00:22:17.510
as a very simple digital control
system, or discrete control

00:22:17.510 --> 00:22:18.420
system.

00:22:18.420 --> 00:22:22.220
So in discrete control
theory concepts,

00:22:22.220 --> 00:22:24.920
things only happen in an
instantaneous period in time.

00:22:24.920 --> 00:22:26.910
Nothing happens in between.

00:22:26.910 --> 00:22:29.030
So we've got a nice
match between the theory

00:22:29.030 --> 00:22:32.890
and what's actually happening.

00:22:32.890 --> 00:22:36.580
And so we execute this
loop once every cycle.

00:22:36.580 --> 00:22:40.060
Now, you may be saying, jeez,
do we have to measure it

00:22:40.060 --> 00:22:40.810
after every cycle?

00:22:40.810 --> 00:22:42.377
What about every 10th cycle?

00:22:42.377 --> 00:22:43.960
Maybe it's going to
take too much time

00:22:43.960 --> 00:22:46.502
to make the measurement and slow
the process down, and so on.

00:22:46.502 --> 00:22:48.610
Fine-- we can put
those multipliers in.

00:22:48.610 --> 00:22:52.120
But the fastest we could ever
do it would be one cycle--

00:22:52.120 --> 00:22:55.333
one measurement per cycle.

00:22:55.333 --> 00:22:57.000
Well, this is where
we found out that we

00:22:57.000 --> 00:22:59.310
had reinvented the wheel--
or uninvented the wheel,

00:22:59.310 --> 00:23:00.990
or something like that.

00:23:00.990 --> 00:23:04.200
Within the
semiconductor industry,

00:23:04.200 --> 00:23:06.180
there's this concept
of run-by-run control,

00:23:06.180 --> 00:23:08.160
where you've got a recipe,
you run the process,

00:23:08.160 --> 00:23:10.350
you make a measurement,
you say it's not right--

00:23:10.350 --> 00:23:11.608
let's change the recipe--

00:23:11.608 --> 00:23:12.400
that sort of thing.

00:23:12.400 --> 00:23:15.250
It's given the title
run-by-run control.

00:23:15.250 --> 00:23:18.840
And I think even, if you look
in the text on Montgomery--

00:23:18.840 --> 00:23:21.750
and I don't remember
what chapter

00:23:21.750 --> 00:23:23.618
it's in-- there's
something in there about--

00:23:23.618 --> 00:23:24.660
forgot the term he used--

00:23:24.660 --> 00:23:26.790
I think he calls it
feedback control.

00:23:26.790 --> 00:23:29.100
But there is some
discussion of this.

00:23:29.100 --> 00:23:33.240
And there are some
larger theoretical tracks

00:23:33.240 --> 00:23:36.960
around that talk about the
concept of a discrete control

00:23:36.960 --> 00:23:40.460
system like this.

00:23:40.460 --> 00:23:42.790
So what is it we're
really trying to do?

00:23:42.790 --> 00:23:44.950
Well, to use, again, the
terminology of the class,

00:23:44.950 --> 00:23:47.320
we would like to reduce
the expected loss function

00:23:47.320 --> 00:23:53.590
or increase a measure of process
capability with feedback.

00:23:53.590 --> 00:23:57.880
So ultimately, as I said, if
our goal is to go, say, from--

00:23:57.880 --> 00:24:03.840
if we have a target that looks
like that and we have a process

00:24:03.840 --> 00:24:08.850
that's over here
somewhere-- oops--

00:24:08.850 --> 00:24:10.278
it's not very
[INAUDIBLE] looking.

00:24:14.410 --> 00:24:21.130
If we can make the process
look more like that,

00:24:21.130 --> 00:24:23.860
we will have increased
our process capability

00:24:23.860 --> 00:24:25.720
or decreased our process--

00:24:25.720 --> 00:24:27.530
our expected loss.

00:24:27.530 --> 00:24:31.190
And we can think of that,
again, with our two major goals.

00:24:31.190 --> 00:24:34.840
One is to reduce mean
shift to zero, if possible,

00:24:34.840 --> 00:24:36.678
and decrease the variance.

00:24:36.678 --> 00:24:37.720
Now, this is a bit of a--

00:24:44.962 --> 00:24:47.170
I can't think of the word
I'm trying to come up with.

00:24:47.170 --> 00:24:51.180
Anyway, it's-- we're looking
to the future of what's going

00:24:51.180 --> 00:24:52.620
to happen with the results here.

00:24:55.580 --> 00:24:57.740
What if I have a process
that's over here,

00:24:57.740 --> 00:25:00.920
and I'm able to recenter it
without reducing the variance?

00:25:00.920 --> 00:25:03.680
Is that a good thing?

00:25:03.680 --> 00:25:04.600
Yeah.

00:25:04.600 --> 00:25:05.500
OK.

00:25:05.500 --> 00:25:08.290
What if I have a process
over here, and all I can do

00:25:08.290 --> 00:25:09.370
is recenter it--

00:25:09.370 --> 00:25:11.140
I can recenter it,
but at the cost

00:25:11.140 --> 00:25:13.270
of increasing the variance?

00:25:13.270 --> 00:25:15.285
Is that a good thing?

00:25:15.285 --> 00:25:16.410
Well, that sort of depends.

00:25:19.103 --> 00:25:21.270
I didn't tell you how much
I'm going to increase it.

00:25:21.270 --> 00:25:22.590
If I increase it
by a factor of 10,

00:25:22.590 --> 00:25:23.923
you'd probably say it's no good.

00:25:23.923 --> 00:25:26.790
And what if I could move it
over here, center the process,

00:25:26.790 --> 00:25:28.860
and reduce the variance
at the same time?

00:25:28.860 --> 00:25:32.530
Of course-- why
wouldn't that be great?

00:25:32.530 --> 00:25:36.680
So we're going to think
of those as objectives.

00:25:36.680 --> 00:25:43.340
Now, we have to go through this
to understand the derivation.

00:25:43.340 --> 00:25:47.000
And the punch line that I'm
going to come to is, hey,

00:25:47.000 --> 00:25:50.208
we can actually do
two of those three.

00:25:50.208 --> 00:25:52.250
I'm going to show you that
we can send her this--

00:25:52.250 --> 00:25:53.570
guarantee it--

00:25:53.570 --> 00:25:56.750
I love that-- seldom
get to say that.

00:25:56.750 --> 00:25:59.970
But we can guarantee
that we can it,

00:25:59.970 --> 00:26:03.090
virtually under
any circumstance.

00:26:03.090 --> 00:26:08.810
And we can even tell you how
long it will take to center it,

00:26:08.810 --> 00:26:10.400
how many cycles--

00:26:10.400 --> 00:26:11.700
can always do that.

00:26:11.700 --> 00:26:13.880
And then there'll
be two extremes.

00:26:13.880 --> 00:26:16.790
In one extreme, I can
see it, but I will always

00:26:16.790 --> 00:26:19.130
increase the variance--

00:26:19.130 --> 00:26:22.130
but by a well-established,
bounded amount.

00:26:22.130 --> 00:26:25.828
So it's not going to be one
day 20 times, another day

00:26:25.828 --> 00:26:27.120
two times-- that sort of thing.

00:26:27.120 --> 00:26:28.790
It'll tell you exactly
how much it is.

00:26:28.790 --> 00:26:30.748
In the other case-- the
better one, of course--

00:26:30.748 --> 00:26:34.510
I can center it and
reduce the variance.

00:26:34.510 --> 00:26:36.655
Now, the naysayers that
we talked about earlier,

00:26:36.655 --> 00:26:38.530
who would say, oh, don't
adjust the process--

00:26:38.530 --> 00:26:39.730
it'll only get worse--

00:26:39.730 --> 00:26:41.980
we're right, in the
sense that, if I

00:26:41.980 --> 00:26:44.470
just the process and center
the mean, but increase

00:26:44.470 --> 00:26:47.820
the variance, by one
measure of goodness,

00:26:47.820 --> 00:26:49.130
things have gotten worse.

00:26:49.130 --> 00:26:51.810
It's got more variability.

00:26:51.810 --> 00:26:54.150
And we can see,
more heuristically

00:26:54.150 --> 00:26:57.180
than theoretically, why that,
in fact, has to be true.

00:26:57.180 --> 00:27:02.370
But again, if it's bounded
and we know what's going on,

00:27:02.370 --> 00:27:04.030
maybe it's better.

00:27:04.030 --> 00:27:06.130
Maybe it's a lot better.

00:27:06.130 --> 00:27:10.203
OK, so how do we
actually get to use this?

00:27:10.203 --> 00:27:12.120
And I'm going to go
through this real quickly,

00:27:12.120 --> 00:27:14.790
because again, if
you guys have seen

00:27:14.790 --> 00:27:17.880
feedback control in its
basics, you probably

00:27:17.880 --> 00:27:20.340
did it for continuous systems,
and that doesn't really

00:27:20.340 --> 00:27:22.090
give you that much
insight into what we're

00:27:22.090 --> 00:27:24.030
going to be doing here.

00:27:24.030 --> 00:27:27.040
And there's some-- a
couple derivations here,

00:27:27.040 --> 00:27:28.830
which I will just zip
through and assume,

00:27:28.830 --> 00:27:31.205
if you're interested, you can
back and look at the notes.

00:27:31.205 --> 00:27:33.930
Oh yeah, before I forget--

00:27:33.930 --> 00:27:36.000
because I don't want to
wait until the punch line

00:27:36.000 --> 00:27:37.500
at the end--

00:27:37.500 --> 00:27:43.890
there are two papers that
I've put on the website that

00:27:43.890 --> 00:27:46.962
basically recite what
we're talking about--

00:27:46.962 --> 00:27:48.170
what I'm talking about here--

00:27:48.170 --> 00:27:53.010
paper that George Su and I
authored several years back.

00:27:53.010 --> 00:27:55.560
Well, George did his master's
thesis on this whole topic.

00:27:55.560 --> 00:28:00.590
He was a 2830 student the year
I kind of made up this lecture.

00:28:00.590 --> 00:28:03.000
Actually, it was a whole
section of the class back then.

00:28:03.000 --> 00:28:05.705
And he said, hey, that
would be interesting.

00:28:05.705 --> 00:28:07.080
Can I do a master's
thesis on it?

00:28:07.080 --> 00:28:08.760
I said yes, and he
did, and that's--

00:28:08.760 --> 00:28:11.580
a lot of the results I'm
going to talk about today

00:28:11.580 --> 00:28:12.460
are on that.

00:28:12.460 --> 00:28:19.240
And then we had a
particular problem in our--

00:28:19.240 --> 00:28:21.100
oh, great-- I just erased it.

00:28:21.100 --> 00:28:22.900
Well, there's a
second paper that's

00:28:22.900 --> 00:28:28.330
on there that Adam [INAUDIBLE]
did with me based on his PhD.

00:28:28.330 --> 00:28:32.060
And Adam was also a
student in the class, also

00:28:32.060 --> 00:28:35.160
a TA in the class, and
he wanted to say, well,

00:28:35.160 --> 00:28:39.040
what happens if I have a
really big complicated process?

00:28:39.040 --> 00:28:41.090
Instead of having one
input and one output,

00:28:41.090 --> 00:28:45.440
maybe it had 1,000 inputs
and 1,000 outputs--

00:28:45.440 --> 00:28:47.890
because we happened to have
one in our lab that fit that.

00:28:47.890 --> 00:28:50.317
And he said, maybe we can
make it work for this.

00:28:50.317 --> 00:28:51.650
So he did the extension to that.

00:28:51.650 --> 00:28:54.830
And that paper is
very brief version

00:28:54.830 --> 00:28:58.010
of what happens when
you try to extend it

00:28:58.010 --> 00:28:58.940
beyond what I've done.

00:29:02.355 --> 00:29:04.480
But it all requires that
we go through a little bit

00:29:04.480 --> 00:29:06.580
of the theory.

00:29:06.580 --> 00:29:10.470
So what am I trying to
represent with this diagram?

00:29:10.470 --> 00:29:13.920
I'll give you guys a test
of your control background.

00:29:13.920 --> 00:29:14.910
What is this?

00:29:18.500 --> 00:29:19.110
Richard--

00:29:19.110 --> 00:29:20.120
AUDIENCE: Step response?

00:29:20.120 --> 00:29:20.870
DAVID HARDT: Yeah.

00:29:20.870 --> 00:29:26.510
This is a classical,
highly simplified example

00:29:26.510 --> 00:29:30.350
of a-- the simplest dynamic
system you can have.

00:29:30.350 --> 00:29:33.350
And in the lexicon of
our class here, I've

00:29:33.350 --> 00:29:35.510
made a step change to an input.

00:29:35.510 --> 00:29:38.790
I instantaneously change the
pressure, temperature, feed--

00:29:38.790 --> 00:29:39.680
something like that.

00:29:39.680 --> 00:29:41.360
And what's the output do?

00:29:41.360 --> 00:29:43.980
Well, in real systems, they
don't change instantaneously.

00:29:43.980 --> 00:29:45.140
They have dynamics.

00:29:45.140 --> 00:29:47.390
And the simplest dynamics
would be something

00:29:47.390 --> 00:29:49.580
like this, a simple lag.

00:29:49.580 --> 00:29:51.450
This would be a
first-order linear system,

00:29:51.450 --> 00:29:54.660
and it takes four time
constants to settle out.

00:29:54.660 --> 00:29:57.300
And so there's an
important number here,

00:29:57.300 --> 00:29:59.930
which is what I'll call
the process time constant.

00:29:59.930 --> 00:30:01.395
How long does it
take the process

00:30:01.395 --> 00:30:03.770
to reach a steady state after
you've made a change to it?

00:30:03.770 --> 00:30:08.245
That's going to become an
important number for us.

00:30:08.245 --> 00:30:09.620
And then we have
the disturbance,

00:30:09.620 --> 00:30:11.828
which would be our randomized
and that sort of thing.

00:30:11.828 --> 00:30:16.470
But why do I care about
this steady state number?

00:30:16.470 --> 00:30:18.590
Why do I put this number
four times the time

00:30:18.590 --> 00:30:20.030
constant of there.

00:30:20.030 --> 00:30:20.780
Why do you think--

00:30:20.780 --> 00:30:22.400
given where we're going?

00:30:22.400 --> 00:30:25.130
We're only going to look at
the process after it's done.

00:30:25.130 --> 00:30:27.830
We're only going to make a
change between the processes.

00:30:32.818 --> 00:30:34.360
I'm only going to
look at the output.

00:30:34.360 --> 00:30:36.693
Think of it, we're going to
talk about a sampler in just

00:30:36.693 --> 00:30:37.220
a second.

00:30:37.220 --> 00:30:42.180
Sampler is a mathematical
concept, in effect,

00:30:42.180 --> 00:30:44.700
based on a delta function
that says, here's

00:30:44.700 --> 00:30:46.730
a continuous number.

00:30:46.730 --> 00:30:49.230
I'm going to sample it and look
at it for an infinitesimally

00:30:49.230 --> 00:30:51.370
small period of time.

00:30:51.370 --> 00:30:53.188
So I'm going to do
this to the output.

00:30:53.188 --> 00:30:54.980
So I'm going to make
a change, and then I'm

00:30:54.980 --> 00:30:56.120
going to sample the output.

00:30:56.120 --> 00:30:57.927
When do I want to
sample the output?

00:30:57.927 --> 00:30:59.260
AUDIENCE: After it's stabilized.

00:30:59.260 --> 00:31:01.750
DAVID HARDT: After
it's stabilized--

00:31:01.750 --> 00:31:06.100
all right, so conceptually, if
I have a process that has this

00:31:06.100 --> 00:31:10.660
speed to it, and I make sure
I always sample it after

00:31:10.660 --> 00:31:14.652
it's reached this steady state--
after a stepwise change--

00:31:14.652 --> 00:31:17.110
what does the process look
like, from an input-output point

00:31:17.110 --> 00:31:17.610
of view?

00:31:20.190 --> 00:31:22.860
Constant input gives
me a constant output.

00:31:22.860 --> 00:31:25.170
I don't see any dynamics.

00:31:25.170 --> 00:31:27.240
I don't see any of
this stuff in between.

00:31:27.240 --> 00:31:29.640
And can you see that
then, if I looked

00:31:29.640 --> 00:31:31.755
at a lot of different inputs--

00:31:31.755 --> 00:31:34.380
let the output all go to steady
state, looked at all the sample

00:31:34.380 --> 00:31:34.880
ones--

00:31:34.880 --> 00:31:38.190
I basically have a bunch of
inputs, a bunch of outputs.

00:31:38.190 --> 00:31:41.880
And what would be the simplest
relationship between those two?

00:31:46.010 --> 00:31:47.660
You just did your
designed experiments.

00:31:47.660 --> 00:31:49.490
What's the simplest
relationship that you

00:31:49.490 --> 00:31:54.330
could have between a single
input, a single output?

00:31:54.330 --> 00:31:57.290
Yeah-- straight
line, linear fit.

00:31:57.290 --> 00:31:59.440
And that's a great
first place for us

00:31:59.440 --> 00:32:00.500
to start with this model.

00:32:00.500 --> 00:32:03.070
So the nice thing is, with
the cycle-to-cycle control,

00:32:03.070 --> 00:32:05.870
I can take a process
that could be, in fact,

00:32:05.870 --> 00:32:07.930
a lot more complicated by this--

00:32:07.930 --> 00:32:09.790
than this, and just say, sorry.

00:32:09.790 --> 00:32:11.290
I can reduce it down to--

00:32:11.290 --> 00:32:14.583
I hope it's my next slide.

00:32:14.583 --> 00:32:15.750
I hope this thing will work.

00:32:25.030 --> 00:32:28.600
I'm going to skip
through all this.

00:32:28.600 --> 00:32:31.210
This diagram says that what's,
in fact, maybe happening

00:32:31.210 --> 00:32:34.160
with the processes that I make
a change at a particular time.

00:32:34.160 --> 00:32:37.670
It comes up to steady state,
but I sample it here, here,

00:32:37.670 --> 00:32:38.830
here, and here.

00:32:38.830 --> 00:32:45.620
And all that mess in between I'm
unaware of, I don't care about.

00:32:45.620 --> 00:32:49.250
And what I can do now is
reduce the whole process down

00:32:49.250 --> 00:32:53.018
to a single number.

00:32:53.018 --> 00:32:53.810
The nice thing is--

00:32:53.810 --> 00:32:55.130
I don't need to go
into this right now--

00:32:55.130 --> 00:32:56.963
I don't even need to
worry about the offset.

00:32:56.963 --> 00:33:00.590
You think of a straight
line fit-- you've

00:33:00.590 --> 00:33:02.550
got the slope and the offset.

00:33:02.550 --> 00:33:04.800
In the approach that we take
here with cycle to cycle,

00:33:04.800 --> 00:33:06.258
I don't even care
about the offset.

00:33:06.258 --> 00:33:08.720
In run-by-run they
do, but it turns out

00:33:08.720 --> 00:33:10.580
it comes out in the wash anyway.

00:33:10.580 --> 00:33:14.060
So now all I need to know about
the process is an input-output

00:33:14.060 --> 00:33:15.620
relationship between--

00:33:15.620 --> 00:33:16.430
but it's discrete.

00:33:16.430 --> 00:33:20.290
It's between a discrete
input at and instant

00:33:20.290 --> 00:33:23.930
in time and a discrete output.

00:33:23.930 --> 00:33:26.793
So that is a valid model
of our process now.

00:33:26.793 --> 00:33:28.210
The only thing
that's questionable

00:33:28.210 --> 00:33:31.130
is, what's this number,
and is it a constant?

00:33:31.130 --> 00:33:32.980
In other words, if I
run the process today,

00:33:32.980 --> 00:33:33.700
is it one number?

00:33:33.700 --> 00:33:35.350
Is it another number?

00:33:35.350 --> 00:33:41.307
And of course, as you know, we
would do a test for linearity,

00:33:41.307 --> 00:33:42.890
or maybe it should
be-- maybe it would

00:33:42.890 --> 00:33:46.180
be better modeled as quadratic
and other stuff like that.

00:33:46.180 --> 00:33:47.590
Without going into
it, and again,

00:33:47.590 --> 00:33:50.470
invoking the linearization
properties of a good control

00:33:50.470 --> 00:33:52.390
system, it doesn't matter.

00:33:52.390 --> 00:33:54.680
As long as we have a
pretty good estimate of it

00:33:54.680 --> 00:33:57.630
and as long as it's not
rapidly changing, we're OK.

00:34:00.520 --> 00:34:01.630
OK.

00:34:01.630 --> 00:34:03.490
So here's,
ultimately, our model.

00:34:03.490 --> 00:34:04.930
We have the process.

00:34:04.930 --> 00:34:06.550
We have some
process uncertainty,

00:34:06.550 --> 00:34:09.790
and we're going to bring that
in as a purely additive number--

00:34:09.790 --> 00:34:12.940
because the model I just showed
you was a deterministic model.

00:34:12.940 --> 00:34:15.010
There was no randomness
in it, so it obviously

00:34:15.010 --> 00:34:17.500
doesn't capture
what we care about.

00:34:17.500 --> 00:34:20.920
And I'm going to sample
that output compare it

00:34:20.920 --> 00:34:26.989
to what I want, and that'll be
my cycle-to-cycle controller.

00:34:26.989 --> 00:34:31.469
Now, when you get into
discrete control systems,

00:34:31.469 --> 00:34:34.500
one of the things that
you can easily model

00:34:34.500 --> 00:34:37.280
is the idea of a pure delay.

00:34:37.280 --> 00:34:40.489
Obviously, if I got something
that happens a given cycle,

00:34:40.489 --> 00:34:41.570
and nothing--

00:34:41.570 --> 00:34:44.630
I don't do anything until the
next cycle of time happens,

00:34:44.630 --> 00:34:46.315
I can have the concept
of a pure delay

00:34:46.315 --> 00:34:47.690
as well-- something
happens here,

00:34:47.690 --> 00:34:51.230
but there's no reaction
until here, or here, or here.

00:34:51.230 --> 00:34:53.480
And the theory of
discrete control systems

00:34:53.480 --> 00:34:55.889
allows you to deal with
delays very nicely.

00:34:55.889 --> 00:34:58.803
And we have three kinds of
delays in any control system,

00:34:58.803 --> 00:34:59.970
but certainly happened here.

00:34:59.970 --> 00:35:02.750
One is measurement delay.

00:35:02.750 --> 00:35:05.790
Part comes off-- takes me
some time to measure it.

00:35:08.880 --> 00:35:11.350
Because of that
measurement delay,

00:35:11.350 --> 00:35:14.250
there's no way that I
can make an adjustment

00:35:14.250 --> 00:35:15.960
before the next cycle.

00:35:15.960 --> 00:35:18.248
So I already have a
delay based on that.

00:35:18.248 --> 00:35:19.290
There's controller delay.

00:35:22.240 --> 00:35:26.040
Well, of course, if we're using
fast computers and that sort

00:35:26.040 --> 00:35:28.170
of thing, that can
be made very small,

00:35:28.170 --> 00:35:29.400
but it does take some time.

00:35:29.400 --> 00:35:33.990
And if it's an operator, a human
being measuring it and then

00:35:33.990 --> 00:35:36.420
doing a little bit of
pencil work on a path,

00:35:36.420 --> 00:35:38.620
there's a delay
associated with that.

00:35:38.620 --> 00:35:41.940
And then there's
a process delay.

00:35:41.940 --> 00:35:45.600
When can I make the machine?

00:35:45.600 --> 00:35:49.230
When is the machine next
available to be changed?

00:35:49.230 --> 00:35:51.240
So given all three
of these, what

00:35:51.240 --> 00:35:52.740
do you think-- for
this model, what

00:35:52.740 --> 00:35:54.690
do you think the
correct model of delay

00:35:54.690 --> 00:35:58.500
is for this approach
to process control?

00:36:07.660 --> 00:36:11.050
Now, let me preface this
with one other comment.

00:36:11.050 --> 00:36:13.180
We have a basic unit
of time here now?

00:36:16.390 --> 00:36:19.420
Other than zero, what's
the shortest time interval

00:36:19.420 --> 00:36:21.940
that's possible that
exists in this approach

00:36:21.940 --> 00:36:25.158
to the whole feedback
control thing?

00:36:28.510 --> 00:36:30.565
The fastest I can do something--

00:36:33.535 --> 00:36:34.530
AUDIENCE: One cycle--

00:36:34.530 --> 00:36:36.060
DAVID HARDT: One cycle--

00:36:36.060 --> 00:36:39.262
yeah-- one cycle, right?

00:36:39.262 --> 00:36:40.845
Because nothing
exists between cycles.

00:36:43.380 --> 00:36:46.890
When something happens, the next
chance I can do something on

00:36:46.890 --> 00:36:47.860
is a cycle.

00:36:47.860 --> 00:36:49.860
So this is all kind
of time-independent.

00:36:49.860 --> 00:36:52.140
In terms of real time, it's
just based on the cycle

00:36:52.140 --> 00:36:55.140
time of the process.

00:36:55.140 --> 00:36:59.810
So given this, go back
to that other question.

00:36:59.810 --> 00:37:03.110
There are delays involved in
all discrete control system.

00:37:03.110 --> 00:37:06.650
There are delays in
this control system.

00:37:06.650 --> 00:37:10.370
How do you think we should model
the delays of a manufacturing

00:37:10.370 --> 00:37:13.540
process for this context
of cycle-to-cycle control?

00:37:19.210 --> 00:37:21.310
I'll give you the
thought experiment.

00:37:21.310 --> 00:37:24.730
Run the injection
molding machine.

00:37:24.730 --> 00:37:26.920
Put the part on the bench.

00:37:26.920 --> 00:37:28.660
Measure the part.

00:37:28.660 --> 00:37:31.390
Figure out the next control
cycle based on the algorithm

00:37:31.390 --> 00:37:32.710
I'm going to come up with.

00:37:32.710 --> 00:37:34.120
Adjust the machine.

00:37:34.120 --> 00:37:35.170
Push the button.

00:37:35.170 --> 00:37:36.250
Run the machine again.

00:37:38.860 --> 00:37:40.840
That's the delay structure.

00:37:40.840 --> 00:37:42.880
How would you model that delay?

00:37:42.880 --> 00:37:48.220
Or how many delays or how
many machine cycles do I need

00:37:48.220 --> 00:37:51.760
to delay the process, minimum?

00:37:57.260 --> 00:37:58.690
One?

00:37:58.690 --> 00:38:01.360
1/2?

00:38:01.360 --> 00:38:03.740
1/10?

00:38:03.740 --> 00:38:04.240
10?

00:38:07.060 --> 00:38:08.770
I know I'm not making
myself clear here.

00:38:08.770 --> 00:38:10.030
I can see that.

00:38:10.030 --> 00:38:10.750
Richard--

00:38:10.750 --> 00:38:12.790
AUDIENCE: Well, the
discrete points of time,

00:38:12.790 --> 00:38:14.620
where you're looking
at your process

00:38:14.620 --> 00:38:21.460
that you're actually modeling,
I probably arrived when

00:38:21.460 --> 00:38:23.760
your part comes out, kind of.

00:38:23.760 --> 00:38:27.820
So you should probably
have a delay of one cycle.

00:38:27.820 --> 00:38:29.710
DAVID HARDT: Exactly, exactly--

00:38:29.710 --> 00:38:34.090
if I can measure quickly, make
a decision quickly, and be

00:38:34.090 --> 00:38:37.150
ready to adjust the
machine before it's time

00:38:37.150 --> 00:38:42.120
to push the button, then I have
built in a one-cycle delay.

00:38:42.120 --> 00:38:44.040
The best I could ever do is--

00:38:44.040 --> 00:38:47.010
and this is how you capture
in the theory, at least.

00:38:47.010 --> 00:38:48.720
The whole idea of
cycle-to-cycle control

00:38:48.720 --> 00:38:50.250
is I make a measurement.

00:38:50.250 --> 00:38:53.550
The next chance I have to
intervene on the process

00:38:53.550 --> 00:38:55.690
is one cycle later.

00:38:55.690 --> 00:38:57.540
So you build in a
one-cycle delay.

00:38:57.540 --> 00:39:00.100
OK, why does this
make a big difference?

00:39:00.100 --> 00:39:03.700
Well, in looking at discrete
time control theory,

00:39:03.700 --> 00:39:05.490
the whole concept
of a delay operator

00:39:05.490 --> 00:39:07.980
is the whole basis for it.

00:39:07.980 --> 00:39:11.190
Now, if you dig into
your deep dark pasts

00:39:11.190 --> 00:39:14.762
on the control
system theory, you

00:39:14.762 --> 00:39:17.220
may have remembered something
called the Laplace transform,

00:39:17.220 --> 00:39:19.740
Laplace operator, and all
that other business, which

00:39:19.740 --> 00:39:23.610
was a way of algebraically
describing time differential

00:39:23.610 --> 00:39:24.780
equations.

00:39:24.780 --> 00:39:26.880
What you have with a
discrete control system

00:39:26.880 --> 00:39:29.760
is time difference
equations, things

00:39:29.760 --> 00:39:32.910
are just sums of
inputs and outputs

00:39:32.910 --> 00:39:35.445
at different intervals of time.

00:39:35.445 --> 00:39:37.320
There's an equivalent
to that operator, which

00:39:37.320 --> 00:39:40.560
is called the z transform.

00:39:40.560 --> 00:39:43.570
And you're not going to
do z transforms here,

00:39:43.570 --> 00:39:46.260
much as I'd love to,
but basically it's

00:39:46.260 --> 00:39:48.850
an operator that says, if I--

00:39:48.850 --> 00:39:51.720
I transform everything
into this z domain,

00:39:51.720 --> 00:39:55.330
and now the concept of an
advance in time by one time

00:39:55.330 --> 00:39:59.490
step can be done by
having-- by pre-multiplying

00:39:59.490 --> 00:40:02.340
by this operator
z with an exponent

00:40:02.340 --> 00:40:05.460
that's a number of steps
ahead you want to do.

00:40:05.460 --> 00:40:09.300
If I want to have a delay, then
I just put a negative exponent

00:40:09.300 --> 00:40:09.990
up here.

00:40:09.990 --> 00:40:13.260
And so for example, if I
think of this concept of--

00:40:13.260 --> 00:40:17.580
here's the terminology
is, here's the output y

00:40:17.580 --> 00:40:19.455
at instant of time i.

00:40:22.180 --> 00:40:24.490
There's no continuous
variable t.

00:40:24.490 --> 00:40:26.740
It's the sample i, if you will.

00:40:26.740 --> 00:40:30.850
If I multiply that number
by z to the plus 1, that's

00:40:30.850 --> 00:40:35.350
the same as saying, oh, you
mean y one time step ahead?

00:40:35.350 --> 00:40:37.090
And if I multiply
it by z squared,

00:40:37.090 --> 00:40:38.950
it's two time steps ahead.

00:40:38.950 --> 00:40:41.270
And more relevant to what
we're doing here, if I say,

00:40:41.270 --> 00:40:44.380
OK, here's an output
at the current time i,

00:40:44.380 --> 00:40:48.700
if I pre-multiply it by this
operator z to the minus 1,

00:40:48.700 --> 00:40:51.655
I'm really saying let's look
at it one time step behind.

00:40:55.990 --> 00:40:59.560
So when we look at
our process model,

00:40:59.560 --> 00:41:02.842
we have to modify it a
little bit we say, OK, we

00:41:02.842 --> 00:41:04.550
can do this anywhere
in the loop we want,

00:41:04.550 --> 00:41:07.030
but we decided to do it here
because it's the easiest.

00:41:07.030 --> 00:41:11.830
When I make a
change to the input,

00:41:11.830 --> 00:41:13.630
conceptually, I
don't get to see what

00:41:13.630 --> 00:41:16.120
happens to that until
the cycle is over

00:41:16.120 --> 00:41:17.685
and I'm ready to
do the next cycle.

00:41:17.685 --> 00:41:19.310
So we're going to
model the whole thing

00:41:19.310 --> 00:41:22.000
not as a simple gain, but as--

00:41:22.000 --> 00:41:29.200
it's got messed up in
this-- but as this.

00:41:29.200 --> 00:41:30.760
Or in other words,
we're going to say

00:41:30.760 --> 00:41:36.910
that the current output is
equal to the prior input

00:41:36.910 --> 00:41:38.710
times that gain.

00:41:38.710 --> 00:41:41.470
And this may seem
pretty trivial to you,

00:41:41.470 --> 00:41:43.757
but this is the basis
of the whole thing.

00:41:43.757 --> 00:41:46.340
It's very simple from a discrete
control system point of view,

00:41:46.340 --> 00:41:48.520
but the mere fact
that you say, yeah,

00:41:48.520 --> 00:41:50.660
the input leads to the output--

00:41:50.660 --> 00:41:54.800
but a time step later is
what makes the whole thing--

00:41:54.800 --> 00:41:56.620
it's the part that
makes it not work,

00:41:56.620 --> 00:41:57.730
if you don't know
what you're doing,

00:41:57.730 --> 00:41:59.272
and it's the part
you have to analyze

00:41:59.272 --> 00:42:01.980
to be sure what is going on.

00:42:01.980 --> 00:42:04.860
OK, so for the moment,
we've modeled the process.

00:42:04.860 --> 00:42:10.050
It's a pure gain with a one
time step one-cycle delay.

00:42:15.330 --> 00:42:19.260
Here's some data from
a process that's--

00:42:19.260 --> 00:42:22.260
I think this is probably under
a state of statistical control.

00:42:22.260 --> 00:42:24.827
And you know that these
lines in between here--

00:42:24.827 --> 00:42:26.910
this is done on Excel--
the lines in between there

00:42:26.910 --> 00:42:27.840
don't exist.

00:42:27.840 --> 00:42:28.763
It's dots here.

00:42:28.763 --> 00:42:30.930
Here's a measurement, there's
a measurement-- so on.

00:42:30.930 --> 00:42:33.010
They're just there to
let you see it better.

00:42:33.010 --> 00:42:36.750
So that's the output
of our real process.

00:42:36.750 --> 00:42:39.060
Well, how does the model
I just came up with

00:42:39.060 --> 00:42:40.830
reflect this in any way?

00:42:40.830 --> 00:42:41.760
Of course, it doesn't.

00:42:41.760 --> 00:42:44.530
I haven't included
the randomness at all.

00:42:44.530 --> 00:42:47.850
So what we have to do is
add in some randomness,

00:42:47.850 --> 00:42:50.580
then do our sampling,
and then see

00:42:50.580 --> 00:42:53.590
if we get something
that looks like this.

00:42:53.590 --> 00:42:58.230
So again, we have to
come up with a model that

00:42:58.230 --> 00:43:01.860
fits what we observe in real
life-- what I just showed--

00:43:01.860 --> 00:43:05.530
you and also is amenable
to our control theory.

00:43:05.530 --> 00:43:06.917
So again, as I said, here's--

00:43:06.917 --> 00:43:08.250
we're still continuous here now.

00:43:08.250 --> 00:43:10.410
This is before we've
done the sampling.

00:43:10.410 --> 00:43:14.955
We've got this continuous
random variable, d of t.

00:43:14.955 --> 00:43:16.090
It's always there.

00:43:16.090 --> 00:43:17.280
It's always changing.

00:43:17.280 --> 00:43:18.960
Then we sample at our--

00:43:18.960 --> 00:43:21.550
once every cycle, and we
get our discrete variable.

00:43:21.550 --> 00:43:24.625
Now it should include
a random component.

00:43:34.390 --> 00:43:36.730
That's not exactly
what it should say.

00:43:36.730 --> 00:43:39.380
Well, that's jumping ahead,
but let's go ahead and do that.

00:43:39.380 --> 00:43:42.640
So now, in our cycle-to-cycle
control system,

00:43:42.640 --> 00:43:46.990
we're going to add into it
basically a sequence of numbers

00:43:46.990 --> 00:43:52.198
that follows a stationary
normal distribution function.

00:43:52.198 --> 00:43:53.240
Well, that's no big deal.

00:43:53.240 --> 00:43:55.180
That's what you've been
doing all along the term,

00:43:55.180 --> 00:43:56.940
so that's-- that
shouldn't be a problem.

00:44:01.572 --> 00:44:03.280
This is just a little
bit of a connection

00:44:03.280 --> 00:44:07.000
between continuous theory
and the discrete theory.

00:44:07.000 --> 00:44:12.205
A continuous or random
number is, in fact, that.

00:44:12.205 --> 00:44:14.398
If you go back to our
early stuff on statistics,

00:44:14.398 --> 00:44:15.940
this is really where
we started from.

00:44:15.940 --> 00:44:18.610
But there's this number
that's changing continuously,

00:44:18.610 --> 00:44:20.470
and it's never the same
number at any time,

00:44:20.470 --> 00:44:22.960
and it's following a
Gaussian distribution,

00:44:22.960 --> 00:44:25.300
and it's stationary-- or
a normal distribution,

00:44:25.300 --> 00:44:27.670
I should say.

00:44:27.670 --> 00:44:32.020
At any instant in time, there
is no correlation, meaning,

00:44:32.020 --> 00:44:34.882
if I sample this
distribution right now

00:44:34.882 --> 00:44:36.340
and I get a particular
number, that

00:44:36.340 --> 00:44:38.173
gives absolutely no
information about what's

00:44:38.173 --> 00:44:40.150
going to happen next.

00:44:40.150 --> 00:44:42.520
It does allow me eventually,
with enough data,

00:44:42.520 --> 00:44:44.520
to say what the distribution
is, but it tells me

00:44:44.520 --> 00:44:45.990
nothing about what's
going to happen next.

00:44:45.990 --> 00:44:47.250
So it's totally uncorrelated.

00:44:47.250 --> 00:44:49.290
And if we sample
that process, then

00:44:49.290 --> 00:44:51.390
we get what we've used
throughout the term,

00:44:51.390 --> 00:44:53.100
is this normal
identically distributed

00:44:53.100 --> 00:44:56.860
independent random sequence.

00:44:56.860 --> 00:44:58.800
Had-- do any of you use NIDI?

00:44:58.800 --> 00:45:01.290
You talked about the acronym?

00:45:01.290 --> 00:45:02.957
AUDIENCE: We've used IIND, and--

00:45:02.957 --> 00:45:04.290
DAVID HARDT: OK, all the other--

00:45:04.290 --> 00:45:05.693
AUDIENCE: Other permutations--

00:45:05.693 --> 00:45:06.360
DAVID HARDT: OK.

00:45:06.360 --> 00:45:08.540
Normal identically
distributed independence--

00:45:08.540 --> 00:45:12.600
so it means a stationary random
variable with no correlation

00:45:12.600 --> 00:45:16.550
from time to time.

00:45:16.550 --> 00:45:18.260
All right, here's the algebra.

00:45:18.260 --> 00:45:20.720
And it's the key
to the whole thing,

00:45:20.720 --> 00:45:23.840
but I won't go through
it, except to say

00:45:23.840 --> 00:45:26.450
that, if you remember your
block diagram algebra,

00:45:26.450 --> 00:45:28.520
there's a clear algebra
that happens here.

00:45:28.520 --> 00:45:30.620
And we'll just take
the first step here.

00:45:30.620 --> 00:45:33.650
The output y sub i-- what
this diagram means is that

00:45:33.650 --> 00:45:39.837
the output y sub i going
this way is equal to--

00:45:39.837 --> 00:45:40.920
that's a summation there--

00:45:40.920 --> 00:45:42.337
I should have put
out there-- it's

00:45:42.337 --> 00:45:45.500
equal to d sub i plus
the output of this box.

00:45:45.500 --> 00:45:48.920
And the output of this
box is kp times u sub i

00:45:48.920 --> 00:45:51.140
delayed by one time step.

00:45:51.140 --> 00:45:54.660
So that's all of that
equation means right there.

00:45:54.660 --> 00:45:56.780
Then we solve backwards here.

00:45:56.780 --> 00:45:59.210
We say, OK, well, there's
this value right here--

00:45:59.210 --> 00:46:02.750
the input to that happens to
be equal to the controller

00:46:02.750 --> 00:46:08.070
gain times the difference of
the reference and our feedback.

00:46:08.070 --> 00:46:15.830
You put it all together, and
this is the equation for this--

00:46:15.830 --> 00:46:18.640
the output of the controller.

00:46:18.640 --> 00:46:22.440
And then here's the
important thing.

00:46:22.440 --> 00:46:24.870
If I now say, all
right, I'm going

00:46:24.870 --> 00:46:27.200
to make the input my command--

00:46:27.200 --> 00:46:29.700
think of it as a dimension or
something for what we're doing

00:46:29.700 --> 00:46:31.960
here-- a constant value--

00:46:31.960 --> 00:46:34.000
10 inches-- never
going to change.

00:46:37.720 --> 00:46:41.540
And you can think
of it as a constant.

00:46:41.540 --> 00:46:42.290
Oh, I'm sorry.

00:46:42.290 --> 00:46:43.010
Back up.

00:46:43.010 --> 00:46:45.410
I'm going to do that too.

00:46:45.410 --> 00:46:47.900
For the moment, let's say
that the disturbance is not

00:46:47.900 --> 00:46:50.770
random-- it's just
a constant value.

00:46:50.770 --> 00:46:54.550
I'm going to use the term mu,
but it's a constant value.

00:46:54.550 --> 00:46:56.650
If I do that, and put
it into this equation,

00:46:56.650 --> 00:47:04.260
and solve for y sub i,
and I let time go forever,

00:47:04.260 --> 00:47:08.370
so it's now steady state, if
you go through the algebra, what

00:47:08.370 --> 00:47:12.210
you get is that the steady
state value of the output

00:47:12.210 --> 00:47:15.660
is equal to these two
quantities right here.

00:47:15.660 --> 00:47:18.360
It's the disturbance
divided by this quantity,

00:47:18.360 --> 00:47:21.120
and it's the reference
multiplied by that quantity.

00:47:21.120 --> 00:47:23.400
OK-- big deal.

00:47:23.400 --> 00:47:26.760
But here's the big deal.

00:47:26.760 --> 00:47:30.070
Here's the output
value in steady state.

00:47:30.070 --> 00:47:31.420
Here's the disturbance.

00:47:31.420 --> 00:47:33.490
What do I want that
quantity to be,

00:47:33.490 --> 00:47:34.980
if this is a good
control system?

00:47:38.370 --> 00:47:42.743
And for the moment, imagine
that my reference is zero.

00:47:42.743 --> 00:47:44.410
Conceptually, that's
an important thing.

00:47:44.410 --> 00:47:46.380
Imagine that my
reference is zero,

00:47:46.380 --> 00:47:51.120
so the ideal output of
the process is zero.

00:47:51.120 --> 00:47:54.150
Now this says that the ratio
of the output in steady

00:47:54.150 --> 00:47:56.310
state to the disturbance,
which is finite--

00:47:56.310 --> 00:47:58.897
some constant value--
is this quantity.

00:47:58.897 --> 00:48:00.480
What would I like
this quantity to be?

00:48:05.230 --> 00:48:08.440
How about zero?

00:48:08.440 --> 00:48:10.360
Disturbances are bad.

00:48:10.360 --> 00:48:12.160
If this number is
anything but zero,

00:48:12.160 --> 00:48:15.040
then I am not rejecting
my disturbance.

00:48:15.040 --> 00:48:18.070
Let's jump ahead to say,
if I can't make this zero,

00:48:18.070 --> 00:48:20.110
I can't center
this distribution,

00:48:20.110 --> 00:48:22.600
because this shift
is indeed that--

00:48:22.600 --> 00:48:24.980
its mean shift.

00:48:24.980 --> 00:48:31.320
How can I make
this zero, Can't--

00:48:31.320 --> 00:48:32.825
can I?

00:48:32.825 --> 00:48:34.200
How do I make this
quantity zero?

00:48:34.200 --> 00:48:37.355
There it is right there.

00:48:37.355 --> 00:48:38.730
How do I make that
quantity zero?

00:48:44.880 --> 00:48:45.822
I could do that.

00:48:45.822 --> 00:48:48.030
If I can make it an infinite
gain, it would be zero--

00:48:51.310 --> 00:48:53.410
tough thing to do.

00:48:53.410 --> 00:48:55.510
So kind of saying,
it would be easy,

00:48:55.510 --> 00:48:57.010
we're not going to
be able to do it.

00:48:57.010 --> 00:48:58.990
And this means that I
won't be able to do this,

00:48:58.990 --> 00:49:02.510
and the naysayers were right,
and all that sort of thing.

00:49:06.530 --> 00:49:08.460
But fortunately,
you'll see in a moment,

00:49:08.460 --> 00:49:10.250
there is a way we can do it.

00:49:10.250 --> 00:49:13.280
And maybe you saw this in your
control system things as well.

00:49:13.280 --> 00:49:16.010
Conceptually, all
I need is this game

00:49:16.010 --> 00:49:20.330
to be equal infinity when
things are in steady state.

00:49:20.330 --> 00:49:21.580
That's one way to think of it.

00:49:21.580 --> 00:49:24.250
The other way to think of it is,
if you did your control systems

00:49:24.250 --> 00:49:26.560
theory, it said,
steady state area

00:49:26.560 --> 00:49:29.320
equals zero-- that means I
want an integral controller.

00:49:29.320 --> 00:49:31.280
And there's theoretical
reasons for that.

00:49:31.280 --> 00:49:35.920
So what we can do, instead of
using a simple controller--

00:49:35.920 --> 00:49:37.550
I should back up here.

00:49:37.550 --> 00:49:40.270
What I did in here is I picked
our controller, was simply

00:49:40.270 --> 00:49:43.810
to say that the controller
was, if there's an error,

00:49:43.810 --> 00:49:46.705
make a purely proportional
change in the set points.

00:49:46.705 --> 00:49:49.330
Now I'm going to say let's get
a little bit more sophisticated.

00:49:49.330 --> 00:49:51.930
Let's do an integral controller.

00:49:51.930 --> 00:49:54.960
And an integral controller
in discrete terms

00:49:54.960 --> 00:49:59.040
is simply a running
sum of the errors.

00:49:59.040 --> 00:50:03.570
If you remember back to
Calculus 101, calculus--

00:50:03.570 --> 00:50:06.000
typically, when you
drive the integration,

00:50:06.000 --> 00:50:07.912
you start off with a
summation, and then

00:50:07.912 --> 00:50:09.870
make the summation interval
smaller and smaller

00:50:09.870 --> 00:50:11.380
until it becomes continuous.

00:50:11.380 --> 00:50:12.840
Now we break it
back the other way

00:50:12.840 --> 00:50:16.560
and say, OK, the best we can do
for a discrete time integrator

00:50:16.560 --> 00:50:18.460
is to sum up errors.

00:50:18.460 --> 00:50:20.100
So this is my new controller.

00:50:20.100 --> 00:50:23.442
It simply says the
output at any time,

00:50:23.442 --> 00:50:25.650
how I'm going to change the
machine is the sum of all

00:50:25.650 --> 00:50:28.890
the prior errors.

00:50:28.890 --> 00:50:31.920
Again, I can turn this
into recursive form.

00:50:31.920 --> 00:50:34.800
So you just say the next
output is the prior output

00:50:34.800 --> 00:50:39.060
plus the next error.

00:50:39.060 --> 00:50:41.550
And then I can do the z
transform business on it.

00:50:41.550 --> 00:50:42.970
It comes out like this.

00:50:42.970 --> 00:50:46.620
And this is where
it gets useful.

00:50:46.620 --> 00:50:49.290
Now my controller, instead
of being a simple gain,

00:50:49.290 --> 00:50:51.690
looks like this--
the z over z minus 1,

00:50:51.690 --> 00:50:53.670
which is describing
this equation.

00:50:53.670 --> 00:50:57.690
And I can do the algebra of
this and see what happens.

00:50:57.690 --> 00:50:59.790
So I follow the same
block diagram algebra,

00:50:59.790 --> 00:51:03.400
and the nice thing now
is that z is simply

00:51:03.400 --> 00:51:06.480
a multiplier, so I can treat
it like any other quantity.

00:51:06.480 --> 00:51:08.670
If I do that and I
go through all this--

00:51:13.150 --> 00:51:14.800
so these z's cancel out.

00:51:14.800 --> 00:51:18.640
I write the equation
for the disturbance.

00:51:18.640 --> 00:51:20.650
I'm assuming that
r is equal to zero,

00:51:20.650 --> 00:51:23.750
so this is zero over here.

00:51:23.750 --> 00:51:28.360
Go through the block diagram
algebra, get down to here,

00:51:28.360 --> 00:51:30.640
and now a couple of things
are kind of interesting.

00:51:30.640 --> 00:51:34.180
But what I can say is
that steady state--

00:51:34.180 --> 00:51:37.040
we know that all of the y's
in the system are the same.

00:51:37.040 --> 00:51:38.830
Everything's settled out.

00:51:38.830 --> 00:51:41.860
And I come down here and say
that, because this disturbance

00:51:41.860 --> 00:51:45.040
is a constant, these
two things are the same.

00:51:45.040 --> 00:51:50.080
The disturbance at time
20,000 and time 20,000 plus 1

00:51:50.080 --> 00:51:51.882
are the same, because
it's a constant.

00:51:51.882 --> 00:51:53.590
And when you come down
here, you find out

00:51:53.590 --> 00:51:55.510
that this quantity's
equal to zero,

00:51:55.510 --> 00:51:58.335
regardless of the loop gain.

00:51:58.335 --> 00:51:59.710
In other words,
it doesn't matter

00:51:59.710 --> 00:52:02.650
what value I pick for kc.

00:52:02.650 --> 00:52:04.912
It's always zero.

00:52:04.912 --> 00:52:06.370
So it's just a way
of showing that,

00:52:06.370 --> 00:52:08.170
with a simple
integral controller,

00:52:08.170 --> 00:52:12.010
I indeed can take a finite
constant disturbance

00:52:12.010 --> 00:52:14.980
and completely eliminate
it in steady state--

00:52:14.980 --> 00:52:17.710
not instantaneously,
but in steady state.

00:52:22.090 --> 00:52:24.340
So now, here's the problem.

00:52:24.340 --> 00:52:26.850
Since kc doesn't matter--

00:52:26.850 --> 00:52:28.160
that's my controller gain.

00:52:28.160 --> 00:52:29.020
That's my design.

00:52:29.020 --> 00:52:30.640
Since that doesn't matter--

00:52:30.640 --> 00:52:33.290
so must matter to
something, right?

00:52:33.290 --> 00:52:36.550
So what value do I pick
for that gain of kc?

00:52:36.550 --> 00:52:39.730
What's the effective the
value of this controller

00:52:39.730 --> 00:52:42.490
gain on the performance
of this system?

00:52:42.490 --> 00:52:44.290
Do you guys remember
from control theory

00:52:44.290 --> 00:52:48.310
at all what the effect of a
controller gain is, typically?

00:52:48.310 --> 00:52:50.740
Low gain, high gain,
little gain, too high gain,

00:52:50.740 --> 00:52:52.823
too low gain--

00:52:52.823 --> 00:52:55.240
generally, what happens as you
adjust the controller gain?

00:53:01.216 --> 00:53:02.710
AUDIENCE: Speed of the system?

00:53:02.710 --> 00:53:03.850
DAVID HARDT: Yeah.

00:53:03.850 --> 00:53:06.040
Think of it this way.

00:53:06.040 --> 00:53:07.460
Forget about this for a moment.

00:53:07.460 --> 00:53:10.570
This controller game
says it's how much I'm

00:53:10.570 --> 00:53:13.090
going to adjust the
system based on the error.

00:53:13.090 --> 00:53:16.210
If I'm very conservative,
and kc is really small,

00:53:16.210 --> 00:53:18.220
and I get, let's say, an error--

00:53:18.220 --> 00:53:19.600
a modest error,
I'm going to make

00:53:19.600 --> 00:53:22.210
a really modest, timid change.

00:53:22.210 --> 00:53:24.670
It's a measure of
timidity, I guess.

00:53:24.670 --> 00:53:28.090
I'm going to take a timid
change on the-- over here.

00:53:28.090 --> 00:53:33.760
If I'm bold and trusting
my control system--

00:53:33.760 --> 00:53:35.320
small error here, large gain--

00:53:35.320 --> 00:53:36.228
I make a huge change.

00:53:36.228 --> 00:53:37.770
And obviously, a
huge change is going

00:53:37.770 --> 00:53:39.800
to get the system moving faster.

00:53:39.800 --> 00:53:43.150
So conceptually, heuristically--
however you want to call it--

00:53:43.150 --> 00:53:46.000
high gains will generally lead
to faster system response.

00:53:46.000 --> 00:53:49.660
Low gains will lead to
slower system response.

00:53:49.660 --> 00:53:52.660
Which ones do you think
typically-- but not always--

00:53:52.660 --> 00:53:57.130
which ones typically, do you
think, are the most dangerous,

00:53:57.130 --> 00:54:00.430
with respect to things like,
as I mentioned earlier,

00:54:00.430 --> 00:54:03.820
the property of control
systems known as instability--

00:54:03.820 --> 00:54:06.100
high gains or low gains?

00:54:06.100 --> 00:54:07.510
High gains, of course-- yeah--

00:54:07.510 --> 00:54:10.330
because imagine,
tiny error here.

00:54:10.330 --> 00:54:12.520
You're almost there-- huge gain.

00:54:12.520 --> 00:54:14.620
You whack the system
with a big thing,

00:54:14.620 --> 00:54:16.335
it goes way past where
you wanted it to,

00:54:16.335 --> 00:54:18.460
and now you say, oh my
gosh, now it's a large area.

00:54:18.460 --> 00:54:21.110
And it keeps coming back and
forth, and next thing you know,

00:54:21.110 --> 00:54:24.850
you've got a system
that's unstable.

00:54:24.850 --> 00:54:27.070
OK, so to understand
this, you have

00:54:27.070 --> 00:54:28.900
to understand discrete
time control theory.

00:54:28.900 --> 00:54:31.638
There's some wonderful,
books, and courses

00:54:31.638 --> 00:54:32.680
and other things on that.

00:54:32.680 --> 00:54:34.850
We don't have time
for that here.

00:54:34.850 --> 00:54:36.730
We'll do it heuristically.

00:54:36.730 --> 00:54:39.910
We'll do it just
for this system.

00:54:39.910 --> 00:54:40.750
Here's what happens.

00:54:43.880 --> 00:54:46.300
I'm going to step
through different gains.

00:54:46.300 --> 00:54:48.310
Now, I already knew
the theory behind this.

00:54:48.310 --> 00:54:53.130
I knew what these numbers needed
to be, but here's what you get.

00:54:53.130 --> 00:54:54.640
I got to say one of the thing.

00:54:54.640 --> 00:54:57.400
What I'm going to show you is
the product of these two gains.

00:54:57.400 --> 00:54:59.710
That's what really matters,
because again, these--

00:54:59.710 --> 00:55:02.170
you can collapse
these blocks together,

00:55:02.170 --> 00:55:07.240
and it's just this product,
kc kp, that matters--

00:55:07.240 --> 00:55:09.640
the so-called loop gain.

00:55:09.640 --> 00:55:13.130
If I use a loop gain of
1/2, here's what happens.

00:55:13.130 --> 00:55:15.010
If I make a step
change in the input,

00:55:15.010 --> 00:55:19.390
it goes 1, 2, 3, 4, 5, 6, 7--

00:55:19.390 --> 00:55:23.860
maybe 8 cycles later it has
reached the final value,

00:55:23.860 --> 00:55:28.970
and the error is zero,
just as I expected.

00:55:28.970 --> 00:55:29.810
So OK, that's good.

00:55:29.810 --> 00:55:31.810
What happens if I
increase the gain?

00:55:31.810 --> 00:55:33.820
Should get better--
well, indeed, it does.

00:55:33.820 --> 00:55:34.660
Look at this.

00:55:34.660 --> 00:55:37.180
If I increase the game to 9/10--

00:55:37.180 --> 00:55:39.610
1, 2, maybe 3 cycles--

00:55:39.610 --> 00:55:40.900
it's done.

00:55:40.900 --> 00:55:42.850
And you notice, this
is really emphasizing

00:55:42.850 --> 00:55:44.680
the discrete control
aspect of it.

00:55:44.680 --> 00:55:48.490
There's a change, and then who
knows, and then another change,

00:55:48.490 --> 00:55:49.990
and then who knows?

00:55:49.990 --> 00:55:53.080
So 9/10 is good.

00:55:53.080 --> 00:55:53.920
9/10 is good.

00:55:53.920 --> 00:55:58.420
Then 1.5/10 should be good.

00:55:58.420 --> 00:56:00.260
15/10 should be good.

00:56:00.260 --> 00:56:02.590
So I go to 15/10,
and what happens?

00:56:02.590 --> 00:56:05.740
Well, it now takes two things.

00:56:05.740 --> 00:56:07.330
It took three cycles
to settle here.

00:56:07.330 --> 00:56:10.000
Now we're back out to taking
eight cycles to settle,

00:56:10.000 --> 00:56:12.102
and I got this oscillation.

00:56:12.102 --> 00:56:13.810
So it seems like I
kind of went through--

00:56:13.810 --> 00:56:16.990
I was getting better, and
now I'm getting worse.

00:56:16.990 --> 00:56:19.750
Just to see what happens, since
this is a simulation anyway,

00:56:19.750 --> 00:56:22.060
let's set the loop
gain equal to 2.

00:56:22.060 --> 00:56:23.200
And what happens?

00:56:23.200 --> 00:56:26.980
The system indeed is now what
we call marginally stable.

00:56:26.980 --> 00:56:30.790
And I don't have it on here,
but if I set it to 2.001,

00:56:30.790 --> 00:56:32.020
it starts to diverge.

00:56:35.260 --> 00:56:37.060
Here's the cool thing.

00:56:37.060 --> 00:56:39.850
If I set that equal
to 1, how long

00:56:39.850 --> 00:56:41.860
does it take to get
to the correct value?

00:56:46.410 --> 00:56:49.230
One time step-- and this is
actually a pretty well-known

00:56:49.230 --> 00:56:51.840
concept in discrete
time control systems--

00:56:51.840 --> 00:56:56.610
that, if you can magically
find exactly the right gain

00:56:56.610 --> 00:56:58.980
so that the loop
gain is equal to 1,

00:56:58.980 --> 00:57:01.590
you indeed can get exactly
there in one time step.

00:57:01.590 --> 00:57:03.960
So this is our goal.

00:57:03.960 --> 00:57:07.320
And it says that the best
control system I could have now

00:57:07.320 --> 00:57:10.540
would take a mean
offset like this

00:57:10.540 --> 00:57:14.470
and take it to zero
error in one time step.

00:57:14.470 --> 00:57:19.000
So this is probably the right
controller for us to use.

00:57:19.000 --> 00:57:23.470
It also tells us that,
if I'm too aggressive

00:57:23.470 --> 00:57:25.910
and I use a gain--
a loop gain of 2,

00:57:25.910 --> 00:57:28.048
then think of the operators
now at the cement plant

00:57:28.048 --> 00:57:29.090
that I was talking about.

00:57:29.090 --> 00:57:31.510
And they were turning the
knob a little bit too far,

00:57:31.510 --> 00:57:36.100
and so they were maybe here or
here, and making things worse.

00:57:36.100 --> 00:57:39.670
Or they were here and
they were being too timid,

00:57:39.670 --> 00:57:42.220
and it really didn't have any
effect over the time frame

00:57:42.220 --> 00:57:43.480
that they were talking about.

00:57:43.480 --> 00:57:46.600
If you knew what your process
gains were and you knew where

00:57:46.600 --> 00:57:48.460
to set this, you
can always guarantee

00:57:48.460 --> 00:57:53.410
that you got the maximum effect
in the minimum amount of time.

00:57:53.410 --> 00:57:55.030
Also, the other thing
is the operators

00:57:55.030 --> 00:57:56.710
were not using this
control algorithm.

00:57:56.710 --> 00:57:58.930
They were using that
control algorithm,

00:57:58.930 --> 00:58:01.200
so it would never
get to zero error.

00:58:05.680 --> 00:58:09.670
So with a fairly
large gap in coverage

00:58:09.670 --> 00:58:13.090
here, what I'm
purporting to show you

00:58:13.090 --> 00:58:15.070
is that, if I have a random--

00:58:15.070 --> 00:58:18.350
if I have an output-- a process
whose output looks like this,

00:58:18.350 --> 00:58:22.480
and I apply this simple
discrete time controller--

00:58:22.480 --> 00:58:29.800
which means I measure, adjust,
but adjust according to this

00:58:29.800 --> 00:58:34.403
algorithm here,
which basically is--

00:58:34.403 --> 00:58:36.820
this is something I think it's
important-- which basically

00:58:36.820 --> 00:58:39.070
says, OK, I'm the operator.

00:58:39.070 --> 00:58:41.120
I have to make an
adjustment to the process.

00:58:41.120 --> 00:58:43.090
Here's the adjustment
I'm going to make.

00:58:43.090 --> 00:58:45.520
And the adjustment I'm going
to make is whatever it was

00:58:45.520 --> 00:58:48.130
the last time plus this
controller gain-- which,

00:58:48.130 --> 00:58:49.630
you're going to
tell me what it is--

00:58:49.630 --> 00:58:51.490
times the current error--

00:58:51.490 --> 00:58:56.300
little bit different than what
it might have been otherwise.

00:58:56.300 --> 00:58:57.860
You can also notice
that, if I bring

00:58:57.860 --> 00:59:00.068
this over to the other side,
what it's really telling

00:59:00.068 --> 00:59:02.870
the operator is the
increment in the adjustment

00:59:02.870 --> 00:59:06.170
should be proportional
to the air, not

00:59:06.170 --> 00:59:08.270
the absolute value of it.

00:59:08.270 --> 00:59:10.820
But anyway, you implement
that controller.

00:59:10.820 --> 00:59:14.330
And what that says
is that, if I have

00:59:14.330 --> 00:59:17.750
a random output on my
process stationary--

00:59:17.750 --> 00:59:20.270
in a state of stationary
statistical control,

00:59:20.270 --> 00:59:22.760
but offset from
here, it tells me

00:59:22.760 --> 00:59:28.850
that at least the
mean value here before

00:59:28.850 --> 00:59:32.870
will now be the
mean value after.

00:59:32.870 --> 00:59:36.200
But the question is,
will the distribution

00:59:36.200 --> 00:59:40.978
look like that or will
it look like that?

00:59:40.978 --> 00:59:42.770
So we have to look at
the random component.

00:59:42.770 --> 00:59:44.450
This gets a lot
harder to do so, I'll

00:59:44.450 --> 00:59:45.658
just kind of pop through it--

00:59:48.360 --> 00:59:52.280
and again, more heuristically
than mathematically.

00:59:52.280 --> 00:59:57.230
Our random model of this thing
is that we have this normally

00:59:57.230 --> 00:59:58.850
independent--

00:59:58.850 --> 01:00:01.520
identically distributed
independent sequence

01:00:01.520 --> 01:00:02.180
for d sub i.

01:00:02.180 --> 01:00:04.138
So it's a bunch of numbers
that are coming out,

01:00:04.138 --> 01:00:07.020
and they're sampled from
a normal distribution.

01:00:10.450 --> 01:00:13.060
If they are totally
independent, what that means

01:00:13.060 --> 01:00:15.400
is that these--
there's no way that I

01:00:15.400 --> 01:00:17.620
can predict what the next
value of the disturbance

01:00:17.620 --> 01:00:20.470
will be-- this d sub i.

01:00:20.470 --> 01:00:23.570
If there were, then I could
write an equation that says,

01:00:23.570 --> 01:00:26.020
OK, there's some relation
between the current value

01:00:26.020 --> 01:00:27.670
and all the prior values.

01:00:27.670 --> 01:00:31.660
You often see these so-called
time series equations,

01:00:31.660 --> 01:00:34.690
or discrete time equations,
or that sort of thing.

01:00:34.690 --> 01:00:37.150
But since there isn't,
then it says, sorry.

01:00:37.150 --> 01:00:39.880
It's just not equal
to any function

01:00:39.880 --> 01:00:41.020
of any of the prior values.

01:00:41.020 --> 01:00:43.270
There's no way to predict
what's going to happen next.

01:00:46.390 --> 01:00:49.180
So if I do that, then you can--

01:00:49.180 --> 01:00:54.183
I think you can see then that
knowing this doesn't tell me--

01:00:54.183 --> 01:00:55.600
doesn't give me a
good idea of how

01:00:55.600 --> 01:00:57.670
to adjust it to
take care of what

01:00:57.670 --> 01:00:59.290
the next value is going to be.

01:01:05.490 --> 01:01:09.510
So there's no way that
knowing the prior value

01:01:09.510 --> 01:01:11.820
of the disturbance will
allow me to write an equation

01:01:11.820 --> 01:01:15.930
to exactly cancel what
the next one will be.

01:01:15.930 --> 01:01:17.790
So again, what I'm
saying is this.

01:01:20.820 --> 01:01:26.220
Let's imagine here that
I'm at time interval sub i,

01:01:26.220 --> 01:01:28.200
and I have a
disturbance t sub i.

01:01:28.200 --> 01:01:29.640
And I measure that,
and I say, ah!

01:01:29.640 --> 01:01:33.940
The disturbance at this instant
is the value of d sub i.

01:01:33.940 --> 01:01:37.750
What I need to do then is
come up with a-- if you will,

01:01:37.750 --> 01:01:44.890
a delta u that's equal to minus
d sub i for the next cycle.

01:01:44.890 --> 01:01:46.910
But of course, that's too late.

01:01:46.910 --> 01:01:48.350
I can't cancel out
the disturbance

01:01:48.350 --> 01:01:49.350
that's already happened.

01:01:49.350 --> 01:01:52.700
So I need to know what
d sub i plus 1 is.

01:01:52.700 --> 01:01:54.890
And then I could
write this equation,

01:01:54.890 --> 01:01:57.410
and I'd cancel it out.

01:01:57.410 --> 01:02:01.010
But I can't, because I have no
idea what the next one will be.

01:02:03.650 --> 01:02:05.570
But with the controller
that I've written,

01:02:05.570 --> 01:02:07.695
there's no way to separate
out these two functions,

01:02:07.695 --> 01:02:09.260
so I'm going to do this anyway.

01:02:09.260 --> 01:02:10.890
I'm going to do this,
knowing full well

01:02:10.890 --> 01:02:12.890
that it's not right,
because it's the only way I

01:02:12.890 --> 01:02:14.890
can implement the controller.

01:02:14.890 --> 01:02:19.480
And so heuristically,
it can't be good right,

01:02:19.480 --> 01:02:22.060
so it must be bad.

01:02:22.060 --> 01:02:24.595
Oops-- if you go through
the theory on this,

01:02:24.595 --> 01:02:26.470
and even do simulations
and things like that,

01:02:26.470 --> 01:02:28.870
indeed, you find out it's bad.

01:02:28.870 --> 01:02:32.140
And here's the
measure of badness.

01:02:32.140 --> 01:02:33.190
Here's a variance ratio.

01:02:33.190 --> 01:02:38.590
This is basically saying I've
taken a random number with

01:02:38.590 --> 01:02:40.600
a distribution and with
a certain variance--

01:02:40.600 --> 01:02:42.460
and that's sigma squared--

01:02:42.460 --> 01:02:45.310
this is before and after.

01:02:45.310 --> 01:02:46.480
Let me write that down here.

01:02:46.480 --> 01:02:49.440
This is before
and this is after.

01:02:52.060 --> 01:02:54.220
This ratio is how much
the control system

01:02:54.220 --> 01:02:59.840
has increased or decreased
the variance of the output.

01:02:59.840 --> 01:03:01.810
And this is a function
of this loop gain

01:03:01.810 --> 01:03:03.980
that we talked
about, this quantity

01:03:03.980 --> 01:03:06.095
we'd like to have at 1.

01:03:06.095 --> 01:03:07.220
OK, so what does this mean?

01:03:07.220 --> 01:03:08.830
Well, if I don't
do any control--

01:03:08.830 --> 01:03:11.950
loop gain is zero-- then I
haven't increased the variance

01:03:11.950 --> 01:03:13.690
at all, and so it's at 1.

01:03:13.690 --> 01:03:14.960
That ratio's at 1.

01:03:14.960 --> 01:03:17.350
Let's go out to our favorite
number, which was 1,

01:03:17.350 --> 01:03:19.570
because it gives
the best response.

01:03:19.570 --> 01:03:25.150
And it means I've increased the
variance ratio to about 2.2.

01:03:25.150 --> 01:03:30.570
Or the standard
deviation ratio, I think,

01:03:30.570 --> 01:03:32.650
comes out to about 1.5.

01:03:32.650 --> 01:03:36.420
So I've taken this width, and
I've increased it by 50%--

01:03:36.420 --> 01:03:41.820
nothing I can do about,
nothing I can do about it.

01:03:41.820 --> 01:03:43.680
I can run a slower process.

01:03:43.680 --> 01:03:46.050
I can say, OK,
I'll take some time

01:03:46.050 --> 01:03:48.330
steps to reach steady
state and maybe

01:03:48.330 --> 01:03:51.060
bring it down to 1.3, but--

01:03:51.060 --> 01:03:53.400
so this is, in fact, a
really good description

01:03:53.400 --> 01:03:54.900
of what I was
telling you before.

01:03:54.900 --> 01:03:58.170
With this control system,
with this type of noise,

01:03:58.170 --> 01:04:00.600
I can take a process
that looks like this,

01:04:00.600 --> 01:04:03.030
I can guarantee the [INAUDIBLE]
but I'm going to increase

01:04:03.030 --> 01:04:06.990
the variance by some factor,
depending on what I set

01:04:06.990 --> 01:04:07.950
the gain at--

01:04:07.950 --> 01:04:09.960
probably 50%.

01:04:09.960 --> 01:04:12.270
Is that good or is that bad?

01:04:12.270 --> 01:04:15.450
Depends-- getting
rid of mean shifts

01:04:15.450 --> 01:04:17.240
is a pretty important thing.

01:04:17.240 --> 01:04:19.470
If you think about the
philosophy of Six Sigma,

01:04:19.470 --> 01:04:22.350
this is actually pretty
good, because Six Sigma--

01:04:22.350 --> 01:04:24.150
one starts with
narrow distributions,

01:04:24.150 --> 01:04:26.310
allows for mean offsets.

01:04:26.310 --> 01:04:28.200
And if we say,
OK, but we'll make

01:04:28.200 --> 01:04:30.535
sure you don't get mean
offsets, and you already

01:04:30.535 --> 01:04:32.910
have a narrow distribution,
we'll only make it 50% wider.

01:04:36.360 --> 01:04:39.630
So I don't want to sell it
too much, but it's half good,

01:04:39.630 --> 01:04:40.440
it's half bad.

01:04:40.440 --> 01:04:41.640
Richard--

01:04:41.640 --> 01:04:46.070
AUDIENCE: But if you can
adjust the loop gain at 0.2,

01:04:46.070 --> 01:04:48.610
we would still arrive at
our process mean, right?

01:04:48.610 --> 01:04:49.343
DAVID HARDT: Yep.

01:04:49.343 --> 01:04:50.760
Yeah, but I'll
show you an example

01:04:50.760 --> 01:04:53.400
of why that might
not be a good idea,

01:04:53.400 --> 01:04:55.950
when we get to the experiments.

01:04:55.950 --> 01:04:57.840
OK, so the conclusion--

01:04:57.840 --> 01:05:04.140
cycle-to-cycle control for an
uncorrelated random disturbance

01:05:04.140 --> 01:05:05.220
can do what I said.

01:05:05.220 --> 01:05:08.220
It takes this
distribution, shifts it,

01:05:08.220 --> 01:05:10.890
guarantees that it's
going to be at zero mean,

01:05:10.890 --> 01:05:14.760
but it widens the distribution.

01:05:14.760 --> 01:05:16.980
Obviously, I've drawn
this so that it still

01:05:16.980 --> 01:05:19.260
looks fine and the--

01:05:19.260 --> 01:05:23.070
and if I looked at this as
cpk, or expected quality loss,

01:05:23.070 --> 01:05:26.580
the way I've drawn it,
this is a winner by a lot.

01:05:26.580 --> 01:05:29.520
This has terrible
process capability,

01:05:29.520 --> 01:05:31.660
and now this is
really pretty good,

01:05:31.660 --> 01:05:32.910
even though it got wider--

01:05:32.910 --> 01:05:36.070
because of the mean shift.

01:05:36.070 --> 01:05:41.320
However, not all
processes are the same,

01:05:41.320 --> 01:05:44.290
and there's a big difference
in a lot of these.

01:05:44.290 --> 01:05:47.230
And so what if the
process is not well

01:05:47.230 --> 01:05:49.660
described by a normally
identically distributed

01:05:49.660 --> 01:05:53.035
independent random variable?

01:05:53.035 --> 01:05:54.910
Don't worry about what
that says right there.

01:06:00.130 --> 01:06:02.120
It's sometimes
called the concept

01:06:02.120 --> 01:06:04.312
of history, or process
history, or memory,

01:06:04.312 --> 01:06:05.270
or something like that.

01:06:07.647 --> 01:06:09.980
I think it would work well
with a semiconductor process,

01:06:09.980 --> 01:06:11.840
but I know it works well
with injection molding,

01:06:11.840 --> 01:06:13.310
because I'll show
you in a second.

01:06:13.310 --> 01:06:15.920
Imagine I have an
injection molding process,

01:06:15.920 --> 01:06:18.140
and I decide to
make these changes

01:06:18.140 --> 01:06:19.957
by changing the hold time.

01:06:19.957 --> 01:06:22.040
Every time I get an error,
I change the hold time.

01:06:24.747 --> 01:06:27.080
So every time I cycle this
thing, which is pretty rapid,

01:06:27.080 --> 01:06:28.760
I change the hold time.

01:06:28.760 --> 01:06:31.280
Now, the hold time determines,
among other things,

01:06:31.280 --> 01:06:34.190
the temperature at which
you open the mold--

01:06:34.190 --> 01:06:37.280
how cool it is when it opens up,
when you release the pressure.

01:06:37.280 --> 01:06:40.570
OK, how long do you
think it takes that mold

01:06:40.570 --> 01:06:43.680
to reach equilibrium after
I change the hold time?

01:06:43.680 --> 01:06:47.650
You think it reaches equilibrium
after the first cycle?

01:06:47.650 --> 01:06:49.110
Big piece of metal--

01:06:49.110 --> 01:06:52.920
I say, hold it an
extra 10 seconds

01:06:52.920 --> 01:06:56.105
so it starts to cool off.

01:06:56.105 --> 01:06:58.230
It's probably going to take
several of those cycles

01:06:58.230 --> 01:07:00.870
before it cools off to its
new equilibrium temperature.

01:07:00.870 --> 01:07:03.070
Does that makes sense?

01:07:03.070 --> 01:07:05.723
And then, if I say, let's open
it quicker all of a sudden--

01:07:05.723 --> 01:07:07.890
I open it quicker-- it's
going to start to heat up--

01:07:07.890 --> 01:07:09.970
it's going to take a
while to heat up there.

01:07:09.970 --> 01:07:14.267
So in fact, the process
is not at steady state.

01:07:14.267 --> 01:07:16.350
At least the disturbances
are not at steady state.

01:07:16.350 --> 01:07:18.210
There's a little bit of history.

01:07:18.210 --> 01:07:21.450
And we can represent
this mathematically

01:07:21.450 --> 01:07:24.300
by taking a purely random
independent sequence

01:07:24.300 --> 01:07:26.850
and put it through a
first-order process,

01:07:26.850 --> 01:07:29.920
and you end up with an
equation that shows, in fact,

01:07:29.920 --> 01:07:34.540
the next disturbance is somewhat
predicted by the prior ones.

01:07:34.540 --> 01:07:36.623
There's a little bit of
memory between the two,

01:07:36.623 --> 01:07:38.790
and this is where we get
the concept of some process

01:07:38.790 --> 01:07:39.914
correlation.

01:07:42.880 --> 01:07:45.562
So what happens if there's
process correlation?

01:07:45.562 --> 01:07:47.520
Well, this is a lot harder
to do theoretically,

01:07:47.520 --> 01:07:50.100
so we did it in simulation.

01:07:50.100 --> 01:07:52.450
I think we also have a
theoretical one on this,

01:07:52.450 --> 01:07:55.080
but now look at-- here's
the variance ratio,

01:07:55.080 --> 01:07:58.410
same thing as before, but
now with a disturbance

01:07:58.410 --> 01:08:00.450
that has a little
bit of correlation.

01:08:00.450 --> 01:08:01.260
Watch what happens.

01:08:01.260 --> 01:08:04.020
As I increase the gain
from zero up to 1,

01:08:04.020 --> 01:08:07.710
what happens to
the variance ratio?

01:08:07.710 --> 01:08:11.478
It actually goes
down for a while.

01:08:11.478 --> 01:08:13.020
I'm not sure these
numbers are right.

01:08:13.020 --> 01:08:15.555
This one's not right.

01:08:15.555 --> 01:08:16.430
That one's not right.

01:08:16.430 --> 01:08:17.597
But anyway, it's going down.

01:08:20.180 --> 01:08:21.050
Actually, I'm sorry.

01:08:21.050 --> 01:08:22.160
That can be right.

01:08:22.160 --> 01:08:23.720
There's another factor in here.

01:08:23.720 --> 01:08:27.830
So why would the
variance ratio go down?

01:08:27.830 --> 01:08:30.740
Well, it's because
I now actually do

01:08:30.740 --> 01:08:33.620
get some information about what
the next disturbance is going

01:08:33.620 --> 01:08:34.910
to be based on the prior one.

01:08:34.910 --> 01:08:37.100
That's essentially
what correlation means.

01:08:37.100 --> 01:08:39.350
And it's kind of
cool, because it

01:08:39.350 --> 01:08:45.189
can't be much more specific than
that, but it basically says,

01:08:45.189 --> 01:08:45.859
I can--

01:08:45.859 --> 01:08:47.380
I'll show you this in a
moment, but I can actually

01:08:47.380 --> 01:08:49.750
use this controller as a
way of measuring correlation

01:08:49.750 --> 01:08:50.510
in the process.

01:08:50.510 --> 01:08:52.300
If the variance ratio
goes down, there

01:08:52.300 --> 01:08:56.319
had to have been
some correlation.

01:08:56.319 --> 01:08:58.120
Here's the curve that
I was thinking of.

01:08:58.120 --> 01:09:00.010
So you can think
of it instead as

01:09:00.010 --> 01:09:01.540
sort of a continuum
of correlation.

01:09:01.540 --> 01:09:04.479
Here's zero correlation, and
here's a large correlation,

01:09:04.479 --> 01:09:05.420
if you will.

01:09:05.420 --> 01:09:08.620
So zero correlation is
the first case we had--

01:09:08.620 --> 01:09:10.300
independent random variable.

01:09:10.300 --> 01:09:14.990
And here's that same
curve that we had before,

01:09:14.990 --> 01:09:20.020
where, at 1, it
was still up there.

01:09:20.020 --> 01:09:22.525
As I increase the amount of
correlation-- in other words,

01:09:22.525 --> 01:09:24.609
as the words as the memory
gets stronger and stronger--

01:09:24.609 --> 01:09:26.109
this curve starts
to come down here,

01:09:26.109 --> 01:09:30.760
where at very large values,
you can see that at 1,

01:09:30.760 --> 01:09:33.310
I could have a
variance ratio as low

01:09:33.310 --> 01:09:37.000
as 1/3, which means
that, depending

01:09:37.000 --> 01:09:38.979
on the physics of
the process, I could

01:09:38.979 --> 01:09:41.500
take a broad shift
in distribution

01:09:41.500 --> 01:09:44.752
and make it narrow and
centered with this approach.

01:09:44.752 --> 01:09:46.960
And this is with exactly
the same controller, nothing

01:09:46.960 --> 01:09:49.750
different.

01:09:49.750 --> 01:09:56.920
So the cool thing is that
we end up with these--

01:09:56.920 --> 01:10:00.160
it's actually a continuum,
but we can say that,

01:10:00.160 --> 01:10:02.798
for a totally
uncorrelated process,

01:10:02.798 --> 01:10:04.090
here's what's going to happen--

01:10:04.090 --> 01:10:08.050
mean shift and
variance increase.

01:10:08.050 --> 01:10:10.450
If we start to have some
correlation in the process,

01:10:10.450 --> 01:10:13.990
and if there's some memory, some
reason that the disturbance is

01:10:13.990 --> 01:10:17.920
occurring, we can start
to actually get both.

01:10:23.840 --> 01:10:24.880
So who believes this?

01:10:29.840 --> 01:10:30.890
It's just simulation.

01:10:30.890 --> 01:10:32.180
It's just math.

01:10:32.180 --> 01:10:32.920
Who believes it?

01:10:32.920 --> 01:10:35.148
Come on.

01:10:35.148 --> 01:10:36.190
Abstention's not allowed.

01:10:40.360 --> 01:10:41.843
Believers?

01:10:41.843 --> 01:10:44.260
AUDIENCE: I don't believe in
bending an injection molding.

01:10:44.260 --> 01:10:47.230
[LAUGHS]

01:10:47.230 --> 01:10:49.550
DAVID HARDT:
Believers, agnostics?

01:10:49.550 --> 01:10:51.160
OK.

01:10:51.160 --> 01:10:56.890
Obviously, it must work,
or I wouldn't say this.

01:10:56.890 --> 01:10:59.320
So George Su, a good
part of his thesis

01:10:59.320 --> 01:11:01.487
was to say that the theory
wasn't that-- in the end,

01:11:01.487 --> 01:11:02.987
if you'd already
had the background,

01:11:02.987 --> 01:11:04.388
the theory isn't that extensive.

01:11:04.388 --> 01:11:05.930
And it does seem
too good to be true,

01:11:05.930 --> 01:11:07.030
so we said, let's
do an experiment,

01:11:07.030 --> 01:11:08.553
and let's try to
find two extremes.

01:11:08.553 --> 01:11:09.970
Let's find something
that we think

01:11:09.970 --> 01:11:11.680
has the least amount of
correlation and something

01:11:11.680 --> 01:11:13.060
that has a reasonable
correlation.

01:11:13.060 --> 01:11:15.727
Let's also find something that's
quick and easy to do in the lab

01:11:15.727 --> 01:11:16.850
that we have.

01:11:16.850 --> 01:11:19.120
And so we decided not
to do semiconductors.

01:11:19.120 --> 01:11:22.510
We decided to do bending
an injection molding.

01:11:22.510 --> 01:11:27.113
And so George set up this
experiment, which, in fact,

01:11:27.113 --> 01:11:29.530
you guys in Singapore, when
you view this, will recognize,

01:11:29.530 --> 01:11:32.110
because you've done this
in your summer experiments.

01:11:32.110 --> 01:11:34.480
It's an experiment we
used to do in this class.

01:11:34.480 --> 01:11:37.870
You take a simple strip of
sheet metal and you bend it.

01:11:37.870 --> 01:11:39.790
The input is the
depth of the punch.

01:11:39.790 --> 01:11:41.440
The output is the angle--

01:11:41.440 --> 01:11:44.050
pretty simple.

01:11:44.050 --> 01:11:47.140
And we're going to
do injection molding.

01:11:47.140 --> 01:11:49.120
This is in George's thesis.

01:11:49.120 --> 01:11:53.140
And here's the process
model for bending--

01:11:53.140 --> 01:11:55.120
pretty simple, right?

01:11:55.120 --> 01:11:57.190
The input is the
displacement of that punch.

01:11:57.190 --> 01:11:58.420
The output is the angle.

01:11:58.420 --> 01:12:01.632
George did a number of tests.

01:12:01.632 --> 01:12:02.965
He put in different [INAUDIBLE].

01:12:02.965 --> 01:12:05.037
He measured different angles--

01:12:05.037 --> 01:12:07.370
shouldn't be the straight,
but he got some good results.

01:12:07.370 --> 01:12:10.060
And so he came up with this
number for a particular value

01:12:10.060 --> 01:12:10.570
of steel.

01:12:10.570 --> 01:12:13.510
Now, keep in mind, this
number will change immediately

01:12:13.510 --> 01:12:16.300
if I put different
thickness material in

01:12:16.300 --> 01:12:19.420
or a different composition
material, because it

01:12:19.420 --> 01:12:21.550
depends yield strengths,
and stiffness,

01:12:21.550 --> 01:12:23.080
and that sort of thing.

01:12:23.080 --> 01:12:24.680
But he got a nice
number for this.

01:12:24.680 --> 01:12:26.890
So all he needed from
that was the slope.

01:12:26.890 --> 01:12:28.210
Now he had that slope.

01:12:28.210 --> 01:12:30.940
He could tune the loop
gain, knowing that slope

01:12:30.940 --> 01:12:33.460
to be somewhere around
where we wanted it to be.

01:12:33.460 --> 01:12:34.480
So he implemented that.

01:12:34.480 --> 01:12:36.320
And this data's a
little bit weird,

01:12:36.320 --> 01:12:38.530
because we hadn't, at this
point, done all the theory

01:12:38.530 --> 01:12:40.738
and realized that there was
only one true controller.

01:12:40.738 --> 01:12:43.410
So none of these are actually
for the best controller case.

01:12:43.410 --> 01:12:45.160
So here's where
a controller that

01:12:45.160 --> 01:12:48.850
is a proportional controller,
no integral control,

01:12:48.850 --> 01:12:52.060
and has a gain of 1/7.

01:12:52.060 --> 01:12:57.240
And what we want to look at
was the variance ratio only,

01:12:57.240 --> 01:12:59.865
and then see-- indeed,
what we got is--

01:13:03.900 --> 01:13:05.430
here's the data beforehand.

01:13:05.430 --> 01:13:07.650
Here's the data after-hand.

01:13:07.650 --> 01:13:11.340
And our variance did
go up, and it went up

01:13:11.340 --> 01:13:14.587
roughly equal to what
we expected it to see.

01:13:14.587 --> 01:13:15.920
That's not one of the good ones.

01:13:21.240 --> 01:13:24.480
Yeah, so here was one of the
cooler things that we did.

01:13:28.180 --> 01:13:32.260
This Is, now where we
did integral control.

01:13:32.260 --> 01:13:36.820
And we put in a disturbance,
but the disturbance

01:13:36.820 --> 01:13:39.190
was not a mean shift.

01:13:39.190 --> 01:13:42.550
What we did is we took material
of exactly the same thickness--

01:13:42.550 --> 01:13:45.500
I think that's what we did here.

01:13:45.500 --> 01:13:48.230
Yeah, we did material
exactly the same thickness,

01:13:48.230 --> 01:13:49.380
but a different material.

01:13:49.380 --> 01:13:51.710
I think we put it in
aluminum, instead of steel.

01:13:51.710 --> 01:13:55.770
So now the gain is wrong.

01:13:55.770 --> 01:13:57.800
So right here,
everything's fine.

01:13:57.800 --> 01:13:59.360
The target is 35 degrees.

01:13:59.360 --> 01:14:02.400
And George slips in
a different material.

01:14:02.400 --> 01:14:04.550
So immediately, the
angle goes right down,

01:14:04.550 --> 01:14:07.760
because he's using the
setting from the prior cycle.

01:14:07.760 --> 01:14:09.440
So now we've got
this huge error.

01:14:09.440 --> 01:14:10.190
But what happens?

01:14:10.190 --> 01:14:13.550
By following the algorithm,
in one, two, three, four time

01:14:13.550 --> 01:14:18.218
steps, its back and right on
the money where it should be.

01:14:18.218 --> 01:14:20.510
Now, he was using a game that
was too low, so this took

01:14:20.510 --> 01:14:22.520
a long time to come back up.

01:14:22.520 --> 01:14:24.980
And the variance ratio
was a little bit lower

01:14:24.980 --> 01:14:26.870
than we would have
expected, but this

01:14:26.870 --> 01:14:30.110
is another value
for this controller

01:14:30.110 --> 01:14:32.810
that I wanted to point out
to, and why using higher gains

01:14:32.810 --> 01:14:35.840
is important-- if something
like that came along,

01:14:35.840 --> 01:14:37.670
different material or
significant changes

01:14:37.670 --> 01:14:38.900
in the material.

01:14:38.900 --> 01:14:41.510
This automatically,
with no intervention

01:14:41.510 --> 01:14:44.450
on anybody's part-- not even
pulling the and on cord,

01:14:44.450 --> 01:14:49.020
or having to do a statistically
significant number

01:14:49.020 --> 01:14:50.970
of measurements-- just
get you back on track.

01:14:50.970 --> 01:14:54.030
And it's a classic example of
the strength of disturbance

01:14:54.030 --> 01:14:58.930
response for a controller.

01:14:58.930 --> 01:15:06.023
Now, a compilation of
everything that George

01:15:06.023 --> 01:15:08.440
did over all the experiments
with the integral controllers

01:15:08.440 --> 01:15:09.400
is he just--

01:15:09.400 --> 01:15:12.430
for the bending, he
said, let's take a look

01:15:12.430 --> 01:15:16.690
at this quantity v, which was
the expected quality loss.

01:15:16.690 --> 01:15:18.730
And he plotted it as a
function of the gain,

01:15:18.730 --> 01:15:22.270
and indeed, it goes through a
minimum right at the gain of 1,

01:15:22.270 --> 01:15:23.480
and then goes back up.

01:15:23.480 --> 01:15:26.680
So that was a
pretty good result.

01:15:26.680 --> 01:15:29.650
And it said that,
indeed, from no gain

01:15:29.650 --> 01:15:31.300
at all where the
variance is very high

01:15:31.300 --> 01:15:36.560
and the offsets could be very
high, we did a lot better.

01:15:36.560 --> 01:15:39.970
AUDIENCE: Excuse me, was
that curve from experiments?

01:15:39.970 --> 01:15:41.777
DAVID HARDT: Yes, yes.

01:15:41.777 --> 01:15:42.360
Wait a second.

01:15:42.360 --> 01:15:43.900
Actually, no, you're right.

01:15:43.900 --> 01:15:44.400
I'm sorry.

01:15:44.400 --> 01:15:45.740
This was calculated.

01:15:45.740 --> 01:15:46.990
This was not from experiments.

01:15:46.990 --> 01:15:47.490
Yeah.

01:15:47.490 --> 01:15:50.160
But it suggested, again,
that kc should be 1.

01:15:50.160 --> 01:15:51.270
Yes, I'm sorry.

01:15:51.270 --> 01:15:52.620
So then he did this experiment.

01:15:52.620 --> 01:15:56.195
He increased the gain to
1 for the material shift,

01:15:56.195 --> 01:15:58.320
and-- well, this is a
different material shift too.

01:15:58.320 --> 01:15:59.820
This was a change in thickness.

01:15:59.820 --> 01:16:02.400
And, again change in thickness--
it immediately goes down,

01:16:02.400 --> 01:16:06.840
and just in two time steps,
it's back up to zero--

01:16:06.840 --> 01:16:09.180
so pretty cool.

01:16:09.180 --> 01:16:13.110
So it confirms that, indeed,
we can go from here to here

01:16:13.110 --> 01:16:14.650
in a predictable amount of time.

01:16:14.650 --> 01:16:16.780
The higher the gain, the
faster it gets there.

01:16:16.780 --> 01:16:18.322
But what this doesn't
show, but which

01:16:18.322 --> 01:16:19.905
we did have with
other data-- it said,

01:16:19.905 --> 01:16:21.450
yeah, it does
increase the variance

01:16:21.450 --> 01:16:25.800
about the amount we expected.

01:16:25.800 --> 01:16:28.388
OK, so now let's go
to injection molding.

01:16:28.388 --> 01:16:30.180
Well, that got more
complicated right away,

01:16:30.180 --> 01:16:32.638
because the first thing you
find out with injection molding

01:16:32.638 --> 01:16:34.620
is you're not sure
which variables matter.

01:16:34.620 --> 01:16:36.630
You're not sure what
the process gain is,

01:16:36.630 --> 01:16:38.880
so we had to do a
full DOE on the thing

01:16:38.880 --> 01:16:42.480
and do a significance, test and
find out what was important.

01:16:42.480 --> 01:16:45.240
And what we ended up with,
through the end of analysis

01:16:45.240 --> 01:16:47.868
and some other stuff was, I
think-- yeah, that hold time--

01:16:47.868 --> 01:16:50.410
for his particular problem, hold
time was the most important.

01:16:50.410 --> 01:16:55.040
He was molding rings,
simple test rings.

01:16:55.040 --> 01:16:59.690
And so we came up with a
model that looked like this.

01:16:59.690 --> 01:17:02.450
Again, that term didn't matter,
but it was a constant times

01:17:02.450 --> 01:17:04.820
x2, which was the hold time.

01:17:04.820 --> 01:17:05.750
This is reduced one.

01:17:05.750 --> 01:17:09.200
He started with a lot more
variables to start with.

01:17:09.200 --> 01:17:11.120
So here's proportional
control-- again,

01:17:11.120 --> 01:17:12.800
one that we later abandoned.

01:17:12.800 --> 01:17:16.890
But it gives you a nice example
of what-- of a bunch of things.

01:17:16.890 --> 01:17:18.843
Here's open loop, and
he's making these parts

01:17:18.843 --> 01:17:20.510
and noticing they're
all over the place,

01:17:20.510 --> 01:17:23.040
and they're kind of drifting.

01:17:23.040 --> 01:17:24.500
They're not even steady.

01:17:24.500 --> 01:17:26.810
And then he turns on the
controller with a closed loop

01:17:26.810 --> 01:17:30.830
gain of 1/2, and the mean
value is not correct,

01:17:30.830 --> 01:17:32.970
but it's constant.

01:17:32.970 --> 01:17:34.850
So it's completely
eliminating these shifts

01:17:34.850 --> 01:17:40.330
that were going on, and the
effect is quite dramatic.

01:17:40.330 --> 01:17:42.080
Oh, and the other thing
that's really cool

01:17:42.080 --> 01:17:45.070
is that the variance
ratio was like 1/4.

01:17:45.070 --> 01:17:47.570
So you can see here that this
is kind of all over the place,

01:17:47.570 --> 01:17:49.970
and now it's greatly reduced.

01:17:52.782 --> 01:17:54.990
You can actually measure
the correlation of these two

01:17:54.990 --> 01:17:56.850
processes by just doing--

01:17:56.850 --> 01:18:00.510
running it through a
correlation filter.

01:18:00.510 --> 01:18:02.560
This doesn't tell you
just by looking at it,

01:18:02.560 --> 01:18:04.518
they're using that
function, but this basically

01:18:04.518 --> 01:18:06.360
means that bending was
indeed uncorrelated,

01:18:06.360 --> 01:18:08.555
and injection molding
was-- had some correlation.

01:18:08.555 --> 01:18:10.680
There's a little bit of
correlation in the bending,

01:18:10.680 --> 01:18:13.100
because the variance
comes from coupons

01:18:13.100 --> 01:18:15.100
that were cut from the
same sheet of sheet metal

01:18:15.100 --> 01:18:16.058
and that sort of thing.

01:18:20.910 --> 01:18:22.730
That's cool too.

01:18:22.730 --> 01:18:24.460
That's basically more
of the same thing.

01:18:24.460 --> 01:18:29.100
Here's the one I want to
show you is that in injection

01:18:29.100 --> 01:18:31.200
molding integral control--

01:18:31.200 --> 01:18:32.610
it just zooms right in.

01:18:32.610 --> 01:18:36.600
The desired value was 1.436.

01:18:36.600 --> 01:18:38.130
It just pops you
right onto that.

01:18:38.130 --> 01:18:42.182
I guess the measurements
have some error in,

01:18:42.182 --> 01:18:43.140
but this is in inches--

01:18:43.140 --> 01:18:46.320
1.438, and a variance
ratio of 0.4.

01:18:46.320 --> 01:18:48.540
So this is the one
example from his data

01:18:48.540 --> 01:18:53.640
of implementing what we
consider the ideal controller.

01:18:53.640 --> 01:18:57.420
Simply put, it does what
we expected it to do.

01:18:57.420 --> 01:19:01.290
So from these model
predictions and the assumptions

01:19:01.290 --> 01:19:03.000
that we make, we
make the argument

01:19:03.000 --> 01:19:06.330
that we can do this discrete
time control stuff--

01:19:06.330 --> 01:19:08.580
that discrete time
control theory

01:19:08.580 --> 01:19:11.080
will well fit what's going on.

01:19:11.080 --> 01:19:13.870
And you get this condition,
where you will always

01:19:13.870 --> 01:19:16.480
center this, and you
will get varying degrees

01:19:16.480 --> 01:19:22.090
of either amplification or
attenuation of the variance.

01:19:22.090 --> 01:19:23.590
But the thing I
want to emphasize

01:19:23.590 --> 01:19:29.260
is that this is hardcore
feedback control.

01:19:29.260 --> 01:19:31.990
But the way we implement it,
the way it could be implemented

01:19:31.990 --> 01:19:35.187
is simply to have a
path of paper that says,

01:19:35.187 --> 01:19:37.270
if you measure this error,
do the following thing.

01:19:37.270 --> 01:19:39.550
If you measure that error,
do the following thing.

01:19:39.550 --> 01:19:42.220
And you will get these results.

01:19:42.220 --> 01:19:45.100
So it's highly implementable.

01:19:45.100 --> 01:19:46.700
It could be done
automated as well,

01:19:46.700 --> 01:19:48.010
but it's highly implementable.

01:19:48.010 --> 01:19:50.080
And as I understand, in
the semiconductor field,

01:19:50.080 --> 01:19:51.280
the run-by-run is--

01:19:51.280 --> 01:19:55.660
I guess my sense was that,
when it first came out,

01:19:55.660 --> 01:19:58.520
everybody said, yeah, that's
great, but we don't need it.

01:19:58.520 --> 01:20:02.020
And now, as basically
the needs here

01:20:02.020 --> 01:20:04.330
and the criticality
of the mean shifts

01:20:04.330 --> 01:20:07.120
have gotten tighter and tighter,
they're saying, oh, jeez,

01:20:07.120 --> 01:20:10.083
we do need this, and
it's starting to be used.

01:20:10.083 --> 01:20:10.750
Is that correct?

01:20:10.750 --> 01:20:11.375
AUDIENCE: Yeah.

01:20:11.375 --> 01:20:12.458
DAVID HARDT: Yeah.

01:20:12.458 --> 01:20:14.500
I think we talked about
this earlier in the term.

01:20:14.500 --> 01:20:18.256
This whole issue-- when you
get to process capability,

01:20:18.256 --> 01:20:22.690
if the state of the art is--

01:20:22.690 --> 01:20:30.010
here's the process, and here's
the process capability window,

01:20:30.010 --> 01:20:31.330
show me the problem you have.

01:20:31.330 --> 01:20:33.140
There's no problem.

01:20:33.140 --> 01:20:35.680
But if this window all of a
sudden looks like this, say,

01:20:35.680 --> 01:20:41.010
because you're doing 10th
micron lines, whereas before,

01:20:41.010 --> 01:20:46.200
you were doing 5 micron lines,
or you're doing precision

01:20:46.200 --> 01:20:49.080
machine, whereas before you
were doing non-precision--

01:20:49.080 --> 01:20:50.987
this compared to this
looks pretty awful.

01:20:50.987 --> 01:20:53.070
And if you don't know how
to go from here to here,

01:20:53.070 --> 01:20:54.210
what do you do?

01:20:54.210 --> 01:20:56.430
Well, again, run-by-run
or cycle-to-cycle

01:20:56.430 --> 01:20:59.190
says, well, one thing I can
tell you is I can get that baby

01:20:59.190 --> 01:21:01.318
right over in the middle there.

01:21:01.318 --> 01:21:03.360
And if I can work on the
variance, I can do more.

01:21:07.370 --> 01:21:09.902
And the other thing is
the correlation helps.

01:21:09.902 --> 01:21:11.360
We've kind of
avoided correlation--

01:21:11.360 --> 01:21:13.460
because it's
theoretically nasty--

01:21:13.460 --> 01:21:15.260
throughout this class,
but most processes

01:21:15.260 --> 01:21:17.930
do have a little bit
of correlation in them.

01:21:17.930 --> 01:21:19.940
And if I have the
correlation, then indeed,

01:21:19.940 --> 01:21:24.020
I can reduce this even
more, as I mentioned.

01:21:24.020 --> 01:21:26.600
And the last thing I mentioned
is that we have demonstrated

01:21:26.600 --> 01:21:29.400
this as well on a couple
different processes,

01:21:29.400 --> 01:21:33.050
but Adam [INAUDIBLE],,
a couple of years ago,

01:21:33.050 --> 01:21:37.590
extended it to a
100-by-100 problem--

01:21:37.590 --> 01:21:39.290
so 100 inputs, 100
outputs-- because we

01:21:39.290 --> 01:21:40.820
had this whole
process we've been

01:21:40.820 --> 01:21:44.190
looking at in our lab for years
called flexible die-forming

01:21:44.190 --> 01:21:44.690
forming.

01:21:44.690 --> 01:21:47.960
And we had a tool, a
forming machine-- full-size

01:21:47.960 --> 01:21:49.850
forming machine made
up of a lot of elements

01:21:49.850 --> 01:21:51.030
you can move around.

01:21:51.030 --> 01:21:53.238
And in this particular case,
there were 100 elements.

01:21:53.238 --> 01:21:56.120
We used to have a lot
more, but he had 100.

01:21:56.120 --> 01:21:59.030
And the idea is you would form
something, measure it, and say

01:21:59.030 --> 01:22:00.690
there's a shape error.

01:22:00.690 --> 01:22:01.430
How do I fix it?

01:22:01.430 --> 01:22:05.190
And you'd like to do that
as quickly as possible.

01:22:05.190 --> 01:22:06.722
And with this method,
you could show

01:22:06.722 --> 01:22:08.180
that, within one
or two cycles, you

01:22:08.180 --> 01:22:10.250
could reduce the error in that.

01:22:10.250 --> 01:22:13.160
The extension is pretty
complicated, but most

01:22:13.160 --> 01:22:17.780
of the results just to
show up the same way.

01:22:17.780 --> 01:22:20.210
OK?

01:22:20.210 --> 01:22:23.620
Labor Day well spent--

01:22:23.620 --> 01:22:27.010
all right, if you're interested
in this more, as I said,

01:22:27.010 --> 01:22:29.980
there are a couple of papers
that I put on the web.

01:22:29.980 --> 01:22:32.260
There are two
underlying theses--

01:22:32.260 --> 01:22:34.978
a master's thesis
and a PhD thesis.

01:22:34.978 --> 01:22:36.520
That's just the work
we've done here.

01:22:36.520 --> 01:22:39.735
And then, of course, in the
semiconductor literature

01:22:39.735 --> 01:22:41.860
primarily-- a little bit
in the statistical control

01:22:41.860 --> 01:22:44.290
literature-- there's
more into this idea

01:22:44.290 --> 01:22:46.720
of run-by-run control.

01:22:46.720 --> 01:22:48.390
And let's hear the
term they use, Duane?

01:22:48.390 --> 01:22:49.654
It's in the--

01:22:49.654 --> 01:22:51.410
AUDIENCE: There's
run-to-run, run-by-run--

01:22:51.410 --> 01:22:54.250
DAVID HARDT: Yeah, run-to-run--
but even in the general

01:22:54.250 --> 01:22:56.410
statistics community,
there is a term for--

01:22:56.410 --> 01:22:59.260
oh, they call it
adjustment, something

01:22:59.260 --> 01:23:01.690
like continuous adjustment
or feedback adjustment.

01:23:01.690 --> 01:23:03.100
AUDIENCE:
--engineering control--

01:23:03.100 --> 01:23:05.017
DAVID HARDT: Yeah,
engineering control-- yeah.

01:23:05.017 --> 01:23:06.517
It's used a little
bit derogatorily.

01:23:06.517 --> 01:23:07.420
AUDIENCE: [INAUDIBLE]

01:23:07.420 --> 01:23:09.190
DAVID HARDT: Yeah--
right, right.

01:23:09.190 --> 01:23:11.810
So yeah, if you have to have
any more questions about that,

01:23:11.810 --> 01:23:13.900
feel free to contact me.

01:23:13.900 --> 01:23:16.360
OK, thank you all.