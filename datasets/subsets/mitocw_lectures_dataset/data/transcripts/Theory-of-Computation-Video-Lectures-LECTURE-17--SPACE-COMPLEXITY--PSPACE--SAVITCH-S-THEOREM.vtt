WEBVTT

00:00:00.000 --> 00:00:01.988
[SQUEAKING]

00:00:02.982 --> 00:00:04.473
[RUSTLING]

00:00:04.473 --> 00:00:05.467
[CLICKING]

00:00:24.890 --> 00:00:31.820
PROFESSOR: So we've been
talking about P and NP and time

00:00:31.820 --> 00:00:33.350
complexity classes.

00:00:33.350 --> 00:00:35.630
And today we're
going to shift gear.

00:00:35.630 --> 00:00:38.930
We're going to talk about
space complexity or memory

00:00:38.930 --> 00:00:44.090
complexity, as space complexity
is what complexity theorists

00:00:44.090 --> 00:00:48.260
usually refer to it as.

00:00:48.260 --> 00:00:53.810
And time and space are the
two basic most basic measures

00:00:53.810 --> 00:00:57.600
of complexity that we consider.

00:00:57.600 --> 00:01:03.470
And so today we're going to
look at the second of those two,

00:01:03.470 --> 00:01:04.550
the space complexity.

00:01:08.480 --> 00:01:13.040
A lot of this is going to
be by analogy with what

00:01:13.040 --> 00:01:14.420
we did for time complexity.

00:01:14.420 --> 00:01:16.580
We're going to define
complexity classes.

00:01:16.580 --> 00:01:18.740
We'll talk about
polynomial space

00:01:18.740 --> 00:01:21.500
and nondeterministic
polynomial space,

00:01:21.500 --> 00:01:25.550
see how those classes connect
up with the time complexity

00:01:25.550 --> 00:01:27.590
classes that we've
already defined.

00:01:27.590 --> 00:01:30.380
And we'll do some examples
that will be setting us up

00:01:30.380 --> 00:01:35.540
for our further discussion about
space complexity next week.

00:01:35.540 --> 00:01:37.990
So we're going to
talk about, first

00:01:37.990 --> 00:01:42.370
of all, what it means
for a Turing machine

00:01:42.370 --> 00:01:46.310
to run in a certain
amount of space.

00:01:46.310 --> 00:01:51.460
And that's simply going to be
counting the number of cells

00:01:51.460 --> 00:01:56.080
that the Turing machine
scans over on its tape

00:01:56.080 --> 00:01:58.000
during the course
of its computation.

00:01:58.000 --> 00:01:59.800
It might be reading that cell.

00:01:59.800 --> 00:02:01.630
It might be writing
on that cell.

00:02:01.630 --> 00:02:08.020
But the total number of cells
that it actually visits--

00:02:08.020 --> 00:02:10.810
of course, visiting the
same cell multiple times

00:02:10.810 --> 00:02:15.670
only counts once because
space can be reused.

00:02:15.670 --> 00:02:18.130
But we're going to count
the number of cells

00:02:18.130 --> 00:02:20.530
that the Turing machine
visits during the course

00:02:20.530 --> 00:02:24.520
of its computation, and
then define the space

00:02:24.520 --> 00:02:27.830
utilization by analogy
with what we did for time.

00:02:27.830 --> 00:02:30.070
So we'll say a
Turing machine runs

00:02:30.070 --> 00:02:31.450
in a certain amount of space--

00:02:31.450 --> 00:02:33.672
f of n, we'll say.

00:02:33.672 --> 00:02:36.130
First of all, it has to always
hold, so all of the machines

00:02:36.130 --> 00:02:37.600
are deciders.

00:02:37.600 --> 00:02:42.685
And it uses at most
that much tape--

00:02:45.440 --> 00:02:47.950
it visits that number of cells--

00:02:47.950 --> 00:02:50.980
on all inputs of length n.

00:02:50.980 --> 00:02:53.710
So just like we said
for time complexity,

00:02:53.710 --> 00:02:57.760
the machine has to
run within t of n time

00:02:57.760 --> 00:03:00.790
on all inputs of
length n, here it's

00:03:00.790 --> 00:03:04.860
going to have to use
at most f of n cells

00:03:04.860 --> 00:03:07.380
on all inputs of length
n in order for it

00:03:07.380 --> 00:03:09.480
to be running in space f of n.

00:03:13.070 --> 00:03:16.760
A tape cell is simply a
little square of the tape

00:03:16.760 --> 00:03:20.233
where you can write a symbol--

00:03:20.233 --> 00:03:21.900
answering a question,
that good question

00:03:21.900 --> 00:03:23.370
that came in from the chat.

00:03:23.370 --> 00:03:31.430
So I'm not sure we I have
the diagram for that.

00:03:31.430 --> 00:03:33.180
And each of the little
squares on the tape

00:03:33.180 --> 00:03:35.807
are going to be the tape cells.

00:03:35.807 --> 00:03:38.140
Generally, we're going to be
sticking to one-tape Turing

00:03:38.140 --> 00:03:38.830
machines.

00:03:38.830 --> 00:03:41.080
But I'll make a brief remark
about multi-tape Turing

00:03:41.080 --> 00:03:43.530
machines shortly.

00:03:43.530 --> 00:03:44.040
Better?

00:03:44.040 --> 00:03:48.360
Tape cells, sorry, on
all inputs of length n.

00:03:51.060 --> 00:03:54.720
So that's for deterministic
Turing machines.

00:03:54.720 --> 00:03:56.880
For nondeterministic
Turing machines,

00:03:56.880 --> 00:04:05.590
we will say that it also runs
in a certain amount of space.

00:04:05.590 --> 00:04:09.140
So for a
nondeterministic machine,

00:04:09.140 --> 00:04:20.200
it has to use at most that
many tape cells on each branch

00:04:20.200 --> 00:04:22.850
of its computation separately.

00:04:22.850 --> 00:04:24.820
You don't add up
the total number

00:04:24.820 --> 00:04:27.910
of cells used across
all of the branches,

00:04:27.910 --> 00:04:30.280
just like we don't add up
the total amount of time

00:04:30.280 --> 00:04:33.160
the machine uses across
all of its branches.

00:04:33.160 --> 00:04:37.990
For the machine to be running
in, say, space n squared,

00:04:37.990 --> 00:04:42.280
it has to be using at most
n squared cells or order n

00:04:42.280 --> 00:04:46.450
squared cells on each one of
its nondeterministic branches

00:04:46.450 --> 00:04:48.830
separately.

00:04:48.830 --> 00:04:52.140
There might be exponentially
many branches, but that's OK.

00:04:52.140 --> 00:04:56.090
But on each branch, it's going
to be using at most n squared

00:04:56.090 --> 00:04:58.760
or order n squared cells.

00:04:58.760 --> 00:05:01.730
Importantly, though,
that still the machine

00:05:01.730 --> 00:05:03.260
has to be a decider.

00:05:03.260 --> 00:05:07.010
It's not enough to be
looping forever and using

00:05:07.010 --> 00:05:09.590
a small amount of space.

00:05:09.590 --> 00:05:11.480
It could do that,
but that's not going

00:05:11.480 --> 00:05:16.010
to count toward the machine
contributing to its space

00:05:16.010 --> 00:05:17.730
complexity of that language.

00:05:17.730 --> 00:05:21.350
So for the machine to be running
in a certain amount of space,

00:05:21.350 --> 00:05:25.610
we say that the machine
holds on all of its branches.

00:05:25.610 --> 00:05:30.590
And each one of its branches
uses at most that much space.

00:05:36.520 --> 00:05:38.760
I can see lots of typos here.

00:05:38.760 --> 00:05:40.394
Thank you.

00:05:40.394 --> 00:05:44.430
Why did I mess
this all up today?

00:05:44.430 --> 00:05:54.110
So nondeterministic--
good, thank you.

00:05:59.370 --> 00:06:03.660
All right, so we're going to
define the space complexity

00:06:03.660 --> 00:06:06.430
classes analogous to this
time complexity classes.

00:06:06.430 --> 00:06:13.100
So these are languages that
you can do with machines that

00:06:13.100 --> 00:06:15.850
run within that space bound.

00:06:15.850 --> 00:06:21.060
So space f of n-- you can
think of space n squared--

00:06:21.060 --> 00:06:26.830
is all of the languages that a
deterministic one-tape Turing

00:06:26.830 --> 00:06:30.700
machine can do within--

00:06:30.700 --> 00:06:35.260
can decide within-- by using
at most n squared tape cells,

00:06:35.260 --> 00:06:36.790
order n squared tape cells.

00:06:36.790 --> 00:06:40.990
Similarly, the nondeterministic
space complexity class

00:06:40.990 --> 00:06:45.850
are all of the languages that
a nondeterministic one-tape

00:06:45.850 --> 00:06:48.190
Turing machine can
decide, running

00:06:48.190 --> 00:06:49.375
within that amount of space.

00:06:53.440 --> 00:06:58.030
And lastly, we have
polynomial space.

00:06:58.030 --> 00:07:01.120
So that's the union over
all polynomial space bounds

00:07:01.120 --> 00:07:04.480
of the space complexity class,
and nondeterministic polynomial

00:07:04.480 --> 00:07:05.590
space--

00:07:05.590 --> 00:07:09.310
the same for all of the
nondeterministic polynomial

00:07:09.310 --> 00:07:12.260
space classes.

00:07:12.260 --> 00:07:18.970
So I think I do have
a check-in on this

00:07:18.970 --> 00:07:22.495
which talks about
multi-tape Turing machines.

00:07:25.190 --> 00:07:27.850
So we can define
space complexity

00:07:27.850 --> 00:07:30.520
for multi-tape
Turing machines, just

00:07:30.520 --> 00:07:32.860
as we did for one-tape
Turing machines,

00:07:32.860 --> 00:07:36.580
and then define the associated
space complexity classes,

00:07:36.580 --> 00:07:40.580
and then define
the class P space.

00:07:40.580 --> 00:07:44.530
But that would be for
multi-tape Turing machines.

00:07:44.530 --> 00:07:49.690
Now for time, remember
that the class

00:07:49.690 --> 00:07:52.600
P that you would get for
multi-tape Turing machines is

00:07:52.600 --> 00:07:56.230
exactly the same as the class P
that we got for one-tape Turing

00:07:56.230 --> 00:07:57.670
machines.

00:07:57.670 --> 00:08:02.565
That was part of the
nice quality of the class

00:08:02.565 --> 00:08:04.530
P. It's robust in that
sense, and natural.

00:08:04.530 --> 00:08:06.420
So how about for PSPACE?

00:08:06.420 --> 00:08:07.170
What do you think?

00:08:07.170 --> 00:08:10.030
Do we get the same class?

00:08:10.030 --> 00:08:10.530
No?

00:08:10.530 --> 00:08:11.430
Maybe?

00:08:11.430 --> 00:08:15.960
Or yes, because we can convert
a multi-tape Turing machine

00:08:15.960 --> 00:08:18.090
to a single-tape
Turing machine, by only

00:08:18.090 --> 00:08:21.240
squaring the amount of space?

00:08:21.240 --> 00:08:23.790
That was what happened
with time, as you remember.

00:08:23.790 --> 00:08:25.350
Or maybe we can do even better.

00:08:25.350 --> 00:08:28.050
Converting a multi-tape Turing
machine to single-tape only

00:08:28.050 --> 00:08:31.590
increases it by less-- by,
say, a constant factor.

00:08:31.590 --> 00:08:33.630
Here, remember,
this is how we're

00:08:33.630 --> 00:08:36.390
defining space complexity for
multi-tape Turing machines.

00:08:36.390 --> 00:08:40.199
We're taking the sum of all the
cells used on all of the tapes.

00:08:43.730 --> 00:08:50.420
All right, so let's launch that
poll and see what you think.

00:08:50.420 --> 00:08:52.735
Hopefully, this is not too hard.

00:08:55.870 --> 00:08:58.090
Yeah, I think most of you
have got the idea, though.

00:08:58.090 --> 00:08:59.290
Some of you are--

00:08:59.290 --> 00:09:03.310
I worry sometimes about some
of the answers that I get.

00:09:03.310 --> 00:09:06.790
I don't know if you're
serious, or you're really

00:09:06.790 --> 00:09:10.090
badly confused.

00:09:10.090 --> 00:09:13.640
But anyway, let's wrap this up--

00:09:13.640 --> 00:09:17.820
another 10 seconds or so.

00:09:21.695 --> 00:09:22.195
Last call.

00:09:25.267 --> 00:09:26.100
I'm going to end it.

00:09:30.330 --> 00:09:37.680
Yeah, I mean, I think answer
B is a reasonable answer.

00:09:37.680 --> 00:09:41.790
In fact, answer C is
the correct answer.

00:09:41.790 --> 00:09:46.080
If you just look at the same
simulation from multi-tape

00:09:46.080 --> 00:09:51.660
to single-tape and how much
space overhead that simulation

00:09:51.660 --> 00:09:54.660
introduces, it's only linear.

00:09:54.660 --> 00:09:56.670
You're basically just
taking all of the tapes

00:09:56.670 --> 00:09:58.740
of the multi-tape
machine and writing them

00:09:58.740 --> 00:10:02.340
down next to one another,
obviously ignoring

00:10:02.340 --> 00:10:04.380
all the infinitely many blanks.

00:10:04.380 --> 00:10:06.608
We're just taking the
active portion of the tapes,

00:10:06.608 --> 00:10:08.150
writing them down
next to each other.

00:10:08.150 --> 00:10:10.410
So the total amount
used is just going

00:10:10.410 --> 00:10:13.440
to be the sum on the
single-tape of what

00:10:13.440 --> 00:10:18.180
was used on each of the
individual multi-tapes

00:10:18.180 --> 00:10:19.890
in the original machine.

00:10:19.890 --> 00:10:24.240
So there is just a
linear cost overhead

00:10:24.240 --> 00:10:26.190
by converting from
multi-tape to single-tape

00:10:26.190 --> 00:10:28.890
when you're looking at space,
the amount of memory that's

00:10:28.890 --> 00:10:30.880
used.

00:10:30.880 --> 00:10:33.640
For time, remember there
was some additional overhead

00:10:33.640 --> 00:10:38.980
because we had to be updating
where the virtual heads were.

00:10:38.980 --> 00:10:44.200
And that cost extra time to
move our single head around

00:10:44.200 --> 00:10:45.140
to do that.

00:10:45.140 --> 00:10:48.400
But for space, the amount
of time that's introduced

00:10:48.400 --> 00:10:49.518
is irrelevant.

00:10:49.518 --> 00:10:51.310
We're only looking at
the amount of memory.

00:10:51.310 --> 00:10:52.495
And so that's a--

00:10:56.041 --> 00:10:59.500
the overhead on
that is very low.

00:10:59.500 --> 00:11:03.420
I do worry about the folks who
are answering A, for example,

00:11:03.420 --> 00:11:04.420
for this question.

00:11:04.420 --> 00:11:08.860
You should be rethinking
what's really going on here.

00:11:14.570 --> 00:11:23.030
Now let us move on here
from that to our next slide

00:11:23.030 --> 00:11:29.795
and compare the time and
space complexity classes.

00:11:29.795 --> 00:11:34.200
Time and space complexity-- how
do they relate to one another?

00:11:34.200 --> 00:11:37.370
And so first of all,
we're going to point out--

00:11:40.190 --> 00:11:44.960
let's start out--
here, t of n is

00:11:44.960 --> 00:11:46.490
going to be
representing some bound,

00:11:46.490 --> 00:11:48.830
either on the time or
the amount of space.

00:11:48.830 --> 00:11:52.130
And generally, at least
up until this point,

00:11:52.130 --> 00:11:54.680
and mostly going
forward, though there's

00:11:54.680 --> 00:11:58.080
going to be one variation
on that a little later,

00:11:58.080 --> 00:12:02.030
but we're going to be
focusing on bounds which

00:12:02.030 --> 00:12:05.570
are at least big enough
to either read the input

00:12:05.570 --> 00:12:07.230
or at least hold the input.

00:12:07.230 --> 00:12:13.530
So that's why we refer to
t of n being at least n.

00:12:13.530 --> 00:12:19.080
So now if we look at the time
complexity class t of n--

00:12:19.080 --> 00:12:21.660
think of-- t of n
typically would be, say,

00:12:21.660 --> 00:12:24.650
n squared, maybe.

00:12:24.650 --> 00:12:27.110
And the things that
you can do in n

00:12:27.110 --> 00:12:32.420
squared time I claim you can
also do in n squared space.

00:12:35.240 --> 00:12:40.010
And basically, it's just
using the very same machine.

00:12:40.010 --> 00:12:43.130
Suppose you have a machine
that runs in n squared time.

00:12:43.130 --> 00:12:45.740
How could it possibly
use, say, n squared--

00:12:45.740 --> 00:12:49.610
n cubed-- space, if it's
running only in n squared time?

00:12:49.610 --> 00:12:53.490
Even if it tries to use as
much tape as it possibly could,

00:12:53.490 --> 00:12:56.300
as many tape cells
as it possibly could,

00:12:56.300 --> 00:13:00.290
and sending its
head cruising out

00:13:00.290 --> 00:13:03.680
into the blank portion of the
tape, chewing up as much--

00:13:03.680 --> 00:13:06.140
as many tape cells
as it possibly can--

00:13:06.140 --> 00:13:08.300
in n squared time,
it's only going

00:13:08.300 --> 00:13:10.910
to be able to use
n squared space.

00:13:10.910 --> 00:13:14.780
So the very same machine
that runs in t of n time

00:13:14.780 --> 00:13:17.610
is also going to
run in t of n space.

00:13:17.610 --> 00:13:23.420
So this containment
here follows really

00:13:23.420 --> 00:13:27.840
without doing any work at all.

00:13:27.840 --> 00:13:33.380
So just restating that here, a
Turing machine that runs in t

00:13:33.380 --> 00:13:37.670
of n steps cannot use more
than t of n tape cells.

00:13:37.670 --> 00:13:39.270
So right now,
we're focusing on--

00:13:39.270 --> 00:13:41.630
we could prove some
analogous statements

00:13:41.630 --> 00:13:45.170
about nondeterministic
complexity,

00:13:45.170 --> 00:13:49.310
but let's focus here on the
deterministic complexity.

00:13:49.310 --> 00:13:51.560
Now let's look at going
the other direction.

00:13:51.560 --> 00:13:58.400
Suppose we have a Turing machine
that uses t of n space now.

00:13:58.400 --> 00:14:03.150
Does that immediately imply
it's using only t of n time?

00:14:03.150 --> 00:14:07.680
And that's not so clear and,
in fact, probably not true,

00:14:07.680 --> 00:14:12.870
because space appears to be
much more powerful than time.

00:14:12.870 --> 00:14:14.490
And within a certain
amount of space,

00:14:14.490 --> 00:14:18.700
you can run for much longer
than that same amount of time.

00:14:18.700 --> 00:14:22.400
So how long could you run?

00:14:22.400 --> 00:14:28.510
So what you can show is that if
you're running within a certain

00:14:28.510 --> 00:14:30.760
amount of space-- t of
n space, let's say--

00:14:30.760 --> 00:14:33.680
n squared space, for example.

00:14:33.680 --> 00:14:35.980
The amount of time
you could use is

00:14:35.980 --> 00:14:40.025
going to be exponential in n
squared, a 2 to the order n

00:14:40.025 --> 00:14:40.525
squared.

00:14:43.060 --> 00:14:48.880
Sometimes we also write that
as the union of c to the n

00:14:48.880 --> 00:14:53.050
squared by pulling down
that constant here.

00:14:53.050 --> 00:14:55.240
Well, it's also
just to understand

00:14:55.240 --> 00:14:58.030
what we mean by order t
of n up in the exponent.

00:14:58.030 --> 00:15:02.432
It means the union over c
to the t of n for all c.

00:15:02.432 --> 00:15:04.390
Either of these are just
completely equivalent,

00:15:04.390 --> 00:15:06.790
so whichever one you're
more comfortable with.

00:15:06.790 --> 00:15:08.750
But why is this
going to be true?

00:15:08.750 --> 00:15:17.410
Why does a Turing machine that
runs in, say, n squared space,

00:15:17.410 --> 00:15:26.540
use at most 2 to the
order n squared time?

00:15:26.540 --> 00:15:28.790
And that's because
if you look at how

00:15:28.790 --> 00:15:33.020
many possible configurations
the machine can have,

00:15:33.020 --> 00:15:37.220
remember that a
configuration is essentially

00:15:37.220 --> 00:15:38.840
the contents of the tape.

00:15:38.840 --> 00:15:41.180
There's also the head
position and the state.

00:15:41.180 --> 00:15:47.390
But the dominant aspect of
a configuration is the tape.

00:15:47.390 --> 00:15:51.820
And so how many different
tape contents can you have?

00:15:51.820 --> 00:15:54.910
Well, it's going to be
exponential in the length

00:15:54.910 --> 00:15:59.110
of that tape because each
cell can have some fixed

00:15:59.110 --> 00:16:02.150
number of symbols in it.

00:16:02.150 --> 00:16:05.480
If a machine repeats
a configuration,

00:16:05.480 --> 00:16:07.130
it's going to go
forever, which we're

00:16:07.130 --> 00:16:12.410
forbidding in these
machines, because they're all

00:16:12.410 --> 00:16:13.730
going to be deciders.

00:16:13.730 --> 00:16:19.290
So they can only run
for an amount of time

00:16:19.290 --> 00:16:21.680
which is bounded by the
number of configurations

00:16:21.680 --> 00:16:23.340
that the machine can have.

00:16:23.340 --> 00:16:24.635
And so the machine can have--

00:16:27.590 --> 00:16:32.180
if it's running in t of
n space, then the amount

00:16:32.180 --> 00:16:34.640
of time that it
could be running is

00:16:34.640 --> 00:16:38.180
going to be at most some
constant to the t of n or 2

00:16:38.180 --> 00:16:42.210
to the order of t of n,
saying the same thing,

00:16:42.210 --> 00:16:44.148
unless it's going to
repeat a configuration

00:16:44.148 --> 00:16:44.940
and end up looping.

00:16:47.780 --> 00:16:51.050
So these are the two
fundamental connections

00:16:51.050 --> 00:16:52.550
between time and space.

00:16:52.550 --> 00:16:55.520
Time is contained within
the same amount of space.

00:16:55.520 --> 00:16:59.240
Space is contained within that
amount of time exponentiated.

00:17:04.310 --> 00:17:08.060
So one corollary of
that is that the class P

00:17:08.060 --> 00:17:09.270
is contained within PSPACE.

00:17:13.069 --> 00:17:16.089
Similarly, NP is going to
be contained within NPSPACE

00:17:16.089 --> 00:17:17.230
for the very same reason.

00:17:22.700 --> 00:17:28.089
Is this understandable?

00:17:28.089 --> 00:17:31.180
This is a good place or
a moment to add one more

00:17:31.180 --> 00:17:34.450
line to tell you about.

00:17:34.450 --> 00:17:39.410
But leading into the next slide,
we're-- so if you understand

00:17:39.410 --> 00:17:45.731
the definitions of what
we've done so far, all of--

00:17:45.731 --> 00:17:48.290
this is a fairly
straightforward theorem,

00:17:48.290 --> 00:17:51.670
and the corollary is immediate.

00:17:51.670 --> 00:17:55.590
So anything that you
can do in n squared time

00:17:55.590 --> 00:17:56.980
you can do in n
squared in space.

00:17:56.980 --> 00:17:59.370
And so anything you can
do in polynomial time

00:17:59.370 --> 00:18:02.110
you can also do in
polynomial space.

00:18:02.110 --> 00:18:04.930
Yeah, c-- somebody's
asking me, what is the c?

00:18:04.930 --> 00:18:10.628
c is essentially going to be
the size of the tape alphabet

00:18:10.628 --> 00:18:12.670
because that's going to
govern how many different

00:18:12.670 --> 00:18:13.670
configurations you have.

00:18:13.670 --> 00:18:19.810
There's a slight extra
factor for the tape--

00:18:19.810 --> 00:18:23.740
the head location
and also the state.

00:18:23.740 --> 00:18:28.520
But the main thing is going to
be the number of tape symbols

00:18:28.520 --> 00:18:29.810
and the length of the tape.

00:18:32.360 --> 00:18:34.460
But what's going to
come next is we're

00:18:34.460 --> 00:18:38.960
going to prove something more
powerful than this corollary

00:18:38.960 --> 00:18:41.930
that P is contained in
PSPACE, because not only is P

00:18:41.930 --> 00:18:45.187
contained in PSPACE, but NP
is also contained in PSPACE.

00:18:45.187 --> 00:18:47.270
And for that, we're going
to have to do more work.

00:18:54.730 --> 00:18:57.060
So somebody's asking me
about the number of states.

00:18:57.060 --> 00:19:00.360
The number of states
is going to be--

00:19:00.360 --> 00:19:04.740
is fixed depending
on the machine only.

00:19:04.740 --> 00:19:10.920
So it doesn't depend upon n.

00:19:10.920 --> 00:19:17.430
So it could at most affect
the number of configurations

00:19:17.430 --> 00:19:19.050
by a constant factor.

00:19:19.050 --> 00:19:20.550
And those constant
factors are going

00:19:20.550 --> 00:19:25.750
to be absorbed within the
definitions of these complexity

00:19:25.750 --> 00:19:34.085
classes because that's how
we define them to be ignoring

00:19:34.085 --> 00:19:34.960
the constant factors.

00:19:40.930 --> 00:19:43.450
Why don't we just take a--

00:19:43.450 --> 00:19:46.150
this may be a good place
to pause for a second

00:19:46.150 --> 00:19:53.090
and see if there's any
questions, because I

00:19:53.090 --> 00:19:56.030
think for some of you, this
may be straightforward.

00:19:56.030 --> 00:19:59.630
But I think it's less
common to be measuring--

00:19:59.630 --> 00:20:04.740
thinking about the amount of
memory as a complexity measure.

00:20:04.740 --> 00:20:06.560
So this is perhaps a
little less familiar.

00:20:06.560 --> 00:20:10.610
Some of you have seen measuring
time in other classes,

00:20:10.610 --> 00:20:13.280
but measuring the
amount of space

00:20:13.280 --> 00:20:16.220
that the algorithm uses probably
is a little less familiar.

00:20:16.220 --> 00:20:19.550
And maybe it's worth spending
a moment or two answering

00:20:19.550 --> 00:20:20.480
questions about that.

00:20:28.310 --> 00:20:30.810
So I'm not sure I understand
the question that just came in,

00:20:30.810 --> 00:20:32.800
but I'll read it out there.

00:20:32.800 --> 00:20:35.310
Is it possible that a Turing
machine can loop forever?

00:20:35.310 --> 00:20:36.270
Absolutely.

00:20:36.270 --> 00:20:38.280
But a Turing machine
that loops forever

00:20:38.280 --> 00:20:41.910
does not count as one that
runs within the space bound.

00:20:41.910 --> 00:20:44.400
To run within the space
bound, the machine

00:20:44.400 --> 00:20:45.630
must halt on every input.

00:20:45.630 --> 00:20:46.620
It has to be a decider.

00:20:46.620 --> 00:20:49.080
We're only considering
deciders here.

00:20:49.080 --> 00:20:51.330
So is it possible a Turing
machine could loop forever?

00:20:51.330 --> 00:20:51.900
Yes.

00:20:51.900 --> 00:20:53.483
Isn't the Turing
machine we're talking

00:20:53.483 --> 00:20:55.725
about a member of space,
and thus a decider?

00:20:59.860 --> 00:21:01.960
Not totally sure I
understand the question.

00:21:01.960 --> 00:21:11.710
But if a Turing machine is
not halting on all inputs,

00:21:11.710 --> 00:21:12.820
it's not a decider.

00:21:12.820 --> 00:21:14.724
That's our definition.

00:21:18.182 --> 00:21:18.788
Are we good?

00:21:18.788 --> 00:21:20.580
We're not getting very
many questions here.

00:21:20.580 --> 00:21:22.310
So I'm assuming
you're all with me

00:21:22.310 --> 00:21:28.040
or so lost you don't even know
what to ask, which is not good.

00:21:28.040 --> 00:21:29.450
So be bold.

00:21:29.450 --> 00:21:32.420
If you're confused, throw
a question out there,

00:21:32.420 --> 00:21:34.970
because I don't want to
race through this lecture,

00:21:34.970 --> 00:21:38.810
since it's maybe a little
less familiar to some of you.

00:21:38.810 --> 00:21:41.360
So let's move on.

00:21:41.360 --> 00:21:45.980
As promised, I'm going to show
you now that NP, not only P,

00:21:45.980 --> 00:21:50.270
as happens immediately,
but NP is contained

00:21:50.270 --> 00:21:51.950
as a subset of a PSPACE.

00:21:54.540 --> 00:21:56.760
So that is--

00:21:56.760 --> 00:21:58.200
I did get a question.

00:21:58.200 --> 00:22:01.020
I moved on before I
answered this question.

00:22:01.020 --> 00:22:03.030
Can I explain part two
of the proof again?

00:22:03.030 --> 00:22:03.900
Part two?

00:22:03.900 --> 00:22:05.010
OK, let's just do it.

00:22:08.410 --> 00:22:10.840
If something runs in a
certain amount of space,

00:22:10.840 --> 00:22:13.630
you have to just think about how
many different configurations

00:22:13.630 --> 00:22:16.030
the machine can have within
that amount of space.

00:22:16.030 --> 00:22:21.010
Remember the configurations that
we defined way back at LBAs?

00:22:21.010 --> 00:22:22.930
So the number of
configurations of the machine

00:22:22.930 --> 00:22:27.070
can have depends on how
much space it's allocated.

00:22:27.070 --> 00:22:30.430
Like the LBAs-- they had a
fixed number of configurations,

00:22:30.430 --> 00:22:33.610
and we gave a
calculation for that,

00:22:33.610 --> 00:22:35.650
which is basically
an exponential

00:22:35.650 --> 00:22:36.850
in the amount of space.

00:22:36.850 --> 00:22:39.830
That's how many configurations
the machine can have.

00:22:39.830 --> 00:22:44.860
So if the machine is not
looping, if it's a decider,

00:22:44.860 --> 00:22:46.810
it can never repeat
a configuration.

00:22:46.810 --> 00:22:49.820
And that's going to tell us how
long the machine can possibly

00:22:49.820 --> 00:22:50.320
run for.

00:22:54.264 --> 00:22:55.860
It's important to understand.

00:22:55.860 --> 00:22:57.480
I'm not sure if
I knew how to say

00:22:57.480 --> 00:23:02.640
that in any way that different
from what I said before.

00:23:02.640 --> 00:23:07.420
OK, getting back now to proving
that NP is a subset of PSPACE.

00:23:07.420 --> 00:23:09.960
So now we're going to have
to do something that's

00:23:09.960 --> 00:23:13.740
in a way different from what
we did on the previous slide,

00:23:13.740 --> 00:23:17.970
because now it's not
going to be enough to work

00:23:17.970 --> 00:23:19.320
with the same machine.

00:23:19.320 --> 00:23:21.360
Before when we were
converting, we're

00:23:21.360 --> 00:23:24.270
showing that a certain
amount of time, time class,

00:23:24.270 --> 00:23:25.890
is contained within
a space class

00:23:25.890 --> 00:23:27.750
by virtue of the
very same machine--

00:23:27.750 --> 00:23:30.330
by just showing
that if it's running

00:23:30.330 --> 00:23:32.010
within a certain
amount of time, then it

00:23:32.010 --> 00:23:37.110
has to be running within
that same amount of space.

00:23:37.110 --> 00:23:38.982
Or in terms of the
space, it was in the--

00:23:38.982 --> 00:23:40.440
given a certain
amount of space, it

00:23:40.440 --> 00:23:42.898
has to be running that same
machine within a certain amount

00:23:42.898 --> 00:23:45.230
of time.

00:23:45.230 --> 00:23:47.750
Here we're going to--
mixing non-determinism

00:23:47.750 --> 00:23:48.570
and determinism.

00:23:48.570 --> 00:23:52.160
So we're going to have to take
a machine that's an NP type

00:23:52.160 --> 00:23:55.400
machine, a nondeterministic
polynomial time machine,

00:23:55.400 --> 00:23:57.860
and convert it into a
deterministic machine that

00:23:57.860 --> 00:24:00.700
doesn't use a
whole lot of space.

00:24:00.700 --> 00:24:06.190
So there's a difference in
the character of this theorem

00:24:06.190 --> 00:24:10.370
because we have to
introduce a new machine.

00:24:10.370 --> 00:24:14.865
And the way we're going
to prove that, I'm

00:24:14.865 --> 00:24:16.740
going to take advantage
of some of the things

00:24:16.740 --> 00:24:20.370
we've already shown
to prove this.

00:24:20.370 --> 00:24:23.130
One could also prove it a
little bit more directly.

00:24:23.130 --> 00:24:26.650
And maybe it's worth making
sure you understand both proofs.

00:24:26.650 --> 00:24:30.180
So the first thing
I'm going to observe

00:24:30.180 --> 00:24:35.070
is that SAT, our
NP-complete language,

00:24:35.070 --> 00:24:39.210
the satisfiability language,
itself is a member of PSPACE.

00:24:42.470 --> 00:24:48.650
And the reason for that is
when you're given a formula,

00:24:48.650 --> 00:24:56.170
and now you want to test if
that formula is satisfiable,

00:24:56.170 --> 00:24:59.710
one way to do it, the
most obvious way to do it,

00:24:59.710 --> 00:25:06.280
is try all assignments one
by one and see if any of them

00:25:06.280 --> 00:25:07.375
satisfy the formula.

00:25:09.880 --> 00:25:12.100
Now that's going to
take a lot of time.

00:25:12.100 --> 00:25:14.770
But how much space does it use?

00:25:14.770 --> 00:25:18.910
I have in mind reusing
the space every time

00:25:18.910 --> 00:25:21.490
we try the next assignment.

00:25:21.490 --> 00:25:24.070
Think of going through all
of the assignments the way

00:25:24.070 --> 00:25:26.230
an odometer would work--

00:25:26.230 --> 00:25:29.050
just trying every
possible assignment,

00:25:29.050 --> 00:25:30.880
but reusing the
space where you're

00:25:30.880 --> 00:25:35.220
going to write that
assignment down,

00:25:35.220 --> 00:25:41.040
incrementing it like a number
written in binary, if you wish.

00:25:41.040 --> 00:25:43.290
Going through all the possible
assignments, every time

00:25:43.290 --> 00:25:46.380
you get in the next assignment,
you plug it into the formula

00:25:46.380 --> 00:25:48.080
and see if the
formula's satisfied.

00:25:48.080 --> 00:25:49.830
If it is, then you can
accept immediately.

00:25:49.830 --> 00:25:51.990
If not, you go on to
the next assignment.

00:25:51.990 --> 00:25:54.450
And only when you've gone
through all the assignments

00:25:54.450 --> 00:25:58.270
in that way, and none of them
have satisfied the formula,

00:25:58.270 --> 00:25:59.200
then you can reject.

00:25:59.200 --> 00:26:01.218
So how much space does that use?

00:26:01.218 --> 00:26:02.760
That doesn't use a
whole lot of space

00:26:02.760 --> 00:26:06.780
because you're reusing
the space to write down

00:26:06.780 --> 00:26:10.470
one assignment after the next.

00:26:10.470 --> 00:26:13.380
It's only going to be using
an amount of space which

00:26:13.380 --> 00:26:15.930
is big enough to hold an
assignment, which is basically

00:26:15.930 --> 00:26:18.570
linear, because it's the size
of the number of variables

00:26:18.570 --> 00:26:19.450
of the formula.

00:26:19.450 --> 00:26:24.150
So that's going to be a linear
amount of space to solve

00:26:24.150 --> 00:26:25.750
the satisfiability problem.

00:26:25.750 --> 00:26:27.240
And so the
satisfiability problem

00:26:27.240 --> 00:26:31.680
is certainly in PSPACE--

00:26:31.680 --> 00:26:34.310
step one.

00:26:34.310 --> 00:26:38.230
Step two is we're going
to take advantage of what

00:26:38.230 --> 00:26:40.870
we know about reducibility.

00:26:40.870 --> 00:26:45.610
So if A is polynomial
time reducible to B,

00:26:45.610 --> 00:26:47.930
we've already commented--
we didn't say this exactly

00:26:47.930 --> 00:26:48.430
in this way.

00:26:48.430 --> 00:26:51.670
But it's still going to
follow that anything you

00:26:51.670 --> 00:26:53.380
can do in a certain
amount of time,

00:26:53.380 --> 00:26:55.420
you can also do in
that amount of space,

00:26:55.420 --> 00:26:59.275
because it's the
very same machine--

00:26:59.275 --> 00:27:01.610
can't use any more space
than the amount of time

00:27:01.610 --> 00:27:04.530
it was allocated.

00:27:04.530 --> 00:27:07.410
So if A is polynomial
time reducible to B,

00:27:07.410 --> 00:27:10.230
it's also going to be
reducible in polynomial space.

00:27:10.230 --> 00:27:16.030
A polynomial space machine
could do the reduction.

00:27:16.030 --> 00:27:19.860
So that means if A is
polynomial time reducible to B,

00:27:19.860 --> 00:27:21.750
and B is in
polynomial space, then

00:27:21.750 --> 00:27:25.680
A is also in polynomial space.

00:27:25.680 --> 00:27:29.760
But we know, because
satisfiability is NP-complete,

00:27:29.760 --> 00:27:34.070
that every language of
NP is reducible to SAT.

00:27:34.070 --> 00:27:37.200
So put SAT in place
of B. Every NP

00:27:37.200 --> 00:27:40.500
language is polynomial
time-reducible to SAT.

00:27:40.500 --> 00:27:43.380
And we now know that
SAT is in PSPACE.

00:27:43.380 --> 00:27:46.140
So therefore, every
language in NP

00:27:46.140 --> 00:27:48.480
is in PSPACE because
they're all polynomial time

00:27:48.480 --> 00:27:49.350
reducible to SAT.

00:27:52.640 --> 00:27:55.850
So just by using some
of the technology

00:27:55.850 --> 00:27:59.600
we've developed, namely
the notion of completeness

00:27:59.600 --> 00:28:04.160
shows some of its power, that if
you want to conclude something

00:28:04.160 --> 00:28:08.030
about an entire class, an
entire complexity class,

00:28:08.030 --> 00:28:10.580
if you have a complete problem
for that complexity class,

00:28:10.580 --> 00:28:13.730
often it's enough just to work
with the complete problem.

00:28:13.730 --> 00:28:16.940
And then everything else by
virtue of the reducibility,

00:28:16.940 --> 00:28:19.700
is going to inherit
the same property.

00:28:19.700 --> 00:28:21.980
Doesn't work in all cases,
but in many of the cases,

00:28:21.980 --> 00:28:26.060
as long as the reducibility
can be computed

00:28:26.060 --> 00:28:31.950
by the type of procedure
you're working with,

00:28:31.950 --> 00:28:35.340
then you can-- then it follows.

00:28:35.340 --> 00:28:37.200
You could also prove
this more directly.

00:28:37.200 --> 00:28:38.910
I think it's in some
ways a little clumsy

00:28:38.910 --> 00:28:41.970
or a little bit less elegant.

00:28:41.970 --> 00:28:46.740
But you can say, well,
let me just take my--

00:28:46.740 --> 00:28:48.840
take a language that's in NP.

00:28:48.840 --> 00:28:52.500
It has a nondeterministic
polynomial time algorithm.

00:28:52.500 --> 00:28:56.940
And then give a deterministic
polynomial space algorithm--

00:28:56.940 --> 00:29:00.750
simulates that NP algorithm
just by going through all

00:29:00.750 --> 00:29:02.880
the different branches,
but making sure

00:29:02.880 --> 00:29:05.100
that going through all
those different branches,

00:29:05.100 --> 00:29:07.753
you're reusing the space and
not using new space every time

00:29:07.753 --> 00:29:09.420
you're going through
a different branch.

00:29:09.420 --> 00:29:12.240
And you can arrange things
if you're just a little bit

00:29:12.240 --> 00:29:13.710
careful to do it that way.

00:29:13.710 --> 00:29:15.870
So you could give
a direct simulation

00:29:15.870 --> 00:29:19.810
in polynomial space of
any NP Turing machine.

00:29:19.810 --> 00:29:22.040
So I mean, that's also
completely satisfactory.

00:29:22.040 --> 00:29:23.790
But I think this is a
little more elegant.

00:29:26.960 --> 00:29:29.630
This furthermore
is going to allow

00:29:29.630 --> 00:29:35.700
us to conclude some additional
languages are in PSPACE.

00:29:35.700 --> 00:29:38.820
Let's define a class we have not
yet seen, though maybe you've

00:29:38.820 --> 00:29:39.690
seen this--

00:29:39.690 --> 00:29:45.810
I think we've talked about
this notion of co before.

00:29:45.810 --> 00:29:50.110
I think we talked about
co-Turing-recognizable.

00:29:55.110 --> 00:29:57.930
Those are the class of
languages whose complements

00:29:57.930 --> 00:30:01.290
are Turing-recognizable,
and the same for co and P.

00:30:01.290 --> 00:30:04.890
This is the class of languages
whose complements are in NP.

00:30:08.280 --> 00:30:10.920
If you take the complement of
every language that's in NP,

00:30:10.920 --> 00:30:12.420
and now you got
all the languages

00:30:12.420 --> 00:30:14.580
that are in this class coNP.

00:30:14.580 --> 00:30:16.065
It's complement of NP.

00:30:18.990 --> 00:30:22.450
So for example, the complement
of the HAMPATH problem.

00:30:22.450 --> 00:30:27.600
So all the graphs which don't
have Hamiltonian paths from

00:30:27.600 --> 00:30:33.630
SAT, so the
non-Hamiltonian graph--

00:30:33.630 --> 00:30:36.300
the non-Hamiltonian
path problem--

00:30:36.300 --> 00:30:39.450
that's a coNP problem.

00:30:39.450 --> 00:30:41.190
Or here's a language
we haven't--

00:30:41.190 --> 00:30:45.480
I'm not going to define as
in terms of its complement--

00:30:45.480 --> 00:30:46.920
the tautology problem.

00:30:52.920 --> 00:30:55.920
These are the formulas
where all assignments

00:30:55.920 --> 00:30:57.450
satisfy the formula.

00:30:57.450 --> 00:31:01.750
All assignments make
the formula true.

00:31:01.750 --> 00:31:08.260
So a tautology is a
statement that's always true,

00:31:08.260 --> 00:31:09.940
no matter how you
plug in the variables.

00:31:12.510 --> 00:31:17.930
So the tautology
language is in coNP

00:31:17.930 --> 00:31:20.990
because its complement, which
is the non-tautologies-- those

00:31:20.990 --> 00:31:25.820
are the formulas for which
there's some assignment which

00:31:25.820 --> 00:31:26.960
makes it false.

00:31:26.960 --> 00:31:29.270
So that's going to be
clearly an NP language.

00:31:29.270 --> 00:31:32.720
So tautology is a coNP language.

00:31:37.810 --> 00:31:40.450
Now one thing that
we get immediately

00:31:40.450 --> 00:31:42.640
from the theorem
as a corollary--

00:31:42.640 --> 00:31:44.350
really should write
this as a corollary--

00:31:44.350 --> 00:31:51.100
is that coNP is also a subset of
PSPACE And the reason for that

00:31:51.100 --> 00:31:51.730
is--

00:31:51.730 --> 00:31:54.160
and this is something that--

00:31:54.160 --> 00:31:58.150
it's, again, easy,
but make sure you

00:31:58.150 --> 00:32:02.110
understand it-- is
that PSPACE itself

00:32:02.110 --> 00:32:07.310
is closed under complement
because it is defined in terms

00:32:07.310 --> 00:32:08.990
of deterministic machines.

00:32:08.990 --> 00:32:12.910
And deterministic machines--
you can always flip the answer

00:32:12.910 --> 00:32:20.260
and get a machine of the
same type which will decide

00:32:20.260 --> 00:32:23.420
the complementary language.

00:32:23.420 --> 00:32:25.930
So for deterministic machines--

00:32:25.930 --> 00:32:28.990
deterministic deciders,
I should say--

00:32:28.990 --> 00:32:32.500
you can always flip the answer.

00:32:32.500 --> 00:32:39.020
Now, so here, we have
anything that's in PSPACE.

00:32:39.020 --> 00:32:42.380
It has a deterministic
polynomial time--

00:32:42.380 --> 00:32:44.600
polynomial space-- machine.

00:32:44.600 --> 00:32:46.280
And so its
complementary language

00:32:46.280 --> 00:32:47.540
is also going to be in PSPACE.

00:32:47.540 --> 00:32:51.000
So PSPACE and
coPSPACE are equal.

00:32:51.000 --> 00:32:56.530
And so that's why coNP is
going to be in PSPACE--

00:32:56.530 --> 00:32:59.820
going to be a subset of PSPACE.

00:32:59.820 --> 00:33:03.430
I hope that's not
getting mixed up

00:33:03.430 --> 00:33:06.700
by all of the different
alphabet soup here.

00:33:06.700 --> 00:33:10.360
But here is maybe
a picture maybe

00:33:10.360 --> 00:33:13.690
that'll be helpful of
how the world looks

00:33:13.690 --> 00:33:19.930
for the time and space
complexity classes so far.

00:33:19.930 --> 00:33:23.830
So we have P is a subset of NP.

00:33:23.830 --> 00:33:29.700
It's also a subset of coNP,
again, for the same reason

00:33:29.700 --> 00:33:31.740
that P and coP are equal.

00:33:31.740 --> 00:33:38.970
We never even really talk about
coP because it's the same as P.

00:33:38.970 --> 00:33:40.740
But NP and coNP--

00:33:40.740 --> 00:33:42.240
those are two classes
where we don't

00:33:42.240 --> 00:33:49.230
know whether they're equal or
not, because an NP machine--

00:33:49.230 --> 00:33:54.120
you can't necessarily complement
the behavior of an NP machine

00:33:54.120 --> 00:33:56.160
and end up with an NP machine.

00:33:56.160 --> 00:33:58.470
So a question here--
how do we know

00:33:58.470 --> 00:34:01.680
that coNP is a complete
class of problems?

00:34:01.680 --> 00:34:04.200
I didn't say that there's
anything about completeness.

00:34:04.200 --> 00:34:06.900
And coNP is just a
collection of languages.

00:34:06.900 --> 00:34:08.590
I'm not saying it's any--

00:34:08.590 --> 00:34:10.750
any particular feature about it.

00:34:10.750 --> 00:34:12.989
In fact, it does have
a complete problem,

00:34:12.989 --> 00:34:16.199
just like NP has a
complete problem.

00:34:16.199 --> 00:34:18.480
The complements--
and I'm not going

00:34:18.480 --> 00:34:21.480
to prove this right here, though
it's pretty straightforward.

00:34:21.480 --> 00:34:23.639
Complements of all the
NP-complete languages

00:34:23.639 --> 00:34:25.710
are going to be
coNP-complete languages.

00:34:36.471 --> 00:34:37.929
I will answer some
of the questions

00:34:37.929 --> 00:34:42.190
about possible alternate worlds.

00:34:42.190 --> 00:34:44.350
This is how we believe
the world looks like,

00:34:44.350 --> 00:34:47.500
with each one of these regions
being separated from one

00:34:47.500 --> 00:34:50.920
another, including this little
corner of the world here,

00:34:50.920 --> 00:34:55.053
NP, and intersect
coNP, which is not--

00:34:55.053 --> 00:34:57.220
there might be languages
in here which are not in P.

00:34:57.220 --> 00:34:59.380
And we actually believe
there are such languages.

00:34:59.380 --> 00:35:02.560
But again, all of
this is conjectural.

00:35:02.560 --> 00:35:06.070
And even whether P and PSPACE
are the same or different

00:35:06.070 --> 00:35:08.217
is an open question.

00:35:08.217 --> 00:35:09.800
We don't even know
the answer to that,

00:35:09.800 --> 00:35:12.370
which is perhaps even
more shocking that we

00:35:12.370 --> 00:35:15.060
don't know how to solve P and--

00:35:15.060 --> 00:35:17.140
prove P different
from NP, that we

00:35:17.140 --> 00:35:19.480
don't know how to prove P
different from PSPACE, which

00:35:19.480 --> 00:35:21.700
seems to be a much bigger class.

00:35:21.700 --> 00:35:23.200
It would be incredible
that anything

00:35:23.200 --> 00:35:26.260
you can do with a
polynomial amount of space

00:35:26.260 --> 00:35:29.020
you can also do with a
polynomial amount of time.

00:35:29.020 --> 00:35:31.900
But don't know
how to prove that.

00:35:31.900 --> 00:35:32.680
They're different.

00:35:32.680 --> 00:35:35.770
And in fact, so this is
how the world could look.

00:35:39.150 --> 00:35:40.540
Everything could collapse down.

00:35:40.540 --> 00:35:42.270
P could equal PSPACE.

00:35:42.270 --> 00:35:46.095
And then all of these
classes would be the same.

00:35:46.095 --> 00:35:47.220
And I should also mention--

00:35:47.220 --> 00:35:49.080
I don't have this
as another diagram

00:35:49.080 --> 00:35:52.530
here, but just to answer--

00:35:52.530 --> 00:35:53.730
there's other possibilities.

00:35:53.730 --> 00:36:00.623
For example, P could equal NP
without being equal to PSPACE.

00:36:00.623 --> 00:36:02.790
And then you'd have a
different-looking Venn diagram

00:36:02.790 --> 00:36:04.920
here, where there'd
be just two classes.

00:36:04.920 --> 00:36:08.010
P, NP and coNP would
all be the same.

00:36:08.010 --> 00:36:09.360
PSPACE would be different.

00:36:09.360 --> 00:36:11.168
That's possible.

00:36:11.168 --> 00:36:12.210
At least we have no idea.

00:36:14.820 --> 00:36:20.340
A lot of these things can
collapse in various ways.

00:36:20.340 --> 00:36:22.980
And you just have
to make sure that--

00:36:22.980 --> 00:36:26.040
there are some collapses
that obviously could not

00:36:26.040 --> 00:36:27.630
occur, like P--

00:36:27.630 --> 00:36:31.770
if P equals NP, it's
also going to equal coNP.

00:36:31.770 --> 00:36:32.730
So you can't get--

00:36:32.730 --> 00:36:34.960
there are obviously
some crazy collapses

00:36:34.960 --> 00:36:36.990
which could not happen--

00:36:36.990 --> 00:36:39.300
that P collapsing-- P
and NP being the same,

00:36:39.300 --> 00:36:40.410
but different from coNP.

00:36:40.410 --> 00:36:41.700
That can't happen.

00:36:41.700 --> 00:36:49.070
But avoiding some obvious
contradictory situations,

00:36:49.070 --> 00:36:51.420
everything else is possible.

00:36:51.420 --> 00:36:53.570
So somebody said--
so here's a question.

00:36:53.570 --> 00:36:55.310
Let me just answer
a few of these.

00:36:55.310 --> 00:36:57.890
Did we use the
completeness of coNP

00:36:57.890 --> 00:37:02.960
to show that coNP is
a subset of coPSPACE?

00:37:02.960 --> 00:37:06.540
No, we didn't do it that way.

00:37:06.540 --> 00:37:08.780
We showed that coNP--

00:37:15.573 --> 00:37:16.240
well, let's see.

00:37:16.240 --> 00:37:16.810
Did we?

00:37:16.810 --> 00:37:17.650
Is that fair?

00:37:21.540 --> 00:37:24.000
Well, I suppose.

00:37:24.000 --> 00:37:27.000
NP of subset of
PSPACE immediately

00:37:27.000 --> 00:37:29.370
implies, because you're
complementing both sides,

00:37:29.370 --> 00:37:33.090
that coNP is a
subset of coPSPACE.

00:37:33.090 --> 00:37:36.090
So you don't have to deal
with the complete problems

00:37:36.090 --> 00:37:37.410
on the other side.

00:37:37.410 --> 00:37:39.870
That's too complicated
to get into here.

00:37:39.870 --> 00:37:44.010
You don't need to talk about
coNP-complete problems.

00:37:44.010 --> 00:37:46.680
Though, again, those
are very simple to get

00:37:46.680 --> 00:37:49.740
from NP-complete problems.

00:37:49.740 --> 00:37:53.100
Let's see what else is here.

00:37:53.100 --> 00:37:57.340
Are there NP-complete
problems that are in coNP?

00:37:57.340 --> 00:38:00.880
So the answer to that is, no,
not as far as-- well, I mean,

00:38:00.880 --> 00:38:04.900
there would be-- if there was
an NP-complete problem in coNP,

00:38:04.900 --> 00:38:09.330
then all of NP would be in
coNP, and they would be equal.

00:38:09.330 --> 00:38:12.565
So we suspect the NP-complete
problems are not in coNP,

00:38:12.565 --> 00:38:13.940
but don't know
how to prove that.

00:38:17.030 --> 00:38:20.780
So why is tautology in coNP?

00:38:20.780 --> 00:38:23.420
So here is-- tautology
sits in this class, here.

00:38:23.420 --> 00:38:25.610
The reason is that its
complementary language

00:38:25.610 --> 00:38:26.360
is in NP.

00:38:26.360 --> 00:38:30.200
The complement of
tautology are the languages

00:38:30.200 --> 00:38:35.750
where there is some assignment
which makes the formula false.

00:38:35.750 --> 00:38:39.230
So with an NP machine, you
can just guess that assignment

00:38:39.230 --> 00:38:41.960
and check that it makes
the formula false.

00:38:41.960 --> 00:38:45.770
So the complement of
tautology is an NP language.

00:38:45.770 --> 00:38:47.840
And so tautology
is a coNP language.

00:38:54.920 --> 00:38:57.830
So somebody's asking
about PSPACE and NPSPACE.

00:38:57.830 --> 00:38:59.550
And how do those
relate to one another?

00:38:59.550 --> 00:39:02.570
So that's looking
ahead to what we're

00:39:02.570 --> 00:39:05.750
going to be doing next week,
but I'll give you a preview.

00:39:09.150 --> 00:39:11.400
An old, but at the
time surprising,

00:39:11.400 --> 00:39:17.440
theorem was that PSPACE and
NPSPACE actually are equal.

00:39:17.440 --> 00:39:19.950
So they had this analogy
where time breaks down.

00:39:19.950 --> 00:39:22.800
So polynomial space and
non-deterministic polynomial

00:39:22.800 --> 00:39:26.040
space do turn out to be equal.

00:39:26.040 --> 00:39:28.260
The most obvious
way of proving--

00:39:28.260 --> 00:39:32.460
of trying to simulate
an an NPSPACE machine

00:39:32.460 --> 00:39:36.790
would be give you an exponential
deterministic space algorithm.

00:39:36.790 --> 00:39:38.130
So we'll go through that.

00:39:38.130 --> 00:39:41.670
But there is an
algorithm which collapses

00:39:41.670 --> 00:39:43.500
non-deterministic
polynomial space down

00:39:43.500 --> 00:39:45.990
to deterministic polynomial
space, which, again,

00:39:45.990 --> 00:39:47.760
at the time was
kind of surprising.

00:39:51.960 --> 00:39:53.100
Last question I'll take--

00:39:53.100 --> 00:39:55.140
is there some equivalent
concept to the idea

00:39:55.140 --> 00:39:57.870
of a certificate for coNP?

00:39:57.870 --> 00:39:59.910
Yes, there is a notion
of a certificate.

00:39:59.910 --> 00:40:02.760
But now it's going to be a
certificate that you're not

00:40:02.760 --> 00:40:05.040
in the language instead
of a certificate

00:40:05.040 --> 00:40:08.110
that you're in the
language, and then, again,

00:40:08.110 --> 00:40:10.630
work for the very same reason
that we have certificates

00:40:10.630 --> 00:40:13.930
for NP languages, where you
had certificate for membership.

00:40:13.930 --> 00:40:16.900
For coNP, you have certificate
for non-membership.

00:40:16.900 --> 00:40:21.070
There's no other certificate
for membership in coNP.

00:40:21.070 --> 00:40:21.940
So let's move on.

00:40:25.895 --> 00:40:27.270
So now we're going
to introduce--

00:40:27.270 --> 00:40:29.320
we're going to look at
some important examples.

00:40:29.320 --> 00:40:31.580
These are examples
that we're going to--

00:40:31.580 --> 00:40:33.330
I'm going to give you
two examples, first,

00:40:33.330 --> 00:40:34.860
one called TQBF.

00:40:34.860 --> 00:40:37.530
And then we're going to
have a second example.

00:40:37.530 --> 00:40:40.320
Both of those we're going to--

00:40:40.320 --> 00:40:43.857
one of them is going to be an
example of a problem in PSPACE.

00:40:43.857 --> 00:40:45.690
Then the other one is
going to be an example

00:40:45.690 --> 00:40:48.030
of a problem in NPSPACE.

00:40:48.030 --> 00:40:51.010
And these are going to be
important languages for us.

00:40:51.010 --> 00:40:54.150
So they're not just going to
serve as examples for today,

00:40:54.150 --> 00:40:59.140
but they're going to be useful
languages for us later on.

00:40:59.140 --> 00:41:04.170
So just keep that in mind
as we're going through it.

00:41:04.170 --> 00:41:08.870
So to understand TQBF,
you have to understand

00:41:08.870 --> 00:41:13.175
what are called quantified
Boolean formulas or QBFs.

00:41:15.850 --> 00:41:18.350
So those are Boolean formulas,
just like the ones we've been

00:41:18.350 --> 00:41:20.030
seeing-- we've been
talking about--

00:41:20.030 --> 00:41:25.460
with Boolean variables and the
ands/ors and negated variables.

00:41:25.460 --> 00:41:28.025
But now you're going
to add qualifiers,

00:41:28.025 --> 00:41:32.550
the "exists" quantifiers
and "for all" quantifiers.

00:41:32.550 --> 00:41:34.710
If you haven't seen
quantifiers, you

00:41:34.710 --> 00:41:38.340
need to go back
and review those.

00:41:38.340 --> 00:41:40.980
I think that we already
introduced-- talked about them

00:41:40.980 --> 00:41:43.350
briefly earlier in the term.

00:41:43.350 --> 00:41:47.070
But this is part of the basic
math that you need to know.

00:41:49.590 --> 00:41:51.870
Maybe you'll-- not
comfortable with them,

00:41:51.870 --> 00:41:55.380
you'll pick it up
somewhat during the course

00:41:55.380 --> 00:41:59.460
of today's and the next
few lectures, but anyway.

00:41:59.460 --> 00:42:02.513
So if you have a
Boolean formula--

00:42:02.513 --> 00:42:03.930
I'll give you some
examples-- that

00:42:03.930 --> 00:42:06.570
has "exists" and "for
all" quantifiers,

00:42:06.570 --> 00:42:08.970
the requirement
for it to be a QBF

00:42:08.970 --> 00:42:10.530
is that all of
the variables have

00:42:10.530 --> 00:42:14.100
to be within the scope of
one of the quantifiers.

00:42:14.100 --> 00:42:17.370
So all of the variables
of the formula

00:42:17.370 --> 00:42:20.070
have to be quantified by
one of the quantifiers.

00:42:20.070 --> 00:42:23.310
And we're going to assume the
quantifiers are in front--

00:42:23.310 --> 00:42:29.490
are leading quantifiers in front
of the rest of the expression.

00:42:32.510 --> 00:42:37.510
So because all of the
variables have been quantified,

00:42:37.510 --> 00:42:39.610
then a quantified
Boolean formula

00:42:39.610 --> 00:42:42.970
is going to be either
true or false following

00:42:42.970 --> 00:42:46.830
the meaning of the quantifiers.

00:42:46.830 --> 00:42:48.580
And again, some of
this may become clearer

00:42:48.580 --> 00:42:49.585
as we do some examples.

00:42:53.950 --> 00:42:56.210
So here are some
examples coming.

00:42:56.210 --> 00:42:57.820
So here is one--

00:42:57.820 --> 00:42:59.380
here is a QBF.

00:42:59.380 --> 00:43:02.320
So all of the variables,
which are just x and y--

00:43:02.320 --> 00:43:05.530
they both appear in front of--

00:43:05.530 --> 00:43:06.610
next to some quantifier.

00:43:06.610 --> 00:43:14.030
So that's going to be-- that's
a requirement if we have a QBF.

00:43:14.030 --> 00:43:18.560
And so this says, for
all x, there exists a y.

00:43:18.560 --> 00:43:23.120
This expression holds.

00:43:23.120 --> 00:43:26.500
So we need to unpack that
and understand what it means.

00:43:26.500 --> 00:43:28.540
It says, for every x--

00:43:28.540 --> 00:43:32.950
for every way of
assigning a Boolean value

00:43:32.950 --> 00:43:36.460
to x, so x is going to
be either true or false,

00:43:36.460 --> 00:43:39.970
there exists a way of
assigning a Boolean value for y

00:43:39.970 --> 00:43:41.810
to make this true--

00:43:41.810 --> 00:43:47.270
to make the rest of the
expression hold true.

00:43:47.270 --> 00:43:48.980
And we'll go through that.

00:43:48.980 --> 00:43:54.650
But let's contrast that with
the second example, where

00:43:54.650 --> 00:43:57.680
I invert the order
of the quantifiers,

00:43:57.680 --> 00:44:01.740
because that's going to be
important for the meaning

00:44:01.740 --> 00:44:04.580
of the formula.

00:44:04.580 --> 00:44:06.220
So if I say for
every x, there is

00:44:06.220 --> 00:44:11.090
a y, which makes the rest
of it true, that says,

00:44:11.090 --> 00:44:13.540
well, no matter how
I set x, there's

00:44:13.540 --> 00:44:15.950
going to be way to set
y to make this true.

00:44:15.950 --> 00:44:19.190
So that says, well, if I
set x to true, [AUDIO OUT]

00:44:19.190 --> 00:44:23.900
got to be some way to set y to
make the remaining expression

00:44:23.900 --> 00:44:25.410
hold.

00:44:25.410 --> 00:44:30.420
So if I set x to true,
what should I set y to be?

00:44:30.420 --> 00:44:36.990
Well, if I set x to be true,
maybe I could set y to be true.

00:44:36.990 --> 00:44:40.430
Well, then this
clause is satisfied,

00:44:40.430 --> 00:44:42.330
but this clause
won't be satisfied.

00:44:42.330 --> 00:44:45.560
So setting y to be true
is not-- it won't work.

00:44:45.560 --> 00:44:49.800
But for every x, I only need
to show there exists some y.

00:44:49.800 --> 00:44:55.260
So if I take x to be true,
I can set y to be false.

00:44:55.260 --> 00:44:57.330
And now this one
is-- this one holds,

00:44:57.330 --> 00:44:59.412
and this one holds,
and the formula holds.

00:44:59.412 --> 00:45:00.870
But I have to make
sure that that's

00:45:00.870 --> 00:45:03.630
going to be the case
for both settings of x

00:45:03.630 --> 00:45:05.700
because I'm saying for all x.

00:45:05.700 --> 00:45:08.372
So if I set x now to
false, because I already

00:45:08.372 --> 00:45:10.080
showed that it works
for x equal to true,

00:45:10.080 --> 00:45:15.070
if I set x equal to false,
if I set now y to be true,

00:45:15.070 --> 00:45:16.760
this is going to hold.

00:45:16.760 --> 00:45:21.890
So this expression
is true, because it

00:45:21.890 --> 00:45:23.960
is the case that for
every way to set x,

00:45:23.960 --> 00:45:25.730
there is a way to set y.

00:45:25.730 --> 00:45:27.620
So this part holds.

00:45:27.620 --> 00:45:30.200
Let's compare that
with this case.

00:45:30.200 --> 00:45:36.790
Is there some way to set y such
that no matter how I set x,

00:45:36.790 --> 00:45:39.197
this is going to hold?

00:45:39.197 --> 00:45:40.530
And that's not going to be true.

00:45:40.530 --> 00:45:44.120
No matter what you
pick for y, there

00:45:44.120 --> 00:45:47.800
is going to be some way to
set x to make this false.

00:45:47.800 --> 00:45:51.210
So does there exist a y such
that every x makes this true?

00:45:51.210 --> 00:45:52.320
No.

00:45:52.320 --> 00:45:55.380
If you try x equal to true,
it's not going to work.

00:45:55.380 --> 00:45:58.150
If you try x equal to false,
it's not going to work.

00:45:58.150 --> 00:46:03.835
So this second phi 2
expression-- quantified QBF--

00:46:03.835 --> 00:46:04.335
is false.

00:46:07.110 --> 00:46:09.640
We're going to be
playing with these a lot.

00:46:09.640 --> 00:46:15.870
So it's important to understand
how this quantification works.

00:46:15.870 --> 00:46:21.870
So TQBF is the problem
of testing whether one

00:46:21.870 --> 00:46:24.180
of these QBFs is true.

00:46:24.180 --> 00:46:30.630
Or phrased as a language, it's
the collection of true QBFs.

00:46:30.630 --> 00:46:36.105
And that's where we
get the acronym TQBF--

00:46:36.105 --> 00:46:40.332
not acronym, the abbreviation
TQBF for the True Quantified

00:46:40.332 --> 00:46:41.040
Boolean Formulas.

00:46:45.830 --> 00:46:48.790
So going back to
that example, phi 1

00:46:48.790 --> 00:46:50.530
is a true quantified
Boolean formula,

00:46:50.530 --> 00:46:53.930
and phi 2 is not a true
quantified Boolean formula.

00:46:53.930 --> 00:46:56.087
So that's why phi 1
is in the language.

00:46:56.087 --> 00:46:57.295
Phi 2 is not in the language.

00:47:00.450 --> 00:47:03.420
Now our computational
problem is to test

00:47:03.420 --> 00:47:08.660
whether quantified Boolean
formulas are true or not.

00:47:08.660 --> 00:47:11.370
And then we can do it
in polynomial space.

00:47:11.370 --> 00:47:12.600
Oh, there's a Check-in first.

00:47:16.200 --> 00:47:21.850
I claim that SAT is a
special case of TQBF.

00:47:21.850 --> 00:47:23.430
Why is that?

00:47:23.430 --> 00:47:28.350
How can we think of
SAT as a special case?

00:47:28.350 --> 00:47:31.500
If I give you a SAT
formula, how can I

00:47:31.500 --> 00:47:34.560
see that as also a TQBF problem?

00:47:34.560 --> 00:47:37.788
If you want to test if
that formula is true,

00:47:37.788 --> 00:47:38.580
what would you say?

00:47:38.580 --> 00:47:42.270
Remove all the quantifiers
or add some quantifiers?

00:47:42.270 --> 00:47:44.820
And what kind of
quantifiers, maybe?

00:47:47.890 --> 00:47:52.890
How is SAT, just testing
a formula is satisfiable,

00:47:52.890 --> 00:47:54.720
a special case of this--

00:47:54.720 --> 00:47:56.520
what I claim is a
more general problem

00:47:56.520 --> 00:47:59.385
of solving these TQBF problems?

00:48:02.720 --> 00:48:05.355
Closing down.

00:48:05.355 --> 00:48:05.855
Last call.

00:48:11.250 --> 00:48:12.600
Yes, indeed.

00:48:12.600 --> 00:48:17.040
Satisfiability--
so C is correct.

00:48:17.040 --> 00:48:19.260
When you're talking about
a satisfiability problem,

00:48:19.260 --> 00:48:22.440
you're saying, is there
a satisfying assignment?

00:48:22.440 --> 00:48:28.800
Another way of writing that down
is take that Boolean formula

00:48:28.800 --> 00:48:32.160
and put "exists" in front
of all the variables.

00:48:35.430 --> 00:48:39.390
Does there exist a way to
set x1 and x2 and x3 and x4

00:48:39.390 --> 00:48:43.740
to make the formula true--
to make that formula hold?

00:48:43.740 --> 00:48:49.770
So SAT is a special case
by aiding exist qualifiers

00:48:49.770 --> 00:48:52.430
of a TQBF problem.

00:48:52.430 --> 00:48:53.140
So C is correct.

00:48:57.620 --> 00:49:02.290
So why is this problem
in PSPACE, as I claimed?

00:49:02.290 --> 00:49:05.830
And for that, we're going
to give a simple recursive

00:49:05.830 --> 00:49:08.212
algorithm.

00:49:08.212 --> 00:49:11.575
In any quantified
Boolean formula--

00:49:11.575 --> 00:49:13.450
now, if you want to test
if it's true or not,

00:49:13.450 --> 00:49:20.140
we're going to basically strip
off the leading quantifiers.

00:49:20.140 --> 00:49:22.120
So if it's an exist
quantifier, we'll

00:49:22.120 --> 00:49:25.630
remove it and plug
in true and false

00:49:25.630 --> 00:49:32.080
associated to its variable,
and then solve those problems

00:49:32.080 --> 00:49:32.860
recursively.

00:49:35.980 --> 00:49:40.630
So this is just going to be a
recursive procedure for solving

00:49:40.630 --> 00:49:44.390
TQBF problems, operating
by stripping off

00:49:44.390 --> 00:49:47.682
the quantifiers in
front and getting

00:49:47.682 --> 00:49:48.890
smaller and smaller formulas.

00:49:48.890 --> 00:49:50.307
But now we're going
to be plugging

00:49:50.307 --> 00:49:53.690
in values, true
and false, instead

00:49:53.690 --> 00:50:01.070
of relying on the
quantifier to give us

00:50:01.070 --> 00:50:02.195
the meaning of the formula.

00:50:04.920 --> 00:50:07.110
So first of all, if
there are no quantifiers,

00:50:07.110 --> 00:50:09.960
then there are no variables,
because all variables have to--

00:50:09.960 --> 00:50:11.370
bound within quantifiers.

00:50:11.370 --> 00:50:15.060
And in that case, that
quantified Boolean formula

00:50:15.060 --> 00:50:18.750
has to simply be the statement
true or the statement false.

00:50:18.750 --> 00:50:20.520
And so you're going
to output accordingly

00:50:20.520 --> 00:50:24.560
because that's all it can
be if you have no variables.

00:50:24.560 --> 00:50:29.310
If the formula starts
with an exists quantifier,

00:50:29.310 --> 00:50:31.000
what you're going to do--

00:50:31.000 --> 00:50:34.080
so here, psi is the
remainder of the formula

00:50:34.080 --> 00:50:37.140
after you strip off
that exist quantifier.

00:50:37.140 --> 00:50:39.720
So you're going to
evaluate psi now, but take

00:50:39.720 --> 00:50:42.510
that variable that was
bound by the exists

00:50:42.510 --> 00:50:48.340
and just plug in true
and false respectively.

00:50:48.340 --> 00:50:53.490
So you're going to get
two, now, new problems,

00:50:53.490 --> 00:51:00.990
and run them and evaluate
them using the same procedure

00:51:00.990 --> 00:51:04.590
recursively, but now
with x plugged in for--

00:51:04.590 --> 00:51:06.960
true plugged in for x,
and also then with false

00:51:06.960 --> 00:51:09.450
plugged in for x--

00:51:09.450 --> 00:51:13.440
and get the answers
for those two cases.

00:51:13.440 --> 00:51:17.170
And if either one of
them ended up accepting,

00:51:17.170 --> 00:51:19.260
then you're going to
accept, because there exists

00:51:19.260 --> 00:51:24.360
a value of 4x which makes
the whole thing true,

00:51:24.360 --> 00:51:29.130
because you just
recursively showed

00:51:29.130 --> 00:51:31.650
that there was such a
value, either true or false,

00:51:31.650 --> 00:51:33.210
the thing has accepted.

00:51:33.210 --> 00:51:36.490
And if both of them fail,
then you're going to reject.

00:51:36.490 --> 00:51:40.810
And the very same idea if you
have a for all quantifier.

00:51:40.810 --> 00:51:44.890
You're going to evaluate the
remainder of the formula,

00:51:44.890 --> 00:51:49.800
again, with x equal to true and
false, so as two subproblems.

00:51:49.800 --> 00:51:51.300
But now you're going
to require them

00:51:51.300 --> 00:51:54.510
both to accept because that's
the meaning of for all--

00:51:54.510 --> 00:51:58.740
that both assignments to x
have to make the formula true.

00:51:58.740 --> 00:52:02.100
So you're going to evaluate
them recursively and accept

00:52:02.100 --> 00:52:07.740
if both of them are true, as
determined by your recursive--

00:52:07.740 --> 00:52:09.780
your recursion.

00:52:09.780 --> 00:52:12.868
So how much space does this use?

00:52:12.868 --> 00:52:14.910
I'm not going to go through
this in great detail.

00:52:14.910 --> 00:52:20.450
But each recursive level
uses just a constant amount

00:52:20.450 --> 00:52:21.240
of space.

00:52:21.240 --> 00:52:22.880
So every time you
do a recursion,

00:52:22.880 --> 00:52:27.380
you have to remember
that that value--

00:52:27.380 --> 00:52:30.805
that assignment
to that variable.

00:52:30.805 --> 00:52:32.430
You want to think of
recursion as being

00:52:32.430 --> 00:52:33.960
implemented on a stack.

00:52:33.960 --> 00:52:36.150
So you're just going to
pop-- push on the stack

00:52:36.150 --> 00:52:40.690
that value of that variable,
which is that true or false.

00:52:40.690 --> 00:52:44.040
So basically it's
1 bit of memory

00:52:44.040 --> 00:52:47.040
that you're going to require
every time you're going down

00:52:47.040 --> 00:52:48.420
the recursion.

00:52:48.420 --> 00:52:50.100
You just have to remember what--

00:52:52.650 --> 00:52:57.090
which case you're working on,
whether x equal to true or x

00:52:57.090 --> 00:53:00.100
equal to false.

00:53:00.100 --> 00:53:05.320
And so each recursive level
just involves constant space.

00:53:05.320 --> 00:53:07.480
And the depth of the recursion--

00:53:07.480 --> 00:53:09.430
how much might you
have to remember?

00:53:09.430 --> 00:53:12.970
Well, it's going to be at
most 1 for every quantifier,

00:53:12.970 --> 00:53:13.765
because that's--

00:53:13.765 --> 00:53:15.223
you're stripping
them off as you're

00:53:15.223 --> 00:53:16.370
going down the recursion.

00:53:16.370 --> 00:53:19.150
So that's going to be at most
the length of the formula.

00:53:19.150 --> 00:53:22.220
That's at most the number
of quantifiers you can have.

00:53:22.220 --> 00:53:25.510
And so the total amount
of space used by this

00:53:25.510 --> 00:53:29.900
is going to be just n, order n.

00:53:29.900 --> 00:53:35.010
So this problem is
solved in NSPACE,

00:53:35.010 --> 00:53:38.500
and so that's why
it's in PSPACE.

00:53:38.500 --> 00:53:41.480
I think that's all I
wanted to say about this.

00:53:46.890 --> 00:53:48.630
If we regard the tape
in a Turing machine

00:53:48.630 --> 00:53:51.960
as memory in a modern computer,
what does the finite control

00:53:51.960 --> 00:53:53.220
correspond to?

00:53:53.220 --> 00:53:54.990
The finite control
corresponds to just

00:53:54.990 --> 00:53:57.840
a finite additional memory.

00:53:57.840 --> 00:54:00.570
The tape is an unlimited
amount of memory.

00:54:00.570 --> 00:54:03.180
Or if we're putting
bounds, the amount

00:54:03.180 --> 00:54:06.510
of tape is going to be,
say, n squared memory,

00:54:06.510 --> 00:54:07.950
where n is the length of m--

00:54:07.950 --> 00:54:09.510
n is the length of the input.

00:54:09.510 --> 00:54:17.040
So, yeah, they're both memories,
but the finite control is--

00:54:17.040 --> 00:54:18.310
it doesn't grow with n.

00:54:18.310 --> 00:54:23.543
So that's going to be just
some constant amount of memory.

00:54:23.543 --> 00:54:25.710
What would be the time
complexity of this algorithm?

00:54:25.710 --> 00:54:28.260
Time complexity would be bad.

00:54:28.260 --> 00:54:29.513
It's going to be exponential.

00:54:29.513 --> 00:54:31.180
So you'd have to just
double-check that.

00:54:31.180 --> 00:54:34.020
But it's going to
be something like 2

00:54:34.020 --> 00:54:37.170
to the number of
variables that you have--

00:54:37.170 --> 00:54:40.500
2 the number of quantifiers,
plus some small overhead

00:54:40.500 --> 00:54:42.935
for evaluating the
formula multiple time.

00:54:42.935 --> 00:54:44.310
But it's going to
be exponential.

00:54:47.550 --> 00:54:48.930
What else can I answer for you?

00:54:57.570 --> 00:55:00.927
So someone is asking,
going back again to coNP,

00:55:00.927 --> 00:55:03.260
and how do we know there
exists a problem in coNP that's

00:55:03.260 --> 00:55:04.280
coNP-complete?

00:55:04.280 --> 00:55:06.470
We didn't define
even what that means.

00:55:06.470 --> 00:55:10.490
But coNP-complete
means-- we're going

00:55:10.490 --> 00:55:14.030
to start seeing other
examples of completeness

00:55:14.030 --> 00:55:15.830
for different
complexity classes.

00:55:15.830 --> 00:55:19.355
In particular, one thing that's
going to happen on Tuesday

00:55:19.355 --> 00:55:24.330
is we'll see a problem
that's complete for PSPACE.

00:55:24.330 --> 00:55:27.530
In fact, it's going to be TQBF.

00:55:27.530 --> 00:55:32.500
So looking ahead is going to
be a PSPACE-complete problem.

00:55:32.500 --> 00:55:35.320
But we even have
to have the notion

00:55:35.320 --> 00:55:39.100
of what we mean by complete
for these other classes.

00:55:39.100 --> 00:55:43.030
And in the case of coNP,
a problem is coNP-complete

00:55:43.030 --> 00:55:47.380
if it's in coNP, and
every other coNP problem

00:55:47.380 --> 00:55:50.170
is polynomial time-reducible
to it, so just exactly

00:55:50.170 --> 00:55:54.730
the same as we had for NP,
just plugging in coNP instead.

00:55:54.730 --> 00:56:01.320
And you just have to
work through the logic,

00:56:01.320 --> 00:56:03.430
but it's pretty straightforward.

00:56:03.430 --> 00:56:06.360
The complement of any
NP-complete problem

00:56:06.360 --> 00:56:12.010
is going to be a coNP-complete
problem using that definition.

00:56:12.010 --> 00:56:17.100
So I don't want to go through
that, those simple steps.

00:56:17.100 --> 00:56:19.770
But you just can go and
verify that offline--

00:56:19.770 --> 00:56:21.665
that that's going to be true.

00:56:21.665 --> 00:56:23.790
And I think we're going to
probably talk about that

00:56:23.790 --> 00:56:25.350
later in the semester, too.

00:56:29.020 --> 00:56:33.580
So another question-- how
does the TQBF algorithm--

00:56:37.450 --> 00:56:40.320
ah, that is a good
question here.

00:56:40.320 --> 00:56:45.000
Why is the TQBF algorithm that
I just described in PSPACE?

00:56:45.000 --> 00:56:47.940
Doesn't the thing-- every
time I'm doing a recursion,

00:56:47.940 --> 00:56:50.070
doesn't things branch
out so that I end up

00:56:50.070 --> 00:56:52.080
using exponential space?

00:56:52.080 --> 00:56:55.780
Critical thing which I actually
don't think I mentioned,

00:56:55.780 --> 00:56:57.480
which I think is
important to observe,

00:56:57.480 --> 00:57:00.780
is that when you're doing
those two recursive calls, when

00:57:00.780 --> 00:57:04.300
you set x equal to true
and set x equal to false,

00:57:04.300 --> 00:57:07.320
after you've determined
the answer for when you set

00:57:07.320 --> 00:57:11.190
x equal to true, now
you reuse that space,

00:57:11.190 --> 00:57:14.160
that very same space,
to test what happens

00:57:14.160 --> 00:57:16.410
when you have x equal to false.

00:57:16.410 --> 00:57:18.720
So that's the power
of space, which

00:57:18.720 --> 00:57:21.970
makes it different from time,
is that it can be reused.

00:57:21.970 --> 00:57:24.090
So after you've got
the answer for when

00:57:24.090 --> 00:57:27.270
you have x equal to true,
now you free up that space.

00:57:27.270 --> 00:57:29.100
That's no longer needed anymore.

00:57:29.100 --> 00:57:30.570
You just remember the answer.

00:57:30.570 --> 00:57:33.070
And now you see what happens
when you have x equal to false,

00:57:33.070 --> 00:57:34.180
using that same space.

00:57:34.180 --> 00:57:36.390
So there's no
exponential blow-up.

00:57:36.390 --> 00:57:37.640
That's an important point.

00:57:37.640 --> 00:57:41.950
I'm glad you gave me
the chance to say it.

00:57:41.950 --> 00:57:44.050
So somebody's asking
about defining

00:57:44.050 --> 00:57:45.800
time of a non-deterministic
Turing machine

00:57:45.800 --> 00:57:48.885
to the maximum time
of each branch.

00:57:48.885 --> 00:57:50.510
Well, that's sort of
what we have done.

00:57:50.510 --> 00:57:52.135
Maybe I don't understand
your question.

00:57:52.135 --> 00:57:55.460
But you'll have to
ask it afterward

00:57:55.460 --> 00:58:00.920
because I don't want to be
delaying any more than we have.

00:58:00.920 --> 00:58:07.010
So we're going to go
back and move on, here.

00:58:13.130 --> 00:58:17.660
Second example-- and this one
is a kind of a fun example,

00:58:17.660 --> 00:58:20.330
but it's also going to be
an important one for us.

00:58:20.330 --> 00:58:23.030
It's called the Ladder Problem.

00:58:23.030 --> 00:58:25.750
So you may have seen something
called a word ladder.

00:58:25.750 --> 00:58:29.450
But in general, a ladder
is a sequence of strings

00:58:29.450 --> 00:58:31.600
which are all of
the same length,

00:58:31.600 --> 00:58:34.195
but where consecutive strings
differ in a single symbol.

00:58:40.810 --> 00:58:43.390
So for example, if you a
word ladder for English,

00:58:43.390 --> 00:58:46.240
it's going to be a ladder
where all the words are--

00:58:46.240 --> 00:58:49.360
all of the strings
are English words.

00:58:49.360 --> 00:58:52.262
So here's an example.

00:58:52.262 --> 00:58:53.610
I thought I fixed that.

00:58:53.610 --> 00:59:02.160
OK, here is a word
ladder for English.

00:59:02.160 --> 00:59:03.810
And maybe you've seen these.

00:59:03.810 --> 00:59:07.640
Suppose I want to try to
get from "work" to "play."

00:59:07.640 --> 00:59:11.900
But all of the
intermediate strings

00:59:11.900 --> 00:59:16.250
should be English words
with four letters that

00:59:16.250 --> 00:59:20.510
differ from their previous
one in only a single letter.

00:59:20.510 --> 00:59:24.260
And I want to somehow change the
word "work" to the word "play."

00:59:24.260 --> 00:59:26.300
So I don't know if you know.

00:59:26.300 --> 00:59:30.660
So for example, I can
change "work" to "pork."

00:59:30.660 --> 00:59:33.840
So here's just one
letter difference,

00:59:33.840 --> 00:59:36.070
which looks like it's an
improvement, because now I

00:59:36.070 --> 00:59:36.570
have the--

00:59:36.570 --> 00:59:39.600
I'm in agreement on the play.

00:59:39.600 --> 00:59:41.270
But sometimes, you
might change it.

00:59:41.270 --> 00:59:43.020
You might have a good
change, and then you

00:59:43.020 --> 00:59:46.930
have to undo it later, which
I think actually happens here.

00:59:46.930 --> 00:59:49.140
So "pork" then is "port."

00:59:49.140 --> 00:59:52.050
But then we gave
up that progress.

00:59:52.050 --> 00:59:58.535
We made "port" to "sort"
to "suit" to "slot."

00:59:58.535 --> 01:00:00.410
You've got to understand
what I'm doing here.

01:00:00.410 --> 01:00:03.470
Each case, I'm just
changing a single letter.

01:00:03.470 --> 01:00:05.130
But all of these words--

01:00:05.130 --> 01:00:07.520
all of these have to be
legitimate English words

01:00:07.520 --> 01:00:09.400
of length 4.

01:00:09.400 --> 01:00:12.970
"Plot," "ploy,"
and then "play"--

01:00:15.720 --> 01:00:17.762
so that's what a word
ladder in English would be.

01:00:17.762 --> 01:00:19.762
Of course, you can do it
in different languages.

01:00:19.762 --> 01:00:22.020
And now I'm going to
talk about it abstractly,

01:00:22.020 --> 01:00:27.060
where instead of having a
natural human language as being

01:00:27.060 --> 01:00:30.990
the test for a word--

01:00:30.990 --> 01:00:33.390
for being-- a string
being legitimate--

01:00:33.390 --> 01:00:37.560
I'm going to define
any old language.

01:00:40.175 --> 01:00:43.970
Let's say A is going to be some
language, some set of strings.

01:00:43.970 --> 01:00:46.940
And those are going to
be the legal strings that

01:00:46.940 --> 01:00:49.090
can be in the ladder.

01:00:49.090 --> 01:00:51.040
So ladder A is a
ladder of strings

01:00:51.040 --> 01:00:54.310
that are all members of A.

01:00:54.310 --> 01:01:01.200
And now the ladder
DFA problem is A going

01:01:01.200 --> 01:01:03.840
to be the language of some DFA.

01:01:03.840 --> 01:01:11.290
So I'm giving you B and then a
start string and an end string.

01:01:11.290 --> 01:01:13.090
So this is like work and play.

01:01:13.090 --> 01:01:16.870
U and v are like work and
play, so where B is a DFA.

01:01:16.870 --> 01:01:21.430
And its language has a
ladder that goes from u to v,

01:01:21.430 --> 01:01:23.035
and here are the
intermediate strings.

01:01:36.840 --> 01:01:44.190
All right, so I'm going to
show you that this ladder DFA

01:01:44.190 --> 01:01:45.180
problem is an NPSPACE.

01:01:48.800 --> 01:01:52.160
This not super hard
because basically--

01:01:52.160 --> 01:01:56.600
well, let's just actually
look at the slide here.

01:01:56.600 --> 01:01:58.920
The way it's going to work
is it's nondeterministically

01:01:58.920 --> 01:02:01.430
going to guess that
sequence from u to v.

01:02:01.430 --> 01:02:05.280
So if I'm trying to get from
work to play, imagine those--

01:02:05.280 --> 01:02:09.020
I'm going to be
using this in place

01:02:09.020 --> 01:02:13.970
of the language of
my finite automaton,

01:02:13.970 --> 01:02:15.780
just because this is
easier to talk about.

01:02:15.780 --> 01:02:17.540
But imagine these
are being strings

01:02:17.540 --> 01:02:22.190
that are accepted by that DFA.

01:02:22.190 --> 01:02:25.490
So now I'm trying to get from
my string u to the string v.

01:02:25.490 --> 01:02:26.360
And I want to test.

01:02:26.360 --> 01:02:31.150
Can I get there by changing
one letter at a time,

01:02:31.150 --> 01:02:34.375
but staying at strings that
are accepted by the DFA?

01:02:37.590 --> 01:02:42.600
I'm just going to guess that
sequence nondeterministically.

01:02:42.600 --> 01:02:46.230
But I have to make sure--
careful of two things.

01:02:46.230 --> 01:02:49.290
I don't want to guess the
sequence all in advance

01:02:49.290 --> 01:02:52.970
because that sequence might
be exponentially long.

01:02:52.970 --> 01:02:55.150
You have to calculate how
long it could possibly be.

01:02:55.150 --> 01:02:59.458
But you might change
to one symbol,

01:02:59.458 --> 01:03:01.000
then change it to
a different symbol,

01:03:01.000 --> 01:03:04.060
then change it back to
that original symbol.

01:03:04.060 --> 01:03:07.180
So the only bound that
you can write down

01:03:07.180 --> 01:03:08.710
is the number of
possible strings

01:03:08.710 --> 01:03:11.140
that you can have
of that length.

01:03:11.140 --> 01:03:13.000
So it might be exponential.

01:03:13.000 --> 01:03:15.010
You don't want to write
down that whole thing

01:03:15.010 --> 01:03:18.880
because that's going to be
exceeding your space bound.

01:03:18.880 --> 01:03:20.390
But you don't need to.

01:03:20.390 --> 01:03:23.350
You're just going to
guess them one at a time,

01:03:23.350 --> 01:03:24.855
forgetting about
the previous one.

01:03:24.855 --> 01:03:28.300
So just keep guessing the
next one in the sequence

01:03:28.300 --> 01:03:31.770
and only remembering
that one and seeing

01:03:31.770 --> 01:03:38.150
if you ever get to the
string-- your target string.

01:03:38.150 --> 01:03:40.520
But then when you do that,
you have to make sure

01:03:40.520 --> 01:03:43.680
that you don't end
up going forever,

01:03:43.680 --> 01:03:52.680
because that's not allowed
in your NPSPACE algorithm.

01:03:52.680 --> 01:03:55.580
So you're going to
have to keep a counter

01:03:55.580 --> 01:03:59.057
to make sure that if you
go beyond that bound, which

01:03:59.057 --> 01:04:00.890
is going to be the
maximum number of strings

01:04:00.890 --> 01:04:02.450
you could possibly
have, then you're

01:04:02.450 --> 01:04:06.230
going to just shut that branch
of the nondeterminism off.

01:04:06.230 --> 01:04:08.870
You're going to just
reject on that branch.

01:04:08.870 --> 01:04:10.430
So here is-- I'm
going to write--

01:04:10.430 --> 01:04:13.580
say this here.

01:04:13.580 --> 01:04:19.870
Here is my nondeterministic
polynomial space procedure.

01:04:19.870 --> 01:04:25.330
I'm given my language-- my DFA
B and my start and end strings.

01:04:25.330 --> 01:04:29.320
I let y equal to start string.

01:04:29.320 --> 01:04:31.780
Write down the
length of my strings

01:04:31.780 --> 01:04:35.560
that I'm going to have to keep
in mind all the way through.

01:04:35.560 --> 01:04:38.140
And then I'm going to just
repeat the following t

01:04:38.140 --> 01:04:41.470
times, where t is the
maximum length this can be,

01:04:41.470 --> 01:04:45.310
which is the size of the
alphabet of these things

01:04:45.310 --> 01:04:50.348
to the mth power, where m is
the length of those strings.

01:04:50.348 --> 01:04:52.390
And I'm just going to
nondeterministically change

01:04:52.390 --> 01:04:56.320
one symbol at a time,
making sure that I'm

01:04:56.320 --> 01:05:00.720
staying in the language,
so rejecting immediately

01:05:00.720 --> 01:05:04.710
if that change introduced a
string outside the language,

01:05:04.710 --> 01:05:06.660
and accepting if
that string that I

01:05:06.660 --> 01:05:13.840
get by changing that single
symbol is now my target.

01:05:13.840 --> 01:05:16.600
And if I've gone
through my bound,

01:05:16.600 --> 01:05:20.450
and I haven't managed
to reach that target,

01:05:20.450 --> 01:05:21.700
then I'm just going to reject.

01:05:25.760 --> 01:05:30.910
And we just have to observe
that this algorithm doesn't

01:05:30.910 --> 01:05:32.360
use too much space.

01:05:32.360 --> 01:05:34.660
So if you imagine
what we need here,

01:05:34.660 --> 01:05:38.200
here's my input, u and
v, which is a blanked n,

01:05:38.200 --> 01:05:39.580
and the total amount of space.

01:05:39.580 --> 01:05:48.120
I just have to
remember the current y

01:05:48.120 --> 01:05:51.840
and also my counter
t, my counter up to t.

01:05:51.840 --> 01:05:58.320
So each of those can be written
down essentially in space.

01:05:58.320 --> 01:06:02.740
So the total amount is
going to be order n space.

01:06:02.740 --> 01:06:06.700
So that shows that this
ladder DFA problem is actually

01:06:06.700 --> 01:06:09.250
in nondeterministic space n--

01:06:09.250 --> 01:06:10.600
nondeterministic linear space.

01:06:14.580 --> 01:06:18.540
And what we're
going to show next

01:06:18.540 --> 01:06:20.850
is that this
language is actually

01:06:20.850 --> 01:06:22.590
solvable in deterministic space.

01:06:22.590 --> 01:06:24.360
And this is perhaps
a bit of a surprise.

01:06:30.940 --> 01:06:32.620
So what's the size of the input?

01:06:32.620 --> 01:06:37.460
The size of the
input is going to be

01:06:37.460 --> 01:06:43.160
what it takes to write down
the DFA and the two strings, u

01:06:43.160 --> 01:06:52.800
and v. So here, yeah,
I mean, I should

01:06:52.800 --> 01:06:56.335
have also included as part of
the input the description of B

01:06:56.335 --> 01:06:56.835
itself.

01:07:01.920 --> 01:07:06.240
But that's going to be
more in my favor because--

01:07:06.240 --> 01:07:08.370
this is slightly
incorrect, because B

01:07:08.370 --> 01:07:10.620
itself has to appear
as part of the input,

01:07:10.620 --> 01:07:12.220
so apologies for that.

01:07:12.220 --> 01:07:15.030
But still, the
amount of space used

01:07:15.030 --> 01:07:17.880
is going to be order n,
because these are going

01:07:17.880 --> 01:07:19.230
to be actually less than n.

01:07:24.110 --> 01:07:26.070
So we don't run out of
time for the lecture,

01:07:26.070 --> 01:07:29.105
we can save additional
questions for afterward.

01:07:29.105 --> 01:07:30.605
I'll stick around
for a few minutes.

01:07:30.605 --> 01:07:33.650
But I just really have
one more slide here,

01:07:33.650 --> 01:07:36.140
and that is proving
this theorem that ladder

01:07:36.140 --> 01:07:38.950
can be done deterministically
in polynomial space.

01:07:38.950 --> 01:07:43.093
And that's going to be
important as a kind of preview

01:07:43.093 --> 01:07:44.885
of what we're going to
be doing on Tuesday.

01:07:50.840 --> 01:07:54.260
If this goes a little fast, I'll
go over it again on Tuesday.

01:07:54.260 --> 01:07:55.970
So let's just see how it goes.

01:07:55.970 --> 01:08:01.240
So I'm going to show the same
ladder DFA problem is solvable

01:08:01.240 --> 01:08:05.342
deterministically
in polynomial space.

01:08:05.342 --> 01:08:07.050
But this time, it's
going to be n squared

01:08:07.050 --> 01:08:09.120
space instead of
nondeterministically

01:08:09.120 --> 01:08:10.290
in n space.

01:08:10.290 --> 01:08:11.760
So there's going
to be some cost,

01:08:11.760 --> 01:08:15.040
but it's only going
to be a squaring.

01:08:15.040 --> 01:08:17.140
So remember what the problem is.

01:08:17.140 --> 01:08:19.510
I'm giving you
that DFA, and I've

01:08:19.510 --> 01:08:22.300
given you two strings in
the language of that DFA.

01:08:22.300 --> 01:08:26.830
And I want to know, can I
get from the first string

01:08:26.830 --> 01:08:29.979
to the second string by
changing one symbol at a time,

01:08:29.979 --> 01:08:35.200
but always making sure that
the strings along the way

01:08:35.200 --> 01:08:36.505
are accepted by that DFA?

01:08:40.200 --> 01:08:42.990
So I'm going to introduce
notation saying,

01:08:42.990 --> 01:08:45.960
can I get from string
u to v by a ladder?

01:08:45.960 --> 01:08:48.990
But now I'm limiting how
many steps I can take.

01:08:48.990 --> 01:08:51.840
So I'm writing u to
v, but doing it only

01:08:51.840 --> 01:08:55.560
within B intermediate
strings, B steps.

01:08:55.560 --> 01:08:58.590
So is there a ladder from
u to v of length at most B?

01:08:58.590 --> 01:09:01.080
That's what it means to
write this notation down.

01:09:03.680 --> 01:09:07.069
So I'm going to give you
a recursive procedure

01:09:07.069 --> 01:09:10.609
to solve the bounded ladder
problem, where it's just

01:09:10.609 --> 01:09:13.819
like before, but now
I'm going to say,

01:09:13.819 --> 01:09:15.859
not only does there
a ladder from u to v,

01:09:15.859 --> 01:09:23.020
but there's a ladder
of length at most B.

01:09:23.020 --> 01:09:25.840
And that's going to allow
me to solve the ladder

01:09:25.840 --> 01:09:38.760
problem recursively by
shrinking the size of B.

01:09:38.760 --> 01:09:42.479
So how is this going to work?

01:09:47.540 --> 01:09:49.229
Here is going to be the idea.

01:09:49.229 --> 01:09:55.430
So here's my u and my
v. And the procedure

01:09:55.430 --> 01:10:00.770
is going to work by instead of
nondeterministically guessing

01:10:00.770 --> 01:10:03.230
the steps that take
me from work to play,

01:10:03.230 --> 01:10:05.150
because I don't have
nondeterminism anymore,

01:10:05.150 --> 01:10:07.280
I have to operate
deterministically.

01:10:07.280 --> 01:10:10.145
What I'm going to do is work--

01:10:13.810 --> 01:10:15.140
instead of going from--

01:10:15.140 --> 01:10:19.880
looking at the very first
thing that follows from u,

01:10:19.880 --> 01:10:22.510
I'm going to jump
right to the middle

01:10:22.510 --> 01:10:25.075
and try every possible
middle string.

01:10:28.668 --> 01:10:31.210
I have no clue even what that
middle string should look like,

01:10:31.210 --> 01:10:33.945
so I'm going to try all
possibilities in sequence.

01:10:37.360 --> 01:10:39.220
Once I have one of
those possibilities,

01:10:39.220 --> 01:10:41.380
I'm going to
recursively try to solve

01:10:41.380 --> 01:10:43.690
the problem by splitting that.

01:10:43.690 --> 01:10:48.190
But I'm now going to divide
that B value in half.

01:10:48.190 --> 01:10:50.710
So here is the maximum
value we can have.

01:10:50.710 --> 01:10:52.430
This is the t from
the previous slide

01:10:52.430 --> 01:10:53.605
which is the maximum length.

01:10:57.790 --> 01:11:01.210
Here, I'm going to try
every possible intermediate.

01:11:01.210 --> 01:11:05.530
Let's start off with A, all A's.

01:11:05.530 --> 01:11:07.990
And now I can cut
the problem in half.

01:11:07.990 --> 01:11:11.368
Can I get from work to all
A's and all A's to play?

01:11:11.368 --> 01:11:12.910
Well, very first
thing I should check

01:11:12.910 --> 01:11:15.700
is making sure that
all A's in fact

01:11:15.700 --> 01:11:18.100
is a string in the language.

01:11:18.100 --> 01:11:20.792
And if we're thinking
of the language as--

01:11:20.792 --> 01:11:22.240
imagining it's like English--

01:11:22.240 --> 01:11:24.940
all A's is not a
legitimate word.

01:11:24.940 --> 01:11:27.532
So you try the next one, AAB.

01:11:27.532 --> 01:11:28.990
And this is how
it's going to work,

01:11:28.990 --> 01:11:31.210
but now you're going to be--
instead of using English,

01:11:31.210 --> 01:11:33.293
you're going to feed it
into the finite automaton,

01:11:33.293 --> 01:11:37.290
just one after the next, trying
every possibility until--

01:11:37.290 --> 01:11:42.470
like a clock, like an
odometer, just trying them all,

01:11:42.470 --> 01:11:47.060
until eventually you find a
string that's in the language.

01:11:47.060 --> 01:11:49.760
I'm representing that by
an English word "able."

01:11:49.760 --> 01:11:52.460
Maybe that's the first word
that you would have found.

01:11:52.460 --> 01:11:55.190
And then once you find
that, you're going to--

01:11:55.190 --> 01:11:57.890
can I get from "work"
to "able" and "able"

01:11:57.890 --> 01:12:03.100
to "play" recursively, reusing
the space again, but now

01:12:03.100 --> 01:12:06.390
where the bound is cut in half?

01:12:06.390 --> 01:12:08.680
So that's the whole algorithm.

01:12:08.680 --> 01:12:12.890
So just going
through it quickly,

01:12:12.890 --> 01:12:21.500
and I will do this again,
here is my DFA going from u

01:12:21.500 --> 01:12:23.490
to v within B steps.

01:12:23.490 --> 01:12:27.090
First of all-- oh, this is bad.

01:12:27.090 --> 01:12:28.160
t should not be 1.

01:12:28.160 --> 01:12:31.530
This should be B. If B is 1--

01:12:31.530 --> 01:12:33.890
let me quickly fix that.

01:12:33.890 --> 01:12:36.230
So these t's should be B's.

01:12:36.230 --> 01:12:37.160
My apologies.

01:12:40.070 --> 01:12:41.940
So if t is 1--

01:12:41.940 --> 01:12:44.640
if B is 1, then
they have to-- then

01:12:44.640 --> 01:12:47.480
I'm only allowed a
ladder of length 1.

01:12:47.480 --> 01:12:49.550
Now I just check
intermediate directly.

01:12:49.550 --> 01:12:53.990
Do u and v differ in
just-- in one place?

01:12:53.990 --> 01:12:57.530
If yes, then I accept,
else, I reject.

01:12:57.530 --> 01:12:59.690
If it's greater than
1, now I'm going

01:12:59.690 --> 01:13:01.760
to do this procedure
that I described.

01:13:01.760 --> 01:13:09.600
I'm going to try for each
possible w in the middle,

01:13:09.600 --> 01:13:15.770
I'm going to try that
w, test whether I

01:13:15.770 --> 01:13:19.100
can get from u to w in half
the number of steps and from w

01:13:19.100 --> 01:13:20.720
to v in half the
number of steps,

01:13:20.720 --> 01:13:23.750
and accept if they both accept.

01:13:23.750 --> 01:13:27.890
And if trying all
possible w's, none of them

01:13:27.890 --> 01:13:29.570
work, then I know
that there's no way

01:13:29.570 --> 01:13:31.670
to get from u to v in B steps.

01:13:31.670 --> 01:13:34.130
And so then I reject.

01:13:34.130 --> 01:13:38.060
And then to do the original
problem, which was not

01:13:38.060 --> 01:13:43.490
the bounded ladder problem, I
do the bounded ladder problem

01:13:43.490 --> 01:13:46.730
where I put in t, which is the
maximum possible length that it

01:13:46.730 --> 01:13:51.250
could be to get from work to
play or to get from u to v.

01:13:51.250 --> 01:13:54.660
So the space analysis--

01:13:54.660 --> 01:13:56.160
well, I'm kind of
out of time, here.

01:13:56.160 --> 01:13:58.243
So we're going to go through
this again next time.

01:14:01.210 --> 01:14:03.510
So let me skip that analysis.

01:14:03.510 --> 01:14:05.040
I'll review this next time.

01:14:05.040 --> 01:14:06.360
I have a very quick Check-in.

01:14:06.360 --> 01:14:09.660
I just want to get here.

01:14:09.660 --> 01:14:14.400
Find an English word ladder
that connects the word "must"

01:14:14.400 --> 01:14:17.480
to the word "vote."

01:14:17.480 --> 01:14:18.740
You can think about that.

01:14:18.740 --> 01:14:21.410
I mean, it's not that hard
to come up with such a word

01:14:21.410 --> 01:14:25.220
letter, so I encourage you
to think about that-- also,

01:14:25.220 --> 01:14:28.550
to think about voting,
which is also important.

01:14:28.550 --> 01:14:29.390
That's coming up.

01:14:36.850 --> 01:14:38.320
Another 5 seconds here.

01:14:43.892 --> 01:14:45.350
I'm going to end
this, so make sure

01:14:45.350 --> 01:14:47.240
you get your credit
for the Check-in.

01:14:52.860 --> 01:14:54.825
So we're at the
end of the hour--

01:14:58.740 --> 01:15:00.990
end of the 80 minutes, anyway.

01:15:00.990 --> 01:15:03.960
So this is what we did today.

01:15:03.960 --> 01:15:09.060
And looks like I ran over by
a minute, so my apologies.

01:15:09.060 --> 01:15:11.520
But I'll stick around
here if any of you

01:15:11.520 --> 01:15:12.840
have any further questions.

01:15:12.840 --> 01:15:16.170
But otherwise, lecture is over.

01:15:16.170 --> 01:15:17.580
See you guys.

01:15:17.580 --> 01:15:20.710
Do we know anything about ladder
for other kinds of languages?

01:15:20.710 --> 01:15:24.070
I don't know.

01:15:24.070 --> 01:15:26.010
Interesting
question, whether you

01:15:26.010 --> 01:15:32.780
can say some nice things about
the ladder, the ladder problem,

01:15:32.780 --> 01:15:33.920
in other cases.

01:15:33.920 --> 01:15:36.260
I don't know.

01:15:36.260 --> 01:15:40.700
Why is t here, this value of t?

01:15:40.700 --> 01:15:48.200
Sigma to the m, the maximum
length of a word ladder.

01:15:48.200 --> 01:15:49.473
First of all, we have the m.

01:15:49.473 --> 01:15:51.140
Maybe I should have
written this down. m

01:15:51.140 --> 01:15:57.290
is the length of the words.

01:15:57.290 --> 01:16:00.635
Sigma is the alphabet
of the words.

01:16:03.400 --> 01:16:05.500
So the number of
possible different words

01:16:05.500 --> 01:16:07.120
is sigma to the m.

01:16:07.120 --> 01:16:10.540
These are all possible words
that there could possibly be.

01:16:10.540 --> 01:16:15.822
So there's no reason
in the word ladder ever

01:16:15.822 --> 01:16:18.280
to repeat the word because you
can just find a shorter word

01:16:18.280 --> 01:16:22.510
ladder that still does
the job of connecting

01:16:22.510 --> 01:16:25.360
a start and the end,
because you can just cut out

01:16:25.360 --> 01:16:29.890
that middle part,
the repeated part.

01:16:29.890 --> 01:16:35.490
So in that case, the
longest possible word

01:16:35.490 --> 01:16:38.602
ladder is going to be the
total number of possible words

01:16:38.602 --> 01:16:40.560
that you can have, which
is going to be sigma--

01:16:40.560 --> 01:16:43.680
the size of sigma to the m.

01:16:43.680 --> 01:16:46.240
Explain again why coNP
is a subset of PSPACE.

01:16:51.940 --> 01:16:56.830
Well, maybe I'll
say it this way.

01:16:56.830 --> 01:17:00.670
Why is it every coNP
language also in PSPACE?

01:17:00.670 --> 01:17:03.220
Well, take the complement
of your coNP language.

01:17:03.220 --> 01:17:05.140
That's an NP language.

01:17:05.140 --> 01:17:07.613
An NP language is in PSPACE
because we proved that.

01:17:07.613 --> 01:17:08.530
That's what we proved.

01:17:11.820 --> 01:17:14.580
But if a language is in
PSPACE, its complement

01:17:14.580 --> 01:17:18.360
is also in PSPACE, because
for a deterministic procedure,

01:17:18.360 --> 01:17:20.205
you can just flip the
answer of the machine.

01:17:24.510 --> 01:17:29.520
So if B, language B, is in coNP,
its complement, B complement,

01:17:29.520 --> 01:17:32.670
is in NP, which is in PSPACE.

01:17:32.670 --> 01:17:34.320
So B complement is in PSPACE.

01:17:34.320 --> 01:17:37.740
So now PSPACE-- you
can invert the answer.

01:17:37.740 --> 01:17:40.090
And now B is also in PSPACE.

01:17:40.090 --> 01:17:43.110
I hope that helps.

01:17:43.110 --> 01:17:48.150
Somebody's giving me the answer
to get from "must" to "vote."

01:17:48.150 --> 01:17:51.240
But I've seen that answer.

01:17:51.240 --> 01:17:56.010
There are online tools that
will answer word ladders.

01:17:56.010 --> 01:18:00.922
So you just plug in the
start and the finish,

01:18:00.922 --> 01:18:02.380
and it'll give you
the word ladder.

01:18:02.380 --> 01:18:04.590
And then the one
that this person

01:18:04.590 --> 01:18:07.860
has sent me is the one
you get from that tool,

01:18:07.860 --> 01:18:12.450
so I suspect he didn't
find it himself.

01:18:12.450 --> 01:18:14.730
Before lecture, I actually
solved that on my own,

01:18:14.730 --> 01:18:16.020
besides the one that--

01:18:16.020 --> 01:18:18.810
I know the one that
the tool will give you.

01:18:18.810 --> 01:18:23.040
So that tool gives one
in, I think, five steps.

01:18:23.040 --> 01:18:25.080
And I found one on
my own in six steps.

01:18:25.080 --> 01:18:26.620
It's not that hard.

01:18:26.620 --> 01:18:31.200
Yeah, "must," "most,"
"lost," "lose,"

01:18:31.200 --> 01:18:34.340
"rose," "rote," and "vote."

01:18:34.340 --> 01:18:37.610
So they made that seven steps.

01:18:37.610 --> 01:18:41.585
Anyway, for short words, you
can solve these generally

01:18:41.585 --> 01:18:42.710
pretty quickly on your own.

01:18:45.180 --> 01:18:45.680
What else?

01:18:45.680 --> 01:18:47.240
What else can I do for you?

01:18:52.530 --> 01:18:54.660
Do we need to worry
about coming back

01:18:54.660 --> 01:19:00.447
to a previously visited word on
the construction on this page?

01:19:00.447 --> 01:19:02.280
No, we don't have to
worry about coming back

01:19:02.280 --> 01:19:03.990
to a previously visited word.

01:19:03.990 --> 01:19:05.910
All you need to worry
about is making sure

01:19:05.910 --> 01:19:09.660
that you bound how long
are you going to go for.

01:19:09.660 --> 01:19:15.610
And that's where the previously
visited issue comes in.

01:19:15.610 --> 01:19:24.580
If the word ladder that you
found repeats some word,

01:19:24.580 --> 01:19:26.950
well, then there would have
been a shorter word ladder

01:19:26.950 --> 01:19:28.180
that would have also worked.

01:19:28.180 --> 01:19:35.740
But it still shows that it's
possible to get from the start

01:19:35.740 --> 01:19:41.050
word to the finish word if you
have a repeated one in between.

01:19:41.050 --> 01:19:43.070
So that doesn't matter.

01:19:43.070 --> 01:19:44.740
We don't have to
worry about that.

01:19:44.740 --> 01:19:47.030
If you did, then it
would be problem.

01:19:47.030 --> 01:19:48.590
So I think I will--

01:19:48.590 --> 01:19:49.120
4:05.

01:19:49.120 --> 01:19:51.280
I think I'm going to head out.

01:19:51.280 --> 01:19:52.330
See you all, guys.

01:19:52.330 --> 01:19:55.280
And I'm going to join my
TAs in a meeting shortly.

01:19:55.280 --> 01:19:55.780
So bye-bye.

01:19:55.780 --> 01:19:58.290
Thank you for being here.