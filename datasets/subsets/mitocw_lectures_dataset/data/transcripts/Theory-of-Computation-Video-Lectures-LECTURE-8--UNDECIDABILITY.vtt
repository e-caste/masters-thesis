WEBVTT

00:00:00.000 --> 00:00:05.434
[SQUEAKING]
[RUSTLING] [CLICKING]

00:00:25.510 --> 00:00:28.100
PROFESSOR: OK, why
don't I get started?

00:00:28.100 --> 00:00:34.780
So OK, what have we been doing?

00:00:34.780 --> 00:00:36.940
So last time, we
considered a bunch

00:00:36.940 --> 00:00:41.710
of procedures for testing
properties of various automata

00:00:41.710 --> 00:00:50.460
and grammars, the acceptance
problem for DFAs, for NFAs,

00:00:50.460 --> 00:00:52.500
the acceptance problem,
which is really

00:00:52.500 --> 00:00:55.530
degeneration problem for
context-free grammars,

00:00:55.530 --> 00:01:00.420
and emptiness problems for
DFAs and context-free grammars.

00:01:00.420 --> 00:01:06.558
And also, we showed that
A,TM is Turing-recognizable.

00:01:06.558 --> 00:01:08.850
There's a question here in
the chat already about that.

00:01:08.850 --> 00:01:10.170
Yes, we did show that.

00:01:10.170 --> 00:01:11.730
That was the universal
Turing machine

00:01:11.730 --> 00:01:13.000
that we presented at the end.

00:01:13.000 --> 00:01:17.010
That's what shows that A,TM
is Turing-recognizable.

00:01:17.010 --> 00:01:21.580
We mentioned that
A,TM is not decidable,

00:01:21.580 --> 00:01:23.460
which we promised
we will prove today.

00:01:23.460 --> 00:01:25.440
And we will do so.

00:01:25.440 --> 00:01:28.080
OK, so that is the plan--

00:01:28.080 --> 00:01:30.180
proving A,TM is undecidable.

00:01:30.180 --> 00:01:32.460
And we'll introduce the
method for doing that called

00:01:32.460 --> 00:01:34.470
the diagonalization method.

00:01:34.470 --> 00:01:38.670
I will also show the
complement of A,TM is

00:01:38.670 --> 00:01:41.130
Turing-unrecognizable.

00:01:41.130 --> 00:01:43.620
Even though A,TM
itself is recognizable,

00:01:43.620 --> 00:01:45.660
the complement is not.

00:01:45.660 --> 00:01:49.470
And then we will introduce
another method called

00:01:49.470 --> 00:01:52.920
the reducibility method for
showing other problems are not

00:01:52.920 --> 00:01:56.812
decidable and give one example
of another problem, which

00:01:56.812 --> 00:01:59.020
is not decidable, assuming
we have time to get to it.

00:01:59.020 --> 00:02:05.490
If not, we will delay that part
until next Tuesday's lecture.

00:02:05.490 --> 00:02:08.740
All right, acceptance
problem for Turing Machines.

00:02:08.740 --> 00:02:13.560
So just as I mentioned,
we showed that A,TM,

00:02:13.560 --> 00:02:16.900
which is the language of Turing
machines and inputs where

00:02:16.900 --> 00:02:19.800
the machine accepts the input.

00:02:19.800 --> 00:02:21.480
We showed that was recognizable.

00:02:21.480 --> 00:02:22.710
We claimed it was decidable.

00:02:22.710 --> 00:02:25.230
Today, we're going to
prove it's not decidable.

00:02:25.230 --> 00:02:30.520
All right, now the method
that we're going to use,

00:02:30.520 --> 00:02:32.940
which is really the
only method out there

00:02:32.940 --> 00:02:39.240
for proving a problem
as undecidable

00:02:39.240 --> 00:02:41.415
is called the
diagonalization method.

00:02:41.415 --> 00:02:44.040
I mean, ultimately, we're going
to show the reducibility method

00:02:44.040 --> 00:02:44.890
as well.

00:02:44.890 --> 00:02:47.070
But it really depends
on having already

00:02:47.070 --> 00:02:49.290
shown some other
problem undecidable

00:02:49.290 --> 00:02:53.050
via the diagonalization method.

00:02:53.050 --> 00:02:55.950
So ultimately, everything hinges
on the diagonalization method,

00:02:55.950 --> 00:02:58.840
which is really what we have.

00:02:58.840 --> 00:03:05.820
And so to introduce the
diagonalization method,

00:03:05.820 --> 00:03:09.540
I'm going to make a
bit of a digression

00:03:09.540 --> 00:03:13.380
into a branch of mathematics
called set theory

00:03:13.380 --> 00:03:16.860
or it's a part of
mathematical logic, where

00:03:16.860 --> 00:03:20.040
the method of
diagonalization was first

00:03:20.040 --> 00:03:25.320
conceived of back in the late
19th century by a mathematician

00:03:25.320 --> 00:03:27.690
called Georg Cantor.

00:03:27.690 --> 00:03:31.140
And Cantor was considering
the problem of,

00:03:31.140 --> 00:03:36.530
how do you compare the relative
sizes of infinite sets?

00:03:36.530 --> 00:03:43.490
For finite sets, the problem
of comparing-- somebody

00:03:43.490 --> 00:03:45.380
said that Cantor went crazy.

00:03:45.380 --> 00:03:47.450
That is true.

00:03:47.450 --> 00:03:50.630
And maybe I don't know
why he went crazy.

00:03:50.630 --> 00:03:53.960
But he did go--

00:03:53.960 --> 00:03:56.780
he had some mental
problems, unfortunately.

00:04:00.560 --> 00:04:03.470
And so how do we compare the
sizes of sets in general?

00:04:03.470 --> 00:04:06.250
If they're finite sets,
we can just count them up.

00:04:06.250 --> 00:04:09.740
We can say, whoa, this
set has 11 elements,

00:04:09.740 --> 00:04:12.620
and the other set
has 10 elements.

00:04:12.620 --> 00:04:14.630
So the one with 11 is bigger.

00:04:14.630 --> 00:04:16.620
Or if they both have 11,
they're the same size.

00:04:16.620 --> 00:04:18.620
Well, that's not going
to work for infinite sets

00:04:18.620 --> 00:04:21.110
because you can't count them up.

00:04:21.110 --> 00:04:22.850
And so he had--

00:04:22.850 --> 00:04:24.920
Cantor had the following
idea for comparing

00:04:24.920 --> 00:04:27.440
the sizes of infinite sets.

00:04:27.440 --> 00:04:31.940
And that was, basically,
to see whether you

00:04:31.940 --> 00:04:35.310
can have a function
that would map

00:04:35.310 --> 00:04:39.570
from one set to the other
set with certain properties.

00:04:39.570 --> 00:04:43.910
And those properties are
called, traditionally, well,

00:04:43.910 --> 00:04:47.310
I mean, in the past, have
been called the one-to-one

00:04:47.310 --> 00:04:49.410
and onto properties
for the function.

00:04:49.410 --> 00:04:51.300
I'll tell you what that means.

00:04:51.300 --> 00:04:54.180
But the concept is very simple.

00:04:54.180 --> 00:04:56.820
So a one-to-one
function is a function

00:04:56.820 --> 00:05:00.240
that's mapping from A to B.
Those are the two sets whose

00:05:00.240 --> 00:05:03.270
sizes we're trying to compare.

00:05:03.270 --> 00:05:06.810
And the function
being one-to-one just

00:05:06.810 --> 00:05:08.430
means that there
are no collisions.

00:05:08.430 --> 00:05:10.740
If you have two
different elements of A,

00:05:10.740 --> 00:05:13.530
they're never going to map
onto the same element of B.

00:05:13.530 --> 00:05:15.210
So two different
elements of A always

00:05:15.210 --> 00:05:17.280
map onto two different
elements of B.

00:05:17.280 --> 00:05:19.720
So that's the
one-to-one property.

00:05:19.720 --> 00:05:22.410
It's also called injective.

00:05:22.410 --> 00:05:28.960
And the other property is
called onto or surjective,

00:05:28.960 --> 00:05:31.358
which is that the range
of f has to be all of B.

00:05:31.358 --> 00:05:33.150
So you're not allowed
to miss any elements,

00:05:33.150 --> 00:05:35.670
but you have to hit everything.

00:05:35.670 --> 00:05:38.520
And when you have both
of those properties,

00:05:38.520 --> 00:05:41.580
the function is called a
one-to-one correspondence

00:05:41.580 --> 00:05:45.840
or a bijection also, OK?

00:05:45.840 --> 00:05:48.510
Now another way
of looking at it--

00:05:48.510 --> 00:05:50.730
I don't want to make this
more complicated than it

00:05:50.730 --> 00:05:51.480
needs to be.

00:05:51.480 --> 00:05:53.850
It just simply
means that two sets

00:05:53.850 --> 00:05:57.240
are considered to be the
same size if we can match up

00:05:57.240 --> 00:06:00.060
the elements with one set with
elements of the other set.

00:06:00.060 --> 00:06:02.070
You just pair them up.

00:06:02.070 --> 00:06:08.760
For example, well, if you
have finite sets, that idea,

00:06:08.760 --> 00:06:11.910
that informal idea just works
exactly as you would expect.

00:06:11.910 --> 00:06:15.630
For example, if we have two
sets-- here's a set of puppies.

00:06:15.630 --> 00:06:18.480
Here's a set of kittens.

00:06:18.480 --> 00:06:23.300
Now we want to show that those
two sets have the same size.

00:06:23.300 --> 00:06:26.120
We could count them up, as I
mentioned, and see that there

00:06:26.120 --> 00:06:28.040
are six elements in both.

00:06:28.040 --> 00:06:31.740
But counting up does not
work for infinite sets.

00:06:31.740 --> 00:06:37.160
So we can just match up
the elements of the puppies

00:06:37.160 --> 00:06:39.790
with the kittens,
and then we know

00:06:39.790 --> 00:06:42.610
we have the same number
of puppies as kittens.

00:06:42.610 --> 00:06:47.140
OK, now that has the
advantage of it making sense

00:06:47.140 --> 00:06:48.710
when you have infinite sets.

00:06:48.710 --> 00:06:50.523
So we're just going
to extend that idea

00:06:50.523 --> 00:06:51.940
and apply it to
infinite sets too.

00:06:51.940 --> 00:06:53.500
And then we'll have
a notion of what

00:06:53.500 --> 00:06:57.280
it means for two infinite
sets to have the same size.

00:06:57.280 --> 00:06:59.020
And you might wonder,
what do you get?

00:06:59.020 --> 00:07:01.630
Are all infinite
sets of the same size

00:07:01.630 --> 00:07:04.230
when you use this notion or not?

00:07:04.230 --> 00:07:05.860
What happens?

00:07:05.860 --> 00:07:08.170
Well, some strange
things do happen.

00:07:08.170 --> 00:07:12.790
But there actually are quite
some interesting structure

00:07:12.790 --> 00:07:14.660
there that emerges.

00:07:14.660 --> 00:07:19.660
So anyway, I don't
want to rush on.

00:07:19.660 --> 00:07:20.800
Questions on any of this?

00:07:20.800 --> 00:07:22.420
If you want to--

00:07:22.420 --> 00:07:23.080
quick question.

00:07:23.080 --> 00:07:25.497
This, hopefully, was not too
hard, but I want to make sure

00:07:25.497 --> 00:07:28.870
everybody's together with
me on it, so we can pop in--

00:07:28.870 --> 00:07:32.530
I'll give a few seconds for a
chat if you have any questions.

00:07:38.580 --> 00:07:41.220
The range of the set
is all of the elements

00:07:41.220 --> 00:07:44.610
that you hit as you look at
the different possible elements

00:07:44.610 --> 00:07:47.250
of A. So all of the things that
f hits, the standard notion

00:07:47.250 --> 00:07:48.420
of a range of a function.

00:07:51.220 --> 00:07:53.370
So the range of f
has to be equal to B.

00:07:53.370 --> 00:07:54.848
You have to hit everything.

00:07:58.060 --> 00:08:02.180
All right, can you think of
a one-to-one correspondence

00:08:02.180 --> 00:08:03.103
as a relabeling?

00:08:03.103 --> 00:08:04.520
Yeah, I'm not sure
that's helpful.

00:08:04.520 --> 00:08:07.580
But, yes, you can think of as
a relabeling of the elements

00:08:07.580 --> 00:08:09.780
in a sense, but yeah.

00:08:09.780 --> 00:08:12.880
I just think of it
as a matching up.

00:08:12.880 --> 00:08:15.320
All right, so let's move on.

00:08:15.320 --> 00:08:20.120
So coming out of
this notion of sets

00:08:20.120 --> 00:08:22.670
being of the same
size with this notion

00:08:22.670 --> 00:08:25.560
of countable sets, as
we'll see in a minute,

00:08:25.560 --> 00:08:28.400
so let's do an example.

00:08:28.400 --> 00:08:31.000
Let's take the set
of natural numbers--

00:08:31.000 --> 00:08:33.429
1, 2, 3, 4, dot, dot,
dot, dot, and the set

00:08:33.429 --> 00:08:36.909
of integers, which includes
the natural numbers

00:08:36.909 --> 00:08:39.370
but also the negative
numbers and zero.

00:08:42.159 --> 00:08:44.770
So the natural
numbers are typically

00:08:44.770 --> 00:08:49.510
referred to as N. The integers
are typically referred to as Z.

00:08:49.510 --> 00:08:58.210
And what do we think of the
relative sizes of N and Z?

00:08:58.210 --> 00:09:01.600
Well, N is a subset of Z.
It's a proper subset of Z.

00:09:01.600 --> 00:09:04.480
So you might, at first glance,
think that Z is larger,

00:09:04.480 --> 00:09:07.240
and they're not really going
to be of the same size.

00:09:07.240 --> 00:09:10.960
But actually, it turns out that
there's a very simple way--

00:09:10.960 --> 00:09:14.590
the arithmetic and the
properties of infinite sets

00:09:14.590 --> 00:09:16.000
can be a little bit surprising.

00:09:16.000 --> 00:09:19.660
And there is a way of matching
up all of the elements of Z

00:09:19.660 --> 00:09:23.590
with their own elements
of N. And so you

00:09:23.590 --> 00:09:28.480
can show that following that
definition, that these two sets

00:09:28.480 --> 00:09:30.020
are, in fact, of the same size.

00:09:30.020 --> 00:09:34.880
So let's just quickly go
make sure you see that.

00:09:34.880 --> 00:09:37.450
So here is N. Here
is Z I'm going

00:09:37.450 --> 00:09:40.510
to write down a table which
shows how they match up.

00:09:40.510 --> 00:09:43.420
Here is the function f of n
that I'm going to be describing.

00:09:43.420 --> 00:09:47.050
That's the one-to-one
correspondence.

00:09:47.050 --> 00:09:48.880
And so here are the
natural numbers--

00:09:48.880 --> 00:09:52.030
dot, dot, dot, 1 through
7, dot, dot, dot.

00:09:52.030 --> 00:09:53.670
And here are the
elements of Z that I'm

00:09:53.670 --> 00:09:54.670
going to be matching up.

00:09:54.670 --> 00:09:56.300
This is how the
function is working.

00:09:56.300 --> 00:09:57.850
So one, I'm going to--

00:09:57.850 --> 00:09:59.560
f of 1 is going to be 0.

00:09:59.560 --> 00:10:01.840
F of 2 is going to be minus 1.

00:10:01.840 --> 00:10:05.170
F of 3 is going to be 1.

00:10:05.170 --> 00:10:08.740
And I'm just giving
you a way to match up

00:10:08.740 --> 00:10:12.710
each of the natural
numbers with integers

00:10:12.710 --> 00:10:16.910
so that every single integer has
its own natural number and vice

00:10:16.910 --> 00:10:17.410
versa.

00:10:19.990 --> 00:10:21.495
So 4 goes to minus 2.

00:10:21.495 --> 00:10:22.725
5 goes to 2.

00:10:22.725 --> 00:10:24.300
6 goes to minus 3.

00:10:24.300 --> 00:10:27.740
7 goes to 3, and then minus
4, and then 4, and minus 5,

00:10:27.740 --> 00:10:29.700
and then 5, and so on.

00:10:29.700 --> 00:10:31.140
You're clearly
going to cover all

00:10:31.140 --> 00:10:32.640
of the integers in this way.

00:10:32.640 --> 00:10:34.110
And each of the
natural numbers is

00:10:34.110 --> 00:10:35.385
going to have its own integer.

00:10:35.385 --> 00:10:37.260
And there's never going
to be any collisions.

00:10:37.260 --> 00:10:39.090
There's never going to be
two natural numbers assigned

00:10:39.090 --> 00:10:40.270
to the same integer.

00:10:40.270 --> 00:10:45.180
So this meets the conditions
of a one-to-one correspondence

00:10:45.180 --> 00:10:49.410
and shows that the natural
numbers and the integers

00:10:49.410 --> 00:10:55.400
have the same size
following this definition.

00:10:55.400 --> 00:11:02.030
OK, let's do one that's slightly
more complicated and, perhaps,

00:11:02.030 --> 00:11:06.230
slightly more surprising,
which is that if you consider

00:11:06.230 --> 00:11:11.715
all of the rational numbers,
and then they have the same--

00:11:11.715 --> 00:11:12.590
that is a collection.

00:11:12.590 --> 00:11:14.990
Even though the
rational numbers seem

00:11:14.990 --> 00:11:19.190
to be much richer and more
numerous than the integers,

00:11:19.190 --> 00:11:21.500
from this perspective,
they have the same size.

00:11:21.500 --> 00:11:25.110
And for the simplicity
of my presentation,

00:11:25.110 --> 00:11:27.720
I'm going to consider only
the positive rational numbers,

00:11:27.720 --> 00:11:30.080
which I'm going to write as Q+.

00:11:30.080 --> 00:11:32.930
So those are all of the
positive rational numbers

00:11:32.930 --> 00:11:36.530
that can be expressed as a
ratio of two natural numbers.

00:11:36.530 --> 00:11:41.000
And I'm going to show that there
is a one-to-one correspondence

00:11:41.000 --> 00:11:44.180
between these positive
rational numbers

00:11:44.180 --> 00:11:46.820
and the natural numbers.

00:11:46.820 --> 00:11:50.030
OK, so here, I'm
going to, again,

00:11:50.030 --> 00:11:53.510
make a table, just
as I did up above--

00:11:53.510 --> 00:11:55.520
so comparing the
natural numbers and

00:11:55.520 --> 00:11:57.530
the positive rational numbers.

00:11:57.530 --> 00:12:01.010
And to do that, I'm going
to write down over here

00:12:01.010 --> 00:12:02.990
on the side, just
to help you see

00:12:02.990 --> 00:12:08.180
how I'm getting this table,
a separate table that

00:12:08.180 --> 00:12:11.810
has all of the positive
rational numbers appearing

00:12:11.810 --> 00:12:15.170
in a nicely organized way.

00:12:15.170 --> 00:12:17.450
Here are all of the
rational numbers

00:12:17.450 --> 00:12:20.960
here that have 1 as a numerator,
that have 2 as a numerator,

00:12:20.960 --> 00:12:24.140
and so on, and going
through across the columns,

00:12:24.140 --> 00:12:26.310
the different denominators.

00:12:26.310 --> 00:12:29.367
So the numbers
inside here represent

00:12:29.367 --> 00:12:30.950
all of the different
rational numbers.

00:12:30.950 --> 00:12:32.900
And so whatever rational
number you have,

00:12:32.900 --> 00:12:36.770
m over n, that's
going to appear down

00:12:36.770 --> 00:12:39.018
the nth row in the nth column.

00:12:39.018 --> 00:12:40.310
That number is going to appear.

00:12:40.310 --> 00:12:42.200
So they're all going to show up.

00:12:42.200 --> 00:12:49.070
And I'm going to use this table
here to fill out this function.

00:12:49.070 --> 00:12:52.360
So here are all the
natural numbers.

00:12:52.360 --> 00:12:56.950
And the way I'm going to assign
the rational numbers to appear

00:12:56.950 --> 00:13:02.680
over here is I'm just going to
work my way in from the corner.

00:13:02.680 --> 00:13:06.200
And I'm going to do
that by doing layers.

00:13:06.200 --> 00:13:09.370
So first, I'll take
the 1 in this number

00:13:09.370 --> 00:13:10.330
here in this corner.

00:13:10.330 --> 00:13:13.150
Then, I'll do these
three that surrounded it,

00:13:13.150 --> 00:13:15.550
and then these guys
that surround that,

00:13:15.550 --> 00:13:18.910
and these guys sort of in shells
going around the previous ones

00:13:18.910 --> 00:13:20.830
that I've already covered.

00:13:20.830 --> 00:13:23.690
OK, so let me illustrate that.

00:13:23.690 --> 00:13:26.530
So here's 1 over 1, my
first rational number

00:13:26.530 --> 00:13:28.570
that I'm going to
enter into the table,

00:13:28.570 --> 00:13:29.920
appearing right over there.

00:13:29.920 --> 00:13:32.560
So next, I'm going
to go 2 over 1.

00:13:32.560 --> 00:13:35.270
That's going to appear
in the table over there.

00:13:35.270 --> 00:13:36.680
Now, we have 2 over 2.

00:13:36.680 --> 00:13:41.210
Now that's actually a little
bit problematic because 2 over 2

00:13:41.210 --> 00:13:43.530
has already been done.

00:13:43.530 --> 00:13:45.410
And if we put that in--

00:13:45.410 --> 00:13:47.060
because 2 over 2
equals 1 over 1.

00:13:47.060 --> 00:13:50.300
They're both the equal
to the rational number 1.

00:13:50.300 --> 00:13:52.910
So if we put 2 over 2
in this table over here,

00:13:52.910 --> 00:13:55.580
then we would no longer
have the one-to-one property

00:13:55.580 --> 00:13:59.850
because both 1 and 3 would
be mapping to the same point.

00:13:59.850 --> 00:14:04.850
So we're just going to
simply skip over 2 over 2.

00:14:04.850 --> 00:14:06.930
I'll show that as kind
of graying it out.

00:14:06.930 --> 00:14:10.010
So we're not going to add
that one on to the table

00:14:10.010 --> 00:14:12.650
onto my function.

00:14:12.650 --> 00:14:14.270
But so we'll skip over that.

00:14:14.270 --> 00:14:18.532
We'll go to 1 over 2, which
has not been seen before.

00:14:18.532 --> 00:14:20.990
And then we're just going to
continue doing the same thing,

00:14:20.990 --> 00:14:23.600
now going to this
next shell out here.

00:14:23.600 --> 00:14:28.760
3 over 1, 3 over 2, 3 over 3--

00:14:28.760 --> 00:14:31.840
same thing, we're going
to skip over that one--

00:14:31.840 --> 00:14:34.600
2 over 3, 1 over 3.

00:14:34.600 --> 00:14:36.680
I hope you're getting the idea.

00:14:36.680 --> 00:14:38.180
So I'm not going
to fill this table.

00:14:38.180 --> 00:14:41.410
I ran out of room to fill
out this table some more.

00:14:41.410 --> 00:14:44.140
But just to look at how the
process is going to continue

00:14:44.140 --> 00:14:45.580
here, we get 4 over 1.

00:14:45.580 --> 00:14:49.630
Now 4 over 2, again, is a
number we previously seen

00:14:49.630 --> 00:14:52.300
because that's the
rational number 2.

00:14:52.300 --> 00:14:54.400
We saw that up here
when we had 2 over 1,

00:14:54.400 --> 00:14:56.170
so we're going to
have to skip that one.

00:14:56.170 --> 00:14:58.480
4 over 3, 4 over 4--

00:14:58.480 --> 00:15:00.220
that was going to skip.

00:15:00.220 --> 00:15:02.760
3 over 4, and so on.

00:15:02.760 --> 00:15:03.260
OK?

00:15:03.260 --> 00:15:07.040
So by following
this procedure, I'm

00:15:07.040 --> 00:15:08.978
going to be able to
define this function.

00:15:08.978 --> 00:15:10.520
Now this function
is not particularly

00:15:10.520 --> 00:15:14.120
nice in terms of having
an elegant, closed form.

00:15:14.120 --> 00:15:16.820
But it is a totally
legitimate function

00:15:16.820 --> 00:15:20.000
in the sense of being a
mapping from natural numbers

00:15:20.000 --> 00:15:23.630
to the positive
rational numbers.

00:15:23.630 --> 00:15:27.530
And it has the one-to-one
correspondence property.

00:15:27.530 --> 00:15:31.340
So it pairs up each
of the natural numbers

00:15:31.340 --> 00:15:36.740
with each of the positive
rational numbers.

00:15:36.740 --> 00:15:40.217
They each get their
own mate, in a sense.

00:15:40.217 --> 00:15:42.050
And so that shows that
the rational numbers,

00:15:42.050 --> 00:15:44.150
despite the fact
that they're dense,

00:15:44.150 --> 00:15:48.020
and they have all sorts of
very more much bigger seeming,

00:15:48.020 --> 00:15:51.110
they really, from this
perspective of the sizes

00:15:51.110 --> 00:15:56.210
of the sets, they have the same
size as the natural numbers do.

00:15:56.210 --> 00:16:00.020
And so with that, it suggests
that the following definition

00:16:00.020 --> 00:16:02.600
that a set is
countable if it has

00:16:02.600 --> 00:16:06.583
the same size as the natural
numbers or it's finite.

00:16:06.583 --> 00:16:08.000
From this perspective,
we're going

00:16:08.000 --> 00:16:10.220
to be focusing on infinite sets.

00:16:10.220 --> 00:16:13.940
But yeah, countable or countably
infinite, sometimes people say,

00:16:13.940 --> 00:16:15.948
if it has the same size
as the natural numbers.

00:16:15.948 --> 00:16:17.990
Or otherwise, you have to
include the finite sets

00:16:17.990 --> 00:16:18.650
as well.

00:16:18.650 --> 00:16:23.450
And countable means you can
just go through the elements

00:16:23.450 --> 00:16:27.380
of the set as a list.

00:16:27.380 --> 00:16:29.630
So you can count them-- the
first one, the second one,

00:16:29.630 --> 00:16:32.206
the third one, the fourth
one, dot, dot, dot.

00:16:32.206 --> 00:16:34.990
And once you can do
that, and that counting

00:16:34.990 --> 00:16:38.600
is going to hit everything,
then you know can match them--

00:16:38.600 --> 00:16:40.570
you can pair them up
with the natural numbers.

00:16:40.570 --> 00:16:42.760
And so therefore, you
have a countable set.

00:16:42.760 --> 00:16:45.190
OK.

00:16:45.190 --> 00:16:49.750
So as we've shown,
both Z, the integers,

00:16:49.750 --> 00:16:53.690
and the positive rational
numbers are countable sets.

00:16:53.690 --> 00:16:54.190
OK?

00:16:54.190 --> 00:16:57.840
Now you might think
that, well, since we're

00:16:57.840 --> 00:17:00.720
allowing ourselves
to do something

00:17:00.720 --> 00:17:06.540
as arbitrary, in a way,
as this kind of a function

00:17:06.540 --> 00:17:10.740
to match up the natural numbers
with whatever set you're trying

00:17:10.740 --> 00:17:15.572
to measure, that every set
is going to be countable,

00:17:15.572 --> 00:17:18.030
if you think about it that way
because it seems like you're

00:17:18.030 --> 00:17:20.452
allowing too many possibilities.

00:17:20.452 --> 00:17:21.869
And then all the
infinite sets are

00:17:21.869 --> 00:17:24.599
going to end up being the same
size as the natural numbers.

00:17:24.599 --> 00:17:28.000
Well, that is, in
fact, is not true.

00:17:28.000 --> 00:17:29.970
And I don't know.

00:17:29.970 --> 00:17:32.460
Cantor, is the one
who discovered that.

00:17:32.460 --> 00:17:35.500
I don't know if that
was surprising or not.

00:17:35.500 --> 00:17:39.450
But it is interesting,
I think, that there are

00:17:39.450 --> 00:17:41.940
different sizes of infinities.

00:17:41.940 --> 00:17:46.870
And so we're going to now
take a look and see that.

00:17:46.870 --> 00:17:51.660
But I want to, again,
I want to stop and make

00:17:51.660 --> 00:17:52.980
sure we're all together.

00:17:52.980 --> 00:17:54.690
Can we always find
a closed formula

00:17:54.690 --> 00:17:56.850
for f, somebody's asking me.

00:17:56.850 --> 00:17:58.200
I don't know.

00:17:58.200 --> 00:18:03.460
For this particular
f, you probably could,

00:18:03.460 --> 00:18:07.600
but it would probably
be very messy.

00:18:07.600 --> 00:18:09.940
But in general, that's
not a requirement,

00:18:09.940 --> 00:18:13.810
having a closed form for
the mapping function.

00:18:13.810 --> 00:18:17.320
Any function is allowed as long
as a one-to-one correspondence.

00:18:20.530 --> 00:18:22.120
Are we all together on this?

00:18:22.120 --> 00:18:23.920
Are we comfortable
with the notion

00:18:23.920 --> 00:18:27.927
of some infinite sets
having the same size

00:18:27.927 --> 00:18:30.010
as the natural numbers,
and therefore, we're going

00:18:30.010 --> 00:18:31.420
to call them countable sets?

00:18:31.420 --> 00:18:33.760
And we're going to show
some other sets are

00:18:33.760 --> 00:18:36.520
going to have more elements.

00:18:36.520 --> 00:18:38.200
They're going to be uncountable.

00:18:38.200 --> 00:18:39.550
They're going to be beyond--

00:18:39.550 --> 00:18:43.300
strictly speaking, strictly
larger sets in the sense

00:18:43.300 --> 00:18:44.740
that we won't be
able to put them

00:18:44.740 --> 00:18:48.230
into a one-to-one correspondence
with the integers.

00:18:48.230 --> 00:18:49.540
So is N the smallest infinity?

00:18:49.540 --> 00:18:52.810
Yes, N is the smallest one.

00:18:52.810 --> 00:18:56.920
So any infinity
is going to have--

00:18:56.920 --> 00:18:58.107
you're going to always--

00:18:58.107 --> 00:18:59.440
I don't think you even need it--

00:18:59.440 --> 00:19:02.620
you need a special--

00:19:02.620 --> 00:19:04.600
whenever you have an
infinite collection,

00:19:04.600 --> 00:19:06.880
you can always
find a subset which

00:19:06.880 --> 00:19:12.447
is going to be a
countable subset

00:19:12.447 --> 00:19:14.530
and is going to be the
smallest of the infinities,

00:19:14.530 --> 00:19:16.647
but there are bigger ones.

00:19:16.647 --> 00:19:17.980
All right, why don't we move on?

00:19:20.680 --> 00:19:27.280
OK, so the example of a set that
we will show is not countable--

00:19:27.280 --> 00:19:31.300
an uncountable set,
as we call it--

00:19:31.300 --> 00:19:37.910
is a set of real numbers, which
we all know what these are,

00:19:37.910 --> 00:19:38.680
I hope.

00:19:38.680 --> 00:19:40.990
These are all of
the numbers that you

00:19:40.990 --> 00:19:44.620
can express by possibly
infinite decimal representations

00:19:44.620 --> 00:19:50.890
like pi, or E squared of 2, or
any of the other familiar ones.

00:19:50.890 --> 00:19:56.590
Rational numbers are also
members of or also count

00:19:56.590 --> 00:19:59.410
as real numbers
and integers too.

00:19:59.410 --> 00:20:04.390
And so but there are
these additional numbers

00:20:04.390 --> 00:20:07.240
that you can get by the
decimal expansions which

00:20:07.240 --> 00:20:09.520
may not be rational.

00:20:09.520 --> 00:20:12.100
And that collection, even
though, in some ways,

00:20:12.100 --> 00:20:16.060
it looks somewhat similar
to the rational numbers,

00:20:16.060 --> 00:20:17.328
the real numbers--

00:20:17.328 --> 00:20:18.370
I hope I said that right.

00:20:18.370 --> 00:20:22.900
The real numbers,
which is the set

00:20:22.900 --> 00:20:25.630
I'm considering here, the
ones with the infinite decimal

00:20:25.630 --> 00:20:30.200
expansions, they
actually are much larger.

00:20:30.200 --> 00:20:36.650
So the theorem is-- and this
was discovered by Cantor--

00:20:36.650 --> 00:20:39.720
that R is an uncountable set.

00:20:39.720 --> 00:20:42.110
And the reason why
I'm introducing

00:20:42.110 --> 00:20:47.780
this is, besides that I think
it's interesting and has

00:20:47.780 --> 00:20:51.360
some relation to the kinds
of things we're doing,

00:20:51.360 --> 00:20:53.630
but it's really for
the purposes right now,

00:20:53.630 --> 00:20:56.050
is to introduce this method
called diagonalization.

00:20:59.130 --> 00:21:02.100
OK, that's what we're going
to use later on again.

00:21:02.100 --> 00:21:04.530
But this is the first
time it appeared.

00:21:04.530 --> 00:21:08.190
So we're going to use a proof
by contradiction in order

00:21:08.190 --> 00:21:12.060
to show that R, the
collection of real numbers,

00:21:12.060 --> 00:21:13.740
is uncountable.

00:21:13.740 --> 00:21:15.840
And we'll assume,
for contradiction,

00:21:15.840 --> 00:21:17.910
that R countable.

00:21:17.910 --> 00:21:20.250
OK?

00:21:20.250 --> 00:21:23.340
So if we assume
that R is countable,

00:21:23.340 --> 00:21:26.640
it means we have, by definition,
a one-to-one correspondence

00:21:26.640 --> 00:21:29.530
from the natural numbers
to the real numbers.

00:21:29.530 --> 00:21:32.560
OK, so we can match up
all of the natural numbers

00:21:32.560 --> 00:21:37.520
with the real numbers in a
one-to-one and onto fashion.

00:21:37.520 --> 00:21:40.640
So we can pair up the natural
numbers with the real numbers.

00:21:40.640 --> 00:21:44.240
And we will cover all of the
real numbers by doing that.

00:21:44.240 --> 00:21:47.840
And we can make a table,
just like I did before.

00:21:47.840 --> 00:21:50.770
Here it is.

00:21:50.770 --> 00:21:54.700
And you can fill this out
with all of the real numbers.

00:21:54.700 --> 00:21:57.940
And that was what
the assumption means.

00:21:57.940 --> 00:22:00.130
And I'm going to show you
that that's impossible.

00:22:00.130 --> 00:22:04.700
Something is going to go
terribly wrong if you do that.

00:22:04.700 --> 00:22:07.410
Now you might disagree.

00:22:07.410 --> 00:22:08.580
You might be surprised.

00:22:08.580 --> 00:22:13.200
You might think,
well, Professor Sipser

00:22:13.200 --> 00:22:17.640
is wrong, that I'm going
to work on this overnight

00:22:17.640 --> 00:22:19.080
and forget the
rest of my classes,

00:22:19.080 --> 00:22:24.040
and I'm going to come up with
a list of all the real numbers.

00:22:24.040 --> 00:22:26.280
I'm going to fill
them out here and show

00:22:26.280 --> 00:22:28.020
that that's impossible.

00:22:28.020 --> 00:22:31.740
So let's say, hypothetically,
just for my example's sake,

00:22:31.740 --> 00:22:35.280
here is the list that
you came up with.

00:22:35.280 --> 00:22:37.200
So you have to match up
something with the 1.

00:22:37.200 --> 00:22:39.480
Let's say, E. That
was a special case,

00:22:39.480 --> 00:22:41.550
so you're going to
stick that with 1.

00:22:41.550 --> 00:22:43.320
And then pi came
out to be the number

00:22:43.320 --> 00:22:45.982
that you connected up with 2.

00:22:45.982 --> 00:22:47.440
You understand what
I'm doing here?

00:22:47.440 --> 00:22:48.330
I'm making a list.

00:22:48.330 --> 00:22:51.660
I'm trying to make my
correspondence-- my matching up

00:22:51.660 --> 00:22:54.870
between the natural
numbers and my real numbers

00:22:54.870 --> 00:22:59.440
that I'm hypothesizing to
exist for a contradiction.

00:22:59.440 --> 00:23:03.000
So 3, I don't know, 3
is gets connected to 0.

00:23:03.000 --> 00:23:05.820
I'm making this up, obviously--

00:23:05.820 --> 00:23:06.660
not on the spot.

00:23:06.660 --> 00:23:09.210
I wrote the slide,
you know, yesterday.

00:23:09.210 --> 00:23:13.320
But here is the square root of 2
showing up for whatever reason.

00:23:13.320 --> 00:23:15.960
Here is 1/7.

00:23:15.960 --> 00:23:18.660
Here is some other number,
which, I'll be interested

00:23:18.660 --> 00:23:20.407
if you recognize that one.

00:23:20.407 --> 00:23:21.240
That's a subtle one.

00:23:23.990 --> 00:23:29.930
This is 1.234-- yeah, some
familiar looking sequence here.

00:23:29.930 --> 00:23:31.610
And whatever it is--

00:23:31.610 --> 00:23:33.770
whatever it is, this is
what you came up with.

00:23:33.770 --> 00:23:37.160
You claim that this
is going to work as--

00:23:37.160 --> 00:23:37.940
very good.

00:23:37.940 --> 00:23:39.110
Somebody got it.

00:23:39.110 --> 00:23:40.640
It's i to the ith power.

00:23:40.640 --> 00:23:44.640
But let's not get hung
up on that, please.

00:23:44.640 --> 00:23:46.100
I to the ith power,
oddly enough,

00:23:46.100 --> 00:23:48.230
can be seen as a
real number under--

00:23:48.230 --> 00:23:55.560
if you define the imaginary
exponentiation, which is weird.

00:23:55.560 --> 00:23:59.900
But anyway, let's not
get too distracted.

00:23:59.900 --> 00:24:03.230
So here's my list of
numbers, my real numbers

00:24:03.230 --> 00:24:07.950
that I've matched up in my table
here with the natural numbers.

00:24:07.950 --> 00:24:09.710
Now I claim
something goes wrong.

00:24:09.710 --> 00:24:10.610
What goes wrong?

00:24:10.610 --> 00:24:15.830
I'm going to show you
that you actually did not

00:24:15.830 --> 00:24:19.400
do as you claimed,
that there's actually

00:24:19.400 --> 00:24:23.022
at least one number that's
missing from this list.

00:24:23.022 --> 00:24:24.230
And I'll exhibit that number.

00:24:24.230 --> 00:24:25.980
I'm going to show you
what that number is.

00:24:25.980 --> 00:24:27.940
I'm going to explicitly
come up with a number

00:24:27.940 --> 00:24:29.690
and show you that
there's that number it's

00:24:29.690 --> 00:24:31.500
missing from the list.

00:24:31.500 --> 00:24:34.910
So here, it's going
to be a number x.

00:24:34.910 --> 00:24:36.840
X is the one that's missing.

00:24:36.840 --> 00:24:38.420
So how am I going to get x?

00:24:38.420 --> 00:24:41.300
So x, well, I'm going to
start it off with 0 point,

00:24:41.300 --> 00:24:43.550
and then I'm going to fill
out the rest of the places.

00:24:43.550 --> 00:24:44.990
And how am I going
to get those places?

00:24:44.990 --> 00:24:46.490
I'm going to look
at the table here.

00:24:48.940 --> 00:24:50.160
So I want to look at--

00:24:50.160 --> 00:24:53.610
to get my first digit after
the decimal point of x,

00:24:53.610 --> 00:24:55.110
I'm going to look
at the first digit

00:24:55.110 --> 00:24:59.390
after the decimal point
of the very first number.

00:24:59.390 --> 00:25:01.540
So I take the first number,
look at the first digit

00:25:01.540 --> 00:25:05.410
after the decimal point,
which happens to be a 7.

00:25:05.410 --> 00:25:07.510
And the number I'm
going to put in for x

00:25:07.510 --> 00:25:08.950
It's not going to be 7.

00:25:08.950 --> 00:25:11.890
It's going to be
anything except 7.

00:25:11.890 --> 00:25:12.460
Let say, 8.

00:25:15.410 --> 00:25:18.720
For my next digit of x,
I'm going to look at--

00:25:18.720 --> 00:25:20.770
so my second digit
of x, I'm going to--

00:25:20.770 --> 00:25:22.770
everything's going to be
up to the decimal point

00:25:22.770 --> 00:25:24.860
now, so I'm not going
to keep saying that.

00:25:24.860 --> 00:25:26.510
I'm going to look
at the second digit

00:25:26.510 --> 00:25:31.880
of the second number, which is
a 4 after the decimal point.

00:25:34.430 --> 00:25:36.260
There it is.

00:25:36.260 --> 00:25:38.300
And for the second
digit of x, I'm

00:25:38.300 --> 00:25:42.290
going to use something which
is anything besides 4--

00:25:42.290 --> 00:25:44.150
5.

00:25:44.150 --> 00:25:46.492
I have some flexibility here.

00:25:46.492 --> 00:25:47.450
So I could have used 6.

00:25:47.450 --> 00:25:49.820
I could have used 7.

00:25:49.820 --> 00:25:51.860
For those of you who
have seen this before,

00:25:51.860 --> 00:25:54.440
who are going to
nitpick on me, I'm

00:25:54.440 --> 00:25:58.040
going to stay away from 9
and 0 just because there

00:25:58.040 --> 00:26:01.167
is some little edge cases that
arise there, which I don't want

00:26:01.167 --> 00:26:02.750
to get into because
I don't think it's

00:26:02.750 --> 00:26:04.910
interesting for this argument.

00:26:04.910 --> 00:26:06.560
But since I have
some flexibility,

00:26:06.560 --> 00:26:08.270
I'm going to avoid
zeros and nines--

00:26:08.270 --> 00:26:10.140
probably just nines
is all I really need.

00:26:10.140 --> 00:26:15.800
And then the argument is
just going to work fine, OK?

00:26:15.800 --> 00:26:20.290
So the next digit is a 0.

00:26:20.290 --> 00:26:22.900
The third digit, or the
third number is a 0.

00:26:22.900 --> 00:26:25.585
The third digit of x is going
to be anything except for 0.

00:26:25.585 --> 00:26:27.370
It could be a 1.

00:26:27.370 --> 00:26:30.760
Then I have a 2 here.

00:26:30.760 --> 00:26:36.110
Anything except a 2, 6.

00:26:36.110 --> 00:26:39.110
Then a 5-- anything
except a 5, a 1.

00:26:39.110 --> 00:26:43.670
A 9-- anything except
a 9, an 8, and so on.

00:26:43.670 --> 00:26:45.470
There's an 8.

00:26:45.470 --> 00:26:47.270
There's a 2, and dot, dot, dot.

00:26:47.270 --> 00:26:49.270
I'm just going to
keep doing that.

00:26:49.270 --> 00:26:54.330
And I'm going to say you missed
that number, whatever it is.

00:26:54.330 --> 00:26:55.970
But that number,
that's a number.

00:26:55.970 --> 00:26:57.770
After I'm all done,
it's going to be

00:26:57.770 --> 00:27:00.200
the decimal representation
of something.

00:27:00.200 --> 00:27:06.480
And that number, I claim,
is absent from the table.

00:27:06.480 --> 00:27:12.570
And you might say,
well, it's really there.

00:27:12.570 --> 00:27:17.250
It's just on the 23rd row.

00:27:17.250 --> 00:27:20.040
You just didn't get
to it and your slide.

00:27:20.040 --> 00:27:21.180
But it's there.

00:27:21.180 --> 00:27:24.360
Well, I'm going to say I
know it's not in the 23rd row

00:27:24.360 --> 00:27:27.270
because it differs from
the number in the 23rd row

00:27:27.270 --> 00:27:31.920
at the 23rd digit because
I constructed it that way.

00:27:31.920 --> 00:27:34.740
This number is
designed explicitly

00:27:34.740 --> 00:27:37.680
to be different from each of
the numbers that's on the list.

00:27:41.255 --> 00:27:42.880
So it can't be on
the list because it's

00:27:42.880 --> 00:27:44.680
been constructed to be
different from each of them

00:27:44.680 --> 00:27:45.597
in at least one place.

00:27:48.290 --> 00:27:50.410
So I think this is a
beautiful argument,

00:27:50.410 --> 00:27:53.500
and it shows that
no matter how you

00:27:53.500 --> 00:27:57.580
try to come up with a
one-to-one correspondence,

00:27:57.580 --> 00:27:58.990
you're going to fail.

00:27:58.990 --> 00:28:03.780
You might say, oh,
like, just one number?

00:28:03.780 --> 00:28:04.783
I did so much hard work.

00:28:04.783 --> 00:28:05.950
I'm missing just one number.

00:28:05.950 --> 00:28:09.645
Can't I get partial credit
and put this one on the list

00:28:09.645 --> 00:28:10.270
now I fixed it?

00:28:10.270 --> 00:28:10.630
No.

00:28:10.630 --> 00:28:12.730
Obviously, there are many,
many numbers that are missing.

00:28:12.730 --> 00:28:14.155
If you put this
one on the list, I

00:28:14.155 --> 00:28:16.570
was going to construct another
number that was missing.

00:28:16.570 --> 00:28:24.310
So there's just not no
possibility of fixing this.

00:28:24.310 --> 00:28:29.323
And in fact, the real
numbers are uncountable--

00:28:29.323 --> 00:28:31.240
cannot be matched up
with the natural numbers.

00:28:31.240 --> 00:28:33.010
And there's nothing.

00:28:33.010 --> 00:28:34.135
It doesn't even come close.

00:28:36.650 --> 00:28:41.050
So here, a summary
of what I just said.

00:28:41.050 --> 00:28:42.632
F is not a one-to-one
correspondence

00:28:42.632 --> 00:28:43.840
no matter what you try to do.

00:28:43.840 --> 00:28:45.965
You can't come up with a
one-to-one correspondence.

00:28:45.965 --> 00:28:48.900
That's the contradiction.

00:28:48.900 --> 00:28:53.310
So that proves that
R is uncountable.

00:28:53.310 --> 00:28:56.760
And that's why, by the way,
we call this a diagonalization

00:28:56.760 --> 00:28:58.950
because we're going
down this diagonal here

00:28:58.950 --> 00:29:02.990
that's where the term-- that's
where the name is come from.

00:29:02.990 --> 00:29:08.720
OK, so I'm happy to--

00:29:08.720 --> 00:29:11.240
[CHUCKLES] OK, that's a--

00:29:14.260 --> 00:29:17.260
somebody's asking me--
[CHUCKLES] I'm actually--

00:29:17.260 --> 00:29:20.570
I have a-- is it here?

00:29:20.570 --> 00:29:21.820
I can't remember if it's here.

00:29:21.820 --> 00:29:25.090
I have a check-in
coming about this.

00:29:25.090 --> 00:29:27.640
And somebody is
anticipating that

00:29:27.640 --> 00:29:31.450
by asking the actually rather
famous question about there

00:29:31.450 --> 00:29:36.550
being a possible infinity in
between the natural numbers

00:29:36.550 --> 00:29:37.985
and the real numbers.

00:29:37.985 --> 00:29:39.610
We know the real
numbers now are bigger

00:29:39.610 --> 00:29:40.657
than the natural numbers.

00:29:40.657 --> 00:29:42.490
But is there something
that's an in between?

00:29:42.490 --> 00:29:46.000
I mean, this is a very,
very famous problem,

00:29:46.000 --> 00:29:49.090
which I'll talk about when
we get to our check-in, which

00:29:49.090 --> 00:29:49.810
is coming up.

00:29:55.020 --> 00:29:56.940
Somebody is objecting
just the way

00:29:56.940 --> 00:29:59.700
I've defined x using
this procedure that

00:29:59.700 --> 00:30:03.700
really can't, in a sense, state,
you know-- but x is a number.

00:30:03.700 --> 00:30:07.980
X is the result of
what this procedure is.

00:30:07.980 --> 00:30:09.730
Following this procedure,
we're converging

00:30:09.730 --> 00:30:11.260
on some particular value.

00:30:11.260 --> 00:30:13.690
And so that is a value.

00:30:13.690 --> 00:30:18.372
If you want, we can make a more
precise way of determining.

00:30:18.372 --> 00:30:20.080
We don't have the
flexibility of choosing

00:30:20.080 --> 00:30:21.620
the way I did in my example.

00:30:21.620 --> 00:30:24.850
We can make a precise
procedure for coming up

00:30:24.850 --> 00:30:25.820
with these digits.

00:30:25.820 --> 00:30:29.075
But I don't think there's
anybody thinks there's anything

00:30:29.075 --> 00:30:29.575
that's--

00:30:32.460 --> 00:30:35.700
there's any shortcoming
in this argument in terms

00:30:35.700 --> 00:30:37.470
of the way we're defining x.

00:30:37.470 --> 00:30:40.860
I think it's worth understanding
this because it's really going

00:30:40.860 --> 00:30:47.430
to set the groundwork for our
proof that A,TM is undecidable,

00:30:47.430 --> 00:30:49.020
which is a little,
I think, perhaps,

00:30:49.020 --> 00:30:52.350
slightly more abstract in a
way in the way it sort of comes

00:30:52.350 --> 00:30:53.220
across.

00:30:53.220 --> 00:30:56.250
I'm going to try
to connect the two.

00:30:56.250 --> 00:30:58.320
But I think it's
helpful to understand

00:30:58.320 --> 00:31:00.540
at least this argument
because this argument is

00:31:00.540 --> 00:31:04.470
diagonalization in
its most raw form.

00:31:09.600 --> 00:31:11.290
All right, I think we're good.

00:31:11.290 --> 00:31:14.220
So why don't we continue, then?

00:31:14.220 --> 00:31:16.560
So there are a
number of corollaries

00:31:16.560 --> 00:31:19.680
that follow from the statement
that the real numbers is

00:31:19.680 --> 00:31:20.490
uncountable.

00:31:23.910 --> 00:31:27.180
First of all, if
you let script L

00:31:27.180 --> 00:31:29.485
be the collection
of all languages,

00:31:29.485 --> 00:31:31.860
if you want to consider it
over some particular alphabet,

00:31:31.860 --> 00:31:32.370
that's fine.

00:31:32.370 --> 00:31:39.010
But that's not going to be
really important for this point

00:31:39.010 --> 00:31:40.600
that I'm going to make.

00:31:40.600 --> 00:31:46.540
So script L is the
collection of all languages.

00:31:46.540 --> 00:31:50.280
So every subset of sigma star--

00:31:50.280 --> 00:31:53.250
every subset of sigma
star is a language.

00:31:53.250 --> 00:31:56.760
So look at all those
possible subsets.

00:31:56.760 --> 00:31:59.040
So that includes 0
to the k, 1 to the k,

00:31:59.040 --> 00:32:01.860
plus every other language you
can ever think of and more--

00:32:01.860 --> 00:32:04.730
all possible languages.

00:32:04.730 --> 00:32:09.110
So the collection of all
languages is uncountable.

00:32:09.110 --> 00:32:12.110
There's uncountably many
different languages out there.

00:32:12.110 --> 00:32:13.942
I don't want to
belabor this point.

00:32:13.942 --> 00:32:15.650
You can just take this
if you don't quite

00:32:15.650 --> 00:32:18.530
follow the quick argument
I'm going to make here.

00:32:18.530 --> 00:32:23.420
But you can make a
one-to-one correspondence

00:32:23.420 --> 00:32:27.650
from all languages to the
reals so that each language

00:32:27.650 --> 00:32:30.328
gets its own real number.

00:32:30.328 --> 00:32:32.370
And the way I'm going to
think about that-- let's

00:32:32.370 --> 00:32:35.220
put the real numbers
into binary form.

00:32:35.220 --> 00:32:37.590
And if you imagine
here being sigma star,

00:32:37.590 --> 00:32:39.270
all of the possible
strings of sigma

00:32:39.270 --> 00:32:43.560
star written out in
their standard order.

00:32:43.560 --> 00:32:45.500
And now if you have
a language here, A,

00:32:45.500 --> 00:32:47.850
it's just some
arbitrary language.

00:32:47.850 --> 00:32:52.210
So that's going to have some
of the strings of sigma star

00:32:52.210 --> 00:32:52.710
appearing.

00:32:52.710 --> 00:32:55.350
Like 0 is appearing,
but 1 is not appearing.

00:32:55.350 --> 00:32:58.590
00 is appearing and 01,
but not these three.

00:33:01.270 --> 00:33:04.600
And I'm going to associate
to A, my language,

00:33:04.600 --> 00:33:11.440
some real number in binary by
putting in a 0 in the decimal

00:33:11.440 --> 00:33:13.900
representation-- well,
the binary representation,

00:33:13.900 --> 00:33:15.610
I should say--

00:33:15.610 --> 00:33:20.770
for that string if it's not
there and a 1 if it is there.

00:33:24.450 --> 00:33:27.860
And so a real number--
because there's infinitely

00:33:27.860 --> 00:33:31.880
many yes/no choices in
the binary representation

00:33:31.880 --> 00:33:35.090
can represent a
language because of each

00:33:35.090 --> 00:33:38.240
of the yes/no choices of a
string being present or not.

00:33:38.240 --> 00:33:40.450
I'm going to put a 1 for
when the string is present,

00:33:40.450 --> 00:33:41.750
a 0 when it's not present.

00:33:41.750 --> 00:33:44.822
So each language has
its own real number,

00:33:44.822 --> 00:33:46.280
and each real number
is going to be

00:33:46.280 --> 00:33:48.500
associated to its own language.

00:33:48.500 --> 00:33:52.420
Here, I'm restricting myself to
real numbers between 0 and 1.

00:33:52.420 --> 00:33:54.170
That's not going to
be an essential point.

00:33:54.170 --> 00:33:55.880
So let's not get
hung up on that.

00:34:00.050 --> 00:34:10.679
So the fact that the
languages can be putting it

00:34:10.679 --> 00:34:14.429
into a one-to-one correspondence
with the real numbers

00:34:14.429 --> 00:34:19.230
shows that the collection of all
languages is also uncountable.

00:34:19.230 --> 00:34:21.900
Now another observation here--

00:34:21.900 --> 00:34:25.050
another point worth noting is
that if you look at sigma star

00:34:25.050 --> 00:34:30.460
itself, the strings,
all possible strings,

00:34:30.460 --> 00:34:32.880
that's a countable set.

00:34:32.880 --> 00:34:35.340
The collection of all possible
languages is uncountable.

00:34:35.340 --> 00:34:38.340
But the collection of all
possible finite strings

00:34:38.340 --> 00:34:41.270
is countable because
I can just list them.

00:34:41.270 --> 00:34:43.370
Here's my list of all
possible strings, which

00:34:43.370 --> 00:34:44.870
you can put into a
table if you like

00:34:44.870 --> 00:34:46.995
to think of it matching up
with the natural numbers

00:34:46.995 --> 00:34:49.600
in that way.

00:34:49.600 --> 00:34:52.010
Now I'm trying to
make a point here,

00:34:52.010 --> 00:34:55.630
which is that if you take M,
which is all possible Turing

00:34:55.630 --> 00:34:58.030
machines-- script M
is all possible Turing

00:34:58.030 --> 00:35:00.850
machines-- the collection of
all possible Turing machines

00:35:00.850 --> 00:35:02.370
is countable.

00:35:02.370 --> 00:35:06.510
There are only countably many
different Turing machines.

00:35:06.510 --> 00:35:09.217
And you can argue that in all
sorts of messy different ways.

00:35:09.217 --> 00:35:10.800
But I think the most
simple way to see

00:35:10.800 --> 00:35:14.100
that is to think about
each Turing machine

00:35:14.100 --> 00:35:19.230
as having a description,
which is a string.

00:35:19.230 --> 00:35:22.530
So the collection of all
descriptions of Turing machines

00:35:22.530 --> 00:35:25.440
is just a subset of sigma
star, which we already

00:35:25.440 --> 00:35:26.730
know is countable.

00:35:26.730 --> 00:35:32.210
And the subset of any countable
set is going to be countable.

00:35:32.210 --> 00:35:41.250
So anyway, I think
it's worth remembering

00:35:41.250 --> 00:35:46.890
that the collection of old
Turing machines is countable.

00:35:46.890 --> 00:35:49.290
Whereas the collection of
all languages is uncountable.

00:35:49.290 --> 00:35:52.890
And that tells you right there
that some language is not

00:35:52.890 --> 00:35:59.830
decided because there are more
languages than Turing machines.

00:35:59.830 --> 00:36:02.100
We've unaccountably
many language, only

00:36:02.100 --> 00:36:05.470
countably many Turing machines,
so that's fewer Turing machines

00:36:05.470 --> 00:36:06.490
than languages.

00:36:06.490 --> 00:36:09.398
There's no way to map all the
languages onto Turing machines.

00:36:09.398 --> 00:36:11.440
So there's going to always
be some languages that

00:36:11.440 --> 00:36:13.330
got unmapped.

00:36:13.330 --> 00:36:15.318
And so, in particular,
there are going

00:36:15.318 --> 00:36:17.110
to be some languages
which are undecidable.

00:36:17.110 --> 00:36:18.860
There are going to be
some languages which

00:36:18.860 --> 00:36:20.080
are not Turing-recognizable.

00:36:20.080 --> 00:36:25.450
And anything based on some
automata kind of a definition

00:36:25.450 --> 00:36:28.727
process is going to be some
languages that they're not

00:36:28.727 --> 00:36:29.560
going to be defined.

00:36:32.160 --> 00:36:34.740
OK, now what this
corollary shows you

00:36:34.740 --> 00:36:37.950
that there is some language out
there, which is not decidable.

00:36:37.950 --> 00:36:40.200
What we're going to
show next is that there

00:36:40.200 --> 00:36:41.610
is a specific language--

00:36:41.610 --> 00:36:44.690
A,TM-- which is not decidable.

00:36:44.690 --> 00:36:47.930
And but first, I think we
have a check-in coming up.

00:36:47.930 --> 00:36:50.573
And let me give you a
little bit of background

00:36:50.573 --> 00:36:52.490
here because this is
relevant to this question

00:36:52.490 --> 00:36:55.550
that I got about
intermediate size sets.

00:36:55.550 --> 00:36:58.100
So the question of
whether there is

00:36:58.100 --> 00:37:01.370
a set of size between
the natural numbers

00:37:01.370 --> 00:37:04.580
and the real numbers
strictly in between--

00:37:04.580 --> 00:37:07.100
so bigger than the natural
numbers, not the same size

00:37:07.100 --> 00:37:09.320
as the natural numbers,
but not the same size

00:37:09.320 --> 00:37:14.990
as the real numbers either,
but in between in size.

00:37:14.990 --> 00:37:18.500
That was Hilbert's question
number 1 out of his list of 23

00:37:18.500 --> 00:37:21.777
that I talked about
a few lectures back.

00:37:21.777 --> 00:37:24.110
It's interesting that he put
it as number 1 in that very

00:37:24.110 --> 00:37:28.970
privileged special place because
I know Hilbert was very--

00:37:28.970 --> 00:37:30.920
he felt that the
understanding infinity

00:37:30.920 --> 00:37:33.168
was a really central
issue in mathematics.

00:37:33.168 --> 00:37:35.210
And that if we can't answer
a question like this,

00:37:35.210 --> 00:37:38.408
we don't really
understand infinity.

00:37:38.408 --> 00:37:40.700
You want to understand what
kind of sizes of infinities

00:37:40.700 --> 00:37:41.452
are there.

00:37:41.452 --> 00:37:43.160
We know there's the
real number is bigger

00:37:43.160 --> 00:37:44.960
than the natural numbers.

00:37:44.960 --> 00:37:46.340
Is there something in between?

00:37:46.340 --> 00:37:48.800
So fundamental, really.

00:37:48.800 --> 00:37:52.250
But it was shown during the
course of the 20th century,

00:37:52.250 --> 00:37:54.980
really, in two separate steps--
one in the 1930s by Godel,

00:37:54.980 --> 00:37:57.740
one in the early
1970s by Cohen--

00:37:57.740 --> 00:37:59.840
that we can't
answer this question

00:37:59.840 --> 00:38:04.440
by using the standard
axioms of mathematics.

00:38:04.440 --> 00:38:07.750
The answer can go either way.

00:38:07.750 --> 00:38:11.320
And both of them are consistent
with the axes mathematics.

00:38:11.320 --> 00:38:13.260
So you're never going
to be able to prove

00:38:13.260 --> 00:38:18.660
that there is a set
whose size is in between

00:38:18.660 --> 00:38:20.340
or that there is no such set.

00:38:20.340 --> 00:38:23.885
It's just impossible to
prove either way using

00:38:23.885 --> 00:38:26.010
the standard axiom of
mathematics, which, actually,

00:38:26.010 --> 00:38:29.147
is kind of remarkable.

00:38:29.147 --> 00:38:31.230
And so my question for you
is-- and this is really

00:38:31.230 --> 00:38:35.300
a philosophical question,
not one that is directly you

00:38:35.300 --> 00:38:37.050
need to know about
material in the course.

00:38:37.050 --> 00:38:39.538
I think it's just a matter
of your own interest.

00:38:39.538 --> 00:38:40.830
I hope you find it interesting.

00:38:40.830 --> 00:38:44.790
If you don't, you can
just answer it randomly.

00:38:44.790 --> 00:38:50.260
But what's going on here
that we can't answer

00:38:50.260 --> 00:38:52.150
that question
about whether there

00:38:52.150 --> 00:38:54.040
is a set of intermediate size?

00:38:54.040 --> 00:38:57.970
Is it because our axioms for
mathematics are inadequate?

00:38:57.970 --> 00:39:02.470
Or maybe there is no such thing
as a mathematical reality.

00:39:02.470 --> 00:39:05.420
You can talk about
what's real here?

00:39:05.420 --> 00:39:07.120
What's the reality?

00:39:07.120 --> 00:39:09.905
Either there is a set
in between or not.

00:39:09.905 --> 00:39:11.530
If you can imagine,
all of these things

00:39:11.530 --> 00:39:14.200
have their own reality
to them, well, then,

00:39:14.200 --> 00:39:15.467
there's going to be an answer.

00:39:15.467 --> 00:39:17.050
And then you would
expect, well, maybe

00:39:17.050 --> 00:39:18.967
we can find better axioms,
which will actually

00:39:18.967 --> 00:39:19.840
give us that answer.

00:39:19.840 --> 00:39:22.540
Or you can say, well,
there is no reality.

00:39:22.540 --> 00:39:27.220
And infinite sets are
kind of human constructs

00:39:27.220 --> 00:39:30.130
anyway, so we can make them kind
of play out any way we like.

00:39:30.130 --> 00:39:34.570
Mathematicians argue
about that to this day.

00:39:34.570 --> 00:39:38.290
And it is, as I say, really,
it's a philosophical question.

00:39:38.290 --> 00:39:42.160
But just out of curiosity,
let's see how you guys end up

00:39:42.160 --> 00:39:44.270
deciding on that one.

00:39:44.270 --> 00:39:46.310
So here is the poll.

00:39:46.310 --> 00:39:47.450
5 seconds to go.

00:39:47.450 --> 00:39:48.930
Please vote.

00:39:48.930 --> 00:39:52.370
And we're going to end
the polling, 1, 2, 3, now.

00:39:55.200 --> 00:39:57.070
All right, here we go.

00:39:57.070 --> 00:40:00.220
So there's no right answer.

00:40:00.220 --> 00:40:05.220
I think if most mathematicians
were to, I think,

00:40:05.220 --> 00:40:07.830
the instinct of most
logicians, especially, I'm

00:40:07.830 --> 00:40:10.230
not sure if general
mathematicians really even care

00:40:10.230 --> 00:40:13.500
about this question, but
logicians would probably

00:40:13.500 --> 00:40:17.050
have an instinct that, probably,
there are sets in between.

00:40:17.050 --> 00:40:20.070
There's no reason that
there shouldn't be.

00:40:20.070 --> 00:40:21.840
It seems kind of
strange that there

00:40:21.840 --> 00:40:26.280
should be this sort of jump
from the natural numbers

00:40:26.280 --> 00:40:31.090
to the real numbers and
why nothing in between?

00:40:31.090 --> 00:40:36.595
But I don't think that
question is really settled.

00:40:39.962 --> 00:40:41.170
All right, let's continue on.

00:40:41.170 --> 00:40:43.630
I think we are--

00:40:43.630 --> 00:40:44.710
OK, so we're going to--

00:40:47.872 --> 00:40:50.080
our coffee break is coming,
in case you're wondering.

00:40:50.080 --> 00:40:51.790
So this is my last
slide before then.

00:40:51.790 --> 00:40:57.880
But this is an important
slide, so please hold out.

00:40:57.880 --> 00:41:02.170
So here is our promised
theorem of the day.

00:41:02.170 --> 00:41:04.510
I'm going to show that
A,TM is not decidable,

00:41:04.510 --> 00:41:07.280
the acceptance problem
for Turing machines.

00:41:07.280 --> 00:41:10.157
And it's all going to be
contained on this one slide.

00:41:10.157 --> 00:41:11.990
We're going to give a
proof by contradiction

00:41:11.990 --> 00:41:14.990
using diagonalization.

00:41:14.990 --> 00:41:18.620
And we're going to assume
some Turing machine, H,

00:41:18.620 --> 00:41:21.360
decides A,TM.

00:41:21.360 --> 00:41:24.300
And we're going to
get a contradiction.

00:41:24.300 --> 00:41:25.800
So let's, first of
all, make sure we

00:41:25.800 --> 00:41:28.900
understand what H is doing.

00:41:28.900 --> 00:41:30.340
So H gets an input--

00:41:30.340 --> 00:41:33.910
a Turing machine and an input.

00:41:33.910 --> 00:41:37.180
And H is going to be a
decider, so it always

00:41:37.180 --> 00:41:40.830
halts with an
accept or a reject.

00:41:40.830 --> 00:41:45.830
It's supposed to accept if
M accepts w and reject if it

00:41:45.830 --> 00:41:46.740
doesn't.

00:41:46.740 --> 00:41:48.620
So in other words,
it's going to reject

00:41:48.620 --> 00:41:53.330
if M rejects w either by
halting or by looping.

00:41:56.340 --> 00:42:02.530
That's the job of H. And
we're assuming we can do that.

00:42:02.530 --> 00:42:04.140
But we will see a
contradiction occur.

00:42:06.900 --> 00:42:11.450
So the way we're going to do
that is really kind of just one

00:42:11.450 --> 00:42:13.220
step here in a way.

00:42:13.220 --> 00:42:16.910
And we're going to use H
to construct another Turing

00:42:16.910 --> 00:42:20.840
machine D. H is going to be a
subroutine to D. We've already

00:42:20.840 --> 00:42:22.490
seen us doing that in the past.

00:42:25.170 --> 00:42:27.830
D is going to do something
a little strange,

00:42:27.830 --> 00:42:31.050
just to warn you.

00:42:31.050 --> 00:42:33.350
D's input is just
a Turing machine--

00:42:33.350 --> 00:42:36.170
no w.

00:42:36.170 --> 00:42:41.630
And what D is going to
do using its subroutine

00:42:41.630 --> 00:42:48.220
H is going to simulate H on
input M, comma, the description

00:42:48.220 --> 00:42:51.860
of M. Now what is that?

00:42:51.860 --> 00:42:55.310
Well, the description of
M is just some string.

00:42:55.310 --> 00:42:56.920
So what H is trying--

00:42:56.920 --> 00:43:01.000
what it's asking H to
tell, to answer is,

00:43:01.000 --> 00:43:07.010
does M accept the
string representing

00:43:07.010 --> 00:43:10.560
M's own description?

00:43:10.560 --> 00:43:14.140
It's as if we're
feeding M into itself,

00:43:14.140 --> 00:43:20.810
which seems like a totally
twisted thing to do,

00:43:20.810 --> 00:43:21.520
you might say.

00:43:25.120 --> 00:43:27.760
Why would you ever feed
a program into itself?

00:43:30.370 --> 00:43:32.710
Somebody has written
cannibalism here--

00:43:32.710 --> 00:43:34.480
yeah, kind of.

00:43:34.480 --> 00:43:38.050
I'd say it's worse
[LAUGHS] because it's not

00:43:38.050 --> 00:43:39.010
eating somebody else.

00:43:39.010 --> 00:43:41.900
It's eating yourself.

00:43:41.900 --> 00:43:49.760
OK, but I claim that there are
actual cases in practice where

00:43:49.760 --> 00:43:51.940
we do this.

00:43:51.940 --> 00:43:56.500
We feed programs
into themselves.

00:43:56.500 --> 00:44:00.700
And the example that I
know of where this is done

00:44:00.700 --> 00:44:04.030
is when you're
making a compiler.

00:44:04.030 --> 00:44:06.010
You might want to
make a compiler

00:44:06.010 --> 00:44:09.280
and then written in the same
language that it's compiling.

00:44:09.280 --> 00:44:12.940
And then you feed the
compiler into itself.

00:44:12.940 --> 00:44:15.370
You may say, why even
bother because it's already,

00:44:15.370 --> 00:44:17.000
obviously, if it,
once it's running,

00:44:17.000 --> 00:44:21.840
you don't need to
compile it again.

00:44:21.840 --> 00:44:25.260
But actually, an example
where this was really used

00:44:25.260 --> 00:44:27.960
was when there was an
optimizing compiler, I think,

00:44:27.960 --> 00:44:31.940
for C written on
early Unix machines.

00:44:31.940 --> 00:44:37.020
And the optimizing compiler
for C was written in C.

00:44:37.020 --> 00:44:41.280
So you would feed the
optimizing compiler

00:44:41.280 --> 00:44:43.950
into the regular
compiler, first of all.

00:44:43.950 --> 00:44:48.970
Now, you had the
compiler running,

00:44:48.970 --> 00:44:51.340
but it was an optimized.

00:44:51.340 --> 00:44:54.460
So but now that it's the
optimizing compiler is running,

00:44:54.460 --> 00:44:56.290
you can feed the
optimizing compiler

00:44:56.290 --> 00:44:58.040
into that, which is itself.

00:44:58.040 --> 00:45:01.290
Now you have an optimized
optimizing compiler.

00:45:01.290 --> 00:45:03.360
So it really makes some--

00:45:03.360 --> 00:45:06.330
there is at least one case
where this has actually

00:45:06.330 --> 00:45:09.620
been done in practice.

00:45:09.620 --> 00:45:10.730
Not that we really care.

00:45:10.730 --> 00:45:14.900
This is a theory class-- but
just for fun to observe that.

00:45:14.900 --> 00:45:18.880
So here, H is trying to
say, well, does in a M end

00:45:18.880 --> 00:45:23.167
up accepting when it's fed
the description of itself?

00:45:23.167 --> 00:45:25.000
You know, at least,
mathematically speaking,

00:45:25.000 --> 00:45:27.610
that's a reasonable
thing to ask.

00:45:27.610 --> 00:45:31.330
And then what D is going to do
when it gets the answer back

00:45:31.330 --> 00:45:32.440
from H--

00:45:32.440 --> 00:45:34.240
H is a decider, don't forget--

00:45:34.240 --> 00:45:36.980
is D's going to do the
opposite of whatever H does.

00:45:36.980 --> 00:45:38.470
It's going to
accept if H rejects

00:45:38.470 --> 00:45:42.030
and reject if H accepts.

00:45:42.030 --> 00:45:45.050
So let's, in summary,
let's pull this together,

00:45:45.050 --> 00:45:51.230
so it's easy to understand,
in the end, what is D doing?

00:45:51.230 --> 00:45:53.240
D is going to accept.

00:45:53.240 --> 00:45:55.010
D is also going to be
decider, by the way.

00:45:55.010 --> 00:45:57.750
So D is always going to
either accept or reject--

00:45:57.750 --> 00:45:58.250
Just.

00:45:58.250 --> 00:46:00.150
The opposite of what
H tells it to do.

00:46:00.150 --> 00:46:06.360
So D is going to accept M
exactly when M doesn't accept M

00:46:06.360 --> 00:46:12.430
because when M doesn't accept
M, H is going to reject,

00:46:12.430 --> 00:46:14.350
and so then D is
going to accept.

00:46:14.350 --> 00:46:17.490
So D accepts M if and
only if M doesn't accept

00:46:17.490 --> 00:46:20.130
M. That's exactly the
condition in which D accepts

00:46:20.130 --> 00:46:24.250
M. I think it's important to
just step back and make sure

00:46:24.250 --> 00:46:26.680
you understand this line
because we have only one line

00:46:26.680 --> 00:46:31.660
left to get our contradiction.

00:46:31.660 --> 00:46:32.160
Right?

00:46:32.160 --> 00:46:32.850
Are we together?

00:46:32.850 --> 00:46:35.070
D accepts M if and
only if M doesn't

00:46:35.070 --> 00:46:38.770
accept M. That's just by the
way we've defined setup D.

00:46:38.770 --> 00:46:43.790
Now what we're going to do is
feed in, instead of M to D,

00:46:43.790 --> 00:46:46.900
and not some arbitrary feed,
we're going to use feed in D

00:46:46.900 --> 00:46:50.760
into D. And that is going
to be our contradiction

00:46:50.760 --> 00:46:53.250
because D is now
going to accept D if

00:46:53.250 --> 00:46:55.260
and only if D doesn't
accept D, and that's

00:46:55.260 --> 00:46:56.675
certainly impossible.

00:46:59.520 --> 00:47:03.450
That's our contradiction which
proves that H cannot exist.

00:47:03.450 --> 00:47:07.270
And therefore, A,TM
is undecidable.

00:47:07.270 --> 00:47:10.060
OK, so we're done,
except for the one

00:47:10.060 --> 00:47:16.090
point, which is that why
is this a diagonalization?

00:47:16.090 --> 00:47:20.800
And I think you can get that
from the following picture.

00:47:20.800 --> 00:47:24.280
If you imagine here writing
down all possible times--

00:47:24.280 --> 00:47:25.610
I'm going to make a table here.

00:47:25.610 --> 00:47:30.490
Here is the list of
all Turing machines,

00:47:30.490 --> 00:47:32.860
including D, which
is a machine which

00:47:32.860 --> 00:47:38.320
I built under the
assumption that H exists.

00:47:38.320 --> 00:47:39.790
So D appears here somewhere.

00:47:39.790 --> 00:47:41.590
But here are all the
other Turing machines.

00:47:41.590 --> 00:47:43.757
And here are all of these
descriptions of the Turing

00:47:43.757 --> 00:47:47.860
machines along the labeling
all of the columns.

00:47:47.860 --> 00:47:49.390
OK, so these are
the rows labeled.

00:47:49.390 --> 00:47:50.710
These are the column labels.

00:47:50.710 --> 00:47:54.100
And inside, I'm
going to tell you

00:47:54.100 --> 00:48:01.120
the answer for whether a given
machine accepts a given input.

00:48:01.120 --> 00:48:04.630
So for example, M1 accepts
its own description

00:48:04.630 --> 00:48:07.000
but rejects the
description of M2,

00:48:07.000 --> 00:48:08.920
but accepts the
description of M3.

00:48:08.920 --> 00:48:09.760
I don't you know.

00:48:09.760 --> 00:48:10.960
I'm obviously I'm
making this up.

00:48:10.960 --> 00:48:11.960
I don't know what M1 is.

00:48:11.960 --> 00:48:16.112
But just hypothetically, that's
what the machine M1 does.

00:48:16.112 --> 00:48:17.570
So I'm just filling
out this table.

00:48:21.632 --> 00:48:24.500
H could get the answer to any
of the elements in this table

00:48:24.500 --> 00:48:30.440
because it can test whether M4
accepts the description of M3.

00:48:30.440 --> 00:48:33.020
So H could fill out this table.

00:48:33.020 --> 00:48:35.720
So maybe M2 is a machine
that always rejects.

00:48:35.720 --> 00:48:38.570
It's a very unfriendly,
rejecting machine.

00:48:38.570 --> 00:48:40.050
M3 is a very friendly machine.

00:48:40.050 --> 00:48:41.900
It accepts all inputs.

00:48:41.900 --> 00:48:46.395
M4 rejects some and accepts
others, dot, dot, dot.

00:48:46.395 --> 00:48:51.110
Now, I want to look and
see, what does D do?

00:48:51.110 --> 00:48:53.840
Now based on the information
that I've already given you,

00:48:53.840 --> 00:48:57.240
we can understand what D does.

00:48:57.240 --> 00:48:59.430
So for example, what
does D do when I

00:48:59.430 --> 00:49:03.940
feed it the description of M1?

00:49:03.940 --> 00:49:05.600
What does D do?

00:49:05.600 --> 00:49:06.610
Well, we can look here.

00:49:06.610 --> 00:49:10.210
D accepts M if and only
if M doesn't accept M. So

00:49:10.210 --> 00:49:18.090
D is going to accept M1 if and
only if M1 does not accept M1.

00:49:18.090 --> 00:49:20.490
Well, M1 does accept M1.

00:49:20.490 --> 00:49:22.980
So D does the opposite.

00:49:22.980 --> 00:49:24.240
D rejects.

00:49:24.240 --> 00:49:26.250
So OK, I'm highlighting here.

00:49:26.250 --> 00:49:29.250
D rejects because
D is going to do

00:49:29.250 --> 00:49:32.790
the opposite of what the machine
does on its own it on input.

00:49:35.370 --> 00:49:39.150
So D on M2, you have to
look what M2 does on M2.

00:49:39.150 --> 00:49:41.560
It rejects, so D does
the opposite of that.

00:49:41.560 --> 00:49:43.220
It accepts.

00:49:43.220 --> 00:49:49.100
And similarly, each
one of these things--

00:49:49.100 --> 00:49:52.060
D's answer is going to
be the opposite of what

00:49:52.060 --> 00:49:54.820
the machine does on
its own description,

00:49:54.820 --> 00:50:00.050
just by virtue of the
definition of D. OK, and so on--

00:50:00.050 --> 00:50:01.540
so far, so good.

00:50:01.540 --> 00:50:06.400
But the problem is, what
happens when D is fed itself?

00:50:06.400 --> 00:50:11.590
Because, as you can see,
we're heading for trouble

00:50:11.590 --> 00:50:13.990
because this is a
diagonal down here.

00:50:13.990 --> 00:50:15.340
D is just one of the rows.

00:50:15.340 --> 00:50:17.890
That diagonal is going
to intersect that row

00:50:17.890 --> 00:50:19.300
at this point.

00:50:19.300 --> 00:50:22.772
And D is defined to be going to
be doing the opposite of what

00:50:22.772 --> 00:50:25.105
that element is, but it can't
be the opposite of itself.

00:50:27.980 --> 00:50:31.300
And so that's the contradiction.

00:50:31.300 --> 00:50:34.740
So I think we're--

00:50:34.740 --> 00:50:39.190
I'm going to call us, give
us a little break here.

00:50:39.190 --> 00:50:41.200
And then you can also
text me in the meantime.

00:50:41.200 --> 00:50:43.860
I'll be happy to answer
some questions during that.

00:50:43.860 --> 00:50:46.170
A little over 4 minutes
to go-- so let's see.

00:50:46.170 --> 00:50:49.770
Let me see if I can
answer your questions.

00:50:49.770 --> 00:50:52.810
OK, what's so special about
A,TM that enables us to do this?

00:50:52.810 --> 00:50:57.020
Why can't we do this
on ADFA, for example?

00:50:57.020 --> 00:50:59.490
That's a good question.

00:50:59.490 --> 00:51:14.890
And the answer is that, in a
sense, we can do this on DFA.

00:51:14.890 --> 00:51:17.920
I mean, I think this is,
perhaps, a bit of a stretch.

00:51:17.920 --> 00:51:22.360
But DFAs could not answer ADFA.

00:51:22.360 --> 00:51:26.698
I mean, we could prove that in
other ways as well by just--

00:51:26.698 --> 00:51:28.490
we could use things
like the pumping lemma,

00:51:28.490 --> 00:51:31.210
and it's not clear, even
how you'd formulate ADFA.

00:51:31.210 --> 00:51:36.940
But what's important
here is that it's really

00:51:36.940 --> 00:51:40.270
the model talking about
itself that really

00:51:40.270 --> 00:51:42.710
is where the problem comes up.

00:51:42.710 --> 00:51:45.490
So if you try to push
this argument through

00:51:45.490 --> 00:51:49.390
to show that ADFA is not
decidable by Turing machines,

00:51:49.390 --> 00:51:54.690
you're going to fail
because we're starting off

00:51:54.690 --> 00:51:56.130
with a Turing machine.

00:51:56.130 --> 00:52:00.060
And I think I'm going
to confuse myself

00:52:00.060 --> 00:52:01.570
if I try to just repeat it.

00:52:01.570 --> 00:52:04.350
But you won't get
a contradiction

00:52:04.350 --> 00:52:07.108
because the Turing machine
is not a finite automaton.

00:52:10.245 --> 00:52:10.745
OK.

00:52:13.870 --> 00:52:15.880
Will this argument
get into self-loops?

00:52:15.880 --> 00:52:19.060
I don't see why it would--
there is some self-reference,

00:52:19.060 --> 00:52:19.693
perhaps.

00:52:19.693 --> 00:52:21.610
We're going to talk about
that a little later.

00:52:21.610 --> 00:52:26.800
So we're going to come back and
revisit this argument in a week

00:52:26.800 --> 00:52:29.170
or so when we talk about
the recursion theorem which

00:52:29.170 --> 00:52:32.740
talks about machines that
can refer to themselves.

00:52:32.740 --> 00:52:35.375
But this is a little
bit of a head--

00:52:35.375 --> 00:52:36.500
getting ahead of ourselves.

00:52:36.500 --> 00:52:40.510
So somebody's commenting
on this reminding them

00:52:40.510 --> 00:52:43.150
of the barber paradox,
if you remember that,

00:52:43.150 --> 00:52:48.122
which has some similarity.

00:52:48.122 --> 00:52:50.880
There is a town
in which there was

00:52:50.880 --> 00:52:54.580
a barber which shaves every man
who doesn't shave themselves.

00:52:54.580 --> 00:52:56.370
It seems he's a
very good barber.

00:52:56.370 --> 00:52:58.710
So there are some people
who shave themselves.

00:52:58.710 --> 00:53:01.950
And all the rest,
the barber shaves.

00:53:01.950 --> 00:53:04.560
The question is, does
the barber shave himself?

00:53:04.560 --> 00:53:07.650
Because he shaves only those
men who don't shave themselves.

00:53:07.650 --> 00:53:09.890
So you've got a same
kind of a contradiction.

00:53:09.890 --> 00:53:11.580
There is a relationship there.

00:53:14.560 --> 00:53:17.400
So someone wants to know, where
did we use the decidability?

00:53:17.400 --> 00:53:23.210
So we used the decidability
to come up with H.

00:53:23.210 --> 00:53:25.220
Once we know that
A,TM is decidable,

00:53:25.220 --> 00:53:29.600
then we have that H function,
and then we can build D.

00:53:29.600 --> 00:53:35.550
So that's the chain of reason.

00:53:35.550 --> 00:53:37.370
So you assume A,TM is decidable.

00:53:37.370 --> 00:53:40.580
Then you have the
decider called H,

00:53:40.580 --> 00:53:44.250
and then you can build
D. Somebody wants

00:53:44.250 --> 00:53:47.350
to see the previous slide.

00:53:47.350 --> 00:53:49.150
What part of the
slide do you want?

00:53:52.880 --> 00:53:55.228
So I'll leave that up there.

00:53:55.228 --> 00:53:57.520
Why can we apply the proof
that all Turing machines are

00:53:57.520 --> 00:53:59.020
accountable to all languages?

00:53:59.020 --> 00:54:02.200
Well, because Turing
machines have descriptions.

00:54:02.200 --> 00:54:04.840
General languages don't
have descriptions.

00:54:04.840 --> 00:54:06.640
And so that's why.

00:54:06.640 --> 00:54:09.850
OK, the candle has
burnt to the bottom,

00:54:09.850 --> 00:54:11.470
and it's time to move on.

00:54:14.200 --> 00:54:17.370
So now, let's look at
the acceptance problem

00:54:17.370 --> 00:54:20.380
for queue automata.

00:54:20.380 --> 00:54:24.040
I'll give you a queue automaton
on input, and I want to know,

00:54:24.040 --> 00:54:25.450
does it accept the input?

00:54:25.450 --> 00:54:27.970
Is that going to be decidable?

00:54:27.970 --> 00:54:29.095
And you have your choices.

00:54:29.095 --> 00:54:32.830
It's either yes, it is
decidable because these

00:54:32.830 --> 00:54:35.200
are similar to pushdown
automata and APDA is decidable,

00:54:35.200 --> 00:54:40.730
or no because yes
contradicts results

00:54:40.730 --> 00:54:42.560
that we know at
this point, or we

00:54:42.560 --> 00:54:45.320
don't have enough information
to answer the question.

00:54:45.320 --> 00:54:46.520
OK, let's put that up.

00:54:49.100 --> 00:54:55.120
One second-- [LAUGHS]
all right, that's it.

00:54:55.120 --> 00:54:56.110
Ready, going, gone.

00:55:00.180 --> 00:55:04.260
So yes, the answer is, well, no.

00:55:04.260 --> 00:55:06.900
[LAUGHS] The answer
is, indeed, the answer

00:55:06.900 --> 00:55:12.563
is B. True, that
queue automata are

00:55:12.563 --> 00:55:14.730
similar to pushdown automata,
but all these automata

00:55:14.730 --> 00:55:16.740
are similar to each
other, and that's not

00:55:16.740 --> 00:55:17.740
going to be good enough.

00:55:20.670 --> 00:55:22.550
What the homework
has asked you to do

00:55:22.550 --> 00:55:24.260
is to show that you
can simulate Turing

00:55:24.260 --> 00:55:26.330
machines with queue automata.

00:55:26.330 --> 00:55:27.800
So if you can
answer the question

00:55:27.800 --> 00:55:31.310
about whether the queue automata
will accept their input,

00:55:31.310 --> 00:55:33.470
that would allow you to be
able to answer questions

00:55:33.470 --> 00:55:35.810
about whether Turing
machines accept their input.

00:55:35.810 --> 00:55:38.720
And we just proved
that's not possible.

00:55:38.720 --> 00:55:47.120
So it would be a contradiction
if we could answer--

00:55:47.120 --> 00:55:50.480
if we could decide A, queue, A.

00:55:50.480 --> 00:55:52.820
Now, we have an example of
an undecidable language.

00:55:52.820 --> 00:55:56.210
Let's look at an example of
an unrecognizable language.

00:55:56.210 --> 00:56:08.560
Now A,TM is not going to serve
that purpose because A,TM is

00:56:08.560 --> 00:56:10.900
Turing-recognizable, as we
pointed out by the universal

00:56:10.900 --> 00:56:12.470
Turing machine.

00:56:12.470 --> 00:56:15.340
So A,TM is undecidable, however.

00:56:15.340 --> 00:56:18.520
How about an
unrecognizable language?

00:56:18.520 --> 00:56:24.020
For that, we will see that the
complement of A,TM will serve.

00:56:24.020 --> 00:56:28.630
So the complement of A,TM is
neither decidable nor even

00:56:28.630 --> 00:56:30.700
recognizable.

00:56:30.700 --> 00:56:32.830
Now it's not
Turing-recognizable.

00:56:32.830 --> 00:56:35.830
And that's going to follow from
a pretty basic theorem that

00:56:35.830 --> 00:56:39.130
connects recognizability and
decidability that I've put up

00:56:39.130 --> 00:56:41.620
here on the screen,
which is that if you have

00:56:41.620 --> 00:56:44.170
a language where it
and its complement

00:56:44.170 --> 00:56:47.470
are both recognizable, then
the language turnout turns out

00:56:47.470 --> 00:56:48.220
to be decidable.

00:56:48.220 --> 00:56:50.460
In fact, a language and its
complement are decidable.

00:56:50.460 --> 00:56:53.020
But being decidable is
closed under complement,

00:56:53.020 --> 00:56:56.220
so that's something
you should be aware.

00:56:56.220 --> 00:56:59.720
But being-- OK.

00:56:59.720 --> 00:57:00.970
We'll get to that in a minute.

00:57:00.970 --> 00:57:07.600
But if-- so anyway, so
if you have a language

00:57:07.600 --> 00:57:09.550
and it's complement
both recognizable,

00:57:09.550 --> 00:57:12.460
how do we know the
language is decidable?

00:57:12.460 --> 00:57:14.890
So first of all, let's take
the two Turing machines,

00:57:14.890 --> 00:57:20.380
M1 and M2 that recognizes
A and A-complement.

00:57:20.380 --> 00:57:22.270
And we're going to
put those together

00:57:22.270 --> 00:57:28.580
to get a decider for A. And
that's going to work like this.

00:57:28.580 --> 00:57:31.740
It's going to be
called T. So T says,

00:57:31.740 --> 00:57:34.020
on input w, what
it's going to do,

00:57:34.020 --> 00:57:37.380
it's going to feed w
into M1 and M2 both.

00:57:40.582 --> 00:57:42.040
A is the language,
by the way, yes.

00:57:42.040 --> 00:57:45.280
A is-- when I say it's
Turing-recognizable,

00:57:45.280 --> 00:57:48.190
you know, Turing-recognizable
only applies to languages.

00:57:48.190 --> 00:57:52.300
So yes, A is often this symbol
I'm going to use for languages,

00:57:52.300 --> 00:57:53.650
sometimes for an automaton.

00:57:53.650 --> 00:57:57.530
But A is typically
going to be a language.

00:57:57.530 --> 00:58:06.978
So now, I'm trying to
make T be a decider for A

00:58:06.978 --> 00:58:10.230
from the recognizers
for A and A-complement.

00:58:10.230 --> 00:58:13.920
So I'm going to
take an input to T

00:58:13.920 --> 00:58:17.165
and feed it into both
recognizers, M1 and M2.

00:58:20.960 --> 00:58:24.230
OK, I'm going to run
them in parallel.

00:58:24.230 --> 00:58:31.940
What's nice is that
because M2 recognizes

00:58:31.940 --> 00:58:34.700
the complement of
what M1 recognizes,

00:58:34.700 --> 00:58:40.070
every string is going to be
accepted either by M1 or by M2

00:58:40.070 --> 00:58:43.880
because every string is either
an A or an A-complement.

00:58:43.880 --> 00:58:48.790
So if I run M1 and M2 on w until
one of the halts or one of them

00:58:48.790 --> 00:58:51.400
accepts, I know I'm not
going to run forever

00:58:51.400 --> 00:58:55.860
because, eventually, one or
the other one have to accept.

00:58:55.860 --> 00:58:58.607
So and then I got my answer
because if M1 accepts,

00:58:58.607 --> 00:58:59.940
then I know I'm in the language.

00:58:59.940 --> 00:59:03.300
But if M2 accepts, I know I'm in
the complement of the language,

00:59:03.300 --> 00:59:04.720
so I'm out of the language.

00:59:04.720 --> 00:59:07.140
So if M1 accepts,
then T should accept.

00:59:07.140 --> 00:59:14.640
But if M2 accepts,
then T should reject. ,

00:59:14.640 --> 00:59:20.340
So that proves that nice little
theorem written at the top

00:59:20.340 --> 00:59:22.580
in blue.

00:59:22.580 --> 00:59:25.630
So I got my decider
for A built out

00:59:25.630 --> 00:59:28.900
of the recognizers for
A and A-complement.

00:59:28.900 --> 00:59:34.210
Now immediately, it follows that
the complement of A,TM is not

00:59:34.210 --> 00:59:41.650
Turing-recognizable because
we know that A,TM itself is

00:59:41.650 --> 00:59:44.460
recognizable, but
it's undecidable.

00:59:47.410 --> 00:59:50.230
If the complement was
also recognizable,

00:59:50.230 --> 00:59:54.250
then A,TM would be
decidable, but it isn't.

00:59:54.250 --> 00:59:58.240
So when something is decidable,
either it or its complement

00:59:58.240 --> 00:59:59.683
have to be unrecognizable.

00:59:59.683 --> 01:00:02.350
And in the case for A,TM, it has
to be the complement because we

01:00:02.350 --> 01:00:05.530
already showed that it is
itself is recognizable.

01:00:09.130 --> 01:00:10.610
So that's the proof of that.

01:00:10.610 --> 01:00:12.340
So here is a little
picture of the way

01:00:12.340 --> 01:00:14.890
the world looks right now if
you have here, in the middle are

01:00:14.890 --> 01:00:17.230
the decidable languages--
so these are all

01:00:17.230 --> 01:00:19.810
languages, this Venn
diagram of languages.

01:00:19.810 --> 01:00:23.740
We showed earlier, the regular,
the context-free, decidable,

01:00:23.740 --> 01:00:26.080
recognizable.

01:00:26.080 --> 01:00:29.170
Here, I've got the recognizable
and what I'm calling

01:00:29.170 --> 01:00:33.290
the co-Turing recognizable.

01:00:33.290 --> 01:00:36.350
This is the collection
of all complements

01:00:36.350 --> 01:00:37.940
of recognizable languages.

01:00:37.940 --> 01:00:41.540
So A,TM bar, A,TM
complement is the complement

01:00:41.540 --> 01:00:43.130
of a recognizable language.

01:00:43.130 --> 01:00:48.290
This region here are
all the complements

01:00:48.290 --> 01:00:53.030
of the recognizable languages
or the so-called co-Turing

01:00:53.030 --> 01:00:57.110
recognizable languages--
complement of.

01:00:57.110 --> 01:00:58.880
So A,TM is on this side.

01:00:58.880 --> 01:01:00.950
A,TM-complement is on that side.

01:01:00.950 --> 01:01:04.610
But if something's in both, by
virtue of this theorem here,

01:01:04.610 --> 01:01:05.925
then it's decidable.

01:01:08.600 --> 01:01:12.050
OK, last check-in for the day.

01:01:12.050 --> 01:01:15.950
From what we learned so far,
which closure properties

01:01:15.950 --> 01:01:18.200
can we prove for the
class of deterring

01:01:18.200 --> 01:01:20.720
recognizable languages?

01:01:20.720 --> 01:01:21.710
Choose all that apply.

01:01:24.730 --> 01:01:28.080
Well, as I say, you don't
have to get it right.

01:01:28.080 --> 01:01:30.250
Let's not spend too
much more time on this

01:01:30.250 --> 01:01:34.740
because we'll talk a
little bit about it.

01:01:34.740 --> 01:01:36.997
Almost all-- its closed
under almost all of them,

01:01:36.997 --> 01:01:37.830
but not all of them.

01:01:45.380 --> 01:01:49.190
Because-- are we done here?

01:01:49.190 --> 01:01:51.430
I think we're done--

01:01:51.430 --> 01:01:51.955
5 seconds.

01:01:54.700 --> 01:01:56.125
OK, here we go, ending polling.

01:02:00.160 --> 01:02:03.940
I'm not sure what the meaning
of [LAUGHS] deleting your answer

01:02:03.940 --> 01:02:05.320
is here.

01:02:05.320 --> 01:02:07.240
Everybody likes union, I guess.

01:02:07.240 --> 01:02:09.130
They're closed under
all of these operations

01:02:09.130 --> 01:02:10.490
except complement.

01:02:13.753 --> 01:02:15.920
But we just proved it's not
closed under complement,

01:02:15.920 --> 01:02:20.760
so I'm a little puzzled by
why we have so many votes

01:02:20.760 --> 01:02:23.490
for closure under complement.

01:02:23.490 --> 01:02:27.090
We have here, A,TM is
Turing-recognizable,

01:02:27.090 --> 01:02:29.055
but A,TM-complement is
not Turing-recognizable.

01:02:29.055 --> 01:02:32.270
it's right here on the slide.

01:02:32.270 --> 01:02:33.770
I'm not trying to
make you feel bad,

01:02:33.770 --> 01:02:41.820
but I'm trying to just point
out that you think, please.

01:02:41.820 --> 01:02:48.020
So now closure under union
and intersection, I mean,

01:02:48.020 --> 01:02:49.580
you could kind of
get those answers

01:02:49.580 --> 01:02:51.710
just by running things
in parallel the way

01:02:51.710 --> 01:02:52.880
we did the proof here.

01:02:52.880 --> 01:02:56.240
You just run both machines.

01:02:56.240 --> 01:03:02.043
And if they both give--

01:03:02.043 --> 01:03:03.710
I mean, it's a little
tricky, I suppose.

01:03:03.710 --> 01:03:08.770
If either one of them
accept, then you can accept.

01:03:08.770 --> 01:03:10.360
Or if they both
accept, you just wait

01:03:10.360 --> 01:03:11.610
until they both have accepted.

01:03:11.610 --> 01:03:13.460
Otherwise, you
just keep running.

01:03:13.460 --> 01:03:15.963
So the first two are
pretty straightforward.

01:03:15.963 --> 01:03:17.380
Closure under
concatenation-- this

01:03:17.380 --> 01:03:18.590
is also going to be similar.

01:03:18.590 --> 01:03:21.820
You just try every possible
way of cutting the string up

01:03:21.820 --> 01:03:24.440
into two pieces and
run in parallel on.

01:03:24.440 --> 01:03:26.920
And if you ever find a
way of cutting it up,

01:03:26.920 --> 01:03:29.540
and you run those two, and put
those two sides in parallel,

01:03:29.540 --> 01:03:34.510
and if they both accept,
then you can accept.

01:03:34.510 --> 01:03:36.770
And star is, again,
very similar.

01:03:36.770 --> 01:03:39.340
So these are not too bad.

01:03:39.340 --> 01:03:41.800
But I admit, you know, it's
not a whole lot of time

01:03:41.800 --> 01:03:44.740
to have to contend with
something that you're just

01:03:44.740 --> 01:03:46.990
getting used to.

01:03:46.990 --> 01:03:53.270
So let's talk about the very
last topic of the day, which

01:03:53.270 --> 01:03:57.050
is really going to be setting
ourselves up for Tuesday's

01:03:57.050 --> 01:03:58.910
lecture next week.

01:03:58.910 --> 01:04:03.230
And that's how we are going to
be showing other languages are

01:04:03.230 --> 01:04:07.490
undecidable, which is something
that I'm going to be expecting

01:04:07.490 --> 01:04:10.880
you guys to be able to do.

01:04:10.880 --> 01:04:15.950
This is the standard
procedure for showing

01:04:15.950 --> 01:04:18.620
languages are
undecidable using what's

01:04:18.620 --> 01:04:21.390
called the reducibility method.

01:04:21.390 --> 01:04:25.250
And what that does is it
takes, as a starting point,

01:04:25.250 --> 01:04:29.090
a language that we already
know is undecidable--

01:04:29.090 --> 01:04:32.630
typically, A,TM-- or it
could be another one that

01:04:32.630 --> 01:04:34.760
you've previously shown
to be undecidable--

01:04:34.760 --> 01:04:38.060
and leverages that information
to show other languages are

01:04:38.060 --> 01:04:40.040
undecidable.

01:04:40.040 --> 01:04:44.730
And it's using what's
called reducibility.

01:04:44.730 --> 01:04:48.570
We're going to go into this
more carefully next time.

01:04:48.570 --> 01:04:50.820
But basically,
reducibility is a way

01:04:50.820 --> 01:04:54.750
of using one problem to
solve another problem.

01:04:54.750 --> 01:04:58.130
And so we are going to
show, for example, let's

01:04:58.130 --> 01:05:00.380
take a look at
the problem called

01:05:00.380 --> 01:05:02.600
the halting problem, which
is like the famous problem

01:05:02.600 --> 01:05:05.570
for Turing machines.

01:05:05.570 --> 01:05:08.240
You just want to know whether
it halts, not necessarily

01:05:08.240 --> 01:05:09.740
whether it accepts.

01:05:09.740 --> 01:05:11.840
So it's very similar,
but not exactly the same.

01:05:14.640 --> 01:05:18.680
And we're going to show
that this halting problem is

01:05:18.680 --> 01:05:20.090
similarly undecidable.

01:05:20.090 --> 01:05:22.520
Now we could go back and do
the whole diagonalization,

01:05:22.520 --> 01:05:23.960
but that seems like--

01:05:23.960 --> 01:05:26.540
well, that's more work than
necessary now that we already

01:05:26.540 --> 01:05:30.830
know A,TM is undecidable because
we're going to show that we can

01:05:30.830 --> 01:05:36.830
reduce the A,TM problem
to the halting problem.

01:05:36.830 --> 01:05:39.510
And we'll explain what
that means again later.

01:05:39.510 --> 01:05:44.060
But the idea is-- and as
we'll show in an illustration

01:05:44.060 --> 01:05:45.500
shortly--

01:05:45.500 --> 01:05:53.700
that by proving by contradiction
if the if HALT,TM were

01:05:53.700 --> 01:05:57.490
decidable, then A,TM
would be decided.

01:05:57.490 --> 01:05:59.450
And we know A,TM
is not decidable.

01:05:59.450 --> 01:06:04.610
And so that's our contradiction.

01:06:04.610 --> 01:06:12.590
Now the way we're going to show
that if HALT,TM is decidable,

01:06:12.590 --> 01:06:18.290
then A,TM is decidable is use
a decider for HALT,TM to decide

01:06:18.290 --> 01:06:28.920
A,TM with a suitable
modification.

01:06:28.920 --> 01:06:35.620
So basically, we want to turn
a HALT,TM decider into an A,TM

01:06:35.620 --> 01:06:36.640
decider.

01:06:36.640 --> 01:06:41.020
And that's how we're going to
reduce the problem of solving

01:06:41.020 --> 01:06:44.140
A,TM to the problem
of solving HALT,TM.

01:06:44.140 --> 01:06:45.972
Let's just do an example.

01:06:45.972 --> 01:06:47.680
If you've seen it
before, obviously, this

01:06:47.680 --> 01:06:49.040
is not going to be hard.

01:06:49.040 --> 01:06:52.950
But for the many of you who
have not seen it before,

01:06:52.950 --> 01:06:55.470
I'm partly doing it this time
just so we can do it again

01:06:55.470 --> 01:06:56.320
next time.

01:06:56.320 --> 01:06:58.980
And maybe it'll sink in
by virtue of repetition.

01:07:03.520 --> 01:07:06.040
So again, so as I just
said, we're going to assume

01:07:06.040 --> 01:07:09.190
the HALT,TM problem is decidable
and use that to show that A,TM

01:07:09.190 --> 01:07:11.170
is decidable, which
we know is false.

01:07:11.170 --> 01:07:14.460
We showed it just
earlier that it's not.

01:07:14.460 --> 01:07:16.480
So assume we have a
decider for HALT,TM.

01:07:16.480 --> 01:07:24.000
We'll call it R. And we're going
to construct from R a decider

01:07:24.000 --> 01:07:28.430
for A,TM we'll call S. OK?

01:07:28.430 --> 01:07:30.650
So we're, again, typical
proof by contradiction.

01:07:30.650 --> 01:07:34.100
We're assuming the opposite
of what we're trying to prove.

01:07:34.100 --> 01:07:37.640
And then we're going
to get something crazy.

01:07:37.640 --> 01:07:41.930
OK, so here, my job now,
is I'm assuming I have R,

01:07:41.930 --> 01:07:43.350
which is a HALT,TM decider.

01:07:43.350 --> 01:07:49.670
So now, I'm assuming
I know how to decide

01:07:49.670 --> 01:07:54.000
if a Turing machine and an
input eventually halts--

01:07:54.000 --> 01:07:54.500
Not.

01:07:54.500 --> 01:07:58.390
Necessarily would it accept,
just whether it halts.

01:07:58.390 --> 01:07:59.460
It's conceivable.

01:07:59.460 --> 01:08:01.320
You have to bear with me here.

01:08:01.320 --> 01:08:03.660
It's conceivable that
you could find a way

01:08:03.660 --> 01:08:07.440
to test whether Turing
machines halt on their input,

01:08:07.440 --> 01:08:10.050
even though we now know that
testing whether they accept

01:08:10.050 --> 01:08:13.084
their input is not decidable.

01:08:15.870 --> 01:08:18.420
So you have to be open-minded
to the possibility

01:08:18.420 --> 01:08:21.840
that the HALT
problem is decidable,

01:08:21.840 --> 01:08:23.819
and we're going to show
that that's can't be.

01:08:23.819 --> 01:08:27.120
So we're going to show that
if we could decide the halting

01:08:27.120 --> 01:08:32.479
problem, then we can use that to
decide the acceptance problem.

01:08:32.479 --> 01:08:34.590
OK, so how are we
going to do that?

01:08:34.590 --> 01:08:37.080
So imagine how we can
solve the halting problem.

01:08:37.080 --> 01:08:43.340
So to solve the A,TM, which
is what my job is to do,

01:08:43.340 --> 01:08:46.240
so S is supposed to solve A,TM.

01:08:46.240 --> 01:08:49.840
I'm constructing a Turing
machine as decide A,TM.

01:08:49.840 --> 01:08:51.069
I'm going to use first--

01:08:51.069 --> 01:08:52.390
I'm giving it M and w.

01:08:52.390 --> 01:08:55.830
I'm going to feed it into R
since that's really all I got.

01:08:55.830 --> 01:09:00.810
See if R tells me what happens.

01:09:00.810 --> 01:09:04.680
Does M on w at least halt?

01:09:04.680 --> 01:09:08.399
Well, if R says,
no, it doesn't halt,

01:09:08.399 --> 01:09:12.120
well then I'm actually done
because if M doesn't even

01:09:12.120 --> 01:09:14.370
halt on w, then it
couldn't be accepting w.

01:09:14.370 --> 01:09:17.399
So at that point, I know
that M doesn't accept w,

01:09:17.399 --> 01:09:20.840
and I can reject right off.

01:09:20.840 --> 01:09:23.899
So R, you can see how it
could potentially be helpful.

01:09:23.899 --> 01:09:25.729
But it's going to be
helpful in either way

01:09:25.729 --> 01:09:30.800
because if R says M
does hold, well, then,

01:09:30.800 --> 01:09:34.020
I'm also good because I
don't know the answer yet,

01:09:34.020 --> 01:09:38.689
but what I do know is I
can now simulate M on w

01:09:38.689 --> 01:09:42.140
until it halts because
R has told me it halts.

01:09:42.140 --> 01:09:47.160
So I don't have to worry
about getting into a loop.

01:09:47.160 --> 01:09:50.630
So S can be confident in being
a decider for whatever it's

01:09:50.630 --> 01:09:57.270
doing because I'm running
now M on w with a guarantee

01:09:57.270 --> 01:10:00.380
that it halts.

01:10:00.380 --> 01:10:02.960
And now, that's going to
tell me-- now eventually,

01:10:02.960 --> 01:10:05.720
the simulation of M on w is
going to end up at an accept

01:10:05.720 --> 01:10:06.220
or reject.

01:10:06.220 --> 01:10:07.928
And that's going to
be the answer I need.

01:10:07.928 --> 01:10:09.320
So if M is accepted,
then accept.

01:10:09.320 --> 01:10:13.100
And if M is rejected,
then reject.

01:10:13.100 --> 01:10:19.990
And that's how S solves A,TM
using R, which solves HALT,TM.

01:10:19.990 --> 01:10:22.540
But S can't exist.

01:10:22.540 --> 01:10:24.130
And so therefore, R can't exist.

01:10:24.130 --> 01:10:28.460
And therefore, HALT,TM
can't be decidable.

01:10:28.460 --> 01:10:29.170
OK?

01:10:29.170 --> 01:10:30.295
So that quickly--

01:10:35.630 --> 01:10:39.870
OK, I'm not sure which
diagram you wanted me to show.

01:10:39.870 --> 01:10:41.490
But anyway, maybe
we can do that.

01:10:41.490 --> 01:10:44.310
We're basically at the end
of the hour or end of the 90

01:10:44.310 --> 01:10:44.920
minutes.

01:10:44.920 --> 01:10:46.620
So let's do a quick review.

01:10:46.620 --> 01:10:48.915
And if you stick around, I'm
happy to go back and look

01:10:48.915 --> 01:10:51.540
at any of the other slides that
you might have missed something

01:10:51.540 --> 01:10:52.490
on.

01:10:52.490 --> 01:10:57.950
OK, so just to recap, we
showed that the natural numbers

01:10:57.950 --> 01:11:00.950
and the real numbers are not the
same size using that definition

01:11:00.950 --> 01:11:03.740
of one-to-one correspondence to
introduce the diagonalization

01:11:03.740 --> 01:11:04.490
method.

01:11:04.490 --> 01:11:06.950
We used the diagonalization
method to show that A,TM is

01:11:06.950 --> 01:11:08.240
undecidable.

01:11:08.240 --> 01:11:10.305
We also showed
that little theorem

01:11:10.305 --> 01:11:11.930
that if the language
and its complement

01:11:11.930 --> 01:11:15.290
are recognizable, then
the language is decidable.

01:11:15.290 --> 01:11:18.950
And from that, we concluded
that A,TM complement is not

01:11:18.950 --> 01:11:20.210
recognizable.

01:11:20.210 --> 01:11:23.390
And then we showed, at least
by virtue of an introduction

01:11:23.390 --> 01:11:26.390
to the method, the reducibility
method to show that HALT,TM is

01:11:26.390 --> 01:11:27.770
undecidable.

01:11:27.770 --> 01:11:29.660
And that was today's lecture.

01:11:29.660 --> 01:11:32.880
And we're and we're at
the end of the hour.

01:11:32.880 --> 01:11:35.900
So why don't I--

01:11:35.900 --> 01:11:36.890
we are finished.

01:11:36.890 --> 01:11:39.260
You can log out.

01:11:39.260 --> 01:11:43.300
And if you want, I
will stick around.

01:11:43.300 --> 01:11:46.510
OK, OK, this is kind of
a good question here.

01:11:50.130 --> 01:12:00.790
So I'm getting a question about
the A,TM-complement, which is--

01:12:00.790 --> 01:12:06.960
since we have a
recognizer for A,TM,

01:12:06.960 --> 01:12:12.150
if I'm doing justice
to this question,

01:12:12.150 --> 01:12:14.940
we have a recogniser for A,TM,
so why can't we just invert

01:12:14.940 --> 01:12:17.950
the answer?

01:12:17.950 --> 01:12:23.310
Flip the answer around, and
now, we have a recognizer

01:12:23.310 --> 01:12:27.900
for the complement of
A,TM, A,TM-complement.

01:12:27.900 --> 01:12:30.530
So why doesn't that work?

01:12:30.530 --> 01:12:36.170
Well, the reason that doesn't
work is because the recognizer

01:12:36.170 --> 01:12:42.080
for A,TM might be rejecting
some things by looping.

01:12:42.080 --> 01:12:48.470
And now, if you just flip
the accepting and rejecting,

01:12:48.470 --> 01:12:51.410
when it hits one of
those halting states,

01:12:51.410 --> 01:12:53.660
it's going to give
the reverse answer.

01:12:53.660 --> 01:12:58.130
But when it rejects
by looping, it'll

01:12:58.130 --> 01:12:59.540
continue to reject by looping.

01:12:59.540 --> 01:13:02.030
So you won't get the
complementary language

01:13:02.030 --> 01:13:02.600
coming out.

01:13:06.560 --> 01:13:15.780
So if it would be helpful, I
can go back to that slide here,

01:13:15.780 --> 01:13:18.230
which proves that
A,TM-complement is

01:13:18.230 --> 01:13:26.130
unrecognizable because maybe we
should start with the bottom.

01:13:26.130 --> 01:13:33.170
We know that A,TM is
recognizable and undecidable,

01:13:33.170 --> 01:13:33.670
right?

01:13:33.670 --> 01:13:35.230
We already proved
those two facts.

01:13:35.230 --> 01:13:41.020
A,TM is recognizable from
the universal Turing machine,

01:13:41.020 --> 01:13:45.360
and it's undecidable by the
diagonalization argument.

01:13:45.360 --> 01:13:48.060
Those two things
together tell us

01:13:48.060 --> 01:13:52.200
that the complement has
to be unrecognizable

01:13:52.200 --> 01:13:55.350
because if a language
and its complement

01:13:55.350 --> 01:13:57.750
are both recognizable-- and
we already know the language

01:13:57.750 --> 01:13:59.490
itself is recognizable.

01:13:59.490 --> 01:14:01.697
So now, if the complement
is also recognizable,

01:14:01.697 --> 01:14:04.155
the language is going to be
decidable by the upper theorem.

01:14:10.670 --> 01:14:12.980
So it must be the case had
either the language itself

01:14:12.980 --> 01:14:16.948
is unrecognizable, or its
complement is unrecognizable.

01:14:16.948 --> 01:14:18.490
We know the language
is recognizable.

01:14:18.490 --> 01:14:20.560
That's what the universal
Turing machine told us.

01:14:20.560 --> 01:14:22.540
So the only thing left
is for the complement

01:14:22.540 --> 01:14:25.300
to be unrecognizable.

01:14:25.300 --> 01:14:28.690
You should review that
if you didn't get it

01:14:28.690 --> 01:14:32.560
because this is the
kind of reasoning

01:14:32.560 --> 01:14:35.930
we're going to be building
on things like that.

01:14:35.930 --> 01:14:40.510
So I think it's good to
make sure you understand.

01:14:40.510 --> 01:14:41.010
OK.

01:14:44.147 --> 01:14:45.730
OK, the diagram on
the right-- so this

01:14:45.730 --> 01:14:47.350
is just a Venn diagram here.

01:14:47.350 --> 01:14:49.420
I threw this in at
the last minute here.

01:14:49.420 --> 01:14:53.640
I was worried about
it being confusing.

01:14:53.640 --> 01:14:55.030
That part is--

01:15:00.570 --> 01:15:03.240
I'm trying to show that the
three classes that we've

01:15:03.240 --> 01:15:04.590
already talked about--

01:15:04.590 --> 01:15:06.780
the languages which
are decidable,

01:15:06.780 --> 01:15:09.210
the languages which are
Turing-recognizable,

01:15:09.210 --> 01:15:11.160
and the languages
whose complements

01:15:11.160 --> 01:15:12.780
are Turing-recognizable.

01:15:12.780 --> 01:15:17.290
Those are three separate
classes of languages.

01:15:17.290 --> 01:15:22.630
And those come up here
in those three regions.

01:15:22.630 --> 01:15:24.450
These are the decidable ones.

01:15:24.450 --> 01:15:27.240
Here are the recognizable ones.

01:15:27.240 --> 01:15:31.930
And here are the ones whose
complements are recognizable.

01:15:31.930 --> 01:15:36.780
Now if a language is in
both the recognizable,

01:15:36.780 --> 01:15:38.310
and its complement
is recognizable--

01:15:38.310 --> 01:15:41.460
so it's in both of these
bigger regions here--

01:15:41.460 --> 01:15:45.980
then this theorem tells
you it's decidable.

01:15:45.980 --> 01:15:49.600
So that's why the intersection
of these two regions

01:15:49.600 --> 01:15:51.940
is marked as being
decidable because that

01:15:51.940 --> 01:15:52.870
means you're in both.

01:15:57.510 --> 01:15:59.580
OK?

01:15:59.580 --> 01:16:03.090
But we know that A,TM is
sitting out here as recognizable

01:16:03.090 --> 01:16:04.170
but not decidable.

01:16:04.170 --> 01:16:06.720
So A,TM is in the
recognizable side,

01:16:06.720 --> 01:16:12.450
but it's not on the complement
of recognizable, A,TM itself.

01:16:12.450 --> 01:16:15.840
The complement of A,TM is the
complement of a recognizable

01:16:15.840 --> 01:16:22.120
but itself is not recognizable
and not decidable.

01:16:22.120 --> 01:16:26.180
So you got this side
of nice, you know--

01:16:26.180 --> 01:16:28.340
I hope you think
it's nice, but it's

01:16:28.340 --> 01:16:31.710
sort of a try to summarize
things in this little Venn

01:16:31.710 --> 01:16:32.210
diagram.

01:16:35.200 --> 01:16:40.610
So I think I'm going
to then sign off.

01:16:40.610 --> 01:16:45.690
And I'll see you all on Tuesday.

01:16:45.690 --> 01:16:47.100
And have a good weekend.

01:16:47.100 --> 01:16:48.770
Bye bye.