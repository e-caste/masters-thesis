WEBVTT

00:00:00.000 --> 00:00:01.972
[SQUEAKING]

00:00:01.972 --> 00:00:03.944
[RUSTLING]

00:00:03.944 --> 00:00:05.423
[CLICKING]

00:00:25.180 --> 00:00:26.900
MICHAEL SIPSER: Hi, everybody.

00:00:26.900 --> 00:00:29.770
Can you hear me?

00:00:29.770 --> 00:00:30.280
Yes.

00:00:30.280 --> 00:00:32.980
Good.

00:00:32.980 --> 00:00:37.630
Welcome back to the course.

00:00:37.630 --> 00:00:47.470
And so we are now at
lecture 10, and let's see.

00:00:47.470 --> 00:00:48.470
What have we been doing?

00:00:48.470 --> 00:00:53.950
We've been talking
about undecidability.

00:00:53.950 --> 00:00:59.170
So we introduced, last time,
reducibilities and mapping

00:00:59.170 --> 00:01:04.150
reducibilities for
proving various problems

00:01:04.150 --> 00:01:06.190
are undecidable.

00:01:06.190 --> 00:01:09.160
And this time, we're going
to-- and today, we're

00:01:09.160 --> 00:01:14.890
going to introduce a
more sophisticated method

00:01:14.890 --> 00:01:19.930
for proving undesirability
using reducibilities.

00:01:19.930 --> 00:01:22.765
And that's called the
computation history method.

00:01:22.765 --> 00:01:25.810
And that's pretty
much what's used

00:01:25.810 --> 00:01:31.120
in all of the more serious
cases where people have

00:01:31.120 --> 00:01:33.020
proved problems undecidable.

00:01:33.020 --> 00:01:37.360
It's pretty much a
widespread method.

00:01:37.360 --> 00:01:40.900
Especially it's not an active
area of research these days,

00:01:40.900 --> 00:01:44.380
but at times when people were
proving problems undecidable,

00:01:44.380 --> 00:01:48.267
this was frequently a
method that was used.

00:01:48.267 --> 00:01:49.850
So we'll go over
that today, and we'll

00:01:49.850 --> 00:01:56.850
prove a few examples of problems
undecidable using that method.

00:01:56.850 --> 00:01:57.350
All right.

00:01:57.350 --> 00:02:00.840
So why don't we get started.

00:02:00.840 --> 00:02:04.200
So first of all,
most importantly,

00:02:04.200 --> 00:02:08.630
you should remember how
we prove problems are

00:02:08.630 --> 00:02:10.590
undecidable in the first place.

00:02:10.590 --> 00:02:15.460
And that is by showing some
other undecidable problem

00:02:15.460 --> 00:02:18.040
that we already know
is undecidable is

00:02:18.040 --> 00:02:21.650
reducible to the
problem of interest.

00:02:21.650 --> 00:02:23.410
So typically, you
might be reducing

00:02:23.410 --> 00:02:27.220
ATM, which is a problem that
we started with and showed

00:02:27.220 --> 00:02:30.850
to be undecidable by the
diagonalization method.

00:02:30.850 --> 00:02:33.340
Or it might be some other
problem that we've subsequently

00:02:33.340 --> 00:02:35.920
shown to be undecidable,
and you take that problem,

00:02:35.920 --> 00:02:38.710
and you reduce it to
the problem you're

00:02:38.710 --> 00:02:40.730
trying to show undecidable.

00:02:40.730 --> 00:02:41.230
OK?

00:02:41.230 --> 00:02:43.000
Whoops.

00:02:43.000 --> 00:02:44.530
Let me fix that.

00:02:44.530 --> 00:02:45.030
OK.

00:02:50.540 --> 00:02:52.490
So this is the thing
to keep in mind.

00:02:52.490 --> 00:02:53.990
To prove a language
is undecidable,

00:02:53.990 --> 00:02:56.540
show that ATM or some other
known undecidable language

00:02:56.540 --> 00:02:59.300
is reducible to the
problem B that you

00:02:59.300 --> 00:03:03.200
have at hand that you're
trying to show undecidable.

00:03:03.200 --> 00:03:03.700
All right.

00:03:03.700 --> 00:03:05.770
So we are now going to--

00:03:11.370 --> 00:03:15.120
first, I'm going to
start off by remembering

00:03:15.120 --> 00:03:18.120
Hilbert's tenth problem,
which we discussed briefly

00:03:18.120 --> 00:03:22.120
a few lectures back,
as you may remember.

00:03:22.120 --> 00:03:24.210
So that's a problem
where you were

00:03:24.210 --> 00:03:29.490
given, say, some polynomial
over several variables,

00:03:29.490 --> 00:03:42.430
like 3x squared y minus
15z plus 2xz equals 5.

00:03:42.430 --> 00:03:45.080
And you want to
solve that problem.

00:03:45.080 --> 00:03:49.720
You want to find a solution
that solves that equation,

00:03:49.720 --> 00:03:52.450
but you require
that the solution

00:03:52.450 --> 00:03:55.690
involves only integers.

00:03:55.690 --> 00:03:58.890
So those are so-called
diophantine problems

00:03:58.890 --> 00:04:02.520
because the requirement is that
the solution be in integers.

00:04:02.520 --> 00:04:12.520
And Hilbert's problem was
to ask for an algorithm.

00:04:12.520 --> 00:04:14.950
Not the language that he
used, but doesn't matter.

00:04:14.950 --> 00:04:16.899
Essentially, he asked
for an algorithm

00:04:16.899 --> 00:04:20.829
to test whether a polynomial
has a solution in integers,

00:04:20.829 --> 00:04:23.890
whether the polynomial equation
has a solution in integers.

00:04:23.890 --> 00:04:35.330
And as we now know, that
problem was posed back in 1900,

00:04:35.330 --> 00:04:40.310
it took 71 years to find the
solution, but the answer is no.

00:04:40.310 --> 00:04:42.380
There is no-- there
is no such algorithm.

00:04:42.380 --> 00:04:44.330
We talked about this
when we were discussing

00:04:44.330 --> 00:04:47.240
the Church-Turing thesis.

00:04:47.240 --> 00:04:53.900
And the method showing
that there is no algorithm

00:04:53.900 --> 00:04:58.360
is by a reduction from
ATM to that problem.

00:04:58.360 --> 00:05:00.060
So one can use
exactly the method

00:05:00.060 --> 00:05:03.990
that we're using today
to prove that problem is

00:05:03.990 --> 00:05:06.600
undecidable about polynomials.

00:05:06.600 --> 00:05:08.790
The only thing is is
that the reduction,

00:05:08.790 --> 00:05:13.060
that single reduction, would
take the entire semester.

00:05:13.060 --> 00:05:16.120
And I know that's
in fact correct

00:05:16.120 --> 00:05:18.593
because when I was
a graduate student,

00:05:18.593 --> 00:05:20.260
there was a woman in
the math department

00:05:20.260 --> 00:05:25.480
at Berkeley, where I
studied, and the whole course

00:05:25.480 --> 00:05:29.260
was to go through the proof
of Hilbert's tenth problem,

00:05:29.260 --> 00:05:31.690
of the solution to Hilbert's
tenth problem, the proof

00:05:31.690 --> 00:05:35.650
of the undecidability
of the solution,

00:05:35.650 --> 00:05:38.320
of the undecidability of
testing whether a polynomial has

00:05:38.320 --> 00:05:40.350
an integral solution.

00:05:40.350 --> 00:05:46.690
So the thing is is that involves
some fairly hairy number theory

00:05:46.690 --> 00:05:50.710
in order to come up with
the right polynomials

00:05:50.710 --> 00:05:53.755
to basically simulate
the Turing machine.

00:05:53.755 --> 00:05:55.630
So that's kind of getting
ahead of ourselves.

00:05:55.630 --> 00:05:57.670
That's what we're going
to be doing today.

00:05:57.670 --> 00:06:00.220
But we're going to-- instead
of looking at that problem

00:06:00.220 --> 00:06:03.010
because we don't have a whole
semester to spend on it,

00:06:03.010 --> 00:06:04.540
we're going to look
at a toy problem

00:06:04.540 --> 00:06:06.760
instead where there's
no number theory,

00:06:06.760 --> 00:06:11.020
but it still has the same
basic underlying idea

00:06:11.020 --> 00:06:14.170
that was employed
in the solution

00:06:14.170 --> 00:06:16.550
to Hilbert's tenth problem.

00:06:16.550 --> 00:06:18.820
So that toy problem is called
the post correspondence

00:06:18.820 --> 00:06:19.690
problem.

00:06:19.690 --> 00:06:21.970
And it's going to have
some other utility for us.

00:06:21.970 --> 00:06:25.780
Well, the main reason
we're studying it

00:06:25.780 --> 00:06:27.160
is just to illustrate
the method.

00:06:30.860 --> 00:06:35.180
So and the method is going
to be, as I have been saying,

00:06:35.180 --> 00:06:38.020
is this computation
history method.

00:06:38.020 --> 00:06:40.570
OK, so why don't
we-- we'll first

00:06:40.570 --> 00:06:43.060
talk about this post
correspondence problem

00:06:43.060 --> 00:06:44.830
because that's very
easy to understand,

00:06:44.830 --> 00:06:50.210
and then we'll spend a little
time introducing that method.

00:06:50.210 --> 00:06:52.220
All right.

00:06:52.220 --> 00:07:01.030
So the post correspondence
problem is as follows.

00:07:01.030 --> 00:07:07.780
You're given a bunch
of pairs of strings.

00:07:07.780 --> 00:07:11.520
So here is one pair, t1 and b1.

00:07:11.520 --> 00:07:14.220
And I'm writing
them as dominoes.

00:07:14.220 --> 00:07:16.440
I'm calling them
dominoes because I'm

00:07:16.440 --> 00:07:21.440
writing one of the strings
on top of the other string.

00:07:21.440 --> 00:07:25.640
In fact, I'm using t and
b for top and bottom here.

00:07:25.640 --> 00:07:28.390
So this is t1 is
the top string, b1

00:07:28.390 --> 00:07:31.590
is the bottom string
in the first domino.

00:07:31.590 --> 00:07:35.280
And then in the second domino,
we have two other strings,

00:07:35.280 --> 00:07:37.080
a top and a bottom and so on.

00:07:39.770 --> 00:07:45.790
So we have these here, this
collection of dominoes,

00:07:45.790 --> 00:07:48.910
as sort of the legal dominoes.

00:07:48.910 --> 00:07:52.630
And what the goal is, to find
a sequence of those dominoes.

00:07:55.270 --> 00:07:57.610
So you want to pick from
these dominoes here.

00:07:57.610 --> 00:07:59.470
You're allowed to
repeat dominoes.

00:07:59.470 --> 00:08:01.990
So you want to pick a
sequence of those dominoes,

00:08:01.990 --> 00:08:05.140
line them up next to
each other, and so

00:08:05.140 --> 00:08:08.890
that the string that you get
by reading along the top, all

00:08:08.890 --> 00:08:11.188
of the ts together,
is going to be

00:08:11.188 --> 00:08:13.480
exactly the same as the string
you get by reading along

00:08:13.480 --> 00:08:15.940
all the bottoms.

00:08:15.940 --> 00:08:18.080
I'll give you an example.

00:08:18.080 --> 00:08:19.930
So here, to write it
down a little bit more

00:08:19.930 --> 00:08:23.680
formally, so what
I'm calling a match

00:08:23.680 --> 00:08:29.770
is a sequence of these
dominoes, so it's ti1, ti2.

00:08:29.770 --> 00:08:32.520
Well, it's i1 is
the first domino,

00:08:32.520 --> 00:08:35.020
i2 is the second
domino and so on.

00:08:35.020 --> 00:08:36.760
And then what
you're going to have

00:08:36.760 --> 00:08:41.530
is all the top strings
concatenated together

00:08:41.530 --> 00:08:44.710
is exactly the same as what you
get by concatenating together

00:08:44.710 --> 00:08:45.700
all the bottom strings.

00:08:48.260 --> 00:08:50.090
So here's an
example, and I think

00:08:50.090 --> 00:08:53.030
it'll become clear if you
didn't understand it so far,

00:08:53.030 --> 00:08:57.560
but it'll be completely clear
from the example, I hope.

00:08:57.560 --> 00:09:02.590
So here is a bunch
of dominoes, four.

00:09:02.590 --> 00:09:07.090
And what I want to
know is, is there

00:09:07.090 --> 00:09:10.150
some selection of
these dominoes-- again,

00:09:10.150 --> 00:09:11.380
you can repeat dominoes.

00:09:11.380 --> 00:09:13.730
Otherwise, it would be not
an interesting problem.

00:09:13.730 --> 00:09:16.570
So you can repeat these
as many times as you like.

00:09:16.570 --> 00:09:18.730
And I want to pick
these dominoes

00:09:18.730 --> 00:09:21.712
and line them up so that
what you get by reading along

00:09:21.712 --> 00:09:23.170
the top is the same
as what you get

00:09:23.170 --> 00:09:25.710
by reading along the bottom.

00:09:25.710 --> 00:09:28.670
So first of all, if
you just stare at this

00:09:28.670 --> 00:09:31.340
and you're trying
to make a match,

00:09:31.340 --> 00:09:35.150
you'll see that there's only
one possible way to start this.

00:09:38.410 --> 00:09:41.290
For example, if you started
with the third domino here,

00:09:41.290 --> 00:09:44.710
ba over aa, it would
fail immediately

00:09:44.710 --> 00:09:50.215
because the b and
the a are different.

00:09:50.215 --> 00:09:53.860
And if you use the second
domino as your starting point,

00:09:53.860 --> 00:10:00.235
that would fail to match as well
because aa would have to be--

00:10:00.235 --> 00:10:02.440
the top string
would start with aa,

00:10:02.440 --> 00:10:04.390
the bottom string
would start with ab,

00:10:04.390 --> 00:10:07.800
and they could never be equal.

00:10:07.800 --> 00:10:09.470
So by looking at
this, you can see

00:10:09.470 --> 00:10:11.630
that the only possible
choice that you have

00:10:11.630 --> 00:10:14.980
is to start with
the first domino.

00:10:14.980 --> 00:10:17.290
So I'm going to start to
build a domino for you

00:10:17.290 --> 00:10:18.410
just so you can see it.

00:10:18.410 --> 00:10:24.010
So here's the match so
you can see the process.

00:10:24.010 --> 00:10:27.460
So the match starts with
the very first domino.

00:10:27.460 --> 00:10:29.080
And the way I'm
going to write it

00:10:29.080 --> 00:10:32.570
is I'm going to take the
dominoes and kind of skew them

00:10:32.570 --> 00:10:36.130
so that you can see how the
top and bottom strings are

00:10:36.130 --> 00:10:38.810
lining up.

00:10:38.810 --> 00:10:43.120
But they're the same
dominoes, they've just been--

00:10:43.120 --> 00:10:45.380
I changed the shape.

00:10:45.380 --> 00:10:48.880
So this is the first
domino, ab over aba.

00:10:48.880 --> 00:10:53.260
Now, the second
domino in my match,

00:10:53.260 --> 00:10:56.710
it's got to start with an
a as the leftmost symbol

00:10:56.710 --> 00:10:57.670
on the top string.

00:10:57.670 --> 00:11:00.550
So that would rule out
this one, for example.

00:11:00.550 --> 00:11:02.200
But there might be
several choices,

00:11:02.200 --> 00:11:05.170
and so it's not exactly obvious
which one you should take.

00:11:05.170 --> 00:11:08.360
What I'm going to suggest
is we take this one here.

00:11:08.360 --> 00:11:10.420
So we take aa over aba.

00:11:10.420 --> 00:11:12.490
You see it. aa over aba.

00:11:12.490 --> 00:11:16.360
It's just written--
I'm just skewing it

00:11:16.360 --> 00:11:21.100
so that I can line up the a
over a, the b over b, the a

00:11:21.100 --> 00:11:22.640
over a and so on.

00:11:22.640 --> 00:11:26.710
So I'm starting to build
this concatenation of the top

00:11:26.710 --> 00:11:29.320
being equal to the
concatenation of the bottom.

00:11:32.020 --> 00:11:34.290
Following me so far, I hope?

00:11:34.290 --> 00:11:36.960
So now, what's next?

00:11:36.960 --> 00:11:40.290
So I need to have something
where the top string is

00:11:40.290 --> 00:11:42.562
going to start with a ba.

00:11:42.562 --> 00:11:44.550
Fact, there's only
one choice for that,

00:11:44.550 --> 00:11:46.880
so it's clearly going to
have to be this domino is

00:11:46.880 --> 00:11:47.880
going to be next.

00:11:47.880 --> 00:11:49.700
So it's going to
put a ba up here,

00:11:49.700 --> 00:11:53.510
but then it's going to force
an aa down below because that's

00:11:53.510 --> 00:11:57.000
what this domino does.

00:11:57.000 --> 00:11:58.770
So this ba matches with that.

00:11:58.770 --> 00:12:03.140
Now we have the aa to deal with.

00:12:03.140 --> 00:12:06.250
So we're going to
reuse this domino

00:12:06.250 --> 00:12:09.190
because that's the only
one that starts with an aa.

00:12:09.190 --> 00:12:12.280
So we're going to
reuse that one.

00:12:12.280 --> 00:12:13.690
Now we have aa and aba.

00:12:13.690 --> 00:12:16.270
Now we need something
that starts with aba.

00:12:16.270 --> 00:12:18.580
I see two choices.

00:12:18.580 --> 00:12:21.655
Could be this one because
this is consistent with--

00:12:21.655 --> 00:12:24.310
at least it captures the ab.

00:12:24.310 --> 00:12:26.210
We could try putting
this one over here,

00:12:26.210 --> 00:12:29.830
but a better choice would be to
use this one because if we use

00:12:29.830 --> 00:12:33.580
this one, we finish the match.

00:12:33.580 --> 00:12:36.175
And therefore, we have found
what we're looking for.

00:12:39.610 --> 00:12:45.410
And this collection of
dominoes here has a match.

00:12:45.410 --> 00:12:47.845
Now, it's not always obvious.

00:12:47.845 --> 00:12:50.680
Some collections of dominoes
may not have a match.

00:12:50.680 --> 00:12:53.905
And so the computational
problem is, is there a match?

00:12:56.440 --> 00:12:59.530
And the theorem that
we're going to prove today

00:12:59.530 --> 00:13:02.260
is that this problem
is undecidable.

00:13:02.260 --> 00:13:07.510
Simple as it is, simple little
combinatorial problem of trying

00:13:07.510 --> 00:13:13.910
to put together different tiles
like that to form a match,

00:13:13.910 --> 00:13:17.175
there is no algorithm
for solving that problem.

00:13:17.175 --> 00:13:20.350
And I think this is kind
of interesting because it's

00:13:20.350 --> 00:13:22.480
the first example of
a problem that we have

00:13:22.480 --> 00:13:28.240
where the underlying
question does not really

00:13:28.240 --> 00:13:31.130
seem to have anything
to do with computation.

00:13:31.130 --> 00:13:34.730
You might argue that
ATM being undecidable

00:13:34.730 --> 00:13:37.850
is perhaps a little
unsurprising after the fact

00:13:37.850 --> 00:13:40.247
because it's a problem
about Turing machines,

00:13:40.247 --> 00:13:42.080
so you can imagine
Turing machines are going

00:13:42.080 --> 00:13:44.630
to have a tough time answering.

00:13:44.630 --> 00:13:48.080
But here's a problem
just about strings.

00:13:48.080 --> 00:13:50.930
And we're going to
show it's undecidable.

00:13:50.930 --> 00:13:53.990
So just to formulate
this as a language,

00:13:53.990 --> 00:13:56.840
I'm going to call
the PCP language,

00:13:56.840 --> 00:14:07.280
is the collection of these PCP
problems, PCP instances, which

00:14:07.280 --> 00:14:10.700
are just themselves, each one
is a collection of dominoes.

00:14:10.700 --> 00:14:16.070
So it's the language of all
collections of these dominoes

00:14:16.070 --> 00:14:18.210
where there is a match.

00:14:18.210 --> 00:14:19.970
So it's all of the
PCP problems where you

00:14:19.970 --> 00:14:21.650
can solve them with a match.

00:14:21.650 --> 00:14:24.710
And we're going
to prove that it's

00:14:24.710 --> 00:14:28.020
undecidable by showing that
ATM is reducible to that PCP

00:14:28.020 --> 00:14:28.520
language.

00:14:31.620 --> 00:14:34.717
Now, before we do that,
I'm going to have to--

00:14:34.717 --> 00:14:37.050
I'm going to explain to you
what the computation history

00:14:37.050 --> 00:14:40.770
method is in the first pla--
that we're going to be using.

00:14:40.770 --> 00:14:43.550
So before we do that, here's
our first check-in for the day.

00:14:48.510 --> 00:14:50.220
Just to make sure
you're following me

00:14:50.220 --> 00:15:01.530
about what this PCP problem
is, I am going to give you

00:15:01.530 --> 00:15:07.630
a question to test,
is there a match

00:15:07.630 --> 00:15:09.925
with these three dominoes?

00:15:09.925 --> 00:15:11.500
So I want you to
think about that.

00:15:14.710 --> 00:15:17.230
I mean, the main thing I want
to make sure you understand

00:15:17.230 --> 00:15:19.070
is what a match is
in the first place.

00:15:19.070 --> 00:15:22.300
This is not a super hard
problem to tell whether or not

00:15:22.300 --> 00:15:23.020
there's a match.

00:15:27.260 --> 00:15:27.760
OK.

00:15:30.430 --> 00:15:33.430
Five seconds.

00:15:33.430 --> 00:15:34.750
All ready?

00:15:34.750 --> 00:15:35.380
OK.

00:15:35.380 --> 00:15:36.370
Closing it out.

00:15:39.110 --> 00:15:41.790
OK.

00:15:41.790 --> 00:15:47.190
So for those of you who
said there is a match,

00:15:47.190 --> 00:15:51.840
I want you to exhibit the
match because in fact, there

00:15:51.840 --> 00:15:54.750
is no such-- there is no match.

00:15:54.750 --> 00:15:58.710
And I mean, you could get--
by fiddling around with it,

00:15:58.710 --> 00:16:01.050
I think if you try
to find a match,

00:16:01.050 --> 00:16:05.460
you'll pretty quickly see
that you're going to get--

00:16:05.460 --> 00:16:07.650
I think what happens is
you kind of get into--

00:16:07.650 --> 00:16:11.280
if you try to build a match
with this particular setup,

00:16:11.280 --> 00:16:15.510
you're just going to get stuck
sort of repeating yourself.

00:16:15.510 --> 00:16:21.480
And one point here that
you may have missed

00:16:21.480 --> 00:16:25.510
is that a match has to
be a finite sequence.

00:16:25.510 --> 00:16:27.750
So if you were thinking about--

00:16:27.750 --> 00:16:30.090
there is a kind of
an infinite match

00:16:30.090 --> 00:16:34.200
that you can build with
this set of dominoes,

00:16:34.200 --> 00:16:35.430
but that's not allowed.

00:16:35.430 --> 00:16:38.233
We're only allowing
finite matches.

00:16:38.233 --> 00:16:40.900
And so that means that you might
change your answer as a result,

00:16:40.900 --> 00:16:43.030
but too late.

00:16:43.030 --> 00:16:47.810
So and one way to
see that you can't

00:16:47.810 --> 00:16:53.060
have a match in this
problem is that you're

00:16:53.060 --> 00:16:54.740
going to have to start--

00:16:54.740 --> 00:16:58.800
neither of these two are
possible starting points,

00:16:58.800 --> 00:17:01.160
so this one is going to
be clearly the only chance

00:17:01.160 --> 00:17:04.369
that you're going to have as a
match, the first domino here.

00:17:04.369 --> 00:17:08.329
But then once you put this
one down, the bottom one,

00:17:08.329 --> 00:17:11.660
the bottom string, the bottom
bs that you're going to get,

00:17:11.660 --> 00:17:15.079
the bottom string is going to
be longer than the top string.

00:17:15.079 --> 00:17:18.450
And then the other two are
going to have the same length.

00:17:18.450 --> 00:17:21.680
So you're never going
to have the top be

00:17:21.680 --> 00:17:23.240
the same length as the bottom.

00:17:23.240 --> 00:17:27.170
The bottom is always going to be
longer no matter how many more

00:17:27.170 --> 00:17:28.550
dominoes you lay out.

00:17:28.550 --> 00:17:33.110
So there's no chance of
there being a match here.

00:17:33.110 --> 00:17:35.060
OK.

00:17:35.060 --> 00:17:40.010
So now we're going
to work our way

00:17:40.010 --> 00:17:43.250
up to introducing this
computation history method.

00:17:45.880 --> 00:17:54.030
And first, let me define
something for a Turing machine

00:17:54.030 --> 00:17:57.360
that I'm going to
call a configuration.

00:17:57.360 --> 00:18:00.540
Configuration is just a
snapshot of the Turing machine

00:18:00.540 --> 00:18:03.520
in the middle of
its computation.

00:18:03.520 --> 00:18:05.850
So if you're running
the Turing machine

00:18:05.850 --> 00:18:08.970
and you just stop
it at some moment,

00:18:08.970 --> 00:18:11.280
it's going to be
in a certain state,

00:18:11.280 --> 00:18:13.560
the head is going to be
on a certain position,

00:18:13.560 --> 00:18:16.760
and the tape is going to
have a certain contents.

00:18:16.760 --> 00:18:20.420
And with that
information, you can then

00:18:20.420 --> 00:18:23.360
continue the computation
of the Turing machine.

00:18:23.360 --> 00:18:25.550
That's a full set
of the information

00:18:25.550 --> 00:18:27.920
that you need about
the Turing machine that

00:18:27.920 --> 00:18:30.950
tells you everything
about its computation

00:18:30.950 --> 00:18:32.810
at that moment in time.

00:18:32.810 --> 00:18:35.450
The state, head position,
and tape contents.

00:18:35.450 --> 00:18:38.930
And so that, we're calling
that information together,

00:18:38.930 --> 00:18:41.450
state, head position,
tape contents, we're

00:18:41.450 --> 00:18:43.430
calling that a configuration.

00:18:43.430 --> 00:18:47.030
Fairly basic notion.

00:18:47.030 --> 00:18:49.070
I mean, if your program--

00:18:49.070 --> 00:18:51.410
if you have something-- if
you have the states of all

00:18:51.410 --> 00:18:53.990
the variables and where
the current execution

00:18:53.990 --> 00:18:57.260
of the program is at a
moment in time, same idea.

00:18:59.940 --> 00:19:00.440
OK.

00:19:00.440 --> 00:19:04.310
So in terms of a picture here,
here is the Turing machine.

00:19:04.310 --> 00:19:07.160
Imagine it's in state q3.

00:19:07.160 --> 00:19:10.250
The head position is in the
sixth position on the tape,

00:19:10.250 --> 00:19:14.900
so p would be 6 because
it's in the sixth position,

00:19:14.900 --> 00:19:18.050
and the tape contents is going
to be this bunch of as followed

00:19:18.050 --> 00:19:19.220
by this bunch of bs.

00:19:19.220 --> 00:19:21.440
So I would write
it down like this.

00:19:21.440 --> 00:19:25.190
State's in q3, head
position number 6,

00:19:25.190 --> 00:19:27.590
this is the contents
of the tape.

00:19:27.590 --> 00:19:31.520
Now, what we're going to often
do for convenience in using

00:19:31.520 --> 00:19:34.580
this notion in proofs is
that we're going to want

00:19:34.580 --> 00:19:43.920
to represent a configuration
as a string in a particular way

00:19:43.920 --> 00:19:46.425
that's going to be--
that's going to--

00:19:46.425 --> 00:19:50.010
this concept is going
to come up kind of again

00:19:50.010 --> 00:19:52.800
and again during the course.

00:19:52.800 --> 00:19:55.410
And so it's going
to be handy to have

00:19:55.410 --> 00:20:01.620
a particular way of writing down
configurations for doing proofs

00:20:01.620 --> 00:20:02.560
about them.

00:20:02.560 --> 00:20:05.610
And so the way we're going
to write them down is--

00:20:05.610 --> 00:20:06.750
I think it's just maybe--

00:20:06.750 --> 00:20:09.880
I can just put it right
up here like this.

00:20:09.880 --> 00:20:15.140
We're going to write down
the symbols of the tape.

00:20:15.140 --> 00:20:17.060
But what we're
going to do is stick

00:20:17.060 --> 00:20:21.230
in the middle of those
symbols the state

00:20:21.230 --> 00:20:25.130
of the machine
immediately to the left

00:20:25.130 --> 00:20:29.420
of the position that the
machine is currently reading.

00:20:29.420 --> 00:20:34.100
So you can imagine the
head here, which is coming.

00:20:34.100 --> 00:20:37.250
Imagine the state is kind
of where the head is.

00:20:37.250 --> 00:20:42.290
It's pointing at the symbol
immediately to its right.

00:20:42.290 --> 00:20:45.220
So this is just another way of
writing down a configuration.

00:20:45.220 --> 00:20:47.570
Here's the tape
contents, which I'm

00:20:47.570 --> 00:20:48.820
sort of writing formally here.

00:20:48.820 --> 00:20:52.940
I'm breaking the tape
contents into two parts,

00:20:52.940 --> 00:20:56.260
which I'm calling t1 and t2.

00:20:56.260 --> 00:20:58.730
This is the t1
part, the t2 part.

00:20:58.730 --> 00:21:07.690
And I'm putting the state
in between t1 and t2

00:21:07.690 --> 00:21:13.030
where I have in mind that the
machine's head position is

00:21:13.030 --> 00:21:15.500
right at the beginning of t2.

00:21:15.500 --> 00:21:20.440
But maybe this picture just says
it all and it's clear enough.

00:21:20.440 --> 00:21:22.360
So just keep in
mind that when we're

00:21:22.360 --> 00:21:25.010
going to be writing down
configurations of machines,

00:21:25.010 --> 00:21:27.010
we're typically going to
write it down this way.

00:21:31.270 --> 00:21:33.310
OK, so I think this
is a good moment

00:21:33.310 --> 00:21:36.580
to take a-- to take a
moment for questions.

00:21:36.580 --> 00:21:37.080
Oh.

00:21:37.080 --> 00:21:38.910
I see there's a lot
of questions already.

00:21:42.510 --> 00:21:44.730
So one question is,
how does the encoding

00:21:44.730 --> 00:21:49.330
differentiate between
the string and the state?

00:21:49.330 --> 00:21:51.150
If I'm understanding
you correctly,

00:21:51.150 --> 00:21:57.380
I'm going to be assuming that
the symbols that represent

00:21:57.380 --> 00:22:00.830
states and the symbols
that appear on the tape

00:22:00.830 --> 00:22:03.030
are distinct from one another.

00:22:03.030 --> 00:22:06.290
So you can always tell just like
usually the way we write things

00:22:06.290 --> 00:22:08.450
down when you have
a state symbol

00:22:08.450 --> 00:22:11.240
or whether you
have a tape symbol.

00:22:11.240 --> 00:22:12.800
And so in a
configuration, you're

00:22:12.800 --> 00:22:16.130
going to have a
bunch of tape symbols

00:22:16.130 --> 00:22:19.280
and a single state symbol
represent in the position

00:22:19.280 --> 00:22:20.150
where the head is.

00:22:22.940 --> 00:22:28.700
Somebody says-- 6 here is
just this is 1, 2, 3, 4, 5, 6.

00:22:28.700 --> 00:22:29.510
We're in head p--

00:22:29.510 --> 00:22:30.950
the head is in position six.

00:22:30.950 --> 00:22:33.163
That's all I had in
mind for 6, and that's

00:22:33.163 --> 00:22:34.580
why that 6 is
appearing over there

00:22:34.580 --> 00:22:36.247
because that's the
position of the head.

00:22:38.470 --> 00:22:39.760
Good.

00:22:39.760 --> 00:22:40.480
All right.

00:22:40.480 --> 00:22:41.725
So why don't we continue.

00:22:45.610 --> 00:22:48.760
Now, we're all ready to
start defining computation

00:22:48.760 --> 00:22:54.500
histories, which themselves
are not very difficult concept.

00:22:54.500 --> 00:22:59.660
Computation history for a
Turing machine M on an input w

00:22:59.660 --> 00:23:03.320
is just the sequence of
configurations you go through.

00:23:03.320 --> 00:23:10.148
When you start the machine
at the beginning with M

00:23:10.148 --> 00:23:11.570
on the tape--

00:23:11.570 --> 00:23:16.310
with w on the tape,
I'm sorry, and the head

00:23:16.310 --> 00:23:21.095
at the beginning in position
one and the state in 20

00:23:21.095 --> 00:23:24.110
or whatever the start
state is of the machine.

00:23:24.110 --> 00:23:27.860
So that's going to be the
starting configuration here.

00:23:27.860 --> 00:23:29.870
And these are the
sequence of configuration

00:23:29.870 --> 00:23:32.060
that machines go through--
that the machine goes

00:23:32.060 --> 00:23:34.310
through step by step.

00:23:34.310 --> 00:23:37.760
Every step of the machine
is getting represented here

00:23:37.760 --> 00:23:40.710
until it ends up at an accept.

00:23:40.710 --> 00:23:42.710
That's what we mean by
a computation history,

00:23:42.710 --> 00:23:44.460
or sometimes we're
going to emphasize that

00:23:44.460 --> 00:23:48.580
by calling it an accepting
computation history.

00:23:48.580 --> 00:23:51.890
Represent meaning that the
machine has accepted its input,

00:23:51.890 --> 00:23:54.160
and these are the
sequence of configurations

00:23:54.160 --> 00:23:56.870
that the machine goes through.

00:23:56.870 --> 00:23:59.150
That's what I mean by
a computation history.

00:23:59.150 --> 00:24:00.500
You know, I'm sure in--

00:24:00.500 --> 00:24:03.230
I mean, I think the terminology
changes over the years,

00:24:03.230 --> 00:24:07.790
but there's a notion similar
to that for any kind of--

00:24:07.790 --> 00:24:10.910
if you're running a
program and you just

00:24:10.910 --> 00:24:13.580
want to keep track of how
the variables are changing

00:24:13.580 --> 00:24:16.370
as you're in this particular
run of the machine,

00:24:16.370 --> 00:24:18.810
and you're writing
them all down,

00:24:18.810 --> 00:24:23.210
it's like a log of the
history of the settings

00:24:23.210 --> 00:24:25.880
of the internal states of
the machine and variables

00:24:25.880 --> 00:24:26.450
and so on.

00:24:29.030 --> 00:24:31.150
So this is just all
of the configurations

00:24:31.150 --> 00:24:34.840
the machine goes through on
the way to accepting its input.

00:24:34.840 --> 00:24:37.120
If the machine does
not accept its input,

00:24:37.120 --> 00:24:38.665
there is no computation history.

00:24:41.170 --> 00:24:41.670
OK?

00:24:41.670 --> 00:24:44.160
So there is no accepting
computation history, at least,

00:24:44.160 --> 00:24:47.130
to emphasize that point.

00:24:47.130 --> 00:24:49.350
Because that can only occur
obviously if the machine

00:24:49.350 --> 00:24:50.880
has accepted its input.

00:24:53.310 --> 00:24:53.810
OK.

00:24:53.810 --> 00:24:57.020
So just as we had
with configurations,

00:24:57.020 --> 00:24:59.990
we're going to want to be
able to write down computation

00:24:59.990 --> 00:25:02.188
histories as strings.

00:25:02.188 --> 00:25:04.730
And it'll be convenient to have
a particular format for doing

00:25:04.730 --> 00:25:05.670
that as well.

00:25:05.670 --> 00:25:07.460
And it's kind of
the obvious thing.

00:25:07.460 --> 00:25:13.670
We're just going to take the
sequence of configurations

00:25:13.670 --> 00:25:17.840
in the computation history and
write them down as a string

00:25:17.840 --> 00:25:20.630
where each
configuration is going

00:25:20.630 --> 00:25:23.790
to be the string for
that configuration.

00:25:23.790 --> 00:25:26.020
I'll show you kind of a
little example in a second.

00:25:26.020 --> 00:25:29.312
But just to focus
on the concept here,

00:25:29.312 --> 00:25:31.020
we're just going to
write down the string

00:25:31.020 --> 00:25:33.960
for this configuration, the
starting configuration and then

00:25:33.960 --> 00:25:35.790
the next configuration
and so on until you

00:25:35.790 --> 00:25:37.523
get to the accepting
configuration

00:25:37.523 --> 00:25:38.940
and separate each
of those strings

00:25:38.940 --> 00:25:41.990
by some pound signed letter.

00:25:41.990 --> 00:25:42.490
OK?

00:25:42.490 --> 00:25:49.460
So here is a computation
history for M on w

00:25:49.460 --> 00:25:53.450
where w is the string
w1, w2, dot, dot, wn.

00:25:53.450 --> 00:25:54.635
So here is the--

00:25:57.930 --> 00:26:02.780
here is the first configuration.

00:26:02.780 --> 00:26:07.190
So this part here is
the computation history

00:26:07.190 --> 00:26:09.200
encoded as a string.

00:26:09.200 --> 00:26:13.220
I'm giving you this extra
side information just

00:26:13.220 --> 00:26:15.690
to make it clearer
what's going on there.

00:26:15.690 --> 00:26:17.510
So this is the
first configuration,

00:26:17.510 --> 00:26:20.360
this is the second
configuration, and so on.

00:26:20.360 --> 00:26:26.180
And I'm trying to even give you
a little bit more detail of how

00:26:26.180 --> 00:26:30.980
it might look by kind of making
the example a little bit more

00:26:30.980 --> 00:26:32.040
concrete.

00:26:32.040 --> 00:26:35.690
So let's say that the
Turing machine, when

00:26:35.690 --> 00:26:38.870
it's in the starting
state q0, looking

00:26:38.870 --> 00:26:41.870
at the very first
symbol of the input

00:26:41.870 --> 00:26:47.720
tape in this particular input,
say w1, it goes from q0 to q7

00:26:47.720 --> 00:26:50.780
and writes an a on the tape and
moves its head to the right.

00:26:50.780 --> 00:26:54.150
So that's why the second
configuration reflects that.

00:26:54.150 --> 00:26:57.500
See here, it went from q0 to q7.

00:26:57.500 --> 00:26:59.520
Now the head is in
the second position,

00:26:59.520 --> 00:27:02.060
so that's why that state
symbol is moved over one.

00:27:02.060 --> 00:27:07.820
And the very first position
now has become an a

00:27:07.820 --> 00:27:11.720
because the machine has changed
whatever was on that input tape

00:27:11.720 --> 00:27:14.780
there in the first
position to an a.

00:27:14.780 --> 00:27:17.795
And then the next step,
it goes from q7 reading

00:27:17.795 --> 00:27:23.330
a w2, which is where the head
is now, looking at the w2,

00:27:23.330 --> 00:27:27.690
and goes to q8, writing a
c, and again moves right.

00:27:27.690 --> 00:27:28.190
OK?

00:27:28.190 --> 00:27:31.760
So that's why I drew
these in the way I did.

00:27:31.760 --> 00:27:35.120
And so you go through a sequence
of those, you get to q accept,

00:27:35.120 --> 00:27:40.730
and that's the encoded form
of the computation history.

00:27:40.730 --> 00:27:43.690
All right?

00:27:43.690 --> 00:27:46.070
I think that's-- is that
all I wanted to say?

00:27:46.070 --> 00:27:47.330
Yeah.

00:27:47.330 --> 00:27:53.280
So you can feel free to ask
another question if you want.

00:27:53.280 --> 00:27:54.680
I'm just going to relaunch this.

00:28:00.200 --> 00:28:00.800
Yeah.

00:28:00.800 --> 00:28:01.300
Good.

00:28:03.810 --> 00:28:10.310
So if we're all together
on configurations,

00:28:10.310 --> 00:28:12.800
computation histories,
and how we're

00:28:12.800 --> 00:28:15.280
going to be writing
them down as strings,

00:28:15.280 --> 00:28:16.630
that's what we've done so far.

00:28:19.450 --> 00:28:22.200
No questions, so I'm
going to move on.

00:28:22.200 --> 00:28:23.190
All right.

00:28:23.190 --> 00:28:28.230
So let me define a new
automaton that we're

00:28:28.230 --> 00:28:39.590
going to mainly use as just
to provide an example for us

00:28:39.590 --> 00:28:42.160
today.

00:28:42.160 --> 00:28:46.320
I'm going to call this a
linearly bounded automaton.

00:28:46.320 --> 00:28:52.290
And all it is is
a Turing machine

00:28:52.290 --> 00:28:54.240
where the Turing
machine is going to be

00:28:54.240 --> 00:28:58.440
restricted in where it can--

00:28:58.440 --> 00:29:01.018
the tape is not going
to be infinite anymore.

00:29:01.018 --> 00:29:03.435
The tape is just going to be
big enough to hold the input.

00:29:06.060 --> 00:29:08.460
So the machine no
longer has the ability

00:29:08.460 --> 00:29:12.330
to move into the portion of the
tape to the right of the input

00:29:12.330 --> 00:29:13.890
because there is
no tape out there.

00:29:13.890 --> 00:29:16.950
It just has the
tape sitting here

00:29:16.950 --> 00:29:19.980
that contains the input,
which the tape itself

00:29:19.980 --> 00:29:21.280
can vary in size.

00:29:21.280 --> 00:29:25.360
However big the input is,
that's how big the tape is.

00:29:25.360 --> 00:29:28.070
So the tape adjusts to
the length of the input.

00:29:28.070 --> 00:29:29.920
But once you've
started the machine

00:29:29.920 --> 00:29:32.860
with some particular input,
that's as big as the tape is.

00:29:32.860 --> 00:29:35.588
There's no more.

00:29:35.588 --> 00:29:37.380
The reason why it's
called linearly bounded

00:29:37.380 --> 00:29:40.845
is because the amount of
memory is a linear function

00:29:40.845 --> 00:29:43.560
of the size of the input
because you can effectively

00:29:43.560 --> 00:29:48.245
get somewhat more memory by
enlarging the tape alphabet,

00:29:48.245 --> 00:29:50.370
but that's going to be
fixed for any given machine,

00:29:50.370 --> 00:29:53.620
so that's where the linearly
comes from, if that's helpful.

00:29:53.620 --> 00:29:57.915
But if you don't get that,
it's sort of a side remark.

00:30:01.580 --> 00:30:05.510
But what's important
to me is that you

00:30:05.510 --> 00:30:09.230
understand what I mean
by a Linearly Bounded

00:30:09.230 --> 00:30:12.080
Automaton, or an LBA.

00:30:12.080 --> 00:30:15.080
It's just like a Turing
machine, but that portion

00:30:15.080 --> 00:30:18.470
of the tape that originally
had blanks is just not there.

00:30:18.470 --> 00:30:21.140
As the machine tries
to move its head

00:30:21.140 --> 00:30:23.330
off the right end of
the input, it just

00:30:23.330 --> 00:30:25.550
sticks there just as if
it tried to move its head

00:30:25.550 --> 00:30:27.470
off the left end of the input.

00:30:27.470 --> 00:30:30.120
Doesn't go anywhere.

00:30:30.120 --> 00:30:33.150
So now, we're going to ask
the same kinds of questions

00:30:33.150 --> 00:30:35.760
about LBAs that we
ask for other automa.

00:30:35.760 --> 00:30:37.950
So the acceptance problem.

00:30:37.950 --> 00:30:43.860
If I give you an input
and some particular LBA

00:30:43.860 --> 00:30:49.850
and I want to know, does
the LBA accept that input?

00:30:49.850 --> 00:30:55.910
Well, and now the question is,
is that the decidable or not?

00:30:55.910 --> 00:31:02.280
So at first glance,
you might think,

00:31:02.280 --> 00:31:06.350
well, an LBA is like
a Turing machine,

00:31:06.350 --> 00:31:09.650
and the ATM problem
is undecidable,

00:31:09.650 --> 00:31:17.090
so that might be a
good first guess.

00:31:17.090 --> 00:31:22.490
And also, if you try
to simulate them,

00:31:22.490 --> 00:31:25.070
if you try to figure out how
you would go about simulating

00:31:25.070 --> 00:31:30.660
the machine, if given b and
w, if you actually tried

00:31:30.660 --> 00:31:32.860
to simulate the machine
to get the answer,

00:31:32.860 --> 00:31:35.260
so you run b on w,
well, of course,

00:31:35.260 --> 00:31:37.410
if you run it for a while,
and it eventually halts,

00:31:37.410 --> 00:31:39.840
either accepting or rejecting,
then you know the answer

00:31:39.840 --> 00:31:40.980
and you're finished.

00:31:40.980 --> 00:31:45.493
But this machine
might get into a loop.

00:31:45.493 --> 00:31:47.160
You know, nothing to
prevent the machine

00:31:47.160 --> 00:31:48.660
from looping on
that finite amount

00:31:48.660 --> 00:31:52.350
of-- on that limited
amount of tape that it has.

00:31:52.350 --> 00:31:56.650
And then you might
be in trouble.

00:31:56.650 --> 00:32:01.870
But in fact, that's not the
case because when you start out

00:32:01.870 --> 00:32:04.480
with a limited amount
of tape, if you

00:32:04.480 --> 00:32:08.020
run the machine for a long
time and it's not halting,

00:32:08.020 --> 00:32:10.840
it's going and going and
going, inevitably, it's

00:32:10.840 --> 00:32:17.800
going to have to
repeat, get into exactly

00:32:17.800 --> 00:32:21.550
the same configuration that it
did before because there's only

00:32:21.550 --> 00:32:23.170
a limited number
of configurations

00:32:23.170 --> 00:32:24.550
that the machine has.

00:32:24.550 --> 00:32:26.620
And once it repeats
a configuration,

00:32:26.620 --> 00:32:29.260
it's going to be repeating
that configuration forever,

00:32:29.260 --> 00:32:32.430
and it's going to be in a loop.

00:32:32.430 --> 00:32:38.210
So this problem, in
fact, is decidable

00:32:38.210 --> 00:32:40.550
because the idea
is if b on w runs

00:32:40.550 --> 00:32:45.320
for a very long time and an
amount that you can calculate,

00:32:45.320 --> 00:32:48.140
then you know it's
got to be cycling.

00:32:48.140 --> 00:32:49.490
More than just looping.

00:32:49.490 --> 00:32:53.220
It's got to be repeating itself.

00:32:53.220 --> 00:32:55.550
And so therefore, once it
starts repeating itself,

00:32:55.550 --> 00:32:58.940
it's going to be going forever.

00:32:58.940 --> 00:33:01.960
So and here is the
actual calculation,

00:33:01.960 --> 00:33:04.340
which is something I'm sure
you could do on your own,

00:33:04.340 --> 00:33:06.110
but just to spell it out.

00:33:06.110 --> 00:33:09.550
So if you have an
input of length n

00:33:09.550 --> 00:33:15.790
that you're providing to
b, so if w is of length n,

00:33:15.790 --> 00:33:22.820
the LBA can only go for
this number of different--

00:33:22.820 --> 00:33:25.570
it can only have this number
of different configurations.

00:33:25.570 --> 00:33:29.140
The number of states times the
number of head positions, which

00:33:29.140 --> 00:33:32.170
is n, the number of head
positions on the tape,

00:33:32.170 --> 00:33:36.145
times the number of
different tape contents.

00:33:36.145 --> 00:33:38.560
If the tape was
only one long, this

00:33:38.560 --> 00:33:41.780
is the-- this is the size
of the tape alphabet.

00:33:41.780 --> 00:33:49.630
So if the tape were two long,
the tape had two cells on it,

00:33:49.630 --> 00:33:51.370
the number of
possible tape contents

00:33:51.370 --> 00:33:55.120
would be the square
of the alphabet.

00:33:55.120 --> 00:33:59.380
And if the tape is going
to be n symbols long,

00:33:59.380 --> 00:34:04.447
it's going to be the tape
alphabet size to the nth power.

00:34:04.447 --> 00:34:06.530
So therefore, if a Turing
machine runs for longer,

00:34:06.530 --> 00:34:08.650
it's got to repeat
some configuration,

00:34:08.650 --> 00:34:09.909
and it'll never hold.

00:34:09.909 --> 00:34:15.130
So the decider is going to be
hopefully clear at this point.

00:34:15.130 --> 00:34:20.679
You're given b and w, so this
is the decider for a LBA.

00:34:20.679 --> 00:34:23.889
It's going to run b on w
for this number of steps.

00:34:23.889 --> 00:34:25.780
If it's accepted by
then, then you accept,

00:34:25.780 --> 00:34:29.750
and if it hasn't, if it's
rejected or it's still running,

00:34:29.750 --> 00:34:30.596
then you can reject.

00:34:30.596 --> 00:34:32.679
And you know, if it's still
running at this point,

00:34:32.679 --> 00:34:33.909
it's never going to accept.

00:34:37.330 --> 00:34:38.630
All right.

00:34:38.630 --> 00:34:39.860
Any questions on this?

00:34:47.659 --> 00:34:48.489
OK, let's move on.

00:34:51.270 --> 00:34:51.770
All right.

00:34:51.770 --> 00:34:57.770
So now, but what's
different now,

00:34:57.770 --> 00:35:00.260
or what's perhaps
interesting now

00:35:00.260 --> 00:35:05.510
is that even though the
acceptance problem for LBAs

00:35:05.510 --> 00:35:09.320
is decidable, the emptiness
problem is undecidable.

00:35:11.840 --> 00:35:13.940
And that's where the
computation history

00:35:13.940 --> 00:35:15.120
method is going to come in.

00:35:15.120 --> 00:35:16.040
So this is where
we're going to be

00:35:16.040 --> 00:35:18.920
starting to do something new
in terms of a proof technique.

00:35:25.420 --> 00:35:28.810
So we're going to
reduce ATM to ELBA,

00:35:28.810 --> 00:35:32.140
the emptiness problem for LBAs.

00:35:32.140 --> 00:35:36.927
So given an LBA, does it
accept anything or not?

00:35:36.927 --> 00:35:39.260
And this is going to use the
computation history method.

00:35:39.260 --> 00:35:41.800
So this will be a
chance to illustrate

00:35:41.800 --> 00:35:43.940
that method for the first time.

00:35:43.940 --> 00:35:46.940
So the setup initially
is just like before.

00:35:46.940 --> 00:35:48.580
We're going to assume
we have a Turing

00:35:48.580 --> 00:35:53.150
machine that decides this
ELBA problem that of interest.

00:35:53.150 --> 00:35:55.240
And we're going to
use that to construct

00:35:55.240 --> 00:35:59.280
Turing machine-deciding
ATM for our contradiction.

00:35:59.280 --> 00:36:04.148
OK, so here is S,
supposedly deciding ATM,

00:36:04.148 --> 00:36:05.690
and what is it going
to do-- and this

00:36:05.690 --> 00:36:08.610
is going to be the tricky part.

00:36:08.610 --> 00:36:14.310
S is going to use M
and w to design an LBA.

00:36:19.550 --> 00:36:25.270
That LBA is going to be built
with the knowledge of M and w.

00:36:25.270 --> 00:36:28.692
In fact, it's going to
have M and w built into it.

00:36:28.692 --> 00:36:36.470
So that's why I'm
calling that LBA B of Mw

00:36:36.470 --> 00:36:41.630
because it depends on
Mw, as I'll describe.

00:36:41.630 --> 00:36:48.220
And what that LBA does,
it takes its input,

00:36:48.220 --> 00:36:52.210
let's call it the x,
the input to the LBA,

00:36:52.210 --> 00:36:57.430
and examines that input
to see if that input is

00:36:57.430 --> 00:37:00.011
an accepting computation
history for M on w.

00:37:02.840 --> 00:37:05.480
That'll be just looking
for computation histories

00:37:05.480 --> 00:37:06.290
for M on w.

00:37:08.613 --> 00:37:10.780
And that's the only thing
it's going to ever accept.

00:37:17.760 --> 00:37:21.900
If you feed it something
which is not a computation

00:37:21.900 --> 00:37:25.080
history, that sequence
of configurations

00:37:25.080 --> 00:37:28.890
for M on w leading to an accept,
if you feed it something else,

00:37:28.890 --> 00:37:31.260
the LBA is just
going to reject it.

00:37:31.260 --> 00:37:37.800
It only accepts the accepting
computation history for M on w.

00:37:37.800 --> 00:37:42.810
And now, if you can
build such a thing,

00:37:42.810 --> 00:37:49.040
then you can use that
machine in your emptiness

00:37:49.040 --> 00:37:52.280
tester to see if it
accepts any strings at all.

00:37:52.280 --> 00:37:54.140
Because the only thing
it could possibly

00:37:54.140 --> 00:37:57.170
be accepting is an accepting
computation history.

00:37:57.170 --> 00:37:59.840
You don't even know if
there exists one because you

00:37:59.840 --> 00:38:02.250
don't know if M accepts w.

00:38:02.250 --> 00:38:08.610
So you're going to
build this LBA, which

00:38:08.610 --> 00:38:12.750
is looking for accepting
computation histories,

00:38:12.750 --> 00:38:15.720
and then see if its
language is empty or not.

00:38:15.720 --> 00:38:19.200
If its language is not
empty, the only thing

00:38:19.200 --> 00:38:21.480
it could be accepting is
this computation history,

00:38:21.480 --> 00:38:23.520
so you know M accepts w.

00:38:23.520 --> 00:38:25.500
Whereas if the
language is empty,

00:38:25.500 --> 00:38:29.010
you know that there is no
computation history for M on w,

00:38:29.010 --> 00:38:31.590
and so M does not accept w.

00:38:31.590 --> 00:38:32.660
So that's the whole idea.

00:38:32.660 --> 00:38:37.760
The trick is, how do
you build this LBA?

00:38:37.760 --> 00:38:41.030
So first, you're going to make
this LBA which tests its input

00:38:41.030 --> 00:38:44.240
to see if it's an accepting
computation history for M on w.

00:38:47.390 --> 00:38:52.860
And you have to build
this LBA without even

00:38:52.860 --> 00:38:57.550
knowing whether there is
a computation history.

00:38:57.550 --> 00:38:59.170
It's not like you
can take that string

00:38:59.170 --> 00:39:00.820
and just build a
string into the LBA

00:39:00.820 --> 00:39:03.390
because you don't even
know if that string exists.

00:39:03.390 --> 00:39:10.210
But what you can do is you
can make the LBA follow

00:39:10.210 --> 00:39:14.380
the rules of M. It
knows w, and it knows M,

00:39:14.380 --> 00:39:19.780
so it can take its input, and
using w and the rules of M,

00:39:19.780 --> 00:39:25.320
see if that input is a
computation history for M on w.

00:39:25.320 --> 00:39:27.060
And that's what
it's going to do.

00:39:27.060 --> 00:39:31.965
So here is this machine
I'm going to construct.

00:39:31.965 --> 00:39:34.710
I'll give it to you written
down and with a little bit

00:39:34.710 --> 00:39:37.830
more details of its procedure.

00:39:37.830 --> 00:39:39.610
But just to kind
of illustrate it,

00:39:39.610 --> 00:39:43.140
so here is a proposed
input to B of Mw.

00:39:43.140 --> 00:39:45.090
This would be the x here.

00:39:45.090 --> 00:39:48.220
This would be an x
that would be accepted.

00:39:48.220 --> 00:39:52.040
But anything else that would be
provided would not be accepted.

00:39:52.040 --> 00:39:54.430
So this is the sequence of
configurations written down

00:39:54.430 --> 00:39:55.000
as a string.

00:39:55.000 --> 00:40:00.040
That would be the x that I'm
providing to the B of Mw.

00:40:00.040 --> 00:40:02.965
And it's supposed to be checking
this to make sure it's legit.

00:40:06.360 --> 00:40:08.880
So on input x, the
way it's going to--

00:40:08.880 --> 00:40:10.800
the way it's going
to proceed, it's

00:40:10.800 --> 00:40:13.260
going to first check
to see whether x begins

00:40:13.260 --> 00:40:22.470
in the right way because this
LBA, it knows M and it knows w.

00:40:22.470 --> 00:40:24.220
So the very first thing
is it takes a look

00:40:24.220 --> 00:40:26.950
at the first part of the
string up to the pound sign.

00:40:26.950 --> 00:40:28.570
If there's no pound
sign, if you're

00:40:28.570 --> 00:40:30.310
going to just feed
junk in, it's going

00:40:30.310 --> 00:40:32.770
to be easily
identifiable as junk.

00:40:35.710 --> 00:40:38.285
So if you're going
to feed something--

00:40:38.285 --> 00:40:40.660
so it's going to-- the LBA is
going to take everything up

00:40:40.660 --> 00:40:44.920
to the first pound sign and
just confirm that that thing is

00:40:44.920 --> 00:40:48.985
the first configuration,
the starting configuration

00:40:48.985 --> 00:40:51.860
of M on w, which means it has
to start with the start state,

00:40:51.860 --> 00:40:53.380
then here is w.

00:40:53.380 --> 00:40:55.840
So just kind of check that.

00:40:55.840 --> 00:41:00.610
Then it's going to check
that each one of these guys

00:41:00.610 --> 00:41:02.530
follows legally from
the previous one

00:41:02.530 --> 00:41:05.138
according to the rules of
M. It's going to first check

00:41:05.138 --> 00:41:07.180
that this one is correct,
and then this one leads

00:41:07.180 --> 00:41:09.720
to that one, according
to the rules of M,

00:41:09.720 --> 00:41:11.470
then this one leads
to that one, according

00:41:11.470 --> 00:41:15.490
to the rules of M. All of
that-- the knowledge of M and w

00:41:15.490 --> 00:41:19.120
is built in so it can do that.

00:41:19.120 --> 00:41:24.100
And then it just follows along,
checking this computation.

00:41:24.100 --> 00:41:26.260
It's easy to check that
a computation is correct.

00:41:26.260 --> 00:41:29.085
That's all that's
really going on here.

00:41:29.085 --> 00:41:31.210
It's going to check that
the computation is correct

00:41:31.210 --> 00:41:33.400
until it gets to the
end and then makes sure

00:41:33.400 --> 00:41:36.910
that the last configuration
that it's been given as input

00:41:36.910 --> 00:41:39.280
is an accepting
configuration, that there's

00:41:39.280 --> 00:41:42.640
an accept state in it.

00:41:42.640 --> 00:41:47.770
And if everything that passes it
accepts, otherwise, it rejects.

00:41:47.770 --> 00:41:49.820
OK?

00:41:49.820 --> 00:41:52.010
And the point is
that this is an LBA.

00:41:52.010 --> 00:41:52.940
You don't-- oh, wait.

00:41:52.940 --> 00:41:54.440
Just kind of jumped
ahead of myself.

00:41:54.440 --> 00:41:56.190
You don't need any
additional information.

00:41:56.190 --> 00:41:58.190
So how does it actually do this?

00:41:58.190 --> 00:42:00.830
So how do you actually
do this on the tape?

00:42:00.830 --> 00:42:04.850
So I claimed that the LBA
doesn't need any extra space

00:42:04.850 --> 00:42:06.110
to do this--

00:42:06.110 --> 00:42:07.660
to do this check.

00:42:07.660 --> 00:42:11.945
It's just going to be
zigzagging back and forth here

00:42:11.945 --> 00:42:18.550
on the input, checking that the
corresponding symbols match up

00:42:18.550 --> 00:42:21.220
except around the
head position where

00:42:21.220 --> 00:42:23.920
it gets updated correctly.

00:42:23.920 --> 00:42:27.663
And it may need to mark-- it
will need to mark on the tape,

00:42:27.663 --> 00:42:29.080
it's allowed to
write on the tape,

00:42:29.080 --> 00:42:32.960
just to make sure it keeps
track of where it is.

00:42:32.960 --> 00:42:34.940
But this is a very simple--

00:42:34.940 --> 00:42:36.740
I mean, I'm not trying to--

00:42:36.740 --> 00:42:39.990
if you're not following it,
I'm not trying to alarm you,

00:42:39.990 --> 00:42:43.670
but I'm just trying to help
you understand that this is not

00:42:43.670 --> 00:42:45.890
a complicated
procedure here to do

00:42:45.890 --> 00:42:50.990
this check that the actual
computation that's written down

00:42:50.990 --> 00:42:54.590
of the Turing machine is valid.

00:42:54.590 --> 00:42:56.790
But we can deal with
the question here.

00:43:01.080 --> 00:43:02.570
Oh, good.

00:43:02.570 --> 00:43:05.120
Now we got some questions.

00:43:05.120 --> 00:43:06.493
Oops.

00:43:06.493 --> 00:43:08.910
You can be thinking about--
while I'm thinking about this,

00:43:08.910 --> 00:43:10.785
you can think about that
check-in over there.

00:43:14.140 --> 00:43:16.290
So here's a good question.

00:43:16.290 --> 00:43:19.380
Going from each configuration
to the next configuration,

00:43:19.380 --> 00:43:24.880
is it a unique next step?

00:43:24.880 --> 00:43:27.120
Well, I'm assuming that
the Turing machine we're

00:43:27.120 --> 00:43:29.340
starting with is
deterministic, so there

00:43:29.340 --> 00:43:30.850
should be only one way to go.

00:43:30.850 --> 00:43:33.750
So the answer to
that question is yes.

00:43:33.750 --> 00:43:36.990
This is going to be
a unique string here.

00:43:36.990 --> 00:43:41.520
There's really going to be
only one computation history.

00:43:41.520 --> 00:43:44.280
Not that it really
matters in a sense,

00:43:44.280 --> 00:43:47.430
the answer to that
question, as long as

00:43:47.430 --> 00:43:49.380
that accepting
computation history

00:43:49.380 --> 00:43:54.205
corresponds to the machine
actually accepting.

00:43:54.205 --> 00:43:57.900
Oh boy, we're all over--
we're all over the place here.

00:43:57.900 --> 00:44:06.330
OK, are you ready
to end this poll?

00:44:11.380 --> 00:44:12.990
All right.

00:44:12.990 --> 00:44:14.190
Well, this is where we are.

00:44:16.980 --> 00:44:20.220
Everybody who said they'd
rather be in 6.046,

00:44:20.220 --> 00:44:21.750
I know who you are.

00:44:21.750 --> 00:44:24.810
You're all going to be expelled.

00:44:24.810 --> 00:44:26.928
No, I'm joking.

00:44:26.928 --> 00:44:27.970
I don't know who you are.

00:44:27.970 --> 00:44:32.280
So yeah.

00:44:32.280 --> 00:44:32.780
Good.

00:44:38.260 --> 00:44:44.590
So we are here at the break,
and I made this poll on purpose

00:44:44.590 --> 00:44:46.660
at this moment so we
can spend a little time.

00:44:46.660 --> 00:44:48.880
Let me just start
our clock going,

00:44:48.880 --> 00:44:52.810
and I can try to help you,
those of you who answered C,

00:44:52.810 --> 00:44:55.180
that you're baffled.

00:44:55.180 --> 00:44:59.220
I can try to help you
understand what's going on.

00:44:59.220 --> 00:44:59.720
Ah.

00:44:59.720 --> 00:45:01.762
So this is a good-- this
is a good question here.

00:45:06.170 --> 00:45:07.340
OK, well, OK.

00:45:07.340 --> 00:45:08.550
Several good questions here.

00:45:08.550 --> 00:45:13.550
So somebody asks, why
don't we just test

00:45:13.550 --> 00:45:16.050
all possible strings for B?

00:45:16.050 --> 00:45:19.860
Remember, if we're
trying to test emptiness

00:45:19.860 --> 00:45:25.360
for B's language,
that's the ELBA problem.

00:45:25.360 --> 00:45:28.360
Now, why don't we just
try all possible strings?

00:45:28.360 --> 00:45:31.480
And that would work
if we had enough time,

00:45:31.480 --> 00:45:32.980
but there's infinitely
many strings,

00:45:32.980 --> 00:45:34.420
and so that's not going
to be good if we're

00:45:34.420 --> 00:45:35.378
trying to be a decider.

00:45:40.590 --> 00:45:46.380
So that's why we don't
just try all strings.

00:45:46.380 --> 00:45:47.880
But here's this
other question here.

00:45:47.880 --> 00:45:50.660
This is a--

00:45:50.660 --> 00:45:51.650
OK.

00:45:51.650 --> 00:46:01.690
So the question is, how
do we find the input x?

00:46:01.690 --> 00:46:06.880
So this is an important
question because we

00:46:06.880 --> 00:46:08.950
don't find the input x.

00:46:08.950 --> 00:46:14.860
There's no-- the input x, at
least the accepted input x,

00:46:14.860 --> 00:46:20.930
would be the accepting
computation history for M on w.

00:46:20.930 --> 00:46:22.985
We're never going to find an--

00:46:22.985 --> 00:46:24.890
we're never going to find an x.

00:46:24.890 --> 00:46:29.390
We're building this LBA.

00:46:29.390 --> 00:46:31.430
We're never going
to run that LBA.

00:46:31.430 --> 00:46:36.010
We're designing that LBA not
for the purposes of running it.

00:46:36.010 --> 00:46:42.670
We're building that LBA only
for the purpose of using the LBA

00:46:42.670 --> 00:46:44.710
language emptiness tester.

00:46:44.710 --> 00:46:46.900
We're going to build
that LBA and feed it

00:46:46.900 --> 00:46:50.500
into the Turing machine R,
which is going to tell us

00:46:50.500 --> 00:46:52.690
whether that LBA's
language is empty.

00:46:52.690 --> 00:46:55.300
We, ourselves, is never
going to run that machine.

00:46:55.300 --> 00:46:57.430
We're never going to
come up with an x.

00:46:57.430 --> 00:47:02.350
We're just having-- we are
designing a computation

00:47:02.350 --> 00:47:04.650
checker.

00:47:04.650 --> 00:47:09.770
And then the emptiness
tester for that

00:47:09.770 --> 00:47:16.710
that we assume to exist
for ELBA is going to say,

00:47:16.710 --> 00:47:20.730
yes, there is some computation
which this machine accepts,

00:47:20.730 --> 00:47:23.610
or no, there is no computation
which this machine accepts,

00:47:23.610 --> 00:47:27.120
and that's going to be a
computation for M on w.

00:47:27.120 --> 00:47:30.900
And so that's going to tell
us whether or not M accepts w.

00:47:30.900 --> 00:47:33.330
So we're never going to
actually be finding an x.

00:47:33.330 --> 00:47:36.010
We're never going to
be running that LBA.

00:47:36.010 --> 00:47:46.940
We're just feeding, using
that LBA as an input to R.

00:47:46.940 --> 00:47:49.670
Does the computation history
method always use LBAs?

00:47:49.670 --> 00:47:53.940
No, as you will see
right after the break.

00:47:53.940 --> 00:47:57.540
Because the LBAs is just
kind of an easy place to get

00:47:57.540 --> 00:48:00.870
started, but we're going to use
the computation history method

00:48:00.870 --> 00:48:04.030
and computation histories next
on the post correspondence

00:48:04.030 --> 00:48:04.530
problem.

00:48:07.060 --> 00:48:08.285
Yes.

00:48:08.285 --> 00:48:10.870
The computation
histories and the input x

00:48:10.870 --> 00:48:12.770
are always going to be finite.

00:48:12.770 --> 00:48:14.410
So that was an
answer to a question

00:48:14.410 --> 00:48:16.900
about whether these
histories or the inputs

00:48:16.900 --> 00:48:18.230
are going to be finite or not.

00:48:18.230 --> 00:48:21.940
So those strings are
always going to be finite,

00:48:21.940 --> 00:48:25.640
and the computation history
is going to be finite.

00:48:25.640 --> 00:48:28.802
So we are at the end
of our five minutes.

00:48:28.802 --> 00:48:30.760
Let me just see if there
was another question I

00:48:30.760 --> 00:48:31.468
wanted to answer.

00:48:37.320 --> 00:48:38.760
Let's move on.

00:48:38.760 --> 00:48:42.900
OK, now coming back to the
undecidability of this post

00:48:42.900 --> 00:48:44.140
correspondence problem.

00:48:44.140 --> 00:48:47.340
So remember the post
correspon-- this problem,

00:48:47.340 --> 00:48:48.570
you're given those dominoes.

00:48:48.570 --> 00:48:50.070
You want to know
if there's a match.

00:48:50.070 --> 00:48:53.160
Here is a little mini
version of the diagram,

00:48:53.160 --> 00:48:55.620
if that helps you remember it.

00:48:55.620 --> 00:49:00.940
And we're going to prove that
this language is undecidable.

00:49:00.940 --> 00:49:11.060
And so it's undecidable to test
whether you have a match, given

00:49:11.060 --> 00:49:14.690
a set of dominoes, whether
a match is possible.

00:49:14.690 --> 00:49:16.190
And we're going to
use-- we're going

00:49:16.190 --> 00:49:19.780
to reduce ATM to this language
using the computation history

00:49:19.780 --> 00:49:20.280
method.

00:49:20.280 --> 00:49:23.940
So how in the world are
we going to do that?

00:49:23.940 --> 00:49:26.690
First of all, there's a little
detail here I want to mention.

00:49:26.690 --> 00:49:33.790
Just don't focus
on this, but I'm

00:49:33.790 --> 00:49:36.760
going to assume the
matches always start

00:49:36.760 --> 00:49:40.480
with the very first domino
on the list, the very

00:49:40.480 --> 00:49:43.240
first domino in the collection.

00:49:43.240 --> 00:49:45.250
So there's going to be,
like, a starting domino.

00:49:45.250 --> 00:49:47.230
Just going to make my
proof a little simpler

00:49:47.230 --> 00:49:50.780
to do it that way, and then you
can fix that assumption later.

00:49:50.780 --> 00:49:52.360
And if we have time
at the end, I'll

00:49:52.360 --> 00:49:54.805
do that or maybe after
the lecture is over.

00:49:54.805 --> 00:49:56.500
If there are questions,
I can show you

00:49:56.500 --> 00:49:57.740
how to fix that assumption.

00:49:57.740 --> 00:50:00.790
But for now, to
simplify the proof,

00:50:00.790 --> 00:50:03.988
we're going to assume that
there was a starting domino,

00:50:03.988 --> 00:50:05.530
that the matches
always have to start

00:50:05.530 --> 00:50:06.760
with that particular domino.

00:50:09.365 --> 00:50:11.240
If you didn't follow
that point, don't worry.

00:50:11.240 --> 00:50:12.198
You can just ignore it.

00:50:12.198 --> 00:50:14.390
You'll see where
it comes up later.

00:50:14.390 --> 00:50:19.010
So now we're going to
reduce ATM to the PCP.

00:50:19.010 --> 00:50:21.463
So assuming we have a
machine that decides the PCP,

00:50:21.463 --> 00:50:23.380
we're going to use that
to make a machine that

00:50:23.380 --> 00:50:26.300
decides the ATM as before.

00:50:26.300 --> 00:50:31.600
So here is the Turing machine
S, which is going to decide ATM.

00:50:31.600 --> 00:50:36.360
And the way we're going
to do it is like this.

00:50:36.360 --> 00:50:37.730
We're given M and w.

00:50:37.730 --> 00:50:43.800
We want to know, as
always, does M accept w?

00:50:43.800 --> 00:50:46.770
What we're going to do
is we're going to build

00:50:46.770 --> 00:50:50.120
an instance of the PCP problem.

00:50:50.120 --> 00:50:56.210
So we're going to build
a collection of dominoes

00:50:56.210 --> 00:50:57.920
which are going to--

00:50:57.920 --> 00:51:02.150
and that collection is going
to be built knowing M and w.

00:51:02.150 --> 00:51:05.370
So that's going to affect the
dominoes we're going to create.

00:51:05.370 --> 00:51:09.350
So this collection of dominoes
is going to be called P of Mw.

00:51:09.350 --> 00:51:11.780
Depends on an M and w.

00:51:11.780 --> 00:51:16.700
And finding a match
for this set of ws

00:51:16.700 --> 00:51:20.480
is going to force you
to simulate M on w

00:51:20.480 --> 00:51:23.150
because the match is going to
correspond to a computation

00:51:23.150 --> 00:51:26.150
history for M on w.

00:51:26.150 --> 00:51:29.330
So we're going to use--

00:51:29.330 --> 00:51:35.990
once we do that, once we build
the set of dominoes where

00:51:35.990 --> 00:51:40.640
a match corresponds to
a computation history,

00:51:40.640 --> 00:51:43.100
we're going to use R to
determine whether or not

00:51:43.100 --> 00:51:45.200
there is a match.

00:51:45.200 --> 00:51:46.700
Or in other words,
whether or not

00:51:46.700 --> 00:51:48.590
there is a computation
history, which

00:51:48.590 --> 00:51:51.970
is whether or not M accepts w.

00:51:51.970 --> 00:51:54.400
So if there is a
match, we're going

00:51:54.400 --> 00:51:57.350
to accept because
we know M accepts w.

00:51:57.350 --> 00:51:59.920
And if there is no
match, we're going

00:51:59.920 --> 00:52:04.980
to reject because we
know M does not accept w.

00:52:04.980 --> 00:52:07.460
OK.

00:52:07.460 --> 00:52:08.217
This is the plan.

00:52:08.217 --> 00:52:09.800
I haven't told you
how to do this yet.

00:52:12.670 --> 00:52:15.940
I mean, I'm worried about
the significant number of you

00:52:15.940 --> 00:52:20.320
who are feeling
confused by the method.

00:52:20.320 --> 00:52:24.850
I mean, you guys should
be texting me and the TAs

00:52:24.850 --> 00:52:27.730
to try to at least get a
sense of how this is working.

00:52:27.730 --> 00:52:29.560
I mean, we're
going to be going--

00:52:29.560 --> 00:52:33.002
we're going to be
doing the method again.

00:52:33.002 --> 00:52:34.960
It's just going to be a
little more complicated

00:52:34.960 --> 00:52:38.350
because we have to also deal
with these dominoes and all

00:52:38.350 --> 00:52:40.975
that stuff, and that's
why I presented it

00:52:40.975 --> 00:52:44.050
to you the first time in
the setting of the LBAs,

00:52:44.050 --> 00:52:47.945
which were, in a sense, the
method comes out perhaps more

00:52:47.945 --> 00:52:48.445
simply.

00:52:55.740 --> 00:52:57.800
So a match is
going to correspond

00:52:57.800 --> 00:53:01.550
to an accepting
computation history.

00:53:01.550 --> 00:53:06.730
Sometimes if I don't
use the word accepting,

00:53:06.730 --> 00:53:09.920
I'm just being a little sloppy.

00:53:09.920 --> 00:53:11.480
Computation history
and accepting

00:53:11.480 --> 00:53:14.570
computation history, for us
right now, they're the same.

00:53:14.570 --> 00:53:15.950
I mean, later on,
we may actually

00:53:15.950 --> 00:53:17.930
talk about rejecting
computation histories,

00:53:17.930 --> 00:53:22.790
but let's not get
ourselves confused.

00:53:22.790 --> 00:53:25.100
Computation
histories always have

00:53:25.100 --> 00:53:29.670
to end with the
machine accepting.

00:53:29.670 --> 00:53:30.480
OK.

00:53:30.480 --> 00:53:33.150
Somebody's asking, what
does it mean for match

00:53:33.150 --> 00:53:35.190
to correspond to a
computation history?

00:53:35.190 --> 00:53:36.090
You'll see.

00:53:36.090 --> 00:53:37.590
That's going to be
on my next slide.

00:53:42.260 --> 00:53:42.760
Oh.

00:53:42.760 --> 00:53:45.190
So this is a good question.

00:53:45.190 --> 00:53:48.970
Is my step two trying
to use R to determine

00:53:48.970 --> 00:53:50.680
whether M accepts w?

00:53:50.680 --> 00:53:55.810
Well, yes, but I'm doing that by
testing whether these dominoes

00:53:55.810 --> 00:53:57.940
have a match.

00:53:57.940 --> 00:54:00.880
Because R decides PCP.

00:54:00.880 --> 00:54:05.040
I can only use R to test
whether things have a match.

00:54:05.040 --> 00:54:08.910
Someone asks, should
step two be to use R

00:54:08.910 --> 00:54:11.220
to determine
whether M accepts w?

00:54:11.220 --> 00:54:12.910
Well, in effect,
that's what it's doing,

00:54:12.910 --> 00:54:16.800
but it's doing indirectly
through testing

00:54:16.800 --> 00:54:20.290
whether this PCP--

00:54:20.290 --> 00:54:21.790
whether these
dominoes have a match.

00:54:21.790 --> 00:54:23.665
Because those dominoes
are going to force you

00:54:23.665 --> 00:54:25.330
to simulate M on w.

00:54:25.330 --> 00:54:27.380
OK, I think I'm
repeating myself here,

00:54:27.380 --> 00:54:30.190
so let's avoid getting
into a loop on the lecture

00:54:30.190 --> 00:54:34.750
and see how we
actually build P of Mw.

00:54:34.750 --> 00:54:36.700
So now you understand
what-- you have

00:54:36.700 --> 00:54:38.305
to have the plan in your mind.

00:54:41.910 --> 00:54:44.520
We are given M and w.

00:54:44.520 --> 00:54:47.940
We're trying to make
a set of dominoes

00:54:47.940 --> 00:54:53.160
where a match is going to be a
computation history for M on w.

00:54:53.160 --> 00:54:54.660
So the string
you're going to get

00:54:54.660 --> 00:54:57.300
in that match, the top
string and the bottom string,

00:54:57.300 --> 00:54:59.130
which are going to be--

00:54:59.130 --> 00:55:03.890
have to match, they're going
to be computation histories--

00:55:03.890 --> 00:55:06.870
they're going to be a
computation history of M on w.

00:55:06.870 --> 00:55:10.140
So I want to figure out how to
make my dominoes force that.

00:55:13.090 --> 00:55:13.780
OK.

00:55:13.780 --> 00:55:15.715
So my starting
domino, as I told you,

00:55:15.715 --> 00:55:17.590
there's going to be a
special starting domino

00:55:17.590 --> 00:55:20.290
in my collection, which is
going to require the match

00:55:20.290 --> 00:55:21.490
to start with that domino.

00:55:21.490 --> 00:55:24.080
It's going to be this one here.

00:55:24.080 --> 00:55:26.707
It's going to have
these two strings in it.

00:55:26.707 --> 00:55:28.290
And you can see
already, it's starting

00:55:28.290 --> 00:55:31.590
to look like a
computation history.

00:55:31.590 --> 00:55:34.720
The dominoes are going
to have that feature.

00:55:34.720 --> 00:55:38.550
So it's the pair of
strings, and I've

00:55:38.550 --> 00:55:42.300
written it kind of to help you
see what's kind of going on.

00:55:42.300 --> 00:55:47.850
It's a pound sign on the top
and the starting configuration

00:55:47.850 --> 00:55:49.680
for M on w on the bottom.

00:55:53.020 --> 00:55:55.530
And what I'm going
to do for you here

00:55:55.530 --> 00:55:58.830
is at the bottom
of the slide, I'm

00:55:58.830 --> 00:56:01.920
going to take the dominoes
I've written down so far

00:56:01.920 --> 00:56:04.380
and try to be building
a match, and you'll

00:56:04.380 --> 00:56:09.230
see how that match is forcing
a simulation of the machine.

00:56:09.230 --> 00:56:11.120
So let's take this
as an illustration.

00:56:11.120 --> 00:56:15.470
Let's assume the input to M,
so I'm running M on w now.

00:56:15.470 --> 00:56:18.260
I'm trying to see,
does M accept w?

00:56:18.260 --> 00:56:21.900
w is a string 223.

00:56:21.900 --> 00:56:26.700
So the start
configuration for M on w

00:56:26.700 --> 00:56:30.450
is q0, that's the
starting state for M,

00:56:30.450 --> 00:56:33.510
and then w following it is 223.

00:56:33.510 --> 00:56:36.000
That's what is going to appear
on the tape of the Turing

00:56:36.000 --> 00:56:38.360
machine to start off.

00:56:38.360 --> 00:56:44.690
So this is the start
configuration for M on w,

00:56:44.690 --> 00:56:49.380
assuming that I had this
particular input string to w.

00:56:49.380 --> 00:56:53.640
And so given the
dominoes that I've

00:56:53.640 --> 00:56:57.480
given you so far,
just one, this is how

00:56:57.480 --> 00:57:00.950
the match is going to start.

00:57:00.950 --> 00:57:04.230
Now, there's going to
be more dominoes coming.

00:57:04.230 --> 00:57:07.640
So for every possible
tape symbol and state,

00:57:07.640 --> 00:57:09.290
don't get confused
by the language

00:57:09.290 --> 00:57:11.980
here, this is the
important thing.

00:57:11.980 --> 00:57:15.730
If in the Turing machine--

00:57:15.730 --> 00:57:18.100
and I'll just read
this in English to you.

00:57:18.100 --> 00:57:22.180
If the Turing machine, when
it's in state q, and the head

00:57:22.180 --> 00:57:27.740
is reading an a, it
moves to state R,

00:57:27.740 --> 00:57:34.310
writes a b at that point, and
its head moves to the right.

00:57:34.310 --> 00:57:41.990
I'm focusing on rightward moving
Turing machine steps right now.

00:57:41.990 --> 00:57:49.220
But for every possible
state and tape symbol

00:57:49.220 --> 00:57:51.830
and looking at what
happens, I'm going

00:57:51.830 --> 00:57:57.110
to have a domino that's going
to capture this information,

00:57:57.110 --> 00:57:59.510
and it's going to
be this domino here.

00:57:59.510 --> 00:58:04.400
q a on top, b r on the bottom.

00:58:04.400 --> 00:58:08.530
So just a string. q a on
the top, b r on the bottom.

00:58:08.530 --> 00:58:09.485
So let's see why?

00:58:09.485 --> 00:58:11.615
Well, that's sort
of arcane-looking.

00:58:11.615 --> 00:58:13.700
Why is that a good
thing to-- why

00:58:13.700 --> 00:58:16.140
is that a useful
domino to put in here?

00:58:16.140 --> 00:58:23.610
Well, if you take a look,
let's assume my Turing machine,

00:58:23.610 --> 00:58:27.150
when it's in state q0,
which is the starting state,

00:58:27.150 --> 00:58:29.040
and the head is
reading a 2, which

00:58:29.040 --> 00:58:34.050
it will happen to be reading
because the string w starts

00:58:34.050 --> 00:58:38.670
with a 2, if it
goes into state q7

00:58:38.670 --> 00:58:43.090
and writes a 4 and then moves
right, I'm going to have--

00:58:43.090 --> 00:58:47.170
in this domino, I'm
going to have q02

00:58:47.170 --> 00:58:55.730
on top and 4q7 on the
bottom because 4 is what I--

00:58:55.730 --> 00:58:59.760
right here, that's the
b, and the new state

00:58:59.760 --> 00:59:01.830
that I'm going into is q7.

00:59:01.830 --> 00:59:05.740
So that's going to be the
domino that I'm going to get.

00:59:05.740 --> 00:59:06.930
And here it is.

00:59:06.930 --> 00:59:08.895
Here's that domino
appearing in the match.

00:59:12.160 --> 00:59:20.770
So it's going to
match up with q02,

00:59:20.770 --> 00:59:24.610
which don't get the--
the top string has

00:59:24.610 --> 00:59:25.990
to equal the bottom string.

00:59:25.990 --> 00:59:29.290
So and this is going to
be the only choice that I

00:59:29.290 --> 00:59:31.900
have for extending the match.

00:59:31.900 --> 00:59:37.150
So q02 is going to be on the
top when I put that there,

00:59:37.150 --> 00:59:42.080
but that's going to force
4Q7 to appear at the bottom

00:59:42.080 --> 00:59:44.560
because that's what's going
to be the bottom string

00:59:44.560 --> 00:59:48.320
corresponding to
the q02 on the top.

00:59:48.320 --> 00:59:49.460
OK?

00:59:49.460 --> 00:59:52.620
So if you're looking
down here, this

00:59:52.620 --> 00:59:56.620
is the beginning of the second
configuration of the machine.

00:59:56.620 --> 00:59:59.390
That's what I want
to be happening.

00:59:59.390 --> 01:00:01.040
I want to be--

01:00:01.040 --> 01:00:03.995
that match should look
like a computation history.

01:00:08.030 --> 01:00:10.520
So this is going to be-- all
possible right moves are going

01:00:10.520 --> 01:00:12.895
to be handled in this way,
and it's going to be a similar

01:00:12.895 --> 01:00:15.410
process for the left
moves, but let me not--

01:00:15.410 --> 01:00:19.430
I'll leave that to
your imagination.

01:00:19.430 --> 01:00:24.090
Now, how do I continue
on from there?

01:00:24.090 --> 01:00:27.900
What does the rest of this
configuration look like?

01:00:27.900 --> 01:00:31.040
Well, that should just be a
copying over of the remaining

01:00:31.040 --> 01:00:33.890
symbols that were on the tape
because they don't change.

01:00:33.890 --> 01:00:36.740
Things only change
around the head.

01:00:36.740 --> 01:00:39.560
The rest of those symbols,
which is the 2 and the 3, those

01:00:39.560 --> 01:00:41.310
should just get
copied over here.

01:00:41.310 --> 01:00:43.760
So I'm going to have
two additional--

01:00:43.760 --> 01:00:46.400
I'm going to have
additional symbols in my--

01:00:46.400 --> 01:00:49.830
dominoes in my collection.

01:00:49.830 --> 01:00:59.480
So for every tape symbol, I'm
going to have aa be a domino.

01:00:59.480 --> 01:01:01.370
So for every tape
symbol a, I'm going

01:01:01.370 --> 01:01:05.050
to have aa be a domino
in my collection.

01:01:05.050 --> 01:01:09.210
And so that says I can have--

01:01:09.210 --> 01:01:11.640
so there's going
to be a 2 2 domino.

01:01:11.640 --> 01:01:13.650
So I can match up
this 2 over here,

01:01:13.650 --> 01:01:16.500
but that forces me to
put a 2 down over there.

01:01:16.500 --> 01:01:18.990
There's also going to
be a 3 3 domino, which

01:01:18.990 --> 01:01:20.640
is going to match
up with that 3,

01:01:20.640 --> 01:01:23.340
but it's going to force me
to put a 3 down over there.

01:01:23.340 --> 01:01:29.600
That's the only way I can extend
this match that I built so far.

01:01:29.600 --> 01:01:32.280
I have no choice.

01:01:32.280 --> 01:01:36.680
Those are the only dominoes
that I'm going to be given.

01:01:36.680 --> 01:01:41.600
And so doing, I'm forcing you to
basically simulate the machine.

01:01:41.600 --> 01:01:43.130
Now, what I want
to have happen next

01:01:43.130 --> 01:01:46.250
is a pound sign to appear
here, and that will conclude

01:01:46.250 --> 01:01:48.540
my second configuration.

01:01:48.540 --> 01:01:52.010
So there's going to be a pound
sign pound sign domino as well

01:01:52.010 --> 01:01:54.170
because there's a
pound sign here.

01:01:54.170 --> 01:01:56.750
It's going to get matched
with the pound sign up top.

01:01:56.750 --> 01:02:00.677
Forces a pound sign to
come down on the bottom.

01:02:00.677 --> 01:02:02.510
And if you look at the
way we are right now,

01:02:02.510 --> 01:02:04.880
we're exactly like where
we were at the beginning

01:02:04.880 --> 01:02:07.400
when we had just this
first domino appearing.

01:02:07.400 --> 01:02:11.830
But now we're one
configuration later.

01:02:11.830 --> 01:02:17.910
So if you understood that,
and I admit that it's--

01:02:17.910 --> 01:02:19.545
there's just one idea here.

01:02:22.300 --> 01:02:25.630
And once you get the
idea, it's all trivial.

01:02:25.630 --> 01:02:26.940
It's all very simple.

01:02:26.940 --> 01:02:29.018
But there's just you
have to get that idea.

01:02:29.018 --> 01:02:31.560
I'm trying to figure out how to
get that idea into your head.

01:02:31.560 --> 01:02:34.275
Once you get the idea, you can
write all this stuff yourself.

01:02:38.960 --> 01:02:45.950
So following this description
of how the transition

01:02:45.950 --> 01:02:48.260
function of the machine
works and copying

01:02:48.260 --> 01:02:53.360
over the symbols from the tape
to the next configuration,

01:02:53.360 --> 01:02:55.100
I'm going to be able
to get configuration

01:02:55.100 --> 01:02:59.592
after configuration going
until I get to a point

01:02:59.592 --> 01:03:00.550
when there's an accept.

01:03:04.290 --> 01:03:07.300
And now, from the machine's
perspective, we're done.

01:03:07.300 --> 01:03:08.890
The machine has
accepted its input.

01:03:08.890 --> 01:03:10.750
This is our computation history.

01:03:10.750 --> 01:03:11.650
But is it a match?

01:03:17.900 --> 01:03:21.230
Well, up until--
this bottom thing

01:03:21.230 --> 01:03:24.440
is the computation history,
but it's not a match

01:03:24.440 --> 01:03:26.330
because the top doesn't
equal the bottom.

01:03:26.330 --> 01:03:32.000
There's still extra stuff at
the bottom, which the top,

01:03:32.000 --> 01:03:33.880
it doesn't have.

01:03:33.880 --> 01:03:35.500
So what I'm going
to need to do now

01:03:35.500 --> 01:03:42.480
is add some additional kind
of pseudo steps of the machine

01:03:42.480 --> 01:03:47.440
where I'm going to allow the
top to catch up to the bottom.

01:03:47.440 --> 01:03:49.510
And the way I'm going to
be thinking about that,

01:03:49.510 --> 01:03:51.355
and this is not real
for a Turing machine

01:03:51.355 --> 01:03:53.230
as much as the Turing
machine is real anyway,

01:03:53.230 --> 01:03:58.270
but you're going to imagine I'm
going to add a new kind of move

01:03:58.270 --> 01:04:00.850
to the machine which is
going to allow the head

01:04:00.850 --> 01:04:05.910
to eat the symbols off
the tape like Pac-Man.

01:04:05.910 --> 01:04:06.410
OK?

01:04:06.410 --> 01:04:11.930
And the way I'm going to
get that effect, on the top,

01:04:11.930 --> 01:04:14.570
if I have any tape
symbol next to a qaccept

01:04:14.570 --> 01:04:19.780
on either side on the top, what
I'm going to get you to write

01:04:19.780 --> 01:04:22.360
on the bottom is just
qaccept with that tas--

01:04:22.360 --> 01:04:25.320
with that tape symbol gone.

01:04:25.320 --> 01:04:30.146
And by repeating
that move after move,

01:04:30.146 --> 01:04:32.255
the actual tape is
going to be shrinking.

01:04:32.255 --> 01:04:33.630
The symbols on
the tape are going

01:04:33.630 --> 01:04:36.390
to be going down one
by one, move by move,

01:04:36.390 --> 01:04:40.770
until there's nothing left
except just the qaccept

01:04:40.770 --> 01:04:42.720
all by itself.

01:04:42.720 --> 01:04:43.220
OK?

01:04:43.220 --> 01:04:45.260
So I have this sort
of Pac-Man idea.

01:04:45.260 --> 01:04:48.050
I'll be eating the
symbols on the tape.

01:04:48.050 --> 01:04:51.410
And then finally,
I get to a point

01:04:51.410 --> 01:04:55.220
when there's just the
qaccept alone on the tape.

01:04:55.220 --> 01:04:57.900
There's no symbols
left to consume.

01:04:57.900 --> 01:05:00.250
And then I'm going to
add one last domino here,

01:05:00.250 --> 01:05:03.030
which is qaccept
pound pound matching

01:05:03.030 --> 01:05:12.344
with just pound, which just
conveniently finishes off

01:05:12.344 --> 01:05:14.090
the match.

01:05:14.090 --> 01:05:15.985
And so the match is completed.

01:05:15.985 --> 01:05:18.340
This is actually a
little detailed here.

01:05:18.340 --> 01:05:20.530
I hesitate even to
bring it up because I

01:05:20.530 --> 01:05:22.330
think it's the
kind of thing where

01:05:22.330 --> 01:05:25.000
if you understand
everything up to this point,

01:05:25.000 --> 01:05:26.350
you could fill it in yourself.

01:05:26.350 --> 01:05:28.810
But just for
completeness' sake, you

01:05:28.810 --> 01:05:35.950
have to deal with the situation
when the head of the Turing

01:05:35.950 --> 01:05:38.560
machine might move
into the blank portion

01:05:38.560 --> 01:05:42.080
of the tape, which is not
taken into account here.

01:05:42.080 --> 01:05:46.450
And the way we get that effect
is by having another domino

01:05:46.450 --> 01:05:49.630
here, which allows me to add
blank symbols at the bottom as

01:05:49.630 --> 01:05:51.510
needed.

01:05:51.510 --> 01:05:53.510
That's just a detail.

01:05:53.510 --> 01:05:55.760
I'm more worried
that you understand

01:05:55.760 --> 01:05:57.900
the underlying concept.

01:05:57.900 --> 01:06:04.730
So here is going
to be a check-in.

01:06:04.730 --> 01:06:05.823
I'm trying to remember--

01:06:09.850 --> 01:06:10.350
OK.

01:06:10.350 --> 01:06:12.810
But so OK.

01:06:12.810 --> 01:06:18.150
So what else can we conclude
from this information?

01:06:18.150 --> 01:06:21.350
So we know-- at this point, we
know that PCP is undecidable.

01:06:21.350 --> 01:06:24.200
That's what we just
finished proving.

01:06:24.200 --> 01:06:27.460
What else do we
know, if anything?

01:06:27.460 --> 01:06:29.731
Or do we even know that?

01:06:29.731 --> 01:06:30.248
Let's see.

01:06:30.248 --> 01:06:32.290
My picture is a little
bit covering the check-in,

01:06:32.290 --> 01:06:33.415
but it's still readable.

01:06:42.800 --> 01:06:46.550
So I mean, this is not an
easy concept to get the idea.

01:06:46.550 --> 01:06:53.350
But once you get it, you'll
see it's not that bad.

01:06:56.290 --> 01:06:57.640
OK.

01:06:57.640 --> 01:06:58.510
Another 15 seconds.

01:07:05.700 --> 01:07:08.000
So this portion-- this
question is not really

01:07:08.000 --> 01:07:11.540
relying so much on the
computation history method.

01:07:11.540 --> 01:07:17.030
It's just relying on the fact
about PCP being undecidable.

01:07:20.830 --> 01:07:21.340
OK.

01:07:21.340 --> 01:07:24.540
Everybody almost done?

01:07:24.540 --> 01:07:27.440
Five seconds.

01:07:27.440 --> 01:07:27.950
All right.

01:07:31.940 --> 01:07:36.500
So I can see that there is
some level of confusion.

01:07:39.730 --> 01:07:46.330
So the reason why
B is correct is

01:07:46.330 --> 01:07:52.360
that we know PCP is
undecidable, but we also

01:07:52.360 --> 01:07:54.910
know that it's recognizable
because you could

01:07:54.910 --> 01:07:58.570
try all possible
ways of combining

01:07:58.570 --> 01:08:04.780
dominoes and one after the
next, except if you ever

01:08:04.780 --> 01:08:06.760
find a match.

01:08:06.760 --> 01:08:08.190
So that might go forever.

01:08:08.190 --> 01:08:10.800
But if there is a
match of a possible,

01:08:10.800 --> 01:08:12.000
you'll find it eventually.

01:08:12.000 --> 01:08:15.600
So PCP is a
recognizable language.

01:08:15.600 --> 01:08:16.873
Undecidable.

01:08:16.873 --> 01:08:18.540
And so therefore, we
know its complement

01:08:18.540 --> 01:08:21.660
has to be unrecognizable
because that's

01:08:21.660 --> 01:08:23.470
something we've shown before.

01:08:23.470 --> 01:08:25.840
If a language and its complement
are both recognizable,

01:08:25.840 --> 01:08:28.420
then it's decidable, but we
know PCP is not decidable,

01:08:28.420 --> 01:08:31.960
so both sides can't
be recognizable.

01:08:31.960 --> 01:08:32.460
OK.

01:08:32.460 --> 01:08:38.870
So let me prove to
you one last theorem

01:08:38.870 --> 01:08:42.890
that's going to be useful
for your homework involving

01:08:42.890 --> 01:08:44.430
the computation history method.

01:08:44.430 --> 01:08:47.060
So you'll have one
last chance to get

01:08:47.060 --> 01:08:50.779
the way we're going to
use this, though this one

01:08:50.779 --> 01:08:55.430
is going to be a little bit more
similar in spirit to the LBA

01:08:55.430 --> 01:08:58.250
version than to the
PCP version, which

01:08:58.250 --> 01:09:00.080
has this extra kind
of complication

01:09:00.080 --> 01:09:04.670
about coding the computations
of the machine into dominoes.

01:09:04.670 --> 01:09:09.707
Here, we're going to operate
with another automaton which

01:09:09.707 --> 01:09:11.540
where it's going to be
more straightforward.

01:09:11.540 --> 01:09:12.560
But anyway, OK.

01:09:12.560 --> 01:09:14.160
Getting ahead of myself.

01:09:14.160 --> 01:09:18.260
So if you remember, for
context-free grammars,

01:09:18.260 --> 01:09:22.240
we had the ECFG problem,
the emptiness problem.

01:09:22.240 --> 01:09:24.979
We showed that was decidable.

01:09:24.979 --> 01:09:27.529
So testing whether a
context-free grammar's language

01:09:27.529 --> 01:09:30.310
is empty is decidable.

01:09:30.310 --> 01:09:34.600
However, testing whether a
context-free grammar's language

01:09:34.600 --> 01:09:38.170
is everything, whether
it's equal to sigma star,

01:09:38.170 --> 01:09:39.640
that turns out to be--

01:09:42.750 --> 01:09:45.590
that turns out to
be undecidable.

01:09:45.590 --> 01:09:46.090
OK?

01:09:46.090 --> 01:09:48.085
So emptiness testing for
context-free grammars,

01:09:48.085 --> 01:09:49.750
decidable.

01:09:49.750 --> 01:09:53.527
Sigma star testing, undecidable.

01:09:56.340 --> 01:09:56.840
OK.

01:09:56.840 --> 01:10:00.980
So we'll show that ATM
is reducible to old PDA

01:10:00.980 --> 01:10:04.340
via the computation
history method.

01:10:04.340 --> 01:10:10.770
And so assume we
have same patterns.

01:10:10.770 --> 01:10:12.920
Assume we have a
decider for all PDA

01:10:12.920 --> 01:10:15.200
and make a decider for old t--

01:10:15.200 --> 01:10:17.990
decider for ATM.

01:10:17.990 --> 01:10:20.120
Here's the ATM decider.

01:10:20.120 --> 01:10:26.510
And now, similar to what
we did for the LBA case,

01:10:26.510 --> 01:10:29.330
but with a twist.

01:10:29.330 --> 01:10:33.000
We're going to make a
pushdown automaton that's

01:10:33.000 --> 01:10:35.520
going to check its input
to see whether it's

01:10:35.520 --> 01:10:38.220
an accepting computation
history of M on w.

01:10:38.220 --> 01:10:42.610
Just like the LBA did, if you
think back to how that worked.

01:10:42.610 --> 01:10:46.470
Remember, the LBA
tested its input

01:10:46.470 --> 01:10:50.340
to see whether it's an
accepted computation history.

01:10:50.340 --> 01:10:52.320
Accepted if it did,
and then we test

01:10:52.320 --> 01:10:54.690
the LBA's language for
emptiness to see if there

01:10:54.690 --> 01:10:56.520
are any computation histories.

01:10:56.520 --> 01:10:58.680
So we're doing the
same kind of thing,

01:10:58.680 --> 01:11:03.230
except now, the PDA is
going to test its input

01:11:03.230 --> 01:11:06.380
to see whether it's an
accepting computation history,

01:11:06.380 --> 01:11:09.930
and if it is, it's
going to reject.

01:11:09.930 --> 01:11:15.600
It's going to do the
reverse of what the LBA did.

01:11:15.600 --> 01:11:17.790
And that's going to turn
out to be necessary.

01:11:17.790 --> 01:11:20.520
But for the moment,
let's just go with it,

01:11:20.520 --> 01:11:23.670
and maybe we'll see it in the
proof, why the proof needs

01:11:23.670 --> 01:11:25.080
it to be this way.

01:11:25.080 --> 01:11:28.380
So this pushdown
automaton is going

01:11:28.380 --> 01:11:32.040
to accept its input if
it's not in accepting

01:11:32.040 --> 01:11:33.690
computation history for M on w.

01:11:33.690 --> 01:11:35.050
Otherwise, it will accept.

01:11:35.050 --> 01:11:39.990
So you can think of this
PDA as accepting all junk.

01:11:39.990 --> 01:11:45.110
It just doesn't
accept the good stuff,

01:11:45.110 --> 01:11:48.180
the accepting
computation history.

01:11:48.180 --> 01:11:49.140
OK?

01:11:49.140 --> 01:11:52.050
It's accepting all
the things which

01:11:52.050 --> 01:11:55.500
fail to be an accepting
computation history.

01:11:55.500 --> 01:11:56.130
OK?

01:11:56.130 --> 01:12:00.630
And then once we have that,
we test whether R's language

01:12:00.630 --> 01:12:06.290
is everything, whether BMw's
language is everything using R.

01:12:06.290 --> 01:12:12.080
Because if that PDA's
language is everything,

01:12:12.080 --> 01:12:17.810
then we know there could not
be an accepting computation

01:12:17.810 --> 01:12:27.560
history because that's the one
thing that gets not accepted.

01:12:27.560 --> 01:12:29.367
That's the one thing
that gets rejected.

01:12:29.367 --> 01:12:30.950
So if it's accepting
everything, there

01:12:30.950 --> 01:12:34.940
is not going to be an
accepting computation history.

01:12:34.940 --> 01:12:37.160
So if there is no--

01:12:37.160 --> 01:12:39.770
if this is equal to
sigma star, then there

01:12:39.770 --> 01:12:41.790
couldn't be an accepting
computation history,

01:12:41.790 --> 01:12:43.290
and so we're going to accept.

01:12:43.290 --> 01:12:43.790
OK.

01:12:43.790 --> 01:12:45.170
So how is this going to work?

01:12:45.170 --> 01:12:52.390
So what's different now about
this case from the LBA case

01:12:52.390 --> 01:12:59.170
is remember, the LBA got
the computation history

01:12:59.170 --> 01:13:02.230
on its input, and
it used its ability

01:13:02.230 --> 01:13:06.370
to write on the tape to
check that each configuration

01:13:06.370 --> 01:13:08.050
followed the next one.

01:13:08.050 --> 01:13:11.420
We don't have the ability to
write on the tape in a pushdown

01:13:11.420 --> 01:13:12.010
automaton.

01:13:12.010 --> 01:13:13.385
And by the way,
I hope you're all

01:13:13.385 --> 01:13:16.570
comfortable with my using
PDAs instead of grammars

01:13:16.570 --> 01:13:19.520
because we can interchange
one to the other.

01:13:19.520 --> 01:13:21.550
Should have mentioned
that when I did it.

01:13:21.550 --> 01:13:26.980
But so the PDA is going
to be using its stack

01:13:26.980 --> 01:13:31.240
to compare each configuration
with the next one, OK?

01:13:31.240 --> 01:13:33.820
So the way that's going
to happen is it's going

01:13:33.820 --> 01:13:37.040
to non-deterministically
take one of these--

01:13:37.040 --> 01:13:40.810
so the very first thing
it does is, as before, it

01:13:40.810 --> 01:13:44.350
checks to make sure that
the beginning of the input

01:13:44.350 --> 01:13:46.150
is the start configuration.

01:13:46.150 --> 01:13:48.080
But then once that's--
that's the easy part.

01:13:48.080 --> 01:13:53.350
But once we get going with that,
we push each configuration--

01:13:53.350 --> 01:13:56.170
well, first of all, we
non-deterministically

01:13:56.170 --> 01:13:59.200
choose which
configuration might be

01:13:59.200 --> 01:14:05.377
the one that fails where one
fails to go to the next one.

01:14:05.377 --> 01:14:07.460
Because those are the ones
we're trying to accept,

01:14:07.460 --> 01:14:08.418
when there's a failure.

01:14:10.673 --> 01:14:12.840
So we're now determined to
simply look for the place

01:14:12.840 --> 01:14:14.130
that there's a failure.

01:14:14.130 --> 01:14:19.020
We push that onto the stack,
and then we pop it off the stack

01:14:19.020 --> 01:14:22.770
and compare it with
the next configuration.

01:14:22.770 --> 01:14:25.190
So that's how we're using
the stack instead of being

01:14:25.190 --> 01:14:27.380
able to mark on the input.

01:14:27.380 --> 01:14:30.660
Now there's a-- so I'm kind of
going to illustrate that here.

01:14:30.660 --> 01:14:34.110
So as we're going to
read this thing here,

01:14:34.110 --> 01:14:35.850
I'm going to put
it onto the stack.

01:14:35.850 --> 01:14:37.790
So this thing
moves over to here,

01:14:37.790 --> 01:14:43.290
and this input here
got put onto the stack.

01:14:43.290 --> 01:14:46.480
q0, w1, w1, it's q0, w1, w2.

01:14:46.480 --> 01:14:47.140
You see that.

01:14:47.140 --> 01:14:49.760
That first configuration is
now sitting on the stack.

01:14:49.760 --> 01:14:51.640
Now, as we're going
to pop it off,

01:14:51.640 --> 01:14:55.860
we're going to match it with
the second configuration.

01:14:55.860 --> 01:14:58.140
Now, if you're
following me, you'll

01:14:58.140 --> 01:15:00.270
realize that there's
a difficulty here

01:15:00.270 --> 01:15:02.940
because it's coming
out in reverse.

01:15:02.940 --> 01:15:05.820
It comes out in the reverse
order that we put it in,

01:15:05.820 --> 01:15:08.480
and that's not what
we needed to do.

01:15:08.480 --> 01:15:10.230
So what we're going
to do here, and here's

01:15:10.230 --> 01:15:12.480
a little sort of a
twist, we're going

01:15:12.480 --> 01:15:15.300
to change the way we're
writing down computation

01:15:15.300 --> 01:15:17.250
histories by making them--

01:15:17.250 --> 01:15:20.512
by writing them-- reversing
the even-numbered ones.

01:15:20.512 --> 01:15:22.845
So this one here is going to
be written down in reverse.

01:15:27.910 --> 01:15:29.170
And that's perfectly OK.

01:15:29.170 --> 01:15:32.050
We can write down
computation histories

01:15:32.050 --> 01:15:35.660
in any way we want
to meet our needs.

01:15:35.660 --> 01:15:37.000
So we're going to reverse--

01:15:37.000 --> 01:15:39.010
we're going to reverse
the alternate ones.

01:15:39.010 --> 01:15:41.230
And now, when we
push one, it's going

01:15:41.230 --> 01:15:44.380
to come off in the right order
to compare with the next one.

01:15:44.380 --> 01:15:47.080
And so that's how
the procedure works.

01:15:47.080 --> 01:15:48.620
OK?

01:15:48.620 --> 01:15:52.475
We're running a
little short on time.

01:15:52.475 --> 01:15:53.350
You need to be able--

01:15:53.350 --> 01:15:53.930
let's see.

01:15:53.930 --> 01:16:00.680
So let me just go
to a quick recap.

01:16:00.680 --> 01:16:02.630
The computation
history method is

01:16:02.630 --> 01:16:05.060
useful for showing the
undecidability of problems

01:16:05.060 --> 01:16:08.860
when you're testing for
the existence of an object.

01:16:08.860 --> 01:16:11.100
Each of those four cases
that we showed today

01:16:11.100 --> 01:16:13.710
involved in testing
whether something exists.

01:16:13.710 --> 01:16:17.460
So is there an integer
solution to the polynomial?

01:16:17.460 --> 01:16:19.530
Is there some string
in the language?

01:16:19.530 --> 01:16:22.830
Is there string that's
not in the language?

01:16:22.830 --> 01:16:25.000
Or is there a match?

01:16:25.000 --> 01:16:30.300
So that's a typical case
when this computation history

01:16:30.300 --> 01:16:32.710
method comes up.

01:16:32.710 --> 01:16:39.890
And so as a quick review, these
are the things we showed today.

01:16:39.890 --> 01:16:41.980
OK, so why don't we--

01:16:41.980 --> 01:16:44.070
we're just out of time.

01:16:44.070 --> 01:16:47.930
And so I'm going to
let you go, but I

01:16:47.930 --> 01:16:52.280
will stick around for another
5 minutes or 10 minutes.

01:16:52.280 --> 01:16:55.070
Happy to answer any
questions if you have them,

01:16:55.070 --> 01:16:58.730
but that's officially
the end of the lecture.

01:16:58.730 --> 01:16:59.780
OK.

01:16:59.780 --> 01:17:01.850
So let me try to
get to-- there's

01:17:01.850 --> 01:17:03.440
a lot of questions in the chat.

01:17:03.440 --> 01:17:05.360
Don't forget, write
to the TAs too.

01:17:15.610 --> 01:17:21.010
So if M does not accept w, what
will happen to the computation

01:17:21.010 --> 01:17:21.760
history?

01:17:21.760 --> 01:17:25.990
So if M does not
accept w, then there

01:17:25.990 --> 01:17:29.725
is no computation-- there is no
accepting computation history.

01:17:29.725 --> 01:17:31.600
That's the only kind of
competition histories

01:17:31.600 --> 01:17:33.260
we're considering.

01:17:33.260 --> 01:17:36.300
So if M does not accept w, there
is no accepting computation

01:17:36.300 --> 01:17:36.800
history.

01:17:36.800 --> 01:17:38.970
There's no computation history.

01:17:38.970 --> 01:17:41.220
So I don't know what it
means, what will happen to it.

01:17:41.220 --> 01:17:44.520
It just doesn't exist.

01:17:44.520 --> 01:17:49.020
So I hope that's helpful.

01:17:52.990 --> 01:17:56.470
Don't we need to be able to add
states to the end of the tape?

01:17:56.470 --> 01:17:57.850
Hm.

01:17:57.850 --> 01:17:59.650
I don't know what that means.

01:17:59.650 --> 01:18:03.000
Add states to the
end of the tape.

01:18:03.000 --> 01:18:05.850
I don't under-- you'll have
to repeat that one, sorry,

01:18:05.850 --> 01:18:07.170
or explain that better.

01:18:11.283 --> 01:18:13.123
Ah.

01:18:13.123 --> 01:18:15.290
So this is a go-- this is
a very good question here.

01:18:15.290 --> 01:18:18.140
Where does the previous
proof fail when

01:18:18.140 --> 01:18:22.040
trying to reduce ATM to ECFG?

01:18:22.040 --> 01:18:26.930
It's got to fail because
ECFG is decidable.

01:18:26.930 --> 01:18:28.500
So that's a very good question.

01:18:28.500 --> 01:18:32.210
Maybe we can just go back
to that last slide here.

01:18:35.325 --> 01:18:37.200
Because I was running
a little short on time,

01:18:37.200 --> 01:18:40.080
I didn't really
focus on why we have

01:18:40.080 --> 01:18:47.000
to accept the non-computation
history strings.

01:18:47.000 --> 01:18:49.470
Why are we accepting
all the junk strings

01:18:49.470 --> 01:18:54.900
and only rejecting
the strings which

01:18:54.900 --> 01:18:57.480
are the computation histories?

01:18:57.480 --> 01:19:01.560
So we're looking for
strings that fail.

01:19:01.560 --> 01:19:05.070
A string could fail
because it starts wrong.

01:19:05.070 --> 01:19:08.150
It doesn't have the
start configuration.

01:19:08.150 --> 01:19:11.150
Or it maybe doesn't end with
the accepting configuration.

01:19:11.150 --> 01:19:13.700
Or maybe one configuration
doesn't lead properly

01:19:13.700 --> 01:19:15.080
to the next one.

01:19:15.080 --> 01:19:17.300
Any of those cases
are a failure,

01:19:17.300 --> 01:19:19.175
and are going to be
a reason to accept.

01:19:22.770 --> 01:19:27.720
The reason why we can
do that is because we're

01:19:27.720 --> 01:19:30.390
taking advantage of the
pushdowns non-determinism.

01:19:30.390 --> 01:19:37.150
We don't know where the
failure might occur,

01:19:37.150 --> 01:19:39.090
so we're going to
non-deterministically guess

01:19:39.090 --> 01:19:41.160
where that failure occurs.

01:19:41.160 --> 01:19:43.170
If we were going
to flip this around

01:19:43.170 --> 01:19:47.540
and say let's accept
only the good ones

01:19:47.540 --> 01:19:50.450
and reject everything
else, we would

01:19:50.450 --> 01:19:53.660
have to test that
each configuration led

01:19:53.660 --> 01:19:55.650
to the next one.

01:19:55.650 --> 01:19:57.910
So we'd have to check them all.

01:19:57.910 --> 01:20:01.800
So if something fails, it
only has to fail in one place,

01:20:01.800 --> 01:20:05.790
and then we can accept.

01:20:05.790 --> 01:20:09.780
If it's a good computation
history, we have to--

01:20:09.780 --> 01:20:12.270
it has to be good everywhere.

01:20:12.270 --> 01:20:13.880
And so the pushdown
automaton, really,

01:20:13.880 --> 01:20:15.880
if you're going to get
down to the nitty gritty,

01:20:15.880 --> 01:20:18.770
the pushdown automaton can check
that this configuration leads

01:20:18.770 --> 01:20:23.540
to that configuration pushing on
the stack and then popping it.

01:20:23.540 --> 01:20:25.610
But now, by the time
you get to here,

01:20:25.610 --> 01:20:27.860
you want to check that this
second configuration leads

01:20:27.860 --> 01:20:29.870
to the third one.

01:20:29.870 --> 01:20:32.120
You would need to push the
second configuration onto

01:20:32.120 --> 01:20:36.020
the stack, but at this point,
you're already after the second

01:20:36.020 --> 01:20:39.590
configuration, so we cannot
back up and push the second one

01:20:39.590 --> 01:20:41.570
on the stack.

01:20:41.570 --> 01:20:46.630
So the pushdown automaton
is not able to check

01:20:46.630 --> 01:20:49.930
in the positive sense that you
have a computation history.

01:20:49.930 --> 01:20:51.983
It's only able to--
and accept them.

01:20:51.983 --> 01:20:53.650
It's only to check
in the negative sense

01:20:53.650 --> 01:20:57.850
that you don't have
a computation history

01:20:57.850 --> 01:21:01.370
and accept all the
ones that fail.

01:21:01.370 --> 01:21:06.510
And that's just because it
only has to fail in one place.

01:21:06.510 --> 01:21:08.910
I hope that helps.

01:21:08.910 --> 01:21:12.870
So that's why we couldn't flip
this around and make this proof

01:21:12.870 --> 01:21:14.610
work for the emptiness
problem and only

01:21:14.610 --> 01:21:18.000
have to work for the everything
problem, the all problem.

01:21:20.680 --> 01:21:21.180
All right.

01:21:24.490 --> 01:21:29.250
OK, so bye-bye everybody, and
I will see you on Tuesday.