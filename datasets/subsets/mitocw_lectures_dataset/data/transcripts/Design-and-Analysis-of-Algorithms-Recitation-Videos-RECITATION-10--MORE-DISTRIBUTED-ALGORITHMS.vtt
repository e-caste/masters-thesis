WEBVTT

00:00:00.080 --> 00:00:02.500
The following content is
provided under a Creative

00:00:02.500 --> 00:00:04.019
Commons license.

00:00:04.019 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.730
continue to offer high-quality
educational resources for free.

00:00:10.730 --> 00:00:13.350
To make a donation or
view additional materials

00:00:13.350 --> 00:00:17.217
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.217 --> 00:00:17.842
at ocw.mit.edu.

00:00:21.257 --> 00:00:22.090
LING REN: All right.

00:00:22.090 --> 00:00:24.030
Let's get started.

00:00:24.030 --> 00:00:28.250
Today's topic would be
distributed algorithms.

00:00:28.250 --> 00:00:31.900
We will look at
two new algorithms.

00:00:31.900 --> 00:00:35.210
But they are similar to what
you have seen in the lectures.

00:00:35.210 --> 00:00:38.930
So it will also be a review
of some concepts in lectures.

00:00:52.250 --> 00:00:56.130
So our first example
would be, again,

00:00:56.130 --> 00:00:59.390
[INAUDIBLE], the
simplest example.

00:01:05.670 --> 00:01:11.730
But this time, the network
and topology would be a ring.

00:01:21.810 --> 00:01:25.700
So in the lectures,
the example we see

00:01:25.700 --> 00:01:28.570
is a click, meaning they
are fully connected.

00:01:28.570 --> 00:01:29.070
Right.

00:01:29.070 --> 00:01:32.340
Every node can talk
to every other node.

00:01:32.340 --> 00:01:36.240
There, if you remember,
our solution for everyone

00:01:36.240 --> 00:01:39.100
to generate a UID
or a random number.

00:01:39.100 --> 00:01:45.260
And if you are the maximum, then
you output, you're the leader

00:01:45.260 --> 00:01:48.610
You can do that because, yeah,
you are connected to everybody.

00:01:48.610 --> 00:01:52.000
So you immediately know
what random number everybody

00:01:52.000 --> 00:01:52.640
generates.

00:01:52.640 --> 00:01:55.870
And you can compare whether
you are the largest.

00:01:55.870 --> 00:02:00.830
Now, the idea is the
same if we have a ring.

00:02:00.830 --> 00:02:04.940
So you want everyone to
generate a ID or random number.

00:02:04.940 --> 00:02:07.550
I'll just say ID from now on.

00:02:07.550 --> 00:02:11.780
And you want to collect
everyone else ID

00:02:11.780 --> 00:02:13.840
so that you know
whether your ID is

00:02:13.840 --> 00:02:18.326
the largest among all of them.

00:02:18.326 --> 00:02:18.826
OK.

00:02:24.754 --> 00:02:28.212
AUDIENCE: [INAUDIBLE]

00:02:29.480 --> 00:02:30.188
LING REN: Pardon?

00:02:30.188 --> 00:02:33.152
AUDIENCE: [INAUDIBLE]

00:02:34.289 --> 00:02:34.830
LING REN: OK.

00:02:34.830 --> 00:02:39.270
The question is where did
the comparison happen?

00:02:39.270 --> 00:02:42.200
So we first need
some way to pass

00:02:42.200 --> 00:02:44.810
the numbers around
such that everyone

00:02:44.810 --> 00:02:47.370
has everyone else's number.

00:02:47.370 --> 00:02:47.870
Right.

00:02:47.870 --> 00:02:49.460
You have the number
of everyone, then

00:02:49.460 --> 00:02:52.791
you can compare whether
the largest equals yours.

00:02:52.791 --> 00:02:53.290
OK.

00:02:53.290 --> 00:02:55.000
If the largest equals
yours, then you

00:02:55.000 --> 00:02:56.041
know you are the largest.

00:02:56.041 --> 00:03:01.130
And you're going to
output, I'm the leader.

00:03:01.130 --> 00:03:01.630
OK.

00:03:01.630 --> 00:03:05.300
So the difficulty is just
how to pass the numbers

00:03:05.300 --> 00:03:08.220
around so that everyone
sees everyone else's number.

00:03:11.120 --> 00:03:12.790
Any ideas?

00:03:12.790 --> 00:03:13.520
Simple solution.

00:03:39.755 --> 00:03:41.590
Well, there's not
much you can do.

00:03:41.590 --> 00:03:43.990
You are just connect to your
two neighbors, the left one

00:03:43.990 --> 00:03:44.740
and the right one.

00:03:54.800 --> 00:03:56.835
So how do you propagate
the information?

00:04:06.134 --> 00:04:07.130
Go ahead.

00:04:07.130 --> 00:04:10.616
AUDIENCE: You can take
the maximum of your ID

00:04:10.616 --> 00:04:14.579
and neighbor's IDs and
kind of broadcast that.

00:04:14.579 --> 00:04:15.120
LING REN: OK.

00:04:15.120 --> 00:04:16.519
So what does
broadcast mean here?

00:04:16.519 --> 00:04:17.935
AUDIENCE: Like
tell your neighbors

00:04:17.935 --> 00:04:21.720
what the largest of
your value [INAUDIBLE]

00:04:21.720 --> 00:04:23.230
LING REN: OK.

00:04:23.230 --> 00:04:25.170
And yes.

00:04:25.170 --> 00:04:32.650
Let me call them A, B, C, E,
F. Then, yes, C can tell D

00:04:32.650 --> 00:04:35.167
or can tell B, but
how does C tell E?

00:04:41.498 --> 00:04:47.267
AUDIENCE: It waited around to
I guess propagate the maximum.

00:04:47.267 --> 00:04:47.850
LING REN: Yep.

00:04:47.850 --> 00:04:53.970
So it would be just,
say, everyone talks

00:04:53.970 --> 00:04:55.660
to its right neighbor.

00:04:55.660 --> 00:04:58.930
And then B has A's IDs, C
these B's ID, D has C's ID,

00:04:58.930 --> 00:05:02.360
and then continue and
pass around next time.

00:05:05.390 --> 00:05:08.260
So just to make
it perfect clear.

00:05:08.260 --> 00:05:15.280
Say they generate some
random IDs that's 5, 10, 20.

00:05:15.280 --> 00:05:19.035
And then in the next round,
A would send its ID to B, B

00:05:19.035 --> 00:05:22.470
would send its ID to C,
C would send its ID to D.

00:05:22.470 --> 00:05:25.520
And in the next round, B would
pass this information along

00:05:25.520 --> 00:05:28.930
to C. And C would pass
the information to D.

00:05:28.930 --> 00:05:31.320
And just continue.

00:05:31.320 --> 00:05:36.240
And eventually everyone will
have everyone else's ID.

00:05:36.240 --> 00:05:38.720
So how many rounds do we need?

00:05:51.790 --> 00:05:58.001
If they are in
nodes in the system.

00:05:58.001 --> 00:06:00.292
AUDIENCE: I think probably
in just one direction or two

00:06:00.292 --> 00:06:02.110
neighbors.

00:06:02.110 --> 00:06:05.190
LING REN: I think you
can do it either way.

00:06:05.190 --> 00:06:09.914
If you propagate both ways,
it probably 2x faster, yeah.

00:06:09.914 --> 00:06:11.390
AUDIENCE: [INAUDIBLE]

00:06:11.390 --> 00:06:12.870
LING REN: Yeah, correct.

00:06:12.870 --> 00:06:14.700
It's just O(n).

00:06:14.700 --> 00:06:16.810
But to keep it simple,
let's say we just

00:06:16.810 --> 00:06:18.240
propagate in one direction.

00:06:18.240 --> 00:06:19.030
That's also fine.

00:06:19.030 --> 00:06:21.340
Still O(n).

00:06:21.340 --> 00:06:25.983
So how many messages
are sent in total?

00:06:25.983 --> 00:06:28.388
AUDIENCE: n squared.

00:06:28.388 --> 00:06:29.487
LING REN: Pardon?

00:06:29.487 --> 00:06:30.320
AUDIENCE: n squared.

00:06:30.320 --> 00:06:31.399
LING REN: n squared.

00:06:31.399 --> 00:06:31.898
Yep.

00:06:34.590 --> 00:06:37.660
Is that obvious to everyone?

00:06:37.660 --> 00:06:38.160
OK.

00:06:38.160 --> 00:06:40.132
Give an explanation.

00:06:40.132 --> 00:06:41.715
AUDIENCE: Yeah, at
each round everyone

00:06:41.715 --> 00:06:44.900
sends a message
to its neighbors.

00:06:44.900 --> 00:06:45.900
LING REN: Yeah.

00:06:45.900 --> 00:06:48.030
Yeah.

00:06:48.030 --> 00:06:50.350
Every round, everyone
sends a message.

00:06:50.350 --> 00:06:54.550
Or you can think of every
message as propagated n times.

00:06:54.550 --> 00:06:58.700
And there are n
messages in total.

00:06:58.700 --> 00:07:00.171
OK.

00:07:00.171 --> 00:07:00.670
Yeah.

00:07:00.670 --> 00:07:04.180
That's definitely a solution.

00:07:04.180 --> 00:07:07.000
Well, you can imagine, it's
probably the naive solution.

00:07:07.000 --> 00:07:09.220
And can we do better than that?

00:07:14.566 --> 00:07:16.996
AUDIENCE: In this case,
are we assuming they

00:07:16.996 --> 00:07:18.454
know that there are n of them?

00:07:21.380 --> 00:07:22.280
LING REN: OK.

00:07:22.280 --> 00:07:23.370
Good question.

00:07:23.370 --> 00:07:25.989
So if they know
there are n of them,

00:07:25.989 --> 00:07:27.530
yep, then they know
how to terminate.

00:07:27.530 --> 00:07:30.230
So your question is how
to terminate, right?

00:07:30.230 --> 00:07:35.070
If they don't, eventually
you will receive your own ID

00:07:35.070 --> 00:07:36.230
on the other side.

00:07:36.230 --> 00:07:38.850
If we keep sending
left, eventually you

00:07:38.850 --> 00:07:40.600
will receive it
on the left port.

00:07:40.600 --> 00:07:44.265
And, yeah, that's an
indication of termination.

00:07:47.498 --> 00:07:47.998
Question?

00:07:47.998 --> 00:07:49.664
AUDIENCE: Are we
assuming the trajectory

00:07:49.664 --> 00:07:51.165
that these are unique?

00:07:51.165 --> 00:07:51.790
LING REN: Yeah.

00:07:51.790 --> 00:07:55.480
We usually assume that, yeah.

00:07:55.480 --> 00:08:00.420
Either it's a unique
user-- sorry, UID.

00:08:00.420 --> 00:08:02.260
What does U stand
for by the way?

00:08:02.260 --> 00:08:06.630
Or if you generate random
numbers in a large range,

00:08:06.630 --> 00:08:08.180
it's very unlikely
that they collide.

00:08:20.560 --> 00:08:21.230
OK.

00:08:21.230 --> 00:08:22.480
So can we do better than that?

00:08:37.990 --> 00:08:40.700
You have some idea?

00:08:40.700 --> 00:08:47.560
AUDIENCE: Once
something [INAUDIBLE]

00:08:47.560 --> 00:08:52.204
where you only pass it
to the one that's bigger.

00:08:52.204 --> 00:08:52.870
LING REN: Hm-mm.

00:08:52.870 --> 00:08:53.200
OK.

00:08:53.200 --> 00:08:54.490
I think you have two ideas.

00:08:54.490 --> 00:08:58.080
And binary search, we'll
see how that works later.

00:08:58.080 --> 00:09:01.250
So you said only forward
something that's larger?

00:09:01.250 --> 00:09:02.580
0

00:09:02.580 --> 00:09:04.746
AUDIENCE: Yeah, like only
forward things are larger.

00:09:08.014 --> 00:09:09.930
LING REN: OK, yeah,
that's on the right track.

00:09:09.930 --> 00:09:13.730
So one obvious
thing we can do is

00:09:13.730 --> 00:09:18.920
that so we actually don't care
what all the IDs are, right.

00:09:18.920 --> 00:09:23.100
We only care whether a
certain ID's the largest.

00:09:23.100 --> 00:09:29.060
So for example, in this case,
when A send its ID 5 to B,

00:09:29.060 --> 00:09:32.210
B knows this 5
won't be the leader.

00:09:32.210 --> 00:09:32.710
All right.

00:09:32.710 --> 00:09:33.970
Because 5 is too small.

00:09:33.970 --> 00:09:36.220
It's even smaller than his ID.

00:09:36.220 --> 00:09:40.190
So we can choose to
drop this message.

00:09:40.190 --> 00:09:44.720
There's no point in passing
that message further.

00:09:44.720 --> 00:09:46.810
Same thing for this message.

00:09:46.810 --> 00:09:49.420
C knows that 10 is too small.

00:09:49.420 --> 00:09:53.980
And it doesn't have
to pass it along.

00:09:53.980 --> 00:09:57.452
AUDIENCE: [INAUDIBLE]

00:09:58.940 --> 00:09:59.940
LING REN: Oh, the ID?

00:09:59.940 --> 00:10:03.460
It's just the integer each
node chooses at random.

00:10:03.460 --> 00:10:06.210
See.

00:10:06.210 --> 00:10:10.280
Yeah, the only purpose of
the ID is to break symmetry.

00:10:10.280 --> 00:10:11.720
So, yeah.

00:10:11.720 --> 00:10:14.230
Like we have seen the lecture,
if they don't do this,

00:10:14.230 --> 00:10:17.284
if they don't have
any unique identifier,

00:10:17.284 --> 00:10:18.950
they won't be able
to select the leader.

00:10:21.570 --> 00:10:25.120
And when they have
a unique number,

00:10:25.120 --> 00:10:28.100
then they can select, yeah,
the largest one or smallest

00:10:28.100 --> 00:10:30.210
one in some way.

00:10:34.490 --> 00:10:34.990
OK.

00:10:34.990 --> 00:10:37.190
Does this optimization
make sense?

00:10:37.190 --> 00:10:42.650
We can cut [INAUDIBLE]
messages that

00:10:42.650 --> 00:10:47.365
have no chance of
becoming the leader.

00:10:47.365 --> 00:10:49.031
AUDIENCE: What is the
upper bound of it?

00:10:49.031 --> 00:10:51.310
Is it still n squared?

00:10:51.310 --> 00:10:52.060
LING REN: Correct.

00:10:52.060 --> 00:10:52.559
Yeah.

00:10:52.559 --> 00:10:57.300
That's a very good question and
very good answer, by the way.

00:10:57.300 --> 00:11:00.660
But how effective is this?

00:11:00.660 --> 00:11:04.510
Well in average case, we may
be able to drop some messages.

00:11:04.510 --> 00:11:08.190
But there pathological
case where it actually

00:11:08.190 --> 00:11:09.270
doesn't help at all.

00:11:09.270 --> 00:11:12.530
Say this is the ID we choose.

00:11:12.530 --> 00:11:15.450
Then when there's
20, it send around.

00:11:15.450 --> 00:11:17.180
B cannot drop it.

00:11:17.180 --> 00:11:20.320
Right, because it
may be the largest.

00:11:20.320 --> 00:11:23.240
And when this 10 is sent
to C, C cannot drop it.

00:11:23.240 --> 00:11:26.130
And when 20 comes along,
it also cannot drop it.

00:11:26.130 --> 00:11:30.420
So no node can drop any message.

00:11:30.420 --> 00:11:32.585
Its worst case is
still n square.

00:11:51.770 --> 00:11:52.270
OK.

00:11:52.270 --> 00:11:58.320
So let's think about the
binary search equivalent, yeah,

00:11:58.320 --> 00:12:00.240
or how to binary
search in this case.

00:12:07.968 --> 00:12:11.130
AUDIENCE: So binary
is [INAUDIBLE] what?

00:12:11.130 --> 00:12:12.380
LING REN: Yeah, good question.

00:12:12.380 --> 00:12:15.920
It's not very obvious
binary searching to what.

00:12:18.800 --> 00:12:23.530
I Yeah, just some
binary idea that

00:12:23.530 --> 00:12:26.510
will give us a n log end bound.

00:12:26.510 --> 00:12:29.640
So actually this is
the better logarithm.

00:12:29.640 --> 00:12:31.982
But once you have a
log n, you can probably

00:12:31.982 --> 00:12:32.773
get-- OK, go ahead.

00:12:32.773 --> 00:12:35.360
AUDIENCE: How about
kind of merging,

00:12:35.360 --> 00:12:39.019
like instead of finding
the [INAUDIBLE],

00:12:39.019 --> 00:12:43.355
finding like log maximum,
then [INAUDIBLE].

00:12:43.355 --> 00:12:43.980
LING REN: Yeah.

00:12:43.980 --> 00:12:46.448
That's on the right track, yeah.

00:12:46.448 --> 00:12:48.281
AUDIENCE: Like clusters
of some [INAUDIBLE].

00:12:50.615 --> 00:12:51.240
LING REN: Yeah.

00:12:51.240 --> 00:12:55.440
That's definitely
the right idea.

00:12:55.440 --> 00:12:58.411
Let's detail it a little bit.

00:12:58.411 --> 00:12:59.410
How do you carry it out?

00:13:16.274 --> 00:13:17.266
Hm-mm.

00:13:17.266 --> 00:13:19.746
AUDIENCE: Divide the two parts.

00:13:24.210 --> 00:13:27.170
Like kind of the [INAUDIBLE].

00:13:27.170 --> 00:13:29.440
LING REN: And, OK,
so then it's let

00:13:29.440 --> 00:13:33.940
them select their leader
respectively and compare

00:13:33.940 --> 00:13:35.710
which one is larger.

00:13:35.710 --> 00:13:37.590
It's interesting thought.

00:13:48.975 --> 00:13:50.955
AUDIENCE: First,
for example, A, B

00:13:50.955 --> 00:13:53.430
finds the maximum
between these two,

00:13:53.430 --> 00:13:57.885
the C, D finds the maximum
E [INAUDIBLE] maximum.

00:13:57.885 --> 00:14:00.855
Kind of merging, considering
them as one node.

00:14:02.877 --> 00:14:04.460
LING REN: I think
the first difficulty

00:14:04.460 --> 00:14:06.870
I see is that if
you cut it by half,

00:14:06.870 --> 00:14:09.157
it's no longer a ring, right.

00:14:13.149 --> 00:14:17.150
AUDIENCE: Also they can't
cut themselves in half.

00:14:17.150 --> 00:14:17.830
LING REN: Yeah.

00:14:17.830 --> 00:14:18.190
Yeah.

00:14:18.190 --> 00:14:18.700
Correct.

00:14:18.700 --> 00:14:20.000
Yeah, yeah.

00:14:43.952 --> 00:14:48.532
Yeah, it's definitely
not an easy problem, not

00:14:48.532 --> 00:14:49.240
a easy algorithm.

00:14:54.370 --> 00:15:01.330
And the idea is to, well,
you had the right idea.

00:15:01.330 --> 00:15:07.380
That we want to--
what's the word?

00:15:07.380 --> 00:15:10.030
Let the weak candidates
shut up early.

00:15:12.630 --> 00:15:17.790
So what I mean by that is say
we have several round, so this B

00:15:17.790 --> 00:15:25.690
and A and C. We will that B
only propagate to A and C first.

00:15:25.690 --> 00:15:30.600
If B is the local maximum
among A, B, C, then

00:15:30.600 --> 00:15:32.390
B will try to talk further.

00:15:35.000 --> 00:15:36.430
Increase its range.

00:15:36.430 --> 00:15:40.140
If B is not the local maximum
of A, B, C, then, yeah,

00:15:40.140 --> 00:15:41.600
it can be quiet.

00:15:41.600 --> 00:15:44.460
Doesn't need to send
messages anymore.

00:15:44.460 --> 00:15:46.550
If B succeeds in the
next round, then you

00:15:46.550 --> 00:15:51.320
go further increase its range
to try to talk to more people.

00:15:55.670 --> 00:15:56.310
OK.

00:15:56.310 --> 00:15:58.010
So how does it work in detail?

00:16:00.910 --> 00:16:07.950
Well so in round I,
we will let a node

00:16:07.950 --> 00:16:12.950
send this message up
to 2 raised to I hops.

00:16:16.190 --> 00:16:20.485
In this case, is 1 and in
next round is 2 and then 4.

00:16:24.090 --> 00:16:29.460
If at any point some mode
like along this range

00:16:29.460 --> 00:16:32.940
decides that you are
not the local maximum,

00:16:32.940 --> 00:16:37.790
then they will reply
that, yeah, you no longer

00:16:37.790 --> 00:16:40.600
need to send messages anymore.

00:16:40.600 --> 00:16:45.360
If this message successfully
reaches this endpoint

00:16:45.360 --> 00:16:48.980
that 2 raised to I hops,
then this guy will respond.

00:16:48.980 --> 00:16:52.890
And this guy, if it still thinks
you are the local maximum,

00:16:52.890 --> 00:16:57.520
then it will respond the message
while saying, yeah, continue.

00:17:03.250 --> 00:17:03.750
OK.

00:17:03.750 --> 00:17:11.190
And if the sender receives the
continue message on both sides,

00:17:11.190 --> 00:17:14.190
then they it continue
into the next round.

00:17:14.190 --> 00:17:16.063
Otherwise, it will go inactive.

00:17:20.272 --> 00:17:21.230
Is the algorithm clear?

00:17:35.581 --> 00:17:37.664
AUDIENCE: If the problem
reaches the next maximum,

00:17:37.664 --> 00:17:41.729
like next the node each
has to send a message.

00:17:41.729 --> 00:17:42.770
LING REN: Say that again.

00:17:42.770 --> 00:17:47.180
AUDIENCE: Like after receiving
like don't sending it,

00:17:47.180 --> 00:17:49.262
like do you have to
choose one node, which

00:17:49.262 --> 00:17:50.542
has to send the message?

00:17:50.542 --> 00:17:51.250
LING REN: Oh, OK.

00:17:51.250 --> 00:17:54.110
In the first round, everyone
send their messages.

00:17:54.110 --> 00:17:54.610
OK.

00:17:54.610 --> 00:17:57.820
Then some of them
will go inactive

00:17:57.820 --> 00:17:59.930
because they learn
they are not maximum.

00:17:59.930 --> 00:18:02.630
And the remaining,
the surviving ones,

00:18:02.630 --> 00:18:05.350
will, yeah, continue
sending messages.

00:18:05.350 --> 00:18:07.410
And then, yeah, half
of them probably

00:18:07.410 --> 00:18:08.911
will die in the next round.

00:18:08.911 --> 00:18:10.785
And the surviving ones
keep sending messages.

00:18:14.315 --> 00:18:14.815
Make sense?

00:18:21.038 --> 00:18:23.483
AUDIENCE: How do you
return messages through I?

00:18:23.483 --> 00:18:26.906
Like if you [INAUDIBLE] its
neighbor and not the node that

00:18:26.906 --> 00:18:28.276
do either.

00:18:28.276 --> 00:18:28.900
LING REN: Yeah.

00:18:28.900 --> 00:18:32.340
So we will send the
message of this form,

00:18:32.340 --> 00:18:35.970
say, well, some message.

00:18:39.200 --> 00:18:43.970
And then we will send the
hop and the direction,

00:18:43.970 --> 00:18:47.260
either left or right.

00:18:47.260 --> 00:18:50.160
And this hop will
initially be set

00:18:50.160 --> 00:18:56.150
to 2 raised to I,
the number of round.

00:18:56.150 --> 00:18:58.505
Then when this guy
receives the message,

00:18:58.505 --> 00:19:05.420
it will increment the hop
count and pass it along.

00:19:05.420 --> 00:19:08.170
And every node when
forwarding the message

00:19:08.170 --> 00:19:12.220
will decrease the that h by 1.

00:19:12.220 --> 00:19:16.490
And finally when it reaches
here, that number becomes 0.

00:19:16.490 --> 00:19:23.020
And when a node sees a
message with 0 hop count,

00:19:23.020 --> 00:19:26.220
it's going to reverse it, send
it in the other direction.

00:19:26.220 --> 00:19:36.220
And, again, set it
back to 2 raised to I.

00:19:36.220 --> 00:19:41.040
This message I should say ID.

00:19:44.770 --> 00:19:48.780
And at certain
point, a certain node

00:19:48.780 --> 00:19:50.920
may decide this ID's too small.

00:19:50.920 --> 00:19:52.300
It doesn't have a chance.

00:19:52.300 --> 00:19:56.710
Then the I can directly send
it in the opposite direction,

00:19:56.710 --> 00:19:58.974
replying a message saying,
yeah, you are too small.

00:20:02.610 --> 00:20:03.290
OK.

00:20:03.290 --> 00:20:09.200
So any more questions
on the algorithm itself?

00:20:09.200 --> 00:20:11.090
If not, what's the next step?

00:20:16.425 --> 00:20:17.395
AUDIENCE: Time.

00:20:17.395 --> 00:20:19.030
LING REN: Yeah, time complexity.

00:20:19.030 --> 00:20:21.210
I already claimed it's n log n.

00:20:21.210 --> 00:20:21.800
Is it?

00:20:27.800 --> 00:20:30.194
This is round.

00:20:30.194 --> 00:20:30.860
This is message.

00:20:33.900 --> 00:20:35.270
This is also message complexity.

00:20:38.820 --> 00:20:39.320
OK.

00:20:39.320 --> 00:20:40.345
So why is it n log n?

00:21:15.190 --> 00:21:18.034
AUDIENCE: The log n [INAUDIBLE].

00:21:18.034 --> 00:21:18.700
LING REN: Hm-mm.

00:21:18.700 --> 00:21:22.055
So we have a certain
number of rounds.

00:21:22.055 --> 00:21:23.305
So how many rounds do we have?

00:21:28.530 --> 00:21:31.010
AUDIENCE: Two.

00:21:31.010 --> 00:21:32.000
LING REN: Yeah, maybe.

00:21:32.000 --> 00:21:33.936
But, yeah, I'll just say log n.

00:21:33.936 --> 00:21:34.436
OK.

00:21:37.280 --> 00:21:42.810
Because you are increasing
your hop length.

00:21:42.810 --> 00:21:48.250
And we're going to compute
like how many nodes are still

00:21:48.250 --> 00:21:55.490
active each around and how many
messages are sent in the round.

00:21:55.490 --> 00:22:02.630
So, well, the number
of nodes active

00:22:02.630 --> 00:22:07.651
will just be this number
if we start from 0.

00:22:07.651 --> 00:22:08.150
Why?

00:22:08.150 --> 00:22:11.210
Because the first time
everyone is active.

00:22:11.210 --> 00:22:16.210
In the next time, only 1/3
of them will be active.

00:22:16.210 --> 00:22:20.100
But we said we are conservative
here at we put 1/2.

00:22:20.100 --> 00:22:21.080
Right.

00:22:21.080 --> 00:22:23.490
Next round is actually 1/5.

00:22:27.180 --> 00:22:29.350
If it's local maximum,
it means like these two

00:22:29.350 --> 00:22:32.625
and those two will go inactive.

00:22:32.625 --> 00:22:39.200
But we put this
as a upper bound.

00:22:39.200 --> 00:22:44.660
So this is the number of
nodes that are still active.

00:22:44.660 --> 00:22:52.890
And they will send the
message up to this many hops.

00:22:56.285 --> 00:22:58.710
OK.

00:22:58.710 --> 00:23:00.955
And there are two directions.

00:23:06.460 --> 00:23:08.400
And you send a message back.

00:23:08.400 --> 00:23:11.760
And then, yeah-- sorry,
send the message forward

00:23:11.760 --> 00:23:15.175
and someone will reply.

00:23:15.175 --> 00:23:18.615
But in the end, this is n log n.

00:23:24.117 --> 00:23:28.500
Yeah, and I think
I got 8n log n.

00:23:28.500 --> 00:23:32.664
So my recitation note says
it's 4 log n, not entirely sure

00:23:32.664 --> 00:23:33.330
what's going on.

00:23:33.330 --> 00:23:33.830
Yeah.

00:23:33.830 --> 00:23:36.330
But you can double check
whether this is correct

00:23:36.330 --> 00:23:38.170
or the recitation
note is correct.

00:23:58.728 --> 00:24:01.190
AUDIENCE: What is I again?

00:24:01.190 --> 00:24:04.790
LING REN: I's the number
of round in the I-th round.

00:24:04.790 --> 00:24:05.290
Yeah.

00:24:05.290 --> 00:24:07.230
This many nodes
are still active.

00:24:07.230 --> 00:24:11.020
And each of them will send
a message of this many hops.

00:24:28.090 --> 00:24:30.970
And I didn't mention
whether the network

00:24:30.970 --> 00:24:32.680
is synchronous or asynchronous.

00:24:32.680 --> 00:24:35.180
And it turns out
it doesn't care.

00:24:35.180 --> 00:24:38.680
Some of them can work for both
synchronous and asynchronous.

00:24:38.680 --> 00:24:40.960
Apparently, it works for
synchronous networks.

00:24:40.960 --> 00:24:45.710
If it's asynchronous,
then what changes

00:24:45.710 --> 00:24:49.620
is that different nodes
are in different rounds.

00:24:49.620 --> 00:24:52.650
A certain node may be far
ahead than the others.

00:24:52.650 --> 00:24:53.590
But it's fine.

00:24:53.590 --> 00:24:59.660
Eventually, they will converge
to the correct result. OK.

00:24:59.660 --> 00:25:01.505
So let's look at
the second problem.

00:25:07.330 --> 00:25:10.070
Well, problem's
defined even simpler.

00:25:10.070 --> 00:25:15.140
We just want to count how
many nodes are out there.

00:25:15.140 --> 00:25:19.235
We want the algorithm to
work both synchronously and

00:25:19.235 --> 00:25:19.860
asynchronously.

00:25:23.560 --> 00:25:26.260
By that I just mean
we have a network.

00:25:33.130 --> 00:25:36.220
Well, say you have a
lot of nodes after that.

00:25:36.220 --> 00:25:39.440
Just want to count how
many nodes are there

00:25:39.440 --> 00:25:40.170
in this network.

00:25:45.440 --> 00:25:49.312
So I'll give you, say, one
minutes to let's first come up

00:25:49.312 --> 00:25:50.270
with a high-level plan.

00:25:56.350 --> 00:25:58.543
Is the problem clear?

00:25:58.543 --> 00:26:02.471
AUDIENCE: In the worst
case, [INAUDIBLE].

00:26:02.471 --> 00:26:05.389
The worst case.

00:26:05.389 --> 00:26:05.930
LING REN: OK.

00:26:05.930 --> 00:26:06.888
I haven't defined that.

00:26:06.888 --> 00:26:11.460
Let's not worry about
complexity now for now.

00:26:11.460 --> 00:26:14.380
The complexity will
depend on number of nodes

00:26:14.380 --> 00:26:22.330
and the number of
edges, E. Let's just

00:26:22.330 --> 00:26:23.610
get it functionally correct.

00:27:53.070 --> 00:27:53.630
OK.

00:27:53.630 --> 00:27:56.090
Anyone share a
high-level strategy?

00:28:01.130 --> 00:28:01.820
Go ahead.

00:28:01.820 --> 00:28:05.257
AUDIENCE: So each
node will start

00:28:05.257 --> 00:28:11.149
like IDs of the other
devices [INAUDIBLE].

00:28:11.149 --> 00:28:15.077
So basically like it's going
to send propagates [INAUDIBLE]

00:28:15.077 --> 00:28:18.023
sets of each node.

00:28:23.424 --> 00:28:25.310
LING REN: On what edge?

00:28:25.310 --> 00:28:26.495
AUDIENCE: Furthest one.

00:28:26.495 --> 00:28:27.120
LING REN: Yeah.

00:28:27.120 --> 00:28:30.274
It wasn't on both edges?

00:28:30.274 --> 00:28:32.409
AUDIENCE: Itself first.

00:28:32.409 --> 00:28:32.950
LING REN: OK.

00:28:32.950 --> 00:28:38.030
So then maybe send the 1 here
and send the 1 here there.

00:28:38.030 --> 00:28:41.870
Then this node will think it
has a children, it as a child,

00:28:41.870 --> 00:28:43.060
right, which is this one.

00:28:43.060 --> 00:28:46.430
Let's just say this
is the entire network.

00:28:46.430 --> 00:28:50.772
And what message does
it send to this guy?

00:28:50.772 --> 00:28:51.772
AUDIENCE: Reinforced it.

00:28:57.450 --> 00:28:59.440
LING REN: Well, you
probably need send two here

00:28:59.440 --> 00:29:04.480
because you have one and this
is possibly its child, right.

00:29:04.480 --> 00:29:06.484
But then we're double
counting this node.

00:29:06.484 --> 00:29:07.150
See the problem?

00:29:13.442 --> 00:29:16.589
AUDIENCE: Do nodes have
their IDs, like unique IDs?

00:29:16.589 --> 00:29:17.380
LING REN: Oh, yeah.

00:29:17.380 --> 00:29:18.460
They have their IDs.

00:29:18.460 --> 00:29:20.680
AUDIENCE: We can't send
the IDs instead of the IDs

00:29:20.680 --> 00:29:22.589
through the end node.

00:29:22.589 --> 00:29:23.130
LING REN: OK.

00:29:26.300 --> 00:29:29.103
We are going to
send all the IDs.

00:29:29.103 --> 00:29:30.186
AUDIENCE: Yeah, neighbors.

00:29:43.497 --> 00:29:49.269
And after n steps, it's going
to have the [INAUDIBLE].

00:29:49.269 --> 00:29:49.810
LING REN: OK.

00:29:49.810 --> 00:29:51.550
Yeah, that's an
interesting thought.

00:29:51.550 --> 00:29:56.260
And then you may
still need the root.

00:29:56.260 --> 00:30:01.750
And that will have
everyone's ID.

00:30:01.750 --> 00:30:04.710
And then see how many
unique I's are there.

00:30:07.600 --> 00:30:08.100
OK.

00:30:08.100 --> 00:30:09.060
Interesting.

00:30:09.060 --> 00:30:12.455
Does this algorithm work?

00:30:12.455 --> 00:30:13.790
Yeah, I don't see any problem.

00:30:22.376 --> 00:30:23.810
OK.

00:30:23.810 --> 00:30:28.650
But let me still repeat
what our algorithm

00:30:28.650 --> 00:30:34.900
is because it's closer
to what's in the lecture.

00:30:34.900 --> 00:30:42.305
So we're going to find a
spanning tree of this network.

00:30:44.960 --> 00:30:47.720
A spanning tree
means, well, like I

00:30:47.720 --> 00:30:49.135
have to cut one of these edges.

00:30:52.840 --> 00:30:56.860
If I have a tree, then I
can have every child report

00:30:56.860 --> 00:30:58.610
to its parent.

00:30:58.610 --> 00:31:05.130
Like how many offsprings,
including myself do I have.

00:31:05.130 --> 00:31:11.510
And this node will sum
up all its children

00:31:11.510 --> 00:31:12.670
and report to its parent.

00:31:18.370 --> 00:31:20.440
Does everyone get that?

00:31:20.440 --> 00:31:23.550
So first, we'll find
a spanning tree.

00:31:29.466 --> 00:31:37.154
And second, we'll have
child reports to parent.

00:31:50.790 --> 00:31:54.470
AUDIENCE: How can we
find the spanning tree?

00:31:54.470 --> 00:31:55.470
LING REN: Good question.

00:31:55.470 --> 00:31:59.770
So in the lecture, we
have seen algorithm

00:31:59.770 --> 00:32:12.105
that find BFS spanning tree
for synchronous networks.

00:32:15.330 --> 00:32:15.830
OK.

00:32:15.830 --> 00:32:17.380
This is review of the lecture.

00:32:20.732 --> 00:32:21.440
How does it work?

00:32:35.290 --> 00:32:39.280
Each node will, say, we
need to first choose a root.

00:32:39.280 --> 00:32:43.350
And our root will just send
a message to its neighbor

00:32:43.350 --> 00:32:46.950
and, yeah, saying, you are
my child, you are my child,

00:32:46.950 --> 00:32:49.000
you are my child.

00:32:49.000 --> 00:32:53.300
And then every node upon
receiving this message

00:32:53.300 --> 00:33:00.724
from the parent will
search among its neighbors.

00:33:00.724 --> 00:33:01.690
All right.

00:33:01.690 --> 00:33:04.260
So the neighbors that
haven't got a parent

00:33:04.260 --> 00:33:08.515
will acknowledge this
sender as the parent.

00:33:12.400 --> 00:33:12.900
OK.

00:33:12.900 --> 00:33:13.910
That's a little messy.

00:33:27.650 --> 00:33:33.380
So this node will
search to the leaf node.

00:33:33.380 --> 00:33:36.250
But then it will also try
to search for this guy.

00:33:36.250 --> 00:33:38.630
But this guy already had
a parent, then, yeah,

00:33:38.630 --> 00:33:44.210
it will say I already got a
parent and blah, blah, blah.

00:33:44.210 --> 00:33:47.330
This will give us a
BFS spanning tree.

00:33:47.330 --> 00:33:48.080
What does it mean?

00:33:48.080 --> 00:33:50.075
It's a spanning
tree found by BFS.

00:33:52.620 --> 00:33:54.680
Does it work for
asynchronous network?

00:33:59.680 --> 00:34:00.395
Go ahead.

00:34:00.395 --> 00:34:01.172
AUDIENCE: This version doesn't.

00:34:01.172 --> 00:34:02.672
But there's a
different version that

00:34:02.672 --> 00:34:05.110
contains an edge for
relaxation technique.

00:34:05.110 --> 00:34:05.840
LING REN: Yeah.

00:34:05.840 --> 00:34:06.470
Correct.

00:34:06.470 --> 00:34:10.931
And so why does this version not
work for a synchronous network?

00:34:10.931 --> 00:34:12.306
AUDIENCE: Because
different nodes

00:34:12.306 --> 00:34:14.290
can be on a different
round number

00:34:14.290 --> 00:34:18.270
so that a longer path could
end up going to the node even.

00:34:18.270 --> 00:34:19.290
LING REN: Yeah, exactly.

00:34:19.290 --> 00:34:23.030
So let me give a
concrete example.

00:34:23.030 --> 00:34:25.080
What does asynchronous
network mean?

00:34:25.080 --> 00:34:28.580
Is that, well, messages
travel at different speed.

00:34:28.580 --> 00:34:32.760
Say this link for some
reason is temporarily down.

00:34:32.760 --> 00:34:37.030
And this node doesn't receive
the message from the root.

00:34:37.030 --> 00:34:41.210
And then this message
travels very fast.

00:34:41.210 --> 00:34:43.000
And this message also
travels very fast.

00:34:43.000 --> 00:34:47.480
So this message may
reach this node earlier.

00:34:47.480 --> 00:34:52.300
And then this node will think
of it as a child of this node.

00:34:52.300 --> 00:34:52.850
OK.

00:34:52.850 --> 00:34:55.889
And then this message
comes along, finally.

00:34:55.889 --> 00:34:58.490
But this node says, yeah,
I already have a parent.

00:34:58.490 --> 00:35:00.870
And I'm going to reject you.

00:35:00.870 --> 00:35:03.070
AUDIENCE: So it still
makes a spanning tree?

00:35:03.070 --> 00:35:04.220
LING REN: Yes.

00:35:04.220 --> 00:35:05.330
Good point.

00:35:05.330 --> 00:35:09.143
This is not a BFS spanning tree
but it's still a spanning tree.

00:35:09.143 --> 00:35:09.870
All right.

00:35:09.870 --> 00:35:12.600
So in our problem, we're
totally fine with it.

00:35:16.340 --> 00:35:16.840
Yeah.

00:35:16.840 --> 00:35:20.210
But you do have to know if
you really want a BFS spanning

00:35:20.210 --> 00:35:22.580
tree in an asynchronous
network, then

00:35:22.580 --> 00:35:25.002
you have to like record the
distance and do the relaxation

00:35:25.002 --> 00:35:25.960
and so on and so forth.

00:35:29.229 --> 00:35:30.170
OK.

00:35:30.170 --> 00:35:33.740
So we will just use this
algorithm, the BFS spanning

00:35:33.740 --> 00:35:37.139
tree algorithm, just
run it asynchronously.

00:35:37.139 --> 00:35:38.680
It doesn't find the
BFS spanning tree

00:35:38.680 --> 00:35:40.610
but it finds some spanning tree.

00:35:46.990 --> 00:35:47.490
OK.

00:35:47.490 --> 00:35:48.850
How does this algorithm work?

00:35:56.290 --> 00:35:58.030
We will have several variables.

00:35:58.030 --> 00:36:01.510
The first one is parent.

00:36:01.510 --> 00:36:04.540
We will initialize to
this undefined single.

00:36:13.900 --> 00:36:14.900
OK.

00:36:14.900 --> 00:36:20.350
Then every node will pass
around this search message.

00:36:20.350 --> 00:36:23.170
I'll use a slightly
more shorthand notation

00:36:23.170 --> 00:36:24.185
than from the lecture.

00:36:32.746 --> 00:36:33.250
OK.

00:36:33.250 --> 00:36:38.920
Let's say the code I
wrote is for a process u.

00:36:42.392 --> 00:36:44.880
OK.

00:36:44.880 --> 00:36:51.410
If we receive a message,
a search message, from v

00:36:51.410 --> 00:37:01.135
to u, that means u-- sorry, v
is trying to become a parent.

00:37:01.135 --> 00:37:01.635
OK.

00:37:05.130 --> 00:37:11.530
And if I do not
have a parent yet,

00:37:11.530 --> 00:37:25.310
I should set the
parent to v. OK.

00:37:25.310 --> 00:37:26.432
So what's the next step?

00:37:38.990 --> 00:37:41.120
Now, we got this search
message from our parent.

00:37:41.120 --> 00:37:43.200
And we have to pass it along.

00:37:49.687 --> 00:37:52.431
AUDIENCE: Should we
send it to the like

00:37:52.431 --> 00:37:53.690
add your child [INAUDIBLE].

00:37:53.690 --> 00:37:54.830
LING REN: Oh, yeah.

00:37:54.830 --> 00:37:55.330
Great.

00:37:58.746 --> 00:38:03.310
Yeah, we first need to
respond by saying, OK,

00:38:03.310 --> 00:38:07.300
I'll use a shorter notation.

00:38:07.300 --> 00:38:12.860
Send these a cue that
that's the message that will

00:38:12.860 --> 00:38:14.640
be sent to v at some point.

00:38:17.350 --> 00:38:21.330
The message we send is parent 1.

00:38:21.330 --> 00:38:23.640
Parent 2.

00:38:23.640 --> 00:38:30.107
This is a response to v saying,
yeah, you are my parent.

00:38:34.400 --> 00:38:34.990
OK.

00:38:34.990 --> 00:38:50.720
Then else, we also have to
respond by saying parent 0.

00:38:50.720 --> 00:38:54.820
You are not my parent because I
already got some other parent.

00:38:54.820 --> 00:38:55.320
OK.

00:38:55.320 --> 00:38:56.474
Missing a step here.

00:39:03.590 --> 00:39:05.255
If we receive a search message.

00:39:05.255 --> 00:39:06.500
Go ahead.

00:39:06.500 --> 00:39:08.935
AUDIENCE: We send messages
to all the other nodes.

00:39:08.935 --> 00:39:09.560
LING REN: Yeah.

00:39:09.560 --> 00:39:17.170
We need to pass it to all
my potential children.

00:39:17.170 --> 00:39:26.050
So I use this comma u,
meaning the neighbors of u.

00:39:26.050 --> 00:39:27.870
And then I'll send
them a message.

00:39:31.959 --> 00:39:32.500
What message?

00:39:35.410 --> 00:39:35.910
Search.

00:39:47.041 --> 00:39:47.540
OK.

00:39:59.465 --> 00:39:59.965
OK.

00:39:59.965 --> 00:40:06.000
So, well, naturally since
we have a search message

00:40:06.000 --> 00:40:08.130
and we know how to
deal with it, now we

00:40:08.130 --> 00:40:10.620
are sending this parent message
with better deal with it.

00:40:10.620 --> 00:40:11.940
Right.

00:40:11.940 --> 00:40:15.940
So then the next
chunk of code should

00:40:15.940 --> 00:40:25.030
be if we receive this parent
message, I'll say parent b,

00:40:25.030 --> 00:40:28.540
meaning this message comes
with either true or false.

00:40:32.590 --> 00:40:37.854
I received this message
from some node w.

00:40:37.854 --> 00:40:38.700
OK.

00:40:38.700 --> 00:40:40.780
I'm still u here.

00:40:40.780 --> 00:40:43.910
Because I just send all
the message to all the w's,

00:40:43.910 --> 00:40:46.765
to all my neighbors, and they
should give me a response.

00:40:55.430 --> 00:40:55.930
OK.

00:40:55.930 --> 00:41:03.530
If b is 1 that means
this particular w

00:41:03.530 --> 00:41:06.810
take me as its parent.

00:41:06.810 --> 00:41:09.360
Make sense?

00:41:09.360 --> 00:41:10.210
OK.

00:41:10.210 --> 00:41:14.280
So I'd better have a
list of my children.

00:41:14.280 --> 00:41:16.500
I want to keep track of that.

00:41:16.500 --> 00:41:17.000
How?

00:41:20.320 --> 00:41:25.480
We will create a new
variable for children.

00:41:25.480 --> 00:41:28.890
It's going to be
initialized to what?

00:41:32.100 --> 00:41:33.190
Yeah, empty set.

00:41:37.730 --> 00:41:42.040
And now if this b
is 1, then I'm going

00:41:42.040 --> 00:41:45.182
to put w in this children list.

00:41:49.910 --> 00:41:51.170
OK.

00:41:51.170 --> 00:42:01.700
I'm leaving some space
here because our root

00:42:01.700 --> 00:42:03.020
should be slightly different.

00:42:03.020 --> 00:42:06.050
So every other node will
send search messages

00:42:06.050 --> 00:42:07.954
when it receive
a search message.

00:42:07.954 --> 00:42:09.120
We need someone to initiate.

00:42:12.260 --> 00:42:14.130
Make sense?

00:42:14.130 --> 00:42:20.800
So if u equals root,
we say the root is v0.

00:42:26.460 --> 00:42:28.300
So two things should happen.

00:42:28.300 --> 00:42:34.260
First, we should set its
parent to some special value.

00:42:34.260 --> 00:42:35.150
Just say root.

00:42:40.050 --> 00:42:44.527
And then I should copy
this blob of code to here.

00:42:58.163 --> 00:42:59.160
OK.

00:42:59.160 --> 00:43:04.720
It's a little crowded but
I hope it's still legible.

00:43:14.930 --> 00:43:15.430
OK.

00:43:15.430 --> 00:43:19.050
This is already almost
the correct algorithm,

00:43:19.050 --> 00:43:22.020
except that we don't
know how to terminate.

00:43:22.020 --> 00:43:24.720
If we wait long
enough, then everyone

00:43:24.720 --> 00:43:29.110
will receive all the responses
and everyone will know

00:43:29.110 --> 00:43:32.721
its parent and this child list.

00:43:32.721 --> 00:43:33.720
But how do we terminate?

00:43:38.322 --> 00:43:39.472
AUDIENCE: After n rounds.

00:43:39.472 --> 00:43:41.680
LING REN: Yeah, that's one
way to do, after n rounds.

00:43:41.680 --> 00:43:44.710
But the whole point is we
are trying to find what n is.

00:43:44.710 --> 00:43:46.420
We don't know how
many nodes are there.

00:43:46.420 --> 00:43:50.920
AUDIENCE: If we receive
reject for all, [INAUDIBLE].

00:43:53.920 --> 00:43:55.551
LING REN: Say again.

00:43:55.551 --> 00:44:00.999
AUDIENCE: For all the search,
if we receive a reject.

00:44:00.999 --> 00:44:01.790
LING REN: Oh, yeah.

00:44:01.790 --> 00:44:06.850
If you receive a response,
either parent 0 or parent 1

00:44:06.850 --> 00:44:11.370
from all your neighbors, then
your job is pretty much done.

00:44:11.370 --> 00:44:14.813
But the others have not.

00:44:14.813 --> 00:44:15.760
All right.

00:44:15.760 --> 00:44:17.700
So you send a message very fast.

00:44:17.700 --> 00:44:18.920
They responded to you.

00:44:18.920 --> 00:44:22.930
And they are still
working very hard.

00:44:22.930 --> 00:44:23.630
OK.

00:44:23.630 --> 00:44:27.490
So then we need to use the
technique from the lecture

00:44:27.490 --> 00:44:31.050
that's called converge cast.

00:44:31.050 --> 00:44:36.430
So everyone will send a
done signal when it is done

00:44:36.430 --> 00:44:38.016
and all its children
are also done.

00:44:41.404 --> 00:44:41.904
OK.

00:44:44.830 --> 00:44:50.150
To do that, I'm going to define
a new variable called searched.

00:44:50.150 --> 00:44:53.816
Searched means
someone has responded.

00:44:53.816 --> 00:44:54.750
OK.

00:44:54.750 --> 00:44:58.670
In this case, w has responded.

00:44:58.670 --> 00:45:01.070
I'll put it into
the search the list,

00:45:01.070 --> 00:45:05.001
no matter whether it accepts
me as parent or reject.

00:45:05.001 --> 00:45:05.500
OK.

00:45:05.500 --> 00:45:09.230
Then naturally I need to
define this variable here.

00:45:24.699 --> 00:45:25.200
OK.

00:45:25.200 --> 00:45:38.310
As a last step, If we search the
list equals my neighbor list,

00:45:38.310 --> 00:45:43.660
that means everyone
has responded

00:45:43.660 --> 00:45:51.630
and all my children
are done, then

00:45:51.630 --> 00:45:55.410
I need a new
variable called done.

00:45:55.410 --> 00:46:03.388
That's another list tracking who
has finished and who has not.

00:46:07.628 --> 00:46:08.128
OK.

00:46:08.128 --> 00:46:09.600
AUDIENCE: So what's
the first one?

00:46:09.600 --> 00:46:10.530
LING REN: Say again.

00:46:10.530 --> 00:46:11.930
AUDIENCE: What
was the first one?

00:46:11.930 --> 00:46:13.140
LING REN: This one?

00:46:13.140 --> 00:46:16.975
Searched means
someone has responded

00:46:16.975 --> 00:46:18.961
to the search message.

00:46:18.961 --> 00:46:19.460
OK.

00:46:19.460 --> 00:46:25.170
Done means all its
children are done.

00:46:25.170 --> 00:46:27.975
I haven't write how
done is defined.

00:46:27.975 --> 00:46:29.130
Give me a minute.

00:46:29.130 --> 00:46:34.780
In this case, I'm going to
send my parent a message.

00:46:34.780 --> 00:46:38.460
This is the step
of converge cast.

00:46:38.460 --> 00:46:39.257
What do I send?

00:46:39.257 --> 00:46:40.590
I'm going to send them I'm done.

00:46:48.318 --> 00:46:49.780
OK.

00:46:49.780 --> 00:46:52.620
Then whenever we
create a message,

00:46:52.620 --> 00:46:56.440
we should deal
with that message.

00:46:56.440 --> 00:47:02.821
If we receive a message
I'm done, what do we do?

00:47:02.821 --> 00:47:03.320
OK.

00:47:03.320 --> 00:47:11.480
From w, then we're going
to mark that node as done.

00:47:26.030 --> 00:47:26.830
OK.

00:47:26.830 --> 00:47:28.470
There's this other point.

00:47:28.470 --> 00:47:32.450
So someone has to
initiate the done signal.

00:47:32.450 --> 00:47:34.550
That's going to be
our leaves, right.

00:47:34.550 --> 00:47:37.160
Because when this
condition check,

00:47:37.160 --> 00:47:38.510
they don't have any children.

00:47:38.510 --> 00:47:40.130
Their children
list is empty set.

00:47:40.130 --> 00:47:42.270
And their done list
is also empty set.

00:47:42.270 --> 00:47:45.580
But they're going to send
the I'm done signal first.

00:47:45.580 --> 00:47:47.740
And then in the
median nodes, we'll

00:47:47.740 --> 00:47:52.281
send a done signal when
all its children are done.

00:47:52.281 --> 00:47:52.780
All right.

00:47:52.780 --> 00:47:57.150
So this is the
converged cast version.

00:47:57.150 --> 00:48:00.930
Only gives us a
termination point

00:48:00.930 --> 00:48:04.380
of our spanning tree search.

00:48:04.380 --> 00:48:08.090
We haven't count the number
of nodes in the network.

00:48:11.072 --> 00:48:15.330
But that's a small modification.

00:48:15.330 --> 00:48:19.700
We're just going to include that
number in the I'm done signal.

00:48:19.700 --> 00:48:24.190
So then I need to define
another variable called

00:48:24.190 --> 00:48:27.460
total that's initialized to 0.

00:48:27.460 --> 00:48:31.040
This variable will
attract how many

00:48:31.040 --> 00:48:35.560
nodes do I have in
my subtree, including

00:48:35.560 --> 00:48:36.720
me and all my children.

00:48:39.740 --> 00:48:43.040
Then when I send
the I'm done signal,

00:48:43.040 --> 00:48:47.370
I'm going to send this-- sorry.

00:48:47.370 --> 00:48:50.700
That's not right way.

00:48:50.700 --> 00:48:52.790
When I'm sending
the I'm done signal,

00:48:52.790 --> 00:48:57.980
I'm going to send my total
number of offspring with it.

00:48:57.980 --> 00:49:03.330
And when I receive,
one of my children

00:49:03.330 --> 00:49:05.110
reports that I do
have t children.

00:49:08.310 --> 00:49:12.070
I need to increment my
total by that amount.

00:49:21.601 --> 00:49:22.100
OK.

00:49:22.100 --> 00:49:24.240
I made a mistake again.

00:49:24.240 --> 00:49:28.060
Should be total plus 1.

00:49:28.060 --> 00:49:29.010
Right.

00:49:29.010 --> 00:49:30.930
Because I'm counting
all my children and then

00:49:30.930 --> 00:49:32.030
I should include myself.

00:49:43.426 --> 00:49:44.800
So that's the
complete algorithm.

00:49:49.370 --> 00:49:49.870
Yeah.

00:49:49.870 --> 00:49:53.970
One purpose is just to create
a different angle to look

00:49:53.970 --> 00:49:55.070
at distributed algorithm.

00:49:55.070 --> 00:49:58.310
Usually just draw
that network graphs.

00:49:58.310 --> 00:50:00.980
But sometimes it's
helpful to think about how

00:50:00.980 --> 00:50:02.227
the code actually works.

00:50:05.703 --> 00:50:06.203
OK.

00:50:10.180 --> 00:50:12.170
That's all for today.