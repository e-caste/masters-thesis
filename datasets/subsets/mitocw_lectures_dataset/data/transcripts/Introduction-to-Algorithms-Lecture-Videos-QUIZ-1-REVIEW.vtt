WEBVTT

00:00:00.000 --> 00:00:01.964
[SQUEAKING]

00:00:01.964 --> 00:00:03.928
[RUSTLING]

00:00:03.928 --> 00:00:06.383
[CLICKING]

00:00:12.780 --> 00:00:14.130
JASON KU: All right.

00:00:14.130 --> 00:00:16.020
Welcome, everybody.

00:00:16.020 --> 00:00:17.580
Everyone ready for the quiz?

00:00:17.580 --> 00:00:18.540
AUDIENCE: No.

00:00:18.540 --> 00:00:19.710
JASON KU: Quiz next week.

00:00:19.710 --> 00:00:20.280
Yes.

00:00:20.280 --> 00:00:22.530
I hope you all are
here because you know

00:00:22.530 --> 00:00:23.790
that there's a quiz next week.

00:00:23.790 --> 00:00:24.300
OK.

00:00:24.300 --> 00:00:26.250
So what is this quiz about?

00:00:26.250 --> 00:00:27.870
It's about what
we've talked about so

00:00:27.870 --> 00:00:29.430
far in this class of course.

00:00:29.430 --> 00:00:31.080
What is this class about?

00:00:31.080 --> 00:00:34.090
Someone remember from
my first lecture?

00:00:34.090 --> 00:00:35.160
What is this class about?

00:00:35.160 --> 00:00:37.243
What are we trying to
test you in this class?

00:00:37.243 --> 00:00:38.160
AUDIENCE: Algorithims.

00:00:38.160 --> 00:00:39.035
JASON KU: Algorithms.

00:00:39.035 --> 00:00:39.780
Great.

00:00:39.780 --> 00:00:40.655
Also data structures.

00:00:40.655 --> 00:00:41.155
Right?

00:00:41.155 --> 00:00:42.750
That's what the first
part of this is.

00:00:42.750 --> 00:00:45.870
But really it's to get you to
solve computational problems.

00:00:45.870 --> 00:00:47.790
That's the first thing.

00:00:47.790 --> 00:00:52.000
Be able to argue to someone else
that you actually did solve it.

00:00:52.000 --> 00:00:52.500
Right?

00:00:52.500 --> 00:00:53.280
It's correct.

00:00:53.280 --> 00:00:54.000
Right?

00:00:54.000 --> 00:00:56.010
That you chose something that's
better than other things,

00:00:56.010 --> 00:00:56.910
that it's efficient.

00:00:56.910 --> 00:00:57.690
Right?

00:00:57.690 --> 00:01:00.240
And that you can communicate
those things to other people.

00:01:00.240 --> 00:01:00.750
Right?

00:01:00.750 --> 00:01:04.890
Those are my big four that I try
to get you guys to internalize.

00:01:04.890 --> 00:01:06.960
And so that's what
our quizzes are going

00:01:06.960 --> 00:01:08.870
to try to evaluate you on.

00:01:08.870 --> 00:01:09.470
OK.

00:01:09.470 --> 00:01:15.570
And so aside from some
nitty gritty kind of stuff

00:01:15.570 --> 00:01:17.280
that we do at the
beginning of the term

00:01:17.280 --> 00:01:21.010
like talking about our
model of computation.

00:01:21.010 --> 00:01:21.510
Right?

00:01:21.510 --> 00:01:26.620
Our model-- and asymptotics.

00:01:26.620 --> 00:01:31.500
Asym-- sym-- totics.

00:01:31.500 --> 00:01:33.900
Is that right?

00:01:33.900 --> 00:01:37.470
Recurrences right?

00:01:37.470 --> 00:01:39.990
Aside from these
kind of basics, we

00:01:39.990 --> 00:01:42.720
delve straight into algorithms.

00:01:42.720 --> 00:01:43.830
Right?

00:01:43.830 --> 00:01:48.060
These are kind of like
almost definitions.

00:01:48.060 --> 00:01:49.920
We don't rely on these
things very much.

00:01:49.920 --> 00:01:52.213
I mean, we rely on these
things all the time.

00:01:52.213 --> 00:01:53.880
But it's kind of the
mathematics that we

00:01:53.880 --> 00:01:54.930
use to talk about things.

00:01:54.930 --> 00:01:55.440
Right?

00:01:55.440 --> 00:01:57.180
How can we even say
how long this stuff

00:01:57.180 --> 00:01:58.860
takes unless we can reason--

00:01:58.860 --> 00:02:01.260
we can abstract a way
that this stuff is not

00:02:01.260 --> 00:02:02.730
on a real computer.

00:02:02.730 --> 00:02:04.650
This is kind of in our
minds, in a computer.

00:02:04.650 --> 00:02:06.483
And we're reasoning
about these things based

00:02:06.483 --> 00:02:09.300
on the number of
constant time operations

00:02:09.300 --> 00:02:12.237
this magical
computer might have,

00:02:12.237 --> 00:02:14.070
which is a pretty good
representation of any

00:02:14.070 --> 00:02:16.990
of the computers you have
for certain assumptions.

00:02:16.990 --> 00:02:17.490
Right?

00:02:17.490 --> 00:02:20.430
We're not-- I mean, there's not
a lot of problem set questions

00:02:20.430 --> 00:02:23.790
we had you talk about.

00:02:23.790 --> 00:02:27.497
These things--
specifically-- usually they

00:02:27.497 --> 00:02:28.830
were part of some other problem.

00:02:28.830 --> 00:02:29.340
Right?

00:02:29.340 --> 00:02:33.000
You had to describe the
running time of this thing.

00:02:33.000 --> 00:02:34.975
And you might have had
to solve a recurrence.

00:02:34.975 --> 00:02:36.600
And you might have
uses master theorem.

00:02:36.600 --> 00:02:37.380
That kind of thing.

00:02:37.380 --> 00:02:37.880
Right?

00:02:37.880 --> 00:02:39.780
Or you use asymptotics
all the time.

00:02:39.780 --> 00:02:41.820
Or you need to
remember in our model,

00:02:41.820 --> 00:02:44.550
oh, it kind of matters
how big of an integer

00:02:44.550 --> 00:02:47.530
I can store and do arithmetic
on in constant time.

00:02:47.530 --> 00:02:48.030
Right?

00:02:48.030 --> 00:02:50.190
So for that p-set
3 question you had

00:02:50.190 --> 00:02:54.410
at the end of the
coding question,

00:02:54.410 --> 00:02:56.370
you wanted to hash things.

00:02:56.370 --> 00:02:59.070
And you need to argue
that those things fit

00:02:59.070 --> 00:03:02.070
in a constant number
of words so that

00:03:02.070 --> 00:03:03.390
could be done in constant time.

00:03:03.390 --> 00:03:06.090
A lot of you guys
found canonicalizations

00:03:06.090 --> 00:03:11.620
basically mapping to things
that were exponentially large.

00:03:11.620 --> 00:03:14.530
So maybe multiplying a
product of primes or something

00:03:14.530 --> 00:03:15.030
like that.

00:03:15.030 --> 00:03:17.560
And that would not be
a good representation.

00:03:17.560 --> 00:03:18.060
OK.

00:03:18.060 --> 00:03:21.930
So these things come up, but
they're not the main focus

00:03:21.930 --> 00:03:23.070
of the problems we solve.

00:03:23.070 --> 00:03:24.720
What are the main focus of the--

00:03:24.720 --> 00:03:27.240
how do we solve a computational
problem in this class?

00:03:27.240 --> 00:03:30.600
I gave you two ways at
the beginning of the term.

00:03:30.600 --> 00:03:33.750
Do you guys remember?

00:03:33.750 --> 00:03:45.270
We can solve-- how to solve a
computational-- computational

00:03:45.270 --> 00:03:45.770
problem.

00:03:51.548 --> 00:03:52.340
One's the hard way.

00:03:52.340 --> 00:03:53.930
One's the easy way.

00:03:53.930 --> 00:03:54.890
AUDIENCE: Brute force.

00:03:54.890 --> 00:03:55.520
JASON KU: Brute force.

00:03:55.520 --> 00:03:56.020
OK.

00:03:56.020 --> 00:03:58.910
So you're describing
to me a technique

00:03:58.910 --> 00:04:00.440
for making your own algorithm.

00:04:00.440 --> 00:04:01.160
Right?

00:04:01.160 --> 00:04:05.840
I can just design my new
algorithm from scratch.

00:04:05.840 --> 00:04:07.690
One way I could do
that is brute force it.

00:04:07.690 --> 00:04:08.190
Right?

00:04:08.190 --> 00:04:10.910
Look at all the possible
outputs and see which one works.

00:04:10.910 --> 00:04:11.780
Right?

00:04:11.780 --> 00:04:14.192
Or I could reduce to something
like divide and conquer

00:04:14.192 --> 00:04:15.150
or something like that.

00:04:15.150 --> 00:04:16.490
That's generally a
hard thing to do--

00:04:16.490 --> 00:04:17.615
to make your own algorithm.

00:04:17.615 --> 00:04:18.860
Right?

00:04:18.860 --> 00:04:21.380
That's why we don't ask you
to do it a lot in this class.

00:04:21.380 --> 00:04:22.580
It's an 046 kind of thing.

00:04:22.580 --> 00:04:23.080
Right?

00:04:23.080 --> 00:04:31.100
So the first thing you could do
is write design a new algorithm

00:04:31.100 --> 00:04:33.410
from scratch.

00:04:33.410 --> 00:04:35.190
Usually it's not from scratch.

00:04:35.190 --> 00:04:35.690
Right?

00:04:35.690 --> 00:04:38.360
Usually you're reducing to
some kind of algorithmic design

00:04:38.360 --> 00:04:40.940
paradigm that you've
maybe heard of.

00:04:40.940 --> 00:04:44.480
You'll talk a lot more about it
in 046 and at the end of this

00:04:44.480 --> 00:04:46.490
term when we talk about
dynamic programming.

00:04:46.490 --> 00:04:48.980
But generally, that's
a hard thing to do.

00:04:48.980 --> 00:04:50.270
Right?

00:04:50.270 --> 00:04:52.400
You're trying to think
of a recursive algorithm.

00:04:52.400 --> 00:04:53.060
Right?

00:04:53.060 --> 00:04:55.280
You're trying to prove
that it's correct--

00:04:55.280 --> 00:04:57.440
all these nitty gritty--
we have actually,

00:04:57.440 --> 00:04:59.270
throughout the
class in lectures,

00:04:59.270 --> 00:05:02.330
have been showing
you the algorithms.

00:05:02.330 --> 00:05:05.300
But we're not really expecting
you to make those algorithms.

00:05:05.300 --> 00:05:08.660
What are we expecting you
to do most of the time.

00:05:08.660 --> 00:05:09.710
Yeah?

00:05:09.710 --> 00:05:12.810
To reduce it to a problem that
we showed you how to solve.

00:05:12.810 --> 00:05:13.310
Right?

00:05:19.940 --> 00:05:21.830
I'm going to say
thing here, but really

00:05:21.830 --> 00:05:25.250
what I mean is an algorithm
that we've taught you to--

00:05:25.250 --> 00:05:28.790
basically here-- reduced
to a known thing--

00:05:28.790 --> 00:05:31.940
to known thing.

00:05:31.940 --> 00:05:36.440
Usually that means there's
a problem or an interface

00:05:36.440 --> 00:05:38.540
that we've given you.

00:05:38.540 --> 00:05:41.720
And in general, we've shown
you multiple different ways

00:05:41.720 --> 00:05:43.770
to solve that
problem or interface.

00:05:43.770 --> 00:05:44.270
Right?

00:05:44.270 --> 00:05:48.770
So we've shown you many
ways on how to sort things.

00:05:48.770 --> 00:05:51.050
And we've shown you many
ways on how to implement

00:05:51.050 --> 00:05:53.840
sequence and set interfaces.

00:05:53.840 --> 00:05:55.340
Remember?

00:05:55.340 --> 00:05:59.690
And a lot of times
the types of problems

00:05:59.690 --> 00:06:03.710
that we're asking you to do
is to just use as a black box

00:06:03.710 --> 00:06:05.040
some of the things that we did.

00:06:05.040 --> 00:06:08.340
But you need, as a programmer,
as a computer scientist,

00:06:08.340 --> 00:06:12.350
you need to tell me when
I should use what went.

00:06:12.350 --> 00:06:12.850
Right?

00:06:12.850 --> 00:06:13.310
Yeah?

00:06:13.310 --> 00:06:15.980
AUDIENCE: Could you clarify what
you mean by use as a black box?

00:06:15.980 --> 00:06:16.970
JASON KU: Use as a black box.

00:06:16.970 --> 00:06:17.470
Exactly.

00:06:17.470 --> 00:06:18.230
Right.

00:06:18.230 --> 00:06:20.690
So this is a phrase that
I use and a lot of people

00:06:20.690 --> 00:06:21.920
in computer science use.

00:06:21.920 --> 00:06:26.030
It's basically you import
a library into your code.

00:06:26.030 --> 00:06:26.990
Right?

00:06:26.990 --> 00:06:27.810
What do I have?

00:06:27.810 --> 00:06:29.120
I have an API.

00:06:29.120 --> 00:06:31.520
I have a way to
interact with that code.

00:06:31.520 --> 00:06:32.960
I don't actually
know what's going

00:06:32.960 --> 00:06:35.990
on inside of that library.

00:06:35.990 --> 00:06:37.670
I'm using it as a black box.

00:06:37.670 --> 00:06:38.990
It's opaque to me.

00:06:38.990 --> 00:06:40.640
I cannot look inside--

00:06:40.640 --> 00:06:43.550
I can actually probably could
look inside what their code is,

00:06:43.550 --> 00:06:44.750
but I'm not going to.

00:06:44.750 --> 00:06:46.760
The thing that makes
it useful to me

00:06:46.760 --> 00:06:49.460
is that has this
useful API that I

00:06:49.460 --> 00:06:52.150
trust it to do the
things that you told me

00:06:52.150 --> 00:06:53.150
that it was going to do.

00:06:53.150 --> 00:06:53.690
Right?

00:06:53.690 --> 00:06:56.000
And so there's kind of--

00:06:56.000 --> 00:06:58.490
I'm going to jump around a
little bit here actually,

00:06:58.490 --> 00:07:02.100
because that's a great question.

00:07:02.100 --> 00:07:08.330
So here I think of there's three
different types of problems

00:07:08.330 --> 00:07:11.630
that we talk about, that
we give you in this class.

00:07:11.630 --> 00:07:13.790
You might have seen
this on the problem set.

00:07:13.790 --> 00:07:14.690
Right?

00:07:14.690 --> 00:07:18.650
I like to categorize them into
three different categories

00:07:18.650 --> 00:07:19.230
here.

00:07:19.230 --> 00:07:24.380
One is you have to understand
the internals of a data

00:07:24.380 --> 00:07:26.630
structure, an
algorithm that we know.

00:07:26.630 --> 00:07:29.810
You have to be able to look
inside and, I don't know,

00:07:29.810 --> 00:07:32.900
given a node in a balanced
binary search tree--

00:07:32.900 --> 00:07:34.460
an AVL tree--

00:07:34.460 --> 00:07:35.870
how can I do a rotation?

00:07:35.870 --> 00:07:36.530
Right?

00:07:36.530 --> 00:07:38.660
Or how do I do an insert?

00:07:38.660 --> 00:07:43.370
Or something about the
structure of this thing--

00:07:43.370 --> 00:07:46.250
a binary heap--
where are the top k

00:07:46.250 --> 00:07:49.700
things in a max binary heap,
which is on your problem set.

00:07:49.700 --> 00:07:54.830
Those things require me to very
much not black box these data

00:07:54.830 --> 00:07:55.430
structures.

00:07:55.430 --> 00:07:56.630
It's a white box.

00:07:56.630 --> 00:07:57.170
Right?

00:07:57.170 --> 00:07:59.940
I need to know what's inside of
that to answer that question.

00:07:59.940 --> 00:08:00.440
Right?

00:08:00.440 --> 00:08:02.240
I need to know about the
internals of that data

00:08:02.240 --> 00:08:02.740
structure.

00:08:02.740 --> 00:08:03.740
Right?

00:08:03.740 --> 00:08:06.463
And there are other types of
problems where it's like, oh,

00:08:06.463 --> 00:08:08.630
I don't need to know what
the internals of this data

00:08:08.630 --> 00:08:09.950
structure is.

00:08:09.950 --> 00:08:14.450
I can just operate with
knowledge of the API

00:08:14.450 --> 00:08:17.150
and try to hook it in to
the problem that I need.

00:08:17.150 --> 00:08:20.020
And that's what I call a
reduction type problem.

00:08:20.020 --> 00:08:22.880
This is how does the core
material we presented

00:08:22.880 --> 00:08:25.280
to you in lecture work?

00:08:25.280 --> 00:08:28.580
This is how do I apply
that core material?

00:08:28.580 --> 00:08:31.940
And harder than
both of those things

00:08:31.940 --> 00:08:34.788
is what I might call a
modification type of--

00:08:34.788 --> 00:08:36.080
these aren't really good names.

00:08:36.080 --> 00:08:38.100
I came up with
these this morning.

00:08:38.100 --> 00:08:40.440
But it's trying
to get at the idea

00:08:40.440 --> 00:08:44.400
here that it's possible that you
need to know what the API is,

00:08:44.400 --> 00:08:46.515
and you need to know what's
going on inside to be

00:08:46.515 --> 00:08:47.640
able to answer the problem.

00:08:47.640 --> 00:08:51.660
Things like adapting a
divide and conquer algorithm.

00:08:51.660 --> 00:08:56.970
Or making-- instead of
using a dynamic array that

00:08:56.970 --> 00:08:58.950
has extra space on
one end, maybe I

00:08:58.950 --> 00:09:01.560
have to put extra space in the
middle or something like that.

00:09:01.560 --> 00:09:02.060
Right?

00:09:02.060 --> 00:09:04.800
I'm adapting something that
was from the core material.

00:09:04.800 --> 00:09:05.850
It's pretty close.

00:09:05.850 --> 00:09:07.350
But I have to modify
it in some way.

00:09:07.350 --> 00:09:08.490
Augmentation right?

00:09:08.490 --> 00:09:12.570
I have to take the vanilla
said AVL tree that I might

00:09:12.570 --> 00:09:15.480
have given you and put some
other property on the nodes

00:09:15.480 --> 00:09:18.870
and you need to tell me
how to maintain that.

00:09:18.870 --> 00:09:21.880
How can I compute that subtree
property from its children?

00:09:21.880 --> 00:09:23.500
Does that make sense?

00:09:23.500 --> 00:09:26.490
So this is the
harder of the things.

00:09:26.490 --> 00:09:27.000
Right?

00:09:27.000 --> 00:09:29.530
If you can identify
which one of these--

00:09:29.530 --> 00:09:31.750
a problem that you
look at on an exam--

00:09:31.750 --> 00:09:34.050
[INAUDIBLE] under--
maybe that can help you

00:09:34.050 --> 00:09:36.930
conceptualize what should I use.

00:09:36.930 --> 00:09:38.860
For a reduction type problem--

00:09:38.860 --> 00:09:41.310
I'm going to talk about
this in a second--

00:09:41.310 --> 00:09:43.950
but a lot of times it's
useful to reduce it

00:09:43.950 --> 00:09:50.910
to a problem or an interface
rather than an algorithm

00:09:50.910 --> 00:09:52.980
or a data structure.

00:09:52.980 --> 00:09:56.070
What does that mean?

00:09:56.070 --> 00:10:01.620
If I can solve the problem by
saying reducing to sorting,

00:10:01.620 --> 00:10:03.720
I can argue to you that
that algorithm is correct.

00:10:03.720 --> 00:10:05.680
I just use sorting
as a black box.

00:10:05.680 --> 00:10:07.560
Now it might not be efficient.

00:10:07.560 --> 00:10:11.640
My choice of sorting
algorithm that I chose matters

00:10:11.640 --> 00:10:12.505
for efficiency.

00:10:12.505 --> 00:10:14.130
But for correctness,
it doesn't matter.

00:10:14.130 --> 00:10:15.000
Right?

00:10:15.000 --> 00:10:18.420
For a data structures
problem I might

00:10:18.420 --> 00:10:22.410
reduce to using two set
data structures and sequence

00:10:22.410 --> 00:10:24.840
data structure or
something like that.

00:10:24.840 --> 00:10:30.930
But it will be correct if I
reduce it to those things.

00:10:30.930 --> 00:10:36.300
I can define the operations
in terms of those interfaces.

00:10:36.300 --> 00:10:38.100
I don't have to make
that choice until I

00:10:38.100 --> 00:10:39.100
talk about running time.

00:10:39.100 --> 00:10:39.600
Right?

00:10:39.600 --> 00:10:40.950
Until I talk about efficiency.

00:10:40.950 --> 00:10:44.820
And the name of the game
on the quiz to get points--

00:10:44.820 --> 00:10:48.390
we can't give you points
for an incorrect algorithm

00:10:48.390 --> 00:10:50.340
or something that's
pretty close to correct.

00:10:50.340 --> 00:10:51.990
Right?

00:10:51.990 --> 00:10:53.790
And we can't give
you full points

00:10:53.790 --> 00:10:57.840
unless the correct algorithm
you give us is efficient

00:10:57.840 --> 00:11:00.570
and that you've argued things
like correctness and running

00:11:00.570 --> 00:11:02.430
time and things like that.

00:11:02.430 --> 00:11:07.260
Your algorithm could be
correct and efficient,

00:11:07.260 --> 00:11:10.090
but you analyzed the
running time incorrectly

00:11:10.090 --> 00:11:11.700
so we mark you
points off for there.

00:11:11.700 --> 00:11:15.450
Or most of the time what
you do is you present us

00:11:15.450 --> 00:11:17.790
with an inefficient algorithm.

00:11:17.790 --> 00:11:19.500
And then you analyze
the running time

00:11:19.500 --> 00:11:22.050
as if it's the target running
time that we gave you.

00:11:22.050 --> 00:11:22.650
Right?

00:11:22.650 --> 00:11:24.310
That's bad on two fronts.

00:11:24.310 --> 00:11:24.970
Right?

00:11:24.970 --> 00:11:25.470
OK.

00:11:25.470 --> 00:11:27.220
So try not to fall
into these traps.

00:11:27.220 --> 00:11:27.720
OK.

00:11:27.720 --> 00:11:30.060
So some general test
taking strategies when

00:11:30.060 --> 00:11:31.840
you're looking at your quiz.

00:11:31.840 --> 00:11:35.250
I really strongly urge you to
read through the entire exam

00:11:35.250 --> 00:11:38.760
before you start because
some of the problems

00:11:38.760 --> 00:11:40.780
will be easier for
you than others.

00:11:40.780 --> 00:11:44.100
And if you're trying
to maximize points

00:11:44.100 --> 00:11:49.050
on here as all of you, I'm
sure, are trying to do,

00:11:49.050 --> 00:11:53.160
it's useful to make that initial
pass through the problems

00:11:53.160 --> 00:11:55.530
to see which ones
are easiest for you.

00:11:55.530 --> 00:11:58.440
And then you can tackle
them in the order

00:11:58.440 --> 00:11:59.790
in which you have confidence.

00:11:59.790 --> 00:12:05.370
Now in actuality, the average
on say quiz one of this class

00:12:05.370 --> 00:12:09.180
tends to be around, I don't
know, between 60 and 80.

00:12:09.180 --> 00:12:11.970
I don't think it's ever been 80.

00:12:11.970 --> 00:12:15.210
But it's not 100.

00:12:15.210 --> 00:12:21.690
So doing 50% of the
problems well is probably

00:12:21.690 --> 00:12:24.510
going to be better for you
in terms of time management

00:12:24.510 --> 00:12:28.290
and those kinds of things
than doing all of the--

00:12:28.290 --> 00:12:30.390
attempting all of
the problems and not

00:12:30.390 --> 00:12:33.840
doing great on any of
them in terms of point--

00:12:33.840 --> 00:12:35.880
you have to, in
computer science,

00:12:35.880 --> 00:12:39.690
you have to be pretty close to
a correct answer to get points.

00:12:39.690 --> 00:12:40.410
Right?

00:12:40.410 --> 00:12:43.960
It basically needs to be almost
correct or you don't get--

00:12:43.960 --> 00:12:46.590
if you've seen how
your problem sets are

00:12:46.590 --> 00:12:48.510
being graded-- sometimes
our problem set

00:12:48.510 --> 00:12:50.310
graders make mistakes.

00:12:50.310 --> 00:12:56.110
Sometimes they give you points
for an incorrect solution.

00:12:56.110 --> 00:12:56.610
Right?

00:12:56.610 --> 00:12:59.730
It's really on you to take
a look at your problem sets

00:12:59.730 --> 00:13:02.370
that you gave us and our
solutions that we gave you.

00:13:02.370 --> 00:13:06.090
We spent a lot of time writing
good solutions for you guys.

00:13:06.090 --> 00:13:09.460
You need to make sure
that the material.

00:13:09.460 --> 00:13:12.330
Don't come up to us
at the end of an exam

00:13:12.330 --> 00:13:16.440
and say, oh, I said the same
thing on my problem set.

00:13:16.440 --> 00:13:19.050
It was marked correct and
you guys marked it wrong.

00:13:19.050 --> 00:13:20.370
Well, yeah.

00:13:20.370 --> 00:13:21.780
The staff knows
a little bit more

00:13:21.780 --> 00:13:25.050
about algorithms than your
graders on your problem sets.

00:13:25.050 --> 00:13:26.950
And we grade your exams.

00:13:26.950 --> 00:13:29.190
So unfortunately,
that's not an excuse.

00:13:29.190 --> 00:13:31.020
It's on you to
know the material.

00:13:31.020 --> 00:13:31.800
Yep?

00:13:31.800 --> 00:13:33.780
AUDIENCE: So are
most of the problems

00:13:33.780 --> 00:13:36.180
on the exams multiple
part things where

00:13:36.180 --> 00:13:37.740
we need to have a
good understanding

00:13:37.740 --> 00:13:39.553
and do the first
few parts in order

00:13:39.553 --> 00:13:41.470
to get even partial
credit on the other parts?

00:13:41.470 --> 00:13:42.765
Or is it like [INAUDIBLE]?

00:13:42.765 --> 00:13:43.390
JASON KU: Yeah.

00:13:43.390 --> 00:13:48.400
So the question
is, are questions

00:13:48.400 --> 00:13:53.020
built on top of each other so
that you're kind of at a wall

00:13:53.020 --> 00:13:54.670
if you missed the first part?

00:13:54.670 --> 00:13:56.750
We try not to design
exams that way.

00:13:56.750 --> 00:13:57.250
OK.

00:13:57.250 --> 00:13:59.770
You can actually take a
look at the practice exam

00:13:59.770 --> 00:14:02.500
that's already been posted.

00:14:02.500 --> 00:14:04.900
Our problems tend to
be self-contained.

00:14:04.900 --> 00:14:07.450
And if they are multiple
parts, the parts

00:14:07.450 --> 00:14:10.300
are usually independent.

00:14:10.300 --> 00:14:13.420
Usually you don't need to
have done A correctly in order

00:14:13.420 --> 00:14:14.710
to do B correctly.

00:14:14.710 --> 00:14:16.090
All right?

00:14:16.090 --> 00:14:18.730
And that's how our problem
sets try to be written as well.

00:14:18.730 --> 00:14:23.163
For your last coding
question and 4

00:14:23.163 --> 00:14:24.580
you had this problem
where you had

00:14:24.580 --> 00:14:26.830
to design this data structure.

00:14:26.830 --> 00:14:29.410
But C said use
that as a black box

00:14:29.410 --> 00:14:31.360
essentially and
solve the problem.

00:14:31.360 --> 00:14:32.380
Right?

00:14:32.380 --> 00:14:34.000
So you actually
don't need to show--

00:14:34.000 --> 00:14:36.970
we've given you this interface.

00:14:36.970 --> 00:14:38.680
You can just use
that interface to be

00:14:38.680 --> 00:14:42.550
able to answer C, the
algorithms question,

00:14:42.550 --> 00:14:45.610
without even solving the data
structures question correctly.

00:14:45.610 --> 00:14:47.300
Does that make sense?

00:14:47.300 --> 00:14:49.180
And actually, the
algorithms question

00:14:49.180 --> 00:14:52.150
was the easier one there, I
think, from what I remember.

00:14:52.150 --> 00:14:52.780
Yeah?

00:14:52.780 --> 00:14:54.460
AUDIENCE: Do we have to
write code on the exam?

00:14:54.460 --> 00:14:56.460
JASON KU: Do you have to
write code on the exam?

00:14:59.170 --> 00:15:04.360
I've never given an exam where
you've had to write code.

00:15:04.360 --> 00:15:07.660
I have written exams where
you have to read code.

00:15:07.660 --> 00:15:08.170
OK?

00:15:08.170 --> 00:15:11.410
So pseudocode or Python--

00:15:11.410 --> 00:15:13.330
since Python's a
prerequisite for this class,

00:15:13.330 --> 00:15:15.370
it's completely fair
game that we give you

00:15:15.370 --> 00:15:16.930
small snippets of
Python code and you

00:15:16.930 --> 00:15:21.370
have to be able to
understand what's going on.

00:15:21.370 --> 00:15:22.870
Yeah?

00:15:22.870 --> 00:15:24.640
AUDIENCE: You
listed amortization

00:15:24.640 --> 00:15:27.310
under the modification
[INAUDIBLE]..

00:15:27.310 --> 00:15:31.305
Does that mean we're using
an amortized [INAUDIBLE]??

00:15:31.305 --> 00:15:31.930
JASON KU: Yeah.

00:15:31.930 --> 00:15:34.330
What I mean here--

00:15:34.330 --> 00:15:37.720
amortization certainly
appears in here or here--

00:15:37.720 --> 00:15:39.460
these kinds of things.

00:15:39.460 --> 00:15:41.590
Oftentimes if I'm
using a dynamic array,

00:15:41.590 --> 00:15:44.440
if I'm using a binary heap,
if I'm using a hash table,

00:15:44.440 --> 00:15:47.710
amortization will appear
here in our running times

00:15:47.710 --> 00:15:49.090
for those dynamic operations.

00:15:49.090 --> 00:15:51.040
What I mean here
in amortization--

00:15:51.040 --> 00:15:53.950
I mean if I'm asking you
to generalize something

00:15:53.950 --> 00:15:57.940
that we've done like with
dynamic arrays where instead

00:15:57.940 --> 00:16:00.100
of adding additional
space at the end,

00:16:00.100 --> 00:16:02.020
I'm putting additional
space in the middle

00:16:02.020 --> 00:16:04.580
or at the beginning or
something like that.

00:16:04.580 --> 00:16:08.050
And you're having to do some
kind of amortized analysis.

00:16:08.050 --> 00:16:13.940
Now, often it's
unnecessary to do this in--

00:16:13.940 --> 00:16:16.900
when we talked about
a problem where

00:16:16.900 --> 00:16:19.990
we did do our own
amoritized analysis

00:16:19.990 --> 00:16:22.150
and making a double ended deck--

00:16:22.150 --> 00:16:24.630
I mean a double ended queue--

00:16:24.630 --> 00:16:26.830
you could actually
solve it by reducing

00:16:26.830 --> 00:16:31.090
to using two dynamic arrays.

00:16:31.090 --> 00:16:32.020
Right?

00:16:32.020 --> 00:16:37.540
So there's a lot of
ways in which you

00:16:37.540 --> 00:16:39.280
could reduce to using things.

00:16:39.280 --> 00:16:41.500
But you might have to do
some additional bookkeeping

00:16:41.500 --> 00:16:42.430
at the end.

00:16:42.430 --> 00:16:46.750
But what this is saying
is that these are more--

00:16:46.750 --> 00:16:48.400
you're not using
things as a black box.

00:16:48.400 --> 00:16:51.650
You're changing something about
the boxes that we gave you.

00:16:51.650 --> 00:16:52.150
Right?

00:16:52.150 --> 00:16:53.560
Does that make sense.

00:16:53.560 --> 00:16:54.340
Yeah?

00:16:54.340 --> 00:16:56.980
AUDIENCE: If you tell us to
write an algorithm that does

00:16:56.980 --> 00:17:00.610
something like O(log n)
time, and we can think only

00:17:00.610 --> 00:17:03.060
of an algorithm that does
something inefficiently like

00:17:03.060 --> 00:17:03.968
O(n) at end time.

00:17:03.968 --> 00:17:04.510
JASON KU: OK.

00:17:04.510 --> 00:17:06.470
AUDIENCE: Then is there
any point writing that?

00:17:06.470 --> 00:17:07.095
JASON KU: Sure.

00:17:07.095 --> 00:17:11.589
So let's actually
move on for a second.

00:17:11.589 --> 00:17:19.430
I actually-- I'm going to
answer your question very soon.

00:17:19.430 --> 00:17:20.329
OK.

00:17:20.329 --> 00:17:22.339
But I'm going to get
to it in a second.

00:17:22.339 --> 00:17:23.750
OK?

00:17:23.750 --> 00:17:26.960
If I don't answer that question
in five minutes, please let me

00:17:26.960 --> 00:17:27.619
know.

00:17:27.619 --> 00:17:28.730
OK?

00:17:28.730 --> 00:17:30.500
So the first thing,
when I'm approaching

00:17:30.500 --> 00:17:33.260
a problem on the
exam, I might try

00:17:33.260 --> 00:17:35.730
to ask some questions
about the problem.

00:17:35.730 --> 00:17:36.230
OK.

00:17:36.230 --> 00:17:38.360
It's going to help me
decide what to use.

00:17:38.360 --> 00:17:39.260
Right?

00:17:39.260 --> 00:17:41.600
Different than
your problems sets.

00:17:41.600 --> 00:17:43.610
Your problem sets--
basically, what

00:17:43.610 --> 00:17:47.150
do you use is what did we talk
about in lecture that week.

00:17:47.150 --> 00:17:49.280
On a quiz you have
eight lectures

00:17:49.280 --> 00:17:51.030
that you've talked about.

00:17:51.030 --> 00:17:52.940
And so this is going
to be a harder thing

00:17:52.940 --> 00:17:56.030
for you to do because you don't
know which of the eight lecture

00:17:56.030 --> 00:17:57.950
material is going to
apply to this problem.

00:17:57.950 --> 00:18:00.020
And it could be a
combination of them actually.

00:18:00.020 --> 00:18:03.260
And so I'm trying to give
you ways of answering

00:18:03.260 --> 00:18:04.290
that question faster.

00:18:04.290 --> 00:18:04.790
OK?

00:18:04.790 --> 00:18:07.578
So is this a
mechanical reduction

00:18:07.578 --> 00:18:08.870
or a modification type problem?

00:18:08.870 --> 00:18:11.433
That's just going to help
me determine the difficulty

00:18:11.433 --> 00:18:12.350
level of what this is.

00:18:12.350 --> 00:18:14.240
You might not be
able to answer it.

00:18:14.240 --> 00:18:17.000
But it can give you a sense
for what kind of problem it is.

00:18:17.000 --> 00:18:20.840
Is this a problem about data
structures sorting both?

00:18:20.840 --> 00:18:22.460
Right?

00:18:22.460 --> 00:18:24.860
If it's about data
structures, do I

00:18:24.860 --> 00:18:26.780
need to support
sequence type operations

00:18:26.780 --> 00:18:30.620
or do I need to store an
extrinsic order on something?

00:18:30.620 --> 00:18:34.970
Or is it a thing where I care
about what the objects are?

00:18:34.970 --> 00:18:37.850
I'm trying to look things
up by what they are.

00:18:37.850 --> 00:18:39.110
Or maybe both?

00:18:39.110 --> 00:18:40.580
Or maybe some combination?

00:18:40.580 --> 00:18:42.920
If I have a bunch of
different types of keys

00:18:42.920 --> 00:18:44.900
that I might want
a query on, I might

00:18:44.900 --> 00:18:48.080
have to use at least two
set type of data structures.

00:18:48.080 --> 00:18:48.588
Right?

00:18:48.588 --> 00:18:50.630
You could get very
complicated with these things.

00:18:50.630 --> 00:18:52.790
But putting it in
terms of well, I'm

00:18:52.790 --> 00:18:59.150
going to need to do this kind
of operation on these names.

00:18:59.150 --> 00:19:01.550
Then I can think, oh, I need
a set data structure there.

00:19:01.550 --> 00:19:03.530
I'll think about how to
implement that later.

00:19:03.530 --> 00:19:04.490
Should I use a hash table?

00:19:04.490 --> 00:19:05.657
Should I use a sorted array?

00:19:05.657 --> 00:19:07.550
Should I use a AVL tree?

00:19:07.550 --> 00:19:11.780
But thinking about it first
at the abstract level of I

00:19:11.780 --> 00:19:15.200
need a set data structure here
can help you compartmentalize

00:19:15.200 --> 00:19:17.150
correctness versus efficiency.

00:19:17.150 --> 00:19:18.530
Does that make sense?

00:19:18.530 --> 00:19:19.610
OK.

00:19:19.610 --> 00:19:23.480
If you're stuck, this
is your question.

00:19:23.480 --> 00:19:27.590
If you're stuck, write
down a correct algorithm

00:19:27.590 --> 00:19:29.540
that's inefficient.

00:19:29.540 --> 00:19:32.000
We can give you points for
a correct algorithm that's

00:19:32.000 --> 00:19:32.600
inefficient.

00:19:32.600 --> 00:19:34.050
At least it's a
correct algorithm.

00:19:34.050 --> 00:19:35.510
That's better than other things.

00:19:35.510 --> 00:19:36.470
Right?

00:19:36.470 --> 00:19:41.150
Now, if it's
exponential time, you

00:19:41.150 --> 00:19:44.570
might be limited to 10%
or 20% of the points.

00:19:44.570 --> 00:19:47.300
But if it's a log factor--

00:19:47.300 --> 00:19:50.360
worse, or linear factor-- worse.

00:19:50.360 --> 00:19:52.070
Maybe that's OK.

00:19:52.070 --> 00:19:56.270
On a data structures problem,
if any operation takes order n

00:19:56.270 --> 00:19:59.405
time, that's probably not going
to give you a lot of points

00:19:59.405 --> 00:20:01.280
because the whole point
of the data structure

00:20:01.280 --> 00:20:04.520
is to make those
operations fast.

00:20:04.520 --> 00:20:08.570
But if it solves the problem,
you'll get some points.

00:20:08.570 --> 00:20:10.190
You won't get 0 points.

00:20:10.190 --> 00:20:11.000
Yeah?

00:20:11.000 --> 00:20:12.458
AUDIENCE: Will we
get any questions

00:20:12.458 --> 00:20:14.250
that are like how fast
can you make this?

00:20:14.250 --> 00:20:15.350
Make this as fast as possible.

00:20:15.350 --> 00:20:15.975
JASON KU: Yeah.

00:20:15.975 --> 00:20:19.590
So a lot of times we'll say,
give us an efficient algorithm.

00:20:19.590 --> 00:20:20.090
OK.

00:20:20.090 --> 00:20:22.820
It's like, whoa, I don't know
if it's efficient or not.

00:20:22.820 --> 00:20:25.170
Well, that just means that
faster running times are

00:20:25.170 --> 00:20:26.540
going to give you more points.

00:20:26.540 --> 00:20:27.110
OK?

00:20:27.110 --> 00:20:31.580
So in questions like
that, it's mostly

00:20:31.580 --> 00:20:34.370
trying to play this game of--

00:20:34.370 --> 00:20:37.850
usually, we'll put an efficient
one in not in terms of a data

00:20:37.850 --> 00:20:40.850
structure because usually,
the data structures problem--

00:20:40.850 --> 00:20:44.270
it's important in
your implementation

00:20:44.270 --> 00:20:47.180
that these data structure
operations be fast.

00:20:47.180 --> 00:20:50.090
And we want to tell
you how fast is.

00:20:50.090 --> 00:20:50.630
Right?

00:20:50.630 --> 00:20:57.200
So data structures questions
in general, there's

00:20:57.200 --> 00:20:59.960
usually a trade-off
between running times

00:20:59.960 --> 00:21:01.430
of these different operations.

00:21:01.430 --> 00:21:04.170
And it's really important how
they relate to each other.

00:21:04.170 --> 00:21:05.750
And so for data
structures problem,

00:21:05.750 --> 00:21:08.790
it's kind of about getting
those running times.

00:21:08.790 --> 00:21:09.290
OK?

00:21:09.290 --> 00:21:13.310
With an algorithms problem
where we ask you to do one thing

00:21:13.310 --> 00:21:15.590
and we try to do it
as fast as possible,

00:21:15.590 --> 00:21:16.610
try to get linear time.

00:21:16.610 --> 00:21:17.110
Right?

00:21:17.110 --> 00:21:20.570
Most of the time you can't
get better than linear time

00:21:20.570 --> 00:21:23.660
if you have to read the
entire input at some point

00:21:23.660 --> 00:21:26.180
if I want to find the
things in my data.

00:21:26.180 --> 00:21:28.880
And if you can't think of
a linear time algorithm,

00:21:28.880 --> 00:21:31.940
think of an n squared thing
or think of n log n thing.

00:21:31.940 --> 00:21:32.750
Right?

00:21:32.750 --> 00:21:36.950
Maybe that's a little hard for
you guys to think of right now.

00:21:36.950 --> 00:21:40.987
But that's why I'm saying start
with any correct algorithm

00:21:40.987 --> 00:21:42.320
and then maybe you can optimize.

00:21:42.320 --> 00:21:44.000
Maybe you can use a
better data structure

00:21:44.000 --> 00:21:45.083
to make it more efficient.

00:21:45.083 --> 00:21:46.920
Does that make sense?

00:21:46.920 --> 00:21:48.900
Any other questions?

00:21:48.900 --> 00:21:50.150
OK.

00:21:50.150 --> 00:21:52.260
Moving right along.

00:21:52.260 --> 00:21:52.760
OK.

00:21:52.760 --> 00:21:55.490
Here's some downsides.

00:21:55.490 --> 00:21:56.270
OK.

00:21:56.270 --> 00:22:00.410
If you find yourself doing one
of these things three things,

00:22:00.410 --> 00:22:01.257
take a step back.

00:22:01.257 --> 00:22:02.840
You're probably doing
something wrong.

00:22:02.840 --> 00:22:04.070
OK?

00:22:04.070 --> 00:22:08.060
So question yourself if you're
trying to compute decimals,

00:22:08.060 --> 00:22:10.430
rationals, or real numbers.

00:22:10.430 --> 00:22:11.900
I can't store
those things on a--

00:22:11.900 --> 00:22:15.060
I mean, I can store decimals
to finite precision.

00:22:15.060 --> 00:22:16.710
But if you're doing
finite precision,

00:22:16.710 --> 00:22:21.255
you might as well multiply your
numbers by that fixed precision

00:22:21.255 --> 00:22:22.380
and deal with the integers.

00:22:22.380 --> 00:22:23.340
Right?

00:22:23.340 --> 00:22:24.810
We only have taught
you how to deal

00:22:24.810 --> 00:22:25.980
with the integers in this class.

00:22:25.980 --> 00:22:26.490
Right?

00:22:26.490 --> 00:22:30.180
We haven't even shown you
how to efficiently compute

00:22:30.180 --> 00:22:32.440
on rationals and real numbers.

00:22:32.440 --> 00:22:36.060
We have told you if you have
a denominator and a numerator

00:22:36.060 --> 00:22:39.150
of a fraction, I can
take two fractions

00:22:39.150 --> 00:22:41.430
and compare them
right in constant time

00:22:41.430 --> 00:22:43.140
by doing cross multiplication.

00:22:43.140 --> 00:22:49.770
But if I'm trying to actually
do this division to arbitrary

00:22:49.770 --> 00:22:54.550
precision, that's not
happy because I can't even

00:22:54.550 --> 00:22:56.550
represent that on my
computer in a finite number

00:22:56.550 --> 00:22:59.850
of decimal points for
some of these things.

00:23:02.670 --> 00:23:05.350
If you're trying to use
Radix sort for every answer,

00:23:05.350 --> 00:23:07.620
it's probably wrong.

00:23:07.620 --> 00:23:11.700
One of the things that we
try to do on our quizzes--

00:23:11.700 --> 00:23:15.210
we're not just giving you a
bunch of problems randomly.

00:23:15.210 --> 00:23:17.010
We probably are
making problems that

00:23:17.010 --> 00:23:19.740
cover the material in some way.

00:23:19.740 --> 00:23:22.350
We do want to test you
on all of the things.

00:23:22.350 --> 00:23:26.670
And so if you find that
you're using the same thing

00:23:26.670 --> 00:23:29.640
four or five times
on the exam, that

00:23:29.640 --> 00:23:33.300
might be a sign that you're
using it too many times.

00:23:33.300 --> 00:23:34.342
It's not always the case.

00:23:34.342 --> 00:23:34.842
Right?

00:23:34.842 --> 00:23:36.360
Sometimes hashing
is super useful,

00:23:36.360 --> 00:23:38.140
so you want to use
it all the time.

00:23:38.140 --> 00:23:41.940
But in particular,
everyone tries

00:23:41.940 --> 00:23:45.090
to use Radix sort when
it's inappropriate.

00:23:45.090 --> 00:23:48.300
And they love because
it gets linear time.

00:23:48.300 --> 00:23:49.140
Right?

00:23:49.140 --> 00:23:55.080
But if you write merge sort for
something where Radix sort will

00:23:55.080 --> 00:23:57.840
apply, you'll get some points
because it's correct but not

00:23:57.840 --> 00:24:01.080
efficient.

00:24:01.080 --> 00:24:03.370
And it's inefficient
by a log factor.

00:24:03.370 --> 00:24:04.530
Right?

00:24:04.530 --> 00:24:08.790
If you're trying to use
Radix sort in a situation

00:24:08.790 --> 00:24:11.340
where comparisons are the
answer and you don't have

00:24:11.340 --> 00:24:13.770
a bound on the integers,
if I don't have

00:24:13.770 --> 00:24:15.330
a bound on the size
of the integers,

00:24:15.330 --> 00:24:19.380
then this may be taking
a huge amount of time.

00:24:19.380 --> 00:24:21.870
So I might not
even think of that

00:24:21.870 --> 00:24:26.095
as being correct because it
could be exponential time.

00:24:26.095 --> 00:24:26.970
I mean, I don't know.

00:24:26.970 --> 00:24:28.512
I don't know how
big my word size is.

00:24:28.512 --> 00:24:30.850
It could be arbitrarily bad.

00:24:30.850 --> 00:24:32.340
OK.

00:24:32.340 --> 00:24:34.170
And then if you're
trying to augment

00:24:34.170 --> 00:24:37.470
a binary tree with something
that's not a subtree property--

00:24:37.470 --> 00:24:40.350
something that can't be
computed from the augmentations

00:24:40.350 --> 00:24:41.730
of its two children--

00:24:41.730 --> 00:24:43.050
you're doing something bad.

00:24:43.050 --> 00:24:48.240
Every exam we have
30% of students

00:24:48.240 --> 00:24:58.410
say augment by my index in the
entire tree or augment by--

00:24:58.410 --> 00:25:00.150
here's one that's fun--

00:25:00.150 --> 00:25:03.195
augment by the size
of my left subtree--

00:25:07.090 --> 00:25:09.610
the number of nodes
in my left subtree.

00:25:09.610 --> 00:25:10.390
How can I--

00:25:14.010 --> 00:25:17.920
I'm not sure how I can maintain
that with rotations and things

00:25:17.920 --> 00:25:20.420
like that.

00:25:20.420 --> 00:25:21.700
Let's see.

00:25:21.700 --> 00:25:24.910
In order for me to keep
track of the augmentation

00:25:24.910 --> 00:25:30.430
of my left tree from the
augmentation of my left tree,

00:25:30.430 --> 00:25:33.310
I have to do a logarithmic
walk all the way down the thing

00:25:33.310 --> 00:25:35.260
to figure out how many
things were there.

00:25:35.260 --> 00:25:37.540
So that's not a maintainable
thing in constant time.

00:25:37.540 --> 00:25:39.910
If I want to augment
something of my left subtree,

00:25:39.910 --> 00:25:42.910
just augment the thing
itself and just look

00:25:42.910 --> 00:25:45.250
at your left subtree and
look at its augmentation.

00:25:45.250 --> 00:25:46.720
Does that make sense?

00:25:46.720 --> 00:25:47.252
Yeah?

00:25:47.252 --> 00:25:49.460
AUDIENCE: If you had say,
augmented it with a subtree

00:25:49.460 --> 00:25:52.030
and then augmented it again with
[INAUDIBLE] subtree and then

00:25:52.030 --> 00:25:52.240
use that--

00:25:52.240 --> 00:25:53.240
JASON KU: You could do that.

00:25:53.240 --> 00:25:53.920
AUDIENCE: --does
that still count as--

00:25:53.920 --> 00:25:54.670
JASON KU: You could do that.

00:25:54.670 --> 00:25:55.010
Yeah.

00:25:55.010 --> 00:25:56.552
So you could do that
in constant time

00:25:56.552 --> 00:25:58.750
by augmenting by subtree size.

00:25:58.750 --> 00:25:59.470
Right?

00:25:59.470 --> 00:26:01.360
AUDIENCE: And then have another
augmentation in [INAUDIBLE]..

00:26:01.360 --> 00:26:03.943
JASON KU: You could have another
augmentation because then you

00:26:03.943 --> 00:26:06.580
could just look at-- but then
just look at your left subtree

00:26:06.580 --> 00:26:07.350
please.

00:26:07.350 --> 00:26:08.473
Yeah.

00:26:08.473 --> 00:26:09.640
No reason to store it again.

00:26:09.640 --> 00:26:10.140
Right?

00:26:10.140 --> 00:26:12.070
You just do one constant time--

00:26:12.070 --> 00:26:13.570
look to your left.

00:26:13.570 --> 00:26:14.410
OK.

00:26:14.410 --> 00:26:15.830
Don't do that.

00:26:15.830 --> 00:26:16.450
OK.

00:26:16.450 --> 00:26:19.310
So that is-- cool.

00:26:19.310 --> 00:26:20.740
I'm not that far behind.

00:26:20.740 --> 00:26:25.540
Those are my tips on
solving questions.

00:26:25.540 --> 00:26:26.830
Oh, there's one more page.

00:26:26.830 --> 00:26:27.330
Yeah?

00:26:27.330 --> 00:26:29.270
AUDIENCE: So when
defining an augmentation,

00:26:29.270 --> 00:26:32.470
[INAUDIBLE] do the formula and
argue that it's [INAUDIBLE]..

00:26:32.470 --> 00:26:33.220
JASON KU: Exactly.

00:26:33.220 --> 00:26:33.720
Right.

00:26:33.720 --> 00:26:41.320
So the idea is if you give an
augmentation that's not a--

00:26:41.320 --> 00:26:43.210
we're going to talk
about our standard things

00:26:43.210 --> 00:26:45.460
you can reduce to in a second.

00:26:45.460 --> 00:26:49.390
If you're saying, I'm
going to take a set AVL

00:26:49.390 --> 00:26:52.990
tree or a sequence AVL tree--

00:26:52.990 --> 00:26:55.130
and for example, at
the end of lecture,

00:26:55.130 --> 00:26:59.530
we were talking about how
a sequence AVL tree could

00:26:59.530 --> 00:27:02.260
be modified to
support priority queue

00:27:02.260 --> 00:27:05.650
operations in the same
running times as binary heaps.

00:27:05.650 --> 00:27:06.190
Right?

00:27:06.190 --> 00:27:10.150
And that was saying we
store our subtree maxes--

00:27:10.150 --> 00:27:12.490
the max thing in my subtree.

00:27:12.490 --> 00:27:14.800
Right?

00:27:14.800 --> 00:27:16.660
And so that's a
different augmentation

00:27:16.660 --> 00:27:20.960
than what's already augmented
on the sequence AVL tree.

00:27:20.960 --> 00:27:25.400
What are the augmentations
on a sequence AVL tree?

00:27:25.400 --> 00:27:26.320
AUDIENCE: Size.

00:27:26.320 --> 00:27:27.444
JASON KU: Size.

00:27:27.444 --> 00:27:29.038
AUDIENCE: Count.

00:27:29.038 --> 00:27:31.330
JASON KU: So counts is the
same thing as how many nodes

00:27:31.330 --> 00:27:32.080
are in my subtree.

00:27:32.080 --> 00:27:32.590
And?

00:27:32.590 --> 00:27:33.100
AUDIENCE: Height.

00:27:33.100 --> 00:27:33.808
JASON KU: Height.

00:27:33.808 --> 00:27:35.410
Right because it's an AVL tree.

00:27:35.410 --> 00:27:36.730
Right?

00:27:36.730 --> 00:27:40.690
So if I'm augmenting
by max in my subtree,

00:27:40.690 --> 00:27:43.210
that's not part of my
standard interface.

00:27:43.210 --> 00:27:44.595
So you need to tell me that.

00:27:44.595 --> 00:27:45.970
Even though we've
done it before,

00:27:45.970 --> 00:27:47.710
it should be very easy for you.

00:27:47.710 --> 00:27:49.930
Just say, I'm
augmenting by my max.

00:27:49.930 --> 00:27:53.260
Max can be computed
as the max between me

00:27:53.260 --> 00:27:55.300
and my left and right
subtree if they exist.

00:27:55.300 --> 00:27:55.840
Done.

00:27:55.840 --> 00:27:56.620
Right?

00:27:56.620 --> 00:27:58.270
But just do that.

00:27:58.270 --> 00:27:59.560
You have to tell me--

00:27:59.560 --> 00:28:01.270
and it takes
constant time, so it

00:28:01.270 --> 00:28:05.450
can be maintained at constant
time when I'm doing my stuff.

00:28:05.450 --> 00:28:07.840
Does that makes sense?

00:28:07.840 --> 00:28:08.560
OK.

00:28:08.560 --> 00:28:11.470
So the last thing,
I guess especially

00:28:11.470 --> 00:28:14.380
on the data
structures problems, I

00:28:14.380 --> 00:28:17.380
would suggest that you
approach these things

00:28:17.380 --> 00:28:23.000
by solving these problems just
in terms of the interfaces

00:28:23.000 --> 00:28:24.250
first.

00:28:24.250 --> 00:28:27.370
Because then at least you
get something that's correct.

00:28:27.370 --> 00:28:31.210
And then choose the
algorithms or data structures

00:28:31.210 --> 00:28:35.140
that you use to implement
those interfaces afterwards.

00:28:35.140 --> 00:28:37.280
One gets you to a
correct algorithm.

00:28:37.280 --> 00:28:39.070
The other is for efficiency.

00:28:39.070 --> 00:28:42.070
Decoupling these might help
you in solving the problem.

00:28:42.070 --> 00:28:45.290
If it doesn't help you, don't.

00:28:45.290 --> 00:28:48.310
If you're like, whenever I
see a set data structure,

00:28:48.310 --> 00:28:53.710
I'm going to probably use a hash
table, that's probably fine.

00:28:53.710 --> 00:28:55.900
But if we're looking for
worst case time bounds,

00:28:55.900 --> 00:28:57.300
that's probably not fun.

00:28:57.300 --> 00:28:58.990
So you just--

00:29:02.090 --> 00:29:07.300
I'm suggesting that you separate
these things so that you

00:29:07.300 --> 00:29:08.980
concentrate on solving
the problem first

00:29:08.980 --> 00:29:10.240
and then optimize it later.

00:29:10.240 --> 00:29:10.960
Yeah?

00:29:10.960 --> 00:29:12.510
AUDIENCE: Just a question
in regards to worst case

00:29:12.510 --> 00:29:13.030
time bounds.

00:29:13.030 --> 00:29:13.750
JASON KU: Mm-hmm.

00:29:13.750 --> 00:29:15.140
AUDIENCE: So for a hash table.

00:29:15.140 --> 00:29:15.580
JASON KU: Mm-hmm.

00:29:15.580 --> 00:29:16.705
AUDIENCE: Given that's
a code one expected.

00:29:16.705 --> 00:29:17.920
JASON KU: Mm-hmm.

00:29:17.920 --> 00:29:20.227
AUDIENCE: That also implies
that's O of n worst case.

00:29:20.227 --> 00:29:21.310
So could you --technically

00:29:21.310 --> 00:29:22.643
JASON KU: It doesn't imply that.

00:29:22.643 --> 00:29:24.160
It is that.

00:29:24.160 --> 00:29:26.770
So, I mean, you could have
a data structure whose

00:29:26.770 --> 00:29:30.130
expected time bound is constant,
but it's a worst case bound

00:29:30.130 --> 00:29:31.400
is n log n.

00:29:31.400 --> 00:29:34.720
It just happens to be the
fact that for a hash table,

00:29:34.720 --> 00:29:37.990
those worst case
operations are linear.

00:29:37.990 --> 00:29:41.740
But if I --had we had a
question up here beforehand,

00:29:41.740 --> 00:29:45.190
if I had a running time
bound that I did something

00:29:45.190 --> 00:29:51.040
to a hash table in constant
expected time, I did a look up,

00:29:51.040 --> 00:29:56.020
and then I queried an a AVL tree
for the predecessor of a node

00:29:56.020 --> 00:29:58.030
or something like
that, and I did

00:29:58.030 --> 00:30:03.850
that in O of log n time,
what's the worst case running

00:30:03.850 --> 00:30:04.420
time of that?

00:30:04.420 --> 00:30:05.320
AUDIENCE: O of n.

00:30:05.320 --> 00:30:07.090
JASON KU: O of n.

00:30:07.090 --> 00:30:09.977
What's the expected
running time of this thing?

00:30:09.977 --> 00:30:11.440
AUDIENCE: Log n.

00:30:11.440 --> 00:30:12.610
JASON KU: Log n.

00:30:12.610 --> 00:30:14.050
Expected log n.

00:30:14.050 --> 00:30:15.920
Because it's possible
that in the worst case

00:30:15.920 --> 00:30:16.712
it could be higher.

00:30:16.712 --> 00:30:18.810
Does that makes sense?

00:30:18.810 --> 00:30:19.310
OK.

00:30:23.960 --> 00:30:25.370
--so OK.

00:30:25.370 --> 00:30:29.030
The second bullet is just
setting up a data structures

00:30:29.030 --> 00:30:29.680
problem.

00:30:29.680 --> 00:30:31.175
There's a lot of moving parts.

00:30:31.175 --> 00:30:33.050
We're going to do two
data structures problem

00:30:33.050 --> 00:30:35.810
at the end of this session.

00:30:35.810 --> 00:30:41.120
Describe all of the data
structures you're using,

00:30:41.120 --> 00:30:42.620
including what they store.

00:30:42.620 --> 00:30:44.510
If you're storing a
set data structure,

00:30:44.510 --> 00:30:47.150
you better tell me what
the things you're stored

00:30:47.150 --> 00:30:49.340
are keyed on.

00:30:49.340 --> 00:30:51.170
Usually the things
that we're storing

00:30:51.170 --> 00:30:53.450
contain a bunch of
information, and if you just

00:30:53.450 --> 00:30:57.920
say I'm storing all of
the toppings of my pizza

00:30:57.920 --> 00:31:01.323
in the set data structure,
and that's all you tell me,

00:31:01.323 --> 00:31:02.990
I have no idea what
you're talking about

00:31:02.990 --> 00:31:04.940
because I don't know what
the semantics of your data

00:31:04.940 --> 00:31:05.523
structure are.

00:31:05.523 --> 00:31:06.830
What is it keyed on?

00:31:06.830 --> 00:31:09.260
I have to say,
oh, it's keyed on,

00:31:09.260 --> 00:31:14.140
I don't know the y's
or something like that.

00:31:14.140 --> 00:31:14.930
OK.

00:31:14.930 --> 00:31:16.140
And there are invariants.

00:31:16.140 --> 00:31:18.920
How we're setting up these
data structures problem,

00:31:18.920 --> 00:31:22.880
usually how I solve these when
I'm writing the solutions,

00:31:22.880 --> 00:31:28.250
I set up a state of what
this data structure could

00:31:28.250 --> 00:31:29.600
be at some instance.

00:31:29.600 --> 00:31:31.880
I'm going to say,
this data structure

00:31:31.880 --> 00:31:35.090
stores all of the
things less than --k

00:31:35.090 --> 00:31:37.340
with key less than
k, blah, blah, blah.

00:31:37.340 --> 00:31:41.600
And this one stores
the extrinsic order

00:31:41.600 --> 00:31:45.320
of the items based
on blah, blah, blah.

00:31:45.320 --> 00:31:46.100
OK.

00:31:46.100 --> 00:31:50.450
So actually, me stating
what they store in that way

00:31:50.450 --> 00:31:53.690
is actually imposing some kind
of invariant on these data

00:31:53.690 --> 00:31:56.480
structures that I'm
wanting to maintain.

00:31:56.480 --> 00:31:59.150
But what I need to do to prove
that this thing is correct

00:31:59.150 --> 00:32:04.280
is that based on the assumption
that those invariants held

00:32:04.280 --> 00:32:07.820
before my operation.

00:32:07.820 --> 00:32:09.920
Then I can prove that
an operation is correct

00:32:09.920 --> 00:32:15.620
if all of those invariants
are maintained before, then

00:32:15.620 --> 00:32:16.920
after the operation.

00:32:16.920 --> 00:32:19.610
That's kind of how I'm proving
that this thing is correct.

00:32:19.610 --> 00:32:22.100
And then when I'm querying,
I'm doing some kind of lookup

00:32:22.100 --> 00:32:25.280
on this data structure, I
can rely on those invariants.

00:32:25.280 --> 00:32:27.460
I know that those
things are good,

00:32:27.460 --> 00:32:29.780
those things have
been maintained,

00:32:29.780 --> 00:32:32.420
and so I can rely on
those to look up what's

00:32:32.420 --> 00:32:34.250
the largest k of this thing.

00:32:34.250 --> 00:32:35.408
Does that make sense?

00:32:35.408 --> 00:32:36.950
If this is very
abstract, we're going

00:32:36.950 --> 00:32:40.650
to get a little bit more
concrete in just a second.

00:32:40.650 --> 00:32:44.060
And then implement
every operation.

00:32:44.060 --> 00:32:45.950
You have no idea
how many solutions

00:32:45.950 --> 00:32:50.570
we read on the quizzes,
which we give you

00:32:50.570 --> 00:32:55.400
three operations to implement
and you don't even mention one.

00:32:55.400 --> 00:32:57.260
And it's usually
the easiest one.

00:32:57.260 --> 00:32:59.990
It's like inserted into
your data structure.

00:32:59.990 --> 00:33:02.330
It's like, come
on, just say that.

00:33:02.330 --> 00:33:05.630
We can't give you points unless
you mention that operation.

00:33:05.630 --> 00:33:07.480
Does that make sense?

00:33:07.480 --> 00:33:10.520
And then it's going
to help --us happy

00:33:10.520 --> 00:33:12.740
graders give you more points.

00:33:12.740 --> 00:33:17.840
Not really, but if
your solution is

00:33:17.840 --> 00:33:21.200
well-organized and well-labeled
and things like that,

00:33:21.200 --> 00:33:24.760
then we're going to be able to
comprehend your solution better

00:33:24.760 --> 00:33:26.510
and we'll be able to
give you more points.

00:33:26.510 --> 00:33:30.510
Remember, part of this class
is about communication.

00:33:30.510 --> 00:33:37.040
If your thing is correct but we
can't tell what you're saying,

00:33:37.040 --> 00:33:38.035
then it's not correct.

00:33:42.020 --> 00:33:44.280
OK.

00:33:44.280 --> 00:33:44.780
All right.

00:33:44.780 --> 00:33:48.470
So now we get --to
any questions on that?

00:33:48.470 --> 00:33:49.242
Yeah.

00:33:49.242 --> 00:33:51.020
AUDIENCE: Just a
question on invariants.

00:33:51.020 --> 00:33:52.760
So one of the data
structures that we've

00:33:52.760 --> 00:33:54.135
discussed in the
class previously

00:33:54.135 --> 00:33:55.750
to state like what
the invariants are,

00:33:55.750 --> 00:33:57.243
like the set AVL tree rule.

00:33:57.243 --> 00:33:57.910
JASON KU: Right.

00:33:57.910 --> 00:33:59.950
So if it's the
standard things, we

00:33:59.950 --> 00:34:04.240
were going to talk about what
the standard things are now.

00:34:04.240 --> 00:34:07.330
Then you don't need to
re-argue or --restate

00:34:07.330 --> 00:34:10.600
I mean, you can
basically say like,

00:34:10.600 --> 00:34:14.962
because the set and sequence
interfaces are defined

00:34:14.962 --> 00:34:16.420
that way, these
things are correct,

00:34:16.420 --> 00:34:22.000
like --almost you
can --basically

00:34:22.000 --> 00:34:25.719
you're trying to convince
us that why it's correct.

00:34:25.719 --> 00:34:28.600
If you're correctly using
a set or sequence data

00:34:28.600 --> 00:34:32.710
structure in these data
structures-type problems, then

00:34:32.710 --> 00:34:38.239
unless you're using it
in a way that is unusual,

00:34:38.239 --> 00:34:41.080
usually you can just
rely on the properties

00:34:41.080 --> 00:34:43.790
of the set and sequence data
structures that we gave you.

00:34:43.790 --> 00:34:48.070
I do want you to mention that
you thought about correctness.

00:34:48.070 --> 00:34:54.790
Like this data structure
is correct because.

00:34:54.790 --> 00:34:58.840
Just write a sentence
saying that and arguing

00:34:58.840 --> 00:35:01.480
that you're
basically maintaining

00:35:01.480 --> 00:35:03.460
the invariance of your
data structure kind

00:35:03.460 --> 00:35:04.960
of at the upper level.

00:35:04.960 --> 00:35:08.590
What kinds of things is
this data structure storing?

00:35:08.590 --> 00:35:14.320
What things about the
global data structure

00:35:14.320 --> 00:35:16.900
are we relying on to
make query operations?

00:35:16.900 --> 00:35:22.000
As long as you are convincing
that after a dynamic operation

00:35:22.000 --> 00:35:25.210
when modifying the data
structure that those invariant

00:35:25.210 --> 00:35:29.830
stay the --same that are
still satisfied, then

00:35:29.830 --> 00:35:32.770
that's really all
you need to say.

00:35:32.770 --> 00:35:36.160
These invariants are
satisfied because

00:35:36.160 --> 00:35:39.670
of the definitions of a set
and sequence data structure.

00:35:39.670 --> 00:35:42.550
A lot of times it doesn't
require a lot of thought

00:35:42.550 --> 00:35:45.310
for --the we're not
--asking the reason

00:35:45.310 --> 00:35:48.850
why we do reduction
problems is so you

00:35:48.850 --> 00:35:51.490
don't have to do a lot of
work to prove to us that it's

00:35:51.490 --> 00:35:52.480
correct.

00:35:52.480 --> 00:35:54.610
We have these really
nice black boxes.

00:35:54.610 --> 00:35:55.480
They are correct.

00:35:55.480 --> 00:35:57.970
We proved them to you
that they're correct,

00:35:57.970 --> 00:36:01.480
and so you don't have
to redo that work.

00:36:01.480 --> 00:36:07.420
So now we're going to go
through the core material I like

00:36:07.420 --> 00:36:09.610
to think about in this class.

00:36:09.610 --> 00:36:11.350
The first part of
this class, aside

00:36:11.350 --> 00:36:16.960
from these mathematical
tools that we developed

00:36:16.960 --> 00:36:18.460
at the beginning
of the course, it's

00:36:18.460 --> 00:36:21.670
mostly about solving problems
involving data structures.

00:36:21.670 --> 00:36:24.310
And we motivated this
problem of sorting

00:36:24.310 --> 00:36:27.070
by saying that a sorted array
is a data structure that's

00:36:27.070 --> 00:36:28.720
actually pretty useful.

00:36:28.720 --> 00:36:31.030
But how do we sort those things?

00:36:31.030 --> 00:36:35.350
Well, we showed you a
bunch of ways to do that.

00:36:35.350 --> 00:36:37.900
And this is that nice table.

00:36:37.900 --> 00:36:40.540
Lots of stuff.

00:36:40.540 --> 00:36:42.500
Why do we show you so
many sorting algorithms?

00:36:42.500 --> 00:36:45.694
Why don't we just give
you one algorithm?

00:36:45.694 --> 00:36:46.790
Hmm?

00:36:46.790 --> 00:36:47.290
Yeah?

00:36:47.290 --> 00:36:49.270
AUDIENCE: --run times.

00:36:49.270 --> 00:36:50.830
JASON KU: Different run times.

00:36:50.830 --> 00:36:51.850
AUDIENCE: Better for --different

00:36:51.850 --> 00:36:52.915
JASON KU: Better for
different scenarios.

00:36:52.915 --> 00:36:53.260
AUDIENCE: Yeah.

00:36:53.260 --> 00:36:55.107
They each have their
own individual points,

00:36:55.107 --> 00:36:55.940
then they do better.

00:36:55.940 --> 00:36:56.565
JASON KU: Yeah.

00:36:56.565 --> 00:37:00.820
You'll notice in
this table, there's

00:37:00.820 --> 00:37:05.260
not blue all the way across
for any of these things.

00:37:05.260 --> 00:37:07.720
So some of them are better
for different scenarios.

00:37:07.720 --> 00:37:12.250
And actually, these comments
list some special cases where

00:37:12.250 --> 00:37:14.200
these things might be better.

00:37:14.200 --> 00:37:17.920
In actuality, this
ultra-blue thing

00:37:17.920 --> 00:37:20.710
is saying like this
could be linear time.

00:37:20.710 --> 00:37:22.270
That's better.

00:37:22.270 --> 00:37:26.470
But in some cases this is worse
than all the other things.

00:37:26.470 --> 00:37:31.570
So be a little wary of
this blue color here.

00:37:31.570 --> 00:37:35.620
Generally we're trying to get
you further down in this chart

00:37:35.620 --> 00:37:37.900
if you can.

00:37:37.900 --> 00:37:45.100
And in general, like for
example, merge sort, AVL sort,

00:37:45.100 --> 00:37:48.580
these are really the same in
terms of asymptotic complexity

00:37:48.580 --> 00:37:51.460
and the way in which you
interact with these sorting

00:37:51.460 --> 00:37:53.110
rooms.

00:37:53.110 --> 00:37:54.910
But there are
special cases where

00:37:54.910 --> 00:37:58.900
you might use insertion sort
or selection --sort actually,

00:37:58.900 --> 00:38:01.450
I'm not sure about
insertion sort.

00:38:01.450 --> 00:38:07.750
You had in your
recitation two days ago--

00:38:07.750 --> 00:38:11.350
I think you guys
showed how to do

00:38:11.350 --> 00:38:14.890
if you had a k-proximate array
where things are not more

00:38:14.890 --> 00:38:16.450
than k away from each other.

00:38:16.450 --> 00:38:18.643
Insertion sort actually
runs in n times k,

00:38:18.643 --> 00:38:20.560
and so if k is small,
then that's really good,

00:38:20.560 --> 00:38:22.390
that's kind of like linear.

00:38:22.390 --> 00:38:24.640
But you can actually
do even better

00:38:24.640 --> 00:38:28.270
with a binary heap, which you
saw in recitation, hopefully,

00:38:28.270 --> 00:38:32.470
where you can get that down to
n log k by --keeping maintaining

00:38:32.470 --> 00:38:37.840
a heap as you go across and
finding the max that way.

00:38:37.840 --> 00:38:40.780
So insertion sort
maybe is not so great.

00:38:40.780 --> 00:38:43.840
But selection sort,
the name of the game

00:38:43.840 --> 00:38:50.290
there is that if
my reads are cheap

00:38:50.290 --> 00:38:54.120
but my writes are
expensive, selection sort

00:38:54.120 --> 00:38:56.670
it actually does pretty
well, because I only have--

00:38:56.670 --> 00:38:57.540
sorry.

00:38:57.540 --> 00:39:00.450
Reads are cheap and my
writes are expensive.

00:39:00.450 --> 00:39:02.675
Selection sort does a
linear number of swaps.

00:39:02.675 --> 00:39:04.800
It's looking down, finding
the max, swapping it in,

00:39:04.800 --> 00:39:06.240
and keep it going.

00:39:06.240 --> 00:39:08.460
And so in such cases,
that's actually

00:39:08.460 --> 00:39:11.770
better than any of these other
algorithms that we've got.

00:39:11.770 --> 00:39:12.270
Yeah?

00:39:12.270 --> 00:39:13.464
AUDIENCE: Those heap --sorts

00:39:13.464 --> 00:39:14.220
JASON KU: Mm-hmm.

00:39:14.220 --> 00:39:17.130
AUDIENCE: --time, worst
case are expected.

00:39:17.130 --> 00:39:19.350
JASON KU: This is worst case.

00:39:19.350 --> 00:39:21.090
So it's a little hard to--

00:39:21.090 --> 00:39:24.330
there was a lot of moving
parts to get to this bound

00:39:24.330 --> 00:39:27.360
in Tuesday's lecture.

00:39:27.360 --> 00:39:28.920
Basically what we
did, we showed you

00:39:28.920 --> 00:39:31.920
how to think of an
array as a heap--

00:39:31.920 --> 00:39:34.020
as a binary tree.

00:39:34.020 --> 00:39:35.220
Complete binary tree.

00:39:35.220 --> 00:39:36.720
It's not an AVL--

00:39:36.720 --> 00:39:40.380
I mean, it is an AVL
tree, but AVL trees

00:39:40.380 --> 00:39:43.190
are weaker than a complete tree.

00:39:43.190 --> 00:39:46.470
Height balance is a weaker
property than a complete.

00:39:46.470 --> 00:39:50.580
The reason why we use
complete is because it's

00:39:50.580 --> 00:39:54.270
unique for a number of nodes.

00:39:54.270 --> 00:39:57.963
That way, when I give you one
array with a fixed length,

00:39:57.963 --> 00:39:59.880
I know exactly what tree
you're talking about,

00:39:59.880 --> 00:40:03.547
because there's a
one-to-one mapping there.

00:40:03.547 --> 00:40:10.350
If there was some ambiguity on
what tree I was talking about,

00:40:10.350 --> 00:40:13.290
I --wouldn't heaps
just wouldn't work.

00:40:13.290 --> 00:40:17.130
So what heap sort does is
it has this correspondence

00:40:17.130 --> 00:40:20.010
between arrays and binary trees.

00:40:20.010 --> 00:40:22.470
And then what it
does is it provides

00:40:22.470 --> 00:40:26.940
these operations that kind of
only do operations at the end.

00:40:26.940 --> 00:40:30.330
And then the
in-place optimization

00:40:30.330 --> 00:40:32.970
is that, well, instead of
actually popping it or pushing

00:40:32.970 --> 00:40:34.920
it onto the back
of an array, I'm

00:40:34.920 --> 00:40:39.660
just going to think of a
subset of my array as a heap

00:40:39.660 --> 00:40:45.960
and then always kind of
pooping the max out to the end.

00:40:45.960 --> 00:40:49.020
Just leaving it behind
and thinking of my heap

00:40:49.020 --> 00:40:51.660
as a smaller subset.

00:40:51.660 --> 00:40:55.095
And that's how we --got
it didn't actually

00:40:55.095 --> 00:40:58.950
de-use any amortization.

00:40:58.950 --> 00:41:01.440
For the time bound, time
bounds you could actually

00:41:01.440 --> 00:41:04.950
do this with the amortized
basically dynamic array

00:41:04.950 --> 00:41:05.940
version of this.

00:41:05.940 --> 00:41:07.530
The time bound
doesn't rely on that.

00:41:07.530 --> 00:41:12.720
The in-place relies on keys
staying all within one array.

00:41:12.720 --> 00:41:14.250
Does that make sense?

00:41:14.250 --> 00:41:17.080
You're doing a bunch of
amortized operations,

00:41:17.080 --> 00:41:19.530
so that this actually does
achieve worst case n log n.

00:41:19.530 --> 00:41:20.280
Yeah?

00:41:20.280 --> 00:41:22.632
AUDIENCE: It seems that
the things we learned--

00:41:22.632 --> 00:41:23.340
JASON KU: Mm-hmm.

00:41:23.340 --> 00:41:24.550
AUDIENCE: --not like--

00:41:24.550 --> 00:41:25.440
JASON KU: Mm-hmm.

00:41:25.440 --> 00:41:26.815
AUDIENCE: They
tend to be better.

00:41:26.815 --> 00:41:29.594
So assume that most algorithms
than we want them to be--

00:41:29.594 --> 00:41:31.210
JASON KU: Uh huh.

00:41:31.210 --> 00:41:32.430
AUDIENCE: --faster.

00:41:32.430 --> 00:41:35.460
It seems like people will
not use as often, especially

00:41:35.460 --> 00:41:37.620
in these [INAUDIBLE]
insertion and selection.

00:41:37.620 --> 00:41:38.537
JASON KU: Right, yeah.

00:41:38.537 --> 00:41:40.920
So there are these special
cases where they're good,

00:41:40.920 --> 00:41:45.690
but, I mean, generally
these are better

00:41:45.690 --> 00:41:48.600
general data structures
for most situations

00:41:48.600 --> 00:41:49.710
that you come across.

00:41:49.710 --> 00:41:52.140
I mean, there are cases where
those other things are good,

00:41:52.140 --> 00:41:54.210
so you don't want to
completely ignore them,

00:41:54.210 --> 00:41:58.200
but generally, yeah, you're
trying to be lower bound

00:41:58.200 --> 00:41:58.800
in this chart.

00:41:58.800 --> 00:42:01.383
AUDIENCE: What I mean is that
if I don't have any --bound like

00:42:01.383 --> 00:42:03.780
I'm using them all except
for selection sort--

00:42:03.780 --> 00:42:05.910
JASON KU: So there's
too many things on here

00:42:05.910 --> 00:42:09.030
for us to test all
of them on an exam.

00:42:09.030 --> 00:42:12.300
So don't be afraid if not
everything is covered.

00:42:12.300 --> 00:42:15.360
Worry when things are
covered 18 times on the exam,

00:42:15.360 --> 00:42:17.020
that's not good.

00:42:17.020 --> 00:42:17.520
OK.

00:42:17.520 --> 00:42:20.970
So for radix sort,
there are situations

00:42:20.970 --> 00:42:23.430
where you get linear time.

00:42:23.430 --> 00:42:25.380
It's when you're
polynomial-bounded.

00:42:25.380 --> 00:42:28.770
Are there times
when I want to use

00:42:28.770 --> 00:42:31.680
radix sort when I'm
not polynomial-bounded

00:42:31.680 --> 00:42:32.565
in my integers?

00:42:37.708 --> 00:42:39.750
AUDIENCE: Well, if you're
not polynomial-bounded,

00:42:39.750 --> 00:42:41.790
then that could take
a really long time.

00:42:41.790 --> 00:42:43.210
JASON KU: Sure, yeah.

00:42:43.210 --> 00:42:49.990
But like where's --the this
will be worse than n log n when?

00:42:52.960 --> 00:42:55.270
It's definitely
better than n log n

00:42:55.270 --> 00:42:58.330
when u is polynomially bounded.

00:42:58.330 --> 00:43:00.540
Because it's linear.

00:43:00.540 --> 00:43:01.390
Yeah?

00:43:01.390 --> 00:43:03.520
AUDIENCE: [INAUDIBLE]
n to the n.

00:43:03.520 --> 00:43:05.370
JASON KU: n to the n.

00:43:05.370 --> 00:43:05.870
OK.

00:43:05.870 --> 00:43:09.490
So if I put n to
the n in here, I

00:43:09.490 --> 00:43:12.310
get an n factor
that comes out here.

00:43:12.310 --> 00:43:15.080
That gives me a
quadratic running time,

00:43:15.080 --> 00:43:17.710
which is not great.

00:43:17.710 --> 00:43:22.750
But when will this be
better then n log n?

00:43:22.750 --> 00:43:24.010
Yeah?

00:43:24.010 --> 00:43:27.757
AUDIENCE: n to the c,
because it's less n to the c.

00:43:27.757 --> 00:43:29.590
JASON KU: n to the c--
so that'll definitely

00:43:29.590 --> 00:43:31.025
give us linear time.

00:43:31.025 --> 00:43:32.150
That's what this is saying.

00:43:32.150 --> 00:43:35.710
But we can actually
do better than n log n

00:43:35.710 --> 00:43:43.150
if this u is n to the c
times log n for some c.

00:43:43.150 --> 00:43:48.610
If --it's like if it's
n to the c log log n,

00:43:48.610 --> 00:43:50.070
that's smaller than log n.

00:43:50.070 --> 00:43:52.360
So that's a better algorithm.

00:43:52.360 --> 00:43:53.590
That's a faster algorithm.

00:43:53.590 --> 00:43:58.600
Do you guys see why we
wrote these things this way?

00:43:58.600 --> 00:44:02.140
It's so that we give
you a more --precise

00:44:02.140 --> 00:44:05.680
this is more important for you
understand what u means here

00:44:05.680 --> 00:44:09.040
than that this thing
sometimes runs in linear time.

00:44:09.040 --> 00:44:12.740
We want to know when
it runs in linear time.

00:44:12.740 --> 00:44:13.900
Does that makes sense?

00:44:13.900 --> 00:44:16.755
Or when it runs faster
than merge sort.

00:44:16.755 --> 00:44:19.850
Does that makes sense?

00:44:19.850 --> 00:44:20.350
OK.

00:44:20.350 --> 00:44:21.505
So that's sorting.

00:44:24.160 --> 00:44:26.320
We have sequence-type
data structures.

00:44:26.320 --> 00:44:28.870
We have linked lists,
we have dynamic arrays,

00:44:28.870 --> 00:44:30.070
we have sequence AVLs.

00:44:30.070 --> 00:44:32.310
Sequence AVLs are great.

00:44:32.310 --> 00:44:34.030
I don't know why
no one teaches it.

00:44:34.030 --> 00:44:35.290
They're great.

00:44:35.290 --> 00:44:38.230
They don't teach it probably
because they're actually not

00:44:38.230 --> 00:44:40.930
that useful.

00:44:40.930 --> 00:44:45.760
You don't actually use the
insert in the middle a lot

00:44:45.760 --> 00:44:46.660
in coding.

00:44:46.660 --> 00:44:50.140
So it's-- you can usually
get around with like shifting

00:44:50.140 --> 00:44:53.045
something to the end and doing
dynamic operations there,

00:44:53.045 --> 00:44:55.420
and that's a lot of the games
that you try to play so you

00:44:55.420 --> 00:44:57.490
don't have to make your
own data structures,

00:44:57.490 --> 00:45:02.230
and you can just use the
Python list that's in your--

00:45:02.230 --> 00:45:04.120
like native to your thing.

00:45:04.120 --> 00:45:06.190
But it has a
theoretical interest

00:45:06.190 --> 00:45:08.530
because it gets these
kind of balanced bounds

00:45:08.530 --> 00:45:12.970
if you need to insert in
the middle of this sequence.

00:45:12.970 --> 00:45:18.400
Now some of you look at me
and had a question before that

00:45:18.400 --> 00:45:24.490
was like, but Jason,
how does linked list

00:45:24.490 --> 00:45:27.760
operations on the
end of a linked list,

00:45:27.760 --> 00:45:30.220
why does that take linear time?

00:45:30.220 --> 00:45:34.030
It's because in lecture,
we presented you with what?

00:45:36.890 --> 00:45:39.620
A singly-linked list.

00:45:39.620 --> 00:45:42.412
It just had pointers
to the next thing.

00:45:42.412 --> 00:45:44.870
And if I only have pointers to
the next thing and a pointer

00:45:44.870 --> 00:45:49.130
to the head, for
me to find the end,

00:45:49.130 --> 00:45:52.430
I need to walk all
the way down the list.

00:45:52.430 --> 00:45:57.500
Now let's say I keep my pointer
to the tail, then finding that

00:45:57.500 --> 00:46:01.340
and n1 is fine, but removing
it still takes linear time,

00:46:01.340 --> 00:46:04.610
because I don't know
what came before me.

00:46:04.610 --> 00:46:08.420
And so that's why in
p-set whatever, 1, 2,

00:46:08.420 --> 00:46:11.810
I don't remember, you
stored a pointer back

00:46:11.810 --> 00:46:14.190
to your previous one that
gave you doubly-linked lists.

00:46:14.190 --> 00:46:15.110
Yay, right?

00:46:15.110 --> 00:46:19.130
So actually, expanding
this table out,

00:46:19.130 --> 00:46:22.400
you can reference a
doubly-linked list here and get

00:46:22.400 --> 00:46:24.940
this one as constant time.

00:46:24.940 --> 00:46:26.550
Does that make sense?

00:46:26.550 --> 00:46:30.860
And this one's
still linear time.

00:46:30.860 --> 00:46:32.000
OK.

00:46:32.000 --> 00:46:34.200
But this one's
still linear time.

00:46:34.200 --> 00:46:36.650
We actually also
showed you how to do

00:46:36.650 --> 00:46:38.540
this in constant amortized.

00:46:38.540 --> 00:46:40.100
Do you guys remember that?

00:46:40.100 --> 00:46:45.080
That was in problem
session 2 or 1?

00:46:45.080 --> 00:46:46.670
I don't remember.

00:46:46.670 --> 00:46:50.360
It was whatever we talking
about amortized stuff.

00:46:50.360 --> 00:46:52.100
We --got we got
actually both of these

00:46:52.100 --> 00:46:58.160
to one amortized using the
concepts of the dynamic array.

00:46:58.160 --> 00:47:00.470
And then we actually
did it one more time

00:47:00.470 --> 00:47:02.390
where we got a good
doubly-ended thing.

00:47:02.390 --> 00:47:04.970
What was that?

00:47:04.970 --> 00:47:06.380
Does anyone remember?

00:47:06.380 --> 00:47:08.430
We went to problem session 3.

00:47:08.430 --> 00:47:08.930
Yeah?

00:47:08.930 --> 00:47:09.972
AUDIENCE: Oh.

00:47:09.972 --> 00:47:11.180
I'm probably wrong, this is--

00:47:11.180 --> 00:47:11.420
JASON KU: OK.

00:47:11.420 --> 00:47:12.670
AUDIENCE: --problem session 3.

00:47:12.670 --> 00:47:14.510
But like q dq type stuff?

00:47:14.510 --> 00:47:17.330
JASON KU: So q dq,
those are talking

00:47:17.330 --> 00:47:20.210
about doubly-ended things.

00:47:20.210 --> 00:47:23.750
Those are implemented in a
certain way, which is actually

00:47:23.750 --> 00:47:24.680
one of these things.

00:47:24.680 --> 00:47:28.880
It's actually, I think,
this one in Python.

00:47:28.880 --> 00:47:32.330
But there's --a we used a
different data structure

00:47:32.330 --> 00:47:35.810
to get something that
had really good at.

00:47:35.810 --> 00:47:38.960
It had really good
pop and append

00:47:38.960 --> 00:47:41.820
and first and last
dynamic operations.

00:47:41.820 --> 00:47:44.240
Do you --guys anyone
remember from session 3?

00:47:47.635 --> 00:47:49.090
AUDIENCE: [INAUDIBLE]

00:47:49.090 --> 00:47:52.000
AUDIENCE: Isn't it
dynamic array [INAUDIBLE]??

00:47:52.000 --> 00:47:54.790
JASON KU: That's what this was.

00:47:54.790 --> 00:47:55.480
OK.

00:47:55.480 --> 00:47:57.700
We got one that had
expected bounds.

00:47:57.700 --> 00:48:00.640
Does that help?

00:48:00.640 --> 00:48:01.270
What?

00:48:01.270 --> 00:48:04.120
I heard someone say it.

00:48:04.120 --> 00:48:04.770
Hash table.

00:48:04.770 --> 00:48:05.270
Yeah.

00:48:05.270 --> 00:48:09.100
So basically what you
did, instead --of this

00:48:09.100 --> 00:48:10.150
is a sequence thing.

00:48:10.150 --> 00:48:13.300
These things don't have keys.

00:48:13.300 --> 00:48:16.270
But I could identify
with each item

00:48:16.270 --> 00:48:20.727
as I stick it in, a key
representing its index.

00:48:20.727 --> 00:48:22.310
And I could use a
hash table that way.

00:48:22.310 --> 00:48:26.890
Now there was some difficulty
if I removed the first thing.

00:48:30.130 --> 00:48:34.510
Because actually, how
--those are all of my indices

00:48:34.510 --> 00:48:35.710
have now changed.

00:48:35.710 --> 00:48:39.280
But if I just store what the
smallest index in my thing is,

00:48:39.280 --> 00:48:42.160
then I'm golden,
because I can compute

00:48:42.160 --> 00:48:45.890
what that index should be I
change things at the front.

00:48:45.890 --> 00:48:46.390
OK.

00:48:46.390 --> 00:48:48.730
So there's actually
three different ways

00:48:48.730 --> 00:48:51.190
we showed you of getting
constant time at the front

00:48:51.190 --> 00:48:53.570
and the back of this thing.

00:48:53.570 --> 00:48:57.190
So actually, you can think
of that as standard material

00:48:57.190 --> 00:48:59.050
that you can reduce to.

00:48:59.050 --> 00:49:00.790
That's the one
exception of the things

00:49:00.790 --> 00:49:02.720
that I'm not showing
on this chart,

00:49:02.720 --> 00:49:05.290
but is a bonus if you're
watching this problem session.

00:49:05.290 --> 00:49:05.950
Yeah?

00:49:05.950 --> 00:49:08.890
AUDIENCE: So isn't a hash table
a set data structure, though?

00:49:08.890 --> 00:49:09.850
JASON KU: It is.

00:49:09.850 --> 00:49:12.800
But we used it to implement
a sequenced data structure.

00:49:12.800 --> 00:49:15.730
So I will refer you to
that problem session

00:49:15.730 --> 00:49:18.550
if you want to
learn more about it.

00:49:18.550 --> 00:49:21.090
So, any questions on
sequenced data structures?

00:49:21.090 --> 00:49:21.743
Yeah?

00:49:21.743 --> 00:49:22.630
AUDIENCE: I--

00:49:22.630 --> 00:49:23.890
JASON KU: Yeah, uh huh.

00:49:23.890 --> 00:49:25.420
AUDIENCE: Should
we be-- or-- yeah.

00:49:25.420 --> 00:49:28.930
Should we be able to look prove
the tables that we're given?

00:49:28.930 --> 00:49:32.310
JASON KU: So I would hope--

00:49:32.310 --> 00:49:36.550
hope-- that if I gave you
a blank table, that you

00:49:36.550 --> 00:49:37.960
would be able to fill it out.

00:49:37.960 --> 00:49:40.300
That's how well I
want you to know how

00:49:40.300 --> 00:49:43.090
these things are implemented.

00:49:43.090 --> 00:49:46.120
We're not going to
have that on the exam.

00:49:46.120 --> 00:49:47.650
That's a boring
kind of question.

00:49:47.650 --> 00:49:49.480
AUDIENCE: But it is
important to know?

00:49:49.480 --> 00:49:50.105
JASON KU: Yeah.

00:49:50.105 --> 00:49:53.350
I would-- it's good
for you to think,

00:49:53.350 --> 00:49:56.110
like, oh, if I'm going
to use an AVL tree,

00:49:56.110 --> 00:49:58.360
operations are generally
going to be log n.

00:49:58.360 --> 00:50:00.340
That's a really useful
thing-- or, if I'm

00:50:00.340 --> 00:50:03.850
going to use a hash table,
dictionary-type operations,

00:50:03.850 --> 00:50:07.030
finding, inserting, and
deleting, those are fast.

00:50:07.030 --> 00:50:11.620
Doing order-type operations
on hash tables is bad,

00:50:11.620 --> 00:50:14.110
that's hard to do because
I have to basically look

00:50:14.110 --> 00:50:16.150
through all my things.

00:50:16.150 --> 00:50:19.870
Knowing that dynamic operations
on a sorted array is bad.

00:50:19.870 --> 00:50:26.680
Or knowing that-- you have to
think about here what we mean

00:50:26.680 --> 00:50:29.720
when we say linked list and
dynamic array in this table,

00:50:29.720 --> 00:50:30.220
because--

00:50:30.220 --> 00:50:31.360
AUDIENCE: Singly-linked.

00:50:31.360 --> 00:50:32.360
JASON KU: Yeah, exactly.

00:50:32.360 --> 00:50:34.060
We are implying
singly-linked here

00:50:34.060 --> 00:50:36.340
because that's what we
presented to you in lecture.

00:50:36.340 --> 00:50:37.930
And so those are
the standard things

00:50:37.930 --> 00:50:39.370
that we want you to reduce to.

00:50:39.370 --> 00:50:39.520
Yeah?

00:50:39.520 --> 00:50:41.437
AUDIENCE: --three modified
standard things are

00:50:41.437 --> 00:50:43.330
the doubly-linked lists,
the doubly-ended--

00:50:43.330 --> 00:50:43.955
JASON KU: Yeah.

00:50:43.955 --> 00:50:46.236
Basically you can
assume that you have--

00:50:46.236 --> 00:50:49.390
it's this one that you
probably want to use,

00:50:49.390 --> 00:50:53.710
because you get
constant indexing.

00:50:53.710 --> 00:50:57.580
And then pretty
good on both ends.

00:50:57.580 --> 00:51:00.490
But if you need
a double-ended Q,

00:51:00.490 --> 00:51:04.720
you can also reduce it to having
two dynamic arrays back-to-back

00:51:04.720 --> 00:51:06.440
when going this way,
when going this way.

00:51:06.440 --> 00:51:07.607
And so there's lots of--

00:51:07.607 --> 00:51:09.940
we're not going to give that
to you as a standard method

00:51:09.940 --> 00:51:12.460
because there's literally like
four methods we showed you

00:51:12.460 --> 00:51:13.750
how to do.

00:51:13.750 --> 00:51:14.930
So you choose one.

00:51:14.930 --> 00:51:15.430
OK.

00:51:15.430 --> 00:51:16.030
Yeah?

00:51:16.030 --> 00:51:18.910
AUDIENCE: In the interest
of saving time on the exam,

00:51:18.910 --> 00:51:21.860
if we want to say, like, we do
this thing with the sequence

00:51:21.860 --> 00:51:23.978
AVL and it takes log n time.

00:51:23.978 --> 00:51:26.020
Do we have to say the
sentence like, because this

00:51:26.020 --> 00:51:28.228
is sequence AVL, it takes
a longer time because this?

00:51:28.228 --> 00:51:30.880
Or can we just like say like,
for the table that we know?

00:51:30.880 --> 00:51:33.106
JASON KU: Yeah, no.

00:51:33.106 --> 00:51:35.560
If you told me that you're
storing things in a sequence

00:51:35.560 --> 00:51:38.260
AVL and you just say--

00:51:38.260 --> 00:51:40.900
you basically say what
you do to it, and you say,

00:51:40.900 --> 00:51:42.580
which takes blah,
blah, blah time,

00:51:42.580 --> 00:51:45.760
you don't need to say
because it's a sequence AVL,

00:51:45.760 --> 00:51:47.770
because you already told
us it's a sequence AVL.

00:51:47.770 --> 00:51:50.140
I believe that you
probably wrote the chart

00:51:50.140 --> 00:51:52.910
on your cheat sheet
and you looked it up.

00:51:52.910 --> 00:51:54.550
All right.

00:51:54.550 --> 00:51:55.870
Any other questions on this?

00:51:55.870 --> 00:51:56.470
No.

00:51:56.470 --> 00:51:57.130
Yeah?

00:51:57.130 --> 00:51:59.680
AUDIENCE: Just make sure,
the doubly-linked lists

00:51:59.680 --> 00:52:02.968
will make the insert
on [INAUDIBLE]..

00:52:02.968 --> 00:52:04.820
Is that the only change?

00:52:04.820 --> 00:52:05.735
JASON KU: Yes.

00:52:05.735 --> 00:52:10.550
That doubly-linked list
gives this guy constant time.

00:52:10.550 --> 00:52:13.010
And actually, there are
two operations here,

00:52:13.010 --> 00:52:14.270
insert, delete, and--

00:52:14.270 --> 00:52:17.300
I guess there's a
find here as well.

00:52:17.300 --> 00:52:19.100
If I just store
the tail pointer,

00:52:19.100 --> 00:52:22.130
that gets defined
to constant time.

00:52:22.130 --> 00:52:25.190
but it doesn't get the
dynamic ones to constant time.

00:52:25.190 --> 00:52:27.800
I need to store the previous
pointers as well at each node.

00:52:27.800 --> 00:52:29.220
Does that make sense?

00:52:29.220 --> 00:52:31.880
OK.

00:52:31.880 --> 00:52:36.120
Lastly-- or I guess second to
lastly, set data structures.

00:52:36.120 --> 00:52:38.030
There are a little
bit more of these.

00:52:38.030 --> 00:52:39.170
Not so many more.

00:52:42.150 --> 00:52:44.510
But yeah.

00:52:44.510 --> 00:52:47.600
We had a sorted array, gets
good find, but is not dynamic.

00:52:51.320 --> 00:52:55.010
We set AVL tree which
does pretty good

00:52:55.010 --> 00:52:57.380
find and is dynamic.

00:52:57.380 --> 00:53:02.878
Again, you get this n
log n overhead to build,

00:53:02.878 --> 00:53:05.420
because essentially what you're
doing with both of those data

00:53:05.420 --> 00:53:07.260
structures is to sort.

00:53:07.260 --> 00:53:12.080
But if I'm looking
on a theory question,

00:53:12.080 --> 00:53:13.520
like I'm not asking
you something

00:53:13.520 --> 00:53:16.370
specifically about a
sorted array, if you

00:53:16.370 --> 00:53:19.880
have a choice between this
data structure and this data

00:53:19.880 --> 00:53:21.440
structure, which
one do you choose?

00:53:25.620 --> 00:53:27.620
Well, I don't quite
know, because it's

00:53:27.620 --> 00:53:32.510
almost like this one's better at
everything except for this one.

00:53:32.510 --> 00:53:35.245
But can anyone tell me how to
make this one constant time

00:53:35.245 --> 00:53:37.400
as well?

00:53:37.400 --> 00:53:38.420
Augmentation.

00:53:38.420 --> 00:53:43.040
I could just store in my
subtrees the max or min.

00:53:43.040 --> 00:53:45.790
And I can make this one
strictly better than this one.

00:53:45.790 --> 00:53:47.807
So in theory
problem, you probably

00:53:47.807 --> 00:53:48.890
just want to use this one.

00:53:51.410 --> 00:53:54.320
Here, hash tables,
direct access arrays,

00:53:54.320 --> 00:53:56.600
even better for
these operations.

00:53:56.600 --> 00:53:57.830
That's great.

00:53:57.830 --> 00:53:59.750
But they suck at these.

00:53:59.750 --> 00:54:02.720
So if you need these,
don't use these.

00:54:02.720 --> 00:54:05.480
And in actual coding,
especially if you're

00:54:05.480 --> 00:54:08.360
coding in a language that's not
Python, something that doesn't

00:54:08.360 --> 00:54:10.070
automatically give
you a hash table,

00:54:10.070 --> 00:54:14.450
if you're in C in a
microcontroller lab at MIT

00:54:14.450 --> 00:54:18.170
here, you're taking
6115 or whatever,

00:54:18.170 --> 00:54:21.290
and you're doing assembly,
usually what you're doing

00:54:21.290 --> 00:54:23.600
is a direct access stuff.

00:54:23.600 --> 00:54:26.180
Because that's
giving you the jumps

00:54:26.180 --> 00:54:27.740
that you need in
machine language

00:54:27.740 --> 00:54:30.510
to actually go and access
this in constant time.

00:54:30.510 --> 00:54:32.960
That's generally if you
have control over the keys

00:54:32.960 --> 00:54:33.950
that you're putting--

00:54:33.950 --> 00:54:35.870
that you are putting
in your data structure,

00:54:35.870 --> 00:54:38.515
you don't want this
overhead of running

00:54:38.515 --> 00:54:39.890
your keys through
a hash function

00:54:39.890 --> 00:54:40.940
to look these things up.

00:54:40.940 --> 00:54:44.990
You just store the
things in an array.

00:54:44.990 --> 00:54:47.960
You use the hash
table when you don't

00:54:47.960 --> 00:54:49.880
have control over
the keys or your keys

00:54:49.880 --> 00:54:52.767
are like strings or something.

00:54:52.767 --> 00:54:54.350
So that's when you
use the hash table.

00:54:54.350 --> 00:54:58.215
Now for our purposes,
usually a hash table

00:54:58.215 --> 00:54:59.840
is just as good unless
we're asking you

00:54:59.840 --> 00:55:02.690
for worst case bounds.

00:55:02.690 --> 00:55:05.738
And we're going to do this
when we talk about the data

00:55:05.738 --> 00:55:06.530
structures problem.

00:55:06.530 --> 00:55:12.050
If we give you a situation where
we don't care if you achieve

00:55:12.050 --> 00:55:13.760
worst case are
expected or amortized

00:55:13.760 --> 00:55:15.177
or any of these
things, we'll just

00:55:15.177 --> 00:55:19.760
say, make sure you state
which one you achieve.

00:55:19.760 --> 00:55:22.310
And as long as you analyzed
it correctly with respect

00:55:22.310 --> 00:55:25.430
to your data structures,
then you're fine.

00:55:25.430 --> 00:55:27.930
But if we say you better
do worst case here,

00:55:27.930 --> 00:55:29.930
I'm going to slap you around.

00:55:29.930 --> 00:55:32.930
Then please get those bounds.

00:55:32.930 --> 00:55:36.710
Don't use the hash
table in that case.

00:55:36.710 --> 00:55:38.330
That makes sense?

00:55:38.330 --> 00:55:40.640
OK.

00:55:40.640 --> 00:55:43.872
Lastly, we've got priority
queues which we talked about.

00:55:43.872 --> 00:55:45.830
I'm not going to go
through this one very much.

00:55:45.830 --> 00:55:49.760
It's basically just
adding this to the thing.

00:55:49.760 --> 00:55:52.400
But in actuality, you can
get all of these bounds

00:55:52.400 --> 00:55:55.190
with a set AVL--

00:55:55.190 --> 00:55:59.153
I mean a sequence AVL tree
with max or min augmentation,

00:55:59.153 --> 00:56:01.820
which isn't on this list because
we didn't really talk about it,

00:56:01.820 --> 00:56:04.490
but hopefully you can--

00:56:04.490 --> 00:56:07.850
if you need these bounds
without the amortization,

00:56:07.850 --> 00:56:10.980
then you could achieve them.

00:56:10.980 --> 00:56:11.480
All right.

00:56:11.480 --> 00:56:13.700
So that's basically
everything that we've

00:56:13.700 --> 00:56:15.913
talked about in the class.

00:56:15.913 --> 00:56:18.330
We're going to spend the rest
of the time working a couple

00:56:18.330 --> 00:56:19.460
of data structures problem.

00:56:19.460 --> 00:56:23.030
I'm not-- there's a number of
different types of questions

00:56:23.030 --> 00:56:27.980
you'll actually
see on the quiz--

00:56:27.980 --> 00:56:30.530
the practice quiz that we
gave you from last term.

00:56:30.530 --> 00:56:33.500
There are some what I call
mechanical-type questions up

00:56:33.500 --> 00:56:35.300
at the front.

00:56:35.300 --> 00:56:37.940
Then usually some
reduction-type problems

00:56:37.940 --> 00:56:40.490
where you're reducing to
using some sorting algorithms

00:56:40.490 --> 00:56:41.720
or some data structures.

00:56:41.720 --> 00:56:43.850
And then usually
the latter ones are

00:56:43.850 --> 00:56:46.790
ones where you have to do some
kind of something additional,

00:56:46.790 --> 00:56:50.070
like some augmentation or
some divide and conquer

00:56:50.070 --> 00:56:51.920
or something like that.

00:56:51.920 --> 00:56:53.480
OK.

00:56:53.480 --> 00:56:55.460
So we're going to
go ahead and spend

00:56:55.460 --> 00:56:59.390
the rest of the time working
a couple of these problems.

00:56:59.390 --> 00:57:04.520
These were from spring
of 2019 on the exam.

00:57:04.520 --> 00:57:09.260
And actually, one of the
TAs who's TAing for us

00:57:09.260 --> 00:57:12.020
now was also TAing
for us in spring 2019.

00:57:12.020 --> 00:57:13.970
Was grading problem
number 2 here,

00:57:13.970 --> 00:57:16.370
the rainy research
problem, and just hated me,

00:57:16.370 --> 00:57:18.590
because no one did it right.

00:57:18.590 --> 00:57:19.520
All right.

00:57:19.520 --> 00:57:23.120
So, let's try to
solve these problems.

00:57:23.120 --> 00:57:28.730
So problem 1 is
about restaurant--

00:57:28.730 --> 00:57:31.880
restaurant, yes, OK.

00:57:31.880 --> 00:57:32.748
All right.

00:57:32.748 --> 00:57:34.040
So basically, what's happening?

00:57:34.040 --> 00:57:38.150
A popular restaurant,
Criminal Seafood.

00:57:38.150 --> 00:57:39.830
What's the reference?

00:57:39.830 --> 00:57:40.580
Legal Seafood.

00:57:40.580 --> 00:57:41.750
Yes, opposite.

00:57:41.750 --> 00:57:44.360
Does not take reservations,
but maintains a wait list

00:57:44.360 --> 00:57:47.010
where customers who have
been on the wait list longer

00:57:47.010 --> 00:57:48.590
are seated earlier.

00:57:48.590 --> 00:57:50.830
Sometimes customers decide
to eat somewhere else,

00:57:50.830 --> 00:57:53.030
so restaurant must remove
them from the wait list.

00:57:53.030 --> 00:57:54.620
OK.

00:57:54.620 --> 00:57:57.710
Assume that a customer
has a different name.

00:57:57.710 --> 00:58:00.320
No two customers are
added to the wait list

00:58:00.320 --> 00:58:01.880
at the exact same time.

00:58:01.880 --> 00:58:04.550
So there's a kind of an
ordering at which people are

00:58:04.550 --> 00:58:06.060
being added to this wait list.

00:58:06.060 --> 00:58:07.430
Does that makes sense?

00:58:07.430 --> 00:58:09.770
Design a database to help
Criminals Seafood maintain

00:58:09.770 --> 00:58:11.510
its wait lists
supporting the following

00:58:11.510 --> 00:58:13.460
operations, each
in constant time.

00:58:13.460 --> 00:58:18.590
OK, so here, we've refactored
the running time up to the top.

00:58:18.590 --> 00:58:20.090
And it's a-- oh, sorry.

00:58:20.090 --> 00:58:21.692
I added the build here.

00:58:21.692 --> 00:58:23.150
I guess that's
still constant time.

00:58:23.150 --> 00:58:23.840
That's fine, OK.

00:58:23.840 --> 00:58:24.680
AUDIENCE: I have time d--

00:58:24.680 --> 00:58:25.305
JASON KU: Yeah.

00:58:25.305 --> 00:58:29.450
State whether each running
time operation is worst case,

00:58:29.450 --> 00:58:30.480
amortized, expected.

00:58:30.480 --> 00:58:33.260
So, when you see that
statement, you're saying, OK,

00:58:33.260 --> 00:58:37.580
I'm allowed to use a
hash table if I want to.

00:58:37.580 --> 00:58:39.860
I just have to make
sure if I use one,

00:58:39.860 --> 00:58:44.900
I label my operations expected
and amortized when they occur.

00:58:44.900 --> 00:58:46.580
Which operations are expected?

00:58:46.580 --> 00:58:47.840
Basically all of them.

00:58:47.840 --> 00:58:49.490
Which operations are amortized?

00:58:49.490 --> 00:58:52.790
The ones that changed what's
in the data structure, insert,

00:58:52.790 --> 00:58:54.260
delete.

00:58:54.260 --> 00:58:54.890
OK.

00:58:54.890 --> 00:58:58.370
So we've got some operations,
building an empty thing.

00:58:58.370 --> 00:59:02.330
Adding a name-- so this name is
x to the back of the wait list.

00:59:02.330 --> 00:59:03.530
What do I know about x?

00:59:03.530 --> 00:59:06.350
What do I know about the
names per our assumptions

00:59:06.350 --> 00:59:06.980
in this class?

00:59:06.980 --> 00:59:08.690
AUDIENCE: They're unique,
so they can be a key.

00:59:08.690 --> 00:59:10.648
JASON KU: They're unique,
so they can be a key.

00:59:10.648 --> 00:59:14.540
And they fit in a
constant number of words

00:59:14.540 --> 00:59:15.780
by our assumption.

00:59:15.780 --> 00:59:17.920
So I can compare
two of them in--

00:59:17.920 --> 00:59:19.700
or I can hash one
in constant time.

00:59:19.700 --> 00:59:21.950
That's kind of the assumption
we make on these inputs,

00:59:21.950 --> 00:59:23.150
they're strings.

00:59:23.150 --> 00:59:26.060
And I didn't assign you
a bound on their length,

00:59:26.060 --> 00:59:29.690
so it's probably not something
you need to worry about.

00:59:29.690 --> 00:59:33.110
OK remove a name.

00:59:33.110 --> 00:59:35.720
So already I'm
feeling like, I need

00:59:35.720 --> 00:59:39.230
to be able to find
things by their name.

00:59:39.230 --> 00:59:40.400
OK.

00:59:40.400 --> 00:59:43.220
And then seat the
next person in line.

00:59:43.220 --> 00:59:44.610
Does that makes sense?

00:59:44.610 --> 00:59:47.360
So what kinds of things do
I need to maintain here?

00:59:47.360 --> 00:59:49.850
I have people.

00:59:49.850 --> 00:59:53.090
They have names and they
have kind of places,

00:59:53.090 --> 00:59:55.340
the time that they came in.

00:59:55.340 --> 00:59:56.555
But am I given the times?

00:59:59.880 --> 01:00:01.020
No.

01:00:01.020 --> 01:00:02.820
I'm not given times anywhere.

01:00:02.820 --> 01:00:05.710
It's not on the inputs
to my operations.

01:00:05.710 --> 01:00:08.560
So it's not like I'm going
to be able to key on time.

01:00:08.560 --> 01:00:09.270
That makes sense?

01:00:09.270 --> 01:00:12.000
What's the important
part about the times?

01:00:12.000 --> 01:00:12.547
The order.

01:00:12.547 --> 01:00:13.880
AUDIENCE: And you're given that.

01:00:13.880 --> 01:00:14.505
JASON KU: Yeah.

01:00:14.505 --> 01:00:17.670
Basically whenever--
I'm basically

01:00:17.670 --> 01:00:20.160
trying to maintain a
sequence on these guys.

01:00:20.160 --> 01:00:23.797
There's a front one and a back
one and people in the middle.

01:00:23.797 --> 01:00:25.880
And I want to make sure
that order stays the same,

01:00:25.880 --> 01:00:27.880
or else people are going
to getting angry at me,

01:00:27.880 --> 01:00:31.390
because ah, they came here
after me and I got a--

01:00:31.390 --> 01:00:32.970
yeah.

01:00:32.970 --> 01:00:34.720
You've been in that situation.

01:00:34.720 --> 01:00:35.280
OK.

01:00:35.280 --> 01:00:38.220
So, we're trying to maintain
some kind of sequence,

01:00:38.220 --> 01:00:41.550
an extrinsic order
on these things.

01:00:41.550 --> 01:00:44.250
But we're also needing to
be able to look up people

01:00:44.250 --> 01:00:47.640
by their name because I want to
be able to change this thing.

01:00:47.640 --> 01:00:51.000
Does this maybe sound familiar
to some other problem we had

01:00:51.000 --> 01:00:54.990
on this term's problem sets?

01:00:54.990 --> 01:00:58.600
Yeah, I think there
was a problem where--

01:00:58.600 --> 01:00:59.640
AUDIENCE: The chat.

01:00:59.640 --> 01:01:00.900
JASON KU: The chat.

01:01:00.900 --> 01:01:03.090
You had to store a sequence.

01:01:03.090 --> 01:01:06.120
But you also had this dictionary
that you had to look things up.

01:01:06.120 --> 01:01:11.670
Now the nice thing
about that situation

01:01:11.670 --> 01:01:14.940
is that the things that
you needed to look up on

01:01:14.940 --> 01:01:16.530
was static.

01:01:16.530 --> 01:01:18.870
And so what could I
use for my dictionary,

01:01:18.870 --> 01:01:22.320
my sets data structure for that?

01:01:22.320 --> 01:01:25.290
Anyone remember?

01:01:25.290 --> 01:01:26.970
You could just use
a sorted array.

01:01:26.970 --> 01:01:28.770
Because it's
static, these things

01:01:28.770 --> 01:01:32.010
aren't updating all the time,
and so it was fine for me

01:01:32.010 --> 01:01:34.290
to just use a static array.

01:01:34.290 --> 01:01:39.450
Here-- and we gave
you lookup times that

01:01:39.450 --> 01:01:41.610
were worst case logarithmic.

01:01:41.610 --> 01:01:43.200
Here, I'm asking
for constant time.

01:01:45.600 --> 01:01:47.100
Sorted array is not
going to cut it,

01:01:47.100 --> 01:01:49.638
set AVL's not going to cut
it, so what am I going to use?

01:01:49.638 --> 01:01:50.430
AUDIENCE: Dynamic--

01:01:50.430 --> 01:01:52.650
JASON KU: A dynamic
array or a hash table.

01:01:52.650 --> 01:01:55.980
Now dynamic array might not be
great because I don't actually

01:01:55.980 --> 01:01:58.590
have a numeric bound on
how big these keys are,

01:01:58.590 --> 01:02:01.260
I just know that
they fit in words.

01:02:01.260 --> 01:02:03.900
So I can't actually make
a direct access array

01:02:03.900 --> 01:02:05.125
because those words--

01:02:05.125 --> 01:02:07.000
while they fit in a
constant number of words,

01:02:07.000 --> 01:02:09.390
I don't know if the integer
representation of those

01:02:09.390 --> 01:02:11.820
are polynomial-bounded.

01:02:11.820 --> 01:02:13.200
Does that make sense?

01:02:13.200 --> 01:02:16.043
So I do want to use
hashing in this case.

01:02:16.043 --> 01:02:17.460
And so what do I
want to maintain?

01:02:17.460 --> 01:02:30.180
I want to maintain a sequence
data structure on customers.

01:02:30.180 --> 01:02:31.620
Customers.

01:02:31.620 --> 01:02:33.060
Is there a U in there somewhere?

01:02:33.060 --> 01:02:33.560
No.

01:02:33.560 --> 01:02:34.620
This is right, right?

01:02:34.620 --> 01:02:35.120
OK.

01:02:35.120 --> 01:02:41.170
And a set mapping.

01:02:41.170 --> 01:02:42.780
So this is usually how I do it.

01:02:42.780 --> 01:02:46.380
Like I want to say a
set keyed on something.

01:02:46.380 --> 01:02:49.020
If it's just a set,
then I just have it key.

01:02:49.020 --> 01:02:51.150
I can look up whether that
thing is there or not.

01:02:51.150 --> 01:02:55.140
But when I'm actually having
it mapped to something else,

01:02:55.140 --> 01:03:00.120
I'll say, mapping a key, space,
to something else, usually

01:03:00.120 --> 01:03:02.010
the item that I'm
storing or maybe

01:03:02.010 --> 01:03:04.380
some property of the
items that I'm storing.

01:03:04.380 --> 01:03:05.620
Does that make sense?

01:03:05.620 --> 01:03:06.120
OK.

01:03:06.120 --> 01:03:09.140
So mapping, what do I map here?

01:03:09.140 --> 01:03:09.640
Names.

01:03:13.380 --> 01:03:15.348
To-- oh.

01:03:15.348 --> 01:03:16.320
To what?

01:03:16.320 --> 01:03:18.438
Do I want to map?

01:03:18.438 --> 01:03:20.558
AUDIENCE: To time--

01:03:20.558 --> 01:03:21.350
JASON KU: The time.

01:03:21.350 --> 01:03:23.690
The time that they entered.

01:03:23.690 --> 01:03:24.921
Do I want to do that?

01:03:24.921 --> 01:03:27.350
AUDIENCE: Well, you can't
exactly do it with the time

01:03:27.350 --> 01:03:29.517
that they entered, but the
sequence on the customers

01:03:29.517 --> 01:03:30.895
will show what's next in line.

01:03:30.895 --> 01:03:31.520
JASON KU: Yeah.

01:03:31.520 --> 01:03:35.570
I want to store it to where
it is in this sequence.

01:03:35.570 --> 01:03:38.450
So I'll just store the index
where it is in the sequence

01:03:38.450 --> 01:03:39.620
and I can just look it up.

01:03:39.620 --> 01:03:43.177
That's sounds-- yeah?

01:03:43.177 --> 01:03:43.760
Is that what--

01:03:43.760 --> 01:03:45.560
AUDIENCE: I thought
the indices change.

01:03:45.560 --> 01:03:46.185
JASON KU: Yeah.

01:03:46.185 --> 01:03:48.380
Indices change every time
I add or remove things.

01:03:48.380 --> 01:03:49.550
AUDIENCE: [INAUDIBLE]

01:03:49.550 --> 01:03:50.390
JASON KU: Ah, yeah.

01:03:50.390 --> 01:03:53.270
Store a pointer.

01:03:53.270 --> 01:04:00.740
Pointer to place in sequence.

01:04:00.740 --> 01:04:04.520
Now, that's a
little weird to say,

01:04:04.520 --> 01:04:09.500
because I haven't told you how
I represented this sequence.

01:04:09.500 --> 01:04:13.790
But conceptually I can
say I'm drawing a pointer

01:04:13.790 --> 01:04:15.470
to someplace in
this that represents

01:04:15.470 --> 01:04:19.700
where it is, I'll deal with
the details of that later.

01:04:19.700 --> 01:04:22.580
But generally I call this
a linked data structure,

01:04:22.580 --> 01:04:26.780
because I'm linking
between two data structures

01:04:26.780 --> 01:04:30.380
so that I can do a query in one,
say, and find out where it is

01:04:30.380 --> 01:04:31.970
and the other.

01:04:31.970 --> 01:04:36.140
Or do a query in the
other, that kind of thing.

01:04:36.140 --> 01:04:39.990
So, everyone kind of understand
why I chose these things?

01:04:39.990 --> 01:04:41.240
How I approached this problem?

01:04:41.240 --> 01:04:42.020
Yeah?

01:04:42.020 --> 01:04:46.430
AUDIENCE: I'm not sure how
a pointer fixes the problem

01:04:46.430 --> 01:04:49.820
of just storing an index.

01:04:49.820 --> 01:04:53.880
The place that a person
is at in the sequence

01:04:53.880 --> 01:04:55.260
is going to change over time.

01:04:55.260 --> 01:04:55.560
JASON KU: Mm-hmm.

01:04:55.560 --> 01:04:57.852
AUDIENCE: --assuming that a
pointer updates, would that

01:04:57.852 --> 01:04:58.570
change?

01:04:58.570 --> 01:04:59.340
JASON KU: So-- OK.

01:04:59.340 --> 01:05:03.850
So let's say if every time--

01:05:03.850 --> 01:05:05.190
so let's say I'm storing--

01:05:05.190 --> 01:05:07.410
let's say I'm storing this
sequence in a linked list,

01:05:07.410 --> 01:05:09.120
let's just say,
because I know that I'm

01:05:09.120 --> 01:05:11.162
going to have to be
inserting and deleting things

01:05:11.162 --> 01:05:12.860
from the middle of this thing.

01:05:12.860 --> 01:05:13.840
Does that make sense?

01:05:13.840 --> 01:05:14.340
All right.

01:05:14.340 --> 01:05:16.920
So I'm going to go
ahead and say that this

01:05:16.920 --> 01:05:19.050
is going to be a linked list.

01:05:19.050 --> 01:05:21.165
Now I have this linked list.

01:05:24.930 --> 01:05:30.900
So if I said, all right, the
set data structure in my set

01:05:30.900 --> 01:05:32.520
stores--

01:05:32.520 --> 01:05:36.272
or stores where it is
in the linked list,

01:05:36.272 --> 01:05:41.980
let's say it's stored
at k, all right?

01:05:41.980 --> 01:05:43.620
Cool.

01:05:43.620 --> 01:05:51.750
Now if I seat this guy,
I stick him at his table,

01:05:51.750 --> 01:05:54.180
every index has changed.

01:05:54.180 --> 01:05:57.870
So for me to update the
indices stored in this set data

01:05:57.870 --> 01:06:00.545
structure, I have to change
every single one of them.

01:06:00.545 --> 01:06:01.170
AUDIENCE: Yeah.

01:06:01.170 --> 01:06:02.100
JASON KU: Does that make sense?

01:06:02.100 --> 01:06:04.000
AUDIENCE: Yeah, no, this
makes way more sense.

01:06:04.000 --> 01:06:04.625
JASON KU: Yeah.

01:06:04.625 --> 01:06:07.290
So really what I want, not
to store a number here,

01:06:07.290 --> 01:06:09.330
but an actual pointer
to the node that's

01:06:09.330 --> 01:06:12.540
containing this thing,
because the node

01:06:12.540 --> 01:06:16.380
isn't changing unless that
thing left my data structure.

01:06:16.380 --> 01:06:20.340
The node, the address of this
thing in memory, the node

01:06:20.340 --> 01:06:22.500
is just a little
container that contains

01:06:22.500 --> 01:06:25.110
an item and the next
pointer, and actually we're

01:06:25.110 --> 01:06:28.900
going to need a
previous pointer here.

01:06:28.900 --> 01:06:31.800
We're going to need
a doubly-linked list.

01:06:31.800 --> 01:06:34.440
Because what we're going to
do when we remove something,

01:06:34.440 --> 01:06:36.750
we need to stitch
it back together

01:06:36.750 --> 01:06:38.820
in constant time,
which means we need

01:06:38.820 --> 01:06:42.720
to know what's the one in front
of us and the one behind us.

01:06:42.720 --> 01:06:43.395
Yeah?

01:06:43.395 --> 01:06:44.470
No?

01:06:44.470 --> 01:06:44.970
All right.

01:06:44.970 --> 01:06:47.230
So linked list here.

01:06:47.230 --> 01:06:49.500
We already said maybe
using a hash table here.

01:06:54.030 --> 01:06:56.850
And so, OK, great.

01:06:56.850 --> 01:07:00.690
This is basically
enough for me to say,

01:07:00.690 --> 01:07:03.500
this is my data structure,
these are the invariants.

01:07:03.500 --> 01:07:04.500
What are the invariants?

01:07:04.500 --> 01:07:07.230
It's storing all the customers.

01:07:07.230 --> 01:07:08.220
That's an invariant.

01:07:08.220 --> 01:07:10.860
I mean, it's not a very
strong invariant, but it's--

01:07:10.860 --> 01:07:13.260
yeah, I mean, I should say that.

01:07:13.260 --> 01:07:15.090
I'm storing all the
customers because I'm

01:07:15.090 --> 01:07:17.730
going to have to make sure
that I'm maintaining that when

01:07:17.730 --> 01:07:19.770
I do a query.

01:07:19.770 --> 01:07:24.450
And then here, set
mapping names to pointers.

01:07:24.450 --> 01:07:26.940
The place in this thing.

01:07:26.940 --> 01:07:29.520
And as I remove things,
I need to make sure

01:07:29.520 --> 01:07:31.620
that invariant stays the same.

01:07:31.620 --> 01:07:33.810
It's still mapping all
the names of customers

01:07:33.810 --> 01:07:37.560
that I have in my
thing to their nodes.

01:07:37.560 --> 01:07:39.810
So when something
leaves, I better

01:07:39.810 --> 01:07:43.320
need to make sure that both
of these things are updated.

01:07:43.320 --> 01:07:44.320
Does that make sense?

01:07:44.320 --> 01:07:44.820
OK.

01:07:44.820 --> 01:07:47.790
So how do I maintain
these operations?

01:07:47.790 --> 01:07:50.400
We've got a build--

01:07:50.400 --> 01:07:53.910
build just sets up
empty of these things.

01:07:53.910 --> 01:07:56.010
It's easier to say that.

01:07:56.010 --> 01:07:59.610
I build an empty linked
list, doubly-linked lists

01:07:59.610 --> 01:08:04.080
on the customers,
and I build a set--

01:08:04.080 --> 01:08:07.740
a hash table mapping nothing
to nothing right now.

01:08:07.740 --> 01:08:08.430
OK.

01:08:08.430 --> 01:08:10.410
So that's build.

01:08:10.410 --> 01:08:13.080
I'm going to be precise
here and actually

01:08:13.080 --> 01:08:18.870
write down the thing
because I told you not

01:08:18.870 --> 01:08:21.510
to ignore a
operation, or else we

01:08:21.510 --> 01:08:23.850
can't give you points for it.

01:08:23.850 --> 01:08:24.957
The next one-- yeah?

01:08:24.957 --> 01:08:27.374
AUDIENCE: By emptying-- by
building an empty linked list--

01:08:27.374 --> 01:08:28.109
JASON KU: Mm-hmm.

01:08:28.109 --> 01:08:30.460
AUDIENCE: --it just has
like the head and the tail,

01:08:30.460 --> 01:08:32.652
it's actually none,
but, like, it exists?

01:08:32.652 --> 01:08:33.569
JASON KU: Yeah, right.

01:08:33.569 --> 01:08:35.880
It's a thing in
memory that we store.

01:08:35.880 --> 01:08:38.500
It has a pointer to
a head and a tail.

01:08:38.500 --> 01:08:40.140
Those are none right now.

01:08:40.140 --> 01:08:42.630
But we will add things to it.

01:08:42.630 --> 01:08:43.380
OK.

01:08:43.380 --> 01:08:45.870
So the second one, add name.

01:08:50.910 --> 01:08:52.170
What do we have to say?

01:08:52.170 --> 01:08:54.060
We have to update this
data structure so it

01:08:54.060 --> 01:08:56.580
maintains it's a variance.

01:08:56.580 --> 01:09:00.779
I have to-- usually I
start with one of them.

01:09:00.779 --> 01:09:03.300
I get to a point
where, oh, I really

01:09:03.300 --> 01:09:05.850
should have updated
the other one first.

01:09:05.850 --> 01:09:07.560
So sometimes it's hit or miss.

01:09:07.560 --> 01:09:08.720
What do I want to do here?

01:09:08.720 --> 01:09:12.930
Well, I have no idea where
in this sequence this is.

01:09:12.930 --> 01:09:16.470
So I kind of have
to go here first.

01:09:16.470 --> 01:09:17.760
Oh, sorry.

01:09:17.760 --> 01:09:21.240
Adding a guy, I
could do either way.

01:09:21.240 --> 01:09:23.770
I know-- where is
he going to go?

01:09:23.770 --> 01:09:25.420
End of the list.

01:09:25.420 --> 01:09:27.840
So I just stick it there.

01:09:27.840 --> 01:09:36.689
So add x to end of sequence.

01:09:36.689 --> 01:09:41.370
So I come to a
trick that I like.

01:09:41.370 --> 01:09:43.950
Sequence, set.

01:09:43.950 --> 01:09:44.460
OK.

01:09:44.460 --> 01:09:46.830
In this instance I only have
one sequence and one set.

01:09:46.830 --> 01:09:50.388
And so calling them sequence
and set, probably fine.

01:09:50.388 --> 01:09:51.930
I'm not going to
confuse the greater,

01:09:51.930 --> 01:09:54.480
I'm not going to confuse myself.

01:09:54.480 --> 01:09:56.970
But when I have more
than one of these things,

01:09:56.970 --> 01:10:01.470
or even for brevity on an exam
where I'm time-constrained,

01:10:01.470 --> 01:10:03.690
give these things a name.

01:10:03.690 --> 01:10:08.580
Say this is a sequence
C and M. I don't know.

01:10:08.580 --> 01:10:12.240
I see customer here, I
see a map here, so maybe.

01:10:12.240 --> 01:10:13.350
I don't know.

01:10:13.350 --> 01:10:15.720
But just give them
a letter, then we

01:10:15.720 --> 01:10:17.970
can follow you much more
clearly and you can refer

01:10:17.970 --> 01:10:19.980
to these things more precisely.

01:10:19.980 --> 01:10:25.930
So end of C.

01:10:25.930 --> 01:10:27.940
Then what do we have to do?

01:10:27.940 --> 01:10:30.730
I fix this guy, this guy's good.

01:10:30.730 --> 01:10:32.570
Now I have to fix this guy.

01:10:32.570 --> 01:10:37.600
So I add x to the set and
I map it back to that node

01:10:37.600 --> 01:10:39.160
that I just came from.

01:10:39.160 --> 01:10:41.560
I could store it in
a temporary variable.

01:10:41.560 --> 01:10:59.030
Add x to M pointing
to n node v to v. OK.

01:10:59.030 --> 01:11:00.490
Cool?

01:11:00.490 --> 01:11:08.050
So, I added my x to the end of
C into a node v. I'm kind of--

01:11:08.050 --> 01:11:11.410
I labeled it so I can
reference it later.

01:11:11.410 --> 01:11:15.610
And in code, I would probably
remember what that node was.

01:11:15.610 --> 01:11:19.750
Add x to M pointing
to that node,

01:11:19.750 --> 01:11:21.370
and now I've maintained
my invariant.

01:11:21.370 --> 01:11:21.880
Great.

01:11:21.880 --> 01:11:24.470
AUDIENCE: Maybe [INAUDIBLE].

01:11:24.470 --> 01:11:28.370
JASON KU: Add key x.

01:11:28.370 --> 01:11:35.360
Or add x to M having the
key of x point to that node.

01:11:35.360 --> 01:11:36.330
Does that make sense?

01:11:36.330 --> 01:11:38.750
There's a subtlety there.

01:11:38.750 --> 01:11:43.100
3 3, we have remove--

01:11:43.100 --> 01:11:45.230
I don't remember
the name, whatever.

01:11:45.230 --> 01:11:46.760
OK.

01:11:46.760 --> 01:11:48.590
So here, we have to do--

01:11:48.590 --> 01:11:49.490
order matters.

01:11:49.490 --> 01:11:53.175
I don't know where it
is in the sequence,

01:11:53.175 --> 01:11:54.800
but I'm going to look
it up in the set,

01:11:54.800 --> 01:11:57.920
and I'm going to
remove it from the set,

01:11:57.920 --> 01:12:00.170
and I'm going to look
at whatever it points to

01:12:00.170 --> 01:12:02.180
and remove it from the sequence.

01:12:02.180 --> 01:12:03.930
I'm running out of
time a little bit here,

01:12:03.930 --> 01:12:05.597
so I'm not going to
write all that down.

01:12:05.597 --> 01:12:07.160
You guys understand
what that means.

01:12:07.160 --> 01:12:08.780
Here, we're using
the fact that it's

01:12:08.780 --> 01:12:12.740
a doubly-linked list so that
we can relink things together.

01:12:12.740 --> 01:12:16.260
You don't have to tell
me the three points--

01:12:16.260 --> 01:12:20.840
the previous pointer of my
next thing to the next-- the--

01:12:20.840 --> 01:12:21.375
right?

01:12:21.375 --> 01:12:23.000
You don't have to
tell me how to relink

01:12:23.000 --> 01:12:27.110
those pointers because we did
that already in problem set 1

01:12:27.110 --> 01:12:27.878
or whatever.

01:12:27.878 --> 01:12:30.420
AUDIENCE: Just in general, as
you're in a situation for where

01:12:30.420 --> 01:12:32.342
you're using not a
doubly-linked list--

01:12:32.342 --> 01:12:33.050
JASON KU: Mm-hmm.

01:12:33.050 --> 01:12:34.040
AUDIENCE: where
just a linked list

01:12:34.040 --> 01:12:35.420
would be better than
a doubly linked list

01:12:35.420 --> 01:12:37.220
because it seems like it
always solves problems.

01:12:37.220 --> 01:12:37.845
JASON KU: Yeah.

01:12:37.845 --> 01:12:40.430
Doubly-linked lists is
almost always strictly better

01:12:40.430 --> 01:12:42.380
than a singly-linked
in theory problems.

01:12:42.380 --> 01:12:47.540
So yeah, use it.

01:12:47.540 --> 01:12:48.680
OK.

01:12:48.680 --> 01:12:50.420
And then seat, last one.

01:12:55.090 --> 01:12:59.890
That's just take the
front of the sequence,

01:12:59.890 --> 01:13:03.760
remove it, change
the head around,

01:13:03.760 --> 01:13:06.880
but I get that you
can delete first.

01:13:06.880 --> 01:13:09.350
You're reducing to the
interface that we had.

01:13:09.350 --> 01:13:12.490
You're deleting first
on the sequence.

01:13:12.490 --> 01:13:14.870
But now, we have a situation.

01:13:14.870 --> 01:13:16.360
I deleted the first guy.

01:13:16.360 --> 01:13:19.150
How do I know who
the first guy is?

01:13:19.150 --> 01:13:21.320
Well, I'm storing
its name in there.

01:13:21.320 --> 01:13:23.180
I'm storing the names
of these customers.

01:13:23.180 --> 01:13:27.220
So I know who is at the
front, I look in this set data

01:13:27.220 --> 01:13:29.813
structure, and I
remove that entry.

01:13:29.813 --> 01:13:30.730
Does that makes sense?

01:13:30.730 --> 01:13:34.270
Because now, I no longer need
to maintain where he goes.

01:13:34.270 --> 01:13:38.500
Now in actuality,
I could just not

01:13:38.500 --> 01:13:40.790
update this set data structure.

01:13:40.790 --> 01:13:43.360
But if I do that, then,
well, my running times

01:13:43.360 --> 01:13:45.010
are still linear time.

01:13:45.010 --> 01:13:46.900
I'm not giving you
a bound on space.

01:13:46.900 --> 01:13:50.440
I'm still constant time, sorry.

01:13:50.440 --> 01:13:53.320
So you don't actually
have to do that removal,

01:13:53.320 --> 01:13:56.440
but if that customer
comes back and wants

01:13:56.440 --> 01:14:00.565
to get on the wait list again,
there are things to consider.

01:14:03.710 --> 01:14:04.210
OK.

01:14:04.210 --> 01:14:07.130
So that's that question.

01:14:07.130 --> 01:14:11.500
Next question, last
10 minutes or so.

01:14:11.500 --> 01:14:12.790
Raniy Research.

01:14:12.790 --> 01:14:20.260
This is a problem that
people had nightmares about.

01:14:20.260 --> 01:14:25.330
OK, so basically we've
got a Meather Wan.

01:14:25.330 --> 01:14:26.680
He's a weatherman.

01:14:26.680 --> 01:14:30.850
A scientist who studies
global rainfall.

01:14:30.850 --> 01:14:34.450
And he's got a bunch
of sensors everywhere.

01:14:34.450 --> 01:14:37.540
And each one can post to
the cloud or something

01:14:37.540 --> 01:14:39.910
a measurement that's
of the form a triple

01:14:39.910 --> 01:14:43.150
of integers r, l,
and t where r is

01:14:43.150 --> 01:14:46.690
a positive amount of
rainfall, an integer;

01:14:46.690 --> 01:14:51.470
a latitude, an integer
again; and at a time.

01:14:51.470 --> 01:14:53.150
We got three things
to deal with here.

01:14:53.150 --> 01:14:53.650
Yuck.

01:14:56.478 --> 01:14:57.520
But they're all integers.

01:14:57.520 --> 01:14:59.830
And don't be like,
oh, well Jason,

01:14:59.830 --> 01:15:03.260
latitudes are pretty small.

01:15:03.260 --> 01:15:06.370
So I can assume these
integers are small

01:15:06.370 --> 01:15:09.010
and these things
take constant time.

01:15:09.010 --> 01:15:11.530
I'm not specifying to
you a resolution at which

01:15:11.530 --> 01:15:13.600
I'm measuring these integers.

01:15:13.600 --> 01:15:16.630
And I haven't given you a bound
between what that resolution is

01:15:16.630 --> 01:15:18.790
compared to the number of
measurements that I have,

01:15:18.790 --> 01:15:20.000
so I don't play those games.

01:15:20.000 --> 01:15:21.130
OK.

01:15:21.130 --> 01:15:24.880
The peak rainfall
at a given latitude

01:15:24.880 --> 01:15:29.650
since a particular time
is the maximum rainfall

01:15:29.650 --> 01:15:33.520
at any measurement at that
latitude measured at a time

01:15:33.520 --> 01:15:35.820
greater than or
equal to that time.

01:15:35.820 --> 01:15:37.270
Does that make sense?

01:15:37.270 --> 01:15:39.940
Or 0 if there aren't
measurements at that latitude.

01:15:39.940 --> 01:15:40.690
OK.

01:15:40.690 --> 01:15:44.380
To score after the time-- or
before the time or whatever.

01:15:44.380 --> 01:15:50.110
Describe a database that we
can build it in constant time.

01:15:50.110 --> 01:15:51.100
Is an empty one--

01:15:51.100 --> 01:15:53.020
I added this one
because we weren't

01:15:53.020 --> 01:15:55.810
good about that last spring.

01:15:55.810 --> 01:15:57.250
Record data.

01:15:57.250 --> 01:15:58.810
We give you a triplet.

01:15:58.810 --> 01:16:02.170
And then-- so record data,
for it to be correct,

01:16:02.170 --> 01:16:05.092
I just have to maintain
that information.

01:16:05.092 --> 01:16:07.810
For these kind of
updates, I don't--

01:16:07.810 --> 01:16:11.470
it's really hard for me to argue
that this thing is correct.

01:16:11.470 --> 01:16:12.670
Because I just--

01:16:12.670 --> 01:16:15.130
I throw it at the
database, the database

01:16:15.130 --> 01:16:17.890
doesn't have to give
anything back to me.

01:16:17.890 --> 01:16:20.980
So the important thing
here about correctness

01:16:20.980 --> 01:16:24.255
is that peak rainfall gives
it to me and it gives it to me

01:16:24.255 --> 01:16:25.880
in the time bound
that I'm looking for.

01:16:25.880 --> 01:16:28.030
And peak rainfall is
returning the peak rainfall

01:16:28.030 --> 01:16:31.960
at a particular
latitude since t.

01:16:31.960 --> 01:16:33.790
So we have three things.

01:16:33.790 --> 01:16:34.466
Yep?

01:16:34.466 --> 01:16:35.924
AUDIENCE: Given
that you never have

01:16:35.924 --> 01:16:39.290
to return a single measurement,
is that [INAUDIBLE]

01:16:39.290 --> 01:16:40.413
have a record of it?

01:16:40.413 --> 01:16:42.080
JASON KU: There's the
potential that you

01:16:42.080 --> 01:16:44.600
don't need to store
all of the information

01:16:44.600 --> 01:16:46.880
because all we're
doing is giving you

01:16:46.880 --> 01:16:49.340
back R's, essentially.

01:16:49.340 --> 01:16:52.670
It's possible that you don't
need to store the latitudes

01:16:52.670 --> 01:16:54.380
or times at all.

01:16:54.380 --> 01:16:56.360
You don't even need
to store the triplets.

01:16:56.360 --> 01:17:00.980
Now in reality, I'm querying
on the latitudes and the times.

01:17:00.980 --> 01:17:03.518
So I should store
them somewhere,

01:17:03.518 --> 01:17:05.060
but I might be able
to compress them.

01:17:05.060 --> 01:17:11.540
In particular, many things could
be stored at the same latitude.

01:17:11.540 --> 01:17:13.610
That's kind of the whole
point of the query.

01:17:13.610 --> 01:17:15.500
And so we want--

01:17:15.500 --> 01:17:18.120
I mean, we may only need to
store that latitude once.

01:17:18.120 --> 01:17:19.560
Does that makes sense?

01:17:19.560 --> 01:17:20.060
OK.

01:17:20.060 --> 01:17:21.770
I'm going to wait
for questions until

01:17:21.770 --> 01:17:25.140
after because I want to get
to a solution to this problem.

01:17:25.140 --> 01:17:25.640
All right.

01:17:25.640 --> 01:17:28.030
So what do we need to do?

01:17:28.030 --> 01:17:29.870
We need to be able
to add things.

01:17:29.870 --> 01:17:31.110
And I want to return.

01:17:31.110 --> 01:17:34.125
So return, I'm going to
have to query something,

01:17:34.125 --> 01:17:35.750
and then I'm going
to return something.

01:17:35.750 --> 01:17:40.828
So return peak rainfall at
latitude l since time t.

01:17:40.828 --> 01:17:42.620
What do I care about
in a particular query?

01:17:42.620 --> 01:17:48.860
I only care about all the
things at l, at a latitude l.

01:17:48.860 --> 01:17:52.700
So really, this isn't
such an interesting thing,

01:17:52.700 --> 01:17:55.850
but I want to be able to have
maybe many data structures, one

01:17:55.850 --> 01:17:59.120
associated with each L.
Does that make sense?

01:17:59.120 --> 01:18:05.210
And how can I find
one in each L quickly?

01:18:05.210 --> 01:18:06.210
Put it in a dictionary.

01:18:06.210 --> 01:18:07.370
What's my time bound?

01:18:07.370 --> 01:18:08.650
Worst case log n.

01:18:08.650 --> 01:18:11.430
So what data structure do I use
for that set data structure?

01:18:11.430 --> 01:18:12.710
A set AVL.

01:18:12.710 --> 01:18:17.180
So you're going to
first have a set AVL--

01:18:20.840 --> 01:18:33.500
say, L-- mapping latitudes to--

01:18:33.500 --> 01:18:36.903
well, now we have
more data structures.

01:18:36.903 --> 01:18:38.570
I want to store a lot
of the things that

01:18:38.570 --> 01:18:41.710
have the same latitudes
in another data structure.

01:18:41.710 --> 01:18:45.230
The ones probably
storing the times

01:18:45.230 --> 01:18:47.340
in the rainfalls of
all those measurements.

01:18:47.340 --> 01:18:49.510
Yeah?

01:18:49.510 --> 01:18:50.122
Yeah.

01:18:50.122 --> 01:18:51.080
AUDIENCE: A hash table.

01:18:51.080 --> 01:18:52.038
JASON KU: A hash table.

01:18:52.038 --> 01:18:53.810
OK, so what kinds
of query am I going

01:18:53.810 --> 01:18:57.030
to want to do on the things
at the same latitude?

01:18:57.030 --> 01:18:59.030
AUDIENCE: You're going
to want to get the times.

01:18:59.030 --> 01:19:00.905
JASON KU: I'm going to
want to get the times,

01:19:00.905 --> 01:19:04.520
but more than that, I'm doing
kind of an ordered query.

01:19:04.520 --> 01:19:08.300
I need the things less
than a certain time.

01:19:08.300 --> 01:19:09.077
Greater, sorry.

01:19:09.077 --> 01:19:10.160
AUDIENCE: So it's really--

01:19:10.160 --> 01:19:11.302
JASON KU: Just a second.

01:19:11.302 --> 01:19:13.260
AUDIENCE: Could you do
like an AVL for the time

01:19:13.260 --> 01:19:15.060
and an AVL for the rain?

01:19:15.060 --> 01:19:15.620
JASON KU: OK.

01:19:15.620 --> 01:19:18.290
Do I care about an
AVL for the rain?

01:19:18.290 --> 01:19:22.348
I mean, looking up
on the rainfall.

01:19:22.348 --> 01:19:22.890
AUDIENCE: No.

01:19:22.890 --> 01:19:23.862
JASON KU: No.

01:19:23.862 --> 01:19:25.820
So I'm going to go ahead
and store these things

01:19:25.820 --> 01:19:37.370
in a time-sorted AVL to
mapping latitude l to--

01:19:37.370 --> 01:19:39.860
I'm going to call this
data structure a time data

01:19:39.860 --> 01:19:40.520
structure.

01:19:40.520 --> 01:19:43.430
I'm going to say it's t of l.

01:19:43.430 --> 01:19:44.990
That kind of looks
like a recurrence,

01:19:44.990 --> 01:19:46.280
so it's a little
irking me right now,

01:19:46.280 --> 01:19:47.590
but I don't have
anything better.

01:19:47.590 --> 01:19:48.090
All right.

01:19:48.090 --> 01:19:51.680
So now each one of these
time data structures

01:19:51.680 --> 01:20:08.840
is a set AVL mapping time
to the rainfall measurement.

01:20:08.840 --> 01:20:10.160
All right.

01:20:10.160 --> 01:20:11.450
So that's going to--

01:20:11.450 --> 01:20:15.060
if my query was, return
the peak rainfall--

01:20:15.060 --> 01:20:15.560
sorry.

01:20:15.560 --> 01:20:22.820
Return the rainfall of the thing
with latitude l and time t,

01:20:22.820 --> 01:20:24.350
we'd be done, kind of.

01:20:24.350 --> 01:20:27.500
You'd know how to
support that query.

01:20:27.500 --> 01:20:29.270
To insert things,
I insert things

01:20:29.270 --> 01:20:32.450
into both data structures,
and I just look it up.

01:20:32.450 --> 01:20:34.880
The one complication
here is that I'm not

01:20:34.880 --> 01:20:39.740
asking for what is the
rainfall at a particular time.

01:20:39.740 --> 01:20:44.180
I want to know what the maximum
rainfall is up to this time.

01:20:44.180 --> 01:20:45.200
OK.

01:20:45.200 --> 01:20:49.040
So max heap's good if I
want to know the global max.

01:20:49.040 --> 01:20:54.200
But here, I want to know the
max bounded by a certain range.

01:20:54.200 --> 01:20:56.180
So we're going to--

01:20:56.180 --> 01:20:57.860
you can ask me
questions after this,

01:20:57.860 --> 01:21:00.350
we're running out of
time a little bit.

01:21:00.350 --> 01:21:03.810
So anyone have an idea for how--

01:21:03.810 --> 01:21:04.310
yeah?

01:21:04.310 --> 01:21:06.723
AUDIENCE: Could you just
augment the AVL with the max?

01:21:06.723 --> 01:21:07.265
JASON KU: OK.

01:21:07.265 --> 01:21:08.710
AUDIENCE: And you can just
look at the right child

01:21:08.710 --> 01:21:10.700
and then just look at
the max at that point?

01:21:10.700 --> 01:21:11.408
JASON KU: Ah, OK.

01:21:11.408 --> 01:21:12.920
So what your
colleague is saying,

01:21:12.920 --> 01:21:18.110
if we augment by the
max r in my subtree,

01:21:18.110 --> 01:21:21.800
maybe we can use that to
figure out this query.

01:21:21.800 --> 01:21:24.410
Because we're ordered
on t, right we

01:21:24.410 --> 01:21:28.190
have this nice monotonic
property that everything that's

01:21:28.190 --> 01:21:30.980
going to be in my query--

01:21:30.980 --> 01:21:35.210
everything to the right
of a certain time--

01:21:35.210 --> 01:21:41.700
if my time is above t
at a particular node,

01:21:41.700 --> 01:21:43.260
in everything in
the right subtree

01:21:43.260 --> 01:21:48.870
is also above that t because
of the order of my set's data

01:21:48.870 --> 01:21:51.690
structure, because
I'm ordered on times.

01:21:51.690 --> 01:21:54.240
So there's maybe the
possibility that if I

01:21:54.240 --> 01:21:56.520
look to my right
subtree, I can not

01:21:56.520 --> 01:21:59.910
do work all over
here by just looking

01:21:59.910 --> 01:22:01.980
at the max in that subtree.

01:22:01.980 --> 01:22:15.000
so That's an idea of, let's
say, augmented by subtree max r.

01:22:15.000 --> 01:22:17.290
You probably want to
give this a name as well.

01:22:17.290 --> 01:22:24.840
So like v max where v
is a node in my thing.

01:22:24.840 --> 01:22:28.530
And I want to show how to
support this, how I can compute

01:22:28.530 --> 01:22:29.980
that from its children.

01:22:29.980 --> 01:22:33.690
So how do I actually
support this query,

01:22:33.690 --> 01:22:37.380
I can think of it recursively.

01:22:37.380 --> 01:22:39.400
I have a couple of cases.

01:22:39.400 --> 01:22:44.190
If I'm at a v here, I want to
define a recursive function

01:22:44.190 --> 01:22:52.200
that's called peak rainfall
of a given node lower bounded

01:22:52.200 --> 01:22:52.770
by a t.

01:22:55.920 --> 01:22:59.190
So if I'm here,
there's two cases.

01:22:59.190 --> 01:23:03.885
Either my t, my time is bigger
or smaller-- is in my range

01:23:03.885 --> 01:23:06.690
or out of my range.

01:23:06.690 --> 01:23:08.850
If it's out of my
range, what do I do?

01:23:08.850 --> 01:23:12.120
It's lower than my time bound.

01:23:12.120 --> 01:23:16.140
I can just recursively call
this function on this node.

01:23:16.140 --> 01:23:19.290
Because I know that
anything is going

01:23:19.290 --> 01:23:23.460
to be down here
that I care about.

01:23:23.460 --> 01:23:26.400
And that's just one
recursive call down the tree.

01:23:26.400 --> 01:23:29.490
And so if I only limit myself
to one recursive call down

01:23:29.490 --> 01:23:32.490
the tree, I'm always
going down each time.

01:23:32.490 --> 01:23:34.920
This is going to take
logarithmic time.

01:23:34.920 --> 01:23:37.740
So that's the first case,
that's the easy case.

01:23:37.740 --> 01:23:41.220
This thing is not in range, I
return recursively the thing

01:23:41.220 --> 01:23:42.133
to my right.

01:23:42.133 --> 01:23:43.050
What's the other case?

01:23:43.050 --> 01:23:46.440
I'm in my range.

01:23:46.440 --> 01:23:51.240
Well now I could return,
recursively call both sides.

01:23:51.240 --> 01:23:53.640
Because that's what this
peak is talking about.

01:23:53.640 --> 01:23:55.020
What's my peak rainfall?

01:23:55.020 --> 01:23:57.720
But if I do that, if I
call it here recursively

01:23:57.720 --> 01:24:00.750
and I call it here recursively,
that could take linear time.

01:24:00.750 --> 01:24:03.600
I might touch every
node in my tree.

01:24:03.600 --> 01:24:05.300
So why did I do
this augmentation?

01:24:05.300 --> 01:24:07.800
So I don't have to
do work on this node.

01:24:07.800 --> 01:24:12.780
I just return the maximum
rainfall in this subtree,

01:24:12.780 --> 01:24:15.090
and then recurse on this side.

01:24:15.090 --> 01:24:18.060
So I did constant
work on this side,

01:24:18.060 --> 01:24:19.750
I did one recursive
call down here

01:24:19.750 --> 01:24:21.750
which you could go to the
bottom, but that's OK,

01:24:21.750 --> 01:24:24.863
I can afford to go to
the bottom of the tree.

01:24:24.863 --> 01:24:25.780
Does that makes sense?

01:24:25.780 --> 01:24:29.850
And if I don't have either
subtree, then I'm done.

01:24:29.850 --> 01:24:31.420
If at any time.

01:24:31.420 --> 01:24:33.660
I don't have the node
that I'm supposed

01:24:33.660 --> 01:24:40.500
to recurse on, I take the
max of this subtree, myself,

01:24:40.500 --> 01:24:43.860
and whatever the recursive
return value is here.

01:24:43.860 --> 01:24:47.070
And comparing three values,
returning their max.

01:24:47.070 --> 01:24:48.280
Does that make sense?

01:24:48.280 --> 01:24:48.780
OK.

01:24:48.780 --> 01:24:52.380
So that's what we call
a one-sided range query.

01:24:52.380 --> 01:24:58.260
So in the-- I think problem
session 4 that I didn't get to,

01:24:58.260 --> 01:25:02.100
it shows you a way to do this
for a two-sided range query

01:25:02.100 --> 01:25:05.610
where I need to know the maximum
of all things between two

01:25:05.610 --> 01:25:07.170
things.

01:25:07.170 --> 01:25:09.930
But it's really no more
difficult than this

01:25:09.930 --> 01:25:13.560
to finding a recursive function
that uses an augmentation so

01:25:13.560 --> 01:25:18.210
that you don't have to do
recursive call on both sides.

01:25:18.210 --> 01:25:19.740
Does that makes sense?

01:25:19.740 --> 01:25:21.000
OK.

01:25:21.000 --> 01:25:25.830
That's going to be it for now,
and I can take questions after.

01:25:25.830 --> 01:25:27.740
Thanks for coming.