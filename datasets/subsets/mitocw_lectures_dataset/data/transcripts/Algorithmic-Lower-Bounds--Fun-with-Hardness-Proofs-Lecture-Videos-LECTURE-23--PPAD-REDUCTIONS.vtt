WEBVTT

00:00:00.080 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.810
Commons license.

00:00:03.810 --> 00:00:06.060
Your support will help
MIT OpenCourseWare

00:00:06.060 --> 00:00:10.150
continue to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.700
To make a donation or to
view additional materials

00:00:12.700 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.263
at ocw.mit.edu.

00:00:26.760 --> 00:00:28.260
PROFESSOR: Today
we have a lecturer,

00:00:28.260 --> 00:00:32.140
guest lecture two of
two, Costis Daskalakis.

00:00:32.140 --> 00:00:33.960
COSTIS DASKALAKIS:
Glad to be back.

00:00:33.960 --> 00:00:37.480
So let's continue on the
path we followed last time.

00:00:37.480 --> 00:00:40.110
Let me remind you what we
did last time, first of all.

00:00:40.110 --> 00:00:43.010
So I talked about
interesting theorems

00:00:43.010 --> 00:00:47.010
in topology-- Nash,
Sperner, and Brouwer.

00:00:47.010 --> 00:00:52.160
And I defined the
corresponding--

00:00:52.160 --> 00:00:53.970
so these were
theorems in topology.

00:00:53.970 --> 00:00:57.820
Define the
corresponding problems.

00:00:57.820 --> 00:01:00.990
And because of these
existence theorems,

00:01:00.990 --> 00:01:04.300
the corresponding search
problems were total.

00:01:04.300 --> 00:01:10.260
And then I looked into the
problems in NP that are total,

00:01:10.260 --> 00:01:17.010
and I tried to identify what in
these problems make them total

00:01:17.010 --> 00:01:20.040
and tried to identify
combinatorial argument that

00:01:20.040 --> 00:01:24.150
guarantees the existence of
solutions in these problems.

00:01:24.150 --> 00:01:26.850
Motivated by the
argument, which turned out

00:01:26.850 --> 00:01:29.130
to be a parity argument
on directed graphs,

00:01:29.130 --> 00:01:34.460
I defined the class PPAD,
and I introduced the problem

00:01:34.460 --> 00:01:44.660
of ArithmCircuitSAT, which is
PPAD complete, and from which

00:01:44.660 --> 00:01:48.330
I promised to show a bunch
of PPAD hardness deductions

00:01:48.330 --> 00:01:49.530
this time.

00:01:49.530 --> 00:01:57.280
So let me remind you the
salient points from this list

00:01:57.280 --> 00:01:58.130
before I keep going.

00:01:58.130 --> 00:02:02.020
So first of all, the PPAD class
has a combinatorial flavor.

00:02:02.020 --> 00:02:04.250
In the definition of the
class, what I'm doing

00:02:04.250 --> 00:02:09.610
is I'm defining a graph
on all possible n-bit

00:02:09.610 --> 00:02:13.790
strings, so an
exponentially large set

00:02:13.790 --> 00:02:16.370
by providing two
circuits, P and N.

00:02:16.370 --> 00:02:22.260
P is a circuit of
possible father,

00:02:22.260 --> 00:02:25.920
and N is the circuit
of possible child.

00:02:25.920 --> 00:02:29.780
And given these two circuits,
I establish a directed edge

00:02:29.780 --> 00:02:34.110
between string v1 and string v2,
if they agree on their parent

00:02:34.110 --> 00:02:37.730
relationship, meaning v2
believes V1 is his father,

00:02:37.730 --> 00:02:41.280
and also v1 believes
v2 is its child.

00:02:41.280 --> 00:02:43.745
In that case if this
condition is true,

00:02:43.745 --> 00:02:47.020
I establish an edge between
these two pairs of nodes.

00:02:47.020 --> 00:02:49.480
And I do the same for
all pairs of strings.

00:02:49.480 --> 00:02:52.190
And in the end, I get a graph.

00:02:52.190 --> 00:02:55.650
And the problem end of the line
is given these two circuits

00:02:55.650 --> 00:02:59.130
and the corresponding graph
that they define on this set,

00:02:59.130 --> 00:03:04.030
if the all 0 string is
unbalanced meaning different

00:03:04.030 --> 00:03:07.410
in and out degree,
then I want you

00:03:07.410 --> 00:03:13.960
to find another
unbalanced node, string,

00:03:13.960 --> 00:03:17.940
which is guaranteed to exist
by the parity arguments.

00:03:17.940 --> 00:03:21.350
And PPAD is a class of
all search problems in FNP

00:03:21.350 --> 00:03:25.580
they are reducable-- polynomial
time reducible to this problem.

00:03:25.580 --> 00:03:29.480
I'll remind you also of
structure of the graph defined

00:03:29.480 --> 00:03:31.130
by these two circuits.

00:03:31.130 --> 00:03:37.040
It's easy to verify that if
my edge definition is this,

00:03:37.040 --> 00:03:40.340
then every vertex has in degree
and out degree at most once.

00:03:40.340 --> 00:03:43.730
So the graph that's induced
by these two circuits

00:03:43.730 --> 00:03:45.320
will have this form.

00:03:45.320 --> 00:03:49.410
And basically, I'm looking
for all red points.

00:03:49.410 --> 00:03:53.280
For any of these points, any
of these red points, strings,

00:03:53.280 --> 00:03:55.610
are solutions, any
unbalanced string,

00:03:55.610 --> 00:03:58.180
except for the all 0 string.

00:03:58.180 --> 00:04:00.160
If the all 0 string
is not unbalanced,

00:04:00.160 --> 00:04:02.219
then I don't want
you to do anything.

00:04:02.219 --> 00:04:03.760
If it is unbalanced,
then I'm looking

00:04:03.760 --> 00:04:05.170
for any of these red vertices.

00:04:05.170 --> 00:04:08.590
So that's the class PPAD, and
it has a combinatorial flavor.

00:04:08.590 --> 00:04:12.050
So I'm defining a huge graph,
we have these two circuits.

00:04:12.050 --> 00:04:15.390
And I'm asking you to find
any of these red points.

00:04:15.390 --> 00:04:19.529
So on the other hand,
sort of like the problems

00:04:19.529 --> 00:04:22.880
we were targeting, Nash
equilibrium, Brouwer's theorem,

00:04:22.880 --> 00:04:25.090
had a more continues flavor.

00:04:25.090 --> 00:04:32.790
So instead of working
directly with this problem,

00:04:32.790 --> 00:04:34.370
with the end of the
line, and trying

00:04:34.370 --> 00:04:37.740
to reduce this problem
too Nash and to Brouwer

00:04:37.740 --> 00:04:40.590
to establish PPAD
hardness deductions,

00:04:40.590 --> 00:04:43.010
I actually introduced
a problem that actually

00:04:43.010 --> 00:04:44.700
closer to this problem.

00:04:44.700 --> 00:04:46.430
It has a continuous flavor.

00:04:46.430 --> 00:04:49.940
And it was the problem
ArithmCircuitSAT.

00:04:49.940 --> 00:04:51.760
There were a bunch
of problems last time

00:04:51.760 --> 00:04:53.720
about the definition
of the problem.

00:04:53.720 --> 00:04:57.630
So I decided to be more
explicit about what it is.

00:04:57.630 --> 00:05:00.590
So basically I'm
giving you a circuit

00:05:00.590 --> 00:05:04.020
that has two types of nodes,
viable nodes, v1 through vn,

00:05:04.020 --> 00:05:06.740
and gate nodes, g1 through gn.

00:05:06.740 --> 00:05:12.470
Now gate node has one
of six possible flavors.

00:05:12.470 --> 00:05:17.220
It could be an assignment
gate, and addition gate,

00:05:17.220 --> 00:05:20.730
a subtraction gate, set
equal to constant gate,

00:05:20.730 --> 00:05:25.346
multiply by a constant
gate, and comparison gate.

00:05:25.346 --> 00:05:26.720
Depending on the
type, it's going

00:05:26.720 --> 00:05:31.740
to have from 0 to the
3 inputs, to 2 inputs.

00:05:31.740 --> 00:05:33.900
And it always has 1 output.

00:05:33.900 --> 00:05:38.610
Now what I wanted to emphasize
is that this graph doesn't

00:05:38.610 --> 00:05:40.840
have inputs-- input variables.

00:05:43.760 --> 00:05:46.440
Loops are allowed.

00:05:46.440 --> 00:05:49.280
And what I want to emphasize
that I didn't emphasise

00:05:49.280 --> 00:05:55.430
last time is that variable
nodes have n degree 1,

00:05:55.430 --> 00:05:57.470
and gates have 0,
1, or 2 inputs,

00:05:57.470 --> 00:05:59.370
depending on their type.

00:05:59.370 --> 00:06:03.000
Otherwise for instance,
the out degree of a node

00:06:03.000 --> 00:06:04.360
could be arbitrary.

00:06:04.360 --> 00:06:08.790
The fan out could be
arbitrary, it doesn't matter.

00:06:08.790 --> 00:06:10.050
But you have to respect this.

00:06:10.050 --> 00:06:14.060
Every variable node
has n degree 1.

00:06:14.060 --> 00:06:18.920
Every gate node has 1, 2, or 2
inputs depending on the type.

00:06:18.920 --> 00:06:22.404
There are no edges
between gates and gates,

00:06:22.404 --> 00:06:23.570
and variables and variables.

00:06:23.570 --> 00:06:26.270
There are only edges
between variables and gates,

00:06:26.270 --> 00:06:28.060
and gates to variables.

00:06:28.060 --> 00:06:29.710
That's the input.

00:06:29.710 --> 00:06:33.080
The input is a circuit
that has this form.

00:06:33.080 --> 00:06:34.840
And what I want
you to do is I want

00:06:34.840 --> 00:06:39.165
you to find an
assignment of real 0,

00:06:39.165 --> 00:06:43.200
1 values to the
variables of this circuit

00:06:43.200 --> 00:06:48.870
such that the constraints
of the gates are satisfied.

00:06:48.870 --> 00:06:51.510
And here are the
constrains of the gates.

00:06:51.510 --> 00:06:53.530
So if they gate is
an assignment gate,

00:06:53.530 --> 00:06:57.100
I want the output
node, the node who's

00:06:57.100 --> 00:07:00.270
connected to the
output of the gate

00:07:00.270 --> 00:07:05.240
has equal value to the node
that's feeding into that gate.

00:07:05.240 --> 00:07:06.950
If they gate is
an addition gate,

00:07:06.950 --> 00:07:12.750
I want that variable node
who's connected to the output

00:07:12.750 --> 00:07:18.430
of the gate to be basically the
sum of the values of the inputs

00:07:18.430 --> 00:07:22.439
to the addition gate, except
I'm also going to threshold it.

00:07:22.439 --> 00:07:24.980
I'm not going to allow it going
above 1, and so and so forth.

00:07:24.980 --> 00:07:27.810
So these are the
gate conditions.

00:07:27.810 --> 00:07:33.270
So now what I said last time
is that a satisfying assignment

00:07:33.270 --> 00:07:36.820
always exists for this problem.

00:07:36.820 --> 00:07:39.320
It's not a priori,
so it a requires work

00:07:39.320 --> 00:07:41.750
and actually it is going
through a fixed point

00:07:41.750 --> 00:07:46.960
to argue that there is always
a solution to this problem.

00:07:46.960 --> 00:07:49.790
What I also claimed
last time is that it's

00:07:49.790 --> 00:07:52.680
PPAD complete to find a
satisfying assignment.

00:07:52.680 --> 00:07:56.390
So it's a natural starting
point for deductions.

00:07:56.390 --> 00:07:59.290
What I also said last
time is that in fact,

00:07:59.290 --> 00:08:05.660
I can allow some noise in the
error, in the gate constraints.

00:08:05.660 --> 00:08:10.080
I can allow plus minus
epsilon deviation

00:08:10.080 --> 00:08:13.200
from the gate constraints.

00:08:13.200 --> 00:08:16.140
And so this should
be a minus epsilon.

00:08:16.140 --> 00:08:18.580
Sorry about that.

00:08:18.580 --> 00:08:21.860
And this epsilon is
part of the input.

00:08:21.860 --> 00:08:25.950
I can give as input both
a circuit and an epsilon.

00:08:25.950 --> 00:08:28.420
And I will ask you to
satisfy the gate constraints

00:08:28.420 --> 00:08:30.530
with an epsilon.

00:08:30.530 --> 00:08:33.980
Now last time I also
showed you the structure

00:08:33.980 --> 00:08:36.470
the hardness proof
for Nash, which

00:08:36.470 --> 00:08:40.860
basically took generic PPAD
end of the line problem.

00:08:40.860 --> 00:08:43.049
Today PPAD complete
problem, end of the line,

00:08:43.049 --> 00:08:49.070
is embedded into geometry,
into the 3-D cube.

00:08:49.070 --> 00:08:55.160
Then we define a version of
Sperner's Lemma, which then

00:08:55.160 --> 00:08:58.110
introduced ArithmCircuitSAT.

00:08:58.110 --> 00:09:00.090
And I didn't show this
part of the deduction,

00:09:00.090 --> 00:09:01.881
and I'm not going to
show it because that's

00:09:01.881 --> 00:09:03.540
the complicated part.

00:09:03.540 --> 00:09:05.650
But I am going to
show is how to go

00:09:05.650 --> 00:09:08.080
from this problem,
the ArithmCircuitSAT

00:09:08.080 --> 00:09:11.810
to Nash equilibrium,
just to show how easy it

00:09:11.810 --> 00:09:17.570
is to work with this problem
and reduce to other problems.

00:09:17.570 --> 00:09:20.150
So that's where I
want to focus on.

00:09:20.150 --> 00:09:22.350
So that's the review
from last time.

00:09:22.350 --> 00:09:24.510
And this time, I want
to talk about-- I

00:09:24.510 --> 00:09:26.260
want to show the PPAD
completeness of Nash

00:09:26.260 --> 00:09:27.870
equilibrium.

00:09:27.870 --> 00:09:34.460
I'm going to briefly give
two other examples that

00:09:34.460 --> 00:09:38.500
have come from combinatorics.

00:09:38.500 --> 00:09:41.690
And then lastly, I'm going
to talk about other existence

00:09:41.690 --> 00:09:46.570
arguments and the complexity
classes that they define.

00:09:46.570 --> 00:09:50.922
So I'm going to introduce these
classes, PPA, PPP, and PLS.

00:09:50.922 --> 00:09:52.380
Before I do that,
I also thought it

00:09:52.380 --> 00:09:53.629
was a question from last time.

00:09:53.629 --> 00:09:55.720
PPAD stands for
polynomial parity argument

00:09:55.720 --> 00:09:59.170
in directed graphs,
corresponding to the fact

00:09:59.170 --> 00:10:01.780
that this class is defined
with this parity argument

00:10:01.780 --> 00:10:05.130
in directed graphs in mind.

00:10:05.130 --> 00:10:07.410
So let's focus on this
reduction, from Circuit

00:10:07.410 --> 00:10:08.740
to Nash.

00:10:08.740 --> 00:10:13.370
I want to introduce a concept
before I show the reduction.

00:10:13.370 --> 00:10:16.770
That concept is graphical
games and polymatrix games,

00:10:16.770 --> 00:10:19.090
a special case of
graphical games.

00:10:19.090 --> 00:10:21.650
So graphical games
were introduced in 2001

00:10:21.650 --> 00:10:25.990
by Kearns, Littman, and Singh
as something very natural.

00:10:25.990 --> 00:10:28.560
Basically they tried
to capture situations

00:10:28.560 --> 00:10:30.140
where the payoff
of a player only

00:10:30.140 --> 00:10:34.130
depends on the actions
of a few other players,

00:10:34.130 --> 00:10:36.590
because of geographical,
communication,

00:10:36.590 --> 00:10:38.020
or other constraints.

00:10:38.020 --> 00:10:42.675
So in the graphical game, the
players are nodes in the graph,

00:10:42.675 --> 00:10:44.940
in a directive graph.

00:10:44.940 --> 00:10:47.990
And a player's
payoff only depends

00:10:47.990 --> 00:10:51.780
on her own strategy, as well
as the strategy of the players

00:10:51.780 --> 00:10:53.530
that point to him.

00:10:56.710 --> 00:11:00.310
For example, this
guy's payoff depends

00:11:00.310 --> 00:11:03.390
on this guy's, this guy's,
and this guy's action.

00:11:03.390 --> 00:11:05.670
Because all of these guys
point to him, as well as

00:11:05.670 --> 00:11:06.380
his own action.

00:11:10.950 --> 00:11:15.680
A special case of these
games was actually

00:11:15.680 --> 00:11:18.940
introduced much earlier.

00:11:18.940 --> 00:11:21.360
So polymatrix games
are graphical games

00:11:21.360 --> 00:11:23.510
where the payoff
functions of the nodes

00:11:23.510 --> 00:11:26.250
are actually
edge-wise separable.

00:11:26.250 --> 00:11:30.310
So for instance, the
payoff of this guy

00:11:30.310 --> 00:11:34.000
as a function of
everybody's mixed strategy

00:11:34.000 --> 00:11:37.150
is separable overall
edges that point

00:11:37.150 --> 00:11:42.530
to him of some pairwise
player function that

00:11:42.530 --> 00:11:47.460
has to do with his action
and his neighbor's action.

00:11:47.460 --> 00:11:49.700
That's what's written here.

00:11:49.700 --> 00:11:59.230
And it's not very hard to see
that any-- so this is a utility

00:11:59.230 --> 00:12:06.750
function that depends on
the two mixed strategies.

00:12:06.750 --> 00:12:10.730
And by assumption, these
players randomize independently

00:12:10.730 --> 00:12:12.050
of each other.

00:12:12.050 --> 00:12:18.680
So any such expectation of a
pair of players' strategies

00:12:18.680 --> 00:12:20.850
that's are a
product can actually

00:12:20.850 --> 00:12:24.594
be written as a quadratic form.

00:12:24.594 --> 00:12:25.260
Do you see that?

00:12:29.100 --> 00:12:31.130
Let me write on the board.

00:12:31.130 --> 00:12:44.940
So again, Xv is the mixed
strategy of player v. Xw

00:12:44.940 --> 00:12:50.870
is the mixed strategy of w.

00:12:50.870 --> 00:12:59.540
What I mean by Uwv Xu,
comma Xw is basically

00:12:59.540 --> 00:13:06.180
an expectation over an
action Su drawn from Xu,

00:13:06.180 --> 00:13:09.480
and action is Sw.

00:13:09.480 --> 00:13:13.960
Sorry-- Sv drawn from
Xv, Sw drawn from Xw,

00:13:13.960 --> 00:13:31.590
independently of-- and that's
just the sum of all the Us

00:13:31.590 --> 00:13:45.950
and all the Sws of U, W, sv,
sw, and then the probabilities.

00:13:53.910 --> 00:13:56.340
And that's a quadratic form.

00:13:56.340 --> 00:14:00.260
So that's what I
mean by this line.

00:14:00.260 --> 00:14:03.780
Because players play
independently from each other,

00:14:03.780 --> 00:14:09.070
any expectation with respect
to that product distribution

00:14:09.070 --> 00:14:11.249
is a quadratic form.

00:14:11.249 --> 00:14:12.790
I'm not saying
something interesting.

00:14:15.480 --> 00:14:17.630
Good?

00:14:17.630 --> 00:14:20.210
So then a polymatrix
game is really,

00:14:20.210 --> 00:14:24.460
because of this, defined
by a directive graph.

00:14:24.460 --> 00:14:30.630
And then for every directed
edge, and every-- there is

00:14:30.630 --> 00:14:38.730
a matrix that defines the
quadratic form for that edge.

00:14:38.730 --> 00:14:41.964
So polymatrix game
is easily described.

00:14:41.964 --> 00:14:43.630
You can describe by
specifying the graph

00:14:43.630 --> 00:14:46.170
and then giving a matrix
what every directed edge.

00:14:49.010 --> 00:14:52.170
So bimatrix game are
two player games.

00:14:52.170 --> 00:14:54.200
So that's why these
are called polymatrix,

00:14:54.200 --> 00:14:56.996
because you have many matrices.

00:14:56.996 --> 00:14:59.370
In a two player game, you only
need to give two matrices,

00:14:59.370 --> 00:15:06.799
one for a two player game
is just player 1, player 2.

00:15:06.799 --> 00:15:08.590
And you give one matrix
for this direction,

00:15:08.590 --> 00:15:10.110
and one matrix for
that direction.

00:15:10.110 --> 00:15:12.530
So that's a bimatrix game.

00:15:12.530 --> 00:15:13.813
This is a polymatrix game.

00:15:17.760 --> 00:15:23.360
Now what I want to do
is I want to-- in order

00:15:23.360 --> 00:15:26.577
to reduce ArithmCircuitSAT
to Nash, instead what

00:15:26.577 --> 00:15:28.410
I'm going to do first
is I'm going to reduce

00:15:28.410 --> 00:15:33.320
ArithmCircuitSAT
to finding a Nash

00:15:33.320 --> 00:15:36.450
equilibrium in a
polymatrix game.

00:15:36.450 --> 00:15:38.250
That's what I want to do first.

00:15:38.250 --> 00:15:41.870
After I do that, then I'm
going to reduce it to-- so here

00:15:41.870 --> 00:15:43.600
I have many players.

00:15:43.600 --> 00:15:46.340
I want to go down
to two players.

00:15:46.340 --> 00:15:48.780
But the first step is to
just go to multiplayer

00:15:48.780 --> 00:15:50.000
Nash equilibrium.

00:15:50.000 --> 00:15:53.790
Then that deduction
is the easy part.

00:15:53.790 --> 00:15:55.670
Also this is an easy part.

00:15:55.670 --> 00:15:56.920
The hard part happened before.

00:16:00.200 --> 00:16:05.800
So now how can we reduce
an ArithmCircuitSAT problem

00:16:05.800 --> 00:16:10.760
into a polymatrix game
Nash equilibrium problem?

00:16:10.760 --> 00:16:18.180
Like in LP completeness, like in
reductions for NP, RP hardness

00:16:18.180 --> 00:16:21.820
proofs, you have
to give gadgets.

00:16:21.820 --> 00:16:28.890
You have to identify objects
in polymatrix games that

00:16:28.890 --> 00:16:31.920
simulate the
operations that happen

00:16:31.920 --> 00:16:34.030
in your circuit over here.

00:16:34.030 --> 00:16:38.870
So what I want to introduce is
what is called a game gadget.

00:16:38.870 --> 00:16:41.030
These are small
polymatrix games that

00:16:41.030 --> 00:16:44.350
do various arithmetic
operations, which

00:16:44.350 --> 00:16:49.560
I can then put together to
simulate an ArithmCircuitSAT

00:16:49.560 --> 00:16:50.060
problem.

00:16:53.586 --> 00:16:55.460
So what I want to do is
I'm going to give you

00:16:55.460 --> 00:16:56.720
a flavor of these gadgets.

00:16:56.720 --> 00:16:58.670
So I'm going to give you
the addition gadgets.

00:16:58.670 --> 00:17:03.010
I want to give you a polymatrix
game that does addition.

00:17:06.740 --> 00:17:08.150
So it's going to
have-- this game

00:17:08.150 --> 00:17:11.540
is going to have four players.

00:17:11.540 --> 00:17:14.760
Everything player will have
just two strategies-- 0 and 1,

00:17:14.760 --> 00:17:18.300
two pure strategies, hence the
mixed strategy of that player

00:17:18.300 --> 00:17:19.849
is going to be a
real number in 0,

00:17:19.849 --> 00:17:21.780
1, which corresponds
to the probability

00:17:21.780 --> 00:17:24.210
by which this player plays 1.

00:17:28.930 --> 00:17:31.030
So here's the structure
of the gadget.

00:17:31.030 --> 00:17:33.230
So this gadget, I'm
showing it here embedded

00:17:33.230 --> 00:17:36.630
into a potentially
bigger polymatrix game.

00:17:36.630 --> 00:17:42.075
But the gadget itself is going
to have four players, X, Y, W,

00:17:42.075 --> 00:17:47.580
Z. Now X, Y are what is called
the input to the gadget.

00:17:47.580 --> 00:17:50.970
So these are players
who point to W,

00:17:50.970 --> 00:17:53.930
but don't depend on
the actions of W and X

00:17:53.930 --> 00:17:56.500
because there are no
directions going the other way.

00:17:56.500 --> 00:17:59.730
So these guys don't care about
what these players are doing,

00:17:59.730 --> 00:18:03.300
and they serve as an
input to the gadget.

00:18:03.300 --> 00:18:08.030
Now this player, W, gets his
input of players strategies

00:18:08.030 --> 00:18:09.840
in this gadget.

00:18:09.840 --> 00:18:13.810
While X only cares
about the W is doing.

00:18:13.810 --> 00:18:16.050
So X and Y are going
to be called the input

00:18:16.050 --> 00:18:17.470
players to the gadget.

00:18:17.470 --> 00:18:20.130
Z is going to be called the
output player to the gadget.

00:18:20.130 --> 00:18:24.930
And W is going to be called
the auxiliary player.

00:18:24.930 --> 00:18:28.630
Now what I want to do is I want
to define-- the only thing I'm

00:18:28.630 --> 00:18:30.720
going to define is the
payoff function of W

00:18:30.720 --> 00:18:32.020
and the payoff function of Z.

00:18:32.020 --> 00:18:34.320
And I'm going to define this
payoff functions in a way

00:18:34.320 --> 00:18:37.930
that addition somehow
happens at a Nash equilibrium

00:18:37.930 --> 00:18:39.250
of this little game.

00:18:42.820 --> 00:18:44.974
So I'm going to define
the payoff succinctly.

00:18:44.974 --> 00:18:47.140
But then I'm going to
convince you that these really

00:18:47.140 --> 00:18:49.630
correspond to tables.

00:18:49.630 --> 00:18:56.370
So I'm going to say that W is
paid an expected-- depending

00:18:56.370 --> 00:18:57.240
on what he plays.

00:18:57.240 --> 00:19:02.020
So if he plays 0, he gets
paid an expected probability

00:19:02.020 --> 00:19:04.870
X equal $1, plus
probably X equals

00:19:04.870 --> 00:19:09.080
Y equals $1 if he plays 0.

00:19:09.080 --> 00:19:13.610
But if he plays 1, he only gets
paid probabilities equals $1.

00:19:13.610 --> 00:19:16.720
So in some sense if he plays
0, he looks to the left.

00:19:16.720 --> 00:19:19.020
If he plays 1, he
looks to the right.

00:19:19.020 --> 00:19:23.810
His payoffs are the sum of
these two guys probabilities

00:19:23.810 --> 00:19:30.380
of playing 1 in one case,
and this guy's probability

00:19:30.380 --> 00:19:31.990
of playing 1 in the other case.

00:19:31.990 --> 00:19:38.880
So that's the payoff function
to W. Now you would ask me maybe

00:19:38.880 --> 00:19:42.170
how can you implement
this payoff functions.

00:19:42.170 --> 00:19:45.100
And that's actually very easy.

00:19:45.100 --> 00:19:52.290
So here's the table for
player W. So when W plays 0,

00:19:52.290 --> 00:20:01.950
his payoff is depending on
the strategies of X and Y.

00:20:01.950 --> 00:20:06.310
I'm going to define it
to be 0, 1, 1, and 2.

00:20:06.310 --> 00:20:12.370
Now notice that in expectation
over X's and Y's strategies,

00:20:12.370 --> 00:20:17.360
he's payoff-- so if he plays
0, his expected payoff over X

00:20:17.360 --> 00:20:21.820
and Y's strategies is just
the probability that X plays

00:20:21.820 --> 00:20:26.280
1 plus the probability
that Y plays 1.

00:20:26.280 --> 00:20:29.580
Do you see this
from this matrix?

00:20:29.580 --> 00:20:37.060
So what's the expected
payoff to W when he plays 0?

00:20:37.060 --> 00:20:45.110
So this is 1 if Y
plays 1, but X plays 0.

00:20:48.400 --> 00:20:56.300
And it's 1 if X plays
1, but Y plays 0,

00:20:56.300 --> 00:20:59.040
and 2 if they both play 1.

00:21:04.970 --> 00:21:08.680
And I claim that if you
properly collect the terms,

00:21:08.680 --> 00:21:13.730
this is just equal to
probability Y plays 1,

00:21:13.730 --> 00:21:18.982
and X plays 1.

00:21:18.982 --> 00:21:19.940
So that's what I claim.

00:21:22.700 --> 00:21:24.740
So I covered this line.

00:21:24.740 --> 00:21:28.160
This line is also easy to cover
by saying that when W plays 0,

00:21:28.160 --> 00:21:34.720
his payoff just depends
on what Z is doing.

00:21:34.720 --> 00:21:36.390
And it's going to be like this.

00:21:39.950 --> 00:21:42.560
So when W plays 1,
his expected payoff

00:21:42.560 --> 00:21:44.670
is exactly the
probability Z plays 1.

00:21:48.690 --> 00:21:50.380
So what I've written
here is actually

00:21:50.380 --> 00:21:54.355
consistent with some tables
that I'm hiding from this slide.

00:21:57.440 --> 00:22:02.210
So that's, I guess, that's
what I want to write.

00:22:02.210 --> 00:22:06.230
And then similarly, Z is paid
to play the opposite of W.

00:22:06.230 --> 00:22:08.270
What do I mean by that?

00:22:08.270 --> 00:22:13.220
I mean that Z's payoff,
when he plays 0,

00:22:13.220 --> 00:22:17.010
is exactly 1/2, no
matter what W does.

00:22:17.010 --> 00:22:24.070
But if he plays 1, his
payoff is 1 minus W plays 1.

00:22:24.070 --> 00:22:26.420
Which again, you
should be able to see

00:22:26.420 --> 00:22:29.400
that there's a table, a little
table implementing these payoff

00:22:29.400 --> 00:22:31.220
functions.

00:22:31.220 --> 00:22:32.290
And that sounds weird.

00:22:32.290 --> 00:22:33.830
Why did I define it this way?

00:22:33.830 --> 00:22:36.270
Here's my claim.

00:22:36.270 --> 00:22:38.680
In any Nash equilibrium
of a game that

00:22:38.680 --> 00:22:44.470
contains this little
gadget, the probability

00:22:44.470 --> 00:22:46.900
that the output player
plays 1 is basically

00:22:46.900 --> 00:22:49.990
the sum of the probability
that the input players play

00:22:49.990 --> 00:22:54.530
1 thresholded at 1 of course.

00:22:54.530 --> 00:22:57.970
So if this little gadget
that I define here

00:22:57.970 --> 00:23:03.960
is part of a bigger game-- now
what can the bigger game do?

00:23:03.960 --> 00:23:10.090
So it can fit something into
X. It can take the value of Z

00:23:10.090 --> 00:23:13.070
and use it in some other way,
potentially looping around,

00:23:13.070 --> 00:23:18.550
doing anything and once, except
the only inputs to W's payoff

00:23:18.550 --> 00:23:19.860
are X, Y, and Z.

00:23:19.860 --> 00:23:22.890
And the only input
to Z's payoff is W,

00:23:22.890 --> 00:23:26.520
but otherwise the
game can be arbitrary.

00:23:26.520 --> 00:23:28.690
So if this game
that I define here

00:23:28.690 --> 00:23:30.930
is embedded within
a bigger game,

00:23:30.930 --> 00:23:32.930
then in anything Nash
equilibrium of that bigger

00:23:32.930 --> 00:23:36.670
game, the probability
that this guy plays 1

00:23:36.670 --> 00:23:38.800
is exactly the sum
of the probabilities

00:23:38.800 --> 00:23:43.280
that these two guys play
1, thresholded at 1.

00:23:43.280 --> 00:23:44.550
Now how can we see this?

00:23:44.550 --> 00:23:47.740
Why is that true?

00:23:47.740 --> 00:23:50.400
It's a little case analysis.

00:23:50.400 --> 00:23:51.330
It's very simple.

00:23:51.330 --> 00:23:52.290
Let's try to do it.

00:23:58.790 --> 00:24:03.820
So suppose that the
probability that Z plays 1

00:24:03.820 --> 00:24:10.500
is smaller than the probability
X plays 1 plus the probability

00:24:10.500 --> 00:24:13.050
Y plays 1.

00:24:13.050 --> 00:24:17.580
Actually, let's do
something else--

00:24:17.580 --> 00:24:23.560
it's smaller than the
min between this and 1.

00:24:26.200 --> 00:24:27.420
What happens in this case?

00:24:27.420 --> 00:24:31.570
So what happens if Z is smaller
than the minimum of these two

00:24:31.570 --> 00:24:33.880
values?

00:24:33.880 --> 00:24:37.954
What is W going to
do in that case?

00:24:37.954 --> 00:24:39.900
AUDIENCE: Is he going to play 0?

00:24:39.900 --> 00:24:42.940
COSTIS DASKALAKIS: Yeah, because
0 gives him a high payoff,

00:24:42.940 --> 00:24:44.700
gives his a higher
payoff than this guy,

00:24:44.700 --> 00:24:47.550
but because of that condition.

00:24:47.550 --> 00:24:59.159
So this implies that W is going
to play 0 with probability 1.

00:24:59.159 --> 00:25:00.200
Now what does this imply?

00:25:03.230 --> 00:25:07.165
If W plays 0 with probability
1, what does Z do?

00:25:07.165 --> 00:25:08.290
If he plays 0, he gets 0.5.

00:25:08.290 --> 00:25:10.850
What if he plays 1?

00:25:10.850 --> 00:25:13.880
How much does he get?

00:25:13.880 --> 00:25:16.800
He gets 1 because
of that condition.

00:25:19.540 --> 00:25:22.040
So he's going to play what?

00:25:22.040 --> 00:25:22.830
1.

00:25:22.830 --> 00:25:33.380
And so this implies
that-- but how

00:25:33.380 --> 00:25:36.560
can 1 be smaller than the
minimal of 1 and something

00:25:36.560 --> 00:25:37.290
else?

00:25:37.290 --> 00:25:38.550
That's can't be.

00:25:38.550 --> 00:25:42.280
So this is impossible.

00:25:42.280 --> 00:25:46.040
So do the other side,
or maybe you already

00:25:46.040 --> 00:25:47.530
trust me that it's OK.

00:25:55.680 --> 00:25:58.752
Let's try to argue that
this cannot be the case.

00:25:58.752 --> 00:26:00.210
I don't need to do
the mean anymore

00:26:00.210 --> 00:26:03.730
because it can't possibly
be that this guy plays

00:26:03.730 --> 00:26:06.220
more than 1 probability.

00:26:06.220 --> 00:26:09.200
So this is the only case
I want to consider now.

00:26:15.480 --> 00:26:16.720
So what happens in this case?

00:26:19.560 --> 00:26:22.690
The same logic.

00:26:22.690 --> 00:26:24.944
What does W do?

00:26:24.944 --> 00:26:25.890
AUDIENCE: Play 1?

00:26:25.890 --> 00:26:27.848
COSTIS DASKALAKIS: Has
to play 1 because that's

00:26:27.848 --> 00:26:30.690
the better strategy.

00:26:30.690 --> 00:26:33.057
And what does he do?

00:26:33.057 --> 00:26:33.765
AUDIENCE: Play 0.

00:26:36.874 --> 00:26:38.540
COSTIS DASKALAKIS:
But 0 can't be bigger

00:26:38.540 --> 00:26:40.850
than the sum of two
r probabilities,

00:26:40.850 --> 00:26:43.320
so this and that can happen.

00:26:43.320 --> 00:26:47.910
Hence, the only case that's
possible is this one.

00:26:51.460 --> 00:26:53.180
So it's very simple.

00:26:53.180 --> 00:26:55.610
So the only realization
that one had to do

00:26:55.610 --> 00:27:00.330
is that-- where the
arithmetic happens?

00:27:00.330 --> 00:27:02.000
It happens in the
mixed strategies

00:27:02.000 --> 00:27:03.010
chosen by the players.

00:27:03.010 --> 00:27:04.500
That's where it happens.

00:27:11.610 --> 00:27:13.000
So this is the addition gadget.

00:27:13.000 --> 00:27:15.302
Similarly, one can
define other gadgets.

00:27:15.302 --> 00:27:16.760
For example, the
subtraction gadget

00:27:16.760 --> 00:27:21.270
is really, really similar to
this except with one change.

00:27:21.270 --> 00:27:24.540
I replace this
plus with a minus.

00:27:24.540 --> 00:27:26.130
That's the only
change I need to do.

00:27:29.500 --> 00:27:35.430
I'm not sure I want to do
it, but in other words,

00:27:35.430 --> 00:27:41.140
this table-- I only
change this table

00:27:41.140 --> 00:27:47.270
to have 0 here and minus 1 here.

00:27:47.270 --> 00:27:51.210
And I've exactly implemented
that, the subtraction.

00:27:51.210 --> 00:27:53.880
And the proof is
exactly the same.

00:27:53.880 --> 00:27:56.600
You can argue that in any Nash
equilibrium of a game that

00:27:56.600 --> 00:28:00.120
contains this gadget, the
probability that this guy plays

00:28:00.120 --> 00:28:04.330
1 is actually the difference
of the probabilities

00:28:04.330 --> 00:28:09.370
that X plays 1 and Y plays 1,
a probability truncated at 0.

00:28:13.020 --> 00:28:17.040
Any questions about
what taking place here?

00:28:17.040 --> 00:28:20.820
What we're trying to do is we
want take a ArithmCircuitSAT

00:28:20.820 --> 00:28:24.730
instance, and we want to
create a polymatrix game that

00:28:24.730 --> 00:28:27.530
simulates that
circuit SAT instance.

00:28:27.530 --> 00:28:31.660
And what we need for that is
gadgets, so little polymatrix

00:28:31.660 --> 00:28:34.565
games that implement
various operations.

00:28:37.530 --> 00:28:39.800
And I showed you
addition and subtraction.

00:28:39.800 --> 00:28:43.740
But I claim that
you can implement

00:28:43.740 --> 00:28:44.795
a bunch of other gates.

00:28:49.990 --> 00:28:51.790
To have a more
succinct notation,

00:28:51.790 --> 00:28:57.220
I'm going to use probability
that some node plays 1.

00:28:57.220 --> 00:28:59.480
I'm not going to
differentiate that with an X,

00:28:59.480 --> 00:29:02.090
and the probability
that X plays 1.

00:29:02.090 --> 00:29:03.820
With this notation,
I claim that we

00:29:03.820 --> 00:29:07.090
can implement all the gadgets
that we need to simulate

00:29:07.090 --> 00:29:10.220
a circuit SAT instance.

00:29:10.220 --> 00:29:11.765
So let's look at this table.

00:29:11.765 --> 00:29:14.870
So in all these
lines of this table,

00:29:14.870 --> 00:29:18.000
Z is the output
player of the gadget,

00:29:18.000 --> 00:29:20.880
X and Y are the input
players of the gadgets.

00:29:20.880 --> 00:29:22.870
And potentially, the
gadget's implementing

00:29:22.870 --> 00:29:26.110
each of these gates
use auxiliary players.

00:29:26.110 --> 00:29:29.590
Like in the addition case, I was
using one intermediate player.

00:29:29.590 --> 00:29:32.050
He was the auxiliary player.

00:29:32.050 --> 00:29:37.390
And the claim is that you
can implement gadgets such

00:29:37.390 --> 00:29:41.230
that if any of these gadgets
is contained in a bigger

00:29:41.230 --> 00:29:45.820
polymatrix game, then any Nash
equilibrium of these bigger

00:29:45.820 --> 00:29:51.527
polymatrix game
these conditions are

00:29:51.527 --> 00:29:58.700
satisfied by the output and
input players of the gadget.

00:29:58.700 --> 00:30:02.010
And this is as long as you
don't mess up with the gadgets,

00:30:02.010 --> 00:30:06.920
meaning that the bigger
the game can have edges

00:30:06.920 --> 00:30:09.080
into the input players
of the gadgets,

00:30:09.080 --> 00:30:11.490
and edges out of output
players of the gadgets.

00:30:16.220 --> 00:30:18.700
But I claim that you can
implement all of the gadgets

00:30:18.700 --> 00:30:20.160
that you need.

00:30:20.160 --> 00:30:23.710
So in particular, if you have
an instance for ArithmCircuitSAT

00:30:23.710 --> 00:30:26.780
you can create the
polymatrix game

00:30:26.780 --> 00:30:34.350
by composing gadgets
for each of these gates,

00:30:34.350 --> 00:30:38.280
so that at any Nash
equilibrium of polymatrix game,

00:30:38.280 --> 00:30:42.060
all gates conditions
are satisfied.

00:30:42.060 --> 00:30:47.430
So in particular, you are--
by finding a Nash equilibrium

00:30:47.430 --> 00:30:50.140
of this game, you are
solving the instance

00:30:50.140 --> 00:30:54.140
of ArithmCircuitSAT
you started with.

00:30:54.140 --> 00:30:56.300
So that's the idea.

00:30:56.300 --> 00:31:02.590
Any questions about what
happened so far in the lecture?

00:31:02.590 --> 00:31:08.150
Questions about this deduction,
or how the gadgets work?

00:31:08.150 --> 00:31:08.650
Yeah?

00:31:08.650 --> 00:31:10.233
AUDIENCE: Does this
give a valid proof

00:31:10.233 --> 00:31:13.130
that every instance
of ArithmCircuitSAT

00:31:13.130 --> 00:31:14.370
has a satisfying ascendant?

00:31:14.370 --> 00:31:16.810
COSTIS DASKALAKIS:
Yeah, that's correct.

00:31:16.810 --> 00:31:18.550
Because this is a game.

00:31:18.550 --> 00:31:21.230
Some by Nash's theorem,
there is a Nash equilibrium.

00:31:21.230 --> 00:31:24.240
Hence, there is a
solution to that.

00:31:24.240 --> 00:31:27.676
Because a Nash equilibrium
is a solution to that.

00:31:27.676 --> 00:31:28.550
That's exactly right.

00:31:28.550 --> 00:31:30.200
Actually that's how we get it.

00:31:33.830 --> 00:31:36.000
One thing that's
not exactly obvious,

00:31:36.000 --> 00:31:39.490
but you can argue that it's
true is that actually not only

00:31:39.490 --> 00:31:40.990
there's always a
solution, but there

00:31:40.990 --> 00:31:44.480
is a solution in
irrational numbers

00:31:44.480 --> 00:31:47.860
with polynomial description
complexity in the input size.

00:31:47.860 --> 00:31:53.430
So that requires some linear
programming techniques.

00:31:53.430 --> 00:31:55.840
But that's also use it to show.

00:31:55.840 --> 00:31:58.250
A priori, Nash's
theorem will give you

00:31:58.250 --> 00:31:59.470
that any solution exists.

00:31:59.470 --> 00:32:01.910
It wouldn't give guarantees
about the description

00:32:01.910 --> 00:32:03.620
complexity of that solution.

00:32:03.620 --> 00:32:05.060
But using linear
programming, you

00:32:05.060 --> 00:32:07.350
can argue that there's
always a rational solution

00:32:07.350 --> 00:32:10.332
with polynomial
description complexity.

00:32:10.332 --> 00:32:12.415
Are you interested in
seeing any of these gadgets?

00:32:16.230 --> 00:32:17.590
I've only shown addition.

00:32:17.590 --> 00:32:19.310
Do you want to
see anything else?

00:32:19.310 --> 00:32:21.450
Do you believe me that
I can actually do that?

00:32:21.450 --> 00:32:23.260
AUDIENCE: The
comparison one that

00:32:23.260 --> 00:32:27.290
has arbitrary output
for a certain conditions

00:32:27.290 --> 00:32:28.680
seems interesting.

00:32:28.680 --> 00:32:31.229
COSTIS DASKALAKIS:
OK, I can show that.

00:32:31.229 --> 00:32:33.020
So let me try to do
the comparison gadgets.

00:32:33.020 --> 00:32:35.103
They're actually simpler
than the addition gadget.

00:32:39.560 --> 00:32:41.560
So I want to implement
a comparison.

00:32:41.560 --> 00:32:46.540
So I'm only going to have the
input players and the output

00:32:46.540 --> 00:32:48.880
player.

00:32:48.880 --> 00:32:55.090
And the payoffs of the output
player are-- let's see.

00:32:57.900 --> 00:33:00.010
So if you play 0,
then his payoff

00:33:00.010 --> 00:33:07.070
is only depends on the
X. And it looks like is.

00:33:07.070 --> 00:33:13.090
If he plays 1, let's
see if it works.

00:33:13.090 --> 00:33:17.520
I haven't prepared this but
it's easy to figure this out.

00:33:17.520 --> 00:33:21.140
Worse case, I'll back track.

00:33:21.140 --> 00:33:26.490
So now what I want to argue
is that-- let's bring up

00:33:26.490 --> 00:33:28.090
the conditions that
I need to satisfy.

00:33:32.150 --> 00:33:34.470
So I want to satisfy
those conditions.

00:33:34.470 --> 00:33:36.460
So let's see if I do
satisfy these conditions.

00:33:36.460 --> 00:33:39.640
So I messed it up a
little bit, I guess.

00:33:39.640 --> 00:33:45.985
So I have to replace
X here and Y here.

00:33:48.560 --> 00:33:50.080
Now let's see if that's true.

00:33:50.080 --> 00:33:59.760
So I claim that if probability
x is bigger than probability y,

00:33:59.760 --> 00:34:04.720
then what do I prefer to play?

00:34:04.720 --> 00:34:05.810
I'm prefer to play 0.

00:34:12.440 --> 00:34:15.219
Similarly for the other
case, when they're equal,

00:34:15.219 --> 00:34:18.290
anything is possible.

00:34:18.290 --> 00:34:20.460
It's that's simple.

00:34:20.460 --> 00:34:22.070
There's not [INAUDIBLE]
going on here.

00:34:26.111 --> 00:34:26.610
Cool.

00:34:26.610 --> 00:34:30.920
So I've established
that this direction,

00:34:30.920 --> 00:34:32.620
this part of the direction.

00:34:32.620 --> 00:34:36.190
Now I want to go down
from a polymatrix game

00:34:36.190 --> 00:34:37.760
to a two-player game.

00:34:42.820 --> 00:34:45.000
That's the next
part of the lecture.

00:34:45.000 --> 00:34:48.139
How do you go down
to two players?

00:34:48.139 --> 00:34:58.170
Well the first thing to
note is that all the gates

00:34:58.170 --> 00:35:02.600
can be implemented
with bipartite graphs.

00:35:02.600 --> 00:35:10.390
So if you remember
my addition gadget,

00:35:10.390 --> 00:35:13.710
it had the input and
the output players

00:35:13.710 --> 00:35:17.430
on one side and the
auxiliary player on one side.

00:35:17.430 --> 00:35:20.000
My comparison gadget does
not satisfy this probability

00:35:20.000 --> 00:35:22.000
because the input players
and the output players

00:35:22.000 --> 00:35:23.467
are on different sides.

00:35:23.467 --> 00:35:25.800
But I claim that you can
implement actually a comparison

00:35:25.800 --> 00:35:30.150
by adding an X and an additional
step with a bipartite graph.

00:35:30.150 --> 00:35:32.900
So I claim that all
gates can be implemented

00:35:32.900 --> 00:35:36.400
with polymatrix games
that have input and output

00:35:36.400 --> 00:35:41.680
players on one side,
and auxiliary vertices

00:35:41.680 --> 00:35:43.280
on the other side.

00:35:43.280 --> 00:35:49.871
So I claim that all my gadgets
are actually bipartite.

00:35:49.871 --> 00:35:51.620
So in particularly, I
can color this graph

00:35:51.620 --> 00:35:54.730
with two colors, blue and red.

00:35:54.730 --> 00:35:59.850
And what I want to do is I want
to create these super players.

00:35:59.850 --> 00:36:01.880
I'm going to call the lawyers.

00:36:01.880 --> 00:36:08.100
I'm going to have a red
lawyer and a blue lawyer.

00:36:08.100 --> 00:36:11.150
And the red player is going to
represent all the nodes that

00:36:11.150 --> 00:36:14.940
are colored red in here,
while the blue lawyer is going

00:36:14.940 --> 00:36:16.810
to represent all blue nodes.

00:36:19.360 --> 00:36:23.330
And what I want to do is I
want to define the lawyer

00:36:23.330 --> 00:36:24.310
game in the next slide.

00:36:27.120 --> 00:36:29.460
So every lawyer,
so the red lawyer,

00:36:29.460 --> 00:36:35.240
his strategy set is the union,
not the product, the union.

00:36:35.240 --> 00:36:37.040
That's important,
otherwise my deduction

00:36:37.040 --> 00:36:38.990
would be exponentially large.

00:36:38.990 --> 00:36:41.380
My induction wouldn't
be a polynomial.

00:36:41.380 --> 00:36:44.400
So as a lawyer, and
that poses actually

00:36:44.400 --> 00:36:45.967
technicalities in
the construction

00:36:45.967 --> 00:36:47.050
that I'm about to present.

00:36:47.050 --> 00:36:51.310
But every lawyer will have a
strategy set, a pure strategy

00:36:51.310 --> 00:36:55.990
set, the union of the pure
strategy sets of the clients

00:36:55.990 --> 00:36:57.010
that he represents.

00:36:57.010 --> 00:36:59.700
So the red lawyer
has one strategy

00:36:59.700 --> 00:37:04.830
for every strategy
of every red nodes.

00:37:04.830 --> 00:37:07.820
The blue lawyer has one
strategy for every strategy

00:37:07.820 --> 00:37:09.150
of every blue node.

00:37:11.912 --> 00:37:13.620
Now what I want to do
is I want to define

00:37:13.620 --> 00:37:16.190
the payoffs in the lower game.

00:37:16.190 --> 00:37:18.400
What are the payoffs
in the lower game?

00:37:18.400 --> 00:37:21.200
Well, what happens
if the red lawyer

00:37:21.200 --> 00:37:27.680
decides to play strategy
i or red client U?

00:37:27.680 --> 00:37:31.860
And what if the
blue lawyer plays

00:37:31.860 --> 00:37:34.840
strategy j of blue node v?

00:37:34.840 --> 00:37:36.990
What are the payoffs
of the two lawyers

00:37:36.990 --> 00:37:40.450
in that choice of strategies?

00:37:40.450 --> 00:37:43.500
Well, it's going to be exactly
the corresponding payoffs

00:37:43.500 --> 00:37:48.920
of the nodes of the
polymatrix game.

00:37:48.920 --> 00:37:51.750
So the red lawyer
will the payoff

00:37:51.750 --> 00:37:56.990
that U would have gotten
in the polymatrix game

00:37:56.990 --> 00:38:00.410
if these two players
played i and j.

00:38:00.410 --> 00:38:03.010
And the blue
lawyer's going to get

00:38:03.010 --> 00:38:05.980
his client's value,
so v's value,

00:38:05.980 --> 00:38:09.070
under the same
choice of strategies.

00:38:09.070 --> 00:38:12.780
So in particularly, if there's
no edge between those two nodes

00:38:12.780 --> 00:38:16.450
that blue and red
lawyers chose to play,

00:38:16.450 --> 00:38:18.800
then nobody gets anything.

00:38:18.800 --> 00:38:22.390
The payoff here
is going to be 0.

00:38:22.390 --> 00:38:27.730
And if there is a
directed edge from V to U,

00:38:27.730 --> 00:38:31.120
then this is going
to be 0, and that's

00:38:31.120 --> 00:38:33.190
whatever it is, and vice versa.

00:38:33.190 --> 00:38:35.686
But you get the idea.

00:38:35.686 --> 00:38:38.880
If the blue lawyer decides
to represent a client,

00:38:38.880 --> 00:38:42.950
and the red lawyer decides
to represent another client,

00:38:42.950 --> 00:38:46.240
then the payoff of the lawyers
are the corresponding payoffs

00:38:46.240 --> 00:38:47.960
that the clients
would have gotten

00:38:47.960 --> 00:38:51.120
had they played the strategies
that the lawyers decided

00:38:51.120 --> 00:38:52.510
to play for them.

00:38:52.510 --> 00:38:55.280
That's the definition
of the lawyer game.

00:38:55.280 --> 00:38:55.890
Is this clear?

00:38:58.810 --> 00:39:04.440
Now the wishful thinking
is that if X and Y

00:39:04.440 --> 00:39:08.290
is a Nash equilibrium
of the lawyer game,

00:39:08.290 --> 00:39:16.100
then if I look at the marginal
probability distributions

00:39:16.100 --> 00:39:20.650
on the different nodes,
on the different clients

00:39:20.650 --> 00:39:23.570
by their lawyer, then
this marginal probability

00:39:23.570 --> 00:39:25.775
distribution are a
Nash equilibrium.

00:39:28.830 --> 00:39:32.380
So the wishful
thinking is that if I

00:39:32.380 --> 00:39:34.920
start with a Nash equilibrium
of the lawyer game,

00:39:34.920 --> 00:39:38.340
then if I look at
the distribution

00:39:38.340 --> 00:39:42.580
that the red lawyer,
the marginal probability

00:39:42.580 --> 00:39:47.980
distribution that the red
lawyer places on every red node

00:39:47.980 --> 00:39:50.770
separately, and the
marginal probability

00:39:50.770 --> 00:39:53.590
distributions that the
blue lawyer places on

00:39:53.590 --> 00:39:56.200
all blue node separately,
so all this collection

00:39:56.200 --> 00:39:59.170
of marginal probability
distributions,

00:39:59.170 --> 00:40:02.290
that this collection is a Nash
equilibrium of the polymatrix

00:40:02.290 --> 00:40:03.344
game.

00:40:03.344 --> 00:40:04.510
That's the wishful thinking.

00:40:10.380 --> 00:40:12.340
Questions about what
the wishful thinking is?

00:40:17.450 --> 00:40:18.950
Of course, this is
wishful thinking

00:40:18.950 --> 00:40:21.800
because we know
how lawyers behave.

00:40:21.800 --> 00:40:24.185
They only represent
the lucrative clients.

00:40:26.920 --> 00:40:33.440
There's no reason that the red
lawyer would have incentive

00:40:33.440 --> 00:40:41.010
to choose at least some strategy
to place positive probability

00:40:41.010 --> 00:40:43.350
mass on every node
he represents.

00:40:43.350 --> 00:40:47.210
Maybe in the Nash equilibrium
of this lawyer game,

00:40:47.210 --> 00:40:48.910
some of these
marginal distributions

00:40:48.910 --> 00:40:52.800
are actually undefined
because the lawyers-- are ill

00:40:52.800 --> 00:40:55.330
defined because the
lawyers place 0 probability

00:40:55.330 --> 00:40:59.440
mass on the strategies
of those nodes.

00:40:59.440 --> 00:41:01.990
So that wishful thinking
isn't going through.

00:41:01.990 --> 00:41:03.590
But there is some truth to that.

00:41:03.590 --> 00:41:05.290
So there is a way to fix it.

00:41:05.290 --> 00:41:09.150
So here's how we're going
to fix the lawyer game.

00:41:09.150 --> 00:41:11.220
So we know what lawyers like.

00:41:11.220 --> 00:41:13.250
They like money.

00:41:13.250 --> 00:41:15.600
So we're going to define
a high stakes game.

00:41:17.926 --> 00:41:19.300
But the lawyers
are going to play

00:41:19.300 --> 00:41:23.230
on the side at the same
time as the actual game

00:41:23.230 --> 00:41:25.160
that we're interested in.

00:41:25.160 --> 00:41:28.570
So for a lot of cash-- so those
are the stakes of that game.

00:41:30.857 --> 00:41:32.190
We're going to do the following.

00:41:32.190 --> 00:41:35.200
So some terminology first.

00:41:35.200 --> 00:41:37.310
So suppose that we had
lots of generalities.

00:41:37.310 --> 00:41:40.550
Suppose that every lawyer
has n clients he represents.

00:41:43.370 --> 00:41:46.000
And let's label the
red lawyer's clients

00:41:46.000 --> 00:41:49.690
1 through n, and the blue
lawyer's clients 1 through n.

00:41:49.690 --> 00:41:52.500
If you know one of the two
lawyers have fewer clients,

00:41:52.500 --> 00:41:55.960
then we can pad this
with dummy players

00:41:55.960 --> 00:42:02.000
and that doesn't change the
polymatrix game's equilibria.

00:42:02.000 --> 00:42:05.970
So suppose that both lawyers
represent the same number

00:42:05.970 --> 00:42:07.840
of players, clients.

00:42:07.840 --> 00:42:11.970
And let's label both lawyers'
clients one through n,

00:42:11.970 --> 00:42:13.080
in an arbitrary way.

00:42:17.600 --> 00:42:20.770
The strategies of
the high stakes game

00:42:20.770 --> 00:42:23.050
are exactly the same as
the strategies of the game

00:42:23.050 --> 00:42:24.320
that I showed in
the previous slide.

00:42:24.320 --> 00:42:25.695
In particular,
the red lawyer has

00:42:25.695 --> 00:42:28.660
the union of the
strategies of blue nodes.

00:42:28.660 --> 00:42:31.530
And red lawyer has the
union of the strategies

00:42:31.530 --> 00:42:33.400
of the red nodes.

00:42:33.400 --> 00:42:36.910
Now what's the high stakes game?

00:42:36.910 --> 00:42:40.840
Suppose that the red player
plays any strategy of client j,

00:42:40.840 --> 00:42:44.310
and the blue lawyer play
any strategy of client k.

00:42:44.310 --> 00:42:50.570
Then if they choose
different clients,

00:42:50.570 --> 00:42:53.100
they both get 0 dollars.

00:42:53.100 --> 00:42:57.060
But if they choose the
same client-- I mean,

00:42:57.060 --> 00:42:59.730
it's not the same client, it's
the same label of a client

00:42:59.730 --> 00:43:02.090
because they each represent
different clients.

00:43:02.090 --> 00:43:06.690
But if they choose different
labels, then they both get 0.

00:43:06.690 --> 00:43:11.830
If the choose the same
label, whoever it was,

00:43:11.830 --> 00:43:15.950
the red lawyer
gets a lot of cash,

00:43:15.950 --> 00:43:19.070
and that blue lawyer
loses a lot of cash.

00:43:23.810 --> 00:43:29.520
Again, so this game has the same
strategies as the lawyer game

00:43:29.520 --> 00:43:31.960
that I showed in
the previous slide.

00:43:31.960 --> 00:43:34.810
Except now in this game,
all the lawyers care

00:43:34.810 --> 00:43:40.160
about is the labels
of the clients

00:43:40.160 --> 00:43:42.680
whose strategies they choose.

00:43:42.680 --> 00:43:48.640
So if they choose a
strategy of a client that

00:43:48.640 --> 00:43:53.060
has the same label, then the
red lawyer gains a lot of money,

00:43:53.060 --> 00:43:54.820
and the blue lawyer
lose a lot of money.

00:43:54.820 --> 00:43:58.440
But if they choose strategies of
clients with different labels,

00:43:58.440 --> 00:44:01.700
then they both get 0.

00:44:01.700 --> 00:44:04.740
In other words in some
sense, the blue lawyer

00:44:04.740 --> 00:44:08.300
is trying to avoid
the red lawyer,

00:44:08.300 --> 00:44:13.810
and the red lawyer is trying
to catch the blue lawyer.

00:44:13.810 --> 00:44:16.330
So now this is a
simple 0 sum game.

00:44:16.330 --> 00:44:19.270
And it's not hard to
see that in any Nash

00:44:19.270 --> 00:44:28.620
equilibrium of this
game, the lawyers are

00:44:28.620 --> 00:44:34.190
going to represent every client
with the same probability.

00:44:34.190 --> 00:44:37.830
So each lawyer
assigns a probability

00:44:37.830 --> 00:44:42.500
exactly 1/n to the
set of his strategies

00:44:42.500 --> 00:44:46.360
corresponding to
each of his clients.

00:44:46.360 --> 00:44:48.240
So the high stakes
game has the property

00:44:48.240 --> 00:44:53.160
that the lawyers represent
all their clients

00:44:53.160 --> 00:44:55.430
with the same
probability distribution,

00:44:55.430 --> 00:44:57.750
and you can divide the
probability distribution

00:44:57.750 --> 00:45:01.590
in an arbitrary way within
the strategies of each

00:45:01.590 --> 00:45:03.770
of their clients in this game.

00:45:06.500 --> 00:45:10.840
That's easy to see just by the
symmetry of this games, that

00:45:10.840 --> 00:45:12.790
has to be true.

00:45:12.790 --> 00:45:18.310
And with these two
definitions, the game

00:45:18.310 --> 00:45:21.310
that I'm going to do for my
reduction from polymatrix games

00:45:21.310 --> 00:45:26.610
to two player games is going to
be the sum of these two games.

00:45:26.610 --> 00:45:30.200
So this is the game
that I defined earlier.

00:45:30.200 --> 00:45:33.230
And this matrix
is a block matrix.

00:45:33.230 --> 00:45:38.070
So this is a block of strategies
corresponding to-- this matrix

00:45:38.070 --> 00:45:45.410
is a matrix that is a constant
matrix where everything is big.

00:45:45.410 --> 00:45:48.940
And this block
corresponds to-- these

00:45:48.940 --> 00:45:50.830
are the strategies
of client with label

00:45:50.830 --> 00:45:52.520
1 for the red lawyer.

00:45:52.520 --> 00:45:58.520
And this is the
strategies of the client

00:45:58.520 --> 00:46:01.290
of the blue lawyer with
label 1, and so on so forth.

00:46:01.290 --> 00:46:03.380
So this is a block matrix.

00:46:03.380 --> 00:46:09.730
And there are ms and minus
ms in this diagonal blocks,

00:46:09.730 --> 00:46:11.960
and everything else is 0.

00:46:11.960 --> 00:46:13.560
So that's the high stakes game.

00:46:13.560 --> 00:46:17.940
It's played along
blocks of strategies

00:46:17.940 --> 00:46:20.830
because all I care of
is the label the client

00:46:20.830 --> 00:46:24.370
I'm choosing for each
of these lawyers.

00:46:24.370 --> 00:46:26.480
Well, this is a more
fine-grained game,

00:46:26.480 --> 00:46:29.490
where I not only care about
which clients and choosing,

00:46:29.490 --> 00:46:32.440
but also which strategies of
these clients I'm choosing.

00:46:32.440 --> 00:46:37.290
And I'm going to choose
an m that overwhelms

00:46:37.290 --> 00:46:38.510
the payoffs in this games.

00:46:38.510 --> 00:46:41.470
So this condition is OK
for what I'm about to say.

00:46:41.470 --> 00:46:45.650
But think of m as huge
compared to the maximum utility

00:46:45.650 --> 00:46:49.440
in this game times the number
of clients in that game.

00:46:52.902 --> 00:46:55.360
AUDIENCE: Just to make sure
I'm understanding this so far--

00:46:55.360 --> 00:46:59.365
so in the naive game,
if the red guy chooses

00:46:59.365 --> 00:47:01.240
strategy and the blue
guys chooses a strategy

00:47:01.240 --> 00:47:02.781
and the two vertices
they choose from

00:47:02.781 --> 00:47:05.230
are not connected by an
edge, then they both get 0.

00:47:05.230 --> 00:47:07.680
COSTIS DASKALAKIS: Yeah.

00:47:07.680 --> 00:47:10.110
And if they're connected,
they get payoffs

00:47:10.110 --> 00:47:12.161
that the corresponding
nodes would have gotten--

00:47:12.161 --> 00:47:13.660
AUDIENCE: [INAUDIBLE]
vertical edge,

00:47:13.660 --> 00:47:16.801
one is the one on the outgoing
vertex will still get 0.

00:47:16.801 --> 00:47:18.176
COSTIS DASKALAKIS:
Exactly, yeah.

00:47:23.290 --> 00:47:24.800
Any other questions
about-- yeah?

00:47:24.800 --> 00:47:26.955
AUDIENCE: Even with a
really large choice of m,

00:47:26.955 --> 00:47:29.771
can't it still mess up
the values a little bit?

00:47:29.771 --> 00:47:30.770
COSTIS DASKALAKIS: Yeah.

00:47:30.770 --> 00:47:32.430
It will mess it up a little bit.

00:47:32.430 --> 00:47:34.280
So the Nash equilibrium
of this game,

00:47:34.280 --> 00:47:36.620
the addition of these
two games, is not

00:47:36.620 --> 00:47:39.227
going to have the property
that this game by itself had.

00:47:39.227 --> 00:47:40.560
But it's going to be very close.

00:47:40.560 --> 00:47:42.892
And I'm going to be
specific about it.

00:47:42.892 --> 00:47:46.910
AUDIENCE: So the choice of me
is so that the isn't that big.

00:47:46.910 --> 00:47:48.910
COSTIS DASKALAKIS: Even
for arbitrarily large m,

00:47:48.910 --> 00:47:53.230
I can't actually quite show
that the lawyers represent

00:47:53.230 --> 00:47:54.690
their clients exactly equally.

00:47:54.690 --> 00:47:56.060
But I can bring it close.

00:47:56.060 --> 00:47:58.990
And the larger m is
the closer the come.

00:47:58.990 --> 00:48:01.610
In particular, I can show
the following statement

00:48:01.610 --> 00:48:08.540
that in any Nash equilibrium
of the combined game, if X used

00:48:08.540 --> 00:48:12.700
the total mass that
the red lawyer places

00:48:12.700 --> 00:48:19.630
on the union of strategies of
node U, then that's about 1/m.

00:48:19.630 --> 00:48:23.760
But there is the matter that's
the case with m, and similarly

00:48:23.760 --> 00:48:26.810
for the blue lawyer.

00:48:26.810 --> 00:48:32.160
So approximately they're
representing all their clients.

00:48:32.160 --> 00:48:36.270
And if I choose m huge
then at least my marginals

00:48:36.270 --> 00:48:37.970
are well-defined now.

00:48:37.970 --> 00:48:41.960
So there is probability
mass on every client

00:48:41.960 --> 00:48:44.640
and I can define these
marginal distributions.

00:48:44.640 --> 00:48:47.130
Now whether these distributions
are useful or not,

00:48:47.130 --> 00:48:49.690
we are about to see.

00:48:49.690 --> 00:48:54.820
But what I'm saying here
is that as far as deciding

00:48:54.820 --> 00:48:59.760
how to split the
pie into my clients,

00:48:59.760 --> 00:49:01.950
really the large
game is what matters.

00:49:01.950 --> 00:49:03.560
The high stakes game
is what matters.

00:49:03.560 --> 00:49:09.230
Because if I make a mistake, m
is huge, some huge [INAUDIBLE].

00:49:09.230 --> 00:49:11.850
So for splitting,
for deciding how

00:49:11.850 --> 00:49:15.490
to split my total unit
of probability mass

00:49:15.490 --> 00:49:19.290
into my clients, only the high
stakes game-- essentially,

00:49:19.290 --> 00:49:22.610
only the high
stakes games matter.

00:49:22.610 --> 00:49:30.350
On the other hand, when it comes
to having decided how much mass

00:49:30.350 --> 00:49:33.800
to put on the unit of a
particular node strategies,

00:49:33.800 --> 00:49:38.900
deciding about the fine-grained
decision of how to allocate

00:49:38.900 --> 00:49:47.570
that Xu into the different
strategies on that node U, then

00:49:47.570 --> 00:49:50.790
actually only the
small game matters.

00:49:50.790 --> 00:49:53.500
And the reason is
that the payoff

00:49:53.500 --> 00:50:01.030
different of the red lawyer
from strategies Ui and Uj--

00:50:01.030 --> 00:50:04.790
so to distinguishes
between strategies

00:50:04.790 --> 00:50:09.950
i and j of node U, the payoff
difference between these two

00:50:09.950 --> 00:50:13.450
choices doesn't have m in it.

00:50:13.450 --> 00:50:17.250
If you actually look
at it, m goes away.

00:50:17.250 --> 00:50:22.100
There's no m in the payoff
difference between these two

00:50:22.100 --> 00:50:24.000
options.

00:50:24.000 --> 00:50:29.126
So which one is better
doesn't have m in it,

00:50:29.126 --> 00:50:30.500
essentially doesn't
have m in it.

00:50:30.500 --> 00:50:35.940
There is some m in
here because this I'm

00:50:35.940 --> 00:50:39.330
summing over all nodes,
and different nodes

00:50:39.330 --> 00:50:46.790
have different sum
of probabilities.

00:50:46.790 --> 00:50:50.940
But I'm going to get to that.

00:50:50.940 --> 00:50:56.460
But trust me that when
the red lawyer is trying

00:50:56.460 --> 00:51:03.820
to decide how to allocate this
Xu probability that he has

00:51:03.820 --> 00:51:07.600
decided to allocate
on the difference

00:51:07.600 --> 00:51:11.454
strategies of node U, he looks
at this difference, that's

00:51:11.454 --> 00:51:12.870
the difference in
the two payoffs.

00:51:12.870 --> 00:51:15.360
And essentially there's
no m in this equation.

00:51:15.360 --> 00:51:20.239
So we're going to see when m
gets into the picture and why.

00:51:20.239 --> 00:51:22.280
But this is just from the
definition of the game.

00:51:22.280 --> 00:51:23.920
Again, this is exactly true.

00:51:23.920 --> 00:51:26.080
The difference of the two
payoff is exactly this.

00:51:28.850 --> 00:51:34.530
Now from that
equation, it follows

00:51:34.530 --> 00:51:37.840
that if they lawyer decides
to put positive probability

00:51:37.840 --> 00:51:43.930
mass on a particular strategy i
of that node, then for all js,

00:51:43.930 --> 00:51:47.070
for all alternative
strategies of that node

00:51:47.070 --> 00:51:49.960
that he could choose, it
better be that this payoff

00:51:49.960 --> 00:51:52.690
difference is positive.

00:51:52.690 --> 00:51:57.060
And that really, really looks
like the condition of the Nash

00:51:57.060 --> 00:52:01.690
equilibrium conditions for the
client, if you think about it.

00:52:01.690 --> 00:52:08.820
Because if I define the
marginal probabilities

00:52:08.820 --> 00:52:11.190
of node U on these
two strategies,

00:52:11.190 --> 00:52:17.610
on these strategies, then this
is really the Nash equilibrium

00:52:17.610 --> 00:52:23.980
condition for that node
U. The only problem

00:52:23.980 --> 00:52:29.540
is to go from this equation
for the unmarginalized

00:52:29.540 --> 00:52:34.690
probabilities Vy,
Vl's, to the marginals.

00:52:34.690 --> 00:52:37.150
I'm dividing with something,
and that something

00:52:37.150 --> 00:52:39.880
is an equal for all these.

00:52:39.880 --> 00:52:42.810
So if it was equal,
then these marginals

00:52:42.810 --> 00:52:45.440
would actually be
directly Nash equilibrium.

00:52:45.440 --> 00:52:49.510
Because this condition I
could just divide by 1/n,

00:52:49.510 --> 00:52:52.180
and this would be made
marginal probability.

00:52:52.180 --> 00:52:54.480
And that's exactly the
equilibrium condition

00:52:54.480 --> 00:52:56.590
for the client U.

00:52:56.590 --> 00:53:00.930
The problem is that these
Xvs are not all equal.

00:53:00.930 --> 00:53:03.180
Yvs are not equal.

00:53:03.180 --> 00:53:06.780
So I cannot just divide by 1/n
and claim that the equation is

00:53:06.780 --> 00:53:09.120
still true.

00:53:09.120 --> 00:53:13.010
But the point is that
this error doesn't

00:53:13.010 --> 00:53:17.180
create too much problems in
the equilibrium conditions.

00:53:17.180 --> 00:53:19.260
And OK, it's not going
to be an exact Nash

00:53:19.260 --> 00:53:21.480
equilibrium for the
polymatrix game,

00:53:21.480 --> 00:53:24.050
but it's going to be
an approximate one.

00:53:24.050 --> 00:53:28.500
And because I can take n
to be as large as I want,

00:53:28.500 --> 00:53:33.830
I can make this approximation
go to 0 as fast as I want.

00:53:33.830 --> 00:53:37.350
And remember this
ArithmCircuitSAT problem

00:53:37.350 --> 00:53:39.617
allowed some error in it.

00:53:39.617 --> 00:53:41.200
So what effectively
is going to happen

00:53:41.200 --> 00:53:44.830
here is that I'm going to get
an approximate equilibrium

00:53:44.830 --> 00:53:45.810
of the polymatrix game.

00:53:45.810 --> 00:53:47.980
So that would correspond to
an approximate equilibrium

00:53:47.980 --> 00:53:49.854
of the arithmetic SAT
problem I started with.

00:53:49.854 --> 00:53:52.070
But this approximation
can back accommodated,

00:53:52.070 --> 00:53:55.140
and the problem is to PPAD hard.

00:53:55.140 --> 00:53:57.470
So that's approximately
how the argument works.

00:54:02.420 --> 00:54:05.310
The fact that the
disagreements aren't uniform

00:54:05.310 --> 00:54:09.230
doesn't really matter as long
as n is chosen large enough.

00:54:11.770 --> 00:54:14.280
I went a bit too fast.

00:54:14.280 --> 00:54:18.240
I didn't mean for this
to be very detailed.

00:54:18.240 --> 00:54:22.210
But I meant to convey
the bigger picture.

00:54:22.210 --> 00:54:23.910
And the bigger
picture basically says

00:54:23.910 --> 00:54:26.160
that you can analyze what
happens in this lower

00:54:26.160 --> 00:54:28.460
game in two steps.

00:54:28.460 --> 00:54:31.930
In one step, you argue that
the lawyers approximately

00:54:31.930 --> 00:54:34.680
represent all their clients.

00:54:34.680 --> 00:54:36.810
In the other step,
you have to decide

00:54:36.810 --> 00:54:44.060
how these lawyers allocate
their probabilities

00:54:44.060 --> 00:54:47.840
to the different strategies
of a particular node.

00:54:47.840 --> 00:54:51.910
That leads you to write down
this difference of payoffs

00:54:51.910 --> 00:54:56.720
that the lawyer is
experiencing when he switches.

00:54:56.720 --> 00:54:59.500
This is tracking how much
better the expected payoff

00:54:59.500 --> 00:55:04.150
from this strategies is
compared to that strategy.

00:55:04.150 --> 00:55:07.210
And by the equilibrium
conditions of the lawyer game,

00:55:07.210 --> 00:55:11.040
you get the inequality I
showed in the next slide

00:55:11.040 --> 00:55:15.660
that if the lawyer decides
to place positive probability

00:55:15.660 --> 00:55:18.980
mass to a strategy
i of node U, then it

00:55:18.980 --> 00:55:24.236
must be that there is no
alternative strategy, Uj,

00:55:24.236 --> 00:55:25.860
that would give them
the better payoff,

00:55:25.860 --> 00:55:28.250
so you get this condition.

00:55:28.250 --> 00:55:32.730
And that's essentially
the equilibrium condition

00:55:32.730 --> 00:55:35.550
for the polymatrix
game, except that you

00:55:35.550 --> 00:55:37.720
need to normalize these guy.

00:55:37.720 --> 00:55:40.080
And when you try to
normalize these guy,

00:55:40.080 --> 00:55:43.850
you run into the
problem that the lawyers

00:55:43.850 --> 00:55:48.330
don't play uniform
strategies for their clients.

00:55:48.330 --> 00:55:51.540
But they play approximate
uniform distribution

00:55:51.540 --> 00:55:52.810
of their clients.

00:55:52.810 --> 00:55:56.190
So this inequality gets
messed up a little bit.

00:55:56.190 --> 00:55:58.320
So effectively that
means that the players

00:55:58.320 --> 00:56:01.490
are almost best responding.

00:56:01.490 --> 00:56:04.052
The marginal distributions on
an approximate Nash equilibrium

00:56:04.052 --> 00:56:05.010
of the polymatrix game.

00:56:07.680 --> 00:56:12.090
Also because the polymatrix game
came from my ArithmCircuitSAT

00:56:12.090 --> 00:56:14.640
problem, an approximate
evaluation of that problem.

00:56:14.640 --> 00:56:18.670
But theses are all PPAD hard,
as I pointed out earlier.

00:56:18.670 --> 00:56:21.340
That's the high level idea.

00:56:21.340 --> 00:56:24.270
And trust me, the details
are not hard at all.

00:56:24.270 --> 00:56:24.770
OK

00:56:24.770 --> 00:56:32.850
So you just have to trust me
that the approximate uniform

00:56:32.850 --> 00:56:34.990
distribution of
the claim are true

00:56:34.990 --> 00:56:41.200
and that dividing by
approximately 1/n here

00:56:41.200 --> 00:56:43.458
doesn't mess up this
condition too much.

00:56:46.390 --> 00:56:48.940
So this was the end of
the proof basically.

00:56:48.940 --> 00:56:51.520
That's basically
how the proof goes.

00:56:51.520 --> 00:56:56.780
So if have this,
it's easy to do this,

00:56:56.780 --> 00:56:58.220
and then it's easy to go here.

00:57:00.942 --> 00:57:03.377
Any questions?

00:57:03.377 --> 00:57:04.960
Now the reduction I
showed you was not

00:57:04.960 --> 00:57:06.150
from the original paper.

00:57:06.150 --> 00:57:11.690
It was established by a follow
up paper by Chen and Deng.

00:57:11.690 --> 00:57:15.490
In that original paper, we
actually took this problem

00:57:15.490 --> 00:57:16.900
in reduced to 4-player Nash.

00:57:20.530 --> 00:57:23.152
The proof is identical
to the one I showed you.

00:57:23.152 --> 00:57:25.610
The only reason that we went
to four players instead of two

00:57:25.610 --> 00:57:31.330
players is that our gadgets
were four-partite instead

00:57:31.330 --> 00:57:32.260
of bipartite.

00:57:32.260 --> 00:57:35.520
So we had four colors
and four lawyers.

00:57:35.520 --> 00:57:38.900
Now why did we have
four-partite gadgets?

00:57:38.900 --> 00:57:42.150
Well, we were being a bit silly.

00:57:42.150 --> 00:57:44.500
We had in our
arithmetic circuit,

00:57:44.500 --> 00:57:47.540
we had an extra gate,
which plus multiplication,

00:57:47.540 --> 00:57:50.750
not by a constant, but the
multiplication of two numbers.

00:57:50.750 --> 00:57:54.276
And you can show that
this-- but we didn't use it.

00:57:54.276 --> 00:57:56.710
We were being a bit silly.

00:57:56.710 --> 00:58:00.520
We had this gadget here
that we weren't using.

00:58:00.520 --> 00:58:05.300
And it was hard to-- actually
it's impossible to make it

00:58:05.300 --> 00:58:07.980
into a bipartite gadget.

00:58:07.980 --> 00:58:11.890
So in our recent paper, we made
it into a four-partite gadget.

00:58:11.890 --> 00:58:13.570
And then, in the
followup paper we

00:58:13.570 --> 00:58:16.980
actual managed to reduce it
to a three-partite gadget.

00:58:16.980 --> 00:58:19.510
But then this multiplication
gadget actually you can show

00:58:19.510 --> 00:58:22.430
cannot be reduced to bipartite.

00:58:22.430 --> 00:58:24.190
So these guys observed
that actually we

00:58:24.190 --> 00:58:26.660
are not using multiplication.

00:58:26.660 --> 00:58:30.410
So you can implement all
gadgets that we actually

00:58:30.410 --> 00:58:31.980
used with partite graphs.

00:58:31.980 --> 00:58:33.730
So you can go down
to two lawyers

00:58:33.730 --> 00:58:37.190
instead of three lawyers.

00:58:37.190 --> 00:58:41.930
So it felt like leaving money
on the table, but that's OK.

00:58:45.780 --> 00:58:50.451
That's my discussion of
PPAD-completeness of Nash.

00:58:50.451 --> 00:58:50.950
Yeah?

00:58:50.950 --> 00:58:53.150
AUDIENCE: Obviously,
in zero-sum games,

00:58:53.150 --> 00:58:55.890
it's easy to find
an equilibrium.

00:58:55.890 --> 00:58:59.120
Is there something in
between zero-sum games

00:58:59.120 --> 00:59:02.450
and general two-player
games for which any hardness

00:59:02.450 --> 00:59:03.452
result is known?

00:59:06.410 --> 00:59:08.500
COSTIS DASKALAKIS: Yeah.

00:59:08.500 --> 00:59:13.780
A natural way to interpolate
between zero-sum games

00:59:13.780 --> 00:59:17.450
and general two-player
games is the following.

00:59:17.450 --> 00:59:21.950
So in a zero-sum game let's
call R and C the payoff matrix

00:59:21.950 --> 00:59:23.460
of the two players.

00:59:23.460 --> 00:59:27.820
In the game of zero-sum, if R
plus C, the sum of these two

00:59:27.820 --> 00:59:35.110
matrices is identically 0, as I
claimed in the very first slide

00:59:35.110 --> 00:59:36.600
I gave last time.

00:59:36.600 --> 00:59:45.610
Now you could call a game
rank-r if R plus C has rank-r.

00:59:51.190 --> 01:00:04.582
Now what is known is that
rank-1 games can be solved in P.

01:00:04.582 --> 01:00:14.135
I believe that it's known that
rank-3 games are PPAD hard.

01:00:20.970 --> 01:00:28.780
And you should look at the
paper by Mehta, Ruta Mehta

01:00:28.780 --> 01:00:34.860
in '14, I believe,
where she shows that.

01:00:34.860 --> 01:00:38.910
She might even be showing
rank-2, but I'm not sure.

01:00:38.910 --> 01:00:43.760
Maybe there is some gap there.

01:00:43.760 --> 01:00:50.630
Maybe it's even-- so there is
a constant where it's already

01:00:50.630 --> 01:00:51.430
PPAD hard.

01:00:55.660 --> 01:01:00.680
And while I'm here, an
interesting open question

01:01:00.680 --> 01:01:06.950
is approximate equilibrium.

01:01:06.950 --> 01:01:15.970
So interesting open problem--
approximate Nash equilibria.

01:01:20.930 --> 01:01:22.640
Even into two-player
games, we've

01:01:22.640 --> 01:01:24.190
don't know how to find them.

01:01:24.190 --> 01:01:27.980
So let me remind you what this.

01:01:27.980 --> 01:01:31.550
So a Nash equilibrium is
a pair of strategies such

01:01:31.550 --> 01:01:35.990
that no one has an incentive to
change his randomization given

01:01:35.990 --> 01:01:38.410
what the other player is doing.

01:01:38.410 --> 01:01:46.070
And epsilon Nash equilibrium is
when this condition are true to

01:01:46.070 --> 01:01:47.630
within an order of epsilon.

01:01:47.630 --> 01:01:52.129
So no player has incentive, more
than epsilon, additive epsilon

01:01:52.129 --> 01:01:53.670
incentive, to changed
his strategies.

01:01:58.600 --> 01:02:06.055
So at most, additive
epsilon incentive to change.

01:02:09.540 --> 01:02:12.170
Now what do we know
about these problems?

01:02:12.170 --> 01:02:15.880
Well, if the input
to your problem

01:02:15.880 --> 01:02:20.370
is a game and an epsilon, then
it follows from those results

01:02:20.370 --> 01:02:21.600
that that's PPAD complete.

01:02:24.340 --> 01:02:28.220
Now it's even true that
if your input is a game,

01:02:28.220 --> 01:02:31.480
and you have a
prespecified epsilon that's

01:02:31.480 --> 01:02:35.040
inverse polynomial in
the size of the game,

01:02:35.040 --> 01:02:38.010
so that the input
is a game, and there

01:02:38.010 --> 01:02:42.190
is a inverse
polynomial function,

01:02:42.190 --> 01:02:43.190
and that's your epsilon.

01:02:43.190 --> 01:02:45.290
And you want to find an
inverse polynomial Nash

01:02:45.290 --> 01:02:49.420
equilibrium of this given game
that's still PPAD complete.

01:02:49.420 --> 01:02:51.465
But what is not known
is epsilon constant.

01:02:54.750 --> 01:02:56.620
How hard is it to
find equilibria

01:02:56.620 --> 01:03:00.340
when epsilon is a constant?

01:03:00.340 --> 01:03:10.110
And if your matrices
have entries in 0,1,

01:03:10.110 --> 01:03:12.830
then we know how to
do this in time n

01:03:12.830 --> 01:03:16.760
to the order log n
over epsilon squared.

01:03:19.570 --> 01:03:23.430
We know that there is no
FPTAS for the problem because

01:03:23.430 --> 01:03:28.890
of actually these
results, follow up results

01:03:28.890 --> 01:03:29.860
to these results.

01:03:29.860 --> 01:03:33.370
But what I claimed earlier about
inverse polynomial accuracy

01:03:33.370 --> 01:03:36.940
prohibits an FPTAS
for the problem.

01:03:36.940 --> 01:03:38.780
But a PTAS is possible.

01:03:38.780 --> 01:03:40.490
What we have is a quasi-PTAS.

01:03:40.490 --> 01:03:44.080
So if you have an
n-th strategy game,

01:03:44.080 --> 01:03:46.740
and you're interested in
some constant epsilon,

01:03:46.740 --> 01:03:50.720
then we can get you an epsilon
Nash equilibrium, n to the log

01:03:50.720 --> 01:03:52.900
and over epsilon squared time.

01:03:52.900 --> 01:03:54.930
And because I'm looking
at additive of epsilons,

01:03:54.930 --> 01:03:57.740
I'm also normalizing
my payoffs to be 0, 1,

01:03:57.740 --> 01:04:03.950
so that epsilon is related to
the maximum payoff of the game.

01:04:03.950 --> 01:04:05.270
So that's what we have.

01:04:05.270 --> 01:04:13.380
And it's a great open problem
if you can improve this, or show

01:04:13.380 --> 01:04:15.280
a lawyer bond.

01:04:15.280 --> 01:04:17.990
That's a great open problem.

01:04:17.990 --> 01:04:24.530
Speaking of which, if the
rank of this game is up to,

01:04:24.530 --> 01:04:27.415
I believe, logarithmic,
we know how to get a PTAS.

01:04:33.590 --> 01:04:35.900
Now I don't have
too much time left,

01:04:35.900 --> 01:04:40.460
so I guess I had two
options for today.

01:04:40.460 --> 01:04:44.780
One was to talk about
different problems

01:04:44.780 --> 01:04:52.270
that you can show PPAD hard, or
to talk about other existence

01:04:52.270 --> 01:04:54.360
arguments.

01:04:54.360 --> 01:04:57.990
And I think I only have
time for one of the two.

01:05:04.470 --> 01:05:07.940
The other option is to show
other arguments of existence

01:05:07.940 --> 01:05:08.790
in TFNP.

01:05:08.790 --> 01:05:12.229
So two examples,
or other argument?

01:05:12.229 --> 01:05:13.145
What do you guys vote?

01:05:15.990 --> 01:05:17.820
So who wants two other examples?

01:05:20.350 --> 01:05:21.620
OK, who's giving the count?

01:05:24.370 --> 01:05:26.135
Who wants other
existence arguments?

01:05:29.960 --> 01:05:33.034
So I think there's a slight
majority for other existence

01:05:33.034 --> 01:05:34.575
arguments, so I'm
going to show that.

01:05:40.670 --> 01:05:46.010
PPAD is founded on the
directed parity argument.

01:05:46.010 --> 01:05:49.870
Other natural arguments of
existence in combinatorics

01:05:49.870 --> 01:05:51.880
are the following,
and each of them

01:05:51.880 --> 01:05:55.950
is going to correspond to a
different complexity class.

01:05:55.950 --> 01:05:59.230
This is a parity argument
on an undirected graph

01:05:59.230 --> 01:06:02.160
if an undirected graph has
a node of odd degree then

01:06:02.160 --> 01:06:05.260
it must have another
node of odd degree,

01:06:05.260 --> 01:06:08.120
also known as the
handshaking lemma, I believe.

01:06:11.730 --> 01:06:13.360
Well this is another simple one.

01:06:13.360 --> 01:06:18.300
If a DAG, any DAG
has a sink, that's

01:06:18.300 --> 01:06:19.910
going to give rise
to the class PLS.

01:06:23.210 --> 01:06:24.910
And that's the
pigeonhole principle.

01:06:24.910 --> 01:06:26.970
If you have a function
mapping n elements,

01:06:26.970 --> 01:06:29.840
n minus 1 elements, than
there is a collision.

01:06:29.840 --> 01:06:32.460
That's going to give
rise to the PPP.

01:06:32.460 --> 01:06:34.990
So PPA stands for
polynomial parity

01:06:34.990 --> 01:06:40.310
on undirected graphs, PLS,
polynomial local search, PPP,

01:06:40.310 --> 01:06:42.890
polynomial pigeonhole principle.

01:06:42.890 --> 01:06:44.820
And I'm going to
define them formally

01:06:44.820 --> 01:06:47.180
in the next few slides.

01:06:47.180 --> 01:06:49.050
So I'm going to start
with PPA because it's

01:06:49.050 --> 01:06:51.765
very similar to be PPAD,
except there's no direction.

01:06:54.470 --> 01:07:00.920
And the input to the
problem is a circuit

01:07:00.920 --> 01:07:05.200
that induces a graph
of [INAUDIBLE] strings.

01:07:05.200 --> 01:07:13.760
So the circuit gets its input at
nodes, and outputs two strings.

01:07:13.760 --> 01:07:16.570
Gets one string,
outputs two strings.

01:07:16.570 --> 01:07:20.090
Now this circuit induces
a undirected graph

01:07:20.090 --> 01:07:22.960
over all possible strings
in the following way.

01:07:22.960 --> 01:07:25.620
There is a node between
string 1 and string 2

01:07:25.620 --> 01:07:29.990
if v1 is in the
output list of v2,

01:07:29.990 --> 01:07:32.120
and v2 is in the
output list of v1.

01:07:34.940 --> 01:07:38.180
So this circuit gets
n-bits as input,

01:07:38.180 --> 01:07:40.970
and has two n-bits as output.

01:07:40.970 --> 01:07:44.500
And no matter what it is,
it doesn't use a graph

01:07:44.500 --> 01:07:51.370
over strings that places an
edge between these two strings,

01:07:51.370 --> 01:07:56.310
if v1 is in the output
list of v2, and vice versa.

01:07:56.310 --> 01:08:00.440
Now in the same reasoning as
last time, the same spirit

01:08:00.440 --> 01:08:03.520
as last time, any
input C is going

01:08:03.520 --> 01:08:05.660
to reduce a graph with
a particular structure.

01:08:05.660 --> 01:08:07.970
What's that structure?

01:08:07.970 --> 01:08:10.250
The odd degree of
every node is what?

01:08:10.250 --> 01:08:12.180
At most 2.

01:08:12.180 --> 01:08:16.910
Hence the graph that is
induced by any given circuit

01:08:16.910 --> 01:08:19.825
is going to be a collection
of isolated vertices, cycles,

01:08:19.825 --> 01:08:20.325
and paths.

01:08:23.410 --> 01:08:27.340
The odd degree node
problem is the following.

01:08:27.340 --> 01:08:31.740
If the 0 string has
odd degree, then I

01:08:31.740 --> 01:08:34.830
want you to find me another
node with odd degree,

01:08:34.830 --> 01:08:38.140
which we know exists by
the handshaking lemma.

01:08:38.140 --> 01:08:42.640
Otherwise, if 0 to the n has
even degree, just say, yes,

01:08:42.640 --> 01:08:45.260
and call it a day.

01:08:45.260 --> 01:08:51.779
Now PPA is the class of
search problems in NP

01:08:51.779 --> 01:08:54.740
that are reducible, polytime
reducible, to this problem,

01:08:54.740 --> 01:08:58.605
to the odd degree node
problem, whose graph structure

01:08:58.605 --> 01:09:03.979
is very similar to PPAD,
except there are no directions.

01:09:03.979 --> 01:09:08.270
So any circuit C defines
a graph of this form,

01:09:08.270 --> 01:09:11.069
except the graph is over
exponentially many vertices,

01:09:11.069 --> 01:09:15.779
so we cannot just go
and check every node,

01:09:15.779 --> 01:09:17.330
every node's degree.

01:09:17.330 --> 01:09:22.160
So the question is if 0
to the n has odd degree,

01:09:22.160 --> 01:09:24.960
then there must be another
node of odd degree.

01:09:24.960 --> 01:09:27.490
Any of these nodes is a valid
solution to the problem.

01:09:30.100 --> 01:09:34.240
Something that I didn't
mention before for PPAD,

01:09:34.240 --> 01:09:36.080
but it's useful to
mention, and I'm also

01:09:36.080 --> 01:09:40.080
going to mention it
for PPA, if I insist

01:09:40.080 --> 01:09:43.140
on finding the other
end of this path,

01:09:43.140 --> 01:09:45.870
of the specific path
that started at 0,

01:09:45.870 --> 01:09:46.960
the problem is not in FNP.

01:09:51.420 --> 01:09:56.060
So it's crucial that
given the unbalanceness,

01:09:56.060 --> 01:09:57.955
or the odd degree
of this node, I'll

01:09:57.955 --> 01:10:02.020
allow you to return any
other odd degree node.

01:10:02.020 --> 01:10:03.540
That's very crucial.

01:10:03.540 --> 01:10:06.630
If I insisted on
you returning me

01:10:06.630 --> 01:10:11.290
the other endpoint on the
path that starts at 0,

01:10:11.290 --> 01:10:14.080
that's above NP basically
because there's no source

01:10:14.080 --> 01:10:18.850
certificate that this node
in the other end of the path

01:10:18.850 --> 01:10:19.880
starting at 0.

01:10:19.880 --> 01:10:21.560
So it's very crucial
that I allow you

01:10:21.560 --> 01:10:23.320
to return any odd degree node.

01:10:26.550 --> 01:10:30.490
Now an interesting problem
that is in this class,

01:10:30.490 --> 01:10:33.950
and as far as we
know, not in PPAD,

01:10:33.950 --> 01:10:39.520
is the problem Smith, which
is given a Hamiltonian

01:10:39.520 --> 01:10:43.360
circuit in a
3-regular graph, find

01:10:43.360 --> 01:10:47.394
me another Hamiltonian
circuit in this graph.

01:10:47.394 --> 01:10:49.060
Now this graph is not
exponentially big.

01:10:49.060 --> 01:10:50.976
It's actually a graph
that you can write down.

01:10:50.976 --> 01:10:53.490
So I give you a
graph explicitly,

01:10:53.490 --> 01:10:56.200
and I also give you
a Hamiltonian circuit

01:10:56.200 --> 01:10:59.310
in this graph.

01:10:59.310 --> 01:11:01.485
I claim that there is
another Hamiltonian circuit.

01:11:04.640 --> 01:11:06.430
The question is find it.

01:11:09.184 --> 01:11:11.100
Now why is there always
a Hamiltonian circuit?

01:11:11.100 --> 01:11:14.710
Well, that follows
from a theorem by Smith

01:11:14.710 --> 01:11:18.640
saying that-- a theorem by Smith
implies that there's always

01:11:18.640 --> 01:11:20.622
another Hamiltonian path.

01:11:20.622 --> 01:11:22.080
And let me actually
show it to you.

01:11:22.080 --> 01:11:23.880
It's very simple.

01:11:23.880 --> 01:11:27.090
So here's is actually a copy
from Papadimitriou's '94 paper.

01:11:29.660 --> 01:11:32.570
I guess there's a
missing apostrophe here.

01:11:32.570 --> 01:11:35.980
So here's the input graph.

01:11:35.980 --> 01:11:44.800
And obviously, this is
a Hamiltonian circuit.

01:11:44.800 --> 01:11:49.630
So I'm following the outer
boundary here, going inside,

01:11:49.630 --> 01:11:51.070
and then coming back here.

01:11:51.070 --> 01:11:52.945
That's the Hamiltonian circuit.

01:11:52.945 --> 01:11:54.820
And here's the same
circuit, except I removed

01:11:54.820 --> 01:11:58.250
one edge, x and y.

01:11:58.250 --> 01:12:00.770
And here I'm showing
a bunch of operations

01:12:00.770 --> 01:12:04.480
you can do this
Hamiltonian path-- this

01:12:04.480 --> 01:12:10.950
is a Hamiltonian path-- to
create another Hamilton path

01:12:10.950 --> 01:12:13.480
with the same edge missing.

01:12:13.480 --> 01:12:17.410
Hence, out of that edge, you
get another Hamiltonian circuit.

01:12:17.410 --> 01:12:20.230
And the [INAUDIBLE]
is very simple.

01:12:20.230 --> 01:12:23.160
So what you do is the following.

01:12:23.160 --> 01:12:25.380
So you start with--
it doesn't matter.

01:12:25.380 --> 01:12:28.230
You can start with
an arbitrary node.

01:12:28.230 --> 01:12:36.830
All the circuits I'm
going to be defining,

01:12:36.830 --> 01:12:40.190
will have x as one
of the two endpoints.

01:12:40.190 --> 01:12:44.160
But the other endpoint is
going to be moving around

01:12:44.160 --> 01:12:47.480
and in the end, is going
to get back to this vertex.

01:12:47.480 --> 01:12:50.770
Hence, I can knock that edge
back and get the circuit.

01:12:50.770 --> 01:12:52.880
So I started with the circuit.

01:12:52.880 --> 01:12:56.630
I remove one edge, x and y.

01:12:56.630 --> 01:12:58.130
And I'm about to
show you that there

01:12:58.130 --> 01:13:02.930
is another Hamiltonian path
that misses the same edge,

01:13:02.930 --> 01:13:05.020
but is different than this one.

01:13:05.020 --> 01:13:06.370
So it's going to be that one.

01:13:06.370 --> 01:13:08.000
Now let me try to
argue that that

01:13:08.000 --> 01:13:11.947
is another Hamiltonian path
that is missing the same edge.

01:13:11.947 --> 01:13:13.030
How am I going to do that?

01:13:13.030 --> 01:13:18.370
Well, in this sequence
of Hamiltonian paths

01:13:18.370 --> 01:13:20.710
that I'm going to define,
x is going to stay fixed,

01:13:20.710 --> 01:13:22.720
y is going to be moving around.

01:13:22.720 --> 01:13:26.360
Now let's land somewhere
in the middle, here.

01:13:26.360 --> 01:13:28.970
So now y is this guy.

01:13:28.970 --> 01:13:33.320
y, because the
graph is 3-regular,

01:13:33.320 --> 01:13:36.580
and y is an endpoint,
there's exactly

01:13:36.580 --> 01:13:40.420
one edge that's used in
the Hamiltonian path.

01:13:40.420 --> 01:13:43.590
And there are two
edges that are missing.

01:13:43.590 --> 01:13:50.605
I'm going to try to add both
of them and get a circuit--

01:13:50.605 --> 01:13:53.720
and get a path, a
Hamiltonian path.

01:13:53.720 --> 01:13:58.850
What would happen if I tried to
add this edge into this path?

01:13:58.850 --> 01:14:01.615
Well, that wouldn't
be a path anymore.

01:14:04.380 --> 01:14:08.460
So because this guy would have
degree 3 if I added that edge.

01:14:08.460 --> 01:14:11.480
Now have two kill one of the
two edges adjacent to this node.

01:14:11.480 --> 01:14:14.620
And I'm going to kill the one
that the maintains the fact

01:14:14.620 --> 01:14:17.000
that the graph is connected.

01:14:17.000 --> 01:14:21.960
If I add this edge, and I
kill this edge, I'm screwed.

01:14:21.960 --> 01:14:24.820
The graph is not
connected anymore.

01:14:24.820 --> 01:14:26.250
So I'm going to kill that edge.

01:14:26.250 --> 01:14:27.840
So what happens here?

01:14:27.840 --> 01:14:30.160
I added that edge, and
I killed that edge.

01:14:30.160 --> 01:14:32.760
And this what I got.

01:14:32.760 --> 01:14:37.899
If I tried to add this
edge, then this node

01:14:37.899 --> 01:14:38.690
will have degree 3.

01:14:38.690 --> 01:14:42.130
I have to kill either
that edge or that edge.

01:14:42.130 --> 01:14:46.439
I can kill exactly one to
avoid disconnecting my graph.

01:14:46.439 --> 01:14:47.980
And I'm going to be
killing that one,

01:14:47.980 --> 01:14:50.290
and that's going
to bring me here.

01:14:50.290 --> 01:14:58.610
So every Hamiltonian path
has exactly two neighbors

01:14:58.610 --> 01:15:07.450
corresponding to adding
one of the two missing

01:15:07.450 --> 01:15:12.310
edges from the y
endpoint of that path.

01:15:12.310 --> 01:15:16.400
And there's only one
way this thing can stop,

01:15:16.400 --> 01:15:17.330
by arriving at y.

01:15:21.280 --> 01:15:24.010
If I don't get
endpoint y to come back

01:15:24.010 --> 01:15:26.070
to its original position
I will keep going.

01:15:31.680 --> 01:15:35.000
In other words, like my proof
[INAUDIBLE], what I did here

01:15:35.000 --> 01:15:37.510
is I defined a
neighborhood relationship

01:15:37.510 --> 01:15:40.320
between Hamiltonian
paths, which was

01:15:40.320 --> 01:15:43.360
adding an edge, one
of the two missing

01:15:43.360 --> 01:15:45.530
edges from the endpoints.

01:15:45.530 --> 01:15:49.025
And another, the only stopping
condition is if I get here.

01:15:49.025 --> 01:15:52.940
And that's why Smith is in PPA.

01:15:52.940 --> 01:15:54.890
Now it's a very
interesting problem

01:15:54.890 --> 01:15:56.875
to show that this
is PPA complete.

01:16:01.780 --> 01:16:04.660
Let me define the class PLS.

01:16:04.660 --> 01:16:07.950
That was define earlier
by Johnson, Papadimitriou

01:16:07.950 --> 01:16:10.730
and Yanakakis.

01:16:10.730 --> 01:16:15.220
Now I want to implement a class
that exploits this argument,

01:16:15.220 --> 01:16:16.402
that every DAG has a sink.

01:16:16.402 --> 01:16:17.860
The way I'm going
to do that is I'm

01:16:17.860 --> 01:16:20.260
going to give you two functions.

01:16:20.260 --> 01:16:23.390
Function C is going
to take-- both of them

01:16:23.390 --> 01:16:26.730
will have n-bits as inputs.

01:16:26.730 --> 01:16:31.760
This guy, C, will output
a list of strings,

01:16:31.760 --> 01:16:34.010
a list of k strings.

01:16:34.010 --> 01:16:38.340
So it has n-bits as input,
and k n-bits as output.

01:16:38.340 --> 01:16:42.790
While this guy is
outputting some real number,

01:16:42.790 --> 01:16:44.800
I mean, some rational
number, whatever.

01:16:44.800 --> 01:16:48.007
But I interpret the output
of the circuit as a number.

01:16:48.007 --> 01:16:49.590
I interpret the
output of this circuit

01:16:49.590 --> 01:16:50.965
as a list of other strings.

01:16:54.681 --> 01:16:58.010
I add that's between-- given
these two circuits, that

01:16:58.010 --> 01:17:01.930
induces a DAG, I claim,
in the following way.

01:17:01.930 --> 01:17:05.440
I add an edge from
v1 to v2 if v2

01:17:05.440 --> 01:17:12.890
is in the adjacency list of
v1, and the score of v2 two

01:17:12.890 --> 01:17:17.240
is better than the score of v1.

01:17:17.240 --> 01:17:21.290
Then and only then, I add
an edge from v1 to v2.

01:17:21.290 --> 01:17:27.280
And obviously, this is a DAG now
because I'm increasing my score

01:17:27.280 --> 01:17:28.480
as I go along.

01:17:28.480 --> 01:17:32.150
So I cannot come back
to where I started.

01:17:32.150 --> 01:17:34.980
So the problem that
I want to define

01:17:34.980 --> 01:17:41.020
is the FindSink problem, which
is given two circuits as above,

01:17:41.020 --> 01:17:48.800
find an x that has a
better score than any

01:17:48.800 --> 01:17:52.470
of the adjacent vertices.

01:17:52.470 --> 01:17:55.650
And such a thing has to exist
because if I define this graph

01:17:55.650 --> 01:17:57.350
and find any sink
of this graph, this

01:17:57.350 --> 01:17:59.930
will satisfy this property.

01:17:59.930 --> 01:18:04.240
The class PLS are all
search problems in the P,

01:18:04.240 --> 01:18:05.830
but are polynomial
time reducible

01:18:05.830 --> 01:18:08.850
to this problem, FindSink.

01:18:08.850 --> 01:18:12.970
The picture for this
problem is this,

01:18:12.970 --> 01:18:15.060
exponentially large graph.

01:18:15.060 --> 01:18:16.910
But there is a DAG
that's implicitly

01:18:16.910 --> 01:18:20.440
defined by these two vertices,
by these two circuits.

01:18:20.440 --> 01:18:21.915
And all of these are solutions.

01:18:26.920 --> 01:18:28.640
An interesting
problem in this class

01:18:28.640 --> 01:18:31.390
is the LocalMaxCut
problem, a relative

01:18:31.390 --> 01:18:35.510
of the well-known MaxCut
problem, which is NP complete.

01:18:35.510 --> 01:18:39.850
In the LocalMaxCut problem, I'm
giving you a weighted graph.

01:18:39.850 --> 01:18:43.310
And I want a partition
that's not globally

01:18:43.310 --> 01:18:45.920
optimal, but locally
optimal, meaning

01:18:45.920 --> 01:18:47.780
there is no single
node I could move

01:18:47.780 --> 01:18:50.060
from one to the
other side of the cut

01:18:50.060 --> 01:18:51.231
to improve the cut value.

01:18:55.950 --> 01:19:00.860
Now if the weights were
bounded and integral,

01:19:00.860 --> 01:19:04.390
this wouldn't be a hard problem.

01:19:04.390 --> 01:19:07.100
But for arbitrary
weights, it's actually PLS

01:19:07.100 --> 01:19:12.732
complete to find a
local maximum cut.

01:19:17.340 --> 01:19:20.110
Final problem, and
I'm concluding,

01:19:20.110 --> 01:19:23.480
is final class is
the class PPP that's

01:19:23.480 --> 01:19:27.120
trying to implement the
pigeonhole principle.

01:19:27.120 --> 01:19:29.950
Here I'm giving you
a circuit that has

01:19:29.950 --> 01:19:31.795
n-bit input and n-bit outputs.

01:19:38.610 --> 01:19:40.690
The collision problem
that I want to define

01:19:40.690 --> 01:19:43.630
is given sets of
circuits, either find

01:19:43.630 --> 01:19:47.660
me an x that maps
to the 0 string,

01:19:47.660 --> 01:19:52.580
or find me a pair x and y
that map to the same string.

01:19:52.580 --> 01:19:56.350
Clearly, by the pigeonhole
principle if nobody goes to 0,

01:19:56.350 --> 01:19:59.470
there must be two
guys that collide.

01:19:59.470 --> 01:20:03.830
So this problem is also total
by the pigeonhole principal.

01:20:03.830 --> 01:20:07.590
So it always has a solution,
no matter what the circuit is.

01:20:07.590 --> 01:20:10.150
And the class PPP is
all problems in NP that

01:20:10.150 --> 01:20:11.520
are reducible to this problem.

01:20:14.730 --> 01:20:19.830
Finally, the hierarchy of
problems I defined is this.

01:20:19.830 --> 01:20:23.600
P, FNP, there is total
FNP somewhere here,

01:20:23.600 --> 01:20:25.130
which I don't show.

01:20:25.130 --> 01:20:28.210
And these are the relationships
of these problems.

01:20:28.210 --> 01:20:32.790
I haven't shown that
these arrows true,

01:20:32.790 --> 01:20:35.530
that this is a subclass,
PPD's a subclass

01:20:35.530 --> 01:20:36.530
of these two subclasses.

01:20:36.530 --> 01:20:37.350
This is easy.

01:20:37.350 --> 01:20:41.800
This is a simple exercise
we can think about.

01:20:41.800 --> 01:20:43.880
This is basically
my introduction

01:20:43.880 --> 01:20:48.250
to PPA, PPAD and
related classes.

01:20:48.250 --> 01:20:50.040
The final thing that
I want to point out

01:20:50.040 --> 01:20:52.615
is answering a
question that was asked

01:20:52.615 --> 01:20:53.990
after the previous
lecture, which

01:20:53.990 --> 01:20:57.430
was why did you
define these classes,

01:20:57.430 --> 01:21:02.760
and not just a TFNP
complete problem.

01:21:02.760 --> 01:21:09.170
Why did you have to pay special
attention to precise existence

01:21:09.170 --> 01:21:12.700
argument that gives
rise to the guarantee

01:21:12.700 --> 01:21:14.960
that your problems are total?

01:21:14.960 --> 01:21:18.750
And the reason for that
is that actually TFNP

01:21:18.750 --> 01:21:21.890
is not what's called
a syntactic class.

01:21:21.890 --> 01:21:29.870
In other words, if I give
you a problem with TFNP--

01:21:29.870 --> 01:21:34.900
if I give you a Turing machine,
you cannot decide whether that

01:21:34.900 --> 01:21:39.250
is computing a total problem,
that no matter what the input

01:21:39.250 --> 01:21:43.940
to that machine is,
there's always an output.

01:21:43.940 --> 01:21:50.210
So I had to pay attention to the
specialized existence arguments

01:21:50.210 --> 01:21:53.030
because for specialized
existence arguments,

01:21:53.030 --> 01:21:57.930
I know a priori that
the problem is total.

01:21:57.930 --> 01:22:02.600
So in particular, no matter
what circuit I give you here,

01:22:02.600 --> 01:22:04.120
I don't even have
to check anything.

01:22:04.120 --> 01:22:07.720
No matter what input you give
me, I know there is a solution.

01:22:07.720 --> 01:22:12.110
No matter what pairs of
circuits you give me here,

01:22:12.110 --> 01:22:13.920
I don't need to check anything.

01:22:13.920 --> 01:22:15.930
I know the answer
to this problem--

01:22:15.930 --> 01:22:20.100
there's always an answer to this
problem, and so on, so forth.

01:22:20.100 --> 01:22:23.490
No matter what you
give to me as input,

01:22:23.490 --> 01:22:27.000
it is important to
define complexity classes

01:22:27.000 --> 01:22:30.686
for which you can show
hardness results to find

01:22:30.686 --> 01:22:31.435
complete problems.

01:22:34.220 --> 01:22:36.150
Otherwise, you
would have what is

01:22:36.150 --> 01:22:39.790
called promise classes, which
are not amenable to showing

01:22:39.790 --> 01:22:42.740
the completeness results.

01:22:42.740 --> 01:22:44.970
On that brief not,
I want to stop.

01:22:44.970 --> 01:22:46.820
Thanks a lot.