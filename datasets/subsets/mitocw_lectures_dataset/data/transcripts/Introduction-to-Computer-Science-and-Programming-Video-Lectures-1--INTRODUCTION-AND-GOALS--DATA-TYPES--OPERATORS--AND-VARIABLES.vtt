WEBVTT

00:00:00.030 --> 00:00:02.400
The following content is
provided under a Creative

00:00:02.400 --> 00:00:03.810
Commons license.

00:00:03.810 --> 00:00:06.840
Your support will help MIT
OpenCourseware continue to

00:00:06.840 --> 00:00:10.510
offer high-quality educational
resources for free.

00:00:10.510 --> 00:00:13.390
To make a donation, or view
additional materials from

00:00:13.390 --> 00:00:17.430
hundreds of MIT courses, visit
MIT OpenCourseware, at

00:00:17.430 --> 00:00:17.580
ocw.mit.edu .

00:00:17.580 --> 00:00:18.520
PROFESSOR: Good morning.

00:00:18.520 --> 00:00:19.440
Try it again.

00:00:19.440 --> 00:00:22.120
Good morning.

00:00:22.120 --> 00:00:25.820
STUDENTS: Good morning.

00:00:25.820 --> 00:00:27.510
PROFESSOR: Thank you.

00:00:27.510 --> 00:00:31.330
This is 6.00, also known as
Introduction to Computer

00:00:31.330 --> 00:00:32.990
Science and Programming.

00:00:32.990 --> 00:00:35.330
My name is Eric Grimson, I have
together Professor John

00:00:35.330 --> 00:00:37.400
Guttag over here, we're
going to be lecturing

00:00:37.400 --> 00:00:39.320
the course this term.

00:00:39.320 --> 00:00:41.610
I want to give you a heads up;
you're getting some serious

00:00:41.610 --> 00:00:43.710
firepower this term.

00:00:43.710 --> 00:00:47.320
John was department head for
ten years, felt like a

00:00:47.320 --> 00:00:50.180
century, and in course six,
I'm the current department

00:00:50.180 --> 00:00:51.140
head in course six.

00:00:51.140 --> 00:00:55.810
John's been lecturing for
thirty years, roughly.

00:00:55.810 --> 00:00:58.130
All right, I'm the young guy,
I've only been lecturing for

00:00:58.130 --> 00:00:59.820
twenty-five years.

00:00:59.820 --> 00:01:03.260
You can tell, I have less
grey hair than he does.

00:01:03.260 --> 00:01:05.220
What I'm trying to say to
you is, we take this

00:01:05.220 --> 00:01:07.050
course really seriously.

00:01:07.050 --> 00:01:08.530
We hope you do as well.

00:01:08.530 --> 00:01:10.750
But we think it's really
important for the department

00:01:10.750 --> 00:01:14.000
to help everybody learn about
computation, and that's what

00:01:14.000 --> 00:01:16.200
this course is about.

00:01:16.200 --> 00:01:19.840
What I want to do today is three
things: I'm going to

00:01:19.840 --> 00:01:22.340
start-- actually, I shouldn't
say start, I'm going to do a

00:01:22.340 --> 00:01:24.430
little bit of administrivia, the
kinds of things you need

00:01:24.430 --> 00:01:26.720
to know about how we're going
to run the course.

00:01:26.720 --> 00:01:30.230
I want to talk about the goal
of the course, what it is

00:01:30.230 --> 00:01:32.770
you'll be able to do at the end
of this course when you

00:01:32.770 --> 00:01:35.950
get through it, and then I want
to begin talking about

00:01:35.950 --> 00:01:39.870
the concepts and tools of
computational thinking, which

00:01:39.870 --> 00:01:41.600
is what we're primarily going
to focus on here.

00:01:41.600 --> 00:01:43.590
We're going to try and help you
learn how to think like a

00:01:43.590 --> 00:01:45.680
computer scientist, and we're
going to begin talking about

00:01:45.680 --> 00:01:47.730
that towards the end of this
lecture and of course

00:01:47.730 --> 00:01:50.750
throughout the rest of the
lectures that carry on.

00:01:50.750 --> 00:01:52.750
Right, let's start
with the goals.

00:01:52.750 --> 00:01:55.310
I'm going to give you
goals in two levels.

00:01:55.310 --> 00:01:58.800
The strategic goals are the
following: we want to help

00:01:58.800 --> 00:02:02.090
prepare freshmen and sophomores
who are interested

00:02:02.090 --> 00:02:05.260
in majoring in course six to
get an easy entry into the

00:02:05.260 --> 00:02:07.270
department, especially for those
students who don't have

00:02:07.270 --> 00:02:09.720
a lot of prior programming
experience.

00:02:09.720 --> 00:02:11.860
If you're in that category,
don't panic, you're

00:02:11.860 --> 00:02:12.720
going to get it.

00:02:12.720 --> 00:02:14.730
We're going to help you ramp
in and you'll certainly be

00:02:14.730 --> 00:02:17.810
able to start the course six
curriculum and do just fine

00:02:17.810 --> 00:02:20.120
and still finish on target.

00:02:20.120 --> 00:02:22.670
We don't expect everybody to
be a course six major,

00:02:22.670 --> 00:02:25.850
contrary to popular opinion,
so for those are you not in

00:02:25.850 --> 00:02:27.790
that category, the second thing
we want to do is we want

00:02:27.790 --> 00:02:30.490
to help students who don't plan
to major in course six to

00:02:30.490 --> 00:02:34.610
feel justifiably confident in
their ability to write and

00:02:34.610 --> 00:02:37.850
read small pieces of code.

00:02:37.850 --> 00:02:40.240
For all students, what we want
to do is we want to give you

00:02:40.240 --> 00:02:43.390
an understanding of the role
computation can and cannot

00:02:43.390 --> 00:02:47.890
play in tackling technical
problems. So that you will

00:02:47.890 --> 00:02:50.680
come away with a sense of what
you can do, what you can't do,

00:02:50.680 --> 00:02:53.340
and what kinds of things you
should use to tackle complex

00:02:53.340 --> 00:02:54.680
problems.

00:02:54.680 --> 00:02:56.900
And finally, we want to position
all students so that

00:02:56.900 --> 00:03:00.870
you can easily, if you like,
compete for things like your

00:03:00.870 --> 00:03:02.440
office and summer jobs.

00:03:02.440 --> 00:03:04.120
Because you'll have an
appropriate level of

00:03:04.120 --> 00:03:06.460
confidence and competence
in your ability to do

00:03:06.460 --> 00:03:08.540
computational problem solving.

00:03:08.540 --> 00:03:10.660
Those are the strategic goals.

00:03:10.660 --> 00:03:15.490
Now, this course is primarily
aimed at students who have

00:03:15.490 --> 00:03:19.240
little or no prior programming
experience.

00:03:19.240 --> 00:03:21.890
As a consequence, we believe
that no student here is

00:03:21.890 --> 00:03:24.700
under-qualified for this
course: you're all MIT

00:03:24.700 --> 00:03:26.880
students, you're all qualified
to be here.

00:03:26.880 --> 00:03:29.110
But we also hope that there
aren't any students here who

00:03:29.110 --> 00:03:31.950
are over-qualified
for this course.

00:03:31.950 --> 00:03:32.810
And what do I mean by that?

00:03:32.810 --> 00:03:37.240
If you've done a lot prior
programming, this is probably

00:03:37.240 --> 00:03:39.820
not the best course for you,
and if you're in that

00:03:39.820 --> 00:03:42.270
category, I would please
encourage you to talk to John

00:03:42.270 --> 00:03:45.780
or I after class about what your
goals are, what kind of

00:03:45.780 --> 00:03:48.160
experience you have, and how
we might find you a course

00:03:48.160 --> 00:03:51.290
that better meets your goals.

00:03:51.290 --> 00:03:54.070
Second reason we don't want
over-qualified students in the

00:03:54.070 --> 00:03:56.160
class, it sounds a little nasty,
but the second reason

00:03:56.160 --> 00:03:59.780
is, an over-qualified student,
somebody who's, I don't know,

00:03:59.780 --> 00:04:03.220
programmed for Google for the
last five years, is going to

00:04:03.220 --> 00:04:05.600
have an easy time in this
course, but we don't want such

00:04:05.600 --> 00:04:08.710
a student accidentally
intimidating the rest of you.

00:04:08.710 --> 00:04:12.140
We don't want you to feel
inadequate when you're simply

00:04:12.140 --> 00:04:13.520
inexperienced.

00:04:13.520 --> 00:04:16.080
And so, it really is a course
aimed at students with little

00:04:16.080 --> 00:04:18.530
or no prior programming
experience.

00:04:18.530 --> 00:04:20.480
And again, if you're not in that
category, talk to John or

00:04:20.480 --> 00:04:22.660
I after class, and we'll help
you figure out where you might

00:04:22.660 --> 00:04:24.610
want to go.

00:04:24.610 --> 00:04:24.930
OK.

00:04:24.930 --> 00:04:26.680
Those are the top-level
goals of the course.

00:04:26.680 --> 00:04:29.950
Let's talk sort of at a more
tactical level, about what do

00:04:29.950 --> 00:04:31.320
we want you to know
in this course.

00:04:31.320 --> 00:04:33.410
What we want you to be able
to do by the time

00:04:33.410 --> 00:04:34.710
you leave this course?

00:04:34.710 --> 00:04:41.280
So here are the skills that we
would like you to acquire.

00:04:41.280 --> 00:04:44.340
Right, the first skill we want
you to acquire, is we want you

00:04:44.340 --> 00:04:46.840
to be able to use the basic
tools of computational

00:04:46.840 --> 00:04:50.180
thinking to write small scale
programs. I'm going to keep

00:04:50.180 --> 00:04:52.030
coming back to that idea,
but I'm going to call it

00:04:52.030 --> 00:04:57.750
computational thinking.

00:04:57.750 --> 00:05:00.550
And that's so you can write
small pieces of code.

00:05:00.550 --> 00:05:02.990
And small is not derogatory
here, by the way, it just says

00:05:02.990 --> 00:05:05.870
the size of things you're
going to be able to do.

00:05:05.870 --> 00:05:08.115
Second skill we want you to have
at the end of this course

00:05:08.115 --> 00:05:10.870
is the ability to use a
vocabulary of computational

00:05:10.870 --> 00:05:13.170
tools in order to be
able to understand

00:05:13.170 --> 00:05:15.050
programs written by others.

00:05:15.050 --> 00:05:16.520
So you're going to be able
to write, you're going

00:05:16.520 --> 00:05:19.840
to be able to read.

00:05:19.840 --> 00:05:24.610
This latter skill, by the way,
is incredibly valuable.

00:05:24.610 --> 00:05:26.470
Because you won't want to do
everything from scratch

00:05:26.470 --> 00:05:28.410
yourself, you want to be able
to look at what is being

00:05:28.410 --> 00:05:31.010
created by somebody else and
understand what is inside of

00:05:31.010 --> 00:05:33.130
there, whether it works
correctly and how you can

00:05:33.130 --> 00:05:34.250
build on it.

00:05:34.250 --> 00:05:35.540
This is one of the
few places where

00:05:35.540 --> 00:05:37.800
plagiarism is an OK thing.

00:05:37.800 --> 00:05:40.510
It's not bad to, if you like,
learn from the skills of

00:05:40.510 --> 00:05:42.660
others in order to create
something you want to write.

00:05:42.660 --> 00:05:44.090
Although we'll come back
to plagiarism as a

00:05:44.090 --> 00:05:46.300
bad thing later on.

00:05:46.300 --> 00:05:48.500
Third thing we want you to
do, is to understand the

00:05:48.500 --> 00:05:52.210
fundamental both capabilities
and limitations of

00:05:52.210 --> 00:05:55.680
computations, and the costs
associated with them.

00:05:55.680 --> 00:05:57.430
And that latter statement sounds
funny, you don't think

00:05:57.430 --> 00:05:59.770
of computations having
limits, but they do.

00:05:59.770 --> 00:06:01.330
There're some things that
cannot be computed.

00:06:01.330 --> 00:06:03.350
We want you to understand
where those limits are.

00:06:03.350 --> 00:06:05.850
So you're going to be
able to understand

00:06:05.850 --> 00:06:15.290
abilities and limits.

00:06:15.290 --> 00:06:18.000
And then, finally, the last
tactical skill that you're

00:06:18.000 --> 00:06:19.580
going to get out of this course
is you're going to have

00:06:19.580 --> 00:06:22.970
the ability to map scientific
problems into a

00:06:22.970 --> 00:06:24.970
computational frame.

00:06:24.970 --> 00:06:26.940
So you're going to be able to
take a description of a

00:06:26.940 --> 00:06:37.290
problem and map it into
something computational.

00:06:37.290 --> 00:06:39.170
Now if you think about
it, boy, it sounds

00:06:39.170 --> 00:06:41.060
like grammar school.

00:06:41.060 --> 00:06:43.400
We're going to teach you to
read, we're going to teach you

00:06:43.400 --> 00:06:46.740
to write, we're going to teach
you to understand what you can

00:06:46.740 --> 00:06:49.700
and cannot do, and most
importantly, we're going to

00:06:49.700 --> 00:06:52.570
try and give you the start
of an ability to take a

00:06:52.570 --> 00:06:55.600
description of a problem from
some other domain, and figure

00:06:55.600 --> 00:06:57.980
out how to map it into that
domain of computation so you

00:06:57.980 --> 00:07:01.710
can do the reading and writing
that you want to do.

00:07:01.710 --> 00:07:03.400
OK, in a few minutes we're going
to start talking then

00:07:03.400 --> 00:07:05.600
about what is computation, how
are we going to start building

00:07:05.600 --> 00:07:07.590
those tools, but that's what you
should take away, that's

00:07:07.590 --> 00:07:09.850
what you're going to gain out
of this course by the time

00:07:09.850 --> 00:07:11.770
you're done.

00:07:11.770 --> 00:07:14.500
Now, let me take a sidebar for
about five minutes to talk

00:07:14.500 --> 00:07:17.570
about course administration, the
administrivia, things that

00:07:17.570 --> 00:07:19.200
we're going to do in the course,
just so you know what

00:07:19.200 --> 00:07:20.820
the rules are.

00:07:20.820 --> 00:07:24.610
Right, so, class is two hours
of lecture a week.

00:07:24.610 --> 00:07:26.370
You obviously know where
and you know when,

00:07:26.370 --> 00:07:27.630
because you're here.

00:07:27.630 --> 00:07:29.760
Tuesdays and Thursdays
at 11:00.

00:07:29.760 --> 00:07:32.620
One hour of recitation a week,
on Fridays, and we'll come

00:07:32.620 --> 00:07:34.900
back in a second to how you're
going to get set up for that.

00:07:34.900 --> 00:07:38.290
And nine hours a week of
outside-the-class work.

00:07:38.290 --> 00:07:40.750
Those nine hours are going to
be primarily working on

00:07:40.750 --> 00:07:42.860
problem sets, and all the
problems sets are going to

00:07:42.860 --> 00:07:45.650
involve programming in Python,
which is the language we're

00:07:45.650 --> 00:07:48.010
going to be using this term.

00:07:48.010 --> 00:07:50.180
Now, one of the things you're
going to see is the first

00:07:50.180 --> 00:07:51.690
problem sets are pretty easy.

00:07:51.690 --> 00:07:52.900
Actually, that's probably
wrong, John, right?

00:07:52.900 --> 00:07:54.160
They're very easy.

00:07:54.160 --> 00:07:55.220
And we're going to ramp up.

00:07:55.220 --> 00:07:57.010
By the time you get to the end
of the term, you're going to

00:07:57.010 --> 00:07:59.330
be dealing with some fairly
complex things, so one of the

00:07:59.330 --> 00:08:01.540
things you're going to see is,
we're going to make heavy use

00:08:01.540 --> 00:08:04.360
of libraries, or code
written by others.

00:08:04.360 --> 00:08:06.880
It'll allow you to tackle
interesting problems I'll have

00:08:06.880 --> 00:08:11.860
you to write from scratch, but
it does mean that this skill

00:08:11.860 --> 00:08:13.170
here is going to be
really valuable.

00:08:13.170 --> 00:08:15.403
You need to be able to read that
code and understand it,

00:08:15.403 --> 00:08:18.050
as well as write your own.

00:08:18.050 --> 00:08:19.350
OK.

00:08:19.350 --> 00:08:20.380
Two quizzes.

00:08:20.380 --> 00:08:23.220
During the term, the dates have
already been scheduled.

00:08:23.220 --> 00:08:25.660
John, I forgot to look them up,
I think it's October 2nd

00:08:25.660 --> 00:08:29.260
and November 4th, it'll be
on the course website.

00:08:29.260 --> 00:08:31.610
My point is, go check the course
website, which by the

00:08:31.610 --> 00:08:34.470
way is right there.

00:08:34.470 --> 00:08:37.180
If you have, if you know you
have a conflict with one of

00:08:37.180 --> 00:08:40.470
those quiz dates now, please
see John or I right away.

00:08:40.470 --> 00:08:42.460
We'll arrange something
ahead of time.

00:08:42.460 --> 00:08:44.120
But if you--

00:08:44.120 --> 00:08:45.640
The reason I'm saying that is,
you know, you know that you're

00:08:45.640 --> 00:08:47.840
getting married that day for
example, we will excuse you

00:08:47.840 --> 00:08:49.740
from the quiz to get married.

00:08:49.740 --> 00:08:51.640
We'll expect you come right
back to do the quiz by the

00:08:51.640 --> 00:08:53.390
way, but the--

00:08:53.390 --> 00:08:54.560
Boy, tough crowd.

00:08:54.560 --> 00:08:57.040
All right.

00:08:57.040 --> 00:08:59.360
If you have a conflict,
please let us know.

00:08:59.360 --> 00:09:03.240
Second thing is, if you have an
MIT documented special need

00:09:03.240 --> 00:09:07.230
for taking quizzes, please see
John or I well in advance.

00:09:07.230 --> 00:09:08.730
At least two weeks
before the quiz.

00:09:08.730 --> 00:09:10.950
Again, we'll arrange for this,
but you need to give us enough

00:09:10.950 --> 00:09:13.830
warning so that we can
deal with that.

00:09:13.830 --> 00:09:16.920
OK, the quizzes are open book.

00:09:16.920 --> 00:09:20.330
This course is not
about memory.

00:09:20.330 --> 00:09:22.190
It's not how well you can
memorize facts: in fact, I

00:09:22.190 --> 00:09:24.180
think both John and I are a
little sensitive to memory

00:09:24.180 --> 00:09:26.230
tests, given our age,
right John?

00:09:26.230 --> 00:09:28.370
This is not about how you
memorize things, it's about

00:09:28.370 --> 00:09:29.020
how you think.

00:09:29.020 --> 00:09:30.720
So they're open note,
open book.

00:09:30.720 --> 00:09:34.420
It's really going to test
your ability to think.

00:09:34.420 --> 00:09:38.250
The grades for the course will
be assigned roughly, and I use

00:09:38.250 --> 00:09:40.110
the word roughly because we
reserve the right to move

00:09:40.110 --> 00:09:42.390
these numbers around a little
bit, but basically in the

00:09:42.390 --> 00:09:44.940
following percentages: 55% of
your grade comes from the

00:09:44.940 --> 00:09:48.750
problem sets, the other 45%
come from the quizzes.

00:09:48.750 --> 00:09:50.810
And I should've said there's two
quizzes and a final exam.

00:09:50.810 --> 00:09:52.550
I forgot, that final exam
during final period.

00:09:52.550 --> 00:09:55.440
So the quiz percentages
are 10%, 15%, and 20%.

00:09:55.440 --> 00:09:59.030
Which makes up the other 45%.

00:09:59.030 --> 00:10:00.220
OK.

00:10:00.220 --> 00:10:02.420
Other administrivia.

00:10:02.420 --> 00:10:05.180
Let me just look through
my list here.

00:10:05.180 --> 00:10:07.930
First problem set, problem set
zero, has already been posted.

00:10:07.930 --> 00:10:09.800
This is a really easy one.

00:10:09.800 --> 00:10:11.600
We intend it to be a really
easy problem set.

00:10:11.600 --> 00:10:14.610
It's basically to get you to
load up Python on your machine

00:10:14.610 --> 00:10:17.470
and make sure you understand
how to interact with it.

00:10:17.470 --> 00:10:19.820
The first problem set will be
posted shortly, it's also

00:10:19.820 --> 00:10:23.630
pretty boring-- somewhat like
my lectures but not John's--

00:10:23.630 --> 00:10:25.510
and that means, you know,
we want you just to

00:10:25.510 --> 00:10:26.260
get going on things.

00:10:26.260 --> 00:10:27.980
Don't worry, we're going to make
them more interesting as

00:10:27.980 --> 00:10:28.950
you go along.

00:10:28.950 --> 00:10:31.540
Nonetheless, I want to stress
that none of these problems

00:10:31.540 --> 00:10:33.740
sets are intended
to be lethal.

00:10:33.740 --> 00:10:36.140
We're not using them to weed you
out, we're using them to

00:10:36.140 --> 00:10:36.770
help you learn.

00:10:36.770 --> 00:10:39.850
So if you run into a problem
set that just, you

00:10:39.850 --> 00:10:41.640
don't get, all right?

00:10:41.640 --> 00:10:43.290
Seek help.

00:10:43.290 --> 00:10:46.080
Could be psychiatric help,
could be a TA.

00:10:46.080 --> 00:10:47.830
I recommend the TA.

00:10:47.830 --> 00:10:50.450
My point being, please come
and talk to somebody.

00:10:50.450 --> 00:10:53.310
The problems are set up so that,
if you start down the

00:10:53.310 --> 00:10:55.520
right path, it should be pretty
straight-forward to

00:10:55.520 --> 00:10:56.640
work it through.

00:10:56.640 --> 00:11:00.130
If you start down a plausible
but incorrect path, you can

00:11:00.130 --> 00:11:02.920
sometimes find yourself stuck in
the weeds somewhere, and we

00:11:02.920 --> 00:11:03.980
want to bring you back in.

00:11:03.980 --> 00:11:08.040
So part of the goal here is,
this should not be a grueling,

00:11:08.040 --> 00:11:10.980
exhausting kind of task, it's
really something that should

00:11:10.980 --> 00:11:12.750
be helping you learn
the material.

00:11:12.750 --> 00:11:15.000
If you need help, ask John,
myself, or the TAs.

00:11:15.000 --> 00:11:17.540
That's what we're here for.

00:11:17.540 --> 00:11:18.530
OK.

00:11:18.530 --> 00:11:22.110
We're going to run primarily a
paperless subject, that's why

00:11:22.110 --> 00:11:23.130
the website is there.

00:11:23.130 --> 00:11:24.760
Please check it, that's where
everything's going to be

00:11:24.760 --> 00:11:27.120
posted in terms of things
you need to know.

00:11:27.120 --> 00:11:30.680
In particular, please go to it
today, you will find a form

00:11:30.680 --> 00:11:33.440
there that you need to fill out
to register for, or sign

00:11:33.440 --> 00:11:35.840
up for rather, a recitation.

00:11:35.840 --> 00:11:37.110
Recitations are on Friday.

00:11:37.110 --> 00:11:39.090
Right now, we have them
scheduled at 9:00, 10:00,

00:11:39.090 --> 00:11:41.790
11:00, 12:00, 1:00, and 2:00.

00:11:41.790 --> 00:11:45.480
We may drop one of the
recitations, just depending on

00:11:45.480 --> 00:11:46.610
course size, all right?

00:11:46.610 --> 00:11:48.770
So we reserve the right,
unfortunately, to have to move

00:11:48.770 --> 00:11:49.890
you around.

00:11:49.890 --> 00:11:52.120
My guess is that 9:00 is not
going to be a tremendously

00:11:52.120 --> 00:11:54.510
popular time, but maybe
you'll surprise me.

00:11:54.510 --> 00:11:56.040
Nonetheless, please
go in and sign up.

00:11:56.040 --> 00:11:58.520
We will let you sign up for
whichever recitation makes

00:11:58.520 --> 00:11:59.740
sense for you.

00:11:59.740 --> 00:12:02.180
Again, we reserve the right to
move people around if we have

00:12:02.180 --> 00:12:04.340
to, just to balance load, but we
want you to find something

00:12:04.340 --> 00:12:08.350
that fits your schedule
rather than ours.

00:12:08.350 --> 00:12:09.370
OK.

00:12:09.370 --> 00:12:10.920
Other things.

00:12:10.920 --> 00:12:12.960
There is no required text.

00:12:12.960 --> 00:12:17.420
If you feel exposed without a
text book, you really have to

00:12:17.420 --> 00:12:20.126
have a textbook, you'll find one
recommended-- actually I'm

00:12:20.126 --> 00:12:23.230
going to reuse that word, John,
at least suggest it, on

00:12:23.230 --> 00:12:24.020
the course website.

00:12:24.020 --> 00:12:26.190
I don't think either of us are
thrilled with the text, it's

00:12:26.190 --> 00:12:28.630
the best we've probably found
for Python, it's OK.

00:12:28.630 --> 00:12:29.950
If you need it, it's there.

00:12:29.950 --> 00:12:33.990
But we're going to basically not
rely on any specific text.

00:12:33.990 --> 00:12:34.270
Right.

00:12:34.270 --> 00:12:36.620
Related to that: attendance
here is

00:12:36.620 --> 00:12:38.600
obviously not mandatory.

00:12:38.600 --> 00:12:40.450
You ain't in high
school anymore.

00:12:40.450 --> 00:12:42.900
I think both of us would love to
see your smiling faces, or

00:12:42.900 --> 00:12:44.320
at least your faces,
even if you're not

00:12:44.320 --> 00:12:46.910
smiling at us every day.

00:12:46.910 --> 00:12:49.300
Point I want to make about this,
though, is that we are

00:12:49.300 --> 00:12:52.040
going to cover a lot of material
that is not in the

00:12:52.040 --> 00:12:53.840
assigned readings, and we do
have assigned readings

00:12:53.840 --> 00:12:57.760
associated with each one
of these lectures.

00:12:57.760 --> 00:13:00.900
If you choose not to show up
today-- or sorry, you did

00:13:00.900 --> 00:13:03.000
choose to show up today, if you
choose not to show up in

00:13:03.000 --> 00:13:05.750
future days-- we'll understand,
but please also

00:13:05.750 --> 00:13:08.420
understand that the TAs won't
have a lot of patience with

00:13:08.420 --> 00:13:10.970
you if you're asking a question
about something that

00:13:10.970 --> 00:13:12.910
was either covered in the
readings, or covered in the

00:13:12.910 --> 00:13:14.820
lecture and is pretty
straight forward.

00:13:14.820 --> 00:13:14.930
All right?

00:13:14.930 --> 00:13:16.630
We expect you to behave
responsibly

00:13:16.630 --> 00:13:18.900
and we will as well.

00:13:18.900 --> 00:13:20.950
All right.

00:13:20.950 --> 00:13:22.950
I think the last thing I want
to say is, we will not be

00:13:22.950 --> 00:13:26.110
handing out class notes.

00:13:26.110 --> 00:13:27.920
Now this sounds like a
draconian measure;

00:13:27.920 --> 00:13:29.070
let me tell you why.

00:13:29.070 --> 00:13:31.660
Every study I know of, and I
suspect every one John knows,

00:13:31.660 --> 00:13:35.560
about learning, stresses that
students learn best when they

00:13:35.560 --> 00:13:36.940
take notes.

00:13:36.940 --> 00:13:40.460
Ironically, even if they
never look at them.

00:13:40.460 --> 00:13:40.770
OK.

00:13:40.770 --> 00:13:44.850
The process of writing is
exercising both halves of your

00:13:44.850 --> 00:13:46.840
brain, and it's actually helping
you learn, and so

00:13:46.840 --> 00:13:48.610
taking notes is really
valuable thing.

00:13:48.610 --> 00:13:50.820
Therefore we're not going
to distribute notes.

00:13:50.820 --> 00:13:53.470
What we will distribute for
most lectures is a handout

00:13:53.470 --> 00:13:55.800
that's mostly code examples
that we're going to do.

00:13:55.800 --> 00:13:57.310
I don't happen to have one today
because we're not going

00:13:57.310 --> 00:13:58.410
to do a lot of code.

00:13:58.410 --> 00:13:59.970
We will in future.

00:13:59.970 --> 00:14:02.980
Those notes are going to make
no sense, I'm guessing,

00:14:02.980 --> 00:14:04.870
outside of the lecture,
all right?

00:14:04.870 --> 00:14:08.280
So it's not just, you can swing
by 11:04 and grab a copy

00:14:08.280 --> 00:14:10.150
and go off and catch
some more sleep.

00:14:10.150 --> 00:14:13.120
What we recommend is you use
those notes to take your own

00:14:13.120 --> 00:14:15.910
annotations to help you
understand what's going on,

00:14:15.910 --> 00:14:17.840
but we're not going to
provide class notes.

00:14:17.840 --> 00:14:20.720
We want you to take your own
notes to help you, if you

00:14:20.720 --> 00:14:23.820
like, spur your own
learning process.

00:14:23.820 --> 00:14:24.170
All right.

00:14:24.170 --> 00:14:28.620
And then finally, I want to
stress that John, myself, all

00:14:28.620 --> 00:14:32.120
of the staff, our job is
to help you learn.

00:14:32.120 --> 00:14:32.950
That's what we're here for.

00:14:32.950 --> 00:14:35.000
It's what we get
excited about.

00:14:35.000 --> 00:14:38.080
If you're stuck, if you're
struggling, if you're not

00:14:38.080 --> 00:14:40.930
certain about something,
please ask.

00:14:40.930 --> 00:14:42.950
We're not mind readers, we
can't tell when you're

00:14:42.950 --> 00:14:44.990
struggling, other than sort of
seeing the expression on your

00:14:44.990 --> 00:14:48.180
face, we need your help
in identifying that.

00:14:48.180 --> 00:14:50.070
But all of the TAs, many of whom
are sitting down in the

00:14:50.070 --> 00:14:53.690
front row over here, are here
to help, so come and ask.

00:14:53.690 --> 00:14:56.870
At the same time, remember that
they're students too.

00:14:56.870 --> 00:14:59.010
And if you come and ask a
question that you could have

00:14:59.010 --> 00:15:02.740
easily answered by doing the
reading, coming to lecture, or

00:15:02.740 --> 00:15:05.580
using Google, they're going
to have less patience.

00:15:05.580 --> 00:15:07.430
But helping you understand
things that really are a

00:15:07.430 --> 00:15:10.420
conceptual difficulty is what
they're here for and what

00:15:10.420 --> 00:15:14.080
we're here for, so please
come and talk to us.

00:15:14.080 --> 00:15:15.390
OK.

00:15:15.390 --> 00:15:17.550
That takes care of the
administrivia preamble.

00:15:17.550 --> 00:15:18.420
John, things we add?

00:15:18.420 --> 00:15:34.890
PROFESSOR GUTTAG: Two
more quick things.

00:15:34.890 --> 00:15:35.750
This semester, your class
is being videotaped for

00:15:35.750 --> 00:15:35.780
OpenCourseware.

00:15:35.780 --> 00:15:36.092
If any of you don't want your
image recorded and posted on

00:15:36.092 --> 00:15:38.520
the web, you're supposed to sit
in the back three rows.

00:15:38.520 --> 00:15:39.243
PROFESSOR GRIMSON:
Ah, thank you.

00:15:39.243 --> 00:15:39.390
I forgot.

00:15:39.390 --> 00:15:40.260
PROFESSOR GUTTAG: --Because
the camera may pan.

00:15:40.260 --> 00:15:40.460
I think you're all very
good-looking and give MIT a

00:15:40.460 --> 00:15:40.650
good image, so please, feel
free to be filmed.

00:15:40.650 --> 00:15:45.600
PROFESSOR GRIMSON: I'll turn
around, so if you want to, you

00:15:45.600 --> 00:15:48.050
know, move to the back,
I won't see who moves.

00:15:48.050 --> 00:15:48.340
Right.

00:15:48.340 --> 00:15:48.570
Great.

00:15:48.570 --> 00:15:49.090
Thank you, John.

00:15:49.090 --> 00:15:57.320
PROFESSOR GUTTAG: So that, the
other thing I want to mention

00:15:57.320 --> 00:16:00.130
is, recitations are also
very important.

00:16:00.130 --> 00:16:00.449
We will be covering material in
recitations that're not in

00:16:00.449 --> 00:16:03.108
the lectures, not in the
reading, and we do expect you

00:16:03.108 --> 00:16:03.630
to attend recitations.

00:16:03.630 --> 00:16:04.794
PROFESSOR GRIMSON: Great.

00:16:04.794 --> 00:16:06.210
Thanks, John.

00:16:06.210 --> 00:16:08.050
Any questions about
the administrivia?

00:16:08.050 --> 00:16:10.280
I know it's boring, but we need
to do it so you know what

00:16:10.280 --> 00:16:12.820
the ground rules are.

00:16:12.820 --> 00:16:13.420
Good.

00:16:13.420 --> 00:16:14.280
OK.

00:16:14.280 --> 00:16:16.970
Let's talk about computation.

00:16:16.970 --> 00:16:19.870
As I said, our strategic goal,
our tactical goals, are to

00:16:19.870 --> 00:16:23.280
help you think like a computer
scientist. Another way of

00:16:23.280 --> 00:16:25.350
saying it is, we want to give
you the skill so that you can

00:16:25.350 --> 00:16:28.220
make the computer do what
you want it to do.

00:16:28.220 --> 00:16:30.530
And we hope that at the end of
the class, every time you're

00:16:30.530 --> 00:16:32.990
confronted with some technical
problem, one of your first

00:16:32.990 --> 00:16:35.900
instincts is going to be, "How
do I write the piece of code

00:16:35.900 --> 00:16:37.620
that's going to help
me solve that?"

00:16:37.620 --> 00:16:39.120
So we want to help you
think like a computer

00:16:39.120 --> 00:16:41.990
scientist. All right.

00:16:41.990 --> 00:16:45.970
And that, is an interesting
statement.

00:16:45.970 --> 00:16:55.690
What does it mean, to think
like a computer scientist?

00:16:55.690 --> 00:16:59.100
Well, let's see.

00:16:59.100 --> 00:17:00.480
The primary knowledge you're
going to take away from this

00:17:00.480 --> 00:17:02.630
course is this notion of
computational problem solving,

00:17:02.630 --> 00:17:04.670
this ability to think in

00:17:04.670 --> 00:17:07.590
computational modes of thought.

00:17:07.590 --> 00:17:10.890
And unlike in a lot of
introductory courses, as a

00:17:10.890 --> 00:17:12.870
consequence, having the ability
to memorize is not

00:17:12.870 --> 00:17:13.460
going to help you.

00:17:13.460 --> 00:17:16.260
It's really learning those
notions of the tools that you

00:17:16.260 --> 00:17:18.170
want to use.

00:17:18.170 --> 00:17:19.180
What in the world does
it mean to say

00:17:19.180 --> 00:17:20.450
computational mode of thought?

00:17:20.450 --> 00:17:22.340
It sounds like a hifalutin
phrase you use when you're

00:17:22.340 --> 00:17:24.830
trying to persuade
a VC to fund you.

00:17:24.830 --> 00:17:25.390
Right.

00:17:25.390 --> 00:17:27.530
So to answer this, we really
have to ask a different

00:17:27.530 --> 00:17:31.490
question, a related question;
so, what's computation?

00:17:31.490 --> 00:17:32.690
It's like a strange
statement, right?

00:17:32.690 --> 00:17:35.430
What is computation?

00:17:35.430 --> 00:17:38.840
And part of the reason for
putting it up is that I want

00:17:38.840 --> 00:17:41.500
to, as much as possible,
answer that question by

00:17:41.500 --> 00:17:45.620
separating out the mechanism,
which is the computer, from

00:17:45.620 --> 00:17:47.420
computational thinking.

00:17:47.420 --> 00:17:47.590
Right.

00:17:47.590 --> 00:17:49.570
The artifact should not be
what's driving this.

00:17:49.570 --> 00:17:51.090
It should be the notion of,
"What does it mean to do

00:17:51.090 --> 00:17:53.240
computation?"

00:17:53.240 --> 00:17:56.110
Now, to answer that, I'm going
to back up one more level.

00:17:56.110 --> 00:17:57.900
And I'm going to pose what
sounds like a philosophy

00:17:57.900 --> 00:18:01.070
question, which is, "What is
knowledge?" And you'll see in

00:18:01.070 --> 00:18:02.130
about two minutes why I'm
going to do this.

00:18:02.130 --> 00:18:04.815
But I'm going to suggest that I
can divide knowledge into at

00:18:04.815 --> 00:18:07.060
least two categories.

00:18:07.060 --> 00:18:08.390
OK, and what is knowledge?

00:18:08.390 --> 00:18:12.280
And the two categories I'm going
to divide them into are

00:18:12.280 --> 00:18:19.870
declarative and imperative
knowledge.

00:18:19.870 --> 00:18:20.150
Right.

00:18:20.150 --> 00:18:22.840
What in the world is declarative
knowledge?

00:18:22.840 --> 00:18:25.120
Think of it as statements
of fact.

00:18:25.120 --> 00:18:27.610
It's assertions of truth.

00:18:27.610 --> 00:18:29.740
Boy, in this political season,
that's a really dangerous

00:18:29.740 --> 00:18:30.630
phrase to use, right?

00:18:30.630 --> 00:18:32.920
But it's a statement of fact.

00:18:32.920 --> 00:18:34.350
I'll stay away from the
political comments.

00:18:34.350 --> 00:18:35.930
Let me give you an
example of this.

00:18:35.930 --> 00:18:36.130
Right.

00:18:36.130 --> 00:18:37.830
Here's a declarative
statement.

00:18:37.830 --> 00:18:46.980
The square root of x is that y
such that y squared equals x,

00:18:46.980 --> 00:18:48.940
y's positive.

00:18:48.940 --> 00:18:50.800
You all know that.

00:18:50.800 --> 00:18:52.280
But what I want you to
see here, is that's a

00:18:52.280 --> 00:18:54.550
statement of fact.

00:18:54.550 --> 00:18:55.220
It's a definition.

00:18:55.220 --> 00:18:55.750
It's an axiom.

00:18:55.750 --> 00:19:00.700
It doesn't help you
find square roots.

00:19:00.700 --> 00:19:02.865
If I say x is 2, I want to know,
what's the square root

00:19:02.865 --> 00:19:06.380
of 2, well if you're enough of
a geek, you'll say 1.41529 or

00:19:06.380 --> 00:19:10.340
whatever the heck it is, but in
general, this doesn't help

00:19:10.340 --> 00:19:12.660
you find the square root.

00:19:12.660 --> 00:19:15.600
The closest it does is it would
let you test. You know,

00:19:15.600 --> 00:19:17.290
if you're wandering through
Harvard Square and you see an

00:19:17.290 --> 00:19:19.540
out-of-work Harvard grad,
they're handing out examples

00:19:19.540 --> 00:19:21.450
of square roots, they'll give
you an example and you can

00:19:21.450 --> 00:19:23.666
test it to see, is the
square root of

00:19:23.666 --> 00:19:26.930
2, 1.41529 or whatever.

00:19:26.930 --> 00:19:29.090
I don't even get laughs at
Harvard jokes, John, I'm going

00:19:29.090 --> 00:19:31.550
to stop in a second
here, all right?

00:19:31.550 --> 00:19:33.410
All right, so what am I
trying to say here?

00:19:33.410 --> 00:19:36.560
It doesn't -- yeah, exactly.

00:19:36.560 --> 00:19:38.580
We're staying away from that,
really quickly, especially

00:19:38.580 --> 00:19:39.850
with the cameras rolling.

00:19:39.850 --> 00:19:40.130
All right.

00:19:40.130 --> 00:19:41.260
What am I trying to say?

00:19:41.260 --> 00:19:44.140
It tells you how you might test
something but it doesn't

00:19:44.140 --> 00:19:46.380
tell you how to.

00:19:46.380 --> 00:19:48.330
And that's what imperative
knowledge is.

00:19:48.330 --> 00:19:51.190
Imperative knowledge
is a description of

00:19:51.190 --> 00:19:52.380
how to deduce something.

00:19:52.380 --> 00:19:54.780
So let me give you an
example of a piece

00:19:54.780 --> 00:19:56.510
of imperative knowledge.

00:19:56.510 --> 00:19:58.940
All right, this is actually a
very old piece of imperative

00:19:58.940 --> 00:20:00.970
knowledge for computing square
roots, it's attributed to

00:20:00.970 --> 00:20:04.400
Heron of Alexandria, although I
believe that the Babylonians

00:20:04.400 --> 00:20:07.110
are suspected of knowing
it beforehand.

00:20:07.110 --> 00:20:09.860
But here is a piece of
imperative knowledge.

00:20:09.860 --> 00:20:10.830
All right?

00:20:10.830 --> 00:20:17.540
I'm going to start with a guess,
I'm going to call it g.

00:20:17.540 --> 00:20:26.910
And then I'm going to say, if g
squared is close to x, stop.

00:20:26.910 --> 00:20:28.530
And return g.

00:20:28.530 --> 00:20:30.560
It's a good enough answer.

00:20:30.560 --> 00:20:38.850
Otherwise, I'm going to get a
new guess by taking g, x over

00:20:38.850 --> 00:20:42.880
g, adding them, and
dividing by two.

00:20:42.880 --> 00:20:44.610
Then you take the average
of g and x over g.

00:20:44.610 --> 00:20:47.080
Don't worry about how came
about, Heron found this out.

00:20:47.080 --> 00:20:56.210
But that gives me a new guess,
and I'm going to repeat.

00:20:56.210 --> 00:20:58.680
That's a recipe.

00:20:58.680 --> 00:21:01.840
That's a description
of a set of steps.

00:21:01.840 --> 00:21:04.030
Notice what it has, it has a
bunch of nice things that we

00:21:04.030 --> 00:21:05.210
want to use, right?

00:21:05.210 --> 00:21:08.750
It's a sequence of specific
instructions

00:21:08.750 --> 00:21:10.790
that I do in order.

00:21:10.790 --> 00:21:13.600
Along the way I have some tests,
and depending on the

00:21:13.600 --> 00:21:17.040
value of that test, I may change
where I am in that

00:21:17.040 --> 00:21:18.570
sequence of instructions.

00:21:18.570 --> 00:21:20.460
And it has an end test,
something that tells me when

00:21:20.460 --> 00:21:22.350
I'm done and what
the answer is.

00:21:22.350 --> 00:21:24.480
This tells you how to
find square roots.

00:21:24.480 --> 00:21:25.300
it's how-to knowledge.

00:21:25.300 --> 00:21:27.530
It's imperative knowledge.

00:21:27.530 --> 00:21:27.800
All right.

00:21:27.800 --> 00:21:31.060
That's what computation
basically is about.

00:21:31.060 --> 00:21:35.930
We want to have ways of
capturing this process.

00:21:35.930 --> 00:21:37.780
OK, and that leads now to an
interesting question, which

00:21:37.780 --> 00:21:43.290
would be, "How do I build a
mechanical process to capture

00:21:43.290 --> 00:21:46.910
that set of computations?" So
I'm going to suggest that

00:21:46.910 --> 00:21:50.030
there's an easy way to do it--

00:21:50.030 --> 00:21:53.474
I realized I did the boards in
the wrong order here-- one of

00:21:53.474 --> 00:21:55.460
the ways I could do it is, you
could imagine building a

00:21:55.460 --> 00:21:57.630
little circuit to do this.

00:21:57.630 --> 00:22:00.080
If I had a couple of elements of
stored values in it, I had

00:22:00.080 --> 00:22:02.100
some wires to move things
around, I had a little thing

00:22:02.100 --> 00:22:05.000
to do addition, little thing
to do division, and a

00:22:05.000 --> 00:22:07.160
something to do the testing, I
could build a little circuit

00:22:07.160 --> 00:22:09.700
that would actually do
this computation.

00:22:09.700 --> 00:22:11.860
OK.

00:22:11.860 --> 00:22:15.410
That, strange as it sounds, is
actually an example of the

00:22:15.410 --> 00:22:18.440
earliest computers, because the
earliest computers were

00:22:18.440 --> 00:22:31.750
what we call fixed-program
computers, meaning that they

00:22:31.750 --> 00:22:34.890
had a piece of circuitry
designed to do a specific

00:22:34.890 --> 00:22:35.395
computation.

00:22:35.395 --> 00:22:38.200
And that's what they would do:
they would do that specific

00:22:38.200 --> 00:22:40.060
computation.

00:22:40.060 --> 00:22:41.300
You've seen these
a lot, right?

00:22:41.300 --> 00:22:47.540
A good example of this:
calculator.

00:22:47.540 --> 00:22:51.610
It's basically an example of
a fixed-program computer.

00:22:51.610 --> 00:22:53.460
It does arithmetic.

00:22:53.460 --> 00:22:55.860
If you want play video games
on it, good luck.

00:22:55.860 --> 00:22:58.130
If you want to do word
processing on it, good luck.

00:22:58.130 --> 00:23:00.690
It's designed to do
a specific thing.

00:23:00.690 --> 00:23:03.400
It's a fixed-program computer.

00:23:03.400 --> 00:23:05.710
In fact, a lot of the other
really interesting early ones

00:23:05.710 --> 00:23:09.970
similarly have this flavor, to
give an example: I never know

00:23:09.970 --> 00:23:14.310
how to pronounce this,
Atanasoff, 1941.

00:23:14.310 --> 00:23:16.340
One of the earliest
computational things was a

00:23:16.340 --> 00:23:18.870
thing designed by a guy named
Atanasoff, and it basically

00:23:18.870 --> 00:23:22.750
solved linear equations.

00:23:22.750 --> 00:23:26.030
Handy thing to do if you're
doing 1801, all right, or

00:23:26.030 --> 00:23:29.330
1806, or whatever you want
to do those things in.

00:23:29.330 --> 00:23:31.730
All it could do, though, was
solve those equations.

00:23:31.730 --> 00:23:36.200
One of my favorite examples of
an early computer was done by

00:23:36.200 --> 00:23:39.300
Alan Turing, one of the great
computer scientists of all

00:23:39.300 --> 00:23:43.580
time, called the bombe, which
was designed to break codes.

00:23:43.580 --> 00:23:45.110
It was actually used during
WWII to break

00:23:45.110 --> 00:23:46.060
German Enigma codes.

00:23:46.060 --> 00:23:48.520
And what it was designed
to do, was to solve

00:23:48.520 --> 00:23:49.540
that specific problem.

00:23:49.540 --> 00:23:53.140
The point I'm trying to make is,
fixed-program computers is

00:23:53.140 --> 00:23:55.210
where we started, but it doesn't
really get us to where

00:23:55.210 --> 00:23:55.680
we'd like to be.

00:23:55.680 --> 00:23:58.440
We want to capture this idea
of problem solving.

00:23:58.440 --> 00:24:01.260
So let's see how
we'd get there.

00:24:01.260 --> 00:24:05.390
So even within this framework
of, given a description of a

00:24:05.390 --> 00:24:08.460
computation as a set of steps,
in the idea that I could build

00:24:08.460 --> 00:24:10.410
a circuit to do it, let me
suggest for you what would be

00:24:10.410 --> 00:24:13.340
a wonderful circuit to build.

00:24:13.340 --> 00:24:15.080
Suppose you could build a
circuit with the following

00:24:15.080 --> 00:24:18.580
property: the input to this
circuit would be any other

00:24:18.580 --> 00:24:20.370
circuit diagram.

00:24:20.370 --> 00:24:22.680
Give it a circuit diagram for
some computation, you give it

00:24:22.680 --> 00:24:26.270
to the circuit, and that circuit
would wonderfully

00:24:26.270 --> 00:24:30.990
reconfigure itself to act like
the circuits diagram.

00:24:30.990 --> 00:24:33.000
Which would mean, it could
act like a calculator.

00:24:33.000 --> 00:24:35.150
Or, it could act like
Turing's bombe.

00:24:35.150 --> 00:24:38.070
Or, it could act like a
square root machine.

00:24:38.070 --> 00:24:39.360
So what would that circuit
look like?

00:24:39.360 --> 00:24:42.200
You can imagine these tiny
little robots wandering

00:24:42.200 --> 00:24:42.700
around, right?

00:24:42.700 --> 00:24:44.860
Pulling wires and pulling
out components and

00:24:44.860 --> 00:24:45.710
stacking them together.

00:24:45.710 --> 00:24:47.990
How would you build a circuit
that could take a circuit

00:24:47.990 --> 00:24:53.030
diagram in and make a machine
act like that circuit?

00:24:53.030 --> 00:24:55.170
Sounds like a neat challenge.

00:24:55.170 --> 00:24:59.010
Let me change the
game slightly.

00:24:59.010 --> 00:25:02.160
Suppose instead, I want a
machine that can take a

00:25:02.160 --> 00:25:07.350
recipe, the description of a
sequence of steps, take that

00:25:07.350 --> 00:25:12.230
as its input, and then that
machine will now act like what

00:25:12.230 --> 00:25:15.240
is described in that recipe.

00:25:15.240 --> 00:25:17.590
Reconfigure itself, emulate it,
however you want to use

00:25:17.590 --> 00:25:19.780
the words, it's going to
change how it does the

00:25:19.780 --> 00:25:21.900
computation.

00:25:21.900 --> 00:25:23.830
That would be cool.

00:25:23.830 --> 00:25:24.890
And that exists.

00:25:24.890 --> 00:25:26.240
It's called an interpreter.

00:25:26.240 --> 00:25:29.460
It is the basic heart
of every computer.

00:25:29.460 --> 00:25:33.330
What it is doing, is saying,
change the game.

00:25:33.330 --> 00:25:40.820
This is now an example of a
stored-program computer.

00:25:40.820 --> 00:25:48.990
What that means, in a
stored-program computer, is

00:25:48.990 --> 00:25:51.920
that I can provide to the
computer a sequence of

00:25:51.920 --> 00:25:55.520
instructions describing the
process I want it to execute.

00:25:55.520 --> 00:25:58.150
And inside of the machine, and
things we'll talk about, there

00:25:58.150 --> 00:26:02.190
is a process that will allow
that sequence to be executed

00:26:02.190 --> 00:26:06.130
as described in that recipe,
so it can behave like any

00:26:06.130 --> 00:26:09.920
thing that I can describe
in one of those recipes.

00:26:09.920 --> 00:26:10.810
All right.

00:26:10.810 --> 00:26:14.115
That actually seems like a
really nice thing to have, and

00:26:14.115 --> 00:26:19.210
so let me show you what that
would basically look like.

00:26:19.210 --> 00:26:22.990
Inside of a stored-program
computer, we would have the

00:26:22.990 --> 00:26:31.650
following: we have a memory,
it's connected to two things;

00:26:31.650 --> 00:26:37.870
control unit, in what's called
an ALU, an arithmetic logic

00:26:37.870 --> 00:26:46.460
unit, and this can take in
input, and spit out output,

00:26:46.460 --> 00:26:50.080
and inside this stored-program
computer, excuse me, you have

00:26:50.080 --> 00:26:55.140
the following: you have a
sequence of instructions.

00:26:55.140 --> 00:27:03.720
And these all get
stored in there.

00:27:03.720 --> 00:27:05.280
Notice the difference.

00:27:05.280 --> 00:27:07.550
The recipe, the sequence of
instructions, is actually

00:27:07.550 --> 00:27:10.020
getting read in, and it's
treated just like data.

00:27:10.020 --> 00:27:12.770
It's inside the memory of the
machine, which means we have

00:27:12.770 --> 00:27:15.500
access to it, we can change it,
we can use it to build new

00:27:15.500 --> 00:27:19.210
pieces of code, as well as
we can interpret it.

00:27:19.210 --> 00:27:21.400
One other piece that goes
into this computer--

00:27:21.400 --> 00:27:23.720
I never remember where to put
the PC, John, control?

00:27:23.720 --> 00:27:25.270
ALU?

00:27:25.270 --> 00:27:26.480
Separate?

00:27:26.480 --> 00:27:29.400
I'll put it separate--
you have a thing

00:27:29.400 --> 00:27:31.280
called a program counter.

00:27:31.280 --> 00:27:34.380
And here's the basis
of the computation.

00:27:34.380 --> 00:27:38.400
That program counter points to
some location in memory,

00:27:38.400 --> 00:27:43.050
typically to the first
instruction in the sequence.

00:27:43.050 --> 00:27:45.390
And those instructions, by the
way, are very simple: they're

00:27:45.390 --> 00:27:48.880
things like, take the value out
of two places in memory,

00:27:48.880 --> 00:27:51.400
and run them through the
multiplier in here, a little

00:27:51.400 --> 00:27:53.340
piece of circuitry, and
stick them back into

00:27:53.340 --> 00:27:54.840
someplace in memory.

00:27:54.840 --> 00:27:57.490
Or take this value out of
memory, run it through some

00:27:57.490 --> 00:28:00.570
other simple operation, stick
it back in memory.

00:28:00.570 --> 00:28:03.240
Having executed this
instruction, that counter goes

00:28:03.240 --> 00:28:05.500
up by one and we move
to the next one.

00:28:05.500 --> 00:28:08.670
We execute that instruction,
we move to the next one.

00:28:08.670 --> 00:28:13.960
Oh yeah, it looks a whole
lot like that.

00:28:13.960 --> 00:28:16.760
Some of those instructions will
involve tests: they'll

00:28:16.760 --> 00:28:18.820
say, is something true?

00:28:18.820 --> 00:28:22.120
And if the test is true, it will
change the value of this

00:28:22.120 --> 00:28:25.660
program counter to point to
some other place in the

00:28:25.660 --> 00:28:28.220
memory, some other point in that
sequence of instructions,

00:28:28.220 --> 00:28:30.030
and you'll keep processing.

00:28:30.030 --> 00:28:32.100
Eventually you'll hopefully
stop, and a value gets spit

00:28:32.100 --> 00:28:34.470
out, and you're done.

00:28:34.470 --> 00:28:35.520
That's the heart
of a computer.

00:28:35.520 --> 00:28:37.140
Now that's a slight
misstatement.

00:28:37.140 --> 00:28:39.490
The process to control it is
intriguing and interesting,

00:28:39.490 --> 00:28:42.720
but the heart of the computer is
simply this notion that we

00:28:42.720 --> 00:28:46.190
build our descriptions, our
recipes, on a sequence of

00:28:46.190 --> 00:28:47.910
primitive instructions.

00:28:47.910 --> 00:28:50.100
And then we have a
flow of control.

00:28:50.100 --> 00:28:51.780
And that flow of control is
what I just described.

00:28:51.780 --> 00:28:53.990
It's moving through a sequence
of instructions, occasionally

00:28:53.990 --> 00:28:57.840
changing where we are
as we move around.

00:28:57.840 --> 00:28:58.200
OK.

00:28:58.200 --> 00:29:02.210
The thing I want you to take
away from this, then, is to

00:29:02.210 --> 00:29:06.840
think of this as, this is,
if you like, a recipe.

00:29:06.840 --> 00:29:19.020
And that's really what
a program is.

00:29:19.020 --> 00:29:21.930
It's a sequence of
instructions.

00:29:21.930 --> 00:29:23.650
Now, one of things I left
hanging is, I said, OK, you

00:29:23.650 --> 00:29:24.520
build it out of primitives.

00:29:24.520 --> 00:29:25.960
So one of the questions is,
well, what are the right

00:29:25.960 --> 00:29:28.100
primitives to use?

00:29:28.100 --> 00:29:31.120
And one of the things that was
useful here is, that we

00:29:31.120 --> 00:29:33.130
actually know that the set of
primitives that you want to

00:29:33.130 --> 00:29:37.390
use is very straight-forward.

00:29:37.390 --> 00:29:39.510
OK, but before I do that, let me
drive home this idea of why

00:29:39.510 --> 00:29:42.090
this is a recipe.

00:29:42.090 --> 00:29:44.380
Assuming I have a set of
primitive instructions that I

00:29:44.380 --> 00:29:47.010
can describe everything on, I
want to know what can I build.

00:29:47.010 --> 00:29:49.710
Well, I'm going to do the same
analogy to a real recipe.

00:29:49.710 --> 00:29:51.360
So, real recipe.

00:29:51.360 --> 00:29:51.850
I don't know.

00:29:51.850 --> 00:29:54.230
Separate six eggs.

00:29:54.230 --> 00:29:55.620
Do something.

00:29:55.620 --> 00:29:57.200
Beat until the-- sorry,
beat the whites

00:29:57.200 --> 00:29:59.240
until they're stiff.

00:29:59.240 --> 00:30:02.030
Do something until an
end test is true.

00:30:02.030 --> 00:30:04.730
Take the yolks and mix them in
with the sugar and water--

00:30:04.730 --> 00:30:05.060
No.

00:30:05.060 --> 00:30:06.825
Sugar and flour I guess is
probably what I want, sugar

00:30:06.825 --> 00:30:08.430
and water is not going to do
anything interesting for me

00:30:08.430 --> 00:30:11.010
here-- mix them into
something else.

00:30:11.010 --> 00:30:13.310
Do a sequence of things.

00:30:13.310 --> 00:30:17.400
A traditional recipe actually
is based on a small set of

00:30:17.400 --> 00:30:21.230
primitives, and a good chef
with, or good cook, I should

00:30:21.230 --> 00:30:23.060
say, with that set of
primitives, can create an

00:30:23.060 --> 00:30:26.040
unbounded number of
great dishes.

00:30:26.040 --> 00:30:28.270
Same thing holds true
in programming.

00:30:28.270 --> 00:30:29.020
Right.

00:30:29.020 --> 00:30:37.560
Given a fixed set of primitives,
all right, a good

00:30:37.560 --> 00:30:43.630
programmer can program
anything.

00:30:43.630 --> 00:30:45.720
And by that, I mean anything
that can be described in one

00:30:45.720 --> 00:30:47.400
of these process, you can
capture in that set of

00:30:47.400 --> 00:30:49.580
primitives.

00:30:49.580 --> 00:30:51.480
All right, the question is, as
I started to say, is, "What

00:30:51.480 --> 00:30:54.220
are the right primitives?" So
there's a little bit of, a

00:30:54.220 --> 00:30:55.830
little piece of history
here, if you like.

00:30:55.830 --> 00:31:01.860
In 1936, that same guy, Alan
Turing, showed that with six

00:31:01.860 --> 00:31:05.850
simple primitives, anything that
could be described in a

00:31:05.850 --> 00:31:08.730
mechanical process, it's
actually algorithmically,

00:31:08.730 --> 00:31:12.990
could be programmed just using
those six primitives.

00:31:12.990 --> 00:31:14.730
Think about that for a second.

00:31:14.730 --> 00:31:16.320
That's an incredible
statement.

00:31:16.320 --> 00:31:20.100
It says, with six primitives,
I can rule the world.

00:31:20.100 --> 00:31:23.470
With six primitives, I
can program anything.

00:31:23.470 --> 00:31:25.620
A couple of really interesting
consequences of that, by the

00:31:25.620 --> 00:31:29.770
way, one of them is, it says,
anything you can do in one

00:31:29.770 --> 00:31:31.920
programming language,
you can do in

00:31:31.920 --> 00:31:33.810
another programming language.

00:31:33.810 --> 00:31:36.440
And there is no programming
language that is better-- well

00:31:36.440 --> 00:31:37.790
actually, that's not quite true,
there are some better at

00:31:37.790 --> 00:31:39.580
doing certain kinds of things--
but there's nothing

00:31:39.580 --> 00:31:43.340
that you can do in C that
you can't do in Fortran.

00:31:43.340 --> 00:31:45.250
It's called Turing
compatibility.

00:31:45.250 --> 00:31:46.890
Anything you can do with one,
you can do with another, it's

00:31:46.890 --> 00:31:49.250
based on that fundamental
result.

00:31:49.250 --> 00:31:50.390
OK.

00:31:50.390 --> 00:31:53.310
Now, fortunately we're not going
to start with Turing's

00:31:53.310 --> 00:31:56.600
six primitives, this would be
really painful programming,

00:31:56.600 --> 00:31:59.770
because they're down at the
level of, "take this value and

00:31:59.770 --> 00:32:01.550
write it onto this tape." First
of all, we don't have

00:32:01.550 --> 00:32:04.330
tapes anymore in computers, and
even if we did, you don't

00:32:04.330 --> 00:32:05.780
want to be programming
at that level.

00:32:05.780 --> 00:32:07.410
What we're going to see with
programming language is that

00:32:07.410 --> 00:32:09.370
we're going to use higher-level
abstracts.

00:32:09.370 --> 00:32:12.170
A broader set of primitives,
but nonetheless the same

00:32:12.170 --> 00:32:13.150
fundamental thing holds.

00:32:13.150 --> 00:32:16.570
With those six primitives,
you can do it.

00:32:16.570 --> 00:32:18.080
OK.

00:32:18.080 --> 00:32:19.920
So where are we here?

00:32:19.920 --> 00:32:22.410
What we're saying is, in order
to do computation, we want to

00:32:22.410 --> 00:32:24.820
describe recipes, we want to
describe this sequence of

00:32:24.820 --> 00:32:28.110
steps built on some primitives,
and we want to

00:32:28.110 --> 00:32:30.520
describe the flow of control
that goes through those

00:32:30.520 --> 00:32:33.210
sequence of steps
as we carry on.

00:32:33.210 --> 00:32:35.050
So the last thing we need before
we can start talking

00:32:35.050 --> 00:32:36.500
about real programming
is, we need to

00:32:36.500 --> 00:32:39.030
describe those recipes.

00:32:39.030 --> 00:32:41.330
All right, And to describe
the recipes, we're

00:32:41.330 --> 00:32:54.180
going to want a language.

00:32:54.180 --> 00:32:57.860
We need to know not only what
are the primitives, but how do

00:32:57.860 --> 00:33:01.960
we make things meaningful
in that language.

00:33:01.960 --> 00:33:03.080
Language.

00:33:03.080 --> 00:33:05.680
There we go.

00:33:05.680 --> 00:33:07.510
All right.

00:33:07.510 --> 00:33:08.680
Now, it turns out there are--

00:33:08.680 --> 00:33:09.820
I don't know, John, hundreds?

00:33:09.820 --> 00:33:10.220
Thousands?

00:33:10.220 --> 00:33:11.470
Of programming languages?

00:33:11.470 --> 00:33:13.410
At least hundreds-- of
programming languages around.

00:33:13.410 --> 00:33:16.065
PROFESSOR JOHN GUTTAG:
[UNINTELLIGIBLE]

00:33:16.065 --> 00:33:16.492
PROFESSOR ERIC GRIMSON: True.

00:33:16.492 --> 00:33:18.620
Thank you.

00:33:18.620 --> 00:33:20.120
You know, they all
have, you know,

00:33:20.120 --> 00:33:21.290
their pluses and minuses.

00:33:21.290 --> 00:33:23.910
I have to admit, in my career
here, I think I've taught in

00:33:23.910 --> 00:33:26.080
at least three languages, I
suspect you've taught more,

00:33:26.080 --> 00:33:27.570
five or six, John?

00:33:27.570 --> 00:33:29.600
Both of us have probably
programmed in more than those

00:33:29.600 --> 00:33:31.700
number of languages, at least
programmed that many, since we

00:33:31.700 --> 00:33:33.840
taught in those languages.

00:33:33.840 --> 00:33:35.040
One of the things you
want to realize is,

00:33:35.040 --> 00:33:36.930
there is no best language.

00:33:36.930 --> 00:33:38.630
At least I would argue that,
I think John would agree.

00:33:38.630 --> 00:33:40.860
We might both agree we have
our own nominees for worst

00:33:40.860 --> 00:33:43.120
language, there are
some of those.

00:33:43.120 --> 00:33:44.750
There is no best language.

00:33:44.750 --> 00:33:44.920
All right?

00:33:44.920 --> 00:33:46.380
They all are describing
different things.

00:33:46.380 --> 00:33:48.873
Having said that, some of them
are better suited for some

00:33:48.873 --> 00:33:51.400
things than others.

00:33:51.400 --> 00:33:55.970
Anybody here heard of MATLAB
Maybe programmed in MATLAB?

00:33:55.970 --> 00:33:58.220
It's great for doing things with
vectors and matrices and

00:33:58.220 --> 00:34:01.630
things that are easily captured
in that framework.

00:34:01.630 --> 00:34:02.710
But there's some things
that are a real

00:34:02.710 --> 00:34:03.490
pain to do in MATLAB.

00:34:03.490 --> 00:34:05.670
So MATLAB's great for
that kind of thing.

00:34:05.670 --> 00:34:07.850
C is a great language for
programming things that

00:34:07.850 --> 00:34:10.620
control data networks,
for example.

00:34:10.620 --> 00:34:12.860
I happen to be, and John
teases me about this

00:34:12.860 --> 00:34:14.920
regularly, I'm an old-time Lisp
programmer, and that's

00:34:14.920 --> 00:34:16.710
how I was trained.

00:34:16.710 --> 00:34:19.190
And I happen to like Lisp and
Scheme, it's a great language

00:34:19.190 --> 00:34:20.970
when you're trying to deal with
problems where you have

00:34:20.970 --> 00:34:23.400
arbitrarily structured
data sets.

00:34:23.400 --> 00:34:25.550
It's particularly
good at that.

00:34:25.550 --> 00:34:27.800
So the point I want to make
here is that there's no

00:34:27.800 --> 00:34:30.330
particularly best language.

00:34:30.330 --> 00:34:32.350
What we're going to do is simply
use a language that

00:34:32.350 --> 00:34:33.060
helps us understand.

00:34:33.060 --> 00:34:34.620
So in this course, the
language we're

00:34:34.620 --> 00:34:38.060
going to use is Python.

00:34:38.060 --> 00:34:39.490
Which is a pretty new language,
it's growing in

00:34:39.490 --> 00:34:42.580
popularity, it has a lot of
the elements of some other

00:34:42.580 --> 00:34:44.750
languages because it's more
recent, it inherits things

00:34:44.750 --> 00:34:48.390
from it's pregenitors,
if you like.

00:34:48.390 --> 00:34:50.270
But one of the things I want to
stress is, this course is

00:34:50.270 --> 00:34:54.310
not about Python.

00:34:54.310 --> 00:34:55.500
Strange statement.

00:34:55.500 --> 00:34:58.000
You do need to know how to use
it, but it's not about the

00:34:58.000 --> 00:35:00.330
details of, where do the
semi-colons go in Python.

00:35:00.330 --> 00:35:02.400
All right?

00:35:02.400 --> 00:35:04.050
It's about using it to think.

00:35:04.050 --> 00:35:06.520
And what you should take away
from this course is having

00:35:06.520 --> 00:35:10.470
learned how to design recipes,
how to structure recipes, how

00:35:10.470 --> 00:35:13.120
to do things in modes
in Python.

00:35:13.120 --> 00:35:15.045
Those same tools
easily transfer

00:35:15.045 --> 00:35:16.790
to any other language.

00:35:16.790 --> 00:35:18.640
You can pick up another language
in a week, couple of

00:35:18.640 --> 00:35:22.640
weeks at most, once you
know how to do Python.

00:35:22.640 --> 00:35:23.280
OK.

00:35:23.280 --> 00:35:25.420
In order to talk about Python
and languages, I want to do

00:35:25.420 --> 00:35:28.250
one last thing to set the stage
for what we're going to

00:35:28.250 --> 00:35:30.510
do here, and that's to talk
about the different dimensions

00:35:30.510 --> 00:35:31.650
of a language.

00:35:31.650 --> 00:35:33.560
And there're three I
want to deal with.

00:35:33.560 --> 00:35:35.660
The first one is, whether
this is a high-level

00:35:35.660 --> 00:35:41.120
or low-level language.

00:35:41.120 --> 00:35:42.830
That basically says,
how close are you

00:35:42.830 --> 00:35:43.770
the guts of the machine?

00:35:43.770 --> 00:35:45.950
A low-level language, we used
to call this assembly

00:35:45.950 --> 00:35:48.200
programming, you're down at the
level of, your primitives

00:35:48.200 --> 00:35:51.340
are literally moving pieces of
data from one location of

00:35:51.340 --> 00:35:54.080
memory to another, through
a very simple operation.

00:35:54.080 --> 00:35:57.100
A high-level language, the
designer has created a much

00:35:57.100 --> 00:35:59.530
richer set of primitive
things.

00:35:59.530 --> 00:36:02.230
In a high-level language, square
root might simply be a

00:36:02.230 --> 00:36:04.200
primitive that you can use,
rather than you having to go

00:36:04.200 --> 00:36:06.010
over and code it.

00:36:06.010 --> 00:36:08.540
And there're trade-offs
between both.

00:36:08.540 --> 00:36:12.710
Second dimension is, whether
this is a general versus a

00:36:12.710 --> 00:36:15.980
targeted language.

00:36:15.980 --> 00:36:18.860
And by that I mean, do the set
of primitives support a broad

00:36:18.860 --> 00:36:22.130
range of applications, or is
it really aimed at a very

00:36:22.130 --> 00:36:23.410
specific set of applications?

00:36:23.410 --> 00:36:25.710
I'd argue that MATLAB is
basically a targeted language,

00:36:25.710 --> 00:36:29.470
it's targeted at matrices and
vectors and things like that.

00:36:29.470 --> 00:36:31.540
And the third one I want to
point out is, whether this is

00:36:31.540 --> 00:36:41.810
an interpreted versus
a compiled language.

00:36:41.810 --> 00:36:44.440
What that basically says
is the following: in an

00:36:44.440 --> 00:36:46.760
interpreted language, you take
what's called the source code,

00:36:46.760 --> 00:36:49.740
the thing you write, it may go
through a simple checker but

00:36:49.740 --> 00:36:52.270
it basically goes to the
interpreter, that thing inside

00:36:52.270 --> 00:36:54.210
the machine that's going to
control the flow of going

00:36:54.210 --> 00:36:55.970
through each one of
the instructions,

00:36:55.970 --> 00:36:57.400
and give you an output.

00:36:57.400 --> 00:37:00.420
So the interpreter is simply
operating directly on your

00:37:00.420 --> 00:37:02.430
code at run time.

00:37:02.430 --> 00:37:05.050
In a compiled language, you have
an intermediate step, in

00:37:05.050 --> 00:37:07.370
which you take the source code,
it runs through what's

00:37:07.370 --> 00:37:10.240
called a checker or a compiler
or both, and it creates what's

00:37:10.240 --> 00:37:11.890
called object code.

00:37:11.890 --> 00:37:16.250
And that does two things: one,
it helps catch bugs in your

00:37:16.250 --> 00:37:19.160
code, and secondly it often
converts it into a more

00:37:19.160 --> 00:37:21.970
efficient sequence of
instructions before you

00:37:21.970 --> 00:37:24.000
actually go off and run it.

00:37:24.000 --> 00:37:24.190
All right?

00:37:24.190 --> 00:37:25.400
And there's trade-offs
between both.

00:37:25.400 --> 00:37:27.520
I mean, an interpreted language
is often easier to

00:37:27.520 --> 00:37:30.280
debug, because you can still see
your raw code there, but

00:37:30.280 --> 00:37:32.680
it's not always as fast. A
compiled language is usually

00:37:32.680 --> 00:37:34.770
much faster in terms
of its execution.

00:37:34.770 --> 00:37:37.900
And it's one of the things you
may want to trade off.

00:37:37.900 --> 00:37:38.120
Right.

00:37:38.120 --> 00:37:43.300
In the case of Python, it's
a high-level language.

00:37:43.300 --> 00:37:45.660
I would argue, I think John
would agree with me, it's

00:37:45.660 --> 00:37:47.095
basically a general-purpose
language.

00:37:47.095 --> 00:37:50.010
It happens to be better suited
for manipulating strings than

00:37:50.010 --> 00:37:51.770
numbers, for example,
but it's really a

00:37:51.770 --> 00:37:53.490
general-purpose language.

00:37:53.490 --> 00:37:55.003
And it's primarily--

00:37:55.003 --> 00:37:58.100
I shouldn't say primarily, it
is an interpreted language.

00:37:58.100 --> 00:37:59.360
OK?

00:37:59.360 --> 00:38:03.000
As a consequence, it's not as
good as helping debug, but it

00:38:03.000 --> 00:38:04.370
does let you-- sorry, that's the
wrong way of saying-- it's

00:38:04.370 --> 00:38:07.280
not as good at catching some
things before you run them, it

00:38:07.280 --> 00:38:09.030
is easier at some times
in debugging as you go

00:38:09.030 --> 00:38:11.470
along on the fly.

00:38:11.470 --> 00:38:11.800
OK.

00:38:11.800 --> 00:38:13.410
So what does Python look like?

00:38:13.410 --> 00:38:15.766
In order to talk about Python--
actually, I'm going

00:38:15.766 --> 00:38:22.170
to do it this way-- we need
to talk about how to

00:38:22.170 --> 00:38:22.860
write things in Python.

00:38:22.860 --> 00:38:26.070
Again, you have to let me back
up slightly and set the stage.

00:38:26.070 --> 00:38:28.820
Our goal is to build recipes.

00:38:28.820 --> 00:38:29.960
You're all going to be
great chefs by the

00:38:29.960 --> 00:38:30.660
time you're done here.

00:38:30.660 --> 00:38:32.150
All right?

00:38:32.150 --> 00:38:35.550
Our goal is to take problems and
break them down into these

00:38:35.550 --> 00:38:37.890
computational steps, these
sequence of instructions

00:38:37.890 --> 00:38:40.460
that'll allow us to capture
that process.

00:38:40.460 --> 00:38:42.690
To do that, we need to describe:
not only, what are

00:38:42.690 --> 00:38:45.630
the primitives, but how do we
capture things legally in that

00:38:45.630 --> 00:38:47.420
language, and interact
with the computer?

00:38:47.420 --> 00:38:49.450
And so for that, we
need a language.

00:38:49.450 --> 00:38:51.190
We're about to start talking
about the elements of the

00:38:51.190 --> 00:38:54.000
language, but to do that, we
also need to separate out one

00:38:54.000 --> 00:38:58.290
last piece of distinction.

00:38:58.290 --> 00:38:59.780
Just like with a natural
language, we're going to

00:38:59.780 --> 00:39:02.910
separate out syntax
versus semantics.

00:39:02.910 --> 00:39:03.600
So what's syntax?

00:39:03.600 --> 00:39:09.750
Syntax basically says, what are
the legal expressions in

00:39:09.750 --> 00:39:16.960
this language?

00:39:16.960 --> 00:39:22.910
Boy, my handwriting is
atrocious, isn't it?

00:39:22.910 --> 00:39:25.890
There's a English sequence
of words.

00:39:25.890 --> 00:39:27.750
It's not since syntactically
correct, right?

00:39:27.750 --> 00:39:28.910
It's not a sentence.

00:39:28.910 --> 00:39:30.350
There's no verb in there
anywhere, it's just

00:39:30.350 --> 00:39:31.400
a sequence of nouns.

00:39:31.400 --> 00:39:32.940
Same thing in our languages.

00:39:32.940 --> 00:39:36.670
We have to describe how do you
put together legally formed

00:39:36.670 --> 00:39:38.190
expressions.

00:39:38.190 --> 00:39:39.070
OK?

00:39:39.070 --> 00:39:41.030
And as we add constructs to the
language, we're going to

00:39:41.030 --> 00:39:42.780
talk about.

00:39:42.780 --> 00:39:45.550
Second thing we want to talk
about very briefly as we go

00:39:45.550 --> 00:39:48.680
along is the semantics
of the language.

00:39:48.680 --> 00:39:50.610
And here we're going to break
out two pieces; static

00:39:50.610 --> 00:39:53.230
semantics and full semantics.

00:39:53.230 --> 00:40:01.950
Static semantics basically
says which programs are

00:40:01.950 --> 00:40:05.730
meaningful.

00:40:05.730 --> 00:40:09.090
Which expressions make sense.

00:40:09.090 --> 00:40:17.740
Here's an English sentence.

00:40:17.740 --> 00:40:20.090
It's syntactically correct.

00:40:20.090 --> 00:40:20.300
Right?

00:40:20.300 --> 00:40:23.090
Noun phrase, verb,
noun phrase.

00:40:23.090 --> 00:40:25.460
I'm not certain it's meaningful,
unless you are in

00:40:25.460 --> 00:40:29.620
the habit of giving your
furniture personal names.

00:40:29.620 --> 00:40:30.240
What's the point?

00:40:30.240 --> 00:40:32.770
Again, you can have things that
are syntactically legal

00:40:32.770 --> 00:40:35.870
but not semantically meaningful,
and static

00:40:35.870 --> 00:40:38.980
semantics is going to be a way
of helping us decide what

00:40:38.980 --> 00:40:41.360
expressions, what pieces of
code, actually have real

00:40:41.360 --> 00:40:41.950
meaning to it.

00:40:41.950 --> 00:40:43.450
All right?

00:40:43.450 --> 00:40:47.160
The last piece of it is, in
addition to having static

00:40:47.160 --> 00:40:53.910
semantics, we have sort
of full semantics.

00:40:53.910 --> 00:40:58.170
Which is, what does
the program mean?

00:40:58.170 --> 00:40:59.830
Or, said a different way,
what's going to

00:40:59.830 --> 00:41:08.600
happen when I run it?

00:41:08.600 --> 00:41:09.770
That's the meaning of
the expression.

00:41:09.770 --> 00:41:10.660
That's what you want.

00:41:10.660 --> 00:41:10.790
All right?

00:41:10.790 --> 00:41:13.060
You want to know, what's the
meaning of this piece of code?

00:41:13.060 --> 00:41:14.470
When I run it, what's
going to happen?

00:41:14.470 --> 00:41:16.360
That's what I want to build.

00:41:16.360 --> 00:41:18.200
The reason for pulling this out
is, what you're going to

00:41:18.200 --> 00:41:21.700
see is, that in most languages,
and certainly in

00:41:21.700 --> 00:41:29.090
Python-- we got lots of help
here-- all right, Python comes

00:41:29.090 --> 00:41:31.840
built-in with something that
will check your static, sorry,

00:41:31.840 --> 00:41:33.440
your syntax for you.

00:41:33.440 --> 00:41:37.880
And in fact, as a sidebar, if
you turn in a problem set that

00:41:37.880 --> 00:41:40.510
is not syntactically correct,
there's a simple button that

00:41:40.510 --> 00:41:42.620
you push that will check
your syntax.

00:41:42.620 --> 00:41:44.320
If you've turned in a program
that's not syntactically

00:41:44.320 --> 00:41:46.400
correct, the TAs give
you a zero.

00:41:46.400 --> 00:41:48.040
Because it said you didn't even
take the time to make

00:41:48.040 --> 00:41:49.050
sure the syntax is correct.

00:41:49.050 --> 00:41:50.840
The system will help
you find it.

00:41:50.840 --> 00:41:53.110
In Python, it'll find it,
I think one bug at

00:41:53.110 --> 00:41:53.820
a time, right John?

00:41:53.820 --> 00:41:55.530
It finds one syntax error at
a time, so you have to be a

00:41:55.530 --> 00:41:57.130
little patient to do it,
but you can check that

00:41:57.130 --> 00:41:59.630
the syntax is right.

00:41:59.630 --> 00:42:06.050
You're going to see that we
get some help here on the

00:42:06.050 --> 00:42:08.080
static semantics, and I'm going
to do an example in a

00:42:08.080 --> 00:42:11.860
second, meaning that the system,
some languages are

00:42:11.860 --> 00:42:15.930
better than others on it, but it
will try and help you catch

00:42:15.930 --> 00:42:20.040
some things that are not
semantically correct

00:42:20.040 --> 00:42:21.380
statically.

00:42:21.380 --> 00:42:23.940
In the case of Python, it does
that I think all at run time.

00:42:23.940 --> 00:42:26.670
I'm looking to you again,
John, I think there's no

00:42:26.670 --> 00:42:27.490
pre-time checks.

00:42:27.490 --> 00:42:27.690
Its-- sorry?

00:42:27.690 --> 00:42:28.930
PROFESSOR JOHN GUTTAG:
[UNINTELLIGIBLE]

00:42:28.930 --> 00:42:31.260
PROFESSOR ERIC GRIMSON:
There is some.

00:42:31.260 --> 00:42:32.890
OK.

00:42:32.890 --> 00:42:35.150
Most of them, I think though,
are primarily caught at run

00:42:35.150 --> 00:42:36.990
time, and that's a little bit
of a pain because you don't

00:42:36.990 --> 00:42:38.860
see it until you go and run the
code, and there are some,

00:42:38.860 --> 00:42:40.590
actually we're going to see an
example I think in a second

00:42:40.590 --> 00:42:43.800
where you find it, but you
do get some help there.

00:42:43.800 --> 00:42:47.250
The problem is, things that you
catch here are actually

00:42:47.250 --> 00:42:49.800
the least worrisome bugs.

00:42:49.800 --> 00:42:52.800
They're easy to spot, you can't
run the program with

00:42:52.800 --> 00:42:55.770
them there, so you're not going
to get weird answers.

00:42:55.770 --> 00:42:58.190
Not everything is going
to get caught in

00:42:58.190 --> 00:42:59.360
static semantics checking.

00:42:59.360 --> 00:43:00.790
Some things are going to
slide through, and

00:43:00.790 --> 00:43:03.040
that's actually a bother.

00:43:03.040 --> 00:43:04.060
It's a problem.

00:43:04.060 --> 00:43:07.280
Because it says, your program
will still give you a value,

00:43:07.280 --> 00:43:10.010
but it may not be what you
intended, and you can't always

00:43:10.010 --> 00:43:12.260
tell, and that may propagate
it's way down through a whole

00:43:12.260 --> 00:43:14.600
bunch of other computations
before it causes some

00:43:14.600 --> 00:43:16.400
catastrophic failure.

00:43:16.400 --> 00:43:19.290
So actually, the problem with
static semantics is you'd like

00:43:19.290 --> 00:43:21.890
it to catch everything, you
don't always get it.

00:43:21.890 --> 00:43:23.550
Sadly we don't get
much help here.

00:43:23.550 --> 00:43:25.390
Which is where we'd like it.

00:43:25.390 --> 00:43:27.440
But that's part of your job.

00:43:27.440 --> 00:43:27.780
OK.

00:43:27.780 --> 00:43:30.130
What happens if you actually
have something that's both

00:43:30.130 --> 00:43:32.880
syntactically correct, and
appears to have correct static

00:43:32.880 --> 00:43:33.780
semantics, and you run it?

00:43:33.780 --> 00:43:37.990
It could run and give you the
right answer, it could crash,

00:43:37.990 --> 00:43:43.070
it could loop forever, it could
run and apparently give

00:43:43.070 --> 00:43:45.270
you the right answer.

00:43:45.270 --> 00:43:47.410
And you're not always going
to be able to tell.

00:43:47.410 --> 00:43:49.080
Well, you'll know when it
crashes, that doesn't help you

00:43:49.080 --> 00:43:51.020
very much, but you can't
always tell whether

00:43:51.020 --> 00:43:52.760
something's stuck in an infinite
loop or whether it's

00:43:52.760 --> 00:43:54.880
simply taking a long
time to compute.

00:43:54.880 --> 00:43:57.240
You'd love to have a system that
spots that for you, but

00:43:57.240 --> 00:43:58.780
it's not possible.

00:43:58.780 --> 00:44:00.620
And so to deal with
this last one, you

00:44:00.620 --> 00:44:02.630
need to develop style.

00:44:02.630 --> 00:44:06.210
All right?

00:44:06.210 --> 00:44:09.420
Meaning, we're going to try to
help you with how to develop

00:44:09.420 --> 00:44:12.500
good programming style, but you
need to write in a way in

00:44:12.500 --> 00:44:15.630
which it is going to be easy
for you to spot the places

00:44:15.630 --> 00:44:19.940
that cause those semantic
bugs to occur.

00:44:19.940 --> 00:44:20.380
All right.

00:44:20.380 --> 00:44:23.610
If that sounds like a really
long preamble, it is.

00:44:23.610 --> 00:44:24.710
Let's start with Python.

00:44:24.710 --> 00:44:28.270
But again, my goal here is to
let you see what computation's

00:44:28.270 --> 00:44:30.290
about, why we need to do it,
I'm going to remind you one

00:44:30.290 --> 00:44:32.820
last time, our goal is to
be able to have a set of

00:44:32.820 --> 00:44:35.590
primitives that we combine
into complex expressions,

00:44:35.590 --> 00:44:38.820
which we can then abstract to
treat as primitives, and we

00:44:38.820 --> 00:44:43.100
want to use that sequence of
instructions in this flow of

00:44:43.100 --> 00:44:47.220
control computing, in order
to deduce new information.

00:44:47.220 --> 00:44:50.530
That imperative knowledge that
we talked about right there.

00:44:50.530 --> 00:44:52.850
So I'm going to start today,
we have about five or ten

00:44:52.850 --> 00:44:54.580
minutes left, I think, in
order-- sorry, five minutes

00:44:54.580 --> 00:44:56.500
left-- in order to do this
with some beginnings of

00:44:56.500 --> 00:44:58.970
Python, and we're going to pick
this up obviously, next

00:44:58.970 --> 00:45:02.730
time, so; simple parts
of Python.

00:45:02.730 --> 00:45:04.710
In order to create any kinds of
expressions, we're going to

00:45:04.710 --> 00:45:06.640
need values.

00:45:06.640 --> 00:45:07.780
Primitive data elements.

00:45:07.780 --> 00:45:13.520
And in Python, we have two to
start with; we have numbers,

00:45:13.520 --> 00:45:16.580
and we have strings.

00:45:16.580 --> 00:45:18.720
Numbers is what you'd expect.

00:45:18.720 --> 00:45:21.200
There's a number.

00:45:21.200 --> 00:45:21.920
There's another number.

00:45:21.920 --> 00:45:24.030
All right?

00:45:24.030 --> 00:45:28.400
Strings are captured in Python
with an open quote and some

00:45:28.400 --> 00:45:33.030
sequence of characters followed
by a closed quote.

00:45:33.030 --> 00:45:37.340
Associated with every data
type in Python is a type,

00:45:37.340 --> 00:45:40.040
which identifies the kind
of thing it is.

00:45:40.040 --> 00:45:41.390
Some of these are obvious.

00:45:41.390 --> 00:45:44.960
Strings are just a type
on their own.

00:45:44.960 --> 00:45:46.630
But for numbers, for example,
we can have

00:45:46.630 --> 00:45:47.980
a variety of types.

00:45:47.980 --> 00:45:49.530
So this is something that
we would call an

00:45:49.530 --> 00:45:50.780
integer, or an INT.

00:45:50.780 --> 00:45:54.300
And this is something
we would call a

00:45:54.300 --> 00:45:57.130
floating point, or a float.

00:45:57.130 --> 00:45:59.480
Or if you want to think of
it as a real number.

00:45:59.480 --> 00:46:01.690
And there's some others
that we can see.

00:46:01.690 --> 00:46:04.380
We're going to build up this
taxonomy if you like, but the

00:46:04.380 --> 00:46:07.180
reason it's relevant is,
associated with each one of

00:46:07.180 --> 00:46:11.130
those types is a set of
operators that expect certain

00:46:11.130 --> 00:46:13.370
types of input in order
to do their job.

00:46:13.370 --> 00:46:16.480
And given those types of input,
will get back output.

00:46:16.480 --> 00:46:17.050
All right.

00:46:17.050 --> 00:46:19.590
In order to deal with this, let
me show you an example,

00:46:19.590 --> 00:46:21.880
and I hope that comes
up, great.

00:46:21.880 --> 00:46:25.040
What I have here is a Python
shell, and I'm going to just

00:46:25.040 --> 00:46:27.570
show you some simple examples
of how we start building

00:46:27.570 --> 00:46:28.370
expressions.

00:46:28.370 --> 00:46:30.550
And this'll lead into what
you're going to see next time

00:46:30.550 --> 00:46:32.610
as well as what you're
going to do tomorrow.

00:46:32.610 --> 00:46:33.710
So.

00:46:33.710 --> 00:46:37.480
Starting with the shell, I
can type in expressions.

00:46:37.480 --> 00:46:38.870
Actually, let me back up
and do this in video.

00:46:38.870 --> 00:46:42.630
I can type in a number, I get
back a number, I can type in a

00:46:42.630 --> 00:46:46.990
string, I get back the string.

00:46:46.990 --> 00:46:49.690
Strings, by the way, can have
spaces in them, they can have

00:46:49.690 --> 00:46:52.510
other characters, it's simply
a sequence of things, and

00:46:52.510 --> 00:46:59.870
notice, by the way, that the
string five-- sorry, the

00:46:59.870 --> 00:47:02.110
string's digit five digit
two is different

00:47:02.110 --> 00:47:03.930
than the number 52.

00:47:03.930 --> 00:47:05.680
The quotes are around them
to make that distinction.

00:47:05.680 --> 00:47:07.770
We're going to see
why in a second.

00:47:07.770 --> 00:47:09.820
What I'm doing, by the way, here
is I'm simply typing in

00:47:09.820 --> 00:47:11.240
expressions to that
interpreter.

00:47:11.240 --> 00:47:13.820
It's using its set of rules to
deduce the value and print

00:47:13.820 --> 00:47:15.540
them back out.

00:47:15.540 --> 00:47:17.260
Things I might like to do in
here is, I might like to do

00:47:17.260 --> 00:47:19.200
combinations of things
with these.

00:47:19.200 --> 00:47:23.900
So we have associated with
simple things, a set of

00:47:23.900 --> 00:47:27.300
operations.

00:47:27.300 --> 00:47:32.440
So for numbers, we have the
things you'd expect, the

00:47:32.440 --> 00:47:33.020
arithmetics.

00:47:33.020 --> 00:47:35.880
And let me show you some
examples of that.

00:47:35.880 --> 00:47:38.440
And actually, I'm going to do
one other distinction here.

00:47:38.440 --> 00:47:42.760
What I typed in, things like--
well, let me start this way--

00:47:42.760 --> 00:47:44.850
there's an expression.

00:47:44.850 --> 00:47:48.630
And in Python the expression
is, operand, operator,

00:47:48.630 --> 00:47:51.150
operand, when we're doing simple
expressions like this,

00:47:51.150 --> 00:47:53.790
and if I give it to the
interpreter, it gives me back

00:47:53.790 --> 00:47:56.080
exactly what you'd expect,
which is that value.

00:47:56.080 --> 00:47:57.290
OK?

00:47:57.290 --> 00:47:59.670
The distinction I'm going to
make is, that's an expression.

00:47:59.670 --> 00:48:01.450
The interpreter is going
to get a value for it.

00:48:01.450 --> 00:48:03.000
When we start building
up code, we're

00:48:03.000 --> 00:48:04.160
going to use commands.

00:48:04.160 --> 00:48:05.120
Or statements.

00:48:05.120 --> 00:48:08.220
Which are actually things that
take in a value and ask the

00:48:08.220 --> 00:48:09.750
computer to do something
with it.

00:48:09.750 --> 00:48:13.980
So I can similarly do this,
which is going to look strange

00:48:13.980 --> 00:48:16.135
because it's going to give me
the same value back out, but

00:48:16.135 --> 00:48:17.640
it actually did a slightly
different thing.

00:48:17.640 --> 00:48:19.910
And notice, by the way, when I
typed it how print showed up

00:48:19.910 --> 00:48:21.390
in a different color?

00:48:21.390 --> 00:48:24.020
That's the Python saying, that
is a command, that is a

00:48:24.020 --> 00:48:26.260
specific command to get the
value of the expression and

00:48:26.260 --> 00:48:27.060
print it back out.

00:48:27.060 --> 00:48:29.490
When we start writing code,
you're going to see that

00:48:29.490 --> 00:48:31.180
difference, but for now, don't
worry about it, I just want to

00:48:31.180 --> 00:48:33.020
plant that idea.

00:48:33.020 --> 00:48:33.190
OK.

00:48:33.190 --> 00:48:35.130
Once we've got that, we
can certainly, though,

00:48:35.130 --> 00:48:39.000
do things like this.

00:48:39.000 --> 00:48:42.240
Notice the quotes around it.

00:48:42.240 --> 00:48:44.630
And it treats it as a string,
it's simply getting me back

00:48:44.630 --> 00:48:47.900
the value of that string,
52 times 7, rather than

00:48:47.900 --> 00:48:49.800
the value of it.

00:48:49.800 --> 00:48:52.030
Now, once we've got that, we
can start doing things.

00:48:52.030 --> 00:48:53.720
And I'm going to use print
here-- if I could type, in

00:48:53.720 --> 00:48:55.720
order to just to get into that,
I can't type, here we

00:48:55.720 --> 00:48:57.660
go-- in order to get
into the habit.

00:48:57.660 --> 00:49:00.480
I can print out a string.

00:49:00.480 --> 00:49:07.010
I can print out--

00:49:07.010 --> 00:49:09.130
Ah!--

00:49:09.130 --> 00:49:10.860
Here's a first example
of something that

00:49:10.860 --> 00:49:11.910
caught one of my things.

00:49:11.910 --> 00:49:15.000
This is a static
semantic error.

00:49:15.000 --> 00:49:16.110
So what went on here?

00:49:16.110 --> 00:49:18.470
I gave it an expression that
had an operand in there.

00:49:18.470 --> 00:49:21.290
It expected arithmetic types.

00:49:21.290 --> 00:49:23.800
But I gave two strings.

00:49:23.800 --> 00:49:26.010
And so it's complaining at me,
saying, you can't do this.

00:49:26.010 --> 00:49:27.810
I don't know how to take
two strings and

00:49:27.810 --> 00:49:30.020
multiply them together.

00:49:30.020 --> 00:49:32.280
Unfortunately-- now John you may
disagree with me on this

00:49:32.280 --> 00:49:34.780
one-- unfortunately in Python
you can, however,

00:49:34.780 --> 00:49:37.570
do things like this.

00:49:37.570 --> 00:49:39.950
What do you figure that's
going to do?

00:49:39.950 --> 00:49:41.400
Look legal?

00:49:41.400 --> 00:49:45.080
The string three times
the number three?

00:49:45.080 --> 00:49:49.850
Well it happens to give me
three threes in a row.

00:49:49.850 --> 00:49:50.400
I hate this.

00:49:50.400 --> 00:49:51.510
I'm sorry, John, I hate this.

00:49:51.510 --> 00:49:55.060
Because this is overloading that
multiplication operator

00:49:55.060 --> 00:49:56.360
with two different tasks.

00:49:56.360 --> 00:49:57.580
It's saying, if you give
me two numbers, I'll

00:49:57.580 --> 00:49:58.320
do the right thing.

00:49:58.320 --> 00:50:00.510
If you give me a number and
a string, I'm going to

00:50:00.510 --> 00:50:02.130
concatenate them together,
it's really different

00:50:02.130 --> 00:50:05.380
operations, but nonetheless,
it's what it's going to do.

00:50:05.380 --> 00:50:11.130
STUDENT: [UNINTELLIGIBLE]

00:50:11.130 --> 00:50:12.700
PROFESSOR ERIC GRIMSON:
There you go.

00:50:12.700 --> 00:50:14.690
You know, there will be a
rebuttal phase a little later

00:50:14.690 --> 00:50:16.380
on, just like with the political
debates, and he

00:50:16.380 --> 00:50:18.520
likes it as a feature, I don't
like it, you can tell he's not

00:50:18.520 --> 00:50:20.810
a Lisp programmer and I am.

00:50:20.810 --> 00:50:21.020
All right.

00:50:21.020 --> 00:50:22.710
I want to do just a couple
more quick examples.

00:50:22.710 --> 00:50:23.410
Here's another one.

00:50:23.410 --> 00:50:24.980
Ah-ha!

00:50:24.980 --> 00:50:28.220
Give you an example
of a syntax error.

00:50:28.220 --> 00:50:31.110
Because 52A doesn't
make sense.

00:50:31.110 --> 00:50:32.400
And you might say, wait a
minute, isn't that a string,

00:50:32.400 --> 00:50:34.870
and the answer's no, I didn't
say it's a string by putting

00:50:34.870 --> 00:50:35.692
quotes around it.

00:50:35.692 --> 00:50:38.430
And notice how the machine
responds differently to it.

00:50:38.430 --> 00:50:41.290
In this case it says, this is
a syntax error, and it's

00:50:41.290 --> 00:50:43.120
actually highlighting where
it came from so I can go

00:50:43.120 --> 00:50:44.940
back and fix it.

00:50:44.940 --> 00:50:45.710
All right.

00:50:45.710 --> 00:50:48.800
Let's do a couple of other
simple examples.

00:50:48.800 --> 00:50:49.160
All right?

00:50:49.160 --> 00:50:50.640
I can do multiplication.

00:50:50.640 --> 00:50:51.320
I've already seen that.

00:50:51.320 --> 00:50:52.960
I can do addition.

00:50:52.960 --> 00:50:54.460
Three plus five.

00:50:54.460 --> 00:50:58.020
I can take something to a power,
double star, just take

00:50:58.020 --> 00:50:59.900
three to the fifth power.

00:50:59.900 --> 00:51:03.390
I can do division, right?

00:51:03.390 --> 00:51:04.360
Whoa.

00:51:04.360 --> 00:51:05.420
Right?

00:51:05.420 --> 00:51:08.090
Three divided by five is zero?

00:51:08.090 --> 00:51:10.010
Maybe in Bush econom-- no, I'm
not going to do any political

00:51:10.010 --> 00:51:12.350
comments today, I will not
say that, all right?

00:51:12.350 --> 00:51:14.090
What happened?

00:51:14.090 --> 00:51:15.280
Well, this is one of
the places where

00:51:15.280 --> 00:51:16.500
you have to be careful.

00:51:16.500 --> 00:51:19.070
It's doing integer division.

00:51:19.070 --> 00:51:22.110
So, three divided by five
is zero, with a

00:51:22.110 --> 00:51:23.090
remainder of three.

00:51:23.090 --> 00:51:24.120
So this is the correct answer.

00:51:24.120 --> 00:51:28.240
If I wanted to get full, real
division, I should make one of

00:51:28.240 --> 00:51:30.810
them a float.

00:51:30.810 --> 00:51:32.500
And yes, you can look at that
and say, well is that right?

00:51:32.500 --> 00:51:35.410
Well, up to some level of
accuracy, yeah, that's .6 is

00:51:35.410 --> 00:51:36.380
what I'd like to get out.

00:51:36.380 --> 00:51:38.430
All right.

00:51:38.430 --> 00:51:40.720
I can do other things.

00:51:40.720 --> 00:51:46.600
In a particular, I have similar
operations on strings.

00:51:46.600 --> 00:51:48.660
OK, I can certainly print out
strings, but I can actually

00:51:48.660 --> 00:51:51.250
add strings together, and just
as you saw, I can multiply

00:51:51.250 --> 00:51:53.670
strings, you can kind of guess
what this is going to do.

00:51:53.670 --> 00:51:58.820
It is going to merge them
together into one thing.

00:51:58.820 --> 00:51:59.190
I want--

00:51:59.190 --> 00:52:00.730
I know I'm running you slightly
over, I want to do

00:52:00.730 --> 00:52:03.940
one last example, it's, I also
want to be able to do, have

00:52:03.940 --> 00:52:05.290
variables to store things.

00:52:05.290 --> 00:52:11.140
And to do that, in this it says,
if I have a value, I

00:52:11.140 --> 00:52:12.870
want to keep it around,
to do that, I can

00:52:12.870 --> 00:52:20.490
do things like this.

00:52:20.490 --> 00:52:21.370
What does that statement do?

00:52:21.370 --> 00:52:24.140
It says, create a name for a
variable-- which I just did

00:52:24.140 --> 00:52:28.180
there, in fact, let me type it
in-- mystring, with an equal

00:52:28.180 --> 00:52:32.580
sign, which is saying, assign or
bind to that name the value

00:52:32.580 --> 00:52:35.430
of the following expression.

00:52:35.430 --> 00:52:37.040
As a consequence, I
can now refer to

00:52:37.040 --> 00:52:39.920
that just by its name.

00:52:39.920 --> 00:52:43.190
If I get the value of mystring,
there it is, or if I

00:52:43.190 --> 00:52:49.760
say, take mystring and add to it
the string, mylastname, and

00:52:49.760 --> 00:52:51.970
print it back out.

00:52:51.970 --> 00:52:53.610
So this is the first
start of this.

00:52:53.610 --> 00:52:54.950
What have we done?

00:52:54.950 --> 00:52:57.880
We've got values, numbers
and strings.

00:52:57.880 --> 00:52:59.610
We have operations to
associate with them.

00:52:59.610 --> 00:53:00.730
I just threw a couple up here.

00:53:00.730 --> 00:53:02.220
You're going to get a chance
to explore them, and you'll

00:53:02.220 --> 00:53:04.910
see not only are there the
standard numerics for strings,

00:53:04.910 --> 00:53:06.960
there are things like length
or plus or other things you

00:53:06.960 --> 00:53:08.140
can do with them.

00:53:08.140 --> 00:53:10.500
And once I have values, I want
to get a hold of them so I can

00:53:10.500 --> 00:53:11.270
give them names.

00:53:11.270 --> 00:53:12.820
And that's what I just did
when I bound that.

00:53:12.820 --> 00:53:16.650
I said, use the name mystring
to be bound to or have the

00:53:16.650 --> 00:53:19.470
value of Eric, so I can refer
to it anywhere else that I

00:53:19.470 --> 00:53:20.830
want to use it.

00:53:20.830 --> 00:53:23.020
And I apologize for taking you
over, we'll come back to this

00:53:23.020 --> 00:53:25.460
next time, please go to the
website to sign up for

00:53:25.460 --> 00:53:27.430
recitation for tomorrow.