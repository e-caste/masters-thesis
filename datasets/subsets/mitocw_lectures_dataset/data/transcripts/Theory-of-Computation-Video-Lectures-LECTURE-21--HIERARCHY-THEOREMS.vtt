WEBVTT

00:00:00.000 --> 00:00:01.980
[SQUEAKING]

00:00:01.980 --> 00:00:04.455
[RUSTLING]

00:00:04.455 --> 00:00:06.930
[CLICKING]

00:00:25.590 --> 00:00:27.340
MICHAEL SIPSER: OK,
welcome everybody.

00:00:27.340 --> 00:00:31.680
So we are here today,
lecture number 21.

00:00:31.680 --> 00:00:34.770
Coming into the
homestretch of the course.

00:00:34.770 --> 00:00:38.850
I'd say probably
this last quarter

00:00:38.850 --> 00:00:42.040
of the course is a bit
more technical, perhaps.

00:00:42.040 --> 00:00:43.290
So a little bit more abstract.

00:00:43.290 --> 00:00:46.620
Some of the theorems are
going to be more difficult.

00:00:46.620 --> 00:00:49.740
So I'll try to work through
them slowly and answer

00:00:49.740 --> 00:00:50.400
your questions.

00:00:50.400 --> 00:00:54.810
But you know, I
think you can expect

00:00:54.810 --> 00:00:57.060
to find the material a
bit more challenging.

00:00:57.060 --> 00:01:11.140
As we started-- as we started
with this theorem last time,

00:01:11.140 --> 00:01:17.440
about nondeterministic log space
being closed under complement.

00:01:17.440 --> 00:01:19.410
So NL equals coNL.

00:01:19.410 --> 00:01:22.830
We kind of only got about
maybe a third of the way

00:01:22.830 --> 00:01:23.440
through that.

00:01:23.440 --> 00:01:25.350
So I'm going to
start over with that,

00:01:25.350 --> 00:01:28.470
and spend kind of the
first half of the lecture

00:01:28.470 --> 00:01:29.800
today talking about that.

00:01:29.800 --> 00:01:32.910
And then we're going to
talk about the hierarchy

00:01:32.910 --> 00:01:36.660
theorems, which are a
very important aspect

00:01:36.660 --> 00:01:38.520
of the complexity landscape.

00:01:38.520 --> 00:01:44.780
Basically, they tell you that if
you allow your favorite model,

00:01:44.780 --> 00:01:48.510
let's say Turing machines,
to have more resources,

00:01:48.510 --> 00:01:50.990
then they can do more things.

00:01:50.990 --> 00:01:53.150
But we'll get to
that in due course.

00:01:53.150 --> 00:01:58.460
OK, so let us go back to--

00:01:58.460 --> 00:02:02.600
oops, reminder to myself--

00:02:02.600 --> 00:02:08.400
go back to the
Immerman-SzelepcsÃ©nyi theorem,

00:02:08.400 --> 00:02:13.220
which is that NL
is equal to coNL.

00:02:13.220 --> 00:02:15.590
So as I mentioned,
these are going

00:02:15.590 --> 00:02:18.080
to be the same
slides as last time.

00:02:18.080 --> 00:02:21.740
And I'll just try to
walk through them slowly.

00:02:21.740 --> 00:02:24.840
I hope you get it.

00:02:24.840 --> 00:02:29.450
But if you don't, ask
me or the TAs questions.

00:02:29.450 --> 00:02:35.870
So we're going to first, I mean,
the thing we're going to show

00:02:35.870 --> 00:02:39.020
is that the
complement of path is

00:02:39.020 --> 00:02:41.960
solvable in
non-deterministic log space.

00:02:41.960 --> 00:02:45.770
We already know that
path is solvable in NL.

00:02:45.770 --> 00:02:47.090
That's easy to do.

00:02:47.090 --> 00:02:50.780
You basically just
start at the start node,

00:02:50.780 --> 00:02:53.030
and you guess the
sequence of nodes,

00:02:53.030 --> 00:02:57.000
storing only the current node in
your log space working memory,

00:02:57.000 --> 00:03:00.920
on your logs based work tape.

00:03:00.920 --> 00:03:03.800
You guess the sequence of
nodes on the different branches

00:03:03.800 --> 00:03:05.090
of the non-determinism.

00:03:05.090 --> 00:03:07.550
And if you ever get
to the target node t,

00:03:07.550 --> 00:03:09.530
then you can accept.

00:03:09.530 --> 00:03:12.920
But how can a non-deterministic
log space machine

00:03:12.920 --> 00:03:16.100
know or accept the
complement of path?

00:03:16.100 --> 00:03:19.670
So it would have to accept
when there's no path.

00:03:19.670 --> 00:03:23.240
And that is a lot harder.

00:03:23.240 --> 00:03:27.140
But big surprise to the
complexity community

00:03:27.140 --> 00:03:28.580
that it is true.

00:03:31.350 --> 00:03:34.190
So as we discussed
last time, we're

00:03:34.190 --> 00:03:37.400
going to talk about
computing functions

00:03:37.400 --> 00:03:39.290
with a non-deterministic
machine.

00:03:39.290 --> 00:03:41.090
And that turns out to
be a convenient way

00:03:41.090 --> 00:03:44.250
of looking at this.

00:03:44.250 --> 00:03:47.330
So we're going to have
non-deterministic machines that

00:03:47.330 --> 00:03:50.840
have different branches of the
non-determinism on some input,

00:03:50.840 --> 00:03:53.660
and it's supposed to
compute some function value

00:03:53.660 --> 00:03:55.400
remaining on the tape.

00:03:55.400 --> 00:03:57.140
But because of the
non-determinism,

00:03:57.140 --> 00:03:59.840
you can imagine that
different branches might have

00:03:59.840 --> 00:04:01.460
different function outputs.

00:04:01.460 --> 00:04:02.900
Well, that's not allowed.

00:04:02.900 --> 00:04:09.330
All branches must either report
the value of the function

00:04:09.330 --> 00:04:12.900
that we're trying to
compute, or they can punt.

00:04:12.900 --> 00:04:20.310
Basically, they can reject
and say, well, basically I

00:04:20.310 --> 00:04:22.019
don't know.

00:04:22.019 --> 00:04:25.260
So all branches must either
report the correct answer,

00:04:25.260 --> 00:04:26.780
or they can say I don't know.

00:04:26.780 --> 00:04:28.610
And some branch must--

00:04:28.610 --> 00:04:31.440
at least one branch
must report an answer.

00:04:31.440 --> 00:04:34.630
Must report the answer.

00:04:34.630 --> 00:04:37.090
And that's what it
means to be computing

00:04:37.090 --> 00:04:40.820
a function with a
non-deterministic machine.

00:04:40.820 --> 00:04:43.740
And we're going to show
that certain functions can

00:04:43.740 --> 00:04:46.165
be computed with
nondeterministic log space

00:04:46.165 --> 00:04:46.665
machines.

00:04:49.880 --> 00:04:52.850
In particular,
this path function,

00:04:52.850 --> 00:04:56.600
which sort of incorporates
both the positive and negative

00:04:56.600 --> 00:04:59.990
of both when there is a
path and when there is not

00:04:59.990 --> 00:05:02.960
a path into the function,
because the function

00:05:02.960 --> 00:05:07.700
has to answer yes when there is
a path from s to t and no when

00:05:07.700 --> 00:05:11.090
there is no path from s to t.

00:05:11.090 --> 00:05:16.950
So if you could do
this, you're done.

00:05:16.950 --> 00:05:20.310
Because you can make
a non-deterministic--

00:05:20.310 --> 00:05:23.440
you can make an NL machine.

00:05:23.440 --> 00:05:25.350
So if you could compute
the path function,

00:05:25.350 --> 00:05:28.440
you can make an NL
machine, which would accept

00:05:28.440 --> 00:05:30.060
whenever the function says no.

00:05:33.400 --> 00:05:39.430
And the other cases, and
if the machine that's

00:05:39.430 --> 00:05:44.140
computing the function rejects,
then you'll reject as well.

00:05:44.140 --> 00:05:46.240
But you accept if
the function says no.

00:05:46.240 --> 00:05:47.740
And so therefore,
you're going to be

00:05:47.740 --> 00:05:51.250
making an NL machine which
does the complement of the path

00:05:51.250 --> 00:05:53.560
problem.

00:05:53.560 --> 00:06:00.010
So if you can compute the path
function, that would be great.

00:06:00.010 --> 00:06:01.960
So that's what we would
like to be able to do.

00:06:04.600 --> 00:06:08.560
So as I mentioned, we're going
to have two other values that

00:06:08.560 --> 00:06:11.080
are going to be relevant
to computing the path

00:06:11.080 --> 00:06:13.390
function, which is what
we're ultimately going to do.

00:06:13.390 --> 00:06:16.030
And that's going to
be the number of nodes

00:06:16.030 --> 00:06:20.140
that you can reach
from the start,

00:06:20.140 --> 00:06:24.820
from the start node in
your graph, and the--

00:06:24.820 --> 00:06:27.590
for-- R is the
collection of nodes and c

00:06:27.590 --> 00:06:29.410
is the number of
reachable nodes.

00:06:32.130 --> 00:06:33.220
So shown on this picture.

00:06:33.220 --> 00:06:37.230
And here, if it's helpful to
you to see it in a more formal

00:06:37.230 --> 00:06:40.760
[INAUDIBLE] is
you can think of R

00:06:40.760 --> 00:06:44.090
as a function of the graph
and the start node, of course.

00:06:44.090 --> 00:06:45.890
But sometimes we'll
just call it R,

00:06:45.890 --> 00:06:49.400
when it's clear which graph and
start node we're talking about.

00:06:52.860 --> 00:06:55.250
R is the set of reachable nodes.

00:06:55.250 --> 00:07:01.890
So it's the collection u
such that the answer is yes.

00:07:01.890 --> 00:07:13.830
And c is the size of R. So
the way we're going to start

00:07:13.830 --> 00:07:18.120
is kind of an easy theorem,
though this is still

00:07:18.120 --> 00:07:21.070
going to be relevant
kind of at the end.

00:07:21.070 --> 00:07:25.590
But for now, it's really more
a practice with the concept

00:07:25.590 --> 00:07:28.200
that we have come up, you
know, this function concept

00:07:28.200 --> 00:07:30.070
that we've just introduced.

00:07:30.070 --> 00:07:36.300
So I want to say that the path
function, with an NL machine.

00:07:36.300 --> 00:07:41.640
Then I can compute the
count with an NL machine.

00:07:41.640 --> 00:07:45.240
So understand what a computing
the path function means.

00:07:45.240 --> 00:07:51.500
That you have your NL
machine, and every branch

00:07:51.500 --> 00:07:54.560
has to either say I don't
know, which is reject.

00:07:54.560 --> 00:07:57.972
Or it has to have
the answer, which

00:07:57.972 --> 00:07:59.930
it's going to be yes if
there is a path, and no

00:07:59.930 --> 00:08:00.860
if there is no path.

00:08:04.150 --> 00:08:10.200
And if I can be able to count
the number of nodes that do

00:08:10.200 --> 00:08:11.520
have a path.

00:08:11.520 --> 00:08:13.545
The number of nodes for
which the answer is yes.

00:08:17.270 --> 00:08:19.760
And this, I think if
you're comfortable

00:08:19.760 --> 00:08:25.700
with the definition, this
is more or less obvious,

00:08:25.700 --> 00:08:28.520
because what you
would do is you would

00:08:28.520 --> 00:08:31.790
go through the nodes
of G, one by one,

00:08:31.790 --> 00:08:39.990
and test using your path
function what the answer is.

00:08:39.990 --> 00:08:41.370
Yes or a no.

00:08:41.370 --> 00:08:44.580
And every time it's a yes,
you add 1 to the count.

00:08:44.580 --> 00:08:47.340
Until you've gone
through all of the nodes.

00:08:47.340 --> 00:08:50.770
And then you have your
answer, which is [INAUDIBLE]

00:08:50.770 --> 00:08:53.910
and that's c.

00:08:53.910 --> 00:08:57.360
Now, if the machine
that's trying

00:08:57.360 --> 00:09:01.930
to compute the path function
on the non-determinism rejects,

00:09:01.930 --> 00:09:02.590
that's OK.

00:09:02.590 --> 00:09:07.180
For computing c, that
branch will reject also.

00:09:07.180 --> 00:09:11.650
But when you're-- some branch
has to get the right answer

00:09:11.650 --> 00:09:14.140
on--

00:09:14.140 --> 00:09:17.120
has to get the right answer.

00:09:17.120 --> 00:09:20.865
And so then, you get the--

00:09:20.865 --> 00:09:23.650
you know what's
happening with that node.

00:09:23.650 --> 00:09:27.610
And so you then can either
increment the count,

00:09:27.610 --> 00:09:29.320
or you move on to the next node.

00:09:29.320 --> 00:09:32.442
I think I'm trying to say--

00:09:32.442 --> 00:09:34.150
I'm not sure if I'm
making it any clearer

00:09:34.150 --> 00:09:35.560
by kind of repeating myself.

00:09:35.560 --> 00:09:36.890
But OK, here.

00:09:36.890 --> 00:09:38.890
So you're going to start
out with-- you're given

00:09:38.890 --> 00:09:42.110
the graph and the start node.

00:09:42.110 --> 00:09:44.570
We're trying to compute this
value c, which is the number

00:09:44.570 --> 00:09:46.862
reachable from the start node.

00:09:46.862 --> 00:09:49.070
You start out with-- you
have a counter, which you're

00:09:49.070 --> 00:09:50.720
going to set initially to 0.

00:09:50.720 --> 00:09:53.460
And you go through
every node of the graph.

00:09:53.460 --> 00:09:59.130
And if the path
function computation

00:09:59.130 --> 00:10:02.145
says yes, you can reach u,
then you add 1 to the count.

00:10:02.145 --> 00:10:07.290
It says no, you cannot reach
u, then you just continue.

00:10:07.290 --> 00:10:10.440
And maybe I should
add another line here.

00:10:10.440 --> 00:10:19.230
If the thing that's computing
rejects, then you also reject.

00:10:19.230 --> 00:10:20.790
And then at the
end, you output--

00:10:24.290 --> 00:10:27.100
so what we're going to prove
is the other direction.

00:10:27.100 --> 00:10:31.600
If I give you the count, then
I can answer the question

00:10:31.600 --> 00:10:34.310
for each node whether
it's reachable or not.

00:10:34.310 --> 00:10:35.740
And this is the thing.

00:10:35.740 --> 00:10:38.470
Because what it's saying that
is I can give you the count,

00:10:38.470 --> 00:10:40.850
I'm done.

00:10:40.850 --> 00:10:43.280
If we can get that count,
that's going to be enough.

00:10:47.600 --> 00:10:50.065
So maybe even before
the check, and maybe we

00:10:50.065 --> 00:10:51.440
should just answer
any questions.

00:10:51.440 --> 00:10:57.620
Because if you're stuck
here, then you're doomed.

00:10:57.620 --> 00:11:00.740
So I think it makes sense
to try to understand

00:11:00.740 --> 00:11:03.690
what's going on at this--

00:11:03.690 --> 00:11:07.020
because I think the
real guts of this proof

00:11:07.020 --> 00:11:09.510
is coming on the next slide.

00:11:09.510 --> 00:11:11.860
Kind of the main idea.

00:11:11.860 --> 00:11:15.570
So I'm happy to take, if there's
any questions about this.

00:11:21.742 --> 00:11:23.200
I'll just wait for
a second and see

00:11:23.200 --> 00:11:24.490
if you're typing away there.

00:11:28.017 --> 00:11:29.600
Well, why don't we
go to the check in.

00:11:29.600 --> 00:11:31.970
Maybe that'll help.

00:11:31.970 --> 00:11:33.380
Not a very difficult check in.

00:11:38.510 --> 00:11:40.450
It'll come up.

00:11:40.450 --> 00:11:42.160
OK.

00:11:42.160 --> 00:11:44.380
Just a little practice
with the concept.

00:11:44.380 --> 00:11:47.470
So I'm going to
give you some graph.

00:11:47.470 --> 00:11:50.380
It has 9 nodes.

00:11:50.380 --> 00:11:54.370
And I want to know the
value of the count.

00:11:54.370 --> 00:11:58.480
So we'll assume that
s, the start node here,

00:11:58.480 --> 00:12:00.760
is reachable from itself.

00:12:00.760 --> 00:12:02.010
And now what's the value of c?

00:12:07.410 --> 00:12:10.130
Are we good?

00:12:10.130 --> 00:12:12.980
I'm going to shut this down,
give you another two seconds.

00:12:12.980 --> 00:12:15.530
Please get your answer in.

00:12:15.530 --> 00:12:18.245
OK, ready, set, end.

00:12:22.690 --> 00:12:26.440
Yeah, the right answer is,
in fact, E, which is 6.

00:12:26.440 --> 00:12:29.373
There is 6 reachable
nodes in this graph.

00:12:29.373 --> 00:12:31.540
And that's what the value
C is supposed to tell you,

00:12:31.540 --> 00:12:34.240
is how many nodes
can I get to from s.

00:12:34.240 --> 00:12:39.620
And what I'm saying is that
if I can calculate that

00:12:39.620 --> 00:12:41.570
in this sort of
non-deterministic function

00:12:41.570 --> 00:12:47.640
sense, so if some branches
can get that answer,

00:12:47.640 --> 00:12:53.400
then I can use that to test
for each node, whether it's

00:12:53.400 --> 00:12:56.700
reachable or not, which is kind
of a little bit of a miracle.

00:12:56.700 --> 00:12:57.870
That's kind of surprising.

00:12:57.870 --> 00:13:01.080
Just knowing how many nodes are
reachable will allow me to test

00:13:01.080 --> 00:13:05.670
whether each individual node
is reachable, because that's--

00:13:05.670 --> 00:13:08.130
no obvious reason
why that would be.

00:13:08.130 --> 00:13:10.955
So there's going to be a
procedure for doing that,

00:13:10.955 --> 00:13:12.080
which is on the next slide.

00:13:12.080 --> 00:13:12.900
And here it is.

00:13:16.370 --> 00:13:21.260
So this is the key idea that
we're going to repeat later.

00:13:21.260 --> 00:13:25.670
But so it's good to understand.

00:13:25.670 --> 00:13:28.220
This is the slide you
really need to understand.

00:13:30.980 --> 00:13:32.102
So I'm giving the graph.

00:13:32.102 --> 00:13:33.560
Let's assume the
graph has m nodes.

00:13:36.590 --> 00:13:38.810
Now, as I said.

00:13:38.810 --> 00:13:41.150
OK, so let's just say,
what are we doing here?

00:13:41.150 --> 00:13:46.040
Given that count,
we can compute path.

00:13:46.040 --> 00:13:49.490
So we'll get the answer for
every node in the graph,

00:13:49.490 --> 00:13:51.850
if I just know how many--

00:13:51.850 --> 00:13:53.590
so I'll know, I
can get the answer

00:13:53.590 --> 00:13:57.900
for whether a node is reachable
or not if I just have--

00:13:57.900 --> 00:14:02.010
if I just know how many
reachable nodes there are.

00:14:02.010 --> 00:14:05.520
So what I'm going to do is
get that count of how many

00:14:05.520 --> 00:14:07.840
are reachable.

00:14:07.840 --> 00:14:10.410
Now, I'm going to go to--

00:14:10.410 --> 00:14:11.850
I'm going-- so look.

00:14:11.850 --> 00:14:14.490
Let's see, what's the
idea here, before we even

00:14:14.490 --> 00:14:17.630
jump into the algorithm.

00:14:17.630 --> 00:14:23.830
The idea is let's say I know
how many nodes are reachable,

00:14:23.830 --> 00:14:26.520
like 100 nodes are reachable.

00:14:26.520 --> 00:14:28.760
Now, what I'm going to
do, what the algorithm

00:14:28.760 --> 00:14:33.250
that is going to do is find
all 100 reachable nodes.

00:14:33.250 --> 00:14:35.110
[? Go ?] 1 by 1, but
it doesn't matter.

00:14:35.110 --> 00:14:40.450
Sort of conceptually, it's going
to find all reachable nodes.

00:14:40.450 --> 00:14:42.810
And non-deterministically
guessing them.

00:14:42.810 --> 00:14:44.810
So it's not sure in advance
which ones they are.

00:14:44.810 --> 00:14:47.410
But it's going to
guess basically 100--

00:14:47.410 --> 00:14:50.355
it's going to guess some of
the nodes as being reachable,

00:14:50.355 --> 00:14:52.480
confirm that the ones that
it guesses are reachable

00:14:52.480 --> 00:14:54.730
are reachable, and
then check to see

00:14:54.730 --> 00:14:57.810
that that number equals 100.

00:14:57.810 --> 00:15:00.030
On some branch of
the non-determinism,

00:15:00.030 --> 00:15:02.430
you will guess right,
and you'll end up

00:15:02.430 --> 00:15:06.540
with exactly the right set
of 100 reachable nodes.

00:15:06.540 --> 00:15:11.640
And then you'll see, is t
one of those reachable ones?

00:15:11.640 --> 00:15:13.080
In which case you say yes.

00:15:13.080 --> 00:15:17.430
Or is t not one of
those 100 nodes.

00:15:17.430 --> 00:15:20.610
And then you know
the answer is no.

00:15:20.610 --> 00:15:23.190
Because if you've
guessed 100 nodes,

00:15:23.190 --> 00:15:25.170
and you know they're
all reachable,

00:15:25.170 --> 00:15:27.540
and you know there are
exactly 100 reachable nodes,

00:15:27.540 --> 00:15:29.907
then every other node
is not reachable.

00:15:33.490 --> 00:15:34.780
So that's the spirit of this.

00:15:34.780 --> 00:15:36.447
And that's, I'm just
going to write that

00:15:36.447 --> 00:15:40.500
down here in the algorithm.

00:15:40.500 --> 00:15:42.420
Can you guys hear me still?

00:15:42.420 --> 00:15:45.660
Yeah, somebody said my
audio is like flipping out.

00:15:45.660 --> 00:15:50.610
I am getting a sign or
two of unstable internet.

00:15:50.610 --> 00:15:54.090
So if you need me to repeat
anything, just send me a note.

00:15:54.090 --> 00:15:54.930
Good, thank you.

00:16:01.200 --> 00:16:04.860
All right, so well, maybe
I should speak slowly,

00:16:04.860 --> 00:16:07.500
if it's not coming
through too well.

00:16:13.610 --> 00:16:17.210
So what we're going to do
is go through all the nodes

00:16:17.210 --> 00:16:21.730
of the graph, one
by one, and guess

00:16:21.730 --> 00:16:25.710
whether it's a reachable
node or not a reachable node.

00:16:25.710 --> 00:16:28.110
If we guess it is
reachable, I'm going

00:16:28.110 --> 00:16:34.480
to also guess the path, which
shows that it's reachable.

00:16:34.480 --> 00:16:36.580
And then I'm going
to-- and I'm going

00:16:36.580 --> 00:16:39.160
to keep a count of how many
reachable nodes I found.

00:16:42.080 --> 00:16:48.550
If that count agrees with the
value c I started with, then

00:16:48.550 --> 00:16:52.020
I know I found them all.

00:16:52.020 --> 00:16:57.780
And if t is not one of them,
then I know t is not reachable.

00:16:57.780 --> 00:17:00.580
That's the idea.

00:17:00.580 --> 00:17:03.010
So here's my--
this is going to be

00:17:03.010 --> 00:17:05.829
a count of the number
of nodes that I

00:17:05.829 --> 00:17:08.950
have found which are reachable.

00:17:08.950 --> 00:17:10.300
That's k.

00:17:10.300 --> 00:17:13.810
Now here I'm going to
non-deterministically choose,

00:17:13.810 --> 00:17:16.270
is it a reachable node or not.

00:17:16.270 --> 00:17:19.630
I've just called it two
branches of the algorithm, the p

00:17:19.630 --> 00:17:22.569
branch or the n branch.
p means there's a path,

00:17:22.569 --> 00:17:26.750
an n means there's no path.

00:17:26.750 --> 00:17:30.680
So if I guessed p at this
point for this node u--

00:17:30.680 --> 00:17:32.740
so I'm going to each of
the nodes one by one.

00:17:32.740 --> 00:17:34.690
u is the current node.

00:17:34.690 --> 00:17:39.790
If I've guessed that it
does have a path from s,

00:17:39.790 --> 00:17:43.300
then I'm going to
guess that path,

00:17:43.300 --> 00:17:45.940
to make sure that it
really is a reachable node.

00:17:52.280 --> 00:17:55.190
If I fail to find
a path, then this

00:17:55.190 --> 00:17:58.670
is one of the branches of
the non-determinism that

00:17:58.670 --> 00:18:00.578
is going to fail.

00:18:00.578 --> 00:18:01.370
It's going to punt.

00:18:01.370 --> 00:18:04.640
It's going to say, I don't
know under this branch.

00:18:04.640 --> 00:18:07.910
Because either
you guessed wrong,

00:18:07.910 --> 00:18:10.370
and this node was not reachable.

00:18:10.370 --> 00:18:13.940
Or if it was
reachable, you failed

00:18:13.940 --> 00:18:17.360
to find a path, which shows
you that it's reachable.

00:18:17.360 --> 00:18:20.850
There was some path, but you
didn't guess the right one.

00:18:20.850 --> 00:18:23.190
Either way, you
made a bad choice.

00:18:23.190 --> 00:18:24.870
You're just going to punt.

00:18:27.880 --> 00:18:30.430
Now, if you have
determined that t

00:18:30.430 --> 00:18:34.540
is that node that
you've just shown

00:18:34.540 --> 00:18:37.360
is reachable, because at
this stage, you did not fail,

00:18:37.360 --> 00:18:47.350
so you succeeded in
showing a path to u, then--

00:18:47.350 --> 00:18:51.460
and u equals t,
then t is reachable,

00:18:51.460 --> 00:18:55.470
so there is a path from s
to t, and you're finished.

00:18:55.470 --> 00:18:58.240
Because you know, you've got
the answer you're looking for.

00:18:58.240 --> 00:19:00.850
And so now you can say yes.

00:19:00.850 --> 00:19:03.580
Otherwise, if u is
some other node,

00:19:03.580 --> 00:19:05.690
then you can just
increase your count

00:19:05.690 --> 00:19:07.690
of the number of reachable
nodes that you found.

00:19:10.500 --> 00:19:12.450
So you found a reachable node.

00:19:12.450 --> 00:19:14.490
If it's t, you're
great, you're done.

00:19:14.490 --> 00:19:17.430
If it's not, you just
include that in your count

00:19:17.430 --> 00:19:19.200
of reachable nodes.

00:19:19.200 --> 00:19:22.380
Now, if you've guessed that
the node is not reachable, OK,

00:19:22.380 --> 00:19:23.700
then you just proceed--

00:19:23.700 --> 00:19:26.603
you're not going
to-- you're just

00:19:26.603 --> 00:19:28.020
going to move on
to the next node,

00:19:28.020 --> 00:19:31.500
because you're looking for a
collection of reachable nodes.

00:19:38.493 --> 00:19:39.660
Getting some questions here.

00:19:39.660 --> 00:19:42.360
But let me wait
till the end here.

00:19:42.360 --> 00:19:47.050
Now, after I finish going
through all of the nodes,

00:19:47.050 --> 00:19:51.190
so I'm finished
with this loop here

00:19:51.190 --> 00:19:54.340
of going through
all the nodes, now I

00:19:54.340 --> 00:19:59.750
see, did I find c
reachable nodes,

00:19:59.750 --> 00:20:01.880
because k is the
count of the nodes

00:20:01.880 --> 00:20:03.590
that I've found to be reachable.

00:20:03.590 --> 00:20:07.310
If that agrees with c, then
I know I found them all.

00:20:07.310 --> 00:20:10.910
If a differs from c, then
something has gone wrong.

00:20:10.910 --> 00:20:13.370
Because I am told there
are c reachable nodes,

00:20:13.370 --> 00:20:16.010
and I did not find
c reachable nodes.

00:20:16.010 --> 00:20:17.930
So I made some bad
guesses along the way.

00:20:17.930 --> 00:20:20.690
I guessed some node which
really is reachable,

00:20:20.690 --> 00:20:21.990
I guess it was not reachable.

00:20:21.990 --> 00:20:23.420
So I didn't find them all.

00:20:23.420 --> 00:20:25.490
I'm going to punt.

00:20:25.490 --> 00:20:31.190
But if I found them all, and
I didn't end up accepting it,

00:20:31.190 --> 00:20:33.560
I didn't say yes at
this stage, so t was not

00:20:33.560 --> 00:20:35.600
one of the ones I
found unreachable,

00:20:35.600 --> 00:20:39.260
then I'm convinced
that t is not one

00:20:39.260 --> 00:20:40.550
of those that are reachable.

00:20:40.550 --> 00:20:42.110
That was not one
of those c nodes

00:20:42.110 --> 00:20:43.485
that I found which
are reachable.

00:20:43.485 --> 00:20:46.140
And now, I can say no.

00:20:46.140 --> 00:20:52.172
So let me take questions here,
because I think we're, yeah,

00:20:52.172 --> 00:20:53.380
that's the end of this slide.

00:20:53.380 --> 00:21:00.310
This is kind of an important
piece to understand.

00:21:00.310 --> 00:21:02.890
We can spend a couple of minutes
trying to work through this.

00:21:06.593 --> 00:21:08.760
So somebody is asking, how
does nondeterministically

00:21:08.760 --> 00:21:10.260
pick a path fail?

00:21:10.260 --> 00:21:16.620
If you fail, what I mean
is pick a path from s to u.

00:21:16.620 --> 00:21:20.040
So you have to go from s to
whatever your current node

00:21:20.040 --> 00:21:21.640
u is.

00:21:21.640 --> 00:21:24.760
So you're going to
pick some path to u.

00:21:24.760 --> 00:21:26.302
You guessed u is reachable.

00:21:26.302 --> 00:21:28.510
Now you have to demonstrate
it's reachable by picking

00:21:28.510 --> 00:21:29.590
a path from s to u.

00:21:29.590 --> 00:21:34.030
If you don't end up
at u, and the pair--

00:21:34.030 --> 00:21:36.250
you don't want to go
forever on any branch.

00:21:36.250 --> 00:21:38.500
So you're going to
limit it to m steps.

00:21:38.500 --> 00:21:41.360
Your path has to be
of length m at most.

00:21:41.360 --> 00:21:47.090
So after m steps, if you have
not reached u by that point,

00:21:47.090 --> 00:21:49.805
you've picked a bad path,
and you're going to reject.

00:22:05.870 --> 00:22:08.602
So what's the difference
between no and reject?

00:22:08.602 --> 00:22:09.560
That's a good question.

00:22:12.230 --> 00:22:15.740
Reject, in this case,
is an I don't know.

00:22:15.740 --> 00:22:19.640
The algorithm could not
make a determination based

00:22:19.640 --> 00:22:22.500
on the guesses that it's made.

00:22:22.500 --> 00:22:25.110
In this non-deterministic
branch of the algorithm,

00:22:25.110 --> 00:22:27.450
it made bad choices,
which doesn't

00:22:27.450 --> 00:22:30.690
allow it to reach a conclusion
one way or the other.

00:22:33.650 --> 00:22:37.160
Remember, this algorithm here
is computing a function now.

00:22:37.160 --> 00:22:38.660
It's not an alg--
it can [INAUDIBLE]

00:22:38.660 --> 00:22:41.930
nondeterministic algorithm in
the language recognition sense,

00:22:41.930 --> 00:22:43.860
this is a function computer.

00:22:43.860 --> 00:22:47.180
And so it has to get the answer
to the path function, which

00:22:47.180 --> 00:22:50.845
is a yes or a no, or an I
don't know on some branches.

00:22:50.845 --> 00:22:53.770
On some branches it's
allowed to do that too.

00:22:53.770 --> 00:22:56.293
So no and reject are
totally different.

00:23:03.668 --> 00:23:05.710
This is the same thing we
talked about last time.

00:23:05.710 --> 00:23:09.190
Why do we need two
branches for p and n,

00:23:09.190 --> 00:23:12.220
if we're only going to
have a proposal just

00:23:12.220 --> 00:23:13.720
to have the p branch?

00:23:13.720 --> 00:23:17.290
Well, but some nodes
are not reachable.

00:23:17.290 --> 00:23:18.910
If you're going to look for--

00:23:18.910 --> 00:23:24.940
if you have an unreachable
node, so it's not in R,

00:23:24.940 --> 00:23:27.610
you can't get to
that node from s,

00:23:27.610 --> 00:23:30.250
you have to skip over
that node, because you're

00:23:30.250 --> 00:23:33.760
trying to find a subset
of the reachable nodes.

00:23:33.760 --> 00:23:40.530
So you're trying to pick that
subset here one node at a time.

00:23:40.530 --> 00:23:42.260
So if you're only
going to allow things--

00:23:42.260 --> 00:23:44.330
you're going to require
everything in the subset,

00:23:44.330 --> 00:23:46.590
there are going to be some
nodes which are not reachable,

00:23:46.590 --> 00:23:48.170
and you're not going to find
a path because they're not

00:23:48.170 --> 00:23:50.128
reachable, and you're
going to end up rejecting

00:23:50.128 --> 00:23:52.080
all the time on that node.

00:23:52.080 --> 00:23:53.310
So you're going to be--

00:23:53.310 --> 00:23:56.220
the algorithm will not work.

00:23:59.320 --> 00:24:01.610
So I'm not sure I understand
this question here,

00:24:01.610 --> 00:24:03.800
but somebody says,
if t is reachable,

00:24:03.800 --> 00:24:05.910
we output yes on that branch.

00:24:05.910 --> 00:24:11.940
But don't we also output
no on some other branch?

00:24:11.940 --> 00:24:14.610
That's a good-- let's
see what happens

00:24:14.610 --> 00:24:17.670
if t is actually reachable.

00:24:20.330 --> 00:24:22.460
How can we-- so
if t is reachable,

00:24:22.460 --> 00:24:24.950
there's some branch that's
going to output yes.

00:24:24.950 --> 00:24:26.300
We all agree with that.

00:24:26.300 --> 00:24:29.630
Or at least, if you're
following, we agree.

00:24:29.630 --> 00:24:33.890
But could some other
branch output no?

00:24:33.890 --> 00:24:38.140
If t actually is reachable.

00:24:38.140 --> 00:24:41.380
OK, that's a great question.

00:24:41.380 --> 00:24:43.540
And no, that's not
going to happen.

00:24:46.880 --> 00:24:50.030
If t is actually reachable,
how could a branch output no?

00:24:52.630 --> 00:24:56.770
That must mean that
it does not guess t

00:24:56.770 --> 00:24:58.630
as one of the reachable nodes.

00:24:58.630 --> 00:25:01.660
Because it's going through
all of the nodes here,

00:25:01.660 --> 00:25:03.970
you know, it's going
through all the nodes,

00:25:03.970 --> 00:25:08.210
and picking them as
reachable or not.

00:25:08.210 --> 00:25:10.470
If it picked t as one
of the reasonable ones,

00:25:10.470 --> 00:25:12.580
then it's going to output yes.

00:25:12.580 --> 00:25:14.620
Because it will
find, it'll either

00:25:14.620 --> 00:25:17.500
output yes, or if it
doesn't find the right--

00:25:17.500 --> 00:25:19.180
doesn't guess the
right path, it'll

00:25:19.180 --> 00:25:21.790
end up rejecting on that path.

00:25:21.790 --> 00:25:25.930
But some path will end up saying
yes, so if t is reachable.

00:25:25.930 --> 00:25:28.810
And if you guess--

00:25:28.810 --> 00:25:31.570
if you know t is reachable,
and you guess t--

00:25:31.570 --> 00:25:35.470
you guess u is reachable at
the point when u equals t,

00:25:35.470 --> 00:25:37.890
you will end up outputting yes.

00:25:37.890 --> 00:25:41.880
The only way you
could not output yes

00:25:41.880 --> 00:25:44.910
is if you guessed that
node is unreachable.

00:25:48.090 --> 00:25:51.790
But then your count is
not going to add up right.

00:25:51.790 --> 00:25:54.820
Because you wouldn't-- you
did not find all the reachable

00:25:54.820 --> 00:25:56.260
nodes.

00:25:56.260 --> 00:25:58.300
If t is one of the
reachable nodes,

00:25:58.300 --> 00:26:00.400
and you know there are
100 reachable nodes,

00:26:00.400 --> 00:26:03.040
and you skipped over
t as one of the ones

00:26:03.040 --> 00:26:05.320
that you say is
unreachable, you at best

00:26:05.320 --> 00:26:07.360
can only find 99
reachable nodes.

00:26:07.360 --> 00:26:11.030
And you're not going
to end up saying no.

00:26:11.030 --> 00:26:14.502
You're going to
end up rejecting.

00:26:14.502 --> 00:26:15.710
So it's a very good question.

00:26:15.710 --> 00:26:18.530
But you have to think through
what's going to happen here.

00:26:18.530 --> 00:26:22.080
This c here is kind of a check.

00:26:22.080 --> 00:26:29.512
It's almost like, well,
it's like a checksum,

00:26:29.512 --> 00:26:30.470
if you know what it is.

00:26:30.470 --> 00:26:33.125
It makes sure that
everything that--

00:26:33.125 --> 00:26:34.730
if you got to c.

00:26:34.730 --> 00:26:36.260
If you got to--

00:26:36.260 --> 00:26:38.420
if k equals c at
this point, that

00:26:38.420 --> 00:26:40.710
means you actually found
all of the reachable nodes.

00:26:40.710 --> 00:26:44.615
So c is kind of a check that you
found all the reachable nodes.

00:26:49.090 --> 00:26:49.590
Right?

00:26:49.590 --> 00:26:52.800
So if k equals c
at this point, you

00:26:52.800 --> 00:26:56.785
have found every reachable node.

00:26:56.785 --> 00:26:58.660
And t was one of the
ones that are reachable.

00:26:58.660 --> 00:26:59.470
You found t.

00:27:04.660 --> 00:27:05.395
OK, let's see.

00:27:09.070 --> 00:27:11.260
Is the reason we do this
with c essentially so

00:27:11.260 --> 00:27:13.210
that we know when we
can stop guessing,

00:27:13.210 --> 00:27:16.270
and correctly identify if
it's impossible to reach t?

00:27:16.270 --> 00:27:18.070
Well, it's not a matter of--

00:27:18.070 --> 00:27:19.870
it's not a matter of
stopping guessing.

00:27:19.870 --> 00:27:24.100
It's a check that
we found everything.

00:27:24.100 --> 00:27:27.400
Because we're going to go
through and do all the guessing

00:27:27.400 --> 00:27:31.290
for every node no matter what.

00:27:31.290 --> 00:27:33.800
So we're not going to
stop anything early,

00:27:33.800 --> 00:27:35.950
unless we find that
t is reachable.

00:27:35.950 --> 00:27:37.250
Then we can stop early.

00:27:37.250 --> 00:27:39.723
But to show that t
is not reachable,

00:27:39.723 --> 00:27:41.390
we have to go through
the whole process.

00:27:46.820 --> 00:27:48.530
How come we intuitively
see that we don't

00:27:48.530 --> 00:27:49.850
have contradictory branches?

00:27:49.850 --> 00:27:52.510
That's sort of-- I was
trying to say that just now.

00:27:52.510 --> 00:27:54.830
I hope that got through.

00:27:54.830 --> 00:27:57.050
You can't have
contradictory branches,

00:27:57.050 --> 00:27:59.540
because if you got
to this stage here,

00:27:59.540 --> 00:28:02.450
you have found all
the reachable nodes.

00:28:02.450 --> 00:28:05.120
So at this stage,
if you got to six,

00:28:05.120 --> 00:28:07.520
you have made all
correct guesses.

00:28:10.260 --> 00:28:11.970
You have found all
the reachable nodes.

00:28:11.970 --> 00:28:13.890
You have convinced
yourself that they're all

00:28:13.890 --> 00:28:18.810
reachable by guessing
the path to them.

00:28:18.810 --> 00:28:21.630
And you've checked that
you have the right number

00:28:21.630 --> 00:28:24.550
of reachable nodes,
because it equals c.

00:28:24.550 --> 00:28:27.640
So you must have found them all.

00:28:27.640 --> 00:28:29.390
So you cannot have a
contradictory answer,

00:28:29.390 --> 00:28:31.530
because either t is one of the
ones you found, in which case,

00:28:31.530 --> 00:28:33.140
you would have already said yes.

00:28:33.140 --> 00:28:37.320
Or otherwise, you found them
all, and t was not one of them.

00:28:37.320 --> 00:28:39.950
And so you're going to say
no, you can't have both things

00:28:39.950 --> 00:28:40.910
cannot happen.

00:28:40.910 --> 00:28:41.600
Let's move on.

00:28:44.250 --> 00:28:46.950
So next thing we're going
to do is the next slide

00:28:46.950 --> 00:28:50.500
is exactly the
same as this slide.

00:28:50.500 --> 00:28:55.870
Except instead of
saying is t reachable,

00:28:55.870 --> 00:29:00.490
I want to know is it reachable
within d, within distance d.

00:29:05.040 --> 00:29:05.540
OK?

00:29:05.540 --> 00:29:07.567
So--

00:29:07.567 --> 00:29:09.650
Which is going to mean
exactly the same procedure.

00:29:09.650 --> 00:29:21.335
Can I get-- instead of asking
can I get from s to t with

00:29:21.335 --> 00:29:22.710
a path of any
length-- of course,

00:29:22.710 --> 00:29:24.240
it's going to be
at most length m--

00:29:24.240 --> 00:29:26.400
now I want to know, can
I get to from s to t

00:29:26.400 --> 00:29:29.530
by a path at most length d.

00:29:29.530 --> 00:29:32.920
These are the number of
edges in the path, say.

00:29:32.920 --> 00:29:38.360
And that's the same procedure,
because instead of--

00:29:38.360 --> 00:29:41.750
I'm just going to
cut things off at d.

00:29:41.750 --> 00:29:44.840
But if I know in
advance how many nodes

00:29:44.840 --> 00:29:48.790
are reachable
within d, I'm going

00:29:48.790 --> 00:29:51.970
to find all the nodes that are
reachable within d and see,

00:29:51.970 --> 00:29:55.230
was t one of the ones
reachable within d.

00:29:55.230 --> 00:29:56.470
It's the same exact idea.

00:29:56.470 --> 00:30:00.040
So here is the next slide,
which kind of shows that.

00:30:00.040 --> 00:30:02.400
So here is the definition.

00:30:02.400 --> 00:30:06.960
Path sub d means reachable by
a path of length of most d.

00:30:10.670 --> 00:30:15.020
So R sub d is all
of the ones that

00:30:15.020 --> 00:30:19.630
are reachable by a
path of that length.

00:30:19.630 --> 00:30:21.100
And c simply is the count.

00:30:21.100 --> 00:30:24.120
It's the number that
are reachable within d.

00:30:26.630 --> 00:30:28.280
So if you understood
the last slide,

00:30:28.280 --> 00:30:31.850
hopefully this slide will
seem kind of obvious to you.

00:30:31.850 --> 00:30:35.160
I'm going to just
highlight all the changes.

00:30:35.160 --> 00:30:39.900
So if I can now
calculate c sub d,

00:30:39.900 --> 00:30:44.690
which is the number reachable
by a path of most of length d,

00:30:44.690 --> 00:30:47.270
then I can test
whether or not nodes

00:30:47.270 --> 00:30:50.560
are reachable by a
path of that length.

00:30:50.560 --> 00:30:53.140
First, I calculate c sub d.

00:30:53.140 --> 00:30:57.310
I go, I pick every node as
being reachable within d or not.

00:30:57.310 --> 00:31:00.550
Now I just have to check that
my path that I'm guessing

00:31:00.550 --> 00:31:03.700
has length at most d,
instead of length of most m,

00:31:03.700 --> 00:31:07.080
which is what I had before.

00:31:07.080 --> 00:31:09.120
Keep a count of the
ones that I found.

00:31:09.120 --> 00:31:13.080
If that count equals c sub d,
then I know I found them all.

00:31:13.080 --> 00:31:16.530
If it's not equal to
c sub d, then I've

00:31:16.530 --> 00:31:18.090
made some bad choice
along the way,

00:31:18.090 --> 00:31:21.210
and I can just punt
and say I don't know.

00:31:21.210 --> 00:31:23.580
And if t was not one
of the ones that I've

00:31:23.580 --> 00:31:26.160
shown to be reachable
within d, then I

00:31:26.160 --> 00:31:28.350
know it's not
reachable within d.

00:31:28.350 --> 00:31:32.510
And so I can say no.

00:31:36.140 --> 00:31:39.360
So I don't know if this merits
any additional questions.

00:31:39.360 --> 00:31:42.292
But this is really the same.

00:31:42.292 --> 00:31:44.000
It's just a repeat of
the previous slide.

00:31:44.000 --> 00:31:48.260
What's kind of amazing
is now the last slide

00:31:48.260 --> 00:31:52.082
is going to be again a repeat.

00:31:52.082 --> 00:31:53.790
Let me just foreshadow
where we're going.

00:31:53.790 --> 00:31:56.540
But feel free to ask a question,
on this, or on the first slide,

00:31:56.540 --> 00:31:59.240
if you didn't-- on the previous
slide, if you didn't get that.

00:31:59.240 --> 00:32:01.310
Also, we can try to
help you out with that.

00:32:04.410 --> 00:32:07.090
The next slide,
what I'm going to do

00:32:07.090 --> 00:32:12.920
is show how to compute
all these c values.

00:32:12.920 --> 00:32:16.550
And I should
mention, the value c,

00:32:16.550 --> 00:32:18.210
which is the total
number of reachable,

00:32:18.210 --> 00:32:20.240
it's going to be
the same as c sub m.

00:32:20.240 --> 00:32:22.590
Reachable with an m, the
number of nodes of the graph.

00:32:22.590 --> 00:32:24.740
So if I can get up
to c sub m I'm done.

00:32:27.540 --> 00:32:34.620
And what I'm going to show
you is that knowing c sub i,

00:32:34.620 --> 00:32:36.510
I can compute c sub i plus 1.

00:32:36.510 --> 00:32:40.370
Or c sub d, I can
compute c sub d plus 1.

00:32:40.370 --> 00:32:44.000
Since I'm using d as my
index here basically.

00:32:44.000 --> 00:32:46.610
So c sub 0 we know is just s.

00:32:46.610 --> 00:32:51.120
Well, it's just 1, because
you can just start with s.

00:32:51.120 --> 00:32:53.300
That's the only thing
reachable within 0.

00:32:53.300 --> 00:32:59.600
And then, once I know that,
I can figure out c sub 1,

00:32:59.600 --> 00:33:03.380
c sub 2, c sub 3, and so on,
and then I get the c sub n,

00:33:03.380 --> 00:33:05.990
and then I have the count of
the total number reachable,

00:33:05.990 --> 00:33:07.970
and then I can test
the path function.

00:33:13.870 --> 00:33:16.210
So the trick now is
being able to count.

00:33:18.810 --> 00:33:21.270
Given c sub d, I would
like to figure out

00:33:21.270 --> 00:33:22.740
what is c sub d plus 1.

00:33:25.948 --> 00:33:27.240
Now, how am I going to do that?

00:33:27.240 --> 00:33:29.750
What I'm going to do
is that's my goal.

00:33:29.750 --> 00:33:32.870
What I'm going to do is
something in between.

00:33:32.870 --> 00:33:35.930
I'm going to do a theorem
just like this, but instead

00:33:35.930 --> 00:33:39.650
of giving c sub d, instead
of computing paths of d,

00:33:39.650 --> 00:33:42.810
I'm going to compute
paths of d plus 1.

00:33:42.810 --> 00:33:47.740
So knowing how many
are reachable from d,

00:33:47.740 --> 00:33:50.170
I'm going to give a
test for whether things

00:33:50.170 --> 00:33:52.870
are reachable within d plus 1.

00:33:52.870 --> 00:33:56.410
And the fact is, that's easy,
because this thing already

00:33:56.410 --> 00:34:01.020
tells me how to compute
whether I'm reachable within d.

00:34:01.020 --> 00:34:03.360
And being able to be
reachable from within d

00:34:03.360 --> 00:34:06.180
plus 1 means I have an
edge from something that's

00:34:06.180 --> 00:34:08.870
reachable within d.

00:34:08.870 --> 00:34:11.815
So if I can figure out which
are reachable within d, well,

00:34:11.815 --> 00:34:13.190
and I just want
to see, do I have

00:34:13.190 --> 00:34:18.870
an edge, do I have
an edge from one

00:34:18.870 --> 00:34:21.239
of the nodes that are
reachable within d.

00:34:21.239 --> 00:34:23.040
Then I'm reachable
within d plus 1.

00:34:25.610 --> 00:34:28.190
Then if I can test whether
individual nodes are

00:34:28.190 --> 00:34:31.880
reachable within d plus 1,
I can count how many nodes

00:34:31.880 --> 00:34:33.350
are reachable within d plus 1.

00:34:33.350 --> 00:34:36.385
That was that very first
easy theorem that I showed.

00:34:36.385 --> 00:34:37.760
So I know there's
a lot of pieces

00:34:37.760 --> 00:34:39.810
here that you have
to put together.

00:34:39.810 --> 00:34:42.980
But in the end, each individual
piece is not that bad.

00:34:46.155 --> 00:34:47.780
I don't know how many
of you follow me.

00:34:47.780 --> 00:34:51.360
Oh no, this is not
supposed to be here.

00:34:51.360 --> 00:34:53.630
There we go.

00:34:53.630 --> 00:34:56.199
So here is the last part,
which again, is just

00:34:56.199 --> 00:34:59.840
a simple modification of
what the previous slide had.

00:34:59.840 --> 00:35:03.050
So I'm going to
show how to compute

00:35:03.050 --> 00:35:05.340
the path d plus 1 function.

00:35:05.340 --> 00:35:08.060
So testing if there's
a path of length d

00:35:08.060 --> 00:35:11.610
plus 1 from s to some node t.

00:35:11.610 --> 00:35:14.490
But only knowing how many
nodes are reachable within d.

00:35:17.790 --> 00:35:19.770
So I'm going to
find all nodes that

00:35:19.770 --> 00:35:24.290
are reachable within d, just
like I did before, but see

00:35:24.290 --> 00:35:28.800
if any one of those
nodes has an edge to t.

00:35:28.800 --> 00:35:31.230
Not necessarily that
one is equal to t.

00:35:31.230 --> 00:35:33.990
Because that says that
t is reachable within d.

00:35:33.990 --> 00:35:37.020
But I want to know, does
it have an edge to t.

00:35:37.020 --> 00:35:40.250
That means t is reachable
within d plus 1.

00:35:40.250 --> 00:35:44.280
So if I find all the nodes that
are reachable within d, and t

00:35:44.280 --> 00:35:48.900
turns out to be reachable
from one of those by an edge,

00:35:48.900 --> 00:35:53.150
then t is reachable
within d plus 1.

00:35:53.150 --> 00:35:55.550
And if d is not reachable
from any of those nodes

00:35:55.550 --> 00:35:58.940
with an edge, then t is not
reachable from d plus 1.

00:35:58.940 --> 00:36:00.110
I hope you're following me.

00:36:00.110 --> 00:36:03.230
I'm not sure you are.

00:36:03.230 --> 00:36:05.600
So anyway, that's
the algorithm here.

00:36:05.600 --> 00:36:08.930
And the corollary
is that you can

00:36:08.930 --> 00:36:12.710
compute c sub d plus 1 from
c d, because if you can count

00:36:12.710 --> 00:36:15.030
the past, if you can
test for each node

00:36:15.030 --> 00:36:17.300
if it's reachable, as I
mentioned before, you go

00:36:17.300 --> 00:36:21.470
through all the nodes, see
whether the reachable d plus 1,

00:36:21.470 --> 00:36:23.780
and then count them up.

00:36:23.780 --> 00:36:25.220
Now I have c sub d plus 1.

00:36:25.220 --> 00:36:26.690
And now I'm done.

00:36:26.690 --> 00:36:38.000
Because I'm going to compute
each d plus 1 from the value

00:36:38.000 --> 00:36:39.680
d that I previously computed.

00:36:39.680 --> 00:36:41.510
I'm going to do
that for all these.

00:36:44.160 --> 00:36:46.980
Should say 0 here, actually.

00:36:46.980 --> 00:36:51.750
And except, if the path says--
if the path function now

00:36:51.750 --> 00:36:54.600
says that the answer is no.

00:36:54.600 --> 00:36:58.140
Because I'm trying to do
the complement of the path

00:36:58.140 --> 00:36:59.620
language.

00:36:59.620 --> 00:37:04.390
And reject if the path
thing for m says yes.

00:37:04.390 --> 00:37:07.750
And that's my non-deterministic
algorithm for the path

00:37:07.750 --> 00:37:11.720
complement problem.

00:37:11.720 --> 00:37:16.350
Anyway, maybe you need to
look at a little bit offline.

00:37:16.350 --> 00:37:19.518
It's presented in a little
bit different way in the book.

00:37:19.518 --> 00:37:21.810
I don't know if that will be
more or less clear to you.

00:37:21.810 --> 00:37:25.620
But I think this has been
a little bit more unpacked

00:37:25.620 --> 00:37:26.955
for the purposes of the lecture.

00:37:30.010 --> 00:37:31.440
So let's just see.

00:37:31.440 --> 00:37:35.820
I'm not getting any questions,
which probably means

00:37:35.820 --> 00:37:37.870
I've lost a huge chunk of you.

00:37:37.870 --> 00:37:40.765
But the good news is
we're going to move on

00:37:40.765 --> 00:37:41.640
to a different topic.

00:37:46.700 --> 00:37:49.880
But feel free to ask a question
on this if you want, or we're

00:37:49.880 --> 00:37:53.510
going to shift gears now to
talking about the hierarchy

00:37:53.510 --> 00:37:56.510
theorems, which is going to be
the second half of the lecture.

00:37:56.510 --> 00:37:59.540
Also, not so easy,
I have to say.

00:37:59.540 --> 00:38:01.820
Probably a little less
technical than this

00:38:01.820 --> 00:38:04.130
one is, but it's
also there's going

00:38:04.130 --> 00:38:09.140
to be spending time on just
mainly just one theorem.

00:38:09.140 --> 00:38:11.558
But anyway, so looking
ahead to where we're going,

00:38:11.558 --> 00:38:12.725
and then we'll have a break.

00:38:18.745 --> 00:38:22.640
What we've shown so far,
these are the major complexity

00:38:22.640 --> 00:38:23.210
classes.

00:38:23.210 --> 00:38:26.360
I'm not including, let's say,
the complementary classes,

00:38:26.360 --> 00:38:29.730
the co-NP type classes.

00:38:29.730 --> 00:38:32.360
These are the major
classes we've seen so far.

00:38:32.360 --> 00:38:37.730
And as we've seen, they form
a hierarchy of containments.

00:38:40.790 --> 00:38:42.830
Some of those
containments trivial,

00:38:42.830 --> 00:38:45.650
and some slightly less trivial.

00:38:45.650 --> 00:38:48.440
But we have not shown
whether any of these classes

00:38:48.440 --> 00:38:50.120
are different.

00:38:50.120 --> 00:38:52.970
We've pointed out that there
were some unsolved problems

00:38:52.970 --> 00:38:54.890
here, but do we know
any of these classes

00:38:54.890 --> 00:38:56.360
differ from each other?

00:38:56.360 --> 00:38:59.490
Or could it all
collapse down to L?

00:38:59.490 --> 00:39:04.080
And the answer to that is
we do know that PSPACE and L

00:39:04.080 --> 00:39:06.360
are actually different.

00:39:06.360 --> 00:39:09.430
That we can prove.

00:39:09.430 --> 00:39:14.830
And it relies on
the theorem that

00:39:14.830 --> 00:39:20.740
says if you give a Turing
machine more space,

00:39:20.740 --> 00:39:22.450
then you can do more things.

00:39:22.450 --> 00:39:28.210
So because PSPACE is a
bigger bound than log space,

00:39:28.210 --> 00:39:30.370
we know we can do more things.

00:39:30.370 --> 00:39:37.680
In fact, because NL is contained
within log squared space

00:39:37.680 --> 00:39:40.350
deterministically and
PSPACE is bigger than that,

00:39:40.350 --> 00:39:43.260
we actually can
separate PSPACE and NL.

00:39:43.260 --> 00:39:45.790
So we're going to
prove that today.

00:39:45.790 --> 00:39:47.460
So basically, the
idea of the theorem

00:39:47.460 --> 00:39:50.700
says that if you
give a Turing machine

00:39:50.700 --> 00:39:54.150
a bit more time or a bit more
space, then it can do more.

00:39:54.150 --> 00:39:56.100
So there are some
conditions on that

00:39:56.100 --> 00:39:59.460
we have to-- we'll get into.

00:39:59.460 --> 00:40:01.890
One of the conclusions
that we'll show

00:40:01.890 --> 00:40:08.213
is that time n squared,
if you compare with time--

00:40:08.213 --> 00:40:09.630
the things you can
do in n squared

00:40:09.630 --> 00:40:12.750
time versus the things you
can do in n cubed time,

00:40:12.750 --> 00:40:15.870
there are more things you
can do n cubed time than what

00:40:15.870 --> 00:40:17.160
you can do in n squared time.

00:40:17.160 --> 00:40:20.410
I mean, that's what
you would expect.

00:40:20.410 --> 00:40:22.350
But it's not the
case that everything

00:40:22.350 --> 00:40:26.190
we expect in complexity
theory, we can prove.

00:40:26.190 --> 00:40:28.260
This is one of the
things we can prove.

00:40:28.260 --> 00:40:31.240
So as you add more time,
you can do more things.

00:40:31.240 --> 00:40:32.760
So this is a proper subset here.

00:40:32.760 --> 00:40:34.890
So there are some
things n time n

00:40:34.890 --> 00:40:37.695
cubed that are not n time n
squared, and ditto for space.

00:40:40.400 --> 00:40:42.620
So that's going to be--

00:40:42.620 --> 00:40:45.830
that brings us to
our coffee break.

00:40:45.830 --> 00:40:48.860
And so feel free to
shoot me any questions

00:40:48.860 --> 00:40:53.530
about what we've done so
far, or anything else.

00:40:53.530 --> 00:40:58.660
And otherwise, we
will launch our timer,

00:40:58.660 --> 00:41:00.790
and I'll see you
in five minutes.

00:41:00.790 --> 00:41:03.320
OK, so getting some
good questions here.

00:41:03.320 --> 00:41:11.730
Could we also make a solution--
this is getting back to that,

00:41:11.730 --> 00:41:13.800
the logs-- the NL equals coNL.

00:41:13.800 --> 00:41:17.850
Somebody's saying could we just
make another selection just

00:41:17.850 --> 00:41:22.000
by non-deterministically
choosing C vertices,

00:41:22.000 --> 00:41:25.960
and then checking that
they're all reachable.

00:41:25.960 --> 00:41:32.320
That's effectively what
we're doing, but be careful,

00:41:32.320 --> 00:41:35.480
because we cannot
store C vertices.

00:41:35.480 --> 00:41:37.640
So that's why we're
doing them one at a time.

00:41:37.640 --> 00:41:40.450
We can't guess all
C vertices up front,

00:41:40.450 --> 00:41:43.300
because where are you
going to store all that?

00:41:43.300 --> 00:41:45.340
We only have log space.

00:41:45.340 --> 00:41:48.310
OK, another--
somebody is asking,

00:41:48.310 --> 00:41:50.200
how much working space
do we need for storing

00:41:50.200 --> 00:41:51.160
the intermediate steps?

00:41:51.160 --> 00:41:53.240
I'm not sure what
intermediate steps you mean.

00:41:53.240 --> 00:41:55.720
But if it's all to Ci values.

00:41:55.720 --> 00:41:59.830
You know, C going from
C0 to C1 to C2 to C3,

00:41:59.830 --> 00:42:01.960
we don't store those.

00:42:01.960 --> 00:42:07.210
All you need, you need C sub
D to calculate C sub D plus 1.

00:42:07.210 --> 00:42:09.190
And then you forget
C sub D. You couldn't

00:42:09.190 --> 00:42:10.183
store all the C values.

00:42:10.183 --> 00:42:11.350
But you don't need them all.

00:42:11.350 --> 00:42:14.020
You only need the most recent
one to go to the next one.

00:42:14.020 --> 00:42:15.820
OK, somebody's
asking, can I go over

00:42:15.820 --> 00:42:21.010
why the complement of path
in NL implies NL equal coNL?

00:42:21.010 --> 00:42:24.910
Because the
complement of path is,

00:42:24.910 --> 00:42:27.040
essentially it's coNL complete.

00:42:27.040 --> 00:42:29.290
I mean, it is.

00:42:29.290 --> 00:42:35.430
So everything in NL
is reducible to path.

00:42:35.430 --> 00:42:40.050
Everything in coNL is reducible
to the complement of path

00:42:40.050 --> 00:42:42.540
by the same reduction.

00:42:42.540 --> 00:42:44.910
And so if you can do
the complement of path

00:42:44.910 --> 00:42:49.320
in any class, you can do all of
the complements of NL languages

00:42:49.320 --> 00:42:50.430
in any class.

00:42:50.430 --> 00:42:52.740
And so you can do the
complement of path in NL,

00:42:52.740 --> 00:42:58.110
you can do all of the
coNL problems in NL.

00:42:58.110 --> 00:43:01.080
And so then NL equals coNL.

00:43:01.080 --> 00:43:03.570
You have to think
through the logic of it.

00:43:03.570 --> 00:43:05.670
That part is not hard.

00:43:05.670 --> 00:43:06.510
Why?

00:43:06.510 --> 00:43:10.410
It's enough to solve the path
complement problem in NL.

00:43:10.410 --> 00:43:11.520
That does everything else.

00:43:11.520 --> 00:43:13.395
Because it goes through
the same completeness

00:43:13.395 --> 00:43:16.200
phenomenon that
we've been seeing.

00:43:16.200 --> 00:43:19.470
Somebody is asking about
the two set problem

00:43:19.470 --> 00:43:21.450
that we talked about last time.

00:43:21.450 --> 00:43:28.020
And is it, and you know, I
pointed out that that's in NL.

00:43:28.020 --> 00:43:29.070
The two set problem.

00:43:29.070 --> 00:43:30.570
Well, the complement
of the two set,

00:43:30.570 --> 00:43:36.850
problem, the unsatisfiable
two set formulas.

00:43:36.850 --> 00:43:40.030
That's in NL language,
because you can basically

00:43:40.030 --> 00:43:43.115
look for a contradiction
non-deterministically in log

00:43:43.115 --> 00:43:43.615
space.

00:43:46.870 --> 00:43:49.982
I think I probably won't be able
to explain that in a minute.

00:43:49.982 --> 00:43:51.940
But maybe we'll have our
recitation instructors

00:43:51.940 --> 00:43:55.080
cover that in recitation.

00:43:55.080 --> 00:43:55.900
It's a nice proof.

00:43:55.900 --> 00:43:56.550
Not very hard.

00:43:56.550 --> 00:43:58.410
But it's a nice proof.

00:44:01.618 --> 00:44:03.910
It's something you have to
do, you have to think about,

00:44:03.910 --> 00:44:05.130
you have to argue.

00:44:05.130 --> 00:44:08.250
But it's still,
it's not super hard.

00:44:08.250 --> 00:44:10.110
Understanding the
two set problem.

00:44:10.110 --> 00:44:14.400
And the complement of two
set we showed, is in NL.

00:44:14.400 --> 00:44:18.270
And because NL equals coNL,
also the two set problem itself,

00:44:18.270 --> 00:44:21.720
without complemenation is in NL.

00:44:21.720 --> 00:44:23.010
And in fact, is NL complete.

00:44:25.845 --> 00:44:27.470
I think we're going
to have to move on.

00:44:30.243 --> 00:44:31.910
I'll stick around
after lecture, in case

00:44:31.910 --> 00:44:35.960
there's any questions that I can
answer quickly at that point.

00:44:35.960 --> 00:44:40.220
Sorry if I couldn't get
to your question just now.

00:44:40.220 --> 00:44:42.680
All right.

00:44:42.680 --> 00:44:44.315
Continuing on here.

00:44:48.280 --> 00:44:52.970
Shifting gears, the
space hierarchy theorem.

00:44:52.970 --> 00:45:01.110
So as I mentioned,
I think, maybe

00:45:01.110 --> 00:45:05.817
it's good to just go
back to this slide here.

00:45:05.817 --> 00:45:08.400
We're going to do the time and
space hierarchy theorems, which

00:45:08.400 --> 00:45:09.720
show that if you can
do a little bit more--

00:45:09.720 --> 00:45:12.012
if you give a little bit more
time or a little bit more

00:45:12.012 --> 00:45:14.460
space, you can do more things.

00:45:14.460 --> 00:45:18.420
We're going to do the space case
first, because that actually

00:45:18.420 --> 00:45:21.990
tends to be slightly, for
certain technical reasons

00:45:21.990 --> 00:45:24.310
slightly easier.

00:45:24.310 --> 00:45:28.360
So space hierarchy theorem.

00:45:28.360 --> 00:45:31.140
So here is the statement
of the theorem.

00:45:37.280 --> 00:45:45.710
So for any bound, think of s is
going to be some space bound.

00:45:45.710 --> 00:45:50.413
And again, f has to satisfy some
technical condition in yellow.

00:45:50.413 --> 00:45:52.080
Remember that it's
yellow because that's

00:45:52.080 --> 00:45:53.205
going to be relevant later.

00:45:55.840 --> 00:45:59.640
So there's going to be
some technical condition.

00:45:59.640 --> 00:46:03.840
No matter what function you
have, whatever space bound

00:46:03.840 --> 00:46:05.340
you have, as long
as it satisfies

00:46:05.340 --> 00:46:08.860
this condition, which is a mild
condition, but you need it.

00:46:08.860 --> 00:46:11.460
Whatever space
bound you have, you

00:46:11.460 --> 00:46:15.730
can find a language
A which requires

00:46:15.730 --> 00:46:19.300
exactly that much space.

00:46:19.300 --> 00:46:21.780
So if f is like n
cubed, we're going

00:46:21.780 --> 00:46:24.468
to find a language A that
requires n cubed space.

00:46:24.468 --> 00:46:26.760
If it's n to the hundredth,
we can find a language that

00:46:26.760 --> 00:46:28.980
requires n to the
hundredth space,

00:46:28.980 --> 00:46:32.280
and cannot be done
with n to 99-th space.

00:46:32.280 --> 00:46:36.570
Whatever it is, you can find
a language that requires

00:46:36.570 --> 00:46:38.220
exactly that much space.

00:46:38.220 --> 00:46:40.300
And if you like it a
little bit more formally,

00:46:40.300 --> 00:46:43.830
so that means that it can be
decided in that much space,

00:46:43.830 --> 00:46:45.840
but it cannot be
decided in less space.

00:46:49.987 --> 00:46:51.570
Framing it at a
slightly different way

00:46:51.570 --> 00:46:54.210
in terms of our
space classes, I'm

00:46:54.210 --> 00:46:57.270
going to define a
notion which is kind--

00:46:57.270 --> 00:47:00.690
it's not said this
way in the book,

00:47:00.690 --> 00:47:03.600
but maybe it's a helpful
way to write it down.

00:47:03.600 --> 00:47:06.480
It's space little o of f of n.

00:47:06.480 --> 00:47:07.980
So those are all
the things that you

00:47:07.980 --> 00:47:13.000
can do by a function that's a
little o of f of n in space.

00:47:13.000 --> 00:47:16.990
So space little o of f of n is
properly contained within space

00:47:16.990 --> 00:47:19.147
f of n.

00:47:19.147 --> 00:47:20.730
In other words,
there's something here

00:47:20.730 --> 00:47:21.647
which is not in there.

00:47:24.280 --> 00:47:26.380
Picture it
pictorially, I'm going

00:47:26.380 --> 00:47:29.860
to exhibit some language,
some explicit language

00:47:29.860 --> 00:47:34.947
A, which I can do in this much
space, but not in any less.

00:47:34.947 --> 00:47:37.030
Now, you can sort of think
of this as a little bit

00:47:37.030 --> 00:47:39.790
like the situation for
context-free language

00:47:39.790 --> 00:47:43.420
and regular languages, where we
exhibited a particular language

00:47:43.420 --> 00:47:45.820
that differentiated-- that
was in context free but not

00:47:45.820 --> 00:47:46.840
regular.

00:47:46.840 --> 00:47:50.130
And we're going to kind
of do the same thing now.

00:47:50.130 --> 00:47:53.640
But the one key difference is
that in the case of separating

00:47:53.640 --> 00:47:55.230
the context free
and the regular,

00:47:55.230 --> 00:47:59.740
we could give a nice language,
like 0 to the k, 1 to the k.

00:47:59.740 --> 00:48:03.090
Here, the language is not going
to be so nice to describe.

00:48:03.090 --> 00:48:06.030
It's going to be the language
that some Turing machine we're

00:48:06.030 --> 00:48:07.687
going to give decides.

00:48:07.687 --> 00:48:09.270
But you're not going
to be able to get

00:48:09.270 --> 00:48:12.300
a nice simple understanding of
A. It's going to be whatever

00:48:12.300 --> 00:48:13.700
that Turing machine does.

00:48:13.700 --> 00:48:17.070
And in that sense, it's
not a very natural language

00:48:17.070 --> 00:48:20.850
that's easy to sort of
get your mind around.

00:48:20.850 --> 00:48:26.970
So the outline, and really, you
don't have to worry about this,

00:48:26.970 --> 00:48:28.650
but maybe it helps.

00:48:28.650 --> 00:48:33.870
It's really going to be a kind
of a diagonalization proof.

00:48:33.870 --> 00:48:37.180
The way this machine
D is going to operate.

00:48:37.180 --> 00:48:42.150
So D is going to give
you my language A.

00:48:42.150 --> 00:48:44.280
So D is going to be
designed, and I'm

00:48:44.280 --> 00:48:46.920
going to show you D
on the next slide.

00:48:46.920 --> 00:48:51.600
D is going to run within my
target space bound, f of n.

00:48:51.600 --> 00:48:52.680
And here's the key.

00:48:52.680 --> 00:48:54.242
Here's the kicker.

00:48:54.242 --> 00:48:58.460
D is going to be designed to
make sure that its language

00:48:58.460 --> 00:49:02.640
cannot be done in less space.

00:49:02.640 --> 00:49:05.220
And the way it does
that is it makes sure

00:49:05.220 --> 00:49:09.810
that its language is different
from any language that

00:49:09.810 --> 00:49:16.312
is decidable by a Turing
machine in less space.

00:49:16.312 --> 00:49:18.520
And it's going to be different
in at least one place.

00:49:22.020 --> 00:49:26.180
So any-- D is going to guarantee
that its language cannot be

00:49:26.180 --> 00:49:28.850
done in little o
of f of n space,

00:49:28.850 --> 00:49:31.490
because it's going to be
different from every language

00:49:31.490 --> 00:49:37.220
that's doable in little o
of f of n space somewhere.

00:49:37.220 --> 00:49:38.090
That's the point.

00:49:38.090 --> 00:49:41.330
And then the language A is
going to be the language

00:49:41.330 --> 00:49:47.410
of this Turing machine D.

00:49:47.410 --> 00:49:49.130
So it looks like a tall order.

00:49:49.130 --> 00:49:51.940
The D has to make
sure that each--

00:49:51.940 --> 00:49:55.390
that for every
machine, its language

00:49:55.390 --> 00:49:58.420
differs from that
machine's language,

00:49:58.420 --> 00:50:01.360
if that machine is running in
little low o of f of n space.

00:50:01.360 --> 00:50:04.150
But it's basically going
to be a diagonalization.

00:50:04.150 --> 00:50:07.960
So for all of the different
possible inputs to D,

00:50:07.960 --> 00:50:10.570
that input is going
to actually code up

00:50:10.570 --> 00:50:15.207
a machine, on which
we're going to make sure

00:50:15.207 --> 00:50:16.790
that we're different
from that machine

00:50:16.790 --> 00:50:19.970
if it's a small space machine.

00:50:19.970 --> 00:50:21.050
Let's see if that--

00:50:21.050 --> 00:50:23.670
So I can take a couple
of questions here.

00:50:23.670 --> 00:50:25.070
Does f have to be computable?

00:50:25.070 --> 00:50:27.597
So that's going to be
one of the conditions

00:50:27.597 --> 00:50:29.180
that we're going to
have to guarantee.

00:50:29.180 --> 00:50:31.130
Where f satisfies a
technical condition,

00:50:31.130 --> 00:50:32.990
yeah, it's going to end
up being have-- it's

00:50:32.990 --> 00:50:33.740
going to be computable.

00:50:33.740 --> 00:50:34.670
But that's not enough.

00:50:38.653 --> 00:50:39.820
Good, good question, though.

00:50:43.960 --> 00:50:49.510
OK, so let's move on from there.

00:50:49.510 --> 00:50:53.760
So here is-- now what my job is
to give you this Turing machine

00:50:53.760 --> 00:50:58.500
D. So D, D's language is
going to be my language A,

00:50:58.500 --> 00:51:04.790
which requires f of n space,
cannot be done in less.

00:51:04.790 --> 00:51:06.230
OK, oops.

00:51:06.230 --> 00:51:07.520
I need to--

00:51:07.520 --> 00:51:10.010
I need the full slide here,
so I have to take myself out.

00:51:16.070 --> 00:51:17.270
All right.

00:51:17.270 --> 00:51:19.650
Now, this is my goal.

00:51:19.650 --> 00:51:22.070
I want to exhibit
this language A, which

00:51:22.070 --> 00:51:24.890
I can do in this much
space, but not in any less.

00:51:29.340 --> 00:51:33.750
And so I'm going to give this
machine D, as I mentioned,

00:51:33.750 --> 00:51:35.910
where A is D's language.

00:51:35.910 --> 00:51:37.800
D runs in order f of n space.

00:51:37.800 --> 00:51:40.630
And that sort of-- that
achieves this part.

00:51:40.630 --> 00:51:47.050
And D, make sure that its
language cannot be done in any

00:51:47.050 --> 00:51:48.860
less space.

00:51:48.860 --> 00:51:50.800
So that achieves this part.

00:51:50.800 --> 00:51:52.420
So it's different
from the language

00:51:52.420 --> 00:51:55.525
of any machine that runs in
little o of f of n space.

00:52:01.600 --> 00:52:08.520
So this is how D
is going to work.

00:52:08.520 --> 00:52:10.650
I'm going to try to give
you a little picture

00:52:10.650 --> 00:52:14.880
to help see to accompany
the description.

00:52:14.880 --> 00:52:20.500
So D gets its input w,
which is of length n.

00:52:20.500 --> 00:52:27.610
The very first thing D does
is it marks off f of n space.

00:52:27.610 --> 00:52:29.560
Because it's only
allowed to use--

00:52:29.560 --> 00:52:33.130
we're only going to allow
D to use f of n space.

00:52:33.130 --> 00:52:37.180
Because otherwise, we're
in danger of D not--

00:52:37.180 --> 00:52:40.000
of A not being in space f of n.

00:52:40.000 --> 00:52:43.300
So D is going to guarantee
that, by making sure

00:52:43.300 --> 00:52:46.810
it's going to mark
off f of n space.

00:52:46.810 --> 00:52:49.570
And if it ever tries to use
more than that, it just rejects.

00:52:52.090 --> 00:52:56.250
But by virtue of that,
we're sure that D's language

00:52:56.250 --> 00:52:57.450
is in space f of n.

00:52:57.450 --> 00:53:00.090
Because D is an f of n
space Turing machine.

00:53:00.090 --> 00:53:03.130
And it's going to be decided.

00:53:03.130 --> 00:53:09.510
So this part so far
is not too hard.

00:53:09.510 --> 00:53:12.010
Now we're going to start
getting into the meat here.

00:53:12.010 --> 00:53:22.330
So if w-- now, what we want
to think of w as a description

00:53:22.330 --> 00:53:24.670
of a machine that
we're going to feed--

00:53:24.670 --> 00:53:26.920
that's going to run on w.

00:53:26.920 --> 00:53:29.090
So this is going
to a little bit,

00:53:29.090 --> 00:53:32.710
you know, back to
an earlier when we

00:53:32.710 --> 00:53:34.000
talked about diagonalization.

00:53:34.000 --> 00:53:36.010
So don't get thrown off by this.

00:53:38.800 --> 00:53:42.040
We're going to think of w
not only as the input to D,

00:53:42.040 --> 00:53:46.450
but it's also going to be
the description of a machine.

00:53:46.450 --> 00:53:49.070
And if it turns out that w
doesn't describe anything,

00:53:49.070 --> 00:53:52.330
it's just a junk w, then
we're not interested.

00:53:52.330 --> 00:53:55.060
We're just going to
reject on that w.

00:53:55.060 --> 00:53:57.100
We're only interested
in the w's that

00:53:57.100 --> 00:54:03.410
do describe some machine M.

00:54:03.410 --> 00:54:08.330
So if M-- if w describes
some machine M,

00:54:08.330 --> 00:54:13.010
then we're going to run M on w.

00:54:13.010 --> 00:54:17.750
And we're going to do the
opposite of what M does.

00:54:17.750 --> 00:54:19.510
That's the whole idea.

00:54:19.510 --> 00:54:23.350
We're just going to make
sure that what we're doing

00:54:23.350 --> 00:54:24.970
is not the same as
what M is doing.

00:54:28.360 --> 00:54:36.410
So at a high level, the basic
idea for this is not hard.

00:54:36.410 --> 00:54:40.380
So we're going to
simulate M on w.

00:54:40.380 --> 00:54:43.427
If M rejects, then we'll accept.

00:54:43.427 --> 00:54:44.760
If M accepts, then we'll reject.

00:54:44.760 --> 00:54:46.372
We're just going
to do the opposite.

00:54:53.460 --> 00:54:55.460
And I think that is--

00:54:55.460 --> 00:54:57.650
so we have to be careful
when we do the simulation.

00:54:57.650 --> 00:54:59.040
This is a little
bit of a detail,

00:54:59.040 --> 00:55:02.443
but this is a proof where
you need to pay attention

00:55:02.443 --> 00:55:03.110
to some details.

00:55:05.810 --> 00:55:13.220
The cost of simulating M on
D is only a constant factor.

00:55:13.220 --> 00:55:17.090
Because if M uses a
certain amount of space,

00:55:17.090 --> 00:55:20.480
when D is simulating
M, you know,

00:55:20.480 --> 00:55:23.540
M may have a larger taper
alphabet than D does,

00:55:23.540 --> 00:55:29.120
but D can then encode M's
tape by using several cells

00:55:29.120 --> 00:55:30.710
for each of M's cells.

00:55:30.710 --> 00:55:32.760
But it's only going to
be a constant factor.

00:55:32.760 --> 00:55:36.170
And that's important
here, because we

00:55:36.170 --> 00:55:41.700
have to make sure that
if this was a big blowup,

00:55:41.700 --> 00:55:47.370
D would not be able to run M.
I think I'm sort of arguing

00:55:47.370 --> 00:55:49.290
the details without
making sure we understand

00:55:49.290 --> 00:55:51.210
the fundamental concept.

00:55:51.210 --> 00:55:54.090
So let me back up.

00:55:57.000 --> 00:56:02.070
The point is that D is doing
something the opposite of M.

00:56:02.070 --> 00:56:05.640
Now, D can't be
different from every M,

00:56:05.640 --> 00:56:08.250
because D itself is a
Turing machine, of course.

00:56:08.250 --> 00:56:11.460
But the thing is that
D is only running

00:56:11.460 --> 00:56:13.510
with an f of n tape cells.

00:56:13.510 --> 00:56:15.960
So it has to be able to
do that simulation of M

00:56:15.960 --> 00:56:17.370
within that amount of tape.

00:56:17.370 --> 00:56:19.380
If M is using a
lot of tape, then D

00:56:19.380 --> 00:56:21.922
is going to use a lot of tape,
and it's just going to reject.

00:56:24.130 --> 00:56:28.080
So this is only going to
really come into play,

00:56:28.080 --> 00:56:30.240
being able to
simulate M, if M is

00:56:30.240 --> 00:56:33.750
using a small amount
of space, so that D

00:56:33.750 --> 00:56:35.910
can do this simulation.

00:56:35.910 --> 00:56:38.213
Let's just see, maybe--

00:56:38.213 --> 00:56:39.880
so there's going to
be some issues here.

00:56:39.880 --> 00:56:41.380
But before I get
to that, let's just

00:56:41.380 --> 00:56:43.410
see what your questions are.

00:56:43.410 --> 00:56:46.710
How can a Turing machine know if
w is encoding some other Turing

00:56:46.710 --> 00:56:48.240
machine?

00:56:48.240 --> 00:56:49.590
Oh, that's simple.

00:56:49.590 --> 00:56:52.290
You know, what is a coding
of a Turing machine?

00:56:52.290 --> 00:56:56.090
It's just the standard--
we have a standard coding.

00:56:56.090 --> 00:56:59.100
It's just coding the
rules of the machine.

00:56:59.100 --> 00:57:01.680
So it has to have states,
transition function,

00:57:01.680 --> 00:57:02.770
blah, blah, blah.

00:57:02.770 --> 00:57:04.530
So it just has to
be some-- whatever

00:57:04.530 --> 00:57:06.450
our encoding for
the Turing machine

00:57:06.450 --> 00:57:11.927
is, we can always test whether a
string is a legitimate encoding

00:57:11.927 --> 00:57:12.760
of a Turing machine.

00:57:12.760 --> 00:57:15.870
So that shouldn't be bad.

00:57:15.870 --> 00:57:18.270
Somebody says, why do we
reject if we use more than f

00:57:18.270 --> 00:57:19.620
of n cells?

00:57:19.620 --> 00:57:22.640
Isn't it OK to use order f of n?

00:57:22.640 --> 00:57:23.550
Yes, it could be.

00:57:23.550 --> 00:57:25.870
But we have to cut
it off somewhere.

00:57:25.870 --> 00:57:28.700
It might be-- it's OK,
we could use 2 f of n.

00:57:28.700 --> 00:57:30.110
We could use 10 f of n.

00:57:30.110 --> 00:57:33.680
But we have to have
some constant for D.

00:57:33.680 --> 00:57:35.720
And that's just
simply constant 1.

00:57:35.720 --> 00:57:39.470
So D has to run
within f of n cells.

00:57:39.470 --> 00:57:41.960
And that's going to
be good enough for us.

00:57:41.960 --> 00:57:45.320
OK, do we have to make sure that
M runs in little o of f of n?

00:57:45.320 --> 00:57:47.810
So we can't really
tell whether M is

00:57:47.810 --> 00:57:50.220
running in little o of f of n.

00:57:50.220 --> 00:57:53.580
All we can tell is whether
we can finish the simulation.

00:57:53.580 --> 00:57:55.200
So that's actually going to be--

00:57:55.200 --> 00:57:58.020
maybe you can just hold off on
that question, because there

00:57:58.020 --> 00:58:01.140
is a point that we have to
follow up on in that, which

00:58:01.140 --> 00:58:06.420
is just because
we may or may not

00:58:06.420 --> 00:58:10.200
be able to finish
simulating M on this w

00:58:10.200 --> 00:58:12.990
doesn't necessarily tell us what
the asymptotic behavior of M

00:58:12.990 --> 00:58:13.490
is.

00:58:13.490 --> 00:58:15.480
But we'll have to
look at that in a bit.

00:58:15.480 --> 00:58:17.790
So somebody saying, what
happens if M loops on w?

00:58:17.790 --> 00:58:20.207
That's going to be one of our
issues we have to deal with.

00:58:20.207 --> 00:58:21.950
That's a good question there.

00:58:21.950 --> 00:58:25.030
Step two alone can use
more than f of n cells.

00:58:25.030 --> 00:58:27.620
Yes, step two alone can
use more than f of n cells.

00:58:27.620 --> 00:58:30.428
If it does, we're just
going to end up rejecting.

00:58:30.428 --> 00:58:31.970
So we're getting
good questions here.

00:58:31.970 --> 00:58:33.920
Some of them I'm going
to address anyway,

00:58:33.920 --> 00:58:35.330
so why don't we just move on.

00:58:40.810 --> 00:58:42.250
So here is sort of a question.

00:58:42.250 --> 00:58:46.135
I think this is one of the
questions that related to one

00:58:46.135 --> 00:58:47.260
of the ones that got asked.

00:58:47.260 --> 00:58:50.510
What happens if it runs in
little o of f of n space?

00:58:50.510 --> 00:58:53.110
So remember, what
we're trying to do

00:58:53.110 --> 00:58:55.870
is be different from
every small space.

00:58:55.870 --> 00:58:58.790
You know, little o of
f of n space machine.

00:58:58.790 --> 00:59:01.960
So what if M runs in
little o of f of n space,

00:59:01.960 --> 00:59:04.320
but has a big constant?

00:59:04.320 --> 00:59:05.960
So what I mean by
that concretely,

00:59:05.960 --> 00:59:09.320
is suppose D is
an n cubed space.

00:59:09.320 --> 00:59:13.970
So suppose we're trying
to get A in n cubed space,

00:59:13.970 --> 00:59:18.030
but show it's not
in n squared space.

00:59:18.030 --> 00:59:20.950
So D is going to run in n cubed.

00:59:20.950 --> 00:59:25.020
And we have to make sure that
any machine that's running in n

00:59:25.020 --> 00:59:28.302
squared space cannot
do the same language.

00:59:28.302 --> 00:59:30.010
So we're going to be
different from that.

00:59:30.010 --> 00:59:37.190
But the problem is
that the machine

00:59:37.190 --> 00:59:42.280
M might be running
in n squared space,

00:59:42.280 --> 00:59:43.550
but with a huge constant.

00:59:43.550 --> 00:59:46.130
So it might be running
in a million n squared.

00:59:46.130 --> 00:59:51.370
So that's still a machine that's
running in little o of n cubed.

00:59:51.370 --> 00:59:52.870
And we have to be
different from it.

00:59:52.870 --> 00:59:55.510
But for the particular
w we're working on,

00:59:55.510 --> 00:59:58.240
we might not have
enough space to run M,

00:59:58.240 --> 01:00:01.180
because of the huge constant.

01:00:01.180 --> 01:00:02.890
The asymptotic
behavior is only going

01:00:02.890 --> 01:00:06.670
to be relevant for large W. For
small w, we may not see that.

01:00:06.670 --> 01:00:11.050
We may not have enough
space to run M. So what

01:00:11.050 --> 01:00:12.640
are we going to do to fix that?

01:00:12.640 --> 01:00:16.250
We're going to run that M on
infinitely many different w's.

01:00:16.250 --> 01:00:19.600
There's going to be infinitely
many different w's that are all

01:00:19.600 --> 01:00:22.380
going to encode the same M.

01:00:22.380 --> 01:00:24.240
And the way I'm
going to do that is

01:00:24.240 --> 01:00:30.780
by thinking of w
as representing M,

01:00:30.780 --> 01:00:37.120
but having an unbounded number
of trailing zeros after that.

01:00:37.120 --> 01:00:39.690
So I'm going to strip off--
the very first thing I'm

01:00:39.690 --> 01:00:41.790
going to do with w, is
I'm going to strip off

01:00:41.790 --> 01:00:44.310
the trailing zeros up
until the final one.

01:00:44.310 --> 01:00:45.630
I'm going to remove those.

01:00:45.630 --> 01:00:50.290
And then take the rest, as the
description of the machine.

01:00:50.290 --> 01:00:52.860
So now, I'm going
to have potentially

01:00:52.860 --> 01:00:57.720
w's that have an enormous
number of zeros at the end,

01:00:57.720 --> 01:01:01.320
big enough so that I can see
the asymptotic behavior of M,

01:01:01.320 --> 01:01:05.250
and that if M is really running
in little o of f of n space,

01:01:05.250 --> 01:01:08.998
I'll have enough space to
run M to completion on w.

01:01:08.998 --> 01:01:11.040
And so then I'll be able
to be different from it.

01:01:13.820 --> 01:01:16.110
So I'm going to
showing that over here.

01:01:16.110 --> 01:01:20.170
So here's a very large
W. I'm going to strip off

01:01:20.170 --> 01:01:22.300
the trailing zeros.

01:01:22.300 --> 01:01:23.890
The rest of it is
just going to be M.

01:01:23.890 --> 01:01:28.080
And I'm going to run
this M on the whole w.

01:01:28.080 --> 01:01:30.390
The entire w, without
the zeroes stripped off.

01:01:30.390 --> 01:01:36.060
So now M is going to be
running on a very large input,

01:01:36.060 --> 01:01:41.700
big enough so that D, which
has asymptotically more space

01:01:41.700 --> 01:01:46.530
than M does, will have enough
space to run M to completion.

01:01:46.530 --> 01:01:48.150
Now, another question
that got asked.

01:01:48.150 --> 01:01:49.950
What happens if M loops?

01:01:49.950 --> 01:01:53.020
That's going to be a problem,
because D always has to hold.

01:01:53.020 --> 01:01:55.740
And if it just
blindly simulates M,

01:01:55.740 --> 01:01:58.560
then D might be
looping on M. Not

01:01:58.560 --> 01:02:00.900
if M is going to use a
lot of space, by the way.

01:02:00.900 --> 01:02:04.260
Because then D is going
to catch it in step one.

01:02:04.260 --> 01:02:09.930
But if M loops on a small
amount of space, then

01:02:09.930 --> 01:02:15.600
D might end up looping,
as presently constructed.

01:02:15.600 --> 01:02:17.480
So what I'm going
to do is I'm going

01:02:17.480 --> 01:02:20.450
to put a counter which
makes it stop if it

01:02:20.450 --> 01:02:24.090
runs for 2 to f of n space.

01:02:24.090 --> 01:02:26.280
So basically, because
that's how long

01:02:26.280 --> 01:02:30.590
D could possibly run
without looping anyway,

01:02:30.590 --> 01:02:32.940
and M could be running
without looping anyway.

01:02:32.940 --> 01:02:37.160
And so we're going to run
it for this number of steps.

01:02:37.160 --> 01:02:41.270
And I'm going to reject
if it hasn't yet halted,

01:02:41.270 --> 01:02:42.800
as well as that.

01:02:42.800 --> 01:02:46.440
Because it has to be looping
at that point anyway.

01:02:46.440 --> 01:02:48.253
And so it's not
interesting for us.

01:02:48.253 --> 01:02:49.670
It doesn't matter
what we're going

01:02:49.670 --> 01:02:51.080
to do if it hasn't halted.

01:02:51.080 --> 01:02:55.230
Because M is not a decider.

01:02:55.230 --> 01:02:59.290
And the last thing
is how to compute f.

01:02:59.290 --> 01:03:01.300
So I'll try to address
some questions here

01:03:01.300 --> 01:03:03.910
in our remaining time.

01:03:03.910 --> 01:03:05.840
How to compute f.

01:03:05.840 --> 01:03:09.410
So to mark off f of n cells,
we also have to compute f.

01:03:09.410 --> 01:03:11.720
I didn't think any of you
guys asked that question,

01:03:11.720 --> 01:03:13.880
except maybe sort at
the very beginning,

01:03:13.880 --> 01:03:17.020
about f being a
computable function.

01:03:17.020 --> 01:03:19.120
Certainly, f is going to
have to be computable.

01:03:19.120 --> 01:03:21.040
But not only does it
have to be computable,

01:03:21.040 --> 01:03:24.005
it has to be computable
within the space bound.

01:03:24.005 --> 01:03:25.630
And that's just going
to be a condition

01:03:25.630 --> 01:03:27.100
we're going to impose on f.

01:03:27.100 --> 01:03:29.710
It's so called space
constructable, namely,

01:03:29.710 --> 01:03:34.060
that you can compute it
within its own space bound.

01:03:34.060 --> 01:03:36.940
And all nice functions
that we care about

01:03:36.940 --> 01:03:39.430
are going to be
space constructable.

01:03:39.430 --> 01:03:46.300
So it doesn't turn out to
be an obstacle to applying

01:03:46.300 --> 01:03:49.420
the hierarchy theorem, but it
is a condition that we need.

01:03:49.420 --> 01:03:54.310
It actually is not true
without that condition.

01:03:54.310 --> 01:03:56.740
Let's just-- oh, I
have a check-in here.

01:03:56.740 --> 01:03:58.795
Maybe if we can take a
couple of questions first.

01:04:03.180 --> 01:04:06.570
Some of you are anticipating
my check-in actually,

01:04:06.570 --> 01:04:09.150
which is good.

01:04:09.150 --> 01:04:11.550
So let me hold off on those.

01:04:11.550 --> 01:04:16.360
Sorry, a bit confused about what
is M. Can we say D is input M,

01:04:16.360 --> 01:04:17.710
and simulates M on-- yeah.

01:04:17.710 --> 01:04:23.800
So somebody is saying, can
we say that D has input M,

01:04:23.800 --> 01:04:25.570
and simulates M on itself?

01:04:25.570 --> 01:04:28.070
Yes, that's exactly
what's happening.

01:04:28.070 --> 01:04:31.750
The reason why we're doing that
is because we have to cover all

01:04:31.750 --> 01:04:33.460
possible M's.

01:04:33.460 --> 01:04:37.120
So as we get all
possible inputs w,

01:04:37.120 --> 01:04:39.460
they're going to range
over all possible M's.

01:04:39.460 --> 01:04:43.030
And so every possible M
is going to get addressed

01:04:43.030 --> 01:04:47.230
to see if we can run it
within the space bound,

01:04:47.230 --> 01:04:49.930
and be different from it.

01:04:49.930 --> 01:04:53.020
D's job is to be different
from each of those M's.

01:04:53.020 --> 01:04:55.600
But it's not-- again,
there is some details here

01:04:55.600 --> 01:04:59.470
that got raised in these issues.

01:04:59.470 --> 01:05:04.430
But in a sense, this is
just kind of more technical,

01:05:04.430 --> 01:05:07.000
I would focus on understanding
what I originally wrote down,

01:05:07.000 --> 01:05:08.350
because that's the main idea.

01:05:08.350 --> 01:05:13.060
The rest of it is just
implementation details.

01:05:13.060 --> 01:05:14.330
So why don't I--

01:05:14.330 --> 01:05:16.690
can I give an example of
a nonspace constructable

01:05:16.690 --> 01:05:17.710
function?

01:05:17.710 --> 01:05:19.380
Yes.

01:05:19.380 --> 01:05:22.330
Log log log n space.

01:05:22.330 --> 01:05:26.280
You cannot compute log log log
n space within log log log n

01:05:26.280 --> 01:05:27.180
space.

01:05:27.180 --> 01:05:29.940
And in fact, it's
known that there's

01:05:29.940 --> 01:05:34.230
nothing new between constant
space, which is just regular,

01:05:34.230 --> 01:05:36.180
and log log log n space.

01:05:36.180 --> 01:05:38.130
Anything you can
do in log log log

01:05:38.130 --> 01:05:40.570
n space is a regular language.

01:05:40.570 --> 01:05:45.060
So the hierarchy theorem
doesn't want to apply there.

01:05:45.060 --> 01:05:50.190
Because well, it applies,
but that's not a--

01:05:50.190 --> 01:05:52.670
it's not space constructable.

01:05:52.670 --> 01:05:59.360
To find higher level large
nonspace constructable

01:05:59.360 --> 01:06:06.840
functions, you can do it, but
they're not easy to describe.

01:06:06.840 --> 01:06:08.580
Let's do our check-in here.

01:06:08.580 --> 01:06:10.473
What happens when
we run D on itself?

01:06:10.473 --> 01:06:12.390
I got a couple of people
asking me about that.

01:06:12.390 --> 01:06:15.030
So this is just a good
lead in to our check-in.

01:06:15.030 --> 01:06:16.050
And this a little--

01:06:16.050 --> 01:06:17.550
you really have to
understand what's

01:06:17.550 --> 01:06:23.740
going on, to see what does D
do when if you feed in itself,

01:06:23.740 --> 01:06:25.630
maybe with some trailing zeros.

01:06:25.630 --> 01:06:28.690
Because remember, the algorithm
strips off trailing zeros.

01:06:28.690 --> 01:06:31.400
So what does it do in that case?

01:06:31.400 --> 01:06:33.850
So here are my options there.

01:06:33.850 --> 01:06:39.232
You can get to pick which
one you think is the answer.

01:06:39.232 --> 01:06:40.690
So I'll give you
another 30 seconds

01:06:40.690 --> 01:06:43.510
on this, because this requires
a little bit of thinking.

01:06:43.510 --> 01:06:45.190
If you want to invest in it.

01:06:45.190 --> 01:06:45.760
All right.

01:06:50.500 --> 01:06:52.000
Wrap this up, guys.

01:06:55.160 --> 01:06:56.210
5 seconds to go.

01:07:01.000 --> 01:07:08.070
OK, I'm going to end it, so get
your participation points in.

01:07:08.070 --> 01:07:10.120
A bunch of you have
not said anything.

01:07:10.120 --> 01:07:11.920
Come on.

01:07:11.920 --> 01:07:15.480
I can see the count here,
and it's three or four

01:07:15.480 --> 01:07:17.460
of you are not answered.

01:07:17.460 --> 01:07:18.960
Well, you're going to lose out.

01:07:18.960 --> 01:07:20.050
Closing.

01:07:20.050 --> 01:07:20.550
All right.

01:07:20.550 --> 01:07:24.180
So the right answer is, in
fact, C. It does reject.

01:07:24.180 --> 01:07:25.680
Let's just understand
what happened.

01:07:25.680 --> 01:07:27.873
It's definitely we don't
get a contradiction.

01:07:27.873 --> 01:07:29.790
I mean, this is an
algorithm I just described.

01:07:29.790 --> 01:07:30.930
It's going to do something.

01:07:34.770 --> 01:07:39.180
I'm assuming the people who
picked E are having fun,

01:07:39.180 --> 01:07:41.160
as I did when I came
up with the check-in.

01:07:45.258 --> 01:07:48.388
But not a question--
answer A is not

01:07:48.388 --> 01:07:50.680
going to be good either,
because D has to be a decider.

01:07:50.680 --> 01:07:52.247
So it can't loop on anything.

01:07:52.247 --> 01:07:53.830
So the only sort of
reasonable answers

01:07:53.830 --> 01:07:56.770
are reject, accept, or reject.

01:07:56.770 --> 01:08:03.390
When you run D on itself,
what's it going to try to do?

01:08:03.390 --> 01:08:04.950
It's going to-- the
very first thing

01:08:04.950 --> 01:08:08.460
it's going to mark
off f of n tape cells.

01:08:08.460 --> 01:08:11.580
And then it's going to get
its input, which is itself,

01:08:11.580 --> 01:08:14.520
tries to simulate itself
on the same input.

01:08:14.520 --> 01:08:17.580
That simulated D is
also going to try

01:08:17.580 --> 01:08:19.620
to mark off f of n tape cells.

01:08:19.620 --> 01:08:22.979
But due to some
simulation-- there's

01:08:22.979 --> 01:08:25.410
going to be some cost
to doing the simulation.

01:08:25.410 --> 01:08:27.270
When the simulated
D is going to try

01:08:27.270 --> 01:08:29.460
to mark off f of
n tape cells it's

01:08:29.460 --> 01:08:33.310
going to blow the
original D's space bound

01:08:33.310 --> 01:08:34.660
and exceed the bound.

01:08:34.660 --> 01:08:39.920
And so D is going to
reject upright in step one

01:08:39.920 --> 01:08:42.350
when it tries to get
an input of itself.

01:08:46.109 --> 01:08:48.130
It's very clear what's
going to happen.

01:08:48.130 --> 01:08:50.430
It's just going to
reject, because of--

01:08:50.430 --> 01:08:53.220
for this, reject in particular.

01:08:53.220 --> 01:08:57.020
And notice this, you know, yes.

01:08:57.020 --> 01:09:00.890
You know, OK, let me
not try to confuse it.

01:09:00.890 --> 01:09:04.800
OK, so that's all I
want to say about this.

01:09:04.800 --> 01:09:07.640
Let's now move in our
remaining 7 minutes

01:09:07.640 --> 01:09:11.710
to the time hierarchy
theorem, which

01:09:11.710 --> 01:09:13.930
is very has the same proof.

01:09:13.930 --> 01:09:16.772
But some of the technical
details are slightly different.

01:09:21.620 --> 01:09:24.350
So now, if I give
you a time bound,

01:09:24.350 --> 01:09:26.810
again, we are going to have
to face with the same notion,

01:09:26.810 --> 01:09:28.268
that you have to
be able to compute

01:09:28.268 --> 01:09:31.208
f within x amount of time.

01:09:31.208 --> 01:09:32.750
So it has to be a
time constructable.

01:09:32.750 --> 01:09:36.149
I'm not going to define that.

01:09:36.149 --> 01:09:40.590
So there's a language A which
requires that much time.

01:09:40.590 --> 01:09:42.578
So it has to be decided
within that much time.

01:09:42.578 --> 01:09:44.120
But there's a slight
difference here.

01:09:44.120 --> 01:09:47.149
And this is an artifact of
the proof of the theorem,

01:09:47.149 --> 01:09:51.319
not because it's an absolute
truth, as far as we know.

01:09:51.319 --> 01:09:54.380
It's not that it's not
decidable in little o of f of n.

01:09:54.380 --> 01:09:57.860
You actually, you can only
prove something slightly weaker

01:09:57.860 --> 01:09:59.630
when you have one
tape Turing machines.

01:09:59.630 --> 01:10:03.500
That it's decidable
in little o over--

01:10:03.500 --> 01:10:09.890
there's a slight gap
in what you can prove.

01:10:09.890 --> 01:10:12.470
So it's not only that
you can't prove--

01:10:12.470 --> 01:10:13.670
it requires little o.

01:10:13.670 --> 01:10:15.240
But little o of--

01:10:15.240 --> 01:10:18.710
little o of f of
n over log f of n

01:10:18.710 --> 01:10:23.070
is what you can prove that you
get from this time hierarchy

01:10:23.070 --> 01:10:23.570
theorem.

01:10:23.570 --> 01:10:25.730
But let's not get caught
up on that for now.

01:10:31.390 --> 01:10:34.060
So the proof outline is the
same outline as we had before.

01:10:36.670 --> 01:10:40.280
We're going to give a D that
runs in order f of n time.

01:10:40.280 --> 01:10:46.360
So it ensures that the language
is in that time complexity

01:10:46.360 --> 01:10:48.040
class time f of n.

01:10:48.040 --> 01:10:50.770
And it makes sure it's different
from every machine that

01:10:50.770 --> 01:10:52.600
runs faster.

01:10:52.600 --> 01:10:55.420
By some significant--
by a log factor faster.

01:10:59.600 --> 01:11:06.570
And so, why don't I
show how that goes.

01:11:06.570 --> 01:11:10.280
The proof is, in some ways,
almost exactly the same.

01:11:13.050 --> 01:11:16.410
I'm going to give a D, which
runs in this much time,

01:11:16.410 --> 01:11:19.710
and it shows it's
different from every M that

01:11:19.710 --> 01:11:24.880
runs in a lot less time.

01:11:24.880 --> 01:11:29.082
Here is the algorithm for
D. Now, it computes f of n.

01:11:29.082 --> 01:11:31.290
But it does something a
little different with f of n.

01:11:31.290 --> 01:11:34.890
Remember, in the space
hierarchy theorem,

01:11:34.890 --> 01:11:38.970
we marked off f of n space.

01:11:38.970 --> 01:11:41.850
Now, this f of n is going to be
used for a different purpose.

01:11:41.850 --> 01:11:44.410
It's going to be a clock.

01:11:44.410 --> 01:11:48.606
And you have to shut M down
if it runs for more than f

01:11:48.606 --> 01:11:50.020
of n steps.

01:11:50.020 --> 01:11:51.895
Not if it uses more
than f of n space.

01:11:54.760 --> 01:11:59.290
Because we're only interested in
M's that use significantly less

01:11:59.290 --> 01:12:01.130
than f of n time.

01:12:01.130 --> 01:12:06.430
So we're going to run M for
f for some number of steps.

01:12:06.430 --> 01:12:08.920
Whatever M says, we're
going to do the opposite.

01:12:08.920 --> 01:12:11.590
And only if we can actually
finish that simulation,

01:12:11.590 --> 01:12:13.390
will we be able to
be sure that we're

01:12:13.390 --> 01:12:16.770
different from what M is doing.

01:12:16.770 --> 01:12:18.270
So this is the whole
algorithm here.

01:12:18.270 --> 01:12:21.460
We don't have to do any
further modifications.

01:12:21.460 --> 01:12:25.080
And where is that log
n factor coming from?

01:12:25.080 --> 01:12:26.790
It's actually coming
from a funny place.

01:12:30.140 --> 01:12:34.190
And you have to get into a
little bit of the guts of this.

01:12:34.190 --> 01:12:39.360
When you're simulating M on
w, remember that M itself

01:12:39.360 --> 01:12:41.798
was described by w.

01:12:41.798 --> 01:12:43.340
So you're going to
have to write down

01:12:43.340 --> 01:12:50.200
a copy of M, which is just
as described by W. And then

01:12:50.200 --> 01:12:51.700
so you're going
to-- and then you're

01:12:51.700 --> 01:12:55.370
going to have the tape
that M is working on,

01:12:55.370 --> 01:12:57.460
which is starting
out with w on it.

01:13:00.090 --> 01:13:03.930
And you have to be, now you
have to be a little careful

01:13:03.930 --> 01:13:05.080
how you manage that.

01:13:05.080 --> 01:13:08.190
Because if your
description of M is just

01:13:08.190 --> 01:13:13.580
sitting at the beginning of the
tape, as you're simulating M,

01:13:13.580 --> 01:13:16.940
every time you do one step
in modifying the tape,

01:13:16.940 --> 01:13:19.820
you don't want to
have to go back

01:13:19.820 --> 01:13:23.980
to the beginning of the tape
to look up the next step of M.

01:13:23.980 --> 01:13:27.430
So you actually have to
carry M along with you

01:13:27.430 --> 01:13:29.930
as you're doing the simulation.

01:13:29.930 --> 01:13:34.090
And you can do that by expanding
the tape alphabet of the tape

01:13:34.090 --> 01:13:39.290
so that you can effectively
have two symbols on one cell.

01:13:39.290 --> 01:13:41.560
One is going to be
for describing M,

01:13:41.560 --> 01:13:45.910
and the other one is going to
be for just for the simulation

01:13:45.910 --> 01:13:46.780
tape.

01:13:46.780 --> 01:13:49.450
And you'll be carrying
M along with you

01:13:49.450 --> 01:13:51.550
wherever your head
is, so you don't have

01:13:51.550 --> 01:13:57.190
to go very far to look up M.
And so that's all possible,

01:13:57.190 --> 01:13:59.890
because that's going to add only
a constant factor, because M

01:13:59.890 --> 01:14:02.470
is fixed in size,
doesn't depend on--

01:14:07.331 --> 01:14:10.370
for large inputs
to M, M is fixed.

01:14:10.370 --> 01:14:13.510
But the tricky thing
here is the counter,

01:14:13.510 --> 01:14:15.310
to make sure we're not
using too much time.

01:14:18.250 --> 01:14:21.010
The counter has size log
f of n, because that's

01:14:21.010 --> 01:14:25.180
how big it has to count up to
so you can shut it down if it's

01:14:25.180 --> 01:14:28.540
going to exceed f of n steps.

01:14:28.540 --> 01:14:32.230
And let's see,
you'll have to run

01:14:32.230 --> 01:14:33.850
for a certain amount of time.

01:14:33.850 --> 01:14:38.380
And keeping the
counter nearby has--

01:14:38.380 --> 01:14:40.660
the counter now, it
can be pretty big.

01:14:40.660 --> 01:14:46.570
And so that's going to cost you
a log factor of simulation cost

01:14:46.570 --> 01:14:50.390
to move that counter
around all the time.

01:14:50.390 --> 01:14:56.980
And so that's why you have to
run for only a log factor less,

01:14:56.980 --> 01:15:00.610
so that you can actually
finish within f of n time,

01:15:00.610 --> 01:15:02.890
as you're required to do.

01:15:02.890 --> 01:15:04.720
I realize that that's
a mouthful there.

01:15:04.720 --> 01:15:06.850
And you may not have
all understood that.

01:15:06.850 --> 01:15:07.782
It doesn't matter.

01:15:07.782 --> 01:15:08.740
It's not that critical.

01:15:08.740 --> 01:15:10.448
I think what I'm really
more concerned is

01:15:10.448 --> 01:15:15.430
you understand the main idea
of the hierarchy theorem.

01:15:15.430 --> 01:15:21.430
Some of these implementation
details, if you don't get them,

01:15:21.430 --> 01:15:22.810
I wouldn't worry about it.

01:15:22.810 --> 01:15:25.300
I feel I have to include
them for completeness sake

01:15:25.300 --> 01:15:27.080
and to be honest with
you about the proof.

01:15:27.080 --> 01:15:29.470
But if you didn't follow
everything, that's OK.

01:15:29.470 --> 01:15:34.540
I do want to understand the main
idea, though, of the algorithm,

01:15:34.540 --> 01:15:37.660
making sure that what it's
doing is different from what

01:15:37.660 --> 01:15:41.380
every machine is doing if that
machine runs in little o of f

01:15:41.380 --> 01:15:45.970
of n space or a small amount
of time, little o of f of n

01:15:45.970 --> 01:15:48.520
over log f of n time.

01:15:48.520 --> 01:15:52.400
And I think we're
going to end here.

01:15:52.400 --> 01:15:54.580
So we're pretty
much out of time.

01:15:54.580 --> 01:15:58.570
I'm going to stick
around for a little bit,

01:15:58.570 --> 01:16:00.460
in case there's
any questions here.

01:16:00.460 --> 01:16:03.700
Oh, there's one last
check-in though.

01:16:03.700 --> 01:16:04.510
Let's look at this.

01:16:04.510 --> 01:16:06.610
This is kind of an
interesting sort of follow on

01:16:06.610 --> 01:16:09.550
to the hierarchy theorem.

01:16:09.550 --> 01:16:12.400
If you look at the two
questions, does L equal P,

01:16:12.400 --> 01:16:15.380
and does P equal P space?

01:16:15.380 --> 01:16:19.090
These are both
unsolved problems.

01:16:19.090 --> 01:16:21.070
What, if anything, does
the hierarchy theorem

01:16:21.070 --> 01:16:24.400
tell us about those questions?

01:16:24.400 --> 01:16:27.100
And it's kind of interesting,
that there are actually-- well,

01:16:27.100 --> 01:16:32.650
I'll leave it to you to tell
me if you can see what it

01:16:32.650 --> 01:16:34.390
might actually be telling you.

01:16:34.390 --> 01:16:35.620
Closing.

01:16:35.620 --> 01:16:36.640
Get your answer in.

01:16:39.800 --> 01:16:42.890
OK, 1, 2, 3.

01:16:42.890 --> 01:16:45.780
I feel like I'm running
an auction house here.

01:16:45.780 --> 01:16:46.905
And I should have a gavel.

01:16:53.910 --> 01:16:57.390
Yes, in fact, we know
that these are separated.

01:16:57.390 --> 01:16:59.130
So it's not-- even
though we don't

01:16:59.130 --> 01:17:01.560
know if L equals P,
or P equal P space,

01:17:01.560 --> 01:17:03.330
they can't both be equal.

01:17:03.330 --> 01:17:06.520
Because then L
would equal P space,

01:17:06.520 --> 01:17:08.970
and we know that's false.

01:17:08.970 --> 01:17:11.920
So at least one of
these has the answer no.

01:17:11.920 --> 01:17:15.700
So with that, let's
wrap up today's lecture.

01:17:15.700 --> 01:17:17.770
Now we prove these
hierarchy theorems.

01:17:17.770 --> 01:17:21.260
And why don't we just--

01:17:21.260 --> 01:17:25.630
I'm going to shut us down here.

01:17:25.630 --> 01:17:29.020
But before-- well,
I mean, we're over,

01:17:29.020 --> 01:17:30.988
so you can feel free to go.

01:17:30.988 --> 01:17:33.280
But I'll stick around in case
anybody has any questions

01:17:33.280 --> 01:17:34.900
for a few minutes anyway.

01:17:34.900 --> 01:17:38.460
And then we'll call it a day.

01:17:38.460 --> 01:17:41.490
Since we just showed space N
is a proper subset of space N

01:17:41.490 --> 01:17:44.610
to the K for any K,
why can't we also say

01:17:44.610 --> 01:17:46.470
space N is a proper
subset of P space?

01:17:46.470 --> 01:17:49.990
Yes, space N is a proper
subset of P space.

01:17:49.990 --> 01:17:50.490
Yeah.

01:17:50.490 --> 01:17:52.980
So somebody just
asked, we just showed

01:17:52.980 --> 01:17:58.350
that space N is a proper subset
of space N to the K. Does

01:17:58.350 --> 01:18:01.260
that also say that space N is
a proper subset of P space?

01:18:01.260 --> 01:18:02.010
Definitely.

01:18:06.400 --> 01:18:10.450
Space N to the K is a proper
subset of space N to the K

01:18:10.450 --> 01:18:13.780
plus 1, which is a
subset of P space.

01:18:13.780 --> 01:18:17.620
So any fixed polynomial is
going to be a subset of P space,

01:18:17.620 --> 01:18:20.020
because P space includes
all the polynomials.

01:18:20.020 --> 01:18:23.350
Which of the two
unsolved problems--

01:18:23.350 --> 01:18:28.590
whoops-- do I think is more
like likely to be true?

01:18:28.590 --> 01:18:32.950
Well, I think most--

01:18:32.950 --> 01:18:35.440
I mean, I would bet that
both of these are not equal.

01:18:35.440 --> 01:18:37.240
So both of these have answer no.

01:18:40.060 --> 01:18:44.950
It would be weird, you know,
I mean, you think L equals P?

01:18:44.950 --> 01:18:46.590
That anything can do
in polynomial time

01:18:46.590 --> 01:18:47.590
you can do in log space?

01:18:47.590 --> 01:18:49.810
Log space is incredibly weak.

01:18:49.810 --> 01:18:53.200
And P space is
incredibly strong.

01:18:53.200 --> 01:18:56.130
I would be shocked if
either of these were equal.

01:18:56.130 --> 01:18:58.520
So we just-- the
problem is that we

01:18:58.520 --> 01:19:05.870
don't have a method for
proving problems are actually,

01:19:05.870 --> 01:19:08.120
have high complexity
of any sort.

01:19:08.120 --> 01:19:10.220
We don't know how to
show things outside of L.

01:19:10.220 --> 01:19:14.000
Don't know how to show
things outside of P. Except

01:19:14.000 --> 01:19:15.500
by using the hierarchy theorem.

01:19:15.500 --> 01:19:17.750
Diagonalization
is the only method

01:19:17.750 --> 01:19:20.720
that we have for showing
things are outside of classes.

01:19:20.720 --> 01:19:22.830
And there's reason
to believe, as well.

01:19:22.830 --> 01:19:25.700
This we'll get to, I think,
next lecture, in fact.

01:19:25.700 --> 01:19:29.360
There's kind of reasons to
believe that the hierarchy

01:19:29.360 --> 01:19:32.120
theorem type argument,
which is diagonalization

01:19:32.120 --> 01:19:36.780
is not going to answer
those kinds of questions.

01:19:36.780 --> 01:19:38.240
So we need a different method.

01:19:38.240 --> 01:19:40.430
And diagonalization
is all we got.

01:19:43.430 --> 01:19:44.553
Good question, though.

01:19:44.553 --> 01:19:46.220
If I didn't get to
answer your question,

01:19:46.220 --> 01:19:47.900
you have a question
for me, ask it again,

01:19:47.900 --> 01:19:48.900
because it's got buried.

01:19:51.410 --> 01:19:55.010
So it means we are very far
from disproving P versus NP,

01:19:55.010 --> 01:19:58.010
is that right?

01:19:58.010 --> 01:19:59.100
It could happen tomorrow.

01:20:01.860 --> 01:20:04.440
How can you tell?

01:20:04.440 --> 01:20:08.010
It doesn't-- it seems clear
that the present state

01:20:08.010 --> 01:20:13.920
of mathematics, as of right
now, is we don't have a clue how

01:20:13.920 --> 01:20:15.963
to answer those
kinds of questions.

01:20:15.963 --> 01:20:18.255
And it's not obvious that
we've even made any progress.

01:20:21.010 --> 01:20:24.240
But you know, that's
the nature of the game.

01:20:24.240 --> 01:20:26.100
That's the nature of the beast.

01:20:26.100 --> 01:20:29.040
Somebody gets a good idea, and
all of a sudden lots of things

01:20:29.040 --> 01:20:30.060
can change.

01:20:30.060 --> 01:20:31.800
And that can happen
at any point.

01:20:31.800 --> 01:20:33.960
Maybe one of you guys.

01:20:33.960 --> 01:20:37.170
When would these results first--

01:20:37.170 --> 01:20:38.010
the stuff.

01:20:38.010 --> 01:20:38.760
OK.

01:20:38.760 --> 01:20:40.770
The hierarchy theorem is old.

01:20:40.770 --> 01:20:45.450
That goes back to the very--
when time classes were first

01:20:45.450 --> 01:20:48.420
defined, I think it's
one of the first results

01:20:48.420 --> 01:20:50.670
to show the hierarchy.

01:20:50.670 --> 01:20:54.765
And that's late '60s.

01:20:58.520 --> 01:21:03.890
The NL equal coNL, I think I
mentioned, was like mid-1980s.

01:21:03.890 --> 01:21:05.800
Much later.

01:21:05.800 --> 01:21:07.780
I mean, from your
points of view,

01:21:07.780 --> 01:21:14.290
it was back in the
cave age either way.

01:21:14.290 --> 01:21:17.080
But yeah, but the
hierarchy theorem,

01:21:17.080 --> 01:21:21.520
that actually predates
my coming into the field.

01:21:21.520 --> 01:21:24.280
But the NL equal coNL,
that was something

01:21:24.280 --> 01:21:28.210
that I personally experienced
how surprised people were.

01:21:31.220 --> 01:21:35.240
I think I'm going to send
you off, all off on your way.

01:21:35.240 --> 01:21:36.590
But good having you here.

01:21:36.590 --> 01:21:38.840
And have a good
weekend, everybody.

01:21:38.840 --> 01:21:43.420
And I will see you on Tuesday.

01:21:43.420 --> 01:21:44.790
Bye-bye.