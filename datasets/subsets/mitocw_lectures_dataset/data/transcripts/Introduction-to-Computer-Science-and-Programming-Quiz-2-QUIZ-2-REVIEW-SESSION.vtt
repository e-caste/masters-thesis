WEBVTT

00:00:00.530 --> 00:00:02.960
The following content is
provided under a Creative

00:00:02.960 --> 00:00:04.370
Commons license.

00:00:04.370 --> 00:00:07.410
Your support will help MIT
OpenCourseWare continue to

00:00:07.410 --> 00:00:11.060
offer high quality educational
resources for free.

00:00:11.060 --> 00:00:13.960
To make a donation or view
additional materials from

00:00:13.960 --> 00:00:19.790
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:19.790 --> 00:00:21.040
ocw.mit.edu.

00:00:24.420 --> 00:00:26.860
PROFESSOR: So we'll start off
by going over the Quiz Two

00:00:26.860 --> 00:00:28.960
practice questions.

00:00:28.960 --> 00:00:29.990
So, (1.1).

00:00:29.990 --> 00:00:32.390
In Python a subclass could
override methods of its

00:00:32.390 --> 00:00:33.250
superclass.

00:00:33.250 --> 00:00:34.900
What say you all?

00:00:34.900 --> 00:00:36.030
True?

00:00:36.030 --> 00:00:37.080
All right.

00:00:37.080 --> 00:00:39.670
There are some repeat people
from last night, so they know

00:00:39.670 --> 00:00:41.420
these already.

00:00:41.420 --> 00:00:43.840
Standard deviation, coefficient
of variation are

00:00:43.840 --> 00:00:45.230
different names for
the same thing.

00:00:45.230 --> 00:00:46.486
True or false?

00:00:46.486 --> 00:00:47.460
AUDIENCE: False.

00:00:47.460 --> 00:00:48.930
PROFESSOR: False.

00:00:48.930 --> 00:00:52.430
All right. (1.3.)

00:00:52.430 --> 00:00:53.162
AUDIENCE: Can you go over
what the coefficient

00:00:53.162 --> 00:00:55.090
of variation is?

00:00:55.090 --> 00:00:58.600
PROFESSOR: So, coefficient
of variation.

00:00:58.600 --> 00:00:59.850
It is--

00:01:04.430 --> 00:01:05.680
I have to write big
for the camera.

00:01:12.890 --> 00:01:15.620
Is that right?

00:01:15.620 --> 00:01:16.870
People who haven't
asked a question.

00:01:19.820 --> 00:01:22.690
It's the other way
around, right?

00:01:22.690 --> 00:01:28.150
Coefficient of variation is the
standard deviation divided

00:01:28.150 --> 00:01:30.830
by the mean.

00:01:30.830 --> 00:01:33.200
What does this tell you?

00:01:33.200 --> 00:01:36.140
Like, what sort of information
does the coefficient of

00:01:36.140 --> 00:01:37.390
variation tell you?

00:01:40.100 --> 00:01:41.350
Anyone?

00:01:42.760 --> 00:01:47.400
So, it's another way of telling
if your distribution

00:01:47.400 --> 00:01:49.590
is very widely spread.

00:01:49.590 --> 00:01:54.830
So, what it's getting at is--

00:01:54.830 --> 00:01:56.670
it's trying to help you
compare your standard

00:01:56.670 --> 00:01:57.640
deviation against your mean.

00:01:57.640 --> 00:02:04.780
Because, let's say that I have a
distribution and its mean is

00:02:04.780 --> 00:02:06.093
all the way out at 1.

00:02:09.770 --> 00:02:13.670
Let's pick a very
large number.

00:02:13.670 --> 00:02:16.340
So it's got a really big
mean, but say its

00:02:16.340 --> 00:02:19.980
standard deviation is--

00:02:19.980 --> 00:02:20.660
I don't know--

00:02:20.660 --> 00:02:21.510
100.

00:02:21.510 --> 00:02:23.592
Would you say that that's
widely spread out?

00:02:23.592 --> 00:02:25.080
It's pretty tight.

00:02:25.080 --> 00:02:26.430
If you're taking--

00:02:26.430 --> 00:02:31.110
if this were like, I don't know,
an observatory taking

00:02:31.110 --> 00:02:33.680
measurements of deep space and
you've got a fluctuation of

00:02:33.680 --> 00:02:35.530
100 for each standard deviation,
you'd probably say

00:02:35.530 --> 00:02:36.730
that was pretty good.

00:02:36.730 --> 00:02:38.450
And you wouldn't be too
concerned about it, because

00:02:38.450 --> 00:02:41.700
you've got a planet out there
that's billions of light years

00:02:41.700 --> 00:02:44.080
away or something.

00:02:44.080 --> 00:02:47.490
So on the other hand, let's
say that I have another

00:02:47.490 --> 00:02:52.800
measurement, and its mean is
somewhere around, say, 50.

00:02:52.800 --> 00:02:56.850
And its standard deviation
is 100.

00:02:56.850 --> 00:02:58.100
So it's a lot fatter.

00:03:00.780 --> 00:03:04.650
You would say that this has a
much wider spread, right?

00:03:04.650 --> 00:03:06.470
So it's a way of relating
the standard

00:03:06.470 --> 00:03:07.850
deviation to the mean.

00:03:07.850 --> 00:03:13.480
And, rule of thumb is if this
is less than or equal to 1,

00:03:13.480 --> 00:03:16.740
we're going to say that it's
not too widespread, there's

00:03:16.740 --> 00:03:19.220
not a lot of variation.

00:03:19.220 --> 00:03:22.900
That's a standard that
Professor Guttag has.

00:03:22.900 --> 00:03:25.170
Depending on your purposes
maybe that's too large or

00:03:25.170 --> 00:03:28.840
whatever, so but that's what
coefficient of variation is.

00:03:28.840 --> 00:03:31.247
Everyone clear on it?

00:03:31.247 --> 00:03:33.243
AUDIENCE: What's the difference
between variance

00:03:33.243 --> 00:03:36.740
and standard deviation?

00:03:36.740 --> 00:03:37.370
PROFESSOR: The difference
between variance

00:03:37.370 --> 00:03:39.210
and standard deviation?

00:03:39.210 --> 00:03:40.955
Standard deviation is the
square root of variance.

00:03:45.350 --> 00:03:47.710
All right.

00:03:47.710 --> 00:03:51.220
Unit testing is useful
for debugging.

00:03:51.220 --> 00:03:52.982
What does the audience say?

00:03:52.982 --> 00:03:53.464
AUDIENCE: True.

00:03:53.464 --> 00:03:54.714
AUDIENCE: True.

00:03:57.810 --> 00:03:58.160
PROFESSOR: OK.

00:03:58.160 --> 00:04:00.610
You know what unit testing
is, can you define it?

00:04:00.610 --> 00:04:04.315
AUDIENCE: Well, unit testing is
when you use other code to

00:04:04.315 --> 00:04:05.830
test your code.

00:04:05.830 --> 00:04:06.800
PROFESSOR: Right.

00:04:06.800 --> 00:04:11.030
So say you've broken your code
up into nice little functions

00:04:11.030 --> 00:04:12.590
like a good programmer.

00:04:12.590 --> 00:04:14.700
And you want to make sure that
those functions are giving you

00:04:14.700 --> 00:04:16.329
the right values.

00:04:16.329 --> 00:04:18.070
What you're doing with unit
testing is, you're writing a

00:04:18.070 --> 00:04:19.220
bunch of other code.

00:04:19.220 --> 00:04:21.269
Or a little bit of code.

00:04:21.269 --> 00:04:23.300
Sometimes a lot, it depends on
how thorough you want to be in

00:04:23.300 --> 00:04:24.620
your testing.

00:04:24.620 --> 00:04:29.970
And what you have is known
input and known output.

00:04:29.970 --> 00:04:31.760
And you're going to feed your
input to the functions you're

00:04:31.760 --> 00:04:33.500
testing, and you're going to
make sure that they give you

00:04:33.500 --> 00:04:35.650
the output that you're
expecting.

00:04:35.650 --> 00:04:37.600
And if they don't give you the
output that you're expecting,

00:04:37.600 --> 00:04:40.110
that indicates that there's
probably a bug.

00:04:40.110 --> 00:04:43.490
Which also kind of supports the
idea that unit testing is

00:04:43.490 --> 00:04:45.250
good for debugging.

00:04:45.250 --> 00:04:49.360
And if you are very
conscientious about your code

00:04:49.360 --> 00:04:52.180
and doing unit testing, you're
going to run your unit tests

00:04:52.180 --> 00:04:55.850
every time you either run your
code or make a change.

00:04:55.850 --> 00:04:58.860
Because you might have
inadvertently introduced a bug

00:04:58.860 --> 00:05:00.590
into the code that
you're modifying.

00:05:00.590 --> 00:05:04.780
So it's a way of verifying, it's
a way of detecting bugs,

00:05:04.780 --> 00:05:07.130
and also verifying that any
changes you make in the

00:05:07.130 --> 00:05:11.820
process of writing more
functions for your program or

00:05:11.820 --> 00:05:14.260
modifying functionality in your
program don't introduce

00:05:14.260 --> 00:05:15.510
other bugs.

00:05:18.430 --> 00:05:22.580
So in Python, functions cannot
be used as actual parameters.

00:05:25.320 --> 00:05:25.980
False.

00:05:25.980 --> 00:05:27.230
Why?

00:05:29.878 --> 00:05:31.380
AUDIENCE: [INAUDIBLE]

00:05:31.380 --> 00:05:35.884
PROFESSOR: Well, you could just
rephrase the question.

00:05:35.884 --> 00:05:38.250
But a better answer
is that functions

00:05:38.250 --> 00:05:39.680
are first class citizens.

00:05:39.680 --> 00:05:42.660
So they are objects in and of
themselves, and so you can

00:05:42.660 --> 00:05:44.870
pass them around to a function
and functions

00:05:44.870 --> 00:05:46.430
can make use of them.

00:05:46.430 --> 00:05:53.370
So we might see an example of
that later on if you want.

00:05:53.370 --> 00:05:54.180
All right.

00:05:54.180 --> 00:05:54.940
1.5.

00:05:54.940 --> 00:05:57.990
Increasing the size of a hash
table typically increases the

00:05:57.990 --> 00:05:59.960
amount of time needed to
locate a variable or

00:05:59.960 --> 00:06:02.810
value in the table.

00:06:02.810 --> 00:06:04.356
False.

00:06:04.356 --> 00:06:05.844
Why?

00:06:05.844 --> 00:06:07.332
AUDIENCE: It is Constant type.

00:06:07.332 --> 00:06:07.828
PROFESSOR: Right.

00:06:07.828 --> 00:06:09.316
The hashing function is
generally constant.

00:06:16.230 --> 00:06:17.480
OK.

00:06:21.740 --> 00:06:25.960
So, what does this code print?

00:06:25.960 --> 00:06:27.370
AUDIENCE: [INAUDIBLE]

00:06:27.370 --> 00:06:29.764
PROFESSOR: Six?

00:06:29.764 --> 00:06:30.760
AUDIENCE: 11.

00:06:30.760 --> 00:06:32.010
PROFESSOR: It's 11.

00:06:34.158 --> 00:06:35.010
AUDIENCE: [INAUDIBLE]

00:06:35.010 --> 00:06:39.360
PROFESSOR: So what is the
string x actually?

00:06:42.386 --> 00:06:43.770
AUDIENCE: Binary?

00:06:43.770 --> 00:06:45.450
PROFESSOR: It's the binary
representation of an integer.

00:06:45.450 --> 00:06:47.830
And all this code is
doing is, it's just

00:06:47.830 --> 00:06:50.550
converting it to a decimal.

00:06:50.550 --> 00:06:53.880
And because I came prepared
tonight--

00:06:56.710 --> 00:06:58.992
sorta kind of--

00:06:58.992 --> 00:07:02.620
I have the code here.

00:07:02.620 --> 00:07:05.240
And we can verify it.

00:07:05.240 --> 00:07:08.720
Any burning questions
on that problem?

00:07:08.720 --> 00:07:09.970
Moving on.

00:07:18.710 --> 00:07:21.650
What is the expected
value of g1?

00:07:25.565 --> 00:07:26.815
Anyone?

00:07:37.445 --> 00:07:39.200
Well, look at what
the code's doing.

00:07:43.470 --> 00:07:44.720
Did someone--

00:07:46.740 --> 00:07:48.480
AUDIENCE: What's "gauze,"
that function?

00:07:48.480 --> 00:07:49.670
We haven't used that one.

00:07:49.670 --> 00:07:50.380
PROFESSOR: Gauss is--

00:07:50.380 --> 00:07:51.630
AUDIENCE: Oh, Gauss.

00:07:51.630 --> 00:07:55.170
PROFESSOR: --a method on the
random object that draws a

00:07:55.170 --> 00:07:58.180
random value from a Gaussian
distribution

00:07:58.180 --> 00:08:00.120
that has a mean at--

00:08:00.120 --> 00:08:01.460
well, in this case, mean--

00:08:01.460 --> 00:08:04.350
and a standard deviation
of s-t-d-dev,

00:08:04.350 --> 00:08:06.100
whatever you put in there.

00:08:06.100 --> 00:08:10.840
So maybe for this example, if
I wanted to draw a random

00:08:10.840 --> 00:08:13.510
value from this distribution,
which I said had a mean of 50

00:08:13.510 --> 00:08:16.850
and a standard deviation
of 100, I would say

00:08:16.850 --> 00:08:25.160
random.Gauss 50, 100.

00:08:25.160 --> 00:08:30.480
So, in answering the question
(3.1), what do people think?

00:08:30.480 --> 00:08:32.360
What about (3.2)?

00:08:32.360 --> 00:08:34.140
100,000.

00:08:34.140 --> 00:08:35.970
So they're both the same.

00:08:35.970 --> 00:08:40.030
But they both have a different
standard deviation.

00:08:40.030 --> 00:08:44.650
So what this is getting
at is, it's getting

00:08:44.650 --> 00:08:46.965
you to look at this.

00:08:53.030 --> 00:08:55.830
So this code is straight
from the question.

00:08:55.830 --> 00:09:02.180
And all I'm going to do is, I'm
going to plot a histogram

00:09:02.180 --> 00:09:04.140
of what this function
produces.

00:09:04.140 --> 00:09:08.950
And also I'm going to run it a
number of times and verify

00:09:08.950 --> 00:09:11.500
that I am getting 100,000
in general.

00:09:19.720 --> 00:09:21.030
Python.

00:09:21.030 --> 00:09:22.850
There we go.

00:09:22.850 --> 00:09:25.350
So it's not exactly 100,000,
but it's close enough.

00:09:25.350 --> 00:09:29.650
I mean, we're not going
to be too upset.

00:09:29.650 --> 00:09:35.880
So this picture here shows the
actual values that were drawn

00:09:35.880 --> 00:09:40.720
when I repeated the experiment
a number of times.

00:09:40.720 --> 00:09:43.680
So I don't know if you can see
on the screen but there's this

00:09:43.680 --> 00:09:48.390
big, really thin, vertical
line here.

00:09:48.390 --> 00:09:50.070
Those are the results from
the Gaussian with

00:09:50.070 --> 00:09:51.960
a 0 standard deviation.

00:09:51.960 --> 00:09:55.160
So everything was
100,000 exactly.

00:09:55.160 --> 00:09:57.920
And then these red blocks
here, this is with the

00:09:57.920 --> 00:09:59.170
standard deviation of 20.

00:10:04.830 --> 00:10:06.592
Any questions on this?

00:10:06.592 --> 00:10:07.584
Yeah?

00:10:07.584 --> 00:10:10.064
AUDIENCE: What's the difference
between a normal

00:10:10.064 --> 00:10:12.048
distribution and a Gaussian
distribution?

00:10:12.048 --> 00:10:13.040
PROFESSOR: The name.

00:10:13.040 --> 00:10:15.354
The question was, what's the
difference between a normal

00:10:15.354 --> 00:10:16.760
distribution and a Gaussian
distribution.

00:10:16.760 --> 00:10:21.472
And it's just, it's
a different name.

00:10:21.472 --> 00:10:22.722
AUDIENCE: [INAUDIBLE]

00:10:25.470 --> 00:10:26.980
PROFESSOR: How I
came across it?

00:10:26.980 --> 00:10:27.475
AUDIENCE: Yeah.

00:10:27.475 --> 00:10:29.455
How are we supposed to see
that in this problem,

00:10:29.455 --> 00:10:31.930
[UNINTELLIGIBLE]?

00:10:31.930 --> 00:10:38.950
PROFESSOR: Well, if you look
at the plots, which I

00:10:38.950 --> 00:10:40.910
apparently killed--

00:10:40.910 --> 00:10:42.855
so let me pull them up again--

00:10:54.810 --> 00:10:55.700
All right.

00:10:55.700 --> 00:11:03.970
So the thing that you want
to know about Gaussian

00:11:03.970 --> 00:11:09.820
distributions is that, at the
mean, is the value that's the

00:11:09.820 --> 00:11:11.600
most probable.

00:11:11.600 --> 00:11:14.150
So its peak is at the mean.

00:11:14.150 --> 00:11:18.750
And so if you're taking a
1000 numbers from this

00:11:18.750 --> 00:11:23.900
distribution, then if you know
which number you're expecting

00:11:23.900 --> 00:11:27.720
to see with the highest
probability--

00:11:27.720 --> 00:11:30.481
I'm not sure if this sentence
is grammatical any more--

00:11:30.481 --> 00:11:30.962
AUDIENCE: Yeah.

00:11:30.962 --> 00:11:34.329
So really standard deviation
doesn't really have anything

00:11:34.329 --> 00:11:34.810
to do with it.

00:11:34.810 --> 00:11:37.270
PROFESSOR: What it's going
to affect is, it's

00:11:37.270 --> 00:11:39.230
going to tell you that--

00:11:39.230 --> 00:11:43.360
like, if you have a standard
deviation of 10 versus 20,

00:11:43.360 --> 00:11:44.750
it's just going to tell
you what the spread

00:11:44.750 --> 00:11:45.510
of the curve is.

00:11:45.510 --> 00:11:46.980
But it's not going to change
the expected value.

00:11:46.980 --> 00:11:50.360
So, why don't I actually
demonstrate that?

00:11:50.360 --> 00:11:53.340
Because I'm a fan of visuals
and not necessarily good at

00:11:53.340 --> 00:11:55.210
English tonight.

00:12:04.100 --> 00:12:04.450
All right.

00:12:04.450 --> 00:12:08.000
So all I did in the code was,
I just changed the standard

00:12:08.000 --> 00:12:10.040
deviation of the first
distribution to

00:12:10.040 --> 00:12:12.460
be 10 versus 20.

00:12:12.460 --> 00:12:19.390
And what you can see from the
plots are that the value with

00:12:19.390 --> 00:12:26.010
the highest probability is still
centered at 100,000.

00:12:26.010 --> 00:12:29.540
But the first plot, as opposed
to the first time we ran this

00:12:29.540 --> 00:12:32.070
with a 0 standard deviation,
is a little

00:12:32.070 --> 00:12:33.950
bit more spread out.

00:12:33.950 --> 00:12:37.180
And the plot with 20, for the
standard deviation, is even

00:12:37.180 --> 00:12:38.380
more spread out, than it.

00:12:38.380 --> 00:12:41.610
But they both have the highest
probability at 100,000 or

00:12:41.610 --> 00:12:43.586
centered at 100,000.

00:12:43.586 --> 00:12:49.382
AUDIENCE: So it's like, if you
have a mean for g1 of 100, or

00:12:49.382 --> 00:12:53.246
g2 of 200, then you would
expect 200,000 for g2?

00:12:53.246 --> 00:12:54.220
PROFESSOR: Yeah.

00:12:54.220 --> 00:13:01.720
So if instead you had a mean
of, say, 200 for the second

00:13:01.720 --> 00:13:07.100
distribution, versus 100,
you'd expect them in two

00:13:07.100 --> 00:13:09.000
completely separate places.

00:13:09.000 --> 00:13:11.950
And you'd get an expected
value that's

00:13:11.950 --> 00:13:14.840
100,000 versus 200,000.

00:13:14.840 --> 00:13:20.770
So here close to 100,000, close
to 200,000 and then see

00:13:20.770 --> 00:13:22.020
what my distribution is.

00:13:26.430 --> 00:13:26.760
All right.

00:13:26.760 --> 00:13:28.010
We good on this?

00:13:31.850 --> 00:13:33.680
So moving on.

00:13:33.680 --> 00:13:35.840
Question (4).

00:13:35.840 --> 00:13:39.525
What is the probability of the
final value of num6 being 0?

00:13:42.704 --> 00:13:45.608
AUDIENCE: 9/10 to the 10.

00:13:45.608 --> 00:13:47.834
PROFESSOR: 9 over 10,
the whole thing to

00:13:47.834 --> 00:13:49.480
the 10th power, right?

00:13:49.480 --> 00:13:50.460
OK.

00:13:50.460 --> 00:13:55.155
So does anyone not see
why that's the case?

00:13:59.530 --> 00:14:02.310
So I'm going to explain
that anyway.

00:14:02.310 --> 00:14:07.760
So what this code is doing is,
for 10 times its drawing an

00:14:07.760 --> 00:14:09.830
integer from 0 to 9.

00:14:09.830 --> 00:14:11.000
A random integer.

00:14:11.000 --> 00:14:13.240
It's a uniform distribution.

00:14:13.240 --> 00:14:15.920
And it's counting the number
of times that the integer

00:14:15.920 --> 00:14:19.590
drawn is 6.

00:14:19.590 --> 00:14:21.550
And it's incrementing
a counter.

00:14:21.550 --> 00:14:26.950
So the question can be rephrased
as, what's the

00:14:26.950 --> 00:14:33.060
probability that no 6's were
drawn 10 times out of a pool

00:14:33.060 --> 00:14:35.940
of 10 integers?

00:14:35.940 --> 00:14:45.280
And the way you can figure it
out is on one pool where, say

00:14:45.280 --> 00:14:47.920
I had a 10 sided dice.

00:14:47.920 --> 00:14:50.510
On one roll, what's
the probability of

00:14:50.510 --> 00:14:51.390
not getting a 6?

00:14:51.390 --> 00:14:53.530
It's going to be 9
over 10, right?

00:14:53.530 --> 00:14:54.820
And if you do that 10 times.

00:14:54.820 --> 00:14:58.000
9 over 10 times 9 over 10 times
9 over 10, that gives

00:14:58.000 --> 00:15:01.785
you 9 over 10 to
the 10th power.

00:15:01.785 --> 00:15:10.320
And because this is a code
class, we have a

00:15:10.320 --> 00:15:11.210
demonstration.

00:15:11.210 --> 00:15:14.940
So here's the answer that
we hand-jammed or

00:15:14.940 --> 00:15:18.040
that we just discussed.

00:15:18.040 --> 00:15:22.840
And now here is a function
count of 6.

00:15:22.840 --> 00:15:27.690
And it's the code that you
see in problem (4).

00:15:27.690 --> 00:15:28.740
And all I'm going to
do is, I'm going to

00:15:28.740 --> 00:15:29.970
run a number of trials.

00:15:29.970 --> 00:15:32.290
And I'm going to count the
number of trials that come up

00:15:32.290 --> 00:15:35.490
0, and increment a
count numzero's.

00:15:35.490 --> 00:15:38.400
And then I'm going to say,
this is what I think the

00:15:38.400 --> 00:15:40.150
probability of getting a 0 is.

00:15:40.150 --> 00:15:42.760
And then we'll compare
the two numbers.

00:15:42.760 --> 00:15:45.040
OK so that's the probability
that we count

00:15:45.040 --> 00:15:47.100
9/10 to the 10th power.

00:15:47.100 --> 00:15:51.410
And then this is the estimated
probability that we got from

00:15:51.410 --> 00:15:54.990
running this function
100,000 times.

00:15:54.990 --> 00:15:59.462
So we good on this problem?

00:15:59.462 --> 00:16:00.845
AUDIENCE: Instead of solving
it the way that you guys

00:16:00.845 --> 00:16:03.446
solved it, can you solve
it by saying that

00:16:03.446 --> 00:16:05.604
the problem's also--

00:16:05.604 --> 00:16:08.426
that it's 1 minus the
probability that 6

00:16:08.426 --> 00:16:09.676
will always be picked?

00:16:11.940 --> 00:16:15.630
PROFESSOR: That you will
see at least one 6?

00:16:15.630 --> 00:16:20.280
1 minus the probability that
you'll see at least one 6?

00:16:24.160 --> 00:16:27.660
AUDIENCE: No, never mind.

00:16:27.660 --> 00:16:29.820
PROFESSOR: You can solve
it in different ways.

00:16:29.820 --> 00:16:32.520
It's just this way is--

00:16:32.520 --> 00:16:35.090
I think, probably, this way of
thinking about it is probably

00:16:35.090 --> 00:16:37.453
more intuitive.

00:16:37.453 --> 00:16:39.908
AUDIENCE: When would you want to
solve this kind of problem

00:16:39.908 --> 00:16:44.818
with [INAUDIBLE], instead
of when it says it's not

00:16:44.818 --> 00:16:47.764
something, to use 1 minus
the probability?

00:16:47.764 --> 00:16:49.237
That it is [UNINTELLIGIBLE]

00:16:52.690 --> 00:16:54.640
PROFESSOR: Well, my answer
would be when it

00:16:54.640 --> 00:16:56.030
makes sense to you.

00:17:00.460 --> 00:17:03.170
Some problems are easier viewed
in the negative light,

00:17:03.170 --> 00:17:06.349
which is what you're saying
as 1 minus whatever.

00:17:06.349 --> 00:17:07.980
And some problems are
better solved in a

00:17:07.980 --> 00:17:08.847
straightforward fashion.

00:17:08.847 --> 00:17:14.105
So it's whatever tool
gets the job done.

00:17:14.105 --> 00:17:18.420
I don't have a general rule
of thumb for you.

00:17:18.420 --> 00:17:23.301
Maybe there's a course
18 person who does.

00:17:23.301 --> 00:17:30.700
AUDIENCE: So this problem, would
we possibly be asked,

00:17:30.700 --> 00:17:33.910
what is the probability that
it'll end up being 1?

00:17:33.910 --> 00:17:40.355
Or does it necessarily matter
which of those 10 came up 6?

00:17:40.355 --> 00:17:42.775
And how would you show that, if
we were going to be asked

00:17:42.775 --> 00:17:44.170
that question?

00:17:44.170 --> 00:17:44.910
PROFESSOR: Well.

00:17:44.910 --> 00:17:46.890
One, I haven't seen the quiz.

00:17:46.890 --> 00:17:49.510
So I can't give you
a definite.

00:17:49.510 --> 00:17:52.630
But you could be asked,
instead of using

00:17:52.630 --> 00:17:55.560
6, maybe say, 1.

00:17:55.560 --> 00:17:57.488
Is that going to really
change anything?

00:17:57.488 --> 00:17:57.976
AUDIENCE: No.

00:17:57.976 --> 00:18:03.344
I guess I meant that one
of those 10 outcomes

00:18:03.344 --> 00:18:05.232
ends up being a 6.

00:18:05.232 --> 00:18:07.080
PROFESSOR: Right.

00:18:07.080 --> 00:18:09.910
AUDIENCE: I can do it if, they
say the fifth trial is a 6.

00:18:12.720 --> 00:18:17.000
But just 1 of those 10 trials
being a 6, I don't know how to

00:18:17.000 --> 00:18:17.860
write properly?

00:18:17.860 --> 00:18:21.000
PROFESSOR: So what's the
probability that you get 1 of

00:18:21.000 --> 00:18:23.004
the trials as exactly 6?

00:18:23.004 --> 00:18:25.910
Or exactly 1 of the trials
comes up as 6?

00:18:25.910 --> 00:18:27.845
AUDIENCE: Yeah.

00:18:27.845 --> 00:18:33.600
PROFESSOR: Well, one way of
thinking of it is-- so we

00:18:33.600 --> 00:18:34.820
calculated 9/10.

00:18:34.820 --> 00:18:38.540
That's the probability that
6 doesn't come up, right?

00:18:38.540 --> 00:18:41.330
So what's the probability
that 6 will come up?

00:18:41.330 --> 00:18:42.340
1/10.

00:18:42.340 --> 00:18:46.280
So instead of doing 9/10 to the
10th power, it would be

00:18:46.280 --> 00:18:50.150
9/10 to the 9th power
times 1/10, right?

00:18:53.650 --> 00:18:54.650
AUDIENCE: OK, that'll
account for.

00:18:54.650 --> 00:18:58.330
Thanks

00:18:58.330 --> 00:19:01.550
PROFESSOR: And because I'm never
very comfortable with

00:19:01.550 --> 00:19:07.196
this stuff, why don't
we do a simulation?

00:19:17.680 --> 00:19:19.420
So this is what we're saying.

00:19:19.420 --> 00:19:21.300
Exactly one 6 comes up.

00:19:26.610 --> 00:19:30.220
And I'm going to
set this to 1.

00:19:30.220 --> 00:19:32.920
AUDIENCE: Isn't that saying that
it's less likely that one

00:19:32.920 --> 00:19:37.684
6 comes up than zero
6s come up?

00:19:37.684 --> 00:19:40.325
Is it?

00:19:40.325 --> 00:19:41.255
That's true?

00:19:41.255 --> 00:19:42.190
PROFESSOR: Yeah.

00:19:42.190 --> 00:19:44.280
Because you're looking
for exactly--

00:19:44.280 --> 00:19:49.100
you're looking for a sequence
of 10 events where exactly 1

00:19:49.100 --> 00:19:50.290
of those of events is a 6.

00:19:50.290 --> 00:19:54.626
Which seems more unlikely than,
say, getting everything

00:19:54.626 --> 00:19:58.450
that's not a 6.

00:19:58.450 --> 00:20:02.794
So I want to verify this.

00:20:02.794 --> 00:20:07.190
AUDIENCE: Why is it 9/10
to the 9th [INAUDIBLE]

00:20:07.190 --> 00:20:10.600
PROFESSOR: Because we're
asking, if I roll this

00:20:10.600 --> 00:20:15.740
10-sided dice 10 times, what's
the probability that exactly

00:20:15.740 --> 00:20:19.380
one of those rolls is going
to come up with 6?

00:20:19.380 --> 00:20:22.330
And so what we're asking is,
what is the probability that I

00:20:22.330 --> 00:20:26.490
roll the dice 9 times and it
doesn't come up with 6?

00:20:26.490 --> 00:20:30.210
And then what's the probability
that on the

00:20:30.210 --> 00:20:34.060
remaining roll, that
it comes up as 6?

00:20:34.060 --> 00:20:36.610
Which is 1/10.

00:20:36.610 --> 00:20:39.513
So let's see if I'm
in the ballpark.

00:20:47.710 --> 00:20:48.833
Did I make a mistake?

00:20:48.833 --> 00:20:50.083
AUDIENCE: [INAUDIBLE]

00:20:53.563 --> 00:20:56.954
where if there's ten different
ways-- so it would be like--

00:20:56.954 --> 00:20:58.443
PROFESSOR: Oh, yeah.

00:20:58.443 --> 00:21:00.335
So yeah, you're right.

00:21:00.335 --> 00:21:02.227
That's why I don't
like that stuff.

00:21:05.070 --> 00:21:08.000
So yeah, it's a little bit more
complicated than that.

00:21:08.000 --> 00:21:10.449
AUDIENCE: You only counted
one case of getting--

00:21:10.449 --> 00:21:11.870
PROFESSOR: That's right.

00:21:11.870 --> 00:21:14.910
So in this, I'm only
counting one case.

00:21:14.910 --> 00:21:18.100
There's multiple ways that
exactly one dice

00:21:18.100 --> 00:21:19.946
could come up 6.

00:21:19.946 --> 00:21:21.365
So the answer is more
complicated.

00:21:21.365 --> 00:21:22.961
AUDIENCE: So would you
just multiply by 10?

00:21:22.961 --> 00:21:24.211
Because there's 10
different places?

00:21:27.520 --> 00:21:27.850
PROFESSOR: Yeah.

00:21:27.850 --> 00:21:29.700
So actually, that's
what we got, so--

00:21:34.050 --> 00:21:35.300
we'll just do this.

00:21:40.330 --> 00:21:42.335
Well, of course that's
going to come up.

00:21:42.335 --> 00:21:45.286
But the simulation gives us the
same answer as what we've

00:21:45.286 --> 00:21:47.340
just come up with discussing.

00:21:47.340 --> 00:21:50.184
OK, problem solved.

00:21:50.184 --> 00:21:52.658
Did that work?

00:21:52.658 --> 00:21:53.908
AUDIENCE: Yeah.

00:21:56.080 --> 00:21:59.175
PROFESSOR: Probability
can be tricky.

00:22:03.908 --> 00:22:05.630
AUDIENCE: So essentially,
you could just take the

00:22:05.630 --> 00:22:08.336
probability that 9 of
the rolls aren't 6,

00:22:08.336 --> 00:22:09.320
and leave it at that?

00:22:09.320 --> 00:22:13.256
Because you multiply it
by 10 [INAUDIBLE].

00:22:13.256 --> 00:22:13.748
PROFESSOR: Yeah.

00:22:13.748 --> 00:22:18.176
You can also do it that way.

00:22:18.176 --> 00:22:20.190
So again, there's
multiple ways to

00:22:20.190 --> 00:22:21.330
think about the problem.

00:22:21.330 --> 00:22:23.770
So she was saying, instead
of multiplying by

00:22:23.770 --> 00:22:26.050
10, we just say that--

00:22:26.050 --> 00:22:30.300
we take the probability that we
have 9 rolls that aren't 6.

00:22:30.300 --> 00:22:33.540
And that works too.

00:22:33.540 --> 00:22:35.320
That's what she just
pointed out.

00:22:35.320 --> 00:22:39.260
So these parts cancel
each other out.

00:22:42.600 --> 00:22:43.430
It's basically--

00:22:43.430 --> 00:22:45.080
it is the same thing as this.

00:22:47.920 --> 00:22:49.170
Yay.

00:22:51.480 --> 00:22:51.900
All right.

00:22:51.900 --> 00:22:53.150
Are we good on this question?

00:22:59.280 --> 00:22:59.770
All right.

00:22:59.770 --> 00:23:00.670
Problem (5).

00:23:00.670 --> 00:23:03.410
It was matching plots.

00:23:03.410 --> 00:23:05.480
So you have three
functions here.

00:23:05.480 --> 00:23:10.340
You have a polynomial,
or two polynomials.

00:23:10.340 --> 00:23:13.460
One's a cubic, one's
a quintic.

00:23:13.460 --> 00:23:14.710
And one's an exponential.

00:23:17.840 --> 00:23:19.700
There are a couple ways that
you could go about

00:23:19.700 --> 00:23:21.030
solving this one.

00:23:21.030 --> 00:23:23.080
One is to plug values
in and kind of match

00:23:23.080 --> 00:23:24.730
them up with the plots.

00:23:24.730 --> 00:23:29.630
Another is to look at the
axis of the plots.

00:23:29.630 --> 00:23:34.380
So this exponential function
here, if we were to have it on

00:23:34.380 --> 00:23:37.790
two linear axes, the x-axis
and the y-axis for both

00:23:37.790 --> 00:23:41.780
linear, you'd see the expected
curve upward sharply.

00:23:41.780 --> 00:23:44.905
But if you notice, a couple
of the plots are

00:23:44.905 --> 00:23:47.010
in a semi-log y-axis.

00:23:47.010 --> 00:23:52.000
So if you put an exponential
with a linear x-axis and a

00:23:52.000 --> 00:23:53.910
logarithmic y-axis, what
would you expect the

00:23:53.910 --> 00:23:56.290
plot to look like?

00:23:56.290 --> 00:23:57.810
It would be a straight
line, right.

00:23:57.810 --> 00:24:03.050
So what that tells us is that if
we look at the bottom plot,

00:24:03.050 --> 00:24:05.170
we have something with
a straight line.

00:24:05.170 --> 00:24:09.490
So, bottom plot is the
third function.

00:24:09.490 --> 00:24:11.340
So, exponential.

00:24:11.340 --> 00:24:16.680
And then for the remaining two
functions, there are a couple

00:24:16.680 --> 00:24:18.940
methods that you would use,
or you could use.

00:24:18.940 --> 00:24:24.170
One is to plug values in and see
where the points wind up

00:24:24.170 --> 00:24:26.200
and compare them
with the plots.

00:24:26.200 --> 00:24:29.480
Another way to think about it is
that one of the plots is on

00:24:29.480 --> 00:24:34.990
a semi-log and another plot is
on just both linear axes.

00:24:34.990 --> 00:24:46.290
And if you plot a polynomial
that's not exponential on a

00:24:46.290 --> 00:24:48.760
logarithmic y-axis, what
would you expect the

00:24:48.760 --> 00:24:50.010
curve to look like?

00:24:52.710 --> 00:24:56.340
It should look somewhat similar
to a logarithm.

00:24:56.340 --> 00:25:04.720
So with that in mind,
you could then start

00:25:04.720 --> 00:25:06.870
plugging points in.

00:25:06.870 --> 00:25:09.400
And what you would come up
with is that the second

00:25:09.400 --> 00:25:12.860
function is this
top plot here.

00:25:12.860 --> 00:25:18.878
And the middle plot here
is the first function.

00:25:18.878 --> 00:25:22.170
Is there anyone who's
lost on that?

00:25:22.170 --> 00:25:23.860
Uh-oh.

00:25:23.860 --> 00:25:25.110
AUDIENCE: Wait, why?

00:25:30.242 --> 00:25:33.714
So you have two quadratic
functions, right?

00:25:33.714 --> 00:25:35.698
One and two are quadratic?

00:25:35.698 --> 00:25:36.690
PROFESSOR: They're
polynomials.

00:25:36.690 --> 00:25:38.178
They're not exponential.

00:25:38.178 --> 00:25:38.674
AUDIENCE: OK.

00:25:38.674 --> 00:25:40.162
And then the third one's
exponential.

00:25:40.162 --> 00:25:45.618
And the reason why the third
one's linear is because when

00:25:45.618 --> 00:25:50.000
you plot an exponential--

00:25:50.000 --> 00:25:52.160
PROFESSOR: If you plot an
exponential with a linear

00:25:52.160 --> 00:25:55.847
x-axis and a logarithmic
y-axis, it should be a

00:25:55.847 --> 00:25:56.346
straight line.

00:25:56.346 --> 00:25:56.845
Right?

00:25:56.845 --> 00:25:58.342
Or a straightish line.

00:25:58.342 --> 00:26:00.837
AUDIENCE: Why?

00:26:00.837 --> 00:26:04.829
PROFESSOR: It's the way
the math works out.

00:26:04.829 --> 00:26:06.079
AUDIENCE: [INAUDIBLE]

00:26:10.320 --> 00:26:13.100
PROFESSOR: Any other
questions?

00:26:13.100 --> 00:26:17.850
All right, we'll move
onto the next one.

00:26:17.850 --> 00:26:19.345
What does the following
code print?

00:26:25.702 --> 00:26:27.686
AUDIENCE: 16.

00:26:27.686 --> 00:26:33.660
And then square root
of [INAUDIBLE]

00:26:33.660 --> 00:26:36.534
PROFESSOR: Close.

00:26:36.534 --> 00:26:39.340
So I don't actually
have the answer.

00:26:39.340 --> 00:26:41.950
Well, not written down.

00:26:41.950 --> 00:26:44.572
But I have the code, so I'm just
going to run the code.

00:26:48.910 --> 00:26:50.160
So you're close.

00:26:52.630 --> 00:26:54.710
Shall we spend some time
stepping through this code,

00:26:54.710 --> 00:26:55.870
understanding it?

00:26:55.870 --> 00:26:57.160
All right.

00:26:57.160 --> 00:27:03.820
So, what question (6) does is,
it creates a class hierarchy.

00:27:03.820 --> 00:27:07.800
And at the top of it, it
has the shape class.

00:27:07.800 --> 00:27:13.130
Which has just two methods,
double underbar EQ and double

00:27:13.130 --> 00:27:16.260
underbar GE.

00:27:16.260 --> 00:27:19.370
That was just defined as
equals operator and the

00:27:19.370 --> 00:27:23.590
greater than or equal
operator for shapes.

00:27:23.590 --> 00:27:25.760
In terms of their area.

00:27:25.760 --> 00:27:30.437
So what this is saying is that
two shapes are equal if their

00:27:30.437 --> 00:27:38.870
areas are equal, and a shape S1
is going to be larger than

00:27:38.870 --> 00:27:42.510
another shape if its area is
larger than the other shape.

00:27:42.510 --> 00:27:44.460
So if I had--

00:27:48.400 --> 00:27:52.990
well let's go down and
we'll get to that.

00:27:52.990 --> 00:27:55.730
Square, subclass of shape.

00:27:55.730 --> 00:27:57.320
It is what it says it is.

00:27:57.320 --> 00:27:58.630
It's a square.

00:27:58.630 --> 00:28:02.470
And it has a side.

00:28:02.470 --> 00:28:04.810
And its area is what
you'd expect it to

00:28:04.810 --> 00:28:07.020
be, the side squared.

00:28:07.020 --> 00:28:10.590
And circle is just defined--

00:28:10.590 --> 00:28:15.620
it just has a radius, and its
area is what you would

00:28:15.620 --> 00:28:16.870
expect it to be.

00:28:19.120 --> 00:28:22.150
There is a function here, f.

00:28:22.150 --> 00:28:27.020
And it takes a parameter, l.

00:28:27.020 --> 00:28:28.470
And I --

00:28:28.470 --> 00:28:31.470
if you look at the code here and
you kind of walk through

00:28:31.470 --> 00:28:34.100
it -- l would have to
be either a list

00:28:34.100 --> 00:28:39.150
or a tuple of elements.

00:28:39.150 --> 00:28:41.280
Doesn't have to necessarily
be shapes.

00:28:41.280 --> 00:28:46.230
But this first line is just
going to return none if the

00:28:46.230 --> 00:28:47.760
list is empty.

00:28:47.760 --> 00:28:52.840
And then these next lines are
going to, one it's going to

00:28:52.840 --> 00:28:56.230
set the first element equal to
x, and then iterate through

00:28:56.230 --> 00:28:58.410
each element in l.

00:28:58.410 --> 00:29:01.880
And then if the element it's
looking at is larger than x

00:29:01.880 --> 00:29:04.590
it's going to set x
to the element.

00:29:04.590 --> 00:29:08.970
So what this function is doing
is finding the largest element

00:29:08.970 --> 00:29:10.220
in the list.

00:29:13.110 --> 00:29:14.360
Everyone follow that?

00:29:17.420 --> 00:29:22.680
So, this should be pretty
straightforward.

00:29:22.680 --> 00:29:24.930
As should this.

00:29:24.930 --> 00:29:28.190
This part my trip
some people up.

00:29:28.190 --> 00:29:32.950
So, this obviously creates
an empty list.

00:29:32.950 --> 00:29:38.630
What this does is, it creates
a dictionary of class names.

00:29:38.630 --> 00:29:43.460
And what it's saying is
that for a key of 0,

00:29:43.460 --> 00:29:44.860
the class is circle.

00:29:44.860 --> 00:29:48.650
And for a key of one the
class is square.

00:29:48.650 --> 00:29:49.900
Everyone see that?

00:29:53.330 --> 00:29:56.990
This loop here iterates
for 10 times.

00:29:56.990 --> 00:30:01.440
And it appends 10 elements.

00:30:01.440 --> 00:30:05.110
And then each of those elements
are defined by this

00:30:05.110 --> 00:30:06.360
shapes dictionary.

00:30:09.170 --> 00:30:15.560
On each iteration, it's going to
take the modulus of i, the

00:30:15.560 --> 00:30:18.360
index, or the number.

00:30:18.360 --> 00:30:23.580
And if it's a 0, it's going to
construct whatever class the

00:30:23.580 --> 00:30:25.140
dictionary of shapes returns.

00:30:25.140 --> 00:30:29.110
So if it's an even number,
it's going to be circle.

00:30:29.110 --> 00:30:31.570
And if it's an odd number
is going to be a square.

00:30:34.370 --> 00:30:37.076
Everyone follow that?

00:30:37.076 --> 00:30:40.700
Does no-one follow that?

00:30:40.700 --> 00:30:41.710
OK.

00:30:41.710 --> 00:30:43.855
Or does anyone not
follow that?

00:30:43.855 --> 00:30:45.530
Got my logic messed up.

00:30:45.530 --> 00:30:46.040
All right.

00:30:46.040 --> 00:30:48.180
So now what we have here
is a list of shapes.

00:30:50.770 --> 00:30:54.890
And then all this does is it's
going to print which shape.

00:30:54.890 --> 00:30:58.380
Is it going to be the fourth
or the fifth shape?

00:30:58.380 --> 00:30:59.260
Fifth, right?

00:30:59.260 --> 00:31:00.720
Because we've started
indexing it at 0.

00:31:05.530 --> 00:31:08.090
So this number is
obviously even.

00:31:08.090 --> 00:31:13.320
So this should be a circle
shape, or a circle class.

00:31:13.320 --> 00:31:14.690
And what should its radius be?

00:31:17.552 --> 00:31:18.506
AUDIENCE: [INAUDIBLE]

00:31:18.506 --> 00:31:19.940
PROFESSOR: Right.

00:31:19.940 --> 00:31:24.060
And then this line here is just
going call the function

00:31:24.060 --> 00:31:26.620
f, which is going to find
the larger shape.

00:31:26.620 --> 00:31:31.960
Which is determined
by its area.

00:31:31.960 --> 00:31:34.330
And in this particular instance,
it's going to be a

00:31:34.330 --> 00:31:35.580
circle with radius eight.

00:31:38.550 --> 00:31:41.640
Once you figure out what f does,
this is actually not

00:31:41.640 --> 00:31:43.600
such a hard problem.

00:31:43.600 --> 00:31:46.190
So the key to understanding this
one is figuring out what

00:31:46.190 --> 00:31:47.990
f is actually doing.

00:31:47.990 --> 00:31:52.410
And you'll probably see a
problem or two on the exam

00:31:52.410 --> 00:31:58.380
that's written like this, where
the function has been

00:31:58.380 --> 00:32:00.610
obfuscated.

00:32:00.610 --> 00:32:06.710
So it doesn't have nice
little variable names.

00:32:06.710 --> 00:32:09.910
If we were writing this
for real, it would be

00:32:09.910 --> 00:32:12.370
something like that.

00:32:12.370 --> 00:32:15.070
AUDIENCE: Wait, what was
the radius on L?

00:32:15.070 --> 00:32:16.080
It was--

00:32:16.080 --> 00:32:17.385
PROFESSOR: Radius on L?

00:32:17.385 --> 00:32:19.660
AUDIENCE: Or not radius.

00:32:19.660 --> 00:32:22.390
Like, L4 was circled.

00:32:22.390 --> 00:32:26.710
And was that all it was,
it was just a circle?

00:32:26.710 --> 00:32:28.090
PROFESSOR: With radius 4.

00:32:28.090 --> 00:32:29.220
AUDIENCE: With radius 4?

00:32:29.220 --> 00:32:33.060
OK, that's what I thought.

00:32:33.060 --> 00:32:35.392
PROFESSOR: All right.

00:32:35.392 --> 00:32:37.842
AUDIENCE: How many of those
special underbar functions

00:32:37.842 --> 00:32:39.810
have we seen?

00:32:39.810 --> 00:32:44.250
Have we seen anything besides
edit string and [INAUDIBLE]?

00:32:44.250 --> 00:32:45.520
PROFESSOR: So, how many
of the double underbar

00:32:45.520 --> 00:32:47.616
functions have you seen?

00:32:47.616 --> 00:32:49.390
That's a good question.

00:32:49.390 --> 00:32:51.780
You've seen a lot, right?

00:32:51.780 --> 00:32:58.340
The ones that I would be
familiar with definitely INIT

00:32:58.340 --> 00:33:04.980
definitely EQ, GE and
definitely STR.

00:33:04.980 --> 00:33:11.640
You might want to be familiar
with this, LE.

00:33:11.640 --> 00:33:13.050
So what is LE?

00:33:13.050 --> 00:33:15.620
What do you think that does?

00:33:15.620 --> 00:33:16.790
Less than or equal to.

00:33:16.790 --> 00:33:17.460
Less than.

00:33:17.460 --> 00:33:23.070
So it's this the opposite
of GE, right?

00:33:23.070 --> 00:33:29.205
I think there's also an
LT, so less than.

00:33:29.205 --> 00:33:30.455
And GT.

00:33:33.450 --> 00:33:36.170
It's fairly logical.

00:33:36.170 --> 00:33:46.330
And historically you don't need
to have these memorized.

00:33:46.330 --> 00:33:48.410
I've never seen a question where
you've actually had to

00:33:48.410 --> 00:33:54.280
produce code that uses double
underbar on the quiz.

00:33:54.280 --> 00:33:56.840
You just have to understand
what it's doing

00:33:56.840 --> 00:33:57.610
if you can see it.

00:33:57.610 --> 00:33:58.860
Like, in a code reading
exercise.

00:34:01.560 --> 00:34:07.260
And the conventions are fairly
straightforward to understand.

00:34:11.230 --> 00:34:12.480
Can I move on?

00:34:14.910 --> 00:34:16.395
AUDIENCE: Can you scroll
down a little bit?

00:34:16.395 --> 00:34:24.084
Where it says print L4,
or I guess print FL.

00:34:24.084 --> 00:34:29.030
Does it automatically just print
the string function?

00:34:29.030 --> 00:34:30.110
PROFESSOR: Yes.

00:34:30.110 --> 00:34:36.794
So you're asking why
I don't have this.

00:34:36.794 --> 00:34:38.080
AUDIENCE: Right.

00:34:38.080 --> 00:34:44.900
PROFESSOR: So in this flavor
of Python, and if you don't

00:34:44.900 --> 00:34:50.690
have an explicit conversion to
string, Python will look for

00:34:50.690 --> 00:34:54.570
the underbar STR function
if it exists.

00:34:54.570 --> 00:34:58.470
If it doesn't exist then you get
that weird object at blah,

00:34:58.470 --> 00:35:00.880
blah, blah.

00:35:00.880 --> 00:35:03.230
AUDIENCE: Right.

00:35:03.230 --> 00:35:04.900
PROFESSOR: Any other
questions?

00:35:04.900 --> 00:35:07.870
AUDIENCE: What list are
you reading up on top?

00:35:11.830 --> 00:35:14.305
PROFESSOR: Are you confused
because it's the same name?

00:35:14.305 --> 00:35:14.800
AUDIENCE: Maybe.

00:35:14.800 --> 00:35:16.285
I don't know.

00:35:16.285 --> 00:35:18.760
So the third thing
that [INAUDIBLE].

00:35:18.760 --> 00:35:22.225
I understand the second thing,
circle with radius 4.

00:35:22.225 --> 00:35:26.190
But how do you get that
circle of radius 8?

00:35:26.190 --> 00:35:30.925
PROFESSOR: Well, the way we
get that is, f of l--

00:35:30.925 --> 00:35:32.089
f is the function, right?

00:35:32.089 --> 00:35:33.420
AUDIENCE: Right, and it produces
the largest element

00:35:33.420 --> 00:35:34.917
of the list.

00:35:34.917 --> 00:35:39.410
And the list, L, contains
0 to 9?

00:35:39.410 --> 00:35:39.490
PROFESSOR: Yes.

00:35:39.490 --> 00:35:41.709
So we could actually print
out what L contains.

00:35:41.709 --> 00:35:43.188
AUDIENCE: Why isn't it square?

00:35:43.188 --> 00:35:45.653
Isn't 9 [INAUDIBLE]?

00:35:45.653 --> 00:35:47.625
PROFESSOR: Why don't we do it?

00:36:05.900 --> 00:36:06.200
All right.

00:36:06.200 --> 00:36:07.950
So all it's going to do is, it's
going to print out all

00:36:07.950 --> 00:36:11.860
the shapes in the list
and their areas.

00:36:11.860 --> 00:36:14.585
I've got stuff at the top.

00:36:24.140 --> 00:36:27.950
So this is the first shape.

00:36:27.950 --> 00:36:34.450
And then, as we move down the
list, we have square with side

00:36:34.450 --> 00:36:39.320
1, circle with radius 2, 3, et
cetera, et cetera, et cetera.

00:36:39.320 --> 00:36:45.480
And then, this is the area of
the circle with radius 8

00:36:45.480 --> 00:36:51.060
versus the area of a
square with side 9.

00:36:54.920 --> 00:37:00.270
So, and it depends on--

00:37:00.270 --> 00:37:03.710
the reason why it works this
way is that this is greater

00:37:03.710 --> 00:37:08.160
than or equal to operator is
defined in terms of the area

00:37:08.160 --> 00:37:09.410
method of the shapes.

00:37:12.160 --> 00:37:13.879
Does that--

00:37:13.879 --> 00:37:14.352
AUDIENCE: So wait.

00:37:14.352 --> 00:37:16.244
What is this doing then?

00:37:16.244 --> 00:37:19.560
L is a list of areas?

00:37:19.560 --> 00:37:20.810
PROFESSOR: No, L is
a list of shapes.

00:37:24.100 --> 00:37:27.004
It's a list of subclasses
of shapes.

00:37:33.452 --> 00:37:35.932
AUDIENCE: So you're feeding
f this list of shapes.

00:37:38.908 --> 00:37:42.740
Oh, and to compare if S and
L [? into that list ?]

00:37:42.740 --> 00:37:43.736
is greater.

00:37:43.736 --> 00:37:46.292
And for equal to x, do you have
to use the greater than

00:37:46.292 --> 00:37:47.222
or equal to--

00:37:47.222 --> 00:37:47.620
PROFESSOR: Operator, right.

00:37:47.620 --> 00:37:51.206
AUDIENCE: --method, the
class of shapes

00:37:51.206 --> 00:37:51.704
which compares areas?

00:37:51.704 --> 00:37:53.696
PROFESSOR: Mm-hm.

00:37:53.696 --> 00:37:57.040
Now, I might regret this.

00:38:09.110 --> 00:38:11.155
I think this'll work.

00:38:11.155 --> 00:38:11.620
Yep.

00:38:11.620 --> 00:38:12.870
It works.

00:38:15.560 --> 00:38:19.380
So, you see this weirdness
I have here?

00:38:19.380 --> 00:38:21.270
It's showing pretty explicitly
that I'm

00:38:21.270 --> 00:38:24.950
calling this a GE operator.

00:38:24.950 --> 00:38:27.180
It's just so--

00:38:27.180 --> 00:38:30.090
this is really just shorthand
for that.

00:38:30.090 --> 00:38:31.430
Syntactic sugar.

00:38:31.430 --> 00:38:33.290
It's easier to look at.

00:38:33.290 --> 00:38:36.300
Easier to understand.

00:38:36.300 --> 00:38:39.580
And to even drive that
point further home--

00:38:48.870 --> 00:38:52.490
whenever that GE, whenever that
comparison is done, it's

00:38:52.490 --> 00:38:55.620
going to print out I'm here.

00:38:55.620 --> 00:38:56.990
So it is actually getting
called and not

00:38:56.990 --> 00:38:58.240
just blowing smoke.

00:39:02.570 --> 00:39:03.820
Have we beaten this
problem to death?

00:39:07.470 --> 00:39:08.720
Last problem.

00:39:12.140 --> 00:39:17.480
So, I'm actually not a huge
fan of this problem.

00:39:17.480 --> 00:39:21.340
But the way I think of it
is, it's the number

00:39:21.340 --> 00:39:22.930
guessing game, right?

00:39:22.930 --> 00:39:27.150
So I say to you, I'm thinking of
a number between 0 and 100.

00:39:27.150 --> 00:39:29.080
Or in this case, maxVal.

00:39:29.080 --> 00:39:32.080
And your job is to guess, as
quickly as possible, what

00:39:32.080 --> 00:39:33.300
number I'm thinking of.

00:39:33.300 --> 00:39:36.350
The only thing I can tell you
is that you give me a guess

00:39:36.350 --> 00:39:38.800
and I'll tell you if it's higher
or lower, or if it is

00:39:38.800 --> 00:39:40.710
the answer.

00:39:40.710 --> 00:39:43.420
So if I'm thinking of a
number between 0 and

00:39:43.420 --> 00:39:47.962
100, what's the strategy?

00:39:47.962 --> 00:39:49.030
AUDIENCE: [UNINTELLIGIBLE]

00:39:49.030 --> 00:39:49.942
PROFESSOR: Binary search.

00:39:49.942 --> 00:39:51.090
AUDIENCE: Binary search, yeah.

00:39:51.090 --> 00:39:52.130
PROFESSOR: Binary
search, right?

00:39:52.130 --> 00:39:54.560
So you're going to start
in the middle.

00:39:54.560 --> 00:39:56.530
You're going to start at 50, and
you're going to say-- and

00:39:56.530 --> 00:40:00.300
I'm going to say, well,
no, the number I'm

00:40:00.300 --> 00:40:01.750
thinking of is lower.

00:40:01.750 --> 00:40:05.970
So now you're going to guess
between 0 and 50, 25.

00:40:05.970 --> 00:40:08.310
And I'm going to say
it's higher.

00:40:08.310 --> 00:40:11.562
Now you're going to guess
between 25 and 50.

00:40:11.562 --> 00:40:13.950
I don't know, I didn't actually
think of a number.

00:40:13.950 --> 00:40:15.750
But you get the idea, right?

00:40:15.750 --> 00:40:18.785
So this problem is asking you to
implement a binary search.

00:40:21.850 --> 00:40:25.880
And comp.guess here
is functioning

00:40:25.880 --> 00:40:30.256
as me in this problem.

00:40:30.256 --> 00:40:34.670
It knows a number and you write
a program that's going

00:40:34.670 --> 00:40:38.730
to guess it, which
is find.number.

00:40:38.730 --> 00:40:45.200
So, there are multiple ways
to do this problem.

00:40:45.200 --> 00:40:48.560
Here is my solution.

00:40:53.070 --> 00:40:55.930
This is just an implementation
of comp guess.

00:40:55.930 --> 00:40:59.070
At the beginning, set a maximum
value of 100,000.

00:40:59.070 --> 00:41:01.620
And I'm going to guess the magic
number, or I'm going to

00:41:01.620 --> 00:41:05.028
choose a random number
from between-- yeah?

00:41:05.028 --> 00:41:07.754
AUDIENCE: When you say binary
search, is that the same thing

00:41:07.754 --> 00:41:10.320
as bisection search?

00:41:10.320 --> 00:41:10.810
PROFESSOR: It's the same idea.

00:41:10.810 --> 00:41:14.020
But the way that I differentiate
binary search

00:41:14.020 --> 00:41:16.610
from bisection search is that
you do a binary search on a

00:41:16.610 --> 00:41:20.620
finite list of elements,
of sorted elements.

00:41:20.620 --> 00:41:26.600
So I might have a list of names
in alphabetical order,

00:41:26.600 --> 00:41:29.500
or a list of numbers
in ascending order.

00:41:29.500 --> 00:41:33.150
And I would do a binary
search on that list.

00:41:33.150 --> 00:41:37.490
With bisection search, it's not
necessarily a finite list

00:41:37.490 --> 00:41:40.830
of numbers or elements
that I'm looking at.

00:41:40.830 --> 00:41:44.580
It's, I know that the answer
exists within a lower and an

00:41:44.580 --> 00:41:50.230
upper bound, and I'm going to
divide that search space in

00:41:50.230 --> 00:41:54.410
half successively or iteratively
to find that

00:41:54.410 --> 00:41:55.950
actual value.

00:41:55.950 --> 00:41:58.790
But it's not necessarily a
finite list of elements

00:41:58.790 --> 00:42:00.040
between those bounds.

00:42:02.330 --> 00:42:03.880
That's good?

00:42:03.880 --> 00:42:06.080
AUDIENCE: Yes.

00:42:06.080 --> 00:42:08.410
PROFESSOR: So this is
one implementation.

00:42:08.410 --> 00:42:13.890
You can do it any
number of ways.

00:42:13.890 --> 00:42:19.060
This numSteps thing, you
wouldn't need to have.

00:42:19.060 --> 00:42:23.170
It's just for me to illustrate
some stuff.

00:42:23.170 --> 00:42:25.240
So I'm going to start
at 0, and I'm

00:42:25.240 --> 00:42:27.190
going to start at maxVal.

00:42:27.190 --> 00:42:28.970
And then I'm going to
keep iterating.

00:42:28.970 --> 00:42:32.200
While I don't have,
or while I haven't

00:42:32.200 --> 00:42:34.710
reached the answer, basically.

00:42:34.710 --> 00:42:38.880
So, I'm going to make my
guess in the middle.

00:42:38.880 --> 00:42:48.330
And then if comp.guess tells me
that it's higher, or that

00:42:48.330 --> 00:42:51.270
my guess is too low, basically,
then I'm going to

00:42:51.270 --> 00:42:54.890
set my upper--

00:42:54.890 --> 00:42:58.120
sorry, if my guess is too high,
then I'm going to set my

00:42:58.120 --> 00:42:59.950
upper bound to my guess.

00:42:59.950 --> 00:43:02.110
And then I'm going to search
in the middle from there.

00:43:02.110 --> 00:43:04.940
And then if it tells me that my
guess is too high, then I'm

00:43:04.940 --> 00:43:08.400
going to search in
the upper region.

00:43:08.400 --> 00:43:11.510
Otherwise, that means I've
made the correct

00:43:11.510 --> 00:43:15.810
guess and I'm done.

00:43:15.810 --> 00:43:23.480
So, very simple.

00:43:27.610 --> 00:43:31.640
The key part of this problem
that tells you that you should

00:43:31.640 --> 00:43:34.370
use binary search, though, is
that it stipulates you need to

00:43:34.370 --> 00:43:37.440
have a log maxVal algorithm.

00:43:37.440 --> 00:43:42.410
And binary search is
a log N algorithm.

00:43:42.410 --> 00:43:47.180
I mean, you could do find number
in a linear search, but

00:43:47.180 --> 00:43:48.430
it would be fairly
inefficient.

00:43:51.350 --> 00:43:52.600
All right?

00:43:54.937 --> 00:43:56.843
AUDIENCE: [INAUDIBLE] just guess
one number, then go--

00:43:56.843 --> 00:43:58.040
PROFESSOR: Yeah, start at 0--

00:43:58.040 --> 00:43:59.120
AUDIENCE: [UNINTELLIGIBLE]
guess 1, you guess

00:43:59.120 --> 00:44:00.834
2, then guess 3.

00:44:00.834 --> 00:44:02.300
PROFESSOR: Yep.

00:44:02.300 --> 00:44:04.404
So you just keep incrementing
by one.

00:44:10.212 --> 00:44:14.568
AUDIENCE: If it didn't specify,
oh, it should run log

00:44:14.568 --> 00:44:17.472
[UNINTELLIGIBLE], would it be
OK if we had used the word

00:44:17.472 --> 00:44:18.860
[UNINTELLIGIBLE]?

00:44:18.860 --> 00:44:20.940
PROFESSOR: If it didn't specify
the complexity, then

00:44:20.940 --> 00:44:23.990
yeah, you could use whatever
search you deemed appropriate.

00:44:23.990 --> 00:44:27.410
But because it said it
needs to be log N --

00:44:27.410 --> 00:44:28.380
AUDIENCE: Yeah, yeah.

00:44:28.380 --> 00:44:31.290
OK.

00:44:31.290 --> 00:44:33.230
AUDIENCE: [INAUDIBLE]

00:44:33.230 --> 00:44:34.685
PROFESSOR: What's that?

00:44:34.685 --> 00:44:36.625
AUDIENCE: Are you going
to [UNINTELLIGIBLE]?

00:44:40.100 --> 00:44:41.350
PROFESSOR: Not in this
particular case.

00:44:45.000 --> 00:44:47.940
Because we're dealing with
integers anyway.

00:44:47.940 --> 00:44:53.197
So all these operations
are going to

00:44:53.197 --> 00:44:55.804
result in integer results.

00:44:55.804 --> 00:44:57.147
AUDIENCE: Are you going to ever
be able to get to the

00:44:57.147 --> 00:44:59.130
highest number?

00:44:59.130 --> 00:45:02.850
PROFESSOR: So if it were,
like, 99,000?

00:45:02.850 --> 00:45:05.820
Is that what you're asking?

00:45:05.820 --> 00:45:07.800
AUDIENCE: If the number
were maxVal.

00:45:07.800 --> 00:45:09.780
PROFESSOR: Well, we'll see.

00:45:09.780 --> 00:45:11.072
I might have it wrong in my

00:45:11.072 --> 00:45:12.633
implementation, always possible.

00:45:12.633 --> 00:45:16.561
If I do, I'd probably take
one point off me.

00:45:27.880 --> 00:45:30.300
Yeah, so I have a bug.

00:45:30.300 --> 00:45:33.380
So I am actually--

00:45:33.380 --> 00:45:37.060
AUDIENCE: When it divides, it
rounds it down [INAUDIBLE].

00:45:37.060 --> 00:45:37.360
PROFESSOR: Yeah.

00:45:37.360 --> 00:45:38.980
So I have a bug.

00:45:38.980 --> 00:45:44.300
And I'm not going to try and
fix it right now, but yeah.

00:45:44.300 --> 00:45:46.800
If I were grading this and this
were my solution, I'd

00:45:46.800 --> 00:45:49.330
dock me a point or two.

00:45:49.330 --> 00:45:52.590
AUDIENCE: What's your error?

00:45:52.590 --> 00:45:58.300
PROFESSOR: My error is that
because of this the way that I

00:45:58.300 --> 00:46:05.000
get my guess here, I'm never
going to get to max val.

00:46:05.000 --> 00:46:09.246
If the computer chose maxVal as
its guess, then I'd never

00:46:09.246 --> 00:46:10.496
get to that.

00:46:14.190 --> 00:46:17.936
So yeah, you caught me.

00:46:17.936 --> 00:46:20.870
AUDIENCE: A friend of mine
looked at this and was like,

00:46:20.870 --> 00:46:24.782
oh, you should define another
function to solve it.

00:46:24.782 --> 00:46:26.444
Is that kind of thing actually
allowed on the

00:46:26.444 --> 00:46:29.690
exam at all, or no?

00:46:29.690 --> 00:46:31.370
PROFESSOR: Well, why did your
friend think you need to find

00:46:31.370 --> 00:46:33.370
another function?

00:46:33.370 --> 00:46:35.870
AUDIENCE: I'm not
exactly sure.

00:46:35.870 --> 00:46:40.370
It was supposed to be
[UNINTELLIGIBLE]

00:46:40.370 --> 00:46:44.870
PROFESSOR: Did they say define
a recursive function?

00:46:44.870 --> 00:46:46.360
AUDIENCE: I think that's what
I was trying to do.

00:46:46.360 --> 00:46:47.662
PROFESSOR: So I'm solving
it iteratively.

00:46:47.662 --> 00:46:50.400
You really can write a
recursive function.

00:46:50.400 --> 00:46:54.030
And in this case, because
we've given you the

00:46:54.030 --> 00:46:57.320
specification for find number,
you'd probably write something

00:46:57.320 --> 00:47:00.632
like find number helper, and
have whatever additional

00:47:00.632 --> 00:47:03.203
parameters you needed in order
to support the recursion.

00:47:03.203 --> 00:47:05.668
AUDIENCE: So you can
do that or no?

00:47:05.668 --> 00:47:06.161
PROFESSOR: Yeah.

00:47:06.161 --> 00:47:06.654
We'd be fine with that.

00:47:06.654 --> 00:47:11.091
The point is that you write a
function that runs in log

00:47:11.091 --> 00:47:12.341
maxVal time.

00:47:15.035 --> 00:47:17.623
AUDIENCE: Because at the top it
says that the magic number

00:47:17.623 --> 00:47:21.937
is in range maxVal, doesn't
that mean that the number

00:47:21.937 --> 00:47:25.881
would not ever be maxVal?

00:47:25.881 --> 00:47:27.853
PROFESSOR: Let me see.

00:47:27.853 --> 00:47:29.332
Actually, yeah.

00:47:29.332 --> 00:47:32.783
Because it would be 0 to 999--

00:47:32.783 --> 00:47:35.750
or 999,999.

00:47:35.750 --> 00:47:40.070
Well, I'm not sure
if this actually

00:47:40.070 --> 00:47:41.513
constitutes a bug or not.

00:47:41.513 --> 00:47:43.437
So I'd have to do
unit testing.

00:47:43.437 --> 00:47:46.804
I don't have any test cases.

00:47:46.804 --> 00:47:49.520
Which is, again, back
to unit testing.

00:47:52.460 --> 00:47:54.420
You have a question or--?

00:47:54.420 --> 00:47:54.910
AUDIENCE: Yeah.

00:47:54.910 --> 00:48:00.480
Could you do this by saying
your guess equals choose a

00:48:00.480 --> 00:48:01.956
random number between
high and low?

00:48:05.400 --> 00:48:07.700
PROFESSOR: You could.

00:48:07.700 --> 00:48:09.492
But it would have--

00:48:09.492 --> 00:48:16.857
the analyzing complexity would
be problematic, I would think.

00:48:16.857 --> 00:48:20.416
Doing it this way, by guessing
right in the middle, you know

00:48:20.416 --> 00:48:25.590
it's going to be log
maxVal complexity.

00:48:25.590 --> 00:48:27.810
If you were to choose a random
number between low and high,

00:48:27.810 --> 00:48:31.390
I'm not sure what that would
do to the complexity.

00:48:31.390 --> 00:48:33.220
It would make the analysis a
little bit more intricate.

00:48:37.964 --> 00:48:43.780
And if this were the actual quiz
and you put that as your

00:48:43.780 --> 00:48:44.927
answer we'd probably take
a fair number of

00:48:44.927 --> 00:48:46.177
points off for it.

00:48:50.530 --> 00:48:52.064
There are people who
do study algorithms

00:48:52.064 --> 00:48:53.052
that do that, though.

00:48:53.052 --> 00:48:56.016
They use random numbers in
order to [UNINTELLIGIBLE]

00:48:56.016 --> 00:48:57.266
the values.

00:48:59.980 --> 00:49:04.100
So we're done with the quiz.

00:49:04.100 --> 00:49:06.260
And now we've got a list
of topics to go over.

00:49:09.380 --> 00:49:14.060
So, let's start at the top.

00:49:14.060 --> 00:49:16.980
The first subject that was
listed-- so all you got the

00:49:16.980 --> 00:49:20.450
list of quiz topics for the
quiz, I'm assuming?

00:49:20.450 --> 00:49:23.560
Did all of you look at it?

00:49:23.560 --> 00:49:25.290
The first topic is algorithms.

00:49:25.290 --> 00:49:28.380
And I have big-O notation,
exhaustive enumeration, guess

00:49:28.380 --> 00:49:30.060
and check, successive
approximation, divide and

00:49:30.060 --> 00:49:33.360
conquer, binary search, merge
sort, hashing, orders of

00:49:33.360 --> 00:49:35.860
growth, and amortized
analysis.

00:49:35.860 --> 00:49:39.270
So, first come, first serve.

00:49:39.270 --> 00:49:41.057
What do people want to see?

00:49:41.057 --> 00:49:42.011
AUDIENCE: Hashing.

00:49:42.011 --> 00:49:42.965
AUDIENCE: Yeah.

00:49:42.965 --> 00:49:45.830
Hashing and amortized
analysis.

00:49:45.830 --> 00:49:47.730
PROFESSOR: Hashing and
amortized analysis.

00:49:47.730 --> 00:49:50.400
OK.

00:49:50.400 --> 00:49:52.610
So why don't I start with
hashing, because

00:49:52.610 --> 00:49:53.940
that's pretty easy.

00:49:53.940 --> 00:50:00.620
The idea behind hashing is that
you have a function, and

00:50:00.620 --> 00:50:03.360
it's going to take some input.

00:50:03.360 --> 00:50:08.000
And it's going to compute
an address of some sort.

00:50:08.000 --> 00:50:13.690
And let's imagine that I have
a data structure that has a

00:50:13.690 --> 00:50:17.950
number of buckets arranged
one after the other.

00:50:23.700 --> 00:50:31.770
What hashing does is, it says I
have this input s, or a key,

00:50:31.770 --> 00:50:33.190
if you will.

00:50:33.190 --> 00:50:36.030
And I'm going to compute
an address like a

00:50:36.030 --> 00:50:37.540
number of some sort.

00:50:37.540 --> 00:50:39.830
And it's going to, say,
wind up here.

00:50:42.540 --> 00:50:46.430
And this relates to Python
because this is how

00:50:46.430 --> 00:50:48.280
dictionaries are implemented.

00:50:48.280 --> 00:50:51.890
So this s here is going to be
the key that you give the

00:50:51.890 --> 00:50:53.320
dictionary.

00:50:53.320 --> 00:50:57.530
And then it'll compute a
location for this bucket where

00:50:57.530 --> 00:50:58.780
it's going to put the value.

00:51:03.740 --> 00:51:08.080
So, the idea--

00:51:08.080 --> 00:51:12.890
what makes these hashing
functions valuable, especially

00:51:12.890 --> 00:51:16.060
with respect to dictionaries, is
that you can check for the

00:51:16.060 --> 00:51:20.270
presence of a key or a value
in constant time.

00:51:20.270 --> 00:51:24.590
Because the hashing function
is more or less constant.

00:51:24.590 --> 00:51:27.680
And once you have an address
into the data structure, it's

00:51:27.680 --> 00:51:30.590
very easy to compute the
location where you're going to

00:51:30.590 --> 00:51:32.530
put something.

00:51:32.530 --> 00:51:37.160
So, I'm not sure--

00:51:37.160 --> 00:51:41.860
does that kind of help you?

00:51:41.860 --> 00:51:47.520
You don't need to know hashing
in great detail.

00:51:47.520 --> 00:51:51.290
You're not going to need to know
the hashing function for

00:51:51.290 --> 00:51:54.560
like a string, or the hashing
function for a tuple or

00:51:54.560 --> 00:51:55.910
something like that.

00:51:55.910 --> 00:52:01.130
The main points that you need to
get from hashing is that it

00:52:01.130 --> 00:52:03.820
computes an address into
this data structure.

00:52:03.820 --> 00:52:06.620
It's a constant time thing.

00:52:06.620 --> 00:52:10.120
And that's about it, actually.

00:52:10.120 --> 00:52:12.990
If you have those two
concepts down--

00:52:12.990 --> 00:52:15.510
well, also, three that that's
how dictionaries are

00:52:15.510 --> 00:52:16.620
implemented--

00:52:16.620 --> 00:52:21.860
if you have those in your mind
for hashing, you'll be good.

00:52:21.860 --> 00:52:24.630
Anyone have any other questions
for hashing?

00:52:24.630 --> 00:52:27.250
AUDIENCE: So we never have to
like write a hashing function.

00:52:27.250 --> 00:52:28.500
It's more like [INAUDIBLE]

00:52:31.198 --> 00:52:32.770
PROFESSOR: This is so that you
know what it is, and when you

00:52:32.770 --> 00:52:35.750
see it in the future, if you see
it in the future, you're

00:52:35.750 --> 00:52:37.240
not totally lost.

00:52:37.240 --> 00:52:40.720
You have an idea of
what it's doing.

00:52:40.720 --> 00:52:45.550
You can define your own hash
functions, but we're not going

00:52:45.550 --> 00:52:47.250
to require that of you
in this course.

00:52:53.940 --> 00:52:56.800
So that's hashing, basically.

00:52:56.800 --> 00:52:59.620
And all you need to
know for the quiz.

00:52:59.620 --> 00:53:08.010
So for amortized analysis, the
idea behind amortized analysis

00:53:08.010 --> 00:53:11.140
is that you have--

00:53:11.140 --> 00:53:14.770
maybe you have a known sequence
of operations.

00:53:14.770 --> 00:53:21.320
And you're trying to find what
the worst case runtime for

00:53:21.320 --> 00:53:23.330
that sequence of
operations is.

00:53:23.330 --> 00:53:26.740
And you might have a bunch of
operations that are really,

00:53:26.740 --> 00:53:29.840
really low cost, or
low complexity.

00:53:29.840 --> 00:53:31.870
And one really expensive one.

00:53:31.870 --> 00:53:39.140
And for our purposes, we're
trying to find this--

00:53:39.140 --> 00:53:42.420
find which of these operations
is the dominating factor for

00:53:42.420 --> 00:53:43.330
the complexity.

00:53:43.330 --> 00:53:48.330
So the example I would use is,
let's say that I have the task

00:53:48.330 --> 00:53:55.490
of searching for an element
in a big list of elements.

00:53:55.490 --> 00:53:59.240
So we know two basic search
algorithms for this, right?

00:53:59.240 --> 00:54:02.990
We know a linear search, where
we go one at a time through

00:54:02.990 --> 00:54:04.080
each of the elements.

00:54:04.080 --> 00:54:07.855
And what's the complexity
of that?

00:54:07.855 --> 00:54:08.850
AUDIENCE: [INAUDIBLE]

00:54:08.850 --> 00:54:09.355
PROFESSOR: What's that?

00:54:09.355 --> 00:54:11.650
AUDIENCE: Just the length
of [INAUDIBLE].

00:54:11.650 --> 00:54:13.310
PROFESSOR: It's going to be
linear in terms of the number

00:54:13.310 --> 00:54:15.010
of elements in the list.

00:54:15.010 --> 00:54:19.370
We also know binary search.

00:54:19.370 --> 00:54:22.160
What's the complexity
of binary search?

00:54:22.160 --> 00:54:22.990
AUDIENCE: Log N.

00:54:22.990 --> 00:54:25.750
PROFESSOR: Log N. Now, there's
a problem with binary search.

00:54:25.750 --> 00:54:27.580
It has a requirement.

00:54:27.580 --> 00:54:32.290
Will binary search work on a
list that is not sorted?

00:54:32.290 --> 00:54:33.650
No.

00:54:33.650 --> 00:54:35.380
You require it to be sorted.

00:54:35.380 --> 00:54:41.610
So, we've talked about
sorting in class.

00:54:41.610 --> 00:54:42.860
He covered it during
the lecture.

00:54:46.520 --> 00:54:54.510
For basic sorting that we've
seen, the lower bound, the

00:54:54.510 --> 00:54:58.100
complexity of the sorting
algorithms is N log N. So

00:54:58.100 --> 00:55:00.880
merge sort will be an
N log N algorithm.

00:55:00.880 --> 00:55:04.540
So, when--

00:55:04.540 --> 00:55:10.360
let's say that we just need
to do one search, right?

00:55:10.360 --> 00:55:16.590
Do I really want to
use binary search?

00:55:16.590 --> 00:55:17.940
Why?

00:55:17.940 --> 00:55:19.800
AUDIENCE: [INAUDIBLE]

00:55:19.800 --> 00:55:22.995
PROFESSOR: Because I have
to sort it first.

00:55:22.995 --> 00:55:28.470
And if I just do--

00:55:28.470 --> 00:55:44.060
if I do I have to sort
and then search, and

00:55:44.060 --> 00:55:45.310
this is going to be--

00:55:54.040 --> 00:56:04.250
whereas if I do a linear search,
I just have search.

00:56:11.460 --> 00:56:17.720
And for just a single search,
for binary search, this is

00:56:17.720 --> 00:56:19.740
going to dominate
my complexity.

00:56:19.740 --> 00:56:21.795
But, let's say that I'm going
to do a million searches.

00:56:25.400 --> 00:56:29.660
Now, it might behoove me to
actually sort this first.

00:56:29.660 --> 00:56:33.980
Because I only have to
sort the list once.

00:56:33.980 --> 00:56:36.850
And then I can do as many
searches as I want.

00:56:36.850 --> 00:56:42.490
So, in the grand scheme of
things, if I'm doing a million

00:56:42.490 --> 00:56:48.140
searches, then linear search
is a really poor choice.

00:56:48.140 --> 00:56:52.550
And binary search would
be my best option.

00:56:52.550 --> 00:56:55.520
And this is about as deep
as we want to go

00:56:55.520 --> 00:56:56.960
with amortized analysis.

00:56:56.960 --> 00:57:01.090
It's this idea that there's a
certain point at which one

00:57:01.090 --> 00:57:03.170
algorithm becomes more important
than another

00:57:03.170 --> 00:57:06.920
algorithm, because the
composition of its operations

00:57:06.920 --> 00:57:10.330
kind of determines, it changes
as you increase the number of

00:57:10.330 --> 00:57:12.340
elements you're working with
the number of times you're

00:57:12.340 --> 00:57:13.590
going to do the operation.

00:57:17.220 --> 00:57:18.530
That's kind of what you
need to understand

00:57:18.530 --> 00:57:20.530
for amortized analysis.

00:57:20.530 --> 00:57:26.180
And it can be used in other
types of analyses, but we're

00:57:26.180 --> 00:57:27.580
not going to get into that.

00:57:34.270 --> 00:57:35.800
All right.

00:57:35.800 --> 00:57:39.930
What other topics do we want
to go over for algorithms?

00:57:39.930 --> 00:57:45.950
We've got big-O notation,
exhaustive enumeration, divide

00:57:45.950 --> 00:57:46.530
and conquer.

00:57:46.530 --> 00:57:48.544
Successive approximation,
merge sort,

00:57:48.544 --> 00:57:50.480
and orders of growth.

00:57:54.352 --> 00:57:56.290
AUDIENCE: Can we go
over merge sort?

00:57:56.290 --> 00:57:58.752
PROFESSOR: You want to
go over merge sort?

00:57:58.752 --> 00:58:00.630
OK.

00:58:00.630 --> 00:58:02.640
So-- and today actually,
I have my code.

00:58:06.640 --> 00:58:11.700
So merge sort is a divide
and conquer algorithm.

00:58:11.700 --> 00:58:17.500
And the idea is that
I am going to

00:58:17.500 --> 00:58:19.450
take a list of elements.

00:58:22.840 --> 00:58:31.750
And I'm going to divide
the list in half.

00:58:31.750 --> 00:58:34.120
So I'm going to get a left list
and a right list, and

00:58:34.120 --> 00:58:36.070
they're unsorted.

00:58:36.070 --> 00:58:37.590
And then I'm going to call
merge.sort on them.

00:58:40.290 --> 00:58:45.110
And I'm going to keep
recursively calling merge sort

00:58:45.110 --> 00:58:49.360
until I have one element or
no elements in the list.

00:58:49.360 --> 00:58:51.065
And then I'm going to
return the list.

00:58:53.800 --> 00:58:58.850
After I do a merge sort on the
left and right halves, I'm

00:58:58.850 --> 00:59:01.940
going to merge them.

00:59:01.940 --> 00:59:06.760
And the merge operation is just
going to start at the

00:59:06.760 --> 00:59:10.690
beginning of the left and right
halves of the list, and

00:59:10.690 --> 00:59:13.890
it's going to append the
smaller element at the

00:59:13.890 --> 00:59:17.180
beginning of each of the lists
to result until it gets to the

00:59:17.180 --> 00:59:18.520
end of the lists.

00:59:18.520 --> 00:59:24.650
So I'll try a blackboard
demonstration in a second.

00:59:24.650 --> 00:59:26.670
Or explanation in a second.

00:59:26.670 --> 00:59:35.810
So, this before parameter,
all this is doing is it's

00:59:35.810 --> 00:59:39.420
determining the order
of the elements.

00:59:39.420 --> 00:59:45.600
So it's saying that left should
come before right.

00:59:45.600 --> 00:59:48.590
It'll return true if left should
come before right, and

00:59:48.590 --> 00:59:51.300
false if right should
come before left.

00:59:54.100 --> 01:00:04.910
So, intuitively, because I don't
think that was a very

01:00:04.910 --> 01:00:06.850
good explanation,
let's say that I

01:00:06.850 --> 01:00:08.100
have a list of elements.

01:00:16.740 --> 01:00:17.990
And they're unsorted.

01:00:28.360 --> 01:00:28.690
All right.

01:00:28.690 --> 01:00:31.580
So it's an unsorted
list of elements.

01:00:31.580 --> 01:00:35.880
When merge.sort first starts,
it's going to divide this list

01:00:35.880 --> 01:00:37.700
into left and right halves.

01:00:37.700 --> 01:00:39.780
So basically it's going to
take the middle here.

01:00:42.820 --> 01:00:53.360
And then it's going to call
itself, on this left half and

01:00:53.360 --> 01:00:54.610
then on this right half.

01:01:01.760 --> 01:01:03.060
And it's going to
keep doing this.

01:01:03.060 --> 01:01:08.120
It's going to divide this
half into say --

01:01:08.120 --> 01:01:09.370
5, 2, 1.

01:01:30.380 --> 01:01:32.800
Now, when it gets to these
little single elements, it's

01:01:32.800 --> 01:01:34.050
going to do something
interesting.

01:01:40.460 --> 01:01:42.420
It's going to merge these two.

01:01:42.420 --> 01:01:45.560
So when it gets down to these
single elements, it's just

01:01:45.560 --> 01:01:50.050
going to return the list as
is, it's not going to do

01:01:50.050 --> 01:01:51.310
anything to them.

01:01:51.310 --> 01:02:10.110
And then the code after
this, division, is

01:02:10.110 --> 01:02:11.040
going to merge them.

01:02:11.040 --> 01:02:13.560
And the way it merges them is,
it's going to start at the

01:02:13.560 --> 01:02:15.430
beginning of these two lists.

01:02:15.430 --> 01:02:19.390
And it's going to say, is this
element larger or smaller than

01:02:19.390 --> 01:02:20.100
this element?

01:02:20.100 --> 01:02:22.990
Or is it going to come
before this element?

01:02:22.990 --> 01:02:25.270
And it's going to construct
a merged list.

01:02:28.420 --> 01:02:32.220
And then return that
as its result.

01:02:32.220 --> 01:02:34.370
So this is going to come down.

01:02:34.370 --> 01:02:37.850
So now at this point it's
popping back up the stack.

01:02:37.850 --> 01:02:39.170
It's going to return this.

01:02:39.170 --> 01:02:41.920
It's going to merge
these two lists.

01:02:41.920 --> 01:02:44.570
Starts at the beginning
of both lists.

01:02:44.570 --> 01:02:47.780
One comes before two.

01:02:47.780 --> 01:02:50.540
And then this list is done,
so now it only has

01:02:50.540 --> 01:02:51.790
this list to do.

01:02:55.170 --> 01:02:59.120
After each merge step, these
lists are going to be sorted.

01:02:59.120 --> 01:03:02.240
So now where are we at?

01:03:02.240 --> 01:03:04.932
So now let's do this guy.

01:03:04.932 --> 01:03:07.160
So this guy gets merged
into 6 and 9.

01:03:10.550 --> 01:03:12.620
And then this guy, I
didn't divide up.

01:03:12.620 --> 01:03:14.820
So, bad on me.

01:03:40.770 --> 01:03:43.995
So we're going to merge those
two single element lists.

01:03:52.220 --> 01:03:54.565
Now these get merged.

01:04:12.420 --> 01:04:14.810
So these guys are going
to get merged.

01:04:14.810 --> 01:04:18.170
So, this is going to become, I
think my tree got messed up a

01:04:18.170 --> 01:04:19.420
little bit.

01:04:25.780 --> 01:04:28.210
Now we're going to merge
these lists.

01:04:28.210 --> 01:04:30.200
So we're going to start
at the beginning.

01:04:30.200 --> 01:04:31.830
1 comes before 3.

01:04:31.830 --> 01:04:33.860
First element is 1.

01:04:33.860 --> 01:04:35.110
2 comes before 3.

01:04:37.780 --> 01:04:39.050
Now we're here in this list.

01:04:39.050 --> 01:04:40.800
We're still at the beginning
of this list.

01:04:40.800 --> 01:04:42.050
3 comes before 5.

01:04:44.692 --> 01:04:46.120
5 comes before 7.

01:04:49.330 --> 01:04:50.700
And we're here.

01:04:50.700 --> 01:04:53.610
6 comes before 7.

01:04:53.610 --> 01:04:55.350
Then we have 7.

01:04:55.350 --> 01:04:59.240
And then 9 comes before 10.

01:04:59.240 --> 01:05:00.590
Now we're done with this list.

01:05:00.590 --> 01:05:03.910
So now we have 10, 13.

01:05:03.910 --> 01:05:09.060
And at the end of the last
merge the list is sorted.

01:05:09.060 --> 01:05:14.288
So, I'm not sure how
clear that was.

01:05:14.288 --> 01:05:16.276
AUDIENCE: What happens if
there's [UNINTELLIGIBLE] to

01:05:16.276 --> 01:05:16.780
begin with?

01:05:16.780 --> 01:05:19.928
Like all of your split equally
into [UNINTELLIGIBLE]?

01:05:19.928 --> 01:05:21.904
What if there's one more
element at the top,

01:05:21.904 --> 01:05:23.386
[UNINTELLIGIBLE]?

01:05:23.386 --> 01:05:25.370
Do you know what I mean, like,
there'd be one left over?

01:05:25.370 --> 01:05:26.993
PROFESSOR: What do you mean?

01:05:26.993 --> 01:05:32.400
So there's an odd number of
elements in the list?

01:05:32.400 --> 01:05:35.650
So you would just get
an uneven split.

01:05:35.650 --> 01:05:38.130
So your left sub-list might
have 6 elements.

01:05:38.130 --> 01:05:40.200
Say you have 11 elements
in the list.

01:05:40.200 --> 01:05:43.220
Left element would have 6,
or left list would have 6

01:05:43.220 --> 01:05:45.130
elements and then the right
list would have 5.

01:05:45.130 --> 01:05:46.028
AUDIENCE: [UNINTELLIGIBLE]
then that would

01:05:46.028 --> 01:05:48.070
split with 3 and 2.

01:05:48.070 --> 01:05:50.683
And then the 2 would split to
1 and 1, the 3 would split

01:05:50.683 --> 01:05:53.558
into 1 and 2, and then the
2 would split again?

01:05:53.558 --> 01:05:56.400
PROFESSOR: And then the 1 would
actually make a call,

01:05:56.400 --> 01:05:58.556
but it would be an empty list.

01:05:58.556 --> 01:06:02.280
It would split, but one of them
would be an empty list.

01:06:02.280 --> 01:06:02.770
AUDIENCE: Oh.

01:06:02.770 --> 01:06:07.180
So and then it would
just get--

01:06:07.180 --> 01:06:08.190
PROFESSOR: And that's kind of
what happened with my tree.

01:06:08.190 --> 01:06:09.480
I didn't go all the way
down on some of the

01:06:09.480 --> 01:06:10.900
branches of my tree.

01:06:14.850 --> 01:06:16.920
I mean, the main idea behind
merge.sort is that you split

01:06:16.920 --> 01:06:20.350
the list in half, whatever
size it this.

01:06:20.350 --> 01:06:24.560
And then you merge sort
those separate halves.

01:06:24.560 --> 01:06:26.650
And merge sort is going to do
the same thing with those

01:06:26.650 --> 01:06:26.810
separate halves.

01:06:26.810 --> 01:06:28.610
It's going to split
them in half.

01:06:28.610 --> 01:06:31.380
And sort those halves until it
gets to the smallest case,

01:06:31.380 --> 01:06:34.000
which is an empty list or
just a single element.

01:06:34.000 --> 01:06:36.840
And then it's just going to
start merging these lists.

01:06:36.840 --> 01:06:38.253
AUDIENCE: Right, I was just
wondering what happened

01:06:38.253 --> 01:06:40.140
[UNINTELLIGIBLE]

01:06:40.140 --> 01:06:43.138
PROFESSOR: Yeah, you'd split it
into 2 and 1, and then that

01:06:43.138 --> 01:06:44.910
merge sort would be
like 1 and 1.

01:06:44.910 --> 01:06:49.596
And then this 1 would split it
into a list of 1 and nothing.

01:06:49.596 --> 01:06:50.548
That's all.

01:06:50.548 --> 01:06:52.452
And then the merge between
that's obvious, right?

01:06:56.270 --> 01:07:00.104
AUDIENCE: So in the merge sort
lecture notes, at one point,

01:07:00.104 --> 01:07:02.000
lambda is used.

01:07:02.000 --> 01:07:04.370
Can you explain a bit
how this works?

01:07:04.370 --> 01:07:06.180
PROFESSOR: Does he actually
use a lambda?

01:07:06.180 --> 01:07:06.510
AUDIENCE: Yeah.

01:07:06.510 --> 01:07:08.502
Why is it useful?

01:07:08.502 --> 01:07:12.486
I guess [UNINTELLIGIBLE].

01:07:12.486 --> 01:07:12.984
PROFESSOR: Ah.

01:07:12.984 --> 01:07:15.990
He used lambda.

01:07:15.990 --> 01:07:20.050
OK, Python has these functions
called lambda functions.

01:07:20.050 --> 01:07:25.570
And what they are essentially
are like one-liner bits of

01:07:25.570 --> 01:07:27.710
code that return a value.

01:07:27.710 --> 01:07:30.160
So let's see.

01:07:40.980 --> 01:07:42.230
I can't believe he
used lambda.

01:07:47.450 --> 01:07:50.730
I'm trying to think of where
I would actually use them.

01:07:50.730 --> 01:07:51.760
Like, an example.

01:07:51.760 --> 01:07:54.710
And I don't have one off
the top of my head.

01:07:54.710 --> 01:07:59.050
You're not going to see
a lambda on the quiz.

01:07:59.050 --> 01:08:02.350
The syntax is not
too difficult.

01:08:02.350 --> 01:08:08.840
It's basically, so,
like lambda x.

01:08:08.840 --> 01:08:11.700
And then it's going to return,
like, x-squared.

01:08:11.700 --> 01:08:13.620
This is going to create
a function.

01:08:13.620 --> 01:08:22.069
And it can be something like, I
assign this lambda function

01:08:22.069 --> 01:08:25.250
to a variable square.

01:08:25.250 --> 01:08:29.470
And I'm going to pull
up a separate--

01:08:29.470 --> 01:08:31.770
So I'm creating a
function square.

01:08:31.770 --> 01:08:45.660
But instead of writing something
like this, I write

01:08:45.660 --> 01:08:47.970
it as this.

01:08:47.970 --> 01:08:49.220
And ...

01:08:55.432 --> 01:08:57.859
AUDIENCE: [INAUDIBLE]

01:08:57.859 --> 01:08:59.452
PROFESSOR: What's that?

01:08:59.452 --> 01:09:02.398
AUDIENCE: Do you have to save it
before it lets you run it?

01:09:02.398 --> 01:09:02.889
PROFESSOR: Yeah.

01:09:02.889 --> 01:09:03.871
That's, again, what I'm doing.

01:09:03.871 --> 01:09:06.817
I'm just trying to think
of a witty name.

01:09:13.691 --> 01:09:16.444
I'm actually stunned that he
whipped lambda out in lecture.

01:09:19.359 --> 01:09:22.720
So really it's a
way of defining

01:09:22.720 --> 01:09:25.200
these one-liner functions.

01:09:25.200 --> 01:09:31.250
Python's lambda functions are
kind of broken, at least in

01:09:31.250 --> 01:09:35.420
the 2.5, 2.6, 2.7,
2.x versions.

01:09:35.420 --> 01:09:39.560
3.0, 3.x versions of Python, I
think, actually do away with

01:09:39.560 --> 01:09:44.229
lambda because they
were broken.

01:09:44.229 --> 01:09:46.180
You find lambda functions in
a lot of other programming

01:09:46.180 --> 01:09:47.680
languages like Lisp or Scheme.

01:09:51.220 --> 01:09:56.630
And you're never going to
see this on a quiz.

01:09:56.630 --> 01:09:58.040
But if you want to learn
more about them you

01:09:58.040 --> 01:09:59.290
can look it up online.

01:10:03.020 --> 01:10:05.182
AUDIENCE: While you're running
the function, what is the

01:10:05.182 --> 01:10:07.748
[INAUDIBLE]

01:10:07.748 --> 01:10:10.153
The same thing?

01:10:10.153 --> 01:10:11.115
Oh, OK.

01:10:11.115 --> 01:10:12.570
PROFESSOR: Yeah.

01:10:12.570 --> 01:10:15.835
I had it there as an
illustration that the

01:10:15.835 --> 01:10:21.220
functions are-- they're
functionally equivalent.

01:10:21.220 --> 01:10:27.290
And it actually serves to
illustrate another point, that

01:10:27.290 --> 01:10:31.810
functions are objects and you
can sign them and pass them

01:10:31.810 --> 01:10:33.010
around and stuff.

01:10:33.010 --> 01:10:37.460
But lambda functions on their
own, you're not going to need

01:10:37.460 --> 01:10:44.885
to know that piece of linguistic
Python, Pythonese.

01:10:44.885 --> 01:10:45.875
Bad sentence.

01:10:45.875 --> 01:10:48.350
You're not going to
need to know it.

01:10:48.350 --> 01:10:50.330
Does that work?

01:10:50.330 --> 01:10:51.580
OK.

01:10:54.290 --> 01:10:57.383
I'm going to have to ask him
about that, because I can't

01:10:57.383 --> 01:10:59.982
believe he used lambda
in lecture.

01:11:03.770 --> 01:11:05.885
AUDIENCE: In one of the
lecture notes, he used

01:11:05.885 --> 01:11:08.470
something called x-range.

01:11:08.470 --> 01:11:08.940
PROFESSOR: x-range.

01:11:08.940 --> 01:11:10.570
AUDIENCE: What does that do?

01:11:10.570 --> 01:11:13.520
PROFESSOR: Did he talk about
generator objects or iterate?

01:11:13.520 --> 01:11:14.715
Or yield?

01:11:14.715 --> 01:11:18.040
You haven't seen those?

01:11:18.040 --> 01:11:19.290
OK.

01:11:23.410 --> 01:11:30.720
So what you're asking is,
something like that.

01:11:30.720 --> 01:11:31.970
He used something like that.

01:11:34.590 --> 01:11:38.830
The difference between range
and x-range is that range

01:11:38.830 --> 01:11:43.480
returns a list of integers,
and x-range returns in

01:11:43.480 --> 01:11:44.730
generator object.

01:11:47.460 --> 01:11:51.150
And I know that really meant
a whole lot to you.

01:11:51.150 --> 01:11:53.625
So let's say that I assign ...

01:11:56.470 --> 01:11:57.720
AUDIENCE: [INAUDIBLE]

01:11:59.956 --> 01:12:02.960
PROFESSOR: Yeah. that's what
I'm going to show.

01:12:02.960 --> 01:12:07.490
So if I do print list of
integers, or list of numbers,

01:12:07.490 --> 01:12:09.170
it's actually going to print
the list of numbers.

01:12:13.650 --> 01:12:14.950
Someone fall back there?

01:12:19.260 --> 01:12:21.850
So it's actually going
to print that list.

01:12:21.850 --> 01:12:23.810
Now, if I do something like--

01:12:36.270 --> 01:12:37.970
pretty sure this is not
going to print the...

01:12:40.740 --> 01:12:44.880
The reason is that if you look
at the type of the object

01:12:44.880 --> 01:12:54.550
that's returned, it's--

01:12:54.550 --> 01:12:56.970
well, x-range doesn't really
help much either.

01:12:59.840 --> 01:13:01.280
Why does he do this to me?

01:13:06.690 --> 01:13:09.820
It's a way of-- so let's say
that you have a list of a

01:13:09.820 --> 01:13:13.550
billion elements, or numbers,
or things that you need to

01:13:13.550 --> 01:13:16.930
iterate over in a for loop.

01:13:16.930 --> 01:13:19.300
It's probably not a good idea
to bring all of those into

01:13:19.300 --> 01:13:21.110
memory at once.

01:13:21.110 --> 01:13:26.020
So, or to necessarily keep
them all around.

01:13:26.020 --> 01:13:27.130
You want--

01:13:27.130 --> 01:13:29.690
that's where things like
x-range come in.

01:13:29.690 --> 01:13:35.251
So, let's do this.

01:13:35.251 --> 01:13:40.121
AUDIENCE: [INAUDIBLE] for i
in x-range 10 [INAUDIBLE]

01:13:40.121 --> 01:13:40.608
PROFESSOR: Yeah.

01:13:40.608 --> 01:13:55.050
So if I do this, it's going
to be the same as if

01:13:55.050 --> 01:13:56.300
I were to do this.

01:14:05.600 --> 01:14:07.880
It's going to have the same
functional effect, but the

01:14:07.880 --> 01:14:12.410
difference comes in-- let's
say that I were to do

01:14:12.410 --> 01:14:13.660
something like this.

01:14:19.790 --> 01:14:21.500
Lot of numbers, right?

01:14:21.500 --> 01:14:23.230
I'm hoping Python crashes
on this, because

01:14:23.230 --> 01:14:25.430
this is my whole point.

01:14:25.430 --> 01:14:28.630
Yeah, so there's
too many items.

01:14:28.630 --> 01:14:31.280
But let's see if I do
it with x-range.

01:14:39.000 --> 01:14:40.655
I should probably comment
this out.

01:14:49.940 --> 01:14:53.058
I chose a really too large
number, didn't I?

01:15:06.260 --> 01:15:08.190
I'm going to find a number
that has too many list

01:15:08.190 --> 01:15:12.570
elements, but Python can still
feel comfortable constructing

01:15:12.570 --> 01:15:16.350
an x-range out of...

01:15:16.350 --> 01:15:17.730
The point is that there's
a certain

01:15:17.730 --> 01:15:20.180
point, a certain number.

01:15:25.870 --> 01:15:27.810
I don't know if it's going
to do that comfortably.

01:15:38.200 --> 01:15:40.890
So you see this little delay
that's occurring?

01:15:40.890 --> 01:15:43.410
Actually, this kind
of a long delay?

01:15:43.410 --> 01:15:45.910
It's actually hanging up
on this range command.

01:15:45.910 --> 01:15:49.220
Because it's actually
constructing this list object

01:15:49.220 --> 01:15:51.840
with all these integers in it.

01:15:51.840 --> 01:15:55.295
So, let's say I do this.

01:16:01.040 --> 01:16:03.290
Are you going to need to know
the exact difference?

01:16:03.290 --> 01:16:05.420
No.

01:16:05.420 --> 01:16:06.570
Is there a difference?

01:16:06.570 --> 01:16:08.790
Yes.

01:16:08.790 --> 01:16:11.120
Am I prepared to explain
it exactly, right now?

01:16:11.120 --> 01:16:13.510
Not really.

01:16:13.510 --> 01:16:17.750
Previous iterations of this
class have covered the yield

01:16:17.750 --> 01:16:22.750
statement in Python, which
allows you to create functions

01:16:22.750 --> 01:16:27.320
that create generator
objects that...

01:16:27.320 --> 01:16:28.391
You did yield?

01:16:28.391 --> 01:16:31.337
AUDIENCE: [INAUDIBLE]

01:16:31.337 --> 01:16:35.770
PROFESSOR: All right, then you
should know about this.

01:16:35.770 --> 01:16:39.010
So range is going to give
you a list of integers.

01:16:39.010 --> 01:16:41.700
x-range is going to give you a
generator object that uses

01:16:41.700 --> 01:16:43.930
yields to produce
these integers.

01:16:43.930 --> 01:16:50.205
So let me see if can
rescue my machine.

01:16:53.490 --> 01:16:54.740
All right.

01:17:25.330 --> 01:17:29.700
So, he covered something
like that with yield?

01:17:29.700 --> 01:17:35.710
So if I were to, say,
do i in my x-range--

01:17:42.240 --> 01:17:43.490
back to where I was.

01:17:47.030 --> 01:17:52.030
My x-range does the exact same
thing that x-range does.

01:17:52.030 --> 01:18:09.050
Now, as I said before, if I do
a list, or if I do range,

01:18:09.050 --> 01:18:10.660
that's going to be
a list, right?

01:18:10.660 --> 01:18:12.010
If I assign this to ...

01:18:27.240 --> 01:18:28.920
see that?

01:18:28.920 --> 01:18:30.605
That's what the yield statement
does for you.

01:18:30.605 --> 01:18:35.300
It produces that generator and
that's how x-range functions.

01:18:35.300 --> 01:18:40.580
So, basically it allows you to
do some interesting things.

01:18:40.580 --> 01:18:42.435
Like, in this case, it's not too
interesting because it's

01:18:42.435 --> 01:18:47.620
just returning one integer
after the other.

01:18:47.620 --> 01:18:49.445
But let's say that
I wanted to do --

01:18:53.330 --> 01:18:54.580
def my_squares.

01:19:16.920 --> 01:19:21.680
All that's going to do is return
these squares of all

01:19:21.680 --> 01:19:38.240
the numbers between 0 and max N.
So if I were to do this, it

01:19:38.240 --> 01:19:39.970
should print out all
the squares--

01:19:39.970 --> 01:19:42.810
or the square root of all the
numbers between 0 and 9.

01:19:46.380 --> 01:19:49.390
Make sense?

01:19:49.390 --> 01:19:51.860
So that's what yield gets you.

01:19:51.860 --> 01:19:55.200
Those are generator objects.

01:19:55.200 --> 01:19:56.720
And that's how x-range works.

01:19:56.720 --> 01:19:57.990
That's how it's different
than range.

01:20:02.020 --> 01:20:05.780
Does that make sense
to everyone?

01:20:05.780 --> 01:20:05.870
OK.

01:20:05.870 --> 01:20:08.398
I don't need to beat that
to death any longer?

01:20:11.180 --> 01:20:13.390
I was not expecting
that question.

01:20:13.390 --> 01:20:14.460
OK.

01:20:14.460 --> 01:20:17.265
What should we go over next?

01:20:17.265 --> 01:20:19.195
Is everyone comfortable
with orders of growth?

01:20:24.820 --> 01:20:25.390
All right.

01:20:25.390 --> 01:20:29.150
The next major topic area I
have is linguistic issues.

01:20:29.150 --> 01:20:32.250
So, this covers stuff like
exceptions, polymorphism,

01:20:32.250 --> 01:20:34.370
classes and objects.

01:20:34.370 --> 01:20:37.330
So people want to
go over classes?

01:20:37.330 --> 01:20:38.030
Objects?

01:20:38.030 --> 01:20:38.490
Polymorphism?

01:20:38.490 --> 01:20:40.450
OK.

01:20:40.450 --> 01:20:42.410
AUDIENCE: What's polymorphism?

01:20:42.410 --> 01:20:44.860
PROFESSOR: Yeah, we'll
get to that.

01:20:49.780 --> 01:20:52.467
So before my computer
crashed--

01:20:56.380 --> 01:20:57.880
all right.

01:20:57.880 --> 01:21:03.200
So here are some class
definitions.

01:21:03.200 --> 01:21:08.220
So I have a shape object, and
I've defined two methods, area

01:21:08.220 --> 01:21:10.570
and perimeter.

01:21:10.570 --> 01:21:13.790
They currently do nothing
except for raise not

01:21:13.790 --> 01:21:15.810
implemented errors.

01:21:15.810 --> 01:21:17.480
And now I have to find
a class hierarchy.

01:21:17.480 --> 01:21:21.610
I have a rectangle class that
inherits from shape.

01:21:21.610 --> 01:21:24.440
So shape is a superclass
of rectangle.

01:21:24.440 --> 01:21:27.250
Rectangle is a subclass
of shape.

01:21:27.250 --> 01:21:29.920
This also says--

01:21:29.920 --> 01:21:33.370
well, let me ask the question,
is shape a rectangle?

01:21:39.130 --> 01:21:42.680
It's not rhetorical.

01:21:42.680 --> 01:21:43.360
AUDIENCE: [INAUDIBLE]

01:21:43.360 --> 01:21:44.543
PROFESSOR: Not necessarily.

01:21:44.543 --> 01:21:46.808
Is rectangle a shape?

01:21:46.808 --> 01:21:47.261
AUDIENCE: Yes.

01:21:47.261 --> 01:21:48.620
PROFESSOR: OK.

01:21:48.620 --> 01:21:49.310
It's an easy question.

01:21:49.310 --> 01:21:52.500
It's not a trick question.

01:21:52.500 --> 01:21:55.020
In the rectangle class,
I have an INIT method.

01:21:55.020 --> 01:21:57.740
It just takes the length
and the width.

01:21:57.740 --> 01:21:59.880
So computing the area
is really easy.

01:21:59.880 --> 01:22:03.810
And then computing the perimeter
is also very easy.

01:22:03.810 --> 01:22:07.280
And now I have a string
representation which is just

01:22:07.280 --> 01:22:10.300
rectangle with the
length and width.

01:22:10.300 --> 01:22:15.570
Ellipse inherits from shape
and it has one radius--

01:22:15.570 --> 01:22:22.960
or one, the long axis
and the short axis.

01:22:22.960 --> 01:22:27.290
And computing the area for
that is pretty easy.

01:22:27.290 --> 01:22:29.860
Computing the perimeter, on the
other hand, I had to look

01:22:29.860 --> 01:22:30.780
it up online.

01:22:30.780 --> 01:22:34.510
So if you're interested in the
formula I used go take a look

01:22:34.510 --> 01:22:36.695
at this website.

01:22:42.050 --> 01:22:43.870
Again, I have a string method.

01:22:43.870 --> 01:22:48.030
And then now we have a square
which inherits from rectangle.

01:22:48.030 --> 01:22:51.690
Because square is just a special
case of a rectangle.

01:22:51.690 --> 01:22:54.270
And so I'm going to reuse it.

01:22:54.270 --> 01:23:00.210
I'm just going to make both
lengths the same.

01:23:00.210 --> 01:23:03.470
That make sense to everyone?

01:23:03.470 --> 01:23:05.880
And I don't need to override the
area and perimeter because

01:23:05.880 --> 01:23:07.315
they're pretty easy
to understand.

01:23:07.315 --> 01:23:10.710
Or they're the same.

01:23:10.710 --> 01:23:11.850
And then circle.

01:23:11.850 --> 01:23:13.870
It just inherits from ellipse,
and same thing.

01:23:13.870 --> 01:23:16.655
I'm just going to reuse the
stuff that I have in ellipse.

01:23:21.750 --> 01:23:24.060
All right.

01:23:24.060 --> 01:23:26.350
I've defined a bag
of shapes here.

01:23:26.350 --> 01:23:28.690
Circles, squares, rectangles.

01:23:28.690 --> 01:23:29.805
Rectangles.

01:23:29.805 --> 01:23:32.560
Lots of stuff.

01:23:32.560 --> 01:23:36.170
Now, to answer your question,
what polymorphism allows me to

01:23:36.170 --> 01:23:44.870
do is, it allows me to treat
subclasses that share a

01:23:44.870 --> 01:23:49.460
particular superclass, or a
parent class, the same.

01:23:49.460 --> 01:23:56.100
So I've defined an area method
on the shape class.

01:23:56.100 --> 01:23:59.350
And all of my subclasses,
rectangle, ellipse, circle and

01:23:59.350 --> 01:24:03.640
square, inherit from
this superclass.

01:24:03.640 --> 01:24:06.420
And some of them override area,
some of them don't.

01:24:06.420 --> 01:24:09.750
It doesn't really
matter to me.

01:24:09.750 --> 01:24:13.360
What matters to me is that if I
have a bag of these shapes,

01:24:13.360 --> 01:24:16.030
I know that I have
an area method.

01:24:16.030 --> 01:24:20.530
And I don't need to know the
particular or the type of the

01:24:20.530 --> 01:24:25.740
object that I'm calling
the area method on.

01:24:25.740 --> 01:24:27.300
Right?

01:24:27.300 --> 01:24:29.810
Python is going to take
care of that for me.

01:24:29.810 --> 01:24:34.200
I can just iterate through this
bag of shapes, call the

01:24:34.200 --> 01:24:36.490
area method, and I can get
a sum of the areas.

01:24:39.320 --> 01:24:41.700
That's what polymorphism gives
to me, is it allows me to

01:24:41.700 --> 01:24:44.820
treat objects uniformly.

01:24:44.820 --> 01:24:49.060
It allows the objects to change
their behavior based on

01:24:49.060 --> 01:24:51.510
the particular type of object
that I'm using.

01:24:51.510 --> 01:24:54.700
But I don't need to know
the particular details.

01:24:54.700 --> 01:24:56.420
So it's pretty powerful.

01:24:56.420 --> 01:25:01.490
So it's like, if I were to
create a racing game and I

01:25:01.490 --> 01:25:04.940
wanted to drive a car, I could
have different models of car.

01:25:04.940 --> 01:25:09.850
But my game engine wouldn't need
to know to drive method

01:25:09.850 --> 01:25:10.680
to call for.

01:25:10.680 --> 01:25:16.320
Like, a Ford car versus a
Chevrolet, all that stuff.

01:25:20.810 --> 01:25:22.400
That kind of answer
your question?

01:25:22.400 --> 01:25:23.650
AUDIENCE: Yeah.

01:25:26.181 --> 01:25:32.690
AUDIENCE: So if there's not an
area function that overrides

01:25:32.690 --> 01:25:35.490
it, what is it going to sum
if it just raises a

01:25:35.490 --> 01:25:36.740
non-implemented error?

01:25:39.770 --> 01:25:41.570
Yeah, if you haven't
redefined.

01:25:41.570 --> 01:25:46.190
PROFESSOR: In this example, I'm
using all what are known

01:25:46.190 --> 01:25:47.072
as concrete classes.

01:25:47.072 --> 01:25:49.350
So they're not abstract.

01:25:49.350 --> 01:25:53.220
They all have implementations
of area.

01:25:53.220 --> 01:25:57.710
But if I were to say, for some
reason I decided that I wanted

01:25:57.710 --> 01:26:00.765
to make something amorphous.

01:26:04.080 --> 01:26:05.800
This should raise
an error, right?

01:26:08.560 --> 01:26:10.146
Unless I have invalid syntax.

01:26:18.660 --> 01:26:19.910
So when it gets to
there, yeah.

01:26:25.326 --> 01:26:26.764
Any other questions?

01:26:26.764 --> 01:26:29.184
AUDIENCE: So what's the
difference between inheritance

01:26:29.184 --> 01:26:30.434
and [UNINTELLIGIBLE]?

01:26:33.540 --> 01:26:34.950
PROFESSOR: They're related.

01:26:34.950 --> 01:26:41.040
But what inheritance means is
that if I say that rectangle

01:26:41.040 --> 01:26:44.720
inherits from shape, that
means it gets all of its

01:26:44.720 --> 01:26:48.520
methods and attributes.

01:26:48.520 --> 01:26:52.820
But it's not necessarily
polymorphic in that case.

01:26:52.820 --> 01:26:58.490
It's just, it's like saying a
rectangle is a shape so it has

01:26:58.490 --> 01:27:02.420
all these characteristics of
a shape and then some.

01:27:02.420 --> 01:27:06.200
The polymorphism comes in when I
override the area method and

01:27:06.200 --> 01:27:09.870
then I can treat all shapes,
whether they're rectangles,

01:27:09.870 --> 01:27:14.375
squares, circles, uniformly
with the area method.

01:27:19.180 --> 01:27:20.500
You might--

01:27:20.500 --> 01:27:24.470
I'm trying to think of an
example where it would be.

01:27:24.470 --> 01:27:31.330
So let's say that I didn't do
this in a class or entered a

01:27:31.330 --> 01:27:32.760
way or using classes.

01:27:32.760 --> 01:27:46.970
And so I had a really naive
implementation that said,

01:27:46.970 --> 01:27:48.950
let's represent them
as dictionaries.

01:28:19.660 --> 01:28:21.810
So I have two really stupid
functions here.

01:28:21.810 --> 01:28:25.050
And they say they make a circle
and they make a square.

01:28:25.050 --> 01:28:27.810
And so really all it's doing
is representing these as

01:28:27.810 --> 01:28:28.730
dictionaries.

01:28:28.730 --> 01:28:31.510
And the key is side
and radius.

01:28:31.510 --> 01:28:34.880
Now, let's say that I want to
have my list of shapes.

01:28:39.310 --> 01:28:40.490
I make a square.

01:28:40.490 --> 01:28:41.740
I'm going to make a circle.

01:28:46.830 --> 01:28:49.060
Another square.

01:28:49.060 --> 01:28:51.980
OK, so now I've got a bag or
shapes or a list of shapes.

01:28:51.980 --> 01:28:52.870
What's that?

01:28:52.870 --> 01:28:56.181
AUDIENCE: Can you [INAUDIBLE]?

01:28:56.181 --> 01:28:57.600
PROFESSOR: Spending too
much time on that one.

01:29:01.400 --> 01:29:02.190
All right.

01:29:02.190 --> 01:29:04.280
So if I were to take
a look at this.

01:29:16.770 --> 01:29:18.500
It's going to print out a
bunch of dictionaries.

01:29:18.500 --> 01:29:24.090
Now, the question is, what if I
wanted to compute the areas

01:29:24.090 --> 01:29:25.340
of these data types?

01:29:28.820 --> 01:29:33.780
Using polymorphism, I can just
call dot area on each shape.

01:29:33.780 --> 01:29:37.180
But if I wanted to do the same
thing with this code, I would

01:29:37.180 --> 01:29:45.606
have to have square area
s, return, d, side.

01:29:52.620 --> 01:30:03.080
And then def circle, area,
c, return, 3.14.

01:30:03.080 --> 01:30:05.320
9 times c--

01:30:10.460 --> 01:30:11.920
I'm already getting
tripped up.

01:30:17.310 --> 01:30:21.830
So even this is not so bad,
because if I do something like

01:30:21.830 --> 01:30:27.190
this, I can still get
the areas, right?

01:30:39.505 --> 01:30:42.600
And I can do this because I know
what's in those positions

01:30:42.600 --> 01:30:43.920
in the list.

01:30:43.920 --> 01:30:45.314
So.

01:30:45.314 --> 01:30:47.202
AUDIENCE: You forgot to close
your parentheses.

01:30:47.202 --> 01:30:48.452
PROFESSOR: Oh.

01:30:52.880 --> 01:30:53.390
OK.

01:30:53.390 --> 01:30:54.970
So it's going to work.

01:30:54.970 --> 01:30:58.465
But now, if I want to print out
all the areas of all the

01:30:58.465 --> 01:31:02.760
shapes in this loop here, how
am I going to do that?

01:31:02.760 --> 01:31:10.776
Because I can't just call square
area of s, because what

01:31:10.776 --> 01:31:17.280
if s is a circle It's going to
give me an error, right?

01:31:17.280 --> 01:31:25.050
I could get around this by
saying, if radius in s, then I

01:31:25.050 --> 01:31:26.300
know it's a circle, right?

01:31:34.170 --> 01:31:36.885
Or, side in s.

01:31:41.000 --> 01:31:45.660
But you see how the code is
getting kind of ugly now?

01:31:45.660 --> 01:31:50.550
I have to know details about
how these different objects

01:31:50.550 --> 01:31:53.650
are implemented, how square and
circle are implemented in

01:31:53.650 --> 01:31:54.990
the dictionary.

01:31:54.990 --> 01:31:58.590
I have to know what type
they are before I

01:31:58.590 --> 01:32:00.900
compute their area.

01:32:00.900 --> 01:32:06.540
And I can do it, but
it's kind of ugly.

01:32:06.540 --> 01:32:15.190
Whereas if I invest a little
bit of time in a class

01:32:15.190 --> 01:32:19.690
hierarchy, I can do this
much more easily.

01:32:19.690 --> 01:32:21.240
Much more cleanly.

01:32:21.240 --> 01:32:27.520
It's a way of abstracting
from the problem.

01:32:27.520 --> 01:32:28.870
You don't have to worry
about the details of

01:32:28.870 --> 01:32:31.760
the individual shapes.

01:32:31.760 --> 01:32:34.060
Did I kill that?

01:32:34.060 --> 01:32:35.150
And beat it into the ground.

01:32:35.150 --> 01:32:36.641
AUDIENCE: Just for
clarification.

01:32:36.641 --> 01:32:39.623
So the point of polymorphism
is just like inheritance,

01:32:39.623 --> 01:32:42.680
essentially, kind
of boiled down?

01:32:42.680 --> 01:32:45.368
PROFESSOR: The point of
polymorphism is that if you

01:32:45.368 --> 01:32:49.220
have a class hierarchy of
objects, you don't need to

01:32:49.220 --> 01:32:54.460
know the details of the objects,
of what specific type

01:32:54.460 --> 01:32:55.080
an object is.

01:32:55.080 --> 01:32:57.610
As long as you know that
in the case of--

01:32:57.610 --> 01:32:59.649
AUDIENCE: So long as there
exists a method

01:32:59.649 --> 01:33:00.510
that you want to use.

01:33:00.510 --> 01:33:00.988
PROFESSOR: Right.

01:33:00.988 --> 01:33:02.900
AUDIENCE: Where it inherits
from that class,

01:33:02.900 --> 01:33:04.334
you could use it.

01:33:04.334 --> 01:33:05.290
PROFESSOR: Yeah.

01:33:05.290 --> 01:33:10.135
So in this particular example,
shape has an area method.

01:33:10.135 --> 01:33:15.150
And I have a bunch of concrete
subclasses of shape that have

01:33:15.150 --> 01:33:16.620
all overridden the
area method.

01:33:16.620 --> 01:33:19.090
And they do it in
different ways.

01:33:19.090 --> 01:33:22.110
You compute the area differently
for a rectangle

01:33:22.110 --> 01:33:23.790
versus an ellipse.

01:33:23.790 --> 01:33:26.820
I don't have to worry about
which particular shape it is.

01:33:26.820 --> 01:33:30.520
I just call the area method, and
I don't have to do all the

01:33:30.520 --> 01:33:33.070
checking that I do here.

01:33:33.070 --> 01:33:37.590
Where I look at, is this a
circle, is this a square.

01:33:37.590 --> 01:33:39.286
I don't know, so I'm not
going to compute that.

01:33:39.286 --> 01:33:41.726
AUDIENCE: How do you
avoid the checking?

01:33:41.726 --> 01:33:43.190
[INAUDIBLE]

01:33:43.190 --> 01:33:45.060
PROFESSOR: So--

01:33:45.060 --> 01:33:46.310
AUDIENCE: [INAUDIBLE]

01:33:50.020 --> 01:33:50.310
PROFESSOR: See?

01:33:50.310 --> 01:33:51.762
AUDIENCE: Oh, OK, Great.

01:33:51.762 --> 01:33:54.666
Yeah.

01:33:54.666 --> 01:33:57.570
PROFESSOR: [INAUDIBLE]

01:33:57.570 --> 01:33:59.030
Anyone lost?

01:33:59.030 --> 01:34:02.560
Any other questions?

01:34:02.560 --> 01:34:06.660
So that actually touched
on a couple of topics.

01:34:06.660 --> 01:34:10.630
So we saw exceptions here.

01:34:10.630 --> 01:34:12.480
Is there anyone who wants
to see anything else on

01:34:12.480 --> 01:34:14.256
exceptions?

01:34:14.256 --> 01:34:15.750
AUDIENCE: What's the difference

01:34:15.750 --> 01:34:17.820
between pass and continue?

01:34:17.820 --> 01:34:19.820
PROFESSOR: Pass and continue?

01:34:19.820 --> 01:34:21.070
OK.

01:34:25.290 --> 01:34:29.717
So the question is what's
the difference

01:34:29.717 --> 01:34:30.420
between pass and continue.

01:34:30.420 --> 01:34:34.370
So when you have pass, this is
basically a null command.

01:34:34.370 --> 01:34:35.710
It's a do nothing command.

01:34:35.710 --> 01:34:38.220
I can actually run this
code right now.

01:34:38.220 --> 01:34:42.240
And it will do absolutely
nothing useful.

01:34:42.240 --> 01:34:43.490
But it also won't complain.

01:34:49.190 --> 01:34:51.180
It's a placeholder.

01:34:51.180 --> 01:34:52.340
Sometimes--

01:34:52.340 --> 01:34:54.510
so a lot of times you'll
see in your code

01:34:54.510 --> 01:34:57.040
something like this.

01:34:57.040 --> 01:35:02.320
Let's x equals 150.

01:35:02.320 --> 01:35:14.165
If x mod 2 equals 0, pass else,
do something useful.

01:35:17.580 --> 01:35:20.750
So we see this a lot
in your p-sets.

01:35:20.750 --> 01:35:22.100
It's not a slam on
you or anything.

01:35:22.100 --> 01:35:24.025
But you could simplify
this by saying--

01:35:32.880 --> 01:35:34.950
but the way that you
conceptualize a problem forced

01:35:34.950 --> 01:35:37.950
you to have this if statement.

01:35:37.950 --> 01:35:40.000
And then you didn't have
anything useful to put in

01:35:40.000 --> 01:35:42.580
here, so you had to put
a pass in order to

01:35:42.580 --> 01:35:45.260
make Python not complain.

01:35:45.260 --> 01:35:52.500
So, let's be a little less
flip and more concrete.

01:35:52.500 --> 01:35:53.885
It's getting late, I'm
getting punchy.

01:35:59.060 --> 01:35:59.370
All right.

01:35:59.370 --> 01:36:03.100
So if I were to run this now,
it's not going to print

01:36:03.100 --> 01:36:04.630
anything because it hit
the pass command.

01:36:07.390 --> 01:36:10.140
Now let's make this on.

01:36:10.140 --> 01:36:12.400
So if we've verified that this
code works and that I'm not

01:36:12.400 --> 01:36:13.510
blowing smoke.

01:36:13.510 --> 01:36:19.000
Now, let's take out the pass.

01:36:19.000 --> 01:36:20.490
Python's going to complain.

01:36:20.490 --> 01:36:22.160
Why?

01:36:22.160 --> 01:36:26.900
Because after this if
line, here it's

01:36:26.900 --> 01:36:28.500
expecting a block of code.

01:36:28.500 --> 01:36:31.790
But there's nothing there.

01:36:31.790 --> 01:36:34.490
The pass keyword give you
a do nothing command.

01:36:34.490 --> 01:36:38.650
It says, I don't really have
anything to say here, but you

01:36:38.650 --> 01:36:40.480
want me to put something
here so I'm going to

01:36:40.480 --> 01:36:41.650
put something here.

01:36:41.650 --> 01:36:44.870
But it doesn't do anything.

01:36:44.870 --> 01:36:48.770
So that's pass.

01:36:48.770 --> 01:36:53.160
so It's a placeholder,
is the basic answer.

01:36:53.160 --> 01:36:54.870
Now, continue is different.

01:36:54.870 --> 01:36:57.660
Because continue actually has
a function that is useful.

01:37:01.740 --> 01:37:04.860
Let's say that I'm not too
familiar with the range

01:37:04.860 --> 01:37:07.700
command, and I don't know that
I can specify a step.

01:37:07.700 --> 01:37:11.550
And I want to print out
all the odd integers.

01:37:11.550 --> 01:37:15.960
And I also am going to restrict
myself and say that I

01:37:15.960 --> 01:37:22.140
can't use an else or something
of that nature.

01:37:22.140 --> 01:37:23.460
So I'm going to handicap
myself.

01:37:29.620 --> 01:37:31.290
This x-range --

01:37:31.290 --> 01:37:34.240
is x-range cool?

01:37:34.240 --> 01:37:35.980
So.

01:37:35.980 --> 01:37:37.390
I only want to print
out odd numbers.

01:37:51.860 --> 01:37:53.160
Or we can do it like this.

01:37:53.160 --> 01:37:55.600
Either/or, it doesn't matter.

01:37:55.600 --> 01:37:58.696
So, comment this.

01:37:58.696 --> 01:38:03.430
What continue does is it, if
you're within a loop, as we

01:38:03.430 --> 01:38:07.060
are here with this for loop,
tells Python if it sees a

01:38:07.060 --> 01:38:10.400
continue statement, do not
continue beyond this point

01:38:10.400 --> 01:38:12.400
within the block of the loop.

01:38:12.400 --> 01:38:16.420
Go instead and perform the next
iteration of this loop.

01:38:16.420 --> 01:38:19.320
Go to the top of this loop.

01:38:19.320 --> 01:38:24.020
So, what this code should do,
I'm hoping, in case I don't--

01:38:24.020 --> 01:38:26.230
I might have a bug--

01:38:26.230 --> 01:38:27.635
it should print out
the odd integers.

01:38:32.900 --> 01:38:38.290
So what's happening is that when
the integer is even, it's

01:38:38.290 --> 01:38:41.660
hitting this continue
statement.

01:38:41.660 --> 01:38:44.850
And this is telling Python, go
back up to the top of this for

01:38:44.850 --> 01:38:48.538
loop and do the next
iteration.

01:38:48.538 --> 01:38:53.478
AUDIENCE: If you were to
have [UNINTELLIGIBLE]?

01:38:53.478 --> 01:38:55.454
PROFESSOR: So if I
just had pass?

01:38:55.454 --> 01:38:57.430
It'll print all the integers.

01:39:00.888 --> 01:39:02.138
That work?

01:39:05.334 --> 01:39:06.816
Anyone confused?

01:39:06.816 --> 01:39:09.944
AUDIENCE: You could also have
your code if not that

01:39:09.944 --> 01:39:12.250
[UNINTELLIGIBLE].

01:39:12.250 --> 01:39:13.500
PROFESSOR: Yeah, but
[INAUDIBLE].

01:39:18.425 --> 01:39:21.820
There are some schools of
thought that say that continue

01:39:21.820 --> 01:39:24.630
is something that disturbs
the flow of code

01:39:24.630 --> 01:39:28.960
and should be avoided.

01:39:28.960 --> 01:39:30.140
I don't subscribe to that.

01:39:30.140 --> 01:39:34.890
I think that if it makes your
code clearer, then use it.

01:39:34.890 --> 01:39:37.480
Which is to say that, yeah, you
can rewrite a lot of your

01:39:37.480 --> 01:39:39.090
code to not use continue.

01:39:39.090 --> 01:39:41.120
OK, do we need to
go over anything

01:39:41.120 --> 01:39:42.630
with linguistic issues?

01:39:42.630 --> 01:39:45.282
Are we good on classes?

01:39:45.282 --> 01:39:48.440
AUDIENCE: Can we go over
exceptions, please?

01:39:48.440 --> 01:39:50.810
PROFESSOR: So there is a
question on exceptions.

01:39:50.810 --> 01:39:55.420
So exceptions are another
way of flow control.

01:39:55.420 --> 01:39:59.610
And if I can pull up my source
file, I have an example of

01:39:59.610 --> 01:40:00.860
handling exceptions.

01:40:05.860 --> 01:40:07.276
There we go.

01:40:10.000 --> 01:40:12.780
Exceptions give you
a way of handling

01:40:12.780 --> 01:40:15.250
certain errors that occur.

01:40:15.250 --> 01:40:19.570
So, the easiest one to come
up with is division by 0.

01:40:19.570 --> 01:40:23.400
So normally, if you would
do a division by 0 --

01:40:31.910 --> 01:40:34.660
so I'm going trying
to divide 10 by 0.

01:40:34.660 --> 01:40:40.180
The universe won't end, but
Python will be very unhappy.

01:40:40.180 --> 01:40:43.570
In programs that are more
complex that the ones that

01:40:43.570 --> 01:40:47.750
we've been writing, division
by 0 happens but you don't

01:40:47.750 --> 01:40:50.610
necessarily want the program
to crash, right?

01:40:50.610 --> 01:40:53.460
You want to be able to handle
that error in a

01:40:53.460 --> 01:40:55.210
semi-graceful way.

01:40:55.210 --> 01:41:00.920
And in this particular example,
with a division by 0,

01:41:00.920 --> 01:41:03.090
we can do that with
exceptions.

01:41:03.090 --> 01:41:07.490
So let's say that instead of the
program crashing I want to

01:41:07.490 --> 01:41:10.990
print out a nicer error message
rather than everything

01:41:10.990 --> 01:41:12.060
in big red.

01:41:12.060 --> 01:41:14.645
I say, well, you divided by 0
so maybe you should change

01:41:14.645 --> 01:41:15.895
your numbers.

01:41:18.020 --> 01:41:23.030
The way I capture, or catch this
exception, is I have a

01:41:23.030 --> 01:41:27.080
tribe keyword, a colon,
and then I have

01:41:27.080 --> 01:41:28.380
this block of code.

01:41:28.380 --> 01:41:31.800
This is the code that could
potentially raise an exception

01:41:31.800 --> 01:41:34.030
where the error might occur.

01:41:34.030 --> 01:41:38.990
This code could be-- in this
case, it's just straight up

01:41:38.990 --> 01:41:41.100
assignment and division.

01:41:41.100 --> 01:41:44.140
It could be a function that
raises the exception.

01:41:44.140 --> 01:41:45.270
It doesn't matter.

01:41:45.270 --> 01:41:47.760
The point is that there's an
exception that might occur.

01:41:47.760 --> 01:41:51.850
If an exception occurs, then
Python is going to look past

01:41:51.850 --> 01:41:56.780
this block of code here at
these except statements.

01:41:56.780 --> 01:41:59.300
And it's going to look at the
type of exception it has.

01:41:59.300 --> 01:42:03.680
In this case it's a by 0
division error, and it's going

01:42:03.680 --> 01:42:06.880
to match the exception against
whatever type this is.

01:42:06.880 --> 01:42:10.870
And you can put inside here
whatever code you want in

01:42:10.870 --> 01:42:12.980
order to handle this
exception.

01:42:12.980 --> 01:42:17.160
So in this case I'm just
printing divided by 0.

01:42:17.160 --> 01:42:21.450
I could be rude and
I could say--

01:42:28.610 --> 01:42:31.410
see, can't even spell.

01:42:31.410 --> 01:42:34.180
So I can handle this exception
however I want.

01:42:34.180 --> 01:42:37.990
But the program's not
going to crash.

01:42:37.990 --> 01:42:40.910
And this program's actually not
going to really convince

01:42:40.910 --> 01:42:46.060
you of that, but you see that--
the first thing you see

01:42:46.060 --> 01:42:49.320
here is that there's no big red
blaring message that says

01:42:49.320 --> 01:42:50.480
you have an exception.

01:42:50.480 --> 01:42:53.080
It's all code that
I've written.

01:42:53.080 --> 01:42:55.030
And I could even be
silent about it.

01:42:55.030 --> 01:42:56.530
I could say, I'm not going
to say anything.

01:42:56.530 --> 01:42:57.780
I'm just going to
fail silently.

01:43:01.550 --> 01:43:03.520
Tell me it's all good.

01:43:03.520 --> 01:43:04.810
It's not going to tell
me I divided by 0.

01:43:08.100 --> 01:43:10.610
It can come in handy if I
like have an input loop.

01:43:10.610 --> 01:43:14.540
So let's say I'm going to do a
little bit more, be a little

01:43:14.540 --> 01:43:17.900
bit more creative and do--

01:43:17.900 --> 01:43:20.444
oh.

01:43:20.444 --> 01:43:22.165
AUDIENCE: [INAUDIBLE]

01:43:22.165 --> 01:43:24.511
How does it [INAUDIBLE]?

01:43:24.511 --> 01:43:27.710
PROFESSOR: That's an internal
Python thing.

01:43:27.710 --> 01:43:32.760
So if you want to learn about
all the wonderful exceptions

01:43:32.760 --> 01:43:36.806
that Python provides you in its
class library, you can go

01:43:36.806 --> 01:43:39.821
to the Python documentation.

01:43:39.821 --> 01:43:44.155
Or you can even do
a Google search.

01:43:53.184 --> 01:43:56.887
Of course, Chrome is being very
slow, and the network's

01:43:56.887 --> 01:43:57.550
probably down.

01:43:57.550 --> 01:43:58.800
So built-in exceptions.

01:44:01.110 --> 01:44:03.482
So these are all the exceptions
that Python has.

01:44:07.590 --> 01:44:09.520
And you can use these too.

01:44:09.520 --> 01:44:14.790
Let's say that, let me get back
to my contrived example.

01:44:14.790 --> 01:44:18.140
I want to create a
loop that says--

01:44:48.920 --> 01:44:55.470
let's say that I want to catch,
I don't want to divide

01:44:55.470 --> 01:44:56.880
even numbers for some reason.

01:45:05.600 --> 01:45:06.740
What do we have here?

01:45:06.740 --> 01:45:08.680
What can we find?

01:45:08.680 --> 01:45:09.930
I think there's a value error.

01:45:14.030 --> 01:45:16.380
There we go.

01:45:16.380 --> 01:45:18.145
So let's say that I'm going
to raise a value error.

01:45:23.590 --> 01:45:33.010
And I am actually going
to do this this way.

01:45:51.410 --> 01:45:53.595
So I've created a function
that's not going to allow me

01:45:53.595 --> 01:45:56.260
to input even numbers.

01:45:56.260 --> 01:45:59.260
It's going to raise a value
error if I enter in a 2 or a 4

01:45:59.260 --> 01:46:00.090
or whatever.

01:46:00.090 --> 01:46:03.420
But, if I do enter in an odd
number it is just going to

01:46:03.420 --> 01:46:04.820
return that number to me.

01:46:04.820 --> 01:46:06.890
So I'm going to use
that function now.

01:46:14.930 --> 01:46:22.320
And I'm just going to do the
silly thing and divide, do a

01:46:22.320 --> 01:46:25.200
division, and print it out.

01:46:25.200 --> 01:46:28.750
So if I comment out this code
up here and I comment this

01:46:28.750 --> 01:46:33.800
out, and I run this, so--

01:46:33.800 --> 01:46:36.750
let's do 3.

01:46:36.750 --> 01:46:38.000
That's interesting.

01:46:43.090 --> 01:46:45.849
Apparently Python is a little
constipated right now.

01:46:50.740 --> 01:46:54.030
We edit this during the summer,
so we can take that

01:46:54.030 --> 01:46:55.280
out, I think.

01:46:58.670 --> 01:46:59.060
All right.

01:46:59.060 --> 01:47:00.750
So it does what we
expected it to.

01:47:00.750 --> 01:47:03.120
It's going to keep on prompting
us for numbers and

01:47:03.120 --> 01:47:06.580
it's going to divide them for
us and give us the answers.

01:47:06.580 --> 01:47:09.390
So we've got a really dumb
calculator here.

01:47:09.390 --> 01:47:12.430
Except when I try to do even
numbers, because my calculator

01:47:12.430 --> 01:47:14.590
is really, really dumb.

01:47:14.590 --> 01:47:16.810
So it's going to raise
a value error.

01:47:16.810 --> 01:47:20.470
And it raises the value error
in this function here.

01:47:20.470 --> 01:47:22.930
I can handle this, though,
because I know how.

01:47:27.000 --> 01:47:31.070
So what should I type here?

01:47:31.070 --> 01:47:32.320
OK.

01:47:35.226 --> 01:47:37.178
AUDIENCE: If you wanted to
specifically catch that error.

01:47:37.178 --> 01:47:38.886
But you could just leave
it as except, and it

01:47:38.886 --> 01:47:39.618
would catch any error?

01:47:39.618 --> 01:47:41.570
PROFESSOR: Yes.

01:47:41.570 --> 01:47:42.546
[INAUDIBLE].

01:47:42.546 --> 01:47:44.010
AUDIENCE: So if any error
were to be thrown, then

01:47:44.010 --> 01:47:44.498
[INAUDIBLE].

01:47:44.498 --> 01:47:47.914
But if you wanted specifically
to say, OK, the value error

01:47:47.914 --> 01:47:50.360
[UNINTELLIGIBLE].

01:47:50.360 --> 01:47:51.830
PROFESSOR: Right.

01:47:51.830 --> 01:47:55.900
So what she was saying is
that I could do this.

01:47:55.900 --> 01:47:58.396
I don't have to specify what
error I'm expecting.

01:47:58.396 --> 01:47:59.794
I could say--

01:48:03.990 --> 01:48:05.450
But it's not going
to give me any

01:48:05.450 --> 01:48:07.030
detail about what happened.

01:48:10.120 --> 01:48:16.190
And what I'm going to do is,
I'm going to say that if I

01:48:16.190 --> 01:48:19.170
have an exception then I'm
just going to repeat my

01:48:19.170 --> 01:48:21.820
getting of the numbers.

01:48:21.820 --> 01:48:26.570
So, let's say that I do this.

01:48:26.570 --> 01:48:30.300
Something happened, not
really specific.

01:48:30.300 --> 01:48:33.140
Nothing happened?

01:48:33.140 --> 01:48:35.556
OK, I divided all right.

01:48:35.556 --> 01:48:37.510
AUDIENCE: What if you put
in [UNINTELLIGIBLE]?

01:48:37.510 --> 01:48:38.357
PROFESSOR: What's that?

01:48:38.357 --> 01:48:39.351
AUDIENCE: [INAUDIBLE]

01:48:39.351 --> 01:48:42.830
Would it also come back in
case something happened?

01:48:42.830 --> 01:48:43.028
PROFESSOR: Yeah.

01:48:43.028 --> 01:48:45.315
That's a good question.

01:48:45.315 --> 01:48:48.794
Something happened, but
we don't know what.

01:48:48.794 --> 01:48:51.590
We know we have a bug, because
an exception was thrwn.

01:48:51.590 --> 01:48:52.510
But we don't know what it is.

01:48:52.510 --> 01:48:53.003
AUDIENCE: Because it's
never going to crash.

01:48:53.003 --> 01:48:53.496
PROFESSOR: Yeah.

01:48:53.496 --> 01:48:55.468
It's never going to crash.

01:48:55.468 --> 01:48:59.905
AUDIENCE: So a useful example
of when to use this, would

01:48:59.905 --> 01:49:07.793
that be like [INAUDIBLE], and
you have the list to choose

01:49:07.793 --> 01:49:09.765
from the letters [INAUDIBLE]
it would

01:49:09.765 --> 01:49:11.737
remove each of the guesses?

01:49:11.737 --> 01:49:13.955
If you accidentally guess
something that

01:49:13.955 --> 01:49:14.695
you've already guessed?

01:49:14.695 --> 01:49:16.568
PROFESSOR: Yeah, you can raise
an exception to say, already

01:49:16.568 --> 01:49:17.160
guessed this.

01:49:17.160 --> 01:49:19.132
AUDIENCE: As opposed to the
program, that first one I ran,

01:49:19.132 --> 01:49:21.843
I accidentally did the same
letter again, and the whole

01:49:21.843 --> 01:49:22.583
program just crashed.

01:49:22.583 --> 01:49:23.569
PROFESSOR: Yep.

01:49:23.569 --> 01:49:26.034
AUDIENCE: So you can raise an
exception for whoever's

01:49:26.034 --> 01:49:27.050
[INAUDIBLE].

01:49:27.050 --> 01:49:27.520
PROFESSOR: Yeah.

01:49:27.520 --> 01:49:30.840
You can catch any errors
that were raised.

01:49:30.840 --> 01:49:32.740
So we've got a couple
of exceptions

01:49:32.740 --> 01:49:33.056
that are raised here.

01:49:33.056 --> 01:49:35.590
And actually this program
can crash.

01:49:35.590 --> 01:49:36.315
Oh, wait.

01:49:36.315 --> 01:49:37.097
No, it can't.

01:49:37.097 --> 01:49:37.864
Because [INAUDIBLE].

01:49:37.864 --> 01:49:39.620
It thinks [INAUDIBLE].

01:49:39.620 --> 01:49:41.680
Silly Python.

01:49:41.680 --> 01:49:47.320
So it's not going
to crash at all.

01:49:47.320 --> 01:49:49.950
We did a really good
job, right?

01:49:49.950 --> 01:49:52.630
So now we want to get a little
bit more specific so I'm going

01:49:52.630 --> 01:49:54.710
to catch a value error.

01:49:54.710 --> 01:49:59.220
So I'm only going to handle this
one type of exception.

01:49:59.220 --> 01:50:00.390
Because--

01:50:00.390 --> 01:50:03.860
so it still works.

01:50:03.860 --> 01:50:05.200
A, something happened.

01:50:05.200 --> 01:50:10.450
But now we know that it's
because I did something silly.

01:50:10.450 --> 01:50:14.970
And, now I can break the program
because this keyboard

01:50:14.970 --> 01:50:16.880
interrupt, that's actually
an exception.

01:50:16.880 --> 01:50:20.060
When you hit Control-C,
it's going to break

01:50:20.060 --> 01:50:20.630
you out of the program.

01:50:20.630 --> 01:50:22.210
But because we're catching
that exception

01:50:22.210 --> 01:50:23.462
it just kept going.

01:50:23.462 --> 01:50:24.938
AUDIENCE: [INAUDIBLE]

01:50:24.938 --> 01:50:27.398
make an exception [INAUDIBLE].

01:50:27.398 --> 01:50:28.874
PROFESSOR: Yes.

01:50:28.874 --> 01:50:30.124
AUDIENCE: [INAUDIBLE]

01:50:35.762 --> 01:50:37.012
AUDIENCE: [INAUDIBLE]

01:50:45.110 --> 01:50:46.586
AUDIENCE: Wait, what?

01:50:46.586 --> 01:50:48.600
[INTERPOSING VOICES]

01:50:48.600 --> 01:50:52.705
PROFESSOR: I'm quoting the
girls over there, so.

01:50:52.705 --> 01:50:53.955
AUDIENCE: Are you?

01:50:57.655 --> 01:50:59.640
PROFESSOR: Uh-oh.

01:50:59.640 --> 01:51:01.630
So something happened.

01:51:01.630 --> 01:51:03.540
Oh, wow.

01:51:03.540 --> 01:51:05.865
How did that happen?

01:51:05.865 --> 01:51:08.190
Oh, I know how that happened.

01:51:08.190 --> 01:51:09.440
What am I missing here?

01:51:12.010 --> 01:51:14.134
So I caught the keyboard
interrupt, right?

01:51:17.100 --> 01:51:18.250
I didn't go to the
top of the loop.

01:51:18.250 --> 01:51:21.470
So what happened is, it tried
to execute this, but num2

01:51:21.470 --> 01:51:23.530
hadn't been defined.

01:51:23.530 --> 01:51:27.255
So we're going to kick
me back up to the

01:51:27.255 --> 01:51:28.505
top of the loop here.

01:51:31.375 --> 01:51:32.830
AUDIENCE: Oh.

01:51:32.830 --> 01:51:34.770
It's a clingy program.

01:51:34.770 --> 01:51:38.180
[LAUGHTER]

01:51:38.180 --> 01:51:39.050
PROFESSOR: Yes.

01:51:39.050 --> 01:51:40.300
It is a clingy program.

01:51:42.980 --> 01:51:43.310
Anyway.

01:51:43.310 --> 01:51:47.890
So, does everyone get the idea
of what the exceptions are?

01:51:47.890 --> 01:51:52.704
So I don't have to
go any more?

01:51:52.704 --> 01:51:54.870
AUDIENCE: In this except up
there, there's always

01:51:54.870 --> 01:51:55.760
[INAUDIBLE]?

01:51:55.760 --> 01:51:56.750
PROFESSOR: Yeah.

01:51:56.750 --> 01:51:58.520
AUDIENCE: But what does
this [INAUDIBLE]?

01:51:58.520 --> 01:52:01.985
PROFESSOR: So When you get an
exception, when an exception

01:52:01.985 --> 01:52:04.951
is raised, it's actually
an object.

01:52:04.951 --> 01:52:07.350
So there's an object that's
associated with it.

01:52:07.350 --> 01:52:10.170
And in a lot of cases you
really don't have to be

01:52:10.170 --> 01:52:12.180
concerned about it, but
sometimes you want some

01:52:12.180 --> 01:52:13.160
additional information.

01:52:13.160 --> 01:52:19.190
So these are not very
interesting exceptions, but

01:52:19.190 --> 01:52:23.750
some exceptions might have some
additional diagnostic

01:52:23.750 --> 01:52:24.370
information.

01:52:24.370 --> 01:52:28.060
So if you were, say, logging
the run of your program.

01:52:28.060 --> 01:52:31.530
And you wanted to diagnose any
exceptions that you caught?

01:52:31.530 --> 01:52:34.080
Like, say, you got a generic
exception or you got something

01:52:34.080 --> 01:52:36.680
that was kind of odd that
weren't expecting, you could

01:52:36.680 --> 01:52:38.210
print out additional
information.

01:52:38.210 --> 01:52:41.440
And so E is the name
of that object.

01:52:41.440 --> 01:52:48.540
So, I can do this.

01:52:55.180 --> 01:52:56.430
Well.

01:53:00.810 --> 01:53:02.060
This is because --

01:53:10.870 --> 01:53:15.180
if you give it a primer like
that, it's going to put that

01:53:15.180 --> 01:53:17.180
message into the exception.

01:53:17.180 --> 01:53:20.870
So now I can retrieve it when
the exception is raised.

01:53:20.870 --> 01:53:23.750
So if I'm raising the exception,
I can provide

01:53:23.750 --> 01:53:25.590
additional information.

01:53:25.590 --> 01:53:30.470
So that's the message that I've
put into the exception

01:53:30.470 --> 01:53:31.720
when I raised it.

01:53:33.890 --> 01:53:35.050
Does that make sense?

01:53:35.050 --> 01:53:38.190
AUDIENCE: Well, how is that
different-- so is it the same

01:53:38.190 --> 01:53:41.190
thing as saying print,
[INAUDIBLE]?

01:53:41.190 --> 01:53:41.950
PROFESSOR: Yeah.

01:53:41.950 --> 01:53:48.550
So this is a really [INAUDIBLE]
example.

01:53:48.550 --> 01:53:51.490
So this is just going to
print out whatever

01:53:51.490 --> 01:53:52.830
message I passed in.

01:53:52.830 --> 01:53:56.430
So when I say this and point to
my screen, I really meant

01:53:56.430 --> 01:53:59.230
this and highlighted this.

01:53:59.230 --> 01:54:02.580
So, this line is going to print
out this message that I

01:54:02.580 --> 01:54:05.760
passed in when I raised
the exception.

01:54:05.760 --> 01:54:09.160
Because what I'm actually doing
is, I'm creating a value

01:54:09.160 --> 01:54:15.220
error object that has this
message associated with it.

01:54:15.220 --> 01:54:19.090
And that's what gets passed up
this exception chain until I

01:54:19.090 --> 01:54:21.740
finally handle it. here.

01:54:21.740 --> 01:54:25.552
And E holds the reference to
that value error object.

01:54:25.552 --> 01:54:28.055
AUDIENCE: So E is
an actual value?

01:54:28.055 --> 01:54:28.480
PROFESSOR: Yeah.

01:54:28.480 --> 01:54:29.730
So if I do something
like this--

01:54:36.438 --> 01:54:40.140
and I print out the type--
you can see that?

01:54:40.140 --> 01:54:42.096
It's pretty neat.

01:54:42.096 --> 01:54:45.407
But did that answer
your question?

01:54:45.407 --> 01:54:46.657
AUDIENCE: [INAUDIBLE]

01:54:51.740 --> 01:54:52.670
PROFESSOR: Could
it be anything?

01:54:52.670 --> 01:54:57.210
So let's think of something
like this.

01:55:02.540 --> 01:55:03.790
Like a list.

01:55:10.610 --> 01:55:11.101
AUDIENCE: No.

01:55:11.101 --> 01:55:16.763
I meant in your accept value
error dash E. Could you put

01:55:16.763 --> 01:55:20.948
any variable there, or
does it have to be E?

01:55:20.948 --> 01:55:21.876
PROFESSOR: Oh, any name?

01:55:21.876 --> 01:55:23.270
AUDIENCE: Yeah.

01:55:23.270 --> 01:55:25.392
PROFESSOR: I've always used E.
That's kind of a convention.

01:55:25.392 --> 01:55:27.822
But I think you'd be
fine doing that.

01:55:31.230 --> 01:55:34.550
E is the convention that
I use, but some

01:55:34.550 --> 01:55:35.320
people don't like that.

01:55:35.320 --> 01:55:36.700
They're like, you should
name it something

01:55:36.700 --> 01:55:37.670
a little bit better.

01:55:37.670 --> 01:55:40.783
But honestly, why bother?

01:55:43.490 --> 01:55:43.650
Ok.

01:55:43.650 --> 01:55:45.150
Are we good with exceptions?

01:55:45.150 --> 01:55:47.570
That answer your question?

01:55:47.570 --> 01:55:48.820
Any other questions
on exceptions?

01:55:50.960 --> 01:55:55.298
AUDIENCE: Is there a built-in
amount of errors you can have?

01:55:55.298 --> 01:55:57.515
Like value errors,
[UNINTELLIGIBLE], can you make

01:55:57.515 --> 01:55:58.680
up your own?

01:55:58.680 --> 01:56:01.030
PROFESSOR: Can you make up
your own exceptions?

01:56:01.030 --> 01:56:01.370
Yes.

01:56:01.370 --> 01:56:02.568
You can do that.

01:56:02.568 --> 01:56:03.972
You can say--

01:56:11.320 --> 01:56:12.570
but--

01:56:14.630 --> 01:56:15.880
and--

01:56:21.670 --> 01:56:24.770
I think this is going to work.

01:56:24.770 --> 01:56:26.560
It's been while since I've
defined my own exceptions.

01:56:43.450 --> 01:56:46.250
So and again, I can handle it.

01:56:50.800 --> 01:56:53.410
So if you ever work on big
systems, a lot of times

01:56:53.410 --> 01:56:56.270
they'll have their own exception
hierarchies that

01:56:56.270 --> 01:56:59.060
define all sorts of exceptions
for the specific application

01:56:59.060 --> 01:57:01.550
you're working on.

01:57:01.550 --> 01:57:05.680
Python's built in exceptions
are pretty rich, so--

01:57:10.480 --> 01:57:13.970
there we go.

01:57:13.970 --> 01:57:15.220
AUDIENCE: [INAUDIBLE]

01:57:18.550 --> 01:57:20.370
PROFESSOR: I don't
think you do.

01:57:20.370 --> 01:57:23.410
It's convention.

01:57:23.410 --> 01:57:25.355
I could probably do
this, I think.

01:57:29.720 --> 01:57:31.175
Oh, wait.

01:57:35.060 --> 01:57:35.920
The only difference--

01:57:35.920 --> 01:57:38.500
or the only problem
is, is that now--

01:57:38.500 --> 01:57:42.910
see I expect my exception to
have a message attribute.

01:57:42.910 --> 01:57:43.740
And I don't have anything
on this.

01:57:43.740 --> 01:57:44.990
So I have to do this.

01:57:47.580 --> 01:57:49.200
Or something similar, right?

01:57:49.200 --> 01:57:51.510
I have to define message
on this.

01:57:51.510 --> 01:57:52.850
And I think this'll work.

01:57:58.430 --> 01:58:00.130
Well, actually, it does
guard against it.

01:58:00.130 --> 01:58:04.030
So yes, you do have to inherit
from exception.

01:58:04.030 --> 01:58:05.620
It's one of the few
things that Python

01:58:05.620 --> 01:58:09.420
seems to guard against.

01:58:09.420 --> 01:58:16.518
So, does that answer
your question?

01:58:21.630 --> 01:58:25.140
So we're getting kind of late.

01:58:25.140 --> 01:58:29.120
The only other topics that we
have are the simulations and

01:58:29.120 --> 01:58:34.700
the distributions and
that's about it.

01:58:34.700 --> 01:58:40.190
So, are there any questions
on Monte Carlo methods?

01:58:40.190 --> 01:58:44.350
We've kind of done those
to death, right?

01:58:44.350 --> 01:58:47.094
Real quick, someone humor me,
what is a Monte Carlo method?

01:58:51.046 --> 01:58:56.480
AUDIENCE: An algorithm that
uses random sampling for

01:58:56.480 --> 01:59:01.420
trials to [INAUDIBLE].

01:59:01.420 --> 01:59:01.914
PROFESSOR: Right.

01:59:01.914 --> 01:59:02.902
So, it's--

01:59:02.902 --> 01:59:04.878
what's that?

01:59:04.878 --> 01:59:06.128
AUDIENCE: [INAUDIBLE]

01:59:10.900 --> 01:59:14.180
PROFESSOR: It computes some
value or solution to a problem

01:59:14.180 --> 01:59:17.780
using a random process
and repeated trials.

01:59:17.780 --> 01:59:19.030
So--

01:59:20.780 --> 01:59:23.454
AUDIENCE: Is it almost
brute force?

01:59:23.454 --> 01:59:24.980
PROFESSOR: No, it's not what
we call brute force.

01:59:24.980 --> 01:59:29.890
I mean, it's like we computed
pi by throwing a dart at a

01:59:29.890 --> 01:59:31.900
chalkboard or something
like that.

01:59:31.900 --> 01:59:35.430
And it landed in a square, and
we used some sort of analysis

01:59:35.430 --> 01:59:38.870
to figure out what pi was based
on that throwing a dart

01:59:38.870 --> 01:59:41.610
at a board a million times.

01:59:41.610 --> 01:59:44.610
So that's what a Monte
Carlo method is.

01:59:44.610 --> 01:59:48.430
Anything that uses random stuff
to compute a value.

01:59:48.430 --> 01:59:51.100
A random simulation.

01:59:51.100 --> 01:59:52.350
Where'd my chalk go?

01:59:56.890 --> 02:00:00.720
And we actually a couple of
Monte Carlo methods when I

02:00:00.720 --> 02:00:02.450
showed the solutions
for problems (3)

02:00:02.450 --> 02:00:04.310
and (4) on the quiz.

02:00:04.310 --> 02:00:06.960
I used a random number generator
in order to figure

02:00:06.960 --> 02:00:09.180
out the probabilities
of not rolling a 6

02:00:09.180 --> 02:00:10.730
and all that stuff.

02:00:10.730 --> 02:00:14.170
And I used the Monte Carlo
method to show me that I was

02:00:14.170 --> 02:00:17.530
wrong on my initial answer for
rolling exactly one 6.

02:00:25.160 --> 02:00:28.070
So, is everyone comfortable with
coefficient of variation?

02:00:28.070 --> 02:00:33.210
Because I did that
first, initially.

02:00:33.210 --> 02:00:36.480
Confidence intervals
and levels?

02:00:36.480 --> 02:00:37.730
Does anyone have any
questions on that?

02:00:40.910 --> 02:00:42.640
AUDIENCE: What is a confidence
interval?

02:00:42.640 --> 02:00:45.770
PROFESSOR: What is a confidence
interval and a

02:00:45.770 --> 02:00:47.570
confidence level?

02:00:47.570 --> 02:00:47.906
OK.

02:00:47.906 --> 02:00:54.950
So, let's say I do
a political poll.

02:01:09.920 --> 02:01:13.400
Let's say I do a political poll
and I sample 1,000 people

02:01:13.400 --> 02:01:14.480
in the population.

02:01:14.480 --> 02:01:24.280
And I say 46% of them will
vote for Candidate X. My

02:01:24.280 --> 02:01:29.070
margin of error is plus
or minus 4, and my

02:01:29.070 --> 02:01:35.755
confidence is 95.

02:01:39.010 --> 02:01:47.880
What this is saying is that if
I conduct this poll, the same

02:01:47.880 --> 02:01:51.940
poll, sampling 1,000
random people at a

02:01:51.940 --> 02:01:56.240
time, over 100 trials--

02:01:56.240 --> 02:01:59.410
so I do 100 polls--

02:01:59.410 --> 02:02:03.840
what I'm saying is that 95 out
of 100 of those times, my

02:02:03.840 --> 02:02:08.120
level of support for Candidate
X will be between

02:02:08.120 --> 02:02:15.280
42% and 50%, right?

02:02:15.280 --> 02:02:17.490
Basically what you
need to know for

02:02:17.490 --> 02:02:19.820
confidence levels and intervals.

02:02:19.820 --> 02:02:22.260
The other thing that you need to
know for confidence levels

02:02:22.260 --> 02:02:33.610
and intervals is that if you
have a normal distribution,

02:02:33.610 --> 02:02:44.300
with a standard deviation
sigma, then 1 standard

02:02:44.300 --> 02:02:47.720
deviation from the mean
is going to have--

02:02:47.720 --> 02:02:50.095
is that 66 or 67?

02:02:53.320 --> 02:02:55.260
Is it 68?

02:02:55.260 --> 02:02:56.250
I wrote it down, 68.

02:02:56.250 --> 02:02:57.500
Thank you.

02:03:01.440 --> 02:03:07.050
And then 2 standard deviations
is going to be 95.

02:03:07.050 --> 02:03:13.960
And then 3 standard deviations
is going to be what, 97?

02:03:13.960 --> 02:03:15.800
Or is it 99.7?

02:03:15.800 --> 02:03:20.220
99.7.

02:03:20.220 --> 02:03:25.125
So, but you need to just know
that for normal distributions.

02:03:27.870 --> 02:03:40.450
So if this is one standard
deviation, it's saying that 68

02:03:40.450 --> 02:03:43.800
of the sample points are going
to be within 1 standard

02:03:43.800 --> 02:03:45.710
deviation of this mean.

02:03:45.710 --> 02:03:50.810
And then if you have 2 sigma,
then that means 95 are going

02:03:50.810 --> 02:03:54.430
to be within 2 sigma
of the mean.

02:03:54.430 --> 02:03:59.190
And then if you have 3 sigma,
then 99.7 are going to be

02:03:59.190 --> 02:04:04.470
within 3 standard deviations
of the mean.

02:04:04.470 --> 02:04:11.730
So I think that's all you
really need to know for

02:04:11.730 --> 02:04:15.890
confidence intervals and levels,
and also for normal

02:04:15.890 --> 02:04:17.140
distributions.

02:04:23.710 --> 02:04:30.390
So we're actually kind of at the
end of the review session.

02:04:30.390 --> 02:04:32.190
So does anyone have
any questions

02:04:32.190 --> 02:04:33.440
that I haven't answered?

02:04:36.390 --> 02:04:38.190
No?

02:04:38.190 --> 02:04:39.390
All right.

02:04:39.390 --> 02:04:40.640
I'm done.