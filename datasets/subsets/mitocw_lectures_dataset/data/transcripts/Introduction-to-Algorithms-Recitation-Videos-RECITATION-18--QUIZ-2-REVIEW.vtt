WEBVTT

00:00:00.080 --> 00:00:01.800
The following
content is provided

00:00:01.800 --> 00:00:04.040
under a Creative
Commons license.

00:00:04.040 --> 00:00:06.880
Your support will help MIT
OpenCourseWare continue

00:00:06.880 --> 00:00:10.740
to offer high quality
educational resources for free.

00:00:10.740 --> 00:00:13.360
To make a donation or
view additional materials

00:00:13.360 --> 00:00:17.237
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.237 --> 00:00:17.862
at ocw.mit.edu.

00:00:20.794 --> 00:00:22.460
PROFESSOR: So you
guys might have heard,

00:00:22.460 --> 00:00:24.590
we have a quiz tomorrow.

00:00:24.590 --> 00:00:26.880
So we're going to do
a review for that.

00:00:26.880 --> 00:00:29.690
Did everyone turn in P set six?

00:00:29.690 --> 00:00:30.200
Yes?

00:00:30.200 --> 00:00:30.900
Good.

00:00:30.900 --> 00:00:34.060
All right, so
what's on this quiz?

00:00:34.060 --> 00:00:37.470
Numerics and graph stuff.

00:00:37.470 --> 00:00:39.920
So are there any
specific pain points?

00:00:39.920 --> 00:00:41.065
I have problems prepared.

00:00:41.065 --> 00:00:42.750
Now, and then at
8:00 PM is going

00:00:42.750 --> 00:00:44.700
to be a review
session for concepts.

00:00:44.700 --> 00:00:47.660
So now problems, 8:00 PM
concepts, tomorrow [? Yakim ?]

00:00:47.660 --> 00:00:50.580
has office hours at
5:00 PM, conveniently

00:00:50.580 --> 00:00:51.700
placed before the quiz.

00:00:51.700 --> 00:00:52.360
Poor guy.

00:00:52.360 --> 00:00:55.230
So take advantage of that.

00:00:55.230 --> 00:00:56.085
So yeah.

00:00:56.085 --> 00:00:59.460
AUDIENCE: Numerics, on
P set we were mostly

00:00:59.460 --> 00:01:02.140
asked-- you said five,
four, whichever came before.

00:01:02.140 --> 00:01:05.140
You mostly asked for the running
times and things like that.

00:01:05.140 --> 00:01:08.570
But the numeric lecture
notes are kind of detailed

00:01:08.570 --> 00:01:13.320
and go into Newtonian
method and all that.

00:01:13.320 --> 00:01:15.750
How much detail do
we need to know?

00:01:15.750 --> 00:01:18.130
PROFESSOR: So on the P set
we make your life easier

00:01:18.130 --> 00:01:20.800
by giving you the
pseudocode of the code

00:01:20.800 --> 00:01:23.040
that you needed to implement.

00:01:23.040 --> 00:01:26.380
And we ask you one
algorithm design question,

00:01:26.380 --> 00:01:28.620
the problem of
finding the k-th root.

00:01:28.620 --> 00:01:30.820
And that required
you to understand

00:01:30.820 --> 00:01:32.760
almost everything
that was going on.

00:01:32.760 --> 00:01:35.410
We'll want you to understand
things that are going on

00:01:35.410 --> 00:01:39.951
to come up with something fairly
similar to what you've seen.

00:01:39.951 --> 00:01:41.450
So yeah, I know
that I told you guys

00:01:41.450 --> 00:01:42.777
before that ignore numerics.

00:01:42.777 --> 00:01:44.860
Just close your eyes and
pretend it didn't happen.

00:01:44.860 --> 00:01:47.950
Actually it turns out there's a
significant amount of numerics

00:01:47.950 --> 00:01:48.450
on the quiz.

00:01:48.450 --> 00:01:50.450
So we're going to start
with a numerics problem,

00:01:50.450 --> 00:01:51.770
and go through it.

00:01:51.770 --> 00:01:53.500
I'm really sorry about that.

00:01:53.500 --> 00:01:55.850
Clearly I didn't have
my way for this, right?

00:01:55.850 --> 00:02:00.090
OK so we started two
big things in numerics.

00:02:00.090 --> 00:02:02.470
Karatsuba, which is
really easy compared

00:02:02.470 --> 00:02:07.230
to Newton which requires
a lot of understanding.

00:02:07.230 --> 00:02:11.200
So we're going to spend
our time on Newton today.

00:02:11.200 --> 00:02:12.990
OK, so anything aside from that?

00:02:12.990 --> 00:02:13.813
Yes.

00:02:13.813 --> 00:02:15.729
AUDIENCE: The thing we
were just talking about

00:02:15.729 --> 00:02:17.757
before you were here
was what kind of edges

00:02:17.757 --> 00:02:21.160
are produced by depth
first search versus breadth

00:02:21.160 --> 00:02:21.701
first search?

00:02:21.701 --> 00:02:23.334
AUDIENCE: And why
do they matter?

00:02:23.334 --> 00:02:24.750
PROFESSOR: And why
do they matter.

00:02:24.750 --> 00:02:24.950
OK.

00:02:24.950 --> 00:02:26.010
AUDIENCE: Because it's probably
going to be a question on the--

00:02:26.010 --> 00:02:28.830
PROFESSOR: So I'm going to
go on this very quickly now,

00:02:28.830 --> 00:02:30.290
because I want to
cover problems,

00:02:30.290 --> 00:02:33.941
but tonight-- this is on
the outline for the review.

00:02:33.941 --> 00:02:35.440
So if you guys can
make it tonight--

00:02:35.440 --> 00:02:37.106
AUDIENCE: It's late,
so I can't make it.

00:02:37.106 --> 00:02:38.212
PROFESSOR: Sorry.

00:02:38.212 --> 00:02:39.920
Well, they are also
in the lecture notes.

00:02:39.920 --> 00:02:42.110
But I'll go through
them very quickly now.

00:02:42.110 --> 00:02:43.040
OK, anything else?

00:02:47.780 --> 00:02:49.450
AUDIENCE: Making trees
with DFS and BFS,

00:02:49.450 --> 00:02:51.049
this might be tonight also.

00:02:51.049 --> 00:02:52.090
PROFESSOR: Making trees--

00:02:52.090 --> 00:02:54.050
AUDIENCE: Or your search trees.

00:02:54.050 --> 00:02:58.700
So instead of-- do you
know what I mean by that?

00:02:58.700 --> 00:03:01.255
PROFESSOR: Do you mean
graph transformation?

00:03:01.255 --> 00:03:03.630
AUDIENCE: So you've got a tree
and you search through it.

00:03:03.630 --> 00:03:05.627
So then when you're
searching through it,

00:03:05.627 --> 00:03:07.460
the result of searching
it, you can put that

00:03:07.460 --> 00:03:11.100
into almost a binary tree.

00:03:11.100 --> 00:03:12.980
PROFESSOR: OK so
how BFS and DFS work

00:03:12.980 --> 00:03:15.480
and how they produce
trees, I'm assuming, right?

00:03:15.480 --> 00:03:17.040
Because if you start
out with a tree,

00:03:17.040 --> 00:03:19.980
everything's going to be
really nice and simple.

00:03:19.980 --> 00:03:21.410
AUDIENCE: Right.

00:03:21.410 --> 00:03:22.360
PROFESSOR: Yes?

00:03:22.360 --> 00:03:23.797
AUDIENCE: Bidirectional search.

00:03:23.797 --> 00:03:24.380
PROFESSOR: OK.

00:03:24.380 --> 00:03:25.960
AUDIENCE: Is that
going to be included?

00:03:25.960 --> 00:03:27.501
PROFESSOR: At a very
conceptual level

00:03:27.501 --> 00:03:31.460
because we didn't give
you a P set on it.

00:03:31.460 --> 00:03:33.140
AUDIENCE: Was that
what rubrics was?

00:03:33.140 --> 00:03:34.160
AUDIENCE: Yeah.

00:03:34.160 --> 00:03:34.810
AUDIENCE: It was bidirectional?

00:03:34.810 --> 00:03:36.250
AUDIENCE: Well it's not going
to be on it so, we're happy.

00:03:36.250 --> 00:03:38.041
PROFESSOR: Well I mean
we didn't give you--

00:03:38.041 --> 00:03:40.910
you kind of had to solve a
problem just by-- we have

00:03:40.910 --> 00:03:42.950
to tell you this
is bidirectional

00:03:42.950 --> 00:03:44.850
BFS, go code it up.

00:03:44.850 --> 00:03:47.250
This is bi-directional
Dijkstra, go code it up.

00:03:47.250 --> 00:03:51.110
So we're not going to ask you
anything too fancy on them.

00:03:51.110 --> 00:03:53.204
So nothing past the P set.

00:03:53.204 --> 00:03:54.620
AUDIENCE: Will you
have a question

00:03:54.620 --> 00:03:57.050
like when you were
studying BFS, saying

00:03:57.050 --> 00:04:00.313
how there will be
levels of graphs?

00:04:00.313 --> 00:04:00.938
PROFESSOR: Yep.

00:04:00.938 --> 00:04:02.890
AUDIENCE: Could there
be anything about that?

00:04:02.890 --> 00:04:05.420
PROFESSOR: So levels of graphs
as in the levels in BFS?

00:04:05.420 --> 00:04:08.227
Or the levels that we're using
when we're building graphs?

00:04:08.227 --> 00:04:09.768
AUDIENCE: Copies of
graphs and then--

00:04:09.768 --> 00:04:10.210
AUDIENCE: Transformations.

00:04:10.210 --> 00:04:10.570
PROFESSOR: Yep.

00:04:10.570 --> 00:04:11.980
OK, transformations and layers.

00:04:11.980 --> 00:04:13.447
Yeah, I think this is important.

00:04:13.447 --> 00:04:15.988
AUDIENCE: Any particular tips
on what kind of transformations

00:04:15.988 --> 00:04:17.014
we might encounter?

00:04:17.014 --> 00:04:17.680
PROFESSOR: Sure.

00:04:17.680 --> 00:04:19.882
Problem one has this
transformation, problem two--

00:04:19.882 --> 00:04:20.866
[AUDIENCE LAUGHTER]

00:04:20.866 --> 00:04:24.690
AUDIENCE: Basically,
when do we use these?

00:04:24.690 --> 00:04:29.440
Is it when we are given more
than one parameter for a cause.

00:04:29.440 --> 00:04:31.396
PROFESSOR: So I have
some problems on this

00:04:31.396 --> 00:04:32.520
but we have to have a deal.

00:04:32.520 --> 00:04:34.560
You guys have to help me
go through the problems

00:04:34.560 --> 00:04:36.680
fast enough so that we get here.

00:04:36.680 --> 00:04:37.180
OK?

00:04:37.180 --> 00:04:39.830
So if you know the
answer, say the answer.

00:04:39.830 --> 00:04:42.910
Don't let me wait.

00:04:42.910 --> 00:04:43.665
OK.

00:04:43.665 --> 00:04:46.660
AUDIENCE: Also, when you run
Dijkstra and Bellman-Ford

00:04:46.660 --> 00:04:50.340
on a graph, with
positive edges, they

00:04:50.340 --> 00:04:52.970
produce the same
shortest path weight

00:04:52.970 --> 00:04:55.570
but might have different trees?

00:04:55.570 --> 00:04:57.837
PROFESSOR: Yes,
that's conceivable.

00:04:57.837 --> 00:04:58.420
Because they--

00:04:58.420 --> 00:05:00.650
AUDIENCE: It's one of the
questions on spring 2011.

00:05:00.650 --> 00:05:01.233
PROFESSOR: OK.

00:05:01.233 --> 00:05:04.420
So first off, they both
have positive edges, so

00:05:04.420 --> 00:05:06.170
they both work, right?

00:05:06.170 --> 00:05:09.247
If you had to choose,
which one would you choose?

00:05:09.247 --> 00:05:11.080
If you had to choose
which are going to run,

00:05:11.080 --> 00:05:11.750
which one would you run?

00:05:11.750 --> 00:05:12.541
AUDIENCE: Dijkstra.

00:05:12.541 --> 00:05:13.735
PROFESSOR: OK, why Dijkstra?

00:05:13.735 --> 00:05:15.070
AUDIENCE: It's faster.

00:05:15.070 --> 00:05:15.960
PROFESSOR: Faster.

00:05:15.960 --> 00:05:27.464
OK so positive edges,
Dijkstra is faster.

00:05:27.464 --> 00:05:29.130
Now if you're going
to run both of them,

00:05:29.130 --> 00:05:31.470
they relax edges in
different orders.

00:05:31.470 --> 00:05:31.970
Right?

00:05:31.970 --> 00:05:34.310
So let's say we have this.

00:05:36.950 --> 00:05:40.560
I know you guys remember the
sequence of diamonds, right?

00:05:40.560 --> 00:05:43.710
My nice example that shows that
the number of paths in a graph

00:05:43.710 --> 00:05:46.080
is exponential in the
number of vertices.

00:05:46.080 --> 00:05:47.376
So let's have one diamond.

00:05:47.376 --> 00:05:50.490
1, 1, 1, 1.

00:05:50.490 --> 00:05:57.490
S, A, B, T. So say we're
looking for shortest path

00:05:57.490 --> 00:05:58.550
from S. Right?

00:05:58.550 --> 00:06:02.660
So the distance
from S to S is zero,

00:06:02.660 --> 00:06:05.730
and everything else
starts out as infinity.

00:06:05.730 --> 00:06:07.270
SA is infinity.

00:06:07.270 --> 00:06:10.150
SB is infinity.

00:06:10.150 --> 00:06:12.630
ST is infinity.

00:06:12.630 --> 00:06:14.650
Suppose I relax
edges in this order.

00:06:14.650 --> 00:06:18.150
One, two, three, four.

00:06:18.150 --> 00:06:19.190
What am I going to get?

00:06:19.190 --> 00:06:22.540
If I relax SA, then the
distance from S to A

00:06:22.540 --> 00:06:23.730
is going to become 1, right?

00:06:23.730 --> 00:06:27.090
Because it's 0 plus 1 1.

00:06:27.090 --> 00:06:30.610
And then the parent
of A is going to be S.

00:06:30.610 --> 00:06:34.300
Now say I relax AT.

00:06:34.300 --> 00:06:38.440
The distance from S
to T is going to be 2.

00:06:38.440 --> 00:06:39.640
Sorry.

00:06:39.640 --> 00:06:46.020
Parent of T is going
to be A. Right?

00:06:46.020 --> 00:06:50.080
OK now I'm relaxing this one.

00:06:50.080 --> 00:06:53.400
This is going to become
one and the parent of B

00:06:53.400 --> 00:06:56.820
is going to become S. And
as I'm relaxing this one,

00:06:56.820 --> 00:07:00.460
nothing happens because I
already had a distance of 2.

00:07:00.460 --> 00:07:03.010
Now if I relax them
in this order instead,

00:07:03.010 --> 00:07:07.210
so the bottom one first and
the top one is afterwards,

00:07:07.210 --> 00:07:09.220
I'm going to get
the different path.

00:07:09.220 --> 00:07:09.760
Right?

00:07:09.760 --> 00:07:11.850
OK so what path do I
have now from S to T?

00:07:15.440 --> 00:07:16.900
AUDIENCE: Right
now you have SAT.

00:07:16.900 --> 00:07:19.250
PROFESSOR: OK, why SAT?

00:07:19.250 --> 00:07:20.520
How do you compute the path?

00:07:20.520 --> 00:07:21.910
Parent pointers, right?

00:07:21.910 --> 00:07:25.820
Start at T, look at
the parent pointer.

00:07:25.820 --> 00:07:26.980
Look at the parent pointer.

00:07:29.940 --> 00:07:32.550
So because I relax
them in this order,

00:07:32.550 --> 00:07:35.260
this path was considered
before this path.

00:07:35.260 --> 00:07:37.820
So the parent pointer of
T is A but if I relax them

00:07:37.820 --> 00:07:40.542
in the other order, the
parent pointer could be B.

00:07:40.542 --> 00:07:42.420
So by the way, this
could happen if you're

00:07:42.420 --> 00:07:44.102
running Dijkstra
or Bellman-Ford.

00:07:44.102 --> 00:07:45.560
Or if you're running
Dijkstra, it's

00:07:45.560 --> 00:07:48.610
just about how you're going
to have the ties separated.

00:07:48.610 --> 00:07:50.320
So your priority
queue implementation

00:07:50.320 --> 00:07:52.346
might give you different paths.

00:07:52.346 --> 00:07:53.840
Does it make sense now?

00:07:53.840 --> 00:07:55.730
So if the order in
which edges are relaxed.

00:07:55.730 --> 00:07:58.453
That's what defines with path
you're going to end up with.

00:07:58.453 --> 00:07:59.140
AUDIENCE: OK.

00:07:59.140 --> 00:08:00.050
PROFESSOR: OK.

00:08:00.050 --> 00:08:02.480
Hopefully useful.

00:08:02.480 --> 00:08:04.560
All right.

00:08:04.560 --> 00:08:06.485
I saw four hands before.

00:08:06.485 --> 00:08:08.720
AUDIENCE: Oh, just
overall, how similar

00:08:08.720 --> 00:08:11.370
is this test compared
to previous tests?

00:08:11.370 --> 00:08:15.070
PROFESSOR: Less algorithm
design, more concepts.

00:08:15.070 --> 00:08:15.695
AUDIENCE: Nice.

00:08:15.695 --> 00:08:17.120
AUDIENCE: Yes.

00:08:17.120 --> 00:08:19.660
PROFESSOR: Well OK,
not less algorithm--

00:08:19.660 --> 00:08:22.090
so it's not going to be as
much out-of-the-box thinking,

00:08:22.090 --> 00:08:25.260
it's going to be a lot more
of what we drilled already.

00:08:25.260 --> 00:08:27.120
So as a hint, what
kind of problem

00:08:27.120 --> 00:08:29.405
did we practice over,
and over, and over?

00:08:29.405 --> 00:08:30.590
AUDIENCE: States

00:08:30.590 --> 00:08:31.510
PROFESSOR: OK.

00:08:31.510 --> 00:08:33.360
Graph transformation, right?

00:08:33.360 --> 00:08:35.452
So chances are you'll see that.

00:08:35.452 --> 00:08:37.340
AUDIENCE: Wait, what's
graph transformation?

00:08:37.340 --> 00:08:42.659
[LAUGHTER]

00:08:42.659 --> 00:08:44.700
PROFESSOR: So we start
with a complicated problem

00:08:44.700 --> 00:08:48.420
and reduce it to a shortest path
problem or to a shortest length

00:08:48.420 --> 00:08:49.090
path problem.

00:08:52.200 --> 00:08:52.810
OK.

00:08:52.810 --> 00:08:54.660
Cool.

00:08:54.660 --> 00:08:57.430
So that being said, let's go.

00:08:57.430 --> 00:09:00.480
Numerics, everyone's
favorite topic.

00:09:00.480 --> 00:09:04.920
So suppose we're
trying to compute this.

00:09:04.920 --> 00:09:08.200
Cube root of 6,006.

00:09:08.200 --> 00:09:11.030
And the problem
statement says this,

00:09:11.030 --> 00:09:17.080
you start out with an
initial approximation of one,

00:09:17.080 --> 00:09:25.810
and it wants two
approximations after that.

00:09:25.810 --> 00:09:28.680
The problem also tells you which
function we're going to use.

00:09:28.680 --> 00:09:30.540
But why don't we
make this fun and try

00:09:30.540 --> 00:09:34.415
to guess what the
function will be?

00:09:34.415 --> 00:09:45.330
AUDIENCE: x cubed minus 6,006?

00:09:45.330 --> 00:09:47.350
PROFESSOR: OK. x
cubed minus 6,006

00:09:47.350 --> 00:09:49.289
why did I choose this function?

00:09:49.289 --> 00:09:49.830
Well, not me.

00:09:49.830 --> 00:09:51.378
Why did you choose
this function?

00:09:51.378 --> 00:09:52.378
AUDIENCE: It's the root.

00:09:55.130 --> 00:10:02.940
PROFESSOR: OK so reason
number one-- right?

00:10:02.940 --> 00:10:03.897
Important.

00:10:03.897 --> 00:10:05.730
Has to be zero at the
answer, because that's

00:10:05.730 --> 00:10:07.740
what Newton's method gives us.

00:10:07.740 --> 00:10:08.990
And what else?

00:10:08.990 --> 00:10:10.460
AUDIENCE:
Multiplication is easy.

00:10:14.390 --> 00:10:16.370
PROFESSOR: OK.

00:10:16.370 --> 00:10:19.160
So it's easy to compute
whatever Newton's method wants

00:10:19.160 --> 00:10:20.620
us to compute.

00:10:20.620 --> 00:10:23.570
What does Newton's method
want us to compute?

00:10:23.570 --> 00:10:28.230
So given an approximation,
xi, how do we

00:10:28.230 --> 00:10:31.320
get to the next
approximation, xi plus 1.

00:10:31.320 --> 00:10:32.187
Formula.

00:10:32.187 --> 00:10:34.520
By the way, this formula
should be on your cheat sheets.

00:10:34.520 --> 00:10:37.564
If it's not, no
sympathy for you.

00:10:37.564 --> 00:10:39.516
AUDIENCE: I don't remember.

00:10:39.516 --> 00:10:44.884
xi plus f over f prime.

00:10:51.250 --> 00:10:52.440
AUDIENCE: Where's the prime?

00:10:52.440 --> 00:10:54.240
AUDIENCE: Prime's on the bottom.

00:10:54.240 --> 00:10:56.320
PROFESSOR: So yeah,
where's the prime?

00:10:56.320 --> 00:10:58.560
And is this right?

00:11:01.976 --> 00:11:05.392
AUDIENCE: Isn't
there a constant?

00:11:05.392 --> 00:11:06.860
AUDIENCE: Isn't it minus?

00:11:06.860 --> 00:11:08.341
PROFESSOR: Isn't it minus?

00:11:08.341 --> 00:11:11.287
AUDIENCE: Maybe.

00:11:11.287 --> 00:11:12.270
AUDIENCE: There you go.

00:11:12.270 --> 00:11:13.390
PROFESSOR: So yeah,
if you guys start out

00:11:13.390 --> 00:11:15.640
with the wrong formula
you'd get the wrong answer.

00:11:15.640 --> 00:11:17.490
Again, no sympathy.

00:11:17.490 --> 00:11:20.500
So get that on your sheets.

00:11:20.500 --> 00:11:23.570
OK so this is what we
need to compute, right?

00:11:23.570 --> 00:11:26.330
You start with an approximation
and you have to subtract this.

00:11:26.330 --> 00:11:29.590
So this has to be
easy to compute.

00:11:29.590 --> 00:11:35.450
What if I chose instead
a very nice function.

00:11:35.450 --> 00:11:37.450
x-- sorry, x minus.

00:11:40.750 --> 00:11:44.432
This is clearly zero where
I want it to be, right?

00:11:44.432 --> 00:11:46.056
AUDIENCE: But we
don't know what six--

00:11:46.056 --> 00:11:47.680
PROFESSOR: But if
I'm trying to compute

00:11:47.680 --> 00:11:51.120
the successive approximations,
very good, I'm getting what?

00:11:51.120 --> 00:11:59.670
f of x over f prime of x is
x minus square root 3 6,006

00:11:59.670 --> 00:12:02.815
over-- what's the
derivative of this?

00:12:02.815 --> 00:12:03.490
AUDIENCE: One.

00:12:03.490 --> 00:12:04.880
PROFESSOR: One.

00:12:04.880 --> 00:12:07.140
So I haven't done
anything, right?

00:12:07.140 --> 00:12:09.370
In order to compute the
successive approximation,

00:12:09.370 --> 00:12:11.450
I have to know this number.

00:12:11.450 --> 00:12:15.020
So this doesn't get me anywhere,
that's why it's a bad function.

00:12:15.020 --> 00:12:18.290
By the way, it's not enough
that this is easy to compute.

00:12:18.290 --> 00:12:22.920
What you want is this guy
has to be easy to compute.

00:12:22.920 --> 00:12:24.770
In the case of division,
we had a function

00:12:24.770 --> 00:12:26.280
that looked pretty wacky.

00:12:26.280 --> 00:12:29.360
But then when we divided
that by the derivative,

00:12:29.360 --> 00:12:31.690
we got something
reasonably nice.

00:12:31.690 --> 00:12:34.240
So this has to be
easy to compute.

00:12:34.240 --> 00:12:36.990
AUDIENCE: So we changed it
from that one to this one just

00:12:36.990 --> 00:12:38.994
because this one is easier or--

00:12:38.994 --> 00:12:40.410
PROFESSOR: So we're
using this one

00:12:40.410 --> 00:12:44.476
because this one-- let's see
how easy this one is to compute.

00:12:44.476 --> 00:12:46.720
Computing this one requires
that you know the answer

00:12:46.720 --> 00:12:48.600
to your original problem,
which is not cool.

00:12:48.600 --> 00:12:50.536
Right.

00:12:50.536 --> 00:12:53.310
So you're trying to
compute this number.

00:12:53.310 --> 00:12:55.420
But if you use this,
Newton's approximation

00:12:55.420 --> 00:12:57.860
requires that you compute this.

00:12:57.860 --> 00:13:00.262
So you have to know this here.

00:13:00.262 --> 00:13:02.470
Which is what you're trying
to do in the first place.

00:13:02.470 --> 00:13:03.678
AUDIENCE: Wait, I'm confused.

00:13:03.678 --> 00:13:05.650
We went from x
cubed minus 6 over 6

00:13:05.650 --> 00:13:07.920
to x minus cube
root of 6 over 6.

00:13:07.920 --> 00:13:08.657
So what's your--

00:13:08.657 --> 00:13:10.240
PROFESSOR: So this
is a good function.

00:13:10.240 --> 00:13:11.100
We can use this.

00:13:11.100 --> 00:13:12.890
This is a bad function
and I was asking

00:13:12.890 --> 00:13:14.080
why is this a bad function.

00:13:14.080 --> 00:13:15.912
AUDIENCE: Oh, OK.

00:13:15.912 --> 00:13:16.830
PROFESSOR: OK.

00:13:16.830 --> 00:13:18.950
So lets see, if we try
to compute it using this,

00:13:18.950 --> 00:13:21.215
what do we get?

00:13:21.215 --> 00:13:23.125
xi minus

00:13:23.125 --> 00:13:25.544
AUDIENCE: x cubed minus 6,006.

00:13:25.544 --> 00:13:27.488
PROFESSOR: X cubed minus 6,006.

00:13:27.488 --> 00:13:28.641
Divided by--

00:13:28.641 --> 00:13:29.432
AUDIENCE: 3x cubed.

00:13:32.360 --> 00:13:34.510
PROFESSOR: OK.

00:13:34.510 --> 00:13:38.063
So someone simplify this for me.

00:13:38.063 --> 00:13:47.432
AUDIENCE: 6i minus x over 3
plus 6,006 over 3 squared.

00:13:47.432 --> 00:13:48.816
Oh, well.

00:13:48.816 --> 00:13:49.515
It's 2,002.

00:13:49.515 --> 00:13:51.056
PROFESSOR: I'll
choose the easy step.

00:13:53.998 --> 00:13:54.498
OK.

00:14:01.970 --> 00:14:02.845
So what's x1?

00:14:10.030 --> 00:14:12.510
AUDIENCE: You plug in x0.

00:14:12.510 --> 00:14:14.316
PROFESSOR: OK.

00:14:14.316 --> 00:14:16.785
I heard a 2,002.

00:14:16.785 --> 00:14:19.160
I don't think it's--
it's very close.

00:14:19.160 --> 00:14:20.585
AUDIENCE: 2,002 and two thirds.

00:14:20.585 --> 00:14:22.490
0.67.

00:14:22.490 --> 00:14:24.310
PROFESSOR: OK, cool.

00:14:24.310 --> 00:14:28.230
So 0.67, let's
get to that later.

00:14:28.230 --> 00:14:31.210
I don't like fractional numbers.

00:14:31.210 --> 00:14:32.960
I mean this is the
right answer math-wise,

00:14:32.960 --> 00:14:35.430
but we'll get to that because
if we want to code this up,

00:14:35.430 --> 00:14:37.180
we probably don't want
fractional numbers.

00:14:37.180 --> 00:14:38.730
So very good point there.

00:14:38.730 --> 00:14:40.940
What if I want to compute x2?

00:14:40.940 --> 00:14:43.350
I take this guy and
I plug it into where?

00:14:47.020 --> 00:14:49.730
This thing over here, right?

00:14:49.730 --> 00:14:51.750
So this way I can
compute approximations

00:14:51.750 --> 00:14:56.240
that get closer and closer
to my original value.

00:14:56.240 --> 00:14:56.740
OK.

00:14:56.740 --> 00:14:57.820
Does this ring a bell?

00:15:01.430 --> 00:15:03.051
Yes, everyone is
happy with this?

00:15:03.051 --> 00:15:03.550
Cool.

00:15:06.099 --> 00:15:07.390
So how about the initial guess?

00:15:07.390 --> 00:15:10.530
Here we started with
a known initial guess.

00:15:10.530 --> 00:15:11.971
Is this a good guess?

00:15:11.971 --> 00:15:14.326
AUDIENCE: It's a
really bad guess.

00:15:14.326 --> 00:15:16.450
2,002?

00:15:16.450 --> 00:15:17.450
PROFESSOR: No, I mean 1.

00:15:17.450 --> 00:15:17.950
AUDIENCE: 1?

00:15:17.950 --> 00:15:19.900
That's also a really bad guess.

00:15:19.900 --> 00:15:21.370
AUDIENCE: Why
would you even ask?

00:15:21.370 --> 00:15:23.330
AUDIENCE: 11 and a half.

00:15:23.330 --> 00:15:25.020
PROFESSOR: All right.

00:15:25.020 --> 00:15:29.000
So you're saying 11 and a
half would be a nice guess.

00:15:29.000 --> 00:15:30.920
So, first off, let's
see, what do we

00:15:30.920 --> 00:15:34.640
need to-- what does Newton's
algorithm guarantee?

00:15:34.640 --> 00:15:38.120
What-- if the guess
is really, really bad,

00:15:38.120 --> 00:15:40.030
would we get an
answer all the time?

00:15:40.030 --> 00:15:42.020
Maybe takes forever but
we'll get an answer.

00:15:42.020 --> 00:15:43.375
True or false?

00:15:43.375 --> 00:15:44.000
AUDIENCE: True.

00:15:46.477 --> 00:15:47.310
PROFESSOR: Not true.

00:15:47.310 --> 00:15:48.587
Sorry.

00:15:48.587 --> 00:15:50.920
AUDIENCE: But it has to be
right for your answer to be--

00:15:50.920 --> 00:15:53.456
PROFESSOR: OK, so what does
Newton's method guarantee?

00:15:53.456 --> 00:15:54.887
[INTERPOSING VOICES]

00:15:54.887 --> 00:15:55.720
PROFESSOR: Yep, yep.

00:15:55.720 --> 00:15:57.785
So what is the fancy
math name for that?

00:15:57.785 --> 00:15:59.660
AUDIENCE: Quadratic
convergence or something.

00:15:59.660 --> 00:16:01.540
PROFESSOR: Quadratic
convergence, all right.

00:16:01.540 --> 00:16:03.770
So this is what
Newton guarantees.

00:16:06.530 --> 00:16:11.970
Quadratic-- so what
does this mean?

00:16:11.970 --> 00:16:15.740
For all your approximations,
they're all going to be xi.

00:16:15.740 --> 00:16:21.180
If we write them as true
answer times 1 plus error, i.

00:16:21.180 --> 00:16:25.640
So this error is the relative
error of the approximation.

00:16:25.640 --> 00:16:32.170
Newtons method guarantees
that the error at each step

00:16:32.170 --> 00:16:35.060
is squared.

00:16:35.060 --> 00:16:41.120
So if this guy-- if
E0 is greater than 1,

00:16:41.120 --> 00:16:43.329
would we get an answer?

00:16:43.329 --> 00:16:43.870
AUDIENCE: No.

00:16:47.820 --> 00:16:50.380
PROFESSOR: OK so what we need?

00:16:50.380 --> 00:16:54.080
What's the minimum that we need?

00:16:54.080 --> 00:16:58.140
E0 has to be between
what and what?

00:16:58.140 --> 00:17:00.540
AUDIENCE: Negative 1?

00:17:00.540 --> 00:17:02.460
AUDIENCE: Is it negative
1, 1 or 0 and 1?

00:17:02.460 --> 00:17:04.001
AUDIENCE: It would
be 0 and 1, right?

00:17:04.001 --> 00:17:05.820
Because won't it
be less than one?

00:17:05.820 --> 00:17:07.280
AUDIENCE: Negative 1.

00:17:07.280 --> 00:17:09.200
AUDIENCE: Oh, absolute value.

00:17:09.200 --> 00:17:11.254
PROFESSOR: I think if you
score something smaller

00:17:11.254 --> 00:17:12.670
than negative 1
you get a positive

00:17:12.670 --> 00:17:15.490
and then-- so, let's
say this works.

00:17:15.490 --> 00:17:21.000
So then x0 has to be
between what and what

00:17:21.000 --> 00:17:22.485
in relation to the real answer?

00:17:29.910 --> 00:17:35.355
AUDIENCE: The real answer
minus x0 over [INAUDIBLE].

00:17:37.479 --> 00:17:39.187
AUDIENCE: 2 times the
actual answer is 0.

00:17:42.770 --> 00:17:45.580
PROFESSOR: OK so this
is a sucky guess.

00:17:45.580 --> 00:17:47.320
We can do a lot
better, but at least it

00:17:47.320 --> 00:17:48.528
will make the thing converge.

00:17:51.320 --> 00:17:51.820
Fair enough?

00:17:55.710 --> 00:17:58.870
OK now what if I
want a good guess?

00:17:58.870 --> 00:18:03.520
First off, let's backtrack
to a more general problem

00:18:03.520 --> 00:18:05.330
because this is easy, right?

00:18:05.330 --> 00:18:08.370
To plug it into our calculator
and you have the answer.

00:18:08.370 --> 00:18:13.973
So what if I'm trying to
compute cube root of r.

00:18:13.973 --> 00:18:16.177
Can everyone see, by the way?

00:18:16.177 --> 00:18:16.760
AUDIENCE: Yes.

00:18:16.760 --> 00:18:17.015
AUDIENCE: Mhmm.

00:18:17.015 --> 00:18:17.598
PROFESSOR: OK.

00:18:17.598 --> 00:18:20.345
So I'm trying to
compute cube root of r.

00:18:20.345 --> 00:18:21.810
r is a number.

00:18:21.810 --> 00:18:26.046
Suppose I'm trying to compute,
for example, cube root of 2.

00:18:29.330 --> 00:18:33.130
What's the first
thing I need to do?

00:18:33.130 --> 00:18:35.020
I'm going to code
this up, by the way.

00:18:35.020 --> 00:18:37.061
Well, not me but suppose
we want to code this up.

00:18:37.061 --> 00:18:39.156
What's the first
thing we want to do?

00:18:39.156 --> 00:18:42.000
AUDIENCE: I think we want an
initial guess at a function.

00:18:42.000 --> 00:18:44.250
PROFESSOR: OK so we're going
to need an initial guess.

00:18:44.250 --> 00:18:44.930
That's good.

00:18:49.770 --> 00:18:52.259
And what else do we want?

00:18:52.259 --> 00:18:54.550
AUDIENCE: We need to decide
how much precision we want.

00:18:54.550 --> 00:18:55.175
PROFESSOR: Yep.

00:18:55.175 --> 00:18:56.335
And why is that?

00:18:56.335 --> 00:18:59.245
AUDIENCE: Because this
cube root of 2 is 1.

00:18:59.245 --> 00:19:01.670
If you round down.

00:19:01.670 --> 00:19:04.580
That doesn't tell us very much.

00:19:04.580 --> 00:19:07.022
I don't know, we don't
like the fractions.

00:19:07.022 --> 00:19:08.480
PROFESSOR: We don't
like fractions.

00:19:08.480 --> 00:19:10.670
OK, why don't we like fractions?

00:19:10.670 --> 00:19:11.835
It's a lot easier to code.

00:19:11.835 --> 00:19:12.990
AUDIENCE: Decimal point there.

00:19:12.990 --> 00:19:14.640
PROFESSOR: Yep, you have to
deal with the decimal point

00:19:14.640 --> 00:19:15.598
and we don't like that.

00:19:15.598 --> 00:19:17.912
So we want to take
this problem, and we

00:19:17.912 --> 00:19:20.000
want to move it
into integer land.

00:19:20.000 --> 00:19:21.750
So what we did
here has fractions.

00:19:21.750 --> 00:19:23.980
We don't like that because
that's a pain to code.

00:19:23.980 --> 00:19:26.780
We didn't make you code
fractions on the P set, right?

00:19:26.780 --> 00:19:29.190
So then we better know
how to avoid fractions

00:19:29.190 --> 00:19:32.670
if you want to solve
real life problems.

00:19:32.670 --> 00:19:36.310
So we're going to say that
we're happy with some amount

00:19:36.310 --> 00:19:38.110
of precision in the answer.

00:19:38.110 --> 00:19:39.920
And then we're going
to do something

00:19:39.920 --> 00:19:42.676
that lets us do all our
computations in integer land.

00:19:49.340 --> 00:19:51.720
Because that's a happy place.

00:19:51.720 --> 00:20:00.020
So how do I-- suppose
I'm working in base B

00:20:00.020 --> 00:20:03.720
and I want d digits
of precision.

00:20:03.720 --> 00:20:06.300
What do I want to compute?

00:20:06.300 --> 00:20:08.806
How do I transform the
problem in that way?

00:20:08.806 --> 00:20:09.660
Yes?

00:20:09.660 --> 00:20:15.262
AUDIENCE: You multiply 2
root 3 times B to the d.

00:20:15.262 --> 00:20:16.720
PROFESSOR: OK so
we want the answer

00:20:16.720 --> 00:20:22.146
to be 2 times B to the d.

00:20:22.146 --> 00:20:24.790
And if we're integer land, what
are we actually going to get?

00:20:30.830 --> 00:20:37.210
So suppose B is 10-- let's work
with familiar numbers-- d is 2.

00:20:37.210 --> 00:20:40.950
So we're going to
want to compute

00:20:40.950 --> 00:20:45.005
square root of 3 2 times 100.

00:20:45.005 --> 00:20:46.880
Does anyone have a
calculator and can tell me

00:20:46.880 --> 00:20:49.390
what square root of 3 is?

00:20:49.390 --> 00:20:50.279
First two digits?

00:20:50.279 --> 00:20:51.320
AUDIENCE: Cube root of 2.

00:20:51.320 --> 00:20:52.695
PROFESSOR: Sorry,
cube root of 2.

00:20:57.720 --> 00:20:59.985
AUDIENCE: 1.2.

00:20:59.985 --> 00:21:06.770
PROFESSOR: So let's say that
square root of 3 is 1.2345.

00:21:06.770 --> 00:21:08.780
Hopefully someone will
fix this up for us.

00:21:08.780 --> 00:21:10.020
But let's say it's this.

00:21:10.020 --> 00:21:13.310
If I multiply it by
100 what do I get?

00:21:13.310 --> 00:21:14.750
123 times 45.

00:21:18.780 --> 00:21:21.860
So multiply by 100 means
you move the decimal point

00:21:21.860 --> 00:21:22.640
to the right.

00:21:22.640 --> 00:21:23.140
Right?

00:21:23.140 --> 00:21:24.820
So it's still not an integer.

00:21:24.820 --> 00:21:27.010
If we work in integer
land, our algorithm

00:21:27.010 --> 00:21:29.450
will return an integer.

00:21:29.450 --> 00:21:30.950
What's the integer
that we're hoping

00:21:30.950 --> 00:21:33.464
our algorithm will return?

00:21:33.464 --> 00:21:35.260
AUDIENCE: 1.23, right?

00:21:35.260 --> 00:21:37.090
PROFESSOR: We're
hoping so, right?

00:21:37.090 --> 00:21:37.590
Why?

00:21:37.590 --> 00:21:38.730
What can you do with 123?

00:21:41.950 --> 00:21:42.520
Shift right.

00:21:42.520 --> 00:21:47.060
So if you divide this
by 100, you get 1.23.

00:21:47.060 --> 00:21:49.895
And this is our answer with
two digits of precision.

00:21:49.895 --> 00:21:56.582
AUDIENCE: Do you want
the actual-- it's 1.2599.

00:21:56.582 --> 00:21:57.790
PROFESSOR: You guys are good.

00:22:04.800 --> 00:22:07.460
OK.

00:22:07.460 --> 00:22:11.320
So our algorithm will
give us this, right?

00:22:11.320 --> 00:22:16.530
So it's not going to
give us exactly cube

00:22:16.530 --> 00:22:18.690
root of 2 times 100.

00:22:18.690 --> 00:22:20.630
It's not going to give
us exactly this value.

00:22:20.630 --> 00:22:23.424
What's it going to give us?

00:22:23.424 --> 00:22:24.965
AUDIENCE: Two digits--
close to that.

00:22:29.720 --> 00:22:32.830
PROFESSOR: So it's going to
give us an integer, right?

00:22:32.830 --> 00:22:34.870
So what kind of integer?

00:22:34.870 --> 00:22:35.757
Math.

00:22:35.757 --> 00:22:36.590
AUDIENCE: Truncated?

00:22:36.590 --> 00:22:38.480
PROFESSOR: OK, what's
the math for that?

00:22:38.480 --> 00:22:39.050
Truncated.

00:22:39.050 --> 00:22:40.530
Floor.

00:22:40.530 --> 00:22:42.070
Very good.

00:22:42.070 --> 00:22:44.740
So this is what we're
actually going to compute.

00:22:44.740 --> 00:22:47.010
Actually, because
we're in integer land,

00:22:47.010 --> 00:22:48.830
we're going to have
floors at every step

00:22:48.830 --> 00:22:50.810
when we're doing
that approximation.

00:22:50.810 --> 00:22:52.310
And there's a fancy
proof for Newton

00:22:52.310 --> 00:22:54.268
that says that even though
you're taking floors

00:22:54.268 --> 00:22:58.430
all the time, it will still
converge to the right thing.

00:22:58.430 --> 00:23:01.739
So in order to compute
this, how are we

00:23:01.739 --> 00:23:03.030
going to transform the problem?

00:23:06.060 --> 00:23:09.250
AUDIENCE: Slide
the Bd into that.

00:23:09.250 --> 00:23:10.066
PROFESSOR: OK.

00:23:10.066 --> 00:23:12.190
AUDIENCE: You're going to
have to put a 3 in there.

00:23:12.190 --> 00:23:12.734
B to the 3d.

00:23:12.734 --> 00:23:14.150
PROFESSOR: So we're
actually going

00:23:14.150 --> 00:23:18.466
to compute cube root
of 2 times B to the 3d.

00:23:25.580 --> 00:23:26.630
Fair enough?

00:23:26.630 --> 00:23:28.379
And if we slide this
right by the digits

00:23:28.379 --> 00:23:30.795
afterwards we're going to get
our two digits of precision.

00:23:33.590 --> 00:23:35.370
OK.

00:23:35.370 --> 00:23:38.910
So now I figured
out my precision.

00:23:38.910 --> 00:23:41.740
I want an initial guess--
and actually I lied,

00:23:41.740 --> 00:23:44.250
there's one more problem.

00:23:44.250 --> 00:23:45.060
Running time.

00:23:48.547 --> 00:23:50.505
Do you guys want to start
with the running time

00:23:50.505 --> 00:23:53.825
or initial guess?

00:23:53.825 --> 00:23:56.570
AUDIENCE: Initial guess.

00:23:56.570 --> 00:24:01.245
PROFESSOR: OK so what I
want a good initial guess?

00:24:01.245 --> 00:24:06.117
AUDIENCE: Between 0 and 2x.

00:24:06.117 --> 00:24:08.450
PROFESSOR: OK so if I don't
have that the algorithm will

00:24:08.450 --> 00:24:09.580
crash and burn.

00:24:09.580 --> 00:24:11.050
When we did Newton
in recitation,

00:24:11.050 --> 00:24:13.600
I said that I would
like two things.

00:24:13.600 --> 00:24:17.110
And I backed up, I coded
that into P set five

00:24:17.110 --> 00:24:18.596
when I did the guess.

00:24:18.596 --> 00:24:19.970
So what are the
two things that I

00:24:19.970 --> 00:24:21.645
want from a good initial guess?

00:24:21.645 --> 00:24:23.070
AUDIENCE: Order of magnitude?

00:24:23.070 --> 00:24:24.770
PROFESSOR: OK.

00:24:24.770 --> 00:24:26.280
Perfect.

00:24:26.280 --> 00:24:29.000
AUDIENCE: Oh, god.

00:24:29.000 --> 00:24:36.000
[LAUGHS]

00:24:36.000 --> 00:24:37.700
PROFESSOR: OK, so
order of magnitude

00:24:37.700 --> 00:24:43.390
is a fancy CSE way to say,
right number of digits.

00:24:43.390 --> 00:24:46.470
Suppose we're computing this.

00:24:46.470 --> 00:24:49.190
Or suppose we're
computing the cube

00:24:49.190 --> 00:24:57.880
root of some number
in base B. So

00:24:57.880 --> 00:25:03.850
supposed r is somewhere
between 0 and B.

00:25:03.850 --> 00:25:06.140
It's one digit in base
B. How many digits

00:25:06.140 --> 00:25:08.160
is this result is going to have?

00:25:11.590 --> 00:25:13.440
AUDIENCE: The amount
of digits divided by 3.

00:25:13.440 --> 00:25:16.380
The amount of digits
in 2 times B to the 3d.

00:25:16.380 --> 00:25:19.810
Which is whatever
B to the 3d is.

00:25:19.810 --> 00:25:21.310
AUDIENCE: D plus 1?

00:25:21.310 --> 00:25:25.150
PROFESSOR: OK so roughly
either d or d plus 1.

00:25:25.150 --> 00:25:28.590
See, d plus 1.

00:25:28.590 --> 00:25:33.500
So a decent approximation would
be a 1 followed by these zeros.

00:25:33.500 --> 00:25:35.180
An even better
approximation is what

00:25:35.180 --> 00:25:39.050
if we can get the first
digit right or almost right?

00:25:39.050 --> 00:25:40.030
How would we do that?

00:25:43.730 --> 00:25:48.300
AUDIENCE: Pick up the
first digit of our r

00:25:48.300 --> 00:25:50.640
PROFESSOR: OK and I promise
that r is one digit.

00:25:50.640 --> 00:25:52.740
Just So let's say we pick up r.

00:25:52.740 --> 00:25:54.260
And?

00:25:54.260 --> 00:25:56.256
AUDIENCE: We do
Newtons method on that.

00:25:56.256 --> 00:25:57.552
And we just guess one?

00:25:57.552 --> 00:25:59.912
Is that a thing?

00:25:59.912 --> 00:26:01.286
PROFESSOR: Uhh--

00:26:01.286 --> 00:26:02.744
AUDIENCE: Take the
cube root of it.

00:26:02.744 --> 00:26:04.785
AUDIENCE: It should be
some kind of inefficient--

00:26:04.785 --> 00:26:07.800
PROFESSOR: Yeah what's some
kind of inefficient way

00:26:07.800 --> 00:26:09.302
that we can think of quickly?

00:26:09.302 --> 00:26:10.170
AUDIENCE: Can you--

00:26:10.170 --> 00:26:11.040
AUDIENCE: Binary?

00:26:11.040 --> 00:26:12.498
PROFESSOR: Did you
say divide and--

00:26:12.498 --> 00:26:14.435
AUDIENCE: --divide it by 2r?

00:26:14.435 --> 00:26:15.310
PROFESSOR: Oh, sorry.

00:26:15.310 --> 00:26:16.260
I thought You were>you
were going to say divide

00:26:16.260 --> 00:26:17.580
and conquer.

00:26:17.580 --> 00:26:20.450
So I heard binary search,
so binary search wins.

00:26:20.450 --> 00:26:21.950
So we're going to
the binary search.

00:26:21.950 --> 00:26:26.630
Binary search from 0 to r.

00:26:26.630 --> 00:26:27.130
Right?

00:26:27.130 --> 00:26:30.610
In order to the binary search,
suppose I have my guess,

00:26:30.610 --> 00:26:37.522
g, I want to see how g
compares to cube root of r.

00:26:37.522 --> 00:26:38.230
How do I do this?

00:26:41.870 --> 00:26:49.440
So this is equivalent to
g cubed compared to r.

00:26:49.440 --> 00:26:54.029
g cubed is to multiplication,
so I know how to do that.

00:26:54.029 --> 00:26:54.529
OK?

00:27:00.120 --> 00:27:01.120
Make sense for everyone?

00:27:04.460 --> 00:27:07.060
Sorry, r.

00:27:07.060 --> 00:27:07.560
My bad.

00:27:11.700 --> 00:27:14.800
So this is going to be one
digit in base, B, so hopefully

00:27:14.800 --> 00:27:17.740
not too much work.

00:27:17.740 --> 00:27:18.720
OK.

00:27:18.720 --> 00:27:21.234
But remember this, you can;t
do the comparison directly

00:27:21.234 --> 00:27:22.900
because you can't
compute this directly.

00:27:22.900 --> 00:27:26.730
So you need to do it this way.

00:27:26.730 --> 00:27:30.197
AUDIENCE: So r is just the
first digit of the number?

00:27:30.197 --> 00:27:30.822
PROFESSOR: Yep.

00:27:35.260 --> 00:27:37.510
So we're going for a
slightly easier problem.

00:27:37.510 --> 00:27:40.570
We're trying to compute the cube
root of a single digit number

00:27:40.570 --> 00:27:44.360
to an arbitrary precision.

00:27:44.360 --> 00:27:46.810
You can make it harder, but
there's no point right now.

00:27:46.810 --> 00:27:48.140
So we'll stick to this.

00:27:48.140 --> 00:27:50.390
So how much time will this take?

00:27:50.390 --> 00:27:54.070
How many approximations
will I need to do?

00:27:54.070 --> 00:27:56.620
By the way, so suppose I
compute my approximations.

00:27:56.620 --> 00:27:57.120
Right?

00:27:57.120 --> 00:28:02.300
So I compute x0, x1, x2,
x3, so on and so forth.

00:28:02.300 --> 00:28:04.970
When do I stop?

00:28:04.970 --> 00:28:07.265
AUDIENCE: When both
digits are the same?

00:28:07.265 --> 00:28:08.890
PROFESSOR: All the
digits are the same.

00:28:08.890 --> 00:28:15.120
So when one approximation is
the same with the next one.

00:28:15.120 --> 00:28:15.990
That's what you're?

00:28:15.990 --> 00:28:16.490
Right.

00:28:19.170 --> 00:28:20.640
So these are all integers.

00:28:20.640 --> 00:28:22.802
The moment I get two
identical integers,

00:28:22.802 --> 00:28:24.760
I know there's no point
to continue because I'm

00:28:24.760 --> 00:28:27.300
going to get the
same value forever.

00:28:27.300 --> 00:28:29.360
Also this means
that Newton's method

00:28:29.360 --> 00:28:30.770
has converged on this integer.

00:28:30.770 --> 00:28:32.530
So hopefully I will
get the answer,

00:28:32.530 --> 00:28:37.150
which I can convert
into the right answer.

00:28:37.150 --> 00:28:39.050
OK so how fast does this work?

00:28:39.050 --> 00:28:40.740
What is n?

00:28:40.740 --> 00:28:43.740
When am I going to stop?

00:28:43.740 --> 00:28:46.215
AUDIENCE: Log base 2 of d?

00:28:46.215 --> 00:28:49.185
PROFESSOR: OK.

00:28:49.185 --> 00:28:59.100
So n is-- so the number of
digits in my approximation--

00:28:59.100 --> 00:29:02.690
the number of correct
digits-- doubles every time.

00:29:02.690 --> 00:29:05.600
So after log these steps,
I have the right answer.

00:29:05.600 --> 00:29:09.420
Now what if instead of doing
this I did binary search?

00:29:09.420 --> 00:29:14.640
So instead of doing Newton's
method I do binary search on 0

00:29:14.640 --> 00:29:15.866
to r?

00:29:15.866 --> 00:29:16.740
I can do that, right?

00:29:16.740 --> 00:29:19.040
Because I can get
a guess and then

00:29:19.040 --> 00:29:24.117
I can use this to see if
my guess is right or wrong.

00:29:24.117 --> 00:29:25.950
So in theory I could
do it in binary search.

00:29:25.950 --> 00:29:27.100
How fast would that be?

00:29:27.100 --> 00:29:28.600
AUDIENCE: And what
is the difference

00:29:28.600 --> 00:29:29.724
between big r and little r?

00:29:32.350 --> 00:29:34.895
PROFESSOR: Big R is-- oh,
I didn't write the big r.

00:29:34.895 --> 00:29:35.896
Big r is this guy, here.

00:29:35.896 --> 00:29:36.936
AUDIENCE: Oh, OK, gotcha.

00:29:36.936 --> 00:29:37.830
OK.

00:29:37.830 --> 00:29:39.220
PROFESSOR: And this is little r.

00:29:39.220 --> 00:29:39.880
Sorry.

00:29:39.880 --> 00:29:42.550
Good question, I
apologize for that.

00:29:42.550 --> 00:29:47.960
So R is little r
times B to the 3d.

00:29:47.960 --> 00:29:51.400
AUDIENCE: D times log 2 of B--

00:29:51.400 --> 00:29:52.400
AUDIENCE: To the d.

00:29:52.400 --> 00:29:53.164
Log r to the d.

00:29:53.164 --> 00:29:54.580
AUDIENCE: Oh, it's
the same thing.

00:29:54.580 --> 00:29:55.540
Right.

00:29:55.540 --> 00:29:58.400
AUDIENCE: Yeah.

00:29:58.400 --> 00:29:58.900
On the y.

00:30:02.760 --> 00:30:09.110
PROFESSOR: OK so the
number of guesses is

00:30:09.110 --> 00:30:10.410
AUDIENCE: Log big r.

00:30:10.410 --> 00:30:12.440
PROFESSOR: Log big r.

00:30:12.440 --> 00:30:19.170
And someone was one step ahead
and said it's order of B times

00:30:19.170 --> 00:30:21.710
log little r.

00:30:21.710 --> 00:30:25.300
Or I think it's d plus little r.

00:30:25.300 --> 00:30:30.590
So this is order of d.

00:30:30.590 --> 00:30:32.928
Does this make
sense for everyone?

00:30:32.928 --> 00:30:36.704
AUDIENCE: I didn't quite
follow what happened there.

00:30:36.704 --> 00:30:38.870
PROFESSOR: So I'm doing a
binary search on the range

00:30:38.870 --> 00:30:40.540
from 0 to r.

00:30:40.540 --> 00:30:41.240
How many steps?

00:30:41.240 --> 00:30:43.018
How many guesses?

00:30:43.018 --> 00:30:43.946
Log r.

00:30:43.946 --> 00:30:44.470
Right?

00:30:44.470 --> 00:30:47.750
This is binary search.

00:30:47.750 --> 00:30:53.620
R is little r times b to the 3d.

00:30:53.620 --> 00:31:00.420
So if we log this,
log R is log little r

00:31:00.420 --> 00:31:10.760
plus 3d log B. B is order
one, so we get order of log B.

00:31:10.760 --> 00:31:14.300
OK so Newton's method
is exponentially faster

00:31:14.300 --> 00:31:17.920
in terms of the number of digits
compared to binary search.

00:31:17.920 --> 00:31:20.630
So if you can pull it
off with Newton's method

00:31:20.630 --> 00:31:22.370
and you have big
numbers, you probably

00:31:22.370 --> 00:31:24.299
want to use Newton's method.

00:31:24.299 --> 00:31:26.590
Because binary search will
give you a slower algorithm.

00:31:30.238 --> 00:31:32.420
OK, how are we doing
with these concepts?

00:31:37.480 --> 00:31:39.530
I see everyone's unhappy.

00:31:39.530 --> 00:31:41.430
Is it because of Newton
or something I said?

00:31:41.430 --> 00:31:43.770
AUDIENCE: Can you
summarize the difference

00:31:43.770 --> 00:31:45.520
between binary search
and Newton's, again?

00:31:45.520 --> 00:31:47.930
So you said binary
search takes kind

00:31:47.930 --> 00:31:50.060
of long versus Newton's method.

00:31:50.060 --> 00:31:50.790
PROFESSOR: OK.

00:31:50.790 --> 00:31:53.391
So how do you do binary search?

00:31:53.391 --> 00:31:55.140
AUDIENCE: Divide and
conquer, which is--

00:31:55.140 --> 00:31:56.681
PROFESSOR: Divide
and conquer, right?

00:31:56.681 --> 00:31:59.459
You start out with an interval,
you guess somewhere in half,

00:31:59.459 --> 00:32:02.000
and then you see which half of
the interval you recurse onto.

00:32:02.000 --> 00:32:05.040
And your interval halves
in size every time.

00:32:05.040 --> 00:32:08.700
So given the initial size of the
interval, the number of guesses

00:32:08.700 --> 00:32:12.350
you have is log of
that interval size.

00:32:12.350 --> 00:32:16.410
In this case we're guessing
a number between 0 and r.

00:32:16.410 --> 00:32:18.975
So the big goal is to
compute cube root of R.

00:32:18.975 --> 00:32:21.100
And we're guessing that
hey, it has to be somewhere

00:32:21.100 --> 00:32:25.250
between 0 and R. So we're going
to do binary search on this.

00:32:25.250 --> 00:32:28.340
And in order to see
how our guess compares,

00:32:28.340 --> 00:32:31.031
we're going to use
this trick, here.

00:32:33.740 --> 00:32:37.640
So the number of guesses
we make is log R. Now

00:32:37.640 --> 00:32:39.900
R is that number, over there.

00:32:39.900 --> 00:32:43.070
It's little r times B to the 3d.

00:32:43.070 --> 00:32:44.520
So how many digits does it have?

00:32:44.520 --> 00:32:47.530
Roughly d digits.

00:32:47.530 --> 00:32:50.390
So log of R is
going to be order d.

00:32:53.650 --> 00:32:57.600
OK so if you do binary search
to guess a d digit number,

00:32:57.600 --> 00:32:59.780
the running time will
be roughly order d.

00:32:59.780 --> 00:33:02.200
Order of the number of digits.

00:33:02.200 --> 00:33:05.150
If you use Newton's
method and your function

00:33:05.150 --> 00:33:06.600
is good and
everything converges,

00:33:06.600 --> 00:33:08.400
then you have
quadratic convergence.

00:33:08.400 --> 00:33:11.840
Which guarantees that you'll
have log of d guesses.

00:33:11.840 --> 00:33:14.080
Log of d approximations.

00:33:14.080 --> 00:33:16.780
So Newton's method is a
lot faster for big numbers,

00:33:16.780 --> 00:33:20.450
because you have a log
there instead of d.

00:33:20.450 --> 00:33:22.810
So this is the big
difference between them.

00:33:22.810 --> 00:33:24.680
But for Newton, you
need a lot of things.

00:33:24.680 --> 00:33:24.870
Right?

00:33:24.870 --> 00:33:26.953
You need that function,
you need an initial guess,

00:33:26.953 --> 00:33:29.900
you need a lot of
things to make it work.

00:33:29.900 --> 00:33:30.400
Yes?

00:33:30.400 --> 00:33:32.858
AUDIENCE: So is that just like
the number of times it runs?

00:33:32.858 --> 00:33:35.985
Because don't you have a
multiplication and a division?

00:33:35.985 --> 00:33:36.610
PROFESSOR: Yep.

00:33:36.610 --> 00:33:38.830
So this is the
number of guesses.

00:33:38.830 --> 00:33:40.720
The total running time
is quite different.

00:33:40.720 --> 00:33:43.136
You need to jump through a few
more hoops to analyze that.

00:33:43.136 --> 00:33:48.280
But this is the number of
guesses or approximations

00:33:48.280 --> 00:33:51.362
that each method makes.

00:33:51.362 --> 00:33:52.820
So if your math
would be order one,

00:33:52.820 --> 00:33:54.111
this would be the running time.

00:33:54.111 --> 00:33:59.150
If the math isn't order one,
then it gets more complicated.

00:33:59.150 --> 00:34:02.432
AUDIENCE: So what's the
running time of a division?

00:34:02.432 --> 00:34:04.640
PROFESSOR: What is running
time of the division using

00:34:04.640 --> 00:34:07.750
Newton's method?

00:34:07.750 --> 00:34:10.309
It's the same as the running
time of the multiplication

00:34:10.309 --> 00:34:12.350
that you're using to
compute your approximations.

00:34:14.949 --> 00:34:17.889
And it's like two pages
of notes to prove that.

00:34:17.889 --> 00:34:20.764
So let's not go over that now.

00:34:20.764 --> 00:34:22.889
But the idea is that every
time you're multiplying,

00:34:22.889 --> 00:34:24.409
you start multiplying
small numbers

00:34:24.409 --> 00:34:26.590
and the numbers double in size
when you're multiplying them.

00:34:26.590 --> 00:34:28.214
So only the last
multiplication counts.

00:34:28.214 --> 00:34:30.420
All the others are
tiny compared to that.

00:34:34.679 --> 00:34:35.305
OK.

00:34:35.305 --> 00:34:36.429
Anything else about Newton?

00:34:43.110 --> 00:34:44.840
Sorry guys, we have
Newton on the exam

00:34:44.840 --> 00:34:46.090
so we have to go through this.

00:34:46.090 --> 00:34:49.900
Let's go through some
fun graph problems.

00:34:49.900 --> 00:34:54.507
OK so we kicked off these two.

00:34:54.507 --> 00:34:56.465
Graphs the BFS edges and
graph transformations.

00:35:07.532 --> 00:35:09.490
OK I'm going to do a
graph transformation first

00:35:09.490 --> 00:35:12.166
because I think that's
more useful than BFS edges,

00:35:12.166 --> 00:35:13.790
but hopefully I'm
going to get to both.

00:35:25.650 --> 00:35:28.460
So suppose I have a graph.

00:35:28.460 --> 00:35:31.220
Each path is either red or blue.

00:35:35.110 --> 00:35:38.440
By the way, no political
connection whatsoever.

00:35:38.440 --> 00:35:40.410
And you have weights
on each path.

00:35:47.280 --> 00:35:52.430
So we want a path from S to T
with the following constraint.

00:35:52.430 --> 00:35:55.650
So these weights are
the costs of, maybe,

00:35:55.650 --> 00:35:59.250
how much gas you're
spending to go on that road.

00:35:59.250 --> 00:36:01.977
So in order to switch from
a red edge to a blue edge,

00:36:01.977 --> 00:36:03.310
you also have to pay some money.

00:36:03.310 --> 00:36:06.620
You have to pay a cost of 5.

00:36:06.620 --> 00:36:08.920
So if you're going
to go-- if you're

00:36:08.920 --> 00:36:12.520
going to go from S
to A-- let's call

00:36:12.520 --> 00:36:16.790
this guy A-- if you're
going to go this way,

00:36:16.790 --> 00:36:23.220
then your total cost is 3, 1, 4.

00:36:23.220 --> 00:36:28.600
If you're going to go from S
to B, then if you go this way,

00:36:28.600 --> 00:36:31.620
your total cost is
going to be 3 plus 1

00:36:31.620 --> 00:36:35.380
plus 5 for switching from
a red to a blue edge.

00:36:35.380 --> 00:36:38.640
So the cost for switching
from red to blue is 5.

00:36:38.640 --> 00:36:42.602
The cost for switching
from blue to red is 5.

00:36:42.602 --> 00:36:44.393
And I'll let you guys
think of it for a bit

00:36:44.393 --> 00:36:45.393
while I erase the board.

00:37:09.030 --> 00:37:13.090
AUDIENCE: What's your goal in
playing the best path from--

00:37:13.090 --> 00:37:16.025
PROFESSOR: Best path from S
to T. Smallest total cost.

00:37:16.025 --> 00:37:16.566
AUDIENCE: OK.

00:37:26.030 --> 00:37:28.840
PROFESSOR: So any thoughts?

00:37:28.840 --> 00:37:31.289
Yes.

00:37:31.289 --> 00:37:33.245
AUDIENCE: It's
kind of on the run,

00:37:33.245 --> 00:37:38.135
but create a supernode
connect all the red paths.

00:37:38.135 --> 00:37:41.069
And create another one
connecting all the blue paths.

00:37:41.069 --> 00:37:45.470
And then try to find the
shortest length to T just using

00:37:45.470 --> 00:37:49.140
those two graphs, I guess.

00:37:49.140 --> 00:37:50.640
PROFESSOR: So you're
going to create

00:37:50.640 --> 00:37:52.780
a supernode
connecting the paths.

00:37:52.780 --> 00:37:55.006
So how does this work?

00:37:55.006 --> 00:38:02.476
AUDIENCE: You create
the path from S

00:38:02.476 --> 00:38:04.470
to T just using the reds.

00:38:04.470 --> 00:38:07.060
PROFESSOR: OK so I'm going
to copy everything and use

00:38:07.060 --> 00:38:08.970
the reds.

00:38:08.970 --> 00:38:18.170
So S, C, D, T, and I'm
only going to use the reds.

00:38:18.170 --> 00:38:23.806
All right, red, red, red.

00:38:27.300 --> 00:38:29.470
OK.

00:38:29.470 --> 00:38:33.470
AUDIENCE: And then-- wait,
is that all the right paths?

00:38:33.470 --> 00:38:35.858
PROFESSOR: I hope so.

00:38:35.858 --> 00:38:37.358
AUDIENCE: All right,
and then you're

00:38:37.358 --> 00:38:41.380
going to try doing that
with the blue paths as well.

00:38:41.380 --> 00:38:45.326
PROFESSOR: So am I creating
another copy of this?

00:38:45.326 --> 00:38:46.080
AUDIENCE: Yeah.

00:38:46.080 --> 00:38:46.663
PROFESSOR: OK.

00:38:59.571 --> 00:39:01.050
Let's see, what else, what else?

00:39:08.940 --> 00:39:13.122
OK

00:39:13.122 --> 00:39:14.978
AUDIENCE: From S to T, right?

00:39:14.978 --> 00:39:16.230
PROFESSOR: A path from S to T?

00:39:16.230 --> 00:39:21.564
AUDIENCE: Yeah, so you
just compare the path of S

00:39:21.564 --> 00:39:23.556
to the path of T.
So you completely

00:39:23.556 --> 00:39:27.540
take that out, the
additional cost [INAUDIBLE]

00:39:27.540 --> 00:39:29.282
just by comparing
those two and seeing

00:39:29.282 --> 00:39:30.688
which ones are
the shortest path.

00:39:30.688 --> 00:39:32.271
AUDIENCE: It's correct
for this graph,

00:39:32.271 --> 00:39:35.010
but it's not correct in general.

00:39:35.010 --> 00:39:37.520
[INTERPOSING VOICES]

00:39:37.520 --> 00:39:42.510
AUDIENCE: And the last
option would be combining--

00:39:42.510 --> 00:39:44.559
PROFESSOR: OK so if
I do this so far.

00:39:44.559 --> 00:39:47.100
So I've taken the original graph
and I've created two copies.

00:39:47.100 --> 00:39:48.520
One that has all
of the red paths,

00:39:48.520 --> 00:39:50.007
one that has all the blue paths.

00:39:50.007 --> 00:39:51.254
AUDIENCE: Right.

00:39:51.254 --> 00:39:52.920
PROFESSOR: By the
way, let's label this.

00:39:52.920 --> 00:39:54.760
The nodes are--

00:39:54.760 --> 00:39:56.760
AUDIENCE: So it would
work in this specific case

00:39:56.760 --> 00:40:00.700
because you [INAUDIBLE].

00:40:00.700 --> 00:40:03.390
PROFESSOR: So if you compute
the two shortest paths here,

00:40:03.390 --> 00:40:06.820
you'll get the path using only
reds, path using only blues.

00:40:06.820 --> 00:40:09.090
But you're not
expressing the fact

00:40:09.090 --> 00:40:12.580
that you're allowed to alternate
between reds and blues.

00:40:12.580 --> 00:40:14.190
How do you express that?

00:40:14.190 --> 00:40:16.110
AUDIENCE: Make a
lot of corrections.

00:40:16.110 --> 00:40:17.920
AUDIENCE: Put two layers in--

00:40:17.920 --> 00:40:18.900
PROFESSOR: Two layers.

00:40:18.900 --> 00:40:20.110
OK so these are two layers.

00:40:20.110 --> 00:40:24.240
This is the red layer, and
this is the blue layer.

00:40:27.370 --> 00:40:29.380
And how do I connect them?

00:40:29.380 --> 00:40:31.340
AUDIENCE: If there's
an edge connecting them

00:40:31.340 --> 00:40:35.750
on the upper graph, we're
just connecting them.

00:40:35.750 --> 00:40:38.220
AUDIENCE: Or connect
the respective nodes

00:40:38.220 --> 00:40:40.279
and make it a 5.

00:40:40.279 --> 00:40:41.695
PROFESSOR: Both
answers work, they

00:40:41.695 --> 00:40:43.000
have the same number of edges.

00:40:43.000 --> 00:40:44.930
The last answer is
easier to visualize,

00:40:44.930 --> 00:40:47.000
so I'm going to go with that.

00:40:47.000 --> 00:40:49.420
So I can go from the red
world to the blue world,

00:40:49.420 --> 00:40:51.190
and back, if I'm
willing to pay 5.

00:40:55.690 --> 00:40:56.615
So this is what--

00:41:02.842 --> 00:41:07.261
AUDIENCE: And you just use
those with the new edges.

00:41:07.261 --> 00:41:09.426
Or not DFS, but Dijkstra's.

00:41:09.426 --> 00:41:12.050
PROFESSOR: All right so all the
edges here are positive, right?

00:41:12.050 --> 00:41:13.523
So I'm going to use Dijkstra.

00:41:18.360 --> 00:41:20.564
AUDIENCE: Is there any
case in a positive graph

00:41:20.564 --> 00:41:24.860
that Dijkstra's slower
than Bellman-Ford?

00:41:24.860 --> 00:41:27.681
Because one is like b log b,
and the other one is like b e.

00:41:27.681 --> 00:41:28.180
Right?

00:41:28.180 --> 00:41:29.860
So if you have a lot of--

00:41:29.860 --> 00:41:31.502
PROFESSOR: OK so
what is Dijkstra?

00:41:31.502 --> 00:41:32.980
AUDIENCE: B log b-

00:41:32.980 --> 00:41:34.132
PROFESSOR: Almost.

00:41:34.132 --> 00:41:36.020
AUDIENCE: T log
b, I think, right?

00:41:36.020 --> 00:41:39.170
That's the theoretical
best case ever,

00:41:39.170 --> 00:41:42.569
PROFESSOR: So actually,
the theoretical is E plus--

00:41:42.569 --> 00:41:44.068
AUDIENCE: Yeah,
that's what I meant.

00:41:44.068 --> 00:41:45.042
AUDIENCE: Oh.

00:41:45.042 --> 00:41:45.770
Oh--

00:41:45.770 --> 00:41:47.561
PROFESSOR: This is what
you get with heaps,

00:41:47.561 --> 00:41:50.722
so this is what we
got in the P set.

00:41:50.722 --> 00:41:52.500
AUDIENCE: What
was the first one?

00:41:52.500 --> 00:41:55.375
AUDIENCE: The first one
is like Fibonacci heaps.

00:41:55.375 --> 00:41:57.000
It's got a really
high constant factor,

00:41:57.000 --> 00:41:59.160
so you never actually use it.

00:41:59.160 --> 00:42:01.400
PROFESSOR: So this is a
nice theoretical thing,

00:42:01.400 --> 00:42:03.680
and this is what
you get in practice.

00:42:03.680 --> 00:42:06.100
If you use the
regular binary heaps.

00:42:06.100 --> 00:42:08.290
And so you compare
this to Bellman-Ford

00:42:08.290 --> 00:42:16.340
which is-- whoops--
V times E. I'm

00:42:16.340 --> 00:42:19.410
going to guess that this
is faster no matter what.

00:42:19.410 --> 00:42:21.110
AUDIENCE: Yes, OK.

00:42:21.110 --> 00:42:25.660
So the theoretical one could
be slower, then, possible.

00:42:25.660 --> 00:42:28.430
The Fibonacci one?

00:42:28.430 --> 00:42:32.499
Because if you have a ton of
vertices without many edges.

00:42:32.499 --> 00:42:34.290
PROFESSOR: OK If you
have a ton of vertices

00:42:34.290 --> 00:42:35.580
but not too many edges.

00:42:35.580 --> 00:42:36.590
AUDIENCE: Yeah.

00:42:36.590 --> 00:42:38.500
PROFESSOR: Then you're
saying that this

00:42:38.500 --> 00:42:42.122
is going to be bigger than--
so what do you do in that case?

00:42:42.122 --> 00:42:45.129
AUDIENCE: I mean you could just
ignore the vertices, I guess.

00:42:45.129 --> 00:42:46.670
PROFESSOR: OK so if
you have a ton of

00:42:46.670 --> 00:42:48.070
vertices and not
that many edges.

00:42:48.070 --> 00:42:51.790
So if you have edges
smaller-- sorry-- yeah,

00:42:51.790 --> 00:42:53.750
it's just smaller
than vertices, then

00:42:53.750 --> 00:42:56.070
some vertices have
to be unconnected.

00:42:56.070 --> 00:42:57.091
So what to do?

00:42:57.091 --> 00:42:58.382
AUDIENCE: You just ignore them.

00:42:58.382 --> 00:42:59.380
AUDIENCE: You're not going
to reach them anyway.

00:42:59.380 --> 00:43:00.930
PROFESSOR: How do
you ignore them?

00:43:00.930 --> 00:43:01.730
How do you ignore them in--

00:43:01.730 --> 00:43:02.750
AUDIENCE: Oh, I see your point.

00:43:02.750 --> 00:43:04.624
So you're never going
to get to them anyways.

00:43:04.624 --> 00:43:05.125
So--

00:43:05.125 --> 00:43:07.207
AUDIENCE: Well no, but
once you've started at one,

00:43:07.207 --> 00:43:08.888
you're going to have
to touch them all.

00:43:08.888 --> 00:43:11.260
They're all going
to be in the heap.

00:43:11.260 --> 00:43:12.240
Yeah.

00:43:12.240 --> 00:43:13.906
AUDIENCE: No, don't
put them in the heap

00:43:13.906 --> 00:43:16.620
until you look at them.

00:43:16.620 --> 00:43:19.210
AUDIENCE: Well, there's
a starting point, right?

00:43:19.210 --> 00:43:21.710
If you can't go anywhere in the
starting point, you're done.

00:43:21.710 --> 00:43:26.704
PROFESSOR: OK so you take the
starting point and you do--

00:43:26.704 --> 00:43:28.090
[INTERPOSING VOICES]

00:43:28.090 --> 00:43:31.740
PROFESSOR: Ok so I would take
the starting point and do a BFS

00:43:31.740 --> 00:43:33.850
and ignore everything else.

00:43:33.850 --> 00:43:37.355
And that is clearly order of
how many vertices and edges that

00:43:37.355 --> 00:43:38.590
are reachable from that.

00:43:38.590 --> 00:43:41.310
So that will give
you a nice graph.

00:43:41.310 --> 00:43:43.570
Either that, or if you
initialization your Dijkstra

00:43:43.570 --> 00:43:45.765
carefully enough, this
actually only reflects

00:43:45.765 --> 00:43:48.630
the reachable
edges and vertices.

00:43:48.630 --> 00:43:50.610
So you never have this.

00:43:50.610 --> 00:43:52.730
So either one works.

00:43:52.730 --> 00:43:55.235
In theory mode, it might be
better to say I'll do a BFS

00:43:55.235 --> 00:43:57.210
and reduce the graph.

00:43:57.210 --> 00:43:58.826
Because that's easier to argue.

00:43:58.826 --> 00:43:59.326
Yes.

00:43:59.326 --> 00:44:03.830
AUDIENCE: So, for
this, when you make all

00:44:03.830 --> 00:44:06.714
that-- I guess my
question is are we

00:44:06.714 --> 00:44:09.410
going to be asked to
talk about running times

00:44:09.410 --> 00:44:10.880
for different transformation?

00:44:10.880 --> 00:44:12.772
Or the algorithms?

00:44:12.772 --> 00:44:14.730
PROFESSOR: Well so at
the very least, last time

00:44:14.730 --> 00:44:17.430
we said, this is the problem.

00:44:17.430 --> 00:44:19.560
Give us an algorithm
with this running time.

00:44:19.560 --> 00:44:19.840
AUDIENCE: Right.

00:44:19.840 --> 00:44:21.548
PROFESSOR: So you have
to be able to know

00:44:21.548 --> 00:44:22.470
your transformations.

00:44:22.470 --> 00:44:24.636
So not the running for
computing the transformation,

00:44:24.636 --> 00:44:27.650
but you have to be able to know
how much bigger the graph gets

00:44:27.650 --> 00:44:29.811
and what that implies
for the running time.

00:44:29.811 --> 00:44:31.810
Turns out that usually
for these transformations

00:44:31.810 --> 00:44:33.310
you can compute
them in linear time.

00:44:33.310 --> 00:44:35.330
So the time for computing
a transformation

00:44:35.330 --> 00:44:37.190
is much smaller than
the time for running

00:44:37.190 --> 00:44:38.450
Dijkstra or Bellman-Ford.

00:44:38.450 --> 00:44:43.312
So that's why we don't
really go into that.

00:44:43.312 --> 00:44:45.440
This one is definitely
linear time.

00:44:45.440 --> 00:44:50.030
So what happens to the
graph in this case?

00:44:50.030 --> 00:44:52.503
Number of edges and
number of vertices.

00:44:52.503 --> 00:44:54.868
AUDIENCE: Number of
edges increases by V

00:44:54.868 --> 00:44:56.760
and number of vertices.

00:44:56.760 --> 00:44:59.130
So increase by V.

00:44:59.130 --> 00:45:02.692
PROFESSOR: That's
V, and times is 2.

00:45:02.692 --> 00:45:04.650
So you plug this into
Bellman-Ford or Dijkstra,

00:45:04.650 --> 00:45:06.290
you find out the
new running time.

00:45:06.290 --> 00:45:08.990
So every time you see what is
the size of your new graph,

00:45:08.990 --> 00:45:10.531
and you plug that
into the algorithm.

00:45:14.354 --> 00:45:16.020
OK so what is the
intuition behind this?

00:45:16.020 --> 00:45:17.370
Did everyone get this problem?

00:45:20.530 --> 00:45:22.530
So it's the old problem
that we're going through

00:45:22.530 --> 00:45:26.050
again and again, where you
have a graph that's 2D,

00:45:26.050 --> 00:45:28.977
and we want to compute
something that Dijkstra

00:45:28.977 --> 00:45:30.060
can't compute on it's own.

00:45:30.060 --> 00:45:32.680
Or that Bellman-Ford
can't compute on it's own.

00:45:32.680 --> 00:45:34.800
So in order to be able
to compute those things,

00:45:34.800 --> 00:45:37.350
we need to add additional
states to the graph.

00:45:37.350 --> 00:45:39.720
And the way we do that is
we make copies of the graph

00:45:39.720 --> 00:45:40.590
that we call layers.

00:45:40.590 --> 00:45:44.550
Because we're thinking that if
you take that 2D map, and you

00:45:44.550 --> 00:45:46.330
create copies of
it, you basically

00:45:46.330 --> 00:45:49.760
have a 3D graph where there
is the original graph.

00:45:52.560 --> 00:45:54.520
That's the science part
of the problem, the art

00:45:54.520 --> 00:45:57.150
part of solving the
problem is figuring out

00:45:57.150 --> 00:45:59.550
what those layers are
and how you connect them.

00:45:59.550 --> 00:46:01.880
Because by doing that you
can solve a ton of problems,

00:46:01.880 --> 00:46:05.310
as we have seen in this class.

00:46:05.310 --> 00:46:07.760
AUDIENCE: Is there a
possibility that you

00:46:07.760 --> 00:46:09.991
have a very large
number of layers needed

00:46:09.991 --> 00:46:14.598
to be permutations
of-- different choice

00:46:14.598 --> 00:46:17.286
to make instead of
just a red or a blue?

00:46:17.286 --> 00:46:18.190
PROFESSOR: Yep.

00:46:18.190 --> 00:46:21.536
So is there a problem where
we had a ton of layers?

00:46:21.536 --> 00:46:22.160
AUDIENCE: Mhmm.

00:46:22.160 --> 00:46:23.430
PROFESSOR: Yep.

00:46:23.430 --> 00:46:25.220
OK so two problems, right?

00:46:25.220 --> 00:46:26.942
AUDIENCE: One for every second.

00:46:26.942 --> 00:46:28.810
[LAUGHS]

00:46:28.810 --> 00:46:31.876
PROFESSOR: And so these
are the layers, presumably.

00:46:31.876 --> 00:46:33.750
We had two problems that
had a ton of layers.

00:46:33.750 --> 00:46:35.208
One of them was
the highway problem

00:46:35.208 --> 00:46:37.070
where you had timetables.

00:46:37.070 --> 00:46:39.172
And there, the number
of layers was the number

00:46:39.172 --> 00:46:40.880
of minutes in the day
you're considering.

00:46:40.880 --> 00:46:44.010
So roughly, 1440.

00:46:44.010 --> 00:46:47.410
And the other one was StarCraft
where the number of layers

00:46:47.410 --> 00:46:50.400
was something ginormous, right?

00:46:50.400 --> 00:46:53.106
So as long as that fits
the theory, that's fine.

00:46:53.106 --> 00:46:55.730
As long as the number of layers
fits whatever the problem wants

00:46:55.730 --> 00:46:57.894
you to compute, its OK.

00:46:57.894 --> 00:47:01.303
AUDIENCE: So transforming
another layer,

00:47:01.303 --> 00:47:07.150
is that like in V time because
copying the number of vertices?

00:47:07.150 --> 00:47:09.946
PROFESSOR: Yeah,
so you should be

00:47:09.946 --> 00:47:12.640
able to implement this in
order of V plus E, which

00:47:12.640 --> 00:47:15.670
is what you need to output
the new graph description.

00:47:15.670 --> 00:47:19.405
I claim that for this you can.

00:47:19.405 --> 00:47:24.240
AUDIENCE: So for E prime, I
guess, how'd you get that?

00:47:24.240 --> 00:47:26.375
PROFESSOR: So for
each vertex you

00:47:26.375 --> 00:47:29.610
are going to create a
red copy and a blue copy.

00:47:29.610 --> 00:47:31.080
2V, this is easy.

00:47:31.080 --> 00:47:34.770
Now, the red edges stay in here,
the blue edges stay in here.

00:47:34.770 --> 00:47:36.540
So nothing changed so far.

00:47:36.540 --> 00:47:39.280
But each red vertex needs to
be connected to the blue vertex

00:47:39.280 --> 00:47:42.320
by an edge of weight 5.

00:47:42.320 --> 00:47:46.280
So that means that we're going
to copy over the original edges

00:47:46.280 --> 00:47:49.656
and we're going to add the
edges that connect the vertices.

00:47:49.656 --> 00:47:51.520
AUDIENCE: [INAUDIBLE].

00:47:51.520 --> 00:47:53.770
PROFESSOR: So we're not going
to ask about the running

00:47:53.770 --> 00:47:55.450
time of the
transformations in general.

00:47:55.450 --> 00:47:57.990
Because we assume that they
can be done in linear time.

00:47:57.990 --> 00:48:01.150
But you need to at least have a
sense of whether your graph is

00:48:01.150 --> 00:48:02.880
going to double,
whether it's going

00:48:02.880 --> 00:48:06.060
to increase exponentially, or
what's going to happen to it.

00:48:06.060 --> 00:48:08.100
So let's make a small
tweak to this problem.

00:48:08.100 --> 00:48:10.150
Suppose that the
instead of having this,

00:48:10.150 --> 00:48:13.460
I can go from red to
blue, but once I've

00:48:13.460 --> 00:48:16.360
gone from red to
blue, I can't go back.

00:48:16.360 --> 00:48:20.850
So I can start out either red
or blue, I can go red to blue,

00:48:20.850 --> 00:48:23.794
but once I'm in blue I
can't go back to red.

00:48:23.794 --> 00:48:25.522
AUDIENCE: Make those
directed edges.

00:48:25.522 --> 00:48:27.390
PROFESSOR: From where to where?

00:48:27.390 --> 00:48:28.785
AUDIENCE: Red to blue.

00:48:32.510 --> 00:48:36.600
PROFESSOR: OK so this is
how I express constraints,

00:48:36.600 --> 00:48:39.570
in constraints among layers.

00:48:39.570 --> 00:48:42.540
Before, we had two
layers, red and blue.

00:48:42.540 --> 00:48:45.216
And we connected them by
an edge of weight 5, which

00:48:45.216 --> 00:48:47.090
says you can go from
red world to blue world,

00:48:47.090 --> 00:48:50.460
and back, all you
have to do is pay 5.

00:48:50.460 --> 00:48:53.510
If we have directed edges,
then this is a constraint.

00:48:53.510 --> 00:48:56.690
If the constraint
said there's no cost,

00:48:56.690 --> 00:48:58.480
but you can only go
from red to blue,

00:48:58.480 --> 00:49:00.440
you still have to do two layers.

00:49:00.440 --> 00:49:02.790
And keep track of
which layer you're in.

00:49:02.790 --> 00:49:05.060
But then your edge
of the weight 0.

00:49:05.060 --> 00:49:07.440
Since we have to pay,
the edge is weight 5.

00:49:10.590 --> 00:49:12.660
So we can use layers to
express additional costs,

00:49:12.660 --> 00:49:13.960
or just to express constraints.

00:49:17.150 --> 00:49:18.395
Does this make sense?

00:49:18.395 --> 00:49:20.770
AUDIENCE: Does this include
back edges, or forward edges,

00:49:20.770 --> 00:49:21.702
as well?

00:49:21.702 --> 00:49:22.910
PROFESSOR: Let's get to that.

00:49:22.910 --> 00:49:25.320
OK, so does this
make sense so far?

00:49:25.320 --> 00:49:28.330
One more question, what shortest
path do I want to compute here?

00:49:31.054 --> 00:49:34.640
To make sure that
you guys got it.

00:49:34.640 --> 00:49:37.500
AUDIENCE: Oh, you have to
do two of them maybe, four--

00:49:37.500 --> 00:49:39.100
PROFESSOR: OK, I
like four of them.

00:49:39.100 --> 00:49:46.290
So I have to do SR, TR,
SR, TB, SB, TR, SB, TB.

00:49:46.290 --> 00:49:48.066
Fortunately, our
algorithms give us

00:49:48.066 --> 00:49:49.440
the shortest path
from one source

00:49:49.440 --> 00:49:50.648
to all of the other vertices.

00:49:50.648 --> 00:49:54.080
So I'd only have to run
Dijkstra or Bellman-Ford twice.

00:49:54.080 --> 00:49:56.250
What if I want to run
the algorithm once?

00:49:56.250 --> 00:49:57.123
What do I do?

00:49:57.123 --> 00:50:00.020
AUDIENCE: You put
vertices on the edges.

00:50:00.020 --> 00:50:03.530
PROFESSOR: OK so supernode
as a source, supernode

00:50:03.530 --> 00:50:05.550
as a destination.

00:50:05.550 --> 00:50:07.480
And I connect them to what?

00:50:07.480 --> 00:50:09.048
AUDIENCE: Zero weight.

00:50:09.048 --> 00:50:09.964
PROFESSOR: To?

00:50:09.964 --> 00:50:10.880
AUDIENCE: The two.

00:50:10.880 --> 00:50:11.800
AUDIENCE: Final V.

00:50:11.800 --> 00:50:13.700
PROFESSOR: OK, very good.

00:50:13.700 --> 00:50:15.785
And?

00:50:15.785 --> 00:50:16.410
AUDIENCE: Same.

00:50:20.115 --> 00:50:21.490
PROFESSOR: So what
happened here?

00:50:21.490 --> 00:50:24.460
This says you can go anywhere.

00:50:24.460 --> 00:50:26.494
And this says you can
come back from anywhere.

00:50:26.494 --> 00:50:28.864
AUDIENCE: Bridge
between the worlds.

00:50:28.864 --> 00:50:29.812
PROFESSOR: Yep.

00:50:29.812 --> 00:50:32.190
[AUDIENCE LAUGHING]

00:50:32.190 --> 00:50:35.550
PROFESSOR: So do we want this
to be directed or undirected,

00:50:35.550 --> 00:50:37.384
by the way, does it matter?

00:50:37.384 --> 00:50:38.175
AUDIENCE: Directed.

00:50:38.175 --> 00:50:39.231
You can only go one way--

00:50:39.231 --> 00:50:41.730
AUDIENCE: Oh, depends on which
problem you're talking about.

00:50:45.592 --> 00:50:47.300
PROFESSOR: I think if
they're undirected,

00:50:47.300 --> 00:50:49.508
it shouldn't matter too
much, because there shouldn't

00:50:49.508 --> 00:50:54.630
be a path where you go back to
the source and then you switch.

00:50:54.630 --> 00:50:56.510
But this would be
if you're on a quiz

00:50:56.510 --> 00:50:57.884
and you don't want
to think about

00:50:57.884 --> 00:51:00.488
that, I'd make them directed
just to be on the safe side.

00:51:00.488 --> 00:51:01.229
AUDIENCE: What were
the four shortest

00:51:01.229 --> 00:51:02.958
paths you said we
needed to calculate

00:51:02.958 --> 00:51:05.430
for the original problem,
before you added the supernodes?

00:51:05.430 --> 00:51:07.760
PROFESSOR: So we don't
know whether we start out

00:51:07.760 --> 00:51:08.714
with a red edge--

00:51:08.714 --> 00:51:09.380
AUDIENCE: Right.

00:51:09.380 --> 00:51:10.629
PROFESSOR: --with a blue edge.

00:51:10.629 --> 00:51:13.911
We don't know whether we end up
with a red edge or a blue edge.

00:51:13.911 --> 00:51:15.910
AUDIENCE: Stay in red
world, stay in blue world,

00:51:15.910 --> 00:51:17.320
red to blue and blue to red.

00:51:17.320 --> 00:51:21.060
PROFESSOR: Yeah OK, cool.

00:51:21.060 --> 00:51:24.332
So let's talk about BFS and
DFS very briefly, I guess.

00:51:27.110 --> 00:51:28.145
So BFS and DFS.

00:51:31.200 --> 00:51:32.450
What does BFS give us?

00:51:32.450 --> 00:51:35.770
Why is it useful?

00:51:35.770 --> 00:51:37.700
AUDIENCE: Shortest paths.

00:51:37.700 --> 00:51:39.250
PROFESSOR: Shortest
paths in terms

00:51:39.250 --> 00:51:40.410
of number of edges, right?

00:51:40.410 --> 00:51:42.710
No weight on the engines.

00:51:42.710 --> 00:51:52.370
So shortest paths using
the number of edges.

00:51:52.370 --> 00:51:55.770
What does DFS give us?

00:51:55.770 --> 00:51:57.802
AUDIENCE: Topological start.

00:51:57.802 --> 00:51:59.760
PROFESSOR: Hey, man, you
had this on the P set,

00:51:59.760 --> 00:52:00.885
I wouldn't call it nothing.

00:52:05.090 --> 00:52:07.800
OK, how does BFS
look at the graph?

00:52:07.800 --> 00:52:10.810
How does it partition the graph?

00:52:10.810 --> 00:52:12.080
Nodes are grouped into--

00:52:12.080 --> 00:52:12.850
AUDIENCE: Levels.

00:52:12.850 --> 00:52:13.522
PROFESSOR: Levels.

00:52:13.522 --> 00:52:15.355
AUDIENCE: The light
distance and the source.

00:52:17.267 --> 00:52:18.850
PROFESSOR: So you
start with a source,

00:52:18.850 --> 00:52:21.310
and then all the nodes
that are one edge

00:52:21.310 --> 00:52:23.910
away are at level one,
all the nodes that

00:52:23.910 --> 00:52:28.960
are two edges away are level
two, so on and so forth.

00:52:28.960 --> 00:52:30.350
What does DFS give us?

00:52:34.470 --> 00:52:34.970
A mess?

00:52:34.970 --> 00:52:36.760
A mess, right?

00:52:36.760 --> 00:52:39.890
So it gives us edge types.

00:52:43.650 --> 00:52:46.775
And it gives us exit times.

00:52:51.020 --> 00:52:53.415
Exit times are useful for
topological sort, right?

00:52:53.415 --> 00:52:53.915
Yes.

00:52:53.915 --> 00:52:56.770
AUDIENCE: It also
gives us a tree.

00:52:56.770 --> 00:53:00.360
PROFESSOR: OK, does
BFS give us a tree?

00:53:00.360 --> 00:53:01.310
AUDIENCE: Yes.

00:53:01.310 --> 00:53:03.020
AUDIENCE: Yes, they
both give us trees.

00:53:03.020 --> 00:53:04.936
PROFESSOR: So both of
them will give us trees.

00:53:10.380 --> 00:53:11.910
So what are those trees?

00:53:11.910 --> 00:53:16.450
For each node, BFS or
DFS discovered that node

00:53:16.450 --> 00:53:19.880
by going from some parent
node across an edge.

00:53:19.880 --> 00:53:23.610
So that edge belongs to
the BFS or to the DFS tree.

00:53:23.610 --> 00:53:25.170
How do we compute those trees?

00:53:27.948 --> 00:53:29.502
AUDIENCE: Just do it?

00:53:29.502 --> 00:53:31.210
PROFESSOR: So how do
you, in BFS and DFS,

00:53:31.210 --> 00:53:32.697
what do you compute to--

00:53:32.697 --> 00:53:33.780
AUDIENCE: Parent pointers?

00:53:33.780 --> 00:53:35.160
PROFESSOR: Parent pointers.

00:53:35.160 --> 00:53:37.260
So that's what you use
to keep track of them.

00:53:37.260 --> 00:53:38.760
Sorry the question
is bad but that's

00:53:38.760 --> 00:53:42.080
what I want you
to get out of it.

00:53:42.080 --> 00:53:45.090
Parent pointers.

00:53:45.090 --> 00:53:47.620
So DFS and BFS will both
compute trees of the graph.

00:53:47.620 --> 00:53:51.852
Are they the same trees
or different trees?

00:53:51.852 --> 00:53:53.060
AUDIENCE: Probably different.

00:53:53.060 --> 00:53:53.950
PROFESSOR: Different
trees, right?

00:53:53.950 --> 00:53:54.616
Let's take this.

00:53:58.160 --> 00:54:02.470
S, A, B, right?

00:54:02.470 --> 00:54:07.072
BFS will give us this,
DFS will give us this.

00:54:11.140 --> 00:54:15.010
OK, what edge types
do we have in DFS?

00:54:15.010 --> 00:54:16.320
AUDIENCE: Forward edges.

00:54:16.320 --> 00:54:17.530
PROFESSOR: OK, forward.

00:54:17.530 --> 00:54:18.030
Cool.

00:54:18.030 --> 00:54:19.290
What are they?

00:54:19.290 --> 00:54:21.675
AUDIENCE: Those are
just from parent

00:54:21.675 --> 00:54:26.210
to children that
are being presented.

00:54:26.210 --> 00:54:27.430
PROFESSOR: OK.

00:54:27.430 --> 00:54:29.530
AUDIENCE: So, I don't
know how else to put it.

00:54:29.530 --> 00:54:32.460
PROFESSOR: OK so you should
have this on your cheat sheet,

00:54:32.460 --> 00:54:34.104
right?

00:54:34.104 --> 00:54:36.020
If nobody knows the
answer, you should have it

00:54:36.020 --> 00:54:37.620
on your cheat sheet.

00:54:37.620 --> 00:54:43.000
So tree edges, the ones that
show up in the DFS tree.

00:54:43.000 --> 00:54:44.572
Backwards edges,

00:54:44.572 --> 00:54:46.300
AUDIENCE: Cross edges.

00:54:46.300 --> 00:54:47.785
PROFESSOR: Cross edges.

00:54:47.785 --> 00:54:50.330
AUDIENCE: Forward edges.

00:54:50.330 --> 00:54:53.300
PROFESSOR: And forward edges.

00:54:53.300 --> 00:54:56.790
If your graph is undirected,
what types of edges

00:54:56.790 --> 00:54:59.690
do you not have?

00:54:59.690 --> 00:55:01.825
AUDIENCE: Forward edges.

00:55:01.825 --> 00:55:04.740
Forward edges and
backward edges.

00:55:04.740 --> 00:55:06.374
Or no, forward edges.

00:55:10.712 --> 00:55:12.170
PROFESSOR: OK.

00:55:12.170 --> 00:55:14.910
So this is a lecture
notes, and we're

00:55:14.910 --> 00:55:17.680
going to go over them tonight.

00:55:17.680 --> 00:55:20.199
But if you can't make it,
they're in lecture notes.

00:55:20.199 --> 00:55:21.990
So you should have this
on your cheat sheet

00:55:21.990 --> 00:55:24.040
if you don't know them.

00:55:24.040 --> 00:55:24.540
Right?

00:55:24.540 --> 00:55:26.748
Nobody answered today, so
if you guys don't have them

00:55:26.748 --> 00:55:29.700
on your cheat sheet
I will be upset.

00:55:29.700 --> 00:55:32.125
OK.

00:55:32.125 --> 00:55:34.550
Cool.

00:55:34.550 --> 00:55:36.591
More questions?

00:55:36.591 --> 00:55:38.591
AUDIENCE: Edges do not
exist in BFS, edge types?

00:55:41.550 --> 00:55:44.160
PROFESSOR: DFS uses-- so
out of BFS we get levels,

00:55:44.160 --> 00:55:48.390
and out DFS we get
those edge types.

00:55:48.390 --> 00:55:54.360
AUDIENCE: Is there--
about the edge types?

00:55:54.360 --> 00:55:57.400
PROFESSOR: Some algorithms
use them in their proofs.

00:55:57.400 --> 00:55:59.610
So the proof for
topological sort

00:55:59.610 --> 00:56:02.030
uses the fact that in
directed acyclic graphs,

00:56:02.030 --> 00:56:04.360
you won't have some
types of edges.

00:56:04.360 --> 00:56:06.120
For the other types
of edges it argues

00:56:06.120 --> 00:56:08.350
that the order that you
get from topological sort

00:56:08.350 --> 00:56:09.810
is the right order.

00:56:09.810 --> 00:56:12.320
So it's mostly theoretical
but since we taught you

00:56:12.320 --> 00:56:15.295
about edge types, we
might ask you about them.

00:56:15.295 --> 00:56:15.794
Yes.

00:56:15.794 --> 00:56:18.280
AUDIENCE: So does
DFS actually-- is

00:56:18.280 --> 00:56:21.050
it able to distinguish
between back-crossing over,

00:56:21.050 --> 00:56:24.590
or is it only-- does it only
see that the node has already

00:56:24.590 --> 00:56:26.930
been visited by something?

00:56:26.930 --> 00:56:32.559
PROFESSOR: So how would you make
it distinguish between them?

00:56:32.559 --> 00:56:33.350
You have to, right?

00:56:33.350 --> 00:56:35.190
Because otherwise, why
are we studying them?

00:56:35.190 --> 00:56:37.780
There has to be a way to
distinguish between them.

00:56:37.780 --> 00:56:40.604
AUDIENCE: Because the
DFS does recursive calls

00:56:40.604 --> 00:56:43.300
and you know where the back is.

00:56:43.300 --> 00:56:45.690
PROFESSOR: So let's
do a DFS tree quickly.

00:56:51.370 --> 00:56:53.630
So suppose we went like this.

00:56:53.630 --> 00:57:02.140
And then like this,
this, and then this.

00:57:02.140 --> 00:57:06.110
Sorry, I'm trying really hard to
make up an example on the spot

00:57:06.110 --> 00:57:09.028
such that I won't
discount myself.

00:57:17.400 --> 00:57:19.122
How do I get that, do you know?

00:57:19.122 --> 00:57:22.008
AUDIENCE: Maybe an edge
from the second one

00:57:22.008 --> 00:57:25.870
to the last one on the right.

00:57:25.870 --> 00:57:26.670
PROFESSOR: Here?

00:57:26.670 --> 00:57:29.818
AUDIENCE: Yeah and this
will be the arrowhead,

00:57:29.818 --> 00:57:33.467
and you can start
from the second one.

00:57:33.467 --> 00:57:34.300
PROFESSOR: This one?

00:57:34.300 --> 00:57:35.734
AUDIENCE: Yeah.

00:57:35.734 --> 00:57:38.819
Wouldn't that be a forward edge?

00:57:38.819 --> 00:57:39.360
PROFESSOR: OK

00:57:39.360 --> 00:57:39.830
AUDIENCE: Because
it's downward--

00:57:39.830 --> 00:57:41.290
PROFESSOR: Yeah, I like that.

00:57:41.290 --> 00:57:45.010
OK, I like that.

00:57:45.010 --> 00:57:51.770
OK so S, A, B, C,
D, E. So assume

00:57:51.770 --> 00:57:54.930
this is the order that they
listed in adjacency list.

00:57:54.930 --> 00:57:56.940
So let's label all of the edges.

00:57:56.940 --> 00:57:59.236
SA and SB are what?

00:57:59.236 --> 00:58:02.230
AUDIENCE: Forward edges.

00:58:02.230 --> 00:58:06.060
PROFESSOR: OK AC?

00:58:06.060 --> 00:58:08.060
AUDIENCE: Forward.

00:58:08.060 --> 00:58:09.060
PROFESSOR: CD?

00:58:09.060 --> 00:58:10.840
AUDIENCE: Forward.

00:58:10.840 --> 00:58:12.147
PROFESSOR: CE?

00:58:12.147 --> 00:58:13.400
AUDIENCE: Forward.

00:58:13.400 --> 00:58:14.325
PROFESSOR: OK, AE?

00:58:17.035 --> 00:58:18.484
AUDIENCE: Aren't
those tree edges?

00:58:18.484 --> 00:58:21.212
AUDIENCE: That's a forward edge.

00:58:21.212 --> 00:58:22.670
PROFESSOR: That
took a while, guys.

00:58:22.670 --> 00:58:24.602
That took a while.

00:58:24.602 --> 00:58:26.051
AUDIENCE: It goes forward.

00:58:26.051 --> 00:58:28.224
AUDIENCE: Well no,
forward means like you're

00:58:28.224 --> 00:58:29.951
skipping a generation.

00:58:29.951 --> 00:58:31.325
PROFESSOR: OK so
the three edges.

00:58:34.476 --> 00:58:35.760
AUDIENCE: [INAUDIBLE]

00:58:35.760 --> 00:58:37.510
PROFESSOR: So the three
edges are the ones

00:58:37.510 --> 00:58:39.320
that DFS uses to go forward.

00:58:39.320 --> 00:58:41.190
So they're the ones
that map the DFS calls.

00:58:44.100 --> 00:58:45.940
So how do we express that?

00:58:45.940 --> 00:58:52.264
So suppose you're at some node
u, and you have an edge, uv.

00:58:52.264 --> 00:58:54.434
AUDIENCE: The parent of v is u.

00:58:54.434 --> 00:58:56.100
PROFESSOR: So you're
at here, right now.

00:58:59.640 --> 00:59:04.570
OK, so v.parent has to be u.

00:59:04.570 --> 00:59:05.940
And?

00:59:05.940 --> 00:59:08.080
v is?

00:59:08.080 --> 00:59:09.702
Is it visited or not?

00:59:09.702 --> 00:59:11.130
AUDIENCE: It's a new vertex.

00:59:11.130 --> 00:59:13.990
AUDIENCE: It's not.

00:59:13.990 --> 00:59:15.450
PROFESSOR: So v is
not visited yet.

00:59:21.160 --> 00:59:23.490
So this is a tree edge.

00:59:23.490 --> 00:59:25.837
Now let's compare this
to a forward edge.

00:59:32.180 --> 00:59:34.059
So what happens
to a forward edge?

00:59:34.059 --> 00:59:36.933
AUDIENCE: Parents of children--

00:59:36.933 --> 00:59:39.345
AUDIENCE: Parent ancestors--

00:59:39.345 --> 00:59:40.970
PROFESSOR: So you're
at here right now.

00:59:44.690 --> 00:59:47.260
And you're looking
at the edge uv.

00:59:47.260 --> 00:59:49.240
Right? so we're
looking at the edge uv.

00:59:49.240 --> 00:59:51.470
uv would point
downward in the tree.

00:59:51.470 --> 00:59:53.801
What's true about--

00:59:53.801 --> 00:59:56.557
AUDIENCE: v.parent is u.

00:59:56.557 --> 00:59:57.140
AUDIENCE: No--

00:59:57.140 --> 00:59:58.223
AUDIENCE: Not necessarily.

00:59:58.223 --> 01:00:00.600
PROFESSOR: OK.

01:00:00.600 --> 01:00:04.560
So v.parent is u.

01:00:04.560 --> 01:00:07.220
So it can be the parent,
or the grandparent,

01:00:07.220 --> 01:00:10.350
or-- so u has to be
somewhere up the tree.

01:00:10.350 --> 01:00:11.020
Right?

01:00:11.020 --> 01:00:14.654
So I can have a ton
of dot parents here.

01:00:14.654 --> 01:00:17.070
AUDIENCE: There has to be more
than one dot parent, right?

01:00:17.070 --> 01:00:19.278
Because otherwise
we get tree edge.

01:00:19.278 --> 01:00:21.760
It can't just be one parent.

01:00:21.760 --> 01:00:22.644
PROFESSOR: OK.

01:00:22.644 --> 01:00:25.097
AUDIENCE: So you'd have to
recurse up more than once.

01:00:25.097 --> 01:00:25.722
PROFESSOR: Yep.

01:00:25.722 --> 01:00:29.560
So for a node you go up until
you find u, and if you found u,

01:00:29.560 --> 01:00:33.770
then it's a forward
edge, otherwise,

01:00:33.770 --> 01:00:35.967
if you find the root of
the tree then you give up.

01:00:35.967 --> 01:00:37.550
AUDIENCE: Well then
it's a cross edge.

01:00:40.826 --> 01:00:44.230
If you go up and you get
to the root but-- oh--

01:00:44.230 --> 01:00:46.626
PROFESSOR: Yeah, so if
you got to the root,

01:00:46.626 --> 01:00:47.750
it is not the forward edge.

01:00:47.750 --> 01:00:49.880
Right now we're looking
at what does it mean.

01:00:49.880 --> 01:00:52.745
So you have to be somewhere
around the ancestor chain of u,

01:00:52.745 --> 01:00:56.070
so if you keep following v's
parents, you have to see u.

01:00:56.070 --> 01:00:59.170
If not, it's not
the forward edge.

01:00:59.170 --> 01:01:00.010
OK.

01:01:00.010 --> 01:01:02.070
And when you see
it, did you visit it

01:01:02.070 --> 01:01:03.807
or did you not visit it?

01:01:03.807 --> 01:01:04.890
AUDIENCE: Already visited.

01:01:10.650 --> 01:01:11.740
PROFESSOR: OK.

01:01:11.740 --> 01:01:15.680
So now we have two more edge
types, we have back edges,

01:01:15.680 --> 01:01:17.040
and we have cross edges.

01:01:17.040 --> 01:01:18.740
Right?

01:01:18.740 --> 01:01:21.608
Show me a back edge here.

01:01:21.608 --> 01:01:22.940
AUDIENCE: DA.

01:01:22.940 --> 01:01:24.720
PROFESSOR: DA is a back edge.

01:01:24.720 --> 01:01:26.570
OK back edges are
also reasonably easy.

01:01:26.570 --> 01:01:27.320
So let's do those.

01:01:30.610 --> 01:01:31.630
What's a back edge.

01:01:31.630 --> 01:01:34.525
So I am at u now.

01:01:34.525 --> 01:01:37.700
I'm looking at the edge uv.

01:01:37.700 --> 01:01:39.028
AUDIENCE: It's a cycle.

01:01:39.028 --> 01:01:40.710
AUDIENCE: Node to ancestor.

01:01:40.710 --> 01:01:41.418
PROFESSOR: Sorry?

01:01:41.418 --> 01:01:43.330
AUDIENCE: It's a
node to an ancestor.

01:01:43.330 --> 01:01:46.295
PROFESSOR: OK so who
is who's ancestor?

01:01:46.295 --> 01:01:47.744
AUDIENCE: A is D's ancestor.

01:01:47.744 --> 01:01:48.910
AUDIENCE: V is u's ancestor.

01:01:48.910 --> 01:01:51.680
PROFESSOR: OK.

01:01:51.680 --> 01:02:00.000
So if I keep going,
u.parent many times over,

01:02:00.000 --> 01:02:05.540
I should eventually
see v. Uhh-- yeah.

01:02:05.540 --> 01:02:09.120
So the difference
between this and this

01:02:09.120 --> 01:02:11.324
is who is who's parent?

01:02:11.324 --> 01:02:16.194
AUDIENCE: Wait, wouldn't
u be a parent of v?

01:02:16.194 --> 01:02:20.000
Because we didn't go from
A to C to D and then at D

01:02:20.000 --> 01:02:23.302
I realize that I
can go to A, but I

01:02:23.302 --> 01:02:27.090
won't go because
it's already visited?

01:02:27.090 --> 01:02:28.970
PROFESSOR: Wait.

01:02:28.970 --> 01:02:30.380
AUDIENCE: But assuming that--

01:02:30.380 --> 01:02:31.790
AUDIENCE: A is an ancestor of D.

01:02:31.790 --> 01:02:33.290
PROFESSOR: So A is
an ancestor of D

01:02:33.290 --> 01:02:35.350
because by the time
I got to D, I've

01:02:35.350 --> 01:02:42.419
already set the parent
pointers for C and D.

01:02:42.419 --> 01:02:43.385
AUDIENCE: Yes.

01:02:43.385 --> 01:02:45.317
But-- wait.

01:02:45.317 --> 01:02:50.114
u.parent is v. Then u is
A here and v is D here--

01:02:50.114 --> 01:02:51.250
AUDIENCE: No u is D here.

01:02:51.250 --> 01:02:53.540
PROFESSOR: I'm at u
right now, so I'm at D.

01:02:53.540 --> 01:02:57.540
And I'm looking at the edge uv.

01:02:57.540 --> 01:02:59.340
AUDIENCE: Do we have
a cross edge in here?

01:02:59.340 --> 01:03:01.220
PROFESSOR: Do we have
a cross edge in here.

01:03:01.220 --> 01:03:01.950
Good question.

01:03:01.950 --> 01:03:03.838
What is the cross edge?

01:03:03.838 --> 01:03:06.680
AUDIENCE: C?

01:03:06.680 --> 01:03:08.430
PROFESSOR: OK so this
guy is a cross edge.

01:03:08.430 --> 01:03:10.346
So what is the difference
between a cross edge

01:03:10.346 --> 01:03:12.790
and a forward edge?

01:03:12.790 --> 01:03:16.015
[CLASS MURMURS]

01:03:16.015 --> 01:03:18.440
AUDIENCE: It's not an ancestor.

01:03:18.440 --> 01:03:22.150
AUDIENCE: Ancester goes up to S.

01:03:22.150 --> 01:03:26.750
PROFESSOR: So a cross edge is
very close to a forward edge

01:03:26.750 --> 01:03:38.670
except u is not an ancestor
of v. v in the DFS tree.

01:03:42.750 --> 01:03:44.434
OK?

01:03:44.434 --> 01:03:47.386
AUDIENCE: [INAUDIBLE]

01:03:47.386 --> 01:03:49.846
PROFESSOR: Yep.

01:03:49.846 --> 01:03:50.840
Yep.

01:03:50.840 --> 01:03:55.998
So the only common ancestor
between B and C is the source.

01:04:04.720 --> 01:04:07.850
OK so please get these
conditions in the notes.

01:04:07.850 --> 01:04:11.145
So as a summary, if it's
an edge that DFS uses,

01:04:11.145 --> 01:04:12.970
it's a tree edge.

01:04:12.970 --> 01:04:16.960
If it's going against the way
of the DFS, it's a back edge.

01:04:16.960 --> 01:04:20.810
If it fast forwards
in DFS, so instead

01:04:20.810 --> 01:04:24.320
of going one level down, it
does multiple levels down,

01:04:24.320 --> 01:04:25.980
then it's a forward edge.

01:04:25.980 --> 01:04:30.520
And otherwise, it's weird
edge so it's a cross edge.

01:04:30.520 --> 01:04:31.524
One way to look at it.

01:04:31.524 --> 01:04:32.024
Yeah.

01:04:32.024 --> 01:04:33.607
AUDIENCE: Is this
only true because we

01:04:33.607 --> 01:04:35.880
were going alphabetically?

01:04:35.880 --> 01:04:37.780
PROFESSOR: Yeah, this
depends on the order

01:04:37.780 --> 01:04:40.430
in which the nodes are
listed in the adjacency list.

01:04:40.430 --> 01:04:43.310
AUDIENCE: So it could've
been pretty different

01:04:43.310 --> 01:04:46.190
if we went from A to E?

01:04:46.190 --> 01:04:47.800
PROFESSOR: Oh Yeah, yeah.

01:04:47.800 --> 01:04:48.724
Yep.

01:04:48.724 --> 01:04:50.682
AUDIENCE: I'm trying to
solve this another way.

01:04:50.682 --> 01:04:54.180
The graph information--

01:04:54.180 --> 01:04:54.973
PROFESSOR: Yeah

01:04:54.973 --> 01:04:57.751
AUDIENCE: --would you say that's
moderate or an easy example?

01:04:57.751 --> 01:05:00.530
The transformation.

01:05:00.530 --> 01:05:03.290
PROFESSOR: This is
on the easy side.

01:05:03.290 --> 01:05:05.950
So look at the problems
that we had so far.

01:05:05.950 --> 01:05:08.160
There are more problems
in this review packet.

01:05:08.160 --> 01:05:11.640
There are like six,
seven, eight problems.

01:05:11.640 --> 01:05:14.310
It's going to be online.

01:05:14.310 --> 01:05:16.060
It's the notes for
this recitation.

01:05:16.060 --> 01:05:17.100
Sorry, bad name.

01:05:17.100 --> 01:05:19.550
So the notes for
this recitation.

01:05:19.550 --> 01:05:21.190
This is on the easy side.

01:05:21.190 --> 01:05:24.010
The StarCraft problem, last time
is on the insanely difficult

01:05:24.010 --> 01:05:25.810
side, so that's not
going to happen.

01:05:25.810 --> 01:05:27.910
AUDIENCE: I so
don't even get that.

01:05:27.910 --> 01:05:30.060
PROFESSOR: That's
on the hard side.