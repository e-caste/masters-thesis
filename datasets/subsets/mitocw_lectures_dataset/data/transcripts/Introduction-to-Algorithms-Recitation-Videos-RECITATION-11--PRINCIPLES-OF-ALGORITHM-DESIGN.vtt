WEBVTT

00:00:00.050 --> 00:00:01.770
The following
content is provided

00:00:01.770 --> 00:00:04.000
under a Creative
Commons license.

00:00:04.000 --> 00:00:06.860
Your support will help MIT
OpenCourseWare continue

00:00:06.860 --> 00:00:10.720
to offer high quality
educational resources for free.

00:00:10.720 --> 00:00:13.320
To make a donation or
view additional materials

00:00:13.320 --> 00:00:17.207
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.207 --> 00:00:17.832
at ocw.mit.edu.

00:00:21.380 --> 00:00:23.720
PROFESSOR: It's a bit better,
my heart's back in place.

00:00:23.720 --> 00:00:26.812
I'm glad that not
everyone's gone.

00:00:26.812 --> 00:00:29.480
AUDIENCE: Well you mean passed
out and died from the test?

00:00:29.480 --> 00:00:30.250
PROFESSOR: Yeah.

00:00:30.250 --> 00:00:32.380
AUDIENCE: OK, no there
were a few students left.

00:00:32.380 --> 00:00:35.400
PROFESSOR: That's
good, that's good.

00:00:35.400 --> 00:00:37.650
I think once we release the
results everyone will calm

00:00:37.650 --> 00:00:41.498
down, and we'll realize that
the mistake was on our part.

00:00:41.498 --> 00:00:42.710
AUDIENCE: The mistake?

00:00:42.710 --> 00:00:46.120
PROFESSOR: I mean the results
are lower than what we thought.

00:00:46.120 --> 00:00:48.600
And it's because we
haven't covered something

00:00:48.600 --> 00:00:51.870
that I will cover today.

00:00:51.870 --> 00:00:54.346
So we think-- well we
talked about it yesterday,

00:00:54.346 --> 00:00:56.220
and we think we haven't
done enough algorithm

00:00:56.220 --> 00:00:57.094
design with you guys.

00:00:57.094 --> 00:00:59.230
So today I have
problems, and we're

00:00:59.230 --> 00:01:01.870
going to come up with solutions.

00:01:01.870 --> 00:01:03.453
AUDIENCE: Are you
not going to tell us

00:01:03.453 --> 00:01:05.519
what [INAUDIBLE] number is?

00:01:05.519 --> 00:01:07.060
PROFESSOR: It's in
the lecture notes.

00:01:07.060 --> 00:01:09.650
It's actually quite boring.

00:01:09.650 --> 00:01:11.080
I promise it's really boring.

00:01:11.080 --> 00:01:12.004
AUDIENCE: OK.

00:01:12.004 --> 00:01:14.170
PROFESSOR: And if you want
to do that next time when

00:01:14.170 --> 00:01:15.780
we'll actually talk
about numerics.

00:01:15.780 --> 00:01:17.150
The thing is numerics
are straightforward.

00:01:17.150 --> 00:01:18.649
Once you learn the
algorithms you're

00:01:18.649 --> 00:01:21.100
not going to come
up with a new one.

00:01:21.100 --> 00:01:22.546
I'm pretty sure about that.

00:01:22.546 --> 00:01:24.920
Like you're not going to come
up with a revolutionary way

00:01:24.920 --> 00:01:26.980
of adding two numbers.

00:01:26.980 --> 00:01:29.420
AUDIENCE: I don't know.

00:01:29.420 --> 00:01:30.340
You never know.

00:01:30.340 --> 00:01:31.840
PROFESSOR: Well you
can tell me why.

00:01:31.840 --> 00:01:32.950
Think about it and
then you can tell me

00:01:32.950 --> 00:01:33.750
why you are not going to.

00:01:33.750 --> 00:01:34.740
AUDIENCE: OK, got it.

00:01:37.680 --> 00:01:41.450
PROFESSOR: OK so let's
start with a problem.

00:01:41.450 --> 00:01:43.450
We know what sorted
arrays look like, right?

00:01:46.130 --> 00:01:50.890
1, 3, 5, 6, 7, 9, 12.

00:01:50.890 --> 00:01:53.809
This is a sorted array.

00:01:53.809 --> 00:01:55.350
If we're given a
sorted array we know

00:01:55.350 --> 00:01:59.210
how to find the
number in it, right?

00:01:59.210 --> 00:02:01.729
What's the running
time for that.

00:02:01.729 --> 00:02:03.020
AUDIENCE: For any given number?

00:02:03.020 --> 00:02:04.656
PROFESSOR: Yeah.

00:02:04.656 --> 00:02:06.390
AUDIENCE: [INAUDIBLE]

00:02:06.390 --> 00:02:09.338
PROFESSOR: Well what's
the best way that we know?

00:02:09.338 --> 00:02:10.230
AUDIENCE: Logarithm.

00:02:10.230 --> 00:02:11.896
PROFESSOR: Log and
binary search, right?

00:02:14.580 --> 00:02:18.040
Well instead of this we're
given a shifted array.

00:02:18.040 --> 00:02:20.880
And shifted means
that-- say you're

00:02:20.880 --> 00:02:23.185
shifting the array
by K elements.

00:02:23.185 --> 00:02:25.090
We're taking these guys.

00:02:25.090 --> 00:02:27.890
So the array is
shifted to the left.

00:02:27.890 --> 00:02:30.930
So these K elements
end up on the right.

00:02:30.930 --> 00:02:34.760
These N minus K elements
end up on the left.

00:02:34.760 --> 00:02:39.000
So 7, 9, 12, 1, 3, 5, 6.

00:02:42.780 --> 00:02:48.130
So still N elements they are
shifted by some number K.

00:02:48.130 --> 00:02:51.220
And I want to find one
number, e, in the array.

00:02:51.220 --> 00:02:52.805
I don't know K by the way.

00:02:52.805 --> 00:02:54.430
We just know that
it's a shifted array.

00:02:58.120 --> 00:02:58.930
This is 12.

00:03:06.490 --> 00:03:12.430
So the first thing
you do is figure out

00:03:12.430 --> 00:03:14.635
how much time you
have for this, right?

00:03:14.635 --> 00:03:16.760
If you're on a test, you
roughly know how much time

00:03:16.760 --> 00:03:17.590
you have for a problem.

00:03:17.590 --> 00:03:18.890
If you're on an
interview you have

00:03:18.890 --> 00:03:20.520
to figure out how much
time the interviewer is

00:03:20.520 --> 00:03:21.950
willing to give you for problem.

00:03:21.950 --> 00:03:24.960
And spend the first,
I don't, a third

00:03:24.960 --> 00:03:26.357
of the time thinking maybe.

00:03:26.357 --> 00:03:28.190
Come up with the best
solution that you can.

00:03:28.190 --> 00:03:30.800
And then stop there,
and start talking.

00:03:30.800 --> 00:03:32.540
So the first thing
you do, you want

00:03:32.540 --> 00:03:33.930
to make sure that when
you run out of time

00:03:33.930 --> 00:03:35.013
you have something to say.

00:03:35.013 --> 00:03:37.670
The most awful thing you can
say is, dude I'm going home now.

00:03:37.670 --> 00:03:39.422
Or leave the answer blank.

00:03:39.422 --> 00:03:40.880
If you leave the
answer blank we're

00:03:40.880 --> 00:03:42.570
not going to give
you points, right?

00:03:42.570 --> 00:03:43.780
So not good.

00:03:43.780 --> 00:03:46.140
So what's the worst
answer you could give us?

00:03:50.260 --> 00:03:54.460
OK worst is a bad term.

00:03:54.460 --> 00:03:56.630
What's the brute force
solution to this?

00:03:56.630 --> 00:03:58.970
The solution where we don't
care about the running time,

00:03:58.970 --> 00:04:02.100
but we want the correct answer.

00:04:02.100 --> 00:04:03.350
AUDIENCE: Look everywhere.

00:04:03.350 --> 00:04:04.710
PROFESSOR: Yep.

00:04:04.710 --> 00:04:06.600
So do a linear search.

00:04:06.600 --> 00:04:09.350
Pretend we don't know
anything about this array.

00:04:09.350 --> 00:04:11.420
Lose the information that
it's a shifted array.

00:04:11.420 --> 00:04:16.860
Linear search
running time order N.

00:04:16.860 --> 00:04:19.108
OK so this is
something, at least now

00:04:19.108 --> 00:04:20.899
when your time runs
out you have something.

00:04:20.899 --> 00:04:22.524
You're not going to
leave empty handed.

00:04:25.010 --> 00:04:26.250
Let's start thinking now.

00:04:26.250 --> 00:04:26.770
Next step.

00:04:30.011 --> 00:04:32.764
AUDIENCE: [INAUDIBLE]
can we shift it again?

00:04:32.764 --> 00:04:34.430
PROFESSOR: So the
fact that it's shifted

00:04:34.430 --> 00:04:37.640
means that-- so originally
it was sorted, right?

00:04:37.640 --> 00:04:39.900
But now instead of it
being completely sorted,

00:04:39.900 --> 00:04:42.580
you have all the elements
are shifted to the left.

00:04:42.580 --> 00:04:45.610
And then so there's a
rotation thing going on here.

00:04:45.610 --> 00:04:48.430
So these elements
got out of the array

00:04:48.430 --> 00:04:51.182
and then they are put back
in from the other side.

00:04:51.182 --> 00:04:52.870
AUDIENCE: Why do we do that?

00:04:52.870 --> 00:04:54.820
PROFESSOR: That's how
the info looks like.

00:04:54.820 --> 00:04:55.910
We don't do it.

00:04:55.910 --> 00:04:58.042
It was done to us.

00:04:58.042 --> 00:04:58.932
AUDIENCE: Oh OK.

00:04:58.932 --> 00:04:59.890
So now what do we want?

00:04:59.890 --> 00:05:00.980
PROFESSOR: We want
to find an element--

00:05:00.980 --> 00:05:01.620
AUDIENCE: Oh, I see.

00:05:01.620 --> 00:05:04.161
PROFESSOR: --despite the fact
that the array looks like this.

00:05:04.161 --> 00:05:06.235
AUDIENCE: Do we know that
the list that we have

00:05:06.235 --> 00:05:07.240
is shifted already?

00:05:07.240 --> 00:05:07.910
PROFESSOR: Yes.

00:05:07.910 --> 00:05:11.280
So we're promised that
this is a shifted array.

00:05:11.280 --> 00:05:13.130
So it will look like this.

00:05:13.130 --> 00:05:15.710
But we don't know what K is.

00:05:15.710 --> 00:05:20.810
If we knew what K is,
could we do something fast?

00:05:20.810 --> 00:05:22.010
What would we do?

00:05:22.010 --> 00:05:24.754
AUDIENCE: Yeah, you'd
just re-shift [INAUDIBLE].

00:05:24.754 --> 00:05:26.170
PROFESSOR: OK so
if you re-shifted

00:05:26.170 --> 00:05:28.610
what's the running time?

00:05:28.610 --> 00:05:31.560
AUDIENCE: For order
K [INAUDIBLE].

00:05:31.560 --> 00:05:33.225
PROFESSOR: OK so if
we actually shifted

00:05:33.225 --> 00:05:36.450
and then do a binary search
it's order K plus log

00:05:36.450 --> 00:05:40.692
N. So for big K's
that's not better.

00:05:40.692 --> 00:05:45.542
AUDIENCE: Why is it not
order N plus log [INAUDIBLE].

00:05:45.542 --> 00:05:48.000
PROFESSOR: You can say that
since we don't have any promise

00:05:48.000 --> 00:05:53.620
on K it's N. It's order K if
you can shift things out of both

00:05:53.620 --> 00:05:54.410
N's.

00:05:54.410 --> 00:05:55.970
With Python this
would be order N,

00:05:55.970 --> 00:05:58.610
just popping out one element
is order N in Python.

00:05:58.610 --> 00:06:01.430
So this is assuming
a smart array.

00:06:01.430 --> 00:06:03.420
Otherwise if it's
Python, good point.

00:06:03.420 --> 00:06:07.920
It's straight up order N.
So now another good point.

00:06:07.920 --> 00:06:12.420
You have this solution, and you
have the brute force solution.

00:06:12.420 --> 00:06:14.760
They have the same running time.

00:06:14.760 --> 00:06:16.110
You run out of time.

00:06:16.110 --> 00:06:17.950
Which one are you
going to code up?

00:06:17.950 --> 00:06:21.257
Which one are you going to show?

00:06:21.257 --> 00:06:22.340
AUDIENCE: The simpler one.

00:06:22.340 --> 00:06:23.923
PROFESSOR: The simpler
one, excellent.

00:06:23.923 --> 00:06:26.230
So the reason is,
if you're on a test

00:06:26.230 --> 00:06:30.787
it's probably give the
pseudocode, then analyze it.

00:06:30.787 --> 00:06:32.870
If you're in an interview
the guy will ask you OK,

00:06:32.870 --> 00:06:34.290
what's the running time?

00:06:34.290 --> 00:06:38.121
Code it up on the board in
C, Java, whatever he knows.

00:06:38.121 --> 00:06:39.870
So you want to code
the simplest solution,

00:06:39.870 --> 00:06:42.170
because that reduces the
chance that you'll have bugs.

00:06:42.170 --> 00:06:44.290
So that gives you
the most points.

00:06:44.290 --> 00:06:46.270
So this solution
shows more insight,

00:06:46.270 --> 00:06:49.490
but it doesn't have
a better run time.

00:06:49.490 --> 00:06:51.760
Stick to the simple solution.

00:06:51.760 --> 00:06:53.166
However if you
have this then you

00:06:53.166 --> 00:06:54.540
have some insight
on the problem.

00:06:54.540 --> 00:06:57.300
So you can keep
going and hope you

00:06:57.300 --> 00:06:59.480
can come up with
a better answer.

00:06:59.480 --> 00:07:02.090
So if we knew K, one
thing we could do

00:07:02.090 --> 00:07:05.300
is reduce the array
to an unshifted array.

00:07:05.300 --> 00:07:07.850
What's another thing we can do?

00:07:07.850 --> 00:07:10.080
So I claim that
if you know K you

00:07:10.080 --> 00:07:16.196
can come up with a
reasonably easy log N method.

00:07:16.196 --> 00:07:18.370
AUDIENCE: If you're
doing binary search,

00:07:18.370 --> 00:07:23.530
like if you just pretend like
the array is all together,

00:07:23.530 --> 00:07:28.013
but if you know K. So let's
say you're looking for 6.

00:07:28.013 --> 00:07:32.340
Then you'd say oh well I'm
going to split the array half,

00:07:32.340 --> 00:07:34.080
but you're actually
going to start at K

00:07:34.080 --> 00:07:35.470
and then split it in half.

00:07:35.470 --> 00:07:38.300
So it's like you pretend that--

00:07:38.300 --> 00:07:39.780
PROFESSOR: So what
you want to say

00:07:39.780 --> 00:07:43.827
is you have a pretend
array in your mind, right?

00:07:43.827 --> 00:07:44.410
AUDIENCE: Yes.

00:07:44.410 --> 00:07:47.110
It's [INAUDIBLE] by K.

00:07:47.110 --> 00:07:49.590
PROFESSOR: And you want to
access the middle element

00:07:49.590 --> 00:07:53.030
to see if what you're looking
for is bigger or smaller.

00:07:53.030 --> 00:07:55.100
Instead of looking at
the middle element here,

00:07:55.100 --> 00:07:57.636
you look at the
middle plus K, right?

00:07:57.636 --> 00:07:58.219
AUDIENCE: Yes.

00:07:58.219 --> 00:07:59.638
Oh, there you go.

00:07:59.638 --> 00:08:01.530
Plus K.

00:08:01.530 --> 00:08:04.219
PROFESSOR: This is one way of
doing it, good running time.

00:08:04.219 --> 00:08:05.260
The problem is it's hard.

00:08:05.260 --> 00:08:08.490
You'll have to rewrite binary
search and hope it works.

00:08:08.490 --> 00:08:10.580
What I would do,
given that I've had

00:08:10.580 --> 00:08:15.460
a bit of time to think
about it, is this is sorted.

00:08:15.460 --> 00:08:17.790
This is sorted.

00:08:17.790 --> 00:08:22.630
So two binary searched are
also going to be log N time.

00:08:22.630 --> 00:08:25.270
Two binary searches,
two lines of pseudocode.

00:08:25.270 --> 00:08:27.540
The running time analysis
is pretty simple.

00:08:27.540 --> 00:08:30.880
Correctness is
also pretty simple.

00:08:30.880 --> 00:08:32.710
And also this gives
me some insight

00:08:32.710 --> 00:08:34.689
on the rest of the
problem I claim.

00:08:37.470 --> 00:08:43.780
OK so if we have K we can do
log N. What if we don't have K?

00:08:43.780 --> 00:08:45.830
What do we do?

00:08:45.830 --> 00:08:46.909
Yes?

00:08:46.909 --> 00:08:48.200
AUDIENCE: Figure out what K is.

00:08:48.200 --> 00:08:50.783
PROFESSOR: All right let's try
to find K. We know how to do it

00:08:50.783 --> 00:08:55.360
if we have K. So let's try
to find K. What-- if I want

00:08:55.360 --> 00:09:00.020
to arrive to a
solution that's log N,

00:09:00.020 --> 00:09:01.830
how much time can I
spend on finding K?

00:09:04.340 --> 00:09:07.260
OK so let's find
K in log N time.

00:09:11.220 --> 00:09:13.210
AUDIENCE: Binary
search for minimum?

00:09:13.210 --> 00:09:15.720
PROFESSOR: Binary search--
so I like binary search,

00:09:15.720 --> 00:09:17.780
because binary search
is an algorithm that

00:09:17.780 --> 00:09:19.590
runs on an array.

00:09:19.590 --> 00:09:21.300
And that runs in log N time.

00:09:21.300 --> 00:09:24.092
So if I'm able to make it
work I know everything's

00:09:24.092 --> 00:09:25.550
going to be right
in terms of time.

00:09:25.550 --> 00:09:28.335
So what do you run
a binary search for?

00:09:28.335 --> 00:09:29.960
AUDIENCE: The smallest
number possible?

00:09:29.960 --> 00:09:32.335
I guess that's kind of going
through all of them, though.

00:09:32.335 --> 00:09:33.400
It doesn't really help.

00:09:33.400 --> 00:09:35.280
PROFESSOR: So if
you have the min.

00:09:35.280 --> 00:09:36.902
Sorry, you can
speak in one second.

00:09:36.902 --> 00:09:38.110
AUDIENCE: Oh we have the min!

00:09:38.110 --> 00:09:39.943
PROFESSOR: So no, if
you can't have the min.

00:09:39.943 --> 00:09:41.080
I think it's good insight.

00:09:41.080 --> 00:09:45.134
So if you knew where the min
is, you know this is K, right?

00:09:45.134 --> 00:09:45.970
AUDIENCE: Yes.

00:09:45.970 --> 00:09:47.900
PROFESSOR: So this
is the minimum,

00:09:47.900 --> 00:09:51.105
that's K. OK, what
were you going to say?

00:09:51.105 --> 00:09:52.653
AUDIENCE: Oh for
just binary search

00:09:52.653 --> 00:09:55.491
it would not
[INAUDIBLE] minimum.

00:09:55.491 --> 00:10:01.900
I was thinking that if we start
at 1 we will see to our right

00:10:01.900 --> 00:10:02.900
and left.

00:10:02.900 --> 00:10:05.304
And the point where
[INAUDIBLE] are ending

00:10:05.304 --> 00:10:08.004
is where we have something
larger to our right

00:10:08.004 --> 00:10:09.420
and something
smaller to our left.

00:10:09.420 --> 00:10:11.420
PROFESSOR: OK so there's
a discontinuity here,

00:10:11.420 --> 00:10:12.180
that's what you're
saying, right?

00:10:12.180 --> 00:10:13.180
So this is sorted.

00:10:13.180 --> 00:10:15.390
But then at this
point this breaks.

00:10:15.390 --> 00:10:18.700
AUDIENCE: Yes, we are kind
of finding that point where

00:10:18.700 --> 00:10:20.650
something to the
right that's greater

00:10:20.650 --> 00:10:22.682
than [INAUDIBLE] and
something to the left

00:10:22.682 --> 00:10:24.225
is also greater
than [INAUDIBLE].

00:10:24.225 --> 00:10:26.100
PROFESSOR: OK so let's
see if we can do that.

00:10:26.100 --> 00:10:29.030
So for binary search you
have to go somewhere.

00:10:29.030 --> 00:10:32.890
So in our case we're
trying to get K, right?

00:10:32.890 --> 00:10:36.200
And we know that it's
somewhere between 1 and 10.

00:10:36.200 --> 00:10:38.515
And what binary search
does is it makes a guess.

00:10:42.970 --> 00:10:45.820
It says hey, I think it's
in the middle of the array.

00:10:45.820 --> 00:10:49.380
So it will probably
guess n over 2.

00:10:49.380 --> 00:10:52.030
And it makes a
guess and you have

00:10:52.030 --> 00:10:54.290
to tell it was the
guess too small,

00:10:54.290 --> 00:10:57.310
or was the guess too large?

00:10:57.310 --> 00:10:59.220
Because this is what
allows you to recurse

00:10:59.220 --> 00:11:02.930
on either the left interval
or on the right interval.

00:11:02.930 --> 00:11:07.100
The problem with a discontinuity
is, if I guess here,

00:11:07.100 --> 00:11:10.850
and if I guess here, I still
don't see the discontinuity.

00:11:10.850 --> 00:11:12.860
So it's good inside,
but it's not enough.

00:11:12.860 --> 00:11:14.540
I need a little bit more.

00:11:14.540 --> 00:11:18.531
Yes, 2, 3 hands oh wow
you guys don't got it?

00:11:18.531 --> 00:11:20.155
AUDIENCE: So I think
we can arbitrarily

00:11:20.155 --> 00:11:22.497
take the halfway point
instead of subtracting

00:11:22.497 --> 00:11:23.455
from the first element.

00:11:23.455 --> 00:11:27.085
And then if it's
a negative number,

00:11:27.085 --> 00:11:30.055
then discontinuity
will be in this half.

00:11:30.055 --> 00:11:32.107
If it's [INAUDIBLE] it
will be in the other half.

00:11:32.107 --> 00:11:33.315
And then you recurse on that.

00:11:33.315 --> 00:11:34.920
PROFESSOR: OK.

00:11:34.920 --> 00:11:37.950
So let's draw this up.

00:11:37.950 --> 00:11:43.740
So in a sorted array the
numbers look like this.

00:11:43.740 --> 00:11:47.170
In a shifted array
we splice it here,

00:11:47.170 --> 00:11:49.530
and this guy goes to the right.

00:11:49.530 --> 00:11:57.220
So it's like this
and then like this.

00:11:57.220 --> 00:11:59.750
So this picture shows me the
insight that I had before,

00:11:59.750 --> 00:12:03.320
that this part is sorted
and this part is sorted.

00:12:03.320 --> 00:12:05.110
The missing part,
which I just heard now,

00:12:05.110 --> 00:12:09.880
is that since the whole
array was originally sorted,

00:12:09.880 --> 00:12:13.020
this guy is smaller
than this guy.

00:12:13.020 --> 00:12:19.160
So if I draw a
horizontal line here,

00:12:19.160 --> 00:12:21.150
I can draw a horizontal
line somewhere,

00:12:21.150 --> 00:12:24.990
and this and this
will not cross it.

00:12:24.990 --> 00:12:29.670
So this whole thing
is taller than this.

00:12:29.670 --> 00:12:33.130
So by the way, K was where
the discontinuity was, right?

00:12:33.130 --> 00:12:34.580
You said discontinuity.

00:12:34.580 --> 00:12:38.450
This is K, it's somewhere here.

00:12:38.450 --> 00:12:39.540
So this is a better.

00:12:39.540 --> 00:12:44.330
So if I make my guess and
I land somewhere here,

00:12:44.330 --> 00:12:46.150
I can know that my
guess is too big,

00:12:46.150 --> 00:12:48.450
because it's below the line.

00:12:48.450 --> 00:12:51.830
If I make my guess and
it's somewhere here,

00:12:51.830 --> 00:12:54.410
I know my guess is too small,
because the number that I

00:12:54.410 --> 00:12:56.530
see here is above the line.

00:12:56.530 --> 00:12:57.820
Who sets the line?

00:12:57.820 --> 00:12:58.950
The first element here.

00:13:02.010 --> 00:13:04.030
So this is how you
look at it graphically.

00:13:04.030 --> 00:13:06.410
If you don't want to
look at it graphically,

00:13:06.410 --> 00:13:08.820
this was a sorted array.

00:13:08.820 --> 00:13:12.960
If this is the Kth
element, then everything

00:13:12.960 --> 00:13:14.950
here is smaller than it.

00:13:14.950 --> 00:13:18.470
So all these guys are smaller
than the first element.

00:13:24.180 --> 00:13:26.780
OK so honestly who
understands the solution?

00:13:29.360 --> 00:13:31.432
3, 4, OK.

00:13:31.432 --> 00:13:34.230
Oh, OK pretty good.

00:13:34.230 --> 00:13:36.380
Do we want to code
this up, or do we

00:13:36.380 --> 00:13:39.019
want to look at another problem?

00:13:39.019 --> 00:13:40.685
OK who wants to look
at another problem?

00:13:43.900 --> 00:13:45.560
Clear majority, all right.

00:13:45.560 --> 00:13:46.980
Usually I have to
do both choices,

00:13:46.980 --> 00:13:49.780
because not enough people are
paying attention to get this.

00:13:49.780 --> 00:13:51.560
So I am happy.

00:13:51.560 --> 00:13:53.515
AUDIENCE: [INAUDIBLE].

00:13:53.515 --> 00:13:54.140
PROFESSOR: Yes.

00:13:59.870 --> 00:14:02.120
All right so before I start
another problem, one thing

00:14:02.120 --> 00:14:03.130
I want to say.

00:14:03.130 --> 00:14:05.186
Not only do I have a
solution for this problem,

00:14:05.186 --> 00:14:06.560
but I have a
process that allowed

00:14:06.560 --> 00:14:11.040
me to go from nothing to
a few partial solutions.

00:14:11.040 --> 00:14:13.230
And while I was doing
that, I was getting insight

00:14:13.230 --> 00:14:16.300
and I was making sure that if
I run out of time before I have

00:14:16.300 --> 00:14:20.670
the final solution, I don't walk
out of the room empty handed.

00:14:20.670 --> 00:14:23.000
So I don't just want to
show you the final solution,

00:14:23.000 --> 00:14:24.630
I want to show you the process.

00:14:24.630 --> 00:14:26.838
You can look at the notes
and see the final solution.

00:14:26.838 --> 00:14:30.860
That's not everything I
want you to get out of this.

00:14:30.860 --> 00:14:33.900
OK, problem 2 has a heap.

00:14:38.960 --> 00:14:41.420
And this is a minimum heap,
so it looks like this.

00:14:51.360 --> 00:14:55.520
So this is a minimum
heap, N elements.

00:14:55.520 --> 00:14:59.440
And I want to extract the kth
smallest element in the heap.

00:15:03.330 --> 00:15:07.450
So if K equals 3, this is the
third smallest element, right?

00:15:07.450 --> 00:15:09.240
K equals 4, it's this guy.

00:15:09.240 --> 00:15:12.130
5, and 6, 1 and 2 are here.

00:15:14.740 --> 00:15:18.756
OK the good running
time that we want,

00:15:18.756 --> 00:15:20.630
because this is a hard
problem so we give you

00:15:20.630 --> 00:15:25.300
the running time,
is K log K. However

00:15:25.300 --> 00:15:29.942
before we do that I want to
hear some brute force solutions.

00:15:29.942 --> 00:15:31.555
AUDIENCE: All of them.

00:15:31.555 --> 00:15:32.180
PROFESSOR: And?

00:15:35.110 --> 00:15:37.170
OK you need to sort them first.

00:15:37.170 --> 00:15:41.600
So this heap is actually
an array, right?

00:15:41.600 --> 00:15:49.840
2, 5, 7, 6, 8, oh
it's 6, 9, 8, sorry.

00:15:49.840 --> 00:15:53.200
So you're saying sort
the array, then K--

00:15:53.200 --> 00:15:54.640
AUDIENCE: [INAUDIBLE].

00:15:54.640 --> 00:15:57.004
PROFESSOR: OK what's the
running time for this?

00:15:57.004 --> 00:16:04.090
AUDIENCE: Log N.

00:16:04.090 --> 00:16:05.910
PROFESSOR: All right
we have a solution.

00:16:05.910 --> 00:16:09.180
We're not going to
leave empty handed.

00:16:09.180 --> 00:16:12.857
OK let's try to go a bit better.

00:16:12.857 --> 00:16:14.440
What's another way
of going it that'll

00:16:14.440 --> 00:16:18.190
give me a better running time?

00:16:18.190 --> 00:16:20.815
AUDIENCE: You could pop 5 of
the K elements off of the--

00:16:20.815 --> 00:16:22.940
PROFESSOR: All right so
this is a mean heap, right?

00:16:22.940 --> 00:16:24.281
So it has find min.

00:16:26.990 --> 00:16:33.950
And find min runs in order
log N. So if I call it K times

00:16:33.950 --> 00:16:36.910
I'm going to get the
K smallest elements.

00:16:36.910 --> 00:16:39.610
By the way heap sort
says pop and times,

00:16:39.610 --> 00:16:42.190
and you'll have all the
elements in sorted order.

00:16:42.190 --> 00:16:43.970
So we're doing a
heap sort, except we

00:16:43.970 --> 00:16:47.710
stop when we lose
interest after K elements.

00:16:47.710 --> 00:16:54.700
So we're down from
N log N to K log N.

00:16:54.700 --> 00:16:58.600
So I would be interested in
hearing a solution that's

00:16:58.600 --> 00:17:03.890
worse, because it would
look like N log K.

00:17:03.890 --> 00:17:06.826
But shows me more insight.

00:17:06.826 --> 00:17:07.950
So by the way this is good.

00:17:07.950 --> 00:17:12.190
You're already K log N. So
K log N, the correct answer

00:17:12.190 --> 00:17:16.569
is K log K. Small
difference, right?

00:17:16.569 --> 00:17:18.280
It's a logarithm factor.

00:17:18.280 --> 00:17:19.930
At least it's not an N factor.

00:17:19.930 --> 00:17:21.499
If you code this up
chances are we're

00:17:21.499 --> 00:17:23.540
not going to be able to
distinguish between this.

00:17:23.540 --> 00:17:24.998
So you'll never
see this on a PSet.

00:17:24.998 --> 00:17:28.150
So you're almost there.

00:17:28.150 --> 00:17:30.790
And this is just applying
straight up knowledge

00:17:30.790 --> 00:17:32.830
that we had before.

00:17:32.830 --> 00:17:36.210
Let's look at this
solution, if anyone sees it.

00:17:38.800 --> 00:17:41.640
Before we attempt K log K.

00:17:41.640 --> 00:17:43.490
AUDIENCE: In another
case would we

00:17:43.490 --> 00:17:48.070
just pop off first K elements,
why would that be in log N?

00:17:48.070 --> 00:17:51.620
Because it's actually
an array, so I

00:17:51.620 --> 00:17:54.980
would think that we'd
just take the K time.

00:17:54.980 --> 00:17:56.650
PROFESSOR: So this is a heap.

00:17:56.650 --> 00:17:58.516
If you don't maintain
the heaping variant

00:17:58.516 --> 00:17:59.890
after you do the
first pop you're

00:17:59.890 --> 00:18:02.570
not going to be able
to do the second one.

00:18:02.570 --> 00:18:05.970
OK, cool.

00:18:05.970 --> 00:18:07.480
So let me give you a hint.

00:18:07.480 --> 00:18:10.260
How would we find--
if this is an array--

00:18:10.260 --> 00:18:12.280
how do I find the minimum?

00:18:12.280 --> 00:18:14.680
2, 5, 7, did I forget something?

00:18:14.680 --> 00:18:16.180
No.

00:18:16.180 --> 00:18:19.280
Let's pretend this array doesn't
start with 2, because it's

00:18:19.280 --> 00:18:21.530
boring if it starts with 2.

00:18:21.530 --> 00:18:23.140
How do I find the minimum?

00:18:23.140 --> 00:18:26.300
I keep one variable that says
the best I've seen so far,

00:18:26.300 --> 00:18:27.250
right?

00:18:27.250 --> 00:18:31.570
Let's see, N-- oh
this is still boring.

00:18:31.570 --> 00:18:32.960
Let's start here.

00:18:32.960 --> 00:18:38.120
So we start with
best seen equals 7.

00:18:38.120 --> 00:18:41.970
Then when we go to 6 we see,
is 6 better than best seen?

00:18:41.970 --> 00:18:45.500
If so, replace best seen with 6.

00:18:45.500 --> 00:18:46.940
If not keep going.

00:18:46.940 --> 00:18:47.950
Then I get to 9.

00:18:47.950 --> 00:18:50.400
Is 9 better than best seen?

00:18:50.400 --> 00:18:51.430
Nope, keep going.

00:18:51.430 --> 00:18:52.820
Is 8 better than best seen?

00:18:52.820 --> 00:18:54.200
Nope, keep going.

00:18:54.200 --> 00:18:59.210
So I compare every element
with the best seen,

00:18:59.210 --> 00:19:02.950
and then whenever the element
is better I do a replacement.

00:19:02.950 --> 00:19:06.060
And then at the end, best seen
will have the smallest element.

00:19:06.060 --> 00:19:08.130
So this algorithm
works for k equals

00:19:08.130 --> 00:19:11.510
1, which isn't very useful.

00:19:11.510 --> 00:19:14.130
So can we generalize
this somehow

00:19:14.130 --> 00:19:17.557
to-- so we have a
running time here.

00:19:17.557 --> 00:19:20.140
That might give you a hint about
how we want to generalize it,

00:19:20.140 --> 00:19:28.749
and I want to generalize
it for all values of K.

00:19:28.749 --> 00:19:33.334
AUDIENCE: If you go to the
power of 2 then it's less than--

00:19:33.334 --> 00:19:35.070
the nearest power
of 2 less than K--

00:19:35.070 --> 00:19:35.985
PROFESSOR: OK.

00:19:35.985 --> 00:19:42.010
AUDIENCE: --that element, and
iterate forward with your best

00:19:42.010 --> 00:19:42.510
seen.

00:19:42.510 --> 00:19:44.470
Does that make sense?

00:19:44.470 --> 00:19:48.610
If you want the kth, if you
want the tenth smallest element,

00:19:48.610 --> 00:19:55.040
then it has to be
after the 8th row

00:19:55.040 --> 00:19:57.690
because it's the next
level in the tree.

00:19:57.690 --> 00:19:58.565
Does that make sense?

00:19:58.565 --> 00:20:00.020
That doesn't make sense.

00:20:00.020 --> 00:20:03.417
PROFESSOR: It makes sense,
but I don't think it's right.

00:20:03.417 --> 00:20:05.500
So you're thinking that
the tenth smallest element

00:20:05.500 --> 00:20:07.220
has to be somewhere
below, right?

00:20:07.220 --> 00:20:07.845
AUDIENCE: Yeah.

00:20:10.270 --> 00:20:20.630
PROFESSOR: 1, 2, 3, 4, 5, 6,
7, 8, 9, 10, and then pretend

00:20:20.630 --> 00:20:22.570
that there are numbers here.

00:20:22.570 --> 00:20:27.480
11, 12, 13, 14, 15, do
you see what I'm saying?

00:20:27.480 --> 00:20:28.340
So this is a heap.

00:20:34.420 --> 00:20:37.640
So I can keep filling
it with bigger elements,

00:20:37.640 --> 00:20:40.490
and 10 is here.

00:20:40.490 --> 00:20:43.910
However you can
do something else

00:20:43.910 --> 00:20:48.350
to limit the size of the heap.

00:20:48.350 --> 00:20:50.640
It will give us a
different running time,

00:20:50.640 --> 00:20:52.280
but you can do something.

00:20:52.280 --> 00:20:53.660
You can think about it.

00:20:53.660 --> 00:20:56.490
How can you chop up
some of the heap?

00:20:56.490 --> 00:20:58.450
For example if I have
a heap that's ten deep

00:20:58.450 --> 00:21:03.250
and I look at the fourth
element, what can I do?

00:21:03.250 --> 00:21:04.840
You can think about that.

00:21:04.840 --> 00:21:08.262
And let's try to get to this.

00:21:08.262 --> 00:21:09.720
So I'll accept an
answer for either

00:21:09.720 --> 00:21:12.010
how do we limit the
heap in that case,

00:21:12.010 --> 00:21:15.270
or how do we generalize
this algorithm.

00:21:15.270 --> 00:21:16.580
Yes?

00:21:16.580 --> 00:21:18.870
AUDIENCE: You want us to
remember the smallest K

00:21:18.870 --> 00:21:23.406
elements, you'd make a max
heap [INAUDIBLE] K [INAUDIBLE]

00:21:23.406 --> 00:21:25.310
[INAUDIBLE].

00:21:25.310 --> 00:21:27.060
PROFESSOR: OK so
I want to have--

00:21:27.060 --> 00:21:30.050
I'll break down your
solution into parts .

00:21:30.050 --> 00:21:35.090
So you want to have a bag of
the smallest K elements, right?

00:21:35.090 --> 00:21:40.960
So instead of the best seen, you
want to have the K best seen.

00:21:40.960 --> 00:21:44.930
And once you have a bag you want
to go through your elements.

00:21:44.930 --> 00:21:46.920
And then if you have
something that's

00:21:46.920 --> 00:21:48.817
better than what
you have in the bag,

00:21:48.817 --> 00:21:50.150
you want to put that in the bag.

00:21:52.710 --> 00:21:55.100
Suppose I have,
suppose K equals 3,

00:21:55.100 --> 00:21:59.310
and I have 2, 5,
and 7 in the bag.

00:21:59.310 --> 00:22:00.820
And I see 6.

00:22:00.820 --> 00:22:03.120
Who do I want to
compare it with?

00:22:03.120 --> 00:22:05.700
The biggest thing
in the bag, right?

00:22:05.700 --> 00:22:09.790
So if I want the K
smallest elements,

00:22:09.790 --> 00:22:11.830
if this guy is
smaller than anything,

00:22:11.830 --> 00:22:14.830
these aren't the K
smallest elements anymore.

00:22:14.830 --> 00:22:17.500
So I want to take the
maximum in the bag,

00:22:17.500 --> 00:22:20.160
compare it with what
I'm seeing right now,

00:22:20.160 --> 00:22:23.530
and if what I'm seeing is
smaller I want to replace it.

00:22:29.704 --> 00:22:30.620
AUDIENCE: [INAUDIBLE].

00:22:30.620 --> 00:22:32.700
PROFESSOR: Because I
keep doing this maximum,

00:22:32.700 --> 00:22:34.400
I keep asking this
maximum question,

00:22:34.400 --> 00:22:35.490
this has to be a max heap.

00:22:35.490 --> 00:22:36.882
That's why he said max heap.

00:22:41.610 --> 00:22:43.900
So you did all
these steps at once

00:22:43.900 --> 00:22:45.450
and then gave me
the final answer.

00:22:45.450 --> 00:22:47.230
But this is how you
do it step by step.

00:22:47.230 --> 00:22:52.810
So it looks like finding
the minimum element,

00:22:52.810 --> 00:22:54.450
except you have a bag.

00:22:54.450 --> 00:22:56.590
And that bag has to
be a maximum heap.

00:22:56.590 --> 00:22:58.380
And the original heap
is a minimum heap.

00:22:58.380 --> 00:23:00.338
So the fact that you have
to use a maximum heap

00:23:00.338 --> 00:23:01.960
is a bit nontrivial.

00:23:01.960 --> 00:23:03.020
Good answer.

00:23:03.020 --> 00:23:06.100
All right so we
have K log N, and we

00:23:06.100 --> 00:23:10.270
have N log K, so choose what
you want to have in your log.

00:23:10.270 --> 00:23:11.410
We have a solution for you.

00:23:14.530 --> 00:23:15.680
How about this.

00:23:15.680 --> 00:23:16.770
How are we doing here?

00:23:20.480 --> 00:23:22.690
So suppose I'm looking
for the fourth element,

00:23:22.690 --> 00:23:25.120
and my heap has 10 levels.

00:23:25.120 --> 00:23:28.050
How can I chop it--
how can I reduce

00:23:28.050 --> 00:23:29.650
the number of things
I'm looking at?

00:23:37.330 --> 00:23:40.230
AUDIENCE: You can reduce
it down to 4 levels.

00:23:40.230 --> 00:23:43.550
PROFESSOR: I can reduce it
down to 4 levels, exactly.

00:23:43.550 --> 00:23:48.640
So this heap has log N levels.

00:23:48.640 --> 00:23:52.490
And my K is smaller than log
N. I can reduce the heap down

00:23:52.490 --> 00:23:55.700
to K levels and discard
everything below.

00:23:59.150 --> 00:24:03.310
And the reason for that is
we have a mean heap, right?

00:24:03.310 --> 00:24:07.690
So if we go down from, on any
path from the roots to a leaf,

00:24:07.690 --> 00:24:11.150
the values have to
increase, right?

00:24:11.150 --> 00:24:12.520
Otherwise it's not a mean keep.

00:24:12.520 --> 00:24:15.290
Otherwise there's an invariant
violation somewhere there.

00:24:15.290 --> 00:24:21.650
So as I go down on any path
my numbers are going up.

00:24:21.650 --> 00:24:26.615
So these are all the
paths of length 4.

00:24:26.615 --> 00:24:29.370
All of them have
to go through here.

00:24:29.370 --> 00:24:32.320
All the paths of length
4 will stop here.

00:24:32.320 --> 00:24:34.450
So I know that
everything here has

00:24:34.450 --> 00:24:37.210
to be bigger than
the first 4 elements.

00:24:37.210 --> 00:24:41.330
So if I reduce this to K and
I discard everything else,

00:24:41.330 --> 00:24:44.630
what's the running time?

00:24:44.630 --> 00:24:47.150
So if I use my find my
extract min algorithm before,

00:24:47.150 --> 00:24:49.389
what was the running time?

00:24:49.389 --> 00:24:51.361
AUDIENCE: It was [INAUDIBLE].

00:24:56.790 --> 00:24:58.300
PROFESSOR: So it's not the--

00:24:58.300 --> 00:25:01.085
AUDIENCE: Oh sorry it's the--

00:25:01.085 --> 00:25:02.960
PROFESSOR: So what's
one operation in a heap?

00:25:02.960 --> 00:25:06.420
If I have the height of a
heap, what's an operation?

00:25:06.420 --> 00:25:08.604
How much time does it
take to do one operation

00:25:08.604 --> 00:25:10.270
as a function of the
height of the heap?

00:25:13.940 --> 00:25:17.010
So if my heap has h
levels, in this case

00:25:17.010 --> 00:25:20.840
h happens to be log
N, it's order h.

00:25:20.840 --> 00:25:24.090
So if I reduce it-- I'm not
reducing it from N to K.

00:25:24.090 --> 00:25:24.950
I wish I could.

00:25:24.950 --> 00:25:26.800
I'm reducing it from log N to K.

00:25:26.800 --> 00:25:30.670
So for really tiny K's,
this becomes order K.

00:25:30.670 --> 00:25:38.410
And my total running
time is K squared.

00:25:38.410 --> 00:25:42.230
So I'm going to do K
operations, K extract mins.

00:25:42.230 --> 00:25:45.730
OK now the reason I wanted
to entertain this is I

00:25:45.730 --> 00:25:48.970
claim it's going to be useful
to help us find the answer.

00:25:48.970 --> 00:25:52.630
So everything that we have
here gives us some insight

00:25:52.630 --> 00:25:56.350
into what the correct answer is.

00:25:56.350 --> 00:25:57.900
Well what our correct answer is.

00:25:57.900 --> 00:26:01.040
There might be others.

00:26:01.040 --> 00:26:04.350
So let's think for a bit,
and see if we can do better.

00:26:13.220 --> 00:26:14.678
Am I covering something?

00:26:14.678 --> 00:26:15.674
I hope not.

00:26:27.321 --> 00:26:29.404
So by the way, when you
have problems on your own,

00:26:29.404 --> 00:26:31.470
say you are looking at
CLRS or at old exams,

00:26:31.470 --> 00:26:35.270
you want to give yourselves
half an hour, an hour to think.

00:26:35.270 --> 00:26:37.027
And just this process
alone is going

00:26:37.027 --> 00:26:38.360
to help you do better on a test.

00:26:38.360 --> 00:26:40.290
Because while you're thinking
you're going through everything

00:26:40.290 --> 00:26:40.850
you know.

00:26:40.850 --> 00:26:43.050
And you're rearranging
stuff in your brain

00:26:43.050 --> 00:26:45.336
in a way that will be
easier to access it later.

00:26:45.336 --> 00:26:47.710
So now you're going to think,
what do I know about heaps?

00:26:47.710 --> 00:26:50.640
What do I know that
takes log N time?

00:26:50.640 --> 00:26:52.380
What do I know that
takes N log N time?

00:26:52.380 --> 00:26:55.340
And your brain will
be better at answering

00:26:55.340 --> 00:26:57.129
these kinds of questions later.

00:26:57.129 --> 00:26:58.920
Now we're not going to
give you 30 minutes,

00:26:58.920 --> 00:27:01.860
because that would make
us run out of time.

00:27:05.129 --> 00:27:08.047
AUDIENCE: You want to reduce
it down to K elements.

00:27:08.047 --> 00:27:09.630
PROFESSOR: I want
to only have to look

00:27:09.630 --> 00:27:11.650
at K elements, that's good.

00:27:11.650 --> 00:27:14.160
AUDIENCE: Otherwise you
can't plug K into the search.

00:27:14.160 --> 00:27:16.640
PROFESSOR: Yep,
OK so that's good.

00:27:16.640 --> 00:27:19.630
AUDIENCE: Which is interesting,
because it's K log K,

00:27:19.630 --> 00:27:21.130
and that kind of
suggests that you'd

00:27:21.130 --> 00:27:23.420
have K elements in the tree.

00:27:23.420 --> 00:27:27.860
But then you're searching
for each one in the tree.

00:27:27.860 --> 00:27:29.440
PROFESSOR: So
maybe I'm not going

00:27:29.440 --> 00:27:32.430
to be able to cut this heap
into K elements, right?

00:27:32.430 --> 00:27:34.886
I'll have to do a bit more.

00:27:40.298 --> 00:27:42.758
AUDIENCE: Can you cut
this heap into K elements

00:27:42.758 --> 00:27:48.220
and use that heap to
do our [INAUDIBLE]?

00:27:48.220 --> 00:27:50.080
PROFESSOR: Let's see
how we'd cut this heap.

00:27:50.080 --> 00:27:52.090
First off let's
see how this keep

00:27:52.090 --> 00:27:53.940
would look like if it's cut.

00:27:53.940 --> 00:27:58.080
How do we find the
first K elements here?

00:27:58.080 --> 00:28:00.518
How do we find
the first element?

00:28:00.518 --> 00:28:03.362
AUDIENCE: [INAUDIBLE].

00:28:03.362 --> 00:28:06.690
PROFESSOR: It's the root.

00:28:06.690 --> 00:28:08.973
Second element.

00:28:08.973 --> 00:28:11.740
AUDIENCE: [INAUDIBLE].

00:28:11.740 --> 00:28:13.090
PROFESSOR: What do I look at?

00:28:13.090 --> 00:28:16.000
If I want to select the
second element in a heap,

00:28:16.000 --> 00:28:18.220
how many elements do
I have to look at?

00:28:18.220 --> 00:28:22.940
Two, 5 and 7, because everything
below will be bigger, right?

00:28:22.940 --> 00:28:26.180
OK I look at them,
I compare them,

00:28:26.180 --> 00:28:29.230
I know 5 is the smallest one.

00:28:29.230 --> 00:28:31.990
Now suppose I want to
find the third element.

00:28:31.990 --> 00:28:32.920
Who do I look at?

00:28:39.120 --> 00:28:40.640
7 or the thing under 5.

00:28:40.640 --> 00:28:42.630
So 7 is still in
the race for sure.

00:28:42.630 --> 00:28:47.420
And then I have to look
at the children of 5.

00:28:54.110 --> 00:28:57.670
Right now we're looking at 3.

00:28:57.670 --> 00:29:02.770
Suppose this has some
really large kids.

00:29:02.770 --> 00:29:04.050
As in numbers.

00:29:04.050 --> 00:29:07.810
And I find that this
is the third element.

00:29:07.810 --> 00:29:09.850
Who do I look at for
the fourth element?

00:29:13.450 --> 00:29:15.840
AUDIENCE: [INAUDIBLE].

00:29:15.840 --> 00:29:20.660
PROFESSOR: OK so this
isn't in the race

00:29:20.660 --> 00:29:22.360
anymore, because it's the third.

00:29:22.360 --> 00:29:25.010
The fourth has to be
either of these two guys.

00:29:25.010 --> 00:29:26.390
Or the kids here, right?

00:29:29.690 --> 00:29:31.840
And it happens to be 7.

00:29:31.840 --> 00:29:34.460
So I take it out.

00:29:34.460 --> 00:29:40.540
If I want to look at the-- if I
want to find the next element,

00:29:40.540 --> 00:29:41.660
who's in the race?

00:29:41.660 --> 00:29:43.968
This guy gets out of the race.

00:29:43.968 --> 00:29:44.966
AUDIENCE: 7's kids.

00:29:48.958 --> 00:29:49.960
[INAUDIBLE]

00:29:49.960 --> 00:29:52.610
PROFESSOR: OK so
we have something.

00:29:52.610 --> 00:29:54.640
We're not really
cutting up the heap,

00:29:54.640 --> 00:29:57.230
but we are sort of computing
where the blade would

00:29:57.230 --> 00:30:02.110
go if we wanted to cut it up
in K elements and N minus K

00:30:02.110 --> 00:30:03.950
elements.

00:30:03.950 --> 00:30:06.990
Does this make some sense?

00:30:06.990 --> 00:30:08.371
Nods, no nods.

00:30:08.371 --> 00:30:09.912
AUDIENCE: I mean I
guess you're never

00:30:09.912 --> 00:30:14.530
going to be going
down farther than K.

00:30:14.530 --> 00:30:16.610
PROFESSOR: So let's just
understand the concept.

00:30:16.610 --> 00:30:18.318
And then we're going
to do one more pass,

00:30:18.318 --> 00:30:21.070
write pseudocode, and
understand the running time.

00:30:21.070 --> 00:30:23.122
Because this is still
confusing, right?

00:30:23.122 --> 00:30:24.580
We'll need one more
pass, otherwise

00:30:24.580 --> 00:30:27.300
we can't write the
pseudocode into it.

00:30:27.300 --> 00:30:31.595
So does the concept make sense?

00:30:31.595 --> 00:30:33.455
AUDIENCE: Is that K log K?

00:30:33.455 --> 00:30:34.080
PROFESSOR: Yes.

00:30:37.560 --> 00:30:40.960
So the idea here is that I
have a horizon that says,

00:30:40.960 --> 00:30:44.320
what are the next elements
that I'm willing to consider?

00:30:44.320 --> 00:30:46.730
And first the horizon
starts with just the root,

00:30:46.730 --> 00:30:48.920
because I know that's
the minimum element.

00:30:48.920 --> 00:30:50.890
And when I take an
element out of the horizon

00:30:50.890 --> 00:30:52.970
I put in its children.

00:30:52.970 --> 00:30:56.160
That's what I did all the time.

00:30:56.160 --> 00:30:59.160
So given a horizon how do I
know what the next elements

00:30:59.160 --> 00:31:01.536
to extract out of the horizon?

00:31:01.536 --> 00:31:03.000
AUDIENCE: [INAUDIBLE].

00:31:03.000 --> 00:31:04.720
PROFESSOR: The mean, OK.

00:31:04.720 --> 00:31:06.620
So I want a data
structure for the horizon

00:31:06.620 --> 00:31:09.490
that can extract means quickly.

00:31:09.490 --> 00:31:13.030
OK what am I going to
use for the horizon?

00:31:13.030 --> 00:31:15.490
A min heap, excellent.

00:31:15.490 --> 00:31:17.405
So let's try to
go for pseudocode.

00:31:26.030 --> 00:31:30.694
Suppose we have H as
our original heap.

00:31:30.694 --> 00:31:31.527
So H is a mean heap.

00:31:34.150 --> 00:31:36.300
We will make Z be our horizon.

00:31:36.300 --> 00:31:37.279
I can't use H again.

00:31:37.279 --> 00:31:38.820
It would be nice if
I could, but I'll

00:31:38.820 --> 00:31:41.610
use Z because Z's also
a letter in horizon.

00:31:41.610 --> 00:31:44.910
So Z's the mean heap.

00:31:44.910 --> 00:31:48.700
And then first I
will insert into Z.

00:31:48.700 --> 00:31:51.620
I'll insert the
heap's root, right?

00:31:51.620 --> 00:31:55.910
So Z dot insert H of 1.

00:31:55.910 --> 00:31:58.220
Remember that heaps
are actually arrays.

00:31:58.220 --> 00:31:59.220
I hinted to his earlier.

00:31:59.220 --> 00:32:04.740
So these nodes have are
elements in an array.

00:32:04.740 --> 00:32:09.550
So this is the first element,
second, third, fourth, fifth,

00:32:09.550 --> 00:32:11.970
sixth.

00:32:11.970 --> 00:32:15.130
So we're using array
backed heaps, and H of one

00:32:15.130 --> 00:32:16.670
is going to be the root.

00:32:16.670 --> 00:32:21.120
Then I'm going to compute the
first K elements like this,

00:32:21.120 --> 00:32:29.380
for K in range-- sorry,
for i in range K,

00:32:29.380 --> 00:32:33.480
so K is going to go from 1 to K.

00:32:33.480 --> 00:32:34.280
What I want to do?

00:32:38.590 --> 00:32:41.420
Take, compute the ith element.

00:32:41.420 --> 00:32:43.508
How do I do that?

00:32:43.508 --> 00:32:46.190
AUDIENCE: Extract min.

00:32:46.190 --> 00:32:48.346
PROFESSOR: i equals
Z dot extract min.

00:32:57.010 --> 00:32:59.335
And then I want to insert
the children in the horizon.

00:33:02.170 --> 00:33:04.290
Right?

00:33:04.290 --> 00:33:05.075
How do I do that?

00:33:08.664 --> 00:33:11.030
AUDIENCE: 2i and 2i plus 1.

00:33:11.030 --> 00:33:16.110
PROFESSOR: OK so this is
if I know the index, right?

00:33:19.450 --> 00:33:21.880
When I'm putting
things in the heap

00:33:21.880 --> 00:33:23.520
the keys are going
to be the values,

00:33:23.520 --> 00:33:25.936
so that I can take
out the minimum.

00:33:25.936 --> 00:33:30.460
AUDIENCE: [INAUDIBLE] heap
first and then inserted H Y.

00:33:30.460 --> 00:33:33.370
PROFESSOR: Yeah, OK.

00:33:33.370 --> 00:33:36.800
This is empty.

00:33:36.800 --> 00:33:38.000
And this is the input.

00:33:45.560 --> 00:33:49.050
OK so I need to use the
numbers as the keys.

00:33:49.050 --> 00:33:51.440
So when I extract
something out of the heap,

00:33:51.440 --> 00:33:53.870
so when I extract the first
element it's going to say 2,

00:33:53.870 --> 00:33:56.770
it's not going to say 1.

00:33:56.770 --> 00:33:58.137
If I want to--

00:33:58.137 --> 00:34:02.790
AUDIENCE: Why wouldn't Z dot
extract [INAUDIBLE] because--

00:34:02.790 --> 00:34:07.600
PROFESSOR: So this will give
me the next key in the horizon.

00:34:07.600 --> 00:34:11.550
AUDIENCE: But-- oh I
see, you're starting out

00:34:11.550 --> 00:34:13.150
with just the first one.

00:34:13.150 --> 00:34:14.439
PROFESSOR: Yeah.

00:34:14.439 --> 00:34:15.409
AUDIENCE: Oh and then you
want to add in the next.

00:34:15.409 --> 00:34:17.283
PROFESSOR: So at the
end of this whole thing,

00:34:17.283 --> 00:34:25.639
if I'm extracting them right, I
can return this variable here.

00:34:25.639 --> 00:34:29.190
Because after K durations this
is going to be the Kth element.

00:34:29.190 --> 00:34:31.250
So I return it and I'm done.

00:34:31.250 --> 00:34:37.520
The problem is I want this
guy's index too, right?

00:34:37.520 --> 00:34:40.739
So I can't just store
the key in the heap.

00:34:40.739 --> 00:34:43.020
I have to augment the heap
to let me store values.

00:34:43.020 --> 00:34:45.340
And I have to store the index.

00:34:45.340 --> 00:34:49.090
So for this guy would
have Z insert H of 1,

00:34:49.090 --> 00:34:51.530
and then it's index 1.

00:34:51.530 --> 00:34:56.300
Then when I get
out the ith element

00:34:56.300 --> 00:34:58.040
I'll also get out it's index.

00:34:58.040 --> 00:35:00.144
A variable name for that?

00:35:00.144 --> 00:35:01.130
AUDIENCE: j.

00:35:01.130 --> 00:35:02.930
PROFESSOR: j.

00:35:02.930 --> 00:35:07.770
OK why would you name
your variables like this?

00:35:07.770 --> 00:35:10.640
In the previous section I had
a similar suggestion, i, i.

00:35:10.640 --> 00:35:14.680
So why would you name
your variables like this?

00:35:14.680 --> 00:35:16.530
AUDIENCE: [INAUDIBLE].

00:35:16.530 --> 00:35:17.530
PROFESSOR: Job security.

00:35:20.750 --> 00:35:21.930
All right.

00:35:21.930 --> 00:35:23.540
So it's OK here.

00:35:23.540 --> 00:35:26.580
Try to not to do that when
doing an exam or an interview,

00:35:26.580 --> 00:35:28.184
because it reflects
poorly on you.

00:35:28.184 --> 00:35:30.350
For an interview and for
an exam you'll get us upset

00:35:30.350 --> 00:35:32.800
and we might be less lenient.

00:35:32.800 --> 00:35:34.940
Or at least explain
what you're doing.

00:35:34.940 --> 00:35:38.390
So extract min is going
to give us the key.

00:35:38.390 --> 00:35:40.830
And it's going to give
us index in the heap.

00:35:40.830 --> 00:35:41.970
What do we do afterwards?

00:35:46.052 --> 00:35:48.870
AUDIENCE: We add to
[INAUDIBLE] H of--

00:35:48.870 --> 00:35:53.430
PROFESSOR: All right
so when we take out 2--

00:35:53.430 --> 00:35:55.430
so we start out with
an horizon of 2.

00:35:55.430 --> 00:35:58.610
When we take it out 2's the
only thing that's in the horizon

00:35:58.610 --> 00:35:59.110
first.

00:35:59.110 --> 00:36:03.540
Then we take it out and its two
children get in the horizon.

00:36:03.540 --> 00:36:06.300
Then we take out
one of the children

00:36:06.300 --> 00:36:09.564
and put its children
in the horizon.

00:36:09.564 --> 00:36:10.980
So when we take
out a node we want

00:36:10.980 --> 00:36:13.400
to put its children
in the horizon.

00:36:13.400 --> 00:36:15.790
So we're going to say Z dot--

00:36:15.790 --> 00:36:17.640
AUDIENCE: Insert.

00:36:17.640 --> 00:36:19.740
PROFESSOR: Insert.

00:36:19.740 --> 00:36:22.800
What do I insert?

00:36:22.800 --> 00:36:26.055
AUDIENCE: H of I times 2.

00:36:26.055 --> 00:36:27.406
j times 2.

00:36:27.406 --> 00:36:28.030
PROFESSOR: See?

00:36:28.030 --> 00:36:31.330
It's working already.

00:36:31.330 --> 00:36:33.010
The job security
thing is working.

00:36:33.010 --> 00:36:35.206
And?

00:36:35.206 --> 00:36:36.630
AUDIENCE: 2j plus 1.

00:36:40.940 --> 00:36:42.825
You have to do two lines.

00:36:42.825 --> 00:36:43.700
PROFESSOR: OK, sweet.

00:36:57.990 --> 00:36:59.920
OK.

00:36:59.920 --> 00:37:01.214
Does this work?

00:37:01.214 --> 00:37:03.380
I mean does this do what
we wanted it to do earlier?

00:37:08.260 --> 00:37:11.188
AUDIENCE: Wait,
we're extracting oh--

00:37:16.304 --> 00:37:17.595
PROFESSOR: All right first nod.

00:37:21.710 --> 00:37:24.146
AUDIENCE: I mean if
K is small enough.

00:37:24.146 --> 00:37:29.940
Eventually you'll ask for
something that is out of range.

00:37:29.940 --> 00:37:32.700
PROFESSOR: Oh so you're
thinking that eventually these

00:37:32.700 --> 00:37:33.617
will run out of range.

00:37:33.617 --> 00:37:35.616
AUDIENCE: If you have
your really lopsided array

00:37:35.616 --> 00:37:37.950
eventually you'll ask for
something that's [INAUDIBLE].

00:37:37.950 --> 00:37:42.150
PROFESSOR: OK what would
we want to do in that case?

00:37:42.150 --> 00:37:46.764
AUDIENCE: Just want to check to
make sure that the [INAUDIBLE].

00:37:46.764 --> 00:37:48.680
PROFESSOR: Yeah, but
otherwise move on, right?

00:37:48.680 --> 00:37:52.600
If an element doesn't have kids,
we don't add on to the horizon.

00:37:52.600 --> 00:37:56.540
So we need some bounce
checks, exception checking,

00:37:56.540 --> 00:37:58.390
things like that in here.

00:37:58.390 --> 00:37:59.880
And I won't add
that because that

00:37:59.880 --> 00:38:01.990
will make it look long and ugly.

00:38:01.990 --> 00:38:05.350
So this is the idea.

00:38:05.350 --> 00:38:06.850
OK what's the running
time for this?

00:38:09.774 --> 00:38:10.690
AUDIENCE: [INAUDIBLE].

00:38:14.530 --> 00:38:15.520
PROFESSOR: Cool.

00:38:15.520 --> 00:38:22.020
So creating heaps, initializing,
all order 1, insertion,

00:38:22.020 --> 00:38:23.400
this heap is almost empty now.

00:38:23.400 --> 00:38:25.030
So this is order 1.

00:38:25.030 --> 00:38:28.520
Then these happen K times.

00:38:28.520 --> 00:38:32.070
And these are all
operations on the heap Z.

00:38:32.070 --> 00:38:37.090
And the heap for the heap Z,
it has some number of elements.

00:38:37.090 --> 00:38:40.570
And it's not always going
to have one element,

00:38:40.570 --> 00:38:42.010
because every time
I'm extracting

00:38:42.010 --> 00:38:43.450
one element I'm adding two.

00:38:43.450 --> 00:38:49.461
So well how many elements
is it going to have at most?

00:38:49.461 --> 00:38:49.960
AUDIENCE: K.

00:38:49.960 --> 00:38:51.961
PROFESSOR: OK why is that?

00:38:51.961 --> 00:38:54.850
AUDIENCE: Because each time
you add it it's one element.

00:38:54.850 --> 00:38:56.430
PROFESSOR: So I
extract one for sure.

00:38:56.430 --> 00:38:58.760
And then I add at
most two elements.

00:38:58.760 --> 00:39:03.070
So the heap size grows by at
most 1 in every iteration.

00:39:03.070 --> 00:39:07.550
So the heap size Z will
have at most K elements.

00:39:11.030 --> 00:39:13.270
So now I know the running
for all these operations.

00:39:13.270 --> 00:39:15.350
What is it?

00:39:15.350 --> 00:39:18.680
Log K. Cool.

00:39:18.680 --> 00:39:24.440
So it's K times log K. And
the reason that it works,

00:39:24.440 --> 00:39:26.270
it's a bit harder to see.

00:39:26.270 --> 00:39:29.440
You have to convince yourself
maybe using this bigger tree,

00:39:29.440 --> 00:39:31.800
that whenever you're spending
expanding the horizon

00:39:31.800 --> 00:39:34.250
you're expanding
it the right way.

00:39:34.250 --> 00:39:37.600
So the idea is
again that whatever

00:39:37.600 --> 00:39:42.760
path you take down you're
going to see ascending numbers.

00:39:42.760 --> 00:39:44.360
So when you're
increasing the horizon

00:39:44.360 --> 00:39:47.220
you're always pushing
it down in such a way

00:39:47.220 --> 00:39:52.100
that your invariant is that
all the numbers in the horizon

00:39:52.100 --> 00:39:55.140
are smaller then their children.

00:39:55.140 --> 00:39:57.260
And so on and so forth.

00:39:57.260 --> 00:39:59.040
So the horizon is
always guaranteed

00:39:59.040 --> 00:40:02.330
to have the smallest number
that you haven't extracted yet.

00:40:02.330 --> 00:40:04.372
And that's really the
only thing you need.

00:40:07.230 --> 00:40:10.430
OK does this make some sense?

00:40:10.430 --> 00:40:13.471
AUDIENCE: It never would have
occurred to me on an exam.

00:40:13.471 --> 00:40:14.470
PROFESSOR: Yeah exactly.

00:40:14.470 --> 00:40:17.610
This would not occur on an
exam unless you think a lot,

00:40:17.610 --> 00:40:19.640
you're super inspired, all that.

00:40:19.640 --> 00:40:22.570
If it doesn't occur
to you what do you do?

00:40:22.570 --> 00:40:24.970
AUDIENCE: Go with
the N log K solution.

00:40:24.970 --> 00:40:26.410
PROFESSOR: OK, very good.

00:40:26.410 --> 00:40:27.138
Wait.

00:40:27.138 --> 00:40:28.890
AUDIENCE: K log N.

00:40:28.890 --> 00:40:32.450
PROFESSOR: OK, K log N
or N log K, which one?

00:40:32.450 --> 00:40:33.740
AUDIENCE: K log N.

00:40:33.740 --> 00:40:34.370
PROFESSOR: Why?

00:40:34.370 --> 00:40:36.840
Two reasons.

00:40:36.840 --> 00:40:40.630
K log N is-- so two
reasons, faster and simpler.

00:40:44.510 --> 00:40:47.110
So you write this down.

00:40:47.110 --> 00:40:53.510
And you get half score or 3/4
of the score and you're done.

00:40:53.510 --> 00:40:55.240
It's better than
nothing, anything,

00:40:55.240 --> 00:40:57.630
and getting a 0, right?

00:40:57.630 --> 00:41:01.560
I mean 3/4 of a score for
two lines of pseudocode

00:41:01.560 --> 00:41:03.854
is reasonable, right?

00:41:03.854 --> 00:41:04.645
Two or three lines.

00:41:04.645 --> 00:41:06.231
This is three lines probably.

00:41:10.160 --> 00:41:13.510
Also on most exams
we're humans, right?

00:41:13.510 --> 00:41:16.394
We might mess them up, we
might make them too long.

00:41:16.394 --> 00:41:17.810
If we make them
too long, you want

00:41:17.810 --> 00:41:20.610
to get the most
number of points.

00:41:20.610 --> 00:41:23.050
You'll have time to
figure out one or two

00:41:23.050 --> 00:41:24.170
problems at that level.

00:41:24.170 --> 00:41:26.397
But if we give you too
many, for the rest of them

00:41:26.397 --> 00:41:27.980
you want to have
something simple that

00:41:27.980 --> 00:41:30.954
gives you some of the points.

00:41:30.954 --> 00:41:31.870
Same for an interview.

00:41:31.870 --> 00:41:34.060
For most interviews
most people don't really

00:41:34.060 --> 00:41:37.670
have a clue how many
problems you can solve,

00:41:37.670 --> 00:41:39.420
how many problems
are reasonable.

00:41:39.420 --> 00:41:41.350
So you want, for
every problem you

00:41:41.350 --> 00:41:44.890
want to show some
solution reasonably fast.

00:41:44.890 --> 00:41:46.589
And then see if they're happy.

00:41:46.589 --> 00:41:48.630
And if they're happy move
on to the next problem.

00:41:48.630 --> 00:41:51.990
And if they're not happy
only then spend more time.

00:41:51.990 --> 00:41:54.960
So this is as important as that.

00:41:54.960 --> 00:41:58.100
If you look at the recitation
notes we'll have some problems

00:41:58.100 --> 00:42:00.076
and we'll have some solutions.

00:42:00.076 --> 00:42:01.950
What are going to do,
memorize the solutions?

00:42:01.950 --> 00:42:03.540
Yay, you know how to
solve more problems.

00:42:03.540 --> 00:42:05.498
There are probably a
million problems in total.

00:42:05.498 --> 00:42:07.904
That doesn't get you very far.

00:42:07.904 --> 00:42:09.820
So what you want is to
understand this process

00:42:09.820 --> 00:42:10.694
that we went through.

00:42:10.694 --> 00:42:14.782
So every time we tried
something we got from some point

00:42:14.782 --> 00:42:16.490
to some point with a
better running time.

00:42:16.490 --> 00:42:17.850
Well except for here.

00:42:17.850 --> 00:42:19.890
And where we had more
insight on the problem.

00:42:19.890 --> 00:42:23.030
So this is the important part.

00:42:23.030 --> 00:42:27.080
And I'm going to show you one
more problem, really quickly.

00:42:27.080 --> 00:42:29.200
We're probably not going
to be able to solve it,

00:42:29.200 --> 00:42:30.660
because it's hard.

00:42:30.660 --> 00:42:32.660
But we are going
to talk about it

00:42:32.660 --> 00:42:36.300
and see if we can
get some insight.

00:42:36.300 --> 00:42:38.730
Let's see, what do
I want to erase?

00:42:38.730 --> 00:42:39.968
This.

00:42:39.968 --> 00:42:41.462
I like that.

00:43:02.910 --> 00:43:07.380
All right, so we have an array
random numbers, 7, 2, 5--

00:43:07.380 --> 00:43:15.020
this time there's no
order in it-- 8, 9, 4.

00:43:15.020 --> 00:43:18.340
And we tell you that the
array has 2 to the N numbers,

00:43:18.340 --> 00:43:20.280
to make the problem easier.

00:43:20.280 --> 00:43:22.534
1, 2, 3, 4, 5, 6, 7.

00:43:26.390 --> 00:43:27.840
6.

00:43:27.840 --> 00:43:30.030
So you have this array.

00:43:30.030 --> 00:43:33.580
And we want to answer
queries of this shape.

00:43:33.580 --> 00:43:37.080
Say this array is E,
and it has N elements,

00:43:37.080 --> 00:43:40.750
and you know that N
is some 2 to the K.

00:43:40.750 --> 00:43:45.240
Minimum of all the
elements from i to j.

00:43:47.870 --> 00:43:49.552
So you have two
phases, just like we

00:43:49.552 --> 00:43:50.760
had on a problem on the exam.

00:43:50.760 --> 00:43:53.093
You have a pre-processing
stage where you get the array,

00:43:53.093 --> 00:43:56.342
you do some computation,
you save some information.

00:43:56.342 --> 00:43:57.800
And then you have
a querying phase,

00:43:57.800 --> 00:44:02.280
where you have to answer
these as fast as possible.

00:44:02.280 --> 00:44:04.310
I see most people
have unhappy faces.

00:44:04.310 --> 00:44:06.740
Bad memories, huh?

00:44:06.740 --> 00:44:09.780
OK let's not worry
about that problem.

00:44:09.780 --> 00:44:11.820
Let's look at this one.

00:44:11.820 --> 00:44:14.210
So assuming you have
as much time as you

00:44:14.210 --> 00:44:16.900
want to do the
pre-processing, what's

00:44:16.900 --> 00:44:20.260
the fastest way you
could answer these?

00:44:20.260 --> 00:44:22.065
Yes?

00:44:22.065 --> 00:44:23.460
AUDIENCE: If you
had as much time

00:44:23.460 --> 00:44:27.055
for pre-processing
[INAUDIBLE] memorize it.

00:44:27.055 --> 00:44:27.930
PROFESSOR: All right.

00:44:27.930 --> 00:44:32.510
So if we compute the answers to
all possible solutions, right?

00:44:32.510 --> 00:44:34.770
How would I store that?

00:44:34.770 --> 00:44:37.930
So I want to do this in order 1.

00:44:37.930 --> 00:44:40.266
So how would I
store these answers?

00:44:40.266 --> 00:44:43.220
AUDIENCE: Just sort your array.

00:44:43.220 --> 00:44:44.885
PROFESSOR: OK so
I sort my array.

00:44:44.885 --> 00:44:47.830
AUDIENCE: Then you want
the minimum from i to j,

00:44:47.830 --> 00:44:50.770
so look at the ith element
and that's your [INAUDIBLE].

00:44:59.610 --> 00:45:01.650
PROFESSOR: OK so figure it out?

00:45:04.690 --> 00:45:06.921
Well I mean if I can sort
it I can also say hey,

00:45:06.921 --> 00:45:08.420
why don't we use
this array instead?

00:45:12.016 --> 00:45:13.390
And then I'll
answer the queries.

00:45:18.820 --> 00:45:21.600
You can go off a tangent
trying to sort the elements

00:45:21.600 --> 00:45:22.550
and keep their keys.

00:45:22.550 --> 00:45:25.230
The important thing is if
you think about it for awhile

00:45:25.230 --> 00:45:27.570
and you see that things
stop making sense, back out.

00:45:27.570 --> 00:45:29.627
Look somewhere else.

00:45:29.627 --> 00:45:31.710
We spent some time trying
to find a solution based

00:45:31.710 --> 00:45:34.410
on sorting in my last section.

00:45:34.410 --> 00:45:36.030
It's not going to work.

00:45:36.030 --> 00:45:38.252
So--

00:45:38.252 --> 00:45:42.570
AUDIENCE: Can't you just take
the [INAUDIBLE] from i to j?

00:45:45.032 --> 00:45:46.740
PROFESSOR: OK let's
get to that in a bit.

00:45:46.740 --> 00:45:47.865
So let's keep that in mind.

00:45:47.865 --> 00:45:50.960
Because that's another point
on the trade off curve.

00:45:50.960 --> 00:45:54.970
So if I want to serve
my queries in order 1,

00:45:54.970 --> 00:46:01.780
then the way I do that is I will
have a hash of all the arrays

00:46:01.780 --> 00:46:04.100
that look like i, j.

00:46:04.100 --> 00:46:08.790
So all the possible intervals.

00:46:08.790 --> 00:46:12.830
And I'll store the answer here.

00:46:12.830 --> 00:46:18.200
The minimum the
elements from i to j.

00:46:18.200 --> 00:46:20.950
And I can do a hash lookup
in order 1 and get the answer

00:46:20.950 --> 00:46:23.490
and return the answer.

00:46:23.490 --> 00:46:25.080
How many elements
so I have here?

00:46:28.760 --> 00:46:31.739
So how much storage do
I have to use for this?

00:46:31.739 --> 00:46:32.780
AUDIENCE: O of N squared.

00:46:32.780 --> 00:46:38.560
PROFESSOR: OK N values for this,
N values for this, so roughly

00:46:38.560 --> 00:46:40.540
N squared.

00:46:40.540 --> 00:46:43.620
What's the time
for computing this?

00:46:43.620 --> 00:46:44.930
Brute force, let's not think.

00:46:44.930 --> 00:46:48.314
What's the time
for computing this?

00:46:48.314 --> 00:46:49.280
AUDIENCE: N cubed.

00:46:49.280 --> 00:46:50.179
PROFESSOR: N cubed.

00:46:50.179 --> 00:46:50.845
You're thinking.

00:46:54.290 --> 00:46:56.370
So I have unsquared
elements here.

00:46:56.370 --> 00:46:59.060
For every element
I have to compute

00:46:59.060 --> 00:47:04.330
the minimum of potentially
order N elements, right?

00:47:04.330 --> 00:47:05.350
So this is N cubed.

00:47:05.350 --> 00:47:08.110
I could reduce it to N squared
by noticing that if I have

00:47:08.110 --> 00:47:10.390
the minimum of these
elements, and I

00:47:10.390 --> 00:47:13.050
want to compute the
minimum of these elements,

00:47:13.050 --> 00:47:14.980
really all I have to
do is compute, compare

00:47:14.980 --> 00:47:18.000
this minimum with this element.

00:47:18.000 --> 00:47:20.730
So every time I start
with an interval of size 1

00:47:20.730 --> 00:47:22.550
and then I expand it by 1.

00:47:22.550 --> 00:47:24.350
So I have my two for loops here.

00:47:24.350 --> 00:47:27.310
And I keep growing my minimum.

00:47:27.310 --> 00:47:33.025
So I could get down to
order of N squared times.

00:47:37.210 --> 00:47:41.750
So I have one solution
that has order

00:47:41.750 --> 00:47:44.280
of N squared time and
space, and then answers

00:47:44.280 --> 00:47:46.480
the queries in order 1.

00:47:46.480 --> 00:47:49.790
You had a solution you
said where, what you do

00:47:49.790 --> 00:47:53.890
is, when you get a query
you compute this, right?

00:47:53.890 --> 00:47:55.890
You were suggesting
sorting the array.

00:47:55.890 --> 00:47:58.715
That would be N log N. I
would suggest not sorting it.

00:47:58.715 --> 00:48:00.840
Do the splicing, you look
through all the elements,

00:48:00.840 --> 00:48:03.596
and you find the minimum.

00:48:03.596 --> 00:48:06.844
AUDIENCE: I was saying that
if the original E spans i to j

00:48:06.844 --> 00:48:08.660
and started at the--

00:48:08.660 --> 00:48:10.410
PROFESSOR: So when you
get a query the i's

00:48:10.410 --> 00:48:14.300
and j's change for every query.

00:48:14.300 --> 00:48:16.710
Otherwise we could
compute the answer.

00:48:16.710 --> 00:48:21.300
So we have one answer
where we take order

00:48:21.300 --> 00:48:23.510
N time to answer a query.

00:48:23.510 --> 00:48:25.768
And what do we do
for pre-processing?

00:48:32.400 --> 00:48:32.900
Nothing.

00:48:32.900 --> 00:48:34.940
Order 1.

00:48:34.940 --> 00:48:39.350
So these are two ends
of a trade off, right?

00:48:39.350 --> 00:48:43.257
One possible extreme is that you
pre-compute all your answers.

00:48:43.257 --> 00:48:45.590
The other possible extreme
is that you don't do anything

00:48:45.590 --> 00:48:47.590
and you brute
force every answer.

00:48:47.590 --> 00:48:49.704
And now we want to
find a point somewhere

00:48:49.704 --> 00:48:51.120
on this line between
the extremes.

00:48:55.320 --> 00:48:57.800
So the answer that we're
going to show in the solutions

00:48:57.800 --> 00:49:05.980
uses order N log N space.

00:49:05.980 --> 00:49:09.240
And it answers
the query by using

00:49:09.240 --> 00:49:17.580
order 1 elements in this
order N log N data structure.

00:49:17.580 --> 00:49:20.550
So I have order N
log N partial minima.

00:49:20.550 --> 00:49:24.540
And I will only use two of them.

00:49:24.540 --> 00:49:28.300
So the total running time
isn't actually order 1.

00:49:28.300 --> 00:49:30.898
But we only use
order 1 elements.

00:49:35.350 --> 00:49:39.600
Let's start thinking
very quickly.

00:49:39.600 --> 00:49:42.070
Let's think for about a
minute, and then we'll

00:49:42.070 --> 00:49:44.460
go through the solution.

00:49:44.460 --> 00:49:45.864
And there are
multiple solutions.

00:49:45.864 --> 00:49:47.780
All of them are interesting
in different ways.

00:49:47.780 --> 00:49:50.200
And there are other
solutions that

00:49:50.200 --> 00:49:55.002
are equally fun and applicable
with not the same running time.

00:50:00.820 --> 00:50:02.155
Let me make some space here.

00:50:26.647 --> 00:50:28.980
So like I said, thinking is
a useful process on its own.

00:50:28.980 --> 00:50:31.510
So you're getting better
just by doing this.

00:50:35.010 --> 00:50:38.760
AUDIENCE: [INAUDIBLE] using
more than one space total?

00:50:38.760 --> 00:50:40.520
PROFESSOR: We're
using N log N space.

00:50:40.520 --> 00:50:43.106
AUDIENCE: Oh and it
takes constant time--

00:50:43.106 --> 00:50:44.980
PROFESSOR: It will only
look at two elements.

00:50:44.980 --> 00:50:46.313
It's actually not constant time.

00:50:46.313 --> 00:50:48.730
We're not going to worry
too much about time.

00:50:48.730 --> 00:50:51.722
It turns out being log.

00:50:51.722 --> 00:50:53.700
AUDIENCE: Ok, what
was the order 1 then?

00:50:53.700 --> 00:50:56.440
PROFESSOR: You only
access order 1 elements.

00:50:56.440 --> 00:50:58.854
Order 1 partial minimum.

00:50:58.854 --> 00:50:59.562
AUDIENCE: Oh, OK.

00:51:04.442 --> 00:51:07.370
Does it have to do
with two different K?

00:51:07.370 --> 00:51:08.346
PROFESSOR: Maybe.

00:51:08.346 --> 00:51:12.738
AUDIENCE: I don't know
what to do with that.

00:51:12.738 --> 00:51:14.770
There's probably some
sort of tree involved.

00:51:21.120 --> 00:51:23.536
PROFESSOR: So you're going to
want to split things, right?

00:51:23.536 --> 00:51:25.130
Into halves.

00:51:25.130 --> 00:51:28.020
And you're going to want to be
able to do this all the time.

00:51:28.020 --> 00:51:30.800
And we say 2 to the K so we
don't have to worry about,

00:51:30.800 --> 00:51:33.384
oh my God what happens if
the halves aren't equal?

00:51:33.384 --> 00:51:35.800
You can usually solve this
when you implement the problem.

00:51:35.800 --> 00:51:38.000
But it's useful
to not worry about

00:51:38.000 --> 00:51:41.760
that when you come up
with your first algorithm.

00:51:41.760 --> 00:51:43.656
If you're going to start
dividing in halves.

00:51:53.586 --> 00:51:54.502
AUDIENCE: [INAUDIBLE].

00:51:59.460 --> 00:52:00.415
PROFESSOR: Um.

00:52:00.415 --> 00:52:01.331
AUDIENCE: [INAUDIBLE].

00:52:04.740 --> 00:52:08.090
PROFESSOR: So that leads
to another useful solution.

00:52:08.090 --> 00:52:12.060
That leads to a solution
that takes-- that has N log N

00:52:12.060 --> 00:52:14.340
storage and it will
run in N log N time

00:52:14.340 --> 00:52:17.210
with N log N element axes.

00:52:17.210 --> 00:52:18.790
So what you thinking
of is you're

00:52:18.790 --> 00:52:21.710
going to have your array
of elements, right?

00:52:21.710 --> 00:52:25.510
And say you want to find the
minimum from here to here.

00:52:25.510 --> 00:52:28.380
You're going to have
your array split in half.

00:52:28.380 --> 00:52:31.620
So you're going to find
the minimum of this,

00:52:31.620 --> 00:52:33.377
and the minimum of this.

00:52:33.377 --> 00:52:34.960
But to do that you'll
have to recurse.

00:52:34.960 --> 00:52:37.075
So this is also
say split in half.

00:52:37.075 --> 00:52:40.550
So you'll have to
find-- so it turns out

00:52:40.550 --> 00:52:42.340
that if you do this,
in the end you'll

00:52:42.340 --> 00:52:46.300
have log N minima that
you have to look at.

00:52:46.300 --> 00:52:49.600
But this is more, this is a
cooler and more useful thing,

00:52:49.600 --> 00:52:51.570
so I'll try to put it
on a PSet or something

00:52:51.570 --> 00:52:53.820
to make you think about it.

00:52:53.820 --> 00:52:55.526
So this is-- don't
tell people yet.

00:52:55.526 --> 00:52:57.150
You might have a
solution to a problem.

00:53:05.880 --> 00:53:07.350
AUDIENCE: [INAUDIBLE].

00:53:07.350 --> 00:53:09.100
PROFESSOR: OK.

00:53:09.100 --> 00:53:13.100
So what we thought of, or the
way we thought of doing it,

00:53:13.100 --> 00:53:19.870
is 6, 7, 2, 5, 3, 8, 9, 4.

00:53:19.870 --> 00:53:21.630
So we compute these
partial minima.

00:53:21.630 --> 00:53:23.930
We split the array into two.

00:53:23.930 --> 00:53:28.313
And these are the
minima that we compute.

00:53:32.480 --> 00:53:35.994
Sorry, this is like
this, this is like this.

00:53:38.940 --> 00:53:42.022
So everything, so all the
left half then these guys,

00:53:42.022 --> 00:53:44.510
then these guys, then this guy.

00:53:44.510 --> 00:53:48.510
Everything here, then these
guys, then these guys,

00:53:48.510 --> 00:53:50.220
then this guy.

00:53:50.220 --> 00:53:55.100
So if your i and j are on
different sides of the middle,

00:53:55.100 --> 00:53:58.110
then you do two
lookups, you're done.

00:53:58.110 --> 00:54:00.810
If they're in the
same half, then you

00:54:00.810 --> 00:54:02.759
have a problem
that's half the size.

00:54:02.759 --> 00:54:04.800
So you're going to have
to take this array that's

00:54:04.800 --> 00:54:07.380
half the size, 2, 5.

00:54:07.380 --> 00:54:09.410
Split it into halves
and do the same thing.

00:54:12.290 --> 00:54:15.690
And then we're going to have to
do the same to this other one.

00:54:15.690 --> 00:54:19.450
3, 8, 9, 4, split it into
halves and do the same thing.

00:54:23.010 --> 00:54:25.110
So in the end you'll
end up in someplace

00:54:25.110 --> 00:54:29.410
where your interval ages are on
different sides of the middle.

00:54:29.410 --> 00:54:33.420
And you look at two
elements and you're done.

00:54:33.420 --> 00:54:35.860
Let's see how much
space this takes.

00:54:35.860 --> 00:54:38.770
Can someone tell me a
recursion for how much

00:54:38.770 --> 00:54:45.220
space, for how many minimums
I would need to keep?

00:54:45.220 --> 00:54:47.220
So space for an elements is?

00:54:51.070 --> 00:54:54.990
AUDIENCE: The first
level you have 8.

00:54:54.990 --> 00:54:59.390
So go down by an order of 2.

00:54:59.390 --> 00:55:01.780
PROFESSOR: So what's
the first level?

00:55:01.780 --> 00:55:03.010
AUDIENCE: Of 8 N.

00:55:03.010 --> 00:55:05.200
PROFESSOR: So order N plus?

00:55:08.310 --> 00:55:09.550
AUDIENCE: N over 2?

00:55:09.550 --> 00:55:10.682
t of N over 2?

00:55:10.682 --> 00:55:12.140
PROFESSOR: OK S
because it's space.

00:55:12.140 --> 00:55:13.560
N over 2.

00:55:13.560 --> 00:55:16.045
OK.

00:55:16.045 --> 00:55:16.545
And?

00:55:18.750 --> 00:55:19.666
AUDIENCE: [INAUDIBLE].

00:55:22.940 --> 00:55:24.660
PROFESSOR: You're
missing something.

00:55:24.660 --> 00:55:25.930
Look at this picture.

00:55:25.930 --> 00:55:27.970
So this is the whole thing.

00:55:27.970 --> 00:55:29.590
Then I have a half.

00:55:29.590 --> 00:55:33.120
And then what else do I have?

00:55:33.120 --> 00:55:33.910
AUDIENCE: 2.

00:55:33.910 --> 00:55:35.008
PROFESSOR: The other half.

00:55:35.008 --> 00:55:36.229
AUDIENCE: Oh, 2.

00:55:36.229 --> 00:55:38.270
PROFESSOR: OK so the
difference between these two

00:55:38.270 --> 00:55:39.853
is that one of them
gives you order N,

00:55:39.853 --> 00:55:43.170
the other one gives you N log
N. So I gave you the answer,

00:55:43.170 --> 00:55:45.050
so I can't ask you
for the answer now.

00:55:45.050 --> 00:55:46.870
But where did we
see this before?

00:55:46.870 --> 00:55:48.130
Pretend these are t's.

00:55:48.130 --> 00:55:49.310
AUDIENCE: [INAUDIBLE].

00:55:49.310 --> 00:55:50.620
PROFESSOR: Sorry?

00:55:50.620 --> 00:55:53.450
So these are t's, this is the
recursion for [? more sort ?].

00:55:53.450 --> 00:55:56.049
So once you put it up you
don't draw the recursion tree

00:55:56.049 --> 00:55:56.590
and solve it.

00:55:56.590 --> 00:55:59.270
You say this is what we saw
in [? more sort. ?] Therefore,

00:55:59.270 --> 00:56:05.720
the solution is N
log N. So this is

00:56:05.720 --> 00:56:07.380
how you show you
have N log N space,

00:56:07.380 --> 00:56:09.290
and it's pretty clear
that you're only

00:56:09.290 --> 00:56:10.975
going to access two elements.

00:56:10.975 --> 00:56:12.875
AUDIENCE: I don't
understand how [INAUDIBLE].

00:56:16.680 --> 00:56:18.070
PROFESSOR: How it works?

00:56:18.070 --> 00:56:23.340
So you have your i
and you have your j.

00:56:23.340 --> 00:56:25.250
Let's make that one i here.

00:56:25.250 --> 00:56:27.385
If you want to find
the minimum, if i and j

00:56:27.385 --> 00:56:33.550
are on different sides of the
half, you have this and this.

00:56:33.550 --> 00:56:36.060
And these two partial minima
cover your entire interval.

00:56:39.830 --> 00:56:44.630
Now if they're on the
same side of the half then

00:56:44.630 --> 00:56:47.121
you recurse to a
smaller problem.

00:56:47.121 --> 00:56:49.537
AUDIENCE: Well you don't have
to there because you already

00:56:49.537 --> 00:56:52.140
have the minimum
of that section.

00:56:52.140 --> 00:56:53.875
PROFESSOR: Yeah.

00:56:53.875 --> 00:56:57.280
AUDIENCE: It wouldn't work
if you had 6 and 2, right?

00:56:57.280 --> 00:56:59.220
Or that.

00:56:59.220 --> 00:57:00.636
PROFESSOR: Yeah.

00:57:00.636 --> 00:57:03.410
AUDIENCE: Well why not
just take 7 and 2 then?

00:57:03.410 --> 00:57:05.657
Why do you have to break
up the entire panel?

00:57:05.657 --> 00:57:07.490
PROFESSOR: Assume there's
more things there.

00:57:10.490 --> 00:57:11.440
AUDIENCE: Oh I see.

00:57:11.440 --> 00:57:16.660
PROFESSOR: So if you have this,
now it's no longer true, right?

00:57:16.660 --> 00:57:19.830
So wherever they are
here, you do that.

00:57:19.830 --> 00:57:22.670
And remember your pseudocode
has to be as simple as possible

00:57:22.670 --> 00:57:24.730
to reduce the
probability of bugs.

00:57:24.730 --> 00:57:26.870
So you want to do the
simplest possible thing,

00:57:26.870 --> 00:57:29.680
not have special cases.

00:57:29.680 --> 00:57:31.670
OK.

00:57:31.670 --> 00:57:33.450
By the way there's
a study that shows

00:57:33.450 --> 00:57:37.080
that for good or bad
programmers, if you have

00:57:37.080 --> 00:57:40.724
1,000 lines of code, there's a
constant probability of a bug.

00:57:40.724 --> 00:57:42.390
And the constants are
different for good

00:57:42.390 --> 00:57:45.830
versus bad programmers,
but it's still a constant.

00:57:45.830 --> 00:57:49.030
So how many mistakes
you make is directly

00:57:49.030 --> 00:57:50.957
proportional to
how much you write.

00:57:50.957 --> 00:57:52.498
This is why we like
simple solutions.

00:57:55.850 --> 00:57:59.350
OK, any questions on this?

00:57:59.350 --> 00:58:00.990
So we have four problems.

00:58:00.990 --> 00:58:02.390
We didn't cover one.

00:58:02.390 --> 00:58:04.830
Look at the other one,
look at the solution.

00:58:04.830 --> 00:58:07.120
Ideally look at the problem,
think for at least half

00:58:07.120 --> 00:58:09.320
an hour, then look
at the solution.

00:58:09.320 --> 00:58:11.792
What I want you to take
away is not just oh, here

00:58:11.792 --> 00:58:14.000
are three problems, let's
memorize how we solve them.

00:58:14.000 --> 00:58:15.780
But the whole process
thing, and how

00:58:15.780 --> 00:58:19.100
we played with data structures
and how we used all the hints

00:58:19.100 --> 00:58:23.170
that we possibly could to build
more insights into the problem.

00:58:23.170 --> 00:58:25.020
OK, cool.