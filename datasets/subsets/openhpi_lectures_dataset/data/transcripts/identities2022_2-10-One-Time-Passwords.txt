WEBVTT

1
00:00:01.480 --> 00:00:06.620 
Now we consider One-Time Passwords in our
openHPI course about Digital Identities.

2
00:00:07.980 --> 00:00:10.790 
When we speak about
password-based authentication,

3
00:00:11.390 --> 00:00:17.140 
we every time saw a question mark
concerning the security, because

4
00:00:17.150 --> 00:00:20.310 
password-based authentication
is not considered

5
00:00:20.880 --> 00:00:25.930 
secure enough and one needs to do a
lot to use it in the right way.

6
00:00:26.610 --> 00:00:33.530 
But one possibility to really secure
passwords for authentication is possible

7
00:00:33.870 --> 00:00:36.150 
by means of one-time
passwords.

8
00:00:36.890 --> 00:00:40.480 
The idea behind such one-time
passwords is exactly what the name

9
00:00:40.690 --> 00:00:46.610 
tells us: each password can only
be used once for authentication,

10
00:00:47.130 --> 00:00:51.280 
after it is used it
loses its validity.

11
00:00:51.910 --> 00:00:57.860 
So it makes no sense to look for this,
to spy out, to use keyloggers,

12
00:00:57.860 --> 00:01:02.290 
all these kinds of attacks that we saw (in the
previous chapter) to get the password in the

13
00:01:02.290 --> 00:01:08.880 
hand of an attacker, because after
it is used it's no more usable for

14
00:01:09.430 --> 00:01:15.940 
authentication. Typically such one-time
passwords are automatically and randomly

15
00:01:16.190 --> 00:01:18.000 
generated character
strings

16
00:01:18.640 --> 00:01:23.180 
that are sent to a user over a second
independent transmission channel.

17
00:01:25.190 --> 00:01:29.760 
Let's have a closer look at the
provision of one-time passwords.

18
00:01:30.190 --> 00:01:33.430 
On the one side, it's a very secure
way, on the other side for

19
00:01:33.430 --> 00:01:35.990 
each authentication we
need a new password.

20
00:01:36.440 --> 00:01:40.140 
So, the challenge here
is that both the user

21
00:01:40.610 --> 00:01:45.290 
as well as the authentication
authority, the service or the

22
00:01:45.290 --> 00:01:51.020 
ID provider of that service must know
which one-time password is valid

23
00:01:51.220 --> 00:01:54.860 
and which ones are
already used.

24
00:01:56.020 --> 00:02:00.680 
To this challenge, there are two possible
solutions: the one solution is

25
00:02:00.910 --> 00:02:02.680 
to work with
password lists.

26
00:02:04.430 --> 00:02:08.110 
This is a list of valid
one-time passwords

27
00:02:08.520 --> 00:02:12.680 
that's generated by the
authentication authority and it is

28
00:02:12.680 --> 00:02:16.810 
transmitted to the user over a
second secure transport channel,

29
00:02:17.110 --> 00:02:20.720 
it could not be sent over the
internet because then everyone can,

30
00:02:21.030 --> 00:02:23.130 
every attacker can
get access to it.

31
00:02:23.740 --> 00:02:30.390 
And you know this, for
example, "TAN Lists" in

32
00:02:30.680 --> 00:02:32.030 
case of online
banking, the "mTAN"

33
00:02:34.390 --> 00:02:40.110 
procedures and others, they are working
on the basis of such password lists.

34
00:02:40.700 --> 00:02:45.690 
And then the second possibility
to solve the challenge

35
00:02:46.130 --> 00:02:48.040 
is that both user and

36
00:02:48.670 --> 00:02:53.440 
the authentication authority needs
to know which is valid and which

37
00:02:53.440 --> 00:02:58.420 
is an invalid password. It's the
work with password generators:

38
00:02:58.940 --> 00:03:03.210 
password generators dynamically
generate one-time passwords

39
00:03:03.690 --> 00:03:08.490 
that are only valid in
a certain time span.

40
00:03:10.130 --> 00:03:15.290 
If we have a closer look at such
password generators, then

41
00:03:15.780 --> 00:03:22.160 
these are small devices often called
"tokens" or applications on your computer.

42
00:03:22.900 --> 00:03:28.870 
The password generators they produce
one-time passwords by means of

43
00:03:29.030 --> 00:03:32.200 
special algorithms. These
algorithms are known

44
00:03:32.690 --> 00:03:36.630 
to the authentication
authority and

45
00:03:37.490 --> 00:03:41.710 
can be run in three
different ways.

46
00:03:42.320 --> 00:03:47.960 
We can distinguish, Time-Controlled
one-time password generator,

47
00:03:48.410 --> 00:03:53.830 
we can distinguish, Event-Driven
generation of a one-time

48
00:03:53.830 --> 00:03:57.610 
password, and we can see the
Challenge and Response-Controlled

49
00:03:57.790 --> 00:03:59.300 
generation of
a password.

50
00:03:59.910 --> 00:04:04.580 
Let's have a closer look at these three
possibilities because it's an interesting topic

51
00:04:04.780 --> 00:04:09.740 
that at a certain moment the user
needs a new password to authenticate

52
00:04:10.680 --> 00:04:14.280 
for a service, for an
online service, and the

53
00:04:14.760 --> 00:04:19.080 
authentication authority needs to
know exactly this password

54
00:04:19.340 --> 00:04:22.160 
to give the user access
or to prevent access.

55
00:04:22.870 --> 00:04:28.320 
The Time-Controlled one-time password
generator works as following: The token

56
00:04:28.810 --> 00:04:33.330 
and authentication authority,
a token is on the

57
00:04:33.330 --> 00:04:36.870 
side of the user, the authentication
authority is on the side of the service,

58
00:04:37.120 --> 00:04:38.870 
they work
synchronously.

59
00:04:40.020 --> 00:04:44.770 
Both sides calculate one-time
passwords at the same time interval

60
00:04:45.050 --> 00:04:48.040 
which are valid until

61
00:04:48.840 --> 00:04:52.610 
the use or the next
calculation iteration.

62
00:04:53.370 --> 00:04:58.960 
So, each time the token compute
something, it is known by the

63
00:04:59.610 --> 00:05:04.240 
authentication authority and it's accepted
but only for a very short time.

64
00:05:05.390 --> 00:05:10.280 
The authentication authority allows
a certain time tolerance range,

65
00:05:11.070 --> 00:05:14.920 
as the clock in the token is
not already 100% accurate.

66
00:05:15.210 --> 00:05:19.430 
So, both are based on the time,
and exactly for this time span

67
00:05:19.580 --> 00:05:26.360 
around the systems on both sides, this
one-time password is computed. An example,

68
00:05:26.560 --> 00:05:30.090 
here is the "Google
Authenticator".

69
00:05:32.140 --> 00:05:33.380 
The google
authenticator.

70
00:05:34.020 --> 00:05:41.410 
Here is such a token as in the RSA
token and the google authenticator.

71
00:05:42.420 --> 00:05:47.280 
This RSA authenticator is
used for the "SecurID"

72
00:05:47.690 --> 00:05:53.120 
approach. So, here on this device and on the
other side, the same computation is done

73
00:05:53.540 --> 00:05:59.250 
starting from the time point, and google
authenticator is another approach.

74
00:06:00.320 --> 00:06:05.170 
How is the one-time password created
in case of Event-Controlled

75
00:06:05.220 --> 00:06:07.050 
one-time password
generation?

76
00:06:07.720 --> 00:06:12.330 
The generation of a one time
password here is triggered

77
00:06:12.570 --> 00:06:19.390 
by the user or by key-pressing or
by pressing a key on a token,

78
00:06:19.790 --> 00:06:25.260 
then exactly at this moment the token
and the authentication authority

79
00:06:25.440 --> 00:06:29.580 
remember the number of previously
generated passwords.

80
00:06:30.040 --> 00:06:31.750 
The token generates a
new one-time password,

81
00:06:32.490 --> 00:06:36.290 
and the authority
knows that now a new

82
00:06:36.290 --> 00:06:40.460 
one-time password is used for
authentication and in this way the

83
00:06:41.520 --> 00:06:45.210 
one-time password is known
on the side of the user,

84
00:06:45.210 --> 00:06:47.710 
as well on the side of the
authentication authority.

85
00:06:48.360 --> 00:06:52.620 
The calculation of the one-time
password here is carried out

86
00:06:52.820 --> 00:06:55.670 
using previously
generated passwords,

87
00:06:56.540 --> 00:07:01.320 
and also here the authentication
authority allows a tolerance range,

88
00:07:01.610 --> 00:07:04.460 
just in case the
user has not used

89
00:07:04.960 --> 00:07:06.310 
a generated password.

90
00:07:07.630 --> 00:07:14.020 
Then the third approach to solve this challenge
is the Challenge-Response-Controlled

91
00:07:14.130 --> 00:07:15.780 
one-time password
generation.

92
00:07:16.580 --> 00:07:24.170 
Here the user wants to authenticate him/herself
and asks the authentication authority.

93
00:07:24.770 --> 00:07:30.170 
The procedure looks like the following:
The authentication authority

94
00:07:30.770 --> 00:07:35.990 
sends - when the user is requesting,
a random value to the token.

95
00:07:37.390 --> 00:07:40.390 
By the calculation algorithms
that are also known to the

96
00:07:41.010 --> 00:07:47.580 
authentication authority, the token
generates from the received input

97
00:07:48.500 --> 00:07:54.440 
a one-time password. Then the
user sends the generated

98
00:07:54.480 --> 00:07:57.470 
one-time password to the
authentication authority.

99
00:07:58.020 --> 00:08:03.190 
The authentication authority knows which
was the initial value, they know the

100
00:08:03.510 --> 00:08:08.040 
algorithm and can do the
calculation on the side

101
00:08:09.050 --> 00:08:13.010 
of the authentication service and
then they can decide whether

102
00:08:14.530 --> 00:08:18.670 
the value, the one-time
password is valid

103
00:08:19.270 --> 00:08:23.630 
or not, and if it's correct then
the user is authenticated.

104
00:08:24.610 --> 00:08:26.910 
So, to summarize
what we

105
00:08:27.540 --> 00:08:31.420 
have learned about such
one-time passwords:

106
00:08:32.230 --> 00:08:37.820 
One-time passwords can only be
used once as the name is saying.

107
00:08:38.350 --> 00:08:42.710 
Provision is done by means
of a password list

108
00:08:43.740 --> 00:08:49.130 
or a password generator. And for the
password generators, we can distinguish

109
00:08:49.350 --> 00:08:53.450 
between Time-controlled one-time
password generation,

110
00:08:53.760 --> 00:08:58.960 
Event-Driven generation, and
Challenge-Response-Controlled generation
