WEBVTT

1
00:00:00.690 --> 00:00:05.850 
Now we consider the length of passwords
and we will discuss the importance

2
00:00:06.170 --> 00:00:09.610 
of the large length of
passwords in our openHPI

3
00:00:10.440 --> 00:00:12.050 
course about Digital
Identities.

4
00:00:12.880 --> 00:00:19.110 
This password length really has a great influence
(I will show later figures about that)

5
00:00:21.420 --> 00:00:25.580 
on the strength, on the security
of a password and the efficiency

6
00:00:25.900 --> 00:00:30.060 
of possible password
attacks. Reminder -

7
00:00:31.680 --> 00:00:36.910 
notes on generating
secure passwords: we

8
00:00:37.460 --> 00:00:43.370 
recommended to use upper and lower case letters,
we recommended different character classes

9
00:00:43.700 --> 00:00:49.640 
to use - when passwords are formed, character
classes like letters, numbers, and

10
00:00:49.890 --> 00:00:55.330 
special characters. We proposed to
have passwords at least of length

11
00:00:55.640 --> 00:01:03.730 
12 and we advised taking passwords
- not from dictionaries and

12
00:01:04.130 --> 00:01:11.190 
also not from the user context, and we
warned that password should never be used,

13
00:01:11.360 --> 00:01:15.990 
that the same password should never
be used for different services.

14
00:01:17.390 --> 00:01:18.620 
Now we want to
consider,

15
00:01:19.260 --> 00:01:26.750 
why we give such advices, and what are
the reasons for these indications.

16
00:01:28.490 --> 00:01:32.330 
Let's remember the brute force
attacks. Brute-force attacks are

17
00:01:32.330 --> 00:01:37.960 
the simplest and most straight forward
attacks to crack a password. And the idea

18
00:01:38.220 --> 00:01:45.150 
we already discuss this, is the systematic
test of all possible character combinations

19
00:01:45.440 --> 00:01:49.670 
for a selected character
class at a given length.

20
00:01:50.660 --> 00:01:57.240 
So with sufficient time and resources,
brute force always leads to

21
00:01:57.560 --> 00:02:02.580 
the goal, because the password
is a concrete combination and

22
00:02:03.120 --> 00:02:07.470 
when we check all possible combinations,
we also find this combination.

23
00:02:08.450 --> 00:02:15.520 
So the trick for this brute force
attack not to be successful

24
00:02:16.120 --> 00:02:22.760 
is to provide, to use long passwords,
so that it's no more possible,

25
00:02:23.070 --> 00:02:25.850 
that the time that's available
for the attack is not enough

26
00:02:26.050 --> 00:02:29.170 
to perform such brute
force attacks.

27
00:02:29.870 --> 00:02:38.070 
So the formula which explains why each of
a digital letter helps is the following:

28
00:02:38.560 --> 00:02:42.590 
If we compute the number of
password candidates from all the

29
00:02:43.310 --> 00:02:47.750 
combinations of the character,
then we have to take the number

30
00:02:48.170 --> 00:02:51.160 
of the characters
that are available

31
00:02:52.040 --> 00:02:55.990 
and then to the password length,
have to take this number

32
00:02:55.990 --> 00:02:57.230 
to the password length.

33
00:02:58.050 --> 00:02:59.090 
(Number_of_password_candidates = (range_of_characters)
to the power of Password Length)

34
00:02:59.950 --> 00:03:03.220 
So the larger
this range is,

35
00:03:04.230 --> 00:03:05.640 
the more possibilities

36
00:03:06.320 --> 00:03:11.010 
are available to check this. For
example, if we have only 0 and 1,

37
00:03:11.430 --> 00:03:15.480 
then the number of the
password candidates is

38
00:03:15.910 --> 00:03:20.680 
2 to the power of the length
of the password: 2^8 if the

39
00:03:20.680 --> 00:03:25.300 
password has length 8, but if
we take the letters of our

40
00:03:25.930 --> 00:03:31.310 
alphabet then we have 26
letters, then we have 26

41
00:03:32.890 --> 00:03:35.460 
to the power of 8, if the
password has the length 8.

42
00:03:35.970 --> 00:03:39.670 
But if we are case-sensitive, so
we've distinguished between

43
00:03:39.670 --> 00:03:42.710 
a lower case and an
upper case letter,

44
00:03:43.160 --> 00:03:48.110 
then we have 2 times
26 and that is 52 to

45
00:03:48.260 --> 00:03:52.160 
the power of 8. You see the
more character we use,

46
00:03:52.590 --> 00:03:58.170 
the larger is the number of the
available password candidates,

47
00:03:58.660 --> 00:04:03.390 
and it grows with each additional
thing, it grows exponentially.

48
00:04:05.250 --> 00:04:10.470 
So the idea of the systematic testing is
all possible character combinations

49
00:04:10.760 --> 00:04:15.630 
are used and then by means
of this formula we just

50
00:04:16.160 --> 00:04:21.710 
discussed, one can
expect that after half

51
00:04:22.370 --> 00:04:27.930 
of all the tries, we have found
in the meanwhile, the password.

52
00:04:28.650 --> 00:04:31.900 
So from all the possibilities
if we check randomly,

53
00:04:32.710 --> 00:04:39.910 
the expected time to find
the right password is half

54
00:04:40.140 --> 00:04:42.320 
of the number of
password candidates.

55
00:04:42.870 --> 00:04:47.050 
So to protect our passwords
against brute-force attacks, the

56
00:04:47.050 --> 00:04:51.590 
number of password candidates
needs to be as long as possible.

57
00:04:52.830 --> 00:04:58.000 
To understand this, let's have a closer
look and consider a password consists

58
00:04:58.590 --> 00:05:00.840 
only of lower
case letters.

59
00:05:01.620 --> 00:05:06.440 
These are the letters of our alphabet
with our 26 possible characters,

60
00:05:06.910 --> 00:05:10.130 
and when we also
take numbers

61
00:05:10.730 --> 00:05:15.030 
in our password forming,
then we get 10

62
00:05:16.020 --> 00:05:20.420 
additional characters -
the numbers 0 to 9.

63
00:05:21.540 --> 00:05:25.830 
So the number of possible characters
when we work with these

64
00:05:25.830 --> 00:05:30.240 
two groups, letters and
numbers is 26 + 10 = 36.

65
00:05:31.950 --> 00:05:38.140 
So now let's try and check and
see how many seconds it costs

66
00:05:38.690 --> 00:05:41.910 
to prove all the
possibilities,

67
00:05:42.590 --> 00:05:46.470 
to take each of
the possible

68
00:05:47.020 --> 00:05:52.710 
character, to check this. So if we
have our password of length 1,

69
00:05:52.940 --> 00:05:54.990 
we have to check 36,

70
00:05:55.880 --> 00:05:58.220 


71
00:05:58.940 --> 00:06:03.510 
different characters - 26 from the
alphabet and 10 from the numbers.

72
00:06:03.700 --> 00:06:10.730 
And then if we think, if we assume
that we can do 100 billion

73
00:06:11.260 --> 00:06:14.490 
password check
generation

74
00:06:15.420 --> 00:06:20.650 
in 1 second, then
we need 0.001

75
00:06:21.020 --> 00:06:24.740 
second to check all 36
passwords consisting of 1

76
00:06:26.160 --> 00:06:32.360 
character. If we have to check all
sequences of two different characters,

77
00:06:32.790 --> 00:06:37.350 
then we have 36 times 36 possibilities
or the number of our possible

78
00:06:38.130 --> 00:06:42.320 
password candidates
is: 36 * 36 = 1296,

79
00:06:42.650 --> 00:06:48.210 
and the time we need
is even smaller than

80
00:06:49.730 --> 00:06:53.070 
0.001 sec.

81
00:06:54.320 --> 00:06:58.200 
If we check passwords with
three different characters

82
00:06:58.720 --> 00:07:02.970 
we get 36 times 36
times 36 candidates,

83
00:07:03.270 --> 00:07:08.550 
these are 46 thousand candidates
which we need to check and time is,

84
00:07:09.050 --> 00:07:12.830 
with our assumption that we can
check, that we can generate

85
00:07:12.870 --> 00:07:16.900 
100 billion passwords in a second, what's possible
with modern machines - is the same i.e. 0.001 sec.

86
00:07:17.220 --> 00:07:23.510 
Now with 4 letters,
there are 1,679,616 -

87
00:07:23.510 --> 00:07:25.450 


88
00:07:26.080 --> 00:07:28.500 
different candidates
and it's also

89
00:07:29.710 --> 00:07:33.610 
immediately computed. For 5
letters, we have 60 Million

90
00:07:34.370 --> 00:07:39.540 
and then for 6 letters we have 2 billion, and
now you see, now we start to need more time.

91
00:07:39.760 --> 00:07:42.070 
More time, but it
can be done in a

92
00:07:43.270 --> 00:07:48.420 
small fraction of a second. Again so
all passwords that have length 6,

93
00:07:48.960 --> 00:07:54.280 
it can be done in less than a
second. All passwords that

94
00:07:54.810 --> 00:07:59.280 
have length 7 can be
checked in time of less

95
00:07:59.390 --> 00:08:04.410 
then 1 second. And now if we
have passwords of length 8,

96
00:08:04.940 --> 00:08:10.350 
then it becomes more than a second, which
is needed to test all combinations -

97
00:08:10.940 --> 00:08:16.990 
this takes 28 seconds, it's also
no problem for the attacker.

98
00:08:17.430 --> 00:08:23.840 
Then we come from seconds to minutes,
and if we consider passwords here

99
00:08:24.340 --> 00:08:32.360 
in our example of the length 10 then we
need to check for all the combinations

100
00:08:32.710 --> 00:08:39.240 
of 10 different characters, we
would need more than 10 hours.

101
00:08:41.530 --> 00:08:45.930 
10 hours is also not too much if
an attacker wants to really

102
00:08:45.930 --> 00:08:47.600 
know our password
to misuse

103
00:08:48.370 --> 00:08:56.500 
our account. So what can be done? We can
work with case sensitive characters,

104
00:08:56.840 --> 00:08:59.670 
work with lower case and
upper case letters - it

105
00:09:00.450 --> 00:09:06.430 
doubles the number of characters, and we can
additionally take special characters.

106
00:09:06.750 --> 00:09:13.420 
So even then for passwords with
length 10, we are in a time frame

107
00:09:13.570 --> 00:09:17.010 
that it's possible for the
attackers to get it.

108
00:09:17.810 --> 00:09:21.260 
This is the reason that we
proposed to have length-12,

109
00:09:21.750 --> 00:09:25.450 
because with the
exponential time to check

110
00:09:26.290 --> 00:09:31.940 
passwords with length 12, this would need
years. I will show you a table later.

111
00:09:32.490 --> 00:09:36.560 
So brute-force attacks are often
performed against password hash,

112
00:09:37.110 --> 00:09:43.440 
because the attacker does not know the
password, so the possible password candidate

113
00:09:44.220 --> 00:09:49.650 
need to be hashed and then the attacker
is able to check if this hash,

114
00:09:49.890 --> 00:09:55.640 
if it doesn't agree with the hash from
the database - the customer database.

115
00:09:56.970 --> 00:10:01.440 
So the generated
password hash is

116
00:10:01.970 --> 00:10:04.090 
compared with the
hash the attacker

117
00:10:04.930 --> 00:10:06.610 
has in hand, and
if they match,

118
00:10:07.220 --> 00:10:09.540 
the password candidate
is the password

119
00:10:10.480 --> 00:10:14.440 
the attacker is looking for, and it's
the password that the attacker can use

120
00:10:14.730 --> 00:10:19.990 
to misuse the account
of that user.

121
00:10:21.040 --> 00:10:25.880 
The speed of the brute
force attacks,

122
00:10:25.880 --> 00:10:29.300 
of course, depends
on the calculation

123
00:10:29.740 --> 00:10:33.260 
speed, it depends on the machines
that are available to the attacker,

124
00:10:33.640 --> 00:10:37.790 
and it depends on the hash functions
that are used. So for example,

125
00:10:37.790 --> 00:10:41.460 
with MD5 hashes, one
can calculate or

126
00:10:42.900 --> 00:10:48.900 
compute a hash and perform the
combination faster than with the

127
00:10:49.110 --> 00:10:52.630 
SHA-512 hash.
The SHA-512

128
00:10:54.270 --> 00:10:58.240 
hash is much more secure
than the MD5 hash.

129
00:10:58.740 --> 00:11:02.460 
Here is a table which shows
this cracking complexity,

130
00:11:02.870 --> 00:11:06.530 
so we have here listed the
length of a password,

131
00:11:07.220 --> 00:11:11.290 
and we have a list of the
time that is needed

132
00:11:11.820 --> 00:11:15.940 
to check all the password
candidates. We have the

133
00:11:16.430 --> 00:11:22.960 
differences, when one only uses
the lower case and letters, as

134
00:11:22.960 --> 00:11:25.850 
we did in our example.
If one uses

135
00:11:26.500 --> 00:11:28.160 
the lower and upper
case of the

136
00:11:29.150 --> 00:11:34.960 
letters together with the numbers, and
if one additionally uses the special

137
00:11:35.280 --> 00:11:38.100 
characters then
the number of

138
00:11:39.020 --> 00:11:43.820 
letters that can be placed in
each position is increased. So

139
00:11:44.350 --> 00:11:47.820 
in the cracking process, in
the brute force method more

140
00:11:47.820 --> 00:11:49.220 
combinations have
to be checked.

141
00:11:49.940 --> 00:11:58.060 
Here, with our length of the password, the machine
we already assumed that 100 billion passwords

142
00:11:58.280 --> 00:12:04.230 
can be generated per second, and you see
if one uses a password of length 12,

143
00:12:04.980 --> 00:12:10.120 
which is considered long,
only with these letters,

144
00:12:10.940 --> 00:12:16.770 
only with the lower case and numbers, then
already we need one and a half year

145
00:12:17.550 --> 00:12:25.090 
for checking the password of
length 10. This was our example,

146
00:12:25.370 --> 00:12:32.420 
one needs about 10, about 11 hours.
So with each additional number this

147
00:12:34.070 --> 00:12:38.120 
exponential increasing
shows that waiting years

148
00:12:38.530 --> 00:12:39.900 
to find out the
password.

149
00:12:40.720 --> 00:12:45.900 
This is for the attacker too
costly and too time-intensive.

150
00:12:47.260 --> 00:12:49.900 
So password
length and the

151
00:12:51.990 --> 00:12:56.690 
characters, the group of
characters you are using really

152
00:12:57.760 --> 00:13:03.140 
play great importance for
the security of passwords.
