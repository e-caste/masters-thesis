WEBVTT

1
00:00:00.620 --> 00:00:05.650 
hi, this is Isabell Sippli and
I would like to talk about

2
00:00:05.650 --> 00:00:07.690 
building modern
applications at scale.

3
00:00:08.360 --> 00:00:11.950 
before i do that a little disclaimer
this is my personal view

4
00:00:11.950 --> 00:00:16.720 
an opinion. It does not necessarily
represent IBM s position or strategy.

5
00:00:17.680 --> 00:00:22.940 
so who am I? I am a senior architect
of the IBM R&amp;D lab in Germany.

6
00:00:23.400 --> 00:00:26.460 
My team and I have been developing
cloud native applications

7
00:00:26.470 --> 00:00:28.170 
since 2015.

8
00:00:29.030 --> 00:00:32.380 
we also develop traditional
enterprise applications and that

9
00:00:32.380 --> 00:00:36.510 
are built-in like mostly
monolithic forms. so I get a

10
00:00:36.510 --> 00:00:39.050 
bit of both worlds and I
understand the differences and

11
00:00:39.050 --> 00:00:41.540 
it's something, I'm trying
to explain to you today.

12
00:00:42.300 --> 00:00:45.790 
also, I'm leading a team of
developers, so I look for

13
00:00:46.300 --> 00:00:49.050 
what we do from an architectural
perspective, how to a certain

14
00:00:49.050 --> 00:00:52.200 
technologies fit in and work
together with my team and bring

15
00:00:52.200 --> 00:00:55.540 
that into real-life applications.
so I also still love to code

16
00:00:55.540 --> 00:00:57.460 
and I do as much
as I can.

17
00:00:59.390 --> 00:01:03.190 
Today I'd like to give you a
basic understanding of how we

18
00:01:03.190 --> 00:01:06.840 
develop modern cognitive and
enterprise-scale applications.

19
00:01:07.290 --> 00:01:11.190 
and I'd like to do that by looking
at three different parts. First

20
00:01:11.520 --> 00:01:14.800 
I'd like to introduce some basic
technologies, what is docker,

21
00:01:14.800 --> 00:01:18.820 
what Kubernetes is and how it is been
designed private bringing it all together

22
00:01:19.410 --> 00:01:22.510 
what are process and paradigms,
why it is a great idea

23
00:01:22.510 --> 00:01:26.170 
to look at micro-surfaces and
DevOps and I'd also like to do

24
00:01:26.180 --> 00:01:30.130 
a little reality checks in talking about
what we actually do with my team.

25
00:01:30.600 --> 00:01:35.020 
So by no means, this is not a
complete list. But it should

26
00:01:35.020 --> 00:01:38.960 
get used to starting it and it should provide
pointers for further learning. There are

27
00:01:39.080 --> 00:01:41.570 
those great stuff out there in
the internet that i'll point to

28
00:01:41.750 --> 00:01:45.740 
that you couldn't take on and
start. I'm assuming you

29
00:01:45.740 --> 00:01:49.200 
are a developer somewhat seasoned in
at least one modern programming

30
00:01:49.200 --> 00:01:54.140 
language be it go javascript
using no js or java.

31
00:01:54.570 --> 00:01:57.770 
so you can take that
development knowledge

32
00:01:57.770 --> 00:02:01.840 
and then apply what i'm talking
to you today in order to look

33
00:02:01.840 --> 00:02:04.320 
at what it takes to develop
modern applications.

34
00:02:05.840 --> 00:02:08.930 
so starting with containers
what is the problem that is

35
00:02:08.930 --> 00:02:10.250 
actually solved
by containers.

36
00:02:11.120 --> 00:02:15.310 
First of all, they make your life as a
developer easier so so yeah to that.

37
00:02:15.690 --> 00:02:19.140 
Second, in the most simple case,
it allows you to package

38
00:02:19.140 --> 00:02:22.270 
your application once and then deployed
in very different environments.

39
00:02:22.430 --> 00:02:25.860 
so you can take your code and rap
all up and then run it on your

40
00:02:25.860 --> 00:02:28.300 
laptop or running in a
production environment in

41
00:02:28.700 --> 00:02:31.230 
almost identical men and
that's really helpful.

42
00:02:33.110 --> 00:02:37.280 
looking into more details what
containers actually bring us is that

43
00:02:38.420 --> 00:02:41.610 
they not only allow you to package
or application. but they

44
00:02:41.610 --> 00:02:46.020 
also allow you to do that together
with the dependencies and then

45
00:02:46.160 --> 00:02:47.690 
isolate the
whole runtime.

46
00:02:48.400 --> 00:02:51.690 
once they are ready, so when you
have a container image and

47
00:02:51.690 --> 00:02:55.660 
then you start running it, as
a running instance, and they

48
00:02:55.660 --> 00:02:59.320 
are easy to deploy. they are portable
across host operating systems

49
00:02:59.550 --> 00:03:03.100 
so you can build a linux container
with abandon for example

50
00:03:03.100 --> 00:03:05.330 
running on a record
system and vice versa.

51
00:03:06.130 --> 00:03:09.520 
they created from immutable layered
images. so you can really

52
00:03:09.520 --> 00:03:12.400 
build on top of each other and
can take what you have and then

53
00:03:12.400 --> 00:03:13.640 
just add your
stuff on top.

54
00:03:14.580 --> 00:03:17.850 
they are also isolated from the
host of reading systems. so

55
00:03:17.850 --> 00:03:21.180 
they allow you to isolate your
application and when it runs

56
00:03:21.180 --> 00:03:23.500 
together with other applications
or they own get like their

57
00:03:23.500 --> 00:03:27.710 
own little home in space, and
allow you to be independent of

58
00:03:28.150 --> 00:03:32.430 
what what other things are
running on your computer.

59
00:03:34.020 --> 00:03:36.480 
so looking up the difference
between a virtual machine and

60
00:03:36.480 --> 00:03:38.320 
a container. you might
think you're well back

61
00:03:39.060 --> 00:03:42.660 
we've always had virtual machines,
what's the point. the key difference

62
00:03:42.660 --> 00:03:45.860 
from my perspective is the virtual
machine virtualizes the hardware,

63
00:03:46.130 --> 00:03:50.440 
where is the containers
actually isolated process. so

64
00:03:51.410 --> 00:03:54.800 
even though they are very
similar the container entities

65
00:03:54.800 --> 00:03:58.900 
are much smaller than an actual
virtual machine. they are

66
00:03:59.160 --> 00:04:02.790 
like faster and easier to build
and to start and to deploy.

67
00:04:02.990 --> 00:04:07.110 
so you get on a lot of benefits from
a handling perspective. obviously

68
00:04:07.270 --> 00:04:09.400 
virtual machines are still necessary
because somewhere you need

69
00:04:09.400 --> 00:04:11.200 
to run your
container house.

70
00:04:12.030 --> 00:04:16.200 
but as a developer, I would absolutely
favor stop working with containers.

71
00:04:17.970 --> 00:04:21.680 
some advantages and i've kind of
already mentioned them. containers

72
00:04:21.680 --> 00:04:24.430 
a totally programming language
independent. so you can put

73
00:04:25.390 --> 00:04:28.860 
into a container or whatever
you can basically install

74
00:04:29.000 --> 00:04:31.340 
on top of a base of
rating systems.

75
00:04:32.010 --> 00:04:36.850 
it makes your applications portable and it
allows you for example to automatically load

76
00:04:37.030 --> 00:04:40.790 
dependencies. so you when
you build a container,

77
00:04:40.790 --> 00:04:45.750 
you usually do that from an
existing image, for example from

78
00:04:45.990 --> 00:04:49.620 
a basic rating system image and
then you can actually define

79
00:04:49.620 --> 00:04:52.090 
which dependencies you want and
then they're automatically

80
00:04:52.090 --> 00:04:57.610 
loaded at startup. it allows you
to also share apps more easily

81
00:04:57.780 --> 00:04:59.840 
and to actually speed up
your development cycle.

82
00:05:01.410 --> 00:05:04.960 
from an admin operations perspective
which is equally as important

83
00:05:04.960 --> 00:05:07.360 
as your deaf perspectives because
at some point someone needs

84
00:05:07.360 --> 00:05:10.460 
to run your applications to provide
service to and customers.

85
00:05:11.370 --> 00:05:15.290 
they allow for standardized
environments and the administration

86
00:05:15.420 --> 00:05:20.560 
is really simple, because it actually abstracts
away from a specific operating system.

87
00:05:20.980 --> 00:05:26.130 
it allows for very sweet
scaling through the docker or

88
00:05:26.400 --> 00:05:27.610 
related container
engines.

89
00:05:28.810 --> 00:05:32.120 
and it allows you basically to deploy
build and run your application

90
00:05:32.120 --> 00:05:36.850 
with almost every infrastructure.
if you want to try it yourself,

91
00:05:37.170 --> 00:05:39.950 
I've put in a little link at
the bottom of the discharge

92
00:05:40.390 --> 00:05:44.890 
training.play with docker. com/
ops- s1-hello is a super

93
00:05:44.890 --> 00:05:47.810 
nice introduction that gets you started
really quickly. you need nothing

94
00:05:48.040 --> 00:05:50.510 
just get this started. so I would
absolutely recommend that

95
00:05:52.120 --> 00:05:57.590 
moving over to Kubernetes, so now you have
your continuous application, great, but

96
00:05:57.830 --> 00:06:00.900 
how do you actually deployed to
production and how do you scale

97
00:06:00.900 --> 00:06:05.070 
it and how do you manage. it especially if
it's not just your tiny application, but

98
00:06:05.180 --> 00:06:07.920 
it might need another service
or work together with

99
00:06:08.330 --> 00:06:11.310 
another application. that's a problem
that you kind of have to address.

100
00:06:11.710 --> 00:06:15.790 
and that's what contain
orchestration tools like

101
00:06:15.800 --> 00:06:19.380 
Kubernetes do. There are other out
in the industry, but Kubernetes

102
00:06:19.380 --> 00:06:22.720 
is at the moment is probably
the most dominant one.

103
00:06:22.750 --> 00:06:24.720 
so if you look at that little
picture on the right hand

104
00:06:25.250 --> 00:06:28.880 
side, we have little containers and
they all managed by coordinators.

105
00:06:29.940 --> 00:06:33.530 
so this picture really shows a
super simple analogy for what

106
00:06:33.670 --> 00:06:36.740 
Kubernetes actually does. so at
the bottom of your container

107
00:06:36.740 --> 00:06:40.670 
the ship, you have your infrastructure.
that's all the machines in the ship and

108
00:06:41.020 --> 00:06:45.490 
I'm coming back to IT that's all
you're physical and virtual

109
00:06:45.800 --> 00:06:50.720 
an infrastructure that provides all the
basic in order to run your services.

110
00:06:50.970 --> 00:06:53.620 
and those services are your
little containers, and they sit

111
00:06:53.620 --> 00:06:56.590 
on the ship. they are
distributed across the ship.

112
00:06:56.950 --> 00:07:01.160 
they might be loaded and
offloaded. and the instance that

113
00:07:01.160 --> 00:07:03.850 
actually controls sat on a
container ship is the bridge as

114
00:07:03.850 --> 00:07:06.570 
a white thing. there in the middle
where you have companies on top.

115
00:07:06.820 --> 00:07:09.730 
and that's very similar to what
companies do. it really helps you

116
00:07:10.100 --> 00:07:12.200 
orchestrating all
your containers

117
00:07:12.890 --> 00:07:16.190 
understanding where they should
run and when they should run, in

118
00:07:16.190 --> 00:07:18.580 
which context they should run, how
they should be isolated, who

119
00:07:18.580 --> 00:07:21.890 
has access to them. so that's
a really good analogy.

120
00:07:23.500 --> 00:07:27.020 
if you go to K8s. it's actually
an open-source project

121
00:07:27.030 --> 00:07:30.780 
and that's the core definition if you
go to that. also to the GitHub.

122
00:07:31.170 --> 00:07:34.230 
and it says it's a system for
automated deployment scaling

123
00:07:34.230 --> 00:07:36.980 
and management of containerized
application. and that's really

124
00:07:36.980 --> 00:07:37.740 
the just of it.

125
00:07:39.110 --> 00:07:42.180 
if you want to learn more, there
is an awesome video that i

126
00:07:42.180 --> 00:07:45.990 
have linked here. and it explains
Kubernetes like kind of

127
00:07:45.990 --> 00:07:50.540 
children analogy
with a little

128
00:07:51.040 --> 00:07:57.000 
animated like animals, I think
it's called phoebe. and

129
00:07:57.230 --> 00:07:59.130 
it's the first thing that I ever
looked at when I started to

130
00:07:59.130 --> 00:08:01.560 
look at containers and I really enjoyed
it, so I would recommend that.

131
00:08:01.880 --> 00:08:04.390 
if you're ready for hands-on I
would recommend the tutorial

132
00:08:04.390 --> 00:08:09.310 
at the bottom. it's similar to the docker
tutorial. it takes you basically through

133
00:08:09.760 --> 00:08:14.890 
simple steps to get into the
whole Kubernetes ecosystem.

134
00:08:14.890 --> 00:08:18.060 
so go there and tried it
if you have some time.

135
00:08:19.410 --> 00:08:24.050 
right so remember we had docker cooperating.
now we are moving over to cloud private.

136
00:08:24.430 --> 00:08:28.160 
so you have your containers,
you have Kubernetes, then you

137
00:08:28.200 --> 00:08:30.970 
you need to manage Kubernetes. I
mean you to operate that scale

138
00:08:30.970 --> 00:08:34.040 
because it's not going to be like
a single small system. It is

139
00:08:34.040 --> 00:08:36.600 
probably going to grow over time
as they get more successful

140
00:08:36.890 --> 00:08:40.230 
an IBM Cloud private helps
you with that. it does many

141
00:08:40.230 --> 00:08:42.850 
other great things, but that's
what it is at the cord.

142
00:08:44.050 --> 00:08:48.290 
it also basically brings a cloud
native to the enterprise. so

143
00:08:48.290 --> 00:08:49.680 
it helps you as a

144
00:08:50.890 --> 00:08:54.840 
an enterprise when later
you work for the prices

145
00:08:55.240 --> 00:08:59.610 
around innovation because
it's based on an open

146
00:08:59.610 --> 00:09:03.050 
community space container platform.
it also uses to allow you to

147
00:09:03.050 --> 00:09:06.350 
do a platform as a service with
cloud foundry and it is a very

148
00:09:06.350 --> 00:09:11.130 
sweet DevOps toolchain integration. also
its really big and hybrid integration.

149
00:09:11.900 --> 00:09:15.630 
so it allows you to integrate
what do you have today with all

150
00:09:15.630 --> 00:09:20.040 
the new stuff that you're building
and secured access and basically

151
00:09:20.250 --> 00:09:24.090 
give you a very consistent experience
across private and public environments.

152
00:09:25.430 --> 00:09:29.410 
it helps you protecting your
investment in leveraging that

153
00:09:29.750 --> 00:09:33.860 
because it gives you like a continuous
version of most of obvious middleware,

154
00:09:34.180 --> 00:09:37.670 
and very prescriptive guidance to
optimize existing workloads.

155
00:09:37.670 --> 00:09:40.630 
and it works with existing apps stated
skills and infrastructure too.

156
00:09:41.200 --> 00:09:45.010 
besides that, it is really strong
in management and compliance.

157
00:09:45.010 --> 00:09:48.020 
so it comes with like predefined
operational services that

158
00:09:48.020 --> 00:09:51.110 
include logging monitoring security
and gives you the flexibility

159
00:09:51.110 --> 00:09:53.480 
to integrate with your existing
tools and processes.

160
00:09:55.050 --> 00:09:59.940 
a quick overview on the solution
at the bottom you have the

161
00:10:00.170 --> 00:10:02.890 
container registration platform
that scrutinises and darker

162
00:10:02.980 --> 00:10:06.050 
which is a very popular
container runtime.

163
00:10:07.040 --> 00:10:09.990 
and build system you have your
core operational services in

164
00:10:09.990 --> 00:10:12.820 
the middle that allow you for
centralized logging monitoring,

165
00:10:13.240 --> 00:10:17.390 
metering security and a learning.
and at the top we have

166
00:10:17.400 --> 00:10:20.090 
a content catalogue were basically
obvious brings a lot of

167
00:10:20.090 --> 00:10:24.410 
free package stuff that you can just take
and use to develop your applications.

168
00:10:26.240 --> 00:10:28.680 
again if you want to learn more
you see the pattern by now.

169
00:10:29.040 --> 00:10:32.070 
there's a really nice guided
demo on the first link and you

170
00:10:32.070 --> 00:10:35.030 
can actually try it yourself.
we have a public hungry poll

171
00:10:35.030 --> 00:10:38.440 
that shows you how you can
actually install IBM private

172
00:10:38.440 --> 00:10:39.220 
on your laptop

173
00:10:41.250 --> 00:10:44.790 
ok coming back to my
agenda and looking at

174
00:10:45.320 --> 00:10:48.430 
what we're going to do next. The
next thing is micro-surfaces.

175
00:10:49.210 --> 00:10:53.100 
so micro services really
helps you to develop

176
00:10:53.510 --> 00:10:57.130 
applications that are optimized
for cloud native environments.

177
00:10:57.400 --> 00:11:01.460 
it allows you to develop a single
application as a sweet of small services

178
00:11:01.590 --> 00:11:05.110 
where each one is running its
own process. remember very

179
00:11:05.110 --> 00:11:08.820 
likely to what we very similar to what
we do with containers and those

180
00:11:08.960 --> 00:11:11.740 
small services they communicate
with lightweight mechanisms.

181
00:11:12.250 --> 00:11:15.920 
usually they are built around
business capabilities and

182
00:11:15.920 --> 00:11:19.910 
they are hopefully independently
deployable by a fully automated

183
00:11:19.910 --> 00:11:22.810 
deployment machinery.
that basically means,

184
00:11:23.890 --> 00:11:27.960 
you have a little unit, you can throw
it out and then your machinery starts

185
00:11:28.210 --> 00:11:31.960 
and deploys it and tests it until
it's actually in production.

186
00:11:33.600 --> 00:11:35.020 
so this is

187
00:11:36.900 --> 00:11:40.900 
sample application spread out
in different microservices

188
00:11:40.900 --> 00:11:44.370 
basically where you have a couple
of fewer services a couple of

189
00:11:44.720 --> 00:11:50.490 
processing control services
and the database services

190
00:11:50.780 --> 00:11:53.070 
as well. and

191
00:11:54.920 --> 00:11:57.840 
when you look at communication
like let's say this is a weber

192
00:11:57.840 --> 00:12:01.890 
which is like the majority of all
applications. if it's not a native

193
00:12:02.680 --> 00:12:06.520 
mobile app. you have
your web app and then

194
00:12:06.530 --> 00:12:09.750 
at likely go through load
balancer relented it accesses

195
00:12:09.760 --> 00:12:13.330 
a UI micro server or parts of
that that will then potentially

196
00:12:13.330 --> 00:12:17.690 
federate out to back on services and
access to databases. and each of them,

197
00:12:19.250 --> 00:12:22.820 
they have a single
purpose and the best

198
00:12:22.820 --> 00:12:26.920 
analogy that I found from my perspective
is they're very like UNIX tools.

199
00:12:27.240 --> 00:12:30.450 
they do one thing and they do that
one right, and they don't look at

200
00:12:31.170 --> 00:12:33.230 
all the other
capabilities

201
00:12:33.710 --> 00:12:38.610 
of your total application.
but they really focus

202
00:12:38.610 --> 00:12:39.800 
on one particular
thing.

203
00:12:40.460 --> 00:12:44.930 
if we go back to that picture,
we have for example a shopping

204
00:12:44.930 --> 00:12:49.740 
card and a service that does all
the orders of service that

205
00:12:49.740 --> 00:12:52.460 
takes care of all the customers.
indeed the organi servers don't

206
00:12:52.460 --> 00:12:55.800 
really have to know all the
details of the customer service.

207
00:12:55.800 --> 00:12:59.000 
but if it needs to know something, it
can call that and that's one of those

208
00:12:59.280 --> 00:13:00.760 
paradigms that are
really important.

209
00:13:03.690 --> 00:13:07.120 
remember when I gave the
definition, I talked about like

210
00:13:07.120 --> 00:13:10.250 
a fully automated deployment
machinery and what we really need

211
00:13:10.250 --> 00:13:13.900 
here is infrastructure automation
and continuous delivery. so

212
00:13:13.900 --> 00:13:17.260 
you have to have automated tasks
that give you a lot of confidence

213
00:13:17.260 --> 00:13:21.140 
that your code actually runs and if
you haven't looked at automated

214
00:13:21.140 --> 00:13:24.350 
test cases when developing. I would
recommend you actually do that right now.

215
00:13:25.460 --> 00:13:28.740 
and then similar to that, you have
to automate your deployment.

216
00:13:29.050 --> 00:13:31.570 
if you're currently developing
an application and every time

217
00:13:31.570 --> 00:13:35.060 
you want to test it, like you have
to copy some files somewhere

218
00:13:35.070 --> 00:13:37.970 
manually and then run a script
to sort it all up. that's not

219
00:13:37.970 --> 00:13:42.280 
a great idea in an enterprise
environment. you have to be able to

220
00:13:42.540 --> 00:13:45.950 
write a line, a changeset of
a couple of lines of code

221
00:13:46.170 --> 00:13:49.680 
commit that to a version control
repository and then machinery has to

222
00:13:49.980 --> 00:13:53.870 
basically take that change,
deployed to an environment run a

223
00:13:53.870 --> 00:13:56.950 
sweet of tests. if they are good
promoted to the next environment

224
00:13:57.010 --> 00:14:00.190 
and i'll talk about that
in a bit more detail.

225
00:14:03.230 --> 00:14:07.800 
moving over to DevOps. because
that's very similar to

226
00:14:08.230 --> 00:14:12.050 
automated deployment of machinery, at least
that's one of the cornerstones of it.

227
00:14:12.550 --> 00:14:15.820 
what does DevOps actually
mean? so that's it the first

228
00:14:15.820 --> 00:14:19.560 
stuff that i talked about is more
like what you do as a developer

229
00:14:19.560 --> 00:14:22.560 
and now looking at their
phones actually means how do

230
00:14:22.560 --> 00:14:26.440 
you collaborate with people that put
your application in production.

231
00:14:26.630 --> 00:14:31.170 
and you could do that yourself, if you
follow the utility running paradigm.

232
00:14:31.660 --> 00:14:34.850 
but sometimes you might have
very close and adjacent teams.

233
00:14:35.750 --> 00:14:39.540 
that's basically where the devil
movement came up. so mostly

234
00:14:39.540 --> 00:14:42.930 
this is a culture and or an
organizational philosophy

235
00:14:43.240 --> 00:14:46.540 
of how you actually collaborate
between people that mostly

236
00:14:46.540 --> 00:14:50.400 
develop code and some that
mostly operating applications.

237
00:14:50.650 --> 00:14:53.030 
and that's like the way of
working, and it also there are a

238
00:14:53.030 --> 00:14:57.480 
couple of models that help you
work on looking at that. so

239
00:14:59.030 --> 00:15:01.510 
there is no single right way to
do that, but there are wrong

240
00:15:01.510 --> 00:15:03.900 
ways and i'm going to show you
some of those wrong ways. so

241
00:15:03.900 --> 00:15:06.990 
this is really bad having two
liked totally separate teams

242
00:15:06.990 --> 00:15:10.750 
that don't interact and talk to
each other. that's what we used

243
00:15:10.750 --> 00:15:13.700 
to do until like a couple of
years ago, where the daft team

244
00:15:13.700 --> 00:15:16.550 
would always say, well but the
upside is that they always ruin

245
00:15:16.550 --> 00:15:19.930 
our application and they are super
strict and no one applies our changes

246
00:15:20.180 --> 00:15:23.840 
already obscene would say, hey
but the developers have no clue

247
00:15:23.930 --> 00:15:28.060 
what's going on in production and
they always try to ruin productions

248
00:15:28.060 --> 00:15:30.750 
and there was a lot of like
banging going on. so this

249
00:15:30.750 --> 00:15:34.540 
is bad, don't do that. this is
also bad if you want to start

250
00:15:34.750 --> 00:15:37.730 
establishing DevOps and then you build
like a completely separate team

251
00:15:37.900 --> 00:15:41.740 
that do not talk that much to the
DevOps team is not going to work.

252
00:15:42.090 --> 00:15:45.290 
obviously there are many
flavors of bad, so

253
00:15:46.080 --> 00:15:50.630 
don't do that the two circles
that are not like interfering

254
00:15:50.630 --> 00:15:52.200 
with each other what
you want this.

255
00:15:52.720 --> 00:15:55.030 
you want true collaboration
between the teams and you could

256
00:15:55.030 --> 00:15:58.640 
do that either by having like
dedicated people in each team

257
00:15:58.640 --> 00:16:02.460 
that work closely together and to
have shared responsibilities.

258
00:16:02.690 --> 00:16:05.700 
you could actually also merge
those two bubbles, so you have

259
00:16:05.980 --> 00:16:10.010 
one close team, I said it already
to do your ability to run it.

260
00:16:10.160 --> 00:16:15.130 
but keep in mind when you look at teams
look at the collaboration between

261
00:16:15.640 --> 00:16:18.990 
the people that write the code and the
people that put it in production.

262
00:16:20.760 --> 00:16:25.410 
so talking about continued
integration delivery and deployment

263
00:16:25.510 --> 00:16:28.290 
you might have heard that before,
I don't want to dive in like

264
00:16:28.290 --> 00:16:31.700 
too much detail, but just give you
a quick overview. I'm coming

265
00:16:31.710 --> 00:16:34.900 
again coming back to like the
fully automated deployment

266
00:16:34.900 --> 00:16:36.850 
machinery that i that
i mentioned earlier.

267
00:16:37.310 --> 00:16:39.710 
those are the stages that
will help you to do that.

268
00:16:40.130 --> 00:16:43.700 
and they build on top
of each other. so

269
00:16:43.810 --> 00:16:47.250 
starting with continuous integration
that really does is that

270
00:16:47.260 --> 00:16:50.890 
it allows you to integrate your
code into a shared repository

271
00:16:50.890 --> 00:16:54.920 
at least daily and I would say
dailies even not enough in some

272
00:16:54.920 --> 00:17:00.490 
cases and I said that already you develop
your code like on your laughter locally.

273
00:17:00.800 --> 00:17:03.680 
and then you obviously write
tests that make sure that the

274
00:17:03.680 --> 00:17:06.340 
code actually does what you think
it should do. then you commit

275
00:17:06.340 --> 00:17:09.770 
that code to a sense of repose,
and then the machinery starts.

276
00:17:09.780 --> 00:17:13.870 
so he takes that code test runs the
first these sweet of unit tests,

277
00:17:14.180 --> 00:17:17.530 
then the deploy said, for example,
to first tests were staging

278
00:17:17.530 --> 00:17:21.100 
environment runs to test, there are
and then subsequently promotes that.

279
00:17:21.490 --> 00:17:22.820 
why would you
want to do that

280
00:17:23.560 --> 00:17:26.950 
because you should have smaller
sizes of changeset that then

281
00:17:26.950 --> 00:17:30.170 
lead to easier integration.
the smaller the changed

282
00:17:30.510 --> 00:17:33.200 
the more control you have and the
more you see what the impact is.

283
00:17:33.390 --> 00:17:37.410 
it also allows you to catch
issues fast, and then hopefully

284
00:17:37.410 --> 00:17:39.790 
deliver software more rapidly
because that's what this is all

285
00:17:39.790 --> 00:17:42.770 
about. you wanted to live of value to
your customers as fast as you can.

286
00:17:43.610 --> 00:17:47.480 
moving to continuous delivery is a bit
further than that one because it

287
00:17:48.260 --> 00:17:53.350 
in theory it basically says that you
should have every change to the system

288
00:17:53.620 --> 00:17:58.180 
in a reasonable state. so every
change that you make every commit

289
00:17:58.370 --> 00:18:04.350 
that makes it, for example, to your
central mass branch in your repository

290
00:18:04.700 --> 00:18:07.060 
should be deployable
to production.

291
00:18:07.970 --> 00:18:11.950 
that means what it adds to
continues on an integration

292
00:18:11.950 --> 00:18:14.610 
is basically all of these
completely automated deployments

293
00:18:14.610 --> 00:18:20.330 
in between the different stages.
and last continuous deployment

294
00:18:20.700 --> 00:18:24.400 
basically says, ok the second
you can get a line of code

295
00:18:24.410 --> 00:18:27.510 
the whole system will make sure that
it actually ends up in production.

296
00:18:27.910 --> 00:18:32.020 
so if you look at the
little graphic that you

297
00:18:32.020 --> 00:18:34.680 
see in the references someone else
drew out. and it's really good.

298
00:18:34.930 --> 00:18:36.380 
it basically shows

299
00:18:37.180 --> 00:18:40.280 
that the last stage to production
for continuous delivery, it's

300
00:18:40.280 --> 00:18:43.500 
a manual for continuous deployment
it goes automated and not

301
00:18:43.500 --> 00:18:45.900 
every time wants that. my team,
for example, we don't do that.

302
00:18:46.140 --> 00:18:48.490 
we do continuous
delivery but then we

303
00:18:49.000 --> 00:18:52.470 
we have like a manual quality
gates before we actually

304
00:18:52.470 --> 00:18:55.910 
release into production. and
that's fine, other companies

305
00:18:55.910 --> 00:18:59.440 
don't do that, it depends
sometimes also on regulatory

306
00:18:59.440 --> 00:19:01.770 
controls where you can do it or
not, in our case we can't.

307
00:19:03.500 --> 00:19:08.210 
ok. last but at least, I'm
a little reality check

308
00:19:08.210 --> 00:19:09.810 
what does my team do?

309
00:19:11.100 --> 00:19:13.880 
so i'd like to talk a little
bit about the applications we

310
00:19:13.880 --> 00:19:17.290 
develop. How our team structures?
how we use open source technology?

311
00:19:17.690 --> 00:19:21.210 
how we IBM cloud private
and what we could

312
00:19:21.210 --> 00:19:23.760 
do for example to run this also
in persistence using docker.

313
00:19:24.340 --> 00:19:27.070 
first of all,

314
00:19:28.360 --> 00:19:34.410 
my team is responsible for any
wrong automation, that's a

315
00:19:35.330 --> 00:19:39.670 
suffer is a service solution. it's also
locally available that allows you basically

316
00:19:39.960 --> 00:19:44.120 
to automate operational instructions
for your an operations

317
00:19:44.120 --> 00:19:47.520 
team starting from manual moving
over to somewhat semi automated

318
00:19:47.520 --> 00:19:50.610 
instructions too, like a fully
automated reaction to an incident.

319
00:19:51.330 --> 00:19:54.220 
I've been running automation
place probably like

320
00:19:54.220 --> 00:19:56.620 
in a bigger game.
there are adjacent

321
00:19:57.450 --> 00:20:02.010 
technologies or solutions like i'm alert
notification or cloud event management and

322
00:20:02.200 --> 00:20:05.600 
i'm partially responsible for
some areas. they're so we

323
00:20:05.610 --> 00:20:10.330 
work in a bigger team. but my core
team we have three microservices.

324
00:20:10.730 --> 00:20:14.250 
they have built Node.js
or using a CouchDB and

325
00:20:14.250 --> 00:20:16.000 
the Angular.js.

326
00:20:17.260 --> 00:20:23.090 
we're using Jenkins&amp; Artifactory
as our basically automated

327
00:20:23.260 --> 00:20:27.790 
deployment machinery. we deploy
into two environments. one is

328
00:20:27.790 --> 00:20:30.810 
IBM Cloud Foundry Services
and cloudant. so when we

329
00:20:30.810 --> 00:20:33.580 
deploy to cloud, when it's a software
service application, we're

330
00:20:33.580 --> 00:20:37.030 
using cloud and on which is cached beyond
recovers plus a little bit more.

331
00:20:37.270 --> 00:20:40.570 
and then we're on developing on a
platform as a service offering

332
00:20:40.570 --> 00:20:42.270 
from IBM that space
will cloud foundry.

333
00:20:43.270 --> 00:20:46.980 
when we do this locally,
we basically take our

334
00:20:46.980 --> 00:20:49.590 
code, the one exactly the
same code that we put with

335
00:20:49.590 --> 00:20:52.940 
the apply to cloud we wrap it up
in a container and and then

336
00:20:52.940 --> 00:20:54.300 
run it on IBM
Cloud private.

337
00:20:55.320 --> 00:20:58.480 
we have developers on two sites
and we have i said that

338
00:20:58.480 --> 00:21:01.160 
already separate responsibilities
for production environments

339
00:21:01.460 --> 00:21:04.560 
for regulatory controls. and
also because we have to

340
00:21:04.560 --> 00:21:07.320 
do twenty-four seven support
and you don't want like

341
00:21:07.320 --> 00:21:10.830 
a local team to like us or shifts
as we're like a big company,

342
00:21:10.830 --> 00:21:12.770 
you can actually afford to
have teams in different

343
00:21:13.190 --> 00:21:14.190 
spaces.

344
00:21:15.960 --> 00:21:19.080 
i brought some screenshots of
some of the tools that we have.

345
00:21:19.390 --> 00:21:22.280 
so this is our opponent is like
a super small home-grown

346
00:21:22.280 --> 00:21:25.920 
tool that we built in order to keep
control for all deployments.

347
00:21:26.130 --> 00:21:29.440 
and you see like we have several
stages as we move forward

348
00:21:29.440 --> 00:21:33.390 
to production. production is not a
nice picture. but just basically

349
00:21:33.770 --> 00:21:36.750 
when my developers
decided that

350
00:21:37.480 --> 00:21:40.710 
they have a local feature ready,
they can integrate that nto

351
00:21:40.710 --> 00:21:43.200 
a branch and then it's automatically
deployed to the edge.

352
00:21:44.170 --> 00:21:47.510 
and on edge the test cases
that run and you see they

353
00:21:47.510 --> 00:21:48.740 
are like different
services.

354
00:21:49.790 --> 00:21:52.040 
remember the three services
that I talked about earlier.

355
00:21:52.470 --> 00:21:54.020 
then moves over
to stating,

356
00:21:54.650 --> 00:21:57.910 
if all the test goes green and
then at some point it moves over

357
00:21:57.910 --> 00:22:00.320 
to immigration. and that's the
last thing to report before we

358
00:22:00.320 --> 00:22:01.760 
actually move over
to production.

359
00:22:03.560 --> 00:22:08.060 
this is a screenshot
of our live

360
00:22:08.560 --> 00:22:09.730 
Jenkins

361
00:22:11.130 --> 00:22:14.620 
instance. so you see not all the
time everything goes well. we

362
00:22:14.620 --> 00:22:17.780 
have areas where some of her
tests actually fail. and that's

363
00:22:17.780 --> 00:22:21.780 
ok. but it stops at a certain
gate. so we know ok alright.

364
00:22:21.940 --> 00:22:25.160 
we have to improve upon here and
yeah we probably shouldn't

365
00:22:25.160 --> 00:22:28.720 
have for failing builds
right after each other.

366
00:22:28.720 --> 00:22:31.340 
but that sometimes happens.
and we're transferring about

367
00:22:31.340 --> 00:22:34.960 
that, because we know we're going to catch that
before it actually moves into production.

368
00:22:36.310 --> 00:22:40.000 
that's like a
sample picture

369
00:22:41.090 --> 00:22:45.630 
of how some of our deployments
move. so that's basically

370
00:22:45.630 --> 00:22:50.520 
moving from the very first
committe of a cold over to like

371
00:22:50.750 --> 00:22:54.660 
several test ages into our search
environment, and then to

372
00:22:54.660 --> 00:22:57.840 
the end, and from there, another
automated pipeline picks up. so we

373
00:22:57.840 --> 00:23:00.680 
have basically split up our
pipelines into smaller chunks.

374
00:23:02.630 --> 00:23:07.070 
this is a little view on what we
actually do from Github perspective.

375
00:23:07.300 --> 00:23:11.240 
so when you can see here, we
do cut reviews. so before

376
00:23:11.240 --> 00:23:15.420 
actually a change is
merged into our master.

377
00:23:15.870 --> 00:23:18.490 
another person should have a
look. so we have like the four

378
00:23:18.490 --> 00:23:21.040 
i principle and to
actually ensure quality.

379
00:23:21.460 --> 00:23:24.200 
and then we also have automated
checks before it can actually

380
00:23:24.200 --> 00:23:27.180 
be promoted. and those automated
checks are actually all the

381
00:23:27.180 --> 00:23:30.420 
test cases that are run. so it
will not be possible that a code

382
00:23:30.420 --> 00:23:33.240 
makes it into production that is not
properly and thoroughly tested.

383
00:23:36.100 --> 00:23:39.700 
some last words on open source. so
we're IBM, in general, is really

384
00:23:39.700 --> 00:23:43.080 
begun open source. that's not
always known in the public, but

385
00:23:43.220 --> 00:23:46.600 
if you want to have a look at
some of the great things

386
00:23:46.600 --> 00:23:49.780 
that we do, go to the
developer.ibm.com /open. i

387
00:23:49.780 --> 00:23:52.260 
mean you'll find that we're
actually really involved in very

388
00:23:52.260 --> 00:23:55.560 
many various and diverse
open source project.

389
00:23:56.040 --> 00:23:58.980 
for our project alone, we use
a lot of open sources we

390
00:23:58.980 --> 00:24:01.830 
have more than nineteen pm modules
as we're developing a node.

391
00:24:01.880 --> 00:24:04.430 
and we are actually responsible
for what we deliver, so we could

392
00:24:04.440 --> 00:24:07.410 
just can't grab a module from
the internet and then send it

393
00:24:07.410 --> 00:24:09.780 
to our customers. and go yeah,
it is ganna to be fine.

394
00:24:10.550 --> 00:24:12.250 
we have to scan that
for security.

395
00:24:13.150 --> 00:24:17.570 
we have to maintain that open source
libraries life-cycle, because sometimes

396
00:24:17.810 --> 00:24:20.750 
those modules tend not to be
continued anymore. and we have

397
00:24:20.750 --> 00:24:23.450 
to make a decision on what we do
that and what we do with that.

398
00:24:23.450 --> 00:24:25.070 
because either we just

399
00:24:26.220 --> 00:24:28.660 
try to maintain yourself which
we do not really very do what

400
00:24:28.660 --> 00:24:32.200 
we have to do or we have to move to
actually another open-source module.

401
00:24:32.950 --> 00:24:37.230 
we also have to ensure vitality
before we actually grab

402
00:24:37.230 --> 00:24:39.740 
a module, so we can't just take
like any random module out there.

403
00:24:39.980 --> 00:24:42.490 
and we'll have a look at how many
times it's been downloaded,

404
00:24:42.490 --> 00:24:45.390 
how many major releases that we
have, when was the last release,

405
00:24:45.630 --> 00:24:49.250 
and how many contributors and maintainers
are there, and how many bullet requests,

406
00:24:49.530 --> 00:24:52.470 
to make sure this is really a
vivid thing. because if it's

407
00:24:52.480 --> 00:24:55.080 
a super small thing we might
actually build it ourselves.

408
00:24:55.090 --> 00:24:56.270 
so we have better
control over it.

409
00:24:58.400 --> 00:25:02.590 
all right before I close, obviously
this technology also allows us

410
00:25:02.890 --> 00:25:06.010 
to deploy to like different
environments. so if we wanted

411
00:25:06.010 --> 00:25:08.970 
to, for example, deploy to a
power environment we would

412
00:25:08.970 --> 00:25:12.240 
have to build docker containers that
support the power infrastructure.

413
00:25:12.240 --> 00:25:15.880 
but everything else would
actually stay the same because

414
00:25:16.040 --> 00:25:19.630 
we have all of this automated
machinery in place and that allows

415
00:25:19.630 --> 00:25:23.670 
us to be very flexible in what
we do. yes, it always works.

416
00:25:23.680 --> 00:25:27.440 
but it's under control and it
feels very safe. and last but

417
00:25:27.440 --> 00:25:30.000 
not least, I'd like to thank
colleagues Ralf and Simon. and

418
00:25:30.000 --> 00:25:32.130 
for their contributions and
feedback. I haven't done all of

419
00:25:32.130 --> 00:25:34.600 
this alone would. they really help
me with preparing this talk.

420
00:25:35.140 --> 00:25:38.300 
and yeah I hope I gave
you a good overview on

421
00:25:39.050 --> 00:25:41.770 
how to develop applications. I
wanted to give you some pointers

422
00:25:42.500 --> 00:25:46.800 
across like different areas that
help you prepare yourself for,

423
00:25:47.150 --> 00:25:51.610 
when leaving university and
then actually moving over

424
00:25:51.940 --> 00:25:54.500 
to professional software
development, which I really

425
00:25:54.500 --> 00:25:58.230 
hope you do because it's
great fun. and I hope this

426
00:25:58.230 --> 00:26:01.400 
helped and i'd like to
thank you for your

427
00:26:02.170 --> 00:26:04.170 
attention and wish
you a great time.
