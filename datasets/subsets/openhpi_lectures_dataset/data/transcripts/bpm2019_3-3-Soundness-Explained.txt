WEBVTT

1
00:00:01.210 --> 00:00:05.680 
Welcome to video clip 3.3 in
which we explain soundness.

2
00:00:07.590 --> 00:00:11.540 
So the idea of soundness we
discussed in the previous

3
00:00:12.030 --> 00:00:16.570 
video clip already. Now we
make it a bit more concrete

4
00:00:16.570 --> 00:00:19.290 
and we identify three
properties that

5
00:00:20.090 --> 00:00:23.650 
are important that need to
be fulfilled for a process

6
00:00:23.650 --> 00:00:28.100 
model to be sound. We assume process
models to be structurally sound.

7
00:00:28.850 --> 00:00:31.970 
So soundness has these
three properties- one,

8
00:00:32.530 --> 00:00:36.470 
once a process has started,
regardless of which decisions are

9
00:00:36.470 --> 00:00:40.220 
taken by the process, at some
point, the process will reach the

10
00:00:40.220 --> 00:00:41.280 
end event o.

11
00:00:43.370 --> 00:00:47.370 
Property two, if and when it reaches
the end event o, the process has

12
00:00:47.740 --> 00:00:52.950 
completely terminated which means no
further activities can be executed

13
00:00:53.410 --> 00:00:54.710 
by the process anymore.

14
00:00:56.150 --> 00:00:59.520 
And the third property is each
process activity participates

15
00:00:59.520 --> 00:01:04.410 
in at least one execution, so is
present in at least one trace.

16
00:01:07.090 --> 00:01:11.550 
We will apply soundness in the
next slides and before that

17
00:01:11.550 --> 00:01:15.220 
I like to notice like to make
this remark that soundness is

18
00:01:15.220 --> 00:01:19.090 
a generic correctness criterion
which is quite similar to normal

19
00:01:19.090 --> 00:01:24.080 
forms in databases. Some of you might
know normal forms in databases

20
00:01:24.300 --> 00:01:29.060 
that are properties of database
schemas that avoids a

21
00:01:29.060 --> 00:01:35.470 
certain behavior or certain data
content in the database that is not

22
00:01:35.780 --> 00:01:41.300 
not useful. So it's quite similar
to that in the sense that

23
00:01:41.660 --> 00:01:45.780 
we can show a property of the model
level and then on the instance

24
00:01:45.780 --> 00:01:50.350 
level for each process instance
we can be sure that that

25
00:01:50.350 --> 00:01:53.570 
the property holds for all of
these instances. So I only need

26
00:01:53.570 --> 00:01:57.460 
to show the property once for
the process model and then I

27
00:01:57.460 --> 00:02:01.350 
don't need to check each process
instance if it complies or

28
00:02:01.350 --> 00:02:07.300 
if it is sound we can
deduce that it is an

29
00:02:07.310 --> 00:02:09.590 
automatically sound if the
process model is sound.

30
00:02:10.550 --> 00:02:13.690 
And that's also similar to what
we see in databases where we

31
00:02:13.970 --> 00:02:19.400 
if we can show that that the database
schema is in a certain normal form

32
00:02:19.760 --> 00:02:23.390 
then certain anomalies cannot
occur in the database.

33
00:02:26.100 --> 00:02:29.100 
Alright so let's look at
the three properties.

34
00:02:29.960 --> 00:02:33.230 
Properties one two and
three by example.

35
00:02:34.050 --> 00:02:38.380 
And though the first property was
regardless of which activity

36
00:02:38.390 --> 00:02:39.990 
which decision
is taken,

37
00:02:40.810 --> 00:02:44.290 
the process eventually
reaches the

38
00:02:45.100 --> 00:02:48.910 
the final event the
output event.

39
00:02:49.660 --> 00:02:54.800 
And let's see if we can do a
brief analysis here and we can

40
00:02:55.110 --> 00:02:57.730 
we can decide to work
here or here or here.

41
00:02:58.880 --> 00:03:03.660 
In any case at some point we are at the
point of decide on claim coverage,

42
00:03:03.990 --> 00:03:08.600 
regardless of which of the
three decisions are taken I

43
00:03:08.600 --> 00:03:11.460 
will always come to the
decide and claim coverage.

44
00:03:12.050 --> 00:03:15.410 
And then I can either work here
or there but in any case

45
00:03:15.920 --> 00:03:18.300 
I will come to the
output o. So

46
00:03:19.110 --> 00:03:24.150 
all behavior regardless of which decision
is taken by the process I come from

47
00:03:24.700 --> 00:03:29.210 
from the state the initial state
to the final state or from state

48
00:03:29.210 --> 00:03:32.250 
i to the state o. So
property one obviously met

49
00:03:33.770 --> 00:03:37.370 
property two.
If I reach

50
00:03:38.170 --> 00:03:43.620 
o is the only state in which
or if I reach the final

51
00:03:43.620 --> 00:03:48.610 
state o if come to the o then the
the process model is completely

52
00:03:48.780 --> 00:03:52.510 
terminated. So there is no more
activity happening there. And

53
00:03:52.510 --> 00:03:57.960 
also we can see this basically by
the same walk-through I did.

54
00:03:58.180 --> 00:04:02.220 
So when I come to the claim processed
the claim processed event

55
00:04:02.220 --> 00:04:07.060 
occurs then I can be sure that no
other activity is still happening

56
00:04:07.090 --> 00:04:10.320 
as no activity left
in the process.

57
00:04:12.020 --> 00:04:14.630 
And the third property

58
00:04:15.130 --> 00:04:20.290 
umm third property is that all
activities can participate in

59
00:04:20.290 --> 00:04:23.400 
this process of course, that's is
also true and that's also shown

60
00:04:23.400 --> 00:04:26.480 
in the walkthrough see that the
yellow lines are everywhere so all

61
00:04:26.690 --> 00:04:30.140 
activities can happen. Not all
activities need to happen nor

62
00:04:30.140 --> 00:04:33.940 
events need to happen for the
same process instance but

63
00:04:34.390 --> 00:04:38.970 
for let's say all activities
are in one trace and by the

64
00:04:38.970 --> 00:04:43.450 
way each trace that we produce here
starts with i and ends with o.

65
00:04:43.680 --> 00:04:47.590 
So that's all also nice application
of what we learned about

66
00:04:47.590 --> 00:04:48.520 
traces before.

67
00:04:50.830 --> 00:04:55.050 
Formally the process is in a
deadlock after o has been reached.

68
00:04:55.720 --> 00:05:00.210 
So deadlock is a
situation in which

69
00:05:00.670 --> 00:05:04.270 
a process cannot move further
or a general system cannot

70
00:05:04.270 --> 00:05:08.260 
move further, it got stuck and
of course this also happens

71
00:05:08.260 --> 00:05:12.900 
here when o occurs but at
that point it's perfectly

72
00:05:12.900 --> 00:05:16.270 
ok because at that point the
process don't the process

73
00:05:16.270 --> 00:05:20.090 
does not need to continue
and therefore the deadlock

74
00:05:20.090 --> 00:05:25.530 
in state o is perfectly ok and we are
and it does not violate soundness.

75
00:05:28.410 --> 00:05:30.840 
Ok so once we know

76
00:05:32.110 --> 00:05:36.710 
what sound behavior is how can we detect
unsound behaviour? Well by negating

77
00:05:36.850 --> 00:05:38.800 
either of the three
properties.

78
00:05:39.810 --> 00:05:43.760 
So we can detect unsound process
behavior by finding a violation of

79
00:05:43.990 --> 00:05:46.790 
either of the soundness
properties. So violation of

80
00:05:47.370 --> 00:05:52.730 
property one the process cannot reach
the final event o, it gets stuck

81
00:05:52.940 --> 00:05:57.550 
before. There is a deadlock and
the deadlock before o is always

82
00:05:57.550 --> 00:05:58.990 
reached, to be
precise here.

83
00:06:00.320 --> 00:06:04.290 
Well a violation of property two
means remaining activities

84
00:06:04.290 --> 00:06:07.780 
remaining activity in the process
after reaching the final event

85
00:06:07.920 --> 00:06:12.320 
o the final event is reached and still
activities can happen in the process.

86
00:06:13.620 --> 00:06:17.320 
And we even see an example
where there is a continuous

87
00:06:17.430 --> 00:06:20.900 
execution of activities
after the final event

88
00:06:21.310 --> 00:06:24.360 
output event has occurred and that's
called a livelock situation.

89
00:06:24.970 --> 00:06:28.650 
And violation of property three is
that there might be activities

90
00:06:28.650 --> 00:06:32.130 
that can never be executed. These are
called dead activities because they can

91
00:06:32.340 --> 00:06:35.800 
they appear in no trace of the
process model therefore that

92
00:06:35.810 --> 00:06:38.970 
would we would also say this
is unsound process behavior.

93
00:06:40.140 --> 00:06:44.570 
So let's look at the violation of property
one and the deadlock violation.

94
00:06:45.420 --> 00:06:50.980 
We look at the example that we
introduced in the previous video clip.

95
00:06:51.650 --> 00:06:56.260 
So you remember the problem
that we had here.

96
00:06:56.760 --> 00:07:01.900 
So we first of all we make a
walk through make another

97
00:07:01.900 --> 00:07:07.730 
walkthrough here we have the concurrency.
So after receive order these two

98
00:07:08.700 --> 00:07:11.740 
OR branches can be executed
independently from each other.

99
00:07:12.320 --> 00:07:15.960 
And here then is a synchronizing
join, the AND join synchronize

100
00:07:15.960 --> 00:07:17.850 
the two branches, check
payment is done,

101
00:07:18.650 --> 00:07:21.040 
payment is ok, and then
always reached. Yeah so

102
00:07:21.770 --> 00:07:24.600 
of course here we have

103
00:07:25.810 --> 00:07:28.220 
event i and here we
have the event o.

104
00:07:29.490 --> 00:07:33.860 
Alright so that's an example of a
valid completely valid execution

105
00:07:34.080 --> 00:07:36.010 
of this process
model and

106
00:07:36.620 --> 00:07:41.480 
so there's no problem here.
However property one states that

107
00:07:41.700 --> 00:07:44.700 
regardless of the decision
taken by the process

108
00:07:45.180 --> 00:07:47.850 
the property should
hold that i reach o.

109
00:07:48.890 --> 00:07:51.950 
So let's see what
happens if

110
00:07:53.490 --> 00:07:58.590 
I erase that again. What happens
if I did these things the first

111
00:07:58.590 --> 00:08:01.690 
time, but then this decision is
taken invalid amount sent update

112
00:08:01.690 --> 00:08:05.390 
invoice is performed receive
payment is done twice and then

113
00:08:05.390 --> 00:08:09.470 
the process is stuck. So here the
process is stuck because the end join

114
00:08:09.720 --> 00:08:14.970 
cannot fire. And in this case
the o is not reached, so the

115
00:08:14.970 --> 00:08:18.840 
final event o is not reached. So their
decision in which the final event

116
00:08:19.080 --> 00:08:22.640 
is not reached and therefore the
process model violates property one.

117
00:08:25.290 --> 00:08:29.800 
Violation of property two -
remaining activities or livelock.

118
00:08:29.800 --> 00:08:34.120 
Here we have a livelock. If and
when the process reaches o

119
00:08:34.210 --> 00:08:37.680 
it has completely terminated. No
further activities can be executed

120
00:08:37.680 --> 00:08:39.330 
by the process
anymore. That's a

121
00:08:40.030 --> 00:08:41.260 
that's property two.

122
00:08:42.370 --> 00:08:47.800 
Here we have a slight change so
maybe some of you spotted that

123
00:08:47.970 --> 00:08:50.550 
a change of the process
model already.

124
00:08:51.220 --> 00:08:54.220 
And that is we have

125
00:08:54.840 --> 00:08:58.180 
here we have an XOR

126
00:08:59.560 --> 00:09:02.410 
an XOR join and here we
have an AND split.

127
00:09:02.880 --> 00:09:09.950 
Ok so what happens is that receive order
here we have the AND split, the XOR join

128
00:09:10.510 --> 00:09:14.840 
immediately triggers the outgoing
edge, check payment is done here

129
00:09:15.330 --> 00:09:19.000 
the first time o is executed
but here we have the send

130
00:09:19.400 --> 00:09:21.760 
updated invoice. Then

131
00:09:22.470 --> 00:09:25.840 
we have from the first iteration we
go here we have a check payment

132
00:09:26.230 --> 00:09:30.240 
and here we have another iteration
and receive payment is done. So

133
00:09:30.680 --> 00:09:32.520 
this loop will continue

134
00:09:33.450 --> 00:09:39.040 
without any AND so that's a livelock
consisting of these three

135
00:09:39.040 --> 00:09:42.080 
activities because this isn't
the problem is that of course

136
00:09:42.080 --> 00:09:43.180 
this is an AND split.

137
00:09:44.030 --> 00:09:47.340 
And in order to avoid the
deadlock here we introduce this

138
00:09:47.340 --> 00:09:52.060 
XOR join which leads to a
consecutive or to infinite let's

139
00:09:52.060 --> 00:09:53.930 
execution also of
check payment.

140
00:09:54.930 --> 00:09:57.700 
Right that's an example of a livelock,
also something you would not

141
00:09:57.740 --> 00:09:59.450 
like to see in
your process.

142
00:10:00.260 --> 00:10:06.160 
By the way also this is a
perfectly legal process

143
00:10:06.160 --> 00:10:08.930 
model in terms of syntax. It's
even structurally sound.

144
00:10:09.540 --> 00:10:12.860 
But still it has these behavioral
anomalies that is that are

145
00:10:12.860 --> 00:10:17.420 
incurred by the wrong use
on the wrong use of the

146
00:10:18.160 --> 00:10:22.060 
of the gateways and also
of the structure.

147
00:10:24.280 --> 00:10:27.790 
Ok processes in the livelock of
the control flow structure

148
00:10:27.790 --> 00:10:30.890 
makes the process executing
an infinite number

149
00:10:30.890 --> 00:10:34.850 
of activities we've seen this in the
previous slide already. So here

150
00:10:34.960 --> 00:10:39.160 
we are you can have them a dedicated
explanation of the livelock.

151
00:10:40.800 --> 00:10:44.420 
But it does not only need to be
livelock that violates property

152
00:10:44.420 --> 00:10:47.560 
two but we can also have remaining
activity in the process.

153
00:10:47.560 --> 00:10:51.130 
So after reaching the final event
there might be additional

154
00:10:51.130 --> 00:10:55.740 
activities happening in the
process. And an example that we

155
00:10:55.740 --> 00:10:59.940 
see here that we also see in real world
process models here and there -

156
00:11:00.340 --> 00:11:05.430 
if we use an AND split and
if the AND split is then

157
00:11:05.430 --> 00:11:07.330 
close with an XOR join.

158
00:11:08.360 --> 00:11:10.420 
So what happens here is

159
00:11:12.540 --> 00:11:16.840 
that we receive order the first
activity then we package the products

160
00:11:17.800 --> 00:11:20.980 
and this again concurrency
introduced by the AND split,

161
00:11:21.400 --> 00:11:25.990 
issue payment, receive payment,
if receive payment completes

162
00:11:25.990 --> 00:11:27.100 
cheque payment is done,

163
00:11:28.220 --> 00:11:32.120 
if issue shipment is performed
check payment is done again.

164
00:11:32.130 --> 00:11:35.620 
After the first execution of cheque
payment the end event occurs

165
00:11:36.230 --> 00:11:40.910 
but then check payment can still
be executed or depending on the

166
00:11:41.070 --> 00:11:45.650 
on the speed of the concurrent branches
even more activities can be executed.

167
00:11:46.360 --> 00:11:49.270 
So let's look
that maybe more

168
00:11:50.150 --> 00:11:54.060 
in more details. So let's assume
receive order is performed, send

169
00:11:54.060 --> 00:11:56.450 
invoice is performed, receive
payment is performed,

170
00:11:57.000 --> 00:12:01.170 
the XOR join is performed,
check payment is performed,

171
00:12:01.640 --> 00:12:03.810 
and the end event occurs
for the first time.

172
00:12:04.280 --> 00:12:06.980 
So that should signal the end of
the process but there is no

173
00:12:06.980 --> 00:12:10.990 
end of the process because package
products can be executed

174
00:12:11.360 --> 00:12:14.810 
and issue shipment can be executed
and check payment can be

175
00:12:14.810 --> 00:12:19.310 
executed one more time. So
reaching the final event o does

176
00:12:19.310 --> 00:12:22.480 
not signal the end of the process
but there is activity left

177
00:12:22.480 --> 00:12:26.020 
and these activities are called this
is called the situation is called

178
00:12:26.230 --> 00:12:29.190 
remaining activity after
reaching the final event.

179
00:12:31.300 --> 00:12:35.340 
How to avoid unsound processes?
Well you should always

180
00:12:35.350 --> 00:12:40.670 
we could always use structured
process models so that each split

181
00:12:40.880 --> 00:12:44.620 
is closed by the
respective join.

182
00:12:45.720 --> 00:12:49.340 
So each split gateway has
exactly one join gateway of

183
00:12:49.340 --> 00:12:52.940 
the same type so that each path
originating from the split

184
00:12:52.950 --> 00:12:56.070 
will reach the join. So that's
block structured model we also

185
00:12:56.070 --> 00:12:58.600 
say block structured model
to this structure.

186
00:12:59.780 --> 00:13:03.850 
This makes sure that
loops obey or make

187
00:13:04.570 --> 00:13:07.590 
this makes also sure that loops
obey the block structure

188
00:13:08.100 --> 00:13:09.890 
as seen in the
earlier example.

189
00:13:10.910 --> 00:13:14.960 
However using only block structured
process models limit the

190
00:13:14.960 --> 00:13:17.630 
expressiveness or limited in
what you like to express

191
00:13:17.630 --> 00:13:21.090 
for instance you cannot express the
different outcomes you cannot express

192
00:13:21.490 --> 00:13:24.740 
that you have an XOR split. So
either yes on the order is

193
00:13:24.740 --> 00:13:26.900 
fulfilled or no the order
is not fulfilled.

194
00:13:27.410 --> 00:13:31.630 
And you cannot use different end
events to represent these two

195
00:13:31.630 --> 00:13:36.520 
different outcomes. So there is this
limitation so in general this

196
00:13:36.520 --> 00:13:40.200 
might not be so good idea to
use only the structured

197
00:13:40.210 --> 00:13:41.510 
structured
process models.

198
00:13:44.270 --> 00:13:48.850 
Ok we sketch that in the middle
part here. However these

199
00:13:48.850 --> 00:13:51.260 
constraints limit the
possibilities of modelling

200
00:13:51.840 --> 00:13:55.160 
process models that are best
understood might not be possible.

201
00:13:55.250 --> 00:13:59.370 
So there is a price to pay and the
price to pay might be quite high

202
00:13:59.690 --> 00:14:04.390 
in many cases. But there is
there is a better way and

203
00:14:04.390 --> 00:14:08.200 
better way is to use smart modeling tools
and there are modeling tools like

204
00:14:08.360 --> 00:14:12.980 
the Signavio process editor that
you have been working with.

205
00:14:13.240 --> 00:14:16.870 
So we use smart modeling tools that
provide soundness checks and

206
00:14:16.880 --> 00:14:20.780 
feedback messages on why a given
process is not sound. So that's

207
00:14:21.080 --> 00:14:24.210 
always a good way
to use these

208
00:14:24.720 --> 00:14:27.300 
formal properties and to be able
to check these properties

209
00:14:27.300 --> 00:14:28.510 
also in your
modeling tool.

210
00:14:30.830 --> 00:14:34.870 
That concludes videoclip 3.3 in
which we explained soundness.

211
00:14:35.510 --> 00:14:41.170 
So soundness the idea of soundness is
that every process instance terminates

212
00:14:41.530 --> 00:14:45.630 
properly, so in any case
regardless of which decision

213
00:14:45.630 --> 00:14:48.010 
is taken by the process
I reached the final

214
00:14:49.100 --> 00:14:52.620 
final event o. If I reach the
final event o there's no more

215
00:14:52.620 --> 00:14:57.540 
activity left in the process and
all activities contribute to

216
00:14:57.950 --> 00:14:59.360 
at least one
process instance.

217
00:15:01.800 --> 00:15:06.080 
We saw that we saw a number of
violations in order to detect

218
00:15:06.540 --> 00:15:10.400 
unsound behaviour. We can look
for deadlocks, we can look for

219
00:15:10.400 --> 00:15:14.730 
livelocks. So we can look for
remaining activities and

220
00:15:15.120 --> 00:15:19.680 
structured process models help
actually help avoid these anomalies

221
00:15:19.900 --> 00:15:23.990 
but there's a price to pay and also
there's a possibility of using

222
00:15:24.460 --> 00:15:28.310 
the right modeling tool. Then you can
model as you like, be expressive

223
00:15:28.310 --> 00:15:31.820 
as you like and still be sure
that your process does not have

224
00:15:32.000 --> 00:15:33.110 
behavioral anomalies.
