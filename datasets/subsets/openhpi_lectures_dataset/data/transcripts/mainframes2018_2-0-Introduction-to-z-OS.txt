WEBVTT

1
00:00:00.180 --> 00:00:04.919 
Welcome to the introduction to the z/OS operating system.

2
00:00:04.920 --> 00:00:08.460 
My name is Phillip Brune from Neu Ulm University of Applied Sciences.

3
00:00:10.550 --> 00:00:15.199 
In this presentation, I would like to give you a brief introduction in

4
00:00:15.200 --> 00:00:19.699 
the z/OS operating system, which is the most important

5
00:00:19.700 --> 00:00:24.259 
and most critical, although the

6
00:00:24.260 --> 00:00:28.789 
operating system for the most critical applications on the set mainframe

7
00:00:28.790 --> 00:00:34.189 
platform and our overview slide that we already had in the introduction,

8
00:00:34.190 --> 00:00:39.079 
we can see that s is the name of the operating system,

9
00:00:39.080 --> 00:00:43.489 
which dates back to the first days of the mainframe in the 1960's.

10
00:00:43.490 --> 00:00:48.019 
And originally it was named MVS for multiple virtual storage

11
00:00:48.020 --> 00:00:52.219 
and during the years it changed its name.

12
00:00:52.220 --> 00:00:56.149 
But most of the time it was called something with MVS in front.

13
00:00:56.150 --> 00:01:00.679 
But in the 90's it was called always OS 390, and then nowadays

14
00:01:00.680 --> 00:01:01.680 
it's called z/OS.

15
00:01:02.870 --> 00:01:07.339 
The original MVS name originated from multiple virtual storage

16
00:01:07.340 --> 00:01:11.959 
because it was a new feature in these days that a system could

17
00:01:11.960 --> 00:01:17.509 
have multiple programs running in parallel having their own virtual

18
00:01:17.510 --> 00:01:21.949 
memory, virtual storage. This, of course, is standard today, but in these days

19
00:01:21.950 --> 00:01:26.030 
it was a new innovation, so it was put in the name of the product.

20
00:01:27.800 --> 00:01:32.659 
And the operating system evolved over the years, starting from

21
00:01:32.660 --> 00:01:35.389 
a very simple, so called primary control program.

22
00:01:35.390 --> 00:01:40.879 
Simplify our modern perspective on the original 360,

23
00:01:40.880 --> 00:01:46.129 
which is or was a 16 or later 24 bit system

24
00:01:46.130 --> 00:01:48.649 
until nowadays we call it sideways.

25
00:01:48.650 --> 00:01:52.759 
Nevertheless, this is the same operating system in a way, so it's just evolving.

26
00:01:52.760 --> 00:01:57.259 
But of course, many features originating from earlier versions are still

27
00:01:57.260 --> 00:01:59.810 
present and are still core to the system.

28
00:02:02.890 --> 00:02:07.509 
When you look at modern mainframe in a typical enterprise setting, of course,

29
00:02:07.510 --> 00:02:11.199 
we already heard that the mainframe could be partitioned.

30
00:02:11.200 --> 00:02:15.759 
So we have a logical partitions and typically we will not only have one partition,

31
00:02:15.760 --> 00:02:20.259 
but the system will be partitioned in different virtual servers and try to

32
00:02:20.260 --> 00:02:25.179 
illustrate this here, and you could run different operating systems in the different

33
00:02:25.180 --> 00:02:28.419 
bits of machines. So logical partitioning is a.

34
00:02:29.420 --> 00:02:34.009 
But virtualization technique that's built in the hardware, and in this case,

35
00:02:34.010 --> 00:02:36.589 
for example, we have here one two partition.

36
00:02:36.590 --> 00:02:41.029 
Typically in practice, z/OS is run directly in

37
00:02:41.030 --> 00:02:45.709 
an LAPR, logical partition not under ZVM virtualization.

38
00:02:45.710 --> 00:02:48.049 
Nevertheless, this, of course, is possible.

39
00:02:48.050 --> 00:02:50.599 
That was a sketch idea. It's just not very common.

40
00:02:50.600 --> 00:02:55.709 
It's common for teaching and educational settings, but not very common for industrial

41
00:02:55.710 --> 00:03:00.709 
or professional business applications, because

42
00:03:00.710 --> 00:03:05.449 
it has some licensing issues that make it less effective for

43
00:03:05.450 --> 00:03:09.739 
commercial customers. So this is why we use typically said to us as the core operating

44
00:03:09.740 --> 00:03:12.469 
system and its own logical partition.

45
00:03:12.470 --> 00:03:16.430 
So now we would like to have a look closer look on the z/OS operating system

46
00:03:17.800 --> 00:03:22.279 
that the operating system is reflexive flagship

47
00:03:22.280 --> 00:03:24.649 
product by IBM for the mainframe.

48
00:03:24.650 --> 00:03:29.419 
It's the long lasting workhorse for

49
00:03:29.420 --> 00:03:32.930 
enterprise applications. And during the decades, it has

50
00:03:33.980 --> 00:03:37.219 
of course changed. New features have been added.

51
00:03:37.220 --> 00:03:41.689 
But the fundamental structure, of course, is still still the same like every operating

52
00:03:41.690 --> 00:03:46.339 
system also said has a kernel which is doing the basic

53
00:03:46.340 --> 00:03:51.319 
things of an operating system kernel, which is in particular memory management

54
00:03:51.320 --> 00:03:54.709 
and CPU management, scheduling, task management.

55
00:03:54.710 --> 00:03:59.539 
And they're providing the connection to address the peripheral

56
00:03:59.540 --> 00:04:02.779 
peripheral devices that i o devices.

57
00:04:02.780 --> 00:04:07.279 
However, on z/OS is here something specific because

58
00:04:07.280 --> 00:04:11.719 
a large part of the input output management code

59
00:04:11.720 --> 00:04:16.429 
is not part of the kernel, but is moved out to so-called access

60
00:04:16.430 --> 00:04:20.539 
methods. An access method could be imagined as

61
00:04:21.740 --> 00:04:25.550 
kind of a shared library for all programs that provides

62
00:04:26.840 --> 00:04:31.279 
functions, routines to access all devices of different

63
00:04:31.280 --> 00:04:36.049 
kind and depending on the type of i o device and the style.

64
00:04:36.050 --> 00:04:39.679 
How this is accessed, there are different access methods.

65
00:04:39.680 --> 00:04:42.829 
For example, he has a basic partitioned access method, basic sequential.

66
00:04:42.830 --> 00:04:45.019 
These are some more historical ones.

67
00:04:45.020 --> 00:04:49.669 
But today, for example, we still use the virtual storage access method,

68
00:04:49.670 --> 00:04:54.389 
which is very common and very popular.

69
00:04:55.400 --> 00:05:00.379 
And these are typical routines for accessing

70
00:05:00.380 --> 00:05:04.909 
i o devices, for accessing, for example, disks and and terminals

71
00:05:04.910 --> 00:05:09.439 
and so on. And these access methods, there

72
00:05:09.440 --> 00:05:13.579 
are different ways to access the file, and a program and application program can also

73
00:05:13.580 --> 00:05:18.139 
determine how it accesses of file by choosing a specific access method for

74
00:05:18.140 --> 00:05:20.059 
a certain operation.

75
00:05:20.060 --> 00:05:24.679 
That's a different way of of implementing input output operations compared,

76
00:05:24.680 --> 00:05:27.319 
for example, how it is handled in in a Linux kernel.

77
00:05:29.240 --> 00:05:34.759 
On top of that, of course, we have different applications or assistance system services

78
00:05:34.760 --> 00:05:37.369 
that are part of the operating system.

79
00:05:37.370 --> 00:05:41.809 
And in the following, we will have introductions to different

80
00:05:41.810 --> 00:05:46.789 
or to various of these very important or original

81
00:05:46.790 --> 00:05:51.969 
from the from the first versions is the drop entry subsystem, the drop entry subsystem.

82
00:05:51.970 --> 00:05:56.719 
The JS is a process that has started usually

83
00:05:56.720 --> 00:05:59.540 
during, um, starting up the system

84
00:06:01.250 --> 00:06:05.749 
in the Linux world. We would call that booting the system and the mainframe, but we call

85
00:06:05.750 --> 00:06:07.819 
it IP initial program load.

86
00:06:07.820 --> 00:06:12.259 
So when we do an IPO and we start the operating system

87
00:06:12.260 --> 00:06:16.729 
like in all operating systems, some tasks already started directly

88
00:06:16.730 --> 00:06:21.049 
after booting that started as part of the system initialization.

89
00:06:21.050 --> 00:06:25.699 
And these are called started tasks and the drop entry subsystem, for example,

90
00:06:25.700 --> 00:06:30.169 
is such a static task. So it's something that's usually running on a system

91
00:06:30.170 --> 00:06:34.609 
and the jump entry subsystem is there for handing the batch

92
00:06:34.610 --> 00:06:37.609 
processing running batch jobs.

93
00:06:37.610 --> 00:06:42.109 
On the other hand, of course, we have the interactive component

94
00:06:42.110 --> 00:06:46.759 
called T as all the time sharing option and by the name you already

95
00:06:46.760 --> 00:06:50.179 
can see, that is originally was an option, something that they could add

96
00:06:51.530 --> 00:06:54.559 
because in the first systems, of course, there was only batch processing.

97
00:06:54.560 --> 00:06:59.179 
But then in the seventies, the interactive style of working with a system

98
00:06:59.180 --> 00:07:02.329 
using terminals and direct user interaction came up.

99
00:07:02.330 --> 00:07:07.579 
And so the TSL was at at the so could be imagined like

100
00:07:07.580 --> 00:07:11.449 
a log in shell on a Linux or Unix environment, for example.

101
00:07:11.450 --> 00:07:15.919 
So it's a command interface to start programs and to interact with the system

102
00:07:15.920 --> 00:07:18.739 
to make it a bit more efficient and easier.

103
00:07:18.740 --> 00:07:23.359 
Later on, the ICF was added, which is a sort of a service program that's run, and that is

104
00:07:23.360 --> 00:07:27.859 
all that provides a certain kind of text based menu interface to

105
00:07:27.860 --> 00:07:32.399 
make operations. Anesthesia, then, of course, we have the so-called

106
00:07:32.400 --> 00:07:37.149 
unique system services, which are also integral part of the Cedras distribution

107
00:07:37.150 --> 00:07:41.969 
system services is of repair on top of the z/OS as kernel.

108
00:07:41.970 --> 00:07:46.499 
And on top of the access methods to implement Oppo's

109
00:07:46.500 --> 00:07:51.299 
conforme machine interface or System Interface API

110
00:07:51.300 --> 00:07:55.739 
so you could run and compile Unix programs without modification

111
00:07:55.740 --> 00:07:58.589 
on z/OS. So this makes it said us as well.

112
00:07:58.590 --> 00:08:01.319 
POSIX compliant operating system.

113
00:08:01.320 --> 00:08:05.369 
This is an integral part, and it's a sort of it's not an emulation, it's not a virtual

114
00:08:05.370 --> 00:08:09.899 
machine, but it's just a wrapper that converts the system calls into

115
00:08:09.900 --> 00:08:13.230 
a system called the Unix system, causing into sideways system calls.

116
00:08:14.670 --> 00:08:19.049 
So this is a very directly integral part of the system.

117
00:08:19.050 --> 00:08:23.609 
We have in on many systems that would have a transaction processing

118
00:08:23.610 --> 00:08:26.459 
monitor, such as six, for example, which I just sketched.

119
00:08:26.460 --> 00:08:30.629 
Here we go. Come back to that later in the chapter on transaction processing.

120
00:08:30.630 --> 00:08:34.288 
And beside this, of course, we can have a majority of other programs, third party

121
00:08:34.289 --> 00:08:39.029 
programs, database servers and everything that you could imagine

122
00:08:39.030 --> 00:08:43.709 
that are just briefly summarized up here with other programs.

123
00:08:43.710 --> 00:08:48.179 
So this is a basic structure of ASADA's instance of US address

124
00:08:48.180 --> 00:08:52.499 
system. And in the following, you will have a deeper look on the job intercept system on

125
00:08:52.500 --> 00:08:55.829 
the TESOL and ISPF and Unix system services.

126
00:08:55.830 --> 00:09:00.359 
And we talk about Java, for example. So these are the core parts

127
00:09:00.360 --> 00:09:01.409 
of z/OS.

128
00:09:05.550 --> 00:09:10.139 
So one of the as I already mentioned,

129
00:09:10.140 --> 00:09:14.819 
a one one, one sort of unconventional

130
00:09:14.820 --> 00:09:19.499 
thing, these access methods, these libraries that are used to access

131
00:09:19.500 --> 00:09:23.490 
files or datasets as they're called on the mainframe on the side of us

132
00:09:24.540 --> 00:09:29.189 
by application programs. And so these are kind of libraries

133
00:09:29.190 --> 00:09:33.689 
that communicate then with the actual i o devices using

134
00:09:33.690 --> 00:09:38.609 
or going through the kernel by sending so-called channel programs.

135
00:09:38.610 --> 00:09:42.539 
We learned that in the past on the channel subsystem, and this channel programs consist

136
00:09:42.540 --> 00:09:44.489 
of channel command votes, which are

137
00:09:47.160 --> 00:09:51.719 
sequences of instructions and how I operations should be performed.

138
00:09:51.720 --> 00:09:52.720 
And.

139
00:09:53.610 --> 00:09:58.079 
By choosing the right access method, a program can determine how it opens

140
00:09:58.080 --> 00:10:02.519 
and accesses, for example, a data set or which record would call a fail

141
00:10:02.520 --> 00:10:06.689 
in a modern operating system like Linux.

142
00:10:06.690 --> 00:10:10.319 
So there are different access methods that have been developed and implemented over the

143
00:10:10.320 --> 00:10:14.939 
years, and some have been added today, usually for some of the most important one,

144
00:10:14.940 --> 00:10:17.159 
and the others are partially emulated.

145
00:10:17.160 --> 00:10:21.639 
But still, of course, these ways these access methods are accessible

146
00:10:21.640 --> 00:10:26.189 
are present on the system so we can use them to access the different kind

147
00:10:26.190 --> 00:10:27.190 
of files.
