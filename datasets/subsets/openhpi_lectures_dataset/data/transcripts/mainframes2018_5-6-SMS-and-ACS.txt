WEBVTT

1
00:00:00.720 --> 00:00:02.999 
Hello, folks, it's me again.

2
00:00:03.000 --> 00:00:07.469 
Wolfram Greis, from the European Academy and in the next video

3
00:00:07.470 --> 00:00:11.549 
clip, I want to talk about storage management subsystem.

4
00:00:11.550 --> 00:00:16.128 
The automatic management of storage in

5
00:00:16.129 --> 00:00:20.609 
an z/os environment and important

6
00:00:20.610 --> 00:00:25.349 
component of this SMS environment is automatic

7
00:00:25.350 --> 00:00:30.389 
class selection managed by automatic class selection routines.

8
00:00:30.390 --> 00:00:35.159 
I will talk about these components in the next minutes.

9
00:00:38.440 --> 00:00:42.806 
SMS is a set of constructs, interfaces and routines

10
00:00:43.870 --> 00:00:48.399 
used by the DFSMS, and the

11
00:00:48.400 --> 00:00:53.289 
goal is an efficient management of storage and storage

12
00:00:53.290 --> 00:00:58.180 
medium. And the core logic of SMS is

13
00:00:59.320 --> 00:01:04.689 
implemented with SMS routines, automatic selection routines,

14
00:01:04.690 --> 00:01:09.999 
with interactive storage management facility and is ISMF

15
00:01:10.000 --> 00:01:13.869 
Extension and so-called SMS constructs.

16
00:01:13.870 --> 00:01:19.449 
And this logic is built into the components

17
00:01:19.450 --> 00:01:23.380 
data facility product. This is data management component

18
00:01:24.580 --> 00:01:29.079 
within the z/OS heirarchical storage manager as I talked

19
00:01:29.080 --> 00:01:32.739 
already in the last videoclip and the dataset services.

20
00:01:34.900 --> 00:01:39.369 
Now the idea of SMS is you have a logical request to allocate

21
00:01:39.370 --> 00:01:43.540 
some data on DASD and

22
00:01:45.010 --> 00:01:50.019 
in early times of mainframe

23
00:01:50.020 --> 00:01:54.549 
processing, you had to define this a

24
00:01:54.550 --> 00:01:59.049 
lot of parameters as example, independent if

25
00:01:59.050 --> 00:02:03.579 
you work with DSD, along with this ISPFs, you had

26
00:02:03.580 --> 00:02:08.168 
to define how many space you need, how many tracks, how

27
00:02:08.169 --> 00:02:13.179 
many cylinders. These are physical parameters

28
00:02:13.180 --> 00:02:15.849 
for allocating DASD space.

29
00:02:15.850 --> 00:02:20.499 
You don't need these physical view

30
00:02:20.500 --> 00:02:23.949 
any more. So you just have a logical request.

31
00:02:23.950 --> 00:02:28.569 
And a logical request is controlled by the so-called last

32
00:02:28.570 --> 00:02:30.639 
level qualifier of a dataset.

33
00:02:30.640 --> 00:02:35.379 
So the main control is done by this last level qualifier.

34
00:02:35.380 --> 00:02:40.719 
As example, if you allocate the dataset with the last level qualifier of cobol,

35
00:02:40.720 --> 00:02:45.309 
SMS automatically knows that you

36
00:02:45.310 --> 00:02:50.259 
want to have a logical record up length of 80, because

37
00:02:50.260 --> 00:02:55.719 
cobol source code is still managed by

38
00:02:55.720 --> 00:03:00.369 
logic, a record length of 80 and some other assumptions

39
00:03:00.370 --> 00:03:01.179 
are made.

40
00:03:01.180 --> 00:03:04.976 
So you adjust the request,

41
00:03:07.210 --> 00:03:10.210 
give in your logical information and

42
00:03:11.710 --> 00:03:16.479 
SMS does the physical placement of the data

43
00:03:16.480 --> 00:03:19.259 
depending on your logical request.

44
00:03:19.260 --> 00:03:24.189 
There are some definitions and rules given into such an environment.

45
00:03:24.190 --> 00:03:27.619 
It's done by storage administrators as examples.

46
00:03:27.620 --> 00:03:32.169 
The number of generations for back

47
00:03:32.170 --> 00:03:36.999 
up copies, space capacity parameters, importance

48
00:03:37.000 --> 00:03:41.919 
of some data and so on. A lot of parameters are defined by storage

49
00:03:41.920 --> 00:03:42.920 
administrators.

50
00:03:45.390 --> 00:03:49.934 
We have four different estimates constructs within SMS

51
00:03:51.300 --> 00:03:56.189 
as example, the data class defines the characteristics

52
00:03:56.190 --> 00:04:00.720 
of the data as example just mentioned, cobol

53
00:04:01.740 --> 00:04:07.019 
source code always has the

54
00:04:07.020 --> 00:04:09.359 
logic recordings of 80.

55
00:04:09.360 --> 00:04:14.099 
The storage class takes some

56
00:04:14.100 --> 00:04:17.549 
performance assumptions and performance issues.

57
00:04:17.550 --> 00:04:22.469 
The management class is the interface to the hierarachical storage manager.

58
00:04:22.470 --> 00:04:27.089 
It means also, depending on the last level qualifier, the management class

59
00:04:27.090 --> 00:04:31.679 
determines how many back up copies are held

60
00:04:31.680 --> 00:04:36.449 
within SMS. Or if in any case, backups

61
00:04:36.450 --> 00:04:40.889 
are made as example. If you allocate a temporary dataset,

62
00:04:40.890 --> 00:04:43.649 
you don't need any backup of course.

63
00:04:43.650 --> 00:04:48.689 
And this is a logical view depending on the

64
00:04:48.690 --> 00:04:53.241 
dataset, naming conventions and some other parameters you

65
00:04:55.410 --> 00:04:56.864 
give in to the subsystem.

66
00:05:02.570 --> 00:05:07.009 
And if the logical view is complete, your

67
00:05:07.010 --> 00:05:11.899 
physical view is completely managed by estimates so the user

68
00:05:11.900 --> 00:05:16.489 
don't have any control on where the

69
00:05:16.490 --> 00:05:20.969 
datasets are placed. This is totally managed by

70
00:05:20.970 --> 00:05:25.669 
SMS. And this is a really good idea that SMS and

71
00:05:26.750 --> 00:05:31.219 
this automation deal with

72
00:05:31.220 --> 00:05:33.260 
the physical placement of the data.

73
00:05:35.960 --> 00:05:40.419 
A very important concept within SMS is the automatic class

74
00:05:40.420 --> 00:05:45.679 
selection and the routines that are behind these class selections.

75
00:05:45.680 --> 00:05:50.119 
With these routines, you can define what happens if

76
00:05:50.120 --> 00:05:54.919 
you do a dataset allocation and all these routines

77
00:05:54.920 --> 00:05:59.539 
are processed when the new dataset allocation takes

78
00:05:59.540 --> 00:06:00.259 
place.

79
00:06:00.260 --> 00:06:04.939 
The first is the data class routine, depending on

80
00:06:04.940 --> 00:06:09.409 
the mostly on the last level qualifier, or you can

81
00:06:09.410 --> 00:06:13.859 
also give in parameters in ISPF or

82
00:06:13.860 --> 00:06:18.679 
also on desktops with trace parameters which

83
00:06:18.680 --> 00:06:23.089 
data class you want to use in this case.

84
00:06:23.090 --> 00:06:27.529 
But in the most cases, it's really just done

85
00:06:27.530 --> 00:06:32.419 
by naming conventions. It means if you allocate dataset

86
00:06:32.420 --> 00:06:36.049 
with the last level qualifier, let's take the same example again.

87
00:06:36.050 --> 00:06:40.759 
COBOL data class defines that the logical record length is

88
00:06:40.760 --> 00:06:45.379 
80 and that you need a certain default

89
00:06:45.380 --> 00:06:50.329 
DASD space. If you want to increase or decrease

90
00:06:50.330 --> 00:06:55.009 
this default number, you can give in some

91
00:06:55.010 --> 00:06:59.719 
more parameters, but normally just the dataset name is enough

92
00:06:59.720 --> 00:07:04.579 
to let the ACS manage how

93
00:07:04.580 --> 00:07:06.889 
the dataset is allocated.

94
00:07:06.890 --> 00:07:11.659 
First routine is data class, second routine

95
00:07:11.660 --> 00:07:14.119 
that is processed is a storage class.

96
00:07:14.120 --> 00:07:19.159 
And as example, if you don't assign any storage

97
00:07:19.160 --> 00:07:24.049 
class or in most cases it's automatically assigned

98
00:07:24.050 --> 00:07:28.489 
or not assigned, depending again on naming conventions,

99
00:07:28.490 --> 00:07:33.289 
if no storage class is assigned, then the dataset

100
00:07:33.290 --> 00:07:34.360 
is not SMS managed.

101
00:07:35.420 --> 00:07:39.919 
As example system data set that have

102
00:07:39.920 --> 00:07:44.180 
a high level qualifier as of example

103
00:07:45.230 --> 00:07:50.269 
as one are not SMS managed because

104
00:07:50.270 --> 00:07:54.919 
these are datasets belonging to the operating system and you

105
00:07:54.920 --> 00:07:58.390 
don't want as example to migrate this to

106
00:08:01.880 --> 00:08:04.389 
a migration level.

107
00:08:05.390 --> 00:08:10.549 
So normally for system datasets you don't assign any

108
00:08:10.550 --> 00:08:15.079 
storage class and then this dataset is not SMS

109
00:08:15.080 --> 00:08:19.519 
managed. After that comes the management class with the interface

110
00:08:19.520 --> 00:08:23.989 
to the hierarchical storage manager and afterwards the storage group can

111
00:08:23.990 --> 00:08:28.908 
be assigned and the storage group manages where the data is

112
00:08:28.909 --> 00:08:33.558 
physically placed. And this management, again, to mention, is totally

113
00:08:33.559 --> 00:08:35.257 
done by SMS.

114
00:08:38.650 --> 00:08:43.418 
Naming conventions are really critical in an environment.

115
00:08:43.419 --> 00:08:47.919 
It's a really important issue and eases

116
00:08:47.920 --> 00:08:52.509 
all the processing that are done for the users

117
00:08:52.510 --> 00:08:57.219 
that they want to allocate new data sets or delete some data sets

118
00:08:57.220 --> 00:09:00.609 
and also for administrators.

119
00:09:00.610 --> 00:09:05.109 
And as example, once again, the naming conventions are really

120
00:09:05.110 --> 00:09:10.719 
important. It means especially SMS is

121
00:09:10.720 --> 00:09:15.849 
dependent on partly the high level qualifier,

122
00:09:15.850 --> 00:09:21.249 
but the most important part of a dataset is a low level qualifier,

123
00:09:21.250 --> 00:09:24.279 
the last level of these datasets.

124
00:09:24.280 --> 00:09:28.749 
And just to give you an example, cobol, once again,

125
00:09:28.750 --> 00:09:33.729 
this example, cobol is a data class

126
00:09:33.730 --> 00:09:37.419 
assigned DCP of 80 means.

127
00:09:37.420 --> 00:09:42.069 
This is a data class. This is a partitioned dataset, and it

128
00:09:42.070 --> 00:09:46.209 
has fixed log records with record length of 80.

129
00:09:46.210 --> 00:09:49.089 
This is just a naming convention.

130
00:09:49.090 --> 00:09:52.900 
And the SMS afterwards

131
00:09:54.520 --> 00:09:59.289 
manages this dataset as cobol source code.

132
00:09:59.290 --> 00:10:03.789 
And in this case, the logical record lengths

133
00:10:03.790 --> 00:10:05.769 
as example is 80.

134
00:10:05.770 --> 00:10:08.908 
We have other examples here CNTL is for JCL.

135
00:10:10.450 --> 00:10:14.949 
It's a ESDS dataset. It's a header file, for

136
00:10:14.950 --> 00:10:19.239 
example, C language code.

137
00:10:19.240 --> 00:10:24.819 
It's a LIST file and with LOAD* means

138
00:10:24.820 --> 00:10:29.499 
everything within last table qualifier beginning with load is detailed

139
00:10:29.500 --> 00:10:33.789 
as a load library with special assignments and so on.

140
00:10:37.120 --> 00:10:42.129 
ISMF is a component that is an extension on implementation

141
00:10:42.130 --> 00:10:47.169 
of an ISPF environment,

142
00:10:47.170 --> 00:10:52.519 
so we have interactive ISPF menu system

143
00:10:52.520 --> 00:10:57.609 
that makes storage management really quite easy.

144
00:10:57.610 --> 00:11:00.309 
Information about dataset and volumes.

145
00:11:00.310 --> 00:11:04.419 
You can create listings with special criteria.

146
00:11:04.420 --> 00:11:08.049 
You can delete data sets and backup copies.

147
00:11:08.050 --> 00:11:10.509 
You can the control of migration.

148
00:11:10.510 --> 00:11:15.459 
And much more important, of course, of recall of data.

149
00:11:15.460 --> 00:11:19.959 
You can request back ups whenever you want and you can request

150
00:11:19.960 --> 00:11:22.059 
recovery and so on.

151
00:11:24.640 --> 00:11:29.518 
This was a videoclip for SMS and the automatic class

152
00:11:29.519 --> 00:11:34.179 
selection idea. If you have any questions, if you have any remarks,

153
00:11:34.180 --> 00:11:39.579 
please use the forum on the openHPI platform.

154
00:11:39.580 --> 00:11:44.319 
Thanks a lot for attending and see you on one of our next video

155
00:11:44.320 --> 00:11:45.320 
clips.
