WEBVTT

1
00:00:01.100 --> 00:00:04.400 
The idea that we want,
that I want to point out

2
00:00:04.400 --> 00:00:08.800 
with this slide is
that blockchain is not

3
00:00:08.800 --> 00:00:13.130 
a new technology in the sense that
there is something technologically

4
00:00:13.130 --> 00:00:16.160 
new, but that it's a combination
of already existing technologies

5
00:00:17.170 --> 00:00:20.200 
and maybe it is interesting to
illustrate how these work together

6
00:00:20.200 --> 00:00:24.240 
in order to create an algorithmic
solution to the problem setting

7
00:00:24.240 --> 00:00:29.290 
that we described. If we assume
that we have a central database

8
00:00:29.290 --> 00:00:32.320 
where we have this kind of
transaction data that we want to

9
00:00:32.320 --> 00:00:37.370 
have for a transfer
of digital ownership

10
00:00:37.370 --> 00:00:42.420 
basically. We have signed
data on this database

11
00:00:42.420 --> 00:00:45.450 
then we still have a single point
of failure due to the single

12
00:00:45.450 --> 00:00:49.490 
database, we have a database
admin that might change

13
00:00:49.490 --> 00:00:53.530 
data on the database.
The latter can be

14
00:00:54.540 --> 00:00:59.590 
changed or we can complicate
things by actually grouping these

15
00:00:59.590 --> 00:01:02.620 
transactions to block and hashing
them with the hash pointers

16
00:01:02.620 --> 00:01:06.660 
as we discussed. Now
if you have a given

17
00:01:07.670 --> 00:01:10.700 
chain of these
blocks, hash blocks

18
00:01:11.710 --> 00:01:14.740 
you can easily spot if someone
changes a transaction because

19
00:01:14.740 --> 00:01:19.790 
the hash chain is broken. We
are better than just having

20
00:01:19.790 --> 00:01:22.820 
the transactions that can be
individually changed because now

21
00:01:22.820 --> 00:01:25.850 
they basically have to rewrite
whole chunks of the history.

22
00:01:26.860 --> 00:01:28.880 
Still we have a single
point of failure

23
00:01:29.890 --> 00:01:34.940 
and usually we might want
to go to a distributed

24
00:01:34.940 --> 00:01:37.970 
database that has desirable
properties. There is

25
00:01:37.970 --> 00:01:41.101 
no single point of failure anymore,
maybe even better scalability

26
00:01:41.101 --> 00:01:45.105 
and then the whole system
is replicated among

27
00:01:45.105 --> 00:01:48.108 
the different nodes of
this distributed database.

28
00:01:49.109 --> 00:01:54.114 
This is already an
interesting concept

29
00:01:54.114 --> 00:01:59.119 
for certain use cases, but still
it assumes that within standard

30
00:01:59.119 --> 00:02:01.121 
implementations of
distributed databases

31
00:02:01.121 --> 00:02:05.125 
all the nodes work together
to solve this multi concurrent

32
00:02:05.125 --> 00:02:10.130 
write problem, or at least let's
say a big fraction of the nodes.

33
00:02:11.131 --> 00:02:15.135 
Now if we go to a scenario, as we
said, that these machines are actually

34
00:02:15.135 --> 00:02:18.138 
hosted by different
companies that want to

35
00:02:18.138 --> 00:02:22.142 
compete around the write access:
the different companies have

36
00:02:22.142 --> 00:02:25.145 
an interest in
manipulating the data, then

37
00:02:26.146 --> 00:02:29.149 
the algorithms that we use here
usually cannot be used any more

38
00:02:30.150 --> 00:02:35.155 
and here in this scenario we
do not have a decentralized

39
00:02:35.155 --> 00:02:40.160 
database admin anymore. We
have different systems working

40
00:02:40.160 --> 00:02:44.164 
together according to the
protocol but nobody has access to

41
00:02:44.164 --> 00:02:48.168 
the other systems and in this
scenario where you have the trust

42
00:02:48.168 --> 00:02:53.173 
border moved from your
organization and still

43
00:02:53.173 --> 00:02:57.177 
you want to have a single,
agreed upon consensus state

44
00:02:57.177 --> 00:03:02.182 
then the outlined idea of block
chain provides an algorithmic

45
00:03:02.182 --> 00:03:07.187 
solution that allows
to find a consensus

46
00:03:09.189 --> 00:03:12.192 
and solve this
competing write problem.

47
00:03:15.195 --> 00:03:19.199 
Now if we design a system,
we face some engineering

48
00:03:19.199 --> 00:03:22.202 
tradeoffs and
one I want to

49
00:03:23.203 --> 00:03:29.209 
illustrate here. If we
design it we want to

50
00:03:29.209 --> 00:03:35.215 
achieve consistency on the data
and decentralization of the

51
00:03:35.215 --> 00:03:38.218 
system and scalability for
large scale application.

52
00:03:39.219 --> 00:03:42.222 
What does it mean? If we talk
about consistency we might have

53
00:03:42.222 --> 00:03:45.225 
a system where everybody can
just write and we do not care

54
00:03:45.225 --> 00:03:47.227 
whether the state
is consistent or not

55
00:03:48.228 --> 00:03:52.232 
or we have a strong eventual
consistency which could be described

56
00:03:52.232 --> 00:03:55.235 
as merge consistency.
If you want to merge

57
00:03:55.235 --> 00:03:58.238 
your data, there will be no
conflict or you have a fully

58
00:03:59.239 --> 00:04:02.242 
consistent system where
everybody sees the same

59
00:04:02.242 --> 00:04:06.246 
data or an error. In order to
avoid the double spent problem

60
00:04:06.246 --> 00:04:07.247 
you need to be here.

61
00:04:09.249 --> 00:04:13.253 
Now we want also to have a
decentralized system because

62
00:04:14.254 --> 00:04:18.258 
in the blockchain application
scenario we do not have a centralized

63
00:04:18.258 --> 00:04:21.261 
party that everybody trusts. Now
instead of having a centralized

64
00:04:21.261 --> 00:04:24.264 
system we might go to
consortium where we have known

65
00:04:24.264 --> 00:04:29.269 
players and permission systems
or we are in the public full

66
00:04:29.269 --> 00:04:31.271 
decentralization where
everybody can participate.

67
00:04:32.272 --> 00:04:35.275 
Then we have scalability
which has dimensions like

68
00:04:36.276 --> 00:04:40.280 
network size latency
and throughput and

69
00:04:40.280 --> 00:04:45.285 
if we look at these tradeoffs there
are basically different technological

70
00:04:45.285 --> 00:04:49.289 
alternatives where the classical
public block chains are just

71
00:04:49.289 --> 00:04:53.293 
one option because they are
consistent and decentral in a way.

72
00:04:53.293 --> 00:04:56.296 
There are other options
like for example Bigchain DB

73
00:04:56.296 --> 00:05:00.300 
which is a startup from
Berlin and they have

74
00:05:00.300 --> 00:05:03.303 
a lesser degree of
decentralization, because they use a

75
00:05:04.304 --> 00:05:07.307 
distributed database
as a starting point

76
00:05:08.308 --> 00:05:14.314 
but they are scaleable. Now
in this trade off you have to

77
00:05:14.314 --> 00:05:16.316 
look at your use case and
see how much trust is there

78
00:05:17.317 --> 00:05:20.320 
and how scalable do you want
to be and the permission block

79
00:05:20.320 --> 00:05:23.323 
chains that we will
discuss are kind of

80
00:05:24.324 --> 00:05:29.000 
a bit more scalable, a
bit less decentralised.

81
00:05:31.331 --> 00:05:35.335 
Blockchain provides a
platform on which we can

82
00:05:35.335 --> 00:05:38.338 
build different types of
applications so we have this property

83
00:05:38.338 --> 00:05:42.342 
that we have a disintermediation of
trust as we said, it's a decentralized

84
00:05:42.342 --> 00:05:45.345 
setting. We have
immutability of record

85
00:05:46.346 --> 00:05:48.348 
because we have this hash
chain and it's easy to

86
00:05:49.349 --> 00:05:51.351 
check the tempering
of the data

87
00:05:52.352 --> 00:05:55.355 
and we have smart contracts
and cryptocurrencies.

88
00:05:55.355 --> 00:06:00.360 
The use case we discussed
is just one use case

89
00:06:00.360 --> 00:06:03.363 
of these, or one combination
of these features.

90
00:06:04.364 --> 00:06:10.370 
Now there are many
more from various

91
00:06:10.370 --> 00:06:13.373 
disciplines, I will not
go into too much detail

92
00:06:13.373 --> 00:06:17.377 
here but you can have an
arbitrary combination of these

93
00:06:17.377 --> 00:06:24.384 
properties and define
insurance cases or you can

94
00:06:24.384 --> 00:06:28.388 
have IOT cases
or supply chain

95
00:06:29.389 --> 00:06:33.393 
applications by combining
these properties of

96
00:06:34.394 --> 00:06:38.398 
the blockchain platform as such.
There is a lot of multi-party

97
00:06:38.398 --> 00:06:41.401 
corporations going on and
as we saw with international

98
00:06:42.402 --> 00:06:46.406 
money transfer they are
long chains of trust

99
00:06:46.406 --> 00:06:49.409 
where there could be possible
conflicts about what the

100
00:06:50.410 --> 00:06:54.414 
state of the process of
the business contract is.

101
00:06:54.414 --> 00:06:57.417 
Where we have information
imbalance and if we

102
00:06:57.417 --> 00:07:01.421 
have this shared consensus
state then we can

103
00:07:02.422 --> 00:07:08.428 
agree on this
state and we reduce

104
00:07:09.429 --> 00:07:12.432 
the problem of agreeing
what the state of our

105
00:07:12.432 --> 00:07:16.436 
interaction is because whatever
is on the block chain is defined

106
00:07:16.436 --> 00:07:21.441 
as the state and this can
reduce time and costs of

107
00:07:21.441 --> 00:07:25.445 
ongoing processes
that will reduce

108
00:07:25.445 --> 00:07:29.449 
risk and fraud because it's
transparent and auditible to

109
00:07:29.449 --> 00:07:33.453 
everyone that takes
part. We can transact

110
00:07:34.454 --> 00:07:38.458 
digital representations of assets
or monitor business process

111
00:07:38.458 --> 00:07:40.460 
execution,
inter-company.

112
00:07:42.462 --> 00:07:45.465 
There is a word of
caution of course.

113
00:07:45.465 --> 00:07:50.470 
That is important. What makes
a good blockchain useÂ case?

114
00:07:50.470 --> 00:07:56.476 
If we have many write transactions
by many different parties

115
00:07:56.476 --> 00:07:59.479 
that do not trust each other,
so that's what we discussed,

116
00:07:59.479 --> 00:08:04.484 
then we are in a setting

117
00:08:04.484 --> 00:08:08.488 
like a trust-less environment
where we can not agree who runs

118
00:08:08.488 --> 00:08:12.492 
the system, who determines
the rules, no single identity

119
00:08:12.492 --> 00:08:16.496 
or party can do that.

120
00:08:16.496 --> 00:08:20.500 
Then the question arises
who may write at what

121
00:08:20.500 --> 00:08:25.505 
time and what is a valid write
access. We want to have a true

122
00:08:25.505 --> 00:08:28.508 
immutability of the
transactions without

123
00:08:30.510 --> 00:08:34.514 
having a central party and
only of all these aspects apply

124
00:08:35.515 --> 00:08:40.520 
we have a blockchain use case.
Now if one of these does not

125
00:08:40.520 --> 00:08:44.524 
apply then this is
putting it a bit hard,

126
00:08:44.524 --> 00:08:48.528 
there are other options,
technological options

127
00:08:49.529 --> 00:08:52.532 
that do not pay the price that we
have to pay if we use blockchain.

128
00:08:52.532 --> 00:08:56.536 
Blockchain solves
a very complicated

129
00:08:57.537 --> 00:09:01.541 
problem and we pay a
high price for this,

130
00:09:01.541 --> 00:09:05.545 
so if we do not have to
solve this problem because

131
00:09:05.545 --> 00:09:08.548 
one of these conditions doesn't
apply, we better use another

132
00:09:08.548 --> 00:09:10.550 
technology that doesn't
have the high price.

133
00:09:11.551 --> 00:09:15.555 
We talked about what block chain
actually what kind of terminology

134
00:09:15.555 --> 00:09:19.559 
we are actually talking about,
decentralization, the different

135
00:09:19.559 --> 00:09:22.562 
dimensions, architectural,
political decentralization.

136
00:09:22.562 --> 00:09:24.564 
What kind of trust we are
actually talking about.

137
00:09:25.565 --> 00:09:28.568 
We introduce cryptocurrencies,
the cryptography

138
00:09:28.568 --> 00:09:31.571 
that we need in order to
design the cryptocurrency

139
00:09:31.571 --> 00:09:35.575 
and the consensus algorithm that
we have in an open permission with

140
00:09:35.575 --> 00:09:38.578 
blockchain. We had a
look at the architectural

141
00:09:38.578 --> 00:09:43.583 
concept of blockchains where we
sketched some application scenarios

142
00:09:43.583 --> 00:09:45.585 
and talked about engineering
tradeoffs that we face or that

143
00:09:45.585 --> 00:09:49.589 
we have. I gave a brief
business point of view

144
00:09:49.589 --> 00:09:53.593 
on this topic and discussed
the value drivers and

145
00:09:53.593 --> 00:09:58.598 
where we should be careful if we
consider use cases to be blockchain

146
00:09:58.598 --> 00:10:03.603 
or not. With this probably
we go to questions.
