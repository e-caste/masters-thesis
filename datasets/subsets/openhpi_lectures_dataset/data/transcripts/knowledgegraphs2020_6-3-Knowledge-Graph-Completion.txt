WEBVTT

1
00:00:00.820 --> 00:00:04.970 
This is knowledge graphs lecture six
advanced knowledge graph applications.

2
00:00:05.200 --> 00:00:09.130 
So in this lecture we are going to talk
about knowledge graph completion.

3
00:00:10.920 --> 00:00:16.730 
So now the point is we have to know how
complete are the knowledge graphs. So

4
00:00:17.020 --> 00:00:21.510 
let's do it with the help of a query
between DBpedia and wikidata.

5
00:00:22.080 --> 00:00:27.410 
So let's check whether all
climatologists in DBpedia are labelled

6
00:00:27.620 --> 00:00:32.110 
the similar like they are also labelled
as climatologists in wikidata.

7
00:00:32.820 --> 00:00:37.250 
So for this reason we will use this
service command for a service

8
00:00:37.250 --> 00:00:42.450 
clause for giving the endpoints
of both the data sets that

9
00:00:42.450 --> 00:00:47.900 
you have already studied before. So
this query actually extracts the

10
00:00:48.440 --> 00:00:52.850 
the people who are typed as
climatologists in DBpedia and

11
00:00:52.850 --> 00:00:58.290 
checks against wikidata if they exist
there as climatologists or not.

12
00:00:58.740 --> 00:01:01.960 
So let's try to run
this query online.

13
00:01:03.110 --> 00:01:07.770 
So here are the results of this query
which you see already not too many.

14
00:01:08.480 --> 00:01:13.820 
So here you can actually see
that we have got fifteen

15
00:01:13.990 --> 00:01:16.980 
fifteen climatologists
which are missing.

16
00:01:17.450 --> 00:01:23.560 
So this actually supports the fact
that knowledge graphs cannot

17
00:01:24.200 --> 00:01:30.450 
reach full coverage all the time. So the
point is that knowledge graphs cannot

18
00:01:30.590 --> 00:01:35.460 
have every entity which exists
in the universe and it is

19
00:01:35.470 --> 00:01:39.410 
highly it is highly unlikely
that the knowledge graph is

20
00:01:39.410 --> 00:01:43.440 
also fully correct because in the
curation in the knowledge graphs

21
00:01:43.560 --> 00:01:47.590 
graph creation techniques we had
seen that there are methods to

22
00:01:47.750 --> 00:01:50.220 
create knowledge graphs
automatically also

23
00:01:50.660 --> 00:01:52.780 
which can create
some error also

24
00:01:53.460 --> 00:01:57.620 
in the knowledge graphs. So in
order to rectify these problems

25
00:01:57.880 --> 00:02:00.960 
we use the knowledge graph
refinement techniques.

26
00:02:01.390 --> 00:02:08.800 
So usually these proposed approaches
include deduplicating entity nodes

27
00:02:08.960 --> 00:02:13.520 
so it is a called entity resolution.
Then we have collective

28
00:02:13.520 --> 00:02:18.080 
reasoning which is probabilistic
soft logic. Then we have

29
00:02:18.080 --> 00:02:20.990 
linked prediction or knowledge
graph completion which you are

30
00:02:20.990 --> 00:02:24.820 
going to see in the course of this
lecture. And then there are

31
00:02:24.840 --> 00:02:29.470 
there is dealing with missing values
and anything else that will

32
00:02:29.680 --> 00:02:32.270 
improve the existing
knowledge graphs.

33
00:02:33.360 --> 00:02:38.700 
So now there is a difference between completion
and error detection. So in completion

34
00:02:38.950 --> 00:02:44.330 
the fact does not exist, the
triple does not exist.

35
00:02:44.340 --> 00:02:46.710 
Or you can say that the
knowledge is missing.

36
00:02:47.300 --> 00:02:53.670 
So for example you add a whole triple
Joseph Fourier has occupation physicist.

37
00:02:54.320 --> 00:02:59.770 
And the second one is error detection.
So a triple already exists

38
00:02:59.770 --> 00:03:04.030 
some knowledge already exists
which is wrong So this can be

39
00:03:04.040 --> 00:03:09.540 
done by finding the inconsistencies.
So here it says Joseph Fourier

40
00:03:09.710 --> 00:03:14.650 
is a human and then Joseph is
a fictional character. So

41
00:03:14.650 --> 00:03:19.070 
he can either be fictional
character or human and from our

42
00:03:19.070 --> 00:03:22.680 
knowledge we know that
Joseph is a human.

43
00:03:24.960 --> 00:03:28.410 
So how do we perform this knowledge
graph completion? So in

44
00:03:28.410 --> 00:03:31.280 
the previous lecture you have
seen knowledge graph embedding

45
00:03:31.280 --> 00:03:36.720 
approaches in which the knowledge graphs
are embedded into the latent spaces

46
00:03:36.970 --> 00:03:41.740 
into these vector spaces that you had a
detailed introduction to just previously.

47
00:03:42.000 --> 00:03:46.920 
And then these vector spaces these
embedding spaces can be used

48
00:03:47.230 --> 00:03:52.280 
to make inferences by learning and
operating on these vector spaces.

49
00:03:53.420 --> 00:03:59.180 
So however these embedding models
do not make use of any rules

50
00:03:59.510 --> 00:04:03.100 
during the inferencing and
have limited accuracy.

51
00:04:03.900 --> 00:04:10.260 
So let's give a brief example of such
kind of knowledge graph completion.

52
00:04:10.500 --> 00:04:15.830 
So for example you have the
entity Atsumo Omuhura

53
00:04:16.450 --> 00:04:21.750 
who has the occupation
climatologist. So here in the red

54
00:04:22.040 --> 00:04:27.690 
you see an id wd:Q111
blah blah blah.

55
00:04:28.160 --> 00:04:30.900 
This is the ID for
climatologists.

56
00:04:31.540 --> 00:04:36.490 
So here if we try to predict
this entity here, this is what

57
00:04:36.500 --> 00:04:41.890 
we call tail prediction. So what
is a tail I already explained

58
00:04:41.890 --> 00:04:46.680 
this in the last lecture where we were
talking about translational models.

59
00:04:48.410 --> 00:04:52.970 
So here are different kinds of link
prediction tasks that can be done.

60
00:04:53.290 --> 00:04:57.950 
So the first one is the triple
classification. We are given a triple

61
00:04:58.290 --> 00:05:02.670 
you try to know if it is feasible
or not or if it should this

62
00:05:02.680 --> 00:05:05.520 
triple should be is
correct or not.

63
00:05:05.960 --> 00:05:11.140 
So here you have the result, it says
yes with a score ninety five percent,

64
00:05:11.700 --> 00:05:16.610 
so which means that this is this should
be a triple in the knowledge graph.

65
00:05:17.150 --> 00:05:21.060 
Then we have tail prediction.
So in the tail prediction so

66
00:05:21.490 --> 00:05:24.500 
since you have learned
knowledge graphs with the

67
00:05:24.500 --> 00:05:29.740 
help of the terms of subject, property
and object the object is the tail

68
00:05:30.230 --> 00:05:36.460 
and then here in the tail prediction you
are looking for what entity should

69
00:05:36.560 --> 00:05:41.960 
be there in the tail. So here in this
example you see Joseph Fourier

70
00:05:42.270 --> 00:05:46.860 
occupation physicist or chemist.
So for physicist you have a

71
00:05:46.860 --> 00:05:50.480 
higher score and then chemist you
have a score point nine three.

72
00:05:50.700 --> 00:05:54.200 
So you have two possible options
or you can choose the one

73
00:05:54.200 --> 00:05:55.270 
with the highest score.

74
00:05:56.360 --> 00:06:01.000 
Then we have head prediction where
you are predicting the head

75
00:06:01.000 --> 00:06:05.950 
entity in the triple and then
given your relation and the

76
00:06:05.950 --> 00:06:10.460 
tail entity. So here you have
two options, here is the

77
00:06:10.520 --> 00:06:16.060 
algorithm generates this output. So you
have albert einstein and stephen hawking.

78
00:06:16.530 --> 00:06:21.210 
So the score are given in front
of each of these entities.

79
00:06:21.750 --> 00:06:25.540 
Then we have relation prediction.
So we are given head and tail

80
00:06:25.540 --> 00:06:30.410 
entity, we try to predict the relation.
So in this example occupation

81
00:06:30.420 --> 00:06:34.540 
and then we have entity
classification where we try to find

82
00:06:34.830 --> 00:06:40.370 
the types of entities which we
also call type prediction.

83
00:06:40.810 --> 00:06:47.510 
So you have Joseph Fourier who is a person,
human; so you have these cores for

84
00:06:47.790 --> 00:06:49.110 
these types also.

85
00:06:51.180 --> 00:06:56.090 
So we we will try to discuss a little
bit more on the type prediction. So

86
00:06:56.360 --> 00:07:01.160 
predicting a type or a
class for an entity given

87
00:07:01.160 --> 00:07:04.220 
some characteristics of the
entity. So it could be neighbour

88
00:07:04.220 --> 00:07:07.420 
and neighbouring nodes, or any
kind of characteristics that

89
00:07:07.480 --> 00:07:11.880 
we can have. It could be the description
of the entity, it can be anything.

90
00:07:12.290 --> 00:07:18.100 
However this problem actually is a very
common problem in machine learning.

91
00:07:18.420 --> 00:07:21.740 
It can be solved with that which
is known as classification.

92
00:07:22.180 --> 00:07:29.200 
So here you try to classify an entity into its
type. So there are supervised approaches

93
00:07:29.350 --> 00:07:34.090 
where type prediction can be addressed
with the help of classification

94
00:07:34.090 --> 00:07:36.330 
model based on labeled
training data.

95
00:07:37.010 --> 00:07:42.200 
So the training data usually
contains a set of entities which

96
00:07:42.210 --> 00:07:44.470 
already have some
types attached.

97
00:07:45.800 --> 00:07:50.860 
Then we have other ways of doing type
prediction - you have multi class prediction.

98
00:07:51.100 --> 00:07:54.520 
So in knowledge graphs usually
there are more than two types

99
00:07:54.520 --> 00:07:59.300 
or classes of the entities to distinguish.
For example physicist chemist or

100
00:07:59.450 --> 00:08:04.270 
climatologist. Then you have single
label classification where you

101
00:08:04.670 --> 00:08:10.350 
classify the entity into
one class or one type.

102
00:08:10.610 --> 00:08:16.970 
Then you have multi-level classification
where you have entities which allow

103
00:08:17.160 --> 00:08:21.060 
for the assignment of more than
one type. Such as here you have

104
00:08:21.060 --> 00:08:25.250 
an example - electron is a
particle, electron is a wave.

105
00:08:27.550 --> 00:08:31.960 
And then you have methods for
knowledge graph link prediction.

106
00:08:31.960 --> 00:08:35.680 
So I will take one of the methods
from the previous lecture that we

107
00:08:35.970 --> 00:08:38.860 
that we discussed. It was the
translational embeddings

108
00:08:39.380 --> 00:08:42.940 
which is with transE,
so you have of course

109
00:08:42.940 --> 00:08:46.830 
unsupervised and supervised
methods. So in transE

110
00:08:46.830 --> 00:08:51.900 
how does it happen as we saw before?
You take the vector of the subject,

111
00:08:52.160 --> 00:08:57.500 
so the head entity and the vector
of the property. So you have

112
00:08:57.500 --> 00:09:00.950 
the relation, the vector
of the relation.

113
00:09:01.470 --> 00:09:06.840 
So you when you perform addition
on the vectors of head and tail

114
00:09:07.040 --> 00:09:11.560 
you predict the, sorry the vectors
of head and the relation

115
00:09:11.560 --> 00:09:12.860 
than you predict
the tail.

116
00:09:13.470 --> 00:09:17.840 
So similarly you have some supervised
methods for the prediction.

117
00:09:18.720 --> 00:09:23.140 
So for example let's see the example
that we have been continuing

118
00:09:23.140 --> 00:09:28.880 
before. So you have for example
the vector of Joseph Fourier

119
00:09:29.070 --> 00:09:33.180 
who has an occupation. So this
is the relation and the first

120
00:09:33.190 --> 00:09:36.260 
Joseph Fourier as the head head
entity and these are the two

121
00:09:36.260 --> 00:09:41.580 
vectors of these two head and the
relation. And this way you can predict

122
00:09:41.780 --> 00:09:48.230 
the tail entity. So here it gives you
transE gives you chemist, physicist,

123
00:09:48.730 --> 00:09:53.350 
theoretical physicist and/or engineer.
So it gives you the vectors

124
00:09:53.350 --> 00:09:58.070 
of these entities. And then
it is also ranked based

125
00:09:58.070 --> 00:09:59.010 
on the scores.

126
00:10:01.510 --> 00:10:05.560 
So finally now we have concluded
the knowledge graph completion.

127
00:10:05.560 --> 00:10:09.230 
We will now move towards knowledge
graph mappings and alignment.
