WEBVTT

1
00:00:00.260 --> 00:00:04.290 
Hi. I'm Martin from the algorithm
engineering group of the Hasso

2
00:00:04.940 --> 00:00:06.120 
Plattner Institute here.

3
00:00:06.730 --> 00:00:13.410 
And I'm theoretician and that basically
means I'm trying to understand how

4
00:00:13.530 --> 00:00:17.180 
computer programs, that is
algorithms as we call them,

5
00:00:17.640 --> 00:00:22.020 
perform well on problems that are
relevant to practice. So we're

6
00:00:22.020 --> 00:00:26.210 
looking at practically motivated
problems and trying to understand

7
00:00:26.210 --> 00:00:30.770 
how certain algorithms perform
on them and why they perform

8
00:00:30.780 --> 00:00:35.480 
in a certain way. That is, we try to
analyze how well they perform

9
00:00:35.700 --> 00:00:39.360 
then to get to the core of this
performance analysis which

10
00:00:39.360 --> 00:00:42.940 
usually yields better algorithms
in the end. So technically

11
00:00:42.940 --> 00:00:46.890 
speaking, you could say, we're trying
to improve algorithms in general.

12
00:00:47.420 --> 00:00:51.020 
And today I want to present a
small result of ours to you. So

13
00:00:51.020 --> 00:00:53.630 
this is in collaboration with
Benjamin as you can see

14
00:00:54.210 --> 00:00:58.320 
on some algorithms called Randomized
Search Heuristics. This is

15
00:00:58.420 --> 00:01:02.610 
the focus of my research, basically
just some computer programs

16
00:01:02.610 --> 00:01:05.560 
that employ randomization.
So, that it's just

17
00:01:06.050 --> 00:01:10.250 
some dice rolls to get you
better results ultimately.

18
00:01:11.240 --> 00:01:15.120 
And now in order to explain what
this result is about, we first

19
00:01:15.120 --> 00:01:19.010 
need to think about what the domain
of these randomized search

20
00:01:19.010 --> 00:01:23.290 
heuristics is in the first place.
And that is the vast domain of

21
00:01:23.670 --> 00:01:27.950 
optimization. You probably know
optimization from real life.

22
00:01:27.950 --> 00:01:31.280 
So as seen in this picture, there
if you have a smartphone, I

23
00:01:31.460 --> 00:01:36.090 
guess most of you have already got some
bunch of optimization algorithms or

24
00:01:36.220 --> 00:01:39.320 
computer programs on there most
likely. Like seen in this picture,

25
00:01:39.320 --> 00:01:42.270 
for example, if you want to travel
from one point to another

26
00:01:42.490 --> 00:01:46.360 
you usually want to do so using
the fastest way possible or

27
00:01:46.370 --> 00:01:49.460 
maybe the shortest way possible.
It depends, there are different

28
00:01:49.460 --> 00:01:52.900 
priorities you can choose from
and each time you make such

29
00:01:52.900 --> 00:01:55.780 
an estimation or have such a
goal in mind where you want to

30
00:01:55.780 --> 00:01:59.730 
find the best possible solution,
you have an optimization problem.

31
00:02:00.370 --> 00:02:03.040 
And now as you can see here
in this little picture,

32
00:02:03.450 --> 00:02:08.110 
basically this is a personal scale.
So you have a problem that

33
00:02:08.110 --> 00:02:13.270 
is suited to your own desires and
that usually is kind of easy

34
00:02:13.270 --> 00:02:17.190 
to solve. So these problems usually
are of a small scale and

35
00:02:17.190 --> 00:02:22.240 
somewhat easily solvable. So they can be
done by your smartphone for example.

36
00:02:22.440 --> 00:02:26.970 
And they're also often cheap to solve.
So that means for example in this

37
00:02:27.970 --> 00:02:31.940 
car driving example, if you want
to go from one point to another

38
00:02:32.320 --> 00:02:35.590 
and you're delayed by some minutes,
that's not going to cost

39
00:02:35.590 --> 00:02:40.070 
you much or whatnot. I mean, you lost five
minutes but that's okay, overall speaking.

40
00:02:40.860 --> 00:02:45.240 
This is one regime where
optimization basically comes into

41
00:02:45.240 --> 00:02:47.760 
play for each of us in
our day to day lives.

42
00:02:48.240 --> 00:02:51.740 
Now on the other hand as you can see
there's still some space. We have a

43
00:02:51.930 --> 00:02:55.950 
vastly different domain, which is what
I want to call the industrial scale.

44
00:02:56.430 --> 00:03:00.080 
Like in this example for example
you have like tons of trucks

45
00:03:00.080 --> 00:03:03.810 
and you have all of these different
facilities. Let's just assume

46
00:03:03.810 --> 00:03:07.090 
in Germany. So these little blue
dots there and now you want

47
00:03:07.090 --> 00:03:10.400 
to distribute all of your trucks
to all of these different

48
00:03:10.400 --> 00:03:14.670 
facilities because you have some goods
or so they need to transport there.

49
00:03:14.850 --> 00:03:18.340 
And now we have to kind of route
all of these trucks in parallel,

50
00:03:18.340 --> 00:03:22.580 
so that they have a very short
time getting there and maybe

51
00:03:22.580 --> 00:03:25.500 
some of them also have to go to
multiple locations at once

52
00:03:25.920 --> 00:03:28.090 
and you kind of want to
manage all of that.

53
00:03:28.610 --> 00:03:31.830 
For example we could think of
these red lines as like some

54
00:03:31.830 --> 00:03:35.380 
idea of how such a routing network
could look like, to get all

55
00:03:35.380 --> 00:03:37.950 
of these trucks to all of
the different places.

56
00:03:38.640 --> 00:03:42.910 
And now we have some parallels to
the personal scale but usually

57
00:03:42.910 --> 00:03:46.530 
things are far more complicated
in these kinds of scenarios.

58
00:03:47.180 --> 00:03:50.980 
So on the one hand they're usually
hard. So that means that they

59
00:03:50.980 --> 00:03:55.110 
are not easily solvable by a
computer program and that is not

60
00:03:55.110 --> 00:03:59.460 
just only because they are of a
larger scale, but this is also

61
00:03:59.460 --> 00:04:02.720 
because they are intrinsically
more complicated. Like if we compare

62
00:04:02.720 --> 00:04:06.670 
these two problems we have
there, the personal scale

63
00:04:06.710 --> 00:04:10.660 
just requires you to be rooted from
one point to another whereas

64
00:04:10.660 --> 00:04:13.760 
in the industrial scale we do
not have just as many routing

65
00:04:13.760 --> 00:04:16.750 
problems as we have trucks
but there are dependencies

66
00:04:16.750 --> 00:04:20.020 
between the trucks because they
could share some roads and

67
00:04:20.020 --> 00:04:22.480 
because they also want to get
to multiple locations, maybe or whatnot.

68
00:04:23.420 --> 00:04:26.820 
So there are far more constraints
that we have to worry about

69
00:04:26.820 --> 00:04:30.890 
and usually these problems are
thus intrinsically far more hard

70
00:04:31.310 --> 00:04:35.180 
and they are also far more expensive.
Like if we could save on some

71
00:04:35.180 --> 00:04:38.890 
mileages on some of these trucks
we would save tons of money

72
00:04:38.890 --> 00:04:42.530 
whereas in the personal example, if
we just save on some kilometers

73
00:04:42.530 --> 00:04:46.480 
for just one trip or so, it's basically
not going to affect anything.

74
00:04:47.130 --> 00:04:51.590 
So the industrial scale is where
computers basically are just

75
00:04:51.590 --> 00:04:57.250 
really used to an abundance and where it
really counts to have very good algorithms.

76
00:04:57.740 --> 00:05:00.500 
And this is what we are focusing
on basically. We're trying

77
00:05:00.500 --> 00:05:04.610 
to look at these industrial scale.
So large relevant problems

78
00:05:04.930 --> 00:05:09.190 
and try to figure out how we can
improve the computer programs

79
00:05:09.510 --> 00:05:14.480 
solving these problems in order to
reduce the overall computation

80
00:05:14.480 --> 00:05:18.680 
time and that's just also save on
money and on through computation

81
00:05:18.680 --> 00:05:20.650 
expenses, for example,
as processing time.

82
00:05:22.030 --> 00:05:24.690 
And now for this
example in particular,

83
00:05:25.510 --> 00:05:28.550 
I mean, there are different approaches
of how one could tackle this,

84
00:05:28.860 --> 00:05:33.240 
usually in this case this problem
is so hard that there is no

85
00:05:33.510 --> 00:05:37.230 
known way of finding an optimal
solution within reasonable time

86
00:05:37.440 --> 00:05:41.840 
and thus one goes back to something
known as heuristics. This

87
00:05:41.840 --> 00:05:43.510 
is what we're going
to look at here.

88
00:05:44.380 --> 00:05:47.790 
This is the title of a talk basically,
and we're not going to look at

89
00:05:48.130 --> 00:05:53.210 
any heuristics, so that it's just some rule of
thumbs, but at randomized search heuristics.

90
00:05:53.610 --> 00:05:57.780 
They work in the following way: so
assume we are given this road network

91
00:05:57.950 --> 00:06:01.490 
on the bottom. So this is one
solution we already have. This

92
00:06:01.490 --> 00:06:05.250 
is our standard solution we're
working with. It's just like best

93
00:06:05.250 --> 00:06:07.810 
practice. So we're used
to that. We know how it

94
00:06:07.810 --> 00:06:11.390 
works but we feel like we could
still improve on that. And the

95
00:06:11.390 --> 00:06:16.350 
way we do so, I mean, as the name maybe suggest
randomized search heuristics is that

96
00:06:16.650 --> 00:06:19.430 
we just employ randomness.
That is we roll some

97
00:06:19.430 --> 00:06:23.210 
dice or we just make some random
decisions and as you can see

98
00:06:23.210 --> 00:06:24.510 
we now change the

99
00:06:25.680 --> 00:06:29.780 
road network with these green
edges there. So we maybe removed

100
00:06:29.780 --> 00:06:33.340 
some edges, we maybe changed some
and we also just maybe put

101
00:06:33.340 --> 00:06:37.190 
some new routes in there and we
get to an entirely new network.

102
00:06:37.620 --> 00:06:41.390 
And of course we don't only just do this
once, but we do this multiple times

103
00:06:41.630 --> 00:06:45.420 
just to keep things concise here.
We have two examples and as

104
00:06:45.420 --> 00:06:49.500 
you can see the top new solution
is different from the bottom one,

105
00:06:49.810 --> 00:06:53.210 
because we employed some randomness or
just some random variation in there

106
00:06:53.570 --> 00:06:56.040 
and now we have a bunch
of different solutions

107
00:06:56.870 --> 00:07:00.730 
that may be better or not and
we're the judges of whether this

108
00:07:00.730 --> 00:07:05.260 
is good or not. So we can just
select some of these solutions.

109
00:07:05.520 --> 00:07:08.880 
Usually we'll select probably more. In
this example we have two solutions

110
00:07:09.160 --> 00:07:12.210 
and the green arrow should indicate
that we're taking the top solution.

111
00:07:12.490 --> 00:07:16.420 
So our user guided selection. So
our intuition or our knowledge

112
00:07:16.500 --> 00:07:20.260 
of what a good road network looks
like tells us that we would

113
00:07:20.260 --> 00:07:24.290 
prefer the top one over the bottom
one. And this is why we would then

114
00:07:24.430 --> 00:07:28.290 
use this new road network basically
as a new foundation and

115
00:07:28.290 --> 00:07:31.010 
then we repeat this process and
basically cross our fingers

116
00:07:31.010 --> 00:07:34.530 
that everything works out, that we
get a very good road network.

117
00:07:34.740 --> 00:07:38.880 
So ultimately we have a loop in
this process overall. And this

118
00:07:38.880 --> 00:07:42.510 
is what constitutes a randomized
search heuristic. So basically

119
00:07:42.510 --> 00:07:46.250 
just some luck and just some
rules of thumb that try to get

120
00:07:46.250 --> 00:07:49.270 
us forward and forward to better
and better solutions ultimately.

121
00:07:50.640 --> 00:07:54.480 
This is the general outline. So now
if you recall, I said initially

122
00:07:54.480 --> 00:07:59.040 
that I'm a theoretician and that
is we analyze these things,

123
00:07:59.040 --> 00:08:02.350 
so these behaviors, these algorithms
with mathematical rigor.

124
00:08:02.990 --> 00:08:06.040 
So you can think of this in the
following way in the context

125
00:08:06.040 --> 00:08:09.590 
of randomize search heuristics -
there are basically two main

126
00:08:09.590 --> 00:08:13.250 
factors that come into play. On one
hand side we have the randomness,

127
00:08:13.250 --> 00:08:17.510 
on the other side we have this user
guidance. So it was this selection

128
00:08:17.510 --> 00:08:21.270 
that we made in the end. As I
said before, the selection was

129
00:08:21.270 --> 00:08:25.990 
with respect to our choice. So
basically what we prefer and

130
00:08:25.990 --> 00:08:29.510 
we may not be able to actually
model this mathematically. Maybe

131
00:08:29.510 --> 00:08:33.290 
we are, if so maybe we are capable
of employing better strategies

132
00:08:33.290 --> 00:08:35.050 
than these randomized
search heuristics,

133
00:08:35.550 --> 00:08:38.380 
but maybe we don't and we
just can tell, don't know,

134
00:08:39.140 --> 00:08:43.040 
just feeling of our guts, so
which solution we prefer and

135
00:08:43.040 --> 00:08:47.510 
this is why we model this
basically as a black box. This is

136
00:08:47.510 --> 00:08:50.990 
why you see this black box. This
f just tells us there is some

137
00:08:51.010 --> 00:08:55.370 
underlying principle. So maybe some
mathematical foundation to this problem

138
00:08:55.620 --> 00:09:00.560 
but the algorithm itself is not
capable of seeing that. It does

139
00:09:00.560 --> 00:09:03.670 
not know what we prefer or what
not and this is where this

140
00:09:03.670 --> 00:09:07.780 
black box comes into play in this user
guide. And so we try to communicate

141
00:09:08.240 --> 00:09:10.830 
our feeling to the
computer program.

142
00:09:11.640 --> 00:09:14.390 
And this is on the other side
basically. The computer program

143
00:09:14.390 --> 00:09:19.480 
does all of these random choices and tries
to basically propose better solutions

144
00:09:19.880 --> 00:09:23.440 
to us so that we can
make some estimated

145
00:09:23.860 --> 00:09:27.920 
wise choices of what solutions
may be better and of course,

146
00:09:27.950 --> 00:09:30.670 
I mean, if we see there are some
dice but usually the randomness

147
00:09:30.670 --> 00:09:33.210 
employed is far
more complex or

148
00:09:35.250 --> 00:09:38.730 
better suited to making better
decisions ultimately. And there

149
00:09:38.730 --> 00:09:41.850 
is a connection between these two
things in the end. So on the

150
00:09:41.850 --> 00:09:45.610 
one hand side we have like the
algorithm that makes the random

151
00:09:45.610 --> 00:09:49.580 
decisions and makes some suggestions
of some solutions, on the other

152
00:09:49.850 --> 00:09:54.340 
side we have like this black box - us,
the decision maker who wants to

153
00:09:54.720 --> 00:09:57.460 
kind of decide what solutions
are the ones to keep.

154
00:09:57.900 --> 00:10:02.320 
And the theory kind of tries to
understand this interaction

155
00:10:02.320 --> 00:10:03.990 
between these
two concepts.

156
00:10:04.630 --> 00:10:08.900 
And this is where the result that I'm
going to present you then basically

157
00:10:09.050 --> 00:10:12.580 
lies there. So in this intersection
between these two things how

158
00:10:12.580 --> 00:10:14.930 
does the method and
the user guidance

159
00:10:15.790 --> 00:10:17.210 
play off of one another?

160
00:10:17.940 --> 00:10:21.670 
And to illustrate this, of course
like theoretically we would

161
00:10:21.670 --> 00:10:26.050 
model some kind of user guidance.
So the algorithm does not

162
00:10:26.050 --> 00:10:29.130 
know what's happening in this
black box. When we perform the

163
00:10:29.130 --> 00:10:33.310 
analysis, we know what's happening
and I basically use some

164
00:10:33.310 --> 00:10:35.830 
metaphors to
explain how

165
00:10:36.600 --> 00:10:37.790 
you could think of this.

166
00:10:38.640 --> 00:10:42.420 
So imagine you're in this industrial
process and you have a pipeline.

167
00:10:42.890 --> 00:10:46.390 
A pipeline consists of different
sections and each section

168
00:10:46.390 --> 00:10:49.180 
does something with your product
and in the end you want to

169
00:10:49.180 --> 00:10:51.240 
end up with a very
good product.

170
00:10:51.840 --> 00:10:55.750 
And all that you can do is like
press some switches or some

171
00:10:55.750 --> 00:10:57.830 
levers or whatnot in
this control panel.

172
00:10:58.410 --> 00:11:01.210 
And now if you're like me, I have no
clue how this pipeline works. So

173
00:11:01.210 --> 00:11:05.990 
this is this control panel basically
is a black box to me. I can

174
00:11:06.170 --> 00:11:10.580 
push some switches or whatnot, play around
with it and this effects the pipeline

175
00:11:10.790 --> 00:11:14.150 
and I can see what effect it has
on the pipeline. But I have

176
00:11:14.150 --> 00:11:18.590 
no clue how these things actually
connect. So basically what

177
00:11:18.590 --> 00:11:22.280 
I'm going to do, assuming that I
cannot destroy anything, I just

178
00:11:22.280 --> 00:11:25.380 
play around with the control
panel and figure out piece by

179
00:11:25.380 --> 00:11:29.030 
piece of how to get this pipeline
working such that it is like in a

180
00:11:29.390 --> 00:11:32.490 
very good state. Let's say like
an optimal state ultimately.

181
00:11:33.650 --> 00:11:38.190 
So this is how you can think
of how to model this concept.

182
00:11:38.750 --> 00:11:43.950 
And now is theoreticians when performing
analysis on this kind of abstract model,

183
00:11:44.140 --> 00:11:49.050 
we can think of different modes of operation
of how this control panel actually

184
00:11:49.690 --> 00:11:53.470 
acts on this pipeline. I myself
when I'm pressing the switches

185
00:11:53.470 --> 00:11:56.540 
have no clue how it works but of
course the control panel itself

186
00:11:56.540 --> 00:12:00.240 
has some underlying logic of how
it influences the pipeline.

187
00:12:00.700 --> 00:12:04.900 
And in this example we're just thinking
of two different modes of operation

188
00:12:05.170 --> 00:12:08.590 
and the first one that comes to
mind probably is that all of

189
00:12:08.610 --> 00:12:11.790 
these sections are independent. We
have these different sections

190
00:12:11.790 --> 00:12:15.040 
of the pipeline and each of them
has like some switches or

191
00:12:15.040 --> 00:12:18.360 
levers or whatnot on the control
panel and just manipulating

192
00:12:18.360 --> 00:12:21.060 
one section has no effect
on the other sections.

193
00:12:21.500 --> 00:12:23.940 
As you can see in this little
picture there, if you're familiar

194
00:12:23.940 --> 00:12:27.710 
with the game mastermind, basically
this is the same thing you're

195
00:12:27.710 --> 00:12:32.060 
doing there. So there's one player coming
up with like code of four colours,

196
00:12:32.270 --> 00:12:36.450 
and the other player tries to figure out the
code by constantly making some guesses.

197
00:12:36.730 --> 00:12:40.050 
And the first player then gives
some feedback in form of whether

198
00:12:40.050 --> 00:12:43.340 
the colours are correct or whether they're
at the correct position or what not.

199
00:12:43.570 --> 00:12:46.540 
So this is kind of the same
metaphor going on here.

200
00:12:47.500 --> 00:12:51.950 
Now, for the second mode of operation,
of course the counterpart

201
00:12:51.950 --> 00:12:56.580 
that is we have dependent sections.
Meaning, while we see that

202
00:12:56.580 --> 00:13:00.680 
some switches do something with
some section of the pipeline,

203
00:13:00.890 --> 00:13:03.620 
now if we press another switch
or another lever or what not,

204
00:13:03.620 --> 00:13:07.440 
we may also affect other parts
of the pipeline. So that is we

205
00:13:07.440 --> 00:13:11.510 
do not have this clean separation
anymore but everything can affect

206
00:13:11.690 --> 00:13:15.240 
everything else. So, we are in
highly dependent state and this

207
00:13:15.240 --> 00:13:18.440 
intuitively makes things
much more complicated.

208
00:13:19.330 --> 00:13:23.660 
Now usually one considers like
a certain bounded degree of

209
00:13:23.680 --> 00:13:27.310 
complexity, which I'm not going
to go into detail here, but

210
00:13:27.790 --> 00:13:33.190 
basically the kind of depth we're
looking at is limited in how

211
00:13:33.370 --> 00:13:37.160 
much interaction we can have between
all of these different switches

212
00:13:37.410 --> 00:13:41.360 
and levers in this pipeline. And
as a picture here, what you

213
00:13:41.360 --> 00:13:44.830 
see down there is kind of try
to sketch a schedule how you

214
00:13:44.830 --> 00:13:49.490 
can think of these dependent section with
respect to some real world problem also,

215
00:13:49.690 --> 00:13:52.950 
where you have like tons of
different employees with different

216
00:13:52.950 --> 00:13:56.120 
jobs that you want to schedule
like a large time frame

217
00:13:56.540 --> 00:13:59.670 
and usually you want to start at
the beginning because if you

218
00:13:59.670 --> 00:14:04.110 
schedule the middle and then you see, okay,
something changes at the beginning,

219
00:14:04.400 --> 00:14:07.860 
then this just overthrows all of
your plans for the middle and

220
00:14:07.860 --> 00:14:11.470 
you have to start all over again. So
this is kind of the dependency

221
00:14:11.470 --> 00:14:14.870 
that's going on there where like
parts that happen later on

222
00:14:14.870 --> 00:14:17.680 
in the process are dependent on
parts that happened earlier

223
00:14:17.680 --> 00:14:18.590 
in the process.

224
00:14:20.690 --> 00:14:25.980 
And now, this was a metaphor. So these
things are also mathematically modeled

225
00:14:26.590 --> 00:14:30.060 
differently of course in the context
of the theoretical analysis

226
00:14:30.060 --> 00:14:33.370 
will render my search heuristics
and this is also the domain

227
00:14:33.370 --> 00:14:36.110 
where our results come
into play ultimately.

228
00:14:36.650 --> 00:14:40.550 
So before hand, so the traditional
approaches, basically the

229
00:14:40.550 --> 00:14:45.390 
way of how you roll dice, these established
computer programs or algorithms,

230
00:14:45.610 --> 00:14:48.880 
have the following run-
times. Now what that means:

231
00:14:49.350 --> 00:14:53.630 
basically the number of operations
they take until they find

232
00:14:53.750 --> 00:14:57.910 
a solution of a sufficiently good
quality, let's just assume optimal here.

233
00:14:58.490 --> 00:15:02.710 
And this theta is in front
of these symbols, so this Greek

234
00:15:02.710 --> 00:15:05.880 
letter basically just tells
us the order of magnitude.

235
00:15:06.780 --> 00:15:11.250 
"n" in this case is always the number
of sections of the pipeline

236
00:15:11.260 --> 00:15:15.010 
if we want to think of it this
way. So basically we can see,

237
00:15:15.010 --> 00:15:18.760 
okay, the complexity with respect
to how long the pipeline is.

238
00:15:18.780 --> 00:15:21.920 
Of course the longer the pipeline
is so the more sections we have

239
00:15:22.250 --> 00:15:25.260 
the more operations it's going
to take us until we figure out

240
00:15:25.260 --> 00:15:28.410 
all the right combinations to press
for the pipeline to work out,

241
00:15:28.910 --> 00:15:31.900 
but there may be different
complexities of how long this takes.

242
00:15:32.250 --> 00:15:36.720 
We can see here, these are
these two usual run- times or

243
00:15:36.720 --> 00:15:39.650 
complexity results you would
get. There are some approaches

244
00:15:39.650 --> 00:15:42.410 
that are better for one problem
but then they're worse for

245
00:15:42.410 --> 00:15:46.040 
the other problem and this is what
most of the approaches have

246
00:15:46.050 --> 00:15:50.920 
is typical run times. Now, since
the approaches are randomized,

247
00:15:50.960 --> 00:15:54.980 
of course these are not deterministic run
times these are the expected run times, so

248
00:15:55.670 --> 00:16:00.790 
kind of the expected number of operations
until you find the optimal solution.

249
00:16:01.160 --> 00:16:05.890 
And they also usually hold with high
probability. So that means the probability

250
00:16:06.110 --> 00:16:10.530 
of the run time being far higher or
far lower than what's given there is

251
00:16:10.710 --> 00:16:13.930 
basically negligible. So that's
almost never going to happen.

252
00:16:15.220 --> 00:16:19.010 
Now of course so this is the
traditional approach, it's our approach.

253
00:16:19.010 --> 00:16:23.020 
In contrast we improved on
that. So as you can see

254
00:16:23.670 --> 00:16:27.760 
for the first independent section
part we did not really improve

255
00:16:27.770 --> 00:16:31.940 
because this is kind of a tight
result given the way of how

256
00:16:31.940 --> 00:16:35.430 
you model information but basically
you cannot really improve

257
00:16:35.430 --> 00:16:39.540 
on this analog. And most of the
cases. However, where we improve

258
00:16:39.550 --> 00:16:43.610 
is in the bottom part. So now
beforehand you had some solvers

259
00:16:43.610 --> 00:16:47.670 
that had different run times depending on
how the control panel actually looks like.

260
00:16:48.020 --> 00:16:51.690 
So, again going back to the metaphor,
when I'm pressing the switches

261
00:16:52.130 --> 00:16:57.100 
I could employ the same strategy
but depending on how the controls

262
00:16:57.100 --> 00:17:00.360 
are really wired to the pipeline,
I would end up with different

263
00:17:00.360 --> 00:17:03.590 
results if I would follow the
traditional approach. Now where

264
00:17:03.590 --> 00:17:07.370 
is if you follow our approach? So
this new algorithm basically

265
00:17:07.550 --> 00:17:11.370 
you would always end up with
roughly the same run time, meaning

266
00:17:11.370 --> 00:17:15.240 
you can employ the same schemes
of operation and for different

267
00:17:15.240 --> 00:17:18.300 
problems like these two different
parts - the independent and

268
00:17:18.300 --> 00:17:21.450 
the dependent sections, you would
end up with the same run time.

269
00:17:22.160 --> 00:17:26.490 
And of course what's impressive there
is like the speedup we get between

270
00:17:26.870 --> 00:17:30.970 
for the bottom problem which I basically
want to highlight here roughly.

271
00:17:31.120 --> 00:17:36.280 
So this is roughly in the order
of n which is like the number

272
00:17:36.280 --> 00:17:40.880 
of sections of the pipeline. Just to
make things a bit more precise,

273
00:17:41.050 --> 00:17:44.610 
so assuming that we had like
thousand stages in our pipeline,

274
00:17:44.610 --> 00:17:47.100 
this would be speedup of one
hundred and forty four.

275
00:17:48.010 --> 00:17:51.110 
It may seem like one thousand is
a large number, but actually

276
00:17:51.110 --> 00:17:54.470 
for these industrial scale
problems this is a very very low

277
00:17:54.470 --> 00:17:57.300 
number. Usually this would
be far higher like

278
00:17:57.840 --> 00:18:00.710 
the one hundred thousand or
millions or even higher. So this

279
00:18:00.710 --> 00:18:03.110 
meet up would of course
increase then even more.

280
00:18:03.550 --> 00:18:06.190 
This is just like one
industry example.

281
00:18:07.050 --> 00:18:09.830 
To make sense of what
this actually means,

282
00:18:10.250 --> 00:18:14.300 
if the original times with the
traditional approach would take

283
00:18:14.300 --> 00:18:19.490 
you one day to figure out how to
construct this pipeline to work well,

284
00:18:19.700 --> 00:18:24.390 
with our new approach that would only
take ten minutes overall. That's

285
00:18:24.820 --> 00:18:26.560 
quite an impressive
gain there.

286
00:18:28.100 --> 00:18:32.520 
And that's basically how our
result works and how it improves

287
00:18:32.620 --> 00:18:37.610 
and this was our way of how we
hopefully improve the world

288
00:18:37.610 --> 00:18:41.400 
to be a bit more cleaner
and better. Thank you.
