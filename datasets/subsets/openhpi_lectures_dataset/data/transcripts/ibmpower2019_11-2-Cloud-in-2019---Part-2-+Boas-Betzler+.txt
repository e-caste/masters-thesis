WEBVTT

1
00:00:00.430 --> 00:00:05.220 
So in the next few minutes we'll further
discuss how that shared responsibility looks like

2
00:00:05.570 --> 00:00:09.040 
and what is required from
US application developer as

3
00:00:09.560 --> 00:00:16.070 
a person who operates or delivers
IT or workload or applications

4
00:00:16.200 --> 00:00:19.700 
or as someone who builds
and advises on clouds.

5
00:00:21.020 --> 00:00:26.840 
Let's first come to a couple of
different categories that help us better understand

6
00:00:27.230 --> 00:00:31.020 
the huge set of clouds that
are out there in the marketplace.

7
00:00:31.430 --> 00:00:36.280 
Now, this list is not comprehensive.
It's also not meant to be

8
00:00:36.700 --> 00:00:42.870 
a decision list on which cloud
or which choice of cloud makes

9
00:00:43.010 --> 00:00:44.970 
business or
economic sense.

10
00:00:45.920 --> 00:00:50.110 
Obviously you'll see that there is no
mention of cost or no mention of

11
00:00:50.280 --> 00:00:55.470 
function completeness or not even mention
of achievement of service level

12
00:00:55.730 --> 00:01:00.040 
agreements or quality of service in this
list here. All these would be

13
00:01:00.210 --> 00:01:04.190 
other elements that would be really
important for deciding on what cloud

14
00:01:04.420 --> 00:01:08.810 
to use for a certain workload.
But the list that I provided

15
00:01:08.810 --> 00:01:15.050 
here helps us to get our head around
what really is the fundamental difference in

16
00:01:15.430 --> 00:01:20.300 
the structure, in the architecture and
the design of different clouds.

17
00:01:21.100 --> 00:01:26.080 
First differentiation is do your own or
buy. Do I build my own cloud

18
00:01:26.180 --> 00:01:29.720 
or do I buy a
cloud service from a vendor.

19
00:01:30.450 --> 00:01:34.490 
Next differentiation is the
level of isolation.

20
00:01:34.890 --> 00:01:39.690 
Do I have strong isolation on
a physical layer that each of

21
00:01:39.890 --> 00:01:44.700 
the workload has a separated
physical element to deploy

22
00:01:44.700 --> 00:01:51.040 
or run the workload on, or do
I only provide logical isolation or maybe

23
00:01:51.470 --> 00:01:56.930 
even on a shared infrastructure
only provide isolation through encryption.

24
00:01:58.650 --> 00:02:02.340 
Level of abstraction is something
that I mentioned before. There

25
00:02:02.340 --> 00:02:07.630 
are very low level capabilities
pure infrastructure, think of compute

26
00:02:07.810 --> 00:02:12.450 
arm storage and network. There
are high level elements or

27
00:02:12.930 --> 00:02:17.170 
services that represent a platform or
then software as a service.

28
00:02:18.320 --> 00:02:20.710 
Also single ten
vs multi ten.

29
00:02:21.360 --> 00:02:24.230 
That is somewhat related to
the level of isolation

30
00:02:24.730 --> 00:02:29.580 
but there are clouds that are only
built for a single tenant or

31
00:02:29.790 --> 00:02:33.490 
there are clouds that are built
for maybe a small number of

32
00:02:33.490 --> 00:02:35.780 
tenants or users
on that cloud.

33
00:02:38.190 --> 00:02:42.830 
I did mention that a huge
value proposition of cloud is the

34
00:02:43.910 --> 00:02:46.690 
so called limitless
scalability. Of course,

35
00:02:47.140 --> 00:02:51.370 
every cloud has certain limits.
However it really matters how

36
00:02:51.370 --> 00:02:54.480 
big the resource pool is. The
bigger the resource pool typically

37
00:02:54.910 --> 00:02:59.700 
and simplified the biggest the
economy of scale and the bigger

38
00:02:59.700 --> 00:03:03.950 
is the ability to quickly scale out to
whatever the need of that workload is.

39
00:03:05.430 --> 00:03:07.810 
And what we see
emerging, I would say

40
00:03:08.430 --> 00:03:12.430 
in the last couple of years
and months, is the appearance of

41
00:03:12.700 --> 00:03:16.670 
specialized clouds. The early
typical clouds were commodity,

42
00:03:16.840 --> 00:03:22.040 
commodity infrastructure, commodity capabilities,
generalized, very standardized.

43
00:03:22.470 --> 00:03:27.270 
Now we start to see very
specialized elements in cloud, for example

44
00:03:27.470 --> 00:03:34.610 
in the form of specific compute capabilities
like GPUs, like a power architecture,

45
00:03:34.790 --> 00:03:40.350 
like mainframe system C architecture,
or like capabilities around

46
00:03:40.360 --> 00:03:45.770 
a specific scale up hardware when it
comes to very large in-memory databases.

47
00:03:47.080 --> 00:03:52.250 
Now let's apply these abstract categories to
a couple of real examples. For example,

48
00:03:52.810 --> 00:03:56.410 
in a public cloud, the picture looks
like this. As you would expect

49
00:03:57.360 --> 00:04:02.490 
the service provider to build it, so you
as a consumer would just consume

50
00:04:02.750 --> 00:04:07.110 
the services provided and already built
by that cloud service provider.

51
00:04:07.870 --> 00:04:11.210 
Typically public clouds
are there for sharing.

52
00:04:11.630 --> 00:04:13.490 
They basically have
a shared everything

53
00:04:14.040 --> 00:04:18.960 
capability and the level of
the smallest level of

54
00:04:19.500 --> 00:04:23.390 
capability that is dedicated to certain
use or to certain account

55
00:04:23.590 --> 00:04:26.360 
would be virtual machine. But
the underlying physical hardware

56
00:04:26.640 --> 00:04:29.860 
be it the bare metal or
be it the network or

57
00:04:30.360 --> 00:04:35.410 
the storage, the physical storage devices,
they are typically are not isolated

58
00:04:35.780 --> 00:04:39.630 
on a physical level but rather on
a logical and on an encryption level.

59
00:04:40.290 --> 00:04:41.910 
Now with the
level of abstraction,

60
00:04:42.520 --> 00:04:46.370 
a public cloud does provide
typically the whole spectrum of

61
00:04:46.370 --> 00:04:49.660 
abstraction down from infrastructure up
to very high level

62
00:04:49.660 --> 00:04:51.580 
services that they
do provide.

63
00:04:52.680 --> 00:04:57.770 
Focus however is, as I mentioned before on
multi tenant on a large number of tenants.

64
00:04:58.720 --> 00:05:03.290 
The pool size is very big and
that drove the adoption of cloud

65
00:05:04.030 --> 00:05:08.340 
to the very attractive price point
of cloud capabilities and that's

66
00:05:08.540 --> 00:05:12.250 
only possible with a large pool
size. And of course then you

67
00:05:12.390 --> 00:05:16.830 
have very channelized and
very standardized and commodity

68
00:05:17.350 --> 00:05:19.550 
abstraction and
capabilities there.

69
00:05:21.480 --> 00:05:24.500 
Now compare that
again to the

70
00:05:25.210 --> 00:05:32.210 
few of a typical existing enterprise
that has legacy infrastructure, maybe some

71
00:05:32.590 --> 00:05:36.820 
hardware that has a very specialized function
which has been around already for

72
00:05:37.290 --> 00:05:42.450 
ten, fifteen, twenty years. The traditional
IT which uses a maybe

73
00:05:42.450 --> 00:05:46.020 
in house data center and
deploys IT infrastructure dere

74
00:05:46.620 --> 00:05:51.240 
and that is provisioned in a manual
fashion or then a dedicated

75
00:05:51.250 --> 00:05:55.690 
on-premise cloud that provides some
level of self service that

76
00:05:55.690 --> 00:06:00.470 
has a certain concept of pooling but
that still is in the data

77
00:06:00.470 --> 00:06:04.440 
center in-house of certain enterprise.
And then we come to

78
00:06:05.120 --> 00:06:08.530 
clouds that are provided by cloud
providers that would be off-

79
00:06:08.530 --> 00:06:13.010 
premise, maybe carved off a certain
scope of that cloud or

80
00:06:13.090 --> 00:06:17.340 
a certain volume of infrastructure
for specific customers or then

81
00:06:17.670 --> 00:06:19.070 
the shared
public clouds.

82
00:06:21.170 --> 00:06:25.720 
Now to give you another
example of this dedicated on-premise

83
00:06:25.720 --> 00:06:29.470 
cloud, let's look at a
deployment of VMWare

84
00:06:30.130 --> 00:06:32.630 
in an enterprise
data center.

85
00:06:33.560 --> 00:06:37.700 
Now if we compare that back
to the different categories from

86
00:06:37.700 --> 00:06:42.070 
a self service perspective,
from a build perspective,

87
00:06:42.220 --> 00:06:48.140 
this is basically build by the IT
center or by the IT organization

88
00:06:48.140 --> 00:06:50.140 
or IT group
in that company.

89
00:06:50.740 --> 00:06:54.310 
They basically went in, took the
machines, put them down on the

90
00:06:54.310 --> 00:06:59.680 
floor of the data center, installed
the virtualization capabilities of VMWare

91
00:07:00.140 --> 00:07:05.570 
and then provided that to consumers, different
lines of businesses of that enterprise.

92
00:07:06.370 --> 00:07:08.050 
From an isolation focus,

93
00:07:08.660 --> 00:07:15.290 
there is a certain level of sharing.
Pools of hosts are shared across

94
00:07:16.060 --> 00:07:21.460 
a set of virtual machines. However
the sharing is relatively limited,

95
00:07:21.840 --> 00:07:25.890 
and often only limited to
maybe the compute element.

96
00:07:26.820 --> 00:07:29.130 
We still do see
a lot of

97
00:07:29.810 --> 00:07:33.940 
specific and dedicated network elements
that are not built

98
00:07:33.940 --> 00:07:38.340 
out of a software defined networking and the
same is true for storage as well,

99
00:07:38.470 --> 00:07:42.290 
that the storage might be very
much dedicated and and isolated

100
00:07:42.290 --> 00:07:43.310 
for a certain workload.

101
00:07:44.220 --> 00:07:47.940 
Abstraction level is slow, relatively
low. It is a representation

102
00:07:47.940 --> 00:07:49.840 
of infrastructure,
virtual machines.

103
00:07:50.540 --> 00:07:53.960 
The number of tenants
is limited as well,

104
00:07:54.510 --> 00:07:58.320 
mainly it for a single
company representing a single tenant

105
00:07:58.390 --> 00:08:02.210 
or for that matter if different
lines of businesses in that company

106
00:08:02.350 --> 00:08:07.590 
are expressed as tenants, then that small
number of tenants in the enterprise.

107
00:08:08.100 --> 00:08:15.160 
And the pools are typically sized to
the capacity of the lines of businesses

108
00:08:15.290 --> 00:08:21.090 
that require resources, namely relatively
limited set of a pool sizes.

109
00:08:22.180 --> 00:08:28.390 
I would call the specialization somewhere in
between. It's not completely generalized, although

110
00:08:28.780 --> 00:08:33.470 
virtualization in itself is
a certain generalization and

111
00:08:33.740 --> 00:08:40.100 
a certain standardization. However, the hardware
and the specific capabilities put

112
00:08:40.380 --> 00:08:44.540 
onto the data center floor
is often optimized specifically for

113
00:08:44.730 --> 00:08:47.810 
knowing the workload off
of that enterprise.

114
00:08:51.320 --> 00:08:55.080 
Compare that to what you saw
earlier with respect to public

115
00:08:55.080 --> 00:08:57.470 
cloud, you do see
quite some difference.

116
00:08:58.480 --> 00:09:04.890 
So let us go further into what is
really meant between do it yourself versus buy.

117
00:09:05.860 --> 00:09:09.610 
What is really the relationship
between a service consumer

118
00:09:09.780 --> 00:09:11.050 
and a service provider?

119
00:09:12.350 --> 00:09:17.350 
Now in this typical stack a
few what you see here on

120
00:09:18.020 --> 00:09:20.590 
the side that shows
the traditional IT

121
00:09:21.170 --> 00:09:26.830 
is the complete stack managed by a
single company where the complete stack was

122
00:09:27.320 --> 00:09:32.410 
optimized, managed, built, maybe not
by the same team but in

123
00:09:32.420 --> 00:09:35.370 
relative close collaboration
with one another.

124
00:09:36.190 --> 00:09:40.790 
Now if you move from
from that in-house IT

125
00:09:41.230 --> 00:09:45.960 
to a capability where
infrastructure as a service

126
00:09:46.520 --> 00:09:51.110 
is consumed from a cloud provider,
you see that the cloud provider

127
00:09:51.570 --> 00:09:55.830 
an outsourced or external entity
is suddenly responsible for

128
00:09:55.830 --> 00:10:00.130 
the networking, the storage, the servers
for keeping them, setting them up

129
00:10:00.310 --> 00:10:03.990 
are buying the real estate or
renting the real estate, putting

130
00:10:04.270 --> 00:10:08.580 
all those capabilities down and
even providing the virtualization.

131
00:10:08.880 --> 00:10:12.060 
The consumer or company would
still be responsible for the

132
00:10:12.060 --> 00:10:14.780 
OS middleware run-time
data and code.

133
00:10:15.840 --> 00:10:16.790 
In many cases,

134
00:10:18.480 --> 00:10:20.050 
the industry found
out that

135
00:10:21.110 --> 00:10:26.150 
these businesses do not consider it
to be their core business

136
00:10:26.150 --> 00:10:32.370 
or the core competency to manage operating
systems, to patch operating systems, to

137
00:10:32.610 --> 00:10:37.830 
keep middleware up and running. Rather,
they are looking for value

138
00:10:37.980 --> 00:10:42.260 
and for value add in the
application, in the code they provide,

139
00:10:42.410 --> 00:10:46.220 
and in the data that they
derive for add or leverage.

140
00:10:46.640 --> 00:10:49.070 
So they are moving
on to higher abstraction

141
00:10:49.850 --> 00:10:54.750 
in the pass area, in the platform
area and say, look, we would

142
00:10:54.750 --> 00:10:58.420 
like to delegate all the heavy
lifting and all the hard work

143
00:10:58.550 --> 00:11:00.250 
of running
the infrastructure

144
00:11:00.910 --> 00:11:04.180 
maintaining a platform, patching it,
keeping it up and running,

145
00:11:04.440 --> 00:11:08.590 
monitoring it, ensuring that it's secure
and so on to to another

146
00:11:08.590 --> 00:11:14.040 
party who specialised in that capability, so
that we as exploited we as consumer

147
00:11:14.160 --> 00:11:19.120 
of that service of that cloud can
focus on what we really understand with

148
00:11:19.850 --> 00:11:23.400 
value add with respect to the
application run time and data.

149
00:11:24.510 --> 00:11:27.690 
Or, of course you have the
case where even a complete stack

150
00:11:27.690 --> 00:11:32.580 
is then consumed as a software and the
users just interact with the provider

151
00:11:32.760 --> 00:11:35.510 
through an interface and
consume the software directly.

152
00:11:38.240 --> 00:11:45.190 
As we move from these different, from
the more traditional full stack management

153
00:11:45.790 --> 00:11:50.330 
to interacting with the service
provider, also the roles within

154
00:11:50.440 --> 00:11:53.420 
an enterprise within a company
change, the role of

155
00:11:54.080 --> 00:11:57.840 
those who develop applications, the
role of those who

156
00:11:58.390 --> 00:12:00.500 
manage the infrastructure
they change.

157
00:12:02.380 --> 00:12:07.570 
As we have a traditional work
split in the traditional enterprise of

158
00:12:08.780 --> 00:12:13.610 
OPs teams that are focused on
the infrastructure alone, so they would

159
00:12:13.720 --> 00:12:16.230 
do everything up to
the layer of,

160
00:12:17.410 --> 00:12:22.360 
let's say, compute network and
storage infrastructure. And then

161
00:12:22.360 --> 00:12:25.710 
another team came in and
started to manage the

162
00:12:26.650 --> 00:12:31.140 
operating system, the middleware and
ensure the patching access control,

163
00:12:31.360 --> 00:12:37.220 
monitoring and incident and problem management
of that element and then

164
00:12:37.440 --> 00:12:41.350 
the developers came in and
they provided their applications

165
00:12:41.350 --> 00:12:46.620 
and handed them over to the OPs
teams to now run, deploy, run

166
00:12:46.620 --> 00:12:48.180 
and manage
those applications.

167
00:12:48.880 --> 00:12:52.580 
That role split is changing. The
first thing that is changing is

168
00:12:53.070 --> 00:12:56.910 
that some of the providers
of those layers, infrastructure platform

169
00:12:56.910 --> 00:13:00.720 
or even software layer can be
delegated to an external entity

170
00:13:00.940 --> 00:13:02.180 
namely the
cloud provider

171
00:13:03.180 --> 00:13:08.810 
and the other optimisation that we see
and that we realize is that

172
00:13:09.470 --> 00:13:15.510 
the split between OPs teams and Dev
teams has to change, has to be

173
00:13:16.410 --> 00:13:21.540 
ripped apart and put together into
a full stack development team

174
00:13:21.890 --> 00:13:27.080 
in order to achieve the flexibility and
the quick turnaround for new versions,

175
00:13:27.470 --> 00:13:31.440 
new releases and new
capabilities in the application.

176
00:13:32.730 --> 00:13:37.780 
Now such a full stack team
is a lot easier to

177
00:13:38.210 --> 00:13:41.140 
realize for small start
up where anyway

178
00:13:41.930 --> 00:13:45.560 
it is just one person or maybe
just a handful of person that can

179
00:13:45.890 --> 00:13:50.210 
eat a box of pizza together
that develop applications and later

180
00:13:50.210 --> 00:13:55.180 
also run them and also manage
and operate and monitor the infrastructure.

181
00:13:55.620 --> 00:14:00.130 
In a typical enterprise, that
transformation is more complex

182
00:14:00.130 --> 00:14:03.830 
and requires more time and also
requires a change of cultures.

183
00:14:05.360 --> 00:14:09.550 
Now, of course, I do want
to recognize that that very simple

184
00:14:09.550 --> 00:14:14.510 
and strict separation of layers is
an ideal view. It is not

185
00:14:14.510 --> 00:14:20.090 
the reality. The reality we often see
is that the applications that we

186
00:14:20.770 --> 00:14:23.790 
traditionally see and that
we encounter today

187
00:14:24.220 --> 00:14:28.460 
do not have clear interfaces
and separations for those layers,

188
00:14:28.700 --> 00:14:32.810 
but often those layers overlap, often
those layers do not have

189
00:14:33.030 --> 00:14:36.730 
clearly defined and agreed interfaces
and often those layers

190
00:14:36.730 --> 00:14:40.530 
are not standardized but have
very non standard requirements

191
00:14:40.530 --> 00:14:41.980 
or capabilities in them.

192
00:14:43.990 --> 00:14:46.850 
Let's quickly talk about
another category on

193
00:14:47.340 --> 00:14:50.340 
the set of differentiaters
of different clouds. Let's talk

194
00:14:50.340 --> 00:14:52.100 
about the level
of abstraction.

195
00:14:54.040 --> 00:14:58.020 
If you go from bottom to
top here through those abstractions,

196
00:14:58.020 --> 00:15:03.660 
you see bare metal, then hypervisor
capabilities that abstracts out of the

197
00:15:05.360 --> 00:15:10.380 
base infrastructures of compute network and
storage. Then the next abstraction is

198
00:15:10.570 --> 00:15:13.770 
containers which provides a
maximum of portability,

199
00:15:14.310 --> 00:15:18.720 
standardizing and contracting some of
the packaging and some

200
00:15:18.720 --> 00:15:20.860 
of the operating
system elements.

201
00:15:21.500 --> 00:15:26.620 
Next step to a platform is
a service environment to deploy applications

202
00:15:27.240 --> 00:15:32.550 
and an up to a serverless
environment where the consumer mainly

203
00:15:32.550 --> 00:15:36.190 
focuses on the code
and deploys code

204
00:15:36.840 --> 00:15:40.890 
really delegating the complete rest of
the stack on how to

205
00:15:41.880 --> 00:15:46.870 
deploy and also how to execute
that code to a service provider.

206
00:15:48.230 --> 00:15:51.690 
Now all that gives us
additional speed. At high abstraction

207
00:15:51.690 --> 00:15:56.580 
level the quicker we are to push
out new features, new functions, new capabilities.

208
00:15:57.180 --> 00:16:02.260 
It also allows us to be
more portable to more quickly deploy

209
00:16:02.260 --> 00:16:07.380 
into these different kinds of clouds
that we mentioned earlier. However,

210
00:16:07.520 --> 00:16:13.310 
it also means that the exploiter
or the provider of those functions

211
00:16:14.430 --> 00:16:17.040 
hands over much
of the control

212
00:16:17.860 --> 00:16:21.750 
to the service provider. So,
the performance and the control,

213
00:16:21.750 --> 00:16:25.590 
the fine level control is handed
over to the service provider

214
00:16:25.590 --> 00:16:29.880 
and the service provider offers a set
of standard interfaces and instead of

215
00:16:30.020 --> 00:16:34.150 
a set of standard capabilities, to
then deploy this code. So

216
00:16:34.150 --> 00:16:36.860 
it's a trade off. What is
more important to me, to

217
00:16:37.800 --> 00:16:42.960 
ensure that the last bit of
performance is optimized out of

218
00:16:42.960 --> 00:16:47.180 
a certain piece of code and
match it to a certain hardware,

219
00:16:47.330 --> 00:16:52.320 
or am I more interested in
portability and also speed of deployment

220
00:16:52.320 --> 00:16:54.770 
and speed of new
functions and new features.

221
00:16:57.210 --> 00:17:01.090 
Now, these higher level
abstractions have also

222
00:17:02.230 --> 00:17:04.780 
required a change
in process.

223
00:17:06.040 --> 00:17:09.940 
If we have those technical
capabilities to quickly deploy code

224
00:17:10.050 --> 00:17:15.400 
from a technical perspective, it also
requires a change in how traditional

225
00:17:15.740 --> 00:17:20.380 
organizations operate when it comes
to what process they've defined

226
00:17:20.530 --> 00:17:21.860 
to push out new code.

227
00:17:22.470 --> 00:17:26.540 
So traditionally, the separation
between development test and

228
00:17:26.540 --> 00:17:32.000 
later into prod and pre prod
required a quite heavy change process

229
00:17:32.270 --> 00:17:36.800 
that went through a
very important change board

230
00:17:37.290 --> 00:17:41.760 
with a very time
consuming approval process.

231
00:17:42.340 --> 00:17:47.350 
Now, that process together with
all these new capabilities that

232
00:17:47.350 --> 00:17:49.420 
technically would allow us
to be quicker

233
00:17:50.070 --> 00:17:52.010 
doesn't actually get us
to the end game.

234
00:17:52.580 --> 00:17:57.360 
So, in theory the ideal case
is that pipelines are defined that

235
00:17:57.520 --> 00:18:01.360 
different features within one
application are separated out

236
00:18:01.610 --> 00:18:05.650 
and each feature stream, each
pipeline can push new versions

237
00:18:05.650 --> 00:18:09.340 
and push new capabilities quickly
through the complete pipeline,

238
00:18:09.560 --> 00:18:11.870 
through DevTest pre
prod into prod

239
00:18:12.500 --> 00:18:16.740 
independent of other elements.
Now so much for

240
00:18:17.230 --> 00:18:22.730 
the hope, the wish and the dream
of cloud native IT. In reality

241
00:18:22.730 --> 00:18:26.390 
we often see that there are
still dependencies between different pipelines

242
00:18:26.500 --> 00:18:30.810 
and before we are able to push out
to prod, there's some set of integration required

243
00:18:31.030 --> 00:18:35.240 
and some testing and some
release process still required before

244
00:18:35.420 --> 00:18:38.740 
a new version is pushed out
into prod. And of course whenever

245
00:18:38.740 --> 00:18:42.430 
we have a mix between traditional
IT and cloud-native IT,

246
00:18:42.680 --> 00:18:46.570 
we also see that integration
being required especially before the

247
00:18:46.930 --> 00:18:47.950 
production step.

248
00:18:50.440 --> 00:18:56.580 
Another element of shared responsibility
that is changing between

249
00:18:56.590 --> 00:19:02.040 
traditional IT and cloud is how quality
of service and service levels are achieved.

250
00:19:03.020 --> 00:19:09.070 
For example, in an environment where
the abstraction level is virtual machines,

251
00:19:10.060 --> 00:19:15.720 
the application developer basically put
the application together and

252
00:19:16.160 --> 00:19:19.100 
ensured that the application would
run in a single instance,

253
00:19:19.100 --> 00:19:20.660 
in a single
virtual machine.

254
00:19:21.720 --> 00:19:25.520 
If for some reason, then
the underlying virtual machine the

255
00:19:25.520 --> 00:19:29.990 
underlying physical host of that virtual
machine was not available or

256
00:19:30.440 --> 00:19:33.870 
broke down, availability of
the virtual machine

257
00:19:34.420 --> 00:19:38.490 
was basically requested from
the operations team

258
00:19:39.110 --> 00:19:41.810 
to be continued on
another physical machine.

259
00:19:42.240 --> 00:19:46.770 
How did the operations team ensure that?
Well by defining these x-clusters,

260
00:19:47.230 --> 00:19:51.210 
or sets of clusters across multiple
hosts and a virtual machine

261
00:19:51.280 --> 00:19:54.690 
would quickly replicate and be
made available on another

262
00:19:55.100 --> 00:19:58.300 
physical machine or physical
node. Same for

263
00:19:59.680 --> 00:20:04.370 
the state in that virtual machine,
same for storage on storage devices,

264
00:20:04.700 --> 00:20:08.710 
same for virtual volumes that would
be made available on different

265
00:20:08.850 --> 00:20:12.930 
physical hosts because the data of
it was replicated. So basically,

266
00:20:13.070 --> 00:20:17.780 
virtual machines were patched and and were
backed up and the operations around that

267
00:20:18.200 --> 00:20:22.370 
was delegated to an Ops
team that didn't really interact

268
00:20:22.580 --> 00:20:23.870 
with the
development team

269
00:20:24.490 --> 00:20:29.350 
and for the most part there was a
clear border or even clear wall

270
00:20:29.590 --> 00:20:33.170 
between the Devs and Ops team.
So the responsibility for quality

271
00:20:33.170 --> 00:20:36.610 
of service and service level
was mainly pushed and delegated

272
00:20:36.610 --> 00:20:38.770 
down to the infrastructure
of VMWare.

273
00:20:39.490 --> 00:20:43.460 
Now as we move into
more distributed computing paradigms

274
00:20:43.460 --> 00:20:45.950 
into micro services
or specifically containers,

275
00:20:46.950 --> 00:20:50.260 
we need to realize that
there is a shared responsibility.

276
00:20:50.970 --> 00:20:53.410 
The developer of
the application

277
00:20:54.120 --> 00:20:59.250 
the one packaging a container, the one
designing a workload in a container

278
00:20:59.950 --> 00:21:03.890 
has shared responsibility when it comes
to quality of service and

279
00:21:04.110 --> 00:21:10.240 
service levels. There is a set
of automated management of containers. However,

280
00:21:11.260 --> 00:21:16.670 
that automation will not in itself achieve
quality of service and service levels.

281
00:21:17.130 --> 00:21:22.070 
The application needs to be prepared,
to deal with the automated

282
00:21:22.070 --> 00:21:25.300 
management of the containers
in order to provide

283
00:21:26.050 --> 00:21:29.250 
high-availability, disaster
recovery, replication.

284
00:21:29.740 --> 00:21:32.970 
For example state
in a container

285
00:21:34.030 --> 00:21:36.080 
could be ephemeral
any time

286
00:21:37.420 --> 00:21:41.140 
because the underlying physical node
goes away. Yes, of course

287
00:21:41.140 --> 00:21:45.420 
the underlying automation might restart a
container on a different physical host

288
00:21:45.930 --> 00:21:49.990 
however that original state that was
live in an instance of

289
00:21:50.010 --> 00:21:53.440 
that container on the previous
host is no longer available

290
00:21:53.490 --> 00:21:55.540 
and was not replicated
by any magic.

291
00:21:56.170 --> 00:22:00.960 
So the application developer better follow
the twelve factors to ensure

292
00:22:01.780 --> 00:22:06.190 
that his application his or her
application can deal well with

293
00:22:06.190 --> 00:22:08.960 
the automation of the
underlying container environment.

294
00:22:11.420 --> 00:22:15.070 
So, summarizing out of the
different topics that we discussed,

295
00:22:15.190 --> 00:22:18.420 
what are the key takeaways that I
would like to share with you?

296
00:22:19.550 --> 00:22:24.680 
Well, most important you need to
understand that the reality of

297
00:22:25.510 --> 00:22:31.610 
information technology that start-ups,
companies, enterprises face

298
00:22:32.060 --> 00:22:35.210 
is not an island. It's not a
single cloud, it's a multi cloud

299
00:22:35.330 --> 00:22:40.900 
and often it's a mix of multiple
clouds as well as on-premise traditional IT.

300
00:22:42.790 --> 00:22:49.300 
We also need to tolerate in our
developing of applications, in our advising

301
00:22:49.450 --> 00:22:54.020 
enterprises or companies on how
to use infrastructure technology

302
00:22:54.410 --> 00:23:00.750 
that there is a mix of traditional
IT and cloud native capabilities.

303
00:23:00.760 --> 00:23:03.300 
Yes we can use
cloud native capabilities

304
00:23:03.700 --> 00:23:06.990 
to develop applications more quickly
and be more flexible in

305
00:23:06.990 --> 00:23:11.170 
reacting to user demands. However we
still need to connect them

306
00:23:11.410 --> 00:23:13.980 
to elements that run in
the traditional IT.

307
00:23:14.880 --> 00:23:18.650 
We need to be able to
distinguish between different categories of cloud,

308
00:23:18.780 --> 00:23:23.150 
understand the service split - who is
responsible for which level of service,

309
00:23:23.530 --> 00:23:28.080 
understand the level of isolation that
different kinds of cloud offer.

310
00:23:28.370 --> 00:23:30.380 
Is it physical,
logical or

311
00:23:32.010 --> 00:23:35.760 
isolation through encryption? The level
of sharing, so which

312
00:23:35.760 --> 00:23:39.540 
elements in a cloud infrastructure
are shared, which are logically

313
00:23:39.540 --> 00:23:44.640 
shared and which are physically shared
between different tenants, different accounts

314
00:23:44.820 --> 00:23:47.080 
or different users
on that cloud.

315
00:23:47.810 --> 00:23:51.560 
What is the right abstraction level
for my application or for

316
00:23:51.560 --> 00:23:52.970 
a certain set
of workload?

317
00:23:53.590 --> 00:23:57.830 
What are the scale capabilities of
that cloud which has to

318
00:23:57.830 --> 00:24:03.040 
do with the pool size? Do I have
a dedicated pool or is that pool

319
00:24:03.560 --> 00:24:05.300 
going to be shared
with many many

320
00:24:05.930 --> 00:24:09.310 
tenants and customers and
therefore provides me a

321
00:24:09.740 --> 00:24:15.130 
really high scalability? And what
specializations does my workload require

322
00:24:15.560 --> 00:24:19.600 
and the cloud that I pick
will it provide those specializations?

323
00:24:21.070 --> 00:24:24.840 
So the shared responsibility
that we need to

324
00:24:25.430 --> 00:24:29.050 
accept has much to do
with understanding the split

325
00:24:29.500 --> 00:24:33.190 
or the interface between the service
provider and the service consumer

326
00:24:33.430 --> 00:24:38.470 
at whatever level of abstraction the
split is and then also understand

327
00:24:39.050 --> 00:24:43.810 
what the consumer and provider
have to contribute in order

328
00:24:43.810 --> 00:24:45.830 
to achieve that
shared responsibility.

329
00:24:46.970 --> 00:24:54.710 
And finally, not all workload that we
develop will just manage itself. In fact,

330
00:24:55.380 --> 00:25:00.070 
typically no workload, no application
that we develop once we

331
00:25:00.070 --> 00:25:04.270 
push it into production will just
continue to run there for

332
00:25:04.480 --> 00:25:08.900 
many many years with or without care
and keeping. It does require monitoring,

333
00:25:09.010 --> 00:25:13.140 
it does require management and
it requires operational aspects

334
00:25:13.350 --> 00:25:17.280 
that need to be provided to
run such an application in production.

335
00:25:18.310 --> 00:25:23.630 
Now, I want to thank you very much
for your interest and I hope you can

336
00:25:23.830 --> 00:25:27.890 
take away all these points with you
and I want to thank you

337
00:25:27.900 --> 00:25:28.790 
for your interest.
