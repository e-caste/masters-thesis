WEBVTT

1
00:00:00.740 --> 00:00:04.610 
Yeah, welcome to the mainframe server OS perspective.

2
00:00:06.020 --> 00:00:10.549 
As an introduction to the mainframe course, we just want to talk

3
00:00:10.550 --> 00:00:15.649 
a little bit about where mainframe computing comes from,

4
00:00:15.650 --> 00:00:19.939 
how server computing is different from traditional desktop computing.

5
00:00:19.940 --> 00:00:24.889 
What are the key optimization goals and the criteria for server systems?

6
00:00:24.890 --> 00:00:29.329 
And there are attributes like capacity and scalability,

7
00:00:29.330 --> 00:00:34.699 
integrity, security, the availability server

8
00:00:34.700 --> 00:00:38.119 
computers typically have access to large amounts of data.

9
00:00:39.680 --> 00:00:44.539 
They cannot be run without sophisticated systems management facilities.

10
00:00:44.540 --> 00:00:49.459 
And oftentimes people talk about autonomic capabilities and mean that

11
00:00:49.460 --> 00:00:54.020 
the systems maintain themselves to some extent.

12
00:00:56.860 --> 00:00:59.509 
So just the definition with capacity.

13
00:00:59.510 --> 00:01:04.540 
We talk about the potential for holding and storing

14
00:01:05.860 --> 00:01:10.329 
huge amounts of data disk, for instance,

15
00:01:10.330 --> 00:01:15.219 
or also long term storage like tape

16
00:01:15.220 --> 00:01:19.540 
with capacity. People also address the power to produce and perform

17
00:01:22.280 --> 00:01:26.839 
tasks, sufficient computing capacity, for instance, to run the programs that

18
00:01:26.840 --> 00:01:31.369 
process the data or also sufficient capacity to store the

19
00:01:31.370 --> 00:01:35.809 
data on a single server and sometimes

20
00:01:35.810 --> 00:01:38.930 
also on distributed and dispersed systems.

21
00:01:41.810 --> 00:01:46.459 
With a service level agreement, we address the fact that computer systems

22
00:01:46.460 --> 00:01:51.109 
cannot themselves solve all the problems on the planet, but

23
00:01:51.110 --> 00:01:55.969 
we have agreements between service providers and recipients, business

24
00:01:55.970 --> 00:01:58.759 
units, server owners.

25
00:01:58.760 --> 00:02:01.939 
These are different terms for the same fact.

26
00:02:01.940 --> 00:02:06.769 
And typically it is that SLA describes a baseline

27
00:02:06.770 --> 00:02:11.569 
for capacity demands. For instance, we want to say that 99 percent

28
00:02:11.570 --> 00:02:16.279 
or 95 percent of ATM transactions are to be completed in less

29
00:02:16.280 --> 00:02:20.779 
than a second, or that 90 percent of the daily reports are completed

30
00:02:20.780 --> 00:02:21.780 
by 6:00 a.m.

31
00:02:23.630 --> 00:02:28.249 
It is beyond the scope of the technical solution to define what

32
00:02:28.250 --> 00:02:31.259 
happens if SLAs are not met.

33
00:02:31.260 --> 00:02:34.340 
Oftentimes the lawyers take over in that moment.

34
00:02:36.650 --> 00:02:41.119 
Another aspect that is typical for server systems is that we are

35
00:02:41.120 --> 00:02:45.949 
planning for downtime, we need to address the fact that systems

36
00:02:45.950 --> 00:02:49.189 
are out and that there are outages.

37
00:02:49.190 --> 00:02:54.679 
These may be planned or unplanned, for instance, for software maintenance

38
00:02:54.680 --> 00:02:58.939 
to implement new levels of features or to fix problems.

39
00:03:00.500 --> 00:03:05.029 
And oftentimes the continuity of a service can be provided

40
00:03:05.030 --> 00:03:09.409 
by sharing resources for critical workloads across several machines.

41
00:03:11.450 --> 00:03:16.099 
Planning for downtime also means that it makes a

42
00:03:16.100 --> 00:03:20.599 
big difference whether a system comes down planned or unplanned, that you

43
00:03:20.600 --> 00:03:23.930 
need to plan ahead, that you need to schedule maintenance and to force.

44
00:03:26.650 --> 00:03:31.089 
In case we want to provide continuity of service in event

45
00:03:31.090 --> 00:03:34.209 
of failures, we need to have two or more physical machines.

46
00:03:34.210 --> 00:03:38.949 
Obviously the scalability, we want to address the ability of a system

47
00:03:38.950 --> 00:03:43.479 
to continue to function if it's changed in

48
00:03:43.480 --> 00:03:48.129 
size or volume. So scalability means that we can add

49
00:03:48.130 --> 00:03:52.869 
additional hardware, that we can add additional software, or that we can change

50
00:03:52.870 --> 00:03:56.739 
from a single system to a distributed system.

51
00:03:56.740 --> 00:04:01.209 
It also addresses the ability to retain performance levels when adding

52
00:04:01.210 --> 00:04:05.259 
additional resources such as processors or memory or storage.

53
00:04:05.260 --> 00:04:10.239 
With a scalable system, we can adapt to work within

54
00:04:10.240 --> 00:04:14.829 
smaller networks to perform tasks of varying complexity.

55
00:04:14.830 --> 00:04:19.120 
So we basically can adapt ourselves to changing requirements.

56
00:04:21.510 --> 00:04:26.129 
Integrity and security addressed the question to not only

57
00:04:26.130 --> 00:04:30.689 
be operational, but operate on valid data,

58
00:04:30.690 --> 00:04:35.369 
which means we have to implement data security as protection against unauthorized

59
00:04:35.370 --> 00:04:40.079 
access, against transfer or denial of service, against

60
00:04:40.080 --> 00:04:41.969 
modification or destruction.

61
00:04:41.970 --> 00:04:46.379 
And these attempts can be done accidentally or intentionally.

62
00:04:46.380 --> 00:04:50.939 
Oftentimes, the accidental data security

63
00:04:50.940 --> 00:04:54.839 
problems are due to the most difficult ones to address.

64
00:04:57.430 --> 00:05:02.089 
In order to talk about terms like integrity and security, you have to have

65
00:05:02.090 --> 00:05:06.669 
well-defined security objectives, which means you have to address the

66
00:05:06.670 --> 00:05:08.859 
job of a security administrator.

67
00:05:08.860 --> 00:05:13.059 
You need to talk about security policies, the security measures and so forth.

68
00:05:13.060 --> 00:05:17.919 
And also the system needs to provide interfaces to

69
00:05:17.920 --> 00:05:20.079 
enforce authority rules.

70
00:05:22.870 --> 00:05:26.729 
RAS, or reliability, availability, serviceability,

71
00:05:27.940 --> 00:05:32.799 
those three terms address the stability

72
00:05:32.800 --> 00:05:37.269 
of a system and can be seen as key features for data

73
00:05:37.270 --> 00:05:41.709 
processing, which means that in the system

74
00:05:41.710 --> 00:05:46.359 
architecture, we place a high priority on systems that

75
00:05:46.360 --> 00:05:50.019 
are available and in service all the time.

76
00:05:50.020 --> 00:05:55.389 
So RAS is the central design feature for many computer systems,

77
00:05:55.390 --> 00:05:59.769 
and RAS talks about systems, which means it doesn't talk about hardware alone.

78
00:05:59.770 --> 00:06:04.449 
It doesn't talk about the OS only or the application, but it talks

79
00:06:04.450 --> 00:06:06.459 
about the entire stack.

80
00:06:06.460 --> 00:06:10.989 
And this reliability will oftentimes mean that

81
00:06:10.990 --> 00:06:13.899 
systems have to have extensive self-checking and self-recovery.

82
00:06:15.790 --> 00:06:21.159 
Availability means that a system can recover from failed components without

83
00:06:21.160 --> 00:06:24.849 
impacting the rest of the warning system. That means hardware recovery,

84
00:06:25.900 --> 00:06:31.179 
for instance, by replacing components with spares and software recovery,

85
00:06:31.180 --> 00:06:34.779 
one has to understand that there's a big difference between hardware and software because

86
00:06:34.780 --> 00:06:39.969 
hardware units that are replicated can be seen as independent units,

87
00:06:39.970 --> 00:06:44.439 
whereas replicating the same software bug just creates the

88
00:06:44.440 --> 00:06:45.440 
same problem.

89
00:06:46.950 --> 00:06:51.809 
People talk about mean time between failures as a measure that describes

90
00:06:51.810 --> 00:06:57.209 
the availability of a computer system, and with serviceability,

91
00:06:57.210 --> 00:07:01.799 
we mean that a system can basically

92
00:07:01.800 --> 00:07:05.759 
postmortem determine why a failure occurred.

93
00:07:05.760 --> 00:07:10.409 
And that way we can replace elements like hardware

94
00:07:10.410 --> 00:07:15.119 
and software elements, and we have as little impact on the operational system

95
00:07:15.120 --> 00:07:19.619 
as possible. Serviceability also means that we have well-defined units of

96
00:07:19.620 --> 00:07:23.399 
replacement that might be hardware or software components.

97
00:07:26.040 --> 00:07:30.509 
We already mentioned that for subway systems it's

98
00:07:30.510 --> 00:07:35.219 
typical that we have access to large amounts of data, which means we need to store

99
00:07:35.220 --> 00:07:37.919 
the data and we need to process the data.

100
00:07:37.920 --> 00:07:42.359 
And the good old tape is still available

101
00:07:42.360 --> 00:07:47.099 
and denserthan ever before, basically to store

102
00:07:47.100 --> 00:07:48.899 
data, huge amounts of data.

103
00:07:48.900 --> 00:07:53.429 
People oftentimes talk about structured and unstructured data

104
00:07:53.430 --> 00:07:58.229 
and talk about the massive growth of

105
00:07:58.230 --> 00:08:01.420 
unstructured data in server computing.

106
00:08:02.550 --> 00:08:07.319 
We often talk about systems of record

107
00:08:07.320 --> 00:08:12.059 
and systems that do transaction processing and systems that typically operate

108
00:08:12.060 --> 00:08:14.989 
on structured data rather than unstructured data.

109
00:08:18.000 --> 00:08:23.189 
When processing data, we need to move them from disk to

110
00:08:23.190 --> 00:08:28.139 
memory, and for that we are going to have

111
00:08:28.140 --> 00:08:33.058 
many discs, because the large discs don't give us a good i/o

112
00:08:33.059 --> 00:08:37.769 
bandwidth. However, a huge number of smaller discs, this is typical

113
00:08:37.770 --> 00:08:40.580 
for server systems and the bandwidth is crucial.

114
00:08:42.559 --> 00:08:47.329 
When it comes to systems management, we talk about a collection of tools

115
00:08:47.330 --> 00:08:52.279 
and disciplines to monitor and control systems behavior, which means performance

116
00:08:52.280 --> 00:08:56.959 
monitoring, workload, configuration operations, also problem management, looking

117
00:08:56.960 --> 00:09:01.880 
at the network, the storage, security and also change management.

118
00:09:03.380 --> 00:09:07.939 
All these operations have to be defined by clear processes

119
00:09:07.940 --> 00:09:12.499 
and they are either performed by the operating system

120
00:09:12.500 --> 00:09:16.639 
themselves or appropriate subsystems.

121
00:09:16.640 --> 00:09:21.349 
This is also the market for specialized tools from various software

122
00:09:21.350 --> 00:09:26.089 
companies in order to achieve high availability,

123
00:09:26.090 --> 00:09:30.799 
not only the hardware infrastructure and the software components are

124
00:09:30.800 --> 00:09:34.729 
critical, but also the operational procedures and good systems management.

125
00:09:34.730 --> 00:09:39.469 
And in the end plays a vital role for achieving high availability.

126
00:09:42.670 --> 00:09:47.289 
I already mentioned that systems management is a complex task and

127
00:09:49.180 --> 00:09:53.019 
the desire is high to have systems manage themselves.

128
00:09:53.020 --> 00:09:57.939 
Autonomic capabilities mean exactly that.

129
00:09:57.940 --> 00:10:02.979 
So in analogy to the autonomic

130
00:10:02.980 --> 00:10:05.229 
central nervous system in the human body.

131
00:10:06.440 --> 00:10:11.019 
We want to have the systems adjust to many situations automatically without

132
00:10:11.020 --> 00:10:12.020 
external help.

133
00:10:13.240 --> 00:10:18.429 
And this means fewer people, fewer human maintenance

134
00:10:18.430 --> 00:10:23.289 
and basically quicker fixes and quicker debugging

135
00:10:23.290 --> 00:10:25.780 
of problems in computer systems.

136
00:10:29.210 --> 00:10:34.309 
So these are targets and design goals basically

137
00:10:34.310 --> 00:10:36.649 
for server systems.

138
00:10:36.650 --> 00:10:41.599 
And now if we look at the time axis and ask ourselves

139
00:10:41.600 --> 00:10:46.039 
how did systems evolve and what

140
00:10:46.040 --> 00:10:51.259 
is the status, where are we and what can we learn from history, then

141
00:10:51.260 --> 00:10:54.700 
one comes up with business picture similar to that one here.

142
00:10:55.910 --> 00:11:00.769 
We started out a long time ago with big computers, expensive

143
00:11:00.770 --> 00:11:05.419 
computers. People were not supposed to touch the computers and mainframes fall

144
00:11:05.420 --> 00:11:10.099 
exactly in that class. The hardware was king and it was from one big

145
00:11:10.100 --> 00:11:15.109 
vendor or typically a vendor

146
00:11:15.110 --> 00:11:17.689 
like IBM or a couple of others.

147
00:11:17.690 --> 00:11:21.470 
But in all these cases, the hardware was closed and proprietary.

148
00:11:23.720 --> 00:11:28.189 
In the nineteen-eighties there was the advent of the PC.

149
00:11:28.190 --> 00:11:33.409 
With PCs, software became crucial and software was king basically.

150
00:11:33.410 --> 00:11:36.950 
And Microsoft for over ruled the world, if you will,

151
00:11:38.000 --> 00:11:43.189 
because Microsoft created the understanding of stanard of a software

152
00:11:43.190 --> 00:11:47.809 
and people would send word documents and email something

153
00:11:47.810 --> 00:11:51.559 
that was completely unacceptable a couple of years before.

154
00:11:51.560 --> 00:11:56.419 
So. There was the move from expensive centralized

155
00:11:56.420 --> 00:12:00.979 
hardware to personal computers, however, that move came

156
00:12:00.980 --> 00:12:04.219 
at a price of reliability.

157
00:12:04.220 --> 00:12:07.669 
People were assumed to reboot the computer very often.

158
00:12:07.670 --> 00:12:12.139 
In fact, there was a time when logging onto computers meant to just

159
00:12:12.140 --> 00:12:16.699 
reboot the computer. And now we are trying

160
00:12:16.700 --> 00:12:21.439 
to mix both worlds, the expensive but reliable mainframe

161
00:12:21.440 --> 00:12:26.119 
world, and the cheap but unreliable PC world

162
00:12:26.120 --> 00:12:30.469 
into something that is best of breed, basically.

163
00:12:30.470 --> 00:12:35.389 
And when we look at the cloud and we see today a mixture, we have clusters

164
00:12:35.390 --> 00:12:40.999 
of workstations, we have people participating

165
00:12:41.000 --> 00:12:45.529 
at home in distributed applications, helping out, giving

166
00:12:45.530 --> 00:12:49.969 
away resources. But we also have the centralized systems

167
00:12:49.970 --> 00:12:55.519 
like the Linux one is the latest addition in the mainframe scene

168
00:12:55.520 --> 00:13:00.209 
that contribute to cloud computing,

169
00:13:00.210 --> 00:13:04.679 
The big difference now via hardware had

170
00:13:04.680 --> 00:13:09.389 
its time as the central component and software was most important

171
00:13:09.390 --> 00:13:13.859 
on a single PC in the 80s. Now we have to middleware the software layer or an

172
00:13:13.860 --> 00:13:18.599 
abstract layer of abstraction that sits between systems and distributed

173
00:13:18.600 --> 00:13:19.600 
systems

174
00:13:20.250 --> 00:13:22.829 
technology basically, that is most important.

175
00:13:22.830 --> 00:13:26.729 
And we rely on open standards like Web services.

176
00:13:26.730 --> 00:13:29.160 
It's not clear who is going to rule the world.

177
00:13:30.540 --> 00:13:35.429 
Looks like neither Microsoft nor IBM will be in that role,

178
00:13:35.430 --> 00:13:39.959 
but they will still play an important role.

179
00:13:39.960 --> 00:13:44.459 
And for us, when looking at these systems, the question is what can

180
00:13:44.460 --> 00:13:49.439 
we take away or can we reinvent reuse

181
00:13:49.440 --> 00:13:54.209 
as ideas that came from the old times like Vista

182
00:13:54.210 --> 00:13:58.380 
or 360 and the mainframe operating systems up to the US?

183
00:13:59.520 --> 00:14:05.019 
We had things like the resource access control framework or the job entry subsystem.

184
00:14:05.020 --> 00:14:08.370 
We have licensing models that might be appropriate to cloud as well.

185
00:14:09.730 --> 00:14:14.379 
With systems like VMS, the system from Digital Equipment

186
00:14:14.380 --> 00:14:18.939 
Corporation. There were solutions like clustering and failover

187
00:14:18.940 --> 00:14:20.859 
and the versioning file system.

188
00:14:20.860 --> 00:14:25.089 
So this is something that has completely disappeared from most systems nowadays.

189
00:14:25.090 --> 00:14:30.039 
And if you look at IBM's AIX Unix, then

190
00:14:30.040 --> 00:14:32.679 
they really introduced journalling filesystems.

191
00:14:32.680 --> 00:14:36.099 
They have high availability, availability solutions.

192
00:14:36.100 --> 00:14:38.229 
They have logical partitioning.

193
00:14:38.230 --> 00:14:42.849 
These are all features that need to be carried over to the world of cloud computing.

194
00:14:42.850 --> 00:14:47.559 
And even if one is mostly interested in,

195
00:14:47.560 --> 00:14:52.209 
say, Web services, it's still worthwhile looking at these

196
00:14:52.210 --> 00:14:56.769 
older systems because they introduce the technologies that are sought after

197
00:14:56.770 --> 00:14:57.770 
today.

198
00:14:59.140 --> 00:15:04.509 
Another story is interesting, and this is the story of looking at history

199
00:15:04.510 --> 00:15:06.459 
of operating systems.

200
00:15:06.460 --> 00:15:11.469 
And in that graph, there is a number of

201
00:15:11.470 --> 00:15:16.089 
lineups of systems like the MULTICS and UNIX line

202
00:15:16.090 --> 00:15:19.419 
in the very center where systems

203
00:15:20.860 --> 00:15:25.599 
created the prototypes for generations of operating

204
00:15:25.600 --> 00:15:30.309 
systems, like the MULTICS with the process model led to

205
00:15:30.310 --> 00:15:34.809 
UNIX and then later on to different variants like the AT&amp;T and the

206
00:15:34.810 --> 00:15:36.819 
Berkeley distribution.

207
00:15:36.820 --> 00:15:42.129 
The same with the OS 360 from IBM, which was

208
00:15:42.130 --> 00:15:46.569 
the initial desired operating system for the

209
00:15:46.570 --> 00:15:47.619 
mainframe.

210
00:15:47.620 --> 00:15:52.059 
And in fact the OS 360 was

211
00:15:52.060 --> 00:15:56.649 
also the key for this

212
00:15:56.650 --> 00:15:59.109 
software engineering story.

213
00:15:59.110 --> 00:16:04.419 
The mythical Man Month by Fred Brooks.

214
00:16:04.420 --> 00:16:09.189 
And this is the story about creating a software system that was

215
00:16:09.190 --> 00:16:13.989 
late, that was too big, that would not fit the

216
00:16:13.990 --> 00:16:18.549 
computer system when it was released and that was

217
00:16:18.550 --> 00:16:23.679 
difficult to maintain. There was written with inappropriate tools

218
00:16:23.680 --> 00:16:28.149 
that had so many box that and showed

219
00:16:28.150 --> 00:16:32.860 
the behavior that fixing box would introduce more new box than

220
00:16:34.120 --> 00:16:35.830 
old box were removed.

221
00:16:37.380 --> 00:16:42.329 
So from a software engineering standpoint, that system was a big challenge and

222
00:16:42.330 --> 00:16:44.219 
it succeeded in the market.

223
00:16:44.220 --> 00:16:49.109 
However, it triggered research in a field which is termed software

224
00:16:49.110 --> 00:16:54.029 
engineering nowadays and which in the very end led to

225
00:16:54.030 --> 00:16:58.799 
institutes like the Hasso Plattner Institute, where we do research in the field of

226
00:16:58.800 --> 00:17:03.629 
how software engineering for big systems may

227
00:17:03.630 --> 00:17:08.519 
work. And we all know processes like agile development

228
00:17:08.520 --> 00:17:10.559 
and we know the DevOp.

229
00:17:10.560 --> 00:17:14.789 
This all originated in one system, which was the OS 360.

230
00:17:16.500 --> 00:17:21.299 
And of course, all 360 technology

231
00:17:21.300 --> 00:17:25.979 
has been carried over several to several generations, enterprise systems,

232
00:17:25.980 --> 00:17:30.599 
architecture and the 390 up to the system that we know

233
00:17:30.600 --> 00:17:32.100 
is the OS nowadays.

234
00:17:33.410 --> 00:17:38.119 
This is also interesting with mainframe,

235
00:17:38.120 --> 00:17:43.160 
the IBM introduced not only the term of computer architecture.

236
00:17:45.420 --> 00:17:50.859 
This is the original flier from April

237
00:17:50.860 --> 00:17:56.199 
7, 1964, when people talked about

238
00:17:56.200 --> 00:18:01.299 
computers that can fulfill all computing needs, the 360

239
00:18:01.300 --> 00:18:03.849 
degree picture, the windows.

240
00:18:03.850 --> 00:18:07.690 
But also when people talked about different

241
00:18:08.830 --> 00:18:12.639 
models of computers that were able to run the same program.

242
00:18:12.640 --> 00:18:17.139 
So something that is taken for given nowadays that

243
00:18:17.140 --> 00:18:21.619 
we have upward compatability that the next

244
00:18:21.620 --> 00:18:26.869 
new computer will be able to run the same programs like today's computer

245
00:18:26.870 --> 00:18:29.629 
that was not given before 64.

246
00:18:29.630 --> 00:18:34.249 
So this is the start of a long

247
00:18:34.250 --> 00:18:34.879 
story.

248
00:18:34.880 --> 00:18:39.679 
And by the time people talked about IBM and the Seven Dwarfs because IBM was producing

249
00:18:39.680 --> 00:18:43.969 
approximately 70 per cent of our computers in 64.

250
00:18:43.970 --> 00:18:50.029 
However, the major technological

251
00:18:50.030 --> 00:18:53.569 
development in the 60s, there was the IBM system 360.

252
00:18:53.570 --> 00:18:56.239 
And what they introduced early on was.

253
00:18:57.940 --> 00:19:02.799 
Not only the concept of running an operating system by that time,

254
00:19:02.800 --> 00:19:07.539 
not yet called the OS. But still operating system on a partition

255
00:19:07.540 --> 00:19:12.159 
and a system. But they also introduce the idea of using virtualization,

256
00:19:12.160 --> 00:19:16.839 
running an operating system in their cases, even as in

257
00:19:16.840 --> 00:19:21.429 
the virtualization layer. And in fact, there are two levels of socialization.

258
00:19:21.430 --> 00:19:26.319 
This partitioning of is logical partitions policy and the introduction

259
00:19:26.320 --> 00:19:31.269 
of the hypervisor. There was a basic feature of the system.

260
00:19:31.270 --> 00:19:36.019 
Later on, the system was able to run Linux and Linux

261
00:19:36.020 --> 00:19:40.809 
unspotted, basically. And this Eiffel's we talk about integrated facilities

262
00:19:40.810 --> 00:19:45.369 
for Linux, basically CPUs that have special

263
00:19:45.370 --> 00:19:47.260 
special rules attached to it.

264
00:19:50.320 --> 00:19:54.849 
Why is virtualization important and what does it really

265
00:19:54.850 --> 00:19:59.289 
mean from a historical standpoint this year, hardware virtualization,

266
00:19:59.290 --> 00:20:03.969 
where we first virtualize all the interfaces, which means

267
00:20:03.970 --> 00:20:08.469 
we have a virtual machine monitor, we have our virtual lifestyle interfaces,

268
00:20:08.470 --> 00:20:13.059 
we have social memory, we have processes as models for

269
00:20:13.060 --> 00:20:14.440 
virtualizing computer hardware.

270
00:20:17.330 --> 00:20:22.399 
Virtualization is also great means for isolation and for running different

271
00:20:22.400 --> 00:20:27.049 
operating systems, different personalities on the same metal, on the same

272
00:20:27.050 --> 00:20:31.849 
computer. There are other means of virtualization besides hardware

273
00:20:31.850 --> 00:20:35.479 
virtualization. There's also processor virtualization.

274
00:20:35.480 --> 00:20:40.009 
Early example, that was DePasquale compiler that would translate

275
00:20:40.010 --> 00:20:44.899 
not into machine code but into peacoat, a pseudo pseudocode

276
00:20:44.900 --> 00:20:47.029 
for virtual machine.

277
00:20:47.030 --> 00:20:51.619 
And if you look at Java nowadays, it still translates into bytecode, which is

278
00:20:51.620 --> 00:20:55.019 
the machine code of an.

279
00:20:55.020 --> 00:21:00.119 
Non-existent computer, basically, and

280
00:21:00.120 --> 00:21:05.309 
for efficiency reasons, we oftentimes now see instructions said racialization,

281
00:21:05.310 --> 00:21:10.409 
like the binary translation that we find and transmit cruiser for energy efficiency,

282
00:21:10.410 --> 00:21:15.149 
or that we find an Rosero where, for instance, Apple made

283
00:21:15.150 --> 00:21:19.769 
a move from power architecture to intel architecture and was able to run power

284
00:21:19.770 --> 00:21:22.770 
binaries on on the new systems.

285
00:21:25.420 --> 00:21:29.969 
And another concept that was first coined on

286
00:21:29.970 --> 00:21:34.929 
the mainframe and introduced in the market and became widespread use, nowadays,

287
00:21:34.930 --> 00:21:38.969 
that's the concept of core processors. So if you look at a computer at home, then you

288
00:21:38.970 --> 00:21:42.480 
find the GPU and there's the concept of

289
00:21:43.590 --> 00:21:48.539 
the General-Purpose Graphical Processing Unit, which is rather a simply computer

290
00:21:48.540 --> 00:21:53.069 
computer in the box, which is an add on to the main

291
00:21:53.070 --> 00:21:57.569 
system. And this is a

292
00:21:57.570 --> 00:22:02.549 
story that started a long time ago with introducing cryptographic

293
00:22:02.550 --> 00:22:08.119 
units into the mainframe processor and introducing specialized

294
00:22:08.120 --> 00:22:12.650 
up codes into the into the machine language of the system.

295
00:22:14.850 --> 00:22:19.559 
So this open s.L and Vesicular, that's the attempt to unify

296
00:22:19.560 --> 00:22:24.569 
both worlds, the you and to GP world, and we will see

297
00:22:24.570 --> 00:22:27.929 
more specialized compute units in the future.

298
00:22:27.930 --> 00:22:32.579 
And the systems, the most recent, the fourteeners,

299
00:22:32.580 --> 00:22:35.160 
again making a strong move in that direction.

300
00:22:36.970 --> 00:22:41.439 
And additional examples, these are, for instance, the eyehole channels, the question

301
00:22:41.440 --> 00:22:45.939 
of lockstep execution for high availability,

302
00:22:45.940 --> 00:22:50.499 
the question of redundancy or how you do monitoring or billing

303
00:22:50.500 --> 00:22:55.209 
so many fields. Fair mainframes introduce concepts

304
00:22:55.210 --> 00:22:58.390 
that are now widespread use in the server marketplace.

305
00:23:00.140 --> 00:23:04.310 
During the course, we are going to address additional aspects

306
00:23:05.450 --> 00:23:10.639 
and we start with architecture, the instructions said

307
00:23:10.640 --> 00:23:13.699 
the virtualization approach.

308
00:23:13.700 --> 00:23:18.319 
If you talk about the enterprise hardware and give an overview of the

309
00:23:18.320 --> 00:23:22.819 
architecture and the subsystems there, talk about the availability

310
00:23:22.820 --> 00:23:26.660 
and wrasse features in general monitoring.

311
00:23:28.340 --> 00:23:32.849 
There will be discussion of operating systems and the evolution

312
00:23:32.850 --> 00:23:37.669 
we talk about Linux on systems, the programing interfaces

313
00:23:37.670 --> 00:23:42.529 
like the transaction management, like kicks the DB to database

314
00:23:42.530 --> 00:23:47.619 
and the like, and in the end, the mainframe.

315
00:23:47.620 --> 00:23:52.599 
That started many movies and many trends in our industry.

316
00:23:52.600 --> 00:23:57.429 
In the end, it's not much different from the programing

317
00:23:57.430 --> 00:24:00.639 
standpoint than a regular system.

318
00:24:00.640 --> 00:24:05.319 
You can have your Linux running, you can have your eclipse programing environment

319
00:24:05.320 --> 00:24:10.209 
running, and to the programmer should be able to

320
00:24:10.210 --> 00:24:14.829 
make steps, first steps on a mainframe, even even

321
00:24:14.830 --> 00:24:17.890 
relatively quickly, even if it's a new platform to you.

322
00:24:19.030 --> 00:24:23.769 
So this is my introductory message to the mainframe, Mücke.

323
00:24:23.770 --> 00:24:28.299 
And I just want to say welcome to openHPI and to

324
00:24:28.300 --> 00:24:29.589 
our corsia. Thank you.
