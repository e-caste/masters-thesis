WEBVTT

1
00:00:00.820 --> 00:00:06.520 
In our openHPI course "Blockchain: Revealing
the Myth", we now consider the second

2
00:00:07.070 --> 00:00:12.170 
component of the bitcoin system - the
blocks and the chain of blocks.

3
00:00:13.150 --> 00:00:19.300 
Let's shortly review that we already
discussed that there is a majority decision

4
00:00:19.540 --> 00:00:24.220 
by the longest chain of

5
00:00:25.240 --> 00:00:27.510 
the history of the transactions.

6
00:00:28.790 --> 00:00:33.120 
We have no central authority,
there is no trusted third party,

7
00:00:33.510 --> 00:00:39.160 
all transactions are publicly
announced, users are pseudonymous,

8
00:00:39.790 --> 00:00:44.330 
and we have a system for participants
to agree on a single history

9
00:00:44.640 --> 00:00:51.030 
of the order in which transactions were received
and the majority decision is represented

10
00:00:51.260 --> 00:00:56.530 
by the longest chain in which the greatest
proof of a work effort is invested.

11
00:00:58.240 --> 00:01:02.470 
In order to prevent fraud in order
to prevent double spending

12
00:01:02.500 --> 00:01:08.900 
a peer to peer distributed timestamping is
used that generates a computational proof

13
00:01:09.220 --> 00:01:13.510 
of the chronological order of the
transactions and the transactions

14
00:01:14.060 --> 00:01:20.830 
that are computationally impractical to
reverse protect sellers from fraud.

15
00:01:23.340 --> 00:01:28.300 
The system now we have, but if we would
implemented and uses in practice

16
00:01:28.860 --> 00:01:34.050 
it would be much too slow. If
you think for each transaction this

17
00:01:34.820 --> 00:01:37.510 
proof of work need to be
done too inter-connected,

18
00:01:38.310 --> 00:01:43.980 
so we cannot do this every time
a new transaction arrives.

19
00:01:44.920 --> 00:01:50.070 
So the users have to solve a
computational complex task

20
00:01:50.530 --> 00:01:55.570 
and to cryptographically link
by generating hashes all the

21
00:01:55.570 --> 00:01:57.790 
transactions individually
with each other.

22
00:01:59.060 --> 00:02:02.560 
And exactly to make this
process more efficient,

23
00:02:03.490 --> 00:02:08.330 
each user first collects a number
of received transactions

24
00:02:09.040 --> 00:02:10.440 
into a so-called block.

25
00:02:11.420 --> 00:02:15.530 
A block of a
specified size.

26
00:02:16.580 --> 00:02:21.970 
And then work on finding a difficult
proof of work for this new block

27
00:02:22.590 --> 00:02:27.190 
is done and this proof together
with a hash of the previous block

28
00:02:27.320 --> 00:02:28.980 
are added to
the new block.

29
00:02:29.710 --> 00:02:36.920 
So we have here exactly behave in
the same way like we explained

30
00:02:37.300 --> 00:02:41.760 
on the level of transactions. Now to
make the system more efficient,

31
00:02:41.940 --> 00:02:48.360 
we do this on the level of blocks and
blocks are a collection of a transactions

32
00:02:48.780 --> 00:02:50.220 
received with the users.

33
00:02:52.560 --> 00:02:58.980 
Now let's have a closer look to this
computational task that demands

34
00:02:59.150 --> 00:03:02.120 
a huge CPU effort work.

35
00:03:02.990 --> 00:03:07.290 
Like previously we mentioned
this work proves

36
00:03:08.010 --> 00:03:15.520 
that the block chain is in the right order
and makes it difficult to manipulate.

37
00:03:16.780 --> 00:03:21.780 
How this computation tax looks
like? And this computational task

38
00:03:22.000 --> 00:03:26.880 
consists of simply trying out
a number of hash values

39
00:03:27.420 --> 00:03:31.410 
to find a value that
corresponds to a given target.

40
00:03:32.560 --> 00:03:36.540 
You remember, hash functions are
one-way functions, so one can

41
00:03:36.550 --> 00:03:40.560 
do something and computes a hash
value than can manipulate

42
00:03:40.560 --> 00:03:48.110 
and then the next hash value is computed. Here
we insist that the resulting hash value

43
00:03:48.490 --> 00:03:51.720 
is below a given target.

44
00:03:53.410 --> 00:03:58.550 
To do this, the user needs
something to change

45
00:03:59.190 --> 00:04:04.210 
the block, to change the block
for providing a new hash

46
00:04:04.710 --> 00:04:09.430 
and of course this could not be as a transactions
and other important information,

47
00:04:09.800 --> 00:04:13.040 
so there is
a nonce edit.

48
00:04:13.720 --> 00:04:19.500 
So an arbitrary number which is called
a nonce and this is used together

49
00:04:19.650 --> 00:04:25.010 
with the information inside the
block to compute the hash.

50
00:04:25.520 --> 00:04:30.780 
And this nonce can be
changed to come up with

51
00:04:30.780 --> 00:04:35.940 
a new hash value which is
hopefully below of the target.

52
00:04:37.060 --> 00:04:43.740 
So this nonce, this is
typically combination of symbols

53
00:04:43.740 --> 00:04:49.030 
that is only used once in the respective
context in this context is

54
00:04:49.460 --> 00:04:53.090 
to provide the
possibility to vary

55
00:04:53.790 --> 00:05:00.090 
in the hash values of a block without
touching the transactions inside the block.

56
00:05:01.570 --> 00:05:07.180 
So if result at hash
isn't below of the target

57
00:05:07.730 --> 00:05:12.220 
the user keeps trying to incrementing
the nonce in the block

58
00:05:12.340 --> 00:05:16.110 
until a value is found that
gives the block a hash

59
00:05:16.980 --> 00:05:23.790 
that is below of the target and this can
be seen that it starts with the required

60
00:05:24.250 --> 00:05:28.040 
zero bits. The smaller
the number of the more

61
00:05:28.830 --> 00:05:33.160 
zeroes we have. So here
this is the idea

62
00:05:33.650 --> 00:05:39.300 
and incrementing the announce does not
mean that the hash value is incremented

63
00:05:39.610 --> 00:05:45.790 
because the hash value does not
content depend from the content

64
00:05:46.300 --> 00:05:51.310 
of the value. So in this
way we have a block

65
00:05:51.740 --> 00:05:55.700 
and we add this nonce,
we compute the hash,

66
00:05:56.330 --> 00:06:03.900 
the hash its here if we look to
hexadecimal numbers we have a target,

67
00:06:04.270 --> 00:06:10.750 
a target, this is where we have
to find a nonce that our hash

68
00:06:10.750 --> 00:06:12.160 
is below of the target.

69
00:06:12.790 --> 00:06:15.530 
You see here is the
number of zeros,

70
00:06:16.950 --> 00:06:25.410 
this gives the size of the
target and we have to find a nonce

71
00:06:25.610 --> 00:06:28.340 
set the hash value
of the block

72
00:06:29.100 --> 00:06:33.050 
with all the credentials with all
the transactions plus a nonce

73
00:06:33.490 --> 00:06:38.920 
is smaller sends the target
and if not we have to redo.

74
00:06:40.340 --> 00:06:45.220 
So if this proof of work
would be too easy to solve,

75
00:06:46.550 --> 00:06:50.520 
we would get a large number of
forks, because many people come

76
00:06:50.520 --> 00:06:54.130 
up with the result eventually
working with other

77
00:06:54.800 --> 00:06:59.410 
with other collections of
transactions inside the block, so

78
00:06:59.500 --> 00:07:02.820 
this needs to be prevented.
So there should be a gap

79
00:07:03.270 --> 00:07:06.740 
between the different
block creations

80
00:07:07.910 --> 00:07:12.500 
in the bitcoin system, ten minutes
are considered as a good gap

81
00:07:13.680 --> 00:07:21.980 
to save for stability of the
network and not get too much forks.

82
00:07:22.640 --> 00:07:28.780 
so the computational task need
so difficult that it needs

83
00:07:29.810 --> 00:07:36.350 
around ten minutes to find the
solution that needs a huge amount of

84
00:07:36.570 --> 00:07:42.480 
CPU power, it needs a huge
amount of energy to provide this.

85
00:07:43.670 --> 00:07:48.320 
So the solution implemented in
bitcoin system is to vary

86
00:07:48.790 --> 00:07:53.410 
the proof of work difficulty, that
means to adjust the target

87
00:07:53.780 --> 00:07:57.410 
according to the change in the
hash rate of the network.

88
00:07:58.230 --> 00:08:02.630 
So it is ruled in the
bitcoin that the target

89
00:08:03.100 --> 00:08:06.310 
adjust every two thousand
and sixteen blocks.

90
00:08:07.020 --> 00:08:10.050 
This is roughly
produced in two weeks

91
00:08:10.530 --> 00:08:15.530 
such that ten minutes are required
to create the new block,

92
00:08:15.720 --> 00:08:20.590 
so that the target could be made
more difficult to reach, can be

93
00:08:20.850 --> 00:08:24.620 
changed every two thousand and
sixteen blocks to hold this gap,

94
00:08:24.990 --> 00:08:29.430 
stable this gap of ten minutes
between the production of new

95
00:08:30.760 --> 00:08:32.720 
blocks remained stable.

96
00:08:34.190 --> 00:08:37.700 
If the computing power of the
entire network increases,

97
00:08:38.150 --> 00:08:41.830 
or eventually decreases and the
two thousand and sixty blocks

98
00:08:41.830 --> 00:08:48.320 
are found in less or more than two weeks,
then the level of difficulty is raised

99
00:08:48.450 --> 00:08:52.320 
or lowered accordingly.
So in this way as

100
00:08:53.050 --> 00:08:58.460 
a stable increase on the chain of
the blocks can be guaranteed.

101
00:09:00.560 --> 00:09:03.320 
Now the question is
what is the incentive

102
00:09:04.020 --> 00:09:06.560 
for the users to
stay honest?

103
00:09:08.070 --> 00:09:17.210 
To encourage them to stay honest, to expend
a lot of CPU power, to expend electricity

104
00:09:18.140 --> 00:09:21.090 
by forming such blocks.

105
00:09:21.720 --> 00:09:26.670 
Such valid blocks. It's a huge
work it's a huge amount of energy

106
00:09:27.640 --> 00:09:32.950 
and it's needed, otherwise we could
not run our peer to peer network

107
00:09:33.270 --> 00:09:35.010 
in a safe way.

108
00:09:36.710 --> 00:09:41.320 
It would be definitely wrong to assume
that all users act rationally

109
00:09:41.320 --> 00:09:43.830 
and follow the set
rules strictly

110
00:09:44.760 --> 00:09:50.040 
only to have the option of a cash
system without a third party

111
00:09:50.330 --> 00:09:55.950 
and using the peer to peer electronic
cash system also for similar values.

112
00:09:57.790 --> 00:10:02.320 
So what is necessary? We have
to have a closer look

113
00:10:03.010 --> 00:10:08.620 
to the network to discuss and understand
what could be the incentives

114
00:10:08.850 --> 00:10:16.240 
for the users to stay healthy or to
invest this proof of work in running

115
00:10:16.490 --> 00:10:20.320 
the bitcoin network in
a correct stable way.

116
00:10:22.720 --> 00:10:26.250 
To summarize what we have
had up to this moment,

117
00:10:27.010 --> 00:10:33.360 
to make the process of cryptographic
linking more efficient all users first

118
00:10:33.570 --> 00:10:38.010 
collect transactions
received a into a block.

119
00:10:38.720 --> 00:10:43.610 
So they do not this proof of
work with every new transaction

120
00:10:43.820 --> 00:10:48.050 
they collect transaction into a
block and then they do this work.

121
00:10:49.170 --> 00:10:53.320 
So the need to generate
the hash of the block

122
00:10:54.020 --> 00:10:56.760 
and work on finding a
difficult proof of work

123
00:10:57.620 --> 00:11:03.390 
forces a new block and this proof together
with the hash of the previous block

124
00:11:03.760 --> 00:11:06.040 
are added to
the new block.

125
00:11:06.640 --> 00:11:11.830 
So in the new block with adding
the hash as as a proof of work

126
00:11:12.230 --> 00:11:19.560 
gives the other users information that
this user who produced this block

127
00:11:19.780 --> 00:11:25.140 
has really invested this
proof of work.

128
00:11:27.540 --> 00:11:31.820 
The proof of work is
represented by a nonce, by an

129
00:11:33.890 --> 00:11:38.040 
additional value, which in
combination with a block

130
00:11:38.890 --> 00:11:42.860 
after hash function gives a
value that's below the current

131
00:11:42.860 --> 00:11:47.490 
target as a current target and
here with announce one can play

132
00:11:47.630 --> 00:11:52.930 
and can look to find such a nonce
said the hash of the block

133
00:11:53.390 --> 00:11:59.070 
and the nonce is below of the target
and this target is adapted

134
00:11:59.830 --> 00:12:04.500 
from time to time in such a
way that this proof of work

135
00:12:05.380 --> 00:12:07.410 
needs around
ten minutes.
