WEBVTT

1
00:00:09.900 --> 00:00:13.130 
Sorry for the row story,
there is nearly no argument

2
00:00:13.130 --> 00:00:19.190 
for the row store except it is an
accumulator and you permanently

3
00:00:19.190 --> 00:00:25.250 
update. We need row stores
or something like a block

4
00:00:25.250 --> 00:00:31.310 
with attributes for
controlled sums for statistics

5
00:00:31.310 --> 00:00:34.340 
in an operating system and
things like this, so there

6
00:00:34.340 --> 00:00:41.410 
is some use for this
concept of a row.

7
00:00:41.410 --> 00:00:47.470 
But, for application I
can't see it anymore.

8
00:00:48.480 --> 00:00:49.400 
Do you have one?

9
00:00:49.490 --> 00:00:52.520 
I would not build social
networks on columns.

10
00:00:53.530 --> 00:00:56.560 
This is something else,
so social network is,

11
00:00:57.570 --> 00:01:01.610 
there is, this is just
information connected

12
00:01:01.610 --> 00:01:03.630 
and this is a network.

13
00:01:03.630 --> 00:01:06.660 
I would not use a
relational database at all.

14
00:01:06.660 --> 00:01:12.720 
That's probably
true but be careful,

15
00:01:12.720 --> 00:01:17.770 
actually the business applications
are dealing with objects

16
00:01:18.780 --> 00:01:23.830 
and all attempts to actually
build an object store,

17
00:01:23.830 --> 00:01:27.870 
and I did two of
those, they have some

18
00:01:28.880 --> 00:01:31.910 
glamorous

19
00:01:32.920 --> 00:01:37.970 
they look good
and in the end

20
00:01:37.970 --> 00:01:40.100 
they are not good
enough. Main reason is

21
00:01:41.101 --> 00:01:46.106 
the applications, the business
applications and most other applications

22
00:01:46.106 --> 00:01:50.110 
are not dealing with the single
case where the object is the

23
00:01:50.110 --> 00:01:55.115 
dominating construct, they
are dealing with multiple

24
00:01:55.115 --> 00:01:59.119 
objects. Whether
this is in

25
00:02:00.120 --> 00:02:05.125 
personalized healthcare, it is
more interesting to see multiple

26
00:02:05.125 --> 00:02:08.128 
patients, how they have
been treated instead of

27
00:02:08.128 --> 00:02:13.133 
one single one. Systems are not
built to manage the personal

28
00:02:14.134 --> 00:02:17.137 
health history of one single
person, they do this as well but

29
00:02:17.137 --> 00:02:22.142 
they take this as an,
this is a necessary step

30
00:02:22.142 --> 00:02:24.144 
in order to do something
across patients.

31
00:02:25.145 --> 00:02:27.147 
We don't do anything
with one single account,

32
00:02:28.148 --> 00:02:32.152 
we do it with
multiple accounts.

33
00:02:33.153 --> 00:02:36.156 
There is not much information
in one single account

34
00:02:37.157 --> 00:02:40.160 
there is not one single product
in a company, there are thousands

35
00:02:40.160 --> 00:02:45.165 
of products. So most applications
are, in mathematical terms, set

36
00:02:45.165 --> 00:02:49.169 
oriented applications.
Network applications and

37
00:02:49.169 --> 00:02:54.174 
a social network where
we connect messages

38
00:02:55.175 --> 00:03:00.180 
are messages containing
text, video, pictures

39
00:03:00.180 --> 00:03:05.185 
is a bit different
but we're doing,

40
00:03:05.185 --> 00:03:09.189 
or SAP is doing applications
like this and it has to

41
00:03:09.189 --> 00:03:16.196 
be seen whether the
translation from a network of

42
00:03:17.197 --> 00:03:27.207 
non formatted objects
can be represented

43
00:03:27.207 --> 00:03:30.210 
in a database like
this well enough.

44
00:03:31.211 --> 00:03:35.215 
I would not say out
of the box with this

45
00:03:35.215 --> 00:03:38.218 
database concept, it is
better than what facebook has

46
00:03:39.219 --> 00:03:43.223 
built, purposely built for
that type of application,

47
00:03:43.223 --> 00:03:46.226 
but I'm also not sure
whether it's not possible.

48
00:03:49.229 --> 00:03:52.232 
So despite there are
different concepts for

49
00:03:52.232 --> 00:03:56.236 
graph databases and graph
store is another store which

50
00:03:56.236 --> 00:04:01.000 
has to be, not only
analyzed but also

51
00:04:01.241 --> 00:04:04.244 
tested in the future. What can
you do with graph store better?

52
00:04:04.244 --> 00:04:08.248 
We have a clear
application in this concept

53
00:04:08.248 --> 00:04:12.252 
here, the hierarchies,
the hierarchies are

54
00:04:12.252 --> 00:04:15.255 
this is a pointer structure
and in a graph store

55
00:04:16.256 --> 00:04:21.261 
it would be advantageous
because you can travel

56
00:04:21.261 --> 00:04:25.265 
along the the graph,
the nodes, faster

57
00:04:25.265 --> 00:04:28.268 
than probably in a
representation in a column store.

58
00:04:33.273 --> 00:04:38.278 
For the application, it is
important that a application

59
00:04:38.278 --> 00:04:42.282 
has the the functionality of a
hierarchy in a database system.

60
00:04:43.283 --> 00:04:48.288 
This is a fundamental
request which, unfortunately

61
00:04:48.288 --> 00:04:53.293 
in this database in concept,
was a little bit underdeveloped.

62
00:04:54.294 --> 00:04:57.297 
I don't know why but,
because it was clear

63
00:04:58.298 --> 00:05:01.301 
seven years ago that this
is a major request that

64
00:05:02.302 --> 00:05:05.305 
not only we have to grab
large amounts of data,

65
00:05:06.306 --> 00:05:10.310 
data sets quickly. We also have
to organize them, aggregate

66
00:05:10.310 --> 00:05:14.314 
them and organize them
according to a hierarchy.

67
00:05:15.315 --> 00:05:18.318 
So hierarchy handling is
important, how is it done,

68
00:05:19.319 --> 00:05:22.322 
can be done any way
by the database.

69
00:05:25.325 --> 00:05:28.328 
I think the graph store
could be more elegant

70
00:05:29.329 --> 00:05:34.334 
but hierarchies are
relatively small data sets

71
00:05:35.335 --> 00:05:39.339 
in comparison to big
data, relatively small.

72
00:05:39.339 --> 00:05:42.342 
So actually it doesn't matter
so much how you implement them

73
00:05:42.342 --> 00:05:44.344 
it's more important
that they are there

74
00:05:44.344 --> 00:05:48.348 
and their operations
on hierarchies.

75
00:05:48.348 --> 00:05:51.351 
A good example for this
is MDX in Microsoft,

76
00:05:52.352 --> 00:05:55.355 
Microsoft's
SQL-Server is a

77
00:06:00.360 --> 00:06:04.364 
a good implementation
of hierarchies and

78
00:06:08.368 --> 00:06:09.369 
building aggregates
along hierarchies.
