WEBVTT

1
00:00:04.400 --> 00:00:10.100 
To keep the main for a longer period
of time, a day free of change,

2
00:00:12.120 --> 00:00:19.190 
we store the data in an insert-only
mode, so we never delete any

3
00:00:19.190 --> 00:00:26.260 
data, delete is bad despite
you learn that SQL has insert

4
00:00:26.260 --> 00:00:32.320 
update, delete - delete is
bad and actually there are not

5
00:00:32.320 --> 00:00:36.360 
so many applications where
you really use delete

6
00:00:36.360 --> 00:00:41.410 
or can use delete, not
in the ones where the

7
00:00:41.410 --> 00:00:46.460 
old value still has a value. You
can not, in accounting you can not

8
00:00:46.460 --> 00:00:48.480 
delete something, in sales
you can not delete something.

9
00:00:48.480 --> 00:00:54.540 
In a construction
phase you can build

10
00:00:54.540 --> 00:00:59.590 
something and delete it and forget
it when you are in the preparation

11
00:00:59.590 --> 00:01:01.610 
of doing something. When you're
drawing something you can delete

12
00:01:01.610 --> 00:01:05.650 
all the time, so there are
applications where delete works.

13
00:01:05.650 --> 00:01:12.720 
Here the delete is basically
eliminated and replaced

14
00:01:12.720 --> 00:01:17.770 
by invalidate outdated tuples
instead. So the database keeps

15
00:01:17.770 --> 00:01:23.830 
a history of the
previous stages

16
00:01:23.830 --> 00:01:30.900 
of each individual tuple.
This has to be considered when

17
00:01:30.900 --> 00:01:35.950 
you build other applications
where delete is a

18
00:01:36.960 --> 00:01:39.990 
frequent occurring

19
00:01:41.101 --> 00:01:49.109 
operation which changes, many
changes are happening to one tuple

20
00:01:49.109 --> 00:01:55.115 
that we create a long chain of
history. So when you have this

21
00:01:55.115 --> 00:01:58.118 
application you have to think
about it, does that matter

22
00:01:58.118 --> 00:02:04.124 
and what are the implications of
that because there is no physical

23
00:02:04.124 --> 00:02:09.129 
delete. So the advantage
is we have a gap less time

24
00:02:09.129 --> 00:02:12.132 
travel possible, we can
go back and forth in time.

25
00:02:13.000 --> 00:02:16.136 
For most applications
this feature is very nice,

26
00:02:17.137 --> 00:02:21.141 
we haven't had this in
the past, we haven't used

27
00:02:21.141 --> 00:02:25.145 
it when databases are offering
that and that has some technical

28
00:02:25.145 --> 00:02:28.148 
implications, the
system is not totally

29
00:02:29.149 --> 00:02:33.153 
self explanatory
without a log.

30
00:02:34.154 --> 00:02:38.158 
Even disregarding the
technical database log which

31
00:02:38.158 --> 00:02:41.161 
is not very accessible to
application programmers,

32
00:02:42.162 --> 00:02:45.165 
we can travel back
and forth in time.

33
00:02:45.165 --> 00:02:49.169 
This is good for legal
requirements, the system is

34
00:02:49.169 --> 00:02:55.175 
auditable at any point in
time. It is an implicit logging

35
00:02:55.175 --> 00:03:00.180 
and snapshot isolation
and locking is simplified

36
00:03:00.180 --> 00:03:03.183 
with that. We will see
this in the second and

37
00:03:03.183 --> 00:03:08.188 
dictionary cleaning
becomes obsolete so ok.

38
00:03:11.191 --> 00:03:14.194 
Because otherwise you have to,
if you take delete the record

39
00:03:14.194 --> 00:03:18.198 
then you also have to look in
a dictionary with this record,

40
00:03:18.198 --> 00:03:21.201 
this tuple was the only one which
contributed to the dictionary

41
00:03:21.201 --> 00:03:24.204 
and you have to clean
up the dictionary.

42
00:03:27.207 --> 00:03:32.212 
When we, we have two
possibilities how

43
00:03:32.212 --> 00:03:37.217 
to do this, the first
one is we just flag -

44
00:03:37.217 --> 00:03:43.223 
every single tuple has a flag
it is "valid from"

45
00:03:43.223 --> 00:03:48.228 
So you see there was a Michael
Berg before Michael Berg

46
00:03:48.228 --> 00:03:50.230 
got changed, what
did we change?

47
00:03:54.234 --> 00:03:59.239 
The city, he moved from Berlin to
Potsdam. When we basically travel

48
00:03:59.239 --> 00:04:03.243 
through the records
for our application

49
00:04:03.243 --> 00:04:06.246 
and we find
Michael Berg again

50
00:04:06.246 --> 00:04:11.251 
and that has a new valid,
a newer a valid_from date

51
00:04:11.251 --> 00:04:15.000 
then we ignore this tuple
and take this tuple.

52
00:04:15.255 --> 00:04:19.259 
It is obvious,
this is very cheap.

53
00:04:19.259 --> 00:04:23.263 
This is an implicit
invalidation of the old tuple.

54
00:04:24.264 --> 00:04:28.268 
The insert does not require an
update of the formerly current

55
00:04:28.268 --> 00:04:34.274 
tuple, but the select, group
by, and join operations have to

56
00:04:34.274 --> 00:04:38.278 
find the most recent entries
first. So insert is very fast,

57
00:04:39.279 --> 00:04:42.282 
the read is very slow, and
after what you have heard

58
00:04:43.283 --> 00:04:48.288 
most of the activities
are anyway range select,

59
00:04:48.288 --> 00:04:51.291 
group by, and join operations
and not the original insert.

60
00:04:52.292 --> 00:04:55.295 
We introduce a concept "valid
from" "valid to",

61
00:04:56.296 --> 00:05:00.300 
we go back to
the original

62
00:05:00.300 --> 00:05:05.305 
entry in the main and
flag in the main. This is

63
00:05:05.305 --> 00:05:11.311 
only valid to a certain
date and enter the new one,

64
00:05:12.312 --> 00:05:17.317 
first in the delta and
later than, we merge

65
00:05:17.317 --> 00:05:20.320 
it later into the main
with the valid_from date.

66
00:05:20.320 --> 00:05:26.326 
When we travel through the
data sequentially or direct

67
00:05:26.326 --> 00:05:30.330 
access and we have
to travel through the

68
00:05:30.330 --> 00:05:35.335 
delta anyway, in
addition to the main and

69
00:05:35.335 --> 00:05:39.339 
we find an entry
with a valid_to date

70
00:05:40.340 --> 00:05:45.345 
and our operational date is
beyond the valid_to date then

71
00:05:45.345 --> 00:05:51.351 
we ignore this tuple.
So this is added,

72
00:05:51.351 --> 00:05:54.354 
the insert requires an
update of the formerly

73
00:05:55.355 --> 00:05:59.359 
current tuple, select and
group by is easy because we can

74
00:05:59.359 --> 00:06:02.362 
easily eliminate
those in the operation

75
00:06:03.363 --> 00:06:06.366 
without searching
for something else.

76
00:06:06.366 --> 00:06:11.371 
This is how it's implemented
and actually if you

77
00:06:13.000 --> 00:06:17.377 
write a little bit about this
with this concept you can reduce

78
00:06:17.377 --> 00:06:20.380 
the locking significantly
in the system.

79
00:06:21.381 --> 00:06:25.385 
Actually I postulated
once that you can have

80
00:06:25.385 --> 00:06:28.388 
basically a lock, nearly,
a lock-free system.

81
00:06:29.389 --> 00:06:35.395 
Because every single
transaction is taking place

82
00:06:36.396 --> 00:06:40.400 
at a certain point in time
and when a transaction starts,

83
00:06:41.401 --> 00:06:45.405 
the transaction which
is updating something,

84
00:06:45.405 --> 00:06:49.409 
so where potential
locking plays a role

85
00:06:50.410 --> 00:06:55.415 
the transaction
sees only the window

86
00:06:56.416 --> 00:06:59.419 
of data up to the time
the transaction started.

87
00:07:00.420 --> 00:07:04.424 
A transaction doesn't see
the data which was entered

88
00:07:04.424 --> 00:07:10.430 
after it started so with
this snapshot isolation

89
00:07:10.430 --> 00:07:15.435 
we can simplify the database
locking tremendously.

90
00:07:16.436 --> 00:07:20.440 
That was, it was an import
point for me six years ago,

91
00:07:20.440 --> 00:07:24.444 
to basically, or five
years ago to state that

92
00:07:24.444 --> 00:07:28.448 
even in this database concept
you can create something

93
00:07:28.448 --> 00:07:33.453 
which is nearly lock-free
and database locks are bad.

94
00:07:33.453 --> 00:07:37.457 
Because if we have a lot
of transactional processing

95
00:07:37.457 --> 00:07:41.461 
with transactional processing
of the insert and change type

96
00:07:42.462 --> 00:07:46.466 
then we need this isolation
otherwise we can create

97
00:07:46.466 --> 00:07:51.471 
the famous a-b, b-a locks
and block the system

98
00:07:52.472 --> 00:07:56.476 
and in order to eliminate
this we introduce

99
00:07:56.476 --> 00:07:58.478 
the concept
like this and...

100
00:08:00.480 --> 00:08:09.489 
Student: Did you say that the "valid_to" field is witten directly to the main store? HP: yes.

101
00:08:11.491 --> 00:08:16.496 
Somebody? There are exceptions,
it's only on the next page.

102
00:08:22.502 --> 00:08:27.507 
We check status
fields and

103
00:08:27.507 --> 00:08:32.512 
the valid_to for example can
be updated, it's actually,

104
00:08:32.512 --> 00:08:35.515 
this is a field which
updated only by the database.

105
00:08:35.515 --> 00:08:41.521 
It's not a field the user
sees, it's a timestamp

106
00:08:42.522 --> 00:08:45.525 
and, as I said,
a transaction

107
00:08:45.525 --> 00:08:51.531 
is only, when a transaction
enters the system, the transaction

108
00:08:51.531 --> 00:08:55.535 
is only working at
this point t1 in time.

109
00:08:55.535 --> 00:09:00.540 
The transaction
sees only data

110
00:09:01.541 --> 00:09:07.547 
which has a valid_from

111
00:09:08.548 --> 00:09:13.553 
which is before and ignores if
somebody has a valid_to after

112
00:09:13.553 --> 00:09:18.558 
this time. So if something got,
while this transaction is happening,

113
00:09:18.558 --> 00:09:22.562 
something got invalidated, the
transaction is not seeing that.

114
00:09:25.565 --> 00:09:29.569 
What it is doing is,
when actually an insert

115
00:09:29.569 --> 00:09:32.572 
an insert is harmless.
When an update

116
00:09:33.573 --> 00:09:37.577 
or an insert as a result
of an update is happening

117
00:09:37.577 --> 00:09:40.580 
it is being checked
whether it's still valid.

118
00:09:43.583 --> 00:09:47.587 
This little check is done but
the database has anyway the

119
00:09:47.587 --> 00:09:52.592 
address, checks whether
nothing has happened to

120
00:09:52.592 --> 00:09:54.594 
this tuple I'm working
on, I want to update this,

121
00:09:55.595 --> 00:09:58.598 
then nothing has happened to
this, then I can update it.

122
00:10:00.600 --> 00:10:06.606 
This very very short
phase now, I don't

123
00:10:06.606 --> 00:10:10.610 
know whether that is,
this is by probably

124
00:10:10.610 --> 00:10:14.614 
a comparant swap or something
like this, block, this

125
00:10:14.614 --> 00:10:18.618 
is not a real a real
database lock anymore.

126
00:10:18.618 --> 00:10:23.623 
I was pretty sure that
the database locks are

127
00:10:23.623 --> 00:10:27.627 
absolutely not necessary.
They are not necessary for the

128
00:10:27.627 --> 00:10:32.632 
duration of a transaction, which
is, we're talking nanoseconds

129
00:10:32.632 --> 00:10:35.635 
here. The record
is still there,

130
00:10:36.636 --> 00:10:41.641 
it is still valid, we
flag it now as updated and

131
00:10:42.642 --> 00:10:46.000 
write the new, insert the new one.
So this short period is probably

132
00:10:46.000 --> 00:10:51.651 
blocked but then the
database is totally

133
00:10:52.652 --> 00:10:56.656 
in a consistent state
and another transaction

134
00:10:57.657 --> 00:11:00.660 
which started
working here, on t2,

135
00:11:04.664 --> 00:11:09.669 
probably sees, still sees
when it started and this

136
00:11:09.669 --> 00:11:12.672 
hasn't happened, still
thought this was valid.

137
00:11:13.673 --> 00:11:19.679 
Now it has been changed here,
sees now before it inserts

138
00:11:19.679 --> 00:11:22.682 
updates, this is an update and
insert otherwise it doesn't make

139
00:11:22.682 --> 00:11:26.686 
sense. It reads
it, oh, it was just

140
00:11:26.686 --> 00:11:31.691 
updated and in this case

141
00:11:32.692 --> 00:11:36.696 
this would be rejected
and the application has

142
00:11:36.696 --> 00:11:42.702 
to deal with this, the
probability is minuscule.

143
00:11:43.703 --> 00:11:49.709 
Even in highest volume systems
like travel systems, flight booking

144
00:11:49.709 --> 00:11:50.710 
systems or
something like that.
