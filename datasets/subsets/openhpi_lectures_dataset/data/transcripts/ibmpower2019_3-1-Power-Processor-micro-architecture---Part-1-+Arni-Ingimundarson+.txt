WEBVTT

1
00:00:01.080 --> 00:00:03.749 
Welcome to this part

2
00:00:03.750 --> 00:00:05.399 
of the lecture series.

3
00:00:05.400 --> 00:00:07.679 
My name is Arni Ingimundarson and I want to

4
00:00:07.680 --> 00:00:09.629 
introduce you to the POWER process of

5
00:00:09.630 --> 00:00:12.239 
microarchitecture and giving you a

6
00:00:12.240 --> 00:00:15.079 
few samples from the history of

7
00:00:15.080 --> 00:00:16.080 
the POWER processor.

8
00:00:19.140 --> 00:00:20.429 
A few words about me.

9
00:00:21.510 --> 00:00:23.729 
I said, my name is Arni Ingimundarson and I studied

10
00:00:23.730 --> 00:00:26.039 
electrical engineering at the Technical University

11
00:00:26.040 --> 00:00:28.679 
of Darmstadt, specializing

12
00:00:28.680 --> 00:00:30.719 
on computer system and formal verification.

13
00:00:33.120 --> 00:00:36.209 
After 11 years at Texas Instruments, developing

14
00:00:36.210 --> 00:00:38.229 
ultra-lowPOWER microcontroller and secure

15
00:00:38.230 --> 00:00:40.829 
microcontrollers, I've been

16
00:00:40.830 --> 00:00:43.859 
with IBM since 2015 developing

17
00:00:43.860 --> 00:00:46.639 
arithmetic logic units and working with

18
00:00:46.640 --> 00:00:48.990 
SAP HANA on POWER team,

19
00:00:50.610 --> 00:00:52.769 
porting and supporting HANA on the POWER

20
00:00:52.770 --> 00:00:53.770 
architecture.

21
00:00:58.680 --> 00:01:02.279 
I want to split my

22
00:01:02.280 --> 00:01:04.378 
subject into four parts.

23
00:01:04.379 --> 00:01:06.159 
In this video, I will give you an overview of the

24
00:01:06.160 --> 00:01:07.619 
DLX, microarchitecture.

25
00:01:09.440 --> 00:01:12.209 
The second video, I will show

26
00:01:12.210 --> 00:01:13.980 
you the POWER4 and POWER5

27
00:01:15.180 --> 00:01:17.099 
microarchitecture.

28
00:01:17.100 --> 00:01:19.499 
The third video, I will give you an overview of the

29
00:01:19.500 --> 00:01:21.960 
POWER7 architecture, including

30
00:01:23.310 --> 00:01:26.609 
touching on the subject of symmetric multiprocessing

31
00:01:26.610 --> 00:01:28.919 
and the last lecture, I will give you an overview of

32
00:01:28.920 --> 00:01:30.110 
the POWER8 and POWER9.

33
00:01:35.080 --> 00:01:37.869 
The DLX processor architecture

34
00:01:37.870 --> 00:01:40.599 
was designed by Hennessy and

35
00:01:40.600 --> 00:01:41.600 
Patterson.

36
00:01:42.970 --> 00:01:45.399 
It's architecture is used mainly in the academic

37
00:01:45.400 --> 00:01:46.420 
world for teaching.

38
00:01:47.950 --> 00:01:50.930 
It is a simple 32 bit RISC

39
00:01:50.931 --> 00:01:54.109 
architecture based on the MIPS architecture.

40
00:01:55.360 --> 00:01:57.669 
It has 32 bit fixed-width

41
00:01:58.810 --> 00:02:00.694 
instructions set.

42
00:02:00.695 --> 00:02:03.579 
It has three instructions types and

43
00:02:03.580 --> 00:02:06.309 
the instructions are being processed by

44
00:02:06.310 --> 00:02:08.460 
the processor in a five-stage pipeline.

45
00:02:15.820 --> 00:02:17.919 
The instructions types of the

46
00:02:20.050 --> 00:02:22.899 
DLX architecture has three

47
00:02:22.900 --> 00:02:25.929 
types, and it shows

48
00:02:25.930 --> 00:02:27.610 
a significant and typical

49
00:02:29.680 --> 00:02:32.289 
way how the RISC instruction

50
00:02:32.290 --> 00:02:33.849 
sets usually are defined.

51
00:02:33.850 --> 00:02:36.639 
We see this as a homogenic set up with the

52
00:02:36.640 --> 00:02:39.549 
opcode always in the same position, that position

53
00:02:39.550 --> 00:02:41.559 
for all three types.

54
00:02:41.560 --> 00:02:44.649 
We also see that the source registered

55
00:02:44.650 --> 00:02:47.319 
bits defining the source register also on

56
00:02:47.320 --> 00:02:50.859 
the same type and then we have a varying

57
00:02:50.860 --> 00:02:52.839 
fields for the other types.

58
00:02:52.840 --> 00:02:56.019 
The three types are the

59
00:02:56.020 --> 00:02:58.539 
beginning with the I-type instruction, which is used

60
00:02:58.540 --> 00:03:01.449 
for load and store instruction, conditional branch

61
00:03:01.450 --> 00:03:04.329 
and jump to register instructions.

62
00:03:04.330 --> 00:03:07.119 
And here we see that we

63
00:03:07.120 --> 00:03:09.909 
have a field defining the source

64
00:03:09.910 --> 00:03:12.699 
register and the destination register, which

65
00:03:12.700 --> 00:03:14.940 
is unused, for example, for jump instruction.

66
00:03:17.700 --> 00:03:19.139 
The R-type instructions

67
00:03:20.640 --> 00:03:23.639 
type is used for all instructions

68
00:03:23.640 --> 00:03:26.969 
where we have to register operations.

69
00:03:26.970 --> 00:03:28.289 
We have an opcode,

70
00:03:29.700 --> 00:03:32.459 
we have a two-source register

71
00:03:32.460 --> 00:03:35.309 
defined and we have one destination register.

72
00:03:36.390 --> 00:03:39.599 
The function field at the end is

73
00:03:39.600 --> 00:03:42.869 
showing you what is defining which

74
00:03:42.870 --> 00:03:46.289 
or further defining the opcode, for example,

75
00:03:46.290 --> 00:03:48.989 
the specific types of arithmetic logic

76
00:03:48.990 --> 00:03:50.969 
unit operations.

77
00:03:50.970 --> 00:03:54.239 
And the third and the last instruction type

78
00:03:54.240 --> 00:03:56.999 
is the J-type instructions, which is used for

79
00:03:57.000 --> 00:04:00.169 
jump and link instructions.

80
00:04:05.900 --> 00:04:09.301 
The difference between CISC and

81
00:04:09.302 --> 00:04:10.879 
RISC architecture is

82
00:04:12.680 --> 00:04:15.139 
it's mainly in how the instructions words are

83
00:04:15.140 --> 00:04:16.489 
defined.

84
00:04:16.490 --> 00:04:19.009 
On the RISC side, we usually have a simpler set of

85
00:04:19.010 --> 00:04:21.889 
instructions and we have specific

86
00:04:21.890 --> 00:04:24.920 
instructions for memory access.

87
00:04:26.950 --> 00:04:30.159 
While on the CISC side, you can

88
00:04:30.160 --> 00:04:33.279 
often have special

89
00:04:33.280 --> 00:04:36.009 
operands of an instruction referencing

90
00:04:36.010 --> 00:04:37.010 
memory directly.

91
00:04:38.650 --> 00:04:41.619 
The one advantage of the RISC type instruction set

92
00:04:42.760 --> 00:04:46.269 
is that it has fixed width,

93
00:04:46.270 --> 00:04:48.879 
bit width which means that

94
00:04:48.880 --> 00:04:51.819 
if you have a window for

95
00:04:51.820 --> 00:04:54.729 
the instruction fetch that you always have a fixed

96
00:04:54.730 --> 00:04:57.699 
set of instructions being fetched with every window

97
00:04:57.700 --> 00:05:00.129 
while on the CISC side you have a variable-length

98
00:05:00.130 --> 00:05:01.130 
instructions.

99
00:05:02.800 --> 00:05:05.559 
So you have a little bit more effort

100
00:05:05.560 --> 00:05:08.079 
on the decoder side to decode the instruction.

101
00:05:10.960 --> 00:05:12.850 
Today, most modern processor,

102
00:05:13.900 --> 00:05:17.529 
at least internally, use a RISC like

103
00:05:17.530 --> 00:05:19.839 
micro instructions inside, which is not visible to

104
00:05:19.840 --> 00:05:20.840 
the outside.

105
00:05:26.190 --> 00:05:29.249 
The five-stage pipeline of a DLX

106
00:05:29.250 --> 00:05:30.600 
microprocessor or microarchitecture

107
00:05:32.670 --> 00:05:35.969 
is a

108
00:05:35.970 --> 00:05:38.651 
good example of one pipeline for a RISC

109
00:05:38.652 --> 00:05:41.439 
microcontroller or microprocessor.

110
00:05:43.110 --> 00:05:45.939 
We start with an instruction fetch

111
00:05:45.940 --> 00:05:48.830 
where the instructions are loaded from the memory.

112
00:05:50.710 --> 00:05:53.309 
When the instruction word has been

113
00:05:53.310 --> 00:05:56.069 
fetched, we need to decode it to

114
00:05:56.070 --> 00:05:57.569 
decide what to do.

115
00:05:57.570 --> 00:06:00.419 
And the third stage we execute that instruction.

116
00:06:02.590 --> 00:06:05.429 
And in the fourth state, we

117
00:06:05.430 --> 00:06:06.621 
execute memory accesses,

118
00:06:08.760 --> 00:06:12.719 
which not all does not apply to all instructions.

119
00:06:12.720 --> 00:06:16.049 
And in the fifth cycle, the Write Back cycles,

120
00:06:16.050 --> 00:06:18.719 
the results of the operation are written back into

121
00:06:18.720 --> 00:06:19.720 
the register field.

122
00:06:21.440 --> 00:06:24.199 
And this applies both to the memory as well

123
00:06:24.200 --> 00:06:27.079 
as register to register operations, the

124
00:06:27.080 --> 00:06:29.379 
results are written in the Write Back cycle.

125
00:06:33.020 --> 00:06:34.610 
Now, as you can see

126
00:06:36.440 --> 00:06:39.319 
that you have five cycles executing

127
00:06:39.320 --> 00:06:42.019 
one instructions, and

128
00:06:42.020 --> 00:06:44.899 
since each stage is usually

129
00:06:44.900 --> 00:06:47.929 
a separate logic function,

130
00:06:47.930 --> 00:06:48.930 
we can have

131
00:06:51.200 --> 00:06:53.839 
what is called pipelining of instruction.

132
00:06:53.840 --> 00:06:56.810 
So as soon as the first instruction has been fetched

133
00:06:58.880 --> 00:07:01.519 
and it's in the decode cycle, we

134
00:07:01.520 --> 00:07:04.399 
can use parallel to the decode

135
00:07:04.400 --> 00:07:05.779 
cycle of the first instruction.

136
00:07:05.780 --> 00:07:07.489 
We can fetch the next instruction.

137
00:07:10.180 --> 00:07:13.089 
And this can be done even

138
00:07:13.090 --> 00:07:16.119 
further for all five stages

139
00:07:17.680 --> 00:07:20.439 
so that we can have five instructions

140
00:07:20.440 --> 00:07:23.139 
in flight and in

141
00:07:23.140 --> 00:07:24.140 
parallel.

142
00:07:25.390 --> 00:07:28.269 
If pipelining is implemented, depends on

143
00:07:28.270 --> 00:07:31.059 
on the implementation of the architecture,

144
00:07:31.060 --> 00:07:34.719 
there are implementations available that do not

145
00:07:34.720 --> 00:07:37.329 
parallelize the instructions or pipelining

146
00:07:37.330 --> 00:07:40.119 
instructions, but there are quite

147
00:07:40.120 --> 00:07:41.489 
a few that will do so.

148
00:07:47.840 --> 00:07:50.959 
I want to take at this point

149
00:07:50.960 --> 00:07:53.540 
to show you a little bit more details on how

150
00:07:55.440 --> 00:07:56.730 
such a pipeline is

151
00:07:58.290 --> 00:08:00.509 
on high level implemented in the hardware

152
00:08:01.770 --> 00:08:04.439 
and this diagram I'm

153
00:08:04.440 --> 00:08:07.289 
showing, the five

154
00:08:07.290 --> 00:08:08.310 
pipeline stages,

155
00:08:10.080 --> 00:08:12.059 
these symbols here,

156
00:08:13.290 --> 00:08:16.859 
signals registers or latches

157
00:08:16.860 --> 00:08:18.779 
in the hardware which

158
00:08:20.100 --> 00:08:21.449 
store the data

159
00:08:24.000 --> 00:08:26.729 
and output of constant data over the whole clock

160
00:08:26.730 --> 00:08:30.059 
cycles. And they are updated

161
00:08:30.060 --> 00:08:31.350 
with every clock cycle.

162
00:08:32.789 --> 00:08:34.109 
So what happens in these systems

163
00:08:36.960 --> 00:08:39.869 
is that we have for the fetch

164
00:08:39.870 --> 00:08:42.029 
instruction for we have, for example, the

165
00:08:42.030 --> 00:08:44.669 
instruction address and this register

166
00:08:45.870 --> 00:08:49.769 
and the instruction address is then indexed

167
00:08:49.770 --> 00:08:50.849 
into the memory.

168
00:08:52.350 --> 00:08:54.779 
And given this address, the memory will

169
00:08:56.610 --> 00:08:59.789 
output the corresponding

170
00:08:59.790 --> 00:09:02.069 
words stored as that address.

171
00:09:02.070 --> 00:09:04.889 
And within the next rising

172
00:09:04.890 --> 00:09:06.989 
edge of the clock over the next clock cycle, we

173
00:09:06.990 --> 00:09:10.139 
store the results in this register here.

174
00:09:10.140 --> 00:09:13.919 
And parallel to that, the address

175
00:09:13.920 --> 00:09:17.489 
instruction address is being incremented

176
00:09:17.490 --> 00:09:20.249 
by the offset of the size of one

177
00:09:20.250 --> 00:09:22.019 
instruction words.

178
00:09:22.020 --> 00:09:24.840 
And in the DLX case, we have

179
00:09:26.400 --> 00:09:28.829 
a 32 bit instruction as of four bytes per

180
00:09:28.830 --> 00:09:29.830 
instruction.

181
00:09:31.290 --> 00:09:33.929 
The second

182
00:09:33.930 --> 00:09:36.989 
stage, the instruction decode stage,

183
00:09:36.990 --> 00:09:40.109 
here we have two operations

184
00:09:40.110 --> 00:09:41.639 
happening in parallel.

185
00:09:41.640 --> 00:09:44.399 
There is we are decoding the instructions, what

186
00:09:44.400 --> 00:09:47.159 
we need to do, as well

187
00:09:47.160 --> 00:09:49.769 
as reading all the register

188
00:09:50.790 --> 00:09:52.649 
referenced by that instruction word.

189
00:09:55.100 --> 00:09:56.325 
In the third cycle,

190
00:09:57.840 --> 00:10:00.479 
we take the data that has

191
00:10:00.480 --> 00:10:03.889 
been stored in this register

192
00:10:03.890 --> 00:10:06.739 
or in the snatch, and

193
00:10:06.740 --> 00:10:10.249 
we select the correct operands

194
00:10:10.250 --> 00:10:13.309 
depending on how the interaction was defined,

195
00:10:13.310 --> 00:10:15.949 
and we run it through the ALU, the arithmetic

196
00:10:15.950 --> 00:10:18.909 
logic unit, which performs additions,

197
00:10:18.910 --> 00:10:21.409 
subtractions and so on, depending on what

198
00:10:21.410 --> 00:10:24.649 
instruction types have been or instruction functions

199
00:10:24.650 --> 00:10:25.699 
have been implemented.

200
00:10:29.270 --> 00:10:32.209 
In the fourth cycle, we have a memory access

201
00:10:32.210 --> 00:10:35.059 
cycle, so for

202
00:10:35.060 --> 00:10:38.329 
read instructions, we are only

203
00:10:38.330 --> 00:10:40.969 
specifying the address here, which will give us

204
00:10:40.970 --> 00:10:43.669 
the data that was stored at that

205
00:10:43.670 --> 00:10:45.229 
address. For

206
00:10:46.460 --> 00:10:49.069 
store instructions, we both have the address as

207
00:10:49.070 --> 00:10:51.230 
well as the data to be stored

208
00:10:52.550 --> 00:10:54.769 
and the last cycle is showing us

209
00:10:55.950 --> 00:10:58.949 
that we have a path back to the register

210
00:10:58.950 --> 00:11:01.589 
file where the updated

211
00:11:01.590 --> 00:11:02.691 
results are being stored.

212
00:11:05.580 --> 00:11:08.549 
And just as a reminder,

213
00:11:08.550 --> 00:11:11.519 
looking at how the pipeline worked, these

214
00:11:11.520 --> 00:11:13.799 
five stages can be pipelined.

215
00:11:13.800 --> 00:11:16.549 
And we see everything is working in parallel.

216
00:11:19.320 --> 00:11:21.389 
I would like to point out one

217
00:11:22.590 --> 00:11:25.679 
minor thing here, which is actually

218
00:11:25.680 --> 00:11:28.469 
quite typical for high-level block

219
00:11:28.470 --> 00:11:29.470 
diagrams of

220
00:11:32.040 --> 00:11:34.649 
computer architecture or many things.

221
00:11:35.850 --> 00:11:38.459 
Usually, they show the bare minimum

222
00:11:38.460 --> 00:11:41.339 
of things that you want to show, which implies

223
00:11:41.340 --> 00:11:42.839 
that there are a lot of other things that are

224
00:11:42.840 --> 00:11:43.840 
hidden.

225
00:11:44.700 --> 00:11:47.849 
And one thing that I want to point out that is

226
00:11:47.850 --> 00:11:50.070 
hidden is that

227
00:11:51.210 --> 00:11:53.909 
the branch decision

228
00:11:53.910 --> 00:11:56.639 
or branch execution happens also

229
00:11:56.640 --> 00:11:57.999 
in the execution cycle.

230
00:11:59.190 --> 00:12:02.510 
And if we have a pipeline architecture,

231
00:12:04.510 --> 00:12:07.359 
we see that if

232
00:12:07.360 --> 00:12:10.119 
and if this let's assume that

233
00:12:10.120 --> 00:12:12.130 
we want that the second instruction

234
00:12:13.150 --> 00:12:14.470 
is a branch instruction.

235
00:12:15.820 --> 00:12:18.279 
We see that there are two more instructions that are

236
00:12:18.280 --> 00:12:21.519 
being fetched or worked on

237
00:12:21.520 --> 00:12:24.049 
while until these second instructions

238
00:12:25.090 --> 00:12:27.339 
in the execution phase where we actually have an

239
00:12:27.340 --> 00:12:30.129 
updated address or instruction

240
00:12:30.130 --> 00:12:32.949 
pointer and

241
00:12:32.950 --> 00:12:35.469 
this path is missing from this diagram.

242
00:12:39.330 --> 00:12:40.330 
And

243
00:12:44.170 --> 00:12:46.809 
that is a quite critical part of when

244
00:12:46.810 --> 00:12:49.479 
reading block diagrams of microarchitecture,

245
00:12:49.480 --> 00:12:52.599 
there is so many things that is implied

246
00:12:52.600 --> 00:12:55.299 
in the drawings that we need to think about.

247
00:12:56.680 --> 00:12:59.349 
And so please

248
00:12:59.350 --> 00:13:02.349 
keep that in mind when reading block diagrams, even

249
00:13:02.350 --> 00:13:04.179 
if things seems hard to understand.

250
00:13:05.420 --> 00:13:07.899 
That is often because there are something missing in

251
00:13:07.900 --> 00:13:08.900 
the diagram.

252
00:13:12.900 --> 00:13:13.900 
So,

253
00:13:17.710 --> 00:13:20.499 
before we finish this

254
00:13:20.500 --> 00:13:23.409 
video, I want to give you a

255
00:13:23.410 --> 00:13:26.439 
short overview of the history of the

256
00:13:26.440 --> 00:13:29.499 
POWER processors, what the history of the releases

257
00:13:29.500 --> 00:13:30.897 
of the different versions.

258
00:13:33.010 --> 00:13:35.739 
The POWER4 processor, which we will talk about

259
00:13:35.740 --> 00:13:37.389 
in the next video.

260
00:13:37.390 --> 00:13:39.999 
That is a consolidation of a longer

261
00:13:40.000 --> 00:13:42.749 
history within IBM with collaborations with

262
00:13:42.750 --> 00:13:43.750 
other companies

263
00:13:46.130 --> 00:13:48.644 
which resulted in the POWER4

264
00:13:50.120 --> 00:13:52.440 
chips and

265
00:13:53.720 --> 00:13:56.389 
IBM has been steadily developing

266
00:13:56.390 --> 00:13:59.089 
and inventing in the POWER architecture until we

267
00:13:59.090 --> 00:14:01.989 
have POWER9

268
00:14:01.990 --> 00:14:04.460 
released in 2017.

269
00:14:08.220 --> 00:14:10.949 
And as I said, we will touch upon

270
00:14:10.950 --> 00:14:13.950 
part of those in the next videos.

271
00:14:17.390 --> 00:14:20.239 
I have here a short list

272
00:14:20.240 --> 00:14:22.879 
of material for further

273
00:14:22.880 --> 00:14:25.609 
reading, which

274
00:14:25.610 --> 00:14:27.320 
I can quite recommend.

275
00:14:29.390 --> 00:14:31.034 
And with that, I

276
00:14:32.510 --> 00:14:34.939 
want to thank you for your attention this time and

277
00:14:34.940 --> 00:14:36.950 
hope to see you in the next video.
