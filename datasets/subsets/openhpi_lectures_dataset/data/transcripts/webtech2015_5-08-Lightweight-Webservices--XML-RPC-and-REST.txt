WEBVTT

1
00:00:04.590 --> 00:00:07.380 
Now we introduce Lightweight Webservices

2
00:00:07.820 --> 00:00:11.670 
and speak about XML- RPC &amp; REST.

3
00:00:13.480 --> 00:00:15.210 
Web Services. Web services

4
00:00:15.860 --> 00:00:22.560 
are designed and are standardized to have a tool kit for

5
00:00:23.630 --> 00:00:26.900 
program very large web application.

6
00:00:27.780 --> 00:00:29.930 
Web Applications at the enterprise scale-

7
00:00:31.030 --> 00:00:36.750 
this web service standards are quite complicated, are quite complex for all aspects.

8
00:00:37.150 --> 00:00:41.530 
They are definitions and standards proposed. So it's difficult

9
00:00:41.720 --> 00:00:45.230 
to design such applications. For that reason,

10
00:00:45.650 --> 00:00:50.520 
there was a request of lightweight alternatives to the web service standards,

11
00:00:51.150 --> 00:00:58.220 
and there are two- I want to introduce the first is the XML remote procedure call-

12
00:00:58.500 --> 00:01:00.800 
the XML RPC and the second

13
00:01:01.400 --> 00:01:04.580 
is our REST architectures.

14
00:01:05.610 --> 00:01:10.170 
The XML Remote Procedure Call- that was a historical predecessor

15
00:01:10.630 --> 00:01:16.120 
of the web services, and the web service protocols- the SOAP protocol

16
00:01:16.650 --> 00:01:20.480 
which was specified for the web services.

17
00:01:21.680 --> 00:01:24.500 
It is a very simple XML protocol

18
00:01:25.350 --> 00:01:29.630 
and can be used for remote method invocation.

19
00:01:30.600 --> 00:01:34.860 
And XML RPC uses a very limited

20
00:01:35.720 --> 00:01:41.070 
HTTP Vocabulary, HTP the Hypertext Transfer Protocol.

21
00:01:42.650 --> 00:01:46.920 
Rest-the REpresentational State Transfer

22
00:01:48.320 --> 00:01:51.230 
is architecture and not a technology.

23
00:01:52.250 --> 00:01:57.510 
It is a ROA- an architecture and Resource Oriented Architecture

24
00:01:58.200 --> 00:02:04.910 
and uses compared to XML RPC the complete HTTP vocabulary.

25
00:02:06.220 --> 00:02:12.560 
Meanwhile over the last year, the REST has prevailed over the XML RPC.

26
00:02:14.010 --> 00:02:20.430 
To give you an impression of XML RPC, let's consider only a very simple example.

27
00:02:21.020 --> 00:02:23.490 
And we consider a

28
00:02:24.620 --> 00:02:27.910 
shopping example. As a shopping cart and

29
00:02:28.720 --> 00:02:31.840 
as an application of the e-shop and

30
00:02:32.500 --> 00:02:38.100 
there is some item in the shopping cart, and this item should be deleted.

31
00:02:39.740 --> 00:02:45.130 
For an XML RPC there is only a usable supposed method.

32
00:02:47.090 --> 00:02:54.560 
Then here in the body of the request, the actual action has to be specified,

33
00:02:54.910 --> 00:02:56.980 
that has to be

34
00:02:58.230 --> 00:03:03.960 
performed within the object. And here in this case its 'delete'. So

35
00:03:04.130 --> 00:03:09.310 
the item should delete. And here later the item is described

36
00:03:09.330 --> 00:03:14.180 
which is the subject of the action that has to be performed.

37
00:03:17.950 --> 00:03:22.170 
Now we consider REST architectures- a presentational state transfer.

38
00:03:25.160 --> 00:03:30.480 
The web is resource oriented and REST shows a way to process these resources

39
00:03:30.900 --> 00:03:34.760 
exclusively with the http methods.

40
00:03:36.640 --> 00:03:40.930 
The HTTP path determines which resources

41
00:03:41.960 --> 00:03:46.810 
are processed and the http methods determine how

42
00:03:47.120 --> 00:03:49.240 
these resources are processed.

43
00:03:49.870 --> 00:03:54.670 
So there is a POST method that can be used to create resources.

44
00:03:55.370 --> 00:04:00.370 
There is a GET method- http GET methods that can be used to read

45
00:04:00.500 --> 00:04:07.290 
resources. So HTTP PUT methods can be used to update resources.

46
00:04:07.720 --> 00:04:12.270 
And finally the DELETE method can be used to

47
00:04:13.030 --> 00:04:14.900 
delete resources.

48
00:04:16.560 --> 00:04:21.060 
The data of which are in such a request

49
00:04:21.630 --> 00:04:27.590 
to be transferred, they are transported inside the body of the message.

50
00:04:31.920 --> 00:04:37.720 
There are two message types in http- we have the request message and we have the

51
00:04:38.030 --> 00:04:44.110 
response message. The HTTP protocol which was characterized in the

52
00:04:44.110 --> 00:04:45.950 
RFC 2016.

53
00:04:46.710 --> 00:04:51.250 
So the request message - they are a

54
00:04:52.420 --> 00:04:57.360 
need for describing the method that has to be applied. The GET,

55
00:04:57.370 --> 00:05:02.860 
POST, PUT or DELETE method. Then the path needs to be described.

56
00:05:02.860 --> 00:05:09.360 
The path as part of the URL here in this application of OpenHPI.

57
00:05:09.780 --> 00:05:13.430 
The resource that has to be manipulated is described

58
00:05:13.840 --> 00:05:17.850 
in the URL. You remember this was

59
00:05:19.480 --> 00:05:24.980 
the only way in a POST method to do. And then there follows a request header

60
00:05:25.210 --> 00:05:26.700 
and the request body.

61
00:05:27.880 --> 00:05:30.450 
Beside of that, there is a response message.

62
00:05:31.180 --> 00:05:34.240 
The response message- there is a status code,

63
00:05:34.790 --> 00:05:38.910 
for example 200 OK, or 403 forbidden or 404

64
00:05:38.910 --> 00:05:42.920 
Not Found. There is a response header

65
00:05:43.380 --> 00:05:45.410 
and the response body.

66
00:05:49.720 --> 00:05:54.070 
For REST application, there are four design principles.

67
00:05:54.750 --> 00:05:59.840 
The first design principle is that only the http methods GET, POST

68
00:05:59.960 --> 00:06:01.950 
PUT and DELETE are used.

69
00:06:02.620 --> 00:06:06.980 
The second design principle is that the REST application should be

70
00:06:07.290 --> 00:06:10.050 
described in a stateless way.

71
00:06:11.090 --> 00:06:16.640 
So all the necessary data need to be transferred upon a request.

72
00:06:17.840 --> 00:06:19.220 
Then third, the principle

73
00:06:20.120 --> 00:06:23.840 
else oriented on directory structures

74
00:06:24.550 --> 00:06:27.650 
and should be described,

75
00:06:28.320 --> 00:06:32.300 
should be named as intuitive as possible

76
00:06:32.900 --> 00:06:36.320 
to make it possible that in case of doubt

77
00:06:36.820 --> 00:06:39.790 
the right URL can be guessed.

78
00:06:41.250 --> 00:06:47.570 
And the fourth design principle is that the data is transferred as XML

79
00:06:47.930 --> 00:06:49.370 
or as JSON.

80
00:06:52.480 --> 00:06:59.190 
Then to explain the format of the data response,

81
00:06:59.670 --> 00:07:03.370 
the service notes MIME type of the request.

82
00:07:04.150 --> 00:07:09.900 
And then the server sends back the response in the appropriate MIME format.

83
00:07:11.660 --> 00:07:14.450 
Also to give an example for REST,

84
00:07:15.090 --> 00:07:18.300 
we take the same situation. We have a shopping cart,

85
00:07:18.880 --> 00:07:25.990 
there is a product to be deleted in this shopping cart and you see here

86
00:07:26.120 --> 00:07:32.240 
the description of the arrest code. It's much simpler than in the case

87
00:07:32.520 --> 00:07:38.850 
of the XML RPC. So it starts with the action that has to be performed

88
00:07:39.250 --> 00:07:43.440 
and this action is specified directly via the

89
00:07:44.650 --> 00:07:46.660 
method- the http method.

90
00:07:47.350 --> 00:07:54.750 
Then we have to give the subject on which the method has to be

91
00:07:55.050 --> 00:07:57.500 
applied and this item

92
00:07:58.790 --> 00:08:01.970 
as the subject is part of path.
