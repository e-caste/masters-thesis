WEBVTT

1
00:00:00.630 --> 00:00:04.660 
Welcome to this MOOC session. My name is Evelyn Lorz and I

2
00:00:04.660 --> 00:00:09.460 
am responsible for the openUTM transaction monitor at fujitsu.

3
00:00:10.470 --> 00:00:14.570 
This session will give you a brief overview on this platform's

4
00:00:15.190 --> 00:00:16.770 
concepts and functions.

5
00:00:19.840 --> 00:00:22.700 
Have you ever wondered about the purpose

6
00:00:23.230 --> 00:00:26.250 
of a transaction monitor like openUTM?

7
00:00:28.190 --> 00:00:33.790 
The common view is that the main task of a transaction monitor is to

8
00:00:34.340 --> 00:00:40.620 
assure data consistency and integrity for online transaction processing applications,

9
00:00:40.910 --> 00:00:44.410 
even in the case of problems like a system crash.

10
00:00:45.470 --> 00:00:49.260 
That of course is true but there are many more features.

11
00:00:50.230 --> 00:00:54.700 
Online transaction processing applications are required in banking or

12
00:00:54.880 --> 00:00:57.210 
for travel booking systems.

13
00:00:59.380 --> 00:01:03.980 
A transaction monitor will provide a robust run-time environment

14
00:01:04.310 --> 00:01:06.390 
for such kinds of application.

15
00:01:07.120 --> 00:01:12.350 
The application programmer will be able to focus on the business logic.

16
00:01:12.680 --> 00:01:15.920 
Meanwhile the transaction monitor provides

17
00:01:16.570 --> 00:01:20.790 
the core elements of transaction management and acts like a

18
00:01:20.790 --> 00:01:23.200 
high level operating system.

19
00:01:24.570 --> 00:01:29.990 
The transaction monitor optimizes system resources like cpu or memory. It

20
00:01:31.120 --> 00:01:35.390 
establishes network connection and a great deal more.

21
00:01:36.450 --> 00:01:41.790 
You may compare this functionality to that of a modern java based application server,

22
00:01:41.970 --> 00:01:44.770 
but in a classic cobol environment.

23
00:01:46.860 --> 00:01:53.980 
A very important feature of openUTM is that, it allows multiplex operations,

24
00:01:54.330 --> 00:01:59.220 
which means the parallel access for up to five hundred thousand users

25
00:01:59.520 --> 00:02:01.140 
in a transactional mode.

26
00:02:01.990 --> 00:02:07.290 
Of course openUTM takes care for the access control and the authorization

27
00:02:07.590 --> 00:02:14.060 
of all these users. OpenUTM coordinates heterogeneous resource managers,

28
00:02:14.410 --> 00:02:16.430 
like different databases.

29
00:02:17.320 --> 00:02:22.890 
It provides transaction security by using the 2 phase-commit protocol

30
00:02:23.050 --> 00:02:25.770 
and providing recovery and restart

31
00:02:26.470 --> 00:02:28.540 
functions in case of a failure.

32
00:02:32.390 --> 00:02:34.970 
Why do we call it openUTM?

33
00:02:35.590 --> 00:02:40.430 
On this slide you'll see the reference model that was defined

34
00:02:40.760 --> 00:02:47.300 
for distributed transaction processing model by the open group originally X/Open.

35
00:02:47.530 --> 00:02:52.110 
And it shows how openUTM supports this reference model.

36
00:02:53.570 --> 00:03:00.130 
X/Open was founded by a group of several european unix manufacturers

37
00:03:00.380 --> 00:03:04.840 
in order to provide open standards for information technology.

38
00:03:05.260 --> 00:03:11.380 
Later it merged with the open software foundation to form the open group.

39
00:03:11.720 --> 00:03:17.060 
The reference model defines basically four kinds of systems

40
00:03:17.180 --> 00:03:21.380 
and which is more important, a certain set of

41
00:03:21.890 --> 00:03:26.980 
protocols, standardized protocols to be used for the communication between

42
00:03:27.110 --> 00:03:28.230 
those systems.

43
00:03:29.590 --> 00:03:36.550 
There are application programs, resource managers, transaction managers and communication resource

44
00:03:36.680 --> 00:03:37.250 
managers.

45
00:03:38.940 --> 00:03:44.490 
A resource manager manages a certain part of a system's shared resources.

46
00:03:45.020 --> 00:03:48.260 
A typical resource manager is a database management system.

47
00:03:48.870 --> 00:03:54.030 
OpenUTM provides several internal resource managers, for example

48
00:03:54.250 --> 00:03:57.040 
for the management of local storage areas

49
00:03:57.440 --> 00:04:00.710 
that may be used for application specific data.

50
00:04:01.990 --> 00:04:03.760 
A transaction manager

51
00:04:04.640 --> 00:04:07.420 
obviously controls transactions.

52
00:04:09.010 --> 00:04:14.160 
The open group defined the standardized 'XA' interface for the

53
00:04:14.160 --> 00:04:19.070 
communication between a transaction manager and an external resource manager,

54
00:04:19.390 --> 00:04:21.730 
like a database system- like oracle.

55
00:04:23.780 --> 00:04:25.900 
A communication resource manager

56
00:04:27.230 --> 00:04:31.620 
controls the communication between an application program and

57
00:04:31.630 --> 00:04:35.260 
its clients or between two application programs.

58
00:04:36.880 --> 00:04:40.990 
The open group defined the RFC1006 protocol

59
00:04:40.990 --> 00:04:43.480 
as a standard for client communication.

60
00:04:44.760 --> 00:04:48.660 
openUTM provides the UPIC protocol which is based on

61
00:04:48.660 --> 00:04:50.880 
the RFC1006.

62
00:04:52.210 --> 00:04:55.250 
Another important protocol is the

63
00:04:56.160 --> 00:05:00.450 
LU6.1. This protocol is used for integrating into

64
00:05:00.850 --> 00:05:07.410 
IBM environments. OpenUTM is able to interact with the CICS

65
00:05:07.410 --> 00:05:09.510 
transaction monitor of OpenUTM of

66
00:05:10.960 --> 00:05:15.530 
IBM using the LU6.1 protocol.

67
00:05:16.820 --> 00:05:22.610 
Additionally openUTM supports the OSI transaction protocol.

68
00:05:23.850 --> 00:05:29.140 
On this slide you'll see how openUTMco-ordinates transactions

69
00:05:29.150 --> 00:05:33.990 
with several databases by using the two-phase commit protocol.

70
00:05:35.140 --> 00:05:40.490 
Data records stored to a database system are subject to the synchronization and

71
00:05:40.640 --> 00:05:45.830 
locking mechanisms of the database system and not to that of the transaction monitor.

72
00:05:46.750 --> 00:05:52.350 
Therefore to ensure global data consistency openUTM has to synchronize

73
00:05:53.480 --> 00:05:58.170 
the openUTM transaction with the transaction of the respective database

74
00:05:58.290 --> 00:06:04.500 
systems. You can see the openUTM transactions and the database

75
00:06:04.500 --> 00:06:09.270 
transactions as sub transactions of one global transaction.

76
00:06:09.990 --> 00:06:14.010 
The global transaction end can only be reached

77
00:06:14.490 --> 00:06:20.910 
if each sub transaction has reached the preliminary end of transaction

78
00:06:21.030 --> 00:06:26.680 
status. In other words in this example where we have two databases,

79
00:06:26.760 --> 00:06:32.320 
the database a and the database c. The openUTM transaction spends

80
00:06:32.730 --> 00:06:36.700 
the transactions of both databases.

81
00:06:37.330 --> 00:06:42.620 
The openUTM transaction can only be closed when both sub

82
00:06:42.620 --> 00:06:45.980 
transactions have been successfully completed.

83
00:06:47.850 --> 00:06:52.330 
If only one of this sub transactions will fail, openUTM

84
00:06:52.490 --> 00:06:55.580 
will have to reset both transactions.

85
00:06:56.880 --> 00:06:59.010 
This coordination efforts

86
00:06:59.660 --> 00:07:05.500 
of the transactions do not result in any additional efforts for the application

87
00:07:05.620 --> 00:07:06.280 
programmer.

88
00:07:10.080 --> 00:07:13.510 
The application programmer implements the business

89
00:07:13.950 --> 00:07:17.320 
logic into so called program units.

90
00:07:19.510 --> 00:07:24.310 
Each program unit provides a certain service to the business process.

91
00:07:25.830 --> 00:07:29.260 
A program may be implemented in C or C++.

92
00:07:30.410 --> 00:07:36.830 
Today many of the existing application programs are still implemented in COBOL.

93
00:07:38.490 --> 00:07:41.470 
On the BS2000, platform we additionally

94
00:07:42.270 --> 00:07:49.250 
provide a BS2000 assembler for Fortran, Pascal and PL/1.

95
00:07:50.640 --> 00:07:53.610 
A program unit runs under the control of the openUTM

96
00:07:54.250 --> 00:07:58.990 
transaction monitor. It communicates with the transaction monitor using

97
00:07:59.130 --> 00:08:02.720 
a certain set of standardized interfaces.

98
00:08:03.510 --> 00:08:09.190 
A program unit can directly access a database using SQL statements.

99
00:08:09.990 --> 00:08:13.080 
The openUTM coordinates the database

100
00:08:14.070 --> 00:08:18.910 
transactions either using the x/open standardized

101
00:08:19.330 --> 00:08:23.780 
interface or a BS2000 specific interface- the IUTMDB.

102
00:08:23.850 --> 00:08:29.620 
This is used for BS2000 databases like

103
00:08:30.380 --> 00:08:35.810 
Sesam/SQL, UDS or LEASY. The openUTM transaction monitor

104
00:08:36.480 --> 00:08:40.560 
is available on the fujitsu business server with the operating

105
00:08:40.560 --> 00:08:42.240 
system BS2000.

106
00:08:42.860 --> 00:08:43.820 
Unonventional

107
00:08:45.130 --> 00:08:50.420 
linux distributions on various unix systems first, of all solaris

108
00:08:50.900 --> 00:08:56.480 
but as well HP-UX or AIX and of course on windows platforms.

109
00:09:01.070 --> 00:09:06.270 
Let's look at a typical dialogue program unit implemented for openUTM.

110
00:09:07.630 --> 00:09:12.960 
In the left hand column you'll see the example code of such a program unit.

111
00:09:13.850 --> 00:09:18.610 
The application programmer will basically use four different types of calls

112
00:09:18.860 --> 00:09:24.860 
to open OpenUTM. That's the INIT call, the MPUT and the PEND call.

113
00:09:25.820 --> 00:09:29.830 
When the application program starts, openUTM will perform

114
00:09:29.970 --> 00:09:33.750 
the XA_open call towards the database.

115
00:09:36.430 --> 00:09:42.110 
The XA_Open call opens a connection towards the database.

116
00:09:43.560 --> 00:09:47.920 
For each program unit run the program unit has to register

117
00:09:48.350 --> 00:09:55.080 
at openUTM using the INIT call. This INIT call will

118
00:09:55.980 --> 00:09:59.410 
cause openUTM to call the XA_start

119
00:10:00.130 --> 00:10:01.440 
towards the database,

120
00:10:02.480 --> 00:10:07.000 
which opens a transaction between the program unit and the database.

121
00:10:08.220 --> 00:10:13.740 
The MGET call will cause OpenUTM to read a client message and

122
00:10:13.740 --> 00:10:15.740 
provide it to the program unit.

123
00:10:17.820 --> 00:10:23.820 
The program unit then starts processing this message. Let's assume its implemented

124
00:10:24.350 --> 00:10:29.730 
in cobol and works with an oracle database. It will retrieve

125
00:10:29.730 --> 00:10:36.500 
data from that oracle database, change that data and store them back using ESQL

126
00:10:36.680 --> 00:10:43.740 
statements. With the MPUT message the program unit defines the message

127
00:10:43.740 --> 00:10:49.240 
that is to be sent back to the client. OpenUTM will receive that message

128
00:10:49.440 --> 00:10:52.620 
but put it to a buffer only

129
00:10:53.290 --> 00:10:56.440 
because there might be other open transactions.

130
00:10:57.130 --> 00:11:01.540 
With a PEND call the program unit signals to openUTM that

131
00:11:01.540 --> 00:11:08.180 
the processing is finalized. OpenUTM will then call the XA-end,

132
00:11:09.640 --> 00:11:14.340 
which disassociates the program unit from the transaction.

133
00:11:14.800 --> 00:11:20.390 
Then it will call XA-prepare to set the preliminary end of transaction status

134
00:11:20.970 --> 00:11:27.530 
and with an XA_commit close the complete transaction, but only if

135
00:11:27.910 --> 00:11:30.860 
the sub transactions have been successful.

136
00:11:32.070 --> 00:11:36.440 
If the sub transactions failed openUTM will

137
00:11:38.880 --> 00:11:41.580 
reset all database transactions

138
00:11:42.500 --> 00:11:45.210 
and perform a rollback of the database

139
00:11:46.320 --> 00:11:51.220 
and dismiss the original message to the client. Instead it will send

140
00:11:51.600 --> 00:11:53.010 
a message of failure.

141
00:11:53.690 --> 00:11:57.820 
If everything was successful, openUTM will send the buffered

142
00:11:57.820 --> 00:11:59.140 
message to the client.

143
00:12:01.810 --> 00:12:05.750 
In the short time available here, I could only give you a very

144
00:12:05.750 --> 00:12:08.620 
brief look on the openUTM features.

145
00:12:10.390 --> 00:12:15.040 
I think however that this is sufficient to show that openUTM

146
00:12:15.040 --> 00:12:18.940 
is a powerful tool for online transaction processing.

147
00:12:19.470 --> 00:12:24.080 
Please remember openUTM is available on BS2000

148
00:12:24.570 --> 00:12:30.520 
on linux, on unix and on windows. And it allows the implementation of fault-tolerant

149
00:12:30.620 --> 00:12:33.240 
applications. Thank you.
