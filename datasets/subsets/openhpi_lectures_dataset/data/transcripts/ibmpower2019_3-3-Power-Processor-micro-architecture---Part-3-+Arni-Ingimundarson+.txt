WEBVTT

1
00:00:00.570 --> 00:00:02.490 
Welcome to the third video

2
00:00:04.170 --> 00:00:06.209 
in this part of the lecture series on the POWER

3
00:00:06.210 --> 00:00:07.829 
processor microarchitecture.

4
00:00:07.830 --> 00:00:09.169 
My name is Arni Ingimundarson.

5
00:00:11.290 --> 00:00:14.649 
This part, I want to give you a

6
00:00:14.650 --> 00:00:16.109 
very brief introduction of the POWER7

7
00:00:17.800 --> 00:00:21.249 
and then talk about the symmetric multiprocessing

8
00:00:21.250 --> 00:00:23.672 
aspects of a larger SMP

9
00:00:25.120 --> 00:00:26.120 
system.

10
00:00:28.090 --> 00:00:30.909 
In the last video we reviewed

11
00:00:30.910 --> 00:00:33.634 
or looked at the POWER4 and POWER5

12
00:00:34.900 --> 00:00:37.849 
processors, we looked at the instruction pipeline,

13
00:00:37.850 --> 00:00:41.529 
which is identical in both of them and

14
00:00:41.530 --> 00:00:43.861 
the core block diagram of those processors.

15
00:00:48.110 --> 00:00:50.990 
If we look at the next

16
00:00:52.490 --> 00:00:55.399 
processors in the POWER series, the POWER6 introduced

17
00:00:55.400 --> 00:00:58.040 
in 2007, having two

18
00:00:59.060 --> 00:01:00.060 
SMT2 cores, which is

19
00:01:01.970 --> 00:01:04.909 
same as the POWER5, we have the later

20
00:01:04.910 --> 00:01:08.119 
on POWER7 introduced

21
00:01:08.120 --> 00:01:10.939 
in 2010 where we have

22
00:01:10.940 --> 00:01:14.149 
an increased number of cores, on the

23
00:01:14.150 --> 00:01:17.059 
chip as well as an SMT4

24
00:01:17.060 --> 00:01:18.856 
core supporting 4 hardware threads

25
00:01:21.560 --> 00:01:22.560 
on each core.

26
00:01:24.740 --> 00:01:27.048 
That results in a computer

27
00:01:30.080 --> 00:01:32.509 
system where we have significantly many hardware threads

28
00:01:32.510 --> 00:01:36.289 
in the system. So the POWER6 has 128

29
00:01:36.290 --> 00:01:39.409 
hardware threads, but with POWER7, we are jumping

30
00:01:39.410 --> 00:01:43.159 
to 1024 hardware threads.

31
00:01:43.160 --> 00:01:46.669 
And even on the POWER8, which was introduced in

32
00:01:46.670 --> 00:01:50.239 
2014 with 12 SMT8 cores,

33
00:01:50.240 --> 00:01:52.507 
we have 1500 hardware threads.

34
00:01:54.020 --> 00:01:56.869 
So this poses

35
00:01:56.870 --> 00:01:59.689 
a problem on a big system

36
00:01:59.690 --> 00:02:02.239 
because we have many participants that need to

37
00:02:02.240 --> 00:02:03.559 
communicate with each other.

38
00:02:04.700 --> 00:02:07.279 
And so we will talk about that a little bit later on.

39
00:02:08.820 --> 00:02:11.799 
First, a very brief glimpse of the POWER7.

40
00:02:11.800 --> 00:02:14.899 
And here we see a chip photo

41
00:02:14.900 --> 00:02:15.900 
of the POWER7.

42
00:02:17.320 --> 00:02:20.759 
The POWER7 has a

43
00:02:20.760 --> 00:02:23.959 
dedicated or has a L3 cache

44
00:02:23.960 --> 00:02:26.369 
on chip for each cores.

45
00:02:26.370 --> 00:02:28.940 
So we have each core has its

46
00:02:30.710 --> 00:02:33.889 
L1 and L2 and

47
00:02:33.890 --> 00:02:36.055 
the ISU and the LSU.

48
00:02:37.190 --> 00:02:40.099 
We have a shared instruction data

49
00:02:40.100 --> 00:02:43.190 
Level-2 cache and the POWER7 introduced

50
00:02:44.630 --> 00:02:47.749 
an L3 cache on-chip which

51
00:02:47.750 --> 00:02:50.719 
is shared among all

52
00:02:50.720 --> 00:02:52.189 
the cores on the chip.

53
00:02:55.750 --> 00:02:58.599 
Looking at the core block diagram of the POWER7, we see

54
00:02:58.600 --> 00:03:01.479 
that that has gotten quite a bit

55
00:03:01.480 --> 00:03:04.359 
more complicated than the

56
00:03:04.360 --> 00:03:06.360 
POWER4 which we have here,

57
00:03:07.540 --> 00:03:11.499 
but still, we can quite easily map

58
00:03:11.500 --> 00:03:15.129 
the stages of the

59
00:03:15.130 --> 00:03:17.830 
DLX architecture to these stages here.

60
00:03:20.050 --> 00:03:22.689 
Very quick and fast over what we have here, the

61
00:03:22.690 --> 00:03:25.209 
instruction L1 cache.

62
00:03:25.210 --> 00:03:28.269 
We have an instruction fetch unit, decoding

63
00:03:28.270 --> 00:03:31.239 
unit, which maps to our instruction fetch and decode

64
00:03:31.240 --> 00:03:32.240 
stages.

65
00:03:34.690 --> 00:03:38.199 
The instructions are being dispatched to a

66
00:03:38.200 --> 00:03:39.659 
unified issue queue,

67
00:03:41.230 --> 00:03:44.109 
which handles all of the arithmetic instructions,

68
00:03:44.110 --> 00:03:46.613 
plus queues

69
00:03:49.750 --> 00:03:52.839 
for the branch and condition register operations,

70
00:03:52.840 --> 00:03:56.589 
as well as for some of the load and store

71
00:03:56.590 --> 00:03:59.889 
instructions or for the load and store instructions.

72
00:04:03.070 --> 00:04:05.050 
And the execution units

73
00:04:06.700 --> 00:04:09.969 
receives the instruction from the issue queues

74
00:04:09.970 --> 00:04:12.879 
corresponding to our execute instruction

75
00:04:12.880 --> 00:04:14.050 
execution states in the

76
00:04:17.019 --> 00:04:20.439 
DLX. The LSU unit manages the

77
00:04:20.440 --> 00:04:23.799 
data access to the memory through the L1

78
00:04:23.800 --> 00:04:24.800 
data cache.

79
00:04:26.560 --> 00:04:29.379 
And we have here up

80
00:04:29.380 --> 00:04:32.649 
here the completion

81
00:04:32.650 --> 00:04:34.470 
unit, as we saw in the and the POWER4

82
00:04:36.940 --> 00:04:38.042 
manages and

83
00:04:39.790 --> 00:04:42.099 
keeps books of all the instructions that are in flight

84
00:04:42.100 --> 00:04:44.919 
and the systems and removes them from the

85
00:04:44.920 --> 00:04:46.810 
books as soon as the instruction is complete.

86
00:04:49.130 --> 00:04:52.879 
We will talk more about that in the next video,

87
00:04:52.880 --> 00:04:55.190 
but remembering the increased number of

88
00:04:56.629 --> 00:05:00.049 
hardware threads in those starting

89
00:05:00.050 --> 00:05:02.959 
with POWER7 and later increased with

90
00:05:02.960 --> 00:05:06.019 
POWER8, we have

91
00:05:08.280 --> 00:05:10.830 
noticed that a number, of cores,

92
00:05:12.120 --> 00:05:15.089 
increases the number of communication channels

93
00:05:15.090 --> 00:05:17.609 
increases as well, and actually they are proportional to

94
00:05:17.610 --> 00:05:20.699 
N squared and the formula

95
00:05:20.700 --> 00:05:22.769 
for the number of channels given here.

96
00:05:22.770 --> 00:05:25.799 
And we need to take SMT modes into

97
00:05:25.800 --> 00:05:29.369 
account as well, because each hardware thread can be

98
00:05:29.370 --> 00:05:31.439 
running a different type of program.

99
00:05:32.880 --> 00:05:35.759 
And so the pressure on

100
00:05:35.760 --> 00:05:38.999 
the communication channels in the system increases

101
00:05:39.000 --> 00:05:40.740 
with the number of participants.

102
00:05:45.960 --> 00:05:48.269 
All the POWER processors

103
00:05:50.130 --> 00:05:53.339 
support SMP modes and

104
00:05:53.340 --> 00:05:56.159 
the topology of the systems in the earlier

105
00:05:56.160 --> 00:05:59.099 
system was as depicted here

106
00:05:59.100 --> 00:06:02.549 
where the POWER4 and POWER5 has a

107
00:06:02.550 --> 00:06:05.939 
ToroidTopology where we have

108
00:06:05.940 --> 00:06:09.759 
a unit consisting of

109
00:06:09.760 --> 00:06:12.749 
four cores, or

110
00:06:12.750 --> 00:06:13.942 
four sockets which are

111
00:06:16.800 --> 00:06:19.049 
fully connected to each other, so we have good

112
00:06:19.050 --> 00:06:21.989 
communication channels between, but

113
00:06:21.990 --> 00:06:25.529 
connecting this

114
00:06:25.530 --> 00:06:28.619 
module to the other modules, we have

115
00:06:28.620 --> 00:06:31.949 
a ring like structure connecting each

116
00:06:34.230 --> 00:06:37.379 
process on each corner to the next one.

117
00:06:37.380 --> 00:06:40.282 
The POWER5 increase the size of the Toroid,

118
00:06:42.390 --> 00:06:44.550 
supporting more chips.

119
00:06:46.290 --> 00:06:48.142 
But the topology remains the same.

120
00:06:50.010 --> 00:06:51.500 
Starting with POWER6 and POWER7,

121
00:06:53.280 --> 00:06:55.889 
the topology changes.

122
00:06:57.000 --> 00:07:00.029 
We have still

123
00:07:00.030 --> 00:07:02.909 
had modules with four chips

124
00:07:02.910 --> 00:07:04.680 
which are fully connected together,

125
00:07:05.940 --> 00:07:07.329 
but we have

126
00:07:10.410 --> 00:07:13.919 
each chip on the module

127
00:07:13.920 --> 00:07:16.979 
connects to up to two

128
00:07:16.980 --> 00:07:19.349 
other chips located on different models.

129
00:07:19.350 --> 00:07:23.069 
So if you look at that one module containing four chips

130
00:07:23.070 --> 00:07:25.949 
as one unit, we see that that unit

131
00:07:25.950 --> 00:07:28.949 
has connections to every other module

132
00:07:28.950 --> 00:07:29.950 
and this system.

133
00:07:33.860 --> 00:07:37.249 
This results in a topology

134
00:07:37.250 --> 00:07:40.069 
where we have three hops or three, we need

135
00:07:40.070 --> 00:07:42.829 
to cross three communication links

136
00:07:44.060 --> 00:07:47.250 
at most to be able to connect with every partner.

137
00:07:48.350 --> 00:07:51.349 
So assume, for example, we have this

138
00:07:51.350 --> 00:07:54.409 
chip we want to communicate with

139
00:07:54.410 --> 00:07:55.410 
this chip.

140
00:07:56.180 --> 00:07:58.100 
We first need to go over to this one.

141
00:07:59.390 --> 00:08:02.449 
Then we jump across the modules and then we

142
00:08:02.450 --> 00:08:06.169 
use the internal links of this module

143
00:08:06.170 --> 00:08:09.080 
to connect to this chip here.

144
00:08:16.250 --> 00:08:19.069 
POWER8 and POWER9 have a similar topology.

145
00:08:21.800 --> 00:08:25.189 
But what changes is that we have

146
00:08:25.190 --> 00:08:28.549 
more communication channels per

147
00:08:28.550 --> 00:08:31.699 
chip so that we can implement

148
00:08:31.700 --> 00:08:33.512 
a 2-hop topology.

149
00:08:35.740 --> 00:08:37.939 
POWER8 and POWER9 are

150
00:08:39.620 --> 00:08:42.769 
configured in a systems where we have

151
00:08:42.770 --> 00:08:45.514 
four chip support, four sockets per drawer.

152
00:08:47.510 --> 00:08:50.389 
These four chips in each drawer are fully

153
00:08:50.390 --> 00:08:53.569 
connected to each other, similar

154
00:08:53.570 --> 00:08:55.309 
to the modules on the

155
00:08:58.010 --> 00:08:59.419 
POWER4 and 5.

156
00:09:01.160 --> 00:09:04.039 
And then

157
00:09:04.040 --> 00:09:06.919 
each chip in

158
00:09:06.920 --> 00:09:09.919 
a drawer is connected to the corresponding chip

159
00:09:09.920 --> 00:09:12.619 
and all the other drawers in the system and the three

160
00:09:12.620 --> 00:09:13.939 
other drawers.

161
00:09:13.940 --> 00:09:17.779 
So we see that each chip has three internal connections

162
00:09:17.780 --> 00:09:21.019 
to the other three chips in the drawer

163
00:09:21.020 --> 00:09:24.179 
and three external connections to a chip

164
00:09:24.180 --> 00:09:27.049 
in three additional

165
00:09:27.050 --> 00:09:28.050 
drawers.

166
00:09:31.850 --> 00:09:35.239 
This gives us two possibilities

167
00:09:35.240 --> 00:09:36.671 
to communicate with different chips.

168
00:09:39.460 --> 00:09:42.289 
We have the option to first go across the

169
00:09:42.290 --> 00:09:45.319 
drawers and then within a draw to the chips

170
00:09:45.320 --> 00:09:48.529 
where we want to communicate with

171
00:09:48.530 --> 00:09:50.600 
or alternatively, we can

172
00:09:51.620 --> 00:09:55.579 
first do the hop inside our drawer before we go

173
00:09:55.580 --> 00:09:57.529 
directly to the chip and in the

174
00:09:58.790 --> 00:10:00.229 
drawer of our target.

175
00:10:04.300 --> 00:10:07.779 
Now the question arises, what communication

176
00:10:07.780 --> 00:10:10.659 
needs to happen over these

177
00:10:10.660 --> 00:10:13.779 
communication channels and the biggest

178
00:10:13.780 --> 00:10:16.599 
part of those communications

179
00:10:16.600 --> 00:10:17.685 
is the cache coherency.

180
00:10:20.330 --> 00:10:23.169 
The cores, they all need

181
00:10:23.170 --> 00:10:26.169 
to get the data from the L1

182
00:10:26.170 --> 00:10:29.409 
caches that the data must

183
00:10:29.410 --> 00:10:32.319 
reside in the L1 cache before the cores can use

184
00:10:32.320 --> 00:10:33.320 
them.

185
00:10:34.390 --> 00:10:37.569 
And the caches have

186
00:10:37.570 --> 00:10:40.479 
a bigger granule than a byte.

187
00:10:40.480 --> 00:10:43.299 
So we are usually talking about cache lines

188
00:10:44.890 --> 00:10:47.470 
that are being transferred between the chips.

189
00:10:48.580 --> 00:10:51.489 
And the cache lines that

190
00:10:51.490 --> 00:10:54.669 
we transfer, they can either come directly

191
00:10:54.670 --> 00:10:58.509 
from the memory or

192
00:10:58.510 --> 00:10:59.510 
if they are

193
00:11:01.420 --> 00:11:04.449 
modified in our neighbouring core or

194
00:11:04.450 --> 00:11:07.299 
a chip. We can get a copy of that

195
00:11:07.300 --> 00:11:09.309 
cache line from our neighbour.

196
00:11:10.840 --> 00:11:13.419 
And of course, if that cache line has been modified

197
00:11:13.420 --> 00:11:16.299 
somewhere in the system, we want to

198
00:11:16.300 --> 00:11:18.969 
read the latest version of the cache line and not

199
00:11:20.140 --> 00:11:23.619 
the one that is still in memory, which has old data.

200
00:11:23.620 --> 00:11:27.219 
So we need to always get the modified data from

201
00:11:27.220 --> 00:11:30.069 
our neighbours if it has

202
00:11:30.070 --> 00:11:31.070 
been modified.

203
00:11:33.050 --> 00:11:35.979 
And now the question arises, how

204
00:11:35.980 --> 00:11:38.859 
do we find out that the data has

205
00:11:38.860 --> 00:11:41.799 
been modified or how do we find out if our neighbour

206
00:11:41.800 --> 00:11:44.799 
has a copy of the cache line that we need

207
00:11:46.870 --> 00:11:49.299 
and the

208
00:11:50.560 --> 00:11:53.545 
POWER7, 8

209
00:11:53.546 --> 00:11:56.439 
and 9 implement a what is called

210
00:11:56.440 --> 00:11:59.319 
a scoped broadcast system to

211
00:11:59.320 --> 00:12:02.589 
find out where the cache line

212
00:12:02.590 --> 00:12:04.239 
may reside.

213
00:12:04.240 --> 00:12:07.149 
So if a core on one

214
00:12:07.150 --> 00:12:10.179 
socket, once we get a copy of a cache

215
00:12:10.180 --> 00:12:13.059 
line, it estimates

216
00:12:13.060 --> 00:12:14.410 
where it might find it.

217
00:12:16.000 --> 00:12:17.679 
And depending on the estimate,

218
00:12:19.090 --> 00:12:22.119 
we start with the smallest level of broadcast or we only

219
00:12:22.120 --> 00:12:24.639 
ask other cores on the same chip

220
00:12:25.780 --> 00:12:26.780 
and that is a

221
00:12:54.130 --> 00:12:54.151 
chip-level broadcast. And if we succeed, then our neighboring core on the same chip will give us a copy of the

222
00:12:54.152 --> 00:12:54.172 
cache line and we can continue working. The next level is on the drawer level. Here the broadcast reaches all the

223
00:12:54.173 --> 00:12:56.649 
sockets in the same drawer. And if any core in that

224
00:12:56.650 --> 00:13:00.459 
drawer has a copy of the cache line that we need,

225
00:13:00.460 --> 00:13:03.639 
we will get a copy of that cache line

226
00:13:03.640 --> 00:13:04.640 
sent to us.

227
00:13:06.430 --> 00:13:09.549 
And the third scope is if you don't find

228
00:13:09.550 --> 00:13:12.849 
the answer within our drawer, we need to broadcast

229
00:13:12.850 --> 00:13:13.850 
over the whole chip.

230
00:13:14.960 --> 00:13:17.969 
And we'll hopefully find

231
00:13:19.750 --> 00:13:21.010 
a copy of the cache line

232
00:13:24.280 --> 00:13:27.099 
somewhere in our system and latest the

233
00:13:27.100 --> 00:13:28.306 
memory where that cache line

234
00:13:30.340 --> 00:13:33.399 
has its permanent home will

235
00:13:33.400 --> 00:13:35.079 
respond to our broadcast.

236
00:13:38.260 --> 00:13:41.080 
So I hope that gave you a glimpse of

237
00:13:42.100 --> 00:13:45.112 
how the SMP architecture

238
00:13:46.950 --> 00:13:49.859 
needs to implement and so that we can

239
00:13:49.860 --> 00:13:53.459 
communicate through such many sockets

240
00:13:53.460 --> 00:13:56.339 
and at that point you again to

241
00:13:56.340 --> 00:13:59.609 
our reading list with

242
00:13:59.610 --> 00:14:02.579 
interesting paper that IBM publishes, for example, on

243
00:14:02.580 --> 00:14:05.059 
every POWER processor that releases.

244
00:14:06.060 --> 00:14:09.179 
And with that, I thank you very much

245
00:14:09.180 --> 00:14:11.369 
for your attention this time and hope to see you in the

246
00:14:11.370 --> 00:14:12.370 
next video.
