WEBVTT

0
00:00:00.290 --> 00:00:02.830 
Welcome everyone! In this video,

1
00:00:02.830 --> 00:00:08.210 
we're gonna actually learn how to use the real devices that we

2
00:00:08.210 --> 00:00:13.360 
have access to through the IBM quantum services platform and

3
00:00:13.360 --> 00:00:17.360 
there are some intermediate steps that we have to do in order

4
00:00:17.360 --> 00:00:21.580 
to be able to run our circuits in these backends.

5
00:00:22.110 --> 00:00:24.960 
So let's go back to the Quantum lab

6
00:00:27.050 --> 00:00:31.330 
and now we will be using the file real backend executions.

7
00:00:33.730 --> 00:00:40.380 
So first of all, as usual let's import and load our account

8
00:00:43.060 --> 00:00:44.590 
and I'll check the backends

9
00:00:45.810 --> 00:00:49.120 
that we have access to. In this case as you see,

10
00:00:49.130 --> 00:00:53.470 
we can output more things such as the number of qubits,

11
00:00:53.470 --> 00:00:57.560 
which is important to take into account because depending on

12
00:00:57.560 --> 00:01:01.320 
our circuit we will need one backend or another.

13
00:01:01.810 --> 00:01:05.379 
So, as you probably already remember,

14
00:01:05.390 --> 00:01:10.890 
the simulator has 32 qubit, can simulate up to 32 qubits.

15
00:01:10.900 --> 00:01:16.080 
And then we have one backend that is armed only with one qubit,

16
00:01:16.610 --> 00:01:19.920 
that is mostly used for by people that

17
00:01:19.930 --> 00:01:23.960 
are researching about quantum hardware.

18
00:01:23.970 --> 00:01:27.840 
Then we have these real devices of five qubits and then

19
00:01:27.840 --> 00:01:32.140 
we have other simulators that we saw in the previous video

20
00:01:33.170 --> 00:01:37.860 
and there you have the the information on the qubits

21
00:01:37.860 --> 00:01:43.700 
they can simulate. Finally IBMQ Manila as well has five qubits.

22
00:01:44.860 --> 00:01:52.750 
So, now another tool that is also important, it's the Qiskit backend overview,

23
00:01:52.760 --> 00:01:58.300 
it will probably remind you of what we saw directly in the platform.

24
00:01:58.310 --> 00:02:02.230 
And here you can also check information about

25
00:02:02.240 --> 00:02:04.830 
each of the devices that you have access to.

26
00:02:05.990 --> 00:02:11.930 
So yeah, in this case you have the number of qubits, the quantum volume,

27
00:02:11.940 --> 00:02:17.750 
how many jobs are pending in each of them,

28
00:02:18.880 --> 00:02:25.170 
if it actually has some pending jobs or if it's already

29
00:02:25.730 --> 00:02:30.070 
free. Also some

30
00:02:30.950 --> 00:02:33.970 
information about the

31
00:02:34.180 --> 00:02:38.350 
error rates and we can explore all about it here.

32
00:02:39.500 --> 00:02:41.630 
Let me just,

33
00:02:44.470 --> 00:02:47.320 
okay this, so that we can see it bigger.

34
00:02:48.030 --> 00:02:56.000 
Okay, so one very useful function that we have access to is the least busy function.

35
00:02:56.010 --> 00:03:03.500 
So, we can select a backend, telling it that we want the one that has a shorter queue

36
00:03:04.330 --> 00:03:07.510 
and we can also add some filters.

37
00:03:07.510 --> 00:03:12.670 
So, for instance, if we need more than two kqubits, we could add

38
00:03:12.670 --> 00:03:16.230 
these conditions, so that the number of qubits is bigger or equal than two.

39
00:03:16.930 --> 00:03:22.260 
Of course it's always better to choose the newest backend and to

40
00:03:22.260 --> 00:03:28.300 
choose the one with the highest quantum volume.

41
00:03:28.310 --> 00:03:36.110 
But in this case since our goal is just to learn how to use it,

42
00:03:36.120 --> 00:03:39.370 
there is least busy backend, it's the optimal one.

43
00:03:40.460 --> 00:03:45.950 
So, here we can check all the information about the qubits, the multi qubit kits,

44
00:03:45.960 --> 00:03:47.780 
the ever map.

45
00:03:47.790 --> 00:03:51.600 
This is something that we can also output directly from the backend.

46
00:03:51.600 --> 00:03:55.720 
But here in this visualization we have all the information.

47
00:03:56.240 --> 00:04:01.950 
In this case IBMQ Quito is the least busy device

48
00:04:01.960 --> 00:04:04.030 
and this is the one that we are going to use.

49
00:04:04.970 --> 00:04:09.380 
So, let's go back to our well known bell state.

50
00:04:10.200 --> 00:04:12.750 
How did we run it in a simulator?

51
00:04:12.760 --> 00:04:18.050 
We saw that in the previous video, selected the backend and run.

52
00:04:24.820 --> 00:04:34.470 
So, now remember that we have selected as backend the least busy one. So it's

53
00:04:35.070 --> 00:04:43.170 
IBMQ Quito that we have tried to run it and it appeared here a message that said job failed.

54
00:04:43.700 --> 00:04:50.090 
And actually if we output the job result, we're gonna get more information on.

55
00:04:50.100 --> 00:04:52.460 
Why did we get this error?

56
00:04:53.890 --> 00:04:56.760 
So, here it says IBMQ

57
00:04:56.770 --> 00:05:02.880 
Job failure error, unable to restrict results for job blah blah blah.

58
00:05:02.890 --> 00:05:09.590 
Job has failed. The queue object uses gates Hadamard that are not among the basis

59
00:05:09.590 --> 00:05:10.540 
gates.

60
00:05:11.390 --> 00:05:15.640 
So, what is it trying to tell us? What it's telling us,

61
00:05:15.650 --> 00:05:19.940 
is that because we have chosen this backend the IBMQ

62
00:05:19.940 --> 00:05:25.230 
Quito and the IBMQ Quito has a concrete set of basis

63
00:05:25.230 --> 00:05:27.800 
gates that, we can check here.

64
00:05:27.810 --> 00:05:30.020 
And in our circuit

65
00:05:32.290 --> 00:05:35.740 
we had used a Hadamard gate,

66
00:05:39.830 --> 00:05:46.820 
it's not a gate that can be recognized by our backend. So, what do we have to do in this case?

67
00:05:46.830 --> 00:05:50.540 
And this is where we introduce the transpiler, the transpiler,

68
00:05:50.540 --> 00:05:54.820 
is this tool that will enable us to translate our circuit

69
00:05:54.830 --> 00:06:01.750 
into a circuit that is equivalent and our backend can actually run.

70
00:06:03.130 --> 00:06:06.670 
So, that's what we're doing here. And let's print

71
00:06:07.260 --> 00:06:08.510 
the new circuit.

72
00:06:08.520 --> 00:06:09.620 
So as you see,

73
00:06:09.630 --> 00:06:17.360 
we have passed from this to this, it even ask adds some auxiliary

74
00:06:17.370 --> 00:06:24.980 
qubits, because in this case our backend has five qubits and therefore it

75
00:06:24.980 --> 00:06:30.420 
just adds some extra qubits that are auxiliary and that they don't do anything

76
00:06:30.420 --> 00:06:34.290 
but they have to be there because our physical qubit has five qubits.

77
00:06:35.040 --> 00:06:40.680 
And as you see it also has composed the Hadamard into three gates

78
00:06:40.690 --> 00:06:45.680 
that are among the ones that were part of the basis gates of our backend.

79
00:06:46.870 --> 00:06:49.750 
So, now let's try again to run it.

80
00:06:51.440 --> 00:06:54.920 
And with this job status we can check

81
00:06:55.450 --> 00:06:57.150 
the status of our job.

82
00:06:58.610 --> 00:06:59.930 
It's queued,

83
00:07:01.330 --> 00:07:02.610 
queued again,

84
00:07:04.610 --> 00:07:06.890 
it will at some point finish.

85
00:07:06.900 --> 00:07:14.210 
So, now it was sent, were also obtain information here that pops up in our window.

86
00:07:15.770 --> 00:07:16.900 
Queued.

87
00:07:21.160 --> 00:07:26.880 
So, let's go back just to check how many jobs there were

88
00:07:28.080 --> 00:07:29.790 
in the queue.

89
00:07:31.080 --> 00:07:37.710 
Pending jobs three at the time when we were selecting it. Not sure how many. But

90
00:07:38.390 --> 00:07:41.080 
yeah let's see if it has finished.

91
00:07:41.680 --> 00:07:48.010 
Well, it will eventually finish, right now we can just check the results that I got

92
00:07:48.020 --> 00:07:57.270 
before and as you see, this is different from where we were observing before.

94
00:07:59.620 --> 00:08:05.110 
Okay so finally it's actively running and it shouldn't take too long.

95
00:08:06.470 --> 00:08:08.260 
It has successfully run.

96
00:08:09.280 --> 00:08:12.030 
Perfect, so now we can print it.

97
00:08:15.400 --> 00:08:23.810 
And here we can observe that even though we were expecting to see 50% more or

98
00:08:23.810 --> 00:08:28.890 
less of the 00 and the 11 state, because we are running this in a real device.

99
00:08:28.890 --> 00:08:31.030 
We are also serving some nice.

100
00:08:32.330 --> 00:08:34.390 
So, let's keep moving.

101
00:08:37.520 --> 00:08:42.200 
And another important thing if you think about it, it's

102
00:08:42.210 --> 00:08:46.350 
that we have this backend, in this case IBMQ Quito

103
00:08:47.500 --> 00:08:50.650 
and we are using qubit zero and one.

104
00:08:51.340 --> 00:08:56.210 
And let's have a look into more details at the gates that we're applying.

105
00:08:56.220 --> 00:08:59.450 
So, two Q zero, we are applying three gates,

106
00:08:59.450 --> 00:09:02.480 
we still don't know which one is Q zero and then we

107
00:09:02.480 --> 00:09:08.050 
are applying an operation that takes, that they supply to two qubits.

108
00:09:08.060 --> 00:09:11.580 
Therefore we will need these two qubits to be connected but

109
00:09:11.580 --> 00:09:14.080 
that's not the case for all the qubits in the backend.

110
00:09:14.090 --> 00:09:19.510 
So, there is a good way to choose what we call the initial layout

111
00:09:19.720 --> 00:09:21.760 
and in this case it's very easy because single qubit operations

112
00:09:23.260 --> 00:09:28.490 
don't need any kind of connectivity and we only have a security operations that

113
00:09:28.500 --> 00:09:33.040 
involve two qubits and we have several qubits that are connected among each other.

114
00:09:33.050 --> 00:09:36.160 
So, we we should choose two qubits that are

115
00:09:36.160 --> 00:09:39.580 
actually connected but then again please keep in mind

116
00:09:39.580 --> 00:09:44.800 
that we did not have the same connection error rates for each of them, for all of them.

117
00:09:44.990 --> 00:09:49.610 
So, if we check the error map for our backend, there are some qubits

118
00:09:49.610 --> 00:09:53.800 
that are better, that have better error rate

119
00:09:53.800 --> 00:09:58.270 
connection and also have better readout error.

120
00:09:58.280 --> 00:10:02.730 
So, therefore we will have to take all of

121
00:10:02.730 --> 00:10:05.930 
these things into account when running an experiment.

122
00:10:07.250 --> 00:10:11.820 
And these are things that should be selected by us or can

123
00:10:11.820 --> 00:10:19.580 
be selected using what we call the optimization levels.

124
00:10:20.200 --> 00:10:24.700 
So, let's do a more interesting example in this case

125
00:10:24.700 --> 00:10:27.690 
if we transpiled this circuit for our backend,

126
00:10:27.690 --> 00:10:31.410 
you see that it has nothing to do with the one that we had before,

127
00:10:31.420 --> 00:10:38.150 
it has been translated in a much much deeper circuit.

128
00:10:38.150 --> 00:10:39.840 
But this is what actually gets

129
00:10:40.080 --> 00:10:41.360 
executed in the real backend.

130
00:10:41.370 --> 00:10:49.160 
So, even if we have written circuit with depth 5, what

131
00:10:49.160 --> 00:10:52.750 
will be actually executing the real backend is much longer.

132
00:10:52.760 --> 00:10:57.450 
The errors come from anything we do, from our deliberations.

133
00:10:57.460 --> 00:11:02.780 
So, it's important to take into account and that we want to optimize the circuits, but

134
00:11:02.780 --> 00:11:07.350 
then the circuit that we write here is not exactly the one that gets executed.

135
00:11:09.210 --> 00:11:10.190 
There is a layout,

136
00:11:10.190 --> 00:11:15.020 
we have said that it's important. So, in this case we're gonna choose it manually

137
00:11:15.030 --> 00:11:19.960 
and if we choose it manually since we are doing operations between 01 and 2,

138
00:11:19.970 --> 00:11:24.730 
these two qubits, we will need, you see that there

139
00:11:24.730 --> 00:11:27.590 
are some operations that involve Q zero and Q one,

140
00:11:27.590 --> 00:11:32.730 
Q two and Q one, Q one and Q zero

141
00:11:33.300 --> 00:11:40.370 
And okay here there is no operation between Q2 and Q0 but could be the case.

142
00:11:40.380 --> 00:11:43.660 
So, what do in that case because they are not physically connected.

143
00:11:43.660 --> 00:11:45.140 
If we choose them this way,

144
00:11:45.150 --> 00:11:49.690 
we will have to add some swap gates that are

145
00:11:49.700 --> 00:11:56.010 
are these gates that swap the values of two

146
00:11:56.170 --> 00:11:56.820 
qubits.

147
00:11:58.730 --> 00:12:01.450 
And this is also a problem, because we are introducing

148
00:12:01.450 --> 00:12:05.390 
more CNOT gates and therefore we will have more noise.

149
00:12:05.400 --> 00:12:09.810 
So, how to take care of coming up with a good layout,

150
00:12:09.820 --> 00:12:21.340 
with a good combination of swaps, choosing the better,

151
00:12:21.340 --> 00:12:23.950 
the best qubits in terms of error rates.

152
00:12:24.380 --> 00:12:26.430 
So, for that we have the optimization levels

153
00:12:26.440 --> 00:12:31.000 
and optimization levels are each of them

154
00:12:31.000 --> 00:12:36.250 
does something, there are 3, 0 does nothing.

155
00:12:36.260 --> 00:12:40.220 
And here you can read about what each of them takes care of,

156
00:12:40.870 --> 00:12:45.660 
but basically let's try for this complete circuit,

157
00:12:45.670 --> 00:12:48.450 
what each of the levels could add.

158
00:12:48.460 --> 00:12:52.740 
It is a stochastic process, transpiring there is.

160
00:12:54.710 --> 00:12:57.050 
It's not easy to come up with the,

161
00:12:57.060 --> 00:13:01.630 
with the best combination of swap gates or with

162
00:13:01.630 --> 00:13:06.410 
the optimal initial layout maybe for such a small circuit

163
00:13:06.410 --> 00:13:10.850 
just, but what if we have thousands of qubits and

164
00:13:10.860 --> 00:13:15.580 
again with many different possibilities of choosing the qubits.

165
00:13:15.580 --> 00:13:19.330 
It's a difficult problem.

166
00:13:20.610 --> 00:13:24.320 
But luckily for us there are some stochastic methods that select

167
00:13:24.330 --> 00:13:28.970 
all of these things and now let's see for our example,

168
00:13:29.990 --> 00:13:31.280 
how it will look like.

169
00:13:33.250 --> 00:13:33.820 
Okay.

170
00:13:35.260 --> 00:13:45.970 
It's also possible to select our own coupling map, this is what we are doing here.

171
00:13:49.570 --> 00:13:51.870 
They need to lay out in a couple of them up.

172
00:13:53.030 --> 00:13:54.470 
We transpile it again

173
00:13:54.610 --> 00:13:56.860 
and count how many operations we have.

174
00:13:57.810 --> 00:14:02.280 
Adding up also the optimization level and as

175
00:14:02.280 --> 00:14:06.240 
you see this will be the more

176
00:14:07.160 --> 00:14:12.620 
better, this will be the best possible

177
00:14:12.630 --> 00:14:15.110 
circuit that we can send to the actual backend.

178
00:14:15.120 --> 00:14:19.400 
So, here we compute the depth of each of the

179
00:14:19.410 --> 00:14:24.680 
circuits, when we are changing the different parameters.

180
00:14:25.930 --> 00:14:29.460 
And the last thing that I wanted to show you in real

181
00:14:29.460 --> 00:14:33.010 
backend execution is we mentioned in the beginning of the course that

182
00:14:33.280 --> 00:14:35.510 
Qiskit was a hardware agnostic.

183
00:14:35.520 --> 00:14:39.120 
So, this is an example on how you would run your

184
00:14:39.120 --> 00:14:42.380 
experiment if you were using, for example, the IONQ.

185
00:14:42.380 --> 00:14:43.320 
Provider.

186
00:14:43.330 --> 00:14:48.610 
I'm not gonna execute it because I don't have an account, but you

187
00:14:48.610 --> 00:14:52.780 
can easily create one, it's temporary, but you can easily create one.

188
00:14:52.780 --> 00:14:54.630 
You will input your token here,

189
00:14:54.810 --> 00:14:59.930 
you will see the kind of agnost that you have access to construct the circuit

190
00:14:59.930 --> 00:15:08.370 
as before and then run your your circuit in an ion trap and you could

191
00:15:08.370 --> 00:15:14.330 
also get the results and plot the the convictionary in a Histogram. And with

192
00:15:14.330 --> 00:15:21.320 
that we have finished the real backend execution and this concludes week one.

193
00:15:21.640 --> 00:15:26.190 
So, thank you so much for following all

194
00:15:26.190 --> 00:15:31.540 
these courses and next week Elisa will start explaining

195
00:15:31.550 --> 00:15:34.920 
how to combine all these tools that you learned,

196
00:15:34.930 --> 00:15:39.760 
to apply them for implementing some quantum algorithms.

197
00:15:39.770 --> 00:15:45.510 
Thank you so much! and have a nice second week.
