WEBVTT

1
00:00:00.950 --> 00:00:05.270 
This is knowledge graph lecture number
3, Querying RDFS with SPARQL.

2
00:00:05.580 --> 00:00:09.080 
This is the final part of this
lecture in which we talk again

3
00:00:09.080 --> 00:00:12.920 
about SPARQL and you will see
that SPARQL is more than just

4
00:00:12.920 --> 00:00:14.470 
a plain query language.

5
00:00:16.060 --> 00:00:20.960 
We are already or still on the
query level in the semantic

6
00:00:20.960 --> 00:00:26.310 
web technology stack and now we finalize
what we already know about SPARQL.

7
00:00:27.010 --> 00:00:32.030 
You remember besides being a query language
SPARQL was also a protocol layer

8
00:00:32.200 --> 00:00:37.310 
and also an output specification format
for the SPARQL queries and this is

9
00:00:37.570 --> 00:00:40.680 
where we are going to start now
in this part of the lecture.

10
00:00:40.680 --> 00:00:44.700 
So first we want to focus on this
XML output format specification,

11
00:00:45.420 --> 00:00:49.390 
in case you address directly a
SPARQL and point of course

12
00:00:49.390 --> 00:00:52.830 
you want to be able to interpret its
output, in this, of course, is here

13
00:00:53.130 --> 00:00:57.370 
a standardized in the following way.
So this is an XML document that is

14
00:00:57.810 --> 00:01:02.560 
given back and you see there
that you have here a part

15
00:01:02.560 --> 00:01:06.560 
which is named SPARQL so you
have a SPARQL tech there and

16
00:01:06.560 --> 00:01:08.360 
this gives us
SPARQL namespace.

17
00:01:09.220 --> 00:01:14.400 
Followed first by a head section in
that file and the head section

18
00:01:14.670 --> 00:01:20.080 
contains all of the variables of the
SPARQL query. So all variables that

19
00:01:20.080 --> 00:01:25.480 
the SPARQL query contained are listed
here in the head field that you see there

20
00:01:25.770 --> 00:01:29.800 
a tag called variable, and then
name, and then comes the name

21
00:01:29.800 --> 00:01:34.220 
of the variable which here in
our example is x, hpage, name,

22
00:01:34.230 --> 00:01:35.830 
mbox or blurb.

23
00:01:37.580 --> 00:01:40.730 
Below the head section then
comes the result section where

24
00:01:40.730 --> 00:01:46.210 
the original SPARQL results really reside
and each of the results consist of single

25
00:01:46.400 --> 00:01:51.610 
query results. So the result
section has another tag inside

26
00:01:51.610 --> 00:01:55.630 
nested which is simply called
result and there in this result

27
00:01:56.810 --> 00:02:02.380 
bindings for specific variables
are given and these variables

28
00:02:02.380 --> 00:02:07.620 
are bound to their achieved
results row by row, line by line.

29
00:02:07.620 --> 00:02:12.110 
So first here for example
for the binding of the

30
00:02:12.880 --> 00:02:16.820 
variable with the name x, then
some code or some result will

31
00:02:16.820 --> 00:02:20.770 
be given here and then the same for
the variable with the name hpage.

32
00:02:21.990 --> 00:02:24.360 
You see here a few examples
because there are

33
00:02:24.990 --> 00:02:29.230 
that's a different types of results
possible. So the first one

34
00:02:29.460 --> 00:02:32.390 
gives back for example a blank
node. Therefore you have here

35
00:02:32.390 --> 00:02:36.980 
the tag b node. The second one give
simply back a URI, therefore

36
00:02:36.980 --> 00:02:41.660 
the tag URI within the binding
or it can also give back a literal.

37
00:02:41.830 --> 00:02:47.810 
So you see here a literal with a
language attribute. And also

38
00:02:47.810 --> 00:02:51.780 
what you can do for example you can
give back data typed literals

39
00:02:51.780 --> 00:02:55.980 
by explicitly stating what kind
of data type has been used

40
00:02:55.980 --> 00:03:00.830 
for a specific literal that you
see. So lots of varieties that

41
00:03:00.830 --> 00:03:06.990 
then will be parsed by the application
or service that had connected

42
00:03:07.120 --> 00:03:12.340 
the SPARQL endpoint and has asked
the SPARQL query and then

43
00:03:12.410 --> 00:03:16.910 
this is the result that comes back and
has to be further processed of course. So this

44
00:03:18.080 --> 00:03:20.170 
is the output
specification.

45
00:03:21.870 --> 00:03:24.260 
Let's take a quick look
into the protocol layer.

46
00:03:24.680 --> 00:03:28.690 
We know that SPARQL of course
is a client server application

47
00:03:28.690 --> 00:03:32.560 
where we have the SPARQL end server that
is accessed via a client which usually

48
00:03:32.790 --> 00:03:36.510 
resides on that same browser and
the query is done over the

49
00:03:36.510 --> 00:03:40.190 
web and the transport of the query
of course is done via http.

50
00:03:40.500 --> 00:03:44.660 
And on top of http there is the
SPARQL protocol layer and

51
00:03:44.660 --> 00:03:49.440 
this is really simple because
this is an http request that

52
00:03:49.440 --> 00:03:53.950 
you do here and you specify a specific
URI that gives commands to

53
00:03:54.170 --> 00:03:58.260 
the SPARQL server and usually
this SPARQL URI consists

54
00:03:58.260 --> 00:04:02.830 
here of three parts, you have first
the URL of the SPARQL endpoint.

55
00:04:02.950 --> 00:04:07.210 
In our case here that's the blue
part example org slash SPARQL.

56
00:04:08.800 --> 00:04:12.500 
Then comes the rdf graph for
rdf graphs to be queried. This

57
00:04:12.500 --> 00:04:16.020 
is an optional part here given
in green that you have first

58
00:04:16.020 --> 00:04:20.360 
the keyboard named graph URI,
equals and then comes the URL

59
00:04:20.840 --> 00:04:23.890 
off the rdf graph that
has to be queried.

60
00:04:24.520 --> 00:04:27.970 
And then comes the SPARQL query
here given in green and of course

61
00:04:28.170 --> 00:04:32.440 
the entire query since it contains
also blanks and sometimes

62
00:04:32.440 --> 00:04:36.310 
things that cannot be directly
displayed within the URL or the URI.

63
00:04:36.610 --> 00:04:40.450 
This is URL encoded. So therefore
you see these lots of &amp;

64
00:04:40.450 --> 00:04:44.180 
and plus signs
within this URL.

65
00:04:45.420 --> 00:04:49.790 
This is then the entire address
that will be transferred via

66
00:04:49.790 --> 00:04:55.730 
http to the SPARQL server. If we
look at a a example communication

67
00:04:55.730 --> 00:04:58.520 
between a client and a server it
would look the following way. So

68
00:04:58.710 --> 00:05:02.650 
on the client the SPARQL query
that you see in gray has been

69
00:05:02.660 --> 00:05:07.490 
edited and sent away and then you
see the http trace of that

70
00:05:07.490 --> 00:05:11.860 
SPARQL query in the yellow box, so
this is an http get request

71
00:05:11.860 --> 00:05:13.390 
you have here
a query to

72
00:05:14.000 --> 00:05:18.150 
dbpedia, so therefore you see here
the SPARQL end point is dbpedia.

73
00:05:18.150 --> 00:05:21.860 
We are asking the default
graph which is dbpedia.org and

74
00:05:21.860 --> 00:05:25.020 
then comes the query in green
and the host of course that we

75
00:05:25.020 --> 00:05:28.090 
are asking here is
again dbpedia.org.

76
00:05:28.890 --> 00:05:31.210 
And of course we want an
answer that might be in

77
00:05:31.870 --> 00:05:35.720 
variants of headers, so for example
we can take a syntactical answer,

78
00:05:35.720 --> 00:05:41.050 
we can take a application xml
sorted answer; so it should

79
00:05:41.060 --> 00:05:44.780 
definitely be xml because you
know the SPARQL output format is

80
00:05:45.030 --> 00:05:49.690 
xml. And then if you trace the
answer that comes back from the

81
00:05:49.690 --> 00:05:53.050 
SPARQL server, you see that one,
so this is the SPARQL response,

82
00:05:53.260 --> 00:05:56.040 
and this comes of course via the
web server which tells you

83
00:05:56.040 --> 00:06:01.280 
ok this is http one one and of
course the query was successful.

84
00:06:01.280 --> 00:06:05.210 
Therefore you get the successful
code two hundred ok and of

85
00:06:05.210 --> 00:06:08.930 
course it also tells you when
was the query sent and when or

86
00:06:08.930 --> 00:06:12.750 
what type of query was it
and of course what's the length

87
00:06:12.750 --> 00:06:15.890 
of the message that comes now and
later on you see you that's

88
00:06:15.890 --> 00:06:18.810 
then now the SPARQL document
starting with the SPARQL part

89
00:06:18.810 --> 00:06:21.580 
and the name spaces that have
been used and then we have a

90
00:06:21.580 --> 00:06:23.680 
header section where we
have author and work,

91
00:06:24.260 --> 00:06:28.060 
that was what we had already in
our SPARQL query, the slide

92
00:06:28.060 --> 00:06:31.180 
before, and then of course comes
the result section where you

93
00:06:31.180 --> 00:06:36.080 
have all the bindings for author
and work, two specific URIs

94
00:06:36.080 --> 00:06:37.390 
here for example.

95
00:06:38.710 --> 00:06:43.980 
So this is the SPARQL protocol
Yeah and we were talking

96
00:06:43.980 --> 00:06:47.730 
a lot about SPARQL as a query
language already, so especially

97
00:06:47.730 --> 00:06:51.370 
for all of the select statements
that you have seen but SPARQL

98
00:06:51.370 --> 00:06:55.360 
has more commands than just select
So for example what you can do

99
00:06:55.600 --> 00:06:59.990 
besides others, so there is also
the possibility for example to

100
00:07:00.400 --> 00:07:05.460 
enter values and new data into
a SPARQL server and there is

101
00:07:05.460 --> 00:07:10.560 
also the possibility to create
new graphs and stuff like

102
00:07:10.560 --> 00:07:14.620 
that. But we don't look at these things, we
simply look at the query language part

103
00:07:14.780 --> 00:07:18.270 
which here consists first of
everything which is connected

104
00:07:18.280 --> 00:07:21.490 
to the keyword select, we did this
already before in the lecture,

105
00:07:21.640 --> 00:07:24.560 
and there are a few more that I
want to quickly mention here.

106
00:07:25.080 --> 00:07:28.770 
For example you know sometimes
these select statements need

107
00:07:28.780 --> 00:07:32.080 
a lot of time, but sometimes you
only want to know is there

108
00:07:32.080 --> 00:07:35.860 
any answer to my question? So is
there a single result line?

109
00:07:35.860 --> 00:07:38.040 
If there is one, I'm
completely happy.

110
00:07:38.940 --> 00:07:43.980 
And then therefore not to wait
until the entire select presents

111
00:07:43.980 --> 00:07:46.400 
all of the results that
have to be created.

112
00:07:46.920 --> 00:07:50.710 
There is another keyboard which
is ask and ask simply checks

113
00:07:50.710 --> 00:07:55.170 
whether there is at least one result.
So the result of an ask query

114
00:07:55.440 --> 00:07:59.510 
is always either true or false
and it's delivered in xml

115
00:07:59.510 --> 00:08:02.190 
you can also deliver if
you want to in JSON.

116
00:08:02.730 --> 00:08:07.480 
So simply take an arbitrary
select query that you have, you

117
00:08:07.480 --> 00:08:10.920 
can also take this one we have
here which asks is there an

118
00:08:10.920 --> 00:08:12.910 
author with any
notable work,

119
00:08:14.050 --> 00:08:16.910 
and then you simply put there
ask instead of select,

120
00:08:17.320 --> 00:08:19.760 
and we can try out that
query and you see

121
00:08:20.260 --> 00:08:24.530 
the page that we got back is almost
empty and there is only true

122
00:08:24.960 --> 00:08:29.840 
in the upper right corner and
that's it. So this is the result

123
00:08:29.840 --> 00:08:32.890 
of that kind of SPARQL query
we can also look at it here

124
00:08:32.890 --> 00:08:36.920 
if we added the spark query again and
simply let it run than you see here

125
00:08:37.070 --> 00:08:39.030 
we have the value
true. That's it.

126
00:08:43.960 --> 00:08:48.710 
Okay. Besides ask you have a second
possibility. You know sometimes

127
00:08:48.710 --> 00:08:52.990 
you want simply know all about
the entities which might be

128
00:08:53.290 --> 00:08:56.400 
the result of a select query. You
don't know all the properties

129
00:08:56.400 --> 00:09:00.830 
but you want to know all of them
So what kind of facts is known

130
00:09:00.830 --> 00:09:05.980 
about one entity or about several entities?
For that you have the so called

131
00:09:06.280 --> 00:09:12.290 
describe command. With describe the
result is an rdf graph with

132
00:09:12.390 --> 00:09:15.940 
data about the resources which
are in the result. So we have

133
00:09:15.940 --> 00:09:21.250 
here exactly the same, so we query
only with a describe in the

134
00:09:21.260 --> 00:09:24.820 
beginning and it says show all
available data about authors

135
00:09:24.890 --> 00:09:28.960 
and their notable work. So besides
the authors and besides the

136
00:09:28.960 --> 00:09:33.310 
notable works it shows also every
information about each of the authors

137
00:09:33.520 --> 00:09:37.390 
that is here. We can of course try
this out. Let's hope that this

138
00:09:37.390 --> 00:09:40.770 
runs quickly sometimes this takes
a lot of time. So you see, okay,

139
00:09:41.010 --> 00:09:45.500 
here we have a subject which
obviously is an author and besides

140
00:09:45.500 --> 00:09:48.510 
the notable works you see here
what is else known about that

141
00:09:48.510 --> 00:09:51.520 
author and this is simply all of
the triples that are there for

142
00:09:51.690 --> 00:09:55.650 
this singlesingle
entity and of course then

143
00:09:55.650 --> 00:09:58.820 
there come other entities and this
is lots of data. So sometimes

144
00:09:59.160 --> 00:10:02.080 
these kind of questions
come rather handy.

145
00:10:03.500 --> 00:10:06.780 
And there was a third and last
option I wanted to show you

146
00:10:06.780 --> 00:10:10.600 
and this is the so called construct
query. What does that mean?

147
00:10:11.130 --> 00:10:17.680 
With construct I can instead you
know of producing tables as output

148
00:10:17.960 --> 00:10:20.530 
I can produce new
rdf triples.

149
00:10:21.350 --> 00:10:24.720 
By that, so in principle it works
like a select statement, only

150
00:10:24.720 --> 00:10:29.150 
thing is that I order or organize
the output in terms of triples.

151
00:10:29.150 --> 00:10:32.930 
So this is what construct does.
So construct here, for example,

152
00:10:32.930 --> 00:10:35.910 
does exactly the same. What I want
to do is create create new

153
00:10:35.910 --> 00:10:40.100 
rdf triples for authors and the
notable work and I want to connect

154
00:10:40.320 --> 00:10:45.310 
author and their notable work
with a new property that comes

155
00:10:45.310 --> 00:10:51.440 
from my namespace for example, I have
here the property from http example org

156
00:10:51.600 --> 00:10:55.110 
he has written, so I want to have
tripled in the result author

157
00:10:55.110 --> 00:10:58.790 
has written some books and author
and book so these queries

158
00:10:58.790 --> 00:11:01.850 
are then in the WHERE part of the
SPARQL query that you see

159
00:11:01.850 --> 00:11:06.230 
here and this follows the traditional
select scheme that we know.

160
00:11:06.520 --> 00:11:10.340 
And simply from the results author and
book than these kind of triples with

161
00:11:10.450 --> 00:11:14.120 
closing with a period will be
constructed. Let's try it out.

162
00:11:16.840 --> 00:11:19.500 
So we do this
and you see

163
00:11:20.210 --> 00:11:25.030 
we have triples, so we have subject
predicate object exactly here in

164
00:11:25.550 --> 00:11:30.090 
our query as a result and we see
here that here subject Q62073

165
00:11:30.090 --> 00:11:33.920 
has written a
book and the book is

166
00:11:33.920 --> 00:11:36.630 
Q56607450.

167
00:11:37.700 --> 00:11:40.350 
Whatever you do with that
information, it's already available

168
00:11:40.350 --> 00:11:43.260 
there is subject predicate object
and you can use it further

169
00:11:43.260 --> 00:11:47.650 
and create a new rdf graph out
of it or complement existing

170
00:11:47.810 --> 00:11:49.290 
rdf graphs with it.

171
00:11:51.440 --> 00:11:55.720 
So that's all what I wanted to tell you
or we wanted to tell you about SPARQL.

172
00:11:56.810 --> 00:12:02.430 
You see your again the result. We have
now already talked about a lot

173
00:12:02.950 --> 00:12:07.380 
of different technologies which
are here represented in the

174
00:12:07.380 --> 00:12:10.610 
semantic web technology stack. So
we have talked about the web

175
00:12:10.610 --> 00:12:15.370 
foundations, we have talked about rdf in
general, we have talked about several

176
00:12:15.640 --> 00:12:20.270 
other kinds of formats like turtle,
like rdfa and we have talked

177
00:12:20.270 --> 00:12:23.030 
about the SPARQL query
language. However

178
00:12:23.770 --> 00:12:27.100 
there are more things between
heaven and earth than can be

179
00:12:27.110 --> 00:12:32.250 
explained simply by rdf or rdfs
and simply for that reason

180
00:12:32.990 --> 00:12:37.360 
we want now continue in the next
lecture with knowledge representation

181
00:12:37.480 --> 00:12:39.020 
based on ontologies.
