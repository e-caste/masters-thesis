WEBVTT

1
00:00:00.930 --> 00:00:04.020 
In order to better understand
how service provider

2
00:00:04.340 --> 00:00:09.830 
use digital identities, let's
have a closer look to passwords

3
00:00:09.830 --> 00:00:14.800 
based login process. Here we
have a user, there is a web

4
00:00:14.800 --> 00:00:18.100 
service, the web service
runs on the servers

5
00:00:18.350 --> 00:00:22.490 
the web servers provider and a
when the user wants to use the

6
00:00:22.490 --> 00:00:27.720 
service the user has to
register, registering means

7
00:00:27.980 --> 00:00:31.150 
the user enters has to
enter a user name

8
00:00:31.350 --> 00:00:36.780 
and has to enter plaintext
password into the form of the

9
00:00:36.790 --> 00:00:41.570 
website. He can select the
user name john13 for example

10
00:00:41.640 --> 00:00:46.180 
and then he types in his
password. You see it's a quite

11
00:00:46.180 --> 00:00:49.870 
secure password it
use different

12
00:00:49.870 --> 00:00:54.700 
types of signals,
different types of signs

13
00:00:55.140 --> 00:00:59.480 
and numbers and others.
The user enters user

14
00:00:59.480 --> 00:01:03.800 
name and plaintext then the
password and the user name is

15
00:01:03.800 --> 00:01:10.630 
sent over the internet to the
server of the service provider

16
00:01:11.500 --> 00:01:14.770 
then the server disguised
that means hashes

17
00:01:15.450 --> 00:01:20.170 
is a password and compares it
with hash password which is

18
00:01:20.170 --> 00:01:23.010 
already stored in the user
database for that user.

19
00:01:23.610 --> 00:01:26.790 
In the first step when
the user registered

20
00:01:27.100 --> 00:01:32.400 
in the database the digital identity
is established the username

21
00:01:32.410 --> 00:01:35.380 
and the password and all the
other data that are needed

22
00:01:35.810 --> 00:01:38.660 
and then later when a user
comes back to the service

23
00:01:38.930 --> 00:01:44.130 
by hand of user name and
password it is checked whether

24
00:01:44.470 --> 00:01:48.210 
the service knows
the user.

25
00:01:51.480 --> 00:01:55.940 
In the right way in the database
the password is not allowed

26
00:01:56.020 --> 00:02:02.120 
to be stored in plaintext.
The mathematical way

27
00:02:02.350 --> 00:02:07.150 
to disguise it is to hash it
but unfortunately there

28
00:02:07.150 --> 00:02:11.190 
are many service provider who do
store passwords in plaintext

29
00:02:11.390 --> 00:02:16.000 
always old an unsafe hashing
methods so that if

30
00:02:16.220 --> 00:02:19.190 
cybercriminals get
access to the database

31
00:02:19.540 --> 00:02:23.520 
then they see
the password

32
00:02:23.810 --> 00:02:30.960 
in the plaintext. The cybercriminals,
we saw this already

33
00:02:31.420 --> 00:02:35.540 
try to get access
when they

34
00:02:35.790 --> 00:02:39.190 
break into the service they
particularly are interested to

35
00:02:39.190 --> 00:02:43.460 
get access to the user database
because then later on

36
00:02:43.650 --> 00:02:49.570 
they can use, they can misuse the
service on a regular way by miss

37
00:02:49.570 --> 00:02:52.790 
using a digital identity
of one of its users.

38
00:02:54.530 --> 00:03:00.100 
The cybercriminals
manage to get

39
00:03:00.200 --> 00:03:02.860 
they managed to get
access to the user base

40
00:03:03.140 --> 00:03:07.240 
they download the user base with
all the digital identities

41
00:03:07.240 --> 00:03:11.270 
of all the users that are
registered with the service

42
00:03:11.670 --> 00:03:16.540 
and in particular
the wrap the pair

43
00:03:16.540 --> 00:03:20.160 
consists of user name and
password which allows them

44
00:03:20.160 --> 00:03:24.790 
later to officially
use the service.

45
00:03:26.450 --> 00:03:31.440 
Why it's particularly
difficult when

46
00:03:31.650 --> 00:03:36.980 
passwords are stolen why so
dangerous, an attacker can misuse

47
00:03:37.000 --> 00:03:42.590 
username password easy to
officially log into the service

48
00:03:42.770 --> 00:03:47.860 
where the password was stolen.
An attacker can also attempt

49
00:03:47.860 --> 00:03:51.430 
to log into another service
using the same password,

50
00:03:51.750 --> 00:03:57.170 
that is often very successful
because many users use

51
00:03:57.170 --> 00:04:00.010 
the same password
for different

52
00:04:00.020 --> 00:04:02.730 
accounts for different
digital identities.

53
00:04:03.250 --> 00:04:08.020 
Sometimes they do not use this
in a identical way, sometimes

54
00:04:08.020 --> 00:04:13.100 
they do some slightly
altered data for example

55
00:04:13.130 --> 00:04:16.410 
coding also the name of the
service into the password

56
00:04:16.740 --> 00:04:22.300 
but for the attacker, if say a
get such a password the user

57
00:04:22.300 --> 00:04:26.660 
name password combination in their
hand, there is a huge chance

58
00:04:26.710 --> 00:04:32.460 
that they can use this password also
to break in to other services.

59
00:04:34.520 --> 00:04:38.440 
Problem if identity
data are stolen

60
00:04:38.920 --> 00:04:43.570 
the user does not know this,
the user can only see

61
00:04:43.810 --> 00:04:49.960 
that his data were stolen when some
of his accounts were misused

62
00:04:50.720 --> 00:04:55.050 
and for example he has to pay
for the service he never used.

63
00:04:56.280 --> 00:05:01.220 
How to store the password
safely in a correct way,

64
00:05:02.210 --> 00:05:05.860 
this should be done and should
be expected by all the service

65
00:05:05.860 --> 00:05:10.710 
provider because there is a
cryptographic methods that help

66
00:05:11.010 --> 00:05:14.340 
to make it difficult
to misuse a password

67
00:05:14.510 --> 00:05:20.760 
for attackers and this
technique to disguise

68
00:05:21.190 --> 00:05:25.590 
a password is by hashing
and encryption.

69
00:05:27.240 --> 00:05:31.440 
When we look and consider and
analyze the experience with our

70
00:05:31.440 --> 00:05:34.520 
HPI identity leak
checker then we see

71
00:05:34.750 --> 00:05:39.580 
that many of the service providers
store passwords in plaintext,

72
00:05:39.670 --> 00:05:43.970 
about one third of all. Of course
this is very unprofessional

73
00:05:44.550 --> 00:05:49.360 
because then if attackers are
succesfully able to steal

74
00:05:49.620 --> 00:05:53.750 
such an user database they can
immediately use a password

75
00:05:53.750 --> 00:05:59.150 
because its stored there in
plaintext. Some others use methods

76
00:05:59.160 --> 00:06:02.660 
hashing methods which are
outdated, meanwhile

77
00:06:03.000 --> 00:06:05.680 
and outdated for such
a hash method means

78
00:06:05.890 --> 00:06:10.910 
that it's easy to break
it so that it's not

79
00:06:10.960 --> 00:06:17.230 
much for needed to reveal the
clear text password out of this

80
00:06:17.230 --> 00:06:21.650 
weakly hashed password for
example MD5 and SHA-1

81
00:06:21.750 --> 00:06:28.120 
are such passwords. But what is a
way to work correctly to hide

82
00:06:28.190 --> 00:06:31.250 
correctly the passwords
in such a user database

83
00:06:31.670 --> 00:06:38.550 
to disguise it. This is done
by means of a hash function

84
00:06:38.700 --> 00:06:42.440 
what is a hash function,
a hash function maps

85
00:06:42.680 --> 00:06:47.220 
the clear text password,
hash function measures

86
00:06:47.220 --> 00:06:52.450 
maps any words or any
sequence of signs

87
00:06:52.760 --> 00:06:57.240 
into an obfuscated
fixed length text

88
00:06:57.630 --> 00:07:02.150 
this text is a hash. We have
the plaintext functions

89
00:07:02.150 --> 00:07:04.670 
a hash function is applied
to produce a hash

90
00:07:05.140 --> 00:07:09.210 
and the idea of this hash function
is that it's almost impossible

91
00:07:09.220 --> 00:07:13.390 
to come back to reveal,
only knowing the hash

92
00:07:13.620 --> 00:07:17.970 
to find out the plaintext
the original plaintext,

93
00:07:18.300 --> 00:07:23.800 
so it's a one way function. Hash function
are distinguished so that it's

94
00:07:23.800 --> 00:07:27.210 
only possible to recover
the original password

95
00:07:27.470 --> 00:07:30.890 
from the hash. With
an extreme effort

96
00:07:31.470 --> 00:07:34.520 
so that we would need
years of computation

97
00:07:34.760 --> 00:07:39.680 
to get it back so this hash
functions, cryptographic

98
00:07:39.680 --> 00:07:45.180 
hash function that are used
to disguise passwords that

99
00:07:45.190 --> 00:07:49.300 
are one way function. This
way it's easy to compute

100
00:07:49.420 --> 00:07:55.790 
but in that way it's almost
impossible. We will have and offer

101
00:07:55.790 --> 00:07:59.530 
you an excursion in
this week where we

102
00:07:59.750 --> 00:08:04.310 
go into more details with
this hash functions.

103
00:08:06.090 --> 00:08:10.460 
Frequently used hash
algorithms are MD5

104
00:08:10.460 --> 00:08:16.070 
and SHA-1 but both are
now considered unsafe

105
00:08:16.650 --> 00:08:21.700 
when computers become more
powerful, it becomes more

106
00:08:21.700 --> 00:08:26.750 
easy to reveal from the hash
the original password.

107
00:08:27.400 --> 00:08:31.220 
When I mentioned that
it needs years

108
00:08:31.540 --> 00:08:36.420 
ten years ago then today it could
be computed in minutes and

109
00:08:36.420 --> 00:08:39.500 
if it can be computed
if the password

110
00:08:39.500 --> 00:08:44.650 
if the hash can be cracked in
minutes then it's to be considered

111
00:08:44.750 --> 00:08:52.370 
unsecure. Safer hash methods
are used and also are

112
00:08:52.370 --> 00:08:58.060 
available so SHA-2 or
SHA-512 or SHA-3

113
00:08:58.060 --> 00:09:02.770 
are in place
and should be

114
00:09:03.180 --> 00:09:09.480 
installed to produce the hash
of a password for user

115
00:09:09.480 --> 00:09:14.610 
database by all internet services.
Here is an example to show

116
00:09:14.610 --> 00:09:20.520 
you how is this hash look like
so for demonstration purposes

117
00:09:20.600 --> 00:09:25.250 
we are take the unsecure
MD5 in this example

118
00:09:25.730 --> 00:09:29.910 
then the hash value
is shorter and fits

119
00:09:30.160 --> 00:09:35.620 
to this slide. This
is a password, the

120
00:09:35.620 --> 00:09:39.440 
password where we start
with in the beginning

121
00:09:39.440 --> 00:09:44.180 
of this clip and we apply the
hash value in this case

122
00:09:44.180 --> 00:09:48.470 
MD5 and this is the
resulting hash value

123
00:09:48.980 --> 00:09:55.590 
If there is a secure
hash function

124
00:09:55.590 --> 00:10:01.370 
used then this computation is easy
but to reveal from that side

125
00:10:01.420 --> 00:10:07.000 
the original password it's
difficult, I remind you MD5

126
00:10:07.170 --> 00:10:11.750 
is no more secure so it's possible with
larger (fault?) and computational

127
00:10:11.750 --> 00:10:15.930 
power to reveal the password
and relative short time

128
00:10:16.200 --> 00:10:20.420 
so there are more
secure hash functions

129
00:10:20.700 --> 00:10:24.620 
in place but the principle is the
same, the principle is the same

130
00:10:24.790 --> 00:10:27.630 
to hide a password
by hashing it.

131
00:10:29.940 --> 00:10:35.170 
Now when the password is in
the user database in the

132
00:10:35.170 --> 00:10:39.190 
hashed variant then there
is no clear text password

133
00:10:39.630 --> 00:10:43.420 
how the password is validated
when the user comes next time

134
00:10:43.420 --> 00:10:51.970 
back to the service. The user starts
to enter his or her plaintext

135
00:10:51.970 --> 00:10:56.110 
password we use the same as we
did in the beginning example

136
00:10:57.460 --> 00:11:02.470 
then the service sees John13
and looks in its user

137
00:11:02.470 --> 00:11:05.950 
base in this user
database and sees ok it

138
00:11:06.770 --> 00:11:12.070 
remembers a user john13
and then there is the

139
00:11:12.080 --> 00:11:18.060 
hashed password.
In the next step

140
00:11:18.390 --> 00:11:22.540 
the passport here has to
be taken by the service

141
00:11:22.810 --> 00:11:26.830 
and a new hash value
with the same method

142
00:11:27.030 --> 00:11:31.790 
has to be applied to the password
in our case in our example

143
00:11:31.790 --> 00:11:35.460 
we take MD5 because of
the short hash value

144
00:11:35.750 --> 00:11:40.600 
and then hash is produced
and for validating

145
00:11:40.780 --> 00:11:45.290 
whether the user is authorized
whether it is the right user

146
00:11:45.930 --> 00:11:51.290 
it's now only need to be compared
the password the hash password

147
00:11:51.290 --> 00:11:55.780 
that stores in the user
base of the service and

148
00:11:55.950 --> 00:12:00.750 
the computed password that
was computed from the

149
00:12:00.760 --> 00:12:06.360 
input of the user to that
service. In case both agree

150
00:12:06.740 --> 00:12:12.340 
then the login is successful
and if there is a mismatch

151
00:12:12.530 --> 00:12:18.840 
then login failed, mismatch can
also come if you misspell

152
00:12:19.360 --> 00:12:26.740 
if you input you password, you misspell it then of
course it's different it's a different string

153
00:12:27.110 --> 00:12:31.160 
and then the hash function comes
with a different result and here

154
00:12:31.160 --> 00:12:37.120 
is no agreement between
them. In this way

155
00:12:37.300 --> 00:12:43.440 
the data, the digital
identity can be secured

156
00:12:43.710 --> 00:12:49.000 
and there is this common secret,
the password between the

157
00:12:49.000 --> 00:12:52.830 
authorized user and the
service that allows

158
00:12:53.080 --> 00:12:56.060 
the service to remember
the user and to give him

159
00:12:56.240 --> 00:13:00.000 
or her access to his,
to its resources.

160
00:13:01.630 --> 00:13:07.020 
Sometimes is not so
easy to disguise

161
00:13:07.020 --> 00:13:11.770 
by hashing because it
could happen as follows

162
00:13:12.400 --> 00:13:16.670 
we could have same
two different users

163
00:13:17.110 --> 00:13:22.900 
having the same password
and then of course in our

164
00:13:23.070 --> 00:13:27.000 
database where the user name
is stored and then a side of

165
00:13:27.010 --> 00:13:29.840 
the user name the hash
password is stored.

166
00:13:30.240 --> 00:13:35.320 
How to secure the case when
the user A and user B

167
00:13:35.320 --> 00:13:38.750 
use the same password.

168
00:13:39.690 --> 00:13:44.290 
The same hash value
is stored, database

169
00:13:44.630 --> 00:13:48.650 
and in theory it would be
possible that user A

170
00:13:48.970 --> 00:13:54.930 
is misusing the account
of user B and orders

171
00:13:54.940 --> 00:13:58.300 
some shops, do
some shopping

172
00:13:58.600 --> 00:14:04.560 
on the payment of user B. If an
attacker knows for example

173
00:14:04.560 --> 00:14:09.630 
one users password he knows a
password of all other users

174
00:14:09.900 --> 00:14:16.100 
with same passport, in this
way the hash can be guessed

175
00:14:16.350 --> 00:14:22.840 
by hashing all words in a dictionary
so for example a password

176
00:14:23.210 --> 00:14:28.810 
or the attacks, also for that case
there is a solution in place

177
00:14:28.920 --> 00:14:32.410 
and the solution looks as
follows, the same password

178
00:14:32.700 --> 00:14:36.160 
is artificially
disguised differently

179
00:14:36.580 --> 00:14:41.630 
every time and the idea behind
this that before the hash

180
00:14:41.630 --> 00:14:46.460 
value of a password is calculated
the password is extended

181
00:14:46.460 --> 00:14:50.710 
by a random string, the random
string the name is salt

182
00:14:51.160 --> 00:14:56.120 
so here are we apply our hash
function not only on the password

183
00:14:56.340 --> 00:15:02.890 
but also an the salt before
the hash value is computed.

184
00:15:03.740 --> 00:15:09.590 
In this case now user A and user
B which have the same passport

185
00:15:09.950 --> 00:15:13.880 
but of course the
passport was prolonged

186
00:15:14.070 --> 00:15:19.680 
by a different source then it
results, the same password

187
00:15:19.680 --> 00:15:24.340 
results in different hashs, so
that it's no more possible

188
00:15:24.510 --> 00:15:30.720 
to misuse the hash value of
a password that is known.

189
00:15:32.450 --> 00:15:37.480 
In this way the
service provider

190
00:15:37.790 --> 00:15:44.770 
secures the secret password by
storing it not in plaintext

191
00:15:44.950 --> 00:15:48.930 
but store it in a in
form of the hash value

192
00:15:49.180 --> 00:15:53.820 
so also for the employees of
that service, it's impossible

193
00:15:53.860 --> 00:15:59.550 
to conclude from that hash value
the real password of the user

194
00:15:59.680 --> 00:16:05.060 
and the same as for cybercriminals
they can steal the data they

195
00:16:05.060 --> 00:16:09.560 
can see there is user A but
as long as they have only

196
00:16:09.620 --> 00:16:14.060 
the hash value the hash password
they cannot misuse a password

197
00:16:14.380 --> 00:16:18.360 
and try for example to apply it
also for other services of that

198
00:16:18.370 --> 00:16:19.160 
particular user.
