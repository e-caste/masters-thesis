WEBVTT

1
00:00:00.410 --> 00:00:01.881 
Hello, I'm Wolfgang Rother.

2
00:00:01.882 --> 00:00:03.379 
I'm working for the IBM POWER

3
00:00:03.380 --> 00:00:05.269 
platform team in Germany, and I

4
00:00:05.270 --> 00:00:07.279 
want to show you today

5
00:00:07.280 --> 00:00:09.289 
some interesting

6
00:00:09.290 --> 00:00:11.450 
points about the IBM i architecture.

7
00:00:12.830 --> 00:00:15.559 
IBM has a long history in developing

8
00:00:15.560 --> 00:00:16.459 
midrange systems.

9
00:00:16.460 --> 00:00:17.923 
In the year 1988,

10
00:00:19.190 --> 00:00:21.439 
application system 400, short

11
00:00:21.440 --> 00:00:23.959 
AS/400, was announced.

12
00:00:23.960 --> 00:00:25.831 
It was a combination of a

13
00:00:25.832 --> 00:00:27.499 
software and a hardware in one

14
00:00:27.500 --> 00:00:29.299 
system design.

15
00:00:29.300 --> 00:00:30.300 
In

16
00:00:31.780 --> 00:00:33.969 
2008, IBM decided

17
00:00:33.970 --> 00:00:35.829 
to separate this in

18
00:00:35.830 --> 00:00:37.629 
the hardware section and an

19
00:00:37.630 --> 00:00:39.579 
operating system because of the

20
00:00:39.580 --> 00:00:41.889 
unification of two platforms,

21
00:00:41.890 --> 00:00:43.719 
the UNIX and the IBM i

22
00:00:43.720 --> 00:00:45.429 
environment.

23
00:00:45.430 --> 00:00:47.259 
Today, IBM

24
00:00:47.260 --> 00:00:50.109 
i is the successful

25
00:00:50.110 --> 00:00:51.999 
successor of the operating

26
00:00:52.000 --> 00:00:53.431 
system from 1988.

27
00:00:54.940 --> 00:00:57.399 
It's 30 years old architecture,

28
00:00:57.400 --> 00:00:59.499 
and it's still very successful.

29
00:00:59.500 --> 00:01:01.649 
It runs on POWER9 systems today.

30
00:01:02.980 --> 00:01:04.958 
The secret of the success

31
00:01:04.959 --> 00:01:06.969 
was gradual, not radical changes

32
00:01:06.970 --> 00:01:09.309 
inside the

33
00:01:09.310 --> 00:01:11.199 
environment, inside the architecture

34
00:01:11.200 --> 00:01:12.939 
so that people can use all the

35
00:01:12.940 --> 00:01:14.405 
applications today.

36
00:01:16.120 --> 00:01:18.219 
The design goals elsewhere

37
00:01:18.220 --> 00:01:20.499 
at first that the developers

38
00:01:20.500 --> 00:01:22.659 
had in mind to create

39
00:01:22.660 --> 00:01:24.849 
a business computer, which means

40
00:01:24.850 --> 00:01:26.349 
that it's optimized for running

41
00:01:26.350 --> 00:01:28.299 
business applications.

42
00:01:28.300 --> 00:01:30.159 
That means they wanted to

43
00:01:30.160 --> 00:01:31.989 
create a computer

44
00:01:31.990 --> 00:01:33.999 
system for multi-user environments

45
00:01:34.000 --> 00:01:36.639 
with high intensive workloads

46
00:01:36.640 --> 00:01:39.549 
and high throughput

47
00:01:39.550 --> 00:01:41.052 
with a very fast I/O.

48
00:01:42.250 --> 00:01:44.439 
And one other important thing

49
00:01:44.440 --> 00:01:46.030 
was the ability to

50
00:01:47.500 --> 00:01:49.389 
use older

51
00:01:49.390 --> 00:01:51.009 
applications further, even the

52
00:01:51.010 --> 00:01:52.359 
hardware was exchanged.

53
00:01:52.360 --> 00:01:54.579 
This is very important because

54
00:01:54.580 --> 00:01:56.889 
in the 80s, nobody

55
00:01:56.890 --> 00:01:58.839 
had branch applications from

56
00:01:58.840 --> 00:02:01.119 
ISPs so that most companies

57
00:02:01.120 --> 00:02:03.159 
had to create their own applications

58
00:02:03.160 --> 00:02:04.629 
and they wanted to protect their

59
00:02:04.630 --> 00:02:05.630 
investments.

60
00:02:07.350 --> 00:02:09.508 
They designed five

61
00:02:09.509 --> 00:02:11.619 
architectural principles for the

62
00:02:11.620 --> 00:02:13.589 
AS/400, the most important

63
00:02:13.590 --> 00:02:15.269 
one was the technology independent

64
00:02:15.270 --> 00:02:17.219 
machine interface, which is

65
00:02:17.220 --> 00:02:19.949 
a kind of the translation layer

66
00:02:19.950 --> 00:02:20.950 
for the system.

67
00:02:22.140 --> 00:02:23.369 
The operating system and the

68
00:02:23.370 --> 00:02:25.209 
applications itself, branch in

69
00:02:25.210 --> 00:02:27.749 
the kind of virtual machine.

70
00:02:27.750 --> 00:02:29.909 
The second point was the decision

71
00:02:29.910 --> 00:02:31.829 
to use single level store,

72
00:02:31.830 --> 00:02:33.929 
which means that all

73
00:02:33.930 --> 00:02:36.269 
this per default,

74
00:02:36.270 --> 00:02:38.309 
our virtual memory of

75
00:02:38.310 --> 00:02:40.199 
the system itself.

76
00:02:40.200 --> 00:02:42.149 
So the file system was placed into

77
00:02:42.150 --> 00:02:44.609 
this virtual memory

78
00:02:44.610 --> 00:02:47.099 
and furthermore, all processes

79
00:02:47.100 --> 00:02:49.439 
had to run in the same

80
00:02:49.440 --> 00:02:50.440 
virtual address space.

81
00:02:53.370 --> 00:02:55.229 
Furthermore, the object based

82
00:02:55.230 --> 00:02:57.749 
architecture was chosen

83
00:02:57.750 --> 00:02:59.619 
because it was the base of

84
00:02:59.620 --> 00:03:02.069 
our security and all informations

85
00:03:02.070 --> 00:03:04.110 
should be stored in objects.

86
00:03:06.770 --> 00:03:09.049 
The integrated business

87
00:03:09.050 --> 00:03:11.059 
middleware for

88
00:03:11.060 --> 00:03:13.429 
running business applications,

89
00:03:13.430 --> 00:03:15.859 
so middleware like a database

90
00:03:15.860 --> 00:03:17.539 
so that people don't have to

91
00:03:17.540 --> 00:03:19.259 
integrate middleware by themselves

92
00:03:19.260 --> 00:03:21.199 
so they can create applications

93
00:03:21.200 --> 00:03:23.569 
and can run it at IBM i

94
00:03:23.570 --> 00:03:25.879 
in the well tested environment.

95
00:03:25.880 --> 00:03:27.873 
At least they needed a

96
00:03:27.874 --> 00:03:30.138 
high performance work

97
00:03:30.139 --> 00:03:31.219 
management, which I will cover in

98
00:03:31.220 --> 00:03:32.509 
the second module.

99
00:03:34.430 --> 00:03:36.679 
The programmers for you and IBM i

100
00:03:36.680 --> 00:03:38.839 
was that

101
00:03:38.840 --> 00:03:40.954 
IBM created a

102
00:03:40.955 --> 00:03:43.009 
machine interface and the view

103
00:03:43.010 --> 00:03:45.139 
of a programmer was to this

104
00:03:45.140 --> 00:03:46.579 
machine interface.

105
00:03:46.580 --> 00:03:48.529 
Under the machine interface

106
00:03:48.530 --> 00:03:51.049 
there was a kernel which IBM

107
00:03:51.050 --> 00:03:53.059 
called system licensed internal

108
00:03:53.060 --> 00:03:54.949 
code, which was the layer

109
00:03:54.950 --> 00:03:57.939 
to build the machine interface.

110
00:03:57.940 --> 00:04:00.249 
So running the applications

111
00:04:00.250 --> 00:04:02.769 
above the machine interface,

112
00:04:02.770 --> 00:04:04.599 
which not allowed direct access to

113
00:04:04.600 --> 00:04:06.609 
hardware, allows IBM

114
00:04:06.610 --> 00:04:09.369 
to protect application investments

115
00:04:09.370 --> 00:04:10.989 
because they could change the

116
00:04:10.990 --> 00:04:12.939 
hardware without impact

117
00:04:12.940 --> 00:04:14.280 
of these applications.

118
00:04:16.190 --> 00:04:19.249 
The use of objects was well known

119
00:04:19.250 --> 00:04:21.528 
or the use of objects

120
00:04:21.529 --> 00:04:24.439 
was very important because

121
00:04:24.440 --> 00:04:26.629 
they need two parts inside

122
00:04:26.630 --> 00:04:28.040 
the operating system itself.

123
00:04:30.020 --> 00:04:31.939 
Hardware dependent part, which

124
00:04:31.940 --> 00:04:34.159 
called system license internal code,

125
00:04:34.160 --> 00:04:36.289 
I already mentioned, is

126
00:04:36.290 --> 00:04:38.269 
the base

127
00:04:38.270 --> 00:04:40.549 
for the virtualization

128
00:04:40.550 --> 00:04:42.049 
layer called the machine interface.

129
00:04:42.050 --> 00:04:44.029 
All objects above

130
00:04:44.030 --> 00:04:45.649 
the machine interface are

131
00:04:45.650 --> 00:04:47.399 
combinations of objects from the

132
00:04:47.400 --> 00:04:49.549 
system license internal code,

133
00:04:49.550 --> 00:04:51.499 
and all applications can

134
00:04:51.500 --> 00:04:54.049 
use the objects inside

135
00:04:54.050 --> 00:04:56.329 
the operating system, which

136
00:04:56.330 --> 00:04:57.889 
on the other side use

137
00:05:00.620 --> 00:05:02.449 
other combination was a combination

138
00:05:02.450 --> 00:05:04.279 
of the objects of

139
00:05:04.280 --> 00:05:06.199 
the system license internal code.

140
00:05:06.200 --> 00:05:08.299 
Objects, for example, our database

141
00:05:08.300 --> 00:05:10.129 
files, user profiles, programs

142
00:05:10.130 --> 00:05:11.420 
and a lot of

143
00:05:12.710 --> 00:05:13.939 
more.

144
00:05:13.940 --> 00:05:16.309 
The use of objects are very,

145
00:05:16.310 --> 00:05:18.619 
was very important because

146
00:05:18.620 --> 00:05:20.599 
with encapsulation they could

147
00:05:20.600 --> 00:05:22.669 
hide the internal data structure

148
00:05:22.670 --> 00:05:24.529 
and data manipulation was

149
00:05:24.530 --> 00:05:26.449 
only allowed via the methods

150
00:05:26.450 --> 00:05:27.450 
of the objects.

151
00:05:28.310 --> 00:05:31.279 
This helps to get the independency

152
00:05:31.280 --> 00:05:32.480 
so that you

153
00:05:33.590 --> 00:05:35.569 
change the data structure

154
00:05:35.570 --> 00:05:37.519 
internally of this object

155
00:05:37.520 --> 00:05:39.829 
and you extend the methods

156
00:05:39.830 --> 00:05:41.869 
of the objects by newer

157
00:05:41.870 --> 00:05:43.159 
methods.

158
00:05:43.160 --> 00:05:45.139 
The older applications can also

159
00:05:45.140 --> 00:05:47.599 
use the newer object to run

160
00:05:47.600 --> 00:05:49.669 
further because all

161
00:05:49.670 --> 00:05:51.709 
other interfaces exists.

162
00:05:54.380 --> 00:05:56.270 
The RS/400 file system in

163
00:05:57.350 --> 00:06:00.049 
1988 was designed like a database

164
00:06:00.050 --> 00:06:01.879 
file system, so you have a

165
00:06:01.880 --> 00:06:02.880 
route called

166
00:06:03.770 --> 00:06:05.659 
QSYS and you have libraries

167
00:06:05.660 --> 00:06:07.669 
and objects, which contains

168
00:06:07.670 --> 00:06:09.284 
in the QSYS.

169
00:06:11.770 --> 00:06:14.409 
Libraries itself,

170
00:06:14.410 --> 00:06:16.419 
not the QSYS, could

171
00:06:16.420 --> 00:06:18.279 
contain objects, but not other

172
00:06:18.280 --> 00:06:19.280 
libraries.

173
00:06:20.170 --> 00:06:22.059 
This was comparable to

174
00:06:22.060 --> 00:06:24.279 
a database structure

175
00:06:24.280 --> 00:06:26.529 
but was not successful inside

176
00:06:26.530 --> 00:06:27.530 
the 90s.

177
00:06:28.660 --> 00:06:29.660 
With the

178
00:06:30.490 --> 00:06:32.379 
client-server environments coming up

179
00:06:32.380 --> 00:06:34.449 
in the 90s, this file

180
00:06:34.450 --> 00:06:36.040 
system became an issue.

181
00:06:37.090 --> 00:06:39.249 
So IBM decided to create

182
00:06:39.250 --> 00:06:40.479 
a new one.

183
00:06:40.480 --> 00:06:42.819 
It was a virtual filesystems

184
00:06:42.820 --> 00:06:45.489 
which also contained

185
00:06:45.490 --> 00:06:47.209 
the older file system QSYS

186
00:06:48.310 --> 00:06:50.010 
inside a folder called

187
00:06:51.130 --> 00:06:52.130 
QSYS.LIB.

188
00:06:53.040 --> 00:06:55.019 
And this

189
00:06:55.020 --> 00:06:57.029 
advantage here was that

190
00:06:57.030 --> 00:06:59.369 
you could also other files

191
00:06:59.370 --> 00:07:01.559 
from other environments like Unix

192
00:07:01.560 --> 00:07:03.629 
or Windows could store in

193
00:07:03.630 --> 00:07:05.819 
this virtual file system

194
00:07:05.820 --> 00:07:07.799 
in such a manner as

195
00:07:07.800 --> 00:07:09.899 
of the original one file system.

196
00:07:09.900 --> 00:07:11.729 
So the name and the access right

197
00:07:11.730 --> 00:07:12.810 
could be saved in the

198
00:07:14.205 --> 00:07:16.649 
IFS as well as in the

199
00:07:16.650 --> 00:07:18.139 
other environment.

200
00:07:19.380 --> 00:07:21.749 
The secret for integrating

201
00:07:21.750 --> 00:07:23.649 
the QSYS was very easy.

202
00:07:24.870 --> 00:07:26.699 
It was an assignment

203
00:07:26.700 --> 00:07:28.340 
of a triple.

204
00:07:30.110 --> 00:07:31.937 
Because all objects inside the

205
00:07:31.938 --> 00:07:32.938 
QSYS

206
00:07:34.220 --> 00:07:36.289 
was unique by this triple,

207
00:07:36.290 --> 00:07:38.149 
which contains the object name, the

208
00:07:38.150 --> 00:07:40.040 
object type and the library.

209
00:07:41.250 --> 00:07:42.250 
And this could be

210
00:07:43.600 --> 00:07:45.699 
assigned to

211
00:07:45.700 --> 00:07:47.679 
other file

212
00:07:47.680 --> 00:07:49.989 
which called QSYS.LIB,

213
00:07:49.990 --> 00:07:50.990 
Library.LIB, objectName.objectType.

214
00:07:52.720 --> 00:07:54.669 
If you do this, we have one

215
00:07:54.670 --> 00:07:56.589 
assignment,so

216
00:07:56.590 --> 00:07:57.590 
that you

217
00:07:58.870 --> 00:08:01.029 
can use the newer structure,

218
00:08:01.030 --> 00:08:02.674 
but the older applications can

219
00:08:03.790 --> 00:08:06.069 
also use the older

220
00:08:06.070 --> 00:08:07.539 
naming convention.

221
00:08:07.540 --> 00:08:09.999 
And until today, IBM has

222
00:08:10.000 --> 00:08:11.919 
2 name formats -

223
00:08:11.920 --> 00:08:13.779 
the older one, which is named

224
00:08:13.780 --> 00:08:15.759 
Format0 and the newer one,

225
00:08:15.760 --> 00:08:16.929 
which is named Format1.

226
00:08:19.090 --> 00:08:20.919 
Creating an IBM i program

227
00:08:20.920 --> 00:08:21.940 
is similar

228
00:08:23.200 --> 00:08:24.670 
to creating a Java

229
00:08:25.810 --> 00:08:26.810 
object.

230
00:08:27.550 --> 00:08:30.969 
This is a two step compiler

231
00:08:30.970 --> 00:08:32.918 
and the first step will be done by

232
00:08:32.919 --> 00:08:34.749 
the user itself, by

233
00:08:34.750 --> 00:08:35.750 
the programmers.

234
00:08:36.580 --> 00:08:38.408 
The second step will be

235
00:08:38.409 --> 00:08:40.749 
done by the operating system

236
00:08:40.750 --> 00:08:42.999 
with the kind of compiler

237
00:08:43.000 --> 00:08:45.159 
under the machine interface

238
00:08:45.160 --> 00:08:46.268 
contained in the SLIC.

239
00:08:47.950 --> 00:08:50.079 
This compiler was called

240
00:08:50.080 --> 00:08:52.239 
translator and the translator

241
00:08:52.240 --> 00:08:54.159 
created the binary code for

242
00:08:54.160 --> 00:08:56.049 
the underlying hardware and

243
00:08:56.050 --> 00:08:58.149 
all this together

244
00:08:58.150 --> 00:09:00.240 
was the program object.

245
00:09:02.020 --> 00:09:03.909 
If you see the insides

246
00:09:03.910 --> 00:09:05.048 
of a program object,

247
00:09:06.070 --> 00:09:08.109 
as other program objects

248
00:09:08.110 --> 00:09:09.069 
have the header.

249
00:09:09.070 --> 00:09:11.769 
In the header, name,

250
00:09:11.770 --> 00:09:12.969 
owner and other informations are

251
00:09:12.970 --> 00:09:14.859 
stored. And one part was

252
00:09:14.860 --> 00:09:16.409 
also the translator version.

253
00:09:17.620 --> 00:09:19.419 
Of course, the program object

254
00:09:19.420 --> 00:09:21.049 
contains the binary instruction

255
00:09:21.050 --> 00:09:22.050 
stream.

256
00:09:22.480 --> 00:09:24.339 
And furthermore, there

257
00:09:24.340 --> 00:09:26.409 
was another part inside

258
00:09:26.410 --> 00:09:28.209 
the program object that's called

259
00:09:28.210 --> 00:09:29.210 
Observability.

260
00:09:30.220 --> 00:09:32.259 
This observability is contain debug

261
00:09:32.260 --> 00:09:33.969 
information and the program

262
00:09:33.970 --> 00:09:34.899 
template.

263
00:09:34.900 --> 00:09:36.789 
And this is the secret why we

264
00:09:36.790 --> 00:09:38.919 
can change the hardware without

265
00:09:38.920 --> 00:09:40.740 
impact of the program.

266
00:09:42.500 --> 00:09:44.589 
A simple way to 64 bit

267
00:09:44.590 --> 00:09:46.479 
was shown in the

268
00:09:46.480 --> 00:09:48.909 
year 1994

269
00:09:48.910 --> 00:09:50.799 
when IBM decided to change the

270
00:09:50.800 --> 00:09:53.289 
hardware from the 48 bit

271
00:09:53.290 --> 00:09:55.329 
CISC environment to a 64

272
00:09:55.330 --> 00:09:57.099 
bit RISC environment.

273
00:09:57.100 --> 00:09:59.499 
And all the customers had to do was

274
00:09:59.500 --> 00:10:01.509 
to save their applications on the

275
00:10:01.510 --> 00:10:03.459 
older side and restore

276
00:10:03.460 --> 00:10:04.749 
it on the newer side.

277
00:10:05.770 --> 00:10:08.047 
So but this migration

278
00:10:09.590 --> 00:10:11.189 
is not finished.

279
00:10:11.190 --> 00:10:13.769 
The objects on the newer hardware

280
00:10:13.770 --> 00:10:15.772 
are still containing the CISC

281
00:10:15.773 --> 00:10:17.999 
code, so the operating

282
00:10:18.000 --> 00:10:20.489 
system had to do something

283
00:10:20.490 --> 00:10:21.720 
by their own.

284
00:10:23.190 --> 00:10:25.589 
At first because of the translator

285
00:10:25.590 --> 00:10:27.719 
version, the operating system

286
00:10:27.720 --> 00:10:29.579 
is aware that the code

287
00:10:29.580 --> 00:10:31.619 
stored inside the program object

288
00:10:31.620 --> 00:10:33.599 
is not the right one.

289
00:10:33.600 --> 00:10:35.969 
So they can use the template

290
00:10:35.970 --> 00:10:37.799 
stored in the object and

291
00:10:37.800 --> 00:10:40.319 
can create the newer one

292
00:10:40.320 --> 00:10:42.179 
by compiling the

293
00:10:42.180 --> 00:10:44.099 
object with the new translator in

294
00:10:44.100 --> 00:10:45.389 
the SLIC.

295
00:10:45.390 --> 00:10:46.390 
And after that

296
00:10:47.460 --> 00:10:49.589 
you can delete the older objects

297
00:10:49.590 --> 00:10:51.059 
and the migration is finished.

298
00:10:53.040 --> 00:10:55.169 
This one is very easy

299
00:10:55.170 --> 00:10:56.170 
and

300
00:10:57.060 --> 00:10:59.279 
at the end of the day, it's

301
00:10:59.280 --> 00:11:01.229 
really a good advantage of

302
00:11:01.230 --> 00:11:02.249 
this architecture.

303
00:11:04.210 --> 00:11:06.119 
Another advantage of

304
00:11:06.120 --> 00:11:08.129 
the machine interface was

305
00:11:08.130 --> 00:11:10.199 
shown in mid of the 90s

306
00:11:10.200 --> 00:11:12.689 
when IBM decided to create a new

307
00:11:12.690 --> 00:11:14.549 
S/36 environment, which

308
00:11:14.550 --> 00:11:17.009 
was an mid-range system.

309
00:11:17.010 --> 00:11:18.479 
They decided to implement the

310
00:11:18.480 --> 00:11:20.849 
operating system S/36

311
00:11:20.850 --> 00:11:22.456 
inside an AS/400.

312
00:11:23.640 --> 00:11:25.439 
How they did it?

313
00:11:25.440 --> 00:11:27.929 
They extended the machine interface

314
00:11:27.930 --> 00:11:29.879 
and so the users

315
00:11:29.880 --> 00:11:32.339 
could run S/36 programs

316
00:11:32.340 --> 00:11:34.589 
as well as RS/400 programs

317
00:11:34.590 --> 00:11:36.329 
on the same machine.

318
00:11:38.280 --> 00:11:39.280 
Furthermore,

319
00:11:40.760 --> 00:11:42.979 
they created end of the 90s,

320
00:11:42.980 --> 00:11:44.809 
an environment called

321
00:11:44.810 --> 00:11:46.099 
PASE. PASE means Portable

322
00:11:46.100 --> 00:11:48.079 
Applications Solution Environment

323
00:11:48.080 --> 00:11:49.919 
and this in runtime environment for

324
00:11:49.920 --> 00:11:52.819 
UNIX applications

325
00:11:52.820 --> 00:11:54.230 
from IBM called

326
00:11:55.340 --> 00:11:57.289 
AIX because IBM used the same

327
00:11:57.290 --> 00:11:59.209 
processor technology,

328
00:11:59.210 --> 00:12:01.159 
they could run on the same

329
00:12:01.160 --> 00:12:02.029 
system.

330
00:12:02.030 --> 00:12:03.919 
The processor itself

331
00:12:03.920 --> 00:12:06.019 
has three modes.

332
00:12:06.020 --> 00:12:07.999 
The first mode was the AS/400

333
00:12:08.000 --> 00:12:10.099 
mode and the second mode and default

334
00:12:10.100 --> 00:12:12.039 
mode was a Unix mode, the 64

335
00:12:12.040 --> 00:12:13.879 
or 32 bit

336
00:12:13.880 --> 00:12:16.161 
mode for AIX

337
00:12:16.162 --> 00:12:17.539 
applications.

338
00:12:17.540 --> 00:12:18.540 
To extend

339
00:12:19.580 --> 00:12:22.489 
the machine interface, iBM

340
00:12:22.490 --> 00:12:24.529 
could now execute

341
00:12:24.530 --> 00:12:25.530 
an AIX compiled application

342
00:12:28.190 --> 00:12:30.213 
inside an AS/400 environment.

343
00:12:31.430 --> 00:12:33.409 
This is very important because a lot

344
00:12:33.410 --> 00:12:35.299 
of newer

345
00:12:35.300 --> 00:12:36.300 
software

346
00:12:37.240 --> 00:12:39.399 
coming from AIX, like

347
00:12:39.400 --> 00:12:40.840 
the Java Virtual Machine,

348
00:12:42.160 --> 00:12:44.619 
our dynamic DNS

349
00:12:44.620 --> 00:12:46.179 
or something else.

350
00:12:46.180 --> 00:12:48.249 
And today it's very important

351
00:12:48.250 --> 00:12:50.259 
because we can

352
00:12:50.260 --> 00:12:52.569 
also run Linux applications

353
00:12:52.570 --> 00:12:54.879 
in this environment too.

354
00:12:54.880 --> 00:12:56.199 
This environment has a good

355
00:12:56.200 --> 00:12:58.779 
integration to the AS/400 side.

356
00:12:58.780 --> 00:13:00.601 
You can use PASE

357
00:13:00.602 --> 00:13:02.469 
applications in combining with

358
00:13:02.470 --> 00:13:03.542 
AS/400 objects.

359
00:13:05.650 --> 00:13:07.509 
This is very important when

360
00:13:07.510 --> 00:13:09.309 
you show, when you look at the

361
00:13:09.310 --> 00:13:11.169 
modern application development,

362
00:13:12.370 --> 00:13:14.199 
we can use the PASE open

363
00:13:14.200 --> 00:13:16.179 
source as a connector

364
00:13:16.180 --> 00:13:18.279 
between the user

365
00:13:18.280 --> 00:13:20.619 
interfaces and

366
00:13:20.620 --> 00:13:21.620 
AS/400back end

367
00:13:22.690 --> 00:13:23.690 
where you can

368
00:13:25.630 --> 00:13:27.690 
build Web services from

369
00:13:30.390 --> 00:13:32.279 
old APG objects, and you can also

370
00:13:32.280 --> 00:13:34.379 
use the functionality

371
00:13:34.380 --> 00:13:36.534 
of the SQL database.

372
00:13:38.130 --> 00:13:39.809 
Thank you. That's all for today.
