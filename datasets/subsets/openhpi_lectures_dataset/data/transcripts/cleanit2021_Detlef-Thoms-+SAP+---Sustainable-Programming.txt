WEBVTT

1
00:00:13.360 --> 00:00:16.790 
Hello and welcome to the session on
Sustainable Programming. My name is

2
00:00:16.790 --> 00:00:20.190 
Detlef Thoms and I'm the Chief Product
Expert within the central Performance

3
00:00:20.190 --> 00:00:22.130 
and Scalability
team at SAP.

4
00:00:24.040 --> 00:00:28.810 
Our team has the mission to ensure
that SAP software is performant,

5
00:00:28.860 --> 00:00:30.860 
scalable and
sustainable.

6
00:00:33.280 --> 00:00:37.780 
You already heard in the welcome video
by Thomas Saueressig, SAP's

7
00:00:37.780 --> 00:00:40.340 
Executive Board Member
for Product Engineering,

8
00:00:41.170 --> 00:00:45.540 
that climate action is a topic
that affects almost everything

9
00:00:45.690 --> 00:00:47.050 
and everyone today.

10
00:00:49.720 --> 00:00:53.130 
In this session you will learn
how sustainable programming

11
00:00:53.140 --> 00:00:55.910 
fits into SAP's
sustainability journey.

12
00:00:57.190 --> 00:01:02.190 
You will gain insight into some of the
performance and scalability recommendations

13
00:01:02.470 --> 00:01:04.690 
that we use in
product development.

14
00:01:06.590 --> 00:01:11.370 
SAP has a vision. We want to help the world
run better and improve people's lives.

15
00:01:11.790 --> 00:01:14.640 
Sustainability is an important
part of this vision.

16
00:01:15.720 --> 00:01:20.420 
We want to create a positive
economic, environmental and social

17
00:01:20.420 --> 00:01:21.830 
impact for the planet.

18
00:01:23.640 --> 00:01:26.830 
Reducing energy consumption and
greenhouse gas emissions are

19
00:01:26.830 --> 00:01:29.720 
crucial factors to the
health of our environment.

20
00:01:31.290 --> 00:01:37.150 
SAP sees itself into two roles when
driving sustainability - as an enabler

21
00:01:37.430 --> 00:01:38.580 
and as exemplar.

22
00:01:40.840 --> 00:01:46.050 
As enablers, we want to provide our
customers with products and services

23
00:01:46.500 --> 00:01:50.940 
that enable them to meet their
sustainability challenges and

24
00:01:50.980 --> 00:01:52.040 
opportunities.

25
00:01:54.940 --> 00:02:00.240 
SAP's Climate21 solution
as the enabler for sustainability

26
00:02:00.550 --> 00:02:03.180 
was introduced in a
video by Priti Prabhoo,

27
00:02:03.590 --> 00:02:07.090 
vice president and head of product
management for climate 21.

28
00:02:08.410 --> 00:02:13.050 
Please check out her introduction
and related openSAP course

29
00:02:13.410 --> 00:02:16.530 
"Business Success with Climate
Action" for more details.

30
00:02:18.320 --> 00:02:22.750 
As examplar, we have the goal
to significantly reduce

31
00:02:22.760 --> 00:02:24.920 
our own ecological
footprint.

32
00:02:26.670 --> 00:02:31.990 
For energy consumption our data centers
have become an important focus

33
00:02:32.130 --> 00:02:35.400 
as more and more of our
business moves to the cloud.

34
00:02:37.610 --> 00:02:42.960 
Energy consumption in our data centers is
closely related to technology innovation

35
00:02:43.190 --> 00:02:45.690 
and customer adoption
of our solutions.

36
00:02:47.700 --> 00:02:53.130 
Following our environmental strategy, we
have created the "Green Cloud" at SAP.

37
00:02:54.700 --> 00:03:00.420 
Since 2014, we are
all ready powering all of SAP's

38
00:03:00.420 --> 00:03:04.570 
internal and external
data centers with one hundred

39
00:03:04.570 --> 00:03:08.600 
percent renewable electricity to achieve
a data center carbon footprint

40
00:03:08.930 --> 00:03:09.680 
of zero.

41
00:03:11.800 --> 00:03:16.300 
Being an exemplar is also where
sustainable programming enters the game.

42
00:03:16.420 --> 00:03:21.370 
How can each developer contribute in
reducing the energy consumption?

43
00:03:23.170 --> 00:03:27.960 
For software developers being sustainable
and contributing to Green IT

44
00:03:28.460 --> 00:03:33.660 
means designing software programs that make
efficient use of computing resources.

45
00:03:34.030 --> 00:03:38.750 
For SAP developers and architects,
this becomes even more imperative

46
00:03:39.240 --> 00:03:43.810 
if we take the huge number of business
transactions worldwide into consideration

47
00:03:44.290 --> 00:03:47.900 
that are handled by an SAP
system in one way or another.

48
00:03:48.950 --> 00:03:54.500 
The key question is how computing
and storage power can be

49
00:03:54.500 --> 00:03:57.810 
provided with minimum
environmental impact

50
00:03:58.460 --> 00:04:02.230 
and how to solve the challenge
in finding the right balance

51
00:04:02.540 --> 00:04:09.130 
between End-to-End Response Time, Throughput
and Economical/Sustainable Resource Consumption.

52
00:04:10.750 --> 00:04:15.040 
This means that during the development
process the energy consumption

53
00:04:15.040 --> 00:04:19.940 
of different software architectures
needs to be measured and assessed.

54
00:04:21.020 --> 00:04:24.550 
A great deal can be achieved
with just a little effort.

55
00:04:25.220 --> 00:04:29.480 
Often it is a quite
manageable set of decisions

56
00:04:30.010 --> 00:04:33.090 
which lead to significant
differences in power consumption.

57
00:04:34.070 --> 00:04:39.190 
By "significant impact" I mean that
large business applications

58
00:04:39.190 --> 00:04:43.690 
can save the amount of the energy
consumed by a medium sized

59
00:04:43.690 --> 00:04:45.020 
city in a year.

60
00:04:47.010 --> 00:04:49.160 
Let's have a look at
the following example.

61
00:04:51.060 --> 00:04:56.720 
Our reference is a typical data set environment for
high volume transaction business applications.

62
00:04:58.330 --> 00:05:01.700 
On the right side of the
slide, you see a calculation.

63
00:05:02.640 --> 00:05:06.160 
Let us assume that a sustainable
programming measure

64
00:05:06.690 --> 00:05:08.650 
is successfully
implemented

65
00:05:09.710 --> 00:05:12.780 
and one CPU second is
saved as a result.

66
00:05:14.300 --> 00:05:18.910 
Typically, this saving corresponds
to an energy reduction of

67
00:05:18.910 --> 00:05:21.310 
ten watt-seconds
per transaction.

68
00:05:23.160 --> 00:05:27.540 
If such a transaction is performed
by one hundred five million users

69
00:05:27.890 --> 00:05:32.810 
twenty times a day on two hundred
thirty working days, the total

70
00:05:32.810 --> 00:05:35.700 
energy saved is nineteen
megawatt hours.

71
00:05:38.040 --> 00:05:44.050 
Now, if five hundred developers optimize
ten transactions in this way,

72
00:05:45.130 --> 00:05:48.650 
the energy saved amounts
to the equivalent

73
00:05:49.180 --> 00:05:53.010 
of the annual power consumption
of over thirty thousand

74
00:05:53.440 --> 00:05:54.980 
two person households.

75
00:05:55.640 --> 00:05:58.890 
According to the power consumption
index of the German government.

76
00:06:00.110 --> 00:06:06.790 
From this back-of-the-envelope calculation we
see that sustainable programming measures

77
00:06:07.180 --> 00:06:08.980 
can have a big impact.

78
00:06:11.590 --> 00:06:14.770 
Let's see how we get there
in SAP development.

79
00:06:15.580 --> 00:06:20.080 
The question is, how do we use
this knowledge and practice? How

80
00:06:20.080 --> 00:06:24.710 
can we make sure that all developers
know what they should do?

81
00:06:26.700 --> 00:06:29.690 
At SAP, we did not have
to start from scratch.

82
00:06:30.710 --> 00:06:34.330 
We already had an ever evolving
base of recommendations

83
00:06:34.750 --> 00:06:36.640 
for the efficient
use of hardware.

84
00:06:39.530 --> 00:06:44.380 
They have been used for internal quality
management since the nineteen nineties.

85
00:06:45.330 --> 00:06:49.580 
These performance recommendations
enable developers to achieve

86
00:06:49.590 --> 00:06:53.210 
optimal system response
times and data throughput.

87
00:06:54.390 --> 00:06:59.290 
Furthermore they give guidance on
how to efficiently use system

88
00:06:59.300 --> 00:07:04.900 
resources in a way that
scalability is achieved.

89
00:07:06.720 --> 00:07:10.620 
Of course these measures implicitly
lead to greater energy efficiency.

90
00:07:12.340 --> 00:07:15.910 
In the beginning, it wasn't our
goal to save energy explicitly

91
00:07:15.990 --> 00:07:18.550 
but we changed our
perspective ten years ago.

92
00:07:19.450 --> 00:07:22.500 
Energy efficiency is an
important requirement today

93
00:07:23.150 --> 00:07:27.030 
and just as important as
performance and scalability.

94
00:07:28.060 --> 00:07:33.090 
As a result, we have included power
consumption as an additional criteria.

95
00:07:35.270 --> 00:07:38.300 
The recommendations I will
introduce with the next slides are

96
00:07:38.300 --> 00:07:40.690 
pragmatic steps for
software development.

97
00:07:41.360 --> 00:07:46.510 
They do not claim to provide a
comprehensive approach to accomplishing

98
00:07:46.520 --> 00:07:49.680 
energy efficient software
development in every organization.

99
00:07:50.780 --> 00:07:57.430 
Rather they serve as examples to explain
the theoretical and practical principles

100
00:07:57.810 --> 00:08:00.720 
on which sustainable
programming is based.

101
00:08:03.430 --> 00:08:09.360 
Please note that there are of course many more
basic common sense recommendations, like

102
00:08:09.660 --> 00:08:13.710 
optimization of algorithms
or avoidance of memory-leaks.

103
00:08:15.730 --> 00:08:19.590 
These I will not cover here but
view them as table-stakes for

104
00:08:19.590 --> 00:08:21.060 
coding best practices.

105
00:08:24.510 --> 00:08:30.290 
Let's start with recommendations for communication
across a distributed application stack.

106
00:08:31.060 --> 00:08:35.470 
Here we look at a sketch of a typical
distributed application stick.

107
00:08:35.980 --> 00:08:41.300 
We include tiers for UI, UI
integration, service, and database.

108
00:08:42.500 --> 00:08:45.930 
They all communicate and
exchange data via network.

109
00:08:48.420 --> 00:08:53.950 
With regards to the network communication
there are two determining factors.

110
00:08:54.580 --> 00:08:58.140 
Network round-trips and
transferred data volume.

111
00:09:01.100 --> 00:09:07.030 
Both require energy consumption in terms
of CPU cycles for data processing

112
00:09:07.550 --> 00:09:10.930 
and for data transmission
as an electronic signal.

113
00:09:13.090 --> 00:09:18.000 
Whenever possible, the aim is to
buffer the required data where

114
00:09:18.000 --> 00:09:20.230 
the computational
tasks arise.

115
00:09:21.290 --> 00:09:25.340 
This is the only way to avoid energy
intensive and time-consuming

116
00:09:25.350 --> 00:09:29.060 
round trips through the complete
stack in a system landscape.

117
00:09:29.560 --> 00:09:33.580 
Here are some programming
recommendation SAP is using:

118
00:09:35.210 --> 00:09:39.450 
in these cases we increase performance
and lower energy consumption.

119
00:09:40.520 --> 00:09:43.510 
This has a positive impact
on sustainability.

120
00:09:46.230 --> 00:09:52.330 
First distribute functionality smartly
over the tears to reduce communication.

121
00:09:53.830 --> 00:09:59.980 
Second, share the static resources
globally in a content delivery network.

122
00:10:01.900 --> 00:10:08.450 
Third, reduce the number of network
round-trips by caching static meta-data.

123
00:10:10.050 --> 00:10:14.750 
Fourth, minimize the amount of
transferred data by using compression.

124
00:10:18.240 --> 00:10:22.380 
Now, let's go one level deeper and
zoom in on the energy efficient

125
00:10:22.380 --> 00:10:27.660 
use of the database. In traditional
row-orientated database systems,

126
00:10:27.960 --> 00:10:31.870 
indices are used to speed up
access on column stores

127
00:10:32.390 --> 00:10:34.540 
that are often used
for data selection.

128
00:10:36.540 --> 00:10:42.580 
Without indices, full table scans are performed
leading to large query response times,

129
00:10:42.990 --> 00:10:45.270 
often involving
disk accesses.

130
00:10:47.310 --> 00:10:52.090 
Therefore in row-based databases
indices are everywhere.

131
00:10:53.570 --> 00:10:57.390 
Of course these helper structures
introduce data redundancy

132
00:10:57.660 --> 00:11:01.670 
and substantial maintaining
costs when changing data.

133
00:11:03.490 --> 00:11:06.350 
Therefore, only a few
indices should be defined.

134
00:11:08.620 --> 00:11:12.410 
Let us now have a look at
modern column orientated

135
00:11:12.830 --> 00:11:15.740 
in-memory database
systems like SAP HANA.

136
00:11:17.660 --> 00:11:23.450 
A data select operation on an attribute
only requires a column can.

137
00:11:24.480 --> 00:11:27.870 
This is performed much faster
than a complete table scan.

138
00:11:29.540 --> 00:11:34.430 
And of course we see a sustainability
advantage because energy

139
00:11:34.430 --> 00:11:37.470 
consuming disk
accesses are avoided.

140
00:11:39.360 --> 00:11:41.830 
We can aggregate data
on the fly in memory

141
00:11:42.240 --> 00:11:45.280 
without explicit
indices because

142
00:11:45.960 --> 00:11:49.920 
with columnar store, every
column is an index by default.

143
00:11:52.050 --> 00:11:55.970 
So why should our developers
care about additional indices?

144
00:11:58.730 --> 00:12:04.160 
Well, it turns out that there are
special cases when indices can indeed

145
00:12:04.590 --> 00:12:10.810 
bring benefits. That is the case when
we want to query very selectively

146
00:12:11.150 --> 00:12:15.340 
and very frequently on
extremely large columns.

147
00:12:16.220 --> 00:12:20.640 
Then secondary indices are the right
tool to reduce CPU consumption

148
00:12:20.890 --> 00:12:23.150 
and consequently
save energy.

149
00:12:25.340 --> 00:12:31.270 
As an example are business systems that handle
very high volumes of specific accesses

150
00:12:31.700 --> 00:12:34.910 
with the same highly parallel
repetitive processes.

151
00:12:36.790 --> 00:12:40.380 
If we want to make a single
request under these conditions,

152
00:12:40.940 --> 00:12:46.700 
then we have response times that can even
be noticed in an in-memory architecture.

153
00:12:48.460 --> 00:12:53.150 
In such a case it is beneficial -
both from an ecological

154
00:12:53.590 --> 00:12:58.740 
and economic perspective - to
implement an explicit index, so

155
00:12:58.740 --> 00:13:01.470 
that a full column scan
is not necessary.

156
00:13:04.680 --> 00:13:08.960 
By means of an explicit index,
the data is sorted or hashed.

157
00:13:09.490 --> 00:13:14.790 
As a result, the access based on an index
is faster than a full column scan

158
00:13:15.110 --> 00:13:19.760 
and a CPU consumption is nearly
independent of the size of the table.

159
00:13:22.050 --> 00:13:26.730 
We calculated the resource savings for a
table with one hundred million entries.

160
00:13:28.320 --> 00:13:33.400 
Without an index, power consumption
would have been 5.4
161

161
00:13:33.400 --> 00:13:35.670 
watt-seconds
per query.

162
00:13:36.820 --> 00:13:41.540 
With the index, we had 0.035
watt-seconds.

163
00:13:42.340 --> 00:13:47.720 
This corresponds to a reduction by a
factor of one hundred fifty five.

164
00:13:49.990 --> 00:13:53.640 
Of course there are situations
where the excess optimization

165
00:13:53.650 --> 00:14:00.160 
cannot be done with indices. For this let's
have a look at dynamic caching structures.

166
00:14:01.430 --> 00:14:05.150 
The additional sustainability
challenge can be illustrated

167
00:14:05.230 --> 00:14:08.410 
in another example for
in-memory database computing.

168
00:14:09.810 --> 00:14:16.710 
In traditional databases, a necessary method was
to store certain aggregated database content

169
00:14:17.250 --> 00:14:19.690 
additionally in
aggregation tables.

170
00:14:21.380 --> 00:14:25.160 
This was content that was used,
for example, in scenarios which

171
00:14:25.160 --> 00:14:30.770 
repeatedly needed to determine total
inventory, as fast as possible.

172
00:14:32.910 --> 00:14:37.060 
Let's think of a purchasing
department that wants to determine

173
00:14:37.440 --> 00:14:41.670 
the value of all the open purchase
orders without selecting

174
00:14:41.870 --> 00:14:43.840 
all the sales
orders to do this.

175
00:14:45.690 --> 00:14:48.960 
Of course, this method
has its price.

176
00:14:50.150 --> 00:14:53.260 
Every time a new customer
document arrives,

177
00:14:54.010 --> 00:14:56.410 
both the table with the
customer document

178
00:14:56.880 --> 00:15:00.040 
and the aggregation table
has to be updated.

179
00:15:00.530 --> 00:15:06.360 
In high-volume businesses with massively
parallel requirements, these aggregates

180
00:15:06.650 --> 00:15:11.360 
limit the possible throughputs
in traditional databases due

181
00:15:11.360 --> 00:15:13.650 
to the update
lock collisions.

182
00:15:15.460 --> 00:15:18.670 
In memory computing offers
us the opportunity

183
00:15:19.360 --> 00:15:23.180 
to form such an aggregate
only when required -

184
00:15:24.420 --> 00:15:32.440 
on the fly - in a lock-free design and then evaluate
it ad hoc without compromising performance.

185
00:15:34.080 --> 00:15:39.820 
Lock-free designs are by themselves a
significant enabler for sustainability.

186
00:15:41.370 --> 00:15:44.820 
Transition to a lock-free design
might allow consolidation

187
00:15:44.820 --> 00:15:50.860 
of multiple system into one, substantially
optimizing the infrastructure overhead.

188
00:15:51.340 --> 00:15:55.680 
Under certain circumstances there
are application scenarios

189
00:15:56.060 --> 00:16:00.410 
where repeated on-the-fly aggregation
leads to high CPU consumption,

190
00:16:01.220 --> 00:16:06.240 
which can then be significantly
improved by using dynamic caching

191
00:16:06.240 --> 00:16:07.040 
structures.

192
00:16:09.050 --> 00:16:09.890 
For example,

193
00:16:11.320 --> 00:16:16.130 
in the automotive industry when a
vehicle moves along a production line

194
00:16:16.370 --> 00:16:21.030 
and at the same time it is necessary
to document which materials

195
00:16:21.030 --> 00:16:23.170 
are used at what
point in time.

196
00:16:24.980 --> 00:16:30.130 
In a typical automotive scenario, around
half a million inventory checks

197
00:16:30.540 --> 00:16:36.770 
are made every hour to record the relevant
material movements from the warehouse

198
00:16:37.120 --> 00:16:38.190 
to the manufacturing.

199
00:16:41.280 --> 00:16:46.060 
Anyone who decides exclusively
for ad-hoc reporting here will

200
00:16:46.060 --> 00:16:48.790 
have to deal with five
hundred thousand

201
00:16:49.280 --> 00:16:51.630 
on-the-fly aggregations
every hour.

202
00:16:52.430 --> 00:16:57.750 
And every aggregation works on a database
with easily three hundred thousand entries.

203
00:16:58.990 --> 00:17:02.580 
This means we would have to
aggregate three hundred thousand

204
00:17:02.590 --> 00:17:05.310 
articles five hundred
thousand times.

205
00:17:06.300 --> 00:17:11.840 
Hourly inventory checks of this size
require up to thirty CPU cores.

206
00:17:13.930 --> 00:17:17.730 
In these cases it is
significantly more sustainable

207
00:17:18.130 --> 00:17:22.150 
to use dynamic caching structures
which make the database content

208
00:17:22.150 --> 00:17:27.680 
to be processed available and thus
complement on-the-fly aggregation.

209
00:17:28.910 --> 00:17:32.100 
These were some of the recommendations
for sustainable programming

210
00:17:32.220 --> 00:17:33.610 
in use at SAP.

211
00:17:36.360 --> 00:17:41.050 
To wrap up this introduction,
let's take a step back and look

212
00:17:41.050 --> 00:17:45.040 
at the common patters in
our optimization strategy.

213
00:17:46.340 --> 00:17:50.220 
Let's have a look at the main
power consumers in an SAP system

214
00:17:50.230 --> 00:17:52.590 
that can be influenced
by software design:

215
00:17:53.050 --> 00:17:57.390 
the CPU, the memory, the
hard disk and the network.

216
00:17:59.110 --> 00:18:03.700 
Analyzing these components helps
you fully understand how your

217
00:18:03.700 --> 00:18:06.230 
application is using
hardware resources.

218
00:18:08.460 --> 00:18:12.970 
It is important to bear in mind
that the energy requirement

219
00:18:13.090 --> 00:18:16.010 
of these four components
are connected.

220
00:18:17.830 --> 00:18:21.300 
Reducing consumption
at one point always

221
00:18:21.710 --> 00:18:25.470 
affects the energy appetite
of the other three factors.

222
00:18:26.820 --> 00:18:31.290 
Gaining a clear picture of these
interdependecies will determine

223
00:18:31.290 --> 00:18:34.200 
the success of our
sustainability measures.

224
00:18:36.490 --> 00:18:41.860 
There's no magic bullet for all software-
development areas and organizations.

225
00:18:43.430 --> 00:18:47.640 
Our optimization strategy
is based on these three

226
00:18:48.080 --> 00:18:49.090 
cornerstones:

227
00:18:51.350 --> 00:18:54.350 
in memory computing
rather than disk I/O,

228
00:18:57.370 --> 00:19:00.220 
caches rather than
CPU cycles,

229
00:19:02.820 --> 00:19:08.250 
content delivery network and code
pushdown rather than high data transfer

230
00:19:08.370 --> 00:19:10.710 
and a large number
of round trips.

231
00:19:13.670 --> 00:19:18.730 
This strategy leads to an increased
energy consumption in the memory,

232
00:19:19.430 --> 00:19:24.260 
the total energy balance is kept
positive thanks to savings

233
00:19:24.270 --> 00:19:28.480 
in the other components (that
is, CPU, hard disk and network).

234
00:19:31.190 --> 00:19:35.550 
So please keep in mind that you
need to devise a strategy to

235
00:19:35.550 --> 00:19:39.640 
optimize the four big
interdependent power components

236
00:19:40.350 --> 00:19:45.080 
without negatively impacting
performance, as outlined before.

237
00:19:47.470 --> 00:19:53.260 
Software engineers can achieve success not
only through the features they build

238
00:19:53.990 --> 00:19:57.020 
but also through the
energy they save.

239
00:19:59.050 --> 00:20:03.060 
With this, I am at the end of my
presentation on sustainable programming.

240
00:20:05.060 --> 00:20:10.920 
In this overview session, I did show why
we consider sustainable programming

241
00:20:11.460 --> 00:20:19.110 
important at SAP and which optimization
strategy and programming recommendations

242
00:20:19.510 --> 00:20:20.180 
we use.

243
00:20:24.160 --> 00:20:29.420 
In a second video we will introduce
some basics behind the calculation

244
00:20:29.960 --> 00:20:33.860 
of carbon footprint for running
applications on Premise or

245
00:20:33.870 --> 00:20:34.630 
in the Cloud.

246
00:20:38.030 --> 00:20:39.970 
Thank you very much
for taking your time.
