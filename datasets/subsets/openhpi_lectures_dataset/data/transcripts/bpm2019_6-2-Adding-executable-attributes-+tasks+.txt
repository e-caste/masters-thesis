WEBVTT

1
00:00:00.620 --> 00:00:04.260 
Well hello and welcome back.
Obviously Nela gave you guys

2
00:00:04.260 --> 00:00:08.780 
a very nice example on how this
execution as a concept kind

3
00:00:08.780 --> 00:00:11.680 
of works and we're going to
start now talking about how

4
00:00:12.160 --> 00:00:15.410 
adding these attributes really
happens, how we really

5
00:00:15.410 --> 00:00:19.020 
really make the engine understand
executable processes.

6
00:00:19.020 --> 00:00:24.490 
We are of course going to start with
tasks. So the majority of processes

7
00:00:24.620 --> 00:00:28.310 
kind of can be completely modelled
using these three task types.

8
00:00:28.500 --> 00:00:31.520 
In most cases are the most important
because of the most commonly

9
00:00:31.520 --> 00:00:36.440 
used and basically contain most of
the use cases. A service task

10
00:00:36.620 --> 00:00:40.060 
a user task and a business
rules task. So any of those

11
00:00:40.060 --> 00:00:43.940 
tasks your favourite? Nope,
yours? Umm not really. I am

12
00:00:43.940 --> 00:00:46.750 
kind of more into the deep cuts
of BPMN. We prefer the really

13
00:00:46.750 --> 00:00:49.830 
obscure tasks no-one really knows
about, but we'll talk about those

14
00:00:49.830 --> 00:00:54.130 
a little later on. So these let me
talk to each of these individually.

15
00:00:55.150 --> 00:00:58.160 
First of all the service task-
the service task is used when

16
00:00:58.160 --> 00:01:00.730 
you actually want to run some
kind of code you want to call

17
00:01:00.730 --> 00:01:04.110 
some kind of system make a calculation
but basically what you're

18
00:01:04.110 --> 00:01:07.530 
doing is you're having an automated
service produce some kind

19
00:01:07.530 --> 00:01:11.030 
of data usually or or do something
for you. And this could be

20
00:01:11.030 --> 00:01:13.760 
something like sending an email
maybe it could be something

21
00:01:13.760 --> 00:01:16.750 
like calculating an insurance
premium. Whatever it is, it just

22
00:01:16.750 --> 00:01:20.690 
means a code is being run on the
engine is letting that code

23
00:01:20.690 --> 00:01:22.420 
know that now it's
time to do that.

24
00:01:23.120 --> 00:01:26.680 
And we also have a user task
there. Now user task is for when

25
00:01:26.680 --> 00:01:29.900 
we have a user we would quite
like to get information from.

26
00:01:30.120 --> 00:01:34.240 
This means that we can not continue the
process until a human worker from kind

27
00:01:34.340 --> 00:01:38.210 
as may be seen some kind of data
and approved it or has entered

28
00:01:38.210 --> 00:01:42.410 
some sort of data into a into
a website. Now for that it

29
00:01:42.410 --> 00:01:48.080 
means that that task needs some
kind of pointer to a UI. Now

30
00:01:48.080 --> 00:01:50.830 
as a service task we need to
point out a specific system

31
00:01:51.180 --> 00:01:54.980 
and then run that this would need
to show the user some kind of

32
00:01:55.840 --> 00:01:59.590 
a front end some kind of
interface that the user can

33
00:01:59.590 --> 00:02:03.610 
then enter some data and then
complete the task. Now in the

34
00:02:03.610 --> 00:02:07.040 
final there's a business rules
task and this guy right

35
00:02:07.040 --> 00:02:11.960 
here is used in order to take
the context of the data in

36
00:02:11.960 --> 00:02:14.560 
the current instance and actually
be able to make a decision

37
00:02:14.760 --> 00:02:19.120 
based on the current context. That
usually means it implements

38
00:02:19.120 --> 00:02:22.200 
DMN decision model notation
which we talked about earlier.

39
00:02:22.470 --> 00:02:26.110 
Well not we, but someone
did earlier and

40
00:02:26.880 --> 00:02:30.510 
that particular method says
that will take a whole bunch

41
00:02:30.510 --> 00:02:34.360 
of data from the context will run
through some rules and will produce

42
00:02:34.680 --> 00:02:38.240 
a variable that tells us what the
result of that distance rule is.

43
00:02:39.410 --> 00:02:41.380 
So let's take a look at the
service task first of all.

44
00:02:41.980 --> 00:02:46.290 
Most of the time a service task
tends to run java code. And

45
00:02:46.290 --> 00:02:49.820 
that is because the Camunda
engine itself is a java based

46
00:02:49.820 --> 00:02:53.870 
engine. So it's very easy to
communicate to the engine via java

47
00:02:53.950 --> 00:02:57.890 
the primary API is in java as
well. So if you actually wanted

48
00:02:57.890 --> 00:03:01.690 
to call a system or make some sort
of code run it's it's usually

49
00:03:01.690 --> 00:03:04.660 
a really really good idea
to use a java class.

50
00:03:05.360 --> 00:03:09.090 
Now it's important to know that
the service task and the java

51
00:03:09.090 --> 00:03:11.890 
class are not intrinsically
locked together.

52
00:03:12.320 --> 00:03:16.900 
Rather the java class is independent
and deployed along with

53
00:03:17.010 --> 00:03:20.930 
the model but if not actually
embedded in it. Which means we

54
00:03:20.930 --> 00:03:25.950 
must be able to tell the service
task to be able to find

55
00:03:25.960 --> 00:03:29.410 
this java class somewhere. Now
we'll talk about deployments

56
00:03:29.410 --> 00:03:32.530 
a little later on but basically
it means that we need to have

57
00:03:32.530 --> 00:03:36.060 
some sort of method of addressing
where this is. So if we take

58
00:03:36.060 --> 00:03:38.730 
a look at the properties panel
the properties panel there on

59
00:03:38.730 --> 00:03:42.670 
the right is where you would add
all of the required semantics

60
00:03:42.670 --> 00:03:47.600 
when it comes to adding execution to
models. In this particular case

61
00:03:47.730 --> 00:03:51.380 
we have an implementation drop
down in which we have selected

62
00:03:51.380 --> 00:03:55.630 
java class. Now I quite like java as so
that's why I tend to use java classes

63
00:03:55.770 --> 00:04:00.090 
Nela, you have a preference I'm
sure. I would rather code things

64
00:04:00.090 --> 00:04:04.400 
on Python, and so I would go for an
implementation that has external tasks.

65
00:04:04.920 --> 00:04:09.340 
This means you could have other
code running in another language.

66
00:04:09.570 --> 00:04:12.990 
Exactly that that can be pretty
good so you don't need to use

67
00:04:12.990 --> 00:04:17.310 
java if you like Nela prefer python
and then you can absolutely

68
00:04:17.310 --> 00:04:20.470 
use whatever language you like. But
we won't talk about that right now.

69
00:04:20.620 --> 00:04:23.640 
With an external task you need to
add a topic and have a whole

70
00:04:23.710 --> 00:04:26.520 
method of subscription but we won't
talk that right now instead

71
00:04:26.560 --> 00:04:30.210 
we'll focus on java classes. Now
if you do select java class

72
00:04:30.300 --> 00:04:33.450 
it usually means you need to
deploy the model on the class

73
00:04:33.450 --> 00:04:36.640 
together we will talk about that
shortly. But that is where

74
00:04:36.640 --> 00:04:41.200 
we're able to use this pattern here.
Now this is called a qualified name

75
00:04:41.330 --> 00:04:45.340 
and this actually will tell us
where abouts in whereabouts

76
00:04:45.340 --> 00:04:48.890 
to find the specific class you want
to call. This is like an address.

77
00:04:49.110 --> 00:04:53.100 
And once you add that it means
in runtime when you start the

78
00:04:53.100 --> 00:04:57.180 
instance the engine will move the
token to the to the end service task

79
00:04:57.350 --> 00:04:59.170 
and then we'll end up
calling that class.

80
00:05:00.830 --> 00:05:03.970 
So user tasks next user
tasks are a little easier

81
00:05:04.490 --> 00:05:07.940 
in some degree because they're
not running code. Instead when

82
00:05:07.940 --> 00:05:11.540 
we get there we want to display
something to a user and there

83
00:05:11.540 --> 00:05:13.660 
are actually lots of ways of
doing this. But in the end the

84
00:05:13.660 --> 00:05:16.740 
user needs to be able to see a whole
bunch of data or some sort of

85
00:05:16.870 --> 00:05:22.070 
form fields and then be able to tell the
engine that the user has finished.

86
00:05:22.390 --> 00:05:25.590 
So that's what the complete button
there does. So that's our

87
00:05:25.590 --> 00:05:28.430 
main goal, we want to show
things to the user be able

88
00:05:28.430 --> 00:05:31.700 
to let them add some data if they
want and then complete the

89
00:05:31.700 --> 00:05:34.710 
task and then return to the engines
so the token can continue.

90
00:05:35.200 --> 00:05:37.600 
There is a lot of ways of doing
this in Camunda as I mentioned.

91
00:05:37.860 --> 00:05:40.100 
But the way we're going to do
it is the way we tend to use

92
00:05:40.100 --> 00:05:42.570 
for prototyping which is
called form fields.

93
00:05:43.040 --> 00:05:47.540 
Now form fields are used to really
quite quickly prototypes of front end

94
00:05:47.750 --> 00:05:53.290 
so which means we can add some
properties to the form fields

95
00:05:53.550 --> 00:05:58.450 
section in the properties
panel and then those will

96
00:05:58.450 --> 00:06:01.810 
be rendered into a UI. So for
instance if I click the little

97
00:06:01.810 --> 00:06:03.830 
button right there
I will end up

98
00:06:04.710 --> 00:06:08.810 
creating an element that would
then be used as a variable. So

99
00:06:08.810 --> 00:06:11.450 
here we have an ID section that
this actually gives us the

100
00:06:11.450 --> 00:06:15.710 
ID or the name of the variable
we're going to to be populating.

101
00:06:16.020 --> 00:06:20.350 
So in this case the invoice
category variable will actually

102
00:06:20.350 --> 00:06:25.510 
be some value that will be given to the
engine after the user completes the task.

103
00:06:25.800 --> 00:06:29.000 
Now how do we know what that
variable contains? Well the first

104
00:06:29.000 --> 00:06:32.900 
way is that we have a type mechanism
here and that says string.

105
00:06:33.070 --> 00:06:37.380 
So this means that this invoice
category will be a series of

106
00:06:37.780 --> 00:06:41.910 
alphanumeric characters of some kind.
And to tell the user themselves

107
00:06:41.920 --> 00:06:45.250 
what they are expected to put in there
we also have a label. And this

108
00:06:45.360 --> 00:06:49.700 
would in a human readable
way say invoice category.

109
00:06:49.930 --> 00:06:54.430 
Now what this means is that if this
gets rendered the user will see

110
00:06:54.560 --> 00:06:59.400 
a little label it says invoice
category followed by a space

111
00:06:59.400 --> 00:07:02.400 
to enter some kind of data. And
once the user completes it we

112
00:07:02.400 --> 00:07:06.210 
will then have a variable called
invoice category with that

113
00:07:06.270 --> 00:07:08.450 
added value of whatever
the user entered.

114
00:07:10.330 --> 00:07:14.840 
So next up business rules. So
in business rules the basic

115
00:07:14.840 --> 00:07:17.910 
idea is that we want to take
the current context as I said

116
00:07:17.990 --> 00:07:22.550 
and check against some rules and
in most cases that's DMN. So if

117
00:07:22.550 --> 00:07:26.570 
we see there we have a DMN
table generally gets called

118
00:07:26.580 --> 00:07:29.490 
from business rules task
and in this case we

119
00:07:29.490 --> 00:07:33.000 
are specifically interested in
breweries. Now I am a big fan

120
00:07:33.000 --> 00:07:36.130 
of mechanics, I quite like Danish
beer, what about yourself?

121
00:07:36.130 --> 00:07:40.970 
Your preference? Oh I like Guinness.
Really? Ok yeah its good.

122
00:07:40.970 --> 00:07:44.500 
Yeah no from ireland it is
good. Yeah so this can help

123
00:07:44.500 --> 00:07:48.820 
us actually say depending on
our current input which

124
00:07:48.820 --> 00:07:51.250 
is the Brewery name we can
find at the location.

125
00:07:51.830 --> 00:07:57.330 
Now the way to add DMN tables to
at these business rules tasks

126
00:07:57.470 --> 00:08:02.860 
is again similar enough
to the way service

127
00:08:02.860 --> 00:08:06.900 
tasks work because actually
we don't have to use

128
00:08:06.900 --> 00:08:10.410 
DMN but its most common so we
can select DMN from the drop

129
00:08:10.410 --> 00:08:15.320 
down there. And if we do we would then be
able to see the reference we're calling.

130
00:08:16.250 --> 00:08:19.650 
So this is saying okay I would
like the I would like you to

131
00:08:19.650 --> 00:08:24.110 
call this table call beverage
choice. So that means

132
00:08:24.110 --> 00:08:27.560 
that when we get to this point the
engine will then call the table

133
00:08:27.990 --> 00:08:31.620 
it'll populate the they'll go through
the rules and then return something.

134
00:08:31.790 --> 00:08:34.560 
And returning something is
important because the very last

135
00:08:34.560 --> 00:08:39.910 
thing we need to make sure we add is
the variable the result variable.

136
00:08:40.300 --> 00:08:43.500 
Because this is actually going to
store the result of our table.

137
00:08:44.070 --> 00:08:47.470 
And in this case would put it into
a variable called beverage.

138
00:08:48.270 --> 00:08:52.220 
So there are three main tasks
but of course there are more.

139
00:08:52.450 --> 00:08:56.560 
So let's take a look at these
guys here. Now these are all

140
00:08:56.730 --> 00:09:00.420 
bar the manual task in there these
all have some use. The manual

141
00:09:00.420 --> 00:09:04.840 
task is really not very useful.
It's kind of just used for

142
00:09:05.280 --> 00:09:09.660 
I don't know sort of indicating that something
happens outside the IT infrastructure.

143
00:09:09.970 --> 00:09:14.490 
Is that your favorite one?
Well not not so much

144
00:09:14.490 --> 00:09:18.670 
I know well. You prefer different
ones? Yeah well yeah ones that

145
00:09:18.670 --> 00:09:21.360 
have actual execution semantics? That
makes sense. I would prefer those too.

146
00:09:21.530 --> 00:09:23.870 
Now luckily we're going to talk
about each of those and find

147
00:09:23.870 --> 00:09:26.570 
out which ones are more interesting and
hopefully Nela will like one of them.

148
00:09:26.890 --> 00:09:30.250 
We will take the first one there
is a script task. Now very often

149
00:09:30.250 --> 00:09:33.810 
a script task can be can conflated
or confused with the service

150
00:09:33.810 --> 00:09:36.290 
task but there are some
clear differences.

151
00:09:36.710 --> 00:09:39.300 
If I select this the very first
thing is quite interesting as

152
00:09:39.300 --> 00:09:42.640 
there's no implementation type.
Instead it's asking you for

153
00:09:42.640 --> 00:09:47.170 
a script format. Now what this
means is that as opposed to a

154
00:09:47.170 --> 00:09:51.270 
service task which is calling a service
that is located somewhere else

155
00:09:51.530 --> 00:09:55.660 
a script task is usually calling
something very locally. In

156
00:09:55.660 --> 00:10:00.590 
this case for instance it's a
javascript bit of code which I

157
00:10:01.320 --> 00:10:04.430 
just typed in there into the
script section. Which means

158
00:10:04.430 --> 00:10:08.900 
it's embedded within the model.
Now this is quite commonly

159
00:10:08.900 --> 00:10:12.060 
used for very quick calculations
and things but it has some

160
00:10:12.060 --> 00:10:15.860 
pretty big drawbacks yes, Nela?
You can't maintain state here.

161
00:10:16.270 --> 00:10:19.310 
Yhat's a huge problem, yeah. You do not
have to maintain state between this

162
00:10:19.530 --> 00:10:22.620 
so it means that this will always
call itself and just run

163
00:10:22.620 --> 00:10:25.750 
that right through it.
And another big problem

164
00:10:25.750 --> 00:10:30.880 
is is very hard to maintain
because it's embedded in the xml

165
00:10:30.880 --> 00:10:34.480 
of your process which makes it incredibly
hard to test and maintain. So usually

166
00:10:34.600 --> 00:10:39.680 
it's not done to do things as looked
on at in order to um implement

167
00:10:39.680 --> 00:10:42.930 
things that are in anyway
complicated. Usually it's used just

168
00:10:42.930 --> 00:10:46.970 
for things that are quite
easy to to execute.

169
00:10:48.210 --> 00:10:51.920 
So next up we have our lovely
call activity. This is actually

170
00:10:51.920 --> 00:10:56.300 
an incredibly useful symbol and
is generally used in order to

171
00:10:56.410 --> 00:10:59.520 
call other processes, of course,
between processes specifically.

172
00:10:59.780 --> 00:11:02.680 
So if you selected a call activity
you would have this thing

173
00:11:02.680 --> 00:11:07.990 
here. Now what this means is it is going to
call another process you have somewhere

174
00:11:08.260 --> 00:11:11.140 
deployed on the engine and what
will happen is the engine will

175
00:11:11.140 --> 00:11:15.410 
wait on this symbol until the
process it calls has finished.

176
00:11:15.870 --> 00:11:18.500 
So that means that we call
process and we have

177
00:11:19.000 --> 00:11:22.110 
basically a parent child
relationship now where the parent

178
00:11:22.110 --> 00:11:24.830 
is called the child once the
child has finished the parent

179
00:11:24.830 --> 00:11:26.580 
continues on
the way . So

180
00:11:27.380 --> 00:11:31.880 
how do we know what child to call? Well we
have our called element section there

181
00:11:32.030 --> 00:11:37.380 
in which you could actually add
the ID or the key of of the

182
00:11:37.390 --> 00:11:40.870 
process that we're interested
in calling. And then of

183
00:11:40.870 --> 00:11:43.920 
course it would return and we
continue. There's a lot of reasons

184
00:11:43.930 --> 00:11:47.940 
for having call activities. Like
for instance reusable processes.

185
00:11:47.940 --> 00:11:52.240 
So if you have a let's say a part
of your process that you're

186
00:11:52.240 --> 00:11:56.740 
repeating across different processes it's
a very common pattern for instance.

187
00:11:56.870 --> 00:12:00.610 
Well then you would want to actually
abstract that into a call activity

188
00:12:00.690 --> 00:12:04.520 
to make sure that you could reuse
it and change it from one place.

189
00:12:04.800 --> 00:12:07.350 
Any other ideas on how we
might use a call activity?

190
00:12:08.280 --> 00:12:11.000 
Well if your process
is really big if you

191
00:12:11.000 --> 00:12:14.770 
have a huge process and you want
take out some complexity you

192
00:12:14.770 --> 00:12:18.990 
could use call activities to make
your parent process smaller.

193
00:12:19.090 --> 00:12:21.830 
Exactly that is a really good idea.
Because a very very big model

194
00:12:21.910 --> 00:12:24.820 
can be sometimes quite hard to
maintain and read so it can be

195
00:12:25.000 --> 00:12:28.400 
said be really good idea to take
parts of that process away

196
00:12:28.560 --> 00:12:31.130 
and actually maintain
it independently.

197
00:12:31.920 --> 00:12:36.120 
Finally we have these guys here
send and receive tasks. Now

198
00:12:36.640 --> 00:12:40.620 
receiving a task is really really
easy, you just need to wait for

199
00:12:40.680 --> 00:12:45.140 
add a name and then wait for that message
name. Very very straightforward

200
00:12:45.330 --> 00:12:48.730 
but sending a task is much
more complicated and

201
00:12:49.310 --> 00:12:53.220 
uh and that is because of course
we don't have the same context

202
00:12:53.230 --> 00:12:57.850 
of or the concept of them being
able to just put a simple little

203
00:12:57.850 --> 00:13:01.300 
sign, because in runtime we need
to find a specific instance.

204
00:13:01.590 --> 00:13:05.040 
Now I will explain why in more detail
later on but right now the way

205
00:13:05.040 --> 00:13:09.060 
you implement a send task is usually
by calling a java class that

206
00:13:09.060 --> 00:13:13.780 
then does the send itself. And
we can usually do that by in

207
00:13:13.780 --> 00:13:18.220 
exactly the same way as a service task
would do. And that send task needs to

208
00:13:18.650 --> 00:13:22.450 
tell the engine that at once to
send a message to that message

209
00:13:22.450 --> 00:13:25.690 
name and it often has a whole
bunch of other stuff in there.

210
00:13:25.860 --> 00:13:30.770 
Like business keys and of
course variables as well.

211
00:13:31.760 --> 00:13:36.020 
Now the quick recap here just
to remind you the technical

212
00:13:36.020 --> 00:13:40.830 
aspects of service tasks and send
tasks are often java classes.

213
00:13:41.130 --> 00:13:44.620 
You can also use external tasks
if you want to use other code,

214
00:13:45.100 --> 00:13:48.220 
other languages for instance.
Now technical attributes

215
00:13:48.220 --> 00:13:53.300 
of a user task tend to be pointing
to a specific user interface.

216
00:13:53.380 --> 00:13:56.610 
It doesn't really do any calculation
because it doesn't often need to.

217
00:13:56.780 --> 00:13:59.480 
Instead it is just trying
to show somebody some UI.

218
00:14:00.540 --> 00:14:02.810 
And these in our case are
created from foreign fields.

219
00:14:03.240 --> 00:14:06.380 
We also have technical attributes
for our business rules task

220
00:14:07.060 --> 00:14:09.500 
and when you implement the
DMN table the important

221
00:14:09.500 --> 00:14:12.600 
thing is to point to that DMN
table and then of course make

222
00:14:12.600 --> 00:14:16.540 
sure you are calling the right one and
then you need to put the result of

223
00:14:16.540 --> 00:14:18.070 
the table into
a variable.

224
00:14:18.810 --> 00:14:22.070 
Well we haven't answered the question
which is your favourite task then.

225
00:14:22.700 --> 00:14:25.870 
That's kind of hard I mean tasks
are not that interesting, I

226
00:14:25.870 --> 00:14:28.640 
would say my favorite is
probably going to be

227
00:14:29.840 --> 00:14:34.970 
call activity, I think. I want to
say the same. Right yeah ok.

228
00:14:35.090 --> 00:14:38.080 
I guess we can share the same.
It's a sharing concept

229
00:14:38.080 --> 00:14:43.940 
right and sharing is cool. Yeah
but I guess the favorite

230
00:14:43.940 --> 00:14:46.330 
symbol of course is going to get
more complicated now when we go

231
00:14:46.330 --> 00:14:48.770 
into gateways and events because
it's pretty cool stuff in there.

232
00:14:48.950 --> 00:14:52.130 
So and that's what we'll be talking
about next. Thank you very much.
