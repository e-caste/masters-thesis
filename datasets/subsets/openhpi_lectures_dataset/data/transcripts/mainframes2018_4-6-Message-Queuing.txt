WEBVTT

1
00:00:01.040 --> 00:00:02.070 
Hello it's me again, Wolfgang Greis from the European Mainframe Academy

2
00:00:05.530 --> 00:00:09.570 
and in the next video clip I want to talk about Message Queuing.

3
00:00:10.920 --> 00:00:14.430 
In the first video clip now in message queuing in general to

4
00:00:14.440 --> 00:00:18.120 
talk about the general concepts, and afterwards in the second

5
00:00:18.130 --> 00:00:22.430 
video clip concerning the IBM product IBMMQ.

6
00:00:23.340 --> 00:00:29.310 
I start now with message queuing and in the past we had monolithic applications

7
00:00:29.620 --> 00:00:33.170 
within a network interface between a so called

8
00:00:33.890 --> 00:00:39.900 
Thumb Terminal and a Mainframe. The network in the past normally was an SNA

9
00:00:40.270 --> 00:00:46.110 
network system, network architecture. It's a propriety network solution from

10
00:00:46.450 --> 00:00:50.240 
IBM and we have an interface between this thumb

11
00:00:50.680 --> 00:00:55.260 
terminal and the mainframe. And this is a so called thirty to seventy

12
00:00:55.970 --> 00:01:02.160 
interface. The application was the whole application was running on the mainframe

13
00:01:02.640 --> 00:01:09.270 
and if we accessed a database example and in many cases relational databases,

14
00:01:09.630 --> 00:01:14.660 
we had an interface between the application and the databases. And this is

15
00:01:14.770 --> 00:01:17.710 
the SQL interface, and

16
00:01:18.730 --> 00:01:25.300 
normally the application was designed with so called embedded SQL,

17
00:01:25.650 --> 00:01:30.380 
also called Static SQL because the SQL statements were

18
00:01:30.760 --> 00:01:35.730 
embedded in a static form in the application.

19
00:01:37.260 --> 00:01:40.850 
Things have changed in between of course, and today we have

20
00:01:41.840 --> 00:01:46.650 
client-server applications. I won't go into each and every detail

21
00:01:46.650 --> 00:01:52.450 
now concerning client server. I want just to emphasize on the

22
00:01:53.170 --> 00:01:59.030 
business logic, where it means that two applications running on different platforms

23
00:01:59.340 --> 00:02:04.900 
can have contact or contact with each other to transfer data between applications.

24
00:02:05.670 --> 00:02:10.360 
The applications can run on different platforms and if we think about the history,

25
00:02:11.210 --> 00:02:14.400 
it all started as example when we talk about

26
00:02:15.840 --> 00:02:23.490 
web interfaces and so on it started with http. Http as an interface for requesting

27
00:02:23.660 --> 00:02:25.540 
static documents from a server.

28
00:02:27.470 --> 00:02:35.790 
And the idea came up not just to access static information but also dynamic

29
00:02:36.870 --> 00:02:38.790 
information, means a programme.

30
00:02:39.640 --> 00:02:45.320 
We extract information from a server site and

31
00:02:46.110 --> 00:02:49.670 
deliver to the client whatever the client is requesting.

32
00:02:50.150 --> 00:02:56.470 
And I just want to talk about two interfaces that are important one is

33
00:02:56.640 --> 00:02:59.640 
RPC from the remote procedure call.

34
00:03:00.160 --> 00:03:05.900 
We had then afterwards also RM I, RM I remote method invocation

35
00:03:06.240 --> 00:03:10.320 
means it went into object orientation architectures.

36
00:03:11.580 --> 00:03:17.480 
And we had CORBA in the past and what is really an important

37
00:03:17.650 --> 00:03:19.440 
technique, it's a generic

38
00:03:20.440 --> 00:03:24.670 
term. Now I show here it's a MoM and MoM stands for

39
00:03:25.390 --> 00:03:29.730 
generic term for Message Oriented Middleware.

40
00:03:30.610 --> 00:03:38.080 
Let's start with RPC and why RPC is a so called synchronous interface,

41
00:03:38.600 --> 00:03:41.380 
and how RPC is working.

42
00:03:42.330 --> 00:03:44.040 
In the past we had program

43
00:03:45.710 --> 00:03:47.020 
on the one side program

44
00:03:51.060 --> 00:03:54.710 
sub-routine or function or whatever it is called on the other side.

45
00:03:55.190 --> 00:04:00.990 
And if we are in a heterogeneous environment on one platform it's very easy.

46
00:04:01.400 --> 00:04:05.250 
We have a program A. Program A makes a call on

47
00:04:06.490 --> 00:04:10.200 
program B or function B or support B whatever it is called.

48
00:04:10.830 --> 00:04:18.250 
And the call B now goes into program B or call B is executed some instructions.

49
00:04:18.530 --> 00:04:23.250 
And afterwards after these instructions, program B returns. Returns means

50
00:04:23.630 --> 00:04:30.130 
goes back into the program A and continues the execution where it stopped

51
00:04:31.580 --> 00:04:41.390 
call of Program B. Now think about the idea to have these program A and program B

52
00:04:41.600 --> 00:04:45.950 
not on the same platform but on different platforms. So we have

53
00:04:47.970 --> 00:04:53.460 
a network in between and let's assume we have a program A- it's

54
00:04:54.020 --> 00:05:00.470 
written on a unix system in C and we define as example some

55
00:05:00.990 --> 00:05:02.830 
arguments we want to

56
00:05:05.960 --> 00:05:12.760 
transfer to program B. This argument as example is an integer just called x.

57
00:05:13.220 --> 00:05:20.790 
On the other side, Program B is a program written on the mainframe written in cobol.

58
00:05:21.220 --> 00:05:27.920 
And we define also an integer to get the argument from program A.

59
00:05:28.480 --> 00:05:29.910 
Now the problem is,

60
00:05:30.940 --> 00:05:35.500 
a unix cell program written in C and a mainframe program written

61
00:05:35.500 --> 00:05:41.300 
in cobol even if we define an integer on both sides, this integer can be different.

62
00:05:41.810 --> 00:05:46.360 
And for the communication and that it works properly, we need to have

63
00:05:47.120 --> 00:05:52.170 
a kind of language to define these interfaces. This language

64
00:05:52.180 --> 00:05:54.340 
is called Interface Definition Language

65
00:05:54.740 --> 00:05:57.760 
to define what exactly is

66
00:05:58.490 --> 00:06:03.560 
delivered as an argument to program B and also normally from

67
00:06:03.560 --> 00:06:09.120 
a function or support, we expect to have some return information. And all the

68
00:06:09.390 --> 00:06:13.210 
return information must be defined. And in this case we need

69
00:06:13.260 --> 00:06:14.930 
an interface definition language.

70
00:06:15.560 --> 00:06:20.990 
Now this is a so called synchronous communications. Synchronous means we have

71
00:06:22.410 --> 00:06:27.790 
a system and application we are calling must be up and running.

72
00:06:27.920 --> 00:06:32.320 
Means the server where program B is running must be active and

73
00:06:32.470 --> 00:06:37.280 
program B must also ready to be started to

74
00:06:39.980 --> 00:06:45.790 
take the request from program A, execute program B and returns.

75
00:06:46.410 --> 00:06:50.510 
And another important thing is that the process A, the program A

76
00:06:51.760 --> 00:06:54.410 
is blocked as long as

77
00:06:55.070 --> 00:06:56.650 
the support B is running.

78
00:06:57.410 --> 00:07:03.850 
And these things are not so good in heterogeneous environments and

79
00:07:04.020 --> 00:07:06.610 
that's why we had some other

80
00:07:07.410 --> 00:07:11.730 
also synchronous activities in the past. I already mentioned

81
00:07:12.170 --> 00:07:17.120 
RMI remote method iinvocation for java environments.

82
00:07:17.410 --> 00:07:21.110 
For java environments we don't need the interface definition language

83
00:07:21.380 --> 00:07:24.930 
why because when we have on both sides

84
00:07:26.950 --> 00:07:31.530 
a java program, and another java object we

85
00:07:32.220 --> 00:07:36.890 
define an integer in both cases. The integer is defined via

86
00:07:37.150 --> 00:07:42.000 
java standards. So it's the same and we don't need an interface definition language

87
00:07:42.700 --> 00:07:45.350 
with RMI. The

88
00:07:46.670 --> 00:07:53.930 
other side is that we need to have must have on both sides a java program.

89
00:07:54.150 --> 00:07:59.210 
And in many heterogeneous environments, this is not the case that's why

90
00:07:59.330 --> 00:08:05.570 
corba came up. Corba came up to also object orient it. We can call different

91
00:08:06.490 --> 00:08:11.910 
objects on other platforms but again we have to define the interfaces

92
00:08:12.150 --> 00:08:16.800 
and also corba needs something like an interface definition language.

93
00:08:17.190 --> 00:08:22.520 
Same idea but different implementation of defining such interfaces.

94
00:08:24.440 --> 00:08:28.750 
Now the idea came up with message oriented middleware I mentioned

95
00:08:29.160 --> 00:08:33.180 
when I talked about client server environments. Again we have a program

96
00:08:33.280 --> 00:08:38.940 
A and a program B and now the communication with message oriented middleware

97
00:08:39.190 --> 00:08:45.000 
is not synchronous. It's asynchronous and the idea is a program A now

98
00:08:47.750 --> 00:08:52.240 
executes some instructions and then makes a PUT

99
00:08:52.820 --> 00:08:56.860 
to the other side, and PUT means it goes now into a queue.

100
00:08:57.030 --> 00:09:01.130 
That's why it's called messaging and quequing. A message goes into a queue,

101
00:09:01.460 --> 00:09:05.320 
is transferred to the other platform and on the other platform

102
00:09:05.320 --> 00:09:10.460 
we also have a queue, and this queue can now be read by program B.

103
00:09:11.020 --> 00:09:14.300 
Program B does whatever it is requested to do and

104
00:09:15.190 --> 00:09:19.830 
when the program B is finished it puts again a message back

105
00:09:19.940 --> 00:09:24.940 
to the program A. We are another queue. On the old platform it's

106
00:09:24.940 --> 00:09:30.660 
transferred to the other platform and the program A afterwards can get

107
00:09:31.420 --> 00:09:36.360 
the message from program B. This is asynchronous communication

108
00:09:36.620 --> 00:09:41.240 
and a really important aspect is that although the program A

109
00:09:41.430 --> 00:09:46.290 
is not blocked during the execution of program B, it can do other things.

110
00:09:46.940 --> 00:09:50.190 
In between that was the general

111
00:09:51.350 --> 00:09:58.110 
information about messaging and queuing. In the next video clip I will talk

112
00:09:58.360 --> 00:10:00.540 
about the IBM implementation, IBM

113
00:10:02.340 --> 00:10:07.240 
and queue for messaging and queuing. If you have any questions and remarks,

114
00:10:07.340 --> 00:10:10.330 
please use the discussion forum. See you again

115
00:10:10.740 --> 00:10:13.530 
in the next video clip. Thank you for attending.
