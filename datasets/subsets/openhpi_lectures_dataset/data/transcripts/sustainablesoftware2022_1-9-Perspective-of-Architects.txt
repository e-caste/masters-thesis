WEBVTT

1
00:00:01.130 --> 00:00:04.810 
In this video we're going to look at the perspective of architects

2
00:00:04.810 --> 00:00:07.850 
in a software team looking to establish sustainable software

3
00:00:07.850 --> 00:00:09.070 
engineering practices.

4
00:00:11.410 --> 00:00:15.100 
Architects are responsible for setting the guidelines how the

5
00:00:15.100 --> 00:00:18.670 
software is built, how its principal components look like, and

6
00:00:18.670 --> 00:00:23.500 
how they should interact together to perform the full functionality of the system.

7
00:00:24.340 --> 00:00:27.690 
To that extent, they work closely between the product owner

8
00:00:27.740 --> 00:00:31.090 
and the developers and operators of the system to translate

9
00:00:31.450 --> 00:00:35.270 
non technical requirements into technical requirements for

10
00:00:35.270 --> 00:00:36.220 
building the system.

11
00:00:39.440 --> 00:00:43.110 
Taking the Greensoft model as a reference architects have to

12
00:00:43.110 --> 00:00:46.950 
cover a lot of ground. They have to design the architecture

13
00:00:46.950 --> 00:00:51.960 
so that the software meets its requirements across all stages of the life-cycle.

14
00:00:52.570 --> 00:00:57.270 
Architects are involved of course in setting the guidelines for development

15
00:00:57.560 --> 00:01:02.450 
but how they do this also influences how the software can be used later,

16
00:01:02.780 --> 00:01:06.440 
and also has a huge impact on when the software will reach

17
00:01:06.440 --> 00:01:12.510 
its end of life. Architects have to define a lot of criteria for software.

18
00:01:13.190 --> 00:01:17.850 
This means that they have a very good position to also add additional criteria

19
00:01:18.100 --> 00:01:20.990 
for sustainability into the mix.

20
00:01:22.360 --> 00:01:27.500 
When it comes to the procedure models they have to also design

21
00:01:27.500 --> 00:01:31.190 
the system so that it's not just easy to develop and use later on,

22
00:01:31.320 --> 00:01:35.840 
but also how it will be administrated during its use.

23
00:01:36.870 --> 00:01:40.620 
And last but not least they are involved in tooling choices

24
00:01:40.710 --> 00:01:44.150 
for developers and also for the administration of the system.

25
00:01:46.070 --> 00:01:49.320 
What type of requirements to architects work with.

26
00:01:49.920 --> 00:01:54.640 
Let's use our update service example. For example functional

27
00:01:54.640 --> 00:01:58.090 
requirement for the update services that whenever client connects

28
00:01:58.090 --> 00:02:01.560 
to the update service to ask it about available updates, it

29
00:02:01.560 --> 00:02:06.150 
needs to run a correct computation and deliver a result whether

30
00:02:06.150 --> 00:02:07.690 
an update is available or not.

31
00:02:09.140 --> 00:02:11.910 
Non function requirements would be the availability of this

32
00:02:11.910 --> 00:02:15.470 
service, for example you might say ninety nine

33
00:02:15.470 --> 00:02:19.220 
percent of the time, the service should be available to serve requests.

34
00:02:19.590 --> 00:02:24.010 
This means that there is a zero point one opportunity for downtime

35
00:02:24.420 --> 00:02:28.090 
of the service. Scalability is important. The service should

36
00:02:28.090 --> 00:02:32.460 
be able to handle spikes in load but it should also be cost efficient in use.

37
00:02:33.280 --> 00:02:37.150 
And there might be performance targets for the whole system. So

38
00:02:37.280 --> 00:02:41.390 
what is the maximum time it takes a client to install an update

39
00:02:41.770 --> 00:02:43.900 
this includes the download time,

40
00:02:44.660 --> 00:02:48.310 
and the time it takes to make the service request. An architect

41
00:02:48.310 --> 00:02:51.690 
needs to be able to allocate the time between these portions

42
00:02:51.690 --> 00:02:54.790 
and direct the software engineering efforts in a way so that

43
00:02:54.790 --> 00:02:57.340 
the system meets its performance targets as a whole.

44
00:03:00.640 --> 00:03:05.940 
Architects can include sustainability in non functional requirements of the architecture

45
00:03:06.530 --> 00:03:09.110 
for example when it comes to scalability

46
00:03:10.150 --> 00:03:15.410 
scaling a service up is easy, but scaling it down in line with demand

47
00:03:15.590 --> 00:03:19.510 
might be an additional requirement that helps sustainability greatly,

48
00:03:19.790 --> 00:03:23.230 
but it does not only help sustainability most likely, it will

49
00:03:23.230 --> 00:03:24.750 
also help saving costs.

50
00:03:25.860 --> 00:03:30.010 
Performance is also very critical. When negotiating a service

51
00:03:30.010 --> 00:03:35.250 
level agreement or SLA with the consumers of the system, response times

52
00:03:35.440 --> 00:03:40.430 
can have or can afford an architect more options to implement the architecture,

53
00:03:40.820 --> 00:03:46.020 
and they can set also a high bar for implementing services very efficiently.

54
00:03:47.310 --> 00:03:51.880 
What techniques can architects use to design sustainable architectures.

55
00:03:52.530 --> 00:03:55.730 
In this video we're going to look at two particular techniques.

56
00:03:56.060 --> 00:03:59.460 
The first is breaking up services by scaling factors and the

57
00:03:59.460 --> 00:04:03.770 
second is designing systems in a way that they allow very good bin-packing.

58
00:04:06.210 --> 00:04:08.140 
Let's start with scaling factors.

59
00:04:09.110 --> 00:04:12.590 
When we talk about the resources that a service needs at runtime,

60
00:04:12.700 --> 00:04:15.180 
we can put them into three buckets-

61
00:04:15.740 --> 00:04:21.980 
compute means that the service has CPUs or GPUs available for running computations,

62
00:04:22.320 --> 00:04:25.530 
and it also has volatile memory to store the results.

63
00:04:26.650 --> 00:04:30.890 
Persistent storage is a different bucket. This means that we have storage

64
00:04:31.080 --> 00:04:34.810 
that allows us to persist data over a long time, and holds all

65
00:04:34.810 --> 00:04:36.420 
the data that the system works with.

66
00:04:37.930 --> 00:04:41.600 
Networking is the third type of resource. You might need to

67
00:04:41.600 --> 00:04:45.030 
transmit data to clients of the system or you might need to

68
00:04:45.030 --> 00:04:48.290 
transfer large amounts of data between different services that

69
00:04:48.290 --> 00:04:49.570 
make up the whole system.

70
00:04:51.580 --> 00:04:55.390 
Breaking down services to have a clear scaling factor which

71
00:04:55.390 --> 00:05:00.270 
means only one of these factors is the dominant factor in scaling the service

72
00:05:00.760 --> 00:05:04.620 
allows an architect to build the system in a way that achieves

73
00:05:04.620 --> 00:05:08.010 
better utilization of physical resources.

74
00:05:08.620 --> 00:05:13.370 
For example, if you design a service where all the compute intense

75
00:05:13.790 --> 00:05:20.500 
pods are going to dedicate a hardware that's optimized for compute intense applications

76
00:05:20.760 --> 00:05:25.010 
you can save a lot of wasted resources, because these instances

77
00:05:25.010 --> 00:05:29.230 
don't need a lot of networking capacity and a lot of storage capacity.

78
00:05:31.810 --> 00:05:34.900 
Let's look at how breaking up the service by resource scaling

79
00:05:34.900 --> 00:05:38.750 
factors looks like in our software update service example.

80
00:05:40.140 --> 00:05:43.580 
The functionality of the service clients on the left hand side

81
00:05:43.590 --> 00:05:48.690 
requesting updates from an update signed downloading it and installing them.

82
00:05:49.720 --> 00:05:52.170 
How would breaking up the service look like?

83
00:05:53.230 --> 00:05:56.280 
There's three functions in the service which gives us a very good

84
00:05:56.280 --> 00:05:57.910 
idea of how we can break it up.

85
00:05:58.690 --> 00:06:04.390 
The first is the update API- this is where clients ask for available updates.

86
00:06:05.030 --> 00:06:09.650 
Most likely this service is going to be mildly compute intense, which means

87
00:06:09.980 --> 00:06:13.410 
that this service needs to run a computation whether the client

88
00:06:13.410 --> 00:06:16.170 
is eligible and what the upgrade path for its

89
00:06:16.790 --> 00:06:21.670 
software is. A data store which is storage intense

90
00:06:22.080 --> 00:06:25.570 
is responsible for holding all the updates. So this is where

91
00:06:25.570 --> 00:06:29.950 
all the application binaries are to be delivered by the software team.

92
00:06:30.810 --> 00:06:35.360 
And the CDN which we are going to introduce in the next slides is

93
00:06:35.890 --> 00:06:40.900 
responsible for delivering it. So this is where clients download the data from

94
00:06:41.150 --> 00:06:46.210 
and as you can see this is of course a network intense service.

95
00:06:48.280 --> 00:06:51.610 
Let's look at how a content delivery network solves this.

96
00:06:52.410 --> 00:06:56.990 
A content delivery network is built on the idea of having points of presence

97
00:06:57.190 --> 00:07:01.370 
on everywhere in the world. In this example pretty much on every continent.

98
00:07:02.020 --> 00:07:05.550 
Whenever user requests a particular piece of content, the content

99
00:07:05.550 --> 00:07:08.690 
delivery network will try to serve that request out of the

100
00:07:08.690 --> 00:07:10.300 
closest point of present.

101
00:07:11.340 --> 00:07:14.910 
The point of present might have the file it was requested already

102
00:07:14.910 --> 00:07:18.340 
present and if it doesn't it will cache it by retrieving it

103
00:07:18.340 --> 00:07:20.590 
from the original server and caching it

104
00:07:21.260 --> 00:07:22.570 
in the edge location.

105
00:07:24.710 --> 00:07:29.360 
What does that mean for sustainability or why is using a CDN

106
00:07:29.540 --> 00:07:32.370 
a sustainable software engineering practice.

107
00:07:33.070 --> 00:07:37.430 
First the packets travel a shorter distance which means that

108
00:07:37.430 --> 00:07:42.130 
there's less network transfers overall needed which means that there's less energy

109
00:07:42.370 --> 00:07:44.440 
needed to transfer all the data.

110
00:07:45.500 --> 00:07:51.100 
Also the network requires a lot less total bandwidth to serve the customers.

111
00:07:52.530 --> 00:07:57.270 
This is because the customers are being served out of the closest connection

112
00:07:57.600 --> 00:08:03.860 
and the length of connections that are being required to serve all this data

113
00:08:04.010 --> 00:08:05.570 
are typically much shorter

114
00:08:06.680 --> 00:08:12.130 
and the third is that the CDN provider shares its point of presence

115
00:08:12.380 --> 00:08:15.750 
with other customers which means that they are running always

116
00:08:15.750 --> 00:08:19.500 
at a very high utilisation and they leverage algorithms to

117
00:08:19.500 --> 00:08:21.710 
cache the most popular content.

118
00:08:22.470 --> 00:08:26.220 
A single organization might not have enough bandwidth or enough

119
00:08:26.220 --> 00:08:30.690 
customers to build all these points of presence, however a dedicated

120
00:08:30.690 --> 00:08:33.920 
content delivery network has and therefore provides a much

121
00:08:33.920 --> 00:08:37.690 
better and more efficient infrastructure that's not just more efficient

122
00:08:37.830 --> 00:08:41.520 
but also results in faster download time for its customers.

123
00:08:44.900 --> 00:08:47.370 
Let's look at the second aspect- the bin-packing.

124
00:08:49.490 --> 00:08:55.100 
Bin-packing is the process of packing items of different sizes

125
00:08:55.170 --> 00:08:58.540 
into infinite number of bins that have a fixed capacity.

126
00:08:59.090 --> 00:09:06.630 
So if we imagine virtual machines, we can say that we can model virtual machines

127
00:09:06.810 --> 00:09:10.640 
as our items and the bins would be bare metal hosts where we

128
00:09:10.640 --> 00:09:12.730 
want to put the virtual machines onto.

129
00:09:14.190 --> 00:09:16.890 
The problem that comes with it is that virtual machines can

130
00:09:16.890 --> 00:09:21.580 
be of different sizes. Here in this figure on the slide we have

131
00:09:21.590 --> 00:09:24.710 
them in blue which is big virtual machines and we have small

132
00:09:24.710 --> 00:09:26.290 
virtual machines in orange.

133
00:09:27.010 --> 00:09:32.560 
Now we try to find the optimum placement of these virtual machines onto the hosts

134
00:09:32.730 --> 00:09:35.930 
so that we minimize the number of hosts that we need.

135
00:09:36.840 --> 00:09:40.640 
And using a naive solution like first distributing the blue

136
00:09:40.640 --> 00:09:43.220 
ones and then distributing the orange ones,

137
00:09:43.790 --> 00:09:48.430 
as you can see does not deliver an optimum result. You can see

138
00:09:48.500 --> 00:09:51.900 
in the not optimal result that the fourth

139
00:09:52.420 --> 00:09:56.900 
virtual machine host is not fully used. It has a lot of idle

140
00:09:56.900 --> 00:09:59.420 
capacity which is white in this diagram.

141
00:10:00.290 --> 00:10:04.810 
In an optimal solution, on the other hand we have two hosts that

142
00:10:04.810 --> 00:10:08.100 
are fully loaded to one hundred percent and we have a third

143
00:10:08.100 --> 00:10:10.480 
host that has very little spare capacity.

144
00:10:11.810 --> 00:10:16.440 
Actually computing a good solution to the bin packing problem is very difficult.

145
00:10:16.860 --> 00:10:20.120 
Nonetheless there are very good approximations and heuristics

146
00:10:20.120 --> 00:10:21.980 
that deliver good results in practice.

147
00:10:25.120 --> 00:10:26.680 
Why does bin packing matter?

148
00:10:27.370 --> 00:10:32.590 
At the end of the day most teams nowadays use virtualized infrastructure,

149
00:10:32.680 --> 00:10:37.190 
which means that they're one level above hardware, physical hardware.

150
00:10:37.490 --> 00:10:42.560 
Nonetheless at some point the application needs to run on physical hardware

151
00:10:43.270 --> 00:10:46.450 
and the closer we move the decisions on how

152
00:10:47.180 --> 00:10:51.440 
applications are placed onto physical hardware, the closer we

153
00:10:51.440 --> 00:10:56.860 
move those decisions to the hardware, the better solutions we can find.

154
00:10:58.120 --> 00:11:03.690 
For example, we might build our services to be smaller and more fine granular

155
00:11:03.910 --> 00:11:08.060 
which leads to less fragmentation and can enable the service

156
00:11:08.060 --> 00:11:11.480 
provider to shuffle resources around more efficiently.

157
00:11:12.010 --> 00:11:16.270 
An easy analogy for this is trying to fill a jar with stones.

158
00:11:16.470 --> 00:11:20.070 
If all you have is very big stones, when you fill the jar there's

159
00:11:20.070 --> 00:11:24.560 
going to be a lot more air gaps left in the jar, whereas if

160
00:11:24.560 --> 00:11:28.050 
you take sand which is very fine granular and put it into the jar

161
00:11:28.270 --> 00:11:31.430 
it's going to be filled one hundred percent all of the time.

162
00:11:33.640 --> 00:11:38.050 
Finding optimum solutions to bin packing and requires collaboration

163
00:11:38.050 --> 00:11:42.040 
between all the different roles. A service architect might have

164
00:11:42.040 --> 00:11:46.500 
to make decisions about monoliths versus micro services, how to split up

165
00:11:46.760 --> 00:11:51.850 
the application into its principal components, developers choose text x

166
00:11:52.080 --> 00:11:56.560 
operators choose how to package the applications and then infrastructure

167
00:11:57.580 --> 00:12:01.580 
providers make the actual bin packing decision on how to place it.

168
00:12:02.030 --> 00:12:05.230 
But of course for that they need to have information about

169
00:12:05.230 --> 00:12:07.040 
what they're actually trying to package.

170
00:12:09.240 --> 00:12:13.290 
So what are some recommendations for architects to establish

171
00:12:13.290 --> 00:12:15.350 
sustainable software engineering practices.

172
00:12:16.050 --> 00:12:19.960 
The first is that non function requirements offer a great opportunity

173
00:12:19.960 --> 00:12:24.610 
for modeling, sustainability requirements in existing goal dimensions

174
00:12:24.610 --> 00:12:29.710 
and in establish procedures. To that effect this has also been studied in literature.

175
00:12:30.590 --> 00:12:34.570 
Designing an energy efficient architecture means breaking up

176
00:12:34.570 --> 00:12:39.050 
services by resource scaling factors ensuring services can scale up

177
00:12:39.210 --> 00:12:43.170 
and down again and collaborating with other roles to enable

178
00:12:43.180 --> 00:12:44.250 
efficient bin packing.
