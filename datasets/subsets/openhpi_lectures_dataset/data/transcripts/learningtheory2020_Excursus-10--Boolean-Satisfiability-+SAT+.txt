WEBVTT

1
00:00:00.370 --> 00:00:03.870 
Hello everyone. My name is
Ralf Rothenberger and today

2
00:00:03.870 --> 00:00:07.200 
I'm going to present you the
boolean satisfiability problem

3
00:00:07.390 --> 00:00:10.750 
and why this problem is so
important to computer science.

4
00:00:11.870 --> 00:00:16.490 
But first of all to show you how
this topic fits into our MOOC.

5
00:00:16.940 --> 00:00:19.360 
This was the title
slide you might know

6
00:00:20.240 --> 00:00:23.130 
and I'm part of this
excursion window here

7
00:00:23.610 --> 00:00:25.780 
more precisely, I'm going
to show your what

8
00:00:26.300 --> 00:00:30.400 
these formulas mean or how they are
important to computer science

9
00:00:32.210 --> 00:00:36.990 
because these formulas are boolean
satisfiability formulas.

10
00:00:37.620 --> 00:00:43.310 
And the problem consists of having
n variables that can take

11
00:00:43.310 --> 00:00:49.180 
values zero or one and a formula but it
is not really important what it does.

12
00:00:49.420 --> 00:00:54.700 
It contains these variables and
for each set of values that

13
00:00:54.700 --> 00:00:58.680 
you can set its variables to
you get an answer from this

14
00:00:58.680 --> 00:01:01.330 
formula that is
either zero or one.

15
00:01:04.160 --> 00:01:07.990 
And you want to ask the question is
there a satisfying assignment?

16
00:01:08.170 --> 00:01:12.190 
Can you set the variables to zero
and one such that the formula

17
00:01:12.190 --> 00:01:13.510 
gives you the
answer one?

18
00:01:14.440 --> 00:01:16.470 
In this example
you can do that

19
00:01:17.100 --> 00:01:22.530 
and if you said x2
to 1 and x1 to 0,

20
00:01:23.350 --> 00:01:26.820 
it gives you one. I don't want to
go into too much detail here.

21
00:01:27.500 --> 00:01:31.090 
The question is why is
this problem important?

22
00:01:31.550 --> 00:01:34.990 
Well it stands at the core
of computational theory.

23
00:01:35.570 --> 00:01:40.980 
So at the question how
difficult is it in general to

24
00:01:40.980 --> 00:01:43.100 
find a solution to
some problem?

25
00:01:43.750 --> 00:01:48.320 
And there are two people that did
important work showing that SAT is

26
00:01:48.700 --> 00:01:52.180 
an interesting problem and
those two people were

27
00:01:52.840 --> 00:01:55.020 
Stephan A Cook and
Leonid Levin.

28
00:01:56.250 --> 00:02:00.440 
In nineteen seventy one and nineteen
seventy three independently

29
00:02:00.750 --> 00:02:05.320 
they showed that satisfiability
is NP-complete and it was the

30
00:02:05.320 --> 00:02:07.530 
first problem shown
to be NP-complete.

31
00:02:08.210 --> 00:02:10.150 
So what does it mean
to be NP-complete?

32
00:02:11.850 --> 00:02:17.340 
First of all NP is a class of problems
that have two important properties.

33
00:02:18.100 --> 00:02:22.560 
One property is that you can
easily guess a solution and you

34
00:02:22.560 --> 00:02:26.430 
can easily check if the solution
actually is the solution you want.

35
00:02:27.330 --> 00:02:31.820 
So for satisfiability you can
just guess values zero and

36
00:02:31.820 --> 00:02:35.530 
one for your variables. You can
put them into formula and then

37
00:02:35.530 --> 00:02:39.480 
the formula tells you if this is
a satisfying assignment, if

38
00:02:39.480 --> 00:02:40.270 
it gives you one.

39
00:02:41.530 --> 00:02:46.000 
But there are other examples of
NP problems that you might

40
00:02:46.000 --> 00:02:50.220 
know from your everyday life, for
example, packing a backpack.

41
00:02:50.700 --> 00:02:55.260 
So imagine you have a backpack
that can hold a certain volume

42
00:02:55.640 --> 00:03:00.040 
and you have some items that you
want to pack. Each item has a

43
00:03:00.280 --> 00:03:04.250 
certain volume and a certain value
to you and you want to know

44
00:03:04.250 --> 00:03:07.820 
if you can pack items with
a certain total value.

45
00:03:08.790 --> 00:03:12.140 
Again you can see that this
problem is an NP. You can easily

46
00:03:12.140 --> 00:03:16.350 
guess a solution by just randomly
packing some items into your backpack

47
00:03:16.720 --> 00:03:21.440 
and then checking first of all do these
items actually fit into the backpack?

48
00:03:21.580 --> 00:03:25.490 
And second of all is the total
value of the items what you want?

49
00:03:26.380 --> 00:03:29.550 
But there are other
examples like

50
00:03:30.250 --> 00:03:33.990 
finding a shortest route from
some point a to some point b,

51
00:03:35.020 --> 00:03:39.510 
like solving certain puzzles or
riddles like pi cross puzzles

52
00:03:40.880 --> 00:03:45.630 
and also a very important and famous
problem- the travelling salesman.

53
00:03:46.200 --> 00:03:51.930 
So the traveling salesman tries to travel
around Germany visiting all cities

54
00:03:52.200 --> 00:03:55.930 
with a cost that is at
most the budget he has.

55
00:03:56.790 --> 00:04:00.720 
And the cost might depend from
city to city depending on how

56
00:04:00.720 --> 00:04:04.860 
he travels, for example by car,
by bus, by plane and he wants

57
00:04:04.860 --> 00:04:06.060 
to know if this
is possible.

58
00:04:06.930 --> 00:04:10.880 
So there are a lot of problems
in NP that are very important

59
00:04:10.890 --> 00:04:12.000 
to your everyday life.

60
00:04:13.060 --> 00:04:20.180 
And NP-complete now means that
any problem in NP can be

61
00:04:20.190 --> 00:04:22.490 
transformed to an
NP-complete problem.

62
00:04:23.140 --> 00:04:25.820 
For example to a
satisfiability formula.

63
00:04:27.100 --> 00:04:32.320 
In a sense this means that NP-complete
problems are the hardest problems

64
00:04:32.470 --> 00:04:35.910 
of the class NP because
if we knew a way

65
00:04:36.420 --> 00:04:41.230 
to solve an NP-complete problem
very fast we can solve all

66
00:04:41.230 --> 00:04:44.770 
problems in the class NP very
fast by just transforming

67
00:04:44.770 --> 00:04:46.630 
it to the problem and
then solving it.

68
00:04:48.180 --> 00:04:53.320 
So how hard is it to solve an NP-complete
problem, for example, satisfiability?

69
00:04:54.570 --> 00:04:55.680 
Surprisingly

70
00:04:57.170 --> 00:05:03.020 
we still don't know. Despite decades
of research and many famous

71
00:05:03.020 --> 00:05:05.910 
ingenious people who tried
to answer this question

72
00:05:06.440 --> 00:05:07.760 
there's still no
answer yet.

73
00:05:08.750 --> 00:05:12.770 
So since we didn't find an efficient
way of solving these problems

74
00:05:12.980 --> 00:05:16.680 
it is widely assumed that they
cannot be solved efficiently.

75
00:05:17.970 --> 00:05:21.880 
So the theory for satisfiability
looks something like this.

76
00:05:22.430 --> 00:05:26.460 
Well you cannot hope to find an
efficient algorithm because

77
00:05:26.520 --> 00:05:30.250 
a lot of famous and very smart
people couldn't find it either.

78
00:05:31.170 --> 00:05:38.230 
In practice however, many formulas
in the satisfiability problem

79
00:05:38.830 --> 00:05:40.750 
can be solved quite
efficiently.

80
00:05:42.270 --> 00:05:47.490 
In fact the problem is considered
so easy for some cases that

81
00:05:47.490 --> 00:05:51.390 
you can use satisfiability
as kind of an oracle

82
00:05:51.850 --> 00:05:57.860 
because as I said many practical problems
in NP can be transformed to SAT

83
00:05:58.110 --> 00:06:00.510 
and if you have an efficient
way of solving SAT

84
00:06:00.970 --> 00:06:02.520 
well you can solve
these problems.

85
00:06:03.180 --> 00:06:07.100 
So if you use SAT as an oracle you can
imagine having the following situation.

86
00:06:08.020 --> 00:06:11.500 
You have a very hard problem or part
of your problem is very hard.

87
00:06:12.180 --> 00:06:14.170 
So you want to
have an answer

88
00:06:14.830 --> 00:06:16.110 
and you ask an oracle.

89
00:06:16.820 --> 00:06:20.510 
And the oracle just gives you the
answer, so you can solve your problem.

90
00:06:21.420 --> 00:06:25.030 
If you use satisfiability it
works something like this.

91
00:06:25.420 --> 00:06:31.360 
You transform your problem, for example your
problem in NP, to a satisfiability formula,

92
00:06:31.850 --> 00:06:35.110 
you solve it with some state of the
art solver and you hope that it is

93
00:06:35.330 --> 00:06:39.060 
that this works out and the
solver it gives you the answer

94
00:06:39.060 --> 00:06:42.650 
and then you can use this answer
to solve your original problem.

95
00:06:44.910 --> 00:06:50.170 
However this does not work
every time. So there are only

96
00:06:50.170 --> 00:06:52.660 
some instances that
can be solved easily

97
00:06:53.640 --> 00:06:57.420 
because otherwise we would already
have an answer to how hard it is

98
00:06:57.610 --> 00:06:59.380 
to solve NP-complete
problems.

99
00:07:00.360 --> 00:07:02.430 
So which instances can
be solved easily?

100
00:07:02.950 --> 00:07:07.110 
For example instances that
come from circuit design

101
00:07:07.790 --> 00:07:12.670 
or automated planning and scheduling
or hard and software model checking.

102
00:07:13.300 --> 00:07:19.080 
since these instances usually stem from
industrial problems, they are also called

103
00:07:20.410 --> 00:07:21.610 
industrial instances.

104
00:07:22.790 --> 00:07:29.020 
So why is it that SAT servers
are so fast on these instances

105
00:07:29.720 --> 00:07:31.570 
despite the fact
that well

106
00:07:32.490 --> 00:07:37.430 
in theory they should not be. So we
don't know if we can solve SAT

107
00:07:37.550 --> 00:07:42.860 
fast at all. Again we still don't
know the answer to that question

108
00:07:43.430 --> 00:07:47.960 
but there are three major directions of
research to try to find the answer.

109
00:07:48.580 --> 00:07:51.320 
The first direction is trying
to build better solvers,

110
00:07:52.100 --> 00:07:54.450 
second direction is
trying to understand

111
00:07:55.150 --> 00:07:58.040 
why these industrial
instances are easy to solve

112
00:07:58.750 --> 00:08:02.260 
and the last direction is to try
and draw connections to logic.

113
00:08:03.520 --> 00:08:08.030 
So the first direction has already
been very fruitful because

114
00:08:08.030 --> 00:08:12.150 
we have very fast solvers of us and
one driving force behind that

115
00:08:12.450 --> 00:08:16.420 
is the so called SAT competition.
This is a competition that

116
00:08:16.420 --> 00:08:21.630 
takes place every year and it is
as you might imagine it, people

117
00:08:21.630 --> 00:08:24.400 
send in the implementations
of a SAT solver

118
00:08:24.860 --> 00:08:28.570 
and they try to build the best
solver. So the one that

119
00:08:29.160 --> 00:08:33.260 
solves most instances in
the least amount of time.

120
00:08:34.060 --> 00:08:38.430 
And this has has been a driving
force in building better solvers

121
00:08:38.720 --> 00:08:42.430 
in trying to understand which techniques
for solving this work very well

122
00:08:42.950 --> 00:08:45.230 
and which instances
are hard.

123
00:08:45.860 --> 00:08:50.950 
So we can also send in your
satisfiability formulas that have

124
00:08:50.960 --> 00:08:54.150 
a certain property that are
interesting or may be hard to solve

125
00:08:54.370 --> 00:08:57.200 
to see how solvers fare
on that instance.

126
00:08:59.190 --> 00:09:02.780 
The second direction in trying
to understand why such solvers

127
00:09:02.780 --> 00:09:06.480 
are fast is trying to understand
what the instances that can

128
00:09:06.480 --> 00:09:08.890 
be solved efficiently
actually look like.

129
00:09:09.640 --> 00:09:16.480 
So if you visualize the connections
between variables in your SAT instance

130
00:09:16.900 --> 00:09:18.260 
it might look
something like this.

131
00:09:18.960 --> 00:09:23.570 
Well if you generated the
instance at random at least.

132
00:09:24.460 --> 00:09:28.150 
If you have an industrial instance
that looks something like this.

133
00:09:28.850 --> 00:09:31.850 
So you can see that there is a lot
of structure in these instances

134
00:09:32.010 --> 00:09:34.990 
that solvers can take

135
00:09:35.930 --> 00:09:40.700 
that solvers can take advantage
of. So trying to understand

136
00:09:40.710 --> 00:09:44.110 
which structures these are,
which properties solvers use

137
00:09:44.580 --> 00:09:48.980 
can help us in understanding why these
instances can be solved efficiently.

138
00:09:50.630 --> 00:09:55.010 
And the last direction of research is
trying to draw connections to logic.

139
00:09:55.250 --> 00:10:00.290 
So not trying to solve instances
with state of the art SAT solvers

140
00:10:00.500 --> 00:10:02.880 
but with some
logical calculus.

141
00:10:03.560 --> 00:10:09.030 
And it might surprise you but it has been
found that many successful SAT solvers

142
00:10:09.340 --> 00:10:13.480 
essentially do just that. So
they also use logical calculus

143
00:10:13.880 --> 00:10:17.340 
and in trying to understand what
you can solve or not solve

144
00:10:17.340 --> 00:10:20.980 
with this logical calculus you
can also try to understand what

145
00:10:20.980 --> 00:10:24.440 
the successful solvers actually
can or cannot solve.

146
00:10:27.210 --> 00:10:31.600 
So as I showed you boolean satisfiability
is a very important problem

147
00:10:31.830 --> 00:10:37.680 
in computer science. Assumably it is
very hard to solve because we have no

148
00:10:37.980 --> 00:10:40.430 
efficient algorithm that
can solve any instance

149
00:10:40.960 --> 00:10:45.230 
but many instances can be solved
very easily in practice.

150
00:10:46.490 --> 00:10:52.120 
And actually those instants can be
solved so fast that satisfiability

151
00:10:52.120 --> 00:10:56.320 
is also seen as some kind of
multi tool to solve other

152
00:10:56.320 --> 00:11:00.240 
problems, for example problems
in NP that you can and can't

153
00:11:00.240 --> 00:11:01.290 
in your everyday life.

154
00:11:03.420 --> 00:11:07.500 
However there are still many open
questions like how hard is

155
00:11:07.500 --> 00:11:13.690 
it to solve SAT in general and why do SAT
solvers work so well on industrial instances.

156
00:11:14.800 --> 00:11:19.130 
So as you can see satisfiability is a very
important and very interesting problem.

157
00:11:20.430 --> 00:11:21.850 
So thank you very much.
