WEBVTT

1
00:00:00.930 --> 00:00:05.340 
This is knowledge graphs lecture number
five knowledge graph applications.

2
00:00:05.820 --> 00:00:10.820 
In this part of the lecture we are going
to show you how to use knowledge graphs

3
00:00:10.990 --> 00:00:14.530 
in programming. So we do
knowledge graph programming.

4
00:00:16.310 --> 00:00:21.850 
If you are intending to implement
knowledge graph driven web applications

5
00:00:22.200 --> 00:00:25.510 
you are usually following an
architecture that is quite similar

6
00:00:25.520 --> 00:00:29.960 
like the one that you see here and you
require a few components for that.

7
00:00:30.650 --> 00:00:35.180 
The main difference to arbitrary
applications is that of course

8
00:00:35.600 --> 00:00:39.190 
you have to take special care
of your RDF data which means

9
00:00:39.190 --> 00:00:43.390 
you need a local RDF store and
you need this of course for

10
00:00:43.480 --> 00:00:47.010 
caching of your results or of
course for the permanent storage

11
00:00:47.140 --> 00:00:52.320 
of your results that you are of
course encoding a encoding

12
00:00:52.330 --> 00:00:56.300 
in RDF and of course then
storing in an RDF store.

13
00:00:58.710 --> 00:01:02.490 
The rest of the component is you
know quite similar like to

14
00:01:02.500 --> 00:01:07.190 
any other kind of lets say application
or web application. Of course you need

15
00:01:07.480 --> 00:01:11.290 
a logic which is the controller
or implements the controller

16
00:01:11.290 --> 00:01:14.430 
and you need a user interface.
This is your business logic and

17
00:01:14.430 --> 00:01:18.060 
this is not necessarily knowledge
graph specific. So this is

18
00:01:18.200 --> 00:01:23.730 
of course basic and should be of course
a part of every kind of application.

19
00:01:25.110 --> 00:01:29.750 
What is on the other hand again specific for
knowledge graph driven web applications?

20
00:01:30.150 --> 00:01:33.390 
You need something like a
data integration component.

21
00:01:33.850 --> 00:01:37.530 
So either you get your data
directly from a knowledge graph,

22
00:01:37.530 --> 00:01:41.320 
here for example from the linked
data cloud or you get your

23
00:01:41.320 --> 00:01:45.290 
data from some kind of semantic
indexing services so that you

24
00:01:45.290 --> 00:01:50.430 
get your data via google or via another
lets say information system. However

25
00:01:50.910 --> 00:01:56.120 
if it comes let's say encoded
within RDF of course it has to

26
00:01:56.120 --> 00:02:00.130 
be somehow combined with your
local data and potentially also

27
00:02:00.130 --> 00:02:04.590 
different sources from outside
have to be combined. So for this

28
00:02:04.930 --> 00:02:08.890 
you need the integration component that
integrates your data and enables you

29
00:02:09.150 --> 00:02:13.550 
to federate to aggregate to feel
and to combine all the stuff.

30
00:02:15.260 --> 00:02:18.820 
And then in the end of course when
your application has computed

31
00:02:18.820 --> 00:02:22.210 
something so we have results that
we want somehow to publish,

32
00:02:23.000 --> 00:02:25.370 
you need a data re
publishing component

33
00:02:25.810 --> 00:02:30.680 
and this one writes back application
dependent data into the web of data.

34
00:02:31.620 --> 00:02:36.050 
So you need somehow the possibility
either to send this to

35
00:02:36.050 --> 00:02:40.670 
an external web server where
somewhere this data will be stored

36
00:02:40.670 --> 00:02:45.510 
and made accessible again
over the web of data. So

37
00:02:46.850 --> 00:02:50.600 
summing all this up you see here
the components that are used

38
00:02:50.600 --> 00:02:54.930 
for knowledge graph driven web applications
starting from a local RDF store

39
00:02:55.180 --> 00:02:59.770 
over the usual logic and user interface
you need a data integration

40
00:02:59.770 --> 00:03:05.110 
component and a data re publishing or
publishing component. So these are

41
00:03:05.340 --> 00:03:06.960 
the main ingredients.

42
00:03:08.710 --> 00:03:11.380 
But this of course is only the
architecture of your application.

43
00:03:11.910 --> 00:03:16.120 
What about the application itself?
How do I get access on RDF data?

44
00:03:16.260 --> 00:03:19.340 
Of course we know already RDF and
we know SPARQL but of course

45
00:03:19.340 --> 00:03:24.130 
we want to use RDF and SPARQL
within our programming languages

46
00:03:24.620 --> 00:03:26.960 
and the easiest way
to make use of that

47
00:03:27.400 --> 00:03:32.380 
use a suitable library. So here you
see as a short list of existing

48
00:03:32.380 --> 00:03:36.590 
libraries there is a SPARQL javascript
library, there is libraries

49
00:03:36.590 --> 00:03:41.190 
for PHP, for C# for java and
of course for python and

50
00:03:41.190 --> 00:03:44.960 
for sake of simplicity we will
use for this lecture and for

51
00:03:44.960 --> 00:03:48.720 
the example that we show
you here RDFlib and from

52
00:03:48.720 --> 00:03:52.800 
that of course the SPARQL wrapper
which is part of RDFlib and they

53
00:03:52.940 --> 00:03:56.210 
of course belong to the
programming language Python. You

54
00:03:56.210 --> 00:03:59.590 
have you also the links so you
can download the stuff and play

55
00:03:59.590 --> 00:04:04.010 
around with it. So we make use here
of the SPARQL wrapper from python

56
00:04:04.620 --> 00:04:08.700 
and we will of course also
make use of a public SPARQL

57
00:04:08.700 --> 00:04:12.540 
endpoint that we query in our
application and also for sake

58
00:04:12.540 --> 00:04:17.100 
of simplicity we have chosen to use
DBpedia because there the names

59
00:04:17.100 --> 00:04:20.640 
immediately speak for themselves and
you can easily see what we are doing.

60
00:04:20.830 --> 00:04:24.740 
Ok what are we going to
implement? We need an example.

61
00:04:26.590 --> 00:04:31.120 
Since we are scientists and
researchers we want to do a science

62
00:04:31.120 --> 00:04:34.300 
based example and what we want
to do is a simple application

63
00:04:34.990 --> 00:04:39.240 
that looks for famous people in our case
this is of course then scientists

64
00:04:39.490 --> 00:04:41.940 
that have their
birthday today

65
00:04:42.640 --> 00:04:45.710 
and of course we get all
the data from DBpedia.

66
00:04:46.390 --> 00:04:49.620 
So what we want to create first
is we create somehow a list

67
00:04:49.620 --> 00:04:53.960 
of scientists whose birthday is
today including some additional

68
00:04:53.960 --> 00:04:57.290 
information like for example in
which year where they born,

69
00:04:57.530 --> 00:05:01.540 
a short description if available,
also a picture if available.

70
00:05:01.620 --> 00:05:02.970 
So let's see
what's out there

71
00:05:03.600 --> 00:05:07.410 
and then we want do not want
simply to print it, we want to

72
00:05:07.410 --> 00:05:11.880 
do a simple web page. So we want to
format everything in html which

73
00:05:12.170 --> 00:05:15.540 
later on if you want to you could
put this directly somehow

74
00:05:15.800 --> 00:05:20.440 
to your web page and you can display
everything nicely then in your browser

75
00:05:20.620 --> 00:05:25.080 
and for all that we use python
and this SPARQL wrapper library.

76
00:05:26.260 --> 00:05:29.470 
First of all we have to get the
data we are talking about. So

77
00:05:29.470 --> 00:05:34.260 
we must know what kind of SPARQL query
we have to ask we have to query

78
00:05:34.460 --> 00:05:39.020 
in DBpedia. To know of course
a bit what data is available

79
00:05:39.020 --> 00:05:43.530 
about scientists simply grab one
example of a scientist you might know.

80
00:05:44.010 --> 00:05:48.290 
Joseph Fourrier is already a guy that we
know from the course of this lecture

81
00:05:48.460 --> 00:05:52.420 
so look at it in DBmedia and you'll
see what kind of information

82
00:05:52.420 --> 00:05:56.230 
is available and this you might
then include as a template

83
00:05:56.360 --> 00:06:00.080 
within our application and there
you might be ok what do we need

84
00:06:00.230 --> 00:06:03.220 
for the application
we have in mind.

85
00:06:04.340 --> 00:06:06.880 
First of all we are looking
for scientists. So

86
00:06:07.770 --> 00:06:10.830 
if we look at the graph patterns
we create here we look for

87
00:06:10.830 --> 00:06:14.010 
scientists which must be
of RDF type dbo scientist.

88
00:06:14.700 --> 00:06:17.970 
What information could we extract?
So we need the birthdate.

89
00:06:17.970 --> 00:06:21.460 
Clear, so scientists dbo birthdate
and then we get the birthdate.

90
00:06:22.170 --> 00:06:24.570 
We need the name so we
look for RDFS label

91
00:06:25.180 --> 00:06:28.060 
we need for some kind of description
so there is for example

92
00:06:28.060 --> 00:06:31.650 
information about RDFS command
available and of course the

93
00:06:31.650 --> 00:06:36.740 
there is the thumbnail that we might display. So
thumbnail is not everywhere available so

94
00:06:36.880 --> 00:06:41.710 
we use this with of course the
directive optional. So if it's there

95
00:06:42.090 --> 00:06:43.610 
give it back
then it's good.

96
00:06:45.020 --> 00:06:47.130 
And of course we need a
few filter criteria

97
00:06:47.710 --> 00:06:50.940 
since we know that the names
usually are given not only in

98
00:06:50.940 --> 00:06:53.920 
english we restrict here to english
to make the overview easier.

99
00:06:54.310 --> 00:06:56.360 
And then of course the
most difficult thing.

100
00:06:56.910 --> 00:07:00.230 
We are only looking for guys who
have the birthdate to date.

101
00:07:00.520 --> 00:07:05.930 
So this recording takes place on
march eighteen twenty twenty.

102
00:07:07.370 --> 00:07:11.360 
That means of course I could ask
exactly in my SPARQL query

103
00:07:11.360 --> 00:07:15.980 
for a birth date where if the
birthdate is formatted correctly

104
00:07:15.980 --> 00:07:23.210 
according to the xml date
format then I could ask for

105
00:07:23.630 --> 00:07:28.910 
the string of the birthdate and
only take into account or look

106
00:07:28.910 --> 00:07:32.370 
for those who have starting
at the position six

107
00:07:33.240 --> 00:07:37.110 
the day eighteen and then
dash o three for the month.

108
00:07:37.680 --> 00:07:41.460 
But of course I would too have to
adapt this query every other

109
00:07:41.460 --> 00:07:44.590 
day because tomorrow is another
day and I have to adapt the date.

110
00:07:45.470 --> 00:07:50.490 
The nice thing here is we know
what kind of triple store is

111
00:07:50.490 --> 00:07:54.990 
used for storing DBdedia. The public
DBpedia is stored on a huge virtuoso

112
00:07:54.990 --> 00:07:56.290 
triple store.

113
00:07:57.090 --> 00:08:01.340 
And virtuoso offers a few
interesting internal functions.

114
00:08:01.340 --> 00:08:06.820 
So built in functions this is the
a namespace bif that you see

115
00:08:06.820 --> 00:08:10.150 
here and there is a function
which is called current date so

116
00:08:10.150 --> 00:08:15.850 
CUR date with that if you
ask virtuoso server you will

117
00:08:16.070 --> 00:08:19.930 
get back the current date in date
format and that of course here

118
00:08:20.160 --> 00:08:25.750 
we do change again transform into
a string and we look there again

119
00:08:26.060 --> 00:08:31.320 
exactly if let's say the
birth date of a person

120
00:08:31.850 --> 00:08:36.200 
starting at the sixth position of
the string that we extract

121
00:08:36.510 --> 00:08:42.670 
corresponds or is identical to the
same substring from the current date.

122
00:08:43.580 --> 00:08:47.480 
So this is what we are asking this is
our filter criteria. And this works

123
00:08:47.730 --> 00:08:49.780 
any possible day
not only today.

124
00:08:51.090 --> 00:08:56.220 
So let's go on so we use exactly
that triple store function

125
00:08:56.300 --> 00:09:01.870 
and we could make now exactly this
SPARQL query. Ok we can do that.

126
00:09:02.490 --> 00:09:05.980 
Simply click on it and we
see the SPARQL query here

127
00:09:06.540 --> 00:09:07.530 
and I will run it.

128
00:09:08.780 --> 00:09:12.140 
And you see the result comes pretty
quickly. We have here the birth date

129
00:09:12.740 --> 00:09:16.760 
all born on eighteenth of march
starting from sixteen forty

130
00:09:16.760 --> 00:09:20.920 
to the year nineteen sixty
nine. This is the thumb nail

131
00:09:20.920 --> 00:09:24.010 
its not available for
everybody. Then we have here

132
00:09:24.740 --> 00:09:27.890 
the scientist entity with the
name here are the names

133
00:09:28.430 --> 00:09:32.930 
and here are as you see
available descriptions.

134
00:09:35.290 --> 00:09:37.960 
This is quite easy in SPARQL
we know that already but now

135
00:09:37.960 --> 00:09:41.800 
we want to make use of exactly that
data that comes back from SPARQL.

136
00:09:41.970 --> 00:09:44.770 
You remember also the
SPARQL xml output format

137
00:09:45.490 --> 00:09:49.300 
that goes back and that we want
to make use of in a program. So

138
00:09:50.170 --> 00:09:51.830 
let's have a look.

139
00:09:54.290 --> 00:10:00.100 
For that we have prepared for you
a python collaborative notebook.

140
00:10:00.100 --> 00:10:02.910 
So it's a google collaborative
collaborative notebook where

141
00:10:02.910 --> 00:10:07.760 
you can run python code. Of course we can
also comment this python code there

142
00:10:08.040 --> 00:10:10.920 
very nicely and this we have
prepared for you. Simply follow

143
00:10:10.920 --> 00:10:15.050 
the link we have given you there and I
have prepared it already for you here.

144
00:10:15.490 --> 00:10:20.380 
So this is the scientific birthday
example in the collaborative notebook.

145
00:10:20.910 --> 00:10:24.440 
First of all if you want to
run that and if you want

146
00:10:24.440 --> 00:10:28.440 
to adapt that potentially please
make a copy of it because

147
00:10:28.440 --> 00:10:31.430 
you have only read access you might
run it but you can't change

148
00:10:31.430 --> 00:10:35.220 
it. If you want to change it copy
it and save a copy in your

149
00:10:35.220 --> 00:10:39.720 
own drive. So in your own google drive of
course. And then you can use exactly

150
00:10:39.950 --> 00:10:41.640 
this collaborative
notebook.

151
00:10:42.720 --> 00:10:47.770 
So what we need first of course to
make use of it in that collaborative

152
00:10:47.770 --> 00:10:51.620 
notebook based on python and we have
to install the SPARQL wrapper

153
00:10:51.620 --> 00:10:55.380 
library. So this is the first thing
I will run here and then you see

154
00:10:55.690 --> 00:11:02.110 
it will load some stuff and
then I hope now it has loaded

155
00:11:02.290 --> 00:11:05.250 
the SPARQL and installed
this wrapper library.

156
00:11:05.820 --> 00:11:09.320 
We will see if it works exactly
now if we go for the next

157
00:11:10.130 --> 00:11:11.150 
paragraph here.

158
00:11:12.350 --> 00:11:15.870 
So what we did now is of course
we want we need a few more

159
00:11:15.870 --> 00:11:19.560 
libraries. We are dealing with
date and time, so therefore here

160
00:11:19.560 --> 00:11:23.740 
we are importing date time and of
course here in the SPARQL program

161
00:11:23.840 --> 00:11:27.600 
we import the SPARQL wrapper and
can you can here also import

162
00:11:27.600 --> 00:11:31.150 
the SPARQL wrapper returning
or dealing with different

163
00:11:31.150 --> 00:11:34.630 
kind of output formats for
example with json xml

164
00:11:35.060 --> 00:11:37.010 
n tripple and so
on and so on.

165
00:11:38.660 --> 00:11:42.060 
Next thing we have to do after
importing the libraries that we know

166
00:11:42.370 --> 00:11:46.530 
of course we want to act as a specific
SPARQL end point and here it's DBpedia

167
00:11:47.010 --> 00:11:50.700 
we know the web address of DBpedia
and you do this here simply

168
00:11:50.700 --> 00:11:54.120 
by assigning a variable SPARQL
with a directive SPARQL wrapper

169
00:11:54.120 --> 00:11:58.380 
and you give here the string the
URI have the SPARQL end point.

170
00:11:58.530 --> 00:12:02.170 
So let's do this and
SPARQL will be filled.

171
00:12:04.290 --> 00:12:09.570 
Now the next step that we have here is
the SPARQL query that will be executed.

172
00:12:10.250 --> 00:12:14.850 
The SPARQL query is exactly
what we had here in the DBpedia

173
00:12:14.850 --> 00:12:20.460 
SPARQL end point query editor. So what
I have here I say simply SPARQL.

174
00:12:20.830 --> 00:12:24.840 
So this is the variable I
initiated over there. So yes

175
00:12:24.840 --> 00:12:29.360 
SPARQL is here initialized and
I use the method set query

176
00:12:29.510 --> 00:12:32.660 
to give the query and simply to
copy the query and without

177
00:12:32.900 --> 00:12:36.730 
editing the stuff because there
are blanks in there, there

178
00:12:36.730 --> 00:12:40.540 
are quotes in there and double
quotes and stuff like that.

179
00:12:40.780 --> 00:12:46.120 
I use here three double quotes for
in python that I can really use

180
00:12:46.590 --> 00:12:49.820 
all the letters in
the query literally.

181
00:12:51.010 --> 00:12:53.660 
So I use these three double quotes
in the beginning two double

182
00:12:53.660 --> 00:12:55.510 
quotes in the end and
there is the query.

183
00:12:56.340 --> 00:13:01.800 
This is the query and then I set here
the return form to json and here

184
00:13:02.050 --> 00:13:03.700 
I assign already I

185
00:13:04.500 --> 00:13:10.530 
performed the SPARQL query and the
results will be converted exactly

186
00:13:10.710 --> 00:13:15.520 
in a data type that is here
called results and then results

187
00:13:15.520 --> 00:13:20.870 
will contain all the results that
come back from the SPARQL endpoint

188
00:13:21.080 --> 00:13:25.650 
within this SPARQL format that
we have already talked about. So

189
00:13:27.200 --> 00:13:29.210 
let's carry
out that one.

190
00:13:29.980 --> 00:13:34.350 
It did it so now the result is
there. We don't see anything

191
00:13:34.350 --> 00:13:37.440 
so far because it's
all here in results.

192
00:13:37.870 --> 00:13:43.040 
So now results must be formatted
in html encoding because we

193
00:13:43.040 --> 00:13:45.900 
want to display a web
page made out of that.

194
00:13:46.480 --> 00:13:50.480 
So what I do is the following -
I create here html output in

195
00:13:50.480 --> 00:13:54.980 
the following ways of course
first of all we have to create

196
00:13:54.980 --> 00:13:58.430 
an html page which we which means
we need to take html, we have

197
00:13:58.430 --> 00:14:02.170 
to create a header and the header
will be here scientific birthdays

198
00:14:02.170 --> 00:14:06.780 
have to date. And of course I also want
to bring in the scientific birth date

199
00:14:07.000 --> 00:14:11.140 
of a specific date which means of
today, I want to print the date simply.

200
00:14:12.220 --> 00:14:16.970 
For that what I do is simply
I you know I have imported

201
00:14:16.970 --> 00:14:21.030 
the library daytime and there I
create the current date with

202
00:14:21.040 --> 00:14:25.480 
you have the method today and of
course I want to have it sorry

203
00:14:25.610 --> 00:14:28.470 
is played in a different way that
I have the week day of the

204
00:14:28.470 --> 00:14:33.830 
month and then I have the rest. So
weekday month and day of the month

205
00:14:33.960 --> 00:14:38.570 
and exactly with that directive
here. So this is the format I use

206
00:14:38.840 --> 00:14:43.320 
I can print it exactly in
that way and this will be H1

207
00:14:43.320 --> 00:14:45.470 
which means this
is my headline.

208
00:14:46.260 --> 00:14:50.060 
Then I start here an unordered
list and in this unordered list

209
00:14:50.060 --> 00:14:52.430 
I put in all my
results which means from

210
00:14:54.160 --> 00:14:56.670 
the construct result
I have I have to

211
00:14:57.410 --> 00:15:01.140 
extract all of the data and there
of course I have you know

212
00:15:01.750 --> 00:15:06.170 
results connected with bindings
which means if in result I

213
00:15:06.170 --> 00:15:10.550 
find the variable scientist I take
the value of scientist which

214
00:15:10.550 --> 00:15:16.020 
is then here in the bindings part and
what I do first is scientists if I

215
00:15:16.430 --> 00:15:21.880 
get that out of it this is a of course
the URU of the scientist

216
00:15:22.010 --> 00:15:25.800 
I simply combine that with the
prefix from wikipedia that I

217
00:15:25.800 --> 00:15:29.890 
have created a new URI which
only you know uses the

218
00:15:29.890 --> 00:15:33.790 
suffix from the DBpedia plus
the wikipedia prefix.

219
00:15:34.410 --> 00:15:37.330 
I don't wonder too much about
that what I wanted to do here

220
00:15:37.330 --> 00:15:40.700 
is simply of course if I display
that guy if you click then

221
00:15:40.700 --> 00:15:44.880 
on this link you get more information
that will be directly connected or

222
00:15:45.550 --> 00:15:49.620 
taken from wikipedia. So I wanted
to create a wikipedia link.

223
00:15:50.300 --> 00:15:55.850 
For that I need the wikipedia prefix
and here I take simply the suffix of

224
00:15:55.980 --> 00:15:57.800 
you know the URI
of the scientist.

225
00:15:58.690 --> 00:16:02.940 
So this will be my wiki URI.
If the this thing is empty

226
00:16:02.940 --> 00:16:06.830 
so if I have no binding then I will
simply write there NULL so nothing.

227
00:16:07.500 --> 00:16:11.090 
Then I look for the name of the
guy. If there is no name that

228
00:16:11.090 --> 00:16:13.960 
will also be NULL then I look
for the birthdate of the guy.

229
00:16:13.960 --> 00:16:17.210 
then I look for the description and
in the end I look for a thumbnail

230
00:16:17.400 --> 00:16:21.430 
and if there is no thumbnail I
display deliberately another

231
00:16:21.430 --> 00:16:24.020 
image which contains a
small question mark

232
00:16:24.470 --> 00:16:28.450 
because I have no thumbnail
for that guy. So

233
00:16:29.860 --> 00:16:34.430 
next thing I do is of course I
have extracted the birthdate

234
00:16:34.550 --> 00:16:38.350 
and now I really formatted it
in a way that I have you know

235
00:16:38.480 --> 00:16:42.100 
the format in the following way that
I have a year first then the month

236
00:16:42.220 --> 00:16:45.640 
and then the day. And this again
you do with the help here of

237
00:16:45.650 --> 00:16:49.770 
the date time library and with
that small command I have here

238
00:16:49.770 --> 00:16:54.690 
I can reform it. And of course
now I print the entire screen

239
00:16:54.760 --> 00:16:57.720 
and in part and you do it that
way that you have here first

240
00:16:57.720 --> 00:17:00.460 
the characters to be printed. So
this will be a list item in

241
00:17:00.460 --> 00:17:04.610 
html in bold and first should
come of course here the first

242
00:17:04.610 --> 00:17:06.460 
thing that I display
will be here

243
00:17:07.090 --> 00:17:11.210 
the year, you see that here. Then
comes the image that I want

244
00:17:11.210 --> 00:17:15.470 
to display. This this comes down here
this is picked and I replace this again

245
00:17:15.700 --> 00:17:20.530 
by making I have no idea how large the
pictures are that come back and I

246
00:17:20.730 --> 00:17:25.520 
use simply create them and
make them in a fixed size

247
00:17:25.520 --> 00:17:28.750 
which will be only sixty
pixels which is rather small

248
00:17:28.750 --> 00:17:31.610 
because I create or I expect
a large list of that.

249
00:17:32.210 --> 00:17:36.260 
So this is what I do and I also
have there as you see whoops

250
00:17:36.260 --> 00:17:37.750 
I have to go a
bit down sorry.

251
00:17:39.640 --> 00:17:42.770 
So I have been here the wiki URL I
have the name and the description

252
00:17:42.770 --> 00:17:43.700 
everything is in it.

253
00:17:46.380 --> 00:17:50.680 
Sorry this again switched. This
is what we did and in the end

254
00:17:50.680 --> 00:17:55.120 
if we have also this all is in
a loop and if the loop ends

255
00:17:55.370 --> 00:18:00.520 
then in the end what I have here
is I closed the unordered list

256
00:18:00.640 --> 00:18:03.290 
and I closed my
document. That's it.

257
00:18:03.900 --> 00:18:07.620 
So let's run this
section of the code.

258
00:18:09.590 --> 00:18:12.470 
It's already done and if we
scroll down we should see the

259
00:18:12.470 --> 00:18:16.650 
output and you see here it has
created exactly that html document.

260
00:18:17.160 --> 00:18:22.170 
So I have an html I have a header
then here I have here a headline

261
00:18:22.170 --> 00:18:25.730 
and then comes my list and my list
here you see here the years.

262
00:18:26.040 --> 00:18:30.190 
You see URIs of the
images and then later on all the

263
00:18:30.190 --> 00:18:31.560 
rest of what I
want to display.

264
00:18:33.740 --> 00:18:37.720 
Of course this is html and I want
to display it in my browser. So

265
00:18:37.940 --> 00:18:43.020 
what you can do simply go to the next
part here of the collaborative notebook.

266
00:18:43.260 --> 00:18:46.170 
This is exactly the same what
we did but what it does is it

267
00:18:46.170 --> 00:18:50.710 
writes everything into a file
and it asks you then to save

268
00:18:50.720 --> 00:18:55.040 
the file it has created on your
own computer. You simply do that

269
00:18:55.440 --> 00:18:58.990 
and then you go to your file system
and click on the file double

270
00:18:58.990 --> 00:19:03.060 
click on the file and what you
then see is the following

271
00:19:03.090 --> 00:19:06.240 
will be displayed in your browser.
So we have here scientific

272
00:19:06.240 --> 00:19:08.460 
birthdays of wednesday
march eighteen.

273
00:19:09.540 --> 00:19:14.450 
And you see this starts in sixteen forty
with a guy named Philippe de la Hire

274
00:19:14.620 --> 00:19:17.770 
and then you have here another guy
but we don't have a photograph.

275
00:19:17.770 --> 00:19:23.260 
So this is Karel Ferdinand Irmler.
Then you have Christian Goldbach.

276
00:19:23.620 --> 00:19:26.490 
Christian Goldbach have you heard
of them? This is the guy

277
00:19:26.490 --> 00:19:31.550 
with the famous Goldbach conjecture. So
look it look it up in wikipedia.

278
00:19:31.850 --> 00:19:35.860 
Another famous mathematician
Jakob Steiner, so he was a really

279
00:19:35.860 --> 00:19:40.470 
really important geometer yeah back in the
in the eighteenth nineteenth century.

280
00:19:41.410 --> 00:19:45.660 
Sk so this is as you see rather
amazing we have here a short

281
00:19:45.660 --> 00:19:52.010 
list of people who have birthday today
but of course in another year

282
00:19:52.190 --> 00:19:56.110 
and of course you could if you
want to do that you could

283
00:19:56.120 --> 00:19:59.680 
extend it and of course change
it in any way you want. This

284
00:19:59.680 --> 00:20:03.520 
is only a small template that
you see how you can make use

285
00:20:03.520 --> 00:20:08.010 
of RDF and SPARQL within a
programming language. And of course

286
00:20:08.340 --> 00:20:12.330 
there are no limits to your creativity.
You can do whatever you think of

287
00:20:13.490 --> 00:20:16.310 
you might think of the yeah this
was quite nice but you know

288
00:20:16.320 --> 00:20:20.050 
we have read this stuff also
in wiki data you remember and

289
00:20:20.050 --> 00:20:23.940 
in wiki data you have this nice
visualization tool. So for example

290
00:20:24.620 --> 00:20:28.390 
what you could do there is you
can make exactly the same query.

291
00:20:28.390 --> 00:20:30.980 
Here it looks a bit more
difficult as you see here.

292
00:20:32.170 --> 00:20:35.780 
I won't go into detail into the
query, I leave the analysis

293
00:20:35.780 --> 00:20:38.590 
of the query completely to you
but I'm sure you understand

294
00:20:38.590 --> 00:20:41.540 
it if you have followed the course
of that lecture. And of course

295
00:20:41.540 --> 00:20:44.470 
you can simply try it out as
always and if you want to try

296
00:20:44.470 --> 00:20:47.540 
it out I have already prepared here
the output for you since this

297
00:20:48.030 --> 00:20:53.630 
takes a bit longer. You will see
that instead of a few dozen

298
00:20:54.220 --> 00:20:58.360 
scientists wiki data already
gives you more than five hundred

299
00:20:58.360 --> 00:21:02.610 
so almost six hundred scientists back
and you see here yeah this is a

300
00:21:03.040 --> 00:21:06.880 
a huge number of people that we
see here more than five hundred

301
00:21:06.880 --> 00:21:11.280 
people who have birthday today. And of course
you see here also that guy Philippe

302
00:21:11.390 --> 00:21:14.060 
de La Hire sixteen forty
but many others.

303
00:21:15.200 --> 00:21:18.430 
So this is a nice playground
for you. However

304
00:21:18.890 --> 00:21:22.830 
last thing you saw here was a nice
visualization now in a timeline

305
00:21:22.830 --> 00:21:25.080 
not in a list that we
created on our own

306
00:21:26.080 --> 00:21:30.890 
which brings us to our very next
topic with knowledge graphs

307
00:21:30.890 --> 00:21:33.110 
and this is knowledge
graph visualizations.
