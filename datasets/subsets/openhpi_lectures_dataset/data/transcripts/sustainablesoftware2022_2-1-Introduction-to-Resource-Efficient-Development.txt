WEBVTT

1
00:00:00.970 --> 00:00:03.950 
Hi and welcome again from my side. I am honoured to welcome

2
00:00:03.950 --> 00:00:07.150 
you to another section of our course on Sustainable Software Engineering.

3
00:00:07.700 --> 00:00:10.610 
While the topics covered so far have been rather high level

4
00:00:10.830 --> 00:00:13.700 
I will now dive a bit deeper and get into some actual coding

5
00:00:13.700 --> 00:00:17.540 
in the following couple of minutes. But first let's do a quick recap.

6
00:00:18.120 --> 00:00:19.980 
So far you have learned quite a few things.

7
00:00:20.430 --> 00:00:24.090 
You have learned what sustainable means with respect to information technology.

8
00:00:24.730 --> 00:00:27.940 
You have understood the importance of sustainable software in general,

9
00:00:28.110 --> 00:00:31.590 
especially in the context of an ever increasing level of digitization.

10
00:00:31.960 --> 00:00:36.030 
Also you took the perspective of different roles and members of engineering teams,

11
00:00:36.440 --> 00:00:40.440 
all of whom are in some way responsible for driving the sustainability

12
00:00:40.440 --> 00:00:42.200 
and efficiency of software forward.

13
00:00:43.290 --> 00:00:46.430 
While you view things from a rather high level perspective so far,

14
00:00:46.780 --> 00:00:50.300 
we'll now get more concrete and look into some actual coding,

15
00:00:50.640 --> 00:00:53.160 
and how to actually write efficient code as a developer.

16
00:00:53.720 --> 00:00:57.290 
However keep in mind the code is only one of many aspects resource

17
00:00:57.290 --> 00:00:59.940 
efficiency spends the entire development process.

18
00:01:02.810 --> 00:01:05.080 
Let me give you a brief outline of the context.

19
00:01:05.640 --> 00:01:08.410 
So you're watching a course on sustainable software engineering,

20
00:01:08.760 --> 00:01:11.440 
whereas sustainability is a very broad term.

21
00:01:12.210 --> 00:01:16.210 
One central aspect of sustainability however is resource efficiency,

22
00:01:16.730 --> 00:01:19.890 
and one of the most crucial resources in the context of our

23
00:01:19.890 --> 00:01:21.250 
world's climate is carbon.

24
00:01:21.920 --> 00:01:26.140 
So you want to be especially efficient with regard to carbon or co two.

25
00:01:27.010 --> 00:01:30.540 
Carbon in turn occurs largely in the context of energy transformation

26
00:01:30.850 --> 00:01:33.800 
especially as a by-product of producing electricity.

27
00:01:35.150 --> 00:01:38.900 
Accordingly electricity is well known to serve as a proxy for carbon

28
00:01:39.210 --> 00:01:43.160 
with the big advantage of electricity being much easier to measure than carbon.

29
00:01:44.210 --> 00:01:47.350 
In the following chapters we will concern ourselves with programming.

30
00:01:47.700 --> 00:01:51.340 
So electricity consumption of a program will be a central measure.

31
00:01:52.260 --> 00:01:56.180 
This in turn especially includes how efficient your computations are,

32
00:01:56.430 --> 00:01:59.890 
how much memory you use and how much the network is utilized.

33
00:02:05.040 --> 00:02:07.790 
One of the first things you might think of when it comes to

34
00:02:07.790 --> 00:02:11.780 
energy efficiency of programs is- isn't this just equivalent to speed?

35
00:02:12.180 --> 00:02:16.590 
Or in other words, aren't faster programs with lower runtime complexity

36
00:02:16.960 --> 00:02:18.430 
also more energy efficient?

37
00:02:19.150 --> 00:02:23.440 
And in general, yes. However this is not necessarily true always.

38
00:02:24.330 --> 00:02:29.380 
Energy is power multiplied by time. So time is only one of two factors.

39
00:02:29.640 --> 00:02:32.710 
And apparently the power usage factor is not a constant

40
00:02:33.260 --> 00:02:34.090 
but can vary.

41
00:02:35.570 --> 00:02:39.140 
Time can easily be measured for a program but power is harder to measure,

42
00:02:39.460 --> 00:02:40.750 
as we'll see in the following.

43
00:02:42.130 --> 00:02:46.140 
To support this hypothesis of faster programs not necessarily

44
00:02:46.140 --> 00:02:48.330 
being more energy efficient and vice versa,

45
00:02:48.770 --> 00:02:53.340 
there's a paper from twenty seventeen where the authors benchmark different

46
00:02:53.720 --> 00:02:55.910 
programming languages against each other.

47
00:02:57.740 --> 00:03:01.010 
There in a set of different algorithms, each of them implemented in

48
00:03:01.010 --> 00:03:02.880 
twenty seven different programming languages,

49
00:03:03.440 --> 00:03:07.950 
and then they measured the execution time in seconds, the energy consumption in Jules

50
00:03:08.320 --> 00:03:10.120 
and memory usage in megabytes,

51
00:03:10.780 --> 00:03:14.290 
and eventually they found that faster programs can still use

52
00:03:14.290 --> 00:03:16.370 
more energy compared to slower ones.

53
00:03:17.430 --> 00:03:20.630 
The authors of the paper didn't elaborate on reasons for this effect

54
00:03:20.900 --> 00:03:25.260 
but certainly things like input output overhead play a role, for instance

55
00:03:25.430 --> 00:03:28.210 
the time it takes to wait for memory access and the like.

56
00:03:28.980 --> 00:03:33.340 
So usually faster programs are more energy efficient and more

57
00:03:33.340 --> 00:03:36.780 
energy efficient programs tend to be faster. However this is

58
00:03:36.780 --> 00:03:38.000 
still not always true.

59
00:03:42.440 --> 00:03:45.670 
So we found that execution time of a program is only one

60
00:03:46.100 --> 00:03:49.200 
part in the equation for its energy usage, while

61
00:03:49.200 --> 00:03:50.550 
power is the second one.

62
00:03:51.170 --> 00:03:53.650 
Now you may ask how do I determine this factor.

63
00:03:54.470 --> 00:03:57.770 
There are different ways. Some are more accurate, some are rather approximate

64
00:03:58.310 --> 00:04:01.980 
and this is due to the fact that it's very hard to estimate

65
00:04:01.980 --> 00:04:04.680 
the power demand of a single application in isolation.

66
00:04:06.170 --> 00:04:10.840 
Methods include for instance to just measure the overall power consumed by

67
00:04:11.130 --> 00:04:14.010 
the total system using a power meter at the wall plug,

68
00:04:14.670 --> 00:04:18.190 
then there are dedicated software tools and specialized development boards

69
00:04:18.790 --> 00:04:21.610 
which are solely for the purpose of measuring power usage

70
00:04:22.240 --> 00:04:26.020 
and also there are more theoretical or analytical approaches.

71
00:04:26.990 --> 00:04:29.810 
But as you can see none of these methods is trivial.

72
00:04:30.690 --> 00:04:33.970 
So for the sake of simplicity in the remaining part of this

73
00:04:33.970 --> 00:04:38.360 
course we're just going to use execution time as a proxy for energy efficiency,

74
00:04:39.020 --> 00:04:42.740 
especially in the code exercises we will measure the execution time

75
00:04:42.940 --> 00:04:46.260 
not the actual Jules of energy consumed, but still keep in

76
00:04:46.260 --> 00:04:49.960 
mind these measures are strongly correlated but not equivalent.

77
00:04:52.910 --> 00:04:55.940 
Let's get into the actual software development part.

78
00:04:56.940 --> 00:04:59.910 
One of the early steps when starting out with a new software project

79
00:05:00.080 --> 00:05:01.650 
is choosing the right technology.

80
00:05:02.350 --> 00:05:05.830 
With technology I mainly refer to programming language and

81
00:05:05.830 --> 00:05:07.500 
programming frameworks and libraries.

82
00:05:08.500 --> 00:05:11.410 
Technology choice plays an important role with respect to the

83
00:05:11.410 --> 00:05:14.950 
efficiency of your program, especially the programming language you pick.

84
00:05:16.090 --> 00:05:18.170 
Some languages are faster than others.

85
00:05:18.910 --> 00:05:23.110 
For instance compiled languages tend to be faster than virtual machine based ones

86
00:05:23.380 --> 00:05:26.240 
which again are usually faster than interpreted ones.

87
00:05:27.210 --> 00:05:30.210 
It's not a secret that C or Rust programs are tremendously

88
00:05:30.210 --> 00:05:34.090 
faster than equivalent programs implemented in for instance Python.

89
00:05:34.810 --> 00:05:39.120 
On the other hand, Python despite being fairly inefficient, facilitates

90
00:05:39.120 --> 00:05:40.990 
rapid development and better code structure.

91
00:05:41.950 --> 00:05:46.330 
So you can do anything with everything however attempting to write a web

92
00:05:46.570 --> 00:05:49.810 
application in pure c isn't probably the very best pick.

93
00:05:51.250 --> 00:05:53.500 
The takeaway here is there is no right or wrong.

94
00:05:54.040 --> 00:05:57.410 
Technology must be chosen to meet your individual demands.

95
00:05:58.530 --> 00:06:01.610 
It's always about finding a good compromise while considering,

96
00:06:01.650 --> 00:06:05.270 
especially your particular use case non functional requirements

97
00:06:05.470 --> 00:06:07.120 
as well as your team's skills.

98
00:06:08.740 --> 00:06:11.980 
Besides the language itself frameworks and libraries must be

99
00:06:11.980 --> 00:06:16.230 
choosen appropriately as well. A rule of thumb here is be minimalist

100
00:06:16.260 --> 00:06:18.110 
and only pull in what you really need.
