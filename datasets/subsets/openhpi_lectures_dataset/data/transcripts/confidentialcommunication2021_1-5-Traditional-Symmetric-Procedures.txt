WEBVTT

1
00:00:00.930 --> 00:00:05.130 
In our openHPI course "Confidential
Communication in the Internet", now we

2
00:00:05.130 --> 00:00:08.330 
want to consider some
traditional encryption methods.

3
00:00:08.780 --> 00:00:12.870 
To get a feeling what encryption
means and how does it work,

4
00:00:13.270 --> 00:00:17.290 
and these traditional encryption
methods are methods

5
00:00:17.690 --> 00:00:24.770 
that are far before the
computer and internet time.

6
00:00:27.100 --> 00:00:32.370 
So these were symmetric encryption methods
because the asymmetric ones were

7
00:00:32.850 --> 00:00:35.930 
detected thirty
forty years ago.

8
00:00:37.350 --> 00:00:40.740 
Let's start with
substitution ciphers.

9
00:00:41.870 --> 00:00:44.190 
This is a group
from cipher

10
00:00:45.070 --> 00:00:49.610 
and in the substitution ciphers each
letter each character of a text

11
00:00:49.990 --> 00:00:53.910 
of a plaintext is replaced
by a different letter.

12
00:00:54.490 --> 00:00:59.020 
Each letter by a different
letter of the same alphabet

13
00:00:59.460 --> 00:01:04.780 
and the alphabet we are using is
Latin alphabet with twenty six

14
00:01:05.370 --> 00:01:12.510 
letters. And special case of the substitution
cipher is so-called shift cipher

15
00:01:12.720 --> 00:01:17.790 
and also there are several shift
cipher and the idea of this shift

16
00:01:18.030 --> 00:01:21.830 
cipher is that the cipher
text is generated

17
00:01:22.490 --> 00:01:29.660 
by shifting the letters of the plaintext
by n positions in the alphabet.

18
00:01:30.310 --> 00:01:33.430 
Each letter is
shifted, it's shifted

19
00:01:34.770 --> 00:01:38.670 
by the same number
of positions.

20
00:01:39.590 --> 00:01:44.150 
One of this shift cipher was historically
very famous, it's the caesar cipher

21
00:01:45.320 --> 00:01:51.790 
and Caesar, yes the Roman caesar,
here he uses shift cipher

22
00:01:52.340 --> 00:01:55.880 
for encrypting
messages about wars

23
00:01:56.760 --> 00:02:00.740 
and other things by
shifting each character

24
00:02:01.150 --> 00:02:07.320 
by three positions. So for example,
from the world hello, the

25
00:02:07.560 --> 00:02:11.740 
English word hello,
we get the kdoor

26
00:02:12.290 --> 00:02:17.940 
word. So it's no connection but
you see here we have on the

27
00:02:17.940 --> 00:02:20.790 
third and fourth positions
the same letter.

28
00:02:21.240 --> 00:02:27.470 
When we shift it by the same amount
of positions, of course we also got

29
00:02:27.670 --> 00:02:31.300 
same. What is a key in
such a shift cipher?

30
00:02:31.920 --> 00:02:36.870 
The key clearly set to n, that
the number of positions that

31
00:02:36.870 --> 00:02:43.090 
are used to move the letters to
produce the cyber text. And then

32
00:02:44.300 --> 00:02:49.650 
in a Latin alphabet, it can be between one
and twenty six. So the number of keys

33
00:02:49.960 --> 00:02:55.290 
is twenty six. This is a very low
number and this low number

34
00:02:55.910 --> 00:02:59.140 
of course allows
brute-force attacks.

35
00:03:00.280 --> 00:03:04.930 
Why? Brute forces
try out all keys

36
00:03:05.590 --> 00:03:08.080 
up to the moment you
find the right one.

37
00:03:08.570 --> 00:03:14.460 
And when realised to have the right
one if useless or a stupid text

38
00:03:14.610 --> 00:03:16.580 
changed into a
meaningful text.

39
00:03:17.360 --> 00:03:21.780 
When we have only twenty six
different keys, we can start with

40
00:03:21.860 --> 00:03:25.850 
an equal one with an equal
two with an equal three and

41
00:03:28.420 --> 00:03:35.050 
after a short while we have tried
out all the different possible keys

42
00:03:35.440 --> 00:03:40.350 
and then we can
decrypt the ciphertext.

43
00:03:43.230 --> 00:03:45.240 
There are other successful
attacks possible

44
00:03:45.880 --> 00:03:50.030 
for such simple
shift ciphers

45
00:03:50.580 --> 00:03:53.500 
and one is the
frequency analysis.

46
00:03:54.490 --> 00:03:58.380 
And the frequency analysis
is based on the

47
00:03:59.690 --> 00:04:04.140 
appearance of the different
letters in a plaintext.

48
00:04:05.020 --> 00:04:10.340 
And what we see, each language
is characterized that in the

49
00:04:10.340 --> 00:04:11.920 
text of this language

50
00:04:12.540 --> 00:04:17.450 
the frequency of one
letter is about the same

51
00:04:17.910 --> 00:04:21.710 
over many such texts.
So for example the

52
00:04:23.440 --> 00:04:30.090 
letter e comes in the english
text most frequently,

53
00:04:30.750 --> 00:04:36.650 
is in the english text most frequently and
comes with an occurrence of eleven percent.

54
00:04:37.570 --> 00:04:42.650 
The letter a is eight percent, the
letter r is seven percent

55
00:04:43.530 --> 00:04:47.690 
and now we can analyze,
we can analyze the

56
00:04:48.560 --> 00:04:53.190 
ciphertext and can check the
occurrence of the simple letters

57
00:04:53.310 --> 00:04:55.180 
and then we can try out

58
00:04:56.390 --> 00:05:01.750 
according to this, to this frequency
of the different letters to

59
00:05:01.960 --> 00:05:04.660 
change into the
right ones.

60
00:05:05.380 --> 00:05:09.830 
Because we have only one text, we
have a little bit to play with it,

61
00:05:10.020 --> 00:05:15.110 
because in a single text the
distribution can be different from

62
00:05:15.590 --> 00:05:18.160 
all the text
but it is a

63
00:05:18.770 --> 00:05:21.440 
simple approach for
in cyber-attacks.

64
00:05:22.630 --> 00:05:27.530 
Another substitution in cipher are
so called permutation ciphers.

65
00:05:28.210 --> 00:05:32.960 
And the permutation cipher is
is that we have a table.

66
00:05:33.550 --> 00:05:39.330 
We have a table with the alphabet
and then below of each letter

67
00:05:39.590 --> 00:05:42.070 
there is another letter
of the alphabet.

68
00:05:42.570 --> 00:05:49.020 
So we can mix it as we like. Important is
that we have our twenty six characters,

69
00:05:49.310 --> 00:05:54.330 
that we have twenty six
other characters. So a b c

70
00:05:54.940 --> 00:06:03.160 
can r s l, and then we
generate the cipher text, the cipher

71
00:06:03.640 --> 00:06:09.680 
text from the plaintext by
replacing accordingly to this table

72
00:06:09.920 --> 00:06:13.630 
the different letters by
the other letters.

73
00:06:15.180 --> 00:06:22.380 
So a permutation is a function which
assigns each letter of the alphabet,

74
00:06:22.660 --> 00:06:25.070 
another letter in the
alphabet. It needs to be

75
00:06:26.070 --> 00:06:30.050 
isomorphic function,
that means all

76
00:06:30.870 --> 00:06:33.550 
letters have an
original letter.

77
00:06:34.230 --> 00:06:41.360 
So a letter set is assigned to p of set
and p is the permutation, a permutation

78
00:06:42.180 --> 00:06:45.060 
over all the letters
of the alphabet.

79
00:06:45.880 --> 00:06:48.910 
So here the key is
the permutation,

80
00:06:49.700 --> 00:06:53.770 
is the assignment
of the different letters

81
00:06:54.290 --> 00:06:56.810 
and the number
of assignments.

82
00:06:57.490 --> 00:07:02.820 
This is really big. It is twenty
six, this is the number of letters,

83
00:07:02.820 --> 00:07:06.790 
the size of our alphabet and
this is factorial, because we can

84
00:07:06.790 --> 00:07:10.530 
have all these sequences you
can use all the sequences

85
00:07:11.100 --> 00:07:17.620 
and if we know twenty six factorial is
more than four hundred quadrillion.

86
00:07:18.490 --> 00:07:22.970 
So here now we have a
huge space of keys

87
00:07:23.760 --> 00:07:30.350 
and a brute-force attack to try out
all assignments, all permutations

88
00:07:31.060 --> 00:07:34.140 
needs really a
very long time.

89
00:07:34.810 --> 00:07:39.990 
The four quadrillion is four
times ten to twenty six.

90
00:07:42.040 --> 00:07:48.080 
Even more difficult then this permutation
ciphers which is the substitution cipher,

91
00:07:48.270 --> 00:07:52.490 
are ciphers from the
polyalphabetic

92
00:07:53.690 --> 00:07:59.910 
ciphers and the idea here
is that we can use different letters

93
00:08:00.120 --> 00:08:05.700 
for a replacement of one letter
in our plaintext. So here

94
00:08:05.700 --> 00:08:12.280 
we can make the frequency analysis
which is applicable to the permutation

95
00:08:13.120 --> 00:08:18.320 
cipher, but it is no more
applicable here because we can

96
00:08:18.570 --> 00:08:23.290 
replace and letter e
for example by many

97
00:08:24.460 --> 00:08:27.810 
other letters. Sorry, here is a
mistake so it's eleven

98
00:08:28.340 --> 00:08:32.720 
different characters
because this e has

99
00:08:33.590 --> 00:08:39.990 
eleven percent of the different character. So
frequently occurring letters are encoded

100
00:08:40.280 --> 00:08:47.360 
by different characters so that it's
more difficult or impossible to apply

101
00:08:47.650 --> 00:08:54.310 
this frequency methods. But also here
against this polyalphabetic ciphers,

102
00:08:54.630 --> 00:08:57.290 
one can design

103
00:08:58.210 --> 00:09:02.190 
a text based on the
statistical analysis

104
00:09:03.040 --> 00:09:09.100 
of the frequent letter
combinations. One is no more

105
00:09:09.230 --> 00:09:10.590 
looking to the single

106
00:09:11.440 --> 00:09:14.550 
letter, one
considers different

107
00:09:15.850 --> 00:09:21.490 
positions of two or
sequences of three letters

108
00:09:21.840 --> 00:09:25.220 
and investigates
the occurrence of

109
00:09:25.890 --> 00:09:27.970 
such two or
three that are there.

110
00:09:29.120 --> 00:09:34.090 
To make it understandable,
to give an example for such a

111
00:09:34.300 --> 00:09:35.770 
polyalphabetic cipher,

112
00:09:36.490 --> 00:09:40.800 
look please to the VigenÃ¨re cipher.
And here the idea is

113
00:09:41.870 --> 00:09:46.280 
by constantly repeating
an agreed keyword,

114
00:09:47.380 --> 00:09:49.530 
a key text is generated

115
00:09:50.140 --> 00:09:56.860 
in the length of the plaintext.
So we take a keyword and then we

116
00:09:57.920 --> 00:10:03.780 
repeat and repeat and repeat this
keyword as long as we have, as long as

117
00:10:04.310 --> 00:10:06.330 
the length of
our plaintext.

118
00:10:07.010 --> 00:10:11.450 
And then the ciphertext
is obtained by adding

119
00:10:12.080 --> 00:10:15.080 
the plaintext and the key
text letter-by-letter.

120
00:10:15.570 --> 00:10:22.170 
Adding means the position of the
position of the letter and the plaintext

121
00:10:22.540 --> 00:10:30.100 
is changed or is shifted by the
position of the corresponding letter

122
00:10:30.260 --> 00:10:38.200 
of the key text. To make it more clear,
we have our plaintext. Plaintext is

123
00:10:38.910 --> 00:10:41.830 
short, as an example
state secret.

124
00:10:42.750 --> 00:10:45.410 
And our keyword
is secret key.

125
00:10:46.220 --> 00:10:52.460 
Now we repeat secret key as often as
we have the length of the secret key

126
00:10:53.340 --> 00:11:01.520 
and then we can we can
add these

127
00:11:01.940 --> 00:11:07.280 
two letters. That means we shift
the letter s by the position

128
00:11:07.280 --> 00:11:12.700 
of s in the alphabet. And then
we shift the letter t by the

129
00:11:12.700 --> 00:11:19.020 
position of the letter e in the keyword
and then we shift a by the position

130
00:11:19.280 --> 00:11:27.390 
of c and in this way we get this part
and this is quite an interesting

131
00:11:27.490 --> 00:11:32.840 
quite interesting encryption methods.
It's simple to perform but

132
00:11:32.960 --> 00:11:34.350 
difficult to attack.

133
00:11:36.520 --> 00:11:41.480 
With this, there are different
famous examples of this

134
00:11:42.230 --> 00:11:44.300 
polyalphabetic cipher.

135
00:11:45.020 --> 00:11:49.720 
One, which is very interesting
from a theoretical point of

136
00:11:50.020 --> 00:11:52.760 
view is so called
one-time pad.

137
00:11:53.810 --> 00:11:57.170 
And the one-time pad is a special
case of the VigenÃ¨re cyber

138
00:11:57.510 --> 00:12:02.260 
and here the choice of the keyword,
the keyword is not generated

139
00:12:02.260 --> 00:12:04.920 
by repeating a short
keyboard as long as

140
00:12:05.760 --> 00:12:12.780 
a length of plaintext. Here the
key is generated as a randomly

141
00:12:12.930 --> 00:12:21.370 
sequence of letters of unlimited
length so that each plaintext

142
00:12:21.510 --> 00:12:27.520 
we have such a random sequence of
letters as a key for this computation.

143
00:12:29.220 --> 00:12:34.390 
If we apply this, if we apply this
method to a binary alphabet,

144
00:12:34.970 --> 00:12:38.840 
not to our Latin alphabet, to our
binary alphabet and this is

145
00:12:38.840 --> 00:12:43.700 
the situation we have in the
computer world which we have

146
00:12:43.700 --> 00:12:46.160 
in the digital
application, then

147
00:12:47.230 --> 00:12:53.530 
we can prove the following
mathematical theorem which says,

148
00:12:53.530 --> 00:13:00.610 
the one time pads which are operated by
a true random sequence have perfect

149
00:13:00.870 --> 00:13:05.050 
secrecy There is a perfect
security. This is mathematically

150
00:13:05.050 --> 00:13:10.190 
defined what it means. So
by having a real true

151
00:13:10.660 --> 00:13:12.740 
random sequence

152
00:13:13.390 --> 00:13:19.470 
of zero and ones, and have our message
of zero and ones, then we get

153
00:13:19.920 --> 00:13:21.570 
with this one-time pad

154
00:13:22.280 --> 00:13:25.360 
a very secure
encryption method.

155
00:13:27.060 --> 00:13:31.960 
The advantage of this very secure method
is that it's a very simple procedure.

156
00:13:32.750 --> 00:13:37.270 
A very simple procedure that can be used
by each layman with paper and pencil.

157
00:13:37.890 --> 00:13:44.780 
So agents always carry out a sealed
envelope with a longer random sequence

158
00:13:44.920 --> 00:13:50.480 
they got from their agency and
then if they have a message,

159
00:13:50.480 --> 00:13:56.210 
they take this random
sequence and they encode

160
00:13:56.980 --> 00:13:57.720 
the plain text.

161
00:13:59.010 --> 00:14:05.170 
Problem here is to get a
real random sequence

162
00:14:06.260 --> 00:14:08.490 
because it's not easy

163
00:14:09.120 --> 00:14:14.410 
to produce such a very
long random sequence.

164
00:14:15.730 --> 00:14:19.810 
There are pseudorandom

165
00:14:20.890 --> 00:14:25.270 
generators but here for
this validity of this

166
00:14:26.350 --> 00:14:31.360 
mathematical theorem, it's very important
that a real random sequence.

167
00:14:33.040 --> 00:14:37.930 
And this makes it difficult
for exchanging the key

168
00:14:38.730 --> 00:14:42.530 
because both partners, it's a
symmetric cryptographic method,

169
00:14:42.630 --> 00:14:48.740 
so both communication partners need
that key, need that random sequence.

170
00:14:49.700 --> 00:14:54.660 
By the way there are ideas to
use signals from a satellite

171
00:14:55.160 --> 00:14:59.940 
which can be received on any
place on the earth and then if

172
00:14:59.950 --> 00:15:06.910 
they both synchronize their watches, then
they can get such a random sequence.

173
00:15:07.010 --> 00:15:10.830 
So there are many methods. We have
no time to go into detail

174
00:15:11.350 --> 00:15:17.590 
but it is difficult in the sense that
the transmitter and receiver must

175
00:15:17.980 --> 00:15:23.720 
store such very long keys and have
to deal with such very long keys.

176
00:15:25.620 --> 00:15:30.490 
Perhaps the the last
example of rotor ciphers

177
00:15:31.060 --> 00:15:34.330 
and the enigma
encryption mission.

178
00:15:35.100 --> 00:15:39.430 
Here are some historic effects
about this enigma which is

179
00:15:40.260 --> 00:15:42.820 
the famous example
of rotor cipher.

180
00:15:44.290 --> 00:15:50.750 
As late as the first world war
radio messages were encrypted

181
00:15:51.100 --> 00:15:55.160 
with a further developed version
of VigenÃ¨re cipher. So this VigenÃ¨re

182
00:15:55.160 --> 00:15:59.630 
cipher has many many applications
and were very popular

183
00:16:00.190 --> 00:16:04.550 
in the use of
such encrypted,

184
00:16:05.490 --> 00:16:09.960 
mostly in military applications
encryptings.

185
00:16:10.470 --> 00:16:16.740 
So around ninety eighteen, a rotor
cipher became independent invented

186
00:16:16.970 --> 00:16:23.090 
by at least four different inventors
and rotor cipher works as follows.

187
00:16:23.190 --> 00:16:29.490 
One has different such rotors
which can be moved and on each

188
00:16:30.230 --> 00:16:32.050 
entrance there
is one letter.

189
00:16:32.720 --> 00:16:38.210 
And so, inside the
rotor there are different

190
00:16:39.890 --> 00:16:44.460 
permutation cipher. So
there are different connections

191
00:16:44.930 --> 00:16:49.630 
for the single letters. So for
example when we start to put c

192
00:16:50.090 --> 00:16:56.010 
into the first rotor we get a
b. And then the b is moved by

193
00:16:56.010 --> 00:16:59.580 
the first rotor to an
a. And then the a is

194
00:17:00.910 --> 00:17:09.300 
changed into a d. So if we use more of
such rotors, we can generate very very

195
00:17:09.460 --> 00:17:12.130 
different and very

196
00:17:13.000 --> 00:17:17.760 
difficult encryptions, difficult
for crypto analytics.

197
00:17:18.950 --> 00:17:24.770 
So the most famous representative
of rotor ciphers was this

198
00:17:25.180 --> 00:17:31.880 
enigma machine, the enigma encryption
machine that was used by the German

199
00:17:32.150 --> 00:17:36.770 
army in the second world war.
Not only the army, but also the

200
00:17:37.560 --> 00:17:42.220 
marine used it and the
people felt that it's

201
00:17:42.960 --> 00:17:46.500 
unbreakable but a
very famous

202
00:17:47.120 --> 00:17:54.360 
mathematician Turing, Alan Turing, he
got a lot of support from

203
00:17:55.320 --> 00:17:58.310 
from the English army.
So they

204
00:17:59.040 --> 00:18:01.050 
established

205
00:18:02.540 --> 00:18:09.620 
fabric with thousands of people that
worked on the decryption of this

206
00:18:10.030 --> 00:18:14.980 
Enigma machine and at the end even
before the second world war

207
00:18:15.090 --> 00:18:20.630 
was finished, they were able to read
the German, encrypted German messages

208
00:18:20.900 --> 00:18:24.120 
and of course this brought
a big advantage in

209
00:18:24.720 --> 00:18:27.510 
a fight between
these two armies.

210
00:18:29.030 --> 00:18:31.810 
We will have
an excursus

211
00:18:32.450 --> 00:18:37.790 
on rotor ciphers and the enigma. Who
is interested in more details,

212
00:18:38.990 --> 00:18:40.380 
we have it in
our course.

213
00:18:42.350 --> 00:18:47.730 
I think this gives some examples about
the idea of encryption. How it worked

214
00:18:48.070 --> 00:18:52.550 
and the traditional examples
of course are very easy to

215
00:18:52.550 --> 00:18:58.430 
understand and simple to apply. So it
helps us to get an understanding

216
00:19:00.090 --> 00:19:03.410 
at least of these symmetric
encryption methods.
