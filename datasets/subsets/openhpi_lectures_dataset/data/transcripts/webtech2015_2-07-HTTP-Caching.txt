WEBVTT

1
00:00:05.060 --> 00:00:07.190 
Let's now talk about HTTP caching.

2
00:00:08.380 --> 00:00:11.650 
We already discussed that caching is a very important

3
00:00:12.350 --> 00:00:16.870 
technique to improve efficiency of the web.

4
00:00:17.650 --> 00:00:21.230 
And the idea behind is that many resources

5
00:00:21.980 --> 00:00:24.840 
in the web are not changed very often.

6
00:00:25.510 --> 00:00:28.680 
So if a resource is one times requested,

7
00:00:29.250 --> 00:00:34.030 
then it makes sense to store this and when

8
00:00:34.500 --> 00:00:39.000 
a resource is requested a second time then to provide this

9
00:00:39.000 --> 00:00:44.510 
resource out of the store and not by contacting the server

10
00:00:44.700 --> 00:00:46.340 
at the other part of the world.

11
00:00:47.250 --> 00:00:51.430 
So the efficiency of the web may be increased dramatically

12
00:00:51.810 --> 00:00:53.750 
by avoiding such repeated data transfer.

13
00:00:54.390 --> 00:00:57.510 
Data transfer of the same information resource.

14
00:00:59.300 --> 00:01:04.070 
Exactly this is idea for  a cache

15
00:01:04.590 --> 00:01:11.490 
and what is needed are intelligent intermediate systems which are able to

16
00:01:11.650 --> 00:01:13.580 
cache such resources.

17
00:01:14.860 --> 00:01:19.640 
So in this way a cache acts as the third element

18
00:01:20.140 --> 00:01:25.210 
within the client server interaction. We already discuss that such intermediate systems

19
00:01:26.100 --> 00:01:27.870 
make the communication

20
00:01:28.590 --> 00:01:32.060 
model a little bit more complicated but

21
00:01:32.950 --> 00:01:36.430 
we will see it makes sense to use caching strategies.

22
00:01:37.120 --> 00:01:42.560 
So all browser's requests to a web server are rebouted via this intermediate cache.

23
00:01:43.170 --> 00:01:46.340 
We already discuss such proxy server so a

24
00:01:46.750 --> 00:01:50.040 
typical place for such a cache is at the proxy server.

25
00:01:50.810 --> 00:01:54.920 
Then the case stores the respective answer

26
00:01:55.430 --> 00:01:57.790 
for a while for limited time,

27
00:01:58.690 --> 00:02:03.150 
and in case the browser requests the same resource a second time

28
00:02:03.670 --> 00:02:09.910 
then although this request is routed over the cache, the cache sees who

29
00:02:10.290 --> 00:02:14.150 
he can provide the document and then the cache immediately

30
00:02:14.260 --> 00:02:18.730 
provides the document to the browser, response to the browser

31
00:02:18.900 --> 00:02:22.270 
so that no more necessary to request this calls

32
00:02:22.790 --> 00:02:24.560 
over the internet from the

33
00:02:25.270 --> 00:02:26.180 
origin server.

34
00:02:27.460 --> 00:02:34.320 
So in case the source is re-requested the intermediate cache can answer the

35
00:02:35.300 --> 00:02:39.210 
request and not necessary to interact with the server.

36
00:02:40.230 --> 00:02:43.590 
This way caching reduces the communication

37
00:02:44.150 --> 00:02:48.910 
traffic dramatically and it also reduces the server load.

38
00:02:51.270 --> 00:02:53.290 
How such caches are implemented?

39
00:02:54.210 --> 00:02:57.050 
There are different ways to implement such

40
00:02:57.670 --> 00:03:00.610 
such a cache and they differ mainly

41
00:03:01.290 --> 00:03:04.970 
in the place where the cache is implemented.

42
00:03:06.590 --> 00:03:09.550 
Any place between the browser and the server

43
00:03:10.230 --> 00:03:12.470 
makes sense to be used for caching.

44
00:03:13.810 --> 00:03:16.980 
So for example we can cache at the client side.

45
00:03:17.640 --> 00:03:22.180 
So here the cache is at the client and stores the response

46
00:03:22.280 --> 00:03:24.520 
from all the client requests.

47
00:03:25.290 --> 00:03:30.450 
When loading subsequent interlink pages of the same websites

48
00:03:31.050 --> 00:03:36.170 
many shared resources; the images, cascading, stylesheets, javascript,

49
00:03:36.570 --> 00:03:41.520 
are stored in separate files and included by every page.

50
00:03:42.150 --> 00:03:47.870 
So this shared resources can easily be cached. So if next time the

51
00:03:48.140 --> 00:03:53.100 
client requests the data then all the data are already

52
00:03:53.510 --> 00:03:58.890 
at the client site and can be used for giving a fast display of the website.

53
00:03:59.980 --> 00:04:05.320 
So this is a client-side cache, but the client as a cache can also

54
00:04:05.940 --> 00:04:08.330 
be placed in between the

55
00:04:09.000 --> 00:04:10.430 
client and the server.

56
00:04:12.230 --> 00:04:14.640 
For example in proxy server,

57
00:04:15.410 --> 00:04:20.270 
so when the client requesting resource,

58
00:04:21.170 --> 00:04:24.450 
request is rooted over the independent cache

59
00:04:25.470 --> 00:04:30.590 
cache forward this request to the server and the response of the server

60
00:04:30.730 --> 00:04:34.510 
is done while as a cache to the

61
00:04:35.290 --> 00:04:38.040 
requesting client. And then this

62
00:04:38.680 --> 00:04:40.430 
independent intermediate cache

63
00:04:41.140 --> 00:04:45.990 
is used to store this resource before it is forwarded to the client.

64
00:04:47.360 --> 00:04:52.300 
This makes particularly sense if for example such a proxy server

65
00:04:52.440 --> 00:04:57.230 
and the cache inside such a proxy server serves for a full internet

66
00:04:57.540 --> 00:05:03.630 
so all the requests from the clients inside that internet

67
00:05:03.820 --> 00:05:10.100 
are routed over this cache to the origin service and in this way

68
00:05:10.650 --> 00:05:15.380 
if the cache is placed here in this proxy server then

69
00:05:15.810 --> 00:05:19.840 
even if another client of the internet requests it

70
00:05:20.580 --> 00:05:23.220 
you can be served out of the cache.

71
00:05:24.250 --> 00:05:28.940 
And then there is a third possibility that is to place the cache

72
00:05:29.110 --> 00:05:35.240 
on the server side. So here the cache is at the server and the

73
00:05:35.240 --> 00:05:40.190 
cache stores all the response which are sent by the server

74
00:05:40.450 --> 00:05:47.770 
and delivers them independent upon subsequent request. This makes particularly sense

75
00:05:47.980 --> 00:05:51.700 
for dynamically constructed resources.

76
00:05:52.420 --> 00:05:56.660 
So the cache can be implemented on the client side can be implemented

77
00:05:56.670 --> 00:06:00.960 
on the server side and can be in the blended in intermediate systems

78
00:06:01.080 --> 00:06:04.490 
and what we see we find all three

79
00:06:05.160 --> 00:06:07.680 
possibilities simultaneously.

80
00:06:10.240 --> 00:06:14.290 
Now we told only half of the truth,

81
00:06:14.940 --> 00:06:18.760 
what if the cache has stored a document

82
00:06:19.420 --> 00:06:22.870 
and the document is changed on the server side?

83
00:06:23.780 --> 00:06:27.110 
Then if the document would be provided out of the cache,

84
00:06:28.070 --> 00:06:32.220 
the wrong document, the unchanged document, would be sent to

85
00:06:32.220 --> 00:06:36.580 
the client and not the actual document from the

86
00:06:37.070 --> 00:06:38.560 
from the server.

87
00:06:39.900 --> 00:06:43.090 
Such sources resources are called invalid.

88
00:06:43.500 --> 00:06:46.910 
Invalid and are called stale.

89
00:06:48.010 --> 00:06:49.730 
So what is needed if one

90
00:06:51.150 --> 00:06:52.780 
likes to work with such

91
00:06:54.090 --> 00:06:55.920 
caches is to

92
00:06:57.220 --> 00:07:03.180 
develop and to implement mechanisms to prevent that stale

93
00:07:04.390 --> 00:07:08.090 
documents are delivered to the client.

94
00:07:10.660 --> 00:07:15.170 
We speak about a cache hit if the requested resources cache

95
00:07:15.640 --> 00:07:17.460 
is cached and is valid.

96
00:07:18.250 --> 00:07:25.750 
Then the cache can immediately respond to the client and send this resource

97
00:07:26.170 --> 00:07:26.940 
to the client.

98
00:07:30.090 --> 00:07:34.280 
But it's also possible that the resource is normal actor

99
00:07:34.480 --> 00:07:37.650 
that the resource is not even cached.

100
00:07:38.320 --> 00:07:42.160 
In those cases we speak of a cache miss.

101
00:07:43.470 --> 00:07:46.420 
A cache miss means the requested resource

102
00:07:46.850 --> 00:07:51.180 
is either not cached or it is cached but stale.

103
00:07:51.950 --> 00:07:57.890 
So here the cache has to forward the request to the original server

104
00:07:58.210 --> 00:08:02.540 
and then the original server response with the resource and

105
00:08:02.540 --> 00:08:08.180 
then the cache can store the resource before it forwards the resource

106
00:08:08.360 --> 00:08:10.310 
to the client. so cache hit;

107
00:08:13.340 --> 00:08:18.260 
the resource can be delivered out of the cache. Cache miss it's not possible.

108
00:08:19.860 --> 00:08:25.210 
The problem now is how to organize so called cache consistency?

109
00:08:25.620 --> 00:08:29.010 
Cache consistency means that what is cached

110
00:08:29.510 --> 00:08:34.760 
is the same like the resource cache resource is a same resource

111
00:08:34.940 --> 00:08:37.080 
like the resource at the server.

112
00:08:40.630 --> 00:08:42.720 
If a cached resource valid

113
00:08:43.800 --> 00:08:50.070 
that means that cached resource and the original document they match

114
00:08:51.260 --> 00:08:55.640 
this question needs to be answered before a cache can

115
00:08:56.590 --> 00:09:02.050 
respond with the resource in case of cached or has to forward

116
00:09:02.050 --> 00:09:06.020 
the request to the origin server in case if it's not consistent.

117
00:09:08.010 --> 00:09:11.570 
Ways how to provide this how to guarantee that the

118
00:09:13.070 --> 00:09:20.390 
cache consistency is provided a solution is that all the documents are delivered

119
00:09:20.540 --> 00:09:24.250 
with time stamp and expiration date.

120
00:09:25.280 --> 00:09:30.280 
So when the server response by sending a document

121
00:09:31.630 --> 00:09:37.240 
HTTP also includes time stamp and expiration date,

122
00:09:37.940 --> 00:09:43.950 
HTTP communicates this to the cache and to the client.

123
00:09:46.280 --> 00:09:50.940 
For that purpose there is in the header a field,

124
00:09:51.720 --> 00:09:53.080 
header field for caching.

125
00:09:53.870 --> 00:09:56.620 
This field is called cache control.

126
00:09:57.810 --> 00:10:01.950 
An example here cache control max age 3600.

127
00:10:02.410 --> 00:10:08.360 
This is the number of seconds the document is considered to be valid.

128
00:10:09.540 --> 00:10:14.280 
so important cache control settings are max age.

129
00:10:14.910 --> 00:10:19.880 
Max-age defines the time in seconds after which a cache resource

130
00:10:19.880 --> 00:10:23.770 
becomes stale and must be re requested from the origin server.

131
00:10:25.190 --> 00:10:28.780 
Setting no cache no cache is the setting

132
00:10:29.860 --> 00:10:35.750 
of the cache control header field and tells the cache to be re-validate

133
00:10:35.990 --> 00:10:40.210 
the

134
00:10:40.210 --> 00:10:44.060 
resource on every request. And there is

135
00:10:44.660 --> 00:10:49.450 
setting no store and no store prevents the cache from storing

136
00:10:49.560 --> 00:10:51.020 
a resource at all.

137
00:10:52.390 --> 00:10:55.800 
This are the important cache control settings.

138
00:10:57.390 --> 00:10:59.650 
In older HTTP cache header ,

139
00:11:01.330 --> 00:11:04.440 
expire as field used for that purposes.

140
00:11:05.840 --> 00:11:08.790 
Takes a timestamp after which it becomes stale.

141
00:11:10.600 --> 00:11:14.540 
Setting the max age in the cache control header

142
00:11:15.090 --> 00:11:17.200 
overrides the expires header

143
00:11:17.840 --> 00:11:20.040 
in this expire as field.

144
00:11:23.830 --> 00:11:26.160 
Content revalidation;

145
00:11:27.270 --> 00:11:30.140 
the client must re-validate a cache resource

146
00:11:30.580 --> 00:11:31.900 
in the following cases.

147
00:11:33.360 --> 00:11:35.760 
If the max age is reached,

148
00:11:36.980 --> 00:11:44.780 
if a cache control header is set no cache, or must re-validate.

149
00:11:46.500 --> 00:11:51.170 
In these cases the client has to

150
00:11:51.610 --> 00:11:57.110 
request a data cache has to request the data from the origin server.

151
00:11:58.390 --> 00:12:03.490 
The client sends timestamp when it last accessory source

152
00:12:04.470 --> 00:12:06.790 
if modified since header.

153
00:12:08.080 --> 00:12:12.390 
If the resource has been updated on the server since then the

154
00:12:12.390 --> 00:12:17.620 
server answers with a 200 OK and the updated resource.

155
00:12:18.180 --> 00:12:22.360 
So in the request the client ask

156
00:12:23.330 --> 00:12:28.350 
server whether the resource was modified

157
00:12:28.840 --> 00:12:33.150 
in that time. And in case it was modified then the

158
00:12:33.670 --> 00:12:36.240 
server has to be that back the resource.

159
00:12:37.910 --> 00:12:45.000 
Otherwise, it can then back the 304 not modified status in the response

160
00:12:45.430 --> 00:12:51.690 
and then the resource can take out of the cache because it

161
00:12:51.690 --> 00:12:53.170 
was not modified.
