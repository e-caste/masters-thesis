WEBVTT

1
00:00:00.740 --> 00:00:05.959 
Yeah, hello, it's me again, Wolfram Greis from the European Mainframe Academy.

2
00:00:05.960 --> 00:00:10.399 
In the next video clip, I want to talk about Data Management,

3
00:00:10.400 --> 00:00:14.929 
not each and every component of the data management or subcomponents,

4
00:00:14.930 --> 00:00:20.119 
but in fact one component that is important to understand.

5
00:00:20.120 --> 00:00:23.809 
It's the so-called catalog, and the catalog management.

6
00:00:23.810 --> 00:00:28.849 
Catalogs are really critical in a z/OS environment, without a catalog

7
00:00:28.850 --> 00:00:33.559 
no system is running, so we need a so-called master

8
00:00:33.560 --> 00:00:37.349 
catalog in each and every z/OS operating system.

9
00:00:37.350 --> 00:00:41.779 
It's mandatory, no z/OS system can run without such a

10
00:00:41.780 --> 00:00:47.209 
master catalog, a really critical and important component.

11
00:00:47.210 --> 00:00:51.799 
We can have user catalogs, I will give you

12
00:00:51.800 --> 00:00:54.109 
some examples on the next file.

13
00:00:54.110 --> 00:00:59.369 
User catalogs are optional but strongly recommended because

14
00:00:59.370 --> 00:01:03.999 
the management of such an environment is much more easier if

15
00:01:04.000 --> 00:01:06.019 
we use user catalogs.

16
00:01:06.020 --> 00:01:10.699 
If you use just master catalogs, we don't have a control on

17
00:01:10.700 --> 00:01:15.499 
how many entries are done in the Master Catalog and

18
00:01:15.500 --> 00:01:20.059 
if Master Catalog Catalog is getting full, we have a real

19
00:01:20.060 --> 00:01:24.499 
system problem and that's what

20
00:01:24.500 --> 00:01:29.299 
we want to prevent, and that's why we use user catalogs.

21
00:01:29.300 --> 00:01:34.009 
And in the master catalog for each and every user, we normally have just

22
00:01:34.010 --> 00:01:38.959 
one entry, it's a so-called alias entry, pointing to a user catalog,

23
00:01:38.960 --> 00:01:43.459 
and all the data sets are then put into

24
00:01:43.460 --> 00:01:46.459 
the user catalog.

25
00:01:46.460 --> 00:01:50.899 
No reasonable management without user catalogs.

26
00:01:50.900 --> 00:01:54.919 
Now let's talk about naming conventions for datasets.

27
00:01:54.920 --> 00:01:59.869 
We have a flat dataset structure, no file hierarchy,

28
00:01:59.870 --> 00:02:04.399 
as it is typically on other platforms like

29
00:02:04.400 --> 00:02:07.729 
Unix or Linux or Windows available.

30
00:02:07.730 --> 00:02:09.829 
We have a flat dataset structure.

31
00:02:09.830 --> 00:02:14.899 
The dataset name can be a maximum of 44 characters.

32
00:02:14.900 --> 00:02:19.369 
It consists of so-called qualifiers.

33
00:02:19.370 --> 00:02:23.959 
In many cases, it's really useful to use short names with

34
00:02:23.960 --> 00:02:26.629 
just three qualifiers.

35
00:02:26.630 --> 00:02:27.630 
It's just a tip.

36
00:02:32.250 --> 00:02:36.979 
There could be some reason to do it the other way around but normally,

37
00:02:36.980 --> 00:02:41.629 
especially when we also work with ISPF, the Interactive System

38
00:02:41.630 --> 00:02:46.549 
Productivity Facility, it's reasonable to work with

39
00:02:46.550 --> 00:02:51.139 
three qualifiers. We have two special qualifiers

40
00:02:51.140 --> 00:02:55.589 
with a special meaning. We have a so-called high level qualifier,

41
00:02:55.590 --> 00:02:59.329 
it forms the beginning of the dataset name up to the first point.

42
00:02:59.330 --> 00:03:04.099 
A point separates the qualifiers and

43
00:03:04.100 --> 00:03:08.599 
the first qualifier is called, the high level qualifier and

44
00:03:08.600 --> 00:03:13.849 
it has a strategic meaning for the catalog, means it controls

45
00:03:13.850 --> 00:03:18.649 
which catalog, I just mentioned user catalogs, in fact, which user catalog

46
00:03:18.650 --> 00:03:23.089 
is used. It affects the security,

47
00:03:23.090 --> 00:03:27.169 
means with the first qualifier you set the basic security

48
00:03:28.430 --> 00:03:32.929 
management for all data sets, beginning with such

49
00:03:32.930 --> 00:03:35.479 
a high level qualifier.

50
00:03:35.480 --> 00:03:40.099 
And we also control some parts of the

51
00:03:40.100 --> 00:03:43.879 
storage management. And we have a second

52
00:03:44.900 --> 00:03:49.279 
qualifier with a very special meaning, it's the last level qualifier.

53
00:03:49.280 --> 00:03:53.899 
It's the last part of the dataset name, and the last part in this case

54
00:03:53.900 --> 00:03:58.009 
has a strategic meaning for the storage management.

55
00:03:58.010 --> 00:04:03.109 
It's really important to know about the conventions

56
00:04:03.110 --> 00:04:07.729 
for such naming ideas so that, you know,

57
00:04:07.730 --> 00:04:12.379 
in each and every environment that it depends on

58
00:04:12.380 --> 00:04:16.518 
the customer sites. They can have different naming conventions.

59
00:04:16.519 --> 00:04:20.929 
But important, in fact, is that they have naming conventions and that the users

60
00:04:20.930 --> 00:04:25.399 
know this naming conventions and adhere to these

61
00:04:25.400 --> 00:04:30.199 
conventions. Now again, the first part of the

62
00:04:30.200 --> 00:04:33.529 
dataset name is the high level qualifier.

63
00:04:33.530 --> 00:04:38.479 
In our example, so this EMA1015,

64
00:04:38.480 --> 00:04:43.459 
this is the high level qualifier controlling catalog, controlling security, and

65
00:04:43.460 --> 00:04:46.039 
controlling part of storage management.

66
00:04:46.040 --> 00:04:51.139 
And the last is the last part in this case from the last

67
00:04:51.140 --> 00:04:53.899 
point up to the end of the dataset name.

68
00:04:53.900 --> 00:04:58.399 
This is the last level qualifier controlling the storage management and in

69
00:04:58.400 --> 00:05:02.989 
this case, just to mention it, if you have it in as in this

70
00:05:02.990 --> 00:05:07.519 
example, CNTL, it stands for Control,

71
00:05:07.520 --> 00:05:11.989 
and it means in many installations that this is a

72
00:05:11.990 --> 00:05:14.869 
data set for Job Control Language (JCL).

73
00:05:14.870 --> 00:05:19.369 
And it's really needed now for storage management, if you allocate a new

74
00:05:19.370 --> 00:05:23.959 
dataset you don't have to specify the logical records and so

75
00:05:23.960 --> 00:05:28.489 
on. It was very cumbersome in the past if you use

76
00:05:28.490 --> 00:05:33.079 
the naming conventions and with CNTL, it stated that it's for

77
00:05:33.080 --> 00:05:38.269 
Job control. So as in the examples the record length is 80 characters

78
00:05:38.270 --> 00:05:43.969 
and we use sensible, reasonable

79
00:05:43.970 --> 00:05:47.839 
default space allocation and so on.

80
00:05:47.840 --> 00:05:51.379 
So a lot of things are controlled with this last level qualifier.

81
00:05:53.010 --> 00:05:55.979 
Let's have a look on such a catalog structure.

82
00:05:55.980 --> 00:06:00.539 
We have a master catalog already mentioned and in

83
00:06:00.540 --> 00:06:05.669 
each and every z/OS environment, operating system, environment,

84
00:06:05.670 --> 00:06:10.619 
we have, in any case, a high level qualifier that is SYS1

85
00:06:10.620 --> 00:06:15.599 
and SYS1 isn't an alias for the user catalog,

86
00:06:15.600 --> 00:06:18.869 
it has to be and must be in the master catalog.

87
00:06:20.580 --> 00:06:24.202 
There are a lot of data sets beginning with SYS1, fir example,SYS1.PROCLIB,

88
00:06:26.070 --> 00:06:27.070 
SYS1.PARMLIB, SYS1.

89
00:06:28.140 --> 00:06:30.569 
something like page datasets and so on.

90
00:06:30.570 --> 00:06:35.189 
And these datasets have

91
00:06:35.190 --> 00:06:38.939 
be specified in the master catalog.

92
00:06:38.940 --> 00:06:41.299 
So we have a direct pointer from a dataset, SYS1.PARMLIB

93
00:06:43.470 --> 00:06:48.689 
as example onto a DAST in the catalog.

94
00:06:48.690 --> 00:06:53.729 
So it's really just the the dataset name and the pointer

95
00:06:53.730 --> 00:06:58.319 
to volume, volume is the label of a disk

96
00:06:58.320 --> 00:07:02.939 
or, as we say, in the mainframe environment of a DAST, a Direct Access

97
00:07:02.940 --> 00:07:07.649 
Storage Device. And on each and every running system, we

98
00:07:07.650 --> 00:07:12.899 
really can have only unique DAST volume labels.

99
00:07:12.900 --> 00:07:18.329 
So it's really unique if you specify

100
00:07:18.330 --> 00:07:21.182 
SYS1.PARMLIB is on DAST volume -

101
00:07:23.580 --> 00:07:28.589 
DAST01, then it's uniquely identified where the dataset recites.

102
00:07:28.590 --> 00:07:33.749 
And on the volume we have some more things to manage

103
00:07:33.750 --> 00:07:37.379 
these datasets, like volume table of contents.

104
00:07:37.380 --> 00:07:39.600 
On the dataset control blocks and so on.

105
00:07:40.800 --> 00:07:45.659 
We don't go into more detail here concerning these things.

106
00:07:45.660 --> 00:07:50.129 
Just to repeat we have in the master catalog, we have a

107
00:07:50.130 --> 00:07:54.689 
dataset name and volume name for

108
00:07:54.690 --> 00:07:59.639 
each and every dataset that is directly managed

109
00:07:59.640 --> 00:08:04.109 
via master catalog. For user datasets I already mentioned the high

110
00:08:04.110 --> 00:08:08.789 
level qualifier. Normally we have a high level qualifier identified

111
00:08:08.790 --> 00:08:11.459 
in the master catalog as a so-called alias defination.

112
00:08:11.460 --> 00:08:16.449 
Using an alias definition means we have connected with this definition

113
00:08:16.450 --> 00:08:18.779 
a user catalog and then

114
00:08:21.810 --> 00:08:26.399 
the datasets beginning with this high level qualifier,

115
00:08:26.400 --> 00:08:30.929 
there are some special cases where we can have more than one qualifier, it's

116
00:08:30.930 --> 00:08:35.819 
a special term, the multi level alias,

117
00:08:35.820 --> 00:08:40.348 
but it's not that important. I think just to say it here

118
00:08:41.400 --> 00:08:45.869 
with the basic idea, we have an high level qualifier, an alias

119
00:08:45.870 --> 00:08:48.809 
definition and a pointer to a user catalog.

120
00:08:48.810 --> 00:08:53.265 
And then each dataset beginning with this high level qualifier is

121
00:08:54.750 --> 00:08:57.629 
specified within the user catalog.

122
00:08:57.630 --> 00:09:02.579 
And then it's the same structures, we have just the dataset name and the volume name

123
00:09:02.580 --> 00:09:07.109 
and then we get to the volume, to the DAST, to the disk volume.

124
00:09:07.110 --> 00:09:11.879 
And again, it's controlled on the disk with Whittock and

125
00:09:11.880 --> 00:09:13.830 
DSAPs and so on.

126
00:09:15.810 --> 00:09:20.429 
This was the catalog structure as the

127
00:09:20.430 --> 00:09:25.109 
most important component or one of the most important components of data management.

128
00:09:25.110 --> 00:09:29.429 
If you have any questions remarks, please use the discussion form.

129
00:09:29.430 --> 00:09:33.959 
Thank you and see you on our next

130
00:09:33.960 --> 00:09:34.960 
video clip.
