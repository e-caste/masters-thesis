WEBVTT

1
00:00:00.689 --> 00:00:02.519 
Welcome to the introduction to the COBOL programing

2
00:00:02.520 --> 00:00:05.219 
language. My name is Phillip Brune from Neu-Ulm

3
00:00:05.220 --> 00:00:06.960 
University of Applied Sciences.

4
00:00:08.740 --> 00:00:11.349 
We have mentioned COBOL several times during this course

5
00:00:11.350 --> 00:00:14.499 
already, and COBOL plays a very important

6
00:00:14.500 --> 00:00:16.689 
role on the mainframe platform.

7
00:00:16.690 --> 00:00:18.999 
And as you can see from the history of higher programing

8
00:00:19.000 --> 00:00:21.879 
languages, COBOL is one of the earliest

9
00:00:21.880 --> 00:00:24.819 
higher programing languages originating even

10
00:00:24.820 --> 00:00:28.509 
from the 50s and then

11
00:00:28.510 --> 00:00:30.789 
standardized in the early 60s.

12
00:00:30.790 --> 00:00:32.189 
So it

13
00:00:34.180 --> 00:00:37.809 
has been even around before the first S/360

14
00:00:37.810 --> 00:00:39.579 
mainframe appeared.

15
00:00:39.580 --> 00:00:42.459 
And since then it has been an

16
00:00:42.460 --> 00:00:44.679 
important or the important language for business

17
00:00:44.680 --> 00:00:46.109 
application development.

18
00:00:46.110 --> 00:00:49.029 
And COBOL stands for Common

19
00:00:49.030 --> 00:00:50.559 
Business Oriented Language.

20
00:00:50.560 --> 00:00:53.529 
And it was designed from the beginning as a tool even

21
00:00:53.530 --> 00:00:56.409 
for business people to use computers and to do data

22
00:00:56.410 --> 00:00:58.659 
processing, business oriented data processing.

23
00:00:59.950 --> 00:01:02.830 
And up to today, it

24
00:01:04.690 --> 00:01:07.839 
remained an important language for writing business

25
00:01:07.840 --> 00:01:10.479 
applications because there have been so many

26
00:01:10.480 --> 00:01:13.419 
applications written in COBOL that are still running,

27
00:01:13.420 --> 00:01:16.509 
are still around, and COBOL

28
00:01:16.510 --> 00:01:19.449 
has some advantages. It's very, very optimized

29
00:01:19.450 --> 00:01:21.549 
for the processing of data,

30
00:01:22.750 --> 00:01:24.519 
very resource effective.

31
00:01:24.520 --> 00:01:27.459 
And therefore, there are some

32
00:01:27.460 --> 00:01:30.759 
reasons why COBOL is still a very important language.

33
00:01:30.760 --> 00:01:33.730 
One is, of course, that existing applications,

34
00:01:34.750 --> 00:01:37.089 
large amounts of money have been invested over the

35
00:01:37.090 --> 00:01:39.999 
decades, have to be continuously

36
00:01:40.000 --> 00:01:43.179 
further developed, sometimes re-engineered,

37
00:01:43.180 --> 00:01:45.699 
sometimes modernized, combined with more modern

38
00:01:45.700 --> 00:01:48.759 
technologies like Java or JavaScript and so on.

39
00:01:48.760 --> 00:01:51.879 
And on the other hand, there's even

40
00:01:51.880 --> 00:01:54.789 
a sometimes new development of

41
00:01:54.790 --> 00:01:58.000 
new applications that is done in COBOL.

42
00:01:59.430 --> 00:02:01.559 
COBOL, of course, is the typical business language that

43
00:02:01.560 --> 00:02:03.407 
in the modern architecture

44
00:02:04.410 --> 00:02:07.289 
is typically used for

45
00:02:07.290 --> 00:02:10.019 
the business logic or sometimes called Application Tier.

46
00:02:10.020 --> 00:02:11.020 
So it's on the

47
00:02:14.040 --> 00:02:15.040 
business logic level.

48
00:02:16.820 --> 00:02:19.729 
COBOL was first standardised in 1960

49
00:02:19.730 --> 00:02:21.070 
as the so-called COBOL-60

50
00:02:22.700 --> 00:02:26.089 
standard by the Conference on Data Systems Languages,

51
00:02:26.090 --> 00:02:29.059 
CODASYL, which is or was an initiative

52
00:02:29.060 --> 00:02:32.569 
of the American government to the US government to

53
00:02:32.570 --> 00:02:35.989 
standardize these languages.

54
00:02:35.990 --> 00:02:39.049 
Later on, the standardization was taken over by ANSI

55
00:02:39.050 --> 00:02:42.079 
and ISO. And nowadays it's an

56
00:02:42.080 --> 00:02:43.399 
ANSI ISO standard.

57
00:02:43.400 --> 00:02:46.699 
The standard has evolved and different releases

58
00:02:46.700 --> 00:02:48.829 
have been proposed.

59
00:02:48.830 --> 00:02:51.540 
So there is a standard version COBOL-74, COBOL-85

60
00:02:52.700 --> 00:02:57.289 
relating to the respective years and COBOL-2002,

61
00:02:57.290 --> 00:03:00.469 
which then also the COBOL-2002 version

62
00:03:00.470 --> 00:03:03.529 
contains an extension to make COBOL

63
00:03:03.530 --> 00:03:05.260 
also object oriented or OO-COBOL.

64
00:03:06.500 --> 00:03:10.039 
However, the compilers, especially on z/OS, typically

65
00:03:10.040 --> 00:03:12.049 
are based on the COBOL-85 standard.

66
00:03:12.050 --> 00:03:14.959 
So this is the non object oriented

67
00:03:14.960 --> 00:03:18.169 
version and that is the one that is most important

68
00:03:18.170 --> 00:03:20.089 
for development still.

69
00:03:21.970 --> 00:03:24.819 
On a mainframe, COBOL is typically used for the

70
00:03:24.820 --> 00:03:27.999 
two main classical purposes and tasks

71
00:03:28.000 --> 00:03:31.209 
that a mainframe does, namely transaction

72
00:03:31.210 --> 00:03:33.219 
processing applications and batch processing

73
00:03:33.220 --> 00:03:34.599 
applications.

74
00:03:34.600 --> 00:03:37.659 
So COBOL is used as part of transaction processing

75
00:03:37.660 --> 00:03:40.629 
monitors. We'll see that later in the chapter on the

76
00:03:40.630 --> 00:03:43.449 
transaction processing to write

77
00:03:43.450 --> 00:03:45.249 
transaction processing applications.

78
00:03:45.250 --> 00:03:48.729 
And that is used to write batch processing applications

79
00:03:48.730 --> 00:03:52.139 
that in the background process,

80
00:03:52.140 --> 00:03:54.149 
large volumes of data typically.

81
00:03:58.040 --> 00:04:00.979 
COBOL is a very old language, very early,

82
00:04:00.980 --> 00:04:04.249 
coming from the early times of computing, and therefore

83
00:04:05.360 --> 00:04:08.179 
it is a bit more

84
00:04:08.180 --> 00:04:11.269 
modern, is a bit strange to understand

85
00:04:11.270 --> 00:04:14.149 
that the structure of COBOL is still governed by the

86
00:04:14.150 --> 00:04:16.639 
original structure of a punch card.

87
00:04:17.769 --> 00:04:20.409 
And for beginners, this is something you'll have to get

88
00:04:20.410 --> 00:04:21.410 
used to.

89
00:04:22.150 --> 00:04:24.999 
In COBOL, every line of code is

90
00:04:25.000 --> 00:04:27.939 
following a strict structure regarding what

91
00:04:27.940 --> 00:04:30.159 
is allowed to write in which column.

92
00:04:30.160 --> 00:04:33.369 
And every line has maximum 80 characters

93
00:04:33.370 --> 00:04:36.639 
corresponding to the to the 80 characters

94
00:04:36.640 --> 00:04:39.069 
that fitted on a punch card.

95
00:04:39.070 --> 00:04:41.919 
And this corresponds in

96
00:04:41.920 --> 00:04:45.129 
z/OS to a dataset with record length 80

97
00:04:45.130 --> 00:04:48.220 
and blocked, so fixed blocked 80

98
00:04:49.360 --> 00:04:50.649 
characters record length.

99
00:04:52.470 --> 00:04:53.859 
The length structure is as follows.

100
00:04:53.860 --> 00:04:56.939 
So the first six columns are reserved

101
00:04:56.940 --> 00:04:59.549 
or not used, they can be used to put in a sequence

102
00:04:59.550 --> 00:05:02.339 
number, which is optional.

103
00:05:02.340 --> 00:05:03.989 
Then there is column 7.

104
00:05:03.990 --> 00:05:05.648 
You can see here this column 7,

105
00:05:06.960 --> 00:05:09.419 
which is a control column.

106
00:05:09.420 --> 00:05:12.449 
This can either contain nothing, then it's a normal

107
00:05:12.450 --> 00:05:15.539 
line of code. It can contain a star

108
00:05:15.540 --> 00:05:17.267 
that indicates that the rest of the line is a comment,

109
00:05:18.390 --> 00:05:21.329 
source code comment and it can contain,

110
00:05:21.330 --> 00:05:24.689 
alternatively, a minus sign, which indicates

111
00:05:24.690 --> 00:05:27.749 
a continuation line. So a line starting with a minus

112
00:05:27.750 --> 00:05:31.049 
sign in column 7 is a continuation

113
00:05:31.050 --> 00:05:32.050 
of the previous line.

114
00:05:33.000 --> 00:05:36.449 
The columns 8 to 11, so the first four columns

115
00:05:36.450 --> 00:05:39.599 
that are then actually a source code content

116
00:05:39.600 --> 00:05:41.219 
are called the A area.

117
00:05:41.220 --> 00:05:44.489 
And some statements have to start

118
00:05:44.490 --> 00:05:47.459 
have to begin in the A area, division statements,

119
00:05:47.460 --> 00:05:49.469 
procedure names and so on.

120
00:05:49.470 --> 00:05:53.279 
And the rest of the columns, 12 to 72

121
00:05:53.280 --> 00:05:56.009 
is called the B area, and it contains all the other

122
00:05:56.010 --> 00:05:57.494 
instructions and statements of COBOL.

123
00:05:58.740 --> 00:06:01.739 
Columns 73 to 82, so the last eight

124
00:06:01.740 --> 00:06:04.709 
columns are reserved again, and they may be used

125
00:06:04.710 --> 00:06:07.559 
by source code, version control systems, for example,

126
00:06:07.560 --> 00:06:10.439 
to store some markers or

127
00:06:10.440 --> 00:06:11.440 
texts in that.

128
00:06:12.180 --> 00:06:15.269 
So basically we can use for the extra code

129
00:06:15.270 --> 00:06:18.509 
the columns from 8 to 72.

130
00:06:21.200 --> 00:06:24.619 
And the COBOL compilers are, on

131
00:06:24.620 --> 00:06:26.009 
z/OS are rather strict about this.

132
00:06:26.010 --> 00:06:28.489 
There are also other COBOL compilers that are a bit more

133
00:06:28.490 --> 00:06:30.170 
loose regarding formatting,

134
00:06:31.370 --> 00:06:34.459 
maybe, for example, the GNU COBOL on Linux.

135
00:06:34.460 --> 00:06:37.420 
So in general, we should keep to that structure.

136
00:06:39.530 --> 00:06:42.409 
On the other side, the COBOL source code

137
00:06:42.410 --> 00:06:46.009 
is organized into divisions,

138
00:06:46.010 --> 00:06:48.909 
so now we look at the flow with

139
00:06:48.910 --> 00:06:51.939 
the syntax of the COBOL and

140
00:06:51.940 --> 00:06:54.999 
the COBOL code is organized in

141
00:06:55.000 --> 00:06:57.309 
maximum four divisions.

142
00:06:57.310 --> 00:06:59.739 
The general idea of COBOL syntax is to have

143
00:07:01.870 --> 00:07:03.069 
it look like English language.

144
00:07:03.070 --> 00:07:05.709 
That was the intention also of the inventors of the

145
00:07:05.710 --> 00:07:08.709 
language because they wanted to make it readable for

146
00:07:08.710 --> 00:07:09.969 
business people.

147
00:07:09.970 --> 00:07:12.969 
And this makes COBOL

148
00:07:12.970 --> 00:07:15.799 
a very textual language

149
00:07:15.800 --> 00:07:17.139 
with a lot of words.

150
00:07:17.140 --> 00:07:19.959 
And it also

151
00:07:19.960 --> 00:07:22.659 
follows the idea of being like an English text, like a

152
00:07:22.660 --> 00:07:25.299 
book chapter or something. So it has a structure

153
00:07:25.300 --> 00:07:26.529 
containing divisions.

154
00:07:26.530 --> 00:07:29.769 
And then these divisions are separated again into

155
00:07:29.770 --> 00:07:32.979 
sections and the sections are then

156
00:07:32.980 --> 00:07:34.239 
divided into paragraphs.

157
00:07:34.240 --> 00:07:37.419 
So like you would organize a document.

158
00:07:37.420 --> 00:07:40.779 
And the four main divisions are the identification

159
00:07:40.780 --> 00:07:43.839 
division, environment division, data division,

160
00:07:43.840 --> 00:07:45.069 
procedure division.

161
00:07:45.070 --> 00:07:48.039 
And the identification division, some metadata

162
00:07:48.040 --> 00:07:51.459 
of the program is given

163
00:07:51.460 --> 00:07:54.369 
important and mandatories only the so-called

164
00:07:54.370 --> 00:07:57.279 
Program-ID. It's the name of the program.

165
00:07:57.280 --> 00:08:00.369 
And it's then also used on z/OS as the member name

166
00:08:00.370 --> 00:08:02.709 
of the file or the binary.

167
00:08:04.150 --> 00:08:07.133 
The environment division, which actually describes,

168
00:08:08.970 --> 00:08:11.789 
for example, input output structures like

169
00:08:11.790 --> 00:08:14.069 
files that should be opened.

170
00:08:14.070 --> 00:08:16.949 
The data division, which describes the variables

171
00:08:16.950 --> 00:08:19.799 
and the data. So it is a division describing actually

172
00:08:19.800 --> 00:08:22.979 
to the storage and then the procedure division,

173
00:08:22.980 --> 00:08:26.369 
which contains the actual imperative statements, the

174
00:08:26.370 --> 00:08:28.040 
statements that process the data.

175
00:08:31.060 --> 00:08:33.989 
The business statements always start in the A area

176
00:08:33.990 --> 00:08:36.899 
and they are terminated by

177
00:08:36.900 --> 00:08:40.139 
a dot in general, all elements

178
00:08:40.140 --> 00:08:41.798 
of the language are terminated by a dot.

179
00:08:41.799 --> 00:08:44.999 
So the dot is similar to

180
00:08:45.000 --> 00:08:47.070 
the semicolon in C or Java.

181
00:08:48.180 --> 00:08:51.059 
And again, a dot at the end is like in

182
00:08:51.060 --> 00:08:53.549 
the natural language that a sentence is also terminated

183
00:08:53.550 --> 00:08:54.550 
with a dot.

184
00:08:56.280 --> 00:08:58.769 
On the right hand side, you see a simple example program

185
00:08:58.770 --> 00:09:01.439 
that illustrates this. So it's a program that calculates

186
00:09:01.440 --> 00:09:04.079 
basically an interest rate.

187
00:09:04.080 --> 00:09:07.019 
And you see the identification division with the program

188
00:09:07.020 --> 00:09:09.869 
and the interest rate, the data division

189
00:09:09.870 --> 00:09:12.209 
containing the working storage section.

190
00:09:12.210 --> 00:09:13.949 
Here, the variables are defined.

191
00:09:13.950 --> 00:09:17.399 
So in the data division, there's most important typical

192
00:09:17.400 --> 00:09:19.829 
section is the working storage section, which describes

193
00:09:19.830 --> 00:09:23.009 
all the variables and then this procedure division.

194
00:09:23.010 --> 00:09:25.499 
And here is the actual instructions.

195
00:09:25.500 --> 00:09:27.509 
And you see that the instructions themselves start in

196
00:09:27.510 --> 00:09:30.389 
the B area here. So here's the A area, and

197
00:09:30.390 --> 00:09:31.709 
this is the B area.

198
00:09:31.710 --> 00:09:35.249 
So we have the intention of our characters here.

199
00:09:35.250 --> 00:09:38.729 
And I marked the

200
00:09:38.730 --> 00:09:41.069 
data division with a gray background to distinguish the

201
00:09:41.070 --> 00:09:42.519 
different divisions.

202
00:09:42.520 --> 00:09:45.389 
OK, so this program basically does

203
00:09:45.390 --> 00:09:47.699 
the following, it displays, so this is a right

204
00:09:47.700 --> 00:09:50.819 
instruction. It displays an amount or text

205
00:09:50.820 --> 00:09:53.969 
on the screen that the user should enter the amount it

206
00:09:53.970 --> 00:09:55.199 
displays.

207
00:09:55.200 --> 00:09:58.409 
It asks for duration and the user needs to give

208
00:09:58.410 --> 00:10:00.869 
or enter the duration. Accept statements, reads the

209
00:10:00.870 --> 00:10:04.079 
input of the user from the console, that part.

210
00:10:04.080 --> 00:10:07.022 
And then there's a loop that it can

211
00:10:07.023 --> 00:10:09.827 
perform. So the loop runs for the number of years and

212
00:10:11.920 --> 00:10:14.889 
adds the interest rate

213
00:10:14.890 --> 00:10:17.949 
on the amount and at the end displays

214
00:10:17.950 --> 00:10:21.219 
what amount the user has after some years of

215
00:10:21.220 --> 00:10:22.590 
investment. OK.

216
00:10:26.140 --> 00:10:27.739 
Let's have a closer look on variables.

217
00:10:27.740 --> 00:10:30.049 
So the first thing that we see also on the program on

218
00:10:30.050 --> 00:10:33.799 
the previous slide is that all the variables are

219
00:10:33.800 --> 00:10:36.859 
declared in the data division,

220
00:10:36.860 --> 00:10:39.829 
and this means that are only global variables.

221
00:10:39.830 --> 00:10:42.889 
COBOL does not have the idea of local variables

222
00:10:42.890 --> 00:10:45.839 
and no parameters and things like that.

223
00:10:45.840 --> 00:10:48.899 
So the only way of structuring a global

224
00:10:48.900 --> 00:10:52.009 
program is to have some sections and paragraphs

225
00:10:52.010 --> 00:10:54.469 
in the procedure division that can be jumped to.

226
00:10:54.470 --> 00:10:57.129 
So it's like a jump mark, jump label, but not

227
00:10:58.340 --> 00:11:01.249 
a real procedure with the local storage stack

228
00:11:01.250 --> 00:11:02.980 
or recursion is also not possible.

229
00:11:04.640 --> 00:11:07.969 
And the data division contains

230
00:11:07.970 --> 00:11:09.739 
of all the variable definitions or variable

231
00:11:09.740 --> 00:11:11.179 
declarations.

232
00:11:11.180 --> 00:11:14.059 
In the working storage section, we have the

233
00:11:14.060 --> 00:11:16.789 
normal variables that are global variables for program

234
00:11:16.790 --> 00:11:19.589 
execution. And you see that this is

235
00:11:19.590 --> 00:11:22.399 
a simple example showing some different type

236
00:11:22.400 --> 00:11:23.400 
of variables.

237
00:11:24.260 --> 00:11:26.329 
This one is an elementary variable.

238
00:11:26.330 --> 00:11:28.549 
It's started with 77.

239
00:11:28.550 --> 00:11:31.459 
So every variable declaration starts

240
00:11:31.460 --> 00:11:34.279 
with a number that is sort of a level indicator.

241
00:11:34.280 --> 00:11:37.279 
And for the top level

242
00:11:37.280 --> 00:11:40.498 
variables, this level indicator has to be given in the A

243
00:11:40.499 --> 00:11:43.249 
area where the name of the variable and all the rest

244
00:11:43.250 --> 00:11:44.839 
then is in the B area.

245
00:11:44.840 --> 00:11:46.039 
OK.

246
00:11:46.040 --> 00:11:48.889 
And if

247
00:11:48.890 --> 00:11:51.439 
a variable on the top level starts at 77, it's an

248
00:11:51.440 --> 00:11:52.999 
elementary value.

249
00:11:53.000 --> 00:11:55.019 
And if it starts with a number of

250
00:11:56.270 --> 00:11:59.449 
1 or higher, then it's a record structure

251
00:11:59.450 --> 00:12:02.269 
and the substructure of this record then starts always

252
00:12:02.270 --> 00:12:03.469 
in the B area.

253
00:12:03.470 --> 00:12:06.829 
So there is a level from 1 to

254
00:12:06.830 --> 00:12:09.799 
45 at maximum indicating the

255
00:12:09.800 --> 00:12:11.539 
intention or the level of

256
00:12:13.460 --> 00:12:16.219 
the hierarchical structure.

257
00:12:16.220 --> 00:12:20.029 
And this allows to specify

258
00:12:20.030 --> 00:12:22.219 
data records with the hierarchical structure, which is

259
00:12:22.220 --> 00:12:23.989 
very important for business applications.

260
00:12:23.990 --> 00:12:26.239 
For example, just think of a customer record as in this

261
00:12:26.240 --> 00:12:29.149 
example, customer, customer number, name, a part

262
00:12:29.150 --> 00:12:32.029 
of the customer records. OK, so this can be compared

263
00:12:32.030 --> 00:12:34.489 
to struct in C, for example.

264
00:12:34.490 --> 00:12:37.669 
And you see that the second number already is 5 here.

265
00:12:37.670 --> 00:12:40.939 
Of course it could be also 02, but usually one

266
00:12:40.940 --> 00:12:43.549 
makes a larger step. So it's easier to insert later if

267
00:12:43.550 --> 00:12:44.989 
you modify something another.

268
00:12:44.990 --> 00:12:45.990 
Another level.

269
00:12:50.210 --> 00:12:52.850 
Importance is also how the variable is declared, so

270
00:12:54.600 --> 00:12:56.419 
CUSTREC is the structure, but then we have 2 inside the

271
00:12:56.420 --> 00:12:59.329 
structure of two elementary variables and they are

272
00:12:59.330 --> 00:13:02.149 
declared like all variables with the so-called

273
00:13:02.150 --> 00:13:04.339 
PIC class, a picture clause.

274
00:13:04.340 --> 00:13:06.679 
The picture clause specifies the data type.

275
00:13:06.680 --> 00:13:08.299 
So this is the name of the variable.

276
00:13:08.300 --> 00:13:11.179 
This is the picture clause specifying the data type and

277
00:13:11.180 --> 00:13:14.329 
the data type is specified not like

278
00:13:14.330 --> 00:13:17.239 
int or double or something, but it is specified in a

279
00:13:17.240 --> 00:13:19.669 
picture way.

280
00:13:19.670 --> 00:13:22.519 
So you basically describe how the field should

281
00:13:22.520 --> 00:13:26.149 
actually look like. And see, for example,

282
00:13:26.150 --> 00:13:29.239 
this is a field that has four

283
00:13:29.240 --> 00:13:32.208 
digits and the one with the X is 40

284
00:13:32.209 --> 00:13:33.209 
characters, for example.

285
00:13:34.970 --> 00:13:37.849 
So the picture clause defines the type and the format of

286
00:13:37.850 --> 00:13:40.669 
the value, the length of the value and the numerical

287
00:13:40.670 --> 00:13:41.989 
accuracy.

288
00:13:41.990 --> 00:13:44.369 
And this is mapped usually internally using BCD

289
00:13:46.378 --> 00:13:48.349 
arithmetic. Syntax is like this. So it starts with the

290
00:13:48.350 --> 00:13:49.699 
variable name.

291
00:13:49.700 --> 00:13:51.769 
Then there's the key word pick.

292
00:13:51.770 --> 00:13:53.359 
And then there's the symbol.

293
00:13:53.360 --> 00:13:56.299 
And the symbol indicates sort of the type and

294
00:13:56.300 --> 00:13:58.219 
the length and the number of elements.

295
00:13:58.220 --> 00:14:01.969 
And then we have some additional switches here

296
00:14:01.970 --> 00:14:04.919 
to achieve, for example, binary,

297
00:14:04.920 --> 00:14:05.920 
not BCD arithmetic.

298
00:14:06.530 --> 00:14:09.229 
And then we have the option of the value which allow us

299
00:14:09.230 --> 00:14:11.119 
to provide an initial value.

300
00:14:11.120 --> 00:14:13.939 
And then we can also specify arrays.

301
00:14:13.940 --> 00:14:16.609 
Everything is always a fixed length and this is done

302
00:14:16.610 --> 00:14:19.429 
using the OCCURS keyword, occurs

303
00:14:19.430 --> 00:14:23.119 
and then times, says how many elements

304
00:14:23.120 --> 00:14:25.249 
this variable represents is an array.

305
00:14:25.250 --> 00:14:28.279 
OK, for symbol, for the type

306
00:14:28.280 --> 00:14:31.669 
that different options have seen already, X is

307
00:14:31.670 --> 00:14:34.819 
alphanumeric characters, 9 is for

308
00:14:34.820 --> 00:14:36.979 
possibly digits for BCD numbers, for example.

309
00:14:36.980 --> 00:14:40.039 
S indicates a sign inside this

310
00:14:40.040 --> 00:14:43.240 
format string and the V indicates the decimal separator.

311
00:14:46.970 --> 00:14:49.849 
Regarding the statements of COBOL, these are some

312
00:14:49.850 --> 00:14:51.499 
elementary imperative statements.

313
00:14:52.760 --> 00:14:55.349 
ADD statement adds, the MOVE statements is the value

314
00:14:55.350 --> 00:14:58.030 
assignment that moves the value from one variable to

315
00:14:58.031 --> 00:15:01.429 
another one or a value inside of a variable, the

316
00:15:01.430 --> 00:15:02.719 
INSPECT is for string.

317
00:15:02.720 --> 00:15:05.239 
We have seen DISPLAY and ACCEPT, this is input-output on

318
00:15:05.240 --> 00:15:08.149 
the screen. We have WRITE and READ that is for writing,

319
00:15:08.150 --> 00:15:10.549 
reading from a file, from a data set.

320
00:15:10.550 --> 00:15:13.609 
CLOSE and OPEN for accessing, opening, closing

321
00:15:13.610 --> 00:15:16.380 
a file. And at the end of the program there is a STOP

322
00:15:16.381 --> 00:15:19.579 
RUN command that terminates the actual program

323
00:15:19.580 --> 00:15:22.639 
execution. So these are the some common typical

324
00:15:22.640 --> 00:15:24.769 
elementary commands statements.

325
00:15:24.770 --> 00:15:27.169 
And this is then, of course, we have control structures

326
00:15:27.170 --> 00:15:29.899 
as well in COBOL. We need the usual conditional

327
00:15:29.900 --> 00:15:31.309 
statement and the loops.

328
00:15:31.310 --> 00:15:34.399 
And regarding the conditional statements, we have

329
00:15:34.400 --> 00:15:37.383 
the typical IF, THEN, ELSE

330
00:15:37.384 --> 00:15:39.169 
statement. And you see that all the control structures,

331
00:15:39.170 --> 00:15:41.029 
the block structure of the control structures is

332
00:15:41.030 --> 00:15:44.149 
terminated by an END-IF or

333
00:15:44.150 --> 00:15:47.209 
the EVALUATE statement is like the switch case in C,

334
00:15:47.210 --> 00:15:49.429 
its the multiple conditions.

335
00:15:50.840 --> 00:15:52.780 
EVALUATE and END-EVALUATE and

336
00:15:54.950 --> 00:15:57.743 
here for the loops, all loops are indicated by

337
00:15:57.744 --> 00:15:59.929 
PERFORM. So PERFORM, the keyword PERFORM can do

338
00:15:59.930 --> 00:16:02.329 
different things in COBOL. Either it is a call of a

339
00:16:02.330 --> 00:16:05.209 
paragraph and jump of a subroutine to

340
00:16:05.210 --> 00:16:08.749 
a subroutine or it is a loop

341
00:16:08.750 --> 00:16:11.549 
and the different loops all started

342
00:16:11.550 --> 00:16:14.479 
to perform. It's a bit different from modern languages.

343
00:16:14.480 --> 00:16:16.970 
So for example, this is the counting loop "

344
00:16:18.140 --> 00:16:19.839 
PERFORM (n) TIMES" and this is the conditional loop,

345
00:16:21.710 --> 00:16:23.209 
PERFORM [WITH TEST BEFORE | AFTER]. This would

346
00:16:23.210 --> 00:16:26.149 
distinguish the while or the do-while loop

347
00:16:26.150 --> 00:16:28.339 
and with the condition here.

348
00:16:28.340 --> 00:16:30.629 
OK, so that is the syntax.

349
00:16:30.630 --> 00:16:33.139 
One important thing is that it's always confusing for

350
00:16:33.140 --> 00:16:34.140 
beginners.

351
00:16:35.090 --> 00:16:38.029 
The DOT terminates a statement, as

352
00:16:38.030 --> 00:16:40.639 
in a natural language, we learnt that already, but

353
00:16:40.640 --> 00:16:43.519 
inside a block, for example, if you would have

354
00:16:43.520 --> 00:16:46.339 
a hierarchical embedding of one control structure and

355
00:16:46.340 --> 00:16:49.849 
another one inside the outermost control structure,

356
00:16:49.850 --> 00:16:51.829 
you do not put any dots any more.

357
00:16:51.830 --> 00:16:55.279 
And this is different, for example, from

358
00:16:55.280 --> 00:16:58.369 
C or Java, where you put the semicolon inside

359
00:16:58.370 --> 00:16:59.419 
in a blocks as well.

360
00:17:00.500 --> 00:17:03.349 
OK, so this was a short overview on the features

361
00:17:03.350 --> 00:17:06.199 
of COBOL and we will come back to that when we have

362
00:17:06.200 --> 00:17:09.078 
a look on transaction processing later where we

363
00:17:09.079 --> 00:17:12.289 
see how COBOL is used in the context of a transaction

364
00:17:12.290 --> 00:17:14.088 
processing monitor.

365
00:17:14.089 --> 00:17:15.089 
Thank you.
