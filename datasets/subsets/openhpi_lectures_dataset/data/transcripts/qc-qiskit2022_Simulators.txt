WEBVTT

1
00:00:00.040 --> 00:00:03.940 
Welome back everyone! In this video we will learn about

2
00:00:03.940 --> 00:00:07.290 
how to use the simulators in the Qiskit module

3
00:00:07.910 --> 00:00:11.390 
and the different things that you can actually do with them.

4
00:00:11.900 --> 00:00:14.180 
So, let's go back to the quantum lab

5
00:00:16.120 --> 00:00:20.460 
and in this case we will be using the file simulators.

6
00:00:21.750 --> 00:00:26.020 
So, first of all as usual we will import our credentials

7
00:00:27.570 --> 00:00:34.300 
in the module where all the backends are contained, including the simulators.

8
00:00:34.890 --> 00:00:39.490 
Even if now we're only going to be focusing on simulators.

9
00:00:41.360 --> 00:00:46.140 
So, we print the list of providers that we have available in

10
00:00:46.140 --> 00:00:49.810 
our case, in my case and your case it will only be

11
00:00:50.620 --> 00:00:53.810 
the open group and the main project.

12
00:00:55.520 --> 00:00:58.430 
Now, we're going to also import

13
00:00:59.470 --> 00:01:01.110 
a couple of things that we need.

14
00:01:02.070 --> 00:01:08.710 
So, Numpy library, QuantumCircuit, Aer, that is the main

15
00:01:09.790 --> 00:01:12.110 
the main model we will be looking at right now.

16
00:01:12.640 --> 00:01:17.250 
Then some other little things that we will be

17
00:01:17.250 --> 00:01:22.780 
using but I will explain it. And now let's focus on what it's contained in.

18
00:01:23.390 --> 00:01:26.950 
So, what do the backends contain in these Aer modules.

19
00:01:27.870 --> 00:01:29.500 
First, we will be using them

20
00:01:30.180 --> 00:01:32.750 
in the cloud and then we will also check

21
00:01:33.790 --> 00:01:35.410 
an option to install it locally.

22
00:01:37.010 --> 00:01:41.950 
So, as you see we have a general simulator which is called Aer simulator.

23
00:01:42.680 --> 00:01:47.710 
We also have the Aer simulator state vector, Aer simulator density

24
00:01:47.710 --> 00:01:52.020 
matrix, these are simulation methods that we will understand

25
00:01:52.020 --> 00:01:53.380 
a little bit later what they mean.

26
00:01:54.280 --> 00:01:57.100 
Then we have a simulator is called Unitary.

27
00:01:58.640 --> 00:02:02.610 
We have the Qasm simulator, that is the simulator that we have been using

28
00:02:03.020 --> 00:02:07.740 
and we have the other three simulators: state vector, unitary

29
00:02:07.740 --> 00:02:09.190 
simulator and pulse simulator.

30
00:02:09.850 --> 00:02:15.430 
So, today we will be focusing on how to use the general simulator

31
00:02:15.430 --> 00:02:19.880 
and what to do to the circuit so that one or another are selected.

32
00:02:20.690 --> 00:02:23.400 
The simulation methods, we will just mention them because they

33
00:02:23.400 --> 00:02:28.380 
are out of the scope of this course, but it's also useful for

34
00:02:28.380 --> 00:02:29.440 
you to know they are there.

35
00:02:30.640 --> 00:02:33.570 
As well we will also use the

36
00:02:35.150 --> 00:02:36.940 
three simulators that you can see here.

37
00:02:38.410 --> 00:02:41.610 
We will not be touching the Pulse simulator because this is

38
00:02:41.610 --> 00:02:45.860 
something specific to work at the level of Pulses. So, it's interesting

39
00:02:46.530 --> 00:02:49.840 
for users that work closer to the hardware.

40
00:02:50.790 --> 00:02:53.810 
So, yes for you to know that these are all the

41
00:02:54.540 --> 00:03:00.040 
available tools. So, first we will select a general

42
00:03:00.610 --> 00:03:05.420 
backend in the Aer simulator and now depending on what we do

43
00:03:05.420 --> 00:03:11.500 
to our circuit, it will select automatically one of these four simulators,

44
00:03:11.820 --> 00:03:14.060 
the Qasm, the state vector, the unitary, or the pulse.

45
00:03:16.350 --> 00:03:20.120 
So, let's go back to our example

46
00:03:20.990 --> 00:03:24.960 
which is the circuit

47
00:03:25.620 --> 00:03:29.630 
with a Hadamard and a CNOT gate and some measurements for all the q bits.

48
00:03:30.360 --> 00:03:32.070 
We're gonna transpile it.

49
00:03:32.960 --> 00:03:38.670 
This has appeared already in some other videos, you will understand better in the

50
00:03:39.750 --> 00:03:40.460 
real backend

51
00:03:42.060 --> 00:03:48.520 
exÃ©cution video. What this means is basically it kind of translates the circuit

52
00:03:48.710 --> 00:03:52.590 
to another circuit that can be understood by the concrete backend.

53
00:03:53.520 --> 00:03:57.630 
So, now our backend is the simulator that we defined earlier

54
00:03:58.080 --> 00:04:00.330 
and we do the same as before.

55
00:04:01.110 --> 00:04:07.120 
For this backend we use the method run, we say which circuit it should run.

56
00:04:07.320 --> 00:04:10.300 
By default we are not selecting any shots,

57
00:04:11.010 --> 00:04:12.410 
the number of shots, but we could.

58
00:04:13.140 --> 00:04:16.650 
We're storing the result and getting the count's dictionary

59
00:04:20.750 --> 00:04:23.900 
Another thing that might be interesting for us

60
00:04:23.910 --> 00:04:29.120 
could be to store each of the result in each of the shots. So,

61
00:04:29.500 --> 00:04:31.950 
let's do that for a small number of shots.

62
00:04:32.450 --> 00:04:36.700 
Then output what we call memory, instead of getting the counts

63
00:04:36.700 --> 00:04:42.650 
we will get the memory and show what were the actual state

64
00:04:42.650 --> 00:04:46.440 
in each of the of the executions of our circuit.

65
00:04:48.550 --> 00:04:53.810 
So, in this case since we selected, we

66
00:04:53.810 --> 00:04:57.710 
created a circuit and what we use was the method run,

67
00:04:58.160 --> 00:05:04.410 
what was happening behind is that the Qasm simulator was automatically selected.

68
00:05:04.970 --> 00:05:08.410 
Why is that? It's because the Qasm simulator

69
00:05:08.410 --> 00:05:13.120 
is the one that behaves, mimics a real device and

70
00:05:13.560 --> 00:05:15.760 
what we were trying to do is execute a circuit.

71
00:05:16.210 --> 00:05:21.310 
So, it automatically understood that, that was the backend simulator needed.

72
00:05:22.900 --> 00:05:27.480 
So, what about the simulator methods? Here you have the syntaxes

73
00:05:27.770 --> 00:05:29.560 
on how to

74
00:05:30.280 --> 00:05:33.220 
to use each of them.

75
00:05:34.060 --> 00:05:35.890 
But basically

76
00:05:36.730 --> 00:05:42.020 
each of the simulation methods

77
00:05:42.030 --> 00:05:44.570 
supports a different set of instructions.

78
00:05:45.230 --> 00:05:51.120 
We can manually select the simulation

79
00:05:51.120 --> 00:05:58.010 
methods, as you gon see here or select it directly.

80
00:05:59.530 --> 00:06:05.350 
In this case, when to use one or the other,

81
00:06:05.860 --> 00:06:11.970 
what are the advantages or disadvantages depends on

82
00:06:12.710 --> 00:06:19.240 
our current experiments. So, this is a not a straightforward

83
00:06:19.280 --> 00:06:23.390 
answer, you have to know your experiment and you have to decide

84
00:06:23.590 --> 00:06:26.410 
which one will give you the optimal results.

85
00:06:28.520 --> 00:06:33.020 
So, in this case we're running the same example for three or

86
00:06:33.240 --> 00:06:35.350 
four different simulation methods.

87
00:06:36.060 --> 00:06:39.890 
And we're plotting all of them in a histogram.

88
00:06:43.710 --> 00:06:47.160 
An extra thing that we can do if you have

89
00:06:48.110 --> 00:06:52.710 
some device with a GPU available, it would be to

90
00:06:54.010 --> 00:06:57.940 
install locally a GPU,

91
00:06:58.680 --> 00:07:03.480 
a GPU version of the simulator.

92
00:07:04.150 --> 00:07:07.760 
So, you can install it in your device. So,

93
00:07:08.970 --> 00:07:13.050 
in this case I am not going to run

94
00:07:14.230 --> 00:07:16.590 
this code because

95
00:07:17.270 --> 00:07:20.280 
right now I don't have access to such a device, but yes for

96
00:07:20.280 --> 00:07:22.320 
you to keep in mind we could be using

97
00:07:22.940 --> 00:07:27.880 
the GPU version of the simulator that these optimize, so that the

98
00:07:28.560 --> 00:07:35.250 
instructions that happen during the simulation take advantage of the parallel

99
00:07:36.520 --> 00:07:38.890 
structure of the GPU.

100
00:07:39.610 --> 00:07:41.000 
And you have to install

101
00:07:42.320 --> 00:07:44.990 
an extra

102
00:07:45.640 --> 00:07:48.770 
library, which is Qiskit GPU,

103
00:07:50.530 --> 00:07:53.980 
but it is not complicated.

104
00:07:55.480 --> 00:07:59.880 
So, for instance you can maybe install it in a dead zone

105
00:08:00.590 --> 00:08:05.070 
or if you have a machine that has GPU's, that's also

106
00:08:05.510 --> 00:08:11.070 
an option. So, another thing that you can change when doing a simulation, it's

107
00:08:11.660 --> 00:08:15.700 
the Precision, so it could be double or single.

108
00:08:17.450 --> 00:08:20.060 
And see how that affects your results.

109
00:08:21.090 --> 00:08:26.370 
But until now we have been simulating perfect simulations,

110
00:08:26.750 --> 00:08:30.760 
so that means that we are not simulating the noise. So, a good

111
00:08:30.760 --> 00:08:34.430 
question to ask ourselves would be: Can we actually make a more

112
00:08:34.430 --> 00:08:39.710 
realistic simulation? Can we simulate noise? and the answer is yes,

113
00:08:39.840 --> 00:08:43.790 
there are different ways to do that. We can whether build

114
00:08:43.800 --> 00:08:47.590 
our own backend model, a noise model.

115
00:08:48.210 --> 00:08:54.440 
We can also mimic the

116
00:08:55.230 --> 00:08:57.950 
noise model from an actual device, build

117
00:08:58.650 --> 00:09:04.420 
a simulator with that or we can come up with our own noise models.

118
00:09:05.750 --> 00:09:09.640 
So, let's again import all libraries that we will need.

119
00:09:12.350 --> 00:09:15.990 
And lucky for us there is also a

120
00:09:17.330 --> 00:09:23.210 
Qiskit text mock library where we can import fake versions of the backends.

121
00:09:23.710 --> 00:09:26.510 
Here you see Vigo that is our backend that

122
00:09:26.920 --> 00:09:33.780 
is not operating anymore but we still have, we

123
00:09:34.470 --> 00:09:40.780 
can use its noise model. So, we have these fake devices that

124
00:09:41.030 --> 00:09:44.120 
contain a simplified version of their

125
00:09:44.650 --> 00:09:48.750 
noise model and we can use them as backends. So, let's see what

126
00:09:48.750 --> 00:09:52.330 
happens when we execute, for instance the 3GHZ

127
00:09:53.280 --> 00:09:58.700 
state first in an ideal simulation. So using the Qasm simulator

128
00:09:59.040 --> 00:10:00.830 
and now using

129
00:10:02.480 --> 00:10:04.610 
they noisy device.

130
00:10:05.840 --> 00:10:10.660 
So, let's print the new result and as you see it's quite different because

131
00:10:11.260 --> 00:10:15.640 
now we are not only getting the states that we are supposed to see, so

132
00:10:15.960 --> 00:10:18.800 
the idea of simulation will be more or less fifty fifty

133
00:10:19.300 --> 00:10:25.290 
the zero zero zero state and the one one one state, but right now we're seeing

134
00:10:25.720 --> 00:10:29.250 
some residual probabilities associated to all the other states.

135
00:10:29.860 --> 00:10:34.640 
Of course, when we interpret these results we can be aware that

136
00:10:35.750 --> 00:10:39.050 
it's the correct result, but we also,

137
00:10:40.250 --> 00:10:44.390 
we can also observe the presence of noise and this is a still being

138
00:10:44.590 --> 00:10:49.840 
a simulation. So this is a more realistic result

139
00:10:49.850 --> 00:10:53.270 
because this is what we will actually observe in one of the real devices.

140
00:10:56.980 --> 00:11:00.140 
The other two things that might be interesting for you is building

141
00:11:00.140 --> 00:11:03.190 
your own noise model, if you have the notes for that maybe you're

142
00:11:03.190 --> 00:11:06.880 
working in a correction. So, you can combine different types

143
00:11:06.880 --> 00:11:12.330 
of models to create your own noise model or applying noise directly to a

144
00:11:12.560 --> 00:11:17.140 
unitary gate. And i'll leave you the links there, so that you

145
00:11:17.140 --> 00:11:19.480 
can check that out and with that

146
00:11:20.100 --> 00:11:23.420 
we have finished the simulators section.

147
00:11:23.870 --> 00:11:27.190 
And in the next video we will have a look

148
00:11:27.850 --> 00:11:33.120 
into how to execute everything but in the actual real devices.

149
00:11:33.590 --> 00:11:37.080 
Thank you so much for watching and looking forward to the next video
