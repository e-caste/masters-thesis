WEBVTT

1
00:00:01.260 --> 00:00:04.259 
Welcome to the introduction to Web services

2
00:00:04.260 --> 00:00:05.879 
on the mainframe.

3
00:00:05.880 --> 00:00:08.519 
My name is Philip Brune from the Neu-Ulm University of

4
00:00:08.520 --> 00:00:09.520 
Applied Sciences.

5
00:00:10.640 --> 00:00:14.089 
Before we look on how Web services are

6
00:00:14.090 --> 00:00:17.449 
used and implemented on the mainframe

7
00:00:17.450 --> 00:00:20.449 
and on z/OS, first let us have a

8
00:00:20.450 --> 00:00:22.760 
look on what is a Web service in general.

9
00:00:24.020 --> 00:00:26.816 
We all have an idea what a service is.

10
00:00:28.550 --> 00:00:32.089 
Service is in general, in everyday life

11
00:00:32.090 --> 00:00:35.419 
is something where you ask

12
00:00:35.420 --> 00:00:38.869 
a person or institution or a company

13
00:00:38.870 --> 00:00:42.259 
to do something for you, where you just specify,

14
00:00:42.260 --> 00:00:45.639 
"OK, I want to have something done" and

15
00:00:45.640 --> 00:00:46.939 
there's a price for it.

16
00:00:46.940 --> 00:00:50.179 
And you do not have to know how the company

17
00:00:50.180 --> 00:00:53.149 
is doing that. For example, cleaning a house would

18
00:00:53.150 --> 00:00:56.149 
be a service and just specify, "OK, please clean the

19
00:00:56.150 --> 00:00:59.929 
house two times a week" and then

20
00:00:59.930 --> 00:01:02.929 
you expect that the house is clean and you do not have

21
00:01:02.930 --> 00:01:06.589 
to know which kind of cleaning material, for example,

22
00:01:06.590 --> 00:01:09.679 
the person uses or how the person actually

23
00:01:09.680 --> 00:01:12.959 
is doing that and just specify

24
00:01:12.960 --> 00:01:15.949 
quality of service for the result and you pay for it.

25
00:01:15.950 --> 00:01:19.009 
And that's basically similar what we

26
00:01:19.010 --> 00:01:22.189 
think of services in software engineering.

27
00:01:22.190 --> 00:01:24.589 
So the concept of service in software engineering means

28
00:01:24.590 --> 00:01:28.639 
that we have a software component that specifies

29
00:01:28.640 --> 00:01:32.959 
a certain scope and a certain functionality

30
00:01:32.960 --> 00:01:36.079 
and offers this for other components to

31
00:01:36.080 --> 00:01:37.080 
use it.

32
00:01:37.850 --> 00:01:40.249 
But the other components only have to know the interface

33
00:01:40.250 --> 00:01:42.799 
and they only have to know how to call the service and they

34
00:01:42.800 --> 00:01:45.799 
can call the service being

35
00:01:45.800 --> 00:01:48.799 
completely agnostic on how the service is actually doing

36
00:01:48.800 --> 00:01:51.829 
that, the service just needs to specify how it

37
00:01:51.830 --> 00:01:55.279 
is invoked and actually what it does so that the

38
00:01:55.280 --> 00:01:58.309 
functionality and of course maybe

39
00:01:58.310 --> 00:02:01.369 
quality attributes like availability and pricing

40
00:02:01.370 --> 00:02:04.489 
and so on. So a software component that is

41
00:02:04.490 --> 00:02:07.609 
encapsulated, that is self-contained and that

42
00:02:07.610 --> 00:02:10.999 
can be used from other programs or other components

43
00:02:11.000 --> 00:02:14.389 
without knowing anything about the internal implementation

44
00:02:14.390 --> 00:02:17.569 
and without knowing how

45
00:02:17.570 --> 00:02:19.130 
the services actually operate it.

46
00:02:20.300 --> 00:02:23.359 
And usually the

47
00:02:23.360 --> 00:02:27.649 
service should be sort of a meaningful, encapsulated

48
00:02:27.650 --> 00:02:31.549 
and self-contained business functionality

49
00:02:31.550 --> 00:02:34.609 
that has a well-defined external interface and that can

50
00:02:34.610 --> 00:02:37.759 
be called in a sort of platform neutral way.

51
00:02:37.760 --> 00:02:40.729 
Of course, such kind of service can be implemented with a

52
00:02:40.730 --> 00:02:44.389 
lot of different technologies and frameworks and languages,

53
00:02:44.390 --> 00:02:47.539 
and not all services are necessarily Web services.

54
00:02:47.540 --> 00:02:49.999 
So this is more like an architectural paradigm.

55
00:02:50.000 --> 00:02:52.679 
But many services are Web services.

56
00:02:52.680 --> 00:02:55.819 
We talk of a Web service when we have a service type

57
00:02:55.820 --> 00:02:59.089 
of component that is basically invoked or called

58
00:02:59.090 --> 00:03:01.099 
using "http".

59
00:03:01.100 --> 00:03:04.579 
HTTP, The Hypertext Transfer Protocol is the

60
00:03:04.580 --> 00:03:07.879 
basis of the World Wide Web. It's the protocol that is used

61
00:03:07.880 --> 00:03:11.239 
to read and write HTML pages

62
00:03:11.240 --> 00:03:13.159 
and it's very common.

63
00:03:13.160 --> 00:03:16.189 
Everyone uses it every day when we browse the Internet.

64
00:03:16.190 --> 00:03:19.519 
So when HTTP is used

65
00:03:19.520 --> 00:03:22.739 
to communicate between a caller

66
00:03:22.740 --> 00:03:25.649 
and the service component, then it's basically a Web

67
00:03:25.650 --> 00:03:26.650 
service.

68
00:03:27.690 --> 00:03:30.444 
And usually Web services

69
00:03:33.500 --> 00:03:36.469 
are invoked by other programs, so the idea

70
00:03:36.470 --> 00:03:39.679 
is not to have a webpage that is read by an end user and

71
00:03:39.680 --> 00:03:43.279 
browsed by some Web browser, but it's

72
00:03:43.280 --> 00:03:46.309 
using HTTP for communication between

73
00:03:46.310 --> 00:03:50.269 
parts of an application between components and

74
00:03:50.270 --> 00:03:52.729 
program to program communication.

75
00:03:52.730 --> 00:03:55.759 
And this also, of course, means that the data that

76
00:03:55.760 --> 00:03:58.579 
Web service sends is usually not HTML or something, but

77
00:03:58.580 --> 00:04:01.008 
it's something else. For example, JSON or XML, typically

78
00:04:02.660 --> 00:04:05.779 
text based formats for data exchange

79
00:04:05.780 --> 00:04:06.780 
between programs.

80
00:04:08.120 --> 00:04:11.299 
So this is the general idea of a Web service.

81
00:04:11.300 --> 00:04:14.719 
And in recent years there's also a new

82
00:04:14.720 --> 00:04:17.838 
word around that is

83
00:04:17.839 --> 00:04:21.018 
micro services, which extends this pattern

84
00:04:21.019 --> 00:04:24.409 
or this concept of a service a little bit to

85
00:04:24.410 --> 00:04:27.469 
having services

86
00:04:27.470 --> 00:04:30.559 
that are not only a software component,

87
00:04:30.560 --> 00:04:34.099 
but a micro service is a service component

88
00:04:34.100 --> 00:04:37.099 
that is developed, maintained and run

89
00:04:37.100 --> 00:04:40.339 
by one integral team of developers

90
00:04:40.340 --> 00:04:43.309 
and operators. And they have the complete

91
00:04:43.310 --> 00:04:46.999 
responsibility for providing the service and

92
00:04:47.000 --> 00:04:48.799 
the services should not to be too big.

93
00:04:48.800 --> 00:04:51.949 
So micro service means that a team

94
00:04:51.950 --> 00:04:55.099 
that can be fed with two pizzas and two pizza team is able

95
00:04:55.100 --> 00:04:58.069 
to operate, maintain and

96
00:04:58.070 --> 00:05:00.440 
completely provide a service.

97
00:05:02.920 --> 00:05:05.979 
So it's a rather small thing, and

98
00:05:05.980 --> 00:05:09.129 
the uses of such a service do not know

99
00:05:09.130 --> 00:05:11.769 
or do not have to know anything about languages and tools

100
00:05:11.770 --> 00:05:15.309 
used in. So micro service extends the idea

101
00:05:15.310 --> 00:05:18.249 
in an agile manner to operation.

102
00:05:19.790 --> 00:05:22.489 
To better understand the concept of web service at this

103
00:05:22.490 --> 00:05:25.639 
slide, we see the conceptual architecture of

104
00:05:25.640 --> 00:05:29.719 
every Web service system or Web service software,

105
00:05:29.720 --> 00:05:32.689 
so we have usually a client, we can have many

106
00:05:32.690 --> 00:05:35.779 
clients. Clients are programs use the service

107
00:05:35.780 --> 00:05:39.139 
to consume its functionality and

108
00:05:39.140 --> 00:05:41.689 
we have the Web service implementation.

109
00:05:41.690 --> 00:05:45.319 
And since the communication is handled using HTTP

110
00:05:45.320 --> 00:05:48.589 
protocol, of course, the service needs to run inside

111
00:05:48.590 --> 00:05:51.469 
some kind of Web server, web application server.

112
00:05:51.470 --> 00:05:54.559 
And inside the web application server we

113
00:05:54.560 --> 00:05:57.769 
have sort of the service container

114
00:05:57.770 --> 00:06:01.319 
functionality which actually implements the

115
00:06:01.320 --> 00:06:03.739 
environment for writing services.

116
00:06:03.740 --> 00:06:07.279 
And inside that we have then the service implementations.

117
00:06:07.280 --> 00:06:10.489 
If we would do this with Java and Java EE, for example,

118
00:06:10.490 --> 00:06:14.149 
there's a standard called JAX arrays or JAX WS,

119
00:06:14.150 --> 00:06:15.829 
for implementing Web services.

120
00:06:15.830 --> 00:06:18.319 
And the Web service could be, for example, an enterprise

121
00:06:18.320 --> 00:06:21.319 
Java Bean that has exposed its interface

122
00:06:21.320 --> 00:06:24.859 
as a Web service interface.

123
00:06:24.860 --> 00:06:28.220 
And the client now can send calls to the server

124
00:06:29.600 --> 00:06:32.059 
via HTTP, for example.

125
00:06:32.060 --> 00:06:35.036 
It was the XML or JSON

126
00:06:35.037 --> 00:06:37.789 
notation, depending on the technology and the frameworks

127
00:06:37.790 --> 00:06:40.879 
used. For implementing Web services, there

128
00:06:40.880 --> 00:06:43.549 
are different standards.

129
00:06:43.550 --> 00:06:47.209 
They have evolved to different standards and concepts.

130
00:06:47.210 --> 00:06:50.389 
And I tried to just outline the most important

131
00:06:50.390 --> 00:06:53.599 
ones. So we have all the words that are frequently

132
00:06:53.600 --> 00:06:56.629 
used in the context of implementing Web services

133
00:06:56.630 --> 00:06:59.869 
on the mainframe and on other platforms, of course.

134
00:06:59.870 --> 00:07:03.109 
So the basic distinction of

135
00:07:03.110 --> 00:07:06.169 
Web service are or is between

136
00:07:06.170 --> 00:07:07.999 
RESTful Web services and

137
00:07:09.230 --> 00:07:10.909 
SOAP Web services.

138
00:07:10.910 --> 00:07:14.659 
SOAP is a standard specification

139
00:07:14.660 --> 00:07:17.749 
that describes

140
00:07:17.750 --> 00:07:21.949 
the way how a Web service is invoked

141
00:07:21.950 --> 00:07:25.009 
and SOAP is sort of heavyweight

142
00:07:25.010 --> 00:07:28.639 
protocol specifying a set of XML

143
00:07:30.050 --> 00:07:33.349 
document types that form their request and response

144
00:07:33.350 --> 00:07:36.319 
messages to call and receive the

145
00:07:36.320 --> 00:07:38.910 
results of the service and

146
00:07:39.960 --> 00:07:43.039 
originally SOAP stood for Simple Object

147
00:07:43.040 --> 00:07:44.419 
Access Protocol.

148
00:07:44.420 --> 00:07:46.889 
But it's neither object oriented nor simple.

149
00:07:46.890 --> 00:07:49.999 
So the acronym resolution

150
00:07:50.000 --> 00:07:53.029 
officially was dropped and now we just call it SOAP.

151
00:07:53.030 --> 00:07:56.569 
And the other type of Web service,

152
00:07:56.570 --> 00:07:59.119 
which is very common and very popular in the Internet

153
00:07:59.120 --> 00:08:03.229 
world, in the web world, are REST or RESTful Web Services.

154
00:08:03.230 --> 00:08:06.559 
REST is an acronym for Representation and State Transfer,

155
00:08:06.560 --> 00:08:08.569 
and it is basically the idea.

156
00:08:08.570 --> 00:08:10.459 
It's not a standard, it's not a specification.

157
00:08:10.460 --> 00:08:12.889 
It's more like a paradigm or a concept.

158
00:08:12.890 --> 00:08:16.339 
And basically the idea is to map

159
00:08:16.340 --> 00:08:19.399 
the different operations that Web servers can offers

160
00:08:19.400 --> 00:08:22.759 
and can be executed to the

161
00:08:22.760 --> 00:08:24.409 
HTTP request types.

162
00:08:24.410 --> 00:08:26.719 
So get, put, messages and so on.

163
00:08:26.720 --> 00:08:29.390 
And the corresponding URI

164
00:08:30.860 --> 00:08:33.199 
elements that I use to call the service.

165
00:08:33.200 --> 00:08:36.619 
So there's a sort of a scheme that is typically used

166
00:08:36.620 --> 00:08:40.249 
to transform a call into a

167
00:08:40.250 --> 00:08:41.250 
Web request.

168
00:08:42.350 --> 00:08:45.769 
Since it's not standardized, it's not completely

169
00:08:45.770 --> 00:08:47.269 
the same for all implementations.

170
00:08:47.270 --> 00:08:49.099 
So it's more like an idea that you have to know and

171
00:08:49.100 --> 00:08:52.309 
understand. But the details always depend

172
00:08:52.310 --> 00:08:54.499 
on the actual service that you use.

173
00:08:54.500 --> 00:08:57.709 
But it's very, very lightweight and very common to be used

174
00:08:57.710 --> 00:08:58.969 
in the Internet.

175
00:08:58.970 --> 00:09:02.089 
And so most Web services today are

176
00:09:02.090 --> 00:09:03.649 
RESTful Web services.

177
00:09:03.650 --> 00:09:06.739 
SOAP is more used in corporate environments

178
00:09:06.740 --> 00:09:09.799 
and enterprise technology coupling,

179
00:09:09.800 --> 00:09:12.889 
for example, a different business application to another.

180
00:09:14.000 --> 00:09:17.719 
In the context of SOAP, a set of additional standards

181
00:09:17.720 --> 00:09:19.609 
has been specified.

182
00:09:19.610 --> 00:09:22.579 
And one important

183
00:09:22.580 --> 00:09:25.319 
one, for example, is the Web service description language

184
00:09:25.320 --> 00:09:28.609 
WSDL, which is

185
00:09:28.610 --> 00:09:30.109 
describing the interface.

186
00:09:30.110 --> 00:09:33.229 
So SOAP standard describes the messages

187
00:09:33.230 --> 00:09:36.199 
to call actually call the service, but WSDL

188
00:09:36.200 --> 00:09:38.779 
describes how the service should be called.

189
00:09:38.780 --> 00:09:41.929 
So it's a machine readable specification and

190
00:09:41.930 --> 00:09:45.109 
it can be used, for example, to create clients to

191
00:09:45.110 --> 00:09:46.759 
call the service.

192
00:09:46.760 --> 00:09:49.789 
And the next one is the universal description, discovery

193
00:09:49.790 --> 00:09:51.199 
and integration.

194
00:09:51.200 --> 00:09:54.559 
It describes as sort of a directory service

195
00:09:54.560 --> 00:09:57.649 
for services. So you can think of a sort of a phone

196
00:09:57.650 --> 00:10:00.969 
book, can look at your service roughly, and

197
00:10:02.420 --> 00:10:05.089 
their products will sort of provide a service registry

198
00:10:05.090 --> 00:10:08.209 
where ad services can be searched and retrieved

199
00:10:08.210 --> 00:10:11.389 
and information, for example, the WSDL can be stored.

200
00:10:11.390 --> 00:10:13.760 
And then there is a set of further standards

201
00:10:15.050 --> 00:10:18.498 
WS.* standards like WS

202
00:10:18.499 --> 00:10:21.109 
security, WS trust, which mainly cover certain aspects,

203
00:10:21.110 --> 00:10:24.229 
like, for example, security, authentication and things

204
00:10:24.230 --> 00:10:27.230 
like that. They all relate to SOAP, for

205
00:10:29.060 --> 00:10:31.915 
REST, they are not standards in a way. So it's more like a

206
00:10:31.916 --> 00:10:34.399 
paradigm or an idea. But in general, you always have to

207
00:10:34.400 --> 00:10:37.479 
distinguish between RESTful or SOAP based Web

208
00:10:37.480 --> 00:10:38.480 
services.

209
00:10:39.110 --> 00:10:42.389 
If we move on how web services or

210
00:10:42.390 --> 00:10:46.219 
what the role of Web services on the mainframe is, then

211
00:10:46.220 --> 00:10:49.459 
web services on the mainframe are now very,

212
00:10:49.460 --> 00:10:51.289 
very common and used for

213
00:10:52.520 --> 00:10:55.529 
opening up the traditional, for example, COBOL

214
00:10:55.530 --> 00:10:58.269 
transactional programs to be used by

215
00:10:59.480 --> 00:11:02.869 
other applications, non mainframe applications or Web pages

216
00:11:02.870 --> 00:11:04.219 
and so on.

217
00:11:04.220 --> 00:11:07.699 
Mobile clients. And in general, Web services

218
00:11:07.700 --> 00:11:10.699 
on z/OS or also on Linux can

219
00:11:10.700 --> 00:11:12.770 
be implemented on the mainframe

220
00:11:14.480 --> 00:11:17.479 
using Java EE, now called Jakarta EE,

221
00:11:17.480 --> 00:11:20.449 
since it has been released to the open source

222
00:11:20.450 --> 00:11:22.639 
a few weeks ago, a few months ago.

223
00:11:22.640 --> 00:11:26.539 
And regarding

224
00:11:26.540 --> 00:11:29.599 
the Jakarta EE specification, there are

225
00:11:29.600 --> 00:11:32.599 
different application services available on z/OS.

226
00:11:32.600 --> 00:11:36.019 
IBM provides the IBM WebSphere and I would say IBM Liberty

227
00:11:36.020 --> 00:11:37.020 
profile.

228
00:11:38.310 --> 00:11:41.231 
Which is a sort of lightweight component and z/OS

229
00:11:43.800 --> 00:11:44.800 
to implement

230
00:11:47.160 --> 00:11:50.429 
Java EE applications, services

231
00:11:50.430 --> 00:11:53.939 
and so on. And on Linux, of course, you have

232
00:11:53.940 --> 00:11:57.029 
all the Java EE open source and commercial

233
00:11:57.030 --> 00:11:59.429 
tools like Tomcat and Wildfly and JBoss and

234
00:12:01.290 --> 00:12:05.069 
Open Liberty and so on, available

235
00:12:05.070 --> 00:12:07.230 
to implement Web service as well.

236
00:12:08.340 --> 00:12:11.819 
You can either use SOAP here or

237
00:12:11.820 --> 00:12:14.879 
RESTful web services, both as possible using

238
00:12:14.880 --> 00:12:18.419 
Java for both the standards for

239
00:12:18.420 --> 00:12:19.420 
writing.

240
00:12:20.160 --> 00:12:22.439 
SOAP Web services, there's JAX-WS

241
00:12:23.910 --> 00:12:27.161 
API, which is the part of the Java EE

242
00:12:27.162 --> 00:12:30.179 
specification. And there you can easily turn every

243
00:12:30.180 --> 00:12:32.951 
enterprise Java Bean, every stateless enterprise Java Bean

244
00:12:32.952 --> 00:12:35.609 
into a SOAP based Web service just by putting some

245
00:12:35.610 --> 00:12:38.309 
annotations, and then the server automatically opens it as

246
00:12:38.310 --> 00:12:41.039 
a SOAP based Web service.

247
00:12:41.040 --> 00:12:42.839 
And it can be called very easy.

248
00:12:42.840 --> 00:12:45.794 
Basically, you just say, "OK, please be a

249
00:12:45.795 --> 00:12:47.939 
Web service" and then the EJB is reachable.

250
00:12:47.940 --> 00:12:51.029 
And the same is basically true for

251
00:12:51.030 --> 00:12:52.829 
for RESTful Web services.

252
00:12:52.830 --> 00:12:56.219 
There's also a standard API JAX-RS,

253
00:12:56.220 --> 00:12:59.309 
which implements RESTful web services and allows also

254
00:12:59.310 --> 00:13:02.549 
to expose Session Beans, for example, EJB's

255
00:13:02.550 --> 00:13:04.749 
in the form of a Web service.

256
00:13:05.910 --> 00:13:09.179 
So the classical structure is running

257
00:13:09.180 --> 00:13:12.179 
a Java EE application server with some EJBs, for example,

258
00:13:12.180 --> 00:13:15.659 
having clients calling our mainframe here using

259
00:13:15.660 --> 00:13:18.869 
HTTP over the network. And then the EJB again would

260
00:13:18.870 --> 00:13:22.049 
invoke CICS, for example, or other transaction

261
00:13:22.050 --> 00:13:25.199 
processing monitor internally to call the the traditional

262
00:13:25.200 --> 00:13:28.259 
COBOL program, that COBOL program might access the database

263
00:13:28.260 --> 00:13:31.379 
does something, sends back the data and the front

264
00:13:31.380 --> 00:13:32.909 
end sends it back to the client.

265
00:13:32.910 --> 00:13:36.029 
So that was the traditional way of opening COBOL

266
00:13:36.030 --> 00:13:37.289 
programs.

267
00:13:37.290 --> 00:13:39.899 
Now that's an alternative for some time.

268
00:13:39.900 --> 00:13:43.049 
There's a product called z/OS Connect.

269
00:13:43.050 --> 00:13:46.139 
That is an IBM product that can just

270
00:13:46.140 --> 00:13:49.079 
be installed and opens up all the functions and CICS

271
00:13:49.080 --> 00:13:52.919 
transactions on z/OS as

272
00:13:52.920 --> 00:13:55.949 
RESTful Web services. And this is a direct implementation.

273
00:13:55.950 --> 00:13:58.469 
You don't need a separate application server for that, for

274
00:13:58.470 --> 00:14:01.499 
example. And both allow to

275
00:14:01.500 --> 00:14:04.499 
call, for example, transactional

276
00:14:04.500 --> 00:14:07.499 
CICS programs, COBOL programs running CICS

277
00:14:07.500 --> 00:14:10.080 
like here on the z/OS on mainframe

278
00:14:11.430 --> 00:14:15.209 
using Web services.

279
00:14:15.210 --> 00:14:16.919 
And the important part is here

280
00:14:18.300 --> 00:14:21.509 
we have the traditional transactions, which,

281
00:14:21.510 --> 00:14:24.719 
for example, have or in the past had this

282
00:14:24.720 --> 00:14:26.939 
mapped based user interfaces.

283
00:14:26.940 --> 00:14:30.119 
And now we want to have

284
00:14:30.120 --> 00:14:33.239 
these programs being part of

285
00:14:33.240 --> 00:14:36.449 
modern systems, modern architectures

286
00:14:36.450 --> 00:14:39.659 
and with using these Web services front

287
00:14:39.660 --> 00:14:42.629 
end we can turn the traditional COBOL programs

288
00:14:42.630 --> 00:14:46.289 
in service oriented architectures

289
00:14:46.290 --> 00:14:49.829 
are being part of a service oriented architecture, which is

290
00:14:49.830 --> 00:14:53.339 
a good way to to modernize and to

291
00:14:53.340 --> 00:14:55.020 
preserve the value that is

292
00:14:56.370 --> 00:14:59.640 
all that lies in the COBOL programs.

293
00:15:00.780 --> 00:15:01.780 
Thank you very much.
