WEBVTT

1
00:00:01.660 --> 00:00:06.280 
In this talk I will illustrate
my project for Degree Nineteen,

2
00:00:06.690 --> 00:00:10.570 
this project is called Greedy
Maximization of Functions with

3
00:00:10.570 --> 00:00:13.490 
Bounded Curvature under
Partition Matroid Constraints.

4
00:00:14.380 --> 00:00:17.030 
This is a joint
work with

5
00:00:19.040 --> 00:00:24.630 
colleagues at the Friedrich group where I
currently work and it was published

6
00:00:25.990 --> 00:00:29.500 
at an AI conference proceedings
in 2019.

7
00:00:30.860 --> 00:00:34.890 
Ok so just to give a
quick motivation,

8
00:00:36.690 --> 00:00:41.560 
in recent years we've been observed
an increasing amount of attention

9
00:00:42.880 --> 00:00:45.920 
to the problem of creating
a sustainable economy.

10
00:00:47.630 --> 00:00:50.070 
Part of the reason
is because

11
00:00:51.150 --> 00:00:56.390 
we know now that the earth's temperature
is slowly rising and if the

12
00:00:56.790 --> 00:00:59.010 
earth's temperature continue
to rise the way it does

13
00:00:59.560 --> 00:01:01.020 
there will be problems

14
00:01:01.840 --> 00:01:03.170 
for future generations.

15
00:01:05.990 --> 00:01:10.430 
Our project fits in
this framework

16
00:01:11.680 --> 00:01:15.130 
since it asks the following
questions, it tries to address the

17
00:01:15.130 --> 00:01:20.610 
following questions, so how can we measure
the earth temperature efficiently?

18
00:01:22.370 --> 00:01:25.980 
If you think about it, measuring
the earth's temperature is far

19
00:01:25.980 --> 00:01:29.430 
from easy, because it
requires to deploy

20
00:01:30.790 --> 00:01:33.330 
thousands of sensors
across the globe.

21
00:01:34.000 --> 00:01:39.270 
And then you record these
measurements and take the average.

22
00:01:41.270 --> 00:01:47.480 
So of course those sensors
have computer have an

23
00:01:48.190 --> 00:01:50.810 
operational cost and

24
00:01:51.450 --> 00:01:55.140 
we want to minimize those
operational costs and still

25
00:01:55.140 --> 00:01:59.260 
get a good measurement. So in
practice we will only have

26
00:01:59.870 --> 00:02:03.100 
a certain amount of sensors that
we can deploy across locations

27
00:02:03.490 --> 00:02:07.760 
due to the budget constraints,
and we want to find an optimal

28
00:02:08.840 --> 00:02:13.110 
configuration to deploy the
sensor so that the measurement

29
00:02:13.110 --> 00:02:15.680 
is actually as accurate
as possible.

30
00:02:17.440 --> 00:02:21.700 
So the first thing that we observe
is that

31
00:02:22.620 --> 00:02:24.730 
this question is actually
far from trivial,

32
00:02:25.780 --> 00:02:31.390 
the reason being that if you deploy sensors
if you put your sensors evenly

33
00:02:31.950 --> 00:02:36.190 
across countries you will
get a bad measurement. So

34
00:02:37.010 --> 00:02:40.010 
that the intuitive
approach of

35
00:02:40.820 --> 00:02:42.350 
putting all sensors

36
00:02:43.380 --> 00:02:48.780 
equally distant, it just just doesn't
work for a series of reasons.

37
00:02:49.640 --> 00:02:52.360 
One of the reason

38
00:02:53.780 --> 00:02:57.530 
is that there is less
temperature variation

39
00:02:58.560 --> 00:03:02.020 
around the equator than the there is
around the north and the south pole.

40
00:03:03.730 --> 00:03:05.900 
And this significantly
affects

41
00:03:07.180 --> 00:03:12.960 
the average when you

42
00:03:13.120 --> 00:03:14.420 
process your
measurements.

43
00:03:15.290 --> 00:03:18.400 
So in other words this question
is actually far from trivial.

44
00:03:19.930 --> 00:03:23.220 
So what do we do about it? Well,
the first thing that we have

45
00:03:23.220 --> 00:03:26.870 
to ask ourselves is
to actually

46
00:03:27.940 --> 00:03:32.360 
do we have a function? Is
there something

47
00:03:32.360 --> 00:03:35.860 
that we can use to

48
00:03:36.790 --> 00:03:43.930 
to evaluate if the placement for
the sensors is optimal or not?

49
00:03:44.990 --> 00:03:47.590 
In other words we would like to
have a metric or a unit of

50
00:03:47.590 --> 00:03:50.170 
measurement that tells
us, okay we input

51
00:03:52.180 --> 00:03:55.660 
a configuration, a specific
configuration for the sensors,

52
00:03:56.360 --> 00:03:58.880 
and then the output should
be a number that tells us

53
00:03:59.840 --> 00:04:02.520 
if this configuration
is good or bad.

54
00:04:03.850 --> 00:04:06.090 
And this number,
the higher the number

55
00:04:06.790 --> 00:04:09.290 
the better the
configuration.

56
00:04:10.090 --> 00:04:13.410 
So luckily for us

57
00:04:15.520 --> 00:04:16.390 


58
00:04:17.670 --> 00:04:22.110 
we already know that there are some functions
that are commonly used in statistics

59
00:04:22.740 --> 00:04:27.130 
that are suitable as unit of
measurements for this problem.

60
00:04:30.260 --> 00:04:30.750 
And

61
00:04:32.190 --> 00:04:35.710 
we have to use these functions to

62
00:04:36.450 --> 00:04:38.710 
obtain results that are
statistically relevant.

63
00:04:39.960 --> 00:04:43.170 
We cannot come up with with
a function of our own,

64
00:04:43.620 --> 00:04:46.080 
because otherwise the
results will not be

65
00:04:46.750 --> 00:04:49.780 
scientific, will not
not be relevant.

66
00:04:50.510 --> 00:04:52.030 
So we have to use
the entropy,

67
00:04:52.870 --> 00:04:54.690 
these functions are called
entropic functions.

68
00:04:55.460 --> 00:05:00.750 
So this is good news in a sense because we don't
have to identify this function ourselves,

69
00:05:00.970 --> 00:05:05.190 
it's given to us. But
at the same time

70
00:05:06.070 --> 00:05:09.630 
we don't know much about
that function unfortunately. So

71
00:05:10.040 --> 00:05:15.190 
even though these functions
are given to us and people

72
00:05:15.470 --> 00:05:18.460 
that do statistics
they claim that those functions

73
00:05:19.030 --> 00:05:22.680 
are suitable as unit of
measurements for this problem,

74
00:05:23.810 --> 00:05:27.980 
we don't know much about how those functions
look like, how those functions behave,

75
00:05:28.890 --> 00:05:31.870 
and this is a little bit
problematic, because

76
00:05:32.620 --> 00:05:36.360 
we need
to find a procedure then

77
00:05:36.990 --> 00:05:39.340 
to optimize these
functions

78
00:05:40.190 --> 00:05:43.970 
and the only information that we
that we actually have is the

79
00:05:43.980 --> 00:05:48.840 
output of those functions. So we have to come
up with an algorithmic procedure that

80
00:05:49.380 --> 00:05:53.670 
throws possible solutions
or possible sensor

81
00:05:54.360 --> 00:05:57.970 
configurations at these functions
and then it observes the

82
00:05:57.970 --> 00:06:02.940 
output of these functions. And based
on these observations, it learns

83
00:06:04.350 --> 00:06:06.060 
what is the optimal
configuration.

84
00:06:08.000 --> 00:06:08.410 


85
00:06:11.330 --> 00:06:15.530 
So I like to think that this is
a little bit like climbing

86
00:06:15.530 --> 00:06:17.130 
a mountain without
having a map.

87
00:06:18.260 --> 00:06:24.010 
You know the highest peak corresponds to
the optimal configuration for your problem,

88
00:06:24.960 --> 00:06:31.040 
and you know the lower peaks correspond
to less desirable solution.

89
00:06:32.460 --> 00:06:36.110 
And you can view this optimization
problem as a walk or a hike,

90
00:06:36.460 --> 00:06:39.280 
you started base camp
for you likely have

91
00:06:39.850 --> 00:06:42.250 
a less desirable solution
and then you slowly

92
00:06:42.810 --> 00:06:45.100 
climb the mountains
and find your way

93
00:06:47.040 --> 00:06:51.840 
until you get to the
highest peak. So

94
00:06:53.350 --> 00:06:55.780 
in this context, we don't know
much about the functions that

95
00:06:55.780 --> 00:06:57.020 
we're trying
to optimize,

96
00:06:58.080 --> 00:07:02.010 
meaning that we don't really know
which way to go to actually

97
00:07:02.010 --> 00:07:03.470 
get to the
highest point.

98
00:07:04.880 --> 00:07:09.640 
In fact you know it could be the case
it could easily be the case that

99
00:07:10.550 --> 00:07:17.470 
we get lost
at some point and then we end up

100
00:07:17.470 --> 00:07:19.660 
to a less desirable
solution.

101
00:07:20.480 --> 00:07:23.570 
So we have to come up with
sort of a standard way to choose

102
00:07:23.570 --> 00:07:24.710 
which way to go,

103
00:07:26.690 --> 00:07:30.070 
that without really knowing
what is the optimal

104
00:07:31.040 --> 00:07:36.110 
way to go. And what we argue in this work
is that if we follow the steepest ascent,

105
00:07:36.570 --> 00:07:40.920 
which would be greedy algorithm,
if we follow the steepest ascent

106
00:07:41.830 --> 00:07:44.040 
we get to a solution
that's nearly optimal.

107
00:07:45.070 --> 00:07:48.840 
And this is good because this is
a very simple strategy

108
00:07:49.520 --> 00:07:52.220 
for a problem that is
far from trivial.

109
00:07:53.430 --> 00:07:58.210 
And so what we did, we considered
two type of experiments,

110
00:08:00.030 --> 00:08:01.890 
the first experiment
where we have

111
00:08:02.510 --> 00:08:04.990 
that everyone puts the
same amount of resources,

112
00:08:05.840 --> 00:08:07.110 
what is the optimal

113
00:08:08.360 --> 00:08:11.390 
sensor deployment there.
And then in a second

114
00:08:12.010 --> 00:08:14.420 
set of experiments,

115
00:08:15.410 --> 00:08:21.210 
we consider cases where countries are
required to put resources based on

116
00:08:21.410 --> 00:08:25.930 
what they already have. So we clearly see
that countries with more resources

117
00:08:26.360 --> 00:08:27.860 
such as the
North America,

118
00:08:28.810 --> 00:08:32.140 
in Western Europe and

119
00:08:32.900 --> 00:08:36.910 
in Australia
we see that,

120
00:08:38.360 --> 00:08:41.120 
there are more sensors
being deployed than in

121
00:08:41.120 --> 00:08:42.290 
other parts of
the world.

122
00:08:43.240 --> 00:08:45.110 
Whereas like in
the uniform case

123
00:08:45.720 --> 00:08:47.010 
sensors are deployed

124
00:08:47.720 --> 00:08:52.020 
more or less evenly. So we
consider two scenarios

125
00:08:52.020 --> 00:08:56.980 
with this type of constraints and
we run our algorithm and then

126
00:08:57.300 --> 00:08:58.680 
we compare the results.

127
00:09:00.890 --> 00:09:04.260 
So what we find
out is that,

128
00:09:04.950 --> 00:09:10.370 
in both cases the entropy
that our

129
00:09:10.670 --> 00:09:12.500 
very simple technique

130
00:09:13.640 --> 00:09:17.010 
always finds a good value for the
entropy which is the functions

131
00:09:17.010 --> 00:09:20.520 
that we were trying to
optimize earlier, and

132
00:09:21.900 --> 00:09:24.240 
also in
comparison with

133
00:09:25.430 --> 00:09:26.740 
previous related work,

134
00:09:27.370 --> 00:09:32.540 
this is a good indicator that
our strategy is optimal.

135
00:09:33.400 --> 00:09:36.880 
So this is good news
for us, because

136
00:09:37.360 --> 00:09:38.590 
we were able to

137
00:09:39.960 --> 00:09:45.030 
find a very simple procedure

138
00:09:45.940 --> 00:09:47.480 
to

139
00:09:48.910 --> 00:09:54.670 
approach a complex
problem like sensor placement. And

140
00:09:56.120 --> 00:09:59.190 
this procedure works well
in practice, we have some theory to

141
00:09:59.630 --> 00:10:00.990 
back up these results,

142
00:10:02.090 --> 00:10:05.060 
and yeah so this concludes
my presentation.

143
00:10:05.510 --> 00:10:07.820 
Thank you for
your attention.
