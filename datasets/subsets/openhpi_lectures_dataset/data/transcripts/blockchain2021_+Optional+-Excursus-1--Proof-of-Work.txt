WEBVTT

1
00:00:00.320 --> 00:00:03.730 
Welcome back to our openHPI course
"Blockchain: Revealing the Myth".

2
00:00:04.370 --> 00:00:07.370 
In this video, we want to take a
deeper look into the concept

3
00:00:07.370 --> 00:00:11.220 
of proofof-work but not only into
the inner workings of the concept

4
00:00:11.360 --> 00:00:15.520 
but also on the reasoning why
it was chosen for blockchain,

5
00:00:15.520 --> 00:00:18.540 
specifically for proof of work
block chain such as bitcoin.

6
00:00:20.250 --> 00:00:23.130 
So let's remind ourselves where
we left off before we introduce

7
00:00:23.130 --> 00:00:28.390 
the concept of proof of work. We had
a network which everyone could

8
00:00:28.620 --> 00:00:32.100 
vote for the proper order
of the transactions.

9
00:00:32.880 --> 00:00:37.380 
Therefore the majority decision was
represented by the majority of votes.

10
00:00:38.470 --> 00:00:42.390 
However this presents a problem.
As the computer scientist Judith

11
00:00:42.910 --> 00:00:46.470 
Donath put it, "you can have
as many electronic identities

12
00:00:46.490 --> 00:00:48.880 
as you have time and
energy to create."

13
00:00:50.320 --> 00:00:57.690 
So we need to find a way to prevent
participants from creating multiple identities.

14
00:00:58.080 --> 00:01:01.290 
If you compare this to analog
voting in a real life identity

15
00:01:01.780 --> 00:01:06.020 
in real life democracy you have
mechanisms such as a passport

16
00:01:06.020 --> 00:01:10.290 
or ID card to prevent voting
with a false name and you have

17
00:01:10.290 --> 00:01:13.520 
voter registration lists to prevent
voting at multiple locations.

18
00:01:14.180 --> 00:01:19.020 
However, all these mechanisms have
a commonality which is that

19
00:01:19.020 --> 00:01:22.460 
it requires a central entity, in
this case the state. Someone

20
00:01:22.460 --> 00:01:26.520 
has to print the cards, someone has
to maintain the registration lists.

21
00:01:26.950 --> 00:01:30.530 
Obviously in a peer-to-peer
network that is the bitcoin or

22
00:01:30.960 --> 00:01:34.910 
most blockchains it is not
possible to have this instance.

23
00:01:35.370 --> 00:01:39.070 
So the problem that we want to
solve is to make it infeasible

24
00:01:39.100 --> 00:01:43.760 
to vote multiple times without
relying on an identity provider.

25
00:01:44.980 --> 00:01:50.040 
There are already some examples
of mechanisms that can be used

26
00:01:50.040 --> 00:01:52.690 
that you might have already
seen in your daily life.

27
00:01:53.280 --> 00:01:57.010 
If you register for a website
maybe you had to fill out a captcha

28
00:01:57.220 --> 00:01:58.750 
which requires
human input.

29
00:01:59.700 --> 00:02:03.860 
This is for the purpose that an
attacker which wants to create

30
00:02:03.860 --> 00:02:07.840 
multiple identities at a website would
have to manually actually type in

31
00:02:08.190 --> 00:02:10.370 
the captcha and it
cannot be automated

32
00:02:11.010 --> 00:02:16.100 
with a computer. The same concept
lies behind the verified buyer

33
00:02:17.540 --> 00:02:21.040 
mark that you have seen on some
e-commerce sites like amazon.

34
00:02:23.160 --> 00:02:24.330 
It again should make it

35
00:02:25.500 --> 00:02:29.610 
infeasible for the attacker to create

36
00:02:30.150 --> 00:02:32.800 
multiple fake reviews
with just one identity.

37
00:02:33.900 --> 00:02:40.190 
As for him to be able to create a
review he has to first buy the object

38
00:02:40.430 --> 00:02:44.520 
which would require capital
expenditure making it financially

39
00:02:45.390 --> 00:02:48.960 
infeasible to create a large
number of these reviews.

40
00:02:51.120 --> 00:02:55.340 
So this concept can be generalized
to so called resource testing.

41
00:02:55.810 --> 00:02:59.680 
The hypothesis behind this is that an
identity which is fake by an attacker

42
00:02:59.990 --> 00:03:02.900 
has less resources
than a real identity.

43
00:03:04.170 --> 00:03:07.110 
By resource testing
also participants

44
00:03:07.740 --> 00:03:11.250 
it should be possible to distinguish
a fake and a real identity.

45
00:03:12.830 --> 00:03:16.020 
So examples of these testable
resources can be on the one hand

46
00:03:16.210 --> 00:03:21.190 
as we have seen with captchas human interaction
but also something more machine like

47
00:03:21.360 --> 00:03:25.980 
like computing power storage capacity,
network bandwidth or IP addresses.

48
00:03:27.360 --> 00:03:31.410 
So we've already mentioned that proof
of work is based on computing power.

49
00:03:31.890 --> 00:03:36.230 
However why was this chosen? Why
not something like IP addresses?

50
00:03:38.280 --> 00:03:41.670 
As a first intuition it seems
fairly easy to say that

51
00:03:42.250 --> 00:03:45.560 
each participant has to have their
own IP address in order to vote

52
00:03:46.010 --> 00:03:49.270 
on the order of
the transactions.

53
00:03:50.340 --> 00:03:53.840 
If an attacker would attempt to
have multiple identities with

54
00:03:53.840 --> 00:03:58.100 
the same IP address, it is
trivial to recognize this.

55
00:03:59.470 --> 00:04:02.130 
Also through
the nature of

56
00:04:02.890 --> 00:04:04.970 
the IP protocol the
internet routing

57
00:04:05.900 --> 00:04:10.350 
if an attacker simply chooses
an IP address for a second

58
00:04:11.060 --> 00:04:13.850 
identity that he actually
is not in possession of,

59
00:04:14.440 --> 00:04:19.340 
this would be recognized once communication
with the other partner starts.

60
00:04:20.460 --> 00:04:23.340 
So in order to check if
someone actually has

61
00:04:24.160 --> 00:04:28.670 
possession of an IP address we would use
something like a challenge response protocol.

62
00:04:29.280 --> 00:04:32.630 
This means if I as Alice
want to vote,

63
00:04:33.260 --> 00:04:38.410 
I would first contact the challenger
I would say hi I'm Alice

64
00:04:38.410 --> 00:04:39.930 
my IP address is 1234.

65
00:04:41.330 --> 00:04:44.590 
If I'm actually in possession
of the IP address

66
00:04:45.150 --> 00:04:50.070 
then I would receive the answer
from the challenger, hey IP

67
00:04:50.070 --> 00:04:53.790 
1234 are you actually
Alice? If so please reply

68
00:04:53.790 --> 00:04:54.850 
with this random number.

69
00:04:55.980 --> 00:04:59.300 
Only if I'm actually in possession
of the IP address I will

70
00:04:59.300 --> 00:05:03.710 
be able to receive this message and reply
to the challenger with the correct

71
00:05:03.900 --> 00:05:10.210 
number. But here we again see a problem
with the peer-to-peer nature of

72
00:05:10.370 --> 00:05:11.360 
the bitcoin protocol.

73
00:05:12.610 --> 00:05:18.130 
In a decentralised system who would actually
perform this challenge and response interaction?

74
00:05:18.580 --> 00:05:22.840 
Well, it's not possible. That means
the resource testing that

75
00:05:22.840 --> 00:05:27.060 
we need to choose for our bitcoin
protocol needs to be non interactive.

76
00:05:28.210 --> 00:05:31.720 
And this is where there's been
already quite a large number

77
00:05:31.720 --> 00:05:35.590 
of research, even before bitcoin. Going
back to the early nineties with

78
00:05:36.750 --> 00:05:39.830 
works such as pricing via
processing and later on

79
00:05:40.530 --> 00:05:44.810 
even until the early 2000s
with very similar concepts as

80
00:05:44.910 --> 00:05:47.290 
later used in bitcoin
with hashcash.

81
00:05:48.650 --> 00:05:52.290 
So let's take a deeper look. What
do we actually want from a

82
00:05:52.290 --> 00:05:56.700 
computational task in order for it
to be useful for resource testing?

83
00:05:57.370 --> 00:06:00.500 
On the one hand it needs to be
hard to calculate. That means

84
00:06:01.450 --> 00:06:07.480 
obviously the tested one has
to have some work to be done.

85
00:06:07.880 --> 00:06:12.700 
It needs to be easy to verify and it should
be verifiable by everyone without needing

86
00:06:12.980 --> 00:06:16.640 
any additional information other
than the proof of the work itself.

87
00:06:18.110 --> 00:06:22.080 
So the solution that researchers
came up with was to find a

88
00:06:22.080 --> 00:06:23.990 
hash that looks
a certain way.

89
00:06:24.830 --> 00:06:28.350 
If you remember, a hash is basically
a digest or fingerprint

90
00:06:28.870 --> 00:06:32.250 
of a large amount of data,
boiling it down into a small

91
00:06:33.190 --> 00:06:37.160 
string which uniquely
identifies the data.

92
00:06:38.170 --> 00:06:43.060 
If you want to have a more in-depth
look into the function of hash

93
00:06:43.710 --> 00:06:45.970 
functions and the
algorithms used

94
00:06:46.780 --> 00:06:51.190 
you can visit our openHPI course on
Confidential Communication in the Internet.

95
00:06:52.670 --> 00:06:55.810 
There is an excursion in week one
video 8 for more information.

96
00:06:58.560 --> 00:07:02.340 
So, resource testing with proof
of work therefore means that

97
00:07:02.340 --> 00:07:06.940 
we have hash function which uses the
message "M" and nonce "n" as input.

98
00:07:07.870 --> 00:07:12.260 
And the tasks that should be done
in the proof of work is to

99
00:07:12.260 --> 00:07:16.320 
find the nonce "n" so that the hash
of the message "M" and nonce

100
00:07:16.320 --> 00:07:18.450 
"n" is below a
certain target "t".

101
00:07:19.850 --> 00:07:23.770 
The only known algorithm to solve this
is so called brute force which means

102
00:07:24.020 --> 00:07:25.800 
just trying
different numbers.

103
00:07:26.930 --> 00:07:29.990 
The lower the target the more
difficult this task becomes

104
00:07:30.160 --> 00:07:31.510 
as it's more
restrictive.

105
00:07:32.370 --> 00:07:36.360 
This can also be described as
finding the hash of "M" and "n" with

106
00:07:36.610 --> 00:07:38.490 
a certain amount of
zeroes at the front.

107
00:07:40.690 --> 00:07:43.500 
So this kind of
resource testing

108
00:07:44.960 --> 00:07:47.820 
satisfies the requirements that
we set out in the beginning.

109
00:07:47.900 --> 00:07:51.310 
We want it to be non-interactive. So it
can be calculated without interaction

110
00:07:51.860 --> 00:07:54.140 
and can be verified later
without interaction.

111
00:07:55.460 --> 00:07:59.920 
But it can be calculated in
advance. If we think back to

112
00:08:00.560 --> 00:08:04.830 
our example of voting, this would
be problematic. I could spend

113
00:08:05.290 --> 00:08:09.810 
weeks or months even in advance to
prepare a lot of these proof of works

114
00:08:10.030 --> 00:08:12.040 
and if I want to

115
00:08:12.870 --> 00:08:17.520 
manipulate a certain vote, I could use
all of my accumulated proof of works

116
00:08:17.790 --> 00:08:21.130 
to simply manipulate
this one specific vote.

117
00:08:21.630 --> 00:08:25.430 
This means that we need to
introduce a challenge. Like I said

118
00:08:25.430 --> 00:08:28.860 
before, we have a challenge and
response which we can use

119
00:08:29.450 --> 00:08:31.560 
to have an interaction.

120
00:08:32.620 --> 00:08:36.350 
So adding a non predictable challenge
"c" prevents pre calculation.

121
00:08:36.780 --> 00:08:41.420 
If I don't know the input for my hash
function I obviously can't calculate

122
00:08:41.620 --> 00:08:42.450 
the result of it.

123
00:08:44.720 --> 00:08:48.860 
But again the challenge, who would
pose it in a peer to peer system?

124
00:08:49.830 --> 00:08:53.810 
Well luckily in our peer-to-
peer blockchain system we

125
00:08:54.290 --> 00:08:58.210 
already have information that
updates from time to time. In

126
00:08:58.210 --> 00:09:01.750 
the bitcoin for example every ten
minutes which everyone knows about.

127
00:09:02.060 --> 00:09:04.390 
It is the currently
highest or

128
00:09:05.030 --> 00:09:07.850 
most current block. So

129
00:09:08.550 --> 00:09:10.970 
we choose the head of
the previous block

130
00:09:11.430 --> 00:09:14.790 
or the hash of the previous
block as a kind of challenge.

131
00:09:16.060 --> 00:09:18.210 
Let's look at this in
a bit more detail.

132
00:09:19.210 --> 00:09:24.320 
We have a peer-to-peer network. We
have the currently most recent

133
00:09:24.320 --> 00:09:27.910 
block that everyone knows about and we
have a target that everyone knows about.

134
00:09:29.070 --> 00:09:31.070 
This means if I want to
create a new block

135
00:09:31.560 --> 00:09:34.360 
I would have to take a message, I
would take nonce and I would

136
00:09:34.360 --> 00:09:38.090 
take the previous hash. And
calculate the new hash.

137
00:09:39.220 --> 00:09:43.400 
We check, well it's not below the
target. So we increase the nonce

138
00:09:43.690 --> 00:09:46.410 
try another one and still
see it's not below.

139
00:09:47.610 --> 00:09:51.530 
We repeat this a lot of
times and finally after,

140
00:09:51.980 --> 00:09:57.250 
let's say a few minutes, we will
come to a result that has a nonce

141
00:09:57.510 --> 00:10:00.770 
which results in a hash
that is below the target.

142
00:10:02.180 --> 00:10:06.930 
We can then append it to the currently
highest block and propagate

143
00:10:06.930 --> 00:10:08.170 
it to the other
participants.

144
00:10:10.730 --> 00:10:15.640 
In bitcoin obviously we won't
say hey I'm Alice or I'm Bob in

145
00:10:15.640 --> 00:10:19.050 
our message but rather we will
include useful information about

146
00:10:19.050 --> 00:10:20.340 
the block that
we want to add.

147
00:10:21.460 --> 00:10:24.500 
So we have the protocol version,
we have the Merkle root of

148
00:10:24.500 --> 00:10:28.540 
the data, which means the transactions
that we want to include in the block,

149
00:10:29.030 --> 00:10:31.780 
the timestamp and the
target that is currently

150
00:10:32.350 --> 00:10:37.110 
known. This represents the message "M",
the nonce - obviously the nonce,

151
00:10:37.410 --> 00:10:40.570 
and the hash of the previous block
represents the challenge "c".

152
00:10:42.110 --> 00:10:45.280 
The hash function that is used as
the cryptographically secure

153
00:10:45.610 --> 00:10:49.570 
hash function SHA-256.
More information on that in the

154
00:10:50.500 --> 00:10:52.380 
secure communications
on the internet

155
00:10:53.130 --> 00:10:55.700 
video in our openHPI course.

156
00:10:58.950 --> 00:11:01.870 
So, what do we use to calculate
these kinds of hashes?

157
00:11:02.420 --> 00:11:06.110 
Well, if you have something like a
laptop or a desktop maybe at home

158
00:11:06.470 --> 00:11:11.370 
you will have this general purpose
chip the CPU central processing unit.

159
00:11:12.230 --> 00:11:14.030 
Obviously it's able to

160
00:11:14.810 --> 00:11:19.050 
show you the web browser, maybe
you make a presentation on it,

161
00:11:19.390 --> 00:11:22.420 
but you can also calculate hashes.
So there's a few hundred

162
00:11:22.610 --> 00:11:25.130 
maybe a few thousand hashes
per second that you can do.

163
00:11:26.450 --> 00:11:30.130 
If you compare this to a more
specialized processor which is

164
00:11:30.130 --> 00:11:32.350 
for example, specialized
for graphics processing

165
00:11:32.810 --> 00:11:38.050 
it might have a lot more parallel processes
that it can do which also suits

166
00:11:38.330 --> 00:11:42.750 
not only graphics processing but for
example SHA-256 calculations.

167
00:11:43.460 --> 00:11:46.280 
So it is already a
magnitude faster

168
00:11:47.080 --> 00:11:49.570 
then a general purpose
processor like a CPU.

169
00:11:51.060 --> 00:11:55.310 
What is actually mostly used in
a system like bitcoin is the

170
00:11:55.310 --> 00:11:59.610 
the so called Application Specific
Integrated Circuits. These ASICs,

171
00:12:00.840 --> 00:12:04.860 
circuits which are specifically
designed to only perform the

172
00:12:04.860 --> 00:12:10.520 
calculations for a specific
algorithm. This means the pictured

173
00:12:10.680 --> 00:12:14.490 
system here for example would only be
able to calculate hashes for the

174
00:12:14.620 --> 00:12:19.520 
SHA-256 algorithm, but
through this specialization

175
00:12:20.890 --> 00:12:26.350 
gets huge performance increases. So
it is not only a magnitude faster

176
00:12:27.110 --> 00:12:31.950 
but multiple magnitudes faster. This is
in the trillions of hashes per second.

177
00:12:33.190 --> 00:12:34.210 
So as you can imagine,

178
00:12:35.090 --> 00:12:40.970 
it is not anymore your typical end
user on this laptop that performs

179
00:12:41.220 --> 00:12:45.480 
this proof of work, but rather it really
has professionalized and commercialized.

180
00:12:46.920 --> 00:12:51.810 
In recent years there has been
an increasing drive towards

181
00:12:52.690 --> 00:12:57.880 
concentration of these hash powers. So on
the one hand it's professionalized in

182
00:12:58.030 --> 00:13:03.530 
huge data centers but also in a geographical
sense it concentrates in countries

183
00:13:03.710 --> 00:13:07.440 
where the electricity is cheap
and the maintenance of these

184
00:13:08.040 --> 00:13:09.330 
data centers
becomes cheap.

185
00:13:10.240 --> 00:13:14.140 
So sixty five percent of the hash
power is actually located in China

186
00:13:14.610 --> 00:13:19.530 
while another large chunk of it is
located in Russia, Kazakhstan or Iran

187
00:13:19.700 --> 00:13:23.760 
where access to, for example,
fossil fuel is very cheap.

188
00:13:25.570 --> 00:13:29.850 
So, speaking of fossil fuels, obviously,
you also have to take into account

189
00:13:30.180 --> 00:13:34.220 
the huge energy consumption that
comes along with this proof

190
00:13:34.220 --> 00:13:37.670 
of work and the computational
tasks that are being performed.

191
00:13:39.910 --> 00:13:43.890 
The estimated power consumption
of the bitcoin system

192
00:13:44.370 --> 00:13:49.630 
really is immense. It is in the
terawatt hours which if you

193
00:13:49.630 --> 00:13:51.900 
want to take a comparison
that we can comprehend,

194
00:13:52.950 --> 00:13:57.120 
we have to compare it to whole countries.
So currently it is estimated that the

195
00:13:57.410 --> 00:14:00.110 
bitcoin consumption is equivalent
to something like the

196
00:14:00.530 --> 00:14:03.460 
consumption of electricity
in a country like Chile.

197
00:14:06.270 --> 00:14:09.530 
And there is a clear correlation
between the price and the

198
00:14:09.530 --> 00:14:14.210 
energy that is spent in performing
the proof-of-work. The more

199
00:14:14.740 --> 00:14:19.020 
the bitcoin that you mine is worth,
the more it becomes viable

200
00:14:19.230 --> 00:14:21.420 
for you to spend
money, to

201
00:14:22.040 --> 00:14:27.700 
spend electricity but also to buy new hardware
for you to perform this proof-of-work and

202
00:14:27.900 --> 00:14:32.140 
increase your chances in getting the
next block and therefore getting

203
00:14:32.410 --> 00:14:38.840 
your bitcoin. So with the first price surge
or immense price surge of bitcoin

204
00:14:39.150 --> 00:14:41.430 
at the end of 2017 you can see

205
00:14:42.330 --> 00:14:46.450 
a delayed increase in the
estimated power consumption.

206
00:14:48.320 --> 00:14:52.050 
This comes from miners seeing
that it's profitable that they

207
00:14:52.050 --> 00:14:54.660 
have to buy new hardware,
maybe developing

208
00:14:55.700 --> 00:14:59.630 
new ASICs that are more
performant and can scale up more.

209
00:15:00.500 --> 00:15:04.090 
Similarly in the other surges in 2019

210
00:15:04.090 --> 00:15:09.030 
and at the beginning of this year,
you can see the sharp increase in

211
00:15:10.900 --> 00:15:15.230 
the energy consumption as it
becomes profitable again to spend

212
00:15:15.230 --> 00:15:19.970 
the energy to run these
systems and to mine bitcoins.

213
00:15:21.350 --> 00:15:26.420 
So we have to keep in mind that proof-of-work
has solved quite a few issues

214
00:15:26.670 --> 00:15:32.100 
but also created some drawbacks in the sense
of the environmental impact

215
00:15:32.340 --> 00:15:35.410 
and the electricity
consumption that it demands.

216
00:15:35.980 --> 00:15:40.250 
So in week two, we will also look
at alternatives to proof of work

217
00:15:40.440 --> 00:15:44.080 
in the form of proof of stake or
proof of authority which will take

218
00:15:44.290 --> 00:15:48.850 
a different approach to solving
the multiple identity problem.
