WEBVTT

1
00:00:00.720 --> 00:00:03.269 
Yeah, hello, it's me again,

2
00:00:03.270 --> 00:00:05.129 
Wolfram Greis from the

3
00:00:05.130 --> 00:00:07.079 
European Mainframe Academy

4
00:00:07.080 --> 00:00:08.909 
and in the next video clip,

5
00:00:08.910 --> 00:00:10.769 
I want to talk about the

6
00:00:10.770 --> 00:00:12.839 
relational data model,

7
00:00:12.840 --> 00:00:14.759 
some of the

8
00:00:14.760 --> 00:00:16.889 
history and

9
00:00:16.890 --> 00:00:18.239 
some background information.

10
00:00:21.750 --> 00:00:24.179 
There are two guys that

11
00:00:24.180 --> 00:00:26.069 
are mentioned when

12
00:00:26.070 --> 00:00:28.409 
it comes to relational databases,

13
00:00:28.410 --> 00:00:30.539 
one is Edgar

14
00:00:30.540 --> 00:00:31.499 
Codd.

15
00:00:31.500 --> 00:00:33.959 
He wrote

16
00:00:33.960 --> 00:00:36.179 
really revolutionary

17
00:00:36.180 --> 00:00:38.489 
people in

18
00:00:38.490 --> 00:00:40.799 
1970 - A relational model

19
00:00:40.800 --> 00:00:42.869 
of data for large shared

20
00:00:42.870 --> 00:00:44.369 
data banks.

21
00:00:44.370 --> 00:00:47.159 
All data is arranged in tables.

22
00:00:47.160 --> 00:00:49.229 
And only seven

23
00:00:49.230 --> 00:00:51.059 
years later,

24
00:00:51.060 --> 00:00:53.069 
Lawrence Ellison,

25
00:00:53.070 --> 00:00:55.259 
also known as Larry

26
00:00:55.260 --> 00:00:57.089 
Ellison, detected

27
00:00:57.090 --> 00:00:59.429 
this revolutionary ideas behind

28
00:00:59.430 --> 00:01:01.379 
the concept and

29
00:01:01.380 --> 00:01:03.299 
implemented the first

30
00:01:04.500 --> 00:01:06.689 
relational database with relational

31
00:01:06.690 --> 00:01:07.559 
software.

32
00:01:07.560 --> 00:01:09.839 
It was afterwards renamed

33
00:01:09.840 --> 00:01:11.819 
to Oracle, means

34
00:01:11.820 --> 00:01:13.455 
Larry Ellison from Oracle

35
00:01:14.970 --> 00:01:16.919 
saw the

36
00:01:16.920 --> 00:01:18.869 
potential behind

37
00:01:18.870 --> 00:01:20.879 
this idea from

38
00:01:20.880 --> 00:01:22.319 
Edgar Codd and it's the first

39
00:01:22.320 --> 00:01:23.729 
implementation.

40
00:01:23.730 --> 00:01:26.189 
Afterwards, also, IBM

41
00:01:26.190 --> 00:01:27.239 
got into the

42
00:01:28.380 --> 00:01:31.139 
bandwagon and

43
00:01:31.140 --> 00:01:32.990 
implemented a System

44
00:01:34.020 --> 00:01:35.879 
R later renamed

45
00:01:35.880 --> 00:01:36.880 
to

46
00:01:40.770 --> 00:01:42.899 
SQL/DS and renamed again

47
00:01:42.900 --> 00:01:45.299 
to Db2.

48
00:01:45.300 --> 00:01:47.609 
And in 1981,

49
00:01:47.610 --> 00:01:49.799 
Codd received the Turing Award.

50
00:01:49.800 --> 00:01:51.659 
Turing Award is an award

51
00:01:53.250 --> 00:01:55.529 
named after Alan

52
00:01:55.530 --> 00:01:57.509 
Turing and a computer

53
00:01:57.510 --> 00:02:00.449 
specialist from the

54
00:02:00.450 --> 00:02:01.979 
U.K.

55
00:02:01.980 --> 00:02:03.899 
And Turing Award is

56
00:02:03.900 --> 00:02:05.789 
something like the Nobel

57
00:02:05.790 --> 00:02:08.099 
Prize of the I.T.

58
00:02:08.100 --> 00:02:09.255 
because there is no

59
00:02:11.310 --> 00:02:13.589 
IT Nobel Prize.

60
00:02:13.590 --> 00:02:15.598 
So Turing

61
00:02:15.599 --> 00:02:17.969 
award is something like the

62
00:02:17.970 --> 00:02:19.141 
Nobel Prize of the IT.

63
00:02:22.580 --> 00:02:24.409 
OK, think of

64
00:02:24.410 --> 00:02:26.659 
the entity relational model,

65
00:02:26.660 --> 00:02:29.029 
we don't go into some details

66
00:02:29.030 --> 00:02:30.619 
here concerning entity

67
00:02:30.620 --> 00:02:33.199 
relationships, but normally

68
00:02:33.200 --> 00:02:35.449 
in many cases, data

69
00:02:35.450 --> 00:02:37.249 
is modeled after the entity

70
00:02:37.250 --> 00:02:38.719 
relationship model.

71
00:02:38.720 --> 00:02:40.759 
It means you have an entity

72
00:02:40.760 --> 00:02:42.799 
called "Students".

73
00:02:42.800 --> 00:02:44.809 
And as I already said,

74
00:02:44.810 --> 00:02:47.269 
we see a relational database

75
00:02:47.270 --> 00:02:48.359 
implementation.

76
00:02:48.360 --> 00:02:50.689 
All data is put into tables.

77
00:02:50.690 --> 00:02:52.639 
So we have a

78
00:02:52.640 --> 00:02:54.739 
table called students.

79
00:02:54.740 --> 00:02:57.709 
We have another entity

80
00:02:57.710 --> 00:02:59.899 
like "Lecture"

81
00:02:59.900 --> 00:03:01.309 
another table.

82
00:03:01.310 --> 00:03:03.859 
And to combine these

83
00:03:03.860 --> 00:03:06.229 
two entities

84
00:03:06.230 --> 00:03:07.629 
we say

85
00:03:08.990 --> 00:03:11.749 
a third table is implemented

86
00:03:11.750 --> 00:03:13.759 
called in this case "Visit".

87
00:03:13.760 --> 00:03:16.219 
So, entity students

88
00:03:16.220 --> 00:03:18.019 
visit lectures.

89
00:03:18.020 --> 00:03:20.359 
And as you very

90
00:03:20.360 --> 00:03:22.189 
easily can see, that

91
00:03:22.190 --> 00:03:23.190 
in this case,

92
00:03:25.160 --> 00:03:26.539 
the join of this table

93
00:03:27.560 --> 00:03:28.560 
is done

94
00:03:29.660 --> 00:03:31.789 
via the third table where you

95
00:03:31.790 --> 00:03:33.649 
have a student

96
00:03:33.650 --> 00:03:36.589 
ID of the first table

97
00:03:36.590 --> 00:03:38.623 
students and the

98
00:03:38.624 --> 00:03:40.549 
lecturer ID of the second table

99
00:03:40.550 --> 00:03:42.110 
lectures and

100
00:03:43.160 --> 00:03:44.192 
with the third

101
00:03:45.560 --> 00:03:47.389 
table, we

102
00:03:47.390 --> 00:03:50.029 
associate these both tables.

103
00:03:50.030 --> 00:03:51.719 
We will build a relation.

104
00:03:51.720 --> 00:03:53.689 
I think this is one of

105
00:03:53.690 --> 00:03:55.129 
the reasons why it's called a

106
00:03:55.130 --> 00:03:56.959 
relational model, where

107
00:03:56.960 --> 00:03:58.159 
in this case we see

108
00:03:59.680 --> 00:04:01.819 
that Donald Duck, in this case

109
00:04:01.820 --> 00:04:03.080 
with the student ID

110
00:04:04.580 --> 00:04:06.439 
458932 is

111
00:04:06.440 --> 00:04:09.199 
the busiest

112
00:04:09.200 --> 00:04:11.599 
student, took all three

113
00:04:11.600 --> 00:04:13.459 
lectures in this case,

114
00:04:13.460 --> 00:04:15.319 
Java databases

115
00:04:15.320 --> 00:04:16.765 
and networks.

116
00:04:19.420 --> 00:04:21.249 
OK, SQL, I

117
00:04:21.250 --> 00:04:23.469 
already mentioned to you in the last

118
00:04:23.470 --> 00:04:25.359 
video clip is a structured query

119
00:04:25.360 --> 00:04:28.179 
language also

120
00:04:28.180 --> 00:04:30.489 
invented at the IBM

121
00:04:30.490 --> 00:04:32.589 
lab in San Jose,

122
00:04:32.590 --> 00:04:35.379 
in California,

123
00:04:35.380 --> 00:04:37.269 
and it's designed by

124
00:04:37.270 --> 00:04:39.399 
Don Chamberlin and Ray Boyce,

125
00:04:39.400 --> 00:04:41.599 
two System R developers,

126
00:04:41.600 --> 00:04:44.469 
the first

127
00:04:44.470 --> 00:04:46.689 
DB relational

128
00:04:46.690 --> 00:04:48.609 
database implementation

129
00:04:48.610 --> 00:04:49.659 
of IBM.

130
00:04:49.660 --> 00:04:51.699 
And in former days it was called

131
00:04:51.700 --> 00:04:53.778 
structured English query

132
00:04:53.779 --> 00:04:55.719 
language. And that's why in many

133
00:04:55.720 --> 00:04:56.830 
cases today we all

134
00:04:58.780 --> 00:04:59.878 
still say SEQUEL

135
00:05:00.970 --> 00:05:02.889 
for structured

136
00:05:02.890 --> 00:05:04.389 
query language.

137
00:05:04.390 --> 00:05:06.489 
It was standardized in

138
00:05:06.490 --> 00:05:08.559 
1986 with

139
00:05:08.560 --> 00:05:10.689 
the ANSI Institute,

140
00:05:10.690 --> 00:05:12.819 
and in 1987

141
00:05:12.820 --> 00:05:13.820 
it's gotten an

142
00:05:15.160 --> 00:05:16.659 
ISO (international standardization

143
00:05:16.660 --> 00:05:18.879 
organization) Standard.

144
00:05:18.880 --> 00:05:19.880 
Current

145
00:05:21.380 --> 00:05:22.869 
SQL standard is 2008.

146
00:05:24.250 --> 00:05:26.229 
Problem with SQL standards, when

147
00:05:26.230 --> 00:05:28.089 
those who often implement all

148
00:05:28.090 --> 00:05:30.039 
the functions, they

149
00:05:30.040 --> 00:05:32.319 
implement proprietary extensions

150
00:05:32.320 --> 00:05:33.999 
for better performance or other

151
00:05:34.000 --> 00:05:34.989 
reasons.

152
00:05:34.990 --> 00:05:37.179 
So migration in many cases

153
00:05:37.180 --> 00:05:39.069 
is cumbersome, means if you want

154
00:05:39.070 --> 00:05:41.177 
to migrate from as

155
00:05:41.178 --> 00:05:43.419 
an example, from an Oracle

156
00:05:43.420 --> 00:05:45.939 
database to Db2 or vice versa,

157
00:05:45.940 --> 00:05:48.249 
it's normally not easy because

158
00:05:48.250 --> 00:05:50.139 
of these proprietary extensions.

159
00:05:52.580 --> 00:05:54.499 
We have three different

160
00:05:54.500 --> 00:05:56.989 
types of SQL statements

161
00:05:56.990 --> 00:05:59.089 
for definition of objects.

162
00:05:59.090 --> 00:06:01.309 
We use the Data Definition

163
00:06:01.310 --> 00:06:03.469 
Language (DDL) for

164
00:06:03.470 --> 00:06:05.389 
read, update and delete

165
00:06:05.390 --> 00:06:06.469 
of data.

166
00:06:06.470 --> 00:06:08.419 
We use Data Manipulation

167
00:06:08.420 --> 00:06:09.649 
Language (DML), I think it's the

168
00:06:09.650 --> 00:06:11.809 
most important part, especially

169
00:06:11.810 --> 00:06:13.069 
for the users.

170
00:06:13.070 --> 00:06:15.259 
And for access control means,

171
00:06:15.260 --> 00:06:17.629 
in this case, grant and revoke,

172
00:06:17.630 --> 00:06:19.609 
we use Data Control

173
00:06:19.610 --> 00:06:20.750 
Language (DCL).

174
00:06:22.610 --> 00:06:24.679 
These are all the

175
00:06:24.680 --> 00:06:26.570 
query language

176
00:06:28.580 --> 00:06:30.949 
activities, instructions

177
00:06:30.950 --> 00:06:31.909 
we have.

178
00:06:31.910 --> 00:06:33.889 
So it's not too much

179
00:06:33.890 --> 00:06:36.019 
and it looks quite

180
00:06:36.020 --> 00:06:36.819 
easy.

181
00:06:36.820 --> 00:06:38.839 
The problem is that we have

182
00:06:38.840 --> 00:06:40.969 
a lot of parameters behind these

183
00:06:40.970 --> 00:06:43.429 
instructions, and

184
00:06:43.430 --> 00:06:45.649 
especially when we

185
00:06:45.650 --> 00:06:47.779 
bring different tables

186
00:06:47.780 --> 00:06:50.179 
into some relationships,

187
00:06:50.180 --> 00:06:52.039 
we call it, we join

188
00:06:52.040 --> 00:06:54.319 
these different tables.

189
00:06:54.320 --> 00:06:56.419 
It's really not easy, has a lot

190
00:06:56.420 --> 00:06:58.339 
of implications

191
00:06:58.340 --> 00:07:00.319 
concerning performance and so

192
00:07:00.320 --> 00:07:02.749 
on. So structured query language

193
00:07:02.750 --> 00:07:04.939 
is really quite

194
00:07:04.940 --> 00:07:06.799 
complicated, especially in

195
00:07:06.800 --> 00:07:07.930 
bigger environments.

196
00:07:09.140 --> 00:07:11.029 
Here is a very easy example,

197
00:07:11.030 --> 00:07:13.180 
means in this case a DML

198
00:07:13.181 --> 00:07:14.939 
statement - SELECT customer number

199
00:07:14.940 --> 00:07:17.239 
(CNR), NAME and

200
00:07:17.240 --> 00:07:18.274 
the CITY; FROM the table CUSTOMER;

201
00:07:19.400 --> 00:07:21.559 
WHERE the STATE in this example

202
00:07:21.560 --> 00:07:22.560 
is California (CA);

203
00:07:24.540 --> 00:07:25.540 
ORDER BY the customer number (CNR).

204
00:07:28.060 --> 00:07:29.919 
This was the

205
00:07:29.920 --> 00:07:32.649 
very brief introduction

206
00:07:32.650 --> 00:07:33.650 
to

207
00:07:35.200 --> 00:07:37.029 
the relational idea.

208
00:07:37.030 --> 00:07:39.219 
For questions and

209
00:07:39.220 --> 00:07:41.229 
remarks, please use the

210
00:07:41.230 --> 00:07:43.149 
discussion forum on

211
00:07:43.150 --> 00:07:45.699 
the openHPI

212
00:07:45.700 --> 00:07:47.109 
platform.

213
00:07:47.110 --> 00:07:49.179 
Thank you for attending and see

214
00:07:49.180 --> 00:07:51.279 
you in the next video.
