WEBVTT

1
00:00:00.650 --> 00:00:03.840 
Welcome. In this video I will tell
you what a lock property is

2
00:00:03.910 --> 00:00:07.160 
and how we can store points
even if we learn iteratively.

3
00:00:08.260 --> 00:00:12.100 
So uh in the last video we talked
about two different learning

4
00:00:12.890 --> 00:00:16.720 
options or learning models, the one
uses all information involved

5
00:00:16.730 --> 00:00:19.840 
and the other one always uses
the last prediction model and

6
00:00:19.840 --> 00:00:23.120 
the current datum to produce
a new prediction model.

7
00:00:24.510 --> 00:00:28.610 
And you raise the question is
there an iterative learner? So

8
00:00:28.610 --> 00:00:32.530 
one that only uses the last prediction
model and the current input

9
00:00:32.780 --> 00:00:36.430 
that learns the family of half
spaces which we talked about

10
00:00:36.430 --> 00:00:41.880 
in the first week and is defined
as follows- so for three

11
00:00:41.890 --> 00:00:44.650 
integers a0, a1, a2

12
00:00:45.360 --> 00:00:51.070 
we define the half-space by
all points that yeah like

13
00:00:51.080 --> 00:00:56.500 
x1 and x2 also integers
that lie above or below

14
00:00:56.610 --> 00:01:02.250 
depending on the sign of a0,
the line given by a1 and a2

15
00:01:02.410 --> 00:01:08.620 
and a0. Okay so why did I write
these like kind of brackets

16
00:01:08.920 --> 00:01:15.340 
there? Well we used coding to make sure
that this is a hypothesis space.

17
00:01:15.550 --> 00:01:20.650 
So we denote by curly H
or calligraphic H the

18
00:01:20.650 --> 00:01:26.400 
set of all these Li and i now uh is
a code, like is a natural number

19
00:01:26.630 --> 00:01:31.710 
that encodes a0, a1 and a2 and I hope
you remember we had this table

20
00:01:31.900 --> 00:01:35.840 
too much integers and natural
numbers with the bijection that

21
00:01:35.840 --> 00:01:41.100 
is given by the table and we
also used the merge method to

22
00:01:41.210 --> 00:01:44.830 
make vectors of natural numbers,
just one neutral number and

23
00:01:44.830 --> 00:01:49.560 
this is what we use in order
to yeah to decide whether

24
00:01:49.740 --> 00:01:56.790 
a given input n corresponds to a vector
x1 x2 that satisfies the inequality

25
00:01:57.160 --> 00:02:00.950 
a0 is greater or
equal a1x1+ a2x2.

26
00:02:02.680 --> 00:02:09.320 
And we also proved that every hypothesis
space is learnable by enumeration strategy.

27
00:02:09.840 --> 00:02:14.890 
So for the full batch learners we already
answered the question positively, we know

28
00:02:15.060 --> 00:02:18.340 
that this family of half-spaces
is learnable by them but maybe

29
00:02:18.340 --> 00:02:23.660 
the iterative learners I mean
they seem to be a little bit

30
00:02:23.860 --> 00:02:26.300 
less strong, so maybe they
can't learn it. Let's see.

31
00:02:27.990 --> 00:02:33.290 
Ok so there's a lot of data that the
learner will see at some point

32
00:02:34.550 --> 00:02:38.730 
and if it has seen like for example
this finite amount of data

33
00:02:39.040 --> 00:02:42.990 
the full batch learner
will probably guess

34
00:02:43.570 --> 00:02:46.800 
a line. I mean it has some options
but if we say that there

35
00:02:46.800 --> 00:02:50.030 
should be an integer on it
then this is a good choice.

36
00:02:52.130 --> 00:02:56.800 
Ok but does it really use all these points? I
mean we're talking about iterative learning,

37
00:02:56.950 --> 00:03:01.560 
so we want to use as few data
as possible. So maybe it only

38
00:03:01.560 --> 00:03:06.510 
needs less points maybe only a
few very close to the line

39
00:03:07.250 --> 00:03:11.990 
but maybe we don't even need these.
Maybe these four points are enough.

40
00:03:12.580 --> 00:03:15.330 
Well what is special about
these four points?

41
00:03:16.370 --> 00:03:17.740 
Well I mean they
are different.

42
00:03:18.770 --> 00:03:22.960 
Ok so we have two lines going
through the positively labeled

43
00:03:22.960 --> 00:03:26.530 
points u and v and the negatively
labeled points x and y

44
00:03:27.130 --> 00:03:28.630 
and these lines
are parallel.

45
00:03:29.710 --> 00:03:33.310 
They're not only parallel they're
as close as they can get

46
00:03:33.640 --> 00:03:37.690 
if the points x, y, u and v
lie on the integer grid.

47
00:03:39.520 --> 00:03:40.580 
And also

48
00:03:42.380 --> 00:03:49.200 
they overlap. So it's kind of hard
to find another line or two lines

49
00:03:49.370 --> 00:03:53.730 
in between these line segments
and this would be the only way

50
00:03:53.930 --> 00:03:57.970 
to change the prediction model
because we have to be consistent

51
00:03:58.170 --> 00:04:01.960 
so the negatively labeled data
still has to lie on the negative

52
00:04:01.960 --> 00:04:05.890 
side of the line and the positively
labeled data also has to

53
00:04:05.890 --> 00:04:09.680 
lie on the positively labeled side of
the line. So a new prediction model

54
00:04:09.910 --> 00:04:15.110 
would have to lie between the yellow
and the red line segment. Okay so

55
00:04:15.330 --> 00:04:18.980 
this is why this so called lock
property of these four points

56
00:04:19.260 --> 00:04:25.350 
u v x and y is kind of a
strong argument for saying,

57
00:04:25.360 --> 00:04:29.990 
oh well, I mean I will ignore all data I
see in the future that is consistent

58
00:04:30.190 --> 00:04:34.540 
and the only data that may like make
me worry is inconsistent data

59
00:04:34.680 --> 00:04:39.150 
with the half space given by
the red line segment uv.

60
00:04:42.360 --> 00:04:46.430 
Ok but still that's four points
and an iterative learner can

61
00:04:46.440 --> 00:04:52.900 
only slow consider one datum. So
how do we store four points?

62
00:04:54.730 --> 00:04:58.660 
Okay I mean we've already seen
it the merge method will

63
00:04:58.660 --> 00:05:04.470 
help us here too. So we
just yeah, u v and x and

64
00:05:04.470 --> 00:05:08.360 
y correspond to natural numbers.
This is an array of four natural

65
00:05:08.360 --> 00:05:12.040 
numbers and then we can use the
merge method to make one natural

66
00:05:12.040 --> 00:05:18.620 
number out of it and this may be j.
So if we see a j we interpret it as

67
00:05:18.810 --> 00:05:23.760 
as u v x and y and we ask does
this j have the lock property?

68
00:05:25.530 --> 00:05:29.870 
Ok well if it has then we say
ok this just stands for the

69
00:05:29.870 --> 00:05:32.560 
half space given by
the line segment u v

70
00:05:34.040 --> 00:05:36.850 
and if it doesn't have the lock
property then we say well it

71
00:05:36.850 --> 00:05:40.320 
doesn't really matter, we are only
interested in points with a lock property.

72
00:05:40.560 --> 00:05:45.090 
So we fix some arbitrary
hypothesis space in advance. So

73
00:05:45.090 --> 00:05:49.870 
the half space of all points having
positive second coordinate for example

74
00:05:50.100 --> 00:05:52.070 
and this is our
dummy hypothesis.

75
00:05:52.790 --> 00:05:59.080 
Okay so what is this now? Well I say this
is a new uniform decision procedure

76
00:05:59.190 --> 00:06:03.560 
for the set of half-spaces
because if we are given n and j

77
00:06:04.280 --> 00:06:09.220 
we just say these are the inputs
and we want to find out whether

78
00:06:09.220 --> 00:06:10.460 
N is in n j.

79
00:06:12.150 --> 00:06:17.120 
Ok so we extract the vector set
from the N, we extract u v

80
00:06:17.120 --> 00:06:21.950 
x and y from the j, we ask do
they have the lock property?

81
00:06:23.090 --> 00:06:26.940 
If they have a look property we
compute the half-space and we answer

82
00:06:27.310 --> 00:06:31.110 
yes the point is in the half-space
that corresponds to j if

83
00:06:31.110 --> 00:06:34.670 
it is in this half-space. So if
that lies in this half space

84
00:06:35.020 --> 00:06:41.070 
and otherwise we say well yes if
that is in this prefix dummy

85
00:06:41.380 --> 00:06:42.480 
half space.

86
00:06:44.420 --> 00:06:48.230 
So this is another uniform decision
procedure for the set of half spaces

87
00:06:48.350 --> 00:06:51.940 
and this allows us to store
points which is really nice.

88
00:06:54.060 --> 00:06:59.140 
Ok but how does the iterative learner
m now use the lock property

89
00:06:59.280 --> 00:07:03.660 
to learn the set of half spaces? We
will see this in the next video.
