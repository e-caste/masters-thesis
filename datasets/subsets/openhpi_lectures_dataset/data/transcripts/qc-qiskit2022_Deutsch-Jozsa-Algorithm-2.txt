WEBVTT

0
00:00:00.710 --> 00:00:03.810 
Hi everyone and welcome back to this second part of the

1
00:00:04.410 --> 00:00:07.730 
Deutsch-Jozsa algorithm. In the last video you have seen what the

2
00:00:08.690 --> 00:00:13.420 
Deutsch-Jozsa algorithm is, how it works and how we can
implement the circuit with Qiskit

3
00:00:14.060 --> 00:00:16.790 
and now in this video I will show you how we can actually

4
00:00:16.790 --> 00:00:20.120 
run it both on the simulator and then on an actual device.

5
00:00:21.860 --> 00:00:25.880 
So, here were our functions, our imports where we created the circuit.

6
00:00:25.890 --> 00:00:31.790 
That's how we ended the last video and now we're gonna try to run it with the simulator

7
00:00:32.340 --> 00:00:38.130 
for that, we first specify our backend which is the Aer simulator.

8
00:00:38.820 --> 00:00:42.190 
Then we specify the number of shots where we just chose 1000

9
00:00:42.190 --> 00:00:45.270 
here but in theory we can go up to like 65,000.

10
00:00:46.550 --> 00:00:50.170 
Then we again run our algorithm to create the

11
00:00:50.630 --> 00:00:51.260 
Deutsch-Jozsa circuit.

12
00:00:52.030 --> 00:00:56.080 
So, I'm specifying here to run it on n cubits and we said before n equals four

13
00:00:57.230 --> 00:01:01.640 
and then we execute that circuit just by writing

14
00:01:01.640 --> 00:01:03.370 
execute and specifying the circuit

15
00:01:03.370 --> 00:01:06.620 
we want to run, the backend we want to use and the number of shots.

16
00:01:07.250 --> 00:01:11.900 
And well since we're interested in the result, we say .result in the brackets.

17
00:01:12.850 --> 00:01:13.530 
Now,

18
00:01:13.540 --> 00:01:15.570 
what we're actually interested is in not all

19
00:01:15.570 --> 00:01:17.920 
of the different results but what we just

20
00:01:17.920 --> 00:01:21.690 
care about right now is to get the number of counts of our 1000 shots.

21
00:01:21.700 --> 00:01:24.910 
So, we say results.get_counts and then we

22
00:01:24.910 --> 00:01:26.710 
plot the histogram with a number of counts.

23
00:01:26.720 --> 00:01:28.290 
So, let's do that.

24
00:01:28.940 --> 00:01:32.460 
Let's run the cell and you can see here is

25
00:01:32.470 --> 00:01:35.780 
we get the zero bit string with probability one.

26
00:01:36.370 --> 00:01:40.470 
So, all of our 1000 shots all gave the zero bit string.

27
00:01:40.480 --> 00:01:43.430 
And as we have learned in the last video,

28
00:01:43.440 --> 00:01:46.560 
this implies that the oracle function was constant.

29
00:01:47.340 --> 00:01:48.440 
As you may have noticed,

30
00:01:48.450 --> 00:01:52.380 
I actually just put n here when I called the Deutsch-Jozsa

31
00:01:52.380 --> 00:01:55.810 
algorithm and they did not specify which oracle we want to use.

32
00:01:55.820 --> 00:02:01.050 
This means it just chose a random oracle. So, we can now run the function again

33
00:02:01.950 --> 00:02:02.890 
and again.

34
00:02:02.900 --> 00:02:08.160 
And now you see, now it actually changed, now we get the one straight one bit string.

35
00:02:08.789 --> 00:02:11.210 
So, we get something that's different from the zero bit string.

36
00:02:11.210 --> 00:02:13.080 
So, in this case it was a balanced oracle.

37
00:02:14.240 --> 00:02:16.690 
Great. So, this was using the simulator though.

38
00:02:16.700 --> 00:02:20.060 
But now of course we're interested in using actual quantum devices.

39
00:02:20.730 --> 00:02:21.580 
For that,

40
00:02:21.590 --> 00:02:24.570 
we just need to change the backends instead of having the simulator,

41
00:02:24.580 --> 00:02:27.410 
we now want to get a quantum backend.

42
00:02:28.180 --> 00:02:31.240 
So, one example would be that we can just specify it

43
00:02:31.240 --> 00:02:34.050 
by saying that we want to have this specific device,

44
00:02:34.050 --> 00:02:37.650 
for example, the IBMQ_Quito or the Hanoi device.

45
00:02:37.660 --> 00:02:40.720 
We have to be careful though some of the devices have a queue here and

46
00:02:40.720 --> 00:02:45.060 
some do not just in case you get some error message that might be it.

47
00:02:45.070 --> 00:02:49.210 
But what we also can do is because you may have noticed that of course for

48
00:02:49.210 --> 00:02:50.600 
the quantum devices they all have a queue

49
00:02:50.600 --> 00:02:54.400 
of jobs that have to be evaluated or executed.

50
00:02:54.630 --> 00:02:57.510 
And in order to choose one that has a short queue, we can say

51
00:02:57.510 --> 00:03:01.400 
we want to have the least busy device. So, we call the least busy function

52
00:03:01.410 --> 00:03:06.060 
which we reported in the beginning as well and we require that well it

53
00:03:06.060 --> 00:03:09.320 
has to have we need a device that has at least n plus one qubits

54
00:03:10.180 --> 00:03:14.050 
and that is not the simulator and that is operating.

55
00:03:15.260 --> 00:03:18.230 
Then we can print this least busy backend,

56
00:03:18.910 --> 00:03:23.070 
We can determine our number of shots. I increased to 20,000.

57
00:03:23.810 --> 00:03:27.580 
We can also call what we call the Qiskit job watcher which you will see,

58
00:03:27.580 --> 00:03:32.310 
it's gonna pop up and then we will see a window where we can see how our jobs are doing,

59
00:03:32.310 --> 00:03:33.230 
whether they're in the queue,

60
00:03:33.230 --> 00:03:34.630 
whether they're already running, whether they're

61
00:03:34.630 --> 00:03:36.800 
still getting evaluated and so on.

62
00:03:38.150 --> 00:03:41.540 
So, here we now again call the Deutsch-Jozsa

63
00:03:41.980 --> 00:03:47.170 
circuit with n And some oracle number and we executed just as same as before.

64
00:03:47.180 --> 00:03:49.900 
And then we will have a job ID.

65
00:03:49.910 --> 00:03:53.100 
And if we later on I wanna call that job and

66
00:03:53.100 --> 00:03:55.470 
like get look again at the statistics of that job.

67
00:03:55.480 --> 00:03:58.720 
It's good if we keep that job ID. For that, I'M printing it

68
00:03:59.440 --> 00:04:01.320 
and you see here I've commented some

69
00:04:01.320 --> 00:04:05.220 
other commands which is something specific that

70
00:04:05.220 --> 00:04:07.970 
I can do if I ever if I know which device I'm using,

71
00:04:07.980 --> 00:04:09.790 
I may want to choose a layout.

72
00:04:10.900 --> 00:04:14.860 
The layout is if I look at the different devices for example,

73
00:04:14.860 --> 00:04:16.180 
let's say the Hanoi device

74
00:04:17.160 --> 00:04:24.580 
then we will see in a second, here we will see the layout map so we can see

75
00:04:24.580 --> 00:04:26.720 
or connectivity map is what they call it and

76
00:04:26.720 --> 00:04:28.790 
we can see how the different qubits are aligned.

77
00:04:29.300 --> 00:04:33.760 
So, let's say we need three qubits then it would be bad to use the cubit 0,

78
00:04:33.770 --> 00:04:36.590 
12 and 26 for example because there's a lot of other

79
00:04:36.590 --> 00:04:39.170 
qubits in between and we would need a lot of swap gates

80
00:04:39.790 --> 00:04:42.180 
Instead it might make sense to then take qubits

81
00:04:42.190 --> 00:04:45.170 
0,1 and 4 or we could also choose some

82
00:04:45.170 --> 00:04:47.090 
that have a very low coherence time or a

83
00:04:47.090 --> 00:04:50.170 
small readout error and then choose according to that.

84
00:04:51.640 --> 00:04:54.240 
But this is just an optional thing that we can give the layout,

85
00:04:54.250 --> 00:04:55.690 
which makes a lot of sense,

86
00:04:55.700 --> 00:04:58.900 
basically only sense if we know which device we're using

87
00:04:58.910 --> 00:05:01.590 
but if we just use the least busy one,

88
00:05:01.600 --> 00:05:06.470 
what we can then actually do is what I did here and didn't mention yet is you can

89
00:05:06.470 --> 00:05:09.210 
use the so called optimization level number 3 which

90
00:05:09.210 --> 00:05:12.800 
is the highest that Qiskit has what optimizes automatically.

91
00:05:12.810 --> 00:05:14.990 
Also for the layout map.

92
00:05:15.000 --> 00:05:18.160 
So, it will automatically choose what it thinks is the best layout

93
00:05:18.600 --> 00:05:22.610 
plus it will also like combine some gates that can be simplified for example.

94
00:05:23.670 --> 00:05:25.910 
So, let us run that.

95
00:05:27.580 --> 00:05:33.070 
And now we should soon see here, now we see the jobs,

96
00:05:33.780 --> 00:05:36.490 
this window popping popping up,

97
00:05:36.500 --> 00:05:39.560 
we see the job is evaluated and we're number 8 in the queue.

98
00:05:39.570 --> 00:05:40.530 
And the job is queued.

99
00:05:42.050 --> 00:05:45.190 
Because I don't want to wait now obviously, here we see also a job ID.

100
00:05:45.200 --> 00:05:50.550 
So, later on we could check the results but well of course I don't want to wait now.

101
00:05:50.550 --> 00:05:55.760 
So, I ran the job before I called it the old job and I looked at some,

102
00:05:55.770 --> 00:05:57.940 
we can look at these results now.

103
00:05:58.610 --> 00:06:03.860 
So, we specify the provider that I used, actually in this case I used

104
00:06:03.870 --> 00:06:07.910 
the IBM Hanoi device, so I need to specify the provider to be internal

105
00:06:08.550 --> 00:06:12.150 
and I can retrieve the job with the job ID I printed for that one.

106
00:06:12.670 --> 00:06:18.570 
Now, let's look at the result. So, we again just look at the accounts of the Histogram.

107
00:06:19.090 --> 00:06:23.700 
And here we can see how the Histogram looks. Now we have with like 96% chance,

108
00:06:23.700 --> 00:06:25.600 
we get the zero bit string.

109
00:06:26.390 --> 00:06:29.040 
And well that's not 100% chance but of course

110
00:06:29.050 --> 00:06:31.270 
there's always some noise if we use actual devices.

111
00:06:31.780 --> 00:06:36.080 
So, we can conclude from this histogram that our actual output is

112
00:06:36.080 --> 00:06:38.920 
the zero bit string and the other outputs are just noise.

113
00:06:40.580 --> 00:06:43.720 
Now I also ran a few other oracles. So this was

114
00:06:43.940 --> 00:06:44.940 
oracle number 2 for example.

115
00:06:44.940 --> 00:06:49.420 
Now oracle number 1 looks like that, you can see in this case it's a one bit string.

116
00:06:49.420 --> 00:06:52.510 
So, in this case the oracle was balanced and not constant.

117
00:06:52.520 --> 00:06:55.700 
And yes there is a very small probability to have the zero bit string.

118
00:06:55.710 --> 00:06:59.330 
But again this is just noise, in theory that wouldn't be there.

119
00:07:00.610 --> 00:07:02.830 
And then another oracle

120
00:07:04.250 --> 00:07:05.210 
which looks like this

121
00:07:05.780 --> 00:07:06.300 
and this

122
00:07:06.300 --> 00:07:10.020 
I just wanted to show you to make sure it doesn't have to be the one bit string.

123
00:07:10.020 --> 00:07:12.220 
It can be any bit string that is not the zero bit string.

124
00:07:12.220 --> 00:07:15.980 
So, in this case we have 0100 which is not just zeros.

125
00:07:15.990 --> 00:07:20.210 
So, it again implies that our oracle was balanced and not constant.

126
00:07:21.960 --> 00:07:25.570 
Now one thing I actually have not mentioned yet but

127
00:07:25.570 --> 00:07:26.880 
it's something that I still want to show you at

128
00:07:26.880 --> 00:07:30.060 
the end of the video is that this oracle function

129
00:07:30.060 --> 00:07:32.720 
that we use the Qiskit one, where Qiskit,

130
00:07:32.720 --> 00:07:37.890 
provides us one out of four oracles is very nice but it only works for four qubits.

131
00:07:38.640 --> 00:07:44.460 
So, if I wanna run my algorithm on a on any other number of n qubits,

132
00:07:44.990 --> 00:07:48.110 
then I should maybe just write my own oracle

133
00:07:48.760 --> 00:07:50.890 
and I just show you now how that works.

134
00:07:51.610 --> 00:07:54.560 
So, I can just define my own function in Deutsch-Jozsa

135
00:07:54.990 --> 00:07:57.530 
algorithm, where I again in the beginning create

136
00:07:57.530 --> 00:07:59.890 
my quantum circuit with n plus one qubits

137
00:08:00.570 --> 00:08:04.460 
And I can again give an oracle number, in this case just 1.

138
00:08:04.970 --> 00:08:08.500 
If it's one I want my oracle to be balanced

139
00:08:09.720 --> 00:08:13.760 
and while balanced. One way to implement a balanced function.

140
00:08:13.760 --> 00:08:14.890 
There's a lot of different ways.

141
00:08:14.890 --> 00:08:18.340 
One way would just be to look at the first bit of the bit string.

142
00:08:18.350 --> 00:08:20.720 
If I give you an n-bit bit string and you just look at the

143
00:08:20.720 --> 00:08:24.230 
first bit in half of the cases at 0 and of the cases it's 1.

144
00:08:24.240 --> 00:08:26.180 
So, your oracle would be balanced.

145
00:08:26.820 --> 00:08:30.230 
Another option is that what we implement here,

146
00:08:30.240 --> 00:08:33.559 
it's a bit more advanced but still easy.

147
00:08:33.570 --> 00:08:38.380 
We basically take the, we look at the the parity of the bit

148
00:08:38.380 --> 00:08:42.179 
string, so we add up all the bits or qubits in that case.

149
00:08:42.190 --> 00:08:45.920 
And so if the parity is odd, we output one.

150
00:08:45.930 --> 00:08:50.730 
If the parity is even output zero, that's another way to have a balanced oracle.

151
00:08:51.040 --> 00:08:55.890 
So, to do that we just apply the CNOT gate. So it's CX

152
00:08:55.890 --> 00:08:59.570 
here because X for the polyX but that imply, that makes means

153
00:08:59.570 --> 00:09:02.160 
we're implementing the CNOT gate that you have seen before,

154
00:09:02.160 --> 00:09:04.680 
that applies the XOR function.

155
00:09:04.690 --> 00:09:08.280 
If we do that with all qubits in the end we were adding them all up

156
00:09:08.590 --> 00:09:10.000 
too. So, we get the parity.

157
00:09:10.930 --> 00:09:15.940 
So, this is for the case of the balanced oracle. And for the case of the constant oracle,

158
00:09:16.890 --> 00:09:21.770 
in that case we just randomly choose either 0 or 1 and just output that.

159
00:09:21.780 --> 00:09:25.360 
So, in the case of zero we do nothing. In the case of one we just apply the X

160
00:09:25.360 --> 00:09:29.800 
Gate to flip it. So our input qubit will be flipped from 0 to 1.

161
00:09:29.810 --> 00:09:33.350 
So, we just output either always only zero or always only one.

162
00:09:34.950 --> 00:09:40.700 
Then this oracle that we just defined we make it to be a gate and call it again the

163
00:09:41.070 --> 00:09:41.870 
the oracle

164
00:09:42.600 --> 00:09:43.860 
and return that function

165
00:09:45.930 --> 00:09:46.220 
Now,

166
00:09:46.220 --> 00:09:50.100 
as before we can just call our algorithm, in

167
00:09:50.100 --> 00:09:52.280 
this algorithm we call the Deutsch-Jozsa Algorithm oracle.

168
00:09:52.280 --> 00:09:54.800 
So, this will automatically be updated now and we

169
00:09:54.800 --> 00:09:57.590 
can draw the new circuit now with eight qubits

170
00:09:59.390 --> 00:10:01.700 
for example, but we can really choose any number of

171
00:10:01.710 --> 00:10:03.980 
n here now and again you see we have our

172
00:10:04.860 --> 00:10:06.290 
8 qubits Hadamard gates, oracle function

173
00:10:06.640 --> 00:10:10.190 
hadamard gates and measurements and this extra one to store the output.

174
00:10:11.670 --> 00:10:15.460 
Now, I don't wanna run it again. Now, I just wanted to show

175
00:10:15.460 --> 00:10:20.880 
you actually a job that I ran before with this self made oracle.

176
00:10:21.690 --> 00:10:23.780 
Just to show you that it also worked, actually only

177
00:10:23.780 --> 00:10:26.630 
ran it on four qubits but it works on any number

178
00:10:27.240 --> 00:10:30.680 
But so in four qubits just so we can compare it to the results we had before.

179
00:10:30.690 --> 00:10:34.770 
Again we get like 96% chance to get the right one and the rest is noise.

180
00:10:36.870 --> 00:10:41.070 
But now the oracle that I, if I ran the other job

181
00:10:42.320 --> 00:10:46.680 
we get this distribution which well, makes

182
00:10:46.680 --> 00:10:48.940 
us assume that again we were not interested

183
00:10:48.940 --> 00:10:51.700 
in the zero bit string but the output was actually the one bit string.

184
00:10:52.250 --> 00:10:58.010 
But what you can see it's only 58% now to get this one bit string rather than

185
00:10:58.550 --> 00:11:00.980 
90, above 90 what we had before.

186
00:11:01.970 --> 00:11:06.380 
I just wanted to show you that because well the reason that this now decreased

187
00:11:06.390 --> 00:11:11.440 
by so much is that the way we implemented the oracle for the balanced case.

188
00:11:11.450 --> 00:11:15.900 
So, this is obviously the balance case, was that we applied to CNOT

189
00:11:15.900 --> 00:11:18.600 
gates between all the different qubits.

190
00:11:18.610 --> 00:11:22.300 
So, rather than just looking at for example the first qubit which might have been done

191
00:11:22.300 --> 00:11:26.570 
in one of the oracles where we saw the distribution before where we have like 93%.

192
00:11:27.310 --> 00:11:30.340 
Now, we applied a lot of gates and a lot of gates

193
00:11:30.340 --> 00:11:34.950 
means much more errors because each gate leads to some error.

194
00:11:34.960 --> 00:11:37.670 
Each gate has a small error rate but if we add them up

195
00:11:37.680 --> 00:11:41.040 
of course we get a bigger error and then also we have a

196
00:11:41.040 --> 00:11:45.050 
longer the more gates we have the longer coherence time we need for

197
00:11:45.050 --> 00:11:48.890 
our qubits. So, they might also decode here which also needs the noise.

198
00:11:48.900 --> 00:11:51.820 
So, if you for example look at this job that I ran here,

199
00:11:52.450 --> 00:11:54.590 
if we look at it how it looks like here we

200
00:11:54.590 --> 00:11:56.880 
see the results again and here we can see how the

201
00:11:56.880 --> 00:12:00.560 
circuit looked like once we transpiled it to our system because

202
00:12:00.570 --> 00:12:03.200 
not only do we have these and qubit these n CNOT

203
00:12:03.200 --> 00:12:06.100 
gates but because of the mapping we sometimes also

204
00:12:06.100 --> 00:12:08.550 
need some swap gates and some additional gates because it needs

205
00:12:08.550 --> 00:12:10.780 
to all be transpiled in a way that the quantum

206
00:12:10.780 --> 00:12:14.290 
computer with our given connectivity map can actually implement it.

207
00:12:14.970 --> 00:12:19.580 
So, here you can see how long it actually looks and well then given all these gates,

208
00:12:19.590 --> 00:12:21.030 
that's why we have more noise.

209
00:12:21.040 --> 00:12:22.320 
However,

210
00:12:22.330 --> 00:12:24.950 
I think it's still clearly identifiable what the result

211
00:12:24.950 --> 00:12:27.640 
was. In this case the oracle was balanced.

212
00:12:27.650 --> 00:12:29.110 
So, even that works.

213
00:12:29.120 --> 00:12:33.050 
And as I said you can just define the oracle as you wish and might choose an

214
00:12:33.050 --> 00:12:37.530 
easier version if you want to scale it up and have more qubits and want less noise.

215
00:12:38.360 --> 00:12:39.500 
Thank you for watching.

216
00:12:39.510 --> 00:12:42.060 
And then in the next video we are gonna go

217
00:12:42.060 --> 00:12:44.710 
into the next algorithm which is the Grovers algorithm.

218
00:12:44.720 --> 00:12:45.320 
See you.
