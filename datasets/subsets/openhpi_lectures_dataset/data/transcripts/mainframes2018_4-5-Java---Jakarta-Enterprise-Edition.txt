WEBVTT

1
00:00:01.650 --> 00:00:06.360 
Welcome to the introduction to Java Enterprise Edition. Nowadays

2
00:00:06.620 --> 00:00:10.540 
recently renamed to Jakarta Enterprise Edition or

3
00:00:11.120 --> 00:00:17.280 
Jakarta Java (EE). My name is Philipp Brune from Neu-Ulm University of Applied Sciences.

4
00:00:19.670 --> 00:00:24.070 
We have already learned about the java language and the java runtime-the JVM.

5
00:00:24.570 --> 00:00:28.770 
But java is more than just the language and the runtime.

6
00:00:29.580 --> 00:00:35.730 
In fact what we typically consider java as a language is sort of the core

7
00:00:37.590 --> 00:00:39.450 
labelled java standard edition java-Java SE,

8
00:00:40.210 --> 00:00:43.070 
which contains the language- the API, the LIBS and the JVM.

9
00:00:45.680 --> 00:00:49.850 
To make java really useful for enterprise computing of course

10
00:00:50.320 --> 00:00:54.810 
we need more than that. And the next part of the java ecosystem

11
00:00:55.460 --> 00:01:00.040 
that extends this java standard edition is the java enterprise edition,

12
00:01:00.180 --> 00:01:03.280 
now called jakarta enterprise edition and

13
00:01:04.080 --> 00:01:08.060 
this was originally official java standard, now

14
00:01:08.680 --> 00:01:11.680 
released in the open source community and further developed

15
00:01:11.680 --> 00:01:17.300 
in the open source community under the roof of the Apache foundation.

16
00:01:17.300 --> 00:01:18.520 
And this is Jakarta EE now.

17
00:01:20.750 --> 00:01:26.560 
Jakarta EE is basically a specification that describes an environment for building

18
00:01:26.920 --> 00:01:31.440 
high level mission-critical enterprise applications. And

19
00:01:31.440 --> 00:01:34.220 
this specification can be implemented by

20
00:01:34.650 --> 00:01:38.980 
an open public specification describing APIS, describing

21
00:01:39.430 --> 00:01:43.790 
interfaces that need to be provided. And if you

22
00:01:44.350 --> 00:01:47.580 
sum up all the requirements and the specifications from java

23
00:01:47.580 --> 00:01:51.690 
EE, you end up with something called an application server. And

24
00:01:51.690 --> 00:01:56.010 
the application server is basically an implementation of the specification.

25
00:01:56.780 --> 00:02:00.430 
And since it's a public specification it can be implemented by

26
00:02:00.560 --> 00:02:04.620 
basically everyone and there are a lot of different implementations

27
00:02:04.770 --> 00:02:07.510 
that are all compliant to the specification.

28
00:02:08.020 --> 00:02:11.700 
Commercial ones and open ones, open source implementations.

29
00:02:12.850 --> 00:02:16.020 
Common ones for example open source are Jboss or GlassFish.

30
00:02:17.360 --> 00:02:18.570 
Now it is called white fly,

31
00:02:19.480 --> 00:02:22.560 
and there are other open liberty. There are many different

32
00:02:23.390 --> 00:02:24.440 
implementations.

33
00:02:25.870 --> 00:02:29.140 
And beyond java EE of course the open source world has created

34
00:02:29.140 --> 00:02:34.260 
a lot of other components, tools, extensions, standards and so on

35
00:02:34.820 --> 00:02:36.560 
that form the java ecosystem.

36
00:02:37.660 --> 00:02:41.940 
So here we have the Apache projects, the eclipse projects. We have

37
00:02:42.250 --> 00:02:44.880 
something like Junit. We have a lot of different IDES.

38
00:02:45.290 --> 00:02:48.190 
We have the spring framework, the play framework and so on. And

39
00:02:48.190 --> 00:02:52.480 
all together is then the java ecosystem, and if you want to use or

40
00:02:53.060 --> 00:02:56.030 
understand java then you basically should get an overview of

41
00:02:56.040 --> 00:02:59.050 
the whole ecosystem not only of the language itself.

42
00:03:01.180 --> 00:03:04.220 
Let's have a closer look on java/ jakarta EE.

43
00:03:06.100 --> 00:03:07.900 
As I said, implementing

44
00:03:09.060 --> 00:03:14.760 
the specification leads to the implementation of a java EE application server .

45
00:03:15.210 --> 00:03:18.790 
Java EE application server is a middleware software

46
00:03:19.300 --> 00:03:23.830 
that runs on the jvm. Of course it usually is written in java itself,

47
00:03:24.040 --> 00:03:27.940 
and it provides an environment for building business applications.

48
00:03:28.630 --> 00:03:31.230 
And for the business applications, we need basically

49
00:03:31.900 --> 00:03:36.530 
different layers. So every business application usually is organized

50
00:03:36.530 --> 00:03:41.270 
into the three tiers of the three layers- presentation tier, business logic tier,

51
00:03:41.690 --> 00:03:45.500 
persistence tier. And persistence tier is typically formed by

52
00:03:45.500 --> 00:03:49.840 
a database management system- can be SQL or SQL based or

53
00:03:50.350 --> 00:03:53.730 
other kind of enterprise information system like for example

54
00:03:54.830 --> 00:03:59.730 
something like maybe an external transactional resource injectional

55
00:03:59.730 --> 00:04:00.990 
system or things like that.

56
00:04:02.530 --> 00:04:07.250 
And persistence tier is there to store persistently the data to

57
00:04:08.280 --> 00:04:10.960 
store and retrieve the data. Then we have the business logic

58
00:04:10.960 --> 00:04:14.760 
here and the actual business logic the processing of the data happens .

59
00:04:14.990 --> 00:04:18.130 
And then we have the presentation here which realizes the user

60
00:04:18.130 --> 00:04:21.530 
interface and the input output to the user or maybe also to

61
00:04:21.740 --> 00:04:23.310 
other programs okay.

62
00:04:24.140 --> 00:04:27.390 
The presentation tier in modern applications is typically

63
00:04:27.460 --> 00:04:31.680 
web based, using web standards html, css, javascript and so on.

64
00:04:31.980 --> 00:04:34.950 
The client is typically a web browser and then we communicate

65
00:04:34.950 --> 00:04:36.990 
using http with the application server.

66
00:04:38.040 --> 00:04:41.730 
The application server has on the top level a web container,

67
00:04:41.830 --> 00:04:46.420 
for example Apache Tomcat to implement the web profile of the java EE

68
00:04:46.540 --> 00:04:50.500 
specification containing technologies to create dynamic web

69
00:04:50.500 --> 00:04:54.220 
pages like javaserver pages, java faces servlets and so on.

70
00:04:54.790 --> 00:04:58.130 
Below that is the component container. This is very specific for

71
00:04:58.440 --> 00:05:03.340 
java EE, for example you will not find a similar concept for example in PHP.

72
00:05:04.370 --> 00:05:08.440 
So it's a unique feature of java. Of course it's very strongly

73
00:05:08.440 --> 00:05:12.390 
inspired by the transaction processing monitors, like cics for example.

74
00:05:13.580 --> 00:05:17.470 
The component container runs so called enterprise java means, also

75
00:05:18.430 --> 00:05:21.340 
alternative implementations like the spring framework, which

76
00:05:21.340 --> 00:05:23.950 
also provides some kind of component container.

77
00:05:24.360 --> 00:05:27.540 
And the idea is that a component is a soft piece of software,

78
00:05:27.540 --> 00:05:30.980 
java class for example that implements a certain business logic

79
00:05:30.980 --> 00:05:35.650 
part of business functionality and gets a lot of service functionality

80
00:05:35.650 --> 00:05:39.910 
from the container. So the developer of the business component

81
00:05:40.650 --> 00:05:43.170 
doesn't need to implement trivial things by hand.

82
00:05:44.700 --> 00:05:47.920 
So this is the fundamental structure of every

83
00:05:48.360 --> 00:05:50.290 
full stack Java EE application.

84
00:05:51.210 --> 00:05:55.300 
And now we'll have a closer look on that.

85
00:05:55.740 --> 00:05:58.970 
So what is the purpose of using such kind of framework. Java EE is

86
00:05:59.160 --> 00:06:02.550 
sometimes criticized for being very complex and having a steep learning curve.

87
00:06:02.930 --> 00:06:06.240 
And that is partially true even though in recent years it has

88
00:06:06.240 --> 00:06:07.450 
been simplified a lot.

89
00:06:08.390 --> 00:06:14.260 
And most recent developments, for example Liberty or Open Liberty

90
00:06:14.420 --> 00:06:18.530 
applications have tried to sort of reduce the complexity to

91
00:06:18.530 --> 00:06:20.870 
the minimum that is needed for certain application.

92
00:06:22.660 --> 00:06:23.610 
Objectives: generally

93
00:06:24.730 --> 00:06:26.330 
to support an efficient and

94
00:06:27.110 --> 00:06:30.900 
faster development of business applications by avoiding coding.

95
00:06:31.480 --> 00:06:35.920 
Things that are already there- so fostering re-use, supporting re-use

96
00:06:36.980 --> 00:06:39.030 
and avoiding implementing

97
00:06:39.690 --> 00:06:43.420 
infrastructure things like security, data access, and so on so.

98
00:06:43.420 --> 00:06:47.450 
This is provided by the framework, so the developer can really focus only on

99
00:06:47.640 --> 00:06:48.750 
business requirements.

100
00:06:50.340 --> 00:06:57.570 
And therefore java EE contains a big number of ready to use frameworks and components

101
00:06:57.720 --> 00:07:01.930 
for standard tasks like for example persisting data, persistence storage.

102
00:07:02.140 --> 00:07:03.580 
Java persistence API,

103
00:07:04.210 --> 00:07:06.910 
transaction, support, handing distributed transactions. It's a

104
00:07:06.910 --> 00:07:09.870 
sort of a transaction processing monitor functionality that's

105
00:07:09.870 --> 00:07:11.550 
implemented in component container.

106
00:07:13.460 --> 00:07:16.940 
Distributed applications, calling remote functions, web services,

107
00:07:16.940 --> 00:07:19.810 
web-based user interfaces- all these stuff that are typical

108
00:07:19.810 --> 00:07:23.220 
for modern applications is more or less implemented, ready to

109
00:07:23.220 --> 00:07:25.010 
use and can be just used by-

110
00:07:25.760 --> 00:07:28.420 
for example configuring the server in the right way.

111
00:07:29.920 --> 00:07:33.820 
The general idea is that java EE abstracts a lot of the underlying

112
00:07:33.820 --> 00:07:37.380 
soft and hardware infrastructure. For example also from the databases

113
00:07:37.580 --> 00:07:38.820 
and things like that.

114
00:07:42.390 --> 00:07:46.100 
On z/Os, on the mainframe and linux on such systems, we have different

115
00:07:46.140 --> 00:07:50.160 
possibilities to use java EE. And java EE has become on z/OS

116
00:07:51.090 --> 00:07:55.360 
beside the classical CICS applications, the second most important

117
00:07:55.540 --> 00:08:02.580 
type of applications because java and java EE is a sort of replacement increasingly replacing cobol,

118
00:08:03.180 --> 00:08:07.750 
and cics, or combined with cobol and cics. So it allows to

119
00:08:08.630 --> 00:08:13.140 
build mission-critical applications and therefore sometimes takes over

120
00:08:13.450 --> 00:08:17.420 
step by step slowly the role of cobol. And this is why it is

121
00:08:17.420 --> 00:08:18.840 
important especially on the mainframe.

122
00:08:21.050 --> 00:08:25.170 
On z/OS  itself, now we have for many years a java EE application server

123
00:08:25.170 --> 00:08:26.870 
called WebSphere, IBM WebSphere

124
00:08:27.820 --> 00:08:29.850 
Application Server and

125
00:08:31.010 --> 00:08:32.730 
the most recent version is the

126
00:08:33.560 --> 00:08:36.460 
WebSphere Application Server for z/OS Liberty which is based

127
00:08:36.460 --> 00:08:39.280 
on the open liberty implementation of java

128
00:08:39.850 --> 00:08:42.430 
EE and this is a very

129
00:08:43.550 --> 00:08:45.900 
modularized and more lightweight approach.

130
00:08:46.390 --> 00:08:49.970 
And it can also be embedded

131
00:08:50.640 --> 00:08:55.220 
in inside cics regions so it can be combined with classical mainframe applications like

132
00:08:55.380 --> 00:08:58.750 
cics applications, cobol etcetera to provide

133
00:08:59.430 --> 00:09:03.570 
a very efficient and lightweight interface to

134
00:09:04.210 --> 00:09:05.820 
combine cobol and java code.

135
00:09:06.850 --> 00:09:08.590 
So this is especially important on z/OS where we have

136
00:09:10.170 --> 00:09:12.210 
classic mainframe cobol workloads.

137
00:09:13.620 --> 00:09:17.550 
On linux für z Systems, on the other hand we have of course the full

138
00:09:17.550 --> 00:09:18.930 
range of open source

139
00:09:19.640 --> 00:09:22.680 
java EE implementations ready at hand because they are written

140
00:09:22.680 --> 00:09:24.980 
in java and then they can be just used on

141
00:09:25.550 --> 00:09:28.890 
on the linux on Z set systems as well,

142
00:09:30.180 --> 00:09:34.390 
for example probably most common one is the WildFly, which is the

143
00:09:35.670 --> 00:09:38.890 
new version of jboss open source version of the jboss application

144
00:09:38.890 --> 00:09:42.790 
server which is a very robust and long time

145
00:09:43.440 --> 00:09:47.460 
existing java EE implementation belonging to red hat now

146
00:09:48.350 --> 00:09:52.760 
which is also used in commercial and business applications in the industry.

147
00:09:53.610 --> 00:09:56.010 
Then we have the open liberty which is the the open source

148
00:09:56.030 --> 00:09:58.840 
version of the liberty application server.

149
00:09:59.440 --> 00:10:02.870 
GlassFish used to be the reference implementation of java EE.

150
00:10:04.110 --> 00:10:06.930 
And of course Apache has a lot of projects in that direction.

151
00:10:07.130 --> 00:10:10.950 
As for example Apache Tomcat which is only the profile but combined with TomEE.

152
00:10:11.240 --> 00:10:13.130 
It's also a container

153
00:10:14.190 --> 00:10:18.030 
anymore there are other implementations. And of course for example

154
00:10:18.030 --> 00:10:22.600 
on linux we have the SAP Netweaver AS application server. SAP netweaver

155
00:10:22.860 --> 00:10:26.080 
is the foundation application server of the SAP

156
00:10:28.650 --> 00:10:32.250 
suite of business applications, COP, CRMN and so on. So it's the

157
00:10:33.100 --> 00:10:38.210 
underlying infrastructure, and it implements also a JEE stick

158
00:10:38.890 --> 00:10:43.690 
for many years now. And this is also available on linux für z Systems.

159
00:10:47.340 --> 00:10:52.390 
In general as I said, a unique feature of JEE is

160
00:10:53.160 --> 00:10:56.260 
the so called enterprise JavaBeans- the components

161
00:10:56.830 --> 00:11:00.750 
that are service components, that are supported by the component

162
00:11:00.750 --> 00:11:03.080 
container or live in the component container.

163
00:11:04.100 --> 00:11:07.550 
And each of these are Server-Side components. In fact they are basic in java classes,

164
00:11:07.730 --> 00:11:11.570 
and there are objects of these classes. And they are managed by the EJB

165
00:11:11.810 --> 00:11:14.780 
container. So the developer for example has not to deal with

166
00:11:14.790 --> 00:11:17.260 
instantiationm creating objects and things like that.

167
00:11:18.650 --> 00:11:23.590 
And they purpose is to encapsulate business logic, encapsulate a piece of

168
00:11:24.120 --> 00:11:27.530 
business logic that fulfills a certain purpose for example

169
00:11:27.540 --> 00:11:29.160 
handling customer data or something like that.

170
00:11:31.960 --> 00:11:37.080 
EJB container provides integrated distributed transaction support to these EJBs.

171
00:11:38.410 --> 00:11:43.350 
By default every method call of an EJB is one distributed transaction. So every

172
00:11:44.190 --> 00:11:48.440 
IO operation done inside this method will belong to one transaction.

173
00:11:50.610 --> 00:11:55.050 
In addition, the component container manages access control, has security features,

174
00:11:55.750 --> 00:11:57.540 
for example role-based access control.

175
00:11:59.070 --> 00:12:02.780 
So not every method can be called by every client depending on authorization.

176
00:12:04.690 --> 00:12:08.190 
And in general the container provides for example support for

177
00:12:08.190 --> 00:12:12.680 
turning an EJB directly into web services soap or web based services.

178
00:12:13.640 --> 00:12:16.470 
To execute EJB methods in the background by a time control

179
00:12:16.470 --> 00:12:20.040 
which is kind of a batch processing mechanism, scheduling mechanism

180
00:12:20.500 --> 00:12:23.690 
and it supports for example dependency injection resolving

181
00:12:24.230 --> 00:12:28.880 
the values of attributes at runtime automatically without the need

182
00:12:29.470 --> 00:12:32.330 
to assign values for example to object variables.

183
00:12:35.100 --> 00:12:36.330 
There are different types of EJBs.

184
00:12:37.190 --> 00:12:40.210 
And three major kinds- the

185
00:12:41.490 --> 00:12:44.570 
first, the Entity "Beans" which are not really EJBs anymore

186
00:12:44.570 --> 00:12:47.770 
since the EJB 3 specification but now they are just normal

187
00:12:47.770 --> 00:12:51.670 
java objects basically. And entity beans describe the business

188
00:12:51.670 --> 00:12:54.920 
objects that are persisted and retrieved from the data store so they

189
00:12:55.140 --> 00:12:56.790 
are the interface to the database.

190
00:12:57.620 --> 00:12:59.580 
We have Session Beans which are

191
00:13:02.820 --> 00:13:06.720 
the most important EJBs and we have three types- the stateless,

192
00:13:06.720 --> 00:13:08.450 
the stateful, and singleton session bean.

193
00:13:10.050 --> 00:13:13.650 
The stateless session bean is a component that

194
00:13:14.980 --> 00:13:18.690 
is not client specific. So every client can get for every call another

195
00:13:19.300 --> 00:13:22.690 
instance and they do not have an internal state and the client

196
00:13:22.690 --> 00:13:26.450 
cannot rely on the internal state because you don't know which

197
00:13:26.450 --> 00:13:27.970 
object you get the next time.

198
00:13:29.340 --> 00:13:32.210 
A stateful session bean is client specific so every client

199
00:13:32.220 --> 00:13:35.120 
accessing the server has during the session

200
00:13:35.590 --> 00:13:39.190 
the same instance of this EJB and can also

201
00:13:39.730 --> 00:13:42.070 
keep data inside the EJB object.

202
00:13:42.980 --> 00:13:45.730 
And the singleton implements a singleton so it has a state

203
00:13:45.730 --> 00:13:48.460 
but it's the same for all clients. So it's a global object.

204
00:13:49.880 --> 00:13:52.650 
The singleton pattern has been specified in the book.

205
00:13:55.580 --> 00:13:58.680 
And then the third category- a message driven beans. Message

206
00:13:58.680 --> 00:14:02.180 
driven beans are listeners to a message queue. So every time

207
00:14:02.180 --> 00:14:05.020 
a message comes asynchronously, the message driven bean

208
00:14:05.020 --> 00:14:07.410 
gets notified and processes the message.

209
00:14:08.180 --> 00:14:12.280 
And this can be used on the mainframe, for example as a listener or

210
00:14:12.280 --> 00:14:16.400 
integrated with a message queue with the MQ product on

211
00:14:18.060 --> 00:14:19.640 
z/OS by JMS Bridge. So that java

212
00:14:20.480 --> 00:14:23.750 
bean can read messages for example from the MQ

213
00:14:24.680 --> 00:14:25.660 
message queuing system.

214
00:14:26.690 --> 00:14:29.810 
Finally here is an example of a simple

215
00:14:30.560 --> 00:14:33.840 
enterprise java bean- a stateless enterprise java bean. So the most

216
00:14:34.330 --> 00:14:35.410 
typical, most common

217
00:14:36.830 --> 00:14:39.280 
type of java beans to illustrate the

218
00:14:40.270 --> 00:14:42.860 
concept. So this

219
00:14:43.520 --> 00:14:45.770 
enterprise java bean class implements

220
00:14:46.520 --> 00:14:48.670 
a simple book store functionality

221
00:14:49.460 --> 00:14:52.140 
and it's called BookEJB. And

222
00:14:53.510 --> 00:14:56.450 
basically you see that it looks like a normal java class.

223
00:14:56.450 --> 00:15:01.170 
It is basically first of all a standard java class and a java code.

224
00:15:01.510 --> 00:15:07.570 
It is marked as an EJB for the container, for the EJB container to be

225
00:15:08.790 --> 00:15:12.740 
maintained and used as an EJB by annotation. So this is the stateless

226
00:15:12.740 --> 00:15:16.730 
annotation that basically indicates that this class is a stateless

227
00:15:16.750 --> 00:15:17.980 
session bean for example.

228
00:15:19.810 --> 00:15:23.460 
Notations start in java typically with or always with an @

229
00:15:23.460 --> 00:15:27.310 
sign and they are kind of markers of text that

230
00:15:28.080 --> 00:15:32.560 
are not really code that is executed but they are used to give

231
00:15:32.570 --> 00:15:36.050 
a hint on information to a runtime environment, in this case the

232
00:15:36.370 --> 00:15:37.120 
EJB container.

233
00:15:39.020 --> 00:15:42.700 
The class has two methods the EJB has two methods- one is findBook

234
00:15:42.700 --> 00:15:46.180 
and one is createBook. So it's a simple bookstore that

235
00:15:46.180 --> 00:15:51.180 
you can get books from and put books in to illustrate simple data operations.

236
00:15:51.510 --> 00:15:56.580 
And in this case this uses JPA in java entity beans. The entity bean-

237
00:15:56.810 --> 00:16:00.090 
a class is not given here but it's called the book. So we think

238
00:16:00.090 --> 00:16:03.650 
of it as a representation of data of a book and

239
00:16:05.100 --> 00:16:09.190 
this object is a book objects can be stored in the database by the

240
00:16:09.430 --> 00:16:15.540 
createBook method. So you hand over the object and it is persisted

241
00:16:15.540 --> 00:16:19.490 
using the entity manager. To insert the book in the database,

242
00:16:19.490 --> 00:16:23.160 
to transform it from an object or into a database notation

243
00:16:23.740 --> 00:16:27.060 
regardless of which kind of database it is. It's just handed by

244
00:16:27.170 --> 00:16:30.960 
JPA, so EM persist writes this book object in the database.

245
00:16:32.570 --> 00:16:36.290 
Same as the find method, it is given a

246
00:16:36.730 --> 00:16:41.170 
numerical ID, sort of primary key of the object and we get

247
00:16:41.170 --> 00:16:42.860 
back the full object. So JPA

248
00:16:44.590 --> 00:16:47.690 
as part of the EJB framework turns the

249
00:16:48.550 --> 00:16:53.990 
book object into a database representation sensitive database,

250
00:16:53.990 --> 00:16:55.690 
inserts it there and retrieves it there.

251
00:16:56.610 --> 00:17:01.580 
As you can see we do not have to write any kind of sql or database

252
00:17:01.580 --> 00:17:03.050 
query language code for that.

253
00:17:03.770 --> 00:17:07.590 
We do not have to deal with handling transaction boundaries,

254
00:17:07.610 --> 00:17:10.330 
opening and committing a transaction for example. This is all

255
00:17:10.330 --> 00:17:15.990 
handled by the container. Every method of an EJB- in this case two methods here

256
00:17:16.300 --> 00:17:21.410 
is by default one transaction. And every data operation done

257
00:17:21.410 --> 00:17:24.990 
inside belongs to that. It could be even a distributed transaction.

258
00:17:24.990 --> 00:17:30.310 
So that is the transaction monitor functionality provided by java EE. And

259
00:17:31.960 --> 00:17:35.930 
I always handed by a so-called entity manager object which is

260
00:17:36.140 --> 00:17:39.690 
an abstraction of the database, of the underlying database

261
00:17:40.200 --> 00:17:43.430 
realized by the JPA- Java Persistence API framework.

262
00:17:44.160 --> 00:17:46.520 
And as you can see, in this EJB

263
00:17:47.910 --> 00:17:52.390 
no value is assigned to the variable M. This is not necessary

264
00:17:52.840 --> 00:17:58.230 
because here we use dependency injection, the annotation persistence context here.

265
00:17:58.770 --> 00:18:05.360 
And EM should contain a connection or a presentation of the connection

266
00:18:05.590 --> 00:18:09.480 
to the database name, book star, which has been defined beforehand,

267
00:18:09.480 --> 00:18:12.010 
and the configuration of the server. And now the

268
00:18:13.740 --> 00:18:17.020 
EJB container ensures that every time EM is used like here or here

269
00:18:17.640 --> 00:18:21.180 
automatically the right object is injected

270
00:18:22.140 --> 00:18:27.040 
in the background before the call is executed. So this is completely

271
00:18:27.040 --> 00:18:28.490 
transparent to the developer.

272
00:18:29.390 --> 00:18:32.440 
What you can see here is the developer really can focus on

273
00:18:32.440 --> 00:18:35.290 
the business logic so he can think about ok or he or she can

274
00:18:35.290 --> 00:18:38.180 
think about how to find the object, how to persist the object.

275
00:18:38.180 --> 00:18:41.140 
You do not have to actually write the data operations. Do not

276
00:18:41.140 --> 00:18:45.800 
have to write the transaction handling. So it basically the full functionality is achieved

277
00:18:46.790 --> 00:18:49.690 
two lines of code or two actual statements that

278
00:18:49.920 --> 00:18:51.330 
do the actual work. So

279
00:18:52.100 --> 00:18:54.980 
it is very efficient and it reduces the

280
00:18:55.470 --> 00:18:57.850 
number of lines of code the developers have to write

281
00:18:58.260 --> 00:19:03.150 
and allow the developers to focus on the business functionality. And that is

282
00:19:03.700 --> 00:19:05.540 
one of the main strengths of EJB

283
00:19:07.100 --> 00:19:08.240 
and java enterprise.

284
00:19:09.900 --> 00:19:10.720 
Thank you very much.
