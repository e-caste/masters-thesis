WEBVTT

1
00:00:00.390 --> 00:00:04.190 
Hello and welcome to the second
video about training sequences,

2
00:00:04.420 --> 00:00:06.320 
so the input of the
machine learner.

3
00:00:07.480 --> 00:00:11.140 
This is the question that will guide
us through this second video.

4
00:00:11.680 --> 00:00:15.440 
So let us remember in the last
video we saw that learning means

5
00:00:15.440 --> 00:00:18.980 
that a machine learner gets fed
this training sequences and

6
00:00:18.990 --> 00:00:20.320 
outputs a
prediction model.

7
00:00:21.480 --> 00:00:25.300 
But the prediction model is a
function that assigns values

8
00:00:25.300 --> 00:00:30.080 
zero or one standing for no and
yes to a question. So we want

9
00:00:30.080 --> 00:00:34.180 
some framework that works for every
question, not only for the one

10
00:00:34.370 --> 00:00:36.050 
that we saw in
the last video.

11
00:00:37.100 --> 00:00:40.660 
Ok so what is the prediction
model, where we say that a that

12
00:00:40.660 --> 00:00:44.880 
the domain of the prediction model is just
the natural numbers and it labels them?

13
00:00:46.350 --> 00:00:49.870 
Ok and the set of all training
sequences, well what is this

14
00:00:49.870 --> 00:00:54.930 
now? Ok so we have finite sequences, often
natural numbers that are already labelled.

15
00:00:56.150 --> 00:01:00.060 
Hmm why does this fit to our
illustrating example of

16
00:01:00.060 --> 00:01:02.950 
finding out whether there is a
butterfly on a picture? Let's see.

17
00:01:04.360 --> 00:01:08.880 
Ok so we have a picture, for example
of fifty times thirty pixels

18
00:01:09.170 --> 00:01:13.260 
and we have colour vectors or
color values for every pixel

19
00:01:13.400 --> 00:01:17.760 
which gives us in the end a vector with
four thousand five hundred color vectors.

20
00:01:18.650 --> 00:01:22.950 
Ok so if we know the height
and the width of the

21
00:01:22.960 --> 00:01:27.050 
image then we can use this vector
to reconstruct the image.

22
00:01:28.530 --> 00:01:32.940 
Ok so the image is uniquely specified
by its height, its width and

23
00:01:32.940 --> 00:01:33.680 
the color vector.

24
00:01:36.140 --> 00:01:40.670 
Now how can we use this to encode
an image into a natural number?

25
00:01:41.430 --> 00:01:45.430 
we want it so that we can know
which image it was in the end.

26
00:01:46.580 --> 00:01:51.110 
Ok I will show you one
way to think of it.

27
00:01:51.890 --> 00:01:55.720 
So if the height is fifty, the
width is thirty and this is the

28
00:01:55.880 --> 00:01:59.970 
area of color values on
the vector then we can

29
00:01:59.970 --> 00:02:02.140 
write this in binary
representation

30
00:02:02.780 --> 00:02:07.920 
and then we well we merge the
sequences. We first merge the

31
00:02:07.920 --> 00:02:11.760 
height and the with binary sequence
and we obtain another binary

32
00:02:11.760 --> 00:02:14.910 
sequence, but we know how to
interpret it since we know that

33
00:02:14.920 --> 00:02:16.280 
we use the
merge method.

34
00:02:17.000 --> 00:02:21.480 
And now we have two binary vectors. And
we can again use the merge method

35
00:02:21.790 --> 00:02:25.900 
to merge them and then we get a bit
string, well, one bit string.

36
00:02:25.900 --> 00:02:29.120 
This is the important thing and
we know how to reconstruct

37
00:02:29.120 --> 00:02:32.710 
the original bit strings because we
know that we use the merge method.

38
00:02:33.720 --> 00:02:37.540 
Ok so we can evaluate this binary
representation and we get

39
00:02:37.540 --> 00:02:41.380 
a natural number and this natural
number is a code for the

40
00:02:41.390 --> 00:02:42.610 
image we started with.

41
00:02:44.260 --> 00:02:48.370 
Well ok. But we want to do with
the other way around too. So

42
00:02:48.370 --> 00:02:53.020 
let's look at a well I agree that
it's a large natural number

43
00:02:53.130 --> 00:02:56.580 
but let's see. Does it encode an
image? Which one does it encode?

44
00:02:57.260 --> 00:03:02.920 
So we right it in a binary system, it
looks like this, and then we well we

45
00:03:03.130 --> 00:03:07.500 
unmerge it and then we get
two binary sequences.

46
00:03:08.330 --> 00:03:10.310 
We unmerge the
first one again

47
00:03:11.690 --> 00:03:16.130 
and now we see already one zero
is the representation for two,

48
00:03:16.240 --> 00:03:18.980 
the binary representation for
the decimal number two,

49
00:03:19.750 --> 00:03:23.020 
and yeah so we have a
two times two image

50
00:03:24.310 --> 00:03:26.860 
and we have the colour
vectors that you see there.

51
00:03:28.000 --> 00:03:29.950 
So it wasn't
this image.

52
00:03:32.630 --> 00:03:36.790 
Ok so we defined the prediction
model as labeling natural numbers.

53
00:03:37.620 --> 00:03:41.840 
We saw that the training sequences
are finite sequences of

54
00:03:41.840 --> 00:03:46.940 
such labeled natural numbers and
we argued that a natural number

55
00:03:46.940 --> 00:03:52.320 
is indeed an image in a unique way
and we know which image it is.

56
00:03:53.450 --> 00:03:56.540 
So this matches the binary
classification of images that we

57
00:03:56.540 --> 00:03:58.540 
talked about in the
first video already

58
00:03:59.350 --> 00:04:03.910 
and also I mean if we don't have the
image itself but some feature vector

59
00:04:04.100 --> 00:04:08.260 
we can do the exact same thing,
just not having color values

60
00:04:08.610 --> 00:04:10.220 
but maybe other values.

61
00:04:13.200 --> 00:04:17.930 
And umm well if you ask me now how this
is standard practice there is no

62
00:04:18.040 --> 00:04:22.480 
one answer. So it depends on the
electronic device how these

63
00:04:22.480 --> 00:04:24.940 
vectors or images are
represented in detail.

64
00:04:27.230 --> 00:04:31.210 
So to sum up, in this video we
clarified what the domain of

65
00:04:31.210 --> 00:04:35.340 
the machine learner is, namely finite
labeled sequences of natural numbers.

66
00:04:36.210 --> 00:04:39.890 
And in the next video we will
clarify what the range is.
