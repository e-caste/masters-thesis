WEBVTT

1
00:00:00.810 --> 00:00:04.350 
Now we consider asymmetric
encryption methods in our openHPI

2
00:00:04.920 --> 00:00:08.780 
course "Confidential Communication
in the Internet". You remember

3
00:00:09.210 --> 00:00:14.320 
the characteristic of this
symmetric encryption methods was

4
00:00:14.550 --> 00:00:19.030 
that they use two keys.
They use a key pair

5
00:00:19.690 --> 00:00:22.190 
for encryption and
for decryption.

6
00:00:22.920 --> 00:00:27.540 
So the private key, this was one
of the two must be kept secret.

7
00:00:27.550 --> 00:00:31.760 
Only the owner of the key pair

8
00:00:33.260 --> 00:00:38.150 
can know the private key. No one
else, no communication partner

9
00:00:39.680 --> 00:00:43.700 
is allowed to know him. And then we
have a public key and the name

10
00:00:43.810 --> 00:00:49.260 
public comes from the fact that this
key have to be made available

11
00:00:49.460 --> 00:00:51.880 
to all the other
communication partners.

12
00:00:52.850 --> 00:00:58.470 
Now the idea is, we can take a message
and can encrypt the message

13
00:00:58.470 --> 00:01:03.520 
with the public key and then the
only way to decrypt this document

14
00:01:03.710 --> 00:01:06.160 
is to use the corresponding
private key.

15
00:01:07.510 --> 00:01:13.020 
And the same is true in a reverse
direction. A message can be

16
00:01:13.020 --> 00:01:14.810 
encrypted with a
private key

17
00:01:15.620 --> 00:01:19.730 
and then it can only be decrypted
with the corresponding public key.

18
00:01:20.900 --> 00:01:25.700 
An important objective
is that it is

19
00:01:26.410 --> 00:01:28.810 
practically impossible

20
00:01:29.510 --> 00:01:36.840 
to construct the private key from the
public one. The public one knows everyone

21
00:01:37.010 --> 00:01:40.840 
and though it should not be
possible for anyone to

22
00:01:41.690 --> 00:01:48.000 
conclude from the public art, from
the public key to the private key.

23
00:01:49.610 --> 00:01:53.380 
So what are the prerequisites for
such an asymmetric encryption?

24
00:01:54.340 --> 00:02:01.500 
Each participant in this communication
have a key pair - have a private key

25
00:02:01.960 --> 00:02:04.570 
which they have

26
00:02:06.290 --> 00:02:12.060 
to keep secret and a public key
which is a public accessible.

27
00:02:13.330 --> 00:02:18.980 
The private key can be securely
assigned to a participant

28
00:02:19.230 --> 00:02:24.880 
because only this participant has this
private key. No one else knows it.

29
00:02:26.030 --> 00:02:30.440 
So now let's look how the encryption
is working. The encryption is

30
00:02:30.600 --> 00:02:36.980 
working, let's take a message and
then the message should be sent

31
00:02:37.220 --> 00:02:43.610 
from Bob to Alice, then Bob
who encrypts the message takes

32
00:02:43.610 --> 00:02:45.330 
a public key from Alice,

33
00:02:46.810 --> 00:02:51.440 
encrypts the message and
sends it to Alice.

34
00:02:51.870 --> 00:02:57.470 
And then Alice is able to decrypt this
message by their own private key.

35
00:02:58.320 --> 00:03:01.390 
So we have the text, we
take the public key

36
00:03:02.080 --> 00:03:05.520 
from Alice, we encrypt this

37
00:03:06.190 --> 00:03:13.030 
with our function and then with
the private key of Alice,

38
00:03:14.950 --> 00:03:17.560 
I have to - this was

39
00:03:18.280 --> 00:03:23.070 
the public key of Alice and Alice
is unable with the private key

40
00:03:23.490 --> 00:03:29.290 
to reproduce the original text
out of this encrypted message.

41
00:03:30.140 --> 00:03:36.860 
So, and the encrypted message stays
confidential. After Bob has encrypted

42
00:03:37.290 --> 00:03:40.920 
the text, this is a ciphertext,
has encrypted the

43
00:03:41.390 --> 00:03:46.700 
text with the
public key from Alice,

44
00:03:47.250 --> 00:03:52.650 
no one else, only Alice, is able to
decrypt the text because she

45
00:03:53.490 --> 00:03:56.630 
has the corresponding
private key.

46
00:03:58.480 --> 00:04:02.530 
So encryption of a message with
the subscriber's private key

47
00:04:02.950 --> 00:04:08.680 
allows anyone to verify the message
really originated from the sender.

48
00:04:09.230 --> 00:04:15.540 
So if we encrypt the message
with the private key of Bob,

49
00:04:16.840 --> 00:04:22.320 
then everyone knows the public key of
Bob, everyone can take the public key

50
00:04:22.640 --> 00:04:28.620 
and can decrypt this message and in
this way he or she can conclude that

51
00:04:29.310 --> 00:04:34.900 
this message comes definitely from
Bob because he was the only

52
00:04:35.720 --> 00:04:39.040 
who was able to encrypt it in
such a way with his private key

53
00:04:39.340 --> 00:04:41.440 
that it could be decrypted
with his public key.

54
00:04:42.180 --> 00:04:47.590 
Here, Bob takes the
private key of a text.

55
00:04:47.990 --> 00:04:50.600 
This is encrypted,
this is a ciphertext,

56
00:04:51.030 --> 00:04:54.370 
and anyone who takes
the or applies the

57
00:04:55.180 --> 00:04:58.430 
decryption function with
the public key of Bob

58
00:04:59.240 --> 00:05:02.280 
gets back the
text. So here

59
00:05:02.930 --> 00:05:09.420 
with this application, this
form of application, we can

60
00:05:09.420 --> 00:05:13.010 
ensure the legal binding
of the message and its

61
00:05:13.950 --> 00:05:19.740 
sender and in this way we can
prove the authenticity

62
00:05:20.270 --> 00:05:21.090 
of the sender.

63
00:05:24.150 --> 00:05:27.570 
But both approaches
only work

64
00:05:28.220 --> 00:05:30.860 
if the public key is
not compromised.

65
00:05:31.970 --> 00:05:35.480 
It's really clear that this
is the public key of Alice

66
00:05:36.080 --> 00:05:37.290 
or the public
key of Bob,

67
00:05:38.040 --> 00:05:40.560 
and second that
the private key

68
00:05:41.170 --> 00:05:42.710 
was kept secret.

69
00:05:44.050 --> 00:05:48.660 
So these are the basic idea
of asymmetric encryption.

70
00:05:49.090 --> 00:05:55.390 
And now let's have a closer look
to the most famous, most popular

71
00:05:56.510 --> 00:05:59.020 
encryption algorithms.

72
00:06:00.570 --> 00:06:03.850 
Asymmetric encryption
algorithms, the RSA algorithm.

73
00:06:04.790 --> 00:06:08.800 
So RSA encryption is the most
famous and most widespread

74
00:06:09.110 --> 00:06:15.210 
assymetric 2-key encryption. It was,
and the name came from the developer.

75
00:06:15.560 --> 00:06:17.860 
It was developed in
nineteen seventy seven.

76
00:06:18.280 --> 00:06:23.890 
Ron Rivest is a famous

77
00:06:25.470 --> 00:06:29.110 
such algorithm designer for
such cryptographic algorithms.

78
00:06:29.660 --> 00:06:31.560 
Adi Shamir is a famous

79
00:06:32.350 --> 00:06:34.910 
security analyst

80
00:06:35.550 --> 00:06:41.310 
who analyzes and such crypto
analyst and Leonard Adleman

81
00:06:41.310 --> 00:06:47.170 
was a PhD student and they developed
in nineteen seventy seven this RSA

82
00:06:48.650 --> 00:06:54.840 
algorithm and in complete difference to
the symmetric encryption algorithm,

83
00:06:55.460 --> 00:07:00.230 
the asymmetric encryption algorithm
like RSA is based on

84
00:07:00.740 --> 00:07:05.270 
difficult mathematical problems.
In the case of RSA,

85
00:07:05.270 --> 00:07:09.480 
it is a mathematical
problem of factorization.

86
00:07:10.280 --> 00:07:13.790 
That means to check

87
00:07:14.470 --> 00:07:19.360 
whether two very large randomly
selected prime numbers,

88
00:07:20.010 --> 00:07:27.340 
whether a big number which is a product of two
very large randomly selected prime numbers,

89
00:07:28.120 --> 00:07:32.530 
it can be factorized without the
knowledge of the two prime

90
00:07:32.530 --> 00:07:34.460 
numbers. This is a
factorization problem

91
00:07:35.910 --> 00:07:39.500 
and when we speak about large
numbers and its numbers with

92
00:07:39.560 --> 00:07:41.490 
more than a
hundred igits.

93
00:07:43.220 --> 00:07:46.640 
So the RSA procedure
and we show

94
00:07:48.050 --> 00:07:48.920 
how it works

95
00:07:50.220 --> 00:07:55.420 
at hand of small numbers. In practice
of course these are huge numbers

96
00:07:55.560 --> 00:08:00.940 
which are used here. The starting point is
that one has to select two prime numbers.

97
00:08:02.170 --> 00:08:06.040 
We take some small one, we take
seventeen and thirty one

98
00:08:06.540 --> 00:08:14.030 
and then calculate the product,
the N. The N is p times q and in

99
00:08:14.030 --> 00:08:20.080 
our case, N seventeen times thirty
one is five hundred twenty seven.

100
00:08:21.280 --> 00:08:23.260 
So the attacker

101
00:08:24.950 --> 00:08:30.830 
has to answer the question, has to
find p and q out of this number

102
00:08:32.670 --> 00:08:40.920 
and this is almost impossible if p
and q are very large prime

103
00:08:41.050 --> 00:08:47.530 
numbers. Then the third step is
that this so called Eulerian

104
00:08:47.540 --> 00:08:49.190 
Phi function is computed.

105
00:08:50.210 --> 00:08:55.740 
And this is in case of the product
of two if N is a product

106
00:08:55.740 --> 00:09:00.150 
of two prime numbers, it's quite
easy because it's simple. The product

107
00:09:00.150 --> 00:09:03.050 
of p minus one
times q minus one.

108
00:09:04.630 --> 00:09:11.900 
And in our case the Eulerian Phi
function can simply be computed

109
00:09:11.900 --> 00:09:16.060 
sixteen (seventeen minus one) times
thirty (thirty one minus one)

110
00:09:16.100 --> 00:09:17.820 
and this is forty eight.

111
00:09:19.490 --> 00:09:27.080 
And then we can generate the
key pair for the two

112
00:09:27.200 --> 00:09:29.390 
participations in
our communication.

113
00:09:30.360 --> 00:09:37.660 
So to this end we select a number e
which is smaller than the Eulerian-Phi

114
00:09:38.180 --> 00:09:42.820 
of N function and it is
not divisible by this.

115
00:09:43.440 --> 00:09:49.420 
So for example we can choose e equal to
thirteen. It is smaller than four hundred

116
00:09:49.660 --> 00:09:53.240 
what was it four hundred twenty
eight and it is not divisible

117
00:09:53.410 --> 00:09:57.980 
and then the pair thirteen and our
product five hundred twenty seven,

118
00:09:58.130 --> 00:10:06.400 
it's a public key. And then we have
to find the multiplicative inverse d

119
00:10:06.840 --> 00:10:11.730 
from e with regard mod
Phi of N and then

120
00:10:12.070 --> 00:10:17.840 
this d gives the, in
our case computation is

121
00:10:17.840 --> 00:10:24.590 
thirty seven, in our simple example
because e times thirteen times

122
00:10:24.890 --> 00:10:30.000 
thirty seven is mod forty eight is
equal to one. So

123
00:10:31.210 --> 00:10:34.950 
this is a public key
and this is the private key

124
00:10:35.300 --> 00:10:38.350 
of the participant of
our communication.

125
00:10:39.970 --> 00:10:44.900 
So in the end only e, d, N are needed
to generate the public key

126
00:10:45.140 --> 00:10:49.940 
e,N and d,N.

127
00:10:51.140 --> 00:10:55.690 
so now we can apply the procedure. So
you have a communication partner

128
00:10:56.510 --> 00:11:01.360 
who has the public who has a key pair
of the public and the private key.

129
00:11:01.920 --> 00:11:08.460 
We take the message. The message in
this case is considered a number

130
00:11:09.210 --> 00:11:15.300 
and we compute the
a code, the cipher code

131
00:11:16.010 --> 00:11:23.750 
a ciphertext of this message by
computing this number e mod N.

132
00:11:25.070 --> 00:11:30.500 
And the message can be then re-
computed decrypted from the cipher

133
00:11:31.210 --> 00:11:34.040 
by cipher to the power d mod N.

134
00:11:35.540 --> 00:11:40.450 
So by the way here
we should write cipher

135
00:11:42.160 --> 00:11:45.650 
instead of code to
see this number text.

136
00:11:46.470 --> 00:11:49.480 
So the encryption and decryption
with the private and public

137
00:11:49.480 --> 00:11:51.180 
key now works
as following.

138
00:11:51.940 --> 00:11:57.610 
We have the message. Message
to e gives the ciphercode and

139
00:11:57.770 --> 00:12:00.490 
then we can - so this is cipher -

140
00:12:02.860 --> 00:12:08.350 
and then we can do this encryption and
decryption in the reverse order

141
00:12:08.550 --> 00:12:14.020 
taking the private key for computing
the ciphertext and taking

142
00:12:14.020 --> 00:12:18.310 
the public key for computing the
message. Remember we had those two

143
00:12:18.590 --> 00:12:23.720 
applications that we can
encrypt with the public key and

144
00:12:23.720 --> 00:12:29.990 
then we can encode with a private
key. We have this in both cases.

145
00:12:31.240 --> 00:12:36.520 
So in our example let's
make it concrete now.

146
00:12:36.950 --> 00:12:42.840 
The communication partner B, Bob,
will send to Alice the message

147
00:12:43.310 --> 00:12:48.530 
"456". It's also a very
simple message and it's a number

148
00:12:48.530 --> 00:12:50.820 
because we have to
compute a number

149
00:12:51.480 --> 00:12:56.760 
computation but a string every time
can be interpreted as a number.

150
00:12:58.080 --> 00:13:06.190 
So B gets the public
key (e,N) as we have described

151
00:13:06.630 --> 00:13:10.200 
from A. So B takes

152
00:13:11.300 --> 00:13:17.750 
what we have e,N and d,N
are the private and the public key

153
00:13:17.890 --> 00:13:22.050 
from Alice. Bob will
send Alice a message.

154
00:13:22.720 --> 00:13:26.390 
So he takes the
public key from A

155
00:13:27.040 --> 00:13:32.100 
and encrypts "456". The
message 456 by 456

156
00:13:32.100 --> 00:13:36.930 
to the e mod N is 456 to the
power 13 mod and it is

157
00:13:37.180 --> 00:13:39.550 
this number. This
is a cipher

158
00:13:40.190 --> 00:13:46.140 
text of this message and it's encoded
with the public key of Alice.

159
00:13:47.280 --> 00:13:54.310 
And then B sends this ciphertext
via the open internet to A

160
00:13:54.770 --> 00:14:01.730 
and then Alice can detect this
by applying her private key.

161
00:14:02.080 --> 00:14:09.980 
They can decrypt the cipher back
to the original message simply

162
00:14:09.980 --> 00:14:14.090 
by computing four hundred forty
seven to thirty seven. This

163
00:14:14.090 --> 00:14:19.220 
was her private key mod
this way and this is exactly our

164
00:14:19.340 --> 00:14:21.030 
message four five six.

165
00:14:23.140 --> 00:14:24.890 
This is the
encryption way.

166
00:14:25.670 --> 00:14:28.840 
And the way around
that Bob

167
00:14:29.540 --> 00:14:32.920 
takes his private key
to encrypt a message,

168
00:14:33.530 --> 00:14:38.370 
this is a way to convince all the
other communication partner that

169
00:14:38.500 --> 00:14:43.580 
he, Bob, was the one who
sent this message.

170
00:14:46.120 --> 00:14:50.520 
A few remarks that this mathematical
computation is really correct

171
00:14:50.990 --> 00:14:57.010 
and this is based on a mathematical
theorem, the so called Fermat's

172
00:14:57.520 --> 00:15:00.030 
theorem. We are
here in the

173
00:15:00.640 --> 00:15:06.280 
area of number theory, so
this fact, this Fermat's

174
00:15:06.730 --> 00:15:13.180 
little theorem says for any a and
any prime number p it holds

175
00:15:13.430 --> 00:15:17.820 
a to the p minus one is
congruent one mod p

176
00:15:18.510 --> 00:15:19.940 
if and only if,

177
00:15:21.560 --> 00:15:24.540 
no - if a is not a
multiple of p.

178
00:15:25.720 --> 00:15:29.880 
So the chain of evidence
now if e times d

179
00:15:30.320 --> 00:15:37.100 
equals one, this was exactly how we
computed the private key d

180
00:15:37.290 --> 00:15:44.190 
from the selected e, then there exist
an e and x with the property

181
00:15:44.410 --> 00:15:47.690 
that e times d
minus one is x

182
00:15:48.760 --> 00:15:53.140 
times p minus one
times p minus one.

183
00:15:53.810 --> 00:15:57.250 
So this is a little bit
complicated, is not necessary to

184
00:15:58.070 --> 00:16:03.250 
to understand this to this extent.
So people who are interested

185
00:16:03.250 --> 00:16:08.190 
are invited to look to the more
deeper information in other courses

186
00:16:08.530 --> 00:16:13.950 
about internet security. But it gives
a good feeling about the nature

187
00:16:14.680 --> 00:16:17.480 
how this asymmetric
encryption methods

188
00:16:18.710 --> 00:16:26.010 
are working, they are computed and
now we have to look into more detail

189
00:16:26.120 --> 00:16:27.390 
how they are employed.
