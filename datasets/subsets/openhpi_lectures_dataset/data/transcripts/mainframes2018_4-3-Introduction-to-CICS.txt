WEBVTT

1
00:00:01.710 --> 00:00:05.960 
Welcome to our introduction to CICS. My name is Philipp Brune

2
00:00:06.420 --> 00:00:09.370 
from the Neu-Ulm university of Applied Sciences.

3
00:00:11.880 --> 00:00:16.740 
CICS our kicks, differently pronounced sometimes is a transaction

4
00:00:16.740 --> 00:00:19.680 
processing monitor. It's the dominating

5
00:00:20.420 --> 00:00:25.410 
transaction processing monitor application on z/OS. And

6
00:00:26.800 --> 00:00:32.430 
transaction processing monitors are a crucial component, middleware component,a software

7
00:00:32.570 --> 00:00:36.490 
to implement online transaction processing applications or OLTP

8
00:00:37.330 --> 00:00:38.810 
applications or systems.

9
00:00:39.710 --> 00:00:44.780 
The basic purpose of an OLTP system is to execute electronic business activities

10
00:00:45.470 --> 00:00:49.990 
typically form a transactional, we call transaction and these transactions

11
00:00:49.990 --> 00:00:53.060 
are invoked from clients/client devices.

12
00:00:53.820 --> 00:00:55.330 
In the past this used to be

13
00:00:56.740 --> 00:01:04.040 
thirty to seventy terminals but it can be also, today of course, it's

14
00:01:04.230 --> 00:01:06.310 
web applications, mobile applications. Or

15
00:01:07.610 --> 00:01:10.850 
there are special client systems, client devices like for example

16
00:01:11.290 --> 00:01:14.440 
automated teller machines or other special purpose hardware.

17
00:01:14.640 --> 00:01:17.350 
So a client device invokes a transaction

18
00:01:18.250 --> 00:01:22.690 
on the mainframe system and or on the application,

19
00:01:23.310 --> 00:01:27.490 
and usually this involves accessing so called transactional

20
00:01:27.490 --> 00:01:30.740 
resources. We learned that in the introduction, for example, a

21
00:01:30.850 --> 00:01:35.090 
transactional resource could be a relational or non relational database management system.

22
00:01:35.420 --> 00:01:40.610 
And there are multiple reads/write operations part of the

23
00:01:42.370 --> 00:01:44.060 
access to the database.

24
00:01:44.850 --> 00:01:46.860 
CICS promotes CICS

25
00:01:47.750 --> 00:01:52.950 
stands for Customer Information Control System and it's a transaction processing monitor,

26
00:01:53.630 --> 00:01:58.410 
and purpose is to coordinate multiple transactional resources,

27
00:01:58.490 --> 00:02:03.220 
for example database management systems as part of distributed transactions.

28
00:02:03.420 --> 00:02:07.370 
And therefore transaction processing monitors use the Two-Phase

29
00:02:07.370 --> 00:02:09.280 
Commit Protocol, we had that in the introduction.

30
00:02:10.840 --> 00:02:12.840 
The main properties of

31
00:02:13.830 --> 00:02:16.670 
the product of CICS is

32
00:02:18.410 --> 00:02:25.540 
its software package- IBM a very traditional software package existing for decades now.

33
00:02:26.090 --> 00:02:29.900 
And in the beginning it was a classical z/OS mainframe product but

34
00:02:30.050 --> 00:02:33.250 
nowadays there also exists ported versions for other operating

35
00:02:33.250 --> 00:02:36.220 
system, also for other platforms like x eighty six,

36
00:02:36.970 --> 00:02:39.380 
linux, windows and so on. But these

37
00:02:40.490 --> 00:02:43.590 
are compatible but partially compatible but

38
00:02:44.390 --> 00:02:46.660 
in the core build on a different source code base

39
00:02:47.500 --> 00:02:49.420 
than the mainframe z/OS product.

40
00:02:52.840 --> 00:02:59.050 
So on a z/OS CICS runs as a task- started task in

41
00:03:00.170 --> 00:03:05.070 
its own region, in its own address space which on address space and basically

42
00:03:05.490 --> 00:03:07.960 
behaves a little bit like an operating system in an operating

43
00:03:07.960 --> 00:03:13.110 
system. So it's a task that is controlled by z/OS but

44
00:03:13.130 --> 00:03:16.990 
inside it does a lot of things that our operation system, likely

45
00:03:17.010 --> 00:03:21.640 
for example, it makes its own handling of task management to achieve maximum

46
00:03:21.820 --> 00:03:23.170 
transaction performance.

47
00:03:24.270 --> 00:03:28.920 
And cics programs which are also called transaction service.

48
00:03:28.970 --> 00:03:32.390 
So these are the programs that actually implement transactions.

49
00:03:33.970 --> 00:03:37.750 
Normally only communicate or in general only communicate with

50
00:03:37.750 --> 00:03:42.890 
cics so they are not allowed to invoke operating system API calls,

51
00:03:43.310 --> 00:03:48.480 
kernel calls or something because all the input, output operations need to be

52
00:03:49.060 --> 00:03:53.160 
by cics to achieve, for example the processing of the distributed transactions.

53
00:03:53.890 --> 00:03:59.070 
And therefore CICS is the only external interface for the programs

54
00:03:59.070 --> 00:04:03.320 
that implement the transactions and run another control of CICS.

55
00:04:06.220 --> 00:04:09.850 
Shows an overview- the figure shows an overview

56
00:04:10.750 --> 00:04:13.270 
of the architecture of cics and

57
00:04:14.590 --> 00:04:15.990 
transaction processing monitors.

58
00:04:16.810 --> 00:04:20.700 
At the core of course are there to handle distributed transactions. in general.

59
00:04:21.260 --> 00:04:24.170 
Of course they can also handle non distributed transactions

60
00:04:24.460 --> 00:04:27.790 
which is just a special case of a distributed transaction.

61
00:04:28.270 --> 00:04:32.920 
And to do that there is the component in the cics called the back-end management.

62
00:04:33.150 --> 00:04:35.230 
In general cics runs on z/OS

63
00:04:36.610 --> 00:04:39.090 
at least on the mainframe, as we can see it here.

64
00:04:39.610 --> 00:04:42.050 
Inside we have the CICS Transaction Server

65
00:04:43.790 --> 00:04:48.110 
as part of its own region as a started task and the transaction

66
00:04:48.110 --> 00:04:49.900 
server itself has basically three layers.

67
00:04:50.930 --> 00:04:54.830 
The lowest layer is the back-end management which is there to coordinate

68
00:04:55.170 --> 00:04:59.810 
the storage, the devices of the other systems that are used to

69
00:05:00.070 --> 00:05:04.880 
read and write data from. So this is the back-end management handling the

70
00:05:05.210 --> 00:05:07.780 
transactional resources. Then we have the actual

71
00:05:08.410 --> 00:05:09.930 
business logic layer

72
00:05:11.040 --> 00:05:11.730 
which is the

73
00:05:13.120 --> 00:05:17.250 
layer where our transaction service programs that implement

74
00:05:17.250 --> 00:05:20.350 
the transactions are executed. So we have task management here.

75
00:05:20.630 --> 00:05:26.010 
And then we have at the top layer, we have the front end management which is

76
00:05:26.120 --> 00:05:27.230 
basically there to

77
00:05:30.550 --> 00:05:33.360 
provide the user interface or the connections to the outside

78
00:05:33.370 --> 00:05:36.170 
world. So this is sort of the presentation layer as we would

79
00:05:36.170 --> 00:05:40.460 
call it in a modern three D architecture. And this presentation

80
00:05:40.460 --> 00:05:42.190 
layer or this front-end management layer

81
00:05:42.960 --> 00:05:46.730 
for example implements something called BMS- the basic mapping support.

82
00:05:47.250 --> 00:05:50.280 
which in the past was frequently used or still is used, but

83
00:05:50.280 --> 00:05:52.940 
in the past it was more important to implement the

84
00:05:53.700 --> 00:05:56.720 
thirty to seventy terminal based

85
00:05:58.250 --> 00:06:02.510 
user interfaces. And it was accessed or is accessed by client

86
00:06:02.510 --> 00:06:05.040 
terminals and they connect, and can execute

87
00:06:05.690 --> 00:06:08.900 
transactions. So this of course is today not the

88
00:06:09.810 --> 00:06:13.250 
most important way how transactions are invoked. We do it

89
00:06:13.910 --> 00:06:18.310 
today more from frontend systems so called systems of engagement.

90
00:06:18.570 --> 00:06:21.330 
And we have maybe mobile clients and other clients in front.

91
00:06:21.590 --> 00:06:26.530 
And they probably are more like here, so we have external systems connecting and

92
00:06:26.640 --> 00:06:30.770 
calling transactions, but both is still possible and still used.

93
00:06:33.760 --> 00:06:38.170 
When we write, or to write CICS programs, CICS transactional programs,

94
00:06:38.380 --> 00:06:42.170 
there's a variety of programming language basically the supported for all

95
00:06:42.460 --> 00:06:46.620 
programming languages that are usable on the z/OS on the mainframe in general.

96
00:06:47.430 --> 00:06:51.640 
The most important one is typically COBOL, so most CICS programs

97
00:06:51.640 --> 00:06:55.000 
are written in cobol. But there's also the possibility to do is PL/1.

98
00:06:55.320 --> 00:06:59.150 
PL/1 is an IBM programming language that

99
00:06:59.990 --> 00:07:04.130 
was sort of intended originally, sort of successor to COBOL.

100
00:07:04.510 --> 00:07:09.380 
But still cobol is used in PL/1. It's not so widespread.

101
00:07:10.370 --> 00:07:12.650 
Then of course also C and C++ are possible.

102
00:07:13.620 --> 00:07:17.250 
And today even java can be used inside CICS.

103
00:07:18.330 --> 00:07:22.820 
In general CICS works in a way that of course

104
00:07:23.510 --> 00:07:27.070 
every I/O operation that a CICS transaction program

105
00:07:27.490 --> 00:07:31.830 
has to do needs to go through the transaction server, to the

106
00:07:31.830 --> 00:07:34.600 
transaction processing monitor to make sure that

107
00:07:35.030 --> 00:07:37.390 
the transaction processing monitor

108
00:07:38.440 --> 00:07:43.230 
can handle it, intercept it and make sure that the transaction properties are

109
00:07:43.340 --> 00:07:45.880 
kept. So for making

110
00:07:47.210 --> 00:07:52.100 
all kinds of I/O operations, the transaction program has to use

111
00:07:52.210 --> 00:07:57.100 
a special syntax. So it is done in a way that there is a macro language

112
00:07:57.780 --> 00:08:01.260 
and this macro language is independent of the programming languages used. And

113
00:08:01.360 --> 00:08:05.220 
other macros start with a statement EXEC CICS and End-EXEC.

114
00:08:05.820 --> 00:08:09.660 
And everything in between then is CICS code and not code of the

115
00:08:09.970 --> 00:08:15.890 
host language. And during compilation of that CICS programs, this macros are

116
00:08:16.330 --> 00:08:20.970 
preprocessed and turned into some library calls

117
00:08:20.970 --> 00:08:25.150 
that are specific for CICS, so that the programmer or the developer

118
00:08:25.150 --> 00:08:27.860 
only has to learn the macros and can work

119
00:08:28.610 --> 00:08:30.910 
in a standard way with a CICS interface.

120
00:08:34.180 --> 00:08:36.670 
CICS programs are forbidden or it is forbidden that they directly

121
00:08:36.670 --> 00:08:39.870 
access operating system functions, for example z/OS functions.

122
00:08:40.750 --> 00:08:42.020 
Like for example I/O

123
00:08:42.680 --> 00:08:44.730 
as I said to ensure that

124
00:08:46.050 --> 00:08:48.480 
the transaction processing monitor

125
00:08:49.210 --> 00:08:54.370 
knows of all input-output operations to keep track of for handling

126
00:08:54.380 --> 00:08:55.540 
the transactions.

127
00:08:58.450 --> 00:09:00.540 
CICS transaction is

128
00:09:03.420 --> 00:09:06.170 
usually used or started then when the

129
00:09:07.040 --> 00:09:11.930 
CICS program is compiled and it is deployed. So the application server

130
00:09:12.790 --> 00:09:14.300 
that transaction processing monitor

131
00:09:15.030 --> 00:09:18.330 
which is a kind of application server, is able to

132
00:09:18.810 --> 00:09:20.810 
locate it and to start it. Then

133
00:09:21.490 --> 00:09:26.270 
it is assigned a so called transaction identifier or transaction code.

134
00:09:26.560 --> 00:09:27.710 
And this transaction code or TA

135
00:09:28.410 --> 00:09:31.450 
code is usually a four character/ four digit character

136
00:09:31.920 --> 00:09:37.750 
string that is used to identify the transaction. And in the

137
00:09:39.370 --> 00:09:42.910 
original way when the user started the transaction using terminal,

138
00:09:43.580 --> 00:09:48.010 
just had to enter the code and press return and the transaction was started.

139
00:09:49.740 --> 00:09:52.470 
Today of course the code could be used from other clients.

140
00:09:53.730 --> 00:09:58.280 
And also CICS transaction can start another one

141
00:09:58.690 --> 00:10:01.910 
directly, so we can break up the problem in multiple

142
00:10:02.560 --> 00:10:03.770 
partial transactions.

143
00:10:05.430 --> 00:10:10.680 
And of course the CICS transactions today are mainly invoked from other

144
00:10:11.390 --> 00:10:16.230 
non mainframe applications while the CICS transaction gateway and

145
00:10:16.230 --> 00:10:21.270 
the external call interface are nowadays also using restful web services.

146
00:10:22.230 --> 00:10:25.730 
And in general every transaction program runs always under

147
00:10:25.730 --> 00:10:29.810 
the control of that cics transaction server so it's not possible to

148
00:10:30.280 --> 00:10:34.690 
run that cics program outside cics or to test it outside cics, because

149
00:10:37.190 --> 00:10:44.630 
the exact macros or CICS macros always need the environment to work and to function.

150
00:10:47.280 --> 00:10:51.590 
So this is a simple example of a cobol program just to illustrate the concept.

151
00:10:52.140 --> 00:10:55.590 
This is a very simple cobol program doing the hello world in

152
00:10:55.590 --> 00:10:59.370 
cics which is of course the most elementary program to typically write.

153
00:10:59.780 --> 00:11:01.870 
So you see that there's a normal cobol

154
00:11:04.420 --> 00:11:07.680 
start of the program identification division and we have a

155
00:11:07.690 --> 00:11:10.750 
variable defined here and so on. So this is all, this is cobol code.

156
00:11:11.230 --> 00:11:14.590 
So we use a cobol variable here for example. Then we move some

157
00:11:14.590 --> 00:11:16.720 
values inside the cobol variable.

158
00:11:17.350 --> 00:11:19.830 
Everything in green is standard cobol and then

159
00:11:20.530 --> 00:11:25.260 
the actual CICS invocation starts, the macro. So embedded in the

160
00:11:25.260 --> 00:11:30.160 
source code is that CICS macro and everything blue here is CICS specific.

161
00:11:31.330 --> 00:11:32.700 
And it consists of a-

162
00:11:34.070 --> 00:11:37.940 
the first instruction is a send instruction. A send instruction always

163
00:11:38.070 --> 00:11:40.490 
sends some data to the terminal, to the user.

164
00:11:41.460 --> 00:11:44.220 
And in this case of course it just writes hello world on the screen.

165
00:11:45.360 --> 00:11:49.850 
And the second one then is the return. So it

166
00:11:50.900 --> 00:11:53.110 
indicates that the control is

167
00:11:53.930 --> 00:11:56.030 
given back to the transaction processing monitor.

168
00:11:57.220 --> 00:12:00.950 
So these are the two commands here- CICS commands and in return

169
00:12:01.790 --> 00:12:05.700 
that are executed inside by the macro.

170
00:12:08.900 --> 00:12:12.490 
Of course for real application, you need sort of a user interface and

171
00:12:12.930 --> 00:12:15.670 
as long as thirty to seventy terminals are used,

172
00:12:16.140 --> 00:12:19.720 
the user interface as we have seen in the overview architecture

173
00:12:19.890 --> 00:12:23.010 
is implemented using the so called basic mapping support.

174
00:12:24.990 --> 00:12:27.620 
In terms of so called maps and map sets,

175
00:12:28.550 --> 00:12:33.640 
so we can think of a map as a screen and a screen on the terminal is

176
00:12:34.420 --> 00:12:37.330 
sort of a mask of characters- eighty versus

177
00:12:38.560 --> 00:12:44.190 
twentyfour, or eighty  columns twenty four rows, and in this

178
00:12:45.930 --> 00:12:49.150 
screen there are some fixed parts that are just explanation

179
00:12:49.150 --> 00:12:52.180 
labels and so on and there are some parts where the user can enter data

180
00:12:52.310 --> 00:12:57.890 
or maybe data is also displayed. And these structure, these masks they are defined

181
00:12:58.200 --> 00:13:00.940 
for CICS in terms of

182
00:13:01.720 --> 00:13:06.620 
a macro language that is internally nothing but an assembler program

183
00:13:06.890 --> 00:13:09.440 
consisting of three assembler macros.

184
00:13:11.000 --> 00:13:12.280 
We have heard that for z/OS,there's

185
00:13:13.150 --> 00:13:14.880 
a very powerful high level assembler.

186
00:13:15.830 --> 00:13:19.840 
This is used internally here so what you see here is a map

187
00:13:19.850 --> 00:13:21.540 
definition, or a map set definition

188
00:13:22.610 --> 00:13:26.170 
and when you read it you can see that it's rather intuitive

189
00:13:26.170 --> 00:13:27.460 
to understand so we have

190
00:13:28.470 --> 00:13:30.490 
different types of macros, basically three

191
00:13:30.920 --> 00:13:35.310 
with renames defining map sets, maps set fields. So a map set

192
00:13:35.320 --> 00:13:39.860 
is a collection of maps. A map defines basically one screen and a

193
00:13:40.140 --> 00:13:45.160 
field inside the screen, inside the map is a field for input

194
00:13:45.160 --> 00:13:48.540 
outputs of information either displayed or read from the terminal.

195
00:13:49.150 --> 00:13:53.540 
So a field if it's an input field has to be linked to a

196
00:13:54.390 --> 00:13:57.680 
variable name or something to store the data when it's received.

197
00:13:58.620 --> 00:14:01.770 
And that is basically implemented here with the parameters of this macros.

198
00:14:02.030 --> 00:14:04.730 
If you read it, you can see that as a position on the screen and

199
00:14:04.880 --> 00:14:07.780 
defines the style of printing and the value and so on.

200
00:14:08.350 --> 00:14:12.150 
And in this example you see that how

201
00:14:13.500 --> 00:14:17.990 
a map is defined. So in this case we have one map set, one map and

202
00:14:18.570 --> 00:14:21.680 
a few fields and it's basically a demo application

203
00:14:22.260 --> 00:14:26.960 
that is displaying some simple credit card check limit check or something.

204
00:14:28.370 --> 00:14:32.300 
And the three macros are listed here with the names and you'll

205
00:14:32.300 --> 00:14:36.340 
see here is always the field name and the macro name and then the parameters.

206
00:14:36.680 --> 00:14:37.860 
For example this is the name QCKSET

207
00:14:39.060 --> 00:14:45.010 
of the map set. Here the map inside the map set and then there's the fields for

208
00:14:45.130 --> 00:14:50.240 
this map. Ok, it could happen that in this case it's only one map inside

209
00:14:50.240 --> 00:14:53.080 
the map set but there could at some point come another one if it's a

210
00:14:53.200 --> 00:14:55.910 
bigger problem or a bigger program okay.

211
00:14:56.910 --> 00:14:59.120 
So typically a map set can have more than one map.

212
00:15:01.970 --> 00:15:04.250 
So if you use that map set, so this is the definition- the map

213
00:15:04.250 --> 00:15:10.180 
set is compiled or assembled in advance and stored in a library in a

214
00:15:10.430 --> 00:15:13.160 
PDS library to be accessible to

215
00:15:14.350 --> 00:15:19.310 
CICS. And now we write the cobol code that uses these map definitions.

216
00:15:19.990 --> 00:15:24.270 
So we have a separation here of the user interface and the actual processing code.

217
00:15:25.040 --> 00:15:30.060 
And of course, it doesn't have to be cobol.

218
00:15:30.060 --> 00:15:33.830 
It could be any of the languages supported by six but in this example it's cobol.

219
00:15:34.090 --> 00:15:38.450 
So here you see how a cobol program running inside CICS would use these maps.

220
00:15:38.970 --> 00:15:45.250 
Now we again have the green part- the cobol program called the blue

221
00:15:45.440 --> 00:15:47.700 
is special for CICS or special for the problem.

222
00:15:48.370 --> 00:15:52.040 
Here we see the EXEC statements and in this case the program basically

223
00:15:52.260 --> 00:15:54.860 
the first thing it does, it does a send again. But in this case

224
00:15:55.060 --> 00:15:58.850 
it's doing a send map so it sends the map with the name from the map set

225
00:15:59.150 --> 00:16:00.680 
to the screen, displays it

226
00:16:02.150 --> 00:16:05.350 
and then the next statement it's already to receive, which

227
00:16:05.360 --> 00:16:09.240 
means the receiver's blocking so it waits for the user to enter data and pressing

228
00:16:09.550 --> 00:16:16.340 
the enter key. And if the user presses that then the data is transmitted

229
00:16:16.340 --> 00:16:19.440 
to the server and the receive statement will receive the data and continue.

230
00:16:19.990 --> 00:16:24.340 
And receive says ok put the received data or handle the received

231
00:16:24.340 --> 00:16:26.770 
data according to this map definition here,

232
00:16:27.570 --> 00:16:31.750 
for example the map definition then defines which values go to which

233
00:16:31.910 --> 00:16:32.380 
arrival.

234
00:16:34.160 --> 00:16:37.520 
To have a mapping between the names the logical names inside the map

235
00:16:37.710 --> 00:16:39.780 
and the variable names in cobol.

236
00:16:40.530 --> 00:16:44.590 
When a map set is assembled it's not only creating a binary

237
00:16:44.590 --> 00:16:47.100 
representation of the layout and all the information, but it

238
00:16:47.100 --> 00:16:50.420 
also creates a so called copy book. Copy book is

239
00:16:52.090 --> 00:16:55.900 
a code fragment in a target language, in this case cobol.

240
00:16:56.510 --> 00:17:01.350 
That then can be imported in the cobol code to create the necessary

241
00:17:01.350 --> 00:17:04.450 
variable definitions. If you go back here to the

242
00:17:05.230 --> 00:17:08.950 
map set definition you see that there are some field names here

243
00:17:09.360 --> 00:17:10.190 
describing the

244
00:17:11.910 --> 00:17:16.070 
variables in which the data that is read in from that map should be stored.

245
00:17:16.640 --> 00:17:21.810 
And basically this when you assemble this using the appropriate

246
00:17:22.430 --> 00:17:26.650 
commands then a COBOL copy book is created as well which is

247
00:17:26.650 --> 00:17:29.790 
basically a text fragment containing the variable definitions and COBOL

248
00:17:30.130 --> 00:17:34.360 
syntax. For the variables that are labelled here.

249
00:17:35.120 --> 00:17:39.370 
And this one needs to be imported in the cobol code like a macro import.

250
00:17:40.750 --> 00:17:44.280 
You can compare that a little bit with and include in C for example.

251
00:17:44.950 --> 00:17:48.010 
And this is done by the copy statement here. So in the working

252
00:17:48.010 --> 00:17:50.360 
storage section you'll see that there's basically a copy statement

253
00:17:50.660 --> 00:17:54.210 
which copies this copy book corresponding the name corresponds to the

254
00:17:55.140 --> 00:17:59.660 
map set as well. And this means ok here all the variable definitions are

255
00:17:59.940 --> 00:18:03.660 
copied into the cobol code before it is compiled to

256
00:18:04.560 --> 00:18:06.750 
have the variables at hand that are defined in

257
00:18:08.110 --> 00:18:12.380 
the map. And so we can refer to variables.

258
00:18:12.840 --> 00:18:15.590 
You see the variables here that we refer to for example

259
00:18:16.350 --> 00:18:21.910 
here the account number that are not defined in the working

260
00:18:21.910 --> 00:18:23.240 
storage section, but they are

261
00:18:24.300 --> 00:18:25.610 
defined by the account number.

262
00:18:26.330 --> 00:18:29.400 
In and out for example are not defined. These come from

263
00:18:29.900 --> 00:18:33.350 
the copy book. They are implicitly imported

264
00:18:33.770 --> 00:18:37.080 
so you have to know how the things play together.

265
00:18:38.010 --> 00:18:43.040 
And then what the program checks- if in the received data the account

266
00:18:43.040 --> 00:18:45.980 
number has a certain value and if it has a certain value this

267
00:18:45.980 --> 00:18:49.650 
is of course just a dummy program. It moves some warning text

268
00:18:49.660 --> 00:18:53.920 
to the output message and then it does again send and sends back the result

269
00:18:54.190 --> 00:18:56.720 
to the screen. Okay, so this example

270
00:18:57.770 --> 00:19:03.060 
basically illustrates how user interfaces work with BMS in CICS transactions.

271
00:19:04.010 --> 00:19:07.010 
And of course if a program uses BMS transactions,

272
00:19:07.700 --> 00:19:10.060 
BMS commands, BMS maps, then

273
00:19:12.050 --> 00:19:15.980 
it depends on this BMS functionality and it also depends on user interaction.

274
00:19:16.270 --> 00:19:20.660 
So when such kind of programs or applications are modernised

275
00:19:20.660 --> 00:19:24.050 
and we replace the thirty to seventy user interfaces, there

276
00:19:24.050 --> 00:19:27.610 
must be some kind of replacement for this input output operation as well.

277
00:19:28.180 --> 00:19:31.690 
Different technologies and concepts have been proposed for that

278
00:19:32.310 --> 00:19:33.520 
over the decades but

279
00:19:34.680 --> 00:19:36.400 
today of course it's possible to

280
00:19:37.290 --> 00:19:38.910 
sort of use this kind of

281
00:19:39.550 --> 00:19:43.060 
transaction code in web based applications as well.

282
00:19:44.800 --> 00:19:48.440 
All right, so this was a short introduction in the idea and concepts of

283
00:19:48.850 --> 00:19:52.630 
the cics transaction processing monitor which is still sort

284
00:19:52.630 --> 00:19:56.900 
of one of the core components for mainframe applications. Most

285
00:19:57.090 --> 00:20:01.900 
critical mainframe applications probably use cobol and cics as the foundation.

286
00:20:02.540 --> 00:20:03.530 
Thank you very much.
