WEBVTT

1
00:00:00.840 --> 00:00:05.040 
This is knowledge graphs lecture number
two, basic semantic technologies.

2
00:00:05.840 --> 00:00:08.340 
This now is the first
excursion in that course.

3
00:00:09.170 --> 00:00:13.520 
Excursions are not a direct part of the
curriculum of that course, but however

4
00:00:13.690 --> 00:00:17.470 
if it comes to applying the
technology we were talking about

5
00:00:17.490 --> 00:00:20.500 
and about, let's say, a
deeper understanding

6
00:00:21.070 --> 00:00:25.900 
we try to deepen that and your knowledge
with the help of these course excursions.

7
00:00:26.570 --> 00:00:29.830 
The very first excursion today
we are talking about how we

8
00:00:29.830 --> 00:00:33.600 
bring rdf, we know already
about that, to the web

9
00:00:34.110 --> 00:00:38.320 
because up to now we know the web
of course is programmed in html.

10
00:00:38.820 --> 00:00:43.290 
And html and rdf they are not
necessarily compatible. So

11
00:00:43.700 --> 00:00:46.720 
how does it work? It works
with so called rdfa.

12
00:00:48.360 --> 00:00:52.680 
So we see, we are now on the
format level again. So you know

13
00:00:53.040 --> 00:00:57.960 
rdf xml, rdf turtle are two
different formats how to express

14
00:00:57.960 --> 00:01:02.780 
rdf for example within the semantic
web stack, technology stick

15
00:01:02.910 --> 00:01:07.620 
and rdfa and microformats are other
two formats we will talk about today.

16
00:01:08.000 --> 00:01:08.910 
So let's have a look.

17
00:01:10.220 --> 00:01:16.450 
In principle there are several ways, at least
three ways to embedd structured data

18
00:01:16.600 --> 00:01:20.950 
with explicit semantic annotations
inside html documents.

19
00:01:22.080 --> 00:01:25.860 
First and oldest version would be
domain specific microformat, so

20
00:01:26.090 --> 00:01:29.340 
the oldest version. We will shortly
talk about that but it's

21
00:01:29.510 --> 00:01:32.590 
nowadays more or less old-fashioned.
Then of course you could

22
00:01:32.590 --> 00:01:37.320 
use generic idea of or you can
also use html five micro data

23
00:01:37.650 --> 00:01:43.050 
which of course also has a rather
prominent example which

24
00:01:43.050 --> 00:01:45.720 
is schema.org, you probably have
heard of that already.

25
00:01:46.590 --> 00:01:50.010 
Okay, but let's start first with the
microformats. They have been

26
00:01:50.010 --> 00:01:53.630 
introduced already rather early in
two thousand and five and you see

27
00:01:54.120 --> 00:01:58.550 
they are kind of markup that
usually express limited semantics.

28
00:01:58.550 --> 00:02:02.090 
So they are designed to solve
simple specific problems, usually

29
00:02:02.100 --> 00:02:05.970 
for example a business card information
or something like that and

30
00:02:06.460 --> 00:02:10.980 
in the first place they are designed
for humans, and machines second.

31
00:02:11.570 --> 00:02:15.010 
And they are used in web pages
to describe a specific type

32
00:02:15.010 --> 00:02:18.700 
of information for example a
person, an event, a product or a

33
00:02:18.700 --> 00:02:22.090 
review or something like that.
What you can do with it, you can

34
00:02:22.250 --> 00:02:26.290 
easily extract this kind of
microformats from the html documents.

35
00:02:26.290 --> 00:02:31.330 
And what they do or how they work is in
general they are using the class attribute

36
00:02:31.520 --> 00:02:35.870 
in the html text and most times
they are using the span tag

37
00:02:35.880 --> 00:02:39.790 
or the division tag and then they
assign brief and descriptive

38
00:02:39.790 --> 00:02:41.800 
names to their entities
and their properties.

39
00:02:42.690 --> 00:02:46.380 
Let's have a look at a small
example. H card is one of the most

40
00:02:46.380 --> 00:02:51.480 
prominent microformats. So this is
for describing persons, like

41
00:02:51.730 --> 00:02:55.200 
in a business card. What you do
there, you see you have here

42
00:02:55.200 --> 00:02:59.550 
the class v card which defines
the age card format and then

43
00:02:59.590 --> 00:03:03.980 
you see the first name for example of
that person, the title of that person

44
00:03:04.300 --> 00:03:07.320 
the organization he or she is
working in and then you have

45
00:03:07.320 --> 00:03:11.410 
address information like street,
postal code and of course the

46
00:03:11.410 --> 00:03:15.150 
city, so the locality and stuff like
that and even a bit more information.

47
00:03:15.720 --> 00:03:17.090 
The nice thing is then

48
00:03:17.800 --> 00:03:20.920 
this is of course embedded as
you see here with this kind of

49
00:03:20.920 --> 00:03:25.570 
attributes within the html markup
and can rather easily be extracted

50
00:03:25.750 --> 00:03:30.580 
as structured data. Of course
this has several pros and cons.

51
00:03:31.330 --> 00:03:34.980 
On the one hand of course a
microformats can rather easily

52
00:03:34.980 --> 00:03:39.280 
be transcoded to rdf via, lets
say, an XSLT. So

53
00:03:39.280 --> 00:03:41.140 
this is easy. So the
transfer from

54
00:03:42.000 --> 00:03:45.660 
a microformat to rdf, this
is possible, no problem.

55
00:03:46.230 --> 00:03:49.060 
However if you want to introduce
a new microformat that is

56
00:03:49.060 --> 00:03:53.570 
then used in html, first this has
to be consolidated and confirmed

57
00:03:53.790 --> 00:03:59.160 
by the community and always you have to
develop a new XSLT stylesheet for a

58
00:03:59.370 --> 00:04:01.020 
new extraction
after that.

59
00:04:01.860 --> 00:04:07.130 
And however if you are using more
than a single microformat within

60
00:04:07.320 --> 00:04:11.090 
one html document then of course
the processing becomes really

61
00:04:11.090 --> 00:04:14.520 
really complex because then
you have to take care for

62
00:04:14.920 --> 00:04:19.160 
different kind of, of course,
vocabulary that are used there and

63
00:04:19.160 --> 00:04:22.280 
also styles that are used
there to encode the stuff.

64
00:04:22.730 --> 00:04:26.360 
And of course also there might
be conflicts with

65
00:04:26.360 --> 00:04:28.880 
existing html
attributes. Therefore

66
00:04:30.050 --> 00:04:33.720 
we are going for something much
more flexible and we try to embed

67
00:04:34.420 --> 00:04:38.670 
real rdf into html, which means
we don't have to define every

68
00:04:38.670 --> 00:04:43.180 
time a new a vocabulary that has
to be confirmed by the entire

69
00:04:43.180 --> 00:04:48.390 
community who uses it. No, we are
using just you know rdf plain

70
00:04:48.390 --> 00:04:52.290 
and the rdf as it is and with the
help of rdf of course we can encode

71
00:04:52.600 --> 00:04:55.960 
almost everything and can
put it into html code.

72
00:04:56.460 --> 00:05:02.170 
The way how to do that is called rdfa
and rdfa stands for the abbreviation

73
00:05:02.370 --> 00:05:08.940 
rdf in html attribute. So this is
for generic rdf annotation within

74
00:05:09.090 --> 00:05:14.410 
html or x html documents. And you
do it again like in the way

75
00:05:14.410 --> 00:05:17.630 
for microformats you are
reusing existing attributes.

76
00:05:18.140 --> 00:05:21.460 
Meanwhile we have version one
point one which is based on html

77
00:05:21.460 --> 00:05:25.670 
five and this has become a
W3C recommendation already

78
00:05:25.670 --> 00:05:28.640 
in two thousand and twelve and
we will talk about a lighter

79
00:05:28.640 --> 00:05:33.030 
version of that rdfa light one point
one because this is completely sufficient

80
00:05:33.170 --> 00:05:37.350 
to make it clear to you the
principal how you know this kind

81
00:05:37.350 --> 00:05:38.930 
of rdf embedding works.

82
00:05:40.020 --> 00:05:44.840 
So what kind of attributes are
used? So for on the one hand

83
00:05:44.840 --> 00:05:48.420 
of course you reuse existing
html attributes, for example

84
00:05:48.420 --> 00:05:51.860 
href to define a link of source
to define a link to another

85
00:05:51.970 --> 00:05:56.670 
entity for example and there are a
few new html attributes. There is

86
00:05:56.870 --> 00:06:01.930 
the vocal attribute, type of attribute,
property, resource and prefix.

87
00:06:02.550 --> 00:06:04.090 
How does that work
I will tell you.

88
00:06:05.560 --> 00:06:09.940 
So let's do a quick example. If we
want to talk, let's say something

89
00:06:09.940 --> 00:06:14.270 
similar like we had already in this
age card microformat example,

90
00:06:14.400 --> 00:06:19.180 
let's say, we want to do a website
that gives information about me.

91
00:06:19.320 --> 00:06:25.430 
So first thing I have to do there
is of course I have to tell

92
00:06:25.540 --> 00:06:30.670 
which kind of vocabulary I'm going
to use. And in rdf for example

93
00:06:30.770 --> 00:06:34.430 
it's a very convenient and
popular way to express personal

94
00:06:34.430 --> 00:06:38.200 
data with the help of the so called
foaf, this is the friend of a friend

95
00:06:38.390 --> 00:06:43.920 
vocabulary and this here is used too
in our example. And you include this

96
00:06:44.190 --> 00:06:48.940 
by the attribute vocab and then
you specify which vocabulary

97
00:06:49.150 --> 00:06:52.530 
you would like to use and this is
then the URI of the vocabulary

98
00:06:52.530 --> 00:06:54.100 
that we are going
to use next.

99
00:06:55.870 --> 00:06:59.760 
Then of course we want to talk about
the person, so we want to describe me.

100
00:07:00.300 --> 00:07:03.910 
So I have to I have the
possibility to say the thing

101
00:07:03.910 --> 00:07:08.480 
that I'm going to describe next has
a specific type, which means yeah

102
00:07:08.740 --> 00:07:12.850 
the class to which it belongs and
this is done usually then with

103
00:07:12.980 --> 00:07:17.270 
the attribute type of and then I
tell exactly what am I talking

104
00:07:17.270 --> 00:07:19.920 
about, I'm talking about
here about a person.

105
00:07:21.480 --> 00:07:24.520 
Then for that person I
can give properties.

106
00:07:25.300 --> 00:07:30.170 
And here the properties again they
might come here from the fourth

107
00:07:30.310 --> 00:07:34.970 
vocabulary, I have the name, I
have the phone number and I

108
00:07:34.970 --> 00:07:37.860 
can give an image, for example
and you see here I use here

109
00:07:38.370 --> 00:07:43.300 
the property or the
attribute property and I say

110
00:07:43.410 --> 00:07:47.250 
the property that I want to use is
the property name and the value

111
00:07:47.390 --> 00:07:53.480 
which I would like to fill the property
with is then simply the subsequent

112
00:07:53.620 --> 00:07:59.010 
html code which is in between the tags
the span tags I am reusing here

113
00:07:59.200 --> 00:08:03.760 
for exactly that purpose. So this
means the name is Harald Sack,

114
00:08:04.030 --> 00:08:07.240 
the phone number is this one eight
hundred number and of course

115
00:08:07.240 --> 00:08:10.900 
there is an image and the image
of course is here described

116
00:08:10.900 --> 00:08:16.530 
via source attribute that I give
within an image tag at html,

117
00:08:16.530 --> 00:08:19.860 
which means this image is also already
displayed here in the website.

118
00:08:19.980 --> 00:08:22.520 
However it's also

119
00:08:23.350 --> 00:08:25.530 
annotated as
being an image.

120
00:08:26.560 --> 00:08:30.120 
Ok next thing I can do is for
example I can also do what is it

121
00:08:30.300 --> 00:08:34.200 
I am talking about. So I can create
an identifier for the things

122
00:08:34.200 --> 00:08:37.580 
we are talking about. So
you remember this from

123
00:08:38.250 --> 00:08:42.050 
designating something and to have a
designator and a designatum. I can

124
00:08:42.190 --> 00:08:45.820 
define a designatum here
by saying this resource

125
00:08:45.820 --> 00:08:50.720 
I'm talking about here is me and I call
this Harald and this means than hash

126
00:08:50.930 --> 00:08:55.580 
Harald and this will be simply
complemented to the already

127
00:08:55.580 --> 00:08:59.220 
existing base URI, so resource
already refers to the base

128
00:08:59.220 --> 00:09:04.010 
URI of the web page and then
I can also externally refer to

129
00:09:04.260 --> 00:09:08.470 
myself exactly with the base URI
and I say then hash Harald

130
00:09:08.470 --> 00:09:12.390 
if I have defined it exactly in
that way and this then identifies

131
00:09:12.390 --> 00:09:16.880 
exactly me and then come all of
the fact that I hear stored

132
00:09:16.890 --> 00:09:20.970 
like for example what's the type
of me, what's my name, what's my

133
00:09:20.970 --> 00:09:25.150 
phone number and so on and so on and
I have this data structured put

134
00:09:25.480 --> 00:09:28.040 
into the html document.

135
00:09:29.090 --> 00:09:32.020 
And however if the vocabulary you
are using is not sufficient

136
00:09:32.490 --> 00:09:34.330 
to describe all the
properties that you want

137
00:09:35.170 --> 00:09:38.660 
we can simply add new vocabulary
and we can use prefixes like

138
00:09:38.660 --> 00:09:43.610 
we are used to do that in rdf.
So there is another attribute,

139
00:09:43.620 --> 00:09:47.460 
its called prefix and then simply
define here a new prefix

140
00:09:47.460 --> 00:09:52.190 
for a vocabulary and I have the example
here that I use the open vocabulary

141
00:09:52.560 --> 00:09:57.470 
vocabulary and this here I use
with the prefix abbreviation ov

142
00:09:57.740 --> 00:10:00.950 
and then you see this in the last
line here I use a property

143
00:10:00.990 --> 00:10:05.670 
from that which is ov preferred beverage,
so this preferred beverage property

144
00:10:06.430 --> 00:10:11.020 
comes from the ov open vocabulary
vocabulary and I say

145
00:10:11.020 --> 00:10:14.190 
then my favorite beverage
is espresso, what else?

146
00:10:16.120 --> 00:10:20.730 
Okay last thing I'm going to
tell you about rdfa,

147
00:10:21.440 --> 00:10:26.060 
one specialty now what you can do for
example is you can separate content

148
00:10:26.420 --> 00:10:30.550 
from presentation. Let's have
a look at the example here.

149
00:10:31.100 --> 00:10:34.800 
In that example what I want to
do is I want to give the time

150
00:10:34.800 --> 00:10:37.510 
when the document was created.
So this is an old document,

151
00:10:37.970 --> 00:10:42.060 
don't be confused by that. I say the
document has been created on the

152
00:10:42.220 --> 00:10:45.870 
twenty eighth of October in two
thousand and twelve and I give

153
00:10:46.190 --> 00:10:50.870 
the date here exactly in the html
document which will be displayed

154
00:10:50.870 --> 00:10:55.510 
in the browser is twenty eight
period ten period twenty twelve.

155
00:10:56.070 --> 00:11:00.250 
However this is not a valid date
format in rdf. So what I can

156
00:11:00.250 --> 00:11:04.550 
do here is I can separate here exactly
the presentation which will be

157
00:11:04.720 --> 00:11:06.280 
displayed in
the browser from

158
00:11:08.050 --> 00:11:13.530 
the content that will be taken
as rdf content then because

159
00:11:13.530 --> 00:11:18.200 
I say here yeah for the property
created please then take exactly

160
00:11:18.200 --> 00:11:22.010 
that string that has been put
here in the content attribute

161
00:11:22.110 --> 00:11:27.420 
and this is formatted according
to the xml date data type.

162
00:11:28.580 --> 00:11:33.320 
So this would be the separation
of presentation and content

163
00:11:33.380 --> 00:11:37.030 
with the help of
rdfa inside html.

164
00:11:39.100 --> 00:11:42.870 
And talking about data types
of course you can also give

165
00:11:43.400 --> 00:11:47.700 
every property that you define here
you can associate a specific

166
00:11:47.700 --> 00:11:51.900 
xml schema definition data type
with it simply by saying data

167
00:11:51.900 --> 00:11:56.400 
type equals and then you give
the xml schema definition data

168
00:11:56.400 --> 00:11:59.490 
type that we have already talked
about. Like for example here

169
00:11:59.700 --> 00:12:02.780 
the year two thousand twelve
will be interpreted as a year

170
00:12:03.540 --> 00:12:05.450 
So it's easy as that.

171
00:12:07.270 --> 00:12:11.640 
To sum it up and in general what you
distinguish when you use rdfa

172
00:12:11.800 --> 00:12:15.080 
is you distinguish between two
different sorts of triples.

173
00:12:15.760 --> 00:12:19.660 
Once are triples where the
object is a resource

174
00:12:20.060 --> 00:12:23.610 
and the other ones are triples where
the object is simply a literal.

175
00:12:24.370 --> 00:12:27.130 
When the object is
simply a literal then

176
00:12:27.550 --> 00:12:30.600 
you have the possibility either
you separate presentation and

177
00:12:30.600 --> 00:12:37.090 
content by using here the content
attribute or simply you know

178
00:12:37.330 --> 00:12:42.950 
the parsed html data will be taken
as the object as a literal.

179
00:12:44.060 --> 00:12:46.870 
On the other hand if the
object is a resource

180
00:12:47.460 --> 00:12:52.050 
then you can use the href
attribute that you have in

181
00:12:52.050 --> 00:12:56.860 
html or you use the resource
attribute that comes with rdfa

182
00:12:56.860 --> 00:13:01.710 
to indicate exactly the URI of
the object you are talking about.

183
00:13:03.620 --> 00:13:09.020 
So yeah now we come to the practical
point of that application.

184
00:13:09.020 --> 00:13:13.440 
Of course rdfa only makes use if
you really are able to extract

185
00:13:13.700 --> 00:13:17.380 
exactly this rdf code
from the html page

186
00:13:18.180 --> 00:13:23.090 
and I have here given you an
address off a nice tool, it's the

187
00:13:23.090 --> 00:13:26.600 
RDFa 1.1 Distiller and
Parser available here

188
00:13:26.600 --> 00:13:30.700 
at the W3C website you
simply follow the link and then

189
00:13:30.890 --> 00:13:34.680 
what happens is you come directly
to that application and what

190
00:13:34.680 --> 00:13:38.420 
you can do here you can
here specify a URI

191
00:13:38.920 --> 00:13:42.540 
and this URI then is taken
and all the rdf that is within

192
00:13:42.540 --> 00:13:45.690 
the web page will be extracted.
For that of course we need some

193
00:13:45.690 --> 00:13:51.060 
kind of web page that contains rdf.
So this here is the sky high block

194
00:13:51.330 --> 00:13:54.400 
simply just to mention so this is
a small block that is maintained

195
00:13:54.400 --> 00:13:58.350 
by our group for many years now
and this is a blog about daily

196
00:13:58.620 --> 00:14:02.200 
events in science,
tech and art history.

197
00:14:02.670 --> 00:14:05.780 
I have selected here you an
article from march fourteen two

198
00:14:05.780 --> 00:14:08.820 
thousand and twenty about Paul
Ehrlich and his research on

199
00:14:08.880 --> 00:14:13.910 
chemotherapy and magic bullets and
you simply take this address here,

200
00:14:14.930 --> 00:14:16.130 
for example
because I know,

201
00:14:17.090 --> 00:14:24.260 
sorry this is a web page that
contains rdf in the form of rdfa.

202
00:14:24.520 --> 00:14:25.680 
I copy it here

203
00:14:26.970 --> 00:14:28.430 
and then I
simply say go

204
00:14:30.040 --> 00:14:33.330 
and what you see here is you
see this here in rdf turtle

205
00:14:34.230 --> 00:14:39.350 
all the data that is here, all
the triples that are here in

206
00:14:39.490 --> 00:14:43.250 
that rdf file. So for example you
have here something like a

207
00:14:43.570 --> 00:14:48.360 
you have your chemotherapy or here
hematology which is a thing,

208
00:14:48.370 --> 00:14:51.980 
ok or you have Leipzig which
is a place and stuff like that.

209
00:14:52.160 --> 00:14:56.660 
So these things are part structured
data that can be extracted from

210
00:14:56.810 --> 00:15:01.520 
that document and is encoded
inside the html code as

211
00:15:01.520 --> 00:15:07.380 
rdfa. So simply try it out
it's really really easy. Okay.

212
00:15:09.890 --> 00:15:13.340 
You might ask yeah how frequently
is this rdfa really

213
00:15:13.340 --> 00:15:16.730 
used on the web. Interestingly,
so this is the statistics from

214
00:15:16.740 --> 00:15:22.060 
early twenty twenty according to
W3tech where statistics

215
00:15:22.060 --> 00:15:26.180 
about the entire web is collected.
So the idea of a usage on

216
00:15:26.180 --> 00:15:30.160 
àrbitrary website already now is
between forty five and fifty

217
00:15:30.160 --> 00:15:34.570 
percent, so it's really really
high. And this is the case

218
00:15:34.570 --> 00:15:38.240 
because it pays off if you're
using rdfa in your website

219
00:15:38.500 --> 00:15:42.650 
this will be beneficial for search
engine optimization, meaning

220
00:15:42.940 --> 00:15:47.520 
using rdfa in your website google
benefits this in the sense

221
00:15:47.520 --> 00:15:50.650 
that of course then it will be
displayed higher in the search

222
00:15:50.650 --> 00:15:54.850 
results and of course the structured
knowledge that is encoded here

223
00:15:55.120 --> 00:15:59.280 
within the html page can be
extracted, can be easily read by

224
00:15:59.280 --> 00:16:02.940 
google and of course this information
can also be used otherwise.

225
00:16:03.530 --> 00:16:07.390 
Which kind of vocabulary is are
used most here? So for example

226
00:16:07.390 --> 00:16:10.810 
you see here that ninety four
percent of all of the websites

227
00:16:10.810 --> 00:16:14.920 
here that contain rdfa they are using
the open graph vocabulary and this is

228
00:16:15.190 --> 00:16:19.010 
vocabulary defined by facebook
or they are using just generic

229
00:16:19.010 --> 00:16:24.420 
rdfa and is almost thirty percent
here. So it's pretty frequently.

230
00:16:25.840 --> 00:16:29.090 
However now we come to a point
where we say okay we know now

231
00:16:29.090 --> 00:16:34.450 
everything about rdf and rdfs.
Next let's see how we can use

232
00:16:34.450 --> 00:16:39.870 
it in the sense, yeah, if there are huge lets
say files or databases containing rdf

233
00:16:40.150 --> 00:16:43.570 
how can we query rdf
in an efficient way.

234
00:16:44.040 --> 00:16:47.870 
And you will learn this in the next
lecture when we talk about SPARQL.
