WEBVTT

1
00:00:00.580 --> 00:00:04.530 
In our OpenHPI course,
Half-century of internet,

2
00:00:04.530 --> 00:00:08.920 
we want to speak about routing.
Routing in the right area network

3
00:00:09.200 --> 00:00:10.580 
routing in an internet.

4
00:00:11.660 --> 00:00:16.560 
So a router is a packet
switch which processes

5
00:00:16.830 --> 00:00:21.170 
the incoming data packets
and it has a task

6
00:00:21.630 --> 00:00:25.280 
to forward it into the
direction of the destination.

7
00:00:26.160 --> 00:00:32.170 
So the first rule to evaluate the destination
address of as a received data package,

8
00:00:32.920 --> 00:00:35.240 
then it selects a route

9
00:00:35.970 --> 00:00:43.430 
through a neighbour, a packet switch on
the path to the destination address,

10
00:00:43.970 --> 00:00:46.220 
and then it forwards
the data packet.

11
00:00:48.280 --> 00:00:55.040 
The determination of an optimal path for
such data packets from sender to receiver

12
00:00:55.380 --> 00:00:59.820 
in such a wide area network in
internet it's called routing.

13
00:01:01.870 --> 00:01:07.110 
Let's discuss, let's consider this
routing, the task to compute

14
00:01:07.200 --> 00:01:11.370 
an optimal route in the wide
area network in more detail.

15
00:01:12.920 --> 00:01:16.400 
The first statement we can do is
that optimal routing in a wide

16
00:01:16.400 --> 00:01:22.760 
area network is possible independent
of the source of the data package.

17
00:01:24.000 --> 00:01:28.640 
This is a principle of optimality which
says an optimal route for a packet

18
00:01:28.910 --> 00:01:31.550 
depends solely on
the destination,

19
00:01:32.260 --> 00:01:37.200 
and not on its starting point
or the route taken so far.

20
00:01:37.680 --> 00:01:40.430 
This principle of optimality
is a mathematical statement,

21
00:01:40.880 --> 00:01:46.890 
so we can at least sketch the
proof of this statement.

22
00:01:48.080 --> 00:01:51.190 
Let's consider this
road from B to C,

23
00:01:51.850 --> 00:01:57.740 
and assume give it the name 1 and
let's assume that's an optimal route

24
00:01:58.110 --> 00:01:59.330 
from B to C.

25
00:02:03.120 --> 00:02:06.510 
B also receives
packages from A,

26
00:02:07.950 --> 00:02:09.150 
this is another router.

27
00:02:10.440 --> 00:02:15.610 
And now the claim is that following
the optimal route from B to C

28
00:02:18.090 --> 00:02:21.350 
has an optimum connection
from A to C.

29
00:02:24.100 --> 00:02:29.620 
Let's assume the optimal
route from over B to C,

30
00:02:30.510 --> 00:02:31.520 
So it is a better one,

31
00:02:37.000 --> 00:02:41.800 
so that B to C via 2

32
00:02:42.540 --> 00:02:46.190 
is the more optimal,
shorter, so A to B via

33
00:02:47.290 --> 00:02:48.840 
route 1 to C.

34
00:02:50.310 --> 00:02:54.540 
Then of course it's clear because
this is the same, that 2 is

35
00:02:54.550 --> 00:02:55.730 
shorter than 1.

36
00:02:57.190 --> 00:03:02.570 
So then the optimal route from
B to C would be 2 and not 1,

37
00:03:03.910 --> 00:03:09.890 
as a contradiction, because we
assumed that 1 was an optimal way.

38
00:03:10.370 --> 00:03:14.240 
So in this way, we have proved
it does not matter where

39
00:03:14.700 --> 00:03:19.990 
a packet comes from. The optimal
route from this to this

40
00:03:20.690 --> 00:03:27.490 
also is optimal for packages
withing the source

41
00:03:27.700 --> 00:03:31.290 
very far from.

42
00:03:32.520 --> 00:03:34.380 
So the principle of

43
00:03:35.560 --> 00:03:41.190 
source independence allows the use of
very efficient routing algorithms,

44
00:03:41.400 --> 00:03:45.570 
because at every point I only have
to declare for each package

45
00:03:45.570 --> 00:03:50.400 
for the own packets of the own network
as for package to be forwarded

46
00:03:50.560 --> 00:03:57.220 
it's only enough to concentrate
on finding the optimal route

47
00:03:57.420 --> 00:04:05.830 
from B to C. For determining such an
optimal route in computer we consider

48
00:04:05.830 --> 00:04:08.450 
the computer network
as a graph.

49
00:04:09.290 --> 00:04:14.210 
In this graph the nodes represent
routers and the edges represent

50
00:04:14.210 --> 00:04:19.980 
connections between two routers. In a network,
not all routers are directly connected.

51
00:04:20.220 --> 00:04:26.080 
Ao an edge is only drawn when there is a
direct connection between two routers.

52
00:04:28.010 --> 00:04:32.490 
In such a graph, there
is no end systems,

53
00:04:32.920 --> 00:04:38.360 
which is connected so we put it
away, to make it very clear what

54
00:04:38.360 --> 00:04:43.200 
what needs to be considered to
compute an optimal route.

55
00:04:44.130 --> 00:04:49.340 
Because the end systems are not relevant
for the calculation of the routes.

56
00:04:50.360 --> 00:04:56.880 
One can understand this in a better way
at hand of an example, this is our

57
00:04:57.150 --> 00:05:03.500 
entrance example: often a Wide Area
Network consisting of 4 networks

58
00:05:03.750 --> 00:05:09.310 
which are interconnected in that
way and the route is a graph

59
00:05:09.470 --> 00:05:17.180 
we draw where we take the points
sir for the packet switches

60
00:05:18.220 --> 00:05:24.020 
with is the corresponding number. And
the edge we draw is a connection

61
00:05:24.200 --> 00:05:29.230 
between two edges. So
what we say this

62
00:05:31.320 --> 00:05:37.000 
in the connection in the
graph of routers is enough

63
00:05:37.410 --> 00:05:43.850 
information to run such
a routing algorithm.

64
00:05:45.490 --> 00:05:53.170 
Routing tables, these are the data structures we
need for computing such routing algorithms.

65
00:05:53.690 --> 00:05:59.250 
So these are the main data structures,
we already showed it in another clip.

66
00:05:59.900 --> 00:06:04.330 
So each packet switch manages
its own routing table,

67
00:06:06.030 --> 00:06:11.010 
and the different routing algorithms
now distinguish in which way

68
00:06:11.210 --> 00:06:14.040 
the routers compute
the routing

69
00:06:15.440 --> 00:06:18.290 
table we need for
each destination.

70
00:06:19.030 --> 00:06:21.760 
The Next-Hop,

71
00:06:22.310 --> 00:06:28.150 
the packet has to be forwarded
to reach the final destination

72
00:06:28.510 --> 00:06:31.250 
this was the next stop
we already discussed.

73
00:06:32.230 --> 00:06:37.740 
So the routing table must have an
entry for each potential target

74
00:06:38.150 --> 00:06:40.010 
in the network.

75
00:06:41.590 --> 00:06:46.940 
The routing table should not only tell
what is the next hop, the routing table

76
00:06:47.240 --> 00:06:53.540 
should provide an
optimal route, the

77
00:06:53.730 --> 00:07:00.660 
next-hop which helps to
find the shortest path

78
00:07:01.100 --> 00:07:02.670 
or the cheapest path
tp destination.

79
00:07:07.200 --> 00:07:12.280 
Let's see how this principle of
optimality can be applied.

80
00:07:13.900 --> 00:07:18.140 
Again a mathematical theorem, If
one connects the optimal routes

81
00:07:18.570 --> 00:07:22.780 
from all possible nodes
in our graphs, this way

82
00:07:22.780 --> 00:07:27.330 
the routers, routers A1 to
An, with a destination that

83
00:07:28.080 --> 00:07:32.630 
one obtains a tree
so-called, sink tree.

84
00:07:33.600 --> 00:07:34.920 
I will show you
an example,

85
00:07:35.860 --> 00:07:41.010 
the natural metric of such a tree
is the number of required hops

86
00:07:41.400 --> 00:07:45.430 
and we want to have the
shortest, the smallest number

87
00:07:45.830 --> 00:07:51.770 
of required hops to transmit
our data package in an

88
00:07:51.900 --> 00:07:54.340 
optimal way to the
destination.

89
00:07:55.650 --> 00:07:57.900 
What is important
with such an entry

90
00:07:58.510 --> 00:08:01.980 
structure? Such a
tree has no loops,

91
00:08:03.480 --> 00:08:07.890 
each packet reach its destination
after a finite number of

92
00:08:07.890 --> 00:08:12.900 
steps there is no possibility
that route is sent in a circle

93
00:08:13.260 --> 00:08:18.090 
a from one router to another,
without reaching its destination.

94
00:08:19.040 --> 00:08:22.340 
So the purpose of the
various routing algorithms

95
00:08:23.110 --> 00:08:25.410 
is the construction
of a sink tree

96
00:08:25.870 --> 00:08:31.550 
to determine the optimal route in
the corresponding entries of a

97
00:08:31.860 --> 00:08:35.700 
routing table. Let's
consider an example,

98
00:08:36.730 --> 00:08:42.780 
I mentioned already we have
our goal, our Z computer and

99
00:08:42.780 --> 00:08:46.990 
we have in our graph all the
routers that are available, also

100
00:08:46.990 --> 00:08:52.660 
end systems are omitted. And then in
the graph, we interconnect to routers

101
00:08:53.080 --> 00:08:56.120 
if there is a direct
connection between these.

102
00:08:56.900 --> 00:09:02.830 
You see in this graph there are
cycles, so we can move in this way.

103
00:09:03.480 --> 00:09:08.680 
So what we have to do, is
to construct a sink tree.

104
00:09:09.560 --> 00:09:15.390 
The sink tree that means a pause
to all these goal computers,

105
00:09:15.390 --> 00:09:17.390 
this is our route
in our graph,

106
00:09:18.410 --> 00:09:23.080 
without any circle. So
we omit connections

107
00:09:23.620 --> 00:09:31.450 
between the router, the different routing
algorithm uses in a different way

108
00:09:31.750 --> 00:09:36.970 
and then we reach such a
sink tree for our router Z

109
00:09:37.170 --> 00:09:40.700 
where the destination
address belongs to.

110
00:09:41.740 --> 00:09:45.890 
So there are different routing
algorithms to compute this,

111
00:09:46.570 --> 00:09:50.290 
for example central
routing algorithms,

112
00:09:50.880 --> 00:09:55.860 
there is a central instance
which knows the networks

113
00:09:55.900 --> 00:10:01.510 
and computes the routing table
for each of the routers.

114
00:10:03.330 --> 00:10:09.580 
So this rather long waiting times because
its central instance has to compute

115
00:10:09.710 --> 00:10:15.870 
for all the router each table, then
the table has to be transmitted,

116
00:10:16.100 --> 00:10:17.530 
so it's a long process.

117
00:10:18.720 --> 00:10:24.050 
That's the problem with the central routing
algorithms, it is called a single point of failure.

118
00:10:24.840 --> 00:10:30.830 
Or a resource bottleneck
in the centre occurs

119
00:10:31.250 --> 00:10:37.020 
then the entire network operation
does not work correctly.

120
00:10:37.200 --> 00:10:41.230 
So here with this approach, we
have single point of failure.

121
00:10:42.020 --> 00:10:47.550 
So more interesting and
applied in the real-life

122
00:10:47.990 --> 00:10:51.530 
in the internet are decentralized
routing algorithms.

123
00:10:52.050 --> 00:10:57.450 
Here each router calculates
its own routing table,

124
00:10:57.910 --> 00:11:00.260 


125
00:11:00.870 --> 00:11:05.020 
based on its own knowledge of
the network environment.

126
00:11:06.650 --> 00:11:13.250 
So the question is what does a single
router know from its neighbourhood?

127
00:11:14.230 --> 00:11:17.860 
So this information

128
00:11:18.470 --> 00:11:22.520 
about the neighbourhood is
received by the neighbours

129
00:11:23.720 --> 00:11:27.030 
and the router looks for
a broader neighborhood,

130
00:11:27.530 --> 00:11:32.220 
then it leads a while up to
this information is reaching.

131
00:11:32.220 --> 00:11:36.800 
So its is a rather long process
of adoption to any change

132
00:11:36.800 --> 00:11:40.280 
in the network situation, if for
example a router in another

133
00:11:40.280 --> 00:11:45.720 
part of the network has a failure, then,
of course, there's no more working,

134
00:11:45.920 --> 00:11:49.520 
then the routing tables
need to be adapted.

135
00:11:50.310 --> 00:11:54.930 
Here are different routing algorithms
known in the literature,

136
00:11:55.080 --> 00:11:59.670 
Isolate routing, Distance vector
method, link-state routing.

137
00:12:00.240 --> 00:12:06.610 
And indeed Distance vector
method was used first in

138
00:12:06.610 --> 00:12:12.230 
the internet, later it was link-state routing.
So there are different routing mechanisms

139
00:12:12.580 --> 00:12:17.210 
we will speak about it in more detail
about the routing algorithms

140
00:12:17.520 --> 00:12:23.570 
that are in place. But for
your understanding, that by

141
00:12:23.710 --> 00:12:26.370 
this mechanism

142
00:12:27.030 --> 00:12:32.230 
describes a network by a graph,
where the nodes are the routers,

143
00:12:32.590 --> 00:12:38.740 
the edges are the direct connections,
and then we construct the

144
00:12:39.130 --> 00:12:45.820 
sink tree out of this, and by
means of sink tree we compute

145
00:12:45.830 --> 00:12:47.070 
the next the
hop tables.
