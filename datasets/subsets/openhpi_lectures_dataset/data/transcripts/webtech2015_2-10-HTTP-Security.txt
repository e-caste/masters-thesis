WEBVTT

1
00:00:04.740 --> 00:00:08.720 
Now let's speak about security aspects

2
00:00:09.610 --> 00:00:11.720 
working with a HTTP protocol.

3
00:00:13.220 --> 00:00:15.690 
So in the following we want to consider

4
00:00:16.250 --> 00:00:20.070 
different mechanisms for HTTP security we

5
00:00:21.060 --> 00:00:24.980 
want to speak about authentication allows to

6
00:00:24.980 --> 00:00:27.940 
authenticate and to also resize a client,

7
00:00:29.370 --> 00:00:37.540 
also server in an HTTP communication and HTTPS as the transport channel security

8
00:00:37.670 --> 00:00:44.870 
which makes it possible that the documents at the resources may be encrypted

9
00:00:45.280 --> 00:00:48.790 
to defend the content of the web documents when transported

10
00:00:49.340 --> 00:00:51.910 
via HTTP over the open internet

11
00:00:52.810 --> 00:00:56.950 
and from being spied out or even from being manipulated.

12
00:00:57.390 --> 00:01:04.700 
And HTTP as also provides means for strong authentication to

13
00:01:04.700 --> 00:01:08.610 
prevent interception of confidential data like passports or

14
00:01:08.780 --> 00:01:10.390 
an also reside parties.

15
00:01:11.710 --> 00:01:15.950 
Let's start with considering the authentication methods that are

16
00:01:16.590 --> 00:01:18.840 
coming with HTTP.

17
00:01:19.720 --> 00:01:22.470 
So in security relevant resources,

18
00:01:23.390 --> 00:01:28.250 
which shall be accessed via HTTP suitable authentication and

19
00:01:28.260 --> 00:01:31.440 
authorisation of the client is necessary.

20
00:01:33.240 --> 00:01:35.780 
Problem HTTP is a stateless protocol,

21
00:01:36.420 --> 00:01:40.770 
that means results from a previous communication cannot be remembered.

22
00:01:41.650 --> 00:01:45.370 
But its only valid in the time span between the connection

23
00:01:45.370 --> 00:01:49.630 
establishment by a client request and delivery of the

24
00:01:50.230 --> 00:01:51.760 
requested resources.

25
00:01:53.890 --> 00:01:59.340 
HTTP/1.1 comes with two different methods for authentication

26
00:01:59.520 --> 00:02:04.660 
with a basic access authentication which was also available in HTTP/1.1

27
00:02:04.990 --> 00:02:10.290 
and the digest access authentication which is more

28
00:02:10.370 --> 00:02:16.360 
secure than the basic authentication. Let's start to consider the basic authentication.

29
00:02:16.870 --> 00:02:21.850 
Here the procedure is the following; the client sends requests

30
00:02:21.880 --> 00:02:27.680 
for a protected resource, then the server checks the availability of that resource,

31
00:02:27.920 --> 00:02:34.470 
and sees resources available, but resource is secured. So not

32
00:02:34.470 --> 00:02:39.560 
everyone can access this resource. So the server responds with a status code

33
00:02:39.950 --> 00:02:46.310 
401 unauthorized and he transmits this together with the

34
00:02:47.830 --> 00:02:51.170 
WWW-authentication response header.

35
00:02:52.890 --> 00:02:57.500 
The header determines the authentication type in that case when

36
00:02:57.500 --> 00:03:02.790 
we consider basic out education it is WWW-authenticate basic.

37
00:03:04.070 --> 00:03:09.270 
The header value also contains the so called real name.

38
00:03:09.790 --> 00:03:13.250 
This is the name for the protected resources area.

39
00:03:13.780 --> 00:03:18.050 
So here the real name is a restricted area so

40
00:03:18.930 --> 00:03:24.640 
when the client next time sends his request together with his authentication

41
00:03:25.230 --> 00:03:31.770 
the server remembers the resource place where the resource is stored.

42
00:03:32.880 --> 00:03:33.560 
The client

43
00:03:35.210 --> 00:03:41.810 
displays as a browser the place for the user log inform and ask the user

44
00:03:41.960 --> 00:03:44.180 
for his credentials.

45
00:03:48.130 --> 00:03:53.560 
Then the client, a username password,

46
00:03:54.240 --> 00:03:59.380 
it is concatenated as a string separated by a colon,

47
00:03:59.840 --> 00:04:06.190 
username:password and then the string is encoded with base64.

48
00:04:07.230 --> 00:04:12.440 
So it looks like this and in this way the client

49
00:04:13.010 --> 00:04:19.030 
now a new request for the protected resource and his ended together with the

50
00:04:20.010 --> 00:04:24.650 
authorisation request hader field as set by his input.

51
00:04:26.240 --> 00:04:32.290 
The header field contains the authentication method and the base64 string

52
00:04:32.740 --> 00:04:37.420 
for example authorisation basic and then a string that was produced

53
00:04:37.830 --> 00:04:40.250 
out of user name and password.

54
00:04:41.450 --> 00:04:43.890 
Now the server receives this

55
00:04:44.570 --> 00:04:51.890 
request it's a request for a protected resource and then it checks the credentials.

56
00:04:53.510 --> 00:04:54.960 
Credentials they checked

57
00:04:55.620 --> 00:04:58.640 
the user name password to find out whether

58
00:04:59.050 --> 00:05:02.190 
the client has the right to

59
00:05:02.920 --> 00:05:05.020 
access the protected resource.

60
00:05:06.980 --> 00:05:11.750 
What are potential pitfalls in this very basic out education method?

61
00:05:11.860 --> 00:05:16.590 
Why this method is not to be considered as a cure method?

62
00:05:17.320 --> 00:05:22.870 
First pitfall is base64 is a reversible encoding.

63
00:05:23.430 --> 00:05:28.150 
It is it was not designed as an encryption typically

64
00:05:28.150 --> 00:05:32.940 
are not reversible only if one knows a key but basic64

65
00:05:33.550 --> 00:05:35.080 
can be

66
00:05:36.490 --> 00:05:39.460 
reverse encoded.

67
00:05:41.380 --> 00:05:46.250 
Next pitfall is that the transmission of the encoded string

68
00:05:46.820 --> 00:05:52.550 
is no more secure than the to transmit the plaintext. Everyone he

69
00:05:52.690 --> 00:05:59.710 
who even drops the communication can also can also get

70
00:06:00.810 --> 00:06:04.790 
username password string encoded in base64.

71
00:06:05.410 --> 00:06:11.800 
So that means the transport channel security must be ensured for basic

72
00:06:11.920 --> 00:06:16.510 
authentication to use only this basic authentication method

73
00:06:17.100 --> 00:06:20.660 
is not as secure way of authentication.

74
00:06:23.040 --> 00:06:27.840 
Now let's consider the second method which was introduced with

75
00:06:27.840 --> 00:06:31.040 
HTTP/1.1 the digest

76
00:06:31.790 --> 00:06:33.060 
authentication.

77
00:06:34.650 --> 00:06:39.190 
Access authentication is a stronger authentication method and

78
00:06:39.210 --> 00:06:45.240 
a meant to allow HTTP authentication without the need for an encrypted transport channel.

79
00:06:46.340 --> 00:06:50.910 
Basic authentication only works with a encrypted transport channel

80
00:06:52.870 --> 00:06:56.010 
digest authentication can work without.

81
00:06:57.160 --> 00:07:00.470 
Digest authentication applies a cryptographic hash function

82
00:07:02.290 --> 00:07:06.690 
MD5 function to the credentials before transmitting them.

83
00:07:07.120 --> 00:07:13.240 
So here a real encryption function is used to encrypt the username

84
00:07:13.240 --> 00:07:14.410 
and the password.

85
00:07:15.510 --> 00:07:21.720 
Together announce now is a random value are sent by the server in the

86
00:07:22.620 --> 00:07:24.980 
WWW-Authenticate header

87
00:07:26.250 --> 00:07:32.500 
that needs to be included in the credential string before the string is

88
00:07:32.660 --> 00:07:39.410 
hashed. The idea behind is that this random value is unique,

89
00:07:40.070 --> 00:07:43.740 
so even if someone records the

90
00:07:45.370 --> 00:07:49.250 
request from the client to the server

91
00:07:49.760 --> 00:07:54.670 
it cannot replayed, it cannot be used again, because for the

92
00:07:54.670 --> 00:07:57.860 
next interaction a new random value is sent.

93
00:07:58.810 --> 00:08:01.640 
The digest authentication use encryption

94
00:08:02.270 --> 00:08:04.050 
for the

95
00:08:05.480 --> 00:08:10.820 
credentials a hash function and the credentials consist of

96
00:08:10.830 --> 00:08:16.640 
the username of the password and the announce which were sent by the server.

97
00:08:17.080 --> 00:08:22.540 
All this information are hashed together to prevent replay attacks.

98
00:08:23.850 --> 00:08:29.220 
But also for the digest authentication there are limitations.

99
00:08:29.730 --> 00:08:34.750 
Limitations here are the used hash functions the MD5

100
00:08:35.290 --> 00:08:37.080 
is considered as program.

101
00:08:37.730 --> 00:08:42.610 
It's no difficult to encrypt

102
00:08:44.580 --> 00:08:50.840 
this hash value it does not need long time and for that reason MD5

103
00:08:51.020 --> 00:08:56.030 
should not be used as an encryption hash or encrypting hash function

104
00:08:56.480 --> 00:09:04.210 
anymore in applications which needs higher security standards. And then

105
00:09:05.510 --> 00:09:10.130 
the next limitation of the digest sort authentication methods

106
00:09:10.860 --> 00:09:17.470 
of HTTP/1.1 is that the digest authentication is vulnerable

107
00:09:17.790 --> 00:09:20.080 
to a men-in-the-middle attack.

108
00:09:21.030 --> 00:09:25.770 
Here is a man-in-the-middle can intercept the initial response

109
00:09:25.890 --> 00:09:29.310 
and manipulates the authenticate header

110
00:09:29.950 --> 00:09:37.010 
to ask the client not to apply the digest authentication but to imply

111
00:09:37.190 --> 00:09:41.780 
a simple basic authentication which much easier than to take off

112
00:09:42.030 --> 00:09:45.440 
the credentials for a later misuse.

113
00:09:49.070 --> 00:09:56.570 
Important in the use of HTTP is the provide of HTTP

114
00:09:56.890 --> 00:09:58.650 
in connection with the transport

115
00:10:00.490 --> 00:10:03.300 
security. This is a HTTPS

116
00:10:04.330 --> 00:10:10.660 
secure alternative to HTTP it's described in RFC2818

117
00:10:11.320 --> 00:10:18.950 
and HTTPS stands for hypertext transfer protocol secure and

118
00:10:19.470 --> 00:10:24.770 
it provides the possibility of encrypting all the communication and of

119
00:10:25.210 --> 00:10:27.190 
providing strong authentication

120
00:10:28.020 --> 00:10:31.180 
needs of the communication partner

121
00:10:31.980 --> 00:10:36.840 
as well of the browser as well of the web server.

122
00:10:37.440 --> 00:10:46.260 
And the basic idea is simply to run HTTP wire TLS. TLS formerly known as SSL

123
00:10:46.880 --> 00:10:51.760 
is a protocol layer for

124
00:10:52.610 --> 00:10:58.480 
encrypting all the traffic. So it's an additional layer here

125
00:10:58.480 --> 00:11:03.300 
the TLS layer in the TCP IP stack. So we have statistic

126
00:11:03.300 --> 00:11:07.700 
P connection which is necessary to be established for a HTTP

127
00:11:07.920 --> 00:11:10.810 
communication then

128
00:11:11.410 --> 00:11:17.710 
a TLS is applied which provides encryption of all the communication

129
00:11:18.430 --> 00:11:24.250 
and other tools and then this transport layer security

130
00:11:24.750 --> 00:11:30.470 
secures all the HTTP communication. So as this transport layers accrued here

131
00:11:31.110 --> 00:11:37.950 
formerly known as SSL provides encryption and provides certificate based authentication

132
00:11:38.240 --> 00:11:41.460 
much better means for authentication than the

133
00:11:42.120 --> 00:11:45.160 
means HTTP is providing.

134
00:11:48.550 --> 00:11:55.580 
HTTPS passwords and other confidential data can no longer be intercepted easily by

135
00:11:55.790 --> 00:12:02.110 
an also resides parties so if you run your online banking or

136
00:12:02.110 --> 00:12:07.480 
if you run other applications with a high security standard then

137
00:12:08.050 --> 00:12:10.940 
definitely you should use HTTPS.

138
00:12:11.560 --> 00:12:15.040 
You can see this also in the URL

139
00:12:15.910 --> 00:12:22.990 
scheme so it is important here to see this S this is the security

140
00:12:23.800 --> 00:12:28.170 
features if you like to secure HTTP communication this is

141
00:12:28.620 --> 00:12:29.480 
what you should do.
