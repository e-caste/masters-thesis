WEBVTT

1
00:00:00.700 --> 00:00:03.460 
Now we want to have a closer
look to password security

2
00:00:03.950 --> 00:00:10.770 
and authentication by means of passwords in
our openHPI course about digital identities.

3
00:00:12.240 --> 00:00:15.830 
We already discussed this.
This is a very popular method

4
00:00:16.350 --> 00:00:23.390 
to bind a digital identity to a user by
means of a password authentication.

5
00:00:25.030 --> 00:00:30.380 
And the idea is simple.
The user proves that the

6
00:00:31.560 --> 00:00:33.650 
digital identity
belongs to him

7
00:00:34.400 --> 00:00:38.950 
by means of inputting, entering
the correct password.

8
00:00:39.430 --> 00:00:44.000 
This is an authentication by knowledge.
The password needs to hold a secret

9
00:00:44.360 --> 00:00:49.670 
and in this way the service provider
trusts that it is a real user

10
00:00:50.390 --> 00:00:55.410 
that belongs to that digital identity
because he knows the correct password.

11
00:00:56.660 --> 00:01:01.100 
So the online service interface of
authentication checks the correctness

12
00:01:01.470 --> 00:01:05.790 
of the password by
comparing it with the information

13
00:01:05.860 --> 00:01:08.430 
that was collected during
the registration

14
00:01:08.860 --> 00:01:13.450 
when the digital identity of
the user was established and

15
00:01:13.940 --> 00:01:17.900 
the service can check
this simply by checking

16
00:01:18.680 --> 00:01:24.890 
his data, user database and comparing
the password which was typed in

17
00:01:25.090 --> 00:01:26.780 
with the password
that was stored.

18
00:01:27.580 --> 00:01:32.180 
And if those match then the user
is given access to the service,

19
00:01:32.180 --> 00:01:35.390 
the user can use the
resources of the service

20
00:01:35.830 --> 00:01:41.910 
and all the authentication relates
to the digital identity which

21
00:01:42.450 --> 00:01:44.230 
is secured
by that password.

22
00:01:45.280 --> 00:01:52.090 
Passwords are stored in user databases,
should never be stored in plaintext.

23
00:01:52.620 --> 00:01:57.960 
We already discussed this, they should be
stored in a distinguished form

24
00:01:58.330 --> 00:02:02.850 
so that neither the
employees of the service nor other

25
00:02:03.270 --> 00:02:08.500 
persons that get access to the customer
database can understand the password.

26
00:02:08.830 --> 00:02:11.410 
So a cryptographic
hash function

27
00:02:12.450 --> 00:02:18.350 
that is applied to the password and the hash
value of this password that is what

28
00:02:18.470 --> 00:02:23.670 
typically is stored in the
database of the service. So if we

29
00:02:23.670 --> 00:02:27.870 
look on this authentication process
which is based on passwords,

30
00:02:28.150 --> 00:02:35.550 
here we have our customer who
wants to use the service and

31
00:02:36.260 --> 00:02:42.340 
enters the password. Then the password
is sent in plaintext to

32
00:02:42.340 --> 00:02:45.210 
the server, to
the service provider.

33
00:02:45.770 --> 00:02:49.010 
The website sends the password
together with the user name

34
00:02:49.480 --> 00:02:52.240 
to the online service

35
00:02:53.050 --> 00:03:00.350 
or the identity provider of the online
service and then the service compares

36
00:03:00.830 --> 00:03:04.180 
the data with what is
stored in his database.

37
00:03:04.900 --> 00:03:10.440 
In his database typically it is stored,
password is stored in a hashed form.

38
00:03:10.670 --> 00:03:17.590 
So here the input password also is
hashed and then the two hash values

39
00:03:17.770 --> 00:03:18.610 
are compared.

40
00:03:19.990 --> 00:03:23.580 
What is here vulnerability?

41
00:03:24.860 --> 00:03:26.840 
Vulnerability, of course is

42
00:03:27.460 --> 00:03:32.480 
to give in the password which
is available in plaintext.

43
00:03:33.150 --> 00:03:36.060 
When the provider would
store a password

44
00:03:36.540 --> 00:03:41.410 
in plaintext, not in a
hashed form as it

45
00:03:42.690 --> 00:03:45.760 
should be done in
the user database,

46
00:03:46.750 --> 00:03:51.990 
then the people that have
access to the database

47
00:03:53.220 --> 00:03:58.180 
illegally as attackers or legally
as a service provider, can see

48
00:03:59.910 --> 00:04:05.220 
the password and in that way it's
easy to use the digital identity.

49
00:04:06.590 --> 00:04:11.290 
So if cybercriminals succeed in
accessing the IT system of

50
00:04:11.310 --> 00:04:17.100 
the online service via the internet, if
they succeed in being able to download

51
00:04:17.490 --> 00:04:23.520 
the user database with all the
passwords and if the passwords are

52
00:04:23.770 --> 00:04:30.430 
stored in plaintext then the attacker
has access to all the passwords

53
00:04:30.570 --> 00:04:31.330 
in plaintext.

54
00:04:32.920 --> 00:04:38.980 
Even if the attacker only gets this
database with the hashed passwords,

55
00:04:39.450 --> 00:04:43.500 
then it is very dangerous for
the users of the services.

56
00:04:44.240 --> 00:04:45.770 
Because the attacker

57
00:04:46.710 --> 00:04:49.830 
can, we will discuss this
later, they can access

58
00:04:50.300 --> 00:04:54.290 
via the passwords to
the online service

59
00:04:54.700 --> 00:04:59.710 
via the stolen passwords to the online
service and can misuse the digital identities.

60
00:05:00.470 --> 00:05:05.570 
So the attacker can try to use
the same or slightly modified

61
00:05:05.570 --> 00:05:10.640 
user name password combinations also
with other services. With other service

62
00:05:10.820 --> 00:05:14.910 
the database was not stolen
and why it's successful? Yeah,

63
00:05:15.770 --> 00:05:19.510 
because many people use
different services

64
00:05:19.930 --> 00:05:24.730 
with the same password or only with
a slightly modified password.

65
00:05:25.570 --> 00:05:28.640 
So user usually
know nothing

66
00:05:29.320 --> 00:05:34.840 
about the theft of the identity data
So they trust that all works fine,

67
00:05:35.190 --> 00:05:41.360 
but in reality if an attacker
succeed in stealing the password

68
00:05:41.610 --> 00:05:44.470 
database, the customer
database from one service,

69
00:05:45.190 --> 00:05:49.050 
it is highly probable
that the attacker is also able

70
00:05:49.490 --> 00:05:54.110 
to get access via this digital
identity to other services.

71
00:05:55.730 --> 00:05:59.290 
So here are
the question how

72
00:06:01.110 --> 00:06:04.280 
passwords can be stored
in a secure way.

73
00:06:04.880 --> 00:06:09.580 
I already started to discuss
about hash value. So the

74
00:06:10.160 --> 00:06:16.100 
professional way to store a password
outside of the service provider

75
00:06:16.380 --> 00:06:21.130 
is to store it in a
cryptographic encrypted form.

76
00:06:21.800 --> 00:06:26.970 
And what is the cryptographic methods
that are needed, that are applied

77
00:06:27.390 --> 00:06:31.240 
to encrypt passwords
are hash methods.

78
00:06:32.160 --> 00:06:35.830 
So the hashing that's
a kind of concealment.

79
00:06:36.470 --> 00:06:41.530 
And as a hash function, the hash
method transforms the password

80
00:06:42.110 --> 00:06:48.320 
in a string that looks very curious
and gives no possibility to

81
00:06:49.010 --> 00:06:54.110 
get information about the password
and this hash value typically

82
00:06:54.530 --> 00:06:56.550 
is a string of a
fixed length.

83
00:06:58.610 --> 00:07:03.250 
But our experience with the HPI
Identity Leak Checker, I already

84
00:07:03.260 --> 00:07:09.150 
introduced this where we help people to find
out whether their digital identities

85
00:07:09.350 --> 00:07:15.810 
are published, are stolen and
openly published in the internet,

86
00:07:16.330 --> 00:07:22.880 
we find that one third of the
twelve billion identity data sets

87
00:07:23.090 --> 00:07:28.300 
we have collected, one third
of them, about four billion,

88
00:07:28.780 --> 00:07:31.100 
password is in
plaintext.

89
00:07:31.710 --> 00:07:34.290 
It's not in the hash
value, it's in plaintext.

90
00:07:35.100 --> 00:07:39.320 
The two third hash methods
are applied which are

91
00:07:39.730 --> 00:07:44.160 
outdated and only one third
of the passwords are stored

92
00:07:45.260 --> 00:07:49.300 
are hashed in a correct way
and stored in a correct way.

93
00:07:49.740 --> 00:07:54.740 
So this is really
a disaster and

94
00:07:55.430 --> 00:08:00.740 
for that reason, it's so important
that you check from time to time

95
00:08:00.890 --> 00:08:05.660 
whether your identity is
stolen and published

96
00:08:06.160 --> 00:08:09.560 
because sometimes
the password is, in this

97
00:08:11.260 --> 00:08:17.590 
digital identity, the password is
accessible in plaintext.

98
00:08:19.530 --> 00:08:21.580 
To speak about the hashing,

99
00:08:22.430 --> 00:08:25.880 
let's have a closer
look at how it works.

100
00:08:26.460 --> 00:08:31.690 
So the idea is to hide
the mean of a password.

101
00:08:32.160 --> 00:08:35.830 
So to only make
it a string of

102
00:08:36.580 --> 00:08:41.620 
symbols which looks random. And
this is what the cryptographic

103
00:08:41.620 --> 00:08:45.530 
hash functions are doing. A
hash function transforms

104
00:08:46.010 --> 00:08:50.470 
a password into a ciphertext

105
00:08:51.030 --> 00:08:55.810 
into a hash value of a fixed
length. So for example here

106
00:08:55.810 --> 00:08:59.170 
the password u/3a and so on

107
00:08:59.760 --> 00:09:04.820 
is hashed by the hash function
with the name MD5, it's

108
00:09:04.820 --> 00:09:10.110 
a special hash function, in that
form in that string and you see

109
00:09:10.300 --> 00:09:16.570 
from that string you cannot get any
information about the password itself.

110
00:09:18.240 --> 00:09:23.750 
The hash functions are designed, the
cryptographic hash function are designed

111
00:09:23.950 --> 00:09:30.030 
exactly for that purpose. They are designed
in such a way that it's practically

112
00:09:30.250 --> 00:09:35.210 
impossible, it is possible
but it needs centuries

113
00:09:35.890 --> 00:09:42.270 
to compute it, so that it's practically
impossible to recover the original password

114
00:09:42.720 --> 00:09:44.370 
out from the hash value.

115
00:09:45.110 --> 00:09:48.620 
Mathematically we speak about
one-way functions. The one way

116
00:09:48.810 --> 00:09:52.760 
it's easy from the plaintext to the hash
functions the computation is easy,

117
00:09:53.150 --> 00:09:56.110 
but from the hash function
it's not possible to

118
00:09:57.800 --> 00:09:59.870 
conclude on
the password.

119
00:10:01.170 --> 00:10:04.270 
The commonly used hash
functions for password hash

120
00:10:04.860 --> 00:10:11.410 
are MD5 and SHA1, but both
are meanwhile considered unsecure

121
00:10:11.670 --> 00:10:16.820 
because they are reversible with the
computational power of the reason computers.

122
00:10:17.060 --> 00:10:22.650 
So what years ago needed centuries,
nowadays with the modern computer

123
00:10:22.880 --> 00:10:24.320 
can be done in minutes.

124
00:10:26.060 --> 00:10:28.230 
The hashing methods which are

125
00:10:29.190 --> 00:10:37.840 
more secure and should be applied is
SHA2, SHA3 and bcrypt.

126
00:10:39.630 --> 00:10:44.780 
Let's look how the validation
process works with such a hashed

127
00:10:45.220 --> 00:10:52.980 
password. So, user wants to use a
service and enters his or her

128
00:10:53.120 --> 00:10:59.210 
password. Then the password is
received from the database, here

129
00:10:59.210 --> 00:11:05.830 
is a user and the database. So the
user gets access to this hash value

130
00:11:06.040 --> 00:11:10.560 
of the password. So what now
is done on the side of

131
00:11:11.570 --> 00:11:15.790 
the service that the received
clear text password

132
00:11:16.260 --> 00:11:21.410 
is hashed, in this case, is short
hashed with the MD5 hash

133
00:11:21.650 --> 00:11:23.790 
function into
that string

134
00:11:24.530 --> 00:11:32.120 
and then the service provider can
check whether John123 really

135
00:11:32.300 --> 00:11:39.500 
is the right username for
the password and now here

136
00:11:39.500 --> 00:11:43.740 
the service has a hash value and
compares the hash value with

137
00:11:43.740 --> 00:11:45.530 
the hash value
that was stored

138
00:11:46.390 --> 00:11:50.300 
of the password and
if they are equal then

139
00:11:51.160 --> 00:11:55.150 
login is successful otherwise
login failed.

140
00:11:56.040 --> 00:12:01.670 
This is the procedure. The password is sent
in clear text and on the service side, it is

141
00:12:02.260 --> 00:12:05.760 
computed, the hash value of
the password is computed and

142
00:12:05.760 --> 00:12:11.860 
then in the user database it is checked
whether the combination username and

143
00:12:12.090 --> 00:12:13.620 
hash value of
the password

144
00:12:14.790 --> 00:12:20.480 
belong to each other and if yes
then login the binding

145
00:12:22.160 --> 00:12:26.730 
of the digital identity to
the user is finished, positively

146
00:12:26.730 --> 00:12:28.770 
finished otherwise
it's confused.

147
00:12:30.170 --> 00:12:34.480 
There is one remark and
one problem we want to

148
00:12:35.220 --> 00:12:39.180 
show how service providers
deal with that

149
00:12:39.800 --> 00:12:46.230 
password that it's hiding
by hashing has some weak

150
00:12:46.230 --> 00:12:48.540 
spots. For example
we have two users

151
00:12:49.580 --> 00:12:55.270 
and in large services that is
very likely we have two users

152
00:12:56.170 --> 00:12:58.660 
which have the
same password.

153
00:12:59.520 --> 00:13:03.610 
And when they use the same passwords
then of course the hash value

154
00:13:03.940 --> 00:13:05.670 
of the same password

155
00:13:06.290 --> 00:13:10.380 
is the same. So we have two
different users with

156
00:13:10.890 --> 00:13:13.250 
the same password in
the same password hash.

157
00:13:14.290 --> 00:13:19.640 
So the computation of the hash value
will not help to distinguish

158
00:13:19.640 --> 00:13:23.460 
between these two users. So
for example this can happen

159
00:13:23.910 --> 00:13:30.070 
for users with the same passwords or
when they have the same name or others

160
00:13:30.470 --> 00:13:34.690 
that they have the same hash
value stored in the database.

161
00:13:36.260 --> 00:13:40.830 
So when an attacker knows
from one user's password

162
00:13:41.870 --> 00:13:46.710 
then he knows also the
password of all users

163
00:13:47.350 --> 00:13:52.790 
which are using the same password
which have the same hash value.

164
00:13:53.420 --> 00:13:54.770 
So if an attacker

165
00:13:56.960 --> 00:14:02.270 
succeeds in stealing
user database

166
00:14:03.140 --> 00:14:08.170 
and he finds out many users
with the same hash value

167
00:14:08.680 --> 00:14:14.840 
and he gets knowledge from one of
the user's plaintext password,

168
00:14:15.490 --> 00:14:17.810 
then the attacker
can immediately

169
00:14:19.210 --> 00:14:25.770 
misuse all the other digital identities
that are using the same password.

170
00:14:27.560 --> 00:14:31.980 
So the hash for example can be guessed

171
00:14:32.170 --> 00:14:38.460 
by hashing our words in a dictionary,
so, because many users use

172
00:14:38.580 --> 00:14:42.890 
simple words and when the attacker
computes a hash value, he can

173
00:14:43.130 --> 00:14:49.550 
detect agreement between the
computation results and

174
00:14:49.550 --> 00:14:55.990 
what is stored in the database
and then he knows the password.

175
00:14:58.410 --> 00:15:03.740 
So to make this, to
prevent such a situation,

176
00:15:04.520 --> 00:15:09.520 
there is the idea to use hash functions
and to compute hash functions

177
00:15:10.010 --> 00:15:13.860 
by means of Salt, by means of
additional information.

178
00:15:14.730 --> 00:15:21.180 
So the same password is
disguised differently every time

179
00:15:22.590 --> 00:15:25.760 
is disguised every time

180
00:15:26.250 --> 00:15:30.930 
by the following idea. Before the hash
value of the password is calculated,

181
00:15:31.560 --> 00:15:34.840 
the password is extended
by a random string.

182
00:15:35.550 --> 00:15:37.710 
The random string
is called Salt.

183
00:15:38.520 --> 00:15:42.680 
So the hash function, in our
example the MD5 hash function,

184
00:15:42.900 --> 00:15:48.030 
is not only applied to the password
itself, but it's applied to the password

185
00:15:49.100 --> 00:15:51.150 
that is extended
by the Salt.

186
00:15:51.960 --> 00:15:57.560 
And the Salt is a random string. So if
another user with the same password comes

187
00:15:57.880 --> 00:16:02.360 
then by the selection, by the
random selection of the string,

188
00:16:02.870 --> 00:16:08.280 
the password is in another way
extended and has another hash value

189
00:16:08.910 --> 00:16:11.290 
than the password for
the first user.

190
00:16:12.010 --> 00:16:13.770 
So then of course the

191
00:16:15.100 --> 00:16:20.790 
service provider in its database
has to remember the Salt.

192
00:16:21.420 --> 00:16:26.090 
So we have our user A and B which are
using the same passwor. This is possible

193
00:16:26.710 --> 00:16:35.000 
in plaintext and then here in case
of user A, the password is

194
00:16:35.240 --> 00:16:40.840 
prolonged by these three

195
00:16:41.300 --> 00:16:46.050 
characters and for the other one
it's extended by this three

196
00:16:46.050 --> 00:16:48.780 
password and in the
result these two

197
00:16:49.660 --> 00:16:52.090 
hash values differ.

198
00:16:52.850 --> 00:16:57.010 
And it's no more easy for
the attacker

199
00:16:58.510 --> 00:17:03.770 
from knowing one password to being
able to misuse all the digital

200
00:17:03.770 --> 00:17:07.930 
identities that belong to users
which use the same password.

201
00:17:09.020 --> 00:17:11.710 
Let's summarize what
we have discussed.

202
00:17:12.830 --> 00:17:14.910 
The password authentication is

203
00:17:15.960 --> 00:17:21.160 
an authentication through knowledge.
Password is a secret and the user

204
00:17:21.160 --> 00:17:24.890 
knows a secret and in this way
the service provider trusts

205
00:17:25.230 --> 00:17:27.540 
that this is the
right person and

206
00:17:28.500 --> 00:17:31.390 
which belongs to that
digital identity.

207
00:17:32.150 --> 00:17:36.710 
So when the correct password is
entered the user proves

208
00:17:36.710 --> 00:17:40.170 
that a digital identity belongs
to him. So online service

209
00:17:40.840 --> 00:17:43.540 
does not store
the password

210
00:17:44.430 --> 00:17:50.540 
in a right, in the plaintext but
it stores it in a hashed value.

211
00:17:51.390 --> 00:17:57.120 
And the online service uses the password,
the password that it is first time

212
00:17:57.490 --> 00:18:01.640 
stored when the user
register with the service

213
00:18:02.100 --> 00:18:07.310 
and when the user later want to use the
service, the online service checks

214
00:18:07.620 --> 00:18:12.230 
whether the user knows the
password and for that reason the

215
00:18:12.230 --> 00:18:16.460 
service has to store the
password on his side.

216
00:18:17.140 --> 00:18:18.700 
But the user service is

217
00:18:20.060 --> 00:18:23.020 
advised not to store the
password in plaintext.

218
00:18:23.680 --> 00:18:26.490 
The service is advised
to do this in a

219
00:18:27.290 --> 00:18:30.770 
disguised form as
a password hash,

220
00:18:31.400 --> 00:18:34.960 
how we discussed it. And to
increase the security,

221
00:18:36.100 --> 00:18:40.410 
that only secure
hash methods

222
00:18:41.080 --> 00:18:46.510 
should be applied on one side and
second the password should be

223
00:18:46.730 --> 00:18:49.790 
extended by Salt,
so that the

224
00:18:50.880 --> 00:18:56.580 
password concealment also
works for the same password.

225
00:18:57.650 --> 00:19:02.080 
So in this way, authentication using
passwords is very important

226
00:19:02.080 --> 00:19:05.210 
and to understand
this and in later

227
00:19:07.790 --> 00:19:15.530 
videos we will see how users try
to attack such password based

228
00:19:15.540 --> 00:19:16.520 
digital identities.
