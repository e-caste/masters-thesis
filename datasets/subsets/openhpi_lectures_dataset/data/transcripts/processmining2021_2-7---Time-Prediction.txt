WEBVTT

1
00:00:00.860 --> 00:00:04.879 
Welcome to this video clip in which we discuss the topic of Time Prediction.

2
00:00:06.630 --> 00:00:11.159 
So in practice, we often would like to know how currently running cases

3
00:00:11.160 --> 00:00:15.510 
unfold, so we would like to look a little bit into the future so

4
00:00:15.780 --> 00:00:20.249 
we can see here some running traces for which we may want to

5
00:00:20.250 --> 00:00:25.110 
know how they unfold and, of course, there are different perspectives

6
00:00:25.380 --> 00:00:28.350 
on that, how Trace's can unfold.

7
00:00:28.590 --> 00:00:33.199 
What we are particularly interested in in the context of this clip is time.

8
00:00:33.210 --> 00:00:37.979 
So and it's the reason is the time is simply a particularly

9
00:00:37.980 --> 00:00:42.479 
relevant aspect and in many cases, we would like to understand how

10
00:00:42.480 --> 00:00:46.500 
long it will take until Trace or a case completes.

11
00:00:46.830 --> 00:00:50.848 
And so you can see here some typical questions that we might be interested in as a

12
00:00:51.240 --> 00:00:53.102 
customer, but also as an organization.

13
00:00:53.760 --> 00:00:56.999 
We would be interested in actually being able to answer these questions.

14
00:00:57.420 --> 00:01:01.242 
For instance, when will I receive a decision on my claim that would fit to our

15
00:01:01.950 --> 00:01:06.480 
example that we have used here in other contexts we could be asking,

16
00:01:06.690 --> 00:01:11.099 
when will I receive my order? So, if you order something online, you may be interested in

17
00:01:11.430 --> 00:01:15.030 
typically interested in how long does it take until I receive my items?

18
00:01:15.600 --> 00:01:20.159 
Or in another context, you may also be interested in when will my technical issue

19
00:01:20.160 --> 00:01:24.659 
be fixed? Imagine you had an issue with your phone, you send it out and

20
00:01:24.660 --> 00:01:27.499 
now you want to know when do you get your phone back?

21
00:01:28.170 --> 00:01:32.699 
So, these are all issues that relate to time prediction and

22
00:01:33.450 --> 00:01:37.679 
what we need to do. Of course, if we want to answer the question how long it will take,

23
00:01:37.680 --> 00:01:42.149 
we need to be able to somewhat predict how long it will take and

24
00:01:42.150 --> 00:01:46.439 
the question we would like to answer in the context of this clip is how can we accomplish

25
00:01:46.440 --> 00:01:47.440 
this?

26
00:01:49.090 --> 00:01:51.638 
So the basic idea of time prediction is to look into

27
00:01:53.620 --> 00:01:58.239 
the completed cases, yes, so if we conduct process mining, we have collected

28
00:01:58.240 --> 00:02:01.082 
data about traces from the past and we can, of course, use

29
00:02:02.980 --> 00:02:07.480 
the historical data, this is the idea, of course, to

30
00:02:07.600 --> 00:02:10.859 
predict the remaining runtime of incomplete cases.

31
00:02:10.870 --> 00:02:13.565 
That's the essential idea that we would like to use and

32
00:02:15.460 --> 00:02:20.439 
to be more specific the first idea that we would like to explain here is to use

33
00:02:20.440 --> 00:02:22.360 
Trace's with the same prefix.

34
00:02:22.720 --> 00:02:26.349 
What does it mean? Let's look into an example to illustrate this.

35
00:02:27.760 --> 00:02:32.619 
What you see here is a admittedly quite small event log with just three traces

36
00:02:32.860 --> 00:02:37.839 
and what we have added besides the specific execution

37
00:02:37.840 --> 00:02:41.025 
order or completion times, you see here that we have received the

38
00:02:42.280 --> 00:02:46.629 
claim after ten hours and then checked for completeness after 20,

39
00:02:46.900 --> 00:02:51.130 
etc. So, this entire trace terminates after

40
00:02:51.790 --> 00:02:54.338 
245 hours and so we have added here these completion

41
00:02:56.380 --> 00:03:00.849 
timestamps, that is, of course, a relevant

42
00:03:00.850 --> 00:03:03.110 
information in the context of time prediction.

43
00:03:03.430 --> 00:03:06.076 
So, this is the data that we have and we would like to

44
00:03:07.870 --> 00:03:10.222 
use this data to predict the time of unfinished,

45
00:03:13.030 --> 00:03:14.680 
of still open traces.

46
00:03:15.610 --> 00:03:18.844 
So, let's look at this example here, so what you see here is still

47
00:03:20.050 --> 00:03:24.262 
running case, we have just made the decision about this case so we

48
00:03:24.580 --> 00:03:29.289 
from now, you're familiar with the process, we know that there is still to two events

49
00:03:29.290 --> 00:03:33.969 
to follow, that is the preparation of the respective

50
00:03:33.970 --> 00:03:35.800 
letter and then the sending of that letter.

51
00:03:36.250 --> 00:03:40.072 
So, there are two activities or events left here and the question is, how long

52
00:03:40.840 --> 00:03:43.470 
does it take? And now the idea of the prefix.

53
00:03:43.750 --> 00:03:48.219 
So, there's a bit of a technical term for basically this execution

54
00:03:48.220 --> 00:03:51.650 
sequence that we have observed. So this here is our prefix with a very

55
00:03:52.840 --> 00:03:56.709 
specific order of receiving claim, checking for completeness,

56
00:03:59.020 --> 00:04:03.449 
inviting the claim review, re-reviewing the claim internally, receiving the claim review

57
00:04:03.460 --> 00:04:05.620 
and then deciding on the claim coverage.

58
00:04:05.650 --> 00:04:09.849 
So, we are now the idea is that we look into our log

59
00:04:10.390 --> 00:04:15.009 
and specifically focus on those races where we have observed this very

60
00:04:15.010 --> 00:04:19.540 
sequence. If we look into our log here,

61
00:04:19.810 --> 00:04:22.260 
what we see is that there are two traces that have

62
00:04:24.370 --> 00:04:27.440 
exactly this prefix, namely the first and the second one.

63
00:04:27.700 --> 00:04:31.870 
Yeah, so we see that we here observe the exact same order

64
00:04:32.170 --> 00:04:36.610 
of events in these two traces and now the idea is, OK,

65
00:04:36.940 --> 00:04:41.589 
if these two traces have the same prefix, we have observed the same

66
00:04:41.590 --> 00:04:46.089 
activities in the very same order, then we can use the remaining

67
00:04:46.100 --> 00:04:47.962 
runtime to predict the runtime of this

68
00:04:50.980 --> 00:04:54.970 
incomplete trace for which we obviously don't know how long it's going to take.

69
00:04:55.450 --> 00:05:00.129 
So, let's look at this. So, what we see here is that the first trace takes

70
00:05:00.130 --> 00:05:04.899 
15 hours until completion and for the second trace, it takes 20 hours until completion.

71
00:05:05.950 --> 00:05:09.625 
Now we have these two traces only so a reasonable approach would be to say,

72
00:05:10.420 --> 00:05:12.576 
OK, we simply take an average here and could

73
00:05:15.100 --> 00:05:19.480 
argue that the remaining runtime of this incomplete trace is

74
00:05:20.230 --> 00:05:24.601 
17.5 Hours. So, we added up to 243 plus 17.5,

75
00:05:24.880 --> 00:05:28.340 
we end up with 260.5 Hours in total.

76
00:05:28.960 --> 00:05:33.699 
So, that is a very simple approach where we leverage

77
00:05:33.700 --> 00:05:36.983 
the idea that we can learn, so to say from the completed traces and

78
00:05:38.290 --> 00:05:42.859 
use the data about the completed traces and the runtime data about completed tries

79
00:05:42.970 --> 00:05:44.920 
to predict incomplete traces.

80
00:05:45.910 --> 00:05:48.213 
Now, there are several problems related to this

81
00:05:50.410 --> 00:05:55.029 
approach, and the problem is mainly related

82
00:05:55.030 --> 00:05:57.921 
to this notion of a prefix, so focusing on traces that have

83
00:05:59.740 --> 00:06:04.360 
the exact same prefix. So, what we've just done is we said, OK, we

84
00:06:04.570 --> 00:06:09.112 
only consider traces that have exactly the same activity order,

85
00:06:09.280 --> 00:06:14.079 
we have observed exactly the same activity order is, in practice, hard to justify

86
00:06:14.080 --> 00:06:18.570 
because of many reasons. One of the obvious reason is, of course, parallelism.

87
00:06:18.580 --> 00:06:20.589 
Let's look at an example to illustrate this.

88
00:06:20.950 --> 00:06:22.322 
So, if we take this trace as

89
00:06:25.540 --> 00:06:28.823 
an example and what we have analyzed also in the other clips before

90
00:06:30.010 --> 00:06:34.569 
is that here in the middle there is this AND split where we basically have these

91
00:06:34.570 --> 00:06:38.294 
two independent branches. So here we have the internal claim review and here

92
00:06:39.010 --> 00:06:43.720 
we have the two activities where we invite and then receive the claim review.

93
00:06:43.990 --> 00:06:47.230 
They can simply be conducted independently from each other.

94
00:06:47.830 --> 00:06:50.721 
So that means this activity here in particular can occur at

95
00:06:52.300 --> 00:06:56.769 
any moment of time, it could happen before we even invite the claim review

96
00:06:56.770 --> 00:07:00.999 
could happen right after or it could happen after we have received the media.

97
00:07:01.570 --> 00:07:06.100 
So, this illustrates that focusing on this very strict order,

98
00:07:06.320 --> 00:07:11.019 
this focus on this notion of a prefix is simply too strict, we can simply

99
00:07:11.020 --> 00:07:15.549 
swap these two activities and it's very hard to find a reason

100
00:07:15.550 --> 00:07:20.139 
why such a trace would be longer, why we couldn't use this

101
00:07:20.140 --> 00:07:24.820 
trace here as a basis for predicting

102
00:07:25.300 --> 00:07:27.370 
an incomplete trace as well.

103
00:07:27.610 --> 00:07:30.110 
Yeah, and it also comes with the second problem.

104
00:07:30.610 --> 00:07:33.256 
So, what happens actually, if we would like to predict

105
00:07:35.470 --> 00:07:38.557 
the runtime of an incomplete trace for which we cannot find any

106
00:07:39.910 --> 00:07:41.910 
matching trace in our log.

107
00:07:41.920 --> 00:07:46.079 
So, if we try to find that specific prefix in the log and we realize that there

108
00:07:47.200 --> 00:07:51.639 
is no matching trace available, then the only thing that we can do

109
00:07:51.640 --> 00:07:54.579 
is saying, OK, we cannot predict anything.

110
00:07:55.900 --> 00:08:00.639 
So, this shows that this notion of a prefix and there's a very strict

111
00:08:00.820 --> 00:08:05.679 
idea of looking for traces where we have observed the exact same execution

112
00:08:05.680 --> 00:08:09.519 
sequence is simply too strict and there is a need for abstraction.

113
00:08:11.230 --> 00:08:15.759 
And the idea we would like to introduce here is the state abstraction,

114
00:08:15.760 --> 00:08:18.450 
a so-called street abstraction based on sets.

115
00:08:19.750 --> 00:08:24.550 
So, it's important to keep in mind when we talk about sets that in the set, every element

116
00:08:24.790 --> 00:08:28.689 
was just once and second, there is no order considered.

117
00:08:29.080 --> 00:08:32.363 
We use an example to illustrate this, but this is already important

118
00:08:33.909 --> 00:08:38.619 
to keep in mind. The idea is now that by representing states assets,

119
00:08:38.620 --> 00:08:42.370 
we can address some of the problems that we have discussed before.

120
00:08:43.450 --> 00:08:48.039 
So, what you see here is on the right hand side, what we will refer

121
00:08:48.040 --> 00:08:51.690 
to as a state. So, this is nothing else but a set consisting

122
00:08:52.900 --> 00:08:54.610 
of a number of activities.

123
00:08:55.270 --> 00:08:57.700 
So, these curly brackets indicate that we're looking at a set.

124
00:08:58.630 --> 00:09:03.490 
So, it's important to keep in mind that every element will occupy just once, even if

125
00:09:04.510 --> 00:09:09.249 
this one of these activities or more of these activities have been executed

126
00:09:09.250 --> 00:09:12.679 
several times and the order here is arbitrary.

127
00:09:12.700 --> 00:09:16.914 
So, there is an order that you can see, but it doesn't have any meaning or elements of

128
00:09:17.140 --> 00:09:19.730 
a set do not have an actual order.

129
00:09:20.350 --> 00:09:23.739 
How does this help us in our context?

130
00:09:23.770 --> 00:09:27.909 
Well, what you see here is that this state that is

131
00:09:28.210 --> 00:09:33.249 
essentially a set of events actually captures or can represent

132
00:09:33.400 --> 00:09:37.809 
all of these traces here, all of these prefixes.

133
00:09:38.170 --> 00:09:42.249 
Yeah, so you see here that we have the prefix where we first receive the claim, then

134
00:09:42.250 --> 00:09:46.599 
check for completeness, then invite the claim review, then review the claim internally

135
00:09:46.600 --> 00:09:49.029 
and receive the claim review and then decide.

136
00:09:49.450 --> 00:09:52.659 
Then we see several variations of this.

137
00:09:52.850 --> 00:09:57.610 
So, here we first received the claim review and then

138
00:09:57.910 --> 00:10:00.360 
we review the claim internally.

139
00:10:00.370 --> 00:10:04.899 
So this variation is represented by the exact same state, just like all

140
00:10:04.900 --> 00:10:07.989 
the other ones. So why is this interesting?

141
00:10:08.050 --> 00:10:12.850 
Well, this is interesting because this state can represent

142
00:10:13.000 --> 00:10:16.910 
all these prefixes and quite some more in this one we've indicated here

143
00:10:17.980 --> 00:10:21.116 
and this now helps us, because if we so imagine we have observed

144
00:10:22.840 --> 00:10:27.099 
only an event log, we have only included the first two,

145
00:10:28.210 --> 00:10:32.169 
then we could still make a prediction for the other ones, even though we have never

146
00:10:32.170 --> 00:10:37.270 
actually observed them before because they all relate to the same state

147
00:10:37.510 --> 00:10:42.009 
based on sets and this is the idea we would like to leverage

148
00:10:42.490 --> 00:10:46.900 
that we abstract from the specific prefixes and so to

149
00:10:46.910 --> 00:10:51.159 
say, summarize several prefixes in a set based state

150
00:10:51.550 --> 00:10:55.820 
that allows us to be much more flexible with respect to the prediction of time.

151
00:10:57.220 --> 00:11:00.356 
So, what does it mean for our log if we now try to represent our

152
00:11:01.750 --> 00:11:03.465 
entire log based on sets, then this

153
00:11:06.370 --> 00:11:10.310 
looks as follows. Let's simply go through this step by step to illustrate this.

154
00:11:10.840 --> 00:11:15.399 
So let's start with the first trace, you see that the

155
00:11:15.400 --> 00:11:20.230 
first trace starts with the recieve claim, so the first state

156
00:11:20.890 --> 00:11:25.240 
or the state that we end up with after executing this event

157
00:11:25.450 --> 00:11:28.341 
is this one. So now if we also execute the second activity,

158
00:11:30.250 --> 00:11:33.429 
check for claim completeness, we end up in this state.

159
00:11:34.510 --> 00:11:38.773 
Now, it's not so surprising what's happening, of course, now, if we move further to the

160
00:11:38.950 --> 00:11:43.577 
right, there's a state that includes invite

161
00:11:43.690 --> 00:11:47.576 
claim review, then there is the state where we have included review claim internally,

162
00:11:47.577 --> 00:11:51.820 
receive claim to make the decision on the claim

163
00:11:52.240 --> 00:11:56.799 
and then what we see here is that in the end, in this case, the claim

164
00:11:56.800 --> 00:12:00.139 
is accepted and then the acceptance letter is being sent out.

165
00:12:00.160 --> 00:12:02.414 
So at the end of this trace, we end up in this

166
00:12:04.840 --> 00:12:07.241 
state. What's now important to realize that these

167
00:12:09.370 --> 00:12:13.494 
states include much more than just this specific order of activities,

168
00:12:14.170 --> 00:12:17.355 
so technically, this stage refers to any execution order of these

169
00:12:18.670 --> 00:12:23.242 
three activities. So, even if we would have started with a check for claim completeness,

170
00:12:23.350 --> 00:12:27.074 
obviously, that is not in line with our expectations because the model would

171
00:12:28.000 --> 00:12:31.899 
not consider this a compliant or conforming case but

172
00:12:32.440 --> 00:12:37.029 
this is not the point here. So, we here we are simply interested in having

173
00:12:37.030 --> 00:12:41.739 
a representation of the states that allows for a bit more flexibility than the prefixes.

174
00:12:42.190 --> 00:12:44.787 
So, now we have the states from the first trace only.

175
00:12:46.420 --> 00:12:48.086 
So let's look what we have to add.

176
00:12:48.370 --> 00:12:53.029 
If we also would like to represent and include the other two, Trace's as well.

177
00:12:53.500 --> 00:12:57.224 
So if we look at the second trace, we see that it actually follows the exact

178
00:12:58.120 --> 00:13:01.795 
same sequence, the only difference being that in the end we actually reject

179
00:13:02.720 --> 00:13:05.529 
the claim and send a rejection letter, respectively.

180
00:13:06.430 --> 00:13:10.105 
So here, obviously, we may not only go to this state, we have been prepared

181
00:13:11.110 --> 00:13:14.540 
to approve the letter, but we may also end up or move to a state where

182
00:13:15.700 --> 00:13:18.248 
we have prepared a rejection letter and respectively

183
00:13:20.830 --> 00:13:25.820 
also move over to a state where we have then sent out this letter of rejections.

184
00:13:27.520 --> 00:13:29.970 
Finally, let's look at the third trace.

185
00:13:30.250 --> 00:13:34.659 
So what you see here is that we indeed here observe some variation

186
00:13:35.230 --> 00:13:37.419 
with respect to these reviewing activities.

187
00:13:37.430 --> 00:13:42.141 
So here we have invite, claim, review first and then review claim internally

188
00:13:42.460 --> 00:13:46.539 
and the third trace, we see that we review the claim internally first.

189
00:13:46.690 --> 00:13:51.339 
So, what does it mean? Well, that basically moving from this state to

190
00:13:51.340 --> 00:13:54.329 
this state. So, where we first have received the claim check,

191
00:13:55.870 --> 00:13:59.739 
claim completeness and then move to the state where we have

192
00:14:01.210 --> 00:14:05.277 
reviewed the claim internally, important to realize and to note is that, of course,

193
00:14:05.860 --> 00:14:10.539 
once we have then also executed the invite for claim review

194
00:14:10.540 --> 00:14:13.370 
activity, then we move to this state.

195
00:14:13.480 --> 00:14:18.129 
So, here we end up in the same state that we have seen before, again,

196
00:14:18.250 --> 00:14:22.390 
because the order does not matter in a particular state, set

197
00:14:22.690 --> 00:14:25.419 
based state. So, this

198
00:14:27.430 --> 00:14:32.079 
set of states essentially represents our very small log, what

199
00:14:32.080 --> 00:14:36.519 
we can do on top now, this is, of course, relevant for the sake of time prediction

200
00:14:36.520 --> 00:14:38.559 
is to add the remaining times.

201
00:14:38.560 --> 00:14:43.239 
So, for each state, we can now compute how much time is left according

202
00:14:43.510 --> 00:14:48.039 
to the model, and we can simply annotate each state respectively.

203
00:14:48.730 --> 00:14:50.200 
So, this is what you can see here.

204
00:14:51.880 --> 00:14:55.510 
So, what you see here are essentially averages, right, so for

205
00:14:56.560 --> 00:15:01.129 
each from each trace in this case, we get different information.

206
00:15:01.150 --> 00:15:05.500 
So, you see that here, this trace is actually faster than this one

207
00:15:05.660 --> 00:15:09.950 
and that these have the same time but there are some variations in between.

208
00:15:10.420 --> 00:15:15.039 
So, these are simply the completion times that we take from

209
00:15:15.040 --> 00:15:19.749 
the event log and we annotate each state with the remaining runtime

210
00:15:19.750 --> 00:15:21.820 
according to this log.

211
00:15:22.120 --> 00:15:25.697 
And in case we have two or more values, we simply compute the average and

212
00:15:26.590 --> 00:15:29.860 
include this here and this representation, respectively.

213
00:15:31.910 --> 00:15:35.291 
So, we now can do with this representation is actually we can predict

214
00:15:36.350 --> 00:15:40.221 
the time of unseen traces, of incomplete traces and this is, of course, exactly

215
00:15:41.090 --> 00:15:44.309 
what we would like to do. So, let's look at some examples.

216
00:15:44.900 --> 00:15:48.428 
So this is an incomplete trace where we have just received the claim, we

217
00:15:49.490 --> 00:15:53.959 
have conducted the claim completeness check and we have reviewed

218
00:15:53.960 --> 00:15:58.272 
the claim internally and now the question is when the question that we have to answer as

219
00:15:58.460 --> 00:16:01.579 
to which state does this incomplete trace relate?

220
00:16:02.030 --> 00:16:06.859 
We realized that it actually relates to this state and well,

221
00:16:07.250 --> 00:16:10.890 
we are ready by figuring that out, we already have our answer.

222
00:16:11.420 --> 00:16:15.889 
And so the remaining run time would have predicted remaining runtime for this

223
00:16:15.890 --> 00:16:17.292 
incomplete trace is 195.

224
00:16:20.090 --> 00:16:23.324 
Let's look at another example, so here we have received the claim,

225
00:16:24.830 --> 00:16:29.419 
have checked the claim for completeness and invited to claim review and

226
00:16:29.420 --> 00:16:32.507 
if you check with this representation, you see that this prefix

227
00:16:34.340 --> 00:16:38.059 
then relates to a different state in this graph here.

228
00:16:38.420 --> 00:16:40.649 
So it actually relates to this state.

229
00:16:41.360 --> 00:16:45.788 
So the conclusion is that the remaining runtime is 232.

230
00:16:48.640 --> 00:16:53.850 
Let's look at another example a bit further in the process of execution,

231
00:16:54.100 --> 00:16:57.669 
so here we you see that we have just made the decision.

232
00:16:57.670 --> 00:16:59.875 
So there are just two activities left and the

233
00:17:02.350 --> 00:17:06.939 
respective state would be that one, yeah, so the predicted

234
00:17:06.940 --> 00:17:09.660 
time or remaining runtime would be 18.

235
00:17:10.810 --> 00:17:14.289 
Here you see a variation of this, so it's again, we'd like to highlight

236
00:17:15.339 --> 00:17:19.809 
that these are states based on sets, so the order does not matter.

237
00:17:20.050 --> 00:17:22.990 
So, that means that this trace here where actually we do not

238
00:17:24.640 --> 00:17:28.509 
invite the claim review first, but review the claim internally first,

239
00:17:29.080 --> 00:17:31.824 
does represent, does relate to the exact same state here

240
00:17:33.520 --> 00:17:37.933 
in our graph. So the predicted remaining runtime is 18

241
00:17:38.440 --> 00:17:41.086 
as well and so it's important to realize that this, of

242
00:17:42.880 --> 00:17:47.260 
course, provides is an abstraction from from reality and comes

243
00:17:47.500 --> 00:17:51.567 
with advantages and disadvantages but what you can see here from these examples is,

244
00:17:51.940 --> 00:17:56.589 
of course, that it provides us with quite some flexibility and would allow

245
00:17:56.590 --> 00:18:00.453 
us to indeed also predict the remaining runtime of trace's

246
00:18:01.570 --> 00:18:05.559 
for which we have not where we've not seen the specific prefix before.

247
00:18:07.010 --> 00:18:10.048 
To summarize, we can predict the remaining runtime of a trace,

248
00:18:11.840 --> 00:18:16.279 
of an incomplete trace based on data that we have collected about completed trace.

249
00:18:16.340 --> 00:18:19.819 
So, that's the basic idea that we have presented here and that a robust

250
00:18:21.170 --> 00:18:24.502 
solution is what we discussed requires to define a suitable state abstraction.

251
00:18:25.670 --> 00:18:30.169 
So, it's a very technical term, but we, of course, need to be able to somehow

252
00:18:30.170 --> 00:18:34.645 
represent the state of the trace in a suitable way,

253
00:18:34.970 --> 00:18:39.619 
we have seen that if we work with prefixes, we're in a very strict

254
00:18:39.620 --> 00:18:44.059 
context and if we work with sets, we are much more flexible and in that sense,

255
00:18:46.100 --> 00:18:50.329 
this choice, again, relates to the issue of overfitting and underfeeding that we have

256
00:18:50.330 --> 00:18:52.539 
discussed in the context of the quality dimensions.

257
00:18:52.910 --> 00:18:56.487 
So, if we work with prefixes, we're more likely to overfit because we are

258
00:18:57.380 --> 00:19:00.271 
very strict and insist, OK, we can only predict the runtime

259
00:19:01.880 --> 00:19:05.069 
of this trace if we have seen the very same prefix before.

260
00:19:06.380 --> 00:19:09.467 
While a set based representation might be more suitable, again,

261
00:19:10.940 --> 00:19:15.709 
which state representation is appropriate, depends on the context,

262
00:19:15.710 --> 00:19:20.569 
depends on the type of the process but we have discussed two specific

263
00:19:21.200 --> 00:19:24.679 
choices here that can be also applied in practice.
