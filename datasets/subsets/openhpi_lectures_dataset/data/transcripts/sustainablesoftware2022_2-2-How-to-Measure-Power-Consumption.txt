WEBVTT

1
00:00:00.510 --> 00:00:04.620 
Hi again. In the previous chapters we already briefly talked about energy efficiency

2
00:00:04.870 --> 00:00:08.010 
and especially about how it can vary across different programming languages.

3
00:00:08.380 --> 00:00:12.250 
In this chapter now we want to look into how to actually measure that energy.

4
00:00:14.220 --> 00:00:18.340 
Let me first have a few words about what energy efficiency actually even is.

5
00:00:19.240 --> 00:00:23.130 
So, efficiency in very simple terms, usually is about how much

6
00:00:23.130 --> 00:00:27.820 
you get for how much you give. And in this case what you give is basically energy

7
00:00:28.080 --> 00:00:29.920 
and what you get is calculations.

8
00:00:31.010 --> 00:00:34.850 
The energy efficiency can be measured on multiple different multiple different levels.

9
00:00:35.190 --> 00:00:38.720 
So for instance, you could specify the energy efficiency of

10
00:00:38.720 --> 00:00:42.290 
a whole data center and a commonly used metric here is the

11
00:00:42.290 --> 00:00:44.710 
PUE or power usage effectiveness.

12
00:00:45.390 --> 00:00:49.520 
However this is not quite what we want. Instead we want to get way more fine-grained

13
00:00:49.760 --> 00:00:54.160 
and want to get the energy efficiency of actual software programs on a

14
00:00:54.620 --> 00:00:56.000 
on a quite low level.

15
00:00:57.990 --> 00:01:00.760 
Let me start with a few fundamentals here. So, remember this

16
00:01:00.760 --> 00:01:04.840 
simple formula from the previous slides which stated that energy

17
00:01:04.840 --> 00:01:09.040 
is the product of power multiplied by time, where as energy

18
00:01:09.040 --> 00:01:13.620 
is measured in joules, power is measured in watts and time obviously in seconds.

19
00:01:15.580 --> 00:01:16.980 
With respect to software now,

20
00:01:17.840 --> 00:01:22.520 
it is usually about basically in simple terms how much you

21
00:01:22.520 --> 00:01:25.490 
can squeeze out, like how many calculations you can squeeze

22
00:01:25.490 --> 00:01:30.230 
out of every bit of energy you spend. Or more formally, the energy

23
00:01:30.230 --> 00:01:33.860 
efficiency of software can be defined as the number of calculations

24
00:01:33.860 --> 00:01:39.490 
or computations per joule or equivalently the number of floating-point operations per second

25
00:01:39.640 --> 00:01:44.680 
per watt. This is not entirely correct in that it only

26
00:01:45.180 --> 00:01:48.930 
it only focuses on CPU and neglects things like storage and network

27
00:01:49.380 --> 00:01:55.090 
and it also only assumes that the CPU solely performs floating-point operations,

28
00:01:55.380 --> 00:01:58.540 
both of which are simplifying assumptions that are not entirely correct.

29
00:01:58.870 --> 00:02:03.290 
But let's stick with the concept anyway for now and let's keep

30
00:02:03.530 --> 00:02:04.500 
things simple.

31
00:02:09.860 --> 00:02:13.590 
So, now that you've got a rough idea of what energy efficiency

32
00:02:13.590 --> 00:02:15.940 
is and how it can be defined,

33
00:02:16.650 --> 00:02:18.980 
we now

34
00:02:19.810 --> 00:02:22.050 
want to look into how to actually measure it

35
00:02:23.170 --> 00:02:25.500 
because that's a quite interesting part.

36
00:02:26.470 --> 00:02:29.150 
So again, the formula from the previous slides remember it,

37
00:02:29.590 --> 00:02:33.150 
it defined energy as the product of power multiplied by time

38
00:02:33.490 --> 00:02:36.530 
and of course the time part of the equation is quite easy to measure.

39
00:02:37.250 --> 00:02:42.590 
Basically you just take a clock and measure how long your program takes to execute.

40
00:02:43.430 --> 00:02:46.480 
Instead the power part of the equation is way harder to measure

41
00:02:46.810 --> 00:02:50.140 
and especially since we're interested in measuring it on a

42
00:02:50.140 --> 00:02:53.640 
quite low level. So we're interested in measuring the power

43
00:02:53.640 --> 00:02:56.780 
consumption of individual programs or individual processes

44
00:02:57.950 --> 00:03:01.340 
rather than of a whole system. So measuring the power consumption

45
00:03:01.340 --> 00:03:05.080 
of a whole system for instance a notebook or a whole server rack

46
00:03:05.340 --> 00:03:09.100 
it is quite easy but breaking that down into

47
00:03:09.530 --> 00:03:14.710 
smaller parts and attributing parts of their total power consumption to individual

48
00:03:15.470 --> 00:03:19.970 
parts or individual software components, that is way harder and

49
00:03:20.190 --> 00:03:25.670 
rather non-trivial. And in fact it's even an ongoing research topic, so

50
00:03:26.010 --> 00:03:29.500 
there's no real right or wrong here. There's no already well

51
00:03:29.500 --> 00:03:32.940 
established standards but instead there's still many still

52
00:03:32.940 --> 00:03:34.600 
much research being conducted.

53
00:03:35.970 --> 00:03:40.310 
So, we categorized the approaches to measuring power consumption of software

54
00:03:40.610 --> 00:03:42.950 
into essentially three different classes.

55
00:03:43.630 --> 00:03:45.710 
One of them being hardware based approaches,

56
00:03:46.790 --> 00:03:49.220 
moreover software based approaches and lastly

57
00:03:49.710 --> 00:03:51.510 
what we call analytical approaches.

58
00:03:52.280 --> 00:03:56.910 
Let's in the following slides now get or look into each of

59
00:03:56.910 --> 00:03:57.700 
them briefly.

60
00:04:00.610 --> 00:04:03.420 
So, let's start with hardware based measurements, because these

61
00:04:03.420 --> 00:04:07.750 
are the most obvious ones and also the most arguably the most simple ones

62
00:04:08.050 --> 00:04:11.970 
as in fact they are not too much different from how you would even measure your

63
00:04:12.420 --> 00:04:14.450 
energy consumption of your apartment at home.

64
00:04:14.880 --> 00:04:18.900 
And in fact the simplest method here is to essentially just

65
00:04:19.220 --> 00:04:23.200 
use a power meter plugged between your wall socket and your machine

66
00:04:23.490 --> 00:04:26.750 
and just measure the power that the power intake of your machine

67
00:04:28.150 --> 00:04:29.300 
through that power meter.

68
00:04:30.230 --> 00:04:34.550 
To get a bit more precise, what a research paper did is they

69
00:04:34.840 --> 00:04:37.990 
basically intercepted the CPU power lines to

70
00:04:38.420 --> 00:04:42.980 
get a metric about the CPUs like the power consumption of

71
00:04:42.980 --> 00:04:44.540 
the CPU in isolation,

72
00:04:45.410 --> 00:04:47.390 
or what is also commonly

73
00:04:48.050 --> 00:04:51.300 
being done in literature is to use specialized development

74
00:04:51.300 --> 00:04:54.380 
boards or electronic circuits which are made solely for the

75
00:04:54.380 --> 00:04:56.770 
purpose of energy or power measurements.

76
00:04:58.410 --> 00:05:01.410 
A pro of these hardware-based approaches is that the measurements

77
00:05:01.410 --> 00:05:05.740 
themselves are quite precise as you're measuring the actual physical,

78
00:05:06.010 --> 00:05:09.490 
like the actual raw physical voltage and current.

79
00:05:10.270 --> 00:05:14.500 
While a drawback here is that it is usually quite difficult

80
00:05:14.510 --> 00:05:18.670 
as we already discussed to break these measurements down for

81
00:05:18.670 --> 00:05:23.310 
individual components or even programs. Usually you get rather the

82
00:05:23.520 --> 00:05:25.140 
measurements for the whole system

83
00:05:25.970 --> 00:05:28.090 
instead of individual components.

84
00:05:30.450 --> 00:05:32.970 
Okay let's move on to the software based approaches.

85
00:05:33.790 --> 00:05:37.210 
These are arguably the most interesting ones and also the ones

86
00:05:37.210 --> 00:05:38.970 
where most research is going on with.

87
00:05:40.270 --> 00:05:44.840 
And a very important piece in the toolbox of these software-based measurements is the

88
00:05:45.100 --> 00:05:49.920 
intel or apple tool which is basically a software defined power meter

89
00:05:50.710 --> 00:05:55.960 
that reports power usage values directly from your CPU at any time.

90
00:05:57.440 --> 00:06:02.640 
This one also builds the basis for most other approaches, including the next one

91
00:06:03.280 --> 00:06:07.270 
that builds on top of this power meter.

92
00:06:08.010 --> 00:06:12.170 
It's a tool presented in the context of a paper from 2015

93
00:06:12.810 --> 00:06:14.490 
and it is called PowerAPI

94
00:06:16.320 --> 00:06:19.990 
which is a quite comprehensive and complex software tool suite

95
00:06:20.480 --> 00:06:24.390 
designed solely for the purpose of power measurements. And it

96
00:06:24.390 --> 00:06:27.860 
even features measurements on different levels of granularity

97
00:06:28.150 --> 00:06:31.800 
ranging from device level down to individual program level.

98
00:06:32.990 --> 00:06:36.410 
It also supports different power models as well as

99
00:06:37.540 --> 00:06:41.510 
different types of sensory and it also comes as a python module

100
00:06:41.510 --> 00:06:44.910 
so you can even use it inside your own code with a quite easy

101
00:06:44.910 --> 00:06:46.350 
to use and high level API.

102
00:06:47.050 --> 00:06:49.740 
So I would definitely recommend to check this tool out

103
00:06:50.160 --> 00:06:53.520 
as it is quite an impressive piece of software in the

104
00:06:54.060 --> 00:06:56.410 
context of power measurement.

105
00:06:58.220 --> 00:07:02.650 
Moreover, I want to depict another or I want to highlight another

106
00:07:03.610 --> 00:07:07.850 
research paper which now instead focuses on measuring the power

107
00:07:07.850 --> 00:07:09.790 
consumption on a per container level.

108
00:07:10.810 --> 00:07:15.680 
In this research paper, what the authors did is they essentially had the vision

109
00:07:16.090 --> 00:07:20.760 
to have energy as just another resource besides CPU compute,

110
00:07:21.500 --> 00:07:24.640 
storage usage and network utilization.

111
00:07:25.540 --> 00:07:30.240 
And then be able to constrain and allocate this resource among different containers

112
00:07:30.930 --> 00:07:36.060 
and essentially on a per container level define

113
00:07:36.060 --> 00:07:37.520 
so called power budgets

114
00:07:38.520 --> 00:07:43.790 
which then determine how the container, like how many how much performance

115
00:07:43.980 --> 00:07:47.610 
the container is allowed to consume

116
00:07:49.510 --> 00:07:54.470 
and be able to basically schedule and orchestrate the containers based on their

117
00:07:54.750 --> 00:07:58.140 
actual energy consumption. And for that they proposed a tool

118
00:07:58.140 --> 00:08:00.280 
called a software tool called DockerCap.

119
00:08:01.750 --> 00:08:05.520 
Lastly the last thing I want to present here is

120
00:08:06.140 --> 00:08:10.210 
another research paper that goes even one step further and

121
00:08:10.780 --> 00:08:15.520 
tries to estimate the power consumption even on a per method level. So

122
00:08:15.760 --> 00:08:17.560 
one step more fine grained.

123
00:08:18.790 --> 00:08:23.010 
And what the authors here did is they proposed a software framework

124
00:08:23.010 --> 00:08:26.300 
that essentially hooks into your code and measures the execution

125
00:08:26.300 --> 00:08:30.990 
time of individual functions as well as their percentage of the total program

126
00:08:31.370 --> 00:08:32.320 
execution time

127
00:08:33.560 --> 00:08:37.440 
and combined with power measurements using the Intel RAPL tool,

128
00:08:37.740 --> 00:08:42.970 
they can then estimate the percentage, the power consumption percentage of each

129
00:08:43.250 --> 00:08:44.710 
method inside the program.

130
00:08:47.520 --> 00:08:50.680 
So, of course to the software based approaches there are

131
00:08:51.350 --> 00:08:54.060 
pros and cons as well. Pros including that

132
00:08:54.480 --> 00:08:58.940 
these approaches are other non-intrusive meaning that you don't

133
00:08:58.940 --> 00:09:02.380 
have to mess with physical wire cables.

134
00:09:03.610 --> 00:09:05.410 
Instead everything is just software based.

135
00:09:06.760 --> 00:09:11.450 
And another pro is quite high level of granularity as we saw earlier

136
00:09:11.850 --> 00:09:17.020 
that it can even be broken down to individual methods or classes of a program.

137
00:09:18.580 --> 00:09:22.870 
Disadvantages of these type of approaches include that rather

138
00:09:22.960 --> 00:09:25.510 
or mostly all of them are rather heuristic

139
00:09:26.790 --> 00:09:31.510 
and based on power models. So instead of measuring the actual raw physical values,

140
00:09:32.230 --> 00:09:34.370 
you're instead

141
00:09:35.130 --> 00:09:38.600 
measuring on a derived level, so to say.

142
00:09:40.010 --> 00:09:44.320 
And moreover, what can be considered another disadvantage of these approaches is

143
00:09:44.710 --> 00:09:47.730 
they're overhead in terms of that these software measurement

144
00:09:48.240 --> 00:09:52.230 
tools themselves again consume energy

145
00:09:52.760 --> 00:09:56.690 
which can be considered a disadvantage of these approaches.

146
00:09:59.020 --> 00:10:02.860 
The last category is what we call the analytical approaches.

147
00:10:03.100 --> 00:10:05.310 
And without going into too much detail here,

148
00:10:05.840 --> 00:10:10.680 
so, the basic idea here is basically to take a complex program

149
00:10:10.680 --> 00:10:15.410 
and break it down into its individual fundamental parts, its individual

150
00:10:16.230 --> 00:10:18.920 
assembly language level CPU instructions.

151
00:10:19.490 --> 00:10:22.820 
And then for each of these instructions you know the time or

152
00:10:22.830 --> 00:10:26.270 
rather the number of CPU cycles it takes to execute them.

153
00:10:27.120 --> 00:10:31.100 
And if you combine this by the frequency and voltage of your CPU,

154
00:10:31.560 --> 00:10:35.500 
you can then basically get an estimate of

155
00:10:35.990 --> 00:10:41.820 
the theoretical expected power consumption of your program on a

156
00:10:42.230 --> 00:10:44.480 
rather analytical and theoretical level.

157
00:10:45.790 --> 00:10:47.670 
An advantage here is that, again,

158
00:10:48.640 --> 00:10:51.900 
these are non-intrusive approaches. Meaning that,

159
00:10:52.430 --> 00:10:54.940 
you don't have to like cut power lines or so

160
00:10:55.540 --> 00:10:57.770 
in order to use them.

161
00:10:58.660 --> 00:11:03.790 
And disadvantages include that it only considered CPU and neglects

162
00:11:03.810 --> 00:11:08.090 
things like stretch network and also this is rather useful only for

163
00:11:08.300 --> 00:11:12.640 
highly CPU bown programs like in the case with machine learning applications or so.

164
00:11:13.880 --> 00:11:19.380 
By the way, these these disadvantages also mostly applied to the

165
00:11:19.620 --> 00:11:21.780 
software-based type of approaches as well.

166
00:11:24.740 --> 00:11:29.370 
Okay, so now that you got a brief outline of the approaches available out there.

167
00:11:30.240 --> 00:11:36.210 
The key take-away here is for you now that all of these approaches are rather approximate.

168
00:11:36.630 --> 00:11:38.510 
None of them is really one hundred percent accurate.

169
00:11:39.050 --> 00:11:44.440 
And as you saw it is quite non-trivial to measure the power consumption of software.

170
00:11:45.520 --> 00:11:49.620 
So, now that we have learned this, let's again simplify things again a bit

171
00:11:50.210 --> 00:11:54.080 
and again go back to taking the execution time of a program

172
00:11:54.090 --> 00:11:57.190 
as a proxy for its energy consumption.

173
00:11:58.020 --> 00:12:00.420 
We're going to do so in the remaining course and especially

174
00:12:00.420 --> 00:12:03.360 
also in the coding exercises, we are going to

175
00:12:03.990 --> 00:12:07.300 
measure the execution time of your program rather than its

176
00:12:07.300 --> 00:12:11.190 
actual energy consumption in joules, just because it's easier to do

177
00:12:11.920 --> 00:12:16.580 
and it would be way too hard to set up a complex measurement infrastructure for that.

178
00:12:17.410 --> 00:12:19.560 
But always keep in mind, also

179
00:12:20.330 --> 00:12:24.000 
these concepts are like the execution time of a program

180
00:12:24.000 --> 00:12:28.780 
and its energy usage, although these are very highly correlated

181
00:12:29.290 --> 00:12:32.680 
they're still not equivalent concepts,

182
00:12:33.530 --> 00:12:35.830 
which is a fact that you should keep in mind.
