WEBVTT

1
00:00:00.790 --> 00:00:04.300 
Welcome to the introduction to the Mainframe CPU Architecture.

2
00:00:04.490 --> 00:00:06.670 
The architecture of the mainframe processors.

3
00:00:07.190 --> 00:00:11.000 
My name is Philipp Brune from the Neu-Ulm University of Applied Sciences.

4
00:00:13.150 --> 00:00:17.080 
The mainframe process architecture from the beginning has been

5
00:00:17.340 --> 00:00:19.060 
designed in a way that it is

6
00:00:19.920 --> 00:00:24.460 
not just defined ad-hoc as it was used in these days, in the

7
00:00:24.790 --> 00:00:30.230 
sixties for other systems, but before the architecture was implemented,

8
00:00:30.680 --> 00:00:35.620 
its principles were laid down in a document called the principles of operation.

9
00:00:36.090 --> 00:00:41.190 
This document is basically a description of the architecture. So it specifies

10
00:00:41.490 --> 00:00:43.460 
registers, instruction set,

11
00:00:44.850 --> 00:00:47.860 
I/O system and everything related to the hardware.

12
00:00:48.590 --> 00:00:53.020 
And this document has remained until today. So, it has been

13
00:00:54.150 --> 00:00:58.870 
a new version of the principles of operation for every new generation

14
00:00:59.030 --> 00:01:02.750 
of the mainframe CPU. And this document is public, so you can

15
00:01:02.800 --> 00:01:08.140 
download and read it and in principle can be used to build a compatible system

16
00:01:09.020 --> 00:01:12.610 
this is sometimes used by emulation approaches as well in the

17
00:01:12.610 --> 00:01:14.130 
past it was also used by

18
00:01:15.120 --> 00:01:20.890 
other IT companies that offered IBM compatible mainframe systems. And

19
00:01:22.520 --> 00:01:24.980 
it's very instructive to read this document because

20
00:01:25.420 --> 00:01:27.330 
if you want to get a deep understanding of

21
00:01:28.090 --> 00:01:30.730 
the way how this system actually works.

22
00:01:33.110 --> 00:01:34.480 
The Principles of Operation

23
00:01:35.190 --> 00:01:37.050 
are basically the

24
00:01:38.480 --> 00:01:42.540 
essential specification of the system. Over the years the architecture

25
00:01:42.540 --> 00:01:47.540 
of the mainframe CPU has evolved from the original S360

26
00:01:47.540 --> 00:01:50.150 
architecture which was a sixteen and then

27
00:01:50.150 --> 00:01:52.110 
later twenty four bit system.

28
00:01:53.220 --> 00:01:58.230 
Here the number of bits refers to the width of the CPU internal data

29
00:01:58.690 --> 00:02:01.260 
buses and registers and

30
00:02:03.330 --> 00:02:04.330 
then it was

31
00:02:06.470 --> 00:02:10.310 
succeeded or superseded by the S370

32
00:02:11.160 --> 00:02:13.560 
architecture which was first XA which was

33
00:02:14.340 --> 00:02:17.480 
for the first time than a thirty one bit architecture.

34
00:02:18.610 --> 00:02:22.890 
And then this was again extended in the eighties

35
00:02:23.450 --> 00:02:28.540 
to the so called ESA architecture which also was a thirty one

36
00:02:28.540 --> 00:02:31.190 
bit system but with some special features to

37
00:02:31.720 --> 00:02:34.310 
have more address space and then

38
00:02:35.070 --> 00:02:40.230 
it came up with S390 in the nineties and then

39
00:02:40.230 --> 00:02:44.220 
later on with the z. So you could see that whereas in the first

40
00:02:44.530 --> 00:02:47.120 
version the S360, the 360 was

41
00:02:47.140 --> 00:02:50.680 
a synonym for three hundred sixty degrees, showing the

42
00:02:51.590 --> 00:02:56.960 
unique or the possibility to use the system in nearly all kinds of applications.

43
00:02:57.820 --> 00:03:00.870 
Then later on it became more like a number of decades. So

44
00:03:00.870 --> 00:03:03.080 
in the seventies it was three hundred seventy,

45
00:03:03.750 --> 00:03:06.470 
and in the nineties it was three hundred ninety, in the eighties

46
00:03:06.470 --> 00:03:08.990 
it was not three hundred eighty but it was three hundred seventy.

47
00:03:09.590 --> 00:03:11.960 
Or just called the ESA architecture.

48
00:03:12.620 --> 00:03:16.320 
And then in the new century it has been renamed to system z

49
00:03:17.370 --> 00:03:21.810 
nowadays it's called z systems and before that it was named z series. So

50
00:03:23.030 --> 00:03:25.760 
the numbers have not continued.

51
00:03:30.770 --> 00:03:34.320 
It's important to see that this system switch from twenty four

52
00:03:34.320 --> 00:03:37.380 
to thirty one bit. Now you could ask why thirty one bit. Usually

53
00:03:37.380 --> 00:03:40.330 
in computer science, we have thirty two bit. The answer is that

54
00:03:40.510 --> 00:03:42.530 
of course it is thirty two bit system but the

55
00:03:45.260 --> 00:03:49.410 
most significant bit is used for indicating whether it

56
00:03:49.410 --> 00:03:53.440 
is a twenty four bit instruction for backward compatibility or a real

57
00:03:54.440 --> 00:03:58.240 
thirty one bit instruction. So it's sort of not usable for addressing.

58
00:03:59.320 --> 00:04:01.510 
That is why it's called in fact a thirty one bit

59
00:04:01.940 --> 00:04:04.790 
architecture. And then later on

60
00:04:05.730 --> 00:04:07.560 
with the introduction of the set systems,

61
00:04:08.130 --> 00:04:11.550 
it has been further developed to a sixty four bit architecture

62
00:04:11.900 --> 00:04:15.680 
which it is today. And the most recent current

63
00:04:16.310 --> 00:04:20.410 
generation of the z processor is the version z14, that's the newest

64
00:04:20.590 --> 00:04:23.970 
newest one. So approximately every one and a half to two years

65
00:04:23.970 --> 00:04:25.960 
there's a new generation of a

66
00:04:26.790 --> 00:04:31.340 
new processor generation in average. So it's not always exactly but

67
00:04:32.950 --> 00:04:34.170 
it has evolved like that.

68
00:04:38.550 --> 00:04:42.940 
So still the architecture is backward compatible and even the

69
00:04:42.950 --> 00:04:46.950 
most modern z14 would execute a program written for

70
00:04:46.950 --> 00:04:50.330 
the original twenty four bit s360 architecture.

71
00:04:54.070 --> 00:04:59.140 
The CPU is a so called extreme CISC processor. So it has a very

72
00:04:59.140 --> 00:05:01.650 
large instruction set of machine instructions

73
00:05:03.290 --> 00:05:06.980 
and the current CPU now is the newest generation,

74
00:05:08.160 --> 00:05:14.190 
is a ten core CPU is called a processing unit every core

75
00:05:14.190 --> 00:05:16.750 
is called a processing unit and

76
00:05:18.090 --> 00:05:21.940 
on a CPU chip we have ten cores plus the caches

77
00:05:22.400 --> 00:05:26.120 
and these are put together on a single chip module.

78
00:05:27.080 --> 00:05:29.020 
These chip modules may look like this. This is

79
00:05:29.430 --> 00:05:34.150 
from a set thirteen but the ones are of course not very different regarding the

80
00:05:36.750 --> 00:05:42.930 
visuals. The current has a clock rate of 5.2 GHz,

81
00:05:43.170 --> 00:05:45.590 
so it's a very high clock rate and

82
00:05:46.310 --> 00:05:48.410 
the PUs of such a system

83
00:05:49.330 --> 00:05:53.850 
can be configured for different workloads. This configuration is done

84
00:05:53.990 --> 00:05:55.360 
in firmware, so it's not

85
00:05:57.150 --> 00:06:01.380 
that it's a different CPU or a different physical thing, but it's just done

86
00:06:01.560 --> 00:06:07.730 
by software. So the CPU can be configured to execute different kinds of workloads.

87
00:06:08.380 --> 00:06:12.500 
Some are so called CPs, general purpose processors that execute

88
00:06:12.500 --> 00:06:15.740 
everything they execute zox linux and all kind of programs.

89
00:06:16.050 --> 00:06:18.840 
But there are also special purpose

90
00:06:20.710 --> 00:06:23.630 
PUs, like for example IFL, the Integrated Facility for Linux,

91
00:06:25.750 --> 00:06:28.270 
is a PU that just runs linux and its applications.

92
00:06:28.820 --> 00:06:31.580 
Of course this is only sort of

93
00:06:32.290 --> 00:06:37.700 
prohibited by firmware because the physical CPU is the same but this allows

94
00:06:38.410 --> 00:06:42.100 
IBM to license this course with a different much

95
00:06:42.710 --> 00:06:45.700 
more cost effective price for example. So

96
00:06:46.150 --> 00:06:50.070 
it's basically an issue of licensing and pricing.

97
00:06:52.180 --> 00:06:55.950 
Also there's a kind of special purpose CPU for java based workloads,

98
00:06:56.120 --> 00:06:59.280 
like for example, the zIIP application server which is called zIIP.

99
00:06:59.940 --> 00:07:02.990 
So this is a PU that is only configured for

100
00:07:04.300 --> 00:07:08.840 
executing java and other more modern so called modern workloads

101
00:07:08.960 --> 00:07:13.490 
that are not classical six core programs for example. Nevertheless

102
00:07:13.510 --> 00:07:16.940 
it's physically the same processor type or the same architecture.

103
00:07:19.020 --> 00:07:23.720 
On the right hand side you see the set up of the registers off the

104
00:07:24.360 --> 00:07:25.630 
mainframe PU.

105
00:07:26.860 --> 00:07:29.550 
Of course everybody has an arithmetic and logic unit

106
00:07:30.380 --> 00:07:33.190 
ALU and a control unit which is more or less

107
00:07:33.830 --> 00:07:39.710 
the case for every processor and then it has a set of registers that

108
00:07:41.070 --> 00:07:45.120 
are typical for the mainframe CPU there is the so called program

109
00:07:45.120 --> 00:07:49.930 
status word PSW, which is containing the full state of the currently

110
00:07:49.930 --> 00:07:54.380 
executed program. So it has two parts. The flag part and the address part.

111
00:07:54.540 --> 00:07:57.070 
So the address part contains the program counter. The actual

112
00:07:57.260 --> 00:08:01.310 
address that is executed and the next address that needs to be executed and

113
00:08:02.060 --> 00:08:06.100 
the flags contain status like for example overflow, division by

114
00:08:06.180 --> 00:08:07.210 
zero and things like that.

115
00:08:08.520 --> 00:08:11.450 
Then we have sixteen general purpose registers

116
00:08:11.980 --> 00:08:15.160 
and also sixteen floating-point registers and the width of

117
00:08:15.160 --> 00:08:17.410 
the registers is different in this picture.

118
00:08:20.190 --> 00:08:23.920 
A single yellow block indicates always the width of the architecture.

119
00:08:23.920 --> 00:08:24.780 
So for example on a

120
00:08:27.040 --> 00:08:31.090 
thirty one bit or thirty two bit architecture, the PSW would be

121
00:08:31.290 --> 00:08:34.300 
sixty four bits together, address and flex and

122
00:08:34.930 --> 00:08:37.810 
general purpose would be thirty one bits and

123
00:08:40.260 --> 00:08:43.680 
in this example, for example, the floating-point registers have doubled the

124
00:08:44.390 --> 00:08:45.420 
machine size.

125
00:08:47.660 --> 00:08:50.700 
On the right lower corner you'll see the access registers. There are sixteen

126
00:08:50.700 --> 00:08:53.360 
access registers and these are used for or

127
00:08:54.270 --> 00:08:57.640 
they were introduced for the ESA architecture which is

128
00:08:58.530 --> 00:09:01.690 
an extension of the original XA architecture

129
00:09:02.180 --> 00:09:07.060 
with thirty one bit to increase the size of available virtual

130
00:09:07.060 --> 00:09:11.510 
memory for an application without increasing the address size.

131
00:09:13.110 --> 00:09:17.660 
Additional data only address spaces have been introduced and

132
00:09:17.660 --> 00:09:21.790 
for each of these virtual data only address spaces, you need base register

133
00:09:24.480 --> 00:09:27.730 
for addressing and these other access registers roughly.

134
00:09:29.050 --> 00:09:33.130 
Oky so this is the basic structure of the CPU and

135
00:09:35.890 --> 00:09:38.960 
it's important to know that this type of processor is an extreme

136
00:09:38.960 --> 00:09:41.130 
complex instruction set computer and

137
00:09:41.960 --> 00:09:45.990 
this means that it has complex instructions for, for example,

138
00:09:45.990 --> 00:09:49.680 
load and store operations for different kinds of conditional branching,

139
00:09:50.510 --> 00:09:54.020 
for encryption, for string manipulation. So

140
00:09:54.740 --> 00:09:57.650 
machine instruction set nearly like a complete

141
00:09:58.130 --> 00:10:02.210 
library routine and on another platform okay. So string manipulation

142
00:10:02.210 --> 00:10:04.370 
counting characters and things like that. So

143
00:10:04.910 --> 00:10:08.990 
these are very complex instructions. Many of them are not actually

144
00:10:09.440 --> 00:10:13.070 
directly implemented in microcode but they are partially implemented

145
00:10:13.070 --> 00:10:17.290 
in something called minicode which is again calling them microcode instructions.

146
00:10:17.540 --> 00:10:21.140 
So it's a multi-layer hierarchy of instructions

147
00:10:22.630 --> 00:10:25.260 
and many of these instructions are actually implemented in

148
00:10:25.260 --> 00:10:29.240 
the CPU in software. But from a developer point of view of course they are

149
00:10:29.910 --> 00:10:32.530 
machine instructions. And,

150
00:10:35.350 --> 00:10:37.820 
of course we have different instructions for switching

151
00:10:38.490 --> 00:10:42.100 
or for different address sizes; twenty four versus thirty one or sixty four bit.

152
00:10:42.360 --> 00:10:46.940 
This originates from the history and evolution,

153
00:10:47.530 --> 00:10:49.410 
so many of these instructions are just

154
00:10:50.140 --> 00:10:54.150 
twice. Or many similar instructions are available for twenty four and

155
00:10:54.320 --> 00:10:56.240 
thirty two bit

156
00:10:56.880 --> 00:11:01.150 
and of course this increases the size of the number of instructions.

157
00:11:03.410 --> 00:11:05.790 
A very unique feature of the mainframe CPU is the

158
00:11:06.480 --> 00:11:11.450 
existence of hardware machine instructions for processing calculating

159
00:11:11.650 --> 00:11:14.590 
numbers and the so called binary coded decimal scheme

160
00:11:15.030 --> 00:11:18.940 
which is very important for commercial calculations, which is one of the

161
00:11:19.130 --> 00:11:22.900 
core domains of the mainframes I used and

162
00:11:24.410 --> 00:11:28.220 
this allows to make decimal calculations with a defined precision.

163
00:11:29.340 --> 00:11:32.640 
Usually digits are represented by four bits or eight bits

164
00:11:33.120 --> 00:11:35.500 
in sort of kind of a digit string

165
00:11:36.230 --> 00:11:41.310 
and in the packed format you have four bits per digit. So two digits per byte

166
00:11:41.580 --> 00:11:46.360 
and with these packed decimal instructions the system can calculate directly by

167
00:11:46.590 --> 00:11:50.330 
machine instruction. So there are for example machine instructions for BCD

168
00:11:50.670 --> 00:11:53.890 
addition, BCD division and so on. And

169
00:11:55.160 --> 00:11:59.520 
since z13 there have been further instructions added for example for

170
00:12:00.850 --> 00:12:04.880 
single instruction multiple data instructions for fast string

171
00:12:04.880 --> 00:12:08.690 
processing which is important for example speeding up

172
00:12:09.680 --> 00:12:13.250 
string manipulation for non structured data and things like

173
00:12:13.250 --> 00:12:16.270 
that that might be used for example for improving java performance.

174
00:12:18.310 --> 00:12:21.050 
So it's very common that for the mainframe architecture for

175
00:12:21.050 --> 00:12:24.110 
every generation of the CPU instructions have been added to

176
00:12:24.110 --> 00:12:27.280 
address specific needs and specific problems of that

177
00:12:28.020 --> 00:12:29.670 
era or that period of time.

178
00:12:30.730 --> 00:12:34.500 
In general of course we have virtual memory management which is an important

179
00:12:35.150 --> 00:12:36.820 
functionality of the CPU

180
00:12:37.490 --> 00:12:40.980 
and this is done by multiple

181
00:12:41.740 --> 00:12:45.730 
steps in direction. You can see it here. This is by example the

182
00:12:45.740 --> 00:12:48.440 
original structure from the S360. So it's

183
00:12:48.440 --> 00:12:50.270 
a twenty four bit structure.

184
00:12:51.030 --> 00:12:54.220 
Every address every virtual address is interpreted in three

185
00:12:54.220 --> 00:12:57.020 
parts - a segment, a page and a displacement

186
00:12:57.630 --> 00:13:03.110 
and the segment points to a number in a segment table which again is

187
00:13:04.120 --> 00:13:07.960 
indexed by the so called segment table origin register that in the CPU and

188
00:13:09.130 --> 00:13:14.690 
inside that table there's another address that points to the so called

189
00:13:16.860 --> 00:13:18.210 
frame number, which then

190
00:13:20.780 --> 00:13:24.290 
no - it points to the page table and then points to the frame number and then

191
00:13:25.050 --> 00:13:29.200 
the displacement is indexing it in a memory page.

192
00:13:30.830 --> 00:13:34.030 
So this is the way how a virtual address is translated to a

193
00:13:34.030 --> 00:13:36.250 
physical address somewhere in memory.

194
00:13:38.560 --> 00:13:40.450 
And that was the way how it was done in the original

195
00:13:41.020 --> 00:13:44.730 
architecture but part of this idea is still present. For example

196
00:13:44.730 --> 00:13:49.490 
the twelve bit displacement is still in use, even with larger addresses.

197
00:13:49.680 --> 00:13:52.830 
So every memory block has

198
00:13:53.780 --> 00:13:54.530 
four kilobytes.

199
00:13:58.630 --> 00:14:01.730 
This leads to a certain layout of the virtual address space

200
00:14:01.730 --> 00:14:05.250 
and is shown here. So in the original S360 architecture,

201
00:14:06.070 --> 00:14:09.550 
every virtual address space was a maximum sixteen megabyte. The

202
00:14:10.360 --> 00:14:15.690 
nucleus the kernel code was residing at the lower edge, starting from zero address.

203
00:14:15.830 --> 00:14:18.350 
Then there was a region of the virtual address space. The region

204
00:14:18.350 --> 00:14:22.290 
is actually the memory that's available to the program, the

205
00:14:22.290 --> 00:14:25.330 
heap and the stack and so on. And then you have some

206
00:14:25.870 --> 00:14:29.820 
address spaces that are reserved for mapping in shared libraries

207
00:14:29.860 --> 00:14:31.140 
and these are other

208
00:14:35.140 --> 00:14:38.640 
address information that is sort of common for multiple address

209
00:14:38.640 --> 00:14:41.080 
spaces, like for example the system queue area

210
00:14:41.720 --> 00:14:43.650 
where some global control blocks for all parallel

211
00:14:44.110 --> 00:14:46.460 
programs, for all other spaces are maintained.

212
00:14:47.250 --> 00:14:49.850 
The page of link area for libraries and

213
00:14:51.120 --> 00:14:53.790 
the common service area for example

214
00:14:54.480 --> 00:14:57.440 
implementing inter-process communication between address spaces.

215
00:14:57.460 --> 00:14:58.740 
And then of course we have

216
00:14:59.950 --> 00:15:03.140 
the so called local system queue area which is

217
00:15:04.790 --> 00:15:09.760 
present in every virtual address space separately and contains the program specific

218
00:15:10.240 --> 00:15:14.120 
control structures that are needed to communicate for example with the kernel,

219
00:15:14.650 --> 00:15:18.100 
especially device control blocks, task control blocks, so control

220
00:15:18.100 --> 00:15:21.720 
structures that are needed to for example control I/O operations.

221
00:15:24.280 --> 00:15:25.070 
In modern architecture, they have

222
00:15:27.450 --> 00:15:28.590 
evolved a little bit

223
00:15:29.310 --> 00:15:33.780 
due to the larger address size and to keep the system backward compatible.

224
00:15:34.160 --> 00:15:36.160 
Everything was sort of doubled in the address

225
00:15:37.160 --> 00:15:41.940 
address space and the nucleus was pushed around the sixteen megabyte

226
00:15:42.680 --> 00:15:45.560 
border. So we have an extended nucleus for the

227
00:15:46.460 --> 00:15:49.910 
thirty one and sixty four bit applications and the nucleus code for the

228
00:15:50.050 --> 00:15:52.350 
twenty four bit applications and

229
00:15:52.990 --> 00:15:57.780 
we have also basically two regions for depending on the type of addressing.

230
00:15:58.980 --> 00:16:01.350 
Of course it can happen that you have a program that links

231
00:16:01.620 --> 00:16:04.260 
a thirty one bit or sixty four bit program that links a twenty

232
00:16:04.260 --> 00:16:08.640 
four bit library, so you could have also in one process the switching between these

233
00:16:08.940 --> 00:16:12.860 
and this means that both needs to be present in parallel.

234
00:16:15.410 --> 00:16:20.520 
Okay so this was a short introduction on how the CPU is built

235
00:16:20.520 --> 00:16:24.220 
up, how the address size increased over time, what

236
00:16:25.570 --> 00:16:28.950 
or which kind of consequences this had for

237
00:16:29.560 --> 00:16:32.170 
virtual address management and

238
00:16:33.120 --> 00:16:36.880 
which registers are there and what is typical for the machine instruction set of that

239
00:16:37.320 --> 00:16:41.150 
type of CPU over the mainframe CPU architecture.

240
00:16:41.850 --> 00:16:42.640 
Thank you very much.
