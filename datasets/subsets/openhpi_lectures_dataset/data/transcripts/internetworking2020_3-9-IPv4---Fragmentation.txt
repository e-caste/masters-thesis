WEBVTT

1
00:00:00.000 --> 00:00:04.000 
In our course half-century
of internet,

2
00:00:04.640 --> 00:00:09.970 
we now want to discuss the
fragmentation of IP diagrams.

3
00:00:10.740 --> 00:00:16.170 
The task of fragmentation
is an important task

4
00:00:16.180 --> 00:00:21.770 
of the internet protocol and
it is important to be able

5
00:00:22.120 --> 00:00:25.730 
to handle the correct
forwarding of data packets.

6
00:00:26.920 --> 00:00:31.400 
We already saw that the
maximum size of packets

7
00:00:31.900 --> 00:00:35.760 
that is allowed in the different
network technologies differ,

8
00:00:36.310 --> 00:00:44.240 
so there is an MTU (maximum transfer
unit) which tells in each technology

9
00:00:44.390 --> 00:00:48.630 
what is the maximum length
of a data package.

10
00:00:49.160 --> 00:00:54.410 
And now if a router gets a data
package and has to forward

11
00:00:54.410 --> 00:00:59.970 
this package to another router over
a network with a smaller MTU,

12
00:01:00.120 --> 00:01:07.540 
then the length of the package has to
be fragmented into different parts.

13
00:01:08.320 --> 00:01:13.570 
During the fragmentation, of course, a
header is needed for each of the fragments

14
00:01:13.960 --> 00:01:20.120 
and this header needs extra
information about the fragmentation,

15
00:01:20.680 --> 00:01:27.380 
which helps the receiver
to fragment the

16
00:01:27.380 --> 00:01:28.090 


17
00:01:28.100 --> 00:01:30.410 
data package

18
00:01:30.840 --> 00:01:37.560 
in the right resources also when
we spoke about the datagrams.

19
00:01:38.590 --> 00:01:42.520 
Now let's have a look at the
fragmentation process,

20
00:01:42.940 --> 00:01:46.960 
and there exist two different
approaches. One approach is so-called

21
00:01:47.550 --> 00:01:49.430 
transparent
fragmentation

22
00:01:50.400 --> 00:01:54.060 
and assume here every
time there is router,

23
00:01:54.670 --> 00:01:57.610 
router which
has to decide

24
00:01:58.640 --> 00:02:02.030 
in which direction the data
package has to be forwarded

25
00:02:02.710 --> 00:02:08.460 
and when they receive this data
package and they find out, they have

26
00:02:08.590 --> 00:02:13.370 
to forward this a data
package via the network 1.

27
00:02:13.780 --> 00:02:19.520 
And the MTU of the network
is smaller then the size

28
00:02:19.520 --> 00:02:23.370 
of the data package, since the
router has to take that the

29
00:02:23.930 --> 00:02:29.340 
package is fragmented in
smaller packets of a length,

30
00:02:29.340 --> 00:02:30.710 
smaller than the MTU.

31
00:02:31.630 --> 00:02:37.610 
And these packages are trans
admitted through this network 1,

32
00:02:38.050 --> 00:02:44.930 
they do this in a different way, and
then they receive on router 2.

33
00:02:47.380 --> 00:02:51.560 
Transparent fragmentation
means that now the router

34
00:02:52.530 --> 00:02:57.950 
reassembles the fragments and then
to the original data package,

35
00:02:58.260 --> 00:03:01.010 
and then the router
checks what is the next

36
00:03:01.440 --> 00:03:07.120 
step, what is the next-hop via which the
network has to transmit the packet

37
00:03:07.470 --> 00:03:13.490 
in the next step. So this is packet 2,
and packet 2 has also the situation

38
00:03:13.650 --> 00:03:18.630 
that the MTU is smaller than the
packet size but it's larger

39
00:03:18.630 --> 00:03:22.420 
than the network 1. So here to
transfer this data package

40
00:03:22.420 --> 00:03:27.700 
via the network 2, it's enough
to have five fragmented

41
00:03:27.710 --> 00:03:32.590 
into 5 fragments. This is done
and then the five fragments

42
00:03:32.590 --> 00:03:38.330 
are sent and then the router 4
reassembles the original datagram

43
00:03:38.340 --> 00:03:42.050 
and makes the
next decisions.

44
00:03:43.440 --> 00:03:48.520 
Beside of this transparent
fragmentation, there is a so-called In

45
00:03:48.690 --> 00:03:50.820 
-transparent
fragmentation.

46
00:03:51.670 --> 00:03:56.840 
Intransparent fragmentation works
as follows, there is our datagram

47
00:03:57.300 --> 00:04:04.630 
reaching a router. The router
sees that the next hop of this

48
00:04:04.640 --> 00:04:09.360 
packet has to go through
network 1, but network 1 has

49
00:04:09.360 --> 00:04:13.170 
a smaller MTU than the
size of a data package.

50
00:04:13.680 --> 00:04:19.310 
Then the router fragments this, here
in our example into 6 fragments.

51
00:04:19.310 --> 00:04:23.630 
Fragments are transferred
through the network 1

52
00:04:23.660 --> 00:04:26.940 
and receive on the other
side a new router.

53
00:04:27.900 --> 00:04:32.690 
But now, different from the
transparent fragmentation

54
00:04:33.160 --> 00:04:38.210 
the router is not
reassembling the fragments

55
00:04:38.670 --> 00:04:45.900 
to reach the original datagram, no, the
router considers the different fragments

56
00:04:46.130 --> 00:04:52.500 
separately and sees, okay
all have to send through

57
00:04:52.750 --> 00:04:57.330 
to the next network

58
00:04:57.990 --> 00:05:04.530 
or another network and it works
fine as long as the data

59
00:05:04.530 --> 00:05:10.000 
packets are smaller than the empty
use of at transfer networks

60
00:05:10.000 --> 00:05:15.890 
but then they reach a new router.
A new router which determines

61
00:05:15.900 --> 00:05:19.450 
these packets have to be
sent through network 2.

62
00:05:19.930 --> 00:05:25.260 
And then the next step in
fragmentation is done when the data

63
00:05:25.260 --> 00:05:29.080 
packet yields a fragmented data
packets are too large to be

64
00:05:29.080 --> 00:05:34.760 
transported on network 2. And then we
get smaller and smaller datagrams

65
00:05:34.950 --> 00:05:39.810 
of course much more likely that they can
be transported without fragmentation

66
00:05:40.400 --> 00:05:48.060 
so the idea here is
to improve speed by

67
00:05:48.680 --> 00:05:56.030 
not a reassembling, but continue
to a to transmit the fragments

68
00:05:56.220 --> 00:06:00.550 
up to the moment they reach the
receiver and then the receiver

69
00:06:00.720 --> 00:06:04.230 
is doing one time
such a resampling.

70
00:06:06.670 --> 00:06:12.980 
They are a number of problems particularly
with the transparent fragmentation

71
00:06:13.270 --> 00:06:19.190 
but one problem is regardless whether it's
transparent or inside fragmentation

72
00:06:19.520 --> 00:06:24.760 
is that the recipient has to
resemble the individual datagrams

73
00:06:24.860 --> 00:06:26.110 
in the correct order

74
00:06:26.820 --> 00:06:32.660 
Otherwise, he cannot get a the sense of
the message which was sent to him,

75
00:06:33.660 --> 00:06:38.880 
the datagrams you remember after being
separated to different fragments,

76
00:06:39.130 --> 00:06:44.730 
they move independently and are transported
independently through the internet.

77
00:06:45.540 --> 00:06:49.590 
So it's very likely
that a later fragment

78
00:06:50.100 --> 00:06:54.750 
reach the receiver earlier,
than an earlier fragment.

79
00:06:55.660 --> 00:07:00.660 
So this is one problem, the other
problem is on the different

80
00:07:00.660 --> 00:07:07.340 
ways to the internet the datagrams may
be fragmented in different ways.

81
00:07:07.700 --> 00:07:12.410 
So not all fragments
of one message are

82
00:07:12.410 --> 00:07:14.330 
fragmented in
the same way.

83
00:07:15.130 --> 00:07:19.700 
Another problem are transmission
errors, they may require the

84
00:07:19.700 --> 00:07:24.720 
retransmission of a fragment.
But when the fragment

85
00:07:24.760 --> 00:07:28.450 
goes, it's transported
through the internet

86
00:07:28.450 --> 00:07:34.590 
in a different way, it could at the
end be differently fragmented.

87
00:07:35.320 --> 00:07:41.710 
So that there are lots of
problems. So the question and

88
00:07:41.720 --> 00:07:46.080 
the IP protocol has to be prepared
to answer those questions.

89
00:07:46.310 --> 00:07:53.330 
So the problem is how IP can guarantee
a a correct defragmentation?

90
00:07:54.970 --> 00:07:59.780 
So this is done by a couple of
techniques, the important

91
00:08:00.160 --> 00:08:05.210 
core technique is the so-called
minimum fragment size.

92
00:08:05.650 --> 00:08:11.160 
And this is that fragments cannot
get smaller than the size,

93
00:08:11.600 --> 00:08:17.870 
and then one can by means of
such things and a lot of

94
00:08:18.150 --> 00:08:24.370 
tricks and calculations can get,
can reach and can manage answer

95
00:08:24.620 --> 00:08:25.830 
to these problems.

96
00:08:27.390 --> 00:08:31.870 
What is a header, what kind
of information is needed

97
00:08:32.210 --> 00:08:36.480 
to be sent with the header of such
fragments. I mentioned already

98
00:08:36.480 --> 00:08:43.130 
that there are fields in the IP header for
such additional digital information.

99
00:08:43.570 --> 00:08:49.070 
So of course, the packet ID needs to
be sent, so those at the receiver

100
00:08:49.320 --> 00:08:54.050 
can realize that this fragment
belongs to that package.

101
00:08:54.710 --> 00:09:00.500 
Then the ID of the first fragment in
the datagram needs to be transmitted

102
00:09:00.700 --> 00:09:06.650 
and a control bit indicating whether the
state diagram is the last fragment

103
00:09:07.010 --> 00:09:11.640 
senses control bit 1 or if they
are more fragments then the

104
00:09:11.640 --> 00:09:15.910 
control will be 0. Let's have
a look at a small example,

105
00:09:16.500 --> 00:09:20.300 
here we have our packet
ID, packet ID is 2A.

106
00:09:20.810 --> 00:09:26.530 
Here we have a fragment ID, of the
first fragment in the datagram 0

107
00:09:26.640 --> 00:09:32.650 
and where we have the control bit and1
says this is the last fragment.

108
00:09:33.050 --> 00:09:39.430 
So datagram, this is a minimum
fragment size is 1 byte, so datagram

109
00:09:39.590 --> 00:09:45.840 
is the payload. Now we
reach a situation where

110
00:09:45.840 --> 00:09:50.360 
this package cannot be transferred
through the next network, since

111
00:09:50.650 --> 00:09:56.510 
the length is longer
than the empty

112
00:09:58.450 --> 00:10:00.350 
package has to
be fragmented

113
00:10:01.010 --> 00:10:05.550 
because each of the fragment
needs an own header.

114
00:10:05.760 --> 00:10:11.040 
So we have to fragment this part
and then to assign a new header.

115
00:10:11.410 --> 00:10:17.210 
So we frequent in our example,
the datagram into data and

116
00:10:17.210 --> 00:10:23.530 
gram to contents. And then each of
the packages needs a new header

117
00:10:24.060 --> 00:10:27.520 
and sender and
receiver address.

118
00:10:27.520 --> 00:10:31.680 
But here I want to show
the first fragment,

119
00:10:32.100 --> 00:10:37.690 
it's in both cases the ID
of the original package.

120
00:10:38.200 --> 00:10:45.640 
And then we have the information
of the first datagram

121
00:10:45.950 --> 00:10:54.560 
it is zero and
then here we say

122
00:10:54.750 --> 00:10:58.610 
here it is the next

123
00:10:59.390 --> 00:11:06.030 
part of the payload
and this package is

124
00:11:06.600 --> 00:11:12.740 
0 control bit, not the final. They're
not a final fragment, but this is.

125
00:11:13.680 --> 00:11:18.390 
And then you can see how it's
continued, for example,

126
00:11:18.390 --> 00:11:22.630 
if it is too long to transport
it to the next network, it has

127
00:11:22.630 --> 00:11:28.960 
to be newly fragmented with
the new header information.

128
00:11:29.170 --> 00:11:32.420 
2A tells what the original
data package means, what

129
00:11:32.420 --> 00:11:37.770 
is the first a
part of the

130
00:11:37.770 --> 00:11:42.590 
fragment and here that was the
second part. So you see with this

131
00:11:42.590 --> 00:11:44.720 
type of extra
information,

132
00:11:45.370 --> 00:11:52.310 
the receiver is able to reconstruct
the fragments and to get

133
00:11:52.450 --> 00:11:56.860 
the original message with the
original content information.
