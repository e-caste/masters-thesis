WEBVTT

1
00:00:00.860 --> 00:00:03.319 
Welcome to our introduction to the Java programing

2
00:00:03.320 --> 00:00:06.319 
language. My name is Philip Brune from the

3
00:00:06.320 --> 00:00:08.269 
Neu-Ulm University of Applied Sciences.

4
00:00:10.370 --> 00:00:12.319 
If you look at the history of higher programing

5
00:00:12.320 --> 00:00:15.364 
languages, then we see that Java is

6
00:00:16.700 --> 00:00:18.049 
right at the bottom.

7
00:00:18.050 --> 00:00:21.349 
So it's a comparatively new programing language

8
00:00:21.350 --> 00:00:23.420 
originating from the 90s,

9
00:00:27.110 --> 00:00:30.289 
started during the expansion

10
00:00:30.290 --> 00:00:32.688 
of the World Wide Web and the World Wide Web became

11
00:00:32.689 --> 00:00:34.399 
popular. And

12
00:00:35.510 --> 00:00:37.867 
so it is sort of an antagonist to COBOL,

13
00:00:39.050 --> 00:00:41.659 
which is a very, very early programing language.

14
00:00:41.660 --> 00:00:44.540 
The Java is a rather modern language.

15
00:00:46.830 --> 00:00:50.339 
The main features of Java are the Java is

16
00:00:50.340 --> 00:00:53.429 
really a universal programing language compared

17
00:00:53.430 --> 00:00:56.699 
to others like PHP or scripting languages, for example,

18
00:00:56.700 --> 00:00:59.699 
which usually are for a special application

19
00:00:59.700 --> 00:01:01.649 
domain like web development.

20
00:01:01.650 --> 00:01:03.449 
Java is a general purpose language.

21
00:01:03.450 --> 00:01:05.879 
This means that it can be used for many different

22
00:01:05.880 --> 00:01:08.729 
purposes, can be used for mobile development,

23
00:01:08.730 --> 00:01:11.789 
for business applications, even

24
00:01:11.790 --> 00:01:14.729 
for embedded applications, partially

25
00:01:14.730 --> 00:01:17.219 
so. There are many application domains.

26
00:01:18.300 --> 00:01:21.119 
It is definitely most

27
00:01:21.120 --> 00:01:24.389 
important for the development of large scale

28
00:01:24.390 --> 00:01:27.559 
mission critical business applications.

29
00:01:27.560 --> 00:01:30.589 
In the context also of the Java Enterprise edition on

30
00:01:30.590 --> 00:01:33.409 
our Jakarta Enterprise Edition, and in

31
00:01:33.410 --> 00:01:36.709 
this sense it is sort of a successor

32
00:01:36.710 --> 00:01:39.559 
to COBOL, it increasingly takes over the role

33
00:01:39.560 --> 00:01:42.409 
of COBOL as the leading language for

34
00:01:42.410 --> 00:01:44.809 
business application development.

35
00:01:44.810 --> 00:01:47.689 
And there's already a large installed base of

36
00:01:48.710 --> 00:01:51.319 
business applications written in Java.

37
00:01:53.370 --> 00:01:56.849 
The syntax of Java is very close to C and C++,

38
00:01:56.850 --> 00:01:59.669 
which are sort of its ancestors and

39
00:01:59.670 --> 00:02:02.609 
of course to other C like languages like PHP, for

40
00:02:02.610 --> 00:02:05.519 
example, and

41
00:02:05.520 --> 00:02:08.429 
compared to C++, Java tries to avoid most

42
00:02:08.430 --> 00:02:10.809 
of the weaknesses.

43
00:02:10.810 --> 00:02:13.270 
The large grammar and

44
00:02:14.340 --> 00:02:17.489 
very complex syntax

45
00:02:17.490 --> 00:02:20.609 
is much simplified, and its

46
00:02:20.610 --> 00:02:23.489 
object orientation is implemented much more

47
00:02:23.490 --> 00:02:26.459 
consequential than in C++ or in PHP.

48
00:02:26.460 --> 00:02:30.089 
In particular, this means that you cannot purely

49
00:02:30.090 --> 00:02:33.119 
program an imperative or procedural programing

50
00:02:33.120 --> 00:02:35.429 
style in Java.

51
00:02:35.430 --> 00:02:38.459 
So everything in Java has to reside inside

52
00:02:38.460 --> 00:02:39.460 
a class.

53
00:02:41.010 --> 00:02:43.859 
The focus of Java is stronger also

54
00:02:43.860 --> 00:02:47.159 
on security, safety and reliability,

55
00:02:47.160 --> 00:02:50.249 
and this is achieved by some of its features.

56
00:02:50.250 --> 00:02:53.249 
For example, Java is statically

57
00:02:53.250 --> 00:02:56.399 
typed, it has statically typed variables and

58
00:02:56.400 --> 00:02:59.579 
these statically typed variables when they are

59
00:02:59.580 --> 00:03:02.729 
assigned, there is a rather strict type checking

60
00:03:02.730 --> 00:03:05.669 
that sometimes confuses beginners because

61
00:03:05.670 --> 00:03:08.609 
it really enforces to think about data

62
00:03:08.610 --> 00:03:09.610 
types.

63
00:03:10.710 --> 00:03:13.199 
It offers an automatic memory management, a garbage

64
00:03:13.200 --> 00:03:16.439 
collection, and memory is allocated automatically and

65
00:03:16.440 --> 00:03:17.819 
also released automatically.

66
00:03:17.820 --> 00:03:20.039 
And there is no real

67
00:03:22.080 --> 00:03:25.049 
mechanism like pointer arithmetics as we know

68
00:03:25.050 --> 00:03:27.869 
them from C and C++ to avoid memory

69
00:03:27.870 --> 00:03:30.809 
leaks. So it's not really possible

70
00:03:30.810 --> 00:03:34.019 
to create memory leaks easily

71
00:03:34.020 --> 00:03:35.020 
in Java.

72
00:03:36.120 --> 00:03:37.770 
Java supports multi threading and

73
00:03:40.970 --> 00:03:44.009 
thread synchronization mechanisms as part

74
00:03:44.010 --> 00:03:46.679 
of as an integral part of the syntax of the language.

75
00:03:46.680 --> 00:03:49.589 
So programing parallel structures

76
00:03:49.590 --> 00:03:52.529 
is also rather easy, and

77
00:03:52.530 --> 00:03:55.679 
one of its most important features is Java

78
00:03:55.680 --> 00:03:58.499 
is executed in a sandbox, which is the Java

79
00:03:58.500 --> 00:04:01.409 
virtual machine, which is isolated from the underlying

80
00:04:01.410 --> 00:04:02.819 
hardware. And

81
00:04:04.320 --> 00:04:07.259 
so Java is compiled first

82
00:04:07.260 --> 00:04:10.379 
in an intermediate bytecode, the intermediate

83
00:04:10.380 --> 00:04:13.319 
language that then is portable

84
00:04:13.320 --> 00:04:16.289 
and executed in the target system at runtime on

85
00:04:16.290 --> 00:04:17.290 
the JVM.

86
00:04:20.040 --> 00:04:22.889 
To understand what Java can do for

87
00:04:22.890 --> 00:04:25.049 
you or what is a difference also to COBOL, it is

88
00:04:25.050 --> 00:04:27.989 
important to know a little bit about object

89
00:04:27.990 --> 00:04:31.019 
orientation. Java is strongly object

90
00:04:31.020 --> 00:04:33.929 
oriented language, even though there are some elementary

91
00:04:33.930 --> 00:04:35.129 
data types.

92
00:04:35.130 --> 00:04:38.279 
And in an object oriented language, the

93
00:04:38.280 --> 00:04:41.249 
basic concept is that all structures,

94
00:04:41.250 --> 00:04:44.429 
all things that you deal with are basically

95
00:04:44.430 --> 00:04:46.199 
objects. An object is

96
00:04:48.990 --> 00:04:52.139 
an abstraction of either a real world object

97
00:04:52.140 --> 00:04:55.979 
like a customer or a machine or something,

98
00:04:55.980 --> 00:04:58.319 
or an abstract concept of reality.

99
00:04:58.320 --> 00:05:01.379 
And it tries to mimic the structures

100
00:05:01.380 --> 00:05:04.259 
of the real world in the programing code as

101
00:05:04.260 --> 00:05:07.289 
well. So in object oriented programing, every

102
00:05:07.290 --> 00:05:09.689 
object belongs to a class and

103
00:05:11.070 --> 00:05:14.399 
every class can be instantiated for

104
00:05:14.400 --> 00:05:16.409 
an arbitrary number of objects.

105
00:05:16.410 --> 00:05:19.289 
So an object is sort of an instance of a class

106
00:05:19.290 --> 00:05:22.139 
and the classes can be understood as a blueprint

107
00:05:22.140 --> 00:05:25.229 
that describes how the objects of this class look like.

108
00:05:25.230 --> 00:05:28.619 
A class describes a set of objects

109
00:05:28.620 --> 00:05:31.739 
and models the concept

110
00:05:31.740 --> 00:05:34.709 
of, for example, the real world or an

111
00:05:34.710 --> 00:05:36.300 
abstract concept.

112
00:05:38.130 --> 00:05:41.219 
In Java, as in other object oriented programing

113
00:05:41.220 --> 00:05:44.111 
languages, the developer actually writes

114
00:05:44.112 --> 00:05:47.239 
classes and then instantiate

115
00:05:47.240 --> 00:05:50.119 
classes creates objects of these classes and

116
00:05:50.120 --> 00:05:51.410 
uses these objects.

117
00:05:52.770 --> 00:05:56.519 
So a class describes a set of similar objects,

118
00:05:56.520 --> 00:05:59.369 
a class in that sense is a blueprint or a mould

119
00:05:59.370 --> 00:06:02.699 
or a template for objects that are created,

120
00:06:02.700 --> 00:06:05.039 
and these objects are created according to the

121
00:06:05.040 --> 00:06:06.379 
definition of the class.

122
00:06:07.500 --> 00:06:11.069 
The class describes the properties or the attributes

123
00:06:11.070 --> 00:06:14.309 
of the objects, basically the values, the data,

124
00:06:14.310 --> 00:06:17.579 
the object contain and the operations

125
00:06:17.580 --> 00:06:20.459 
that you can do or the user, the client

126
00:06:20.460 --> 00:06:22.439 
program can do with the object.

127
00:06:22.440 --> 00:06:25.379 
An object encapsulates, therefore, data

128
00:06:25.380 --> 00:06:28.259 
and program logic in a unit that can

129
00:06:28.260 --> 00:06:30.179 
be used from the outside.

130
00:06:30.180 --> 00:06:32.699 
And the operations, the implementation of the operations

131
00:06:32.700 --> 00:06:35.699 
that an object offers are called methods

132
00:06:35.700 --> 00:06:36.700 
in object orientation.

133
00:06:38.010 --> 00:06:41.369 
Objects are instances of that class and an object

134
00:06:41.370 --> 00:06:43.979 
may have different values for the attributes.

135
00:06:43.980 --> 00:06:46.559 
Every object can have different values and the values of

136
00:06:46.560 --> 00:06:49.379 
the attributes can also change during execution, during

137
00:06:49.380 --> 00:06:52.379 
runtime, and

138
00:06:52.380 --> 00:06:55.259 
the sum of all attributes of an object

139
00:06:55.260 --> 00:06:56.669 
or the values of the attributes

140
00:06:58.440 --> 00:07:00.959 
describes its state so the state can change.

141
00:07:04.670 --> 00:07:07.069 
The operations are then always invoked on the individual

142
00:07:07.070 --> 00:07:08.389 
objects on the class itself.

143
00:07:08.390 --> 00:07:11.389 
The class defines or the class describes the methods, so

144
00:07:11.390 --> 00:07:13.550 
the class defines what method does, but

145
00:07:14.630 --> 00:07:17.899 
actually executed them

146
00:07:17.900 --> 00:07:20.899 
on the objects instances

147
00:07:20.900 --> 00:07:21.900 
of this class.

148
00:07:24.800 --> 00:07:27.889 
So object oriented programing basically means writing

149
00:07:27.890 --> 00:07:30.349 
classes, the developer has to write the classes to

150
00:07:30.350 --> 00:07:32.779 
specify the attributes and the methods as you can see it

151
00:07:32.780 --> 00:07:35.779 
here. So the attributes you can see an attribute

152
00:07:35.780 --> 00:07:38.599 
here, for example, is in

153
00:07:38.600 --> 00:07:41.419 
that case, this simple class in Java models,

154
00:07:41.420 --> 00:07:44.239 
a CellPhone. And every CellPhone, of course, has

155
00:07:44.240 --> 00:07:46.639 
a stage. For example, the number that the user entered

156
00:07:46.640 --> 00:07:49.789 
can change during time, over time.

157
00:07:49.790 --> 00:07:51.769 
In this case, it's called enterednumber.

158
00:07:51.770 --> 00:07:53.089 
We store it as a string.

159
00:07:53.090 --> 00:07:55.969 
So you can imagine enterednumber is a kind

160
00:07:55.970 --> 00:07:58.159 
of variable. But in that sense, it's an attribute

161
00:07:58.160 --> 00:08:01.729 
variable. So it describes a property

162
00:08:01.730 --> 00:08:04.639 
of the class CellPhone and the class CellPhone describes

163
00:08:04.640 --> 00:08:06.979 
the set of possible cell phones.

164
00:08:06.980 --> 00:08:10.159 
And to use that, we would then create instances of this

165
00:08:10.160 --> 00:08:11.599 
nice little CellPhone.

166
00:08:11.600 --> 00:08:13.579 
Of course, you can do something with your cell phone, a

167
00:08:13.580 --> 00:08:15.619 
cell phone is like a little machine that you can

168
00:08:15.620 --> 00:08:18.469 
interact with and to describe this, of course,

169
00:08:18.470 --> 00:08:21.529 
we have methods here, OK?

170
00:08:21.530 --> 00:08:24.619 
And the simple method, for example, would then be called

171
00:08:24.620 --> 00:08:26.899 
dial and it would dial the enterednumber.

172
00:08:26.900 --> 00:08:30.079 
So the method depends on the

173
00:08:30.080 --> 00:08:32.599 
in that sense and the value that that has been entered,

174
00:08:32.600 --> 00:08:34.548 
for example, in the enterednumber before.

175
00:08:34.549 --> 00:08:37.158 
Of course, this is not complete. It's just an excerpt

176
00:08:37.159 --> 00:08:40.129 
from that possible class, but it describes

177
00:08:40.130 --> 00:08:43.189 
the syntax. So in Java, every class starts

178
00:08:43.190 --> 00:08:45.709 
with the word class and then there's the name and that

179
00:08:45.710 --> 00:08:47.089 
sends the CellPhone.

180
00:08:47.090 --> 00:08:49.069 
Class names are written with a capital letter by

181
00:08:49.070 --> 00:08:52.519 
convention, variables and methods are written with a

182
00:08:52.520 --> 00:08:53.990 
small letter by convention.

183
00:08:56.220 --> 00:08:58.412 
So this is the class CellPhone.java

184
00:09:00.000 --> 00:09:02.879 
and in Java, it is necessary

185
00:09:02.880 --> 00:09:05.699 
that every class resides in a separate source code file

186
00:09:05.700 --> 00:09:08.519 
and the source code file has the extension, ".java", as

187
00:09:08.520 --> 00:09:11.879 
you can see here. So this class would reside in the

188
00:09:11.880 --> 00:09:15.329 
CellPhone.java file, and

189
00:09:15.330 --> 00:09:18.359 
after compilation, this then turns into

190
00:09:18.360 --> 00:09:20.639 
the corresponding class file.

191
00:09:20.640 --> 00:09:23.969 
So, CellPhone.class and CellPhone.java

192
00:09:23.970 --> 00:09:25.506 
or all the classes in the

193
00:09:26.870 --> 00:09:29.309 
source files always have a one to one correspondence.

194
00:09:30.480 --> 00:09:32.969 
Of course, there are some classes that could be part of

195
00:09:32.970 --> 00:09:36.089 
other classes, but that's a special we will not discuss

196
00:09:36.090 --> 00:09:37.090 
that now.

197
00:09:38.160 --> 00:09:41.069 
Here's a bit bigger example, a more complete

198
00:09:41.070 --> 00:09:43.109 
and it describes a currency conversion.

199
00:09:43.110 --> 00:09:46.139 
So let's think of a possible set of currency conversions

200
00:09:46.140 --> 00:09:48.809 
so that, now, it's an abstract concept, not a cell phone

201
00:09:48.810 --> 00:09:52.439 
anymore. The CurrencyConverter is a class

202
00:09:52.440 --> 00:09:55.559 
that has objects that allow to convert

203
00:09:55.560 --> 00:09:58.949 
the amount of money from one currency to another one.

204
00:09:58.950 --> 00:10:01.799 
And in this case, this works only for Swiss Francs

205
00:10:01.800 --> 00:10:04.739 
and Euros. So we could easily extend it to

206
00:10:04.740 --> 00:10:07.259 
other currencies.

207
00:10:08.280 --> 00:10:11.459 
So it has one attribute, which is the exchange

208
00:10:11.460 --> 00:10:14.309 
rate from Euro to Swiss Francs,

209
00:10:14.310 --> 00:10:17.340 
and it has in that sense

210
00:10:19.710 --> 00:10:22.799 
one method to convert Swiss Francs

211
00:10:22.800 --> 00:10:24.900 
to Euro. And it takes,

212
00:10:26.760 --> 00:10:29.579 
this method is general, it could take an argument that

213
00:10:29.580 --> 00:10:31.889 
says, "OK, from which currency I want to convert it to

214
00:10:31.890 --> 00:10:35.129 
Euro" and then it checks, here you see an if statement,

215
00:10:35.130 --> 00:10:38.159 
a conditional statement, if the currency

216
00:10:38.160 --> 00:10:41.819 
is equal to Swiss Francs, ISO

217
00:10:41.820 --> 00:10:43.919 
code then use the Swiss Francs rate.

218
00:10:43.920 --> 00:10:46.829 
Otherwise, just return the original value

219
00:10:46.830 --> 00:10:49.779 
because the converter does not know the rate.

220
00:10:49.780 --> 00:10:52.139 
And now you could extend this with multiple, for

221
00:10:52.140 --> 00:10:55.559 
example, conditional statements to create

222
00:10:55.560 --> 00:10:57.480 
a more useful converter.

223
00:10:58.650 --> 00:11:01.709 
And of course, here you have a method that allow

224
00:11:01.710 --> 00:11:04.769 
us to change the value of the rate.

225
00:11:04.770 --> 00:11:07.799 
And in object orientation, we focus strongly

226
00:11:07.800 --> 00:11:10.919 
on encapsulation. And that means that you cannot or

227
00:11:10.920 --> 00:11:13.769 
you should not directly access the properties,

228
00:11:13.770 --> 00:11:16.589 
the attributes of a class, but use dedicated methods

229
00:11:16.590 --> 00:11:17.590 
for it.

230
00:11:19.150 --> 00:11:21.999 
OK, so this was a short glimpse on Java and

231
00:11:22.000 --> 00:11:25.239 
its syntax, and now

232
00:11:25.240 --> 00:11:27.699 
let's have a look on the concept of the Java virtual

233
00:11:27.700 --> 00:11:30.639 
machine as it is very crucial for the

234
00:11:30.640 --> 00:11:32.589 
mainframe as well.

235
00:11:32.590 --> 00:11:35.889 
So the Java virtual machine basically is

236
00:11:35.890 --> 00:11:39.039 
a runtime environment to execute the so-called bytecode.

237
00:11:40.330 --> 00:11:43.419 
If you develop Java, the developer starts with writing a

238
00:11:43.420 --> 00:11:46.389 
".java" file. We have seen that which contains one

239
00:11:46.390 --> 00:11:49.329 
class and usually have a lot of these files

240
00:11:49.330 --> 00:11:52.089 
containing all the classes that form the application.

241
00:11:52.090 --> 00:11:54.999 
So the developer writes the source code and

242
00:11:55.000 --> 00:11:57.939 
then there's a compiler, as in other languages, that

243
00:11:57.940 --> 00:12:00.879 
compiles the source code, which is basically a text in

244
00:12:00.880 --> 00:12:03.699 
a binary format that is sort of an

245
00:12:03.700 --> 00:12:06.309 
executable that is called ".class" file.

246
00:12:06.310 --> 00:12:09.219 
So it is a compiled version of the class, but

247
00:12:09.220 --> 00:12:11.469 
it's not compiled in the machine language of the target

248
00:12:11.470 --> 00:12:14.529 
system, but it's compiled in a machine-independent

249
00:12:14.530 --> 00:12:17.679 
intermediate code called the Java bytecode.

250
00:12:17.680 --> 00:12:20.829 
And then so you can imagine the Java bytecode is

251
00:12:22.000 --> 00:12:24.879 
the machine instructions for

252
00:12:24.880 --> 00:12:28.839 
the JVM, which can be thought of as a powerful

253
00:12:28.840 --> 00:12:30.512 
high-level virtual computer.

254
00:12:31.930 --> 00:12:34.869 
And this compiler, the translated,

255
00:12:34.870 --> 00:12:36.399 
of course, itself, is a Java program.

256
00:12:36.400 --> 00:12:39.309 
So Java is self-hosting like every good

257
00:12:39.310 --> 00:12:42.249 
programing language should be and the JVM,

258
00:12:42.250 --> 00:12:45.369 
the Java Virtual Machine then is the runtime

259
00:12:45.370 --> 00:12:48.549 
that takes a bytecode, converted basically

260
00:12:48.550 --> 00:12:50.439 
to the machine language of the target system and

261
00:12:50.440 --> 00:12:53.709 
executes at runtime and you start the program.

262
00:12:53.710 --> 00:12:56.959 
And the performance and the power of the

263
00:12:56.960 --> 00:12:59.679 
JVM strongly depends on how this translation from the

264
00:12:59.680 --> 00:13:02.469 
bytecode to the native machine language of the target

265
00:13:02.470 --> 00:13:04.389 
system takes place.

266
00:13:04.390 --> 00:13:07.449 
There are different ways to do that at runtime or

267
00:13:07.450 --> 00:13:09.909 
when the program is started before it is executed.

268
00:13:09.910 --> 00:13:12.129 
And this, of course, then will take some time.

269
00:13:12.130 --> 00:13:15.040 
So it shifts the time needed

270
00:13:16.270 --> 00:13:19.869 
to the beginning start up time and

271
00:13:19.870 --> 00:13:22.449 
different versions and different implementations of the

272
00:13:22.450 --> 00:13:25.389 
JVM over time have taken different approaches to

273
00:13:25.390 --> 00:13:26.429 
this issue.

274
00:13:28.110 --> 00:13:30.989 
You can see that on the right hand side, and if

275
00:13:30.990 --> 00:13:33.239 
you are the user, you just look on the system and you

276
00:13:33.240 --> 00:13:35.969 
see the applications in that sense, maybe some of these

277
00:13:35.970 --> 00:13:38.549 
applications, maybe Java applications like Eclipse or

278
00:13:38.550 --> 00:13:41.369 
Java, see the compiler and they run on

279
00:13:41.370 --> 00:13:44.369 
the VM, which is a native program, because

280
00:13:44.370 --> 00:13:47.249 
it translates the machine and you have other

281
00:13:47.250 --> 00:13:49.829 
apps that are native and then there's normal operating

282
00:13:49.830 --> 00:13:51.509 
system and below is the hardware.

283
00:13:51.510 --> 00:13:54.509 
So the JVM translates the bytecode to the

284
00:13:54.510 --> 00:13:57.049 
hardware of the underlying system.

285
00:13:59.630 --> 00:14:01.099 
What are the advantages of that concept?

286
00:14:01.100 --> 00:14:03.529 
Of course, the main advantage is that the bytecode is

287
00:14:03.530 --> 00:14:06.469 
platform independent or Java code is by default

288
00:14:06.470 --> 00:14:09.259 
platform-independent and can easily move from one machine

289
00:14:09.260 --> 00:14:11.989 
to another, from one hardware system, from one platform

290
00:14:11.990 --> 00:14:13.369 
to another.

291
00:14:13.370 --> 00:14:15.439 
A second concept is security.

292
00:14:15.440 --> 00:14:18.319 
Since the JVM is some sort of a sandbox, it avoids or

293
00:14:18.320 --> 00:14:21.349 
prohibits that the Java code can directly

294
00:14:21.350 --> 00:14:24.229 
access hardware or operating system functionalities

295
00:14:24.230 --> 00:14:27.049 
and therefore it avoids a lot or many

296
00:14:27.050 --> 00:14:30.739 
security holes that are possible with other languages.

297
00:14:30.740 --> 00:14:32.749 
The disadvantage, of course, is that you have a

298
00:14:32.750 --> 00:14:35.719 
performance trade-off compared to native applications

299
00:14:35.720 --> 00:14:38.659 
, because the bytecode in some way has to be

300
00:14:38.660 --> 00:14:42.049 
translated to the machine code in the runtime.

301
00:14:42.050 --> 00:14:45.079 
And this also in the past lead to the notion

302
00:14:45.080 --> 00:14:47.929 
that Java is considered slow by some people because it

303
00:14:47.930 --> 00:14:51.439 
sometimes costs a lot of resources to translate

304
00:14:51.440 --> 00:14:54.409 
this code. And the second thing is, of course,

305
00:14:54.410 --> 00:14:57.209 
a platform-specific operating system specific

306
00:14:57.210 --> 00:15:00.289 
or platform-specific features are either not fully usable

307
00:15:00.290 --> 00:15:03.199 
since the bytecode has to be platform-independent

308
00:15:03.200 --> 00:15:06.319 
or they require some special adaptation special classes

309
00:15:06.320 --> 00:15:09.559 
that then of course are not platform-independent anymore

310
00:15:09.560 --> 00:15:12.618 
to use it. And this is also true for the z/OS

311
00:15:12.619 --> 00:15:14.497 
environment will see that on the next slide.

312
00:15:16.370 --> 00:15:19.189 
And of course, one drawback is the JVM must

313
00:15:19.190 --> 00:15:22.219 
be available for the target platform, and

314
00:15:22.220 --> 00:15:25.159 
if the vendor of the target platform of the operating

315
00:15:25.160 --> 00:15:28.159 
system does not support Java, like, for example, the

316
00:15:28.160 --> 00:15:31.159 
mobile phones of iOS Apple mobile

317
00:15:31.160 --> 00:15:33.109 
phones, then you cannot run Java there.

318
00:15:33.110 --> 00:15:35.419 
So that is a problem.

319
00:15:35.420 --> 00:15:38.419 
And of course, for the mainframe, the

320
00:15:38.420 --> 00:15:39.799 
JVM needed to be implemented.

321
00:15:40.920 --> 00:15:43.249 
Java is now available for many years on the

322
00:15:44.510 --> 00:15:47.029 
z/OS and of course, on z Linux, or Linux on the

323
00:15:47.030 --> 00:15:48.030 
mainframe.

324
00:15:48.650 --> 00:15:51.019 
But in the beginning, of course, it took some time until

325
00:15:51.020 --> 00:15:52.369 
it was ported.

326
00:15:52.370 --> 00:15:55.219 
And one big thing is

327
00:15:55.220 --> 00:15:58.249 
that Java requires implicitly

328
00:15:58.250 --> 00:16:00.829 
a hierarchical file system because it has this package

329
00:16:00.830 --> 00:16:03.499 
structure that's built in the language syntax and that

330
00:16:03.500 --> 00:16:06.109 
maps to a hierarchical file tree.

331
00:16:06.110 --> 00:16:08.939 
And this is one issue that had to be solved.

332
00:16:08.940 --> 00:16:11.959 
So in z/OS, the

333
00:16:11.960 --> 00:16:15.169 
Java virtual machine in Java is executed

334
00:16:15.170 --> 00:16:18.199 
in the UNIX system services which have a hierarchical

335
00:16:18.200 --> 00:16:21.199 
file system which offer sort

336
00:16:21.200 --> 00:16:23.989 
of mapped hierarchical file system.

337
00:16:23.990 --> 00:16:26.839 
So Java is always running under z/OS in

338
00:16:26.840 --> 00:16:28.560 
the Unix system services environment.

339
00:16:30.200 --> 00:16:33.439 
IBM is offering a highly optimized JVM for that systems

340
00:16:33.440 --> 00:16:36.919 
that uses the most recent features of the CPU.

341
00:16:36.920 --> 00:16:39.919 
And this JVM is also available for

342
00:16:39.920 --> 00:16:42.859 
other hardware platforms, and

343
00:16:42.860 --> 00:16:43.860 
it is called the J9 VM.

344
00:16:44.960 --> 00:16:47.042 
So it's based, of course, on the standard JVM,

345
00:16:48.230 --> 00:16:51.379 
but it's especially adopted by IBM.

346
00:16:51.380 --> 00:16:54.499 
In 2017, IBM released this

347
00:16:54.500 --> 00:16:56.956 
JVM to open source and now it's called OpenJ9 VM

348
00:16:58.430 --> 00:17:01.489 
and is downloadable for

349
00:17:01.490 --> 00:17:02.490 
free.

350
00:17:02.990 --> 00:17:05.899 
Even for the mainframe.

351
00:17:05.900 --> 00:17:06.900 
And

352
00:17:09.140 --> 00:17:12.289 
during over time, IBM took different approaches

353
00:17:12.290 --> 00:17:14.869 
for this or for the predecessors of this VM to

354
00:17:16.579 --> 00:17:20.568 
run Java on z/OS, for example, in general, Java

355
00:17:20.569 --> 00:17:23.509 
maps its Java internal threads one to one on

356
00:17:23.510 --> 00:17:26.449 
the Unix system services P threads, which then are a one

357
00:17:26.450 --> 00:17:29.569 
to one mapping on the actual z/OS native

358
00:17:29.570 --> 00:17:32.449 
tasks managed by the task control blocks

359
00:17:32.450 --> 00:17:34.159 
you learned in the first chapter.

360
00:17:35.390 --> 00:17:36.390 
And

361
00:17:38.630 --> 00:17:42.199 
these are sort of normal standard z/OS

362
00:17:42.200 --> 00:17:43.200 
tasks.

363
00:17:44.300 --> 00:17:46.880 
IBM provide some additional class libraries, specific

364
00:17:47.930 --> 00:17:51.289 
for z/OS that then of course are not portable any more.

365
00:17:51.290 --> 00:17:54.139 
And these are bundled in something called the Java

366
00:17:54.140 --> 00:17:56.539 
for z/OS Batch Launcher JZOS.

367
00:17:56.540 --> 00:17:59.359 
And this is a product that allows to

368
00:17:59.360 --> 00:18:02.779 
access data sets, z/OS data sets from Java

369
00:18:02.780 --> 00:18:05.669 
and also allows to run Java in

370
00:18:05.670 --> 00:18:08.269 
the JCL jobs in the job entry subsystem.

371
00:18:08.270 --> 00:18:11.239 
So you can use Java for programing batch

372
00:18:11.240 --> 00:18:12.349 
applications as well.

373
00:18:13.850 --> 00:18:16.898 
Running Java in combination with CICS is

374
00:18:16.899 --> 00:18:18.859 
possible as well here.

375
00:18:18.860 --> 00:18:22.069 
One big issue is that CICS provides a very high

376
00:18:22.070 --> 00:18:25.549 
resolution mechanism between running transactions

377
00:18:25.550 --> 00:18:28.579 
to mimic that in Java first until CICS

378
00:18:28.580 --> 00:18:29.580 
transactions server over

379
00:18:33.710 --> 00:18:37.279 
V3 use the so-called pooled persistent reusable JVM,

380
00:18:37.280 --> 00:18:40.219 
which was a mechanism to isolate

381
00:18:40.220 --> 00:18:43.039 
the parallel threads in Java from each

382
00:18:43.040 --> 00:18:45.979 
other. And then because this

383
00:18:45.980 --> 00:18:48.829 
led to a performance trade-offs, it was

384
00:18:48.830 --> 00:18:51.410 
replaced by the modern, more modern Java

385
00:18:52.760 --> 00:18:56.269 
from CICS transactions server V4 and onwards.

386
00:18:56.270 --> 00:18:59.569 
And now they handle this by special

387
00:18:59.570 --> 00:19:02.029 
new type of task control blocks.
