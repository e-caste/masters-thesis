WEBVTT

1
00:00:04.610 --> 00:00:09.170 
Now we want to ask ourselves how characters are encoded. And

2
00:00:09.610 --> 00:00:15.160 
what kind of graphics and video formats are used in the internet.

3
00:00:16.310 --> 00:00:19.690 
Bandwidth and efficiency of data transfer is very important

4
00:00:19.690 --> 00:00:21.430 
in using web applications.

5
00:00:22.050 --> 00:00:28.820 
The data in the web have to be transferred and typically a mess of data

6
00:00:29.100 --> 00:00:32.260 
have to be transferred from the server to the client.

7
00:00:33.200 --> 00:00:36.960 
In order to be able to communicate text information,

8
00:00:37.480 --> 00:00:44.580 
it is necessary to encode the characters of text.

9
00:00:45.220 --> 00:00:52.770 
Encoding means that the characters are transferred into a string of bits.

10
00:00:55.290 --> 00:00:59.070 
The encoding, of course, needs to be standardized.

11
00:00:59.490 --> 00:01:04.300 
Otherwise a web server does not know how to decode

12
00:01:04.750 --> 00:01:10.960 
the character. He is not able to understand the text if it's not characterized.

13
00:01:11.180 --> 00:01:13.790 
So a browser needs exactly to know

14
00:01:14.770 --> 00:01:20.980 
what kind of binary strings is corresponding to what character, and

15
00:01:21.100 --> 00:01:25.340 
in this way when he doesn't know, it's able to reconstruct the

16
00:01:25.340 --> 00:01:28.490 
text and to display the text in the right way.

17
00:01:30.170 --> 00:01:33.600 
If we look for the data that are transferred in the internet, then today

18
00:01:33.600 --> 00:01:37.710 
more and more information does not come in form of text but

19
00:01:37.710 --> 00:01:41.300 
it comes in form of graphics, of photos

20
00:01:41.940 --> 00:01:50.400 
of audio, of video. So a user also here expect fast and efficient communication,

21
00:01:50.650 --> 00:01:56.810 
but graphics audio and video data are much more extensive, much more

22
00:01:57.190 --> 00:02:00.390 
entail much more informations than text information.

23
00:02:00.930 --> 00:02:06.030 
So here it's particularly crucial to provide this data in formats

24
00:02:06.440 --> 00:02:09.740 
that allow to be efficiently transferred.

25
00:02:10.940 --> 00:02:13.850 
Let's start with consider character encoding.

26
00:02:14.320 --> 00:02:18.230 
Characters this is also letters and special characters

27
00:02:18.760 --> 00:02:24.380 
text are created from, have to be encoded to a format

28
00:02:24.990 --> 00:02:29.720 
that computers can handle. So here is an example- We have the character 'A',

29
00:02:30.230 --> 00:02:35.940 
and we have to transfer, to encode this character as a bit string.

30
00:02:36.440 --> 00:02:41.910 
So here are 7 bits used to represent this character.

31
00:02:42.470 --> 00:02:48.490 
And the representation of this bit string can be done by means of a

32
00:02:48.780 --> 00:02:50.370 
decimal number.

33
00:02:51.760 --> 00:02:57.830 
We take the powers of twos and then multiply each with the corresponding bit.

34
00:02:57.940 --> 00:03:04.050 
One times two to the zero, zero times two to the one and so on and so on

35
00:03:04.250 --> 00:03:08.090 
up to the last bit or the first bit, how you consider it.

36
00:03:09.440 --> 00:03:14.250 
One times two to the seven. And then we get a number in this case-

37
00:03:14.260 --> 00:03:21.250 
65 and the 65 is taken as a decimal representation of

38
00:03:21.510 --> 00:03:22.390 
the character 'A'.

39
00:03:23.810 --> 00:03:28.410 
The historical first approach to standardize this encoding was the ASCII-

40
00:03:29.420 --> 00:03:33.760 
American Standard Code for Information Interchange.

41
00:03:35.550 --> 00:03:38.240 
This ASCII was a 7 bit

42
00:03:39.190 --> 00:03:44.390 
encoding. I took here the example 'A' from the ASCII standard.

43
00:03:45.050 --> 00:03:50.020 
The problem was that it could not be used for international communication because

44
00:03:50.320 --> 00:03:58.050 
with 7 bits, we can only encode 128 characters.

45
00:03:58.280 --> 00:04:00.610 
With 7 bits, we can only

46
00:04:01.980 --> 00:04:04.760 
encode two to the seven

47
00:04:06.530 --> 00:04:10.140 
different characters and two to exactly

48
00:04:10.920 --> 00:04:12.240 
128.

49
00:04:13.310 --> 00:04:17.470 
This is the ASCII list. You see here are the special characters

50
00:04:17.900 --> 00:04:22.630 
'A' and then here are the numbers. This is a digit,

51
00:04:23.230 --> 00:04:26.320 
then are the character, capital character,

52
00:04:27.010 --> 00:04:33.790 
small characters and each of the character has a number. The character A-

53
00:04:33.990 --> 00:04:40.260 
capital A has the value 65. We saw in the example last slide.

54
00:04:41.960 --> 00:04:44.530 
Now we see 7 bits.

55
00:04:45.180 --> 00:04:50.610 
I mentioned already we can only encode 128

56
00:04:51.620 --> 00:04:54.050 
different characters.

57
00:04:55.100 --> 00:04:58.500 
To encode more characters, we need more bits.

58
00:04:59.490 --> 00:05:05.160 
So one approach was to design an 8-Bit ASCII encoding.

59
00:05:05.650 --> 00:05:10.220 
This was done with the Standard 8859

60
00:05:10.680 --> 00:05:17.050 
and the idea behind is that the first 128

61
00:05:19.470 --> 00:05:24.060 
numbers are exactly used in the same way like

62
00:05:24.060 --> 00:05:28.330 
in the ASCII code. And then we have with 8 Bit

63
00:05:30.610 --> 00:05:33.840 
additional one hundred twenty eight possibilities

64
00:05:34.270 --> 00:05:37.810 
to characterize other

65
00:05:39.100 --> 00:05:41.690 
characters. So in the

66
00:05:43.020 --> 00:05:51.420 
8 Bit ASCII values, one twenty eight up to one fifty nine are used for

67
00:05:51.940 --> 00:05:57.500 
control characters, and then the remaining one hundred sixty to

68
00:05:57.890 --> 00:05:59.240 
two hundred fifty five

69
00:06:00.220 --> 00:06:06.630 
values are used for multinational extensions. Here you see some of special characters

70
00:06:06.810 --> 00:06:11.430 
coming from different languages. This last

71
00:06:12.640 --> 00:06:17.650 
values are used in different ways. So we have different

72
00:06:18.210 --> 00:06:24.250 
standards from the eighty eight fifty nine. So for example we have the standard

73
00:06:25.220 --> 00:06:31.410 
ISO 8859. One that's used for western Europe.

74
00:06:31.410 --> 00:06:36.640 
That means that the multinational extensions here encode western

75
00:06:37.970 --> 00:06:41.690 
special characters from western Europe languages.

76
00:06:42.450 --> 00:06:44.680 
Eighty eight fifty nine two standard

77
00:06:46.020 --> 00:06:52.040 
then the additional multinational extensions are used for special characters from central

78
00:06:52.300 --> 00:06:56.150 
Europe languages- Hebew, Greek and others.

79
00:06:58.250 --> 00:07:05.490 
But still problem is not solved. What about Chinese, Japanese, Korean language

80
00:07:05.890 --> 00:07:10.480 
which have thousands of characters? Here with this even with

81
00:07:10.480 --> 00:07:14.260 
this 8 Bit ASCII, we can only encode two hundred

82
00:07:14.840 --> 00:07:16.470 
fifty six characters.

83
00:07:17.260 --> 00:07:21.450 
For that reason Unicode was developed.

84
00:07:22.240 --> 00:07:26.660 
UTF encoding scheme Universal Transformation Formats.

85
00:07:27.350 --> 00:07:32.990 
And this Unicode takes more bits to encode characters.

86
00:07:33.750 --> 00:07:38.210 
There's a version UTF-8. This is an 8 Bit Unicoding

87
00:07:38.390 --> 00:07:42.820 
and this is very compatible with ASCII and with the 8 bit ASCII.

88
00:07:43.480 --> 00:07:49.300 
Then we have the UTF-16. Here this is a 16 Bit encode.

89
00:07:49.790 --> 00:07:54.880 
You see with 16 bit we can encode much more characters.

90
00:07:54.880 --> 00:07:57.900 
So we can encode two to the sixteen

91
00:07:59.030 --> 00:08:06.960 
characters, and in this UTF-16 characters consumes 16 or 32

92
00:08:07.430 --> 00:08:13.570 
bits and then we have the UTF 32. It is a 32 bit encode

93
00:08:14.280 --> 00:08:19.300 
and now as the characters always consume 32 bits, this

94
00:08:19.300 --> 00:08:25.190 
UTF is organized in different planes, and the UTF it's no problem

95
00:08:25.480 --> 00:08:30.720 
to encode also Chinese or Japanese letters and

96
00:08:31.190 --> 00:08:36.080 
this is the reason how to encode characters.

97
00:08:37.810 --> 00:08:40.210 
So this was one of the problems. So now we can

98
00:08:40.640 --> 00:08:46.960 
communicate text information. So for each character we have 7,8

99
00:08:47.210 --> 00:08:51.860 
up to 32 bits. So that's not too much. But when we start

100
00:08:51.860 --> 00:08:54.570 
to speak about graphics and video formats,

101
00:08:56.030 --> 00:09:02.190 
in general and multimedia data then there is a lot of information to be transferred.

102
00:09:04.110 --> 00:09:08.350 
While text encoding does not require lots of bandwidth, this graphics

103
00:09:08.440 --> 00:09:15.430 
audio and video do. So in order to increase a browsing speed and reduce traffic

104
00:09:15.780 --> 00:09:18.790 
traffic in the internet particularly, traffic on the routers,

105
00:09:19.110 --> 00:09:23.760 
it is very important to reduce the size of the transferred files.

106
00:09:24.540 --> 00:09:30.910 
And this is done by combining the encoding and with the compression.

107
00:09:32.460 --> 00:09:38.280 
So one starts with an original file and then one tries to compress the

108
00:09:38.580 --> 00:09:43.370 
information contained in it. For example one analyze an image

109
00:09:43.370 --> 00:09:48.020 
and if an image has important parts there are some less important parts

110
00:09:48.220 --> 00:09:52.850 
so with the compression, one tries to kick out the unimportant parts

111
00:09:53.020 --> 00:09:58.480 
with the goal to have the information in a more compact way,

112
00:09:58.820 --> 00:10:02.960 
to be able to faster transmitted over the internet.

113
00:10:03.960 --> 00:10:08.450 
The goal is to make a compression without loss of information,

114
00:10:08.680 --> 00:10:14.390 
or at least with a very small loss of information of important

115
00:10:15.870 --> 00:10:19.380 
parts of the picture, of the video, of the audio.

116
00:10:20.180 --> 00:10:24.570 
Of course also this needs to be standardized, otherwise the

117
00:10:24.580 --> 00:10:29.970 
browsers are not able to decode the encoded file.

118
00:10:30.510 --> 00:10:33.070 
So we start with the original files and we

119
00:10:33.480 --> 00:10:37.230 
then compression and encoding is applied.

120
00:10:37.840 --> 00:10:42.040 
And then the encoded file is transported over the internet.

121
00:10:42.190 --> 00:10:43.660 
And of course in the browser,

122
00:10:44.950 --> 00:10:48.830 
way in the other direction have to be followed.

123
00:10:49.820 --> 00:10:54.340 
Let's start to have a look to graphic and graphics encoding,

124
00:10:54.720 --> 00:10:59.190 
and let's start first to speak about Vector Graphics. Vector Graphics

125
00:10:59.380 --> 00:11:05.240 
that is a mathematical format using geometrical primitives to describe

126
00:11:05.380 --> 00:11:07.790 
and graphic to describe an image.

127
00:11:08.570 --> 00:11:14.570 
Geometrical primitives - these are points, lines curves, shapes and polygons.

128
00:11:14.790 --> 00:11:18.300 
Here located in such a coordinate system.

129
00:11:19.940 --> 00:11:25.190 
The idea and that's where the name come from is that the primitives are

130
00:11:25.660 --> 00:11:29.530 
the position of the primitves are characterized by vectors.

131
00:11:31.370 --> 00:11:35.810 
Vectors are characterized by a starting point and by a direction

132
00:11:36.260 --> 00:11:42.100 
and then for each of these object, the location can be described

133
00:11:42.450 --> 00:11:44.140 
exactly by means of such a vector.

134
00:11:44.900 --> 00:11:49.050 
So the most popular format for such vector graphics

135
00:11:49.450 --> 00:11:52.970 
is the SVG format- the Scalable

136
00:11:53.690 --> 00:11:55.730 
Vector Graphics.

137
00:11:57.190 --> 00:12:00.460 
The advantage of this vector graphics and the

138
00:12:01.210 --> 00:12:07.970 
scalable vector graphics format is that such type of images can very easily

139
00:12:08.720 --> 00:12:15.450 
be scaled. One can zoom in, one can easily zoom out because one only has to

140
00:12:16.130 --> 00:12:18.720 
change the length of the vectors

141
00:12:19.810 --> 00:12:25.630 
for all the vectors in same time. So low space consumption is

142
00:12:25.630 --> 00:12:31.560 
necessary and an XML based format for the transmission

143
00:12:32.370 --> 00:12:35.760 
needs can easily be designed. So this is advantage.

144
00:12:36.210 --> 00:12:41.450 
The disadvantage is this kind of representation of an image does

145
00:12:41.450 --> 00:12:45.990 
not work well for photos, and other very complex pictures.

146
00:12:48.410 --> 00:12:53.820 
Here is a small example of an SVG graphic. You see

147
00:12:54.940 --> 00:13:00.650 
sites at SVG format. So that if a browser receives such an information

148
00:13:00.650 --> 00:13:05.390 
he can understand and know ok this is an SVG encoding. Then

149
00:13:05.760 --> 00:13:11.660 
the width and the height is described. It is a rectangular

150
00:13:12.120 --> 00:13:17.380 
of a certain width and height. They are in color of

151
00:13:18.890 --> 00:13:23.010 
the square rectangular and then there is in

152
00:13:23.470 --> 00:13:29.950 
line link's stroke with given. So if a browser receives this information,

153
00:13:30.320 --> 00:13:35.420 
it interpreters in the following way. We have a square with the color

154
00:13:35.560 --> 00:13:40.680 
blue, which is described here. A zero zero two hundred fifty is the rgb

155
00:13:41.230 --> 00:13:45.570 
Coordinate of the blue color. And there is a stroke

156
00:13:46.970 --> 00:13:49.350 
lengths and widths and the height and

157
00:13:49.960 --> 00:13:55.010 
heights and width are described. So in this way this kind of

158
00:13:55.010 --> 00:13:59.960 
graphic can be very compactly described and

159
00:14:00.680 --> 00:14:02.410 
transferred. Now let's

160
00:14:03.300 --> 00:14:07.310 
have a look to Bitmap Graphics. I mentioned as vector graphics are not suited

161
00:14:07.720 --> 00:14:12.100 
to represent photos.

162
00:14:12.710 --> 00:14:16.380 
So the idea of this bitmap graphics is another approach to

163
00:14:17.110 --> 00:14:23.360 
encode graphics. And it is a historical approach is to

164
00:14:24.730 --> 00:14:30.770 
divide an image in many, many different pieces and then to describe each piece.

165
00:14:31.190 --> 00:14:36.300 
The pieces are called pixels. To describe each pixels in exactly

166
00:14:36.710 --> 00:14:40.440 
the same way. Then if you analyze a large image, then you see

167
00:14:40.440 --> 00:14:44.210 
this is a blue pixels, it's a red pixel, that's the yellow pixel and

168
00:14:44.430 --> 00:14:48.710 
so you can combine the description. You can get a description

169
00:14:48.710 --> 00:14:51.560 
of the full image by saying pixel by pixel

170
00:14:52.650 --> 00:14:54.160 
how it is characterized.

171
00:14:55.000 --> 00:14:57.090 
There is a bit map

172
00:14:58.810 --> 00:15:04.790 
BMP format to describe such bitmaps. Bitmaps encoding is used

173
00:15:04.790 --> 00:15:09.530 
for example in TV. So TVimages this is a

174
00:15:10.500 --> 00:15:14.760 
huge number of pixels which are transmitted.

175
00:15:15.170 --> 00:15:19.700 
But this is not suitable for the web because it's a huge amount of information

176
00:15:19.910 --> 00:15:23.400 
to describe such an image. So what is better

177
00:15:24.360 --> 00:15:28.840 
is to compress this bitmap format. And one idea for example is

178
00:15:29.330 --> 00:15:33.470 
not to describe here pixel by pixel by pixel by pixel that's a blue pixel

179
00:15:33.840 --> 00:15:37.900 
to say no there is a blue pixel and then the next one and then

180
00:15:38.170 --> 00:15:42.010 
one has to give the number, the next one of pixel is also the same

181
00:15:42.140 --> 00:15:45.700 
color. And in this way one can get in with other tricks one

182
00:15:45.700 --> 00:15:51.680 
can get a lot of compression, without losing information or losing only

183
00:15:52.330 --> 00:15:56.780 
a little bit of information and famous formats which follow

184
00:15:56.780 --> 00:16:01.090 
this ideas as a coding idea, encoding a bitmap, formats are JPEG,

185
00:16:01.810 --> 00:16:06.240 
PNG, GIF, TIFF. If you know such kind of formats

186
00:16:06.650 --> 00:16:07.990 
from your transformation.

187
00:16:08.670 --> 00:16:11.660 
Here's only an example. We have the original

188
00:16:12.530 --> 00:16:16.450 
BMP format which exactly says pixel by pixel,

189
00:16:16.860 --> 00:16:20.540 
what is a color you see. It's a nice photo. A complex structure.

190
00:16:20.900 --> 00:16:23.480 
And what's interesting with a JPEG

191
00:16:24.220 --> 00:16:28.960 
encoding, we have one third this image was

192
00:16:28.960 --> 00:16:34.050 
88KB, this is only 27KB. We get a reduction

193
00:16:34.460 --> 00:16:40.260 
by the factor three. But you see it's exactly the same image. One cannot see

194
00:16:40.650 --> 00:16:43.220 
differences between these two images.

195
00:16:43.920 --> 00:16:49.930 
At least with a usual eye. And then one can try to get an even

196
00:16:50.380 --> 00:16:56.090 
larger compression. So here you see it's the next factor by ten

197
00:16:56.760 --> 00:17:01.040 
in the reduction and then the first impression is you get all

198
00:17:01.040 --> 00:17:04.790 
the details of the image, but it starts to be

199
00:17:05.250 --> 00:17:09.730 
that some of the information are lost. You can see a difference

200
00:17:09.730 --> 00:17:14.820 
if you look exactly, but to get the impression, we have a

201
00:17:16.040 --> 00:17:20.450 
huge reduction compared to the original image, and one can see

202
00:17:20.450 --> 00:17:22.410 
it's a lake and shoes and

203
00:17:23.070 --> 00:17:23.720 
the situation.

204
00:17:25.290 --> 00:17:29.910 
This is the encoding of graphics. If we go

205
00:17:30.420 --> 00:17:36.640 
to the video and all the information, then it's even more important to think about

206
00:17:37.610 --> 00:17:42.850 
ideas of compression. So usually videos consist of a video stream,

207
00:17:42.850 --> 00:17:45.790 
a video stream is a huge number of many, many

208
00:17:46.500 --> 00:17:52.020 
images and synchronously there is an audio stream, and both

209
00:17:52.050 --> 00:17:57.630 
need to be encoded. Encoding of video is a very complex task,

210
00:17:57.730 --> 00:18:01.770 
and there is software so called codec which

211
00:18:03.450 --> 00:18:07.690 
performs this encoding. They encode the video stream, they encode

212
00:18:07.710 --> 00:18:12.190 
the audio stream and put both together in a container.

213
00:18:13.390 --> 00:18:16.410 
So famous video codecs are H.264

214
00:18:17.140 --> 00:18:19.440 
Ogg Theora, WebM.

215
00:18:20.190 --> 00:18:25.240 
I mentioned codec, there are much more codecs. I mentioned the codecs that are

216
00:18:25.420 --> 00:18:31.050 
assumed to work with HTML 5. We discussed this already in a

217
00:18:31.390 --> 00:18:36.550 
former week. Famous audio codecs are mp3,

218
00:18:37.640 --> 00:18:41.810 
wma, AAC, Ogg Vorbis. Also these are the

219
00:18:42.660 --> 00:18:46.490 
audio codecs which are assumed to be

220
00:18:47.720 --> 00:18:54.130 
usable in connection with HTML 5 and for the containers,

221
00:18:54.790 --> 00:18:58.340 
there are common formats mp4, WebM,

222
00:18:58.940 --> 00:19:06.160 
OGV. And this codecs also here there are more container formats, more audio codecs.

223
00:19:07.120 --> 00:19:13.540 
This needs to be understood if the server compress the video with this

224
00:19:13.850 --> 00:19:18.240 
codec, then the browser needs to be able

225
00:19:18.880 --> 00:19:25.540 
to understand this information. So he needs as a plugin or he needs to have

226
00:19:27.350 --> 00:19:32.040 
in its software this codecs to be able to

227
00:19:32.510 --> 00:19:37.900 
unencode the encoded data, which were encoded to make transformation

228
00:19:38.340 --> 00:19:41.950 
transport in the internet possible in a faster way. So if we

229
00:19:41.950 --> 00:19:44.980 
look for an example, we have a header information

230
00:19:45.940 --> 00:19:50.650 
container, there is a video as a compressed video, there is a compressed audio.

231
00:19:51.100 --> 00:19:57.240 
There are features, so that's an audio and the video runs asynchornously.

232
00:19:57.570 --> 00:20:01.280 
And if we want to have more information, for example subtitles

233
00:20:01.860 --> 00:20:05.080 
for a video or different audio

234
00:20:06.200 --> 00:20:12.650 
tracks for German or for English or for Chinese language version,

235
00:20:12.960 --> 00:20:18.750 
then it's a typical form. The files are compressed and transmitted over the internet.

236
00:20:20.000 --> 00:20:25.860 
Problem is that not all browsers support all the formats. We

237
00:20:25.860 --> 00:20:31.960 
discussed when we discussed about HTML 5. This new way which allows that the

238
00:20:32.410 --> 00:20:39.230 
browser is able to decode although such video and audio information

239
00:20:39.650 --> 00:20:42.530 
that the browsers behave different.

240
00:20:43.180 --> 00:20:48.500 
In any case if one is willing one can plug in

241
00:20:49.130 --> 00:20:54.910 
a codec if one knows exactly what kind of compression,

242
00:20:55.360 --> 00:20:59.990 
what kind of encoders are used for the video and audio. But

243
00:21:00.010 --> 00:21:04.260 
it's much more convenient if you go to a web application and

244
00:21:04.260 --> 00:21:08.500 
a web service and receive the information that you does not care.

245
00:21:08.860 --> 00:21:13.150 
It's not necessary to care about such encoding questions. Your browser

246
00:21:13.360 --> 00:21:17.550 
should know and should be able to recognize

247
00:21:17.980 --> 00:21:23.410 
the type of compression, and then to be able to decode

248
00:21:24.050 --> 00:21:29.060 
so that you can follow the video and the audio and enjoy

249
00:21:29.560 --> 00:21:31.440 
what you received from the web.
