WEBVTT

1
00:00:00.560 --> 00:00:05.710 
Hello, this is the seventh part of the
course that we are proposing to you.

2
00:00:06.330 --> 00:00:09.120 
and in this course,
we will cover

3
00:00:09.750 --> 00:00:16.030 
the discovery of the framework
and usage of CAPI and OpenCAPI

4
00:00:16.230 --> 00:00:21.150 
to ease the coding of an
accelerator. and we learn many

5
00:00:21.640 --> 00:00:23.840 
??see everything from a
software coding standpoint.

6
00:00:24.680 --> 00:00:28.730 
my name is Alexandre
Castellane and glade to

7
00:00:29.220 --> 00:00:33.790 
present you this course. and I
am working for IBM in France.

8
00:00:34.830 --> 00:00:38.400 
what will cover is many
people see different

9
00:00:39.210 --> 00:00:46.190 
paradigs and considerations about analyzing
an action into different systems.

10
00:00:46.670 --> 00:00:51.420 
we'll see what could be the usage of
CAPI and OpenCAPI technology without

11
00:00:51.470 --> 00:00:58.410 
framework, direct coding. We will then see this
discover in meditates, what the frameworks

12
00:00:58.760 --> 00:01:04.480 
proposes today. for examples and
hopefully, we'll get a summary of

13
00:01:04.810 --> 00:01:08.860 
the main steps he would have to go
through. if you want to externalised

14
00:01:09.270 --> 00:01:11.160 
an action into a FPGA.

15
00:01:12.880 --> 00:01:16.820 
so let's come back to the earlier basic example
where you have a piece of code running

16
00:01:17.120 --> 00:01:22.720 
input variables and providing
output from CPU to

17
00:01:23.500 --> 00:01:28.550 
development. should you need to improve
performances due to the producer

18
00:01:28.830 --> 00:01:33.950 
constraints that we will cover it in
part one and recover it in part two.

19
00:01:34.390 --> 00:01:39.380 
and we'll learn to
consider analyzing the

20
00:01:39.900 --> 00:01:42.350 
part of the competition
into a GPU for example.

21
00:01:43.070 --> 00:01:46.460 
there is a need to duplicate the
data, part of data, at least.

22
00:01:46.620 --> 00:01:49.260 
and then important

23
00:01:50.340 --> 00:01:55.090 
time would be spent to
duplicate, a to a prime and

24
00:01:55.090 --> 00:02:00.240 
b to b prime. same for the results, for
short results need to be collected back

25
00:02:00.530 --> 00:02:03.140 
and administrative before
you get the final result.

26
00:02:03.620 --> 00:02:07.830 
so you end up with the issue
of duplication of the top

27
00:02:08.590 --> 00:02:11.970 
at the gain of computing them
more quickly into a GPU.

28
00:02:13.590 --> 00:02:17.860 
this application is really the
key point of our topic.

29
00:02:18.410 --> 00:02:23.740 
so if you want to analyze to FPGA, you will
be in the contract exactly the same case,

30
00:02:24.070 --> 00:02:28.880 
where the duplication in a
traditional way is about to make

31
00:02:29.160 --> 00:02:32.330 
for your overall
preference.

32
00:02:33.340 --> 00:02:39.430 
now if you use CAPI or OpenCAPI, there is no
need to duplicate. thanks to coherency,

33
00:02:39.710 --> 00:02:42.840 
you have no
time spent to

34
00:02:43.590 --> 00:02:48.370 
this organizing the
currency of data.

35
00:02:48.460 --> 00:02:52.550 
you can directly get them from the
host memory, from the competition

36
00:02:52.680 --> 00:02:57.170 
hardware that is running into the
FPGA. same exercise for the

37
00:02:57.180 --> 00:03:02.450 
output, it can go back directly into
the memory from the FPGA itself.

38
00:03:03.190 --> 00:03:06.630 
if you can simplify the
triggering of your hardware

39
00:03:07.230 --> 00:03:10.800 
using a framework. then it would be
the happier going onto the road.

40
00:03:11.940 --> 00:03:17.930 
let's see what development in CAPI
and OpenCAPI can bring to you.

41
00:03:18.220 --> 00:03:22.400 
so let's take an example in host
server running application and

42
00:03:22.400 --> 00:03:26.930 
enough FPGA already host
part of your code.

43
00:03:27.840 --> 00:03:31.500 
the main processes should be able
to take in software side cxl,

44
00:03:31.500 --> 00:03:33.640 
which is a CAPI
acceleration library.

45
00:03:34.310 --> 00:03:40.240 
and also took from lib(o)cxl, or libcxl
too, lib(o)cxl is in OpenCAPI,

46
00:03:40.850 --> 00:03:44.750 
then on the hardware side, you
obviously need some hardwares

47
00:03:45.260 --> 00:03:49.860 
that is required to make a good exchange
with a software part in between

48
00:03:50.050 --> 00:03:54.130 
your CAPI and OpenCAPI
technology and links to make

49
00:03:54.130 --> 00:03:58.450 
sure that everything is taking
from one site to another.

50
00:03:59.430 --> 00:04:02.810 
you still have to develop your application,
if your software is developed

51
00:04:02.820 --> 00:04:08.700 
you have to externalize some of it to
put all the code into your FPGA,

52
00:04:08.990 --> 00:04:11.630 
rather than the codes need
to be described into HDL,

53
00:04:12.330 --> 00:04:17.360 
hardware description language.
this requires you to

54
00:04:17.460 --> 00:04:22.320 
to benefit from hardware
engineering skills

55
00:04:22.800 --> 00:04:27.540 
to make a very fine
true application.

56
00:04:28.030 --> 00:04:31.220 
this really leads to a very
big development effort.

57
00:04:31.810 --> 00:04:36.160 
this program provides very extremely
good performance, full control of

58
00:04:36.170 --> 00:04:39.040 
at the least by
exchange and

59
00:04:39.610 --> 00:04:45.770 
the programming is based on the
libcxl and PSL/TL-DL interface

60
00:04:46.060 --> 00:04:47.130 
that we have
shown in blue.

61
00:04:48.840 --> 00:04:53.940 
Now what would be the world
if we can ease and release

62
00:04:54.110 --> 00:04:55.790 
the need for
hardware skills.

63
00:04:56.540 --> 00:04:59.010 
so this part will
cover the OC-ACCEL,

64
00:04:59.410 --> 00:05:03.420 
which is simply the third
evolution of the snap,

65
00:05:03.860 --> 00:05:08.970 
which was aimed to address
CAPI 1and CAPI 2 technology.

66
00:05:09.100 --> 00:05:13.390 
OC-ACCEL is aimed at addressing
OpenCAPI technology. the code can be

67
00:05:13.390 --> 00:05:16.400 
looked at here, is located
it in GitHub. so it is

68
00:05:16.880 --> 00:05:21.770 
freely available and the
documentation is also on the GitHub

69
00:05:22.130 --> 00:05:27.340 
repository. we will see how we
can describe the projects

70
00:05:27.610 --> 00:05:29.080 
going through
simple examples.

71
00:05:29.890 --> 00:05:35.320 
examing, look at the simulation
and the generation

72
00:05:35.320 --> 00:05:40.500 
of the flash memory content. and
fully see an example of deployment

73
00:05:40.810 --> 00:05:46.540 
on the Power. so letÂ´s take the same example
as before, we have the same server

74
00:05:46.540 --> 00:05:51.460 
and the same FPGA card with same
processes running up an application

75
00:05:51.470 --> 00:05:55.390 
on the left side, and we have the
same libraries with the same

76
00:05:55.390 --> 00:06:00.600 
link, the same hardware that talks
to the openCAPI link in the FPGA.

77
00:06:01.440 --> 00:06:07.350 
let's have a framework which
provides you a new library and

78
00:06:07.730 --> 00:06:13.460 
complete description of the connection
and main blocks that we ease the DRAM

79
00:06:13.670 --> 00:06:18.880 
and ease the talking to the registers to
allow you to address your hardware.

80
00:06:19.570 --> 00:06:24.470 
it also provides you perversion for
several access paths which are

81
00:06:24.470 --> 00:06:28.540 
hardware way to talk to the
action of devoloping hardware.

82
00:06:29.420 --> 00:06:32.690 
we have addressed
several rams

83
00:06:33.400 --> 00:06:37.320 
the most known once are
counted in divide date.

84
00:06:37.810 --> 00:06:42.330 
we have approved a connection to the
recent cards using the simple c mac

85
00:06:42.650 --> 00:06:47.280 
provided by ethernets
and it's opened to

86
00:06:47.720 --> 00:06:52.160 
host other exist connected
hardware devices or drivers.

87
00:06:53.610 --> 00:06:56.900 
up to you to develop your program
and code your hardware, you

88
00:06:56.900 --> 00:07:01.830 
can still code using
a verilog, HLS or

89
00:07:02.120 --> 00:07:06.390 
HLS languages, but you
also free to use hls

90
00:07:06.400 --> 00:07:08.360 
which has been described
in part one.

91
00:07:10.870 --> 00:07:17.030 
going to the documentation here is the
site where you can find the example and

92
00:07:17.320 --> 00:07:22.340 
the topology and the map of the
different things that offer it

93
00:07:22.540 --> 00:07:27.290 
in oc- accel. we will
concentrate on a few examples,

94
00:07:27.800 --> 00:07:32.550 
in each action, as you can see,
oc-accel action, you will

95
00:07:33.530 --> 00:07:36.960 
set the directory which is software
where you would find your application

96
00:07:37.300 --> 00:07:42.940 
usually coding in c, but you also can code
it in python and you will see in hardware

97
00:07:43.050 --> 00:07:46.650 
the description of the logic
that we go into the FPGA.

98
00:07:47.150 --> 00:07:50.830 
we will briefly explore the
pixel manipulation example

99
00:07:51.390 --> 00:07:56.810 
and we will see also some
things on python usage.

100
00:07:57.870 --> 00:08:02.790 
so first of all, we will set up Xilinx
tools. as you understand, most

101
00:08:02.790 --> 00:08:05.890 
of software development is easy
to getting access today.

102
00:08:06.700 --> 00:08:11.230 
so you need to set up your
path and setup the version.

103
00:08:11.240 --> 00:08:14.900 
so you have a small script that you need
to run, you need to have a license.

104
00:08:15.210 --> 00:08:21.010 
and you see an example of a setting that
allow you to make sure that it allows yours

105
00:08:21.020 --> 00:08:25.560 
running properly, as it
is used by oc-accel.

106
00:08:25.560 --> 00:08:32.540 
the first thing you need to do is to
clone the github site using gclone

107
00:08:32.830 --> 00:08:37.850 
and path to oc-accel, once you have this
clone and set up in your pattern,

108
00:08:38.300 --> 00:08:42.770 
you need to make snap config which will
offer you an open-source menu, when you

109
00:08:43.040 --> 00:08:46.280 
have his menu, it allows you to
select the different cards who

110
00:08:46.280 --> 00:08:50.740 
have prepared for you and the different
actions that we support today as examples.

111
00:08:51.360 --> 00:08:56.610 
you can select different topics
and topics are reorganizing

112
00:08:56.620 --> 00:09:01.720 
depending on the previous choices you have
made in order to limit the risk of errors.

113
00:09:02.630 --> 00:09:06.040 
once you've done that you are built
with a configuration. let's

114
00:09:06.040 --> 00:09:09.860 
take the example of the image filter.
so we can look at different

115
00:09:09.860 --> 00:09:14.010 
files that you would find in
hardware. this is the file where

116
00:09:14.010 --> 00:09:19.660 
we see that the HLS is failed
and the output of HLS

117
00:09:19.670 --> 00:09:23.170 
is returning so strength, so this
is the description of pipelines.

118
00:09:24.250 --> 00:09:29.640 
this is the connection to the host
memory which is where we see

119
00:09:29.750 --> 00:09:34.090 
how we can collect data from
the host memory, images have

120
00:09:34.090 --> 00:09:39.010 
been put into the memory by the
application and FPGA is connected

121
00:09:39.020 --> 00:09:43.970 
directly data to the memory and
putting them into the stream of HLS

122
00:09:44.190 --> 00:09:49.530 
to be able to digest that. this is a
description of the pixel manipulation.

123
00:09:49.950 --> 00:09:52.390 
thanks to HPI for
this very helpful

124
00:09:53.220 --> 00:09:58.440 
example. so the goal is to
detect how much red there

125
00:09:58.440 --> 00:10:05.250 
is into a pixel. if a red is
not sufficiently present,

126
00:10:05.810 --> 00:10:09.210 
you can then replace them
with a great pixel,

127
00:10:09.980 --> 00:10:15.970 
which allows you to get an
image which is modified only

128
00:10:16.150 --> 00:10:23.060 
on red containing pixels. you can see at
the bottom the description of the thing,

129
00:10:23.620 --> 00:10:27.610 
the description of the process
of pixel manipulation.

130
00:10:28.020 --> 00:10:32.820 
so you can see it is very easy to code
and end up of gates into your FPGA.

131
00:10:33.080 --> 00:10:34.940 
once you run
the example.

132
00:10:35.690 --> 00:10:40.970 
once you already understood what you are expected
to do, so finding manipulation of the pixel,

133
00:10:41.120 --> 00:10:46.650 
accepting pixel on detecting the color
and make a decision to replace

134
00:10:46.660 --> 00:10:48.150 
or not the pixel
by great pixel

135
00:10:49.300 --> 00:10:54.570 
and computer, of course, the amont of the
grade that there is into a color pixel.

136
00:10:55.290 --> 00:10:59.630 
you can just simply make
things on this example that

137
00:10:59.630 --> 00:11:05.470 
you have set in your configuration. we
require you let's say four to five minutes,

138
00:11:05.580 --> 00:11:10.820 
you see here, I began the machine
at 21: 24 in the evening.

139
00:11:11.190 --> 00:11:15.710 
and 21:33 we get
the result.

140
00:11:16.280 --> 00:11:21.690 
so sorry 21:29, so in
five minutes will

141
00:11:21.690 --> 00:11:26.880 
exactly the third complete simulation
that is ready, if you go

142
00:11:27.130 --> 00:11:31.260 
up to the end, you would get an
terminal up in your console

143
00:11:31.450 --> 00:11:33.480 
in which you
can run the

144
00:11:34.440 --> 00:11:41.340 
image filter program software that
will manipulate an input image tiger

145
00:11:41.660 --> 00:11:44.850 
color tiger and we provide
an output tiger.

146
00:11:45.550 --> 00:11:51.220 
we often provided very smaller images to make
sure that dissemination time is reasonable.

147
00:11:52.400 --> 00:11:57.380 
once you are ok with simulation and it
does at least something, you can check

148
00:11:57.590 --> 00:12:03.920 
indicates if you need to you can run
display and this will provide you

149
00:12:04.190 --> 00:12:07.630 
a vivido
simulation view

150
00:12:08.140 --> 00:12:13.410 
that we show you exactly the
transfer of each interesting

151
00:12:13.410 --> 00:12:17.360 
net that you have into the hardware.
so you see in light of green

152
00:12:17.550 --> 00:12:19.820 
that there is some
activity on some buses,

153
00:12:20.230 --> 00:12:26.020 
for sure you would see a bus,
when the action is running.

154
00:12:26.220 --> 00:12:30.360 
so there is a light you start
signaled that you would see

155
00:12:30.510 --> 00:12:34.520 
being triggered and you can see
the exchanges. compared to the

156
00:12:34.520 --> 00:12:39.980 
content of your file, you
can check that the bytes

157
00:12:39.990 --> 00:12:43.610 
are properly exchanged and you
can check them make sure that

158
00:12:43.610 --> 00:12:47.240 
they are exchanging the right
order in the right form that

159
00:12:47.240 --> 00:12:52.020 
there is no critical
modification. and

160
00:12:52.210 --> 00:12:54.670 
the hardware does exactly what
your software is expected.

161
00:12:55.710 --> 00:12:59.980 
if you are happy with this,
you can develop a loop here

162
00:13:00.180 --> 00:13:05.430 
and if not, you can simply make a
type of image. this will provide

163
00:13:05.560 --> 00:13:10.330 
binary results into your
installation root,

164
00:13:10.790 --> 00:13:15.240 
into hardware built images you
will find the bin or bins,

165
00:13:15.240 --> 00:13:19.030 
if they are required for
some existing parts.

166
00:13:19.470 --> 00:13:23.250 
then you can just simply at
the end of make image go

167
00:13:23.250 --> 00:13:29.300 
to your power server and use ocu
tips to push this new bins

168
00:13:29.310 --> 00:13:34.030 
into the flush of the card and
at the next restart, you will

169
00:13:34.030 --> 00:13:38.790 
get the new code available. you
can check that the card is

170
00:13:38.900 --> 00:13:42.360 
present. in his
case is AD9V3

171
00:13:42.360 --> 00:13:45.270 
which is in CAPI
model present here.

172
00:13:45.810 --> 00:13:49.100 
you can check inside the card
that there is a proper code.

173
00:13:49.110 --> 00:13:52.450 
but you can't simply rely on the
code run it. and you would

174
00:13:52.450 --> 00:13:57.140 
see the tiger which would be to fold
when the pieces are containing

175
00:13:57.300 --> 00:13:58.160 
enough red.

176
00:13:59.620 --> 00:14:05.290 
another example is the
HLS copy example,

177
00:14:05.300 --> 00:14:12.070 
which contains the throughput
test into the action example

178
00:14:12.300 --> 00:14:17.360 
and test hardware throughput test
and you can estimate the benefits

179
00:14:17.650 --> 00:14:23.660 
of your choice. in his case
almost eighteen gbs useful bs

180
00:14:24.640 --> 00:14:27.240 
have been exchanged
resident.

181
00:14:27.840 --> 00:14:31.420 
make sure that you use the
proposed numactl control

182
00:14:31.930 --> 00:14:37.320 
command to conclude that the proper CPUs
that connected to the proper memory,

183
00:14:37.560 --> 00:14:42.250 
and unconnected to the FPGA to avoid
going from one processor to another.

184
00:14:44.230 --> 00:14:51.840 
hopefully we will see
an example of python,

185
00:14:51.840 --> 00:14:57.180 
in this case, it is an example which has been
provided by ibm research. and we thank

186
00:14:57.540 --> 00:14:59.830 
for this
development made.

187
00:15:00.430 --> 00:15:04.960 
so what we propose here is a library
environment that is controlled

188
00:15:04.970 --> 00:15:08.250 
to make sure that all
dependencies are under control.

189
00:15:08.710 --> 00:15:13.010 
you know the python, it is not easy to be
sure that you have the right visions.

190
00:15:13.350 --> 00:15:16.470 
so we are considering
using SWIG, CURL

191
00:15:17.090 --> 00:15:20.190 
some version of them in
a bytes environment.

192
00:15:20.680 --> 00:15:26.380 
and in this environment, you can
use python described aplication

193
00:15:26.740 --> 00:15:30.940 
which would be simply, we are using
the hello world example which

194
00:15:30.940 --> 00:15:33.960 
instead of being returning in
c, it is returning python.

195
00:15:34.410 --> 00:15:38.580 
the binary is exactly the same as
the c describe the world. so

196
00:15:38.690 --> 00:15:44.840 
you can push into the flesh memory
the exact same being at once

197
00:15:45.190 --> 00:15:47.960 
from the c described the
world and it will work.

198
00:15:48.390 --> 00:15:54.020 
you can also rebuild a binary,
it will work the same.

199
00:15:54.600 --> 00:16:00.200 
so the application will in python
be exchanged with a small

200
00:16:00.200 --> 00:16:04.920 
piece of c described interface
that talks to the hardware

201
00:16:05.220 --> 00:16:11.000 
that where we come back to the very small
thing described communication interface

202
00:16:11.220 --> 00:16:15.790 
and the python with python script
we collect the results of

203
00:16:15.790 --> 00:16:18.170 
case modification that
we propose an example.

204
00:16:18.870 --> 00:16:24.170 
you are the pointer here which will
propose you to get this example working

205
00:16:24.280 --> 00:16:28.530 
on your machine. you can also
use the jupyter notebook

206
00:16:28.940 --> 00:16:30.680 
to make your
code working.

207
00:16:32.240 --> 00:16:36.750 
let's go into the desert like a
summary of the different topics

208
00:16:36.750 --> 00:16:40.140 
we have covered in course
one and course number two.

209
00:16:40.980 --> 00:16:45.800 
so you have a CPU classical sever,
you have the classical IOs

210
00:16:46.470 --> 00:16:51.710 
at the bottom of the host memory
of the top, the application

211
00:16:51.710 --> 00:16:56.220 
is exchanging data from one word
to another, you introduce

212
00:16:56.310 --> 00:17:01.880 
an FPGA which is allowed to
directly collect and put things

213
00:17:01.880 --> 00:17:07.050 
into host memory by itself. it can
also be looked up to disk or network

214
00:17:07.410 --> 00:17:10.920 
should you have some hardware
present on your card.

215
00:17:11.840 --> 00:17:17.300 
thanks to FPGA, you can get new hardware
that is connected to your machine.

216
00:17:17.650 --> 00:17:21.690 
thanks to OpenCAPI very fast
link to the old memory

217
00:17:22.190 --> 00:17:27.100 
and thanks to OC-accel previously snap
you have a development environment

218
00:17:27.440 --> 00:17:31.550 
which allows you to directly
connect all things together.

219
00:17:31.950 --> 00:17:36.290 
should we need quick
development and time

220
00:17:37.090 --> 00:17:42.150 
when you can use HLS and with
these four ingredients

221
00:17:42.390 --> 00:17:47.820 
you have the perfect recipe to
often order accelerate using c++

222
00:17:48.030 --> 00:17:52.010 
into FPGA you have a quick
boarding time, you have a

223
00:17:52.020 --> 00:17:55.910 
minimal changing of the code, if you go to
the vision from one copy to the other.

224
00:17:56.170 --> 00:17:57.970 
and you get the
best deference.

225
00:17:58.770 --> 00:18:02.700 
then you can go back to the
full CPU application.

226
00:18:03.570 --> 00:18:07.380 
don't think that you are
obliged to run the FPGA to

227
00:18:07.380 --> 00:18:11.030 
save your blood? of course you
can. the software can trigger

228
00:18:11.550 --> 00:18:17.350 
a match into the FPGA waiting for the
result to come back, like trigger

229
00:18:17.580 --> 00:18:22.130 
of a non-compression of a video and
wait for the uncompression video

230
00:18:22.140 --> 00:18:25.470 
to be fully back into the memory
before continuing. but you

231
00:18:25.470 --> 00:18:30.170 
can also running part of one.
in this model, for example

232
00:18:30.170 --> 00:18:35.060 
an FPGA that collects a
stream of videos from

233
00:18:35.390 --> 00:18:41.510 
the cage, in this cage, it looked
up too and video is coming

234
00:18:41.510 --> 00:18:46.000 
directly inside the FPGA which
we can uncompress them and

235
00:18:46.000 --> 00:18:49.850 
decide whether that is a picture
movement or not, is the video

236
00:18:49.850 --> 00:18:53.140 
can decide by itself if to put
it into the garbage, but can

237
00:18:53.140 --> 00:18:55.880 
also decide if there is some
movement to provide up to the

238
00:18:55.880 --> 00:18:59.840 
memory and whether the system has
flags or whatever a signaling

239
00:18:59.840 --> 00:19:04.180 
that you can imagine. you can have
software code, completely parallel

240
00:19:04.350 --> 00:19:10.090 
run on the provided video at the
hardware as a feature for you.

241
00:19:10.650 --> 00:19:14.860 
so don't seem that the hardware
cannot run by itself.

242
00:19:15.740 --> 00:19:19.550 
it just needs to
be triggered.

243
00:19:20.820 --> 00:19:26.160 
so we have covered most of the
petition now. let's have a summary.

244
00:19:26.400 --> 00:19:30.040 
of different steps, you will have to go through,
if you want to do some analyzing to an FPGA,

245
00:19:30.180 --> 00:19:35.970 
first you have to isolate and naturally
reason no unwanted dependencies

246
00:19:36.070 --> 00:19:39.450 
from your piece of code that
you want to symbolize.

247
00:19:39.930 --> 00:19:45.040 
then you can simulate and the good thing to
know is that with this simulation engine,

248
00:19:45.360 --> 00:19:48.010 
you can have exactly
the same application

249
00:19:48.420 --> 00:19:54.860 
exercising your similar to the hardware, no need
into the development of the specific case

250
00:19:55.130 --> 00:19:59.280 
for your hardware. this is really a
key benefit of this technology.

251
00:19:59.580 --> 00:20:03.990 
you have the OCSE, OpenCAPI
engine, or PSLSE.

252
00:20:04.400 --> 00:20:10.940 
PSLSE engine that allows you to do the
exact simulation of future hardware.

253
00:20:11.120 --> 00:20:18.400 
once you are already, you just have to
prepare. hopefully the binary content

254
00:20:18.580 --> 00:20:21.980 
is take some time,
but it is done only

255
00:20:21.980 --> 00:20:25.920 
once at the end of the process.
the third one is easy, the

256
00:20:25.920 --> 00:20:30.190 
first one is to make snap config,
to prepare configuration.

257
00:20:30.640 --> 00:20:33.930 
the second one is mixing, the
third one is make image.

258
00:20:37.370 --> 00:20:44.170 
so as a summary, CAPI and OpenCAPI
remove hardware driver latency,

259
00:20:44.280 --> 00:20:48.440 
also a software driver latency
at the classic FPGA driver

260
00:20:48.450 --> 00:20:51.110 
generate express.

261
00:20:52.800 --> 00:20:57.270 
if you consider writing using
HLS. it's a very quick way to

262
00:20:57.270 --> 00:21:02.120 
get estimation performances
and you can which

263
00:21:02.140 --> 00:21:06.520 
also references in some cases
isolated obtain you are writing

264
00:21:07.090 --> 00:21:08.870 
HDL directly.

265
00:21:09.870 --> 00:21:15.390 
snap/oc-accel frameworks to follow the
CAPI and OpenCAPI and FPGA evolution

266
00:21:15.670 --> 00:21:19.730 
without you to change your part
of the code is very valuable.

267
00:21:20.410 --> 00:21:23.810 
everything is open source. so
it's the motivation for you to

268
00:21:23.810 --> 00:21:28.580 
contribute. you're more than
welcome to integrate units

269
00:21:28.590 --> 00:21:30.660 
into the open source
development project.

270
00:21:32.770 --> 00:21:39.230 
don't be scared to write lines. the
research has made new development

271
00:21:39.840 --> 00:21:45.430 
that is available in CAPI 2.0
vision. it was a building

272
00:21:45.440 --> 00:21:49.870 
more than three thousand lines of c code
to describe the action into the FPGA.

273
00:21:51.090 --> 00:21:55.940 
Don't forget about simulation engines are
precious tools, there are precious tools

274
00:21:56.300 --> 00:22:00.160 
to evaluate before
spending time to

275
00:22:00.500 --> 00:22:03.160 
creat or even to
buy the hardware.

276
00:22:04.320 --> 00:22:09.110 
should you need any information in support
of you, should you have any question

277
00:22:09.330 --> 00:22:13.850 
please not hesitate to contact one of
us, we are happy to make friends and

278
00:22:14.230 --> 00:22:18.320 
happy to offer you the technology
support. have a nice day! bye-bye!
