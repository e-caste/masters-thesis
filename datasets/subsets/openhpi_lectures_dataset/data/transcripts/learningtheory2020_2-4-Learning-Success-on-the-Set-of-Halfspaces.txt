WEBVTT

1
00:00:00.220 --> 00:00:04.060 
Welcome back. Today we will
prove that the learner we have

2
00:00:04.060 --> 00:00:09.360 
seen in the last video for the set of half
spaces that fits the hypothesis space

3
00:00:09.480 --> 00:00:13.750 
that we have seen in the video two
days ago is indeed successful.

4
00:00:14.420 --> 00:00:16.550 
So let us recall what
the learner is doing.

5
00:00:17.510 --> 00:00:21.500 
Ok the learner sees a label point
a positively labeled point here

6
00:00:21.810 --> 00:00:26.240 
and the negatively labeled point next
and another negatively labeled point

7
00:00:26.440 --> 00:00:29.970 
and the positively labeled
point and it sees well they

8
00:00:29.970 --> 00:00:34.450 
define two parallel lines and that
have minimal distance according

9
00:00:34.650 --> 00:00:39.340 
to the slope, namely one, so it
goes into lock state and every

10
00:00:39.340 --> 00:00:44.580 
data point it sees that is cannot
that is consistent with these

11
00:00:44.590 --> 00:00:48.080 
yeah, with these two
lines will be ignored.

12
00:00:49.200 --> 00:00:52.700 
Ok but maybe next it sees a datum
that is not consistent with

13
00:00:52.700 --> 00:00:56.020 
it because it would have been
positively labelled if these

14
00:00:56.020 --> 00:01:00.510 
two lines were correct. So we know they
are not and what the learner does is

15
00:01:00.700 --> 00:01:06.270 
it forgets these two lines
and it collects more data

16
00:01:06.280 --> 00:01:08.320 
because it knows maybe
I was not correct.

17
00:01:08.920 --> 00:01:13.010 
So it will see more data and more
data and remember all of it

18
00:01:13.170 --> 00:01:18.880 
until again it is in a lock
state. So the learner sees

19
00:01:18.880 --> 00:01:24.210 
or it defines two lines that have minimal
distance and they have an overlap

20
00:01:24.450 --> 00:01:28.210 
and the minimal distance in this
example where half the slope

21
00:01:28.290 --> 00:01:32.660 
of one half or zero point five is
one over square root of five.

22
00:01:34.320 --> 00:01:38.280 
Ok but maybe yeah so now it is
locked and it will ignore again

23
00:01:38.280 --> 00:01:41.730 
every datum that is consistent
with these dividing

24
00:01:41.880 --> 00:01:45.300 
lines. So the red line is giving
you the half space that lies

25
00:01:45.410 --> 00:01:48.770 
on the other side than the yellow
points the negatively labeled points.

26
00:01:49.280 --> 00:01:53.620 
So maybe this datum is seen after
some data that has been ignored

27
00:01:53.650 --> 00:01:59.480 
and it is again not consistent. So the learner
will unlock again, collect more data

28
00:01:59.660 --> 00:02:04.710 
until it sees well I am again
in a locking state. So again

29
00:02:04.880 --> 00:02:08.830 
two line segments that define
two lines that are of minimal

30
00:02:08.830 --> 00:02:10.540 
distance and
they overlap.

31
00:02:11.260 --> 00:02:15.010 
In our example this was indeed
the half-space we wanted to

32
00:02:15.010 --> 00:02:20.700 
learn. So all further data will be
ignored and this is the result

33
00:02:20.710 --> 00:02:21.890 
of the learning
process.

34
00:02:22.750 --> 00:02:27.440 
But why does the work for every half
space? I mean this is an example.

35
00:02:27.560 --> 00:02:30.380 
So we have to argue a bit
to show that it is true.

36
00:02:34.330 --> 00:02:39.480 
Ok so the first argument why it is
correct is that the distances

37
00:02:39.510 --> 00:02:42.950 
as you have seen in the example
already, they decrease. So

38
00:02:42.950 --> 00:02:46.950 
let's look at it again. So first we
switched from one distance one

39
00:02:47.300 --> 00:02:51.520 
to one over the square root of
five and in the next step

40
00:02:51.970 --> 00:02:55.570 
we even came down to one over
square root of thirteen.

41
00:02:56.350 --> 00:03:02.270 
So yeah this is a very
important thing

42
00:03:02.270 --> 00:03:05.350 
to notice and will be
helpful later on.

43
00:03:07.940 --> 00:03:13.690 
Ok so what is also important is that there
can be only finitely many half spaces

44
00:03:13.790 --> 00:03:17.620 
that have this locked property
that we defined which means

45
00:03:17.630 --> 00:03:22.010 
as you have already seen also in the
example again that the two line segments

46
00:03:22.160 --> 00:03:26.130 
they have the same slope
and they overlap and they

47
00:03:26.130 --> 00:03:27.520 
are of minimal
distance.

48
00:03:28.270 --> 00:03:32.340 
Ok so we have a half space
now that is given by b0, b1

49
00:03:32.340 --> 00:03:38.190 
and b2 integer, three integers
that define the half-space and

50
00:03:38.870 --> 00:03:43.590 
the first thing to notice is that we can
always find three other integers -

51
00:03:43.720 --> 00:03:48.530 
a0, a1 and a2 that have the
property that the greatest

52
00:03:48.530 --> 00:03:50.920 
common divisor of
a1 and a2 is one

53
00:03:51.630 --> 00:03:54.090 
and they justify the
same half spaces.

54
00:03:54.860 --> 00:04:01.120 
Well how do we do that? We just look at the
defining inequality for the half-space

55
00:04:01.350 --> 00:04:04.520 
and divide it by the greatest
common divisor of b1 and b2,

56
00:04:05.330 --> 00:04:09.280 
then we obtain because the
greatest common divisor divides

57
00:04:09.280 --> 00:04:13.330 
b1 and b2 again two
elements of the integers

58
00:04:13.790 --> 00:04:17.870 
and yeah and because we know
that there is an integer

59
00:04:17.870 --> 00:04:22.300 
point that lies on the line defining
our half-space we also obtain

60
00:04:22.450 --> 00:04:26.480 
that b0 divided by this b is
an integer and this is all

61
00:04:26.480 --> 00:04:31.160 
we needed because now we have
a1, a2 and a0, three integers

62
00:04:31.320 --> 00:04:35.820 
that just define the same inequality
because we divided by a number b

63
00:04:35.960 --> 00:04:39.660 
which will not change whether
this inequality is true or not.

64
00:04:41.130 --> 00:04:44.890 
This is a nice first observation and
the second important observation

65
00:04:45.020 --> 00:04:50.180 
to see that only finitely many half
spaces satisfy this lock property

66
00:04:50.380 --> 00:04:55.430 
with regard to a prefixed half
space that we want to learn

67
00:04:55.690 --> 00:04:59.740 
is if we have two
integers a1 and a2

68
00:05:00.230 --> 00:05:04.350 
with this property that we just
showed we can assume named

69
00:05:04.350 --> 00:05:07.740 
that the greatest common
divisor of a1 and a1 is one.

70
00:05:08.840 --> 00:05:15.030 
Then the minimal distance that can be
achieved by a line or by two lines

71
00:05:15.150 --> 00:05:20.780 
with a normal vector a1 a2 um
yeah is given by one over

72
00:05:20.950 --> 00:05:26.190 
the square root of a1 squared plus
a2 squared which is the norm

73
00:05:26.410 --> 00:05:34.060 
of this vector. Ok we will
not prove that, but if you

74
00:05:34.230 --> 00:05:37.960 
if you are interested you can
look in the hand out and also

75
00:05:37.970 --> 00:05:41.570 
basically the main argument what
you can verify yourself when

76
00:05:41.570 --> 00:05:45.970 
you draw some examples on a
piece of paper and of course

77
00:05:45.970 --> 00:05:49.060 
you can rigorously prove it and
if you want to know how it

78
00:05:49.060 --> 00:05:52.430 
is done because yeah you
don't make progress then

79
00:05:52.430 --> 00:05:57.200 
please look into the hand out. So at
the first thing you should try to

80
00:05:57.360 --> 00:06:02.900 
try to prove or try to convince yourself
of is that the minimal distances

81
00:06:03.130 --> 00:06:07.680 
in vertical and horizontal
direction are given by

82
00:06:07.690 --> 00:06:12.050 
one over a1 and one over a2.
So one over a1 horizontally

83
00:06:12.060 --> 00:06:16.190 
and one over a2 vertically and
with this you can derive

84
00:06:16.190 --> 00:06:20.270 
that the minimal distance is
indeed one over the norm of a

85
00:06:20.550 --> 00:06:22.080 
the normal
vector a1 a2,

86
00:06:26.770 --> 00:06:32.240 
So what have we seen? We have seen that
this distance can indeed be computed

87
00:06:32.380 --> 00:06:36.760 
by a function and this function,
well, this helps us now to show

88
00:06:36.760 --> 00:06:41.050 
that only finitely many half spaces
have this lock property because

89
00:06:41.060 --> 00:06:44.290 
if the half space we want to learn
corresponds in our example

90
00:06:44.550 --> 00:06:48.390 
to two and three
as a1 and a2

91
00:06:48.850 --> 00:06:54.840 
then all half spaces that we can
have in the learning process

92
00:06:55.060 --> 00:07:00.020 
beforehand have to lie in the circle
because every time we change our mind

93
00:07:00.250 --> 00:07:05.120 
this minimal distance will
strictly decrease. But it can

94
00:07:05.320 --> 00:07:07.250 
never be lower than
the true one

95
00:07:08.710 --> 00:07:13.160 
and there are only these finitely
many possibilities of choices

96
00:07:13.160 --> 00:07:16.900 
for a1 and a2 that have the
property that they are

97
00:07:16.900 --> 00:07:20.840 
not too large and hence cannot occur
at all in the learning process.

98
00:07:23.540 --> 00:07:27.490 
Ok so we have finitely many
options and every time we change

99
00:07:27.490 --> 00:07:32.210 
we have to decrease. But this
means that at some point we

100
00:07:32.210 --> 00:07:36.820 
just have to be, yeah, we just have
to reach the right half space.

101
00:07:37.890 --> 00:07:42.860 
Just a note on the side is that once the
learner has decided for a quadrant

102
00:07:43.400 --> 00:07:45.590 
then it will stay in
that one forever.

103
00:07:48.330 --> 00:07:52.940 
Ok another thing that one should keep
in mind in order to be convinced

104
00:07:53.110 --> 00:07:57.470 
that the learner truly does what
it should is uh that it indeed

105
00:07:57.480 --> 00:08:03.340 
does reach a correct lock state so it is not
forever collecting points for example.

106
00:08:05.180 --> 00:08:08.330 
So let us look at the learning
process again at our example

107
00:08:08.330 --> 00:08:11.630 
learning process, just
a bit yeah, zoomed

108
00:08:12.030 --> 00:08:17.680 
out. Ok so this is again
the first lock state

109
00:08:18.830 --> 00:08:22.480 
then this data point is ignored,
then this comes in it is unlocked,

110
00:08:22.480 --> 00:08:25.500 
it collects more data, then
it is locking again.

111
00:08:26.300 --> 00:08:31.390 
Ok for example in this locking
state all yellow points above

112
00:08:31.400 --> 00:08:34.990 
the line defined by the yellow
line segment will be ignored

113
00:08:35.700 --> 00:08:40.870 
and all red points below the
line segment defined by the

114
00:08:40.880 --> 00:08:44.690 
below the line defined by the red
line segment will also be ignored.

115
00:08:44.800 --> 00:08:50.040 
But we ignore only finitely many points
and there are infinitely many of them.

116
00:08:50.370 --> 00:08:54.470 
So whenever we see
another data point

117
00:08:55.350 --> 00:09:00.190 
and we unlock we can be sure that we
will also see other data points

118
00:09:00.430 --> 00:09:06.420 
that are even on the side that we might
have excluded finitely many already.

119
00:09:06.910 --> 00:09:12.020 
So we will not lose for example
this yellow data point

120
00:09:12.030 --> 00:09:15.650 
even if it was lost we would
not have lost one that is far

121
00:09:15.650 --> 00:09:17.250 
above it on the
yellow line.

122
00:09:20.320 --> 00:09:25.470 
Ok so finally we will see
two points on the red line

123
00:09:25.480 --> 00:09:30.440 
and two points on the yellow line
that we have not forgotten that are

124
00:09:30.680 --> 00:09:35.750 
and that satisfy the lock property.
So, yeah, so they overlap and

125
00:09:35.750 --> 00:09:39.480 
they are of minimal distance. And
after that the learner will

126
00:09:39.490 --> 00:09:43.250 
only see data that is consistent
because it has already found

127
00:09:43.400 --> 00:09:46.750 
the right half space and then it
will not change its mind anymore.

128
00:09:47.640 --> 00:09:50.530 
So it has converged and the
learner is successful.

129
00:09:52.570 --> 00:09:56.960 
Yes so the properties that we
collected that we argued we have is

130
00:09:57.090 --> 00:10:01.720 
first of all the distances corresponding to
the lock state are strictly decreasing.

131
00:10:02.720 --> 00:10:06.230 
Second is the learner has only
finite options for lock states

132
00:10:06.270 --> 00:10:09.870 
and as a distance is decreasing
has to reach the right one

133
00:10:10.000 --> 00:10:15.210 
if it reaches one at all
after finite many steps and

134
00:10:15.210 --> 00:10:20.150 
then we argue that it has
indeed no chance of avoiding

135
00:10:20.150 --> 00:10:24.080 
the correct lock state because it
can only forget finitely many data

136
00:10:24.210 --> 00:10:28.230 
but there is infinitely many data
that corresponds to lock states.

137
00:10:29.070 --> 00:10:33.060 
And so we proved finally that
the set of half spaces can be

138
00:10:33.060 --> 00:10:34.970 
learned by a mini
batch learner.

139
00:10:36.340 --> 00:10:40.360 
And now we have seen that a set
of half-spaces is learnable

140
00:10:40.360 --> 00:10:45.600 
by a full information learner and by a
mini-batch learner. So the question arises

141
00:10:46.060 --> 00:10:50.110 
are mini batch learners as powerful
as full batch learners? I will

142
00:10:50.110 --> 00:10:51.760 
discuss this in
the next video.
