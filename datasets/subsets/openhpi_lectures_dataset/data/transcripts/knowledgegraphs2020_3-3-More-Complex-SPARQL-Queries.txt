WEBVTT

1
00:00:00.870 --> 00:00:05.630 
Welcome to knowledge graphs, lecture
three querying rdfs with SPARQL.

2
00:00:05.960 --> 00:00:10.350 
In this lecture we are going to talk
about more complex SPARQL queries

3
00:00:11.060 --> 00:00:17.370 
and then we are still on the layer of SPARQL
in the semantic web technology stack.

4
00:00:19.320 --> 00:00:23.200 
So let us consider a situation
where you do not have all the

5
00:00:23.200 --> 00:00:27.480 
information present only on one
dataset. You want to combine

6
00:00:27.480 --> 00:00:31.660 
information from two several data
set. What do you do in that case?

7
00:00:31.910 --> 00:00:34.520 
So let us consider an
example for this.

8
00:00:35.810 --> 00:00:37.210 
If you are looking for

9
00:00:38.520 --> 00:00:44.820 
the fact which mountaineers died on mount
everest ordered by their death date.

10
00:00:45.710 --> 00:00:47.890 
So this information
is given

11
00:00:48.590 --> 00:00:53.820 
through dbpedia category in dbpedia
with the help of the category

12
00:00:53.820 --> 00:00:56.470 
mountaineering deaths
on mount everest.

13
00:00:57.400 --> 00:01:03.560 
And then the items connected to it are
actually those mountaineers who died there.

14
00:01:04.510 --> 00:01:09.420 
Now the point is what if you are also
looking for the death date and this

15
00:01:09.890 --> 00:01:12.640 
information is not present
in that data set?

16
00:01:13.130 --> 00:01:18.650 
So to get this information you
can try to query two data sets

17
00:01:18.650 --> 00:01:22.910 
at the same time. How do you do
that? You do it with the help

18
00:01:22.910 --> 00:01:26.530 
of federated queries. So here for
example on wikidata you can

19
00:01:26.530 --> 00:01:30.780 
find the information about
the death or the death date.

20
00:01:32.510 --> 00:01:37.470 
So how do you do these federated
queries? So we do this

21
00:01:37.470 --> 00:01:41.850 
with the help of the service a
service keyboard. So here you

22
00:01:41.850 --> 00:01:46.370 
can actually see that there is a
service keyword in red which

23
00:01:46.370 --> 00:01:49.430 
is pointing to the dbpedia
SPARQL end point

24
00:01:50.020 --> 00:01:53.320 
and then there is another service
keyword in blue which is

25
00:01:53.320 --> 00:01:57.450 
pointing to the
wikidata SPARQL end point.

26
00:01:58.150 --> 00:02:03.940 
And then these queries are only
possible if a SPARQL end point is

27
00:02:04.060 --> 00:02:06.460 
actually allows this
to happen. Sorry.

28
00:02:07.370 --> 00:02:11.050 
And then, so let's see
how do we run this query

29
00:02:11.700 --> 00:02:16.070 
on the wikidata SPARQL end point.
So here is the information,

30
00:02:16.080 --> 00:02:19.190 
this is the query that I have
just explained which is getting

31
00:02:19.190 --> 00:02:22.030 
data from dbpedia as
well as wikidata.

32
00:02:23.050 --> 00:02:25.760 
So let's try to run this
query. We have this

33
00:02:26.770 --> 00:02:31.080 
results from this query. Now let
us try to visualize this result

34
00:02:31.080 --> 00:02:34.240 
in the form of the timeline.
So for doing that,

35
00:02:35.520 --> 00:02:39.030 
we can simply
write hashtag

36
00:02:40.690 --> 00:02:43.560 
timeline and let's run
this query again.

37
00:02:45.350 --> 00:02:48.970 
Now here we get the nice
visualization with the answers to

38
00:02:48.970 --> 00:02:52.420 
the query that we just posed on
the SPARQL end point coming

39
00:02:52.420 --> 00:02:54.730 
from dbpedia as well
as wikidata.

40
00:02:59.740 --> 00:03:02.100 
So here is the snapshot
of the answers that

41
00:03:02.830 --> 00:03:04.080 
we saw just before.

42
00:03:05.980 --> 00:03:11.100 
So there are many more many more
kind of clauses

43
00:03:11.110 --> 00:03:14.970 
the keywords that you can use in
SPARQL. So for example now

44
00:03:14.980 --> 00:03:20.160 
we are looking for authors with their
notable works and date of publications

45
00:03:20.350 --> 00:03:26.430 
ordered by year. So here in this
case we would use the bind

46
00:03:26.890 --> 00:03:32.080 
keyword. So the binary form allows
a value to be assigned to a variable.

47
00:03:32.340 --> 00:03:36.960 
So here in this query we
are taking out the publication

48
00:03:36.960 --> 00:03:41.280 
dates of the books and then we
are converting them to years

49
00:03:41.290 --> 00:03:47.240 
with the help of year and then
we are only looking for those

50
00:03:47.490 --> 00:03:50.840 
books for which we have the
information about the year.

51
00:03:51.350 --> 00:03:53.360 
So which is given
by the word bound.

52
00:03:53.980 --> 00:03:59.180 
So here we are binding a
new variable year to

53
00:04:00.250 --> 00:04:02.570 
the answer coming
from year date.

54
00:04:03.780 --> 00:04:09.270 
Now if you want to run this SPARQL query
online on the wikidata SPARQL endpoint

55
00:04:09.770 --> 00:04:15.050 
let us click on this link and then we
have the query that I just explained.

56
00:04:16.240 --> 00:04:20.230 
And then you obtain the results
of the labels of the author,

57
00:04:20.230 --> 00:04:24.430 
or the book labels, the books and
the authors and their IDs.

58
00:04:31.550 --> 00:04:36.330 
So this is the snapshot of the
query that you just saw before.

59
00:04:36.330 --> 00:04:40.370 
Here you can actually in the other
screen somehow the year was hidden.

60
00:04:40.690 --> 00:04:44.430 
So here you can actually see that
your information is on the right side.

61
00:04:46.600 --> 00:04:50.500 
So now let us talk about more
aggregate functions. So if we

62
00:04:50.500 --> 00:04:55.780 
are looking for how many authors
are there and how many notable

63
00:04:55.780 --> 00:04:59.200 
works. So this is sort of summarizing
everything that is in

64
00:04:59.200 --> 00:05:03.880 
dbpedia about the authors and the
notable notable works. For doing so

65
00:05:04.170 --> 00:05:09.560 
we use count, so counting is
this is an aggregate function

66
00:05:09.560 --> 00:05:13.340 
which counts the number of times
a given expression has a bound.

67
00:05:14.000 --> 00:05:19.450 
And then there is count distinct which
counts each of the author only one time.

68
00:05:20.280 --> 00:05:24.500 
So the distinct keyword is used for
this for this reason. Now let's

69
00:05:24.500 --> 00:05:27.410 
try to run this query over
this SPARQL endpoint.

70
00:05:30.050 --> 00:05:33.510 
So here you see we have the
same query that we just saw.

71
00:05:34.320 --> 00:05:36.070 
I will try to
run this query

72
00:05:36.840 --> 00:05:41.670 
and then we have total number
of books and the author count

73
00:05:41.970 --> 00:05:43.420 
as the answer
to this query.

74
00:05:45.410 --> 00:05:51.450 
We have more aggregate functions such as
some average min-max and the sample.

75
00:05:53.080 --> 00:05:56.460 
You will see their details in a
little bit, in a little while.

76
00:05:57.540 --> 00:06:01.770 
So let us consider now we are
looking for which author wrote

77
00:06:01.770 --> 00:06:06.110 
how many notable works. So in this
or in this case we want to

78
00:06:06.680 --> 00:06:10.920 
divide the solution into groups.
For doing that we use the group

79
00:06:10.920 --> 00:06:16.800 
by information and then we aggregate function,
then we use the aggregate function

80
00:06:17.050 --> 00:06:21.100 
which calculates for each of
these groups, which calculates

81
00:06:21.100 --> 00:06:25.410 
the book count for each of these
groups. So here we have our

82
00:06:25.410 --> 00:06:28.980 
two aggregate functions in the
red that you see and now let's

83
00:06:28.980 --> 00:06:32.070 
try to run the query over
the SPARQL end point.

84
00:06:38.610 --> 00:06:41.900 
So here we are retrieving all
the books which have the label

85
00:06:42.040 --> 00:06:44.420 
label only
in english.

86
00:06:46.530 --> 00:06:50.320 
And then we should be able to get
the number of books written

87
00:06:50.320 --> 00:06:55.740 
by each of these authors, for
example Thomas Mann is fifty seven.

88
00:07:01.020 --> 00:07:05.010 
So now we will talk about the
aggregate functions which are

89
00:07:05.090 --> 00:07:08.170 
more aggregate functions which are
there. So we have some average

90
00:07:08.170 --> 00:07:13.370 
min and max which are actually fairly
already explainable through their titles.

91
00:07:13.680 --> 00:07:18.080 
Then we have another aggregate
function called the sample so it

92
00:07:18.230 --> 00:07:24.280 
it picks one answer non
deterministically and

93
00:07:24.280 --> 00:07:28.320 
then we have a group concat
which actually concatenates

94
00:07:28.430 --> 00:07:32.900 
the several others pieces of
string into a one long string.

95
00:07:35.630 --> 00:07:40.750 
So in the next lecture you will see more
details on SPARQL subqueries and

96
00:07:40.860 --> 00:07:42.110 
the property paths.
