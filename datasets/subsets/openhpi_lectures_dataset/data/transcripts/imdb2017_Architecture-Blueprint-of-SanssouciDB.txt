WEBVTT

1
00:00:00.400 --> 00:00:06.100 
Ok lets jump fast forward
and look how the system is

2
00:00:06.100 --> 00:00:14.180 
organized. This is the lay
out of the database system.

3
00:00:16.200 --> 00:00:22.260 
We store data in different areas
and I just introduce you to

4
00:00:22.260 --> 00:00:23.270 
the different areas.

5
00:00:25.290 --> 00:00:33.370 
We start with the main, the main
store, we heard we store data

6
00:00:33.370 --> 00:00:36.400 
instead of in records
we store it in columns.

7
00:00:36.400 --> 00:00:38.420 
We just look at the
transition a little bit later.

8
00:00:39.430 --> 00:00:44.480 
And we have dictionaries
we store the data in

9
00:00:45.490 --> 00:00:49.530 
an encoded form, in integer
form, and with the help

10
00:00:49.530 --> 00:00:55.590 
of a dictionary. We
have still indices

11
00:00:56.600 --> 00:01:01.650 
we have only a few indices left,
we still need a primary index

12
00:01:01.650 --> 00:01:05.690 
and probably we need something
like a secondary index.

13
00:01:06.700 --> 00:01:09.730 
We know from the normal
relational databases

14
00:01:09.730 --> 00:01:13.770 
but the number of
indices in the database

15
00:01:13.770 --> 00:01:19.830 
goes down dramatically because
using the attribute vectors

16
00:01:19.830 --> 00:01:23.870 
as index is nearly as good
as the database normally.

17
00:01:24.880 --> 00:01:27.910 
Working on an index,
only a sorted index.

18
00:01:27.910 --> 00:01:32.960 
With the binary tree can be
faster for direct access.

19
00:01:33.970 --> 00:01:37.101 
Anything when we do range
select our sequential

20
00:01:37.101 --> 00:01:40.104 
attribute of the sequential
processing through the attribute

21
00:01:40.104 --> 00:01:42.106 
vectors totally
equivalent.

22
00:01:47.111 --> 00:01:51.115 
So this is where
we store data we

23
00:01:52.116 --> 00:01:57.121 
ignore the delta at the moment, the
downside of a sorted dictionary is

24
00:01:59.123 --> 00:02:02.126 
why we add, when we
add more and more data

25
00:02:03.127 --> 00:02:06.130 
we have to we have to
change the dictionary.

26
00:02:07.131 --> 00:02:10.134 
If we change the dictionary,
we have to start maintaining

27
00:02:11.135 --> 00:02:19.143 
the main storage area. The sorted
dictionary is so positive because

28
00:02:19.143 --> 00:02:24.148 
it's so fast, so the early
builders of that system decided

29
00:02:25.149 --> 00:02:30.154 
to split the main storage area
in two main and the delta.

30
00:02:32.156 --> 00:02:38.162 
All new entries go into a delta
and the dictionary in the delta

31
00:02:38.162 --> 00:02:43.167 
is not sorted. That means
it just will be added

32
00:02:43.167 --> 00:02:46.170 
it is slower then the dictionary
look up, is clearly slower

33
00:02:46.170 --> 00:02:50.174 
it is a scan and
not a direct access.

34
00:02:51.175 --> 00:02:55.179 
But if we keep this relatively
small, then we can deal

35
00:02:55.179 --> 00:03:01.185 
with the slowlyness of
the the delta store.

36
00:03:01.185 --> 00:03:05.189 
On a periodic base the
delta will be merged

37
00:03:05.189 --> 00:03:11.195 
into the main, Jens is
a merge expert so...

38
00:03:12.196 --> 00:03:15.199 
what about our transactional
data, once a day (we do) a merge?

39
00:03:15.199 --> 00:03:18.202 
or several times a
day, do you know?

40
00:03:20.204 --> 00:03:24.208 
Yeah it depends on the size of
a table and depends on ... but,

41
00:03:28.212 --> 00:03:30.214 
once a day, once a day,
just just for a feeling.

42
00:03:31.215 --> 00:03:35.219 
So once a day we merge table,
if nothing happened in the

43
00:03:35.219 --> 00:03:36.220 
table then
there's no merge

44
00:03:39.223 --> 00:03:44.228 
and if there's only one change
and probably that is even not,

45
00:03:44.228 --> 00:03:48.232 
so it this has to trigger,
some information has to trigger

46
00:03:48.232 --> 00:03:52.236 
and it's obviously the merge
process and it's obviously

47
00:03:52.236 --> 00:03:56.240 
based on number of entries,
size of the table, etc. etc.

48
00:04:00.244 --> 00:04:05.249 
And then we can define
which data should be in this

49
00:04:05.249 --> 00:04:10.254 
called hot store, this is the
data as an application definition

50
00:04:11.255 --> 00:04:15.259 
this is a data we really need
for conducting the business.

51
00:04:16.260 --> 00:04:19.263 
So what is a doesn't
sound very precise

52
00:04:19.263 --> 00:04:21.265 
but you can
derive from that

53
00:04:23.267 --> 00:04:28.000 
to conduct the business everything
which has to do with update

54
00:04:28.000 --> 00:04:32.276 
we change something we
create new data. This is

55
00:04:33.277 --> 00:04:39.283 
invoicing, this is moving
stock, this is closing

56
00:04:39.283 --> 00:04:43.287 
the books for a period
has to be in hot store

57
00:04:44.288 --> 00:04:47.291 
and we can write from that, I don't
want to go into the definition

58
00:04:47.291 --> 00:04:51.295 
of hot and cold too much more,
it is what we need to conduct

59
00:04:51.295 --> 00:04:54.298 
the business during a
year, it's my definition.

60
00:04:54.298 --> 00:04:57.301 
It could be a month, it could
be a quarter year is good I

61
00:04:57.301 --> 00:05:01.305 
think so everything which is
necessary to conduct the business

62
00:05:01.305 --> 00:05:05.309 
regardless what
application area we need

63
00:05:06.310 --> 00:05:10.314 
during the year and closing
a year has to be in here.

64
00:05:11.315 --> 00:05:14.318 
Everything which has
taken place already

65
00:05:15.319 --> 00:05:19.323 
and is not necessary for
to fulfill this definition

66
00:05:19.323 --> 00:05:21.325 
can be in cold store.

67
00:05:23.327 --> 00:05:24.328 
So an invoice,

68
00:05:27.331 --> 00:05:30.334 
an order we got last year,
we shipped last year,

69
00:05:32.336 --> 00:05:36.340 
we invoiced last year, the
customer paid last year,

70
00:05:38.342 --> 00:05:43.347 
and we closed last year already,
does not have to be here not store.

71
00:05:45.349 --> 00:05:48.352 
So this definition has to be
broken down from the business

72
00:05:48.352 --> 00:05:54.358 
object, obviously due to the
tables since we have dramatically

73
00:05:54.358 --> 00:05:59.363 
reduced the tables for the first
time in the history at least

74
00:06:00.364 --> 00:06:04.368 
as as far as i know SAP and the
direct competitors we can introduce

75
00:06:04.368 --> 00:06:08.372 
the hot and cold store concept
for transaction processing

76
00:06:10.374 --> 00:06:14.378 
remember the aggregates
and and all the

77
00:06:14.378 --> 00:06:17.381 
the the materialized views
is much more difficult

78
00:06:17.381 --> 00:06:22.386 
the reorganization problem
exponentially grows.

79
00:06:22.386 --> 00:06:25.389 
So we never have tried
this, now we can do this

80
00:06:27.391 --> 00:06:33.397 
we split in hot data, defined
by business definitions and

81
00:06:33.397 --> 00:06:37.401 
into cold data. Cold data per
definition can not be changed

82
00:06:37.401 --> 00:06:41.405 
anymore. As long as an
order is not fully shipped,

83
00:06:43.407 --> 00:06:46.410 
if there is probably a dispute
pending, something like that

84
00:06:47.411 --> 00:06:52.416 
it stays here. If it's fully done
and processed and that is decided

85
00:06:52.416 --> 00:06:55.419 
by the application, it
goes here goes here.

86
00:06:55.419 --> 00:06:59.423 
This transfer takes place
once a year, most likely,

87
00:07:00.424 --> 00:07:05.429 
probably twice a year but not
more. So we have a daily move

88
00:07:05.429 --> 00:07:09.433 
from delta to main and
we have a yearly move

89
00:07:10.434 --> 00:07:12.436 
from main to cold store.

90
00:07:15.439 --> 00:07:20.444 
This has performance
implications without losing any,

91
00:07:21.445 --> 00:07:25.449 
any information because the
database thinks this is all my

92
00:07:25.449 --> 00:07:28.452 
storage and the database
knows a table is,

93
00:07:29.453 --> 00:07:32.456 
entries for a table can be here,
can be here, can be her,e can

94
00:07:32.456 --> 00:07:36.460 
be here. If you want to read all
data and then we have to read

95
00:07:36.460 --> 00:07:42.466 
all stores. The database
does that, they are disjunct

96
00:07:42.466 --> 00:07:47.471 
they can just be added
up. Actually if these

97
00:07:47.471 --> 00:07:53.477 
storage areas reside on different
computers, separate computers

98
00:07:53.477 --> 00:07:56.480 
then we get a parallelism in these
computers, people will do this.

99
00:08:01.485 --> 00:08:08.000 
For a, it is at the moment
an analytic system only for

100
00:08:08.000 --> 00:08:12.496 
point of sales data at Walmart.
Walmart is having 16 of

101
00:08:12.496 --> 00:08:15.499 
these stores. Is
that correct or more?

102
00:08:18.502 --> 00:08:22.506 
16, I think it's
16 and they keep

103
00:08:24.508 --> 00:08:28.512 
300 billion, 300 billion
point of sales records.

104
00:08:32.516 --> 00:08:33.517 
Pretty big business.

105
00:08:35.519 --> 00:08:38.522 
If you had asked me 40 years
ago that this is technically

106
00:08:38.522 --> 00:08:45.529 
possible, this is. We
fly to any moon of Saturn

107
00:08:45.529 --> 00:08:48.532 
and back and live there, that
happens before this happens.

108
00:08:54.538 --> 00:09:00.544 
So this is the data
storage and now, we have a

109
00:09:00.544 --> 00:09:04.548 
few tricks, but they're
all also known and used in

110
00:09:04.548 --> 00:09:08.552 
other databases,
like Vertica before.

111
00:09:09.000 --> 00:09:13.557 
We said not only
do we have a delta,

112
00:09:13.557 --> 00:09:17.561 
when we update data and data we
update can only be here or here

113
00:09:18.562 --> 00:09:21.565 
because it cannot be here,
because it's not allowed to update

114
00:09:21.565 --> 00:09:25.569 
this data. That is only in
emergency process we don't have to

115
00:09:25.569 --> 00:09:32.576 
discuss here. Then we do insert
only, we move the old tuple to

116
00:09:32.576 --> 00:09:35.579 
a history area and put
the new one and the delta

117
00:09:36.580 --> 00:09:41.585 
and mark the old one here as
invalid, this is how we do an update.

118
00:09:41.585 --> 00:09:44.588 
So the little flag here,
it's an insert here

119
00:09:45.589 --> 00:09:48.592 
and it's a move from here to
here, so it's an insert in the

120
00:09:48.592 --> 00:09:52.596 
history. With that we can do
things like time travel, we can

121
00:09:52.596 --> 00:09:56.600 
go backwards in the history of
each table and can reconstruct

122
00:09:56.600 --> 00:10:00.604 
how would table look
like, for example 31

123
00:10:00.604 --> 00:10:06.610 
of May. Which we cannot do in
today's application, we, SAP

124
00:10:06.610 --> 00:10:09.613 
has a, when when I say we,
SAP not built the application

125
00:10:09.613 --> 00:10:14.618 
in a way to do that. In some
applications where this is necessary

126
00:10:14.618 --> 00:10:18.622 
could be HR and others are
where we have to go backwards

127
00:10:18.622 --> 00:10:22.626 
in time from time to
time. The application has

128
00:10:22.626 --> 00:10:26.630 
built this and now we can do
this with database support is

129
00:10:26.630 --> 00:10:29.633 
a standard feature of the
database to do time-travel.

130
00:10:33.637 --> 00:10:38.642 
Any kind of insert operation or
update operation as described

131
00:10:38.642 --> 00:10:44.648 
will be logged and will be
in a if persistent storage

132
00:10:44.648 --> 00:10:48.652 
in order to be able
to restart a system,

133
00:10:49.653 --> 00:10:54.658 
to recreate a system, to
repair a system, etc. So it's

134
00:10:54.658 --> 00:10:57.661 
very traditional here,
like any other database

135
00:10:58.662 --> 00:11:02.666 
it's not a big difference.
Snapshots and logs are

136
00:11:02.666 --> 00:11:07.671 
basically checkpoints,
snapshots and logs are basically

137
00:11:07.671 --> 00:11:13.677 
keeping the history of the
database and the changes

138
00:11:13.677 --> 00:11:18.682 
of the database in persistent
storage. And on top of that, we

139
00:11:18.682 --> 00:11:24.688 
have pretty, here, pretty much the
same what any relational database

140
00:11:24.688 --> 00:11:29.693 
as an SQL interface. We
have stored procedures

141
00:11:29.693 --> 00:11:33.697 
if somebody knows SAP,
you might have seen that

142
00:11:33.697 --> 00:11:37.701 
we have not use stored procedures
nearly at all in the past.

143
00:11:37.701 --> 00:11:41.705 
SAP, since SAP
decided in the early

144
00:11:41.705 --> 00:11:45.709 
90's to run on multiple
relational databases and they all

145
00:11:45.709 --> 00:11:50.714 
have different,
different forms of stored

146
00:11:50.714 --> 00:11:54.718 
procedures, a language is
different and I don't know whether

147
00:11:54.718 --> 00:11:59.723 
it's really true but some lawyers
said we cannot build cross

148
00:11:59.723 --> 00:12:05.729 
compilers from ibm store procedures
to oracle stored procedures

149
00:12:05.729 --> 00:12:09.733 
etc. for legal reasons so we
decided not to use store procedures.

150
00:12:09.733 --> 00:12:15.739 
Which was twenty years ago, okay,
ten years ago not. Now it is

151
00:12:15.739 --> 00:12:22.746 
wrong. Anything which can work
inside this database and produce

152
00:12:23.747 --> 00:12:26.750 
or let the algorithm
run inside here and

153
00:12:26.750 --> 00:12:30.754 
not go back and forth between an
application here and the database

154
00:12:31.000 --> 00:12:33.757 
doesn't go through this
layer here and these

155
00:12:33.757 --> 00:12:38.762 
layers, which is expensive. So
the more you can give the database

156
00:12:38.762 --> 00:12:42.766 
an order and the database runs
the order with help of stored

157
00:12:42.766 --> 00:12:47.771 
procedures inside, it's good for
performance, it's good for simplicity

158
00:12:47.771 --> 00:12:49.773 
of the application etc.
