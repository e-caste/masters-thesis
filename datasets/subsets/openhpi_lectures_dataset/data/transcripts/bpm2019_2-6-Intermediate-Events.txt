WEBVTT

1
00:00:00.490 --> 00:00:05.020 
Welcome to video clip 2.6 in which
we discuss intermediate events.

2
00:00:06.540 --> 00:00:11.090 
So intermediate events as already
discussed in the previous video clip

3
00:00:11.370 --> 00:00:16.040 
happen after the start of the business
process and before its termination.

4
00:00:16.790 --> 00:00:20.770 
Intermediate events can be
both catching and throwing,

5
00:00:21.260 --> 00:00:23.850 
not at the same time but there
can be intermediate events of

6
00:00:23.850 --> 00:00:28.140 
the catching nature and immediate
events of the throwing nature.

7
00:00:28.520 --> 00:00:33.050 
Catching means the process waits for the
occurrance of the event, throwing means

8
00:00:33.400 --> 00:00:37.730 
the process emits the event and continues
with the outgoing sequence flow.

9
00:00:38.940 --> 00:00:41.940 
An intermediate event can be
connected to other nodes of a

10
00:00:41.940 --> 00:00:46.350 
process model by incoming and
outgoing sequel flow arcs

11
00:00:46.350 --> 00:00:50.460 
just like activities or other
nodes of process models.

12
00:00:53.010 --> 00:00:55.870 
Looking at the application
scenario and expanding a little

13
00:00:55.870 --> 00:00:59.030 
bit on the application scenario
if the order is placed on a

14
00:00:59.030 --> 00:01:03.250 
friday or on a weekend the
inventory check shall be delayed

15
00:01:03.250 --> 00:01:07.240 
until monday as the inventory is
updated every sunday evening.

16
00:01:08.730 --> 00:01:12.170 
So here we have another
constraint that we know

17
00:01:12.530 --> 00:01:16.130 
did not represent so far in the
process model. So let's try

18
00:01:16.130 --> 00:01:18.480 
to do that using an
intermediate timer event.

19
00:01:19.120 --> 00:01:23.050 
So intermediate time events
can only be catching

20
00:01:24.150 --> 00:01:27.940 
and that is exactly what we need
here and these intermediate

21
00:01:27.940 --> 00:01:33.400 
timer events act as a delay
mechanism and we can specify that

22
00:01:33.410 --> 00:01:37.820 
by using date time for
instance december sixteenth

23
00:01:38.280 --> 00:01:42.390 
2013, or by recurring
date time for instance

24
00:01:42.390 --> 00:01:44.940 
every sunday or every
saturday at ten am,

25
00:01:45.760 --> 00:01:49.710 
or by duration for instance
when we say one week.

26
00:01:50.490 --> 00:01:55.100 
In the example we have the
following and here we have

27
00:01:56.260 --> 00:01:59.260 
the process model
that is related to

28
00:01:59.710 --> 00:02:03.710 
to the textual representation of
the scenario we had before.

29
00:02:04.090 --> 00:02:09.150 
So there is a decision so whether
the order date is between

30
00:02:09.160 --> 00:02:14.280 
friday and sunday so if the product
has been ordered on a week end

31
00:02:15.090 --> 00:02:18.530 
then the upper branch is chosen
and the upper branch we

32
00:02:18.530 --> 00:02:21.800 
don't have any activity we just
have an intermediate timer event

33
00:02:22.000 --> 00:02:28.350 
and the time event does nothing but
waits for the events to occur

34
00:02:28.700 --> 00:02:31.360 
for the specified event to
occur. So at that point

35
00:02:31.780 --> 00:02:35.970 
let's say on friday afternoon
the order is submitted

36
00:02:36.400 --> 00:02:40.290 
and then the process instance
goes through these to the upper

37
00:02:40.290 --> 00:02:43.850 
branch and then this
is called monday at

38
00:02:44.690 --> 00:02:50.420 
midnight monday at zero o'clock so
to speak and so the process waits.

39
00:02:50.640 --> 00:02:56.510 
friday, saturday, sunday
and monday morning at

40
00:02:56.900 --> 00:03:02.370 
midnight so to speak and then the event
fires and the process continues.

41
00:03:02.680 --> 00:03:07.800 
And the process continues and then we
can check inventory availability. So

42
00:03:08.340 --> 00:03:13.060 
intermediate timer events act as
a delay mechanism and processes

43
00:03:13.060 --> 00:03:14.780 
and is the typical
example of how

44
00:03:15.570 --> 00:03:18.170 
how this could be used.

45
00:03:21.170 --> 00:03:25.410 
Timer events do not need to be
embedded in the sequence flow

46
00:03:25.420 --> 00:03:28.980 
of a process but they can
also be boundary events.

47
00:03:30.030 --> 00:03:35.440 
So a boundary event is as
the name indicates on the

48
00:03:35.440 --> 00:03:36.960 
boundary of an activity

49
00:03:37.570 --> 00:03:40.640 
and boundary events are
always catching events.

50
00:03:41.760 --> 00:03:45.400 
And the occurrence of a boundary
event is only relevant if

51
00:03:45.400 --> 00:03:48.370 
it occurs while the activity
is in the running state.

52
00:03:49.550 --> 00:03:52.650 
So let's draw a little

53
00:03:54.120 --> 00:03:56.480 
process diagram with
a boundary event.

54
00:03:58.160 --> 00:03:59.660 
So here we have

55
00:04:01.680 --> 00:04:05.000 
process continues
activity A,

56
00:04:06.370 --> 00:04:08.330 
and we have an
activity called B,

57
00:04:09.830 --> 00:04:13.370 
and the activity B has
this intermediate

58
00:04:14.000 --> 00:04:20.720 
event and it's a boundary event because
it is a draw is not very nice but

59
00:04:22.000 --> 00:04:25.470 
this is a boundary event and
there we continue with activity

60
00:04:25.470 --> 00:04:28.800 
C and here we continue with
activity D for instance.

61
00:04:29.980 --> 00:04:31.740 
And that needs to be

62
00:04:35.190 --> 00:04:40.190 
sequence flow needs to be a
bit it should go, alright.

63
00:04:40.570 --> 00:04:44.920 
So here we have an activity B.
The activity B has a boundary

64
00:04:44.920 --> 00:04:48.320 
event an intermediate event that
is exactly on the boundary

65
00:04:48.740 --> 00:04:53.880 
of this activity and the occurrence
of the boundary event is

66
00:04:53.880 --> 00:04:58.380 
only relevant if it occurs while the
activity is in the running state. So this

67
00:04:58.860 --> 00:05:02.360 
the occurrence of this activity that
can for instance be a timer event.

68
00:05:02.760 --> 00:05:07.270 
It's only relevant if it occurs
while B happens. If it occurs

69
00:05:07.300 --> 00:05:11.200 
before B starts or if it occurs
after B is terminated it does

70
00:05:11.200 --> 00:05:14.860 
not have any meaning. It does not
it's not relevant it's just

71
00:05:16.200 --> 00:05:19.880 
the event is only relevant
if it occurs while B runs.

72
00:05:21.360 --> 00:05:26.290 
There are two variants of boundary
events which are interrupting

73
00:05:26.290 --> 00:05:29.650 
boundary events and non
interrupting boundary events.

74
00:05:30.860 --> 00:05:36.070 
Interrupting boundary events interrupt
activity so once this intermediate or

75
00:05:36.170 --> 00:05:42.090 
this boundary event occurs B is
stopped B is interrupted not

76
00:05:42.090 --> 00:05:43.170 
continued to the end.

77
00:05:44.580 --> 00:05:47.700 
Non-interrupted boundary non
interrupting boundary events this

78
00:05:47.700 --> 00:05:51.640 
is not the case though B just
continues normally and of course

79
00:05:51.640 --> 00:05:55.360 
C is triggered as well. We see
that in other examples as well.

80
00:05:57.110 --> 00:06:00.640 
So expanding our application
scenario a bit further if the

81
00:06:00.640 --> 00:06:04.220 
product is not in stock and an error
occurred during manufacturing

82
00:06:04.220 --> 00:06:09.890 
the product the order shall be cancelled and
the obtained materials be disposed off.

83
00:06:10.710 --> 00:06:13.900 
In that case the process
terminates unsuccessfully.

84
00:06:15.710 --> 00:06:21.220 
So we represent this situation or this
requirement of the business process

85
00:06:21.420 --> 00:06:24.780 
as an interrupting
boundary arrow event.

86
00:06:25.840 --> 00:06:29.820 
Alright so how does that work?
When the boundary event occurs

87
00:06:29.840 --> 00:06:34.010 
manufacture product is interrupted and
the flow continues with cancelling

88
00:06:34.500 --> 00:06:40.260 
the order. So looking at the
process model we talk about

89
00:06:41.150 --> 00:06:46.040 
this area. So this activity
manufacture product has

90
00:06:46.750 --> 00:06:51.630 
a boundary event, it's an error
boundary event. So if within this

91
00:06:51.860 --> 00:06:55.820 
manufacture product
event an error occurs

92
00:06:56.940 --> 00:07:02.880 
then the order is cancelled. So then
this exception flow is then called,

93
00:07:03.230 --> 00:07:07.500 
is executed, the order is cancelled and
material is disposed off and we have

94
00:07:07.800 --> 00:07:12.350 
end event that indicates that
cancelling of the order.

95
00:07:13.490 --> 00:07:17.730 
If this error event does not
occur while manufacture product

96
00:07:17.730 --> 00:07:22.500 
is performed then we just use the outgoing
sequence flow confirm the shipping

97
00:07:22.640 --> 00:07:25.200 
and the process continues
as specified here.

98
00:07:27.150 --> 00:07:31.740 
Okay typically events or activities to
handle the error situation are started

99
00:07:31.920 --> 00:07:36.940 
after a boundary error event occurred.
So these are typical error handling

100
00:07:37.420 --> 00:07:40.270 
activities that are
executed after

101
00:07:41.270 --> 00:07:43.330 
a boundary error
event has occurred.

102
00:07:44.220 --> 00:07:48.610 
So the question is what is the
difference to an XOR split decision?

103
00:07:49.070 --> 00:07:52.130 
Could I just use an XOR split
so if an error occurs then I

104
00:07:52.130 --> 00:07:54.810 
go that way if no error
occurs I go the other way.

105
00:07:55.330 --> 00:08:00.510 
And in order to discuss this with
you I would like to use another

106
00:08:01.050 --> 00:08:06.340 
little example that looks similar
to the one we had before. So

107
00:08:06.460 --> 00:08:08.570 
we start with an
activity A.

108
00:08:10.150 --> 00:08:12.140 
We then have an
activity B

109
00:08:20.630 --> 00:08:23.730 
with this boundary
arrow event, so

110
00:08:25.120 --> 00:08:28.550 
then I have here
the C activity C

111
00:08:29.020 --> 00:08:32.930 
that handles that continues
somehow. And here we have

112
00:08:33.500 --> 00:08:37.750 
the situation in which the
normal normal process behavior

113
00:08:38.240 --> 00:08:42.580 
continues. And well
I could just do

114
00:08:43.000 --> 00:08:48.090 
represent this as as XOR split decisions.
So here we have the activity A

115
00:08:49.710 --> 00:08:51.020 
then we have activity B

116
00:08:52.330 --> 00:08:53.520 
and then we decide

117
00:08:55.190 --> 00:08:56.470 
whether we go to C

118
00:08:58.700 --> 00:09:02.890 
or we go to D. And then of course
the process continues like this.

119
00:09:03.580 --> 00:09:08.160 
So what's the difference between
these two alternatives? Well I see

120
00:09:08.300 --> 00:09:12.690 
quite some differences and probably
you also see the differences

121
00:09:12.690 --> 00:09:13.880 
at this point already.

122
00:09:14.650 --> 00:09:19.130 
So first the first difference is
that the execution behavior

123
00:09:19.130 --> 00:09:25.820 
is different because in the in the upper
examples using the boundary event

124
00:09:26.980 --> 00:09:32.520 
activity C or activity
B is interrupted is

125
00:09:32.640 --> 00:09:34.880 
cancelled when this
event occurs

126
00:09:35.530 --> 00:09:36.890 
in the lower part

127
00:09:37.500 --> 00:09:41.360 
using the XOR split that's not
the case. B terminates just

128
00:09:41.360 --> 00:09:45.210 
perfectly just normally and
then there is a decision

129
00:09:45.250 --> 00:09:48.720 
about using whether to use
C the error handling or

130
00:09:49.190 --> 00:09:55.250 
whether to use D. So it is a decision
that is based on conditions

131
00:09:55.260 --> 00:09:57.800 
that are attached to the sequence
flow edges as we know.

132
00:09:58.250 --> 00:10:02.010 
But in the upper part the decision
is not taken by a condition

133
00:10:02.010 --> 00:10:05.770 
not specified by a condition but by an
occurred event, by an error event.

134
00:10:06.080 --> 00:10:09.580 
So also from the modelling perspective
it's quite a different thing.

135
00:10:10.000 --> 00:10:14.090 
If I model it as I did in the
lower part I just say well there

136
00:10:14.090 --> 00:10:17.010 
is activities A and B and then
there is a decision. Either I

137
00:10:17.010 --> 00:10:19.020 
go for C or I go for D.

138
00:10:19.620 --> 00:10:23.660 
But if I use the boundary event
it's clear that the normal flow

139
00:10:23.660 --> 00:10:29.140 
is A B D. So if nothing bad happens,
it's A B D. However if there

140
00:10:29.140 --> 00:10:33.950 
is an error or I need to go to
the the C way and I need I

141
00:10:33.950 --> 00:10:35.890 
need to make error handling
and so forth. So

142
00:10:36.550 --> 00:10:40.420 
also from the modeling perspective
that it's different it's

143
00:10:40.420 --> 00:10:43.660 
a difference to indicate that there
even if an error occurs then I need

144
00:10:43.960 --> 00:10:45.230 
to do activity C here.

145
00:10:47.550 --> 00:10:50.240 
Right so there are subtle
differences. The decision is based

146
00:10:50.240 --> 00:10:54.050 
on event occurrence on the one hand
and by conditions on the other.

147
00:10:54.240 --> 00:10:57.420 
But there is also a difference
in execution semantics since

148
00:10:57.420 --> 00:11:01.980 
in the XOR case the activity
completes. So activity B in our case

149
00:11:02.450 --> 00:11:06.950 
while it does not in the
case of the boundary event

150
00:11:07.050 --> 00:11:10.880 
and also as indicated from the
modelling perspective it's clearer

151
00:11:10.880 --> 00:11:15.800 
that an error has occurred rather than a
normal decision during a business process.

152
00:11:16.600 --> 00:11:20.920 
And here in that case I think
also that this decision is

153
00:11:21.270 --> 00:11:26.040 
or it's modelled, the situation
is models appropriately

154
00:11:26.040 --> 00:11:31.410 
using the boundary error event
since if an error occurs during

155
00:11:31.410 --> 00:11:34.480 
manufacturing the product I don't
need to continue manufacturing.

156
00:11:34.480 --> 00:11:39.240 
I just cancel the order and
get rid of the material.

157
00:11:39.780 --> 00:11:45.230 
If the error does not occur then
manufacture product continues

158
00:11:45.660 --> 00:11:49.320 
properly, terminates and then
the normal flow of the process

159
00:11:49.320 --> 00:11:52.540 
continues. I would not be able to
express the same semantics using

160
00:11:52.830 --> 00:11:53.710 
the XOR split.

161
00:11:57.230 --> 00:12:02.900 
We also talked about non
interrupting boundary events. Well

162
00:12:04.440 --> 00:12:08.060 
boundary events might therefore
also be non interrupting. In

163
00:12:08.060 --> 00:12:12.100 
this case the activity continues
just normally while spawning

164
00:12:12.100 --> 00:12:15.820 
a reaction to the event. And the
notation is a bit different

165
00:12:15.820 --> 00:12:18.620 
that's a circle with a
dashed double border. So

166
00:12:19.200 --> 00:12:25.130 
interrupting event have the normal double
border and non interrupting boundary events

167
00:12:26.080 --> 00:12:28.260 
dashed double border.

168
00:12:29.490 --> 00:12:34.080 
Here is an example also related
to the to our scenario. So I'd

169
00:12:34.080 --> 00:12:37.840 
like to inform the a customer
if manufacturing takes longer

170
00:12:37.840 --> 00:12:43.110 
than expected but of course I do not want
to interrupt manufacturing in this case.

171
00:12:44.160 --> 00:12:51.300 
Here we have using the highlighter
I use the non interrupting

172
00:12:51.300 --> 00:12:56.890 
boundary event that is attached
to the manufacture products

173
00:12:56.910 --> 00:13:02.580 
activity in the process. And I have
a timer event I could specify

174
00:13:03.140 --> 00:13:07.870 
i'm certain it's not further
specified that that depends

175
00:13:07.870 --> 00:13:12.070 
on the goal of the process and
of what the customer expect

176
00:13:12.070 --> 00:13:15.880 
of course. So it's not further detailed
the particular timing behavior

177
00:13:16.050 --> 00:13:19.310 
but if the timer occurs or
if it takes longer maybe

178
00:13:19.810 --> 00:13:24.630 
takes longer than two days for instance
and then the boundary event occurs

179
00:13:24.840 --> 00:13:32.380 
the inform customer about delay activity
is executed and then the process

180
00:13:32.510 --> 00:13:38.160 
stops here. Other than that
if manufacture product

181
00:13:38.160 --> 00:13:43.560 
completes before the
timer is fired then the

182
00:13:43.560 --> 00:13:45.970 
time has no effect. It's
an also nice example

183
00:13:46.410 --> 00:13:50.150 
of a situation where the timer
does not have any effect if

184
00:13:50.160 --> 00:13:53.060 
the product is manufactured maybe
after one day already and

185
00:13:53.060 --> 00:13:55.170 
the timer is planned for
two days and of course

186
00:13:55.580 --> 00:13:58.770 
the occurrence of this timer does
not have any effect on the

187
00:13:58.770 --> 00:13:59.800 
process anymore.

188
00:14:02.020 --> 00:14:08.080 
Ok so couldn't we specify the non
interrupting event as an AND split?

189
00:14:08.370 --> 00:14:09.530 
Isn't that
something like

190
00:14:10.250 --> 00:14:13.510 
like an AND split that we use
and what in particular is the

191
00:14:13.510 --> 00:14:15.050 
difference to
the AND split?

192
00:14:15.770 --> 00:14:21.360 
Also in this case there are
subtle differences and also

193
00:14:21.360 --> 00:14:25.350 
I'd like to sketch that. Maybe
I can get rid of the solution

194
00:14:25.920 --> 00:14:27.330 
at this point in time.

195
00:14:28.070 --> 00:14:33.270 
Assume we have an activity
B. Activity B has now this

196
00:14:34.660 --> 00:14:36.410 
non interrupting event.

197
00:14:37.800 --> 00:14:41.690 
And here we have an
activity C for instance.

198
00:14:42.260 --> 00:14:46.260 
And we have an activity D in the
normal case and that's embedded

199
00:14:47.500 --> 00:14:49.230 
in the whole
process flow.

200
00:14:50.140 --> 00:14:53.510 
Why not doing something like
this? So we have activity B.

201
00:14:55.560 --> 00:14:56.480 
Then we have

202
00:15:01.260 --> 00:15:04.070 
of C and of D.

203
00:15:07.260 --> 00:15:11.140 
And the question is so what is what
is the difference again here?

204
00:15:11.760 --> 00:15:16.920 
Well first of all not in all cases C
is executed. So that is the first

205
00:15:16.920 --> 00:15:20.240 
difference or the modeling as an AND
split would not be correct since

206
00:15:20.490 --> 00:15:25.560 
C does not need to be executed
if B has or if the boundary

207
00:15:25.560 --> 00:15:28.410 
event does not occur
while B is active.

208
00:15:29.070 --> 00:15:35.640 
Also it's not clear from the
modeling perspective that

209
00:15:36.300 --> 00:15:39.410 
that's an additional activity C
is an additional activity that

210
00:15:39.410 --> 00:15:42.860 
is only executed if the boundary
event actually occurs.

211
00:15:43.520 --> 00:15:47.520 
So also there are quite some some
differences in the semantics

212
00:15:47.530 --> 00:15:52.440 
of this. I need to use the
eraser because I have

213
00:15:53.210 --> 00:15:57.190 
subtle differences as well or specified
here in this part of the slides.

214
00:15:57.320 --> 00:16:00.160 
So there is a difference in the
execution semantics in the

215
00:16:00.160 --> 00:16:03.220 
AND case activities are sequential
while this is not the case

216
00:16:03.230 --> 00:16:07.730 
with the boundary event and we
need to be careful with joining

217
00:16:07.730 --> 00:16:11.930 
the flow in an AND gateway since the
event can occur several times.

218
00:16:12.570 --> 00:16:16.630 
So also this boundary event can
occur really several times

219
00:16:16.630 --> 00:16:20.350 
so it can depending on the
occurrence of the event then

220
00:16:20.350 --> 00:16:23.900 
I can send several notices to
the customer that the product

221
00:16:23.960 --> 00:16:29.770 
is late and also that would cause
problems when we again wanted to join

222
00:16:30.070 --> 00:16:31.850 
the different nodes
of the AND join.

223
00:16:34.420 --> 00:16:38.670 
Alright we come to
intermediate signal events.

224
00:16:39.190 --> 00:16:44.700 
Signal events are specific or
have a specific property

225
00:16:44.710 --> 00:16:46.770 
and the property is the
scope of the signal event.

226
00:16:48.010 --> 00:16:53.070 
The scope of the signal event is
not as a single process instant

227
00:16:53.700 --> 00:16:59.180 
in its environment but it
can be used to communicate

228
00:16:59.180 --> 00:17:02.820 
the occurrence of events among
different business processes.

229
00:17:03.060 --> 00:17:05.740 
And that's different
from what we've seen

230
00:17:06.290 --> 00:17:09.890 
in the other events also the
other intermediate events that

231
00:17:09.890 --> 00:17:13.640 
are that the scope is always the
business process itself and

232
00:17:13.640 --> 00:17:15.050 
signal events
can be used

233
00:17:16.240 --> 00:17:20.940 
to address a broader scope to also
let's say have implications

234
00:17:20.940 --> 00:17:22.540 
on other business
processes.

235
00:17:24.270 --> 00:17:27.870 
Ok so how does a
single event

236
00:17:28.540 --> 00:17:32.330 
look like? Very simple
examples. So activity A

237
00:17:33.930 --> 00:17:36.480 
Then we have a signal
event. Signal events are

238
00:17:37.190 --> 00:17:43.810 
triangles that if throwing are
black inside then we have the B.

239
00:17:45.690 --> 00:17:50.790 
And so that's a throwing event and
that means after A has occurred

240
00:17:50.820 --> 00:17:55.470 
the signal is thrown and then B
has occurred and this signal

241
00:17:55.470 --> 00:17:59.320 
can then be caught by a number of other
business processes, could also be

242
00:17:59.440 --> 00:18:04.050 
many many other different business
processes. So BPMN signal

243
00:18:04.050 --> 00:18:07.980 
and this is from the specification,
BPMN signal is similar to

244
00:18:07.980 --> 00:18:12.940 
a signal flare that's shot into
the air, shot into the sky is

245
00:18:12.940 --> 00:18:15.860 
visible visible to everyone
who might be interested.

246
00:18:16.350 --> 00:18:20.330 
So that's that's the way in
BPMN to communicate events

247
00:18:20.330 --> 00:18:23.000 
among between different
business processes.

248
00:18:23.790 --> 00:18:27.280 
We also have an example
of an intermediate

249
00:18:27.760 --> 00:18:31.640 
signal event. So a signal events
may be used to inform another

250
00:18:31.640 --> 00:18:36.540 
process to replenish the inventory if a
product is currently not available.

251
00:18:37.990 --> 00:18:43.970 
And so we have here this intermediate
signal event that throws

252
00:18:44.220 --> 00:18:51.580 
let's say the event in the air the sky and
that is caught by this replenish inventory

253
00:18:52.020 --> 00:18:56.700 
intermediate process. If
the process as a position

254
00:18:56.700 --> 00:18:59.360 
it could also be a start event
of another business process,

255
00:18:59.360 --> 00:19:03.570 
that would also be
possible. And once this

256
00:19:04.190 --> 00:19:09.350 
event occurs this replenish inventory
event occurs then of course

257
00:19:09.850 --> 00:19:13.380 
a process can continue can check
the inventory can do back

258
00:19:13.380 --> 00:19:16.630 
orders and things like this. So
this is the way signals are the

259
00:19:16.980 --> 00:19:22.240 
way in BPMN to communicates events
across different business processes.

260
00:19:24.090 --> 00:19:28.280 
There's a very nice BPMN poster
that is produced by the

261
00:19:28.810 --> 00:19:33.030 
BPM offensive Berlin or
the BPM offensive.

262
00:19:33.960 --> 00:19:37.930 
So that's just a just a snippet
of the poster that's a complete

263
00:19:37.940 --> 00:19:43.780 
poster that you also
can order at bpmb.de.

264
00:19:43.780 --> 00:19:48.390 
There are posters available in a
variety of different languages.

265
00:19:48.390 --> 00:19:53.210 
Hopefully your language is also is
also supported also available there.

266
00:19:53.780 --> 00:19:59.280 
And so this is the part where the events
are characterized or these posters

267
00:19:59.590 --> 00:20:04.150 
reasonably complete and this just shows
you that there is a that there are

268
00:20:04.280 --> 00:20:08.270 
many many events or event
types event kinds

269
00:20:08.700 --> 00:20:13.640 
available in BPMN. We just
discussed some of them.

270
00:20:14.090 --> 00:20:20.680 
So um let's see which ones which were the
ones we discussed the un-typed events,

271
00:20:21.060 --> 00:20:25.840 
we took a look at we looked at
at message events, we looked

272
00:20:25.840 --> 00:20:29.120 
at timer events also intermediate
timer events. We also looked

273
00:20:29.120 --> 00:20:34.760 
at error events. So we captured quite
some of them but actually not

274
00:20:34.900 --> 00:20:38.840 
not all of them were discussed
in the context of this course.

275
00:20:40.810 --> 00:20:44.790 
That brings us to the end
of video clip 2.6 where

276
00:20:45.310 --> 00:20:49.920 
we took a look at intermediate
events. Intermediate events can

277
00:20:50.150 --> 00:20:54.020 
be catching, in this case they
act as a delay mechanism. They

278
00:20:54.020 --> 00:20:57.380 
can be throwing in this case I
just throw the event and the

279
00:20:57.380 --> 00:21:01.840 
process continues, or no delay if
an intermediate event throws.

280
00:21:03.090 --> 00:21:07.810 
Boundary events restrict the
scope of an event occurance

281
00:21:07.810 --> 00:21:12.440 
to an activity. So boundary events are
attached to the boundary of activities and

282
00:21:12.660 --> 00:21:17.810 
they only react if the event occurs
while the activity is running.

283
00:21:18.580 --> 00:21:21.940 
Boundary events can be of interrupting
and of non interrupting

284
00:21:21.940 --> 00:21:25.580 
nature. We discuss the relationship
of boundary events with

285
00:21:25.590 --> 00:21:30.180 
an XOR and with AND gateways
and finally we discussed

286
00:21:30.400 --> 00:21:34.670 
signal events and we took a look
also at events and complete

287
00:21:34.670 --> 00:21:38.040 
set of events as
specified in the

288
00:21:38.670 --> 00:21:42.310 
in the standard and as
present in the BPMN poster.

289
00:21:43.670 --> 00:21:47.770 
This short video summarizes what
we looked at in the second

290
00:21:47.770 --> 00:21:52.480 
week of the course. So we took
a look at activities in BPMN.

291
00:21:52.480 --> 00:21:57.680 
Then we discussed that they
represent units of work, that they

292
00:21:57.680 --> 00:21:59.460 
take time to be
completed.

293
00:22:00.360 --> 00:22:04.400 
Activity instances contribute
to process instance. We have

294
00:22:04.400 --> 00:22:09.180 
seen that process models can have many
process instances. Process instances

295
00:22:09.960 --> 00:22:13.080 
contain activity instances
and activity instances

296
00:22:13.500 --> 00:22:16.870 
behave according to state
transition diagram where they

297
00:22:16.880 --> 00:22:19.750 
first are in the init state
than they are normally in the

298
00:22:19.750 --> 00:22:23.530 
ready state and the running state
and the terminated state. However

299
00:22:23.530 --> 00:22:27.960 
we've also seen when we when it
comes to splitting behavior then

300
00:22:28.130 --> 00:22:31.720 
certain activity might not be
required so we can change state

301
00:22:31.720 --> 00:22:33.990 
from init to
skipped also.

302
00:22:35.050 --> 00:22:39.440 
We looked at task types that
determine the nature of a task

303
00:22:39.440 --> 00:22:44.650 
that can be used to enrich business
process models with a type of task.

304
00:22:45.450 --> 00:22:48.080 
The second part we
looked at gateways,

305
00:22:48.550 --> 00:22:53.160 
especially the exclusive OR gateway
that can be used for exclusive

306
00:22:53.160 --> 00:22:55.830 
choices or you can
have 1/m with

307
00:22:56.490 --> 00:23:01.460 
exclusive OR split has m outgoing
edges then I can choose exactly

308
00:23:01.460 --> 00:23:04.910 
one. Using this we looked at the
execution semantics of the

309
00:23:04.910 --> 00:23:08.370 
XOR split and also we looked at the
default flow that is required.

310
00:23:09.210 --> 00:23:15.400 
We can use the XOR gateway also
to realize looping behavior

311
00:23:15.410 --> 00:23:17.410 
and then the loop
condition is basically

312
00:23:18.360 --> 00:23:24.820 
the well is basically the condition of
the outgoing edge of the XOR split.

313
00:23:25.510 --> 00:23:29.690 
We looked at the AND gateway that
allows interleaved ordering

314
00:23:29.760 --> 00:23:34.850 
of activities but also
concurrency so when

315
00:23:34.850 --> 00:23:38.570 
certain parts of processes can be
executed independently from each other

316
00:23:38.900 --> 00:23:42.720 
it's a good idea to use the
AND gateway for these parts.

317
00:23:43.640 --> 00:23:47.700 
The OR gateway offers quite a
flexible behavior because

318
00:23:47.700 --> 00:23:51.750 
the OR split would trigger
any subset of the follow up

319
00:23:51.760 --> 00:23:57.740 
activities using the sequence flow or
conditional sequence flow attached.

320
00:23:58.350 --> 00:24:04.660 
So we can have n/m so any n out of m is
allowed here, so inclusive choices.

321
00:24:05.300 --> 00:24:09.620 
We discuss the OR join which
is quite easy to handle in

322
00:24:10.200 --> 00:24:15.190 
the context of structured models but
in arbitrary structured models

323
00:24:15.650 --> 00:24:19.820 
it's still challenging to
calculate to implement this

324
00:24:19.830 --> 00:24:21.230 
behavior of
the OR join.

325
00:24:22.160 --> 00:24:26.920 
We discussed uncontrolled flow
and also we discussed that

326
00:24:26.930 --> 00:24:29.780 
you might be careful with using
uncontrolled flow because the

327
00:24:29.780 --> 00:24:33.250 
split and join behavior is
different in uncontrolled flow.

328
00:24:34.200 --> 00:24:38.350 
Finally we looked at events in
particular start events and

329
00:24:38.360 --> 00:24:42.010 
end events. Process models should have
one start event, process models

330
00:24:42.010 --> 00:24:46.210 
should have one end event for each possible
outcome of the process. So these

331
00:24:46.880 --> 00:24:50.500 
end events need to be
exclusive to each other.

332
00:24:51.520 --> 00:24:54.700 
We looked at intermediate events
that might be throwing or

333
00:24:54.700 --> 00:25:00.710 
catching and finally we looked at boundary
events that might be interrupting or

334
00:25:00.990 --> 00:25:02.120 
also non interrupting.
