WEBVTT

1
00:00:00.740 --> 00:00:05.640 
Welcome to video clip 2.4 in which
we discuss inclusive gateways and loops.

2
00:00:07.420 --> 00:00:12.390 
We again motivate this with an
extension of our application scenario

3
00:00:12.930 --> 00:00:16.890 
which is as follows. So depending
on the ordered product

4
00:00:17.250 --> 00:00:22.020 
materials from supplier
one or

5
00:00:22.020 --> 00:00:25.040 
supplier two may be sufficient
to manufacture the product. In

6
00:00:25.040 --> 00:00:28.690 
some cases however materials from
both suppliers are required

7
00:00:28.690 --> 00:00:32.240 
for manufacturing the
product. So we have here the

8
00:00:32.240 --> 00:00:36.820 
alternative either supply one is ok or
supplier two is ok or we need

9
00:00:37.180 --> 00:00:42.100 
the material from both. We could
model this situation using the

10
00:00:42.520 --> 00:00:48.030 
exclusive OR split and also
the AND split and so

11
00:00:48.040 --> 00:00:52.820 
the results you see
on this slide. So

12
00:00:53.350 --> 00:00:58.230 
how is that organized here, we have here
the decision the decision either

13
00:00:58.560 --> 00:01:01.790 
material from supplier
one is required or

14
00:01:02.220 --> 00:01:06.520 
material from supplier to is required
or material from both suppliers

15
00:01:06.520 --> 00:01:11.280 
are required in which we have
the concurrent two concurrent

16
00:01:11.280 --> 00:01:14.990 
branches which means requesting
material from supplier one,

17
00:01:15.140 --> 00:01:19.020 
obtaining material from supplier one and
concurrently the same for supplier two.

18
00:01:19.530 --> 00:01:22.130 
And then let's say the
flow continues here.

19
00:01:23.140 --> 00:01:28.150 
What we see here yes we can do that,
we can represent this requirement

20
00:01:28.150 --> 00:01:32.260 
as defined in the text in the
process model but we have

21
00:01:32.260 --> 00:01:36.670 
a little bit of increased complexity
by this and we have also

22
00:01:36.670 --> 00:01:43.400 
an application of tasks. So certain
tasks require or appear several times, so

23
00:01:43.780 --> 00:01:47.410 
request material from
supplier one two times,

24
00:01:47.900 --> 00:01:52.650 
obtain material from supplier one two
times and also the same holds for

25
00:01:53.010 --> 00:01:56.600 
the two activities of
supplier two. So we

26
00:01:57.160 --> 00:02:04.060 
are seeking a way to express
this in a bit more compact way

27
00:02:04.060 --> 00:02:06.920 
and inclusive gateways
can be used to do that.

28
00:02:07.360 --> 00:02:13.360 
So the inclusive gateways also
called or split or split or join

29
00:02:14.200 --> 00:02:19.360 
that means any non-empty subset
of outgoing sequence flow arcs

30
00:02:19.520 --> 00:02:21.900 
is signaled depending
on the conditions,

31
00:02:23.150 --> 00:02:28.630 
and each condition is that is evaluated
to true signals and outgoing arc.

32
00:02:29.110 --> 00:02:34.070 
It's also possible to have a
default flow and that is

33
00:02:34.370 --> 00:02:37.520 
are used only if all other
conditions are false.

34
00:02:39.240 --> 00:02:42.980 
Ok here's an examples so the previous
example now expressed using the

35
00:02:43.150 --> 00:02:48.080 
inclusive gateway expression
in particular the OR split

36
00:02:49.070 --> 00:02:52.350 
and we see the
OR split here.

37
00:02:53.510 --> 00:02:57.330 
And here we just we have
one condition that is

38
00:02:57.900 --> 00:03:01.780 
a material from supplier one is
required the other condition

39
00:03:01.780 --> 00:03:05.090 
is material from supplier two
is required and then either

40
00:03:05.090 --> 00:03:09.020 
the upper branch is taken or the lower
branch is taken or both branches taken.

41
00:03:09.280 --> 00:03:12.860 
So we have the complete execution
semantics appeared in the

42
00:03:12.860 --> 00:03:16.860 
previous process model here
represented in quite a compact way.

43
00:03:18.480 --> 00:03:25.160 
The OR join synchronizes all incoming
sequence flow arcs that can be signaled.

44
00:03:25.920 --> 00:03:30.150 
So the OR join will be discussed
in the next slide in

45
00:03:30.150 --> 00:03:33.990 
a bit more detail but in
general tested the same the

46
00:03:33.990 --> 00:03:39.500 
same task as the XOR join or
as the parallel join

47
00:03:39.520 --> 00:03:42.390 
and the sense that there are
many incoming branches and any

48
00:03:42.390 --> 00:03:47.500 
two symbol synchronize all these and
trigger the next activity only if

49
00:03:47.730 --> 00:03:52.910 
all incoming flows for which I
expect something to come if

50
00:03:53.140 --> 00:03:56.310 
everything or if all these
branches have been signaled.

51
00:03:58.420 --> 00:04:00.910 
Alright let's discuss that a bit
more detail. So we have a number

52
00:04:00.910 --> 00:04:05.300 
of remarks on the OR join. So
again an abstract example.

53
00:04:05.300 --> 00:04:08.900 
So the OR join is the guy
here on the right-hand side.

54
00:04:09.640 --> 00:04:13.380 
This modeling construct provides
a high degree of flexibility

55
00:04:13.380 --> 00:04:15.790 
so OR splits or OR
joins as a construct

56
00:04:16.200 --> 00:04:21.070 
but the OR join has also
non-local execution semantics. So

57
00:04:21.070 --> 00:04:24.850 
what do we mean by non local
execution semantics? That

58
00:04:24.850 --> 00:04:28.610 
means the joint cannot decide
locally whether to signal its

59
00:04:28.620 --> 00:04:33.040 
outgoing edge or not. In all
other constructs we had on the

60
00:04:33.040 --> 00:04:38.410 
constructs could decide locally
what's to do, so the XOR split

61
00:04:38.660 --> 00:04:43.010 
looks at the conditions and then locally
evaluates which branches to take,

62
00:04:43.230 --> 00:04:47.970 
the AND split just signals
all outgoing arcs, also the

63
00:04:47.970 --> 00:04:52.630 
same holds for the XOR join so
any signalling or signalling

64
00:04:52.630 --> 00:04:56.790 
of any incoming arc would then trigger
the signaling of the outgoing

65
00:04:57.090 --> 00:05:01.190 
and the AND join but as the
AND join well it waits for

66
00:05:01.190 --> 00:05:06.620 
signals from each incoming sequence flow arc
and then signals the outgoing arc. So

67
00:05:06.750 --> 00:05:09.320 
all these all
the gateway

68
00:05:09.990 --> 00:05:13.830 
notes we have been looking at
so far have a local behavior.

69
00:05:13.830 --> 00:05:18.860 
They can decide locally. So why is
the origin unable to do that?

70
00:05:19.190 --> 00:05:22.800 
So let's look at this example.
Here it might be the case that

71
00:05:23.340 --> 00:05:26.070 
conditions one
and two are

72
00:05:27.070 --> 00:05:30.440 
chosen so this
branch is chosen

73
00:05:31.670 --> 00:05:32.980 
and this branch
is chosen.

74
00:05:34.140 --> 00:05:39.180 
So what should the XOR, what should
the OR join do at that point in time?

75
00:05:39.620 --> 00:05:44.300 
Well it could wait maybe D will
be executed and maybe there

76
00:05:44.300 --> 00:05:46.950 
is an incoming signal
from this edge.

77
00:05:47.730 --> 00:05:51.870 
But how long should
the orider wait to

78
00:05:51.870 --> 00:05:55.580 
decide that we cannot provide an upper
bound, that can be any run time off

79
00:05:55.940 --> 00:05:59.690 
that's a D can take as long
as it likes and therefore

80
00:05:59.690 --> 00:06:03.370 
the order is unable to decide
at which point the OR join

81
00:06:03.370 --> 00:06:05.880 
should trigger the
outgoing edge.

82
00:06:06.960 --> 00:06:10.340 
However there is
if we limit

83
00:06:10.850 --> 00:06:14.550 
the expressiveness of the OR join of
the structure of the process

84
00:06:14.550 --> 00:06:19.620 
model with the OR join we can
actually provide a solution to this

85
00:06:20.200 --> 00:06:25.090 
and that is for block structured
OR joins. Block structured

86
00:06:25.100 --> 00:06:29.920 
OR joins are quite easy to handle
using false token passing.

87
00:06:30.430 --> 00:06:36.150 
So in block-structured OR joins from
the OR split to the OR join

88
00:06:36.840 --> 00:06:42.400 
so each outgoing edge let's
see if I can sketch that here

89
00:06:42.930 --> 00:06:45.760 
from each outgoing
edge of the OR split

90
00:06:46.650 --> 00:06:51.240 
there is a path that the only
paths that lead to the OR join.

91
00:06:51.460 --> 00:06:55.320 
So this one leads to the OR
Join, that leads to the OR join,

92
00:06:55.500 --> 00:06:58.800 
that leads to the OR join, that
one leads to the OR join as well.

93
00:06:58.800 --> 00:07:00.880 
So in this case we have a
block structure model.

94
00:07:01.860 --> 00:07:06.010 
Then we can use false
token passing to

95
00:07:06.660 --> 00:07:10.090 
support or to evaluate
the OR join. Lets

96
00:07:11.630 --> 00:07:14.830 
use the same example that we have
before in which case conditions

97
00:07:14.830 --> 00:07:18.360 
one and two are chosen or these
two branches will be signaled.

98
00:07:18.550 --> 00:07:21.800 
But how about the other, so
condition three is not taken and

99
00:07:21.800 --> 00:07:25.500 
the lower branch is also not
taken in this case it's called

100
00:07:25.510 --> 00:07:30.120 
False token passing. So we have
additional information

101
00:07:30.130 --> 00:07:34.870 
that is signalled along the edges
but the activities that are

102
00:07:34.870 --> 00:07:38.280 
on the edges are not executed and
that is why it's called false

103
00:07:38.280 --> 00:07:40.810 
token passing. So here
false token comes,

104
00:07:41.230 --> 00:07:44.780 
here false token comes,
here false token comes, here

105
00:07:45.270 --> 00:07:49.480 
and here as well. And in this
case the OR join well what is

106
00:07:49.480 --> 00:07:52.930 
the OR join? The OR join changes
to some kind of AND join

107
00:07:52.940 --> 00:07:57.990 
because I expect from every incoming
arc I expect a signal either

108
00:07:57.990 --> 00:08:01.740 
normal true single or false
a single or false token.

109
00:08:02.150 --> 00:08:06.060 
And in that case it's quite easy
and that works because all

110
00:08:06.060 --> 00:08:10.080 
paths that go out from the
OR join from the split

111
00:08:10.090 --> 00:08:14.010 
will go into the OR join. And in this
case it's quite easy to do that

112
00:08:14.590 --> 00:08:18.320 
arbitrarily structured OR joints
are really complex and are

113
00:08:18.330 --> 00:08:23.300 
still being discussed in academic
worlds. There's a very nice

114
00:08:23.530 --> 00:08:27.000 
paper by Kindler in 2004 that

115
00:08:27.000 --> 00:08:29.210 
raised these questions.

116
00:08:31.460 --> 00:08:34.830 
Alright let's continue with
the application scenario. So

117
00:08:34.980 --> 00:08:39.240 
the order is checked for correctness
and completeness

118
00:08:39.250 --> 00:08:42.040 
after it has
been registered in the system.

119
00:08:43.360 --> 00:08:46.920 
If the order details are not valid
an order update is requested

120
00:08:46.920 --> 00:08:50.250 
which needs to be registered in
the IT system as well and checked

121
00:08:50.250 --> 00:08:55.440 
again. And this is repeated until the order
is valid. So we already by reading this

122
00:08:55.720 --> 00:08:58.810 
we have the feeling that we now
talk about repetitive behavior

123
00:08:58.810 --> 00:09:00.870 
that we talk about loops
in process models.

124
00:09:02.370 --> 00:09:06.570 
So loops are an iteration that can be
modeled with an exclusive gateway.

125
00:09:06.940 --> 00:09:11.110 
The branching condition of the OR
split acts as the loop condition

126
00:09:11.640 --> 00:09:16.030 
and the loop iterations require the
creation of new activity instances

127
00:09:16.410 --> 00:09:20.110 
and there can be many activity instances
for a given process activity

128
00:09:20.240 --> 00:09:21.720 
in one process instance.

129
00:09:25.280 --> 00:09:28.220 
Alright so let's first look at
the example and then look

130
00:09:28.220 --> 00:09:30.460 
at the creation of
activity instances.

131
00:09:31.460 --> 00:09:37.090 
So here we have the normal
flow, so receive the order enter

132
00:09:37.090 --> 00:09:40.940 
order details, check for
correctness and then we have the

133
00:09:41.050 --> 00:09:47.950 
XOR split and here the XOR
split is well evaluated of course the

134
00:09:48.360 --> 00:09:52.810 
conditions are evaluated
here we have a condition, order

135
00:09:52.920 --> 00:09:57.910 
is incorrect. So if the order is actually
incorrect then this branch is taken,

136
00:09:58.690 --> 00:10:03.670 
we request an order update, we receive
an order update and then we

137
00:10:03.820 --> 00:10:09.180 
iterate again. We do this
until the order is correct

138
00:10:09.180 --> 00:10:12.280 
in which case the default flow will
be taken because order incorrect

139
00:10:12.280 --> 00:10:16.180 
is false in this situation and
then we can leave this loop.

140
00:10:16.950 --> 00:10:21.040 
This example shows that there are
or put it the other way around

141
00:10:21.040 --> 00:10:26.450 
so far all our process models had
one activity instance for each

142
00:10:26.560 --> 00:10:29.180 
activity that occurs
in the process model.

143
00:10:29.650 --> 00:10:32.910 
Here it's more because in the
second iteration of the loop

144
00:10:32.910 --> 00:10:36.670 
I have the second let's say
activity instance of enter

145
00:10:36.670 --> 00:10:41.990 
order details in the second instance
of check correctness of order.

146
00:10:43.090 --> 00:10:47.790 
And in this case I just like to mention
that in each new iteration of the loop

147
00:10:47.960 --> 00:10:52.670 
new activity instances need to be
initialized and then by then the

148
00:10:52.990 --> 00:10:57.980 
activity let's say the
state transition diagram

149
00:10:57.980 --> 00:11:01.950 
of activity is still valid but
I need to initialise new

150
00:11:02.360 --> 00:11:07.080 
activity instances with
every new iteration of this loop.

151
00:11:09.350 --> 00:11:13.140 
BPMN also provides uncontrolled
Flow. We have already seen

152
00:11:13.140 --> 00:11:18.440 
uncontrolled flow that is when we
looked at just a normal sequence flow.

153
00:11:19.370 --> 00:11:24.370 
Activities may have several incoming and
several outgoing sequence flow arcs

154
00:11:24.520 --> 00:11:27.600 
and the signaling these arcs is
determined by the so called

155
00:11:27.610 --> 00:11:31.540 
uncontrolled flow semantics and
uncontrolled flow semantics

156
00:11:31.910 --> 00:11:38.800 
means each outgoing edge is signaled. So when
an activity has multiple outgoing address

157
00:11:39.260 --> 00:11:41.400 
all these outgoing
edges are signaled.

158
00:11:42.200 --> 00:11:45.850 
And related to the incoming edges
each incoming edge that is

159
00:11:45.850 --> 00:11:47.440 
signaled executes
the task.

160
00:11:48.390 --> 00:11:51.420 
Alright so that's the semantics
of the uncontrolled flow and

161
00:11:51.420 --> 00:11:54.370 
if I have normal sequences that's
perfectly what

162
00:11:54.370 --> 00:11:59.050 
what I expect. So when the previous
guy determines or signals the edge

163
00:11:59.380 --> 00:12:03.830 
I can change my state to
running executed signal,

164
00:12:04.260 --> 00:12:08.330 
signal the outgoing edge to an
uncontrolled flow to the next

165
00:12:08.860 --> 00:12:11.400 
line. So that's
all perfect behavior.

166
00:12:12.320 --> 00:12:15.120 
However if I have a structure
like the one we see here

167
00:12:15.540 --> 00:12:19.410 
on this slide what is the execution
behaviour of that one? Well

168
00:12:19.900 --> 00:12:25.310 
first and that is there is no doubt
we need to execute activity A.

169
00:12:27.090 --> 00:12:31.900 
After activity A is executed all
outgoing edges are signaled so

170
00:12:32.130 --> 00:12:35.140 
the edge to B is signaled
the edge to C is signaled

171
00:12:35.640 --> 00:12:39.730 
B is ready and can then go to
running and C is ready and can

172
00:12:39.900 --> 00:12:40.710 
then go to running.

173
00:12:42.000 --> 00:12:45.900 
So actually what we see here is an AND
split right. So after A is executed

174
00:12:46.200 --> 00:12:49.480 
the two outgoing edges are
signaled and there's AND split.

175
00:12:50.800 --> 00:12:55.780 
Now what happens after B terminates? After
B terminates these edge is signaled.

176
00:12:56.030 --> 00:13:01.180 
What happens to D? Well D finds an incoming
edge that is signals so D executes,

177
00:13:01.670 --> 00:13:02.970 
so D is executed.

178
00:13:05.050 --> 00:13:07.450 
At that point
C terminates,

179
00:13:08.590 --> 00:13:12.650 
a bit later C terminates that
signal that edge is signaled and D

180
00:13:12.650 --> 00:13:17.520 
what happens, D is executed again so
D is executed two times in

181
00:13:17.700 --> 00:13:22.570 
this process. Why? Because the join
of the uncontrolled flow is

182
00:13:22.570 --> 00:13:25.850 
actually XOR join and the
split as an AND split.

183
00:13:26.290 --> 00:13:31.610 
Also the two structures look very
similar here, they

184
00:13:31.840 --> 00:13:35.720 
do have a different
execution behavior that makes it

185
00:13:35.960 --> 00:13:40.280 
that makes it say that often
leads to quite some confusion.

186
00:13:40.660 --> 00:13:44.430 
So uncontrolled flow might lead
to confusion because the split

187
00:13:44.430 --> 00:13:47.490 
has an AND semantics and the
join has an OR semantics.

188
00:13:49.250 --> 00:13:52.410 
So we come to the modelling
guidelines related to gateways.

189
00:13:52.840 --> 00:13:58.590 
I propose to use gateways for splits
and joins rather than activities.

190
00:13:59.230 --> 00:14:02.170 
The motivation is that uncontrolled
flow semantics are often

191
00:14:02.170 --> 00:14:06.670 
difficult to comprehend, that each activity
should have one incoming and one

192
00:14:06.890 --> 00:14:10.660 
outgoing sequence flow edge that
makes it very clear because then

193
00:14:10.820 --> 00:14:14.560 
activities do not have a split
and join behavior and the concept

194
00:14:14.560 --> 00:14:18.380 
of splitting the concepts of
joining are then represented by

195
00:14:18.380 --> 00:14:20.540 
dedicated element
which is the gateway.

196
00:14:21.650 --> 00:14:25.220 
There's always not always
there sometimes exceptions to

197
00:14:25.320 --> 00:14:29.740 
to rules and here there is an
exception that if we have a loop

198
00:14:30.220 --> 00:14:35.670 
like this then we can save
the XOR join node in the

199
00:14:35.670 --> 00:14:38.560 
beginning and we can
just and model

200
00:14:39.370 --> 00:14:41.280 
we can model this

201
00:14:42.490 --> 00:14:47.440 
by the two incoming edges
so either or enter order

202
00:14:47.450 --> 00:14:50.910 
details can be started after
receive order but it can only

203
00:14:50.920 --> 00:14:54.850 
also be started after receiving
an update. So here no confusion

204
00:14:54.850 --> 00:14:58.300 
is possible in this type of
structure so we could use it here.

205
00:14:58.470 --> 00:15:01.100 
But in general it's a
good idea to have

206
00:15:01.600 --> 00:15:06.180 
each activity that each activity is one
incoming edge and one outgoing edge.

207
00:15:08.070 --> 00:15:12.750 
The second advice and second
modeling guideline in this

208
00:15:12.750 --> 00:15:17.910 
context is avoiding mixed gateways.
BPMN allows mixed gateways.

209
00:15:17.910 --> 00:15:21.600 
So what are mixed gateways? Mixed
gateways are gateways that

210
00:15:21.600 --> 00:15:25.390 
are at the same times split but
at the same time have a split

211
00:15:25.390 --> 00:15:28.430 
behavior and a join behavior.
So gateways that have

212
00:15:29.170 --> 00:15:31.910 
several incoming edges and
several outgoing edges.

213
00:15:33.140 --> 00:15:39.050 
Alright so I'll try to sketch process
model with the mix gateway

214
00:15:39.390 --> 00:15:41.530 
and do this is followed. So

215
00:15:42.770 --> 00:15:46.880 
the process starts executes
A also start example

216
00:15:47.620 --> 00:15:49.520 
after the A we
have an AND split,

217
00:15:51.680 --> 00:15:52.970 
so parallel split,

218
00:15:54.360 --> 00:15:56.040 
because this activity

219
00:15:57.830 --> 00:15:59.610 
this activity
is executed,

220
00:16:00.400 --> 00:16:03.280 
so call it B and C,
you can read it.

221
00:16:05.420 --> 00:16:09.050 
Then we need to join the
concurrent execution of B and C.

222
00:16:10.540 --> 00:16:14.000 
And then we have here the mixed
gateway and there's a D and an E

223
00:16:21.570 --> 00:16:24.900 
and of course these two
also need to be joined.

224
00:16:27.170 --> 00:16:29.780 
And afterwards the process
continues in some way.

225
00:16:30.330 --> 00:16:34.480 
So the mixed gateway of course
is the one in the middle that

226
00:16:34.480 --> 00:16:37.370 
has several incoming edges and
several outgoing edges.

227
00:16:38.090 --> 00:16:41.950 
So now assume during the
review of the process we

228
00:16:41.950 --> 00:16:45.350 
find that well D and E should not
be executed concurrently but

229
00:16:45.350 --> 00:16:52.070 
D and E should be executed alternatively
either D or E. So well we can

230
00:16:52.460 --> 00:16:56.100 
we can easily do that and try to use
the erasor now to change that well

231
00:16:56.330 --> 00:16:58.950 
that should not
be an AND

232
00:16:59.860 --> 00:17:03.580 
split and that should not
be an AND joined but that

233
00:17:04.670 --> 00:17:08.240 
should be
oh sorry

234
00:17:09.200 --> 00:17:12.400 
that should be I need to
erase it again.

235
00:17:15.100 --> 00:17:17.510 
That should be
an XOR split

236
00:17:18.250 --> 00:17:21.660 
and that should be in XOR
join. So wonderful. So we

237
00:17:22.100 --> 00:17:25.190 
made sure that either D
or E is being executed.

238
00:17:26.260 --> 00:17:30.460 
But what happens by that by
changing of this of the

239
00:17:30.460 --> 00:17:34.970 
behavior of this gateway? We also
affect the first part of the

240
00:17:34.970 --> 00:17:40.100 
process in the sense that in this case
B and C are executed concurrently

241
00:17:40.380 --> 00:17:46.260 
and each of them B and C both trigger
the gateway. So the last part,

242
00:17:46.410 --> 00:17:49.910 
so these part of the process is
executed actually twice. The

243
00:17:49.910 --> 00:17:51.810 
first time after
B completes

244
00:17:52.670 --> 00:17:55.290 
and the second time after
C completes. So we have two

245
00:17:55.710 --> 00:18:00.550 
we can have two
executions of D, two executions

246
00:18:00.550 --> 00:18:05.300 
of E or one of both. So and that
of course is undesired behavior.

247
00:18:05.620 --> 00:18:08.350 
If the change is the other
way around if I change the

248
00:18:08.360 --> 00:18:11.840 
first AND to an XOR then we
have a deadlock situation. So

249
00:18:11.840 --> 00:18:13.920 
we have a behavior
mismatch.

250
00:18:14.600 --> 00:18:18.650 
So let's say behavior that we do not
desire in our process model.

251
00:18:19.270 --> 00:18:24.130 
So it's a good idea to avoid mixed
gateways and in the first case well

252
00:18:24.260 --> 00:18:26.560 
we just can have one

253
00:18:28.360 --> 00:18:33.000 
gateway AND gateway and then we
have that's the join gateway

254
00:18:34.450 --> 00:18:37.310 
and then we have a split gateway
and that of course can be also

255
00:18:38.580 --> 00:18:41.260 
and by let's say

256
00:18:41.920 --> 00:18:45.240 
by using two gateway symbols and
attaching them with sequence

257
00:18:45.240 --> 00:18:49.180 
flow we have the same behavior.
But we have for each concept

258
00:18:49.530 --> 00:18:52.580 
that we have in our process
model we have one element

259
00:18:52.580 --> 00:18:57.210 
that represents it, so one concept for joining
and one concept for splitting and these

260
00:18:57.370 --> 00:19:00.300 
are represented by two different
symbols in the process model.

261
00:19:00.520 --> 00:19:05.340 
It's always good to represent one
concept that from the original

262
00:19:05.340 --> 00:19:08.720 
from the domain I like to represent
by one element in the model.

263
00:19:10.580 --> 00:19:14.450 
That concludes video clip 2.4
in which we discussed

264
00:19:14.450 --> 00:19:18.230 
inclusive gateways and loops.
We discuss the split and

265
00:19:18.230 --> 00:19:22.310 
join behavior of the OR
gateway especially the OR join.

266
00:19:22.410 --> 00:19:26.480 
We spent some time discussing
this we have seen that we can

267
00:19:26.480 --> 00:19:31.420 
use a loop so we can use XOR splits
to express loops. We discussed

268
00:19:31.420 --> 00:19:36.220 
uncontrolled flow, also problems that are
related to uncontrolled flow and we

269
00:19:36.520 --> 00:19:40.520 
ended with modeling guidelines
related to gateways especially

270
00:19:40.820 --> 00:19:43.230 
related to mixed
gateways.
