WEBVTT

1
00:00:00.630 --> 00:00:02.572 
Hello, it's me again,

2
00:00:03.900 --> 00:00:06.479 
Wolfram Greis from the European Mainframe Academy.

3
00:00:06.480 --> 00:00:09.269 
In the next video clip, I want to give

4
00:00:09.270 --> 00:00:11.999 
an overview about

5
00:00:12.000 --> 00:00:14.729 
database history in general, and I want to talk

6
00:00:14.730 --> 00:00:17.609 
about the logical data models that

7
00:00:17.610 --> 00:00:19.529 
are in place today.

8
00:00:19.530 --> 00:00:22.229 
Let's start with the database history.

9
00:00:22.230 --> 00:00:24.839 
It began in the 1960s.

10
00:00:24.840 --> 00:00:27.509 
The hierarchical database I.M.S.

11
00:00:27.510 --> 00:00:30.989 
by IBM was invented and

12
00:00:30.990 --> 00:00:34.079 
released. And IMS is a typical

13
00:00:34.080 --> 00:00:37.289 
hierarchical database, means all the data

14
00:00:37.290 --> 00:00:40.019 
in the IMS database are

15
00:00:40.020 --> 00:00:43.439 
in a hierarchical order structured.

16
00:00:43.440 --> 00:00:45.450 
I will get back to that when I talk about

17
00:00:48.300 --> 00:00:50.759 
IMS in one of the next video clips.

18
00:00:50.760 --> 00:00:53.559 
In the 1970s, relational database

19
00:00:53.560 --> 00:00:55.349 
were invented.

20
00:00:55.350 --> 00:00:58.259 
Data is put into tables,

21
00:00:58.260 --> 00:01:01.169 
the data is normalized

22
00:01:01.170 --> 00:01:03.929 
and again 10 years later,

23
00:01:03.930 --> 00:01:06.629 
the RDBMS, Relational

24
00:01:06.630 --> 00:01:10.499 
Database Management Systems were commercialized.

25
00:01:10.500 --> 00:01:13.649 
SQL, the structured query language

26
00:01:13.650 --> 00:01:16.889 
became really important standard

27
00:01:16.890 --> 00:01:20.639 
and database transactions with

28
00:01:20.640 --> 00:01:23.339 
ACID properties were implemented and ACID

29
00:01:23.340 --> 00:01:27.449 
stands for Atomicity, Consistency,

30
00:01:27.450 --> 00:01:30.599 
Isolation and Duration.

31
00:01:30.600 --> 00:01:34.379 
It's really important to understand what

32
00:01:34.380 --> 00:01:37.289 
it means to have transactions.

33
00:01:37.290 --> 00:01:39.929 
Normally you have different steps belonging to a

34
00:01:39.930 --> 00:01:42.749 
transaction, and the idea is these

35
00:01:42.750 --> 00:01:44.099 
different steps may

36
00:01:45.720 --> 00:01:48.479 
only be executed in a whole

37
00:01:48.480 --> 00:01:51.809 
means, all steps or no step at all.

38
00:01:51.810 --> 00:01:54.569 
And this is defined

39
00:01:54.570 --> 00:01:57.479 
as the idea with these

40
00:01:57.480 --> 00:02:00.539 
ACID properties. We will get back to that

41
00:02:00.540 --> 00:02:02.999 
later when we talk about transactions.

42
00:02:05.190 --> 00:02:08.249 
In the 1990s, client-server came up

43
00:02:08.250 --> 00:02:11.109 
with distributed databases.

44
00:02:11.110 --> 00:02:14.489 
When we organized distributed databases,

45
00:02:14.490 --> 00:02:17.249 
we need to have a protocol

46
00:02:17.250 --> 00:02:20.309 
to assure the ACID properties also

47
00:02:20.310 --> 00:02:23.189 
in distributed environments, and this is done with

48
00:02:23.190 --> 00:02:25.829 
a two-phase commit protocol.

49
00:02:25.830 --> 00:02:28.529 
Internet came up with Web 2.0, social media

50
00:02:28.530 --> 00:02:29.849 
and so on.

51
00:02:29.850 --> 00:02:33.989 
And 10 years later in the 2000s,

52
00:02:33.990 --> 00:02:36.719 
now we have big data as

53
00:02:36.720 --> 00:02:39.739 
an extension or

54
00:02:39.740 --> 00:02:43.259 
another possibility to

55
00:02:43.260 --> 00:02:46.379 
deal with data, especially with really

56
00:02:46.380 --> 00:02:48.719 
big amounts of data about big data.

57
00:02:48.720 --> 00:02:51.689 
Not means really not just

58
00:02:51.690 --> 00:02:55.009 
big data, not just big volumes

59
00:02:55.010 --> 00:02:56.879 
as there are other important characteristics.

60
00:02:56.880 --> 00:03:00.119 
We get back to that later in a video clip.

61
00:03:00.120 --> 00:03:02.000 
Important set,

62
00:03:03.090 --> 00:03:05.610 
the idea of no

63
00:03:08.010 --> 00:03:11.069 
SQL. In the first times,

64
00:03:11.070 --> 00:03:14.009 
it really meant we don't want to

65
00:03:15.090 --> 00:03:17.669 
work with this data with SQL.

66
00:03:17.670 --> 00:03:19.979 
So that's why no SQL came into place.

67
00:03:19.980 --> 00:03:21.381 
The idea. But in between,

68
00:03:22.700 --> 00:03:25.319 
it has another meaning.

69
00:03:25.320 --> 00:03:28.019 
No SQL today means not only

70
00:03:28.020 --> 00:03:29.639 
SQL means

71
00:03:30.780 --> 00:03:33.899 
normally I think we should say big data

72
00:03:33.900 --> 00:03:36.599 
is non-relational data

73
00:03:36.600 --> 00:03:39.629 
and also non-relational-data can

74
00:03:39.630 --> 00:03:42.749 
be accessed with a SQL because

75
00:03:42.750 --> 00:03:45.869 
SQL, as I mentioned already, a very important

76
00:03:45.870 --> 00:03:48.929 
standard. So that's a quite interesting

77
00:03:48.930 --> 00:03:50.789 
website available.

78
00:03:50.790 --> 00:03:51.790 
It's called "nosql-database.org".

79
00:03:54.600 --> 00:03:56.819 
Very interesting to have a look into it.

80
00:03:56.820 --> 00:04:00.119 
And especially the idea of

81
00:04:00.120 --> 00:04:01.919 
the BASE properties.

82
00:04:01.920 --> 00:04:05.279 
BASE properties means basic availability,

83
00:04:05.280 --> 00:04:08.759 
means soft state and means eventual

84
00:04:08.760 --> 00:04:11.669 
consistent. And this is a really big

85
00:04:11.670 --> 00:04:14.699 
issue. Normally when we talk about financial

86
00:04:14.700 --> 00:04:17.489 
transactions and so on, we want to have consistency in

87
00:04:17.490 --> 00:04:18.509 
each and every

88
00:04:22.140 --> 00:04:24.899 
time frame and not just

89
00:04:24.900 --> 00:04:26.909 
eventual consistency.

90
00:04:26.910 --> 00:04:31.049 
We will get back to this idea in a later

91
00:04:31.050 --> 00:04:32.050 
video clip.

92
00:04:33.910 --> 00:04:36.160 
Let's talk about the logical data models.

93
00:04:37.630 --> 00:04:40.569 
It began, I already mentioned it, with a hierarchical

94
00:04:40.570 --> 00:04:42.279 
model, started in the 60s

95
00:04:44.380 --> 00:04:47.769 
and afterwards, the

96
00:04:47.770 --> 00:04:50.979 
second model was

97
00:04:50.980 --> 00:04:53.769 
invented. The network model

98
00:04:53.770 --> 00:04:55.569 
also called the

99
00:04:56.770 --> 00:04:59.529 
CODASYL Model, with some implementations as

100
00:04:59.530 --> 00:05:02.679 
example, UDS from Fujitsu,

101
00:05:02.680 --> 00:05:03.879 
Siemens, A.I.M.

102
00:05:03.880 --> 00:05:06.576 
from Fujitsu, IDMS from Cullinet

103
00:05:06.577 --> 00:05:09.099 
in between Computer Associates and so on.

104
00:05:09.100 --> 00:05:10.809 
There were really some

105
00:05:13.180 --> 00:05:16.329 
models working with this network

106
00:05:16.330 --> 00:05:17.709 
structure.

107
00:05:17.710 --> 00:05:21.159 
And the relational models started in the 80s.

108
00:05:21.160 --> 00:05:24.519 
And this is a model which

109
00:05:24.520 --> 00:05:26.949 
got really big interest in between.

110
00:05:26.950 --> 00:05:29.709 
So most of the database

111
00:05:29.710 --> 00:05:32.589 
implementations today work with relational

112
00:05:32.590 --> 00:05:36.009 
model. We have also an object-oriented

113
00:05:36.010 --> 00:05:37.299 
model in between.

114
00:05:37.300 --> 00:05:41.019 
But in my opinion, that's not really

115
00:05:41.020 --> 00:05:43.423 
important and widespread in

116
00:05:45.790 --> 00:05:46.899 
production environments.

117
00:05:48.250 --> 00:05:51.129 
We have big data model and No SQL, I already

118
00:05:51.130 --> 00:05:53.859 
mentioned, it's really important also

119
00:05:53.860 --> 00:05:56.889 
to think and implement such

120
00:05:56.890 --> 00:05:58.839 
kind of models.

121
00:05:58.840 --> 00:06:01.869 
But sometimes we hear

122
00:06:01.870 --> 00:06:03.592 
a quote said the

123
00:06:04.630 --> 00:06:07.359 
relational database model comes to

124
00:06:08.860 --> 00:06:11.649 
its end. And in future, we will all do

125
00:06:11.650 --> 00:06:14.649 
with big data model and No SQL.

126
00:06:14.650 --> 00:06:16.779 
In my opinion, that's nonsense.

127
00:06:16.780 --> 00:06:19.539 
In future, we will have these both

128
00:06:19.540 --> 00:06:22.569 
kind of databases in parallel

129
00:06:22.570 --> 00:06:24.850 
and each and every of these

130
00:06:25.930 --> 00:06:27.699 
has its strengths.

131
00:06:27.700 --> 00:06:30.729 
So in future, we will see a big

132
00:06:30.730 --> 00:06:34.389 
mixture of RDBMS, relational

133
00:06:34.390 --> 00:06:37.329 
database management systems and big data

134
00:06:37.330 --> 00:06:39.069 
environments.

135
00:06:39.070 --> 00:06:42.069 
Let's have a look at these data models.

136
00:06:42.070 --> 00:06:45.279 
This is a hierarchical model and

137
00:06:45.280 --> 00:06:48.399 
as you see and that's where the name came from,

138
00:06:48.400 --> 00:06:51.639 
it's the hierarchical organization

139
00:06:51.640 --> 00:06:54.579 
of data and

140
00:06:54.580 --> 00:06:57.129 
with one exception, the root element.

141
00:06:57.130 --> 00:06:59.949 
Each and every data element has just one

142
00:06:59.950 --> 00:07:03.339 
parent element, and it has really

143
00:07:03.340 --> 00:07:05.109 
big advantages.

144
00:07:05.110 --> 00:07:08.439 
Hierarchical model normally is a programmatic

145
00:07:08.440 --> 00:07:10.410 
model. It means the

146
00:07:12.730 --> 00:07:15.819 
customers program

147
00:07:15.820 --> 00:07:18.490 
and build their applications with

148
00:07:21.730 --> 00:07:23.259 
computer languages.

149
00:07:23.260 --> 00:07:26.109 
And if such a model

150
00:07:26.110 --> 00:07:28.929 
was implemented with a program, the

151
00:07:28.930 --> 00:07:32.019 
access to this data is very, very

152
00:07:32.020 --> 00:07:34.959 
fast. This is the main advantage

153
00:07:34.960 --> 00:07:36.429 
of the hierarchical model.

154
00:07:36.430 --> 00:07:39.429 
And this is why today we have

155
00:07:39.430 --> 00:07:42.309 
still many sites,

156
00:07:42.310 --> 00:07:45.049 
where the hierarchical model with

157
00:07:45.050 --> 00:07:48.519 
the implementation in most cases, IMS from IBM

158
00:07:48.520 --> 00:07:51.339 
is still in place because it had a really,

159
00:07:51.340 --> 00:07:54.339 
really good performance, especially

160
00:07:54.340 --> 00:07:58.029 
for the applications that were programmed

161
00:07:58.030 --> 00:08:01.059 
to access these data in this hierarchical

162
00:08:01.060 --> 00:08:02.060 
order.

163
00:08:02.590 --> 00:08:05.589 
We already talked about the network model, also

164
00:08:05.590 --> 00:08:08.319 
known as CODASYL model, where

165
00:08:08.320 --> 00:08:11.139 
each and every data element

166
00:08:11.140 --> 00:08:13.989 
has not just one parent

167
00:08:13.990 --> 00:08:17.319 
element we can have different

168
00:08:17.320 --> 00:08:18.370 
pointers to

169
00:08:20.230 --> 00:08:22.839 
other elements. And this is the idea.

170
00:08:22.840 --> 00:08:25.269 
That's why it's called the network model.

171
00:08:26.610 --> 00:08:29.799 
In between, we have all those relational

172
00:08:29.800 --> 00:08:32.739 
model. Relational model means all the data

173
00:08:32.740 --> 00:08:35.109 
is put into tables.

174
00:08:35.110 --> 00:08:38.229 
And another very important

175
00:08:38.230 --> 00:08:41.038 
issue, when we talk about relational models, it's

176
00:08:41.039 --> 00:08:44.048 
the so-called structured query language to access

177
00:08:44.049 --> 00:08:46.869 
data in these tables.

178
00:08:46.870 --> 00:08:49.569 
And the advantage of the relational model

179
00:08:49.570 --> 00:08:53.259 
is really, really big flexibility

180
00:08:53.260 --> 00:08:56.409 
and quite easy idea

181
00:08:56.410 --> 00:08:59.169 
of this structured query language.

182
00:08:59.170 --> 00:09:02.109 
So you can really have ad-hoc

183
00:09:02.110 --> 00:09:05.799 
request into your database environment

184
00:09:05.800 --> 00:09:07.720 
with such

185
00:09:09.610 --> 00:09:11.607 
structured query language

186
00:09:13.420 --> 00:09:14.420 
executions.

187
00:09:15.430 --> 00:09:18.609 
The disadvantage

188
00:09:18.610 --> 00:09:21.309 
of the relational model, I think it

189
00:09:21.310 --> 00:09:24.219 
can be seen with these pictures

190
00:09:24.220 --> 00:09:26.979 
of the models is with relational models and

191
00:09:26.980 --> 00:09:29.919 
all the data is put into tables.

192
00:09:29.920 --> 00:09:32.368 
You have to load these tables into storage.

193
00:09:33.830 --> 00:09:36.559 
When working with the data and this

194
00:09:36.560 --> 00:09:39.649 
needs a lot of resources, especially

195
00:09:39.650 --> 00:09:42.859 
a lot of memory and also

196
00:09:42.860 --> 00:09:46.069 
a lot of computer power

197
00:09:46.070 --> 00:09:48.799 
to access this data within

198
00:09:48.800 --> 00:09:50.539 
these tables.

199
00:09:50.540 --> 00:09:53.389 
So the advantage, flexibility, this

200
00:09:53.390 --> 00:09:56.539 
advantage, much more

201
00:09:56.540 --> 00:09:59.779 
resource consumption

202
00:09:59.780 --> 00:10:02.449 
when we work with relational models.

203
00:10:02.450 --> 00:10:05.269 
Just know a few about

204
00:10:05.270 --> 00:10:06.799 
these models.

205
00:10:06.800 --> 00:10:09.499 
And I will get back especially to

206
00:10:09.500 --> 00:10:12.979 
the hierarchical model and in our case,

207
00:10:12.980 --> 00:10:14.839 
implementation with I.M.S.

208
00:10:14.840 --> 00:10:16.519 
and so relational model.

209
00:10:16.520 --> 00:10:17.625 
And when you talk about

210
00:10:20.960 --> 00:10:23.839 
IBM mainframe environments, we talk about

211
00:10:23.840 --> 00:10:26.659 
Db2, when it comes to the relational model.

212
00:10:28.970 --> 00:10:32.029 
As ever, for any questions and remarks, please use

213
00:10:32.030 --> 00:10:34.580 
the discussion forum on

214
00:10:35.660 --> 00:10:38.329 
our openHPI platform.

215
00:10:38.330 --> 00:10:39.949 
Thank you very much for attending.

216
00:10:39.950 --> 00:10:42.800 
And see you in the next video clip.
