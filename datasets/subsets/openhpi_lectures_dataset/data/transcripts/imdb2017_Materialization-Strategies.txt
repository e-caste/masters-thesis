WEBVTT

1
00:00:01.000 --> 00:00:14.000 
The last basic operation we can perform on
relational tables is aggregation on top of

2
00:00:14.000 --> 00:00:22.000 
a table. There are nicely done here two examples
of early materialization and late materialization.

3
00:00:22.000 --> 00:00:30.000 
Since we have everything coded in integers,
in columns, in a column store, we do late

4
00:00:30.000 --> 00:00:39.000 
materialization and we can just jump in how
this works. Basically you should know already

5
00:00:39.000 --> 00:00:40.000 
how it works

6
00:00:40.000 --> 00:00:47.000 
We want to do this here: SELECT city, COUNT(*)
FROM world_population WHERE gender =”m”

7
00:00:47.000 --> 00:00:56.000 
AND country=”GER” GROUP BY city. If we
walk through playing on a LEGO-Level of the

8
00:00:56.000 --> 00:01:22.000 
system then we do parallel; we learned already
we should do it the other way; […].

9
00:01:22.000 --> 00:01:31.000 
So we should do this first here with the predicate
“GER” we go in, lookup, find GER is 68

10
00:01:31.000 --> 00:01:38.000 
in the dictionary and we have a ValueID 68.
We do the same with “m” (male), look it

11
00:01:38.000 --> 00:01:40.000 
up and we get 0.

12
00:01:40.000 --> 00:01:50.000 
We have two results, we have four Germans
and these are the males. And we can AND them

13
00:01:50.000 --> 00:01:58.000 
now and so the remaining position vector is
1-4.

14
00:01:58.000 --> 00:02:06.000 
Whether this is done in parallel or whether
both vectors are created and then ANDed; it’s

15
00:02:06.000 --> 00:02:11.000 
a minor implementation issue. We continue
now.

16
00:02:11.000 --> 00:02:21.000 
After we have this, we apply this now on the
vector of city and count now for the ones

17
00:02:21.000 --> 00:02:29.000 
1, 2 and 4 how many are in 443 and how many
are in 357. 1 and 2.

18
00:02:29.000 --> 00:02:36.000 
And the last one is we materialize now back
1 and 2, we look it up and we find as Bonn

19
00:02:36.000 --> 00:02:41.000 
and Berlin and the real result is now Bonn:
1 and Berlin: 2.

20
00:02:41.000 --> 00:02:53.000 
This is how the machine works: tuck, tuck,
tuck, tuck. And each tuck is one 2.5 billionth

21
00:02:53.000 --> 00:03:00.000 
of a second. This is the speed with which
the machine is working. And again you can

22
00:03:00.000 --> 00:03:09.000 
see if we can distinguish the Berliners out
the 8 billion using an index as a huge advantage,

23
00:03:09.000 --> 00:03:14.000 
if we have to go through all 8 billion to
find the Berliners, it is four times slower

24
00:03:14.000 --> 00:05:14.000 
on average.
