WEBVTT

1
00:00:00.760 --> 00:00:05.390 
This is knowledge graphs lecture
two basic semantic technologies.

2
00:00:06.310 --> 00:00:11.670 
In this part of the lecture we will talk
about more complex rdf data structures.

3
00:00:13.000 --> 00:00:17.710 
We are still on the level of rdf in the
semantic web technologies, there can't our

4
00:00:17.870 --> 00:00:22.930 
examples as you might know they refer
to basically greenhouse effect

5
00:00:23.150 --> 00:00:27.520 
and climate change simply since
it's an important topic.

6
00:00:28.520 --> 00:00:33.170 
ok what kind of complex data
structures are we talking about?

7
00:00:34.000 --> 00:00:39.160 
There are so called rdf lists in the
first place. What you can do with this?

8
00:00:39.280 --> 00:00:43.940 
You can somehow aggregate or
enumerate any resources or literals.

9
00:00:44.870 --> 00:00:48.350 
Please keep in mind that exactly
these kind of lists do not

10
00:00:48.360 --> 00:00:53.100 
generate any new semantics. It's just some
kind of syntactic sugar which means

11
00:00:53.400 --> 00:00:59.460 
it's a way or a helper construct
that helps us to do this kind

12
00:00:59.460 --> 00:01:03.630 
of enumerations and then also
to talk about you know these

13
00:01:03.630 --> 00:01:05.430 
enumerations as a whole.

14
00:01:06.230 --> 00:01:09.950 
So this is what we can do with
the help of so called rdf lists.

15
00:01:10.770 --> 00:01:15.570 
And rdf distinguishes between two
different variants of these lists.

16
00:01:15.800 --> 00:01:19.160 
So first of all there are
the so called containers.

17
00:01:19.730 --> 00:01:26.900 
Containers are open. This means an extension
with new entries is always possible.

18
00:01:27.950 --> 00:01:31.540 
On the other hand we have the so called
collections and collections are

19
00:01:31.830 --> 00:01:35.780 
as you might expect then closed
lists. So they are defined once

20
00:01:35.780 --> 00:01:39.380 
and then further on there is no
further extension possible.

21
00:01:39.810 --> 00:01:43.950 
So that's the difference between
containers and collections

22
00:01:44.180 --> 00:01:48.290 
and there might be situations when
both of them are somehow useful.

23
00:01:49.230 --> 00:01:53.900 
Let us start first with the
open list. So rdf containers.

24
00:01:54.590 --> 00:01:57.430 
Here we have the example that
we want to define a container

25
00:01:57.430 --> 00:02:02.040 
for greenhouse gases and then of
course want to enumerate all

26
00:02:02.040 --> 00:02:05.570 
the greenhouse gases that belong
exactly to that container

27
00:02:05.570 --> 00:02:11.300 
which might be water vapor, carbon
dioxide, methane, nitrous oxide,

28
00:02:11.310 --> 00:02:12.830 
ozone and so
on and so on.

29
00:02:13.440 --> 00:02:16.040 
So these are
greenhouse gases.

30
00:02:16.640 --> 00:02:20.080 
How do I encode that? You see the
structure here, so this is an

31
00:02:20.190 --> 00:02:22.190 
interesting structure
where you say okay,

32
00:02:23.490 --> 00:02:27.290 
greenhouse gases contained
something which is then a blank

33
00:02:27.290 --> 00:02:31.360 
node of type rdf bag which
is a specific container.

34
00:02:31.880 --> 00:02:37.160 
Containers can be for example bags which
define an unordered set of things

35
00:02:37.520 --> 00:02:42.750 
or they can be of type SEQ which
stands for sequential, so there

36
00:02:42.980 --> 00:02:46.790 
the sequence of course does matter.
So we have there an ordered list.

37
00:02:47.090 --> 00:02:51.960 
Or it can be ALT which means
this defines alternatives, which

38
00:02:51.960 --> 00:02:55.930 
means only one of these mentioned
things always counts for

39
00:02:55.930 --> 00:02:59.120 
a statement and I can
select this arbitrarily.

40
00:03:00.750 --> 00:03:06.450 
In our case we have a bag which is a
container a set of unordered items.

41
00:03:07.130 --> 00:03:11.780 
And then the container which is here
blank node has to be connected

42
00:03:11.780 --> 00:03:14.830 
with its content
and this here is

43
00:03:15.510 --> 00:03:20.930 
simply enumerated with properties and there
is an of course then infinitive number

44
00:03:21.170 --> 00:03:25.150 
infinite number of properties
underscore one underscore two

45
00:03:25.150 --> 00:03:29.790 
underscore three and so on and
so on for all of the things

46
00:03:29.790 --> 00:03:31.910 
which might be part
of that container.

47
00:03:32.610 --> 00:03:37.240 
There is this distinction in the
properties simply because you are also

48
00:03:37.380 --> 00:03:41.680 
able to express that there might
be a sequence. If there is

49
00:03:41.680 --> 00:03:44.550 
a sequence of course they are
written from one two three four

50
00:03:44.550 --> 00:03:48.360 
five and so on and you can define the
sequence by defining that

51
00:03:48.630 --> 00:03:50.880 
that container
accordingly.

52
00:03:51.960 --> 00:03:56.250 
However with a bag, you not
necessarily are dependent on that

53
00:03:56.250 --> 00:03:59.280 
sequence that you define here
because you say yeah we don't

54
00:03:59.280 --> 00:04:04.770 
matter. So this is not a sequence and it can
be read in an unordered way arbitrarily.

55
00:04:05.340 --> 00:04:10.520 
Okay so this is a container within
its graph representation.

56
00:04:11.080 --> 00:04:15.060 
Of course we want to represent that
stuff now also in rdf turtle.

57
00:04:15.270 --> 00:04:16.800 
So how does it
look like here?

58
00:04:17.450 --> 00:04:23.020 
So we define here greenhouse gases and we
say greenhouse gases contained something

59
00:04:23.170 --> 00:04:26.350 
which is as we already see here
a blank node, so we are using

60
00:04:26.350 --> 00:04:30.770 
again the square brackets as we have
learned in the last part of the lecture.

61
00:04:32.270 --> 00:04:36.280 
Then first we have to say yes
this is a container. So this is

62
00:04:36.280 --> 00:04:40.780 
of type rdf bag and here you learn
a new abbreviation that is also

63
00:04:40.940 --> 00:04:48.570 
possible in turtle, instead of simply using
rdf type as a property that states that

64
00:04:48.770 --> 00:04:54.650 
some instance is element
of a specific class,

65
00:04:55.540 --> 00:05:00.970 
you say the word A. So the literal
A here simply states that

66
00:05:01.270 --> 00:05:03.660 
this replaces rdf type.

67
00:05:04.280 --> 00:05:07.220 
So this is the same, this is rdf
turtle language definition,

68
00:05:07.370 --> 00:05:11.850 
and of course it reads much shorter
because it says something like this is

69
00:05:12.240 --> 00:05:13.210 
a rdf bag.

70
00:05:14.440 --> 00:05:20.630 
Okay. However there are more
property object pairs following

71
00:05:20.630 --> 00:05:24.390 
here for that container. So then
you have rdf underscore one,

72
00:05:25.310 --> 00:05:30.130 
for water vapor, then you have rdf
underscored two for carbon dioxide

73
00:05:30.330 --> 00:05:33.530 
and so on and so on and so on
and you stop at a

74
00:05:33.530 --> 00:05:37.140 
certain point. And it's an open list
so if you want to extend this list

75
00:05:37.590 --> 00:05:42.270 
then you simply use the next
number in sequence, you use the

76
00:05:42.270 --> 00:05:47.170 
namespace rdf and then underscore
and the next number would

77
00:05:47.180 --> 00:05:51.260 
be eight and then you would add
an eighth greenhouse gas.

78
00:05:52.310 --> 00:05:57.390 
It's as simple as that, so this is an
open list in rdf called rdf container

79
00:05:57.550 --> 00:06:02.380 
that later on can be referenced
and that can be used for any

80
00:06:02.380 --> 00:06:04.230 
kind of purpose that
you have in mind.

81
00:06:07.090 --> 00:06:11.580 
Next then there are the closed
lists which as we have already

82
00:06:11.580 --> 00:06:14.180 
stated cannot be
extended anymore. So let's

83
00:06:16.460 --> 00:06:21.200 
define or represent the same
thing greenhouse gases now with

84
00:06:21.200 --> 00:06:25.740 
the closed list that we have to keep
in mind cannot be further extended.

85
00:06:26.710 --> 00:06:29.160 
So this looks a bit
complicated I agree.

86
00:06:29.710 --> 00:06:34.260 
But the computer scientists among
you for them it might look

87
00:06:34.260 --> 00:06:38.520 
somehow familiar because this
closely resembles to how we define

88
00:06:38.520 --> 00:06:44.050 
so called sequence lists in
programming, or if you know a bit

89
00:06:44.050 --> 00:06:47.870 
about artificial intelligence and
symbolic representation there

90
00:06:48.120 --> 00:06:52.690 
the programming language lisp
also makes use of these kind

91
00:06:52.690 --> 00:06:55.080 
of sequential lists.
How does this work?

92
00:06:55.780 --> 00:06:59.880 
Each sequential list usually
is defined as having a head

93
00:07:00.290 --> 00:07:04.530 
and a tail, and the head element
is the first element in the list

94
00:07:04.960 --> 00:07:09.290 
and the tail then is recursively
defined in the same way that

95
00:07:09.290 --> 00:07:14.100 
also the tail is constituent or
constituted by a head element

96
00:07:14.430 --> 00:07:15.990 
and the rest which
is the tail.

97
00:07:16.680 --> 00:07:19.930 
And you do this further, further,
further, further recursively

98
00:07:19.930 --> 00:07:24.560 
until the list ends and then you
say okay and then the rest of

99
00:07:24.560 --> 00:07:28.290 
your list simply points to a null
element and this here would

100
00:07:28.290 --> 00:07:33.870 
in our case be rdf nil, so it's
the nil element it points to.

101
00:07:34.310 --> 00:07:38.810 
It's a complicated way to define
exactly that kind of structure but it

102
00:07:39.050 --> 00:07:42.480 
has its roots in computer
science of course.

103
00:07:43.970 --> 00:07:48.120 
So how do we now represent exactly
this interesting structure in turtle?

104
00:07:49.260 --> 00:07:52.660 
You might of course translate it
literally one by one

105
00:07:53.100 --> 00:07:56.380 
but then as you see here you end
up in a nested structure like

106
00:07:56.380 --> 00:07:59.650 
that and this of course is really
really painful to write and

107
00:07:59.650 --> 00:08:03.320 
define stuff like that, because
then you have really mountains

108
00:08:03.320 --> 00:08:06.670 
of these square brackets that
have to be closed again.

109
00:08:07.730 --> 00:08:14.660 
Simply for that reason there is a very
nice abbreviation available in turtle

110
00:08:14.950 --> 00:08:20.250 
which says okay we have not used all of
the potentially usable brackets so far.

111
00:08:20.570 --> 00:08:23.340 
Now let's simply
use parentheses,

112
00:08:24.070 --> 00:08:29.840 
and if you use parentheses
parentheses are used here to define

113
00:08:29.870 --> 00:08:33.020 
rdf collections and then
it's really really easy. You

114
00:08:33.020 --> 00:08:37.590 
say again greenhouse gas contains
something and now you contain

115
00:08:37.610 --> 00:08:42.610 
you define and represent your
collection in the following

116
00:08:42.610 --> 00:08:47.010 
way that you use parentheses and within
the parentheses you simply enumerate

117
00:08:47.600 --> 00:08:52.170 
all the elements which are part of your
collection. And keep in mind here

118
00:08:52.380 --> 00:08:55.800 
you don't separate them anymore.
You simply have one element

119
00:08:55.800 --> 00:08:59.150 
after the other and you
separate them by a blank.

120
00:08:59.820 --> 00:09:03.580 
That's it and you close the
parentis as you make your period

121
00:09:03.580 --> 00:09:07.950 
because to triple ends and this
is your entire collection.

122
00:09:09.080 --> 00:09:11.190 
This is of course now
really really simple.

123
00:09:12.150 --> 00:09:15.220 
It's also clear how it can be
interpreted, so it's simply a

124
00:09:15.220 --> 00:09:20.400 
collection of things which cannot be further
extended but of course its implementation

125
00:09:20.610 --> 00:09:24.880 
somehow reflects to what you see here in
the graph or in the more complicated

126
00:09:25.120 --> 00:09:33.060 
rdf statement that you see in gray here.
So these are rdf containers and rdf

127
00:09:33.280 --> 00:09:34.080 
collections.

128
00:09:37.290 --> 00:09:40.370 
This is already quite nice but
there is another thing I wanted

129
00:09:40.370 --> 00:09:43.340 
to mention as one of the complex
constructs which is really

130
00:09:43.340 --> 00:09:47.400 
also important in rdf, and this
is of course something which

131
00:09:47.400 --> 00:09:51.380 
is referred to as so called verification.
Just imagine the following case.

132
00:09:52.810 --> 00:09:55.800 
There is the fact of course that
carbon dioxide has been discovered

133
00:09:55.800 --> 00:09:59.980 
by the dutch guy, but of course
if we have this fact we want

134
00:09:59.980 --> 00:10:02.480 
of course to know can
we trust that fact?

135
00:10:03.300 --> 00:10:09.560 
If wikipedia says so we might trust
it. So how do we know represent

136
00:10:09.560 --> 00:10:14.860 
the fact that dbpedia states that
carbon dioxide has been discovered

137
00:10:14.860 --> 00:10:16.490 
by Jan Baptist
van Helmont?

138
00:10:17.480 --> 00:10:20.140 
Ok that's kind of a problem
that we have to solve.

139
00:10:21.560 --> 00:10:26.400 
Fortunately rdf provides the
concept of verification for us.

140
00:10:26.520 --> 00:10:30.670 
So it permits the interleaving
of statements, which means to

141
00:10:30.670 --> 00:10:34.180 
make statements about statements.
So we want to express wikipedia

142
00:10:34.180 --> 00:10:37.610 
states that carbon dioxide was
discovered by Jan Baptist
van Helmont.

143
00:10:38.590 --> 00:10:42.050 
Part one of these statements is
quite easy. So we can simply

144
00:10:42.050 --> 00:10:45.740 
translate carbon dioxide was discovered
by Jan Baptist van Helmont

145
00:10:45.980 --> 00:10:50.780 
with the triple that carbon dioxide
discovered by Jan Baptist
van Helmont.

146
00:10:51.020 --> 00:10:55.860 
That's easy now we have the first part
of the sentence wikipedia states.

147
00:10:55.970 --> 00:11:00.560 
Yeah ok we can say wikipedia
states, so now what does it state?

148
00:11:00.570 --> 00:11:03.900 
We cannot now simply continue with
the following or subsequent

149
00:11:03.900 --> 00:11:06.360 
three triples because then
we would have a quintuple

150
00:11:06.890 --> 00:11:09.590 
and how to interpret that? That
would be really strange.

151
00:11:10.220 --> 00:11:16.190 
So what we need is we need some concept
or let's say some representation method

152
00:11:16.420 --> 00:11:20.450 
that allows us to address
an entire rdf statement

153
00:11:20.950 --> 00:11:24.030 
as being an instance of
something, as an entity.

154
00:11:25.110 --> 00:11:28.960 
And this is what exactly reification
allows. So there is a new

155
00:11:28.960 --> 00:11:31.780 
construct which is
called rdf statement.

156
00:11:32.420 --> 00:11:37.310 
So and this again defines an rdf
triple and for that I can

157
00:11:37.310 --> 00:11:41.210 
say this statement is connected to a
subject and then I give the subject

158
00:11:41.430 --> 00:11:45.440 
this statement is connected to a
predicate which is then the property.

159
00:11:45.700 --> 00:11:50.110 
This statement is connected to an
object, which is then the object.

160
00:11:51.230 --> 00:11:54.910 
So the value of the property. So
in the end what you have here,

161
00:11:55.120 --> 00:11:58.190 
you have an rdf statement that
we define and the statement

162
00:11:58.190 --> 00:12:01.280 
should contain that carbon dioxide
was discovered by Jan Baptist

163
00:12:01.280 --> 00:12:04.750 
van Helmont, so we give it
accordingly a subject,

164
00:12:05.170 --> 00:12:09.350 
a predicate and an object. So again
here predicate and property

165
00:12:09.350 --> 00:12:14.490 
are somehow intermixed but later on
when we do rdfs you will see why

166
00:12:14.630 --> 00:12:19.610 
property and predicate in rdf or
rdfs there is a distinction.

167
00:12:19.610 --> 00:12:23.090 
So they should not be intermix
so here predicate is only used

168
00:12:23.090 --> 00:12:27.230 
for the rdf statement and reification
construct, keep this in mind.

169
00:12:29.290 --> 00:12:35.070 
Ok so this now is the complete construct
which means wikipedia states something.

170
00:12:35.750 --> 00:12:39.810 
We call it wiki statement
which is of type rdf statement.

171
00:12:39.810 --> 00:12:40.970 
So this is a statement

172
00:12:41.580 --> 00:12:46.520 
and exactly this wiki statement has
a subject, a predicate and an object

173
00:12:46.630 --> 00:12:51.060 
and this is of course subject is carbon
dioxide, predicate is discovered by

174
00:12:51.190 --> 00:12:54.040 
and the object is Jan Baptist van Helmont.

175
00:12:55.120 --> 00:12:59.050 
Now let's write this in turtle.
And we see here, we define

176
00:12:59.530 --> 00:13:04.070 
wikipedia states a wiki statement
and we say the wiki statement

177
00:13:04.530 --> 00:13:09.190 
is of course a statement, it has a subject
which is carbon dioxide, it has a predicate

178
00:13:09.310 --> 00:13:13.740 
which is discovered by and it has
an object which is Jan Baptist
179
00:13:13.900 --&gt; 00:13:17.360
van Helmont. So this
is reification.

180
00:13:19.030 --> 00:13:24.570 
Now you might ask, so for what uses it? So
what's the use of reification?

181
00:13:24.950 --> 00:13:29.130 
It's quite simple. So if you want to model
data provenance who has said what

182
00:13:29.580 --> 00:13:33.260 
at what time if you want to give
metadata about the statement

183
00:13:33.260 --> 00:13:37.290 
then this is of course a really
important concept because you want to

184
00:13:37.890 --> 00:13:42.430 
know how reliable is a statement,
you want to know can I trust

185
00:13:42.430 --> 00:13:45.790 
that statement or not. It makes a
difference if let's say John

186
00:13:45.790 --> 00:13:49.120 
Smith had said something on the
web or whether you really find

187
00:13:49.120 --> 00:13:52.950 
it in wikipedia where lots of others
have either confirmed it or not.

188
00:13:53.260 --> 00:13:56.300 
So this makes a difference you
want to know who said something.

189
00:13:56.520 --> 00:14:02.140 
And for that for expressing provenance
this concept of reification really

190
00:14:02.350 --> 00:14:07.170 
is important. However, I always
say however sorry. So however

191
00:14:07.170 --> 00:14:08.490 
you should be careful.

192
00:14:09.320 --> 00:14:15.960 
Why? What you do here is to
transform a relations or property

193
00:14:16.150 --> 00:14:20.870 
and also classes for example
into instances and potentially

194
00:14:21.040 --> 00:14:25.520 
this might result in type conflicts
later on. So this is a bit tricky

195
00:14:26.310 --> 00:14:30.790 
but it's far more dangerous that
by defining these reified

196
00:14:30.790 --> 00:14:34.040 
statements you might end up
in an infinite recursion

197
00:14:34.490 --> 00:14:38.640 
because of course you can make
a statement also subject or

198
00:14:38.640 --> 00:14:43.790 
property within your reification
and if this is somehow self

199
00:14:44.290 --> 00:14:49.280 
reflective then you end up in an
infinite recursion which is

200
00:14:49.280 --> 00:14:53.580 
a cycle and of course then any
kind of parser or reasoner which

201
00:14:53.580 --> 00:14:58.710 
is of course making use of that kind of
concept will run into an infinite loop.

202
00:14:59.410 --> 00:15:02.850 
Thereby you break the system and
it's not computable anymore.

203
00:15:03.260 --> 00:15:09.210 
So these are the drawbacks. However
it's quite useful thing.

204
00:15:10.810 --> 00:15:16.230 
So much for rdf. What we want to
do next is we want to model

205
00:15:16.240 --> 00:15:23.240 
our own rdf vocabulary and for
that we are using rdfs which is rdf

206
00:15:23.380 --> 00:15:24.040 
schema.
