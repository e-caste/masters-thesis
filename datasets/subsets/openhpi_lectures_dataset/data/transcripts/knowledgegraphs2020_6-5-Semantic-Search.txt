WEBVTT

1
00:00:01.180 --> 00:00:05.910 
This is knowledge graphs lecture number six
"Advanced Knowledge Graph Applications".

2
00:00:06.590 --> 00:00:10.670 
In this part of the lecture we
will talk about semantic search.

3
00:00:10.670 --> 00:00:15.210 
There is one special and rather important
application of knowledge graphs.

4
00:00:16.480 --> 00:00:19.810 
You all know the information
retrieval dilemma. We have spoken

5
00:00:19.810 --> 00:00:22.660 
about it right in the
beginning of this lecture.

6
00:00:23.130 --> 00:00:27.610 
You see here or you can assume
for what kind of concept

7
00:00:28.430 --> 00:00:29.960 
the user was
looking here.

8
00:00:30.740 --> 00:00:35.420 
In a traditional search engine it's
clear that this concept of course

9
00:00:35.530 --> 00:00:40.220 
is either a car or a beast but
of course it shares the same

10
00:00:40.220 --> 00:00:42.510 
term, the same name.
So it's a jaguar

11
00:00:44.320 --> 00:00:48.610 
which means we all know that
natural language is ambiguous.

12
00:00:48.620 --> 00:00:52.470 
So this problem is also referred
to polysemy, for example

13
00:00:53.090 --> 00:00:56.930 
and also different words or
expressions stand for the same

14
00:00:56.930 --> 00:01:01.230 
concept. So you have synonyms,
metaphors and paraphrases. So this

15
00:01:01.870 --> 00:01:05.650 
in general for natural language
is referred to as paraphrasing.

16
00:01:05.920 --> 00:01:12.410 
And simply because we do not have this
unique one to one relation between

17
00:01:12.800 --> 00:01:15.010 
the word or symbol
of a language

18
00:01:16.260 --> 00:01:18.900 
into an entity of a
knowledge base,

19
00:01:19.980 --> 00:01:24.780 
yeah, it becomes difficult
especially for search engines. So

20
00:01:24.780 --> 00:01:27.120 
in the process of
information retrieval.

21
00:01:28.390 --> 00:01:31.950 
First let's have a look at the general
information which we will process.

22
00:01:32.730 --> 00:01:35.620 
How does it work? So usually
everything is centred around a

23
00:01:35.620 --> 00:01:39.080 
huge store of documents that can
be web documents, that can

24
00:01:39.080 --> 00:01:43.590 
also be any other kind of documents and
from that document store first if

25
00:01:43.980 --> 00:01:47.540 
the search engine looks at the
content, which is in this case

26
00:01:47.540 --> 00:01:52.570 
the text of the documents, we first have
to do text acquisition and often then

27
00:01:52.970 --> 00:01:58.150 
the text has to be transformed to
form some kind of search index

28
00:01:58.310 --> 00:02:03.160 
that makes the core part of the search
engine since it determines, you know,

29
00:02:03.280 --> 00:02:08.140 
how to find specific documents and
associate them with specific search terms

30
00:02:09.320 --> 00:02:10.480 
so you have the index.

31
00:02:11.410 --> 00:02:14.860 
Then if it comes to presenting
the results you have a specific

32
00:02:14.860 --> 00:02:19.020 
kind of rankings because some of
the documents fit better other

33
00:02:19.020 --> 00:02:22.140 
words and of course they have
to be ordered accordingly.

34
00:02:22.540 --> 00:02:27.580 
And since nowadays most of the search
engines provide personalized

35
00:02:27.580 --> 00:02:31.770 
results, which means they take into
account your previous actions and also

36
00:02:32.000 --> 00:02:36.680 
actions that have been recorded,
you know, of actions that you

37
00:02:36.680 --> 00:02:38.850 
performed in general
on the web.

38
00:02:39.540 --> 00:02:46.390 
Yeah you have to do a re-ranking possibly
to adapt to personalize the rank here

39
00:02:46.630 --> 00:02:50.650 
of the presented document. So
ranking is connected to the user

40
00:02:50.650 --> 00:02:54.300 
interaction, user interaction
provides an evaluation and then

41
00:02:54.300 --> 00:02:57.450 
potentially a re-ranking of the
presented results which means

42
00:02:57.600 --> 00:03:01.500 
if two different people are looking for
the same thing on the same search engine

43
00:03:01.660 --> 00:03:04.050 
they might be presented
different results.

44
00:03:05.980 --> 00:03:10.210 
So what happens now when knowledge
graphs come into the play?

45
00:03:11.060 --> 00:03:16.430 
You see all of the green parts of
that information retrieval process,

46
00:03:16.790 --> 00:03:21.420 
they are influenced by the knowledge graph.
First of all the text transformation because

47
00:03:21.540 --> 00:03:24.980 
now you have to look in the text,
you have to do further analysis,

48
00:03:24.980 --> 00:03:29.070 
you have to look for semantic
entitie,s for named entities, for

49
00:03:29.070 --> 00:03:32.750 
example for relations and all that stuff.
And this of course has also to be

50
00:03:33.050 --> 00:03:35.220 
considered in the
index creation.

51
00:03:36.560 --> 00:03:41.870 
However then also user interaction
will change because you know

52
00:03:42.310 --> 00:03:46.170 
if I look for a specific word it
might be associated with different

53
00:03:46.170 --> 00:03:49.840 
meanings. So how do I display
that? How do I make clear that

54
00:03:49.840 --> 00:03:53.990 
there are different varieties and things
which might be also differently order

55
00:03:54.390 --> 00:04:00.070 
and if I know my user then probably
I can guess what's the most likely

56
00:04:00.290 --> 00:04:04.350 
meaning of what the
user is looking for.

57
00:04:04.770 --> 00:04:08.740 
So therefore all of these green
parts will be heavily influenced

58
00:04:08.740 --> 00:04:10.570 
by knowledge graph
technology.

59
00:04:12.150 --> 00:04:16.820 
Prerequisite before you start
into a semantic search process,

60
00:04:16.820 --> 00:04:18.570 
what you have to
do, you have to

61
00:04:19.500 --> 00:04:23.750 
annotate your documents with
explicit semantic annotations.

62
00:04:23.750 --> 00:04:28.260 
So you have to named entity recognition
and the entities have to be connected

63
00:04:28.590 --> 00:04:31.160 
to, so the entities in the text,
which means the symbol in the

64
00:04:31.160 --> 00:04:34.930 
text has to be connected to an
entity within your knowledge base.

65
00:04:35.400 --> 00:04:39.380 
This is a small example I wanted
to show you here. So this is an

66
00:04:39.940 --> 00:04:43.940 
screen that is copied from a
block which is semantically

67
00:04:43.940 --> 00:04:47.420 
annotated you can see that here.
I will show you here this is

68
00:04:47.530 --> 00:04:51.800 
our blog, scihi blog, we had
this already in the past here

69
00:04:51.800 --> 00:04:56.200 
in the lecture. There you see
the text is annotated and

70
00:04:56.200 --> 00:04:59.910 
you see here many of the words
underlined. So let's have a

71
00:04:59.910 --> 00:05:04.540 
closer look at that. So for example
if you pass over Neil Armstrong

72
00:05:04.870 --> 00:05:10.680 
then this annotated text is directly
connected to its counterpart

73
00:05:10.680 --> 00:05:13.820 
in the knowledge base, so to
an entity of Neil Armstrong

74
00:05:14.060 --> 00:05:17.900 
and what the user interface does
here is show you immediately

75
00:05:18.220 --> 00:05:21.830 
what other information can I
find there in the knowledge

76
00:05:21.830 --> 00:05:25.210 
base. And this for example is
connected to DBpedia, so therefore

77
00:05:25.210 --> 00:05:29.010 
you will be immediately displayed
the birth year, the death year,

78
00:05:29.200 --> 00:05:32.550 
the death place and other stuff
of information you have about

79
00:05:32.550 --> 00:05:35.980 
Neil Armstrong here, the first man
on the moon. But you can try

80
00:05:35.980 --> 00:05:40.020 
this out with any kind of annotated
text and you get additional

81
00:05:40.020 --> 00:05:46.140 
information about that entity without
leaving, you know, that kind of document.

82
00:05:46.950 --> 00:05:50.730 
So semantic annotation is the
first and important thing.

83
00:05:51.430 --> 00:05:55.360 
And this in the end if I have
semantic annotations within my

84
00:05:55.360 --> 00:05:59.450 
document, if at least the entities are
annotated, I can do entity based search

85
00:05:59.710 --> 00:06:05.720 
comparison to string oriented or string
based text information retrieval.

86
00:06:06.230 --> 00:06:08.210 
And the nice thing is

87
00:06:08.970 --> 00:06:12.260 
entity based information retrieval
is language independent, since

88
00:06:13.820 --> 00:06:18.260 
different words in different or
the same let's say concept in

89
00:06:18.260 --> 00:06:21.720 
different languages of course is
represented by different words.

90
00:06:21.960 --> 00:06:28.080 
But it stays the same concept, which means if
I annotate documents in different languages

91
00:06:28.200 --> 00:06:32.570 
with the respective entity, they
are all annotated with the

92
00:06:32.570 --> 00:06:37.520 
same entity no matter in which language
these documents have been authored.

93
00:06:38.860 --> 00:06:42.800 
So entity based retrieval in the
end is language independent.

94
00:06:43.170 --> 00:06:44.050 
How does it work?

95
00:06:45.520 --> 00:06:50.290 
Imagine the following case. We
have here a following query, we

96
00:06:50.400 --> 00:06:52.910 
would like to look for
Armstrong on the moon,

97
00:06:53.650 --> 00:06:58.270 
and we have here a document about
the first man on the moon

98
00:06:58.270 --> 00:07:02.130 
and what you usually do there is
first thing of course I have

99
00:07:02.130 --> 00:07:06.070 
to do named entity linking on the
query string. So there I find

100
00:07:06.070 --> 00:07:08.360 
the two named entities
Neil Armstrong and moon

101
00:07:08.830 --> 00:07:12.380 
and then I can look of course
for these two entities in my

102
00:07:12.380 --> 00:07:16.670 
documents that also have to be
semantically annotated and there

103
00:07:16.800 --> 00:07:20.300 
I find for example the named entity
recognition will recognize

104
00:07:20.300 --> 00:07:24.480 
the first man on the moon as Neil
Armstrong if it's sufficiently

105
00:07:24.480 --> 00:07:27.300 
sophisticated and of course it
will find the moon. And then

106
00:07:27.300 --> 00:07:31.330 
I have a perfect match. And this
of course will be my perfect

107
00:07:31.330 --> 00:07:35.420 
result I was looking for. This
would be entity based search.

108
00:07:36.560 --> 00:07:39.130 
But with semantic annotations
you can do more.

109
00:07:39.620 --> 00:07:42.440 
You can make use of
semantic similarities.

110
00:07:43.850 --> 00:07:47.860 
Again now, let's see what happens
if we have another document that

111
00:07:47.860 --> 00:07:53.330 
is talking about the second man on
the moon, about Buzz Aldrin. The

112
00:07:54.990 --> 00:07:58.650 
entity resolution process or
named entity linking will give

113
00:07:58.650 --> 00:08:01.970 
you back the moon and of course the
entity Buzz Aldrin. So there is no

114
00:08:02.160 --> 00:08:06.400 
Neil Armstrong in the document.
However we will find out that

115
00:08:06.400 --> 00:08:10.830 
there is a high semantic similarity between
Buzz Aldrin and Neil Armstrong. So

116
00:08:11.140 --> 00:08:14.650 
two entities are considered
semantically similar if they share

117
00:08:14.900 --> 00:08:19.280 
many property value pairs, for
example, or if they share properties

118
00:08:19.280 --> 00:08:22.270 
with rather similar values and
of course since both of them

119
00:08:22.540 --> 00:08:25.990 
share the same moon mission and
of course both of them have

120
00:08:26.000 --> 00:08:28.970 
the same occupation, a similar
age and stuff like that,

121
00:08:29.380 --> 00:08:34.380 
therefore they are considered
semantically similar. And by that

122
00:08:34.390 --> 00:08:37.750 
of course we come then from Buzz
Aldrin to a rather similar

123
00:08:37.750 --> 00:08:42.230 
entity Neil Armstrong that was asked
in our query and now according

124
00:08:42.230 --> 00:08:47.090 
to the ranking that implement,
of course I will also return

125
00:08:47.210 --> 00:08:50.550 
the document with Buzz Aldrin
to that search. But of course

126
00:08:50.690 --> 00:08:54.730 
after the documents that I found with
the directives. So this would be

127
00:08:54.920 --> 00:08:59.630 
entity based search combined with
similarity based entity matching.

128
00:09:02.540 --> 00:09:05.750 
Not always I'm going to look for
things that are really similar,

129
00:09:05.750 --> 00:09:09.150 
but things that are somehow
related to each other.

130
00:09:09.770 --> 00:09:16.340 
So here for this I could also take
into account the same document

131
00:09:16.340 --> 00:09:19.220 
again and the same query. So
Armstrong on the moon i'm looking

132
00:09:19.220 --> 00:09:22.410 
for and here I have a document
about the second man on the moon.

133
00:09:22.650 --> 00:09:26.900 
I find besides the moon which
is a direct hit more also the

134
00:09:26.900 --> 00:09:29.640 
term astronaut and
the term apollo 11.

135
00:09:30.040 --> 00:09:35.200 
And I might easily find out that
Neil Armstrong also is associated

136
00:09:35.200 --> 00:09:39.600 
in the knowledge base with apollo
11and with the type astronaut.

137
00:09:39.810 --> 00:09:44.120 
And by that you know I have a
relation based matching and I

138
00:09:44.120 --> 00:09:49.640 
can of course then also complement my
search results with results that are

139
00:09:49.970 --> 00:09:57.880 
content wise related to my search. So not
necessarily completely identical or similar

140
00:09:58.240 --> 00:10:00.450 
but in this
time related.

141
00:10:01.230 --> 00:10:06.510 
So these three things- entity
matching by equality, similarity

142
00:10:06.510 --> 00:10:09.940 
based entity matching and relationship
based entity matching make up

143
00:10:10.180 --> 00:10:14.770 
semantic search and help of course
to extend the traditional

144
00:10:14.780 --> 00:10:19.430 
search engine and the traditional
search process to make first

145
00:10:19.660 --> 00:10:23.850 
the search more precise, since
we are talking about entities,

146
00:10:24.050 --> 00:10:28.290 
and no longer about this kind of
ambiguous terms of language,

147
00:10:28.450 --> 00:10:31.340 
and on the other hand more
complete since we of course can

148
00:10:31.340 --> 00:10:35.090 
also look for paraphrases
immediately and synonyms and stuff

149
00:10:35.090 --> 00:10:39.180 
like that as well as for similar
things and related things.

150
00:10:39.190 --> 00:10:43.670 
And they are related by default since you
have exactly these kind of similarities

151
00:10:44.040 --> 00:10:49.310 
and relationships represented within
the knowledge graph, that is

152
00:10:49.630 --> 00:10:52.720 
the backbone or the foundation
of that search engine.

153
00:10:53.810 --> 00:10:59.700 
However what we were talking about was
retrieval. So we are looking for things

154
00:11:00.190 --> 00:11:03.090 
that we more or less know. So we
know what we are looking for.

155
00:11:04.030 --> 00:11:10.690 
It might become much more difficult if you
have, let's say, not exactly in mind

156
00:11:10.860 --> 00:11:14.320 
what your result look like.
Especially if you are searching

157
00:11:14.320 --> 00:11:18.490 
in a field you are not familiar
with. So for example you don't

158
00:11:18.600 --> 00:11:22.170 
know the terms you are looking
for and then it's difficult

159
00:11:22.170 --> 00:11:27.360 
for you to describe and to express
your original information need.

160
00:11:28.190 --> 00:11:30.960 
And in that case
exploration

161
00:11:32.030 --> 00:11:35.570 
instead of retrieval would be
the right answer and we will

162
00:11:35.570 --> 00:11:41.000 
show you in the next lecture how
we can go from simple retrieval

163
00:11:41.410 --> 00:11:44.380 
towards semantic
exploration.

164
00:11:45.080 --> 00:11:50.000 
Ok this will be then the next chapter
"Exploratory Search and based on that

165
00:11:50.210 --> 00:11:51.400 
Recommender Systems".
