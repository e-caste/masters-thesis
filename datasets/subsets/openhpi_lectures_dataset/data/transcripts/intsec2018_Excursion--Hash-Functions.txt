WEBVTT

1
00:00:00.630 --> 00:00:04.510 
In this excursion we want to introduce hash functions.

2
00:00:04.780 --> 00:00:09.200 
Hash functions play an important role in many different applications

3
00:00:09.200 --> 00:00:13.930 
in computer science. So the idea behind such hash function

4
00:00:13.930 --> 00:00:17.820 
is that they map large amounts of information

5
00:00:18.420 --> 00:00:24.510 
messages, text, videos into short strings,

6
00:00:24.780 --> 00:00:29.610 
so called fingerprints which are characterized this long

7
00:00:29.630 --> 00:00:33.390 
information. Mathematically there is a function

8
00:00:33.590 --> 00:00:36.870 
the hash function and the hash function maps

9
00:00:37.350 --> 00:00:40.720 
message long message into a hash function.

10
00:00:42.160 --> 00:00:46.660 
When we map long words to small words, then eventually

11
00:00:46.850 --> 00:00:51.530 
same hash value can occur for different messages for different

12
00:00:51.530 --> 00:00:55.970 
long words. Here it's important to have this

13
00:00:55.970 --> 00:01:00.040 
in mind that hash functions are non injective.

14
00:01:01.980 --> 00:01:06.520 
There are different applications of hash functions also

15
00:01:06.520 --> 00:01:11.060 
in the field of internet security. With these particular hash

16
00:01:11.060 --> 00:01:14.880 
functions a we speak of cryptographic hash functions

17
00:01:15.490 --> 00:01:19.770 
but let's start with two applications. The first application

18
00:01:19.770 --> 00:01:25.780 
is the secure storage of passwords by concealment on provider side.

19
00:01:28.000 --> 00:01:32.380 
If a user once to log in to the service he has to prove and

20
00:01:32.380 --> 00:01:36.250 
has to identify himself so he has to give his user name

21
00:01:36.250 --> 00:01:44.720 
and his passwords. What is not ok if when on the service providers

22
00:01:44.720 --> 00:01:49.310 
side the password is directly stored in the database in the user

23
00:01:49.310 --> 00:01:54.460 
database. In that case everyone that has access to the user

24
00:01:54.460 --> 00:01:58.770 
database can also see the password of the person.

25
00:01:59.380 --> 00:02:04.140 
The password is hashed before it's stored in the user database

26
00:02:04.280 --> 00:02:09.940 
so that it's not easily reproducible. Another application is

27
00:02:09.950 --> 00:02:14.390 
that from a long document we create fingerprints,

28
00:02:14.790 --> 00:02:18.550 
for example to send the long document

29
00:02:18.770 --> 00:02:23.420 
together with a smaller copy which helps the user to find out

30
00:02:23.480 --> 00:02:27.550 
whether the document has arrived in the right way.

31
00:02:28.260 --> 00:02:32.660 
Here is an example - so for example one wants to send the message

32
00:02:32.670 --> 00:02:37.590 
I like openhpi, then there is a famous hash function

33
00:02:37.590 --> 00:02:42.560 
SHA-256 and then we have our message and then

34
00:02:42.560 --> 00:02:46.640 
by means of this hash function the message

35
00:02:46.840 --> 00:02:53.450 
is described, the hash value is produced of

36
00:02:53.660 --> 00:02:55.690 
exactly that length.

37
00:02:57.830 --> 00:03:02.010 
In this case it's only an example, we have such a short message

38
00:03:02.380 --> 00:03:06.510 
and a long hash value in the usual application.

39
00:03:07.010 --> 00:03:11.690 
Of course we have huge messages for example a document a

40
00:03:11.690 --> 00:03:16.270 
contract or another thing, so that for case of verification

41
00:03:16.520 --> 00:03:19.870 
the hash value is sent together with a document.

42
00:03:20.380 --> 00:03:23.920 
Let's have a closer look to this password security

43
00:03:24.160 --> 00:03:28.480 
application of a hash value, to secure the password the service

44
00:03:28.480 --> 00:03:32.060 
providers store the hash value of a password

45
00:03:32.270 --> 00:03:37.950 
instead of the password it self. When we speak about password security

46
00:03:37.950 --> 00:03:42.720 
I mentioned this already then we have to invite conflicts

47
00:03:43.020 --> 00:03:47.130 
in case of users which use the same password.

48
00:03:47.520 --> 00:03:50.300 
If they use the same password then also the same

49
00:03:50.590 --> 00:03:55.580 
hash value would be created and it's no more distinguished.

50
00:03:56.400 --> 00:04:01.250 
To the password a salt is appended, random salt

51
00:04:01.490 --> 00:04:06.400 
prevents that identical hashes of the same password

52
00:04:06.600 --> 00:04:10.650 
and makes it more difficult to analyze and

53
00:04:10.660 --> 00:04:15.290 
to crack passwords. So for example to users using a password

54
00:04:15.290 --> 00:04:20.350 
hello, then a salt is added that's a random string

55
00:04:20.940 --> 00:04:26.300 
and then this password appended with salt

56
00:04:26.680 --> 00:04:31.290 
the hash function is applied. Then we get a hash value and

57
00:04:31.300 --> 00:04:35.910 
this hash value that it stored in the user database of the

58
00:04:35.910 --> 00:04:40.510 
provider. Of course the provider needs also to remember

59
00:04:40.510 --> 00:04:44.580 
the salt, so the hash is stored together with a salt.

60
00:04:47.570 --> 00:04:50.870 
For this kind of applications for generally this kind of

61
00:04:50.870 --> 00:04:55.100 
application of hash functions in security relevant areas,

62
00:04:55.540 --> 00:04:58.440 
one needs special type of hash functions,

63
00:04:58.900 --> 00:05:03.110 
so called cryptographic functions. Before I go

64
00:05:03.370 --> 00:05:06.680 
into more detail let's consider second example.

65
00:05:07.300 --> 00:05:11.650 
The second example which plays a role for example in the context

66
00:05:11.660 --> 00:05:15.610 
of digital signatures, digital signatures we'll discuss

67
00:05:15.840 --> 00:05:20.680 
in week five. So here I only a give the principle

68
00:05:20.970 --> 00:05:26.160 
why the hash function plays an important role for such

69
00:05:26.160 --> 00:05:29.900 
security mechanisms. The idea is that

70
00:05:30.260 --> 00:05:34.880 
in addition to the document itself, especially encrypted

71
00:05:35.200 --> 00:05:40.030 
digital copy of the message is sent and if one would

72
00:05:41.140 --> 00:05:44.900 
apply the encryption function to the document to a large

73
00:05:44.900 --> 00:05:49.220 
document for example to a video, then we would get a very large

74
00:05:49.230 --> 00:05:53.990 
encryption it would need a lot of processing power

75
00:05:54.220 --> 00:06:00.370 
and though the idea is to not encrypt the full document. So

76
00:06:00.860 --> 00:06:04.400 
the idea is to apply a hash function to the document

77
00:06:04.960 --> 00:06:11.870 
and then to encrypt the short hash value. So since this helps

78
00:06:11.870 --> 00:06:16.970 
to avoid to increase performance to avoid long and complicated

79
00:06:17.130 --> 00:06:21.880 
computation, so only a short hash value of the document

80
00:06:22.310 --> 00:06:27.010 
the fingerprint is encrypted and sent together with a document

81
00:06:27.010 --> 00:06:31.840 
and so the user, the receiver can check whether

82
00:06:32.040 --> 00:06:37.350 
the document has encrypted itself in a good way. Here

83
00:06:37.600 --> 00:06:40.030 
is the illustration - we have the document

84
00:06:40.620 --> 00:06:43.800 
the document we apply a hash function,

85
00:06:44.090 --> 00:06:48.670 
I apply an outdated hash function in this example because

86
00:06:48.670 --> 00:06:53.980 
they produce small hash values, here's the hash function and

87
00:06:53.980 --> 00:06:58.400 
then with a private key of the user this hash value is encrypted.

88
00:06:59.760 --> 00:07:04.090 
Send it together with a document and then the receiver can

89
00:07:04.090 --> 00:07:09.260 
check, can use the public key of the sender, can encrypt

90
00:07:09.530 --> 00:07:14.940 
the hash value, can compare this hash value with the hash value

91
00:07:15.110 --> 00:07:20.210 
that is produced by the document and if both increase

92
00:07:20.260 --> 00:07:24.840 
then there is a proof that the document for example a contract

93
00:07:25.080 --> 00:07:31.160 
reached the user in the right way. For both this application

94
00:07:31.160 --> 00:07:34.730 
of hash functions in the security area,

95
00:07:35.030 --> 00:07:39.840 
there are some additional requirements for hash functions

96
00:07:40.290 --> 00:07:44.020 
and if this requirements are fulfilled, we speak of

97
00:07:44.300 --> 00:07:45.730 
cryptographic hash functions.

98
00:07:47.940 --> 00:07:51.090 
The problem with hash function is they map large amount of

99
00:07:51.090 --> 00:07:53.930 
information to short information and so

100
00:07:54.220 --> 00:07:58.150 
different large documents can have the same

101
00:07:58.610 --> 00:08:03.020 
hash value. We speak of a collision

102
00:08:03.660 --> 00:08:07.750 
because then it's no more a proof whether this fingerprint come

103
00:08:07.750 --> 00:08:10.270 
from that document or from another document.

104
00:08:10.840 --> 00:08:16.320 
So in the case of cryptographic hash functions

105
00:08:16.730 --> 00:08:21.470 
it should be very difficult to produce such collisions.

106
00:08:23.180 --> 00:08:26.480 
And in order to make this difficult

107
00:08:26.650 --> 00:08:30.960 
to produce such collisions, a requirement for the cryptographic

108
00:08:30.960 --> 00:08:35.460 
hash function is that they should be uniformly distributed.

109
00:08:36.440 --> 00:08:40.190 
Another requirement is that even small changes

110
00:08:40.460 --> 00:08:45.880 
of the input value should result in large changes in the hash value.

111
00:08:45.880 --> 00:08:49.850 
Assume there is a document an important contract and only

112
00:08:49.850 --> 00:08:53.810 
a small piece is changed, for example the price

113
00:08:54.050 --> 00:08:58.640 
or the date. Then there is a small change and

114
00:08:58.870 --> 00:09:03.500 
if there would and this small change if someone tries to manipulate

115
00:09:03.500 --> 00:09:08.610 
this can be detected by means of the requirement that cryptographic

116
00:09:08.610 --> 00:09:13.510 
hash functions have a large difference in the hash value, even

117
00:09:13.520 --> 00:09:18.910 
for documents which are very similar. So working with such type

118
00:09:18.910 --> 00:09:23.390 
of hash functions it's a  known sub area of cryptography,

119
00:09:23.670 --> 00:09:27.580 
so it's abig research field

120
00:09:27.960 --> 00:09:30.770 
and it's very important and

121
00:09:31.060 --> 00:09:35.090 
has many applications in the security area.

122
00:09:36.990 --> 00:09:41.420 
Mathematically, the requirements can

123
00:09:41.420 --> 00:09:45.660 
be formulated in such types of

124
00:09:45.700 --> 00:09:48.530 
properties that need to be fulfilled, the hash functions

125
00:09:49.160 --> 00:09:52.760 
means collision resistance to message M,

126
00:09:53.280 --> 00:09:57.210 
if it is practically impossible

127
00:09:57.890 --> 00:10:01.920 
to construct a different message with the same hash value.

128
00:10:02.630 --> 00:10:06.470 
So an attacker it should be very difficult for it should be almost

129
00:10:06.480 --> 00:10:11.020 
impossible for an attacker to produce a faked message with the

130
00:10:11.020 --> 00:10:15.650 
same hash value. A

131
00:10:15.840 --> 00:10:18.030 
cryptographic hash function should be collision

132
00:10:18.270 --> 00:10:22.730 
resistant and this means that it is practically impossible

133
00:10:23.060 --> 00:10:27.670 
to find two different messages with the same hash value

134
00:10:28.310 --> 00:10:32.910 
and the cryptographic hash function should be one way functions.

135
00:10:33.070 --> 00:10:37.690 
One way function means that it's practically impossible to

136
00:10:37.850 --> 00:10:43.300 
reproduce from an hash values that the value of a message M.

137
00:10:44.260 --> 00:10:48.660 
So in one direction computes a hash value of a message that is

138
00:10:48.660 --> 00:10:53.790 
easy but the reverse direction reconstruct from the hash value

139
00:10:54.090 --> 00:10:59.860 
the message itself this should be at least practically impossible,

140
00:10:59.860 --> 00:11:04.310 
it needs so much computational power it needs so much time that

141
00:11:04.310 --> 00:11:09.790 
it's useless to apply. Cryptographic now we can define it

142
00:11:09.800 --> 00:11:14.090 
correctly, cryptographic hash functions is a collision resistant

143
00:11:14.440 --> 00:11:15.080 
hash function.

144
00:11:17.330 --> 00:11:20.910 
A few words about the length of the hash values - we said we have

145
00:11:20.950 --> 00:11:27.280 
the long information, the long words, the long messages which are mapped

146
00:11:27.290 --> 00:11:31.390 
to small hash values and of course for the application it would be better

147
00:11:32.450 --> 00:11:34.630 
if the hash value is small.

148
00:11:35.190 --> 00:11:38.510 
But the hash value needs a certain length

149
00:11:38.860 --> 00:11:43.640 
to be able to fulfill what you should do

150
00:11:43.870 --> 00:11:46.560 
what you should fulfill and to see this

151
00:11:46.740 --> 00:11:51.430 
let's start with considering the so called birthday paradox.

152
00:11:52.030 --> 00:11:57.040 
A birthday paradox says in a group with only 23

153
00:11:57.500 --> 00:12:02.510 
randomly selected people, the probability that at least two

154
00:12:02.510 --> 00:12:06.630 
have a birthday on the same day as is greater than fifty percent.

155
00:12:08.060 --> 00:12:11.090 
We have 365 days a year,

156
00:12:11.450 --> 00:12:14.250 
so 365

157
00:12:14.250 --> 00:12:17.680 
different possibilities for birthday,

158
00:12:18.280 --> 00:12:24.900 
and a group of 23

159
00:12:24.900 --> 00:12:28.650 
randomly selected person is enough that the probability that

160
00:12:28.650 --> 00:12:34.270 
at least two have on the same day birthday

161
00:12:34.570 --> 00:12:39.550 
is greater than fifty percent. Mathematically with this

162
00:12:39.550 --> 00:12:43.830 
effect, so with this

163
00:12:44.080 --> 00:12:48.280 
birthday paradox one can estimate the probability

164
00:12:48.610 --> 00:12:54.160 
of hash value collisions. And every times this is bad if such hash

165
00:12:54.160 --> 00:12:58.230 
value if there is a collision of the hash value because this provides

166
00:12:58.230 --> 00:13:02.950 
the possibility for an attacker to do some wrong things.

167
00:13:03.520 --> 00:13:07.320 
So if we apply this idea and if we apply this fact

168
00:13:07.320 --> 00:13:13.490 
the birthday paradox, then we can say that if the hash value would have

169
00:13:13.490 --> 00:13:17.600 
a length of 120 bit, this was in the past

170
00:13:17.600 --> 00:13:21.190 
the recommended minimum length,

171
00:13:22.350 --> 00:13:25.710 
then with probability greater than fifty percent

172
00:13:26.100 --> 00:13:29.860 
collisions can be found on

173
00:13:30.030 --> 00:13:35.960 
2 to the 64 random input values. So it's a huge amount

174
00:13:35.960 --> 00:13:39.150 
of input value that's true. But

175
00:13:39.400 --> 00:13:43.240 
considering the high computational power of modern machines

176
00:13:43.610 --> 00:13:49.200 
this is for attacker's not practical impossible

177
00:13:49.600 --> 00:13:52.750 
to misuse this and to create collisions.

178
00:13:54.080 --> 00:13:59.160 
If we insist on a hash value length of

179
00:13:59.160 --> 00:14:04.560 
160 bit, so it is a request with DSS,

180
00:14:04.980 --> 00:14:09.190 
then with a probability of greater than 50%

181
00:14:09.430 --> 00:14:14.380 
a collision can be produced at a collision can be found on

182
00:14:14.380 --> 00:14:18.840 
2 to the power 80 random input values.

183
00:14:21.140 --> 00:14:25.090 
What are the attacks against cryptographic hash functions?

184
00:14:25.930 --> 00:14:29.930 
Of course, we already mentioned collisions play an important roles.

185
00:14:29.930 --> 00:14:34.560 
So the aim of an attack is to try to create a collision.

186
00:14:35.490 --> 00:14:41.050 
To create a collision that means to calculate of two different

187
00:14:41.050 --> 00:14:45.390 
messages to find two different messages with the same hash

188
00:14:45.390 --> 00:14:50.750 
value or to calculate a new message from a

189
00:14:51.110 --> 00:14:55.440 
pre-determined hash value. So the hash values that was used for

190
00:14:55.440 --> 00:15:00.760 
example to secure a password to secure information,

191
00:15:01.120 --> 00:15:06.190 
then the attacker tries to find another password or another

192
00:15:06.190 --> 00:15:09.670 
message with identical hash value.

193
00:15:10.820 --> 00:15:13.880 
And we discussed already the birthday attack.

194
00:15:14.460 --> 00:15:19.090 
So in falsifying messages to generate a pair of messages with

195
00:15:19.090 --> 00:15:23.230 
the same hash value of length n is possible

196
00:15:23.470 --> 00:15:27.280 
with 2 to the n/2 attempts.

197
00:15:28.380 --> 00:15:32.760 
This is the result this is the conclusion from the birthday paradox

198
00:15:33.230 --> 00:15:36.240 
so this attack is every time possible.

199
00:15:36.930 --> 00:15:42.210 
Now you see this n is important, this n needs to be like large,

200
00:15:42.330 --> 00:15:47.070 
it needs to be small to makes the application of hash value sufficient

201
00:15:47.070 --> 00:15:51.780 
or possible, but to guarantee security it needs to

202
00:15:51.780 --> 00:15:56.010 
be large. So every time it is the art of such hash functions

203
00:15:56.290 --> 00:16:00.560 
to find the right balance. With a birthday attack it's

204
00:16:00.560 --> 00:16:05.160 
possible in falsifying messages to generate

205
00:16:05.350 --> 00:16:09.200 
two messages with the same hash value of length n

206
00:16:09.440 --> 00:16:14.190 
that 2 to the power n/2 attempts are possible.

207
00:16:14.710 --> 00:16:18.220 
Protection of course use long hash values,

208
00:16:18.520 --> 00:16:23.690 
for example 512 bits. This is the length

209
00:16:23.690 --> 00:16:28.590 
of the SHA 512 hash functions.

210
00:16:29.000 --> 00:16:33.190 
Why? Then n is equal to 512,

211
00:16:33.450 --> 00:16:40.500 
so you need 2 to the 256

212
00:16:40.890 --> 00:16:46.310 
attempts to find a collision.

213
00:16:48.860 --> 00:16:51.690 
There is another attack, the substitution attack

214
00:16:52.230 --> 00:16:56.760 
at an attack against hash functions and this works with

215
00:16:57.080 --> 00:17:02.400 
any cryptographic hash functions. There is no possibility

216
00:17:02.410 --> 00:17:08.650 
to protect against. The idea is let m

217
00:17:08.990 --> 00:17:12.210 
be the length of the hash value of the

218
00:17:12.440 --> 00:17:16.310 
hash value h of a the message M

219
00:17:18.520 --> 00:17:23.780 
and then the attacker formulate and changes

220
00:17:24.150 --> 00:17:31.590 
many many positions in this hash value.

221
00:17:33.100 --> 00:17:36.620 
So a fake messages formulated and changes are made

222
00:17:36.870 --> 00:17:42.310 
to t greater than m positions. For example, spaces are

223
00:17:42.310 --> 00:17:46.800 
inserted or some which does not change the

224
00:17:47.120 --> 00:17:52.360 
meaning of the document but formally change the encryption

225
00:17:52.360 --> 00:17:56.970 
of the document. So the formulation as a text file for example.

226
00:17:57.890 --> 00:18:02.900 
So for all resulting 2 to the t greater of course than

227
00:18:02.900 --> 00:18:07.390 
2 to the m counterfeits it is very likely that different

228
00:18:07.390 --> 00:18:11.460 
hash values are calculated, so that one of the counterfeits

229
00:18:11.460 --> 00:18:17.000 
has exactly the predetermined hash value h

230
00:18:17.000 --> 00:18:20.420 
of our message the attacker wants to attack.

231
00:18:20.970 --> 00:18:25.860 
This is a bigger principle from combinatorics

232
00:18:26.500 --> 00:18:30.080 
it is a huge number to make such

233
00:18:30.080 --> 00:18:35.410 
a change in modification but it works. And of course what you

234
00:18:35.410 --> 00:18:40.910 
see protection is, this m should be as large as possible

235
00:18:41.420 --> 00:18:44.520 
to make it very very difficult for an attacker

236
00:18:44.820 --> 00:18:48.290 
to come up with such amount of different

237
00:18:48.550 --> 00:18:49.810 
versions of the value.

238
00:18:53.690 --> 00:18:57.500 
Let's speak and consider some of the popular hash functions.

239
00:18:58.300 --> 00:19:01.610 
MD5 for example, message digest five

240
00:19:01.910 --> 00:19:07.640 
is a very popular hash functions which was released in

241
00:19:07.640 --> 00:19:13.220 
1991 by Ron Rivest. It is an improved version

242
00:19:13.220 --> 00:19:17.130 
of another hash function of MD4 and

243
00:19:17.190 --> 00:19:23.670 
the problem is this hash functions MD5 as well as

244
00:19:23.670 --> 00:19:28.420 
SHA-1 are commonly very widely used

245
00:19:28.430 --> 00:19:33.430 
but they were released years ago to the standard

246
00:19:33.430 --> 00:19:39.950 
not by the internet's authority IETF but similar like

247
00:19:39.950 --> 00:19:44.450 
SHA1 with a 512 block length and

248
00:19:44.450 --> 00:19:50.830 
128 bit hash and values this security is no

249
00:19:50.830 --> 00:19:54.720 
more it's no more possible to use it

250
00:19:55.080 --> 00:19:59.980 
because for today's computers and application this length this

251
00:19:59.980 --> 00:20:03.650 
length of 128 bit length hashes

252
00:20:03.820 --> 00:20:05.720 
are considered too short.

253
00:20:08.280 --> 00:20:12.900 
To explain this a little bit more in detail, this message is

254
00:20:13.220 --> 00:20:18.740 
put into blocks, for each block hash value is computed and then

255
00:20:18.740 --> 00:20:23.490 
the hash value the next block and the old hash value

256
00:20:23.770 --> 00:20:28.310 
they are use to compute the next hash value.

257
00:20:28.740 --> 00:20:33.080 
So MD5 as well as SHA 1 are considered

258
00:20:33.510 --> 00:20:37.790 
too short and Hans Dobbertin from German BSI

259
00:20:38.120 --> 00:20:41.880 
found a collision in partial

260
00:20:42.090 --> 00:20:45.360 
function compress function, so attackers are able

261
00:20:45.770 --> 00:20:50.640 
to produce collisions and in this way

262
00:20:50.820 --> 00:20:56.730 
to break this hash functions. So please do no longer use

263
00:20:56.730 --> 00:21:01.140 
MD5 in your application because you are not sure.

264
00:21:01.650 --> 00:21:05.440 
Same is true for SHA 1. I already mentioned SHA 1

265
00:21:05.760 --> 00:21:11.040 
it is the secure hash algorithm

266
00:21:11.390 --> 00:21:15.470 
it was all also developed in 1991

267
00:21:15.710 --> 00:21:19.770 
by NSA also is based on the hash

268
00:21:20.210 --> 00:21:25.750 
function MD4 and then in '95 there was a

269
00:21:25.780 --> 00:21:30.490 
revised version SHA 1 also SHA 1

270
00:21:30.810 --> 00:21:34.620 
together with MD5 is one of the most common

271
00:21:34.950 --> 00:21:37.830 
cryptographic hash functions in the internet.

272
00:21:38.410 --> 00:21:43.280 
It processes 512 bit blocks like MD4

273
00:21:43.680 --> 00:21:48.610 
and generates 160 bit hash values.

274
00:21:49.390 --> 00:21:54.640 
So to give an example when we the hash function

275
00:21:54.640 --> 00:21:59.620 
SHA 1 to the text Franz drives all over Bavaria in

276
00:21:59.620 --> 00:22:06.250 
an utterly shabby taxi, then the SHA 1 100th

277
00:22:06.490 --> 00:22:14.070 
bit hash value has this style in the format

278
00:22:14.390 --> 00:22:20.140 
of hexi decimal description. When we speak about security

279
00:22:20.320 --> 00:22:26.180 
then also SHA one is no longer considered secure.

280
00:22:26.900 --> 00:22:30.890 
And there are proofs also the hash values

281
00:22:30.900 --> 00:22:34.340 
160 bit so it's no more considered secure

282
00:22:34.690 --> 00:22:37.860 
and the first messages from the weakness

283
00:22:37.860 --> 00:22:42.270 
of SHA 1 came from February 2005

284
00:22:42.500 --> 00:22:47.190 
where a Chinese team finds another only theoretically possible is

285
00:22:47.190 --> 00:22:49.570 
this attack another way to crack SHA 1

286
00:22:49.930 --> 00:22:55.980 
with 2 to the power 69 attempts.

287
00:22:58.890 --> 00:23:02.330 
This was improved in August 2005 this

288
00:23:02.330 --> 00:23:07.010 
attack, so there was possible to produce a collision in

289
00:23:07.010 --> 00:23:11.650 
2 to the power 63 attempts and then in February 2017

290
00:23:11.650 --> 00:23:16.900 
last year, Google researchers demonstrated first

291
00:23:17.110 --> 00:23:22.060 
SHA 1hash collision so they proved and showed

292
00:23:22.240 --> 00:23:26.380 
that it's possible to produce a collision that means to

293
00:23:26.380 --> 00:23:30.880 
produce two documents with the same hash value.

294
00:23:32.330 --> 00:23:35.630 
They required 2 to the 60.3 SHA 1

295
00:23:35.630 --> 00:23:40.250 
operations it needs 110 high end graphic cards

296
00:23:41.020 --> 00:23:45.370 
working in parallel for approximately one year,

297
00:23:45.640 --> 00:23:49.980 
but then they found the collision. And this shows

298
00:23:50.200 --> 00:23:53.180 
that also SHA 1 also it's very popular

299
00:23:53.540 --> 00:23:59.070 
is no more considered secure. So the recommendation from the

300
00:23:59.110 --> 00:24:04.060 
NIST now is that users should make

301
00:24:04.060 --> 00:24:07.380 
a transition from SHA 1 to safer

302
00:24:07.580 --> 00:24:11.950 
hash functions. There is the SHA 2 family.

303
00:24:12.390 --> 00:24:15.430 
This was standardized 2 years later

304
00:24:15.430 --> 00:24:20.570 
than SHA 1 and MD5 it was standardized between two thousand

305
00:24:20.580 --> 00:24:24.340 
2002 and 2004 it is usable

306
00:24:24.390 --> 00:24:28.370 
and applicable for different hash lengths.

307
00:24:28.860 --> 00:24:33.050 
So it shows  that SHA-224

308
00:24:33.790 --> 00:24:38.540 
produce hash values of  length 224, so it's

309
00:24:39.030 --> 00:24:46.120 
much longer than the one hundred sixty from SHA-1. There is a version SHA-256,

310
00:24:46.290 --> 00:24:50.210 
SHA-384, SHA-512

311
00:24:50.430 --> 00:24:54.620 
so that if the computers become stronger and

312
00:24:56.190 --> 00:25:00.150 
the attacks can be performed although for larger

313
00:25:00.910 --> 00:25:08.050 
hash lengths, there is a possibility to improve, to prolong the hash value.

314
00:25:10.890 --> 00:25:13.480 
There are some minor weaknesses known

315
00:25:14.500 --> 00:25:16.220 
for the application.

316
00:25:17.920 --> 00:25:19.450 
We have the SHA-3

317
00:25:20.560 --> 00:25:27.070 
which is standardized in October 2012. It provides

318
00:25:27.330 --> 00:25:31.900 
alternative procedures to SHA-2

319
00:25:32.360 --> 00:25:37.730 
and today this is classified as safe.
