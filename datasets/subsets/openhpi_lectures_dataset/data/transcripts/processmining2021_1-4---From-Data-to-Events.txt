WEBVTT

1
00:00:00.850 --> 00:00:05.250 
Welcome to this video clip in which
we discuss how we come from data to

2
00:00:05.360 --> 00:00:05.900 
events.

3
00:00:08.390 --> 00:00:12.120 
We often hear that process
mining is data science

4
00:00:12.860 --> 00:00:18.280 
and in this slide there's
indication that this is actually

5
00:00:18.280 --> 00:00:21.640 
true because the only input we
need to do process mining is

6
00:00:21.640 --> 00:00:23.750 
what you see here on this
slide. So this is the

7
00:00:24.230 --> 00:00:28.250 
these four tables that we have
here in our application scenario

8
00:00:28.460 --> 00:00:33.640 
and this is the complete input that
we use to do process mining here.

9
00:00:34.210 --> 00:00:38.840 
So we see process mining is based
on data and we can really

10
00:00:38.840 --> 00:00:43.130 
characterize process mining as data
science for business processes.

11
00:00:45.110 --> 00:00:49.180 
So how do we come from data to
events? The first thing that

12
00:00:49.190 --> 00:00:52.470 
we need to do is to do
event identification.

13
00:00:54.020 --> 00:00:58.510 
So let's let's take a step back and
let's consider what a business

14
00:00:58.510 --> 00:01:03.570 
process actually is. Well a business
process consists of things that happen.

15
00:01:04.330 --> 00:01:07.050 
So it's the execution
of activities

16
00:01:07.970 --> 00:01:12.330 
starting from receiving the claim
we have to discuss several

17
00:01:12.330 --> 00:01:15.970 
steps until the completion
of the process and the sending

18
00:01:16.400 --> 00:01:22.010 
of the letter. So the execution
of activities is represented

19
00:01:22.010 --> 00:01:26.370 
by events and information about
these events is stored in the

20
00:01:26.370 --> 00:01:28.680 
data that we've seen
in our data tables.

21
00:01:29.520 --> 00:01:35.860 
We use data to identify it and if
you want to create those events.

22
00:01:37.090 --> 00:01:41.490 
Let's look at the following example.
So let's look again at this claim

23
00:01:42.100 --> 00:01:47.280 
at the claim table and we can
say that each tuple in this

24
00:01:47.680 --> 00:01:53.410 
table represents one receiving of
a claim. If you want one event.

25
00:01:54.350 --> 00:01:59.290 
So let's look at the first line,
so we have here a claim with

26
00:01:59.290 --> 00:02:01.050 
claim id 1234,

27
00:02:01.850 --> 00:02:06.500 
client ID cid 272,
theft

28
00:02:06.500 --> 00:02:10.570 
value 890€ received on the third of April

29
00:02:10.570 --> 00:02:12.680 
2020 at 08:05.

30
00:02:13.490 --> 00:02:17.370 
That is information that we have
here. And now we need to look

31
00:02:17.370 --> 00:02:22.230 
at that from a domain specific
perspective. So we see it's a

32
00:02:22.230 --> 00:02:27.290 
claim and the data reports on the
receiving of a claim because

33
00:02:27.290 --> 00:02:30.980 
here we have received date, received
time and it's about a claim.

34
00:02:31.330 --> 00:02:33.770 
So from that we
can deduce

35
00:02:34.700 --> 00:02:41.030 
that this data item represents the
event in which a claim was received.

36
00:02:41.580 --> 00:02:44.790 
So we have the tuple receive
claim with all the

37
00:02:44.790 --> 00:02:46.620 
other attributes

38
00:02:47.520 --> 00:02:50.880 
and that is used to
represent an event.

39
00:02:52.040 --> 00:02:55.990 
It's very important to select
an attribute that identifies

40
00:02:55.990 --> 00:03:01.530 
the case and that's called the case identifier.
So case identifiers are very important.

41
00:03:02.760 --> 00:03:06.410 
It can be one attribute but it
might also be several attributes.

42
00:03:06.410 --> 00:03:09.560 
In our example to
keep things simple

43
00:03:10.310 --> 00:03:14.690 
it is one attribute that we
use as a case identifier.

44
00:03:16.510 --> 00:03:21.170 
So the question is now which
attribute identifies a case in

45
00:03:21.170 --> 00:03:24.890 
our example. So we have several
attributes we have claim ID,

46
00:03:24.890 --> 00:03:29.050 
client ID, theft value and at
the timestamp the question is

47
00:03:29.050 --> 00:03:32.970 
which one is good or which
one represents well

48
00:03:33.840 --> 00:03:37.900 
a particular case or a particular
execution of one business

49
00:03:37.900 --> 00:03:39.220 
process in our example.

50
00:03:40.810 --> 00:03:45.390 
So maybe it's the client ID. So
I assume it's the client ID,

51
00:03:45.580 --> 00:03:51.650 
than all activities are related to
one client and these activities

52
00:03:51.650 --> 00:03:53.100 
are part of one process.

53
00:03:54.030 --> 00:03:58.590 
However in this example this might
not be appropriate. Why? Because

54
00:03:58.590 --> 00:04:03.090 
we have seen that there is at least
one client the ID 128

55
00:04:03.850 --> 00:04:09.880 
that has issued two claims. So
the activities of both claims

56
00:04:10.120 --> 00:04:14.300 
that are independent from each
other are then put into one big

57
00:04:14.480 --> 00:04:18.620 
process and that that would not
work that would end up in very

58
00:04:18.620 --> 00:04:24.190 
complex spaghetti like code and it would
not represent the process properly.

59
00:04:24.350 --> 00:04:29.670 
So the client ID is not appropriate
for our goal of investigating

60
00:04:29.670 --> 00:04:31.230 
the processing
of claims.

61
00:04:32.060 --> 00:04:37.100 
So we want to identify the process or
investigate the processing of claims

62
00:04:37.210 --> 00:04:41.440 
and therefore it's pretty
obvious that the claim ID is

63
00:04:41.860 --> 00:04:47.590 
the right case identifier. Why? Because
it relates all activities of a given

64
00:04:47.690 --> 00:04:52.990 
claim with one another and this is exactly
what a case identifier should do.

65
00:04:54.840 --> 00:04:59.810 
I like to remark here that case identifiers
have to be selected very carefully and

66
00:05:00.750 --> 00:05:05.130 
case identifiers might also consist
of several attributes that

67
00:05:05.130 --> 00:05:09.360 
makes it a bit harder but still you
always need a case identifier

68
00:05:09.360 --> 00:05:13.320 
in process mining. That's a very
important fundamental concept.

69
00:05:15.770 --> 00:05:20.870 
Once we have identified events,
we need to abstract events and

70
00:05:20.870 --> 00:05:22.610 
it's called event
abstraction.

71
00:05:24.420 --> 00:05:27.150 
To characterize
event abstraction

72
00:05:28.320 --> 00:05:32.180 
it's basically abstracting from data
attributes that are not required.

73
00:05:32.590 --> 00:05:35.010 
We see here this table
that we have several

74
00:05:35.610 --> 00:05:39.780 
attributes and in real world example
this is even more attributes

75
00:05:39.780 --> 00:05:40.950 
that are stored here

76
00:05:41.560 --> 00:05:47.920 
and we can abstract from data attributes
that are not required for the purpose

77
00:05:48.240 --> 00:05:52.810 
of process mining as we have
this purpose in our project.

78
00:05:54.410 --> 00:05:58.650 
So but it should also be clear
that the case identifier and

79
00:05:58.650 --> 00:06:03.420 
the activity are never abstracted
from. Why? Because I need to

80
00:06:03.430 --> 00:06:09.210 
identify for an event
always the case and and also

81
00:06:09.210 --> 00:06:13.030 
I need to identify always what actually
happened at this point in time.

82
00:06:13.440 --> 00:06:17.180 
What is really represented
by this particular event.

83
00:06:18.550 --> 00:06:22.510 
Now let's let's look at an example.
So here we want to abstract

84
00:06:22.580 --> 00:06:26.190 
the receive claim event. So
that's the first tuple

85
00:06:27.040 --> 00:06:30.910 
basically here. So the data the
first tuple we use that to

86
00:06:31.150 --> 00:06:34.700 
identify this receive claim we
did that in the previous slide.

87
00:06:35.270 --> 00:06:42.550 
And well we say that it's perfectly
perfect to have just receive claim.

88
00:06:42.990 --> 00:06:48.100 
We have the case ID the claim ID
1234 and then

89
00:06:48.100 --> 00:06:50.790 
we have the time stamp. Now the
time stamp we always need for

90
00:06:50.790 --> 00:06:56.950 
ordering. Now the time stamp is always part
of the event even after event abstraction.

91
00:06:57.650 --> 00:07:01.370 
So the resulting event type
is called receive claim

92
00:07:02.380 --> 00:07:06.860 
and the attributes of this event
type as a claim ID and here

93
00:07:07.210 --> 00:07:11.870 
the two attributes that that
together represent the time stamp.

94
00:07:12.690 --> 00:07:17.530 
For convenience we leave out
the time stamp and abbreviate

95
00:07:17.530 --> 00:07:21.150 
the events because otherwise
it would be very very big

96
00:07:21.150 --> 00:07:23.410 
and we could not really
handle that very nicely.

97
00:07:25.040 --> 00:07:28.550 
We have to bear in mind that
the time stamp is always part

98
00:07:28.560 --> 00:07:32.590 
of the event, we just don't show it
always. We can always refer back

99
00:07:33.040 --> 00:07:37.660 
to our data tables to look
what the time stamp actually

100
00:07:37.850 --> 00:07:42.260 
is. Therefore we just write receive
claim 1234.

101
00:07:42.260 --> 00:07:47.620 
So that is the receive claim activity has
been conducted for, has been completed for

102
00:07:48.570 --> 00:07:51.410 
the claim with the claim ID 1234

103
00:07:51.830 --> 00:07:56.900 
or we even go a step further and
abbreviate receive claim by rc

104
00:07:57.520 --> 00:08:02.180 
and then we just have rc for
the claim 1234.

105
00:08:04.740 --> 00:08:10.330 
Now we continue with this event abstraction
for also our other data tables.

106
00:08:11.900 --> 00:08:17.620 
So looking at the claims tables
and summarizing the complete set

107
00:08:17.620 --> 00:08:20.480 
of events we have here we have
receive claim 1234

108
00:08:20.480 --> 00:08:23.900 
receive claim 1235, receive claim

109
00:08:23.900 --> 00:08:28.030 
1236 and so forth. And you
see here that each and every

110
00:08:28.030 --> 00:08:29.770 
tuple in our
claims table

111
00:08:30.550 --> 00:08:35.890 
is represented by exactly one event
and each event is abstracted

112
00:08:36.250 --> 00:08:40.080 
to the activity what
happened receive claim and

113
00:08:40.730 --> 00:08:45.370 
the case identifier and that is
for case 1234,

114
00:08:45.390 --> 00:08:47.080 
1235 and so forth.

115
00:08:48.480 --> 00:08:52.170 
At this point we just have a set
of events. So we don't bother

116
00:08:52.170 --> 00:08:55.170 
with the ordering here and here
you see that the set and the

117
00:08:55.170 --> 00:08:58.850 
elements in the set are unordered
and therefore we don't have

118
00:08:58.850 --> 00:09:02.100 
ordering at this point in time.
We are not yet interested in

119
00:09:02.100 --> 00:09:05.040 
the ordering of events. We
add that a bit later.

120
00:09:07.930 --> 00:09:12.110 
So I like to notice again that
timestamps are also stored in

121
00:09:12.130 --> 00:09:16.910 
event in the event data. Timestamps
are just not shown in

122
00:09:17.440 --> 00:09:18.590 
the presentation here.

123
00:09:22.190 --> 00:09:26.580 
Let's look at the check table.
So the completeness check was

124
00:09:26.580 --> 00:09:31.170 
another input. So we have this
check data table and we apply

125
00:09:31.170 --> 00:09:37.550 
the same steps again to these check
table. So we do event identification,

126
00:09:38.500 --> 00:09:42.620 
we do event abstraction and
of course we have the same

127
00:09:43.270 --> 00:09:46.620 
case identifier, so
claim ID is again

128
00:09:47.320 --> 00:09:50.740 
a case case identifier
here. So we can

129
00:09:51.710 --> 00:09:57.560 
we can look what are the data tuples
in the check table. So we have here

130
00:09:58.350 --> 00:10:01.720 
the check for claim with a
claim ID 1239

131
00:10:02.170 --> 00:10:06.310 
done by employee 182
and yes it was complete, the

132
00:10:06.310 --> 00:10:10.040 
checking date is the sixth of
April at 08:23

133
00:10:10.450 --> 00:10:15.190 
and this tuple, the first tuple
is then identified as event

134
00:10:15.190 --> 00:10:22.440 
and abstracted to just ccc 1239
where ccc stands for check

135
00:10:22.580 --> 00:10:27.340 
claim completeness. Check claim
completeness 1239

136
00:10:27.660 --> 00:10:31.220 
and we have check claim completeness
1234 and

137
00:10:31.220 --> 00:10:36.190 
so forth. So for each data
tuple in this check table

138
00:10:36.640 --> 00:10:42.590 
we end up with one event and the
event type here is check claim

139
00:10:42.780 --> 00:10:43.470 
completeness.

140
00:10:45.590 --> 00:10:50.020 
We do the same thing for décision events.
So here we have décision events

141
00:10:50.300 --> 00:10:54.130 
and I think we can abbreviate
a little bit in this sense

142
00:10:54.130 --> 00:10:57.150 
because the mechanics is the
same as in the previous

143
00:10:57.950 --> 00:11:02.610 
in the previous example. So we have
an activity called or event type

144
00:11:02.810 --> 00:11:06.450 
decide on coverage.
So we again

145
00:11:07.210 --> 00:11:11.750 
look or identify that each tuple
represents the taking of

146
00:11:11.750 --> 00:11:15.770 
a decision in this insurance claim
process. So we call this event type

147
00:11:16.010 --> 00:11:18.490 
decide on
coverage or dc

148
00:11:19.410 --> 00:11:22.530 
and here again we have a number
of concrete events of that

149
00:11:22.540 --> 00:11:27.300 
type so dc 1239
representing the first tuple,

150
00:11:28.080 --> 00:11:32.750 
the second topple is represented by
dc 1234 and so forth.

151
00:11:33.070 --> 00:11:38.710 
Again we have for each tuple
we have exactly one event.

152
00:11:41.630 --> 00:11:45.610 
Events related to letters are
a bit different because here

153
00:11:45.610 --> 00:11:49.030 
we have an example where there's
more information stored in the

154
00:11:50.180 --> 00:11:55.640 
letter table. And as we
will see we can use one

155
00:11:56.230 --> 00:12:01.090 
we can use one tuple in this
letter table to create two

156
00:12:01.640 --> 00:12:04.840 
events that we use for
process mining a bit later.

157
00:12:05.760 --> 00:12:09.530 
So which type of information is
stored in this letters table?

158
00:12:09.670 --> 00:12:14.540 
Well it's the preparation and sending
of acceptance and rejection letters.

159
00:12:15.380 --> 00:12:19.920 
So we have we have two dimensions if
you want, we have the preparation

160
00:12:19.920 --> 00:12:23.470 
and sending and we have the preparation
and sending for acceptance

161
00:12:23.470 --> 00:12:27.160 
and preparation and sending for
rejection letters. So basically

162
00:12:27.160 --> 00:12:29.610 
it's four different
activities

163
00:12:30.250 --> 00:12:32.330 
that are represented
here in this

164
00:12:33.330 --> 00:12:38.100 
in this table. So several event
types can be derived from this.

165
00:12:38.110 --> 00:12:42.190 
So we have the prepare letter of
acceptance event type which

166
00:12:42.190 --> 00:12:45.240 
we just call pa for
prepare acceptance,

167
00:12:45.820 --> 00:12:49.440 
we have the prepare letter
of rejection event type.

168
00:12:51.530 --> 00:12:54.840 
This is the two preparation event
types if you want and then

169
00:12:54.840 --> 00:12:58.550 
we have the two sending event
type which is send acceptance

170
00:12:58.550 --> 00:13:03.930 
letter, sal, and we have send
rejection letter or srl.

171
00:13:05.450 --> 00:13:08.830 
And now we can just do the
mechanics that we did before. So

172
00:13:08.830 --> 00:13:12.570 
looking here at the first
the first couple again

173
00:13:13.010 --> 00:13:17.230 
we have a letter with letter ID
273 and we can

174
00:13:17.230 --> 00:13:20.450 
abstract from this letter ID as
well because we are interested

175
00:13:20.450 --> 00:13:24.230 
in the claim as case
idea not in the letter ID.

176
00:13:24.270 --> 00:13:24.360 


177
00:13:25.900 --> 00:13:32.140 
and it's the decision is accept. So
it's obviously prepare acceptance

178
00:13:32.140 --> 00:13:35.340 
letter1239, that
the first event that we find

179
00:13:35.520 --> 00:13:38.050 
that we can derive from
the first tuple here

180
00:13:38.610 --> 00:13:42.630 
and the second is send acceptance
letter 1239

181
00:13:43.240 --> 00:13:47.400 
and the acceptance letter is
then sent here, so the SentDate

182
00:13:47.410 --> 00:13:51.160 
and sentTime. So PrepDate
prepTime is

183
00:13:51.160 --> 00:13:55.290 
responsible for the preparation
event types and sentDate and

184
00:13:55.290 --> 00:13:58.420 
sentType is responsible for
the sending event type.

185
00:13:58.830 --> 00:14:04.490 
And the decision accept or reject is then
responsible for saying either reject

186
00:14:04.750 --> 00:14:09.920 
or accept. And here you see the set of
event type that we can deduce from this

187
00:14:10.240 --> 00:14:12.920 
letters table.
We have here

188
00:14:13.540 --> 00:14:18.560 
prepare accept 1239 and
then let's pick a prepare reject or pr

189
00:14:18.720 --> 00:14:24.040 
1242, and so that's
prepare rejection letter

190
00:14:24.040 --> 00:14:28.090 
1242 and send rejection
letter 1242 and

191
00:14:28.090 --> 00:14:31.830 
if we now find 1242
we see that we have

192
00:14:31.830 --> 00:14:37.510 
a reject here, that has led to
the two events that were created

193
00:14:37.580 --> 00:14:39.630 
based on this
one tuple

194
00:14:40.520 --> 00:14:42.030 
in this table.
