WEBVTT

1
00:00:01.350 --> 00:00:06.190 
Hello and welcome to our overview about NoSQL Databases and

2
00:00:06.540 --> 00:00:08.540 
MongoDB. My name is Philipp Brune

3
00:00:09.610 --> 00:00:12.330 
of the Neu-Ulm University of Applied Sciences.

4
00:00:14.650 --> 00:00:19.100 
When we look at the history of database management systems we see that

5
00:00:19.960 --> 00:00:23.580 
nowadays, and for many years, even decades now,

6
00:00:24.230 --> 00:00:30.100 
Relational Database Management Systems or RDMS are the dominant technology

7
00:00:30.720 --> 00:00:33.740 
for business and enterprise applications.

8
00:00:36.060 --> 00:00:39.370 
The success of RDBMS is also due to their

9
00:00:40.890 --> 00:00:44.210 
simple concept and principle. The simplicity of the concept

10
00:00:44.220 --> 00:00:49.240 
of the relational model that allows with a single concept namely the relation

11
00:00:49.500 --> 00:00:52.050 
or as we typically call it in practice a table

12
00:00:53.310 --> 00:00:57.710 
to model basically all kind of data structures.

13
00:00:58.600 --> 00:01:04.040 
Is a very conceptually, very simple and very powerful idea proposed

14
00:01:04.040 --> 00:01:08.300 
by E.F Codd in the seventies already. And since then database

15
00:01:08.300 --> 00:01:11.280 
management systems that use that concept of relations

16
00:01:12.100 --> 00:01:13.800 
became very successful because,

17
00:01:15.250 --> 00:01:17.390 
despite that the basic idea is simple

18
00:01:18.220 --> 00:01:21.460 
these tools are very, very powerful and a lot of programming

19
00:01:21.460 --> 00:01:25.670 
features could be added to the systems, and this made these

20
00:01:25.670 --> 00:01:29.410 
database management systems complex. But most of the central

21
00:01:29.410 --> 00:01:34.340 
data stores like DB2 or Oracle DBMS ,in companies, also on

22
00:01:34.340 --> 00:01:36.320 
the mainframe or typically on the mainframe

23
00:01:36.750 --> 00:01:43.540 
are RDBMS today. RDBMS support transactions very well since they

24
00:01:43.960 --> 00:01:51.560 
run on vertically scalable systems. And due to the standardized language sql

25
00:01:52.900 --> 00:01:54.710 
query language,

26
00:01:55.460 --> 00:01:59.830 
standard language, structured query language which allows to

27
00:02:00.110 --> 00:02:04.940 
access the data in a standardized and platform independent

28
00:02:04.940 --> 00:02:07.740 
way. At least in theory, platform independent way

29
00:02:08.480 --> 00:02:10.300 
makes these kind of databases very,

30
00:02:11.990 --> 00:02:15.640 
very nicely to use and so they are used more or less in

31
00:02:16.300 --> 00:02:19.190 
most classical business applications today.

32
00:02:20.390 --> 00:02:22.010 
Nevertheless there are

33
00:02:23.260 --> 00:02:28.990 
scenarios where RDBMS may not be the best choice or the best tool

34
00:02:28.990 --> 00:02:33.940 
or even are not capable of handling certain types of data and in recent years

35
00:02:34.420 --> 00:02:37.900 
with the rise of the internet and all these heterogeneous data

36
00:02:38.930 --> 00:02:41.350 
NoSql databases showed up.

37
00:02:42.090 --> 00:02:44.910 
NoSql is an acronym that stands for

38
00:02:45.680 --> 00:02:52.540 
Not Only Sql. so they are not meant as a replacement for RDBMS- which are

39
00:02:52.660 --> 00:02:56.910 
very good for a lot of scenarios in corporate and enterprise computing,

40
00:02:57.190 --> 00:02:59.040 
where you have structured, well structured

41
00:02:59.940 --> 00:03:05.640 
information. But NoSql focuses on another domain, namely

42
00:03:06.550 --> 00:03:11.100 
the data processing challenges that arise from big data. From

43
00:03:11.100 --> 00:03:13.940 
big data processing, from analytical processing,

44
00:03:14.750 --> 00:03:19.930 
from using heterogeneous high volume data that is not so structured.

45
00:03:19.930 --> 00:03:21.710 
For example, if you think of data

46
00:03:22.660 --> 00:03:28.740 
in the internet, you might have videos, audio files. These are very, very

47
00:03:29.150 --> 00:03:30.920 
poorly structured information.

48
00:03:31.570 --> 00:03:37.030 
We have Geospatial data, we have the social graph in social networks.

49
00:03:37.700 --> 00:03:41.950 
Social graph means the network that is you and your friends,

50
00:03:41.950 --> 00:03:44.410 
and the friends of your friends, and the relations between them

51
00:03:45.180 --> 00:03:48.600 
which are graph like structures. So that's the social graph

52
00:03:49.170 --> 00:03:51.100 
which can become very big.

53
00:03:51.950 --> 00:03:56.370 
And all these kind of information is textual data -

54
00:03:57.130 --> 00:04:00.820 
just plain text, natural language. All these things are

55
00:04:01.680 --> 00:04:05.530 
information that we have nowadays more and more and when you

56
00:04:05.640 --> 00:04:08.860 
talk about the big data you see that the majority of the data

57
00:04:08.860 --> 00:04:11.960 
in the world is unstructured and heterogeneous and not structured. So

58
00:04:12.890 --> 00:04:16.150 
for these kind of data, for analytics, and artificial intelligence,

59
00:04:16.150 --> 00:04:19.160 
machine learning and so on, we need another way of storing and

60
00:04:19.160 --> 00:04:23.230 
retrieving this information, and this is where NoSQL comes into place. So it's

61
00:04:23.370 --> 00:04:26.770 
not a replacement for the Classical RDBMS, but an addition alternative

62
00:04:28.570 --> 00:04:33.410 
approach. And typically for NoSQL databases, is that they

63
00:04:33.860 --> 00:04:35.990 
don't use very strict structures,

64
00:04:36.760 --> 00:04:41.140 
they can store information that is different, that is not

65
00:04:41.560 --> 00:04:42.650 
structures with the same

66
00:04:43.290 --> 00:04:45.120 
structure- like in a table for example.

67
00:04:46.030 --> 00:04:51.970 
And they focus on a distributed processing to process these large amounts of

68
00:04:52.230 --> 00:04:56.160 
high volume data and fast process this data

69
00:04:57.010 --> 00:04:59.790 
NoSQL databases typically focus on a

70
00:05:00.210 --> 00:05:04.780 
distributed processing scheme, running on a nodes, or in a cluster

71
00:05:04.790 --> 00:05:09.170 
or in a grid. So the processing is split up among separate nodes that

72
00:05:09.660 --> 00:05:11.960 
are horizontally scalable. Scale out

73
00:05:12.820 --> 00:05:19.500 
is the topic here and these different nodes are

74
00:05:19.670 --> 00:05:24.910 
connected to each other using a network and exchange data using the network.

75
00:05:26.810 --> 00:05:31.130 
Therefore these databases need to ensure schemes that allow distributed processing.

76
00:05:31.690 --> 00:05:36.820 
And availability, high availability is typically achieved by redundancy and

77
00:05:38.150 --> 00:05:40.020 
replica, replication of data.

78
00:05:41.080 --> 00:05:44.510 
And whole databases are from the idea,

79
00:05:45.140 --> 00:05:47.610 
from the origin they are horizontally scalable.

80
00:05:48.900 --> 00:05:53.040 
Typically this is achieved by avoiding having strict schemas

81
00:05:53.040 --> 00:05:57.380 
or they are schema-less, having simple efficient APIS, like for example

82
00:05:58.030 --> 00:06:04.970 
javascript based or RESTful APIs. And by usually dropping the support for

83
00:06:05.380 --> 00:06:08.190 
strict transaction properties- the ACID properties.

84
00:06:08.890 --> 00:06:14.210 
This was one of the typical domains of the RDBMS systems or is still

85
00:06:15.160 --> 00:06:17.940 
since transaction processing is an important

86
00:06:18.430 --> 00:06:21.960 
concept. We learned that in the chapter about transaction processing.

87
00:06:22.240 --> 00:06:26.340 
And relational database management systems are rather good in ensuring

88
00:06:27.710 --> 00:06:32.660 
the transaction properties, the ACID properties and having transaction-aware

89
00:06:33.110 --> 00:06:38.650 
processing. Of course this requires, or this limits the processing to a

90
00:06:39.660 --> 00:06:43.320 
single machine, which is what we call vertical scalability.

91
00:06:44.130 --> 00:06:46.010 
and which is typical of the

92
00:06:46.660 --> 00:06:48.930 
traditional mainframes. And

93
00:06:50.340 --> 00:06:52.500 
in NoSQL, we have a different scheme.

94
00:06:53.450 --> 00:06:58.210 
Horizontally scalable and that is very different and very difficult to

95
00:06:58.570 --> 00:07:04.620 
achieve this these transactional properties. So typically NoSQL databases either

96
00:07:05.100 --> 00:07:11.140 
provide no or just reduced guarantees for ensuring the ACID properties.

97
00:07:11.300 --> 00:07:13.360 
So these are typical

98
00:07:14.080 --> 00:07:17.900 
concepts that are common to nearly all NoSQL databases.

99
00:07:18.340 --> 00:07:23.050 
And one sees that it's not about replacing completely RDBMS, but

100
00:07:23.190 --> 00:07:24.880 
providing tools for

101
00:07:26.180 --> 00:07:30.600 
different kind of workloads, and for different kind of application scenarios.

102
00:07:31.520 --> 00:07:34.830 
Nosql is more like a general term. So

103
00:07:36.440 --> 00:07:38.990 
behind the idea of NoSql,

104
00:07:40.070 --> 00:07:44.150 
there are different types of database management systems

105
00:07:44.700 --> 00:07:47.570 
and different types of

106
00:07:48.380 --> 00:07:51.070 
solutions that implement these kind of schemes.

107
00:07:51.750 --> 00:07:56.110 
And on this slide, you see a sort of a list of these typical NoSQL

108
00:07:58.130 --> 00:08:03.240 
classes or this classification of NoSQL databases.

109
00:08:06.230 --> 00:08:08.850 
Top most is the so called Key-Value Star-

110
00:08:09.690 --> 00:08:11.530 
sometimes also called Tuple Star,

111
00:08:12.360 --> 00:08:13.180 
which is the

112
00:08:14.570 --> 00:08:17.590 
most classical NoSQL database type probably.

113
00:08:18.320 --> 00:08:22.500 
Then we have document oriented databases or document stars

114
00:08:22.920 --> 00:08:27.360 
and column oriented databases. There are some more which are

115
00:08:27.560 --> 00:08:32.100 
in principle fall in the category of NoSQL, like graph oriented and

116
00:08:32.570 --> 00:08:34.250 
object oriented DBMS.

117
00:08:34.920 --> 00:08:39.440 
But these two are somehow NoSQL databases that

118
00:08:40.170 --> 00:08:45.390 
existed already before the hype and discussion about NoSQLs.

119
00:08:45.510 --> 00:08:48.820 
So I put them in brackets here. We will not discuss them further

120
00:08:48.820 --> 00:08:51.890 
because these existed already before the NoSQL

121
00:08:53.180 --> 00:08:58.580 
discussion. And graph oriented database management systems are those that use

122
00:08:59.690 --> 00:09:03.760 
graphs or hierarchy or network style like structure to store

123
00:09:03.760 --> 00:09:09.340 
and retrieve the data. And object oriented database management systems or OODBMS

124
00:09:09.630 --> 00:09:14.570 
exist already like from the nineties. It was a big trend in the nineties

125
00:09:15.210 --> 00:09:17.050 
in research and also in practice

126
00:09:17.740 --> 00:09:21.770 
to extend relational models to object oriented models. But this

127
00:09:21.770 --> 00:09:26.680 
trend more or less did not lead to a replacement of RDBMS. Instead

128
00:09:26.940 --> 00:09:30.860 
the mainstream RDBMS systems like DB2 and Oracle have been

129
00:09:31.550 --> 00:09:33.840 
sort of

130
00:09:34.810 --> 00:09:39.220 
enriched by object oriented features. And on the other hand,

131
00:09:39.890 --> 00:09:43.990 
the concept of object oriented databases like object oriented query languages

132
00:09:44.280 --> 00:09:45.450 
more or less lead to the

133
00:09:46.520 --> 00:09:51.690 
evolution of these object relational mapping libraries- like hibernate or JPA, that

134
00:09:51.860 --> 00:09:55.280 
we for example, have an object ordered languages, which are not

135
00:09:55.280 --> 00:09:59.500 
really independent databases but map object oriented structures in

136
00:10:00.210 --> 00:10:04.650 
programming languages on the relational tables, and providing an object oriented

137
00:10:04.830 --> 00:10:06.730 
view on the database. So

138
00:10:07.550 --> 00:10:10.300 
the concepts are there but these kind of databases are a bit

139
00:10:10.300 --> 00:10:13.820 
special and do not play such a big role anymore today. So

140
00:10:14.260 --> 00:10:17.560 
we will not further discuss graph oriented and object oriented

141
00:10:17.800 --> 00:10:19.230 
databases in this lesson.

142
00:10:21.520 --> 00:10:27.760 
So let us have a look a closer look on the typical NoSQL

143
00:10:29.610 --> 00:10:32.320 
data stores like the Key-Value store in the following.

144
00:10:33.940 --> 00:10:35.120 
Let's have a short look on the

145
00:10:35.790 --> 00:10:37.260 
first three of the list.

146
00:10:38.980 --> 00:10:41.590 
Because they are typical for the different

147
00:10:42.750 --> 00:10:45.990 
solutions, the different database systems that exist-

148
00:10:46.810 --> 00:10:49.240 
Most of them open source implementations.

149
00:10:50.230 --> 00:10:52.710 
So let's start with a Key-Value Store or tuple store.

150
00:10:53.290 --> 00:10:54.990 
In a Key-Value Store basically

151
00:10:56.360 --> 00:11:00.050 
an object- data set, any kind of data- we call it the value

152
00:11:00.690 --> 00:11:06.450 
is start referenced by a key. The key can be a number or

153
00:11:06.920 --> 00:11:08.790 
any kind of unique

154
00:11:10.330 --> 00:11:16.870 
identifier that references the data that is the value. okay. So you can

155
00:11:16.870 --> 00:11:18.290 
see it here, we have a key.

156
00:11:19.010 --> 00:11:22.980 
And on the other side, the key points to some kind of data.

157
00:11:23.750 --> 00:11:27.670 
The data can be different for each key. It's just sort of an unstructured

158
00:11:27.810 --> 00:11:30.700 
thing, okay. And this is of course very efficient if you want

159
00:11:30.700 --> 00:11:34.190 
to store heterogeneous data and you want to access it only

160
00:11:34.190 --> 00:11:39.340 
by means of the key. So in a key-value star, the data can only be retrieved by

161
00:11:39.830 --> 00:11:42.710 
the key. It can be searched by the key but it cannot be searched

162
00:11:42.710 --> 00:11:44.460 
by the content in the object.

163
00:11:45.220 --> 00:11:48.660 
This is on one hand very simple on the other hand rather powerful because

164
00:11:48.910 --> 00:11:51.790 
in many applications you typically access the data by the key.

165
00:11:52.470 --> 00:11:54.920 
Just think of business applications, where you for example,

166
00:11:55.710 --> 00:11:58.540 
work with customer data always going in with a customer number

167
00:11:58.540 --> 00:12:00.610 
or with a building number or things like that.

168
00:12:03.760 --> 00:12:09.120 
In general, this idea is not new. It exists for many years.

169
00:12:09.550 --> 00:12:15.300 
For example, as for decades now under unix and linux systems, there is Berkeley DB.

170
00:12:16.290 --> 00:12:21.450 
BerkeleyDB is a Key-Value Store implementation, now belongs to Oracle. It's an open source

171
00:12:22.030 --> 00:12:25.290 
database, more like it's written in C, it's a small library.

172
00:12:25.290 --> 00:12:27.620 
It's very efficient to store and retrieve data.

173
00:12:28.690 --> 00:12:30.910 
It can be used in other applications, for example.

174
00:12:33.390 --> 00:12:37.380 
Closer to NoSQL typically are databases like Membase,

175
00:12:38.160 --> 00:12:42.690 
Couchbase or Microsoft Azure Cloud provides the so-called table

176
00:12:42.690 --> 00:12:45.860 
storage, which is a key-value store. And as

177
00:12:47.520 --> 00:12:51.840 
the VMware Redis database. So these are open source databases that you might

178
00:12:51.990 --> 00:12:56.990 
know that are used for example in web development or application development and other

179
00:12:57.180 --> 00:12:58.870 
things in the context of

180
00:12:59.760 --> 00:13:01.060 
big data applications.

181
00:13:02.310 --> 00:13:05.360 
In general you can think of a key-value store similar to a

182
00:13:05.660 --> 00:13:09.090 
hash table or hash map java or any other higher programming

183
00:13:09.090 --> 00:13:11.910 
language where you can reference a data object with a key.

184
00:13:13.530 --> 00:13:17.330 
And there's also relation to the mainframe because on the mainframe we

185
00:13:17.680 --> 00:13:21.640 
had also key-value stores already a long time ago in the so called ISAM or VSAM

186
00:13:22.920 --> 00:13:28.850 
data sets which provides this kind of indexed sequential or key sequential access, that is

187
00:13:29.210 --> 00:13:32.760 
basically nothing else in a key-value store. So these old ideas,

188
00:13:32.910 --> 00:13:36.970 
they still are live and useful and you see that many of these old ideas

189
00:13:38.470 --> 00:13:42.520 
come back in a new dressing today. So they

190
00:13:43.320 --> 00:13:45.640 
have proven to be valuable over the years.

191
00:13:47.840 --> 00:13:50.340 
A variant of the key-value store as a document store

192
00:13:50.340 --> 00:13:53.610 
is probably the most popular type of NoSQL database.

193
00:13:55.380 --> 00:13:56.280 
The document store or

194
00:13:57.360 --> 00:14:03.810 
document DBMS works in a way that the data that is stored under the key

195
00:14:04.070 --> 00:14:10.260 
is not just a defined data but a document. And a document has a structure-

196
00:14:10.640 --> 00:14:12.450 
typically a hierarchical structure.

197
00:14:13.110 --> 00:14:17.550 
And the documents are referenced by a key. The key points to the

198
00:14:17.550 --> 00:14:20.670 
document as you can see here. But the document now may be a

199
00:14:20.670 --> 00:14:24.740 
JSON structure or it may be an xml structure typically.

200
00:14:25.560 --> 00:14:29.300 
And every document can be different, so there's no fixed schema

201
00:14:29.300 --> 00:14:33.330 
like a relational database. But the objects have a structure

202
00:14:33.330 --> 00:14:37.300 
and a structure makes it possible to search and retrieve data

203
00:14:37.840 --> 00:14:41.480 
according to the content of the document as well. So

204
00:14:42.180 --> 00:14:43.870 
these type of database systems

205
00:14:45.140 --> 00:14:48.520 
are rather similar to key-value stores, but the document has a structure

206
00:14:48.660 --> 00:14:52.070 
and therefore it searchable and retrievable using query languages

207
00:14:52.070 --> 00:14:55.340 
that work on documents like XQuery Xpath and Json IQ.

208
00:14:57.220 --> 00:14:59.930 
The most popular formats that are used in this type of documents,

209
00:15:00.150 --> 00:15:04.180 
or databases are either Json, the javascript object

210
00:15:04.180 --> 00:15:08.140 
notation format which is a textual representation of hierarchical information

211
00:15:08.420 --> 00:15:11.440 
in a way that it automatically is a valid javascript

212
00:15:11.980 --> 00:15:16.130 
object definition. So it can be directly parsed and used in

213
00:15:16.130 --> 00:15:17.310 
javascript. Which is just very

214
00:15:18.020 --> 00:15:21.740 
nicely for building web applications that direct access the

215
00:15:21.740 --> 00:15:22.950 
database from the front-end

216
00:15:23.740 --> 00:15:27.540 
or xml where you have the typical tags with

217
00:15:28.370 --> 00:15:33.790 
brackets and a structure that is also a hierarchical self describing document structure.

218
00:15:34.630 --> 00:15:37.880 
Examples for these kind of databases are for example, BaseX

219
00:15:37.880 --> 00:15:42.190 
which is an xml based database, or Apache CouchDB

220
00:15:42.800 --> 00:15:46.330 
which is Json based, or of course the most popular one that

221
00:15:46.330 --> 00:15:49.130 
you will have a closer look on afterwards is MongoDB. MongoDB is

222
00:15:49.990 --> 00:15:53.190 
probably the most popular NoSQL database. Now it is used in many

223
00:15:53.190 --> 00:15:55.690 
types of applications, also business applications.

224
00:15:57.020 --> 00:16:00.490 
It's Json based, so it's a javascript oriented database.

225
00:16:02.900 --> 00:16:08.960 
Another type of the NoSQL database are the so called column oriented databases,

226
00:16:10.260 --> 00:16:12.020 
which are

227
00:16:12.700 --> 00:16:17.750 
again similar in some way to key-value stars. But they use

228
00:16:18.300 --> 00:16:21.540 
combined keys consisting of a set of column

229
00:16:23.420 --> 00:16:27.930 
table, column values. You can think of column values and

230
00:16:28.590 --> 00:16:31.820 
this can be a multi dimensional key. It can be rather complex.

231
00:16:31.820 --> 00:16:36.320 
It can have a lot of components and all these components together, this

232
00:16:36.790 --> 00:16:40.330 
set of values identifies then uniquely,

233
00:16:41.260 --> 00:16:46.330 
for example a document like an html page. That is already coming from, then

234
00:16:46.520 --> 00:16:50.150 
it was invented by google basically to store and retrieve the

235
00:16:50.540 --> 00:16:54.210 
pages in the search engine. And

236
00:16:56.340 --> 00:16:59.980 
that was the original publication by Chang from two thousand and six.

237
00:17:00.490 --> 00:17:01.080 
And then

238
00:17:03.250 --> 00:17:08.610 
the idea is that again this is not so strict as relational

239
00:17:09.010 --> 00:17:12.970 
models, since we do not have to have a value for every column

240
00:17:13.360 --> 00:17:17.380 
in one key. So the key can also just have empty empty fields

241
00:17:17.380 --> 00:17:21.610 
and therefore it's not directly comparable to a set of columns in a

242
00:17:21.990 --> 00:17:26.560 
relational database. But it provides the concept

243
00:17:26.570 --> 00:17:28.150 
to store the data, not

244
00:17:28.850 --> 00:17:31.820 
row wise but column wise, in the sense that you can have

245
00:17:33.260 --> 00:17:37.290 
also compression techniques to reduce the number of

246
00:17:37.330 --> 00:17:41.140 
values, for example if the same value comes a lot many times in the column

247
00:17:41.530 --> 00:17:42.930 
one after another, okay.

248
00:17:44.350 --> 00:17:48.020 
Examples for this kind of databases are for example Hbase

249
00:17:48.020 --> 00:17:51.610 
based on the Apache Hadoop file system, distributed file system.

250
00:17:52.180 --> 00:17:55.450 
And of course Google BigTable, which is also used in the google app engine.

251
00:17:55.970 --> 00:17:57.880 
This is due to the fact that google

252
00:17:58.500 --> 00:18:02.020 
basically invented this kind of databases. And there's Apache

253
00:18:02.020 --> 00:18:07.710 
Cassandra, which is also very popular. It's also an Apache project and cassandra is

254
00:18:09.150 --> 00:18:13.500 
again such a multi database, also schema-less and also typical

255
00:18:14.010 --> 00:18:16.350 
NoSQL database. Cassandra is written in java

256
00:18:16.960 --> 00:18:21.180 
and therefore it runs also on the mainframe, for example. Even though

257
00:18:21.880 --> 00:18:23.210 
there are some pitfalls

258
00:18:23.990 --> 00:18:26.480 
in importing cassandra to linux on the mainframe.

259
00:18:27.750 --> 00:18:31.270 
We tried this once, we experienced some problems since somewhere in the

260
00:18:31.710 --> 00:18:35.540 
files of Cassandra there were some C code or some C code hidden

261
00:18:35.560 --> 00:18:39.380 
that had to be compiled first but afterwards it worked. So Cassandra

262
00:18:39.380 --> 00:18:42.410 
is ported in portable also to linux on the mainframe.

263
00:18:43.210 --> 00:18:48.010 
But it what it tells you is that sometimes porting even of java applications

264
00:18:48.860 --> 00:18:52.690 
can be cumbersome, because there are some hidden native code parts.

265
00:18:53.450 --> 00:18:57.110 
And also Hypertable is another example of such kind of databases.

266
00:18:59.270 --> 00:19:03.360 
Let us have a look a closer look now on MongoDB, since it is probably the most popular

267
00:19:03.560 --> 00:19:05.340 
SQL database. And

268
00:19:06.610 --> 00:19:09.240 
when we discuss about nNoSQL databases in general,

269
00:19:09.740 --> 00:19:13.890 
one has also to talk a little bit about Map-Reduce. Map-Reduce

270
00:19:14.790 --> 00:19:20.090 
is a more or less the fundamental principle that basically all these distributed

271
00:19:20.300 --> 00:19:23.700 
NoSql databases use to process or dio

272
00:19:24.440 --> 00:19:27.260 
data processing, complex queries on distributed

273
00:19:27.770 --> 00:19:30.250 
data. As I said, one

274
00:19:31.880 --> 00:19:35.980 
common concept of NoSQL is that typically these databases are made for

275
00:19:36.160 --> 00:19:39.520 
running on a grid or a cluster of nodes of service,

276
00:19:39.980 --> 00:19:43.230 
which means that one has to find a way to distribute the work.

277
00:19:43.230 --> 00:19:46.510 
Let the work be distributed and collect again the results. So you have

278
00:19:46.800 --> 00:19:50.740 
again a a common central point of

279
00:19:51.460 --> 00:19:56.340 
accessing the data, okay. And this is what the Map-Reduce scheme is basically made for.

280
00:19:56.750 --> 00:19:58.880 
And it was introduced by Dean and Ghemawat

281
00:20:00.570 --> 00:20:04.170 
in two thousand and four, proposed in a paper by Google.

282
00:20:04.810 --> 00:20:09.930 
And it's basically implemented in all NoSQL databases today. And

283
00:20:11.180 --> 00:20:14.020 
the basic idea is always you have a structure like this. There's

284
00:20:14.020 --> 00:20:17.500 
a Master Node which is responsible for the interaction with

285
00:20:17.680 --> 00:20:21.010 
the client, with the user or with the software that uses the database.

286
00:20:21.380 --> 00:20:24.560 
And then it gets a query for example. It distributes the work

287
00:20:24.560 --> 00:20:27.450 
on the so called Worker Nodes. I must imagine that this

288
00:20:27.450 --> 00:20:30.610 
usually involves a network communication here, to the different nodes.

289
00:20:31.010 --> 00:20:33.840 
The Worker Nodes process part of the data. Data is

290
00:20:34.740 --> 00:20:35.740 
gathered again in

291
00:20:37.350 --> 00:20:40.580 
the Master Node and maybe then distributed again for the next step. So

292
00:20:41.030 --> 00:20:43.910 
there's always network communication involved in these kind

293
00:20:43.910 --> 00:20:48.120 
of distributed architectures and the Map-Reduce scheme is designed in a way

294
00:20:48.230 --> 00:20:49.840 
that if you split up

295
00:20:50.490 --> 00:20:54.390 
every data processing operation into steps- the map phase and the reduce phase.

296
00:20:54.910 --> 00:20:59.030 
And the map phase, you can see how it works. A mapping is done

297
00:20:59.550 --> 00:21:05.540 
and it's a mapping that for each key-value pair that is processed

298
00:21:05.840 --> 00:21:07.900 
this is mapped to a list of another

299
00:21:08.660 --> 00:21:10.650 
set of key-value pairs, okay.

300
00:21:12.380 --> 00:21:15.150 
You can imagine this, this is the example from the paper here.

301
00:21:15.730 --> 00:21:19.550 
Which is basically I'm talking about documents. Think of the

302
00:21:19.550 --> 00:21:23.810 
question- you want to count the words in a big set of documents of texts documents,

303
00:21:24.250 --> 00:21:27.590 
and you split the text document on the different Worker Nodes.

304
00:21:27.590 --> 00:21:30.290 
And every Worker Node first starts to count

305
00:21:30.770 --> 00:21:34.410 
the words that he has in his text, in its text

306
00:21:35.580 --> 00:21:38.780 
on the note and you get a list of words and the

307
00:21:39.580 --> 00:21:42.600 
number of occurrences. So this is the key-value set

308
00:21:43.190 --> 00:21:46.610 
and then the data is collected and distributed again, which

309
00:21:46.610 --> 00:21:48.990 
is called the shuffle phase which is always between the map

310
00:21:48.990 --> 00:21:51.430 
and the reduce phase. And then the second step now,

311
00:21:52.120 --> 00:21:59.100 
the notes start to aggregate for each different key, the counts that

312
00:21:59.330 --> 00:22:02.490 
have been obtained in the first iteration. Okay so that is the

313
00:22:03.480 --> 00:22:07.270 
basic structure. The first step, first it is mapped and then it is

314
00:22:07.430 --> 00:22:08.750 
summed up and aggregated.

315
00:22:09.950 --> 00:22:14.320 
And this is basically the fundamental scheme and a lot of data processing

316
00:22:14.420 --> 00:22:17.760 
operations can be somehow mapped on this kind of

317
00:22:18.460 --> 00:22:21.250 
scheme. Of course the function that is actually

318
00:22:21.880 --> 00:22:24.550 
executed in the Map and the Reduce Phace is

319
00:22:25.240 --> 00:22:28.630 
sort of specific for every single query or has to be provided

320
00:22:28.630 --> 00:22:31.140 
by the developer for every operation separately. So it's not

321
00:22:31.520 --> 00:22:33.700 
a given. It's more like the scheme how it is executed.

322
00:22:35.980 --> 00:22:39.940 
And Map-Reduce is the underlying scheme for most of these non- relational databases.

323
00:22:40.080 --> 00:22:43.420 
these NoSQL databases. And

324
00:22:44.290 --> 00:22:50.980 
of course MongoDB runs on linux and it runs on linux for

325
00:22:51.320 --> 00:22:53.980 
systems, that not from the beginning but for some years,

326
00:22:53.980 --> 00:22:55.130 
now it has been ported.

327
00:22:56.060 --> 00:22:59.990 
MongoDB is written in C. It has some internal dependencies in

328
00:22:59.990 --> 00:23:01.060 
the original version on

329
00:23:02.020 --> 00:23:04.960 
the X86 architecture and the register structure and

330
00:23:04.960 --> 00:23:08.210 
things like that, that had to be modified for the part. So it

331
00:23:08.210 --> 00:23:11.740 
was not something that was ported immediately very, very early

332
00:23:11.740 --> 00:23:14.880 
but it is available now for some years already. So

333
00:23:18.420 --> 00:23:22.450 
a database to store JSON documents as I already mentioned

334
00:23:22.530 --> 00:23:25.820 
and I wanted to illustrate this so you see some screenshots

335
00:23:25.820 --> 00:23:27.120 
here on the right hand side.

336
00:23:28.720 --> 00:23:32.460 
The background is basically to illustrate and

337
00:23:32.460 --> 00:23:35.220 
to prove to you that we are really working on a mainframe. So

338
00:23:35.220 --> 00:23:38.930 
you see this is our linux prompt here and I just

339
00:23:41.780 --> 00:23:44.820 
printed out the info from CPUinfo from the profile

340
00:23:44.820 --> 00:23:46.550 
system, and it shows you that it's

341
00:23:47.500 --> 00:23:49.970 
S398 architecture here. So you see it's on

342
00:23:49.970 --> 00:23:52.820 
the mainframe. You can see the prompt and it's the same here. So

343
00:23:53.790 --> 00:23:57.010 
hopefully believe me that this has been run on a linux on the

344
00:23:57.010 --> 00:24:00.120 
mainframe because otherwise you won't recognize because MongoDB on the linux. on

345
00:24:01.320 --> 00:24:03.990 
the mainframe looks basically the same as MongoDB or every other

346
00:24:03.990 --> 00:24:07.140 
other linux version. Okay so on the right-hand side so

347
00:24:07.140 --> 00:24:09.740 
you see a interaction with MongoDB.

348
00:24:11.290 --> 00:24:14.600 
From the command line, so this is a command line tool Mongo, it's a client

349
00:24:14.870 --> 00:24:18.550 
that has a interactive shell where you can give commands to

350
00:24:18.550 --> 00:24:24.470 
the MongoDB server. And here some status messages but then we start to,

351
00:24:25.260 --> 00:24:27.680 
just to illustrate how it works. So you see here

352
00:24:30.130 --> 00:24:32.760 
the demo data set and a data set is added

353
00:24:33.390 --> 00:24:38.650 
or a document is added here to the data set. If you add a character

354
00:24:38.650 --> 00:24:39.650 
from Harry Potter here.

355
00:24:40.460 --> 00:24:44.640 
In the data set and you see it's just a JSON object. You can

356
00:24:44.640 --> 00:24:45.900 
see the JSON object here

357
00:24:46.770 --> 00:24:48.960 
consisting of names and values.

358
00:24:50.100 --> 00:24:55.670 
And it is just put inside the data set with this javascript style

359
00:24:55.890 --> 00:25:01.010 
notation here. So basically the interface is also looks like javascript functions.

360
00:25:01.570 --> 00:25:06.920 
And then in the next step there's a query executed. The query is executed

361
00:25:08.010 --> 00:25:10.980 
by just putting another JSON object. That sort of

362
00:25:11.810 --> 00:25:15.900 
classifies the set of objects that should be retrieved.

363
00:25:16.950 --> 00:25:18.560 
So everything with a certain

364
00:25:19.860 --> 00:25:25.110 
value for occupation is retrieved and then we get the

365
00:25:25.410 --> 00:25:28.210 
results here. Ok so they are printed of but you can see that

366
00:25:28.230 --> 00:25:31.610 
here we add the data set and here you see that it adds the key.

367
00:25:31.720 --> 00:25:34.390 
The key is this technical identifier that you can see here.

368
00:25:34.810 --> 00:25:37.590 
The ID which is automatically created then for every

369
00:25:38.160 --> 00:25:41.950 
document that is sought in the database. So this works on the

370
00:25:41.950 --> 00:25:43.770 
system set and the question of course is,

371
00:25:44.380 --> 00:25:47.560 
is this useful or why we do that?

372
00:25:48.770 --> 00:25:53.650 
And again the mainframe is not a distributed architecture. So

373
00:25:54.160 --> 00:25:55.280 
MongoDB instance on Linux

374
00:25:57.150 --> 00:26:02.220 
system set does not necessarily have to use the distributed and

375
00:26:02.420 --> 00:26:05.430 
horizontal scaling mechanisms of

376
00:26:06.630 --> 00:26:13.760 
MongoDB. So you can now put MongoDB on a virtual cluster that runs on a single machine

377
00:26:14.340 --> 00:26:17.190 
or a virtual linux guest for example, on a mainframe

378
00:26:17.780 --> 00:26:21.900 
or you can just use vertical scaling and just run it on a single node

379
00:26:22.140 --> 00:26:25.670 
and make this node very big. So both options are possible. In

380
00:26:25.670 --> 00:26:30.420 
both cases you may reduce the overhead for administration and network communication compared

381
00:26:30.590 --> 00:26:36.520 
to the installation in a distributed network cluster. So it has some advantages

382
00:26:36.740 --> 00:26:39.190 
and in combination with the IO bandwidth and

383
00:26:40.210 --> 00:26:45.110 
the data processing capabilities of the mainframe architecture, this

384
00:26:45.110 --> 00:26:49.060 
can lead to very powerful and very efficiently administratable MongoDB

385
00:26:50.460 --> 00:26:55.230 
instances. So this was what I wanted to present about in

386
00:26:55.230 --> 00:26:59.870 
NoSQL in general and MongoDB in particular as the most prominent example probably.

387
00:27:00.310 --> 00:27:03.560 
And we say that these modern concepts of NoSQL

388
00:27:04.090 --> 00:27:06.000 
also play a role in the

389
00:27:06.670 --> 00:27:08.020 
mainframe but especially

390
00:27:08.860 --> 00:27:12.640 
on linux for systems and our linux one. Thank you very much.
