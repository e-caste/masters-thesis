WEBVTT

1
00:00:00.890 --> 00:00:05.869 
Welcome to an overview on the current trends on Linux on the mainframe.

2
00:00:05.870 --> 00:00:09.890 
My name is Phillipp Brune from the Neu Ulm University of Applied Sciences.

3
00:00:13.070 --> 00:00:17.989 
In recent years, Linux has become more and more important on the mainframe platform

4
00:00:17.990 --> 00:00:22.459 
and also is highly supported, and the new

5
00:00:22.460 --> 00:00:26.269 
features are added by IBM on the mainframe platform.

6
00:00:26.270 --> 00:00:31.099 
So Linux now is a real strategic operating system for

7
00:00:31.100 --> 00:00:34.670 
the modern mainframes, and in the recent years since the

8
00:00:35.750 --> 00:00:40.249 
13th generation, IBM also started to market the mainframe in

9
00:00:40.250 --> 00:00:45.109 
particular as a high-end Linux server, and they added a second

10
00:00:45.110 --> 00:00:50.659 
branding and a second production line called Linux one, which

11
00:00:50.660 --> 00:00:55.459 
sort of sells the mainframe hardware under a different brand name Linux

12
00:00:55.460 --> 00:00:58.409 
one to Linux only customers.

13
00:00:58.410 --> 00:01:03.169 
So this is really positioning the platform as a high-end Linux based server

14
00:01:03.170 --> 00:01:08.719 
environment. And in combination with this

15
00:01:08.720 --> 00:01:13.219 
launch of the Linux one platform also, some new features have been

16
00:01:14.480 --> 00:01:17.770 
imported to the to the Linux on s390

17
00:01:19.010 --> 00:01:22.099 
as it is called on the mainframe hardware.

18
00:01:22.100 --> 00:01:27.049 
And among these is KVM, which was not

19
00:01:27.050 --> 00:01:31.789 
available before at least not completely available before, and

20
00:01:31.790 --> 00:01:37.399 
is now also a strategic option on the mainframe hardware.

21
00:01:37.400 --> 00:01:41.989 
KVM is the so-called kernel virtual machine is a concept that

22
00:01:41.990 --> 00:01:46.429 
has been introduced in the Linux kernel for some years now and

23
00:01:46.430 --> 00:01:51.439 
is also standard part of the Linux kernel as the integral part of

24
00:01:51.440 --> 00:01:56.899 
the Linux kernel on most operating systems that the linux supports.

25
00:01:56.900 --> 00:02:01.639 
And so it's a standard feature of the mainline kernel,

26
00:02:01.640 --> 00:02:06.229 
and it basically provides a para virtualization mechanism that is

27
00:02:06.230 --> 00:02:10.939 
by default built into the Linux kernel and allows us to visualize or to run

28
00:02:10.940 --> 00:02:15.529 
virtualized guest operating systems by using para virtualization on

29
00:02:15.530 --> 00:02:17.419 
the Linux kernel.

30
00:02:17.420 --> 00:02:21.329 
The Linux kernel then serves as a kind of a hypervisor.

31
00:02:21.330 --> 00:02:24.289 
Under the concept of

32
00:02:25.998 --> 00:02:30.349 
paravirtualization requires that the guest operating systems are modified and adapted to

33
00:02:30.350 --> 00:02:35.059 
be run in a virtualized environment, which is, of course, especially possible

34
00:02:35.060 --> 00:02:39.109 
if you have Linux on Linux, so you have an open source system on another open source

35
00:02:39.110 --> 00:02:44.659 
system. And in this setting, it became very popular,

36
00:02:44.660 --> 00:02:49.099 
and the basic idea is, as you can see it here on the on the diagram, on

37
00:02:49.100 --> 00:02:52.940 
the figure, you're on mainframe hardware, which can be

38
00:02:54.260 --> 00:02:58.939 
system, so a full mainframe or the Linux one version, which is only

39
00:02:58.940 --> 00:03:02.449 
equipped with IFL processors. So it only runs Linux.

40
00:03:02.450 --> 00:03:07.519 
And on this ,first of all, you run a Linux kernel and

41
00:03:07.520 --> 00:03:11.989 
you're on it, for example, in logical partition and then you use the

42
00:03:11.990 --> 00:03:15.169 
KVM, which is a standard part of this Linux kernel.

43
00:03:15.170 --> 00:03:19.390 
And on top of it, there is the layer that is, basically

44
00:03:21.170 --> 00:03:25.759 
provided by the Qemu environment, which is the original

45
00:03:25.760 --> 00:03:30.559 
emulation, open source emulation environment for different hardware architectures.

46
00:03:30.560 --> 00:03:35.179 
But for KVM, it serves as a kind of a not a full emulation,

47
00:03:35.180 --> 00:03:39.599 
but as the other layer for emulating only the

48
00:03:39.600 --> 00:03:42.139 
for example i/o devices.

49
00:03:42.140 --> 00:03:47.059 
And on top of this, you then run Linux guest systems, virtual

50
00:03:47.060 --> 00:03:51.289 
linux guest systems with their own kernel, which of course, is a kernel that needs to be

51
00:03:51.290 --> 00:03:55.789 
capable to be run on this KVM layer.

52
00:03:55.790 --> 00:03:58.579 
OK. This is the idea of paravirtualization.

53
00:03:58.580 --> 00:04:03.109 
And since Linux, of course, is prepared for that, you can run,

54
00:04:03.110 --> 00:04:07.639 
for example, Linux guests easily on Linux virtualization

55
00:04:07.640 --> 00:04:12.169 
host. And administration tools are provided

56
00:04:12.170 --> 00:04:15.738 
by something called the libvirt and the virsh shell,

57
00:04:18.200 --> 00:04:22.789 
which provides a command and tools to create and stop and start

58
00:04:22.790 --> 00:04:27.269 
the virtual guests and so on, administrate manage to the virtual guests.

59
00:04:27.270 --> 00:04:31.118 
And all these together provides a full-fledged

60
00:04:34.520 --> 00:04:39.709 
virtualization environment in which, the

61
00:04:39.710 --> 00:04:44.329 
big number of virtual guests can be run on a Linux host.

62
00:04:44.330 --> 00:04:47.720 
And it's a fully open source paced environment, so you don't need

63
00:04:49.100 --> 00:04:54.229 
any kind of virtualization system like, for example, ZVM,

64
00:04:54.230 --> 00:04:59.029 
which was the typical solution to a virtualized Linux guest

65
00:04:59.030 --> 00:05:03.559 
or host Linux guests so far, it also still is used in

66
00:05:03.560 --> 00:05:04.560 
many environments.

67
00:05:05.510 --> 00:05:10.009 
So with KVM now there's the option to have a full, pure open

68
00:05:10.010 --> 00:05:14.849 
source virtualization environment on

69
00:05:14.850 --> 00:05:19.319 
the mainframe hardware. And this, of course, is

70
00:05:19.320 --> 00:05:24.599 
especially interesting for companies who really want to have a Linux only

71
00:05:24.600 --> 00:05:29.259 
environment because it allows us to administrate this virtual environment with normal

72
00:05:29.260 --> 00:05:34.199 
Linux skills. You don't need to have special zVM or mainframe

73
00:05:34.200 --> 00:05:38.759 
skills to run Linux in this style on a mainframe

74
00:05:38.760 --> 00:05:39.760 
hardware.

75
00:05:42.020 --> 00:05:46.549 
A second concept that is immensely popular at the moment and

76
00:05:46.550 --> 00:05:51.199 
is probably one of the most important foundations for the the boom

77
00:05:51.200 --> 00:05:56.299 
of cloud computing environments and solutions that we have today is containerization.

78
00:05:56.300 --> 00:06:00.769 
Containerization is a more lightweight virtualization approach, and it

79
00:06:00.770 --> 00:06:04.879 
plays also a big role on Linux on the mainframe.

80
00:06:04.880 --> 00:06:09.201 
And the most popular containerization solution is that the Open-Source

81
00:06:10.550 --> 00:06:13.820 
docker environment or docker daemon, which is

82
00:06:15.020 --> 00:06:20.179 
probably the most widespread solution, not the only one that other containerization

83
00:06:20.180 --> 00:06:24.679 
approaches like Linux containers, for example, but Docker is by far

84
00:06:24.680 --> 00:06:29.479 
the most important one. And of course, Docker is also supported on Linux

85
00:06:29.480 --> 00:06:32.839 
on system set and Linux one.

86
00:06:35.210 --> 00:06:40.039 
It is also supported on virtual guests, so you can see it here

87
00:06:40.040 --> 00:06:41.989 
in a containerization environment.

88
00:06:41.990 --> 00:06:46.699 
You have one Linux kernel, which can be either a virtual

89
00:06:46.700 --> 00:06:50.329 
guest system or on bare metal doesn't matter.

90
00:06:50.330 --> 00:06:55.249 
And there's the kernel, then hosts a number of

91
00:06:55.250 --> 00:06:58.999 
could be a large number of so-called Docker containers.

92
00:06:59.000 --> 00:07:02.509 
Docker containers is an application virtualization approach.

93
00:07:02.510 --> 00:07:07.309 
This means that the containers look like virtual guest machines,

94
00:07:07.310 --> 00:07:10.009 
but in fact, they do not have their own kernel.

95
00:07:10.010 --> 00:07:13.399 
So they are not really virtual operating systems.

96
00:07:13.400 --> 00:07:17.420 
They just are containers around, usually one or a few

97
00:07:18.650 --> 00:07:23.299 
applications that are bundled together and that are provided

98
00:07:23.300 --> 00:07:26.929 
with their own environment in a sense that they have their own file system and their own

99
00:07:27.950 --> 00:07:32.389 
or structures and so on. But this is just a container in a

100
00:07:32.390 --> 00:07:37.099 
sense that this environment is not using a separate kernel.

101
00:07:37.100 --> 00:07:42.319 
So all Docker containers are run as processes on one

102
00:07:42.320 --> 00:07:44.209 
common host kernel.

103
00:07:44.210 --> 00:07:48.859 
So in fact, these are just encapsulated applications that run in user space like

104
00:07:48.860 --> 00:07:53.479 
you would have applications for multiple applications running on a kernel.

105
00:07:53.480 --> 00:07:57.319 
So the idea is that you can encapsulate applications, provide them with their own

106
00:07:57.320 --> 00:08:01.939 
configuration, with their own settings and so on, and they feel like

107
00:08:01.940 --> 00:08:06.379 
they run on their own server. But in fact, they are all running on a single instance

108
00:08:06.380 --> 00:08:08.389 
of the operating system.

109
00:08:08.390 --> 00:08:11.930 
This, of course, is a very lightweight approach, since there's no

110
00:08:13.100 --> 00:08:16.339 
need to run multiple kernels, and

111
00:08:17.810 --> 00:08:22.489 
the isolation between the containers is handled by concepts inside the Linux kernel,

112
00:08:22.490 --> 00:08:26.959 
which are standard concepts of the kernel on top of Linux, there is the so-called Docker

113
00:08:26.960 --> 00:08:31.399 
Daemon process, which manages the container and starts

114
00:08:31.400 --> 00:08:35.479 
and stops the containers and it runs then the lightweight containers.

115
00:08:35.480 --> 00:08:39.918 
Containers started from an image, which is managed by the Docker

116
00:08:39.919 --> 00:08:44.599 
daemon. An image is basically a file system image that

117
00:08:44.600 --> 00:08:49.279 
resides on disk, and then you can start a container and

118
00:08:49.280 --> 00:08:51.349 
Docker calls it the container ready to run.

119
00:08:51.350 --> 00:08:54.589 
And so every container is sort of a running image.

120
00:08:54.590 --> 00:08:59.089 
And the image can be easily moved from one machine to another that can be

121
00:08:59.090 --> 00:09:03.589 
downloaded, there are repositories on the internet where you can upload

122
00:09:03.590 --> 00:09:08.449 
and download ready-made images so you can just pull them and launch them on your

123
00:09:08.450 --> 00:09:13.159 
Docker daemon. This concept is now available on Linux

124
00:09:13.160 --> 00:09:18.499 
on the mainframe for some use as well, and it provides the possibility to

125
00:09:18.500 --> 00:09:23.149 
use this mechanism, for example, for managing lightweight cloud

126
00:09:23.150 --> 00:09:27.829 
instances and things like that in on the mainframe environment

127
00:09:27.830 --> 00:09:32.389 
as well. Containers play an important role in the context of microservice architectures

128
00:09:32.390 --> 00:09:37.069 
and microservices. Microservices, the ideas and microservices

129
00:09:37.070 --> 00:09:41.899 
that you have that you break up large scale applications into various

130
00:09:41.900 --> 00:09:46.369 
microservices that on its own, they are

131
00:09:46.370 --> 00:09:51.259 
self-contained in a way that they have every micro service has its own database,

132
00:09:51.260 --> 00:09:55.999 
its own application server, its own

133
00:09:56.000 --> 00:10:00.499 
logic. And the idea is that one microservices is maintained by a team

134
00:10:00.500 --> 00:10:05.509 
of developers. And if you use so-called DevOps style,

135
00:10:05.510 --> 00:10:09.589 
they also are responsible for running and maintaining the running the production

136
00:10:09.590 --> 00:10:13.827 
container and to have that packaged in a easy

137
00:10:14.960 --> 00:10:18.379 
deployable way, The typical tools are Docker containers.

138
00:10:18.380 --> 00:10:22.659 
So this is very important for modern microservices-based architectures.

139
00:10:26.860 --> 00:10:31.779 
One additional feature that is unique to the Linux one, and that is that system's

140
00:10:31.780 --> 00:10:36.459 
environment under Linux are the so-called secure

141
00:10:36.460 --> 00:10:39.645 
service containers which have were introduced together with the 14th

142
00:10:41.050 --> 00:10:45.819 
generation of mainframes and the secure servers containers

143
00:10:45.820 --> 00:10:50.379 
are a concept that allows to run Docker images

144
00:10:50.380 --> 00:10:55.029 
that are extremely critical or that need a high level

145
00:10:55.030 --> 00:10:58.018 
of protection in a way that

146
00:10:59.790 --> 00:11:04.449 
the image itself is encrypted on disk, but is also encrypted in

147
00:11:04.450 --> 00:11:06.609 
main memory when it's loaded when it's running.

148
00:11:06.610 --> 00:11:10.960 
And the new features of the processor of the set 14 processors,

149
00:11:12.370 --> 00:11:17.049 
which are called pervasive encryption, allow to encrypt

150
00:11:17.050 --> 00:11:21.489 
data and from when it is loaded in the CPU on

151
00:11:21.490 --> 00:11:25.269 
the fly without loss of application speech.

152
00:11:25.270 --> 00:11:29.979 
This has been reached by largely increasing the number of transistors

153
00:11:29.980 --> 00:11:34.749 
on the on the chip that have been dedicated to two encryption facilities

154
00:11:34.750 --> 00:11:37.059 
and cryptographic facilities.

155
00:11:37.060 --> 00:11:41.439 
And therefore, these processors can encrypt and decrypt the data on the fly.

156
00:11:41.440 --> 00:11:45.939 
So the idea is that you run in these so-called

157
00:11:45.940 --> 00:11:49.779 
secure service container, you run basically Docker images that are encrypted.

158
00:11:49.780 --> 00:11:54.639 
So it's sort of an extension of the normal containerization approach.

159
00:11:54.640 --> 00:11:59.649 
And the idea is that an applicationis packaged

160
00:11:59.650 --> 00:12:04.269 
into like a kind of an appliance in a ready-made image.

161
00:12:04.270 --> 00:12:09.009 
And then this image is stored and

162
00:12:09.010 --> 00:12:13.629 
run encrypted and biased by a secret key so

163
00:12:13.630 --> 00:12:18.069 
that even the administrator of the mainframe, the system administrators are not

164
00:12:18.070 --> 00:12:22.809 
able to sort of look into the data or other things that are processed

165
00:12:22.810 --> 00:12:25.059 
in such a secure server's container.

166
00:12:25.060 --> 00:12:29.234 
So this is extremely interesting for very mission-critical and very

167
00:12:32.110 --> 00:12:34.120 
highly secure applications.

168
00:12:35.440 --> 00:12:40.449 
The basic idea is that a secure service container is a Linux based kind of appliance

169
00:12:40.450 --> 00:12:44.889 
that is installed into a dedicated LPAR and

170
00:12:44.890 --> 00:12:49.629 
is fully packaged and then inside the secure service container

171
00:12:49.630 --> 00:12:54.249 
these encrypted images can be run and loaded without

172
00:12:54.250 --> 00:12:57.999 
the need that an administrator may look into them.

173
00:12:58.000 --> 00:13:02.041 
And this array of self-contained Docker structures is used to

174
00:13:04.390 --> 00:13:09.009 
manage that because already packaged Docker container typically should not

175
00:13:09.010 --> 00:13:13.378 
require any kind of console or access to the running

176
00:13:15.040 --> 00:13:19.749 
machine, virtual container machine that is prohibited

177
00:13:19.750 --> 00:13:23.109 
also in such kind of secure service environments.

178
00:13:23.110 --> 00:13:27.719 
So secure service containers run on a dedicated LPAR and can run across,

179
00:13:27.720 --> 00:13:32.649 
of course, side by side with other operating systems, which is a

180
00:13:32.650 --> 00:13:37.299 
special version of Linux running that basically runs its Docker or this

181
00:13:37.300 --> 00:13:39.549 
containerization solution.

182
00:13:39.550 --> 00:13:42.639 
And then we have hardware support.

183
00:13:42.640 --> 00:13:46.479 
We have this key management for pervasive encryption.

184
00:13:46.480 --> 00:13:50.949 
And this kind of hosting model, of course, is interesting for cloud providers

185
00:13:50.950 --> 00:13:55.449 
that you want to make sure that the cloud provider cannot see

186
00:13:55.450 --> 00:13:59.889 
the data of the customers. And it's also especially interesting, for example, in

187
00:13:59.890 --> 00:14:02.169 
the context of blockchain applications.

188
00:14:02.170 --> 00:14:05.259 
Because blockchain applications typically are critical, they are

189
00:14:06.610 --> 00:14:11.649 
required trust and these things, and it's also based on cryptographic

190
00:14:11.650 --> 00:14:12.650 
facilities.

191
00:14:14.450 --> 00:14:19.099 
So finally, in recent years, the topic blockchain has become very

192
00:14:19.100 --> 00:14:23.929 
interesting in the context of mainframes because the mainframe

193
00:14:23.930 --> 00:14:28.369 
is a very well-suited platform to run blockchain applications, especially due to

194
00:14:28.370 --> 00:14:31.099 
its cryptographic capabilities.

195
00:14:31.100 --> 00:14:35.599 
And so let's have a short look on on blockchain as well, which is

196
00:14:35.600 --> 00:14:41.089 
probably going to become an important topic in the mainframe world in the future.

197
00:14:41.090 --> 00:14:46.099 
A blockchain basically is called or represents

198
00:14:46.100 --> 00:14:51.319 
something called a distributed ledger. So it's a journal of operations

199
00:14:51.320 --> 00:14:56.209 
that is stored in a way that you don't need a central instance that all parties

200
00:14:56.210 --> 00:15:00.799 
trust. So basically, it allows to store in

201
00:15:00.800 --> 00:15:04.669 
a trustful way, distributed way

202
00:15:06.260 --> 00:15:08.184 
trustfully store transactions

203
00:15:11.930 --> 00:15:16.399 
that have been executed by different parties that together form

204
00:15:16.400 --> 00:15:20.419 
any kind of business-related network.

205
00:15:21.860 --> 00:15:26.330 
The original idea comes from bitcoin cryptocurrency

206
00:15:27.530 --> 00:15:30.529 
that has been proposed by Nakamoto.

207
00:15:30.530 --> 00:15:35.111 
This is a sort of pseudonym of an unknown person and,

208
00:15:37.550 --> 00:15:40.129 
it was sort of proposed in context of bitcoin.

209
00:15:40.130 --> 00:15:44.599 
Bitcoin works in that sense that you have a distributed ledger, that there's no central

210
00:15:44.600 --> 00:15:47.689 
party that all parties need to trust.

211
00:15:47.690 --> 00:15:51.709 
And this basic idea can, of course, be transferred to a completely different business

212
00:15:51.710 --> 00:15:56.539 
scenarios. Basically, blockchain is an interesting thing always when you have

213
00:15:56.540 --> 00:16:01.709 
different independent parties that have to

214
00:16:01.710 --> 00:16:06.269 
have a common understanding and trust, a central thing

215
00:16:06.270 --> 00:16:11.249 
concept or object that all parties have to access, that all parties have to modify,

216
00:16:11.250 --> 00:16:15.509 
and that these modifications have to be trusted by all parties.

217
00:16:17.000 --> 00:16:21.649 
In the past and today, typically this is handled by having a trusted third party kind

218
00:16:21.650 --> 00:16:26.659 
of a notary that is sort of responsible for keeping

219
00:16:26.660 --> 00:16:29.149 
this journal of this ledger for all the parties.

220
00:16:30.680 --> 00:16:36.259 
And this is a typical situation where you have intermediaries in business-like,

221
00:16:36.260 --> 00:16:39.739 
for example, brokers and things like that.

222
00:16:39.740 --> 00:16:44.329 
And blockchain may provide a concept to sort

223
00:16:44.330 --> 00:16:48.859 
of remove the need for these kind of

224
00:16:48.860 --> 00:16:53.419 
trusted third parties in different types of business-related activities.

225
00:16:54.590 --> 00:16:57.139 
Nevertheless, of course, this is at the very early beginning.

226
00:16:57.140 --> 00:17:01.639 
Now, not many applications have been successfully launched,

227
00:17:01.640 --> 00:17:03.589 
but the idea is very promising.

228
00:17:03.590 --> 00:17:08.629 
And the basic idea is that you use cryptographic facilities of cryptographic concepts

229
00:17:08.630 --> 00:17:14.269 
in the case here of hash functions to actually

230
00:17:14.270 --> 00:17:18.919 
store the ledger in a chain of blocks as

231
00:17:18.920 --> 00:17:21.259 
it is sort of sketched here.

232
00:17:21.260 --> 00:17:25.699 
And the idea is that you have some transaction data in every

233
00:17:25.700 --> 00:17:31.189 
block. For example, in bitcoin, this is the the change of of the

234
00:17:31.190 --> 00:17:36.079 
amount of money in your wallet and you have

235
00:17:36.080 --> 00:17:38.359 
hash values of this data.

236
00:17:38.360 --> 00:17:43.039 
And every block points to a previous block and stores the hash value of the previous

237
00:17:43.040 --> 00:17:47.209 
block and then calculates a new hash value, including the hash value of the previous

238
00:17:47.210 --> 00:17:49.279 
block, and puts this to the next block.

239
00:17:49.280 --> 00:17:54.079 
So the longer the chain is, the more expensive in terms of computational

240
00:17:54.080 --> 00:17:56.809 
power, it would be to make modifications.

241
00:17:56.810 --> 00:18:01.279 
So because you have to sort of re-calculate the hash values and by making

242
00:18:01.280 --> 00:18:04.730 
some additional requirements on the hash values, you can

243
00:18:05.750 --> 00:18:10.519 
make it difficult and more difficult to manipulate or change the data

244
00:18:10.520 --> 00:18:14.419 
so that the chain can be trusted and can be checked by the hash values.

245
00:18:14.420 --> 00:18:18.979 
And that makes it possible that all parties keep a copy of the chain and are able to

246
00:18:18.980 --> 00:18:21.829 
validate any new transaction that is added to the chain.

247
00:18:21.830 --> 00:18:24.079 
That is the basic concept of a blockchain.

248
00:18:24.080 --> 00:18:29.689 
And this allows the implementation of this kind of distributed ledgers

249
00:18:29.690 --> 00:18:34.009 
and for the mainframe in the future, this probably will be a very important workload

250
00:18:34.010 --> 00:18:38.749 
because the mainframe hardware, especially under the Knox, provides

251
00:18:38.750 --> 00:18:43.279 
a good combination of cryptographic facilities and the possibility

252
00:18:43.280 --> 00:18:45.559 
to use the standard open-source tools.

253
00:18:45.560 --> 00:18:50.659 
And that's the so-called Hyperledger framework, which is an open source project highly

254
00:18:50.660 --> 00:18:55.099 
supported by industry that provides the basis

255
00:18:55.100 --> 00:18:59.659 
for implementing blockchain applications also on Linux, on the system set

256
00:18:59.660 --> 00:19:04.159 
and Linux one. So this is a very interesting workload

257
00:19:04.160 --> 00:19:08.929 
that should be kept in mind,

258
00:19:08.930 --> 00:19:13.549 
especially in the context of the future or looking at the future

259
00:19:13.550 --> 00:19:15.529 
of the mainframe platform.

260
00:19:15.530 --> 00:19:16.530 
Thank you very much.
