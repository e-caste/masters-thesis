WEBVTT

1
00:00:01.660 --> 00:00:04.110 
In our openHPI course Blockchain:
Revealing the Myth,

2
00:00:04.660 --> 00:00:10.900 
we now start to consider the different
components of the bitcoin solution

3
00:00:11.230 --> 00:00:16.100 
to the question to establish a
system for financial tracked

4
00:00:16.100 --> 00:00:17.700 
actions which is not

5
00:00:18.490 --> 00:00:21.640 
relying on
trusted parties.

6
00:00:22.330 --> 00:00:27.110 
And the first component are the single
chronological order of the transaction.

7
00:00:28.140 --> 00:00:34.710 
Bitcoin, you remember, wants to serve the
question, wants to establish a system

8
00:00:34.850 --> 00:00:38.490 
for electronic transactions
without relying on trust.

9
00:00:39.160 --> 00:00:42.890 
So our starting point is
no central authority

10
00:00:43.550 --> 00:00:45.940 
and no trusted
third party.

11
00:00:48.650 --> 00:00:51.820 
But in our network we do
not know whether

12
00:00:52.720 --> 00:00:58.510 
all the participants are honest participants.
There are also malicious ones.

13
00:00:59.010 --> 00:01:03.990 
Malicious ones for example that
receive a money transfer and later

14
00:01:04.280 --> 00:01:07.910 
claim they did not
received anything or

15
00:01:08.660 --> 00:01:13.310 
money transfer. So to prevent
that the malicious receiver of

16
00:01:13.310 --> 00:01:18.450 
a money transfer or money transfer can
claim not to have received anything

17
00:01:19.060 --> 00:01:22.120 
we do not trust
other users.

18
00:01:22.930 --> 00:01:25.430 
This is our

19
00:01:26.370 --> 00:01:31.360 
agreement - we do not trust on other
users and the system should work

20
00:01:32.300 --> 00:01:35.780 
even in that case that we
do not trust other users.

21
00:01:36.860 --> 00:01:42.870 
So to make it difficult
for malicious receiver

22
00:01:43.280 --> 00:01:49.950 
to claim that they did not read a
transaction, we make all transactions public.

23
00:01:51.260 --> 00:01:55.900 
All transactions public so
that all the other participants

24
00:01:55.910 --> 00:01:59.780 
of the network see there
was a transaction.

25
00:02:00.750 --> 00:02:06.730 
So it becomes in that case much more
difficult for a malicious receiver, for a

26
00:02:06.930 --> 00:02:14.240 
cybercriminal to claim he didn't receive a
transaction or this was another transaction.

27
00:02:15.020 --> 00:02:20.090 
And the second what we make of
course is we want to be anonymous

28
00:02:20.890 --> 00:02:23.090 
in this peer to
peer network.

29
00:02:23.830 --> 00:02:29.210 
We want not that all the
other people see because

30
00:02:29.420 --> 00:02:34.840 
this transaction is transfered to me

31
00:02:34.840 --> 00:02:36.170 
a huge amount of money.

32
00:02:37.350 --> 00:02:40.240 
So no trust
for everyone,

33
00:02:41.180 --> 00:02:46.120 
all transaction public and we
needs to stay anonymous. This

34
00:02:46.120 --> 00:02:50.620 
is a way we approach
this new system.

35
00:02:51.760 --> 00:02:56.880 
So the question is how do we organize our
selves, how do we organize the network

36
00:02:57.050 --> 00:02:59.410 
without such an
central authority

37
00:03:00.030 --> 00:03:05.420 
or interested party and how do
we protect ourselves from fraud?

38
00:03:05.720 --> 00:03:10.730 
We want to exchange money, we want to
establish an electronic transactions

39
00:03:11.540 --> 00:03:15.580 
for electronic transactions
without relying on trust.

40
00:03:17.450 --> 00:03:23.440 
To accomplish this without a trusted third
party we need a system for participants

41
00:03:24.010 --> 00:03:29.270 
to agree on a single history of
the order of the transactions.

42
00:03:30.510 --> 00:03:35.840 
When such a sequence is accepted by
all the participants of the network,

43
00:03:36.790 --> 00:03:41.130 
it is no more possible for one
malicious receiver to claim this

44
00:03:41.320 --> 00:03:44.970 
transaction was not sent to
me or this transaction

45
00:03:45.760 --> 00:03:48.330 
didn't happen before
that transaction.

46
00:03:48.950 --> 00:03:54.450 
So what we have to organize is that
all the people in the network,

47
00:03:54.450 --> 00:03:56.360 
all the participants in our

48
00:03:57.230 --> 00:04:00.700 
crypto currency system,
in our bitcoin system,

49
00:04:01.590 --> 00:04:08.390 
agree on a single history of all
the transactions which were

50
00:04:09.110 --> 00:04:10.790 
transmitted over
this network.

51
00:04:11.910 --> 00:04:14.720 
So the payee needs proof

52
00:04:15.510 --> 00:04:21.110 
that at the time of the transaction
the majority of nodes agreed

53
00:04:21.430 --> 00:04:23.840 
that the money hasn't
been spent already.

54
00:04:24.580 --> 00:04:30.430 
The majority, so of course we do
not trust anything or anyone but

55
00:04:30.570 --> 00:04:36.430 
we believe that the majority
in the of the network participants

56
00:04:36.750 --> 00:04:38.660 
are honest participants.

57
00:04:39.390 --> 00:04:43.130 
So the payee needs this proof

58
00:04:43.820 --> 00:04:45.570 
that he can spend
the money,

59
00:04:46.510 --> 00:04:51.210 
that he can spend the money because
the majority of the nodes of

60
00:04:51.710 --> 00:04:58.450 
network participants believe that
I have this amount of cash,

61
00:04:58.640 --> 00:05:04.250 
that I am able to spend it for example
to buy a product or a service.

62
00:05:06.420 --> 00:05:11.380 
Nodes here it means
in a way that we have

63
00:05:11.820 --> 00:05:18.070 
peer to peer networks where the users
are the nodes but the nodes are

64
00:05:18.230 --> 00:05:25.810 
anonymous. So here nodes and
participants is used as synonyms.

65
00:05:27.500 --> 00:05:34.080 
So now how we can organize that all
the participants of a network agree

66
00:05:34.480 --> 00:05:36.740 
in a single
chronological order?

67
00:05:37.750 --> 00:05:42.520 
And this is organized by
majority decision making.

68
00:05:43.590 --> 00:05:49.270 
So everyone in our network can vote
for the proper order of transactions.

69
00:05:50.020 --> 00:05:56.270 
The transactions, you remember
were made public. Everyone receives

70
00:05:56.640 --> 00:06:02.760 
everyone in the network receives all the
transactions, can see the transactions

71
00:06:03.200 --> 00:06:09.220 
which were done and now what is
important is to have exactly

72
00:06:10.050 --> 00:06:13.710 
chronological order
of the transactions.

73
00:06:14.960 --> 00:06:17.570 
So the

74
00:06:19.440 --> 00:06:22.630 
vote for this single
chronological order

75
00:06:23.050 --> 00:06:28.410 
is done by the majority of the
network. So it's done by the

76
00:06:28.410 --> 00:06:30.220 
majority of the votes.

77
00:06:33.280 --> 00:06:34.370 
There is a
problem as it.

78
00:06:35.180 --> 00:06:42.690 
Is the majority the number of
nodes which agree in this order?

79
00:06:43.320 --> 00:06:51.610 
But what happens if an attacker if a
cyber criminal allocates many IP addresses?

80
00:06:51.770 --> 00:06:53.910 
So it takes many nodes

81
00:06:54.520 --> 00:06:59.780 
for himself. Officially these
are different nodes, the nodes are

82
00:07:00.020 --> 00:07:03.110 
anonymous user, so
one cannot see that

83
00:07:03.750 --> 00:07:10.450 
all the many IPs belong to one voter.
So its a problem, one IP address

84
00:07:10.810 --> 00:07:18.470 
as one would is not possible as a stable
basis for such an decision making.

85
00:07:19.640 --> 00:07:21.960 
So one needs
another approach.

86
00:07:22.720 --> 00:07:25.680 
And the idea is that
implemented in bitcoin

87
00:07:26.350 --> 00:07:32.070 
is the same like that which was
introduced by Adam Back's

88
00:07:32.610 --> 00:07:34.320 
and called hash cache.

89
00:07:35.280 --> 00:07:40.700 
To cast the votes done in form
of a so called proof of work.

90
00:07:42.040 --> 00:07:49.560 
Of a proof of work, and work here consists
of an very complex computational task

91
00:07:50.160 --> 00:07:53.080 
that demands huge
computational

92
00:07:54.460 --> 00:07:59.900 
effort, a huge computational
CPU effort to be solved.

93
00:08:01.570 --> 00:08:09.370 
And the idea behind to make the
decision dependent from the

94
00:08:09.370 --> 00:08:11.010 
proof of work is done

95
00:08:11.710 --> 00:08:17.360 
is that at least half of the
majority of the CPU power

96
00:08:17.880 --> 00:08:20.560 
is in the hand of the

97
00:08:21.430 --> 00:08:22.770 
honest participants

98
00:08:24.010 --> 00:08:28.040 
because even if a malicious
user has many CPUs,

99
00:08:29.460 --> 00:08:32.300 
this is easy to do.
This is easy to

100
00:08:33.030 --> 00:08:38.650 
to double and up and up but what
is difficult is to provide

101
00:08:38.940 --> 00:08:45.640 
the corresponding CPU power in the
back to influence this proof of work,

102
00:08:45.790 --> 00:08:47.450 
to influence this vote.

103
00:08:48.210 --> 00:08:54.670 
So proof of work is essentially
a one-CPU-one-vote decision,

104
00:08:55.710 --> 00:08:59.830 
not one-IP-address-one-
vote but one-CPU-

105
00:09:00.260 --> 00:09:06.410 
-one-vote. The system is secure
as long as the honest nodes

106
00:09:06.730 --> 00:09:13.350 
collectively control more CPU power than
any operating proof of attacker nodes

107
00:09:13.910 --> 00:09:19.110 
and since this networks
are very large with many users

108
00:09:19.570 --> 00:09:24.040 
this is a assumption and we
can base our considerations.

109
00:09:26.220 --> 00:09:31.460 
So majority decision on the
chronological order of the transaction

110
00:09:31.840 --> 00:09:39.540 
is done by, is organized by
letting all participants know

111
00:09:40.300 --> 00:09:45.760 
about any transaction and then to
bring this transaction in the

112
00:09:46.010 --> 00:09:52.470 
right chronological order by a
proof of work or by solving

113
00:09:52.470 --> 00:09:57.650 
a complex computational task which
needs a lot of CPU resources.

114
00:09:58.470 --> 00:10:02.800 
And the system one-
CPU-one-vote

115
00:10:03.630 --> 00:10:10.030 
is secure at least as long as honest
nodes collectively control more

116
00:10:10.350 --> 00:10:14.970 
CPU power than all the
malicious users together.

117
00:10:17.530 --> 00:10:20.280 
To bring the transaction
in the right order,

118
00:10:20.690 --> 00:10:23.760 
we need a technique that
is called timestamping.

119
00:10:25.110 --> 00:10:28.020 
So we announce all our
transition public key

120
00:10:28.590 --> 00:10:31.850 
by broadcasting them to
all the other users.

121
00:10:32.950 --> 00:10:38.880 
And we vote with our CPU effort for
a proper order of transaction.

122
00:10:40.590 --> 00:10:43.120 
So how exactly does
this order look like,

123
00:10:43.780 --> 00:10:49.800 
how does timestamping work which exactly
tells that this transaction is

124
00:10:49.940 --> 00:10:52.180 
before of a transaction?

125
00:10:53.890 --> 00:10:55.990 
So unlike in the
physical currency

126
00:10:56.700 --> 00:11:02.030 
a digital banknote is a digital
file, it's a simple digital file

127
00:11:02.380 --> 00:11:04.470 
that can be duplicated

128
00:11:05.090 --> 00:11:06.610 
or falsified
very simply.

129
00:11:07.640 --> 00:11:11.550 
So that the same single
digital bank note

130
00:11:12.440 --> 00:11:19.270 
can be easier spent more than once. This
is what we will mention in future

131
00:11:19.530 --> 00:11:21.250 
under the term
double spending.

132
00:11:22.180 --> 00:11:26.480 
So with all the transaction I
need to be given the proof

133
00:11:26.930 --> 00:11:31.030 
that this amount I now
spent to buy this good

134
00:11:31.510 --> 00:11:35.860 
was not already spent for buying
another good or another service.

135
00:11:37.120 --> 00:11:41.280 
In the physical way its simple
because you know its very difficult

136
00:11:41.290 --> 00:11:43.360 
to fake banknotes.

137
00:11:44.000 --> 00:11:48.530 
But here with digital banknotes
its so easy to duplicate or

138
00:11:48.530 --> 00:11:52.650 
to falsify and so we need special
techniques to prevent this.

139
00:11:54.140 --> 00:11:57.410 
And the way we
protect us

140
00:11:58.470 --> 00:12:04.990 
for this double spending is that
we provide the transaction

141
00:12:05.480 --> 00:12:10.990 
into a chain, into an order
which later cannot be

142
00:12:11.580 --> 00:12:17.620 
cannot be changed. So here we have a
time stand which exactly gives a time

143
00:12:18.970 --> 00:12:23.800 
information to any transaction and at
long of this time informations and

144
00:12:23.920 --> 00:12:25.130 
we can linearly

145
00:12:26.400 --> 00:12:29.650 
order these transactions.

146
00:12:30.930 --> 00:12:35.310 
So time stamping and the proof
that the order and contents

147
00:12:35.310 --> 00:12:38.350 
of the transaction have not
been manipulated afterwards

148
00:12:38.850 --> 00:12:40.610 
can be provided
by means

149
00:12:41.320 --> 00:12:44.890 
of timestamps
linked by hashes.

150
00:12:45.920 --> 00:12:48.890 
You remember, a
hash function is

151
00:12:49.570 --> 00:12:50.970 
some special type of

152
00:12:51.790 --> 00:12:59.250 
cryptographic function. You give
an information, so it is a timestamp

153
00:12:59.580 --> 00:13:05.620 
and then you compute a hash so
the time could be no more seen

154
00:13:05.820 --> 00:13:08.390 
but it could be
the hash is

155
00:13:09.040 --> 00:13:14.090 
somewhat unique for that timestamp. So
each transaction is timestamped

156
00:13:15.330 --> 00:13:17.790 
before its hash
is computed.

157
00:13:18.590 --> 00:13:23.110 
So inside the hash of the
transaction there is a timestamp.

158
00:13:23.110 --> 00:13:29.100 
The timestamp is part of them so if
anyone wants to manipulate this,

159
00:13:29.500 --> 00:13:33.840 
to say no this money was not
spent before, he has to

160
00:13:33.840 --> 00:13:39.160 
change the time information and
changing the time information changes

161
00:13:39.310 --> 00:13:41.860 
the hash

162
00:13:42.650 --> 00:13:49.920 
of the transaction and this timestamp is hash
of this transaction is widely published

163
00:13:50.420 --> 00:13:53.410 
and sent is broadcast
and sent to every

164
00:13:53.860 --> 00:13:55.260 
participant of
the network.

165
00:13:56.010 --> 00:14:03.820 
So each timestamp includes a timestamp
also of the previous transaction

166
00:14:04.590 --> 00:14:08.830 
in its hash in this
way forming a chain

167
00:14:09.420 --> 00:14:14.140 
with each additional timestamp being a
timestamp reinforcing the ones before.

168
00:14:14.650 --> 00:14:18.670 
So here we have
the timestamp,

169
00:14:19.450 --> 00:14:24.030 
the hash of the timestamp
of this transaction

170
00:14:24.630 --> 00:14:32.610 
and this is part of the new timestamp
of the new transaction

171
00:14:33.540 --> 00:14:39.920 
and this way we get a sequence of
such a time of such transactions,

172
00:14:40.390 --> 00:14:42.370 
thee chronological order

173
00:14:43.100 --> 00:14:47.580 
and in the network all have
to agree on this order.

174
00:14:48.900 --> 00:14:52.080 
So link to the previous
timestamp proves

175
00:14:52.870 --> 00:14:56.100 
that the previous transaction
must have existed already

176
00:14:56.850 --> 00:14:59.660 
otherwise it could not get into
the hash of the transaction.

177
00:15:00.670 --> 00:15:08.010 
So in this way it becomes difficult to
manipulate the order of the transactions.

178
00:15:09.820 --> 00:15:16.650 
Now we have this chain of hash values, of hash
values of the transactions that include

179
00:15:16.980 --> 00:15:22.080 
the timestamps, the time
stamp of the transaction.

180
00:15:22.740 --> 00:15:25.120 
And each user
a broadcasts

181
00:15:25.760 --> 00:15:29.520 
new transaction to all the
others, to all the other

182
00:15:30.210 --> 00:15:35.390 
participants of the network, this new
transaction has the timestamp, is connected

183
00:15:35.610 --> 00:15:38.660 
with the transactions it
was transferred before.

184
00:15:39.810 --> 00:15:44.100 
Now

185
00:15:44.930 --> 00:15:48.580 
what do the other
users in the network do?

186
00:15:49.420 --> 00:15:55.560 
They have to say yes we accept this
transaction or we do not accept.

187
00:15:56.390 --> 00:16:02.390 
And they accept it only if it's
valid and not already spent.

188
00:16:03.350 --> 00:16:10.130 
So there is a mechanism needed to check
whether this transaction was manipulated,

189
00:16:10.340 --> 00:16:11.990 
whether this
transaction

190
00:16:12.720 --> 00:16:16.440 
wants to transfer an amount

191
00:16:17.300 --> 00:16:20.140 
without owning
that amount.

192
00:16:22.140 --> 00:16:28.340 
So this acceptance is
expressed by the users

193
00:16:29.020 --> 00:16:31.430 
by the proof of work.

194
00:16:32.520 --> 00:16:38.140 
And this proof of work is that they are
creating the next hash in the chain

195
00:16:38.940 --> 00:16:42.730 
using the hash of the accepted
transaction as a previous hash

196
00:16:43.290 --> 00:16:49.330 
and works on finding a difficult
proof of work so that this

197
00:16:49.360 --> 00:16:56.650 
is a kind of certificate for this
chain, that this chain was produced

198
00:16:56.850 --> 00:17:02.280 
with a huge amount of computational
power and it's difficult,

199
00:17:02.310 --> 00:17:07.040 
it's almost impossible to
a fake this order by the

200
00:17:07.930 --> 00:17:10.170 
malicious users.

201
00:17:12.030 --> 00:17:17.480 
This proof of work together with a hash
of the previous transactions are added

202
00:17:17.650 --> 00:17:18.800 
to a new transaction.

203
00:17:20.320 --> 00:17:26.630 
o here it is proved that all are valid
and there is a lot of work invested

204
00:17:27.040 --> 00:17:31.410 
which cannot be
provided by other sides

205
00:17:32.060 --> 00:17:38.780 
and then this is the hash of this
is part of the next transaction,

206
00:17:39.540 --> 00:17:41.620 
in this way becoming

207
00:17:42.350 --> 00:17:45.670 
a new member
of the chain.

208
00:17:46.520 --> 00:17:51.040 
This new transaction is published
all over the internet and

209
00:17:51.040 --> 00:17:55.190 
all the users check whether
it is a valid transaction.

210
00:17:55.930 --> 00:18:01.150 
THey already agreed on that
chain and now they check whether

211
00:18:01.440 --> 00:18:06.620 
the money was spent already
or was not already spent,

212
00:18:07.040 --> 00:18:12.430 
they compute and check the hash
and then with the work of proof

213
00:18:12.720 --> 00:18:17.120 
they give a guarantee that yes
this is a new part of the chain.

214
00:18:19.090 --> 00:18:24.090 
So let's summarize these ideas which
are implemented in the bitcoin

215
00:18:24.860 --> 00:18:29.540 
system to prove a single
order of transaction.

216
00:18:32.060 --> 00:18:36.890 
Each user, this was a first step,
broadcast a new transaction.

217
00:18:38.330 --> 00:18:44.760 
All the other users accept this transaction,
they check it and accept it only

218
00:18:45.180 --> 00:18:51.860 
if it is valid in the form, with the hash
values and so on and not already spent.

219
00:18:52.990 --> 00:18:56.610 
And then the users express
their acceptance

220
00:18:57.110 --> 00:18:59.740 
of the transaction
by working on

221
00:19:00.930 --> 00:19:05.600 
creating the next hash in the
chain, by prolonging the chain.

222
00:19:07.290 --> 00:19:11.920 
So this is the first component, the
basic idea of the first component

223
00:19:12.440 --> 00:19:18.440 
to bring all users in such a peer to
peer network in the bitcoin network

224
00:19:18.930 --> 00:19:24.330 
on the same track believing in the
same single chronological order

225
00:19:24.640 --> 00:19:29.510 
of the transactions which were
done inside the network.

226
00:19:31.800 --> 00:19:37.990 
The users use in order to check
whether it's valid, they use

227
00:19:38.350 --> 00:19:44.280 
the hash of an accepted transaction
as a previous hash

228
00:19:44.540 --> 00:19:46.890 
for the next arriving
transaction

229
00:19:48.040 --> 00:19:52.840 
and to underpin the acceptance,
they work on finding a solution

230
00:19:53.230 --> 00:19:58.710 
of a difficult computational task,
they provide a proof of work

231
00:19:58.900 --> 00:20:06.450 
that needs a lot of CPU resources
to prevent malicious users

232
00:20:06.740 --> 00:20:09.990 
to try to manipulate
this sequence.

233
00:20:11.320 --> 00:20:17.110 
And this proof is
together with the hash

234
00:20:17.550 --> 00:20:22.480 
of the previous transaction part
of the new transaction. So in

235
00:20:22.480 --> 00:20:27.330 
the new transaction all this is
proof together with the

236
00:20:27.350 --> 00:20:33.440 
hash of the previous transaction is
added to the new transaction and

237
00:20:33.740 --> 00:20:36.140 
makes it helps to
make it valid.

238
00:20:36.820 --> 00:20:41.450 
And then the new transaction is
broadcasted again to all the

239
00:20:41.450 --> 00:20:45.570 
users in the network and
not only to the user

240
00:20:46.040 --> 00:20:51.050 
who gets this
transaction, but to every user

241
00:20:51.640 --> 00:20:53.630 
and the users

242
00:20:55.230 --> 00:20:59.420 
now consider
this as valid

243
00:21:00.110 --> 00:21:04.790 
if there exist a chain. So users
who have not yet solved the task

244
00:21:05.240 --> 00:21:10.730 
verify the newly arrived transaction,
check whether there is

245
00:21:10.760 --> 00:21:14.790 
a work of proof, whether its
approved by a work of proof,

246
00:21:15.550 --> 00:21:20.080 
with the reference and the proof
and the hash that is existing

247
00:21:20.080 --> 00:21:24.830 
and then they believe in this
chronicle order of transactions.

248
00:21:25.790 --> 00:21:32.540 
And then say continue in exactly the
same way with the next transaction

249
00:21:32.860 --> 00:21:35.810 
making the chain
longer and longer.

250
00:21:36.760 --> 00:21:40.680 
And in this way every
user has an equal

251
00:21:41.110 --> 00:21:46.480 
copy of the ordered transactions
and can trust in this order

252
00:21:46.590 --> 00:21:48.980 
and can continue
to work on it.

253
00:21:50.790 --> 00:21:52.960 
Now we have a problem.

254
00:21:53.580 --> 00:21:55.260 
To mention in
this point

255
00:21:56.310 --> 00:22:00.470 
when the chain
branches. Let's assume

256
00:22:01.250 --> 00:22:05.720 
in our peer to peer network we
have no central authority.

257
00:22:06.420 --> 00:22:10.790 
So people, the members can
join they can rejoin,

258
00:22:11.290 --> 00:22:17.350 
and so it can happen that several
users simultaneously find a

259
00:22:17.450 --> 00:22:23.130 
solution for the proof of work
and each of them broadcasts

260
00:22:23.180 --> 00:22:25.970 
a new reference and
approved transaction

261
00:22:26.680 --> 00:22:31.080 
because it is synchronously,
the transactions arrive in

262
00:22:32.270 --> 00:22:37.170 
place of the different users and
so different users start to

263
00:22:37.840 --> 00:22:43.300 
solve this very
difficult, prepare,

264
00:22:44.510 --> 00:22:49.670 
look whether the chain is valid
and then start to add new

265
00:22:50.160 --> 00:22:55.620 
transactions and perform the proof
of works that is necessary

266
00:22:56.450 --> 00:23:00.030 
for giving the new
transactions the right form

267
00:23:00.460 --> 00:23:03.130 
and it could
happen that they

268
00:23:04.330 --> 00:23:11.360 
finish starting in similar moments
and then distributing their

269
00:23:11.670 --> 00:23:17.420 
transactions in which are
different from what the other

270
00:23:17.840 --> 00:23:22.160 
users did. So, for example one
user got this transactions, the

271
00:23:22.160 --> 00:23:27.280 
other user got that transaction, so
one want to add this transaction

272
00:23:27.280 --> 00:23:30.810 
to the chain and the other wants
that and both are working

273
00:23:30.810 --> 00:23:32.270 
similar and right away.

274
00:23:33.340 --> 00:23:38.520 
Now it happened that when they
when they broadcast the results

275
00:23:38.980 --> 00:23:42.060 
a user can get one

276
00:23:43.620 --> 00:23:48.810 
user can get different
such transactions.

277
00:23:50.670 --> 00:23:55.040 
So transactions comply
with all rules.

278
00:23:56.110 --> 00:23:59.950 
They refer to the same
last transactions,

279
00:24:00.940 --> 00:24:05.210 
so it is possible

280
00:24:05.230 --> 00:24:08.510 
that the chain will
branch. We call it fork.

281
00:24:09.480 --> 00:24:12.860 
There are different transactions

282
00:24:13.350 --> 00:24:17.380 
added to the same chain.

283
00:24:19.240 --> 00:24:21.780 
Reason - because
transactions

284
00:24:22.730 --> 00:24:27.150 
arrive at the different
time to the different users,

285
00:24:27.460 --> 00:24:29.240 
they start with

286
00:24:31.620 --> 00:24:34.350 
putting the proof
of work,

287
00:24:35.050 --> 00:24:39.590 
to receive transaction
as part of the chain and

288
00:24:39.590 --> 00:24:43.810 
so it could be possible
that the chain forks.

289
00:24:46.590 --> 00:24:52.030 
In that cases the user
work on the first transaction

290
00:24:52.680 --> 00:24:58.940 
they received but saves
the other branches in case

291
00:24:59.350 --> 00:25:06.020 
it becomes longer. So the user
say okay, there are two different

292
00:25:06.020 --> 00:25:11.920 
but I already started to connect to
this chain to the new transaction,

293
00:25:12.450 --> 00:25:15.500 
so they simply store
the other branch.

294
00:25:17.720 --> 00:25:23.010 
So the fork will be broken when
the next solution for the proof

295
00:25:23.010 --> 00:25:26.600 
of work is found and one
branch becomes longer.

296
00:25:28.080 --> 00:25:32.430 
And the users that were
working on other branches

297
00:25:32.950 --> 00:25:35.570 
will then switch to
the longer one.

298
00:25:36.460 --> 00:25:44.510 
So the majority decision is every time
to try to continue the longest chain.

299
00:25:45.530 --> 00:25:50.500 
So the users can switch if they worked
on a shorter fork,

300
00:25:50.760 --> 00:25:55.180 
they can simply switch to the
longer one because they have

301
00:25:55.220 --> 00:26:00.140 
all the information and get this from
the other users in the network.

302
00:26:00.870 --> 00:26:02.590 
Thus after a
certain time,

303
00:26:03.310 --> 00:26:06.350 
we come back to
a single chain

304
00:26:07.150 --> 00:26:11.490 
and the single chain will prevail.
It's not clear which of the

305
00:26:11.490 --> 00:26:15.930 
forks becomes this single chain
but it is clear that after

306
00:26:15.930 --> 00:26:17.680 
a while one
will make it.

307
00:26:18.780 --> 00:26:21.920 
So the shortest chain
then is ignored

308
00:26:22.730 --> 00:26:27.640 
and the transactions therein
do not expire. they are stored.

309
00:26:29.430 --> 00:26:34.530 
What is not yet contained in the valid
blocks will be saved in the buffer.

310
00:26:34.750 --> 00:26:36.950 
The buffer is the so
called memory pool

311
00:26:37.660 --> 00:26:42.680 
on side of the user. So
the user can use his

312
00:26:43.430 --> 00:26:45.150 
transaction
which are not

313
00:26:45.940 --> 00:26:51.520 
contained from his memory pool
and continue to work on,

314
00:26:51.990 --> 00:26:55.690 
to connect the new transaction
with the chain.

315
00:26:58.010 --> 00:27:01.650 
So the majority of a decision, I
already said it, is represented

316
00:27:01.740 --> 00:27:03.090 
by the longest chain.

317
00:27:04.100 --> 00:27:09.250 
Once the CPU effort has been
expended to make it satisfying

318
00:27:09.250 --> 00:27:16.410 
the proof of work, then the transaction
cannot be changed without redoing the work.

319
00:27:18.110 --> 00:27:20.510 
And this is
exactly what

320
00:27:21.580 --> 00:27:26.290 
prevents this chain from
being manipulated.

321
00:27:27.590 --> 00:27:32.470 
To modify a transaction in the
past, for example to claim that

322
00:27:33.010 --> 00:27:39.170 
this money was not received
or to try to double spend

323
00:27:39.910 --> 00:27:45.410 
the amount. To modify a
past transaction the attacker

324
00:27:45.530 --> 00:27:49.870 
would have to redo
the proof of work

325
00:27:50.530 --> 00:27:55.420 
of this and all the following
transaction and then catch up

326
00:27:55.820 --> 00:27:58.580 
and surpass the work
of the honest nodes.

327
00:27:59.280 --> 00:28:03.810 
For example if we have eleven
transactions in our chain,

328
00:28:04.370 --> 00:28:08.190 
and the attacker wants to
modified the eighth transaction,

329
00:28:09.250 --> 00:28:16.100 
he must redo a proof of work not only
for the eighth transaction, but also for

330
00:28:16.210 --> 00:28:19.440 
all the following ones - the ninth
the tenth the eleventh transaction.

331
00:28:21.090 --> 00:28:26.730 
And so the longest chain serves as a proof
of chronological order of transactions

332
00:28:27.320 --> 00:28:31.020 
since it came from the
longest pool of CPU power

333
00:28:32.320 --> 00:28:36.760 
because there was a biggest
amount of proof of work

334
00:28:37.510 --> 00:28:44.030 
invested, so we had this assumption
that the majority of the

335
00:28:45.320 --> 00:28:49.380 
CPU power is in the hand
of the honest user.

336
00:28:49.880 --> 00:28:57.010 
So the largest chain comes from
the largest pool of CPU power

337
00:28:57.130 --> 00:28:59.110 
so it has the
most votes.

338
00:28:59.910 --> 00:29:07.140 
So the majority of decision says
okay, this is the right order of

339
00:29:07.290 --> 00:29:09.970 
our transactions, the right
chronological order.

340
00:29:12.090 --> 00:29:15.330 
Let's summarize
what we have.

341
00:29:16.090 --> 00:29:20.680 
So the majority decision is
represented by the longest

342
00:29:21.430 --> 00:29:29.510 
chain and in the longest chain,
the largest proof of work effort

343
00:29:29.650 --> 00:29:31.090 
was invested.

344
00:29:32.340 --> 00:29:37.090 
So if a majority of CPU power
is controlled by the honest

345
00:29:37.090 --> 00:29:43.510 
nodes, the honest chain will grow the
fastest and outpace any competing chains.

346
00:29:44.670 --> 00:29:48.240 
And in practice looking
to the bitcoin system,

347
00:29:48.720 --> 00:29:56.390 
this works well. So this was the first
component of the bitcoin system

348
00:29:56.540 --> 00:29:59.430 
and the solution of the
problem to provide

349
00:30:00.090 --> 00:30:04.190 
a transaction
system without a

350
00:30:05.420 --> 00:30:10.790 
trusted third party. This is that we can
produce a single chronological order

351
00:30:11.190 --> 00:30:12.200 
of the transactions.
