WEBVTT

1
00:00:01.340 --> 00:00:05.260 
Hi in this video we're going to look at the perspective of developers

2
00:00:05.900 --> 00:00:09.980 
that want to establish sustainable software engineering in their teams.

3
00:00:13.010 --> 00:00:16.470 
When it comes to the software engineering team, the developer

4
00:00:16.480 --> 00:00:18.270 
is of course at the center.

5
00:00:19.350 --> 00:00:22.850 
It's the most important role and that's why in this course

6
00:00:22.850 --> 00:00:26.790 
in its entirety we're going to spend more videos going into

7
00:00:26.840 --> 00:00:32.210 
this role and its responsibilities in particular in more depth.

8
00:00:34.820 --> 00:00:39.290 
In this video today however we want to focus on the high level perspective.

9
00:00:39.550 --> 00:00:43.580 
We want to focus on the developer who in the greensoft model

10
00:00:43.580 --> 00:00:48.230 
is responsible for the development life cycle phase for defining

11
00:00:48.230 --> 00:00:53.280 
the criteria and implementing the measures on how we can

12
00:00:54.580 --> 00:01:00.710 
measure and control these metrics for sustainability.

13
00:01:01.550 --> 00:01:03.990 
And we are also going to look at the

14
00:01:04.810 --> 00:01:08.350 
recommendations and tools in particular for how developers

15
00:01:08.350 --> 00:01:12.760 
choose the tools and the environment that they're working with, with

16
00:01:12.880 --> 00:01:15.000 
an eye for sustainability.

17
00:01:16.190 --> 00:01:20.710 
When it comes to the requirements functional and non functional requirements,

18
00:01:21.010 --> 00:01:26.280 
developers have to work in tandem with their architects and

19
00:01:26.280 --> 00:01:29.820 
in fact the lines between these roles might be a bit blurry.

20
00:01:32.770 --> 00:01:37.460 
When it comes to defining non functional requirements, for example architects

21
00:01:37.580 --> 00:01:42.130 
set the guidelines or the broad characteristics of the system.

22
00:01:42.360 --> 00:01:46.780 
For example they might set a requirement for eight round-trip latency

23
00:01:47.090 --> 00:01:52.430 
for a request and a response generated by the service of one hundred milliseconds.

24
00:01:53.130 --> 00:01:58.560 
The developer on the other hand has the control over how to allocate this

25
00:01:58.960 --> 00:02:02.880 
latency to the individual parts of the computations that need

26
00:02:02.880 --> 00:02:04.270 
to happen to answer it.

27
00:02:04.870 --> 00:02:09.290 
So this means or here we can already see that developers are

28
00:02:09.290 --> 00:02:13.860 
involved in making detailed implementation decisions on how

29
00:02:13.860 --> 00:02:17.590 
the requirements set by an architect have to be fulfilled.

30
00:02:18.360 --> 00:02:23.140 
What developers can do is that they can set a very high bar in their team

31
00:02:23.360 --> 00:02:25.930 
for achieving non-functional requirements.

32
00:02:27.290 --> 00:02:32.120 
Why should they do this? High performance typically implies that a software

33
00:02:32.440 --> 00:02:36.720 
does not only just perform better but it also uses less resources,

34
00:02:36.890 --> 00:02:40.830 
which typically translate also to less energy being used for

35
00:02:40.830 --> 00:02:42.510 
example to perform a computation

36
00:02:43.860 --> 00:02:47.220 
this has many different aspects again that we will cover in

37
00:02:47.220 --> 00:02:51.840 
later videos in more detail for example it might be about choosing

38
00:02:51.860 --> 00:02:55.920 
a particular programming language, choosing a particular library,

39
00:02:55.920 --> 00:02:59.790 
or a particular type of algorithm. It might be about choosing

40
00:02:59.790 --> 00:03:04.680 
a protocol that's very efficient to encode and decode or choosing

41
00:03:04.910 --> 00:03:09.110 
very efficient patterns for implementing logic like event-driven

42
00:03:09.440 --> 00:03:12.030 
versus a more traditional polling mechanism.

43
00:03:13.920 --> 00:03:18.310 
Also developers are involved in implementation decisions when it comes to

44
00:03:18.550 --> 00:03:20.960 
the infrastructure requirements that they have.

45
00:03:21.570 --> 00:03:25.320 
And one of the most important considerations that developers

46
00:03:25.320 --> 00:03:29.460 
have to make there is how many and what type of infrastructure

47
00:03:29.460 --> 00:03:33.010 
services or application services they need.

48
00:03:33.750 --> 00:03:37.760 
What is an application service? An application service is something like

49
00:03:37.990 --> 00:03:43.790 
a database or a message queue that is not written by the development team itself,

50
00:03:43.990 --> 00:03:48.170 
but it's already made component or service that the team wants to consume

51
00:03:48.340 --> 00:03:50.150 
in order to implement its logic.

52
00:03:51.880 --> 00:03:56.810 
What can do software developers do here? They can for example decide to

53
00:03:57.310 --> 00:04:00.500 
minimize the number of components that they need.

54
00:04:00.950 --> 00:04:04.460 
For example they might use a database that they already have

55
00:04:05.030 --> 00:04:08.990 
as a lightweight message queue. This is possible it's not a very

56
00:04:09.380 --> 00:04:13.650 
good pattern when it comes to using the database this way because

57
00:04:13.650 --> 00:04:17.100 
it's not optimized for this use case, but if that means that

58
00:04:17.100 --> 00:04:21.610 
the software team can get away with having one less infrastructure component

59
00:04:21.910 --> 00:04:23.710 
it might be a worthwhile trade-off.

60
00:04:24.320 --> 00:04:27.210 
However if the service needs to scale

61
00:04:27.900 --> 00:04:30.930 
using the database in this way might not be very efficient.

62
00:04:30.930 --> 00:04:35.010 
And it's more efficient to use a proper messaging solution,

63
00:04:35.010 --> 00:04:38.750 
a proper message queue and build a cluster of this message queue

64
00:04:39.020 --> 00:04:41.370 
instead of abusing the database.

65
00:04:45.490 --> 00:04:47.530 
Let's come back to the bin packing problem.

66
00:04:48.390 --> 00:04:53.310 
Bin packing is about assigning resources to a fixed number of

67
00:04:53.710 --> 00:04:57.410 
for example machines by metal running on a data centre in the

68
00:04:57.410 --> 00:05:01.350 
most efficient way possible while having the highest possible

69
00:05:01.350 --> 00:05:05.250 
utilization of the machine, and needing the least amount of machines possible.

70
00:05:05.930 --> 00:05:10.390 
What is developers' role in particular for collaborating on

71
00:05:10.390 --> 00:05:14.110 
the bin packing problem with the other roles in a software team?

72
00:05:16.520 --> 00:05:20.380 
One of the most important decisions when it comes to bin packing

73
00:05:20.390 --> 00:05:26.790 
is how granular a service is. If I have very big granularity,

74
00:05:26.790 --> 00:05:31.980 
very coarse granularity it's much harder to fill physical resources,

75
00:05:31.990 --> 00:05:34.790 
for example bare metal machines to the maximum,

76
00:05:35.210 --> 00:05:40.660 
instead with smaller components, it's very easy to fill them

77
00:05:40.660 --> 00:05:42.010 
to the maximum possible.

78
00:05:42.730 --> 00:05:46.700 
How does the tech stack influence that let's make two examples

79
00:05:46.700 --> 00:05:48.130 
and compare and contrast.

80
00:05:48.960 --> 00:05:51.990 
Take the Java virtual machine for example. The Java virtual

81
00:05:51.990 --> 00:05:55.220 
machine is based on just-in-time compilation, which means that

82
00:05:55.220 --> 00:05:59.250 
it translates java bytecode to actual machine instructions.

83
00:06:00.040 --> 00:06:04.370 
To do so, it needs to store the generated code somewhere

84
00:06:04.860 --> 00:06:08.180 
and the more often a particular piece of code is running the

85
00:06:08.180 --> 00:06:12.550 
JVM will spend more time on the optimization of this code.

86
00:06:13.010 --> 00:06:16.910 
This means that software gets to run faster over time because

87
00:06:16.910 --> 00:06:19.810 
it generates more optimum native machine code.

88
00:06:20.720 --> 00:06:24.370 
However and that's the downside. This means that all this machine

89
00:06:24.370 --> 00:06:26.590 
code needs to be stored in a code cache.

90
00:06:28.750 --> 00:06:33.310 
It also has a garbage collection which means that it uses memory

91
00:06:33.310 --> 00:06:36.710 
in very large chunks and then periodically runs an algorithm

92
00:06:36.710 --> 00:06:40.310 
over to determine the parts of memory that are no longer used

93
00:06:40.390 --> 00:06:42.140 
and free them for future use.

94
00:06:43.210 --> 00:06:46.280 
And java has a native threading model which allows a programmer

95
00:06:46.610 --> 00:06:50.350 
to take advantage of having multiple CPU cores very easily.

96
00:06:51.300 --> 00:06:54.100 
Python on the other hand is an interpreter language,

97
00:06:54.830 --> 00:06:57.860 
which means that it's very easy to start up and very quick

98
00:06:57.870 --> 00:06:59.790 
because it does not need compilation.

99
00:07:00.950 --> 00:07:03.970 
This makes it suitable for a very different range of tasks

100
00:07:03.970 --> 00:07:06.750 
like scripting where java is not really good at.

101
00:07:08.250 --> 00:07:13.870 
However java has a memory model that is able to deal with very

102
00:07:13.870 --> 00:07:16.920 
large heap sizes this is something that's not very easy to

103
00:07:16.920 --> 00:07:21.220 
do in Python for two reasons. Python uses reference counting

104
00:07:21.480 --> 00:07:27.120 
as a memory management mechanism and Python has a global interpreter lock because it's

105
00:07:27.290 --> 00:07:30.610 
an interpreted language, which means that it's very difficult

106
00:07:30.620 --> 00:07:34.810 
to write concurrent applications that use large memory structures

107
00:07:34.810 --> 00:07:35.500 
concurrently.

108
00:07:37.620 --> 00:07:40.860 
What does this mean for the granularity that comes out of these Tech Stack

109
00:07:41.120 --> 00:07:44.310 
if you're trying to express like the minimum granularity that

110
00:07:44.310 --> 00:07:48.510 
makes sense or where it makes sense to not design a particular

111
00:07:48.510 --> 00:07:52.080 
service component smaller than that. For Java in practice you

112
00:07:52.080 --> 00:07:55.910 
might have a service that needs like two CPUs and two gigabytes of RAM.

113
00:07:56.240 --> 00:08:00.150 
With as python you might be fine with just one cpu and one

114
00:08:00.150 --> 00:08:03.910 
hundred twenty eight megabytes of RAM. Or in other words

115
00:08:04.530 --> 00:08:08.820 
a python application in terms of ram is like one sixteenth

116
00:08:08.830 --> 00:08:11.200 
of a minimum viable java application.

117
00:08:14.090 --> 00:08:15.240 
Where does this matter?

118
00:08:16.140 --> 00:08:21.560 
In practice we can use an example that very well illustrates how this

119
00:08:21.660 --> 00:08:26.030 
runtime this tech stack decision is critical for enabling an

120
00:08:26.030 --> 00:08:29.610 
efficient use of resources, and the example we're going to look

121
00:08:29.610 --> 00:08:33.930 
at as serverless computing. Serverless computing is built around the idea

122
00:08:34.170 --> 00:08:38.680 
that a software team hands a piece of code or a container to a cloud provider

123
00:08:39.470 --> 00:08:43.580 
and that provider is operating the whole runtime, so the operating

124
00:08:43.580 --> 00:08:45.410 
system, the infrastructure everything

125
00:08:46.060 --> 00:08:52.760 
and the provider bills the customer only for the amount of CPU and RAM

126
00:08:53.080 --> 00:08:56.900 
usage, that was used to serve actual requests.

127
00:08:57.860 --> 00:09:01.970 
And this is measured in milliseconds. This means that there

128
00:09:01.970 --> 00:09:04.830 
is an incentive for the team to,

129
00:09:06.020 --> 00:09:09.500 
for the software developers to make their applications very fast

130
00:09:09.990 --> 00:09:14.680 
and also make applications very fast to start up and shut down

131
00:09:14.990 --> 00:09:17.560 
because this is what the cloud provider will do when there

132
00:09:17.560 --> 00:09:22.620 
are no requests coming in. As you can see in the figure here on the chart

133
00:09:23.070 --> 00:09:29.490 
that is a section in between the blue requests coming in, where there is no

134
00:09:29.700 --> 00:09:32.970 
request being served by the application and consequentially

135
00:09:32.980 --> 00:09:36.740 
in the green bar which shows the time that's billable below.

136
00:09:37.130 --> 00:09:40.090 
There is a gap which means that the provider does not charge

137
00:09:40.090 --> 00:09:42.030 
the customer for this time

138
00:09:43.150 --> 00:09:46.390 
and as we can see after serving the third request, the provider

139
00:09:46.390 --> 00:09:48.770 
decides to terminate the container instance

140
00:09:49.410 --> 00:09:53.700 
and after that of course the provider also has no cost anymore

141
00:09:53.700 --> 00:09:55.240 
for providing the infrastructure.

142
00:09:56.560 --> 00:09:59.870 
The interesting bit here with the serverless is also that the

143
00:09:59.870 --> 00:10:02.810 
customer is charged for the start-up time of the service which

144
00:10:02.810 --> 00:10:05.420 
is on the very beginning of the chart.

145
00:10:06.130 --> 00:10:10.390 
This means that when a customer wants to take advantage of a serverless environment

146
00:10:10.520 --> 00:10:13.190 
they should build an application using a tech stick that's

147
00:10:13.190 --> 00:10:15.340 
very fast to start up and shut down.

148
00:10:16.980 --> 00:10:21.330 
Another interesting aspect is that the serverless paradigm gives

149
00:10:21.340 --> 00:10:25.030 
us a market solution to finding a sustainable

150
00:10:26.640 --> 00:10:29.670 
infrastructure solution for this application.

151
00:10:30.530 --> 00:10:35.290 
Developers are incentivized to build very efficient applications while

152
00:10:35.390 --> 00:10:39.730 
providers are incentivized to build logic that very efficiently

153
00:10:39.730 --> 00:10:43.810 
allocates these applications onto physical hardware and scale

154
00:10:43.810 --> 00:10:47.730 
them up and down very tightly in line with demand.

155
00:10:52.700 --> 00:10:57.830 
Another important consideration for software engineers trying to build

156
00:10:58.070 --> 00:11:02.330 
sustainable software is to decouple the software from the infrastructure

157
00:11:02.330 --> 00:11:03.630 
that it's actually running on.

158
00:11:04.590 --> 00:11:08.640 
This allows a software team as better and better infrastructure becomes or

159
00:11:09.230 --> 00:11:13.090 
becomes available over time to take advantage of this without

160
00:11:13.090 --> 00:11:17.050 
having to re engineer or rebuild their applications.

161
00:11:18.280 --> 00:11:22.880 
One set of principles in this space or that allows us to do

162
00:11:22.880 --> 00:11:25.150 
this is the twelve factor principles.

163
00:11:25.850 --> 00:11:29.900 
For example one of the principles of the twelve factor principles is

164
00:11:30.080 --> 00:11:35.560 
that we encode software as processes as normal operating processes

165
00:11:35.770 --> 00:11:39.380 
which for example in a serverless environment are very easy to start up

166
00:11:39.660 --> 00:11:40.490 
and scale down.

167
00:11:42.040 --> 00:11:48.770 
Another example is using a multi cloud strategy by targeting the infrastructure

168
00:11:49.010 --> 00:11:53.250 
that's provided by Kubermeters as container orchestrator instead of targeting

169
00:11:53.520 --> 00:11:56.050 
another layer or lower level of hardware.

170
00:11:57.120 --> 00:12:01.380 
This means that anywhere in the future where I can provide

171
00:12:01.380 --> 00:12:04.040 
a Kubermeters cluster I can move my application to.

172
00:12:04.640 --> 00:12:07.590 
This allows me for example to move to another cloud provider

173
00:12:07.600 --> 00:12:11.470 
that is more green or I can even repatriate my workloads to

174
00:12:11.470 --> 00:12:12.350 
a private cloud.

175
00:12:16.740 --> 00:12:19.900 
Measurement is very important. You can't measure,

176
00:12:20.480 --> 00:12:22.460 
you can't manage what you can't measure.

177
00:12:23.930 --> 00:12:27.940 
Sustainability is very hard to measure because it's very encompassing

178
00:12:27.940 --> 00:12:32.050 
and has a lot of different aspects. However what we have established

179
00:12:32.050 --> 00:12:35.770 
as practices in software engineering is how to measure compliance

180
00:12:35.770 --> 00:12:37.780 
to functional and non functional requirements.

181
00:12:38.700 --> 00:12:41.900 
Instrumentation is the process of adding these measurements

182
00:12:41.900 --> 00:12:46.090 
like metrics and logs to software as a run-time behavior

183
00:12:46.500 --> 00:12:50.670 
as opposed to for example demonstrating that we fulfill a non

184
00:12:50.670 --> 00:12:54.010 
functional requirement like one hundred millisecond request latency

185
00:12:54.680 --> 00:12:58.190 
in a dedicated test and an acceptance test.

186
00:12:59.560 --> 00:13:03.550 
If we have these data available at run-time, it allows us to have

187
00:13:03.740 --> 00:13:04.950 
better decision making

188
00:13:05.640 --> 00:13:10.330 
for example we can measure how the software uses

189
00:13:11.310 --> 00:13:15.860 
the internal logic, for example in the update service that we're

190
00:13:15.860 --> 00:13:19.880 
using throughout the lecture as an example we might instrument

191
00:13:19.880 --> 00:13:23.710 
the service to measure how many updates it has served.

192
00:13:24.230 --> 00:13:29.310 
This allows us to build key performance indicators or KPIs as ratios of

193
00:13:29.570 --> 00:13:33.970 
how much infrastructure or resources did we consume for delivering

194
00:13:33.970 --> 00:13:37.340 
how much business benefit. For example we could say how many

195
00:13:37.360 --> 00:13:41.020 
cpu hours did we use per update that we served.

196
00:13:41.890 --> 00:13:45.580 
Making this visible allows us to manage and improve this.

197
00:13:48.780 --> 00:13:52.250 
One last consideration for software development teams is to

198
00:13:52.250 --> 00:13:56.890 
not just consider the run time of the application, but also

199
00:13:58.210 --> 00:14:01.740 
to also consider the development time of the application.

200
00:14:03.220 --> 00:14:04.500 
Most importantly

201
00:14:05.780 --> 00:14:09.640 
it is to build the right thing and not just to build it right.

202
00:14:09.990 --> 00:14:13.790 
This means that software development teams should look to build

203
00:14:13.830 --> 00:14:17.270 
the right solutions to the problems and not build solutions

204
00:14:17.270 --> 00:14:20.840 
to problems that don't exist. This reduces a lot of waste.

205
00:14:21.630 --> 00:14:25.860 
Another concern is to anticipate maintenance concerns in the future.

206
00:14:26.160 --> 00:14:31.010 
So this is about choosing tool chains, managing dependencies responsibly

207
00:14:31.270 --> 00:14:34.990 
in a way that allows software to be operated and

208
00:14:35.750 --> 00:14:37.380 
built with very little churn.

209
00:14:38.340 --> 00:14:43.870 
CI/CD is also a very big sink of resources for many software development teams.

210
00:14:45.010 --> 00:14:48.930 
Improving the time it takes to build the software making this

211
00:14:48.930 --> 00:14:52.950 
faster and more efficient is not just more sustainable because

212
00:14:52.950 --> 00:14:57.740 
it means less resources, it also leads to a much better developer experience.

213
00:14:58.490 --> 00:15:02.480 
And this is very important. Developers need to be conscious

214
00:15:02.480 --> 00:15:05.870 
about making tradeoffs between the developer experience which

215
00:15:05.870 --> 00:15:09.790 
means how comfortable it is to implement the software versus

216
00:15:09.790 --> 00:15:12.860 
how efficient it's going to be at run-time.

217
00:15:13.650 --> 00:15:18.750 
This can influence for example decisions about a text like choosing javascript over

218
00:15:18.870 --> 00:15:19.780 
a language like C++.

219
00:15:22.570 --> 00:15:26.190 
Ok in summary what are the recommendations for developers. Developers

220
00:15:26.190 --> 00:15:29.090 
should set a high bar for non function requirements.

221
00:15:29.540 --> 00:15:32.720 
To couple applications from infrastructure and provide

222
00:15:33.190 --> 00:15:35.530 
limitation and visibility into software operation.

223
00:15:36.140 --> 00:15:40.860 
Last but not least software is not only run but it's also developed

224
00:15:40.920 --> 00:15:44.100 
and this requires resources that also need to be considered

225
00:15:44.110 --> 00:15:45.960 
for sustainable software engineering.
