WEBVTT

1
00:00:00.870 --> 00:00:05.590 
This is knowledge graphs lecture four
knowledge representation with ontologies.

2
00:00:06.510 --> 00:00:10.830 
In this part of the lecture we are
asking ourselves why do we need

3
00:00:11.170 --> 00:00:16.730 
logic. Good question. However what
we did so far was all based

4
00:00:16.730 --> 00:00:20.310 
on RDF and RDF(S)and I
will show you now first

5
00:00:20.710 --> 00:00:26.310 
that exactly RDF and RDF(S) are not
really sufficient for our purposes.

6
00:00:27.040 --> 00:00:31.090 
One of the drawbacks is the so
called inability to express

7
00:00:31.090 --> 00:00:35.220 
the locality of global principles. What
does that mean? So we have here a

8
00:00:35.410 --> 00:00:40.360 
simple example of a property eats
and this says usually an animal

9
00:00:40.520 --> 00:00:43.920 
eats some kind of food and we
have two kinds of food. So we

10
00:00:43.920 --> 00:00:48.330 
have vegetables and we have meat and both
of course are sub-classes of food.

11
00:00:49.610 --> 00:00:53.750 
The problem is now how do I express
that for example if I have

12
00:00:53.750 --> 00:00:58.020 
exactly this kind of structure
that cows only eat vegetables

13
00:00:58.020 --> 00:01:02.320 
and other animals only eat meat
and some animals do eat both.

14
00:01:03.530 --> 00:01:07.560 
That might be complicated with a
simple relation eats we have

15
00:01:07.560 --> 00:01:11.090 
now and not possible based
on RDF and RDF(S).

16
00:01:12.830 --> 00:01:16.840 
Another example that you already
might know is the inability

17
00:01:16.840 --> 00:01:21.620 
to express disjunctiveness among
classes. So for example if

18
00:01:21.620 --> 00:01:25.420 
somebody is dead he cannot be
alive at the same time. So dead

19
00:01:25.430 --> 00:01:29.620 
people and living people are both
subclasses of people but I can't express

20
00:01:29.760 --> 00:01:34.150 
that they are disjunct, that no
element exists that is at the

21
00:01:34.150 --> 00:01:38.220 
same time element of one class
as well as of the other.

22
00:01:40.850 --> 00:01:45.600 
Another thing that fails is in
RDF I am not able to combine

23
00:01:45.610 --> 00:01:50.170 
classes to more complex classes.
Take a simple example. I define

24
00:01:50.170 --> 00:01:54.040 
here road users and road users
should be you know the sum of

25
00:01:54.050 --> 00:01:57.590 
all motorists, motor cyclists,
pedestrians and cyclists.

26
00:01:58.300 --> 00:02:02.270 
Yeah this is of course a problem
because I can't do combinations

27
00:02:02.270 --> 00:02:06.410 
of classes to define new classes.
New classes or a new class

28
00:02:06.410 --> 00:02:09.850 
contains only members from a
given class combination and

29
00:02:09.860 --> 00:02:14.680 
exactly to express this it's not
possible. So usually then what

30
00:02:14.680 --> 00:02:18.520 
I do here is I can't express a
class that is somehow closed.

31
00:02:18.540 --> 00:02:22.020 
So closed classes here
are also not possible.

32
00:02:24.120 --> 00:02:28.470 
Next thing cardinality constraints.
Of course I could here create

33
00:02:28.480 --> 00:02:32.510 
two classes human and parent
and I could say a human has a

34
00:02:32.510 --> 00:02:35.570 
parent who is a parent and of
course parent is a subclass of

35
00:02:35.570 --> 00:02:40.360 
human. But I can't express that every
human usually has exactly two parents

36
00:02:41.240 --> 00:02:44.980 
as well as sometimes exceptions.
So I can't do that simply.

37
00:02:47.340 --> 00:02:52.380 
Moreover property constraints let's
say for example transitivity

38
00:02:52.380 --> 00:02:55.300 
you know this already from the
subclass relation. A subclass

39
00:02:55.300 --> 00:02:57.510 
of a subclass is
also a subclass.

40
00:02:58.320 --> 00:03:02.890 
This I can't express with RDF(S).
The same as uniqueness,

41
00:03:03.210 --> 00:03:07.370 
usually if I want to have a property
like for example 'is mother of'

42
00:03:07.540 --> 00:03:11.890 
then usually mother should be unique,
you know. You can't can only

43
00:03:11.890 --> 00:03:13.930 
have one biological
mother so far.

44
00:03:14.550 --> 00:03:19.720 
Or inversiveness. I can't define
a property and say this is

45
00:03:19.910 --> 00:03:23.430 
the inverse of that property.
Like for example 'is parent of'

46
00:03:23.440 --> 00:03:28.040 
is the inverse of 'is child of'
so exactly this is missing.

47
00:03:29.090 --> 00:03:33.840 
And all of these problems boil
down to a central problem which

48
00:03:33.840 --> 00:03:40.180 
is the general problem of RDF and RDF(S).
RDF(S) does not have the possibility

49
00:03:40.390 --> 00:03:41.970 
to represent negation.

50
00:03:42.800 --> 00:03:46.240 
So I could express here that
I am a vegetarian. So I am

51
00:03:46.810 --> 00:03:49.840 
member of the class vegetarian
as well as I am member of the

52
00:03:49.840 --> 00:03:54.040 
class non vegetarian. However that
does not automatically generate

53
00:03:54.040 --> 00:03:58.670 
any kind of contradiction because I don't
have negation, I can't contradict myself.

54
00:03:59.050 --> 00:04:01.220 
Everything is
true so far.

55
00:04:02.140 --> 00:04:04.660 
You see that's
complicated.

56
00:04:05.650 --> 00:04:11.430 
For that reason RDF(S) is not sufficient
for ontologies in our definition.

57
00:04:12.490 --> 00:04:16.170 
We set an ontology is an explicit
formal specification of a

58
00:04:16.170 --> 00:04:20.610 
shared conceptualization and the most
important part formal specification means

59
00:04:21.040 --> 00:04:27.720 
it must formally machine readable. It must
have a formal machine readable semantics

60
00:04:27.950 --> 00:04:31.860 
and this semantics of course is
derived from mathematical logic

61
00:04:31.860 --> 00:04:38.970 
on which our ontologies in the end are built
upon. We need mathematical logic for exactly

62
00:04:39.330 --> 00:04:44.700 
this machine readable and machine
understandable even more semantic. So

63
00:04:44.850 --> 00:04:50.340 
we will see that. For that we are going
now down to the foundations of logic.

64
00:04:51.100 --> 00:04:56.520 
For our lecture let's define logic as the
study of how to make formal correct

65
00:04:57.090 --> 00:04:58.800 
deductions and
inferences.

66
00:04:59.670 --> 00:05:04.100 
Why formal logic? Simply from our
point of view we want to enable

67
00:05:04.220 --> 00:05:10.260 
automation. So we want to do automated
deductions automatic inferences.

68
00:05:10.500 --> 00:05:15.220 
So we want a program a computer
to find out about deductions

69
00:05:15.220 --> 00:05:19.890 
and inferences. So this is why we
need formal logic in our case.

70
00:05:20.430 --> 00:05:23.730 
The idea is rather old. Already
here in the eighteenth century

71
00:05:23.730 --> 00:05:29.430 
you might remember here Gottfried Wilhelm
Leibniz, famous polymath and philosopher.

72
00:05:29.650 --> 00:05:33.000 
He already had the right idea.
He wrote here in a letter to

73
00:05:33.000 --> 00:05:36.090 
Philipp Spener in1687
the following:

74
00:05:37.440 --> 00:05:41.880 
"The only way to rectify our
reasonings it is to make them as

75
00:05:41.890 --> 00:05:45.880 
tangible as those of the
mathematicians, so that we can find

76
00:05:45.880 --> 00:05:49.910 
our error at a glance, and when
there are disputes among persons,

77
00:05:49.910 --> 00:05:54.480 
we can simply say: Let us
calculate, without further ado,

78
00:05:54.840 --> 00:06:00.560 
to see who of us is right." So
this means he wanted to find a

79
00:06:00.560 --> 00:06:05.430 
formal knowledge representation that
can be used instead of language

80
00:06:05.720 --> 00:06:08.450 
because a formal knowledge
representation we know this already

81
00:06:08.450 --> 00:06:12.040 
is unique and is based on the
formal principles of mathematical

82
00:06:12.040 --> 00:06:16.710 
logic where we can do proofs
and we can prove who is right

83
00:06:16.880 --> 00:06:20.650 
and who is wrong. And this of
course is a very nice dream that

84
00:06:20.660 --> 00:06:25.780 
nowadays we are close to fulfill
by applying mathematical logic

85
00:06:25.980 --> 00:06:30.560 
to symbolic reasoning, to
ontologies. So let's see.

86
00:06:31.800 --> 00:06:35.950 
For the foundations of logic we first need
a syntax . We already know the term.

87
00:06:36.090 --> 00:06:39.770 
Syntax is symbols without any
meaning, so it defines the rules

88
00:06:39.770 --> 00:06:44.660 
how to construct well-formed and valid
sequences of symbols, so called strings.

89
00:06:45.650 --> 00:06:50.220 
And then we have semantics. This is
the meaning of syntax. So this

90
00:06:50.370 --> 00:06:55.190 
semantic defines the rules how the
meaning of complex sequences of symbols

91
00:06:55.460 --> 00:06:59.510 
can be derived from atomic sequences
of symbols. So also rather

92
00:06:59.510 --> 00:07:02.800 
easy but we must get closer
to the term semantic.

93
00:07:04.130 --> 00:07:07.390 
Take the following example - so this
is taken from programming language

94
00:07:07.590 --> 00:07:12.100 
programming languages so
I could say if I is

95
00:07:12.110 --> 00:07:15.860 
negative then display
a negative account.

96
00:07:16.510 --> 00:07:20.690 
And it means from that kind of
programming language the meaning

97
00:07:20.690 --> 00:07:23.740 
behind that is print the message
negative account in the case

98
00:07:23.740 --> 00:07:27.460 
the account balance is negative.
So that's the assignment of

99
00:07:27.460 --> 00:07:30.910 
meaning that would be kind of some
semantics that we have here.

100
00:07:32.080 --> 00:07:35.830 
We can do this a bit more
formally but first we have to

101
00:07:35.840 --> 00:07:38.890 
think of why should we really
care about semantics.

102
00:07:39.290 --> 00:07:44.030 
And there another famous philosopher
might come to our help.

103
00:07:44.030 --> 00:07:47.220 
So this is Bertrand Russell,
also pretty famous look him up

104
00:07:47.220 --> 00:07:51.260 
at wikipedia you will find out very
interesting things about that guy

105
00:07:51.670 --> 00:07:56.130 
who co-authored also together with
another famous mathematician

106
00:07:56.130 --> 00:07:59.130 
Principia Mathematica. So
this is really interesting.

107
00:07:59.930 --> 00:08:02.870 
So he said well from a
philosophical point of view

108
00:08:03.350 --> 00:08:07.960 
we need to specify the relationships
between statements in

109
00:08:07.960 --> 00:08:10.130 
the logic so we do these
kind of statements

110
00:08:10.620 --> 00:08:15.340 
and the existential phenomena they
describe. So this is exactly

111
00:08:15.340 --> 00:08:18.540 
the relationship between the
statements of the logic and the

112
00:08:18.540 --> 00:08:21.640 
external world. So what do they
describe what does they what

113
00:08:21.640 --> 00:08:24.660 
do they mean? So this
is exactly semantics.

114
00:08:25.550 --> 00:08:28.600 
The question of course then is
the programmer might ask yeah

115
00:08:28.610 --> 00:08:31.160 
that's fine but I don't
get paid for philosophy.

116
00:08:31.690 --> 00:08:36.290 
Yeah but from a practical point
of view not from a philosopher

117
00:08:36.430 --> 00:08:40.470 
philosophical point of view, in
order to specify build and test

118
00:08:40.470 --> 00:08:42.570 
ontology based
tools or systems

119
00:08:43.260 --> 00:08:47.810 
we need to precisely define the
relationships like entailment for example

120
00:08:48.030 --> 00:08:52.810 
between logical statements and this
defines the intended behavior

121
00:08:52.810 --> 00:08:58.550 
of our tools and systems. So you see
we need semantics and it should be

122
00:08:58.680 --> 00:09:00.570 
formally expressible.

123
00:09:01.400 --> 00:09:06.260 
Ok so let's have a look at the
different variants of semantics.

124
00:09:06.260 --> 00:09:09.190 
We take again the example here
from programming languages and

125
00:09:09.190 --> 00:09:13.310 
what you see here is in some kind
of lets say pseudo programming

126
00:09:13.310 --> 00:09:17.750 
language how a factorial can
be computed so this is the

127
00:09:17.870 --> 00:09:21.620 
computation of the factorial. And
this is also the intentional

128
00:09:21.620 --> 00:09:26.400 
semantics the intentional semantics
of exactly that piece of code is

129
00:09:26.640 --> 00:09:30.710 
the computation of the factorial.
This is the meaning intended

130
00:09:30.800 --> 00:09:34.440 
by the user who wrote that and
this restricts the set of all

131
00:09:34.440 --> 00:09:38.390 
possible models which means meanings
to the meaning intended by

132
00:09:38.560 --> 00:09:42.600 
usually the human user. So this
is only one piece of semantics.

133
00:09:43.320 --> 00:09:46.960 
There is also a formal semantics this
is simply you know mathematically

134
00:09:46.960 --> 00:09:49.760 
the combination of the factorial
means exactly that and this

135
00:09:49.760 --> 00:09:53.970 
is here this formula is expressed here
in the piece of programming code. So

136
00:09:54.220 --> 00:09:57.880 
the formal semantics aims to
express the meaning of simple

137
00:09:57.880 --> 00:10:01.820 
sequences in that sense programs
in a formal language in a

138
00:10:01.820 --> 00:10:05.420 
way that assertion so the simple
sequences, here the programs

139
00:10:05.580 --> 00:10:09.270 
can be proven by applications of
deduction rules. So this is

140
00:10:09.270 --> 00:10:11.890 
really important semantics in
programming languages based on

141
00:10:11.900 --> 00:10:15.100 
formal semantics, I can do proofs.
I can prove that this is the

142
00:10:15.100 --> 00:10:16.030 
correct program.

143
00:10:18.730 --> 00:10:23.200 
Further on there is something for programming
languages which is called procedural

144
00:10:23.500 --> 00:10:27.450 
semantics. In our case that would
be the behavior of the program

145
00:10:27.450 --> 00:10:31.500 
at execution time. So procedural
semantics is the meaning of

146
00:10:31.500 --> 00:10:35.790 
a language expression program
and this is the procedure that

147
00:10:35.790 --> 00:10:41.040 
takes place internally whenever this
expression occurs. So these are

148
00:10:41.220 --> 00:10:46.910 
different variants of semantics so
how do I define the semantics

149
00:10:46.920 --> 00:10:50.050 
of a mathematical logic
umm mathematical logic.

150
00:10:50.920 --> 00:10:54.960 
Bertrand Russell helps us again and
says in mathematical logic we define

151
00:10:55.150 --> 00:10:59.940 
the semantics in terms of
models. So we use model theory

152
00:10:59.940 --> 00:11:02.840 
we exploit model theory
there. And the model

153
00:11:03.320 --> 00:11:08.470 
is supposed to be an analogue
of the world or a part of the

154
00:11:08.470 --> 00:11:12.160 
world that is being modelled. So this
is then what we treat with. So

155
00:11:13.610 --> 00:11:17.160 
semantics is defined in
terms of kind of a model.

156
00:11:18.070 --> 00:11:22.290 
And this here is Alfred Tarski
who provided us with so called

157
00:11:22.300 --> 00:11:25.550 
model theoretic semantics.
So this is how really

158
00:11:26.140 --> 00:11:31.350 
we create models as being a semantics
for some formal mathematical

159
00:11:31.350 --> 00:11:35.460 
logic and model theoretic semantics
performs the semantic interpretation of

160
00:11:35.630 --> 00:11:41.310 
artificial or natural languages by and
this comes from his or his paper

161
00:11:41.440 --> 00:11:46.880 
identifying meaning with an exact and formally
defined interpretation within a model.

162
00:11:47.150 --> 00:11:52.700 
So model-theoretic semantics is nothing
else but the formal interpretation

163
00:11:53.060 --> 00:11:58.530 
of let's say a mathematical logic
or of a language expression based

164
00:11:58.700 --> 00:12:03.490 
on a model. Apply this now on
the most simplistic logic that

165
00:12:03.490 --> 00:12:06.840 
you can think of which is the
propositional logic what you

166
00:12:06.840 --> 00:12:11.950 
do there is simply you assigned
truth values true and false

167
00:12:11.950 --> 00:12:14.250 
to all your atomic
assertions that you have.

168
00:12:14.660 --> 00:12:17.320 
The thing is either true or false
and something like that and

169
00:12:17.320 --> 00:12:21.310 
if you have combinations of that
logical connectives they are

170
00:12:21.310 --> 00:12:24.550 
described in propositional logic
simply by a truth table so

171
00:12:24.550 --> 00:12:28.430 
you can simply save in a truth table where
you do conjunction and disjunction

172
00:12:28.550 --> 00:12:31.400 
and you have the results what
happens if you combine truth

173
00:12:31.400 --> 00:12:37.160 
with truth. So truth and truth equals
truth for example. These are then

174
00:12:37.300 --> 00:12:40.660 
the truth tables that you apply
and exactly this is the model

175
00:12:40.660 --> 00:12:44.940 
that you use to give semantics
to propositional logic.

176
00:12:46.120 --> 00:12:49.620 
Of course this kind of model
theoretic semantics becomes more

177
00:12:49.620 --> 00:12:53.010 
complicated if you can go to higher
order logics like for example

178
00:12:53.010 --> 00:12:57.100 
first order logic or description logic
that is later on useful for ontologies.

179
00:12:57.310 --> 00:13:01.700 
But this exactly is the basis
this is the fundament.

180
00:13:03.130 --> 00:13:06.940 
In the end we want also to see how
this can be expressed formally

181
00:13:06.940 --> 00:13:10.210 
if we want to give model theoretic
semantics to any kind of logic.

182
00:13:10.410 --> 00:13:15.330 
So any logic L that we have here
consists of a set of statements

183
00:13:15.330 --> 00:13:19.880 
that we have and of course the logic
also comprises an entailment

184
00:13:19.880 --> 00:13:22.560 
relation and you see the symbols
that are used for that. So

185
00:13:22.560 --> 00:13:25.760 
the set of statements is S
and the entailment relation

186
00:13:25.970 --> 00:13:29.860 
you see here under
point number two. Now

187
00:13:31.340 --> 00:13:36.500 
let's have a set of statements
so this is capital Φ is a set

188
00:13:36.500 --> 00:13:40.400 
of statements or subset of S our
set of statements and we have

189
00:13:40.400 --> 00:13:43.320 
lower case φ which is a
statement. We say no

190
00:13:43.920 --> 00:13:49.650 
lowercase φ is a logical consequence
of the set of statements

191
00:13:49.650 --> 00:13:56.410 
that are in capital Φ or from the assertions
of capital Φ follows the assertion

192
00:13:56.810 --> 00:14:00.540 
lower case φ. So this is what we
can do this is the entailment

193
00:14:00.540 --> 00:14:03.480 
relation we are talking about
and what is then really really

194
00:14:03.480 --> 00:14:09.020 
important in logic like that? We have of
course to define identity and this usually

195
00:14:09.390 --> 00:14:14.010 
uh works in the following way: we
say if two different assertions

196
00:14:14.330 --> 00:14:20.910 
Φ and ψ. Both are part of our set of
statements S and if we say from

197
00:14:21.820 --> 00:14:26.190 
the set of lower case φ so we have
to do a set in that because

198
00:14:26.190 --> 00:14:30.660 
the entailment relation as you see
here is always defined between a set

199
00:14:31.180 --> 00:14:37.700 
and a statement. So if
lowercase φ as a set entails

200
00:14:37.780 --> 00:14:42.430 
ψ and vice versa ψ as
I said entails φ

201
00:14:43.160 --> 00:14:48.730 
then both assertions φ and ψ are
logically equivalent which

202
00:14:48.730 --> 00:14:54.760 
means they are identical and this is the
basis for any model theoretic semantics

203
00:14:54.870 --> 00:14:58.530 
for any logic only in
theory of course.

204
00:14:59.170 --> 00:15:03.450 
And in the next lectures we will show
you how this is really applied.

205
00:15:03.900 --> 00:15:07.550 
But you might have realised of
course for that we need some

206
00:15:07.550 --> 00:15:12.480 
knowledge of essential logics to cope
exactly with the terms ontology

207
00:15:12.620 --> 00:15:16.060 
and this then will be subject of
the next excursion. So we do

208
00:15:16.060 --> 00:15:19.020 
a brief recap of
essential logics.
