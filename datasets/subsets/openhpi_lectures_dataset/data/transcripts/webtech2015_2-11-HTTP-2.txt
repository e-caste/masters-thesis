WEBVTT

1
00:00:04.870 --> 00:00:10.430 
When we speak about HTTP we have to speak about the future of HTTP

2
00:00:10.830 --> 00:00:13.520 
and the future is HTTP/2.

3
00:00:14.990 --> 00:00:21.820 
And here is an overview about HTTP/2 which was finally standardized

4
00:00:21.830 --> 00:00:23.920 
in february 2015.

5
00:00:25.470 --> 00:00:30.500 
This is the new standard for the communication in the world wide web,

6
00:00:30.920 --> 00:00:36.140 
it is the successor of HTTP/1.1 and it comes with many

7
00:00:36.580 --> 00:00:42.550 
improvements where the main focus is on the improved perceived

8
00:00:42.560 --> 00:00:44.180 
speed-up for the end user.

9
00:00:45.290 --> 00:00:49.700 
So here are some of the characteristics of HTTP/2:

10
00:00:50.180 --> 00:00:56.930 
HTTP/2 is a binary protocol, HTTP/2 introduces request multiplexing,

11
00:00:57.830 --> 00:01:01.050 
HTTP/2 can compress

12
00:01:01.670 --> 00:01:06.950 
header information, HTTP/2 specifies server push

13
00:01:07.530 --> 00:01:11.480 
and is backward compatible to HTTP/1.1,

14
00:01:12.410 --> 00:01:19.050 
so methods and status codes from HTTP/1.1 will remain also

15
00:01:19.290 --> 00:01:24.300 
true for HTTP/2. Lets have a closer look to some of this

16
00:01:24.790 --> 00:01:31.720 
new improvements, for exampl,e also HTTP/2 makes the web more secure.

17
00:01:33.290 --> 00:01:38.300 
Lets start with the new concepts of streams, messages and frames.

18
00:01:39.890 --> 00:01:47.440 
So, HTTP/2 protocol is a binary protocol, all the earlier versions were

19
00:01:48.050 --> 00:01:53.830 
have been plain text based and plain text can be read by humans,

20
00:01:54.470 --> 00:01:56.720 
this is not the case for the binary protocol.

21
00:01:57.640 --> 00:02:04.650 
HTTP/2 introduces the new concepts of streams, messages and frames

22
00:02:04.950 --> 00:02:12.050 
for a communication. Stream means a virtual channel within a connection which

23
00:02:12.210 --> 00:02:19.320 
carries bi-directional messages. A message is a logical HTTP message

24
00:02:19.570 --> 00:02:26.900 
such as a request or response which consists of one or more frames

25
00:02:27.270 --> 00:02:32.790 
and a frame is the smallest unit of a communication, which carries

26
00:02:32.820 --> 00:02:38.890 
a specific type of data, for example HTTP headers, payload and others.

27
00:02:39.390 --> 00:02:42.740 
These are streams messages and frames.

28
00:02:43.880 --> 00:02:49.460 
HTTP/2 allows mechanisms of multiplexing.

29
00:02:50.990 --> 00:02:53.130 
A known problem for HTTP/1.1,

30
00:02:53.790 --> 00:02:58.730 
the former version, was that only a limited number of connections

31
00:02:58.960 --> 00:03:07.530 
for a host could be could be obtained, so downloading of different resources

32
00:03:07.910 --> 00:03:09.390 
which belong to a

33
00:03:10.650 --> 00:03:12.890 
web document from a server

34
00:03:14.220 --> 00:03:18.850 
is in principle possible only one after the other

35
00:03:19.350 --> 00:03:23.130 
and if you remember that the reason the web document

36
00:03:23.950 --> 00:03:28.740 
consists of many different resources, this was a strong limitation.

37
00:03:29.640 --> 00:03:32.090 
So best practice with HTTP/1.1

38
00:03:32.790 --> 00:03:36.580 
was so called domain charding.

39
00:03:37.260 --> 00:03:41.810 
Here different resources have a website, the images, javascript,

40
00:03:42.260 --> 00:03:48.330 
the cascading stylesheets are published on different subdomains

41
00:03:48.830 --> 00:03:55.810 
and the reason was simply that different subdomains allow more concurrent

42
00:03:55.940 --> 00:03:57.860 
tcp connections.

43
00:03:59.230 --> 00:04:03.030 
For that reason to overcome this limitation, to makes this more

44
00:04:03.440 --> 00:04:09.250 
efficient, HTTP/2 introduces the concept of multiplexing.

45
00:04:10.450 --> 00:04:16.520 
Multiplexing allows to request and receive multiple resources on a single

46
00:04:16.700 --> 00:04:21.580 
TCP connection in an intertwined way.

47
00:04:22.450 --> 00:04:25.920 
So requests are not blocking any longer,

48
00:04:26.340 --> 00:04:30.630 
no need for multiple TCP connections on multiple domain names,

49
00:04:30.990 --> 00:04:38.690 
all the resources belonging to one web document can be transmitted over the same

50
00:04:38.840 --> 00:04:40.610 
TCP connection.

51
00:04:42.700 --> 00:04:46.000 
Another important feature of HTTP/2 is compression

52
00:04:47.320 --> 00:04:50.970 
and HTTP/2 introduces header compression.

53
00:04:51.480 --> 00:04:56.500 
Remember HTTP/1.1 also allows compression but

54
00:04:56.920 --> 00:05:01.130 
HTTP/1.1 only allows compression of the message body,

55
00:05:01.830 --> 00:05:04.380 
the headers need to be uncompressed.

56
00:05:06.340 --> 00:05:09.940 
HTTP/2 allow all the header compression,

57
00:05:10.360 --> 00:05:14.750 
it comes with a special compression method with HPACK.

58
00:05:17.380 --> 00:05:23.680 
This is especially interesting for sites with large cookies. Sometimes cookies are

59
00:05:23.940 --> 00:05:28.670 
very extensive ( 1MB and more ),

60
00:05:30.430 --> 00:05:35.020 
and for recent applications this is very common and

61
00:05:35.700 --> 00:05:41.080 
HTTP/2 allows cookies transported in the header and with the

62
00:05:41.310 --> 00:05:45.120 
possibility also to compress headers, see data,

63
00:05:45.900 --> 00:05:52.490 
to be transferred in the web over the internet are compressed considerably.

64
00:05:53.940 --> 00:05:59.060 
HTTP/2 discourage the use of compressions for the message body,

65
00:06:00.280 --> 00:06:07.190 
it is discouraged to use gzip or deflate and the reason is that

66
00:06:07.310 --> 00:06:11.180 
with both methods there are security concerns.

67
00:06:11.990 --> 00:06:15.120 
There is a famous breach attack on the HTTPS

68
00:06:15.540 --> 00:06:20.620 
and this attack is based on a flaw caused by data compression

69
00:06:21.050 --> 00:06:27.840 
and also concerns against gzip was a reason to introduce this new

70
00:06:28.560 --> 00:06:33.500 
compression method, this HPACK for the header compression.

71
00:06:36.120 --> 00:06:43.750 
Then, another new feature of HTTP/2 is the so called Server Side Push.

72
00:06:44.670 --> 00:06:50.050 
In HTTP/1.1 resources can only be delivered to a

73
00:06:50.050 --> 00:06:54.610 
client by means of a full request/response cycle,

74
00:06:56.250 --> 00:07:01.330 
but the common situation looks like: the client performs a first request,

75
00:07:01.880 --> 00:07:03.140 
parses the HTML

76
00:07:04.810 --> 00:07:08.820 
document server has sent to him and then

77
00:07:09.350 --> 00:07:14.450 
it sees that there are many embedded resources and all those embedded resources

78
00:07:14.710 --> 00:07:17.480 
need to be requested by the client.

79
00:07:18.540 --> 00:07:26.710 
HTTP/2 to overcome this introduces the concept of Server Push.

80
00:07:27.720 --> 00:07:29.870 
This means the server can send

81
00:07:30.530 --> 00:07:35.870 
along a number of additional resources within the first HTTP request

82
00:07:36.360 --> 00:07:41.760 
to save unnecessary round trips, so the server knows which of

83
00:07:41.770 --> 00:07:47.730 
additional resources belong to a page and the server without that the client

84
00:07:47.850 --> 00:07:54.040 
explicitly requested sends all this resources to the

85
00:07:54.490 --> 00:07:55.320 
client,

86
00:07:57.590 --> 00:08:05.080 
but we see the HTTP/2's standard is really very fresh,

87
00:08:05.590 --> 00:08:10.100 
so there are some unclear situation for the implementation,

88
00:08:10.650 --> 00:08:15.560 
so the question is how an HTTP server can identify

89
00:08:16.070 --> 00:08:20.760 
the resources that need to be pushed.

90
00:08:21.780 --> 00:08:26.290 
There are two ideas, one idea is that the authors of a web application,

91
00:08:26.290 --> 00:08:30.720 
of a web document or of a web application, can initiate server push

92
00:08:30.870 --> 00:08:36.170 
explicitly or via additionall HTTP headers, because it also

93
00:08:36.170 --> 00:08:41.230 
knows which resources belong to that application or to that document

94
00:08:41.470 --> 00:08:44.610 
and so he can exactly tells the server

95
00:08:45.410 --> 00:08:50.300 
which resources it makes sense to be pushed with the request.

96
00:08:50.900 --> 00:08:53.710 
And the second idea is to

97
00:08:54.800 --> 00:09:00.410 
the HTTP server learns which request need to be pushed, he can

98
00:09:00.410 --> 00:09:04.530 
learn this by seeing if he sends back a document and then the

99
00:09:04.990 --> 00:09:10.880 
client comes and requested other resources and if this happened many times,

100
00:09:11.160 --> 00:09:17.270 
then the server can remember the situation and if a new client request

101
00:09:17.390 --> 00:09:24.040 
a document then he can push all the resources all the other clients

102
00:09:24.220 --> 00:09:29.040 
have requested when

103
00:09:29.840 --> 00:09:31.610 
they request a document.

104
00:09:34.210 --> 00:09:37.880 
A few words about HTTP/2 and encryption.

105
00:09:39.040 --> 00:09:44.500 
You remember google's SPDY. Google SPDY was the starting point

106
00:09:44.500 --> 00:09:46.620 
for the development of HTTP/2

107
00:09:47.580 --> 00:09:53.480 
and google SPDY was designed as a TLS-only protocol, so for

108
00:09:53.480 --> 00:09:54.980 
google SPDY it was

109
00:09:55.980 --> 00:10:01.540 
necessary to run this, if you want to use encryption,

110
00:10:01.540 --> 00:10:04.110 
method to run this with TLS.

111
00:10:05.460 --> 00:10:13.130 
TLS for having the possibility to encrypt pages or to have strong authentication methods.

112
00:10:14.650 --> 00:10:22.020 
Contrary to google SPDY HTTP/2 will not enforce to use TLS,

113
00:10:22.550 --> 00:10:26.410 
so HTTP/2 also allows non-encrypted communication.

114
00:10:28.010 --> 00:10:33.720 
The specification allows plain HTTP/2 message without any kind of encryption.

115
00:10:34.990 --> 00:10:40.570 
However, if you look to the practice and if you see how the major

116
00:10:40.880 --> 00:10:43.860 
browser manufacturers handles the situation,

117
00:10:44.280 --> 00:10:51.040 
then in the most browsers they enforce the use of TLS in their implementations,

118
00:10:52.530 --> 00:10:58.620 
so to secure the communication, to provide encryption possibilities

119
00:10:58.860 --> 00:11:01.430 
browser manufacturers do not follow this

120
00:11:02.180 --> 00:11:07.390 
idea of the standard to allow also unncrypted

121
00:11:08.000 --> 00:11:14.290 
messages, they implement HTTP/2 in a way that it's every time you use

122
00:11:14.560 --> 00:11:19.190 
TLS. This is true for Google Chrome, for Firefox, for others and

123
00:11:19.190 --> 00:11:23.290 
here for example the statement for Firefox, which says that:

124
00:11:23.290 --> 00:11:29.590 
"that they only implement HTTP/2 over TLS".

125
00:11:32.350 --> 00:11:35.160 
What about the browser and the server support.

126
00:11:36.320 --> 00:11:40.930 
The standard was finished, was published in february 2015,

127
00:11:41.540 --> 00:11:48.180 
and in the moment the following browsers support this new HTTP protocol:

128
00:11:48.760 --> 00:11:50.070 
The Internet Explorer

129
00:11:51.300 --> 00:11:54.970 
works from version 11,

130
00:11:56.090 --> 00:11:58.660 
windows 10 and it

131
00:11:59.290 --> 00:12:05.970 
allows HTTP/2 only with TLS. Firefox 34 and higher numbers

132
00:12:06.210 --> 00:12:08.550 
enable in default

133
00:12:10.350 --> 00:12:15.850 
36 and it's only used in connection with TLS.

134
00:12:16.350 --> 00:12:21.220 
The same is true for Chrome and Chromium, the current versions also

135
00:12:21.340 --> 00:12:27.810 
these browsers allow HTTP/2 only to be used while TLS.

136
00:12:28.660 --> 00:12:34.570 
If we look to the server side and how which of the service support HTTP/2,

137
00:12:34.910 --> 00:12:40.270 
then we see that there's a problem beside of the internet information server

138
00:12:40.760 --> 00:12:45.090 
there are no more public and no more

139
00:12:47.040 --> 00:12:49.190 
main servers

140
00:12:50.150 --> 00:12:52.220 
able to support HTTP/2.

141
00:12:53.480 --> 00:12:58.350 
There are servers available to support HTTP/2: OpenLightSpeed,

142
00:13:00.370 --> 00:13:04.500 
Lucid, H20 but these are more or less smaller

143
00:13:04.910 --> 00:13:11.620 
servers so Apache and others they are not yet able to support HTTP/2.
