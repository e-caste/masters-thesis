WEBVTT

1
00:00:00.000 --> 00:00:06.000 
Back to Hardware. Things happened in hardware
in the last ten years, you know it from the laptops,

2
00:00:09.000 --> 00:00:15.000 
but it also happened in server computers
- actually it happened to a higher extend in servers

3
00:00:15.000 --> 00:00:25.000 
Multi-core architecture was introduced in
the early 2000s, today we have boards

4
00:00:25.000 --> 00:00:34.000 
- a board is a pizza-sized component which goes
into a rack and then is the building block of a server computer

5
00:00:34.000 --> 00:00:42.000 
we typically deal today with
a board called a node then

6
00:00:42.000 --> 00:00:49.000 
We call this a blade.
One blade of an enterprise server is round about,

7
00:00:49.000 --> 00:00:55.000 
the price varies obviously, is round about $50000

8
00:00:55.000 --> 00:01:10.000 
we can copy 50 GB via Infiniband in 10 seconds.
These are a few numbers you should develop

9
00:01:10.000 --> 00:01:16.000 
a feeling for, because if when go for a multi-node
system, things are happening between the systems.

10
00:01:16.000 --> 00:01:25.000 
Engineers have to know what is happening.
Only because the goddamn disk is so slow -

11
00:01:25.000 --> 00:01:32.000 
and we will see in a second how slow it is - that
it totally dominated our thinking, all thinking

12
00:01:32.000 --> 00:01:41.000 
in my career, anything I ever designed and
programmed was dominated by disk and the slowness of disk.

13
00:01:41.000 --> 00:01:52.000 
All I ever build was to overcome
this god damn slow disk. In a totally electronic system,

14
00:01:52.000 --> 00:02:03.000 
we have a spinning, rusty magnetic device which got
only 10 times faster in the last 40 years,

15
00:02:03.000 --> 00:02:20.000 
the average seek time is now 10 ms. When I started
at IBM, it was probably 100. So the disk we

16
00:02:20.000 --> 00:02:28.000 
started working on when we started SAP was already
below 100 ms in seek time. So, only a factor ten.

17
00:02:28.000 --> 00:02:38.000 
Think about what happened since 1972.
The first computer we built a system on was

18
00:02:38.000 --> 00:02:54.000 
the IBM Model 40 and it had 250,000 operations
per second. 250 thousand, 2.5 million, 2.5 billion.

19
00:02:54.000 --> 00:03:14.000 
This is what happened on the
CPU side. A complete distortion of the whole
model of working with databases, large amounts of data.

20
00:03:14.000 --> 00:03:21.000 
The amount of data has a similar
development like the CPU speed and it’s

21
00:03:21.000 --> 00:03:30.000 
actually going now into the petabytes, the
first systems we were running on had 256 kilobytes

22
00:03:30.000 --> 00:03:40.000 
and we did financial accounting, we did purchasing
on these systems. We even sold plus/minus the same business processes.

23
00:03:40.000 --> 00:03:53.000 
We have a memory hierarchy, so we start with
this rusty disk. The good thing is it’s cheap

24
00:03:53.000 --> 00:04:03.000 
and you can buy chunks of it, hordes
of it. Unbelievable large amounts of data, and it has replaced the tapes.

25
00:04:03.000 --> 00:04:09.000 
Then we have flash. There are a few issues with flash,

26
00:04:09.000 --> 00:04:17.000 
the main one is flash is being regarded
as disk from a software perspective, and the

27
00:04:17.000 --> 00:04:25.000 
same input/output methods which were developed
20+ years ago for disks are still in place for flash.

28
00:04:25.000 --> 00:04:33.000 
Nobody is rewriting that. So when
we store data in flash, we store it in cylinders,

29
00:04:33.000 --> 00:04:40.000 
in tracks and segments instead of direct access.

30
00:04:40.000 --> 00:04:44.000 
Main memory is different. Main memory is direct access,

31
00:04:44.000 --> 00:04:59.000 
starts with 0 and ends with 4 TB on one board.
The next level are the CPU caches - L3, L2, L1,

32
00:04:59.000 --> 00:05:07.000 
with different properties - and finally
we arrive in the registers of the CPU and

33
00:05:07.000 --> 00:05:15.000 
there things are happening. Nowhere else it’s
happening. There are four layers which are

34
00:05:15.000 --> 00:05:22.000 
only transport of information, preparation
to put it somewhere where somebody else can pick it up,

35
00:05:22.000 --> 00:05:31.000 
any operation in the end takes place in
the CPU.

36
00:05:31.000 --> 00:05:50.000 
So there is no speciality in in-memory computing, all computing
ever was in-memory, because it takes only place in the CPU.

37
00:05:50.000 --> 00:05:58.000 
But, the whole thing is how fast
can you get data through this memory hierarchy to the CPU?

38
00:05:58.000 --> 00:06:06.000 
And for performance calculations
we will see there are very rough calculations possible

39
00:06:06.000 --> 00:06:16.000 
just by taking the amount of data which has
to be shipped to the CPU.
