WEBVTT

1
00:00:00.470 --> 00:00:02.660 
Hi. This is Isabell Sippli

2
00:00:03.430 --> 00:00:07.530 
and I would like to talk about building modern applications at scale.

3
00:00:08.210 --> 00:00:11.780 
Before I do that, a little disclaimer - this is my personal view

4
00:00:11.780 --> 00:00:16.540 
and opinion. It does not necessarily represent IBM's position or strategy.

5
00:00:17.550 --> 00:00:22.770 
So who am I? I'm a senior architect at the IBM RnD lab in Germany.

6
00:00:23.230 --> 00:00:26.300 
My team and I have been developing cloud native applications

7
00:00:26.310 --> 00:00:28.010 
since 2015.

8
00:00:28.880 --> 00:00:33.040 
We also develop traditional enterprise applications that are built in

9
00:00:33.430 --> 00:00:37.370 
mostly monolithic formats, so I get a bit of both worlds and

10
00:00:37.370 --> 00:00:40.330 
I understand the differences and it's something I'm trying

11
00:00:40.330 --> 00:00:41.360 
to explain to you today.

12
00:00:42.160 --> 00:00:45.620 
Also, I'm leading a team of developers so I look for

13
00:00:46.150 --> 00:00:49.490 
what we do from an architectural perspective, how certain technologies

14
00:00:49.490 --> 00:00:53.530 
fit in and work together with my team and bringing that into real life applications.

15
00:00:53.780 --> 00:00:55.960 
So I also still love to code and I do it

16
00:00:56.410 --> 00:00:57.280 
as much as I can.

17
00:00:59.230 --> 00:01:03.040 
Today I'd like to give you a basic understanding of how we

18
00:01:03.040 --> 00:01:06.650 
develop modern cognitive and enterprise scale applications

19
00:01:07.130 --> 00:01:11.030 
and I'd like to do that by looking at three different parts - first

20
00:01:11.390 --> 00:01:15.100 
I'd like to introduce some basic technologies. What is Docker, what is Kubernetes

21
00:01:16.150 --> 00:01:18.630 
and how do IBM Cloud Private bring it all together.

22
00:01:19.980 --> 00:01:22.620 
What are process and paradigms, why it's a great idea to look

23
00:01:22.620 --> 00:01:27.410 
at micro services and DevOps and I'd also like to do a little reality check

24
00:01:27.710 --> 00:01:29.970 
talking about what we actually do with my team.

25
00:01:30.440 --> 00:01:35.630 
So, by no means this is not a complete list but it should get you started

26
00:01:35.790 --> 00:01:38.650 
and it should provide pointers for further learning.

27
00:01:38.950 --> 00:01:41.410 
There's great stuff out there in the internet that I'll point to

28
00:01:41.640 --> 00:01:43.610 
that, you can then take on and start.

29
00:01:44.660 --> 00:01:47.910 
I'm assuming you are a developer, somewhat seasoned in at least

30
00:01:47.910 --> 00:01:52.770 
one modern programming language, be it go or javascript using

31
00:01:52.770 --> 00:01:53.950 
nodeJS or java.

32
00:01:55.210 --> 00:01:57.710 
So you can take you can take that development knowledge and

33
00:01:57.710 --> 00:02:01.850 
then apply what I'm talking to you today in order to look at

34
00:02:01.850 --> 00:02:04.150 
what it takes to develop modern applications.

35
00:02:05.690 --> 00:02:10.080 
So, starting with containers. What is the problem that is actually solved by containers?

36
00:02:10.640 --> 00:02:13.360 
First of all they make your life as a developer

37
00:02:13.360 --> 00:02:15.130 
easier. So, a yay to that

38
00:02:16.150 --> 00:02:18.980 
and second, in the most simple case it allows you to package

39
00:02:18.980 --> 00:02:22.100 
your application once and then deploy it in very different environments.

40
00:02:22.280 --> 00:02:24.380 
So you can take your code, wrap it all up

41
00:02:24.970 --> 00:02:28.100 
and then run it on your laptop or run it in a production environment in

42
00:02:28.550 --> 00:02:31.050 
almost identical manner and that's really helpful.

43
00:02:32.950 --> 00:02:37.110 
Looking into more details, what containers actually bring us is

44
00:02:38.280 --> 00:02:41.460 
they not only allow you to package your application but they

45
00:02:41.460 --> 00:02:45.850 
also allow you to do that together with the dependencies and then isolate that.

46
00:02:45.990 --> 00:02:47.530 
Isolate the whole runtime.

47
00:02:48.240 --> 00:02:51.530 
Once they are ready, so when you have a container image and

48
00:02:51.530 --> 00:02:54.660 
then you start running it as a running instance,

49
00:02:55.330 --> 00:02:59.160 
they are easy to deploy, they are portable across host operating systems.

50
00:02:59.390 --> 00:03:02.940 
So you can build a linux container with ubuntu and for example

51
00:03:02.940 --> 00:03:05.140 
run it on a record system and vice versa.

52
00:03:06.040 --> 00:03:09.360 
They are created from immutable layered images, so you can really

53
00:03:09.360 --> 00:03:12.450 
build on top of each other and can take what you have and just

54
00:03:12.450 --> 00:03:13.470 
add your stuff on top.

55
00:03:14.470 --> 00:03:17.690 
And they are also isolated from the host of reading systems. So

56
00:03:17.690 --> 00:03:21.370 
they allow you to isolate your application when it runs together

57
00:03:21.370 --> 00:03:24.750 
with other applications, so they don't get like their own little home in space

58
00:03:25.570 --> 00:03:28.380 
and allow you to be independent of what

59
00:03:28.950 --> 00:03:32.230 
other things are running on your computer.

60
00:03:33.870 --> 00:03:36.320 
So, looking at the difference between a virtual machine and

61
00:03:36.320 --> 00:03:37.890 
a container you might think yeah, well,

62
00:03:38.950 --> 00:03:40.970 
we've always had virtual machines what's the point?

63
00:03:41.810 --> 00:03:45.670 
The key difference from my perspective is the virtual machine virtualize the hardware

64
00:03:45.980 --> 00:03:49.020 
whereas the containers actually isolate the process.

65
00:03:49.700 --> 00:03:52.810 
So even though they are very similar,

66
00:03:53.580 --> 00:03:57.430 
the container entities are much smaller than actual virtual machine.

67
00:03:57.770 --> 00:04:01.650 
They are like faster and easier to build and to

68
00:04:01.650 --> 00:04:05.980 
start and to deploy, so you get a lot of benefits from handling perspective.

69
00:04:06.220 --> 00:04:09.040 
Obviously virtual machines are still necessary because somewhere

70
00:04:09.040 --> 00:04:10.940 
you need to run your container host,

71
00:04:11.870 --> 00:04:15.870 
but as a developer I would absolutely favor start working with containers.

72
00:04:17.810 --> 00:04:21.520 
Some advantages and I've kind of already mentioned them - containers

73
00:04:21.520 --> 00:04:24.270 
are totally programming language independent, so you can put

74
00:04:25.230 --> 00:04:29.720 
into a container whatever you can basically install on top of a

75
00:04:30.020 --> 00:04:31.180 
base of rating systems.

76
00:04:31.870 --> 00:04:33.480 
It makes your applications portable,

77
00:04:34.120 --> 00:04:36.680 
it allows you for example to automatically load

78
00:04:37.540 --> 00:04:42.070 
dependencies. So when you build a container you usually do that

79
00:04:42.830 --> 00:04:45.180 
from an existing image, for example from

80
00:04:45.890 --> 00:04:49.460 
a base of rating system image and then you can actually define

81
00:04:49.460 --> 00:04:52.380 
which dependencies you want and then they are automatically loaded

82
00:04:52.710 --> 00:04:57.920 
at startup. It allows you to also share apps more easily and

83
00:04:57.920 --> 00:04:59.680 
to actually speed up your development cycle.

84
00:05:01.260 --> 00:05:04.810 
From an admin operations perspective which is equally as important

85
00:05:04.810 --> 00:05:07.210 
as your Devs perspectives because at some point someone needs

86
00:05:07.210 --> 00:05:10.290 
to run your applications, so provide service to your end customers,

87
00:05:11.260 --> 00:05:13.190 
they allow for standardized environments.

88
00:05:13.940 --> 00:05:18.660 
The administration is really simple because it actually attracts away

89
00:05:18.770 --> 00:05:20.410 
from a specific operating system,

90
00:05:21.390 --> 00:05:23.630 
it allows for very sweet scaling

91
00:05:24.240 --> 00:05:27.450 
through the docker or related container engines

92
00:05:28.770 --> 00:05:32.270 
and it allows you basically to deploy build and run your application with

93
00:05:32.490 --> 00:05:33.850 
almost every infrastructure.

94
00:05:34.470 --> 00:05:38.330 
If you want to try it yourself, I've put in a little link

95
00:05:38.680 --> 00:05:39.940 
at the bottom of this chart

96
00:05:40.050 --> 00:05:46.060 
training.play-with-docker.com/ops-s1-hello/. A super nice introduction that gets

97
00:05:46.060 --> 00:05:48.940 
you started really quickly. You need nothing, just get this started.

98
00:05:48.940 --> 00:05:50.350 
So I would absolutely recommend that.

99
00:05:51.960 --> 00:05:53.450 
Moving over to Kubernetes.

100
00:05:54.280 --> 00:05:57.180 
So now you have your containerized application, great.

101
00:05:57.690 --> 00:06:00.750 
How do you actually deploy it to production? How do you scale

102
00:06:00.750 --> 00:06:04.890 
it and how do you manage it? Especially if it's not just your tiny application but

103
00:06:05.060 --> 00:06:07.730 
it might need another service or work together with

104
00:06:08.350 --> 00:06:11.140 
another application, that's a problem that you kind of have to address.

105
00:06:11.990 --> 00:06:16.510 
And that's what container orchestration tools like Kubernetes do.

106
00:06:16.990 --> 00:06:18.920 
There are other out in the industry but Kubernetes

107
00:06:19.950 --> 00:06:23.230 
at the moment is probably the most dominant one. So if you look

108
00:06:23.230 --> 00:06:24.560 
at that little picture on the right hand

109
00:06:25.080 --> 00:06:28.250 
side you have your little containers and they are all managed by Kubernetes.

110
00:06:29.710 --> 00:06:33.280 
So this picture really shows a super simple analogy for what

111
00:06:33.510 --> 00:06:36.500 
Kubernetes actually does. So at the bottom of your container-

112
00:06:36.500 --> 00:06:40.430 
ship you have your infrastructure. That's all the machines in the ship and

113
00:06:40.840 --> 00:06:45.240 
I'm coming back to IT, that's all your physical and virtual

114
00:06:45.750 --> 00:06:47.560 
infrastructure that provides all

115
00:06:48.450 --> 00:06:51.680 
the basic in order to run your services and those services

116
00:06:51.680 --> 00:06:56.030 
are your little containers they sit on the ship, they are distributed across the ship,

117
00:06:56.710 --> 00:06:58.730 
they might be loaded and offloaded

118
00:06:59.470 --> 00:07:02.240 
and the instance that actually controls that on a container-

119
00:07:02.240 --> 00:07:05.140 
ship is the bridge. It's a white thing there in the middle where

120
00:07:05.230 --> 00:07:07.880 
you have communities on top and that's very similar to what Kubernetes does.

121
00:07:08.660 --> 00:07:11.910 
It really helps you orchestrating all your containers,

122
00:07:12.660 --> 00:07:15.950 
understanding what they should run, when they should run, in

123
00:07:15.950 --> 00:07:18.340 
which context they should run, how they should be isolated, who

124
00:07:18.340 --> 00:07:21.660 
has access to them. So that's a really good analogy.

125
00:07:23.290 --> 00:07:26.770 
If you go to a studio, it's actually an open source project

126
00:07:27.370 --> 00:07:29.120 
and that's the core definition. If you go to that

127
00:07:29.540 --> 00:07:33.990 
also it says it's a system for automating deployment scaling

128
00:07:33.990 --> 00:07:36.730 
and management of containerized applications. And that's really

129
00:07:36.730 --> 00:07:37.490 
the gist of it.

130
00:07:38.880 --> 00:07:42.620 
If you want to learn more there's an awesome video that I've linked here.

131
00:07:42.970 --> 00:07:47.200 
It explains Kubernetes kind of like a children analogy

132
00:07:48.070 --> 00:07:51.570 
with a little animated

133
00:07:53.340 --> 00:07:55.310 
animal. I think it's called Fippi

134
00:07:56.240 --> 00:07:58.790 
and it's the first thing that I ever looked at when I started

135
00:07:58.790 --> 00:08:01.330 
to look at containers and I really enjoyed it so I would recommend that.

136
00:08:01.650 --> 00:08:04.790 
If you're ready for hands on, I would recommend the tutorial at the bottom.

137
00:08:05.100 --> 00:08:09.060 
It's similar to the tutorial. It takes you basically through

138
00:08:10.640 --> 00:08:16.090 
simple steps to get into the whole Kubernetes ecosystem. So go there and try it

139
00:08:16.710 --> 00:08:17.780 
if you have some time.

140
00:08:19.170 --> 00:08:22.790 
Right, so remember we had docker Kubernetes. As we're now moving

141
00:08:22.790 --> 00:08:26.560 
over to cloud private, so you have your containers, you have

142
00:08:26.560 --> 00:08:28.900 
Kubernetes, then you need to manage Kubernetes.

143
00:08:29.360 --> 00:08:32.040 
You need to operate at scale because it's not going to be like

144
00:08:32.570 --> 00:08:35.140 
a single small system, it's probably going to grow over time

145
00:08:35.140 --> 00:08:36.350 
as you get more successful.

146
00:08:37.470 --> 00:08:40.410 
In IBM Cloud Private helps you with that. It does many other great

147
00:08:40.410 --> 00:08:42.550 
things but that's what it is at at the core.

148
00:08:43.820 --> 00:08:47.280 
It also basically brings a cloud native to the enterprise.

149
00:08:47.590 --> 00:08:49.420 
So it helps you as

150
00:08:50.650 --> 00:08:54.590 
as an enterprise when later you work from enterprises

151
00:08:55.720 --> 00:08:57.670 
around innovation because it's

152
00:08:58.370 --> 00:09:01.740 
based on an open data space container platform, it also

153
00:09:02.250 --> 00:09:05.580 
allows you to do platform necessary with cloud foundry and

154
00:09:05.580 --> 00:09:07.810 
it has a very sweet devops tool chain integration.

155
00:09:08.700 --> 00:09:10.870 
Also it's really big and hybrid integration,

156
00:09:11.670 --> 00:09:15.390 
so it allows you to integrate what you have today with all

157
00:09:15.390 --> 00:09:16.670 
the new stuff that you're building

158
00:09:17.510 --> 00:09:21.240 
and secure that access and basically give you a very consistent

159
00:09:21.240 --> 00:09:23.840 
experience across private and public environments.

160
00:09:25.190 --> 00:09:29.150 
It helps you protecting your investment and leveraging that

161
00:09:29.740 --> 00:09:33.610 
because it gives you like a containerized version of most of IBM's middleware

162
00:09:33.930 --> 00:09:37.430 
and very prescriptive guidance to optimize existing workloads

163
00:09:37.430 --> 00:09:40.390 
and it works with existing apps, data skills and infrastructure too.

164
00:09:40.970 --> 00:09:44.770 
Besides that, it's really strong in management and compliance

165
00:09:44.770 --> 00:09:48.070 
so it comes with pre-defined operational services that include

166
00:09:48.070 --> 00:09:51.020 
logging, monitoring, security and gives you the flexibility to

167
00:09:51.020 --> 00:09:53.230 
integrate with your existing tools and processes.

168
00:09:54.860 --> 00:09:59.610 
A quick overview on the solution - at the bottom you have the

169
00:09:59.930 --> 00:10:03.080 
container registration platform that's Kubernetes and docker which

170
00:10:03.080 --> 00:10:05.790 
is a very popular container runtime

171
00:10:06.820 --> 00:10:09.750 
and build system. You have your core operational services in

172
00:10:09.750 --> 00:10:12.540 
the middle that allow you for centralized logging, monitoring,

173
00:10:13.010 --> 00:10:14.830 
metering, security and alerting

174
00:10:15.640 --> 00:10:19.540 
and at the top we have a content catalog for basically IBM brings

175
00:10:19.540 --> 00:10:22.420 
a lot of pre-packaged stuff that you can just take and use

176
00:10:22.620 --> 00:10:24.160 
to develop your applications.

177
00:10:26.030 --> 00:10:28.430 
Again, if you want to learn more you see the pattern by now.

178
00:10:28.920 --> 00:10:31.830 
There's a really nice guided demo on the first link and you

179
00:10:31.830 --> 00:10:35.650 
can actually try it yourself we have a public repo that shows

180
00:10:35.650 --> 00:10:37.090 
you how you can actually install IBM

181
00:10:37.790 --> 00:10:38.960 
Cloud Private on your laptop.

182
00:10:41.040 --> 00:10:44.530 
Okay, coming back to my agenda and looking at

183
00:10:45.100 --> 00:10:48.180 
what we're going to do next. Next thing is micro services.

184
00:10:48.960 --> 00:10:52.840 
So micro services really helps you to develop

185
00:10:53.270 --> 00:10:56.880 
applications that are optimized for cloud native environments.

186
00:10:57.160 --> 00:11:01.210 
It allows you to develop a single application as a suite of small services

187
00:11:01.500 --> 00:11:05.180 
where each one is running in its own process. Remember very

188
00:11:05.180 --> 00:11:08.570 
similar to what we do with containers and those

189
00:11:08.720 --> 00:11:11.490 
small services, they communicate with lightweight mechanisms.

190
00:11:12.010 --> 00:11:14.490 
Usually they are built around business capabilities

191
00:11:15.490 --> 00:11:19.670 
and they hopefully independently deployable by a fully automated

192
00:11:19.670 --> 00:11:21.780 
deployment machinery. That basically means

193
00:11:23.650 --> 00:11:27.710 
you have a little unit, you can throw it out and then your machinery starts

194
00:11:28.310 --> 00:11:31.700 
and deploys it and tests it until it's actually in production.

195
00:11:33.400 --> 00:11:37.860 
So, this is a sample application

196
00:11:38.530 --> 00:11:41.520 
spread out in different micro services basically, where you

197
00:11:41.520 --> 00:11:44.120 
have a couple of UI services, a couple of

198
00:11:45.950 --> 00:11:51.010 
data processing control services and the database services

199
00:11:51.580 --> 00:11:52.840 
as well. And each

200
00:11:54.750 --> 00:11:58.110 
when you look at communication, like let's say, this is a web which is like

201
00:11:58.240 --> 00:12:01.220 
the majority of all applications, if it's not a native

202
00:12:02.760 --> 00:12:06.810 
native mobile app, you have your web app and then it likely

203
00:12:06.810 --> 00:12:10.540 
goes through load balancer then it accesses UI micro servers

204
00:12:10.540 --> 00:12:14.070 
are part of that that will then potentially federate out to

205
00:12:14.070 --> 00:12:17.450 
back-end services and then access to databases. And each of them

206
00:12:18.980 --> 00:12:23.700 
they have a single purpose and the best analogy that I found

207
00:12:23.900 --> 00:12:27.410 
from my perspective is they are very like unix tools. They do

208
00:12:27.410 --> 00:12:30.210 
one thing and they do that one right and they don't look at

209
00:12:30.920 --> 00:12:32.990 
all the other capabilities

210
00:12:33.470 --> 00:12:39.570 
of your total application but they really focus on one particular thing.

211
00:12:40.220 --> 00:12:41.980 
And if we go back to that picture

212
00:12:43.290 --> 00:12:47.070 
we have for example a shopping cart and a service

213
00:12:47.520 --> 00:12:51.080 
that does all the orders, a service that takes care for all the customers and

214
00:12:51.260 --> 00:12:53.190 
the order service doesn't really have to know

215
00:12:54.020 --> 00:12:56.610 
all the details of the customer service but if it needs to

216
00:12:56.610 --> 00:12:59.500 
know something it can call that and that's one of those paradigms

217
00:12:59.500 --> 00:13:00.500 
that are really important.

218
00:13:03.460 --> 00:13:08.720 
Remember, when I gave the definition, I talked about like a fully automated deployment machinery

219
00:13:09.020 --> 00:13:13.170 
and what you really need here is infrastructure automation and continuous delivery.

220
00:13:13.410 --> 00:13:16.370 
So you have to have automated tests that give you a lot of

221
00:13:16.370 --> 00:13:20.230 
confidence that your code actually runs. And if you haven't looked at

222
00:13:20.450 --> 00:13:22.930 
automated test cases when developing I would recommend you

223
00:13:22.930 --> 00:13:24.080 
to actually do that right now.

224
00:13:25.300 --> 00:13:28.490 
And then similar to add you have to automate your deployment

225
00:13:28.820 --> 00:13:31.330 
if you're currently developing an application and every time

226
00:13:31.330 --> 00:13:35.440 
you want to test it you have to copy some files somewhere manually

227
00:13:35.440 --> 00:13:37.990 
and then run a script to start it all up, that's not a great

228
00:13:37.990 --> 00:13:39.470 
idea in an enterprise environment.

229
00:13:40.720 --> 00:13:44.830 
You have to be able to write a line on a change side of a couple

230
00:13:44.830 --> 00:13:48.130 
of lines of code, commit that to a version control repository

231
00:13:48.130 --> 00:13:51.250 
and then the machinery has to basically take that change

232
00:13:51.660 --> 00:13:54.900 
deploy it to an environment, run a suite of tests if they are

233
00:13:54.900 --> 00:13:57.930 
good, promote it to the next environment and I'll talk about that

234
00:13:58.970 --> 00:13:59.930 
a bit in more detail.

235
00:14:02.990 --> 00:14:07.060 
Moving over to devops, because that's very similar to

236
00:14:07.990 --> 00:14:11.810 
automated deployment machinery. At least that's one of the cornerstones of it,

237
00:14:12.680 --> 00:14:14.700 
what does devops actually mean? So that's

238
00:14:15.160 --> 00:14:19.350 
the first stuff that I talked about is more like what you do as a developer

239
00:14:19.760 --> 00:14:23.240 
and now looking at devops actually means how do you collaborate

240
00:14:23.700 --> 00:14:26.750 
with people that put your application in production. And you

241
00:14:26.750 --> 00:14:29.910 
could do that yourself if you follow the you build

242
00:14:29.910 --> 00:14:34.610 
it you run it paradigm but sometimes you might have very close and adjacent teams.

243
00:14:35.540 --> 00:14:39.290 
That's basically where the devops movement came up. So mostly

244
00:14:39.290 --> 00:14:42.690 
this is a culture and or an organizational philosophy

245
00:14:43.310 --> 00:14:46.290 
of how you actually collaborate between people that mostly

246
00:14:46.290 --> 00:14:48.240 
develop code and some that mostly

247
00:14:48.870 --> 00:14:52.290 
operate an application? That's like the way of working and it

248
00:14:52.290 --> 00:14:55.450 
also there are a couple of models that help you looking at that.

249
00:14:56.690 --> 00:15:01.270 
So, there is no single right way to do that but there are wrong

250
00:15:01.270 --> 00:15:03.660 
ways and I'm going to show you some of those wrong ways. So,

251
00:15:03.660 --> 00:15:06.920 
this is really bad. Having two like totally separate teams that

252
00:15:06.930 --> 00:15:10.610 
don't interact and talk to each other that's what we used to

253
00:15:10.610 --> 00:15:13.580 
do until like a couple of years ago where the dev team would

254
00:15:13.580 --> 00:15:16.430 
always say, well, but the upside is that they always read our

255
00:15:16.430 --> 00:15:19.690 
application and they are super strict and they don't want to apply our changes

256
00:15:19.960 --> 00:15:23.590 
where the Ops team would say hey but the developers have no clue

257
00:15:23.720 --> 00:15:27.310 
what's going on in production and they always try to reign in

258
00:15:27.310 --> 00:15:30.280 
production. So there was a lot of blaming going on. So this is

259
00:15:30.280 --> 00:15:33.840 
this is bad don't do that. This is also bad if you want to start

260
00:15:34.510 --> 00:15:37.490 
establishing devops and then you build like a completely separate team

261
00:15:37.670 --> 00:15:41.490 
that do not talk that much to the dev or the ops team, not going to work.

262
00:15:41.850 --> 00:15:43.770 
Obviously there are many flavors of that.

263
00:15:44.300 --> 00:15:48.970 
So don't do the two circles that are not like

264
00:15:49.840 --> 00:15:51.920 
interfering with each other, what you want is this.

265
00:15:52.520 --> 00:15:54.790 
You want true collaboration between the teams and you could

266
00:15:54.790 --> 00:15:58.390 
do that either by having like dedicated people in each team

267
00:15:58.390 --> 00:16:00.050 
that work closely together

268
00:16:00.680 --> 00:16:03.630 
to have shared responsibilities. You could actually also merge

269
00:16:03.630 --> 00:16:07.910 
those two bubbles, so you have one one close team, I said it already

270
00:16:08.490 --> 00:16:11.810 
do you build it you run it, but keep in mind when you

271
00:16:11.810 --> 00:16:14.860 
look at teams, look at the collaboration between

272
00:16:15.410 --> 00:16:18.730 
the people that write the code and the people that put it in production.

273
00:16:20.530 --> 00:16:24.640 
So talking about continuous integration delivery and deployment

274
00:16:25.280 --> 00:16:28.050 
you might have heard that before I don't want to dive in like

275
00:16:28.050 --> 00:16:30.440 
to too much detail, but just give you a quick overview.

276
00:16:31.430 --> 00:16:35.570 
Again coming back to like the fully automated deployment machinery that I

277
00:16:35.690 --> 00:16:39.470 
mentioned earlier those are the stages that will help you to do that.

278
00:16:39.890 --> 00:16:45.240 
So starting with continuous build on top of each other, so starting with continuous integration

279
00:16:46.060 --> 00:16:49.520 
what that really does is it allows you to integrate your code

280
00:16:49.550 --> 00:16:53.480 
to a shared repository at least daily and I would say daily is even

281
00:16:53.820 --> 00:16:58.840 
not enough in some cases. And I said that already you develop your code

282
00:16:59.060 --> 00:17:02.320 
on your left or locally and then you obviously write tests

283
00:17:02.720 --> 00:17:05.280 
that make sure that the code actually does what you think it should do,

284
00:17:05.610 --> 00:17:09.080 
then you commit that code to sent repo and then the machinery

285
00:17:09.080 --> 00:17:13.610 
starts. So it takes that code test runs a first suite of unit tests

286
00:17:13.940 --> 00:17:17.830 
then deploys that for example to first test or staging environment,

287
00:17:17.830 --> 00:17:20.840 
runs a test there and then subsequently promotes that.

288
00:17:21.260 --> 00:17:22.560 
Why would you want to do that?

289
00:17:23.330 --> 00:17:25.810 
Because you should have smaller sizes of change set

290
00:17:26.210 --> 00:17:29.580 
that then lead to easier integration. The smaller the change,

291
00:17:30.270 --> 00:17:32.960 
the more control you have and the more you see what the impact

292
00:17:33.190 --> 00:17:37.160 
is. It also allows you to catch issues fast and then hopefully

293
00:17:37.160 --> 00:17:39.560 
deliver software more rapidly because that's what this is all

294
00:17:39.560 --> 00:17:42.510 
about. You want to deliver value to your customers as fast as you can.

295
00:17:43.950 --> 00:17:47.140 
Moving to continuous delivery is a bit further than that one because

296
00:17:48.060 --> 00:17:53.130 
in theory it basically says that you should have every change to the system

297
00:17:53.390 --> 00:17:57.920 
in a releasable state. So every change that you make, every commit

298
00:17:58.660 --> 00:18:04.100 
that makes it for example to your central master branch in your repository

299
00:18:04.450 --> 00:18:06.810 
should be deployable to production.

300
00:18:07.790 --> 00:18:12.290 
That means what it adds to continuous integration is basically

301
00:18:12.290 --> 00:18:15.710 
all of these completely automated deployments in between the different

302
00:18:16.070 --> 00:18:21.240 
stages. And last continuous deployment basically says

303
00:18:21.240 --> 00:18:23.460 
okay the second you can read a line of code

304
00:18:24.150 --> 00:18:27.250 
the whole system will make sure that it actually ends up in production.

305
00:18:27.670 --> 00:18:30.980 
So if you look at the little graphic that

306
00:18:31.610 --> 00:18:34.430 
you see in the references someone else drew it and it's really good.

307
00:18:35.000 --> 00:18:39.640 
It basically shows that the last stage to production for continuous delivery

308
00:18:39.810 --> 00:18:43.090 
it's manual for continuous deployment it goes automated. And

309
00:18:43.090 --> 00:18:45.650 
not every team wants that, my team for example we don't do that.

310
00:18:46.030 --> 00:18:48.240 
We do continuous delivery but then we

311
00:18:49.180 --> 00:18:52.750 
we have like a manual quality gauge before we actually release

312
00:18:52.750 --> 00:18:57.120 
into production and that's fine. Other companies don't do that. It depends

313
00:18:57.300 --> 00:19:00.180 
sometimes also on regulatory controls where you can do that

314
00:19:00.180 --> 00:19:01.520 
or not, in our case we can't.

315
00:19:03.270 --> 00:19:08.070 
Okay, last but not least, a little reality chec. What

316
00:19:08.070 --> 00:19:08.980 
does my team do?

317
00:19:10.880 --> 00:19:13.640 
So I'd like to talk a little bit about the applications we

318
00:19:13.640 --> 00:19:17.040 
develop, our team structures how we use open source technology,

319
00:19:17.940 --> 00:19:21.670 
how we leverage IBM Cloud Private and what we could do for example to

320
00:19:21.670 --> 00:19:23.170 
run this also in power systems using docker.

321
00:19:24.150 --> 00:19:26.800 
First of all,

322
00:19:28.900 --> 00:19:30.850 
my team is responsible for IBM

323
00:19:32.070 --> 00:19:37.420 
automation, that's a software as a service solution that's also

324
00:19:37.420 --> 00:19:43.080 
locally available that allows you basically to automate operational instructions for your

325
00:19:43.360 --> 00:19:46.530 
operations team, starting from manual moving over to somewhat

326
00:19:46.530 --> 00:19:50.350 
semi automated instructions to like a fully automated reaction to an incident.

327
00:19:51.580 --> 00:19:54.740 
And this IBM automation plays part like in a bigger game.

328
00:19:55.380 --> 00:20:00.130 
There are adjacent technologies or solutions like alert notification

329
00:20:00.320 --> 00:20:04.140 
or cloud event management and I'm partially responsible for some areas there.

330
00:20:04.620 --> 00:20:08.280 
So we work in a bigger team, but my core team

331
00:20:08.750 --> 00:20:11.010 
we have three micro services they are building

332
00:20:11.660 --> 00:20:15.730 
using a CouchDB, and the UI

333
00:20:17.030 --> 00:20:19.500 
is angular.js. We're using Jenkins and Artifactory

334
00:20:20.090 --> 00:20:24.070 
as our basically automated deployment machinery.

335
00:20:24.680 --> 00:20:28.380 
We deploy into two environments - one is IBM Cloud Foundry

336
00:20:28.380 --> 00:20:31.940 
Services, Cloudant, so when we deploy to cloud, when it's

337
00:20:31.940 --> 00:20:34.940 
a software as a service application we're using cloudant, which

338
00:20:35.330 --> 00:20:38.570 
covers plus a little bit more and then we're developing on

339
00:20:38.570 --> 00:20:42.050 
a platform as a service offering from IBM that's based on cloud foundry.

340
00:20:43.050 --> 00:20:44.100 
When we do this locally

341
00:20:44.900 --> 00:20:49.090 
we basically take our code, the one the same exactly the same code that we

342
00:20:49.270 --> 00:20:51.780 
deploy to cloud, we wrap it up in a container

343
00:20:52.370 --> 00:20:54.050 
and then run it on IBM cloud private.

344
00:20:55.090 --> 00:20:58.610 
We have developers on two sites and we have, I said that already

345
00:20:58.610 --> 00:21:01.680 
separate responsibilities for production environments for

346
00:21:02.240 --> 00:21:05.690 
regulatory controls and also because we have to do twenty-four seven support

347
00:21:06.060 --> 00:21:07.930 
and you don't want like a local team to

348
00:21:08.380 --> 00:21:11.150 
go through shifts as we are like a big company and can actually

349
00:21:11.150 --> 00:21:13.940 
afford to have teams in different different spaces.

350
00:21:15.960 --> 00:21:18.810 
I brought some screenshots of some of the tools that we have.

351
00:21:19.170 --> 00:21:22.040 
So, this is our app monitor. It's like a super small homegrown

352
00:21:22.040 --> 00:21:25.670 
tool that we built in order to keep control of our deployments

353
00:21:25.910 --> 00:21:29.290 
and you see like we have several stages as we move over to

354
00:21:29.290 --> 00:21:31.070 
production. Production is not on that picture,

355
00:21:31.810 --> 00:21:36.050 
but edge is basically when my developers decide that

356
00:21:37.270 --> 00:21:40.470 
they have a local feature ready, they can integrate that into

357
00:21:40.470 --> 00:21:42.920 
a branch and then it's automatically deployed to edge.

358
00:21:43.960 --> 00:21:48.480 
And on edge the test cases are run and you see they're like different services.

359
00:21:49.580 --> 00:21:51.750 
remember three services that I talked about earlier

360
00:21:52.280 --> 00:21:55.260 
and then it moves over to staging, if all the tests go

361
00:21:55.260 --> 00:21:58.540 
green and then at some point it moves over to integration and

362
00:21:58.540 --> 00:22:01.500 
that's the last stage before we actually move over to production.

363
00:22:04.190 --> 00:22:06.140 
This is a screenshot of our

364
00:22:07.160 --> 00:22:09.470 
live Jenkin's

365
00:22:11.100 --> 00:22:14.380 
instance. So you see not all the time everything goes well. We

366
00:22:14.380 --> 00:22:18.100 
have areas where some of the tests actually fail and that's ok but

367
00:22:18.230 --> 00:22:20.670 
it stops at a certain gate. So we know okay alright

368
00:22:21.710 --> 00:22:24.920 
we have to improve upon here and yeah we probably shouldn't

369
00:22:24.920 --> 00:22:28.310 
have four failing builds after right after each

370
00:22:28.310 --> 00:22:31.100 
other but that sometimes happens and we're transparent about

371
00:22:31.100 --> 00:22:34.580 
that because we know we're going to catch that before it actually moves into production.

372
00:22:36.070 --> 00:22:39.150 
That's like a sample picture

373
00:22:40.850 --> 00:22:44.520 
of how some of our deployments move. So that's from

374
00:22:44.940 --> 00:22:47.130 
basically moving from the very first

375
00:22:47.810 --> 00:22:53.040 
commit of a code over to like several test stages into our

376
00:22:53.040 --> 00:22:56.070 
search environment and then to the end and from there another

377
00:22:56.070 --> 00:22:58.820 
automated pipeline picks up. So we have basically split up our

378
00:22:58.820 --> 00:23:00.440 
pipelines into smaller chunks.

379
00:23:02.410 --> 00:23:06.810 
This is a little view on what we actually do from a GitHub perspective.

380
00:23:07.060 --> 00:23:11.490 
So what you can see here, we do code reviews. So before actually

381
00:23:11.490 --> 00:23:14.250 
a change is merged into our master,

382
00:23:15.640 --> 00:23:19.290 
another person should have a look so we have like the four eye principle and

383
00:23:19.410 --> 00:23:22.630 
to actually ensure quality. And then we also have automated

384
00:23:22.630 --> 00:23:25.730 
checks before you can actually be promoted and those automated checks

385
00:23:26.280 --> 00:23:29.490 
are actually all the test cases that are run. So it will not be possible

386
00:23:29.690 --> 00:23:32.940 
that a code makes it into production that is not properly and thoroughly tested.

387
00:23:35.870 --> 00:23:38.180 
Some last words on open source, so we're

388
00:23:38.730 --> 00:23:41.320 
in general IBM is really beg in open source. That's not always known

389
00:23:41.920 --> 00:23:44.410 
in the public but if you want to have a look at what

390
00:23:45.160 --> 00:23:49.560 
some of the great things that we do, go to developer.ibm.com/open

391
00:23:49.560 --> 00:23:50.840 
and then you'll find that we're actually

392
00:23:50.840 --> 00:23:55.300 
really involved in very many various and diverse open source project.

393
00:23:55.810 --> 00:23:58.120 
For our project alone we use a lot of open source.

394
00:23:58.590 --> 00:24:01.570 
We have more than ninety npm modules as we're developing a node

395
00:24:01.810 --> 00:24:04.510 
and we are actually responsible for what we deliver. So we just

396
00:24:04.510 --> 00:24:07.320 
can't grab a module from the internet and then send it to our

397
00:24:07.320 --> 00:24:09.510 
customers and go yay it's going to be fine.

398
00:24:10.340 --> 00:24:11.970 
We have to scan that for security,

399
00:24:12.920 --> 00:24:17.300 
we have to maintain that open source libraries life cycle because sometimes

400
00:24:17.570 --> 00:24:20.510 
those modules tend not to be continued anymore and we have

401
00:24:20.510 --> 00:24:23.210 
to make a decision on what we do, that what we do with that

402
00:24:23.210 --> 00:24:24.820 
because either we just

403
00:24:25.990 --> 00:24:28.930 
try to maintain ourself which we rarely do, what we have to do

404
00:24:29.100 --> 00:24:31.960 
or we have to move to actually another open source module.

405
00:24:32.750 --> 00:24:36.480 
We also have to ensure vitality before we actually

406
00:24:36.680 --> 00:24:39.500 
grab a module, so we can't just take any random module out there

407
00:24:39.810 --> 00:24:42.260 
and we'll have a look at how many times it's been downloaded,

408
00:24:42.260 --> 00:24:45.140 
how many major releases that we have, when was the last release,

409
00:24:45.400 --> 00:24:48.990 
and how many contributers and maintainers are there and how many pull requests

410
00:24:49.280 --> 00:24:52.690 
to make sure it's really a vivid thing because if it's a super

411
00:24:52.690 --> 00:24:55.260 
small thing we might actually build it ourselves so we have

412
00:24:55.260 --> 00:24:56.040 
better control over it.

413
00:24:58.200 --> 00:25:02.340 
Alright before I call it, obviously this technology also allows us

414
00:25:03.130 --> 00:25:05.970 
to deploy two like different environments. So if we wanted to

415
00:25:05.970 --> 00:25:10.070 
for example deploy to a power environment we would have to build docker containers

416
00:25:10.460 --> 00:25:13.570 
that support the power infrastructure but everything else would actually

417
00:25:13.670 --> 00:25:18.220 
stay the same because we have all of this automated machinery in place

418
00:25:18.790 --> 00:25:22.680 
that allows us to be very flexible to what we do. Yes, it's always work,

419
00:25:23.480 --> 00:25:27.200 
but it's under control and it feels very safe. And last but

420
00:25:27.200 --> 00:25:29.580 
not least I'd like to thank two colleagues Ralf and Simon

421
00:25:29.660 --> 00:25:32.060 
for contributions and feedback. So I haven't done all of this

422
00:25:32.060 --> 00:25:34.370 
alone but they really helped me with prepping this talk.

423
00:25:35.490 --> 00:25:38.050 
And yeah I hope I gave you a good overview on

424
00:25:38.850 --> 00:25:41.520 
how to develop applications. I wanted to give you some pointers

425
00:25:42.260 --> 00:25:46.550 
across different areas that help you preparing yourself for

426
00:25:47.490 --> 00:25:51.360 
when leaving university and then actually moving over

427
00:25:51.970 --> 00:25:54.510 
to professional software development which I really hope you

428
00:25:54.510 --> 00:25:55.650 
do, because it's great fun

429
00:25:56.790 --> 00:26:00.620 
and I hope this helped and I'd like to thank you for your

430
00:26:01.960 --> 00:26:03.920 
attention and wish you a great time.
