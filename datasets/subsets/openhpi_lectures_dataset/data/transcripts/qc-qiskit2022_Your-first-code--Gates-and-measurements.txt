WEBVTT

1
00:00:01.020 --> 00:00:06.200 
welcome to the next video in this video we will finally get into the

2
00:00:06.710 --> 00:00:09.520 
Qiskit code and we will do our first

3
00:00:10.270 --> 00:00:15.180 
Qiskit program we will learn about how to build circuits what are

4
00:00:15.180 --> 00:00:19.880 
the different elements that we have to build them also to understand them

5
00:00:20.410 --> 00:00:28.190 
and also about the different gates and how to measure the experiments that

6
00:00:28.410 --> 00:00:30.050 
that we will do with the circuits

7
00:00:31.280 --> 00:00:34.870 
so let's go back to our platform

8
00:00:35.880 --> 00:00:42.510 
as i mentioned in a previous video it's also possible to work locally

9
00:00:42.880 --> 00:00:45.760 
so as you already know

10
00:00:46.610 --> 00:00:50.420 
we will be using the IBM Quantum Lab which looks like

11
00:00:52.060 --> 00:00:57.860 
Qubit Aer lab and it's a place where Qiskit is already installed but yes

12
00:00:58.140 --> 00:01:03.560 
before going there we are going to briefly see how Qiskit could be installed

13
00:01:04.010 --> 00:01:06.770 
so for that i'm going to open another

14
00:01:08.280 --> 00:01:14.150 
window and let's check how we will install it locally

15
00:01:15.440 --> 00:01:21.190 
so we will go to the documentation and we will click on getting started

16
00:01:23.390 --> 00:01:27.490 
here there are different options to start on the cloud it's

17
00:01:27.490 --> 00:01:32.930 
the one that we're going to do in this video you can also install it from source

18
00:01:33.370 --> 00:01:35.910 
but we're recommended

19
00:01:37.040 --> 00:01:41.630 
installing it with Anaconda so the first step would

20
00:01:41.630 --> 00:01:44.530 
be installing Anaconda then creating

21
00:01:45.190 --> 00:01:48.100 
a Conda environment only with Python installed

22
00:01:48.640 --> 00:01:51.410 
and in that Conda environment

23
00:01:52.050 --> 00:01:57.610 
we would install Qiskit the way to install it is just this line of code

24
00:01:58.100 --> 00:02:03.050 
"pip install qiskit" and then depending on the kind of

25
00:02:05.090 --> 00:02:06.660 
operating system that you have

26
00:02:07.350 --> 00:02:10.860 
and depending on the tools that you might want to use

27
00:02:11.420 --> 00:02:15.520 
you might for example install some extra

28
00:02:16.210 --> 00:02:19.370 
modules such as the visualization tools

29
00:02:20.060 --> 00:02:23.040 
for that you should "pip install qiskit[visualization]"

30
00:02:24.270 --> 00:02:29.290 
in terms of which platform support Qiskit you can

31
00:02:29.830 --> 00:02:33.930 
use it in different platforms so

32
00:02:35.080 --> 00:02:37.750 
you can use it in linux

33
00:02:38.380 --> 00:02:41.560 
you can use it in macOS or in Windows

34
00:02:42.860 --> 00:02:47.440 
and here you have all the information about the compatibility

35
00:02:47.440 --> 00:02:51.130 
and the versions that you should be using

36
00:02:52.010 --> 00:02:54.950 
and with which Qiskit is compatible

37
00:02:56.290 --> 00:03:00.150 
so everything is listed here as you see

38
00:03:00.920 --> 00:03:06.000 
it's not a difficult installation but for the purpose

39
00:03:06.000 --> 00:03:10.100 
of this demo we will be using the platform where everything

40
00:03:10.110 --> 00:03:11.040 
is really set up

41
00:03:12.810 --> 00:03:16.140 
so let's go back to the platform and launch the Quantum Lab

42
00:03:22.120 --> 00:03:23.630 
so now we're back in the

43
00:03:24.490 --> 00:03:29.890 
IBM Quantum Lab as you might remember it looks like a JupyterLab and we

44
00:03:29.890 --> 00:03:34.710 
can create different Jupyter Notebooks and we have an environment where

45
00:03:34.820 --> 00:03:36.380 
Qiskit is already installed

46
00:03:37.100 --> 00:03:40.970 
so let's first have a look at all the things that we have available

47
00:03:41.120 --> 00:03:44.170 
when you open it for the first time by default you will

48
00:03:44.170 --> 00:03:48.690 
be seen two folders the Qiskit textbook and the Qiskit tutorials

49
00:03:49.010 --> 00:03:54.410 
so those are two folders where you have the Jupyter version

50
00:03:54.410 --> 00:03:58.340 
of the contents of both the tutorials and the textbook and

51
00:03:58.500 --> 00:04:02.760 
it's really handy because you can actually execute the code and you can

52
00:04:03.230 --> 00:04:08.650 
also edit it in the same notebook and you can also use it as

53
00:04:08.650 --> 00:04:13.790 
a draft maybe if you are going to build your own tutorial or you're working

54
00:04:14.010 --> 00:04:18.990 
in some code there is reusable from a tutorial you can have

55
00:04:19.360 --> 00:04:23.220 
directly the Jupyter version inside these two folders

56
00:04:23.880 --> 00:04:29.780 
you can also upload your own files create your own folders

57
00:04:30.480 --> 00:04:34.490 
for this concrete workshop we have created the

58
00:04:34.920 --> 00:04:40.110 
Qiskit intro you will have all these files available in a GitHub-repo

59
00:04:40.110 --> 00:04:46.330 
so you are invited to download it and code along or if you are

60
00:04:47.100 --> 00:04:50.660 
right now you cannot code or for some reason you are going to

61
00:04:50.860 --> 00:04:56.150 
focus on looking at the screen you can always just follow what i'm doing

62
00:04:56.840 --> 00:05:02.000 
so the first for this lesson we're going to be using "your_first_code"

63
00:05:02.410 --> 00:05:06.580 
this Jupyter Notebook here i'm going to make this

64
00:05:08.300 --> 00:05:13.350 
smaller and let's get it started

65
00:05:14.040 --> 00:05:18.190 
so in the first line of code the first thing we

66
00:05:18.190 --> 00:05:23.710 
have to do is import IBMQ which is the provider where all

67
00:05:23.710 --> 00:05:28.980 
the bargains are contained and also the high performance computing

68
00:05:28.980 --> 00:05:32.700 
simulators in the cloud and therefore let's execute it

69
00:05:33.340 --> 00:05:38.280 
and we say to load the account in this case it's telling me

70
00:05:38.280 --> 00:05:41.310 
that the credentials are already in use

71
00:05:42.750 --> 00:05:47.320 
because i have already executed it but for you you're doing

72
00:05:47.320 --> 00:05:51.080 
it for the first time you should execute this

73
00:05:52.740 --> 00:05:53.650 
for the first

74
00:05:54.930 --> 00:05:56.090 
and in the beginning

75
00:05:56.830 --> 00:05:58.490 
of any kind of

76
00:05:59.230 --> 00:06:03.640 
story so this is the way we tell

77
00:06:04.290 --> 00:06:07.590 
the platform that it says that we have an account

78
00:06:07.990 --> 00:06:12.270 
because we are already inside our account we are logged in

79
00:06:12.530 --> 00:06:15.820 
it's not asking us for further identification

80
00:06:16.340 --> 00:06:21.070 
if we were working locally we would need a token that maybe

81
00:06:21.070 --> 00:06:25.480 
you are already saw it's a whether in you can check it here

82
00:06:25.520 --> 00:06:27.010 
i'm going to open it in a new tab

83
00:06:29.250 --> 00:06:32.820 
it's directly here you can copy it or if for some reason is

84
00:06:32.820 --> 00:06:36.060 
not working anymore you can regenerate it

85
00:06:36.750 --> 00:06:44.230 
and you can also look at it here in account settings you will find your token

86
00:06:44.910 --> 00:06:48.790 
but that's only if you have installed Qiskit locally so let's go

87
00:06:48.790 --> 00:06:53.310 
back to the platform here it already knows who we are

88
00:06:53.760 --> 00:06:58.980 
and now that we have uploaded our account let`s list

89
00:06:58.980 --> 00:07:01.000 
list all the providers that we have access to

90
00:07:01.420 --> 00:07:05.570 
here you can see that this is the list of providers that

91
00:07:06.320 --> 00:07:10.870 
appeared without the locker symbol and also the simulators of course

92
00:07:12.250 --> 00:07:16.180 
so first thing we are going to do is creating the same circuit

93
00:07:16.180 --> 00:07:19.580 
that we created with composer but this time with Qiskit code

94
00:07:20.080 --> 00:07:25.140 
so first thing we need to do is importing from Qiskit the class QuantumCircuit

95
00:07:25.470 --> 00:07:29.710 
and we will use that class to create a circuit we give it the name circuit

96
00:07:30.090 --> 00:07:33.420 
and we say that it should have two Qubits

97
00:07:34.250 --> 00:07:39.040 
then we will apply a Hadamard gate to the Qubit in position zero

98
00:07:39.400 --> 00:07:45.780 
and CNOT gate to the two Qubits

99
00:07:47.330 --> 00:07:50.620 
if we only executed this we will

100
00:07:51.030 --> 00:07:55.030 
obtain a circuit with no classical registers because we have

101
00:07:55.030 --> 00:07:58.260 
only said how many registers we have but

102
00:07:58.700 --> 00:08:02.700 
since we are going to apply measure_all() it's going to automatically

103
00:08:02.700 --> 00:08:06.610 
add two classical registers and also a measurement to all those

104
00:08:06.610 --> 00:08:07.780 
Qubits in the circuit

105
00:08:08.650 --> 00:08:10.030 
so let's execute it

106
00:08:11.410 --> 00:08:15.870 
and let's use .draw() in order to

107
00:08:16.520 --> 00:08:20.270 
paint to draw the distribute that we have already

108
00:08:21.820 --> 00:08:25.520 
and as you probably have recognized it's the one of the circuits

109
00:08:25.520 --> 00:08:28.180 
that creates one of the four bell states

110
00:08:29.500 --> 00:08:34.810 
it also adds a barrier but this is for a visualization purposes

111
00:08:35.180 --> 00:08:38.510 
so that you can see all the measurements aligned

112
00:08:42.910 --> 00:08:48.190 
and now we're going to do the same thing that we did before so for that

113
00:08:48.530 --> 00:08:54.090 
we're going to import the Backend Aer because we if you remember

114
00:08:54.090 --> 00:08:55.650 
we use the qasm simulator

115
00:08:56.350 --> 00:09:00.610 
first we say which is the backend that we are going to use in this case

116
00:09:00.850 --> 00:09:04.520 
we use a general one and it will automatically know

117
00:09:05.310 --> 00:09:09.570 
depending on what we do with that circuit it will automatically select

118
00:09:09.850 --> 00:09:13.300 
the appropriate one in this case it will be the qasm simulator because

119
00:09:13.550 --> 00:09:17.680 
we are telling it to run it and to store the result

120
00:09:18.290 --> 00:09:21.480 
from the result we will get the counts which is basically a

121
00:09:21.480 --> 00:09:25.050 
dictionary that contains how many times we saw each of the states

122
00:09:25.350 --> 00:09:26.490 
and we will print them

123
00:09:28.040 --> 00:09:32.870 
so we so what we were expecting a good way to

124
00:09:32.870 --> 00:09:35.220 
represent that graphically is a histogram

125
00:09:37.630 --> 00:09:41.790 
but another thing that might be interesting for us is

126
00:09:43.190 --> 00:09:49.520 
is deriving

127
00:09:49.520 --> 00:09:52.080 
the equivalent unitary to our circuit

128
00:09:53.120 --> 00:09:56.840 
so there is another simulator which is called

129
00:09:56.840 --> 00:09:58.690 
the unitary_simulator and

130
00:09:59.460 --> 00:10:04.240 
for instance if we build this circuit where you see we only have

131
00:10:04.590 --> 00:10:08.290 
a unitary we can use this backend

132
00:10:09.580 --> 00:10:14.220 
in order to compute the equivalent unitary to the circuit

133
00:10:14.760 --> 00:10:17.220 
in this case it was very easy because it was

134
00:10:18.080 --> 00:10:22.990 
a single gate so it corresponds to the gate but if we had more

135
00:10:23.530 --> 00:10:28.290 
unitary operations it will give us the equivalent of all of these

136
00:10:28.840 --> 00:10:32.630 
operations there are

137
00:10:33.550 --> 00:10:37.530 
all the other gates that you can try here i have let

138
00:10:37.530 --> 00:10:40.550 
some examples for you to try them if you want

139
00:10:41.240 --> 00:10:46.010 
and basically you with all of them you can come up with all

140
00:10:46.010 --> 00:10:49.210 
the combinations that you might need for your circuits

141
00:10:49.860 --> 00:10:53.010 
and eventually for your quantum algorithms

142
00:10:54.530 --> 00:10:56.580 
so we have seen a single qubit gate

143
00:10:57.450 --> 00:11:02.230 
which is the Hadamard gate and we have seen also two qubit gate

144
00:11:02.230 --> 00:11:05.520 
which is the CNOT gate there are also other

145
00:11:06.130 --> 00:11:10.780 
multi qubit gates and one thing to take into account is the way

146
00:11:10.960 --> 00:11:14.760 
Qiskit orders basis vectors because it will affect on the

147
00:11:14.760 --> 00:11:19.870 
way we read the results and also on the way that the matrices are represented

148
00:11:20.310 --> 00:11:24.290 
so and why do we

149
00:11:24.820 --> 00:11:28.370 
note that because it's not the usual way

150
00:11:28.880 --> 00:11:34.880 
that physicists do it so you can read here how it's done but basically the

151
00:11:35.920 --> 00:11:38.830 
qubit on top is the one

152
00:11:39.510 --> 00:11:46.470 
on the right and the way they are ordered is from the

153
00:11:46.470 --> 00:11:50.650 
most significant bit to the least significant bit so please take this

154
00:11:51.160 --> 00:11:53.550 
into account

155
00:11:54.670 --> 00:11:58.990 
when measuring the results when reading the results

156
00:12:00.770 --> 00:12:07.760 
cool so one thing that is affected is for instance here if we print

157
00:12:08.150 --> 00:12:12.300 
the matrix associated to the Cx NOT as you see is not the

158
00:12:12.300 --> 00:12:17.820 
same that Elisa showed but this is because of the basis ordering

159
00:12:19.950 --> 00:12:23.730 
ok you can check all the gates there is a tutorial

160
00:12:24.910 --> 00:12:28.910 
for all of them in case you have some questions about the syntax

161
00:12:29.500 --> 00:12:35.300 
you can check it there and now we are going to move

162
00:12:35.340 --> 00:12:39.670 
to other properties we can explore in a circuit

163
00:12:40.150 --> 00:12:43.780 
so let's build a more interesting circuit and

164
00:12:44.190 --> 00:12:49.530 
when we are doing circuit optimization it's important to have

165
00:12:49.530 --> 00:12:51.950 
some control about the number of gates that we

166
00:12:52.520 --> 00:12:55.970 
get of each time because since we are working with noise

167
00:12:56.410 --> 00:12:57.700 
with noisy devices

168
00:12:59.140 --> 00:13:04.510 
it's better to come up with circuit that has a

169
00:13:06.320 --> 00:13:08.130 
that has

170
00:13:10.020 --> 00:13:15.310 
a smaller number of gates and concretely it's important to

171
00:13:15.310 --> 00:13:19.870 
reduce the number of CNOTs because they are the ones that introduce

172
00:13:20.200 --> 00:13:26.230 
more errors so for that we also have for this kind of work

173
00:13:26.590 --> 00:13:29.870 
of preprocessing that we do before even executed our circuit

174
00:13:30.210 --> 00:13:34.740 
there are some tools that we can use to explore how our circuit looks like

175
00:13:35.060 --> 00:13:38.090 
so we can check what the width is

176
00:13:38.710 --> 00:13:41.640 
we can check the number of qubits that we are using

177
00:13:42.480 --> 00:13:48.470 
there is also another method that gives us the number of operations

178
00:13:48.470 --> 00:13:50.410 
for each of the gates

179
00:13:51.470 --> 00:13:55.680 
a circuit size and also circuit depth

180
00:13:56.440 --> 00:13:59.170 
which is what we are always trying to optimize

181
00:14:01.710 --> 00:14:06.740 
there are other things that we can also add to the circuits such as

182
00:14:07.080 --> 00:14:11.340 
appending save_statevector or save_unitary

183
00:14:11.340 --> 00:14:16.760 
and in these cases when we select the general simulator - aer simulator

184
00:14:17.210 --> 00:14:19.140 
since we have

185
00:14:19.910 --> 00:14:25.100 
these instructions appended to our circuit it will automatically

186
00:14:26.150 --> 00:14:28.450 
understand that it has to save

187
00:14:29.090 --> 00:14:33.620 
both state vector in the first case or the unitary in the second one

188
00:14:34.150 --> 00:14:36.100 
and this way we can output it

189
00:14:36.900 --> 00:14:41.770 
maybe we are interested in saving a multiple states at different

190
00:14:41.770 --> 00:14:46.640 
points in our circuit so this is also possible and you have a

191
00:14:46.740 --> 00:14:51.810 
code for that here so basically here we're just

192
00:14:51.810 --> 00:14:53.410 
doing like a for-loop

193
00:14:54.880 --> 00:14:58.380 
for the different steps and we're saving the state vector at

194
00:14:58.430 --> 00:15:01.890 
all of these points and then we are outputting

195
00:15:02.580 --> 00:15:05.810 
the result at each of these states

196
00:15:07.560 --> 00:15:12.520 
maybe we are working with some circuit where it

197
00:15:12.520 --> 00:15:16.470 
is important to set up our initial state vector

198
00:15:17.000 --> 00:15:21.970 
so this is something that we can

199
00:15:21.970 --> 00:15:25.740 
also do we have even a function to generate a random one

200
00:15:26.990 --> 00:15:31.170 
or we have two ways of initializing this circuit the first one

201
00:15:31.180 --> 00:15:33.790 
is initialized there is the one that you can see

202
00:15:34.680 --> 00:15:38.410 
the only condition is that we have

203
00:15:38.410 --> 00:15:44.650 
to give it our input some vector that has norm one

204
00:15:47.970 --> 00:15:51.130 
otherwise it will complain

205
00:15:51.960 --> 00:15:57.570 
but this doesn't give us the most optimal

206
00:15:58.490 --> 00:16:03.030 
set of gates that gives you this initial

207
00:16:03.700 --> 00:16:09.210 
vector state there is a better method in order to initialize

208
00:16:09.210 --> 00:16:12.430 
another option to initialize the circuit which is called isometry

209
00:16:12.720 --> 00:16:16.220 
and it has some more optimized the composition of the gates used

210
00:16:16.740 --> 00:16:24.320 
for uploading these initial state so here you can compare the two outputs

211
00:16:25.690 --> 00:16:29.100 
and as you can see while initialized for the same vector

212
00:16:30.550 --> 00:16:35.680 
used two CNOTs isometry only used one

213
00:16:42.810 --> 00:16:46.750 
other components that might be interesting when working with circuits

214
00:16:47.120 --> 00:16:54.390 
maybe might be composite gates so maybe there is a

215
00:16:54.590 --> 00:16:57.540 
combination a set of gates that are repeated a lot of times

216
00:16:57.540 --> 00:17:00.490 
and we don't want to write them every time so we can create

217
00:17:00.590 --> 00:17:04.180 
our sub-circuit and then append it each time it appears that's

218
00:17:04.180 --> 00:17:05.470 
what we are doing here

219
00:17:10.320 --> 00:17:15.370 
i think that we might want to add this global phase to our circuit that's

220
00:17:15.610 --> 00:17:19.800 
also possible and it's done as you can see here with global phase

221
00:17:21.840 --> 00:17:26.080 
for some algorithms it's important to be able

222
00:17:26.080 --> 00:17:28.390 
to have some free parameter that we want to

223
00:17:28.960 --> 00:17:33.770 
define beforehand such is the case in quantum machine learning

224
00:17:34.190 --> 00:17:37.030 
so that's why we have the option to define a

225
00:17:37.980 --> 00:17:42.690 
circuit with parameters that we can then give values to

226
00:17:46.690 --> 00:17:50.890 
maybe we want to create a random circuit that's also possible

227
00:17:52.400 --> 00:17:58.770 
we also have the possibility to import the Pauli operators

228
00:18:02.490 --> 00:18:06.780 
or define our own initial unitary

229
00:18:07.540 --> 00:18:12.740 
that's also possible or a use a creating a set of gates that

230
00:18:12.740 --> 00:18:14.790 
implement some classical logic

231
00:18:15.540 --> 00:18:18.670 
so that's what this function does

232
00:18:20.500 --> 00:18:22.160 
and these are two examples

233
00:18:23.780 --> 00:18:27.470 
and what if we wanted to create our own operator well this

234
00:18:27.470 --> 00:18:31.360 
is something that we can also do and you can check how to do

235
00:18:31.360 --> 00:18:37.400 
it in this tutorial so with that we have finished our first code tutorial

236
00:18:38.140 --> 00:18:40.860 
and we will continue

237
00:18:41.610 --> 00:18:45.230 
with some visualization tools in the next video

238
00:18:46.160 --> 00:18:49.180 
thank you so much for watching and looking forward to seeing

239
00:18:49.180 --> 00:18:50.320 
you in the next video
