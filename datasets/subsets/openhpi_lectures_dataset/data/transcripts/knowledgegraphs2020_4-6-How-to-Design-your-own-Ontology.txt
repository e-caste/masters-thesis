WEBVTT

1
00:00:00.890 --> 00:00:06.340 
This is knowledge graphs lecture number four
knowledge representations with ontologies.

2
00:00:07.310 --> 00:00:11.340 
So after you have learned now a lot
of how to represent knowledge

3
00:00:11.340 --> 00:00:15.400 
based on description logics and
the web ontology language owl

4
00:00:15.780 --> 00:00:21.290 
you might ask yourself now ok how
do I design my own ontology,

5
00:00:21.290 --> 00:00:26.930 
and this exactly is what you will learn in
this last part of lecture number four.

6
00:00:27.780 --> 00:00:31.630 
So how does it work the ontology
development process? Usually

7
00:00:31.630 --> 00:00:35.480 
you start with something and then
you follow lots of different

8
00:00:35.480 --> 00:00:39.550 
ways trials and errors back and
forth and you hope to come

9
00:00:39.550 --> 00:00:43.270 
out of that maze in the end
with the great ontology.

10
00:00:45.160 --> 00:00:48.540 
I guess it's the worst of
all development strategies

11
00:00:49.210 --> 00:00:52.510 
simply because it's complicated
to structure your knowledge

12
00:00:52.600 --> 00:00:56.790 
right in the correct way so that
it's really useful and efficiently

13
00:00:57.580 --> 00:01:00.520 
applicable within
a computation.

14
00:01:01.470 --> 00:01:05.930 
Therefore methodologies have been
developed how to structure

15
00:01:05.930 --> 00:01:10.270 
the ontology development process
and in the course of this lecture

16
00:01:10.440 --> 00:01:14.470 
we will show you the most simple one
and know what it's called ontology

17
00:01:14.590 --> 00:01:19.580 
101 that has been introduced in two thousand
by Natala Noy and Deborah McGuinness

18
00:01:20.050 --> 00:01:24.170 
and this is something which every
student of ontologies and

19
00:01:24.170 --> 00:01:29.170 
ontology design will learn because this
is the most easiest and simplest way

20
00:01:29.290 --> 00:01:30.810 
to create your
ontology.

21
00:01:31.530 --> 00:01:36.260 
You have to remember that ontology
creation in the end never ends.

22
00:01:36.500 --> 00:01:41.150 
Why is that so? Yeah ontology of
course what you do there it's

23
00:01:41.150 --> 00:01:46.760 
a model of reality and of course
reality also changes, it evolves.

24
00:01:46.950 --> 00:01:51.970 
Therefore also you will never be able
to catch reality completely in one

25
00:01:52.220 --> 00:01:54.220 
lets say static
ontology.

26
00:01:54.910 --> 00:01:58.670 
Therefore also the development
process is kind of an iterative

27
00:01:58.670 --> 00:02:03.240 
process which means it repeats
continuously and improves the

28
00:02:03.240 --> 00:02:08.410 
ontology again and again and again
so that it fits best somehow

29
00:02:08.590 --> 00:02:12.180 
to the application to exactly
what you have in mind.

30
00:02:13.370 --> 00:02:18.540 
And there is no best way you can
say to model an ontology. There

31
00:02:18.540 --> 00:02:22.600 
are always different approaches
and in practice of course the

32
00:02:22.600 --> 00:02:29.280 
application for which the ontology is meant
for this also defines and decides about

33
00:02:29.420 --> 00:02:33.700 
the modeling approach. So keep in
mind there is no one correct

34
00:02:33.700 --> 00:02:38.270 
way to model a domain. There are
always viable alternatives.

35
00:02:39.010 --> 00:02:41.750 
However we start
ontology one on one.

36
00:02:42.900 --> 00:02:45.880 
The first thing you have to
think about is of course which

37
00:02:45.880 --> 00:02:49.780 
domains should be covered by the
ontology, so what do you want to model?

38
00:02:51.340 --> 00:02:54.070 
If you have decided for
a specific domain

39
00:02:54.990 --> 00:02:59.190 
you have also to keep in mind what your
purpose. So what should be in tolerance

40
00:02:59.300 --> 00:03:02.600 
the ontology be used for in that
domain. What exactly is the

41
00:03:02.600 --> 00:03:06.870 
kind of application you have in
mind which forms the basis or

42
00:03:07.320 --> 00:03:10.330 
of which the ontology
should be the foundation.

43
00:03:12.230 --> 00:03:15.320 
Then you have to think of what
type of questions should be

44
00:03:15.320 --> 00:03:18.780 
answered by the knowledge
represented within the ontology

45
00:03:19.540 --> 00:03:24.070 
and who will use and maintain that
ontology. All these questions

46
00:03:24.070 --> 00:03:28.370 
in the end determine you know
also the granularity the way

47
00:03:28.370 --> 00:03:31.220 
of structuring the knowledge and
so on and so on and for that

48
00:03:31.220 --> 00:03:36.110 
what you do, usually you formulate
so called competence questions.

49
00:03:36.110 --> 00:03:39.940 
These are the questions that the
ontology later on should be

50
00:03:40.030 --> 00:03:44.970 
able to answer. I will show you a few of
these competence questions. We will here

51
00:03:45.180 --> 00:03:49.450 
simply go with the example that
comes also with the introductory

52
00:03:49.450 --> 00:03:53.120 
paper of ontology one o' one that we
had referenced on the last slide

53
00:03:53.230 --> 00:03:56.370 
and this example that they are
using is the so called wine

54
00:03:56.370 --> 00:04:00.770 
ontology. So this is an ontology
which describes wine as well

55
00:04:00.770 --> 00:04:03.820 
later on also food and describes
for example you know what

56
00:04:03.820 --> 00:04:06.750 
kind of wine to take for
which kind of food. So

57
00:04:07.550 --> 00:04:11.220 
the competency questions if you
want to model the domain of

58
00:04:11.230 --> 00:04:14.030 
wine could be for example the
following: So of course you could

59
00:04:14.030 --> 00:04:17.960 
ask yourself which properties of wine
should be considered for modelling.

60
00:04:18.550 --> 00:04:22.590 
It's but do a white wine
or a red wine or both?

61
00:04:23.570 --> 00:04:27.200 
Does a Sauvignon Blanc match
with fish? I would say yes but

62
00:04:27.200 --> 00:04:29.360 
of course you have to model
that in a specific way.

63
00:04:29.960 --> 00:04:32.880 
Which wine matches best
for grilled vegetables?

64
00:04:33.710 --> 00:04:37.310 
And which properties of a wine do
influence whether it matches

65
00:04:37.400 --> 00:04:38.730 
with a specific dish.

66
00:04:40.050 --> 00:04:44.680 
Does the bouquet of a wine change for
example with different vintages?

67
00:04:45.100 --> 00:04:48.290 
Probably yes. And does the colour
of the wine depend on the

68
00:04:48.290 --> 00:04:53.490 
colour of the grape? Probably you would say
yes but this is not necessarily true.

69
00:04:53.920 --> 00:04:57.870 
However we are not going deeper into
winemaking here it's only you know

70
00:04:58.050 --> 00:05:02.420 
how does the ontology in the end
reflect the knowledge that

71
00:05:02.430 --> 00:05:07.090 
we want to have for specific
applications here in mind. So let

72
00:05:07.090 --> 00:05:09.100 
this be our competence
questions and

73
00:05:09.810 --> 00:05:14.790 
now it depends you know what the
ontology exactly should be used for

74
00:05:15.060 --> 00:05:19.100 
how these questions in the end
will be phrased and what

75
00:05:19.100 --> 00:05:23.280 
kind of questions will be posed.
So keep in mind for designing

76
00:05:23.280 --> 00:05:26.250 
the competency question what's
your use case exactly.

77
00:05:28.770 --> 00:05:32.290 
So these questions also might
change of course. So you know

78
00:05:32.290 --> 00:05:35.760 
you remember it's an iterative
process and over time of course you

79
00:05:36.150 --> 00:05:40.220 
also adapt probably your application
or your application changes.

80
00:05:40.640 --> 00:05:45.430 
And therefore these questions might change
within the so called ontology life-cycle.

81
00:05:47.120 --> 00:05:50.970 
No matter what you do whenever you have
your competency questioned and you have

82
00:05:51.280 --> 00:05:54.690 
fixed already the domain that you
want to represent you should

83
00:05:54.690 --> 00:05:58.150 
look around whether there is also
already something out there

84
00:05:58.290 --> 00:06:02.330 
that can be reused so reuse is
really really important. Of course

85
00:06:02.330 --> 00:06:05.230 
you want to save costs if somebody
else did already a wine

86
00:06:05.230 --> 00:06:08.690 
ontology so first have a look on
it. I can maybe use it or even

87
00:06:08.700 --> 00:06:13.090 
parts of it can be used. This is
especially useful because you

88
00:06:13.090 --> 00:06:16.810 
can apply tools that have been applied
for other existing ontologies.

89
00:06:16.810 --> 00:06:21.700 
So also for our own ontology. And in
order to re use ontologies also

90
00:06:21.950 --> 00:06:25.520 
that have already been validated by
the application which means you

91
00:06:26.030 --> 00:06:29.560 
you take something which is out
there that has been proven

92
00:06:29.560 --> 00:06:32.940 
to be correct simply because it
has been validated and used

93
00:06:32.940 --> 00:06:37.180 
in some other applications. So
therefore it's always a good

94
00:06:37.180 --> 00:06:42.450 
thing and valuable to consider the
reuse of existing ontologies. However

95
00:06:43.070 --> 00:06:46.310 
you might find out if you inspect
an existing ontology that

96
00:06:46.330 --> 00:06:50.260 
it's insufficient for your purpose.
Then you have to think about

97
00:06:50.260 --> 00:06:55.180 
yeah, it is possible that I take what it's
out there and that I compliment simply

98
00:06:55.350 --> 00:06:57.010 
based on what is
already out there.

99
00:06:58.600 --> 00:07:00.620 
So you should think
about it. It's always

100
00:07:01.340 --> 00:07:04.190 
it saves cost and it's
more efficient.

101
00:07:05.210 --> 00:07:08.720 
So if you don't find a suitable
ontology out there or

102
00:07:08.930 --> 00:07:13.030 
if the adaption of the existing
ontology might be too complex

103
00:07:13.970 --> 00:07:17.840 
then of course you have to create a
complete new ontology and this is

104
00:07:18.090 --> 00:07:19.380 
what we are going
to do now.

105
00:07:21.570 --> 00:07:25.940 
But before starting to define
classes and properties first

106
00:07:25.940 --> 00:07:29.240 
of all you have to be clear what
you are talking about. So you

107
00:07:29.240 --> 00:07:33.280 
have to talk to the experts of
the domain you want to model.

108
00:07:33.790 --> 00:07:37.560 
So most likely if we now want
to model the wine domain not

109
00:07:37.560 --> 00:07:41.040 
all of us are experts in winemaking
of course. So we have to

110
00:07:41.040 --> 00:07:44.640 
talk to the winemakers and then
of course you have to decide

111
00:07:44.640 --> 00:07:47.580 
of course what kind of language
are they using and they are

112
00:07:47.580 --> 00:07:51.500 
using of course concepts and
properties and they talk about stuff

113
00:07:51.600 --> 00:07:55.120 
that you probably don't know. This means
you have first of all to develop

114
00:07:55.260 --> 00:07:58.930 
something which is called a
terminology. So you have to come

115
00:07:58.930 --> 00:08:03.980 
up with terms with concepts and all
these concepts have to be explained.

116
00:08:04.250 --> 00:08:07.530 
And this of course is done first
in natural language. So the

117
00:08:07.530 --> 00:08:12.650 
development of a terminology is the
first step you do in ontology design.

118
00:08:13.360 --> 00:08:18.470 
For our wine ontology for example we
might have terms like wine, grape,

119
00:08:18.480 --> 00:08:22.070 
winery, location and for a wine
you have to define what a

120
00:08:22.070 --> 00:08:27.000 
wines colour its body its flavor
its sugar content and you

121
00:08:27.000 --> 00:08:31.130 
have to define things like sub-types
of wine so we have white wine

122
00:08:31.840 --> 00:08:36.410 
you have red wine we have rose we
have bordeaux wine and of course

123
00:08:36.600 --> 00:08:39.830 
they might fit to different kind
of food. So you have also

124
00:08:39.830 --> 00:08:44.950 
to define seafood fish meat
vegetables cheese and so on and

125
00:08:44.950 --> 00:08:49.110 
so on. So you can do this in
rather fine granularity.

126
00:08:50.890 --> 00:08:53.620 
When we have finished
our terminology

127
00:08:54.560 --> 00:08:57.850 
then it's time to look closer
on it and to do a more formal

128
00:08:57.850 --> 00:09:02.870 
step which means now we are going
to see what kind of classes

129
00:09:02.870 --> 00:09:08.790 
can be drawn out of our terminology.
So for us we have to distinguish

130
00:09:08.790 --> 00:09:12.470 
for example the classes of all of the
wines that you want to represent.

131
00:09:12.890 --> 00:09:16.580 
We have to represent a class which
comprises all of the wineries

132
00:09:16.590 --> 00:09:19.790 
and then of course also a class
of the red wines which might

133
00:09:19.790 --> 00:09:24.470 
be a subclass of the class of
wine. So what you do is you try

134
00:09:24.530 --> 00:09:28.520 
to define classes which are
collections of objects that you

135
00:09:28.520 --> 00:09:32.720 
want to represent in your ontology
and they are somehow similar

136
00:09:32.720 --> 00:09:36.020 
which means they have similar
properties, they share similar

137
00:09:36.020 --> 00:09:37.590 
property values and
stuff like that.

138
00:09:39.430 --> 00:09:42.120 
You can do this in different way
of course, how do I define

139
00:09:42.120 --> 00:09:45.170 
these classes? What are the most
important classes? And there are

140
00:09:45.620 --> 00:09:48.980 
in principle three different
approaches how you model your

141
00:09:48.980 --> 00:09:51.370 
classes and your
hierarchy of classes.

142
00:09:52.460 --> 00:09:56.140 
First one would be for example
we do this top down.

143
00:09:56.600 --> 00:09:59.610 
So from the most general
to the most specific.

144
00:10:00.180 --> 00:10:04.760 
We want to do a wine ontology so
we start with the most generic

145
00:10:04.760 --> 00:10:07.820 
term we have there that
could be beverage.

146
00:10:08.710 --> 00:10:11.860 
Ok what comes below beverage of
course we should distinguish

147
00:10:11.860 --> 00:10:15.440 
between alcoholic beverages and
non alcoholic beverages. So

148
00:10:15.440 --> 00:10:19.300 
we know most wines all wines
are alcoholic beverages.

149
00:10:20.000 --> 00:10:23.400 
So therefore under alcoholic
beverages we might have wine

150
00:10:23.810 --> 00:10:27.660 
as well as beer. However we do
not want to go deeper into beer

151
00:10:27.870 --> 00:10:32.750 
we go deeper into wines. Sorry.
There you can distinguish between

152
00:10:32.940 --> 00:10:35.560 
white wine, rose
wine and red wine.

153
00:10:36.310 --> 00:10:40.080 
This would be a typical
approach in top-down manner.

154
00:10:41.610 --> 00:10:45.550 
Now let's try the other way around.
What happens if we do this

155
00:10:45.550 --> 00:10:49.010 
bottom up? So bottom up we might come
up with the wines we definitely

156
00:10:49.010 --> 00:10:52.750 
want to represent there and this
could be a Bordeaux white wine,

157
00:10:52.940 --> 00:10:56.650 
this could be a Chardonnay white
wine, a Merlot white wine and

158
00:10:56.650 --> 00:11:01.780 
a Bordeaux red wine. Ok so what's
above there? Of course you

159
00:11:01.780 --> 00:11:05.530 
can distinguish there white wines
and you can distinguish red wines.

160
00:11:05.810 --> 00:11:08.620 
So it would be already in our
hierarchy and of course both

161
00:11:08.620 --> 00:11:12.740 
of them are wines and the wine we know
already is an alcoholic beverage.

162
00:11:13.040 --> 00:11:16.560 
So this would be a class hierarchy
that has been created in

163
00:11:16.560 --> 00:11:18.750 
a bottom up
manner. You see

164
00:11:19.760 --> 00:11:24.010 
it's of course similar to the first one
but it's different. So you devout

165
00:11:24.130 --> 00:11:28.220 
things for example that are not important
for you in this bottom-up manner.

166
00:11:28.560 --> 00:11:31.720 
Do you have all the important classes
then if you do it that way?

167
00:11:32.560 --> 00:11:36.700 
Probably. However there is also a
third way to do that in this one

168
00:11:36.920 --> 00:11:39.650 
is referred to as
middle out approach.

169
00:11:40.630 --> 00:11:45.540 
In the middle out approach the things you
start with are the most important classes.

170
00:11:46.020 --> 00:11:50.380 
So you say ok for me the most important
classes in my wine ontology should be

171
00:11:50.610 --> 00:11:56.290 
red wine, Bordeaux wine and white wine. This
is what I definitely want to represent.

172
00:11:57.170 --> 00:12:00.450 
Ok so what you do then is of
course yeah from the middle out

173
00:12:00.450 --> 00:12:03.760 
you can go to the top. So all of
these three things are wine

174
00:12:03.760 --> 00:12:07.300 
and wine of course is an alcoholic
beverage. And now let's go

175
00:12:07.310 --> 00:12:10.780 
more specific and you can say ok
below the white wines I have

176
00:12:10.780 --> 00:12:14.190 
definitely the Bordeaux white wine and
I have the Chardonnay white wine

177
00:12:14.290 --> 00:12:18.290 
and below red wine I have the Merlot red
wine and I have the Bordeaux red wine.

178
00:12:18.480 --> 00:12:21.840 
And of course I have two Bordeauxs
here, they are also connected here

179
00:12:21.840 --> 00:12:26.470 
to the Bordeaux wine. And you see
here again a similar structure

180
00:12:26.710 --> 00:12:28.490 
but of course not
exactly the same.

181
00:12:29.550 --> 00:12:33.280 
Now it depends what kind of
approach you choose and also it

182
00:12:33.280 --> 00:12:38.050 
depends what exactly is the
purpose of your ontology, what

183
00:12:38.050 --> 00:12:41.550 
exactly should be the application,
where should be the emphasis?

184
00:12:41.550 --> 00:12:44.950 
Should the emphasis here be in
the middle, should the emphasis

185
00:12:44.950 --> 00:12:48.790 
be more towards the top or should the
emphasis be more towards the bottom?

186
00:12:50.220 --> 00:12:53.290 
Depends on your application you see
you have different approaches

187
00:12:53.290 --> 00:12:56.440 
you can choose here four
defining classes.

188
00:12:58.370 --> 00:13:02.650 
So when we have finished our first
round of defining classes we then

189
00:13:02.830 --> 00:13:07.270 
think about how can these classes be
connected with each other? Which means

190
00:13:07.400 --> 00:13:09.780 
we have to define
the properties.

191
00:13:10.760 --> 00:13:15.300 
And the properties of course
they describe how each single

192
00:13:15.370 --> 00:13:20.060 
instance of a class will be connected
to another instance of another class.

193
00:13:20.250 --> 00:13:25.280 
So for example you have here
the property like wine has

194
00:13:25.280 --> 00:13:29.770 
a color, wine has residual sugar,
wine has a producer and so

195
00:13:29.770 --> 00:13:34.350 
on and so on and you see here a
small screenshot of a ontology

196
00:13:34.360 --> 00:13:40.670 
design program. So there is an open source
program called Protege, originally also

197
00:13:40.820 --> 00:13:46.340 
provided by the two authors
of the ontology 101. So you

198
00:13:46.450 --> 00:13:52.050 
we will give you the link to that
program prodigy for ontology design

199
00:13:52.250 --> 00:13:55.280 
in the materials for this lecture.
And this would look like

200
00:13:55.280 --> 00:14:01.410 
that and here you see how for example properties
and property restrictions are defined.

201
00:14:01.920 --> 00:14:03.350 
So we have
properties first

202
00:14:04.450 --> 00:14:08.030 
and of course every property somehow
is connected to a specific

203
00:14:08.160 --> 00:14:11.920 
specific domain and a specific
range so what you have to do

204
00:14:11.920 --> 00:14:15.390 
there is you have to define property
constraints that for example

205
00:14:15.560 --> 00:14:19.170 
say that the wine the name of
a wine is always a string,

206
00:14:19.510 --> 00:14:23.700 
the producer of an instance of
wine is a wine maker and so

207
00:14:23.700 --> 00:14:27.780 
on and so on. So you define your
domain and range restrictions.

208
00:14:29.300 --> 00:14:32.650 
And after you have your classes,
class hierarchies, properties,

209
00:14:32.660 --> 00:14:36.300 
property constraints what you
do then is of course you fill

210
00:14:37.090 --> 00:14:40.390 
your ontology with instances
for the classes.

211
00:14:41.980 --> 00:14:46.010 
When you do that then also every
class directly becomes the type

212
00:14:46.370 --> 00:14:49.980 
for its instance and if you have
a class hierarchy then also

213
00:14:49.980 --> 00:14:55.440 
every super class of a direct type also
becomes a type of its instances.

214
00:14:55.840 --> 00:14:59.860 
And you also create instances
for properties which means you

215
00:15:00.020 --> 00:15:04.190 
assign one instance of one class
to another instance of another

216
00:15:04.190 --> 00:15:08.510 
class via a specific property. And
this then on the instance level

217
00:15:08.770 --> 00:15:12.760 
often is already referred to as the
knowledge graph you are talking about

218
00:15:12.860 --> 00:15:16.360 
that is connected to the
terminological knowledge that you

219
00:15:16.360 --> 00:15:20.850 
have defined so far in your ontology.
And in the end you might be also

220
00:15:21.090 --> 00:15:25.990 
able to represent knowledge
like for example the instance

221
00:15:25.990 --> 00:15:29.750 
of the glass of red wine that I
drank last supper. So that can

222
00:15:29.750 --> 00:15:33.710 
be directly represented as an instance
there connected to the classes

223
00:15:33.900 --> 00:15:37.810 
that you have there and of course
then you can use it and can

224
00:15:37.810 --> 00:15:40.680 
make assumptions about it. You
can connect it to other facts

225
00:15:40.680 --> 00:15:42.960 
to other things and then you
can play around with it.

226
00:15:44.830 --> 00:15:48.390 
Of course this is a rather rather
shallow and rather easy approach.

227
00:15:48.390 --> 00:15:53.000 
There are much more sophisticated
approaches to come up with ontologies.

228
00:15:53.290 --> 00:15:56.500 
And keep in mind that ontology
development in practice always

229
00:15:56.500 --> 00:16:01.810 
is an iterative process it means you never
finished. It repeats continuously and

230
00:16:01.990 --> 00:16:06.770 
is trying to improve the ontology.
So here is the link also

231
00:16:07.020 --> 00:16:11.850 
to the ontology 101 pdf which
we also provide for you

232
00:16:11.850 --> 00:16:14.940 
in the material section
of this lecture.

233
00:16:15.590 --> 00:16:22.670 
As said this is more or less a
toy example a toy methodology.

234
00:16:22.790 --> 00:16:28.080 
If your ontologies become let's
say more complex if the domain

235
00:16:28.080 --> 00:16:34.200 
becomes more complex then you need
let's say a more industrial method

236
00:16:34.390 --> 00:16:38.130 
that is really really or professional
method that is better suited

237
00:16:38.270 --> 00:16:44.290 
also for keeping track about
different versions. So versioning

238
00:16:44.290 --> 00:16:48.880 
of ontologies provenance stuff and
stuff like that and of course

239
00:16:49.040 --> 00:16:55.460 
you must have some engineering tools connected
with your ontology development process

240
00:16:55.630 --> 00:16:59.500 
to make this in the end
sound and stable.

241
00:17:00.420 --> 00:17:04.460 
One of the more let's say modern
approaches for ontology

242
00:17:04.460 --> 00:17:07.870 
design is here the unified process
for ontology building. This

243
00:17:07.870 --> 00:17:12.150 
is only one of many other
approaches that is out there and

244
00:17:12.240 --> 00:17:18.230 
this approach for example divides
the process into cycles.

245
00:17:19.090 --> 00:17:22.090 
Of course you know iterative
process and here it's referred

246
00:17:22.090 --> 00:17:25.040 
to as a cycle and each of these
cycles they are subdivided

247
00:17:25.040 --> 00:17:28.230 
into four phases of iterations
which means we have an inception

248
00:17:28.230 --> 00:17:31.920 
phase of the ontology design we
have an elaboration phase we

249
00:17:31.920 --> 00:17:34.990 
have a construction phase and
then we have a transition phase

250
00:17:34.990 --> 00:17:39.250 
either into practice or into
the next cycle of definition.

251
00:17:39.670 --> 00:17:43.340 
And each of these iterations itself
results in a new prototype.

252
00:17:43.710 --> 00:17:47.680 
And what you do then in the iteration
you define five workflows.

253
00:17:47.680 --> 00:17:51.040 
So you have a requirement analysis
you have an analysis of

254
00:17:51.040 --> 00:17:54.700 
all the stuff you have a design
phase you have an implementation

255
00:17:54.700 --> 00:17:58.120 
phase and you have a test phase where
you evaluate all your stuff and then

256
00:17:58.440 --> 00:18:03.130 
go to the next iteration with an
improved version of your ontology. So

257
00:18:03.900 --> 00:18:08.060 
you can read it up in a paper
that is that reference is given

258
00:18:08.060 --> 00:18:12.640 
here and uh this is one of the
processes that support ontology

259
00:18:12.640 --> 00:18:16.740 
design on a more professional level
for more complex ontologies.

260
00:18:17.700 --> 00:18:23.480 
However as you might already assume
many things are done again and again

261
00:18:23.690 --> 00:18:29.700 
in exactly this ontology design process.
So why not let's say coming up with

262
00:18:29.900 --> 00:18:33.980 
templates that help you in the
ontology development process?

263
00:18:34.960 --> 00:18:39.180 
Another idea I wanted to show you
here is the so called ontology

264
00:18:39.180 --> 00:18:42.790 
design patterns that have been
introduced by Gangemi in

265
00:18:42.790 --> 00:18:47.900 
2005 and what is done there
is simply they try to

266
00:18:48.330 --> 00:18:53.260 
move or let's say to migrate an
idea that originally comes

267
00:18:53.260 --> 00:18:57.680 
from architecture into ontology
design. In architecture also

268
00:18:57.680 --> 00:19:01.800 
the way how you build a door or
set a door into a facade or

269
00:19:02.270 --> 00:19:07.100 
set up your windows within your building
its most times exactly the same.

270
00:19:07.210 --> 00:19:10.380 
Or they follow exactly the same
principles. You don't have to

271
00:19:10.380 --> 00:19:14.080 
design this and invent this from
the scratch for that it gives

272
00:19:14.080 --> 00:19:18.040 
so called patterns design patterns
that you can use in architecture.

273
00:19:18.530 --> 00:19:23.010 
And of course simply by transferring
these kind of patterns

274
00:19:23.010 --> 00:19:28.210 
to the ontology level you can come up with
let's say a standard set of solutions

275
00:19:28.330 --> 00:19:33.020 
for more or less generic problems
that are there. And by that

276
00:19:33.020 --> 00:19:38.080 
of course ontology development
can be greatly simplified. But

277
00:19:38.080 --> 00:19:41.480 
to go deeper into that I leave that
to you. This is not necessarily

278
00:19:41.480 --> 00:19:44.370 
subject of this lecture. I only
wanted to point out that there

279
00:19:44.370 --> 00:19:48.890 
are lots of different methods for
ontology design, again depends

280
00:19:48.890 --> 00:19:51.620 
on the application what you have
in mind how large will the

281
00:19:51.620 --> 00:19:55.710 
ontology be how complex will it
be and what exactly will the

282
00:19:55.710 --> 00:20:01.250 
ontology be used for and then you design
for a specific method how exactly

283
00:20:01.470 --> 00:20:04.030 
to go on with the
design process.

284
00:20:05.970 --> 00:20:09.870 
Now we know how to design ontologies
in principle we know already

285
00:20:09.870 --> 00:20:14.040 
also there is a phase where we have to
define instances which means we populate

286
00:20:14.260 --> 00:20:20.630 
our knowledge graph and in the next
lecture our topic will be applications

287
00:20:20.770 --> 00:20:24.300 
that are related to knowledge
graphs. So lecture five then will

288
00:20:24.300 --> 00:20:26.270 
be knowledge graph
applications.
