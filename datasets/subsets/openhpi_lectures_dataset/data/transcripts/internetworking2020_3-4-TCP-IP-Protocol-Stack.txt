WEBVTT

1
00:00:00.770 --> 00:00:04.970 
In our openhpi course "A Half Century
of Internet" now we consider

2
00:00:04.970 --> 00:00:09.730 
the TCP/IP protocol stack, the
operating system of the internet.

3
00:00:12.220 --> 00:00:14.910 
What is the task of such
communication protocols?

4
00:00:15.580 --> 00:00:20.210 
Since the internet consists of different
networks with their own network technology

5
00:00:20.850 --> 00:00:22.720 
internet is
heterogeneous.

6
00:00:23.820 --> 00:00:29.820 
And this heterogeneity makes it necessary
to ensure that communication can work

7
00:00:29.980 --> 00:00:36.070 
with different and possibly incompatible
physical network technologies.

8
00:00:37.510 --> 00:00:41.840 
And for that reason internet needs
own communication protocols,

9
00:00:42.170 --> 00:00:46.740 
needs own address formats,
needs own data formats.

10
00:00:50.900 --> 00:00:55.060 
Communication in the internet
is based on a layered

11
00:00:55.480 --> 00:01:01.040 
communication model and the
reason is that when we look to

12
00:01:01.040 --> 00:01:03.560 
the complex task of
a communication,

13
00:01:04.240 --> 00:01:08.950 
we can separate it into
different subtasks

14
00:01:09.870 --> 00:01:13.620 
and the subtask can
organize in such a way

15
00:01:14.030 --> 00:01:17.270 
that following the divide
and conquer principle

16
00:01:17.780 --> 00:01:23.940 
the complex communication task can be
performed with synced it with the sequence

17
00:01:24.140 --> 00:01:29.200 
of single step. And exactly this
is what a network operating

18
00:01:29.200 --> 00:01:30.440 
system is doing.

19
00:01:32.630 --> 00:01:35.730 
The communication has an
hierarchical nature.

20
00:01:36.370 --> 00:01:42.960 
So it is possible to subdivide the
communication into various subtasks

21
00:01:43.400 --> 00:01:47.870 
on different levels, on
such a layer model.

22
00:01:48.710 --> 00:01:52.670 
So the communication protocols
are designed on the basis of

23
00:01:52.670 --> 00:01:56.460 
such a layered communication model.
On each of the layers there

24
00:01:56.460 --> 00:02:02.920 
are certain subtasks to be solved and the
communication protocols are developed

25
00:02:03.130 --> 00:02:05.820 
to exactly serve
the subtasks.

26
00:02:06.910 --> 00:02:12.360 
And so we have no one communication
protocol we have a series

27
00:02:12.660 --> 00:02:19.100 
a stack of communication protocols which
are doing their work on different layers

28
00:02:19.240 --> 00:02:20.390 
of the communication
model.

29
00:02:21.350 --> 00:02:24.660 
So this complex
communication mission can

30
00:02:25.090 --> 00:02:27.660 
solved by a modular

31
00:02:28.270 --> 00:02:29.830 
divide and conquer
approach.

32
00:02:31.920 --> 00:02:36.520 
What are they doing? What are the
protocols doing on each layer?

33
00:02:38.440 --> 00:02:43.730 
Each protocol is responsible for solving
a subtask of communication. For example

34
00:02:43.980 --> 00:02:48.280 
sending electrical
signals or translating

35
00:02:48.800 --> 00:02:54.440 
of binary data into electrical
signals or by adding address

36
00:02:54.630 --> 00:02:58.760 
or adding a sequence of information
to the binary application data.

37
00:02:59.510 --> 00:03:05.760 
And the idea in this divide and
conquer approach is said a protocol

38
00:03:06.020 --> 00:03:12.340 
solving such a subtask is only communicating
with the protocols of adjacent layers

39
00:03:12.570 --> 00:03:14.370 
in this communication
model.

40
00:03:15.820 --> 00:03:21.400 
So the successful communication
requires that sender and receiver

41
00:03:21.730 --> 00:03:25.630 
follows the same layered
communication protocol stack,

42
00:03:26.030 --> 00:03:30.970 
so that the receiver exactly
knows what to do with this

43
00:03:30.970 --> 00:03:35.150 
piece that was
handed over

44
00:03:35.510 --> 00:03:39.540 
by the protocol of the
other side of the centre.

45
00:03:40.400 --> 00:03:47.130 
They always communicate on the
same layer for successfully

46
00:03:47.350 --> 00:03:48.840 
commmunicating
with each other.

47
00:03:49.730 --> 00:03:51.730 
So the concrete
implementation

48
00:03:52.730 --> 00:03:56.850 
of this subtask
communication subtask

49
00:03:57.450 --> 00:04:03.200 
is handled by so called communication
protocols in each layer.

50
00:04:04.960 --> 00:04:09.650 
So here is such an illustration we
have the sender - we have Alice,

51
00:04:09.950 --> 00:04:14.820 
we have the receiver, its Bob,
they are communicating,

52
00:04:14.820 --> 00:04:21.440 
they use some application that wants
to communicate with the other side.

53
00:04:21.810 --> 00:04:24.600 
So the communication
task

54
00:04:25.300 --> 00:04:31.070 
sends this email to Bob or receive
this information from Bob

55
00:04:31.520 --> 00:04:37.210 
is worked on the different
layers the different

56
00:04:37.220 --> 00:04:44.650 
protocols do their work and then these
signals are transmitted over the

57
00:04:44.900 --> 00:04:48.920 
internet. So here in the
lower layers they are

58
00:04:48.920 --> 00:04:53.330 
more close to the physical layer
here in the utmost layers

59
00:04:53.510 --> 00:04:57.400 
the tasks are more close to the content
what's done, what needs to be done.

60
00:04:57.630 --> 00:05:04.530 
And so here on the protocol the
layer the information got

61
00:05:04.630 --> 00:05:10.250 
on the layer one level is depacked
and is hand over to the

62
00:05:10.250 --> 00:05:14.510 
protocols on layer two. So what's
done in this sequence here

63
00:05:14.510 --> 00:05:19.470 
on the side of the sender is done in that
sequence on the side of the receiver.

64
00:05:20.490 --> 00:05:25.940 
What is used in the internet is a
TCP/IP protocol stack. TCP and

65
00:05:26.080 --> 00:05:31.290 
IP we will know later are the most
important protocols in the stack

66
00:05:31.500 --> 00:05:35.890 
that consists of a lot of
different protocols.

67
00:05:36.980 --> 00:05:45.010 
This communication stack is organized by the
TCP/IP layer layout communication model.

68
00:05:45.320 --> 00:05:51.840 
Its called TCP/IP protocol stack,
sometimes only TCP/IP protocol stack.

69
00:05:52.090 --> 00:05:55.740 
So there are many
names for it.

70
00:05:56.540 --> 00:06:00.920 
The TCP/IP protocol stack consists
of the following layers.

71
00:06:01.740 --> 00:06:09.220 
There are exactly four layers. Some
also count the hardware layer to it.

72
00:06:09.340 --> 00:06:14.900 
But the hardware layer this is a
layer of the networks, then we

73
00:06:14.900 --> 00:06:19.030 
have the link layer. On top of the link
layer there is the internet layer

74
00:06:19.440 --> 00:06:25.020 
for routing the internet packages.
Then we have the transport layer.

75
00:06:25.120 --> 00:06:28.830 
Transport layer takes care for
correct transmission and then

76
00:06:28.830 --> 00:06:33.360 
we have the application layer that makes
it possible that different applications

77
00:06:33.550 --> 00:06:35.730 
can make use of
the internet.

78
00:06:37.320 --> 00:06:43.020 
The protocol on each layer are
responsible to serve a specific task

79
00:06:43.260 --> 00:06:47.380 
and are allowed to add their own
management data to the actual

80
00:06:47.380 --> 00:06:55.530 
user data. So working in this way
is creating overhead. Overhead

81
00:06:55.710 --> 00:07:01.140 
that's necessary for the correct
communication. These are the headers

82
00:07:01.330 --> 00:07:06.580 
I already mentioned in earlier clip. So
let's look to the different layers.

83
00:07:06.580 --> 00:07:10.210 
Let's start with the lowest
layer, with the hardware layer.

84
00:07:10.340 --> 00:07:14.670 
I already mentioned often this is
not counted to the TCP/IP stack

85
00:07:14.680 --> 00:07:16.780 
but it's good to
have it in mind.

86
00:07:17.530 --> 00:07:22.920 
So this is actually the layer below
the TCP/IP stack. It is responsible

87
00:07:22.920 --> 00:07:27.840 
for sending the data via the
physical transport layer,

88
00:07:28.310 --> 00:07:33.740 
via radio signals if it's a
wifi network, via electrical

89
00:07:33.740 --> 00:07:36.050 
signals if it's
ethernetwork.

90
00:07:37.200 --> 00:07:43.920 
So the data mine on the hardware layer
data mines the necessary electrical,

91
00:07:44.310 --> 00:07:49.940 
mechanical, functional or other
parameters uh this is a task

92
00:07:50.120 --> 00:07:52.070 
of the next
upper layer.

93
00:07:53.300 --> 00:07:56.250 
The next upper layer
is the link layer.

94
00:07:56.900 --> 00:08:00.480 
The link layer is responsible
for connection establishment

95
00:08:00.730 --> 00:08:04.210 
and interpretation of the
transmitted physical signals.

96
00:08:04.670 --> 00:08:11.550 
It is responsible that bits received
with are grouped into logical units

97
00:08:11.820 --> 00:08:17.770 
the data packets. And the packets
may contain mechanisms for

98
00:08:17.770 --> 00:08:20.050 
determining and
correcting errors.

99
00:08:21.480 --> 00:08:29.870 
The layer can be subdivided into different
sublayers, the media access control layer

100
00:08:30.370 --> 00:08:34.880 
the MAC layer which controls access
to the physical transmission media

101
00:08:35.310 --> 00:08:38.290 
and the by the way
it's well known

102
00:08:39.040 --> 00:08:43.630 
by the MAC protocols the ethernet
protocol token ring FDDI

103
00:08:44.080 --> 00:08:47.960 
wifi and the logical
link control layer.

104
00:08:48.450 --> 00:08:55.110 
Logical link control LLC which
manages the logical connection

105
00:08:55.400 --> 00:08:59.070 
including error correction
and congestion control.

106
00:09:00.040 --> 00:09:05.780 
Then we come to the next layer
on the TCP/ÃŒP protocol stack,

107
00:09:05.980 --> 00:09:13.220 
the internet layer. The internet layer
provides transport service for data package.

108
00:09:14.970 --> 00:09:21.810 
It determines the path of each data package
from sender to receiver based on the

109
00:09:22.080 --> 00:09:26.630 
addressing scheme, the IP
address which is also defined

110
00:09:26.640 --> 00:09:31.240 
by the internet protocols on that
layer and in this way it's

111
00:09:31.240 --> 00:09:36.140 
responsible for the routing of data
packages through the internet.

112
00:09:37.110 --> 00:09:42.600 
The routing is based on several
criteria such as maximum throughput,

113
00:09:42.610 --> 00:09:48.100 
lowest cost, load distribution,
maximum possible security,

114
00:09:48.410 --> 00:09:54.200 
this can be done and optimized in
the different routing approach.

115
00:09:54.440 --> 00:09:59.080 
Then we will discuss this in
more detail later. Then the

116
00:09:59.080 --> 00:10:03.610 
next layer is the transport layer
in the TCP/IP protocol stack.

117
00:10:04.170 --> 00:10:07.970 
It provides a universal
transport service,

118
00:10:08.580 --> 00:10:12.290 
not only the routing. The routing
is to transport data package

119
00:10:12.390 --> 00:10:16.360 
from one point from the
sender to the receiver.

120
00:10:16.960 --> 00:10:24.060 
If something goes wrong on the internet layer
there is no responsibility for mechanism

121
00:10:24.270 --> 00:10:28.850 
that there is a guarantee that the
package receives. This guarantees

122
00:10:29.100 --> 00:10:32.490 
are given on the next level on
the transport-layer level. For

123
00:10:32.490 --> 00:10:37.330 
that reason here we have a
universal transport service

124
00:10:37.830 --> 00:10:44.800 
dedicated connections with methods to
guarantee transportation of user data

125
00:10:44.910 --> 00:10:46.620 
are provided on
that layer.

126
00:10:47.700 --> 00:10:53.160 
There are quality criteria negotiation,
so the automatic correction and errors,

127
00:10:53.360 --> 00:10:58.660 
correct ordering of the data sequences,
you may remember a message

128
00:10:58.670 --> 00:11:03.580 
is fragmented into different data
packets and those at the receiver

129
00:11:03.730 --> 00:11:07.620 
can get the data packets
in the right sequence.

130
00:11:07.830 --> 00:11:10.650 
This is a responsibility
of the transport layer.

131
00:11:11.720 --> 00:11:16.530 
And then this transport layer
protocols are also responsible

132
00:11:16.690 --> 00:11:19.010 
for the data
flow control.

133
00:11:20.720 --> 00:11:25.440 
It allows even load distribution
in network infrastructure and

134
00:11:25.440 --> 00:11:29.560 
throttling of data transmission
in case of congestion.

135
00:11:30.310 --> 00:11:32.900 
And the last layer is
the application layer.

136
00:11:33.580 --> 00:11:37.420 
The application layer provides
the communication functionality

137
00:11:37.720 --> 00:11:41.870 
that allows an application to access
the internet. We have different

138
00:11:41.870 --> 00:11:46.720 
application. We have email,
we have world wide web,

139
00:11:47.320 --> 00:11:54.480 
we have other services and this applications
can use the service of the internet.

140
00:11:54.730 --> 00:12:00.860 
They need protocols which are here
a in this application layer

141
00:12:01.070 --> 00:12:08.820 
provided. FTP, file transfer protocol, HTTP
the hypertext transfer protocol, SMTP

142
00:12:09.070 --> 00:12:13.230 
the email protocols, simple mail
transfer protocols and many more.

143
00:12:14.290 --> 00:12:18.290 
The application itself be careful as
file transfers or the worldwide

144
00:12:18.290 --> 00:12:22.260 
web or the email do not belong
to the application layer.

145
00:12:22.850 --> 00:12:28.860 
Indeed they recede above the TCP/IP
protocol stack. Here with this protocol

146
00:12:29.010 --> 00:12:34.870 
they can connect, they can hand
over data for a transport through

147
00:12:34.870 --> 00:12:40.030 
the internet and they can
receive data from other

148
00:12:40.270 --> 00:12:42.030 
hosts in the internet.
