WEBVTT

1
00:00:00.900 --> 00:00:04.610 
We already have discussed Digital
Signatures and now we want

2
00:00:04.620 --> 00:00:09.280 
to have a closer look at feasible
digital signatures in our

3
00:00:09.290 --> 00:00:13.290 
openHPI course about Confidential
Communication in the Internet.

4
00:00:14.240 --> 00:00:20.440 
You remember there were two main
problems with digital signature

5
00:00:20.960 --> 00:00:25.460 
and now we concentrate on the
first one. And the first one was

6
00:00:25.460 --> 00:00:28.500 
that the encryption of
the complete document

7
00:00:28.540 --> 00:00:35.910 
with the public key cryptosystem for a
digital signature requires enormous

8
00:00:36.200 --> 00:00:41.100 
computing efforts. Asymmetric
encryption algorithms are

9
00:00:41.920 --> 00:00:45.333 
based on difficult
mathematical problems and

10
00:00:46.000 --> 00:00:52.480 
need to meet the performance of
difficult mathematical operations.

11
00:00:52.770 --> 00:00:57.930 
So, it is not practical
if a long contract is

12
00:00:58.800 --> 00:01:03.950 
encrypted with the private
key of the signee

13
00:01:04.750 --> 00:01:10.540 
in a full extent. Though
the idea is that

14
00:01:10.990 --> 00:01:15.830 
the signee does not sign
the full document.

15
00:01:16.880 --> 00:01:22.810 
The signee only designs the
hash of the document.

16
00:01:23.540 --> 00:01:26.710 
You remember a cryptographic
hash of the document

17
00:01:26.867 --> 00:01:32.370 
this was a fingerprint of the document,
so, it was a short string that

18
00:01:32.530 --> 00:01:35.370 
very much characterizes
the document itself,

19
00:01:35.800 --> 00:01:41.830 
and if one instead of encrypting
the complete document

20
00:01:42.660 --> 00:01:46.170 
with an asymmetric
cryptographic method only

21
00:01:47.170 --> 00:01:50.980 
encrypts the hash, then
it becomes feasible.

22
00:01:53.917 --> 00:01:56.420 
For that, we need
the property

23
00:01:57.190 --> 00:02:01.490 
of hash function, we need the property
that any change in the document

24
00:02:01.620 --> 00:02:05.620 
results also in a change of
the cryptographic hash.

25
00:02:06.190 --> 00:02:12.540 
Otherwise, we cannot use hash for
signature because we were not to prove

26
00:02:12.880 --> 00:02:16.420 
the originality of the hash we
want to prove the originality

27
00:02:16.560 --> 00:02:19.500 
of the document
itself so,

28
00:02:19.730 --> 00:02:24.590 
any manipulation in the document
can also be discovered when

29
00:02:24.590 --> 00:02:29.760 
working with its hash, instead of
working with the document itself.

30
00:02:30.210 --> 00:02:34.370 
So, our digital signature
cryptoprotocol now

31
00:02:34.950 --> 00:02:41.100 
becomes a little bit more complicated.
We take the data, we take the contract

32
00:02:41.440 --> 00:02:44.290 
and then by means of

33
00:02:44.940 --> 00:02:50.490 
cryptographic hash functions,
we compute the hash

34
00:02:50.770 --> 00:02:52.740 
value of this document.

35
00:02:53.350 --> 00:02:58.310 
And then not only the document itself
is encrypted with the public key,

36
00:02:58.720 --> 00:03:06.567 
but the hash is encrypted with the public
key and this is called the signature

37
00:03:06.733 --> 00:03:14.900 
So, together with the document itself, together with the
certificate which gives the public key of the signee

38
00:03:15.250 --> 00:03:20.910 
as well as the encrypted hash, this
now is a digital signature.

39
00:03:23.730 --> 00:03:29.470 
To look how the verification
works of that, a person who

40
00:03:29.470 --> 00:03:33.560 
wants to check the
contract signed by Alice

41
00:03:34.100 --> 00:03:38.420 
gets the data, the contract
itself, gets a certificate of

42
00:03:39.600 --> 00:03:45.380 
Alice with her public key and the
signature is the encrypted hash

43
00:03:45.520 --> 00:03:48.400 
of the document.
From the data,

44
00:03:49.530 --> 00:03:54.470 
verifier computes on his
side the hash value.

45
00:03:56.740 --> 00:04:01.820 
Then it takes the public key
out of the certificate

46
00:04:02.280 --> 00:04:06.140 
and decrypts the signature
of the document.

47
00:04:09.529 --> 00:04:17.970 
Now the hash is re-constructed from the
original contract, from the original document

48
00:04:18.160 --> 00:04:19.410 
on the side of Alice.

49
00:04:20.340 --> 00:04:24.500 
And now one has
similarly like in the

50
00:04:25.360 --> 00:04:30.180 
basic digital signature
crypto protocol,

51
00:04:30.940 --> 00:04:34.100 
whether these two
values agree.

52
00:04:34.640 --> 00:04:40.190 
This is the hash value that's produced
out of the contract of the document

53
00:04:40.740 --> 00:04:44.220 
which arrived on side
of the verifier,

54
00:04:44.680 --> 00:04:49.630 
and this was the hash value of
the original document which

55
00:04:49.630 --> 00:04:53.460 
was sent by the sender.
And if both agree,

56
00:04:54.370 --> 00:05:00.410 
then it is clear this is a
document which was signed

57
00:05:00.550 --> 00:05:06.570 
by Alice and which was received
without any manipulation.

58
00:05:08.440 --> 00:05:10.280 
Let's assume that

59
00:05:10.750 --> 00:05:18.140 
in the open internet, the document, when it
was transmitted to Alice was manipulated.

60
00:05:18.810 --> 00:05:23.230 
So, as this data which is
received on both sides

61
00:05:23.660 --> 00:05:25.940 
are no more as the
original contract,

62
00:05:26.550 --> 00:05:31.720 
then it is clear, also, the hash
value would not agree with the

63
00:05:31.920 --> 00:05:39.100 
hash value of the original document, so,
this could also be taken as a proof

64
00:05:39.680 --> 00:05:44.590 
that when both the hash values agree
that the document was not manipulated

65
00:05:44.960 --> 00:05:46.470 
when sent to Bob.

66
00:05:48.590 --> 00:05:51.440 
Typically for
the asymmetric

67
00:05:52.620 --> 00:05:59.780 
cryptographic method, RSA is used. This is
in the most digital signature protocols,

68
00:06:00.100 --> 00:06:03.260 
the asymmetric
cryptosystem of choice.

69
00:06:04.990 --> 00:06:08.100 
So, in that sense,
all attacks against

70
00:06:08.644 --> 00:06:17.540 
RSA encryption methods are also attacks
against RSA based digital signatures.

71
00:06:19.100 --> 00:06:22.810 
When RSA is used
for a signature,

72
00:06:23.570 --> 00:06:30.690 
then typically one uses longer keys
than when the RSA algorithm is used

73
00:06:30.830 --> 00:06:37.450 
for encryption. And this comes from the nature
of digital signatures. Digital signatures

74
00:06:37.730 --> 00:06:44.470 
generally have to be valid for a longer
time than encryption. Encryption has idea

75
00:06:44.670 --> 00:06:47.880 
to confidentially
transmit data.

76
00:06:48.530 --> 00:06:55.680 
With the signature, one wants to
agree on a contract which is valid

77
00:06:55.830 --> 00:07:01.370 
for a longer time, so the
usage of longer keys

78
00:07:01.840 --> 00:07:07.870 
does not result in additional
difficulties to verify such an RSA

79
00:07:08.590 --> 00:07:13.310 
based digital signature,
it works well.

80
00:07:13.510 --> 00:07:18.200 
So, in practice, the
digital signatures work

81
00:07:18.730 --> 00:07:23.180 
very well on the basis
of the RSA system.

82
00:07:24.510 --> 00:07:27.390 
So, let's have a look
at an example.

83
00:07:28.160 --> 00:07:34.710 
And RSA you remember, this was an
asymmetric encryption method

84
00:07:34.980 --> 00:07:39.190 
that was based on the difficulty
and the idea was based

85
00:07:39.640 --> 00:07:43.990 
to find out whether
a very big number

86
00:07:44.850 --> 00:07:50.650 
can be factorized in a smaller
number. And if we remember the

87
00:07:50.840 --> 00:07:57.520 
procedure, then we have to start
to take two large prime numbers,

88
00:07:58.390 --> 00:08:03.150 
then the prime numbers are computed
and all the people that do not know

89
00:08:03.370 --> 00:08:08.750 
that N is a product of these two numbers
P and Q, they have to break the

90
00:08:08.990 --> 00:08:13.500 
encryption method, they have to
find this factorization and

91
00:08:13.500 --> 00:08:14.300 
this is very difficult.

92
00:08:14.950 --> 00:08:21.790 
To produce the public and the
private key, we take a number A

93
00:08:22.160 --> 00:08:27.580 
lower than "phi(N)" and
then we look for B

94
00:08:28.130 --> 00:08:30.390 
such that A
times B is 1.

95
00:08:31.560 --> 00:08:38.670 
And then (N, B) is the public key
from Alice and the private key

96
00:08:38.860 --> 00:08:48.700 
is (N, A). And here also we can
hold A with the numbers P and Q.

97
00:08:49.230 --> 00:08:54.500 
Then the signature algorithm
looks as follows. Alice

98
00:08:54.530 --> 00:08:59.550 
signs the hash value of the
message. This is a message, then

99
00:09:00.000 --> 00:09:04.250 
a hash function is selected
and then a hash value

100
00:09:04.470 --> 00:09:13.133 
is computed out of this message. And you remember
the hash value is a string of limited length

101
00:09:14.116 --> 00:09:18.283 
between 100 and
300 bytes.

102
00:09:18.499 --> 00:09:23.490 
And then Alice
has to encrypt

103
00:09:24.100 --> 00:09:30.300 
this hash value with her
private key and this

104
00:09:30.710 --> 00:09:37.250 
encryption was in a way that we
have to take the message in

105
00:09:37.250 --> 00:09:42.140 
this way, the hash value
and to take it up to

106
00:09:42.216 --> 00:09:46.640 
"A mod(N)"

107
00:09:47.640 --> 00:09:51.900 
So this is a signature, and
together with the message Aice

108
00:09:51.910 --> 00:09:55.150 
send this signature,
this value to Bob,

109
00:09:56.220 --> 00:09:59.460 
and then Bob calculates
on his side the

110
00:09:59.890 --> 00:10:04.520 
message he received M',
eventually this was

111
00:10:05.320 --> 00:10:06.390 
manipulated.

112
00:10:06.990 --> 00:10:10.700 
If it works wells then this
is the original message M,

113
00:10:10.980 --> 00:10:16.240 
so Bob calculates the hash
value of the document M'

114
00:10:16.870 --> 00:10:23.100 
he received and then he verifies the
signature of Alice. And the verification

115
00:10:23.460 --> 00:10:27.200 
function takes
the hash value,

116
00:10:27.440 --> 00:10:29.680 
takes the signature

117
00:10:30.310 --> 00:10:35.100 
which Alice has sent, this was the
hash value of the message M,

118
00:10:35.560 --> 00:10:41.330 
and then this verification says,
yes, if the hash value of M'

119
00:10:41.330 --> 00:10:45.790 
that is computed on Bob's side
agrees with the hash value

120
00:10:46.750 --> 00:10:48.630 
computed on

121
00:10:49.430 --> 00:10:54.390 
on Alice's side
agree and to

122
00:10:54.800 --> 00:11:01.930 
makes this check, Bob needs to
decrypt the digital signature. And

123
00:11:02.260 --> 00:11:09.800 
for decryption, he has to take the public
key and to perform this computation,

124
00:11:10.346 --> 00:11:17.650 
if this is the hash value
computed on Bob's sides and

125
00:11:17.650 --> 00:11:21.630 
it's true, the message was not
manipulated when it was communicated.

126
00:11:21.630 --> 00:11:40.121 
And Alice was the only one who could encrypt this
hash value in such a way that Bob could decrypt

127
00:11:28.300 --> 00:11:32.650 


128
00:11:33.630 --> 00:11:38.410 


129
00:11:40.171 --> 00:11:42.670 
with her public key.

130
00:11:43.790 --> 00:11:48.190 
Let's look at an example for
such an RSA signature.

131
00:11:48.650 --> 00:11:53.720 
Let's take 2 prime numbers,
you remember the RSA

132
00:11:54.120 --> 00:11:59.930 
then has to compute, first the product
of P and Q, this is a big number

133
00:12:00.270 --> 00:12:04.570 
that needs to be factorized
by an attacker.

134
00:12:05.710 --> 00:12:10.980 
Then the "phi" function
needs to be computed. This

135
00:12:11.640 --> 00:12:15.100 
gives this result then
we can take for the

136
00:12:15.750 --> 00:12:20.140 
for the public key
from Alice (B),

137
00:12:20.750 --> 00:12:25.100 
smaller than "phi(N)", let's
take B = 5. Then we have

138
00:12:25.100 --> 00:12:28.710 
to take for the
private key, the

139
00:12:29.640 --> 00:12:35.460 
inverse of 5 which is equal to
44 million and so and so.

140
00:12:35.630 --> 00:12:42.110 
"modulo[phi(n)]". And then as the
public key of Alice is this number

141
00:12:42.210 --> 00:12:46.980 
and the private key is this
number, together with N

142
00:12:47.780 --> 00:12:50.920 
respectively as P
and Q. Now, Alice

143
00:12:52.350 --> 00:12:57.520 
takes a message M, computes the hash
value. Let the hash value be this value,

144
00:12:57.840 --> 00:13:02.450 
31 million and then
she takes this

145
00:13:03.190 --> 00:13:04.630 
value

146
00:13:06.860 --> 00:13:11.980 
and encrypts it. And encrypting
means to put it into the value

147
00:13:12.820 --> 00:13:18.850 
from the private key, this
was here 44 million

148
00:13:19.840 --> 00:13:21.340 
and so on.

149
00:13:21.397 --> 00:13:27.930 
"modulo[phi(n)]", and then
she gets this hash value.

150
00:13:28.680 --> 00:13:32.597 
And then this
hash value

151
00:13:32.897 --> 00:13:38.790 
is the digital
signature. And

152
00:13:38.790 --> 00:13:41.130 
now Alice sends together
with the message M,

153
00:13:42.190 --> 00:13:45.160 
together with this digital
signature to Bob.

154
00:13:46.500 --> 00:13:51.540 
And then Bob first
calculates the hash value.

155
00:13:52.100 --> 00:13:56.760 
It's not clear whether Bob really
computes the hash value of M

156
00:13:57.220 --> 00:14:01.990 
itself, because when M was
transported through the internet

157
00:14:02.230 --> 00:14:07.230 
it could be that someone manipulated
the message. So what Bob

158
00:14:07.240 --> 00:14:13.360 
received is message M' and then
he computes the hash value

159
00:14:13.680 --> 00:14:17.760 
of M' and then he verifies
the signature of Alice.

160
00:14:18.300 --> 00:14:22.570 
So the verification is that the hash
value of the received message

161
00:14:22.980 --> 00:14:30.180 
needs to be equal with the hash
value of the original message M

162
00:14:30.310 --> 00:14:34.960 
which was sent
by Alice.

163
00:14:35.900 --> 00:14:40.990 
And yes, when these
two values agree

164
00:14:41.630 --> 00:14:44.600 
to this end Bob has to

165
00:14:44.890 --> 00:14:49.500 
decrypt the hash as a
digital signature.

166
00:14:49.740 --> 00:14:55.450 
The encrypted hash value of the
document so he has to take the

167
00:14:55.650 --> 00:15:02.150 
public key from Alice and has to put
the thirty million something into the

168
00:15:02.370 --> 00:15:08.820 
power raised to 5 and then "modulo"
this, and in the case, if both agree

169
00:15:09.110 --> 00:15:16.860 
then really the digital signature
worked well and the document arrived

170
00:15:16.980 --> 00:15:18.400 
without any
manipulation.

171
00:15:19.841 --> 00:15:22.910 
When we want to use this
method in practice,

172
00:15:23.380 --> 00:15:26.490 
then we need that
each application

173
00:15:27.224 --> 00:15:35.441 
that creates or deals binding
documents, in a particular case,

174
00:15:35.720 --> 00:15:40.700 
legally binding documents, then this
application should obligatorily be

175
00:15:40.700 --> 00:15:45.200 
equipped with a simple user
interface for signing.

176
00:15:45.450 --> 00:15:48.440 
So, a button for
signing and a button

177
00:15:49.800 --> 00:15:50.840 
for verifying
the message.

178
00:15:52.730 --> 00:15:58.820 
Signing with asymmetric cryptosystem
requires a private key

179
00:15:58.820 --> 00:16:02.760 
of the signee, and the question
is when we apply this in

180
00:16:02.770 --> 00:16:05.300 
practice where this
private key comes from?

181
00:16:06.320 --> 00:16:09.530 
And typically the
situation is that the

182
00:16:10.924 --> 00:16:17.670 
key pair is stored on the computer
in the main memory of the PC

183
00:16:18.891 --> 00:16:24.500 
of the signee or in a smart card.
If we look to the storage in the

184
00:16:24.500 --> 00:16:29.630 
main memory of course the key
needs to be secured and

185
00:16:29.630 --> 00:16:34.780 
needs to be protected.
So, typically one

186
00:16:35.590 --> 00:16:40.280 
needs a password to access
to this a private key.

187
00:16:41.960 --> 00:16:47.890 
What is clear that if this password is
too weak, then also the private key

188
00:16:48.920 --> 00:16:53.510 
is not secure because
then an attacker

189
00:16:54.300 --> 00:16:57.570 
who gets access to
the PC of a person

190
00:16:58.160 --> 00:17:04.190 
can break his password protection and
then can access the private key.

191
00:17:04.700 --> 00:17:08.840 
So, the storage on a memory
stick which is separately

192
00:17:09.990 --> 00:17:14.370 
disclosed from the system is a good
idea or, I already mentioned this

193
00:17:14.370 --> 00:17:19.900 
the best is the storage on a chip card
with a crypto chip for encryption,

194
00:17:20.180 --> 00:17:22.240 
we will discuss
this later.

195
00:17:24.230 --> 00:17:28.750 
To verify signatures based on
asymmetric cryptosystems

196
00:17:29.170 --> 00:17:31.970 
the signee's public
key is required

197
00:17:32.750 --> 00:17:34.960 
and where does
it come from?

198
00:17:36.410 --> 00:17:39.560 
So when binding public
key to their owner,

199
00:17:40.720 --> 00:17:46.330 
then there is a Trust Problem.
The Trust Problem consists of

200
00:17:46.330 --> 00:17:51.640 
the question, is this really the
public key of this person of

201
00:17:51.650 --> 00:17:55.620 
Alice or of Bob and to
solve the trust problem

202
00:17:56.100 --> 00:18:01.350 
we will discuss in more
extent in a later clip,

203
00:18:01.770 --> 00:18:06.990 
to solve is the trust problem a complex infrastructure,
so-called, Public Key Infrastructure (PKI)

204
00:18:07.590 --> 00:18:13.610 
is needed. So in summary, digital
signatures are much more secure

205
00:18:13.610 --> 00:18:18.870 
than signatures by hand and the
technology for digital signature

206
00:18:19.580 --> 00:18:24.990 
is mature and ready. So, we
can use it to increase

207
00:18:25.420 --> 00:18:31.850 
the security in our internet
communication. We can use this

208
00:18:32.440 --> 00:18:36.370 
digital signatures on
one side to prove

209
00:18:36.990 --> 00:18:42.690 
the originality of a document,
we can prove that it's really

210
00:18:42.870 --> 00:18:48.260 
signed by Alice and otherwise we can
use this technique also to check

211
00:18:48.440 --> 00:18:50.150 
the integrity of

212
00:18:51.580 --> 00:18:54.410 
the message transported
through the internet,

213
00:18:54.860 --> 00:19:00.110 
because if the decrypted
hash value of the message

214
00:19:00.510 --> 00:19:05.700 
which was sent in the digital
signature does not agree with

215
00:19:05.700 --> 00:19:08.270 
the hash value of the received
message, then the reason could

216
00:19:08.270 --> 00:19:13.350 
also be that the message was manipulated
on its path through the internet.

217
00:19:14.400 --> 00:19:18.700 
There are, in
many countries,

218
00:19:20.200 --> 00:19:23.700 
signature legislations,

219
00:19:24.690 --> 00:19:31.100 
legal frameworks, for example, in the
European counties, in Germany, in the UK

220
00:19:31.920 --> 00:19:37.540 
which guarantees that digital
signatures could also be used

221
00:19:37.740 --> 00:19:39.530 
to sign digital
contracts.

222
00:19:41.990 --> 00:19:48.330 
The state is responsible for the digital
identification of its citizens,

223
00:19:48.820 --> 00:19:51.210 
the existence
of systems

224
00:19:52.640 --> 00:19:55.450 
where one can buy
such a certificate

225
00:19:56.120 --> 00:20:01.180 
which are needed for the
digital signatures,

226
00:20:01.430 --> 00:20:06.740 
but for all communication at least
communication with the state authorities

227
00:20:07.750 --> 00:20:11.290 
the state should provide
a framework for

228
00:20:11.940 --> 00:20:18.300 
digital identifications so that the
digital signatures can really

229
00:20:18.450 --> 00:20:21.170 
be applied also in
our practical life.
