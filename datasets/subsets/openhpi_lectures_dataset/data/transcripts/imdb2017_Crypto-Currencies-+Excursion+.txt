WEBVTT

1
00:00:00.000 --> 00:00:04.400 
Lets have a look how
a cryptocurrency,

2
00:00:04.400 --> 00:00:07.700 
a basic one works, so what
we need in order to design

3
00:00:08.800 --> 00:00:11.110 
basically a cryptocurrency.
The ingredients that we need

4
00:00:11.110 --> 00:00:15.150 
are private/public
key, cryptography

5
00:00:15.150 --> 00:00:19.190 
for signatures, to declare
ownership and transact ownership,

6
00:00:19.190 --> 00:00:22.220 
and hash functions for
different purposes.

7
00:00:23.230 --> 00:00:26.260 
I assume you're all familiar
with these concepts.

8
00:00:27.270 --> 00:00:31.310 
Now in order to
claim ownership

9
00:00:32.320 --> 00:00:34.340 
of a digital piece
of information, lets

10
00:00:35.350 --> 00:00:39.390 
assume it's just a number,
the coin ID, I can go ahead

11
00:00:39.390 --> 00:00:43.430 
and sign it with my
private key, so then

12
00:00:43.430 --> 00:00:46.460 
this coin ID plus my
signature is basically

13
00:00:46.460 --> 00:00:50.500 
the claim, my
claim of ownership

14
00:00:50.500 --> 00:00:53.530 
of this kind. If someone sees
this they can prove with my

15
00:00:53.530 --> 00:00:57.570 
public key that it was me who
signed it and that is me who

16
00:00:57.570 --> 00:01:01.610 
owns it. Now I can
go along and say I

17
00:01:02.620 --> 00:01:06.660 
create a statement saying, I
as the owner of the public key

18
00:01:06.660 --> 00:01:10.700 
A transact this coin
ID with my signature

19
00:01:10.700 --> 00:01:14.740 
to someone else the public key
of B and then i take this will

20
00:01:14.740 --> 00:01:16.760 
transaction and sign
it with my private key

21
00:01:17.770 --> 00:01:22.820 
so this would be here. Then anybody
who sees these two transactions

22
00:01:22.820 --> 00:01:27.870 
can see, ah in the first place
it was me, A who owned this coin

23
00:01:27.870 --> 00:01:32.920 
and then I had the
intention to transact

24
00:01:32.920 --> 00:01:38.980 
this coin or this digital asset
to B. Then B can do the same,

25
00:01:38.980 --> 00:01:42.102 
B can transact it to C
and so on. By using the

26
00:01:42.102 --> 00:01:45.105 
public and private key
we can always prove

27
00:01:46.106 --> 00:01:49.109 
the identities or whether
it was the intent of the

28
00:01:49.109 --> 00:01:53.113 
signing party to
transact it. Now if you

29
00:01:53.113 --> 00:01:55.115 
want to know what is
my balance in the end,

30
00:01:56.116 --> 00:02:00.120 
so how much coins do I have, you
need to have kind of the temporal,

31
00:02:00.120 --> 00:02:04.124 
an idea of time, temporal
ordering of these transactions.

32
00:02:04.124 --> 00:02:08.000 
You need to know what is the
current state of the system,

33
00:02:08.128 --> 00:02:12.132 
what is my current account
balance. Therefore we need to

34
00:02:12.132 --> 00:02:16.136 
create this notion of time by
chaining these transactions.

35
00:02:17.137 --> 00:02:19.139 
We could just chain
the transactions or

36
00:02:20.140 --> 00:02:23.143 
what is practically done, these
transactions are grouped into blocks

37
00:02:23.143 --> 00:02:26.146 
and then these blocks are
chained and that's where the name

38
00:02:26.146 --> 00:02:28.148 
block chain originates.

39
00:02:30.150 --> 00:02:33.153 
In order to chain
these blocks,

40
00:02:33.153 --> 00:02:36.156 
we use a hash pointer. A
hash pointer is a pointer

41
00:02:36.156 --> 00:02:39.159 
which additionally to the pointer
information stores also the

42
00:02:39.159 --> 00:02:41.161 
hash of the object
that it is pointing to.

43
00:02:42.162 --> 00:02:46.166 
Here we see the pointer and
the hash of the previous block.

44
00:02:46.166 --> 00:02:49.169 
Then this creates a
hash chain of blocks

45
00:02:50.170 --> 00:02:52.172 
and now the hash function
has some nice properties

46
00:02:53.173 --> 00:02:57.177 
we can not learn about,
it's hiding, we can not

47
00:02:57.177 --> 00:02:59.179 
learn about the content
for just from the hash.

48
00:02:59.179 --> 00:03:01.181 
Just from the finger
print, we can not,

49
00:03:02.182 --> 00:03:05.185 
we do not know what was
the object that was hashed

50
00:03:05.185 --> 00:03:09.189 
and it is binding in the sense
that if someone changes something

51
00:03:09.189 --> 00:03:12.192 
here then the hash of
the pointer will change.

52
00:03:13.193 --> 00:03:18.198 
This hash chain can be
easily calculated if you have

53
00:03:18.198 --> 00:03:21.201 
the data and thereby
you can verify whether

54
00:03:21.201 --> 00:03:25.205 
all the information contained
in the blocks is still the same

55
00:03:25.205 --> 00:03:29.209 
as at the time when they were
created. This creates a very

56
00:03:29.209 --> 00:03:31.211 
easy proof of
"tamper-proofness."

57
00:03:34.214 --> 00:03:39.219 
In a block we gather
certain information,

58
00:03:39.219 --> 00:03:43.223 
we have the hash pointer
to the previous block,

59
00:03:43.223 --> 00:03:45.225 
we have a header with
some information on

60
00:03:46.226 --> 00:03:48.228 
who created the
block and when

61
00:03:48.228 --> 00:03:52.232 
was it created and so on and
so forth. Then we have a list

62
00:03:52.232 --> 00:03:56.236 
of valid transactions, so these
are basically in simplified

63
00:03:56.236 --> 00:04:00.240 
version, inputs and
outputs of transactions.

64
00:04:00.240 --> 00:04:06.246 
Inputs are outputs from previous
blocks that can be consumed

65
00:04:06.246 --> 00:04:11.251 
and then they are used and they
are spent and they generate outputs

66
00:04:11.251 --> 00:04:16.256 
which in turn can be used in
subsequent transactions in the

67
00:04:16.256 --> 00:04:19.259 
next blocks to come. This
is the basic structure

68
00:04:19.259 --> 00:04:23.263 
and so un-spent output
transactions are

69
00:04:23.263 --> 00:04:27.267 
what we name bitcoin or the
digital asset that we are talking

70
00:04:27.267 --> 00:04:33.273 
about. If we have such a
system and everybody agrees on

71
00:04:33.273 --> 00:04:37.277 
this common state, so
on one block chain,

72
00:04:38.278 --> 00:04:41.281 
then we're done then we
have a cryptocurrency.

73
00:04:41.281 --> 00:04:44.284 
People can participate in this
by using the public and private

74
00:04:44.284 --> 00:04:48.288 
key and you can always look
up on the block chain who owns

75
00:04:48.288 --> 00:04:50.290 
what and how much and
you can not change it

76
00:04:50.290 --> 00:04:53.293 
because otherwise this hash
chain will be broken and people

77
00:04:53.293 --> 00:04:56.296 
will see that you're trying
to tamper with the system.

78
00:04:57.297 --> 00:05:01.301 
Now the problem arises in a
decentralized system, if you do

79
00:05:01.301 --> 00:05:04.304 
not have someone that tells
you this is the truth.

80
00:05:04.304 --> 00:05:09.309 
In a de-centralized system I
could also go ahead and sign

81
00:05:09.309 --> 00:05:12.312 
a different transaction
and then put it together

82
00:05:12.312 --> 00:05:14.314 
in a block with other
valid transactions

83
00:05:14.314 --> 00:05:18.318 
and reference back to the first
block so this is a valid block.

84
00:05:19.319 --> 00:05:23.323 
Because at this point
in time here I can still

85
00:05:23.323 --> 00:05:28.328 
spend my funds, now these two
blocks are conflicting, there is

86
00:05:28.328 --> 00:05:32.332 
a double spend and
now if I were B or D

87
00:05:32.332 --> 00:05:36.336 
I want, I will not accept both
of them because one of the two

88
00:05:36.336 --> 00:05:39.339 
should have the funds
in the end and the whole

89
00:05:40.340 --> 00:05:44.344 
problem, this design challenge
of preventing double spends is

90
00:05:44.344 --> 00:05:47.347 
located here. How to
create an algorithm

91
00:05:47.347 --> 00:05:51.351 
that prevents this
kind of behavior or

92
00:05:51.351 --> 00:05:56.356 
punishes it such that
we have a system where

93
00:05:56.356 --> 00:05:58.358 
everybody agrees on
one chain in the end.

94
00:05:59.359 --> 00:06:03.363 
This is what a
consensus algorithm

95
00:06:03.363 --> 00:06:09.369 
does. In bitcoin we have
a consensus protocol

96
00:06:09.369 --> 00:06:14.374 
that uses a proof of work,
let's go step by step

97
00:06:14.374 --> 00:06:17.377 
through this protocol
and see where it goes.

98
00:06:18.378 --> 00:06:21.381 
If someone sends a transaction,
some user sends a transaction

99
00:06:21.381 --> 00:06:27.387 
wants to pay beer in a bar then
they need their private public

100
00:06:28.388 --> 00:06:31.391 
key pair for signing the
transaction as we discussed

101
00:06:31.391 --> 00:06:34.394 
and then this transaction is
broadcast on the network to all

102
00:06:34.394 --> 00:06:36.396 
the nodes that are
participating in the network.

103
00:06:37.397 --> 00:06:41.401 
These nodes that are
participating collect

104
00:06:41.401 --> 00:06:44.404 
transactions and group
them into blocks and

105
00:06:45.000 --> 00:06:48.408 
so they have a local view on the
block chain, they have basically

106
00:06:48.408 --> 00:06:51.411 
a local state and based
on this local state

107
00:06:51.411 --> 00:06:54.414 
they check whether the
transactions they receive are valid

108
00:06:54.414 --> 00:06:59.419 
or not. Then they group a set
of valid transactions into

109
00:06:59.419 --> 00:07:03.423 
a new block and try to

110
00:07:03.423 --> 00:07:06.426 
yeah. Then the question arises,
who may write the next block

111
00:07:06.426 --> 00:07:09.429 
to the block chain. We can not
allow everybody to write at

112
00:07:09.429 --> 00:07:11.431 
the same time because
then we run into the

113
00:07:12.432 --> 00:07:13.433 
multi concurrent
write problem.

114
00:07:14.434 --> 00:07:18.438 
Bitcoin uses a lottery race
which is called proof of work

115
00:07:18.438 --> 00:07:20.440 
in order to restrict write
access to the block chain.

116
00:07:21.441 --> 00:07:26.446 
This lottery race
determines who gets to

117
00:07:26.446 --> 00:07:30.450 
append his or her block
to the block chain

118
00:07:30.450 --> 00:07:32.452 
and the nodes try to
solve this lottery race

119
00:07:33.453 --> 00:07:35.455 
in order to find a block
that can be appended.

120
00:07:36.456 --> 00:07:41.461 
Now if a node finds this,
he broadcasts the new block

121
00:07:41.461 --> 00:07:45.465 
on the network and the
other nodes will check

122
00:07:45.465 --> 00:07:48.468 
whether the transactions
within the block are valid

123
00:07:49.469 --> 00:07:52.472 
based on the history that this
block refers to, so based on

124
00:07:52.472 --> 00:07:55.475 
the hash pointer and
the chain and then

125
00:07:55.475 --> 00:07:58.478 
if it was valid they accept it,
take the transactions within

126
00:07:58.478 --> 00:08:03.483 
the block and update the
local state. Then they express

127
00:08:03.483 --> 00:08:07.487 
their acceptance by starting
the whole process again based

128
00:08:07.487 --> 00:08:10.490 
on the new state, so based on
this new block they will again

129
00:08:10.490 --> 00:08:14.494 
gather transactions, group them
into blocks and so on and try

130
00:08:14.494 --> 00:08:17.497 
to start the next to win
the next lottery race.

131
00:08:19.499 --> 00:08:21.501 
The lottery race works
roughly as follows.

132
00:08:22.502 --> 00:08:25.505 
It is a computational puzzle,
the proof of work that has to

133
00:08:25.505 --> 00:08:28.508 
be done in order to obtain
write access and the

134
00:08:29.509 --> 00:08:32.512 
nodes that try to solve this puzzle
are usually referred to as miners.

135
00:08:33.513 --> 00:08:35.515 
Probably you might have
heard of this or actually

136
00:08:35.515 --> 00:08:38.518 
you might mine yourself or
have mined at some point.

137
00:08:38.518 --> 00:08:42.522 
The idea is that we
have a hash puzzle

138
00:08:43.523 --> 00:08:46.526 
that is, we calculate
the hash of the block

139
00:08:46.526 --> 00:08:49.529 
and we want this hash that
can be interpreted as a number

140
00:08:49.529 --> 00:08:52.532 
to be smaller than a given
threshold that is agreed upon by

141
00:08:52.532 --> 00:08:57.537 
the network. The
block consists of

142
00:08:57.537 --> 00:09:01.541 
some transactions data, the
hash of the previous block which

143
00:09:01.541 --> 00:09:04.544 
indicates basically at what time
or what position in the block chain

144
00:09:04.544 --> 00:09:08.548 
we are. What is the local
state that we refer to

145
00:09:08.548 --> 00:09:12.552 
and then we have a nonce which
is again kind of a number

146
00:09:12.552 --> 00:09:15.555 
that can be changed.
By changing this number

147
00:09:16.556 --> 00:09:20.560 
we can change the hash and we
can try many nonces until we

148
00:09:20.560 --> 00:09:22.562 
find a hash that is
small enough to fulfill

149
00:09:22.562 --> 00:09:26.566 
this relationship. This is a
very hard and demanding puzzle

150
00:09:26.566 --> 00:09:29.569 
because many people
try to solve it and

151
00:09:30.570 --> 00:09:34.574 
if you manage to
find such a hash then

152
00:09:34.574 --> 00:09:38.578 
you can broadcast this block
with this hash and the nonce

153
00:09:38.578 --> 00:09:42.582 
to the network and they will
verify whether you fulfill this

154
00:09:42.582 --> 00:09:46.586 
requirement and then if you
fulfill it and the block is valid

155
00:09:46.586 --> 00:09:51.591 
then it is added to the block
chain. Now we need an additional

156
00:09:51.591 --> 00:09:58.598 
rule, assume now
this it can happen

157
00:09:58.598 --> 00:10:02.602 
and happens actually
frequently that in the network

158
00:10:02.602 --> 00:10:07.607 
two nodes find a valid block
with fulfilling this condition

159
00:10:08.608 --> 00:10:10.610 
roughly at
the same time.

160
00:10:10.610 --> 00:10:13.613 
Because you have network latency
and it's not fully connected

161
00:10:13.613 --> 00:10:17.617 
the network then might be
partitioned into one part of the

162
00:10:17.617 --> 00:10:20.620 
network that sees the one block
first and another part that

163
00:10:20.620 --> 00:10:23.623 
sees the other block first.
Then you are in such a situation

164
00:10:23.623 --> 00:10:27.627 
where you have a temporary
splitting of the chain into

165
00:10:27.627 --> 00:10:31.631 
two parallel chains. Another
question arises, how to deal with

166
00:10:31.631 --> 00:10:35.635 
this problem. These two could
actually be conflicting, there

167
00:10:35.635 --> 00:10:37.637 
could be one transaction
with a double spend inside

168
00:10:38.638 --> 00:10:42.642 
and now we want to find a way
how to how the whole network

169
00:10:42.642 --> 00:10:46.646 
can agree upon one
version of the history and

170
00:10:47.000 --> 00:10:53.653 
decide which chain to continue.
The convention is that the

171
00:10:53.653 --> 00:10:57.657 
longest chain should win, so
if you are in such a scenario

172
00:10:57.657 --> 00:11:01.661 
then the different parts of the
network will continue working

173
00:11:01.661 --> 00:11:03.663 
on their respective
version of the block chain

174
00:11:04.664 --> 00:11:07.667 
and then at some point
one of the two will find

175
00:11:07.667 --> 00:11:10.670 
a block earlier than the other
part of the network. Then

176
00:11:10.670 --> 00:11:13.673 
we have the situation is
shown here where there is one

177
00:11:14.674 --> 00:11:15.675 
parallel chain longer
than the other one

178
00:11:16.676 --> 00:11:19.679 
and then the convention is
that the longer chain wins.

179
00:11:19.679 --> 00:11:24.684 
Now why should a node
or a miner actually

180
00:11:24.684 --> 00:11:28.688 
do this? What is the interest
in doing all this proof

181
00:11:28.688 --> 00:11:31.691 
of work and what is the
interest, the incentive of

182
00:11:31.691 --> 00:11:36.696 
of actually sticking to the main
chain and not working on some

183
00:11:36.696 --> 00:11:40.700 
parallel chain. These
are the incentives

184
00:11:40.700 --> 00:11:43.703 
that I talked about in the first
place, so the winner of this

185
00:11:43.703 --> 00:11:46.706 
lottery race gets a
reward. There is some

186
00:11:46.706 --> 00:11:50.710 
block reward so if
you are the one,

187
00:11:50.710 --> 00:11:53.713 
the node that finds
the block, you get some

188
00:11:54.714 --> 00:11:58.718 
coins in the currency of
the system and these coins

189
00:11:59.719 --> 00:12:02.722 
you can spend then
in later transaction.

190
00:12:02.722 --> 00:12:06.726 
You hope that when these
coins or the system acquire

191
00:12:06.726 --> 00:12:10.730 
some value, that you can exchange
to normal convention money

192
00:12:10.730 --> 00:12:14.734 
at some point or whatever.
Now the incentive is that

193
00:12:15.735 --> 00:12:18.738 
you better make sure that the
block you find is on the main

194
00:12:18.738 --> 00:12:21.741 
chain because if you're
in a parallel chain

195
00:12:22.742 --> 00:12:26.746 
and you mine a lot of nodes,
eventually, a lot of blocks,

196
00:12:27.747 --> 00:12:31.751 
then nobody cares.
You will own a lot of

197
00:12:31.751 --> 00:12:35.755 
currency but if everybody
else only accepts the

198
00:12:35.755 --> 00:12:38.758 
transactions that are
in the longest chain

199
00:12:38.758 --> 00:12:42.762 
basically you're creating
data that nobody will

200
00:12:42.762 --> 00:12:47.767 
accept. Therefore as
node that is mining

201
00:12:47.767 --> 00:12:50.770 
you always want to be sure
that you working on the

202
00:12:51.771 --> 00:12:54.774 
part of the chain that is most
likely to be the longest one

203
00:12:54.774 --> 00:12:58.778 
and therefore an attacker
that wants to double spend

204
00:12:59.779 --> 00:13:02.782 
has to have a lot of computation
power to be faster than the

205
00:13:02.782 --> 00:13:05.785 
majority of the network,
in order to create a chain

206
00:13:05.785 --> 00:13:10.790 
that is faster than
the majority that works

207
00:13:10.790 --> 00:13:13.793 
on one chain and this
is very unlikely in a

208
00:13:13.793 --> 00:13:17.797 
de-centralized system where
there are lots of participants

209
00:13:17.797 --> 00:13:21.801 
with their hashing power and you
as a single institution or as

210
00:13:21.801 --> 00:13:25.805 
a single actor in the system will
not have enough hashing power

211
00:13:25.805 --> 00:13:28.808 
to overtake, basically, the whole
network or the majority of network.

212
00:13:30.810 --> 00:13:34.814 
Now as I said, the nodes, the
miners actually validate whether

213
00:13:34.814 --> 00:13:38.818 
the transactions are valid or
not and to do this they run some

214
00:13:38.818 --> 00:13:42.822 
code locally on their nodes.
Now instead of just having funds

215
00:13:42.822 --> 00:13:45.825 
in these transactions
or numbers basically

216
00:13:45.825 --> 00:13:48.828 
you can also have code
snippets inside, so you

217
00:13:48.828 --> 00:13:53.833 
can embed some application
logic into the transaction

218
00:13:54.834 --> 00:13:57.837 
and then it is executed by the
nodes when they try to validate

219
00:13:57.837 --> 00:14:03.000 
the transaction and this
embedded code in the block chain

220
00:14:03.843 --> 00:14:06.846 
that is then executed de-centrally
by all the participating

221
00:14:06.846 --> 00:14:09.849 
nodes is referred to
as a smart contract.

222
00:14:09.849 --> 00:14:12.852 
It's a very
interesting development

223
00:14:13.853 --> 00:14:18.858 
that because it allows
to have kind of business

224
00:14:18.858 --> 00:14:22.862 
contracts executed
de-centrally on the block chain

225
00:14:22.862 --> 00:14:26.866 
so that we have an automation
of the rule execution and

226
00:14:26.866 --> 00:14:30.870 
not somebody that can
still change the rules

227
00:14:30.870 --> 00:14:35.875 
or prevent this code
to run in the end. This

228
00:14:36.876 --> 00:14:39.879 
poses some interesting
questions, so challenges.

229
00:14:40.880 --> 00:14:46.886 
In the conventional way of
contracting by convention

230
00:14:46.886 --> 00:14:48.888 
law, we want
to be able to

231
00:14:49.889 --> 00:14:51.891 
go back to the so-called
status until so

232
00:14:52.892 --> 00:14:55.895 
if someone deceives
us about the

233
00:14:55.895 --> 00:14:59.899 
property or whatever the
conditions under which you

234
00:14:59.899 --> 00:15:04.904 
will agree to go into contract,
then we want to be able

235
00:15:04.904 --> 00:15:08.908 
to cancel everything and go
back to the status that was

236
00:15:08.908 --> 00:15:13.913 
before. Now with this concept
here the code is out there

237
00:15:13.913 --> 00:15:17.917 
in a decentralized system where
nobody has authority to actually

238
00:15:17.917 --> 00:15:20.920 
control it and eventually if
the condition that is written

239
00:15:20.920 --> 00:15:24.924 
in the contract is applied,
it will be executed

240
00:15:24.924 --> 00:15:28.928 
and whatever has been
agreed on is done.

241
00:15:28.928 --> 00:15:31.931 
Then you can not go
somewhere to court and say

242
00:15:31.931 --> 00:15:35.935 
I want my money back,
it's just enforcing itself

243
00:15:35.935 --> 00:15:40.940 
without any authority regulating
it. This is, to some extent,

244
00:15:40.940 --> 00:15:43.943 
very interesting because you can
not afterwards change the rules

245
00:15:43.943 --> 00:15:47.947 
easily so it has a purpose but
it's also dangerous because

246
00:15:47.947 --> 00:15:52.952 
you can do crazy and also
illegal stuff with it

247
00:15:52.952 --> 00:15:58.958 
and that's a very, this aspect
here is very interesting

248
00:15:58.958 --> 00:16:01.961 
how to interpret
and deal with this

249
00:16:01.961 --> 00:16:04.964 
automatic execution that
nobody can control afterwards.

250
00:16:04.964 --> 00:16:08.968 
Additionally we
have this idea that

251
00:16:09.969 --> 00:16:12.972 
when the code runs on the block
chain this is quite expensive

252
00:16:12.972 --> 00:16:15.975 
in the sense that the
transactions have to be small

253
00:16:16.976 --> 00:16:19.979 
and it is run de-centrally
at many instances.

254
00:16:19.979 --> 00:16:23.983 
Now the question arises, how
much of application logic do

255
00:16:23.983 --> 00:16:26.986 
you want to put de-central,
transparent to everybody

256
00:16:26.986 --> 00:16:29.989 
and how much do you keep
in your application on top,

257
00:16:29.989 --> 00:16:33.993 
that is just visible to you.
How much transparency do you

258
00:16:33.993 --> 00:16:36.996 
need, on the smart contract
and how much can you

259
00:16:36.996 --> 00:16:39.999 
keep in the regular
application.

260
00:16:41.100 --> 00:16:49.100 
Just a brief thing here, bitcoin
somehow supports scripting

261
00:16:49.100 --> 00:16:51.101 
language but the
main platform

262
00:16:51.101 --> 00:16:55.101 
implementing smart
contracts in a decentralized

263
00:16:55.101 --> 00:16:59.101 
public block chain is
the ethereum platform.

264
00:17:00.102 --> 00:17:04.102 
I will not go into to this here
because it's just an overview,

265
00:17:04.102 --> 00:17:08.102 
a general one, but it's a
very important concept and

266
00:17:08.102 --> 00:17:13.103 
I just wanted to mention it. To
recap about cryptocurrencies,

267
00:17:13.103 --> 00:17:18.103 
we have this de-centralization
in an open peer to

268
00:17:18.103 --> 00:17:20.104 
peer network where we have no
trust between the participants

269
00:17:20.104 --> 00:17:23.104 
and no central authority
than can create this trust.

270
00:17:23.104 --> 00:17:27.104 
The miners validate the protocol,
their influences determined by the

271
00:17:27.104 --> 00:17:31.105 
hash power they control and
this creates a tamper-proof hash

272
00:17:31.105 --> 00:17:34.105 
chain. For consensus we have
this block creation lottery that

273
00:17:34.105 --> 00:17:38.105 
is called proof of work, via a
hash puzzle we have conventions

274
00:17:38.105 --> 00:17:41.106 
like the longest chain
wins. It's a probabilistic

275
00:17:41.106 --> 00:17:45.106 
consensus in the sense
that you do not know when

276
00:17:45.106 --> 00:17:47.106 
the block is written, whether it
will end up in the main chain or

277
00:17:47.106 --> 00:17:53.107 
not. It's not deterministic
but the probability

278
00:17:53.107 --> 00:17:56.107 
will increase with
more confirmation.

279
00:17:57.107 --> 00:18:00.108 
You have mining incentives
to incentivize all the people

280
00:18:00.108 --> 00:18:03.108 
that can participate in the
network to behave in a way such

281
00:18:03.108 --> 00:18:06.108 
that you prevent double
spending and so on.

282
00:18:06.108 --> 00:18:12.109 
Of course there are
limitations, so I

283
00:18:13.109 --> 00:18:17.109 
want to single out three
here, this is a very

284
00:18:17.109 --> 00:18:21.110 
challenging problem
setting that we now can

285
00:18:21.110 --> 00:18:24.110 
solve with an algorithmic
solution that was not

286
00:18:25.110 --> 00:18:28.110 
easy or is not easy to
solve in another way

287
00:18:28.110 --> 00:18:31.111 
and of course you have
to pay a price for that

288
00:18:31.111 --> 00:18:36.111 
and this price is quite high.
The proof work is very expensive,

289
00:18:36.111 --> 00:18:39.111 
many miners use a
lot of electricity to

290
00:18:39.111 --> 00:18:43.112 
calculate this hash
puzzle. Right now

291
00:18:43.112 --> 00:18:48.112 
the yearly, the annual
electricity consumption of the

292
00:18:48.112 --> 00:18:51.113 
bitcoin network is
roughly the same as of the

293
00:18:51.113 --> 00:18:56.113 
country Slovenia. You
can argue that this

294
00:18:56.113 --> 00:18:59.113 
is a waste or you can
argue that this is

295
00:18:59.113 --> 00:19:01.114 
the price that we have
to pay to solve this

296
00:19:02.114 --> 00:19:04.114 
problem in an
algorithmic way.

297
00:19:06.114 --> 00:19:09.114 
The protocol has a
rather low throughput

298
00:19:10.115 --> 00:19:13.115 
so theoretically seven
transactions per second,

299
00:19:13.115 --> 00:19:16.115 
that has to be compared with
like VISA which supports

300
00:19:16.115 --> 00:19:18.115 
hundred thousands of
transactions per second.

301
00:19:18.115 --> 00:19:22.116 
This thing is
not suited for

302
00:19:23.116 --> 00:19:27.116 
replacing all the de-central
or payment systems that we have

303
00:19:27.116 --> 00:19:32.117 
in place. You have,
require full replication

304
00:19:32.117 --> 00:19:34.117 
so everybody that
contributes in this network

305
00:19:35.117 --> 00:19:37.117 
should have the full block
chain copied locally, so

306
00:19:38.117 --> 00:19:43.118 
this is also becomes expensive
as the block chain increases.

307
00:19:44.118 --> 00:19:50.119 
After having a talked about the
bitcoin or cryptocurrency use

308
00:19:50.119 --> 00:19:54.119 
case we now can turn, lets
say our attention to the

309
00:19:54.119 --> 00:19:58.119 
underlying architectural
concept, the block chain,

310
00:19:58.119 --> 00:20:02.120 
that enables this de-centralized
and secure and direct transfer

311
00:20:02.120 --> 00:20:07.120 
of digital
assets. Of course,

312
00:20:09.120 --> 00:20:10.121 
so far we talked about

313
00:20:13.121 --> 00:20:17.121 
public application, so
that is open to everybody.

314
00:20:17.121 --> 00:20:20.122 
Everyone who can download
the protocol and run a node

315
00:20:20.122 --> 00:20:24.122 
can participate in this network,
they can all read it so fetch

316
00:20:24.122 --> 00:20:28.122 
information and if they solve
this lottery race then they can

317
00:20:28.122 --> 00:20:33.123 
also all write to the block
chain. It's a permission-less

318
00:20:33.123 --> 00:20:38.123 
public deployment of the
blockchain. Now in order to tackle

319
00:20:38.123 --> 00:20:40.124 
these restrictions that
we just talked about, like

320
00:20:41.124 --> 00:20:43.124 
the costs and the
low throughput

321
00:20:44.124 --> 00:20:47.124 
and for different
applications we might to

322
00:20:48.124 --> 00:20:51.125 
change or further
developed the technology.

323
00:20:51.125 --> 00:20:54.125 
If we're talking about
business applications

324
00:20:54.125 --> 00:20:58.125 
then we are often not
in this open scenario.

325
00:20:59.125 --> 00:21:04.126 
If we are in a scenario where
we actually know the partners

326
00:21:04.126 --> 00:21:09.126 
with which we interact,
then we have identities.

327
00:21:09.126 --> 00:21:11.127 
Instead of everybody
being able to join

328
00:21:11.127 --> 00:21:16.127 
we have a set of
pre-selected players

329
00:21:17.127 --> 00:21:20.128 
that we know before hand and
with whom we can agree on the

330
00:21:20.128 --> 00:21:25.128 
rules. It's a permission
block chain where access, read

331
00:21:25.128 --> 00:21:28.128 
and write access can be
restricted. This is a completely

332
00:21:28.128 --> 00:21:32.129 
different algorithmic
problem and while this

333
00:21:33.129 --> 00:21:37.129 
has been solved kind of by
bitcoin or cryptocurrencies,

334
00:21:37.129 --> 00:21:41.130 
this goes much closer or rather
in the direction of state-machine

335
00:21:41.130 --> 00:21:44.130 
replication that we
already know since decades.

336
00:21:46.130 --> 00:21:49.130 
In both scenarios we need a
consensus algorithm in order

337
00:21:49.130 --> 00:21:52.131 
to agree who may write at what
time if we have conflicting

338
00:21:52.131 --> 00:21:55.131 
write accesses
and if we do not

339
00:21:56.131 --> 00:22:00.132 
trust the other parties to a
full extent. This is the key

340
00:22:00.132 --> 00:22:02.132 
question, how much do
we trust each other.

341
00:22:02.132 --> 00:22:05.132 
In a public block chain, as I
said, we do not trust them at all

342
00:22:05.132 --> 00:22:09.132 
and we use the proof of
work to have a consistent

343
00:22:09.132 --> 00:22:13.133 
block creation where we
have anonymous participants.

344
00:22:13.133 --> 00:22:17.133 
Now in consortium
block chain where

345
00:22:17.133 --> 00:22:21.134 
we agree and know who is
part of this block chain,

346
00:22:21.134 --> 00:22:23.134 
we also need a
consensus algorithm

347
00:22:23.134 --> 00:22:28.134 
but we have known participants
and therefore we can deploy

348
00:22:28.134 --> 00:22:34.135 
other kinds of algorithms. In
bitcoin or ethereum we currently

349
00:22:34.135 --> 00:22:37.135 
use proof of work that we
discussed, so this lottery.

350
00:22:38.135 --> 00:22:43.136 
It basically assumes that the
majority of the hashing power

351
00:22:43.136 --> 00:22:47.136 
is not centralized to
one player that tries to

352
00:22:47.136 --> 00:22:50.137 
attack the network. As soon
as someone has more than 50%

353
00:22:50.137 --> 00:22:53.137 
of the hashing power
they could in principle

354
00:22:53.137 --> 00:22:55.137 
create a chain that grows
faster than the other

355
00:22:56.137 --> 00:22:59.137 
chain and then determine the
rules. As we already discussed

356
00:22:59.137 --> 00:23:02.138 
this was kind of
undermine the reputation

357
00:23:03.138 --> 00:23:06.138 
of the system, the
credibility and probably it

358
00:23:06.138 --> 00:23:10.139 
would make it worthless. This
is a bit questionable whether

359
00:23:10.139 --> 00:23:14.139 
this is actually
reasonable attack. Now in

360
00:23:14.139 --> 00:23:18.139 
a consortium application

361
00:23:19.139 --> 00:23:23.140 
we have different
algorithms, for example,

362
00:23:23.140 --> 00:23:27.140 
practical byzantine fault
tolerance, which is an

363
00:23:27.140 --> 00:23:31.141 
algorithm that we know from
distributed databases state-machine

364
00:23:31.141 --> 00:23:35.141 
replication that tolerates that
a fraction of the participating

365
00:23:35.141 --> 00:23:38.141 
nodes actually has
an arbitrary failure.

366
00:23:38.141 --> 00:23:42.142 
Since we know who is part of
this network, so we have a

367
00:23:42.142 --> 00:23:46.142 
set of n nodes that
participate. If we assume that

368
00:23:47.142 --> 00:23:51.143 
there are not too many malicious
nodes then we can use this algorithm

369
00:23:51.143 --> 00:23:55.143 
and it's much more
efficient, much faster, has

370
00:23:55.143 --> 00:23:57.143 
higher throughput, etc.
