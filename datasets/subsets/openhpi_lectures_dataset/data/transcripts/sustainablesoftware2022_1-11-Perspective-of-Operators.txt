WEBVTT

1
00:00:00.900 --> 00:00:04.090 
Hi. Today we're going to look at the perspective of operators

2
00:00:04.090 --> 00:00:07.560 
working in a software engineering team that wants to adopt

3
00:00:07.560 --> 00:00:09.690 
sustainable software engineering practices.

4
00:00:11.360 --> 00:00:15.100 
Operators in a sustainable software engineering team are tasked

5
00:00:15.100 --> 00:00:18.370 
with taking care of infrastructure, deploying the application.

6
00:00:19.350 --> 00:00:24.410 
If we look at the tasks that they do in day to day work, they

7
00:00:24.410 --> 00:00:27.680 
might be working with provisioning and managing infrastructure,

8
00:00:27.760 --> 00:00:31.820 
making sure that the infrastructure meets the performance requirements of the application

9
00:00:32.240 --> 00:00:35.590 
and making sure that the infrastructure is also used efficiently

10
00:00:35.590 --> 00:00:39.760 
so that it meets cost and hopefully also sustainability goals.

11
00:00:40.820 --> 00:00:45.630 
Other things like taking care of backups, disaster recovery,

12
00:00:45.770 --> 00:00:49.830 
making sure there's logging and monitoring to support the operations of the application.

13
00:00:51.140 --> 00:00:55.020 
Operators cannot really work alone on this. They need to collaborate

14
00:00:55.020 --> 00:00:58.150 
with the other roles in the software engineering team and this

15
00:00:58.150 --> 00:01:02.220 
is especially critical if we want to make use or efficient use of infrastructure.

16
00:01:03.060 --> 00:01:07.490 
The applications are designed by the architects, built by the developers

17
00:01:07.700 --> 00:01:11.290 
and use the infrastructure provided by the operators. And there

18
00:01:11.290 --> 00:01:14.910 
is a tight interaction between the applications and its infrastructure.

19
00:01:15.030 --> 00:01:17.870 
So if we want to make applications, make the most efficient

20
00:01:17.870 --> 00:01:21.720 
use of infrastructure we have to design them for the infrastructure

21
00:01:21.720 --> 00:01:24.610 
that they are running on and vice versa. We have to design the

22
00:01:24.610 --> 00:01:27.430 
infrastructure to meet the exact requirements of the application.

23
00:01:28.330 --> 00:01:32.010 
One of the ways that teams can embed this into practice

24
00:01:32.010 --> 00:01:36.350 
is by adopting a methodology like devops where developers

25
00:01:36.350 --> 00:01:40.190 
and operators can work very closely together in the same team

26
00:01:40.270 --> 00:01:42.850 
without organizational boundaries in between them.

27
00:01:44.820 --> 00:01:49.160 
One example of this collaboration is coming back to the bin packing problem.

28
00:01:49.850 --> 00:01:53.330 
When we take the bin packing problem and apply to infrastructure,

29
00:01:53.580 --> 00:01:57.040 
the operators want to ensure that the platforms they use to

30
00:01:57.040 --> 00:02:01.060 
provide services to the application and infrastructure to the application

31
00:02:01.350 --> 00:02:04.930 
support very tight bin packing. And they can support that by

32
00:02:05.150 --> 00:02:08.640 
choosing platforms that, for example, support virtualization

33
00:02:08.810 --> 00:02:13.290 
or container orchestration for even finer granular bin packing of

34
00:02:13.430 --> 00:02:16.480 
applications onto actual physical hardware.

35
00:02:17.490 --> 00:02:21.900 
And one of the most important ways to make sure that this bin packing works efficiently

36
00:02:22.120 --> 00:02:25.760 
is by providing infrastructure APIs like measuring CPU

37
00:02:25.870 --> 00:02:30.230 
usage, measuring memory consumption storage and aligning that

38
00:02:30.230 --> 00:02:33.060 
with the business requirements of the application, for example

39
00:02:33.060 --> 00:02:36.500 
by measuring how is the application behaving like for example

40
00:02:36.500 --> 00:02:38.050 
tracking its round-trip latency.

41
00:02:38.960 --> 00:02:42.220 
And when you have that information available infrastructure

42
00:02:42.220 --> 00:02:45.790 
can make or the infrastructure platforms can make smart decisions

43
00:02:45.790 --> 00:02:49.450 
about scaling the application called auto scaling. And as you

44
00:02:49.450 --> 00:02:52.380 
can see in the figure below, for example, the application can

45
00:02:52.380 --> 00:02:55.760 
scale down its resource consumption while it's not used and

46
00:02:55.760 --> 00:02:58.260 
then scale it back up when there's more requests coming in.

47
00:03:00.810 --> 00:03:05.580 
Another aspect when it comes to designing efficient infrastructure for applications

48
00:03:05.910 --> 00:03:10.380 
is to be very aware of the storage hierarchy involved.

49
00:03:10.910 --> 00:03:13.750 
Many applications need to work with data and store data

50
00:03:14.190 --> 00:03:17.420 
and there's a hierarchy to how efficient

51
00:03:18.000 --> 00:03:21.650 
we can work with data and applications. So on the highest level

52
00:03:21.650 --> 00:03:25.020 
of the hierarchy we have the CPU with its registers and its

53
00:03:25.020 --> 00:03:30.740 
caches, level one two three caches inside the CPU, very high bandwidth, very fast,

54
00:03:30.980 --> 00:03:34.460 
very efficient. And then we have RAM where we have more of it

55
00:03:34.500 --> 00:03:37.290 
available but it's a bit slower than working directly in the

56
00:03:37.300 --> 00:03:42.100 
CPU and then we might have local storage like SSDs or HDDs

57
00:03:42.100 --> 00:03:45.310 
attached to a local bus like NBME for example.

58
00:03:46.230 --> 00:03:49.410 
And then much slower than that we have

59
00:03:49.990 --> 00:03:54.430 
remote network storage solutions like NFS shares or block storage

60
00:03:54.430 --> 00:03:56.540 
devices mounted to a hypervisor.

61
00:03:57.590 --> 00:03:59.590 
And when we traverse that hierarchy,

62
00:04:00.370 --> 00:04:02.520 
on the top level we have very high performance

63
00:04:03.310 --> 00:04:07.680 
and the lower end we have other properties but not necessarily performance.

64
00:04:08.630 --> 00:04:13.240 
And it's important to pick the right level in the hierarchy to put your

65
00:04:13.500 --> 00:04:17.130 
application to. And if you do that correctly and keeping your

66
00:04:17.130 --> 00:04:19.910 
data as local as possible, you will have higher performance,

67
00:04:19.920 --> 00:04:23.700 
you will use less hardware and that also means you will use

68
00:04:23.700 --> 00:04:25.180 
less energy for your application.

69
00:04:26.230 --> 00:04:28.180 
Let's look at a practical example of this.

70
00:04:28.860 --> 00:04:32.060 
Suppose we have to design as an operator a storage

71
00:04:32.480 --> 00:04:37.610 
solution for a database. And let's suppose we have a very traditional application where there's

72
00:04:37.870 --> 00:04:41.170 
an application server that talks to a database server and all

73
00:04:41.170 --> 00:04:44.490 
of that happens on virtual infrastructure. So the database server

74
00:04:44.520 --> 00:04:46.640 
will actually have a virtual volume

75
00:04:47.660 --> 00:04:48.770 
where it stores its data.

76
00:04:49.530 --> 00:04:54.510 
How is a virtual volume actually implemented? Well in most solutions today

77
00:04:54.660 --> 00:04:57.840 
in virtualized software there's something like a storage array

78
00:04:58.970 --> 00:05:04.520 
behind it that backs the volume and that might be a dedicated machine and that

79
00:05:05.020 --> 00:05:09.130 
has multiple disks. And this storage will also take care of

80
00:05:09.460 --> 00:05:12.970 
replicating the data, so that the data is safe from the loss

81
00:05:12.970 --> 00:05:16.460 
of a single disk and for our example here let's just assume

82
00:05:16.460 --> 00:05:19.040 
that we have a replication factor of three which means there

83
00:05:19.040 --> 00:05:20.640 
will be three copies of the data.

84
00:05:21.720 --> 00:05:25.230 
And what this gives us in terms of properties, it means that

85
00:05:25.230 --> 00:05:27.830 
our data is going to be very durable. So

86
00:05:28.750 --> 00:05:32.720 
we maintain the durability of the data at the storage layer.

87
00:05:32.730 --> 00:05:35.680 
And we protect against hardware failure at this level.

88
00:05:37.140 --> 00:05:43.530 
And the challenge comes when we want to scale this up. Suppose our application

89
00:05:43.780 --> 00:05:46.980 
needs to serve more requests.

90
00:05:47.650 --> 00:05:51.850 
The database can quickly become a bottleneck. So one of the ways

91
00:05:51.990 --> 00:05:55.520 
this is typically solved is by scaling the database horizontally

92
00:05:55.820 --> 00:05:59.220 
and providing something like read replicas for example of your data.

93
00:05:59.830 --> 00:06:03.690 
And if we stick with the approach of having virtual infrastructure,

94
00:06:04.750 --> 00:06:08.530 
you would end up if you have three copies of your database

95
00:06:08.530 --> 00:06:11.660 
and you have three read replicas of your data that there's

96
00:06:11.660 --> 00:06:15.420 
actually nine total copies of your data around because each

97
00:06:15.420 --> 00:06:19.800 
of those is backed by a virtual volume that in turn is replicated three times.

98
00:06:20.690 --> 00:06:24.990 
This might sound a bit like overkill and not very efficient. So,

99
00:06:25.230 --> 00:06:29.060 
when we look at doing this in a cloud native way,

100
00:06:29.650 --> 00:06:31.040 
when we have a database

101
00:06:32.050 --> 00:06:36.220 
that is actually capable of clustering and understands how

102
00:06:36.220 --> 00:06:41.140 
this clustering works and understands how its topology looks like at run-time,

103
00:06:41.420 --> 00:06:43.120 
we might actually choose a different way.

104
00:06:43.700 --> 00:06:46.940 
We might provide storage not as virtual volumes but we might

105
00:06:46.940 --> 00:06:50.760 
use local volumes that are local to the machine where the hypervisor

106
00:06:50.760 --> 00:06:52.130 
is running the database server.

107
00:06:53.310 --> 00:06:56.360 
Remember the storage hierarchy. This would be much faster because

108
00:06:56.360 --> 00:06:59.540 
every request to the storage layer won't go over the network,

109
00:06:59.540 --> 00:07:02.290 
won't go to a separate side, won't go to a separate disk.

110
00:07:02.870 --> 00:07:07.870 
It will instead just be on a local single disk. So we will have much higher performance.

111
00:07:08.260 --> 00:07:12.460 
However of course, it's a tiny bit more dangerous. What happens

112
00:07:12.460 --> 00:07:15.670 
if we lose all three virtual machines or all three hypervisor

113
00:07:16.070 --> 00:07:20.810 
at the same time? Well, you might end up without a single copy of your data.

114
00:07:21.380 --> 00:07:26.740 
So, going this way is of course something that needs to be carefully designed and considered.

115
00:07:27.490 --> 00:07:31.260 
Luckily, also we could think of a hybrid approach where there's like always

116
00:07:31.950 --> 00:07:35.320 
a copy of the data also on a virtual volume somewhere that's

117
00:07:35.320 --> 00:07:38.920 
backed by these durability guarantees. But this just goes to

118
00:07:38.920 --> 00:07:43.750 
show how much potential operators have for designing applications and infrastructure

119
00:07:43.970 --> 00:07:45.010 
in an efficient manner.

120
00:07:47.200 --> 00:07:51.440 
What other tasks do operators have and how can they apply

121
00:07:51.900 --> 00:07:54.160 
sustainable engineering practices to them?

122
00:07:54.890 --> 00:08:00.840 
Operators should take care of running the operations lean and this means that

123
00:08:01.350 --> 00:08:03.960 
some tasks like taking backups for example

124
00:08:04.420 --> 00:08:08.340 
do run in an efficient manner. It's very often the case that

125
00:08:08.340 --> 00:08:11.210 
simple backup strategies like for example taking daily full

126
00:08:11.210 --> 00:08:15.270 
backups of the database can easily result in more data volume

127
00:08:15.270 --> 00:08:18.950 
being processed by the application than what the actual operational

128
00:08:18.950 --> 00:08:23.260 
data volume is of the data. And that's because many databases

129
00:08:23.260 --> 00:08:27.430 
tend to grow over time and backing them up daily just amplifies

130
00:08:27.430 --> 00:08:30.070 
the amount of data that the application processes every day

131
00:08:30.380 --> 00:08:32.560 
and that approaches like an o n squared

132
00:08:33.100 --> 00:08:37.510 
shape in terms of the actual amount of work that the system has to do.

133
00:08:38.530 --> 00:08:42.050 
Logs have a similar problem. Some applications tend to emit

134
00:08:42.050 --> 00:08:44.650 
much more logs than the actual data that they work with.

135
00:08:45.440 --> 00:08:48.730 
And that's not only difficult for operations because you have

136
00:08:48.740 --> 00:08:52.840 
a very high amount of noise, essentially. And very little signal of

137
00:08:53.020 --> 00:08:56.050 
the logs that you are actually interested in to troubleshoot issues.

138
00:08:57.320 --> 00:09:00.250 
And this can be amplified by things like

139
00:09:00.950 --> 00:09:04.060 
when your logs are unstructured which means they're just text

140
00:09:04.450 --> 00:09:08.970 
and they're not using a structured data format. Then you will write complex

141
00:09:09.130 --> 00:09:12.500 
logic to filter log statements and parse them.

142
00:09:13.160 --> 00:09:17.070 
Whereas if you use a structured logging format, you could do that

143
00:09:17.260 --> 00:09:20.010 
natively and save a lot of processing power for logs.

144
00:09:20.910 --> 00:09:24.310 
Of course logs are also another example where it pays off for

145
00:09:24.310 --> 00:09:28.250 
operators to work closely with the developers actually writing the log statements

146
00:09:28.970 --> 00:09:31.620 
and why it's good to have practices like devops where where the

147
00:09:31.620 --> 00:09:33.040 
two roles are in the same team.

148
00:09:34.580 --> 00:09:39.050 
Another source of operations that don't run very lean are things

149
00:09:39.050 --> 00:09:42.710 
like cron jobs. So periodic tasks that systems have to do

150
00:09:43.430 --> 00:09:47.050 
and very simple strategies like just running them hourly

151
00:09:47.520 --> 00:09:52.750 
like every hour, no matter the time of the week might be not very efficient.

152
00:09:52.970 --> 00:09:54.870 
For example if you take a data pipeline,

153
00:09:56.030 --> 00:10:00.470 
on some days nobody looks at the data. Why not just run it from monday to friday.

154
00:10:00.670 --> 00:10:05.860 
You could save two two seventh of total processing volume that way.

155
00:10:08.440 --> 00:10:12.950 
Another aspect when it comes to infrastructure and running lean is that

156
00:10:13.230 --> 00:10:17.650 
for some tasks operators can make decisions to run them on

157
00:10:17.660 --> 00:10:19.790 
hardware or an infrastructure that has

158
00:10:20.990 --> 00:10:25.750 
not as high service levels as always on infrastructure.

159
00:10:26.370 --> 00:10:31.360 
And one example or one opportunity that things like cloud platforms

160
00:10:31.360 --> 00:10:33.190 
offer is spot instances.

161
00:10:33.900 --> 00:10:36.760 
Spot instances are essentially virtual machines that you can

162
00:10:36.760 --> 00:10:40.130 
have and the provider can terminate them at any time.

163
00:10:41.300 --> 00:10:45.050 
But the upside of that is that they can sell you spare capacity.

164
00:10:45.060 --> 00:10:46.620 
So anything that's still

165
00:10:47.550 --> 00:10:50.150 
running in the data center that can still host a virtual machine,

166
00:10:50.340 --> 00:10:53.210 
they can give to you at a very much reduced rate.

167
00:10:54.030 --> 00:10:56.330 
And there's actually a market mechanism behind this and we

168
00:10:56.330 --> 00:10:59.830 
can see this in the diagram here of what the spot price for an instance is

169
00:11:00.240 --> 00:11:03.790 
and you can see that it's very cheap to run workload during the night.

170
00:11:04.040 --> 00:11:06.640 
Supposedly because there's no other workload running in the

171
00:11:06.640 --> 00:11:08.650 
data center at the time or not as much.

172
00:11:09.940 --> 00:11:13.780 
And then during the day, the prices for spot instances go higher.

173
00:11:14.170 --> 00:11:17.960 
And if you have tasks that can wait a little on when they get done,

174
00:11:18.130 --> 00:11:21.420 
this is a great way to save a lot of cost and also make sure

175
00:11:21.420 --> 00:11:25.760 
that the data center infrastructure runs at a high utilization. So,

176
00:11:25.930 --> 00:11:31.500 
overall a very good mechanism to incentivize making more efficient

177
00:11:31.500 --> 00:11:32.730 
use of infrastructure.
