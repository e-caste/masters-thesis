WEBVTT

1
00:00:00.400 --> 00:00:03.700 
In this lecture we're going to
speak about tuple reconstruction.

2
00:00:03.700 --> 00:00:07.110 
What is tuple reconstruction?
Basically, if we have our world

3
00:00:07.110 --> 00:00:09.130 
population table and we
store persons in there

4
00:00:10.140 --> 00:00:15.190 
we sometimes have to retrieve
all data belonging to one person

5
00:00:15.190 --> 00:00:18.220 
to build up the whole
record and to deal with that

6
00:00:18.220 --> 00:00:22.260 
and depending on how
we store the attributes

7
00:00:23.270 --> 00:00:26.300 
we of course have differences
in how we have to do that and

8
00:00:26.300 --> 00:00:30.340 
how long it takes and for that
we're going to have a quick

9
00:00:30.340 --> 00:00:35.390 
recap on the data
layout slides. Of course

10
00:00:36.400 --> 00:00:39.430 
we can store our information
either in row format

11
00:00:40.440 --> 00:00:44.480 
or in column format and as
we've learned in the slides

12
00:00:44.480 --> 00:00:47.510 
of data layout

13
00:00:48.520 --> 00:00:52.560 
while the data itself is
somehow in a table format

14
00:00:53.570 --> 00:00:56.600 
we can only store our
data in a linear way so

15
00:00:56.600 --> 00:00:59.630 
main memory is basically one
dimensional not two dimensional

16
00:01:00.640 --> 00:01:02.660 
and therefore we have
this differences.

17
00:01:04.680 --> 00:01:09.730 
In the row layout we store all
the attributes belonging to

18
00:01:09.730 --> 00:01:12.760 
one tuple, in this case all
the attributes which belong to

19
00:01:12.760 --> 00:01:17.810 
one person adjacent to each
other so we can say ok we've got

20
00:01:17.810 --> 00:01:21.850 
as A the first name, B might be
the last name, C might be the

21
00:01:21.850 --> 00:01:25.890 
birth date or several other
things and this of course

22
00:01:26.900 --> 00:01:30.940 
is a disadvantage if you have
to do a column operation. So

23
00:01:31.950 --> 00:01:35.990 
for example, counting how many
males and how many females we

24
00:01:35.990 --> 00:01:39.103 
have in our whole world population
then we have to jump and jump

25
00:01:39.103 --> 00:01:44.108 
and jump and have to do many
accesses at different positions

26
00:01:44.108 --> 00:01:48.112 
which is costly but a row
operation is of course

27
00:01:48.112 --> 00:01:51.115 
more easy there, so
we've got an advantage.

28
00:01:51.115 --> 00:01:54.118 
If we want to retrieve the
first name, the last name,

29
00:01:55.119 --> 00:01:59.123 
and the birth date for example
so we've got all that adjacent

30
00:01:59.123 --> 00:02:02.126 
to each other and can
retrieve that all at once.

31
00:02:03.127 --> 00:02:08.132 
Just the opposite way, in
the columnar layout, we

32
00:02:08.132 --> 00:02:12.136 
have advantages
if we want to do

33
00:02:13.137 --> 00:02:16.140 
aggregate operations and
we've got disadvantages

34
00:02:16.140 --> 00:02:20.144 
if we want to retrieve all
attributes belonging to one person

35
00:02:21.145 --> 00:02:24.148 
which is basically the case
on tuple reconstruction.

36
00:02:25.149 --> 00:02:28.152 
And with that we are going
to have a look into that.

37
00:02:29.153 --> 00:02:32.156 
So first, for the row layout,
what do we have to do here?

38
00:02:33.157 --> 00:02:36.160 
We've got our 200
bytes per person

39
00:02:37.161 --> 00:02:40.164 
and we have to retrieve that
for let's say row number

40
00:02:41.165 --> 00:02:46.170 
three and therefore we
have to access about

41
00:02:47.171 --> 00:02:52.176 
256 bytes because we can
only accesses data in chunks

42
00:02:52.176 --> 00:02:57.181 
of 64 bytes, so its cache
size and if we read this

43
00:02:57.181 --> 00:03:00.184 
with our assumed scan speed of
four mega byte per milisecond per

44
00:03:00.184 --> 00:03:03.187 
core we end up with
fractions of a microsecond,

45
00:03:04.188 --> 00:03:07.191 
already on one core so
this is really really fast.

46
00:03:08.192 --> 00:03:12.196 
Again, note that
also in this style of

47
00:03:13.197 --> 00:03:17.201 
storing data we load data
which is not actually used

48
00:03:18.202 --> 00:03:20.204 
because of course we
can only access in

49
00:03:21.205 --> 00:03:27.211 
cache sized chunks. But in
a columnar way to store it

50
00:03:28.212 --> 00:03:31.215 
we have to have at least
six different accesses

51
00:03:32.216 --> 00:03:36.220 
because we store the
data which we want to

52
00:03:37.221 --> 00:03:41.225 
read and which we
want to collect

53
00:03:41.225 --> 00:03:46.230 
in six different locations, of
course. So if we access only

54
00:03:46.230 --> 00:03:51.235 
tuple number three, we have
to have these six accesses

55
00:03:52.236 --> 00:03:55.239 
because in this case we have
got six different attributes

56
00:03:55.239 --> 00:03:59.243 
and of course therefore we
have much more data which is

57
00:03:59.243 --> 00:04:03.247 
loaded but not really used. So
our data size is again bigger,

58
00:04:03.247 --> 00:04:07.251 
we have 384
bytes to read

59
00:04:07.251 --> 00:04:11.255 
and this is of course
slower on one core and also

60
00:04:12.256 --> 00:04:17.261 
slower on many cores. But with
that I also want to remind

61
00:04:17.261 --> 00:04:20.264 
you that while this is
a bit slower, so it's

62
00:04:21.265 --> 00:04:23.267 
still below one
microsecond,

63
00:04:25.269 --> 00:04:31.275 
if you would do this with a standard hard disk
so, if you wouldn't do this in main memory,

64
00:04:31.275 --> 00:04:40.284 
but if you would do this in a columnar database, which would use hard drives as its main persistance,

65
00:04:40.284 --> 00:04:47.291 
you would have much much more delay. Because
every access for every attribute in our tuple

66
00:04:47.291 --> 00:04:56.300 
would require the disk to add another complete
seek time which is about ten milliseconds

67
00:04:56.300 --> 00:05:01.305 
and therefore this would be really
really be a hinderance if we would do

68
00:05:01.305 --> 00:05:11.315 
such tuple reconstructions, in a columnar way, on a hard drive. So only with a combination of main memory and columnar storage

69
00:05:11.315 --> 00:05:15.319 
it's also do-able
to do these kind of

70
00:05:15.319 --> 00:05:19.323 
reconstructions. And these
kinds of reconstructions are

71
00:05:19.323 --> 00:05:22.326 
really necessary for
OLTP style of queries so

72
00:05:24.328 --> 00:05:28.332 
if we want to have a customer
account and want to have

73
00:05:28.332 --> 00:05:31.335 
a deeper look into that and we
of course click in our program

74
00:05:31.335 --> 00:05:35.339 
and the program has to fetch all
the data which has to be displayed

75
00:05:35.339 --> 00:05:38.342 
and of course this
is no aggregation and

76
00:05:39.343 --> 00:05:43.347 
but this is also part of enterprise
computing, so this is do-able

77
00:05:43.347 --> 00:05:47.351 
now but wouldn't be
doable in a columnar way

78
00:05:47.351 --> 00:05:51.355 
on hard drives. This also
shows the importance that it

79
00:05:51.355 --> 00:05:56.360 
is really necessary not to write
queries like select star (*)

80
00:05:56.360 --> 00:06:01.365 
from person table or world
population because in most cases when

81
00:06:01.365 --> 00:06:03.367 
you access data in
an enterprise setting

82
00:06:03.367 --> 00:06:06.370 
you don't really need all
that data. As we've learned

83
00:06:07.371 --> 00:06:10.374 
in the lecture on enterprise
data characteristics,

84
00:06:11.375 --> 00:06:15.379 
most tables which we use for our
enterprise data are really sparse

85
00:06:15.379 --> 00:06:19.383 
and wide so meaning that we've
got plenty of columns, so about

86
00:06:19.383 --> 00:06:22.386 
200 of them or even 300

87
00:06:22.386 --> 00:06:28.392 
that mostly are filled with
default values or even null values.

88
00:06:28.392 --> 00:06:33.397 
So if you retrieve all these
you need much much more accesses

89
00:06:34.398 --> 00:06:39.403 
which makes the queries much slower
but the really important facts

90
00:06:39.403 --> 00:06:42.406 
are in the columns which are
actually used, so therefore it's

91
00:06:42.406 --> 00:06:47.411 
really crucial to state in your
query that you write if you

92
00:06:47.411 --> 00:06:52.416 
write an application
exactly what attributes

93
00:06:52.416 --> 00:06:56.420 
do you need and only select
these. So these are linearly

94
00:06:57.421 --> 00:06:59.423 
affecting the runtime of
the program afterwards.
