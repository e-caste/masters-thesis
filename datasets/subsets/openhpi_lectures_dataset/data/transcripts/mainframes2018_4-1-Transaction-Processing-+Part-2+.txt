WEBVTT

1
00:00:01.190 --> 00:00:03.850 
Welcome to the introduction to Transaction Processing.

2
00:00:04.270 --> 00:00:08.150 
My name is Philipp Brune from the Neu-Ulm University of Applied Sciences.

3
00:00:09.220 --> 00:00:12.350 
When we talk about transaction processing first,

4
00:00:12.790 --> 00:00:15.480 
we should understand what actually a transaction is.

5
00:00:16.010 --> 00:00:21.670 
We know that the mainframe is the classical platform for implementing

6
00:00:22.370 --> 00:00:26.920 
high-throughput transaction systems. We discussed this also earlier. The

7
00:00:28.150 --> 00:00:32.700 
online transaction processing or OLTP is therefore

8
00:00:33.110 --> 00:00:36.680 
a typical Strength of the mainframe environment of the Mainframe Architecture.

9
00:00:37.460 --> 00:00:40.830 
We discussed already why this is the case regarding hardware

10
00:00:40.830 --> 00:00:42.190 
and ISO system and so on.

11
00:00:43.560 --> 00:00:47.830 
But first let's understand what is a transaction. So in general

12
00:00:47.940 --> 00:00:50.850 
a transaction maps a business activity.

13
00:00:51.480 --> 00:00:56.140 
So a transaction is a business task. If you think of

14
00:00:57.170 --> 00:01:02.500 
ordering something, booking money, order some

15
00:01:03.180 --> 00:01:07.410 
good, some product and so on and these are typical transactions.

16
00:01:07.610 --> 00:01:10.440 
A customer comes and wants to do some business.

17
00:01:11.410 --> 00:01:15.700 
And these transactions are the processing of such transactions,

18
00:01:15.700 --> 00:01:17.980 
of business transactions usually involves

19
00:01:18.410 --> 00:01:22.090 
modifying accessing data in the systems of a company.

20
00:01:22.650 --> 00:01:23.930 
And usually it involves

21
00:01:24.740 --> 00:01:30.970 
the modification of data and different places. So a transaction

22
00:01:30.970 --> 00:01:36.760 
usually consists of multiple elementary data operations on different

23
00:01:37.080 --> 00:01:38.490 
data sources, for example.

24
00:01:40.010 --> 00:01:45.740 
And, so transaction processing requires, that in a system

25
00:01:46.230 --> 00:01:50.170 
these data access is synchronized so we don't get conflicts between

26
00:01:50.410 --> 00:01:54.440 
concurrent operations. Since we must be aware that usually

27
00:01:55.070 --> 00:01:58.660 
there would be a lot of transactions coming to a system in parallel.

28
00:01:59.190 --> 00:02:02.020 
In the introduction we heard that for example Walmart has a

29
00:02:02.040 --> 00:02:04.070 
billion transactions a day. So

30
00:02:04.960 --> 00:02:08.130 
there are many, many transactions that run in parallel in the

31
00:02:08.130 --> 00:02:10.310 
system and maybe also want to

32
00:02:11.220 --> 00:02:14.740 
change the same data at the same time. And this has to be synchronized

33
00:02:14.740 --> 00:02:18.890 
so we don't get mistakes. And that's one of the elementary purposes of

34
00:02:19.070 --> 00:02:21.630 
transaction processing software.

35
00:02:23.680 --> 00:02:27.450 
So transaction support, having transaction support is a prerequisite

36
00:02:27.810 --> 00:02:31.700 
to implement, to write critical business applications.

37
00:02:32.370 --> 00:02:33.430 
Business applications

38
00:02:34.130 --> 00:02:37.470 
that really matter where money is made and where

39
00:02:38.660 --> 00:02:42.030 
all the assets of a company, for example are maintained and changed.

40
00:02:42.280 --> 00:02:45.780 
And this requires to keep the so called ACID properties.

41
00:02:46.660 --> 00:02:50.430 
Just have a look on that briefly. You learn that also in the database

42
00:02:50.860 --> 00:02:52.090 
part of this lecture.

43
00:02:52.730 --> 00:02:58.180 
And this ACID properties help to ensure the consistency of

44
00:02:58.180 --> 00:03:00.210 
the data of an enterprise.

45
00:03:02.300 --> 00:03:05.980 
So to understand transactions, the most elementary example is

46
00:03:05.980 --> 00:03:10.900 
always booking money on a bank account. And this is just a brief reminder how this

47
00:03:11.620 --> 00:03:15.090 
works, what you have to consider when talking about transactions.

48
00:03:15.390 --> 00:03:18.570 
So just imagine you have a very simple model of a bank account

49
00:03:19.160 --> 00:03:22.550 
consisting of a table which has an account number as a key

50
00:03:22.680 --> 00:03:26.010 
and the balance, the corresponding balance of the corresponding account.

51
00:03:26.960 --> 00:03:30.150 
And if you now want to book money from one account to another

52
00:03:30.480 --> 00:03:33.080 
which means that you reduce the balance of one account and

53
00:03:33.090 --> 00:03:35.210 
increase the balance of the other one.

54
00:03:36.230 --> 00:03:39.380 
If you just think about a standard SQL database,

55
00:03:39.860 --> 00:03:43.120 
you might know that this would be done using update statements.

56
00:03:43.120 --> 00:03:45.540 
And if you look at the update statements, you'll see that for

57
00:03:45.540 --> 00:03:49.650 
this simple thing- booking the money you need two update statements- one modifying

58
00:03:50.010 --> 00:03:53.390 
the source and one modifying the target account.

59
00:03:54.390 --> 00:03:58.890 
And of course it's obvious that for business reasons

60
00:03:59.570 --> 00:04:02.690 
these two update statements always need to be executed together.

61
00:04:02.700 --> 00:04:06.080 
You are not allowed to execute only one because this would lead to

62
00:04:06.360 --> 00:04:10.350 
money disappearing or money just appearing out of nothing. This

63
00:04:10.350 --> 00:04:15.120 
is not not ok. So we can say that this is a typical example

64
00:04:15.120 --> 00:04:17.880 
that these two update statements need to be atomic, they need

65
00:04:17.880 --> 00:04:23.060 
to be executed always- both and not one of it. So,

66
00:04:24.670 --> 00:04:29.320 
atomicity is an important property and this is ensured by transactions. So

67
00:04:29.520 --> 00:04:33.100 
a transaction in general is a sequence of data operations

68
00:04:33.260 --> 00:04:35.910 
that starts at the beginning of transactions, then we have the

69
00:04:35.910 --> 00:04:39.700 
data operations and then as an end of transaction, and after

70
00:04:39.700 --> 00:04:40.700 
the end of transaction

71
00:04:41.670 --> 00:04:45.960 
the transaction is either committed if everything went successfully, or

72
00:04:46.810 --> 00:04:50.190 
upon failure it is rolled back. So the system is in this state

73
00:04:50.250 --> 00:04:54.190 
like the transaction never would have been executed. Okay so

74
00:04:54.190 --> 00:04:56.810 
this is the basic concept of transactions and you know that

75
00:04:56.860 --> 00:05:00.630 
for example from database systems, most database systems support

76
00:05:00.770 --> 00:05:04.810 
such kind of mechanisms or their data stored inside that system.

77
00:05:06.640 --> 00:05:11.370 
So ACID properties mean a transaction needs to be atomic. So this

78
00:05:11.370 --> 00:05:14.400 
means that it always has executed all or nothing.

79
00:05:16.510 --> 00:05:21.090 
It needs to preserve consistency of the data. So the data needs

80
00:05:21.090 --> 00:05:24.470 
to be in order, and all the references need to be correct before

81
00:05:24.470 --> 00:05:25.620 
and after the transaction.

82
00:05:27.080 --> 00:05:29.040 
The transactions need to be isolated.

83
00:05:30.030 --> 00:05:34.260 
This means that the the system should behave like the transaction.

84
00:05:34.380 --> 00:05:38.730 
One transaction was executed independently of the others and

85
00:05:38.880 --> 00:05:42.830 
this could also be understood as a serialization, meaning that all transactions

86
00:05:43.270 --> 00:05:46.160 
should behave like they would have been executed one after

87
00:05:46.160 --> 00:05:47.860 
another in a strict serial order.

88
00:05:48.590 --> 00:05:52.290 
And the last one of course is durability or durable

89
00:05:53.180 --> 00:05:56.350 
transactions. The changes made during a transaction

90
00:05:56.790 --> 00:06:01.170 
after a commit need to be durable, persistent in the system.

91
00:06:01.170 --> 00:06:04.030 
So they should not be able to disappear or

92
00:06:04.430 --> 00:06:07.460 
change without control.

93
00:06:08.190 --> 00:06:12.160 
So that means that they should remain. Okay, so these are the four

94
00:06:12.390 --> 00:06:15.470 
criterias or properties ACID properties that

95
00:06:16.300 --> 00:06:20.460 
every transaction in a business critical application needs to fulfill.

96
00:06:21.910 --> 00:06:24.070 
You learned that already for database systems. If you think

97
00:06:24.070 --> 00:06:26.860 
of a database management system,

98
00:06:27.270 --> 00:06:30.300 
typically an SQL or relational database system,

99
00:06:31.010 --> 00:06:34.450 
then you have of course the support for transactions inside

100
00:06:34.460 --> 00:06:37.700 
that database system for all the data that is stored in that system.

101
00:06:38.040 --> 00:06:40.800 
On the mainframe, this could be for example DB2, instance.

102
00:06:41.710 --> 00:06:46.450 
However in a business scenario, typically we have more than one database

103
00:06:46.960 --> 00:06:51.330 
system or any other data store we have multiple systems and

104
00:06:51.330 --> 00:06:54.580 
we also have different kinds or different types of data stores.

105
00:06:55.050 --> 00:06:56.760 
Just think of a typical

106
00:06:57.410 --> 00:06:58.780 
environment, for example

107
00:06:59.570 --> 00:07:02.970 
where you maybe have a database where some orders are in another

108
00:07:02.970 --> 00:07:04.340 
database that is from the

109
00:07:05.080 --> 00:07:08.140 
booking system and if you change for example order, you might

110
00:07:08.250 --> 00:07:10.620 
also have to change something in accounting.

111
00:07:11.190 --> 00:07:15.290 
So you might have two database systems. Maybe even from different

112
00:07:15.860 --> 00:07:20.010 
vendors or from different other applications. So in a general modern

113
00:07:20.160 --> 00:07:22.550 
complex business application, you might have

114
00:07:22.960 --> 00:07:26.670 
multiple relational or any other database management systems

115
00:07:26.850 --> 00:07:30.390 
that are involved in a process, in the business process and

116
00:07:30.390 --> 00:07:32.630 
therefore also may be involved in a transaction.

117
00:07:33.260 --> 00:07:37.620 
And you might have other data sources. Instead of mainframe systems for example

118
00:07:37.780 --> 00:07:42.670 
we have very frequently the traditional indexed sequential

119
00:07:43.010 --> 00:07:46.910 
data sets which are originating from the VSM

120
00:07:47.650 --> 00:07:51.690 
access method or we might have messaging. We have MQ

121
00:07:52.660 --> 00:07:54.270 
message queues,

122
00:07:55.670 --> 00:07:59.450 
which is also a message queuing system that is available for

123
00:07:59.450 --> 00:08:03.140 
z/OS for many years. A queue you can imagine as a FIFO

124
00:08:03.140 --> 00:08:07.270 
first in first out. A sender puts in messages in the queue and a

125
00:08:07.730 --> 00:08:11.190 
receiver reads out messages from the queue and the input and

126
00:08:11.190 --> 00:08:15.720 
output of the messages in the queue is also transactionally secure. So

127
00:08:17.480 --> 00:08:21.490 
if for example the sender commits the message then the message queuing system

128
00:08:21.740 --> 00:08:26.190 
needs to ensure that this is also a durably and persistently

129
00:08:26.940 --> 00:08:30.530 
stored in the queue. So these are different types of

130
00:08:31.050 --> 00:08:36.540 
applications of systems that for itself behaves transactional.

131
00:08:37.970 --> 00:08:42.040 
But now we have a transaction which spends multiple of these

132
00:08:42.060 --> 00:08:45.020 
systems. We call these systems the transactional resources. So

133
00:08:45.020 --> 00:08:50.350 
we have different systems that by itself are capable of handling transactions inside

134
00:08:51.350 --> 00:08:54.220 
and they serve as a transactional resource for some

135
00:08:55.580 --> 00:08:58.320 
so- called distributed transaction that spends,

136
00:08:59.060 --> 00:09:02.070 
the operations of the transaction spend multiple or involve

137
00:09:02.070 --> 00:09:05.230 
multiple of these transactional resources. So the question is

138
00:09:05.230 --> 00:09:07.950 
now how can we ensure transactional properties

139
00:09:09.240 --> 00:09:13.780 
when we combine multiple systems that each of it have transactional support but

140
00:09:14.120 --> 00:09:18.360 
how do we ensure their ACID properties if the operations spend multiple

141
00:09:18.360 --> 00:09:20.700 
of these systems. And that is the purpose of

142
00:09:21.460 --> 00:09:25.530 
distributed transaction processing and this is usually implemented

143
00:09:25.610 --> 00:09:29.710 
using a software component called middleware which is called

144
00:09:29.810 --> 00:09:34.820 
Transaction Processing Monitor or TPM. Transaction Processing Monitors

145
00:09:35.110 --> 00:09:41.350 
is a type of middleware - a type of software where different offers, commercial offers are

146
00:09:41.830 --> 00:09:44.360 
on the market or the open source offers now are on the market

147
00:09:44.880 --> 00:09:48.810 
of software that is actually there to provide the functionality,

148
00:09:48.810 --> 00:09:51.030 
to handle these distributed transactions.

149
00:09:51.520 --> 00:09:54.760 
So if you think of the example a distributed transaction would be a

150
00:09:54.870 --> 00:09:58.970 
program that modifies different or executes

151
00:09:59.570 --> 00:10:02.620 
operations on different transactional resources, for example

152
00:10:02.620 --> 00:10:06.410 
it reads something from this DBMS insert something in the other DBMS,

153
00:10:06.610 --> 00:10:09.310 
puts a message in the queue and maybe also reads some

154
00:10:10.190 --> 00:10:15.070 
data during executing this transactions. All these operations

155
00:10:15.070 --> 00:10:19.530 
need to be part of this atomic operation between the beginning of transaction

156
00:10:19.700 --> 00:10:24.440 
and the end of transaction. And this is now a distributed transaction

157
00:10:24.440 --> 00:10:26.620 
since you see that it involves different

158
00:10:27.100 --> 00:10:27.870 
data sources.

159
00:10:29.100 --> 00:10:30.780 
And what does it mean? Well

160
00:10:31.560 --> 00:10:32.380 
it means that

161
00:10:33.820 --> 00:10:38.040 
in the beginning, the transaction processing monitor opens up a transaction.

162
00:10:39.110 --> 00:10:42.690 
This transaction bracket on all

163
00:10:43.980 --> 00:10:48.180 
the resources. Then there are all the commands executed and

164
00:10:48.180 --> 00:10:51.150 
at the end, that's the end of transaction. And now of course

165
00:10:51.150 --> 00:10:53.460 
we have to synchronize the different resources. So what the

166
00:10:53.460 --> 00:10:57.100 
transaction processing monitor does is actually he sends a

167
00:10:57.100 --> 00:10:59.950 
so called 'prepare for commit operation'

168
00:11:00.580 --> 00:11:03.840 
At the end of the transaction he sends a prepare for commit first

169
00:11:04.140 --> 00:11:06.110 
to all the involved parties,

170
00:11:06.790 --> 00:11:09.520 
and every involved party needs to check okay

171
00:11:10.370 --> 00:11:14.730 
regarding my internal state am I able to commit this transaction

172
00:11:14.730 --> 00:11:17.510 
or is there some inconsistency, something happened in between that

173
00:11:17.750 --> 00:11:19.840 
prohibits committing the transaction.

174
00:11:20.500 --> 00:11:24.140 
And in this case he sends back a feedback and says  to

175
00:11:24.140 --> 00:11:26.670 
the transaction processing monitor, Okay I'm ready to commit.

176
00:11:27.190 --> 00:11:29.640 
So the transaction processing monitor collects

177
00:11:30.430 --> 00:11:32.590 
the responses of all involved parties,

178
00:11:33.700 --> 00:11:37.980 
and if all parties signal 'Ok i'm ready to commit', then

179
00:11:38.940 --> 00:11:42.320 
the actual final commit is sent simultaneously to all of them.

180
00:11:42.720 --> 00:11:45.820 
If one of the parties says, 'no I'm not able to commit', then a

181
00:11:45.820 --> 00:11:48.600 
rollback is sent to all of them and the transaction is completely

182
00:11:48.600 --> 00:11:51.460 
rolled back. So that is the functionality that the transaction

183
00:11:51.460 --> 00:11:55.900 
processing wanted to actually implement to support distributed

184
00:11:56.120 --> 00:11:59.220 
transaction, and this mechanism is called a 2-Phase Commit protocol

185
00:11:59.690 --> 00:12:02.840 
or 2-Phase Commit because we have first prepared phase and then the actual

186
00:12:03.080 --> 00:12:03.830 
commit phase.

187
00:12:05.690 --> 00:12:10.470 
In addition to supporting distributed transaction, two bigger transaction processing monitors

188
00:12:10.870 --> 00:12:15.060 
support also front and logic so that clients,

189
00:12:15.650 --> 00:12:19.620 
users are able to start these transactions, and of course they

190
00:12:19.620 --> 00:12:22.220 
support handling these transaction programs. So

191
00:12:22.760 --> 00:12:25.850 
these transaction need to be written in some programming language

192
00:12:26.240 --> 00:12:29.410 
and needs to be loaded and executed inside this

193
00:12:29.820 --> 00:12:32.100 
middleware, so the middleware can control what's happening.

194
00:12:32.740 --> 00:12:37.100 
And of course this requires some infrastructure to start and

195
00:12:37.100 --> 00:12:38.980 
run these transaction programs.

196
00:12:39.940 --> 00:12:42.830 
And this is implemented by a typical transaction processing

197
00:12:42.830 --> 00:12:46.410 
monitors. Transaction Processing Monitors is therefore a category

198
00:12:46.410 --> 00:12:49.340 
for software that has been around for many years-

199
00:12:50.350 --> 00:12:54.750 
from the early days of computing, starting on the mainframe.

200
00:12:55.190 --> 00:12:57.620 
So the first transaction processing monitor

201
00:12:58.580 --> 00:13:00.280 
evolved or emerged from the

202
00:13:00.930 --> 00:13:04.290 
software called SABRE- the standard airline booking and reservation

203
00:13:04.290 --> 00:13:05.170 
system which was the

204
00:13:06.120 --> 00:13:09.210 
customer project that was implemented already

205
00:13:09.950 --> 00:13:15.010 
in the early mainframe days for airline reservation, and later on

206
00:13:16.070 --> 00:13:19.910 
the core functionality of this project, actually the distributed

207
00:13:20.180 --> 00:13:23.140 
transaction processing was implemented and then the core functionality

208
00:13:23.140 --> 00:13:27.140 
was carved out and encapsulated in a separate product over

209
00:13:27.140 --> 00:13:28.570 
the years and this evolved to the

210
00:13:30.270 --> 00:13:33.950 
famous transaction processing monitor by IBM for the mainframes

211
00:13:33.950 --> 00:13:38.900 
and other platforms called CICS- the Customer Information Control System.

212
00:13:40.670 --> 00:13:43.900 
And this is probably the most well known classical transaction

213
00:13:43.900 --> 00:13:46.760 
processing monitor. There are others, not only by

214
00:13:48.210 --> 00:13:50.090 
the mainframe vendors, for example in the Fujitsu

215
00:13:51.680 --> 00:13:55.660 
mainframe world, we have the open UTM product, which is also

216
00:13:55.660 --> 00:14:00.070 
a transaction processing monitor. And IBM also has a second one in the

217
00:14:00.180 --> 00:14:01.180 
portfolio called

218
00:14:02.890 --> 00:14:05.450 
IMS-TM. So the information management system which is

219
00:14:06.290 --> 00:14:08.770 
really a database management system but it offers a transaction

220
00:14:08.770 --> 00:14:12.490 
processing monitor component that can be also used independently

221
00:14:12.490 --> 00:14:17.570 
of the actual database. So that is also one transaction processing

222
00:14:17.570 --> 00:14:22.490 
monitor and there are, or at least there have been in the past, offers by other

223
00:14:23.010 --> 00:14:27.570 
companies for also for other operating systems like Unix, for example

224
00:14:28.300 --> 00:14:29.920 
to achieve this functionality.

225
00:14:31.300 --> 00:14:35.400 
And transaction processing monitors typically have, as we already

226
00:14:35.410 --> 00:14:39.270 
heard in the previous slide- different functionality so there's a

227
00:14:39.610 --> 00:14:42.890 
presentation component that allows the user to interact and

228
00:14:43.330 --> 00:14:47.070 
stop the transactions. In a classical mainframe, this was typically

229
00:14:48.250 --> 00:14:53.100 
achieved using terminal based three to seven hour

230
00:14:53.810 --> 00:14:58.860 
terminal screens using for example six basic mapping support.

231
00:14:59.380 --> 00:15:03.330 
But today, of course most transactions are triggered, for example

232
00:15:03.330 --> 00:15:06.050 
using a web service from a mobile device or other

233
00:15:07.100 --> 00:15:08.170 
front-end systems.

234
00:15:09.710 --> 00:15:12.990 
And then of course there's a process control which loads the

235
00:15:12.990 --> 00:15:16.560 
actual programs- the transaction programs and executes them under the control

236
00:15:16.690 --> 00:15:21.390 
of the processing monitor handling the distributed transaction

237
00:15:21.390 --> 00:15:23.680 
in 2-Phase commit mechanism and then

238
00:15:24.670 --> 00:15:27.200 
of course we need the actual transaction server which is basically

239
00:15:27.200 --> 00:15:28.380 
the application program that

240
00:15:29.020 --> 00:15:32.860 
forms the transaction that is run under the control of the TPM.

241
00:15:34.830 --> 00:15:39.490 
So using this mechanism TPM support distributed transactions

242
00:15:40.020 --> 00:15:44.490 
ensure that ACID properties using the 2-Phase Commit protocol.

243
00:15:45.550 --> 00:15:49.790 
The last type of transaction processing monitor that is sort

244
00:15:49.790 --> 00:15:51.090 
of a little bit hidden

245
00:15:51.840 --> 00:15:52.990 
for many people is the

246
00:15:53.690 --> 00:15:58.230 
java enterprise edition and related frameworks that also have

247
00:15:58.230 --> 00:16:00.370 
the support for this distributed transactions.

248
00:16:01.190 --> 00:16:06.460 
So, a Java EE or now since a few weeks it's now called Jakarta EE

249
00:16:06.610 --> 00:16:12.170 
and has been handed in the open source community.

250
00:16:12.610 --> 00:16:18.190 
So the Java/Jakarta EE specification confirm an application server, which

251
00:16:18.500 --> 00:16:22.160 
is also a transaction processing monitor. So it's very similar to

252
00:16:22.530 --> 00:16:26.670 
regarding the concept of the idea very similar to a classical TPM.

253
00:16:27.380 --> 00:16:32.470 
Just for Java bit, so transaction processing monitors

254
00:16:32.810 --> 00:16:36.880 
appear in different kinds and in the following of this

255
00:16:37.460 --> 00:16:39.720 
chapter of the course

256
00:16:40.360 --> 00:16:43.340 
we have a deeper look on the different

257
00:16:44.050 --> 00:16:47.300 
types of transaction processing monitor,

258
00:16:48.050 --> 00:16:52.470 
software environments for COBOL, for java and so on. Thank you.
