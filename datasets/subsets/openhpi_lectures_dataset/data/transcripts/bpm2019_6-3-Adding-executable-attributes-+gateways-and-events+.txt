WEBVTT

1
00:00:00.520 --> 00:00:03.870 
Hello again it's us, who would
have thought? Unless of course

2
00:00:03.870 --> 00:00:06.900 
that you just look for the next
video in which case maybe it's

3
00:00:06.900 --> 00:00:10.930 
been us the whole time. So in this
case we're actually going to discuss

4
00:00:11.120 --> 00:00:15.500 
gateways and events on how
they can be executed. Now

5
00:00:15.500 --> 00:00:19.610 
you probably already know how they
work from a BPMN perspective

6
00:00:19.680 --> 00:00:22.040 
but actually now we're gonna discuss
in a very different perspective

7
00:00:22.040 --> 00:00:24.840 
because it's going to be about
actually how to make the engine

8
00:00:24.840 --> 00:00:28.380 
understand how these things run.
So if we kick things off we'll

9
00:00:28.380 --> 00:00:31.880 
start off with something relatively
simple which is we have here

10
00:00:31.980 --> 00:00:38.470 
a still DMN table and this is
going to check whether some

11
00:00:38.700 --> 00:00:43.080 
variable is check required is
produced there. So we are

12
00:00:43.080 --> 00:00:46.310 
basically starting this process
we're going to run this DMN

13
00:00:46.310 --> 00:00:50.140 
table at the end will produce
some data. Now that's important

14
00:00:50.140 --> 00:00:54.080 
because our export gateway I think
is is called the exclusive

15
00:00:54.080 --> 00:00:57.480 
gateway but it has a much longer much more
complicated. Nela do you know what that is?

16
00:00:57.650 --> 00:01:02.000 
It's a database exclusive gateway.
Sure is, now the database

17
00:01:02.000 --> 00:01:05.630 
thing is really important because this
particular gateway is going to need

18
00:01:05.810 --> 00:01:09.790 
specific data to exist by the
time we get to this point. So

19
00:01:09.790 --> 00:01:13.120 
for instance when we get to
here we are going to evaluate

20
00:01:13.820 --> 00:01:19.050 
what the variable is. So we actually need to
be able to help this gateway understand

21
00:01:19.170 --> 00:01:23.120 
that it's supposed to take this
variable and evaluate it based on

22
00:01:23.340 --> 00:01:27.330 
some criteria we give it. Some
obviously some gateways

23
00:01:27.330 --> 00:01:31.190 
don't require data but this one
absolutely does. So how do we do it?

24
00:01:31.490 --> 00:01:36.560 
Well if we actually imagine that we are
having this variable called approve created

25
00:01:36.680 --> 00:01:40.680 
we can look ahead and see that we
need to give something, we need

26
00:01:40.680 --> 00:01:44.840 
to use an expression. An expression
is a way of being able to validate

27
00:01:45.090 --> 00:01:50.690 
within the expression a a
resulting yes or no. Ok so a

28
00:01:50.690 --> 00:01:54.290 
resulting true or false. So that
means that if I start my expression

29
00:01:54.310 --> 00:01:57.610 
like this so expression will always
start with a little dollar sign there

30
00:01:57.860 --> 00:02:01.250 
and and open curly bracket and
then it'll end with that

31
00:02:01.250 --> 00:02:05.040 
curly brackets. So everything between
there is known as our expression.

32
00:02:05.350 --> 00:02:09.510 
This particular annotation is called JUEL
the java unified expression language

33
00:02:09.620 --> 00:02:13.130 
and it's used throughout the process
to do various bits and pieces.

34
00:02:13.490 --> 00:02:15.390 
The first thing we'll talk
about is actually what would

35
00:02:15.390 --> 00:02:19.040 
happen in this case in this case
we have the word approved

36
00:02:19.040 --> 00:02:23.220 
in the middle. Now that word
actually is specifically

37
00:02:23.220 --> 00:02:27.130 
related to a variable which means
that before this we would

38
00:02:27.130 --> 00:02:30.930 
have need to have the variable
approved populated with some value.

39
00:02:31.130 --> 00:02:36.100 
and what we're doing here is we're saying
if the variable approved is true

40
00:02:36.330 --> 00:02:39.630 
then the expression as a
whole resolves as true.

41
00:02:40.030 --> 00:02:45.000 
And then a then this expression
that is a true expression. Now

42
00:02:45.010 --> 00:02:49.150 
if we wanted to say go a certain
direction if this variable was false

43
00:02:49.340 --> 00:02:51.760 
then we would need
to say ok if

44
00:02:52.800 --> 00:02:55.820 
we have here our expression again,
our open brackets or dollar

45
00:02:55.820 --> 00:02:58.730 
sign on their closed brackets.
But now we have a new word here

46
00:02:58.730 --> 00:03:02.860 
it's a reserved word it's called
a it's a it's 'not'. Now this

47
00:03:02.860 --> 00:03:05.900 
is going to be sound pretty
a bit weird, a bit of

48
00:03:05.900 --> 00:03:09.280 
negative going on here. But the
way this works would be if I

49
00:03:09.280 --> 00:03:13.030 
put a knot in front of approved
that means that this expression

50
00:03:13.230 --> 00:03:18.570 
will resolve to true if the
variable is false. Meaning that

51
00:03:18.940 --> 00:03:22.400 
if the variable is false we will go
in the direction of this particular

52
00:03:22.550 --> 00:03:25.020 
sequence flow
for instance.

53
00:03:25.560 --> 00:03:28.660 
So now expressions can
be quite complex.

54
00:03:29.140 --> 00:03:32.210 
So for instance we happen to be using
here a very simple expression

55
00:03:32.210 --> 00:03:35.780 
that has a single variable and that
variable is either going to have

56
00:03:36.010 --> 00:03:40.680 
true or false value. But it's also possible
to have slightly more complex ones.

57
00:03:40.970 --> 00:03:43.910 
So actually you get very much
more complex ones but this is

58
00:03:43.910 --> 00:03:47.680 
a slightly more complex one. So for
instance if Nela was doing something

59
00:03:47.820 --> 00:03:52.260 
and her her she started this and
her first name of course Nela

60
00:03:52.460 --> 00:03:54.270 
if we had this expression
what would happen?

61
00:03:55.170 --> 00:03:58.550 
It would be false. It sure would,
because this expression says if

62
00:03:58.550 --> 00:04:02.760 
the first name is equal to Niall,
then it returns true. Sadly

63
00:04:02.760 --> 00:04:06.230 
Nela would not return true. So
with that in mind it's important

64
00:04:06.230 --> 00:04:09.820 
we explain this because these
expressions are used throughout

65
00:04:10.060 --> 00:04:14.440 
the process. But in the first
place is within gateways

66
00:04:14.450 --> 00:04:18.000 
as specifically on the sequence
flows leaving the gateways.

67
00:04:18.240 --> 00:04:21.330 
So if I select one of those we can
see here that I have selected

68
00:04:21.340 --> 00:04:25.720 
the yes path of the gateway right here.
So I select that sequence flow.

69
00:04:25.870 --> 00:04:29.740 
Now this is an exclusive gateway
which means it will only take

70
00:04:29.740 --> 00:04:33.260 
one of the two options. But we
still need to tell it exactly

71
00:04:33.270 --> 00:04:37.280 
why it should consider doing one
over the other. And to do that

72
00:04:37.280 --> 00:04:40.930 
we would select expression from
the condition type which is

73
00:04:40.930 --> 00:04:43.340 
what we've been talking about
already. And then we actually

74
00:04:43.350 --> 00:04:48.220 
add our condition here. So in this case
it says dollar sign open bracket

75
00:04:48.590 --> 00:04:52.750 
check required close bracket. Well
that just means that if the variable

76
00:04:52.920 --> 00:04:57.860 
check required is true we will go
in this direction. And presumably

77
00:04:57.960 --> 00:04:59.570 
if it's not true
what will happen?

78
00:05:00.190 --> 00:05:02.860 
We go to the other but we don't
know because I don't see what

79
00:05:02.860 --> 00:05:06.160 
you said on the other sequence
flow. So provided that I

80
00:05:06.160 --> 00:05:08.850 
did the correct no sequence
branch that we would go that

81
00:05:08.850 --> 00:05:11.910 
way if it's not required. So
that makes sense that's

82
00:05:12.730 --> 00:05:16.030 
hopefully that's understandable.
But now let's actually go to

83
00:05:16.030 --> 00:05:19.170 
something that is technically
more complicated

84
00:05:19.180 --> 00:05:23.730 
to understand but actually much
easier to execute. And that

85
00:05:23.730 --> 00:05:26.860 
is of course a parallel gateway.
Now unlike a database gateway

86
00:05:26.860 --> 00:05:31.770 
this does not require any
kind of a data anywhere.

87
00:05:31.820 --> 00:05:35.440 
In fact it doesn't even require
any execution semantics because

88
00:05:35.440 --> 00:05:39.230 
the engine when we get to this
point the token moves to the

89
00:05:39.230 --> 00:05:42.380 
parallel gateway. I'm sure if
you guys remember back when

90
00:05:42.380 --> 00:05:45.670 
you first talked about these it
creates two tokens. One will

91
00:05:45.670 --> 00:05:49.030 
go up to pick contract type and one
will go down to the same client data

92
00:05:49.220 --> 00:05:53.530 
and on the bottom. Now then
we have two tokens they're

93
00:05:53.530 --> 00:05:57.220 
in the same spot but you don't need
to tell the gateway anything.

94
00:05:57.320 --> 00:06:00.260 
That doesn't require any execution
semantics. The engine just

95
00:06:00.260 --> 00:06:06.020 
knows what to do. Similarly when
we arrive at the merging gateway

96
00:06:06.190 --> 00:06:10.500 
the engine also understands how that
works. So it says here that whenever

97
00:06:10.730 --> 00:06:14.650 
two tokens arrive we will
continue. Now why two tokens?

98
00:06:15.080 --> 00:06:18.410 
Because of two incoming sequence
flows. Very good. So actually

99
00:06:18.410 --> 00:06:22.020 
when the first token arrives that
gateway the reason it knows

100
00:06:22.090 --> 00:06:25.430 
to wait for a second one is because
it has two sequence flows,

101
00:06:25.590 --> 00:06:29.570 
not because the engine is counting
tokens from the previous

102
00:06:29.580 --> 00:06:32.590 
gateway. It is
important to know. So

103
00:06:33.260 --> 00:06:36.510 
to make this work that's basically what
you need to do. You don't you just

104
00:06:36.510 --> 00:06:39.320 
put it on the on the on the palate
and it just runs that way.

105
00:06:39.350 --> 00:06:41.770 
You don't need to worry about
any execution semantics.

106
00:06:42.200 --> 00:06:47.120 
Now let's actually talk about some
other gateways as well including

107
00:06:47.240 --> 00:06:49.310 
the event these gaming which
is probably the prettiest of

108
00:06:49.310 --> 00:06:51.710 
the gateways. Yeah but we won't
talk about this yet because

109
00:06:51.710 --> 00:06:55.920 
first we'll talk about events
themselves. And here are some

110
00:06:55.920 --> 00:07:01.410 
of the important ones. Just like
tasks these three event types

111
00:07:01.730 --> 00:07:05.780 
usually solve most problems that
are using events. There are more

112
00:07:05.780 --> 00:07:09.120 
event types but these are the
real key ones. So we have here

113
00:07:09.120 --> 00:07:12.750 
a timer event which is used if
you want to wait for a certain

114
00:07:13.290 --> 00:07:16.660 
time in the future maybe a duration
maybe a date and you want

115
00:07:16.660 --> 00:07:20.680 
to wait for a specific time. Then
on the far right there we have a

116
00:07:20.970 --> 00:07:26.530 
message event which is used for
waiting until an external system

117
00:07:26.710 --> 00:07:30.680 
tells us to continue and then
of course the middle guy

118
00:07:30.690 --> 00:07:34.020 
condition event. What does that
do Nela? Well it checks for a

119
00:07:34.020 --> 00:07:35.430 
certain condition
to be true.

120
00:07:36.190 --> 00:07:40.060 
So so we will wait there until
a specific condition becomes

121
00:07:40.060 --> 00:07:43.810 
true and that condition is usually
revolves around a local variable.

122
00:07:44.040 --> 00:07:47.220 
And if that local variable changes we
will then actually continue along.

123
00:07:47.550 --> 00:07:49.580 
So let's actually look into this
in more detail. Now that we

124
00:07:49.580 --> 00:07:52.440 
know what they are for it's
important how they actually run.

125
00:07:52.630 --> 00:07:56.760 
So the timeer event first of all has two
different ways of being implemented.

126
00:07:56.940 --> 00:07:59.890 
We have the top one up there
which is an intermediate timer

127
00:07:59.890 --> 00:08:03.270 
event and I've added there non
interrupting boundary event.

128
00:08:03.330 --> 00:08:07.170 
There are some important differences
between these two. So the

129
00:08:07.170 --> 00:08:11.580 
first thing is that both of them could
have a date that specifies some days

130
00:08:11.950 --> 00:08:16.470 
the token will not pass
through this until that date

131
00:08:16.650 --> 00:08:20.110 
there has is in the past. So
that could be true could use a

132
00:08:20.110 --> 00:08:23.340 
specific date in the future. You
could also use a duration which

133
00:08:23.340 --> 00:08:26.460 
is kind of interesting. In this
case what you could say is you

134
00:08:26.460 --> 00:08:30.510 
could say we will wait until
specific duration in this case

135
00:08:30.710 --> 00:08:35.790 
it says PT5M. Now this section
from the ISO standard 8601

136
00:08:35.890 --> 00:08:39.050 
and this stands for period
time five minutes.

137
00:08:40.130 --> 00:08:43.490 
Now if you wanted to wait for one
day and five minutes you would say

138
00:08:43.660 --> 00:08:50.550 
P1DT5M for it is accurate, a relatively
okay notation to understand

139
00:08:50.770 --> 00:08:53.370 
and it's available to look up,
it's a very common standard. And

140
00:08:53.370 --> 00:08:57.260 
it means that when the token arrives there
it'll wait five minutes until continuing.

141
00:08:57.450 --> 00:09:00.320 
This is how Nela described
earlier as being how would you

142
00:09:00.320 --> 00:09:03.310 
actually tell the engine to
understand five minutes irrelevant

143
00:09:03.310 --> 00:09:07.100 
of language. Well this is how we use a
language that the engine understands.

144
00:09:07.210 --> 00:09:10.140 
You could also use a more complicated
thing called a Cron time.

145
00:09:10.290 --> 00:09:13.750 
We could specify a very specific
time of the week for instance.

146
00:09:14.050 --> 00:09:17.240 
Now the reason I have that non
interrupting event there is because

147
00:09:18.100 --> 00:09:22.350 
unlike the intermediate one we
could have a cycle time. And

148
00:09:22.350 --> 00:09:26.780 
this would mean that we
would actually select the

149
00:09:26.780 --> 00:09:30.630 
event and we would say I would like
this to happen every five minutes.

150
00:09:30.760 --> 00:09:33.530 
So in the topic example up there
at the intermediate event

151
00:09:33.570 --> 00:09:37.170 
we basically have the ability
to wait for specific duration

152
00:09:37.170 --> 00:09:43.370 
than continue and once we continue that's
all over. But in a non interrupting event

153
00:09:43.480 --> 00:09:47.580 
we could have a token of the user
task. And we could say every

154
00:09:47.580 --> 00:09:50.880 
five minutes create a new token on
the non-interrupted boundary event.

155
00:09:51.090 --> 00:09:54.740 
And then send a reminder for
instance. And in this case

156
00:09:54.740 --> 00:09:58.720 
you would do that by saying
putting an R/ in front of

157
00:09:58.950 --> 00:10:03.780 
the duration. If you do that then
it will repeat forever every five

158
00:10:03.780 --> 00:10:08.230 
minutes as it says there
R4/PT5M. You could

159
00:10:08.230 --> 00:10:12.280 
also use the repeat for a specific
amount of time in which

160
00:10:12.280 --> 00:10:16.420 
you would say repeat for three
minutes repeat three times every

161
00:10:16.420 --> 00:10:20.030 
five minutes by
saying R3/PT5M.

162
00:10:20.510 --> 00:10:25.530 
Ok so let's not look into
conditional events. Conditional

163
00:10:25.530 --> 00:10:29.400 
events as Nela said waits for a
specific condition to become true.

164
00:10:29.470 --> 00:10:33.530 
Now luckily that lovely stuff you learned
earlier about exclusive gateways

165
00:10:33.640 --> 00:10:39.450 
are also true here so you can actually put
an a specific expression within your

166
00:10:39.730 --> 00:10:43.240 
conditional event that waits for
something to happen. Now conditions

167
00:10:43.240 --> 00:10:47.720 
can be quite complicated. In this case
it just says if some variable is true

168
00:10:47.870 --> 00:10:52.010 
then we would continue. Now the way the
condition event actually works is

169
00:10:52.190 --> 00:10:57.180 
every single time the variable is
changed anywhere in the context

170
00:10:57.280 --> 00:11:00.490 
it would re-evaluate every
condition that has a token on it.

171
00:11:01.120 --> 00:11:03.980 
And now that brings us down to the
one the guy there at the bottom

172
00:11:04.190 --> 00:11:06.830 
that's a non interrupting one which
means that you could technically

173
00:11:06.830 --> 00:11:10.090 
trigger this condition multiple
times as many times as you need to

174
00:11:10.470 --> 00:11:15.060 
rather than a timer that will wait for
a specific duration before triggering

175
00:11:15.210 --> 00:11:18.200 
this would happen every single
time this condition is met.

176
00:11:19.290 --> 00:11:23.650 
Ok so you can also if you want to
choose to evaluate the condition

177
00:11:23.670 --> 00:11:27.880 
just face on a specific variable.
So for instance if my

178
00:11:27.930 --> 00:11:31.300 
if my expression says some variable
I only really care about

179
00:11:31.300 --> 00:11:34.460 
that specific variable changing. I don't
really care about the rest of them.

180
00:11:34.640 --> 00:11:38.260 
So I could tell the engine
by saying as you say there

181
00:11:38.290 --> 00:11:42.020 
but in the bottom there it says
if the variable some variable

182
00:11:42.460 --> 00:11:46.250 
is updated that's the only time I want
you to evaluate this expression.

183
00:11:46.900 --> 00:11:50.080 
And this makes sure that it doesn't
evaluate it more often than it needs to.

184
00:11:52.130 --> 00:11:55.470 
So message events these are
actually really really easy to

185
00:11:55.470 --> 00:11:58.660 
implement from a receive point of
view they're more complicated

186
00:11:58.660 --> 00:12:04.280 
to send but the idea is you just need
to add a message name to the event.

187
00:12:04.440 --> 00:12:08.660 
So if I select my message
event non interrupting

188
00:12:08.660 --> 00:12:13.530 
or interrupting I would end up
actually giving it a message name.

189
00:12:14.370 --> 00:12:17.800 
Ok the message can be triggered
when a message of the same

190
00:12:17.800 --> 00:12:21.310 
name is sent to the engine. Now
that's interesting because we

191
00:12:21.310 --> 00:12:24.880 
could have a problem with this,
because as we know messages

192
00:12:24.880 --> 00:12:28.660 
have a very specific criteria when it
comes to being received. What are they?

193
00:12:28.910 --> 00:12:31.690 
It's a one to one correlation
so you should make sure that

194
00:12:31.690 --> 00:12:34.580 
it's just one recipient for the
message, what if you have two

195
00:12:34.580 --> 00:12:37.950 
tokens or two different
instances at your user

196
00:12:37.950 --> 00:12:41.910 
task at that time? Exactly right
because we can have lots and

197
00:12:41.910 --> 00:12:45.520 
lots of instances that all
start, we could have twenty or

198
00:12:45.520 --> 00:12:49.120 
thirty instances of say on the
same message event. And if we

199
00:12:49.120 --> 00:12:52.810 
want which is actually fine but
we need to because messages

200
00:12:52.810 --> 00:12:56.740 
in BPMN have a requirement to
have a one to one correlation

201
00:12:57.000 --> 00:12:59.140 
it means you must make sure you
find the one you're looking

202
00:12:59.140 --> 00:13:01.030 
for. And we can
do this by

203
00:13:01.820 --> 00:13:05.550 
waiting for things like a
business key or a variable that

204
00:13:05.550 --> 00:13:10.020 
match. So instead of saying to the engine
I would like to send this message called

205
00:13:10.130 --> 00:13:14.460 
a message name I would instead say
I would like to find a process

206
00:13:14.460 --> 00:13:18.370 
that has a message name and that
has a business key that matches x

207
00:13:18.490 --> 00:13:22.400 
and it also an instance as a variable
that matches y for instance.

208
00:13:22.480 --> 00:13:24.970 
And that will get you down
to a specific instance.

209
00:13:25.380 --> 00:13:27.630 
And that's usually a really
really good way of actually

210
00:13:27.630 --> 00:13:29.740 
making sure that these things
are implemented correctly.

211
00:13:30.260 --> 00:13:33.760 
So the things that we would have talked
through just now with these gateways

212
00:13:34.650 --> 00:13:38.580 
and events are the idea that
technical attributes go on sequence

213
00:13:38.580 --> 00:13:41.920 
flows for exclusive gateways and
where we would use something called

214
00:13:41.920 --> 00:13:46.190 
an expression language in order to
evaluate those conditions. And

215
00:13:46.330 --> 00:13:49.780 
there are also technical attributes
for events for time events

216
00:13:49.780 --> 00:13:53.460 
such as a specific date a
specific duration and even

217
00:13:53.460 --> 00:13:57.120 
a cycle time so the date, so the
event could keep on triggering.

218
00:13:57.430 --> 00:13:59.920 
Also there are technical attributes
on conditional events which

219
00:13:59.930 --> 00:14:03.100 
also use these expressions
we talked about. And

220
00:14:03.610 --> 00:14:07.920 
we can also ensure the engine only
checks these on a very specific

221
00:14:07.920 --> 00:14:12.290 
time like for instance when they are actually
executed And finally a message event

222
00:14:12.440 --> 00:14:17.060 
very very easy to be able
to to add or receive

223
00:14:17.060 --> 00:14:20.410 
because all you to do on a receive
is add the message name.

224
00:14:20.420 --> 00:14:24.030 
But it's a lot more complicated
to actually send the message

225
00:14:24.060 --> 00:14:28.090 
under the particular case
and you would need

226
00:14:28.090 --> 00:14:32.070 
to add a business key or a
variable. So hopefully now we've

227
00:14:32.070 --> 00:14:35.370 
got your good idea of understanding
what's going on. Next

228
00:14:35.370 --> 00:14:38.460 
up is the exciting part where we're
actually going to be making things

229
00:14:38.460 --> 00:14:42.290 
run and showing you how to actually
practically do things. So

230
00:14:42.770 --> 00:14:43.290 
talk to you then.
