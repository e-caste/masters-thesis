WEBVTT

1
00:00:00.670 --> 00:00:03.819 
Welcome back to the second video in this part of the lecture

2
00:00:03.820 --> 00:00:06.909 
series on the POWER processor microarchitecture.

3
00:00:06.910 --> 00:00:09.309 
My name is Arni Ingimundarson.

4
00:00:09.310 --> 00:00:12.429 
And in this part,

5
00:00:12.430 --> 00:00:15.549 
I want to give you an overview of the POWER4 and the POWER5

6
00:00:15.550 --> 00:00:16.550 
microarchitecture.

7
00:00:19.180 --> 00:00:22.389 
Before we begin, a quick reminder of what we talked

8
00:00:22.390 --> 00:00:24.579 
about in the last video.

9
00:00:24.580 --> 00:00:28.329 
There I introduced you to the DLX microarchitecture,

10
00:00:28.330 --> 00:00:30.160 
showing you its five-stage

11
00:00:31.510 --> 00:00:35.379 
pipeline and giving you a

12
00:00:35.380 --> 00:00:38.709 
first glimpse of a simple block diagram of

13
00:00:38.710 --> 00:00:40.630 
how DLX microarchitecture

14
00:00:41.770 --> 00:00:43.030 
processor could look like.

15
00:00:46.310 --> 00:00:49.579 
And this video I want to talk about the POWER4

16
00:00:49.580 --> 00:00:51.552 
and the POWER5 microprocessors.

17
00:00:54.110 --> 00:00:57.049 
The POWER4 was introduced in 2001.

18
00:00:58.460 --> 00:01:00.761 
It has two single-threaded cores

19
00:01:02.420 --> 00:01:04.169 
on one chip.

20
00:01:04.170 --> 00:01:06.170 
It had a frequency of

21
00:01:07.220 --> 00:01:09.442 
1.1 up to 1.9 Gigahertz.

22
00:01:10.520 --> 00:01:13.819 
The POWER4 processor could be connected

23
00:01:13.820 --> 00:01:17.599 
together, 16 chips together in an SMP

24
00:01:17.600 --> 00:01:19.760 
(symmetric multiprocessing system),

25
00:01:20.900 --> 00:01:23.105 
giving you a 32-waySMP

26
00:01:24.260 --> 00:01:26.449 
and the POWER4 was

27
00:01:27.560 --> 00:01:29.440 
released in two technology steps in

28
00:01:30.980 --> 00:01:34.369 
180 nanometers and then later in 130

29
00:01:34.370 --> 00:01:35.370 
nanometers.

30
00:01:36.380 --> 00:01:38.809 
The POWER5 microarchitecture

31
00:01:41.060 --> 00:01:44.080 
or microprocessor was introduced in 2004.

32
00:01:45.200 --> 00:01:46.849 
It added,

33
00:01:48.470 --> 00:01:50.599 
for the first time in the industry,

34
00:01:52.190 --> 00:01:53.280 
an unsymmetric

35
00:02:04.400 --> 00:02:04.419 
multi-threading on one core. So it has two cores, each core supporting two hardware threads. It supported clock frequency

36
00:02:04.420 --> 00:02:08.749 
for 1.5 to 2.3 Gigahertz, and it extended

37
00:02:08.750 --> 00:02:12.079 
the capabilities of the connection

38
00:02:12.080 --> 00:02:13.490 
of multiple chips together,

39
00:02:15.350 --> 00:02:19.189 
enabling connection of 32 chips which

40
00:02:19.190 --> 00:02:22.849 
resulted in a 64 way SMP system,

41
00:02:22.850 --> 00:02:24.817 
or 128 hardware threads.

42
00:02:26.360 --> 00:02:30.049 
The processor was released in 130 nanometers

43
00:02:30.050 --> 00:02:32.390 
and later in 90 nanometer technologies.

44
00:02:37.490 --> 00:02:40.909 
Here you see a die or picture

45
00:02:40.910 --> 00:02:43.606 
of the chips of the POWER4 and POWER5,

46
00:02:45.800 --> 00:02:49.429 
and as you can see, we have multiple units on

47
00:02:49.430 --> 00:02:52.039 
that chip. And I want to walk you through what these

48
00:02:52.040 --> 00:02:54.289 
abbreviations mean.

49
00:02:55.370 --> 00:02:58.579 
So first we start with and

50
00:02:58.580 --> 00:02:59.580 
the IFU and the BXU.

51
00:03:01.040 --> 00:03:04.159 
The IFU stands for Instruction Fetch Unit,

52
00:03:04.160 --> 00:03:07.729 
which is the unit and part of the processor that fetches

53
00:03:07.730 --> 00:03:10.729 
the instructions from the memory

54
00:03:12.020 --> 00:03:15.199 
and also does the branch prediction and

55
00:03:15.200 --> 00:03:16.200 
branch execution.

56
00:03:23.030 --> 00:03:26.479 
The next stage and in the process

57
00:03:26.480 --> 00:03:29.599 
is, say, the Instruction Decode Unit (IDU),

58
00:03:29.600 --> 00:03:32.749 
which received the instructions fetched by the Instruction

59
00:03:32.750 --> 00:03:36.049 
Fetch Unit and decodes them and passes them on

60
00:03:36.050 --> 00:03:37.589 
in the system.

61
00:03:37.590 --> 00:03:41.329 
And as you can see, both the POWER4 and POWER5

62
00:03:41.330 --> 00:03:44.749 
are very similar in their system and

63
00:03:44.750 --> 00:03:46.459 
their structure.

64
00:03:46.460 --> 00:03:49.549 
The third unit in the pipeline of a POWER

65
00:03:49.550 --> 00:03:52.999 
processor is the Instruction Sequencing Unit (ISU),

66
00:03:53.000 --> 00:03:56.119 
which takes/receives the decoded instructions

67
00:03:56.120 --> 00:04:00.619 
from the Instruction Fetch Unit and

68
00:04:00.620 --> 00:04:04.279 
reorders them to enable out of order execution

69
00:04:04.280 --> 00:04:05.419 
of these instructions.

70
00:04:08.860 --> 00:04:12.479 
The execution

71
00:04:12.480 --> 00:04:15.869 
units in the system are the floating-point execution

72
00:04:15.870 --> 00:04:19.049 
unit, as well as the fixed-point

73
00:04:19.050 --> 00:04:22.919 
execution unit. Fixed-point in opposition to a floating-point

74
00:04:22.920 --> 00:04:26.429 
and fixed-point execution units includes all the logical

75
00:04:26.430 --> 00:04:27.889 
operations as well.

76
00:04:29.160 --> 00:04:32.609 
And these units receive the instruction from the

77
00:04:32.610 --> 00:04:35.279 
instruction sequencing unit.

78
00:04:35.280 --> 00:04:38.519 
And as I said before here, these

79
00:04:38.520 --> 00:04:42.059 
units can receive the instruction out of order.

80
00:04:42.060 --> 00:04:45.509 
And the third execution

81
00:04:45.510 --> 00:04:48.569 
unit, in a sense, is the Load Store

82
00:04:48.570 --> 00:04:52.409 
Unit (LSU), which receives all the load-store instructions

83
00:04:52.410 --> 00:04:55.199 
which read and write data to the memory.

84
00:04:59.730 --> 00:05:02.660 
The POWER4 and POWER5 have an on-chip

85
00:05:04.110 --> 00:05:07.259 
Level-2 (L2) cache in the system, and

86
00:05:07.260 --> 00:05:11.039 
this cache is a shared cache for both instructions

87
00:05:11.040 --> 00:05:12.040 
and data.

88
00:05:13.080 --> 00:05:16.199 
And although not directly

89
00:05:16.200 --> 00:05:18.515 
depicted here, we see that in the LSU

90
00:05:20.070 --> 00:05:24.149 
here and here and in the IFU

91
00:05:24.150 --> 00:05:27.449 
here, we have an array

92
00:05:27.450 --> 00:05:30.719 
of memory for the instructions

93
00:05:30.720 --> 00:05:33.929 
and data caches which are located in those

94
00:05:33.930 --> 00:05:34.930 
units as well.

95
00:05:38.700 --> 00:05:40.534 
The POWER5

96
00:05:41.820 --> 00:05:44.939 
has a memory control

97
00:05:44.940 --> 00:05:48.689 
on-chip while the POWER4 does not have one.

98
00:05:48.690 --> 00:05:50.970 
While both versions have

99
00:05:52.110 --> 00:05:55.229 
an L3 directory and control, which is managing

100
00:05:55.230 --> 00:05:58.499 
the cache, the Level-3 cache,

101
00:05:58.500 --> 00:06:02.369 
which is on an extra chip

102
00:06:02.370 --> 00:06:04.980 
in the systems. They are not on the same chip.

103
00:06:08.430 --> 00:06:11.969 
And we can see here a more

104
00:06:11.970 --> 00:06:15.539 
block diagram overview of what the differences

105
00:06:15.540 --> 00:06:19.119 
of these two processors are.

106
00:06:19.120 --> 00:06:20.120 
We see that

107
00:06:23.040 --> 00:06:24.420 
both controllers have

108
00:06:26.910 --> 00:06:30.659 
L3 memory off-chip, while the controllers

109
00:06:30.660 --> 00:06:34.649 
for the L3 memory, they're not depicted in this block diagram

110
00:06:34.650 --> 00:06:37.703 
are on-chip and the POWER4

111
00:06:38.880 --> 00:06:41.395 
has the memory controller off-chip,

112
00:06:42.690 --> 00:06:46.019 
while the POWER5 has the memory

113
00:06:46.020 --> 00:06:49.229 
controller on-chip, which enables

114
00:06:49.230 --> 00:06:51.569 
higher performance in the memory subsystem.

115
00:06:57.350 --> 00:07:00.529 
In this diagram, we see an

116
00:07:00.530 --> 00:07:03.739 
overview of the whole block diagram of the whole

117
00:07:03.740 --> 00:07:06.929 
chip and here

118
00:07:06.930 --> 00:07:09.979 
things are starting

119
00:07:09.980 --> 00:07:13.039 
to get a little bit more complicated, and especially

120
00:07:13.040 --> 00:07:14.259 
if we keep the DLX microarchitecture

121
00:07:16.310 --> 00:07:19.150 
in our mind, the POWER4

122
00:07:20.600 --> 00:07:24.139 
and the POWER5 of which are both very similar

123
00:07:24.140 --> 00:07:27.146 
in their architecture. We have two processor cores

124
00:07:28.790 --> 00:07:30.319 
in the system.

125
00:07:30.320 --> 00:07:33.439 
We have a core interface unit which

126
00:07:33.440 --> 00:07:35.858 
connects both cores to the cache

127
00:07:37.370 --> 00:07:38.959 
system.

128
00:07:38.960 --> 00:07:42.139 
We have three blocks of L2

129
00:07:42.140 --> 00:07:45.229 
cache and remember that the L2 caches are

130
00:07:45.230 --> 00:07:46.958 
shared instruction and data cache.

131
00:07:48.560 --> 00:07:51.500 
We have one block or two blocks of

132
00:07:53.000 --> 00:07:55.100 
non-caching unit,

133
00:07:56.900 --> 00:08:00.109 
one for each core, for all the memory

134
00:08:00.110 --> 00:08:03.859 
operations that must not go through

135
00:08:03.860 --> 00:08:05.149 
the cache, for example.

136
00:08:08.100 --> 00:08:11.369 
I/O operations going to peripherals on

137
00:08:11.370 --> 00:08:14.290 
the peripherals buses.

138
00:08:17.660 --> 00:08:19.579 
I mentioned in the introduction that

139
00:08:21.080 --> 00:08:24.470 
you can connect multiple POWER4 and POWER5 chips together

140
00:08:27.050 --> 00:08:30.199 
in an SMP system and

141
00:08:30.200 --> 00:08:34.158 
the fabric controller here is the unit

142
00:08:34.159 --> 00:08:37.369 
that manages, first of all, the traffic between these two

143
00:08:37.370 --> 00:08:40.609 
cores, as well as the connections to

144
00:08:40.610 --> 00:08:43.428 
other chips in the system.

145
00:08:43.429 --> 00:08:45.799 
And we will talk more about that in the next video.

146
00:08:48.020 --> 00:08:51.229 
And as I mentioned before,

147
00:08:51.230 --> 00:08:54.649 
both POWER4 and POWER5 have an L-3 cache directory

148
00:08:54.650 --> 00:08:56.668 
and an L-3 controller

149
00:09:32.170 --> 00:09:32.364 
on board. And this unit here is the I/O unit, which is connecting to other I/O peripherals of the system. Let us now look

150
00:09:32.365 --> 00:09:32.387 
at the instruction pipeline of POWER4 and POWER5, which are identical. And as you can see, I have put up here the example

151
00:09:32.388 --> 00:09:33.669 
of the DLX instruction pipeline. And we want to try to show you that even though the pipeline of the POWER processor is

152
00:09:33.670 --> 00:09:36.969 
longer and a little bit more complex, we can still

153
00:09:36.970 --> 00:09:39.279 
see each unit of these

154
00:09:40.540 --> 00:09:41.960 
in the POWER pipeline.

155
00:09:43.300 --> 00:09:46.269 
So the first one is here is the

156
00:09:47.830 --> 00:09:49.480 
instruction fetch.

157
00:09:51.710 --> 00:09:54.829 
And we have the

158
00:09:54.830 --> 00:09:57.619 
instruction cache here as well.

159
00:09:57.620 --> 00:10:00.769 
And then we have a branch prediction and that

160
00:10:00.770 --> 00:10:02.839 
feeds back to the instruction fetch unit.

161
00:10:02.840 --> 00:10:05.969 
And so these are corresponding to the

162
00:10:05.970 --> 00:10:09.259 
IF unit in the DLX pipeline.

163
00:10:09.260 --> 00:10:12.899 
Then we have a series of decode stages.

164
00:10:14.840 --> 00:10:18.109 
The POWER has hundreds and thousands of

165
00:10:18.110 --> 00:10:20.090 
different instructions and

166
00:10:23.450 --> 00:10:26.749 
we need multiple stages to be able to decode all the

167
00:10:26.750 --> 00:10:30.019 
instructions correctly, there is

168
00:10:30.020 --> 00:10:33.569 
a detail here

169
00:10:33.570 --> 00:10:36.779 
listed as well as some instructions are actually split

170
00:10:36.780 --> 00:10:40.349 
up into multiple smaller instructions,

171
00:10:40.350 --> 00:10:43.679 
which is called cracking, as well

172
00:10:43.680 --> 00:10:46.769 
as a group

173
00:10:46.770 --> 00:10:49.260 
formation, which is

174
00:10:51.750 --> 00:10:54.809 
to help the architecture being able to

175
00:10:54.810 --> 00:10:57.330 
process more instructions in parallel in this system.

176
00:10:59.160 --> 00:11:03.209 
So the completion of the in-flight

177
00:11:03.210 --> 00:11:06.329 
bookkeeping of instructions is done in groups and

178
00:11:06.330 --> 00:11:08.729 
not on an individual instruction basis.

179
00:11:10.320 --> 00:11:13.649 
And so, like I said, the decoding

180
00:11:13.650 --> 00:11:17.039 
stages here corresponding to the instruction decoding

181
00:11:17.040 --> 00:11:18.320 
stage on the DLX.

182
00:11:20.800 --> 00:11:24.449 
We have here,

183
00:11:24.450 --> 00:11:27.569 
a stage called Group Dispatch, and then

184
00:11:27.570 --> 00:11:28.570 
followed by mapping stages.

185
00:11:29.760 --> 00:11:32.889 
And the group dispatch that dispatches

186
00:11:32.890 --> 00:11:36.369 
instructions into four separate instruction execution

187
00:11:36.370 --> 00:11:37.370 
pipelines.

188
00:11:38.950 --> 00:11:42.309 
The mapping stage maps, the resources required

189
00:11:42.310 --> 00:11:46.029 
for the instruction to be executed and reserves

190
00:11:46.030 --> 00:11:49.359 
those resources before passing it

191
00:11:49.360 --> 00:11:52.449 
into the issue

192
00:11:52.450 --> 00:11:55.739 
queue where the instructions

193
00:11:55.740 --> 00:11:58.809 
are then finally issued to the execution pipeline.

194
00:12:00.150 --> 00:12:04.499 
So these stages are somewhat between

195
00:12:04.500 --> 00:12:07.709 
the instruction decoding and execute statement

196
00:12:07.710 --> 00:12:10.279 
on the DLX microarchitecture.

197
00:12:11.550 --> 00:12:13.019 
And yeah,

198
00:12:14.850 --> 00:12:17.939 
as soon as an instruction is issued

199
00:12:17.940 --> 00:12:21.239 
to the execution stage, what the first

200
00:12:21.240 --> 00:12:24.359 
stage here is the register

201
00:12:24.360 --> 00:12:27.539 
file stage, which happened on the

202
00:12:27.540 --> 00:12:30.720 
DLX in the instruction decode stage if you remember.

203
00:12:32.520 --> 00:12:35.369 
The register file stage, reads out the operands from the

204
00:12:35.370 --> 00:12:38.819 
register file and passes them on to the individual

205
00:12:38.820 --> 00:12:40.229 
execution unit.

206
00:12:40.230 --> 00:12:43.319 
And we have a branch execution unit here.

207
00:12:43.320 --> 00:12:46.799 
We have a load-store unit,

208
00:12:46.800 --> 00:12:49.859 
we have a fixed-point unit

209
00:12:49.860 --> 00:12:51.179 
and a

210
00:13:06.000 --> 00:13:07.529 
floating-point unit, which is longer than the other stages. We have a write back stage which is where the write back

211
00:13:07.530 --> 00:13:11.219 
of that execution is being planned,

212
00:13:11.220 --> 00:13:12.468 
and here we have the,

213
00:13:15.680 --> 00:13:17.649 
where the write back of the results are returned back to the

214
00:13:17.650 --> 00:13:19.905 
register file and

215
00:13:23.280 --> 00:13:24.944 
we have a transport stage

216
00:13:28.080 --> 00:13:31.679 
where the data is actually being moved to the register file

217
00:13:31.680 --> 00:13:34.739 
and the instructions are all finished in a completion

218
00:13:34.740 --> 00:13:38.159 
stage where the bookkeeping of which instructions

219
00:13:38.160 --> 00:13:41.219 
are in flight are being finally

220
00:13:41.220 --> 00:13:44.939 
updated and completed instructions are removed from that

221
00:13:44.940 --> 00:13:45.940 
bookkeeping.

222
00:13:51.030 --> 00:13:54.119 
This view is a

223
00:13:54.120 --> 00:13:55.919 
block diagram view of the core

224
00:13:57.540 --> 00:13:58.651 
architecture of the POWER4 and POWER5.

225
00:14:02.670 --> 00:14:05.999 
Here, we see as well many of the

226
00:14:06.000 --> 00:14:09.059 
other names that I've talked about before, but also some more

227
00:14:09.060 --> 00:14:10.060 
details.

228
00:14:12.530 --> 00:14:15.289 
This block here is showing the instruction to fetch address

229
00:14:15.290 --> 00:14:17.195 
register, which is

230
00:14:18.430 --> 00:14:21.699 
indexing into the instruction cache from

231
00:14:21.700 --> 00:14:24.789 
which we get the instruction word, which is

232
00:14:24.790 --> 00:14:26.139 
added into the instruction

233
00:14:28.120 --> 00:14:30.917 
queue. From the instruction queue, we have the decode stages

234
00:14:32.950 --> 00:14:36.099 
as well as information passing through the

235
00:14:36.100 --> 00:14:39.219 
global completion table, which is managing

236
00:14:39.220 --> 00:14:42.369 
which instructions are in flight and

237
00:14:42.370 --> 00:14:44.773 
finishing instructions when they are complete.

238
00:14:47.200 --> 00:14:50.649 
Then we see that instruction go through the four execution

239
00:14:50.650 --> 00:14:54.009 
pipelines we saw earlier in the instruction

240
00:14:54.010 --> 00:14:55.010 
pipeline.

241
00:14:55.960 --> 00:14:59.259 
And the instructions are

242
00:14:59.260 --> 00:15:02.409 
stored in a queue and then issued

243
00:15:02.410 --> 00:15:06.219 
out of order from these queues into the individual

244
00:15:06.220 --> 00:15:09.489 
execution units, depending on

245
00:15:09.490 --> 00:15:13.039 
as soon as all operands are available and the resources

246
00:15:13.040 --> 00:15:16.269 
available for, then the instructions

247
00:15:16.270 --> 00:15:17.270 
are being issued.

248
00:15:19.210 --> 00:15:20.210 
The

249
00:15:28.490 --> 00:15:30.191 
load-store execution pipeline, of course, connects the execution to the data cache

250
00:15:31.190 --> 00:15:34.549 
for read, as well as for the store operation

251
00:15:34.550 --> 00:15:37.609 
where these stored words go

252
00:15:37.610 --> 00:15:39.429 
into a storage queue as well.

253
00:15:45.380 --> 00:15:48.529 
So I hope this has been a little

254
00:15:48.530 --> 00:15:51.589 
bit helpful to give you a brief glimpse into

255
00:15:51.590 --> 00:15:54.769 
how the architecture looks like, as last

256
00:15:54.770 --> 00:15:58.369 
time I have here, the list of of the literature

257
00:15:58.370 --> 00:16:01.409 
for reading. And I want to thank you

258
00:16:01.410 --> 00:16:04.459 
all for your attention this time and hope to see you in

259
00:16:04.460 --> 00:16:05.460 
the next video.
