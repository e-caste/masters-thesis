WEBVTT

1
00:00:00.340 --> 00:00:04.420 
hi everyone i'm charis charitsis,
i'm a phd candidate at stanford university.

2
00:00:04.860 --> 00:00:07.740 
i would like to give you some presentation of our work on qualitative

3
00:00:07.740 --> 00:00:11.720 
code assessment in cs one and specifically function names first.

4
00:00:11.740 --> 00:00:14.450 
i would like to touch upon the motivation behind our research.

5
00:00:14.940 --> 00:00:18.260 
in recent years software complexity has been increasing exponentially.

6
00:00:18.720 --> 00:00:21.510 
the new code a professional programmer writes per year is a

7
00:00:21.510 --> 00:00:24.960 
small fraction of the production volume developers spend a

8
00:00:24.960 --> 00:00:28.470 
significant portion of their time on existing code as a result

9
00:00:28.860 --> 00:00:31.350 
the software industry looks for programmers who can write code

10
00:00:31.350 --> 00:00:33.790 
that is readable and resilient to modifications,

11
00:00:34.230 --> 00:00:38.210 
however cs one students focus almost entirely on functionality

12
00:00:38.310 --> 00:00:40.310 
while code style gets often overlooked

13
00:00:41.030 --> 00:00:44.170 
to make matters worse.
teaching students how to write quality

14
00:00:44.170 --> 00:00:46.190 
code takes a lot of time and effort

15
00:00:46.790 --> 00:00:50.220 
on the other hand enrollment in cs one courses keeps increasing

16
00:00:50.220 --> 00:00:54.160 
at a high rate whereas the available human resources per
student are limited.

17
00:00:54.720 --> 00:00:58.580 
in our study we try to automate qualitative assessment we focus

18
00:00:58.580 --> 00:01:00.340 
on function names and how to improve them.

19
00:01:01.130 --> 00:01:03.320 
but why do we find function names important

20
00:01:03.830 --> 00:01:07.210 
writable software originates in its building block the function

21
00:01:07.770 --> 00:01:10.280 
documentation begins with identifier selection

22
00:01:10.710 --> 00:01:14.410 
a common that describes a function appears in a single place
its declaration

23
00:01:14.950 --> 00:01:18.730 
a clear description of the performed task is vital to maintainability.

24
00:01:19.330 --> 00:01:22.630 
however, a function can be called from anywhere in the code.

25
00:01:23.010 --> 00:01:26.380 
ambiguous names in those calls can cause confusion introduce

26
00:01:26.380 --> 00:01:29.570 
bugs and interrupt the thought process on the other hand a

27
00:01:29.570 --> 00:01:33.320 
name that captures with clarity the intended task makes a code editable
in our work.

28
00:01:34.320 --> 00:01:37.750 
we introduce a semi-automated technique to evaluate

29
00:01:37.750 --> 00:01:41.050 
function names and suggest better alternatives for the poor ones.

30
00:01:41.530 --> 00:01:45.430 
the process works as follows first we collect a corpus of student

31
00:01:45.430 --> 00:01:47.440 
code submissions for a particular assignment.

32
00:01:47.840 --> 00:01:51.010 
next we extract the function names from every submission code.

33
00:01:51.530 --> 00:01:55.560 
we use a subset of them and manually assign a score between one and four

34
00:01:55.850 --> 00:01:59.370 
based on the quality of the names, then we use machine learning

35
00:01:59.370 --> 00:02:02.250 
to train a classifier to automatically. label the rest of the

36
00:02:02.250 --> 00:02:05.620 
corpus of functions with a score a score of four means that

37
00:02:05.620 --> 00:02:08.800 
a function has a good name any other score means that there

38
00:02:08.800 --> 00:02:13.360 
is a room for improvement our goal is to replace
bad names with better ones.

39
00:02:13.550 --> 00:02:16.330 
however, we can select a replacement widely.

40
00:02:16.790 --> 00:02:18.880 
the two functions must have the same behavior

41
00:02:19.410 --> 00:02:21.960 
to take that we put in place the following mechanism.

42
00:02:22.480 --> 00:02:26.050 
we automatically instrument every student's code
to capture the memory state

43
00:02:26.240 --> 00:02:29.760 
at every function entrance and exit point which represent the

44
00:02:29.760 --> 00:02:31.750 
precondition and postcondition respectively.

45
00:02:32.390 --> 00:02:36.490 
then we run a matching algorithm that finds functions
with identical behavior

46
00:02:37.170 --> 00:02:41.320 
the algorithm verifies that after swapping two
functions in their respective programs.

47
00:02:41.610 --> 00:02:45.390 
the execution remains unaffected now for any function with a bad name.

48
00:02:45.390 --> 00:02:48.400 
we can search for one with identical behavior that

49
00:02:48.400 --> 00:02:51.980 
has a better score before closing this representation.

50
00:02:51.980 --> 00:02:54.560 
i would like to elaborate briefly on our classification method.

51
00:02:55.240 --> 00:02:58.190 
we're talking as a function names using the naming conventions

52
00:02:58.210 --> 00:03:01.870 
of the underlying programming language using the training set.

53
00:03:02.130 --> 00:03:04.860 
we calculate the probabilities that are talking a person name

54
00:03:04.860 --> 00:03:09.340 
with a given score next for unseen names.
we calculate the product of the

55
00:03:09.630 --> 00:03:12.940 
probabilities and pick the highest as a models prediction.

56
00:03:13.470 --> 00:03:16.140 
the results presented in our paper indicate that this model

57
00:03:16.140 --> 00:03:17.120 
is quite accurate.
