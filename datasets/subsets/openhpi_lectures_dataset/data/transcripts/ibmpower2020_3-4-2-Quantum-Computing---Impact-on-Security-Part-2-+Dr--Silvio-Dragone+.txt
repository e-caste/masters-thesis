WEBVTT

1
00:00:00.950 --> 00:00:07.520 
so hello and welcome back to my
second part of my presentation

2
00:00:07.530 --> 00:00:13.110 
about cybersecurity research in
the age of quantum computing.

3
00:00:13.630 --> 00:00:18.890 
my name is Silvio Dragone and
I am from IBM research.

4
00:00:20.210 --> 00:00:24.030 
so in the first part of my
presentation, we went

5
00:00:24.690 --> 00:00:29.740 
through kind of the classical
algorithm and its mathematics

6
00:00:30.380 --> 00:00:36.240 
and we got the notion on an idea
how quantum computer are going to

7
00:00:36.400 --> 00:00:43.190 
impact those classical an
algorithm. and we made a small

8
00:00:43.190 --> 00:00:47.170 
risk assessment of
these impacts.

9
00:00:48.600 --> 00:00:53.520 
in this second part of my
presentation we are going to

10
00:00:53.520 --> 00:00:57.970 
introduce you to so called
a quantum safe algorithm.

11
00:00:58.560 --> 00:01:03.460 
and we are going to
make a deep dive.

12
00:01:04.160 --> 00:01:10.720 
bear with me you will still be understand
and follow me about the concept of

13
00:01:11.120 --> 00:01:12.830 
lattice based
cryptography.

14
00:01:14.520 --> 00:01:18.880 
so as we learned in
the first part,

15
00:01:20.030 --> 00:01:27.230 
the factorization currently
is a problem that classical

16
00:01:28.430 --> 00:01:36.390 
algorithms like our essay are currently
relying on and the problem is

17
00:01:36.640 --> 00:01:43.350 
that this factorization is
actually also within the space

18
00:01:43.350 --> 00:01:52.540 
where quantum computers significantly
can accelerator those computations.

19
00:01:52.780 --> 00:02:00.020 
so what we are seeking here for the
quantum safe algorithm are actually

20
00:02:00.580 --> 00:02:07.750 
hard problems that are hard not only
for classical computers, but also for

21
00:02:07.940 --> 00:02:09.470 
quantum computers.

22
00:02:11.570 --> 00:02:19.800 
so what are these type of hard
mathematical problems that we

23
00:02:19.800 --> 00:02:26.240 
are considering currently as a
quantum-resistant or quantum-safe.

24
00:02:26.750 --> 00:02:33.970 
so one of these types is the so
called code based on cryptography.

25
00:02:34.270 --> 00:02:41.070 
so they rely on the problem of so
called bounded distance decoding.

26
00:02:41.730 --> 00:02:46.160 
so it is comparable
like any

27
00:02:46.840 --> 00:02:54.950 
parity computation. if you
know the parity, it's hard

28
00:02:54.950 --> 00:03:01.420 
to find a kind of the original source
where you party you have computed out.

29
00:03:02.270 --> 00:03:08.140 
there is the multivariate
a cryptography,

30
00:03:08.600 --> 00:03:12.990 
their problem is relying
on solving multivariate

31
00:03:12.990 --> 00:03:14.340 
quadratic equations.

32
00:03:16.410 --> 00:03:22.240 
we have the type of so called
isogeny- based cryptography.

33
00:03:22.660 --> 00:03:26.360 
the basic problem that
you have to solve there

34
00:03:26.580 --> 00:03:33.510 
is to find a cyclic path within
so called supersingular

35
00:03:33.510 --> 00:03:35.670 
isogeny graphs.

36
00:03:37.860 --> 00:03:43.420 
and there is also the
lattice-based cryptography.

37
00:03:44.630 --> 00:03:52.270 
its problem relies on the shortest
or closest vector problem.

38
00:03:54.320 --> 00:04:02.120 
and last that I'm going to list here is
the so-called hash-based algorithm.

39
00:04:02.860 --> 00:04:10.680 
this cracking the house based
algorithm on quantum computers

40
00:04:10.830 --> 00:04:17.110 
is no different than to any
symmetric algorithm that you

41
00:04:17.110 --> 00:04:22.120 
have to crack on a quantum computer.
so therefore they shared

42
00:04:22.120 --> 00:04:23.280 
the same strength.

43
00:04:25.480 --> 00:04:30.830 
so the american national institute
of standards and technology

44
00:04:31.050 --> 00:04:38.560 
has actually initiated the standardization process
for so-called post-quantum cryptography.

45
00:04:39.280 --> 00:04:46.290 
this is the same work as we use for
quantum-safe cryptography. so

46
00:04:46.620 --> 00:04:49.700 
both are meaning the
same. it's just

47
00:04:50.750 --> 00:04:55.750 
mathematical problems being used
for cryptography that are

48
00:04:55.750 --> 00:04:59.660 
going to be hard for quantum
computers to crack.

49
00:05:01.130 --> 00:05:09.670 
this standardization has been initiated
back in two thousand and sixteen.

50
00:05:10.290 --> 00:05:17.560 
and all candidates had was
due to submit by the end of

51
00:05:17.590 --> 00:05:23.660 
two thousand and seventeen and
next was asking for two schemes.

52
00:05:24.360 --> 00:05:31.360 
to replace signatures and the other
one is to replace key exchange

53
00:05:31.510 --> 00:05:40.640 
algorithm. we are currently in the analysis
phase of this standardization process

54
00:05:40.960 --> 00:05:45.320 
and maybe two words the
end of two thousand

55
00:05:45.720 --> 00:05:51.980 
twenty three, maybe two thousand twenty
four we might have a standard.

56
00:05:53.840 --> 00:05:59.020 
so let's have a look at the
candidates' that have

57
00:05:59.020 --> 00:06:03.630 
been submitted there at the end of
two thousand twenty seventeen

58
00:06:04.430 --> 00:06:10.830 
by the worldwide community on
cryptography on the signature schemes.

59
00:06:12.050 --> 00:06:19.980 
you see quite a number of code
names for schemes, but always

60
00:06:19.980 --> 00:06:24.930 
on the second column you find
actually the type of mathematics

61
00:06:24.930 --> 00:06:30.000 
thoese schemes are based on we
will find types of code based,

62
00:06:30.230 --> 00:06:34.550 
hash based, lattice based,
multivariate once.

63
00:06:35.240 --> 00:06:40.840 
the red highlighted ones are
actually the schemes that IBM

64
00:06:41.020 --> 00:06:45.870 
has significantly
contributed today.

65
00:06:47.860 --> 00:06:54.400 
and now in the summer of this year
two thousand twenty, actually

66
00:06:54.410 --> 00:06:59.990 
missed has reduced the field of
candidates to three finalists.

67
00:07:00.800 --> 00:07:06.340 
those finalists are going to
into the process of being

68
00:07:06.340 --> 00:07:09.490 
drafted and hopefully
also standardized.

69
00:07:10.100 --> 00:07:17.800 
they're based on lattice mathematics
and multivariate quadratic.

70
00:07:18.380 --> 00:07:24.710 
and they have also chosen three of
alternate candidates. they might be

71
00:07:25.010 --> 00:07:28.320 
in later process
standardized as well.

72
00:07:29.710 --> 00:07:35.370 
there we find the types at
the hash based types and

73
00:07:35.370 --> 00:07:38.140 
as well as multivariate
quadratic.

74
00:07:39.780 --> 00:07:43.710 
so for the key
exchanged the list of

75
00:07:44.630 --> 00:07:50.840 
proposal is much larger, but
again here as well the kind of

76
00:07:51.020 --> 00:07:56.060 
dramatical base is still the
same. we find code based on

77
00:07:56.500 --> 00:08:01.870 
algorithm, we find lattice
based algorithm, multivariate

78
00:08:01.870 --> 00:08:08.030 
ones and the isogeny once. the
red highlighted ones are again

79
00:08:08.540 --> 00:08:11.820 
contributioned by IBM.

80
00:08:12.540 --> 00:08:20.080 
to those schemes and like before
on the signature schemes

81
00:08:20.280 --> 00:08:25.230 
in july two thousand and
twenty is actually

82
00:08:25.230 --> 00:08:34.170 
reduced these to four finalists
and for alternate candidates.

83
00:08:34.640 --> 00:08:39.520 
in the finalist we find code and
lattice based task schemes,

84
00:08:40.070 --> 00:08:47.450 
whereas in the alternate a list here
we find as well the isogeny ones.

85
00:08:52.450 --> 00:08:57.960 
so coming from these algorithms
and from the first part of

86
00:08:57.970 --> 00:09:04.320 
my presentation, what are the recommendations
that we can give already today.

87
00:09:05.110 --> 00:09:12.580 
it is a list that I
actually have also

88
00:09:13.410 --> 00:09:18.320 
part of it copied out of the
recommendation from the bsi site.

89
00:09:18.850 --> 00:09:24.460 
I have put the link to this
document in this presentation

90
00:09:24.460 --> 00:09:28.870 
case you want to look up. but
certain recommendation I'd like

91
00:09:28.880 --> 00:09:33.320 
definitely to share with you.
so the first thing that

92
00:09:33.330 --> 00:09:38.830 
we have to know into the future
is that we have to apply much

93
00:09:38.830 --> 00:09:43.100 
more agility into our cryptographic
scheme. so that means we

94
00:09:43.100 --> 00:09:48.910 
have to be prepared into the
future to replace schemes much

95
00:09:48.910 --> 00:09:53.390 
faster than we are
able maybe today.

96
00:09:54.960 --> 00:09:59.470 
definitely are on the symmetric
key part, we can recommend

97
00:10:00.130 --> 00:10:06.920 
just go through bigger key length,
definitely rare think of her

98
00:10:07.020 --> 00:10:11.350 
applying two hundred and
fifty six bit key lengths

99
00:10:11.640 --> 00:10:18.340 
to our symmetric key algorithm,
simply because if quantum

100
00:10:18.340 --> 00:10:22.870 
computers are going to in
place. the forecast says that

101
00:10:22.880 --> 00:10:27.150 
the security of these schemes are
going to be half and we just

102
00:10:27.150 --> 00:10:28.530 
want to have
this buffer

103
00:10:29.320 --> 00:10:30.440 
for the future.

104
00:10:31.680 --> 00:10:39.460 
and if you really have already
today, data that you're going

105
00:10:39.460 --> 00:10:47.330 
to encrypt that have a long lifetime.
that is going to maybe last

106
00:10:48.300 --> 00:10:54.560 
several decades, even you might
consider today to put solutions

107
00:10:54.560 --> 00:11:00.320 
into place that are hybrid. so
combining classical algorithms

108
00:11:00.580 --> 00:11:06.530 
together with candidates coming
from this quantum safe

109
00:11:06.540 --> 00:11:10.340 
an initiative
by a nest.

110
00:11:11.450 --> 00:11:19.040 
so with this combination, you're making
sure that you're coming overcoming

111
00:11:19.380 --> 00:11:25.250 
some implementation issues that
you might find yourself and

112
00:11:25.250 --> 00:11:32.380 
also side-channel issues with those hybrid
schemes. that's what we can already

113
00:11:32.550 --> 00:11:36.440 
recommend today. so

114
00:11:37.380 --> 00:11:42.240 
now that we have talk about
the quantum-safe algorithm

115
00:11:42.240 --> 00:11:48.070 
and about all types of demo
are out there. we'd like

116
00:11:48.070 --> 00:11:53.400 
to have like we did in the rsc
case, a little bit deeper dive

117
00:11:53.400 --> 00:11:57.990 
in the so called lattice
based cryptography.

118
00:11:59.910 --> 00:12:08.530 
first, we have to make a fundamental
understanding was polynomial

119
00:12:09.170 --> 00:12:16.480 
rings. so yeah it's not really
complicated, a polynomial

120
00:12:16.670 --> 00:12:22.890 
you use highlighted here in the
example which is here the blue part

121
00:12:23.060 --> 00:12:25.650 
is just

122
00:12:28.210 --> 00:12:35.930 
a polynomial based on coefficients
that are last to the

123
00:12:35.930 --> 00:12:42.190 
modulus and here in this
representation that I wrote in the

124
00:12:43.080 --> 00:12:49.970 
in the equation. the modulus is
p, in the example that would

125
00:12:49.970 --> 00:12:54.250 
be than twelve thousand two
hundred and eighty nine. so all

126
00:12:54.250 --> 00:12:59.630 
the coefficients of your polynomial
are smaller than this prime.

127
00:13:00.090 --> 00:13:05.530 
and since i have here listed
a cyclic polynomial.

128
00:13:06.060 --> 00:13:14.900 
all the polynomes are
only last up too

129
00:13:15.760 --> 00:13:21.260 
x to the power of in this case
a thousand and twenty three.

130
00:13:21.820 --> 00:13:27.060 
because we are going to divide
by the function x to the power

131
00:13:27.060 --> 00:13:31.350 
of a thousand twenty four
plus one in this example.

132
00:13:31.920 --> 00:13:38.450 
so but what it is good for? what can
we do with it? the good thing is

133
00:13:38.550 --> 00:13:45.780 
we can actually define a ring. a
ring means that we can define

134
00:13:45.830 --> 00:13:49.180 
addition and
multiplication operation

135
00:13:50.270 --> 00:13:55.500 
which will have the
property that if we add

136
00:13:56.120 --> 00:14:01.490 
true values coming out of being
defined are on the same polynomial.

137
00:14:01.900 --> 00:14:09.840 
the result z will be as well
based on the same polynomial.

138
00:14:10.680 --> 00:14:13.410 
and the same is true for
the multiplication.

139
00:14:13.840 --> 00:14:21.550 
so we can define a multiplication
of a time b or both

140
00:14:21.550 --> 00:14:27.960 
based on those polynomials that
result z will be as well are

141
00:14:27.970 --> 00:14:30.580 
on based on the
same polynomial.

142
00:14:31.250 --> 00:14:36.540 
and that's the kind of mathematics
or what is founded on.

143
00:14:37.680 --> 00:14:43.990 
with that we can define a hard
problem, hard mathematical problem.

144
00:14:44.550 --> 00:14:50.030 
let's here look at the matrix
multiplication. so let's

145
00:14:50.030 --> 00:14:56.330 
say we have our matrix a we
multiplied by the vector s

146
00:14:56.440 --> 00:15:01.670 
which actually the real
result into the vector t.

147
00:15:02.800 --> 00:15:08.620 
this only difference to kind of
our classical scheme. this

148
00:15:08.790 --> 00:15:13.090 
matrix multiplication
is all modulus to p.

149
00:15:14.500 --> 00:15:21.360 
but it is now hard problem. let's
say if we have a and t given,

150
00:15:21.540 --> 00:15:27.040 
is it hard to find the s? actually
not in this case, in this case

151
00:15:27.040 --> 00:15:32.530 
with which is to invert our
matrix a multiplied by t

152
00:15:32.560 --> 00:15:36.960 
and then we will find the s. so that's
currently not a hard problem.

153
00:15:37.540 --> 00:15:42.400 
so the hard problem
can might be a being

154
00:15:42.810 --> 00:15:48.230 
described this way. so this time
we do not only multiply as

155
00:15:48.230 --> 00:15:54.340 
to the matrix a, but we also
add a certain error vector e

156
00:15:54.510 --> 00:16:00.170 
to the whole thing. and the outcome
will be t. so now let's say we still

157
00:16:00.290 --> 00:16:04.460 
say ok only a and
t are given,

158
00:16:05.160 --> 00:16:11.150 
so is it possible to
find vectors s and e?

159
00:16:12.090 --> 00:16:14.200 
and the answer
is actually

160
00:16:15.160 --> 00:16:16.450 
that's a hard problem.

161
00:16:17.790 --> 00:16:22.980 
so that means we have
now our hard problem.

162
00:16:23.550 --> 00:16:29.930 
so can we do also cryptography
based on a disheartening problem?

163
00:16:31.040 --> 00:16:36.360 
yes, we can do and you will see
actually it's not going to

164
00:16:36.360 --> 00:16:41.870 
be different from the outside are
from the usage than before.

165
00:16:42.300 --> 00:16:49.370 
let's have a deeper look at these public
key encryption mechanism called kyber,

166
00:16:50.220 --> 00:16:52.260 
crystals Kyber.

167
00:16:53.640 --> 00:16:57.590 
first you always have to
generate the key pairs.

168
00:16:58.500 --> 00:17:04.950 
what you are going to do is that you
are going to generate the matrix a

169
00:17:05.120 --> 00:17:11.880 
out of randomly selected
are polynomials that

170
00:17:11.880 --> 00:17:14.500 
are that you're going
to choose randomly.

171
00:17:15.500 --> 00:17:21.480 
you're going to generate a two
vectors s and d are the offer

172
00:17:21.490 --> 00:17:26.840 
randomly chosen are polynomials. and
what you're going to compute then

173
00:17:27.030 --> 00:17:31.550 
is now exactly your matrix
multiplication here on the last

174
00:17:31.550 --> 00:17:37.890 
line. so that means t is
equal a times as plus e.

175
00:17:38.790 --> 00:17:43.230 
and yes here a detail that i'm going
to ignore for the time being.

176
00:17:43.540 --> 00:17:47.520 
there is also a rounding
factor in place.

177
00:17:48.230 --> 00:17:55.150 
so now we have a public key
which are defined by a and t.

178
00:17:55.580 --> 00:18:00.470 
and we have the secret s. now
somebody is most probably going

179
00:18:00.470 --> 00:18:02.450 
to flock here,
but still

180
00:18:03.360 --> 00:18:09.110 
you missed e and that's the nice part
of it. we don't need e anymore.

181
00:18:09.390 --> 00:18:13.760 
we can actually decrypt it without
e. so we don't even have

182
00:18:13.760 --> 00:18:16.850 
to store e and
remember it anymore.

183
00:18:18.700 --> 00:18:25.710 
so now how do we proceed? so let's
say i'd like to encrypt my secret u

184
00:18:26.270 --> 00:18:33.230 
with a kyber scheme. so what i'm
going to select on my side

185
00:18:33.560 --> 00:18:38.460 
is two random vectors are
r prime and e prime

186
00:18:39.690 --> 00:18:43.880 
based on the same polynomial
defined by kyber.

187
00:18:45.770 --> 00:18:52.250 
and i'm going also to select
a random polynomial and

188
00:18:52.250 --> 00:18:54.040 
there is only a
polynomial f.

189
00:18:54.980 --> 00:18:59.230 
and with that i'm going
to compute first

190
00:18:59.820 --> 00:19:08.000 
u prime which is actually r prime
times A plus e prime. so it's

191
00:19:08.350 --> 00:19:13.860 
fairly similar to actually r prime
times t from keeper generation. but

192
00:19:13.860 --> 00:19:20.660 
I'm also computing v which is a
kind of the vector multiplication

193
00:19:20.930 --> 00:19:22.930 
displayed on the button

194
00:19:24.340 --> 00:19:28.950 
with d scalar edition
of our secret mu.

195
00:19:29.560 --> 00:19:35.030 
so our ciphertext actually
combines two values

196
00:19:35.450 --> 00:19:39.150 
which is to u
prime and v.

197
00:19:40.830 --> 00:19:47.290 
so now the last step that we
have to do is actually do

198
00:19:47.700 --> 00:19:55.990 
decrypt it. so we take these
vectors u prime and v

199
00:19:57.150 --> 00:20:06.030 
and tried to decipher it from our
secret s. what we do is resubtract

200
00:20:06.620 --> 00:20:14.060 
v to or actually u prime times
s from v subtract that

201
00:20:14.110 --> 00:20:22.230 
gives us some value of v, w and
then we do have to just a

202
00:20:22.240 --> 00:20:31.250 
compute our last division by
q half and that will here

203
00:20:31.250 --> 00:20:35.230 
we will end up with our
kind after encrypted mu.

204
00:20:36.280 --> 00:20:41.400 
and that's it. so from
the outside, it's

205
00:20:41.860 --> 00:20:46.620 
completely, it's no different
our of usage than before.

206
00:20:47.210 --> 00:20:52.200 
so now we have been talking a lot
about quantum safe algorithm

207
00:20:52.200 --> 00:20:57.100 
and and how they're being done and
that the industry should actually

208
00:20:57.380 --> 00:21:03.050 
already take action rather today
than tomorrow. let's have a

209
00:21:03.240 --> 00:21:11.290 
quick look into what ibm does already in
this field on the quantum safe algorithm.

210
00:21:11.900 --> 00:21:16.600 
we already have learned that our
ibm did our already contribute

211
00:21:16.600 --> 00:21:21.150 
actually to the actual algorithms
such as a crystals kyber

212
00:21:21.150 --> 00:21:28.280 
and crystals-dilithium, as well to
FALCON and a classical McEliece.

213
00:21:29.200 --> 00:21:38.110 
but IBM also started to introduce
these on the latest platform

214
00:21:38.340 --> 00:21:47.580 
of z machine. so ibm has announced
into in september 2019.

215
00:21:47.950 --> 00:21:52.780 
then you IBM z15
and LinuxONE III

216
00:21:53.700 --> 00:22:01.600 
systems and if we are actually
looking at an advertisement by ibm.

217
00:22:01.700 --> 00:22:09.190 
we find actually that in song
very critical places such as

218
00:22:09.190 --> 00:22:14.870 
the hardware secure module.
that's the place where

219
00:22:15.020 --> 00:22:18.120 
all the keys are stored

220
00:22:19.890 --> 00:22:26.690 
from the client computing things
on z. there are already

221
00:22:26.690 --> 00:22:33.600 
offering to use quantum safer
cryptography. because again

222
00:22:33.600 --> 00:22:37.470 
like being displayed here
on the lower part of

223
00:22:39.700 --> 00:22:43.340 
these giant is actually

224
00:22:43.980 --> 00:22:49.770 
we believe that actually already
today with this system

225
00:22:50.210 --> 00:22:57.630 
you we must enable the clients to start
development are based on the latest

226
00:22:58.210 --> 00:23:02.120 
cryptographically means like
the quantum safe algorithm in

227
00:23:02.120 --> 00:23:09.460 
order for their lifetime of data
to be secure. even if some

228
00:23:09.460 --> 00:23:13.880 
day in the future, a quantum
computer might be large enough

229
00:23:14.490 --> 00:23:22.680 
two crack our classical
cryptographic schemes.

230
00:23:24.250 --> 00:23:30.710 
so with that i'm going to
conclude my second part

231
00:23:31.650 --> 00:23:38.000 
presentation. I like to thank you
very much for your intention

232
00:23:38.810 --> 00:23:42.960 
and just i'd like to
remind you that

233
00:23:43.590 --> 00:23:47.940 
yeah it might be not
too important when

234
00:23:48.780 --> 00:23:54.990 
the quantum computers are big enough
to crack our classical schemes.

235
00:23:55.490 --> 00:24:02.190 
it is already important to act
today and because whatever

236
00:24:02.190 --> 00:24:06.700 
you stored away today might be
valid also in the future and

237
00:24:06.700 --> 00:24:09.530 
you want to have them secured
also in the future.

238
00:24:10.560 --> 00:24:13.930 
thank you very much
and have a nice day!
