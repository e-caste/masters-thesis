WEBVTT

1
00:00:00.450 --> 00:00:05.330 
In our OpenHPI course, a half century
of internet, we now consider

2
00:00:05.330 --> 00:00:10.340 
how TCP is organizing the
flow and overload control.

3
00:00:13.710 --> 00:00:19.960 
The sliding window protocol is a tool
TCP is using for the flow control.

4
00:00:20.460 --> 00:00:27.250 
TCP regulates the data flow by
adopting a Sliding Window Protocol,

5
00:00:29.060 --> 00:00:34.260 
it uses adaptive, load dependent
windows for the transmission,

6
00:00:34.620 --> 00:00:39.720 
and acknowledgement assignment of
windows are a separate process.

7
00:00:41.260 --> 00:00:46.090 
This is a little bit difficult, so
it's most easy way to understand

8
00:00:46.090 --> 00:00:47.620 
is to look to
an example.

9
00:00:48.890 --> 00:00:53.520 
Let's take this a 2500 byte message,

10
00:00:54.210 --> 00:00:57.250 
it is to be sent from A to B
via TCP.

11
00:00:58.870 --> 00:01:05.740 
B has an input buffer or window size
of a 1500 bytes.

12
00:01:06.430 --> 00:01:14.260 
So the complete message does not fit into
that buffer because it's longer

13
00:01:14.450 --> 00:01:18.100 
than the windows size
of the input buffer.

14
00:01:18.910 --> 00:01:25.860 
So the window here F, it is exactly
1500 bytes.

15
00:01:26.000 --> 00:01:31.810 
that are available on side of
the receiver B to receive

16
00:01:31.810 --> 00:01:37.550 
a message. So what A is doing is,
A gets informed informed about

17
00:01:37.560 --> 00:01:41.750 
this 1500 window size

18
00:01:41.860 --> 00:01:45.860 
and sends the first
1000 bytes to B,

19
00:01:47.590 --> 00:01:53.300 
B accepts it, writes said 1000
bytes into the input buffer,

20
00:01:53.580 --> 00:01:55.990 
and that's the
windows sends to

21
00:01:56.690 --> 00:02:02.220 
windows size 1500,
this was original window size, minus 1000

22
00:02:02.610 --> 00:02:07.840 
equals 500 and then
sending the acknowledgment

23
00:02:08.360 --> 00:02:12.290 
it acknowledged that it received
the first 1000 bytes

24
00:02:13.080 --> 00:02:18.810 
and it's at the current the new
windows size so it's 500.

25
00:02:21.290 --> 00:02:25.840 
Now A transfers the
next five hundred bytes

26
00:02:26.250 --> 00:02:28.110 
according to the
windows size,

27
00:02:28.850 --> 00:02:32.030 
so original message was 1500

28
00:02:32.030 --> 00:02:36.320 
already we sent now
the next five hundred bytes

29
00:02:37.380 --> 00:02:43.140 
be accepted set the windows size
to 0 because 1500

30
00:02:43.140 --> 00:02:47.540 
bytes received in
the last cycle are not yet a

31
00:02:47.550 --> 00:02:53.750 
out of the buffer for computation

32
00:02:54.100 --> 00:02:59.130 
and it acknowledged the message
received so far, so it acknowledged

33
00:02:59.130 --> 00:03:03.550 
and received 500
bytes and the new window

34
00:03:03.550 --> 00:03:04.880 
size is 500.

35
00:03:05.840 --> 00:03:11.500 
Now A has a signal not to
send more data to B,

36
00:03:11.950 --> 00:03:15.160 
all the data A would
send in this situation

37
00:03:15.650 --> 00:03:19.490 
there is no space in
the input buffer inside B,

38
00:03:19.670 --> 00:03:27.270 
so it will go lost and is a
useless transport

39
00:03:27.430 --> 00:03:31.700 
through the internet and such
useless transports where

40
00:03:31.700 --> 00:03:36.070 
it's clear that the data which was sent
cannot be processed on the receiver side

41
00:03:36.320 --> 00:03:42.940 
should be avoided because this a
increases in the number of traffic

42
00:03:43.320 --> 00:03:50.080 
in the network. So A has to
wait until B informs a it

43
00:03:50.530 --> 00:03:54.470 
that now it reads something
out of the buffer,

44
00:03:55.230 --> 00:03:58.270 
in our example
that is 1000 bytes,

45
00:03:59.010 --> 00:04:02.480 
and then the window
size can be reset.

46
00:04:03.000 --> 00:04:07.790 
The original window size was
1500,

47
00:04:08.670 --> 00:04:14.740 
from which thousand bytes were taken out,

48
00:04:15.030 --> 00:04:18.040 
so the new free space
is 1000,

49
00:04:18.730 --> 00:04:23.050 
and now this is enough that A can
send the rest of its message

50
00:04:23.350 --> 00:04:31.470 
the last 1000 bytes. So you see
window size of the the space

51
00:04:31.470 --> 00:04:33.860 
inside the input
buffer it's,

52
00:04:34.770 --> 00:04:39.740 
as a sender gets informed by
the receiver about the actual

53
00:04:39.740 --> 00:04:46.270 
size of the input buffer so that
the sender can a can modify

54
00:04:46.830 --> 00:04:51.970 
the speed of sending packages
and have set packages

55
00:04:52.110 --> 00:04:54.690 
according to that
window size.

56
00:04:55.550 --> 00:05:02.760 
Here we can have a look to the same
example on this illustration,

57
00:05:03.260 --> 00:05:07.740 
A sends the first 1000
bytes and the next 500

58
00:05:07.940 --> 00:05:14.990 
it gets acknowledged that a window
size is now zero, so it is

59
00:05:14.990 --> 00:05:20.690 
not allowed to continue to send, B
is waiting up to the moment

60
00:05:20.770 --> 00:05:27.430 
something is
a taken a out of the input buffer.

61
00:05:27.660 --> 00:05:32.750 
If these are 1000 bytes then
the new window size 1000 bytes,

62
00:05:33.510 --> 00:05:40.880 
it can inform A about it and then A can
send the remaining 1000 bytes and

63
00:05:41.100 --> 00:05:49.150 
this is done in this way there is a
control by means of a sliding window.

64
00:05:49.640 --> 00:05:56.340 
A which helps to control the flow
of data from sender to receiver

65
00:05:58.950 --> 00:06:02.850 
so now is the information
is done about it.

66
00:06:03.310 --> 00:06:05.820 
Speaking about TCP
flow control,

67
00:06:06.920 --> 00:06:10.640 
there is a phenomena
Silly Window Syndrome

68
00:06:11.730 --> 00:06:18.870 
it describes a
situation that without additional precautions

69
00:06:19.420 --> 00:06:22.140 
the window size would
be close to zero

70
00:06:22.740 --> 00:06:26.550 
and this would make the
communication inefficient.

71
00:06:28.480 --> 00:06:31.120 
To fix this the receiver may

72
00:06:31.980 --> 00:06:35.110 
only communicate an
updated window size,

73
00:06:35.740 --> 00:06:40.320 
when at least 50 percent of the
maximum window size is available.

74
00:06:41.330 --> 00:06:45.490 
If the receiver would immediately
after some data taken

75
00:06:45.490 --> 00:06:48.690 
out of the input
buffer, say there is

76
00:06:49.550 --> 00:06:55.850 
10 percent or 5 percent available
now in the input buffer,

77
00:06:56.430 --> 00:06:59.440 
then there would be
a lot of messages

78
00:07:00.070 --> 00:07:03.990 
with only a few data that needs
to be transported through the

79
00:07:03.990 --> 00:07:08.350 
internet from sender to the
receiver. So the idea is to prevent

80
00:07:08.350 --> 00:07:11.610 
it to make the communication
as efficient as possible,

81
00:07:12.020 --> 00:07:17.550 
that they receiver only reports
a window size update when

82
00:07:17.550 --> 00:07:21.630 
at least 50 percent of the maximum
window size is available, again

83
00:07:22.950 --> 00:07:29.420 
on the side of sender, there are
also some precautions organized,

84
00:07:30.010 --> 00:07:36.490 
the sender may ensure that the
windows size is not fully used,

85
00:07:36.940 --> 00:07:41.280 
so the sender only sends
a part of the information,

86
00:07:41.820 --> 00:07:48.260 
not completely using the buffer
size, to a cause a situation

87
00:07:48.380 --> 00:07:50.230 
that the window
is zero.

88
00:07:52.540 --> 00:08:01.000 
And also task of TCP is the
overload control, the congestion control

89
00:08:03.290 --> 00:08:07.150 
but it is even more challenging
for TCP connections,

90
00:08:07.620 --> 00:08:15.320 
because there is no means to measure overload
situations. TCP has no instruments

91
00:08:15.610 --> 00:08:22.020 
to measure overload situation and TCP
is only active in the end systems,

92
00:08:22.380 --> 00:08:24.290 
not in the
intermediate systems.

93
00:08:25.320 --> 00:08:30.140 
Though no overload analysis can be made
from intermediate internet systems,

94
00:08:30.640 --> 00:08:35.360 
since data may be transported
in different ways,

95
00:08:36.840 --> 00:08:40.130 
also different
TCP instances

96
00:08:40.920 --> 00:08:42.950 
cannot cooperate
with each other.

97
00:08:44.210 --> 00:08:52.140 
So an idea is needed and that idea consists
in the way that overload

98
00:08:52.720 --> 00:08:57.910 
is measured by analyzing the
number of lost packages,

99
00:08:58.400 --> 00:09:02.040 
The number of unconfirmed packages

100
00:09:03.310 --> 00:09:06.830 
and a then that updates
the windows size

101
00:09:07.240 --> 00:09:12.250 
accordingly. Why is this number
of lost pay packages or the

102
00:09:12.250 --> 00:09:16.690 
number of unconfirmed packages
measures the overload situation?

103
00:09:18.070 --> 00:09:25.390 
If a package is in the time interval time
interval no acknowledgment is received,

104
00:09:25.920 --> 00:09:28.890 
sender re-transmits the package.

105
00:09:30.530 --> 00:09:37.500 
If it happens often, then it's unlikely
as the packages are really lost,

106
00:09:37.630 --> 00:09:41.650 
it's more likely that the
timer is set

107
00:09:42.080 --> 00:09:47.860 
to an interval that is
too short for the current situation

108
00:09:47.960 --> 00:09:55.820 
in the network. And so here on
the basis of this idea which reflects

109
00:09:56.380 --> 00:10:03.250 
the congestion situation in a network,
as there are different algorithms

110
00:10:03.670 --> 00:10:12.170 
implemented in the TCP protocol
to deal with that situation.

111
00:10:12.970 --> 00:10:16.520 
The first is so-called Slow
start algorithms.

112
00:10:17.390 --> 00:10:24.480 
And the idea here is of this algorithm
to fast adapt the windows size

113
00:10:24.780 --> 00:10:26.800 
to the right
a situation.

114
00:10:27.770 --> 00:10:32.170 
So tcp connections are started
with a small window side,

115
00:10:32.640 --> 00:10:38.650 
and then they doubles the size
for each of the next package,

116
00:10:39.120 --> 00:10:43.810 
until packets are lost. In the
case packets are lost, then

117
00:10:43.810 --> 00:10:50.680 
the capacity of the input buffer is
reached and this is a sign to slowdown

118
00:10:51.000 --> 00:10:56.090 
the size of the messages
and the number of messages.

119
00:10:56.900 --> 00:11:01.960 
Another mechanism is a congestion
avoidance algorithm and the

120
00:11:01.970 --> 00:11:06.060 
idea of this congestion avoidance
algorithm is to reduce

121
00:11:06.480 --> 00:11:09.090 
the re-sending a packet.

122
00:11:09.830 --> 00:11:12.040 
So if packet
loss is high,

123
00:11:13.520 --> 00:11:18.910 
so a sender can
realize this if it had

124
00:11:18.910 --> 00:11:24.770 
not received an
acknowledgement of the packets,

125
00:11:25.420 --> 00:11:33.650 
then a lower data rate is sent
to reduce the overload situation.

126
00:11:36.470 --> 00:11:41.450 
Nagle's algorithm is
another algorithm to

127
00:11:41.870 --> 00:11:43.850 
deal with this
overload control,

128
00:11:44.520 --> 00:11:50.180 
it was published in
RFC 896,

129
00:11:50.520 --> 00:11:55.770 
later on it was replaced by RFC
7805 in 2016.

130
00:11:55.960 --> 00:11:58.880 
And Nagle was a
designed set of algorithm,

131
00:11:59.450 --> 00:12:04.540 
and the goal was to reduce
the sending overhead

132
00:12:05.160 --> 00:12:10.370 
because smaller the
a payload of a package,

133
00:12:11.370 --> 00:12:18.130 
so higher is
the overload, because the

134
00:12:18.690 --> 00:12:23.520 
packet has, it is almost the
same for a short package as

135
00:12:23.520 --> 00:12:24.730 
well as for long package.

136
00:12:25.590 --> 00:12:31.010 
And the difference is the number
of data that are transported, so

137
00:12:31.130 --> 00:12:34.830 
the idea is to avoid
to send short packages

138
00:12:35.850 --> 00:12:41.790 
and this is done by delaying sending
acknowledgements as long as it's possible.

139
00:12:42.950 --> 00:12:45.170 
That means the
receiver

140
00:12:46.440 --> 00:12:51.450 
who has to send an acknowledgment
back to the sender waits as long

141
00:12:51.610 --> 00:12:58.070 
as it gets other data, so that it
not only sends a short message

142
00:12:58.090 --> 00:13:04.500 
which tells the window size, but
also sends more data to the sender.

143
00:13:06.540 --> 00:13:12.530 
Similary, delay sending user data until
there are pending acknowledgements

144
00:13:13.200 --> 00:13:18.840 
of course it is a balance, because
if the receiver waits too long

145
00:13:19.230 --> 00:13:24.450 
for sending the data, then there is
a chance that the acknowledgment

146
00:13:24.460 --> 00:13:25.910 
does not receive
in time.

147
00:13:26.620 --> 00:13:30.440 
But if they immediately
send the acknowledgement,

148
00:13:30.970 --> 00:13:35.180 
there is only a lot of
short messages that has to be

149
00:13:35.180 --> 00:13:39.870 
sent through, and a lot of overhead is
transported through the internet

150
00:13:40.060 --> 00:13:42.550 
compared to
the real data.

151
00:13:43.430 --> 00:13:46.590 
So Nagle's algorithm
collects all user data

152
00:13:47.090 --> 00:13:53.730 
and only transmits when
the next due received.

153
00:13:55.520 --> 00:13:59.260 
When we spoke about the
retransmission mechanisms,

154
00:13:59.680 --> 00:14:06.360 
we saw that it is regulated by the
round trip time.

155
00:14:06.900 --> 00:14:10.180 
This time between the
transmission of a packet

156
00:14:10.690 --> 00:14:14.760 
between sending a package and
receiving the acknowledgement,

157
00:14:15.080 --> 00:14:19.530 
and this round trip time
determines the speed

158
00:14:19.940 --> 00:14:22.410 
of transmission
in the internet.

159
00:14:23.730 --> 00:14:29.030 
So the question is how this round
time is computed?

160
00:14:30.010 --> 00:14:36.190 
Originally it was computed in a way
that the rounded time is measured

161
00:14:36.450 --> 00:14:42.390 
for each sent packet and a
weighted average is calculated.

162
00:14:43.000 --> 00:14:48.820 
So the last package with
the last measured round-trip times

163
00:14:48.940 --> 00:14:50.930 
of the different
transmissions,

164
00:14:52.670 --> 00:14:57.400 
the average is computed and then
this gives a new round time,

165
00:14:57.570 --> 00:15:03.370 
that gives a new setting of the timer
for transmitting the new data.

166
00:15:05.220 --> 00:15:10.390 
This algorithm needs to be
improved which was done by Kahn

167
00:15:10.390 --> 00:15:12.790 
and Patridge,

168
00:15:13.450 --> 00:15:17.060 
and they calculated the
round-trip time only

169
00:15:17.520 --> 00:15:21.190 
based on acknowledge
packets by the receiver.

170
00:15:22.500 --> 00:15:25.770 
This increases the
time-out used,

171
00:15:26.380 --> 00:15:29.400 
to resend the packet after
each acknowledgement.

172
00:15:30.610 --> 00:15:37.210 
The idea and reason is that this
algorithms avoid an under-estimation

173
00:15:37.660 --> 00:15:43.890 
of round trip time and this could
happen if one package is sent

174
00:15:45.130 --> 00:15:49.630 
and the acknowledgement
is sent back,

175
00:15:50.130 --> 00:15:55.730 
but the timer interval was too short,
though that the transmission

176
00:15:55.900 --> 00:15:58.210 
is considered as a
package is lost,

177
00:15:58.820 --> 00:16:02.720 
And then a new transmission is
started of the same package,

178
00:16:02.870 --> 00:16:07.720 
and in the new time interval,
the acknowledgment is received

179
00:16:07.890 --> 00:16:12.310 
which are sent by the receiver. So the
situation is that a round-trip

180
00:16:12.310 --> 00:16:15.420 
time is measured the
small amount and not

181
00:16:16.450 --> 00:16:21.560 
this amount, so they avoid the
underestimation of rounded time

182
00:16:21.910 --> 00:16:25.800 
due to the re-sending of packets
that were assumed to be lost,

183
00:16:26.240 --> 00:16:30.050 
but with the late
arrivals acknowledgment.

184
00:16:31.380 --> 00:16:36.190 
Also this algorithm was improved by
the Karel and Jacobson,

185
00:16:36.740 --> 00:16:43.190 
and they refined the Kahn/Patridges's algorithm
by taking into account the fluctuations

186
00:16:43.640 --> 00:16:48.720 
in the communication time. So it's a
new measurement to compute mean

187
00:16:49.300 --> 00:16:56.560 
and the update of the time-out is also
adjusted corresponding to this.

188
00:16:57.140 --> 00:17:01.460 
It's not necessary to go into the
details of this, but to see

189
00:17:02.360 --> 00:17:07.670 
how sophisticated the design
of TCP IP protocol is,

190
00:17:08.090 --> 00:17:16.540 
so that its provides us reliable
communication, it guarantees error-free

191
00:17:16.830 --> 00:17:20.860 
transmission,and
also takes into account

192
00:17:20.870 --> 00:17:26.850 
that the network is efficiently
used by the mechanisms for

193
00:17:26.850 --> 00:17:32.760 
flow control and congestion control,
which are part of the design of TCP IP

194
00:17:32.930 --> 00:17:34.230 
protocol.
