WEBVTT

1
00:00:00.790 --> 00:00:05.730 
Welcome to knowledge graphs. This is
lecture number three querying rdfs

2
00:00:05.930 --> 00:00:12.480 
with SPARQL. So how can we
query rdf and rdfs, this is

3
00:00:12.480 --> 00:00:16.340 
the question we are dealing with here
in the first part of this lecture.

4
00:00:16.640 --> 00:00:20.760 
And we are now on the query level within
the semantic web technology stack

5
00:00:20.930 --> 00:00:23.920 
and we are talking about the
query language SPARQL.

6
00:00:24.440 --> 00:00:31.060 
So what is SPARQL? SPARQL, it's a query
language for rdfs and it's working

7
00:00:31.200 --> 00:00:36.530 
based on a client server paradigm which
means you have a SPARQL endpoint

8
00:00:36.710 --> 00:00:41.080 
that's a server it's like a database
for rdf data

9
00:00:41.610 --> 00:00:47.830 
and exactly this SPARQL endpoint
can be queried via the internet

10
00:00:48.530 --> 00:00:54.940 
by a client and this client accesses
the server via http and above http

11
00:00:55.110 --> 00:00:59.130 
there is the SPARQL protocol layer
which means a SPARQL query

12
00:00:59.130 --> 00:01:05.300 
is sent via http to the server, the
server processes the SPARQL query

13
00:01:05.540 --> 00:01:11.770 
delivers the answer then back to the client
where it is displayed then finally

14
00:01:12.010 --> 00:01:14.250 
within the user interface
of the client.

15
00:01:14.970 --> 00:01:18.850 
And how this works we will see that
in the course of these lectures.

16
00:01:19.870 --> 00:01:23.120 
SPARQL in general is much more
than a query language. So it

17
00:01:23.120 --> 00:01:27.510 
is constituted first of course
of the query language for

18
00:01:27.840 --> 00:01:32.690 
graph traversal within rdf, so it's
based on rdf graph traversal. This is

19
00:01:32.950 --> 00:01:37.140 
the basic principle how it works and
we will explain this later in detail.

20
00:01:37.860 --> 00:01:41.690 
Then SPARQL defines also the
protocol layer I was already

21
00:01:41.690 --> 00:01:47.050 
talking about and referring to.
So this is SPARQL via http.

22
00:01:47.430 --> 00:01:52.010 
And then there is of course a
specific SPARQL xml output format

23
00:01:52.010 --> 00:01:55.940 
specification. This is exactly the form
of the output that is delivered

24
00:01:56.230 --> 00:02:00.280 
back from the SPARQL endpoint,
from the server back to the

25
00:02:00.280 --> 00:02:05.190 
client and the client of course has
to parse this xml output form

26
00:02:05.380 --> 00:02:07.080 
and to do something
with it.

27
00:02:08.130 --> 00:02:12.020 
The standard of course for SPARQL
is from two thousand and

28
00:02:12.020 --> 00:02:14.800 
thirteen, this now is
SPARQL 1.1

29
00:02:15.230 --> 00:02:20.690 
and as many other query languages
for data, SPARQL is also based

30
00:02:20.690 --> 00:02:25.340 
and inspired on the sequel query
language for relational databases.

31
00:02:25.340 --> 00:02:30.200 
And some of you might already know
sequel or sql for relational

32
00:02:30.200 --> 00:02:34.990 
databases which is a rather simple
or easy to learn query language.

33
00:02:34.990 --> 00:02:40.370 
And this is the same with SPARQL.
So SPARQL and sequel are similar

34
00:02:40.710 --> 00:02:44.160 
but not identical. There are
significant differences and the most

35
00:02:44.320 --> 00:02:48.010 
important difference is is that
SPARQL is really a very language

36
00:02:48.010 --> 00:02:52.190 
for graph traversal and why
how this works you will see

37
00:02:52.620 --> 00:02:57.900 
now later on. This is for example
a SPARQL end point, a rather

38
00:02:57.900 --> 00:03:00.870 
prominent endpoint that you
might see more often also here

39
00:03:00.870 --> 00:03:05.390 
in the course of the lecture, this
is the end point of the dbpedia

40
00:03:05.790 --> 00:03:11.120 
database or dbpedia knowledge base
which has been derived from wikipedia.

41
00:03:11.980 --> 00:03:16.360 
In the very first or the second
excursion of this lecture you

42
00:03:16.360 --> 00:03:21.020 
will learn about dbpedia and
also about wikidata, the two

43
00:03:21.020 --> 00:03:24.670 
knowledge bases that we are
going to query with SPARQL.

44
00:03:26.110 --> 00:03:31.020 
So I told you that SPARQL is
a query language for rdf

45
00:03:31.070 --> 00:03:34.890 
graph traversal, so what we
need is now an rdf graph.

46
00:03:35.550 --> 00:03:39.910 
This is an example of an rdf graph
which comprises three different

47
00:03:39.910 --> 00:03:42.730 
books. On the first glance it
might look rather complicated,

48
00:03:42.730 --> 00:03:45.830 
but I walk you through it. So there
is one book Nineteen Eighty-

49
00:03:45.830 --> 00:03:48.930 
four that has been written by
George Orwell in nineteen forty

50
00:03:48.930 --> 00:03:52.860 
eight and this is kind of a dystopian
novel and of course it's a book.

51
00:03:54.260 --> 00:03:58.450 
And then we have An Inconvenient
Truth here written by Al Gore

52
00:03:58.450 --> 00:04:01.270 
and this is a book about global
warming, which of course is

53
00:04:01.270 --> 00:04:04.880 
related to climate change. And this has
been released in two thousand six.

54
00:04:05.090 --> 00:04:07.780 
And of course as we all
know Al Gore is a person.

55
00:04:09.990 --> 00:04:14.150 
And then we have a third book, this
also is an interesting novel called

56
00:04:14.290 --> 00:04:20.110 
Make Room! Make Room! from Harry Harrison.
It's dystopian and it's based on

57
00:04:20.210 --> 00:04:23.540 
or there is something there's
a film based on exactly that

58
00:04:23.550 --> 00:04:26.650 
novel which is quite interesting, you
should see it it's called Soylent Green

59
00:04:26.890 --> 00:04:31.510 
and this is a book about
environmental fiction and yeah

60
00:04:31.510 --> 00:04:36.050 
the author Harry Harrison is also
a person. So we will use this

61
00:04:36.050 --> 00:04:40.950 
graph later and for explaining
how SPARQL is going to work.

62
00:04:45.070 --> 00:04:49.910 
So let's see how SPARQL works. For queries,
first if we want to query rdf

63
00:04:50.240 --> 00:04:55.110 
we are in need of variables that
have to be filled with the

64
00:04:55.110 --> 00:05:00.460 
results that we access in the data. So we
have to define so called SPARQL variables

65
00:05:00.850 --> 00:05:05.890 
which then are later bound to rdf
terms while query processing

66
00:05:06.450 --> 00:05:10.370 
and to distinguish then our usual
vocabulary that we use in

67
00:05:10.370 --> 00:05:14.990 
SPARQL from the variables, all of
the variables that we define

68
00:05:15.330 --> 00:05:19.700 
they have a question mark in the
beginning. So for example

69
00:05:19.700 --> 00:05:24.210 
?title, ?author
and ?date they

70
00:05:24.210 --> 00:05:28.440 
are variables that can be used and then
later on be found which means filled

71
00:05:28.680 --> 00:05:29.800 
with rdf data.

72
00:05:31.420 --> 00:05:36.010 
The very itself is formulated in
exactly the same way like in sequel,

73
00:05:36.580 --> 00:05:41.670 
so you query for variables and
this is performed

74
00:05:41.670 --> 00:05:45.290 
in a so called select statement.
So this is exactly like sequel

75
00:05:45.690 --> 00:05:50.970 
and then you have the keyword select
and usually after select you

76
00:05:51.300 --> 00:05:55.730 
simply list all of the variables
that you want to have filled.

77
00:05:55.790 --> 00:05:59.140 
And for example we can see
select title, author and date

78
00:05:59.760 --> 00:06:02.850 
and so on and so on so we don't
specifically say how exactly

79
00:06:02.850 --> 00:06:04.090 
they should be
selected and

80
00:06:05.060 --> 00:06:09.920 
the result from that query then
will be something like a table.

81
00:06:10.900 --> 00:06:14.980 
So usually it's a table because all
of these variables are ordered

82
00:06:15.370 --> 00:06:19.270 
and also then you have rows of the
single results that are returned.

83
00:06:19.510 --> 00:06:23.880 
So it's a table, the heading again here
you see title author and date and

84
00:06:24.180 --> 00:06:29.340 
regarding to our graph this could be if
we formulate the rest of the query

85
00:06:29.500 --> 00:06:33.790 
accordingly then titles like nineteen
eighty four, an inconvenient

86
00:06:33.800 --> 00:06:35.350 
truth and make
room make room,

87
00:06:36.160 --> 00:06:39.450 
then the authors George Orwell, Al
Gore and Harry Harrison,

88
00:06:39.980 --> 00:06:44.320 
and the publication dates nineteen forty
eight two thousand six and nineteen

89
00:06:44.480 --> 00:06:48.220 
sixty six. This would
be the SPARQL result.

90
00:06:49.370 --> 00:06:51.320 
So far it seems rather
easy, doesn't it?

91
00:06:54.800 --> 00:06:56.500 
What does it mean?

92
00:06:57.370 --> 00:07:03.760 
In SPARQL to query an rdf graph what SPARQL does
is so called graph pattern matching.

93
00:07:05.220 --> 00:07:09.070 
First of all what you formulate
in SPARQL and also the patterns

94
00:07:09.070 --> 00:07:13.270 
that you formulate follow closely
the idea of turtle serialization.

95
00:07:14.270 --> 00:07:19.110 
So SPARQL is based on first rdf
turtle serialization and secondly

96
00:07:19.320 --> 00:07:23.840 
under on a process which is called
basic graph pattern matching.

97
00:07:24.000 --> 00:07:28.090 
What is the graph pattern? A graph
pattern is simply an rdf triple

98
00:07:28.360 --> 00:07:33.210 
where one or more of
the triple constituents

99
00:07:33.700 --> 00:07:38.420 
is a variable, so either subject,
property or object or several

100
00:07:38.420 --> 00:07:41.590 
of them. So a graphpattern or triple
pattern is nothing else but

101
00:07:41.800 --> 00:07:47.450 
turtle plus variables. A simple example
if we want to look for authors

102
00:07:47.830 --> 00:07:51.670 
and their books or the other way
around we want to look for

103
00:07:51.670 --> 00:07:54.870 
books and their corresponding
authors and for that we want

104
00:07:54.870 --> 00:07:59.460 
to use a specific property that
exists for example in the dbpedia

105
00:07:59.460 --> 00:08:04.460 
ontology you will find dbo:author
which is associated with a book

106
00:08:04.810 --> 00:08:08.970 
and then you can, for example, look for
the following graph triple pattern

107
00:08:09.100 --> 00:08:13.480 
and this would be book as a
variable leading question mark,

108
00:08:13.750 --> 00:08:16.670 
then you simply use the URI
of the property that should

109
00:08:16.680 --> 00:08:20.850 
be there. This is dbo:author and
then comes the next variable

110
00:08:21.100 --> 00:08:22.790 
this is then again
the author.

111
00:08:24.120 --> 00:08:27.260 
First letter there
also is then

112
00:08:27.890 --> 00:08:33.030 
a question mark. And since it follows turtle,
each of these graph patterns usually

113
00:08:33.470 --> 00:08:36.550 
is closed with a period
as you see here.

114
00:08:37.200 --> 00:08:38.360 
So this is rather easy,

115
00:08:39.050 --> 00:08:41.400 
these are the variables
as we already know

116
00:08:41.820 --> 00:08:46.440 
and what does it do? So the graph
then is filtered with exactly

117
00:08:46.440 --> 00:08:50.210 
that kind of pattern. So this
pattern goes through the entire

118
00:08:50.210 --> 00:08:54.690 
graph and you see here where it
matches, so where you find exactly

119
00:08:54.690 --> 00:08:58.350 
dbo:author and you have
there a head and a tail of

120
00:08:58.350 --> 00:09:02.610 
course associated exactly with that
property. This is returned then

121
00:09:02.900 --> 00:09:05.930 
in the resulting tables, so for
example Nineteen Eighty Four

122
00:09:05.930 --> 00:09:10.520 
has the author George Orwell, An Inconvenient
Truth has the author Al Gore

123
00:09:10.740 --> 00:09:13.810 
and Make Room! Make Room! has
the author Harry Harrison.

124
00:09:15.230 --> 00:09:19.240 
It's as easy as that. So this is a
simple graph pattern matching.

125
00:09:20.670 --> 00:09:24.920 
Of course then you can do complex
pattern matching and usually

126
00:09:24.920 --> 00:09:29.000 
then SPARQL graph button can be
combined to form complex, in

127
00:09:29.000 --> 00:09:32.660 
this case conjunctive, queries
for rdf traversal. So this is

128
00:09:32.660 --> 00:09:36.810 
the most easiest thing if you simply
combine two of these graph patterns,

129
00:09:36.970 --> 00:09:41.120 
they are always combined conjunctively,
so with a logical AND.

130
00:09:41.730 --> 00:09:45.590 
Later on you will learn that there
is also a logical OR but now

131
00:09:45.820 --> 00:09:51.280 
we focus first on the conjunctive
connection of these two patterns.

132
00:09:51.820 --> 00:09:56.980 
For example, find the books, their authors
and their according literary genres.

133
00:09:57.120 --> 00:10:02.640 
So what I do here, first pattern book dbo:
author and then author as a variable

134
00:10:03.230 --> 00:10:08.170 
like before. However we want to have
to connect exactly the same book

135
00:10:08.270 --> 00:10:11.740 
then with the property
literary genre

136
00:10:12.260 --> 00:10:15.010 
and fill then the
genre variable.

137
00:10:15.840 --> 00:10:19.420 
So you see here we are referring
to in that graph pattern to

138
00:10:19.420 --> 00:10:23.440 
the very same book. So the same
book should be then associated

139
00:10:23.440 --> 00:10:27.980 
with the second pattern. This means this
is a special way of connecting this

140
00:10:28.110 --> 00:10:33.090 
conjunctively. So we are referring to
the same subject here in the query.

141
00:10:33.560 --> 00:10:36.100 
So this it's already
quite interesting.

142
00:10:36.850 --> 00:10:42.150 
However you can go way more complex, so we
try now something more difficult. Given

143
00:10:42.380 --> 00:10:45.600 
a specific book URI, so
here we are talking about the

144
00:10:45.600 --> 00:10:48.150 
book Brave New World which is
not in our graph, but of course

145
00:10:48.150 --> 00:10:51.960 
we can imagine that. Find
its author or authors

146
00:10:52.540 --> 00:10:55.930 
and find then the birth places
of its authors including the

147
00:10:55.930 --> 00:10:59.820 
number of the population of the birthplace.
So this is already a complex query.

148
00:11:00.220 --> 00:11:03.570 
Let's have a look it doesn't
look so complicated at all. So

149
00:11:03.880 --> 00:11:07.550 
we have a URL. This
is first URI

150
00:11:08.220 --> 00:11:11.600 
of Brave New World, so the book
we are looking for. And we want

151
00:11:11.600 --> 00:11:14.160 
to have the authors of that which
means we connect this then

152
00:11:14.160 --> 00:11:18.160 
second place with the property
dbo:author and what we want

153
00:11:18.160 --> 00:11:21.280 
to have filled of course is the object
and there should be the author.

154
00:11:21.570 --> 00:11:24.490 
We make a period to simply
close the first graph pattern.

155
00:11:25.720 --> 00:11:29.640 
Secondly we want to know from
this author the birthplace. So,

156
00:11:30.120 --> 00:11:34.470 
next graph pattern we start with author and
say, okay, author should then be connected

157
00:11:34.820 --> 00:11:38.370 
with the birth place to the
variable birthplace which should

158
00:11:38.370 --> 00:11:42.620 
be filled after that period to
close the second graph pattern.

159
00:11:43.350 --> 00:11:46.010 
And then comes the last one, the
birthplace. Of course we want

160
00:11:46.010 --> 00:11:49.630 
to know its population. So
we have birthplace here.

161
00:11:50.240 --> 00:11:55.350 
We ask for the property population
total and then ask or fill

162
00:11:55.590 --> 00:11:57.600 
the variable
population.

163
00:11:58.210 --> 00:12:03.140 
You see here, author here refers
also to the same author here

164
00:12:03.140 --> 00:12:07.480 
in two places. So this means this
object author should be the same as

165
00:12:07.590 --> 00:12:10.540 
the other in the second
line as the subject.

166
00:12:11.890 --> 00:12:14.850 
And also then the birth place
that we have in the object of

167
00:12:14.860 --> 00:12:19.070 
the second line should be the same
as the subject in the first line.

168
00:12:19.210 --> 00:12:23.290 
So this is already a more complex
graph pattern. You will get easily

169
00:12:23.640 --> 00:12:28.430 
used by that over time so this is
really a nice and easy way to

170
00:12:28.920 --> 00:12:32.750 
query SPARQL and to do really
sophisticated queries with it.

171
00:12:32.750 --> 00:12:36.410 
And we will see this in lots of examples.
So don't worry, you will learn

172
00:12:36.520 --> 00:12:44.290 
how to use that. Okay, so let's have a first
look on a full fledged SPARQL query.

173
00:12:46.010 --> 00:12:48.540 
We said already that it's based
on turtle which means we need,

174
00:12:48.540 --> 00:12:52.610 
of course, prefixes to make this
look a bit more readable.

175
00:12:53.300 --> 00:12:56.380 
The example we are following
here is quite easy. So we want

176
00:12:56.390 --> 00:13:00.710 
to look for authors and the
titles of their notable works.

177
00:13:01.190 --> 00:13:05.470 
And we want to look there in dbpedia
for exactly that information.

178
00:13:05.960 --> 00:13:09.280 
So what we define first here is we
have to define the according

179
00:13:09.280 --> 00:13:10.700 
name spaces
that we need.

180
00:13:11.670 --> 00:13:15.590 
We always need name spaces for
rdf and rdfs since we will

181
00:13:15.610 --> 00:13:20.430 
often use rdf and rdfs properties.
Secondly if we are talking

182
00:13:20.430 --> 00:13:25.610 
about dbpedia we might also use the
dbpedia ontology namespace which

183
00:13:25.610 --> 00:13:30.920 
gives us the names of lots of the
properties that are used there. So now

184
00:13:32.180 --> 00:13:35.980 
we start with a select statement
which specifies exactly what

185
00:13:35.980 --> 00:13:37.440 
I want to have
in my output

186
00:13:38.170 --> 00:13:41.500 
and in my output I want to have
the name of the author I call

187
00:13:41.500 --> 00:13:45.070 
this all the name and I want to
have the title of the books.

188
00:13:45.070 --> 00:13:46.240 
So this is then
the title.

189
00:13:48.460 --> 00:13:52.910 
Next I usually have to specify the
graph to be queried, especially

190
00:13:53.300 --> 00:13:58.190 
if I met a SPARQL end point where many
different graphs might be available.

191
00:13:58.940 --> 00:14:02.630 
In case they have only one graph
then this is the so called

192
00:14:02.660 --> 00:14:08.010 
default graph and I can also
leave out that line and I don't

193
00:14:08.020 --> 00:14:13.230 
need to specify the from case. For
sake of completeness of course

194
00:14:13.230 --> 00:14:17.710 
I show you here that you need the from
but you will see we will need it

195
00:14:17.810 --> 00:14:22.850 
in case we are querying several graphs and
combine the results of them together.

196
00:14:24.180 --> 00:14:26.900 
And then comes the so
called where clause.

197
00:14:27.470 --> 00:14:31.870 
So with the keyword where I
specify all the constraints that

198
00:14:31.870 --> 00:14:35.510 
are put into the graph patterns
that have to be matched. So

199
00:14:35.760 --> 00:14:39.960 
you see here I'm looking for
somebody or some variable I refer

200
00:14:39.960 --> 00:14:44.260 
to as author and author should
be of the type dbo:writer. So this

201
00:14:44.260 --> 00:14:45.540 
means this is
some author.

202
00:14:46.520 --> 00:14:50.160 
Next they say okay, I want not to
have the entity, I want to have

203
00:14:50.170 --> 00:14:52.400 
the name of the entity
which means the label.

204
00:14:52.870 --> 00:14:58.120 
So then I connect author variable here
again with rdfs label which gives me

205
00:14:58.390 --> 00:15:01.340 
the name in human readable
form of the author.

206
00:15:02.420 --> 00:15:06.260 
Interestingly dbo which means
dbpedia ontology gives me

207
00:15:06.260 --> 00:15:09.710 
also a property that states but
what is the notable work of

208
00:15:09.710 --> 00:15:13.690 
somebody. So I connect author then
with notable work and then

209
00:15:13.920 --> 00:15:18.900 
look for the works in a variable
called work and then I say okay

210
00:15:19.680 --> 00:15:24.140 
I also don't want to have exactly that
entity, I want to have the title

211
00:15:24.460 --> 00:15:29.960 
of that entity, so I say work should
be connected via rdfs label

212
00:15:30.220 --> 00:15:33.480 
to its title that has to be filled
and queried from the graph

213
00:15:33.480 --> 00:15:37.440 
and then in the end what I have is the
name of the author and the title

214
00:15:37.810 --> 00:15:41.360 
of the book of his or
her notable work.

215
00:15:42.350 --> 00:15:46.380 
And for all SPARQL
queries that we present you here

216
00:15:46.380 --> 00:15:49.810 
in the lecture we are going
to present you in future lectures,

217
00:15:50.090 --> 00:15:54.100 
you will always see that no matter
whether we are querying dbpedia

218
00:15:54.250 --> 00:15:57.530 
as a knowledge base or whether
we are carrying the data as

219
00:15:57.530 --> 00:16:02.880 
a knowledge base we always
have here in the lower right

220
00:16:02.890 --> 00:16:08.060 
part of the slide you will see
a link which tells use query

221
00:16:08.060 --> 00:16:12.020 
SPARQL endpoint. If you click on that
link I show you how this works.

222
00:16:12.470 --> 00:16:14.090 
So I click here
on that link.

223
00:16:14.720 --> 00:16:19.850 
You will be directly transported in
your browser to the SPARQL endpoint

224
00:16:20.090 --> 00:16:24.600 
and the query will show up immediately
here in the query window.

225
00:16:24.600 --> 00:16:28.270 
You see here exactly the same
query, we have here the prefixes,

226
00:16:28.270 --> 00:16:31.870 
the select statement, the from, the
where clause and so on and so on.

227
00:16:32.310 --> 00:16:36.860 
So what I do here then is simply
I go here and say run query

228
00:16:39.220 --> 00:16:42.010 
and you see the result. So we
have here all the names,

229
00:16:42.970 --> 00:16:46.700 
first column and second
column here title.

230
00:16:47.200 --> 00:16:50.240 
And as you see here it's interesting
in that knowledge base

231
00:16:50.240 --> 00:16:53.350 
of course there are labels in
many different languages. So you

232
00:16:53.350 --> 00:16:56.790 
have here the name of the author
Abbie Hoffman written in English,

233
00:16:56.790 --> 00:17:00.310 
in German, in Spanish, in French,
in Italian, in Japanese, in

234
00:17:00.310 --> 00:17:05.600 
Dutch and so on and so on. So you see
this holds for the author name as well

235
00:17:05.740 --> 00:17:09.600 
as for the title name. So if
you want to have, let's say,

236
00:17:09.760 --> 00:17:12.580 
usable results you should
restrict to one language.

237
00:17:13.050 --> 00:17:17.610 
But we will see later on how
exactly this is going to work. So

238
00:17:18.270 --> 00:17:22.860 
let's continue with the lecture
and with learning SPARQL.

239
00:17:23.990 --> 00:17:28.650 
Next thing I'm going to teach
you is how I can transform

240
00:17:28.830 --> 00:17:33.240 
this output with so called solution
sequence modifiers, which

241
00:17:33.240 --> 00:17:35.580 
means I can for example
order the output.

242
00:17:36.000 --> 00:17:40.030 
It can limit the output that only
a specific numbers of items

243
00:17:40.030 --> 00:17:42.190 
will be displayed and
also I can say, yeah,

244
00:17:42.750 --> 00:17:47.800 
leave out the first n rows of
the result. I only want to see

245
00:17:47.800 --> 00:17:51.740 
this starting, let's say, from row
ten or starting from row number

246
00:17:51.740 --> 00:17:57.400 
twenty and so on. So these are so called output
solution or solution sequence modifiers.

247
00:17:58.230 --> 00:18:01.370 
Our example here is again quite
similar - search for all authors

248
00:18:01.370 --> 00:18:04.220 
and the titles of the
notable works. But now

249
00:18:04.630 --> 00:18:08.960 
ordered by authors in ascending
order and limit the results

250
00:18:08.960 --> 00:18:13.520 
to the first one hundred results starting
the list at offset ten position.

251
00:18:14.270 --> 00:18:18.680 
So what I do is exactly the same
query that we had before. And now

252
00:18:18.920 --> 00:18:22.430 
what I'm going to do is the following -
what I'm going to do here is I

253
00:18:23.250 --> 00:18:28.850 
put here some solution sequence
modifiers, so first I say, order by,

254
00:18:29.210 --> 00:18:32.430 
so this means the result will be
ordered. And then I have the

255
00:18:32.430 --> 00:18:36.260 
choice between ascending and
descending and this series is ascending.

256
00:18:36.550 --> 00:18:38.820 
And then I have
to specify,

257
00:18:39.440 --> 00:18:43.830 
in parenthesis, the variable according
to which the output should

258
00:18:43.840 --> 00:18:45.690 
be ordered. And this
is here the author name.

259
00:18:47.730 --> 00:18:52.030 
Next keyword that you learn here is
limit. Limit tells you, okay, only display

260
00:18:52.550 --> 00:18:56.760 
the number of results that I state
here after limit and this is, well,

261
00:18:56.920 --> 00:19:00.390 
one hundred here. And then I can
give also an offset nd here it is

262
00:19:00.390 --> 00:19:05.420 
offset ten which means line ten
to one hundred and ten are

263
00:19:05.420 --> 00:19:08.390 
displayed. We can try this out
again you see here I have

264
00:19:08.840 --> 00:19:12.430 
a small link given in the slide.
So simply you download the

265
00:19:12.430 --> 00:19:15.680 
slides and then click
on the link. Sorry,

266
00:19:16.150 --> 00:19:18.900 
now I was too fast. I really have
to click on the link here

267
00:19:19.670 --> 00:19:24.690 
and you see here is the query with
limited offset and I do run query.

268
00:19:25.350 --> 00:19:26.810 
And what you see now is

269
00:19:27.940 --> 00:19:32.680 
the table stops here, most likely
after one hundred entries and

270
00:19:32.680 --> 00:19:36.120 
it starts at entry number ten
and this here should be

271
00:19:36.120 --> 00:19:39.600 
Aaron Covington and you see here
the author names are ordered

272
00:19:39.600 --> 00:19:43.510 
alphabetically, so Aaron McGruder
with double a in the beginning

273
00:19:43.760 --> 00:19:46.930 
comes before Abbie Hoffman
with a b in the beginning.

274
00:19:47.520 --> 00:19:49.840 
So you see this
most likely is working.

275
00:19:52.230 --> 00:19:57.560 
Okay so these were output or
solution sequence modifiers.

276
00:20:00.130 --> 00:20:05.520 
The next thing we are going to do is we
want to further, let's say, filter through

277
00:20:05.640 --> 00:20:10.740 
the output of the results. Sometimes
we are only interested in some

278
00:20:10.940 --> 00:20:14.510 
of the output that fulfilled
specific requirements.

279
00:20:15.180 --> 00:20:20.110 
And simply these kind of constraints,
these filter constraints

280
00:20:20.110 --> 00:20:25.220 
can be expressed within the graph
patterns by adding to a graph pattern

281
00:20:25.510 --> 00:20:29.900 
a filter condition. Of course here
with the keyword filter. You

282
00:20:29.900 --> 00:20:33.210 
see what we want to do in the
example is search for all authors

283
00:20:33.280 --> 00:20:37.750 
and the titles of the notable works that
have more than five hundred pages,

284
00:20:37.980 --> 00:20:41.470 
and again limit the result to
the first one hundred, so the

285
00:20:41.470 --> 00:20:45.420 
table will not be too long. So what
I do here is then of course

286
00:20:45.420 --> 00:20:48.770 
I have or I want to have the number
of pages here, and you see here

287
00:20:49.210 --> 00:20:53.130 
of the work, the notable work
that I have selected what I do

288
00:20:53.130 --> 00:20:58.420 
here I select here another property
dbo:number of pages and

289
00:20:58.420 --> 00:21:01.970 
fill a variable called pages. And of
course also I bring the pages here

290
00:21:02.410 --> 00:21:07.030 
in the output in within the select
state. And so I select here

291
00:21:07.060 --> 00:21:10.430 
also name title and pages and
here of course I have to

292
00:21:10.900 --> 00:21:13.690 
specify a graph pattern
for these pages.

293
00:21:14.700 --> 00:21:19.450 
And again what I do now is I
add here a filter condition

294
00:21:19.890 --> 00:21:22.480 
and in the filter condition
I say simply here

295
00:21:23.660 --> 00:21:27.850 
the pages, so this is the variable
I have selected before, should be

296
00:21:28.630 --> 00:21:33.570 
more or greater than five hundred and
I close the parenthesis and that's it.

297
00:21:34.070 --> 00:21:37.600 
So let's see what exactly happens
if I query that on the SPARQL

298
00:21:37.600 --> 00:21:39.150 
endpoint so you
see it here

299
00:21:39.870 --> 00:21:41.750 
and what we are
going to do

300
00:21:42.750 --> 00:21:47.270 
is the following - you see here now a
table with author name, title and pages.

301
00:21:48.150 --> 00:21:51.660 
It's a bit long, simply because
pages is given here with

302
00:21:51.660 --> 00:21:56.040 
a data type is a positive integer and
it starts here with Victor Hugo

303
00:21:56.200 --> 00:21:58.820 
and the book is The Hunchback
of Notre Dame and the

304
00:21:59.340 --> 00:22:03.450 
number of pages is nine hundred forty
and since we haven't restricted so far

305
00:22:03.750 --> 00:22:06.740 
the language you see here the
author name in all languages

306
00:22:06.740 --> 00:22:10.470 
including Arabic and also then
the same book all over again

307
00:22:10.470 --> 00:22:13.940 
in different languages. So you have
here Nuestra Senora de Paris

308
00:22:14.270 --> 00:22:19.380 
which is in Spanish and stuff
like that. So this is interesting

309
00:22:19.560 --> 00:22:22.830 
to see what exactly the
result we were looking for.

310
00:22:25.650 --> 00:22:30.580 
Okay two last things I want to give you on
your way in that part of the lecture.

311
00:22:31.520 --> 00:22:33.090 
Of course what
you can do

312
00:22:33.720 --> 00:22:40.460 
when you are using these filter conditions
is you can combine several conditions

313
00:22:40.830 --> 00:22:44.740 
with further restrictions and they
are so called unary operators

314
00:22:44.740 --> 00:22:49.540 
that you can use. So for example if your
condition results into a boolean value

315
00:22:49.740 --> 00:22:53.030 
you can negate it. So this
is this negation operator.

316
00:22:53.510 --> 00:22:57.690 
If it results or it's part
it's a numeric variable then

317
00:22:57.690 --> 00:23:01.050 
of course you can either turn it
to positive or negative with

318
00:23:01.050 --> 00:23:02.460 
a plus or a minus sign.

319
00:23:03.250 --> 00:23:06.800 
You can ask but a variable really
is bound which means does

320
00:23:06.800 --> 00:23:08.360 
this have a
result or not with

321
00:23:09.390 --> 00:23:12.880 
the operator bound and then in
parenthesis is the variable name

322
00:23:12.880 --> 00:23:17.410 
that you are asking for. You can ask
if the variable result here

323
00:23:17.610 --> 00:23:20.970 
is a URI, you can ask whether
this is a blank node, you can

324
00:23:20.970 --> 00:23:22.410 
ask whether it is a literal.

325
00:23:23.240 --> 00:23:27.640 
What you further can do is you
can transform, for example, an

326
00:23:27.640 --> 00:23:31.770 
output into a string. So you can
transform any kind of literal

327
00:23:31.770 --> 00:23:36.070 
or URL into a string. And you
can ask for a specific language

328
00:23:36.070 --> 00:23:39.190 
so you could for example find
out what the language of a

329
00:23:39.190 --> 00:23:42.910 
specific string is. Is it English, is
it French, is it Italian and you

330
00:23:42.910 --> 00:23:46.130 
can ask for a specific data type
and you will get back that

331
00:23:46.130 --> 00:23:50.490 
URI of the data type. So these
are things you can combine within

332
00:23:50.730 --> 00:23:54.850 
the filter constraints and then you can
do really interesting and sophisticated

333
00:23:55.050 --> 00:23:56.790 
queries with it.

334
00:23:58.260 --> 00:24:02.850 
The very last query I'm going to show
you here in this part of the lecture

335
00:24:03.180 --> 00:24:07.250 
makes use here for example of
this language operator and we

336
00:24:07.250 --> 00:24:10.830 
have talked about that now of course
we want to have all the authors and

337
00:24:10.950 --> 00:24:12.340 
the titles of
their books

338
00:24:12.990 --> 00:24:17.220 
in possibly English language.
And the other thing of course

339
00:24:17.220 --> 00:24:20.950 
what I want to do here is I want
to do a bit, let's say, further

340
00:24:20.950 --> 00:24:24.450 
restrictions. I search for authors
and their books filter with

341
00:24:24.460 --> 00:24:28.420 
the results for English labels
and environmental fiction books

342
00:24:28.420 --> 00:24:32.270 
and of course in the end I limit
again to one hundred resulting lines.

343
00:24:33.030 --> 00:24:36.290 
Let's have a look how to do that so
we include to filter conditions.

344
00:24:36.290 --> 00:24:39.670 
So first you see here that we
say ok first filter condition

345
00:24:39.670 --> 00:24:41.530 
we want to have
the author name

346
00:24:42.240 --> 00:24:47.790 
to be English - en - and of course we
also want to have the title name

347
00:24:48.050 --> 00:24:51.620 
to be English. And the last thing
is of course the work should be,

348
00:24:52.190 --> 00:24:54.950 
among the class should
have dtc:subject

349
00:24:55.600 --> 00:24:57.120 
environmental
fiction books.

350
00:24:58.880 --> 00:25:02.800 
So if we do that and we query
that on the SPARQL end point, let's look,

351
00:25:07.800 --> 00:25:10.580 
the result is much shorter as
you see here. So there are not

352
00:25:10.580 --> 00:25:16.130 
so many environmental fiction
books within dbpedia. However these

353
00:25:16.130 --> 00:25:19.010 
are the english author names and
the english titles and there

354
00:25:19.010 --> 00:25:23.870 
you have Paul Hawken or people
named like Bjorn Lomborg,

355
00:25:23.920 --> 00:25:27.790 
Nicky Hager and so on and so on
and you see also the title

356
00:25:28.150 --> 00:25:31.100 
of the results in English. You
could do now exactly the same

357
00:25:31.100 --> 00:25:35.780 
for French, for Italian for any
other language. Simply try it out,

358
00:25:36.040 --> 00:25:40.810 
use exactly the link we have
provided, you use the query and

359
00:25:40.810 --> 00:25:44.110 
then modify it accordingly and
play around with it. So this is

360
00:25:44.320 --> 00:25:47.180 
the purpose of exactly
what we did so far.

361
00:25:48.360 --> 00:25:53.220 
Okay one of the, let's say, basic
questions you might have right

362
00:25:53.220 --> 00:25:57.100 
now is, yeah, this is all nice
what you do with this dbpedia

363
00:25:57.260 --> 00:26:01.070 
but how in the world do you come
up you know with the names

364
00:26:01.070 --> 00:26:04.800 
of the properties, with the names
of the classes, with the names

365
00:26:04.800 --> 00:26:06.240 
of the stuff
you are using.

366
00:26:06.870 --> 00:26:09.560 
For that of course you have to
get some knowledge about these

367
00:26:09.900 --> 00:26:13.740 
databases or knowledge bases we are
talking about and therefore now

368
00:26:14.110 --> 00:26:17.560 
in the lecture that will come to
excursions the first one on

369
00:26:17.710 --> 00:26:22.030 
dbpedia knowledge base and the second
one on wikidata database that you

370
00:26:22.260 --> 00:26:26.080 
get a bit better acquainted with
exactly these resources that

371
00:26:26.090 --> 00:26:29.950 
we will use heavily then in
the course of this lecture.
