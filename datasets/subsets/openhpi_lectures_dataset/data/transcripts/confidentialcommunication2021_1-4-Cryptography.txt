WEBVTT

1
00:00:02.060 --> 00:00:04.790 
In our openHPI course "Confidential
Communication in the internet",

2
00:00:05.330 --> 00:00:07.930 
we want to introduce
now the

3
00:00:08.560 --> 00:00:15.410 
cryptography. Cryptography is a
science which provide tools to

4
00:00:16.350 --> 00:00:19.710 
guarantee the confidentiality
of information.

5
00:00:21.260 --> 00:00:25.210 
How is this done?
You know that already.

6
00:00:26.050 --> 00:00:31.130 
Cryptography is the science of
encoding and decoding information.

7
00:00:32.150 --> 00:00:36.530 
And what is the basic idea of
encryption, of encoding information?

8
00:00:37.470 --> 00:00:42.660 
Such an encryption makes information
incomprehensible for any

9
00:00:42.940 --> 00:00:44.680 
unauthorized outsider.

10
00:00:46.790 --> 00:00:53.790 
So the meaningful, for example,
text is converted into a

11
00:00:54.890 --> 00:00:57.640 
very randomly looking

12
00:00:58.570 --> 00:01:04.520 
sequence of signs and others so one
cannot one can no more understand

13
00:01:04.930 --> 00:01:08.950 
the content and the meaning
of such document, only insiders.

14
00:01:09.790 --> 00:01:12.820 
Insiders who know
how to reverse

15
00:01:13.870 --> 00:01:19.790 
encrypted document into the original
document, they can get the information.

16
00:01:20.840 --> 00:01:27.220 
By reversing from the encrypted to
the plaintext document this is

17
00:01:27.510 --> 00:01:32.900 
the decryption. So encryption and
decryption are carried out using

18
00:01:33.120 --> 00:01:37.610 
cryptographic methods and there is a
variety of such cryptographic methods

19
00:01:38.100 --> 00:01:41.180 
but there are so
many information

20
00:01:42.320 --> 00:01:47.970 
which are sent over the internet that we do
not have enough cryptographic methods

21
00:01:48.160 --> 00:01:50.360 
so that we can
change from each

22
00:01:51.080 --> 00:01:56.900 
transmission to another transmission by
one cryptographic method to another.

23
00:01:57.430 --> 00:02:04.630 
And for that reason the single cryptographic
methods can be parameterised,

24
00:02:04.630 --> 00:02:07.570 
can be controlled by
a parameter, by a

25
00:02:08.770 --> 00:02:11.170 
certain piece of
additional information,

26
00:02:11.580 --> 00:02:13.540 
by means of the
so called keys.

27
00:02:15.410 --> 00:02:23.130 
So we have our document in plain text, so
one can read it and can understand it.

28
00:02:23.770 --> 00:02:27.020 
And then there is applied
an encryption method

29
00:02:27.440 --> 00:02:33.210 
to encrypt this and transform this
in a ciphertext. And this method

30
00:02:33.560 --> 00:02:39.470 
is controlled by a key,
by a secure key and

31
00:02:40.390 --> 00:02:47.540 
so the same encryption method can be
used by many people for many documents.

32
00:02:48.120 --> 00:02:55.160 
If we look to an example in the internet
world, the DES encryption

33
00:02:55.620 --> 00:03:02.120 
algorithm is very famous. So
it starts with a message. For

34
00:03:02.120 --> 00:03:05.690 
example, this is a
confidential message. Then a

35
00:03:06.720 --> 00:03:12.910 
key that's the sequence of certain
letters, and the application

36
00:03:12.910 --> 00:03:18.260 
of this key - secure key to the
DES encryption algorithm

37
00:03:18.520 --> 00:03:24.870 
convert this text, this is a conventional
message, in the following ciphertext.

38
00:03:25.130 --> 00:03:30.250 
Ciphertext that's the encrypted text.
And here you see that this is a

39
00:03:30.840 --> 00:03:35.510 
completely stupid looking
a sequence of letters

40
00:03:35.990 --> 00:03:42.160 
and other signs
and numbers and others.

41
00:03:44.210 --> 00:03:48.430 
When we discuss such
cryptographic procedures,

42
00:03:49.010 --> 00:03:53.970 
then we have to know the
Kerckhoffs principle.

43
00:03:54.800 --> 00:03:58.060 
So Auguste Kerckhoffs
was a scientist and a

44
00:03:58.550 --> 00:04:01.250 
cryptographic
scientist from the

45
00:04:02.440 --> 00:04:10.500 
nineteenth century and he claimed that the
security of such a cryptographic process

46
00:04:11.310 --> 00:04:15.310 
should only be based on
the secrecy of the key,

47
00:04:16.160 --> 00:04:21.190 
and not on the secrecy of
the cryptographic process.

48
00:04:22.220 --> 00:04:25.160 
And what's the idea behind this
very important principle?

49
00:04:26.240 --> 00:04:32.790 
The principle says the cryptographic
process, the cryptographic method itself

50
00:04:33.240 --> 00:04:37.770 
they should be open. Everyone can
know this method. So all those

51
00:04:38.020 --> 00:04:45.140 
analytics, cyber analytics people can
investigate this procedure and can check

52
00:04:45.330 --> 00:04:47.200 
whether there are
some weakness or not.

53
00:04:47.970 --> 00:04:52.470 
The application later on
the secrecy of the

54
00:04:53.500 --> 00:04:58.940 
cyber text only depends
from the secrecy of the key.

55
00:05:01.390 --> 00:05:02.290 
When we look to the

56
00:05:04.410 --> 00:05:08.490 
cryptographic methods that
we can see two groups.

57
00:05:09.530 --> 00:05:15.140 
The one is a group of so called
symmetric encryption methods

58
00:05:15.890 --> 00:05:21.640 
and symmetric, the reason to call
these methods symmetric methods is

59
00:05:22.190 --> 00:05:27.040 
that they use the same
key for encryption

60
00:05:27.750 --> 00:05:28.870 
and for decryption.

61
00:05:30.430 --> 00:05:35.270 
So the person which encrypts a key
and the person that decrypts a message

62
00:05:35.680 --> 00:05:39.640 
they both need to know the key
because both the encryption

63
00:05:39.640 --> 00:05:44.370 
is done with the key encryption
method and the decryption is done

64
00:05:45.120 --> 00:05:47.540 
with this method
and the same key.

65
00:05:48.440 --> 00:05:51.880 
So it is very very
important so that this

66
00:05:52.480 --> 00:05:55.970 
algorithms and this methods can
be applied in a secure way

67
00:05:56.430 --> 00:06:02.500 
that only sender and receiver know
this key because everyone else

68
00:06:02.800 --> 00:06:05.740 
who knows a key or gets
access to the key

69
00:06:06.250 --> 00:06:12.760 
can also decrypt the text, the
ciphertext and can see the content.

70
00:06:14.250 --> 00:06:18.200 
There are a number of known
and cryptographic methods,

71
00:06:20.280 --> 00:06:24.450 
I already mentioned this is
the data encryption standard,

72
00:06:25.010 --> 00:06:30.040 
IDEAis the international data encryption
algorithm is another important symmetric

73
00:06:30.310 --> 00:06:35.410 
encryption method used in the
internet and the successor of DES

74
00:06:35.790 --> 00:06:40.870 
is AES, the advanced
encryption standard as DES

75
00:06:42.730 --> 00:06:47.750 
is no more considered to be secure.
So today one has to use the

76
00:06:47.850 --> 00:06:49.330 
advanced encryption
standard.

77
00:06:50.680 --> 00:06:55.740 
With the symmetric encryption methods
there is one fundamental problem.

78
00:06:56.700 --> 00:07:01.530 
How to securely exchange
the encryption key?

79
00:07:02.860 --> 00:07:08.020 
If you do this in the criminal
novels

80
00:07:08.560 --> 00:07:14.350 
of the last century, then they both,
the spy and they met in a bookstore

81
00:07:14.350 --> 00:07:18.150 
and they changed the key and
then both go back to their

82
00:07:18.810 --> 00:07:20.260 
flat or to their

83
00:07:21.060 --> 00:07:26.050 
countries and then afterwards
they could send encrypted data,

84
00:07:26.410 --> 00:07:30.030 
encrypted messages by means
of the exchange key.

85
00:07:30.670 --> 00:07:32.990 
But how to exchange
a key when we

86
00:07:33.680 --> 00:07:36.500 
want to send, want to communicate
over the internet?

87
00:07:37.490 --> 00:07:40.790 
We cannot send the key to our
partner because everyone else

88
00:07:40.790 --> 00:07:43.010 
also can get the
key and then

89
00:07:44.110 --> 00:07:48.480 
the person that also this unauthorized
person that also got the key

90
00:07:48.670 --> 00:07:53.720 
is also able to decrypt. So this is a
very very big and central question

91
00:07:54.070 --> 00:07:57.630 
when using such symmetric
encryption methods

92
00:07:59.070 --> 00:08:03.570 
because both coming from the
plain text to the secret text

93
00:08:03.570 --> 00:08:10.430 
to the ciphertext when it's the same key
as when needs to decrypt the cipher

94
00:08:10.640 --> 00:08:12.430 
text into the plaintext.

95
00:08:15.530 --> 00:08:20.520 
We have a third group of cryptographic
methods. We already mentioned the symmetric.

96
00:08:20.820 --> 00:08:24.410 
Later on we will look to the
other methods. Before that

97
00:08:24.410 --> 00:08:30.140 
I want to mention the third group
and these are the hash procedures.

98
00:08:31.610 --> 00:08:35.240 
So in computer science hash
functions are very popular

99
00:08:35.810 --> 00:08:40.050 
and they are also applied in the
field of information security.

100
00:08:40.710 --> 00:08:43.890 
And in information
security, the idea

101
00:08:45.290 --> 00:08:51.820 
of usage of such hash functions is to
generate fingerprints from documents.

102
00:08:52.620 --> 00:08:59.390 
Fingerprints that characterize that
document as precise as possible.

103
00:09:01.040 --> 00:09:04.860 
The idea is if we want for
example to communicate video

104
00:09:05.550 --> 00:09:09.570 
with our latest research results,
it's a huge amount of information.

105
00:09:10.270 --> 00:09:16.340 
And to encrypt this huge amount costs
very much resources. So the idea is

106
00:09:16.780 --> 00:09:20.420 
to produce from the
huge document,

107
00:09:21.060 --> 00:09:23.680 
a small fingerprint
and then only

108
00:09:25.160 --> 00:09:27.770 
only encrypt the
fingerprint.

109
00:09:28.970 --> 00:09:32.700 
With this we cannot guarantee the
confidentiality when we send

110
00:09:32.700 --> 00:09:35.860 
the videos but we can
guarantee the integrity.

111
00:09:36.550 --> 00:09:40.800 
We will discuss this later when
we discuss digital signatures.

112
00:09:42.120 --> 00:09:44.330 
So the objectives to

113
00:09:44.980 --> 00:09:49.690 
be able to use hash functions
with that purposes is

114
00:09:50.370 --> 00:09:54.370 
that the compression of a
document of any length

115
00:09:54.810 --> 00:09:59.540 
to a fixed length, for example one
hundred and sixty bit string

116
00:10:00.230 --> 00:10:04.390 
that it is done in a way that from
the one hundred and sixty bit

117
00:10:04.620 --> 00:10:11.770 
string, it's almost no more possible
to compute the original document.

118
00:10:13.730 --> 00:10:18.920 
Practically should it be impossible.
So what we want, what we

119
00:10:18.920 --> 00:10:24.350 
need in information security are so
called one way hash functions. In one way

120
00:10:24.620 --> 00:10:28.490 
from the document to the hash
it's very easy to compute. But

121
00:10:28.490 --> 00:10:34.890 
in the other way, from the hash back to
the document this is almost impossible.

122
00:10:35.450 --> 00:10:41.030 
Practically it's impossible in the
sense that it needs so much time

123
00:10:41.240 --> 00:10:46.280 
that this time
is centuries for example.

124
00:10:47.990 --> 00:10:52.940 
The second objective of such
cryptographic hash functions is

125
00:10:54.080 --> 00:10:57.940 
they should be very difficult,
it should be very difficult

126
00:10:58.500 --> 00:11:02.280 
for a cryptographic hash
function it should be very difficult

127
00:11:02.990 --> 00:11:08.090 
to find a second document with
exactly the same hash value

128
00:11:08.340 --> 00:11:13.950 
like our original document. We
call this collision resistance

129
00:11:14.450 --> 00:11:20.290 
and we will later understand why this
is a very important request for

130
00:11:21.110 --> 00:11:22.750 
using such hash
functions.

131
00:11:24.390 --> 00:11:30.370 
The hash functions that are currently
regarded as secure is RIPEMD,

132
00:11:30.850 --> 00:11:33.160 
is SHA-256

133
00:11:34.080 --> 00:11:39.830 
here is seen as an
example if we use the SHA hash

134
00:11:40.490 --> 00:11:46.130 
function for the text ABCD
and for the text ABCDE

135
00:11:46.610 --> 00:11:51.980 
then you see very different
hash values. Also this

136
00:11:52.480 --> 00:11:57.540 
original clear text
are relatively similar.

137
00:11:58.140 --> 00:12:02.980 
Of course in this example I do not
use a large document. I showed

138
00:12:02.980 --> 00:12:05.910 
this effect at hand of
a vary small example.

139
00:12:06.540 --> 00:12:10.770 
Then we have SHA-512.
This number gives

140
00:12:10.770 --> 00:12:14.360 
the length of the hash
value as it's produced.

141
00:12:15.050 --> 00:12:20.680 
And then there is a number of hash
methods that are still in use

142
00:12:20.980 --> 00:12:24.650 
but can no more be
considered safe today.

143
00:12:25.150 --> 00:12:30.420 
This is MD4, MD5, this is
RIPEMD-128,

144
00:12:30.640 --> 00:12:37.070 
you see it's a shorter hash length than
this and the shorter the more unsecure are

145
00:12:37.720 --> 00:12:44.570 
such systems. And also the original SHA
which was used as a standardized

146
00:12:45.380 --> 00:12:48.100 
cryptographic hash
function

147
00:12:48.690 --> 00:12:50.530 
by the NSA

148
00:12:51.820 --> 00:12:54.070 
in nineteen ninety two

149
00:12:54.760 --> 00:12:58.300 
is today no more
considered as secure.

150
00:12:59.830 --> 00:13:04.580 
So we have one group of symmetric
encryption methods, we have

151
00:13:04.590 --> 00:13:08.570 
the group of cryptographic hash
functions and the third group

152
00:13:08.580 --> 00:13:16.870 
of such methods and procedures are the cryptographic
asymmetric cryptographic methods.

153
00:13:17.690 --> 00:13:20.180 
And here the

154
00:13:21.410 --> 00:13:27.100 
characteristic property is set,
two different keys are used.

155
00:13:27.190 --> 00:13:30.960 
One for the encryption and the
other for the decryption.

156
00:13:31.850 --> 00:13:37.580 
And we will see with this method it's
more easy and better applicable

157
00:13:38.010 --> 00:13:43.540 
to the internet because the
exchange of the secret key that

158
00:13:43.540 --> 00:13:48.260 
both times are needed is no more
necessary because we have

159
00:13:48.410 --> 00:13:52.740 
two different keys. So every user
gets a so called secret key.

160
00:13:53.200 --> 00:13:55.460 
It is called
private key.

161
00:13:58.300 --> 00:14:03.770 
It is called private key and we
have the public key. The public key

162
00:14:03.900 --> 00:14:11.260 
is open. So for example we
can also look other procedures.

163
00:14:11.390 --> 00:14:16.550 
We have a plaintext and with the
public key of the receiver,

164
00:14:17.370 --> 00:14:23.190 
this plaintext is encrypted. Then
it's sent to the receiver and the

165
00:14:23.390 --> 00:14:27.650 
receiver can use his or
her private key to

166
00:14:28.090 --> 00:14:30.230 
reproduce the plaintext.

167
00:14:31.590 --> 00:14:35.270 
What is important is that
this principle is working

168
00:14:35.970 --> 00:14:39.340 
it should be impossible
that the public

169
00:14:39.770 --> 00:14:45.190 
key is created out of the
private key, that the private key

170
00:14:45.490 --> 00:14:51.810 
is created out of the public key. So the
public key is published publicly. Everyone

171
00:14:52.010 --> 00:14:54.720 
can use everyone in
our encryption

172
00:14:55.860 --> 00:15:01.610 
participant of our encryption method.
Everyone should know and can know it.

173
00:15:01.970 --> 00:15:08.080 
But the private key, the private key
must remain absolutely secure.

174
00:15:08.830 --> 00:15:10.100 
If the private key,

175
00:15:11.610 --> 00:15:15.940 
if my private key comes into
a hand of anyone else

176
00:15:16.560 --> 00:15:22.280 
the system is no more secure because
this person also can decrypt

177
00:15:22.300 --> 00:15:23.890 
messages which
were sent to me.

178
00:15:24.670 --> 00:15:27.090 
And this was what I
start to mention

179
00:15:28.850 --> 00:15:31.150 
to hold this
private key

180
00:15:32.180 --> 00:15:35.860 
absolutely privately, it
should be not possible

181
00:15:37.600 --> 00:15:39.780 
to compute this out of

182
00:15:40.730 --> 00:15:42.320 
a corresponding
public key.

183
00:15:45.310 --> 00:15:49.400 
Let's have a closer look to an
example and the first example

184
00:15:49.400 --> 00:15:52.110 
when we discuss such
asymmetric encryption method

185
00:15:52.560 --> 00:15:54.130 
is the encryption
example.

186
00:15:55.130 --> 00:15:57.940 
And the encryption I
already mentioned

187
00:15:59.210 --> 00:16:04.770 
discussing the illustration is that
the public key of the recipient

188
00:16:04.770 --> 00:16:09.740 
is used for the encryption. Then the
message is sent to the recipient

189
00:16:09.970 --> 00:16:13.860 
and then the recipient can
use its private key for the

190
00:16:14.380 --> 00:16:20.500 
decryption. And because of this
because this private key

191
00:16:23.150 --> 00:16:26.070 
is only known and is
only available to the

192
00:16:26.510 --> 00:16:33.050 
receiver, only the receiver is possible
to decrypt the message. No one else.

193
00:16:33.740 --> 00:16:39.040 
Even the sender can know or
not decrypt the message.

194
00:16:40.630 --> 00:16:45.200 
And for this asymmetric encryption
methods there is also a second

195
00:16:45.610 --> 00:16:49.340 
usability

196
00:16:51.170 --> 00:16:52.160 
way to use it.

197
00:16:53.380 --> 00:16:57.810 
This is a digital signature approach.
Here the following is done.

198
00:16:58.360 --> 00:17:03.890 
The document is encrypted
with the private key

199
00:17:04.330 --> 00:17:09.410 
of the signee. So I
encrypt for example a

200
00:17:10.460 --> 00:17:16.010 
contract. And then everyone who
wants to check whether this

201
00:17:16.030 --> 00:17:17.990 
information really
comes for me

202
00:17:19.290 --> 00:17:22.260 
can use my public key

203
00:17:22.930 --> 00:17:27.090 
and with my public key he or
she can decrypt the document.

204
00:17:27.910 --> 00:17:30.100 
And this is
considered a proof

205
00:17:30.760 --> 00:17:33.990 
if it's possible to successfully
decrypt the document,

206
00:17:34.390 --> 00:17:39.890 
then it's a proof that this message
really comes from the signee

207
00:17:40.410 --> 00:17:42.640 
because only he or
she were able

208
00:17:43.530 --> 00:17:48.320 
to encrypt this in such a way with a
private key that it could be decrypted

209
00:17:48.610 --> 00:17:52.990 
with the corresponding with
the corresponding public key.

210
00:17:56.390 --> 00:18:02.620 
How to attack encryptions? Encryption method
whether it's symmetric or whether it's

211
00:18:02.920 --> 00:18:08.460 
asymmetric. With the hash function
we have to discuss other

212
00:18:09.270 --> 00:18:10.170 
attack methods.

213
00:18:12.390 --> 00:18:15.490 
In any case particularly
for the symmetric

214
00:18:16.190 --> 00:18:22.210 
encryption method, the brute force
attack is a possible attack that

215
00:18:22.450 --> 00:18:23.950 
not can be prevented.

216
00:18:24.950 --> 00:18:29.530 
And the idea behind it
is simply to try out

217
00:18:29.950 --> 00:18:35.080 
all theoretical possible keys. So
if you know the key is of length

218
00:18:35.880 --> 00:18:40.720 
one hundred and it
consists of symbols from

219
00:18:42.700 --> 00:18:46.400 
that alphabet and this
special

220
00:18:47.100 --> 00:18:51.020 
signs then one can
systematically start with

221
00:18:51.590 --> 00:18:56.320 
probing all the letters of
the alphabet then all the

222
00:18:57.310 --> 00:18:58.990 
words of length
two, with

223
00:18:59.720 --> 00:19:03.290 
two letters of the alphabet
and checking length three.

224
00:19:04.340 --> 00:19:09.590 
At the end it is a very
very costly and very time consuming

225
00:19:10.520 --> 00:19:18.710 
process. At the end the attacker will
find the real, it will find the real

226
00:19:18.960 --> 00:19:24.500 
key. So we cannot prevent such
brute-force attack. So the only

227
00:19:24.500 --> 00:19:28.260 
protection against such
brute-force attack is

228
00:19:28.720 --> 00:19:35.920 
that the number of possible keys must be
so large that the systematic testing

229
00:19:36.040 --> 00:19:39.610 
needs too long. It is practically
impossible, for example

230
00:19:40.100 --> 00:19:44.330 
costs with the best computers
thousands of years.

231
00:19:47.760 --> 00:19:51.720 
To round up, in later

232
00:19:53.330 --> 00:19:59.750 
clips of the course we will discuss
symmetric and asymmetric encryption

233
00:19:59.960 --> 00:20:04.870 
methods in more detail, but here to
round-up the introduction we

234
00:20:05.030 --> 00:20:08.020 
have to see what are the
important differences

235
00:20:08.480 --> 00:20:12.390 
between the symmetric and
asymmetric encryption methods.

236
00:20:13.360 --> 00:20:18.570 
You remember, the symmetrical procedure,
which are also called secret key

237
00:20:18.870 --> 00:20:22.110 
procedures because the
key needs to be secret,

238
00:20:23.190 --> 00:20:27.770 
they typically are based on vary
simple mathematical functions

239
00:20:27.940 --> 00:20:32.790 
to only change neighbor bit,
typically the keys are bit strings,

240
00:20:33.210 --> 00:20:35.110 
so to change, to

241
00:20:36.530 --> 00:20:40.760 
to perform a logical
AND, OR, or XOR and others.

242
00:20:42.280 --> 00:20:48.270 
The asymmetric procedures, which are
also known as public key procedures,

243
00:20:49.080 --> 00:20:54.080 
they are based on very complex
mathematica facts.

244
00:20:55.610 --> 00:21:01.180 
So public key procedures require
much more computing resources

245
00:21:02.020 --> 00:21:08.990 
to evaluate an encryption or to
evaluate, to perform a decryption

246
00:21:09.210 --> 00:21:13.590 
than the secret key procedures
because the secret key computings

247
00:21:13.810 --> 00:21:18.910 
are very simple, do simple
operations and because the public

248
00:21:18.910 --> 00:21:22.870 
key procedures are based on
complex mathematical functions

249
00:21:23.450 --> 00:21:27.570 
they are more susceptible to
implementation errors.

250
00:21:29.670 --> 00:21:33.500 
In case of the secret key
symmetric procedures

251
00:21:34.170 --> 00:21:37.810 
plaintext ciphertext are
considered as bit string.

252
00:21:39.030 --> 00:21:43.300 
When we consider asymmetric
public key procedures,

253
00:21:44.050 --> 00:21:45.960 
then we interpret the

254
00:21:46.800 --> 00:21:51.400 
key, the plaintext, the
ciphertext as large numbers.

255
00:21:52.240 --> 00:21:57.230 
And this difference makes it
clear here when we consider

256
00:21:57.230 --> 00:22:00.920 
bit strings, we have the simple
bit operations. Here when we

257
00:22:00.920 --> 00:22:06.420 
use complex mathematical functions we
interpret the key and plaintext and text

258
00:22:06.790 --> 00:22:13.410 
and ciphertext as large numbers. So
this was a first introduction into the

259
00:22:14.260 --> 00:22:20.510 
cryptographic methods, the symmetric asymmetric
methods and into hash function

260
00:22:20.720 --> 00:22:23.340 
and in the following

261
00:22:24.180 --> 00:22:28.390 
videos we will have closer look
and also consider some examples.
