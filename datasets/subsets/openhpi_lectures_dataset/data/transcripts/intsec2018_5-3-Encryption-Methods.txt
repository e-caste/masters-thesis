WEBVTT

1
00:00:00.520 --> 00:00:03.090 
Now we want to consider
encryption methods

2
00:00:03.290 --> 00:00:08.370 
that are used in the internet,
that we use in the modern

3
00:00:08.900 --> 00:00:13.670 
world with our powerful
computers. And if you remember

4
00:00:13.680 --> 00:00:18.500 
we've learned that there are two families
as the symmetric 1-key encryption

5
00:00:18.500 --> 00:00:21.620 
method and the assymetric 2-
key encryption methods

6
00:00:21.900 --> 00:00:25.410 
and let's start with
considering the 1-key

7
00:00:25.620 --> 00:00:26.840 
encryption methods.

8
00:00:28.900 --> 00:00:32.940 
The characteristic of that 1-
key encryption methods is that

9
00:00:33.060 --> 00:00:37.910 
the sender and receiver
use the same key,

10
00:00:38.910 --> 00:00:44.140 
so the same 1-key for
encryption and for decryption.

11
00:00:44.950 --> 00:00:49.400 
This key is called the
secret key, both sender

12
00:00:49.720 --> 00:00:54.340 
and receiver need that key.
Sender using it for encryption,

13
00:00:55.280 --> 00:00:58.420 
so the message send
encrypted messages and

14
00:00:58.700 --> 00:01:03.280 
receiver receives encrypted message
and needs a key to decrypt

15
00:01:03.560 --> 00:01:07.890 
that cyber takes it into the
plaintext into the method

16
00:01:07.910 --> 00:01:13.310 
itself, so a huge problem with
this 1-key encryption methods

17
00:01:13.320 --> 00:01:17.700 
is that the question
needs to be solved, how

18
00:01:17.940 --> 00:01:23.850 
this secure key is exchanged
between the sender

19
00:01:23.850 --> 00:01:29.680 
and the receiver. If there is
some mistake in this exchange,

20
00:01:29.690 --> 00:01:35.290 
if someone has accepted that key,
the one who has a secure key

21
00:01:35.450 --> 00:01:40.780 
can see all, can also apply
decryption and it makes no sense

22
00:01:40.780 --> 00:01:44.520 
to encryption and to hide this.
So here's a problem with

23
00:01:44.520 --> 00:01:49.760 
one key encryption methods is that
the sender and the receiver

24
00:01:49.760 --> 00:01:54.620 
need that key and no one else should
have the access to the key.

25
00:01:54.620 --> 00:01:58.270 
Otherwise he or she would have
the access to the message.

26
00:01:58.770 --> 00:02:03.560 
If we look into a former
description of the 1-key

27
00:02:03.930 --> 00:02:09.030 
encryption, then we
have our plaintext,

28
00:02:09.350 --> 00:02:15.030 
the key is chosen and then
the encryption function is

29
00:02:15.440 --> 00:02:21.110 
applied with that key to the plaintext,
then we receive the cipher,

30
00:02:25.820 --> 00:02:31.810 
then when the
receiver wants to decrypt

31
00:02:32.150 --> 00:02:37.120 
cipher, he or she has
takes the cipher

32
00:02:37.120 --> 00:02:39.950 
and has to apply
the same key

33
00:02:40.450 --> 00:02:44.790 
and then by means of
the decrypt method

34
00:02:45.810 --> 00:02:51.840 
one gets the plaintext back. So
this encryption is done by the

35
00:02:51.840 --> 00:02:57.440 
center with the key and then with
the same key as a receiver

36
00:02:57.700 --> 00:03:01.900 
can apply decryption
methods and find

37
00:03:01.900 --> 00:03:07.410 
back the plaintext. They are
some encryption principles

38
00:03:07.410 --> 00:03:11.910 
which are applied

39
00:03:12.130 --> 00:03:16.550 
and when people design such
encryption by one key encryption

40
00:03:16.550 --> 00:03:19.640 
methods. One of the first encryption
principles is diffusion,

41
00:03:19.970 --> 00:03:23.390 
that means each piece
of supplying text

42
00:03:23.950 --> 00:03:29.860 
should influence as many
places as possible

43
00:03:30.250 --> 00:03:33.810 
in the encrypted
cipher type text.

44
00:03:34.500 --> 00:03:38.960 
So the reason is that some minor
change in the plaintext in

45
00:03:38.960 --> 00:03:43.260 
the document will lead to many
changes in the cipher text.

46
00:03:43.690 --> 00:03:48.780 
Imagine the plaintext is a
contract and there is one number

47
00:03:49.220 --> 00:03:53.970 
that one has to pay
for things in online

48
00:03:53.970 --> 00:03:58.360 
shop. So a small change for
example addition is zero

49
00:03:58.980 --> 00:04:02.260 
changes a price, increase
a prize by ten four.

50
00:04:02.580 --> 00:04:05.480 
it's a small change
in the document

51
00:04:05.700 --> 00:04:10.960 
and to avoid that anyone has a
chance to manipulate this.

52
00:04:11.180 --> 00:04:14.650 
A small change will lead
to a lot of changes

53
00:04:14.940 --> 00:04:19.410 
in the cipher text. Another
principle for encryption,

54
00:04:19.600 --> 00:04:22.630 
by the way, not only for one
key encryption is confusion.

55
00:04:23.360 --> 00:04:26.710 
And the principle of computations
sets a connection between

56
00:04:26.710 --> 00:04:31.160 
cipher text and key

57
00:04:31.860 --> 00:04:36.470 
should be as complex as possible
to make interference more

58
00:04:36.470 --> 00:04:39.140 
difficult to make it difficult
for us to be attacked.

59
00:04:39.570 --> 00:04:44.050 
Which have access
to the cipher

60
00:04:44.520 --> 00:04:50.600 
text that they
cannot draw

61
00:04:50.610 --> 00:04:55.850 
some conclusions
about the key. So

62
00:04:56.210 --> 00:05:00.100 
another principle now
is that for one key

63
00:05:00.100 --> 00:05:06.300 
encryption is that they typically
follow around based approach,

64
00:05:06.310 --> 00:05:10.450 
that means to increase the
complexity of the corruption,

65
00:05:11.060 --> 00:05:16.150 
the encryption method is applied
with different parts of the key

66
00:05:16.450 --> 00:05:21.970 
on repeatedly rearrange text. So
there is not only one encryption

67
00:05:22.070 --> 00:05:27.460 
step, but also there are many encryption
steps, many rounds of encryption

68
00:05:27.650 --> 00:05:32.200 
and for each of this round,
different parts of the key is used.

69
00:05:34.630 --> 00:05:38.420 
The first example of a well known
one key encryption method

70
00:05:38.640 --> 00:05:44.190 
let us have a closer look to the
DES, data encryption standard.

71
00:05:44.190 --> 00:05:49.530 
This was the first official
encryption standard used by

72
00:05:49.540 --> 00:05:53.910 
US governments
from 1967.

73
00:05:54.250 --> 00:05:57.650 
Not only by US government
also by other

74
00:05:57.910 --> 00:06:01.360 
governments and was
used as a standard

75
00:06:01.570 --> 00:06:06.000 
on the internet in that
time. But if I look

76
00:06:06.190 --> 00:06:11.490 
at the key length.
the key length is

77
00:06:11.670 --> 00:06:15.370 
56 bit, that can be
freely chosen.

78
00:06:15.750 --> 00:06:18.900 
The key length of
DES is 64 bit.

79
00:06:19.110 --> 00:06:24.640 
But eight bits are used
as a test sequence.

80
00:06:24.860 --> 00:06:28.680 
So fifty six bit could
be chosen a freely

81
00:06:29.160 --> 00:06:33.770 
and then there are two
to the fifty six

82
00:06:34.060 --> 00:06:38.170 
different possible
keys that can

83
00:06:38.170 --> 00:06:44.420 
be formed by zeroes and
ones, by strings of

84
00:06:44.480 --> 00:06:49.000 
zero and ones of length fifty
six. So this number

85
00:06:49.410 --> 00:06:54.460 
is considered much too small because
with a brute force attack.

86
00:06:54.880 --> 00:06:58.730 
And the modern computer it's
possible in a relatively short

87
00:06:58.730 --> 00:07:05.070 
time to test all possible keys
and in this way to find the

88
00:07:05.070 --> 00:07:11.670 
right key. Because this is DES
encryption which was a popular

89
00:07:11.670 --> 00:07:15.420 
and applied it in
many applications,

90
00:07:15.640 --> 00:07:18.770 
and tries to find
modifications.

91
00:07:19.090 --> 00:07:22.210 
So the people first
experimented with

92
00:07:22.500 --> 00:07:28.370 
applying DES two times, but due to
the attack this DES not

93
00:07:28.590 --> 00:07:32.450 
bring it not only increase
the security considerably,

94
00:07:32.590 --> 00:07:35.550 
but the triple DES.

95
00:07:35.960 --> 00:07:40.700 
This works fine with a triple-
DES, it was triple-DES

96
00:07:40.700 --> 00:07:45.210 
encryption one has an
end key length of

97
00:07:45.500 --> 00:07:49.010 
a double length as
the key space

98
00:07:49.290 --> 00:07:53.070 
has an amount of 2 to the
128

99
00:07:53.390 --> 00:07:59.690 
key is and this is well large.
So that's very difficult to

100
00:07:59.890 --> 00:08:04.480 
run a brute force attack
and it's not expected

101
00:08:04.700 --> 00:08:09.340 
it to get it finished in a
short time. In other popular

102
00:08:09.350 --> 00:08:16.830 
one-key encryption the AES, the
advanced encryption standard,

103
00:08:16.830 --> 00:08:20.540 
it came out of
a competition.

104
00:08:20.920 --> 00:08:25.170 
When people saw that
this key length is

105
00:08:25.170 --> 00:08:27.900 
too short and that DES
is no more secure,

106
00:08:28.400 --> 00:08:31.010 
then there was an
international competition

107
00:08:31.370 --> 00:08:36.790 
asking what is the best
successor forces

108
00:08:36.890 --> 00:08:41.420 
DES encryption method?
And the winner is

109
00:08:41.420 --> 00:08:47.780 
AES, it is a method that won
the cryptography competition

110
00:08:47.950 --> 00:08:52.550 
in 2000 and from
that time

111
00:08:52.750 --> 00:08:57.750 
it is deemed as encryption
standard and DES successor.

112
00:09:00.610 --> 00:09:05.470 
The key length of the
AES is 128,

113
00:09:05.690 --> 00:09:11.570 
but there are other variants of sets
a procedure with the key length

114
00:09:11.570 --> 00:09:14.730 
of 192 or 256 bits.

115
00:09:15.080 --> 00:09:19.960 
So that even if after 128 bit

116
00:09:20.140 --> 00:09:26.500 
key lengths are considered
insecure due to a successful

117
00:09:26.500 --> 00:09:31.810 
brute force attacks it's easy
to use the procedure

118
00:09:31.810 --> 00:09:35.430 
also in future but not with
128

119
00:09:35.760 --> 00:09:40.560 
key length, but with the key
of longer lengths, for

120
00:09:40.560 --> 00:09:43.950 
example 192
and 256.

121
00:09:47.010 --> 00:09:50.090 
I've already mentioned this
key exchange problem.

122
00:09:50.380 --> 00:09:53.370 
which is a problem with
all one key encryption

123
00:09:53.810 --> 00:09:58.770 
and the problem consists in
the challenges that before

124
00:09:58.770 --> 00:10:02.990 
communication can be protected by
means of a one key encryption,

125
00:10:03.250 --> 00:10:08.120 
the communication partners must
agree on a common secret key.

126
00:10:09.730 --> 00:10:13.720 
The key cannot be sent
unencrypted over the open internet

127
00:10:13.720 --> 00:10:17.150 
because everyone has access and
if one or if an attacker has

128
00:10:17.150 --> 00:10:22.620 
access to the
encryption key, then

129
00:10:22.820 --> 00:10:27.820 
he can inside in all the communication
between the two partners.

130
00:10:29.300 --> 00:10:35.030 
The key exchange is only mentioned
as a basic problem for

131
00:10:35.030 --> 00:10:40.730 
one-key encryption schemes and
the differences of people's

132
00:10:40.730 --> 00:10:43.640 
though about different

133
00:10:44.110 --> 00:10:47.670 
solutions to this problem. One,

134
00:10:47.950 --> 00:10:52.250 
the solution is the
Diffie-Hellmann key exchange

135
00:10:52.440 --> 00:10:58.440 
protocol is a little bit
going into the direction

136
00:10:58.440 --> 00:11:02.390 
of the two key
encryption or another

137
00:11:02.580 --> 00:11:09.920 
idea is to use two key encryption
methods for exchange

138
00:11:10.060 --> 00:11:14.980 
of the secret
key in order to laid on

139
00:11:15.210 --> 00:11:19.260 
use a one key encryption
methods which are very

140
00:11:19.260 --> 00:11:22.470 
computation
inefficiently

141
00:11:22.650 --> 00:11:25.880 
compared to the two key
encryption methods.

142
00:11:26.790 --> 00:11:31.230 
And this is the right moment to see
what's the difference between

143
00:11:31.230 --> 00:11:34.540 
one key encryption and two key
encryption, what's the basic

144
00:11:34.540 --> 00:11:39.070 
idea behind this two key
encryption which is

145
00:11:39.260 --> 00:11:43.900 
asymmetric, compared to the
symmetric one key encryption

146
00:11:43.900 --> 00:11:48.700 
method. And the main
idea is that,

147
00:11:49.110 --> 00:11:52.530 
it's not a single
key used by the

148
00:11:52.750 --> 00:11:56.630 
sender and by the
receiver. No

149
00:11:57.070 --> 00:12:02.350 
each user of such a user
in two key encryption

150
00:12:02.350 --> 00:12:05.640 
methods needs a
pair of keys,

151
00:12:06.170 --> 00:12:10.290 
a pair of keys that can be used
for encryption and that can

152
00:12:10.290 --> 00:12:16.360 
be used for decryption purposes.
This pair of keys consists

153
00:12:16.360 --> 00:12:21.880 
of a private key and private key
means this key must be kept

154
00:12:21.880 --> 00:12:26.370 
secret from every other
subscriber, also the receiver

155
00:12:26.700 --> 00:12:31.310 
does not know his private key
to private key only stays

156
00:12:31.730 --> 00:12:35.560 
with the user. And besides
the private key

157
00:12:36.220 --> 00:12:40.390 
in the key pair each user
has a so called public key

158
00:12:40.930 --> 00:12:45.590 
and this key is called public because
it should be made available

159
00:12:45.840 --> 00:12:50.070 
for all other participants in
these two key encryption

160
00:12:50.420 --> 00:12:56.600 
an environment. So
all people

161
00:12:56.810 --> 00:13:00.180 
that want to
communicate in a secure way

162
00:13:00.360 --> 00:13:05.960 
with a user needs to be able to access

163
00:13:06.480 --> 00:13:11.630 
his/her public key. So main idea
of two key encryption,

164
00:13:12.060 --> 00:13:17.100 
each user has two keys, a private
key set must be kept secret

165
00:13:17.100 --> 00:13:20.620 
and a public key that can be
distributed allover the world.

166
00:13:21.310 --> 00:13:26.220 
Now the message is
encrypted with a public key

167
00:13:26.850 --> 00:13:32.400 
can only be decrypted with
the associated private key,

168
00:13:33.100 --> 00:13:35.560 
this is a big difference
to the one key,

169
00:13:35.880 --> 00:13:38.380 
so messages encrypted
with a public key

170
00:13:39.120 --> 00:13:44.120 
need for decryption private key
and messages encrypted with

171
00:13:44.120 --> 00:13:49.650 
a private key need for decryption
is the associated public

172
00:13:49.650 --> 00:13:54.370 
key. Now let's have
a closer look how

173
00:13:54.550 --> 00:13:59.690 
we can apply this, it
is very important

174
00:13:59.870 --> 00:14:04.680 
that the private key
and the public key

175
00:14:05.260 --> 00:14:09.770 
cannot be calculated
from each other, so

176
00:14:09.970 --> 00:14:14.020 
the public key is
known to everyone,

177
00:14:14.320 --> 00:14:18.970 
so it should be impossible
to compute the private key

178
00:14:19.330 --> 00:14:21.250 
out of this public key.

179
00:14:24.480 --> 00:14:28.490 
So what are the requirements, I
already mentioned each user

180
00:14:28.680 --> 00:14:32.020 
wants to apply such an two

181
00:14:32.020 --> 00:14:36.790 
key encryption methods
needs a key pair,

182
00:14:37.290 --> 00:14:40.540 
a key pair consisting
of the private key

183
00:14:40.850 --> 00:14:46.320 
which has to stay secret and it's
only known to the user and

184
00:14:46.320 --> 00:14:51.010 
the public key set can be
distributed over all the world.

185
00:14:51.660 --> 00:14:55.990 
The public key must be freely
acceptable for a everyone

186
00:14:56.550 --> 00:15:00.710 
this is very important
that this encryption

187
00:15:00.710 --> 00:15:06.050 
scheme work but, what
needs to be clear

188
00:15:06.050 --> 00:15:10.310 
and in safely
dedicated is

189
00:15:10.590 --> 00:15:15.540 
that the key should be safely
dedicated to its owner.

190
00:15:16.280 --> 00:15:20.680 
So everyone should
be able to see the

191
00:15:20.920 --> 00:15:25.820 
public key, but it must be clear
that the public keys exactly

192
00:15:25.820 --> 00:15:32.790 
the public key of that owner. So
now, let's look for a how to

193
00:15:32.790 --> 00:15:37.530 
encrypt a message， Now to
encrypted a message with the users

194
00:15:37.720 --> 00:15:44.600 
public key. When the message is
a encrypted with users public

195
00:15:44.600 --> 00:15:50.520 
key, the only one who is
possible is the owner of the

196
00:15:50.900 --> 00:15:53.910 
private key, of the
corresponding private key

197
00:15:54.530 --> 00:16:00.540 
and the private key should
never be left in the environment of the

198
00:16:00.630 --> 00:16:08.210 
user, so the idea here if anyone
wants to send our user

199
00:16:08.500 --> 00:16:14.240 
a message, an encrypted
message who nobody can read,

200
00:16:14.690 --> 00:16:20.530 
then what he has to do he has
to choose the public key

201
00:16:20.940 --> 00:16:24.410 
of that user and the
encrypted message with the

202
00:16:24.410 --> 00:16:31.090 
public key. So it's a plaintext
encrypted with a public

203
00:16:31.090 --> 00:16:36.980 
key provides cipher
that's only decryptable

204
00:16:37.240 --> 00:16:41.600 
by the owner of the private key.
And there is only one owner,

205
00:16:41.800 --> 00:16:47.880 
that is a user himself. So the
confidentiality of the

206
00:16:47.900 --> 00:16:52.880 
message can in this way easily
be ensured everyone who wants

207
00:16:52.880 --> 00:16:57.000 
to send a message confidential
methods to user

208
00:16:57.640 --> 00:17:04.210 
takes his or her public key
and encrypts with 2 way key

209
00:17:04.210 --> 00:17:07.940 
encryption method, and this
message and the cipher

210
00:17:08.200 --> 00:17:10.920 
is sent over the open
internet to the user.

211
00:17:11.340 --> 00:17:15.720 
And the user as the owner of
the corresponding private key

212
00:17:16.140 --> 00:17:19.220 
is the only one who can
decrypt this message.

213
00:17:20.850 --> 00:17:24.910 
So encryption of a message
was a user's private key,

214
00:17:25.680 --> 00:17:31.270 
on the other side allows everyone
else to verify that that

215
00:17:31.270 --> 00:17:35.210 
message originated from the sender,
because the sender was only

216
00:17:35.210 --> 00:17:42.350 
one who owns this private key and
to check what was the content

217
00:17:42.660 --> 00:17:48.350 
when the people around can
take the message that was

218
00:17:48.350 --> 00:17:51.250 
encrypted with the
user private key and

219
00:17:51.690 --> 00:17:56.150 
when this is decrypted per
with the users public key

220
00:17:56.340 --> 00:18:00.520 
it is clear that this message
comes from the user.

221
00:18:00.940 --> 00:18:06.080 
Here again our the mathematical
description we have to plaintext,

222
00:18:06.090 --> 00:18:10.060 
the plaintext is encrypted
with a private key,

223
00:18:10.410 --> 00:18:12.570 
the private key
was too long

224
00:18:16.220 --> 00:18:16.930 


225
00:18:22.870 --> 00:18:25.780 
and now by means of
the public key

226
00:18:26.130 --> 00:18:30.730 
which is available to everyone
the cipher text can

227
00:18:30.730 --> 00:18:34.310 
be decrypted into the
original plaintext,

228
00:18:34.620 --> 00:18:39.450 
and we will see
this can be used

229
00:18:39.940 --> 00:18:46.560 
to prove that this message
really comes from the

230
00:18:46.560 --> 00:18:51.640 
sender and that the message
was not modified on the

231
00:18:51.870 --> 00:18:55.910 
ways on the internet. The liability
and the message integrity

232
00:18:56.110 --> 00:18:57.340 
can thus be ensured.

233
00:18:59.400 --> 00:19:04.120 
Precondition for both
procedures, both procedures

234
00:19:04.460 --> 00:19:09.580 
look only if the public
key is not compromised,

235
00:19:09.820 --> 00:19:14.540 
that means it's clear this
public key belongs to the link

236
00:19:14.880 --> 00:19:17.610 
as that this public key
belongs to that user

237
00:19:17.890 --> 00:19:23.490 
is not disturbed and the other
precondition is that private

238
00:19:23.500 --> 00:19:27.770 
key are kept secret.

239
00:19:28.230 --> 00:19:35.050 
So private keys are not
allowed to leave to be known

240
00:19:35.270 --> 00:19:39.950 
to everyoneelse as
of the owner.

241
00:19:41.500 --> 00:19:45.640 
Although there are famous examples
for such two key encryption

242
00:19:45.640 --> 00:19:48.760 
methods and the
most popular

243
00:19:49.050 --> 00:19:53.600 
two key encryption method
used on the Internet is RSA.

244
00:19:53.600 --> 00:19:58.320 
RSA is developed by or
Rivest, Shamir, Aldleman,

245
00:19:58.320 --> 00:20:03.320 
and three scientists and
and the initials they are

246
00:20:03.320 --> 00:20:09.240 
used to describe this procedure
and this is really the most

247
00:20:09.260 --> 00:20:15.040 
web servers use this

248
00:20:15.040 --> 00:20:20.990 
method to secure
connection. RSA also

249
00:20:21.170 --> 00:20:25.770 
supports different key lengths，
nowadays key should be at least

250
00:20:26.040 --> 00:20:29.620 
2048 bits，

251
00:20:29.970 --> 00:20:33.610 
Reason why one insist
on much longer

252
00:20:33.930 --> 00:20:39.550 
keys for such two -key encryption methods
compared

253
00:20:39.550 --> 00:20:43.350 
to the one key encryption
method is， that the

254
00:20:43.720 --> 00:20:49.040 
two-key encryption
methods are based

255
00:20:49.280 --> 00:20:52.780 
on some mathematical problems.
They are not based on shifting

256
00:20:53.070 --> 00:20:58.170 
shuffle the different

257
00:20:58.170 --> 00:21:02.050 
digits, they are based on
a mathematical problem and

258
00:21:02.060 --> 00:21:07.860 
here RSA is based
on the prime factorization

259
00:21:08.170 --> 00:21:13.300 
of large numbers. It is a very
complicated mathematical procedure,

260
00:21:13.630 --> 00:21:17.670 
but there are methods known
that are more efficient

261
00:21:17.890 --> 00:21:23.010 
than brute force for that reason,
the recommendation is that

262
00:21:23.010 --> 00:21:27.650 
RSA is used at
least whose key is

263
00:21:27.910 --> 00:21:32.320 
from at least
2048 bits.

264
00:21:33.940 --> 00:21:38.150 
And we will have a closer look
at this RSA encryption

265
00:21:38.150 --> 00:21:43.650 
method, it is our excursion in this
week, you are invited to see this.

266
00:21:43.650 --> 00:21:48.270 
We will apply it
in a very simple

267
00:21:48.280 --> 00:21:51.710 
example, because it is
quite complicated

268
00:21:51.970 --> 00:21:59.240 
as all these two key encryption
methods. So now we have learned

269
00:21:59.600 --> 00:22:03.340 
on the one side the one-key encryption
methods, which are very efficient

270
00:22:03.340 --> 00:22:07.090 
versus shuffling around a
bit, but it was a big

271
00:22:07.290 --> 00:22:10.900 
the problem of key exchange at the
beginning of the communication.

272
00:22:11.330 --> 00:22:15.450 
And we have on the other side,
the two key encryption methods

273
00:22:15.800 --> 00:22:20.820 
which have no problems with the
key exchange problem,

274
00:22:21.300 --> 00:22:25.790 
but which are much
less efficient than

275
00:22:26.080 --> 00:22:30.170 
the one key encryption
methods. And exactly,

276
00:22:30.380 --> 00:22:36.080 
this is the idea to create so
called hybrid encryptions.

277
00:22:37.040 --> 00:22:41.260 
Hybrid encryption methods
combine advantages of one

278
00:22:41.520 --> 00:22:46.740 
and two key encryption methods for
compensating their disadvantages.

279
00:22:48.260 --> 00:22:51.400 
And why in such a
combination is useful?

280
00:22:51.580 --> 00:22:55.290 
I mention already one key
encryption are very efficient, but

281
00:22:55.300 --> 00:22:58.330 
require safe exchange
of the secret key.

282
00:22:58.910 --> 00:23:04.220 
And two-key encryption does not
require a secure a key exchange

283
00:23:04.480 --> 00:23:09.070 
but it's very complex to calculate
and therefore not suitable

284
00:23:09.170 --> 00:23:15.670 
for example for a large amount of
data. Hybrid methods combine

285
00:23:15.840 --> 00:23:18.300 
the efficiency of one
key encryption method

286
00:23:18.490 --> 00:23:22.880 
with the initial security of
two-key encryption methods.

287
00:23:23.780 --> 00:23:28.670 
What are the working principles?
So communication partners

288
00:23:28.910 --> 00:23:31.620 
in case of using such
an hybird encryption,

289
00:23:31.950 --> 00:23:38.300 
they agree on one key method
X, a two-key encryption method

290
00:23:38.300 --> 00:23:45.220 
to Y and then they start. So the
sender generates a random

291
00:23:45.220 --> 00:23:51.140 
secret session key, S for later
or application of the 1- key

292
00:23:51.140 --> 00:23:56.230 
encryption method. Then by means
of a two encryption methods

293
00:23:56.230 --> 00:24:02.420 
Y secession key as is encrypted
with a public key of the receiver.

294
00:24:02.910 --> 00:24:06.960 
With the public key of the receiver
and then the cipher is sent

295
00:24:07.010 --> 00:24:13.390 
to the receiver. The receiver is able
to decrypt the received session

296
00:24:13.390 --> 00:24:16.480 
key by means of his
private key. Because

297
00:24:16.680 --> 00:24:21.650 
it was encrypted by
his public key

298
00:24:22.280 --> 00:24:24.350 
and now the sender as well as the receiver
have the session key.
