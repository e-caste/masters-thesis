WEBVTT

1
00:00:00.540 --> 00:00:02.399 
Welcome to our Future in

2
00:00:02.400 --> 00:00:04.179 
Computing - POWER9 and beyond

3
00:00:05.730 --> 00:00:06.730 
MOOC.

4
00:00:06.810 --> 00:00:08.669 
So we are talking today about the

5
00:00:08.670 --> 00:00:10.529 
server OS perspective

6
00:00:10.530 --> 00:00:12.569 
on big systems,

7
00:00:12.570 --> 00:00:14.009 
on server systems.

8
00:00:14.010 --> 00:00:16.109 
And but let us start

9
00:00:16.110 --> 00:00:18.299 
with digitalization,

10
00:00:18.300 --> 00:00:20.399 
it's a term that

11
00:00:20.400 --> 00:00:22.469 
is exciting for many people

12
00:00:22.470 --> 00:00:24.419 
today and

13
00:00:24.420 --> 00:00:26.369 
which indicates a

14
00:00:26.370 --> 00:00:28.739 
change in IT as well.

15
00:00:28.740 --> 00:00:30.119 
On one hand side, we have the

16
00:00:30.120 --> 00:00:31.889 
traditional systems, the systems of

17
00:00:31.890 --> 00:00:34.079 
record, where we see transaction

18
00:00:34.080 --> 00:00:36.599 
processing and structured data,

19
00:00:36.600 --> 00:00:37.799 
where we have imperative

20
00:00:37.800 --> 00:00:39.269 
programming, where we typically

21
00:00:39.270 --> 00:00:41.039 
understand what's going on, where

22
00:00:41.040 --> 00:00:43.079 
emphasis is put on reliability

23
00:00:43.080 --> 00:00:46.019 
and availability and serviceability.

24
00:00:46.020 --> 00:00:47.909 
And on the other side, we

25
00:00:47.910 --> 00:00:49.889 
have the so-called Systems of

26
00:00:49.890 --> 00:00:51.383 
Engagement or the new IT.

27
00:00:52.530 --> 00:00:54.419 
And often times, we

28
00:00:54.420 --> 00:00:56.519 
have here unstructured

29
00:00:56.520 --> 00:00:58.829 
data. In fact, people are explaining

30
00:00:58.830 --> 00:01:00.779 
that unstructured data like sensor

31
00:01:00.780 --> 00:01:03.599 
data is growing exponentially

32
00:01:03.600 --> 00:01:05.669 
and much faster than traditional

33
00:01:05.670 --> 00:01:06.670 
structured data.

34
00:01:07.530 --> 00:01:09.719 
With the new I.T., you have

35
00:01:09.720 --> 00:01:11.609 
approaches like machine learning and

36
00:01:11.610 --> 00:01:14.249 
deep neural networks, and

37
00:01:14.250 --> 00:01:15.899 
the results are fascinating, but

38
00:01:15.900 --> 00:01:16.919 
they come at a price.

39
00:01:16.920 --> 00:01:18.869 
It is very difficult to predict

40
00:01:18.870 --> 00:01:20.879 
system behaviour in that

41
00:01:20.880 --> 00:01:22.619 
kind of new I.T.

42
00:01:22.620 --> 00:01:25.229 
So the challenges

43
00:01:25.230 --> 00:01:27.329 
for us in server computing

44
00:01:27.330 --> 00:01:29.969 
today are how to bridge

45
00:01:29.970 --> 00:01:31.649 
between both worlds.

46
00:01:31.650 --> 00:01:33.539 
And this is a little

47
00:01:33.540 --> 00:01:36.389 
bit the theme of the entire

48
00:01:36.390 --> 00:01:37.439 
online course.

49
00:01:37.440 --> 00:01:39.459 
And in the beginning, we want

50
00:01:39.460 --> 00:01:41.329 
to focus

51
00:01:41.330 --> 00:01:43.849 
on the traditional features

52
00:01:43.850 --> 00:01:45.712 
and qualities of server systems.

53
00:01:47.540 --> 00:01:49.429 
Server systems, one example, we have

54
00:01:49.430 --> 00:01:51.650 
in our lab, this is the IBM

55
00:01:52.760 --> 00:01:53.974 
POWER8 system, and E880,

56
00:01:55.130 --> 00:01:56.959 
huge computer with

57
00:01:56.960 --> 00:01:58.807 
plenty of memory and many cores.

58
00:02:01.170 --> 00:02:03.689 
So what is the motivation for

59
00:02:03.690 --> 00:02:05.189 
building that kind of systems?

60
00:02:06.500 --> 00:02:07.669 
And there's a number of

61
00:02:08.990 --> 00:02:11.419 
features and properties

62
00:02:11.420 --> 00:02:12.420 
and

63
00:02:13.350 --> 00:02:15.599 
, like capacity or scalability,

64
00:02:15.600 --> 00:02:18.059 
like the integrity and security,

65
00:02:18.060 --> 00:02:19.919 
terms like availability, you

66
00:02:19.920 --> 00:02:21.599 
want to access large amounts of

67
00:02:21.600 --> 00:02:24.029 
data, you have systems management

68
00:02:24.030 --> 00:02:26.909 
and you have autonomic capabilities.

69
00:02:26.910 --> 00:02:29.879 
All these terms apply to servers,

70
00:02:29.880 --> 00:02:31.889 
but do not typically apply

71
00:02:31.890 --> 00:02:33.269 
to your notebook computer or your

72
00:02:33.270 --> 00:02:34.949 
desktop computer.

73
00:02:34.950 --> 00:02:37.629 
And what does it mean

74
00:02:37.630 --> 00:02:38.849 
in detail?

75
00:02:38.850 --> 00:02:41.279 
This capacity, you talk about

76
00:02:41.280 --> 00:02:43.229 
the potential for holding

77
00:02:43.230 --> 00:02:45.119 
and storing sufficient

78
00:02:45.120 --> 00:02:46.979 
disk storage or to

79
00:02:46.980 --> 00:02:48.899 
have a long term

80
00:02:48.900 --> 00:02:50.279 
storage media like tape.

81
00:02:50.280 --> 00:02:52.559 
It's also that you have

82
00:02:52.560 --> 00:02:54.719 
storage management that you know

83
00:02:54.720 --> 00:02:56.699 
when to delete

84
00:02:56.700 --> 00:02:58.709 
and when to get rid

85
00:02:58.710 --> 00:03:01.379 
of data that is no longer used.

86
00:03:01.380 --> 00:03:03.329 
It's also the simple question of our

87
00:03:03.330 --> 00:03:05.159 
lifetime of storage media.

88
00:03:05.160 --> 00:03:07.259 
So if you look at your PC

89
00:03:07.260 --> 00:03:09.719 
and the CD, for instance,

90
00:03:09.720 --> 00:03:11.099 
then this particular storage media

91
00:03:11.100 --> 00:03:11.939 
has a lifetime.

92
00:03:11.940 --> 00:03:14.879 
And this capacity

93
00:03:14.880 --> 00:03:16.919 
you address all these aspects,

94
00:03:16.920 --> 00:03:19.079 
you also address the

95
00:03:19.080 --> 00:03:21.239 
power to produce and

96
00:03:21.240 --> 00:03:23.189 
perform and deploy or

97
00:03:23.190 --> 00:03:24.659 
process data.

98
00:03:24.660 --> 00:03:25.739 
So you want to have sufficient

99
00:03:25.740 --> 00:03:28.139 
computing capacity to run

100
00:03:28.140 --> 00:03:29.879 
the programs that are critical for

101
00:03:29.880 --> 00:03:30.880 
your environment.

102
00:03:33.820 --> 00:03:35.439 
The next thing is

103
00:03:36.640 --> 00:03:38.319 
service level agreement, service

104
00:03:38.320 --> 00:03:40.239 
level agreement is basically

105
00:03:40.240 --> 00:03:42.459 
the fact that at some point

106
00:03:42.460 --> 00:03:44.439 
the technical solution has to give

107
00:03:44.440 --> 00:03:46.779 
up, there will be no perfect

108
00:03:46.780 --> 00:03:48.999 
technical solution whatsoever.

109
00:03:49.000 --> 00:03:50.829 
But there is an agreement between

110
00:03:50.830 --> 00:03:52.569 
the service provider and the

111
00:03:52.570 --> 00:03:54.759 
recipient where

112
00:03:54.760 --> 00:03:56.799 
the service provider tells, "I

113
00:03:56.800 --> 00:03:58.629 
will complete

114
00:03:58.630 --> 00:04:00.789 
so many transactions in a given time

115
00:04:00.790 --> 00:04:02.799 
or I will deliver so many

116
00:04:02.800 --> 00:04:04.959 
reports by 6:00

117
00:04:04.960 --> 00:04:06.069 
a.m".

118
00:04:06.070 --> 00:04:08.199 
And what if the

119
00:04:08.200 --> 00:04:10.449 
promise is not kept?

120
00:04:10.450 --> 00:04:12.939 
That's the case where the lawyer

121
00:04:12.940 --> 00:04:15.519 
steps in, where the technicians

122
00:04:15.520 --> 00:04:18.039 
are basically out of the picture

123
00:04:18.040 --> 00:04:20.199 
and having SLA

124
00:04:20.200 --> 00:04:21.699 
is having service level agreements

125
00:04:21.700 --> 00:04:23.619 
is also specific for

126
00:04:23.620 --> 00:04:24.620 
server computing.

127
00:04:26.350 --> 00:04:28.569 
If you want to run your systems

128
00:04:28.570 --> 00:04:30.429 
all the time, you still

129
00:04:30.430 --> 00:04:32.079 
need to do software update.

130
00:04:32.080 --> 00:04:34.239 
You need to change hardware

131
00:04:34.240 --> 00:04:35.019 
components.

132
00:04:35.020 --> 00:04:36.399 
You need to have maintenance

133
00:04:36.400 --> 00:04:37.269 
windows.

134
00:04:37.270 --> 00:04:39.219 
So you need to plan for downtime,

135
00:04:39.220 --> 00:04:41.529 
which means continuity

136
00:04:41.530 --> 00:04:43.419 
can only be achieved if

137
00:04:43.420 --> 00:04:46.149 
you have multiple instances

138
00:04:46.150 --> 00:04:48.009 
of machines

139
00:04:48.010 --> 00:04:50.109 
or storage in order to run

140
00:04:50.110 --> 00:04:51.160 
the critical workload.

141
00:04:52.220 --> 00:04:54.199 
It's also the question of when to

142
00:04:54.200 --> 00:04:55.909 
take down a system.

143
00:04:55.910 --> 00:04:58.909 
So a scheduled downtime

144
00:04:58.910 --> 00:05:01.369 
should make it possible to meet

145
00:05:01.370 --> 00:05:02.839 
SLAs from the remaining systems.

146
00:05:04.630 --> 00:05:07.659 
Scalability, this is the question of

147
00:05:07.660 --> 00:05:09.549 
whether a bigger computer will

148
00:05:09.550 --> 00:05:10.930 
solve bigger problems.

149
00:05:12.280 --> 00:05:14.439 
What we see here is actually a graph

150
00:05:14.440 --> 00:05:15.999 
that demonstrates some of the

151
00:05:16.000 --> 00:05:18.159 
difficulties of building scalable

152
00:05:18.160 --> 00:05:19.299 
solutions.

153
00:05:19.300 --> 00:05:21.399 
What we see here is the execution

154
00:05:21.400 --> 00:05:23.469 
time plotted

155
00:05:23.470 --> 00:05:24.939 
of a simple program.

156
00:05:24.940 --> 00:05:27.249 
This is an algorithm that

157
00:05:27.250 --> 00:05:29.289 
does edge detection and pictures,

158
00:05:29.290 --> 00:05:31.239 
basically, and it is run on

159
00:05:31.240 --> 00:05:33.339 
a huge Silicon

160
00:05:33.340 --> 00:05:35.679 
Graphics computer

161
00:05:35.680 --> 00:05:38.579 
that consists of 16

162
00:05:38.580 --> 00:05:40.089 
sockets. These sockets are organized

163
00:05:40.090 --> 00:05:42.189 
in units of four

164
00:05:42.190 --> 00:05:44.289 
and each socket,

165
00:05:44.290 --> 00:05:46.239 
the host processor

166
00:05:46.240 --> 00:05:47.739 
with 15 cores.

167
00:05:47.740 --> 00:05:49.989 
So what we see here is the naive

168
00:05:49.990 --> 00:05:51.540 
solution of

169
00:05:52.660 --> 00:05:54.669 
parallelising will indeed give

170
00:05:54.670 --> 00:05:56.139 
you performance boost.

171
00:05:56.140 --> 00:05:58.419 
So the more cores you use,

172
00:05:58.420 --> 00:06:00.429 
the lower the execution time

173
00:06:00.430 --> 00:06:02.799 
until you reach that point.

174
00:06:02.800 --> 00:06:05.019 
And this is where you have utilized

175
00:06:05.020 --> 00:06:07.479 
these 60 cores that are available

176
00:06:07.480 --> 00:06:09.789 
in one blade, basically.

177
00:06:09.790 --> 00:06:11.709 
Then you need to go to the next

178
00:06:11.710 --> 00:06:13.539 
blade and this gives you

179
00:06:13.540 --> 00:06:15.579 
such a performance

180
00:06:15.580 --> 00:06:17.799 
hit that you never recover

181
00:06:17.800 --> 00:06:19.779 
from it. So using

182
00:06:19.780 --> 00:06:21.819 
more than the

183
00:06:21.820 --> 00:06:23.679 
sockets in the blade will

184
00:06:23.680 --> 00:06:26.109 
lead to not a performance

185
00:06:26.110 --> 00:06:27.789 
increase, but to decrease.

186
00:06:28.800 --> 00:06:31.239 
We see that NUMA of our programming,

187
00:06:31.240 --> 00:06:33.129 
which means placing the data

188
00:06:33.130 --> 00:06:35.469 
close to the processors

189
00:06:35.470 --> 00:06:37.569 
will give you a constant performance

190
00:06:37.570 --> 00:06:39.879 
increase, even

191
00:06:39.880 --> 00:06:41.769 
using more than

192
00:06:41.770 --> 00:06:43.389 
60 cores.

193
00:06:43.390 --> 00:06:45.429 
However, you do even

194
00:06:45.430 --> 00:06:47.469 
better if you run your program

195
00:06:47.470 --> 00:06:49.479 
as a distributed algorithm using

196
00:06:49.480 --> 00:06:50.409 
MPI.

197
00:06:50.410 --> 00:06:52.449 
So this is a very

198
00:06:52.450 --> 00:06:54.369 
significant picture which

199
00:06:54.370 --> 00:06:56.289 
tells that scalability

200
00:06:56.290 --> 00:06:57.790 
is workload dependent.

201
00:06:59.700 --> 00:07:01.499 
Next feature for service computing

202
00:07:01.500 --> 00:07:02.759 
or server computing.

203
00:07:02.760 --> 00:07:04.559 
This is integrity and security,

204
00:07:04.560 --> 00:07:06.809 
which means data security like

205
00:07:06.810 --> 00:07:08.759 
access controls

206
00:07:08.760 --> 00:07:11.129 
and protection against

207
00:07:11.130 --> 00:07:13.439 
unauthorized access.

208
00:07:13.440 --> 00:07:15.339 
Simple, you would say, but for

209
00:07:15.340 --> 00:07:17.189 
a server system, you want to be

210
00:07:17.190 --> 00:07:19.259 
able to define templates

211
00:07:19.260 --> 00:07:21.180 
and to talk about security

212
00:07:22.350 --> 00:07:24.479 
measures for users

213
00:07:24.480 --> 00:07:26.160 
that you don't even know today.

214
00:07:27.880 --> 00:07:29.769 
Also, you have to implement

215
00:07:29.770 --> 00:07:32.319 
policies and you have to have people

216
00:07:32.320 --> 00:07:34.539 
who are in charge of it.

217
00:07:34.540 --> 00:07:36.459 
So you want to have system

218
00:07:36.460 --> 00:07:38.409 
provided interfaces to

219
00:07:38.410 --> 00:07:40.239 
enforce the authority

220
00:07:40.240 --> 00:07:41.240 
rules.

221
00:07:42.850 --> 00:07:44.799 
The next important feature is

222
00:07:44.800 --> 00:07:46.778 
called RAS.

223
00:07:46.779 --> 00:07:48.399 
RAS stands for reliability,

224
00:07:48.400 --> 00:07:50.483 
availability and serviceability, it

225
00:07:50.484 --> 00:07:52.389 
means basically remaining

226
00:07:52.390 --> 00:07:53.679 
in service all the time.

227
00:07:54.690 --> 00:07:56.639 
And that means

228
00:07:56.640 --> 00:07:58.739 
that your components should have

229
00:07:58.740 --> 00:08:01.229 
self-checking and self-recovery

230
00:08:01.230 --> 00:08:03.180 
features you want to have.

231
00:08:05.160 --> 00:08:06.989 
That a system can recover from a

232
00:08:06.990 --> 00:08:09.419 
failed component without impacting

233
00:08:09.420 --> 00:08:11.549 
the remainder of the system

234
00:08:11.550 --> 00:08:13.709 
and with serviceability,

235
00:08:13.710 --> 00:08:15.659 
you mean that you want to have

236
00:08:15.660 --> 00:08:17.579 
units of replacement and hardware

237
00:08:17.580 --> 00:08:20.639 
or/and software that can easily

238
00:08:20.640 --> 00:08:21.640 
be exchanged.

239
00:08:25.210 --> 00:08:27.219 
Often times, servers need to access

240
00:08:27.220 --> 00:08:29.829 
large amounts of data, which means

241
00:08:29.830 --> 00:08:31.569 
you need to be able to store the

242
00:08:31.570 --> 00:08:33.548 
data and you need to be able

243
00:08:33.549 --> 00:08:35.049 
to process the data.

244
00:08:36.150 --> 00:08:38.019 
And in between there is the

245
00:08:38.020 --> 00:08:40.389 
transfer of data, which brings

246
00:08:40.390 --> 00:08:41.390 
you to the

247
00:08:42.280 --> 00:08:44.409 
bottom line that for

248
00:08:44.410 --> 00:08:46.239 
large amounts of data, the bandwidth

249
00:08:46.240 --> 00:08:47.169 
is crucial.

250
00:08:47.170 --> 00:08:49.059 
Often times you have systems

251
00:08:49.060 --> 00:08:50.110 
with many disks

252
00:08:51.130 --> 00:08:52.659 
in order to achieve sufficient

253
00:08:52.660 --> 00:08:54.314 
bandwidth in the I/O system.

254
00:08:55.900 --> 00:08:58.329 
And finally, systems management,

255
00:08:58.330 --> 00:09:00.579 
this is a collection of disciplines

256
00:09:00.580 --> 00:09:02.229 
to monitor and control systems

257
00:09:02.230 --> 00:09:03.230 
behaviour.

258
00:09:04.910 --> 00:09:06.859 
Systems management is crucial,

259
00:09:06.860 --> 00:09:08.809 
and sometimes

260
00:09:08.810 --> 00:09:10.309 
people think that autonomic

261
00:09:10.310 --> 00:09:11.310 
capabilities

262
00:09:12.890 --> 00:09:15.469 
could replace the human

263
00:09:15.470 --> 00:09:17.449 
operator, that works well

264
00:09:17.450 --> 00:09:18.469 
to a certain extent.

265
00:09:18.470 --> 00:09:20.149 
But in the end, you need to have

266
00:09:20.150 --> 00:09:22.399 
good people for doing systems

267
00:09:22.400 --> 00:09:23.400 
management.

268
00:09:24.980 --> 00:09:27.019 
So these are desirable

269
00:09:27.020 --> 00:09:28.689 
features for service systems.

270
00:09:28.690 --> 00:09:30.589 
Now let's look at a

271
00:09:30.590 --> 00:09:32.779 
number of challenges, challenges

272
00:09:32.780 --> 00:09:33.979 
that come from today's

273
00:09:33.980 --> 00:09:36.139 
infrastructures and from

274
00:09:36.140 --> 00:09:37.969 
use-case scenarios that we see in

275
00:09:37.970 --> 00:09:40.070 
server computing nowadays.

276
00:09:41.600 --> 00:09:43.609 
One challenge as first

277
00:09:43.610 --> 00:09:46.099 
challenge, I want to refer to our

278
00:09:46.100 --> 00:09:48.349 
European project called

279
00:09:48.350 --> 00:09:49.369 
SSICLOPS - Secure and Scalable

280
00:09:49.370 --> 00:09:51.439 
Infrastructure for Cloud Operations.

281
00:09:51.440 --> 00:09:53.509 
And it's very simple.

282
00:09:53.510 --> 00:09:55.069 
It's a resource management question.

283
00:09:55.070 --> 00:09:56.659 
If you place a computation, should

284
00:09:56.660 --> 00:09:57.889 
you place it here?

285
00:09:57.890 --> 00:09:59.689 
Why should you rather use the entire

286
00:09:59.690 --> 00:10:00.979 
rack over there?

287
00:10:00.980 --> 00:10:02.509 
Should you access the data which is

288
00:10:02.510 --> 00:10:04.429 
stored here, or should you be

289
00:10:04.430 --> 00:10:05.749 
able to access the data in a

290
00:10:05.750 --> 00:10:06.973 
different cloud data center

291
00:10:08.300 --> 00:10:09.300 
that is remote?

292
00:10:10.400 --> 00:10:11.809 
What are the implications on

293
00:10:11.810 --> 00:10:13.309 
bandwidth?

294
00:10:13.310 --> 00:10:14.929 
What are the implications on

295
00:10:16.040 --> 00:10:18.679 
the consistency model if you have

296
00:10:18.680 --> 00:10:20.809 
failover scenarios?

297
00:10:20.810 --> 00:10:23.029 
So this needs to be addressed

298
00:10:23.030 --> 00:10:24.919 
and often times people

299
00:10:24.920 --> 00:10:26.869 
think that traffic and

300
00:10:26.870 --> 00:10:28.729 
network protocols, this

301
00:10:28.730 --> 00:10:30.619 
is old stuff that has been

302
00:10:30.620 --> 00:10:32.449 
invented a long time ago,

303
00:10:32.450 --> 00:10:33.859 
20 years or so.

304
00:10:33.860 --> 00:10:35.749 
But turns out there are new kids

305
00:10:35.750 --> 00:10:37.556 
on the block, like the QUIC

306
00:10:37.557 --> 00:10:39.709 
protocol, for instance, that is used

307
00:10:39.710 --> 00:10:42.649 
and defined by Google,

308
00:10:42.650 --> 00:10:43.999 
which basically has the idea of

309
00:10:44.000 --> 00:10:46.249 
implementing part of the TCP IP

310
00:10:46.250 --> 00:10:48.739 
in user space

311
00:10:48.740 --> 00:10:50.989 
and user mode so that

312
00:10:50.990 --> 00:10:53.239 
the multiplexing can

313
00:10:53.240 --> 00:10:55.189 
be done a lot quicker and a lot

314
00:10:55.190 --> 00:10:56.190 
faster.

315
00:10:57.920 --> 00:10:59.749 
A significant amount of the traffic

316
00:10:59.750 --> 00:11:01.699 
to Google's servers already is

317
00:11:01.700 --> 00:11:04.189 
talking QUIC, and

318
00:11:04.190 --> 00:11:06.439 
most of the people haven't

319
00:11:06.440 --> 00:11:07.919 
even heard about it.

320
00:11:07.920 --> 00:11:10.579 
It hasn't yet standardized.

321
00:11:10.580 --> 00:11:12.829 
So this is one of the surprises

322
00:11:12.830 --> 00:11:14.749 
in the network community and

323
00:11:14.750 --> 00:11:16.489 
similar things happen in the other

324
00:11:16.490 --> 00:11:17.719 
areas as well.

325
00:11:17.720 --> 00:11:18.720 
So

326
00:11:19.550 --> 00:11:21.679 
cloud computing does not only mean

327
00:11:23.510 --> 00:11:24.919 
bringing up computers and data

328
00:11:24.920 --> 00:11:27.199 
centers, but also means developing

329
00:11:27.200 --> 00:11:29.119 
new protocols, developing new

330
00:11:29.120 --> 00:11:31.069 
resource management schemes

331
00:11:31.070 --> 00:11:32.899 
and caring about

332
00:11:32.900 --> 00:11:34.340 
energy management and the like.

333
00:11:36.910 --> 00:11:38.739 
The next challenge, this is to

334
00:11:38.740 --> 00:11:40.869 
change from hardware to software,

335
00:11:40.870 --> 00:11:42.699 
so if you look at ultra-dependable

336
00:11:42.700 --> 00:11:45.249 
systems, then often times

337
00:11:45.250 --> 00:11:47.019 
if the costs of failure are in the

338
00:11:47.020 --> 00:11:48.789 
millions, then you go for the

339
00:11:48.790 --> 00:11:49.869 
mainframe. Right.

340
00:11:49.870 --> 00:11:51.699 
The mainframe is the system

341
00:11:51.700 --> 00:11:54.069 
with zero downtime and

342
00:11:54.070 --> 00:11:55.929 
there are about 5000 systems

343
00:11:55.930 --> 00:11:56.919 
on the planet.

344
00:11:56.920 --> 00:11:59.469 
This number remains stable.

345
00:11:59.470 --> 00:12:01.299 
And in other use

346
00:12:01.300 --> 00:12:03.279 
cases, you look for alternative

347
00:12:03.280 --> 00:12:04.280 
solutions

348
00:12:05.650 --> 00:12:07.719 
.The solution works well

349
00:12:07.720 --> 00:12:08.720 
if

350
00:12:11.080 --> 00:12:12.639 
tolerance, disaster tolerance,

351
00:12:12.640 --> 00:12:15.189 
reliability does not come

352
00:12:15.190 --> 00:12:16.779 
at first priority.

353
00:12:16.780 --> 00:12:18.219 
If you look at high performance

354
00:12:18.220 --> 00:12:20.769 
computing solutions, for instance,

355
00:12:20.770 --> 00:12:23.229 
then software solutions are

356
00:12:23.230 --> 00:12:26.289 
applied in the big data centers.

357
00:12:26.290 --> 00:12:28.269 
Now with future

358
00:12:28.270 --> 00:12:30.369 
server computing, with also

359
00:12:30.370 --> 00:12:32.319 
cloud data centers, you

360
00:12:32.320 --> 00:12:34.239 
want to combine both

361
00:12:34.240 --> 00:12:35.980 
worlds. You want to be able to run a

362
00:12:35.981 --> 00:12:37.869 
software-defined environment

363
00:12:37.870 --> 00:12:39.849 
but achieve the

364
00:12:39.850 --> 00:12:41.979 
dependability measures

365
00:12:41.980 --> 00:12:43.839 
or dependability as it

366
00:12:43.840 --> 00:12:45.249 
used to be in the hardware

367
00:12:45.250 --> 00:12:46.250 
solutions.

368
00:12:48.840 --> 00:12:51.809 
Systems look differently,

369
00:12:51.810 --> 00:12:53.729 
did not only look differently

370
00:12:53.730 --> 00:12:55.079 
from the outside, but also

371
00:12:55.080 --> 00:12:56.039 
internally.

372
00:12:56.040 --> 00:12:57.869 
You do have

373
00:12:57.870 --> 00:12:59.699 
the CPU, but you

374
00:12:59.700 --> 00:13:01.559 
also have accelerators like an

375
00:13:01.560 --> 00:13:03.779 
FPGA or

376
00:13:03.780 --> 00:13:05.729 
you have within the same

377
00:13:05.730 --> 00:13:07.799 
processor, within the same

378
00:13:07.800 --> 00:13:09.719 
socket, you have cores that

379
00:13:09.720 --> 00:13:11.669 
are low power, others that are high

380
00:13:11.670 --> 00:13:13.709 
power. So if you go

381
00:13:13.710 --> 00:13:15.239 
and look at your mobile phone,

382
00:13:15.240 --> 00:13:17.789 
chances are that this is a multicore

383
00:13:17.790 --> 00:13:19.979 
which has low power chip,

384
00:13:19.980 --> 00:13:21.719 
low power cores that are being used

385
00:13:21.720 --> 00:13:23.579 
during sleep and high

386
00:13:23.580 --> 00:13:25.649 
powered cores that are being used

387
00:13:25.650 --> 00:13:27.449 
during operation.

388
00:13:27.450 --> 00:13:29.699 
The truth is the Linux inside

389
00:13:29.700 --> 00:13:31.739 
your phone is

390
00:13:31.740 --> 00:13:34.139 
not able to deal with processors

391
00:13:34.140 --> 00:13:35.239 
of different power.

392
00:13:35.240 --> 00:13:37.019 
So they have different operation

393
00:13:37.020 --> 00:13:38.939 
modes, either using all

394
00:13:38.940 --> 00:13:41.069 
the low power cores or using

395
00:13:41.070 --> 00:13:43.009 
all the high power cores,

396
00:13:43.010 --> 00:13:44.940 
another field of open research.

397
00:13:45.990 --> 00:13:48.089 
And then you have certain

398
00:13:48.090 --> 00:13:49.202 
server chips like the POWER9

399
00:13:50.280 --> 00:13:52.109 
where there are

400
00:13:52.110 --> 00:13:54.209 
on-chip acceleration units for

401
00:13:54.210 --> 00:13:55.799 
crypto, for

402
00:13:57.150 --> 00:14:00.179 
communication with

403
00:14:00.180 --> 00:14:02.339 
external environments like GPUs,

404
00:14:02.340 --> 00:14:04.469 
like accelerators

405
00:14:04.470 --> 00:14:05.850 
for implementing

406
00:14:07.350 --> 00:14:09.509 
cache coherency protocols across

407
00:14:09.510 --> 00:14:10.739 
nodes.

408
00:14:10.740 --> 00:14:13.079 
So that's another trend.

409
00:14:13.080 --> 00:14:15.509 
So processors are getting diverse.

410
00:14:15.510 --> 00:14:16.859 
They are diverse in terms of

411
00:14:16.860 --> 00:14:18.269 
computer architecture, instruction

412
00:14:18.270 --> 00:14:19.409 
set architecture.

413
00:14:19.410 --> 00:14:21.449 
They are also diverse in terms of

414
00:14:21.450 --> 00:14:23.130 
having additional functional units.

415
00:14:24.400 --> 00:14:25.719 
If you look at these functional

416
00:14:25.720 --> 00:14:28.389 
units, then bandwidth

417
00:14:28.390 --> 00:14:29.559 
is crucial.

418
00:14:29.560 --> 00:14:31.509 
So, for instance, one of

419
00:14:31.510 --> 00:14:33.579 
these DGX-1 systems

420
00:14:33.580 --> 00:14:35.439 
from nVidia, they

421
00:14:35.440 --> 00:14:37.449 
would be depicted like this one you

422
00:14:37.450 --> 00:14:38.919 
have the NVLink, which gives you

423
00:14:38.920 --> 00:14:41.559 
high bandwidth for communication

424
00:14:41.560 --> 00:14:43.569 
among GPUs,

425
00:14:43.570 --> 00:14:45.999 
but you still have the CPU

426
00:14:46.000 --> 00:14:47.919 
connected to all these high

427
00:14:47.920 --> 00:14:50.019 
powered GPUs using

428
00:14:50.020 --> 00:14:51.999 
PCI Express, which

429
00:14:52.000 --> 00:14:54.129 
has significantly lower bandwidth.

430
00:14:54.130 --> 00:14:56.889 
Not only that, it also

431
00:14:56.890 --> 00:14:58.629 
breaks the picture of having a

432
00:14:58.630 --> 00:15:00.789 
single unified address

433
00:15:00.790 --> 00:15:03.009 
space for your processes.

434
00:15:03.010 --> 00:15:04.010 
So,

435
00:15:05.310 --> 00:15:07.169 
this is the new world

436
00:15:07.170 --> 00:15:09.449 
of accelerators and

437
00:15:09.450 --> 00:15:11.459 
GPUs and the research question

438
00:15:11.460 --> 00:15:14.339 
is how can you create a unified

439
00:15:14.340 --> 00:15:16.769 
view on all these devices?

440
00:15:16.770 --> 00:15:18.479 
It's also the question of we are

441
00:15:18.480 --> 00:15:20.399 
currently reinventing the wheel.

442
00:15:21.400 --> 00:15:23.369 
There are many solutions that had

443
00:15:23.370 --> 00:15:25.169 
been implemented in older systems

444
00:15:25.170 --> 00:15:27.749 
and are kind of forgotten,

445
00:15:27.750 --> 00:15:29.669 
like, for instance, the Resource

446
00:15:29.670 --> 00:15:32.099 
Access Control Framework, which is

447
00:15:32.100 --> 00:15:33.779 
an environment where you can create

448
00:15:33.780 --> 00:15:36.269 
templates for security

449
00:15:36.270 --> 00:15:38.189 
properties of objects that are not

450
00:15:38.190 --> 00:15:40.499 
even defined and not even created

451
00:15:40.500 --> 00:15:42.449 
yet, or like

452
00:15:42.450 --> 00:15:43.829 
the OpenVMS, where you had a

453
00:15:43.830 --> 00:15:45.359 
versioning file system.

454
00:15:45.360 --> 00:15:47.219 
People nowadays, they use GitHub

455
00:15:47.220 --> 00:15:49.349 
and other solutions, which are

456
00:15:49.350 --> 00:15:50.849 
kind of an add-on.

457
00:15:50.850 --> 00:15:52.649 
Why shouldn't the file system be

458
00:15:52.650 --> 00:15:55.169 
able to track all versions of files?

459
00:15:55.170 --> 00:15:57.269 
Or if you look at AIX,

460
00:15:57.270 --> 00:15:59.549 
the older Unix from IBM,

461
00:15:59.550 --> 00:16:01.259 
where you have high availability,

462
00:16:01.260 --> 00:16:03.899 
failover and logical partitioning

463
00:16:03.900 --> 00:16:04.949 
in place.

464
00:16:04.950 --> 00:16:07.559 
So looking at

465
00:16:07.560 --> 00:16:10.229 
existent server operating systems

466
00:16:10.230 --> 00:16:12.689 
sometimes is helpful

467
00:16:12.690 --> 00:16:14.879 
when building new environment.

468
00:16:14.880 --> 00:16:16.829 
And building new environment, they

469
00:16:16.830 --> 00:16:18.749 
should integrate

470
00:16:18.750 --> 00:16:19.750 
and incorporate,

471
00:16:21.300 --> 00:16:22.979 
for instance, Field-Programmable

472
00:16:22.980 --> 00:16:24.539 
Gate Arrays (FPGA).

473
00:16:24.540 --> 00:16:26.999 
They should also incorporate GPUs.

474
00:16:27.000 --> 00:16:29.039 
They should unify the way

475
00:16:29.040 --> 00:16:30.509 
how these devices are being

476
00:16:30.510 --> 00:16:32.639 
programmed. OpenCL makes

477
00:16:32.640 --> 00:16:34.559 
an attempt of unifying

478
00:16:34.560 --> 00:16:36.569 
here and is much better

479
00:16:36.570 --> 00:16:38.039 
and much easier to grasp for

480
00:16:38.040 --> 00:16:40.079 
software people, at least

481
00:16:40.080 --> 00:16:42.209 
than VHDL, for instance.

482
00:16:42.210 --> 00:16:44.369 
And now you can

483
00:16:44.370 --> 00:16:46.589 
in a portable way describe

484
00:16:46.590 --> 00:16:48.059 
how to initialize your hardware, how

485
00:16:48.060 --> 00:16:49.869 
to communicate memory management and

486
00:16:49.870 --> 00:16:51.179 
multiprocessing and the like.

487
00:16:52.590 --> 00:16:54.719 
So these are just a few topics

488
00:16:54.720 --> 00:16:56.549 
of a long series

489
00:16:56.550 --> 00:16:58.829 
of topics to be covered in this

490
00:16:58.830 --> 00:17:00.029 
online course,

491
00:17:01.140 --> 00:17:02.249 
we have talked a little bit about

492
00:17:02.250 --> 00:17:03.809 
the server OS landscape.

493
00:17:03.810 --> 00:17:05.759 
There will be more about the

494
00:17:05.760 --> 00:17:07.649 
history and the development and

495
00:17:07.650 --> 00:17:09.568 
trends in IBM POWER systems.

496
00:17:09.569 --> 00:17:11.549 
So what is the micro

497
00:17:11.550 --> 00:17:12.818 
architecture?

498
00:17:12.819 --> 00:17:14.999 
What is the multicore challenge?

499
00:17:15.000 --> 00:17:17.999 
How do you design and develop

500
00:17:18.000 --> 00:17:19.559 
processor today?

501
00:17:19.560 --> 00:17:21.179 
What is the verification process?

502
00:17:22.230 --> 00:17:24.179 
After talking

503
00:17:24.180 --> 00:17:26.429 
about computer architecture,

504
00:17:26.430 --> 00:17:27.659 
we are going to look at the

505
00:17:27.660 --> 00:17:28.889 
operating systems.

506
00:17:28.890 --> 00:17:30.719 
I mentioned the AIX as a

507
00:17:30.720 --> 00:17:32.339 
Unix version already.

508
00:17:32.340 --> 00:17:34.109 
This PowerVM we have a

509
00:17:34.110 --> 00:17:36.209 
virtualization layer, IBM

510
00:17:36.210 --> 00:17:38.399 
i this is

511
00:17:38.400 --> 00:17:40.160 
synonymous with the AS/400

512
00:17:41.670 --> 00:17:43.289 
mid-range server system that used to

513
00:17:43.290 --> 00:17:45.149 
be installed

514
00:17:45.150 --> 00:17:47.069 
in all of the SMEs

515
00:17:49.180 --> 00:17:51.489 
all over Europe, basically.

516
00:17:51.490 --> 00:17:53.219 
If you talk about Linux and open

517
00:17:53.220 --> 00:17:55.319 
source, remember QUIC,

518
00:17:55.320 --> 00:17:57.479 
that was the network protocol that

519
00:17:57.480 --> 00:17:59.699 
got created because somebody

520
00:17:59.700 --> 00:18:00.989 
just did it.

521
00:18:00.990 --> 00:18:03.239 
This is maybe the new scheme for

522
00:18:03.240 --> 00:18:05.279 
bringing innovation into systems

523
00:18:05.280 --> 00:18:07.079 
that people use the community

524
00:18:07.080 --> 00:18:09.089 
process rather than

525
00:18:09.090 --> 00:18:12.149 
standard-based approaches.

526
00:18:12.150 --> 00:18:13.259 
We talk also about

527
00:18:15.510 --> 00:18:16.510 
high availability.

528
00:18:17.610 --> 00:18:19.619 
I mentioned already the CAPI/SNAP

529
00:18:19.620 --> 00:18:21.899 
framework as a programming framework

530
00:18:21.900 --> 00:18:23.729 
for addressing

531
00:18:23.730 --> 00:18:24.730 
FPGAs.

532
00:18:26.820 --> 00:18:29.159 
CAPI is another interesting feature.

533
00:18:29.160 --> 00:18:31.169 
This is basically the idea

534
00:18:31.170 --> 00:18:32.778 
of extending the cache coherency

535
00:18:32.779 --> 00:18:35.579 
protocol across

536
00:18:35.580 --> 00:18:37.619 
nodes in a

537
00:18:37.620 --> 00:18:39.509 
multi-socket environment

538
00:18:39.510 --> 00:18:41.399 
so that the cache coherency can

539
00:18:41.400 --> 00:18:43.889 
be extended to accelerators.

540
00:18:43.890 --> 00:18:45.809 
And the solution is to build

541
00:18:45.810 --> 00:18:48.329 
a proxy, a little piece of hardware

542
00:18:48.330 --> 00:18:50.549 
on the processor

543
00:18:50.550 --> 00:18:52.529 
in order to keep

544
00:18:52.530 --> 00:18:54.389 
the timing requirements, but

545
00:18:54.390 --> 00:18:56.549 
then have an API to connect

546
00:18:56.550 --> 00:18:59.129 
out to the FPGAs.

547
00:18:59.130 --> 00:19:01.459 
And by the way, IBM

548
00:19:01.460 --> 00:19:04.269 
with CAPI, they also implemented

549
00:19:04.270 --> 00:19:06.629 
NVLink, the high bandwidth connect

550
00:19:06.630 --> 00:19:07.859 
to nVidia

551
00:19:08.880 --> 00:19:09.900 
GPUs inside the

552
00:19:11.160 --> 00:19:12.160 
POWER9 chip.

553
00:19:12.780 --> 00:19:14.879 
Later on, we talk

554
00:19:14.880 --> 00:19:17.249 
a little bit about the new I.T.

555
00:19:17.250 --> 00:19:19.529 
So after addressing

556
00:19:19.530 --> 00:19:21.359 
traditional I.T.,

557
00:19:21.360 --> 00:19:23.009 
we want to ask ourselves, how can it

558
00:19:23.010 --> 00:19:25.169 
be extended to machine

559
00:19:25.170 --> 00:19:27.239 
learning to newer environments?

560
00:19:27.240 --> 00:19:29.009 
And the first thing to talk about is

561
00:19:29.010 --> 00:19:31.649 
cloud and hybrid computing.

562
00:19:31.650 --> 00:19:33.869 
The second is going to be

563
00:19:33.870 --> 00:19:35.249 
workloads like A.I.

564
00:19:35.250 --> 00:19:36.749 
analytics, data science.

565
00:19:39.480 --> 00:19:41.309 
These are further

566
00:19:41.310 --> 00:19:43.409 
presentations and at very end

567
00:19:43.410 --> 00:19:45.449 
we are proud to also have a couple

568
00:19:45.450 --> 00:19:46.769 
of customer stories where people

569
00:19:46.770 --> 00:19:49.139 
tell how systems

570
00:19:49.140 --> 00:19:50.880 
behave in reality.

571
00:19:52.050 --> 00:19:54.209 
At this point in time, I want to

572
00:19:54.210 --> 00:19:56.489 
give some acknowledgements.

573
00:19:56.490 --> 00:19:58.409 
You may have noticed that this

574
00:19:58.410 --> 00:20:00.299 
course is given

575
00:20:00.300 --> 00:20:02.280 
and lectured by many people

576
00:20:04.320 --> 00:20:06.359 
from IBM, from HPI,

577
00:20:06.360 --> 00:20:08.279 
and we just want

578
00:20:08.280 --> 00:20:10.740 
to address

579
00:20:12.750 --> 00:20:14.609 
the acknowledgments and address the

580
00:20:14.610 --> 00:20:16.619 
people who help this preparing that

581
00:20:16.620 --> 00:20:17.620 
particular course.

582
00:20:19.250 --> 00:20:20.250 
This is

583
00:20:21.260 --> 00:20:23.279 
my initial

584
00:20:23.280 --> 00:20:25.259 
welcome to the Future

585
00:20:25.260 --> 00:20:27.389 
in Computing - POWER9 and beyond,

586
00:20:27.390 --> 00:20:29.429 
our MOOC at

587
00:20:29.430 --> 00:20:30.479 
openHPI.

588
00:20:30.480 --> 00:20:31.480 
Thank you.
