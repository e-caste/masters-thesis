WEBVTT

1
00:00:00.500 --> 00:00:04.310 
Speaking about the transport
protocol in our Open HPI course,

2
00:00:04.310 --> 00:00:08.940 
a half-century of internet,
now we consider

3
00:00:09.440 --> 00:00:15.000 
a second important practical
transport protocol

4
00:00:15.250 --> 00:00:16.380 
in the transport layer.

5
00:00:19.380 --> 00:00:24.750 
TCP provides reliable
connection-oriented transport service.

6
00:00:25.650 --> 00:00:30.670 
And we saw for the many
mechanisms involved in TCP,

7
00:00:31.160 --> 00:00:39.740 
it is a very complex protocol, and
implementation and processing requires

8
00:00:40.010 --> 00:00:46.690 
a lot of resources. So for many applications
and for short communication, for example

9
00:00:46.920 --> 00:00:51.840 
a technical communication it
is not efficient enough.

10
00:00:52.420 --> 00:00:56.120 
Before we can use TCP, the
connection is to be established.

11
00:00:56.320 --> 00:01:02.700 
At the end the connection needs
to be terminated, so we look

12
00:01:02.890 --> 00:01:08.970 
for a second protocol which is
compared to TCP absolutely simple/

13
00:01:09.310 --> 00:01:14.590 
And this is the DP protocol,
the Datagram protocol,

14
00:01:14.920 --> 00:01:19.520 
and this is designed for sending
short messages without the

15
00:01:19.520 --> 00:01:21.710 
need to establish
a connection.

16
00:01:22.350 --> 00:01:29.240 
And on the other side with the possibility
that the communication is not reliable,

17
00:01:29.550 --> 00:01:35.650 
that the packets are lost so the
User Datagram provides this very

18
00:01:36.180 --> 00:01:39.990 
efficient but
connectionless,

19
00:01:40.610 --> 00:01:44.550 
and therefore unreliable
transport protocol.

20
00:01:46.160 --> 00:01:52.840 
Similarly, like TCP UDP is using
IP, so all the UDP messages

21
00:01:52.840 --> 00:01:59.740 
are sent as payload inside
an IP datagram and as the

22
00:01:59.750 --> 00:02:07.570 
main tasks of UDP, it extends
and provides ports

23
00:02:07.860 --> 00:02:13.310 
so the UDP ports, because if you remember
the protocols of the transport layer,

24
00:02:13.520 --> 00:02:15.510 
they interconnect
applications,

25
00:02:16.440 --> 00:02:20.990 
IP datagram only
interconnects a computers.

26
00:02:21.530 --> 00:02:27.030 
So what is needed is that a port
that the communication is

27
00:02:27.180 --> 00:02:32.920 
exactly directed to an application,
this is done by port.

28
00:02:32.920 --> 00:02:41.030 
So an important part important a task
of UDP is to provide such ports.

29
00:02:42.030 --> 00:02:47.520 
So UDP is used for
several applications,

30
00:02:47.520 --> 00:02:48.920 


31
00:02:48.920 --> 00:02:51.010 
protocols in the
application layer,

32
00:02:51.340 --> 00:02:52.620 
and are limited to

33
00:02:52.850 --> 00:02:57.190 
very simple

34
00:02:57.690 --> 00:03:05.710 
very short messages and are simple
question and answer interactions.

35
00:03:06.450 --> 00:03:12.440 
So, for example, TPFTP, it's
using the port number 69,

36
00:03:12.790 --> 00:03:17.710 
the domain name
service is using

37
00:03:17.720 --> 00:03:23.330 
a certain type of messages, NTP
protocol, RPC protocol held up.

38
00:03:23.560 --> 00:03:27.790 
So these are services that make use
for the technical communication

39
00:03:28.020 --> 00:03:35.460 
of the UDP protocol and making use of the
UDP protocol mainly provides port numbers.

40
00:03:35.910 --> 00:03:42.300 
UDP accepts data from
application via the

41
00:03:42.300 --> 00:03:47.450 
their ports and forwards
them as encapsulated

42
00:03:47.450 --> 00:03:54.810 
UDP packet, later encapsulated in an IP
packet for transport via internet.

43
00:03:55.050 --> 00:03:59.800 
So the main task of UDP is
this port multiplexing,

44
00:04:01.190 --> 00:04:05.910 
so the port numbers specified
for TCP and UDP can differ,

45
00:04:06.310 --> 00:04:11.630 
but they must match in
case both protocols are

46
00:04:11.640 --> 00:04:17.250 
using the service. Here is the
structure of such a UDP data packet,

47
00:04:17.900 --> 00:04:22.950 
we have the UDP source port,
we have a destination port,

48
00:04:23.570 --> 00:04:28.350 
we have datagram length, UDP
checksum, and then the user data.

49
00:04:28.980 --> 00:04:33.740 
And if we look into detail
in the source port,

50
00:04:34.180 --> 00:04:40.240 
you remember it is 16bit long
number. This is sender's

51
00:04:40.250 --> 00:04:45.330 
port number and then the destination
port is a receiver port number

52
00:04:45.470 --> 00:04:51.380 
for the communication
to identify

53
00:04:51.690 --> 00:04:56.390 
which the communication
is used.

54
00:04:56.390 --> 00:04:57.940 
And we have
seen length,

55
00:04:58.570 --> 00:05:04.380 
here we have a length field,
length can be a 16 bit number,

56
00:05:04.550 --> 00:05:10.830 
it describes the length of the unit
packet in bytes, minimum it's 8 bytes.

57
00:05:11.070 --> 00:05:17.240 
This is the length of the
header maximal is 2 to 6.

58
00:05:17.790 --> 00:05:24.250 
Then here the last his checksum,
also 16 bit are available for it.

59
00:05:24.700 --> 00:05:28.250 
And this is to validate the
integrity of the UDP header.

60
00:05:28.900 --> 00:05:34.030 
So UDP user data and pseudo-header
use algorithm used for

61
00:05:34.030 --> 00:05:35.880 
IP. but this
is optional.

62
00:05:36.920 --> 00:05:43.930 
What are the use cases of UDP
protocol, it can be used when

63
00:05:44.190 --> 00:05:49.410 
packet loss is tolerable or can
be handled by the application.

64
00:05:50.230 --> 00:05:56.960 
Then the expensive and complex
TCP mechanism is not needed

65
00:05:57.170 --> 00:06:01.890 
which provides all the possibility
to check whether a packet

66
00:06:01.900 --> 00:06:02.980 
got lost or not.

67
00:06:04.820 --> 00:06:10.090 
No segmentation is needed, this
is when your UDP can be used

68
00:06:10.430 --> 00:06:15.660 
in case when it is short,
mostly technical messages.

69
00:06:16.120 --> 00:06:21.110 
When the overhead of establishing
a connection is not affordable,

70
00:06:21.360 --> 00:06:25.510 
so for example if a packet is
lost, a new request is made and

71
00:06:25.520 --> 00:06:31.630 
as a use case that
are using UDP.

72
00:06:32.020 --> 00:06:36.270 
Then it's also this dynamic host
configuration protocol, the

73
00:06:36.270 --> 00:06:39.640 
DHCP protocol we
discussed it last week.

74
00:06:40.110 --> 00:06:45.470 
The domain name system is using the
side of TCP also UDP messages.

75
00:06:45.810 --> 00:06:52.870 
The network time protocol, the synchronized
participant's inside the network,

76
00:06:53.090 --> 00:07:00.360 
these are typical services that make
use of your UDP and you see here they

77
00:07:00.680 --> 00:07:06.560 
are in simple messages
short messages, so UDP

78
00:07:06.560 --> 00:07:09.690 
can do this much
faster than TCP.

79
00:07:10.510 --> 00:07:19.760 
More important areas
where UDP is used are

80
00:07:19.940 --> 00:07:25.350 
UDP for realtime system
redesign which has very

81
00:07:25.620 --> 00:07:28.510 
fast reactions and
interactions

82
00:07:29.150 --> 00:07:34.330 
in real-time, and here
complexity mechanisms

83
00:07:34.750 --> 00:07:39.710 
often would not meet
this time requirement.

84
00:07:40.310 --> 00:07:45.930 
So, for example, the data transfer
with RTP, the real-time protocol.

85
00:07:46.260 --> 00:07:51.340 
we will see what it
is in another week.

86
00:07:52.060 --> 00:07:57.070 
The protocols SIP protocol, Session
initiation protocol which

87
00:07:57.070 --> 00:08:02.810 
is used to establish a connection
between two systems, for example,

88
00:08:03.020 --> 00:08:05.130 


89
00:08:05.770 --> 00:08:11.380 
applications such as video streaming,
voice over IP, these are

90
00:08:11.390 --> 00:08:14.440 
applications which
make use of UDP.

91
00:08:15.590 --> 00:08:20.690 
For encrypted data, TCP
is usually preferred

92
00:08:21.160 --> 00:08:28.420 
because with UDP every packet would
have to be encrypted individually,

93
00:08:28.730 --> 00:08:35.380 
because there are no mechanisms
which are provided by TCP.

94
00:08:36.040 --> 00:08:41.790 
So if there are high-security
requests then TCP is better to use

95
00:08:42.050 --> 00:08:42.940 
than UDP.

96
00:08:44.450 --> 00:08:51.090 
There have been efforts also increasing
the data security for the UDP protocol.

97
00:08:51.390 --> 00:08:59.060 
for example SRTP which is
described in RFC 3711,

98
00:08:59.310 --> 00:09:05.260 
or DTLS, which is
described in RFC 6347.

99
00:09:05.660 --> 00:09:10.440 
And the reason why people
spent time to think about

100
00:09:10.440 --> 00:09:16.200 
security mechanisms also
for UDP becomes more

101
00:09:16.200 --> 00:09:22.340 
important in the context of
real data communication.

102
00:09:23.490 --> 00:09:29.560 
Here is one of these initiatives,
it is a quick protocol

103
00:09:29.890 --> 00:09:36.220 
the transport of
HTTP over UDP

104
00:09:36.700 --> 00:09:41.670 
protocol which is used for
the web applications

105
00:09:42.120 --> 00:09:47.190 
and of course, it's used with TCP,
so what people try to experiment

106
00:09:47.430 --> 00:09:50.030 
because it is a very
important protocol,

107
00:09:50.460 --> 00:09:55.970 
and to provide the possibility
for faster communications/

108
00:09:56.350 --> 00:10:00.450 
So people experiment
whether HTTP

109
00:10:00.870 --> 00:10:03.050 
can also be run
over UDP.

110
00:10:03.990 --> 00:10:10.070 
So QUIC is an experimental
protocol on the transport layer

111
00:10:10.380 --> 00:10:15.830 
based on UDP. So it's between
the transport layer and the

112
00:10:16.230 --> 00:10:22.420 
application layer and the idea here
is to speed up communication,

113
00:10:23.710 --> 00:10:27.470 
the development of QUIC and
the experiments go back

114
00:10:27.760 --> 00:10:29.460 
to the year 2013.

115
00:10:30.100 --> 00:10:38.740 
And already in some browsers, it
is implemented, for example

116
00:10:38.990 --> 00:10:46.170 
in Chromium browser side, but it
is only supported by about 4.6%

117
00:10:46.390 --> 00:10:53.160 
of the websites,
this was a

118
00:10:53.270 --> 00:10:55.760 
measurement in
the suburbs.

119
00:10:56.730 --> 00:11:02.740 
So the advantages it is less
overhead compared to TCP, it's

120
00:11:02.740 --> 00:11:06.400 
now necessary to establish
a a connection first

121
00:11:06.950 --> 00:11:09.540 
it immediately can
not be transported,

122
00:11:09.950 --> 00:11:15.810 
but then the other services
that are provided by TCP the

123
00:11:15.870 --> 00:11:21.090 
liability of the data transfer, it needs
to be organised in a different way.

124
00:11:21.580 --> 00:11:28.370 
So here a QUIC can handle a cross
connection and this fits to a

125
00:11:28.590 --> 00:11:33.490 
new a development into a new
version of the HTTP protocol to

126
00:11:33.490 --> 00:11:38.930 
a protocol with multiplex
connections when

127
00:11:38.930 --> 00:11:42.220 
we speak about the protocols
of the application layer.

128
00:11:42.390 --> 00:11:47.640 
We will go into more detail also
for the new HTTP protocol.

129
00:11:47.960 --> 00:11:56.820 
the HTTP over QUIC will most
likely be new HTTP/3 protocol.

130
00:11:56.980 --> 00:12:02.110 
Whoever is interested in such kind of
developments, here is a link to the

131
00:12:02.210 --> 00:12:07.380 
the status of the work. But I mentioned
it is an experimental protocol

132
00:12:08.330 --> 00:12:13.000 
which makes use of the second
important protocol on the transport

133
00:12:13.000 --> 00:12:14.730 
layer, the UDP
protocol.
