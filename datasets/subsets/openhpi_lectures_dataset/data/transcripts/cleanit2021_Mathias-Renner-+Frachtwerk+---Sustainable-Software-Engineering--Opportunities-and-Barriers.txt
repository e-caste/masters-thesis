WEBVTT

1
00:00:03.790 --> 00:00:08.180 
Welcome everyone to our last Clean IT Open Exchange live

2
00:00:08.180 --> 00:00:11.790 
talk at least for this year. So after this we will go to our short

3
00:00:11.890 --> 00:00:17.720 
christmas break. My name is as always Nils KÃ¶nig. I'm here with Maximillian

4
00:00:17.720 --> 00:00:20.820 
and Sophie from the Clean IT Team at HPI,

5
00:00:21.530 --> 00:00:23.980 
and today's guest with us is Mathias Renner.

6
00:00:24.550 --> 00:00:29.830 
Mathias Renner is an IT architect product owner and IT consultant at Frachtwerk.

7
00:00:30.390 --> 00:00:33.840 
Frachtwerk is an IT consulting company that's located in Berlin

8
00:00:34.310 --> 00:00:36.980 
that specializes in logistics and transport.

9
00:00:37.740 --> 00:00:41.940 
Mathias Renner studied business information systems at the University of Bamberg

10
00:00:42.350 --> 00:00:46.450 
and finished his study there with a master's degree in information systems.

11
00:00:46.960 --> 00:00:50.240 
After his study he first co-founded and worked at different

12
00:00:50.240 --> 00:00:52.930 
companies as an IT specialist and consultant.

13
00:00:53.600 --> 00:00:56.930 
And since twenty twenty he has started working

14
00:00:56.930 --> 00:00:59.450 
at Frachtwerk, where he is also still working now.

15
00:00:59.870 --> 00:01:03.300 
And he also works as a lecturer for the big data analytics

16
00:01:03.300 --> 00:01:07.860 
and cloud data platforms lecture at the Hochschule fÃ¼r Technik und Wirtschaft,

17
00:01:07.990 --> 00:01:12.440 
Berlin. With that being said I am very interested for the talk coming now and

18
00:01:12.850 --> 00:01:14.740 
happy. Welcome Mathias Renner.

19
00:01:18.230 --> 00:01:21.510 
Thank you very much. I'll start with sharing my screen.

20
00:01:25.190 --> 00:01:26.320 
Can you see my screen?

21
00:01:27.280 --> 00:01:32.760 
Yes, so thanks for having me. Thanks for the kind words and the invitation of course.

22
00:01:34.270 --> 00:01:38.080 
As mentioned I am Mathias. I work at Frachtwerk.

23
00:01:38.760 --> 00:01:43.520 
At Frachtwerk, we do a consulting and software development, and we

24
00:01:43.530 --> 00:01:46.920 
try to focus on doing that in a sustainable way.

25
00:01:47.350 --> 00:01:51.110 
I say humbly we try because, it's not always easy. There's project

26
00:01:51.110 --> 00:01:56.680 
where it's quite hard to do it but we try a lot and it works better and better.

27
00:01:58.520 --> 00:02:03.410 
Today I would like to present two aspects of sustainable software engineering.

28
00:02:03.630 --> 00:02:06.380 
On the one hand, opportunities that we see

29
00:02:07.120 --> 00:02:11.210 
that drive the topic of sustainability in a software

30
00:02:11.210 --> 00:02:15.460 
engineering process forward, and on the other hand barriers that we see

31
00:02:16.080 --> 00:02:21.110 
that slow us down in applying ecological behavior in software engineering.

32
00:02:26.190 --> 00:02:30.370 
The topic of sustainable software engineering is not only very

33
00:02:30.370 --> 00:02:35.870 
interesting, but it's also very huge. So I cannot cover everything

34
00:02:35.870 --> 00:02:40.480 
today of course. So therefore we created an online

35
00:02:40.480 --> 00:02:44.900 
course. If you want to dig deeper in all the relevant topics around

36
00:02:45.290 --> 00:02:47.990 
sustainable software engineering that we cannot cover today.

37
00:02:48.620 --> 00:02:51.090 
In this course, we will cover

38
00:02:52.130 --> 00:02:57.420 
the questions, how IT- information technology can save co two

39
00:02:57.420 --> 00:03:01.760 
emissions but also how it causes co two emissions, and then we will take

40
00:03:02.010 --> 00:03:05.860 
all the relevant perspectives in the software engineering process

41
00:03:06.160 --> 00:03:09.350 
from the developer to the architect decision makers and so on

42
00:03:09.530 --> 00:03:13.520 
to show practical examples of how each of these roles can do

43
00:03:13.520 --> 00:03:17.180 
its part in making software engineering more sustainable.

44
00:03:18.080 --> 00:03:21.110 
At this point, thanks to the HPI to host us

45
00:03:21.610 --> 00:03:23.260 
for this course and also

46
00:03:24.070 --> 00:03:28.360 
to spread the word about Clean IT and in this, and in many other formats too.

47
00:03:34.000 --> 00:03:40.760 
When I say 'we' then I'm not alone. I mean a wonderful team of these four people

48
00:03:41.960 --> 00:03:43.970 
who work on these topics together.

49
00:03:44.810 --> 00:03:47.440 
First my myself as I've been introduced

50
00:03:48.110 --> 00:03:50.940 
as IT consultant and IT architect.

51
00:03:51.640 --> 00:03:56.660 
There's also with me Johannes who is a CTO at Meshcloud.

52
00:03:57.500 --> 00:03:59.560 
So we are all working in the cloud here.

53
00:04:00.110 --> 00:04:05.150 
He is responsible for product development and search engineering, and he helps

54
00:04:05.260 --> 00:04:08.360 
customers to reduce complexity of the cloud

55
00:04:08.860 --> 00:04:12.340 
and for that they offer multi cloud governance solutions.

56
00:04:13.320 --> 00:04:15.360 
He might be in the audience today.

57
00:04:16.500 --> 00:04:19.170 
So it's nice for the discussion round later.

58
00:04:19.740 --> 00:04:26.000 
And there's also Robin in our team. Robin is a software engineer at Frachtwerk too.

59
00:04:26.780 --> 00:04:32.080 
And also there's a Ferdi that I've already seen. He's in the

60
00:04:32.180 --> 00:04:37.730 
audience today. So he's a software engineer for all the more nerdy questions.

61
00:04:38.740 --> 00:04:42.590 
He's the one to ask for today in the discussion round after the talk.

62
00:04:46.410 --> 00:04:51.900 
In case you cannot wait until our free course kicks off in about three months,

63
00:04:52.080 --> 00:04:54.570 
I recommend some good rates in the meantime.

64
00:04:55.280 --> 00:05:00.190 
It's a practical guide how to apply resource efficient programming

65
00:05:00.790 --> 00:05:04.410 
and it even includes a cheat sheet that you see on there on the right side.

66
00:05:04.850 --> 00:05:09.840 
It's a publication in which Johannes and me participated has been

67
00:05:09.950 --> 00:05:13.360 
coordinated by the bitkom. And at this point I would like to

68
00:05:13.360 --> 00:05:18.970 
thank the coordinator and initiator of this publication. It's Frank Teramo.

69
00:05:19.690 --> 00:05:23.380 
He's the manager of the software division at bitkom and I

70
00:05:23.380 --> 00:05:27.520 
think that sustainably thinking mindsets like him are increasingly

71
00:05:27.520 --> 00:05:30.040 
important in the context of climate change. So

72
00:05:30.950 --> 00:05:36.320 
thumbs up and thanks to Frank.

73
00:05:39.160 --> 00:05:44.590 
Let's go in the topic of the opportunities and barriers of

74
00:05:45.180 --> 00:05:47.260 
software engineering in a sustainable way.

75
00:05:47.920 --> 00:05:49.650 
What's our motivation to

76
00:05:50.310 --> 00:05:54.680 
care about all of this. So of course it's the short answer to

77
00:05:54.680 --> 00:05:58.860 
climate change and there's two things, just two things that

78
00:05:58.860 --> 00:06:01.710 
I would like you to take away as a motivational

79
00:06:02.150 --> 00:06:07.790 
start. First when looking at the latest IPCC reports and the latest

80
00:06:08.270 --> 00:06:11.450 
calculations, that then

81
00:06:12.220 --> 00:06:16.840 
we can we can see that we should be net neutral as Germany as a nation

82
00:06:17.060 --> 00:06:21.040 
in about ten to fifteen years. To not exceed the tipping points

83
00:06:21.530 --> 00:06:24.810 
you know these tipping points the point of no return where

84
00:06:24.910 --> 00:06:29.430 
parts of the natural ecosystem are irreversibly broken.

85
00:06:30.030 --> 00:06:34.500 
So ten to fifteen years. It's not too far in the future. So it

86
00:06:34.540 --> 00:06:39.490 
implies some urgency for us to do more about sustainable also.

87
00:06:39.500 --> 00:06:43.140 
In the sustainability also in the IT sector.

88
00:06:44.240 --> 00:06:45.570 
And the second thing.

89
00:06:46.370 --> 00:06:50.520 
If you translate this more abstract goal on a national level

90
00:06:50.940 --> 00:06:55.040 
to every one of us I assume human beings who live in Europe

91
00:06:55.390 --> 00:06:59.440 
then our average co two footprint has to change dramatically.

92
00:07:00.140 --> 00:07:02.880 
We have to reduce it basically to twenty percent,

93
00:07:03.750 --> 00:07:07.520 
which is not only numbers but also visually

94
00:07:08.090 --> 00:07:13.450 
a big step from ten tonnes of co two emissions per year for

95
00:07:13.450 --> 00:07:17.970 
every one of us for each of us to two tonnes of co two equivalent per year.

96
00:07:19.720 --> 00:07:23.580 
So we have to do a lot. It's urgent, it's important. And now the question is,

97
00:07:23.690 --> 00:07:27.550 
what can we do about it? Let's have a look into this.

98
00:07:28.650 --> 00:07:31.900 
Before we talk about actually practical things that we can do.

99
00:07:32.250 --> 00:07:35.170 
let's have one slide about the overall picture.

100
00:07:35.610 --> 00:07:38.610 
So what should be our overall goal is that

101
00:07:39.080 --> 00:07:42.230 
saved emissions should always be higher at emissions that are

102
00:07:42.240 --> 00:07:47.130 
caused by IT, because also IT comes at some cost of resource consumption. So

103
00:07:47.730 --> 00:07:51.960 
the emissions we save using our technology should always be higher

104
00:07:52.270 --> 00:07:55.420 
than the emissions that are caused by IT.

105
00:07:56.020 --> 00:07:59.470 
So when we look at the left side, there's a bitkom for instance

106
00:07:59.470 --> 00:08:05.460 
that identifies a huge potential to save co two using digital technologies,

107
00:08:06.590 --> 00:08:11.140 
and there's, and it's quite a bit like you can save

108
00:08:11.910 --> 00:08:15.110 
a one in five tonnes of co two,

109
00:08:16.170 --> 00:08:20.520 
which is quite a bit. But as mentioned, there's also the other side

110
00:08:20.860 --> 00:08:26.090 
which is the consumption side and according to some projections

111
00:08:26.940 --> 00:08:31.440 
in the worst case within the next ten years, the ICT- so the

112
00:08:31.500 --> 00:08:37.050 
Information and Communication Technology can consume up to about

113
00:08:37.330 --> 00:08:41.920 
twenty three percent of the globally released greenhouse gas emissions, which is

114
00:08:42.190 --> 00:08:42.770 
quite a lot.

115
00:08:45.050 --> 00:08:49.690 
We will not go further into these numbers and details today

116
00:08:49.730 --> 00:08:55.250 
more in the course. So again invitation to join us in the course but the message

117
00:08:55.720 --> 00:08:59.350 
for now and today is clear. I think it's important that

118
00:08:59.820 --> 00:09:05.590 
we care about it, about doing software engineering and digitalisation as a whole

119
00:09:05.810 --> 00:09:08.720 
in a more sustainable way, as much as we can.

120
00:09:12.780 --> 00:09:15.850 
Let's finally have a look at what we can do.

121
00:09:16.750 --> 00:09:23.770 
And first let's have a look who 'we' is in this question. We have to identify

122
00:09:23.960 --> 00:09:28.350 
who is involved in the software development process.

123
00:09:29.060 --> 00:09:33.380 
And I provide here a model that is not perfect,

124
00:09:34.060 --> 00:09:39.960 
and it's simplified and it gives an overview about the roles there are

125
00:09:40.320 --> 00:09:45.320 
part of the process of software engineering. So you see here in the

126
00:09:45.560 --> 00:09:50.700 
core part a role model of the software engineering team who

127
00:09:50.930 --> 00:09:55.240 
often has a product owner or product manager, on the right side

128
00:09:55.240 --> 00:09:59.270 
who is responsible for the product the budget and makes decisions about it.

129
00:09:59.910 --> 00:10:05.120 
Then you have the architect. IT architect who is responsible for architectural decisions,

130
00:10:05.570 --> 00:10:08.180 
like which components to use in the software stack,

131
00:10:08.690 --> 00:10:10.150 
which databases and so on.

132
00:10:10.980 --> 00:10:14.990 
Then we have the operator who operates the software services,

133
00:10:15.140 --> 00:10:18.410 
and we have the developers themselves who create

134
00:10:18.870 --> 00:10:19.430 
the software.

135
00:10:21.180 --> 00:10:24.300 
This this team is not alone. The context of the team there's more

136
00:10:24.510 --> 00:10:26.440 
for instance. There's the users of course.

137
00:10:27.130 --> 00:10:32.210 
And the user, he uses the software he buys it and he

138
00:10:34.500 --> 00:10:36.310 
is also living in

139
00:10:37.570 --> 00:10:43.310 
in a context of a regulatory framework as also the software engineering team itself.

140
00:10:44.150 --> 00:10:49.490 
Ihe political umbrella who defines laws and

141
00:10:50.000 --> 00:10:54.670 
regulations and sometimes also inspirations how to do software

142
00:10:54.670 --> 00:10:58.250 
engineering for instance by creating labels like the blue angel.

143
00:11:01.880 --> 00:11:03.190 
For now we will

144
00:11:04.550 --> 00:11:07.650 
just talk today. We will go a bit more in the developer

145
00:11:08.100 --> 00:11:12.170 
perspective in the course that I mentioned. We will cover all of these

146
00:11:12.490 --> 00:11:16.050 
roles and what they can do about the software engineering process

147
00:11:16.050 --> 00:11:17.150 
to be more sustainable.

148
00:11:18.740 --> 00:11:24.440 
So let's have a look what that developer's eyes can do and his hands

149
00:11:24.710 --> 00:11:29.760 
in the process. Let's start at the non-functional requirements.

150
00:11:29.760 --> 00:11:34.020 
We see that there's quite a bit potential in setting a high bar

151
00:11:34.300 --> 00:11:39.630 
for non functional requirements to put sustainability in these

152
00:11:40.280 --> 00:11:46.850 
class of requirements. For instance focusing on performance because

153
00:11:47.190 --> 00:11:52.730 
performance correlates with better energy efficiency and again correlates with

154
00:11:53.060 --> 00:11:58.490 
lower energy consumption, and lower resource consumption in

155
00:11:58.490 --> 00:12:00.770 
the very end. So it's nice to

156
00:12:01.830 --> 00:12:06.760 
have software that is, has a high performance that is efficient so when

157
00:12:06.890 --> 00:12:10.300 
a developer writes a code, it's good when when he uses the data

158
00:12:10.300 --> 00:12:13.770 
structures that are actually quite fast for

159
00:12:14.270 --> 00:12:19.910 
solving the problem he has to solve. When he uses libraries or frameworks

160
00:12:20.620 --> 00:12:25.230 
from external sources, then it's nice to use the one we have who are faster

161
00:12:26.500 --> 00:12:28.250 
to have a better time complexity

162
00:12:29.060 --> 00:12:30.990 
in the terms of the big O notation.

163
00:12:31.780 --> 00:12:35.150 
And also when you exchange data and use protocols and data

164
00:12:35.150 --> 00:12:39.320 
formats to do this, it's nice to use the ones that are lightweight

165
00:12:39.580 --> 00:12:44.310 
and fit well for the problem that has to be solved.

166
00:12:46.850 --> 00:12:51.850 
To increase the visibility and to see how sustainable the software

167
00:12:51.850 --> 00:12:55.700 
is that you write, it's useful to implement some metrics in the code.

168
00:12:56.240 --> 00:13:00.760 
To have some some locks that you can then analyze and

169
00:13:01.980 --> 00:13:07.370 
get more insights how sustainable the software use or how the resource footprint

170
00:13:07.530 --> 00:13:08.330 
changed

171
00:13:09.860 --> 00:13:15.730 
over time. So you can for instance do simple great simple KPIs that

172
00:13:16.080 --> 00:13:20.030 
give you an idea about the resource consumption, about the software for instance.

173
00:13:20.150 --> 00:13:24.690 
As an example here you calculate the CPU hours used for a standard

174
00:13:24.690 --> 00:13:26.570 
usage scenario of usage.

175
00:13:28.720 --> 00:13:31.120 
From this develop perspective, a little bit

176
00:13:31.880 --> 00:13:36.480 
up to their perspective how the components that developers write

177
00:13:36.880 --> 00:13:39.020 
are interacting with each other.

178
00:13:40.630 --> 00:13:43.960 
So it's nice or it's often useful

179
00:13:45.000 --> 00:13:51.570 
to think about efficient interactions between software components.

180
00:13:51.790 --> 00:13:57.470 
For instance we see that event driven patterns are more resource

181
00:13:57.470 --> 00:14:02.090 
efficient than when you regularly poll some data from an API.

182
00:14:03.080 --> 00:14:06.300 
And more faster of course because when there's an event, you

183
00:14:06.300 --> 00:14:11.340 
get information about it and not when the period of polling the API

184
00:14:11.570 --> 00:14:13.750 
has the next initiator.

185
00:14:14.770 --> 00:14:20.190 
Also in the context of how the components are interacting with

186
00:14:20.290 --> 00:14:25.560 
each other is nice to actually go to the state to have several components

187
00:14:25.850 --> 00:14:30.100 
to decouple your software in several components.

188
00:14:31.070 --> 00:14:34.920 
And this allows you to scale your software up,

189
00:14:35.970 --> 00:14:40.550 
but also down. And when you scale something down it often comes with some

190
00:14:40.670 --> 00:14:45.430 
les of energy consumption, resource consumption and so on, and

191
00:14:45.430 --> 00:14:49.290 
you can see this in in the bill for instance of your hosting provider.

192
00:14:50.100 --> 00:14:53.990 
So as you see this in the graph here that when you scale something

193
00:14:53.990 --> 00:14:58.920 
down or when you when you don't use a resource all the time,

194
00:14:58.920 --> 00:15:03.480 
then you have some wide areas in your bill,

195
00:15:04.840 --> 00:15:07.660 
metaphorically speaking. So there are some wide areas where

196
00:15:07.660 --> 00:15:09.820 
you don't have to pay for a resource,

197
00:15:10.760 --> 00:15:15.140 
especially when you use a service and market services that you scale down,

198
00:15:15.430 --> 00:15:20.080 
then when there's no demand you can adapt your

199
00:15:21.170 --> 00:15:26.770 
operations to also scale down, and not surf anything when there's no demand.

200
00:15:28.440 --> 00:15:32.880 
Yes much more to talk about what developers can do and also

201
00:15:32.880 --> 00:15:34.890 
here in a more architectural point of view,

202
00:15:35.380 --> 00:15:39.230 
but maybe we can dig into this more in the discussion after

203
00:15:39.230 --> 00:15:42.970 
the talk. But for now let's rather dive up a little bit

204
00:15:44.820 --> 00:15:50.430 
a higher to the method that can be followed when you think about the software

205
00:15:50.670 --> 00:15:53.980 
engineering process. So when we

206
00:15:55.480 --> 00:15:59.440 
think about which persons are involved and and and what they

207
00:15:59.440 --> 00:16:01.960 
are doing in the software engineering process,

208
00:16:02.830 --> 00:16:04.900 
we would like to give you an

209
00:16:06.020 --> 00:16:10.300 
or recommend a model that helps us to get an overview about

210
00:16:10.300 --> 00:16:14.380 
all the relevant context in the software engineering process, and where actually

211
00:16:14.990 --> 00:16:20.290 
you can do some things, you can change the configuration

212
00:16:21.020 --> 00:16:25.740 
to be more sustainable. And for that we found the Greensoft model very useful,

213
00:16:26.620 --> 00:16:31.900 
which offers a holistic perspective on producing but also consuming software.

214
00:16:32.470 --> 00:16:38.840 
And it gives quite a view of ideas and opportunities how to act more sustainably.

215
00:16:40.330 --> 00:16:44.440 
And the perspective of the developer for instance,

216
00:16:44.890 --> 00:16:50.900 
you can see that the model offers you some ideas where the developer

217
00:16:51.280 --> 00:16:56.090 
has some impact during the process and which other

218
00:16:56.180 --> 00:17:01.030 
roles or our contexts are involved. So we use this model quite

219
00:17:01.030 --> 00:17:06.250 
a bit to dig deeper in the different roles and what the developer can do.

220
00:17:07.600 --> 00:17:11.550 
So you find quite a bit of opportunities using this model.

221
00:17:14.410 --> 00:17:17.140 
To sum up the first part about the opportunities,

222
00:17:17.820 --> 00:17:22.270 
we've seen that a developer can do quite a bit of different things.

223
00:17:23.470 --> 00:17:27.580 
Of course the list is much longer than the list I presented,

224
00:17:27.990 --> 00:17:35.150 
and in general there's four things that a developer

225
00:17:35.460 --> 00:17:40.640 
can focus on and that have quite a good effect on the sustainable

226
00:17:41.410 --> 00:17:47.230 
part of software engineering, which is the four words. It's performance, scalability,

227
00:17:47.340 --> 00:17:51.220 
event-driven and decoupling. These are king.

228
00:17:52.350 --> 00:17:55.590 
And also we have seen that the Greensoft model

229
00:17:56.030 --> 00:18:01.080 
gives some guidance to act more sustainably along software engineering.

230
00:18:03.900 --> 00:18:07.530 
So far about the opportunities.

231
00:18:09.470 --> 00:18:12.820 
Now if everyone would seize these opportunities,

232
00:18:14.260 --> 00:18:17.830 
we've seen we would save a lot of resources.

233
00:18:18.330 --> 00:18:19.310 
And that would be great.

234
00:18:19.980 --> 00:18:25.190 
But then reality, and I think everyone of us knows. This looks different.

235
00:18:25.590 --> 00:18:29.390 
The gap between what we need to do and what we actually do

236
00:18:29.880 --> 00:18:35.040 
is quite big. So the question is simply why is that. Why are

237
00:18:35.040 --> 00:18:38.660 
there obviously some barriers, and what are these that prevent

238
00:18:38.670 --> 00:18:40.320 
us from doing more.

239
00:18:44.610 --> 00:18:51.150 
There are two interesting laws or rather empirical observations that are interesting

240
00:18:51.370 --> 00:18:53.240 
in this in the discussion about this.

241
00:18:54.270 --> 00:18:58.570 
These two laws showed transferred several decades now and they

242
00:18:58.570 --> 00:19:01.080 
did not change fundamentally until today.

243
00:19:02.240 --> 00:19:05.920 
The first one is the Moore's law that you probably know. It

244
00:19:05.920 --> 00:19:11.290 
says that the number of transistors in integrated circuits simplified CPU

245
00:19:11.470 --> 00:19:13.360 
doubles every two years.

246
00:19:14.830 --> 00:19:20.490 
And there's another empiric law the Koomey's law, saying that

247
00:19:20.710 --> 00:19:22.170 
in roughly the same time

248
00:19:23.080 --> 00:19:26.420 
as in the Morse law the power consumption for each computing

249
00:19:26.420 --> 00:19:27.960 
unit is cut in half.

250
00:19:30.620 --> 00:19:34.240 
So if you combine these two laws, it means that

251
00:19:34.920 --> 00:19:41.040 
in roughly the same time, the number of computing units are doubling,

252
00:19:42.090 --> 00:19:44.570 
but the energy costs are cut in half.

253
00:19:46.450 --> 00:19:50.530 
So the logic is that over time actually the energy

254
00:19:51.150 --> 00:19:55.240 
consumption is constant, while the computing performance is increasing.

255
00:19:56.750 --> 00:20:01.880 
So that's nice, right? I mean we gain more and he has more power and more

256
00:20:02.270 --> 00:20:07.050 
power and we have the same energy input. So the resource consumption

257
00:20:07.050 --> 00:20:07.890 
is kind of constant.

258
00:20:09.940 --> 00:20:14.690 
Well that's nice and when humans as we are have these kind

259
00:20:14.690 --> 00:20:19.500 
of nice opportunities, at the first site then we tend

260
00:20:19.990 --> 00:20:21.050 
to want more of it.

261
00:20:22.300 --> 00:20:25.350 
Which then increases the resource consumptions,

262
00:20:26.220 --> 00:20:31.270 
their resource consumption again. And this is a big trap.

263
00:20:32.210 --> 00:20:36.630 
Because when sat in something, when we can have something for the same price,

264
00:20:36.910 --> 00:20:42.060 
then we want to have more of it. And this is a big

265
00:20:42.900 --> 00:20:46.890 
pitfall and it also has a name. And you probably know the name.

266
00:20:46.960 --> 00:20:48.380 
It's called the Rebound Effect.

267
00:20:50.420 --> 00:20:54.260 
And we apply this

268
00:20:54.970 --> 00:20:58.820 
effect or we follow the effect probably more than we actually think.

269
00:20:59.160 --> 00:21:03.780 
So the Rebound Effect basically says exactly this that when we

270
00:21:03.920 --> 00:21:07.060 
can have more at the same price we just want to have more.

271
00:21:07.960 --> 00:21:11.840 
There's even in the software context that we're talking about

272
00:21:11.840 --> 00:21:14.350 
here. An empirical law that says

273
00:21:15.130 --> 00:21:18.030 
and that kind of applies this Rebound Effect on the software

274
00:21:18.030 --> 00:21:21.690 
context, and it says that software is getting slower more rapidly,

275
00:21:21.880 --> 00:21:24.270 
that hardware is becoming faster.

276
00:21:25.920 --> 00:21:30.920 
So the energy advancements in hardware that we see in doubling the transistors

277
00:21:31.550 --> 00:21:35.470 
is compensated because the software that we use is

278
00:21:36.160 --> 00:21:38.860 
growing and overall it's slower.

279
00:21:41.760 --> 00:21:45.720 
There is of course some limits to this kind of logical thinking,

280
00:21:46.530 --> 00:21:51.820 
and it simplifies quite a few things. But I think in general the message is

281
00:21:52.240 --> 00:21:57.610 
is clear. That we have quite a bit of efficiency advancements that are good

282
00:21:58.410 --> 00:22:01.630 
but they are always not enough because these advancements are

283
00:22:01.720 --> 00:22:06.180 
compensated and in the end they don't lead to actually reducing resources, or the

284
00:22:06.310 --> 00:22:07.390 
resource consumption.

285
00:22:08.050 --> 00:22:12.590 
So the point is we need other strategies in addition

286
00:22:13.070 --> 00:22:18.080 
to the efficiency strategy to reduce our overall resource consumption.

287
00:22:19.620 --> 00:22:23.020 
In other words, to do software engineering actually more sustainable

288
00:22:23.020 --> 00:22:25.820 
at the end of the day, and not only focusing on

289
00:22:26.970 --> 00:22:29.990 
the efficiency strategy.

290
00:22:30.940 --> 00:22:33.030 
And for that, I would like to propose

291
00:22:35.720 --> 00:22:40.550 
a slide about additional strategies. What we can do in addition to the efficiency

292
00:22:41.010 --> 00:22:43.820 
strategy that we are mostly focusing at.

293
00:22:44.900 --> 00:22:49.180 
So as we see here the efficiency strategy it offers the solutions to have

294
00:22:49.500 --> 00:22:54.810 
more power per watts using virtualization and so on. But the barrier of it

295
00:22:54.930 --> 00:23:00.340 
is the Rebound Effect on the Wirth law, especially in the software context, which is

296
00:23:00.670 --> 00:23:03.510 
quite effective against these solutions.

297
00:23:05.800 --> 00:23:07.110 
What can we do in addition.

298
00:23:08.300 --> 00:23:11.910 
One of them is called the Consistency Strategy. It has some

299
00:23:11.910 --> 00:23:14.490 
ideas of the circular economy,

300
00:23:15.480 --> 00:23:20.610 
and it basically follows the pattern of reusing things, sharing things.

301
00:23:20.900 --> 00:23:26.520 
And in the context of software, one of the main solutions

302
00:23:26.750 --> 00:23:30.550 
is sharing software by creating it in the open and

303
00:23:31.340 --> 00:23:34.100 
sharing it as free and open source software.

304
00:23:35.130 --> 00:23:36.780 
One of the barriers is that

305
00:23:37.610 --> 00:23:43.080 
there's not so many open source business models that are compatible to that.

306
00:23:43.360 --> 00:23:47.370 
So it's not always easy to just reuse and share all the software

307
00:23:47.370 --> 00:23:48.810 
we do in every IT project.

308
00:23:51.510 --> 00:23:53.270 
And the second strategy

309
00:23:53.910 --> 00:23:55.820 
is the Sufficiency Strategy.

310
00:23:58.150 --> 00:23:59.910 
It asks us to

311
00:24:00.590 --> 00:24:04.770 
focus basically only on what we need, and not too much more

312
00:24:04.780 --> 00:24:08.650 
to leave out a nice to have to do to exactly what is necessary.

313
00:24:09.050 --> 00:24:10.870 
So in the context of

314
00:24:11.840 --> 00:24:13.710 
soft engineering, for instance, we

315
00:24:14.420 --> 00:24:19.780 
we focus on the features that are really important for our users,

316
00:24:20.270 --> 00:24:23.210 
and maybe rather avoid the nice to have

317
00:24:23.740 --> 00:24:25.310 
not focus on them too much.

318
00:24:26.330 --> 00:24:31.900 
Or maybe we use the server power. That is actually good for

319
00:24:31.900 --> 00:24:35.940 
the software we want to serve. But we don't buy it like a super

320
00:24:35.940 --> 00:24:40.170 
huge computing machine saying that one day we might use this power

321
00:24:41.300 --> 00:24:45.220 
and and use a lot of resources, and an energy consumption from

322
00:24:45.220 --> 00:24:49.560 
day one when serving just a simple application to the users.

323
00:24:51.030 --> 00:24:56.320 
So both their consistency, efficiency and sufficient strategy

324
00:24:57.450 --> 00:25:01.640 
have limits of course. When it comes to practice there because projects

325
00:25:02.200 --> 00:25:05.890 
in such engineering are often complex and it's not always

326
00:25:05.890 --> 00:25:09.350 
easy to apply all of these strategies. But

327
00:25:10.810 --> 00:25:14.590 
again the rough message is that, if we have these two sets of

328
00:25:14.670 --> 00:25:19.260 
knowledge, efficiency, consistency and sufficiency more in mind,

329
00:25:19.530 --> 00:25:23.970 
that maybe it can save some more resources than we do today

330
00:25:24.130 --> 00:25:26.750 
when we focus only on the efficiency strategy.

331
00:25:31.420 --> 00:25:36.230 
In summary we've seen that efficiency strategy that we often

332
00:25:36.230 --> 00:25:40.690 
focus on has its limits, and there's two others that are beneficial

333
00:25:41.750 --> 00:25:48.540 
to reduce the overall resource consumption at the very end of the day. So

334
00:25:50.110 --> 00:25:52.410 
when we follow all of them together

335
00:25:53.370 --> 00:25:59.790 
it's nice and it's better when we're focusing only on the

336
00:26:00.000 --> 00:26:01.100 
efficiency strategy.

337
00:26:03.140 --> 00:26:07.310 
So I hope that you got some inspiration about the opportunities

338
00:26:07.310 --> 00:26:12.390 
for especially developers can do in the process of software engineering and also

339
00:26:12.640 --> 00:26:16.610 
about the well known Rebound effect that we applied very well

340
00:26:17.100 --> 00:26:20.750 
and that is a barrier against these opportunities and I'm looking

341
00:26:20.750 --> 00:26:24.710 
forward for your questions and for the discussions we can have about it.

342
00:26:24.820 --> 00:26:25.590 
Thank you very much.

343
00:26:28.610 --> 00:26:32.860 
Yeah um thank you very much Mathias for a very, very interesting presentation

344
00:26:33.810 --> 00:26:37.890 
and yeah we will now head to the Q and A section or discussion section.

345
00:26:38.300 --> 00:26:42.860 
So everyone feel free to raise your hand if you want to ask a question and

346
00:26:43.410 --> 00:26:44.910 
then you can just unmute yourself

347
00:26:45.730 --> 00:26:48.100 
Or if you want to participate in the discussion.

348
00:26:48.670 --> 00:26:52.220 
And I think we've already had one or two questions

349
00:26:52.220 --> 00:26:54.760 
in the chat. So the first question is

350
00:26:55.410 --> 00:26:59.960 
efficiency and security are opposing goals also for IT. So

351
00:26:59.970 --> 00:27:02.790 
measures to increase the security EG by data

352
00:27:03.230 --> 00:27:07.470 
mirroring at the data center or block-chain technologies generally

353
00:27:07.470 --> 00:27:11.060 
cause higher resource consumption. And so the question is do

354
00:27:11.060 --> 00:27:14.170 
measures to increase the resource efficiency in IT

355
00:27:14.590 --> 00:27:17.600 
have to start or also have to look at the risk management.

356
00:27:21.430 --> 00:27:24.470 
A very good question, thank you much. But also very complex question.

357
00:27:24.680 --> 00:27:28.140 
I think it depends very much.

358
00:27:28.640 --> 00:27:33.360 
There's I think you have to look at the project-

359
00:27:33.710 --> 00:27:39.940 
how and to prioritize which of these goals are more important overall.

360
00:27:40.430 --> 00:27:43.210 
Of course when you have a software that is high priority

361
00:27:43.540 --> 00:27:47.730 
for security features, you can do

362
00:27:48.520 --> 00:27:51.520 
you should focus more on that, but if you have some

363
00:27:52.030 --> 00:27:55.910 
option to also do some efficiency measurements, you

364
00:27:56.220 --> 00:28:01.210 
go more in that area. So I think it's very much depends, but I think

365
00:28:02.280 --> 00:28:08.010 
in both cases, even if you have, if you have an app that has very high security

366
00:28:08.610 --> 00:28:12.900 
goals even there's probably more options

367
00:28:13.410 --> 00:28:19.590 
to also think about efficiency that are not very obvious at the first time.

368
00:28:19.820 --> 00:28:26.630 
So I just advised you to have just some methods in mind

369
00:28:26.930 --> 00:28:30.280 
for following the green soft model or following

370
00:28:30.690 --> 00:28:34.200 
some ideas that you can do, and then when you have this in mind

371
00:28:34.200 --> 00:28:37.560 
and you design a software they are sometimes more option that

372
00:28:37.560 --> 00:28:40.490 
you think at first when you think about the project.

373
00:28:43.290 --> 00:28:46.790 
Maybe there's also some other colleagues in the

374
00:28:46.900 --> 00:28:50.470 
discussion here. If someone wants to add something you're welcome.

375
00:28:51.240 --> 00:28:55.010 
Sure Johannes here. Maybe I can add a practical

376
00:28:55.600 --> 00:29:00.590 
example there for why it might not necessarily be like opposing

377
00:29:00.590 --> 00:29:03.210 
goals, like resource efficiency and

378
00:29:04.260 --> 00:29:06.030 
data security for example.

379
00:29:06.720 --> 00:29:10.080 
In this case the question goes like for the protection goal

380
00:29:10.080 --> 00:29:14.490 
of availability of an application which is a valid security

381
00:29:16.020 --> 00:29:18.460 
pillar. Essentially to focus on.

382
00:29:19.450 --> 00:29:22.850 
And if you imagine like talking about like a really legacy

383
00:29:22.850 --> 00:29:26.440 
application, we had these like virtual servers and they

384
00:29:26.520 --> 00:29:28.860 
and they were like all these fancy technologies that allowed

385
00:29:28.860 --> 00:29:32.590 
us to move a virtual machine between hosts, and you can imagine

386
00:29:32.590 --> 00:29:35.240 
that keeping these two in sync like that consumes a lot of

387
00:29:35.240 --> 00:29:38.410 
resources, because it works at a very deep layer of the stack

388
00:29:38.530 --> 00:29:40.490 
essentially mirroring the whole machine.

389
00:29:41.240 --> 00:29:44.070 
I mean mainframes, we had the same thing even like where everything

390
00:29:44.070 --> 00:29:47.190 
was redundant. There was a second CPU, a second power supply

391
00:29:47.190 --> 00:29:50.900 
all in the same mainframe. So these things we've been discussing,

392
00:29:51.310 --> 00:29:54.450 
we've been trying to do them forever, and nowadays with the

393
00:29:54.450 --> 00:29:57.750 
cloud we have more advanced databases that are like clustered

394
00:29:57.750 --> 00:30:01.110 
by default for example that only synchronize the data and I

395
00:30:01.110 --> 00:30:04.680 
can spin up the application layer that goes on top of the data

396
00:30:04.690 --> 00:30:06.380 
to make the whole application available

397
00:30:06.820 --> 00:30:11.710 
up in seconds on the second data center. So my protecting the

398
00:30:11.710 --> 00:30:15.890 
availability of my application can cost a lot less if I do it like with

399
00:30:16.120 --> 00:30:22.700 
proper mechanisms. And so I'm not sure if it's necessarily and there's

400
00:30:22.700 --> 00:30:26.470 
like tons of other benefits of as Mathias has shown in the

401
00:30:26.470 --> 00:30:30.390 
presentation of like going serverless, because it allows for example your application to

402
00:30:30.660 --> 00:30:34.460 
scale down to zero when it's not used and all of these other

403
00:30:34.460 --> 00:30:37.750 
things. So I'm not sure if it's like if it's a good idea to

404
00:30:37.750 --> 00:30:41.670 
think about them as opposing goals. I think sometimes there

405
00:30:41.670 --> 00:30:44.610 
might be opposing forces acting on them, but there might be

406
00:30:44.610 --> 00:30:47.540 
like a better third solution out there that actually allows

407
00:30:47.540 --> 00:30:48.940 
the team to achieve both

408
00:30:49.970 --> 00:30:51.200 
goals at the same time.

409
00:30:54.430 --> 00:30:58.710 
Thank you very much. So I think it's always a measure of

410
00:30:59.480 --> 00:31:02.450 
thinking about both terms at the same time and

411
00:31:03.210 --> 00:31:04.730 
kind of finding a balance between them.

412
00:31:05.930 --> 00:31:09.170 
We have also talked in previous talks or in the Clean IT forum

413
00:31:09.320 --> 00:31:13.570 
about cloud measures or going into the cloud with your applications,

414
00:31:13.780 --> 00:31:16.630 
and so my question kind of connects to that.

415
00:31:17.630 --> 00:31:20.890 
When you think about the cloud you always have a lot of

416
00:31:22.320 --> 00:31:25.410 
more co two or energy consumption, because you have to

417
00:31:25.410 --> 00:31:27.790 
maintain a whole network of devices.

418
00:31:28.470 --> 00:31:30.840 
You always want to have the service available.

419
00:31:31.370 --> 00:31:32.690 
And so my question would be,

420
00:31:33.390 --> 00:31:39.590 
is it always more efficient to put processes or programs into

421
00:31:39.590 --> 00:31:42.290 
the cloud and host them in the cloud or could it sometimes

422
00:31:42.290 --> 00:31:45.350 
be more efficient to keep them hosted locally or

423
00:31:46.310 --> 00:31:48.000 
or on other ways?

424
00:31:51.230 --> 00:31:56.180 
Well I have a simple answer. It depends where there's a, I would say there's

425
00:31:56.580 --> 00:32:01.010 
a good solution for each of the two use cases. So there are

426
00:32:02.690 --> 00:32:05.480 
quite a few things that are more useful to be in the cloud

427
00:32:05.480 --> 00:32:10.470 
there's a few things that are more useful to be on a local client,

428
00:32:10.620 --> 00:32:12.400 
and only just running there.

429
00:32:14.130 --> 00:32:16.910 
For instance maybe it's something simple-

430
00:32:17.940 --> 00:32:22.430 
a note taking app you don't need in the browser necessarily

431
00:32:22.430 --> 00:32:26.830 
if it's only for yourself. So you can save the resources in

432
00:32:26.830 --> 00:32:29.690 
the cloud when you want to just to make some notes for yourself

433
00:32:29.690 --> 00:32:30.900 
on your client machine.

434
00:32:31.590 --> 00:32:34.350 
You don't need in the browser. But when you are more people

435
00:32:34.480 --> 00:32:39.110 
and then the use case is to have more participants working

436
00:32:39.110 --> 00:32:45.090 
on these notes together. Then you need solutions that are

437
00:32:45.240 --> 00:32:48.440 
connected, and then you want to maybe

438
00:32:49.100 --> 00:32:53.140 
put the service in a cloud and then there's more people participating it so,

439
00:32:54.690 --> 00:32:59.270 
I think it's a nice mind-set to first ask a question if

440
00:32:59.270 --> 00:33:04.650 
you have to put it in the cloud and to see if there's a solution that you can

441
00:33:05.990 --> 00:33:07.510 
put on your local machine.

442
00:33:08.910 --> 00:33:13.950 
And if not and it serves for a good purpose maybe it's nice

443
00:33:13.950 --> 00:33:16.950 
to put it in the cloud but to ask the question at the beginning

444
00:33:16.950 --> 00:33:19.940 
before you put everything in the cloud. I think it's a good start.

445
00:33:22.510 --> 00:33:24.860 
Okay thank you. So similar to the first

446
00:33:25.480 --> 00:33:28.080 
answer probably that it always kind of depends.

447
00:33:28.810 --> 00:33:31.980 
I see that the first person has answered.

448
00:33:32.620 --> 00:33:37.520 
In many cases digitization enables resource savings in the real world. Example

449
00:33:37.890 --> 00:33:41.180 
a digital twins as the basis for simulation,

450
00:33:41.820 --> 00:33:46.810 
dispensing with time consuming test series with physical products. So

451
00:33:46.970 --> 00:33:51.440 
the question is, should both worlds so the real world and the digital worlds

452
00:33:52.070 --> 00:33:54.080 
should they be considered together as one.

453
00:33:58.580 --> 00:34:01.640 
The trick if I understand the question

454
00:34:03.650 --> 00:34:08.990 
correctly. So the question is if a digital twins

455
00:34:09.500 --> 00:34:12.650 
have a ecological benefit compared to

456
00:34:14.370 --> 00:34:19.700 
you simulate things and you have some better

457
00:34:19.700 --> 00:34:23.300 
insight about the thing you want to simulate and if this is

458
00:34:23.300 --> 00:34:26.840 
actually then, using this insight is ecologically better than

459
00:34:26.840 --> 00:34:30.180 
not doing it. Is that the question? So I have opened my microphones

460
00:34:30.180 --> 00:34:34.500 
Yeah the idea behind

461
00:34:34.500 --> 00:34:40.840 
this question is, in many cases by digitalization we get rid of physical processes.

462
00:34:41.890 --> 00:34:44.330 
For example crash tests in car industry.

463
00:34:44.960 --> 00:34:48.280 
The simple example bio simulation

464
00:34:48.770 --> 00:34:54.820 
in IT. You get rid of this and you have the savings in the real world,

465
00:34:55.140 --> 00:34:58.140 
but also you have clearly resource consumption in the IT

466
00:34:58.250 --> 00:35:04.590 
but if you see the result of digitalisation, the resource consumption is lower

467
00:35:05.210 --> 00:35:09.560 
than before. That is my point or is it a out of scope in

468
00:35:09.560 --> 00:35:12.160 
your consideration. Because it is a one time

469
00:35:13.530 --> 00:35:19.260 
effect. You have only once and if you have digitalised, then it's only

470
00:35:19.450 --> 00:35:20.590 
the IT world

471
00:35:22.300 --> 00:35:27.790 
visible. Thank you for the question, and for clarifying it. Yeah, so

472
00:35:29.330 --> 00:35:32.290 
again no to the boring answer, but

473
00:35:33.310 --> 00:35:37.250 
just to your last part of the question, if you use it only once

474
00:35:37.290 --> 00:35:41.280 
and with IT, it's easier to copy things and do it again, then

475
00:35:41.280 --> 00:35:44.410 
it's probably better to let it stay in the physical world and to do it

476
00:35:45.270 --> 00:35:48.320 
there but when you reuse it several times, then it half then

477
00:35:48.320 --> 00:35:51.080 
it can have a better effect when you digitalised it.

478
00:35:51.570 --> 00:35:57.110 
So for me, I recommend to

479
00:35:57.350 --> 00:36:00.030 
have all the aspects of your skills

480
00:36:00.030 --> 00:36:05.590 
you have in mind. When you how often you do it, how energy- or how

481
00:36:06.130 --> 00:36:09.760 
higher the resource consumption is, for each of the

482
00:36:11.920 --> 00:36:16.390 
instances of the process and when you look at the overall

483
00:36:16.390 --> 00:36:20.770 
calculation, is it in total actually better, more beneficial or not.

484
00:36:20.960 --> 00:36:23.920 
And this can be very different for use cases. So

485
00:36:24.110 --> 00:36:28.690 
I would say, it's hard to say that digitization always is

486
00:36:28.690 --> 00:36:33.080 
always better or always worse. So for me I like to look at the

487
00:36:33.490 --> 00:36:37.580 
configuration of what you have, and then to make was

488
00:36:37.580 --> 00:36:39.840 
probably with some rough assumption that you need.

489
00:36:40.440 --> 00:36:45.270 
And some some perspectives on that, and at the timeline

490
00:36:45.490 --> 00:36:48.870 
and then to see at the end of the day, is it actually a good

491
00:36:48.870 --> 00:36:51.070 
idea to do this in a digital world or not.

492
00:36:53.690 --> 00:36:58.160 
And this maybe to add this and this can be quite complex because

493
00:36:58.320 --> 00:37:02.920 
I mean there's many people who are calculating with co two

494
00:37:02.920 --> 00:37:06.380 
and energy and resource consumption, and focusing on

495
00:37:06.970 --> 00:37:12.710 
that. Then combining this with the resource consumption in the software

496
00:37:12.880 --> 00:37:18.370 
context in the cloud context where it's not always clear where the

497
00:37:18.740 --> 00:37:22.330 
cause of the resource consumption is originating. It makes it

498
00:37:22.330 --> 00:37:25.050 
even complex. So this calculation is very complex,

499
00:37:26.020 --> 00:37:29.150 
and you probably have to simplify a little bit if you don't want to,

500
00:37:29.510 --> 00:37:33.830 
if you're not expert on this topic too much. But

501
00:37:34.070 --> 00:37:37.500 
with some rough calculations sometimes you might have a good

502
00:37:37.500 --> 00:37:38.520 
answer on this question.

503
00:37:42.240 --> 00:37:44.990 
Okay I hope that answers the question that

504
00:37:45.460 --> 00:37:47.690 
I also thank you for for clarifying the question.

505
00:37:49.010 --> 00:37:51.610 
So I see Max is raising his hand. Sure,

506
00:37:52.320 --> 00:37:55.260 
another question. On going into the cloud you mentioned

507
00:37:55.270 --> 00:37:59.630 
words like serverless and event driven. Would you say that approaches

508
00:37:59.630 --> 00:38:02.530 
like serverless functions and function as serverless are

509
00:38:03.270 --> 00:38:07.340 
the new energy efficient and sustainable approaches for

510
00:38:07.980 --> 00:38:08.990 
creating a back end.

511
00:38:11.760 --> 00:38:14.410 
Good question. Well like serverless is like the new

512
00:38:15.210 --> 00:38:18.880 
incarnation of the evolution of micro service as

513
00:38:19.460 --> 00:38:24.040 
some would say. I would say that it's of course

514
00:38:24.040 --> 00:38:26.850 
very useful if you have

515
00:38:27.520 --> 00:38:32.090 
somewhere complete function that you can call,

516
00:38:32.090 --> 00:38:34.930 
and then it gives you some

517
00:38:35.670 --> 00:38:40.970 
result back. But I think also here I think there are some use cases where

518
00:38:41.130 --> 00:38:44.470 
serverless can be not as efficient when you have a lot of

519
00:38:44.900 --> 00:38:47.730 
cache data for instance and you don't have a

520
00:38:47.730 --> 00:38:50.940 
lot of parallel processing. Maybe then it's better to have a process

521
00:38:51.150 --> 00:38:57.840 
running a longer time and then being called and then serving the result,

522
00:38:57.990 --> 00:39:01.510 
like whenever there's a new trigger. So

523
00:39:01.990 --> 00:39:06.260 
I would say, it's in general a good idea to first of course

524
00:39:06.260 --> 00:39:09.330 
decouple micro services and then also see into serverless.

525
00:39:10.100 --> 00:39:13.990 
But not always. But in general I would say it's often a good

526
00:39:13.990 --> 00:39:16.480 
idea to think about serverless.

527
00:39:18.370 --> 00:39:22.760 
Having in mind that it's not a one fits all solution.

528
00:39:23.270 --> 00:39:27.270 
That's I think the case for many things in IT, and in life

529
00:39:27.650 --> 00:39:32.810 
but it's I think often not a bad idea to see which potential

530
00:39:32.810 --> 00:39:35.290 
you have in your software stack to use serverless functions there.

531
00:39:36.530 --> 00:39:40.290 
Ok thank you. Here so yeah as Mathias said, serverless

532
00:39:40.290 --> 00:39:43.280 
is certainly not a silver bullet for all kinds of use cases

533
00:39:44.840 --> 00:39:48.210 
but I would say it's at least the most fine granular way to

534
00:39:48.220 --> 00:39:49.600 
split up your application,

535
00:39:51.090 --> 00:39:54.740 
and to like the most fine granular way to like skate it up and down.

536
00:39:55.460 --> 00:39:58.580 
Even a step photo from the micro services approach

537
00:40:00.980 --> 00:40:04.410 
To add one more perspective, because it connects to the question

538
00:40:04.410 --> 00:40:07.760 
that we had before of if like is the cloud always the best

539
00:40:07.760 --> 00:40:13.070 
place to run an application. The core idea behind serverless is not that

540
00:40:13.210 --> 00:40:17.080 
when it comes to sustainability at least or to the efficiency aspect of it,

541
00:40:17.360 --> 00:40:21.270 
that it is like a paradigm that's necessarily better than others.

542
00:40:21.270 --> 00:40:25.590 
However it makes very strong assumptions about the application

543
00:40:25.910 --> 00:40:29.520 
that we as developers of the application have to adhere to,

544
00:40:29.790 --> 00:40:35.070 
to allow the infrastructure to run it. And this very clean interface

545
00:40:35.070 --> 00:40:38.680 
between the infrastructure that at the end is going to cause

546
00:40:38.680 --> 00:40:42.130 
the resource consumption, right. The infrastructure is what burns

547
00:40:42.130 --> 00:40:46.190 
energy. It's not the app. I mean the app causes it to do it, but

548
00:40:46.210 --> 00:40:50.280 
how it does it is, the choice of the infrastructure and that's

549
00:40:50.280 --> 00:40:52.870 
where serverless makes very strong guarantees

550
00:40:53.670 --> 00:40:56.940 
compared to like a virtual machine which needs always

551
00:40:56.940 --> 00:41:00.500 
to run on the hypervisor. The hypervisor cannot decide to just

552
00:41:00.500 --> 00:41:04.450 
turn it off if no http request comes in. Simply because the

553
00:41:04.460 --> 00:41:07.840 
hypervisor has no visibility into any of that. It happens much

554
00:41:07.840 --> 00:41:12.060 
higher in the stack but service essentially allows the infrastructure

555
00:41:12.060 --> 00:41:16.520 
to have a much higher level contract with the application and

556
00:41:16.520 --> 00:41:20.300 
thus the infrastructure can optimize a lot more. It might move

557
00:41:20.300 --> 00:41:24.440 
your serverless application to a server that has like two percent

558
00:41:24.440 --> 00:41:29.040 
of CPU and Ram left. So these things like maximum utility utilized already

559
00:41:29.210 --> 00:41:33.280 
and you can you know get the tiniest drop of, you know resource

560
00:41:33.280 --> 00:41:35.600 
out of it without requiring a new server.

561
00:41:36.060 --> 00:41:39.640 
And that's like, that's just because the granularity is so small

562
00:41:40.020 --> 00:41:43.490 
and the application contract is so strong essentially. That's

563
00:41:43.490 --> 00:41:47.270 
why, we are able to make much smarter decisions at the infrastructure level.

564
00:41:47.930 --> 00:41:51.460 
Of course the prerequisite for this that someone's actually doing that.

565
00:41:51.590 --> 00:41:55.230 
So far that cloud providers are doing that. Cloud does

566
00:41:55.230 --> 00:41:58.780 
not mean that you couldn't do this with your own cloud like

567
00:41:58.790 --> 00:42:02.580 
you can run serverless on your own companies. It doesn't have to be

568
00:42:03.020 --> 00:42:08.260 
another company's cloud. It can be your own. It's just about really his paradigm

569
00:42:08.470 --> 00:42:12.410 
that the whole infrastructure is fully automated and that this, you know

570
00:42:12.580 --> 00:42:15.890 
dynamic provisioning and scaling of infrastructure is possible.

571
00:42:16.080 --> 00:42:20.100 
This is the aspect of cloud that we're talking about. It's not necessarily the,

572
00:42:20.410 --> 00:42:22.650 
you know it's someone else's data center aspect of it.

573
00:42:25.450 --> 00:42:28.740 
Okay but when it's not someone else's

574
00:42:29.420 --> 00:42:34.480 
data center and it's my own, then I will not optimize my own data center.

575
00:42:34.940 --> 00:42:39.560 
That much maybe. I will just run multiple cuban eata's,

576
00:42:40.140 --> 00:42:43.830 
machines, virtual machines and when I then run

577
00:42:44.480 --> 00:42:49.550 
event-driven options like function as a service. Then it won't

578
00:42:50.130 --> 00:42:52.370 
reduce or energy consumption.

579
00:42:53.650 --> 00:42:55.850 
Right and at that point, you might be better off

580
00:42:56.440 --> 00:42:59.330 
buying it from somewhere else because most likely your cost

581
00:42:59.330 --> 00:43:00.950 
of running this privately

582
00:43:01.610 --> 00:43:04.430 
should also be higher than buying it from someone else, who

583
00:43:04.430 --> 00:43:07.520 
can run it more efficiently because they have the scale and

584
00:43:07.520 --> 00:43:10.970 
they have the higher utilization and all of these things going for them.

585
00:43:11.650 --> 00:43:16.430 
Right, so like if the market was perfect and we know it isn't. But

586
00:43:17.170 --> 00:43:20.940 
you know in a market driven economy theoretically, it would

587
00:43:20.980 --> 00:43:28.570 
probably be the better option to run it somewhere else. Yeah ok, thank you.

588
00:43:31.560 --> 00:43:34.690 
Ok so I think that Tim is raising his hand, so

589
00:43:35.420 --> 00:43:36.120 
please go ahead.

590
00:43:37.870 --> 00:43:41.570 
Yes I first thank you for this great presentation. I really liked it.

591
00:43:41.980 --> 00:43:45.590 
I'm also developer architect and I also tried to bring this

592
00:43:46.500 --> 00:43:51.460 
Green Idea, Green Coding into our every day's work, and

593
00:43:51.860 --> 00:43:54.410 
you also mentioned this, and I'm always asking the same question

594
00:43:54.410 --> 00:43:56.280 
to me. This is not the question to you is-

595
00:43:57.280 --> 00:44:01.170 
I think it's all about measuring and the question is- do you know any

596
00:44:01.600 --> 00:44:05.550 
tool that supports us in our daily work. Maybe especially the

597
00:44:05.550 --> 00:44:08.810 
development phase itself, not just the usage phase, the production phase.

598
00:44:09.020 --> 00:44:12.630 
But it starts when I start working on my machine. Do you know

599
00:44:12.630 --> 00:44:15.240 
any tool that supports us

600
00:44:15.930 --> 00:44:21.040 
in measuring co two or at least energy in emissions.

601
00:44:21.650 --> 00:44:25.760 
You mentioned once like you put yourself

602
00:44:26.270 --> 00:44:30.040 
into the code, put extra code in your own software to measure

603
00:44:30.040 --> 00:44:33.610 
it, but I'm wondering I can't find it, but I'm wondering are

604
00:44:33.610 --> 00:44:36.320 
there any tools which help us on this, and

605
00:44:37.430 --> 00:44:41.890 
I think I will let some answers on this question. Also to Ferdi, who

606
00:44:42.410 --> 00:44:45.370 
has some insights about that from the course. I think that

607
00:44:45.910 --> 00:44:48.200 
first maybe I mentioned this

608
00:44:49.780 --> 00:44:58.060 
the the KPI that you asking for the development process. Ok the

609
00:44:58.290 --> 00:45:00.810 
KPI- a short presentation to calculate

610
00:45:01.920 --> 00:45:06.380 
how much energy the specific user scenario needs for instance.

611
00:45:06.870 --> 00:45:11.540 
You can measure this in time, but this is of the execution of the

612
00:45:11.680 --> 00:45:13.690 
software is basically compiled and used.

613
00:45:14.530 --> 00:45:17.650 
So when you look for the developing process

614
00:45:18.310 --> 00:45:21.830 
itself, I cannot think about anything except

615
00:45:22.260 --> 00:45:25.540 
looking afterwards like when the software is done,

616
00:45:26.190 --> 00:45:29.370 
and how long it takes the software to run and what energy it

617
00:45:29.370 --> 00:45:33.440 
needs when when you run it during the development time.

618
00:45:33.440 --> 00:45:38.010 
I cannot think about too much than the using efficient data

619
00:45:38.010 --> 00:45:39.980 
structures and writing efficient code.

620
00:45:40.750 --> 00:45:43.350 
But maybe Ferdi can add something on that.

621
00:45:46.010 --> 00:45:47.500 
Yeah I think there is actually

622
00:45:48.670 --> 00:45:52.940 
a pretty huge lack of such tooling. So we didn't find any good tuning for that.

623
00:45:53.470 --> 00:45:57.810 
There is some like, low level stuff for instance intel provides a tuning

624
00:45:58.100 --> 00:46:02.920 
that returns basically the power consumption directly from the CPU.

625
00:46:03.380 --> 00:46:06.760 
But it is like very low level programming API that there's no like

626
00:46:08.490 --> 00:46:12.490 
I don't know. ID integrations that give you the overall power consumption

627
00:46:12.800 --> 00:46:14.150 
while developing or so.

628
00:46:16.630 --> 00:46:19.630 
So yeah I think there's definitely a lack of tooling there.

629
00:46:20.170 --> 00:46:25.210 
Usually as Mathias said, he will probably end up using a proxy. I don't know

630
00:46:25.590 --> 00:46:28.410 
use run time as a proxy for energy efficiency.

631
00:46:30.430 --> 00:46:31.810 
So far there's no or

632
00:46:33.050 --> 00:46:37.900 
at least to the best of my knowledge, there's no like elaborate tooling to

633
00:46:38.410 --> 00:46:40.440 
measure the whole thing end to end.

634
00:46:42.360 --> 00:46:46.580 
Maybe someone in the audience has some ideas on this question too.

635
00:46:46.720 --> 00:46:47.510 
Johannes, sorry.

636
00:46:52.740 --> 00:46:55.820 
I think I can also say a little bit about that, so.

637
00:46:56.420 --> 00:47:00.270 
with we've also had a few talks before this of course.

638
00:47:01.540 --> 00:47:06.490 
Actually in the second or third talks, I think we spoke with someone from

639
00:47:06.780 --> 00:47:11.700 
a chair here at the HPI and they have also been creating

640
00:47:11.700 --> 00:47:16.280 
some sort of tool. I think they called it pin point or so and which also

641
00:47:16.430 --> 00:47:19.630 
they developed in order to measure the energy efficiency or

642
00:47:19.630 --> 00:47:23.590 
the energy usage of the program. When it's running I think it's

643
00:47:23.590 --> 00:47:27.880 
also quite low level. So it's not you cannot easily link it

644
00:47:27.880 --> 00:47:31.080 
to your code or to any part of the program really, but

645
00:47:31.670 --> 00:47:36.170 
I think they tried to not just look directly at the hardware

646
00:47:36.170 --> 00:47:38.760 
but go a little bit up from there.

647
00:47:39.550 --> 00:47:42.960 
And so the other part is of course to measure the energy usage

648
00:47:43.290 --> 00:47:47.180 
when the product is finished or when the program is running and that's what

649
00:47:47.410 --> 00:47:51.590 
James Krueger, which was here I think four weeks ago or two months,

650
00:47:51.920 --> 00:47:56.060 
at which they did a lot for the development of the Blue Angel Sigil

651
00:47:56.290 --> 00:47:59.680 
and so they have a lot of examples on how to create a usage

652
00:47:59.790 --> 00:48:04.310 
standard usage scenario at that test the energy consumption of that.

653
00:48:05.040 --> 00:48:08.630 
And you can also not easily link that directly to any code

654
00:48:08.630 --> 00:48:10.850 
fragment or any parts of the code.

655
00:48:11.490 --> 00:48:16.620 
But I think when you measure, when you use both, so the low level and the

656
00:48:17.020 --> 00:48:20.250 
consumption and the the usage when the product is finished,

657
00:48:20.530 --> 00:48:24.130 
then I think you can do some sort of interpolation between

658
00:48:24.130 --> 00:48:27.270 
these two, and maybe do some experiments yourself.

659
00:48:29.910 --> 00:48:32.940 
Okay thank you a lot. That's at least something and I agree it's

660
00:48:33.740 --> 00:48:36.860 
such an important topic, it's hard that we don't have sufficient

661
00:48:36.910 --> 00:48:37.860 
tooling at the moment.

662
00:48:38.960 --> 00:48:40.580 
But I see you have the same problems.

663
00:48:41.900 --> 00:48:44.610 
Thank you for these tips. I would take a look at them.

664
00:48:48.570 --> 00:48:51.230 
Okay yeah, thank you very much for the question, for the answer.

665
00:48:52.040 --> 00:48:56.500 
For the answers, so I think maybe one last question that I also have

666
00:48:56.660 --> 00:48:59.490 
I'm very glad that you mentioned the rebound effect today because

667
00:48:59.720 --> 00:49:03.390 
in the last talks it always comes up in the discussion section and

668
00:49:03.790 --> 00:49:07.580 
I'm glad that you match that by yourself already and I just

669
00:49:07.580 --> 00:49:11.080 
wanted to quickly ask do you have any examples or any methods

670
00:49:11.170 --> 00:49:14.690 
that are efficient or most important or

671
00:49:15.110 --> 00:49:17.860 
most useful against the rebound effect. So

672
00:49:18.750 --> 00:49:21.640 
maybe when you have in your consulting

673
00:49:22.550 --> 00:49:26.000 
work or or elsewhere do you have any examples for that

674
00:49:28.370 --> 00:49:30.250 
I think

675
00:49:31.570 --> 00:49:37.500 
the best is to ask yourself every day, is this necessary,

676
00:49:37.500 --> 00:49:40.420 
is this a high priority, is there something that is more important,

677
00:49:40.420 --> 00:49:41.840 
what is less important,

678
00:49:42.460 --> 00:49:47.810 
is it very important to have so much resources for us, or can

679
00:49:47.810 --> 00:49:49.140 
we live with something less.

680
00:49:50.380 --> 00:49:55.990 
Is it very important to do these three things or is there a

681
00:49:55.990 --> 00:49:59.260 
priority between them and then we can focus on the more important

682
00:49:59.260 --> 00:50:02.100 
things out of these three. So

683
00:50:03.440 --> 00:50:08.180 
I think it's a mindset, it's a thinking and you have to start

684
00:50:08.180 --> 00:50:09.970 
somewhere and I think one of the

685
00:50:11.290 --> 00:50:12.840 
easiest questions is to

686
00:50:13.500 --> 00:50:17.120 
think about- is it necessary, is it a priority

687
00:50:17.580 --> 00:50:21.030 
that we have to do this or is it a nice to have if you go with.

688
00:50:21.030 --> 00:50:26.410 
These questions I think that you can do a lot against our own human pitfall the

689
00:50:26.690 --> 00:50:27.610 
rebound effect.

690
00:50:30.680 --> 00:50:33.180 
So yeah I think the most important point

691
00:50:33.810 --> 00:50:38.210 
you kind of mentioned is that people are aware of that at least and so

692
00:50:38.550 --> 00:50:41.810 
they don't just think about well more efficiency is always better than

693
00:50:42.160 --> 00:50:47.020 
less efficiency. But they also think that this might become a problem later

694
00:50:47.610 --> 00:50:55.510 
on. Okay I think I can't see any hands raised anymore or any

695
00:50:55.510 --> 00:50:56.710 
other questions at the chat.

696
00:50:58.490 --> 00:51:02.770 
And so with that I would say thank you very much everyone. Thank you

697
00:51:03.270 --> 00:51:06.670 
Johannes, Ferdinand and Mathias for answering the questions. Thank

698
00:51:06.670 --> 00:51:08.120 
you very much again for the talk.

699
00:51:08.890 --> 00:51:10.530 
And also thank you for the discussion and

700
00:51:11.730 --> 00:51:13.040 
the interesting questions.

701
00:51:14.210 --> 00:51:17.150 
I would quickly share my screen again for the ad.

702
00:51:19.260 --> 00:51:22.250 
So I hope you can see

703
00:51:23.140 --> 00:51:24.400 
the presentation now.

704
00:51:26.380 --> 00:51:31.150 
Yes so one last thing to say at the end. We will have, we will start

705
00:51:31.290 --> 00:51:34.860 
the Clean-IT Openexchange live talk series or we will continue

706
00:51:34.860 --> 00:51:36.270 
with it in the next year.

707
00:51:37.150 --> 00:51:41.890 
And so our next live talk will be at the thirty first of January

708
00:51:42.340 --> 00:51:46.230 
with Mei Lin Fung also again at sixteen o'clock this time.

709
00:51:47.190 --> 00:51:52.490 
And we will also announce our schedule for the next year sometimes through December or

710
00:51:52.620 --> 00:51:57.800 
early January. We are still asking some participants or inviting some experts

711
00:51:58.520 --> 00:52:00.940 
and I am very excited for the next

712
00:52:01.650 --> 00:52:06.980 
experts in our live talk series and also as Mathias Renner also already mentioned

713
00:52:07.520 --> 00:52:11.790 
we will have not just one new entire course in the Clean-IT forum

714
00:52:12.180 --> 00:52:16.030 
the next year but we will also have a Clean-IT community meeting

715
00:52:16.360 --> 00:52:20.720 
which we hope of course can take place at the HPI here in

716
00:52:20.720 --> 00:52:24.990 
place in the next year, and so we hope we will start these two

717
00:52:24.990 --> 00:52:28.490 
at the same time. So around the end of March next year

718
00:52:29.660 --> 00:52:31.730 
maybe we can then see some of you

719
00:52:32.350 --> 00:52:33.940 
in person here at the HPI.

720
00:52:35.030 --> 00:52:38.920 
Yeah and so with that being said as always you can if you don't

721
00:52:38.980 --> 00:52:40.460 
have already joined the forum

722
00:52:41.120 --> 00:52:45.630 
openhpi.de/clean-it-forum, they will soon find

723
00:52:46.110 --> 00:52:49.660 
the next course next year and if you have any more questions

724
00:52:50.160 --> 00:52:52.920 
you can contact us via clean-IT@hpi.de.

725
00:52:53.680 --> 00:52:56.630 
And so, thank you very much and see you next time.

726
00:52:59.200 --> 00:53:00.940 
Goodbye.
