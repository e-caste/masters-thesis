WEBVTT

1
00:00:00.510 --> 00:00:03.380 
Ladies and gentlemen I'd like to
welcome you to the third week

2
00:00:03.380 --> 00:00:07.040 
of our course on business process
modeling and analysis. In

3
00:00:07.040 --> 00:00:09.800 
this week we will analyze
process behavior.

4
00:00:11.900 --> 00:00:17.390 
The week is organized as follows - we
have seven video clips all together.

5
00:00:17.930 --> 00:00:22.080 
Three of them are bonus material
and I will say a few words

6
00:00:22.080 --> 00:00:23.730 
in a minute about these
bonus material.

7
00:00:24.670 --> 00:00:28.960 
It's about process behavior and
how to analyze process behavior.

8
00:00:28.970 --> 00:00:32.440 
This in itself is a little bit
on the formal side, a little

9
00:00:32.440 --> 00:00:35.010 
bit on the theoretical
side but I'll try to

10
00:00:35.520 --> 00:00:41.130 
explain the concepts as informally
and as practically as I can.

11
00:00:41.410 --> 00:00:45.770 
So in video one 3.1 we define
process behavior. What

12
00:00:45.780 --> 00:00:48.530 
actually is the behavior
of the business process?

13
00:00:49.620 --> 00:00:54.010 
In the video 3.2 we look
at structural soundness

14
00:00:54.010 --> 00:00:59.310 
or structural soundness is a
prerequisite for soundness as which is

15
00:00:59.520 --> 00:01:03.300 
the criterion that we will
look at in this week.

16
00:01:03.890 --> 00:01:08.370 
So video 3.3 looks at
soundness and explains in an

17
00:01:08.380 --> 00:01:12.150 
informal way how soundness what
soundness is what soundness can

18
00:01:12.150 --> 00:01:13.730 
be applied to
processes.

19
00:01:14.780 --> 00:01:19.560 
In video 3.4 we look at
simulating business processes

20
00:01:19.670 --> 00:01:23.430 
before we start the bonus material,
and the bonus material is

21
00:01:23.430 --> 00:01:27.540 
still on the informal side but
again a bit more formal than

22
00:01:27.900 --> 00:01:30.850 
what we discussed
earlier in this week.

23
00:01:31.900 --> 00:01:36.160 
So 3.5 looks at an informal
petri net primer, presents

24
00:01:36.160 --> 00:01:41.770 
petri nets which is a formal foundation
of behavioral analysis of processes,

25
00:01:42.280 --> 00:01:46.530 
explains petri net in a very
informal brief way also.

26
00:01:47.760 --> 00:01:52.780 
Afterwards in 3.6 we map BPMN
process models to petri nets

27
00:01:53.280 --> 00:01:58.560 
and in 3.7 we use petri nets to check
soundness. To check soundness

28
00:01:58.920 --> 00:02:02.670 
of the BPMN process model,
so that we know that's the

29
00:02:02.680 --> 00:02:04.980 
BPMN process model
is correct.

30
00:02:06.390 --> 00:02:10.220 
In the bonus homeworks you can
own additional points. So it's

31
00:02:10.220 --> 00:02:12.960 
not only that we have the bonus
videos but there will also

32
00:02:12.960 --> 00:02:18.350 
be a bonus homework and these go
on top of the normal points.

33
00:02:18.350 --> 00:02:22.500 
So you can own additional points,
so that you can improve your

34
00:02:22.500 --> 00:02:25.700 
overall score that you
achieve in this course.

35
00:02:30.440 --> 00:02:34.110 
In week two we looked at
the syntax and all, this

36
00:02:34.110 --> 00:02:39.010 
is the semantics of modeling languages in
particular process modeling languages.

37
00:02:39.670 --> 00:02:44.540 
And we define syntax as well
syntactic correctness

38
00:02:45.090 --> 00:02:48.800 
makes sure that the elements of
the model are organized in a way

39
00:02:49.360 --> 00:02:53.220 
that matches the abstract syntax
of the modeling language . And

40
00:02:53.220 --> 00:02:58.850 
as an example I have again this
claim insurance claim process

41
00:02:58.850 --> 00:03:00.950 
model that we discussed
earlier already.

42
00:03:01.500 --> 00:03:04.670 
So here we can track whether
it's syntactically correct. So

43
00:03:04.670 --> 00:03:08.370 
what we do we need to check their
well we can take a look at

44
00:03:08.780 --> 00:03:13.130 
the start event. The start event
does not have any incoming

45
00:03:13.130 --> 00:03:17.220 
edges that would be syntactically
incorrect. Start events do not have

46
00:03:17.350 --> 00:03:22.330 
incoming a flow edges and the end
events do not have any outgoing

47
00:03:22.330 --> 00:03:24.230 
flow edges, also
that is correct.

48
00:03:25.130 --> 00:03:27.270 
We have a number
of activities

49
00:03:28.530 --> 00:03:32.480 
and we have one gateway and these
are connected by sequence

50
00:03:32.480 --> 00:03:36.020 
flow and also the sequence
flow each sequence flow edge

51
00:03:36.300 --> 00:03:40.860 
is connecting exactly two
nodes so that this process

52
00:03:40.860 --> 00:03:44.570 
more we can say is technically
correct even if we look at the

53
00:03:44.710 --> 00:03:48.330 
at the role here insurance company
that is we would say that is a

54
00:03:48.650 --> 00:03:52.660 
syntactically correct process
model expressed in the BPMN.

55
00:03:52.660 --> 00:03:56.250 
So it complies to the abstract
syntax of the BPMN.

56
00:03:58.610 --> 00:03:59.970 
So how about semantics?

57
00:04:00.760 --> 00:04:04.560 
Well the semantics
of a process model

58
00:04:05.050 --> 00:04:08.400 
defines the meaning of syntactically
correct process models.

59
00:04:08.410 --> 00:04:11.460 
We only need to have a meaning for a
syntactically correct process model.

60
00:04:12.940 --> 00:04:17.010 
The meaning is the behavior defined
by the process model which is

61
00:04:17.220 --> 00:04:19.410 
the order of performed
activities.

62
00:04:20.290 --> 00:04:25.100 
So in this example again we
see simple simple process

63
00:04:25.100 --> 00:04:28.810 
simple behavior so we have an
event that occurs that is

64
00:04:28.810 --> 00:04:33.140 
the claim received event, the event
that occurs in the beginning.

65
00:04:39.570 --> 00:04:43.800 
Alright here we go. So that is
the first event that occurs

66
00:04:45.190 --> 00:04:50.290 
and after that event occurs
register claim is executed decide

67
00:04:50.290 --> 00:04:52.990 
on claim coverage and then there
is a decision. Either we go to

68
00:04:52.990 --> 00:04:57.450 
the upper branch or we go the lower
branch either of the two for each

69
00:04:57.800 --> 00:05:01.330 
for each process instance either
the upper branch is taken

70
00:05:01.330 --> 00:05:04.260 
or the lower branch is taken. And
that's basically the semantics

71
00:05:04.260 --> 00:05:04.950 
of this process.

72
00:05:07.990 --> 00:05:10.800 
We were discussing syntactical
correctness and now we

73
00:05:10.800 --> 00:05:12.900 
turn to semantic
correctness.

74
00:05:13.770 --> 00:05:17.550 
Semantic correctness needs to
ensure that the process behaves

75
00:05:17.550 --> 00:05:19.630 
correctly and
terminates properly.

76
00:05:20.440 --> 00:05:24.550 
So and this example shows
that we can build

77
00:05:25.130 --> 00:05:31.200 
process models that are syntactically
correct but they have semantic

78
00:05:31.300 --> 00:05:35.720 
they are semantically incorrect,
they have a flaw. That is

79
00:05:35.810 --> 00:05:40.060 
let's say undesirable in process models
so we need to be able to detect

80
00:05:40.260 --> 00:05:44.630 
these kinds of flaws and this is
exactly what we aim at in this week.

81
00:05:46.170 --> 00:05:50.310 
Alright so semantic correctness
ensures that a process behaves

82
00:05:50.310 --> 00:05:52.130 
correctly and
terminates properly.

83
00:05:53.070 --> 00:05:57.690 
And to analyze in semantic
correctness the process model

84
00:05:57.690 --> 00:06:02.250 
needs to be checked for the absence
of behavioral anomalies we call it.

85
00:06:02.950 --> 00:06:08.230 
So let's take a look at this process model.
It's a variant of an order process

86
00:06:09.070 --> 00:06:11.860 
in which first we
analyze the order,

87
00:06:13.370 --> 00:06:16.750 
we receive the order which is
modelled as an activity here,

88
00:06:18.440 --> 00:06:21.780 
then we have concurrent
branches. So we can

89
00:06:23.060 --> 00:06:26.870 
package the product and ship or
issue the shipment concurrently

90
00:06:26.870 --> 00:06:30.210 
to sending the invoice and
receiving the payment only after

91
00:06:30.210 --> 00:06:32.100 
these two and there
is the AND split.

92
00:06:32.700 --> 00:06:36.060 
Only after these two branches
have completed we have

93
00:06:36.060 --> 00:06:40.540 
the synchronizing behavior of
the AND joins or the AND join

94
00:06:40.850 --> 00:06:45.390 
here. And only if these two
branches terminate then the

95
00:06:45.390 --> 00:06:48.750 
next activity can be started
which is checking the payment.

96
00:06:50.060 --> 00:06:53.100 
In this process model is represented
that the check payment

97
00:06:53.100 --> 00:06:58.900 
has two outcomes, two possible
outcomes. One is if the amount

98
00:06:58.900 --> 00:07:00.750 
is invalid. So
here we have

99
00:07:01.500 --> 00:07:04.250 
our condition attached
here invalid amount.

100
00:07:04.810 --> 00:07:09.350 
If the amount is invalid, we need
to send an updated invoice

101
00:07:09.750 --> 00:07:12.550 
to make sure that
we receive

102
00:07:13.180 --> 00:07:14.770 
all the outstanding
funds.

103
00:07:15.550 --> 00:07:20.480 
Although the remaining funds that
have not been paid so far.

104
00:07:21.200 --> 00:07:26.860 
Alright so let's assume we go the lower way
so the cheque payment activity resulted

105
00:07:27.150 --> 00:07:31.200 
an invalid amount to be true. So
the amount was not valid. We

106
00:07:31.200 --> 00:07:34.680 
send an updated
invoice and then so

107
00:07:35.630 --> 00:07:42.190 
and then we go to this
and XOR join again

108
00:07:42.720 --> 00:07:46.670 
and what we do is we wait for receiving
the payment. Assume the payment comes,

109
00:07:47.030 --> 00:07:50.360 
we receive the payment. So we are at
this position exactly and we have

110
00:07:50.620 --> 00:07:54.070 
completed the receive payment activity.
So what happens in this process?

111
00:07:54.770 --> 00:07:58.710 
Well it should continue

112
00:07:59.440 --> 00:08:03.160 
but this is not what happens.
Actually this AND join

113
00:08:04.060 --> 00:08:08.950 
AND join here waits for both incoming
edges to be signalled. And

114
00:08:08.950 --> 00:08:12.380 
here in this case only one incoming
edge is signalled namely the

115
00:08:12.380 --> 00:08:16.090 
one from the receive payment activity.
Therefore the process gets stuck

116
00:08:16.400 --> 00:08:20.090 
so it's a perfectly correct
process model from

117
00:08:20.090 --> 00:08:24.960 
a syntactic point of view but it has
this semantic error semantic flaw

118
00:08:25.210 --> 00:08:27.470 
that it gets stuck it
might get stuck.

119
00:08:28.580 --> 00:08:32.110 
If the other branch would
be chosen in the first

120
00:08:32.400 --> 00:08:35.360 
after the first cheque payment
activity than the process would

121
00:08:35.550 --> 00:08:40.260 
would terminate properly. But there are
cases in which the process does not

122
00:08:40.600 --> 00:08:44.010 
complete properly and this is a
semantic incorrectness that we

123
00:08:44.010 --> 00:08:46.330 
should be able
to detect.

124
00:08:47.690 --> 00:08:52.710 
So this week we explain correct
process behavior in an informal way.

125
00:08:53.260 --> 00:08:56.520 
And as mentioned before as bonus
material we also introduce

126
00:08:56.520 --> 00:09:00.510 
petri nets and a mapping from BPMN
process models to petri nets

127
00:09:00.730 --> 00:09:03.830 
for a more formal investigation
of correctness.

128
00:09:06.890 --> 00:09:11.140 
Process behavior was specified
so far also informally.

129
00:09:11.140 --> 00:09:15.010 
So this activity is executed and the
other activity has been executed.

130
00:09:15.670 --> 00:09:19.740 
Here we will make it a bit more
precise. So the behavior

131
00:09:19.740 --> 00:09:24.000 
of a process model can be characterized
by the set of all execution

132
00:09:24.000 --> 00:09:26.750 
sequences that are
possible in this model.

133
00:09:28.200 --> 00:09:30.450 
Therefore we look
at the traces

134
00:09:31.080 --> 00:09:36.210 
of the process model resulting from events that
occur and activities that are performed.

135
00:09:36.670 --> 00:09:41.290 
So we look at activities that are
performed and events that occur.

136
00:09:41.760 --> 00:09:46.470 
And we build we build
sequences of these

137
00:09:46.910 --> 00:09:51.780 
events and activity in the available
traces or so to speak traces

138
00:09:52.090 --> 00:09:55.890 
of the process and the resulting
semantics. Therefore they are called

139
00:09:55.890 --> 00:09:59.390 
trace semantics. So the trace are
the steps that are taken during

140
00:09:59.600 --> 00:10:01.030 
execution of
the process.

141
00:10:02.330 --> 00:10:07.200 
Ok so this another example again.
What are the traces? And

142
00:10:08.850 --> 00:10:13.350 
each trace begins with a claim
received. So there's a

143
00:10:13.360 --> 00:10:16.830 
trace claim received, register
claim, decide on claim coverage,

144
00:10:17.330 --> 00:10:20.940 
prepare a letter of approval and
claim approved. That's one trace

145
00:10:21.310 --> 00:10:25.220 
one possible execution of the
process. So we see that not all

146
00:10:25.220 --> 00:10:30.200 
activities need to be present in all traces.
Of course we have the decision here.

147
00:10:32.130 --> 00:10:38.040 
But there's another trace and
another trace starts like

148
00:10:38.050 --> 00:10:41.660 
like the first one. So receiving
the claim, registering the claim

149
00:10:41.670 --> 00:10:46.250 
decide on claim coverage. But then
prepare letter of rejection is

150
00:10:46.720 --> 00:10:50.760 
executed and the claim is rejected.
So there are two traces

151
00:10:50.760 --> 00:10:53.020 
this process more or less
exactly two traces.

152
00:10:55.620 --> 00:11:00.010 
So this is shown here again,o
traces in the example

153
00:11:01.150 --> 00:11:06.310 
traces in the example are exactly
the two traces we we can see here.

154
00:11:07.170 --> 00:11:14.190 
So yeah first the first
one goes until

155
00:11:14.810 --> 00:11:17.370 
approval takes the upper branch
and the second one takes the

156
00:11:17.370 --> 00:11:19.950 
lower branch. So there are exactly
these two traces for this

157
00:11:19.950 --> 00:11:20.660 
process model.

158
00:11:23.450 --> 00:11:28.560 
In behavioral analysis we abstract
from the actual running states

159
00:11:28.730 --> 00:11:32.600 
of an activity and so we said
this activity happens that this

160
00:11:32.600 --> 00:11:35.620 
activity is executed this activity
is executed. So we are not

161
00:11:35.620 --> 00:11:39.910 
really interested in the running phase
itself and this is appropriate

162
00:11:39.910 --> 00:11:42.900 
since we're interested in the
logical ordering of the activities

163
00:11:42.990 --> 00:11:46.860 
and not in the activity executions
themselves. So just interested

164
00:11:47.110 --> 00:11:50.750 
in the behavioral analysis
looking for behavioral flaws.

165
00:11:51.210 --> 00:11:56.380 
So what do we actually do when we analyze
the semantics using the trace semantics?

166
00:11:56.760 --> 00:11:59.990 
An activity goes directly
from the ready state

167
00:12:00.490 --> 00:12:01.780 
to the terminated
state.

168
00:12:02.560 --> 00:12:05.870 
So there is a bypass so to speak
of the running state because

169
00:12:06.420 --> 00:12:10.220 
activity that is ready then
in one step is terminated.

170
00:12:11.790 --> 00:12:16.350 
We might even see that a bit more clear in
this example that exhibits concurrency.

171
00:12:16.890 --> 00:12:21.410 
So concurrency results in traces with
an arbitrary ordering of concurrent

172
00:12:21.590 --> 00:12:23.850 
activities. So in this
abstract example

173
00:12:24.560 --> 00:12:28.580 
we have different races. So
each trace starts with with

174
00:12:28.580 --> 00:12:34.180 
the event I, so we start we
label the start event I

175
00:12:34.820 --> 00:12:39.840 
last event O. Reasons will
be discussed in a minute,

176
00:12:39.840 --> 00:12:41.470 
or later this week
I should say.

177
00:12:42.230 --> 00:12:45.530 
So the first activity
that happens here is A.

178
00:12:47.570 --> 00:12:49.690 
Ok let's highlight
that, that's the A.

179
00:12:50.160 --> 00:12:56.120 
And then we have concurrency and in concurrency
we learn that the execution paths

180
00:12:56.370 --> 00:13:00.770 
are independent from each others.
So B and D can be executed

181
00:13:01.260 --> 00:13:03.730 
independently. So
either B can start

182
00:13:04.500 --> 00:13:08.390 
B can be executed start
can be executed

183
00:13:08.960 --> 00:13:14.320 
and then after B has been executed
C or D can be executed.

184
00:13:15.830 --> 00:13:19.340 
And so let's assume
D is executed or D

185
00:13:19.840 --> 00:13:24.440 
happens I should say. Afterwards
E might happen or C might

186
00:13:24.440 --> 00:13:27.650 
happen. And only but only
if all of these five

187
00:13:28.150 --> 00:13:33.000 
activities have been have
occurred have happened we

188
00:13:33.360 --> 00:13:37.310 
need to perform F. So F happens
and then the final event

189
00:13:37.780 --> 00:13:39.180 
the output event
happens.

190
00:13:40.540 --> 00:13:43.420 
Alright so here we
have not just

191
00:13:44.050 --> 00:13:49.110 
two traces as we have a number
of traces and we have here

192
00:13:49.590 --> 00:13:52.330 
i've shown here the
traces. The first one

193
00:13:53.050 --> 00:13:55.550 
that is a sorry
I need to

194
00:13:56.840 --> 00:13:58.230 
use the highlighter
again.

195
00:13:59.110 --> 00:14:05.300 
The first one
is I, so I A

196
00:14:07.050 --> 00:14:10.720 
D, no sorry.

197
00:14:12.370 --> 00:14:17.430 
So let's erase all that to
make it a bit more clear.

198
00:14:18.130 --> 00:14:22.520 
So we now investigate the first
the first trace here. The first

199
00:14:22.520 --> 00:14:27.750 
trace starts with I, then we have
the A, then we have the B,

200
00:14:28.380 --> 00:14:30.250 
then we have the D,

201
00:14:31.070 --> 00:14:36.430 
then we have the C and the E, finally
the F and the O. So that's one

202
00:14:36.850 --> 00:14:39.500 
one way of executing this.
So the first trace.

203
00:14:40.050 --> 00:14:42.950 
The second trace we have a different
ordering of the concurrent

204
00:14:42.950 --> 00:14:47.250 
activities. So we first have
B and C and then D and E.

205
00:14:47.900 --> 00:14:52.450 
In the last one we also have a different
ordering of the concurrent activities. We have

206
00:14:52.610 --> 00:14:55.590 
we start with D and E
and then have B and C.

207
00:14:56.510 --> 00:14:59.980 
So you see if there's concurrently
if there's concurrence in

208
00:14:59.980 --> 00:15:05.430 
a process model we have a larger
state space, more states can be

209
00:15:05.950 --> 00:15:09.030 
process can be in more states
and that makes it far more

210
00:15:09.040 --> 00:15:12.530 
complex than just having sequential
execution like we've seen in

211
00:15:12.530 --> 00:15:13.590 
the first example.

212
00:15:15.850 --> 00:15:19.230 
Right in general all traces
are allowed in which I A

213
00:15:19.730 --> 00:15:24.440 
is followed by any ordering of B C D
and E where B occurs before C and D

214
00:15:24.560 --> 00:15:28.120 
occurs before E followed
by F and the O.

215
00:15:31.350 --> 00:15:35.550 
Ok we now need to look at loops
and here in this example

216
00:15:35.550 --> 00:15:41.190 
we have a loop from well see it
after executing the first part

217
00:15:41.190 --> 00:15:43.060 
of the process we
can step back to A

218
00:15:43.750 --> 00:15:47.100 
which it is used
as a join node.

219
00:15:48.030 --> 00:15:52.180 
And here we can have loops of
arbitrary length depending

220
00:15:52.180 --> 00:15:55.350 
on the number of iterations the
number of iteration is not

221
00:15:55.350 --> 00:15:56.830 
fixed. So they can be

222
00:15:57.570 --> 00:16:01.710 
it can be loops of arbitrary
lengths and one example is here I

223
00:16:01.710 --> 00:16:05.730 
would not discuss that. I think it's
quite clear. After the first iteration

224
00:16:05.950 --> 00:16:11.120 
of these activities I can jump back one loop
iteration one possible loop iteration

225
00:16:11.640 --> 00:16:13.250 
a trace is shown here.

226
00:16:16.470 --> 00:16:19.270 
Also I did that once for two
loop iteration but you can of

227
00:16:19.270 --> 00:16:23.460 
course expand that to any number
of loop iterations which

228
00:16:23.470 --> 00:16:25.390 
increases the length of
the trace of course.

229
00:16:26.830 --> 00:16:30.500 
Alright that concludes video
clip 3.1 in which we

230
00:16:30.800 --> 00:16:34.350 
introduced process behavior, we
looked at syntactic correctness

231
00:16:34.350 --> 00:16:38.580 
but also semantic correctness which
means the behavior of a process model.

232
00:16:39.390 --> 00:16:43.000 
We looked at an example where
we have a behavioral anomaly

233
00:16:43.420 --> 00:16:47.810 
and we introduced traces as a
means to characterize behavior.
