WEBVTT

1
00:00:00.850 --> 00:00:04.760 
Welcome to video clip 2.3
in which we will investigate

2
00:00:04.770 --> 00:00:06.970 
exclusive and
parallel gateways.

3
00:00:08.010 --> 00:00:13.590 
So far we only have seen sequential flow
in the process but of course that's

4
00:00:13.950 --> 00:00:18.370 
not sufficient to express what we
like to express for business processes.

5
00:00:19.130 --> 00:00:24.270 
And therefore we look at the application
scenario continue the application scenario

6
00:00:24.530 --> 00:00:30.090 
with the parts that are shown
in black here. So the grey

7
00:00:30.090 --> 00:00:33.400 
which is greyed out we already
already took a look at. So

8
00:00:33.400 --> 00:00:36.400 
we look now at this new
material here shown in black.

9
00:00:37.170 --> 00:00:42.380 
So this is followed by checking whether
the ordered product is available in

10
00:00:42.610 --> 00:00:47.060 
inventories. This is done after
entering the details

11
00:00:47.060 --> 00:00:48.820 
of an order in an
IT system.

12
00:00:49.920 --> 00:00:53.370 
If the product is available it will
be obtained from the warehouse

13
00:00:53.580 --> 00:00:57.460 
otherwise the materials for the
product needs to be obtained

14
00:00:57.470 --> 00:01:01.720 
and the product be
manufactured. So we look at

15
00:01:02.230 --> 00:01:05.820 
at a situation when the material
is not in the warehouse

16
00:01:05.820 --> 00:01:07.470 
and we need to do
something else.

17
00:01:09.260 --> 00:01:13.840 
Basics to gateways or sequence
flow can only express

18
00:01:13.840 --> 00:01:17.470 
the ordering of activities in terms
of sequences which is often

19
00:01:17.580 --> 00:01:19.450 
not sufficient
as mentioned

20
00:01:20.060 --> 00:01:24.210 
a rich execution conditions can
be expressed using gateways.

21
00:01:24.800 --> 00:01:28.680 
Gateways have the generic shape of
a diamond and are supplemented

22
00:01:28.680 --> 00:01:31.560 
with a symbol that
specifies their behavior.

23
00:01:32.240 --> 00:01:36.500 
And gateways can be used for
splitting and joining sequence flow.

24
00:01:36.830 --> 00:01:41.620 
And in this section we introduce
the data base exclusive gateway.

25
00:01:42.440 --> 00:01:47.650 
This is also called exclusive gateway
or XOR gateway and also the parallel

26
00:01:47.770 --> 00:01:49.320 
gateway or the
AND gateway.

27
00:01:50.920 --> 00:01:54.780 
Let's start with the exclusive gateway.
The exclusive gateway can be used

28
00:01:55.190 --> 00:01:57.750 
as split and
join node

29
00:01:58.420 --> 00:02:02.770 
and looking at the split it's
called XOR split XOR stand

30
00:02:02.770 --> 00:02:08.350 
for exclusive OR split
so exclusive OR split

31
00:02:08.940 --> 00:02:13.970 
meaning from a set of alternatives
exactly one alternative is chosen.

32
00:02:14.670 --> 00:02:18.500 
So these XOR has an
incoming edge and

33
00:02:19.070 --> 00:02:21.220 
several outgoing edges

34
00:02:22.080 --> 00:02:28.010 
and only exactly one of the outgoing
edges is chosen at each signaling

35
00:02:28.280 --> 00:02:29.840 
of the XOR split.

36
00:02:31.410 --> 00:02:33.760 
Conditions attached to
the outgoing edges

37
00:02:34.220 --> 00:02:39.880 
are evaluated and these decisions
are used to decide which

38
00:02:39.890 --> 00:02:44.710 
way is taken which of the outgoing
sequence flow conditional

39
00:02:44.710 --> 00:02:49.840 
sequence flows are chosen flow is chosen
to say so just as one is chosen.

40
00:02:50.770 --> 00:02:54.230 
On the other side we have the
XOR join the exclusive OR join

41
00:02:54.230 --> 00:02:58.510 
and these this construct is used
to merge the past. So in the

42
00:02:58.510 --> 00:03:01.780 
XOR split we spread out so there
are different alternatives

43
00:03:01.980 --> 00:03:05.870 
and these different alternatives
will then be merged

44
00:03:06.060 --> 00:03:10.760 
again in the XOR join and this is
also called exclusive OR join again

45
00:03:10.980 --> 00:03:12.990 
XOR for the
exclusive OR.

46
00:03:14.300 --> 00:03:18.490 
So this construct merges alternative
path and for each incoming

47
00:03:18.710 --> 00:03:22.890 
sequence flow that is signaled an
outgoing sequence flow

48
00:03:23.040 --> 00:03:28.150 
is generated. So let's look at
the example we have here.

49
00:03:28.150 --> 00:03:32.440 
In the lower part of the
picture we have here the XOR

50
00:03:32.960 --> 00:03:36.980 
a gateway that is a split gateway
one incoming agent several

51
00:03:36.980 --> 00:03:41.300 
outgoing edges and you see the conditions
of the gateway attached to the

52
00:03:41.460 --> 00:03:42.940 
outgoing sequence flow

53
00:03:43.660 --> 00:03:47.480 
and the conditions a product in stock
or product not in stock. So after

54
00:03:48.160 --> 00:03:53.350 
we check the inventory availability
we can decide whether the product

55
00:03:53.740 --> 00:03:57.770 
is instead if the product is in
stock we obtain it from the whales

56
00:03:57.880 --> 00:04:01.520 
if the product is not as developed
to first obtain it and then

57
00:04:01.730 --> 00:04:04.480 
manufacture the product
to continue the process

58
00:04:05.040 --> 00:04:09.130 
the XOR joy and then merges
these two alternative paths

59
00:04:09.620 --> 00:04:14.520 
our purpose again so that in any case
we package the product afterwards.

60
00:04:15.010 --> 00:04:19.110 
So each process instance
starts here in the beginning

61
00:04:20.100 --> 00:04:25.020 
and it might go this way or it
might go that way so each process

62
00:04:25.020 --> 00:04:28.780 
instance either goes the other way
or the lower away.

63
00:04:31.870 --> 00:04:37.820 
Ok now what is the exact semantics
of this? We need to detail this

64
00:04:38.430 --> 00:04:43.500 
a bit more. So the exclusive
gateway semantics. The semantics

65
00:04:43.500 --> 00:04:46.210 
of the XOR split
in more detail

66
00:04:47.050 --> 00:04:50.400 
and we do we discuss this in the
example you see here on the

67
00:04:50.400 --> 00:04:54.950 
right-hand side where we have abstract
examples. So at this point abstract examples of

68
00:04:55.800 --> 00:05:00.610 
you are good to explain the
key concepts of the XOR split.

69
00:05:01.050 --> 00:05:09.080 
We have the activities A B C D E and
we have one exclusive or split

70
00:05:10.340 --> 00:05:12.010 
here and
there are these

71
00:05:12.760 --> 00:05:15.720 
conditions attached, condition
one condition two condition

72
00:05:15.720 --> 00:05:22.110 
three and then there is one sequence
flow with this little black line

73
00:05:22.300 --> 00:05:24.370 
and this is called
the default flow.

74
00:05:26.110 --> 00:05:29.720 
Right the standard says that these
conditions are once activity

75
00:05:29.720 --> 00:05:30.940 
A has been executed

76
00:05:32.390 --> 00:05:37.550 
we need to evaluate we need to decide
which way to take actually.

77
00:05:37.990 --> 00:05:41.520 
And this is done by
evaluating the conditions

78
00:05:42.090 --> 00:05:47.030 
of the outgoing edges of the XOR split
and this is done in specific order.

79
00:05:47.990 --> 00:05:51.250 
We do not know in which order
that will be so the model does

80
00:05:51.250 --> 00:05:54.430 
not tell us in which order these
conditions will be evaluated.

81
00:05:54.720 --> 00:05:57.820 
It's not that condition one
condition two condition three is

82
00:05:57.820 --> 00:06:01.190 
evaluated in that order it can be
in any order almost in any order.

83
00:06:03.260 --> 00:06:07.910 
So the default flow is always the
last which has been which has been

84
00:06:08.310 --> 00:06:13.360 
Evaluated. So other than that we
have no information about the ordering

85
00:06:13.710 --> 00:06:16.080 
in which these conditions
are evaluated.

86
00:06:19.280 --> 00:06:24.010 
The arc of the first condition
evaluated to true is then signaled.

87
00:06:24.250 --> 00:06:27.610 
So using the specific order the
first condition that evaluates

88
00:06:27.610 --> 00:06:33.790 
the true that will be chosen and the
respective arc will be triggered.

89
00:06:34.830 --> 00:06:36.720 
All other arcs will
be discarded.

90
00:06:37.730 --> 00:06:40.720 
There can be a default flaw which
is evaluated lost and its

91
00:06:40.720 --> 00:06:45.930 
condition is always evaluated to true.
And default is of course useful

92
00:06:46.210 --> 00:06:49.590 
otherwise there's a danger that
the process get stuck here

93
00:06:49.590 --> 00:06:53.210 
if all conditions are due to falls
the process could not continue

94
00:06:53.540 --> 00:06:57.080 
in this case the default flow helps
us to deal with this situation

95
00:06:57.080 --> 00:06:58.250 
and continue
the process.

96
00:06:59.380 --> 00:07:04.040 
Let's look at the example and let
the real evaluation ordering

97
00:07:04.040 --> 00:07:08.420 
the condition, one condition three
condition two default, that's

98
00:07:08.420 --> 00:07:13.260 
possible since default is the
last in this ordering and

99
00:07:13.540 --> 00:07:17.690 
we don't know which in general
we cannot deduce from

100
00:07:17.690 --> 00:07:20.390 
the model of the order in which
the conditions will be evaluated.

101
00:07:21.280 --> 00:07:25.380 
Ok so let condition one which is
evaluated first evaluate to

102
00:07:25.380 --> 00:07:29.000 
false so we need to look at the
next one. Let condition three

103
00:07:29.000 --> 00:07:34.350 
evaluate to true, very good. So
condition three is evaluated to

104
00:07:34.540 --> 00:07:40.040 
true and then D is executed and
the others are not executed.

105
00:07:40.040 --> 00:07:45.040 
So B is not executed C is not executed
E is not executed, D is started.

106
00:07:46.530 --> 00:07:50.430 
Now we can come back to what
we took a look at in

107
00:07:50.430 --> 00:07:55.640 
the previous video and that is
the state transition diagram

108
00:07:55.640 --> 00:07:58.350 
of activity instances.
aAd here we see that

109
00:07:58.770 --> 00:08:02.740 
all activities are in the init state,
initially are in the init state

110
00:08:03.490 --> 00:08:08.230 
and once B is selected B C and E are
no longer required therefore

111
00:08:08.270 --> 00:08:12.500 
B C and E can go to the skipped
State. This is an example

112
00:08:12.620 --> 00:08:16.530 
where activity in system from
the init state to the skipped

113
00:08:16.540 --> 00:08:20.490 
state and of course d selected
goes from the init state

114
00:08:20.650 --> 00:08:23.160 
to the ready state and is
then ready for execution.

115
00:08:28.240 --> 00:08:33.080 
It's worth mentioning that the XOR
semantics or the semantics that exactly one

116
00:08:33.680 --> 00:08:39.790 
branch is chosen is preserved
even if the conditions of the

117
00:08:40.540 --> 00:08:44.900 
of the edges are overlapping. By
overlapping conditions I mean

118
00:08:44.900 --> 00:08:48.520 
that in a given situation several
conditions evaluate to true

119
00:08:48.520 --> 00:08:53.810 
at the same time. So this is not forbidden
this is not forbidden by BPMN.

120
00:08:54.270 --> 00:08:58.070 
So let's see how BPMN would
handle it using an example.

121
00:08:58.490 --> 00:09:04.250 
So we have again the three conditions -
condition one, condition two, condition three.

122
00:09:04.970 --> 00:09:08.170 
And the condition one might be
cost less than two hundred,

123
00:09:08.580 --> 00:09:12.100 
condition two cost is less than
thousand and condition three

124
00:09:12.100 --> 00:09:14.000 
cost is less than
ten thousand.

125
00:09:14.850 --> 00:09:17.670 
And the evaluation ordering is
the same as before - condition

126
00:09:17.670 --> 00:09:19.550 
one condition three
condition two.

127
00:09:20.990 --> 00:09:25.280 
And assume that a data
object cost has the value

128
00:09:25.280 --> 00:09:27.930 
of five hundred for a
particular process instance.

129
00:09:31.390 --> 00:09:38.080 
Ok so what happens in the case
that cost equals five hundred?

130
00:09:39.230 --> 00:09:42.920 
So first condition one is evaluated
cost is five hundred and

131
00:09:43.320 --> 00:09:47.560 
five hundred is not smaller than
two hundred so condition one

132
00:09:47.560 --> 00:09:50.870 
evaluates to false does not take
we need to evaluate the next

133
00:09:51.430 --> 00:09:55.260 
Condition. Condition three
is that evaluated

134
00:09:56.070 --> 00:09:58.030 
as the order of
evaluation tells us

135
00:09:58.680 --> 00:10:02.070 
the cost is less than five hundred
is less than ten thousand

136
00:10:02.070 --> 00:10:07.960 
Yes, so condition three is evaluated
to true and again the starts.

137
00:10:08.920 --> 00:10:14.630 
So in this case and all B is not
started C is not started E is started

138
00:10:15.250 --> 00:10:19.240 
so we have again the XOR
semantics is correct, exactly one

139
00:10:19.240 --> 00:10:24.950 
of the outgoing branches is
chosen but if the evaluation

140
00:10:24.950 --> 00:10:28.380 
ordering would be a different one
if condition two would be

141
00:10:28.380 --> 00:10:33.160 
evaluated before condition three then
condition two would be selected.

142
00:10:33.640 --> 00:10:38.730 
So that means from the model you cannot
tell if you have overlapping conditions

143
00:10:38.840 --> 00:10:43.090 
which in certain situations which of
the branches are actually taken.

144
00:10:44.890 --> 00:10:48.650 
So the old and of course notice that
the ordering of the evaluation

145
00:10:48.650 --> 00:10:52.660 
is not related to the layout
of the to the layout of

146
00:10:52.670 --> 00:10:56.840 
the activities and of the edges
in the model. So and that brings

147
00:10:56.840 --> 00:11:00.190 
us we come back to these in
the modelling guideline.

148
00:11:00.650 --> 00:11:06.530 
So first of all we should always use
default flow with an exclusive gateway

149
00:11:07.630 --> 00:11:11.350 
and I already mentioned it if
neither condition evaluates to

150
00:11:11.350 --> 00:11:14.800 
true and there is no default flow
the process cannot continue.

151
00:11:15.830 --> 00:11:19.640 
So the previous example if we
had a condition neither condition

152
00:11:19.640 --> 00:11:23.680 
one nor condition two nor condition
three would be evaluated

153
00:11:23.680 --> 00:11:26.630 
to true and we would not have
the default flow the process

154
00:11:26.630 --> 00:11:30.580 
would be stuck there and this
is something we were

155
00:11:31.220 --> 00:11:33.390 
we do not want
to see of course.

156
00:11:34.600 --> 00:11:38.480 
Ok so therefore we need to
have an exclusive default

157
00:11:38.480 --> 00:11:40.060 
flow with the
exclusive gateway.

158
00:11:40.990 --> 00:11:44.080 
In addition if you want to be
sure which path is taken

159
00:11:44.080 --> 00:11:47.470 
in a certain situation you should
make sure that the conditions

160
00:11:47.470 --> 00:11:50.080 
of an exclusive OR gateway
are non overlapping.

161
00:11:50.800 --> 00:11:53.820 
We discussed that also
the previous slides so

162
00:11:54.300 --> 00:11:57.830 
the conditions of exclusive
gateway are non overlapping.

163
00:11:58.390 --> 00:12:02.120 
A nice example of a non overlapping
condition is the

164
00:12:02.120 --> 00:12:05.930 
lower part where we check the
inventory availability and either

165
00:12:05.930 --> 00:12:08.750 
the product is not in stock or
the product is in stock.

166
00:12:09.300 --> 00:12:13.590 
So if you have a boolean variables
can be either true or false

167
00:12:14.070 --> 00:12:17.500 
if it's true it goes that way with false
if it is false it goes the other way.

168
00:12:17.920 --> 00:12:21.620 
That's that's an easy way
and of course the way that

169
00:12:21.630 --> 00:12:25.880 
we see quite often process models
and that is always safe because

170
00:12:25.890 --> 00:12:28.460 
either you go one way or
you go the other way.

171
00:12:28.930 --> 00:12:31.560 
If you have three or more outgoing
edges then you need to be

172
00:12:31.560 --> 00:12:32.490 
a bit more
careful there.

173
00:12:34.950 --> 00:12:39.250 
Let's continue let's let's expand
on the applications scenario

174
00:12:40.620 --> 00:12:44.290 
to introduce additional
concepts. So

175
00:12:45.700 --> 00:12:49.850 
after the product has been manufactured
subsequently the ordered product is

176
00:12:50.000 --> 00:12:52.040 
packaged and shipped
to the customer.

177
00:12:53.050 --> 00:12:56.550 
At the same time invoice is sent
to the customer from whom

178
00:12:56.550 --> 00:12:58.300 
a payment is
received later.

179
00:12:59.050 --> 00:13:02.300 
And once the product has been shipped
successfully and the payment

180
00:13:02.440 --> 00:13:04.950 
has been received the
order can be archived.

181
00:13:06.000 --> 00:13:08.280 
So here we see that

182
00:13:08.990 --> 00:13:15.670 
that there is a at the same time as the at the
same time invoices generated with invoices

183
00:13:16.020 --> 00:13:20.930 
sent to the customer. Here we have
the possibility or it's not

184
00:13:20.930 --> 00:13:23.660 
specified exactly in which order
but it can be at the same

185
00:13:23.660 --> 00:13:28.280 
Time, so it can be concurrently
to the other activity and to

186
00:13:28.280 --> 00:13:33.950 
express concurrency or independence
of execution strands we use them

187
00:13:34.200 --> 00:13:36.490 
and the AND split or
the parallel split.

188
00:13:36.960 --> 00:13:40.560 
In the AND split all outgoing
sequence flow arcs are signaled

189
00:13:40.750 --> 00:13:45.060 
it's not just one selected but all
are select and all are signaled.

190
00:13:45.900 --> 00:13:50.380 
This allows modeling independent
concurrent execution paths.

191
00:13:51.730 --> 00:13:57.030 
So the example we have here
that is a representation

192
00:13:57.030 --> 00:14:00.450 
of what we seen in the text
in the text of the process

193
00:14:01.020 --> 00:14:05.640 
description. So after the product
has been manufactured we

194
00:14:06.100 --> 00:14:09.550 
do two things concurrently - we
can package the product ship

195
00:14:10.530 --> 00:14:13.740 
issue the shipment and concurrently
to that sent the invoice

196
00:14:13.740 --> 00:14:15.200 
and receive payment.

197
00:14:15.810 --> 00:14:18.050 
Only after that happens

198
00:14:18.690 --> 00:14:21.410 
after both had happened we
can archive the order.

199
00:14:22.270 --> 00:14:25.910 
So it is called parallel split
but we need to be a bit careful

200
00:14:25.910 --> 00:14:30.210 
about the term parallel in the
sense that it is not required

201
00:14:30.210 --> 00:14:35.720 
this that the two branches are executed at
the same time so really completely in parallel.

202
00:14:36.380 --> 00:14:41.110 
This means the end splits just
tells that these executions

203
00:14:41.110 --> 00:14:43.750 
are independent from each
other and can progress

204
00:14:44.490 --> 00:14:48.490 
as they like, so they can be they
can be overlapping they can

205
00:14:48.840 --> 00:14:52.230 
the overlaps in time so packaged
product can be done at the

206
00:14:52.230 --> 00:14:55.830 
same time as send the
sending of the invoice

207
00:14:56.440 --> 00:14:59.050 
but it can also be before
that it can be after that.

208
00:14:59.810 --> 00:15:04.100 
However we need to make sure
that the shipment is issued

209
00:15:04.110 --> 00:15:07.940 
only after the product is packaged
and payment of course can

210
00:15:07.940 --> 00:15:11.780 
only be received after the invoice has
been sent. So these constraints are

211
00:15:12.090 --> 00:15:15.940 
we need to make sure that these
constraints are fulfilled but

212
00:15:15.940 --> 00:15:20.820 
other than that, the lower part
of this and the upper

213
00:15:21.140 --> 00:15:25.460 
the lower part
can be executed independently

214
00:15:25.460 --> 00:15:26.090 
from each other.

215
00:15:29.510 --> 00:15:34.560 
Alright let's look at the at the AND join
which is also called a synchronizing join.

216
00:15:34.790 --> 00:15:39.580 
Why it is called a synchronizing
Join? Well because these

217
00:15:40.070 --> 00:15:45.110 
the parallel branches can be
synchronized again, so the

218
00:15:45.110 --> 00:15:50.090 
AND join would only trigger its outgoing
edge if all of the incoming sequence flows

219
00:15:50.280 --> 00:15:53.870 
have been signaled. So in this
case if a packaged product has

220
00:15:53.870 --> 00:15:58.360 
been executed, shipment has been
executed sent invoice and receive

221
00:15:58.760 --> 00:16:02.840 
payment has been executed this is
triggered this edge is triggered

222
00:16:03.020 --> 00:16:08.810 
and only in this case the AND join fires
and joint synchronizes these two

223
00:16:09.100 --> 00:16:13.680 
a branch then then a signals its
outgoing edge so that we can

224
00:16:13.730 --> 00:16:15.560 
then execute
archive order.

225
00:16:17.040 --> 00:16:21.030 
So the end joint synchronizes all
incoming sequence flow arcs

226
00:16:21.870 --> 00:16:25.080 
and only if all incoming sequence
flow arcs have been signaled

227
00:16:25.080 --> 00:16:26.570 
the outgoing
arch is signaled.

228
00:16:29.220 --> 00:16:32.890 
That concludes videoclip 2.3
in which we discussed

229
00:16:33.140 --> 00:16:35.290 
exclusive and
parallel gateways.

230
00:16:35.930 --> 00:16:40.530 
We well took a look at exclusive
gateways and parallel

231
00:16:40.530 --> 00:16:44.970 
Gateways, looked at the syntax and
semantics of these in particular

232
00:16:44.970 --> 00:16:49.230 
the XOR split is quite
interesting execution semantics

233
00:16:49.230 --> 00:16:52.020 
that not everybody
is aware of so I

234
00:16:52.730 --> 00:16:56.600 
think that was quite think its
quite useful to know also this

235
00:16:57.030 --> 00:17:00.910 
part of the semantics of the XOR
split with this and we

236
00:17:00.910 --> 00:17:04.150 
finally discussed the
modelling guidelines.
