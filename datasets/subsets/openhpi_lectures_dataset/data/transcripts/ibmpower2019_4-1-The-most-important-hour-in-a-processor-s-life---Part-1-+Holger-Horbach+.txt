WEBVTT

1
00:00:00.510 --> 00:00:02.249 
Hi, everyone, and welcome to this

2
00:00:02.250 --> 00:00:04.469 
MOOC, its focus

3
00:00:04.470 --> 00:00:06.299 
on the most important hour and a

4
00:00:06.300 --> 00:00:08.219 
processors life and

5
00:00:08.220 --> 00:00:10.139 
I guess this hour this is the amount

6
00:00:10.140 --> 00:00:11.140 
of real time

7
00:00:12.270 --> 00:00:14.129 
that all of the verification efforts

8
00:00:14.130 --> 00:00:16.229 
add up to over the course of a two

9
00:00:16.230 --> 00:00:18.059 
year development cycle of a

10
00:00:18.060 --> 00:00:19.409 
microprocessor.

11
00:00:19.410 --> 00:00:21.239 
My name is Holger Horbach

12
00:00:21.240 --> 00:00:23.789 
and I'll be your guide over the next

13
00:00:23.790 --> 00:00:25.679 
roughly 30 minutes

14
00:00:25.680 --> 00:00:27.839 
to give you a behind the scenes look

15
00:00:27.840 --> 00:00:30.059 
into the development process

16
00:00:30.060 --> 00:00:32.489 
of a modern server processor.

17
00:00:32.490 --> 00:00:34.289 
I hope you had a chance to listen

18
00:00:34.290 --> 00:00:36.779 
into the preceding

19
00:00:36.780 --> 00:00:39.029 
MOOCs and presentations.

20
00:00:39.030 --> 00:00:40.859 
There was one by Wolfgang

21
00:00:40.860 --> 00:00:43.109 
and he talked about the history

22
00:00:43.110 --> 00:00:45.179 
of power based systems

23
00:00:45.180 --> 00:00:47.369 
and the trends and the movements

24
00:00:47.370 --> 00:00:48.899 
in the server market.

25
00:00:48.900 --> 00:00:50.879 
And there was also another

26
00:00:50.880 --> 00:00:52.259 
lecture that I would like to

27
00:00:52.260 --> 00:00:54.224 
recommend that was Arni's

28
00:00:54.225 --> 00:00:56.189 
talk, and he's been diving deep

29
00:00:56.190 --> 00:00:59.279 
into the microprocessor architecture

30
00:00:59.280 --> 00:01:00.729 
of the POWER processor.

31
00:01:00.730 --> 00:01:02.699 
So make sure you take a look at

32
00:01:02.700 --> 00:01:03.700 
this one, too.

33
00:01:04.410 --> 00:01:05.879 
So I'm hoping by now you have

34
00:01:07.080 --> 00:01:08.849 
an understanding of the complexity

35
00:01:08.850 --> 00:01:11.370 
of these modern server processors

36
00:01:12.540 --> 00:01:14.099 
since there's a tremendous amount of

37
00:01:14.100 --> 00:01:16.499 
work that goes into the development

38
00:01:16.500 --> 00:01:18.419 
of these processors

39
00:01:18.420 --> 00:01:20.369 
and into the development of

40
00:01:20.370 --> 00:01:22.739 
every new generation of

41
00:01:22.740 --> 00:01:24.119 
power systems.

42
00:01:24.120 --> 00:01:26.249 
And I'm hoping I can demonstrate

43
00:01:26.250 --> 00:01:27.989 
some of this in the coming minutes.

44
00:01:30.520 --> 00:01:31.929 
So let's start with a couple of raw

45
00:01:31.930 --> 00:01:34.059 
numbers, the

46
00:01:34.060 --> 00:01:36.069 
POWER9 chip is being implemented

47
00:01:36.070 --> 00:01:38.049 
in VHDL and

48
00:01:38.050 --> 00:01:39.939 
actually 10 million or more than 10

49
00:01:39.940 --> 00:01:41.379 
million lines of it.

50
00:01:41.380 --> 00:01:43.299 
So for those of you who

51
00:01:43.300 --> 00:01:45.549 
are not accustomed to the

52
00:01:45.550 --> 00:01:47.709 
server or chip development process,

53
00:01:48.730 --> 00:01:50.589 
the VHDL stands for

54
00:01:50.590 --> 00:01:52.929 
Very large scale

55
00:01:52.930 --> 00:01:54.729 
integration Hardware Descriptive

56
00:01:54.730 --> 00:01:55.689 
Language.

57
00:01:55.690 --> 00:01:57.819 
So it's essentially a programming

58
00:01:57.820 --> 00:01:59.799 
language that hardware

59
00:01:59.800 --> 00:02:01.719 
designers use to

60
00:02:01.720 --> 00:02:03.699 
describe the implementation

61
00:02:03.700 --> 00:02:05.169 
of the components of the chip.

62
00:02:06.370 --> 00:02:08.258 
So this VHDL input is

63
00:02:08.259 --> 00:02:11.079 
then taken and compiled

64
00:02:11.080 --> 00:02:13.839 
and ultimately synthesized into

65
00:02:13.840 --> 00:02:15.339 
the real logic by using an

66
00:02:15.340 --> 00:02:17.319 
appropriate toolset.

67
00:02:17.320 --> 00:02:19.299 
For POWER9, these 10

68
00:02:19.300 --> 00:02:21.669 
million lines of VHDL ultimately

69
00:02:21.670 --> 00:02:23.799 
get synthesized into a chip

70
00:02:23.800 --> 00:02:25.569 
that boasts with about 10 million

71
00:02:25.570 --> 00:02:27.519 
latches and with about

72
00:02:27.520 --> 00:02:30.249 
150 million array cells.

73
00:02:30.250 --> 00:02:31.809 
There's a die photo on the right

74
00:02:31.810 --> 00:02:33.639 
side of this chart and

75
00:02:33.640 --> 00:02:35.319 
you can see how these millions of

76
00:02:35.320 --> 00:02:37.119 
latches are nicely distributed

77
00:02:37.120 --> 00:02:39.759 
across the chip

78
00:02:39.760 --> 00:02:40.749 
for POWER9.

79
00:02:40.750 --> 00:02:43.269 
We're looking at 12 cores

80
00:02:43.270 --> 00:02:45.099 
and I think you can see

81
00:02:45.100 --> 00:02:46.100 
them on a die here.

82
00:02:47.940 --> 00:02:49.619 
So having that said, let's focus

83
00:02:49.620 --> 00:02:51.359 
back on these 10 million lines of

84
00:02:51.360 --> 00:02:52.360 
VHDL.

85
00:02:52.540 --> 00:02:54.849 
Everyone who's written

86
00:02:54.850 --> 00:02:56.889 
code before knows that

87
00:02:56.890 --> 00:02:58.659 
code is bound to be full of bugs.

88
00:03:00.790 --> 00:03:02.949 
In this case, with 10 million lines,

89
00:03:02.950 --> 00:03:04.499 
it's going to be a lot of bugs.

90
00:03:05.890 --> 00:03:07.299 
So.

91
00:03:07.300 --> 00:03:08.649 
I can't really give a precise

92
00:03:08.650 --> 00:03:10.389 
number. These are usually not being

93
00:03:10.390 --> 00:03:12.339 
published, but we can

94
00:03:12.340 --> 00:03:13.869 
safely assume that there's going to

95
00:03:13.870 --> 00:03:15.339 
be a couple of thousand bugs in the

96
00:03:15.340 --> 00:03:17.109 
VHDL here.

97
00:03:17.110 --> 00:03:19.030 
And for obvious reasons,

98
00:03:20.200 --> 00:03:22.029 
these bugs must never, must

99
00:03:22.030 --> 00:03:24.069 
never make their way into

100
00:03:24.070 --> 00:03:25.070 
the

101
00:03:25.990 --> 00:03:26.949 
final chip.

102
00:03:26.950 --> 00:03:28.989 
So when the design data

103
00:03:28.990 --> 00:03:31.119 
gets sent to the fab, the

104
00:03:31.120 --> 00:03:33.309 
silicon fabrication plant,

105
00:03:33.310 --> 00:03:35.199 
we need to be absolutely sure that

106
00:03:35.200 --> 00:03:37.050 
these bugs have been flushed out.

107
00:03:38.650 --> 00:03:40.689 
So the key question here

108
00:03:40.690 --> 00:03:41.690 
really is,

109
00:03:42.820 --> 00:03:44.379 
how do we find all of these bugs?

110
00:03:45.610 --> 00:03:48.549 
And moreover, since

111
00:03:48.550 --> 00:03:50.739 
given the very, very short

112
00:03:50.740 --> 00:03:52.629 
development cycle

113
00:03:52.630 --> 00:03:53.979 
of a processor and we're talking

114
00:03:53.980 --> 00:03:56.249 
about two to three years here,

115
00:03:56.250 --> 00:03:58.089 
the real question really should

116
00:03:58.090 --> 00:03:59.919 
be, how do we find these

117
00:03:59.920 --> 00:04:00.920 
fast?

118
00:04:01.780 --> 00:04:04.119 
And the answer is, well,

119
00:04:04.120 --> 00:04:05.550 
we're going to do hard verification,

120
00:04:06.940 --> 00:04:08.769 
so let's start with a

121
00:04:08.770 --> 00:04:10.599 
quick, simple definition,

122
00:04:10.600 --> 00:04:12.009 
and this is one that I pulled from

123
00:04:12.010 --> 00:04:13.010 
Wikipedia.

124
00:04:14.380 --> 00:04:16.659 
Functional hardware verification

125
00:04:16.660 --> 00:04:18.518 
is the task of verifying that

126
00:04:18.519 --> 00:04:19.699 
a logic is designed to

127
00:04:19.700 --> 00:04:20.700 
specification.

128
00:04:21.959 --> 00:04:24.149 
Sounds pretty boring, I guess

129
00:04:24.150 --> 00:04:26.039 
so I went out looking for,

130
00:04:26.040 --> 00:04:27.149 
I don't know, maybe a little

131
00:04:27.150 --> 00:04:29.069 
catchier definition

132
00:04:29.070 --> 00:04:30.869 
and I like this one much better.

133
00:04:30.870 --> 00:04:33.419 
So this one says, verification

134
00:04:33.420 --> 00:04:35.399 
is the nemesis and nightmare of

135
00:04:35.400 --> 00:04:37.359 
every hardware design, the cool

136
00:04:37.360 --> 00:04:38.999 
the features in the hardware device,

137
00:04:39.000 --> 00:04:40.889 
the harder it is to verify

138
00:04:40.890 --> 00:04:42.569 
there are no shortcuts here.

139
00:04:42.570 --> 00:04:44.609 
Every design is a new beast.

140
00:04:44.610 --> 00:04:46.139 
It is difficult to scale

141
00:04:46.140 --> 00:04:47.699 
intellectually challenging and

142
00:04:47.700 --> 00:04:49.709 
computationally among the hardest

143
00:04:49.710 --> 00:04:51.239 
known problems.

144
00:04:51.240 --> 00:04:52.889 
So this makes it so much cooler.

145
00:04:55.050 --> 00:04:56.050 
And

146
00:04:57.130 --> 00:04:58.749 
I'm going to spend the next couple

147
00:04:58.750 --> 00:05:00.799 
of minutes explaining what

148
00:05:00.800 --> 00:05:02.619 
this hardware verification is all

149
00:05:02.620 --> 00:05:03.620 
about.

150
00:05:04.930 --> 00:05:06.759 
So let's go over some of the

151
00:05:06.760 --> 00:05:08.859 
basic principles first

152
00:05:08.860 --> 00:05:10.719 
before we then focus more on the

153
00:05:10.720 --> 00:05:12.609 
specific challenges that we

154
00:05:12.610 --> 00:05:13.610 
encountered for POWER9.

155
00:05:15.130 --> 00:05:16.899 
OK, let's take a closer look at

156
00:05:16.900 --> 00:05:18.999 
these bugs I keep talking about.

157
00:05:19.000 --> 00:05:20.409 
What is it we're really trying to

158
00:05:20.410 --> 00:05:21.410 
find?

159
00:05:22.030 --> 00:05:24.039 
I'll just try to name a few of them

160
00:05:24.040 --> 00:05:25.509 
at this point.

161
00:05:25.510 --> 00:05:27.009 
The first category is the

162
00:05:27.010 --> 00:05:28.149 
manufacturing bugs.

163
00:05:28.150 --> 00:05:30.039 
So these are the ones that are

164
00:05:30.040 --> 00:05:31.299 
being introduced during the

165
00:05:31.300 --> 00:05:33.909 
manufacturing process.

166
00:05:33.910 --> 00:05:35.289 
This is fairly common and happens

167
00:05:35.290 --> 00:05:36.249 
often.

168
00:05:36.250 --> 00:05:38.049 
The fabrication process is very

169
00:05:38.050 --> 00:05:39.999 
complicated, especially when

170
00:05:40.000 --> 00:05:41.829 
a new technology is first

171
00:05:41.830 --> 00:05:43.419 
being applied.

172
00:05:43.420 --> 00:05:45.309 
To protect ourselves from these

173
00:05:45.310 --> 00:05:47.169 
bugs, a significant

174
00:05:47.170 --> 00:05:49.059 
amount of work is being spent and

175
00:05:49.060 --> 00:05:51.099 
a significant amount of logic is

176
00:05:51.100 --> 00:05:53.319 
actually being put onto

177
00:05:53.320 --> 00:05:54.609 
the chip.

178
00:05:54.610 --> 00:05:56.469 
This logic, what we call

179
00:05:56.470 --> 00:05:58.419 
the BIST engines, the built in

180
00:05:58.420 --> 00:06:00.489 
self-test engines,

181
00:06:00.490 --> 00:06:03.189 
and by running those, we can detect

182
00:06:03.190 --> 00:06:05.109 
that something in the chip

183
00:06:05.110 --> 00:06:07.299 
has gone corrupted.

184
00:06:07.300 --> 00:06:09.159 
When talking about

185
00:06:09.160 --> 00:06:10.449 
manufacturing bugs.

186
00:06:11.900 --> 00:06:14.299 
There's a separate domain

187
00:06:14.300 --> 00:06:16.099 
that worries about these, this is

188
00:06:16.100 --> 00:06:17.989 
called a post silicon validation

189
00:06:17.990 --> 00:06:19.910 
rather than hardware verification.

190
00:06:21.320 --> 00:06:23.299 
The second category of problems

191
00:06:23.300 --> 00:06:24.619 
that we're trying to find is related

192
00:06:24.620 --> 00:06:25.909 
to timing.

193
00:06:25.910 --> 00:06:28.099 
So the time bug will always

194
00:06:28.100 --> 00:06:30.019 
happen if a

195
00:06:30.020 --> 00:06:32.179 
signal cannot make

196
00:06:32.180 --> 00:06:34.069 
its way from a source

197
00:06:34.070 --> 00:06:36.679 
to its destination in the given

198
00:06:36.680 --> 00:06:37.999 
cycle time.

199
00:06:38.000 --> 00:06:39.709 
This means a signal will arrive too

200
00:06:39.710 --> 00:06:41.899 
late, producing corrupted

201
00:06:41.900 --> 00:06:43.130 
results within the chip.

202
00:06:44.440 --> 00:06:45.759 
Again, for this field, there's a

203
00:06:45.760 --> 00:06:47.619 
separate domain that worries

204
00:06:47.620 --> 00:06:48.819 
about this, it's called timing

205
00:06:48.820 --> 00:06:50.679 
verification, and we won't be

206
00:06:50.680 --> 00:06:52.599 
going into details on this during

207
00:06:52.600 --> 00:06:53.600 
this lecture.

208
00:06:54.370 --> 00:06:55.420 
Now, let's get to the

209
00:06:56.590 --> 00:06:58.089 
actual functional bugs.

210
00:06:59.380 --> 00:07:01.689 
There's a simple logic bug that

211
00:07:01.690 --> 00:07:03.039 
really means the logic has

212
00:07:03.040 --> 00:07:04.209 
implementation errors.

213
00:07:04.210 --> 00:07:05.210 
The logic designer

214
00:07:06.220 --> 00:07:08.289 
has not implemented

215
00:07:08.290 --> 00:07:10.389 
an algorithm correctly.

216
00:07:10.390 --> 00:07:12.489 
And I've got two examples

217
00:07:12.490 --> 00:07:13.779 
here.

218
00:07:13.780 --> 00:07:15.609 
One of them is you can imagine we're

219
00:07:15.610 --> 00:07:17.469 
writing to a register that

220
00:07:17.470 --> 00:07:19.599 
has a couple of bits in width

221
00:07:19.600 --> 00:07:21.729 
and the logic

222
00:07:21.730 --> 00:07:23.619 
designer forgot to connect

223
00:07:23.620 --> 00:07:25.389 
a certain bit of the access bus.

224
00:07:25.390 --> 00:07:27.249 
So there's a certain bit that

225
00:07:27.250 --> 00:07:29.139 
we simply cannot write to.

226
00:07:29.140 --> 00:07:30.999 
Another example would be if we're

227
00:07:31.000 --> 00:07:32.829 
trying to write an array

228
00:07:32.830 --> 00:07:34.509 
and the access only works for the

229
00:07:34.510 --> 00:07:36.339 
first 63 out of the

230
00:07:36.340 --> 00:07:37.340 
64 rows.

231
00:07:38.110 --> 00:07:40.059 
These bugs we call the low

232
00:07:40.060 --> 00:07:42.009 
hanging fruits, because

233
00:07:42.010 --> 00:07:43.869 
they're the ones that are easy to

234
00:07:43.870 --> 00:07:45.759 
find and

235
00:07:45.760 --> 00:07:47.829 
easy to get to, the

236
00:07:47.830 --> 00:07:50.139 
really interesting bugs are the

237
00:07:50.140 --> 00:07:52.209 
more complex logic bugs that only

238
00:07:52.210 --> 00:07:54.099 
happen when there's concurrent

239
00:07:54.100 --> 00:07:55.899 
actions going on in the logic

240
00:07:56.920 --> 00:07:58.989 
or there's some deep sequential

241
00:07:58.990 --> 00:08:00.849 
operation that requires us

242
00:08:00.850 --> 00:08:02.919 
to have the correct operations

243
00:08:02.920 --> 00:08:04.989 
in a certain sequence to actually

244
00:08:04.990 --> 00:08:06.309 
hit this bug.

245
00:08:06.310 --> 00:08:08.859 
So these are the bugs that the

246
00:08:08.860 --> 00:08:10.839 
verification engineers drive to go

247
00:08:10.840 --> 00:08:12.759 
after. These are the ones that that

248
00:08:12.760 --> 00:08:15.699 
that we really want to find.

249
00:08:15.700 --> 00:08:18.129 
There's one last category of bugs.

250
00:08:18.130 --> 00:08:20.229 
It's a performance bugs.

251
00:08:20.230 --> 00:08:21.549 
They're usually also pretty hard to

252
00:08:21.550 --> 00:08:23.469 
find because they will not

253
00:08:23.470 --> 00:08:25.149 
ultimately manifest themselves in a

254
00:08:25.150 --> 00:08:28.299 
functional error, meaning the logic

255
00:08:28.300 --> 00:08:29.349 
behaves according to its

256
00:08:29.350 --> 00:08:31.299 
specification, but it

257
00:08:31.300 --> 00:08:32.529 
doesn't perform in the way it's

258
00:08:32.530 --> 00:08:34.158 
supposed to.

259
00:08:34.159 --> 00:08:35.359 
Usually we need dedicated

260
00:08:35.360 --> 00:08:37.158 
verification efforts to actually

261
00:08:37.159 --> 00:08:38.510 
find these problems to.

262
00:08:40.740 --> 00:08:42.749 
So for the remainder

263
00:08:42.750 --> 00:08:44.579 
of this lecture,

264
00:08:45.720 --> 00:08:47.699 
we will start looking more into

265
00:08:47.700 --> 00:08:50.699 
the area of functional verification.

266
00:08:50.700 --> 00:08:51.899 
We now understand what type of

267
00:08:51.900 --> 00:08:53.849 
problems we're going after, and

268
00:08:53.850 --> 00:08:55.139 
I want to spend the next few minutes

269
00:08:55.140 --> 00:08:57.089 
to understand how

270
00:08:57.090 --> 00:08:58.949 
these problems can actually

271
00:08:58.950 --> 00:08:59.950 
be found.

272
00:09:00.450 --> 00:09:01.679 
Let's take a look at the basic

273
00:09:01.680 --> 00:09:02.909 
structure of a functional

274
00:09:02.910 --> 00:09:04.769 
verification environment.

275
00:09:04.770 --> 00:09:06.689 
The basic principle is always

276
00:09:06.690 --> 00:09:07.690 
the same.

277
00:09:08.320 --> 00:09:09.879 
A reference model needs to be

278
00:09:09.880 --> 00:09:11.889 
created that implements

279
00:09:11.890 --> 00:09:14.019 
the specification and that behaves

280
00:09:14.020 --> 00:09:16.419 
the way the design under test,

281
00:09:16.420 --> 00:09:17.420 
we call it DUT,

282
00:09:18.760 --> 00:09:21.249 
the way the DUT behaves, too.

283
00:09:21.250 --> 00:09:23.139 
So the reference model should always

284
00:09:23.140 --> 00:09:24.429 
be implemented at an abstraction

285
00:09:24.430 --> 00:09:26.409 
level that is much higher

286
00:09:26.410 --> 00:09:28.599 
than the actual design under test.

287
00:09:28.600 --> 00:09:30.429 
And it should really only model

288
00:09:30.430 --> 00:09:32.409 
these aspects that

289
00:09:32.410 --> 00:09:34.599 
we ultimately want to check.

290
00:09:34.600 --> 00:09:36.429 
So, for example, unless the

291
00:09:36.430 --> 00:09:38.469 
specification,

292
00:09:38.470 --> 00:09:40.869 
this specific timing requirements,

293
00:09:40.870 --> 00:09:43.149 
there's no need to create a cycle

294
00:09:43.150 --> 00:09:45.279 
accurate reference model

295
00:09:45.280 --> 00:09:47.409 
that attempts to

296
00:09:47.410 --> 00:09:49.239 
predict the precise

297
00:09:49.240 --> 00:09:51.249 
timing on the interface.

298
00:09:51.250 --> 00:09:53.259 
It's much more efficient

299
00:09:53.260 --> 00:09:55.149 
to implement the reference

300
00:09:55.150 --> 00:09:57.399 
model, say, at a transaction

301
00:09:57.400 --> 00:09:58.629 
level.

302
00:09:58.630 --> 00:10:00.909 
So the basic idea is

303
00:10:00.910 --> 00:10:02.859 
to make the

304
00:10:02.860 --> 00:10:04.389 
reference model much simpler than

305
00:10:04.390 --> 00:10:06.129 
the real implementation, also to

306
00:10:06.130 --> 00:10:08.019 
prevent us from

307
00:10:08.020 --> 00:10:09.609 
inserting bugs into the reference

308
00:10:09.610 --> 00:10:11.019 
model, because suddenly it's as

309
00:10:11.020 --> 00:10:13.599 
complex as the design under test.

310
00:10:13.600 --> 00:10:16.089 
So once we have this reference model

311
00:10:16.090 --> 00:10:17.409 
and we have the DUT, we need to

312
00:10:17.410 --> 00:10:18.969 
start worrying about what it is that

313
00:10:18.970 --> 00:10:21.189 
we put into

314
00:10:21.190 --> 00:10:22.299 
these two.

315
00:10:22.300 --> 00:10:23.799 
So we need some kind of test

316
00:10:23.800 --> 00:10:26.529 
pattern, some kind of input stimulus

317
00:10:26.530 --> 00:10:28.029 
to feed into both of these

318
00:10:28.030 --> 00:10:29.030 
components.

319
00:10:30.290 --> 00:10:32.809 
The question is, how are these

320
00:10:32.810 --> 00:10:34.429 
inputs stimuli, how are these test

321
00:10:34.430 --> 00:10:36.109 
patterns actually applied to the

322
00:10:36.110 --> 00:10:37.249 
device under test?

323
00:10:37.250 --> 00:10:39.349 
And to do this, we need to use

324
00:10:39.350 --> 00:10:41.179 
a tool called a

325
00:10:41.180 --> 00:10:42.180 
simulator.

326
00:10:43.010 --> 00:10:45.109 
So the simulator will receive

327
00:10:45.110 --> 00:10:47.029 
a compiled version

328
00:10:47.030 --> 00:10:48.949 
of the logic and then

329
00:10:48.950 --> 00:10:51.049 
elaborated model,

330
00:10:51.050 --> 00:10:53.419 
and it will provide

331
00:10:53.420 --> 00:10:55.459 
access to this

332
00:10:55.460 --> 00:10:57.439 
device under test to its

333
00:10:57.440 --> 00:10:59.359 
internal and external signals.

334
00:10:59.360 --> 00:11:01.159 
We call those facilities.

335
00:11:01.160 --> 00:11:02.599 
It will also perform the task of

336
00:11:02.600 --> 00:11:05.179 
advancing time and clocking

337
00:11:05.180 --> 00:11:06.679 
the model. It will calculate the

338
00:11:06.680 --> 00:11:08.719 
next state of the model once

339
00:11:08.720 --> 00:11:10.759 
the input stimuli have been applied.

340
00:11:11.800 --> 00:11:13.450 
So coming back to the test pattern.

341
00:11:15.020 --> 00:11:16.609 
The simulator will now apply this to

342
00:11:16.610 --> 00:11:18.439 
the device and test it will

343
00:11:18.440 --> 00:11:20.479 
calculate the next state,

344
00:11:20.480 --> 00:11:21.919 
but we can also apply the test

345
00:11:21.920 --> 00:11:23.989 
pattern to the reference model and

346
00:11:23.990 --> 00:11:26.029 
this will calculate the next

347
00:11:26.030 --> 00:11:28.399 
expected value for us.

348
00:11:28.400 --> 00:11:30.439 
So at the end, the final step really

349
00:11:30.440 --> 00:11:32.449 
is just to compare

350
00:11:32.450 --> 00:11:34.459 
the results of these two.

351
00:11:34.460 --> 00:11:36.439 
If the results match, great.

352
00:11:36.440 --> 00:11:37.789 
Looks like the device under test

353
00:11:37.790 --> 00:11:40.039 
does what it's supposed to be doing.

354
00:11:40.040 --> 00:11:42.199 
If the results do not match,

355
00:11:42.200 --> 00:11:44.149 
the question really is do we have

356
00:11:44.150 --> 00:11:46.429 
a problem in the device under test?

357
00:11:46.430 --> 00:11:48.169 
If yes, we'll send it over to the

358
00:11:48.170 --> 00:11:50.419 
logic designer for updating

359
00:11:50.420 --> 00:11:51.529 
and fixing.

360
00:11:51.530 --> 00:11:53.659 
If no, maybe the problem

361
00:11:53.660 --> 00:11:54.529 
is in the reference model.

362
00:11:54.530 --> 00:11:56.449 
In this case, it's up for the

363
00:11:56.450 --> 00:11:58.779 
verification engineer to fix.

364
00:11:58.780 --> 00:12:00.709 
I guess there's a third case.

365
00:12:00.710 --> 00:12:02.629 
It could be that the test pattern

366
00:12:02.630 --> 00:12:04.159 
was illegal and was trying to

367
00:12:04.160 --> 00:12:06.079 
operate design under tests

368
00:12:06.080 --> 00:12:07.669 
out of specification.

369
00:12:07.670 --> 00:12:09.739 
So in this last case,

370
00:12:09.740 --> 00:12:11.209 
we will ultimately just have to

371
00:12:11.210 --> 00:12:12.349 
change the test pattern.

372
00:12:13.910 --> 00:12:16.699 
So this is the basic structure

373
00:12:16.700 --> 00:12:18.319 
of a functional verification

374
00:12:18.320 --> 00:12:19.459 
environment. Unfortunately, we're

375
00:12:19.460 --> 00:12:21.199 
not going to have the time to really

376
00:12:21.200 --> 00:12:22.729 
go into more details about the

377
00:12:22.730 --> 00:12:24.349 
actual architecture of such an

378
00:12:24.350 --> 00:12:25.789 
environment.

379
00:12:25.790 --> 00:12:27.379 
And we won't really be able to look

380
00:12:27.380 --> 00:12:28.519 
at the different verification

381
00:12:28.520 --> 00:12:29.899 
methodologies.

382
00:12:29.900 --> 00:12:31.729 
But I'll still try to give us

383
00:12:31.730 --> 00:12:32.730 
a quick glimpse.

384
00:12:34.280 --> 00:12:35.959 
The verification methodology is

385
00:12:35.960 --> 00:12:37.879 
really different, mostly in

386
00:12:37.880 --> 00:12:39.709 
a few of these aspects

387
00:12:39.710 --> 00:12:40.489 
here.

388
00:12:40.490 --> 00:12:42.349 
So one question is, how is the

389
00:12:42.350 --> 00:12:44.039 
test pattern generated?

390
00:12:45.080 --> 00:12:46.309 
The simplest and most

391
00:12:46.310 --> 00:12:48.649 
straightforward methodology

392
00:12:48.650 --> 00:12:49.929 
would be just to create a directed

393
00:12:49.930 --> 00:12:51.019 
test.

394
00:12:51.020 --> 00:12:53.149 
So that's a manual test coded

395
00:12:53.150 --> 00:12:54.404 
by a verification engineer

396
00:12:56.060 --> 00:12:58.039 
and being

397
00:12:58.040 --> 00:13:00.529 
fed into the system.

398
00:13:00.530 --> 00:13:01.789 
It can also be automatically

399
00:13:01.790 --> 00:13:03.889 
generated by a test case generator

400
00:13:03.890 --> 00:13:05.749 
or some other means.

401
00:13:05.750 --> 00:13:07.459 
So these directed tests, they're

402
00:13:07.460 --> 00:13:09.409 
usually used during

403
00:13:09.410 --> 00:13:10.819 
the early phases of the development

404
00:13:10.820 --> 00:13:12.979 
cycle on the device under test

405
00:13:12.980 --> 00:13:14.269 
and the verification environment are

406
00:13:14.270 --> 00:13:15.949 
still in the bring up phase.

407
00:13:17.650 --> 00:13:19.569 
But they also serve the purpose

408
00:13:19.570 --> 00:13:21.129 
if we have a very, very specific

409
00:13:21.130 --> 00:13:23.259 
scenario that we know

410
00:13:23.260 --> 00:13:24.879 
may be problematic and that we

411
00:13:24.880 --> 00:13:26.949 
ultimately want to go after.

412
00:13:26.950 --> 00:13:28.119 
So once the environment is up and

413
00:13:28.120 --> 00:13:30.249 
running and the initial problems

414
00:13:30.250 --> 00:13:32.139 
have been flushed out,

415
00:13:32.140 --> 00:13:33.909 
we will usually want to switch to

416
00:13:33.910 --> 00:13:36.077 
something less manual

417
00:13:37.790 --> 00:13:39.799 
to increase what we call

418
00:13:39.800 --> 00:13:41.899 
verification coverage.

419
00:13:41.900 --> 00:13:43.669 
So the verification coverage is a

420
00:13:43.670 --> 00:13:45.739 
measure of how much of the device

421
00:13:45.740 --> 00:13:47.659 
under tests, functions and

422
00:13:47.660 --> 00:13:49.520 
states we have exercised.

423
00:13:50.630 --> 00:13:52.759 
So, well, we want to increase

424
00:13:52.760 --> 00:13:54.109 
coverage, we want to get away from

425
00:13:54.110 --> 00:13:56.329 
manual test cases, so one

426
00:13:56.330 --> 00:13:58.309 
very popular method to do this

427
00:13:58.310 --> 00:14:00.979 
is random generation.

428
00:14:00.980 --> 00:14:03.349 
So the test pattern will be

429
00:14:03.350 --> 00:14:04.609 
will no longer be directed.

430
00:14:04.610 --> 00:14:06.559 
It will be randomized

431
00:14:06.560 --> 00:14:07.682 
and since,

432
00:14:09.070 --> 00:14:10.929 
by randomizing the test

433
00:14:10.930 --> 00:14:13.239 
pattern and by randomizing

434
00:14:13.240 --> 00:14:14.240 
the input stimuli,

435
00:14:15.270 --> 00:14:17.159 
we can't freely choose what

436
00:14:17.160 --> 00:14:18.160 
we do.

437
00:14:18.630 --> 00:14:20.579 
In many situations, we

438
00:14:20.580 --> 00:14:22.379 
will probably come to some kind of

439
00:14:22.380 --> 00:14:23.579 
illegal input.

440
00:14:23.580 --> 00:14:24.659 
So we need to make sure that the

441
00:14:24.660 --> 00:14:26.039 
test patterns we generate are

442
00:14:26.040 --> 00:14:27.869 
actually legal test patterns, and

443
00:14:27.870 --> 00:14:29.729 
we need to constrain the randomness

444
00:14:29.730 --> 00:14:30.989 
that is applied to these test

445
00:14:30.990 --> 00:14:32.189 
patterns.

446
00:14:32.190 --> 00:14:34.409 
This is also why a random

447
00:14:34.410 --> 00:14:36.269 
verification methodology is usually

448
00:14:36.270 --> 00:14:38.309 
called a constraint random

449
00:14:38.310 --> 00:14:39.810 
verification methodology.

450
00:14:41.330 --> 00:14:43.699 
So you can imagine that randomizing

451
00:14:43.700 --> 00:14:45.769 
the input patterns that combines

452
00:14:45.770 --> 00:14:47.719 
a lot of additional coverage.

453
00:14:47.720 --> 00:14:50.179 
So when it's done right,

454
00:14:50.180 --> 00:14:52.849 
we will ultimately end up gaining

455
00:14:52.850 --> 00:14:54.409 
or exploring much more of the

456
00:14:54.410 --> 00:14:56.359 
state's base that the designer

457
00:14:56.360 --> 00:14:58.309 
test offers then

458
00:14:58.310 --> 00:15:00.319 
with just a set of purely

459
00:15:00.320 --> 00:15:01.320 
directed tests.
